{"id": "flGGRc", "name": "the flag of Romania - 005", "author": "catafest", "description": "the flag of Romania with wind effect ... \nhttps://en.wikipedia.org/wiki/Flag_of_Romania", "tags": ["flag", "romania", "catafest"], "likes": 0, "viewed": 193, "published": 3, "date": "1638311751", "time_retrieved": "2024-07-30T18:45:00.356632", "image_code": "// this create a rectangle, from uv and size\nfloat rectangle (vec2 uv, float size) {\n\tvec2 s = abs(uv) - vec2(size);\n    float Patrat = length(max(s, .0));\n    Patrat = smoothstep(.001, .0, Patrat);\n    return Patrat;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // all colors\n    vec3 col = vec3(0.0);    // background black \n    vec3 blue = vec3(0.0, 0.0, 1.0); // blue flag\n    vec3 yellow = vec3(1.0, 1.0, 0.0); // yellow flag\n    vec3 red = vec3(1.0, 0.0, 0.0); // red flag\n\n    // get uv area \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    // set a new area for draw \n    vec2 new_uv = uv;\n\n\n    // create a flagpole \n    uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    new_uv = uv;\n    new_uv.x += .335;\n    float flagpole = smoothstep(.0176, .0155, length(new_uv.x));\n    col += flagpole;\n\n    // translation of uv to the left area of flagpole\n    uv.y -= .0;\n    uv.x -= -.321;\n \n    //create animation with color \n    float windColor= .1;\n    \n    // wind effect\n    new_uv.x = uv.x;\n    new_uv.x += -1.0-sin(-iTime);\n    \n    float mod = smoothstep(0.9, 0.0, length(abs(new_uv.x+(new_uv.y*-.5))));\n    \n    // shadow wind\n    uv.y += mod * 0.1;\n    col -= mod * windColor;\n    \n    // up and down flag \n    uv.y +=0.18 * sin(-0.11 * (iTime))/mod*mod;\n    col -= mod*windColor;\n\n    // flag created with the new UV and Patrat \n    new_uv = uv;\n    new_uv.x *= .55;\n    float base = rectangle(new_uv, .3);\n\n    float flag_X = new_uv.x;\n    float flag_Y = new_uv.y* base;\n    \n\n    if (flag_X > 0.0 && flag_X < 0.6  && flag_Y > 0.0) \n    { \t\t       \n\t\tfloat size = 3.0;\n\t\tif (flag_X < 0.33 / size) \n\t\t{\n\t\t\t// Output to screen fill the screen with blue\n\t\t\t//fragColor = vec4(0,0,1,0);\n            col = blue;\n            \t\n\t\t} else if (flag_X < 0.6 / size) {     \n\t\t\t// fill the 2/3 of size with yellow color\n\t\t\tcol = yellow;\n        \t    \n\t\t} else if (flag_X < 0.9 / size) {\n   \n\t\t\t// fill the last 1/3 with the red color \n\t\t\tcol=red;\n\t\t}\n    }\n  \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flGGRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 45, 84, 84, 219], [221, 221, 278, 296, 2031]], "test": "untested"}
{"id": "NtyGWV", "name": "2d bezier test", "author": "jorge2017a2", "description": "2d bezier test", "tags": ["2dbeziertest"], "likes": 6, "viewed": 219, "published": 3, "date": "1638306386", "time_retrieved": "2024-07-30T18:45:01.522516", "image_code": "//por jorge2017a2\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(8.0*antialiasing(0.85),b,d)\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  //colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj-0.05,0.0));\nreturn colOut;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{  vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{   p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\nfloat ellipse(vec2 p, vec2 focus0, vec2 focus1, float radius) \n{  return distance(p, focus0) + distance(p, focus1) - distance(focus0, focus1) * radius;}\n\nfloat ondas(vec2 p)\n{  float si = (sin(iTime + 1.0 * 1.05))/0.3;\n\tfloat co = acos(cos(iTime + 1.0 * 0.5))*0.2;\n    float res=abs(length(p+vec2(si*0.5,co))- 0.2);\n    return res;\n}\n\nfloat diente(vec2 p, vec2 pbx)\n{ float d1= sdCircle(p-vec2(0.0,0.0), 0.5 );\n    float d2= sdCircle(p-vec2(0.2,-0.35),0.5 );\n    float d3=sdBox(p-pbx, vec2(0.65,0.5) );    \n    float dif1= differenceSDF(d1, d2);\n    dif1= differenceSDF(dif1, d3);\n    return dif1;\n}\n\nvec3 MarOnda(vec2 uv,vec3 colOut, vec3 colIn, float t )\n{   float d1=uv.y + sin(uv.x*5.+t)*0.1;\n    colOut= DrawFig(colIn, colOut,d1);\n    return colOut;\n}\n\nvec3 Montana(vec2 uv,vec3 colOut, vec3 colIn )\n{   float d1=-0.2+uv.y + sin(uv.x*6.+10.5*cos(uv.y*1.5+0.25*fract(iTime)))*0.32;\n    colOut= DrawFigBorde(colIn, colOut,d1);\n    return colOut;\n}\n\nvec3 fantasma(vec2 p, vec3 col)\n{  float r1=1.0;\n    float r2=0.8;\n    float h=1.2;\n     \n    float d1= sdUnevenCapsule( p,r1,r2,h);\n    float d2=sdBox(p-vec2(0.0,-0.6),vec2(1.2,0.5) );\n    d1= differenceSDF(d1, d2);\n    \n    float sn=0.5*sin(iTime*2.0);\n    //ojo derecho\n    float radiusA=1.3;\n    float radiusB=1.2;\n    vec2 focus0A=vec2(-0.3,0.0);\n    vec2 focus1A=vec2(0.0,0.3);\n    float d3a= ellipse(p-vec2(0.5+sn*0.15,1.0),focus0A,focus1A,radiusA);\n    float d3b= ellipse(p-vec2(0.5,1.0),focus0A,focus1A,radiusB);\n    \n    //ojo izq\n    vec2 focus0B=vec2(0.3,0.0);\n    vec2 focus1B=vec2(0.0,0.3);\n    float d4a= ellipse(p-vec2(-0.5+sn*0.15,1.0),focus0B,focus1B,radiusA);\n    float d4b= ellipse(p-vec2(-0.5,1.0),focus0B,focus1B,radiusB);\n    \n    //iris\n    float d5a= sdCircle(p-vec2(0.4+sn*0.15,1.1), 0.02 );\n    float d5b= sdCircle(p-vec2(-0.4+sn*0.15,1.1), 0.02 );\n    \n    //dientes\n    vec2 p0=p;\n    p*=0.8;\n    p.x=abs(p.x)-0.1;\n    p.y*=0.55;\n    float d6a=diente( vec2(-p.x,p.y)-vec2(0.0,0.425+abs(sn)*0.125), vec2(0.0,0.3));\n    p=p0;\n    float d6b=diente(p-vec2(0.0,0.87), vec2(0.0,0.3));\n    float d6c=diente(p-vec2(0.2,0.87), vec2(0.0,0.3));\n    float d6d=diente(vec2(-p.x,p.y)-vec2(0.0,0.87), vec2(0.0,0.3));\n    float d6e=diente(vec2(-p.x,p.y)-vec2(0.2,0.87), vec2(0.0,0.3));\n    \n    //boca\n    float d7= sdCircle(p*vec2(0.3,1.2)-vec2(0.0,0.65), 0.2 );\n    \n    \n    //brazo izq\n    vec2 v0A = vec2(-0.8,0.9);\n    vec2 v1A = vec2(-1.3,0.9);\n    vec2 v2A = vec2(-0.5*sn-1.0,-0.3);\n    float b1 =abs( sdBezier( p, v0A,v1A,v2A ))-0.08; \n    \n    //brazo der\n    vec2 v0B = vec2(0.5,0.9);\n    vec2 v1B = vec2(1.3,0.5);\n    vec2 v2B = vec2(1.4+0.5*sn,1.8);\n    float b2 =abs( sdBezier( p-vec2(0.3,0.2), v0B,v1B,v2B ))-0.08; \n    ///zapato\n    float d8a= sdCircle(p.yx*vec2(0.5,-1.2)-vec2(0.0,-0.65), 0.25 );\n    float d8b= sdCircle(p.yx*vec2(0.5,-1.2)-vec2(0.0,0.65), 0.25 );\n    \n    //cuernos\n    p*=0.8;\n    p.x=abs(p.x)+0.2;\n    p.y*=0.55;\n    float d9a=diente( vec2(-p.x,-p.y)*0.5-vec2(0.0,-0.2), vec2(0.0,0.3));\n    \n    col= DrawFigBordeCol(vec3(0.0,0.0,0.0), col, d9a,vec3(1.0));\n    col= DrawFigBordeCol(vec3(0.0,0.0,0.0), col, d8a,vec3(1.0));\n    col= DrawFigBordeCol(vec3(0.0,0.0,0.0), col, d8b, vec3(1.0) );\n    col= DrawFigBorde(vec3(0.95,0.6,0.0), col, d1 );\n    col= DrawFig(vec3(0.0,0.0,0.0), col, d3a );\n    col= DrawFig(vec3(1.0,0.2,0.0), col, d3b );\n    col= DrawFig(vec3(0.0,0.0,0.0), col, d4a );\n    col= DrawFig(vec3(1.0,0.2,0.0), col, d4b );\n    col= DrawFig(vec3(1.0)*sin(iTime), col, d5a ); //iris\n    col= DrawFig(vec3(1.0)*sin(iTime), col, d5b ); //iris\n    col= DrawFigBorde(vec3(0.0,0.0,0.0), col, d7 );\n    //dientes\n    col= DrawFigBorde(vec3(1.0), col, d6a );\n    col= DrawFigBorde(vec3(1.0), col, d6b );\n    col= DrawFigBorde(vec3(1.0), col, d6c );\n    col= DrawFigBorde(vec3(1.0), col, d6d );\n    col= DrawFigBorde(vec3(1.0), col, d6e );\n    col= DrawFigBorde(vec3(0.5,1.0,0.0), col, b1 );\n    col= DrawFigBorde(vec3(0.5,1.0,0.0), col, b2 );\n\n    return col;\n}\n\nfloat Anillo(vec2 p)\n{  float si = (sin(iTime + 1.0 * 1.05))/0.3;\n\tfloat co = acos(cos(iTime + 1.0 * 0.5))*0.2;\n    float res=abs(length(p+vec2(si*0.5,co))- 0.2);\n    return res;\n}\n\n// Tone mapping\n\n// See: http://filmicgames.com/archives/75\nvec3 Uncharted2ToneMapping(vec3 color)\n{   float gamma = 2.2;\n\tfloat A = 0.15;\n\tfloat B = 0.50;\n\tfloat C = 0.10;\n\tfloat D = 0.20;\n\tfloat E = 0.02;\n\tfloat F = 0.30;\n\tfloat W = 11.2;\n\tfloat exposure = 0.012;\n\tcolor *= exposure;\n\tcolor = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;\n\tfloat white = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;\n\tcolor /= white;\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,-0.5);\n    float esc=2.0;\n    uv*=esc;\n    float t=iTime;\n\n    vec3  col=vec3(0.45,0.7,1.0)-uv.y*0.5/esc;\n    col= Montana(uv-vec2(0.0,0.5),col, vec3(0.8,0.3,0.0));\n    col= MarOnda(uv,col, vec3(0.0,0.0,0.75), t*3.0);\n    \n    col= fantasma(uv,col);\n    float d1= Anillo(uv);\n    col= DrawFig(vec3(1.0,0.2,0.0), col,d1);\n    col+=1.2*Uncharted2ToneMapping(col);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "//https://www.shadertoy.com/view/MlKcDD\n//referencia Iq\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n\n// signed distance to a quadratic bezier\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n    float sgn = 0.0;\n\n    float p  = ky - kx*kx;\n    float q  = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float p3 = p*p*p;\n    float q2 = q*q;\n    float h  = q2 + 4.0*p3;\n\n    if( h>=0.0 ) \n    {   // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n\n        #if 0\n        // When p≈0 and p<0, h-q has catastrophic cancelation. So, we do\n        // h=√(q²+4p³)=q·√(1+4p³/q²)=q·√(1+w) instead. Now we approximate\n        // √ by a linear Taylor expansion into h≈q(1+½w) so that the q's\n        // cancel each other in h-q. Expanding and simplifying further we\n        // get x=vec2(p³/q,-p³/q-q). And using a second degree Taylor\n        // expansion instead: x=vec2(k,-k-q) with k=(1-p³/q²)·p³/q\n        if( abs(p)<0.001 )\n        {\n            float k = p3/q;              // linear approx\n          //float k = (1.0-p3/q2)*p3/q;  // quadratic approx \n            x = vec2(k,-k-q);  \n        }\n        #endif\n\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        vec2  q = d+(c+b*t)*t;\n        res = dot2(q);\n    \tsgn = cross2(c+2.0*b*t,q);\n    }\n    else \n    {   // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\n        vec2  qx=d+(c+b*t.x)*t.x; float dx=dot2(qx), sx = cross2(c+2.0*b*t.x,qx);\n        vec2  qy=d+(c+b*t.y)*t.y; float dy=dot2(qy), sy = cross2(c+2.0*b*t.y,qy);\n        if( dx<dy ) { res=dx; sgn=sx; } else {res=dy; sgn=sy; }\n    }\n    \n    return sqrt( res )*sign(sgn);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtyGWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[301, 332, 368, 368, 413], [418, 462, 509, 509, 536], [537, 537, 580, 580, 607], [608, 608, 656, 656, 684], [690, 690, 752, 752, 949], [951, 951, 1032, 1032, 1162], [1164, 1164, 1221, 1221, 1292], [1294, 1294, 1331, 1331, 1405], [1407, 1407, 1442, 1442, 1465], [1467, 1467, 1519, 1519, 1635], [1638, 1638, 1700, 1700, 1937], [1939, 1939, 2003, 2003, 2091], [2093, 2093, 2114, 2114, 2272], [2274, 2274, 2306, 2306, 2538], [2540, 2540, 2597, 2597, 2695], [2697, 2697, 2745, 2745, 2889], [2891, 2891, 2924, 2924, 5904], [5906, 5906, 5928, 5928, 6086], [6105, 6148, 6188, 6188, 6624], [6626, 6626, 6683, 6683, 7194]], "test": "untested"}
{"id": "NsdSWs", "name": "Numerical Derivative", "author": "Zi7ar21", "description": "poggers", "tags": ["derivative", "numerical", "numeric"], "likes": 4, "viewed": 287, "published": 3, "date": "1638290199", "time_retrieved": "2024-07-30T18:45:02.502894", "image_code": "#define dt 0.001\n\n/*\nfloat f(float x)\n{\n    return tanh(x);\n}\n*/\n\n// Suggested demonstration from elenzil (https://www.shadertoy.com/user/elenzil)\nfloat f(float x)\n{\n    float[8] fs;\n    int n = 0;\n    fs[n++] =  tanh(x);\n    fs[n++] =  sinh(x);\n    fs[n++] =  sin (x);\n    fs[n++] =  pow(x, 3.0);\n    fs[n++] =  pow(x, 2.0) * 3.0;\n    fs[n++] =  x * 6.0;\n    fs[n++] =  x;\n    fs[n++] = -x;\n    \n    float t = iTime * 0.25;\n    \n    float T = mod(t, float(fs.length() + 1));\n    int n1 = int(t) % fs.length();\n    int n2 = int((n1 + 1) % fs.length());\n    \n    float m = smoothstep(0.0, 1.0, fract(T) * 2.0);    \n    \n    return mix(fs[n1], fs[n2], m);\n}\n\nfloat df(float x)\n{\n    //return ( f(x + dt) - f(x) ) / dt;\n    return ( f(x + dt) - f(x - dt) ) / (2.0 * dt);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 8.0 * (fragCoord - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    fragColor.x =  f(uv.x) > uv.y ? 0.5               : fragColor.x;\n    fragColor.x = df(uv.x) > uv.y ? 0.5 + fragColor.x : fragColor.x;\n\n    fragColor = fragColor.xxxw;\n\n    if(abs(uv.x) < 0.01)\n    {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n    if(abs(uv.y) < 0.01)\n    {\n        fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n    }\n    if(uv.x * uv.x + uv.y * uv.y < 0.001)\n    {\n        fragColor = vec4(1.0, 1.0, 0.0, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsdSWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[657, 657, 676, 716, 769], [771, 771, 828, 828, 1404]], "test": "untested"}
{"id": "7lG3zd", "name": "Magical King Granzort", "author": "luolin", "description": "A moving picture in animation（Magical King Granzort）", "tags": ["2dcirletesttime"], "likes": 0, "viewed": 255, "published": 3, "date": "1638272016", "time_retrieved": "2024-07-30T18:45:03.351625", "image_code": "float isInSector(vec2 tex, vec2 center, float dis, float t) // 是否在扇形中\n{\n\tfloat res = 0.;\n\tfloat theta = radians(clamp(t, 0., 360.));\n    \n\tfloat rotate_x = sin(theta/2.) + center.x;\n\tfloat rotate_y = cos(theta/2.) + center.y;\n\tvec2 half_theta_v = normalize(vec2(rotate_x, rotate_y) - center);\n\tvec2 c_top = vec2(0, 1);\n\tvec2 cur_v = normalize(tex - center);\n\tfloat cur_theta = acos(dot(half_theta_v, cur_v));\n\treturn step(cur_theta, theta/2.) * step(0., -length(vec2(tex - center)) + dis);\n}\n\nfloat sdfCircle(vec2 tex, vec2 center, float dis)\n{\n    return dis - length(vec2(tex - center)) ;\n}\n\nfloat getPointLineDis(vec2 tex, vec2 p1, vec2 p2)\n{\n\tif((tex.y - p2.y)*(p1.x - p2.x) == (p1.y - p2.y) * (tex.x - p2.x))\n\t{\n\t\treturn 0.0;//共线\n\t}\n\tfloat len1 = length(tex -p1);\n\tfloat len2 = length(tex -p2);\n\tfloat len3 = length(p1 -p2);\n\tfloat half_p = 0.5 * (len1 + len2 + len3);\n\tfloat s = sqrt(half_p * (half_p - len1) * (half_p-len2) * (half_p-len3));\n\tfloat dis = s * 2. / len3;\n\treturn dis;\n}\n\n\nfloat sdfPloygon(mat4x4 points, vec2 tex, float is_in ) // 计算多边形距离场\n{\n\tfloat c=0.;\n\tfloat cur_dis = 100.;\n\n\tint j=0;\n\tint k=0;\n\tint temp_j = 0;\n\tint temp_k = 0;\n\tfor (int i = 0; i < 3; i++) \n\t{\t\n\t\tj = (i*2) / 4;\n\t\ttemp_j = i*2 - i*2 / 4 * 4;\n\t\tvec2 p = vec2(points[j][temp_j], points[j][temp_j + 1]);\n\t\tk = (i*2 + 2) / 4;\n\t\ttemp_k = (i+1)*2 - (i+1)*2 / 4 * 4;\n\t\tvec2 p1 = vec2(points[k][temp_k], points[k][temp_k + 1]);\n\t\n\t\tfloat tmp = p1.x - p.x;\n\t\tvec2 cur_center = 0.5 *(p + p1);\n\t\tfloat dis_c = length(cur_center - tex);\n\t\tfloat length_line = length(p1 - p);\n\t\tfloat dis_l = getPointLineDis(tex, p, p1);\n\t\tfloat dis_2p = min(length(tex - p), length(tex - p1));\n\t\tfloat flag_in_range_line = dot(p-tex, p-p1) * dot(p1-tex, p1-p);\n        cur_dis = min(cur_dis, max(dis_l * step(0., flag_in_range_line),  dis_2p * step(flag_in_range_line, 0.)));\n    }\n\n\treturn cur_dis * (1. - 2. *step(is_in, 0.5));\n}\n\nfloat IsInPloygon(mat4x4 points, vec2 tex ) // 判断是否在多边形内\n{\n\tfloat c=0.;\n\tint j=0;\n\tint k=0;\n\tint temp_j = 0;\n\tint temp_k = 0;\n\tfor (int i = 0; i < 3; i++) \n\t{\t\n\t\tfloat flag = 1.0f;\n\t\tj = (i*2) / 4;\n\t\ttemp_j = i*2 - (i*2 / 4) * 4;\n\t\tvec2 p = vec2(points[j][temp_j], points[j][temp_j + 1]);\n\t\tk = (i*2 + 2) / 4;\n\t\ttemp_k = (i+1)*2 - (i+1)*2 / 4 * 4;\n\t\tvec2 p1 = vec2(points[k][temp_k], points[k][temp_k + 1]);\n\t\tfloat tmp = p1.x - p.x;\n\t\tflag = step(0.00001, abs(tmp));\n\t\tfloat slope = (p1.y - p.y) / tmp;\n\t\tfloat cond1 = step(p.x, tex.x) * step(tex.x, p1.x);\n\t\tfloat cond2 = step(p1.x, tex.x) * step(tex.x, p.x);\n\t\tfloat above = step(tex.y, (slope * (tex.x - p.x) + p.y));\n\t\tfloat cur_val = above* flag *(cond1 + cond2);\n\t\tc = c + cur_val;\n    }\n\treturn mod(c, 2.);\n}\n\nfloat sdfTrigle(vec2 tex, vec2 p0, vec2 p1, vec2 p2)\n{\n\tmat4x4 points;\n\tpoints[0].xy = p0;\n\tpoints[0].zw = p1;\n\tpoints[1].xy = p2;\n\tpoints[1].zw = p0;\n\n\tfloat is_in_tri = IsInPloygon(points, tex);\n\tfloat res = sdfPloygon(points, tex,  is_in_tri );\n\treturn res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord;\n    vec2 center = 0.5 * iResolution.xy;\n    vec3 background_color = vec3(0.5, 0.5, 0.5);\n    vec3 c1 = vec3(1.0, 0., 0.);\n    vec3 c2 = vec3(0., 1., 0.);\n    vec3 c3 = vec3(0., 0., 1.);\n\tfloat edge_width =iResolution.y * 0.025; \n\tfloat radius = iResolution.y * 0.25;\n    \n    float cir_d = sdfCircle(uv, center, radius);\n    float anti = fwidth(cir_d);\n\tvec3 col =  mix(background_color, c1, smoothstep(-anti, anti, cir_d ));\n    float d1 = sdfCircle(uv, center, radius - edge_width);\n\tfloat anti1 = fwidth(d1);\n\tfloat edge_alpha = smoothstep(-anti1, anti1, d1);\n\tcol = mix(col, background_color, edge_alpha);\n    // Output to screen\n\n\tfloat is_in_0 = isInSector(uv, center, radius + anti, iTime*100.);\n\n\tif(is_in_0 <= 0.)\n\t{\n\t\tcol = background_color.xyz;\n\t}\n\n\tfloat tri_d0 = 0.;\n\tfloat tri1_anti = 0.;\n\tfloat tri1_anti1 = 0.;\n\n\tfloat tri2_anti = 0.;\n\tfloat tri2_anti1 = 0.;\n\n\tvec3 col1 = col;\n\tvec3 col2 = col;\n\tfloat tri_radius = radius - edge_width - anti1;\n\n\tif((cir_d > (edge_width + anti1) || cir_d <0. - anti )&& iTime*100. > 360.)\n\t{\n\t\tvec2 p0 = vec2(center.x, center.y + tri_radius);\n\t\tvec2 p1 = vec2(center.x + tri_radius * cos(radians(30.)), center.y - tri_radius* sin(radians(30.)));\n\t\tvec2 p2 = vec2(center.x - tri_radius * cos(radians(30.)), center.y - tri_radius* sin(radians(30.)));\n\n\t\ttri_d0 = sdfTrigle(uv, p0, p1, p2);\n\t\ttri1_anti = fwidth(tri_d0);\n\t\tcol1 = mix(background_color, c2, smoothstep(-tri1_anti, tri1_anti,tri_d0 ));\n\n\t\ttri1_anti1 = fwidth(tri_d0 - edge_width);\n\t\tcol1 = mix(col1, background_color, smoothstep(-tri1_anti1, tri1_anti1,tri_d0 - edge_width ));\n\n\t\tfloat is_in_1 = isInSector(uv, center, radius + tri1_anti, iTime*100. - 360.);\n\n\t\tif(is_in_1 <= 0.)\n\t\t{\n\t\t\tcol1 = background_color.xyz;\n\t\t}\n\t\tcol = col1;\n\t}\n\n\tvec2 p0 = vec2(center.x - tri_radius * cos(radians(30.)),  center.y + tri_radius * sin(radians(30.)));\n\tvec2 p1 = vec2(center.x + tri_radius * cos(radians(30.)), center.y + tri_radius* sin(radians(30.)));\n\tvec2 p2 = vec2(center.x , center.y  - tri_radius);\n\n\tfloat tri_d1 = sdfTrigle(uv, p0, p1, p2);\n\ttri2_anti = fwidth(tri_d1);\n\ttri2_anti1 = fwidth(tri_d1 - edge_width);\n\n\tbool flag0 = tri_d0 > edge_width + tri1_anti || tri_d0 < 0. - tri1_anti1;\n\tbool flag1 = (tri_d0 <= edge_width + tri1_anti && tri_d0 >= 0. - tri1_anti1) &&  (tri_d1 <= edge_width + tri2_anti && tri_d1 >= 0. - tri2_anti1);\n\n\tif((cir_d > (edge_width + anti1) || cir_d < 0. - anti ) && (flag0 || flag1 ) && iTime*100. > 720.)\n\t{\n        \n        if(flag1)\n        {\n            col2 = mix(col, c3, smoothstep(-tri2_anti, tri2_anti,tri_d1 ));\n            col2 = mix(col2, col, smoothstep(-tri2_anti1, tri2_anti1,tri_d1 - edge_width ));\n        }\n        else\n        {\n            col2 = mix(background_color, c3, smoothstep(-tri2_anti, tri2_anti,tri_d1 ));\n            col2 = mix(col2, background_color, smoothstep(-tri2_anti1, tri2_anti1,tri_d1 - edge_width ));\n        }\n\n\t\tfloat is_in_2 = isInSector(uv, center, radius + tri2_anti1, iTime*100. - 720.);\n\n\t\tif(is_in_2 <= 0.)\n\t\t{\n\t\t\tcol2 = col;\n\t\t}\n\t\tcol = col2;\n\t}\n\t\n    fragColor = vec4(col,1.0);\n   }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lG3zd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 83, 83, 503], [505, 505, 556, 556, 604], [606, 606, 657, 657, 1007], [1010, 1010, 1095, 1095, 1928], [1930, 1930, 2006, 2006, 2714], [2716, 2716, 2770, 2770, 2978], [2980, 2980, 3036, 3086, 6187]], "test": "untested"}
{"id": "ftVGDy", "name": "Greek Variants", "author": "dr2", "description": "Beware of viruses bearing Greek letters (especially the Omicron)", "tags": ["font", "cellmarch"], "likes": 14, "viewed": 498, "published": 3, "date": "1638269941", "time_retrieved": "2024-07-30T18:45:04.283134", "image_code": "// \"Greek Variants\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n Beware of viruses bearing Greek letters (especially the Omicron).\n \n Using the Greek characters included in otaviogood's \"SDF Texture Font\"; not\n following WHO naming guidelines.\n\n  No. 14 in \"Font\" series\n    \"Font3d\"               (ltsyRr)\n    \"Lorem Ipsum\"          (XlXyR8)\n    \"Historical Text\"      (4tXcRH)\n    \"Font Clock\"           (MlscR8)\n    \"Alphaville\"           (XtfczN)\n    \"Pi in the Sky\"        (4lfyR7)\n    \"Train Builder\"        (4tlcz7)\n    \"Twisted Time\"         (XlsyWH)\n    \"Alphawall\"            (MlXyWf)\n    \"Alphapolis\"           (4scyDj)\n    \"Pi Night\"             (WsXyR4)\n    \"Corona Time\"          (wsfcRX)\n    \"Facebook Time\"        (sscXRj)\n*/\n\n#define AA  1  // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat Minv3 (vec3 p);\nfloat SmoothMax (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nmat3 StdVuMat (float el, float az);\nfloat FontTexDf (vec2 p, float id);\nfloat Hashfv2 (vec2 p);\nfloat Hashfv3 (vec3 p);\nvec3 Hashv3f (float p);\n\nvec3 cId, ltDir, obRot;\nvec2 obRotCs[3], fntSize, qnTex;\nfloat dstFar, tCur, gSize, vSpd, idTxt, qyHit;\nbool cOcc;\nconst float pi = 3.1415927;\n  \nfloat ObjDf (vec3 p)\n{\n  float d;\n  d = dstFar;\n  if (cOcc) {\n    p -= gSize * (cId + 0.5);\n    p.yz = Rot2Cs (p.yz, obRotCs[0]);\n    p.xz = Rot2Cs (p.xz, obRotCs[1]);\n    p.xy = Rot2Cs (p.xy, obRotCs[2]);\n    p.xz /= fntSize.x;\n    d = 0.5 * SmoothMax (max (fntSize.x * FontTexDf (p.xz + 0.5, idTxt),\n      PrBox2Df (p.xz, vec2 (0.35))), abs (p.y) - fntSize.y, 0.001);\n    qyHit = p.y;\n  }\n  return d;\n}\n\nvoid ObjState ()\n{\n  vec3 vRan;\n  float rNum;\n  int c;\n  vRan = Hashv3f (dot (cId, vec3 (31.1, 41.1, 51.1)) + 99.);\n  cOcc = (vRan.x * step (1.5, length (cId.xz)) > 0.2);\n  if (cOcc) {\n    obRot = (vRan - 0.5) * (tCur + 10.);\n    obRotCs[0] = sin (obRot.x + vec2 (0.5 * pi, 0.));\n    obRotCs[1] = sin (obRot.y + vec2 (0.5 * pi, 0.));\n    obRotCs[2] = sin (obRot.z + vec2 (0.5 * pi, 0.));\n    rNum = Hashfv3 (vec3 (31.1, 41.1, 51.1) * cId + 99.);\n    c = int (rNum * 20.3);\n    if (c < 16) c += 0x80;\n    else c = (c < 20) ? 0x6f : 0x1d;\n    idTxt = float (c);\n  }\n}\n\nvec3 ObjCell (vec3 p)\n{\n  cId.xz = floor (p.xz / gSize);\n  p.y += vSpd * (tCur + 10.) * (1. + Hashfv2 (cId.xz));\n  cId.y = floor (p.y / gSize);\n  return p;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, cIdP, rdi;\n  float dHit, d, eps;\n  eps = 0.001;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  rdi = 1. / rd;\n  cIdP = vec3 (-999.);\n  dHit = eps;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ObjCell (ro + dHit * rd);\n    if (cId != cIdP) {\n      ObjState ();\n      cIdP = cId;\n    }\n    d = ObjDf (p);\n    d = min (d, abs (Minv3 ((gSize * (cId + step (0., rd)) - p) * rdi)) + eps);\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 BgCol (vec3 rd)\n{\n  float t, gd, b;\n  t = tCur * 1.5;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return mix (vec3 (0.35, 0.5, 1.), vec3 (0.1, 0.4, 0.3), 0.5 * (1. - rd.y)) *\n     (0.24 + 0.44 * (rd.y + 1.) * (rd.y + 1.)) * (1. + 0.15 * gd);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, bgCol, vn;\n  float dstObj, s;\n  gSize = 1.;\n  fntSize = vec2 (0.45, 0.02);\n  vSpd = 0.1;\n  bgCol = BgCol (rd);\n  col = bgCol;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    col = (idTxt == float (0x6f)) ? vec3 (0.9, 0.3, 0.3) : vec3 (0.8, 0.9, 0.5);\n    s = step (abs (qyHit), fntSize.y - 0.001);\n    col *= 1. - 0.6 * s;\n    vn = (s > 0.) ? normalize (vec3 (qnTex,\n       0.001 * sign (qyHit))).xzy : vec3 (0., sign (qyHit), 0.);\n    vn.xy = Rot2D (vn.xy, - obRot.z);\n    vn.xz = Rot2D (vn.xz, - obRot.y);\n    vn.yz = Rot2D (vn.yz, - obRot.x);\n    col *= 0.3 + 0.7 * max (dot (vn, ltDir), 0.);\n    col = mix (col, bgCol, smoothstep (0.5, 0.95, dstObj / dstFar));\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define txFnt iChannel0\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, sr, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.25 * pi;\n  el = 0.05 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.7 * pi * mPtr.y;\n  } else {\n    az += pi * sin (0.003 * pi * tCur);\n    el += 0.2 * pi * sin (0.002 * pi * tCur);\n  }\n  el = clamp (el, -0.3 * pi, 0.3 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (0.4);\n  zmFac = 3.;\n  dstFar = 20.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -2.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n#if 0   // (show full font texture instead)\n  col = (max (abs (uv.x), abs (uv.y)) < 1.) ? texture (txFnt, 0.5 * (uv + 1.)).rgb : vec3 (0.);\n#endif\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat FontTexDf (vec2 p, float id)\n{\n  vec3 tx;\n  float d;\n  tx = texture (txFnt, fract ((vec2 (mod (id, 16.),\n     15. - floor (id / 16.)) + fract (p)) * (1. / 16.))).gba - 0.5;\n  qnTex = vec2 (tx.r, - tx.g);\n  d = tx.b + 1. / 256.;\n  return d;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (p + vec3 (37., 39., 41.)) * cHashM);\n}\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftVGDy.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1377, 1377, 1399, 1399, 1781], [1783, 1783, 1801, 1801, 2348], [2350, 2350, 2373, 2373, 2507], [2509, 2509, 2542, 2542, 3099], [3101, 3101, 3123, 3123, 3546], [3548, 3548, 3583, 3583, 4305], [4332, 4332, 4388, 4388, 5626], [5628, 5628, 5661, 5661, 5750], [5752, 5752, 5774, 5774, 5812], [5814, 5814, 5859, 5859, 5951], [5953, 5953, 5998, 5998, 6036], [6038, 6038, 6074, 6074, 6280], [6282, 6282, 6312, 6312, 6425], [6427, 6427, 6458, 6458, 6522], [6524, 6524, 6560, 6560, 6771], [6805, 6805, 6829, 6829, 6889], [6891, 6891, 6915, 6915, 6980], [6982, 6982, 7006, 7006, 7066]], "test": "untested"}
{"id": "flV3DG", "name": "2D Math Plot Grid", "author": "lihengc6", "description": "Basic grid for plotting math functions", "tags": ["2d", "function", "plot"], "likes": 3, "viewed": 439, "published": 3, "date": "1638263121", "time_retrieved": "2024-07-30T18:45:05.047091", "image_code": "// Author: Li-Heng Henry Chang\n\n#define t iTime\n\n//Grid Units\n#define Lgrid 1.  \n#define Sgrid .25\n#define Width_lgrid .01\n#define Width_sgrid .05\n#define zoom 2.;\n\n\n// Modified from:  https://www.shadertoy.com/view/4tB3WV\n\nfloat grid2D(vec2 _p){\n    float width = 1. / iResolution.y * zoom;\n    \n    float axis = smoothstep(0.0, width*4., min( abs(_p.x), abs(_p.y)) );\n    \n    \n    vec2 uv = mod(_p, Lgrid);\n    // center the functions and create symmetry around the mid point of the a grid box\n    float c = Lgrid/2.; // central point\n    float lgrid = c -  max(abs(uv.x - c), abs(uv.y - c));\n    lgrid = smoothstep(0.0, width*2., lgrid);\n    \n    uv = mod(_p, Sgrid);\n    c = Sgrid/2.;\n    float sgrid = c -  max(abs(uv.x - c), abs(uv.y - c));\n    sgrid = smoothstep(0.0, width, sgrid);\n    \n    return min(axis, min(lgrid, sgrid));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = ( fragCoord - .5* iResolution.xy ) / iResolution.y;\n    uv *= zoom;\n    \n    vec3 color = vec3(1.0); \n    color = vec3( grid2D(uv) );\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flV3DG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[224, 224, 246, 246, 838], [841, 841, 896, 948, 1160]], "test": "untested"}
{"id": "NlGGDy", "name": "Biham-Middleton-Levine Traffic 9", "author": "pvillano", "description": "Click to reset. Change the density and colors in Common. I didn't try to optimize branches since it runs at 60 fps anyway.\nEach window has a different density, increasing from top left to bottom right.", "tags": ["cellularautomata", "traffic"], "likes": 7, "viewed": 254, "published": 3, "date": "1638246690", "time_retrieved": "2024-07-30T18:45:06.086313", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n//From https://www.shadertoy.com/view/Mdj3zd\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 texelFetchWrap(vec2 coord){\n    \n    float boxWidth = floor(iChannelResolution[0].x/3.0);\n    if(mod(coord.x, boxWidth) > boxWidth - BORDER){\n        coord.x -= boxWidth - 2.0 * BORDER;\n    } else if(mod(coord.x, boxWidth) < BORDER){\n         coord.x += boxWidth - 2.0 * BORDER;\n    }\n    \n    float boxHeight = floor(iChannelResolution[0].y/3.0);\n    if(mod(coord.y, boxHeight) > boxHeight - BORDER){\n        coord.y -= boxHeight - 2.0 * BORDER;\n    } else if(mod(coord.y, boxHeight) < BORDER){\n         coord.y += boxHeight - 2.0 * BORDER;\n    }\n    \n    return texelFetch(iChannel0, ivec2(coord.xy), 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float boxWidth = floor(iChannelResolution[0].x/3.0);\n    float boxHeight = floor(iChannelResolution[0].y/3.0);\n\tif(mod(fragCoord.x, boxWidth) > boxWidth - BORDER ||\n       mod(fragCoord.x, boxWidth) < BORDER ||\n       mod(fragCoord.y, boxHeight) > boxHeight - BORDER ||\n       mod(fragCoord.y, boxHeight) < BORDER){\n       fragColor = BLACK;\n       return;\n    }\n    \n    \n    if(iFrame == 0 || iMouse.z > 0.0){\n        float raw_density = floor(fragCoord.x/iChannelResolution[0].x*3.0)/8.0 +\n            \t\t\t\tfloor(3.0 - fragCoord.y/iChannelResolution[0].y*3.0)*3.0/8.0;\n        float density = mix(minDensity, maxDensity,raw_density);\n        if (rand(fragCoord) < density/2.0){\n            fragColor = RED;\n        } else if (rand(fragCoord) > 1.0 - density/2.0) {\n            fragColor = BLUE;\n        } else {\n            fragColor = BLACK;\n        }\n        return;\n    }\n    \n    vec4 myColor = texelFetchWrap(fragCoord);\n    vec4 aboveColor = texelFetchWrap(fragCoord + vec2(0.0,1.0));\n    vec4 belowColor = texelFetchWrap(fragCoord + vec2(0.0,-1.0));\n    if(aboveColor == RED && myColor == BLACK){\n        fragColor = RED;\n    } else if (myColor == RED && belowColor == BLACK) {\n        fragColor = BLACK;\n    } else {\n        fragColor = myColor;\n    }\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n//From https://www.shadertoy.com/view/Mdj3zd\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvec4 texelFetchWrap(vec2 coord){\n    \n    float boxWidth = floor(iChannelResolution[0].x/3.0);\n    if(mod(coord.x, boxWidth) > boxWidth - BORDER){\n        coord.x -= boxWidth - 2.0 * BORDER;\n    } else if(mod(coord.x, boxWidth) < BORDER){\n         coord.x += boxWidth - 2.0 * BORDER;\n    }\n    \n    float boxHeight = floor(iChannelResolution[0].y/3.0);\n    if(mod(coord.y, boxHeight) > boxHeight - BORDER){\n        coord.y -= boxHeight - 2.0 * BORDER;\n    } else if(mod(coord.y, boxHeight) < BORDER){\n         coord.y += boxHeight - 2.0 * BORDER;\n    }\n    \n    return texelFetch(iChannel0, ivec2(coord.xy), 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float boxWidth = floor(iChannelResolution[0].x/3.0);\n    float boxHeight = floor(iChannelResolution[0].y/3.0);\n\tif(mod(fragCoord.x, boxWidth) > boxWidth - BORDER ||\n       mod(fragCoord.x, boxWidth) < BORDER ||\n       mod(fragCoord.y, boxHeight) > boxHeight - BORDER ||\n       mod(fragCoord.y, boxHeight) < BORDER){\n       fragColor = BLACK;\n       return;\n    }\n    \n    \n    if(iFrame == 0 || iMouse.z > 0.0){\n        float raw_density = floor(fragCoord.x/iChannelResolution[0].x*3.0)/8.0 +\n            \t\t\t\tfloor(3.0 - fragCoord.y/iChannelResolution[0].y*3.0)*3.0/8.0;\n        float density = mix(minDensity, maxDensity,raw_density);\n        if (rand(fragCoord) < density/2.0){\n            fragColor = RED;\n        } else if (rand(fragCoord) > 1.0 - density/2.0) {\n            fragColor = BLUE;\n        } else {\n            fragColor = BLACK;\n        }\n        return;\n    }\n    \n    vec4 myColor = texelFetchWrap(fragCoord);\n    vec4 leftColor = texelFetchWrap(fragCoord + vec2(-1.0,0.0));\n    vec4 rightColor = texelFetchWrap(fragCoord + vec2(1.0,0.0));\n    if(leftColor == BLUE && myColor == BLACK){\n        fragColor = BLUE;\n    } else if (myColor == BLUE && rightColor == BLACK) {\n        fragColor = BLACK;\n    } else {\n        fragColor = myColor;\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const vec4 RED   = vec4(1.0,0.0,0.0,0.0);\nconst vec4 BLUE  = vec4(0.0,0.0,1.0,0.0);\nconst vec4 BLACK = vec4(0.0,0.0,0.0,0.0);\nconst vec4 GREEN = vec4(0.0,1.0,0.0,0.0);\n\nconst float BORDER = 10.0;\nconst float minDensity = .1;\nconst float maxDensity = .7;", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlGGDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 119]], "test": "untested"}
{"id": "flGGDy", "name": "Spiraling clock", "author": "pvillano", "description": "An analog clock. The red dot is the hour hand, the green dot is the minute hand, and the blue dot (visible on 4k screens) is the second hand.", "tags": ["spirals"], "likes": 6, "viewed": 268, "published": 3, "date": "1638246565", "time_retrieved": "2024-07-30T18:45:06.849273", "image_code": "const float D_MAX = 5.0;\nconst float f = 1.0 / 60.0 / 60.0 / 12.0;\nconst float R_VOID = 60.0;\n\nfloat dist_to(float t, vec2 xy0, float r_interest){\n    float theta = t * f * r_interest;\n    vec2 xy = (r_interest + R_VOID) * vec2(sin(theta), cos(theta));\n    return length(xy-xy0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy0 = (fragCoord - iResolution.xy/2.0);\n    float r_int = max(round(length(xy0)) - R_VOID, 1.0);\n    float t = iDate.w * 2.0 * 3.141592653;\n    float flout = D_MAX;\n    \n    for(float i = -D_MAX; i<=D_MAX; i++){\n        float r = max(r_int+i, 1.0);\n        float dist = dist_to(t, xy0, r);\n        flout = min(flout, dist);\n    }\n    flout = clamp(D_MAX-flout, 0.0, 1.0);\n    \n    float dist1 = dist_to(t, xy0, 1.0);\n    float flout1 = clamp(D_MAX-dist1, 0.0, 1.0);\n    \n    float dist2 = dist_to(t, xy0, 12.0);\n    float flout2 = clamp(D_MAX-dist2, 0.0, 1.0);\n    \n    float dist3 = dist_to(t, xy0, 12.0*60.0);\n    float flout3 = .9 * clamp(D_MAX-dist3, 0.0, 1.0);\n    \n    fragColor = vec4(flout-flout2-flout3, flout-flout1-flout3, flout-flout1-flout2, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flGGDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 95, 146, 146, 281], [283, 283, 340, 340, 1112]], "test": "untested"}
{"id": "Nly3Wy", "name": " Reversible Fluid Flow", "author": "pvillano", "description": "Click and hold on the right to reverse time. Click on the left to reset.", "tags": ["fluid"], "likes": 12, "viewed": 317, "published": 3, "date": "1638246372", "time_retrieved": "2024-07-30T18:45:07.654121", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n      if(iTime <= 0.1|| iFrame < 2){\n        vec2 coord = fragCoord.xy/iChannelResolution[0].xy*iChannelResolution[1].xy;\n        float grey = dot(texelFetch(iChannel1, ivec2(coord), 0), vec4(.3, .59, .11, 0.0));\n        fragColor = vec4(grey, grey, grey, 1.0);\n        return;\n    }\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0).rrra;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float C_INV = 1.0/4.0;\n\nvec4 texelFetchWrap(vec2 coord){\n    coord.x = mod(coord.x, iChannelResolution[0].x);\n    coord.y = mod(coord.y, iChannelResolution[0].y);\n    return texelFetch(iChannel0, ivec2(coord.xy), 0);\n}\n\nfloat calc_ddu(vec2 coord){\n    float sum = 0.0;\n    sum += texelFetchWrap(coord.xy + vec2(1.0,0.0)).r;\n    sum += texelFetchWrap(coord.xy + vec2(-1.0,0.0)).r;\n    sum += texelFetchWrap(coord.xy + vec2(0.0,1.0)).r;\n    sum += texelFetchWrap(coord.xy + vec2(0.0,-1.0)).r;\n    sum -= texelFetchWrap(coord.xy).r * 4.0;\n    return sum*C_INV;\n}\n\nfloat calc_ddu_old(vec2 coord){\n    vec2 sum = vec2(0.0);\n    sum += texelFetchWrap(coord.xy + vec2(1.0,0.0)).rg;\n    sum += texelFetchWrap(coord.xy + vec2(-1.0,0.0)).rg;\n    sum += texelFetchWrap(coord.xy + vec2(0.0,1.0)).rg;\n    sum += texelFetchWrap(coord.xy + vec2(0.0,-1.0)).rg;\n    sum -= texelFetchWrap(coord.xy).rg * 4.0;\n    return (sum.r - sum.g)*C_INV;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 10 || (iMouse.z > 0.0 && iMouse.z < iResolution.x/2.0)){\n        vec2 coord = fragCoord.xy/iChannelResolution[0].xy*iChannelResolution[1].xy;\n        float grey = dot(texelFetch(iChannel1, ivec2(coord), 0), vec4(.3, .59, .11, 0.0));\n        fragColor = vec4(grey, 0.0, 0.0, 1.0);\n        return;\n    }\n   \n    if(iMouse.z > iResolution.x/2.0 || (iResolution.x < 200.0 && iFrame - 10 - ((iFrame - 10)/120)*120 >= 60)){\n        float du_old = texelFetchWrap(fragCoord).g;\n        float u_old = texelFetchWrap(fragCoord).r;\n        float ddu = calc_ddu(fragCoord);\n        float du = du_old + ddu;\n        float u = u_old+du;\n        fragColor = vec4(u,du,0,1);\n    } else {\n        float u_curr = texelFetchWrap(fragCoord).r;\n        float du_curr = texelFetchWrap(fragCoord).g;\n        float u_old = u_curr - du_curr;\n        float ddu_old = calc_ddu_old(fragCoord);\n        float du_old = du_curr - ddu_old;\n        fragColor = vec4(u_old, du_old, 0, 1);\n    }\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "const float C_INV = 1.0/4.0;\n\nvec4 texelFetchWrap(vec2 coord){\n    coord.x = mod(coord.x, iChannelResolution[0].x);\n    coord.y = mod(coord.y, iChannelResolution[0].y);\n    return texelFetch(iChannel0, ivec2(coord.xy), 0);\n}\n\nfloat calc_ddu(vec2 coord){\n    float sum = 0.0;\n    sum += texelFetchWrap(coord.xy + vec2(1.0,0.0)).r;\n    sum += texelFetchWrap(coord.xy + vec2(-1.0,0.0)).r;\n    sum += texelFetchWrap(coord.xy + vec2(0.0,1.0)).r;\n    sum += texelFetchWrap(coord.xy + vec2(0.0,-1.0)).r;\n    sum -= texelFetchWrap(coord.xy).r * 4.0;\n    return sum*C_INV;\n}\n\nfloat calc_ddu_old(vec2 coord){\n    vec2 sum = vec2(0.0);\n    sum += texelFetchWrap(coord.xy + vec2(1.0,0.0)).rg;\n    sum += texelFetchWrap(coord.xy + vec2(-1.0,0.0)).rg;\n    sum += texelFetchWrap(coord.xy + vec2(0.0,1.0)).rg;\n    sum += texelFetchWrap(coord.xy + vec2(0.0,-1.0)).rg;\n    sum -= texelFetchWrap(coord.xy).rg * 4.0;\n    return (sum.r - sum.g)*C_INV;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 10 || (iMouse.z > 0.0 && iMouse.z < iResolution.x/2.0)){\n        vec2 coord = fragCoord.xy/iChannelResolution[0].xy*iChannelResolution[1].xy;\n        float grey = dot(texelFetch(iChannel1, ivec2(coord), 0), vec4(.3, .59, .11, 0.0));\n        fragColor = vec4(grey, 0.0, 0.0, 1.0);\n        return;\n    }\n   \n    if(iMouse.z > iResolution.x/2.0 || (iResolution.x < 200.0 && iFrame - 10 - ((iFrame - 10)/120)*120 >= 60)){\n        float du_old = texelFetchWrap(fragCoord).g;\n        float u_old = texelFetchWrap(fragCoord).r;\n        float ddu = calc_ddu(fragCoord);\n        float du = du_old + ddu;\n        float u = u_old+du;\n        fragColor = vec4(u,du,0,1);\n    } else {\n        float u_curr = texelFetchWrap(fragCoord).r;\n        float du_curr = texelFetchWrap(fragCoord).g;\n        float u_old = u_curr - du_curr;\n        float ddu_old = calc_ddu_old(fragCoord);\n        float du_old = du_curr - ddu_old;\n        fragColor = vec4(u_old, du_old, 0, 1);\n    }\n}", "buffer_b_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nly3Wy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 408]], "test": "untested"}
{"id": "flGGWy", "name": "Vinaigrette", "author": "wyatt", "description": "Properties of Balsamic Vinegar and Olive Oil derived from experimental analysis of appetizers. ", "tags": ["fluid", "automata"], "likes": 15, "viewed": 418, "published": 3, "date": "1638244058", "time_retrieved": "2024-07-30T18:45:08.566681", "image_code": "// Fork of \"Bubbles!!!\" by wyatt. https://shadertoy.com/view/sdfGWr\n// 2021-11-30 02:50:05\n\n// Fork of \"Colors!\" by wyatt. https://shadertoy.com/view/7dX3z7\n// 2021-03-14 23:43:37\n\n// Fork of \"Transport Dynamics II\" by wyatt. https://shadertoy.com/view/sdl3RN\n// 2021-03-14 01:41:52\n\n// Display 🌵\nMain \n{\n    Q = vec4(1.,.65,.3,1)-B(U).w*vec4(1.5,2,2,1);\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define box for(int x=-1;x<=1;x++)for(int y=-1;y<=1;y++)\n#define r2 0.70710678118\n", "buffer_a_code": "// Forces 🦜\nMain\n{\n    Q = A(U);\n    vec4 q = B(U);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u),b = B(U+u+.5);\n        Q.xy -= 0.08*(a.w+b.w)*u; \n    }\n    //Q.y -= 1e-5;\n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    if (iFrame < 1)Q = vec4(0,0,U.x/R.x,.15);\n    if (U.x < 4.||R.x-U.x<4.) Q.xy *= 0.;\n    if (U.y < 4.||R.y-U.y<4.) Q.xy *= 0.;\n    if (Q.w>2.) Q.w = 2.;\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Advect 🐿\nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = 1.;\n       float k = 1.;\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Q.xyz*wa+q.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n    if (U.x < 4.||R.x-U.x<4.) Q.xy *= 0.;\n    if (U.y < 4.||R.y-U.y<4.) Q.xy *= 0.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Forces 🦜\nMain\n{\n    Q = A(U);\n    vec4 q = B(U);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u),b = B(U+u-.5);\n        Q.xy -= 0.08*(a.w*(a.w-.6)+.5*b.w)*u;   \n    }\n    //Q.xy *= .999;\n    Q.y -= 3e-5;\n    if (iMouse.z>0.) \n    Q.xy -= 1e-3*(iMouse.xy-U)/(1.+length(iMouse.xy-U));\n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    if (iFrame < 1)Q = vec4(0,0,U.x/R.x,.5*step(0.,sin(U.x)*cos(U.y)));\n    if (U.x < 2.||R.x-U.x<2.) Q.xy *= 0.;\n    if (U.y < 2.||R.y-U.y<2.) Q.xy *= 0.;\n    if (Q.w>2.) Q.w = 2.;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Advect 🐿\nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5+.5*smoothstep(1.,0.,Q.w*q.w);\n       float k = .5+.5*smoothstep(1.,0.,Q.w*q.w);\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Q.xyz*wa+q.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n    if (U.x < 4.||R.x-U.x<4.) Q.xy *= 0.;\n    if (U.y < 4.||R.y-U.y<4.) Q.xy *= 0.;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flGGWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "fly3DG", "name": "self-avoiding walk", "author": "remaindeer", "description": "Cellular automata implementation of a self-avoiding walk. The left and right panels feature a von Neumann and hexagonal neighborhood respectively.", "tags": ["hexagon", "ca", "saw", "cellularautomata", "vonneumannneighborhood", "randomwalk", "selfavoiding", "4neighborhood", "6neighborhood"], "likes": 8, "viewed": 353, "published": 3, "date": "1638241137", "time_retrieved": "2024-07-30T18:45:09.433364", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv  = fragCoord / iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Buffer A\n\nconst float N = 10.0;\nconst float d = 1.0 / 60.0;\nconst float R = d / 2.0;\nconst float W = R * 0.15;\nconst float r = R * cos(radians(30.0));\n\nfloat random(vec2 seed) {\n    // https://thebookofshaders.com/10/\n    return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat cross2(vec2 p, vec2 q) {\n    return p.x * q.y - p.y * q.x;\n}\n\nbool in_tri(vec2 uv, vec2 v1, vec2 v2, vec2 v3) {\n    // https://mathworld.wolfram.com/TriangleInterior.html\n    // http://www.sunshine2k.de/coding/java/pointInTriangle/pointInTriangle.html\n    vec2 w1 = v2 - v1;\n    vec2 w2 = v3 - v1;\n    float d = determinant(mat2(w1, w2));\n    // check for d ≈ 0.0 ?\n    float s = determinant(mat2(uv - v1, w2)) / d;\n    float t = determinant(mat2(w1, uv - v2)) / d;\n    return s >= 0.0 && t >= 0.0 && (s + t) <= 1.0;\n}\n\nbool in_reg(vec2 uv, vec2 c, float n, float R, float theta) {\n    // break-up regular polygon into triangles\n    float dt = radians(360.0 / n);\n    for (float i = 0.0, j = 1.0; i < n; i++, j++) {\n        vec2 a = R * vec2(cos(dt * i + theta), sin(dt * i + theta)) + c;\n        vec2 b = R * vec2(cos(dt * j + theta), sin(dt * j + theta)) + c;\n        if (in_tri(uv, a, b, c)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nbool in_cir(vec2 uv, vec2 c, float R) {\n    return distance(uv, c) < R;\n}\n\nbool in_hex(vec2 uv, vec2 c, float R) {\n    return in_reg(uv, c, 6.0, R, radians(30.0));\n}\n\nvec2 uv_to_cir(vec2 uv, float R) {\n    return (1.0 + floor(uv / d)) * d - R;\n}\n\nvec2 uv_to_hex(vec2 uv, float R) {\n    float theta = radians(30.0);\n    float r = R * cos(theta);\n    mat2 b = mat2(2.0 * r, 0.0, r, 1.5 * R);\n    vec2 hex = b * round(inverse(b) * uv);\n    bool inhex = in_reg(uv, hex, 6.0, R, theta);\n    // adjust hex coordinate due to overlap\n    if (!inhex)\n        if (cross2(vec2(r, 0.5 * R), hex - uv) < 0.)\n            hex += (uv.x > hex.x) ? b[1] : -b[0];\n        else\n            hex += (uv.x > hex.x) ? b[0] : -b[1];\n    return hex;\n}\n\nvec3 rcir(vec2 seed, vec3 n, vec3 e, vec3 w, vec3 s) {\n    // select random available direction\n    vec3[] dir = vec3[4] (n, e, w, s);\n    int i = 0;\n    if (n == vec3(0)) dir[i++] = vec3(1, 0, 0);\n    if (e == vec3(0)) dir[i++] = vec3(0, 1, 1);\n    if (w == vec3(0)) dir[i++] = vec3(0, 1, 0);\n    if (s == vec3(0)) dir[i++] = vec3(0, 0, 1);\n    return dir[int(float(i) * random(seed))];\n}\n\nvec3 rhex(vec2 seed, vec3 nw, vec3 ne, vec3 wc, vec3 ec, vec3 sw, vec3 se) {\n    // select random available direction\n    vec3[] dir = vec3[6] (nw, ne, wc, ec, sw, se);\n    int i = 0;\n    if (nw == vec3(0)) dir[i++] = vec3(1, 1, 0);\n    if (ne == vec3(0)) dir[i++] = vec3(1, 0, 1);\n    if (wc == vec3(0)) dir[i++] = vec3(1, 0, 0);\n    if (ec == vec3(0)) dir[i++] = vec3(0, 1, 1);\n    if (sw == vec3(0)) dir[i++] = vec3(0, 1, 0);\n    if (se == vec3(0)) dir[i++] = vec3(0, 0, 1);\n    return dir[int(float(i) * random(seed))];\n}\n\nvec2 y_to_xy(vec2 uv) {\n    return uv / (iResolution.xy / iResolution.y) * (iResolution.xy / iResolution.xy);\n}\n\nvec4 main_cir(in vec2 uv, vec2 range) {\n    vec2 cell = uv_to_cir(uv, R);\n    \n    vec3 col1 = texture(iChannel0, y_to_xy(uv)).rgb;\n    vec3 col2 = vec3(0);\n    \n    if (mod(float(iFrame), N) == 0.0) {\n        if (col1 == vec3(0)) {\n            // initialize random cell and direction\n            vec2 rcell = uv_to_cir(vec2(range.x + range.y * random(iTime + iDate.xy), random(iTime * iDate.xy)), R);\n            if (cell == rcell) {\n                col2 = rcir(rcell * iTime, vec3(0), vec3(0), vec3(0), vec3(0));\n            }\n        }\n    }  \n    \n    if (col1 == vec3(0)) {\n        // von Neumann neighborhood state\n        vec3 n = texture(iChannel0, y_to_xy(cell + vec2(0., +d))).rgb;\n        vec3 e = texture(iChannel0, y_to_xy(cell + vec2(+d, 0.))).rgb;\n        vec3 w = texture(iChannel0, y_to_xy(cell + vec2(-d, 0.))).rgb;\n        vec3 s = texture(iChannel0, y_to_xy(cell + vec2(0., -d))).rgb;\n        // is there an instruction?\n        if (n == vec3(0, 0, 1) || e == vec3(0, 1, 0) || w == vec3(0, 1, 1) || s == vec3(1, 0, 0)) {\n            col2 = rcir(cell * iTime, n, e, w, s);\n        }\n    } else {\n        col2 = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0, 2, 4)) - vec3(.01);\n    }\n     \n    \n    float aa = 2.0 / iResolution.y; \n    float dist = distance(uv, cell) - (R - W);\n    // col2 = in_cir(uv, cell, R - W) ? col2 : vec3(0); // anit-alias off\n    col2 *= smoothstep(aa, 0.0, dist);                  // anit-alias on\n    \n    return vec4(col2, 1.0);\n}\n\nvec4 main_hex(in vec2 uv, vec2 range) {\n    vec2 cell = uv_to_hex(uv, R);\n    vec3 col = vec3(0);\n    // on grid\n    if (in_hex(uv, cell, R - W)) {\n        // previous color\n        col = texture(iChannel0, y_to_xy(uv)).rgb;\n        if (mod(float(iFrame), N) == 0.0) {\n            if (col == vec3(0)) {\n                // initialize random cell and direction\n                vec2 rcell = uv_to_hex(vec2(range.x + range.y * random(iTime + iDate.xy), random(iTime * iDate.xy)), R);\n                if (cell == rcell) {\n                    col = rhex(rcell * iTime, vec3(0), vec3(0), vec3(0), vec3(0), vec3(0), vec3(0));\n                }\n            }\n        } else {\n            if (col == vec3(0)) {\n                // hexagonal neighborhood state\n                vec3 nw = texture(iChannel0, y_to_xy(cell + vec2(-(1.0 * r), +(1.5 * R)))).rgb;\n                vec3 ne = texture(iChannel0, y_to_xy(cell + vec2(+(1.0 * r), +(1.5 * R)))).rgb;\n                vec3 wc = texture(iChannel0, y_to_xy(cell + vec2(-(2.0 * r), (0.000000)))).rgb;\n                vec3 ec = texture(iChannel0, y_to_xy(cell + vec2(+(2.0 * r), (0.000000)))).rgb;\n                vec3 sw = texture(iChannel0, y_to_xy(cell + vec2(-(1.0 * r), -(1.5 * R)))).rgb;\n                vec3 se = texture(iChannel0, y_to_xy(cell + vec2(+(1.0 * r), -(1.5 * R)))).rgb;\n                // is there an instruction?\n                if (nw == vec3(0, 0, 1) || ne == vec3(0, 1, 0) || wc == vec3(0, 1, 1) || \n                    ec == vec3(1, 0, 0) || sw == vec3(1, 0, 1) || se == vec3(1, 1, 0)) {\n                    col = rhex(cell * iTime, nw, ne, wc, ec, sw, se);\n                }\n            } else {\n                col = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0, 2, 4)) - vec3(.01);\n            }\n        }\n    }\n    return vec4(col, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.y;\n    float mid = iResolution.x / iResolution.y / 2.0;\n    vec2 range = uv.x < mid ? vec2(0.0, mid) : vec2(mid, mid);\n    fragColor = fragCoord.x < iResolution.x / 2.0 ? main_cir(uv, range) : main_hex(uv, range);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fly3DG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 175]], "test": "untested"}
{"id": "slK3Rd", "name": "G' surface", "author": "DPiker", "description": "G' surface from\nTriply Periodic Bicontinuous Cubic Microdomain Morphologies by\nSymmetries\nhttps://www.msri.org/publications/sgp/jim/papers/morphbysymmetry/text/levelset.pdf\n\nhttps://twitter.com/KangarooPhysics/status/1462951297825525762\n", "tags": ["bicontinuous"], "likes": 3, "viewed": 249, "published": 3, "date": "1638229087", "time_retrieved": "2024-07-30T18:45:10.296057", "image_code": "vec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float timePeriod = 100.0;\n    float wavePeriod = 20.0;\n    float width = 1.5;\n    vec2 screenCoord = fragCoord - iResolution.xy/2.0;\n    vec2 uv =  width * screenCoord / min(iResolution.x, iResolution.y);\n    float x = uv.x;\n    float y = uv.y;\n    float z = 0.0;\n    z = wavePeriod * mod(iTime,timePeriod)/timePeriod;\n   \n    //G' from https://www.msri.org/publications/sgp/jim/papers/morphbysymmetry/text/levelset.pdf\n    float pi = 3.14159265359;\n    float d = \n    sin(4.0 *pi * x)* cos(2.0 * pi * y)* sin(2.0 * pi * z) +\n    sin(4.0 *pi * y)* cos(2.0 * pi * z)* sin(2.0 * pi * x) +\n    sin(4.0 *pi * z)* cos(2.0 * pi * x)* sin(2.0 * pi * y) + 0.32;\n    \n\n    float h = (1.3*d)/5.0;\n    float s = 0.8;\n    float l = 0.9 - 0.15*d;\n\n    if(0.42<d&&d<0.58){l=0.0;};\n\n    vec3 col = hsl2rgb(vec3(h,s,l));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slK3Rd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 169], [171, 171, 228, 228, 1096]], "test": "untested"}
{"id": "ftyGRd", "name": "Teem", "author": "kmaork", "description": "- Drag with the mouse to add material\n- Press spacebar to reset", "tags": ["reactiondiffusion"], "likes": 2, "viewed": 210, "published": 3, "date": "1638225542", "time_retrieved": "2024-07-30T18:45:11.175705", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 st = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if (isEdge(fragCoord, iResolution)) {\n        fragColor = vec4(0.2, 0.3, 0.1, 1.);\n    } else {\n        switch (getMode(fragCoord, iResolution)) {\n        case 0:\n            fragColor = vec4((1. - st.x) * 0.2, st.y, (1. - st.x) * 0.7, 1.);\n            break;\n        case 1:\n            fragColor = vec4((1. - st.x) * 0.6, st.y, 1. - st.x, 1.);\n            break;\n        case 2:\n            fragColor = vec4(1. - st.x, st.y, 0.05, 1.);\n            break;\n        case 3:\n            fragColor = vec4(st.y * 1.5, (1. - st.x) * 0.7, 0., 1.);\n            break;\n        }\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const int SPACEBAR_KEY = 32;\n\nbool is_key_down(in int key) {\n    return texelFetch(iChannel1, ivec2(key, 0), 0).r != 0.;\n}\n\nbool mouseDown() {\n    return iMouse.z > 0.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (iFrame < 2 || is_key_down(SPACEBAR_KEY)) {\n        float dist = length(fragCoord - iResolution.xy / 2.);\n        bool seed = dist < 50.;\n        fragColor.x = 1.;\n        fragColor.y = seed ? 1. : 0.;\n    } else {\n        nextStep(fragColor, fragCoord, iResolution, iChannel0);\n        if (mouseDown()) {\n            if (length(fragCoord - iMouse.xy) < 10.) {\n                fragColor.y = 1.;\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Based on https://www.karlsims.com/rd.html\n\nconst int PARTS = 2;\n\nfloat random(in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nbool isEdge(in vec2 fragCoord, in vec3 iResolution) {\n    return mod(fragCoord.x, iResolution.x / float(PARTS)) < 1. || mod(fragCoord.y, iResolution.y / float(PARTS)) < 1.;\n}\n\nvec2 getLap(in vec2 fragCoord, sampler2D iChannel0) {\n    return 0.05 * (texelFetch(iChannel0, ivec2(fragCoord.x - 1., fragCoord.y - 1.), 0).xy +\n                   texelFetch(iChannel0, ivec2(fragCoord.x - 1., fragCoord.y + 1.), 0).xy +\n                   texelFetch(iChannel0, ivec2(fragCoord.x + 1., fragCoord.y - 1.), 0).xy +\n                   texelFetch(iChannel0, ivec2(fragCoord.x + 1., fragCoord.y + 1.), 0).xy) +\n           0.2 * (texelFetch(iChannel0, ivec2(fragCoord.x - 1., fragCoord.y), 0).xy +\n                  texelFetch(iChannel0, ivec2(fragCoord.x + 1., fragCoord.y), 0).xy +\n                  texelFetch(iChannel0, ivec2(fragCoord.x, fragCoord.y - 1.), 0).xy +\n                  texelFetch(iChannel0, ivec2(fragCoord.x, fragCoord.y + 1.), 0).xy);\n}\n\nint getMode(in vec2 fragCoord, in vec3 iResolution) {\n    return (fragCoord.x < iResolution.x / 2. ? 0 : 1) + (fragCoord.y < iResolution.y / 2. ? 0: 2);\n}\n\nvoid nextStep(out vec4 fragColor, in vec2 fragCoord, in vec3 iResolution, sampler2D iChannel0) {    \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if (isEdge(fragCoord, iResolution)) {\n        fragColor.x = 0.;\n        fragColor.y = 0.;\n        return;\n    }\n    \n    int mode = getMode(fragCoord, iResolution);\n    float dt, Dx, Dy;\n    // y kill factor\n    float K;\n    // x feed factor (also adds to kill)\n    float F;\n    switch (mode) {\n    case 0:\n        dt = .3;\n        Dx = .9;\n        Dy = 0.6;\n        K = 0.09;\n        F = 0.047;\n        break;\n    case 1:\n        dt = .3;\n        Dx = .9;\n        Dy = 0.4;\n        K = 0.0649;\n        F = 0.0167;\n        break;\n    case 2: // Mitosis\n        dt = 1.;\n        Dx = 1.;\n        Dy = 0.4;\n        K = .0645;\n        F = .0385;\n        break;\n    case 3: // Coral\n        dt = 1.;\n        Dx = 1.;\n        Dy = .42;\n        K = .0626;\n        F = .057;\n        break;\n    }\n    \n    float lastX = fragColor.x;\n    float lastY = fragColor.y;\n    vec2 lap = getLap(fragCoord, iChannel0) - fragColor.xy;\n    float reaction = lastX * lastY * lastY;\n    float newX;\n    if (mode < 2) {\n        newX = lastX + dt * (Dx * lap.x - reaction + F);\n    } else {\n        newX = lastX + dt * (Dx * lap.x - reaction + F * (1. - lastX));\n    }\n    float newY = lastY + dt * (Dy * lap.y + reaction - (K + F) * lastY);\n    fragColor.x = clamp(newX, 0., 1.);\n    fragColor.y = clamp(newY, 0., 1.);\n}", "buffer_b_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    nextStep(fragColor, fragCoord, iResolution, iChannel0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    nextStep(fragColor, fragCoord, iResolution, iChannel0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    nextStep(fragColor, fragCoord, iResolution, iChannel0);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftyGRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 696]], "test": "untested"}
{"id": "slKGRd", "name": "FunkyGunky", "author": "Del", "description": "sin patterns", "tags": ["sin", "pattern"], "likes": 7, "viewed": 223, "published": 3, "date": "1638225151", "time_retrieved": "2024-07-30T18:45:12.033412", "image_code": "// pattern test + wobble = funky gunky\n\n#define PI 3.1415926\n\nfloat mysmooth(float k)\n{\n    //k = step(k,0.0);\n    k = 1.0-smoothstep(0.0,0.02,k);\n    return k;\n}\n\nfloat pat(vec2 uv,float p,float q,float t)\n{\n    float z = cos(q * PI * uv.x) * cos(p * PI * uv.y) + cos(q * PI * uv.y) * cos(p * PI * uv.x);\n    z += sin(t*0.75 + uv.x+uv.y * 101.1)*0.035;\t// +wobble\n    float dist=abs(z);\n    \n    float mid = 0.5;\n    if (iMouse.z>0.5)\n        mid = 0.75;\n    \n    return 1.0-mysmooth(dist-mid);\n}\n\n\n\nvec2 smoothRot(vec2 p,float s,float m,float c,float d){\n  s*=0.5;\n  float k=length(p);\n  float x=asin(sin(atan(p.x,p.y)*s)*(1.0-m))*k;\n  float ds=k*s;\n  float y=mix(ds,2.0*ds-sqrt(x*x+ds*ds),c);\n  return vec2(x/s,y/s-d);\n}\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float md = length(uv);\n    float wo = (0.5+sin(iTime*0.375+10.0*uv.x+10.0*uv.y)*0.5)*0.05;\n    float shape = mysmooth(length(uv)-(0.35+wo));\n    uv*=rotate(iTime*0.1+md*0.4);\n    float t = iTime*0.25;\n    float cen = sin(t*0.05)*0.5;\n    uv = smoothRot(uv, 4.0, 0.1, 4.0, cen);\n    vec2 pq = vec2(0.0);\n    pq.x = 4.0+sin(t*0.42)*2.0;\n    pq.y = 3.0+sin(t*0.61)*1.7;\n    float sca = 4.0+sin(t*0.1)*1.5;\n    float d = 0.5+pat(uv, pq.x,pq.y,t);\t\t// layer1\n    d *= 1.+pat(uv, pq.y*sca, pq.x*sca,t);\n    d*=shape;\n    vec3 c1 = vec3(0.3,0.45,1.);\n    vec3 c2 = vec3(0.9,0.55,0.45);\n    c1 = mix(c1,c2,0.5+sin(sin(md*2.0)+iTime)*0.5);\n    fragColor = vec4(c1*d,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slKGRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 87, 110, 162], [164, 164, 208, 208, 497], [501, 501, 556, 556, 723], [725, 725, 747, 747, 814], [820, 820, 877, 877, 1615]], "test": "untested"}
{"id": "ftV3Rt", "name": "characters crumpled paper", "author": "FabriceNeyret2", "description": "in the spirit of Richard Sweeney paper sculpture (\"fluid forms\") - variant of origami with open folds.\nSee https://www.google.com/search?q=paper+scupture%3A+fluid+forms&tbm=isch\nhttps://richardsweeney.co.uk/", "tags": ["gradient", "short", "origami", "reproduction", "folds", "paperscupture", "fluidforms"], "likes": 11, "viewed": 387, "published": 3, "date": "1638195856", "time_retrieved": "2024-07-30T18:45:12.901093", "image_code": "float z = 4./360.;                     // characters size\n\nvoid mainImage( out vec4 O, vec2 U ) {\n    if (iMouse.z>0.) z /= .5 + 4.*iMouse.y/iResolution.y; // mouse zoom\n    U *= z;\n    U += mod(iTime/vec2(1,16.),16.) ;\n    \n    vec2 G = texture(iChannel0,  U / 16.).gb - .5,\n         F = fract(U)  *2. - 1.,\n         I = floor(U); \n         G.y = -G.y;\n\n    G = mix(.3*F, G, smoothstep(1.,.5, max(abs(F.x),abs(F.y))));\n // G = mix(.4*F, G, smoothstep(1.,.7, length(F)));\n    G *=  mod(I,2.)*2.  - 1.; // checker-reverse char depth for slope continuity\n\n    O = vec4( .5+dot( G , cos(iTime+vec2(0,11)) ) ); \n // O = vec4(.5+G,0,0);       // test: show colors\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftV3Rt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 97, 97, 660]], "test": "untested"}
{"id": "ftK3zt", "name": "Patterns 02", "author": "andrinr", "description": "playing around with lines", "tags": ["sinus"], "likes": 1, "viewed": 177, "published": 3, "date": "1638195786", "time_retrieved": "2024-07-30T18:45:13.682004", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uvs = fragCoord/iResolution.xy;\n    \n    vec2 uvc =  uvs - vec2(0.5) +\n        vec2(0.1*sin(iTime*0.3),0.1*cos(iTime*0.4));\n    \n    vec2 uv = fract(uvc*uvc*uvc * 14.0);\n    \n    \n    float d = sqrt(uv.x*uv.x+uv.y*uv.y);\n\n    float c = clamp(sin(d*50.0 + 12.0 *-iTime), 0.0, 1.0);\n\n    float r = max(c*d, 0.0);\n\n    // Output to screen\n    fragColor = vec4(vec3(r, r*0.3*d, 0.4),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftK3zt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 108, 504]], "test": "untested"}
{"id": "NlKGRt", "name": "connect components in truchets 6", "author": "FabriceNeyret2", "description": "WIP: Proceduraly fills a shape with 1 stroke is Tyler Foust spirit ( see below )\nSPACE: restart a new truchet tiling. \nR: reset ids  (do it when apparently monocolor: some id errors for now)\nclick: swap tile manually", "tags": ["flood", "connected", "doodles", "reproduction", "reproduction", "truchets", "streamreduction"], "likes": 15, "viewed": 417, "published": 3, "date": "1638191101", "time_retrieved": "2024-07-30T18:45:14.455935", "image_code": "// shape bounded variant of https://shadertoy.com/view/NtV3zV\n// connecting components in https://shadertoy.com/view/NlGGRV\n// more accelerated variant of https://shadertoy.com/view/stKGzG\n// accelerated variant of https://shadertoy.com/view/7ty3zG\n\n#define hue(v)  (v==.5?vec4(0): vec4( .6 + .6 * cos( .5+(v)  + vec3(0,23,21)  ) , 1 ))\n\n// #define length(v) ( abs(v.x)+abs(v.y) ) // variant with straight lines\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n // O = T(u).agbr; return;\n    vec2 U = N * u / R.y + 0.*iTime, I = floor(U), F = fract(U);\n         \n    O = T(I);                                          // cell states \n    O.w > 0. ? F = vec2(1.-F.y,F.x) : F;\n    \n    O =   smoothstep(N*1.5/R.y,0.,abs(min(length(F),length(1.-F))-.5) ) // truchet drawing\n        * hue( O[ F.x+F.y < 1. ? 1 : 2 ] );            // coloring\n         \n // if (iMouse.z>0.) O += (1.-O.w)*.3*mod(I.x+I.y,2.); // debug: draw tiles\n // O += .3*T(I).w;\n} ", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define H(p)         fract(sin(dot(p, vec2(12.9898, 78.233))-iTime) * 43758.5453)\n#define keyDown(c) ( texelFetch(iChannel3,ivec2(c,1),0).x > 0.)\n\n#define mask         ( length(P-vec2(.6,0))  < .9 && length( P-vec2(.2,0) ) > .7 )   \\\n                  || ( length(P+vec2(.8,0))  < .9 && length( P+vec2(.7,.4) ) > .4 )\n#define set_Id       { O.x = 1.; O.yz = mask ? (1.+U.x+4096.*U.y)*vec2(1,-1) : vec2(.5) ; }\n                  // yz: id of tile segment #1 and #2.  x=1: each time you want to forbid optim on next frame\n                  \nvoid mainImage( out vec4 O, vec2 U )\n{\n    U -= .5;\n    float Nx = floor(N*R.x/R.y);\n    vec2 P = ( 2.*U - vec2(Nx,N) ) / N;\n    if ( iFrame < 1 || keyDown(32) ) {        // --- init: create truchet\n        vec2 I = U;                           // store truchet data\n        O-=O;\n        O.w = mask    \n               ? O.w = step(.5,H(I))          // random axis\n               : mod(I.x+I.y,2.);\n        set_Id;                               // set id of tile segment #1 and #2\n        return;\n    }\n    \n    O = T(U);                                 // previous state\n    vec4 T;\n    if (U.x <= Nx && U.y >= N+4. && U.y <= N+N+4.) // --- keep previous version\n      { U.y -= N+4.; O = T(U); return; }\n      \n    if (U.x >= Nx+4. && U.x <= Nx+4.+Nx/8. && U.y <= N/8.) { // --- reduction map of change\n        O-=O;\n        U.x -= Nx+4.;\n        for (int k=0; k < 64; k++ ) {\n            vec2 V = 8.*U + vec2(k%8,k/8),\n                 o = T(V + vec2(0.,N+4.)).yz, // old vs new value\n                 n = T(V).yz; if ( T(V).x!=0.) continue;\n         // if ( o != n ) O = vec4(o,n);      // if changed, store ( why break worse ? )\n         // if ( o != n ) { O = vec4(o,n); break; } // why worse ? \n            if ( o.x != n.x ) O.xz = vec2(o.x,n.x); // if changed, store \n            if ( o.y != n.y ) O.yw = vec2(o.y,n.y);\n            if (O.x*O.y!=0.) break;\n        }\n        return;\n    }\n    if (U.x > Nx || U.y > N) return;          // propagate only visible tiles\n\n                                              // --- propagate id along connections\n#define Tc(U)      T(mod(U,vec2(Nx,N)))\n#define left       Tc(U+vec2(1,0)).y\n#define right      Tc(U-vec2(1,0)).z\n#define bot      ( T = Tc(U+vec2(0,1)), T.w<1. ? T.y : T.z )\n#define top      ( T = Tc(U-vec2(0,1)), T.w<1. ? T.z : T.y )\n    if (O.w<1.) { // tile contains:  \\     new id = min(connections)\n        O.y = min( O.y, min( right, top ));\n        O.z = min( O.z, min( left , bot ));\n    }\n    else {        // tile contains:  /     new id = min(connections)\n        O.y = min( O.y, min( right, bot ));\n        O.z = min( O.z, min( left , top ));\n    }\n    \n  if (T().x > 0.||O.x>0.) {  O.x-- ; return; }// timer: let re-converge before optime\n  if ( O.y==.5 || O.z==.5 ) return;           // don't touch outside tiles           \n\n                  // --- shortcut2: at color change, update the color source pixel\n    for( float j = 0.; j < N/8.; j++)\n        for( float i = 0.; i < Nx/8.; i++) {\n            T = T( vec2(Nx+4.+i,j) );\n            vec2 o = T.xy, n = T.zw;          // changed old->new value\n            if (O.y==o.x) O.y = n.x, O.x=1.;  // oldvalue was my seg1 : update\n            if (O.y==o.y) O.y = n.y, O.x=1.;\n            if (O.z==o.x) O.z = n.x, O.x=1.;  // oldvalue was my seg2 : update\n            if (O.z==o.y) O.z = n.y, O.x=1.;\n        }\n\n//if ( O.y==.5 || O.z==.5 ) return;           // don't touch outside tiles           \n        \n  if (keyDown(64+18))  set_Id; // key 'R' to reset ids\n  if (iMouse.w>0. && U == floor(iMouse.xy/R.y*N) && O.y!=O.z ) O.w = 1.-O.w; // mouse click for swap\n  if (U == vec2(0) && ( keyDown(64+18) || iMouse.w>0. ) ) O.x = 1.; // let re-converge \n//if (T().x > 0.||O.x>0.) {  O.x-- ; return; }     // timer: let re-converge befor optim\n//return;\n                 // --- connect them all : at block connection, swap\n    if ( iFrame%10==9 && O.y != O.z && H(U) >.995 ) // should be done after convergence, and not on parallel on same block\n        O.w = 1.-O.w, O.x=1.;\n} ", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float N = 64.; // vertical number of tiles\n\n#define R    iResolution.xy\n#define T(U) texelFetch( iChannel0, ivec2(U+R)%ivec2(R), 0 )", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlKGRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[413, 413, 451, 478, 936]], "test": "untested"}
{"id": "ftK3Rt", "name": "Bucking Bronco", "author": "dr2", "description": "Don't fall off", "tags": ["kinematics"], "likes": 25, "viewed": 424, "published": 3, "date": "1638191101", "time_retrieved": "2024-07-30T18:45:15.238842", "image_code": "// \"Bucking Bronco\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrTorusBxDf (vec3 p, vec3 b, float ri);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nvec3 HsvToRgb (vec3 c);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\n\nvec3 ltPos[3], ltCol[3], pUp, qHit;\nvec2 aRotCs[3];\nfloat tCur, dstFar, movFac, platRad[2];\nint idObj;\nconst int idTube = 1, idBall = 2, idBase = 3, idLeg = 4, idPlat = 5, idSeat = 6, idGrip = 7; \nconst float pi = 3.1415927;\n\nstruct TbCon {\n  vec3 pLo, pHi;\n  vec2 aLimCs, tRotCs[2], pRotCs[2];\n  float chLen, chDist, ang, rad;\n};\nTbCon tbCon[4];\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\n#define F(x) (sin (x) / x - b)\n\nfloat SecSolve (float b)\n{  // (from \"Robotic Head\")\n  vec3 t;\n  vec2 f;\n  float x;\n  if (b < 0.95) {\n    t.yz = vec2 (0.7, 1.2);\n    f = vec2 (F(t.y), F(t.z));\n    for (int nIt = 0; nIt < 4; nIt ++) {\n      t.x = (t.z * f.x - t.y * f.y) / (f.x - f.y);\n      t.zy = t.yx;\n      f = vec2 (F(t.x), f.x);\n    }\n    x = t.x;\n  } else if (b < 1.) {\n    x = sqrt (10. * (1. - sqrt (1. - 1.2 * (1. - b))));\n  } else {\n    x = 0.;\n  }\n  return x;\n}\n\nvoid SetConf ()\n{\n  vec3 vp;\n  float tubeLen, t, h, rm, a[3];\n  movFac = SmoothBump (0.15, 0.85, 0.07, mod (0.05 * tCur, 1.));\n  t = 1.5 * tCur;\n  platRad[0] = 3.3;\n  platRad[1] = 1.;\n  rm = 0.55 * (platRad[1] - platRad[0]);\n  h = 0.1 + movFac * 0.9 * (1.2 + 0.6 * sin (2.3 * t));\n  tubeLen = length (vec2 (platRad[1] - platRad[0], 2.));\n  pUp.xz = movFac * Rot2D (vec2 (rm, 0.), t + 0.5 * (Fbm1 (t) - 0.5));\n  pUp.y = h;\n  a[0] = movFac * 0.1 * pi * sin (2.7 * t);\n  a[1] = movFac * 0.1 * pi * sin (2.9 * t);\n  a[2] = movFac * pi * (Fbm1 (0.5 * t) - 0.5) + 0.25 * pi;\n  aRotCs[0] = sin (a[0] + vec2 (0.5 * pi, 0.));\n  aRotCs[1] = sin (a[1] + vec2 (0.5 * pi, 0.));\n  aRotCs[2] = sin (a[2] + vec2 (0.5 * pi, 0.));\n  for (int k = 0; k < 4; k ++) {\n    tbCon[k].pLo = vec3 (Rot2D (vec2 (platRad[0] + 0.11, 0.), float (k) * 0.5 * pi), - h).xzy;\n    tbCon[k].pHi = vec3 (Rot2D (vec2 (platRad[1] + 0.11, 0.), float (k) * 0.5 * pi) + pUp.xz,\n       pUp.y).xzy;\n    tbCon[k].pHi.xy = Rot2D (tbCon[k].pHi.xy, - a[0]);\n    tbCon[k].pHi.zy = Rot2D (tbCon[k].pHi.zy, - a[1]);\n    vp = tbCon[k].pHi - tbCon[k].pLo;\n    tbCon[k].pLo.y += h;\n    tbCon[k].pHi.y += pUp.y;\n    tbCon[k].chLen = 0.5 * length (vp);\n    tbCon[k].tRotCs[0] = sin (atan (vp.x, vp.z) + vec2 (0.5 * pi, 0.));\n    tbCon[k].tRotCs[1] = sin (- asin (length (vp.xz) / length (vp)) + vec2 (0.5 * pi, 0.));\n    tbCon[k].ang = SecSolve (tbCon[k].chLen / tubeLen);\n    tbCon[k].chDist = tbCon[k].chLen / tan (tbCon[k].ang);\n    tbCon[k].rad = length (vec2 (tbCon[k].chDist, tbCon[k].chLen));\n    tbCon[k].aLimCs = sin (- tbCon[k].ang + vec2 (0.5 * pi, 0.));\n  }\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, a;\n  dMin = dstFar;\n  p.y -= 0.36;\n  q = p;\n  q.y -= -0.05;\n  d = PrRoundCylDf (q.xzy, platRad[0] + 0.03, 0.02, 0.04);\n  DMINQ (idBase);\n  q.y -= -0.22;\n  q.xz = abs (q.xz) - 0.63 * platRad[0];\n  d = PrCylDf (q.xzy, 0.1 * platRad[0], 0.15);\n  DMINQ (idLeg);\n  for (int k = 0; k < 4; k ++) {\n    d = PrSphDf (p - tbCon[k].pLo, 0.1);\n    DMINQ (idBall);\n  }\n  q = p;\n  q.y -= pUp.y;\n  q.xy = Rot2Cs (q.xy, aRotCs[0]);\n  q.zy = Rot2Cs (q.zy, aRotCs[1]);\n  q -= pUp;\n  q.y -= -0.1;\n  d = PrRoundCylDf (q.xzy, platRad[1] + 0.07, 0.02, 0.04);\n  DMINQ (idPlat);\n  q.y -= 0.3;\n  d = PrCylDf (q.xzy, 0.15, 0.25);\n  DMINQ (idSeat);\n  q.y -= 0.33;\n  q.xz = Rot2Cs (q.xz, aRotCs[2]);\n  d = PrRoundBoxDf (q, vec3 (0.4, 0.15, 0.08), 0.1);\n  DMINQ (idSeat);\n  q.xy -= vec2 (0.3, 0.25);\n  d = PrTorusBxDf (q.yzx, vec3 (0.25, 0.12, 0.08), 0.03);\n  DMINQ (idGrip);\n  for (int k = 0; k < 4; k ++) {\n    d = PrSphDf (p - tbCon[k].pHi, 0.1);\n    DMINQ (idBall);\n  }\n  for (int k = 0; k < 4; k ++) {\n    q = p - tbCon[k].pLo;\n    q.xz = Rot2Cs (q.xz, tbCon[k].tRotCs[0]);\n    q.yz = Rot2Cs (q.yz, tbCon[k].tRotCs[1]) - vec2 (tbCon[k].chLen, tbCon[k].chDist);\n    a = fract ((128. / tbCon[k].ang) * atan (q.y, - q.z) / (2. * pi));\n    d = max (dot (vec2 (abs (q.y), - q.z), tbCon[k].aLimCs), length (vec2 (length (q.yz) -\n       tbCon[k].rad, q.x)) - (0.08 - 0.012 * smoothstep (0.15, 0.35, 0.5 - abs (0.5 - a))));\n    DMINQ (idTube);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.001 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dMax)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.001 || d > dMax) break;\n  }\n  return 0.3 + 0.7 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, ltDir, ltAx, c;\n  vec2 u;\n  float dstObj, nDotL, sh, att, ltDst, a, r;\n  bool isMet;\n  SetConf ();\n  dstObj = ObjRay (ro, rd);\n  col = vec3 (0.);\n  isMet = false;\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == idTube) {\n      col4 = vec4 (0.8, 0.8, 0.9, 0.3);\n      isMet = true;\n    } else if (idObj == idBall) {\n      col4 = vec4 (0.9, 0.7, 0.4, 0.3);\n      isMet = true;\n    } else if (idObj == idBase) {\n      r = length (qHit.xz);\n      col4 = vec4 (0.5, 0.6, 0.4, 0.1) * (0.85 + 0.15 * smoothstep (0., 0.05,\n         abs (r - 1.1 * platRad[1])));\n      u = Rot2D (qHit.xz, pi / 16.);\n      a = (r > 0.) ? atan (u.y, - u.x) / (2. * pi) : 0.;\n      u = Rot2D (u, 2. * pi * (floor (16. * a + 0.5) / 16.));\n      if (length (u + vec2 (platRad[0] - 0.3, 0.)) < 0.15) col4 = vec4 (((movFac > 0.2) ?\n         HsvToRgb (vec3 (mod (a + 0.5 * pi * tCur, 1.), 1., 1.)) :\n         vec3 (1., 1., 0.) * (0.8 + 0.2 * sin (16. * pi * tCur))), -1.);\n    } else if (idObj == idLeg) {\n      col4 = vec4 (0.5, 0.6, 0.4, 0.1);\n    } else if (idObj == idPlat) {\n      col4 = vec4 (0.6, 0.5, 0.7, 0.2);\n      r = length (qHit.xz);\n      u = Rot2D (qHit.xz, pi / 8.);\n      a = (r > 0.) ? atan (u.y, - u.x) / (2. * pi) : 0.;\n      u = Rot2D (u, 2. * pi * (floor (8. * a + 0.5) / 8.));\n      if (length (u + vec2 (platRad[1] - 0.15, 0.)) < 0.1)\n         col4 = vec4 (((movFac > 0.) ? vec3 (1., 0., 0.) : vec3 (0., 1., 0.)), -1.);\n    } else if (idObj == idSeat) {\n      col4 = vec4 (0.7, 0.5, 0.1, 0.2);\n    } else if (idObj == idGrip) {\n      col4 = vec4 (1., 0.5, 0.5, 0.2);\n      isMet = true;\n    }\n  } else if (rd.y < 0.) {\n    dstObj = - ro.y / rd.y;\n    ro += dstObj * rd;\n    vn = vec3 (0., 1., 0.);\n    u = ro.xz;\n    col4 = vec4 (0.6, 0.5, 0.5, 0.1) * (1. - 0.2 * Fbm2 (4. * u));\n    u = abs (fract (u + 0.5) - 0.5);\n    col4.rgb *= (1. - 0.15 * smoothstep (0.05, 0.08,\n       abs (max (abs (u.x + u.y), abs (u.x - u.y)) - 0.2) - 0.2)) *\n       (1. - 0.15 * smoothstep (0.05, 0.08, length (max (u - 0.42, 0.))));\n  }\n  if (dstObj < dstFar) {\n    if (col4.a >= 0.) {\n      for (int k = VAR_ZERO; k < 3; k ++) {\n        ltDir = ltPos[k] - ro;\n        ltDst = length (ltDir);\n        ltDir /= ltDst;\n        ltAx = normalize (ltPos[k] - vec3 (0., 2., 0.));\n        att = smoothstep (0., 0.02, dot (ltDir, ltAx) - 0.97);\n        sh = (dstObj < dstFar) ? ObjSShadow (ro + 0.01 * vn, ltDir, ltDst) : 1.;\n        nDotL = max (dot (vn, ltDir), 0.);\n        if (isMet) nDotL *= nDotL * nDotL;\n        c = att * ltCol[k] * (col4.rgb * (0.1 + 0.9 * sh * nDotL) +\n           col4.a * step (0.95, sh) * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.));\n        col += c * c;\n      }\n      col = sqrt (col);\n    } else col = col4.rgb * (0.5 + 0.5 * max (0., - dot (vn, rd)));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.2 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.03 * pi * tCur;\n    el += 0.08 * pi * cos (0.02 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, -0.01 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 1.5, -20.);\n  for (int k = VAR_ZERO; k < 3; k ++) {\n    ltPos[k] = vec3 (0., 30., 0.);\n    ltPos[k].xy = Rot2D (ltPos[k].xy, 0.25 * pi * (1. + 0.2 * sin (0.05 * pi * tCur -\n       pi * float (k) / 3.)));\n    ltPos[k].xz = Rot2D (ltPos[k].xz, -0.1 * pi * tCur + 2. * pi * float (k) / 3.);\n  }\n  ltCol[0] = vec3 (1., 0.2, 0.2);\n  ltCol[1] = ltCol[0].gbr;\n  ltCol[2] = ltCol[0].brg;\n  zmFac = 4.2;\n  dstFar = 60.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrTorusBxDf (vec3 p, vec3 b, float ri)\n{\n  return length (vec2 (length (max (abs (p.xy) - b.xy, 0.)) - b.z, p.z)) - ri;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. -\n     3.) - 1., 0., 1.), c.y);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftK3Rt.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1141, 1141, 1167, 1193, 1581], [1583, 1583, 1600, 1600, 3197], [3199, 3199, 3221, 3221, 4681], [4683, 4683, 4716, 4716, 4963], [4965, 4965, 4986, 4986, 5241], [5243, 5243, 5292, 5292, 5534], [5536, 5536, 5571, 5571, 8431], [8433, 8433, 8489, 8489, 9894], [9896, 9896, 9942, 9942, 9989], [9991, 9991, 10037, 10037, 10118], [10120, 10120, 10153, 10153, 10180], [10182, 10182, 10224, 10224, 10275], [10277, 10277, 10334, 10334, 10410], [10412, 10412, 10436, 10436, 10558], [10560, 10560, 10617, 10617, 10700], [10702, 10702, 10738, 10738, 10944], [10946, 10946, 10976, 10976, 11089], [11091, 11091, 11122, 11122, 11186], [11220, 11220, 11244, 11244, 11297], [11299, 11299, 11323, 11323, 11435], [11437, 11437, 11462, 11462, 11608], [11610, 11610, 11635, 11635, 11821], [11823, 11823, 11845, 11845, 11999], [12001, 12001, 12022, 12022, 12177]], "test": "untested"}
{"id": "styGzt", "name": "Mosaic fractal", "author": "jarble", "description": "A colorful mosaic pattern.", "tags": ["fractal", "mosaic"], "likes": 10, "viewed": 411, "published": 3, "date": "1638168699", "time_retrieved": "2024-07-30T18:45:16.075605", "image_code": "//change these constants to get different patterns!\n#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n    //return abs(fract((a+c1.xy)*scale+iTime/500.)-.5); //morphing\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 36.;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    for(int i=0;i<9;i++)\n    {\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 0; k < 3; k++){    \n            uv /= -scale;\n            uv -= (t2.yx)/(scale);\n            //uv -= (t2.yx)/(scale-t3.yx);\n            t2 = triangle_wave(-uv-.5,scale);\n            t3 = -triangle_wave(-uv.yx,scale);\n            //t3 = -triangle_wave(-uv.yx+.5/scale,scale);\n            \n            uv.yx = (t2+t3);\n            uv /= scale;\n            //uv /= scale+uv.yx;\n            //scale *= 1.005;\n            //uv.yx = (t2-t3)/scale;\n\n        }\n        col.x = abs(uv.y-uv.x+col.x);\n        col = col.yzx;\n    }\n    fragColor = vec4(col,1.0);   \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/styGzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 120, 120, 232], [234, 234, 291, 291, 1148]], "test": "untested"}
{"id": "slG3zK", "name": "Segments: Sacred Bearings", "author": "Yusef28", "description": "A segment exercise", "tags": ["circles", "lines", "practice", "segments"], "likes": 22, "viewed": 478, "published": 3, "date": "1638160551", "time_retrieved": "2024-07-30T18:45:16.840559", "image_code": "#define pi acos(-1.)\n#define eps 9./iResolution.y\n\n\n#define maxPoints 16.\n#define screenSize 2.9\nfloat rnd(vec2 id){\n    return sin(fract(dot(id,vec2(14.27,74.97)))*54329.34);\n}\nmat2 rot(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat point(vec2 uv, float r){\n    return smoothstep(r+eps,r-eps,length(uv));\n}\n\nfloat ring(vec2 uv, float r){\n    return smoothstep(eps+0.01, 0., abs(length(uv)-r+0.01));\n}\n\nfloat line(vec2 P, vec2 A, vec2 B, float r){\n    vec2 PA = P-A;\n    vec2 AB = B-A;\n    //dot(AB,P-P3) = 0\n    //dot(AB,P-AB*t)\n    float t = clamp(dot(PA,AB)/dot(AB,AB),0.,1.);\n    return smoothstep(r+eps,r-eps,length(PA-AB*t));\n   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    uv.x+=iTime*0.5;\n    vec2 id = floor(uv*screenSize);\n    \n    uv = fract(uv*screenSize)*2.-1.;\n    \n    vec2 ringPos = vec2(0.,0.);\n    float radius = 0.5;\n    float ring1 = ring(uv-ringPos, radius);\n    vec3 col = vec3(0.);\n    col += ring1;\n    \n    float mx = 1.+floor(abs(mod(iTime*2.+rnd(id*89.)*831.,\n                        maxPoints)-maxPoints/2.))+1.;\n    vec2 now,last=vec2(0.,radius)*rot(iTime);\n    vec2 first = last;\n    col += ring(uv-last, 0.1);\n    col += point(uv-last, 0.04);\n    \n    for(float i = 1.; i < mx; i++){\n    \n        \n        now = vec2(0.,radius)*rot(iTime+i*pi*2./mx);\n        col += ring(uv-now, 0.1);\n        col += point(uv-now, 0.04);\n        col += line(uv,now,last,0.005);\n        \n        \n        \n        last = now;\n    }\n    col += line(uv,now,first,0.005);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slG3zK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 116, 116, 177], [178, 178, 196, 196, 259], [261, 261, 291, 291, 340], [342, 342, 371, 371, 434], [436, 436, 480, 480, 670], [672, 672, 729, 779, 1701]], "test": "untested"}
{"id": "7lyGRt", "name": "[TDF2021] Quake", "author": "soma_arc", "description": "For Tokyo Demo Fest 2021 GLSL Graphics Compo https://tokyodemofest.jp/", "tags": ["3d", "fractal"], "likes": 5, "viewed": 239, "published": 3, "date": "1638155013", "time_retrieved": "2024-07-30T18:45:17.789024", "image_code": "/*\nCreated by soma_arc - 2021\nThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n\tvec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n\t// implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                 fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nstruct Plane{\n    vec3 p1;\n    vec3 p2;\n    vec3 p3;\n    vec3 normal;\n};\n\n\nconst vec3 BLACK = vec3(0);\nconst vec3 RED = vec3(1, 0, 0);\nconst vec3 LIGHT_POS = vec3(100, 100, 100);\nconst vec3 LIGHT_DIR = normalize(LIGHT_POS);\nconst float AMBIENT_FACTOR = 0.1;\n\nconst float EPSILON = 0.001;\nconst float PI = 3.14159265;\nconst float PI_2 = 3.14159265 / 2.;\nconst float RT_3 = sqrt(3.);\nconst float RT_3_INV = 1.0 / sqrt(3.);\n\nconst Plane PL1 = Plane(vec3(0, 5, RT_3_INV),\n                vec3(1, 1, 0),\n                vec3(2, 2, -RT_3_INV),\n                normalize(vec3(RT_3 * 0.5, 0, 1.5)));\n\nconst Plane PL2 = Plane(vec3(0, 3, -RT_3_INV),\n                        vec3(1, 3, 0),\n                        vec3(2, 2, RT_3_INV),\n                        normalize(vec3(RT_3 * 0.5, 0, -1.5)));\nconst Plane PL3 = Plane(\n    vec3(-0.5, 0, 1),\n    vec3(-0.5, 1, 0),\n    vec3(-0.5, 2, 1),\n    vec3(-1, 0, 0));\n\nvec4 s2, s4, s6;\nvec4 s2A, s4A, s6A;\nvec4 s2B, s4B, s6B;\nvec4 s2C, s4C, s6C;\nvec4 gSpheres0, gSpheres1, gSpheres2, gSpheres3, gSpheres4, gSpheres5;\nvec4 inversionSphere;\n\nvec3 vertexes0, vertexes1, vertexes2, vertexes3, vertexes4,vertexes5, vertexes6, vertexes7;\nPlane dividePlane;\nvec4 convexSphere;\n\nfloat gInvNum = 0.;\nfloat gBoundingPlaneY = -9999999999.;\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nvec3 Hsv2rgb(float h, float s, float v){\n    vec3 c = vec3(h, s, v);\n    const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvoid computeCubeSphairahedronA(float zb, float zc) {\n    float r2 = 0.5 + (zb * zc) / 3.0;\n    float r4 = 0.5 + (zb * zb - zb * zc) / 3.0;\n    float r6 = 0.5 + (-zb * zc + zc * zc) / 3.0;\n    s2 = s2A = vec4(1. - r2, 0, 0, r2);\n    s4 = s4A = vec4(-(1. - r4) * 0.5, zb, sqrt(3.) * (1. - r4) * 0.5, r4);\n    s6 = s6A = vec4(-(1. - r6) * 0.5, zc, -sqrt(3.) * (1. - r6) * 0.5, r6);\n    inversionSphere = vec4(-s6.x, -s6.y, s6.z, s6.w);\n}\n\nvoid computeCubeSphairahedronB(float zb, float zc) {\n    float r2 = (3. * RT_3 + 2. * RT_3 * zb * zc) / 9.0;\n    float r4 = (3. * zb * zb - 4. * zb * zc + 3.) / 9.0;\n    float r6 = (3. * zc * zc - 2. * zb * zc + 6.) / 9.0;\n    s2 = s2B = vec4((2. - RT_3 * r2) * 0.5, 0, r2 * 0.5, r2);\n    s4 = s4B = vec4(-(1. - r4) * 0.5, zb, RT_3 * (1. - r4) * 0.5, r4);\n    s6 = s6B = vec4(-(1. - r6) * 0.5, zc, -RT_3 * (1. - r6) * 0.5, r6);\n    inversionSphere = vec4(-s6.x, -s6.y, s6.z, s6.w);\n}\n\nvoid computeCubeSphairahedronC(float zb, float zc) {\n    float r2 = (zb * zb + 2. * zb * zc + 6.) / (5. * RT_3);\n    float r4 = (3. * zb * zb - 4. * zb * zc + 3.) / (5. * RT_3);\n    float r6 = (-zb * zb - 2. * zb * zc + 5. * zc * zc + 9.) / 15.0;\n    s2 = s2C = vec4((2. - RT_3 * r2) * 0.5, 0, r2 * 0.5, r2);\n    s4 = s4C = vec4(-0.5, zb, RT_3 / 2. - r4, r4);\n    s6 = s6C = vec4(-(1. - r6) * 0.5, zc, -RT_3 * (1. - r6) * 0.5, r6);\n    inversionSphere = vec4(-s6.x, -s6.y, s6.z, s6.w);\n}\n\n\nfloat MAX_FLOAT = 1e20;\nconst float THRESHOLD = 0.001;\n\nbool intersectBoundingPlane(const vec3 n, const vec3 p,\n\t\t\t\t\t\t\tconst vec3 rayOrigin, const vec3 rayDir,\n\t\t\t\t\t\t\tinout float t0, inout float t1) {\n\tfloat d = -dot(p, n);\n    float v = dot(n, rayDir);\n    float t = -(dot(n, rayOrigin) + d) / v;\n    if(THRESHOLD < t){\n\t\tif(v < 0.) {\n\t\t\tt0 = max(t, t0);\n\t\t\tt1 = MAX_FLOAT;\n\t\t} else {\n\t\t\tt0 = t0;\n\t\t\tt1 = t;\n\t\t}\n\t\treturn true;\n    }\n    t0 = t0;\n    t1 = MAX_FLOAT;\n\treturn (v < 0.);\n}\n\n/*\nfloat[12] pivoting(float[12] mat, int n, int k){\n    int col = k;\n    float maxValue = abs(mat[k*4 + k]);\n    for (int i = k + 1; i < n; i++) {\n        if (abs(mat[i*4 + k]) > maxValue) {\n            col = i;\n            maxValue = abs(mat[i*4 + k]);\n        }\n    }\n    if (k != col) {\n        float tmp[4];\n        tmp[0] = mat[col*4 + 0];\n        tmp[1] = mat[col*4 + 1];\n        tmp[2] = mat[col*4 + 2];\n        tmp[3] = mat[col*4 + 3];\n        mat[col*4 + 0] = mat[k*4 + 0];\n        mat[col*4 + 1] = mat[k*4 + 1];\n        mat[col*4 + 2] = mat[k*4 + 2];\n        mat[col*4 + 3] = mat[k*4 + 3];\n        mat[k*4 + 0] = tmp[0];\n        mat[k*4 + 1] = tmp[1];\n        mat[k*4 + 2] = tmp[2];\n        mat[k*4 + 3] = tmp[3];\n    }\n    return mat;\n}\n*/\n\nvec4 sphereFromPoints(vec3 p0, vec3 p1, vec3 p2, vec3 p3){\n    /*\n    float coefficient[12];\n    for (int i = 0; i < 3; i++) {\n        coefficient[i * 4 + 0] = 2. * (p[i + 1].x - p[i].x);\n        coefficient[i * 4 + 1] = 2. * (p[i + 1].y - p[i].y);\n        coefficient[i * 4 + 2] = 2. * (p[i + 1].z - p[i].z);\n        coefficient[i * 4 + 3] = -(pow(p[i].x, 2.) + pow(p[i].y, 2.) + pow(p[i].z, 2.)) +\n                pow(p[i + 1].x, 2.) + pow(p[i + 1].y, 2.) + pow(p[i + 1].z, 2.);\n    }\n    */\n    float coefficient0, coefficient1, coefficient2, coefficient3, coefficient4;\n    float coefficient5, coefficient6, coefficient7, coefficient8, coefficient9;\n    float coefficient10, coefficient11;\n    coefficient0 = 2. * (p1.x - p0.x);\n    coefficient1 = 2. * (p1.y - p0.y);\n    coefficient2 = 2. * (p1.z - p0.z);\n    coefficient3 = -(pow(p0.x, 2.) + pow(p0.y, 2.) + pow(p0.z, 2.)) +\n                     pow(p1.x, 2.) + pow(p1.y, 2.) + pow(p1.z, 2.);\n    coefficient4 = 2. * (p2.x - p1.x);\n    coefficient5 = 2. * (p2.y - p1.y);\n    coefficient6 = 2. * (p2.z - p1.z);\n    coefficient7 = -(pow(p1.x, 2.) + pow(p1.y, 2.) + pow(p1.z, 2.)) +\n                     pow(p2.x, 2.) + pow(p2.y, 2.) + pow(p2.z, 2.);\n    coefficient8 = 2. * (p3.x - p2.x);\n    coefficient9 = 2. * (p3.y - p2.y);\n    coefficient10 = 2. * (p3.z - p2.z);\n    coefficient11 = -(pow(p2.x, 2.) + pow(p2.y, 2.) + pow(p2.z, 2.)) +\n                      pow(p3.x, 2.) + pow(p3.y, 2.) + pow(p3.z, 2.);\n    \n    /*\n    const int n = 3;\n    for (int k = 0; k < n - 1; k++) {\n        coefficient = pivoting(coefficient, n, k);\n\n        float vkk = coefficient[k * 4 + k];\n        for (int i = k + 1; i < n; i++) {\n            float vik = coefficient[i * 4 + k];\n            for (int j = k; j < n + 1; ++j) {\n                coefficient[i * 4 + j] = coefficient[i*4 + j] - vik * (coefficient[k * 4 + j] / vkk);\n            }\n        }\n    }\n    \n    coefficient[(n - 1) * 4 + n] = coefficient[(n - 1) * 4 + n] / coefficient[(n - 1) * 4 + n - 1];\n    for (int i = n - 2; i >= 0; i--) {\n        float acc = 0.0;\n        for (int j = i + 1; j < n; j++) {\n            acc += coefficient[i * 4 + j] * coefficient[j * 4 + n];\n        }\n        coefficient[i * 4 + n] = (coefficient[i * 4 + n] - acc) / coefficient[i * 4 + i];\n    }\n    */\n        //coefficient = pivoting(coefficient, 3, 0);\n    int col = 0;\n    float maxValue = abs(coefficient0);\n    if (abs(coefficient4) > maxValue) {\n        col = 1;\n        maxValue = abs(coefficient4);\n    }\n    if (abs(coefficient8) > maxValue) {\n        col = 2;\n        maxValue = abs(coefficient8);\n    }\n    \n    if (col == 1) {\n        float tmp0 = coefficient4;\n        float tmp1 = coefficient5;\n        float tmp2 = coefficient6;\n        float tmp3 = coefficient7;\n        coefficient4 = coefficient0;\n        coefficient5 = coefficient1;\n        coefficient6 = coefficient2;\n        coefficient7 = coefficient3;\n        coefficient0 = tmp0;\n        coefficient1 = tmp1;\n        coefficient2 = tmp2;\n        coefficient3 = tmp3;\n    }\n    \n    if (col == 2) {\n        float tmp0 = coefficient8;\n        float tmp1 = coefficient9;\n        float tmp2 = coefficient10;\n        float tmp3 = coefficient11;\n        coefficient8 = coefficient0;\n        coefficient9 = coefficient1;\n        coefficient10 = coefficient2;\n        coefficient11 = coefficient3;\n        coefficient0 = tmp0;\n        coefficient1 = tmp1;\n        coefficient2 = tmp2;\n        coefficient3 = tmp3;\n    }\n\n    \n        float vkk = coefficient0;\n        float vik = coefficient4;    \n        coefficient4 = coefficient4 - vik * (coefficient0 / vkk);\n        coefficient5 = coefficient5 - vik * (coefficient1 / vkk);\n        coefficient6 = coefficient6 - vik * (coefficient2 / vkk);\n        coefficient7 = coefficient7 - vik * (coefficient3 / vkk);\n    \n        vik = coefficient8;            \n        coefficient8 = coefficient8 - vik * (coefficient0 / vkk);\n        coefficient9 = coefficient9 - vik * (coefficient1 / vkk);\n        coefficient10 = coefficient10 - vik * (coefficient2 / vkk);\n        coefficient11 = coefficient11 - vik * (coefficient3 / vkk);\n\n        \n        //coefficient = pivoting(coefficient, 3, 1);\n    col = 1;\n    maxValue = abs(coefficient5);\n    \n        if (abs(coefficient9) > maxValue) {\n            col = 2;\n            maxValue = abs(coefficient9);\n        }\n    \n    if (col == 2) {\n        float tmp0 = coefficient8;\n        float tmp1 = coefficient9;\n        float tmp2 = coefficient10;\n        float tmp3 = coefficient11;\n        coefficient8 = coefficient4;\n        coefficient9 = coefficient5;\n        coefficient10 = coefficient6;\n        coefficient11 = coefficient7;\n        coefficient4 = tmp0;\n        coefficient5 = tmp1;\n        coefficient6 = tmp2;\n        coefficient7 = tmp3;\n    }\n\n        vkk = coefficient5;\n        vik = coefficient9;\n            \n        coefficient9 = coefficient9 - vik * (coefficient5 / vkk);\n        coefficient10 = coefficient10 - vik * (coefficient6 / vkk);\n        coefficient11 = coefficient11 - vik * (coefficient7 / vkk);\n\n\n    \n    coefficient11 = coefficient11 / coefficient10;\n\n    float acc = 0.0;\n    acc += coefficient6 * coefficient11;\n        \n    coefficient7 = (coefficient7 - acc) / coefficient5;\n        \n    acc = 0.0;\n    acc += coefficient1 * coefficient7;\n    acc += coefficient2 * coefficient11;\n\n    coefficient3 = (coefficient3 - acc) / coefficient0;\n    \n    //vec3 center = vec3(coefficient[0 * 4 + 3], coefficient[1 * 4 + 3], coefficient[2 * 4 + 3]);\n    vec3 center = vec3(coefficient3, coefficient7, coefficient11);\n    float r = length(center - p0);\n    return vec4(center, r);\n}\n\nvec3 invertOnPoint(vec4 sphere, vec3 p) {\n    vec3 d = p - sphere.xyz;\n    float len = length(d);\n    return d * (sphere.r * sphere.r / (len * len)) + sphere.xyz;\n}\n\nvec4 invertOnSphere(vec4 invSphere, vec4 s) {\n    float r = s.w;\n    float coeffR = r * RT_3 / 3.;\n    vec3 p1 = invertOnPoint(invSphere, s.xyz + vec3(coeffR, coeffR, coeffR));\n    vec3 p2 = invertOnPoint(invSphere, s.xyz + vec3(-coeffR, -coeffR, -coeffR));\n    vec3 p3 = invertOnPoint(invSphere, s.xyz + vec3(coeffR, -coeffR, -coeffR));\n    vec3 p4 = invertOnPoint(invSphere, s.xyz + vec3(coeffR, coeffR, -coeffR));\n    return sphereFromPoints(p1, p2, p3, p4);\n}\n\nvec4 invertOnPlane(vec4 invSphere, Plane p) {\n    return sphereFromPoints(invertOnPoint(invSphere, p.p1),\n                            invertOnPoint(invSphere, p.p2),\n                            invertOnPoint(invSphere, p.p3),\n                            invSphere.xyz);\n}\n\nvoid computeGSpheres(){\n    gSpheres0 = invertOnPlane(inversionSphere, PL1);\n    gSpheres1 = invertOnSphere(inversionSphere, s2);\n    gSpheres2 = invertOnPlane(inversionSphere, PL2);\n    gSpheres3 = invertOnSphere(inversionSphere, s4);\n    gSpheres4 = invertOnPlane(inversionSphere, PL3);\n    gSpheres5 = invertOnSphere(inversionSphere, s6);\n    \n}\n\nvec3 computeVertex(vec4 a, vec4 b, vec4 c) {\n    float AB = (dot(a.xyz, a.xyz) - dot(b.xyz, b.xyz) - a.w * a.w + b.w * b.w) * 0.5 -\n               dot(a.xyz, a.xyz) + dot(a.xyz, b.xyz);\n    float AC = (dot(a.xyz, a.xyz) - dot(c.xyz, c.xyz) - a.w * a.w + c.w * c.w) * 0.5 -\n               dot(a.xyz, a.xyz) + dot(a.xyz, c.xyz);\n    float x = -dot(a.xyz, a.xyz) - dot(b.xyz, b.xyz) + 2. * dot(a.xyz, b.xyz);\n    float y = -dot(a.xyz, a.xyz) - dot(c.xyz, c.xyz) + 2. * dot(a.xyz, c.xyz);\n    float z = -dot(a.xyz, a.xyz) + dot(a.xyz, b.xyz) +\n               dot(a.xyz, c.xyz) - dot(b.xyz, c.xyz);\n    float s = (AB * y - AC * z) / (x * y - z * z);\n    float t = (AC * x - AB * z) / (x * y - z * z);\n    return a.xyz + (b.xyz - a.xyz) * s + (c.xyz - a.xyz) * t;\n}\n\n\n/*\n0, 1, 2, \n0, 3, 4, \n2, 4, 5,\n0, 1, 3,\n3, 4, 5,\n1, 2, 5,\n1, 3, 5,\n0, 2, 4\n*/\nvoid computeVertexes(){\n    vertexes0 = computeVertex(gSpheres0,\n                                gSpheres1,\n                                gSpheres2);\n    vertexes1 = computeVertex(gSpheres0,\n                                gSpheres3,\n                                gSpheres4);\n    vertexes2 = computeVertex(gSpheres2,\n                                gSpheres4,\n                                gSpheres5);\n    vertexes3 = computeVertex(gSpheres0,\n                                gSpheres1,\n                                gSpheres3);\n    vertexes4 = computeVertex(gSpheres3,\n                                gSpheres4,\n                                gSpheres5);\n    vertexes5 = computeVertex(gSpheres1,\n                                gSpheres2,\n                                gSpheres5);\n    vertexes6 = computeVertex(gSpheres1,\n                                gSpheres3,\n                                gSpheres5);\n    vertexes7 = computeVertex(gSpheres0,\n                                gSpheres2,\n                                gSpheres4);\n    /*\n    for(int i = 0; i < 8; i++) {\n        vertexes[i] = computeVertex(gSpheres[index[i*3 + 0]],\n                                    gSpheres[index[i*3 + 1]],\n                                    gSpheres[index[i*3 + 2]]);\n    }\n    */\n}\n\nPlane computePlane() {\n        vec3 p1 = invertOnPoint(inversionSphere, vertexes0);\n        vec3 p2 = invertOnPoint(inversionSphere, vertexes1);\n        vec3 p3 = invertOnPoint(inversionSphere, vertexes2);\n\n        vec3 v1 = p2 - p1;\n        vec3 v2 = p3 - p1;\n        vec3 normal = normalize(cross(v1, v2));\n        if (normal.y < 0.) {\n            normal = normal * -1.;\n        }\n        Plane p = Plane(p1, p2, p3, normal);\n        \n        return p;\n}\n\nvec4 computeConvexSphere(){\n    return invertOnPlane(inversionSphere, dividePlane);\n}\n\n// p: center of the plane\n// n: normal of the plane\nbool intersectPlane(vec3 p, vec3 n, \n                    vec3 rayOrigin, vec3 rayDir,\n                     inout float minDist,\n                    inout vec3 intersection, inout vec3 normal){\n    float d = -dot(p, n);\n    float v = dot(n, rayDir);\n    float t = -(dot(n, rayOrigin) + d) / v;\n    if(EPSILON < t && t < minDist){\n\t\tintersection = rayOrigin + t * rayDir;\n        normal = n;\n        minDist = t;\n        return true;\n    }\n    return false;\n}\n\nvec2 opUnion(vec2 d1, vec2 d2) {\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat distSphere(vec3 p, vec4 sphere){\n\treturn distance(p, sphere.xyz) - sphere.w;\n}\n\nfloat distPlane(vec3 pos, vec3 p, vec3 n) {\n    return dot(pos - p, n);\n}\n\nfloat distPrism(const vec3 pos) {\n    float d = -1.;\n\td = max(distPlane(pos, PL1.p1,\n\t\t\t\t\t  PL1.normal),\n\t\t\td);\n    d = max(distPlane(pos, PL2.p1,\n\t\t\t\t\t  PL2.normal),\n\t\t\td);\n    d = max(distPlane(pos, PL3.p1,\n\t\t\t\t\t  PL3.normal),\n\t\t\td);\n    return d;\n}\n\nfloat distInfSphairahedra(const vec3 pos) {\n    float d = distPrism(pos);\n    d = max(distPlane(pos, dividePlane.p1,\n                           dividePlane.normal),\n            d);\n\td = max(-distSphere(pos, s2),\n\t\t\td);\n    d = max(-distSphere(pos, s4),\n\t\t\td);\n    d = max(-distSphere(pos, s6),\n\t\t\td);\n    return d;\n}\n\nvoid SphereInvert(inout vec3 pos, inout float dr, vec4 s) {\n    vec3 diff = pos - s.xyz;\n    float lenSq = dot(diff, diff);\n    float k = (s.w * s.w) / lenSq;\n    dr *= k; // (r * r) / lenSq\n    pos = (diff * k) + s.xyz;\n}\n\nfloat distLimitSetTerrain(vec3 pos, out float invNum) {\n    float dr = 1.;\n    invNum = 0.;\n\n    float d;\n    for(int i = 0; i < 200; i++) {\n        if(25 <= i) break;\n        bool inFund = true;\n\t\tif(distance(pos, s2.xyz) < s2.w) {\n            invNum ++;\n\t\t\tSphereInvert(pos, dr, s2);\n\t\t\tinFund = false;\n\t\t}\n        if(distance(pos, s4.xyz) < s4.w) {\n            invNum ++;\n\t\t\tSphereInvert(pos, dr, s4);\n\t\t\tinFund = false;\n\t\t}\n        if(distance(pos, s6.xyz) < s6.w) {\n            invNum ++;\n\t\t\tSphereInvert(pos, dr, s6);\n\t\t\tinFund = false;\n\t\t}\n\n\t\tpos -= PL1.p1;\n\t\td = dot(pos, PL1.normal);\n\t\tif(d > 0.) {\n            //invNum += 1.;\n\t\t\tpos -= 2. * d * PL1.normal;\n\t\t\tinFund = false;\n\t\t}\n\t\tpos += PL1.p1;\n        \n        pos -= PL2.p1;\n\t\td = dot(pos, PL2.normal);\n\t\tif(d > 0.) {\n            //invNum += 1.;\n\t\t\tpos -= 2. * d * PL2.normal;\n\t\t\tinFund = false;\n\t\t}\n\t\tpos += PL2.p1;\n        \n        pos -= PL3.p1;\n\t\td = dot(pos, PL3.normal);\n\t\tif(d > 0.) {\n            //invNum += 1.;\n\t\t\tpos -= 2. * d * PL3.normal;\n\t\t\tinFund = false;\n\t\t}\n\t\tpos += PL3.p1;\n\n        if(inFund) break;\n    }\n    return distInfSphairahedra(pos) / abs(dr) * 0.1;\n}\n\nvec2 distFunc(vec3 p) {\n\tvec2 d = vec2(distLimitSetTerrain(p, gInvNum), 1);\n    return d;\n}\n\nconst vec2 NORMAL_COEFF = vec2(0.001, 0.);\nvec3 computeNormal(const vec3 p){\n  return normalize(vec3(distFunc(p + NORMAL_COEFF.xyy).x - distFunc(p - NORMAL_COEFF.xyy).x,\n                        distFunc(p + NORMAL_COEFF.yxy).x - distFunc(p - NORMAL_COEFF.yxy).x,\n                        distFunc(p + NORMAL_COEFF.yyx).x - distFunc(p - NORMAL_COEFF.yyx).x));\n}\n\nconst int MAX_MARCH = 300;\nint march (vec3 rayOrg, vec3 rayDir, inout float minDist,\n           inout vec3 intersection, inout vec3 normal) {\n    vec2 dist = vec2(-1);\n    float rayLength = minDist;\n    vec3 rayPos = rayOrg + rayDir * rayLength;\n\n    for(int i = 0 ; i < MAX_MARCH ; i++){\n        dist = distFunc(rayPos);\n        rayLength += dist.x;\n        rayPos = rayOrg + rayDir * rayLength;\n        if(dist.x < EPSILON){\n            int objId = int(dist.y);\n            intersection = rayPos;\n            normal = computeNormal(intersection);\n            minDist = rayLength;\n            return objId;\n        }\n    }\n    return -1;\n}\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n  float imagePlane = (height * .5) / tan(fov * .5);\n  vec3 v = normalize(target - eye);\n  vec3 xaxis = normalize(cross(v, up));\n  vec3 yaxis =  normalize(cross(v, xaxis));\n  vec3 center = v * imagePlane;\n  vec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));\n  return normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));\n}\n\nconst vec4 K = vec4(1.0, .666666, .333333, 3.0);\nvec3 hsv2rgb(const vec3 c){\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvec3 getMatColor(int objId, vec3 normal, vec3 intersection, float t){\n    if(objId == 1){\n        vec3 col = Hsv2rgb((1., -0.01 + (gInvNum) * 0.02), 1., 1.);;\n        return col; \n    }\n\treturn BLACK;\n}\n\nvec3 sky(vec3 rayDir){\n\treturn clamp(vec3(.7, .8, 1.) + exp(dot(rayDir, LIGHT_DIR))*0.1, 0.0, 1.0);\n}\n\nfloat computeShadowFactor (vec3 rayOrg, vec3 rayDir,\n                           float mint, float maxt, float k) {\n    float shadowFactor = 1.0;\n    float t = mint;\n    for(int n = 0; n < 1000; n++){\n        if(t > maxt) break;\n        float d = distFunc(rayOrg + rayDir * t).x;\n        if(d < 0.0001) return 0.;\n\n        shadowFactor = min(shadowFactor, k * d / t);\n        t += d;\n    }\n    return clamp(shadowFactor, 0.0, 1.0);\n}\n\n\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    return pow(clamp(dot(reflect(e,n),l),0.0, 1.),s);\n}\n\nconst float FOG_START = 5.;\nconst float FOG_END = 100.;\nconst float FOG_END_START_RECIPROCAL = 1. / (FOG_END - FOG_START);\nconst vec3 FOG_F = vec3(1.);\nvec3 calcColor(float time, vec3 eye, vec3 ray){\n  \tvec3 l = BLACK;\n\n    float tmin = 0.;\n    float t = 9999999.;\n    const int maxLoop = 10;\n    \tvec3 intersection, normal;\n    \tbool isect;\n    \tint objId = -1;\n        \n        \n    bool hit = intersectBoundingPlane(vec3(0, 1, 0), vec3(0, gBoundingPlaneY, 0),\n                                 eye, ray,\n                                 tmin, t);\n    if(hit && tmin < 30.) {\n        objId = march(eye, ray, tmin,\n                      intersection, normal);\n        if(objId != -1){\n            vec3 matColor = getMatColor(objId, normal, intersection, t);\n            float k = computeShadowFactor(intersection + 0.0001 * normal,\n                                         LIGHT_DIR,\n                                         0.001, 5., 100.);\n            vec3 diffuse =  clamp(dot(normal, LIGHT_DIR), 0., 1.) * matColor;\n            vec3 ambient = matColor * AMBIENT_FACTOR;\n    \t\tl += k * diffuse + ambient;\n            \n            l = mix(FOG_F, l, clamp((FOG_END - tmin) * FOG_END_START_RECIPROCAL, 0.1, 1.0));\n        }\n                      \n    } else {\n        l = mix( sky(ray), l, exp( -0.000000009*t * t ) );\n    }\n    \n  \treturn l;\n}\n\n//w: start time\n//s: duration\nfloat scene(in float t, in float w, in float s){\n    return clamp(t - w, 0.0, s) / s;\n}\n\nfloat expEasingIn(float t){\n    return pow( 2., 13. * (t - 1.) );\n}\n\nfloat circEasingIn(float t){\n\treturn -  (sqrt(1. - t*t) - 1.);\n}\n\nfloat circEasingOut(float t){\n    return sqrt(1. - pow(t - 1., 2.));\n}\n\nfloat circEasingInOut(float t){\n\tt /= .5;\n\tif (t < 1.) return -.5 * (sqrt(1. - t*t) - 1.);\n\tt -= 2.;\n\treturn .5 * (sqrt(1. - t*t) + 1.);\n}\n\nconst vec3 target = vec3(0, 0, 0);\nvec3 up = vec3(0, 1, 0);\nfloat fov = radians(60.);\n\nconst float SAMPLE_NUM = 1.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float t = mod(iTime, 31.);\n    \n    float rad = mix(0.0001, 1.0, circEasingInOut(scene(t, 1.0, 15.)));\n    float rotationT = mix(0., 50., (scene(t, 0., 15.)));\n    if(t < 21.) {\n        \n        float tb = rad * cos(rotationT);\n        float tc = rad * sin(rotationT);\n        tb = mix(tb, 0., circEasingInOut(scene(t, 15., 1.)));\n        tc = mix(tc, 0., circEasingInOut(scene(t, 15., 1.)));\n        \n        tb = mix(tb, 1.2224464245160123, circEasingInOut(scene(t, 16., 1.)));\n        tc = mix(tc, 0.612090457867328, circEasingInOut(scene(t, 16., 1.)));\n        \n        tb = mix(tb, -0.8661174154839888, circEasingInOut(scene(t, 17., 1.)));\n        tc = mix(tc, 0., circEasingInOut(scene(t, 17., 1.)));\n        \n        tb = mix(tb, 0.61096041060052, circEasingInOut(scene(t, 18., 1.)));\n        tc = mix(tc, -0.6110480831254523, circEasingInOut(scene(t, 18., 1.)));\n        \n        tb = mix(tb, -0.6144427845492827, circEasingInOut(scene(t, 19., 1.)));\n        tc = mix(tc, 0.6155169219301033, circEasingInOut(scene(t, 19., 1.)));\n        \n        tb = mix(tb, -0.6492253932449349, circEasingInOut(scene(t, 20., 1.)));\n        tc = mix(tc, -1.1670917737220714, circEasingInOut(scene(t, 20., 1.)));\n        \n        computeCubeSphairahedronA(tb, tc);\n    } else if(t < 22.) {\n        computeCubeSphairahedronA(-0.6492253932449349, -1.1670917737220714);\n        computeCubeSphairahedronB(-1.4263771231354925, -0.4114778978502866);\n        s2 = mix(s2A, s2B, circEasingInOut(scene(t, 21., 1.)));\n        s4 = mix(s4A, s4B, circEasingInOut(scene(t, 21., 1.)));\n        s6 = mix(s6A, s6B, circEasingInOut(scene(t, 21., 1.)));\n        inversionSphere = vec4(-s6.x, -s6.y, s6.z, s6.w);\n    } else if(t < 26.){\n        float tb = -1.4263771231354925;\n        float tc = -0.4114778978502866;\n        tb = mix(tb, 0.9480876782578194, circEasingInOut(scene(t, 22., 1.)));\n        tc = mix(tc, -0.27487295833102093, circEasingInOut(scene(t, 22., 1.)));\n        \n        tb = mix(tb, -0.7341647058410344, circEasingInOut(scene(t, 23., 1.)));\n        tc = mix(tc, -0.8016177852310659, circEasingInOut(scene(t, 23., 1.)));\n        \n        tb = mix(tb, -1.1021579831206387, circEasingInOut(scene(t, 24., 1.)));\n        tc = mix(tc, 0., circEasingInOut(scene(t, 24., 1.)));\n        \n        tb = mix(tb, 0.7341944231647511, circEasingInOut(scene(t, 25., 1.)));\n        tc = mix(tc, 0.8010951070853616, circEasingInOut(scene(t, 25., 1.)));\n        computeCubeSphairahedronB(tb, tc);\n    } else if(t < 27.){\n        computeCubeSphairahedronB(0.7341944231647511, 0.8010951070853616);\n        computeCubeSphairahedronC(0.80897179163727, -0.6172090398213005);\n        s2 = mix(s2B, s2C, circEasingInOut(scene(t, 26., 1.)));\n        s4 = mix(s4B, s4C, circEasingInOut(scene(t, 26., 1.)));\n        s6 = mix(s6B, s6C, circEasingInOut(scene(t, 26., 1.)));\n        inversionSphere = vec4(-s6.x, -s6.y, s6.z, s6.w);\n\n    } else if(t < 30.){\n        float tb = 0.80897179163727;\n        float tc = -0.6172090398213005;\n        tb = mix(tb, -1.0724597039839807, circEasingInOut(scene(t, 27., 1.)));\n        tc = mix(tc, 0.10239062161550339, circEasingInOut(scene(t, 27., 1.)));\n        \n        tb = mix(tb, -0.4626628191468804, circEasingInOut(scene(t, 28., 1.)));\n        tc = mix(tc, -0.7985798919860417, circEasingInOut(scene(t, 28., 1.)));\n        \n        tb = mix(tb, 1.0842163989231046, circEasingInOut(scene(t, 29., 1.)));\n        tc = mix(tc, -0.09944669059450531, circEasingInOut(scene(t, 29., 1.)));\n        \n        computeCubeSphairahedronC(tb, tc);\n    } else {\n        computeCubeSphairahedronC(1.0842163989231046, -0.09944669059450531);\n        computeCubeSphairahedronA(0., 0.);\n        s2 = mix(s2C, s2A, circEasingInOut(scene(t, 30., 1.)));\n        s4 = mix(s4C, s4A, circEasingInOut(scene(t, 30., 1.)));\n        s6 = mix(s6C, s6A, circEasingInOut(scene(t, 30., 1.)));\n        inversionSphere = vec4(-s6.x, -s6.y, s6.z, s6.w);\n    }\n\n    computeGSpheres();\n    computeVertexes();\n    dividePlane = computePlane();\n    convexSphere = computeConvexSphere();\n    gBoundingPlaneY = max(gBoundingPlaneY, s2.y + .01);\n    gBoundingPlaneY = max(gBoundingPlaneY, s4.y + .01);\n    gBoundingPlaneY = max(gBoundingPlaneY, s6.y + .01);\n    vec3 eye = vec3(2. , 2., 2. );\n    eye = mix(eye, vec3(-2, 2, 2), circEasingInOut(scene(t, 15.0, 1.)));\n    eye = mix(eye, vec3(-2, 2, -2), circEasingInOut(scene(t, 20.0, 1.)));\n    eye = mix(eye, vec3(2, 2, -2), circEasingInOut(scene(t, 25.0, 1.)));\n    eye = mix(eye, vec3(2, 2, 2), circEasingInOut(scene(t, 30.0, 1.)));\n    \n    vec3 sum = vec3(0);\n  \tfor(float i = 0. ; i < SAMPLE_NUM ; i++){\n    \tvec2 coordOffset = rand2n(gl_FragCoord.xy, i);\n          \n    \tvec3 ray = calcRay(eye, target, up, fov,\n        \t               iResolution.x, iResolution.y,\n            \t           gl_FragCoord.xy + coordOffset);\n        \n    \tsum += calcColor(t, eye, ray);\n  \t}\n \tvec3 col = (sum/SAMPLE_NUM);\n  \n    \n  \tfragColor = vec4(gammaCorrect(col), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lyGRt.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[130, 219, 260, 260, 541], [1849, 1849, 1878, 1878, 2055], [2057, 2057, 2097, 2097, 2300], [2303, 2303, 2355, 2355, 2737], [2739, 2739, 2791, 2791, 3222], [3224, 3224, 3276, 3276, 3711], [3770, 3770, 3914, 3914, 4200], [4954, 4954, 5012, 5447, 10609], [10611, 10611, 10652, 10652, 10775], [10777, 10777, 10822, 10822, 11240], [11242, 11242, 11287, 11287, 11513], [11515, 11515, 11538, 11538, 11863], [11865, 11865, 11909, 11909, 12624], [12627, 12706, 12729, 12729, 13995], [13997, 13997, 14019, 14019, 14453], [14455, 14455, 14482, 14482, 14540], [14542, 14594, 14786, 14786, 15051], [15053, 15053, 15085, 15085, 15120], [15122, 15122, 15160, 15160, 15206], [15208, 15208, 15251, 15251, 15281], [15283, 15283, 15316, 15316, 15534], [15536, 15536, 15579, 15579, 15852], [15854, 15854, 15913, 15913, 16076], [16078, 16078, 16133, 16133, 17220], [17222, 17222, 17245, 17245, 17313], [17358, 17358, 17391, 17391, 17674], [17703, 17703, 17817, 17817, 18316], [18318, 18318, 18470, 18470, 18830], [18881, 18881, 18908, 18908, 19022], [19025, 19025, 19094, 19094, 19227], [19229, 19229, 19251, 19251, 19330], [19332, 19332, 19446, 19446, 19764], [19767, 19767, 19813, 19813, 19873], [20027, 20027, 20074, 20074, 21220], [21222, 21252, 21300, 21300, 21339], [21341, 21341, 21368, 21368, 21408], [21410, 21410, 21438, 21438, 21474], [21476, 21476, 21505, 21505, 21546], [21548, 21548, 21579, 21579, 21686], [21804, 21804, 21860, 21860, 26840]], "test": "untested"}
{"id": "flyGRd", "name": "GPU-dependent UV precision", "author": "Reedbeta", "description": "Demo of hardware-dependent precision/rounding of UV coordinate for texture sampling. See code comments for full explanation.", "tags": ["2d", "precision", "gpu"], "likes": 4, "viewed": 820, "published": 3, "date": "1638144788", "time_retrieved": "2024-07-30T18:45:18.553978", "image_code": "// This shader demonstrates how GPU hardwares differ in how they\n// handle UV coordinate precision during texture sampling.\n//\n// The upper-left half of the screen is hardware texture sampling, with\n// the texture filter set to nearest, while the lower-right is emulating\n// nearest-neighbor sampling using floor() and texelFetch(). Depending on\n// what GPU you're using, you may see a slight discrepancy between these,\n// visible as stairsteps running along the texel boundaries. The discrepancy\n// is also highlighted in pulsing red.\n//\n// GPUs are only required to use 8 bits of sub-texel precision in their\n// samplers, per API spec. When narrowing from 32-bit floats down to the\n// internal sampler precision, some GPUs might use round-to-nearest, while\n// others might truncate, or simply calculate the nearest neighbor from the\n// full 32-bit input value. This can lead to a mismatch when the same\n// calculation is done at full 32-bit float precision.\n//\n// When the mouse button is pressed, we add a 1/512 texel offset to the UV\n// before floor()-ing it. This simulates the result of a round-to-nearest\n// narrowing conversion. On some hardware that has a disrepancy between the\n// two calculations, this offset fixes it. But on other hardware that was\n// getting it right to begin with, this offset introduces the very artifact\n// we were trying to avoid.\n//\n// Unfortunately, if we need this to work, there seems to be no option but to check\n// which hardware you are running on and apply the offset or not accordingly.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 screenUV = fragCoord / iResolution.xy;\n\n    // Zoom in on the texture and move it around\n    vec2 texUV = fragCoord * .2e-4 + .03;\n    texUV += vec2(.01, .001)*cos(iTime * vec2(0.31, 0.23) + vec2(0,2));\n\n    // HW nearest-neighbor sample\n    float hwSample = texture(iChannel0, texUV).r;\n\n    if (screenUV.x < screenUV.y)\n    {\n        // Upper-left: HW nearest sample\n        fragColor = vec4(vec3(hwSample), 1.0);\n    }\n    else\n    {\n        // Lower-right: emulated in code\n        float offset = (iMouse.z > 0.0) ? 1.0/512.0 : 0.0;\n        ivec2 texelCoord = ivec2(floor(texUV * iChannelResolution[0].xy + offset));\n        float emulatedSample = texelFetch(iChannel0, texelCoord, 0).r;\n        fragColor = vec4(vec3(emulatedSample), 1.0);\n        \n        // Highlight error with pulsing red\n        float errorAlpha = max(0.0, sin(2.0 * iTime));\n        if (hwSample != emulatedSample)\n        {\n            fragColor = mix(fragColor, vec4(1.0, 0.0, 0.0, 1.0), errorAlpha);\n        }\n    }\n}\n", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flyGRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1532, 1532, 1587, 1587, 2595]], "test": "untested"}
{"id": "NlGGzt", "name": "Headache 01", "author": "andrinr", "description": "playing around with lines", "tags": ["sinus"], "likes": 3, "viewed": 227, "published": 3, "date": "1638132467", "time_retrieved": "2024-07-30T18:45:19.314943", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv *= 4.0;\n    \n    uv = fract(uv);\n    \n    uv -= vec2(0.5);\n\n    float c = clamp(sin(sqrt(uv.x*uv.x*uv.x +uv.y*uv.y)*50.0 + 6.0 *iTime), 0.0, 1.0);\n\n    float r = max(c, 0.0);\n\n    // Output to screen\n    fragColor = vec4(vec3(r),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlGGzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 108, 397]], "test": "untested"}
{"id": "NlG3Rt", "name": "Diverging Patterns", "author": "andrinr", "description": "playing around with lines", "tags": ["sinus"], "likes": 1, "viewed": 204, "published": 3, "date": "1638131934", "time_retrieved": "2024-07-30T18:45:20.088874", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5);\n\n    float c = clamp(sin(uv.x*uv.x*uv.y*uv.y*3000.0 + 3.0 *iTime), 0.0, 1.0);\n    float d = clamp(sin((uv.x*uv.y*uv.x)*1000.0 - 3.0 * iTime), 0.0, 1.0);\n    \n    float r = max(d, c);\n\n    // Output to screen\n    fragColor = vec4(vec3(r),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlG3Rt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 108, 405]], "test": "untested"}
{"id": "ftV3zK", "name": "chillwave planet", "author": "z0rg", "description": "A simple landscape I made to sync with some chillwave songs I love. The final video can be found here https://www.youtube.com/watch?v=VRj0uq-kDCg", "tags": ["zef"], "likes": 38, "viewed": 2127, "published": 3, "date": "1638108263", "time_retrieved": "2024-07-30T18:45:20.874773", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec3 col = pow(texture(iChannel0, uv).xyz,vec3(1.3));\n    col += pow(texture(iChannel0, uv).xyz,vec3(.9))*.35;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.141592653\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\n// Stolen from 0b5vr here https://www.shadertoy.com/view/ss3SD8\nfloat hash11(float p)\n{\n    return (fract(sin((p)*114.514)*1919.810));\n}", "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define FFT(a) (texture(iChannel3, vec2(a, 0.)).x-.25)\n\nfloat seed;\nfloat rand()\n{\n    seed++;\n    return hash11(seed);\n}\n\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000.,-1.);\n    //acc = _min(acc, vec2(length(p)-2., 0.));\n    acc = _min(acc, vec2(-p.y, 0.));\n    return acc;\n}\n\nvec3 getEnv(vec3 rd)\n{\n    rd.xy *= r2d(.5);\n    vec2 uv = vec2(atan(rd.z, rd.x)/PI, (acos(rd.y)/PI-.5)*2.);\n    float gradf = 3.;\n    vec3 up = mix(vec3(0.161,0.055,0.239),vec3(0.639,0.059,0.341), sat(uv.y*gradf));\n    vec3 low = mix(vec3(0.161,0.055,0.239),vec3(0.157,0.345,0.337), sat(-uv.y*gradf));\n    vec3 back = mix(low, up, float(uv.y > 0. ? low : up));\n\n    float stars = pow(texture(iChannel2, uv*4.).x, 10.);\n    \n    uv.x *= 1.75;\n    float an = atan(uv.y, uv.x);\n    back += (.35*vec3(0.945,0.220,0.310)*sat(sin(an*12.)+.8))*(1.-sat(length(uv*2.)))+\n    .5*vec3(0.945,0.263,0.216)*sat(sin(an*7.+1.)+.7)*(1.-sat(length(uv*1.5)))+\n    .5*vec3(1.000,0.533,0.502)*sat(sin(an*5.)+.5)*(1.-sat(length(uv*1.)));\n    \n        float rep = 0.05;\n    vec2 uv2 = uv-vec2(0.,0.05);\n    uv2 *= 1.5;\n    float id = floor((uv2.x+rep*.5)/rep);\n    uv2.x = mod(uv2.x+rep*.5,rep)-rep*.5;\n    float height = pow(FFT(abs(id*.01)),1.)*.8;\n    float shape = max(abs(uv2.y)-height, abs(uv2.x)-0.001);\n    vec3 rgbs = mix(vec3(0.208,0.675,0.431)*0., vec3(0.180+sin(id+iTime)*.5+.5,0.820,0.659+sin(-id+iTime)*.5+.5), sat((abs(uv2.y))*10.));\n    back += rgbs*(1.-sat(shape*400.))*(1.-sat(abs(uv.x*2.)-.5));\n    \n    float psz = .3;\n    float planet = length(uv)-psz;\n    vec3 col = back+stars*vec3(0.580,0.804,0.820)*.5;\n    vec3 planetrgb = vec3(0.161,0.055,0.239)*.75\n    +vec3(0.961,0.000,0.192)*pow(texture(iChannel1,uv*5.*length(uv)).x,3.)*sat(uv.y*5.);\n    planetrgb += vec3(1.000,0.173,0.078)*(1.-sat((abs(planet)-.001)*50.))*sat(uv.y*5.);\n    col = mix(col, planetrgb, 1.-sat(planet*400.));\n    \n    col += .5*vec3(1.000,0.173,0.078)*(1.-sat((abs(planet)-.01)*20.))*sat(uv.y*5.);\n    col += vec3(1.000,0.314,0.141)*(1.-sat(planet*100.))*.15;\n    \n    col += .25*rgbs*(1.-sat(shape*10.))*(1.-sat(abs(uv.x*2.)-.5))*sat(planet*10.);\n    \n    return col;\n}\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x, max(l.y, l.z));\n}\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+(r*uv.x+u*uv.y)*5.);\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.001,0.);\n    return normalize(vec3(d)-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.001)\n            return vec3(res.x, distance(p, ro), res.y);\n        p+=rd*res.x;\n    }\n    return vec3(-1.);\n}\n\nvec3 getMat(vec3 res, vec3 rd, vec3 p, vec3 n)\n{\n    return vec3(.1);\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.);\n    \n    float t = 4.68;\n    vec3 ro = vec3(sin(t)*5.,-1.5+sin(iTime*.25)*.2,cos(t)*5.+sin(iTime*.25));\n    vec3 ta = vec3(0.,-2.,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    float d = 100.;\n    vec3 res = trace(ro, rd, 128);\n    \n    if (res.y > 0.)\n    {\n    d = res.y;\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = getMat(res, rd, p, n);\n        float move = p.x+iTime;\n        float river = (abs(p.z-sin(move*1.)*.5-sin(move*.5)*2.)-1.5);\n        float spec = mix(.25,1.,1.-sat(river*400.));\n        float gloss = mix(.5,.05, 1.-sat(river*400.));\n        vec3 refl = normalize(reflect(rd, n)+gloss*(vec3(rand(), rand(), rand())-.5));\n        vec3 resrefl = trace(p+n*0.01, refl, 256);\n        vec3 reflec = vec3(0.);\n        float gridrep = 1.;\n        vec2 griduv = vec2(move, p.z);\n        griduv = mod(griduv+gridrep*.5,gridrep)-gridrep*.5;\n        float gridth = .001;\n        float grid = min(abs(griduv.x)-gridth, abs(griduv.y)-gridth);\n        col += sat(river*400.)*vec3(0.220,0.800,0.412)*(1.-sat(grid*40.))*(1.-sat(res.y/10.));\n        if (resrefl.y > 0.)\n        {\n            vec3 prefl = p+refl*resrefl.y;\n            vec3 nrefl = getNorm(prefl, resrefl.x);\n\n            reflec=getMat(resrefl, refl, prefl, nrefl);\n        }\n        else\n            reflec=getEnv(refl);\n        col += reflec*spec;\n    }\n    else\n        col = getEnv(rd);\n    col += vec3(0.816,0.541,1.000)*(1.-sat(exp(-d*0.2+.5)))*sat(rd.y*1.+.5);\n    col += vec3(1.000,0.314,0.141)*(1.-sat(exp(-d*0.2+1.5)))*sat(rd.y*3.+.5);\n    \n    col += vec3(0.302,0.698,1.000)*pow(1.-sat(abs((rd.y-.05)*15.)),2.)*(1.-sat(abs(rd.z)));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.xx;\n    seed=texture(iChannel2,uv).x;\n    seed+=fract(iTime);\n    vec3 col = rdr(uv);\n    col *= 1.-sat(length(uv*1.5));\n    col = pow(col, vec3(1.2));\n   col *= sat(iTime-1.);\n   \n    col = mix(col, texture(iChannel0, fragCoord.xy/iResolution.xy).xyz,.5);\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftV3zK.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 651]], "test": "untested"}
{"id": "flK3zc", "name": "hexatruchets 2", "author": "FabriceNeyret2", "description": "On hexagons there are 3 types of tiles, * 2,3 or 6 rotations.\nvariant of [url]https://shadertoy.com/view/flGGR3[/url]  with shadows.\n\nclick to see tiles", "tags": ["short", "connect", "doodles", "truchets", "entanglement"], "likes": 23, "viewed": 346, "published": 3, "date": "1638106422", "time_retrieved": "2024-07-30T18:45:21.643717", "image_code": "// variant with shadows https://shadertoy.com/view/flGGR3\n\n#define H(p)   fract(sin(dot(p, vec2(12.9898, 78.233))-floor(iTime)) * 43758.5453)\n#define S(v)   smoothstep( N/R.y, 0., v )\n#define hue(v) ( .6 + .6 * cos( .5+(v)  + vec4(0,23,21,0)  ) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float N = 32.,                                     // vertical number of tiles\n          s = sqrt(3.), r = 1./s;\n          \n    vec2 R = iResolution.xy,\n         U = N * u / R.y * mat2(s,-1,0,2)/4.,          // to tilted space\n         I = floor(U);                                 // I : hexa tile ID\n    U = fract(U) *  mat2(1,.5,0,s/2.) - vec2(1,r)/2.;  // U : local coords\n    U += U.y*s+abs(U.x) < 0. ? I.y--,   + vec2( 0,r)   // Set to hexagon over the 3\n        : U.x < 0.           ? I.x--, -.5*vec2(-1,r)   //   covered by the tilted cell\n        :                             -.5*vec2( 1,r);\n    O-=O;                                              // --- draw tiles\n // O += .5+.5*sin(60.*(length(U)-.5)); return;\n    float t = floor(3.*H(I)),                          // random tile type\n          a = floor(6.*H(I+.5))/6. *6.2831853;         // random tile rotation\n    U *= mat2( cos( a + vec4(0,1.57,-1.57,0) ) );      // do rotation\n    \n#define C(v,r)   S( abs(length(v)-r/2.) )              // draw among 3 types:\n#define sha(x,y) S(length(U-vec2(x,y))-.1)                              \n    O +=   t==0. ? max(C( vec2(abs(U.x)-.5,U.y+r/2.) , r), // 3 short turns\n                           C( U - vec2(0,r), r) )\n         : t==1. ? max(max(C( U - vec2(.5,-s/2.), s),      // 2 larges + 1 short\n                           C( U + vec2(.5, s/2.), s) - sha(0,-.17) ),   // - shadow\n                           C( U - vec2(0,r), r))\n         :         max(max(C( U - vec2(.5,-s/2.), s),      // 2 larges + 1 line\n                           C( U + vec2(.5,-s/2.), s) - sha(-.08,.12) ), // - shadow\n                           S( abs(U.x*s+U.y) / 2.)   - sha(.08,-.12) ); // - shadow\n\n    if (iMouse.z > 0.) O *= hue(6.28*H(I));            // if click show tiling\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flK3zc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[248, 248, 286, 286, 2063]], "test": "untested"}
{"id": "flVGzc", "name": "Steel mesh", "author": "yasuo", "description": "Steel mesh", "tags": ["material"], "likes": 16, "viewed": 261, "published": 3, "date": "1638104962", "time_retrieved": "2024-07-30T18:45:22.476490", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define MAX_STEPS 32\n#define MAX_DIST 6.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define MATERIAL_STEAL 0\n#define MATERIAL_WALL 1\n#define ZERO (min(iFrame,0))\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\n// IQ's 3D noise function. It's faster than the FBM and enough for me to design.\n// The compile is also faster.\nfloat noise3d( vec3 p )\n{\n    p*=0.5;\n    const vec3 s = vec3(27, 111, 57);\n    vec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.); // option\n    h = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\n// thx:iq https://iquilezles.org/articles/distfunctions\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat sdSimpleCylinder(vec3 p, float r, float h){\n    float d = length(p.xz)-r;\n    d = max(abs(p.y)-h,d);\n    return d;\n}\n\n// vertical version\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xy)-t.x,p.z);\n    return length(q)-t.y;\n}\n\n// thx:iq https://iquilezles.org/articles/distfunctions2d\nfloat sdEquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n// thx:iq https://iquilezles.org/articles/distfunctions2d\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\nfloat dFakeSpring(vec3 p){\n    for(int i = 0; i<4; i++){\n        p.z = abs(p.z);\n        p.z-=0.025;\n    }\n\n    float d = sdTorus(p,vec2(0.05,0.023));\n    return d;\n}\n\nfloat steelMesh(vec3 p){\n    float d = dFakeSpring(p);\n    \n    p.yz = abs(p.yz);\n    p.z-=0.2;\n    p.y-=0.32;\n    p.y+=0.22;\n    p.yz*=Rot(radians(-35.0));\n    float d2 = sdSimpleCylinder(p,0.02,0.5);\n    d = opSmoothUnion(d,d2,0.05);\n    return d;\n}\n\nvec2 GetDist(vec3 p) {\n    p.y+=iTime*0.1;\n    p += noise3d(p*300.0)*0.002;   \n    vec3 prevP = p;\n    \n    p.x = mod(p.x,1.2)-0.6;\n    p.y = mod(p.y,1.0)-0.5;\n    p.xz*=Rot(radians(90.0));\n    \n    float d = dFakeSpring(p);\n    d = steelMesh(p);\n    p = prevP;\n    \n    p.x+=0.6;\n    p.y+= 0.5;\n    p.x = mod(p.x,1.2)-0.6;\n    p.y = mod(p.y,1.0)-0.5;\n    \n    p.xz*=Rot(radians(90.0));\n    float d2 = steelMesh(p);\n    d = min(d,d2);\n    \n    p = prevP;\n    float wallD = p.z+0.01;\n    return combine(vec2(d,MATERIAL_STEAL),vec2(wallD,MATERIAL_WALL));\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n\n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n                \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,2,-2));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*shadow*occ;\n    diffCol += col*vec3(1.0,1.0,0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 20.)*occ; // spec\n        \n    return diffCol;\n}\n\nvec3 iconBg(vec2 p, vec3 col){\n    float d = sdEquilateralTriangle(p)-0.2;\n    col = mix(col,vec3(1.0,1.0,0.0),S(d,0.0));\n    d = abs(sdEquilateralTriangle(p)-0.2)-0.05;\n    col = mix(col,vec3(0.0),S(d,0.0));\n    return col;\n}\n\nvec3 hazrdIcon(vec2 p, vec3 col){\n    p*=5.0;\n    vec2 prevP = p;\n    col = iconBg(p,col);\n    \n    p.y+=0.2;\n    p.x = abs(p.x);\n    p.x-=0.3;\n    p*=Rot(radians(30.0));\n    float d = length(p)-0.4;\n    d = max(-(length(p-vec2(0.1,0.0))-0.31),d);\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    p = prevP;\n    p.y-=0.4;\n    d = length(p)-0.4;\n    d = max(-(length(p-vec2(0.0,0.1))-0.31),d);\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    p = prevP;\n    p.y-=0.05;\n    d = abs(length(p)-0.35)-0.05;\n    col = mix(col,vec3(0.0),S(d,0.0));\n     \n    return col;\n}\n\nvec3 warningIcon(vec2 p, vec3 col){\n    p*=5.0;\n    vec2 prevP = p;\n    col = iconBg(p,col);\n    \n    float d = sdUnevenCapsule(p,0.1,0.2,0.7);\n    d = min(length(p-vec2(0.0,-0.35))-0.15,d);\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    return col;\n}\n\nvec3 drawHazardIcons(vec2 p, vec3 col){\n    vec2 prevP = p;\n    p.y+=0.5;\n    p.x = mod(p.x,1.2)-0.6;\n    p.y = mod(p.y,1.0)-0.5;\n    col = warningIcon(p,col);\n    \n    p = prevP;\n    p.x+=0.6;\n    p.x = mod(p.x,1.2)-0.6;\n    p.y = mod(p.y,1.0)-0.5;\n    col = hazrdIcon(p,col);\n    \n    return col;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    vec3 np = p;\n    np.y+=iTime*0.1;\n    float nn = noise3d(np*80.0)*0.12;\n    if(mat == MATERIAL_STEAL){\n        col = diffuseMaterial(n,rd,p,vec3(0.3)+nn+nn);\n    }\n    if(mat == MATERIAL_WALL){\n        col = diffuseMaterial(n,rd,p,(vec3(0.3,0.2,0.1)+nn+nn)+drawHazardIcons(np.xy,col)*0.2);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n      \n    float handShakeY = noise3d(vec3(iTime*1.0,iTime*1.1,iTime*1.2))*0.05;\n    float handShakeX = noise3d(vec3(iTime*1.1,iTime*1.2,iTime*1.1))*0.2;\n    \n    vec3 ro = vec3(handShakeX, handShakeY, 2.0);\n    ro.xz *= Rot(radians(sin(iTime*0.5)*5.0));\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n    } else {\n        col = vec3(0.3);\n    }\n    \n    // gamma correction\n    col = pow( col, vec3(0.8545) );    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flVGzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[365, 365, 401, 401, 443], [445, 557, 582, 582, 939], [941, 997, 1049, 1049, 1149], [1151, 1151, 1200, 1200, 1273], [1275, 1295, 1328, 1328, 1397], [1399, 1457, 1499, 1499, 1710], [1712, 1770, 1832, 1832, 2071], [2073, 2073, 2099, 2099, 2239], [2241, 2241, 2265, 2265, 2492], [2494, 2494, 2516, 2516, 3048], [3050, 3050, 3108, 3108, 3379], [3381, 3381, 3405, 3405, 3606], [3608, 3608, 3650, 3650, 3845], [3847, 3888, 3937, 3937, 4228], [4230, 4230, 4287, 4287, 4906], [4908, 4908, 4938, 4938, 5134], [5136, 5136, 5169, 5169, 5698], [5700, 5700, 5735, 5735, 5952], [5954, 5954, 5993, 5993, 6254], [6256, 6256, 6315, 6315, 6633], [6635, 6635, 6692, 6692, 7438]], "test": "untested"}
{"id": "NtV3zV", "name": "connect components in truchets 4", "author": "FabriceNeyret2", "description": "WIP: Find the connected component, then connect them. (cyclical world to make it solvable). Scale N in Common.\nSPACE to restart a new truchet tiling. \n'R' to reset ids  (do it when apparently monocolor: some id errors for now)\nclick to swap tile manually.", "tags": ["flood", "connected", "doodles", "reproduction", "truchets", "streamreduction"], "likes": 8, "viewed": 299, "published": 3, "date": "1638102844", "time_retrieved": "2024-07-30T18:45:23.343173", "image_code": "// connecting components in https://shadertoy.com/view/NlGGRV\n// more accelerated variant of https://shadertoy.com/view/stKGzG\n// accelerated variant of https://shadertoy.com/view/7ty3zG\n\n#define hue(v)  vec4( .6 + .6 * cos( .5+(v)  + vec3(0,23,21)  ) , 1 )\n\n// #define length(v) ( abs(v.x)+abs(v.y) ) // variant with straight lines\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n // O = T(u).agbr; return;\n    vec2 U = N * u / R.y + 0.*iTime, I = floor(U), F = fract(U);\n         \n    O = T(I);                                          // cell states \n    O.w > 0. ? F = vec2(1.-F.y,F.x) : F;\n    \n    O =   smoothstep(N*1.5/R.y,0.,abs(min(length(F),length(1.-F))-.5) ) // truchet drawing\n        * hue( O[ F.x+F.y < 1. ? 1 : 2 ] );            // coloring\n         \n // if (iMouse.z>0.) O += (1.-O.w)*.3*mod(I.x+I.y,2.); // debug: draw tiles\n // O += .3*T(I).w;\n} ", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define H(p)  fract(sin(dot(p, vec2(12.9898, 78.233))-iTime) * 43758.5453)\n#define keyDown(c)    ( texelFetch(iChannel3,ivec2(c,1),0).x > 0.)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U -= .5;\n    if ( iFrame < 1 || keyDown(32) ) {        // --- init: create truchet\n        vec2 I = U;                           // store truchet data\n        O.w = step(.5,H(I));                  // random axis\n        O.y = 1.+I.x+4096.*I.y;               // id of tile segment #1\n        O.z = -O.y;                           // id of tile segment #2\n        O.x = 0.;\n        return;\n    }\n    \n    O = T(U);                                 // previous state\n    float Nx = floor(N*R.x/R.y);\n    vec4 T;\n    if (U.x <= Nx && U.y >= N+4. && U.y <= N+N+4.) // keep previous version\n      { U.y -= N+4.; O = T(U); return; }\n      \n    if (U.x >= Nx+4. && U.x <= Nx+4.+Nx/8. && U.y <= N/8.) { // reduction map of change\n        O-=O;\n        U.x -= Nx+4.;\n        for (int k=0; k < 64; k++ ) {\n            vec2 V = 8.*U + vec2(k%8,k/8),\n                 o = T(V + vec2(0.,N+4.)).yz, // old vs new value\n                 n = T(V).yz;\n         // if ( o != n ) O = vec4(o,n);      // if changed, store ( why break worse ? )\n         // if ( o != n ) { O = vec4(o,n); break; } // why worse ? \n            if ( o.x != n.x ) O.xz = vec2(o.x,n.x); // if changed, store \n            if ( o.y != n.y ) O.yw = vec2(o.y,n.y);\n            if (O.x*O.y!=0.) break;\n        }\n        return;\n    }\n    if (U.x > Nx || U.y > N) return;          // propagate only visible tiles\n\n                                              // --- propagate id along connections\n#define Tc(U)      T(mod(U,vec2(Nx,N)))\n#define left       Tc(U+vec2(1,0)).y\n#define right      Tc(U-vec2(1,0)).z\n#define bot      ( T = Tc(U+vec2(0,1)), T.w<1. ? T.y : T.z )\n#define top      ( T = Tc(U-vec2(0,1)), T.w<1. ? T.z : T.y )\n//#define min(a,b) ( abs(a) < abs(b) ? a : b ) // may this boost ?\n    if (O.w<1.) { // tile contains:  \\     new id = min(connections)\n        O.y = min( O.y, min( right, top ));\n        O.z = min( O.z, min( left , bot ));\n    }\n    else {        // tile contains:  /     new id = min(connections)\n        O.y = min( O.y, min( right, bot ));\n        O.z = min( O.z, min( left , top ));\n    }\n    \n // if (T().x > 0.) { if (U == vec2(0)) O.x-- ; return; }\n\n                  // --- shortcut2: at color change, update the color source pixel\n    for( float j = 0.; j < N/8.; j++)\n        for( float i = 0.; i < Nx/8.; i++) {\n            T = T( vec2(Nx+4.+i,j) );\n            vec2 o = T.xy, n = T.zw;          // changed old->new value\n            if (O.y==o.x) O.y = n.x;          // oldvalue was my seg1 : update\n            if (O.y==o.y) O.y = n.y;\n            if (O.z==o.x) O.z = n.x;          // oldvalue was my seg2 : update\n            if (O.z==o.y) O.z = n.y;\n        }\n                 \n  if (keyDown(64+18))  O.y = 1.+U.x+4096.*U.y,O.z = -O.y; // key 'R' to reset ids\n  if (iMouse.w>0. && U == floor(iMouse.xy/R.y*N) && O.y!=O.z ) O.w = 1.-O.w; // mouse click for swap\n  if (U == vec2(0) && ( keyDown(64+18) || iMouse.w>0. ) ) O.x = 40.; // let re-converge \n  if (T().x > 0.) { if (U == vec2(0)) O.x-- ; return; }              // let re-converge\n//return;\n                 // --- connect them all : at block connection, swap\n    if ( iFrame%10==9 && O.y != O.z && H(U) >.995 ) // should be done after convergence, and not on parallel on same block\n // if ( iFrame%10==0 && O.y != O.z && H(vec2(H(O.yz),H(U))) >.99 )\n        O.w = 1.-O.w;\n     // O.y = 1.+U.x+4096.*U.y,\n     // O.z = -O.y;\n} ", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float N = 64.; // vertical number of tiles\n\n#define R    iResolution.xy\n#define T(U) texelFetch( iChannel0, ivec2(U+R)%ivec2(R), 0 )", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtV3zV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[334, 334, 372, 399, 857]], "test": "untested"}
{"id": "NtVGz3", "name": "spqr: tube 4", "author": "Fahrenheitrequited", "description": "a", "tags": ["a"], "likes": 2, "viewed": 127, "published": 3, "date": "1638098625", "time_retrieved": "2024-07-30T18:45:24.299616", "image_code": "/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\n\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/CorrodedBeasts.glsl\n*/\n\n#define MARCH_STEPS 100\n#define PART_COUNT 20\n\n#define time iTime\nfloat PI = acos(-1.0);\n//float gid;\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat getId(float t) {\n   return fract(sin(t * 478.129) * 992.421);\n}\n\nfloat box( vec2 p, vec2 b )\n{\n  vec2 q = abs(p) - b;\n  return max(q.x,q.y);\n}\n\n\nvec2 replim( in vec2 p, in float c, in vec2 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\n\nfloat m1(vec2 uv) {\n  \n \n  \n  \n  float t = iTime ;\n  float a = 3.141592/4.;\n  \n  \n  float thing = 10000.;\n  \n  for( float i = 0.; i <5.; i++){\n  \n    uv *= rot(i * a *2.);\n   \n    uv = abs(uv); \n    uv -= vec2(2,7);\n    uv = -abs(uv);\n   \n    \n    float x1 =  box(uv, vec2(1,1));\n    float x2 =  box(uv + vec2(2,11), vec2(1.,5.));\n    float x3 =  box(uv + vec2(14,14), vec2(.1,53.));\n    vec2 q = replim(uv, 10., vec2(11,2));\n    float x4 =  box(q , vec2(.2,2.));\n   \n    float x = min(x4,min(x1,(min(x2,x3))));\n    \n    thing = min(thing,x);\n   \n    \n \n\n  }\n  return thing ;\n\n}\n\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat hash21 (vec2 uv) {\n  return (fract(sin(uv.x * 1913.7361) + uv.y) * 4440.321);\n\n}\n\nfloat a = 3.141592;\nfloat glow = 0.;\nfloat m2(vec2 uv,float id) {\n\n\n  float dom = 20.;\n\n  uv = mod(uv,dom) - dom/2.;  \n\n \n  vec2 uv2 = uv;\n  float q = 1.4 ;\n  \n  float z = 10000.;\n  vec2 off = vec2(58,20);\n\n  for (float i = 0.; i <5.; i++) {\n    off *= rot(i/4.);\n   \n    uv.x *= q;\n\n    uv *= rot(a/2.);\n    \n    float a1 = m1(uv  + off );\n\n    z = min(z,a1) ;\n  }\n  vec2 arm = vec2(24);\n  arm *= rot(iTime * 7.1);\n  float u = length(uv2  + arm) -2.;\n  \n  //glow += .01/(.02 + pow(u,4.5));\n \n  return z/1.4;\n}\n\n\n\n\n\nfloat k1(vec2 p, float f1) {\n    vec2 pa = p;\n\n    float pi = 3.141592;\n    float z = 100000.;\n    for ( float j = 0.; j < 5.; j++) {\n        p = p.x > p.y ? p : p.yx;\n        for ( float i=0.; i < 3.; i++) {\n           //p = replim(p,6., vec2(0,50.));\n\n           p.x = abs(p.x) - 30. * f1 * f1;\n           float a= box(p,vec2(3,51) );\n           z = min(z,a);\n           vec2 pa = replim(pa,25., vec2(2. + f1));\n           float y = box(pa, vec2(8. ));\n           z = min(z,y);\n           p *= 1.12 + f1/3. ;\n           p += vec2(-46,0);\n           p *= rot(pi/2.);\n      \n        }\n    }\n \n    float c = box(pa, vec2(10,100));\n    \n   return min(z,c) ;\n \n}\nfloat pi = 3.141592;\nfloat k2(vec2 p, float f1){\n\n    float z = 10000.;\n    vec2 offset = vec2(200.,0) + vec2(45) * f1;\n   \n    for ( float i =1.; i < 3.; i++ ) {\n        //p = replim(p,8., vec2(0,10.));\n        float a = k1(p * 1.2 +vec2(0,70.) - vec2(17,29)  * 2.3, f1);\n        float b = k1(p + vec2(70,60) - vec2(50), f1);\n        float c = k1(p * 1.5+vec2(80,11), f1);\n\n        float d = a;//min(a,min(b,c));\n        z = min(z,d);\n        z = max(z, -b);\n        z = min(z,c);\n        p *= 1.5;\n        \n        offset *= rot(pi/(2.));\n        p += offset / pow(.3 + f1 * 3.,i );\n        p *= rot((pi/2.));\n       \n        \n    }\n     \n       \n       return z;\n}\n#define MOD3 vec3(.1031,.11369,.13787)\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\nconst float domain_width = 290.;\nconst float domain_height = 27.;//77.;\nvec3 domain = vec3(domain_width,domain_height,domain_width) ;\nfloat tick (float t ) {\n  float i = floor(t);\n  float r = fract(t);\n  r = sqrt(r);\n  return r + i;\n\n}\n\nfloat decal(vec3 p, vec3 domain) {\n\n// ink\n  // return m2(uv);\n  //vec2 q = kifs(p + pow(kifs(p),vec2(1. + sin(iTime))*.5+.5) );\n  \n  \n  vec3 id = floor(p/domain);\n  float f1 = fract(hash31(id) + tick(iTime * .13 ));\n  \n  p = mod(p,domain) - domain/2.;\n  //float one =  k1(kifs(p * f1 + kifs(p * f1)), f1);\n  //float one =  k1(kifs(p + kifs(p) + kifs(kifs(p))), f1);\n  //float one = k1(kifs(p + kifs(p)),f1);\n  float one = k2(p.xz,f1);\n  float two = box(p.xz, vec2(300.));\n  float final = max(one,two);\n  return final;\n}\n\n\n\n\n\nfloat tor(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat sph(vec3 p, float r) {\n  return length(p) - r;\n}\n\nvec3 rep( vec3 p, vec3 c )\n{\n    return mod(p,c) - 0.5 * c;\n}\n\n\nvec3 replim( in vec3 p, in float c, in vec3 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\n\n\n\nvec3 moda(vec3 p, float rep, float off) {\n  vec2 rp = vec2(atan(p.z,p.x)/(2.0*PI), length(p.xz));\n  rp.x=(fract(rp.x*rep-0.5+off)-0.5)/rep;\n  rp.x *= 2.0*PI;\n  return vec3(cos(rp.x)*rp.y,p.y,sin(rp.x)*rp.y);\n}\n\n\nfloat noise(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,37,289);\n  vec4 pos=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 val=mix(fract(sin(pos)*7894.552), fract(sin(pos+st.x)*7894.552), p.x);\n  vec2 val2=mix(val.xz,val.yw, p.y);\n  return mix(val2.x,val2.y, p.z);\n}\n\nfloat fbm(vec3 p) {\n\n  float d=0.5;\n  float f=0.0;\n  for(int i=0; i<5; ++i) {\n    f+=noise(p/d)*d;\n    d*=.5;\n  }\n  return f;\n}\nfloat rnd(float t) {\n  return fract(sin(t*789.451)*7541.223);\n}\nfloat trig (float t) {\n\n  \n  \n  \n   float wave = 0.;\n   for (float i = 0.; i < 5.; i++) {\n       wave += sin(i * .19 + rnd(i) * t);\n       wave += cos(-i * .99 + rnd(i + 1.13) * t);\n       \n   }\n \n \n  \n  return wave;\n  \n}\nvec3 wave (float t) {\n    float x = trig(t);\n    float y = trig(t + 171.321);\n    float z = trig(t + 471.341);\n    \n    return vec3(x,y,z);\n    \n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\nvec3 smin(vec3 a, vec3 b, float h) {\n  vec3 k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\nvec3 tunnel(vec3 p){\n  vec3 off=vec3(0);\n  off.x += sin(p.z*0.2)*1.5;\n  off.y += sin(p.z*0.3)*1.3;\n  return off;\n}\n\n\nfloat surge (float tt) {\n\n   return (1. - cos(mod(tt*pi,pi))/2.)+floor(tt);\n \n}\n\n\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\n\nvec3 flit(float t) {\n\n  vec3 x = normalize(vec3(1));\n  float t1 = tick(t);\n  float t2 = tick(t * .71);\n  float t3 = tick(t * .55);\n  x.yz *= rot(t1);\n  x.xz *= rot(t2);\n  x.yx *= rot(t3);\n  \n  return x;\n}\n\nvec3 bezier( float t ){\n  vec3 one = lattice(floor(t));\n  vec3 two = lattice(floor(t+1.));\n  float per = fract(t);\n  \n  return mix(one,two,per);\n  \n}\nvec3 s;\nint matter = 0;\n\nvec3 probe;\nfloat map(vec3 p) {\n\n// geo\n \n\n  // tunell\n  float minimum = 6.74;\n  float seper = .74;\n  \n  float hole1 = -cyl(p.xy,minimum + 0. * seper);\n  float wall1 = cyl(p.xy, minimum + .2 * seper);\n  float tunnel1 = max(hole1,wall1);\n  \n  \n  float hole2 = -cyl(p.xy,minimum + 8. * seper);\n  float wall2 = cyl(p.xy, minimum + 8.2 * seper);\n  float tunnel2 = max(hole2,wall2);\n  \n  float hole3 = -cyl(p.xy,minimum + 16. * seper);\n  float wall3 = cyl(p.xy, minimum + 16.2 * seper);\n  float tunnel3 = max(hole3,wall3);\n  \n  \n  float tunnel = min(min(tunnel1, tunnel2),tunnel3);\n  \n  matter = 1;\n  return tunnel;\n  \n  /*\n  float ball = sph(p - probe, 1.);\n\n \n  float final = min(ball,tunnel);\n  \n  if ( tunnel == final) {\n      matter = 1;\n  }\n  if ( ball == final) {\n      matter =2;\n  }\n  return final;\n  */\n\n \n}\n\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    float res = 1.;\n    float k = 2.;\n    \n    \n    for( float t=mint; t<maxt; )\n    {\n        \n        float h = map(ro + rd*t);\n        //h = abs(h);\n        if( h<0.001 ){\n            return 0.0;\n        }\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\n\nfloat sss(vec3 p, vec3 l, float d) {\n  return smoothstep(0.0,1.0,map(p+l*d)/d);\n}\n\n\n\nfloat rnd(vec2 t) {\n  return fract(dot(sin(t*vec2(789.451)+t.yx*vec2(842.544)),vec2(7541.223)));\n}\n\n\n\n\n\nfloat shadow(vec3 p, vec3 l, float maxdist, int stepcount, float limit) {\n  float shad=1.0;\n  float dd=0.0;\n  for(int i=0; i<stepcount; ++i) {\n    float d=min(map(p), maxdist);\n    if(d<limit) {\n      shad=0.0;\n      break;\n    }\n    if(dd>=maxdist) {\n      break;\n    }\n  \n    p += l*d;\n    dd+= d;\n \n  }\n  return shad;\n}\n\n\n\nfloat intersect(vec3 p, vec3 l, float maxdist, int stepcount, float limit) {\n  float shad=1.0;\n  float dd=0.0;\n  for(int i=0; i<stepcount; ++i) {\n    float d=min(map(p), maxdist);\n    if(d<limit) {\n\n       float granularity = 20. ;\\\n       \n       float z = decal(p  * granularity, domain );\n       if (  z < 4.5) {\n          d = .1;\n       } else {\n         shad=0.0;\n         break;\n       }\n    }\n   \n    if(dd>=maxdist) {\n      break;\n    }\n  \n    p += l*d;\n    dd+= d;\n \n  }\n  return shad;\n}\n\n\nvec3 vollight ( vec3 lightpos, vec3 s, vec3 r, vec2 uv, float limit) {\n\n  float rand=rnd(uv);\n  \n  \n  const int volsteps=120; //50\n  float voldist = 15.0;\n  float stepsize = voldist/float(volsteps);\n  vec3 lr=r*stepsize;\n  vec3 lp=s + lr*rand;\n  float stepdist=rand*stepsize;\n  vec3 atcol=vec3(0);\n  \n  for(int i=0; i<volsteps; ++i) {\n  \n    if(stepdist>limit) {\n      break;\n    }\n    \n    vec3 lv = lightpos-lp;\n    float ldistvol = length(lv);\n    lv = normalize(lv);\n    float shadvol = intersect(lp, lv, ldistvol, 10, 0.01);\n    atcol += 5./(0.01+(pow(ldistvol,2.))) * shadvol;\n   \n \n    lp+=lr;\n    stepdist+=stepsize;\n    \n  }\n  return atcol;\n}\n\n\n\n\n\nvec3 nav_source (float tt ) {\n//  vec3 source = lattice(tt + 53.1) * 39.3 ;\n  vec3 source = bezier(tt + 53.1) * 39.3 ;\n\n  \n  return source;\n}\nvec3 nav_target (float tt ) {\n  //vec3 target = lattice(tt+1.) * 19.;\n  vec3 target = bezier(tt+1.) * 19.;\n\n  \n  return target;\n}\n\n\n \nfloat factor (float t) {\n    return (atan(40. * sin(t))/atan(40.)) * .5 + .5;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n \n\n  // nav\n    \n   // one \n   \n   \n   float tt = 133.191 + iTime *.3 ;\n\n   tt = tt + sin(tt)  + tt * .1;\n   vec3 source = nav_source(tt) ;\n   vec3 target = nav_target(tt) ;\n \n   source.z += 22. * tt;\n   target.z += 22. * tt;\n \n   \n   \n  // probe =  vec3(0,0, sin(iTime * .91 + 1.5) * 74. + source.z);\n   \n\n \n  vec3 cz=normalize(target-source);\n\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz*0.7);\n  \n  //r.xy *= rot(sin(tick(iTime))*.2);\n\n  vec3 p=source;\n  //float i=0.;\n  float mask=1.0;\n  float d = 10000.0;\n  float dd = 0.;\n  float rand=rnd(uv);\n  \n  \n  // march\n  float granularity = 20. ;\n  bool hit = false;\n  float i ;\n  float z;\n  float res = 1.;\n  for( z=0.; z < 1000.; ++z) {\n    i = z;\n    d=map(p);\n    d = abs(d);\n    if(d<0.01) {\n    \n       \n      i = decal(p  * granularity, domain );\n     \n      if (matter == 1) { \n          if (i > 4.5) {\n            d = .1;\n          } else {\n            hit = true;\n            break;\n          }\n      } else {\n           hit = true;\n            break;\n       \n      \n      }\n    }\n    if ( dd > 10000.) break;\n    dd += d;\n    p+=r*d;\n  }\n  \n  // hue\n\n  vec3 col = vec3(1.);\n  \n  i = decal(p  * granularity, domain );\n  \n  if ( matter == 1) {\n      if ( i > 0.0 && i < 3.0) {\n          col = vec3(0);\n      }\n\n      if ( i > -12.0 && i < 0.0) {\n          col = vec3(.1,.1,.5)*.3;\n        \n      }\n  }\n  if ( matter == 2) {\n      col = vec3(.8,.4,.2);\n  }\n    if ( matter == 3) {\n      col = vec3(1);\n  }\n \n\n \n \n //vec3 atcol = vollight(probe, source , r, uv, dd);\n //col += atcol * .5;\n \n \n \n \n //vec3 atcol = vollight(probe, s, r, uv, dd);\n //col += atcol * .1;\n \n  // sky\n  if (! hit ) {\n\n  \n    float per = dot(r, normalize(vec3(0,2,2)))  * .5 + .5;\n    per = pow(per,2.);\n   \n    col =   mix(  vec3(.5), vec3 (.5) *.1, per);\n    \n  }\n  \n  fragColor = vec4(col, 1);\n\n}\n\n\n  \n\n\n\n/*\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}\n\n*/\n\n/*\n float diff = max(0.0,dot(n,light)*0.5+0.5);\n  float fren = pow(1.+dot(n,r),2.);\n  float sss = sss(p,r,4.) * 2.;\n  float spec= pow(max(dot(reflect(-light,n),-r),.0), 10.) * 5.;\n  float shad = shadow(p, normalize(-light), .1, length(light-p));\n  float fog =  pow(i/1000.,2.);\n  \n  col -= diff * .1;\n  //col += fren;\n  //col += sss;\n  //col += spec;\n  //col *= shad;\n  //col = mix(col, vec3(0), fog);\n  */", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtVGz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[295, 295, 314, 314, 383], [385, 385, 407, 407, 454], [456, 456, 485, 485, 533], [536, 536, 583, 583, 629], [631, 631, 650, 650, 1209], [1211, 1211, 1253, 1253, 1360], [1362, 1362, 1386, 1386, 1448], [1487, 1487, 1515, 1515, 1960], [1966, 1966, 1994, 1994, 2625], [2647, 2647, 2674, 2674, 3293], [3333, 3333, 3356, 3356, 3471], [3607, 3607, 3630, 3630, 3708], [3710, 3710, 3744, 3838, 4230], [4236, 4236, 4263, 4263, 4331], [4333, 4333, 4361, 4361, 4385], [4386, 4386, 4415, 4415, 4502], [4505, 4505, 4533, 4533, 4559], [4561, 4561, 4589, 4589, 4622], [4625, 4625, 4672, 4672, 4718], [4722, 4722, 4763, 4763, 4931], [4934, 4934, 4955, 4955, 5246], [5248, 5248, 5267, 5267, 5375], [5376, 5376, 5396, 5396, 5439], [5440, 5440, 5462, 5462, 5661], [5662, 5662, 5683, 5683, 5808], [5810, 5810, 5849, 5849, 5926], [5928, 5928, 5964, 5964, 6042], [6044, 6044, 6064, 6064, 6158], [6161, 6161, 6185, 6185, 6240], [6244, 6244, 6265, 6265, 6314], [6316, 6316, 6341, 6341, 6810], [6812, 6812, 6832, 6832, 7016], [7018, 7018, 7041, 7041, 7167], [7205, 7205, 7224, 7247, 8005], [8007, 8007, 8071, 8071, 8353], [8356, 8356, 8375, 8375, 8494], [8496, 8496, 8537, 8537, 8583], [8585, 8585, 8621, 8621, 8666], [8670, 8670, 8689, 8689, 8768], [8774, 8774, 8847, 8847, 9096], [9100, 9100, 9176, 9176, 9596], [9599, 9599, 9669, 9669, 10250], [10256, 10256, 10285, 10331, 10397], [10398, 10398, 10427, 10467, 10527], [10532, 10532, 10556, 10556, 10616], [10619, 10619, 10676, 10676, 12719]], "test": "untested"}
{"id": "NlKGRc", "name": "Ever Evolving Maze", "author": "andrinr", "description": "Give it a few seconds", "tags": ["maze"], "likes": 6, "viewed": 254, "published": 3, "date": "1638096779", "time_retrieved": "2024-07-30T18:45:25.073547", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 buffer = texture(iChannel0,uv).xyz;\n    float r = sin(buffer.x);\n    float g = sin(buffer.x + 2.0);\n    float b = sin(buffer.x + 1.0);\n    r = float(int(r * 1.7));\n    vec3 col = vec3(r);// * buffer.x;\n    fragColor = vec4( col,1.);\n    //fragColor = vec4(buffer,1.);\n    }", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Andrin Rehmann\n// 2021\n// andrinrehmann.ch\n// andrinrehmann@gmail.com\n\n#define EXPANSION 2.5\n\n//note: uniformly distributed, normalized rand, [0;1[\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nfloat rand( vec2 uv )\n{\n\tfloat t = fract( iTime );\n\treturn nrand( uv + 0.07*t );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat du = 1. / iResolution.x;\n    float dv = 1. / iResolution.y;\n    \n\tvec2 uv = fragCoord/iResolution.xy;\n    \n    // Cell\n\tfloat y = texture(iChannel0,uv).x;\n    \n    // sum of surrounding y's\n    float l = texture(iChannel0,uv + vec2(-du,0)).x;\n    float d = texture(iChannel0,uv + vec2(0,-dv)).x;\n    float u = texture(iChannel0,uv + vec2(0,dv)).x;\n    float r = texture(iChannel0,uv + vec2(du,0)).x;\n\n    float tl = 0.3;\n    float tu = 0.7;\n    // \n    if (u > tu && d < tl || \n        d > tu  && u < tl || \n        l > tu && r < tl ||  \n        r > tu && l < tl)\n    {\n        y += 0.2;\n    }\n    else\n    {\n        y *= 0.99;\n    }\n    \n    \n    //y *= 0.99;\n    \n    // sum of surrounding y's\n    float s = 1./16. * texture(iChannel0,uv + vec2(-du,-dv)).x +\n              3./16.  * texture(iChannel0,uv + vec2(-du,0)).x + \n              1./16. * texture(iChannel0,uv + vec2(-du,dv)).x + \n              3./16.  * texture(iChannel0,uv + vec2(0,-dv)).x + \n              3./16.  * texture(iChannel0,uv + vec2(0,dv)).x +\n              1./16. * texture(iChannel0,uv + vec2(du,-dv)).x +\n              3./16.  * texture(iChannel0,uv + vec2(du,0)).x + \n              1./16. * texture(iChannel0,uv + vec2(du,dv)).x;\n              \n    y = 0.91 * y + 0.09 * s;\n\n\n    if (rand(uv) > 0.9998)\n    {\n        y = 1.0;\n    }\n    \n    // Mouse interaction\n    if (distance(iMouse.xy, fragCoord) < 1. && iMouse.z > 0.){\n        y = 1.0;\n    }\n    \n    // Init\n    if (iFrame < 1){\n        y = float(int(rand(uv)*2.0));\n    }\n    \n    fragColor = vec4(y, 0, 0, 1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlKGRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 430]], "test": "untested"}
{"id": "NtKGRc", "name": "Fork Single pas guil 898", "author": "guil", "description": "Single pass fluid simulation using Mykhailo Moroz reintegration algorithm.", "tags": ["fluid"], "likes": 12, "viewed": 366, "published": 3, "date": "1638095377", "time_retrieved": "2024-07-30T18:45:25.890363", "image_code": "#define R iResolution.xy\n#define T1(U) texture(iChannel0,U/R)\n\nvoid mainImage( out vec4 C, in vec2 U )\n{   \n\n    float m = T1(U).w;//masse\n    float ms = (sign(m -1.)+1.)*.5;\n    float v = length(T1(U).xy)/10.;//velocity\n    \n    \n    C = .5*m*vec4(1.,1.2,2.,1);\n    \n    if (U.x < 0.2*R.x&&U.y < 0.5*R.y) C = vec4(0.5);\n    if (U.x < 0.4*R.x&&U.y < 0.3*R.y) C = vec4(0.5);\n    \n}  ", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define dt .2\n#define g .1\n#define l .1\n#define h 2\n#define r 1.3\n\nvec2 R;\nvec4 Mouse;\nfloat t;\nint Frame;\n\n#define T(p) texture(ch,(p)/R)\n\nvoid pass( out vec4 Q, in sampler2D ch, in vec2 U )\n{ \n    Q = vec4(0);\n    vec4 dQ = vec4(0);\n    float qw =T(U).w;\n    for (int x = -h; x <= h; x++)\n    for (int y = -h; y <= h; y++)\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = T(U+u);\n        vec2 w1 = clamp(U+u+a.xy*dt-0.5*r,U - 0.5,U + 0.5),\n             w2 = clamp(U+u+a.xy*dt+0.5*r,U - 0.5,U + 0.5);\n        float m = (w2.x-w1.x)*(w2.y-w1.y)/(r*r);\n        Q.xy += m*a.w*a.xy;\n        Q.w += m*a.w;\n        if(x!=0||y!=0)dQ.xy -= (qw<1.)?a.w*(a.w-1.)*u/dot(u,u):qw*qw*a.w*u/dot(u,u);       \n    }\n    if (Q.w>0.)\n        Q.xy/=Q.w;\n    Q.y -= dt*g;\n    Q.xy += dt*l*dQ.xy;\n    \n    //Boundaries\n    if (Frame < 1) Q = vec4(0,0,1,0);\n    if (U.x < 1.||U.y < 1.) Q.xy *= 0.;\n    if (R.x-U.x < 1.||R.y-U.y < 1.) Q.w *= 0.;\n    if (U.x < 0.2*R.x&&U.y < 0.5*R.y) Q.xy *= 0.;\n    if (U.x < 0.4*R.x&&U.y < 0.3*R.y) Q.xy *= 0.;\n \tif (length(U-vec2(0,0.9*R.y)) < .02*R.y) {Q.xy= Q.xy*.5+.5*vec2(.6+0.8*sin(1.5*t),0); Q.w = 1.;};\n    \n    //click mouse to add a circular obstacle\n    if(length(Mouse.xy - U) < 20. && Mouse.z > 0.5)\n        Q.xyw = vec3(0,0,1);\n    \n    Q = clamp(Q, vec4(-5,-5,0,0), vec4(5,5,0,15));\n\n}", "buffer_a_code": "void mainImage( out vec4 Q, in vec2 U )\n{      \n    R = iResolution.xy; t = iTime; Mouse = iMouse; Frame = iFrame;\n    pass( Q, iChannel0, U );\n    \n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 Q, in vec2 U )\n{      \n    R = iResolution.xy; t = iTime; Mouse = iMouse; Frame = iFrame;\n    pass( Q, iChannel0, U );\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 Q, in vec2 U )\n{      \n    R = iResolution.xy; t = iTime; Mouse = iMouse; Frame = iFrame;\n    pass( Q, iChannel0, U );\n    \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 Q, in vec2 U )\n{      \n    R = iResolution.xy; t = iTime; Mouse = iMouse; Frame = iFrame;\n    pass( Q, iChannel0, U );\n    \n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtKGRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 104, 104, 380]], "test": "untested"}
{"id": "ftV3z3", "name": "LUT 2", "author": "turboplay", "description": "Impoted from https://github.com/Oncorporation/obs-shaderfilter", "tags": ["filter", "lut"], "likes": 3, "viewed": 502, "published": 3, "date": "1638093259", "time_retrieved": "2024-07-30T18:45:26.652325", "image_code": "// Color Grade Filter by Charles Fettinger for obs-shaderfilter plugin 4/2020\n//https://github.com/Oncorporation/obs-shaderfilter\n//OBS messed up the LUT system, this is basically the old LUT system\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     float lut_amount_percent = iTime*100.;\n     float lut_scale_percent = 100.;\n     float lut_offset_percent = 0.;\n \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float lut_amount = clamp(lut_amount_percent *.01, -2.0, 2.0);\n\tfloat lut_scale = clamp(lut_scale_percent *.01,-2.0, 2.0);\n\tfloat lut_offset = clamp(lut_offset_percent *.01,-2.0, 2.0);\n\n\tvec4 textureColor = texture(iChannel0, uv);\n\tconst vec3 coefLuma = vec3(0.2126, 0.7152, 0.0722);\n\tfloat lumaLevel = dot(coefLuma, textureColor.rgb);\n\tfloat blueColor = lumaLevel;//textureColor.b * 63.0;\n\n\tvec2 quad1;\n\tquad1.y = floor(floor(blueColor) / 8.0);\n\tquad1.x = floor(blueColor) - (quad1.y * 8.0);\n\n\tvec2 quad2;\n\tquad2.y = floor(ceil(blueColor) / 8.0);\n\tquad2.x = ceil(blueColor) - (quad2.y * 8.0);\n\n\tvec2 texPos1;\n\ttexPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\n\ttexPos1.y = (quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g);\n\n\tvec2 texPos2;\n\ttexPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\n\ttexPos2.y = (quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g);\n\n\tvec4 newColor1 = texture(iChannel1, texPos1);\n\tnewColor1.rgb = newColor1.rgb * lut_scale + lut_offset;\n\tvec4 newColor2 = texture(iChannel1, texPos2);\n\tnewColor2.rgb = newColor2.rgb * lut_scale + lut_offset;\n\tvec4 luttedColor = mix(newColor1, newColor2, fract(blueColor));\n\n\tvec4 final_color = mix(textureColor, luttedColor, lut_amount);\n\tfragColor= vec4(final_color.rgb, textureColor.a);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftV3z3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[204, 204, 261, 261, 1836]], "test": "untested"}
{"id": "7lyGz3", "name": "Foggy Glass Ball", "author": "BeardThings", "description": "Playing around with some scattering equations.", "tags": ["raymarching", "noise", "reflection", "volume", "lighting", "glass", "foggy", "ball", "scattering", "cloudy", "phase", "henyeye", "greenstein"], "likes": 7, "viewed": 314, "published": 3, "date": "1638066453", "time_retrieved": "2024-07-30T18:45:27.434235", "image_code": "const float pi=3.1415;\n\n// Henyey-Greenstein\nfloat hg(float g,float lDotV)\n{\n    return 1./(4.*pi)*(1.-g*g)/pow(1.+g*g-2.*g*lDotV,3./2.);\n}\n\n// Forward+back scatter approx\nfloat phase(float ldotv)\n{\n    return mix(hg(0.6,ldotv),hg(-0.3,ldotv),0.3);\n}\n\n// Simple noise for some nice variety\nfloat noise(vec3 p)\n{\n    // Some curl noise here could be interesting\n    return 1.0-texture(iChannel1,p*0.25+vec3(iTime*0.03,0.,0.)).r*0.35;\n}\n\nbool sphere(vec3 o, vec3 v, float r, out vec2 t)\n{\n    float a=1.0;//dot(v,v); v is expected to be normalized\n    float b=2.*dot(v,o);\n    float c=dot(o,o)-r*r;\n    float d=b*b-4.*a*c;\n    \n    t=vec2((-b-sqrt(d))/(2.*a), (-b+sqrt(d))/(2.*a));\n    return d>=0.;\n}\n\nfloat fresnel(float r1, float r2, vec3 n, vec3 i)\n{\n\tfloat r0 = (r1 - r2) / (r1 + r2);\n\tr0 *= r0;\n\tfloat a = min(1.0 - dot(n, i), 1.0);\n\treturn r0 + (1.0 - r0)*a*a*a*a*a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    float aspect = iResolution.y / iResolution.x;\n    vec3 v=normalize(vec3(0.,0.,1.)+vec3(uv.x,0.,0.)+vec3(0.,uv.y*aspect,0.));\n    vec3 o=vec3(0.,0.,-2.);\n    float r=0.9;\n    vec3 ab=vec3(3.0, 5.0, 4.0)*0.45;\n    float radiance=80.0;\n    \n    vec3 tex=pow(texture(iChannel0,v).rgb,vec3(1.0/2.2));\n    \n    fragColor.rgb = tex.rgb;\n    vec2 t;\n    if(sphere(o, v,r, t))\n    {   \n        vec3 o2s=-o;\n        float w=length(o2s)/dot(normalize(o2s),v);\n        float d2e=r-sqrt(w*w-dot(o2s,o2s));\n        \n        vec3 sp=v*t.x+o;\n        vec3 n = normalize(sp);\n        \n        float rot=iTime*0.5;\n        vec3 lp = normalize(vec3(cos(rot),0.2,-sin(rot)))*1.8;\n        vec3 l = normalize(lp-sp);\n        \n        int steps=64;\n        float depth=(t.y-t.x);\n        float s=depth/float(steps);\n        vec3 irradiance=vec3(0.);\n        float tcc=0.;\n        for(int i=0;i<steps;i++)\n        {\n            vec3 p=(s*float(i)+t.x)*v+o;\n            // Bit of noise for texture\n            float n=noise(p);\n            tcc+=s*n;\n            // TODO: Could simplify this branch\n            vec2 t2;\n            if(sphere(p,l,r,t2))\n                irradiance+=exp((-tcc-t2.y)*ab);\n            else\n                irradiance+=exp(-tcc*ab);\n        }\n        \n        vec3 sl=reflect(v,n);\n        vec3 sc=pow(texture(iChannel0,sl).rgb,vec3(1.0/2.2));\n        \n        vec3 h=normalize(sl-v);\n        float fres=fresnel(1.0,2.0,h,-v);\n        vec3 indirectSpec=sc;\n        \n        float ldotv=dot(l,v);\n        // TODO: Add some specular highlights\n        vec3 diffuse=tex*exp(-tcc*ab)+irradiance*phase(ldotv)*phase(1.)*radiance*s;\n        fragColor.rgb=mix(diffuse,indirectSpec,fres);\n    }  \n    \n    // Linear->SRGB\n    fragColor.rgb = pow(fragColor.rgb,vec3(2.2));\n    // Simple reinhard\n    fragColor.rgb = fragColor.rgb/(fragColor.rgb+vec3(1.0));\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lyGz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 45, 76, 76, 139], [141, 172, 198, 198, 250], [252, 290, 311, 360, 434], [436, 436, 486, 486, 699], [701, 701, 752, 752, 873], [875, 875, 932, 932, 2833]], "test": "untested"}
{"id": "7tG3z3", "name": "Shadertoy Spinner 2", "author": "aiekick", "description": "[url=https://twitter.com/joe_ryba/status/1464712353614860293]Inspiration[/url]", "tags": ["shadertoy", "spinner"], "likes": 39, "viewed": 502, "published": 3, "date": "1638065091", "time_retrieved": "2024-07-30T18:45:28.206171", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2021 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned with Noodlesplate (https://github.com/aiekick/NoodlesPlate)\n\n// Inspired by the twit of @Joe_Ryba \n// https://twitter.com/joe_ryba/status/1464712353614860293\n\n// Use the code from mattz in his \"glyphspinner\" shader, for font sdf extraction \n// https://www.shadertoy.com/view/XsVcDy\n\n// fork of my Shadertoy Spinner\n// https://www.shadertoy.com/view/wdtXzn\n\n#define CHAR_WIDTH 6.\n#define CHAR_DEPTH (0.05 + 0.15 * (sin(iTime * 0.5) * 0.5 + 0.5))\n//#define CHAR_DEPTH 0.2\n#define ANGLE_OFFSET 1.74\n//#define COUNT_WORDS ((cos(iTime * 0.5) * 0.5 + 0.5) * 5.0)\n#define COUNT_WORDS 2.0\n#define RADIUS 0.6\n#define TWISTING_ANGLE 1.0\n\n// for have the good angle as time 0 for the thumbnail\n#define THUMBNAIL_TWISTING_ANGLE_OFFSET -0.5\n\n//#define WIRE_CHARS\n#define WIRE_CHARS_THICK 0.02\n\n// sdf thick when not in wire\n#define SDF_THICk_OFFSET 0.03\n\n#define COUNT_CHARS 10\n//                 S  H  A  D  E  R  T  O  Y  _\nint[] text = int[](67,56,49,52,53,66,68,63,73,0);\n\t\t\t\n// common part used by the map and mat functions\n// return the two sdf's, the torus with squared section, the font letters\nvoid common_map(vec3 p, out float dtorus, out float dfont) {\n    // rotation sheme\n\tconst float a = -ANGLE_OFFSET;\n\tp.xz *= mat2(cos(a),-sin(a),sin(a),cos(a));\n\t\n    // circular path\n    vec2 path = vec2(length(p.xz) - RADIUS, p.y);\n    \n\t// rotation\n\tfloat an = atan(p.x,p.z) * TWISTING_ANGLE + \n        THUMBNAIL_TWISTING_ANGLE_OFFSET + iTime;\n\tpath *= mat2(cos(an), -sin(an), sin(an), cos(an));\n\t\n    // torus sdf\n    dtorus = length(max(abs(path) - vec2(CHAR_DEPTH,0.15),0.0));\n\t\n    // texture uv based on angle\n    vec2 uv = vec2(-atan(p.x,p.z)/3.14159 * COUNT_WORDS, -path.y) * CHAR_WIDTH * 0.5;\n    \n    // char case\n\tfloat cs = CHAR_WIDTH/float(COUNT_CHARS);\n    float idx = floor(uv.x/cs); // idx\n\tuv.x = mod(uv.x, cs) - cs * 0.5;\n    \n    // limit id for avoid array overflow\n\tint id = int(mod(idx,float(COUNT_CHARS)));\n    \n    // font sdf\n\tdfont = approx_font_dist(iChannel0, uv, 16 + text[id]) - 0.005;\n\t\n    #ifdef WIRE_CHARS\n    \tdfont = abs(dfont) - WIRE_CHARS_THICK;\n    #else\n    \tdfont -= SDF_THICk_OFFSET;\n    #endif\n    \n    // white space\n    if (text[id] == 0) dfont = 0.1;\n}\n\n// return the final SDF\nfloat map(vec3 p) {\n    float dtorus, dfont;\n    common_map(p, dtorus, dfont);\n    \n    // final df\n\treturn max(dtorus, dfont);\n}\n\n// same code as map but with decomposition of the last max()\n// for return the material id\nfloat mat(vec3 p) {\n\tfloat dtorus, dfont;\n    common_map(p, dtorus, dfont);\n    \n    // max() decomposition for get df id\n\tif (dtorus > dfont)\n\t\treturn 1.0;\n\treturn 0.0;\n}\n\n// get normal for the surface point and a precision\nvec3 getNormal(vec3 p, float prec) {\n\tvec3 e = vec3(prec, 0, 0);\n\treturn normalize(vec3(\n\t\tmap(p+e.xyz)-map(p-e.xyz),\n\t\tmap(p+e.yxz)-map(p-e.yxz),\n\t\tmap(p+e.zyx)-map(p-e.zyx)));\n}\n\n// IQ Occ\nfloat getAmbiantOcclusion(vec3 p, vec3 n, float k) {\n    const float aoStep = 0.1; \n\tfloat occl = 0.;\n    for(int i = min(iFrame,0); i < 6; ++i)\n    {\n        float diff = float(i)*aoStep;\n        float d = map(p + n*diff);\n        occl += (diff - d) * pow(2., float(-i));\n    }\n    return min(1., 1. - k*occl);\n}\n\n// IQ Shadow\nfloat getShadow(vec3 ro, vec3 rd, float minD, float maxD, float k) {\n    float res = 1.0;\n    float d = minD;\n\tfloat s = 0.;\n    for(int i = min(iFrame,0); i < 20; ++i) {\n        s = map(ro + rd * d);\n        if( abs(s)<d*d*1e-5 ) return 0.0;\n        res = min( res, k * s / d );\n\t\td += s;\n        if(d >= maxD) break;\n    }\n    return res;\n}\n\n// get the perpsective camera\nvec3 cam(vec2 uv, vec3 ro, vec3 cv, float fov) {\n\tvec3 cu = normalize(vec3(0,0,1));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y = cross(z,x);\n  \treturn normalize(z + fov*uv.x*x + fov*uv.y*y);\n}\n\n// from IQ https://www.shadertoy.com/view/MsS3Wc\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 si = iResolution.xy;\n    vec2 uv = (2.*fragCoord.xy-si)/si.y;\n    \n\tvec3 ro = vec3(0, 2.2, 0);\n  \tvec3 cv = vec3(0);\n\tvec3 rd = cam(uv, ro, cv, 0.4);\n\t\n    vec3 col = vec3(0.1);\n\n    float s = 1., d = 0., md = 100.;\n\tfor (int i = 0; i < 500; i++) {\n\t\tif (abs(s)<0.01 || d > 100.) break;\n\t\ts = map(ro + rd * d);\n\t\td += s * 0.1;\n\t}\n\t\n\tif (d < md) {\n\t\tvec3 p = ro + rd * d;\n\t\tvec3 n = getNormal(p, 0.01);\n\t\t\n\t\t// light pos\n\t\tvec3 lp = vec3(0,5,0);\n\t\t\n\t\t// light dir\n\t\tvec3 ld = normalize(lp - p);\n\t\t\t\t\t\t\t\t\n        // diffuse, ambiant occlusion, shadow, specular\n\t\tfloat diff = pow(dot(n, ld) * .5 + .5,2.0);\n\t\tfloat ao = getAmbiantOcclusion(p, n, 40.0);\n\t\tfloat sha = clamp(getShadow(p, ld, 0.01, 150.0, 5.0), 0. ,0.9);\n\t\tfloat spe = pow(max(dot(-rd, reflect(-ld, n)), 0.0), 32.0);\n\t\t\n\t\tif (mat(p) < 0.5) { \n\t\t\t// smooth hsv for letters body\n            vec3 base = hsv2rgb_smooth(vec3(atan(p.x,p.z)/3.14159*0.5 - iTime * 0.1, 0.8, 0.8)); \n            // vary base color according to ao\n\t\t\tcol = mix(base, vec3(1), ao) * 0.5;\n\t\t} else { \n            // reflected gold for letters section\n            col = vec3(1.0, 0.85, 0.0) * \n                texture(iChannel1, reflect(rd, n)).rgb;\t\n        }\n\t\t\n\t\tcol += diff * sha * 0.5 + spe;\n\t\tcol = clamp(col, 0., 1.);\n\t}\n\t\n\tcol = sqrt(col*col*1.5); // gamma correction\n\tfragColor = vec4(col,1);\n}", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//////////////////////////////////////////////////////////////////////////////\n// from mattz \"glyphspinner\" shader: https://www.shadertoy.com/view/XsVcDy\n// texture is 1024x1024\nconst float TEX_RES = 1024.;\n// texture is 16x16 glyphs\nconst float GLYPHS_PER_UV = 16.;\n// since the texture is uint8 it has a bias to represent 0\nconst float TEX_BIAS = 127./255.;\n// get font UV coords from screen coords\nvec2 font_from_screen(vec2 tpos, vec2 char_pos) \n{    \n    return (tpos + char_pos + 0.5)/GLYPHS_PER_UV;\n}\nfloat sample_dist_gaussian(sampler2D sam, vec2 uv) \n{\n    float dsum = 0.;\n    float wsum = 0.;\n    const int nstep = 3;\n    const float w[3] = float[3](1., 2., 1.);\n    for (int i=0; i<nstep; ++i) \n\t{\n        for (int j=0; j<nstep; ++j) \n\t\t{    \n            vec2 delta = vec2(float(i-1), float(j-1))/TEX_RES;   \n            float dist = textureLod(sam, uv-delta, 0.).w - TEX_BIAS;\n            float wij = w[i]*w[j];\n            dsum += wij * dist;\n            wsum += wij;\n        }\n    }\n    return dsum / wsum;\n}\nfloat approx_font_dist(sampler2D sam, vec2 p, int cidx) \n{\n    vec2 cpos = vec2(float(cidx%16), float(cidx/16));\n    vec2 uv = font_from_screen(p, cpos);\n    float fd = sample_dist_gaussian(sam, uv); \n    return fd;   \n}\n//////////////////////////////////////////////////////////////////////////////\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tG3z3.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1132, 1255, 1315, 1337, 2354], [2356, 2380, 2399, 2399, 2509], [2511, 2602, 2621, 2621, 2773], [2775, 2827, 2863, 2863, 3006], [3008, 3018, 3070, 3070, 3331], [3333, 3346, 3414, 3414, 3688], [3690, 3720, 3768, 3768, 3946], [3948, 4030, 4064, 4064, 4240], [4242, 4242, 4299, 4299, 5645]], "test": "untested"}
{"id": "7tGGz3", "name": "Walk 2d-n3 using Structs", "author": "pyBlob", "description": "Mouse: change strength of action (bottom left: base pose, top right: good walk).\n\nGraphs from Top to Bottom (dashed line shows strength of an action):\n- angles of left leg\n- angles of right leg\n- ankle.y of both legs\n- ankle.x of both legs", "tags": ["mouse", "walk", "struct", "camtimer"], "likes": 11, "viewed": 421, "published": 3, "date": "1638054809", "time_retrieved": "2024-07-30T18:45:29.169595", "image_code": "// Body Design and Base Animation by jorge2017a2: https://www.shadertoy.com/view/ftGGzy\n\nconst float     PI = radians(180.);\nconst float TWO_PI = 2. * PI;\n\nmat2 R(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    // https://iquilezles.org/articles/distfunctions2d\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp(dot(pa,ba) / dot(ba,ba), 0.0, 1.0);\n    return length(pa - ba*h);\n}\n\n\n//\n// Position structs\n//\n\nstruct XArm\n{\n    vec2 shoulder, elbow, hand;\n};\n\nstruct XLeg\n{\n    vec2 hip, knee, ankle, toe;\n};\n\nstruct XBody\n{\n    vec2 head;\n    XArm armLeft, armRight;\n    XLeg legLeft, legRight;\n};\n\nconst XArm xarm = XArm(\n    vec2(3, 12),\n    vec2(3, 9),\n    vec2(3, 6)\n);\n\nconst XLeg xleg = XLeg(\n    vec2(3, 8),\n    vec2(3, 5),\n    vec2(3, 2),\n    vec2(4, 2)\n);\n\nconst XBody xbody = XBody(\n    vec2(3, 13),\n    xarm, xarm,\n    xleg, xleg\n);\n\n\n//\n// Color structs\n//\n\nstruct ColArm\n{\n    vec3 upper, lower;\n};\n\nstruct ColLeg\n{\n    vec3 upper, lower, foot;\n};\n\nstruct ColBody\n{\n    vec3 head, spine;\n    ColArm armLeft, armRight;\n    ColLeg legLeft, legRight;\n};\n\nconst vec3 lightgreen = vec3(0,1,0);\nconst vec3 red = vec3(1,0,0);\nconst vec3 blue = vec3(0,0,1);\nconst vec3 pink = vec3(1,.3,.5);\nconst vec3 orange = vec3(1,.5,0);\nconst vec3 yellow = vec3(1,1,0);\nconst vec3 sky = vec3(.5,.7,1);\nconst vec3 water = vec3(.2,.7,1);\nconst vec3 gray = vec3(.5);\nconst vec3 black = vec3(0);\nconst vec3 white = vec3(1);\n\nconst ColBody colBody = ColBody(\n    sky, lightgreen,\n    ColArm(yellow, pink),\n    ColArm(lightgreen, orange),\n    ColLeg(lightgreen, pink, blue),\n    ColLeg(lightgreen, red, blue)\n);\n\n//\n// Drawing\n//\n\nvec3 drawOver(vec3 c, vec3 color, float r)\n{\n    float a = smoothstep(0., fwidth(r), r);\n    return mix(color, c, a);\n}\n\nvec3 drawGraph(vec3 c, vec2 uv, vec3 color, float y)\n{\n    y -= uv.y;\n    float a = smoothstep(0., fwidth(y), abs(y));\n    return mix(color, c, a);\n}\n\nvec3 drawDashed(vec3 c, vec2 uv, vec3 color, float y)\n{\n    y -= uv.y;\n    float a = smoothstep(0., fwidth(y), abs(y));\n\n    float dash = sin(uv.x/fwidth(uv.x)*TWO_PI/16.);\n    float b = smoothstep(0., fwidth(dash), dash);\n\n    return mix(color, c, max(a, b));\n}\n\nvec3 drawSegment(vec3 c, vec2 p, vec2 a, vec2 b, vec3 color, float radius)\n{\n    return drawOver(c, color, sdSegment(p, a, b) - radius);\n}\n\nconst float figureThickness = 0.04;\n\nvec3 drawArm(vec3 c, vec2 p, XArm xarm, ColArm colArm)\n{\n    c = drawSegment(c, p, xarm.shoulder, xarm.elbow, colArm.upper, figureThickness);\n    c = drawSegment(c, p, xarm.elbow   , xarm.hand , colArm.lower, figureThickness);\n    return c;\n}\n\nvec3 drawLeg(vec3 c, vec2 p, XLeg xleg, ColLeg colLeg)\n{\n    c = drawSegment(c, p, xleg.hip  , xleg.knee , colLeg.upper, figureThickness);\n    c = drawSegment(c, p, xleg.knee , xleg.ankle, colLeg.lower, figureThickness);\n    c = drawSegment(c, p, xleg.ankle, xleg.toe  , colLeg.foot , figureThickness);\n    return c;\n}\n\nvec3 drawCircle(vec3 c, vec2 p, vec2 center, float radius, vec3 color)\n{\n    return drawOver(c, color, distance(p, center) - radius);\n}\n\nvec3 drawBody(vec3 c, vec2 p, XBody xbody, ColBody colBody)\n{\n    c = drawArm(c, p, xbody.armLeft, colBody.armLeft);\n    c = drawLeg(c, p, xbody.legLeft, colBody.legLeft);\n    c = drawCircle(c, p, xbody.head, 0.5, colBody.head);\n    c = drawSegment(c, p, xbody.armLeft.shoulder, xbody.legLeft.hip, colBody.spine, figureThickness);\n    c = drawLeg(c, p, xbody.legRight, colBody.legRight);\n    c = drawArm(c, p, xbody.armRight, colBody.armRight);\n    return c;\n}\n\n\n//\n// Animation curves\n//\n\nvoid base_pose(out float ang1, out float ang2, out float ang3, float t, float r1, float r2, float r3)\n{\n    float t1, t2, t3;\n\n    t1=t;\n    t2=(1.0 + sin(t+PI));\n    t3=(1.0 + sin(t+PI));\n\n    ang1 = r1 * sin(t1);\n    ang2 = r2 * sin(t2);\n    ang3 = r3 * sin(t3);\n}\n\nvoid dont_trip_over(inout float f, inout float ang2, inout float ang3, float t)\n{\n    float lift = 1.2;\n    float drop = 4.7;\n    float b2 =  0.7;\n    float b3 = -0.9;\n\n    float phase = mod(t, TWO_PI);\n\n    // use this, to see where the action is active\n    // also helps with adjusting lift, drop, b2 and b3.\n    //if (lift < phase && phase < drop) ang2 += b2;\n    //if (lift < phase && phase < drop) ang3 += b3;\n\n    f *=\n      + smoothstep(lift, lift + 1.8, phase) // lift the leg smoothly\n      - smoothstep(drop - 1.5, drop, phase) // drop the leg smoothly\n      ;\n\n    // use this, to get the final smooth motion.\n    ang2 += b2 * f;\n    ang3 += b3 * f;\n}\n\nvoid horizontal_while_foot_on_ground(inout float f, inout float ang3, float t, float ang1, float ang2)\n{\n    float start = 4.7;\n    float duration = 2.8;\n\n    float phase = mod(t - start, TWO_PI);\n    \n    float angFlat = -ang1-ang2;\n\n    // use this, to see where the action is active\n    // also helps with adjusting start and duration.\n    //if (phase < duration) ang3 = angFlat-1.;\n\n    f *=\n      + smoothstep(0., 0.5, phase) // lift the leg smoothly\n      - smoothstep(duration - 1.2, duration, phase) // drop the leg smoothly\n      ;\n\n    // use this, to get the final smooth motion.\n    ang3 = mix(ang3, angFlat, f);\n}\n\n\n//\n// Action + Angle structs\n//\n\nstruct ActLeg\n{\n    float trip, ground;\n};\n\nstruct ActBody\n{\n    ActLeg legLeft, legRight;\n};\n\nstruct AngArm\n{\n    float shoulder, elbow;\n};\n\nstruct AngLeg\n{\n    float hip, knee, foot;\n    float fTrip, fGround;\n};\n\nstruct AngBody\n{\n    AngArm armLeft, armRight;\n    AngLeg legLeft, legRight;\n};\n\nAngLeg poseLeg(float t, ActLeg actLeg)\n{\n    float ang1, ang2, ang3;\n\n    base_pose(ang1, ang2, ang3, t, 0.6, 0.3, 0.2);\n    dont_trip_over(actLeg.trip, ang2, ang3, t);\n    horizontal_while_foot_on_ground(actLeg.ground, ang3, t, ang1, ang2);\n    \n    return AngLeg(ang1, ang2, ang3, actLeg.trip, actLeg.ground);\n}\n\nAngArm poseArm(float t)\n{\n    float ang1, ang2, ang3;\n\n    base_pose(ang1, ang2, ang3, t, 0.6, 0.2, 0.2);\n    \n    return AngArm(ang1, ang2);\n}\n\nAngBody poseBody(float t, ActBody actBody)\n{\n    return AngBody(\n        poseArm(t + .3                 ), poseArm(t + PI + .3                  ),\n        poseLeg(t     , actBody.legLeft), poseLeg(t + PI     , actBody.legRight)\n    );\n}\n\n\n//\n// Transforms\n//\n\nXArm bendArm(XArm xarm, AngArm angArm)\n{\n    vec2 v0 =                           xarm.shoulder;\n    vec2 v1 =              xarm.elbow - xarm.shoulder;\n    vec2 v2 = xarm.hand  - xarm.elbow                ;\n\n    vec2 q0 =                                          v0;\n    vec2 q1 = q0 + R(angArm.shoulder               ) * v1;\n    vec2 q2 = q1 + R(angArm.shoulder + angArm.elbow) * v2;\n\n    return XArm(q0, q1, q2);\n}\n\nXLeg bendLeg(XLeg xleg, AngLeg angLeg)\n{\n    vec2 v0 =                                      xleg.hip;\n    vec2 v1 =                          xleg.knee - xleg.hip;\n    vec2 v2 =             xleg.ankle - xleg.knee           ;\n    vec2 v3 = xleg.toe  - xleg.ankle                       ;\n\n    vec2 q0 =                                                  v0;\n    vec2 q1 = q0 + R(angLeg.hip                            ) * v1;\n    vec2 q2 = q1 + R(angLeg.hip + angLeg.knee              ) * v2;\n    vec2 q3 = q2 + R(angLeg.hip + angLeg.knee + angLeg.foot) * v3;\n\n    return XLeg(q0, q1, q2, q3);\n}\n\nXBody bendBody(XBody xbody, AngBody angBody)\n{\n    return XBody(\n        xbody.head,\n        bendArm(xbody.armLeft, angBody.armLeft),\n        bendArm(xbody.armRight, angBody.armRight),\n        bendLeg(xbody.legLeft, angBody.legLeft),\n        bendLeg(xbody.legRight, angBody.legRight)\n    );\n}\n\nfloat lowest_point_on_leg(XLeg xleg)\n{\n    return min(xleg.ankle, xleg.toe).y;\n}\n\nfloat lowest_point_on_body(XBody xbody)\n{\n    return min(lowest_point_on_leg(xbody.legLeft), lowest_point_on_leg(xbody.legRight));\n}\n\n//\n// Main\n//\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec3 col = gray;\n    \n    vec2 mouse = vec2(1);\n    if (iMouse.z > .5)\n        mouse = iMouse.xy / iResolution.xy;\n    \n    ActLeg actLeg = ActLeg(mouse.x, mouse.y);\n    ActBody actBody = ActBody(actLeg, actLeg);\n\n    float t = iTime;\n    AngBody angBody = poseBody(t, actBody);\n    XBody worldBody = bendBody(xbody, angBody);\n\n    // animation\n    {\n        float ground = lowest_point_on_body(worldBody);\n\n        vec2 uv = fragCoord / iResolution.y * 2.;\n        uv *= 7.;\n        uv -= vec2(2, 1. - ground);\n\n        col = drawBody(col, uv, worldBody, colBody);\n        col = drawSegment(col, uv - vec2(-0.8, ground), vec2(0, 0), vec2(6.5, 0), water, 0.08);\n    }\n    \n    // graphs\n    {\n        vec2 uv = (fragCoord + .5 - iResolution.xy / 2.) / iResolution.y * 2.;\n        uv -= vec2(.65, 0.);\n        uv /= 2.;\n\n        float t1 = uv.x * TWO_PI;\n        AngBody angBody1 = poseBody(t1, actBody);\n        XBody worldBody1 = bendBody(xbody, angBody1);\n        float ground1 = lowest_point_on_body(worldBody1);\n        \n        if (uv.x >= -.5 && uv.x <= +.5)\n        {\n            float phase = mod(t + PI, TWO_PI);\n            vec2 offset = vec2(.5, 0.);\n            vec2 scale = vec2(1. / TWO_PI, .1);\n\n            uv.y -= .35;\n            col = drawDashed(col, uv, colBody.legLeft.lower*.5, angBody1.legLeft.fTrip * .1);\n            col = drawDashed(col, uv, colBody.legLeft.foot*.5, angBody1.legLeft.fGround * .1);\n            col = drawGraph(col, uv, black, 0.);\n            col = drawGraph(col, uv, colBody.legLeft.upper, angBody1.legLeft.hip  * scale.y);\n            col = drawGraph(col, uv, colBody.legLeft.lower, angBody1.legLeft.knee * scale.y);\n            col = drawGraph(col, uv, colBody.legLeft.foot , angBody1.legLeft.foot * scale.y);\n\n            col = drawCircle(col, uv, vec2(phase, angBody.legLeft.hip )*scale-offset, .01, colBody.legLeft.upper);\n            col = drawCircle(col, uv, vec2(phase, angBody.legLeft.knee)*scale-offset, .01, colBody.legLeft.lower);\n            col = drawCircle(col, uv, vec2(phase, angBody.legLeft.foot)*scale-offset, .01, colBody.legLeft.foot );\n\n            uv.y += .25;\n            col = drawDashed(col, uv, colBody.legRight.lower*.5, angBody1.legRight.fTrip * .1);\n            col = drawDashed(col, uv, colBody.legRight.foot*.5, angBody1.legRight.fGround * .1);\n            col = drawGraph(col, uv, black, 0.);\n            col = drawGraph(col, uv, colBody.legRight.upper, angBody1.legRight.hip  * scale.y);\n            col = drawGraph(col, uv, colBody.legRight.lower, angBody1.legRight.knee * scale.y);\n            col = drawGraph(col, uv, colBody.legRight.foot , angBody1.legRight.foot * scale.y);\n\n            col = drawCircle(col, uv, vec2(phase, angBody.legRight.hip )*scale-offset, .01, colBody.legRight.upper);\n            col = drawCircle(col, uv, vec2(phase, angBody.legRight.knee)*scale-offset, .01, colBody.legRight.lower);\n            col = drawCircle(col, uv, vec2(phase, angBody.legRight.foot)*scale-offset, .01, colBody.legRight.foot );\n\n            uv.y += .25;\n            scale.y = .05;\n            col = drawDashed(col, uv, colBody.legLeft.lower*.5, angBody1.legLeft.fGround * .1);\n            col = drawDashed(col, uv, colBody.legRight.lower*.5, angBody1.legRight.fGround * .1);\n            col = drawGraph(col, uv, black, 0.);\n            col = drawGraph(col, uv, colBody.legLeft .lower, (worldBody1.legLeft .ankle.y-ground1) * scale.y);\n            col = drawGraph(col, uv, colBody.legRight.lower, (worldBody1.legRight.ankle.y-ground1) * scale.y);\n\n            col = drawCircle(col, uv, vec2(phase, worldBody1.legLeft .ankle.y-ground1)*scale-offset, .01, colBody.legLeft .lower);\n            col = drawCircle(col, uv, vec2(phase, worldBody1.legRight.ankle.y-ground1)*scale-offset, .01, colBody.legRight.lower);\n\n            uv.y += .25;\n            scale.y = .02;\n            col = drawGraph(col, uv, black, 0.);\n            col = drawGraph(col, uv, colBody.legLeft .lower, (worldBody1.legLeft .ankle.x) * scale.y);\n            col = drawGraph(col, uv, colBody.legRight.lower, (worldBody1.legRight.ankle.x) * scale.y);\n\n            col = drawCircle(col, uv, vec2(phase, worldBody1.legLeft .ankle.x)*scale-offset, .01, colBody.legLeft .lower);\n            col = drawCircle(col, uv, vec2(phase, worldBody1.legRight.ankle.x)*scale-offset, .01, colBody.legRight.lower);\n        }\n    }\n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tGGz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[156, 156, 173, 173, 239], [241, 241, 293, 348, 465], [1704, 1704, 1748, 1748, 1823], [1825, 1825, 1879, 1879, 1974], [1976, 1976, 2031, 2031, 2238], [2240, 2240, 2316, 2316, 2378], [2417, 2417, 2473, 2473, 2659], [2661, 2661, 2717, 2717, 2979], [2981, 2981, 3053, 3053, 3116], [3118, 3118, 3179, 3179, 3578], [3608, 3608, 3711, 3711, 3874], [3876, 3876, 3957, 3957, 4538], [4540, 4540, 4644, 4644, 5166], [5498, 5498, 5538, 5538, 5811], [5813, 5813, 5838, 5838, 5956], [5958, 5958, 6002, 6002, 6194], [6218, 6218, 6258, 6258, 6633], [6635, 6635, 6675, 6675, 7224], [7226, 7226, 7272, 7272, 7518], [7520, 7520, 7558, 7558, 7600], [7602, 7602, 7643, 7643, 7734], [7751, 7751, 7803, 7803, 12204]], "test": "untested"}
{"id": "slV3zV", "name": "Breathing...", "author": "kmaork", "description": "Interface:\n- Click to change color scheme\n- Drag to rotate and zoom\n\nSadly, it seems that shadertoy does not support mouse interaction on moblie", "tags": ["2d", "interactive", "animation"], "likes": 7, "viewed": 289, "published": 3, "date": "1638047353", "time_retrieved": "2024-07-30T18:45:29.938539", "image_code": "const float PI         = 3.1415926538;\nconst float COLOR_FREQ = 0.08;\nconst float RAD_FREQ   = 0.14;\nconst float ROT_FREQ   = 0.10;\nconst float RRR_FREQ   = 0.09;\n\nfloat wave(in float x) {\n    return cos(2. * PI * x);\n}\n\nfloat cycle(in float x) {\n    return 0.5 * (wave(x) + 1.);\n}\n\nfloat powerCycle(in float x, in float deg) {\n    float w = wave(x);\n    float mag = pow(abs(w), 1. / deg);\n    return 0.5 * ((w > 0. ? mag : -mag) + 1.);\n}\n\nfloat oscillator(in float freq) {\n    return cycle(freq * iTime);\n}\n\nvec4 hue0(in float x) {\n    float base = 16. / 255.;\n    float range = 1. - base;\n    float c = cycle(x);\n    float r = base + c * range;\n    float g = sin(c * PI * 7.) * 140. / 255.;\n    float b = base + (1. - c) * range;\n    return vec4(r, g, b, 1);\n}\n\nvec4 hue1(in float x) {\n    float r = 0.05;\n    float g = powerCycle(x * 3.6, 9.) * 0.7;\n    float b = 0.08;\n    return vec4(r, g, b, 1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float rp = 3.;\n    float rs = 0.11;\n    \n    float sm = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord - iResolution.xy / 2.) / sm * fetchData(ZOOM_ADDR).x;\n    float dist = length(uv);\n    float x = uv.x;\n    float y = uv.y;\n    \n    float rad = oscillator(RAD_FREQ) * 0.7 + 0.75;\n    float a = fetchData(ANGLE_ADDR).x + atan(x, y) + (pow(dist * rs, rp) - pow(rad * rs, rp)) * (oscillator(ROT_FREQ) - 0.5) * 1.5;\n    x = sin(a) * dist;\n    y = cos(a) * dist;\n    float rrr = oscillator(RRR_FREQ) * 0.24 + 1.88;\n    float s = abs(atan(dist * dist - pow(rad, 3.)));\n    float c = COLOR_FREQ * iTime + (s * cos(pow(abs(x), rrr) * y) * cos(pow(abs(y), rrr) * x)) / pow(dist + 1., 1.4) * 1.25;\n    switch (int(fetchData(HUE_ADDR)) % 2) {\n    case 0:\n        fragColor = hue0(c);\n        break;\n    case 1:\n        fragColor = hue1(c);\n        break;\n    }\n    \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Method inspired from https://www.shadertoy.com/view/tdGBDG\n\n// x=current zoom\n// y=zoom when clicked\nconst int ZOOM_ADDR = 0;\n\n// x=current angle\n// y=angle when clicked\nconst int ANGLE_ADDR = 1;\n\nconst int MOUSE_WAS_DOWN_ADDR = 2;\n\nconst int HUE_ADDR = 3;\n\n#define fetchData(addr) texelFetch(iChannel0, ivec2(float(addr), 0.), 0)\n", "buffer_a_code": "const float ZOOM_INIT = 5.5;\nconst float ANGLE_INIT = 0.;\nconst float HUE_INIT = 0.;\n\nbool mouseDown() {\n    return iMouse.z > 0.;\n}\n\nbool mouseClicked() {\n    return iMouse.w > 0.;\n}\n\nbool mouseReleased() {\n    return !mouseDown() && fetchData(MOUSE_WAS_DOWN_ADDR).x == 1.;\n}\n\nbool click() {\n    return mouseReleased() && iMouse.xy == abs(iMouse.zw);\n}\n\nfloat vatan(in vec2 xy) {\n    return atan(xy.x, xy.y);\n}\n\nvec2 toCenter(in vec2 uv) {\n    return uv - iResolution.xy / 2.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    switch (int(fragCoord.x)) {\n    case ZOOM_ADDR:\n        if (iFrame == 0) {\n            fragColor.x = ZOOM_INIT;\n            break;\n        }\n        fragColor = fetchData(ZOOM_ADDR);\n        if (mouseClicked()) {\n            fragColor.y = fragColor.x;\n        } else if (mouseDown()) {\n            fragColor.x = length(toCenter(abs(iMouse.zw))) / length(toCenter(iMouse.xy)) * fragColor.y;\n        }\n        break;\n    case ANGLE_ADDR:\n        if (iFrame == 0) {\n            fragColor.x = ANGLE_INIT;\n            break;\n        }\n        fragColor = fetchData(ANGLE_ADDR);\n        if (mouseClicked()) {\n            fragColor.y = fragColor.x;\n        } else if (mouseDown()) {\n            fragColor.x = vatan(toCenter(abs(iMouse.zw))) - vatan(toCenter(iMouse.xy)) + fragColor.y;\n        }\n        break;\n    case MOUSE_WAS_DOWN_ADDR:\n        fragColor.x = mouseDown() ? 1. : 0.;\n        break;\n    case HUE_ADDR:\n        if (iFrame == 0) {\n            fragColor.x = HUE_INIT;\n            break;\n        }\n        fragColor = fetchData(HUE_ADDR);\n        if (click()) {\n            fragColor.x += 1.;\n        }\n        break;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slV3zV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 164, 188, 188, 219], [221, 221, 246, 246, 281], [283, 283, 327, 327, 438], [440, 440, 473, 473, 507], [509, 509, 532, 532, 762], [764, 764, 787, 787, 903], [905, 905, 960, 960, 1836]], "test": "untested"}
{"id": "flGGR3", "name": "hexatruchets", "author": "FabriceNeyret2", "description": "On hexagons there are 3 types of tiles, * 2,3 or 6 rotations.\n\nclick to see tiles", "tags": ["short", "doodles", "truchets", "entanglement"], "likes": 25, "viewed": 359, "published": 3, "date": "1638044168", "time_retrieved": "2024-07-30T18:45:30.703494", "image_code": "#define H(p)   fract(sin(dot(p, vec2(12.9898, 78.233))-floor(iTime)) * 43758.5453)\n#define S(v)   smoothstep( N/R.y, 0., v )\n#define hue(v) ( .6 + .6 * cos( .5+(v)  + vec4(0,23,21,0)  ) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float N = 32.,                                     // vertical number of tiles\n          s = sqrt(3.), r = 1./s;\n          \n    vec2 R = iResolution.xy,\n         U = N * u / R.y * mat2(s,-1,0,2)/4.,          // to tilted space\n         I = floor(U);                                 // I : hexa tile ID\n    U = fract(U) *  mat2(1,.5,0,s/2.) - vec2(1,r)/2.;  // U : local coords\n    U += U.y*s+abs(U.x) < 0. ? I.y--,   + vec2( 0,r)   // Set to hexagon over the 3\n        : U.x < 0.           ? I.x--, -.5*vec2(-1,r)   //   covered by the tilted cell\n        :                             -.5*vec2( 1,r);\n    O-=O;                                              // --- draw tiles\n // O += .5+.5*sin(60.*(length(U)-.5)); return;\n    float t = floor(3.*H(I)),                          // random tile type\n          a = floor(6.*H(I+.5))/6. *6.2831853;         // random tile rotation\n    U *= mat2( cos( a + vec4(0,1.57,-1.57,0) ) );      // do rotation\n    \n#define C(v,r)   S( abs(length(v)-r/2.) )              // draw among 3 types:\n                            \n    O +=   t==0. ? max(C( vec2(abs(U.x)-.5,U.y+r/2.) , r), // 3 short turns\n                           C( U - vec2(0,r), r) )\n         : t==1. ? max(max(C( U - vec2(.5,-s/2.), s),      // 2 larges + 1 short\n                           C( U + vec2(.5, s/2.), s)),\n                           C( U - vec2(0,r), r))\n         :         max(max(C( U - vec2(.5,-s/2.), s),      // 2 larges + 1 line\n                           C( U + vec2(.5,-s/2.), s)), \n                           S( abs(U.x*s+U.y) / 2.)  ); \n\n    if (iMouse.z > 0.) O *= hue(6.28*H(I));            // if click show tiling\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flGGR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[189, 189, 227, 227, 1875]], "test": "untested"}
{"id": "NtyGR3", "name": "Void Cells", "author": "acoo", "description": "Wavy cell stuff.  Click and drag! ", "tags": ["waves", "cells", "void"], "likes": 2, "viewed": 181, "published": 3, "date": "1638036951", "time_retrieved": "2024-07-30T18:45:31.466454", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) /iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec3 color = vec3(0.0);\n    \n    uv = mouse == vec2(0.0) ? uv - vec2(1.0) * (iResolution.xy / iResolution.y) : uv;\n    \n    vec3 endColor = vec3(0.3, 0.1, 0.6);\n    \n    uv *= 5.0;\n    // mouse -1 to 1\n    vec2 animOffset = vec2(sin(iTime * 0.15), cos(iTime * 0.15)) * 2.0 - 1.0;\n    vec2 mouseOffset = mouse != vec2(0.0) ? mouse * 2.0 - 1.0 : animOffset;\n    float n = dot(abs(uv), mouseOffset);\n    \n    // bg circles\n    vec2 offset = vec2(sin(iTime + n), cos(iTime + n));\n    float d = length(abs(fract(uv + offset)) - 0.5) - 0.5;\n    d = smoothstep(0.03, 0.0, abs(d));\n    \n    // draw circles\n    color += vec3(d);\n    \n    // move space to mouse\n    uv -= (mouse * 2.0 - 1.0) * 5.0 * (iResolution.xy / iResolution.y);\n    // make circle at mouse\n    float l = length(uv) - 0.1;\n    \n    color += mix(vec3(1.0), endColor, l);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtyGR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1040]], "test": "untested"}
{"id": "NlGGR3", "name": "Conic gradient of 2 colors", "author": "fb", "description": "Just a 2 color conic gradient", "tags": ["gradient"], "likes": 6, "viewed": 658, "published": 3, "date": "1638035080", "time_retrieved": "2024-07-30T18:45:32.228417", "image_code": "vec2 rotate(vec2 v, float angle) {\n    return vec2(\n            v.x * cos(angle) - v.y * sin(angle),\n            v.x * sin(angle) + v.y * cos(angle)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 startColor = vec4(1.0, 0.2, 0.2, 1.0);\n    vec4 endColor = vec4(0.2, 0.2, 1.0, 1.0);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 point = vec2(0.5, 0.5);\n    \n    vec2 relative = rotate(uv - point, iTime);\n\n    float angle = atan(relative.x, relative.y);\n    float t = (angle + 3.14) / 2.0 / 3.14;\n    \n    fragColor = mix(startColor, endColor, t);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlGGR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 157], [159, 159, 216, 216, 590]], "test": "untested"}
{"id": "stVGzV", "name": "Oklab", "author": "thepheer", "description": "LCh ↔ Lab ↔ XYZ ↔ sRGB\n\nhttps://bottosson.github.io/posts/oklab/\nhttps://bottosson.github.io/posts/colorpicker/\nhttps://raphlinus.github.io/color/2021/01/18/oklab-critique.html", "tags": ["oklab"], "likes": 5, "viewed": 447, "published": 3, "date": "1638032584", "time_retrieved": "2024-07-30T18:45:32.994369", "image_code": "#define rep(m, x) (mod(x, 2.0*(m)) - (m))\n#define sdf(w, d) smoothstep(1.5*(w), 0.0, d)\n#define plot(w, x, y) sdf(w, abs((x) - (y)))\n#define range(x, a, b) ((a) <= (x) && (x) < (b))\n\nvoid mainImage(out vec4 rgba, vec2 xy) {\n    vec2 px = 1.0/iResolution.xy;\n    vec2 uv = xy*px;\n    \n    const float tau = radians(360.0);\n    float L = 0.50 + 0.49*sin(tau*(0.2*uv.x - 0.1*iTime));\n    float C = 0.18*L*(1.0 - L*L*L);\n    float h = tau*(fract(uv.x + 0.5*iTime) - 0.5);\n\n    // LCh → Lab → sRGB → Lab → LCh\n    vec3 LCh1 = vec3(L, C, h);\n    vec3 Lab1 = LCh_to_Lab(LCh1);\n    vec3 sRGB = Lab_to_sRGB(Lab1);\n    vec3 Lab2 = sRGB_to_Lab(sRGB);\n    vec3 LCh2 = Lab_to_LCh(Lab2);\n    \n    float dashed = sdf(1.0, abs(rep(6.0, xy.x)) - 4.0);\n    float dotted = sdf(1.0, abs(rep(2.0, xy.x)));\n    vec3 split = 0.025*vec3(-1.0, 0.0, 1.0);\n    \n    vec3 plots =\n        plot(px.y, uv.y, 0.500)*dotted*0.1 +\n        plot(px.y, uv.y, 0.100)*dotted*0.1 +\n        plot(px.y, uv.y, 0.775 + 1e3*(LCh2 - LCh1) - split) +\n        plot(px.y, uv.y, 0.625 + 2e4*(Lab2 - Lab1) - split) +\n        plot(px.y, uv.y, 0.100 + 0.4*sRGB);\n\n    vec3 rgb =\n        range(uv.y, 0.9, 1.0) ? sRGB :\n    \tplots;\n\n    rgba = vec4(sRGB_OETF(rgb), 1.0);\n}", "image_inputs": [], "common_code": "// sRGB boilerplate\n\n#define xy_to_XYZ(x, y) vec3(x/y, 1.0, (1.0 - x - y)/y)\n#define diag3(v) mat3((v).x, 0.0, 0.0, 0.0, (v).y, 0.0, 0.0, 0.0, (v).z)\n#define primaries(rx, ry, gx, gy, bx, by) mat3(xy_to_XYZ(rx, ry), xy_to_XYZ(gx, gy), xy_to_XYZ(bx, by))\n#define whitepoint(wx, wy) xy_to_XYZ(wx, wy)\n#define colorspace(gamut, wp) gamut*diag3(inverse(gamut)*wp)\n\nconst vec3 D65 = whitepoint(0.31271, 0.32902);\nconst mat3 sRGB = primaries(0.64, 0.33, 0.30, 0.60, 0.15, 0.06);\nconst mat3 sRGB_to_XYZ = colorspace(sRGB, D65);\nconst mat3 XYZ_to_sRGB = inverse(sRGB_to_XYZ);\n\nvec3 sRGB_OETF(vec3 c) {\n    vec3 a = 12.92*c;\n    vec3 b = 1.055*pow(c, vec3(1.0/2.4)) - 0.055;\n    return mix(a, b, greaterThan(c, vec3(0.00313066844250063)));\n}\n\nvec3 sRGB_EOTF(vec3 c) {\n    vec3 a = c/12.92;\n    vec3 b = pow((c + 0.055)/1.055, vec3(2.4));\n    return mix(a, b, greaterThan(c, vec3(0.0404482362771082)));\n}\n\n// Oklab\n\nconst mat3 M1 = mat3(\n    +0.8189330101, +0.0329845436, +0.0482003018,\n    +0.3618667424, +0.9293118715, +0.2643662691,\n    -0.1288597137, +0.0361456387, +0.6338517070\n);\n\nconst mat3 M2 = mat3(\n    +0.2104542553, +1.9779984951, +0.0259040371,\n    +0.7936177850, -2.4285922050, +0.7827717662,\n    -0.0040720468, +0.4505937099, -0.8086757660\n);\n\nvec3 XYZ_to_Lab(vec3 XYZ) {\n    vec3 lms = M1*XYZ;\n    vec3 lms_p = sign(lms)*pow(abs(lms), vec3(1.0/3.0));\n    return M2*lms_p;\n}\n\nvec3 Lab_to_XYZ(vec3 Lab) {\n    vec3 lms_p = inverse(M2)*Lab;\n    vec3 lms = lms_p*lms_p*lms_p;\n    return inverse(M1)*lms;\n}\n\nvec3 LCh_to_Lab(vec3 LCh) {\n    return vec3(LCh.x, LCh.y*vec2(cos(LCh.z), sin(LCh.z)));\n}\n\nvec3 Lab_to_LCh(vec3 Lab) {\n    return vec3(Lab.x, length(Lab.yz), atan(Lab.z, Lab.y));\n}\n\nvec3 sRGB_to_Lab(vec3 sRGB) {\n    return XYZ_to_Lab(sRGB_to_XYZ*sRGB);\n}\n\nvec3 Lab_to_sRGB(vec3 Lab) {\n    return XYZ_to_sRGB*Lab_to_XYZ(Lab);\n}\n\nvec3 sRGB_to_LCh(vec3 sRGB) {\n    return Lab_to_LCh(sRGB_to_Lab(sRGB));\n}\n\nvec3 LCh_to_sRGB(vec3 LCh) {\n    return Lab_to_sRGB(LCh_to_Lab(LCh));\n}\n\nfloat L_to_Lr(float L) {\n    const vec3 k = vec3(0.206, 0.03, 1.206/1.03);\n    float x = k.z*L - k.x;\n    return 0.5*(x + sqrt(x*x + 4.0*k.y*k.z*L));\n}\n\nfloat Lr_to_L(float Lr) {\n    const vec3 k = vec3(0.206, 0.03, 1.206/1.03);\n    return (Lr*(Lr + k.x))/(k.z*(Lr + k.y));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stVGzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[183, 183, 223, 223, 1225]], "test": "untested"}
{"id": "7lG3RV", "name": "Late Night Waves", "author": "acoo", "description": "Some simple waves and space transformations.", "tags": ["waves"], "likes": 1, "viewed": 139, "published": 3, "date": "1638032301", "time_retrieved": "2024-07-30T18:45:33.789244", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0.0);\n    vec2 uv = 3.0 * (2.0 * fragCoord - iResolution.xy) /iResolution.y;\n    vec3 mainColor = vec3(0.4, 0.5, 0.8);\n\n    vec2 st = uv;\n    uv.x += sin(st.y + iTime) * cos(st.y + iTime);\n    uv.y += cos(st.x + iTime) * sin(st.x - iTime);\n\n    float c = cos(iTime) * 2.0 - 1.0;\n    float s = -sin(iTime) * 2.0 - 1.0;\n    mat2 rot = mat2\n    (\n         c, -s, \n         s,  c\n    );\n    \n    uv *= rot;\n    uv.x += sin(iTime) * 2.0 - 1.0;\n    uv.y -= cos(iTime) * 2.0 - 1.0;\n\n    uv.x = mod(10.0, abs(uv.x));\n    uv.y = mod(10.0, abs(uv.y));\n    \n    color = mix(vec3(1.0), mainColor, 1.0 - length(uv)) * (vec3(1.0) - vec3(abs(uv), 0.0));\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lG3RV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 759]], "test": "untested"}
{"id": "stKGRV", "name": "Grid Segments", "author": "SnoopethDuckDuck", "description": "This is a bit of a monster, could definitely be improved", "tags": ["e"], "likes": 7, "viewed": 292, "published": 3, "date": "1638031880", "time_retrieved": "2024-07-30T18:45:34.556193", "image_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat h21 (float a, float b, float sc) {\n    a = mod(a, sc); b = mod(b, sc);\n    return fract(sin(dot(vec2(a, b), vec2(12.9898, 78.233)))*43758.5453123);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec2 pnt(vec2 ipos, float sc) {\n    float h = h21(ipos.x, ipos.y, sc);\n    float t = iTime + 10. * h;\n    float k = 1.5 +  h;\n    return 0.4 * vec2(thc(4. * (1.-h), 100. + k * t), \n                      ths(4. * h, 100. + (1.-k) * t));\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b * cos(6.28318*(c*t+d) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/ iResolution.y;\n    uv += 2. + 0.03 * iTime;\n    \n    //float a = atan(uv.y, uv.x);\n    float r = length(uv); \n    //uv = vec2(a/pi,log(r) - 0.2 * iTime);\n    \n    float c = 100.;\n    // cant scale dynamically because sc used in h21 (bad)\n    float sc = 6.;\n    vec2 fpos = fract(sc * uv) - 0.;\n    vec2 ipos = floor(sc * uv) + 0.5;    \n    \n    // maybe this bit's not necessary, doesn't do much\n    float time = -0.1 * iTime;\n    float flT = floor(time);\n    float frT = fract(time);\n    \n    // Generate values for each corner of uv (sloppy)\n    // (transitions between different noise sets)\n    float l  = h21(flT + ipos.x + 1., flT + ipos.y,      c * sc);\n    float t  = h21(flT + ipos.x,      flT + ipos.y + 1., c * sc);\n    float tl = h21(flT + ipos.x + 1., flT + ipos.y + 1., c * sc);\n    float id = h21(flT + ipos.x,      flT + ipos.y,      c * sc);\n   \n    float l2  = h21(flT + ipos.x + 2., flT + ipos.y + 1., c * sc);\n    float t2  = h21(flT + ipos.x + 1., flT + ipos.y + 2., c * sc);\n    float tl2 = h21(flT + ipos.x + 2., flT + ipos.y + 2., c * sc);\n    float id2 = h21(flT + ipos.x + 1., flT + ipos.y + 1., c * sc);\n\n    l = mix(l, l2, frT);\n    t = mix(t, t2, frT);\n    tl = mix(tl, tl2, frT);\n    id = mix(id, id2, frT);\n\n    // Smooth fpos completely, so v noise looks better\n    vec2 sfpos = fpos * fpos * (3. - 2. * fpos);\n    \n    // Remove me maybe\n    sfpos = pow(sfpos,vec2(3.));\n    \n    // Smooth the grid uvs so different uvs meet continuously on the edges\n    fpos = mix(fpos, fpos * fpos * (3. - 2. * fpos), 0.5 * thc(4., iTime));\n    \n    // Box lerp between the corner values to get a radius value for this pixel\n    float v = l  * sfpos.x      * (1.-sfpos.y)\n     \t    + t  * (1.-sfpos.x) * sfpos.y\n     \t    + tl * sfpos.x      * sfpos.y\n      \t    + id * (1.-sfpos.x) * (1.-sfpos.y);\n    \n    // Warp again (maybe)\n    //fpos = mix(fpos, fpos * fpos * (3. - 2. * fpos), 0.5 * ths(4., iTime));\n    \n    // shift fpos correctly\n    fpos -= 0.5;\n    \n    // moving points for each cell\n    vec2 p = pnt(ipos, sc);\n\n    vec2 pl = -vec2(1.,0.) + pnt(ipos - vec2(1.,0.), sc);\n    vec2 pr =  vec2(1.,0.) + pnt(ipos + vec2(1.,0.), sc);\n    vec2 pt = -vec2(0.,1.) + pnt(ipos - vec2(0.,1.), sc);\n    vec2 pb =  vec2(0.,1.) + pnt(ipos + vec2(0.,1.), sc);\n       \n    // draw half of each segment for each cell\n    float dl = sdSegment(fpos, p, pl);\n    float dr = sdSegment(fpos, p, pr);\n    float dt = sdSegment(fpos, p, pt);\n    float db = sdSegment(fpos, p, pb);\n        \n    // Outline line segments, scale with v\n    // (m = thickness of line, n = thickness of outline)\n    float m = 0.05 + 0.07 * v;\n    float n = 0.5;\n    float sl = step(dl, m)-step(dl, n * m);\n    float sr = step(dr, m)-step(dr, n * m);\n    float st = step(dt, m)-step(dt, n * m);\n    float sb = step(db, m)-step(db, n * m);\n    \n    float s = max(max(sl, sr), max(st, sb));\n    \n    // Make v noise appear/disappear\n    v *= thc(4., 5. * v + 0.1 * h21(uv) + iTime);\n    \n    // Segment colors, changes if over v noise\n    vec3 col = pal(0.6 * v, vec3(0.), vec3(1.), vec3(1.),  \n                  (0.4 + pow(v,10.)) * v * vec3(0.,0.33,0.66));\n    col *= smoothstep(-0.5, 0.5, 0.5 - v) * s;\n    \n    // Color of v noise\n    vec3 vcol = 1.2 * (1.-s) * v * pal(r + 0.2 * iTime, vec3(1.), vec3(1.), vec3(1.), vec3(0.,0.33,0.66));\n    //vcol *= 2. * ths(2., r + 0.4 * iTime);\n    \n    col += vcol;\n    \n    //col += 1.2 * v + 0.2 * s * pal(0.6 * v , vec3(1.), vec3(1.), vec3(1.),  vec3(0.,0.33,0.66));\n    //col = -v + 1.-col;\n    \n    fragColor = vec4(col, 1.); //vec4(v);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stKGRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 49, 49, 90], [92, 92, 121, 121, 162], [164, 164, 184, 184, 259], [261, 261, 301, 301, 416], [418, 418, 470, 470, 589], [591, 591, 622, 622, 828], [830, 830, 898, 898, 942], [945, 945, 1002, 1002, 4621]], "test": "untested"}
{"id": "slKGzV", "name": "sin precision for large values 2", "author": "FabriceNeyret2", "description": "comparing  sin(x) and sin( mod(x,2pi))  for x (R) , x + 200.tau (G),   x + 400.tau (B).\nVertical grid = 10⁻³    Horizontal grid = 10⁻¹", "tags": ["bench", "bug"], "likes": 3, "viewed": 248, "published": 3, "date": "1638031112", "time_retrieved": "2024-07-30T18:45:35.325137", "image_code": "// variant of https://shadertoy.com/view/7tV3RV\n\n#define f sin                  // put the trigo func to test here\n\n#define S(v) smoothstep( 1./R.y, 0., v )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( u - .5*R ) / R.y;\n    float TAU = 6.28318530718; // indeed, 0718 useless, and 3 can be up to 7\n    O-=O;\n    vec4 X = U.x + vec4(0,200,400,0)*TAU;    // x + big offsets\n    O += S( abs(  U.y - 1e4* ( f(X) - f(mod(X,TAU)) ) )); // plot diffence * 10⁴\n            \n    U = abs(fract(10.*U+.5)-.5) / 10.;       // draw grid    \n    if (O==vec4(0)) O += S( min(U.x,U.y) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slKGzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[158, 158, 196, 196, 613]], "test": "untested"}
{"id": "7tV3zK", "name": "funny: init iTime is not zero", "author": "FabriceNeyret2", "description": "show iTime at frame 0:  try rewind multiple time.\n\nI'm not sure it really qualifies as a bug, anyway please keep it since it is very useful:\nwe can randomize differently at each rewind by putting iTime in the hash formula:\nif (iFrame==0){v = hash(U-iTime)", "tags": ["test", "bug", "trick", "hash", "itime"], "likes": 5, "viewed": 319, "published": 3, "date": "1638027234", "time_retrieved": "2024-07-30T18:45:36.089095", "image_code": "// --- utils from https://www.shadertoy.com/view/llySRh -----------------\nvec4 char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel3, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                        dFdx, dFdy );\n}\n\nvec4 pInt(vec2 p, float n) { // --- display int4\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(p - vec2(-.5,0), 45 ),\n        n = -n;\n\n    for (float i = 3.; i>=0.; i--) \n        n /=  9.999999, // 10., // for windows :-(\n        v += char(p - .5*vec2(i,0), 48+ int(fract(n)*10.) );\n    return v;\n}\n\nvec4 pFloat(vec2 p, float n) { // --- display float4.4\n    vec4 v = vec4(0);\n    if (n < 0.) v += char(p - vec2(-.5,0), 45 ), n = -n;\n    v += pInt(p,floor(n)); p.x -= 2.;\n    v += char(p, 46);      p.x -= .5;\n    v += pInt(p,fract(n)*1e4);\n    return v;\n}// ------------------------------------\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float t = T(0).x;\n    \n    U *= 4./iResolution.y; U.y -= 2.; U.x++;\n    O-=O;\n                   O += pInt( U, floor(t) ).x;   // iTime at frame 0, with many digits\n    U.x -= 2.;     O += char( U,46).x;\n    U.x -= .5;     O += pInt( U, floor(t*1e4) ).x;\n    U.x -= 2.;     O += pInt( U, floor(t*1e8) ).x;\n    U.x -= 2.;     O += pInt( U, floor(t*1e12) ).x;\n    \n    U.y += 1.5; U.x += 4.; O += pInt( U, T(0).y ).x; // iFrame ( always 0 for me )\n\n    \n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{\n    if ( iFrame < 1 ) { O.x = iTime; O.y = float(iFrame); return; }\n    O = T(U);                    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(U) texelFetch( iChannel0, ivec2(U), 0 )", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tV3zK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 74, 100, 100, 331], [333, 333, 361, 381, 642], [644, 644, 674, 698, 900], [941, 941, 979, 979, 1437]], "test": "untested"}
{"id": "7tKGzK", "name": "Single pass reintegration", "author": "guil", "description": "Single pass fluid simulation using Mykhailo Moroz reintegration algorithm.", "tags": ["fluid"], "likes": 14, "viewed": 439, "published": 3, "date": "1638023822", "time_retrieved": "2024-07-30T18:45:36.864022", "image_code": "#define R iResolution.xy\n#define T1(U) texture(iChannel0,U/R)\n\nvoid mainImage( out vec4 C, in vec2 U )\n{   \n\n    float m = T1(U).w;//masse\n    float ms = (tanh(m -1.)+1.)*.5;\n    float v = length(T1(U).xy)/10.;//velocity\n    \n    \n    C = .4*(m)*vec4(1.,1.2,2.,1);\n    \n    if (U.x < 0.2*R.x&&U.y < 0.5*R.y) C = vec4(0.5);\n    if (U.x < 0.4*R.x&&U.y < 0.3*R.y) C = vec4(0.5);\n    \n}  ", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define dt .2\n#define g .4\n#define l .15\n#define h 2\n#define r 1.2\n\nvec2 R;\nvec4 Mouse;\nfloat t;\nint Frame;\n\n#define T(p) texture(ch,(p)/R)\n\nvoid pass( out vec4 Q, in sampler2D ch, in vec2 U )\n{ \n    Q = vec4(0);\n    vec4 dQ = vec4(0);\n    for (int x = -h; x <= h; x++)\n    for (int y = -h; y <= h; y++)\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = T(U+u);\n        vec2 w1 = clamp(U+u+a.xy*dt-0.5*r,U - 0.5,U + 0.5),\n             w2 = clamp(U+u+a.xy*dt+0.5*r,U - 0.5,U + 0.5);\n        float m = (w2.x-w1.x)*(w2.y-w1.y)/(r*r);\n        Q.xy += m*a.w*a.xy;\n        Q.w += m*a.w;\n        if(x!=0||y!=0)dQ.xy -= a.w*(a.w-1.)*u/dot(u,u);       \n    }\n    if (Q.w>0.)\n        Q.xy/=Q.w;\n    Q.y -= dt*g;\n    Q.xy += dt*l*dQ.xy;\n    \n    //Boundaries\n    if (Frame < 1) Q = vec4(0,0,1,0);\n    if (U.x < 1.||U.y < 1.) Q.xy *= 0.;\n    if (R.x-U.x < 1.||R.y-U.y < 1.) Q.w *= 0.;\n    if (U.x < 0.2*R.x&&U.y < 0.5*R.y) Q.xy *= 0.;\n    if (U.x < 0.4*R.x&&U.y < 0.3*R.y) Q.xy *= 0.;\n \tif (length(U-vec2(0,0.9*R.y)) < 8.) {Q.xy= Q.xy*.5+.5*vec2(1.+0.4*sin(1.5*t),0); Q.w = 1.;};\n    \n    //click mouse to add a circular obstacle\n    if(length(Mouse.xy - U) < 20. && Mouse.z > 0.5)\n        Q.xyw = vec3(0,0,1);\n    \n    Q = clamp(Q, vec4(-5,-5,0,0), vec4(5,5,0,15));\n\n}", "buffer_a_code": "void mainImage( out vec4 Q, in vec2 U )\n{      \n    R = iResolution.xy; t = iTime; Mouse = iMouse; Frame = iFrame;\n    pass( Q, iChannel0, U );\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tKGzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 104, 104, 382]], "test": "untested"}
{"id": "7tK3RK", "name": "connected components in truchet5", "author": "FabriceNeyret2", "description": "Find the connected component.  \nEnriched tiles variant of https://shadertoy.com/view/NlGGRV ( accelerated variant of https://shadertoy.com/view/7ty3zG ): no with straight lines and crossings.\n\nclick to restart a new truchet tiling.  Scale N in Common.", "tags": ["flood", "short", "connected", "doodles", "truchets", "streamreduction"], "likes": 9, "viewed": 319, "published": 3, "date": "1638022954", "time_retrieved": "2024-07-30T18:45:37.636956", "image_code": "// enriched tiles variant of https://shadertoy.com/view/NlGGRV\n// accelerated variant of https://shadertoy.com/view/7ty3zG\n\n#define hue(v)  vec4( .6 + .6 * cos( .5+(v)  + vec3(0,23,21)  ) , 1 )\n#define S(v) smoothstep( N*1.5/R.y, 0., v )\nvoid mainImage( out vec4 O, vec2 u )\n{\n // O = T(u).agbr; return;\n    vec2 U = N * u / R.y + 0.*iTime, I = floor(U), F = fract(U);\n         \n    O = T(I);                                          // cell states \n                                                       // --- truchet drawing\n    if (O.w > 1.) {                                    // crossing type\n        F = abs(F-.5);\n        O =   S(min(F.x,F.y))                          // draw crossing\n            * hue( O[ F.x>F.y ? 1 : 2 ] );             // coloring\n      }\n    else {                                             // turns type\n        O.w > 0. ? F = vec2(1.-F.y,F.x) : F;\n        O =   S( abs(min(length(F),length(1.-F))-.5) ) // draw turns\n            * hue( O[ F.x+F.y < 1. ? 1 : 2 ] );        // coloring\n   }        \n // if (iMouse.z>0.) O += (1.-O.w)*.3*mod(I.x+I.y,2.); // debug: draw tiles\n // O += .3*T(I).w;\n} ", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define H(p)  fract(sin(dot(p, vec2(12.9898, 78.233))-iTime) * 43758.5453)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U -= .5;\n    if ( iFrame < 1 || iMouse.z>0.) {         // --- init: create truchet\n        vec2 I = U;                           // store truchet data\n        O.w = floor(4.*H(I));                 // tile type: crossing or turns of \\ or / axis\n        O.y = 1.+I.x+4096.*I.y;               // id of tile segment #1\n        O.z = -O.y;                           // id of tile segment #2\n        return;\n    }\n    \n    O = T(U);                                 // previous state\n    float Nx = floor(N*R.x/R.y);\n    vec4 T,t;\n    if (U.x <= Nx && U.y > N+4. && U.y <= N+N+4.) // keep previous version\n      { U.y -= N+4.; O = T(U); return; }\n      \n    if (U.x >= Nx+4. && U.x <= Nx+4.+Nx/8. && U.y <= N/8.) { // reduction map of change\n        O-=O;\n        U.x -= Nx+4.;\n        for (int k=0; k < 64; k++ ) {\n            vec2 V = 8.*U + vec2(k%8,k/8),\n                 o = T(V + vec2(0.,N+4.)).yz, // old vs new value\n                 n = T(V).yz;\n            if ( o != n ) O = vec4(o,n);      // if changed, store\n        }\n        return;\n    }\n    if (U.x > Nx || U.y > N) return;          // propagate only visible tiles\n\n                                              // --- propagate id along connections\n#define right      T(U+vec2(1,0)).y\n#define left     ( T = T(U-vec2(1,0)), T.w< 2. ? T.z : T.y )\n#define top      ( T = T(U+vec2(0,1)), T.w==0. ? T.y : T.z )\n#define bot      ( T = T(U-vec2(0,1)), T.w==1. ? T.y : T.z )\n    if (O.w==0.)      // tile contains:  \\     new id = min(connections)\n        O.y = min( O.y, min( left , bot )),\n        O.z = min( O.z, min( right, top ));\n    else if (O.w==1.) // tile contains:  /     new id = min(connections)\n        O.y = min( O.y, min( left , top )),\n        O.z = min( O.z, min( right, bot ));\n    else              // tile containes: +     new id = min(connections)\n        O.y = min( O.y, min( left, right)),\n        O.z = min( O.z, min( bot , top  ));\n\n // return;\n                  // --- shortcut: at color change, update the color source pixel\n    for( float j = 0.; j < N/8.; j++)\n        for( float i = 0.; i < Nx/8.; i++) {\n            T = T( vec2(Nx+4.+i,j) );\n            vec2 o = T.xy, n = T.zw;          // changed old->new value\n            if (O.y==o.x) O.y = n.x;          // oldvalue was my seg1 : update\n            if (O.y==o.y) O.y = n.y;\n            if (O.z==o.x) O.z = n.x;          // oldvalue was my seg2 : update\n            if (O.z==o.y) O.z = n.y;\n        }\n} ", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float N = 64.; // vertical number of tiles\n\n#define R    iResolution.xy\n#define T(U) texelFetch( iChannel0, ivec2(U+R)%ivec2(R), 0 )", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tK3RK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[238, 238, 276, 303, 1130]], "test": "untested"}
{"id": "flV3zV", "name": "Sine hash, large arguments", "author": "mla", "description": "A typical sine-based hash function, on left doing a 2pi wrap before calling sin, on the right, leaving it up to the sin function. Both Nvidia and Intel show substantially worse hashing in the unwrapped case for inputs > 1000 or so.", "tags": ["hash"], "likes": 5, "viewed": 274, "published": 3, "date": "1638021361", "time_retrieved": "2024-07-30T18:45:38.398918", "image_code": "float hash(in vec2 uv, bool domod)\n{\n    float PI = 3.14159265;\n    float modval = 2.0*PI;\n    modval = 1.23456789;\n    float seed = dot(uv, vec2(12.9898, 78.233));\n    if (domod) seed = mod(seed,modval);\n    return fract(43758.5453*sin(seed));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(hash(pow(10.0,mod(iTime,20.0))*uv,uv.x < 0.5));    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flV3zV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 246], [248, 248, 305, 305, 422]], "test": "untested"}
{"id": "ftKGzV", "name": "3D truchet - Bonus Stage", "author": "IWBTShyGuy", "description": "Heaven", "tags": ["truchet"], "likes": 10, "viewed": 299, "published": 3, "date": "1638016751", "time_retrieved": "2024-07-30T18:45:39.347382", "image_code": "// Copyright © 2021 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\n#if HW_PERFORMANCE!=0\n// If defined, activate anti-aliasing, level: 2 or 3\n#define AA 2\n#endif\n\n// Apply anti-aliasing to objects below this distance.\n#define AA_FAR 1.5\n\n// ----------------------- Config ----------------------- //\n// The larger these values, the greater the visual impact.\n// It also increases the load on the GPU.\n\n// Farthest distance to draw\nconst float FAR = 4.0;\n\n// the number of coins in one line\nconst int LINE_COIN = 3;\n\n// -------------------- Visual Config ------------------- //\nconst vec3 SUN_SHINE = normalize(vec3(1, -1, -1));\nconst float PIPE_SIZE = 0.075;\nconst float COIN_SIZE = 0.03;\n\n// --------------------- Basic SDF --------------------- //\n// https://iquilezles.org/articles/distfunctions\nfloat sdCylinder(in vec3 p, in float r, in float h) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdStar5(in vec2 p, in float r, in float rf) {\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\n// ----------------------- PIPE ----------------------- //\n// sdf\nfloat sdPipe(in vec3 p) {\n    p /= PIPE_SIZE;\n    float dist0 = sdCylinder(p, 0.5, 0.51);\n    float dist1 = sdCylinder(\n        p - vec3(0, 0.3, 0),\n        0.55, 0.15\n    ) - 0.06;\n    return min(dist0, dist1) * PIPE_SIZE;\n}\n\n// normal\nvec3 normalPipe(in vec3 p) {\n    const vec2 h = vec2(0.0001,0);\n    return normalize(vec3(\n        sdPipe(p+h.xyy) - sdPipe(p-h.xyy),\n        sdPipe(p+h.yxy) - sdPipe(p-h.yxy),\n        sdPipe(p+h.yyx) - sdPipe(p-h.yyx)\n    ));\n}\n\n// albedo\nvec3 albPipe(in vec3 p) {\n    float c = length(p.zx) / PIPE_SIZE;\n    c = smoothstep(0.0, 1.0, (c - 0.42) / 0.01);\n    return vec3(0, c, 0);\n}\n\n// radiance without distance decay\nfloat radPipe(in vec3 normal, in vec3 dir) {\n    float c0 = microfacet(\n        normal,\n        dir,\n        dir,\n        0.0,\n        0.5\n    );\n    float c1 = microfacet(\n        normal,\n        dir,\n        SUN_SHINE,\n        0.9,\n        0.5\n    );\n    return c0 * 0.2 + c1 * 0.8;\n}\n\n// ----------------------- COIN ----------------------- //\n// sdf\nfloat sdCoin(in vec3 p) {\n    p /= COIN_SIZE;\n    float dist = sdCylinder(p, 0.98, 0.08) - 0.02;\n    return dist * COIN_SIZE;\n}\n\nconst vec3 COIN_ALBEDO = vec3(241, 208, 12) / 255.0;\n\n// normal mapping\nvec3 normalCoin(in vec3 p) {\n    float r = 0.98 * COIN_SIZE;\n    float h = 0.08 * COIN_SIZE;\n    vec2 e = vec2(0.0001,0);\n    vec3 base = normalize(vec3(\n        sdCoin(p + e.xyy) - sdCoin(p - e.xyy),\n        sdCoin(p + e.yxy) - sdCoin(p - e.yxy),\n        sdCoin(p + e.yyx) - sdCoin(p - e.yyx)\n    ));\n    if (abs(p.y) < h - 0.001) {\n        return base;\n    } else {\n        vec2 uv = p.zx / r;\n        float r0 = length(uv) - 0.7;\n        float c0 = min(\n            max(0.0, r0 - 0.05),\n            max(0.0, 0.15 - r0)\n        ) * 20.0;\n        vec2 tmp = normalize(p.zx);\n        vec3 n0 = vec3(tmp.y, 0, tmp.x);\n        vec2 e = vec2(0.00001, 0);\n        float r1 = sdStar5(uv, 0.6, 0.4);\n        float c1 = -min(\n            max(0.0, r1 + 0.025),\n            max(0.0, 0.025 - r1)\n        ) * 20.0;\n        vec3 n1 = normalize(vec3(\n            sdStar5(uv+e.yx, 0.6, 0.4) - sdStar5(uv-e.yx, 0.6, 0.4),\n            0,\n            sdStar5(uv+e.xy, 0.6, 0.4) - sdStar5(uv-e.xy, 0.6, 0.4)\n        ));\n        return normalize(base - c0 * n0 - c1 * n1);\n    }\n}\n\n// radiance without distance decay\nfloat radCoin(in vec3 normal, in vec3 dir) {\n    float c0 = microfacet(\n        normal,\n        dir,\n        dir,\n        0.0,\n        0.5\n    );\n    float c1 = microfacet(\n        normal,\n        dir,\n        SUN_SHINE,\n        0.9,\n        0.5\n    );\n    return c0 * 0.2 + c1 * 0.8;\n}\n\n// ----------------------- SDF ----------------------- //\n#define rotate3D(n, t) mat3( \\\n    cos(t) + n.x * n.x * (1.0 - cos(t)), \\\n    n.x * n.y * (1.0 - cos(t)) + n.z * sin(t), \\\n    n.z * n.x * (1.0 - cos(t)) - n.y * sin(t), \\\n    n.x * n.y * (1.0 - cos(t)) - n.z * sin(t), \\\n    cos(t) + n.y * n.y * (1.0 - cos(t)), \\\n    n.y * n.z * (1.0 - cos(t)) + n.x * sin(t), \\\n    n.z * n.x * (1.0 - cos(t)) + n.y * sin(t), \\\n    n.y * n.z * (1.0 - cos(t)) - n.x * sin(t), \\\n    cos(t) + n.z * n.z * (1.0 - cos(t))  \\\n)\n\nconst mat3 T0 = rotate3D(normalize(vec3(0, 1, -1)), PI);\nconst mat3 T1 = rotate3D(normalize(vec3(1, 0, 1)), PI);\nconst mat3 T2 = rotate3D(normalize(vec3(0, 1, 1)), PI);\n\n// hexahedron group\nconst mat3[] S = mat3[](\n    mat3(1, 0, 0, 0, 1, 0, 0, 0, 1),\n    T2,\n    T1,\n    T2 * T1,\n    T1 * T2,\n    T2 * T1 * T2,\n    T0,\n    T2 * T0,\n    T1 * T0,\n    T2 * T1 * T0,\n    T1 * T2 * T0,\n    T2 * T1 * T2 * T0,\n    T0 * T1,\n    T2 * T0 * T1,\n    T1 * T0 * T1,\n    T2 * T1 * T0 * T1,\n    T1 * T2 * T0 * T1,\n    T2 * T1 * T2 * T0 * T1,\n    T0 * T1 * T2,\n    T2 * T0 * T1 * T2,\n    T1 * T0 * T1 * T2,\n    T2 * T1 * T0 * T1 * T2,\n    T1 * T2 * T0 * T1 * T2,\n    T2 * T1 * T2 * T0 * T1 * T2\n);\n\nstruct MarchingOutput {\n    float dist;\n    int shape;\n    mat3 mat;\n    vec3 p;\n};\n\n// cell-wise sdf\n// This time, the objects are sparse, so we don't need to think about the other cells.\nMarchingOutput sDist(in vec3 p, in float t) {\n    int index = int(hash13(floor(p) + 0.23) * 24.0);\n    p = fract(p);\n    \n    MarchingOutput op, op0;\n    \n    // ----------------- PIPE ----------------- //\n    op0.shape = 0;\n    \n    op0.mat = mat3(1);\n    op0.p = p - vec3(0.5, 0.5 * PIPE_SIZE, 0.5);\n    op0.dist = sdPipe(op0.p);\n    op = op0;\n    \n    op0.mat = rotate3D(vec3(1, 0, 0), PI);\n    op0.p = op0.mat * (p - vec3(0.5, 1.0 - 0.5 * PIPE_SIZE, 0.5));\n    op0.dist = sdPipe(op0.p);\n    if (op0.dist < op.dist) op = op0;\n    \n    op0.mat = rotate3D(vec3(0, 0, 1), PI/2.0);\n    op0.p = op0.mat * (p - vec3(0.5 * PIPE_SIZE, 0.5, 0.5));\n    op0.dist = sdPipe(op0.p);\n    if (op0.dist < op.dist) op = op0;\n    \n    op0.mat = rotate3D(vec3(0, 0, 1), -PI/2.0);\n    op0.p = op0.mat * (p - vec3(1.0 - 0.5 * PIPE_SIZE, 0.5, 0.5));\n    op0.dist = sdPipe(op0.p);\n    if (op0.dist < op.dist) op = op0;\n\n    op0.mat = rotate3D(vec3(1, 0, 0), -PI/2.0);\n    op0.p = op0.mat * (p - vec3(0.5, 0.5, 0.5 * PIPE_SIZE));\n    op0.dist = sdPipe(op0.p);\n    if (op0.dist < op.dist) op = op0;\n    \n    op0.mat = rotate3D(vec3(1, 0, 0), PI/2.0);\n    op0.p = op0.mat * (p - vec3(0.5, 0.5, 1.0 - 0.5 * PIPE_SIZE));\n    op0.dist = sdPipe(op0.p);\n    if (op0.dist < op.dist) op = op0;\n\n    // ----------------- COIN ----------------- //\n    op0.shape = 1;\n    op0.mat = rotate3D(vec3(0, 0, 1), -PI / 2.0) * rotate3D(vec3(0, 1, 0), -t);\n\n    for (int i = 0; i < LINE_COIN; i++) {\n        float k = float(i) / float(LINE_COIN);\n        vec3 disp = vec3(0.5, fract(t * 0.1 + k), 0.5);\n        disp = fract(S[index] * (disp - 0.5) + 0.5);\n        op0.p = op0.mat * (p - disp);\n        op0.dist = sdCoin(op0.p);\n        if (op0.dist < op.dist) op = op0;\n    }\n    \n    for (int i = 0; i < LINE_COIN; i++) {\n        float k = float(i) / float(LINE_COIN);\n        float theta = (fract(t * 0.1 + k) - 0.05) * PI * 0.55;\n        vec2 disp2d = vec2(cos(theta), sin(theta)) * (0.5 - PIPE_SIZE) + PIPE_SIZE;\n        vec3 disp = vec3(disp2d.y, 0.5, disp2d.x);\n        disp = fract(S[index] * (disp - 0.5) + 0.5);\n        op0.p = op0.mat * (p - disp);\n        op0.dist = sdCoin(op0.p);\n        if (op0.dist < op.dist) op = op0;\n    }\n\n    for (int i = 0; i < LINE_COIN; i++) {\n        float k = float(i) / float(LINE_COIN);\n        float theta = (fract(t * 0.1 + k) - 0.05) * PI * 0.55;\n        vec2 disp2d = vec2(cos(theta), sin(theta)) * (0.5 - PIPE_SIZE) + PIPE_SIZE;\n        disp2d = 1.0 - disp2d;\n        vec3 disp = vec3(disp2d.y, 0.5, disp2d.x);\n        disp = fract(S[index] * (disp - 0.5) + 0.5);\n        op0.p = op0.mat * (p - disp);\n        op0.dist = sdCoin(op0.p);\n        if (op0.dist < op.dist) op = op0;\n    }\n\n    return op;\n} \n\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 theta = vec2(0.15, 0.25) * iTime;\n    theta.y = sin(theta.y) * 0.5;\n    Camera camera = newCamera(\n        vec3(sin(iTime * 0.1) * 0.1, -iTime * 0.1, cos(iTime * 0.1) * 0.1),\n        vec3(cos(theta.x) * cos(theta.y), sin(theta.y), sin(theta.x) * cos(theta.y)),\n        vec3(0, 1, 0),\n        PI / 4.0,\n        iResolution.x / iResolution.y\n    );\n    Ray ray = cameraRay(camera, fragCoord / iResolution.xy);\n\n    vec3 p = ray.origin;\n    float dist = 0.0;\n    MarchingOutput op;\n    for (int _i = 0; _i < 100; _i++) {\n        op = sDist(p, iTime);\n        if (op.dist < 0.00001 || dist >= FAR) break;\n        dist += op.dist;\n        p = ray.origin + dist * ray.direction;\n    }\n\n    const vec3 BLUE0 = vec3(160, 216, 234) / 255.0;\n    const vec3 BLUE1 = vec3(108, 155, 210) / 255.0;\n    float y = (1.0 + ray.direction.y) * 0.5;\n    vec3 col = pow((1.0 - y) * BLUE0 + y * BLUE1, vec3(2.2));\n    if (dist < FAR) {\n        float decay = smoothstep(0.0, 1.0, dist / FAR);\n        decay *= decay;\n        if (op.shape == 0) { // pipe\n            vec3 normal = transpose(op.mat) * normalPipe(op.p);\n            float rad = radPipe(normal, ray.direction);\n            vec3 albedo = albPipe(op.p);\n            col = (1.0 - decay) * rad * albedo + decay * col;\n        } else { // coin\n            vec3 normal = transpose(op.mat) * normalCoin(op.p);\n            float rad = radCoin(normal, ray.direction);\n            col = (1.0 - decay) * rad * COIN_ALBEDO + decay * col;\n        }\n    }\n\n    fragColor = vec4(pow(col, vec3(0.4545)), clamp(dist, 0.0, FAR));\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    \n// smart anti-aliasing\n// reference: https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n\n// If defined, visualize anti-aliased pixels.\n//#define VISUALIZE_AA\n#ifdef AA\n    if (fwidth(length(O.xyz)) > 0.2 && O.w < AA_FAR) {\n\n        O.xyz = pow(O.xyz, vec3(2.2));\n        vec4 o;\n#if (AA == 2)\n        for (int k = 0; k < 4; k++) {\n              mainImage0(o,U + (vec2(k % 2, k / 2) - 0.5) / 1.5);\n              O += pow(o, vec4(2.2));\n        }\n        O /= 5.0;\n#elif (AA == 3)\n        for (int k = 0; k < 9; k += k == 3 ? 2 : 1 ) {\n              mainImage0(o, U + vec2(k % 3 - 1, k / 3 - 1) / 3.0);\n              O += pow(o, vec4(2.2));\n        }\n        O /= 9.0;\n#endif\n#ifdef VISUALIZE_AA\n        O = vec4(1);\n    } else {\n        O = vec4(0,0,0,1);\n#endif\n        O.xyz = pow(O.xyz, vec3(0.4545));\n    }\n#endif\n    O.w = 1.0;\n}", "image_inputs": [], "common_code": "const float PI = 3.141592653;\n\nstruct Camera {\n    vec3 position;\n    vec3 direction;\n    vec3 up_direction; // not require dot(direction, up_direction) == 0\n    float fov;\n    float aspect; // x / y\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nCamera newCamera(vec3 position, vec3 direction, vec3 up_direction, float fov, float aspect) {\n    Camera camera;\n    camera.position = position;\n    camera.direction = direction;\n    camera.up_direction = up_direction;\n    camera.fov = fov;\n    camera.aspect = aspect;\n    return camera;\n}\n\n// perspective camera ray, uv = fragCoord / iResolution.xy\n// cf: https://qiita.com/aa_debdeb/items/301dfc54788f1219b554\nRay cameraRay(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float radian = camera.fov;\n    float h = tan(radian * 0.5);\n    float w = h * camera.aspect;\n    vec3 right = normalize(cross(camera.direction, camera.up_direction));\n    vec3 up = normalize(cross(right, camera.direction));\n    vec3 direction = normalize(right * w * uv.x + up * h * uv.y + camera.direction);\n    Ray ray;\n    ray.origin = camera.position;\n    ray.direction = direction;\n    return ray;\n}\n\nfloat microfacet(vec3 normal, vec3 cameraDir, vec3 lightDir, float metal, float roughness) {\n    vec3 middle = normalize(cameraDir + lightDir);\n    float dotCN = clamp(-dot(cameraDir, normal), 0.0, 1.0);\n    float dotLN = clamp(-dot(lightDir, normal), 0.0, 1.0);\n    float dotNM = -dot(normal, middle);\n    float dotCM = dot(cameraDir, middle);\n    float alpha = roughness * roughness;\n    \n    // diffuse BRDF\n    float diffuse = 1.0 - metal;\n    \n    // microfacet distribution\n    float alpha2 = alpha * alpha;\n    float tmp = 1.0 - dotNM * dotNM * (1.0 - alpha2);\n    float distribution = alpha2 / (tmp * tmp);\n\n    // schlick approxy & geometric decay\n    float alp = alpha * 0.5;\n    float sal = dotLN / (dotLN * (1.0 - alp) + alp);\n    float sac = dotCN / (dotCN * (1.0 - alp) + alp);\n    float decay = sal * sac;\n\n    // fresnel\n    float c = 1.0 - dotCM;\n    c = c * c * c * c * c;\n    float fresnel = metal + (1.0 - metal) * c;\n\n    // specular BRDF\n    tmp = 4.0 * dotCN * dotLN;\n    float specular = distribution * decay / tmp * fresnel;\n    if (tmp < 0.0001) specular = 0.0;\n    \n    return (diffuse + specular) * dotLN;\n}\n\n// Hash without Sine https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftKGzV.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[700, 809, 862, 862, 969], [971, 1022, 1073, 1073, 1451], [1453, 1519, 1544, 1544, 1744], [1746, 1756, 1784, 1784, 1984], [1986, 1996, 2021, 2021, 2138], [2140, 2175, 2219, 2219, 2461], [2463, 2529, 2554, 2554, 2656], [2712, 2730, 2758, 2758, 3791], [3793, 3828, 3872, 3872, 4114], [5400, 5504, 5549, 5549, 8211], [8214, 8214, 8270, 8270, 9832]], "test": "untested"}
{"id": "NlGGRV", "name": "connected components in truchet3", "author": "FabriceNeyret2", "description": "Find the connected component.  \neven more accelerated variant of [url]https://shadertoy.com/view/7ty3zG[/url], by using change detection & stream reduction https://www.shadertoy.com/view/ftyGzK\n\nclick to restart a new truchet tiling.  Scale N in Common.", "tags": ["flood", "short", "connected", "truchets", "streamreduction"], "likes": 6, "viewed": 312, "published": 3, "date": "1638005862", "time_retrieved": "2024-07-30T18:45:40.233015", "image_code": "// more accelerated variant of https://shadertoy.com/view/stKGzG\n// accelerated variant of https://shadertoy.com/view/7ty3zG\n\n#define hue(v)  vec4( .6 + .6 * cos( .5+(v)  + vec3(0,23,21)  ) , 1 )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n // O = T(u).agbr; return;\n    vec2 U = N * u / R.y + 0.*iTime, I = floor(U), F = fract(U);\n         \n    O = T(I);                                          // cell states \n    O.w > 0. ? F = vec2(1.-F.y,F.x) : F;\n    \n    O =   smoothstep(N*1.5/R.y,0.,abs(min(length(F),length(1.-F))-.5) ) // truchet drawing\n        * hue( O[ F.x+F.y < 1. ? 1 : 2 ] );            // coloring\n         \n // if (iMouse.z>0.) O += (1.-O.w)*.3*mod(I.x+I.y,2.); // debug: draw tiles\n // O += .3*T(I).w;\n} ", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define H(p)  fract(sin(dot(p, vec2(12.9898, 78.233))-iTime) * 43758.5453)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U -= .5;\n    if ( iFrame < 1 || iMouse.z>0.) {         // --- init: create truchet\n        vec2 I = U;                           // store truchet data\n        O.w = step(.5,H(I));                  // random axis\n        O.y = 1.+I.x+4096.*I.y;               // id of tile segment #1\n        O.z = -O.y;                           // id of tile segment #2\n        return;\n    }\n    \n    O = T(U);                                 // previous state\n    float Nx = floor(N*R.x/R.y);\n    vec4 T;\n    if (U.x <= Nx && U.y >= N+4. && U.y <= N+N+4.) // keep previous version\n      { U.y -= N+4.; O = T(U); return; }\n      \n    if (U.x >= Nx+4. && U.x <= Nx+4.+Nx/8. && U.y <= N/8.) { // reduction map of change\n        O-=O;\n        U.x -= Nx+4.;\n        for (int k=0; k < 64; k++ ) {\n            vec2 V = 8.*U + vec2(k%8,k/8),\n                 o = T(V + vec2(0.,N+4.)).yz, // old vs new value\n                 n = T(V).yz;\n         // if ( o != n ) O = vec4(o,n);      // if changed, store ( why break worse ? )\n         // if ( o != n ) { O = vec4(o,n); break; } // why worse ? \n            if ( o.x != n.x ) O.xz = vec2(o.x,n.x); // if changed, store \n            if ( o.y != n.y ) O.yw = vec2(o.y,n.y);\n            if (O.x*O.y!=0.) break;\n        }\n        return;\n    }\n    if (U.x > Nx || U.y > N) return;          // propagate only visible tiles\n\n                                              // --- propagate id along connections\n#define left       T(U+vec2(1,0)).y\n#define right      T(U-vec2(1,0)).z\n#define bot      ( T = T(U+vec2(0,1)), T.w<1. ? T.y : T.z )\n#define top      ( T = T(U-vec2(0,1)), T.w<1. ? T.z : T.y )\n//#define min(a,b) ( abs(a) < abs(b) ? a : b ) // may this boost ?\n    if (O.w<1.) { // tile contains:  \\     new id = min(connections)\n        O.y = min( O.y, min( right, top ));\n        O.z = min( O.z, min( left , bot ));\n    }\n    else {        // tile contains:  /     new id = min(connections)\n        O.y = min( O.y, min( right, bot ));\n        O.z = min( O.z, min( left , top ));\n    }\n\n                  // --- shortcut2: at color change, update the color source pixel\n    for( float j = 0.; j < N/8.; j++)\n        for( float i = 0.; i < Nx/8.; i++) {\n            T = T( vec2(Nx+4.+i,j) );\n            vec2 o = T.xy, n = T.zw;          // changed old->new value\n            if (O.y==o.x) O.y = n.x;          // oldvalue was my seg1 : update\n            if (O.y==o.y) O.y = n.y;\n            if (O.z==o.x) O.z = n.x;          // oldvalue was my seg2 : update\n            if (O.z==o.y) O.z = n.y;\n        }\n} ", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float N = 64.; // vertical number of tiles\n\n#define R    iResolution.xy\n#define T(U) texelFetch( iChannel0, ivec2(U+R)%ivec2(R), 0 )", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlGGRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[197, 197, 235, 262, 720]], "test": "untested"}
{"id": "NlKGRK", "name": "aliasing bad", "author": "pema99", "description": "bad", "tags": ["badaliasing"], "likes": 1, "viewed": 109, "published": 3, "date": "1638004520", "time_retrieved": "2024-07-30T18:45:41.003953", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv *= 2.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 col = vec3(0.);\n    if (uv.x < sin(iTime)-0.005)\n        col = vec3(smoothstep(0.49, 0.5, length(uv)));\n    else if (uv.x > sin(iTime)+0.005)\n        col = vec3(length(uv) >= 0.5);\n    else\n        col = vec3(1., 0., 0.);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlKGRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 433]], "test": "untested"}
{"id": "NtKGRK", "name": "- fire ball -", "author": "anahit_movsesyan", "description": ":octopus:", "tags": ["noise", "fbm", "flame", "fire"], "likes": 17, "viewed": 627, "published": 3, "date": "1638004288", "time_retrieved": "2024-07-30T18:45:41.768908", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI 3.141592\n#define OFF 0.03\n\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat rand(vec2 p) {\n    return fract(sin(dot(p, vec2(12.99, 78.233))) * 43758.545);\n}\n\nfloat shift(float r) {\n    return sin(r * 2. * PI + iTime * 7.) * 0.5 + 0.5;\n}\n\nfloat noise(vec2 p) {\n    vec2 f = fract(p);\n    vec2 i = floor(p);\n    return mix(mix(shift(rand(i + vec2(0, 0))), \n                   shift(rand(i + vec2(1, 0))), f.x),\n               mix(shift(rand(i + vec2(0, 1))), \n                   shift(rand(i + vec2(1, 1))), f.x), f.y);\n}\n\nfloat fbm(vec2 p) {\n    float v = 0.;\n    float a = 1.;\n    for (int i = 0; i < 4; ++i) {\n        vec2 p1 = p * 4. / a;\n        a *= 0.5;\n        v += a * noise(p1);\n    }\n    return v;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 p = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    \n\tvec2 r = vec2(fbm(p + vec2(0,  OFF)) - fbm(p + vec2( 0, -OFF)), \n                 -fbm(p + vec2(OFF,  0)) + fbm(p + vec2(-OFF,  0))) * 0.01;\t\n    r += vec2(0.002, 0.0045);\n\n    vec2 uv = fragCoord / iResolution.xy;\n\tfloat dCircle = sdCircle(p, 0.1); \n\tvec3 col = pow(texture(iChannel0, uv - r).rgb, vec3(1.15))\n             + vec3(smoothstep(0.01, -0.01, abs(dCircle) - 0.007)) * vec3(1., 0.6, 0.25);\n\tcol = clamp(col, 0., 1.);\n    fragColor = vec4(col, 1.);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtKGRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 118]], "test": "untested"}
{"id": "7lGGRV", "name": "eindacor_gears", "author": "Eindacor_DS", "description": "they're gears, you dolt!", "tags": ["gears"], "likes": 4, "viewed": 508, "published": 3, "date": "1637982326", "time_retrieved": "2024-07-30T18:45:42.727346", "image_code": "#define AA .002\n#define PI 3.1415926\n#define MIN_GEAR_RADIUS .1\n#define MIN_GEAR_DIVISION 16.\n#define TOOTH_LENGTH .01\n#define GEAR_ROTATION_SPEED .5\n#define SHADOW_MODIFIER .8\n\n#define CYAN vec3(0., 1., 1.)\n#define MAGENTA vec3(1., 0., 1.)\n#define YELLOW vec3(1., 1., 0.)\n#define RED vec3(1., 0., 0.)\n#define GREEN vec3(0., 1., 0.)\n#define BLUE vec3(0., 0., 1.)\n#define ORANGE vec3(1., .75, .25)\n#define PINK vec3(1., .25, .75)\n#define WHITE vec3(1.)\n#define BLACK vec3(0.)\n\n#define PEG_COLOR vec3(1.)\n#define BACKGROUND_COLOR vec4(.05)\n\n#define DRAW_SHADOWS false\n\n/*\n    TODO:\n        - reduce draw passes by incorporated shadow pass into gear/peg process\n*/\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nmat2x2 createRotationMatrix(float rotation) {\n    return mat2x2(\n        cos(rotation), -sin(rotation),\n        sin(rotation), cos(rotation)\n    );\n}\n\nfloat getGearRadius(float gearIndex) {\n    float randValue = hash(vec2(gearIndex, gearIndex));\n    if (randValue < .333) {\n        return MIN_GEAR_RADIUS;\n    } else if (randValue < .666) {\n        return MIN_GEAR_RADIUS * 2.;\n    } else {\n        return MIN_GEAR_RADIUS * 4.;\n    }\n}\n\nvec4 getGearLocations(float gearLinkValue, float firstIndex, float secondIndex) {\n    vec2 first = vec2(0.);\n    \n    float radialOffsetIncrement = PI / MIN_GEAR_DIVISION * 2.;\n    float maxOffset = PI / 4.;\n    float maxIncrements = 4.;\n    float radialOffset = radialOffsetIncrement * floor(maxIncrements * hash(vec2(gearLinkValue * gearLinkValue, gearLinkValue * 2.)));\n    float rotationVariance = PI / 2.;\n    float rotation = mix(rotationVariance / -2., rotationVariance / 2., hash(vec2(gearLinkValue * gearLinkValue, gearLinkValue * 2.)));\n  \n    mat2x2 rotationMatrix = createRotationMatrix(radialOffset);\n    \n    float dist = getGearRadius(firstIndex) + getGearRadius(secondIndex);\n    \n    vec2 second = (vec2(dist, 0.) * rotationMatrix) + first;\n    \n    return vec4(first.x, first.y, second.x, second.y);\n}\n\nvec3 getRandomColor(float seed) {\n    seed = clamp(seed, 0., 1.);\n    float colorCount = 6.;\n    float colorIncrement = 1.f / colorCount;\n    float seedFloor = floor(seed / colorIncrement) * colorIncrement;\n    float lerpVal = smoothstep(seedFloor, seedFloor + colorIncrement, seed);\n\n    if (seed <= colorIncrement * 1.) {\n        return mix(RED, YELLOW, lerpVal);\n    } else if (seed <= colorIncrement * 2.) {\n        return mix(YELLOW, GREEN, lerpVal);\n    } else if (seed <= colorIncrement * 3.) {\n        return mix(GREEN, CYAN, lerpVal);\n    } else if (seed <= colorIncrement * 4.) {\n        return mix(CYAN, BLUE, lerpVal);\n    } else if (seed <= colorIncrement * 5.) {\n        return mix(BLUE, MAGENTA, lerpVal);\n    } else {\n        return mix(MAGENTA, vec3(1.), lerpVal);\n    }\n}\n\nfloat getPegSmoothStep(vec2 uv, vec2 gearLocation, float gearIndex) {\n    float dist = distance(uv, gearLocation);\n    float holeRadius = .03;\n    \n    if (dist < holeRadius) {\n        return smoothstep(holeRadius - AA, holeRadius - AA * 2., dist);\n    }\n}\n\nbool getHasSpokes(float gearIndex) {\n    return hash(vec2(gearIndex * .23, gearIndex + 89.)) < .75;\n}\n\nvec2 rotateAroundPoint (vec2 anchor, vec2 p, float rads) {\n    mat2x2 rotationMatrix = createRotationMatrix(rads);\n    return (p - anchor) * rotationMatrix + anchor;\n}\n\nint getSpokeCount(float gearIndex) {\n    return int(mix(3., 8., hash(vec2(gearIndex * -.118, gearIndex + 2.))));\n}\n\nfloat getGearSmoothStep(vec2 uv, vec2 gearLocation, float gearIndex, mat2x2 rotationMatrix) {\n    float dist = distance(uv, gearLocation);\n\n    float gearRadius = getGearRadius(gearIndex);\n\n    float gearProportion = gearRadius / MIN_GEAR_RADIUS;\n    float gearDivisions = gearProportion * MIN_GEAR_DIVISION * 2.;\n    \n    uv = ((uv - gearLocation) * rotationMatrix) + gearLocation;\n    \n    float rads = atan(uv.y - gearLocation.y, uv.x - gearLocation.x);\n    \n    float minVal = gearRadius - TOOTH_LENGTH;\n    float maxVal = gearRadius + TOOTH_LENGTH;\n\n    float val = 0.;\n    int spokeCount = getSpokeCount(gearIndex);\n    float innerRadiusDimension = minVal * .4 * hash(vec2(gearIndex, gearIndex));\n    float outerRadiusDimension = minVal * mix(.7, .85, hash(vec2(-gearIndex, -gearIndex)));\n    float spokeWidth = minVal * mix(.02, .1, hash(vec2(gearIndex, -gearIndex)));\n    if (getHasSpokes(gearIndex)) {\n        bool renderRadius = false;\n        for (int i=0; i<spokeCount && !renderRadius; ++i) {\n            vec2 rotatedUv = rotateAroundPoint(gearLocation, uv, float(i) * 2. * PI / float(spokeCount));\n            if (rotatedUv.x < gearLocation.x && abs(rotatedUv.y - gearLocation.y) < spokeWidth) {\n                renderRadius = true;\n            }\n        }\n        \n        if (!renderRadius) {\n            if (dist < innerRadiusDimension) {\n                return smoothstep(innerRadiusDimension, innerRadiusDimension - 2. * AA, dist);\n            }\n            \n            if (dist > outerRadiusDimension && dist <= minVal) {\n                return smoothstep(outerRadiusDimension, outerRadiusDimension + 2. * AA, dist);\n            }\n            \n            if (dist < minVal) {\n                float spokeVal = 0.;\n                for (int i=0; i<spokeCount && !renderRadius; ++i) {\n                    vec2 rotatedUv = rotateAroundPoint(gearLocation, uv, float(i) * 2. * PI / float(spokeCount));\n                    if (rotatedUv.x < gearLocation.x) {\n                        spokeVal = mix(spokeVal, 1., smoothstep(spokeWidth + AA, spokeWidth, abs(rotatedUv.y - gearLocation.y)));\n                    }\n                }\n            \n                return spokeVal;\n            }\n        }\n    }\n    \n    float radIncrements = 2. * PI / gearDivisions;\n    \n    float radIndex = floor(rads / radIncrements);\n    float toothPos = fract(rads / radIncrements);\n\n    // max tooth width is .5\n    float toothWidth = .4;\n    \n    if (mod(radIndex, 2.) == 0.) {\n        float toothVal = smoothstep(toothWidth / 2., 1. - toothWidth / 2., toothPos);\n        gearRadius = mix(minVal, maxVal, toothVal);\n    } else {\n        float toothVal = smoothstep(toothWidth / 2., 1. - toothWidth / 2., toothPos);\n        gearRadius = mix(maxVal, minVal, toothVal);\n    }\n   \n    return mix(val, 1., smoothstep(gearRadius + AA, gearRadius - AA, dist));\n}\n\nvec3 getNextGearLocationAndIndex(float previousIndex, vec2 previousGearLocation) {\n    float gearIndex = previousIndex + 1.;\n    float gearLinkValue = hash(vec2(previousIndex, gearIndex));\n    vec4 gearLocations = getGearLocations(gearLinkValue, previousIndex, gearIndex);\n    vec2 gearLocation = previousGearLocation + (gearLocations.zw - gearLocations.xy);\n    \n    return vec3(gearLocation.x, gearLocation.y, gearIndex);\n}\n\nfloat circleSmoothStepFill(vec2 center, float radius, vec2 p, float antiAlias) {\n\treturn 1.f - smoothstep(radius - antiAlias, radius + antiAlias, distance(center, p));\n}\n\nfloat lineSegmentSmoothStep(vec2 start, vec2 end, vec2 p, float lineThickness, float antiAlias, bool roundEnds) {\n    float halfThickness = lineThickness / 2.f;\n    if (dot(p-end, start - end) < 0.f || dot(p - start, end - start) < 0.f) {\n        return !roundEnds ? 0.f : max(\n\t\t\tcircleSmoothStepFill(start, halfThickness, p, antiAlias),\n\t\t\tcircleSmoothStepFill(end, halfThickness, p, antiAlias)\n        );  \n    }\n    \n    vec2 lineVec = normalize(end - start);\n    vec2 pVec = normalize(p - start);\n\n    float angle = acos(dot(lineVec, pVec) / length(lineVec) * length(pVec));\n    float distFromLine = sin(angle) * distance(start, p);\n    \n    return 1.f - smoothstep(lineThickness / 2.f - antiAlias, halfThickness + antiAlias, distFromLine);\n}\n\nvec4 getPreceedingGearsColor(\n    vec4 inColor,\n    float referenceFirstIndex, \n    float referenceSecondIndex,\n    vec4 referenceLocations,\n    int gearsToRender,\n    vec2 uv,\n    float rotationSpeed,\n    bool isShadow) {\n    \n    vec4 outColor = inColor;\n    \n    for (int i=0; i<gearsToRender; i++) {\n        float targetIndex = referenceFirstIndex - 1.;\n        float linkValue = hash(vec2(targetIndex, referenceFirstIndex));\n        \n        bool isEven = floor(mod(targetIndex, 2.)) <= 0.1;\n        \n        float gearRadius = getGearRadius(targetIndex);\n        float gearProportion = gearRadius / MIN_GEAR_RADIUS;\n        float gearDivisions = gearProportion * MIN_GEAR_DIVISION * 2.;\n        \n        float startingAngle = isEven ? PI / gearDivisions : PI / gearDivisions;\n        \n        float gearSizeSpeedAmplification = MIN_GEAR_RADIUS / gearRadius;\n        \n        float rotation = rotationSpeed * gearSizeSpeedAmplification;\n        if (isEven) {\n            rotation *= -1.;\n        }\n        \n        mat2x2 rotationMatrix = createRotationMatrix(startingAngle + rotation);\n        \n        vec3 gearColor = isShadow ? (outColor * SHADOW_MODIFIER).rgb : getRandomColor(linkValue);\n        \n        vec4 targetReferenceFirstLocations = getGearLocations(linkValue, targetIndex, referenceFirstIndex);\n        vec2 targetLocation = targetReferenceFirstLocations.xy - targetReferenceFirstLocations.zw + referenceLocations.xy;\n        \n        outColor = mix(outColor, vec4(gearColor, 1.), getGearSmoothStep(uv, targetLocation, targetIndex, rotationMatrix)); \n        \n        referenceFirstIndex = targetIndex;\n        referenceSecondIndex = targetIndex - 1.;\n        referenceLocations = vec4(targetLocation.x, targetLocation.y, referenceLocations.x, referenceLocations.y);\n    }\n    \n    return outColor;\n}\n\nvec4 getPreceedingPegsColor(\n    vec4 inColor,\n    float referenceFirstIndex, \n    float referenceSecondIndex,\n    vec4 referenceLocations,\n    int gearsToRender,\n    vec2 uv,\n    bool isShadow) {\n    \n    vec4 outColor = inColor;\n    \n    vec3 pegColor = isShadow ? (outColor * SHADOW_MODIFIER).rgb : PEG_COLOR;\n    \n    for (int i=0; i<gearsToRender; i++) {\n        float targetIndex = referenceFirstIndex - 1.;\n        float linkValue = hash(vec2(targetIndex, referenceFirstIndex));\n        \n        vec4 targetReferenceFirstLocations = getGearLocations(linkValue, targetIndex, referenceFirstIndex);\n        vec2 targetLocation = targetReferenceFirstLocations.xy - targetReferenceFirstLocations.zw + referenceLocations.xy;\n        \n        outColor = mix(outColor, vec4(pegColor, 1.), getPegSmoothStep(uv, targetLocation, targetIndex)); \n        \n        referenceFirstIndex = targetIndex;\n        referenceSecondIndex = targetIndex - 1.;\n        referenceLocations = vec4(targetLocation.x, targetLocation.y, referenceLocations.x, referenceLocations.y);\n    }\n    \n    return outColor;\n}\n\nvec4 getSucceedingGearsColor(\n    vec4 inColor,\n    float referenceFirstIndex, \n    float referenceSecondIndex,\n    vec4 referenceLocations,\n    int gearsToRender,\n    vec2 uv,\n    float rotationSpeed,\n    bool isShadow) {\n    \n    vec4 outColor = inColor;\n    \n    for (int i=0; i<gearsToRender; i++) {\n        float linkValue = hash(vec2(referenceFirstIndex, referenceSecondIndex));\n        \n        bool isEven = floor(mod(referenceFirstIndex, 2.)) <= 0.1;\n        \n        float gearRadius = getGearRadius(referenceFirstIndex);\n        float gearProportion = gearRadius / MIN_GEAR_RADIUS;\n        float gearDivisions = gearProportion * MIN_GEAR_DIVISION * 2.;\n        \n        float startingAngle = isEven ? PI / gearDivisions : PI / gearDivisions;\n        \n        float gearSizeSpeedAmplification = MIN_GEAR_RADIUS / gearRadius;\n        \n        float rotation = rotationSpeed * gearSizeSpeedAmplification;\n        if (isEven) {\n            rotation *= -1.;\n        }\n\n        mat2x2 rotationMatrix = createRotationMatrix(startingAngle + rotation);\n        \n        vec3 gearColor = isShadow ? (outColor * SHADOW_MODIFIER).rgb : getRandomColor(linkValue);\n        \n        outColor = mix(outColor, vec4(gearColor, 1.), getGearSmoothStep(uv, referenceLocations.xy, referenceFirstIndex, rotationMatrix)); \n        \n        vec3 nextLocationAndIndex = getNextGearLocationAndIndex(referenceSecondIndex, referenceLocations.zw);\n        \n        referenceFirstIndex = referenceSecondIndex;\n        referenceSecondIndex = referenceSecondIndex + 1.;\n        referenceLocations = vec4(referenceLocations.z, referenceLocations.w, nextLocationAndIndex.x, nextLocationAndIndex.y);\n    }\n    \n    return outColor;\n}\n\nvec4 getSucceedingPegsColor(\n    vec4 inColor,\n    float referenceFirstIndex, \n    float referenceSecondIndex,\n    vec4 referenceLocations,\n    int gearsToRender,\n    vec2 uv,\n    bool isShadow) {\n    \n    vec4 outColor = inColor;\n    \n    vec3 pegColor = isShadow ? (outColor * SHADOW_MODIFIER).rgb : PEG_COLOR;\n    \n    for (int i=0; i<gearsToRender; i++) {  \n        outColor = mix(outColor, vec4(pegColor, 1.), getPegSmoothStep(uv, referenceLocations.xy, referenceFirstIndex)); \n        \n        vec3 nextLocationAndIndex = getNextGearLocationAndIndex(referenceSecondIndex, referenceLocations.zw);\n        \n        referenceFirstIndex = referenceSecondIndex;\n        referenceSecondIndex = referenceSecondIndex + 1.;\n        referenceLocations = vec4(referenceLocations.z, referenceLocations.w, nextLocationAndIndex.x, nextLocationAndIndex.y);\n    }\n    \n    return outColor;\n}\n\nfloat sinestep(float edge1, float edge2, float val) {\n    float lower = edge1 < edge2 ? edge1 : edge2;\n    float upper = edge1 < edge2 ? edge2 : edge1;\n\n    if (val < lower) {\n        return 0.;\n    } else if (val > upper) {\n        return 1.;\n    }\n    \n    return -1. * cos(1. / (upper - lower));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float aspectRatio = iResolution.x / iResolution.y;\n    \n    uv.x *= aspectRatio;\n    \n    float travelTime = 2.;\n    \n    float dotRadius = .1;\n    \n    float timelerp = fract(iTime / travelTime);\n    \n    int gearsToRender = 16;\n    \n    float originFirstIndex = floor(iTime / travelTime);\n    float originSecondIndex = originFirstIndex + 1.;\n    float linkValue = hash(vec2(originFirstIndex, originSecondIndex));\n    vec4 originLocations = getGearLocations(linkValue, originFirstIndex, originSecondIndex);\n    vec2 firstLocation = originLocations.xy;\n    vec2 secondLocation = originLocations.zw;\n    \n    float previousIndex = originFirstIndex - 1.;\n    float prevLinkValue = hash(vec2(previousIndex, originFirstIndex));\n    vec4 prevFirstLocations = getGearLocations(prevLinkValue, previousIndex, originFirstIndex);\n    vec2 previousLocation = prevFirstLocations.xy - prevFirstLocations.zw + firstLocation;\n    \n    vec2 prevFirstMid = mix(previousLocation, firstLocation, .5);\n    vec2 firstSecondMid = mix(firstLocation, secondLocation, .5);\n    \n    vec2 lerpA = mix(prevFirstMid, firstLocation, timelerp);\n    vec2 lerpB = mix(firstLocation, firstSecondMid, timelerp);\n    vec2 lerpC = mix(lerpA, lerpB, timelerp);\n \n    // modify uv's by bezier curves between midpoints for smooth transitions\n    uv += lerpC - vec2(.5 * aspectRatio, .5);\n    \n    float rotation = 15. * sin(iTime / 5.);\n\n    fragColor = BACKGROUND_COLOR;\n    \n    float shadowDepth = .02;\n    vec2 shadowUv = uv + vec2(shadowDepth);\n    \n    if (DRAW_SHADOWS) {\n        fragColor = getSucceedingGearsColor(\n            fragColor,\n            originFirstIndex, \n            originSecondIndex,\n            originLocations,\n            gearsToRender / 2,\n            shadowUv, \n            rotation,\n            true);\n\n        fragColor = getPreceedingGearsColor(\n            fragColor,\n            originFirstIndex, \n            originSecondIndex,\n            originLocations,\n            gearsToRender / 2,\n            shadowUv,\n            rotation,\n            true);\n    }\n    \n    fragColor = getPreceedingGearsColor(\n        fragColor,\n        originFirstIndex, \n        originSecondIndex,\n        originLocations,\n        gearsToRender / 2,\n        uv,\n        rotation,\n        false);\n        \n    fragColor = getSucceedingGearsColor(\n        fragColor,\n        originFirstIndex, \n        originSecondIndex,\n        originLocations,\n        gearsToRender / 2,\n        uv, \n        rotation,\n        false);\n        \n    if (DRAW_SHADOWS) {\n        fragColor = getSucceedingPegsColor(\n            fragColor,\n            originFirstIndex, \n            originSecondIndex,\n            originLocations,\n            gearsToRender / 2,\n            mix(uv, shadowUv, .35),\n            true);\n\n        fragColor = getPreceedingPegsColor(\n            fragColor,\n            originFirstIndex, \n            originSecondIndex,\n            originLocations,\n            gearsToRender / 2,\n            mix(uv, shadowUv, .35),\n            true);\n    }\n        \n    fragColor = getSucceedingPegsColor(\n        fragColor,\n        originFirstIndex, \n        originSecondIndex,\n        originLocations,\n        gearsToRender / 2,\n        uv,\n        false);\n        \n    fragColor = getPreceedingPegsColor(\n        fragColor,\n        originFirstIndex, \n        originSecondIndex,\n        originLocations,\n        gearsToRender / 2,\n        uv,\n        false);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lGGRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[663, 709, 729, 729, 795], [797, 797, 842, 842, 946], [948, 948, 986, 986, 1232], [1234, 1234, 1315, 1315, 2053], [2055, 2055, 2088, 2088, 2844], [2846, 2846, 2915, 2915, 3102], [3104, 3104, 3140, 3140, 3205], [3207, 3207, 3265, 3265, 3374], [3376, 3376, 3412, 3412, 3490], [3492, 3492, 3585, 3585, 6346], [6348, 6348, 6430, 6430, 6773], [6775, 6775, 6855, 6855, 6944], [6946, 6946, 7059, 7059, 7693], [7695, 7695, 7917, 7917, 9516], [9518, 9518, 9714, 9714, 10608], [10610, 10610, 10832, 10832, 12318], [12320, 12320, 12516, 12516, 13201], [13203, 13203, 13256, 13256, 13503], [13505, 13505, 13562, 13562, 17038]], "test": "untested"}
{"id": "7ty3RK", "name": "Distributing errors as blue nois", "author": "Tara", "description": "Based on: blueNoiseTemporal2019_slides.pdf\nReorders white noise to produce blue noise.\nThis can be used to modify the per-pixel seed of a ray tracer, to produce blue noise instead of white noise artifacts.", "tags": ["as", "errors", "bluenoise", "distributing"], "likes": 2, "viewed": 122, "published": 3, "date": "1637973854", "time_retrieved": "2024-07-30T18:45:43.495292", "image_code": "const int block_size = 4;\nconst int pixels_in_block = block_size * block_size;\n\nfloat luma(vec3 color)\n{\n    return(color.r * 0.2126 + color.g * 0.7152 + color.b * 0.0722);\n    return((color.r + color.g + color.b) / 3.0);\n}\n\nvoid sort_array(inout float array[pixels_in_block])\n{\n    for(int k=0; k<pixels_in_block; ++k)\n    {\n        for(int j=0; j<pixels_in_block-1; ++j)\n        {    \n            if(array[j] > array[j + 1])\n            {\n                float temp = array[j];\n                array[j] = array[j + 1];\n                array[j + 1] = temp;\n            }\n        }\n    }\n}\n\nvoid sort_array(inout vec3 array[pixels_in_block])\n{\n    for(int k=0; k<pixels_in_block; ++k)\n    {\n        for(int j=0; j<pixels_in_block-1; ++j)\n        {    \n            if(luma(array[j]) > luma(array[j + 1]))\n            {\n                vec3 temp = array[j];\n                array[j] = array[j + 1];\n                array[j + 1] = temp;\n            }\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Each pixel figures out which block it's in, and then \n    // orts its own block and picks the correct value for itself.\n    // This could be massively sped up using a compute shader.\n\n    ivec2 block_resolution = ivec2(iResolution.xy) / block_size;\n    ivec2 block_id = ivec2(fragCoord.xy) / block_size;\n    \n    int block_index = block_id.y * block_resolution.x + block_id.x;\n    ivec2 block_min = ivec2(block_index % block_resolution.x, block_index / block_resolution.x);\n    ivec2 block_max = block_min + block_size;\n\n    vec3 sorted_values[pixels_in_block];\n    float sorted_blue_noise_values[pixels_in_block];\n    \n    int value_index = 0;\n    \n    for(int y=block_min.y; y<block_max.y; ++y)\n    for(int x=block_min.x; x<block_max.x; ++x)\n    {\n        ivec2 pos = ivec2(x, y);\n        \n        //vec2 coord = (vec2(pos) + 0.5) / vec2(block_resolution);\n        \n        //vec3 val = texture(iChannel0, coord).rgb;\n        vec3 col = texture(iChannel0, (vec2(pos) + 0.5) / iResolution.xy).rgb;\n        float noise = texture(iChannel1, (vec2(pos) + 0.5) / iChannelResolution[1].xy).r;\n        \n        sorted_values[value_index] = col;\n        sorted_blue_noise_values[value_index] = noise;\n        ++value_index;\n    }\n    \n    // Sort colors:\n    sort_array(sorted_values);\n    \n    // Sort blue noise:\n    //sort_array(sorted_blue_noise_values);\n    \n    \n    //fragColor.rgb = sorted_values[15];\n    fragColor.rgb = sorted_values[pixels_in_block - 1];\n    fragColor.rgb = vec3(sorted_blue_noise_values[pixels_in_block - 1]);\n    \n    // Correlate samples:\n    float noise = texture(iChannel1, fragCoord.xy / iChannelResolution[1].xy).r;\n    fragColor.rgb = vec3(noise);\n    \n    \n    int remapped_index = int((float(pixels_in_block - 1) + 0.5) * noise);\n    fragColor.rgb = sorted_values[remapped_index];\n\n#ifdef SHOW_BLOCKS\n    fragColor *= vec4(fract(float(block_index) / 13.0));\n#endif\n\n\n    //fragColor = texture(iChannel1, fragCoord / iResolution.xy).rrrr;\n    //fragColor = texture(iChannel0, fragCoord / iChannelResolution[0].xy).rrrr;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = fragCoord / iChannelResolution[0].xy;\n\n    fragColor = texture(iChannel0, uv);\n    fragColor = texture(iChannel0, uv).rrrr;\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ty3RK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 80, 104, 104, 223], [225, 225, 278, 278, 589], [591, 591, 643, 643, 965]], "test": "untested"}
{"id": "stGGzK", "name": "TexturedLine", "author": "Del", "description": "A simple line function that also returns UV", "tags": ["line", "texture", "uv", "rect"], "likes": 4, "viewed": 228, "published": 3, "date": "1637971635", "time_retrieved": "2024-07-30T18:45:44.262242", "image_code": "// simple textured line test\n\n// returns distance, u, v\nvec3 TexturedLine( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n    q = mat2(d.x,-d.y,d.y,d.x)*q;\n    vec2 qq = (q)-vec2(l,th)*0.5;\n    q = abs(q)-vec2(l,th)*0.5;\n    float dd =  length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n    float u = abs(qq.x)/l;\n    float v = abs(qq.y)/th;\n    return vec3(dd,u,v);\n}\n \nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n    float size = 0.3+(sin(iTime)*0.25);\n\n    vec2 p1 = vec2(0.0,size)*rotate(iTime);\n    vec2 p2 = vec2(size,0.0)*rotate(iTime);\n    \n    vec3 res = TexturedLine(uv,p1,p2,0.1);\n    \n    \n    float d = step(res.x,0.0);\n    if (iMouse.z>0.5)\n        col = d*texture(iChannel0, -res.yz ).xyz;    \n    else\n        col = d*vec3(res.y,res.z,0.0);\n        \n    fragColor = vec4(col,1.0);\n\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stGGzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 56, 120, 120, 440], [443, 443, 465, 465, 532], [538, 538, 595, 595, 1073]], "test": "untested"}
{"id": "stV3zy", "name": "Marmalade", "author": "ruojake", "description": "A Finnish marmalade candy, popular around Christmas. Ref. https://en.wikipedia.org/wiki/Marmalade#/media/File:Green_balls.jpg", "tags": ["3d", "raytracing", "translucency"], "likes": 6, "viewed": 781, "published": 3, "date": "1637967571", "time_retrieved": "2024-07-30T18:45:45.040162", "image_code": "// Marmalade by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\nfloat sqrMag(vec2 v)\n{\n    return dot(v, v);\n}\n\nfloat lum(vec3 c)\n{\n    return dot(c, vec3(.2126, .7152, .0722));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    vec3 blr = texelFetch(iChannel1, ivec2(fragCoord), 0).rgb;\n    blr = smoothstep(vec3(.2), vec3(.8), blr);\n    \n    col += blr;\n    \n    // reinhard tonemapping\n    float lumC = lum(col);\n    col *= (1. + lumC / 3.) / (1. + lumC);\n    \n    // gamma correction\n    col = pow(col, vec3(1./2.2));\n    \n    // vignette\n    col *= 1. - smoothstep(0., 2., sqrMag(fragCoord / iResolution.xy * 2. - 1.)) * .4;\n    \n    fragColor = vec4(col, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define sat(x) clamp((x), 0., 1.)\n\nvec3 hash33(vec3 p)\n{\n    vec3 q = p;\n    q += vec3(31.1343, 17.1643, 11.5281);\n    q *= dot(p, vec3(3.178, 1.513, 3.312));\n    return fract((q.yyx - q.zxy) * .06753 - (q.yzy + q.zxx) * .0143);\n}\n\nvec3 noise(vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = smoothstep(0., 1., p - i);\n    const vec2 o = vec2(1, 0);\n    \n    return mix(\n        mix(\n            mix(hash33(i), hash33(i + o.xyy), f.x),\n            mix(hash33(i + o.yxy), hash33(i + o.xxy), f.x),\n            f.y),\n        mix(\n            mix(hash33(i + o.yyx), hash33(i + o.xyx), f.x),\n            mix(hash33(i + o.yxx), hash33(i + 1.), f.x),\n            f.y),\n        f.z\n    );\n}\n\nvec3 fbm(vec3 p)\n{\n    vec3 res = vec3(0);\n    float amp = 1.; \n    for(int i = 0; i < 3; ++i)\n    {\n        res += noise(p) * amp - .5 * amp;\n        p *= 2.;\n        amp *= .5;\n    }\n    res *= .5 / pow(.5, 3.);\n    return res;\n}\n\nmat2 rot(float a)\n{\n    float s = sin(a),\n          c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sqrMag(vec3 v)\n{\n    return dot(v, v);\n}\n\nvec4 sphereIntersect(vec3 ro, vec3 rd, vec3 p, float r)\n{\n    float t = dot(rd, p - ro);\n    r = r * r - sqrMag(p - (ro + rd * t));\n    \n    float toRad = sqrt(r);\n    \n    t -= max(toRad,-toRad);\n    \n    return vec4(ro + rd * t, r < 0. ? 0. : 1.);\n}\n\nvec3 sphereInverse(vec3 ro, vec3 rd, vec3 p, float r)\n{\n    float t = dot(rd, p - ro);\n    r = r * r - sqrMag(p - (ro + rd * t));\n    \n    float toRad = sqrt(r);\n    \n    t += max(toRad,-toRad);\n    \n    return ro + rd * t;\n}\n\nvec3 sphNormal(vec3 p, vec3 sp)\n{\n    return normalize(p - sp);\n}\n\nfloat shadow(vec3 p, vec3 sp, float r, vec3 lDir)\n{\n    vec3 y = -lDir;\n    vec3 z = vec3(0, -1, 0);\n    vec3 x = cross(y, z);\n    z = cross(x, y);\n    mat3 m = (mat3(x, y, z));\n    sp *= m;\n    p *= m;\n    \n    return sat(length(sp.xz - p.xz) - r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    \n    vec3 ro = vec3(0,1. + sin(iTime * .3) * .5,-3);\n    mat2 rotation = rot(iTime * .13);\n    ro.xz *= rotation;\n    vec3 rd = normalize(vec3(uv, 1));\n    rd.yz *= rot(sin(iTime * .3) * .1);\n    rd.xz *= rotation;\n\n    vec3 sp = vec3(0, 1, 0);\n    float r = 1.;\n    \n    vec3 p = vec3(0);\n    vec4 intersect = sphereIntersect(ro, rd, sp, r);\n    \n    if(intersect.w > 0.)\n        p = intersect.xyz;\n    else\n        p = rd.y < 0. ? ro + rd * (ro.y / -rd.y) : ro + rd * 1000.;    \n\n    vec3 sgp = sphereIntersect(ro, rd, sp, r + .03).xyz;\n    vec3 sgr = fbm(sgp * 100.);\n    float hl = sat(dot(sgr, fract(sgr * 13.)));\n\n    vec3 seamPlane = normalize(vec3(2,4,1));\n    float seam = abs(dot(p - sp, seamPlane));\n    hl += sat((1.1 - seam * 30.) * .75);\n\n    vec3 n = intersect.w > 0.\n                ? normalize(sphNormal(p, sp) + sgr * .1)\n                : rd.y < 0.\n                    ? vec3(0,1,0)\n                    : -rd;\n    \n    float fnl = pow(sat(1. - dot(rd, -n)), 5.);\n    \n    vec3 lDir = normalize(vec3(1,2,3));\n    float light = dot(n, lDir);\n    \n    vec3 glow = vec3(.2, 1., 0.);\n    \n    vec3 col = vec3(1);\n    \n    if (intersect.w == 0.)\n    {\n        float sh = shadow(p, sp, r, lDir);\n        col *= sh * .75 + .25;\n        col *= sat(length(p - sp) - r * .5);\n        sh = sat(1. - sh);\n        col += sh * sh * sh * glow * .1;\n    }\n    else\n    {\n        float o = 1.;\n        float s = smoothstep(.95 - fnl, 1.1 - fnl, hl);\n        vec3 inv = sphereInverse(ro, rd, sp, r);\n        float tl = smoothstep(.2, 1., abs(light));\n        if(dot(inv - sp, seamPlane) * dot(p - sp, seamPlane) < 0.)\n        {\n            tl *= (1. - abs(dot(inv - sp, seamPlane)));\n        }\n        \n        tl *= min(1. - light, 1.);\n        \n        col = mix(vec3(.02, .2, .01), vec3(.8), s);\n        col *= (light * .5 + .5);\n        o *= sat(p.y * 4.) * .5 + .5;\n        col *= o;      \n        col += tl * glow * .125 * (1. - hl * .35);\n        \n        col += o * sat(p.y * 2. - .4) * sat(dot(reflect(rd, n), lDir) * s);\n    }\n\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = vec2(1. / iResolution.x, 0);\n    \n    fragColor = texture(iChannel0, uv) * 6.;\n    fragColor += texture(iChannel0, uv - st) * 4.;\n    fragColor += texture(iChannel0, uv + st) * 4.;\n    fragColor += texture(iChannel0, uv - st * 2.);\n    fragColor += texture(iChannel0, uv + st * 2.);\n    fragColor *= .0625;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = vec2(0, 1. / iResolution.y);\n    \n    fragColor = texture(iChannel0, uv) * 6.;\n    fragColor += texture(iChannel0, uv - st) * 4.;\n    fragColor += texture(iChannel0, uv + st) * 4.;\n    fragColor += texture(iChannel0, uv - st * 2.);\n    fragColor += texture(iChannel0, uv + st * 2.);\n    fragColor *= .0625;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stV3zy.jpg", "access": "api", "license": "cc-by-sa-4.0", "functions": [[110, 110, 132, 132, 156], [158, 158, 177, 177, 225], [227, 227, 284, 284, 789]], "test": "untested"}
{"id": "flKGRG", "name": "Desmos I Guess.SV", "author": "turtlelover891", "description": "Kinda like the Desmos Graphing Calculator", "tags": ["desmos"], "likes": 3, "viewed": 415, "published": 3, "date": "1637960324", "time_retrieved": "2024-07-30T18:45:45.855981", "image_code": "//So basically, Desmos Graphing Calculator\n\n//equation function with color\nvec3 func(float w, float y, float e, vec3 col){\n    float sol = smoothstep(-1./w, 1./w, 1./w-abs(e-y));\n    return col*sol;\n}\n\n//equation function white\nfloat func(float w, float y, float e){\n    return smoothstep(-1./w, 1./w, 1./w-abs(e-y));\n}\n\n//use pi as needed\nconst float pi = acos(-1.);\n\n//=====================================================\n//Create your own custom functions\n//If a function is in another function, make sure that the function\n//on the inside is initialized before the function on the outside\n\nfloat a(float x, float t){\n    return sin(x*3.-(t*5.));\n}\n\nfloat b(float x, float t){\n    return sin(x+t*5.)*2.-sin(t);\n}\n\nfloat ab(float x, float t){\n    return b(x, t)+(sin(x)/2.+.5)*(a(x, t)-b(x, t));\n}\n\n//=====================================================\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n    vec3 col = vec3(0.);\n    float w = 1.;\n    w = clamp(iMouse.x/5., 2., R.x);\n    float x = fragCoord.x-R.x/2.;\n    float y = fragCoord.y;\n    if(iMouse.xy == vec2(0.)){\n        w = R.x/15.;\n        y /= w;\n        y -= R.y/w/2.;\n    }else{\n    y /= w;\n    y -= clamp(iMouse.y/w, 0., R.y/w);}\n    x /= w;\n\n    float t = iTime;\n    //grid lines\n    col += func(w, y, floor(y))/7.; col += func(w, y, 0.)/4.;\n    col += func(w, x, floor(x))/7.; col += func(w, x, 0.)/4.;\n\n    //The Function 'func' is how you display stuff\n    //The first parameter is w, the width of the line.\n    //Multiply or divide it to grow or shrink the width\n    //The second parameter is the axis, usually use y \n    //The third parameter is the function itself\n    //You can color the function by adding a fourth parameter\n    //Use vec3 for r, g, and b values\n\n    //=========================================================================== \n\n    //col += func(w,  y,  a(x, t),  vec3(1, 0, 0));      //red sin wave\n    //col += func(w,  y,  b(x, t),  vec3(0, 0, 1));      //blue  sin wave\n    col += func(w/2., y, ab(x, t),vec3(0, 1, 0));      //green sin wave\n    //col += func(w, y, x+7.5);                    //white diagonal line\n    //col += func(w, y, -x*x+7.5);                 //white upside down parabola\n    //col += func(w, 2., sqrt(pow(x-3., 2.) + pow(y-2., 2.)));//white circle\n    //col += func(w, x, pi);//white vertical line\n\n    //===========================================================================\n\n    //makes background not entirely black\n    col += vec3(0.075);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flKGRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 75, 122, 122, 200], [202, 228, 266, 266, 319], [595, 595, 621, 621, 652], [654, 654, 680, 680, 716], [718, 718, 745, 745, 800], [860, 860, 917, 917, 2549]], "test": "untested"}
{"id": "ftyGzK", "name": "change detector:stream reduction", "author": "FabriceNeyret2", "description": "Sometime you want to do a complex action (here, draw circle) only at places where some variable changed.\nSince webGLSL doesn't have the splat operator (write2uv), the naive method would be to loop on whole pixels.\nStream Reduction approach is the // way.", "tags": ["tuto", "short", "parallelism", "streamreduction"], "likes": 6, "viewed": 367, "published": 3, "date": "1637953079", "time_retrieved": "2024-07-30T18:45:46.622930", "image_code": "// --- stub task: draw a circle around the changing pixels\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = T(U);                             // show stub evolving image\n    \n    if (  U.x/4. < R.x/64. && U.y/4. < R.y/64. )\n        O =  T1(U/4.), O.b += .3;         // show the 4096x reduced stream\n\n    \n    for (float j = 0.; j < R.y/64.; j++ ) // read the 4096x reduced stream\n        for (float i = 0.; i < R.x/64.; i++ ) {\n            vec4 T =  T1(vec2(i,j));\n            if ( T.a != 0. )              // change detected\n                O[int(T.z)] += smoothstep(1.5,0.,abs(length(U-T.xy)-10.) ); // draw circle\n        }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// --- stub task: revert pixel at random locations\n\n#define H(p)  fract(sin(dot(p, vec2(12.9898, 78.233))-iTime) * 43758.5453)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = T(U) * vec4(1,.99,.99,1); \n    O.a = O.r;                     // memorize the previous value\n    if ( H(U)*H(U*.973) > .995 ) O.rgb += 1.-O.rgb;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R     iResolution.xy\n#define T(U)  texelFetch( iChannel0, ivec2(U), 0 )\n#define T1(U) texelFetch( iChannel1, ivec2(U), 0 )", "buffer_b_code": "// --- first reduction by 64: each thread detect 1st change in a 8x8 block\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U -= .5;\n    if( U.x > R.x/8. || U.y > R.y/8. ) return; // image/64\n    \n    O-=O;\n    for (int k = 0; k < 64; k++ ) {\n        vec2 V =  8.*U + vec2(k%8,k/8);\n        vec4 T = T( V );\n        if ( T.r != T.a ) \n          { O = vec4( V, T.r, 1); return; } // keep location + value, flag to 1\n    }    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// --- first reduction by 64: each thread detect a flag set in a 8x8 block\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U -= .5;\n    if( U.x > R.x/64. || U.y > R.y/64. ) return; // image/4096\n    O-=O;\n    for (int k = 0; k < 64; k++ ) {\n        vec2 V =  8.*U + vec2(k%8,k/8);\n        vec4 T = T( V );\n        if ( T.a != 0. ) { O = T; return; } // propagate the value\n    }    \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftyGzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 98, 98, 627]], "test": "untested"}
{"id": "NtG3RK", "name": "Noise Blobs", "author": "SnoopethDuckDuck", "description": "sc = 3. makes it a noisy trail (need more points in for loop), the for loop is a bit expensive", "tags": ["e"], "likes": 7, "viewed": 317, "published": 3, "date": "1637953057", "time_retrieved": "2024-07-30T18:45:47.410823", "image_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n// smoothstep from a point p\nfloat sp(vec2 uv, float t) {\n    vec2 p = 0.35 * vec2(thc(0.5, t * 0.713), ths(0.5, t));\n    float d = length(uv - p);\n    float k = 0.5 * d + 0.035 * length(uv);\n    return smoothstep(-k, k, k - d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    // warp uv slightly\n    uv /= 0.85 * cosh(1.1 * length(uv));\n\n    float t = 2.5 * iTime;\n    \n    // length of trail (0.05 -> blobs, 3. -> noisy trail)\n    float sc = 0.1; //mix(0.05, 3., .5 + .5 * cos(2. * iTime));\n    \n    // flick between blobs seperated/together\n    float e = .5 + .5 * thc(4., -0.8 * iTime);\n    \n    // make 12 blobs (sc * h21 \"stretches\" using noise)\n    float s = sp(uv, t + sc * h21(uv));\n    for (float i = 1.; i < 12.; i++) {\n        s = max(s, sp(uv, e * i + t + sc * h21(uv + i)));\n    }\n    \n    vec3 col = s * pal(s, vec3(1.), vec3(1.), vec3(1.), s * vec3(0.,0.33,0.66)); \n    col += 2. * vec3(s) * vec3(0.2,0.6,0.9);\n    //col = vec3(s);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtG3RK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 49, 49, 90], [92, 92, 121, 121, 162], [164, 164, 232, 232, 275], [277, 277, 297, 297, 372], [374, 403, 431, 431, 604], [606, 606, 663, 663, 1436]], "test": "untested"}
{"id": "NlGGzK", "name": "Mandelbrot Domain Coloring", "author": "tungster24", "description": "i finally did it :D", "tags": ["fractal", "mandelbrot", "domain"], "likes": 4, "viewed": 282, "published": 3, "date": "1637951862", "time_retrieved": "2024-07-30T18:45:48.183757", "image_code": "//cartesian to polar coordinates\n\nfloat theta(in float x, in float y) {\n    float pi = 3.14159265;\n    return mod(atan(y,x),2.0*pi);\n}\n\nfloat r(in float x, in float y) {\n    return sqrt(x*x+y*y);\n}\n\nvec3 hsv(in float h, in float s, in float v) {\n    // preperation functions\n    float r1 = max(min(abs((mod(h,360.0)-180.0)/60.0)-1.0,1.0),0.0);\n    float g1 = max(min(2.0-abs((mod(h,360.0)-120.0)/60.0),1.0),0.0);\n    float b1 = max(min(2.0-abs((mod(h,360.0)-240.0)/60.0),1.0),0.0);\n    \n    //hsv to rgb functions\n    float r = (r1+(1.0-r1*(100.0-s)/100.0)-s/100.0)*v/100.0;\n    float g = (g1+(1.0-g1*(100.0-s)/100.0)-s/100.0)*v/100.0;\n    float b = (b1+(1.0-b1*(100.0-s)/100.0)-s/100.0)*v/100.0;\n    \n    return vec3(r,g,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // grid with -2 to 2 from -y to y, adjusted for x so there's no distortion\n    float x = (fragCoord.x/iResolution.y)*2.0-1.0*iResolution.x/iResolution.y;\n    float y = (fragCoord.y/iResolution.y)*2.0-1.0;\n    \n    // complex number\n    vec2 z = vec2(0,0);\n    \n    //pi for convenience\n    float pi = 3.1415926;\n    \n    for (int i = 0;i < 40;i++) {\n        z = vec2(z.x*z.x-z.y*z.y+x,2.0*z.x*z.y+y);\n    }\n    \n    //check if r(z.x,z.y) [distance to origin] is overflowing, if so color it white.\n    float k1,k2,k3;\n    if (isnan(r(z.x,z.y))) {k1 = 100.0;k2 = 0.0;k3 = 0.0;}\n    \n    \n    else {k1 = r(z.x,z.y)*100.0;k2 = 100.0-r(z.x,z.y)*100.0;k3 = theta(z.x,z.y)*(180.0/pi)+iTime*360.0;}\n    \n    \n    fragColor = vec4(hsv(k3,k2,k1),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlGGzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 71, 71, 134], [136, 136, 169, 169, 197], [199, 199, 245, 274, 727], [729, 729, 786, 865, 1534]], "test": "untested"}
{"id": "NlG3Wm", "name": "micro Texture NCA68 (minimal)", "author": "Anony", "description": "\"Texture Generation with Ultra-Compact Neural Cellular Automata\" supplementary material\nA collection of Texture generating NCA-68 rules.\nSee \"Buffer A\" for the NCA code", "tags": ["ca"], "likes": 18, "viewed": 425, "published": 3, "date": "1637942780", "time_retrieved": "2024-07-30T18:45:48.958685", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0,uv*0.5)+0.5;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 rule2(vec4 s, vec4 p) {\n  return 1e-3*(vec4(4,-10,-27,18)+\n    mat4(-67,1,2,44,-13,-59,4,30,-1,16,-57,9,-10,-4,-2,-41)*s+\n    mat4(19,-18,-1,8,-4,35,8,0,-4,-4,-1,0,34,31,21,-25)*p+\n    mat4(4,13,18,-57,-79,-22,-25,71,-12,-11,24,27,-17,-8,-7,6)*abs(s)+\n    mat4(11,10,4,0,4,1,2,7,-26,-33,-15,-3,22,27,20,-34)*abs(p));     \n}\n\nvec4 hash43(vec3 p) {\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 R(float x, float y) {\n    return texture(iChannel0, vec2(x, y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 dp = 1.0/iResolution.xy;\n  vec2 pos = fragCoord*dp;\n  \n  float x=pos.x, y=pos.y;\n  float l=x-dp.x, r=x+dp.x, u=y-dp.y, d=y+dp.y;\n  vec4 s = R(x,y);\n  if (s == vec4(0, 0, 0, 0)) { // random initialization\n    fragColor = hash43(vec3(fragCoord, iFrame))-0.5;\n    return;\n  }  \n  // perception\n  vec4 p = R(l,u)*vec4(1,1,-1, 1) + R(x,u)*vec4(2,2,0, 2) + R(r,u)*vec4(1,1,1, 1)\n         + R(l,y)*vec4(2,2,-2, 0) +  s*vec4(-12,-12,0, 0) + R(r,y)*vec4(2,2,2, 0)\n         + R(l,d)*vec4(1,1,-1,-1) + R(x,d)*vec4(2,2,0,-2) + R(r,d)*vec4(1,1,1,-1);\n  vec4 ds = rule2(s, p);  // NCA rule application\n  fragColor = clamp(s+ds, -1.5, 1.5);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlG3Wm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 147]], "test": "untested"}
{"id": "Nty3Ry", "name": "Plotting by dmc3105", "author": "dmc3105", "description": "my first shader", "tags": ["math"], "likes": 1, "viewed": 219, "published": 3, "date": "1637939210", "time_retrieved": "2024-07-30T18:45:49.728626", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pixelsPerSegment = pow(1.2, iTime+ 15.0);\n    float axisThickness = 2.0;\n    float gridThickness = 3.0;\n    float graficThickness = 5.0;\n    \n    vec2 inp = (fragCoord - iResolution.xy * 0.5)/ pixelsPerSegment ;\n    vec2 center = iResolution.xy * 0.5;\n    \n    float x = inp.x;\n    float y = sin(x);\n    \n    \n    vec3 col = vec3(1.0);\n    graficThickness *= 0.5;\n    // draw grid\n    float startX = fragCoord.x - center.x + gridThickness * 0.5;\n    if (startX - (float(int((startX) / pixelsPerSegment))\n        * pixelsPerSegment)<= gridThickness &&\n        fragCoord.x > center.x)\n        col = vec3(0.9);\n    startX = fragCoord.x - center.x - gridThickness * 0.5;\n    if (abs(startX - (float(int((startX) / pixelsPerSegment)))\n        * pixelsPerSegment) <= gridThickness &&\n        fragCoord.x < center.x)\n        col = vec3(0.9);\n    float startY = fragCoord.y - center.y + gridThickness * 0.5;\n    if (startY - (float(int((startY) / pixelsPerSegment))\n        * pixelsPerSegment)<= gridThickness &&\n        fragCoord.y > center.y)\n        col = vec3(0.9);\n    startY = fragCoord.y - center.y - gridThickness * 0.5;\n    if (abs(startY - (float(int((startY) / pixelsPerSegment)))\n        * pixelsPerSegment) <= gridThickness &&\n        fragCoord.y < center.y)\n        col = vec3(0.9);\n        \n        \n\n    //draw axis\n    if (abs(iResolution.x * 0.5 - fragCoord.x) <= axisThickness ||\n        abs(iResolution.y * 0.5 - fragCoord.y) <= axisThickness )\n    {\n        col = vec3(0.0);\n    }\n    \n    \n    \n    // draw function\n    if (pow((pow(inp.y - y, 2.0) + pow(inp.x - x, 2.0)), 0.5) < graficThickness / pixelsPerSegment)\n    {\n        col = vec3(0.0);\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nty3Ry.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "slVGzG", "name": "Gradient 2", "author": "turboplay", "description": "Import from https://github.com/Oncorporation/obs-shaderfilter", "tags": ["filter", "gradient"], "likes": 2, "viewed": 232, "published": 3, "date": "1637926484", "time_retrieved": "2024-07-30T18:45:50.494578", "image_code": "\n// gradient shader by Charles Fettinger for obs-shaderfilter plugin 3/2019\n//https://github.com/Oncorporation/obs-shaderfilter\n vec4 start_color = vec4(0.5, 0.3, 0.1, 1.0);\n float start_step = 0.15f;\n vec4 middle_color = vec4(1.0, 1.0, 1.0, 1.0);\n float middle_step = 0.4f;\n vec4 end_color = vec4(0.5, 0.75, 0.05, 1.0);\n float end_step = 0.9f;\n float alpha_percent = 90.;\n float pulse_speed = 0.;\n bool ease = true;\n bool rotate_colors = false;\n bool Apply_To_Alpha_Layer = true;\n bool Apply_To_Specific_Color;\n vec4 Color_To_Replace = vec4(0.,1.,0.,1.);\n bool horizontal = false;\n bool vertical = false;\n float gradient_center_width_percentage = 50.;\n float gradient_center_height_percentage = 50.;\n\nfloat EaseInOutCircTimer(float t, float b, float c, float d) {\n\tt /= d / 2.;\n\tif (t < 1.) return -c / 2. * (sqrt(1. - t * t) - 1.) + b;\n\tt -= 2.;\n\treturn c / 2. * (sqrt(1. - t * t) + 1.) + b;\n}\n\nfloat BlurStyler(float t, float b, float c, float d, bool ease)\n{\n\tif (ease) return EaseInOutCircTimer(t, 0., c, d);\n\treturn t;\n}\n\nstruct gradient\n{\n\tvec4 color;\n\tfloat step;\n};\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\nconst float PI = 3.14159265f;//acos(-1);\n\tfloat speed = pulse_speed * 0.01;\n\tfloat alpha = alpha_percent * 0.01;\n\t\n\t//circular easing variable\n\tfloat t = sin(iTime * speed) * 2. - 1.;\n\tfloat b = 0.0; //start value\n\tfloat c = 2.0; //change value\n\tfloat d = 2.0; //duration\n\n\tvec2 gradient_center = vec2(gradient_center_width_percentage * 0.01,gradient_center_height_percentage * 0.01);\n\tvec4 color = texture(iChannel0, uv);\n\tfloat luminance = dot(color.rgb, vec3(0.299, 0.587, 0.114));\n\tvec4 gray = vec4(luminance,luminance,luminance, 1);\n\t// skip if (alpha is zero and only apply to alpha layer is true) \n\tif (!(color.a <= 0.0 && Apply_To_Alpha_Layer == true))\n\t{\n\t\tb = BlurStyler(t, 0., c, d, ease);\n\n\t\tconst int no_colors = 3;\n\t\tvec4 s_color = start_color;\n\t\tvec4 m_color = middle_color;\n\t\tvec4 e_color = end_color;\n\n\t\tif (rotate_colors)\n\t\t{\n\t\t\t// get general time number between 0 and 4\n\t\t\tfloat tx = (b + 1.) * 2.;\n\t\t\t// 3 steps  c1->c2, c2->c3, c3->c1\n\t\t\t//when between 0 - 1 only c1 rises then falls\n\n\t\t\tif (tx <= 2.0)\n\t\t\t{\n\t\t\t\ts_color = mix(start_color, middle_color, clamp((min(tx, 2.0) * 0.5) * 2., 0.0, 1.0));\n\t\t\t\tm_color = mix(middle_color, end_color, clamp((min(tx, 2.0) * 0.5) * 2., 0.0, 1.0));\n\t\t\t\te_color = mix(end_color, start_color, clamp((min(tx, 2.0) * 0.5) * 2., 0.0, 1.0));\n\t\t\t}\n\n\t\t\tif ((tx >= 1.0) && (tx <= 3.0))\n\t\t\t{\n\t\t\t\ts_color = mix(middle_color, end_color, clamp(((min(max(1.0, tx), 3.0) - 1.) * 0.5) * 2., 0.0, 1.0));\n\t\t\t\tm_color = mix(end_color, start_color, clamp(((min(max(1.0, tx), 3.0) - 1.) * 0.5) * 2., 0.0, 1.0));\n\t\t\t\te_color = mix(start_color, middle_color, clamp(((min(max(1.0, tx), 3.0) - 1.) * 0.5) * 2., 0.0, 1.0));\n\t\t\t}\n\n\t\t\tif (tx >= 2.0)\n\t\t\t{\n\t\t\t\ts_color = mix(end_color, start_color, clamp(((min(2.0, tx) - 2.) * 0.5) * 2., 0.0, 1.0));\n\t\t\t\tm_color = mix(start_color, middle_color, clamp(((min(2.0, tx) - 2.) * 0.5) * 2., 0.0, 1.0));\n\t\t\t\te_color = mix(middle_color, end_color, clamp(((min(2.0, tx) - 2.) * 0.5) * 2., 0.0, 1.0));\n\t\t\t}\n\n\t\t\tif (tx < 0.)\n\t\t\t{\n\t\t\t\ts_color = mix(end_color, start_color, clamp(abs(max(1.0, tx)) * 2., 0.0, 1.0));\n\t\t\t\tm_color = mix(start_color, middle_color, clamp(abs(max(1.0, tx)) * 2., 0.0, 1.0));\n\t\t\t\te_color = mix(middle_color, end_color, clamp(abs(max(1.0, tx)) * 2., 0.0, 1.0));\n\t\t\t}\n\t\t}\n\n\t\tvec4 colors[no_colors] = vec4[](s_color, m_color, e_color );\n\t\tfloat step[no_colors] = float[]( start_step, middle_step, end_step );\n\n\t\tfloat redness = max(min(color.r - color.g, color.r - color.b) / color.r, 0.);\n\t\tfloat greenness = max(min(color.g - color.r, color.g - color.b) / color.g, 0.);\n\t\tfloat blueness = max(min(color.b - color.r, color.b - color.g) / color.b, 0.);\n\n\t\tfloat dist = distance(uv, gradient_center);\n\t\tif (horizontal && (vertical == false))\n\t\t{\n\t\t\tdist = distance(uv.y, gradient_center.y);\n\t\t}\n\t\tif (vertical && (horizontal == false))\n\t\t{\n\t\t\tdist = distance(uv.x, gradient_center.x);\n\t\t}\n\n\t\tvec4 col = colors[0];\n\t\tfor (int i = 1; i < no_colors; ++i) {\n\t\t\tcol = mix(col, colors[i], smoothstep(step[i - 1], step[i], dist));\n\t\t}\n\t\tcol.a = clamp(alpha, 0.0, 1.0);\n\t\tif (Apply_To_Alpha_Layer == false)\n\t\t\tcolor.a = alpha;\n        if (Apply_To_Specific_Color)\n        {\n            col.a = alpha;\n            vec4 original_color = texture(iChannel0, uv);\n            col.rgb = (distance(color.rgb, Color_To_Replace.rgb) <= 0.075) ? col.rgb : original_color.rgb;\n        }\n\t\t//\tresult = vec4(redness, greenness,blueness,1);\n\t\t//color *= vec4(col.r, col.g, col.b, clamp(dot(color, luminance)* alpha, 0.0, 1.0));\n\t\t//color.rgb += col * alpha;\n\t\t//color.a += clamp(1.0 - alpha, 0.0,1.0);\n\t\t///color.rgb *= (color.rgb * clamp(1.0- alpha, 0.0, 1.0)) + (col.rgb * clamp(alpha, 0.0, 1.0));\n\t\t//color = vec4(max(color.r, col.r), max(color.g, col.g), max(color.b, col.b), clamp(dot(color, luminance) * alpha, 0.0, 1.0));\n\t\tcolor.rgb = mix(color.rgb, col.rgb, clamp(alpha, 0.0, 1.0));\n\n\nfragColor = color;\n\t}\n    \n    \n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slVGzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[702, 702, 764, 764, 895], [897, 897, 962, 962, 1026]], "test": "untested"}
{"id": "7tVGzG", "name": "Spot Light", "author": "turboplay", "description": "https://github.com/Oncorporation imported", "tags": ["light", "effect"], "likes": 1, "viewed": 281, "published": 3, "date": "1637925746", "time_retrieved": "2024-07-30T18:45:51.257538", "image_code": " float Speed_Percent = 100.0f ;\n float Focus_Percent = 15.0f;\n bool Glitch = false;\n vec4 Spotlight_Color = vec4(1,1,1,1);\n float Horizontal_Offset = 0.0f;\n float Vertical_Offset = -0.5f;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n   float speed = Speed_Percent * 0.01;\n\tfloat focus = Focus_Percent;\n\tif (Glitch)\n\t{\n\t\tspeed *= ((2. * 2.) - 1.) * 0.01;\n\t\tfocus *= ((2. * 1.1) - 0.1);\n\t}\n\n\tfloat PI = 3.1415926535897932384626433832795;//acos(-1);\n\tvec4 c0 = texture(iChannel0, uv);\n\tvec3 lightsrc = vec3(sin(iTime * speed * PI * 0.667) *.5 + .5 + Horizontal_Offset, cos(iTime * speed * PI) *.5 + .5 + Vertical_Offset, 1);\n\tvec3 light = normalize(lightsrc - vec3( uv.x + (Horizontal_Offset * speed),  uv.y + (Vertical_Offset * speed), 0));\n\tc0 *= pow(dot(light, vec3(0, 0, 1.)), focus) * Spotlight_Color;\n\n\tfragColor = c0;\n    \n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tVGzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[190, 190, 247, 297, 934]], "test": "untested"}
{"id": "stKGzG", "name": "connected components in truchet2", "author": "FabriceNeyret2", "description": "Find the connected component.  \naccelerated variant of [url]https://shadertoy.com/view/7ty3zG[/url] \n( front still have slow propag sometime. could it be improved ? )\n\nclick to restart a new truchet tiling.  Scale N in Common.", "tags": ["flood", "short", "connected", "truchets"], "likes": 14, "viewed": 347, "published": 3, "date": "1637924472", "time_retrieved": "2024-07-30T18:45:52.023491", "image_code": "// accelerated variant of https://shadertoy.com/view/7ty3zG\n// ( see BuffA from line 33 )\n\n#define hue(v)  vec4( .6 + .6 * cos( .5+(v)  + vec3(0,23,21)  ) , 1 )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = N * u / R.y + 8.*iTime, I = floor(U), F = fract(U);\n         \n    O = T(I);                                          // cell states \n    O.w > 0. ? F = vec2(1.-F.y,F.x) : F;\n    \n    O =   smoothstep(N*1.5/R.y,0.,abs(min(length(F),length(1.-F))-.5) - .05 ) // truchet drawing\n        * hue( O[ F.x+F.y < 1. ? 1 : 2 ] );            // coloring\n         \n // if (iMouse.z>0.) O += (1.-O.w)*.3*mod(I.x+I.y,2.); // debug: draw tiles\n // O += .3*T(I).w;\n} ", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define H(p)  fract(sin(dot(p, vec2(12.9898, 78.233))-iTime) * 43758.5453)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    if ( iFrame < 1 || iMouse.z>0.) {         // --- init: create truchet\n        vec2 I = u-.5;                        // store truchet data\n        O.w = step(.5,H(I));                  // random axis\n        O.y = 1.+I.x+4096.*I.y;               // id of tile segment #1\n        O.z = -O.y;                           // id of tile segment #2\n        return;\n    }\n    \n    u -= .5;\n    O = T(u);                                 // previous state\n // if (u.x > N*R.x/R.y || u.y > N) return;   // propagate only visible tiles\n    \n    vec4 T;                                   // --- propagate id along connections\n#define left       T(u+vec2(1,0)).y\n#define right      T(u-vec2(1,0)).z\n#define bot      ( T = T(u+vec2(0,1)), T.w<1. ? T.y : T.z )\n#define top      ( T = T(u-vec2(0,1)), T.w<1. ? T.z : T.y )\n//#define min(a,b) ( abs(a) < abs(b) ? a : b ) // may this boost ?\n    if (O.w<1.) { // tile contains:  \\     new id = min(connections)\n        O.y = min( O.y, min( right, top ));\n        O.z = min( O.z, min( left , bot ));\n    }\n    else {        // tile contains:  /     new id = min(connections)\n        O.y = min( O.y, min( right, bot ));\n        O.z = min( O.z, min( left , top ));\n    }\n    \n                  // --- shortcut: go check if the id is itself updated\n#define source(v) ( i = int(abs(v))-1, T = T(vec2( i%4096, i/4096 )), \\\n                    v>0. ?  T.y : T.z )\n    int i;\n    O.y = source(O.y);\n    O.z = source(O.z);\n} ", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float N = 60.; // vertical number of tiles\n\n#define R    iResolution.xy\n#define T(U) texelFetch( iChannel0, ivec2(U+R)%ivec2(R), 0 )", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stKGzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[162, 162, 200, 200, 664]], "test": "untested"}
{"id": "slK3RG", "name": "Glow 2", "author": "turboplay", "description": "Glow imported from https://github.com/Oncorporation", "tags": ["filter", "glow"], "likes": 0, "viewed": 236, "published": 3, "date": "1637921541", "time_retrieved": "2024-07-30T18:45:52.789442", "image_code": "// Change these\n float glow_percent = 40.;\n float blur = 1.;\n float min_brightness= 27.;\n float max_brightness = 100.;\n float pulse_speed = 0.;\n vec4 glow_color = vec4(1,1,1,1);\n bool ease = false;\n\n\nfloat EaseInOutCircTimer(float t,float b,float c,float d){\n\tt /= d/2.;\n\tif (t < 1.) return -c/2. * (sqrt(1. - t*t) - 1.) + b;\n\tt -= 2.;\n\treturn c/2. * (sqrt(1. - t*t) + 1.) + b;\t\n}\n\nfloat BlurStyler(float t,float b,float c,float d,bool ease)\n{\n\tif (ease) return EaseInOutCircTimer(t,0.,c,d);\n\treturn t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n  vec2 offsets[4];\noffsets[0] = vec2(-0.1,  0.125);\noffsets[1] = vec2(-0.1, -0.125);\noffsets[2] = vec2(0.1, -0.125);\noffsets[3] = vec2(0.1,  0.125);\n\n\t// convert input for vector math\n\tvec4 color = texture(iChannel0, uv);\n\tfloat blur_amount = blur /100.;\n\tfloat glow_amount = glow_percent * 0.01;\n\tfloat speed = pulse_speed * 0.01;\t\n\tfloat luminance_floor = min_brightness /100.;\n\tfloat luminance_ceiling = float(max_brightness) /100.;\n\n\tif (color.a > 0.0)\n\t{\n\t\t//circular easing variable\n\t\tfloat t = 1. + sin(iTime * speed);\n\t\tfloat b = 0.0; //start value\n\t\tfloat c = 2.0; //change value\n\t\tfloat d = 2.0; //duration\n\n\t\t// simple glow calc\n\t\tfor (int n = 0; n < 4; n++) {\n\t\t\tb = BlurStyler(t, 0., c, d, ease);\n\t\t\tvec4 ncolor = texture(iChannel0, uv + (blur_amount * b) * offsets[n]);\n\t\t\tfloat intensity = dot(ncolor.rgb * 1., vec3(0.299, 0.587, 0.114));\n\t\t\tif ((intensity >= luminance_floor) && (intensity <= luminance_ceiling))\n\t\t\t{\n\t\t\t\tncolor.a = clamp(ncolor.a * glow_amount, 0.0, 1.0);\n\t\t\t\tncolor.rgb = ncolor.rgb * glow_color.rgb;\n\t\t\t\tcolor += (ncolor * (glow_amount * b));\n\t\t\t}\n\t\t}\n\t}\n\tfragColor = color;\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slK3RG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[200, 200, 258, 258, 380], [382, 382, 443, 443, 504], [507, 507, 564, 614, 1767]], "test": "untested"}
{"id": "7tK3RG", "name": "Glass 2", "author": "turboplay", "description": "Imported from https://github.com/Oncorporation/", "tags": ["filter", "glass"], "likes": 2, "viewed": 258, "published": 3, "date": "1637920781", "time_retrieved": "2024-07-30T18:45:53.561378", "image_code": " float Alpha_Percent = 100.0;\n float Offset_Amount = 0.8;\n int xSize = 8;\n int ySize = 8;\n int Reflection_Offset = 2;\n bool Horizontal_Border;\n float Border_Offset = 0.;\n vec4 Border_Color = vec4(.8,.5,1.0,1.0);\n vec4 Glass_Color;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\nint xSubPixel = int(uv.x * iResolution.x) % clamp(xSize,1,100);\n\tint ySubPixel = int(uv.y * iResolution.y) % clamp(ySize,1,100);\n\tvec2 offsets = vec2(Offset_Amount * float(xSubPixel) / iResolution.x, Offset_Amount * float(ySubPixel) / iResolution.y);\n\tuv = uv + offsets;\n\tvec2 uv2 = vec2(uv.x + (float(Reflection_Offset) / iResolution.x),uv.y + (float(Reflection_Offset) / iResolution.y));\n\n\tvec4 rgba = texture(iChannel0, uv);\n\tvec4 rgba_output = vec4(rgba.rgb * Border_Color.rgb, rgba.a);\n\trgba = texture(iChannel0, uv);\n\tvec4 rgba_glass =texture(iChannel0, uv2);\n\t\n\tfloat uv_compare = uv.x;\n\tif (Horizontal_Border)\n\t\tuv_compare = uv.y;\n\n\tif (uv_compare < (Border_Offset - 0.005))\n\t{\n\t\t\trgba_output = (rgba + rgba_glass) *.5 * Glass_Color;\n\t}\n\telse if (uv_compare >= (Border_Offset + 0.005))\n\t{\n\t\trgba_output = texture(iChannel0, uv);\n\t}\n\tfragColor= mix(rgba,rgba_output,(Alpha_Percent * 0.01));\n    \n    }", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tK3RG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7lVGRG", "name": "Frost Glass 2", "author": "turboplay", "description": "Imported from https://github.com/Oncorporation/", "tags": ["filter", "glass"], "likes": 2, "viewed": 513, "published": 3, "date": "1637920344", "time_retrieved": "2024-07-30T18:45:54.357250", "image_code": " float Alpha_Percent = 100.0;\n float Amount = 0.03;\n float Scale = 5.1;\n bool Animate;\n bool Horizontal_Border;\n float Border_Offset = 1.1;\n vec4 Border_Color = vec4(.8,.5,1.0,1.0);\n \nfloat rand(vec2 co)\n{\n\tfloat scale = Scale;\n//\tif (Animate)\n//\t\tscale *= rand_f;\n\tvec2 v1 = vec2(92.0,80.0);\n\tvec2 v2 = vec2(41.0,62.0);\n\treturn fract(sin(dot(co.xy ,v1)) + cos(dot(co.xy ,v2)) * scale);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    vec4 rgba = texture(iChannel0, uv);\n\tvec3 tc = rgba.rgb * Border_Color.rgb;\n\t\n\tfloat uv_compare = uv.x;\n\tif (Horizontal_Border)\n\t\tuv_compare = uv.y;\n\n\tif (uv_compare < (Border_Offset - 0.005))\n\t{\n\t\tvec2 randv = vec2(rand(uv.yx),rand(uv.yx));\n\t\ttc = texture(iChannel0, uv + (randv*Amount)).rgb;\t\t\n\t}\n\telse if (uv_compare >= (Border_Offset + 0.005))\n\t{\n\t\ttc = texture(iChannel0, uv).rgb;\n\t}\n\tfragColor = mix(rgba,vec4(tc,1.0),(Alpha_Percent * 0.01));\n    \n    \n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lVGRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[184, 184, 205, 205, 388], [391, 391, 448, 498, 1005]], "test": "untested"}
{"id": "NtV3zy", "name": "Interactive Mandelbulb 2", "author": "dr2", "description": "Updated with transparent / reflecting envelope", "tags": ["fractal", "reflection", "transparency"], "likes": 8, "viewed": 318, "published": 3, "date": "1637916171", "time_retrieved": "2024-07-30T18:45:55.195011", "image_code": "// \"Interactive Mandelbulb 2\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Updated with transparent / reflecting envelope.\n\n/*\n  Explore the sublime Mandelbulb; use mouse to spin and sliders to zoom and override\n  automatically varying envelope.\n\n  Adapted from something I wrote a long time ago while learning CUDA; further\n  details can be found at the skytopia, subblue and iquilezles sites.\n*/\n\n#define AA   0     // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nvec3 HsvToRgb (vec3 c);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nfloat Fbm2 (vec2 p);\nvec4 Loadv4 (int idVar);\n\nvec3 ltDir;\nfloat dstFar, tCur, sFac, reflFac;\nint nIt, nStep;\nconst int maxStep = 150;\nconst float pi = 3.1415927;\n\nfloat ObjDf (vec3 p)\n{\n  vec4 aa, sa, ca;\n  vec3 c, q, qd;\n  float qLen, qdLen, q2, q4, phi, theta, thetad, phid;\n  q = p.xzy / sFac;\n  c = q;\n  qLen = length (q);\n  phi = atan (q.y, q.x);\n  theta = (qLen > 0.) ? acos (q.z / qLen) : 0.;\n  thetad = 0.;\n  phid = 0.;\n  qdLen = 1.;\n  nIt = 0;\n  for (int n = VAR_ZERO; n < 5; n ++) {\n    q2 = qLen * qLen;\n    q4 = q2 * q2;\n    aa = vec4 (8. * vec2 (theta, phi), 7. * vec2 (theta, phi) + vec2 (thetad, phid));\n    sa = sin (aa);\n    ca = cos (aa);\n    q = q4 * q4 * vec3 (sa.x * vec2 (ca.y, sa.y), ca.x) + c;\n    qd = 8. * q4 * q2 * qLen * qdLen * vec3 (sa.z * vec2 (ca.w, sa.w), ca.z) + 1.;\n    qLen = length (q);\n    phi = atan (q.y, q.x);\n    theta = (qLen > 0.) ? acos (q.z / qLen) : 0.;\n    qdLen = length (qd);\n    phid = atan (qd.y, qd.x);\n    thetad = (qdLen > 0.) ? asin (qd.z / qdLen) : 0.;\n    ++ nIt;\n    if (qLen > 3.1623) break;\n  }\n  return (qLen > 0.) ? sFac * 0.5 * qLen * log (qLen) / qdLen : 0.;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d, eps;\n  eps = 1e-3;\n  dHit = 0.;\n  nStep = 0;\n  for (int j = VAR_ZERO; j < maxStep; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    ++ nStep;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p, float del)\n{\n  vec4 v;\n  vec2 e;\n  e = del * vec2 (1., -1.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col, vec2 parmV)\n{\n  vec4 wgBx[2];\n  vec3 cc[2], cw;\n  vec2 ut, ust, c;\n  float vW[2], asp;\n  c = vec2 (1., 0.5);\n  cc[0] = c.xyy;\n  cc[1] = c.yxy;\n  asp = canvas.x / canvas.y;\n  for (int k = 0; k < 2; k ++)\n     wgBx[k] = vec4 ((0.41 + 0.05 * float (k)) * asp, -0.15, 0.014 * asp, 0.18);\n  vW[0] = parmV.x;\n  vW[1] = parmV.y;\n  for (int k = 0; k < 2; k ++) {\n    ut = 0.5 * uv - wgBx[k].xy;\n    ust = abs (ut) - wgBx[k].zw * vec2 (0.7, 1.);\n    if (Maxv2 (ust) < 0.) {\n      if (Minv2 (abs (ust)) * canvas.y < 2.) cw = 0.3 * cc[k];\n      else cw = (mod (0.5 * ((0.5 * uv.y - wgBx[k].y) / wgBx[k].w - 0.99), 0.1) *\n         canvas.y < 6.) ? 0.3 * cc[k] : 0.6 * cc[k];\n    }\n    ut.y -= (vW[k] - 0.5) * 2. * wgBx[k].w;\n    cw = mix (cc[k], cw, smoothstep (0., 0.5, abs (length (ut * vec2 (1., 2.)) - 0.025) *\n       canvas.y - 3.));\n  }\n  return mix (col, cw, length (cw));\n}\n\nvec3 BgCol (vec3 rd)\n{\n  vec3 col;\n  vec2 u;\n  float el, f;\n  rd.xz = Rot2D (rd.xz, 0.01 * tCur);\n  el = asin (rd.y);\n  u = vec2 (atan (rd.z, - rd.x) + pi, tan (2. * atan (0.5 * el))) / (2. * pi);\n  f = 64.;\n  col = mix (vec3 (0., 0.1, 0.3), vec3 (0.8), mix (Fbm2 (f * u),\n     Fbm2 (f * (u - vec2 (1., 0.))), u.x));\n  col = mix (col, vec3 (0.2, 0.3, 0.4), smoothstep (0.95, 0.98, abs (el) / (0.5 * pi)));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col, roo, rdo, colS[2];\n  float dHit, b, rLim;\n  int nItT;\n  roo = ro;\n  rdo = rd;\n  rLim = 3.;\n  b = - dot (ro, rd);\n  for (int k = VAR_ZERO; k < 2; k ++) {\n    sFac = 0.9 + 0.1 * float (k);\n    ro = roo;\n    rd = rdo;\n    dHit = b * b - dot (ro, ro) + sFac * rLim;\n    if (dHit > 0.) {\n      ro += (b - sqrt (dHit)) * rd;\n      dHit = ObjRay (ro, rd);\n    } else dHit = dstFar;\n    if (dHit < dstFar) {\n      ro += dHit * rd;\n      nItT = nIt;\n      vn = ObjNf (ro, ((k == 0) ? 0.001 : 0.1));\n      if (k == 0) {\n        colS[k] = HsvToRgb (vec3 (fract (0.6 * log (float (nItT))) + fract (0.1 * tCur),\n           1., 1. - 0.5 * smoothstep (0.7, 1., float (nStep) / float (maxStep))));\n        colS[k] = colS[k] * (0.3 + 0.7 * max (dot (vn, ltDir), 0.) +\n           pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.));\n      } else {\n        rd = reflect (rd, vn);\n        colS[k] = mix (BgCol (rd), vec3 (0.9, 0.9, 1.),\n           pow (max (dot (ltDir, rd), 0.), 1024.));\n      }\n    } else colS[k] = BgCol (rdo);\n  }\n  col = mix (colS[0], colS[1], reflFac);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float az, el, zmFac, zmVar, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  stDat = Loadv4 (0);\n  el = stDat.x;\n  az = stDat.y;\n  stDat = Loadv4 (2);\n  zmVar = stDat.x;\n  zmFac = 30. * zmVar + 8.;\n  reflFac = stDat.y;\n  dstFar = 20.;\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -10.);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowWg (uv, canvas, ShowScene (ro, rd), vec2 (zmVar, reflFac));\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1.,\n     0., 1.), c.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 32.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Interactive Mandelbulb 2\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst float txRow = 32.;\nconst float pi = 3.1415927;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 wgBx[2], stDat, mPtr, mPtrP;\n  vec2 iFrag, canvas, ust;\n  float tCur, tCurP, el, az, vW, asp, zmVar, autoMod, reflFac, tMan;\n  int pxId, wgSel, wgReg, kSel;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 3) discard;\n  wgSel = -1;\n  wgReg = -2;\n  if (iFrame <= 3) {\n    el = -0.2 * pi;\n    az = 0.;\n    zmVar = 0.;\n    reflFac = 0.5;\n    mPtrP = mPtr;\n    autoMod = 1.;\n    tMan = tCur;\n    tCurP = tCur;\n  } else {\n    stDat = Loadv4 (0);\n    el = stDat.x;\n    az = stDat.y;\n    autoMod = stDat.z;\n    tMan = stDat.w;\n    stDat = Loadv4 (1);\n    mPtrP = vec4 (stDat.xyz, 0.);\n    wgSel = int (stDat.w);\n    stDat = Loadv4 (2);\n    zmVar = stDat.x;\n    reflFac = stDat.y;\n    tCurP = stDat.z;\n  }\n  wgReg = -2;\n  asp = canvas.x / canvas.y;\n  if (mPtr.z > 0.) {\n    for (int k = 0; k < 2; k ++)\n       wgBx[k] = vec4 ((0.41 + 0.05 * float (k)) * asp, -0.15, 0.014 * asp, 0.18);\n    for (int k = 0; k < 2; k ++) {\n      ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[k].xy) - wgBx[k].zw;\n      if (max (ust.x, ust.y) < 0.) wgReg = k;\n    }\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n    autoMod = 0.;\n    tMan = tCur;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel < 0) {\n    if (mPtr.z > 0.) {\n      az += 0.07 * (1. - 0.85 * zmVar) * mPtr.x;\n      el += 0.07 * (1. - 0.85 * zmVar) * mPtr.y;\n    }\n  } else {\n    for (int k = 0; k < 2; k ++) {\n      if (wgSel == k) {\n        kSel = k;\n        vW = clamp (0.5 + 0.5 * (mPtr.y - wgBx[k].y) / wgBx[k].w, 0., 0.99);\n        break;\n      }\n    }\n    if (kSel == 0) zmVar = vW;\n    else if (kSel == 1) reflFac = vW;\n  }\n  if (autoMod == 1.) {\n    az = mod (az + 0.13 * (tCur - tCurP), 2. * pi);\n    el = mod (el + 0.1 * (tCur - tCurP), 2. * pi);\n    reflFac = SmoothBump (0.22, 0.78, 0.2, fract (0.03 * tCur));\n  } else if (tCur - tMan > 10.) {\n    autoMod = 1.;\n    tMan = tCur;\n  }\n  if (pxId == 0) stDat = vec4 (el, az, autoMod, tMan);\n  else if (pxId == 1) stDat = vec4 (mPtr.xyz, float (wgSel));\n  else if (pxId == 2) stDat = vec4 (zmVar, reflFac, tCur, 0.);\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtV3zy.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[882, 882, 904, 904, 1844], [1846, 1846, 1879, 1879, 2141], [2143, 2143, 2175, 2175, 2430], [2432, 2432, 2490, 2490, 3346], [3348, 3348, 3370, 3370, 3769], [3771, 3771, 3806, 3806, 4910], [4912, 4912, 4968, 4968, 5995], [5997, 5997, 6019, 6019, 6046], [6048, 6048, 6070, 6070, 6097], [6099, 6099, 6123, 6123, 6245], [6247, 6247, 6277, 6277, 6390], [6392, 6392, 6428, 6428, 6634], [6668, 6668, 6692, 6692, 6804], [6806, 6806, 6831, 6831, 7015], [7017, 7017, 7038, 7038, 7193], [7286, 7286, 7311, 7311, 7434]], "test": "untested"}
{"id": "flK3zy", "name": "Bloom 2", "author": "turboplay", "description": "Bloom ported from https://github.com/Oncorporation/obs-shaderfilter/", "tags": ["bloom"], "likes": 1, "viewed": 324, "published": 3, "date": "1637915056", "time_retrieved": "2024-07-30T18:45:56.029779", "image_code": " float Angle_Steps = 15.; //<range 1 - 20>\n float Radius_Steps = 9.; //<range 0 - 20>\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n float ampFactor = mod(iTime,10.f);\n\n  float radiusSteps = clamp(Radius_Steps, 0., 20.);\n\tfloat angleSteps = clamp(Angle_Steps, 1., 20.);\n\tfloat PI = 3.1415926535897932384626433832795;//acos(-1);\n\tfloat minRadius = (0.0 * uv.x);\n\tfloat maxRadius = (1.0 * uv.y);\n\n\tvec4 c0 = texture(iChannel0, uv);\n\tvec4 outputPixel = c0;\n\tvec4 accumulatedColor = vec4(0);\n\n\tfloat totalSteps = radiusSteps * angleSteps;\n\tfloat angleDelta = (2. * PI) / angleSteps;\n\tfloat radiusDelta = (maxRadius - minRadius) / radiusSteps;\n\n\tfor (float radiusStep = 0.; radiusStep < radiusSteps; radiusStep += 1.0) {\n\t\tfloat radius = minRadius + radiusStep * radiusDelta;\n\n\t\tfor (float angle=0.; angle <(2.*PI); angle += angleDelta) {\n\t\t\tvec2 currentCoord;\n\n\t\t\tfloat xDiff = radius * cos(angle);\n\t\t\tfloat yDiff = radius * sin(angle);\n\t\t\t\n\t\t\tcurrentCoord = uv + vec2(xDiff, yDiff);\n\t\t\tvec4 currentColor = texture(iChannel0, currentCoord);\n\t\t\tfloat currentFraction = ((radiusSteps+1. - radiusStep)) / (radiusSteps + 1.);\n\n\t\t\taccumulatedColor +=   currentFraction * currentColor / totalSteps;\n\t\t\t\n\t\t}\n\t}\n\n\toutputPixel += accumulatedColor * ampFactor;\n\n\tfragColor= outputPixel;\n    \n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flK3zy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 145, 195, 1383]], "test": "untested"}
{"id": "ftK3zy", "name": "Weird mix", "author": "turboplay", "description": "A weird mix, imported from https://github.com/Oncorporation/obs-shaderfilter/", "tags": ["burn", "effect"], "likes": 2, "viewed": 205, "published": 3, "date": "1637914636", "time_retrieved": "2024-07-30T18:45:56.813683", "image_code": "\n\nvec4 mod289(vec4 x)\n{\n\treturn x - floor(x / 289.0) * 289.0;\n}\nvec4 permute(vec4 x)\n{\n\treturn mod289(((x * 34.0) + 1.0) * x);\n}\nvec4 taylorInvSqrt(vec4 r)\n{\n\treturn vec4(1.79284291400159 - r * 0.85373472095314);\n}\nvec2 fade(vec2 t) {\n\treturn t * t* t* (t * (t * 6.0 - 15.0) + 10.0);\n}\n\n\n// Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n\tvec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n\tvec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n\tPi = mod289(Pi); // To avoid truncation effects in permutation\n\tvec4 ix = Pi.xzxz;\n\tvec4 iy = Pi.yyww;\n\tvec4 fx = Pf.xzxz;\n\tvec4 fy = Pf.yyww;\n\tvec4 i = permute(permute(ix) + iy);\n\tvec4 gx = fract(i / 41.0) * 2.0 - 1.0;\n\tvec4 gy = abs(gx) - 0.5;\n\tvec4 tx = floor(gx + 0.5);\n\tgx = gx - tx;\n\tvec2 g00 = vec2(gx.x, gy.x);\n\tvec2 g10 = vec2(gx.y, gy.y);\n\tvec2 g01 = vec2(gx.z, gy.z);\n\tvec2 g11 = vec2(gx.w, gy.w);\n\tvec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n\tg00 *= norm.x;\n\tg01 *= norm.y;\n\tg10 *= norm.z;\n\tg11 *= norm.w;\n\tfloat n00 = dot(g00, vec2(fx.x, fy.x));\n\tfloat n10 = dot(g10, vec2(fx.y, fy.y));\n\tfloat n01 = dot(g01, vec2(fx.z, fy.z));\n\tfloat n11 = dot(g11, vec2(fx.w, fy.w));\n\tvec2 fade_xy = fade(Pf.xy);\n\tvec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n\tfloat n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n\treturn 2.3 * n_xy;\n}\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec2 P, vec2 rep)\n{\n\tvec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n\tvec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n\tPi = mod(Pi, rep.xyxy); // To create noise with explicit period\n\tPi = mod289(Pi);        // To avoid truncation effects in permutation\n\tvec4 ix = Pi.xzxz;\n\tvec4 iy = Pi.yyww;\n\tvec4 fx = Pf.xzxz;\n\tvec4 fy = Pf.yyww;\n\tvec4 i = permute(permute(ix) + iy);\n\tvec4 gx = fract(i / 41.0) * 2.0 - 1.0;\n\tvec4 gy = abs(gx) - 0.5;\n\tvec4 tx = floor(gx + 0.5);\n\tgx = gx - tx;\n\tvec2 g00 = vec2(gx.x, gy.x);\n\tvec2 g10 = vec2(gx.y, gy.y);\n\tvec2 g01 = vec2(gx.z, gy.z);\n\tvec2 g11 = vec2(gx.w, gy.w);\n\tvec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n\tg00 *= norm.x;\n\tg01 *= norm.y;\n\tg10 *= norm.z;\n\tg11 *= norm.w;\n\tfloat n00 = dot(g00, vec2(fx.x, fy.x));\n\tfloat n10 = dot(g10, vec2(fx.y, fy.y));\n\tfloat n01 = dot(g01, vec2(fx.z, fy.z));\n\tfloat n11 = dot(g11, vec2(fx.w, fy.w));\n\tvec2 fade_xy = fade(Pf.xy);\n\tvec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n\tfloat n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n\treturn 2.3 * n_xy;\n}\n\n\n\n float Speed = 0.33;\n float Gradient_Adjust = 0.85;\n float Dissolve_Value = 1.43;\n bool Animated;\n bool Apply_to_Channel;\n bool Apply_Smoke = true;\n float Smoke_Horizonal_Speed = 0.3;\n float Smoke_Vertical_Speed = 0.17;\n int Iterations = 4;\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0,uv);\n    \n    vec4 color = fragColor;//image.Sample(textureSampler, v_in.uv);\n\tvec4 smoke = vec4(1.0,1.0,1.0,1.0);\n\tvec4 result = smoke;\n\tfloat t = iTime * Speed;\n\tfloat cycle = 1. - max((sin(t) * 2.) - 1., 0.); //create a negative cycle time as a delay\n\tvec2 dir = vec2(Smoke_Horizonal_Speed, Smoke_Vertical_Speed);\n\t//float largestDistance = sqrt(pow(uv_size.x, 2) + pow(uv_size.y, 2));\n\n\tfloat perlin = 0.5;\n\tfloat smoke_perlin = 0.;\n\tfloat scale = 1.;\n\tfloat w = 0.5;\t\n\n\tfor (int i = 0; i < Iterations; i++) {\n\t\t//vec2 coord = v_in.uv * scale;// (v_in.uv + t * dir)* scale;\n\t\tvec2 coord = (uv + t * (dir * .1)) * scale;\n\t\tvec2 period = scale * dir;\n\t\tperlin += pnoise(coord, period) * w;\n\t\tif (Apply_Smoke)\n\t\t\tsmoke_perlin += cnoise((uv + t * dir) * scale) * w * .5;\n\n\t\tscale *= 2.0;\n\t\tw *= 0.5;\n\t}\n\n\t//float toPoint = abs(length(v_in.uv - (v_in.uv * .5)) / ((1.0001 - t) * largestDistance));\n\tif (!Animated)\n\t\tcycle = 1.;\n\tfloat d = clamp(((Dissolve_Value * cycle + perlin) ) - 1.0, -.01, 0.99);\n\tfloat overOne = clamp(d * Gradient_Adjust,0.,1.);\n\tvec4 burn = texture(iChannel1, vec2(overOne, 0.5));\n\n\tif (Apply_to_Channel) {\n\t\tresult =  color * burn;\n\t}\n\telse {\n\t\tresult = vec4(perlin, perlin, perlin, 1.0) * burn;\n\t}\t\n\n\tif (smoke_perlin > 0.) {\n\t\tsmoke *= smoke_perlin;\n\t\tif (result.a <= 0.04)\n\t\t\tresult = vec4(smoke.rgb, smoke_perlin);\n\t\tresult += smoke;\n\t}\n\n\tfragColor= result;\n    \n    \n}\n\n\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftK3zy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 23, 23, 63], [64, 64, 86, 86, 128], [129, 129, 157, 157, 214], [215, 215, 234, 234, 285], [288, 312, 334, 334, 1327], [1328, 1370, 1402, 1402, 2467], [2715, 2715, 2772, 2822, 4320]], "test": "untested"}
{"id": "NtV3zG", "name": "false ladder", "author": "jorge2017a2", "description": "false ladder", "tags": ["false", "ladder"], "likes": 5, "viewed": 234, "published": 3, "date": "1637896843", "time_retrieved": "2024-07-30T18:45:57.579635", "image_code": "///------------image\n//por jorge2017a1-\n//an unsuccessful attempt to do something else .... uppsss\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvec3 EscaleraTorre(vec3 p)\n{\n    vec3 res= vec3(9999.0, -1.0,-1.0);\n    float d1, d=99999.0;\n    int y;\n    float AnchoTot=4.0;\n    float AltoTot=6.0;\n    float NumEs=8.0;\n    \n    float AnchoEs=AnchoTot/NumEs;\n    float AltoEs=AltoTot/NumEs;\n    float AltoEsNew;\n    \n    for(int i=1;i<=int(NumEs);i++ )\n     {   \n      float posx=float(i)*AnchoEs*2.0;\n      float posy=-float(i)*AltoEs*2.0;\n      AltoEsNew=AltoTot-( float(i)- 1.0)*AltoEs ;\n      float d1=sdBox(p-vec3(posx,posy/2.0-AltoEsNew,0.0), vec3(AnchoEs,AltoEs+AltoEsNew,2.0) );\n      d=min(d,d1);\n     }   \n    res =opU3(res, vec3(d,1.0,-1.0)); //inf\n    return res;\n}\n\n\nvec3 TresEscalones(vec3 p)\n{\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    vec3 res1a= EscaleraTorre(p.yzx-vec3(0.0,0.0,0.0));\n    vec3 res2a= EscaleraTorre(p.yzx-vec3(0.0,13.5,0.0));\n    vec3 res3a= EscaleraTorre(p.yzx-vec3(0.0,27.0,0.0));\n    res =opU3(res, res1a);\n    res =opU3(res, res2a);\n    res =opU3(res, res3a);\n    \nreturn res;\n}\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    p.y-=10.0;\n    vec3 p0=p;\n\tfloat planeDist1 = p.y+10.0;  //piso inf\n    p.x=abs(p.x)-10.0;\n    p.z=abs(p.z)-15.0;\n    vec3 res4= TresEscalones(p);\n\n    res =opU3(res, res4);\n  \n    vec3 p1=p0-vec3(0.0,0.0,0.0);\n    vec3 p2=p0-vec3(0.0,0.0,-11.5);\n    p1.z=opRep1D(p1.z,23.0 );\n    p2.z=opRep1D(p2.z,23.0 );\n    float d1= sdRoundBox(p1, vec3(15.0,0.5,5.0), 0.5 );\n    float d2= sdRoundBox(p2, vec3(15.0,0.5,5.0), 0.5 );\n    res =opU3(res, vec3(d1,2.0,-1.0));\n    res =opU3(res, vec3(d2,3.0,-1.0));\n\n    //return (dist, id_color, id_material)\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 nor = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    nor= normalize(nor);\n    return nor;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n        {mObj.hitbln = true; minDist = abs(t); break;}\n        \n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        t += dS.x;\n        marchCount++;\n    }\n\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{   vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true)\n        {fshadow=GetShadow(p,lp);}\n    else\n        {fshadow=0.5;}\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    lin += 0.4*pow(clamp(dot(hal,n),0.0,1.0),12.0)*dif3;\n    lin *= atten*0.5*col*fshadow;\n    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    lin = pow(lin,vec3(0.4545));\n \n    return lin;\n    //return lin*atten*(1.0/2.0);\n    \n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj;\n    if( mObj.hitbln==false) return  render_sky_color(rd);    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    return colobj;\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;mObj.ro=ro;\n   vec3 p;\n\n   float d=RayMarch(ro,rd, MAX_STEPS);\n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvec3 linear2srgb(vec3 c) {\n    return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*5.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(10.0, 30.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 30.0, -10.0 ); light_color2 =vec3( 1.0 ); \n \n   float pz=mod(t,25.0);\n   vec3 ro=vec3(0.0,15.0,-50.0+pz);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd.xz=rotatev2(rd.xz, clamp( sin(t*0.25),-PI/2.0,PI/2.0) );\n\n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    col = linear2srgb(col);    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "//--------------common\n///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtV3zG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[544, 544, 576, 576, 660], [661, 661, 707, 707, 794], [796, 840, 887, 887, 914], [915, 915, 958, 958, 985], [986, 986, 1034, 1034, 1062], [1063, 1101, 1137, 1137, 1182], [1183, 1223, 1257, 1257, 1352], [1986, 1986, 2014, 2014, 2319], [2321, 2321, 2346, 2346, 2944], [2946, 2946, 2970, 2970, 3150], [3152, 3152, 3201, 3201, 3839], [3841, 3841, 3877, 3877, 4122], [4124, 4124, 4151, 4151, 4168], [4170, 4170, 4206, 4206, 4298], [4299, 4299, 4345, 4345, 4470], [4472, 4472, 4546, 4546, 6145], [6147, 6147, 6227, 6227, 6350], [6352, 6352, 6384, 6384, 6581], [6583, 6583, 6676, 6676, 6835], [6837, 6837, 6868, 6868, 7449], [7451, 7451, 7477, 7477, 7578], [7579, 7579, 7637, 7637, 7689], [7692, 7692, 7749, 7749, 8377]], "test": "untested"}
{"id": "NlKGRG", "name": "More log polar junk", "author": "SnoopethDuckDuck", "description": "bad code, dont really like this one", "tags": ["e"], "likes": 8, "viewed": 248, "published": 3, "date": "1637888696", "time_retrieved": "2024-07-30T18:45:58.348579", "image_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    float pe = 100.;\n    //uv = floor(pe * uv)/pe + 0.;\n    uv.y += 0.02 * cos(10. * uv.x + iTime);\n\n    float a = atan(uv.y, uv.x);\n    float r = length(uv);\n\n    uv = vec2(2. * a, log(r));\n    uv = uv.y * vec2(thc(2., uv.x), ths(2., uv.x));\n    \n    \n    float sc = 1.;\n     vec2 ipos = vec2(floor(0. * iTime + sc * uv.x) + 0.5,\n                      floor( 0.25 * iTime + 2. * sc * uv.y) + 0.5);\n    \n    \n    \n    vec2 fpos = vec2(fract(0. * iTime + sc * uv.x) - 0.5,\n                     fract( 0.3 * iTime + 2. * sc * uv.y) - 0.5);\n    \n    //fpos.y += 0.2 * cos(8.* fpos.x + 10. * h21(ipos) + iTime);\n    float k = 0.6 + 0.4 * thc(0.1, cos(0. * h21(ipos) + 8. * r -5.* a- iTime) + 2. * a - 1.2 * iTime);\n   \n    float d = (2. + thc(4., k + r * 10. - iTime)) * length(fpos) * length(fpos);// + (0.5 + thc(2., 101. * h21(ipos) + iTime));\n    float s = 1.2 * (1.-mlength(fpos)) * smoothstep(-0.5,0.5, 0.45-d);// - step(0.46, mlength(fpos));\n    s = smoothstep(-k, k, \n        -d + 0.32 + 0.1 * thc(4., -iTime + log(r) + 2. * a));\n    vec3 col = vec3(s);\n    vec3 col2 =  pal(k +  - 0.8 * iTime + s * 0.002 * iTime, vec3(1.), vec3(1.), vec3(0.4), log(r) * vec3(0.,0.33,0.66));\n    float s2 = 0.5 + 0.5 * thc(1., 1.5 * thc(2., 8. * s - iTime));\n    col = mix(col, col2, vec3(s2));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlKGRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 49, 49, 90], [92, 92, 121, 121, 162], [164, 164, 191, 191, 232], [234, 234, 261, 261, 302], [304, 304, 372, 372, 415], [417, 417, 437, 437, 512], [514, 514, 538, 538, 578], [580, 580, 637, 637, 2038]], "test": "untested"}
{"id": "slyGzy", "name": "Salad Dressing", "author": "wyatt", "description": "Happy Thanksgiving", "tags": ["particles"], "likes": 29, "viewed": 420, "published": 3, "date": "1637883393", "time_retrieved": "2024-07-30T18:45:59.125502", "image_code": "// Fork of \"SandStorm\" by wyatt. https://shadertoy.com/view/flt3Wr\n// 2021-11-25 22:28:42\n\n// Display 🦜\nMain {\n    vec4 b = B(U);\n    vec4 n = B(U+vec2(0,1));\n    vec4 e = B(U+vec2(1,0));\n    vec4 s = B(U-vec2(0,1));\n    vec4 w = B(U-vec2(1,0));\n    b = 1./4.*(n+e+s+w);\n    Q = 1.-1.4*b*vec4(1.1,1,1.3,1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define ei(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define Z .73\n#define M .125\nvec3 hash(vec3 p3)\n    {\n        p3 = fract(p3 * vec3(.1031, .1030, .0973));\n        p3 += dot(p3, p3.yxz+33.33);\n        return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n    }\n    ", "buffer_a_code": "// Translate Particles 🚗\nMain {\n    Q = vec4(0);\n    vec4 QB = vec4(0);\n    for (float x=-2.;x<=2.;x++)\n    for (float y=-2.;y<=2.;y++)\n    {\n          vec2 xy = vec2(x,y);\n          vec4 b = B(U+xy);\n          if (b.w>0.) {\n              vec4 a = A(U+xy);\n              \n              vec4 _1 = a, _2 = a;\n              mat2 m = ei(6.2*hash(vec3(U+xy,iTime)).x);\n              if (b.w>M) {\n                  vec2 v = vec2(0,Z)*m;\n                  _2.xy -= v;\n                  _1.xy += v;\n              }\n              if (_1.x<U.x+.5&&_1.x>=U.x-.5&&\n                  _1.y<U.y+.5&&_1.y>=U.y-.5){\n                  Q += .5*b.w*_1;\n                  QB.w += .5*b.w; \n              }\n              if (_2.x<U.x+.5&&_2.x>=U.x-.5&&\n                  _2.y<U.y+.5&&_2.y>=U.y-.5){\n                  Q += .5*b.w*_2;\n                  QB.w += .5*b.w;\n              }\n         }\n    }\n    if (QB.w >0.) Q /= QB.w;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Translate Particles 🚗\nMain {\n    Q = vec4(0);\n    vec4 QB = vec4(0);\n    for (float x=-2.;x<=2.;x++)\n    for (float y=-2.;y<=2.;y++)\n    {\n          vec2 xy = vec2(x,y);\n          vec4 b = B(U+xy);\n          if (b.w>0.) {\n              vec4 a = A(U+xy);\n              \n              vec4 _1 = a, _2 = a;\n              mat2 m = ei(6.2*hash(vec3(U+xy,iTime)).x);\n              if (b.w>M) {\n                  vec2 v = vec2(0,Z)*m;\n                  _2.xy -= v;\n                  _1.xy += v;\n              }\n              if (_1.x<U.x+.5&&_1.x>=U.x-.5&&\n                  _1.y<U.y+.5&&_1.y>=U.y-.5){\n                  Q += .5*b.w*_1;\n                  QB.xyz += .5*b.w*b.xyz;\n                  QB.w += .5*b.w; \n              }\n              if (_2.x<U.x+.5&&_2.x>=U.x-.5&&\n                  _2.y<U.y+.5&&_2.y>=U.y-.5){\n                  Q += .5*b.w*_2;\n                  QB.xyz += .5*b.w*b.xyz;\n                  QB.w += .5*b.w;\n              }\n         }\n    }\n    Q = QB;\n    if (QB.w>0.)Q.xyz/=QB.w;\n}", "buffer_b_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Force 🌊\nMain {\n    Q = A(U);\n    vec4 QB = B(U);\n    vec2 f = vec2(0);\n    if (QB.w>0.)\n    {\n        \n        for (float x = -2.;x<=2.;x++)\n        for (float y = -2.;y<=2.;y++)\n        if (x!=0.&&y!=0.)\n        {\n              vec2 xy = vec2(x,y);\n              vec4 b = B(U+xy);\n              f.xy -= 0.1*b.z*b.w*length(sign(b.xyz-.5)-sign(QB.xyz-.5))*xy/dot(xy,xy);\n              f.xy -= 0.01*b.w*(b.w-3.*b.y)*xy/dot(xy,xy);\n         }\n        Q.zw += QB.x*f.xy/QB.w;//-1e-*Q.zw;\n        Q.xy += Q.zw*.5*inversesqrt(\n                1.+dot(Q.zw,Q.zw));\n    }\n    Q.w -= .02/R.y;\n    \n                \n    if (Q.x<2.)Q.z=abs(Q.z),Q.x=2.;\n    if (Q.y<2.)Q.w=abs(Q.w),Q.y=2.;\n    if (R.x-Q.x<3.)Q.z=-abs(Q.z),Q.x=R.x-3.;\n    if (R.y-Q.y<3.)Q.w=-abs(Q.w),Q.y=R.y-3.;\n    if (iMouse.z>0.&&length(U.xy-iMouse.xy)<10.)\n        Q = vec4(U+vec2(.5,0),.25,0);\n    \n    if (iFrame < 1) \n        Q = vec4(U,0,0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Color 🌈\nMain {\n    Q = B(U);\n    if (iMouse.z>0.&&length(U.xy-iMouse.xy)<10.)\n        Q=.5+.5*sin(iTime+vec4(1,2,3,4)),\n        Q.w = 1.;\n    if (iFrame < 1) {\n        Q = max(.5-.5*sin(U.y/R.y*40.+vec4(1,2,3,4)),0.);\n        Q.w = step(U.y,.5*R.y);\n    }\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slyGzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "stG3Ry", "name": "I dont know what this is", "author": "SnoopethDuckDuck", "description": "dont stare at it for too long or you'll feel dizzy", "tags": ["e"], "likes": 11, "viewed": 417, "published": 3, "date": "1637881123", "time_retrieved": "2024-07-30T18:45:59.953288", "image_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 ouv = uv;\n    \n    \n    float v = 0.;\n    float n = 6.;\n    \n    for (float i = 0.; i<n; i++) {\n        float f = pow(0.5, i) * thc(4.,i * 10. * length(uv) + iTime) + i/n;\n        v += 0.5 * f * cosh(2. * thc(4., 2. * pi + iTime) + 1.1 * length(uv));\n    }\n    // */\n    uv /= v;\n    uv /= cosh(0.8 * thc(4., iTime) + 1.1 * length(uv));\n    uv /= -0.6 + cosh(0.4 * ths(4., 1. * iTime) + 1.1 * length(uv));\n    \n    float a = atan(uv.y, uv.x);\n    float r = length(uv);\n       \n\n    uv.x = 1. * a + 0.15 * iTime;\n    uv.y = log(r);\n\n    uv = uv.y * vec2(thc(2., uv.x), ths(2., uv.x));\n\n    //a = atan(uv.y, uv.x);\n    //r = length(uv);\n    \n    //uv.x = r;\n    //uv.y = r;\n\n    float sc = 2. + thc(1., 18. * r + a + iTime);\n    vec2 ipos = floor(sc * uv) + 0.5;\n    vec2 fpos = fract(sc * uv) - 0.5;\n    \n    float d = mlength(fpos);\n    float s = 1.-smoothstep(-0.05,0.05, 0.47-d);\n    s *= s * s * 1.5;\n //   s += step(d,0.1);\n    //s *= thc(4., 3. * s + iTime) ;\n\n    //vec3 col = vec3(s);\n    vec3 col = s * pal(r * 10. + 0.8 * iTime, vec3(1.), vec3(1.), vec3(1.), vec3(0.,0.33,0.66));\n    col += clamp(pow(4. * (1.-r) * r,2.),0.,1.);\n    //col *= 20.;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stG3Ry.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 49, 49, 90], [92, 92, 121, 121, 162], [164, 164, 191, 191, 232], [234, 234, 261, 261, 302], [304, 304, 372, 372, 415], [417, 417, 437, 437, 512], [514, 514, 538, 538, 578], [580, 580, 637, 637, 1919]], "test": "untested"}
{"id": "7ty3zG", "name": "connected components in truchets", "author": "FabriceNeyret2", "description": "Find the connected component.  \nMight be accelerated by using a table of equivalent values rather than directly propagating.\n\nclick to restart a new truchet tiling.  Scale N in Common (try 80) .\n\"infinite\" tiling: comment BuffA:17 & set 1.*Time in Image:5", "tags": ["flood", "short", "connected", "truchets"], "likes": 28, "viewed": 459, "published": 3, "date": "1637880316", "time_retrieved": "2024-07-30T18:46:00.738190", "image_code": "#define hue(v)  vec4( .6 + .6 * cos( .5+(v)  + vec3(0,23,21)  ) , 1 )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = N * u / R.y + 0.*iTime, I = floor(U), F = fract(U);\n         \n    O = T(I);                                          // cell states \n    O.w > 0. ? F = vec2(1.-F.y,F.x) : F;\n    \n    O =   smoothstep(N*1.5/R.y,0.,abs(min(length(F),length(1.-F))-.5) - .1 ) // truchet drawing\n        * hue( O[ F.x+F.y < 1. ? 1 : 2 ] );            // coloring\n         \n // if (iMouse.z>0.) O += (1.-O.w)*.3*mod(I.x+I.y,2.); // debug: draw tiles\n // O += .3*T(I).w;\n} ", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//#define H(p)  mod(p.x+p.y,2.)\n  #define H(p)  fract(sin(dot(p, vec2(12.9898, 78.233))-iTime) * 43758.5453)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    if ( iFrame < 1 || iMouse.z>0.) {         // --- init: create truchet\n        vec2 I = u-.5;                        // store truchet data\n        O.w = step(.5,H(I));                  // random axis\n     // if (u.x > N*R.x/R.y || u.y > N) { O.yz = vec2(0); return; }\n        O.y = 1.+I.x+4096.*I.y;               // id of tile segment #1\n        O.z = -O.y;                           // id of tile segment #2\n        return;\n    }\n    \n    u -= .5;\n    O = T(u);                                 // previous state\n    if (u.x > N*R.x/R.y || u.y > N) return;   // propagate only visible tiles\n    \n                                              // --- propagate id along connections\n#define left(T)    T.y\n#define right(T)   T.z\n#define bot(T)   ( T.w<1. ? T.y : T.z )\n#define top(T)   ( T.w<1. ? T.z : T.y )\n    if (O.w<1.) { // tile contains:  \\     new id = min(connections)\n        O.y = min( O.y, min( right(T(u-vec2(1,0))), top(T(u-vec2(0,1))) ));\n        O.z = min( O.z, min( left (T(u+vec2(1,0))), bot(T(u+vec2(0,1))) ));\n    }\n    else {        // tile contains:  /     new id = min(connections)\n        O.y = min( O.y, min( right(T(u-vec2(1,0))), bot(T(u+vec2(0,1))) ));\n        O.z = min( O.z, min( left (T(u+vec2(1,0))), top(T(u-vec2(0,1))) ));\n    }\n} ", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float N = 30.; // vertical number of tiles\n\n#define R    iResolution.xy\n#define T(U) texelFetch( iChannel0, ivec2(U), 0 )", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ty3zG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 109, 109, 572]], "test": "untested"}
{"id": "7ty3RG", "name": "Baryquadratic Interpolation (2D)", "author": "paniq", "description": "Performing barycentric quadratic interpolation orthogonally. Left: bilinear interpolation, Right: baryquadratic interpolation. Bottom: first derivative.\nInspired by the Cendes-Wong algorithm. ", "tags": ["barycentric", "quadratic", "interpolation"], "likes": 28, "viewed": 642, "published": 3, "date": "1637875213", "time_retrieved": "2024-07-30T18:46:01.602878", "image_code": "\n// this code is in the public domain\n\nvec4 sample_baryquadratic_2d(sampler2D channel, vec2 res, vec2 uv) {\n    vec2 pixelpos = uv * res;\n    vec2 q = fract(pixelpos);\n    ivec2 t = ivec2(pixelpos);\n    ivec2 ires = ivec2(res);\n    ivec3 e = ivec3(-1, 0, 1);\n    vec4 s00 = texelFetch(channel, (t + e.xx) % ires, 0);\n    vec4 s01 = texelFetch(channel, (t + e.xy) % ires, 0);\n    vec4 s02 = texelFetch(channel, (t + e.xz) % ires, 0);\n    vec4 s10 = texelFetch(channel, (t + e.yx) % ires, 0);\n    vec4 s11 = texelFetch(channel, (t + e.yy) % ires, 0);\n    vec4 s12 = texelFetch(channel, (t + e.yz) % ires, 0);\n    vec4 s20 = texelFetch(channel, (t + e.zx) % ires, 0);\n    vec4 s21 = texelFetch(channel, (t + e.zy) % ires, 0);\n    vec4 s22 = texelFetch(channel, (t + e.zz) % ires, 0);\n    \n    vec4 c00 = (s00 + s01 + s10 + s11) / 4.0;\n    vec4 c10 = (s10 + s11 + s20 + s21) / 4.0;\n    vec4 c01 = (s01 + s02 + s11 + s12) / 4.0;\n    vec4 c11 = (s11 + s12 + s21 + s22) / 4.0;\n    \n    vec4 e10 = (s11 + s10) / 2.0;\n    vec4 e01 = (s11 + s01) / 2.0;\n    vec4 e12 = (s11 + s12) / 2.0;\n    vec4 e21 = (s11 + s21) / 2.0;\n    \n    vec4 m00 = (e10 + e01) / 2.0;\n    vec4 m10 = (e10 + e21) / 2.0;\n    vec4 m01 = (e12 + e01) / 2.0;\n    vec4 m11 = (e12 + e21) / 2.0;\n    \n    vec4 u0 = (m00 + m10 + m01 + m11) / 4.0;\n    vec3 w;\n    vec2 qa = abs(q-0.5);\n    bool x_dominant = qa.x >= qa.y;\n    vec2 d = x_dominant?q.xy:q.yx;\n    float s = sign(d.x - 0.5);\n    bool d_pos = (d.x >= 0.5);    \n    bool lower_right = (x_dominant == d_pos);\n    vec4 u1 = lower_right?c10:c01;\n    vec4 u2 = d_pos?c11:c00;\n    vec4 m0 = (x_dominant?(d_pos?e21:e01):(d_pos?e12:e10));\n    vec4 m1 = d_pos?m11:m00;\n    vec4 m2 = lower_right?m10:m01;\n    w.x = 1.0 - abs(d.x - 0.5)*2.0;\n    w.y = (d.x - d.y)*s;\n    w.z = (q.x + q.y - 1.0)*s;\n    vec3 m = 2.0*vec3(w.y*w.z, w.x*w.z, w.x*w.y);\n    w = w*w; \n    return vec4(\n        dot(w, vec3(u0.x, u1.x, u2.x)) + dot(m, vec3(m0.x, m1.x, m2.x)),\n        dot(w, vec3(u0.y, u1.y, u2.y)) + dot(m, vec3(m0.y, m1.y, m2.y)),\n        dot(w, vec3(u0.z, u1.z, u2.z)) + dot(m, vec3(m0.z, m1.z, m2.z)),\n        dot(w, vec3(u0.w, u1.w, u2.w)) + dot(m, vec3(m0.w, m1.w, m2.w)));\n}\n\nvec2 sample_baryquadratic_2d_gradient(sampler2D channel, vec2 res, vec2 uv) {\n    // the field can be made smoother by choosing a higher epsilon value\n    vec2 eps = vec2(1e-5, 0.0);\n    return vec2(\n        sample_baryquadratic_2d(channel, res, uv + eps.xy).x - sample_baryquadratic_2d(channel, res, uv - eps.xy).x,\n        sample_baryquadratic_2d(channel, res, uv + eps.yx).x - sample_baryquadratic_2d(channel, res, uv - eps.yx).x) / (2.0*eps.x*res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n    \n    float h = uv.x;\n    float w = uv.y;\n    \n    uv += iTime * 0.2;\n    uv /= 30.0;\n\n    vec4 col;\n    vec2 n;\n    if (h < 0.0) {\n    \tcol = texture(iChannel0, uv).rrrr;\n        n = vec2(dFdx(col.r), dFdy(col.r)) * iResolution.y / 16.0;\n    } else {\n        col = sample_baryquadratic_2d(iChannel0, iChannelResolution[0].xy, uv).rrrr;\n        n = vec2(dFdx(col.r), dFdy(col.r)) * iResolution.y / 16.0;\n        if (h > 0.9) {            \n            n = sample_baryquadratic_2d_gradient(iChannel0, iChannelResolution[0].xy, uv);\n        }\n    }\n    float ph = sin(iTime * 0.1);\n    n = mix(n, normalize(n), ph*ph);\n    if (w > -0.5) {\n        fragColor = col;\n    } else {\n        fragColor = vec4(n*0.5+0.5, 0.0, 1.0);\n    }\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ty3RG.jpg", "access": "api", "license": "public-domain", "functions": [[39, 39, 107, 107, 2178], [2180, 2180, 2257, 2330, 2634], [2636, 2636, 2693, 2693, 3537]], "test": "untested"}
{"id": "flG3zy", "name": "morphological skeleton 2", "author": "FabriceNeyret2", "description": "For shape characterization. Easy to get with a SDF. Not sure how to use. \nhttps://en.wikipedia.org/wiki/Morphological_skeleton\nhttps://en.wikipedia.org/wiki/Topological_\nexample : [url]https://www.google.com/search?q=Morphological_skeleton&&tbm=isch[/url]", "tags": ["gradient", "valley", "medialaxis", "ridge", "morphologicalmathematics", "topologicalskeleton"], "likes": 15, "viewed": 400, "published": 3, "date": "1637858752", "time_retrieved": "2024-07-30T18:46:02.467566", "image_code": "// variant of https://shadertoy.com/view/flG3Ry\n\n// === morphological skeleton. =============================\n//     also named topological skeleton or medial axis.\n// to get the ridge of SDF ( i.e. valley ), we seek for the max variation of the SDF gradient \n\nfloat z = 4./360.;                     // characters size\n\nvoid mainImage( out vec4 O, vec2 U ) {\n    if (iMouse.z>0.) z /= .5 + 4.*iMouse.y/iResolution.y; // mouse zoom\n    U *= z;\n         \n #define T(U)   texture(iChannel0, ( U + mod(iTime/vec2(1,16.),16.) ) / 16.)\n #define Tc(U)  T(U) * step(T(U).w,.51) // clamp SDF to mask + epsilon\n                           // SDF\n    O = Tc(U) + Tc(U+8.5);              // lost space: insert more chars\n \n    O = O.x - length(fwidth(O.yz))/z/50. * vec4(0,1,1,0);\n     // mask                SDF gradient\n             // max on the ridge of SDF gradient ( = skeleton )\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flG3zy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[320, 320, 358, 358, 874]], "test": "untested"}
{"id": "NlG3zy", "name": "Circle with outline", "author": "MineGame159", "description": "Simple shader to a circle with an outline. Both are optional.", "tags": ["circle", "outline"], "likes": 2, "viewed": 495, "published": 3, "date": "1637858250", "time_retrieved": "2024-07-30T18:46:03.340233", "image_code": "// Parameters\nconst vec4 fillColor = vec4(0.0, 1.0, 0.0, 1.0);\nconst vec4 outlineColor = vec4(0.9, 0.9, 0.9, 1.0);\n\nconst bool fill = true;\nconst bool outline = true;\n\nconst float outlineSize = 16.0;\n\n#define radius iResolution.y / 2.0\n\n// Main function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / min(iResolution.x, iResolution.y) * 2.0;\n    \n    float distance = 1.0 - length(uv);\n    float fade = 1.0 / (radius * 0.5);\n    float outlineSize2 = outlineSize * (1.0 / (radius));\n    \n    // Fill\n    if (fill) {\n        float a;\n        if (outline) a = step(outlineSize2, distance);\n        else a = smoothstep(0.0, outline ? fade + outlineSize2 : fade, distance);\n\n        fragColor = fillColor * a;\n    }\n    \n    // Outline\n    if (outline) {\n        float a = smoothstep(0.0, fade, distance);\n        a *= smoothstep(outlineSize2 + fade, outlineSize2, distance);\n    \n        fragColor = mix(fragColor, outlineColor, a);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlG3zy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[237, 254, 309, 309, 996]], "test": "untested"}
{"id": "ftGGzy", "name": "walk 2d-n3", "author": "jorge2017a2", "description": "walk 2d-n3", "tags": ["walk2dn3"], "likes": 9, "viewed": 236, "published": 3, "date": "1637851432", "time_retrieved": "2024-07-30T18:46:04.222873", "image_code": "//por jorge2017a2....walk 2d-n3\n///referencia\n//https://iquilezles.org/articles/distfunctions2d\n//https://www.shadertoy.com/view/Xdy3Rd..... bmontell\n//https://www.shadertoy.com/view/wtdBzf-----oneshade \n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(1.0),b,d)\n\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n//oneshade\nvec2 RotatePOA(in vec2 p, in vec2 o, in float a) {\n    float c = cos(a), s = sin(a);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\nvec2 cossin(float x)\n{\treturn vec2(cos(x),sin(x));  }\n\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  //colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.5,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj-0.05,0.0)); return colOut; }\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{  vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec3 hacerPiernaIzq(vec2 p, float t, vec3 colOut,vec3 colIn)\n{   vec2 a1=vec2(3.0,8.0);vec2 b1=vec2(3.0,5.0);  //pierna\n    vec2 a2=vec2(3.0,5.0);vec2 b2=vec2(3.0,2.0); //rodilla\n    vec2 a3=vec2(3.0,2.0);vec2 b3=vec2(4.0,2.0); //pie\n\n    float t1, t2, t3;\n    float r1, r2, r3;\n\n   r1=0.6; r2=0.8; r3=0.2;    \n   t1=t;\n   t2=(1.0 + sin(t+PI));//t+TWO_PI;\n   t3=(1.0 + sin(t+PI));\n\n    float ang1=r1*sin(t1);\n    float ang2=r2*sin(t2);\n    float ang3=r3*sin(t3);\n\n    vec2 p1,p2, p3;\n    p1=RotatePOA(p,a1,ang1);\n    p2=RotatePOA(p1,a2,ang2);\n    p3=RotatePOA(p2,a3,ang3);\n\n    float d1= sdSegment(p1,a1,b1);\n    float d2= sdSegment(p2,a2,b2);\n    float d3= sdSegment(p3,a3,b3);\n\n    colOut= DrawFig(vec3(0.0,1.0,0.0), colOut,d1 );\n    colOut= DrawFig(vec3(1.0,0.0+colIn.g,0.0+colIn.b), colOut,d2 );\n    colOut= DrawFig(vec3(0.0,0.0,1.0), colOut,d3 );\n    return colOut;\n}\n\n\nvec3 hacerPiernaDer(vec2 p, float t, vec3 colOut,vec3 colIn)\n{   vec2 a1=vec2(3.0,8.0);vec2 b1=vec2(3.0,5.0);  //pierna\n    vec2 a2=vec2(3.0,5.0);vec2 b2=vec2(3.0,2.0); //rodilla\n    vec2 a3=vec2(3.0,2.0);vec2 b3=vec2(4.0,2.0); //pie\n\n    float t1, t2, t3;\n    float r1, r2, r3;\n\n  r1=0.6; r2=0.8; r3=0.2;    \n   t1=t;\n   t2=(1.0 + sin(t+PI)); //t+TWO_PI;\n   t3=(1.0 + sin(t+PI));\n\n    float ang1=r1*sin(t1);\n    float ang2=r2*sin(t2);\n    float ang3=r3*sin(t3);\n\n    vec2 p1,p2, p3;\n    p1=RotatePOA(p,a1,ang1);\n    p2=RotatePOA(p1,a2,ang2);\n    p3=RotatePOA(p2,a3,ang3);\n\n    float d1= sdSegment(p1,a1,b1);\n    float d2= sdSegment(p2,a2,b2);\n    float d3= sdSegment(p3,a3,b3);\n\n    colOut= DrawFig(vec3(0.0,1.0,0.0), colOut,d1 );\n    colOut= DrawFig(vec3(1.0,0.0+colIn.g,0.0+colIn.b), colOut,d2 );\n    colOut= DrawFig(vec3(0.0,0.0,1.0), colOut,d3 );\n    return colOut;\n}\n\n\nvec3 hacerBrazoIzq(vec2 p, float t, vec3 colOut,vec3 colIn)\n{   vec2 a1=vec2(3.0,12.0);vec2 b1=vec2(3.0,9.0);  //Brazo\n    vec2 a2=vec2(3.0,9.0);vec2 b2=vec2(3.0,6.0); //Ante brazo\n    float t1, t2, t3;\n    float r1, r2, r3;\n\n   r1=0.6; r2=0.8; r3=0.2;    \n   t1=t;\n   t2=t+TWO_PI;\n   t3=(1.0 + sin(t+PI));\n\n    float ang1=r1*sin(t1);\n    float ang2=r2*sin(t2);\n    float ang3=r3*sin(t3);\n\n    vec2 p1,p2, p3;\n    p1=RotatePOA(p,a1,ang1);\n    p2=RotatePOA(p1,a2,ang2);\n    \n    float d1= sdSegment(p1,a1,b1);\n    float d2= sdSegment(p2,a2,b2);\n    \n    colOut= DrawFig(vec3(0.0,1.0,0.0), colOut,d1 );\n    colOut= DrawFig(vec3(1.0,0.0+colIn.g,0.0+colIn.b), colOut,d2 );\n    return colOut;\n}\n\nvec3 hacerBrazoDer(vec2 p, float t, vec3 colOut,vec3 colIn)\n{   vec2 a1=vec2(3.0,12.0);vec2 b1=vec2(3.0,9.0);  //Brazo\n    vec2 a2=vec2(3.0,9.0);vec2 b2=vec2(3.0,6.0); //Ante brazo\n    \n    float t1, t2, t3;\n    float r1, r2, r3;\n\n   r1=0.6; r2=0.2; r3=0.2;    \n   t1=t;\n   t2=t+TWO_PI;\n   t3=(1.0 + sin(t+PI));\n\n    float ang1=r1*sin(t1);\n    float ang2=r2*sin(t2);\n    float ang3=r3*sin(t3);\n\n    vec2 p1,p2, p3;\n    p1=RotatePOA(p,a1,ang1);\n    p2=RotatePOA(p1,a2,ang2);\n    \n    float d1= sdSegment(p1,a1,b1);\n    float d2= sdSegment(p2,a2,b2);\n    \n    colOut= DrawFig(vec3(0.0+colIn.r,1.0,0.0+colIn.b), colOut,d1 );\n    colOut= DrawFig(vec3(1.0,0.0+colIn.g,0.0+colIn.b), colOut,d2 );\n    return colOut;\n}\n\nvec3 HacerCuerpoyCabeza(vec2 p, float t, vec3 colOut,vec3 colIn)\n{\n  vec2 a1=vec2(3.0,12.0);vec2 b1=vec2(3.0,8.0);  //Pansa\n  float d1= sdSegment(p,a1,b1);\n  float d2=sdCircle(p-vec2(3.0,13.0), 0.5 );  //cabeza\n  \n  colOut= DrawFig(vec3(0.0,1.0,0.0), colOut,d1);\n  colOut= DrawFig(vec3(0.5,5.0,1.0), colOut,d2);\n  return colOut;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(-1.0,0.0);\n    uv*=7.0;\n\n    vec3  col=vec3(0.5);\n\n   float t=iTime;\n   uv-=vec2(0.0,-7.0);\n\n    col= HacerCuerpoyCabeza(uv, t, col,vec3(0.0));\n   col= hacerPiernaIzq(uv,t, col,vec3(0.0));\n   col= hacerPiernaDer(uv,t+PI, col,vec3(0.0,0.5,0.5));\n   col= hacerBrazoIzq(uv, t, col,vec3(0.2,0.5,0.3));\n   col= hacerBrazoDer(uv, t-PI, col, vec3(1.0,0.5,0.4));\n   \n   vec2 a1=vec2(0.0,0.0);\n   vec2 b1=vec2(6.5,0.0);\n    float d1= sdSegment(uv-vec2(-2.0,2.0),a1,b1);\n    col= DrawFig(vec3(0.0,1.0,1.0), col,d1 );\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGGzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[417, 417, 451, 451, 546], [548, 559, 609, 609, 689], [691, 691, 713, 713, 744], [746, 777, 813, 813, 858], [863, 907, 954, 954, 981], [982, 982, 1025, 1025, 1052], [1053, 1053, 1101, 1101, 1129], [1135, 1135, 1197, 1197, 1392], [1394, 1394, 1475, 1475, 1602], [1604, 1604, 1661, 1661, 1732], [1734, 1734, 1771, 1771, 1845], [1847, 1847, 1882, 1882, 1905], [1907, 1907, 1959, 1959, 2075], [2077, 2077, 2139, 2139, 2949], [2952, 2952, 3014, 3014, 3824], [3827, 3827, 3888, 3888, 4516], [4518, 4518, 4579, 4579, 5228], [5230, 5230, 5296, 5296, 5560], [5564, 5564, 5621, 5621, 6292]], "test": "untested"}
{"id": "NlG3Ry", "name": "Random Rotate Cube", "author": "IWBTShyGuy", "description": "Axes moves randomly and smoothly.", "tags": ["rotation"], "likes": 12, "viewed": 367, "published": 3, "date": "1637849594", "time_retrieved": "2024-07-30T18:46:05.107508", "image_code": "// Copyright © 2021 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\n#if HW_PERFORMANCE!=0\n// If defined, activate anti-aliasing, level: 2 or 3\n#define AA 2\n#endif\n\n\nconst float AXIS_VELO = 1.0 / PI;\nconst float ROTATE_MEAN_VELO = PI / 2.0;\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdRoundBox(vec3 p, vec3 b, float r) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n// Random unit vector\n// https://qiita.com/aa_debdeb/items/e416ae8a018692fc07eb\nvec3 randomAxis(vec2 gen) {\n    vec2 uv = hash22(gen);\n    float z = 2.0 * uv.x - 1.0;\n    float t = 2.0 * PI * uv.y;\n    return vec3(\n        sqrt(1.0 - z * z) * cos(t),\n        sqrt(1.0 - z * z) * sin(t),\n        z\n    );\n}\n\n// B-spline basis function\nvec3 bspbasis(float t) {\n    return vec3 (\n        (1.0 - t) * (1.0 - t) * 0.5,\n        ((t + 1.0) * (1.0 - t) + t * (2.0 - t)) * 0.5,\n        t * t * 0.5\n    );\n}\n\n// smooth moving unit vector\nvec3 movingAxis(float t, float gen) {\n    t *= AXIS_VELO;\n    vec3 axis0 = randomAxis(vec2(floor(t - 2.0), gen));\n    vec3 axis1 = randomAxis(vec2(floor(t - 1.0), gen));\n    vec3 axis2 = randomAxis(vec2(floor(t), gen));\n    t = fract(t);\n    vec3 b = bspbasis(t);\n    return normalize(axis0 * b.x + axis1 * b.y + axis2 * b.z);\n}\n\n// cellwise SDF\nfloat cellDist(in vec3 p, in vec3 q, in float t) {\n    vec3 fq = floor(q);\n    float gen = fq.x + fq.y * sqrt(2.0) + fq.z * sqrt(5.0);\n    float exists = hash11(gen + 1.8649);\n    if (exists < 0.8) return 0.5;\n    vec3 disp = 0.1 * hash33(fq);\n    p = fract(q) + p - q - 0.5 - disp;\n    vec3 axis = movingAxis(t, gen);\n    float theta = hash11(gen + 0.9286);\n    theta = 2.0 * ROTATE_MEAN_VELO * theta * t;\n    p = rot(axis, theta) * p;\n    return sdRoundBox(p, vec3(0.15), 0.025);\n}\n\n// SDF\nfloat sDist(in vec3 p, in vec3 dir, in float t) {\n    float dist = cellDist(p, p, t);\n    if (floor(p + dist * dir) != floor(p)) {\n        dist = min(dist, cellDist(p, p + dist * dir, t));\n    }\n    return dist;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 p, in vec3 dir, in float t) {\n    const float eps = 0.0001;\n    const vec2 h = vec2(eps,0);\n    return normalize(vec3(\n        cellDist(p+h.xyy, p, t) - cellDist(p-h.xyy, p, t),\n        cellDist(p+h.yxy, p, t) - cellDist(p-h.yxy, p, t),\n        cellDist(p+h.yyx, p, t) - cellDist(p-h.yyx, p, t)\n    ));\n}\n\nconst float FAR = 12.0;\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 theta = vec2(0.15, 0.25) * iTime;\n    theta.y = sin(theta.y) * 0.7;\n    Camera camera = newCamera(\n        vec3(sin(iTime * 0.1) * 0.1, -iTime * 0.5, cos(iTime * 0.1) * 0.1),\n        vec3(cos(theta.x) * cos(theta.y), sin(theta.y), sin(theta.x) * cos(theta.y)),\n        //vec3(0),\n        //vec3(0, 0, 1),\n        vec3(0, 1, 0),\n        PI / 4.0,\n        iResolution.x / iResolution.y\n    );\n    Ray ray = cameraRay(camera, fragCoord / iResolution.xy);\n\n    vec3 p = ray.origin;\n    for (int _i = 0; _i < 100; _i++) {\n        float dist = sDist(p, ray.direction, iTime);\n        float rDist2 = dot(p - ray.origin, p - ray.origin);\n        if (dist < 0.00001 || rDist2 > 144.0) break;\n        p += dist * ray.direction;\n    }\n\n    vec3 col = vec3(0.9, 0.8, 0.9);\n    float dist = length(p - ray.origin);\n    if (dist < FAR) {\n        vec3 normal = calcNormal(p, ray.direction, iTime);\n        float c = -dot(ray.direction, normal);\n        c = clamp(c, 0.0, 1.0);\n        float k = smoothstep(0.0, 1.0, dist / FAR);\n        k *= k;\n        vec3 mat = hash33(floor(p) + 1.23);\n        col = (1.0 - k) * c * mat + k * col;\n    }\n\n    fragColor = vec4(pow(col, vec3(0.4545)), 1);\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    \n// smart anti-aliasing\n// reference: https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n\n// If defined, visualize anti-aliased pixels.\n//#define VISUALIZE_AA\n#ifdef AA\n    if (fwidth(length(O.xyz)) > 0.2) {\n        O.xyz = pow(O.xyz, vec3(2.2));\n        vec4 o;\n#if (AA == 2)\n        for (int k = 0; k < 4; k++) {\n              mainImage0(o,U + (vec2(k % 2, k / 2) - 0.5) / 1.5);\n              O += pow(o, vec4(2.2));\n        }\n        O /= 5.0;\n#elif (AA == 3)\n        for (int k = 0; k < 9; k += k == 3 ? 2 : 1 ) {\n              mainImage0(o, U + vec2(k % 3 - 1, k / 3 - 1) / 3.0);\n              O += pow(o, vec4(2.2));\n        }\n        O /= 9.0;\n#endif\n#ifdef VISUALIZE_AA\n        O = vec4(1);\n    } else {\n        O = vec4(0,0,0,1);\n#endif\n        O.xyz = pow(O.xyz, vec3(0.4545));\n    }\n#endif\n    O.w = 1.0;\n}\n", "image_inputs": [], "common_code": "const float PI = 3.141592653;\n\nstruct Camera {\n    vec3 position;\n    vec3 direction;\n    vec3 up_direction; // not require dot(direction, up_direction) == 0\n    float fov;\n    float aspect; // x / y\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nCamera newCamera(vec3 position, vec3 direction, vec3 up_direction, float fov, float aspect) {\n    Camera camera;\n    camera.position = position;\n    camera.direction = direction;\n    camera.up_direction = up_direction;\n    camera.fov = fov;\n    camera.aspect = aspect;\n    return camera;\n}\n\n// perspective camera ray, uv = fragCoord / iResolution.xy\n// cf: https://qiita.com/aa_debdeb/items/301dfc54788f1219b554\nRay cameraRay(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float radian = camera.fov;\n    float h = tan(radian * 0.5);\n    float w = h * camera.aspect;\n    vec3 right = normalize(cross(camera.direction, camera.up_direction));\n    vec3 up = normalize(cross(right, camera.direction));\n    vec3 direction = normalize(right * w * uv.x + up * h * uv.y + camera.direction);\n    Ray ray;\n    ray.origin = camera.position;\n    ray.direction = direction;\n    return ray;\n}\n\n// Rodrigues' rotation formula\nmat3 rot(vec3 axis, float angle) {\n    return mat3(\n        axis[0] * axis[0] * (1.0 - cos(angle)) + cos(angle),\n        axis[0] * axis[1] * (1.0 - cos(angle)) + axis[2] * sin(angle),\n        axis[0] * axis[2] * (1.0 - cos(angle)) - axis[1] * sin(angle),\n        axis[0] * axis[1] * (1.0 - cos(angle)) - axis[2] * sin(angle),\n        axis[1] * axis[1] * (1.0 - cos(angle)) + cos(angle),\n        axis[1] * axis[2] * (1.0 - cos(angle)) + axis[0] * sin(angle),\n        axis[0] * axis[2] * (1.0 - cos(angle)) + axis[1] * sin(angle),\n        axis[1] * axis[2] * (1.0 - cos(angle)) - axis[0] * sin(angle),\n        axis[2] * axis[2] * (1.0 - cos(angle)) + cos(angle)\n    );\n}\n\n/* ------------------------------------------------------ */\n// Hash without Sine https://www.shadertoy.com/view/4djSRW\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlG3Ry.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[251, 300, 343, 343, 434], [436, 516, 543, 543, 741], [743, 770, 794, 794, 933], [935, 964, 1001, 1001, 1292], [1294, 1310, 1360, 1360, 1793], [1795, 1802, 1851, 1851, 2015], [2017, 2063, 2116, 2116, 2391], [2417, 2417, 2473, 2473, 3659]], "test": "untested"}
{"id": "NtGGzG", "name": "The Cell Void 5 (fake 3D)", "author": "FabriceNeyret2", "description": "perspective variant of [url]https://shadertoy.com/view/NtGGWm [/url]\nmultilayer +cylindrical + 2D variant of lambmeow's [url]https://www.shadertoy.com/view/7lVGWW[/url]\n\nclick for slight fog.", "tags": ["2d", "voronoi", "sdf", "cellular", "short", "void"], "likes": 16, "viewed": 491, "published": 3, "date": "1637846317", "time_retrieved": "2024-07-30T18:46:05.894404", "image_code": "// perspective variant of https://shadertoy.com/view/NtGGWm\n// multilayer variant of https://shadertoy.com/view/NlG3Dw\n// cylindrical variant of https://shadertoy.com/view/flyGDw\n// 2D variant of lambmeow's https://www.shadertoy.com/view/7lVGWW\n\n#define H(v)      fract(1e4*sin((v)*mat2(R,R-71.)))\n#define S(v)      smoothstep(30./R.y,0.,v)\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, P,D,_P, C,\n          U = 10.* ( u+u - R ) / R.y, U0=U;\n    float m = 9.,d, t = iTime, k=8., z=8., r = .4, n=1., _n;\n    O-=O; \n    for( z=32.; z >= 4.; z/=2. ) {                              // several layers\n//  for( n = 2.; n >= 1.; n-=.5 ) {                             // several layers\n        U = U0;\n        U = k*vec2( .995*atan(U.y,U.x), z/length(U) );          // go to cylinder space\n        U.y += n*t;                                             // animation\n        m = 9.;\n        for ( int k=0; k < 9; k++ )                             // jittered point grid distribution\n            D = vec2(k%3,k/3), P = floor(U)+D - H(mod(floor(U)+D,25.)+n/13.),  // NB: cyclical hash\n            d = length(P-U), \n            d < m ? _P=P, _n = n, m = d : m;\n\n        P = _P;\n\n        U = U0;\n        P = k*z/(P.y-_n*t) * cos( P.x/.995/k + vec2(0,-1.57) ); // back to screen space\n        m = length(P-U);\n\n        r = .4*length(U)/10.;                                   // draw disk\n        C = vec2( S(m-r) );                                           // mask\n        C.x = clamp( C.x - .9*S( length(P-U+ U*r/50. ) -r ), 0.,1.); // color = disc - dark disc\n        O =  ( iMouse.z <= 0. ? C.xxxy \n                              : C.xxxy*exp(-vec4(0,1,1,1)/10.*log2(z/4.)) ) // if click, fog\n            + (1.-C.y)*O;                                       // blend\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtGGzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[407, 407, 445, 445, 1852]], "test": "untested"}
{"id": "slKGWw", "name": "Fractal knots", "author": "jarble", "description": "A fractal with knot-like patterns.", "tags": ["fractal", "knot", "lace"], "likes": 22, "viewed": 466, "published": 3, "date": "1637819323", "time_retrieved": "2024-07-30T18:46:06.666340", "image_code": "//change these constants to get different patterns!\n#define c1 vec3(1.,0.5,1.5)\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvec2 triangle_wave(vec2 a,float scale,float num){\n    //a = rotate(a,num*radians(180.));\n    return abs(fract((a+c1.xy)*scale)-.5);\n    //return abs(fract((a+c1.xy+num)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 36.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    float scale = c1.z;\n    float offset = 0.;\n    float offset1 = iTime/1000.;\n    float num = 0.;\n    vec3 col1 = col;\n    \n    for(int i=0;i<9;i++)\n    {\n        //num += ceil(uv.x-uv.y);\n        //uv.x *= sign(uv.x);\n        //uv.y *= sign(uv.y);\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        \n        //float scale = scale+col.x/16.;\n        for(int k = 0; k < 3; k++){\n            \n\n            //uv /= -scale-col.x;\n            //uv += ceil(t2*2.)/2.; //lace pattern\n\n            uv /= -scale;\n            uv -= offset + (t2.yx)/(scale);\n            \n            //uv += fract(uv.x/(3.))/3.; //a more interesting quilt pattern\n\n            //uv -= offset + (t2.yx)/(scale+length(col));\n            \n            //uv -= (t2.yx)/(scale+t3);\n            //uv -= (t2.yx)/(scale+col.x);\n            vec2 temp = t2;\n            t2 = triangle_wave(uv.yx-.5,scale,num);\n            //t2 = triangle_wave(uv.yx-.5+float(i),scale);\n            \n            t3 = triangle_wave(uv,scale,num);\n            //t2 -= abs(t2-.5)/4.;\n            //t3 -= abs(t3-.5)/4.;\n            //t2 = abs(t2-.5);\n            //t3 = abs(t3-.5);\n            \n            uv.yx = (t2+t3)/scale;\n            //t2 /= (1.+temp);\n            //offset -= col.x/16.;\n            //offset += offset1;\n        }\n        //offset += .5/scale;\n        col.x = abs(uv.y-uv.x+col.x);\n        col = col.yzx;\n        col1 = abs(col1-col);\n        //scale *= 1.0+col.x/16.;\n    }\n    fragColor =\n        vec4(col,1.0);\n        //vec4(col1,1.0);  \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slKGWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 111, 111, 195], [197, 197, 246, 285, 379], [381, 381, 438, 438, 2185]], "test": "untested"}
{"id": "NtK3Ww", "name": "Fork spiraling  hypnothala 777", "author": "hypnothalamus", "description": ".", "tags": ["spiral", "conformal", "polar"], "likes": 8, "viewed": 381, "published": 3, "date": "1637810787", "time_retrieved": "2024-07-30T18:46:07.430297", "image_code": "//#define ORIGINAL\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy; U = (U+U-R)/R.y; \n    \n    // Number of divisions of the circle\n    #ifdef ORIGINAL\n        float Q = 6.;\n    #else\n        float Q = 10. + 5.*sin(iTime);\n    #endif\n\n    U = vec2((1.+atan(U.y,U.x)/3.1416)*Q/2.,log(length(U))); // conformal polar\n    // multiply U for smaller tiles\n\n    U.y += U.x/Q; // comment for concentric circles instead of spiral\n    \n    // N is the counter - increasing towards the center\n    float N = floor(1.-U.y) * Q + floor(U.x);\n    \n    O.x = floor(N)/32.; // for display purposes only\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtK3Ww.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 58, 58, 608]], "test": "untested"}
{"id": "7tyGWm", "name": "spqr: volumetric light study", "author": "Fahrenheitrequited", "description": "a", "tags": ["a"], "likes": 6, "viewed": 288, "published": 3, "date": "1637796075", "time_retrieved": "2024-07-30T18:46:08.205225", "image_code": "\n\n#define rep(p,s) (fract(p/s-0.5)-0.5)*s\n\nfloat box(vec3 p, vec3 s) {\n  p=abs(p)-s;\n  return max(p.x, max(p.y,p.z));\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);  \n}\n\n\nfloat tick (float t ) {\n  float i = floor(t);\n  float r = fract(t);\n  r = sqrt(r);\n  return r + i;\n\n}\nfloat grid(vec3 p) {\n  \n  \n  vec3 p2 = p;\n  p2.y = (fract(p.y)-0.5);\n  float d = box(p2, vec3(10.0,0.2,0.05));\n  \n  p.x = (fract(p.x)-0.5);\n  \n  d = min(d, box(p, vec3(0.2,5,0.05)));\n  \n  return d;\n}\n\nfloat sph (vec3 p, float r) {\n  return length(p) -r;\n}\nfloat cyl (vec2 p,float r) {\n  return length(p) - r;\n}\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\n\nfloat map(vec3 p) {\n\n  // geo\n  \n  float outside = cyl(p.xz, 3.);\n  float inside = -cyl(p.xz, 2.8);\n  float tunnel = max(inside,outside);\n  p.xz *= rot((p.y/10.) * sin(iTime) * 5.1);\n  p = rep(p, vec3(.52));\n  float holes = sph(p, .27);\n \n  tunnel = max(tunnel,-holes);\n  return tunnel;\n}\n\nfloat rnd(vec2 uv) {\n  return fract(dot(sin(uv*754.655+uv.yx*942.742),vec2(3847.554)));\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*472.355)*655.644);\n}\n\nfloat curve(float t) {\n  return mix(rnd(floor(t)), rnd(floor(t)+1.0), smoothstep(0.0,1.0,fract(t)));  \n}\n\n\n\n\nfloat shadow(vec3 p, vec3 l, float maxdist, int stepcount, float limit) {\n  float shad=1.0;\n  float dd=0.0;\n  for(int i=0; i<stepcount; ++i) {\n    float d=min(map(p), maxdist);\n    if(d<limit) {\n      shad=0.0;\n      break;\n    }\n    if(dd>=maxdist) {\n      break;\n    }\n  \n    p += l*d;\n    dd+= d;\n \n  }\n  return shad;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  \n  \n  \n  \n\n\n // vec3 r=normalize(vec3(-uv, 1));\n  \n  \n  // nav\n  float tt = iTime * .01 + 16.5;\n  vec3 s,t;\n  s += lattice(tt) * 20.;\n  s += lattice(tt * 3.) * 5.1;\n  s *= sin(tick(iTime * .31) * .21+ 7.);\n  \n  t += lattice(tt * 95. + 1.) * 3.;\n  t += lattice(tt * 57.) * 1.1;;\n  \n \n \n \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,-1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz*0.7);\n  \n\n \n\n  \n  // march\n  \n  vec3 p=s;\n  float dd=0.0;\n  const float maxdist = 100.0;\n  float z;\n  for( z=0.; z<100.; ++z) {\n  \n    float d=map(p);\n    if(d<0.001) break;\n    if(dd>maxdist) { dd=maxdist; break;}\n    p+=r*d;\n    dd+=d;\n    \n  }\n  \n  \n  \n  // volume\n  \n  float rand=rnd(uv);\n  \n  vec3 lightpos = vec3(3);\n  //vec3 lightfocus = vec3(3);\n  float lightangle = .1;\n \n  lightpos = vec3(0,0,4);\n  lightpos.xz *= rot(iTime);\n  lightpos.yz *= rot(iTime * .61);\n  lightpos.xy *= rot(iTime * .41);\n  \n  \n  //lightfocus.yz *= rot(t1 * .7);\n  //lightfocus.xz *= rot(t2 * .8);\n  //lightfocus.yx *= rot(t3 * .91);\n  \n\n\n  \n  const int volsteps=50;\n  float voldist = 15.0;\n  float stepsize = voldist/float(volsteps);\n  vec3 lr=r*stepsize;\n  vec3 lp=s + lr*rand;\n  float stepdist=rand*stepsize;\n  vec3 atcol=vec3(0);\n  \n  for(int i=0; i<volsteps; ++i) {\n  \n    if(stepdist>dd) {\n      break;\n    }\n    \n    vec3 lv = lightpos-lp;\n    float ldistvol = length(lv);\n    lv = normalize(lv);\n    float shadvol = shadow(lp, lv, ldistvol, 10, 0.01);\n    if ( dot( normalize(lv), normalize(lp) ) > -1.) {\n      atcol += 5./(0.01+(pow(ldistvol,1.5))) * shadvol;\n    }\n \n    lp+=lr;\n    stepdist+=stepsize;\n    \n  }\n \n \n  \n  vec2 off=vec2(0.01,0);\n  vec3 n=normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n  \n  vec3 l=normalize(lightpos - p);\n\n  float ldist = length(lightpos - p);\n  float fade = 1.0/(ldist*ldist);\n  \n  float shad = shadow(p + n * 0.2, l, ldist, 30, 0.01);\n  \n  vec3 col=vec3(0);\n\n  col += atcol * .07;\n  col = pow(col, vec3(0.4545));\n  col *= 1.2-length(uv);\n  \n  col += pow( 1.-z/100., 135.) * vec3(1);\n  \n  fragColor = vec4(col, 1);\n}\n\n\n/*\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tyGWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 70, 70, 119], [121, 121, 140, 140, 211], [214, 214, 237, 237, 315], [316, 316, 336, 336, 515], [517, 517, 546, 546, 571], [572, 572, 600, 600, 626], [628, 628, 649, 649, 698], [700, 700, 725, 725, 1194], [1196, 1196, 1215, 1225, 1484], [1486, 1486, 1506, 1506, 1575], [1577, 1577, 1597, 1597, 1639], [1641, 1641, 1663, 1663, 1745], [1750, 1750, 1823, 1823, 2072], [2076, 2076, 2133, 2133, 4381]], "test": "untested"}
{"id": "stGGDm", "name": "Persian carpet 28", "author": "jarble", "description": "More experiments with fractal carpet designs.", "tags": ["fractal", "carpet", "rug"], "likes": 1, "viewed": 257, "published": 3, "date": "1637795691", "time_retrieved": "2024-07-30T18:46:08.967188", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);    \n    vec3 col;  \n    float t1 = 4.5, offset = .5;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale2 = 1.5;\n    float bend = 1.;\n    float scale = c1.z;\n    for(int i=0;i<3;i++)\n    {\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 0; k < 9; k++){    \n            uv /= -scale2;\n            t2 = triangle_wave(uv.yx-offset,scale);\n            t3 = triangle_wave(uv,scale);\n            uv.yx = t2/bend+t3*bend;\n            bend *= -1.;\n            bend -= 1./3.-col.x;\n        }\n        //scale /= 1.+(scale2)*col.x/(8.);\n        scale2 -= (col.x-1.)/(4.);\n        col = col.yzx;\n        col[0] = abs((uv.x)-(uv.y));\n    }\n    \n    fragColor = vec4(vec3(col*2.),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stGGDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 144, 144, 189], [191, 191, 248, 248, 1053]], "test": "untested"}
{"id": "stG3Ww", "name": "Gas chamber", "author": "michael0884", "description": "Makes pretty good vortecies arguably", "tags": ["fluid", "particles", "reintegration", "mpm", "apic"], "likes": 23, "viewed": 726, "published": 3, "date": "1637784501", "time_retrieved": "2024-07-30T18:46:09.760068", "image_code": "//MIT License\n//Copyright 2021 Mykhailo Moroz\n\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb); \t\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    P = floor(P);\n    \n    if(iMouse.z < 0.)\n    {\n       // P = iMouse.xy + 300.*(P/R.x - 0.5); \n    }\n    \n    float m = 0.0;\n    float rho = 0.0;\n    vec2 v = vec2(0.0);\n    float curl = 0.0;\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        //load data\n        vec2 di = vec2(i,j);\n        vec4 data0 = A(P + di);\n        vec4 data1 = B(P + di);\n        \n        //unpack data\n        float m0 = data0.y;\n        vec2 x0 = decode(data0.x) - fract(P);\n        vec2 v0 = decode(data1.x);\n        mat2 B0 = mat2(decode(data1.y),decode(data1.z)); //velocity gradient\n        //update particle position\n        x0 = x0 + di + v0*dt;\n        \n        //find cell contribution\n        vec3 o = overlap(x0, vec2(1.0));\n        \n        m += m0*o.z;\n        \n        float w = k1(x0);\n        \n        v += (v0 + 4.0*B0*x0)*w;\n        curl += w*(x0.x*v0.y - x0.y*v0.x); \n        rho += m0*w;\n    }\n    \n    float arg = 0.5*(atan(v.y, v.x)/PI + 1.0);\n    float d = 8.5*sqrt(abs(curl))*sign(curl);\n    vec3 fluid =step(-d, 0.)*tanh(d)*vec3(1.000,0.180,0.384) - step(d, 0.)*tanh(d)*vec3(0.122,0.459,1.000);\n    \n    C = mix(vec4(1.0), vec4(fluid,1.0), smoothstep(0., 1.0, rho));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R;\nvec4 Mouse;\nfloat time;\nint frame;\n\n#define A(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define B(p) texelFetch(iChannel1, ivec2(mod(p,R)), 0)\n\n#define CH(c, p) texelFetch(c, ivec2(mod(p,R)), 0)\n\n//loop in range\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 0.8\n#define max_vel 1.0\n#define rad 2\n\n#define diffusion 0.05\n#define gravity 0.00\n\n#define PI 3.14159265\n\n#define rest_rho 1.0\n#define eos_pressure 0.5\n\n//pressure equation of state\nfloat pressure(float rho)\n{\n    return 1.2*(rho); //gas\n   // return eos_pressure*(pow(rho/rest_rho,4.) - 1.0); //Tait EOS (water)\n}\n\nvoid InitialConditions(inout float m, inout vec2 v, vec2 P)\n{\n    vec2 dx = P - R*vec2(0.3, 0.5);\n\n    float d = smoothstep(R.y*0.5, R.y*0.49, length(dx));  \n    m = 0.0*d;\n\n    v = d*0.3*normalize(vec2(dx.y,-dx.x));\n}\n\n//KERNEL FUNCTIONS\n\nfloat k0(vec2 dx) //linear kernel\n{\n    vec2 k = max(1.0 - abs(dx), 0.);\n    return k.x*k.y;\n}\n\nvec3 K0(vec2 dx) //linear kernel with the center of mass\n{\n    vec2 k = max(1.0 - abs(dx), 0.);\n    return vec3(dx*0.5, k.x*k.y);\n}\n\nfloat k1(vec2 dx) //quadratic kernel\n{\n    vec2 f = max(1.5 - abs(dx), 0.0);\n    vec2 k = min(max(0.75 - dx*dx, 0.5), 0.5*f*f);\n    return k.x*k.y;\n}\n\n//box size enstimator\nvec2 destimator(vec2 dx)\n{\n    return diffusion*dt+clamp(1.0 - 2.0*abs(dx), 0.001, 1.0);\n}\n\n//box overlap with center of mass\nvec3 overlap(vec2 dx, vec2 box)\n{\n    vec2 min0 = max(dx - box*0.5, -0.5); \n    vec2 max0 = min(dx + box*0.5, 0.5); \n    vec2 size = max(max0 - min0, 0.); \n    return vec3(0.5*(max0 + min0), size.x*size.y/(box.x*box.y));\n}\n\n//boundary\n#define border_h 3.\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -border_h-sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n\n    return bound;\n}\n\n#define h 5.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\n//DATA PACKING\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X)*12.0; \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x/12.0);\n    return uintBitsToFloat(X); \n}\n\n//particle to grid\nvec4 P2G(sampler2D a, sampler2D b, vec2 P)\n{\n    vec2 x = vec2(0.0);\n    vec2 v = vec2(0.0);\n    float m = 0.0;\n    float rho = 0.0;\n    \n    range(i, -1, 1) range(j, -1, 1)\n    {\n        //load data\n        vec2 di = vec2(i,j);\n        vec4 data0 = CH(a, P + di);\n        vec4 data1 = CH(b, P + di);\n        \n        //unpack data\n        float m0 = data0.y;\n        float r0 = data0.w;\n        vec2 x0 = decode(data0.x);\n        vec2 v0 = decode(data1.x);\n        mat2 B0 = mat2(decode(data1.y),decode(data1.z)); //velocity gradient\n        \n        //estimate the shape of the distribution\n        vec2 box = destimator(x0);\n        \n        //predicted density using the affine matrix, thanks to Grant Kot for this idea\n        //float rho = ;//;\n        mat2 stress = -mat2(clamp(pressure(data1.w/determinant(mat2(1.0) + 4.0*B0*dt)), -12., 12.));\n        \n        //update particle position\n        x0 = x0 + di + v0*dt;\n    \n        //find cell contribution\n        vec3 o = overlap(x0, box);\n         \n        //update distribution\n        x += m0*o.xy*o.z;\n        m += m0*o.z;\n        \n        //find grid node contribution\n        float w = k1(x0);\n        \n        //distribute momentum onto grid\n        v += (v0 + 4.0*B0*x0 + dt*stress*x0)*w*m0;\n        rho += m0*w;\n    }\n    \n    \n    //normalize\n    if(rho > 0.0) v /= rho;\n    if(m > 0.0) x /= m;\n    \n   // m = mix(m, 0.3, dt*0.002);\n   \n    if(length(P - R*vec2(0.8 + 0.05*sin(2.4*time), 0.9)) < 10.) \n    {\n        x = vec2(0.0);\n        v =8.8*Dir(-PI*0.25 - PI*0.5 + 0.45*sin(3.4*time));\n        m = mix(m, rest_rho, 0.4*dt);\n    }\n\n    if(length(P - R*vec2(0.2+ 0.05*sin(2.4*time), 0.9)) < 10.) \n    {\n       x = vec2(0.0);\n        v = 8.8*Dir(-PI*0.25 + 0.45*sin(3.4*time));\n        m = mix(m, rest_rho, 0.4*dt);\n    }\n    \n    //initial conditions\n    if(frame < 1)\n    {\n        InitialConditions(m, v, P);\n    }\n    \n    v = (length(v)>max_vel)?normalize(v)*max_vel:v;\n    \n    return vec4(encode(x), m, encode(v), rho);\n}\n\n//grid to particle\nvec4 G2P(sampler2D a, sampler2D b, vec2 P)\n{\n    vec2 V = vec2(0.0);\n    mat2 B = mat2(0.0);\n    \n    vec4 data = CH(a, P);\n    float m = data.y;\n    vec2 x = decode(data.x);\n    float mass = 0.0;\n    \n    range(i, -1, 1) range(j, -1, 1)\n    {\n        //load data\n        vec2 di = vec2(i,j);\n        vec4 data0 = CH(a, P + di);\n        \n        //unpack data\n        float m0 = data0.y;\n        float rho = data0.w;\n        vec2 x0 = decode(data0.x);\n        vec2 dx = x - di;\n        vec2 v0 = decode(data0.z);\n        \n        //find grid node contribution\n        float w = k1(dx);\n        \n        //distribute velocities/forces to particles\n        V += v0*w;\n        vec2 nv0 =dot(v0, normalize(dx))*normalize(dx);\n        //v0 = v0 - nv0 + clamp(nv0, -0.01, 0.01);//remove divergent component, makes it unstable otherwise\n        B += mat2(v0*dx.x,v0*dx.y)*w;\n    }\n    \n    float divergence = 0.5*(B[0][0] + B[1][1]);\n    \n    B -= 1.7*mat2(divergence);\n    \n    //B = B - B*dt*smoothstep(1.0, 0.8, m);\n    \n    //gravity\n    V += -gravity*vec2(sin(0.),cos(0.))*dt;\n    \n    //push fluid\n    V += vec2(0.0, 8.0)*exp(-0.02*pow(distance(P, R*vec2(0.6,0.2)), 2.));\n    \n    if(Mouse.z > 0.)\n    {\n        vec2 dx = (Mouse.xy - P); \n        V += 0.001*exp(-0.03*length(dx))*dt*dx; \n    }\n    \n    //border \n    vec3 N = bN(P + x);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, V);\n    //V *= 1. - 0.1*exp(-N.z);\n    V += (0. + 1.5*max(vdotN, 0.0))*N.xy*step(abs(N.z), border_h)*exp(-N.z);\n   // V = (length(V)>max_vel)?normalize(V)*max_vel:V;\n   \n    //estimate density\n    x += V*dt;\n   \n    range(i, -1, 1) range(j, -1, 1)\n    {\n        //load data\n        vec2 di = vec2(i,j);\n        vec4 data0 = CH(a, P + di);\n        vec2 dx = x - di;\n        //unpack data\n        float m0 = data0.y;\n        \n        mass += data0.w*k1(dx);\n    }\n   \n    return vec4(encode(V), encode(clamp(B[0], -2.5,2.5)), encode(clamp(B[1], -2.5,2.5)), mass);\n}\n\n", "buffer_a_code": "//Advect mass distributions and distrubute the momentum and density to grid\n\n//Advect + P2G\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse; frame = iFrame;\n    P = floor(P);\n   \n    C = P2G(iChannel0,iChannel1,P);\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//Distribute grid velocities to the mass distributions\n\n//G2P\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse; frame = iFrame;\n    P = floor(P);\n    C = G2P(iChannel0, iChannel1, P);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//Advect + P2G\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse; frame = iFrame;\n    P = floor(P);\n   \n    C = P2G(iChannel0,iChannel1,P);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//G2P\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse; frame = iFrame;\n    P = floor(P);\n    C = G2P(iChannel0, iChannel1, P);\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stG3Ww.jpg", "access": "api", "license": "mit", "functions": [[48, 48, 75, 75, 233]], "test": "untested"}
{"id": "Nty3Wm", "name": "Interactive Arrows", "author": "SnoopethDuckDuck", "description": "Click the screen!\n\nUncomment \"p\" for a moving point, change \"n\" to make the arrows behave more interestingly\n\nNeater version here:\nhttps://www.shadertoy.com/view/mtBSWR", "tags": ["e"], "likes": 33, "viewed": 691, "published": 3, "date": "1637779009", "time_retrieved": "2024-07-30T18:46:10.523028", "image_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\n// square length\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nvec2 rot(vec2 uv, float a) {\n    mat2 mat = mat2(cos(a), -sin(a), \n                    sin(a), cos(a));\n    return mat * uv;\n}\n\nfloat sdEquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// draws an arrow (d is used to make it go up + down)\nfloat arrow(vec2 uv, float d) {\n    float h = 0.1 + 0.4 * thc(4.,2. * d);\n    float d1 = sdEquilateralTriangle(uv-vec2(0.,0.25 - h));\n    float s1 = step(d1, -0.5);\n\n    float d2 = sdBox(uv - vec2(0.,-h), vec2(0.05,0.2));\n    float s2 = step(d2, 0.);\n    \n    return max(s1, s2);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    // scale (number of arrows)\n    float sc = 10.; \n    vec2 ipos = floor(sc * uv) + 0.5;\n    ipos /= sc;\n    vec2 fpos = fract(sc * uv) - 0.5;\n    \n    vec2 p = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    \n    // moving point\n    // p = 0.4 * vec2(iResolution.x/iResolution.y * thc(2., 0.5 * iTime), sin(iTime));\n     \n    // cursor\n    float d2 = length(uv-p);\n    float s2 = step(d2,0.02) - step(d2,0.016);\n    s2 *= 0.5;\n    \n    // grid\n    float d3 = mlength(fpos);\n    float s3 = step(d3,0.5) - step(d3,0.48);\n    s3 *= 0.2;\n    \n    // change me!\n    float n = 1.;  \n    // n = -3.;\n    \n    // rotate arrows towards cursor\n    float th = -0.5 * pi + n * atan(p.y-ipos.y, p.x-ipos.x);\n    fpos = rot(fpos, th);\n    \n    // shrink arrows that are far away\n    fpos *= 1. + d2 * d2;  \n   \n    // arrow\n    float s1 = 0.5 * arrow(fpos, d2) ;\n    \n    float s = max(max(s1,s2), s3);\n    \n    // fade \n    // s *= pow(1.-length(ipos-p),3.);\n    \n    vec3 e = vec3(1.);\n    vec3 col = s * pal(s3 * th + d2 - 0.4 * iTime, e, e, e, vec3(0.,1., 2.)/3.);\n    // col = vec3(s);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nty3Wm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 49, 49, 90], [92, 109, 133, 133, 173], [175, 175, 203, 203, 301], [303, 303, 345, 345, 556], [558, 558, 595, 595, 675], [677, 731, 762, 762, 1012], [1014, 1014, 1082, 1082, 1125], [1128, 1128, 1185, 1185, 2370]], "test": "untested"}
{"id": "ftyGDm", "name": "harmonograph", "author": "remaindeer", "description": "Simple harmonograph. Not as cool as Xls3zf by eiffie. Uses anti-aliasing without the time-skip trick from oneshade's comment on slV3Wh.", "tags": ["pendulum", "harmonograph", "blackburnpendulum"], "likes": 3, "viewed": 317, "published": 3, "date": "1637776756", "time_retrieved": "2024-07-30T18:46:11.387716", "image_code": "// Image\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv  = fragCoord / iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Buffer A\n\n#define PI 3.1415926535897932384626433\n#define draw(dist, color) col = max(col, color * smoothstep(2.0 / iResolution.y, 0.0, dist))\n\nfloat pendulum(float t, vec4 param) {\n    // https://en.wikipedia.org/wiki/Harmonograph\n    // vec4 -> (amplitude, frequency, phase, damping)  \n    return param.x * sin(t * param.y + param.z) * exp(-t * param.w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.y;\n    vec2 oo = iResolution.xy / iResolution.y / 2.0; // center\n    \n    vec3 col = texture(iChannel0, fragCoord / iResolution.xy).xyz;\n    vec3 rnd = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0,2,4));\n    \n    float t = iTime;\n    vec4 p1 = vec4(0.15, 2, 3.0 * PI / 2.0, 0.005);\n    vec4 p2 = vec4(0.25, 4, PI, 0.005);\n    vec4 p3 = vec4(0.15, 7, PI / 2.0, 0.0005);\n    vec4 p4 = vec4(0.25, 5, PI / 2.0, 0.0015);\n    vec2 point = vec2(\n        pendulum(t, p1) + pendulum(t, p2),\n        pendulum(t, p3) + pendulum(t, p4)\n    ) + oo;\n    \n    col = draw(length(uv - point) - 0.015, rnd);\n\n    fragColor = vec4(col, 1.0);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftyGDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[10, 10, 65, 65, 185]], "test": "untested"}
{"id": "NtGGWm", "name": "The Cell Void 4 (fake 3D)", "author": "FabriceNeyret2", "description": "multilayer variant of [url]https://shadertoy.com/view/NlG3Dw[/url]\ncylindrical variant of [url]https://shadertoy.com/view/flyGDw[/url]\n2D variant of lambmeow's [url]https://www.shadertoy.com/view/7lVGWW[/url]", "tags": ["2d", "voronoi", "sdf", "cellular", "short", "void"], "likes": 14, "viewed": 387, "published": 3, "date": "1637772299", "time_retrieved": "2024-07-30T18:46:12.174612", "image_code": "// multilayer variant of https://shadertoy.com/view/NlG3Dw\n// cylindrical variant of https://shadertoy.com/view/flyGDw\n\n#define H(v)      fract(1e4*sin((v)*mat2(R,R-71.)))\n#define S(v)      smoothstep(30./R.y,0.,v)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, P,D,_P,\n          U = 10.* ( u+u - R ) / R.y, U0=U;\n    float m = 9.,d, t = iTime, k=8., z=8., n, _n;\n\n  for( n = 2.; n >= 1.; n-=.5 ) {                           // several layers\n    U = U0;\n    U = k*vec2( .995*atan(U.y,U.x), z/length(U) );          // go to cylinder space\n    U.y += n*t;                                             // animation\n\n    for ( int k=0; k < 9; k++ )                             // jittered point grid distribution\n        D = vec2(k%3,k/3), P = floor(U)+D - H(mod(floor(U)+D,25.)+n/13.),  // NB: cyclical hash\n        d = length(P-U), \n        d < m ? _P=P, _n = n, m = d : m;\n }   \n    P = _P;\n\n    U = U0;\n    P = k*z/(P.y-_n*t) * cos( P.x/.995/k + vec2(0,-1.57) ); // back to screen space\n    m = length(P-U);\n \n                                                            // draw disk - dark disk\n    O = vec4( clamp( S(m-.4) - S( length(P-U+ U*length(U)/1e3 ) -.4 )  ,0.,1.) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtGGWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[216, 216, 254, 254, 1201]], "test": "untested"}
{"id": "ftGGWm", "name": "Classic plasma effect", "author": "CenTdemeern1", "description": "Shadertoy implementation of the effect described here: https://www.bidouille.org/prog/plasma", "tags": ["plasma", "background", "trippy"], "likes": 3, "viewed": 317, "published": 3, "date": "1637771235", "time_retrieved": "2024-07-30T18:46:12.944554", "image_code": "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //Inputs for this fragment\n    vec2 u_k = vec2(20,20); //\"Zoom\". You may derive this from the resolution if you want\n    float u_time = iTime;\n    vec2 v_coords = fragCoord / iResolution.xy;\n    \n    //Fragment value calculation done by applying the patterns described on the linked webpage\n    float v = 0.0;\n    vec2 c = v_coords * u_k - u_k/2.0;\n    v += sin((c.x+u_time));\n    v += sin((c.y+u_time)/2.0);\n    v += sin((c.x+c.y+u_time)/2.0);\n    c += u_k/2.0 * vec2(sin(u_time/3.0), cos(u_time/2.0));\n    v += sin(sqrt(c.x*c.x+c.y*c.y+1.0)+u_time);\n    v = v/2.0;\n    \n    //Color\n    vec3 col = vec3(1, sin(PI*v), cos(PI*v)); //Color calculation. v is the \"value\" of the current fragment.\n    fragColor = vec4(col*.5 + .5, 1); //Applies the fragment color, also makes the color brighter.\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGGWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 126, 157, 924]], "test": "untested"}
{"id": "NlG3Dw", "name": "The Cell Void 3 (fake 3D)", "author": "FabriceNeyret2", "description": "cylindrical variant of [url]https://shadertoy.com/view/flyGDw[/url]\n2D variant of lambmeow's [url]https://www.shadertoy.com/view/7lVGWW[/url]", "tags": ["2d", "voronoi", "sdf", "cellular", "short", "void"], "likes": 11, "viewed": 279, "published": 3, "date": "1637771208", "time_retrieved": "2024-07-30T18:46:13.717487", "image_code": "// cylindrical variant of https://shadertoy.com/view/flyGDw\n\n#define H(v) fract(1e4*sin((v)*mat2(R,R-71.)))\n#define S(v) smoothstep(30./R.y,0.,v)\n\n#define CYL\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, P,D,_P,\n          U = 10.* ( u+u - R ) / R.y, U0=U;\n    float m = 9.,d, t = iTime, k=8.;\n #ifdef CYL\n    U = k*vec2( .995*atan(U.y,U.x), 8./length(U) );        // go to cylinder space\n    U.y += t;                                              // animation\n #endif\n \n    for ( int k=0; k < 9; k++ )                            // jittered point grid distribution\n        D = vec2(k%3,k/3), P = D - H(mod(floor(U)+D,25.)), // NB: cyclical hash\n        d = length(P-fract(U)), \n        d < m ? _P=P, m = d : m;\n    \n    P = _P + floor(U);\n #ifdef CYL\n    U = U0;\n    P = k*8./(P.y-t) * cos( P.x/.995/k + vec2(0,-1.57) ); // back to screen space\n    m = length(P-U);\n #endif   \n                                                          // draw disk - dark disk\n    O = vec4( clamp( S(m-.4) - S( length(P-U+ U*length(U)/1e3 ) -.4 )  ,0.,1.) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlG3Dw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 160, 198, 198, 1068]], "test": "untested"}
{"id": "flyGDw", "name": "The Cell Void 2 (fake 3D)", "author": "FabriceNeyret2", "description": "2D variant of lambmeow's [url]https://www.shadertoy.com/view/7lVGWW[/url]\nBut ok, it's static :-p  ( for now ) ", "tags": ["2d", "voronoi", "sdf", "cellular", "short", "void"], "likes": 7, "viewed": 277, "published": 3, "date": "1637770506", "time_retrieved": "2024-07-30T18:46:14.482442", "image_code": "#define H(v) fract(1e4*sin((v)*mat2(R,R-71.)))\n#define S(v) smoothstep(30./R.y,0.,v)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, P,D,_P,\n          U = 10.* ( u+u - R ) / R.y, U0=U;\n    float m = 9.,d, t = iTime;\n \n    for ( int k=0; k < 9; k++ )\n        D = vec2(k%3,k/3), P = D - H(floor(U)+D),\n        d = length(P-fract(U)), \n        d < m ? _P=P, m = d : m;\n                                                          // draw disk - dark disk    \n    O = vec4( clamp( S(m-.4) - S( length(_P-fract(U)+ U*length(U)/2e3 ) -.4 )  ,0.,1.) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flyGDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 86, 124, 124, 566]], "test": "untested"}
{"id": "flyGDD", "name": "Roots Cubic", "author": "spalmer", "description": "Just exhibiting my cubic equation solver.\nDevelopment was done [url=http://shadertoy.com/view/Ns2XRd]here[/url]", "tags": ["antialias", "graph", "plot", "cubic", "equation", "root", "solve"], "likes": 8, "viewed": 422, "published": 3, "date": "1637766748", "time_retrieved": "2024-07-30T18:46:15.611424", "image_code": "/*\nCC0 1.0 Universal (CC0 1.0)\nTo the extent possible under law, the author has waived all \ncopyright and related or neighboring rights to this work.\nhttp://creativecommons.org/publicdomain/zero/1.0\n*/\n\n// toy got big, moved bunch fundamental/unused/reference code to Common tab\n\n// used some guidance from Nickalls but really it's a merge of Wikipedia and Bloxard techniques\n// with help from iq as well, hints from James Blinn, and others.\n\n#if 1\n// solve depressed cubic x³ + cx + d = 0\nvec3 CubicSpalmer(float d, float c) // b = 0, a = 1\n{\n    float l = c / 3.\n    , s = l*l*l\n    , m = d*d + 4.*s;\n    if (m > 0.) { // 1 real root\n        vec2 w = (sqrt(m) * vec2(1,-1) - d) * .5;\n        float v = cbrt(abs(w.x) < abs(w.y) ? w.y : w.x);\n        return vec3(v - l / v, NaN, NaN); // Blinn single cbrt idea\n    }\n    // 2 or 3 distinct roots\n    float t = atan(sqrt(-m), -sign(c)*(d));\n    return 2. * ssqrt(l) * cos((t - pi * vec3(0,2,4))/3.);\n}\n#endif\n\n// solve x³ + cx + d = 0\nvec3 CubicDepressed(float d, float c)\n{\n    vec3 k = vec3(d, c, 0.);\n//    return Cubiciq(k);\n//    return CubicBloxard(k);\n//    return Cubiciq(d, c);\n//    return CubicBloxard(d, c);\n//    return Cubicmla(d, c);\n//    return CubicCardano(d, c); // busted WIP\n//    return CubicSpalmerSaved(d, c);\n    return CubicSpalmer(d, c);\n}\n\n// by spalmer\nvec3 CubicDepress(vec3 k)\n{\n    float d = k.x, c = k.y, b = k.z, // a = 1.\n        x = b/-3.; // inflection point\n    return CubicDepressed((c - 2.*x*x)*x + d, c + b*x) + x;\n}\n// depressing the cubic first makes solution much simpler and seems like it's always a good idea\n// Blinn says it's 3*b*b*b-3*b*c+d and (c-b*b) but he already divided by 3 elsewhere, confusingly\n// and I factored a division here some different way\n\n// dispatch wrapper for cubic equation in standard form\n// solve ((x + k.z)*x + k.y)*x + k.x = 0\nvec3 Cubic(vec3 k) // k.w == 1\n{\n    return\n        CubicDepress\n//     CubicWeierstrass\n//     CubicNickalls\n//     Cubiciq\n//     CubicBloxard\n//     CubicOld\n        (k);\n}\n\n// another dispatch wrapper\n// solve ((k.w*x + k.z)*x + k.y)*x + k.x = 0\n// by first dividing through by the highest order coeff,\n// which does not change the roots\nvec3 Cubic(vec4 k)\n{\n//    return CubicSpalmerInlined(k);\n//    return solveCubicReal(k);\n    if (k.w == 0.)\n        return vec3(Quadratic(k.xyz), NaN); // handle malformed eqn\n    return Cubic(k.xyz / k.w);\n}\n\nvec4 coeff = vec4( .5, -2., 1., 1.*1.5) * -1.;\n// or can set up test cases explicitly and disable animation in setup\n//vec4 coeff = vec4(1.572, -.124, -.784, 1.625);\n//vec4 coeff = vec4(-1.130701, 1.8766, .7778, .6291);\n\nfloat sinOSC(float imin, float imax, float T)\n{\n    return .5 * (sin(T) * (imax - imin) + imax + imin); // slightly optimized\n    //float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    //return imin + v * (imax - imin); // map T to [min, max];\n}\n\n/*\nvoid setup()\n{\n    NaN = sqrt(-min(0., iTime) - 1.); // compile time constant NaN is too problematic\n    float t = -2. * iTime;\n    coeff[0] -= 2.   * sin(.4 * t); // wiggle coeffs to see how they affect the result\n    coeff[1] += .125 * sin(.2 * t);\n    coeff[2] *= 1.2  * cos(.1 * t); // when [2] gets small, starts looking an awful lot like a straight line at 45 degrees at which point you cannot tell which way the curve flips because it's way off-screen\n    coeff[3] *= cos(.05 * t);\n}\n*/\nvoid setup()\n{\n    NaN = sqrt(-min(0., iTime) - 1.); // compile time constant NaN is too problematic\n\n    float Time = iTime + 14.; //17.04; //\n    float a = sinOSC(-1.25, 1.25, Time * 0.15), b = sinOSC( -2.0,  2.0, Time * 0.6), \n          c = sinOSC( -1.0,  1.0, Time * 0.45), d = sinOSC( -1.0,  1.0, Time * 0.25);\n    \n    coeff[0] = d; coeff[1] = c; coeff[2] = b; coeff[3] = a;\n\n// Envy24 test case:\n    // this breaks too, but interestingly, it's not the exact same breakage due to double precision\n    //coeff = vec4(-0.899405409685178,0.982755208911199,-1.43362772677276,0.690866734731352);\n    //coeff = vec4(-.8994, .9827, -1.4336, .6908); // obtained by shader printout, not super precise though\n    //coeff = vec4(-.8994, .9845, -1.4336, .6909); // pretty darn close to Envy24's breakage\n    //coeff[0] = coeff[1] = coeff[2] = 0.; coeff[3] = 1.;\n    //coeff[0] = .5; coeff[1] = coeff[2] = 0.; coeff[3] = 1.;\n    //coeff[0] = -1.; coeff[1] = 0.; coeff[2] = 2.; coeff[3] = 1.;\n    //coeff[0] = -.5; coeff[1] = 0.; coeff[2] = 1.; coeff[3] = 0.;\n}\n\n// function to plot\nfloat f(float x)\n{\n    return eval(x, coeff);\n}\n\n// iq line segment distance\nfloat seg(vec2 p, vec2 a, vec2 b)\n{\n    p -= a; b -= a; return length(p - b *\n        clamp(dot(p, b) / dot(b, b), 0., 1.));\n}\n\nfloat aa(float e)\n{\n    return clamp(1. - e, 0., 1.);\n}\n\n// must search at least thick pixel units away\n// to avoid missing nearby crossings.\nfloat graphf(vec2 p, vec2 R, float scale, float thick)\n{\n    float d = 9e9\n        , i = p.x-.5-thick, j = i, v = f(i*scale) / scale;\n    while ((i += 1.) <= .51+thick+p.x) {\n        float v1 = f(i*scale) / scale;\n        d = min(d, seg(p, vec2(j, v), vec2(i, v1)));\n        v = v1; j = i;\n    }\n    return aa(d + .5 - thick);\n}\n\nvec3 draw(vec2 p)\n{\n    vec2 R = iResolution.xy\n        , q = p - .5*R;\n    float scale = 2.5/R.y;\n    vec3 c = vec3(1);  // bg\n    c = mix(c, vec3(.7), aa(min(abs(q.x),abs(q.y)) - .5));\t// axis lines\n    // the inflection point is at -1./3.*coeff[2]/coeff[3]\n    float x_i = -1./3.*coeff[2]/coeff[3];\n    c = mix(c, vec3(1,.7,1), aa(abs(q.x - x_i / scale) - .0)); // inflection point\n    // TODO graph the rest of the cubic-solving construction\n    c = mix(c, vec3(0), graphf(q, R, scale, 2.5));  // graph curve\n    vec3 s = Cubic(coeff)\n    , v = vec3(f(s[0]), f(s[1]), f(s[2]));\n    c = mix(c, vec3(.8,0,0), aa(length(q - vec2(s[0], v[0]) / scale) - 5.5)); // disks\n    c = mix(c, vec3(0,.6,0), aa(length(q - vec2(s[1], v[1]) / scale) - 5.5));\n    c = mix(c, vec3(0,0,.9), aa(length(q - vec2(s[2], v[2]) / scale) - 5.5));\n    return c; // linear gamma\n}\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    setup();\n    c.rgb = draw(p);\n    c = vec4(pow(c.rgb, vec3(.4545)), 1); // to sRGB gamut\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//const float NaN = intBitsToFloat(~0);\n/*const*/ float NaN = uintBitsToFloat(0x7f800001u);\n\nconst float pi = acos(-1.);\n\n#define sgn(x) ((x)<0. ? -1. : 1.)\n/* // mla\nfloat sgn(float x) {\n  if (x < 0.0) return -1.0;\n  else return 1.0;\n}*/\n\nfloat ssqrt(float x) { return sign(x) * sqrt(abs(x)); }\nfloat spow(float x, float y) { return sign(x) * pow(abs(x), y); }\nfloat cbrt(float x) { return spow(x, 1./3.); } //sign(x) * pow(abs(x), 1./3.); } //\nvec2 cbrt(vec2 x) { return sign(x) * pow(abs(x), vec2(1./3.)); } // compute 2 cube roots at once\n\n#define complex vec2\nconst complex one = complex(1,0);\ncomplex cmul(complex a, complex b) \n{\n    return complex(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);\n}\ncomplex cdiv(complex a, complex b)\n{\n    return cmul(a, complex(b.x, -b.y) / dot(b,b));\n}\n/* // mla\ncomplex cmul(complex z, complex w) {\n  return complex(z.x*w.x-z.y*w.y,z.x*w.y+z.y*w.x);\n}\n\ncomplex cinv(complex z) {\n  return complex(z.x,-z.y)/dot(z,z);\n}\n\ncomplex cdiv(complex z1, complex z2) {\n  return cmul(z1,cinv(z2));\n}\n*/\n\n// evaluate polynomial c(t)\nfloat eval(float t, vec4 c)\n{\n    return ((c.w * t + c.z) * t + c.y) * t + c.x;\n}\ncomplex eval(float t, in complex c[4])\n{\n    return ((c[3] * t + c[2]) * t + c[1]) * t + c[0];\n}\n\n// why have I lettered these this way...\n// I tell ya what, it's maddening to try to use the \"standard\" way\n// which is used here so far... since the meanings of all the coeffs change\n// with every equation order.  But if I reverse them, suddenly\n// everything I do is backwards from all the public literature.\n// To me, the only solution is to avoid these 1-letter names entirely\n// and use indices. And by george, sort them low-order coeffs first.\n// solve a*x + b = 0\nfloat Linear(float b, float a)\n{\n    return -b / a;\n}\n\nfloat Linear(vec2 k)\n{\n    return Linear(k.x, k.y); //k[0], k[1]); //-k[0] / k[1];\n}\n\n// try again, this time try to use methodology that will scale\n// inflection point N is at x_N = -b/(2*a) = -.5*b/a\n// subtracting that gives the reduced quadratic\n// g(z) := f(z + x_N)  := \n// with z = x - x_N\n// substituting seems to give\n// z = (2*a*x_N ± √︁(b^2-4*a*c) - b) / (2*a)\n// and simplifying that by hand gives\n// z = x_N ± (√︁(b^2-4*a*c) - b) / (2*a)\n// now if we know a is 1 because we already divided it out, gets even simpler\n// z = x_N ± (√︁(b^2-4*c) - b) / 2\n// a*z^2 + c - b^2/(4*a) = 0\n// z^2 + c - b^2/4 = 0\n    // at this point we have equation x*x + b/a*x + c/a = 0 or just (x + b)*x + c = 0\n    // now subtract inflection point by substituting z = x - x_N to get\n    // z^2+(2*x_N+b)*z+x_N^2+b*x_N+c=0, subst x_N back out for -b/2 gives\n    // z^2-1/4*b^2+c = 0\n    // solve for z\n    // z = ±sqrt(b^2-4*c)/2 = ±sqrt(b^2/4-c) but we need the .5 on the outside anyway\n    // then the full answer for x is just x = x_N + z\n    // ±sqrt(b^2-4*c)/2\n// solve reduced quadratic (x + b)*x + c = 0\nvec2 Quadratic(float c, float b)\n{\n    float n = b * b - 4. * c; // discriminant\n    return n < 0. ? vec2(NaN) :\n        .5 * (sqrt(n) * vec2(-1, 1) - b); // two solutions, lesser first (may be identical)\n}\n\nvec2 Quadratic(float c, float b, float a)\n{\n    if (a == 0.)\n        return vec2(Linear(c, b), NaN); // handle malformed eqn\n    // else reduce and solve reduced equation\n    return Quadratic(c/a, b/a);\n}\n    // can literally divide by the high coeff and not change the roots, so a can always be 1.0\n    // *although* this might possibly be unwise since it may affect precision prematurely\n    //c /= a; b /= a; //a = 1.; // c only used once more anyway\n    // the inflection point will be at -.5*b\n    //float n = b * b - 4. * c; // discriminant\n    //return n < 0. ? vec2(NaN) :\n    //    .5 * (sqrt(n) * vec2(-1, 1) - b); // two solutions, lesser first (may be identical)\n// I feel like should be able to dispatch back to Linear even in the other case somehow\nvec2 Quadratic(vec3 k)\n{\n    return Quadratic(k.x, k.y, k.z); //k[0], k[1], k[2]);\n}\n\n\n// Ta-da!  spiffy\nvec3 CubicSpalmerInlined(vec4 k)\n{\n    float NaN = uintBitsToFloat(0x7f800001u);\n    float d = k.x, c = k.y, b = k.z, a = k.w;\n    if (a == 0.) { // quadratic inlined\n        if (b == 0.)\n            return vec3(-d/c, NaN, NaN); // handle malformed eqn, let divide handle c == 0 case\n        float n = c * c - 4. * b * d; // discriminant\n        return vec3(n < 0. ? vec2(NaN) :\n            .5 / b * (sign(b) * sqrt(n) * vec2(-1, 1) - c) // two solutions, lesser first (may be identical)\n            , NaN);\n    }\n    d /= a; c /= a; b /= a;\n    float x = b/-3.; // inflection point\n    d += (c - 2.*x*x)*x; c += b*x; // depress cubic\n    float l = c / 3.,\n        s = l*l*l,\n        m = d*d + 4.*s;\n    if (m > 0.) { // 1 real root\n        vec2 w = sqrt(m) * vec2(1,-1) - d;\n        float v = abs(w.x) < abs(w.y) ? w.y : w.x;\n        v = sign(v) * pow(.5*abs(v), 1./3.);\n        return vec3(v - l / v, NaN, NaN) + x; // Blinn single cbrt idea\n    }\n    // 2 or 3 distinct roots\n    return 2. * sign(c)*sqrt(abs(l)) * cos((atan(sqrt(-m), -sign(c)*d) - acos(-1.) * vec3(0,2,4))/3.) + x;\n}\n\n\n#if 1\n// TODO inline it all back again\n// I am NOT ready to do this because I am still optimizing the depressed solver!\n// solve ((k.w*x + k.z)*x + k.y)*x + k.x = 0\nvec3 CubicSpalmerInlinedWIP(vec4 k)\n{\n    float d = k.x, c = k.y, b = k.z, a = k.w;\n    if (a == 0.) { // quadratic inlined\n        if (b == 0.)\n            return vec3(-d/c, NaN, NaN); // handle malformed eqn, let divide handle c == 0 case\n        float n = c * c - 4. * b * d; // discriminant\n        return vec3(n < 0. ? vec2(NaN) :\n            .5 / b * (sign(b) * sqrt(n) * vec2(-1, 1) - c) // two solutions, lesser first (may be identical)\n            , NaN);\n    }\n    // not 100% sure doing all these divisions early is the absolute wisest plan\n    d /= a; c /= a; b /= a; //k.xyz /= k.w; //k.w = 1.;\n    float x = b/-3.; // inflection point\n    d += (c - 2.*x*x)*x; c += b*x; //b = 0.; // depressed cubic\n    float l = c / 3.,\n        s = l*l*l,\n        m = d*d + 4.*s;\n    if (m > 0.) { // 1 real root\n        vec2 w = (sqrt(m) * vec2(1,-1) - d) * .5;\n        float v = cbrt(abs(w.x) < abs(w.y) ? w.y : w.x);\n        return vec3(v - l / v, NaN, NaN) + x; // Blinn single cbrt idea\n    }\n    // 2 or 3 distinct roots\n    return 2. * ssqrt(l) * cos((atan(sqrt(-m), -sign(c)*d) - pi * vec3(0,2,4))/3.) + x;\n}\n// inlines the depressed solver\n// TODO must still inline all the little helper functions like ssqrt, then golf it all back down\n/*\nvec3 CubicSpalmer(float d, float c) // b = 0, a = 1\n{\n    float l = c / 3.\n    , s = l*l*l\n    , m = d*d + 4.*s;\n    if (m > 0.) { // 1 real root\n        vec2 w = (sqrt(m) * vec2(1,-1) - d) * .5;\n        float v = cbrt(abs(w.x) < abs(w.y) ? w.y : w.x);\n        return vec3(v - l / v, NaN, NaN); // Blinn single cbrt idea\n    }\n    // 2 or 3 distinct roots\n    \n}\n*/\n#endif\n\n#if 0\n// saved from before I figured out Blinn's single cbrt idea\nvec3 CubicSpalmer(float d, float c) // b = 0, a = 1\n{\n    float l = c / 3.,\n        s = l*l*l,\n        m = d*d + 4.*s;\n    if (m > 0.)\n    { // 1 real root\n        vec2 w = (sqrt(m) * vec2(1,-1) - d) * .5;\n        if (abs(c) < .004) // what's a good threshold here?\n        { // credit: iq from comment at http://shadertoy.com/view/dsfGWN\n            float k = s/d;  // linear approx\n            //k *= 1. - s/(d*d);  // quadratic approx doesn't seem necessary\n            w = vec2(k, -k-d);\n        }\n        w = cbrt(w);\n        return vec3(w.x + w.y, NaN, NaN);\n    }\n    // 2 or 3 distinct roots\n    float t = atan(sqrt(-m), -sign(c)*d);\n    return 2.*ssqrt(l) * cos((t - pi * vec3(0,2,4))/3.);\n}\n// got rid of some minus signs already        // FIXME in bezier toy you can see this causes a nasty glitch that isn't quite fixed by iq's above fix\n    //    return vec3(w.x - l / w.x, NaN, NaN); // TODO blinn single cbrt idea; not *quite* working, must ensure it's done totally robustly or makes things worse!\n\n// tan = b/c / (a/c) =  b/c*c/a = b/a\n// so we computed the cosine of 3*theta as .5*d/sqrt(abs(s))\n// the sine of that is sqrt(1. - .25*d*d/abs(s))\n// so at the expense of a seemingly wasted sqrt, I can pose the problem in terms of arctangent:\n// ok but the 2 arg form of atan may not in fact be ideal since then must compute the sine fully\n// what if we just pose the problem in terms of the tangent and use 1-argument atan?\n// tangent is just sin/cos so d/sqrt(4.*abs(s)-d*d)\n#endif\n\n#if 0\n// saved working copy\n// solve depressed cubic x³ + cx + d = 0\nvec3 CubicSpalmerSaved(float d, float c) // b = 0, a = 1\n{\n    float l = c / -3.,\n        s = l*l*l,\n        m = d*d - 4.*s;\n    if (m > 0.)\n    { // 1 real root\n        vec2 w = (sqrt(m) * vec2(1,-1) - d) * .5;\n        if (abs(c) < .004)\n        { // credit: iq from comment at http://shadertoy.com/view/dsfGWN\n            float k = -s/d;  // linear approx\n            //k *= 1. + s/(d*d);  // quadratic approx doesn't seem necessary\n            w = vec2(k, -k-d);\n        }\n        w = cbrt(w);\n        return vec3(w.x + w.y, NaN, NaN);\n    }\n    // 2 or 3 distinct roots, imaginary projected back to real\n    return 2.*ssqrt(l) * cos((acos(-.5*d/sqrt(abs(s))) + pi * vec3(2,4,0))/3.);\n}\n\n    //float tc = .5*d / sqrt(abs(s)); // cos(3.*theta)\n    //float ts = sqrt(1. - .25*d*d/abs(s));// * -sign(s); //sin(acos(tc)); // sin(3.*theta) so can use 2-arg atan\n    // btw sign(s) == sign(l) == sign(c)\n    //float t = atan(ts, tc); //acos(tc); // 3.*theta angle in radians\n    //float t = pi+atan(ts/tc); // closest I've gotten so far in terms of sin/cos\n    // I mean if I have to do it like this, the pi offset would get shifted into the vec3(0,2,4) somehow\n    // but am hoping can account for it some other way\n    // anyhows, now that I have a relatively straightforward way to map atan2 to atan, that seems to work,\n    // perhaps now I can simplify some of my tangent-based formulations...\n// NOTE that m = d*d - 4.*s which we already computed and we already know it's < 0.\n//float t = atan(sqrt(-m), abs(d)); //atan(sqrt(4.*abs(s)-d*d), d); // nice! very nice! but it doesn't *quite* work in all circumstances, see Bezier Quadric\n\n    // can someone please tell me why 1-argument atan does not work? it almost works..\n    //float t = pi-atan(-ts/tc); // signs just cancel out I guess\n    //float t = atan((4.*d*abs(s))/sqrt(4.*abs(s)-d*d)); //atan(sqrt(4.*abs(s)-d*d)/(4.*d*abs(s))); //-pi/2.- // broken\n    //float t = pi-atan(-ts/tc); //-pi/2.+atan(tc/ts); //pi-atan(-ts/tc); //\n    //float t = pi + sign(s) * atan(sqrt(4.*abs(s)-d*d)/abs(d)); // pretty good!\n    //float t = pi/2.+atan(d * sign(s), sqrt(abs(s))*sqrt((4.*abs(s)-d*d)/abs(s))); // same as below but uses atan2\n    //float t = pi/2.+atan(d * sign(s) / (sqrt(abs(s))*sqrt((4.*abs(s)-d*d)/abs(s)))); // I guess it's getting there\n    //float t = pi-atan(sign(s) * (sqrt(abs(s))*sqrt((4.*abs(s)-d*d)/abs(s)))/d); // wtf -- it works!  but I don't understand why it's so backwards\n    //float t = pi/2.-atan(d, sqrt(4.*abs(s) - d*d)); //atan(d/sqrt(4.*abs(s) - d*d)); // compute 3.*theta directly using tangent\n\n//float h = 2.*sqrt(abs(s)); //ssqrt(4.*s); // h used only once here\n//return 2.*ssqrt(l) * cos((acos(-d/h) + pi * vec3(2,4,0))/3.);\n// if d/h is a cosine, then h is the hypotenuse and since h*h = d*d + y*y if we want y we get\n// atan(h*h,d*d); // yeah but seems to require another sqrt which I don't want to do\n// I guess we already had the square of it, s, so that's something.\n// TODO use atan - even Blinn says to! handles some edge case precision-related fails\n    \n// FIXME there MUST be some way to do the real root computing only one cbrt\n// surely any equation of the form cbrt(u)+cbrt(v) can be rewritten in the form cbrt(f(u,v))\n// f(u,v) = v+3*u^(1/3)*v^(2/3)+3*u^(2/3)*v^(1/3)+u does not seem too promising though\n// since includes both the cube roots we're trying to eliminate\n// but perhaps if know more about u and v, if they share common factors (and they do)\n// then perhaps more will factor away and combine\n// I just want to do one cbrt here if at all possible\n// AHA! James Blinn's paper mentions this very thing\n// in the section on What could possibly go wrong?/Properly Solving the Embedded Quadratic\n// Blinn's key insight seems to be that, if the answer we seek is \n// p + q, both are cube roots, they're exchangeable because we only need the sum,\n// they only differ by the sign of the sqrt under the cbrt\n// but once you know one (p), the other you can find as simply q = -c/p\n// the only problem is that then you risk another division by zero\n// p+q = q-c/q\n// or q-l/q (remember Blinn factored 3's out)\n\n// TODO there's probably a way to combine the two cases into\n// one case by collapsing the circumcircle radius to zero.\n// I guess no because the 1-real root case is not necessarily at the inflection point.\n#endif\n\n\n\n#if 0\n// see Nickalls paper at http://nickalls.org/dick/papers/maths/cubic1993.pdf\n// \"A new approach to solving the cubic\"\n/*\nN = point of inflection of\ny = ax³ + bx² + cx + d\nis root of 2nd derivative\nf(x) := a*x^3+b*x^2+c*x+d\ndiff(f(x),x)  ==>  3*a*x^2+2*b*x+c\ndiff(f(x),x,2) ==>  6*a*x+2*b\nsolve(diff(f(x),x,2), x)  ==>  x_N = -b/(3*a)\nx_N = -b/(3a)\ny_N = f(x_N) = a*(-b/(3a))^3+b*(-b/(3a))^2+c*-b/(3a)+d = d + (-9*a*b*c+2*b^3)/(27*a^2) = d + (2*b^3)/(27*a^2)-(b*c)/(3*a)\nx = z + x_N\nz = x - x_N\naz³ − 3a𝛿²z + y_N = 0\nbut since we can easily make a=1 if we so choose,\nz³ − 3𝛿²z + y_N = 0\nrelative to N = (x_N,y_N), the sum of the 3 roots is 0\nz1 = 𝛼 − x_N , z2 = 𝛽 − x_N , z3 = 𝛾 − x_N \nz1 + z2 + z3 = 0\nδ = (b² − 3ac) / 9a²\n𝜆² = 3𝛿²\nℎ = 2a𝛿³\na𝛿𝜆²/ℎ = 3/2\nreferencing back to del Ferro's revelation folks seem to always use letters p and q\n(p + q)³ − 3pq(p + q) − (p³ + q³) = 0\npq = 𝛿²\nz = p + q\np³ + q³ = −y_N/a\np³ = 1/2a (−y_N ± √︁(y_N² − 4a²𝛿⁶))\np³ = 1/2a (−y_N ± √︁(y_N² − ℎ²))\ny_N² <=> ℎ² determines number of solutions\nwhen y_N² > ℎ², 𝛼 = x_N + cbrt(1/2a (︂−y_N + √︁(y_N² − ℎ²))︂) + cbrt(1/2a (︂−y_N − √︁(y_N² − ℎ²)︂))\nwhen y_N² == ℎ²\nwhen y_N² < ℎ²\ndl = delta = δ , lm = lambda = λ , h = planck = ℎ\n*/\n// I guess mine sort of evolved from my attempt at implementing Nickalls,\n// but borrowed heavily from bloxard's solver I had before.\n#endif\n\n\n\n#if 1\n// spalmer converted Bloxard solver into depressed cubic solver\nvec3 CubicBloxard(float d, float c)\n{\n// x_N = b = 0.; a = 1.;\n\tfloat p = c;\n    float p3 = c*c*c; //p*p*p; // the only place you ever see p3 is in conjunction with this mystical 3³ = 27 quantity\n    float s = c*c*c/27.; // so give that thing a name! it's (c/3)³\n\tfloat q = d;\n\tfloat e = q*q + 4.*s; //p3/27.;\n\tif (e > 0.)\n\t{ \n\t\tfloat z = sqrt(e);\n\t\tvec2 x = (vec2(z,-z) - q) * .5;\n        if (abs(p) < .004)\n        { // credit: iq\n            float k = s/q; //p3/27./q;              // linear approx\n            //float k = (1.-s/(q*q))*s/q;  //(1.-p3/27./(q*q))*p3/27./q;  // quadratic approx \n            x = vec2(k,-k-q);\n        }\n\t\tvec2 j = cbrt(x); //sign(x) * pow(abs(x), vec2(1./3.));\n\t\treturn vec3(j.x + j.y, NaN, NaN);\n\t}\n\tfloat v = acos(-sqrt(-1./s) * q/2.) / 3.; //acos(-sqrt(-27./p3) * q/2.) / 3.; //\n\tfloat m = cos(v), n = sqrt(3.) * sin(v);\n\treturn vec3(-n - m, n - m, m + m) * sqrt(-p / 3.);\n}\n\n// Per Bloksgaard refactored\n// Find roots using Cardano's method.\n// http://en.wikipedia.org/wiki/Cubic_equation#Cardano%27s_method\n// by bloxard http://shadertoy.com/view/dsX3RM\n// a's and c's reversed vs traditional naming.\n// his a is my b, his b is my c, his c is my d,\n// I had to rename because it was driving me batty\n// also I swapped the argument order because that was also really confusing here\nvec3 CubicBloxard(vec3 K)\n{\n    float d = K.x, c = K.y, b = K.z; //, a = 1.; //\n\tfloat x_N = -b / 3.;\n\tfloat p = c-b*b/3., p3 = p*p*p;\n\tfloat q = b*(2.*b*b-9.*c)/27.+ d;\n\tfloat e = q*q + 4.*p3/27.; // discriminant is like 4x what wikipedia says\n\tif (e > 0.)\n\t{ \n\t\tfloat z = sqrt(e);\n\t\tvec2 x = (vec2(z,-z) - q) * .5;\n        // credit: iq from comment at http://shadertoy.com/view/dsfGWN \n        // led me back to http://shadertoy.com/view/MlKcDD\n        if (abs(p) < .004)\n        {\n            // When p≈0 and p<0, h-q has catastrophic cancelation. So, we do\n            // h=√(q²+4p³)=q·√(1+4p³/q²)=q·√(1+w) instead. Now we approximate\n            // √ by a linear Taylor expansion into h≈q(1+½w) so that the q's\n            // cancel each other in h-q. Expanding and simplifying further we\n            // get x=vec2(p³/q,-p³/q-q). And using a second degree Taylor\n            // expansion instead: x=vec2(k,-k-q) with k=(1-p³/q²)·p³/q\n            //float kx = b/3., ky = c/3., kz = d; //float kx = b/3., ky = c/3., kz = d;\n            float P = c/3. - b*b/9.; //ky - kx*kx;\n            float P3 = P*P*P;\n            float Q = b/3.*(2.*b/3.*b/3. - 3.*c/3.) + d; //kx*(2.*kx*kx - 3.*ky) + kz; // iq's q is scaled differently\n            float k = P3/Q;              // linear approx\n            //float k = (1.-P3/(Q*Q))*P3/Q;  // quadratic approx \n            x = vec2(k,-k-Q);\n        }\n\t\tvec2 uv = sign(x) * pow(abs(x), vec2(1./3.));\n\t\treturn vec3(x_N + uv.x + uv.y, NaN, NaN);\n\t}\n\tfloat v = acos(-sqrt(-27./p3) * q/2.) / 3.;\n\tfloat m = cos(v), n = sqrt(3.) * sin(v);\n    // spalmer ordered 3 roots small to large\n\treturn vec3(-n - m, n - m, m + m) * sqrt(-p / 3.) + x_N;\n}\n#endif\n\n// see James Blinn http://courses.cs.washington.edu/courses/cse590b/13au/\n// which may in fact be where iq got the idea to factor out the 3's\n// whoa!  Blinn states that the 3 roots are simply (for the usual p,q)\n// and w = (sqrt(3)*i - 1)/2 a primitive cube root of unity \n// (p + q, w*p + w*w*q, w*w*p + w*q)\n// which must be where the end code of iq/bloxard style solvers comes from\n// anyway we only need the real parts, right?\n\n#if 1\n// convert iq's solver to depressed solver, then totally redo all the variable names\nvec3 Cubiciq(float d, float c)\n{\n    float p  = c / 3.,\n      s = p*p*p, // same name I used for mine I guess\n      h = d*d + 4.*s;\n    if (h >= 0.)  // 1 root\n    {   \n        h = sqrt(h);\n        vec2 u = .5*(vec2(h,-h) - d);\n        if (abs(p) < .001)\n        {\n            float k = s/d;  // linear approx\n        //  k *= 1. - k/d;  // quadratic approx \n            u = vec2(k, -k-d);  \n        }\n        u = sign(u) * pow(abs(u), vec2(1./3.));\n        return vec3(u.x + u.y, NaN, NaN);\n    }\n    float z = sqrt(-p),\n      v = acos(d/(p*z*2.)) / 3.,\n      m = cos(v),\n      n = sqrt(3.) * sin(v);\n    return vec3(-n-m,n-m,m+m) * z;\n}\n// getting real similar to mine now, especially the first part\n\n// convert iq's solver to depressed solver\nvec3 Cubiciq2(float d, float c)\n{\n    float p  = c / 3.;\n    float q  = d;\n    float p3 = p*p*p;\n    float q2 = q*q;\n    float h  = q2 + 4.*p3;\n    if (h >= 0.)  // 1 root\n    {   \n        h = sqrt(h);\n        vec2 u = .5*(vec2(h,-h)-q);\n        if (abs(p) < 0.001)\n        {\n            float k = p3/q;              // linear approx\n        //  float k = (1.-p3/q2)*p3/q;  // quadratic approx \n            u = vec2(k, -k-q);  \n        }\n        u = sign(u) * pow(abs(u), vec2(1./3.));\n        return vec3(u.x + u.y, NaN, NaN);\n    }\n    float z = sqrt(-p);\n    float v = acos(q/(p*z*2.)) / 3.;\n    float m = cos(v);\n    float n = sqrt(3.) * sin(v);\n    return vec3(-n-m,n-m,m+m) * z;\n}\n\n// spalmer extracted cubic solver from iq's http://shadertoy.com/view/DdlGD8\n//  (a == 1 always here)\n// iq's kx is -x_N compared to most of the rest\n// which means, what, he must have multiplied the whole thing by -3\n// Blinn style eh.\n// I can't stand his kx etc. coeff names, they are so confusing\n// so I'm swapping back to d, c, b, used vec3 coeff interface\n// FIXME c, b internal coeffs also off by a factor of 3\nvec3 Cubiciq(vec3 K)\n{\n    float d = K.x, c = K.y / 3., b = K.z / 3.;\n    float x_N = -b; // I renamed it once I figured out what it was, the inflection point\n    float p  = c - b*b;\n    float q  = b*(2.*b*b - 3.*c) + d;\n    float p3 = p*p*p;\n    float q2 = q*q;\n    float h  = q2 + 4.*p3;\n    vec3 r;\n    if (h >= 0.)  // 1 root\n    {   \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n\n      #if 0\n        // When p≈0 and p<0, h-q has catastrophic cancelation. So, we do\n        // h=√(q²+4p³)=q·√(1+4p³/q²)=q·√(1+w) instead. Now we approximate\n        // √ by a linear Taylor expansion into h≈q(1+½w) so that the q's\n        // cancel each other in h-q. Expanding and simplifying further we\n        // get x=vec2(p³/q,-p³/q-q). And using a second degree Taylor\n        // expansion instead: x=vec2(k,-k-q) with k=(1-p³/q²)·p³/q\n        if (abs(p) < 0.001)\n        {\n            float k = p3/q;              // linear approx\n        //  float k = (1.0-p3/q2)*p3/q;  // quadratic approx \n            x = vec2(k, -k-q);  \n        }\n      #endif\n\n        vec2 uv = sign(x) * pow(abs(x), vec2(1./3.));\n        float t = uv.x + uv.y + x_N;\n        r = vec3(t, NaN, NaN);\n    } else {          // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.)) / 3.;\n        float m = cos(v);\n        float n = sqrt(3.0) * sin(v);\n        // re-order smallest first HACK by spalmer\n        r = vec3(-n-m,n-m,m+m)*z + x_N;\n    }\n    return r;\n}\n// from here http://shadertoy.com/view/3tsczH\n#endif\n\n#if 1\n// by mla http://shadertoy.com/view/mdsGDX\n// Solve depressed cubic x³+px+q = 0 and return largest real root.\nfloat CubicMla(float p, float q)\n{\n  p /= 3.0;\n  float h = q*q + 4.0*p*p*p;              // Discriminant\n  float r = sqrt(abs(h));\n  if (h >= 0.0) {\n    float u = -0.5*(q+sgn(q)*r);          // Largest magnitude root\n    float t = sgn(u)*pow(abs(u),1.0/3.0); // Cube root\n    return t - p/t;\n  } else {\n    // Find real part of 'principal' cube root of -q+ir\n    float theta = atan(r,-q);               // 0 <= theta < PI since r >= 0 -could use -r\n    return 2.0*sqrt(abs(p))*cos(theta/3.0); // Largest root\n  }\n}\n// it's nice, but only returns one root\n\n// more examples of mla, from http://shadertoy.com/view/cdjXR1\n// I reordered the results\n  // Solve x³ + 3px + q = 0\n// this one uses trig\nint dcubic1mla(float p, float q, out vec3 roots)\n{\n  float h = q*q + 4.0*p*p*p;\n  float r = sqrt(abs(h));\n  if (h >= 0.0) {\n    float u = -0.5*(q+sgn(q)*r); // Largest root of quadratic\n    float t = cbrt(u);\n    roots[0] = t - p/t;\n    return 1;\n  } else {\n    float a = atan(r,-q); // 0 <= a < PI\n    float k = 2.0*sqrt(abs(p));\n    roots = k*cos((a+pi*vec3(2,4,0))/3.0);\n    return 3;\n  }\n}\n// complex cuberoot of unity\nconst vec2 omega = 0.5*vec2(-1,sqrt(3.0));\nconst vec2 omega2 = omega*vec2(1,-1);\n// this one is all Newton-Raphson\nint dcubic2mla(float p, float q, out vec3 roots) \n{\n  float h = q*q+4.0*p*p*p;\n  float r = sqrt(abs(h));\n  if (h >= 0.0) {\n    float u = 0.5*(-q-sgn(q)*r);\n    float t = cbrt(u);\n    roots[0] = t - p/t;\n    return 1;\n  } else {\n    float k = 2.0*sqrt(abs(p));\n    vec2 t = normalize(vec2(-q,r));\n    vec2 z = (t+vec2(1,0))/6.0;\n    for (int i = 0; i < 3; i++) {\n      z = normalize(z);\n      vec2 z2 = cmul(z,z);\n      z -= cdiv(cmul(z,z2)-t,3.0*z2);\n    }\n    roots = k*vec3(cmul(z,omega).x,cmul(z,omega2).x,z.x);\n    return 3;\n  }\n}\n// definitely need shims\nvec3 Cubicmla(float d, float c)\n{\n    vec3 r;\n    int n;\n    c /= 3.; // off by factor of 3\n    //r.x = CubicMla(d * 3., c); n = 1;\n    //n = dcubic1mla(c, d, r);\n    n = dcubic2mla(c, d, r);\n    if (n == 1) r.y = r.z = NaN;\n    return r;\n}\n// I'm still confused, but perhaps if I study it more, I'll grok better.\n#endif\n\n// by spalmer\n//vec3 CubicDepress(float d, float c, float b)\n//{\n//    float x = b/-3.; // inflection point\n//    return CubicDepressed((c - 2.*x*x)*x + d, c + b*x) + x;\n//}\n// basically just inlined this and factored out x a shorter name for x_N = inflection point\n// convert to depressed cubic strips out the squared factor b by shifting x axis to the inflection point\n// solving that depressed cubic and converting the results seems simpler.  Far simpler!\n/*\n//    return Cubiciq(vec3(d, c, b)); // sanity check.  Still sane here!\n    float x_N = b / -3.; //-1./3.*b; // locate inflection point\n    float y_N = (2./9.*b*b - c)/3. * b + d; //(27.*d-9.*b*c+2.*b*b*b)/27.; //((x_N+b)*x_N+c)*x_N+d; //\n  #if 1\n    // Wikipedia way, I had Maxima substitute t - b/3 for x and got\n    //(27*t^3 + (27*c-9*b^2)*t + 27*d-9*b*c+2*b^3)/27 = 0\n    // in Horner form it's\n    //((27*t*t+27*c-9*b^2)*t+27*d-9*b*c+2*b^3)/27=0\n    float q = y_N //d - 1./3.*b*c + 2./27.*b*b*b //(27.*d-9.*b*c+2.*b*b*b)/27. //\n    , p = c-b*b/3.; //(3.*c-b*b)/3.; //(27.*c-9.*b*b)/27.; // p = − 3𝛿²\n    // seems like p is scaled by -1./3. so q probably is too\n  #else\n    // see Nickalls paper at http://nickalls.org/dick/papers/maths/cubic1993.pdf\n    // \"A new approach to solving the cubic\"\n    // substituting z = x - x_N\n    // results in depressed cubic in z\n    // z³ − 3𝛿²z + y_N = 0\n    float dldl = (b*b / 3. - c) / 3.; // δ² = (b² − 3*c) / 9\n    float q = y_N, p = -3.*dldl; // duh, the 3's cancel\n  #endif\n*/\n/*\n(%i)\tratsimp(subst(t - b/(3*a), x, (((a*x + b)*x + c)*x + d) / a = 0));\n(%o)\t(27*a^3*t^3+(27*a^2*c-9*a*b^2)*t+27*a^2*d-9*a*b*c+2*b^3)/(27*a^3)=0\n\n(%i)\tratsimp(subst(t - b/3, x, ((x + b)*x + c)*x + d = 0));\n(%o)\t(27*t^3+(27*c-9*b^2)*t+27*d-9*b*c+2*b^3)/27=0\n*/\n\n// http://en.wikipedia.org/wiki/Cubic_equation \"General cubic formula\"\n// evaluated using complex arithmetic only as much as absolutely required.\n// apparently it has some major issues in certain configurations;\n// when plotted solving SDFs for quadric bezier curves, shows\n// a really really bad discontinuity right where iq's fix for\n// catastrophic cancellation using taylor series expansion there.\n// solve reduced cubic ((x + b)*x + c)*x + d = 0\n//vec3 CubicOld(float d, float c, float b)\nvec3 CubicOld(vec3 k)\n{\n    float d = k.x, c = k.y, b = k.z;\n    float h = 27.\n    , o = -1./3.\n    , p = b*b - 3.*c\n    , j = (2.*b*b - 9.*c) * b\n    , q = j + h*d\n    , g = q*q - 4.*p*p*p // discriminant\n    ;\n    vec3 r;\n    if (g > 0.) { // 1-root case all real arithmetic\n        // FIXME why the f did I pick y as a variable name\n        float y = .5*(q + sqrt(g)), z = sign(y) * pow(abs(y), 1./3.); //scbrt(y);\n        r = vec3((b + z + p/z) * o, NaN, NaN);\n    } else { // 3-root case requires complex arithmetic\n        const vec2 E = vec2(-.5, sqrt(.75)); // primitive cube root of complex unity\n        vec2 u = vec2(q, sqrt(-g)) // q +- sqrt(-g) complex result\n        , C = sin(vec2(acos(0.), 0.) + atan(u.y, u.x) / 3.) \n            * pow(.25 * dot(u, u), 1./6.) // inlined trigonometry\n        , s1 = vec2(E.x * C.x - E.y * C.y\n                  , E.x * C.y + E.y * C.x)\n        , s0 = vec2(E.x * C.x + E.y * C.y\n                  , E.x * C.y - E.y * C.x);\n        r = (vec3(\n            (1. + p / dot(C , C )) * C .x,\n            (1. + p / dot(s0, s0)) * s0.x,\n            (1. + p / dot(s1, s1)) * s1.x\n          ) + b) * o;\n    }\n    return r;\n}\n// developed at http://shadertoy.com/view/Ns2XRd\n\n/*\n// substituting z = x - x_N where x_N = -b/3a gives\n(%i12)\t((x + b)*x + c)*x + d = 0;\n(%o12)\tx*(x*(x+b)+c)+d=0\n(%i13)\tsubst(z + x_N, x, %);\n(%o13)\t(z+x_N)*((z+x_N)*(z+x_N+b)+c)+d=0\n(%i14)\tratsimp(%);\n(%o14)\tz^3+(3*x_N+b)*z^2+(3*x_N^2+2*b*x_N+c)*z+x_N^3+b*x_N^2+c*x_N+d=0\n(%i22)  horner(%, z);\n(%o22)\tz*(z*(z+3*x_N+b)+x_N*(3*x_N+2*b)+c)+x_N*(x_N*(x_N+b)+c)+d=0\n(%i29)\tsubst(-b/3, x_N, %o22);\n(%o29)\tz*(z^2+c-b^2/3)+d-(b*(c-(2*b^2)/9))/3=0\n(%i30)\thorner(%, z);\n(%o30)\t(z*(27*z^2+27*c-9*b^2)+27*d-9*b*c+2*b^3)/27=0\nI think that'll do!\n*/\n    // that's still not an easy nut to crack though\n    // but it's a reduced cubic equation in z (notice no z^2 factor)\n    // at very least at this point I have the interface\n    // to convert a general cubic into a reduced cubic \n    // which many other solvers you see use such form \n    // and require eqn to be posed in such way already.\n/*\n ((27*z^2 + 27*c-9*b^2)*z + 27*d-9*b*c+2*b^3)/27 = 0\n ((27*z^2 + 27*c-9*b^2)*z/27 + (27*d-9*b*c+2*b^3)/27) = 0\n ((z^2 + (27*c-9*b^2)/27)*z + d + (-9*b*c+2*b^3)/27) = 0\n ((z^2 + c + -1/3*b^2)*z + d + (-9*c+2*b^2)*b/27) = 0\n*/\n/*\nsolve(z³ − 3*𝛿²*z + y_N = 0, z);\n  [\n z=((-1)/2-(sqrt(3)*%i)/2)*(sqrt(y_N^2-4*𝛿^6)/2-y_N/2)^(1/3)+(((sqrt(3)*%i)/2+(-1)/2)*𝛿^2)/(sqrt(y_N^2-4*𝛿^6)/2-y_N/2)^(1/3)\n,z=((sqrt(3)*%i)/2+(-1)/2)*(sqrt(y_N^2-4*𝛿^6)/2-y_N/2)^(1/3)+(((-1)/2-(sqrt(3)*%i)/2)*𝛿^2)/(sqrt(y_N^2-4*𝛿^6)/2-y_N/2)^(1/3)\n,z=(sqrt(y_N^2-4*𝛿^6)/2-y_N/2)^(1/3)+𝛿^2/(sqrt(y_N^2-4*𝛿^6)/2-y_N/2)^(1/3)\n]\n// think Nickalls has further tricks for reducing those\n// anyway then just take those 3 results and shift by x_N to obtain the roots of the full equation\n*/\n\n#if 0\n// solving the cubic has a long and sordid history.\n// it's way harder than it looks!\n// Cardano called these q and p though, and instead of x used t\n// actually discovered by del Ferro, rediscovered by Tartagli, \n// later published by Cardano and usually attributed thus.\n// http://en.wikipedia.org/wiki/Cubic_equation#Cardano%27s_method\n// solve t³ + p*t + q = 0\nvec3 CubicCardano(float q, float p)\n{\n// introduce variables u, v such that u + v = t, substitute, giving\n//    u³ + v³ + (3*u*v+p)*(u+v) + q = 0 \n// impose condition 3uv + p = 0, removing third term, leading to\n//    u³ + v³ = −q\n//    u*v = −p/3\n// Knowing sum and product of u³ and v³, deduce that they are the solutions\n//    (x-u³)(x-v³) = x²-(u³+v³)x+u³v³ = x²-(u³+v³)x+(uv)³ = 0\n// so\n//    x² + q*x − p³/27 = 0\n// discriminant is Δ = q² + 4*p³/27, and assuming it is positive,\n// real solutions are:\n//    − q/2 ± sqrt(q²/4 + p³/27)\n// So (without loss of generality in choosing u or v):\n//    u = cbrt(-q/2 + √︁{q²/4+p³/27))\n//    v = cbrt(-q/2 - √︁{q²/4+p³/27))\n// As u + v = t, the sum of the cube roots of these solutions is a root of the equation. That is,\n//    t = cbrt(-q/2 + √︁(q²/4+p³/27))\n//      + cbrt(-q/2 - √︁(q²/4+p³/27))\n    float qq = q*q;\n    float p3 = p*p*p;\n    float q_n2 = q/-2.;\n    float r = sqrt(qq/4. + p3/27.);\n    float d = 4.*p3 + 27.*qq;\n    if (d > 0.) {\n        float t0 = cbrt(q_n2 + r)\n                 + cbrt(q_n2 - r);\n        return vec3(t0,NaN,NaN);\n    }\n// else need transcendentals or imaginary numbers.\n// Product of the two cube roots must be –p / 3. \n// It results that a root of the equation is\n//    C − p/(3*C) with C = cbrt(−q/2 + sqrt(q²/4 + p³/27))\n// In this formula, the symbols sqrt and cbrt\n// denote any square root and any cube root.\n// The other roots of the equation are obtained\n// either by changing of cube root or, equivalently,\n// by multiplying the cube root by a primitive\n// cube root of unity, that is (−1 ± √︁(−3)) / 2\n// cbrt(−q/2 + sqrt(q²/4 + p³/27))\n    float t1 = cbrt(q_n2 + r);\n    float t2 = cbrt(q_n2 - r);\n    float t3 = cbrt(q_n2 + q_n2); // so confused here\n    vec3 a = vec3(t1,t2,t3);\n    return a - p / (3.*a);\n}\n// Nickalls mentioned that they used 𝐺 = y_N² and 𝐻=-𝛿² quantities\n// and that they began with equation with b and c divided by 3?!!\n// perhaps that's where Inigo got his method.  It might be more Cardano than the others!\n/*\n𝑎𝑥³ + 3𝑏_1𝑥² + 3𝑐_1𝑥 + 𝑑 = 0,\nand then substituting 𝑥 = 𝑧 − 𝑏_1/𝑎 to generate a reduced equation of the form\n𝑎𝑧³ + 3𝐻/𝑎*𝑧 + 𝐺/𝑎² = 0,\nwhere\n𝐻 = 𝑎𝑐_1 − 𝑏_1² and 𝐺 = 𝑎²𝑑 − 3𝑎𝑏_1𝑐_1 + 2𝑏_1³\nSubsequent development yields a discriminant of the form 𝐺² + 4𝐻³\n*/\n// I give up, haven't gotten it working yet, \n// and figure since it's not ideal, am wasting time on it.\n#endif\n\n#if 0\n// should try Viète's approach TODO\n// http://en.wikipedia.org/wiki/Cubic_equation#Vieta's_substitution\n// substite t = w - p/3w transforms depressed cubic into\n//    w³ + q - p³/27w³ = 0\n// Multiplying by w3, one gets a quadratic equation in w³:\n//    (w³)² + q*w³ - p³/27 = 0\n// Let\n//    W = -q/2 ± √︁(p³/27 + q²/4)\n// be any nonzero root... then I get lost how to convert back to actual root\nvec3 CubicVieta(float q, float p)\n{\nreturn vec3(0);\n    //float p_3 = p/3.;\n    // w = t + p_3*(t + p_3);\n    // t = w - p_3*w;\n    //return vec3(w0,w1,w2)\n}\n// meh, all this substitution just confuses me greatly\n// this is the problem with math on Wikipedia and\n// pretty much all published math, that it's basically all\n// just disjointed ramblings throwing letters around willy-nilly\n// introducing variables at a whim and expecting the reader\n// to keep it all straight.  It's like programming in some\n// really terribly ambiguous programming language, where\n// the programmer decides to change the meaning and type of variables\n// and may, if you're lucky, decide to document it in the comments.\n// Implementation left as an exercise to the reader.  Bah.\n#endif\n\n#if 0\n// bunch of solvers salvaged from Bezier Quadric at http://shadertoy.com/view/3tsczH\n\n// spalmer converted Bloxard solver into depressed cubic solver\nvec3 CubicBloxard(float d, float c)\n{\n// x_N = b = 0.; a = 1.;\n\tfloat p = c;\n    float p3 = c*c*c; //p*p*p; // the only place you ever see p3 is in conjunction with this mystical 3³ = 27 quantity\n    float s = c*c*c/27.; // so give that thing a name! it's (c/3)³\n\tfloat q = d;\n\tfloat e = q*q + 4.*s; //p3/27.;\n\tif (e > 0.)\n\t{ \n\t\tfloat z = sqrt(e);\n\t\tvec2 x = (vec2(z,-z) - q) * .5;\n        if (abs(p) < .004)\n        { // credit: iq\n            float k = s/q; //p3/27./q;              // linear approx\n            //float k = (1.-s/(q*q))*s/q;  //(1.-p3/27./(q*q))*p3/27./q;  // quadratic approx \n            x = vec2(k,-k-q);\n        }\n\t\tvec2 j = cbrt(x); //sign(x) * pow(abs(x), vec2(1./3.));\n\t\treturn vec3(j.x + j.y, NaN, NaN);\n\t}\n\tfloat v = acos(-sqrt(-1./s) * q/2.) / 3.; //acos(-sqrt(-27./p3) * q/2.) / 3.; //\n\tfloat m = cos(v), n = sqrt(3.) * sin(v);\n\treturn vec3(-n - m, n - m, m + m) * sqrt(-p / 3.);\n}\n// cleaned but FIXME now the interface is backwards for this toy, which means this toy is wrong\nvec3 CubicBloxard(vec3 K)\n{\n    float d = K.x, c = K.y, b = K.z; //, a = 1.; //\n\tfloat x_N = -b / 3.;\n\tfloat p = c-b*b/3., p3 = p*p*p;\n\tfloat q = b*(2.*b*b-9.*c)/27.+ d;\n\tfloat e = q*q + 4.*p3/27.; // discriminant is like 4x what wikipedia says\n\tif (e > 0.)\n\t{ \n\t\tfloat z = sqrt(e);\n\t\tvec2 x = (vec2(z,-z) - q) * .5;\n        // credit: iq from comment at http://shadertoy.com/view/dsfGWN \n        // led me back to http://shadertoy.com/view/MlKcDD\n        if (true && abs(p) < .004)\n        {\n            // When p≈0 and p<0, h-q has catastrophic cancelation. So, we do\n            // h=√(q²+4p³)=q·√(1+4p³/q²)=q·√(1+w) instead. Now we approximate\n            // √ by a linear Taylor expansion into h≈q(1+½w) so that the q's\n            // cancel each other in h-q. Expanding and simplifying further we\n            // get x=vec2(p³/q,-p³/q-q). And using a second degree Taylor\n            // expansion instead: x=vec2(k,-k-q) with k=(1-p³/q²)·p³/q\n            //float kx = b/3., ky = c/3., kz = d; //float kx = b/3., ky = c/3., kz = d;\n            float P = c/3. - b*b/9.; //ky - kx*kx;\n            float P3 = P*P*P;\n            float Q = b/3.*(2.*b/3.*b/3. - 3.*c/3.) + d; //kx*(2.*kx*kx - 3.*ky) + kz; // iq's q is scaled differently\n            float k = P3/Q;              // linear approx\n            //float k = (1.-P3/(Q*Q))*P3/Q;  // quadratic approx \n            x = vec2(k,-k-Q);\n        }\n\t\tvec2 uv = sign(x) * pow(abs(x), vec2(1./3.));\n\t\treturn vec3(x_N + uv.x + uv.y, NaN, NaN);\n\t}\n\tfloat v = acos(-sqrt(-27./p3) * q/2.) / 3.;\n\tfloat m = cos(v), n = sqrt(3.) * sin(v);\n    // spalmer ordered 3 roots small to large\n\treturn vec3(-n - m, n - m, m + m) * sqrt(-p / 3.) + x_N;\n}\n\n// trigonometric solver by bloxard, golfed by Fabrice, ungolfed & cleaned by spalmer\n// http://shadertoy.com/view/XdB3Ww\nvec2 solveCubicfablox(vec3 v) // 4th coeff is always 1.0, must normalize equation thus\n{\n    float a = v.x, b = v.y, c = v.z\n    , f = -1./3. * a // was called ofs before\n\t, p  = b + a*f\n\t, p3 = p*p*p\n    // TODO p3/27. comes up at least twice, once inverted\n\t, q  = 1./27. * a * (2.*a*a - 9.*b) + c\n\t, d  = q*q + 4./27. * p3;    \n\tif (d > 0.) {\n\t\tvec2 x = (vec2(1,-1) * sqrt(d) - q) * .5;\n\n        // credit: iq from comment at http://shadertoy.com/view/dsfGWN \n        // led me back to http://shadertoy.com/view/MlKcDD\n        if (abs(p) < .004)\n        {\n            //float p  = ky - kx*kx;\n            //float q  = kx*(2.0*kx*kx - 3.0*ky) + kz;\n            // When p≈0 and p<0, h-q has catastrophic cancelation. So, we do\n            // h=√(q²+4p³)=q·√(1+4p³/q²)=q·√(1+w) instead. Now we approximate\n            // √ by a linear Taylor expansion into h≈q(1+½w) so that the q's\n            // cancel each other in h-q. Expanding and simplifying further we\n            // get x=vec2(p³/q,-p³/q-q). And using a second degree Taylor\n            // expansion instead: x=vec2(k,-k-q) with k=(1-p³/q²)·p³/q\n            float kx = a/3., ky = b/3., kz = c;\n            float P = ky - kx*kx;\n            float P3 = P*P*P;\n            float Q = kx*(2.*kx*kx - 3.*ky) + kz; // iq's q is scaled differently\n            float k = P3/Q;              // linear approx\n            //float k = (1.-P3/(Q*Q))*P3/Q;  // quadratic approx \n            x = vec2(k,-k-Q); //-k-Q, k); //\n            //x += .67*f*f*f;\n        }\n\n        x = sign(x) * pow(abs(x), vec2(1./3.));\n        // FIXME now just need to consolidate these two tests on different sides of the cbrt into one codepath\n        if (abs(p) < .004)\n            return vec2(x.x + x.y - a/3., NaN);\n  \t\treturn vec2(x.x + x.y + f, NaN);\n  \t}\n \tfloat w = acos(max(-1., -sqrt(max(0., -27./p3))*q*.5)) / 3.,\n \t      m = cos(w);\n\treturn vec2(m+m, -sqrt(3.)*sin(w)-m) * sqrt(-p/3.) + f;\n}\n// \t      n = sin(w)*sqrt(3.);\n//\treturn vec2(m+m,-n-m) * sqrt(-p/3.) + ofs; // old extra temporary used once\n\n// Finds roots using Cardano's method. http://wikipedia.org/wiki/Cubic_equation#Cardano's_formula\n// Apparently, must have got the idea to solve Cardano's method using trigonometry \n// from Vieta http://wikipedia.org/wiki/Cubic_equation#Trigonometric_and_hyperbolic_solutions\n// due to the presence of 27./p3, but perhaps this precise trig solution came later.\n\n// Per Bloksgaard refactored\n// Find roots using Cardano's method.\n// http://en.wikipedia.org/wiki/Cubic_equation#Cardano%27s_method\n// by bloxard http://shadertoy.com/view/dsX3RM\n// a's and c's reversed vs traditional naming.\nvec2 solveCubic2(float a, float b, float c)\n{\n\tfloat p = b-a*a/3., p3 = p*p*p;\n\tfloat q = a*(2.*a*a-9.*b)/27.+ c;\n\tfloat d = q*q + 4.*p3/27.;\n\tfloat offset = -a / 3.;\n\tif(d>0.)\n\t{ \n\t\tfloat z = sqrt(d);\n\t\tvec2 x = (vec2(z,-z) - q) * .5;\n        // credit: iq from comment at http://shadertoy.com/view/dsfGWN \n        // led me back to http://shadertoy.com/view/MlKcDD\n        if (abs(p) < .004)\n        {\n            // When p≈0 and p<0, h-q has catastrophic cancelation. So, we do\n            // h=√(q²+4p³)=q·√(1+4p³/q²)=q·√(1+w) instead. Now we approximate\n            // √ by a linear Taylor expansion into h≈q(1+½w) so that the q's\n            // cancel each other in h-q. Expanding and simplifying further we\n            // get x=vec2(p³/q,-p³/q-q). And using a second degree Taylor\n            // expansion instead: x=vec2(k,-k-q) with k=(1-p³/q²)·p³/q\n            float kx = a/3., ky = b/3., kz = c;\n            float P = ky - kx*kx;\n            float P3 = P*P*P;\n            float Q = kx*(2.*kx*kx - 3.*ky) + kz; // iq's q is scaled differently\n            float k = P3/Q;              // linear approx\n            //float k = (1.-P3/(Q*Q))*P3/Q;  // quadratic approx \n            x = vec2(k,-k-Q);\n        }\n\t\tvec2 uv = sign(x)*pow(abs(x), vec2(1./3.));\n\t\treturn vec2(offset + uv.x + uv.y);\n\t}\n\tfloat v = acos(-sqrt(-27./p3)*q/2.)/3.;\n\tfloat m = cos(v), n = sin(v)*sqrt(3.); //1.732050808;\n\treturn vec2(m + m, -n - m) * sqrt(-p / 3.0) + offset;\n}\nvec2 solveCubicBloxard(vec3 v)\n{\n    return solveCubic2(v.x, v.y, v.z);\n}\n// same glitch though\n\n// neat.  But doesn't solve the glitch.\n// Kohler  below\n// note that the cos(acos(theta)/3.) stuff is due to \n// the arrangement of the solutions on an equilateral \n// triangle inscribed in a circle centered on the Mid(curve) point!!!\n// a trigonometric solver by JohanKohler at http://shadertoy.com/view/Md3XD4\n// (possibly actually his friend Adrian Stephens) \n// approximates cos,sin of (acos(x)/3.)\nvec2 cossin_third(float x) \n{\n  #if 1 \n    // polynomial aproximation of cos(acos(x)/3)\n    float c = (((.0161423 * x + .431996) * x + 1.25203) * x + .866017)\n        / ((.312933 * x + 1.25325) * x + 1.);\n    // FIXME horner - compiler will optimize anyway\n    //float c = (.866017 + 1.25203 * x + .431996 * x * x + .0161423 * x * x * x)\n    //    / (1. + 1.25325 * x + .312933 * x * x);\n  #else\n    // honestly, the compiler implements acos\n    // using a similar polynomial anyway!\n    float c = cos(acos(x)/3.);\n  #endif\n    float s = sqrt(1. - c * c); // btw sin(x) = sqrt(1.-cos(x)*cos(x))\n    return vec2(c, s);\n} // either way, has same bug :( otherwise I'd consider extracting wrapper for use by others\n// see also iq http://shadertoy.com/view/WltSD7\n// I believe Kohler's spline setup was derived from bloxard's.\n// Solve cubic equation for roots - Kohler involved too?\nvec3 solveCubicStephens(vec3 v)\n{\n    float a = v.x, b = v.y, c = v.z\n    , f = a / -3.\n    , p = b + a*f\n    , p3 = p*p*p\n    , q = a * (2.*a*a - 9.*b) / 27. + c\n    , d = q*q + 4.*p3 / 27.;    \n    if (d >= 0.) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.;\n        x = sign(x)*pow(abs(x), vec2(1./3.));\n        return vec3(f + x.x + x.y);\n    }    \n    vec2 cs = cossin_third(-sqrt(-27. / p3) * q / 2.);\n    float m = cs.x, n = cs.y * sqrt(3.);\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.) + f;\n}\n\n// my stab at it from http://shadertoy.com/view/flyGDD\n// apparently has its own special issues!\n// yeah it has some real problems, all right.  Worse than bloxard's, for sure.\n// TODO wth do these letters mean anyway?  document coeff order!!!\nfloat Linear(float b, float a)\n{\n    return -b / a;\n}\n\nvec2 Quadratic(float c, float b, float a)\n{\n    if (a == 0.)\n        return vec2(Linear(c, b), NaN); // handle malformed eqn\n    float n = b * b - 4. * a * c; // discriminant\n    return n < 0. ? vec2(NaN) :\n        .5 / a * (sign(a) * sqrt(n) * vec2(-1, 1) - b); // two solutions, lesser first (may be identical)\n}\n// http://en.wikipedia.org/wiki/Cubic_equation \"General cubic formula\"\n// evaluated using complex arithmetic only as much as absolutely required.\nvec3 Cubic(float d, float c, float b, float a)\n{\n    if (a == 0.)\n        return vec3(Quadratic(d, c, b), NaN); // handle malformed eqn\n    float h = 27.*a*a\n    , o = -1./3./a\n    , p = b*b - 3.*a*c\n    , j = (2.*b*b - 9.*a*c) * b\n    , q = j + h*d\n    , g = q*q - 4.*p*p*p // discriminant\n    ;\n    vec3 r;\n    if (g > 0.) { // 1-root case all real arithmetic\n        float y = .5*(q + sqrt(g)), z = sign(y) * pow(abs(y), 1./3.); //scbrt(y);\n        r = vec3((b + z + p/z) * o, NaN, NaN);\n    } else { // 3-root case requires complex arithmetic\n        const vec2 E = vec2(-.5, sqrt(.75)); // primitive cube root of complex unity\n        vec2 u = vec2(q, sqrt(-g)) // q +- sqrt(-g) complex result\n        , C = sin(vec2(acos(0.), 0.) + atan(u.y, u.x) / 3.) // cossin_third stuff\n            * pow(.25 * dot(u, u), 1./6.) // inlined trigonometry\n        //; \n        //mat2 M = mat2(E * vec2(1,-1), E.yx); vec2\n        //  s1 = M * C\n        //, s0 = C * M;\n        , s0 = vec2(E.x * C.x - E.y * C.y\n                  , E.x * C.y + E.y * C.x)\n        , s1 = vec2(E.x * C.x + E.y * C.y\n                  , E.x * C.y - E.y * C.x);\n        r = (vec3( // these max did not help btw\n            (1. + p / max(1e-7, dot(C , C ))) * C .x,\n            (1. + p / max(1e-7, dot(s0, s0))) * s0.x,\n            (1. + p / max(1e-7, dot(s1, s1))) * s1.x\n          ) + b) * o;\n        if (a < 0.)\n            r.xz = r.zx; // order 3-root case\n    }\n    return r;\n}\n// well I'll be damned if mine doesn't have an even *worse* glitch at the same damn place!!!\nvec3 solveCubicspalmer(vec3 v)\n{\n    return Cubic(v.z, v.y, v.x, 1.);\n}\n\n// spalmer extracted cubic solver from iq's http://shadertoy.com/view/DdlGD8\n// The MIT License\n// Copyright © 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// (cubic coeff == 1 always here)\n// the cubic is a bit different at this point than for the usual cubic solver formulation\n// TODO clean all this up and re-optimize\nvec3 solveCubiciq(vec3 c)\n{\n    float kx = c.z, ky = c.y, kz = c.x;\n    float p  = ky - kx*kx;\n    float q  = (2.0*kx*kx - 3.0*ky)*kx + kz;\n    float p3 = p*p*p;\n    float q2 = q*q;\n    float h  = q2 + 4.0*p3;\n    vec3 r;\n    if (h >= 0.)  // 1 root\n    {\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h) - q)/2.0;\n\n      #if 1\n        // When p≈0 and p<0, h-q has catastrophic cancellation. So, we do\n        // h=√(q²+4p³)=q·√(1+4p³/q²)=q·√(1+w) instead. Now we approximate\n        // √ by a linear Taylor expansion into h≈q(1+½w) so that the q's\n        // cancel each other in h-q. Expanding and simplifying further we\n        // get x=vec2(p³/q,-p³/q-q). And using a second degree Taylor\n        // expansion instead: x=vec2(k,-k-q) with k=(1-p³/q²)·p³/q\n        if (abs(p) < 0.001)\n        {\n            float k = p3/q;              // linear approx\n        //  float k = (1.0-p3/q2)*p3/q;  // quadratic approx \n            x = vec2(k, -k-q);  \n        }\n      #endif\n\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x+uv.y-kx;\n        r = vec3(t, NaN, NaN); //t, t, t); //t, 0., 1.); //\n    } else {          // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sqrt(3.0)*sin(v);\n        r = vec3(m+m, -n-m, n-m)*z - kx;\n        // third root can never be closest, though\n    }\n    return r;\n}\n// solve ((t + k.z)*t + k.y)*t + k.x = 0 for t\nvec3 solveCubicspalmeriq(vec3 k)\n{\n    k = vec3(k.x, k.y / 3., k.z / 3.); // convert coeffs for use by iq special solver\n    return solveCubiciq(k);\n}\n// should inline all that\n#endif\n\n// choose cubic equation solver method,\n// specialized to return only the two closer of 3 possible real roots\n// as parametric indices to the equation\n// solve ((t + a.z)*t + a.y)*t + a.x = 0 for t\n// OLD old shim interface, shouldn't need it anymore at all\nvec2 solveCubicReal(vec3 a)\n{\n    return CubicBloxard(a).zx;\n//    return solveCubicspalmeriq(a).xy;\n//    return solveCubicfablox(a.zyx);\n//    return solveCubicStephens(a.zyx).xy;\n//    return solveCubicBloxard(a.zyx);\n//    return solveCubicspalmer(a.zyx).xy;\n}\n// think those all (mostly) work now\n\n\n/*\n// numeric display based on https://shadertoy.com/view/llySRh\n// for debugging the coeffs that break the algo\n#define Font iChannel0\nfloat char(vec2 p, int c)\n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.)\n        return 0.;\n    vec2 q = p/16. + fract(vec2(c, 15-c/16) / 16.);\n    vec4 t = textureLod(Font, q, 0.);\n    // probably not perfect but seems ok\n    float scale = 64./(1.+dot(fwidth(q), vec2(1))); //(abs(dFdx(q.x))+abs(dFdy(q.y))); //length(fwidth(p)); //\n    scale = clamp(scale, 1./1024., 1024.);\n    float g = t.a; // a unorm-encoded signed distance\n    g = .5 - (g - .5) * scale; // antialiasing\n    g = clamp(g, 0., 1.);\n    return g;\n}\n    //float w = scale/16.;// /iResolution.y; //.05; //\n    //g = clamp(.5 - 1./w * (t.w-.5), 0., 1.); //\n    //g = smoothstep(.5+w,.5-w, t.w); // aa sdf - could probably do pixel perfect with a bit more effort\n    //g = clamp(.5 - (t.w - .5) * 8./scale; // yeah but we need scale info, maybe do the scaling here?\n\n// display unsigned int up to 4 digits base 10\nfloat pUint(vec2 p, float n)\n{\n    float v = 0.;\n    for (int i = int(n); i > 0; i /= 10, p.x += .5)\n        v += char(p, 48 + i%10);\n    if (abs(n) < 1e-7)\n        v += char(p, 48);\n    return v;\n}\n\n// display unsigned int 4 digits base 10\nfloat pUint4(vec2 p, float n)\n{\n    float v = 0.;\n    for (int i = int(n), d = 4; d-- > 0; i /= 10, p.x += .5)\n        v += char(p, 48 + i%10);\n    return v;\n}\n\nfloat pSign(vec2 p, inout float n)\n{\n    float v = 0.;\n    if (n < 0.) v += char(p + vec2(.5,0), 45), n = -n;\n    return v;\n}\n\n// display signed int4\nfloat pInt(vec2 p, float n)\n{\n    float v = 0.;\n    v += pSign(p, n); // p.x -= 2.;\n    v += pUint(p, n);\n    return v;\n}\n\n// display signed float4.4\nfloat pFloat(vec2 p, float n)\n{\n    float v = 0.;\n    v += pSign(p, n); p.x -= 2.;\n    v += pUint(p, floor(n)); p.x -= .5;\n    v += char(p, 46); p.x -= 2.;\n    v += pUint4(p, fract(n)*1e4);\n    return v;\n}\n*/\n\n    /*if (true)\n    {\n        c = vec4(0,0,0,1);\n             if (p.y <  60.) c += pFloat((p - vec2(0,  0))/60., coeff[0]);\n        else if (p.y < 120.) c += pFloat((p - vec2(0, 60))/60., coeff[1]);\n        else if (p.y < 180.) c += pFloat((p - vec2(0,120))/60., coeff[2]);\n        else if (p.y < 240.) c += pFloat((p - vec2(0,180))/60., coeff[3]);\n        return;\n    }*/\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flyGDD.jpg", "access": "api", "license": "cc0-1.0", "functions": [[960, 986, 1025, 1025, 1317], [1319, 1333, 1360, 1360, 1508], [1758, 1855, 1887, 1887, 2030], [2032, 2197, 2217, 2286, 2406], [2629, 2629, 2676, 2676, 2881], [2883, 3380, 3394, 3394, 4433], [4435, 4455, 4473, 4473, 4502], [4504, 4532, 4567, 4567, 4658], [4660, 4660, 4679, 4679, 4715], [4717, 4802, 4858, 4858, 5130], [5132, 5132, 5151, 5151, 5988], [5990, 5990, 6026, 6026, 6121]], "test": "untested"}
{"id": "7lV3DD", "name": "MLS Reintegration v2", "author": "michael0884", "description": "Combining MPM-MLS with reintegration tracking. The main idea here is to add forces while advecting mass, not before. \nFixed by removing the divergent part of the affine matrix. Also the matrix is reduced for low densities to remove \"splash curling\"", "tags": ["fluid", "particles", "reintegration", "mpm", "apic"], "likes": 44, "viewed": 1279, "published": 3, "date": "1637764977", "time_retrieved": "2024-07-30T18:46:16.430234", "image_code": "//MIT License\n//Copyright 2021 Mykhailo Moroz\n\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb); \t\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    P = floor(P);\n    \n    if(iMouse.z < 0.)\n    {\n       // P = iMouse.xy + 200.*(P/R.x - 0.5); \n    }\n    \n    float m = 0.0;\n    float rho = 0.0;\n    vec2 v = vec2(0.0);\n    float curl = 0.0;\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        //load data\n        vec2 di = vec2(i,j);\n        vec4 data0 = A(P + di);\n        vec4 data1 = B(P + di);\n        \n        //unpack data\n        float m0 = data0.y;\n        vec2 x0 = decode(data0.x) - fract(P);\n        vec2 v0 = decode(data1.x);\n        mat2 B0 = mat2(decode(data1.y),decode(data1.z)); //velocity gradient\n        //update particle position\n        x0 = x0 + di + v0*dt;\n        \n        //find cell contribution\n        vec3 o = overlap(x0, vec2(1.0));\n        \n        m += m0*o.z;\n        \n        float w = k1(x0);\n        \n        v += (v0 + 0.0*B0*x0)*w;\n        curl += w*(x0.x*v0.y - x0.y*v0.x); \n        rho += m0*w;\n    }\n    \n    float arg = 0.5*(atan(v.y, v.x)/PI + 1.0);\n    float d = 15.5*curl;\n    //vec3 fluid =step(-d, 0.)*tanh(d)*vec3(0.996,0.345,0.345) - step(d, 0.)*tanh(d)*vec3(0.220,0.741,1.000);\n    vec3 fluid = hsv2rgb(vec3(arg, 0.5, 1.5*dot(v,v) + 1.5*abs(d)));\n    C = mix(vec4(1.0), vec4(fluid,1.0), smoothstep(0.2, 1.2, rho));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R;\nvec4 Mouse;\nfloat time;\nint frame;\n\n#define A(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define B(p) texelFetch(iChannel1, ivec2(mod(p,R)), 0)\n\n#define CH(c, p) texelFetch(c, ivec2(mod(p,R)), 0)\n\n//loop in range\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 0.6\n#define max_vel 1.0\n#define rad 2\n\n#define diffusion 0.4\n#define gravity 0.005\n\n#define PI 3.14159265\n\n#define rest_rho 1.0\n#define eos_pressure 0.5\n\n//pressure equation of state\nfloat pressure(float rho)\n{\n    return 2.2*(rho - 1.2); //gas\n   // return eos_pressure*(pow(rho/rest_rho,4.) - 1.0); //Tait EOS (water)\n}\n\nvoid InitialConditions(inout float m, inout vec2 v, vec2 P)\n{\n    vec2 dx = P - R*vec2(0.3, 0.5);\n\n    float d = smoothstep(R.y*0.5, R.y*0.49, length(dx));  \n    m = 0.0*d;\n\n    v = d*0.3*normalize(vec2(dx.y,-dx.x));\n}\n\n//KERNEL FUNCTIONS\n\nfloat k0(vec2 dx) //linear kernel\n{\n    vec2 k = max(1.0 - abs(dx), 0.);\n    return k.x*k.y;\n}\n\nvec3 K0(vec2 dx) //linear kernel with the center of mass\n{\n    vec2 k = max(1.0 - abs(dx), 0.);\n    return vec3(dx*0.5, k.x*k.y);\n}\n\nfloat k1(vec2 dx) //quadratic kernel\n{\n    vec2 f = max(1.5 - abs(dx), 0.0);\n    vec2 k = min(max(0.75 - dx*dx, 0.5), 0.5*f*f);\n    return k.x*k.y;\n}\n\n//box size enstimator\nvec2 destimator(vec2 dx)\n{\n    return diffusion*dt+clamp(1.0 - 2.0*abs(dx), 0.001, 1.0);\n}\n\n//box overlap with center of mass\nvec3 overlap(vec2 dx, vec2 box)\n{\n    vec2 min0 = max(dx - box*0.5, -0.5); \n    vec2 max0 = min(dx + box*0.5, 0.5); \n    vec2 size = max(max0 - min0, 0.); \n    return vec3(0.5*(max0 + min0), size.x*size.y/(box.x*box.y));\n}\n\n//boundary\n#define border_h 3.\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -border_h-sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n\n    return bound;\n}\n\n#define h 5.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\n//DATA PACKING\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X)*3.0; \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x/3.0);\n    return uintBitsToFloat(X); \n}\n\n//particle to grid\nvec4 P2G(sampler2D a, sampler2D b, vec2 P)\n{\n    vec2 x = vec2(0.0);\n    vec2 v = vec2(0.0);\n    float m = 0.0;\n    float rho = 0.0;\n    \n    range(i, -1, 1) range(j, -1, 1)\n    {\n        //load data\n        vec2 di = vec2(i,j);\n        vec4 data0 = CH(a, P + di);\n        vec4 data1 = CH(b, P + di);\n        \n        //unpack data\n        float m0 = data0.y;\n        float r0 = data0.w;\n        vec2 x0 = decode(data0.x);\n        vec2 v0 = decode(data1.x);\n        mat2 B0 = mat2(decode(data1.y),decode(data1.z)); //velocity gradient\n        \n        //estimate the shape of the distribution\n        vec2 box = destimator(x0);\n        \n        //update particle position\n        x0 = x0 + di + v0*dt;\n    \n        //find cell contribution\n        vec3 o = overlap(x0, box);\n         \n        //update distribution\n        x += m0*o.xy*o.z;\n        m += m0*o.z;\n        \n        //find grid node contribution\n        float w = k1(x0);\n        \n        //distribute momentum onto grid\n        v += (v0 + B0*x0)*w*m0;\n        rho += m0*w;\n    }\n    \n    \n    //normalize\n    if(rho > 0.0) v /= rho;\n    if(m > 0.0) x /= m;\n    \n   // m = mix(m, 0.3, dt*0.002);\n   \n    if(length(P - R*vec2(0.8 + 0.05*sin(2.4*time), 0.9)) < 10.) \n    {\n        x = vec2(0.0);\n        v = 1.8*Dir(-PI*0.25 - PI*0.5 + 0.45*sin(3.4*time));\n        m = mix(m, rest_rho, 0.4*dt);\n    }\n\n    if(length(P - R*vec2(0.2+ 0.05*sin(2.4*time), 0.9)) < 10.) \n    {\n       x = vec2(0.0);\n        v =1.8*Dir(-PI*0.25 + 0.45*sin(3.4*time));\n        m = mix(m, rest_rho, 0.4*dt);\n    }\n    \n    //initial conditions\n    if(frame < 1)\n    {\n        InitialConditions(m, v, P);\n    }\n    \n    v = (length(v)>max_vel)?normalize(v)*max_vel:v;\n    \n    return vec4(encode(x), m, encode(v), rho);\n}\n\n//grid to particle\nvec4 G2P(sampler2D a, sampler2D b, vec2 P)\n{\n    vec2 V = vec2(0.0);\n    mat2 B = mat2(0.0);\n    \n    vec4 data = CH(a, P);\n    float m = data.y;\n    vec2 x = decode(data.x);\n    float mass = 0.0;\n    \n    range(i, -1, 1) range(j, -1, 1)\n    {\n        //load data\n        vec2 di = vec2(i,j);\n        vec4 data0 = CH(a, P + di);\n        \n        //unpack data\n        float m0 = data0.y;\n        float rho = data0.w;\n        vec2 x0 = decode(data0.x);\n        vec2 dx = x - di;\n        vec2 v0 = decode(data0.z);\n        \n        //find grid node contribution\n        float w = k1(dx);\n        \n        //distribute velocities/forces to particles\n        V += v0*w;\n        vec2 nv0 =dot(v0, normalize(dx))*normalize(dx);\n        //v0 = v0 - nv0 + clamp(nv0, -0.01, 0.01);//remove divergent component, makes it unstable otherwise\n        B += mat2(v0*dx.x,v0*dx.y)*w;\n        \n        mass += rho*w;\n    }\n    \n    float divergence = 0.5*(B[0][0] + B[1][1]);\n    \n    B -= 2.*mat2(divergence);\n    \n    B = B - B*dt*smoothstep(1.0, 0.8, m);\n    \n    B = mat2(clamp(B[0], -0.1,0.1),clamp(B[1], -0.1,0.1))*4.0;\n    \n    //gravity\n    V += -gravity*vec2(sin(0.),cos(0.))*dt;\n    \n    //push fluid\n    V += vec2(0.0, 1.0)*exp(-0.02*pow(distance(P, R*vec2(0.6,0.2)), 2.));\n    \n    if(Mouse.z > 0.)\n    {\n        vec2 dx = (Mouse.xy - P); \n        V += 0.001*exp(-0.03*length(dx))*dt*dx; \n    }\n    \n    //border \n    vec3 N = bN(P + x);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, V);\n\n    V += (0. + 1.5*max(vdotN, 0.0))*N.xy*smoothstep(4.0, 1.0, N.z);\n   \n    V = (length(V)>max_vel)?normalize(V)*max_vel:V;\n   \n    x += V*dt;\n    \n    //precompute pressure\n    //predicted density using the affine matrix, thanks to Grant Kot for this idea\n    float press = -clamp(pressure(mass/determinant(mat2(1.0) + B*dt)), -5., 5.);\n    \n    //we can just add the pressure to the affine matrix, since it will change the divergence anyway\n    B += mat2(press)*dt;\n   \n    return vec4(encode(V), encode(B[0]), encode(B[1]), press);\n}\n\n", "buffer_a_code": "//Advect mass distributions and distrubute the momentum and density to grid\n\n//Advect + P2G\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse; frame = iFrame;\n    P = floor(P);\n   \n    C = P2G(iChannel0,iChannel1,P);\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//Distribute grid velocities to the mass distributions\n\n//G2P\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse; frame = iFrame;\n    P = floor(P);\n    C = G2P(iChannel0, iChannel1, P);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//Advect + P2G\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse; frame = iFrame;\n    P = floor(P);\n   \n    C = P2G(iChannel0,iChannel1,P);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//G2P\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse; frame = iFrame;\n    P = floor(P);\n    C = G2P(iChannel0, iChannel1, P);\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lV3DD.jpg", "access": "api", "license": "mit", "functions": [[48, 48, 75, 75, 233]], "test": "untested"}
{"id": "7tK3DW", "name": "Colored Spiral", "author": "SnoopethDuckDuck", "description": "wanted to make a grid of arrows, then got distracted", "tags": ["e"], "likes": 33, "viewed": 605, "published": 3, "date": "1637758941", "time_retrieved": "2024-07-30T18:46:17.207157", "image_code": "float thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nfloat arrow(vec2 uv) {\n    float h = 0.1;\n    h += 0.2 * thc(4.,-40. * length(uv) + 3. * atan(uv.y,uv.x) + iTime);\n    h += 0.5 * (0.5 + 0.5 * thc(2., length(uv)*3. - iTime));\n    float d = sdEquilateralTriangle(uv-vec2(0.,0.25 - h));\n    float s = 1.-smoothstep(-0.4,0.4,d+0.5);\n\n    float d2 = sdBox(uv - vec2(0.,-h), vec2(0.05,0.2));\n    float s2 = 1.-smoothstep(-0.4,0.4,d2);\n    \n    s += s2;\n    return s;\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvec2 rot(vec2 uv, float a) {\n    mat2 mat = mat2(cos(a), -sin(a), \n                    sin(a), cos(a));\n    return mat * uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    float a = atan(uv.y, uv.x);\n    float r = log(length(uv));\n    \n    float l = min(1., tanh(0.2 * iTime)/0.95);\n    // 30000000. * a\n    r *= 0.6 + 0.25 * l * thc(1., 3. * a + 2. * length(uv) - iTime);\n\n    //float h = floor(8. * fract(0.1 * iTime)); // do h * a\n    uv = rot(uv, iTime +  7. * a + 3.1415 * cos(9. * r + a - iTime));\n\n    float s = arrow(uv);\n    s *= 1. + 0.3 * s;\n\n    vec3 col = 0.5 * s + s * pal(thc(2., s + 9. * r + a- iTime)  - 0.5 * iTime, vec3(1.), vec3(1.), vec3(1.), cos(s + iTime) * vec3(0.,1.,2.)/3.);\n    //col *= smoothstep(0.,0.1,0.5-length(uv));\n    col = mix(col, vec3(1, .97, .92)*2., smoothstep(0., 3.5, -r));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "float sdEquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tK3DW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 70], [72, 72, 101, 101, 142], [144, 144, 166, 166, 557], [559, 559, 627, 627, 670], [672, 672, 692, 692, 767], [769, 769, 797, 797, 895], [897, 897, 954, 954, 1700]], "test": "untested"}
{"id": "7lVGWW", "name": "The Cell Void", "author": "lambmeow", "description": "testing out voronoi in 3d space", "tags": ["voronoi", "sdf", "cellular", "void"], "likes": 5, "viewed": 375, "published": 3, "date": "1637746961", "time_retrieved": "2024-07-30T18:46:17.971114", "image_code": "#define time (iTime + 100.)\n\n//color\n//#define COLOR\n\n//see all spheres\n//#define SHOW_ALL\n\n\nvec3 rand(vec3 p)\n{\n    float x = dot(p, vec3(105.2523, 323.6236, 246.634)),\n    y = dot(p , vec3(225,123.35235,352.235)),\n    z = dot(p, vec3(373,164.352,273.46343));\n    \n    return fract(sin(vec3(x,y,z))* 45364.623624);\n}\n\nmat2 rot(float a)\n{\n    float c= cos(a), s = sin(a);\n    \n    return mat2(c,-s,s,c);\n}\nvec4 voro(vec3 p)\n{\n    vec3 ip = floor(p), fp = fract(p);\n    \n    float dd = 1.;\n    vec3 pos = vec3(0);\n    for(int i = -1; i <= 1; i++)\n    {\n        for(int j = -1; j <= 1; j ++)\n        {\n            for(int k = -1; k <= 1; k++)\n            {\n                vec3 n = vec3 (j, i ,k); \n                vec3 o = ip + n;\n                //o.xy *= rot(iTime * 0.01) *0.01;\n                vec3 p = rand(o);\n                \n                //p.xz += 0.25 * sin(iTime + p.x) + cos(p.z + iTime) * 0.25;\n                float d = length(n + p - fp);\n            \n                if(d < dd)\n                {\n                    dd = d;\n                    pos = n + p - fp;\n                }\n            }\n        }\n    }\n    return vec4(pos,dd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 r = iResolution.xy,uv = (2. * fragCoord - r)/r.y;\n    \n    \n    vec3 ro = vec3(0, time* 0.01, time),rd = normalize(vec3 (uv,2.));\n    \n    // Time varying pixel color\n    \n    vec3 col = vec3(0);\n    \n    float dd = 0.;\n\n    for(int i = 0; i < 255; i ++)\n    {\n        vec3 p = ro + rd * dd;\n       // p.xy -= ro.xy;\n        //p.xy *= mat2(cos(iTime + p.z), -sin(iTime + p.z), sin(iTime + p.z), cos(iTime + p.z)) * 0.5;\n       //p.xy += ro.xy;\n        vec4 vp = voro(p);\n        float ll = vp.w - length(p - ro)* 0.03 + length(uv) * 0.1;\n        \n        if ( ll < 0.001)\n        {\n            col = 1.-vec3(max(dot(vp.xyz, p), 0.)) * 1.- length(p - ro) * .01; //col = vec3(1) * 100/;\n#ifdef COLOR\n            col.gb *= 0.5 + sin(time * 5. + length(ro-p) ) * 0.3;\n#endif\n\n#ifdef SHOW_ALL\n            col = 1.-vec3(length(p - ro) * 0.01);\n#endif\n\n            break;\n        }\n        dd += ll;\n        \n        if(dd > 100.)\n            break;\n    }\n\n    // Output to screen\n    \n#ifdef SHOW_ALL\n    fragColor = vec4(col,1.0);\n#else\n    fragColor = vec4(col * length(uv /2.) ,1.0);\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lVGWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 112, 112, 317], [319, 319, 338, 338, 405], [406, 406, 425, 425, 1153], [1155, 1155, 1212, 1262, 2361]], "test": "untested"}
{"id": "7sSGDV", "name": "Alien terrain", "author": "z0rg", "description": "A simple lil shader :)", "tags": ["3d", "terrain", "landscape", "alien"], "likes": 7, "viewed": 318, "published": 3, "date": "1637744412", "time_retrieved": "2024-07-30T18:46:18.750032", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c,-s,s,c);}\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(max(l.x,l.y),l.z);\n}\n\nfloat map(vec3 p)\n{\n    float limits = _cube(p,vec3(3.,1.,3.));\n    p.xz *= r2d(iTime*.01);\n    p.xz += vec2(0., iTime);\n    p.xz*=.5;\n\n    float land = -p.y + .5-(\n    texture(iChannel0, p.xz*.01).x\n    -asin(sin(p.x*10.*sin(p.z*2.)))*.05\n    -sin(p.z*7.+p.x*2.)*.2\n    -sin(p.z*10.+p.x*20.)*.05\n    -sin(p.z*50.+p.x*2.+length(p))*.02)*1.25\n    ;\n    return max(land, limits);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 1.;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    \n    return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec2 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        float d = map(p);\n        if (d < 0.01)\n            return vec2(d, distance(ro, p));\n        p+= rd*d*.5;\n    }\n    return vec2(-1.);\n}\nvec3 getNormal(float d, vec3 p)\n{\n    vec2 e = vec2(0.01,0.);\n    return -normalize(vec3(d)-vec3(map(p-e.xyy),map(p-e.yxy),map(p-e.yyx)));\n}\n\nvec3 gradient(float f)\n{\n    //return vec3(1.)*sat((sin(f*100.)-.9)*10.);\n    float stp = 0.025;\n    vec3 col;\n    col = mix(vec3(0.996,0.663,0.086), vec3(0.847,0.133,0.788), f);\n    col = floor(col/stp)*stp;\n    return col;\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = 1.-gradient(sat((uv.y+.5)*1.));\n    float dist = 10.;\n    vec3 ro = vec3(dist, -dist, -dist);\n    vec3 ta = vec3(0.,0.,0.);\n    vec3 rd = normalize(ta-ro);\n    rd = getCam(rd, uv);\n    vec2 res = trace(ro, rd, 64);\n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNormal(res.x, p);//normalize(cross(dFdx(p), dFdy(p)));\n        vec3 lpos = vec3(15.);\n        vec3 ldir = lpos-p;\n        vec3 rgb = gradient(p.y);\n        \n        col = rgb;//*sat(dot(normalize(rd+ldir), n));\n        if (dot(n, vec3(0.,1.,0.)) > 0.01)\n        col -= sat((sin(p.y*25.)-.975)*50.);\n    }\n    \n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\n    vec3 col = rdr(uv);\n    { // Not so cheap antialiasing SSAA x4\n\n        vec2 off = vec2(1., -1.)/(iResolution.x*2.);\n        vec3 acc = col;\n        // To avoid too regular pattern yielding aliasing artifacts\n        mat2 rot = r2d(uv.y*5.); // a bit of value tweaking, appears to be working well\n        acc += rdr(uv-off.xx*rot);\n        acc += rdr(uv-off.xy*rot);\n        acc += rdr(uv-off.yy*rot);\n        acc += rdr(uv-off.yx*rot);\n        col = acc/5.;\n    }\n    col = col.yxz;\n    col = pow(col, vec3(1.45));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSGDV.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[429, 429, 448, 448, 502], [503, 503, 532, 532, 591], [593, 593, 612, 612, 972], [974, 974, 1005, 1005, 1167], [1169, 1169, 1210, 1210, 1413], [1414, 1414, 1447, 1447, 1554], [1556, 1556, 1580, 1629, 1782], [1784, 1784, 1803, 1803, 2437], [2441, 2441, 2498, 2498, 3118]], "test": "untested"}
{"id": "NtKGWD", "name": "Water Fall", "author": "wyatt", "description": "Waterfall using the guil fluid algorithm", "tags": ["fluid", "automata"], "likes": 42, "viewed": 585, "published": 3, "date": "1637723756", "time_retrieved": "2024-07-30T18:46:19.536928", "image_code": "// Fork of \"Aqua Vista\" by wyatt. https://shadertoy.com/view/ssXGDB\n// 2021-11-24 02:54:37\n\n// Fork of \"Temperatures\" by wyatt. https://shadertoy.com/view/fsf3zS\n// 2021-03-22 22:23:14\n\n// Fork of \"Transport Dynamics II\" by wyatt. https://shadertoy.com/view/sdl3RN\n// 2021-03-18 22:39:28\n\n// Display 🌵\nMain \n{\n    vec4 f = A(U);\n    Q = 1.-(.8-0.5*(sin(3.5-.3*(f.z)+vec4(1,2,3,4))))*f.w;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define box for(int x=-1;x<=1;x++)for(int y=-1;y<=1;y++)\n#define r2 0.70710678118\n", "buffer_a_code": "// Forces 🦜\nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u);\n        float f = 0.05*a.w*((a.w-1.)+.2);\n        dQ.xy -= f*u;\n    }\n    Q += dQ;\n    Q.y -= .5/R.y;\n    vec2 M = 1.5*R;\n    if (iMouse.z>0.) M = iMouse.xy;\n    if(length(U-M)<.02*R.y)Q = vec4(.1*normalize(M-0.5*R),-1,1.);\n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    if (iFrame < 1) Q = vec4(0);\n    if (U.x<4.&&U.y>.8*R.y&&U.y<.9*R.y) Q.w = 1.,Q.z=10.*sin(.1*iTime);\n    if (U.x<.05*R.x&&U.y<.8*R.y&&U.y>.7*R.y) Q.xy*=0.;\n    if (U.x<.2*R.x&&U.x>.1*R.x&&U.y<.7*R.y&&U.y>.6*R.y) Q.xy*=0.;\n    if (U.x<.7*R.x&&U.x>.3*R.x&&U.y<.6*R.y&&U.y>.55*R.y) Q.xy*=0.;\n    if (U.x<.65*R.x&&U.x>.6*R.x&&U.y<.7*R.y&&U.y>.48*R.y) Q.xy*=0.;\n    if (U.y<(.2-U.x/R.x*(.1+.1*sin((1.-U.x/R.x)*(1.-U.x/R.x)*50.)))*R.y) Q.xy *= 0.;\n    if (U.x<1.||U.y<1.||R.y-U.y<1.) Q.xy*=0.;\n    if(R.x-U.x<1.)Q *= 0.;\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Advect 🐿\nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5+.5*smoothstep(.4,0.,Q.w*q.w);\n       float k = .5+.5*smoothstep(.4,0.,Q.w*q.w);\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Q.xyz*wa+q.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Forces 🦜\nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u);\n        float f = 0.05*a.w*((a.w-1.)+.2);\n        dQ.xy -= f*u;\n    }\n    Q += dQ;\n    vec2 M = 1.5*R;\n    if (iMouse.z>0.) M = iMouse.xy;\n    if(length(U-M)<.02*R.y)Q = vec4(.1*normalize(M-0.5*R),-1,1.);\n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    if (iFrame < 1) Q = vec4(0);\n    if (U.x<4.&&U.y>.8*R.y&&U.y<.9*R.y) Q.w = 1.,Q.z=10.*sin(.1*iTime);\n    if (U.x<.05*R.x&&U.y<.8*R.y&&U.y>.7*R.y) Q.xy*=0.;\n    if (U.x<.2*R.x&&U.x>.1*R.x&&U.y<.7*R.y&&U.y>.6*R.y) Q.xy*=0.;\n    if (U.x<.7*R.x&&U.x>.3*R.x&&U.y<.6*R.y&&U.y>.55*R.y) Q.xy*=0.;\n    if (U.x<.65*R.x&&U.x>.6*R.x&&U.y<.7*R.y&&U.y>.48*R.y) Q.xy*=0.;\n    if (U.y<(.2-U.x/R.x*(.1+.1*sin((1.-U.x/R.x)*(1.-U.x/R.x)*50.)))*R.y) Q.xy *= 0.;\n    if (U.x<1.||U.y<1.||R.y-U.y<1.) Q.xy*=0.;\n    if(R.x-U.x<1.)Q *= 0.;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Advect 🐿\nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5;\n       float k = .5;\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Q.xyz*wa+q.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtKGWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ftVGDW", "name": "prueba LI", "author": "parabola", "description": "test123", "tags": ["test123"], "likes": 0, "viewed": 239, "published": 3, "date": "1637712436", "time_retrieved": "2024-07-30T18:46:20.339781", "image_code": "float eb(float x) {\n    x = 1. - x;\n    float y = x*x*(3.*x-2.);\n    return 1. - y;\n}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat getBound(vec2 seed, float i) {\n    float p = rand(seed.xy + 1.);\n    if(i < 1.) {\n    \treturn rand(seed) * 0.1 + 0.4;\n    }\n    if(i > 1.0) {\n\t    if(p < 0.07) return 0.;\n    \tif(p > 0.93) return 1.;\n    }\n    return rand(seed) * 0.4 + 0.3;\n}\nfloat getBound(vec2 seed1, vec2 seed2, float intv, float i) {\n    float v1 = getBound(seed1, i);\n    float v2 = getBound(seed2, i);\n    return mix(v1,v2,eb(clamp(intv*2.0-i*0.3-rand(seed1)*0.2,0.,1.)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.y*2.1;\n    vec2 ouv = uv;\n    vec3 col = vec3(1);\n    float ti = iTime * 2.0;\n    vec2 seed1 = vec2(floor(ti),1);\n    vec2 seed2 = vec2(floor(ti)+1.,1);\n    vec2 le1 = vec2(floor(rand(seed1.yx)*16.),floor(rand(seed1.xx)*16.))/16.;\n    vec2 le2 = vec2(floor(rand(seed2.yx)*16.),floor(rand(seed2.xx)*16.))/16.;\n\n    float intv = fract(ti);\n    float ttv = intv;\n    if(abs(uv.x) > 2.0 || abs(uv.y) > 1.0) {\n    } else {\n        float dif = 1.0;\n        uv = uv * vec2(0.25,0.5) + 0.5;\n        vec2 center1 = vec2(0.5,0.5);\n        vec2 size1 = vec2(1,1);\n        vec2 center2 = vec2(0.5,0.5);\n        vec2 size2 = vec2(1,1);\n        for(int i=0;i<8;i++) {\n            float boundX = getBound(seed1,seed2,intv,float(i));\n            float boundX1 = getBound(seed1, float(i));\n            float boundX2 = getBound(seed2, float(i));\n            center1.x -= (0.5 - boundX1) * size1.x;\n            center2.x -= (0.5 - boundX2) * size2.x;\n            if(uv.x < boundX) {\n                uv.x /= boundX;\n                seed1.x += dif, seed2.x += dif;\n                size1.x *= boundX1, size2.x *= boundX2;\n                center1.x -= size1.x * 0.5, center2.x -= size2.x * 0.5;\n            } else {\n                uv.x = (uv.x - boundX) / (1. - boundX);\n                seed1.x -= dif, seed2.x -= dif;\n                size1.x *= 1. - boundX1, size2.x *= 1. - boundX2;\n                center1.x += size1.x * 0.5, center2.x += size2.x * 0.5;\n                intv += 0.15 * dif;\n            }\n\t        seed1 = seed1.yx;\n\t        seed2 = seed2.yx;\n            dif /= 2.0;\n            \n            if(i > 0) {\n                float boundY = getBound(seed1, seed2, intv, float(i));\n                float boundY1 = getBound(seed1, float(i));\n                float boundY2 = getBound(seed2, float(i));\n                center1.y -= (0.5 - boundY1) * size1.y;\n                center2.y -= (0.5 - boundY2) * size2.y;\n                if(uv.y < boundY) {\n                    uv.y /= boundY;\n                    seed1.y += dif, seed2.y += dif;\n                    size1.y *= boundY1, size2.y *= boundY2;\n                    center1.y -= size1.y * 0.5, center2.y -= size2.y * 0.5;\n                } else {\n                    uv.y = (uv.y - boundY) / (1. - boundY);\n                    seed1.y -= dif, seed2.y -= dif;\n                    size1.y *= 1. - boundY1, size2.y *= 1. - boundY2;\n                    center1.y += size1.y * 0.5, center2.y += size2.y * 0.5;\n                    intv += 0.15 * dif;\n                }\n            }\n            seed1 = seed1.yx;\n            seed2 = seed2.yx;\n            dif /= 2.0;\n        }\n        vec2 coord0 = (center1-vec2(0.25,0))/vec2(8.0,16.0);\n        vec2 coord1 = (center2-vec2(0.25,0))/vec2(8.0,16.0);\n        coord0 = clamp(coord0, 0., 1./16.);\n        coord1 = clamp(coord1, 0., 1./16.);\n        vec4 c0 = texture(iChannel0, coord0+le1).xyzw;\n        vec4 c1 = texture(iChannel0, coord1+le2).xyzw;\n        ttv = smoothstep(0.,1.,-0.7 + ttv*4.0 - rand(center1)*2.0);\n        float ld = rand(seed1+seed2) < 0.5 ? 1. : 0.;\n        float ldu = rand(seed1-seed2) < 0.5 ? 1. : 0.;\n        float lb = mix(1.,-1.,ldu);\n        float mixParam = ld < 0.5\n            ? step(uv.x, lb*ttv+ldu)\n            : step(uv.y, lb*ttv+ldu);\n        col *= 1. - mix(c1.x,c0.x,mixParam);\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftVGDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 85], [86, 86, 106, 106, 178], [180, 180, 216, 216, 428], [429, 429, 490, 490, 633], [635, 635, 692, 692, 4089]], "test": "untested"}
{"id": "NlV3WW", "name": "More trippy log-polar grid stuff", "author": "SnoopethDuckDuck", "description": "messy code", "tags": ["e"], "likes": 9, "viewed": 340, "published": 3, "date": "1637709477", "time_retrieved": "2024-07-30T18:46:21.109722", "image_code": "float thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\n#define pi 3.14159\n\nfloat func(vec2 uv, float time) {\n    vec2 p = 0.35 * vec2(thc(4., time), ths(4., time));\n    float d = length(uv-p);\n    float k = 1.1 * thc(4.,3. * uv.x + time);\n    float s = smoothstep(-k, k, 0.82 - d);\n    return s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    float time = -4. * iTime;\n    float a = atan(uv.y, uv.x);\n    float r = log(length(uv));\n  \n    //vec2 ipos = floor(iTime * uv) + 0.5;\n    uv = 0.5 * thc(2. + 1.5 * cos(10. * mlength(uv) + time),\n                   10. * uv) - 0. * thc(1.,iTime);\n            \n    float s = func(uv, time + a + r * 24.+ length(uv) * 0100.);\n    float s2 = func(fract(9. * uv) - 0.5, 8. * r + time);\n\n    s = max(s-s2, 0.08);\n    //s = s2;//mix(s,s2, .5 + .5 * thc(4., iTime));\n\n    vec3 col = s2 * pal(ths(r,length(uv) * r - iTime) + s, vec3(1.), vec3(1.), vec3(1.), s * vec3(0.,0.33,0.66));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlV3WW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 70], [72, 72, 101, 101, 142], [144, 144, 171, 171, 212], [214, 214, 241, 241, 282], [284, 284, 352, 352, 395], [397, 397, 417, 417, 492], [494, 494, 518, 518, 558], [580, 580, 613, 613, 802], [804, 804, 861, 861, 1558]], "test": "untested"}
{"id": "NlVGWW", "name": "monito 2d y fondo ", "author": "jorge2017a2", "description": "monito 2d y fondo ", "tags": ["monito2dyfondo"], "likes": 5, "viewed": 206, "published": 3, "date": "1637703707", "time_retrieved": "2024-07-30T18:46:21.872682", "image_code": "//por jorge2017a2\n///referencia\n//https://iquilezles.org/articles/distfunctions2d\n//https://www.shadertoy.com/view/7ly3D1  ... Lightspeed effect\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(1.0),b,d)\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  //colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\nreturn colOut;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;   return length(max(d,0.0)) + min(max(d.x,d.y),0.0);}\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat ellipse(vec2 p, vec2 focus0, vec2 focus1, float radius) \n{   return distance(p, focus0) + distance(p, focus1) - distance(focus0, focus1) * radius; }\n\nfloat HacerPeloDown1(vec2 p )\n{   float d1= sdCircle(p-vec2(0.0,0.0), 0.5 );\n    float d2= sdCircle(p-vec2(0.2,-0.35),0.5 );\n    float dif1= differenceSDF(d1, d2);\n    return dif1;\n}\nfloat HacerPeloUp1(vec2 p )\n{   float d1= sdCircle(p-vec2(0.0,0.0), 0.5 );\n    float d2= sdCircle(p-vec2(0.42,0.35),0.75 );\n    float dif1= differenceSDF(d1, d2);\n    return dif1;\n}\n\nfloat HacerRostro(vec2 p)\n{   vec2 focus0=vec2(0.0,0.2);\n    vec2 focus1=vec2(0.0,0.8);\n    float radius=2.0;\n    float d1= ellipse(p,focus0,focus1,radius);\n    return d1;\n}\n\nfloat HacerOjo(vec2 p)\n{   vec2 focus0=vec2(0.0,0.2);\n    vec2 focus1=vec2(0.0,0.3);\n    float radius=1.0;\n    float d1= ellipse(p,focus0,focus1,radius);\n    return d1;\n}\n\nfloat HacerBoca(vec2 p)\n{   vec2 focus0=vec2(0.01,0.2);\n    vec2 focus1=vec2(0.2,0.25);\n    float radius=1.0;\n    float d1= ellipse(p,focus0,focus1,radius);\n    return d1;\n}\n\n\nvec3 sd2d(vec2 uv, vec3 col)\n{   float d0=HacerRostro(uv-vec2(0.08,-0.7));\n    col= DrawFigBorde(vec3(0.7,0.6,0.1)-uv.y*0.25, col, d0 );\n    \n    float d1,d2,d3,d4,d5,d6;\n    d1= HacerPeloDown1(uv-vec2(0.05,0.0));\n    d2= HacerPeloUp1(uv-vec2(0.3,0.48));\n    d3= HacerPeloUp1(vec2(-uv.x, uv.y)-vec2(-0.2,0.25));\n    d4= HacerPeloUp1(uv*1.5-vec2(-0.2,0.45));\n    d5= HacerPeloDown1(vec2(-uv.x, uv.y)-vec2(-0.4,-0.1) );\n    d6= HacerPeloUp1(vec2(-uv.x, uv.y)*1.2-vec2(0.6,0.25));\n    \n    float dtdo=unionSDF(d1, d2);\n    dtdo=unionSDF(dtdo, d3);\n    dtdo=unionSDF(dtdo, d4);\n    dtdo=unionSDF(dtdo, d5);\n    dtdo=unionSDF(dtdo, d6);\n    col=DrawFigBorde(vec3(1.0,0.0,0.0)-uv.y, col,dtdo);\n    \n    float dojoI= HacerOjo(uv-vec2(0.0,-0.6));\n    float dojoD= HacerOjo(uv-vec2(0.3,-0.6));\n    col=DrawFigBorde(vec3(0.0,0.0,0.0), col,dojoI);\n    col=DrawFigBorde(vec3(0.0,0.0,0.0), col,dojoD);\n    \n     float dboca= HacerBoca(uv-vec2(0.0,-0.7));\n    col=DrawFigBorde(vec3(0.0,0.0,0.0), col,dboca);\n return col;\n}   \n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv0 = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv0.x *= iResolution.x/iResolution.y;\n    uv0*=1.0;\n     // Normalized pixel coordinates (from -1 to 1)\n    vec2 suv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    //Radial UVs    \n    vec2 uv = vec2(length(suv),atan(suv.y,suv.x));\n    //Stars\n    float offset = .1*sin(uv.y*10.f-iTime*.6)*cos(uv.y*48.f+iTime*.3)*cos(uv.y*3.7f+iTime);\n    vec3 rays = vec3(sin(uv.y*150.f+iTime)*.5+.5)* \n    vec3(sin(uv.y*80.f-iTime*0.6)*.5+.5)*\n    vec3(sin(uv.y*45.f+iTime*0.8)*.5+.5)*\n    vec3(1.f-cos(uv.y+22.f*iTime-pow(uv.x+offset,.3f)*60.f))*\n    vec3(uv.x*2.f);\n    vec2 uv2=rays.xy;\n    \n   vec3  col=vec3(0.0);\n    col=sd2d(uv2, col);\n    col=sd2d(uv0, col);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlVGWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[305, 349, 396, 396, 423], [424, 424, 467, 467, 494], [495, 495, 543, 543, 571], [577, 577, 639, 639, 835], [837, 837, 918, 918, 1048], [1050, 1050, 1107, 1107, 1173], [1175, 1175, 1212, 1212, 1285], [1287, 1287, 1322, 1322, 1345], [1347, 1347, 1411, 1411, 1501], [1503, 1503, 1534, 1534, 1685], [1686, 1686, 1715, 1715, 1867], [1869, 1869, 1896, 1896, 2042], [2044, 2044, 2068, 2068, 2214], [2216, 2216, 2241, 2241, 2389], [2392, 2392, 2422, 2422, 3400], [3409, 3409, 3466, 3466, 4236]], "test": "untested"}
{"id": "flVGWW", "name": "Fork Lost Nitorac 128", "author": "Nitorac", "description": "Use the mouse to rotate the camera; reset the time if you get stuck in the maze ;).", "tags": ["game", "maze", "collisions"], "likes": 4, "viewed": 246, "published": 3, "date": "1637703329", "time_retrieved": "2024-07-30T18:46:22.820149", "image_code": "// Rendering parameters\n#define FOV\t\t\t\t\t80.0\n#define RAY_STEP_MAX\t\t20.0\n#define RAY_LENGTH_MAX\t\t10.0\n#define EDGE_LENGTH\t\t\t0.1\n#define EDGE_FULL\n#define TEXTURE\n#define SHADOW\n#define BUMP_RESOLUTION\t\t100.0\n#define BUMP_INTENSITY\t\t0.1\n#define AMBIENT_NORMAL\t\t0.2\n#define AMBIENT_HIGHLIGHT\t2.5\n#define SPECULAR_POWER\t\t2.0\n#define SPECULAR_INTENSITY\t0.3\n#define FADE_POWER\t\t\t1.5\n#define GAMMA\t\t\t\t0.8\n\n// Math constants\n#define DELTA\t0.002\n#define PI\t\t3.14159265359\n\n// PRNG (unpredictable)\nfloat randUnpredictable (in vec3 seed) {\n\tseed = fract (seed * vec3 (5.6789, 5.4321, 6.7890));\n\tseed += dot (seed.yzx, seed.zxy + vec3 (21.0987, 12.3456, 15.1273));\n\treturn fract (seed.x * seed.y * seed.z * 5.1337);\n}\n\n// PRNG (predictable)\nfloat randPredictable (in vec3 seed) {\n\treturn fract (11.0 * sin (3.0 * seed.x + 5.0 * seed.y + 7.0 * seed.z));\n}\n\n// PRNG (2D only)\nfloat rand (in vec2 seed) {\n\tseed = fract (seed * vec2 (5.3983, 5.4427));\n\tseed += dot (seed.yx, seed.xy + vec2 (21.5351, 14.3137));\n\treturn fract (seed.x * seed.y * 95.4337);\n}\n\n// HSV to RGB\nvec3 hsv2rgb (in vec3 hsv) {\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\treturn hsv.z * (1.0 + hsv.y * clamp (abs (fract (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 2.0, -1.0, 0.0));\n}\n\n// Check whether there is a block at a given voxel edge\nfloat blockCheck (in vec3 p, in vec3 n) {\n\tvec3 blockPosition = floor (p + 0.5 + n * 0.5);\n\tvec3 blockEven = mod (blockPosition, 2.0);\n\tfloat blockSum = blockEven.x + blockEven.y + blockEven.z;\n\treturn max (step (blockSum, 1.5), step (blockSum, 2.5) * step (0.5, randPredictable (blockPosition))) *\n\t\tstep (4.5, mod (blockPosition.x, 32.0)) *\n\t\tstep (2.5, mod (blockPosition.y, 16.0)) *\n\t\tstep (4.5, mod (blockPosition.z, 32.0));\n}\n\n// Cast a ray\nvec3 hit (in vec3 rayOrigin, in vec3 rayDirection, in float rayLengthMax, out float rayLength, out vec3 hitNormal) {\n\n\t// Launch the ray\n\tvec3 hitPosition = rayOrigin;\n\tvec3 raySign = sign (rayDirection);\n\tvec3 rayInv = 1.0 / rayDirection;\n\tvec3 rayLengthNext = (0.5 * raySign - fract (rayOrigin + 0.5) + 0.5) * rayInv;\n\tfor (float rayStep = 0.0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\n\t\t// Reach the edge of the voxel\n\t\trayLength = min (rayLengthNext.x, min (rayLengthNext.y, rayLengthNext.z));\n\t\thitNormal = step (rayLengthNext.xyz, rayLengthNext.yzx) * step (rayLengthNext.xyz, rayLengthNext.zxy) * raySign;\n\t\thitPosition = rayOrigin + rayLength * rayDirection;\n\n\t\t// Check whether we hit a block\n\t\tif (blockCheck (hitPosition, hitNormal) > 0.5 || rayLength > rayLengthMax) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// Next voxel\n\t\trayLengthNext += hitNormal * rayInv;\n\t}\n\n\t// Return the hit point\n\treturn hitPosition;\n}\n\n// Main function\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Read the data\n\tvec3 headPosition;\n\tmat3 headOrientation;\n\tvec3 lightPosition;\n\n\tif (iFrame < 5) {\n\t\theadPosition = vec3 (13.05, 1.5, 13.0);\n\t\tlightPosition = vec3 (13.0, 1.0, 13.0);\n\t\theadOrientation [0] = vec3 (0.0, 0.0, -1.0);\n\t\theadOrientation [1] = vec3 (1.0, 0.0, 0.0);\n\t} else {\n\t\tvec4 data = texture (iChannel0, vec2 (0.5, 0.5) / iResolution.xy);\n\t\theadPosition = data.xyz;\n\t\theadOrientation [1].x = data.w;\n\t\tdata = texture (iChannel0, vec2 (2.5, 0.5) / iResolution.xy);\n\t\tlightPosition = data.xyz;\n\t\theadOrientation [1].y = data.w;\n\t\tdata = texture (iChannel0, vec2 (4.5, 0.5) / iResolution.xy);\n\t\theadOrientation [0] = data.xyz;\n\t\theadOrientation [1].z = data.w;\n\t}\n\theadOrientation [2] = cross (headOrientation [0], headOrientation [1]);\n\n\t// Animate the ambient lighting\n\tfloat ambientIntensity = max (step (1.0, mod (iTime, 10.0)), step (0.25, randUnpredictable (vec3 (iTime))));\n\n\t// Define the ray corresponding to this fragment\n\tvec3 rayOrigin = headPosition;\n\tvec3 rayDirection = headOrientation * normalize (vec3 (2.0 * fragCoord - iResolution.xy, 0.5 * iResolution.x / tan (FOV * PI / 360.0)));\n\n\t// Cast a ray\n\tfloat hitDistance;\n\tvec3 hitNormal;\n\tvec3 hitPosition = hit (rayOrigin, rayDirection, RAY_LENGTH_MAX, hitDistance, hitNormal);\n\tvec3 hitUV = hitPosition * abs (hitNormal.yzx + hitNormal.zxy);\n\n\t// Basic edge detection\n\tvec3 edgeDistance = fract (hitUV + 0.5) - 0.5;\n\tvec3 edgeDirection = sign (edgeDistance);\n\tedgeDistance = abs (edgeDistance);\n\n\t#ifdef EDGE_FULL\n\tvec3 hitNormalAbs = abs (hitNormal);\n\tvec2 edgeSmooth = vec2 (dot (edgeDistance, hitNormalAbs.yzx), dot (edgeDistance, hitNormalAbs.zxy));\n\tfloat highlightIntensity = (1.0 - blockCheck (hitPosition + edgeDirection * hitNormalAbs.yzx, hitNormal)) * smoothstep (0.5 - EDGE_LENGTH, 0.5 - EDGE_LENGTH * 0.5, edgeSmooth.x);\n\thighlightIntensity = max (highlightIntensity, (1.0 - blockCheck (hitPosition + edgeDirection * hitNormalAbs.zxy, hitNormal)) * smoothstep (0.5 - EDGE_LENGTH, 0.5 - EDGE_LENGTH * 0.5, edgeSmooth.y));\n\thighlightIntensity = max (highlightIntensity, (1.0 - blockCheck (hitPosition + edgeDirection, hitNormal)) * smoothstep (0.5 - EDGE_LENGTH, 0.5 - EDGE_LENGTH * 0.5, min (edgeSmooth.x, edgeSmooth.y)));\n\t#else\n\tfloat highlightIntensity = 1.0 - blockCheck (hitPosition + step (edgeDistance.yzx, edgeDistance.xyz) * step (edgeDistance.zxy, edgeDistance.xyz) * edgeDirection, hitNormal);\n\thighlightIntensity *= smoothstep (0.5 - EDGE_LENGTH, 0.5 - EDGE_LENGTH * 0.5, max (edgeDistance.x, max (edgeDistance.y, edgeDistance.z)));\n\t#endif\n\n\t// Texture\n\t#ifdef TEXTURE\n\tvec2 textureUV = fract (vec2 (dot (hitUV, hitNormal.yzx), dot (hitUV, hitNormal.zxy)) + 0.5);\n\ttextureUV.x = (textureUV.x + mod (floor (iTime * 20.0), 6.0)) * 40.0 / 256.0;\n\tfloat textureIntensity = 1.0 - texture (iChannel1, textureUV).r;\n\tfloat texturePhase = 2.0 * PI * randUnpredictable (floor (hitPosition + 0.5 + hitNormal * 1.5));\n\ttextureIntensity *= smoothstep (0.8, 1.0, cos (iTime * 0.2 + texturePhase));\n\thighlightIntensity = max (highlightIntensity, textureIntensity);\n\t#endif\n\n\t// Set the object color\n\tvec3 color = cos ((hitPosition + hitNormal * 0.5) * 0.05);\n\tcolor = hsv2rgb (vec3 (color.x + color.y + color.z + highlightIntensity * 0.05, 1.0, 1.0));\n\n\t// Lighting\n\tvec3 lightDirection = hitPosition - lightPosition;\n\tfloat lightDistance = length (lightDirection);\n\tlightDirection /= lightDistance;\n\n\tfloat lightIntensity = min (1.0, 1.0 / lightDistance);\n\t#ifdef SHADOW\n\tfloat lightHitDistance;\n\tvec3 lightHitNormal;\n\thit (hitPosition - hitNormal * DELTA, -lightDirection, lightDistance, lightHitDistance, lightHitNormal);\n\tlightIntensity *= step (lightDistance, lightHitDistance);\n\t#endif\n\n\t// Bump mapping\n\tvec2 bumpUV = BUMP_RESOLUTION * vec2 (dot (hitUV, hitNormal.yzx), dot (hitUV, hitNormal.zxy));\n\tvec4 bumpID = floor (vec4 (bumpUV, bumpUV + 1.0));\n\tbumpUV = fract (bumpUV);\n\tfloat bump = mix (\n\t\tmix (rand (bumpID.xy), rand (bumpID.zy), bumpUV.x),\n\t\tmix (rand (bumpID.xw), rand (bumpID.zw), bumpUV.x),\n\t\tbumpUV.y);\n\thitNormal = normalize (hitNormal + hitNormal.yzx * (1.0 - highlightIntensity) * BUMP_INTENSITY * (bump - 0.5));\n\n\t// Shading\n\tfloat ambient = mix (AMBIENT_NORMAL, AMBIENT_HIGHLIGHT, highlightIntensity) * ambientIntensity;\n\tfloat diffuse = max (0.0, dot (hitNormal, lightDirection));\n\tfloat specular = pow (max (0.0, dot (reflect (rayDirection, hitNormal), lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\tcolor = (ambient + diffuse * lightIntensity) * color + specular * lightIntensity;\n\tcolor *= pow (max (0.0, 1.0 - hitDistance / RAY_LENGTH_MAX), FADE_POWER);\n\n\t// Light source\n\tlightDirection = lightPosition - rayOrigin;\n\tif (dot (rayDirection, lightDirection) > 0.0) {\n\t\tlightDistance = length (lightDirection);\n\t\tif (lightDistance < hitDistance) {\n\t\t\tvec3 lightNormal = cross (rayDirection, lightDirection);\n\t\t\tcolor += smoothstep (0.001, 0.0, dot (lightNormal, lightNormal));\n\t\t}\n\t}\n\n\t// Adjust the gamma\n\tcolor = pow (color, vec3 (GAMMA));\n\n\t// Set the fragment color\n\tfragColor = vec4 (color, 1.0);\n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Physics parameters\n#define GRAVITY vec3 (0.0, -3.0, 0.0) // Feel free to comment this out to explore the maze freely :)\n\n// Math constants\n#define DELTA\t0.002\n#define PI \t\t3.14159265359\n\n// Element\nstruct Element {\n\tvec3 position;\n\tvec3 speed;\n\tvec3 force;\n\tfloat friction;\n\tfloat radius;\n\tfloat elasticity;\n};\n\n// Head\nstruct Head {\n\tElement element;\n\tmat3 orientation;\n\tfloat forceOrientation;\n};\n\n// Light ball\nstruct LightBall {\n\tElement element;\n\tfloat aheadDistance;\n\tfloat movementAmplitude;\n\tfloat forceSpringStiffness;\n\tfloat forceMaxSqr;\n\tfloat collisionTimer;\n\tfloat collisionTimerMax;\n};\n\n// PRNG (predictable)\nfloat randPredictable (in vec3 seed) {\n\treturn fract (11.0 * sin (3.0 * seed.x + 5.0 * seed.y + 7.0 * seed.z));\n}\n\n// Check whether there is a block at a given position\nfloat blockCheck (in vec3 blockPosition) {\n\tvec3 blockEven = mod (blockPosition, 2.0);\n\tfloat blockSum = blockEven.x + blockEven.y + blockEven.z;\n\treturn max (step (blockSum, 1.5), step (blockSum, 2.5) * step (0.5, randPredictable (blockPosition))) *\n\t\tstep (4.5, mod (blockPosition.x, 32.0)) *\n\t\tstep (2.5, mod (blockPosition.y, 16.0)) *\n\t\tstep (4.5, mod (blockPosition.z, 32.0));\n}\n\n// React to collisions\nvoid collisionReact (inout Element element, in vec3 relativePosition) {\n\n\t// Compute the position relative to the actual hit point\n\trelativePosition -= 0.5 * sign (relativePosition);\n\n\t// Make sure there is a hit\n\tfloat distance = length (relativePosition);\n\tif (distance < element.radius) {\n\n\t\t// Compute the normalized direction of the hit\n\t\trelativePosition /= distance;\n\n\t\t// Upate the position\n\t\tdistance -= element.radius;\n\t\telement.position -= relativePosition * distance;\n\n\t\t// Update the speed\n\t\telement.speed -= (1.0 + element.elasticity) * dot (element.speed, relativePosition) * relativePosition;\n\t}\n}\n\n// Detect collisions (here, \"element\" is a sphere, and the environment is made of cubes)\nvoid collisionDetect (inout Element element) {\n\n\t// Get the position of the current block\n\tvec3 blockPosition = floor (element.position + 0.5);\n\n\t// There is no collision if we are inside a block already\n\tif (blockCheck (blockPosition) > 0.5) {\n\t\treturn;\n\t}\n\n\t// Compute the relative position within the block\n\tvec4 relativePosition = vec4 (element.position - blockPosition, 0.0);\n\n\t// Check whether we are close to a side of the current block\n\tvec3 check = step (0.5 - element.radius, abs (relativePosition.xyz));\n\tif (check.x + check.y + check.z < 0.5) {\n\t\treturn;\n\t}\n\n\t// Prepare to check nearby blocks\n\tvec4 blockDelta = sign (relativePosition);\n\n\t// Handle collisions with the sides\n\tif (check.x > 0.5 && blockCheck (blockPosition + blockDelta.xww) > 0.5) {\n\t\tcheck.x = 0.0;\n\t\tcollisionReact (element, relativePosition.xww);\n\t}\n\tif (check.y > 0.5 && blockCheck (blockPosition + blockDelta.wyw) > 0.5) {\n\t\tcheck.y = 0.0;\n\t\tcollisionReact (element, relativePosition.wyw);\n\t}\n\tif (check.z > 0.5 && blockCheck (blockPosition + blockDelta.wwz) > 0.5) {\n\t\tcheck.z = 0.0;\n\t\tcollisionReact (element, relativePosition.wwz);\n\t}\n\n\t// Take note of whether we have to check the collision with the corner\n\tfloat checkXYZ = check.x * check.y * check.z;\n\n\t// Handle collisions with the edges\n\tif (check.x * check.y > 0.5 && blockCheck (blockPosition + blockDelta.xyw) > 0.5) {\n\t\tcheckXYZ = 0.0;\n\t\tcollisionReact (element, relativePosition.xyw);\n\t}\n\tif (check.y * check.z > 0.5 && blockCheck (blockPosition + blockDelta.wyz) > 0.5) {\n\t\tcheckXYZ = 0.0;\n\t\tcollisionReact (element, relativePosition.wyz);\n\t}\n\tif (check.z * check.x > 0.5 && blockCheck (blockPosition + blockDelta.xwz) > 0.5) {\n\t\tcheckXYZ = 0.0;\n\t\tcollisionReact (element, relativePosition.xwz);\n\t}\n\n\t// Handle the collision with the corner\n\tif (checkXYZ > 0.5 && blockCheck (blockPosition + blockDelta.xyz) > 0.5) {\n\t\tcollisionReact (element, relativePosition.xyz);\n\t}\n}\n\n// Handle movements\nvoid move (inout Element element, in bool collide) {\n\n\t// Handle the friction\n\telement.force -= element.speed * element.friction;\n\n\t// Update the speed\n\telement.speed += element.force * iTimeDelta;\n\n\t// Compute the movement\n\tfloat speed = length (element.speed);\n\tfloat movementLength = speed * iTimeDelta;\n\tvec3 movementDirection = element.speed / speed;\n\n\t// Move towards the destination by small increments, to make sure we detect all collisions\n\t// Note: we could optimize this by going faster when within the inner part of a block, far from the sides\n\t// ...but this isn't really needed, so let's keep it simple\n\tif (collide && element.radius > 0.0) {\n\t\tfor (int iteration = 0; iteration < 8; ++iteration) {\n\t\t\tif (movementLength > element.radius) {\n\t\t\t\telement.position += element.radius * movementDirection;\n\t\t\t\tmovementLength -= element.radius;\n\t\t\t\tcollisionDetect (element);\n\t\t\t}\n\t\t}\n\t}\n\telement.position += movementLength * movementDirection;\n\tif (collide) {\n\t\tcollisionDetect (element);\n\t}\n}\n\n// Get the orientation of the head\nmat3 headOrientationGet () {\n\n\tfloat yawAngle = 3.0 * PI * (iMouse.x / iResolution.x - 0.5);\n\tfloat pitchAngle = PI * (0.5 - iMouse.y / iResolution.y);\n\n\tfloat cosYaw = cos (yawAngle);\n\tfloat sinYaw = sin (yawAngle);\n\tfloat cosPitch = cos (pitchAngle);\n\tfloat sinPitch = sin (pitchAngle);\n\n\tmat3 headOrientation;\n\theadOrientation [0] = vec3 (cosYaw, 0.0, -sinYaw);\n\theadOrientation [1] = vec3 (sinYaw * sinPitch, cosPitch, cosYaw * sinPitch);\n\theadOrientation [2] = vec3 (sinYaw * cosPitch, -sinPitch, cosYaw * cosPitch);\n\treturn headOrientation;\n}\n\n// Main function\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Don't waste time...\n\tif (fragCoord.x > 5.0 || fragCoord.y > 1.0) {\n\t\tdiscard;\n\t}\n\n\t// Define the head\n\tHead head;\n\thead.element.friction = 1.0;\n\thead.element.radius = 0.1;\n\thead.element.elasticity = 0.5;\n\thead.forceOrientation = 2.0;\n\n\t// Define the light ball\n\tLightBall lightBall;\n\tlightBall.element.friction = 1.0;\n\tlightBall.element.radius = 0.5;\n\tlightBall.element.elasticity = 0.5;\n\tlightBall.aheadDistance = 0.5;\n\tlightBall.movementAmplitude = 0.1;\n\tlightBall.forceSpringStiffness = 15.0;\n\tlightBall.forceMaxSqr = 900.0;\n\tlightBall.collisionTimerMax = 5.0;\n\n\t// Initialize the position and speed of both the head and the light ball\n\tif (iFrame < 5) {\n\t\thead.element.position = vec3 (13.05, 1.5, 13.0);\n\t\thead.element.speed = vec3 (0.0);\n\t\tlightBall.element.position = vec3 (13.0, 1.0, 13.0);\n\t\tlightBall.element.speed = vec3 (0.0);\n\t\tlightBall.collisionTimer = 0.0;\n\t} else {\n\t\thead.element.position = texture (iChannel0, vec2 (0.5, 0.5) / iResolution.xy).xyz;\n\t\thead.element.speed = texture (iChannel0, vec2 (1.5, 0.5) / iResolution.xy).xyz;\n\t\tlightBall.element.position = texture (iChannel0, vec2 (2.5, 0.5) / iResolution.xy).xyz;\n\t\tvec4 data = texture (iChannel0, vec2 (3.5, 0.5) / iResolution.xy);\n\t\tlightBall.element.speed = data.xyz;\n\t\tlightBall.collisionTimer = data.w;\n\t}\n\n\t// Move the head\n\thead.orientation = headOrientationGet ();\n\thead.element.force = head.orientation [2] * head.forceOrientation;\n\t#ifdef GRAVITY\n\tfloat gravitySqr = dot (GRAVITY, GRAVITY);\n\tif (gravitySqr > DELTA) {\n\t\thead.element.force += (1.0 - dot (head.element.force, GRAVITY) / gravitySqr) * GRAVITY;\n\t}\n\t#endif\n\tmove (head.element, true);\n\n\t// Move the light ball (using a spring force)\n\tvec3 lightBallPositionTarget = lightBall.movementAmplitude * vec3 (sin (iTime * 2.0), sin (iTime * 3.0), sin (iTime));\n\tlightBallPositionTarget.z += lightBall.aheadDistance;\n\tlightBallPositionTarget = head.element.position + head.orientation * lightBallPositionTarget;\n\tlightBall.element.force = (lightBallPositionTarget - lightBall.element.position) * lightBall.forceSpringStiffness;\n\tif (dot (lightBall.element.force, lightBall.element.force) < lightBall.forceMaxSqr) {\n\t\tlightBall.collisionTimer = 0.0;\n\t} else {\n\t\tlightBall.collisionTimer += iTimeDelta;\n\t}\n\tmove (lightBall.element, lightBall.collisionTimer < lightBall.collisionTimerMax);\n\n\t// Store the data\n\tif (fragCoord.x < 1.0) {\n\t\tfragColor = vec4 (head.element.position, head.orientation [1].x);\n\t} else if (fragCoord.x < 2.0) {\n\t\tfragColor = vec4 (head.element.speed, 0.0);\n\t} else if (fragCoord.x < 3.0) {\n\t\tfragColor = vec4 (lightBall.element.position, head.orientation [1].y);\n\t} else if (fragCoord.x < 4.0) {\n\t\tfragColor = vec4 (lightBall.element.speed, lightBall.collisionTimer);\n\t} else {\n\t\tfragColor = vec4 (head.orientation [0], head.orientation [1].z);\n\t}\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flVGWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[464, 488, 528, 528, 705], [707, 729, 767, 767, 842], [844, 862, 889, 889, 1039], [1041, 1055, 1083, 1083, 1246], [1248, 1304, 1345, 1345, 1735], [1737, 1751, 1867, 1887, 2650], [2652, 2669, 2725, 2744, 7766]], "test": "untested"}
{"id": "wsdXDl", "name": "test multi layered material", "author": "mrExalight", "description": "https://www.activision.com/cdn/research/s2017_pbs_multilayered_slides_final.pdf", "tags": ["material"], "likes": 5, "viewed": 260, "published": 3, "date": "1637702399", "time_retrieved": "2024-07-30T18:46:23.722736", "image_code": "struct Material{\n    vec3 _color;\n\tvec3 _absorption;\n    vec4 _kadsq;\n    float _thickness;\n    float _ior;\n};\n\n\nfloat getHeight(sampler2D sampler, vec2 uv) {\n  return texture(sampler, uv).r;\n}\n\nvec4 bumpFromDepth(sampler2D sampler, vec2 uv, vec2 resolution, float scale) {\n  vec2 step = 1. / resolution;\n    \n  float height = getHeight(sampler, uv);\n    \n  vec2 dxy = height - vec2(\n      getHeight(sampler, uv + vec2(step.x, 0.)), \n      getHeight(sampler, uv + vec2(0., step.y))\n  );\n    \n  return vec4(normalize(vec3(dxy * scale / step, 1.)), height);\n}\n\nvec3 DirectAbsorption( float NdotV, float NdotL, vec3 alpha, float d )\n{\n    vec3 color;\n    float denom = max( NdotL * NdotV, 0.001 );\n    color = exp( -alpha * ( d * ( ( NdotL + NdotV ) / denom) ) );\n    return color;\n}\n\nbool renderLayer(inout vec3 point, inout vec3 eye, inout vec3 color, inout vec2 uv, vec3 normal, vec3 lightColor, vec3 lightPos, inout vec3 absorption, sampler2D sampler, Material material )\n{\n    \n    float d = material._thickness;\n   \n    vec3 eyeDir = normalize(point - eye);\n    vec3 lightDir = normalize(point - lightPos);\n\n    float NdotV = max(dot(normal,-eyeDir), 0.);\n    float NdotL = max(dot(normal,-lightDir), 0.);\n\n    vec3 colorMaterial = vec3(0.);\n\n    colorMaterial += material._color  * material._kadsq.x;\n\n    colorMaterial += lightColor * material._color * material._kadsq.y * max(NdotL,0.);\n\n    colorMaterial += lightColor * material._kadsq.z * pow(max(dot(reflect(lightDir,normal),-eyeDir),0.),material._kadsq.w);\n    \n    color += colorMaterial * absorption;\n    \n    vec3 refractedEye = normalize(refract(eyeDir,normal,material._ior));\n        \n    float cosAlpha = dot(-normal,refractedEye);\n    \n    if(cosAlpha < 0.)\n        return false;\n    \n    float distanceToPointOnTheNextMaterial = d / cosAlpha;\n\n    absorption = DirectAbsorption( NdotV, NdotL, material._absorption, distanceToPointOnTheNextMaterial );\n\n    vec3 tmpPoint = point + refractedEye * distanceToPointOnTheNextMaterial;\n\n    uv = mod(uv + (tmpPoint - point).xy, 1.);\n\n    point = tmpPoint;\n\n    return true;\n}\n\nfloat waterMap( vec2 pos ) {\n\tvec2 posm = pos * m2;\n\t\n\treturn abs( fbm( vec3( 8.*posm, iTime ))-0.5 )* 0.1;\n}\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 dx = vec2( EPSILON, 0. );\n\tvec2 dz = vec2( 0., EPSILON );\n    \n    float refldist = 10.;\n    \n    float bumpfactor = BUMPFACTOR * (1. - smoothstep( 0., BUMPDISTANCE, refldist) );\n    \n    vec3 normal = vec3( 0., 0., 0. );\n\tnormal.x = -bumpfactor * (waterMap(uv + dx) - waterMap(uv-dx) ) / (2. * EPSILON);\n\tnormal.z = -bumpfactor * (waterMap(uv + dz) - waterMap(uv-dz) ) / (2. * EPSILON);\n\tnormal = normalize( normal );\n \n    fragColor = vec4(normal,1.0);\n \n /*\n    Material materials[2];\n    materials[0] = Material(vec3(.0), vec3(.8, .4, .0), vec4(.3, .8, .6, 100.), texture(iChannel1, uv).r * 2., 1.);\n    \n    \n    vec3 point = vec3(uv,0.);\n    vec3 eye = vec3(iMouse.xy/iResolution.xy,10.0);\n    vec3 color = vec3(0);\n    vec3 lightColor = vec3(3.);\n    vec3 lightPos = vec3(iMouse.xy/iResolution.xy,0.2);\n    vec3 absorption = vec3(1.);\n    \n    //vec3 normal = bumpFromDepth(iChannel1, uv, iResolution.xy, .1).rgb;\n    bool rc = renderLayer(point, eye, color, uv, normal, lightColor, lightPos, absorption, iChannel1, materials[0] );\n    if( rc )\n    {\n        materials[1] = Material(texture(iChannel0, uv).rgb, vec3(0.),vec4(.1, .7, .7, 1000.),.01,1.); // TODO : make an update function for material\n        normal = bumpFromDepth(iChannel0, uv, iResolution.xy, .01).rgb;\n        renderLayer(point, eye, color, uv, normal, lightColor, lightPos, absorption, iChannel0, materials[1] );\n    }\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n    */\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsdXDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 158, 158, 193], [195, 195, 273, 273, 557], [559, 559, 631, 631, 780], [782, 782, 974, 974, 2087], [2089, 2089, 2117, 2117, 2198], [2208, 2208, 2265, 2315, 3837]], "test": "untested"}
{"id": "slGGDD", "name": "Gradient Stripe", "author": "malted", "description": "My first shader.", "tags": ["gradient", "sine"], "likes": 0, "viewed": 196, "published": 3, "date": "1637695714", "time_retrieved": "2024-07-30T18:46:24.578448", "image_code": "float lerp(float a, float b, float t) {\n    return (1. - t) * a + b * t;\n}\nfloat invLerp(float a, float b, float v) {\n    return (v - a) / (b - a);\n}\nfloat remap(float iMin, float iMax, float oMin, float oMax, float v) {\n    float t = invLerp(iMin, iMax, v);\n    return lerp(oMin, oMax, t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    vec3 col = vec3(0.14);\n    float lw = remap(-1., 1., .05, .4, sin(iTime*2.));\n    vec3 lc = vec3(uv.x, sin(iTime*2.), .6);\n    \n    bool eq = uv.x <= uv.y - lw || uv.x >= uv.y + lw;\n\n    if (!eq) {\n        col = lc;\n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slGGDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 74], [75, 75, 117, 117, 149], [150, 150, 220, 220, 292], [294, 294, 351, 351, 662]], "test": "untested"}
{"id": "7tGGDW", "name": "Log Polar Cog Distortion", "author": "SnoopethDuckDuck", "description": "quite happy with this one", "tags": ["e"], "likes": 11, "viewed": 294, "published": 3, "date": "1637682023", "time_retrieved": "2024-07-30T18:46:25.340411", "image_code": "float thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    uv /= cosh(length(uv) * 1.1);\n\n    float a = atan(uv.y, uv.x);\n    float r = length(uv);\n    \n    uv = vec2(thc(2.,a), thc(2., 0.1 * thc(3.,10. * a + iTime) + log(r) - 0.5 * iTime));\n\n    float sc = 0. + 1.5 * (1. + 0.1 * thc(3., log(r) + 1. * iTime)) * thc(1., 4. * r + iTime);\n    //sc = tan(sc);\n    //vec2 ipos = floor(sc * uv) + 0.5;\n    vec2 fpos = fract(sc * uv) - 0.5;\n    \n    float d = length(fpos);\n    float v = 0.5 + 0.5 * cos(6. * uv.y - iTime);    \n    float k = 0.4 * (1.-v); // anything * (1.-v) works\n    float s = smoothstep(-k,k,v-d) - smoothstep(-k,k, 0.3-d); // was 0.1\n    \n    // s * X + ..., higher X = more distortion\n    s = cos(s*4. + 2. * a + 8. * r + iTime);\n    vec3 col = s * pal(uv.y + s, vec3(1.), vec3(1.), vec3(1.), vec3(0.,uv.y,2. * uv.y));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tGGDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 70], [72, 72, 101, 101, 142], [144, 144, 171, 171, 212], [214, 214, 241, 241, 282], [284, 284, 352, 352, 395], [397, 397, 417, 417, 492], [494, 494, 518, 518, 558], [560, 560, 617, 617, 1522]], "test": "untested"}
{"id": "stG3WW", "name": "Full Charge", "author": "xenn", "description": "Custom mandelbox", "tags": ["fractal", "gi", "dof", "bloom", "depthoffield", "ao", "mandelbox"], "likes": 20, "viewed": 411, "published": 3, "date": "1637679168", "time_retrieved": "2024-07-30T18:46:26.440470", "image_code": "\n// Fork of \"Weird mandelbox\" by loicvdb. https://shadertoy.com/view/3t3GWH\n// 2021-06-06 02:02:38\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 bloom(float scale, float threshold, vec2 fragCoord){\n    float logScale = log2(scale)+1.0;\n    \n    vec3 bloom = vec3(0);\n    for(int y = -1; y <= 1; y++)\n        for(int x = -1; x <= 1; x++)\n            bloom += textureLod(iChannel0, (fragCoord+vec2(x, y) * scale)/iResolution.xy, logScale).rgb;\n    \n    return max(bloom/9.0 - vec3(threshold), vec3(0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    \n    vec3 bloomSum = bloom(.1 * iResolution.y, .9, fragCoord) * .2\n        \t\t  + bloom(.2 * iResolution.y, .5, fragCoord) * .2;\n    \n    fragColor = vec4(ACESFilm(col + bloomSum), 1.0);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define MaxSteps 64\n#define MaxShadowSteps 16\n#define AmbientLightSteps 8\n#define MaxDist 2.0\n#define MinDist .015\n#define GIStrength 10.03\n#define AOStrength 1.0\n\nvec3 CamPos = vec3(0, 0, -11.);\nvec3 CamRot = vec3(0);\nfloat CamFocalLength = 01.5;\n\nvec3 LightDir;\nvec3 LightColor = vec3(.4, .5, .7) * 3.;\nfloat LightRadius = .05;\n\nfloat Scale = 2.25;\nfloat Radius = .25;\nint Iterations = 9;\nmat3 Rotation;\n\nfloat distanceEstimation(vec3 position){\n    position *= Rotation;\n\tvec4 scalevec = vec4(Scale, Scale, Scale, abs(Scale)) / Radius;\n\tfloat C1 = abs(Scale-1.0), C2 = pow(abs(Scale), float(1-Iterations));\n\tvec4 p = vec4(position.xyz, 1.0), p0 = vec4(position.xyz, 1.0);\n\tfor (int i=0; i< Iterations; i++) {\n    \tp.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;\n    \tp.xyzw *= clamp(max(Radius/dot(p.xyz, p.xyz), Radius), 0.0, 1.0);\n        if(i < 2) p.xyz *= Rotation;\n    \tp.xyzw = p*scalevec + p0;\n\t}\n\treturn (length(p.xyz) - C1) / p.w - C2;\n}\n\nvec3 normalEstimation(vec3 pos, float dist){\n  vec2 k = vec2(dist, 0);\n  return normalize(vec3(distanceEstimation(pos + k.xyy),\n\t  \t\t\t\t\tdistanceEstimation(pos + k.yxy),\n  \t\t\t\t\t\tdistanceEstimation(pos + k.yyx))\n\t\t\t\t - vec3(dist));\n}\nvec3 normalEstimation(vec3 pos){\n  float dist = distanceEstimation(pos);\n  return normalEstimation(pos, dist);\n}\n\nvec3 backgroundColor(vec3 dir){\n    return texture(iChannel0, dir).rgb * 0.;\n}\n\n//blurred cubemap for ambient lighting\nvec3 backgroundColorHemi(vec3 dir){\n    return textureLod(iChannel1, dir, 9.5).rgb;\n}\n\nvec3 directLight(vec3 pos, vec3 normal){\n    float dotLight = -dot(normal, LightDir);\n    if(dotLight < 0.0) return vec3(0);\n    vec3 pos0 = pos;\n    float minAngle = LightRadius;\n    for(int i = 0; i < MaxShadowSteps; i++){\n        float dist = distanceEstimation(pos);\n        if(dist > MaxDist) break;\n        if(dist < MinDist) return vec3(0.0);\n        pos -= LightDir * dist * 3.0;\t//goes 3 times faster since we don't need details\n        minAngle = min(asin(dist/length(pos-pos0)), minAngle);\n    }\n    return LightColor * dotLight * clamp(minAngle/LightRadius, .0, 1.0);\n}\n\nvec3 ambientLight(vec3 pos){\n    vec3 pos0 = pos;\n    float dist0 = distanceEstimation(pos);\n    vec3 normal = normalEstimation(pos).xyz, gi, al = vec3(0.0);\n    float ao = 1., dist = dist0;\n    for(int i = 0; i < AmbientLightSteps; i++){\n        float expectedDist = dist * (1. + .8);\n        dist = distanceEstimation(pos);\n        float weight = AOStrength*(1.-float(i)/float(AmbientLightSteps));\t//more weight to first samples\n        ao *= pow(clamp(dist/expectedDist, 0., 1.0), weight);\n        normal = normalize(normalEstimation(pos, dist)+1.5*normal); //\"smoothed\" normal to avoid artifacts\n        pos += normal * .8*dist; //slightly shorter to avoid artifacts\n        al += backgroundColorHemi(normal);\n        if(i == 6 || i == 13) gi += ao*directLight(pos, normal); // two GI samples\n    }\n    gi *= GIStrength/2.0;\n    return gi + al/float(AmbientLightSteps) * ao;\n}\n\nbool trace(inout vec3 pos, in vec3 dir, out vec3 n){\n    for(int i = 0; i < MaxSteps; i++){\n        float dist = distanceEstimation(pos);\n        if(dist > MaxDist) break;\n        if(dist < MinDist){\n            n = normalEstimation(pos);\n            for(int j = 0; j < 3; j++){\n                dist = distanceEstimation(pos) - 2.*MinDist;\n        \t\tpos += dist * dir;\n            }\n            return true;\n        }\n        pos += dir * dist;\n    }\n    return false;\n}\n\n\nvec4 rayTrace(vec3 pos, vec3 dir){\n    for(int i = 0; i < 5; i++){ //to get to a distance inferior to MaxDist\n        float dist = distanceEstimation(pos);\n        pos += dist * dir;\n        if(dist < MaxDist) break;\n    }\n    vec3 n;\n    if(!trace(pos, dir, n))\n        return vec4(backgroundColor(dir), 10.0);\n    return vec4(directLight(pos, n)+ambientLight(pos), length(CamPos - pos));\n}\n\nmat3 rotationMatrix(vec3 rotEuler){\n    float c = cos(rotEuler.x), s = sin(rotEuler.x);\n    mat3 rx = mat3(1, 0, 0, 0, c, -s, 0, s, c);\n    c = cos(rotEuler.y), s = sin(rotEuler.y);\n    mat3 ry = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    c = cos(rotEuler.z), s = sin(rotEuler.z);\n    mat3 rz = mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n    \n    return rz * rx * ry;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    float time = iTime + 43.;\n    \n    //fractal animation\n    Rotation = rotationMatrix(vec3(time, time*.7, time*.4)*.2);\n    Scale += sin(time*.5)*.25;\n    Radius += cos(time) *.25;\n    \n    //light animation\n    LightDir = normalize(vec3(sin(time*.6), -1, cos(time*.6)));\n    \n    //camera animation\n    CamRot.z = sin(time*.4)*.182;\n    \n    vec2 uv = (fragCoord-iResolution.xy/2.0) / iResolution.y;\n    vec3 rayDir = normalize(vec3(uv, CamFocalLength)) * rotationMatrix(CamRot);\n\n    fragColor = rayTrace(CamPos, rayDir);\n    \n}", "buffer_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "\n\n// triplannar mapping https://www.youtube.com/watch?v=lctXaT9pxA0&t=1031s\nvec3 TriplannarStarsTexture(vec3 p, vec3 normal)\n{\n    // the scale of the texture\n    float scale = 0.1125;\n    // the sharpness of the blending between different axises\n    float blendSharpness = 20.;\n    // finding the different axise's color\n    vec3 colX = texture(iChannel3, p.zy * scale).rgb;\n    vec3 colY = texture(iChannel3, p.xz * scale).rgb;\n    vec3 colZ = texture(iChannel3, p.xy * scale).rgb;\n    \n    // finding the blending amount for each axis\n    vec3 bw = pow(abs(normal), vec3(blendSharpness));\n    // making it so the total (x + y + z) is 1\n    bw /= dot(bw, vec3(1.));\n    \n    // finding the final color\n    return colX * bw.x + colY * bw.y + colZ * bw.z;\n}\n\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    if (iFrame < 60)\n    {\n        vec3 rd = rayDir;\n        // the direction and color of the sun\n        vec3 sun_col = vec3(10., 05.9, 10.6);\n       // vec3 sun_dir = normalize(vec3(sin(iTime), 0.75, cos(iTime)));\n        vec3 sun_dir = normalize(vec3(0., 0.75, -1.));\n\n        // using triplanar mapping to map the stars texture onto the sky\n        vec3 col = pow(TriplannarStarsTexture(rd * 5., rd), vec3(4.));\n        col = mix(col, sun_col * 1.2, pow(max(dot(sun_dir, rd), 0.), 200.));\n\n        fragColor = vec4(col, 1.0);\n    }\n    else\n    {\n        // not doing the math to calculate things like this after frame 60 to give better preformace\n        fragColor = texture(iChannel0, rayDir);\n    }\n}\n\n", "cube_a_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//first DoF pass\n\n#define Aperture .05\n#define DoFClamping .35\n#define DoFSamples 32\n\n#define dir normalize(vec2(1.0, 1.0))\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    //autofocus\n    float focalDistance = texture(iChannel0, vec2(.5), 5.0).a;\n    \n    vec4 col = vec4(0);\n    float samples = 0.0, dr, influence, depth;\n    vec2 d;\n    vec4 p;\n    for(int i = 0; i < DoFSamples; i++){\n        d = dir * float(2*i-DoFSamples)/float(DoFSamples) * DoFClamping;\n        p = texture(iChannel0, (fragCoord + d*iResolution.y*Aperture)/iResolution.xy);\n        dr = min(abs(p.a-focalDistance)/p.a, DoFClamping);\n        influence = clamp((dr - length(d))*iResolution.y*Aperture + .5, 0.0, 1.0) / (dr*dr+.001);\n        col += influence * p;\n        samples += influence;\n    }\n    \n    col /= samples;\n    \n    fragColor = col;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//second DoF pass\n\n#define Aperture .05\n#define DoFClamping .35\n#define DoFSamples 32\n\n#define dir normalize(vec2(1.0, -1.0))\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    //autofocus\n    float focalDistance = texture(iChannel0, vec2(.5), 5.0).a;\n    \n    vec4 col = vec4(0);\n    float samples = 0.0, dr, influence, depth;\n    vec2 d;\n    vec4 p;\n    for(int i = 0; i < DoFSamples; i++){\n        d = dir * float(2*i-DoFSamples)/float(DoFSamples) * DoFClamping;\n        p = texture(iChannel0, (fragCoord + d*iResolution.y*Aperture)/iResolution.xy);\n        dr = min(abs(p.a-focalDistance)/p.a, DoFClamping);\n        influence = clamp((dr - length(d))*iResolution.y*Aperture + .5, 0.0, 1.0) / (dr*dr+.001);\n        col += influence * p;\n        samples += influence;\n    }\n    \n    col /= samples;\n    \n    fragColor = col;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Pi  3.14159265359\n\n#define FocalDistance 1.4\n#define LensRatio 3.5\n#define Margins .1\n\n\nfloat _viewDepth = -1.;\n\nvec3 _sunPos (float time)\n{\ntime = time * .5;\n    // cos(time*0.25)*0.85, sin(time*0.25)*0.6-0.2, 0.0\n    return vec3(-0.6+sin(time*0.2), cos(time*0.2), sin(time*0.2) );       \n}\n\nvec3 _moonPos (float time)\n{\n    time = time * .5;\n    time -= 5.;\n    return vec3(-2.0+sin(time*0.2)*1.5, cos(time*0.2), sin(time*0.2) );          \n}\n\n\n// interpolation\nfloat gaussianInterpol (float t, float a, float b, float c)\n{\n    // a - amplitude, b - center pos, c - frequency\n    return a * exp(-(t-b)*(t-b) / (2.0*c*c));\n   \n}\n\n// fractal noise\n\nfloat random3D(vec3 xyz, vec3 dir)\n{\n    float val = dot(xyz, dir);\n    return fract(30.0 * sin(val));\n}\n\n\n// transformations\n\nmat4 rotX(float angle)\n{\n    mat4 rotMatrix = mat4\n    (\n        vec4( 1.0,        0.0,        0.0, 0.0),\n        vec4( 0.0, cos(angle), sin(angle), 0.0),\n        vec4( 0.0,-sin(angle), cos(angle), 0.0),\n        vec4( 0.0,        0.0,        0.0, 1.0)\n    );\n    \n    return rotMatrix; \n}\n\nmat4 rotY(float angle)\n{\n    mat4 rotMatrix = mat4\n    (\n        vec4( cos(angle), 0.0, -sin(angle), 0.0),\n        vec4(        0.0, 1.0,         0.0, 0.0),\n        vec4( sin(angle), 0.0,  cos(angle), 0.0),\n        vec4(        0.0, 0.0,         0.0, 1.0)\n    );\n    \n    return rotMatrix; \n}\n\nmat4 rotZ(float angle)\n{\n    mat4 rotMatrix = mat4\n    (\n        vec4( cos(angle), sin(angle), 0.0, 0.0),\n        vec4(-sin(angle), cos(angle), 0.0, 0.0),\n        vec4(        0.0,        0.0, 1.0, 0.0),\n        vec4(        0.0,        0.0, 0.0, 1.0)\n    );\n    \n    return rotMatrix; \n}\n\n// math utils\nfloat magnitude(vec3 a)\n{\n    return sqrt(a.x*a.x + a.y*a.y + a.z*a.z);\n}\n\nvec3 normalized(vec3 a)\n{\n    return a/length(a);\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stG3WW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 123, 123, 263], [265, 265, 322, 322, 627], [629, 629, 686, 686, 946]], "test": "untested"}
{"id": "ftyGWD", "name": "Hexagonal Prism Flip", "author": "Shane", "description": "Flipping prisms on an extruded grid.", "tags": ["hexagon", "motion", "physics", "flip", "design", "extrude"], "likes": 85, "viewed": 1064, "published": 3, "date": "1637678815", "time_retrieved": "2024-07-30T18:46:27.391926", "image_code": "/*\n\n    Hexagonal Prism Flip\n    --------------------\n\n\tFlipping boxes and so forth from their standing cell position within\n    a grid is a video loop standard. There are infinite variations, and \n    this is one of the simpler ones.\n    \n    Other than a bit of basic physics in the form of vector and matrix \n    manipulation, there's not a lot to it: Start off with an extruded grid\n    of objects of some kind, animate the individual cell heights and \n    rotate... That can get a bit fiddly, but it's not too bad.\n    \n    Not a lot of effort was put into this. I used a recent extruded grid \n    shader as a template, manipulated the height routine, then colored the \n    objects a little. I kept the rendering style simple. \n    \n\n\n\tPhysics shaders:\n    \n\t// If you search \"physics\" on Shadertoy, Dr2's name will feature\n    // a lot. Here's a fun motion and collision example.\n    Rolling Stones - Dr2 \n\thttps://www.shadertoy.com/view/MdsfD7\n    \n    // I love this.\n    Loop Ramp - glk7 \n    https://www.shadertoy.com/view/wtfXD4\n    \n    // A bouncing motion example with a really elegant solution.\n    Bouncing Balls Example - blackle\n    https://www.shadertoy.com/view/sss3W8\n\n\n*/\n\n\n// Global tile scale.\nvec2 scale = vec2(1./5., 1./5.);\n\n// Off the rows by half a cell to produce a brickwork feel. The staggered \n// effect can also make a quantized image look smoother.\n#define ROW_OFFSET\n\n// Use hexagon pylons instead of squares.\n#define HEXAGON\n\n// Boring out holes on alternate blocks to give it more of a tech feel and\n// to provide a little extra visual stimuli. Without the holes, the image\n// looks cleaner, but less interesting, I feel.\n#define HOLES\n\n// Raising the faces of the pylon tops. I find it can help bounce the light \n// off the surface in a more reflective way.\n//#define RAISED\n\n// Putting a ridge decoraction on the pylon tops.        \n#define RIDGES\n\n\n// The hexagons must use offset rows.\n#ifdef HEXAGON\n#ifndef ROW_OFFSET\n#define ROW_OFFSET\n#endif\n#endif\n\n// Max ray distance.\n#define FAR 20.\n\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n\nfloat hash21(vec2 p){  \n    \n    // Attempting to fix accuracy problems on some systems by using\n    // a slight variation on Dave Hoskin's hash formula, here:\n    // https://www.shadertoy.com/view/4djSRW\n    vec3 p3 = fract(vec3(p.xyx)*.1031);\n    p3 += dot(p3, p3.yzx + 43.123);\n    return fract((p3.x + p3.y)*p3.z);\n    \n    //p = fract(p*2.014371)*128. - vec2(63.537567, 64.484713);\n    //return fract(dot(p.xyx*p.xyy, vec3(128.390654, 128.713193, 2.1396217)));\n    \n    // IQ's vec2 to float hash.\n    //return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); \n}\n\n\n// Height map value. A keyframe time variable is also passed in for usage\n// inside the block function.\nfloat hm(in vec2 p, inout float tm){ \n\n    \n    // Unique random number for this grid cell.\n    float rnd = hash21(p + .13);\n     \n    // Time variable: Manipulated to periodically fit into transcendental functions.\n    // Modulo 8, in this case, means 8 keyframes. The random variable ensures that\n    // the cell object moves at random times compared to its neighbors.\n    tm = mod(rnd*8. + iTime*4./6.2831, 8.);\n    \n    // Keep the time variable (and as such, height) static for all but the first keyframe.\n    tm = (tm<1.)? tm : 0.;\n\n    // A cheap function to create an undulating wave below the flipping object.\n    //p *= 2.;\n    float waveHeight = dot(sin(p*1.4 - cos(p.yx*2.2 + mod(iTime, 6.2831))*2.), vec2(.25)) + .5;\n\n    // Object height. Just a periodic function that goes up and down within\n    // the first keyframe and remains at zero height for the other keyframes.\n    float h = .5 - cos(tm*6.2831)*.5;\n    \n    // The total height is a mixture of the wave and periodic up-down function.\n    // It's range is roughly zero to one, but not quite.\n    return (h/4. + .25)*waveHeight + h;\n    \n    \n}\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2(sdf, abs(pz) - h);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n}\n\n/*\n// IQ's extrusion formula with smoothing.\nfloat opExtrusionS(in float sdf, in float pz, in float h, in float sf){\n   \n    // Slight rounding. A little nicer, but slower.\n    vec2 w = vec2(sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n    \n}\n*/\n\n#ifdef HEXAGON\n// Signed distance to a regular hexagon, with a hacky smoothing variable thrown\n// in. -- It's based off of IQ's more exact pentagon method.\nfloat sHexS(in vec2 p, float r, in float sf){\n    \n      // Flat top.\n      //const vec3 k = vec3(-.8660254, .5, .57735); // pi/6: cos, sin, tan.\n      // Pointed top.\n      const vec3 k = vec3(.5, -.8660254, .57735); // pi/6: cos, sin, tan.\n     \n      // X and Y reflection.  \n      p = abs(p); \n      p -= 2.*min(dot(k.xy, p), 0.)*k.xy;\n\n      r -= sf;\n      // Polygon side.\n      // Flat top.\n      //return length(p - vec2(clamp(p.x, -k.z*r, k.z*r), r))*sign(p.y - r) - sf;\n      // Pointed top.\n      return length(p - vec2(r, clamp(p.y, -k.z*r, k.z*r)))*sign(p.x - r) - sf;\n    \n}\n#endif\n\n/*\n// IQ's unsigned box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n*/\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n\n// Hack to obtain a couple of the static ground shape to create\n// the floor honeycomb.\nfloat shape;\n\n// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed square pylons.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n\nvec4 blocks(vec3 q3){\n    \n    \n\n    // Brick dimension: Length to height ratio with additional scaling.\n    vec2 l = scale;\n\tvec2 s = scale*2.;\n    #ifdef HEXAGON\n    vec2 hSc = vec2(1, scale.y/scale.x*2./1.732);\n    #endif\n    \n    float minSc = min(scale.x, scale.y);\n    \n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual brick ID.\n    vec2 id = vec2(0); \n    \n    // Four block corner postions.\n    #ifdef ROW_OFFSET\n    // Offset rows.\n    vec2[4] ps4 = vec2[4](vec2(-.25, .25), vec2(.25), vec2(.5, -.25), vec2(0, -.25)); \n    #else\n    vec2[4] ps4 = vec2[4](vec2(-.25, .25), vec2(.25), vec2(.25, -.25), vec2(-.25)); \n    #endif\n    \n    float data = 0.; // Extra data.\n    \n    shape = 1e5;\n    \n    for(int i = min(0, iFrame); i<4; i++){\n\n\n        // Local coordinates.\n        p = q3.xy;\n        ip = floor(p/s - ps4[i]) + .5; // Local tile ID.\n        \n        // Correct positional individual tile ID.\n        vec2 idi = (ip + ps4[i])*s;\n        \n        p -= idi; // New local position.\n\n\n        // The extruded block height. See the height map function, above.\n        \n        /// Keyframe time variable.\n        float tm;\n\n        float h = hm(idi, tm);\n        \n        // Flip direction.\n        float dir = (hash21(idi +.07)<.5)? 1. : -1.;\n        // Randomly doubling the flip magnitude... Number of airborn flips.\n        dir *= (hash21(idi +.05)<.5)? 2. : 1.;\n        \n        // It's necessary to let the object clear the ground before rotating, and \n        // for it to finish its rotation upon arrival, so a delay in the rotation \n        // process is necessary. How you arrange that is up to you, but this is how\n        // I did it. It works, but I feel there'd be more elegant solutions.\n        float delay = .175; // Spinning delay - Range: [0, 1].\n        const float totRot = 3.14159; // Total rotation.\n        mat2 cR = (abs(tm - .5)<.5 - delay)? \n                   rot2(dir*(tm - delay)/(1. - delay*2.)*totRot) : mat2(1, 0, 0, 1);\n        \n        // Move the object off the ground.\n        vec3 p3 = vec3(p, q3.z + (h*scale.y*2. - (l.y/2. - .02)*1.));\n        \n        // Rotate.\n        //p3.xy *= cR; // Rotating more than one axis... Probably a bit much.\n        p3.yz *= cR;\n               \n            \n        const float ew = .0125;\n        #ifdef HEXAGON\n        // Hexagon option. ROW_OFFSET is automatically turned on.\n        float di2D = sHexS(p3.xy, minSc/1.732 - ew, .01);\n        //float di2D = length(p3.xy) - (minSc/1.732 - ew); // Cylinder option.\n        \n        // Unrotated shape to carve out the floor.\n        float shp = sHexS(p, minSc/1.732 - ew, .01);\n        //float shp = length(p.xy) - (minSc/1.732 - ew); // Cylinder option.\n        #else\n        \n        float di2D = sBoxS(p3.xy, l/2. - ew, .01);  \n        //float di2D = length(p3.xy) - (minSc/2. - ew); // Cylinder option.\n        // Unrotated shape to carve out the floor.\n        float shp = sBoxS(p.xy, l/2. - ew, .01);\n        //float shp = length(p.xy) - (minSc/2. - ew); // Cylinder option.\n        #endif\n        \n        \n        \n        \n        \n        #ifdef HOLES\n        // Boring out some of the boxes.\n        if((i&1)==0)\n        {\n            di2D = max(di2D, -(di2D + minSc/3.5));\n            //shp = max(shp, -(shp + minSc/4.));\n        }\n        #endif\n        \n        shape = min(shape, shp);\n        \n        \n        // The extruded distance function value.\n        float di = opExtrusion(di2D, p3.z, l.y/2.*(1. - h*.0) - ew);\n\n        \n        #ifdef RAISED\n        // Raised tops.\n        di += di2D*.25;//min(di2D, di2DB)*.5;\n        #endif\n        \n        #ifdef RIDGES\n        // Putting ridges on the faces.\n        di += smoothstep(-.5, .5, sin(di2D/minSc*6.2831*5.))*.005;\n        #endif\n        \n        /*\n        // Lego.\n        float cap = length(p3.xy) - minSc/6.;\n        cap = opExtrusion(cap, p3.z, l.y/2.*(1. - h*.0) - ew + .035);\n        di = min(di, cap); //di = max(di, -cap)\n        */\n        \n        \n\n        // If applicable, update the overall minimum distance value,\n        // ID, and box ID. \n        if(di<d){\n            d = di;\n            id = idi;\n            // Extra data. In this case, the 2D distance field.\n            data = di2D;\n            \n        }\n        \n    }\n    \n    // Return the distance, position-base ID and box ID.\n    return vec4(d, id, data);\n}\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec4 gID;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Floor.\n    float fl = (-p.z + .02);\n    //float fl = (-p.z + .02) + scale.y/2.;\n    \n    // The extruded blocks.\n    vec4 d4 = blocks(p);\n    gID = d4; // Individual block ID.\n    \n    \n    // Cutting out prism shapes from the floor to create the honeycomb mold\n    // for the prism block objects to sit in.\n    fl = max(fl, -max(shape, abs(p.z) - scale.y));\n    \n    #ifdef RIDGES\n    // Hollowing ridge grooves into the floor.\n    float minSc = min(scale.x, scale.y);\n    fl -= smoothstep(-.5, .5, sin(shape/minSc*6.2831*5.))*.005;\n    #endif\n    \n    #ifdef RAISED\n    // Hollowing out the floor to match the raised tops on the objects.\n    fl -= shape*.25;//min(di2D, di2DB)*.5;\n    #endif\n\n    // Debug to see the honeycomb floor only.\n    //d4.x += 1e5;\n \n    // Overall object ID.\n    objID = fl<d4.x? 1. : 0.;\n    \n    // Combining the floor with the extruded object.\n    return  min(fl, d4.x);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = min(0, iFrame); i<64; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        t += i<32? d*.4 : d*.9; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not always affordable. :)\n    const int maxIterationsShad = 32; \n    \n    ro += n*.0015; // Coincides with the hit condition in the \"trace\" function.  \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), .0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, \n    // the lowest number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += clamp(d, .01, stepDist), etc.\n        t += clamp(d, .01, .15); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 3., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    #ifdef HEXAGON\n    scale *= vec2(2./1.732, 1);\n\t#endif\n    \n\t// Camera Setup.\n    // Tilted camera, just to prove it's 3D. :)\n\t//vec3 ro = vec3(0, -1.3, -2.2); // Camera position, doubling as the ray origin.\n\t//vec3 lk = ro + vec3(0, .12, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n\t// Front on camera.\n    vec3 ro = vec3(0, iTime/16., -1.5); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, .05, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(-.25, .5, .5);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Swiveling the camera about the XY-plane.\n\trd.xy *= rot2( sin(iTime)/32. );\n    \n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block field value, block ID and 2D data field value.\n    vec4 svGID = gID;\n    \n    float svObjID = objID;\n    \n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n        vec3 sn = getNormal(sp, t);\n        \n            \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n      \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        //float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 2.);\n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.15, 1., Schlick);  //F0 = .2 - Glass... or close enough. \n        \n          \n        // Scene object color. \n\t    vec3 texCol;   \n\n        \n        if(svObjID<.5){\n            \n            // The flipping prisms.\n            \n            // Manipulating IQ's cosine palette for golden hues.\n            vec3 cCol = (.5 + .45*cos(6.2831*hash21(svGID.yz)/5. + vec3(0, 1, 2) - .1));\n            \n            // Turning it into a pink palette.\n            texCol = mix(min(cCol.xzy*1.65, 1.), vec3(1), .05);\n            \n            // Light based gradient mix.\n            texCol = mix(texCol, texCol.zyx, smoothstep(-.25, .5, ld.y));\n            //texCol = texCol.yxz; // Color swizzle.\n            \n            // Plain white.\n            //texCol = vec3(.75);\n            // Greyscale.\n            //texCol = vec3(hash21(svGID.yz + .15)*.5 + .35);\n \n        }\n        else {\n            \n            // The floor with the bored out honeycomb.\n            texCol = (sp.z>scale.y - .01)? vec3(.2, .4, 1) : vec3(.05);\n            \n            texCol = mix(texCol, texCol.yzx, smoothstep(-.25, .5, -ld.y)*.25);\n            \n            //texCol = mix(texCol.yxz, texCol, .75);\n        }\n       \n        \n        // Combining the above terms to produce the final color.\n        col = texCol*(diff*sh + .3 + vec3(1, .97, .92)*spec*freS*2.*sh);\n      \n        // Shading.\n        col *= ao*atten;\n        \n          \n\t\n\t}\n          \n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftyGWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2116, 2149, 2171, 2171, 2229], [2233, 2233, 2254, 2437, 2804], [2807, 2911, 2947, 3002, 4027], [4030, 4057, 4114, 4114, 4214], [5391, 5419, 5466, 5466, 5556], [10439, 10462, 10480, 10499, 11399], [11403, 11424, 11460, 11509, 11960], [11963, 12054, 12090, 12433, 12705], [12709, 12900, 12952, 13033, 14301], [14304, 14456, 14491, 14491, 14736], [14739, 14739, 14795, 14828, 19501]], "test": "untested"}
{"id": "flVGDR", "name": "the book of shader 练习 Patterns 图", "author": "suolong", "description": "the book of shader 练习", "tags": ["thebookofshader"], "likes": 2, "viewed": 231, "published": 3, "date": "1637677646", "time_retrieved": "2024-07-30T18:46:28.231680", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.y;\n    uv*=12.0;\n    float t = step(1.0,mod(floor(uv.y),2.0))>0.?1.0:-1.0;\n    float t1 = step(1.0,mod(floor(uv.x),2.0))>0.?1.0:-1.0;\n\n    float b = cos(iTime)>0.?1.0:-1.0;\n    float offx = b>0.?b*t*sin(iTime)*2.0:0.;\n    float offy = b>0.?0.:b*t1*sin(iTime)*2.0;\n    uv += vec2(offx,offy);\n    uv = fract(uv);\n    \n    float dis = distance(uv,vec2(0.5));\n    float a = 1.0-smoothstep(0.3,0.35,dis);\n    vec3 col = vec3(a);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flVGDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 579]], "test": "untested"}
{"id": "sly3Dz", "name": "the book of shader 练习", "author": "suolong", "description": "the book of shader 练习", "tags": ["thebookofshader"], "likes": 4, "viewed": 216, "published": 3, "date": "1637677522", "time_retrieved": "2024-07-30T18:46:29.002619", "image_code": "/**\n* the book of shader 的提问练习\n* 图形不是本人设计\n*/\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\nfloat ng(vec2 st,float N,float size,float radian){\n   float a =  atan(st.x,st.y)+radian;\n   float r = TWO_PI/float(N);\n   float d = cos(floor(.5+a/r)*r-a)*length(st);\n   return 1.0-smoothstep(size,size+0.5,d);\n}\nfloat circle(vec2 st,vec2 c,float r,float d,float start,float end){\n  vec2 dir = st-c;\n  float a = atan(dir.y,dir.x);\n  a = step(start,a)*step(a,end);\n  return (smoothstep(r-d,r-d+0.2,distance(st,c))-smoothstep(r,r+0.2,distance(st,c)))*a;\n}\nfloat segment(vec2 st,float pct,float w,float s,float e){\n  return (step(-w*0.5,st.y-pct)-step(w*0.5,st.y-pct))*step(s,st.x)*step(st.x,e);\n}\nvec3 circle2(vec2 st,vec2 c,float r){\n  vec3 col = vec3(0.995,0.325,0.085);\n  float c1 = circle(st,c,r*0.1,r*0.1*0.1,-PI,PI);\n  float c2 = circle(st,c,r*0.1,r*0.1,-PI,PI)*step(0.0,sin(iTime*50.0));\n  float rs= abs(sin(iTime));\n  r =r*rs;\n  float c3 = circle(st,c,r,r,-PI,PI);\n  vec3 lc= col*(smoothstep(r*0.6,r,distance(st,c))-smoothstep(r,r,distance(st,c)));\n  return lc+col*(c1+c2); \n}\nvec3 circle3(vec2 st,vec2 c,float r){\n  vec3 col = vec3(0.240,0.63,0.87);\n  mat2 rotate =mat2(cos(iTime),-sin(iTime),\n                    sin(iTime),cos(iTime));\n  st=rotate*st;\n  float a = PI*0.5;\n  float b = atan(st.y,st.x);\n  float d = (1.0-step(r,distance(st,c)))*step(0.,b)*step(b,a);\n  return col*d*smoothstep(0.0,1.0,b*0.5)+col*step(0.,st.x)*step(st.x,0.2)*step(0.,st.y)*step(st.y,r);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float size = 100.0;   \n    vec2 st = fragCoord/iResolution.y*size-vec2(iResolution.x/iResolution.y,1.0)*size*0.5;\n    vec3 col = vec3(0.0);\n    vec3 col1 = vec3(.6,0.6,0.6);\n    vec3 col2 = vec3(0.583,0.938,0.995);\n    vec3 col3 = vec3(1.,1.,1.);\n    vec3 col4 = vec3(0.773,0.957,0.995);\n    vec3 col5 = vec3(0.583,0.938,0.995);\n\n    float r = 30.0;\n    float w = 0.3;\n    float w1 = w*0.8;\n    float w2 = w*1.2;\n    float x = r*cos(PI/4.0);\n    float l1 = segment(st,st.x,w1,-x,x);\n    col += col1*l1;\n    float l2 = segment(st,-st.x,w1,-x,x);\n    col += col1*l2;\n\n    vec2 c = vec2(0.0);\n    float c1 = circle(st,c,r*0.1,w1,-PI,PI);\n    float c2 = circle(st,c,r*0.5,w1,-PI,PI);\n    float c3 = circle(st,c,r*0.7,w1,-PI,PI);\n    float c4 = circle(st,c,r,w1,-PI,PI);\n    col+= col2*(c1+c2+c3);\n    col+= col3*c4;\n\n    float a = PI*0.1*2.0*(0.5+abs(sin(iTime))*0.5);\n    float c5 = circle(st,c,r*1.2,w,a,PI-a);\n    float c6 = circle(st,c,r*1.2,w,-PI+a,-a);\n    col+= col4*c5+c6;\n     \n    float d = 0.05;\n    float c7 = circle(st,c,r*1.5,w2,d,PI-d);\n    float c8 = circle(st,c,r*1.5,w2,-PI+d,-d);\n    \n    \n    float tx = r*1.5 + sin(iTime)*2.0;\n    float t1 = ng(st+vec2(tx,0.0),3.0,r*1.4*tan(d*0.5),PI*0.5);\n    float t2 = ng(st-vec2(tx,0.0),3.0,r*1.4*tan(d*0.5),-PI*0.5);\n    col+= col5*(c7+c8+t1+t2);\n    float off=iTime*0.1;\n    vec2 cenoff=c+vec2(sin(off)*sin(-off)*cos(off),cos(off)*sin(off*2.0))*r; \n    vec3 cir = circle2(st,cenoff,r*0.4);\n    vec3 cir3 = circle3(st,c,r);\n\n \n    \n\n    \n    fragColor= vec4(col+cir+cir3,1.0);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sly3Dz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 125, 175, 175, 336], [337, 337, 404, 404, 577], [578, 578, 635, 635, 718], [719, 719, 756, 756, 1106], [1107, 1107, 1144, 1144, 1500], [1501, 1501, 1558, 1558, 3097]], "test": "untested"}
{"id": "NltGWs", "name": "shrink circle", "author": "suolong", "description": "收缩的圆圈", "tags": ["2dcircle"], "likes": 1, "viewed": 205, "published": 3, "date": "1637677462", "time_retrieved": "2024-07-30T18:46:29.773558", "image_code": "vec3 circle(vec2 uv,vec2 c,float r,float speed,float width,float offset){\n    vec3 col = vec3(0.);\n    float dis = length(uv-c);\n    if((mod(offset+iTime*speed,r)-width)<dis&&dis<mod(offset+iTime*speed,r)){\n      col = vec3(1.0,0.0,0.0);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y-vec2(iResolution.x/iResolution.y,1.0)*0.5;\n    int num = 6;\n    float r = 0.5;\n    float speed = -0.1;\n    float width = 0.01;\n    float split = 0.2;\n    vec3 col = vec3(0.0);\n    for(int i=0;i<num;i++){\n      col+=circle(uv,vec2(0.),r,speed,width,split*float(i));\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NltGWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 73, 73, 261], [263, 263, 320, 370, 736]], "test": "untested"}
{"id": "ftVGRh", "name": "easy sun", "author": "suolong", "description": "画日", "tags": ["sun"], "likes": 1, "viewed": 198, "published": 3, "date": "1637677453", "time_retrieved": "2024-07-30T18:46:30.713046", "image_code": "float circle (vec2 st, float pct){\n    if(st.y<2.5)return 0.0;\n  return  step(distance(st,vec2(2.5)+vec2(0,sin(iTime)*2.5)), pct);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.y*5.0-vec2(2.,0.0);\n    vec3 color = vec3(0.265,0.48,0.65);\n\n    float pct = 0.2;\n    float intensity =distance(st,vec2(2.5)+vec2(0,sin(iTime)*2.5));\n    color = color+vec3(1.000,0.800,0.306)*pow(4.132,-2.0*intensity);\n    color = mix(color,vec3(0.979,0.978,1.000),circle(st,pct));\n    color =mix(color,mix(vec3(0.1,0.2,0.3),vec3(0.2,0.4,0.8),st.y),1.0-step(2.5,st.y));\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftVGRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 132], [133, 133, 190, 240, 681]], "test": "untested"}
{"id": "Nly3WD", "name": "the book of shader随机练习", "author": "suolong", "description": "the book of shader随机练习", "tags": ["thebookofshader"], "likes": 2, "viewed": 224, "published": 3, "date": "1637675113", "time_retrieved": "2024-07-30T18:46:31.564770", "image_code": "float random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.y-vec2(iResolution.x/iResolution.y*0.5,0.5);\n    uv*=10.0;\n    float t=(noise(uv+iTime))*5.0;\n    float a= smoothstep(2.5+t,t+2.6,length(uv));\n    float b = smoothstep(2.6+t,t+2.7,length(uv));\n    a = a-b;\n    vec3 col = vec3(a);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nly3WD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 144], [146, 233, 259, 259, 776], [777, 777, 834, 834, 1138]], "test": "untested"}
{"id": "ftGGWD", "name": "Slithering Worm", "author": "dr2", "description": "Colorful worm slithering (driven by pseudo-peristalsis)", "tags": ["snake", "motion", "coordinates", "transcendental"], "likes": 14, "viewed": 333, "published": 3, "date": "1637671169", "time_retrieved": "2024-07-30T18:46:32.466358", "image_code": "// \"Slithering Worm\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat Minv2 (vec2 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit;\nfloat tCur, dstFar, tCyc, nCyc, segRot;\nconst float nSeg = 8.;\nint idObj;\nconst float pi = 3.1415927;\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nstruct Arc {\n  vec2 cs, css;\n  float chDist, ang, rad;\n};\nArc arc;\n\n#define F(x) (sin (x) / x - b)\n\nfloat SecSolve (float b)\n{  // (from \"Robotic Head\") \n  vec3 t;\n  vec2 f;\n  t.yz = vec2 (0.7, 1.2);\n  f = vec2 (F(t.y), F(t.z));\n  for (int nIt = 0; nIt < 4; nIt ++) {\n    t.x = (t.z * f.x - t.y * f.y) / (f.x - f.y);\n    t.zy = t.yx;\n    f = vec2 (F(t.x), f.x);\n  }\n  return t.x;\n}\n\nvoid ArcConf ()\n{\n  vec2 u;\n  float arcLen, arcEx, chLen, len, sep;\n  len = 2.;\n  sep = 1.;\n  arcEx = 1.;\n  arcLen = arcEx * length (vec2 (len, sep));\n  u = vec2 (len * sin (0.5 * segRot), sep);\n  chLen = length (u);\n  arc.ang = SecSolve (chLen / arcLen);\n  arc.chDist = chLen / tan (arc.ang);\n  arc.rad = sqrt (arc.chDist * arc.chDist + chLen * chLen);\n  arc.cs = sin (- arc.ang + vec2 (0.5 * pi, 0.));\n  arc.css = sin (- arc.ang - 0.002 + vec2 (0.5 * pi, 0.));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 cs;\n  float dMin, d, tRad, tBmp, s, da, rr, nc;\n  dMin = dstFar;\n  tRad = 0.5;\n  tBmp = 0.05;\n  da = 63. / (2. * arc.ang);\n  nCyc = floor (tCur / tCyc);\n  cs = sin (arc.ang * (1. - 2. * (tCur / tCyc - nCyc)) + vec2 (0.5 * pi, 0.));\n  p.y -= tRad + tBmp;\n  nc = floor (nCyc / 2.);\n  s = sign (nCyc - 2. * nc - 0.5);\n  rr = arc.rad * arc.cs.y;\n  p.x += (4. * nc + s - 2. - mod (nSeg, 2.)) * rr;\n  p.yz = p.zy;\n  p.xy *= vec2 (-1., s);\n  for (float k = float (VAR_ZERO); k < nSeg; k ++) {\n    q = p;\n    q.y *= - sign (mod (k, 2.) - 0.5);\n    q.xy -= vec2 (rr * (2. * k - nSeg + 0.5), - arc.chDist);\n    d = dot (vec2 (abs (q.x), q.y), arc.css);\n    d = max (length (vec2 (length (q.xy) - arc.rad, q.z)) - tRad + tBmp * (1. -\n       smoothstep (0.1, 0.4, 0.5 - abs (0.5 -  mod (da * (atan (q.x, q.y) / (2. * pi)), 1.)))), d);\n    if (k == 0. || k == nSeg - 1.) d = max (d, - sign (k - 0.5) * dot (q.xy, cs * vec2 (1., -1.)));\n    DMINQ (1);\n    if (k == 0. || k == nSeg - 1.) {\n      q.xy = Rot2Cs (q.xy, cs);\n      q.y -= arc.rad;\n      d = PrCapsDf (q.yzx, tRad + tBmp, 0.1);\n      DMINQ (2);\n    }\n  }\n  return dMin;\n}\n\nfloat GrObjDf (vec2 pg)\n{\n  vec3 p, q;\n  vec2 dkMin, cs;\n  float d, tRad, s, rr, nc;\n  dkMin = vec2 (dstFar, 0.);\n  tRad = 0.5 - 0.15;\n  nCyc = floor (tCur / tCyc);\n  cs = sin (arc.ang * (1. - 2. * (tCur / tCyc - nCyc)) + vec2 (0.5 * pi, 0.));\n  p.xz = pg;\n  p.y = 0.;\n  nc = floor (nCyc / 2.);\n  s = sign (nCyc - 2. * nc - 0.5);\n  rr = arc.rad * arc.cs.y;\n  p.x += (4. * nc + s - 2. - mod (nSeg, 2.)) * rr;\n  p.yz = p.zy;\n  p.xy *= vec2 (-1., s);\n  for (float k = float (VAR_ZERO) - 2. * nSeg; k < nSeg; k ++) {\n    q = p;\n    q.y *= - sign (mod (k, 2.) - 0.5);\n    q.xy -= vec2 (rr * (2. * k - nSeg + 0.5), - arc.chDist);\n    d = dot (vec2 (abs (q.x), q.y), arc.css);\n    d = max (length (vec2 (length (q.xy) - arc.rad, q.z)) - tRad, d);\n    if (k == - 2. * nSeg || k == nSeg - 1.) d = max (d, - sign (k - 0.5) *\n       dot (q.xy, cs * vec2 (1., -1.)));\n    if (d < dkMin.x) dkMin = vec2 (d, k);\n    if (k == - 2. * nSeg || k == nSeg - 1.) {\n      q.xy = Rot2Cs (q.xy, cs);\n      q.y -= arc.rad;\n      d = PrCapsDf (q.yzx, tRad, 0.1);\n      if (d < dkMin.x) dkMin = vec2 (d, k);\n    }\n  }\n  dkMin.y = 1. + min (dkMin.y / nSeg, 0.) / 2.;\n  return dkMin.y * step (dkMin.x, 0.);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0005 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.4, 0.5);\n  } else {\n    q = 0.02 * (ro.xz + 2. * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.3, 0.4, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nfloat GrndHtN (vec2 p)\n{\n  return 0.3 * Fbm2 (2. * p);\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHtN (p.xz) - vec2 (GrndHtN (p.xz + e.xy),\n     GrndHtN (p.xz + e.yx)), e.x)).xzy;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, hCol4, bCol4, sCol4;\n  vec3 col, vn;\n  float dstObj, dstGrnd, nDotL, sh, s, f;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    bCol4 = vec4 (0.8, 0.6, 0.2, 0.2);\n    hCol4 = vec4 (0., 0.5, 1., 0.2);\n    sCol4 = vec4 (1., 1., 1., 0.3);\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      qHit.xy = Rot2Cs (qHit.xy, sin (arc.ang * (1. - 2. * (tCur / tCyc - nCyc)) +\n         vec2 (0.5 * pi, 0.)));\n      s = abs (length (qHit.xy) - arc.rad);\n      f = Minv2 (Rot2D (0.5 - abs (0.5 - mod (4. * atan (qHit.xz, vec2 (qHit.y, s)) /\n         vec2 (arc.ang, pi), 1.)), 0.25 * pi));\n      col4 = mix (bCol4, hCol4, smoothstep (0., 0.03, f + 0.05));\n      if (qHit.z > 0.) col4 = mix (sCol4, col4, smoothstep (0., 0.03, s - 0.03));\n    } else if (idObj == 2) {\n      if (qHit.x > 0.) {\n        col4 = bCol4 * (0.3 + 0.7 * smoothstep (0., 0.03, PrRoundBox2Df (qHit.yz,\n           vec2 (0., 0.13), 0.02)));\n      } else {\n        col4 = bCol4 * (0.3 + 0.7 * smoothstep (0., 0.03, PrRoundBox2Df (qHit.yz -\n           vec2 (0., -0.2), vec2 (0.3, 0.), 0.02)));\n        col4 = mix (vec4 (1., 0., 0., -1.), col4, step (0.1,\n           length (vec2 (abs (qHit.y) - 0.2, qHit.z - 0.1))));\n      }\n      col4 = mix (hCol4, col4, smoothstep (0., 0.03, abs (abs (qHit.x) - 0.25) - 0.15));\n      if (qHit.z > 0. && abs (qHit.x) < 0.5) col4 = mix (sCol4, col4,\n         smoothstep (0., 0.03, abs (qHit.y) - 0.03));\n    }\n  } else if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    col4 = 0.6 * mix (vec4 (1., 0.8, 0.5, 0.), vec4 (0.9, 0.7, 0.5, 0.), 0.2 +\n       0.8 * smoothstep (0.3, 0.7, Fbm2 (2. * ro.xz)));\n    f = 1. - smoothstep (0.4, 0.7, dstGrnd / dstFar);\n    vn = GrndNf (ro);\n    s = GrObjDf (ro.xz);\n    col4 *= 1. - 0.1 * s;\n    vn = VaryNf (8. * ro, vn, 2. * f + 8. * s);\n  } else {\n    col = SkyBgCol (ro, rd);\n  }\n  if (dstObj < dstFar || rd.y < 0.) { \n    if (col4.a >= 0.) {\n      nDotL = max (dot (vn, sunDir), 0.);\n      if (dstObj < dstFar && idObj == 1) nDotL *= nDotL;\n      sh = (rd.y < 0.) ? ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;\n      col = col4.rgb * (0.3 + 0.7 * sh * nDotL) +\n         col4.a * step (0.95, sh) * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 32.);\n      col = mix (col, vec3 (0.3, 0.4, 0.5), pow (1. + rd.y, 16.));\n    } else col = col4.rgb * (0.5 + 0.5 * max (- dot (rd, vn), 0.));\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  0   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.13 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az -= 0.03 * pi * tCur;\n    el -= 0.1 * pi * sin (0.02 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, -0.05 * pi);\n  vuMat = StdVuMat (el, az);\n  tCyc = 4.;\n  segRot = pi * (0.4 + 0.*0.1 * floor (mod (tCur / (5. * tCyc), 4.)));\n  ArcConf ();\n  ro = vuMat * vec3 (0., 0., -40.);\n  ro.x -= arc.rad * arc.cs.y * (2. * tCur / tCyc - (nSeg + 1.) / 2.);\n  zmFac = 6. + 2.5 * el;\n  dstFar = 100.;\n  sunDir = vuMat * normalize (vec3 (1., 2., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGGWD.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[780, 780, 806, 833, 1061], [1063, 1063, 1080, 1080, 1527], [1529, 1529, 1551, 1551, 2687], [2689, 2689, 2714, 2714, 3868], [3870, 3870, 3903, 3903, 4151], [4153, 4153, 4174, 4174, 4429], [4431, 4431, 4468, 4468, 4697], [4699, 4699, 4733, 4733, 5490], [5492, 5492, 5516, 5516, 5548], [5550, 5550, 5572, 5572, 5719], [5721, 5721, 5756, 5756, 8167], [8211, 8211, 8267, 8267, 9533], [9535, 9535, 9582, 9582, 9629], [9631, 9631, 9674, 9674, 9738], [9740, 9740, 9762, 9762, 9789], [9791, 9791, 9827, 9827, 10033], [10035, 10035, 10065, 10065, 10178], [10180, 10180, 10211, 10211, 10275], [10309, 10309, 10333, 10333, 10386], [10388, 10388, 10412, 10412, 10524], [10526, 10526, 10551, 10551, 10697], [10699, 10699, 10724, 10724, 10910], [10912, 10912, 10934, 10934, 11088], [11090, 11090, 11111, 11111, 11266], [11268, 11268, 11297, 11297, 11509], [11511, 11511, 11550, 11550, 11807]], "test": "untested"}
{"id": "NtGGWD", "name": "Four-leaf clover quilt", "author": "jarble", "description": "A four-leaf clover pattern.", "tags": ["fractal", "clover", "carpet", "rug"], "likes": 3, "viewed": 247, "published": 3, "date": "1637671087", "time_retrieved": "2024-07-30T18:46:33.410833", "image_code": "//change this constant to get different patterns!\n#define c2 0.\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 9.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float offset = .5;\n    float scale2 = 1.5;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        for(int i=0;i<3;i++)\n        {\n            float bend = 1.0; \n            for(int k = 0; k < 9; k++){       \n                uv /= scale2;\n                uv = triangle_wave(uv.yx+offset,scale)/bend+triangle_wave(uv+offset/scale2,scale)*bend;\n                //bend = 1.+uv.x/2.;\n            }\n            scale /= 1.+(scale2)*col.x/(8.);\n            scale2 -= (col.x-1.)/4.;\n            col[c] = abs(col[c] - ((uv.x)-(uv.y)));\n        }\n\t}\n    fragColor = vec4(vec3(col),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtGGWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 142, 142, 187], [189, 189, 246, 246, 1005]], "test": "untested"}
{"id": "flyGWW", "name": "Sphere texture mapping test", "author": "lambmeow", "description": "just a quick test on spherical mapping", "tags": ["sdf", "texture", "sphere"], "likes": 9, "viewed": 492, "published": 3, "date": "1637662375", "time_retrieved": "2024-07-30T18:46:34.203713", "image_code": "#define PI 3.141592653\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 r = iResolution.xy,uv = (fragCoord* 2.- r)/r.y;\n    vec3 col = vec3(0), ro = vec3(0,0,-3), rd = normalize(vec3(uv,2));\n    float ll = 0.;\n    for(int i = 0; i < 100;i++)\n    {\n       vec3 p = ro + rd * ll;\n       float dd = length(p) - 1.;\n       p.xz *= mat2(cos(iTime), -sin(iTime), sin(iTime), cos(iTime));       \n       p.xy *= mat2(cos(iTime), -sin(iTime), sin(iTime), cos(iTime));\n       if(dd < 0.001)\n       {\n           float a =  1. - ((atan(p.z/p.x)))/(2.*PI);\n           float b =  1. - ((acos(p.y/length(p))))/PI;\n           vec3 diff = texture(iChannel0, vec2(a,b)).rgb;\n           col = diff;\n           break;\n       }\n       ll += dd;\n       if(ll > 100.)\n          break;\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flyGWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 81, 81, 844]], "test": "untested"}
{"id": "stVGDh", "name": "eindacor_dynamic_plaid", "author": "Eindacor_DS", "description": "it's fancy plaid, you dolt!", "tags": ["plaid"], "likes": 2, "viewed": 160, "published": 3, "date": "1637637825", "time_retrieved": "2024-07-30T18:46:35.068401", "image_code": "\n#define PI 3.1415926\n#define ANTI_ALIAS .005\n\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat getNormalizedNonPeriodic(float seed) {\n    return (sin(2. * seed) + sin(PI * seed)+ 2.) / 4.;\n}\n\nfloat getNonPeriodic(float seed) {\n    return sin(2. * seed) + sin(PI * seed);\n}\n\nmat2x2 createRotationMatrix(float rotation) {\n    return mat2x2(\n        cos(rotation), -sin(rotation),\n        sin(rotation), cos(rotation)\n    );\n}\n\nvec4 getColorBlend(float timeScale, vec2 uv, float xHash, float xHashAA, float yHash, float yHashAA, float xBlend, float yBlend) {\n    vec2 xyFirst = vec2(\n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + xHash) + xHash), \n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + yHash) + yHash));\n    \n    vec2 xySecond = vec2(\n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + xHash) + xHash), \n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + yHash) + yHash));\n        \n    vec2 xyColor = xyFirst * xySecond;\n        \n    vec2 xAyFirst = vec2(\n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + xHashAA) + xHashAA), \n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + yHash) + yHash));\n        \n    vec2 xAySecond = vec2(\n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + xHashAA) + xHashAA), \n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + yHash) + yHash));\n        \n    vec2 xAyColor = xAyFirst * xAySecond;\n        \n    vec2 xyAFirst = vec2(\n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + xHash) + xHash), \n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + yHashAA) + yHashAA));\n    \n    vec2 xyASecond = vec2(\n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + xHash) + xHash), \n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + yHashAA) + yHashAA));\n        \n    vec2 xyAColor = xyAFirst * xyASecond;\n        \n    vec2 xAyAFirst = vec2(\n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + xHashAA) + xHashAA), \n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + yHashAA) + yHashAA));\n    \n    vec2 xAyASecond = vec2(\n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + xHashAA) + xHashAA), \n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + yHashAA) + yHashAA));\n        \n      \n    vec2 xAyAColor = xAyAFirst * xAyASecond;\n\n    vec2 xLower = mix(xAyAColor, xyAColor, xBlend);\n    vec2 xUpper = mix(xAyColor, xyColor, xBlend);\n    \n    vec2 finalBlend = mix(xLower, xUpper, yBlend);\n    \n    return vec4(finalBlend.x, finalBlend.y, getNormalizedNonPeriodic(iTime * timeScale + 200.), 1.);\n}\n\nvec4 getBWBlend(float timeScale, vec2 uv, float xHash, float xHashAA, float yHash, float yHashAA, float xBlend, float yBlend) {\n    vec2 xyFirst = vec2(\n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + xHash) + xHash), \n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + yHash) + yHash));\n    \n    vec2 xySecond = vec2(\n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + xHash) + xHash), \n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + yHash) + yHash));\n        \n    vec2 xyColor = xyFirst * xySecond;\n        \n    vec2 xAyFirst = vec2(\n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + xHashAA) + xHashAA), \n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + yHash) + yHash));\n        \n    vec2 xAySecond = vec2(\n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + xHashAA) + xHashAA), \n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + yHash) + yHash));\n        \n    vec2 xAyColor = xAyFirst * xAySecond;\n        \n    vec2 xyAFirst = vec2(\n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + xHash) + xHash), \n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + yHashAA) + yHashAA));\n    \n    vec2 xyASecond = vec2(\n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + xHash) + xHash), \n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + yHashAA) + yHashAA));\n        \n    vec2 xyAColor = xyAFirst * xyASecond;\n        \n    vec2 xAyAFirst = vec2(\n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + xHashAA) + xHashAA), \n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + yHashAA) + yHashAA));\n    \n    vec2 xAyASecond = vec2(\n        getNormalizedNonPeriodic(uv.x + getNonPeriodic(iTime * timeScale + xHashAA) + xHashAA), \n        getNormalizedNonPeriodic(uv.y + getNonPeriodic(iTime * timeScale + yHashAA) + yHashAA));\n        \n      \n    vec2 xAyAColor = xAyAFirst * xAyASecond;\n\n    vec2 xLower = mix(xAyAColor, xyAColor, xBlend);\n    vec2 xUpper = mix(xAyColor, xyColor, xBlend);\n    \n    vec2 finalBlend = mix(xLower, xUpper, yBlend);\n    \n    vec4 blended = vec4(finalBlend.x, finalBlend.y, getNormalizedNonPeriodic(iTime * timeScale + 200.), 1.);\n    return vec4(vec3(blended.x * blended.y), 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float aspectRatio = iResolution.x / iResolution.y;\n    \n    uv.x *= aspectRatio;\n    \n    mat2x2 rotationMatrix = createRotationMatrix(PI / 4.);\n    \n    uv.y += getNonPeriodic(iTime * .1 + uv.x) * .1 + 100.;\n    uv = uv * rotationMatrix;\n       \n    float gridSize = .01;\n\n    float xFloor = floor(uv.x / gridSize);\n    float xHash = hash(vec2(xFloor));\n    float xHashAA = hash(vec2(xFloor - 1.));\n    float xBlend = smoothstep(0., ANTI_ALIAS / gridSize, fract(uv.x / gridSize));\n    \n    float yFloor = floor(uv.y / gridSize);\n    float yHash = hash(vec2(yFloor));\n    float yHashAA = hash(vec2(yFloor - 1.));\n    float yBlend = smoothstep(0., ANTI_ALIAS / gridSize, fract(uv.y / gridSize));\n    \n    float timeScale = .15;\n    \n    fragColor = getColorBlend(timeScale, uv, xHash, xHashAA, yHash, yHashAA, xBlend, yBlend);\n    \n    vec2 trueUv = fragCoord/iResolution.xy;\n    if (iMouse.z > 1.) {\n    \n        float cursorDist = distance(vec2(trueUv.x * aspectRatio, trueUv.y), vec2(iMouse.x / iResolution.x * aspectRatio, iMouse.y / iResolution.y));\n        \n        float spotlightRadius = .4;\n        float spotlightFade = spotlightRadius * .5;\n        float cursorVal = smoothstep(spotlightRadius - spotlightFade, spotlightRadius + spotlightFade, cursorDist);\n             \n        vec4 spotlightColor = getBWBlend(timeScale, uv, xHash, xHashAA, yHash, yHashAA, xBlend, yBlend) * vec4(1.0, 0.5, 0., 1.);\n    \n        fragColor = mix(spotlightColor, fragColor, cursorVal * cursorVal);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stVGDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 94, 114, 114, 180], [182, 182, 226, 226, 283], [285, 285, 319, 319, 365], [367, 367, 412, 412, 516], [518, 518, 648, 648, 2909], [2911, 2911, 3038, 3038, 5357], [5359, 5359, 5416, 5416, 6964]], "test": "untested"}
{"id": "slV3Wh", "name": "spirograph mechanics", "author": "remaindeer", "description": "This is a parameterized spirograph system based on the Wikipedia article ([url]https://en.wikipedia.org/wiki/Spirograph[/url]).", "tags": ["spirograph"], "likes": 6, "viewed": 423, "published": 3, "date": "1637635054", "time_retrieved": "2024-07-30T18:46:35.861281", "image_code": "// Image\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv  = fragCoord / iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Common\n\nvec2 spiro(float t, float R, float k, float l) {\n    // https://en.wikipedia.org/wiki/Spirograph\n    return vec2(\n        R * ((1.0 - k) * cos(t) + l * k * cos((1.0 - k) / k * t)),\n        R * ((1.0 - k) * sin(t) - l * k * sin((1.0 - k) / k * t))\n    );\n}\n\nfloat udSegment(in vec2 p, in vec2 a, in vec2 b) {\n    // https://www.shadertoy.com/view/3tdSDj\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - h * ba);\n}\n", "buffer_a_code": "// Buffer A\n\nvoid mainImage_remaindeer(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.y;\n    vec2 center = iResolution.xy / iResolution.y / 2.0;\n    vec3 col = vec3(0);\n    vec3 rnd = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0,2,4));\n    \n    // https://en.wikipedia.org/wiki/Spirograph\n    float R = 0.5;                                     // outer circle radius\n    float l = 0.7;                                     // dimensionless l parameter = rho / r\n    float k = 0.6;                                     // dimensionless k parameter = r   / R\n    float t = iTime;                                   // outer circle tangent point rotation angle\n    float r = k * R;                                   // inner circle radius\n    float rho = l * r;                                 // distance from inner circle center to the pen\n    float tp = -((R - r) / r) * t;                     // inner circle tangent point rotation angle\n    vec2 pc = (R - r) * vec2(cos(t), sin(t)) + center; // inner circle center\n    vec2 A = rho * vec2(cos(tp), sin(tp)) + pc;        // pen coordinate\n    vec2 point = spiro(t, R, k, l) + center;           // also pen coordinate\n\n    /****/ if (length(uv - center) < 0.005) {\n        col = vec3(1);\n    } else if (length(uv - point ) < 0.005) {\n        col = rnd;\n    } else if (length(uv - point ) < 0.005 * 2.0) {\n        col = vec3(1);\n    } else if (udSegment(uv, A, pc) < 0.0005) {\n        col = vec3(1);\n    } else if (r - 0.0005 < length(uv - pc) && length(uv - pc) < r + 0.0005) {\n        col = rnd;\n    } else if (R - 0.0025 < length(uv - center) && length(uv - center) < R + 0.0025) {\n        col = vec3(1);\n    } else {\n        vec2 uv = fragCoord / iResolution.xy;\n        col = mix(col, texture(iChannel0, uv).xyz, 0.9995);\n    }\n\n    fragColor = vec4(col, 1.0);\n}\n\n// Prevent time-skipping due to changing framerate\nvoid mainImage_oneshade(out vec4 fragColor, in vec2 fragCoord) {\n    #define iTimeDelta 0.01\n    #define iTime (float(iFrame) * iTimeDelta)\n    #define draw(dist, color) col = max(col, color * smoothstep(aa, 0.0, dist))\n    \n    vec2 uv = fragCoord / iResolution.y;\n    vec2 center = iResolution.xy / iResolution.y / 2.0;\n    vec3 col = texture(iChannel0, fragCoord / iResolution.xy).xyz * 0.99;\n    vec3 rnd = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0,2,4));\n    \n    // https://en.wikipedia.org/wiki/Spirograph\n    float R = 0.5;                                     // outer circle radius\n    float l = 0.7;                                     // dimensionless l parameter = rho / r\n    float k = 0.6;                                     // dimensionless k parameter = r   / R\n    float t = iTime;                                   // outer circle tangent point rotation angle\n    float r = k * R;                                   // inner circle radius\n    float rho = l * r;                                 // distance from inner circle center to the pen\n    float tp = -((R - r) / r) * t;                     // inner circle tangent point rotation angle\n    vec2 pc = (R - r) * vec2(cos(t), sin(t)) + center; // inner circle center\n    vec2 A = rho * vec2(cos(tp), sin(tp)) + pc;        // pen coordinate\n    vec2 point = spiro(iTime, R, k, l) + center;       // also pen coordinate\n\n    float aa = 2.0 / iResolution.y; // 2x pixel width\n    draw(length(uv - center) - 0.005, vec3(1.0));\n\n    float distPoint = length(uv - point);\n    draw(distPoint - 0.005, rnd);\n    draw(distPoint - 0.01, vec3(1.0));\n\n    draw(udSegment(uv, A, pc) - 0.0005, vec3(1.0));\n    draw(abs(length(uv - pc) - r) - 0.0005, rnd);\n    draw(abs(length(uv - center) - R) - 0.0025, vec3(1.0));\n\n    fragColor = vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    mainImage_remaindeer(fragColor, fragCoord);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slV3Wh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[10, 10, 65, 65, 185]], "test": "untested"}
{"id": "7tVGWh", "name": "Persian carpet 27", "author": "jarble", "description": "These carpets have many braided knot patterns.", "tags": ["fractal", "carpet", "rug"], "likes": 1, "viewed": 260, "published": 3, "date": "1637633252", "time_retrieved": "2024-07-30T18:46:36.622246", "image_code": "//change this constant to get different patterns!\n#define c2 0.\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 6.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    \n    float offset = .5;\n    float scale2 = 1.5;\n    for(int c=0;c<3;c++){\n        float bend = 1.;\n        float scale = c1.z;\n        for(int i=0;i<3;i++)\n        {\n            \n            for(int k = 0; k < 9; k++){       \n                uv /= -scale2;\n                vec2 s1 = triangle_wave(uv.yx-offset,scale)*bend;\n                vec2 s2 = triangle_wave(uv+offset/scale2,scale)/bend;\n                uv = s1+s2;\n                //uv += fract(uv/1.5)/8.; //this makes a more interesting pattern\n\n                //bend = 1.+(uv.x)/3.;\n            }\n            scale /= 1.+(scale2)*col.x/(8.);\n            scale2 -= (col.x-1.)/4.;\n            col[c] =\n                abs(col[c] - (uv.x-uv.y))\n                //abs(col[c] - (uv.x+uv.y))\n                //abs(col[c] - abs(uv.x-uv.y))\n            ;\n            //col[c] = abs(col[c] + ((uv.x)+(uv.y)))/4.;\n\n        }\n\t}\n    fragColor = vec4(vec3(abs(col)),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tVGWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 142, 142, 187], [189, 189, 246, 246, 1342]], "test": "untested"}
{"id": "ftK3W1", "name": "spqr: portal", "author": "Fahrenheitrequited", "description": "a", "tags": ["a"], "likes": 6, "viewed": 326, "published": 3, "date": "1637622020", "time_retrieved": "2024-07-30T18:46:37.415126", "image_code": "/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\n\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/CorrodedBeasts.glsl\n*/\n\n#define MARCH_STEPS 100\n#define PART_COUNT 20\n\n#define time iTime\nfloat PI = acos(-1.0);\n//float gid;\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat getId(float t) {\n   return fract(sin(t * 478.129) * 992.421);\n}\n\nfloat box( vec2 p, vec2 b )\n{\n  vec2 q = abs(p) - b;\n  return max(q.x,q.y);\n}\n\n\nvec2 replim( in vec2 p, in float c, in vec2 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\n\nfloat m1(vec2 uv) {\n  \n \n  \n  \n  float t = iTime ;\n  float a = 3.141592/4.;\n  \n  \n  float thing = 10000.;\n  \n  for( float i = 0.; i <5.; i++){\n  \n    uv *= rot(i * a *2.);\n   \n    uv = abs(uv); \n    uv -= vec2(2,7);\n    uv = -abs(uv);\n   \n    \n    float x1 =  box(uv, vec2(1,1));\n    float x2 =  box(uv + vec2(2,11), vec2(1.,5.));\n    float x3 =  box(uv + vec2(14,14), vec2(.1,53.));\n    vec2 q = replim(uv, 10., vec2(11,2));\n    float x4 =  box(q , vec2(.2,2.));\n   \n    float x = min(x4,min(x1,(min(x2,x3))));\n    \n    thing = min(thing,x);\n   \n    \n \n\n  }\n  return thing ;\n\n}\n\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat hash21 (vec2 uv) {\n  return (fract(sin(uv.x * 1913.7361) + uv.y) * 4440.321);\n\n}\n\nfloat a = 3.141592;\nfloat glow = 0.;\nfloat m2(vec2 uv,float id) {\n\n\n  float dom = 20.;\n\n  uv = mod(uv,dom) - dom/2.;  \n\n \n  vec2 uv2 = uv;\n  float q = 1.4 ;\n  \n  float z = 10000.;\n  vec2 off = vec2(58,20);\n\n  for (float i = 0.; i <5.; i++) {\n    off *= rot(i/4.);\n   \n    uv.x *= q;\n\n    uv *= rot(a/2.);\n    \n    float a1 = m1(uv  + off );\n\n    z = min(z,a1) ;\n  }\n  vec2 arm = vec2(24);\n  arm *= rot(iTime * 7.1);\n  float u = length(uv2  + arm) -2.;\n  \n  //glow += .01/(.02 + pow(u,4.5));\n \n  return z/1.4;\n}\n\n\n\n\n\nfloat k1(vec2 p, float f1) {\n    vec2 pa = p;\n\n    float pi = 3.141592;\n    float z = 100000.;\n    for ( float j = 0.; j < 5.; j++) {\n        p = p.x > p.y ? p : p.yx;\n        for ( float i=0.; i < 3.; i++) {\n           //p = replim(p,6., vec2(0,50.));\n\n           p.x = abs(p.x) - 30. * f1 * f1;\n           float a= box(p,vec2(3,51) );\n           z = min(z,a);\n           vec2 pa = replim(pa,25., vec2(2. + f1));\n           float y = box(pa, vec2(8. ));\n           z = min(z,y);\n           p *= 1.12 + f1/3. ;\n           p += vec2(-46,0);\n           p *= rot(pi/2.);\n      \n        }\n    }\n \n    float c = box(pa, vec2(10,100));\n    \n   return min(z,c) ;\n \n}\nfloat pi = 3.141592;\nfloat k2(vec2 p, float f1){\n\n    float z = 10000.;\n    vec2 offset = vec2(200.,0) + vec2(45) * f1;\n   \n    for ( float i =1.; i < 3.; i++ ) {\n        //p = replim(p,8., vec2(0,10.));\n        float a = k1(p * 1.2 +vec2(0,70.) - vec2(17,29)  * 2.3, f1);\n        float b = k1(p + vec2(70,60) - vec2(50), f1);\n        float c = k1(p * 1.5+vec2(80,11), f1);\n\n        float d = a;//min(a,min(b,c));\n        z = min(z,d);\n        z = max(z, -b);\n        z = min(z,c);\n        p *= 1.5;\n        \n        offset *= rot(pi/(2.));\n        p += offset / pow(.3 + f1 * 3.,i );\n        p *= rot((pi/2.));\n       \n        \n    }\n     \n       \n       return z;\n}\n#define MOD3 vec3(.1031,.11369,.13787)\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\nconst float domain_width = 290.;\nconst float domain_height = 27.;//77.;\nvec3 domain = vec3(domain_width,domain_height,domain_width) ;\nfloat tick (float t ) {\n  float i = floor(t);\n  float r = fract(t);\n  r = sqrt(r);\n  return r + i;\n\n}\n\nfloat decal(vec3 p, vec3 domain) {\n\n// ink\n  // return m2(uv);\n  //vec2 q = kifs(p + pow(kifs(p),vec2(1. + sin(iTime))*.5+.5) );\n  \n  \n  vec3 id = floor(p/domain);\n  float f1 = fract(hash31(id) + tick(iTime * .13 ));\n  \n  p = mod(p,domain) - domain/2.;\n  //float one =  k1(kifs(p * f1 + kifs(p * f1)), f1);\n  //float one =  k1(kifs(p + kifs(p) + kifs(kifs(p))), f1);\n  //float one = k1(kifs(p + kifs(p)),f1);\n  float one = k2(p.xz,f1);\n  float two = box(p.xz, vec2(300.));\n  float final = max(one,two);\n  return final;\n}\n\n\n\n\n\nfloat tor(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat sph(vec3 p, float r) {\n  return length(p) - r;\n}\n\nvec3 rep( vec3 p, vec3 c )\n{\n    return mod(p,c) - 0.5 * c;\n}\n\n\nvec3 replim( in vec3 p, in float c, in vec3 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\n\n\n\nvec3 moda(vec3 p, float rep, float off) {\n  vec2 rp = vec2(atan(p.z,p.x)/(2.0*PI), length(p.xz));\n  rp.x=(fract(rp.x*rep-0.5+off)-0.5)/rep;\n  rp.x *= 2.0*PI;\n  return vec3(cos(rp.x)*rp.y,p.y,sin(rp.x)*rp.y);\n}\n\n\nfloat noise(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,37,289);\n  vec4 pos=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 val=mix(fract(sin(pos)*7894.552), fract(sin(pos+st.x)*7894.552), p.x);\n  vec2 val2=mix(val.xz,val.yw, p.y);\n  return mix(val2.x,val2.y, p.z);\n}\n\nfloat fbm(vec3 p) {\n\n  float d=0.5;\n  float f=0.0;\n  for(int i=0; i<5; ++i) {\n    f+=noise(p/d)*d;\n    d*=.5;\n  }\n  return f;\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\nvec3 smin(vec3 a, vec3 b, float h) {\n  vec3 k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\nvec3 tunnel(vec3 p){\n  vec3 off=vec3(0);\n  off.x += sin(p.z*0.2)*1.5;\n  off.y += sin(p.z*0.3)*1.3;\n  return off;\n}\n\n\nfloat surge (float tt) {\n\n   return (1. - cos(mod(tt*pi,pi))/2.)+floor(tt);\n \n}\n\n\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\nvec3 s;\nint matter = 0;\n\n\nfloat map(vec3 p) {\n\n // geo\n \n\n  \n  \n  float pi = 3.141592;\n  \n  vec3 q = p;\n  q = rep(q, vec3(0,0,57));\n\n\n  p = vec3(atan(p.x,p.y), length(p.xy) - 1., p.z);\n  \n   \n  p.y = abs(p.y) - 2.;\n  p.y = abs(p.y) -2.;\n\n\n\n \n  float tunnel = box(p, vec3(domain_width,1.,domain_width));\n \n \n  vec3 pulse = vec3(iTime * 10.,0,0);\n  float beam = cylcap(q.yxz + vec3(0,0,430. * sin(iTime * 1.3)), 1.,1.);\n  glow += 0.6/(0.1 + beam);\n \n \n  float hit = min(beam,tunnel);\n  \n  if (tunnel == hit) {\n      matter = 1;\n  \n  }\n  if (beam == hit) {\n      matter = 2;\n  }\n\n\n  return hit;\n \n}\n\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    float res = 1.;\n    float k = 2.;\n    \n    \n    for( float t=mint; t<maxt; )\n    {\n        \n        float h = map(ro + rd*t);\n        //h = abs(h);\n        if( h<0.001 ){\n            return 0.0;\n        }\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\n\nfloat sss(vec3 p, vec3 l, float d) {\n  return smoothstep(0.0,1.0,map(p+l*d)/d);\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*789.451)*7541.223);\n}\n\nfloat rnd(vec2 t) {\n  return fract(dot(sin(t*vec2(789.451)+t.yx*vec2(842.544)),vec2(7541.223)));\n}\n\n\n\nvec3 flit(float t) {\n\n  vec3 x = normalize(vec3(1));\n  float t1 = tick(t);\n  float t2 = tick(t * .71);\n  float t3 = tick(t * .55);\n  x.yz *= rot(t1);\n  x.xz *= rot(t2);\n  x.yx *= rot(t3);\n  \n  return x;\n}\n\nfloat shadow(vec3 p, vec3 l, float maxdist, int stepcount, float limit) {\n  float shad=1.0;\n  float dd=0.0;\n  for(int i=0; i<stepcount; ++i) {\n    float d=min(map(p), maxdist);\n    if(d<limit) {\n      shad=0.0;\n      break;\n    }\n    if(dd>=maxdist) {\n      break;\n    }\n  \n    p += l*d;\n    dd+= d;\n \n  }\n  return shad;\n}\n\nvec3 probepos;\nvec3 probe (vec3 r, vec2 uv, float dd) {\n // volume\n  \n  float rand=rnd(uv);\n  \n  \n  const int volsteps=50;\n  float voldist = 15.0;\n  float stepsize = voldist/float(volsteps);\n  vec3 lr=r*stepsize;\n  vec3 lp=s + lr*rand;\n  float stepdist=rand*stepsize;\n  vec3 atcol=vec3(0);\n  \n  for(int i=0; i<volsteps; ++i) {\n  \n    if(stepdist>dd) {\n      break;\n    }\n    \n    vec3 lv = probepos-lp;\n    float ldistvol = length(lv);\n    lv = normalize(lv);\n    vec3 target = vec3(0);\n   \n    \n    float shadvol = shadow(lp, lv, ldistvol, 10, 0.01);\n \n    \n    float u = dot( normalize(lp - probepos), normalize(probepos-target) ) ;\n    //if ( u > .99) {\n    //u = min(.5,u);\n    //if ( u > .99) {\n    atcol += 35./(0.01+(pow(ldistvol,1.5))) * shadvol * pow(u,10.);\n    //}\n \n    lp+=lr;\n    stepdist+=stepsize;\n    \n  }\n \n  return atcol;\n\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n   float time = iTime;\n\n  // nav\n  \n   float tt = iTime * .15;\n  \n   vec3 s = lattice(tt) * 9.;\n  \n   vec3 t = lattice(tt+5.) * 7.;\n  \n   s.z += tt * 10.;\n   t.z += tt * 10.;\n\n   \n   probepos = s + vec3(0,0,100) * sin(iTime*7.);;\n\n\n \n  vec3 cz=normalize(t-s);\n\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz*0.7);\n  \n  r.xy *= rot(sin(tick(iTime))*.2);\n\n  vec3 p=s;\n  //float i=0.;\n  float mask=1.0;\n  float d = 10000.0;\n  float dd = 0.;\n  float rand=rnd(uv);\n  \n  \n  // march\n  \n  bool hit = false;\n  float i ;\n  float z;\n  float res = 1.;\n  for( z=0.; z < 1000.; ++z) {\n    i = z;\n    d=map(p);\n    d = abs(d);\n    if(d<0.01) {\n    \n      \n       i = decal(p * 100., domain); // resolution\n     \n      if (matter == 1) { \n          if (i > 4.5) {\n            d = .1;\n          } else {\n            hit = true;\n            break;\n          }\n      } else {\n           hit = true;\n            break;\n       \n      \n      }\n    }\n    if ( dd > 10000.) break;\n    dd += d;\n    p+=r*d;\n  }\n  \n  // hue\n\n  vec3 col = vec3(1.);\n  \n  i = decal(p * 100., domain + .01 );\n  \n  if ( matter == 1) {\n      if ( i > 0.0 && i < 3.0) {\n          col = vec3(0);\n      }\n\n      if ( i > -12.0 && i < 0.0) {\n          col = vec3(.1,.1,.5)*.3;\n        \n      }\n  }\n  if ( matter == 2) {\n      col = vec3(1,1,0);\n  }\n    if ( matter == 3) {\n      col = vec3(1);\n  }\n \n //col += probe(r, uv, dd) * .9;\n col += glow * .6;\n col = mix(vec3(.5), col, 1. - z/260.);\n  \n \n \n  // sky\n  if (! hit ) {\n\n  \n    float per = dot(r, normalize(vec3(0,2,2)))  * .5 + .5;\n    per = pow(per,2.);\n   \n    col =   mix(  vec3(.5), vec3 (.5) *.1, per);\n    \n  }\n  \n  fragColor = vec4(col, 1);\n\n}\n\n\n  \n\n\n/*\n\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}\n*/\n\n\n/*\n float diff = max(0.0,dot(n,light)*0.5+0.5);\n  float fren = pow(1.+dot(n,r),2.);\n  float sss = sss(p,r,4.) * 2.;\n  float spec= pow(max(dot(reflect(-light,n),-r),.0), 10.) * 5.;\n  float shad = shadow(p, normalize(-light), .1, length(light-p));\n  float fog =  pow(i/1000.,2.);\n  \n  col -= diff * .1;\n  //col += fren;\n  //col += sss;\n  //col += spec;\n  //col *= shad;\n  //col = mix(col, vec3(0), fog);\n  */", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftK3W1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[295, 295, 314, 314, 383], [385, 385, 407, 407, 454], [456, 456, 485, 485, 533], [536, 536, 583, 583, 629], [631, 631, 650, 650, 1209], [1211, 1211, 1253, 1253, 1360], [1362, 1362, 1386, 1386, 1448], [1487, 1487, 1515, 1515, 1960], [1966, 1966, 1994, 1994, 2625], [2647, 2647, 2674, 2674, 3293], [3333, 3333, 3356, 3356, 3471], [3607, 3607, 3630, 3630, 3708], [3710, 3710, 3744, 3838, 4230], [4236, 4236, 4263, 4263, 4331], [4333, 4333, 4361, 4361, 4385], [4386, 4386, 4415, 4415, 4502], [4505, 4505, 4533, 4533, 4559], [4561, 4561, 4589, 4589, 4622], [4625, 4625, 4672, 4672, 4718], [4722, 4722, 4763, 4763, 4931], [4934, 4934, 4955, 4955, 5246], [5248, 5248, 5267, 5267, 5375], [5377, 5377, 5416, 5416, 5493], [5495, 5495, 5531, 5531, 5609], [5611, 5611, 5631, 5631, 5725], [5728, 5728, 5752, 5752, 5807], [5811, 5811, 5832, 5832, 5881], [5883, 5883, 5908, 5908, 6377], [6404, 6404, 6423, 6432, 6973], [6975, 6975, 7039, 7039, 7321], [7324, 7324, 7343, 7343, 7462], [7464, 7464, 7505, 7505, 7551], [7553, 7553, 7589, 7589, 7634], [7636, 7636, 7656, 7656, 7699], [7701, 7701, 7720, 7720, 7799], [7803, 7803, 7823, 7823, 8007], [8009, 8009, 8082, 8082, 8331], [8348, 8348, 8388, 8399, 9177], [9179, 9179, 9236, 9236, 11102]], "test": "untested"}
{"id": "flVGW1", "name": "head n4", "author": "jorge2017a2", "description": "head n4", "tags": ["headn4"], "likes": 5, "viewed": 222, "published": 3, "date": "1637618523", "time_retrieved": "2024-07-30T18:46:38.461329", "image_code": "///-------------image\n//por jorge2017a2-  head n4\n//22-nov-2021\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{  float k0 = length(p/r);  float k1 = length(p/(r*r));  return k0*(k0-1.0)/k1;}\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{ vec3 pa = p - a, ba = b - a;   float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB) \n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z); }\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x); }\nvec3 rotate_z(vec3 p, float phi) \n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n//https://www.shadertoy.com/view/3tSBzW\nmat3 rotX(float a) { float s = sin(a), c = cos(a); return mat3(1.,0.,0.,0.,c,-s,0.,s,c); }\nmat3 rotY(float a) { float s = sin(a), c = cos(a); return mat3(c,0.,s,0.,1.,0.,-s,0.,c); }\nmat3 rotZ(float a) { float s = sin(a), c = cos(a); return mat3(c,-s,0.,s,c,0.,0.,0.,1.); }\n\n// Identity matrix.\nmat3 identity() {  return mat3( vec3(1, 0, 0), vec3(0, 1, 0), vec3(0, 0, 1) ); }\n\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n  p = abs(p);\n  vec2 b = vec2(la,lb);\n  float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n  vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\nvec3 HacerPelo(vec3 p0, vec3 res , mat3 m1)\n{   vec3 p=p0*m1;\n    float dpelo1=sdCylinderXZ(p-vec3(0.0, 0.0,0.0), vec2(0.8,1.2) );\n    float dpelo2=sdCylinderXZ(p-vec3(0.0, -1.0,0.0),vec2(0.3,2.7) );   \n    res =opU3(res, vec3(dpelo1,1.0,-1.0));\n    res =opU3(res, vec3(dpelo2,2.0,-1.0));\n    return res;\n}\n\n\nfloat OndaDoble(vec2 uv,float  t)\n{   float d1 =uv.y+ sin(uv.x*5.+t)*0.2;\n    float d2 =uv.y+ sin(uv.x*5.+t)*0.2+0.2;   \n    float dfin= differenceSDF(d1, d2);\n    return dfin; }\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0); \n    p.y=p.y-10.0;\n    vec3 p0=p;\n    mat3 m1=rotZ(radians(-20.0));\n    mat3 m2=rotZ(radians(20.0));\n    mat3 m3=identity();\n    res= HacerPelo(p-vec3(-3.5,8.0,-2.0),res,m1 );\n    res= HacerPelo(p-vec3(-1.0,9.0,-2.0),res,m3 );\n    res= HacerPelo(p-vec3( 1.0,9.0,-2.0),res,m3 );\n    res= HacerPelo(p-vec3( 3.5,8.0,-2.0),res,m2 );\n    \n    float dCabeza= sdEllipsoid(p-vec3(0.0,0.0,-2.0), vec3(5.0,6.0,1.0) );\n    \n    float la=2.7; float lb=2.0; float h=3.0; float ra=2.0;\n    float dbarbilla= sdRhombus(p.xzy-vec3(0.0,-1.0,-2.0), la,lb, h, ra);\n    \n    float dFrente= sdBox(p-vec3(0.0,2.0,-1.0), vec3(4.0,2.5,0.2));\n    dCabeza= opSmoothUnion(dFrente, dCabeza, 1.85 );\n    \n    float dbarBxdif= sdBox(p-vec3(0.0,0.5,0.0), vec3(5.0,2.5,4.5));\n    float dCabezaBxdif= sdBox(p-vec3(0.0,-4.5,0.0), vec3(5.2,2.5,4.5));\n    \n    //ojo\n    p.x=abs(p.x)-2.5;\n    vec3 p2=p0;\n    p2.x=abs(p2.x)-2.2;\n    float dOjo=sdEllipsoid(p-vec3(0.0,0.0,-2.8), vec3(1.5,1.3,1.0) );\n    float dOjoHueco=sdEllipsoid(p-vec3(0.0,0.0,-3.0), vec3(1.5,1.3,1.0) );\n    float dPupilaAnillo= sdCylinderXY( p2-vec3(0.0,0.5,-1.0), vec2(0.76,3.0)  );\n    float dPupila= sdCylinderXY( p2-vec3(0.0,0.5,-1.0), vec2(0.7,3.0)  );\n    float dIris= sdCylinderXY( p2-vec3(0.0,0.5,-1.5), vec2(0.45,3.0)  );\n    \n    \n    float dOjoBxdif= sdBox(p-vec3(0.0,-1.1,-1.0), vec3(1.7,1.0,3.2));\n    dOjoHueco=differenceSDF(dOjoHueco,dOjoBxdif); \n    dOjo     =differenceSDF(dOjo,dOjoBxdif); \n    dOjo=intersectSDF(dCabeza,dOjo);\n    //interseccion a ojo\n    dPupilaAnillo=intersectSDF(dOjo,dPupilaAnillo);\n    dPupila=intersectSDF(dOjo,dPupila);\n    dIris=intersectSDF(dOjo,dIris);\n    \n    \n    dbarbilla=differenceSDF(dbarbilla,dbarBxdif);\n        \n    dbarbilla=intersectSDF(dCabeza,dbarbilla); //diferencia barbilla cabeza\n    dCabeza=differenceSDF(dCabeza,dCabezaBxdif);  //diiferencia infeior\n    dCabeza=unionSDF(dCabeza,dbarbilla);\n    dCabeza=opSmoothSubtraction(dOjoHueco,dCabeza,0.25); \n    \n    ///nariz\n    p=p0;\n    p=rotate_x(p-vec3(0.0,-2.0,-2.9), radians(-5.0));\n    float dNarizCen= sdCapsule( p, vec3(0.0,0.0,0.0), vec3(0.0,2.0,0.25), 0.35 );\n    p=p0;\n    float dNarizIzq= sdCapsule( p-vec3(0.0,-2.0,-2.8), vec3(-0.5,0.0,0.0), vec3(0.0,1.0,0.25), 0.25 );\n    float dNarizDer= sdCapsule( p-vec3(0.0,-2.0,-2.8), vec3( 0.5,0.0,0.0), vec3(0.0,1.0,0.25), 0.25 );\n    float dNarizCirIzq= sdSphere( p-vec3(-0.5,-1.8,-3.0), 0.15 );\n    float dNarizCirDer= sdSphere( p-vec3( 0.5,-1.8,-3.0), 0.15 );\n    \n    dCabeza=opSmoothUnion(dCabeza,dNarizCen,0.5);\n    dCabeza=opSmoothUnion(dCabeza,dNarizIzq,0.5);\n    dCabeza=opSmoothUnion(dCabeza,dNarizDer,0.5);\n    //boca\n    float donda= OndaDoble(p.xy*0.5-vec2(0.0,-1.5),iTime*2.5);\n    float dboca= sdBox(p-vec3(0.0,-3.5,-2.0), vec3(3.0,1.0,2.5));\n    dboca=intersectSDF(dboca,donda); \n    dboca=intersectSDF(dboca,dCabeza); \n    \n    res =opU3(res, vec3(dCabeza,33.0,-1.0));\n    res =opU3(res, vec3(dOjo,1.0,-1.0));\n    res =opU3(res, vec3(dPupilaAnillo,0.0,-1.0));\n    res =opU3(res, vec3(dPupila,3.0,-1.0));\n    res =opU3(res, vec3(dIris,0.0,-1.0));\n    res =opU3(res, vec3(dboca,2.0,-1.0));\n    return res;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float dis) \n{   vec3 l = normalize(lp - p);\n    vec3 ldir = normalize(p-rd);\n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    \n    float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true)\n        {fshadow=GetShadow(p,lp);}\n    else\n        {fshadow=0.5;}\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    //lin += 1.0*(dif3)+sh;\n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n  \n      lin *= atten*0.5*col*fshadow;\n    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    lin = pow(lin,vec3(0.4545));\n \n    return lin;\n    //return lin*atten*(1.0/2.0);\n    \n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float dis)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro,  colobj,dis);\n    return result;\n}\n///-------------------------------------\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n\n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    return colobj;\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d);\n   \n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \t   \n   light_pos1= vec3( 10.0, 30.0, -20.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 20.0, -20.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(0.0,12.0,-20.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n    //light_pos1+=ro;\n    //light_pos2+=ro;\n    \n     vec3 col= Render( ro,  rd);\n    //col = exposureToneMapping(2.0, col);\n    col = linear2srgb(col);\n     fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------common\n///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\nvec3  Arrcolores[34] = vec3[34] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9),\nvec3(230,177,161)/255.0\n);\n\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flVGW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[390, 390, 415, 415, 434], [435, 435, 460, 460, 479], [480, 480, 516, 516, 544], [683, 683, 719, 719, 740], [741, 741, 773, 773, 857], [858, 858, 897, 897, 992], [994, 994, 1033, 1033, 1128], [1130, 1130, 1167, 1167, 1246], [1249, 1249, 1301, 1301, 1422], [1423, 1467, 1515, 1515, 1542], [1543, 1543, 1586, 1586, 1613], [1614, 1614, 1662, 1662, 1690], [1692, 1717, 1751, 1751, 1847], [1848, 1848, 1882, 1882, 1973], [1974, 1974, 2009, 2009, 2100], [2102, 2102, 2154, 2154, 2253], [2255, 2255, 2313, 2313, 2413], [2415, 2415, 2474, 2474, 2573], [2575, 2615, 2635, 2635, 2705], [2706, 2706, 2726, 2726, 2796], [2797, 2797, 2817, 2817, 2887], [2889, 2909, 2926, 2926, 2989], [2991, 2991, 3055, 3055, 3306], [3308, 3308, 3353, 3353, 3614], [3617, 3617, 3652, 3652, 3795], [3797, 3797, 3822, 3822, 6977], [6979, 7030, 7054, 7054, 7216], [7218, 7218, 7267, 7267, 7934], [7936, 7936, 7972, 7972, 8217], [8219, 8219, 8246, 8246, 8263], [8265, 8265, 8301, 8301, 8393], [8394, 8394, 8440, 8440, 8565], [8569, 8569, 8654, 8654, 9908], [9910, 9910, 10001, 10001, 10129], [10172, 10172, 10204, 10204, 10401], [10403, 10403, 10496, 10496, 10653], [10656, 10656, 10687, 10687, 11286], [11288, 11288, 11314, 11314, 11424], [11426, 11426, 11484, 11484, 11536], [11538, 11587, 11644, 11644, 12249]], "test": "untested"}
{"id": "7lVGzh", "name": "Autumn mushrooms", "author": "iapafoto", "description": "Leprechauns love mushrooms, when they find an owl they party a lot\nWith party sound on, they only dance when there is music!", "tags": ["bezier", "automn", "elf", "lutin", "leprechaun"], "likes": 32, "viewed": 818, "published": 3, "date": "1637616224", "time_retrieved": "2024-07-30T18:46:39.412786", "image_code": "// Created by sebastien durand - 11/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// *****************************************************************************\n// Based on\n// iq - Quadratic Bezier - https://www.shadertoy.com/view/ldj3Wh\n// *****************************************************************************\n\n#define AA 1\n\n#define ZERO (min(iFrame,0))\n\n#define nose 2.\n#define hat 3.\n#define dress 4.\n#define leg 5.\n#define foot 6.\n#define bear 7.\n#define mushrom 9.\n\n//-----------------------------------------------------------------------------------\n\nvec3 getPtOnBez(vec3 p0, vec3 p1, vec3 p2, float t) {\n    return (1. - t) *((1. - t) * p0 + 2. * t * p1) + t * t * p2;\n}\n\n//-----------------------------------------------------------------------------------\n// Mercury\nfloat fOpUnionRound(float a, float b, float r) {\n\treturn max(r, min (a, b)) - length(max(vec2(r - a,r - b), vec2(0)));\n}\n\nfloat pModPolar(inout vec2 p, float rep) {\n\tfloat an = 3.141592/rep,\n         a = atan(p.y, p.x) + an,\n         r = length(p),\n         c = floor(.5*a/an);\n\ta = mod(a,2.*an) - an;\n\tp = vec2(cos(a), sin(a))*r;\n\tif (abs(c) >= rep*.5) c = abs(c);\n\treturn c;\n}\n\n//-----------------------------------------------------------------------------------\n// iq - https://www.shadertoy.com/view/ldj3Wh\nvec2 sdBezier(vec3 p, vec3 b0, vec3 b1, vec3 b2 ) {\n    b0 -= p; b1 -= p; b2 -= p;\n    vec3 b01 = cross(b0,b1), b12 = cross(b1,b2), b20 = cross(b2,b0),\n         n =  b01+b12+b20;\n    float a = -dot(b20,n), b = -dot(b01,n), d = -dot(b12,n), m = -dot(n,n);\n    vec3  g =  (d-b)*b1 + (b+a*.5)*b2 + (-d-a*.5)*b0;\n    float t = clamp((a*.5+b-.5*(a*a*.25-b*d)*dot(g,b0-2.*b1+b2)/dot(g,g))/m, 0., 1.);\n    return vec2(length(mix(mix(b0,b1,t), mix(b1,b2,t),t)),t);\n}\n\nvec2 sdCap(in vec3 p,in vec3 a,in vec3 b) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1.);\n  return vec2(length(pa - ba*h), h);\n}\n\nfloat sdEllips(in vec3 p,in vec3 r) {\n  float k = length(p/r);\n  return k*(k-1.)/length(p/(r*r));\n}\n\n//-----------------------------------------------------------------------------------\n// Scene modeling\nvec2 sdMush(vec3 p) {\n    float d = .5*(sdBezier(p, vec3(0,0,0), vec3(.4,3,0), vec3(.2,4.2,.3)).x-.1);\n\td = fOpUnionRound(d,max(sdEllips(p-vec3(.3,3.3,.3), vec3(1.2,.7,1.2)),\n                    -sdEllips(p-vec3(.27,3.,.25), vec3(1.3,.7,1.5))),.5);\n\td = min(d,sdEllips(p-vec3(-3.,.6,6.), vec3(.8,.6,.8)));\n\td = min(d,sdEllips(p-vec3(4.5,.5,2.5), vec3(.6,.5,.6)));\n\td = min(d,sdEllips(p-vec3(-6.5,.5,-8.5), vec3(.6,.5,.6)));\n\treturn vec2(d, mushrom);\n}\n\nvec2 sdHand(vec3 p, vec3 p10, vec3 p11, vec3 n) {\n    vec3 knee = .5*(p11+p10) + n,\n         p2 = getPtOnBez(p10, knee, p11, .2),\n         nn = normalize(p10-p2);\n    // harm     \n    vec2 h = sdBezier(p, p11, knee, p10);\n    float d,\n          dm = max(h.x - .1 - .05*h.y, -length(p-p10)+.2),\n          hm=h.y;\n    // fingers\n    d = sdCap(p, p10+vec3(.03*sign(n.x),0,0), p2).x;\n    p += nn*.05;\n    d = min(d, sdCap(p, p10+vec3(0,.05,0), p2+vec3(0,.05,0)).x);\n    d = min(d, sdCap(p, p10-vec3(-.02*sign(n.x),.05,0), p2-vec3(0,.05,0)).x);\n    p += nn*.05;\n    d = min(d, sdCap(p, p10-vec3(0,.1,0), p2-vec3(0,.1,0)).x);\n    d -= .05;\n    return d < dm ? vec2(d, nose) : vec2(dm, dress);\n}\n\nvec2 sdLeg(vec3 p, vec3 foot10, vec3 foot11, vec3 n) {\n    vec3 knee = .5*(foot11+foot10) + n,\n         p4 = getPtOnBez(foot10, knee, foot11, .2);\n    vec2 h = sdBezier(p, foot11, knee, foot10);\n    float d,dm = h.x - .1, \n          hm = leg + h.y;\n    // foot\n    h = sdCap(p, foot10, p4);\n    d = max(h.x - .2, -length(p- mix(foot10, p4, 2.5)) + .4);\n    if (d<dm) { dm=d; hm=dress;}\n    p.y += .1; \n    h = sdCap(p, foot10, foot10 + n);\n    d = h.x - .2;\n    if (d<dm) { dm=d; hm=hat; }\n    return vec2(dm,hm);\n}\n\nfloat invMix(float v0, float v1, float v) {\n    return v1 == v0 ? 1. : (v-v0)/(v1-v0);\n}\n\nfloat getAmp(float frequency) { return texture(iChannel2, vec2(frequency / 512.0, 0)).x; }\n\n#define BPM 127.\nvec2 sdLutin(vec3 p, float lid) {\n    float t = iChannelTime[2]*2.11666,\n          a1 = (getAmp(lid*lid * 20.)*.5+.5)*cos(9.*t+1.57 * lid),\n          anim = (getAmp(lid*lid * 40.)*.5+.5)*cos(6.*t+1.57 * lid),\n          gg = .5*cos(lid*110.);\n          \n    vec3 head = vec3(0,2.5+gg,0),\n         hips = vec3(0,1.2+gg,0);\n   \n    head += .2*vec3(.5,.5,.2)*(a1 + .5*anim);\n    hips += .3*vec3(.5,.2,.2)*anim;   \n    \n    vec3 epaule = head - vec3(0,.7,0),\n         c = head + vec3(0,.9,-.8),\n         b = head + vec3(0,.65,-.3);\n\n    float d, dm, hm = nose;\n    \n    // nez\n    dm = sdEllips(p- head - vec3(0,0,.5), vec3(.3,.15,.3));\n    \n    // bras\n    float s = p.x>0.?1.:-1.;\n    vec2 h = sdHand(p, epaule + vec3(s*1.,-.7+s*.3*anim- .3*gg,.5+ .4*gg), epaule+vec3(s*.4,0.,-.05), vec3(s*.2,-.2,-.2));\n    if( h.x<dm ) { dm=h.x; hm = h.y; }\n \n    // body\n    vec3 pb = p;\n    pb.z /= .7;\n    pb.z -= .2*cos(p.y)*smoothstep(epaule.y,hips.y,invMix(epaule.y,hips.y, p.y));\n    h = sdCap(pb, epaule+vec3(0,-.15,0), hips-vec3(0,.7,0));\n    d = max(h.x - mix(.4,.6,h.y), -length(pb-hips+vec3(0,.8,0)) + .7);\n    if (d<dm) { hm = dress; }\n    dm = .7*fOpUnionRound(d, dm, .15);\n    \n    // legs  \n    h = sdLeg(p, vec3(s*.5,-.7,0), hips + vec3(s*.25,-.2,0), vec3(s*.2,0,.3));\n    if (h.x<dm) { dm=h.x; hm=h.y; }\n    \n     // bonet\n    vec3 p3 = p + vec3(0,.1,-.1);\n    h = sdBezier( p3, head-vec3(0,.05,0), b, c );\n    d = .7*max( h.x - .5 + .5*h.y, -length(p3-(head-vec3(0,.8,-.6))) + 1.);\n    if( d<dm ) { dm=d; hm=hat; }\n\n    // barbe\n    vec3 p4 = p;\n    float k = mix(1.,3.,smoothstep(head.y, head.y-1., p4.y));\n    p4.z*=k;\n    h = sdBezier( p4, head, head - vec3(0,1.,.0), vec3(head.x, head.y, head.z*k) - vec3(-.2*anim,1,-3.));\n    d = .7*fOpUnionRound(h.x - .3*sin(3.14*h.y), length(p-(head-vec3(0,.4,-.2)))-.5, .15);\n    if (d<dm) { dm=d; hm=bear; }\n\n\treturn vec2(dm*.9, 10.*lid + hm );\n}\n\nvec2 map(in vec3 p) {\n\tvec2 h2, h1 = sdMush(p-vec3(0,-1.05,0));\n    float id = pModPolar(p.xz, 6.),\n          d = sdEllips(p-vec3(3,1.35,0), vec3(1.3,2.9,1.6));\n    if (d>0.) h2 = vec2(d+.1,0);\n    else      h2 = sdLutin((p - vec3(3,0,0)).zyx, id);\n    return h1.x<h2.x ? h1 : h2;\n}\n\n//-------------------------------------------------------\n// Ray marching\nvec3 intersect(vec3 ro, vec3 rd ) {\n    vec3 res = vec3(-1.);\n    float maxd = 25., tp = (-.85-ro.y)/rd.y;\n    if (tp>0.) {\n        res = vec3(tp,0,0);\n        maxd = min(maxd,tp);\n    }\n    // Lutins\n    float t = 2., l = 0.;\n    for( int i=ZERO; i<92; i++ ) {\n\t    vec2 h = map(ro+rd*t);\n        if (h.x<.004 || t>maxd) break;\n        t += h.x;\n\t\tl = h.y;\n    }\n    return t<maxd ? vec3(t, l, 1.) : res;\n}\n\nvec3 calcNormal(vec3 p) {\n // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0);\n    for( int i=ZERO; i<4; i++) {\n        vec3 e = .5773*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.);\n        n += e*map(p+.002*e).x;\n    }\n    return normalize(n);\n}\n\nfloat softshadow(vec3 ro,vec3 rd, float mt, float k) {\n    float res = 1., t = mt, h = 1.;\n    for( int i=ZERO; i<48; i++ ) {\n        h = map(ro + rd*t).x;\n        res = min( res, k*h/t );\n\t\tt += clamp( h, .002, 2. );\n        if( res<.001 ) break;\n    }\n    return clamp(res,0.,1.);\n}\n\nfloat map2(vec3 pos ) {\n    return min(pos.y+.85, map(pos).x);\n}\n\n\nfloat calcAO(vec3 p, vec3 n) {\n    float h,d,ao = 0.;\n    for( int i=ZERO; i<8; i++ ) {\n        h = .02 + .5*float(i)/7.;\n        d = map2( p + h*n );\n        ao += h-d;\n    }\n    return clamp( 1.5 - ao*.6, 0., 1. );\n}\n\n\n//------------------------------------------------------------------------\n// [Shane] - Desert Canyon - https://www.shadertoy.com/view/Xs33Df\n//------------------------------------------------------------------------\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D tex, vec3 p, vec3 n){\n    n = max(n*n, .001);\n    n /= (n.x + n.y + n.z );  \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// Grey scale.\nfloat grey(vec3 p) { return dot(p, vec3(.299, .587, .114)); }\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap( sampler2D tex, vec3 p, vec3 n, float k){\n    const float ep = .001;\n    vec3 grad = vec3( grey(tex3D(tex, vec3(p.x-ep, p.y, p.z), n)),\n                      grey(tex3D(tex, vec3(p.x, p.y-ep, p.z), n)),\n                      grey(tex3D(tex, vec3(p.x, p.y, p.z-ep), n)));\n    grad = (grad - grey(tex3D(tex, p, n)))/ep;             \n    grad -= n*dot(n, grad);          \n    return normalize(n + grad*k);\n}\n\n// iq palette\nvec3 pal(in float t) {\n    return .5 + .5*cos(6.28318*(t+vec3(.0,.33,.67)) );\n}\n\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord) {\n    vec4 tot = vec4(0);\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - .5,\n             p = (-iResolution.xy + 2.*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.*fragCoord)/iResolution.y;\n#endif\n\n        //-----------------------------------------------------\n        // camera\n        //-----------------------------------------------------\n        float an = 2. + .3*iTime + 3.*smoothstep(.9,.95, sin(.32*iTime)) +  3.*smoothstep(.9,.95, sin(.06*iTime));\n\n        vec3 ro = mix(1.75,1.2,smoothstep(-.9,-.8, cos(.15*iTime+.001*iTime*iTime)))*vec3(10.0*sin(an),5.0,10.0*cos(an)),\n             ta = vec3(.02*an,0,0);\n\n        // camera matrix\n        float a = .1*cos(.1*iTime);\n        vec3 ww = normalize(ta - ro),\n             uu = normalize(cross(ww,normalize(vec3(sin(a),cos(a),0)))),\n             vv = normalize(cross(uu,ww));\n\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n        //-----------------------------------------------------\n        // render\n        //-----------------------------------------------------\n\n        vec3 lig = normalize(vec3(-.2,.6,.9));\n        float sun = pow( clamp( dot(rd,lig), 0., 1. ), 8. );\n\n        // raymarch\n        vec3 tmat = intersect(ro,rd);\n\n        // geometry\n        vec3 nor, pos = ro + tmat.x*rd;\n        if( tmat.z<.5)\n             nor = vec3(0,1,0);\n        else nor = calcNormal(pos);\n        \n        vec3 ref = reflect( rd, nor );\n\n        // materials\n        vec3 mate = vec3(.5);\n\n        float lid = floor(tmat.y*.1);\n        tmat.y = mod(tmat.y,10.);\n        vec3 col, \n             col1 = pal(lid/6.),\n             col2 = pal(lid/6. + .33);\n\n        if (tmat.y < nose) {\n            float k = texture(iChannel1, .051*pos.xz).x;\n            mate = texture(iChannel1, .2*pos.xz).xyz;\n            mate = .12*pow(mate,vec3(.3));\n            mate = .5*mix(mate, vec3(.65,.5,.0), .2*smoothstep(.5,.6,k));\n            nor = doBumpMap(iChannel1, .2*pos, nor, .02);\n        } else if (tmat.y < hat) {\n            mate = vec3(.68,.475,.446);\n        } else if (tmat.y < dress) {\n            mate = col2;\n        } else if (tmat.y < leg) {\n            mate = col1;\n        } else if (tmat.y < bear) {\n            mate = mix(col2, vec3(.2), smoothstep( -0.1, 0.1, cos( 40.0*tmat.y )));\n        } else if (tmat.y < mushrom) {\n            vec3 p2 = pos;\n            float lid2 = pModPolar(p2.xz, 6.),\n            a1 = cos(6.*iTime+1.57 * lid2),\n            anim = cos(4.*iTime+1.57 * lid2);\n            vec3 head = vec3(0,2.5,0) + vec3(0,.5*cos(lid2*110.),0),\n            hips = vec3(0,1.2,0) + vec3(0,.5*cos(lid2*110.),0);\n            head += .2*vec3(.5,.5,.2)*(a1 + .5*anim);\n            nor = doBumpMap(iChannel0, 1.5*(pos-head)*vec3(1,.2,1), nor, .12);\n            mate = lid2<0. ? vec3(211,110,76)/256. : vec3(1.);\n        } else {\n            vec3 p = pos - vec3(.2,4.2,.3);\n            float r = length(p.xz);\n            if (r<2.) {\n                mate = mix(vec3(.7), .5*vec3(1,.5,1), smoothstep(.5,1.5,pos.y));\n                nor = doBumpMap(iChannel0, vec3(.1*atan(p.x,p.z),.1*r,0), nor, .01);\n            } else {\n                mate = vec3(.7);\n            }\n            mate = 2.*mix(.25*vec3(1,.7,.6),mate,smoothstep(.2,.3,tex3D(iChannel1, .5*pos, nor).x));\n        }\n\n        float occ = calcAO(pos, nor);\n\n        // lighting\n        float sky = clamp(nor.y,0.,1.),\n             bou = clamp(-nor.y,0.,1.),\n             dif = max(dot(nor,lig),0.),\n             bac = max(.3 + .7*dot(nor,-lig),0.),\n             fre = pow( clamp( 1. + dot(nor,rd), 0., 1. ), 5.),\n             spe = .5*max( 0., pow( clamp( dot(lig,reflect(rd,nor)), 0., 1.), 8.)),\n             sha = 0.; \n        if (dif>.001) sha=softshadow(pos+.01*nor, lig, .0005, 32.);\n\n        // lights\n        vec3 brdf = 2.*dif*vec3(1.25,.9,.6)*sha;\n        brdf += 1.5*sky*vec3(.1,.15,.35)*occ;\n        brdf += bou*vec3(.3)*occ;\n        brdf += bac*vec3(.3,.25,.2)*occ;\n        brdf += fre*occ*dif;\n\n        // surface-light interacion\n        col = mate.xyz* brdf;\n        col += (1.-mate.xyz)*spe*vec3(1,.95,.9)*sha*2.*(.2+.8*fre)*occ;\n\n        // fog\n        col = mix( col, 3.*vec3(.09,.13,.15), smoothstep(7.,30.,tmat.x) );\n\t\tcol += .4*vec3(1,.68,.7)*sun;\n        tot += vec4(col, tmat.x);\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // Gamma\n\ttot.xyz = pow(clamp(tot.xyz,0.,1.), vec3(0.5));\n    // Vigneting\n    vec2 q = fragCoord/iResolution.xy;\n    tot.xyz *= pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y), .32); \n    fragColor = vec4(tot.xyz,1.);\n}\n", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 20, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lVGzh.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[614, 614, 667, 667, 734], [736, 833, 881, 881, 953], [955, 955, 997, 997, 1211], [1213, 1345, 1396, 1396, 1803], [1805, 1805, 1848, 1848, 1968], [1970, 1970, 2007, 2007, 2069], [2071, 2175, 2196, 2196, 2626], [2628, 2628, 2677, 2677, 3316], [3318, 3318, 3372, 3372, 3833], [3835, 3835, 3878, 3878, 3923], [3925, 3925, 3956, 3956, 4015], [4034, 4034, 4067, 4067, 5924], [5926, 5926, 5947, 5947, 6208], [6210, 6284, 6319, 6319, 6691], [6693, 6693, 6718, 6813, 7003], [7005, 7005, 7059, 7059, 7289], [7291, 7291, 7314, 7314, 7355], [7358, 7358, 7388, 7388, 7576], [7579, 7950, 7992, 7992, 8137], [8139, 8154, 8174, 8174, 8215], [8217, 8299, 8355, 8355, 8718], [8720, 8734, 8756, 8756, 8813]], "test": "untested"}
{"id": "NlKGWh", "name": "Menger-Rubik's cube", "author": "FabriceNeyret2", "description": "Menger sponge & Rubik's cube at the same time :-)\n\nMouse controls, camera.", "tags": ["raymarching", "sdf", "menger", "rubik", "sierpinski", "short"], "likes": 40, "viewed": 602, "published": 3, "date": "1637614794", "time_retrieved": "2024-07-30T18:46:40.531794", "image_code": "\n#define rot(a)          mat2(cos(a+vec4(0,11,33,0)))  // rotation\n#define H(t)            fract(1e4*sin((t)*1e4))       // hash\n#define B(x,y,z,r1,r2)  max( max(a.x,a.z)-r1, a.y-r2) // box\n               // manage one slice, remember closest to pixel\n#define S(k)   r = q - Y* .67 *float(k-1),                     \\\n               i%3==k ? r.xz *= rot(s*fract(T)*1.57) : U,      \\\n               a = abs(r), v = B(x,y,z,1.,.33),                \\\n               v < t ? t=v, q0 = r + Y* .67 *float(k-1) : r\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9., s, v,T=iTime; \n    int n, i = int(18.*H(floor(T)));                  // choose the random rotation+dir\n    s = i%2==0 ? 1. : -1.; i/=2;                      // direction\n    \n    vec3  R = iResolution, Y = vec3(0,1,0),\n          D = normalize(vec3((U+U-R.xy)/R.y, -3.)),   // ray direction\n          p = vec3(0,0,6), q,q0,r,a,                  // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(10,12,0)/1e2*cos(iTime+vec3(0,11,0))+vec3(0,.12,0); \n\n    for ( O=vec4(1); O.x > 0. && t > .005; O-=.01 ) {\n        q = p,\n        q.yz *= rot(.5-6.3*M.y),                      // rotations\n        q.xz *= rot(-6.3*M.x), t = 9.,\n        q = i/3==1 ? q.xzy : i/3==2 ? q.yxz : q,      // choose rotation axis\n        S(0), S(1), S(2),                             // draw slices + rot one\n        q = q0;\n        for( n=0; n<3; n++ )                          // Menger fractal recursion\n            a = abs(q),\n            t = max(t, -B(x,y,z,.33,3.)),             // holes in 3 directions\n            t = max(t, -B(y,z,x,.33,3.)),\n            t = max(t, -B(z,x,y,.33,3.)),\n            q = fract( 1.5*(q+1.) )*2. - 1.;          // recursion to smaller scale\n\n        p += .25*t*D;                                 // step forward = dist to obj\n    }\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlKGWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[508, 508, 544, 544, 1834]], "test": "untested"}
{"id": "7tyGW1", "name": "Waterfall 5", "author": "guil", "description": "Simple fluid simulation using only velocity and density (no pressure).\nAdvection has been replaced with Mykhailo Moroz reintegration algorithm.", "tags": ["fluid"], "likes": 19, "viewed": 553, "published": 3, "date": "1637611964", "time_retrieved": "2024-07-30T18:46:41.747543", "image_code": "#define R iResolution.xy\n#define T1(U) texture(iChannel0,U/R)\n\nvoid mainImage( out vec4 C, in vec2 U )\n{   \n\n    float m = .2*T1(U).w;//masse\n    float v = length(T1(U).xy)/10.;//velocity\n    \n    \n    C = m*vec4(1,1.2,2,1);\n    \n    if (U.x < 0.2*R.x&&U.y < 0.5*R.y) C = vec4(0.5);\n    if (U.x < 0.4*R.x&&U.y < 0.3*R.y) C = vec4(0.5);\n    \n}  ", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define dt .1\n#define dt1 .4\n#define g .4\n#define l 4.\n#define nu 0.\n#define kappa .0\n#define h 2\n#define r 1.3\n\nvec2 R;\nvec4 Mouse;\nfloat t;\nint Frame;\n\n#define T(p) texture(ch,(p)/R)\n\nvoid sim( out vec4 Q, in sampler2D ch, in vec2 U )\n{   \n    \n    vec4 a = T(U+vec2(1,0)),b = T(U+vec2(0,1)),c = T(U+vec2(-1,0)),d = T(U+vec2(0,-1)),e=.25*(a+b+c+d), dx=a-c, dy=b-d;\n    \n    Q = T(U);\n\n    vec2 gw = vec2(dx.w,dy.w);//density gradient\n    Q.xy -= dt *((Q.w-1.)*l*gw + vec2(0.,g));//forces\n    Q -= dt * vec4(nu,nu,0,kappa) * 4.*(Q-e);//diffusion\n\n    //Boundaries\n    if (Frame < 1) Q = vec4(0,0,1,0);\n    if (U.x < 1.||U.y < 1.) Q.xy *= 0.;\n    if (R.x-U.x < 1.||R.y-U.y < 1.) Q.w *= 0.;\n    if (U.x < 0.2*R.x&&U.y < 0.5*R.y) Q.xy *= 0.;\n    if (U.x < 0.4*R.x&&U.y < 0.3*R.y) Q.xy *= 0.;\n \tif (length(U-vec2(0,0.9*R.y)) < 8.) {Q.xy= Q.xy*.5+.5*vec2(1.+0.4*sin(1.5*t),0); Q.w = 1.;};\n    \n    //click mouse to add a circular obstacle\n    if(length(Mouse.xy - U) < 20. && Mouse.z > 0.5)\n        Q.xyw = vec3(0,0,1);\n    \n    Q = clamp(Q, vec4(-3,-3,0,0), vec4(3,3,0,5));\n}\n\nvoid reint( out vec4 Q, in sampler2D ch, in vec2 U )\n{ \n        Q = vec4(0);\n        for (int x = -h; x <= h; x++)\n        for (int y = -h; y <= h; y++)\n        {\n            vec2 u = vec2(x,y);\n            vec4 a = T(U+u);\n            vec2 w1 = clamp(U+u+a.xy*dt1-0.5*r,U - 0.5,U + 0.5),\n                 w2 = clamp(U+u+a.xy*dt1+0.5*r,U - 0.5,U + 0.5);\n            float m = (w2.x-w1.x)*(w2.y-w1.y)/(r*r);\n            Q.xy += m*a.w*a.xy;\n            Q.w += m*a.w;\n        }\n        if (Q.w>0.)\n            Q.xy/=Q.w;\n\n}", "buffer_a_code": "void mainImage( out vec4 Q, in vec2 U )\n{      \n    R = iResolution.xy; t = iTime; Mouse = iMouse; Frame = iFrame;\n    reint( Q, iChannel0, U );\n    \n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 Q, in vec2 U )\n{      \n    R = iResolution.xy; t = iTime; Mouse = iMouse; Frame = iFrame;\n    sim( Q, iChannel0, U );\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tyGW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 104, 104, 342]], "test": "untested"}
{"id": "7ly3Wh", "name": "infinite mandelbrot zoom", "author": "peabrainiac", "description": "An infinite zoom into the mandelbrot set. Coloring sadly breaks after a while, but the fractal continues on forever.", "tags": ["mandelbrot", "zoom", "infinite"], "likes": 25, "viewed": 894, "published": 3, "date": "1637604839", "time_retrieved": "2024-07-30T18:46:42.713959", "image_code": "// zoom locations. comment this one and uncomment one of the others to zoom somewhere else\n// needle\nconst vec2 MINIBROT_C = vec2(-1.98542425,0.0);\nconst vec2 MINIBROT_SCALE = vec2(5.81884941e-5,0.0);\nconst vec2 MINIBROT_A = vec2(-161.347726,0.0);\nconst float MINIBROT_PERIOD = 5.0;\n\n// seahorse valley 1\n/*const vec2 MINIBROT_C = vec2(-0.862612214,-0.274371722);\nconst vec2 MINIBROT_SCALE = vec2(-5.33653763e-6,-1.60082654e-5);\nconst vec2 MINIBROT_A = vec2(187.960106,92.5553918);\nconst float MINIBROT_PERIOD = 12.0;*/\n\n// seahorse valley 2\n/*const vec2 MINIBROT_C = vec2(-0.722551290,-0.260810603);\nconst vec2 MINIBROT_SCALE = vec2(1.73516282e-5,-6.24633482e-6);\nconst vec2 MINIBROT_A = vec2(157.460179,-16.4403340);\nconst float MINIBROT_PERIOD = 21.0;*/\n\n// elephant valley\n/*const vec2 MINIBROT_C = vec2(0.34462359,0.0564018310);\nconst vec2 MINIBROT_SCALE = vec2(-2.21366831e-6,8.05314001e-7);\nconst vec2 MINIBROT_A = vec2(-113.398177,231.589991);\nconst float MINIBROT_PERIOD = 17.0;*/\n\n// alternating whatever\n/*const vec2 MINIBROT_C = vec2(-0.162415772,-1.04133681);\nconst vec2 MINIBROT_SCALE = vec2(-1.07141152e-6,1.02473337e-6);\nconst vec2 MINIBROT_A = vec2(30.7304447,-1057.92453);\nconst float MINIBROT_PERIOD = 24.0;*/\n\nconst float MINIBROT_R = 8.0;\nconst float MINIBROT_R2 = 32.0;\n\nconst int ITER = 500;\nconst float BAILOUT = 32.0;\n\nvec2 cmul(vec2 a, vec2 b){\n    return vec2(dot(a,vec2(1.0,-1.0)*b),dot(a,b.yx));\n}\n\nvec2 cdiv(vec2 a, vec2 b){\n    return vec2(dot(a,b),dot(a.yx,vec2(1.0,-1.0)*b))/dot(b,b);\n}\n\n// sort of a minimal example of an algorithm I've been working on for a while now.\n// this version only supports zooming into the same minibrot again and again, but\n// there's really nothing stopping one from changing the parameters for each minibrot,\n// and adjusting them automatically as one explores the fractal.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float t = iTime*iTime/(iTime+1.0);\n    float s = -log(length(MINIBROT_SCALE));\n    int n = int(ceil(t/s));\n    float zoom = exp(-(t-s*float(n)));\n    float theta = float(n)*atan(MINIBROT_SCALE.y,MINIBROT_SCALE.x);\n    vec2 C = cmul(MINIBROT_C,cdiv(vec2(1.0,0.0),vec2(1.0,0.0)-MINIBROT_SCALE));\n    vec2 dc = vec2(cos(theta),-sin(theta))*10.0*zoom/length(iResolution);\n    vec2 c = C+cmul(dc,vec2(1.0,-1.0)*(fragCoord-iResolution.xy*0.5));\n    while (n>0&&dot(c-MINIBROT_C,c-MINIBROT_C)>MINIBROT_R2){\n        c = MINIBROT_C+cmul(c,MINIBROT_SCALE);\n        dc = cmul(dc,MINIBROT_SCALE);\n        n--;\n    }\n    \n    vec2 z = vec2(0.0);\n    vec2 dz = dc;\n    int i = 0;\n    float i2 = 0.0;\n    float escapeRadius = n==0?BAILOUT:MINIBROT_R;\n    while(i<ITER){\n        if (dot(z,z)>escapeRadius){\n            if (n==0){\n                break;\n            }else{\n                z = cdiv(z,MINIBROT_A);\n                dz = cdiv(dz,MINIBROT_A);\n                c = MINIBROT_C+cmul(c,MINIBROT_SCALE);\n                dc = cmul(dc,MINIBROT_SCALE);\n                n--;\n                i2 *= MINIBROT_PERIOD;\n                float escapeRadius = n==0?BAILOUT:MINIBROT_R;\n            }\n        }\n        dz = 2.0*cmul(dz,z)+dc;\n        z = cmul(z,z)+c;\n        i++;\n        i2++;\n    }\n    // mixture of distance estimation and logarithmic coloring. sadly, both break after a while.\n    float d = !(i<ITER)?0.0:sqrt(dot(z,z)/dot(dz,dz))*0.5*log(dot(z,z));\n    fragColor = vec4(vec3((1.0-d)*(0.5+0.5*cos(log(1.0+i2*2.0e-5)))),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ly3Wh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1344, 1344, 1370, 1370, 1426], [1428, 1428, 1454, 1454, 1519], [1521, 1838, 1892, 1892, 3418]], "test": "untested"}
{"id": "stG3W1", "name": "Tunnel Experiment #2", "author": "Yusef28", "description": "A tunnel ", "tags": ["tunnel"], "likes": 68, "viewed": 4365, "published": 3, "date": "1637598774", "time_retrieved": "2024-07-30T18:46:43.664418", "image_code": "\n#define T(uv) texture(iChannel0,uv)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n\n    //some sort of adhoch antialiasing based on\n    //an anisotrpic effect by:ulianlumia\n    //unstable universe - https://www.shadertoy.com/view/wtlfz8\n    //fragColor = texelFetch(iChannel0, ivec2(fragCoord),0);\n    fragColor = vec4(0.);\n    float f = length(uv  - 0.6);\n    float SHIFT = sin(iTime)*0.002;\n    fragColor.x += T(uv + f*SHIFT).x;\n    fragColor.y += T(uv -f*SHIFT/2.).y;\n    fragColor.z += T(uv-f*SHIFT).z;\n    fragColor.xyz *= 1.5;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define eps 0.001\n#define S smoothstep\n#define T iTime\n#define TX texture\n#define C clamp\n\n#define MAX_STEPS 100\n#define MAX_DIST 50.\n#define pi 3.14159265\n\nfloat ROUNDING_FACTOR = 0.;\nfloat ROTATION_FACTOR = 10.;\n\nfloat TUBE_RIB_REP_FACTOR = 10.;\nfloat TUBE_RIB_AMP_FACTOR = .0;\nfloat TUNNEL_RADIUS_FACTOR = 1.5;\nfloat SIDE_NUM = 3.;\n\nfloat TEETH_FLOAT = 2.;\nfloat TEETH_REACH = 1.5;\nfloat TEETH_SHAPE_X = 0.5;\nfloat TEETH_SHAPE_Y = 0.15;\nfloat TEETH_SHAPE_POW_Z = 0.2;\nfloat CAMERA_Z_POS = 0.;\nfloat CAMERA_ROTATE_XZ = 0.;\nfloat GAMMA = 0.8;\nfloat BRIGHTNESS = 1.;\nvec3 FAR_LIGHT_POS = vec3(0.,0.,1.4);\nvec3 CLOSE_LIGHT_POS = vec3(0.,-0.,-1.4);\nvec3 backgroundColor = vec3(1.);\nfloat PATH_AMPLITUDE = 0.;\n\n\n//uncomment for more movement\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (a - b) / k, 0.0, 1.0 );\n    return mix( b, a, h ) + k * h * (1.0 - h);\n}\n\nmat2 rot(float a){\n    float c = cos(a), s = sin(a);\n    return mat2(c,-s,s,c);\n}\n    \nfloat sdBox(vec3 p, vec3 d){\n    p = abs(p)-d;\n    return length(max(p,0.)) + \n    min(max(p.x,max(p.y,p.z)), 0.)-ROUNDING_FACTOR;\n}\nfloat sdBox2D(vec3 p, vec3 d){\n    p = abs(p)-d;\n    //return length(max(p,0.)) + \n    return max(p.x,p.z);\n}\nvec2 modPolar(vec2 p, float n){\n\n    float a0 = float(n) / radians(360.); \n    float a = round( atan(p.y, p.x) * a0 ) / a0;\n    \n    p -= vec2(cos(a), sin(a));\n    \n    p *= rot(-a);\n    \n    return p;\n}\n\nvec3 path(vec3 p){\n    // #if PATH_ON == 1.\n     p.x += sin(p.z/4.)*PATH_AMPLITUDE;\n     p.y += sin(p.z/4.+3.)*PATH_AMPLITUDE;\n   //  #endif\n     return p;\n}\n\nfloat globalID = -1.;\nfloat glow;\n\nfloat map(vec3 p){\n    \n    p = path(p);\n    p.xy*=rot(p.z/(ROTATION_FACTOR));//+(0.5+0.5*sin(mod(iTime/5.,2.)))*2.)   );\n    float radius = TUNNEL_RADIUS_FACTOR;//0.8\n    float num = SIDE_NUM; //5 to 8\n    float z = sin(floor(p.z/4.))/4.;\n    float d = 1000.;\n    float tunnel = length(p.xy) - 3.4 \n                                - abs(sin(p.z*TUBE_RIB_REP_FACTOR))\n                                *TUBE_RIB_AMP_FACTOR;\n    d = min(d,tunnel);\n    //p.xy -= vec2(z);\n    \n    //magic!\n    vec3 st = vec3(modPolar(p.xy, num), mod(p.z, 4.)-2. );\n    \n    float wall = sdBox( st-vec3(radius,0.,0.), vec3(0.1,2.,2.) );\n    d = min(-d,wall);\n    //d = min(d, length(st-vec3(radius,0.,0.))-0.3);\n    \n    //d = min(d, sdBox( st-vec3(radius,0.,0.), vec3(0.6,.3, pow(length(p.xy)-1., 2.7) ) ));\n    \n    //door layer one thick\n    float layer1 = sdBox( st-vec3(radius,0.,0.), vec3(0.5,4.,.1) );\n    //door layer two thinner\n    float layer2 = sdBox( st-vec3(radius,0.,0.), vec3(0.8,3.,.08) );\n    //door layer three really thin edge thing\n    float layer3 = sdBox( st-vec3(radius,0.,0.), vec3(0.84,3.7,.01) );\n    \n    d = min(d,min(layer1,min(layer2,layer3)));\n    //\n    vec3 st3 = vec3(modPolar(p.xy, num), mod(p.z, .2)-.1);\n    float lines = sdBox( st3-vec3(radius*1.0,0.,0.), vec3(0.1, 1.85,.02) );\n    //float lines = sdBox( st3-vec3(radius,0.,0.), vec3(0.15,1.,.03) );\n    d = min(d,lines);\n    vec3 st2 = vec3(modPolar(p.xy, num), mod(p.z, 2.)-1.);\n    //panel thing\n    float panel = sdBox( st2-vec3(radius,0.,0.), vec3(0.4,1.1,.9));\n    d = min(d,panel);\n    \n    //panel-indent thing\n    //first version has artifacts\n    //float indent = sdBox( st2-vec3(radius*0.74,0.,0.), vec3(0.15,.58,.8) );\n    float indent = sdBox( st2-vec3(radius*0.74,0.,0.), vec3(0.15,.8,.75) );\n    d = smax(d, -indent,0.003);\n    float outdent = sdBox( st2-vec3(radius,0.,0.), vec3(0.15,.5,.78) );\n    d = min(d, outdent);\n    \n    //ramp thing\n    float ramp = sdBox( vec3(st.x,mod(st.y*TEETH_FLOAT,1.)-.5,st.z*TEETH_REACH)-vec3(radius,0.,0.), vec3(TEETH_SHAPE_X,TEETH_SHAPE_Y, pow(length(st.x/9.)/9., TEETH_SHAPE_POW_Z) ));\n    \n    /*\n    //basic ramp no teeth\n    ramp = sdBox(st-vec3(radius,0.,0.), vec3(0.8,.2, pow(length(st.x/4.), 1.9) ));\n    \n    //basic side teeth\n    ramp = sdBox( vec3(st.x,mod(st.y*4.,1.)-.5,st.z)-vec3(radius,0.,0.), vec3(0.8,.2, pow(length(st.x/4.), 1.9) ));\n\n    //full teeth\n    ramp = sdBox( vec3(st.x,mod(st.y*4.,1.)-.5,st.z)-vec3(radius,0.,0.), vec3(0.85,.3, pow(length(st.x/4.), 1.9) ));\n\n    //thin cover\n    ramp = sdBox( vec3(st.x,mod(st.y*4.,1.)-.5,st.z)-vec3(radius,0.,0.), vec3(1.5,.3, pow(length(st.x/7.), 1.) ));\n\n    //cover\n    ramp = sdBox( vec3(st.x,mod(st.y*4.,1.)-.5,st.z)-vec3(radius,0.,0.), vec3(1.,.3, pow(length(st.x/1.), 1.) ));\n    //exposed\n    ramp = sdBox( vec3(st.x,mod(st.y*4.,1.)-.5,st.z)-vec3(radius,0.,0.), vec3(.8,.3, pow(length(st.x/1.), 1.) ));\n    */  \n    \n    \n    //ramp = max(ramp, -sdBox( st-vec3(radius,0.,-.3), vec3(0.5,.05, 0.2 ) ));\n    d = smin(d,ramp,0.01);\n    \n    vec3 st4 = vec3(p.x,p.y,mod(p.z,2.)-1.);\n    float bridge = sdBox( st4-vec3(0.,-1.1,0.), vec3(0.6,.04, .8 ));\n    //d = min(d,bridge);\n    //globalID = 5.;\n    \n    float minVal = min(min(\n                        min(\n                            min(layer3,lines),\n                            min(panel,bridge)),\n                        min(\n                            min(wall, outdent),\n                            min(layer1,layer2))), min(indent,ramp));\n                            \n    minVal = min(minVal,-tunnel);\n    if(minVal == wall)globalID = 32.;\n    \n    else if(minVal == layer1)globalID = 2.;\n    else if(minVal == layer2)globalID = 3.;\n    else if(minVal == layer3)globalID = 4.;\n    else if(minVal == outdent)globalID = 5.;\n    else if(minVal == lines)globalID = 6.;\n    else if(minVal == bridge)globalID = 7.;\n    else if(minVal == panel)globalID = 5.;\n    else if(minVal == ramp)globalID = 5.;\n    else if(minVal == -tunnel)globalID = 33.;\n    //else globalID = 9.;\n    \n    //else if(minVal == tunnel)globalID = 80.;\n    \n    if(minVal == layer3){\n        glow += smoothstep(0.2,1.,0.015/pow(layer3,.9))*3.;\n    }\n    if(minVal == lines){ \n       glow += abs(max(0.01,(0.0001/(0.03*pow(lines, 1.)))));\n    }\n    \n    \n    return d;\n}\n\nfloat trace(vec3 ro, vec3 rd){\n    \n    float t, d= 0.;\n    \n    for(int i = 0; i < MAX_STEPS; i++){\n        d = map(ro + rd*t);\n        if(abs(d) < 0.001 || t > MAX_DIST) break;\n        t += d*0.75;\n    }\n    \n    return t;\n}\n\nfloat rtrace(vec3 ro, vec3 rd){\n    \n    float t, d= 0.;\n    \n    for(int i = 0; i < MAX_STEPS; i++){\n        d = map(ro + rd*t);\n        if(abs(d) < 0.001 || t > MAX_DIST) break;\n        t += d*0.85;\n    }\n    \n    return t;\n}\nvec3 normal(vec3 p){\n    \n    float d = map(p);\n    vec2 e = vec2(eps,0.);\n    \n    vec3 n = d - vec3(\n            map(p-e.xyy),\n            map(p-e.yxy),\n            map(p-e.yyx));\n            \n    return normalize(n);\n}\nvec3 camRay(vec2 uv, vec3 o, vec3 target, float zoom){\n    \n    vec3 fwd = normalize(target - o);\n    vec3 uu = vec3(0.,1.,0.);\n    vec3 right = normalize(cross(uu, fwd));\n    //order matters\n    vec3 up = cross(fwd,right);\n    vec3 rd = right*uv.x + up*uv.y + fwd*zoom;\n    return normalize(rd);\n\n}\n\n//from shane\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .002;    \n    float end = max(length(rd), .001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, .2), \n        // clamp(h, .02, stepDist*2.), etc.\n        dist += clamp(h, .02, .25);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist>end) break; \n        //if (h<.001 || dist > end) break; // If you're prepared to put up with more artifacts.\n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me.\n    return min(max(shade, 0.) + .25, 1.); \n}\nfloat getGrey(vec3 p)\n{\n    return p.x*0.299 + p.y*0.587 + p.z*0.114;\n       }\n\n//from shane, and he got it from an nvidia tutorial you can google\nvec3 triPlanar(sampler2D tex, vec3 p, vec3 n)\n{\n\n vec3 norm = max(abs(n), 0.0001);\t//I'll keep it simple with just this\n float sum = norm.x+norm.y+norm.z;\n norm = norm/sum;\n    return vec3(texture(tex, p.yz)*norm.x + \n                texture(tex, p.xz)*norm.y +\n                texture(tex, p.xy)*norm.z) ;\n    \n}\n\nvec3 bumpMap(sampler2D tex, in vec3 p, in vec3 n, float bumpfactor)\n{\n\n    const vec3 eps3 = vec3(0.001, 0., 0.);//I use swizzling here, x is eps\n    float ref = getGrey(triPlanar(tex, p, n));//reference value \n    vec3 grad = vec3(getGrey(triPlanar(tex, p - eps3, n)) - ref,\n                     //eps.yxz means 0.,0.001, 0. \"swizzling\n                     getGrey(triPlanar(tex, p - eps3.yxz, n)) - ref,\n                     getGrey(triPlanar(tex, p - eps3.yzx, n)) - ref)/eps3.xxx;\n    \n    grad -= n*dot(grad, n);\n\n    return normalize(n + grad*bumpfactor);\n}\n\nfloat calcAo(vec3 p, vec3 n)\n{\n \nconst float ao_samples = 5.;\n    float r = 0.0, w = 1.0, d;\n    for(float i = 0.01 ; i<ao_samples ; i+=1.1)\n    {\n    d = i/ao_samples;//1/5, 2/5, 3/5, 4/5, 1\n    r += w*(d - map(p + n*d));\n    w*=0.5;\n    }\n\n    return 1.0 - clamp(r,0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n   // vec2 m = iMouse.xy/iResolution.xy;\n   // fragColor = vec4(0.);\n    vec3 ro = vec3(0., 0., -3.+iTime*3. + CAMERA_Z_POS);\n    ro = vec3(-path(ro).xy,ro.z);\n    //ro.yz *= rot(-m.y*pi+1.);\n    //ro.xz *= rot(-m.x*pi*2.);\n    \n    //I was getting some artifacts when I had y at 0.4 or -0.4\n    //for these lights. Glow related artifacts, which was weird.\n    //So I am just letting the x and y be guided by ro.\n    vec3 farLight = ro + FAR_LIGHT_POS;\n    vec3 closeLight = ro + CLOSE_LIGHT_POS;\n    vec3 rd = camRay(uv, ro, ro + vec3(0.,0.,1.), 0.8);\n    rd.xz *= rot(CAMERA_ROTATE_XZ);\n    \n    float t = min(MAX_DIST,trace(ro, rd));\n    \n    \n    // Time varying pixel color\n    vec3 col = vec3(0.0);//TX(iChannel0, rd).rgb;\n    vec3 rcol = vec3(0.);\n    if(t < MAX_DIST){\n    \n        vec3 p = ro + rd*t;\n        vec3 n = normal(p);\n        \n        //col = n*0.5+0.5;//0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n        //col = abs(fract(vec3(atan(p.y,p.x)*pi,p.z,p.z))-0.5);\n        //col= n*0.5+0.5;\n        \n        vec3 seedColor= vec3(3.,2.,5.)/2.;\n        seedColor.xy *= rot(.7);\n        vec3 alb = 1.*vec3((0.5+0.5*cos(seedColor*8. + globalID*6. + 30.).x)*1.2>0.);\n        alb = 0.5+0.5*cos(seedColor*8. + globalID*19. + 34.);\n        //alb.xz *= rot(1.3);\n        alb = alb.zzz-0.1;\n        \n        //alb = 0.5+0.5*cos(vec3(1.,2.,4.)/1. + globalID*54.+1.);\n        \n        if(globalID < 2.) {\n            alb *= triPlanar(iChannel0,p/4.,n).xxx;\n            #ifdef BUMP_MAP_ON\n                n = bumpMap(iChannel0, p/4., n, 0.01);\n            #endif\n        }\n        \n        else if(globalID == 6.){ alb = pow(\n            triPlanar(iChannel1,p/4.,n).xxx,vec3(1.))*3.;\n            #ifdef BUMP_MAP_ON\n                n = bumpMap(iChannel1, p/4., n, 0.01);\n            #endif\n            }\n        \n        else if(\n            globalID < 8.){ alb *= triPlanar(iChannel2,p/4.,n).xxx;\n            #ifdef BUMP_MAP_ON\n                n = bumpMap(iChannel2, p/4., n, 0.01);\n            #endif\n        }\n        \n        //alb = pow(alb,vec3(.3));\n\n        if(globalID == 32.){ alb = backgroundColor*vec3(1.,0.3,0.);}\n        if(globalID == 33.){ alb = backgroundColor*vec3(0.,0.3,0.8);}\n\n        //light 1\n        float ldist = length(farLight-p);\n        vec3 ldir = (farLight-p)/ldist;\n        float diff = max(dot(ldir,n),0.);\n        float spec = pow(max(dot(reflect(-ldir,n),-rd),0.),200.)*1.;\n        col = alb*0.9*diff + spec*vec3(0.5,0.8,0.9);\n        \n        float sha = softShadow(p,farLight,12.);\n        float ao = calcAo(p,n);\n        col *= ao;\n        col *= sha;\n        \n        //light 2\n        ldist = length(closeLight-p);\n        ldir = (closeLight-p)/ldist;\n        diff = max(dot(ldir,n),0.);\n        spec = pow(max(dot(reflect(-ldir,n),-rd),0.),100.)*1.;\n        col += alb*0.3*diff*vec3(1.,0.7,0.7);\n        col/=2.;\n        \n        \n        col += vec3(0.5+0.5*cos(iTime + seedColor + sin(p)/2.))*clamp(glow,0.,1.);//*pow(t/MAX_DIST,.7);\n\n    }\n    \n    col = mix(col,vec3(0.), pow(t/MAX_DIST,1.9));\n    \n    // Output to screen\n    col *= BRIGHTNESS;\n    col = pow(col, vec3(GAMMA));\n    fragColor = vec4(col,1.0);\n}\n\n", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*#define ROUNDING_FACTOR 0.\n#define ROTATION_FACTOR 10.\n\n#define TUBE_RIB_REP_FACTOR 10.\n#define TUBE_RIB_AMP_FACTOR .01\n#define TUNNEL_RADIUS_FACTOR 1.5\n#define SIDE_NUM 3.\n\n#define TEETH_FLOAT 2.\n#define TEETH_REACH 1.5\n#define TEETH_SHAPE_X 0.5\n#define TEETH_SHAPE_Y 0.15\n#define TEETH_SHAPE_POW_Z 0.2\n\n#define CAMERA_Z_POS 0.\n#define CAMERA_ROTATE_XZ 0.\n#define GAMMA 0.8\n#define BRIGHTNESS 1.\n#define FAR_LIGHT_POS vec3(0.,0.,1.4)\n#define CLOSE_LIGHT_POS vec3(0.,-0.,-1.4)\n\n\n#define backgroundColor vec3(1.)\n#define PATH_AMPLITUDE 0.\n\n//#define PATH_ON 0.\n//#define BUMP_MAP_ON 0.\n\n*/", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stG3W1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 95, 95, 589]], "test": "untested"}
{"id": "slyGW1", "name": "line antialiasing 2", "author": "FabriceNeyret2", "description": "thickness > pixel width: regular smoothstep(SDF)\nthickness < pixel width: keep 1.5 pix width, decrease luminance instead.\nDon't forget sRGB final conversion, this is crucial for AA.\nTop: linear radius ( thus converge to grey). Bottom: quadratic radius.", "tags": ["2d", "antialiasing", "short"], "likes": 24, "viewed": 726, "published": 3, "date": "1637595908", "time_retrieved": "2024-07-30T18:46:44.482232", "image_code": "// see also: https://www.shadertoy.com/view/3tSGWy\n//           https://www.shadertoy.com/view/tst3DX\n\n#define R iResolution.xy\n  #define S(d,r) smoothstep( 3.,0., (d)*R.y -r )  \n//#define S(d,r) max( 0., 1. -(d)*R.y/2. +r )  \n  \n\nfloat line(vec2 p, vec2 a,vec2 b, float r) { \n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.), // proj coord on line\n          d = length(p - b * h);                    // dist to segment\n    return S(  d , max(0.,r-1.) ) * min(r,1.);\n}\n\n\nvoid mainImage( out vec4 O,  vec2 u )\n{\n    O -= O;\n    vec2 U = ( 2.*u - R ) / R.y;\n    float tau = 6.2832, n = U.x < 0. ? 32. : 128.,  // number of lines\n          a, l = length(U);\n    l *= U.y > 0. ? .5 : 4.*l;\n#define Line O += (1.-O) * line( U, vec2(0), cos(tau*a-vec2(0,1.57)) , l )\n\n    if ( l*tau/n < 5./R.y ) \n        for ( a = 0.; a < 1.; a+=1./n )             // draw all lines\n            Line;\n               // optim: when lines are separated, e can do this loopless\n    else a = ( round( atan(U.y,U.x)/tau*n )  ) / n,\n            Line;\n\nO = pow(O, vec4(1./2.2) );                          // to sRGB\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slyGW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[231, 231, 275, 275, 490], [493, 493, 532, 532, 1110]], "test": "untested"}
{"id": "7lyGW1", "name": "eindacor_perlin", "author": "Eindacor_DS", "description": "it's perlin noise, you dolt!", "tags": ["perlin"], "likes": 1, "viewed": 193, "published": 3, "date": "1637594966", "time_retrieved": "2024-07-30T18:46:45.395789", "image_code": "#define GRID_DIMENSION .1f\n#define AA .02f\n#define CYAN vec3(0., 1., 1.)\n#define MAGENTA vec3(1., 0., 1.)\n#define YELLOW vec3(1., 1., 0.)\n#define RED vec3(1., 0., 0.)\n#define GREEN vec3(0., 1., 0.)\n#define BLUE vec3(0., 0., 1.)\n#define ORANGE vec3(1., .75, .25)\n#define PINK vec3(1., .25, .75)\n#define WHITE vec3(1.)\n#define BLACK vec3(0.)\n#define PI 3.1415926\n#define DEBUG false\n\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 getRandomVector(float seed) {\n    if (seed < .25) {\n        return vec2(1., 1.);\n    } else if (seed < .5) {\n        return vec2(-1., 1.);\n    } else if (seed < .75) {\n        return vec2(1., -1.);\n    } else {\n        return vec2(-1., -1.);\n    }\n}\n\nfloat getNonPeriodic(float seed) {\n    return (sin(2. * seed) + sin(PI * seed)+ 2.) / 4.;\n}\n\nvec3 getRandomColor(float seed) {\n    seed = clamp(seed, 0., 1.);\n    float colorCount = 6.;\n    float colorIncrement = 1.f / colorCount;\n    float seedFloor = floor(seed / colorIncrement) * colorIncrement;\n    float lerpVal = smoothstep(seedFloor, seedFloor + colorIncrement, seed);\n\n    if (seed <= colorIncrement * 1.) {\n        return mix(RED, YELLOW, lerpVal);\n    } else if (seed <= colorIncrement * 2.) {\n        return mix(YELLOW, GREEN, lerpVal);\n    } else if (seed <= colorIncrement * 3.) {\n        return mix(GREEN, CYAN, lerpVal);\n    } else if (seed <= colorIncrement * 4.) {\n        return mix(CYAN, BLUE, lerpVal);\n    } else if (seed <= colorIncrement * 5.) {\n        return mix(BLUE, MAGENTA, lerpVal);\n    } else {\n        return mix(MAGENTA, vec3(1.), lerpVal);\n    }\n}\n\nvec3 getColor(float seed) {\n    seed = clamp(seed, 0., 1.);\n    float colorIncrement =.25;\n    float seedFloor = floor(seed / colorIncrement) * colorIncrement;\n    float lerpVal = smoothstep(seedFloor, seedFloor + colorIncrement, seed);\n\n    if (seed <= .25) {\n        return mix(PINK * .5, ORANGE, lerpVal);\n    } else if (seed <= .5) {\n        return mix(ORANGE, PINK * .8, lerpVal);\n    } else if (seed <= .75) {\n        return mix(PINK * .8, MAGENTA, lerpVal);\n    } else {\n        return mix(MAGENTA, WHITE, lerpVal);\n    } \n}\n\nvec3 getMixedColor(vec3 color0, vec3 color1, vec3 color2, vec3 color3, float seed) {\n    seed = clamp(seed, 0., 1.);\n    float colorIncrement = .2;\n    float seedFloor = floor(seed / colorIncrement) * colorIncrement;\n    float lerpVal = smoothstep(seedFloor, seedFloor + colorIncrement, seed);\n\n    if (seed <= .2) {\n        return color0;\n    } else if (seed <= .4) {\n        return mix(color0, color1, lerpVal);\n    } else if (seed <= .6) {\n        return mix(color1, color2, lerpVal);\n    } else if (seed <= .8) {\n        return mix(color2, color3, lerpVal);\n    } else {\n        return color3;\n    }\n}\n\nfloat biLerp(float f0, float f1, float f2, float f3, float lerpX, float lerpY) {\n    float upper = mix(f1, f2, lerpX);\n    float lower = mix(f0, f3, lerpX);\n    \n    return mix(lower, upper, lerpY);\n}\n\nfloat getPerlinValue(vec2 uv, float gridDimension) {\n    float xCoord = floor(uv.x / gridDimension) * gridDimension;\n    float yCoord = floor(uv.y / gridDimension) * gridDimension;\n    \n    float xIndex = floor(uv.x / gridDimension);\n    float yIndex = floor(uv.y / gridDimension);\n    \n    float p0Hash = hash(vec2(xIndex, yIndex));\n    float p1Hash = hash(vec2(xIndex, yIndex + 1.));\n    float p2Hash = hash(vec2(xIndex + 1., yIndex + 1.));\n    float p3Hash = hash(vec2(xIndex + 1., yIndex));\n    \n    vec2 p0 = vec2(xCoord, yCoord);\n    vec2 p1 = vec2(xCoord, yCoord + gridDimension);\n    vec2 p2 = vec2(xCoord + gridDimension, yCoord + gridDimension);\n    vec2 p3 = vec2(xCoord + gridDimension, yCoord);\n    \n    float dot0 = dot((uv - p0) / gridDimension, getRandomVector(p0Hash));\n    float dot1 = dot((uv - p1) / gridDimension, getRandomVector(p1Hash));\n    float dot2 = dot((uv - p2) / gridDimension, getRandomVector(p2Hash));\n    float dot3 = dot((uv - p3) / gridDimension, getRandomVector(p3Hash));\n    \n    float xInterp = smoothstep(p0.x, p2.x, uv.x);\n    float yInterp = smoothstep(p0.y, p2.y, uv.y);\n    \n    float val = biLerp(dot0, dot1, dot2, dot3, xInterp, yInterp);\n    \n    // normalizes the perlin value, but inhibits additive perlin functionality upstream\n    //val = (val + 1.) / 2.;\n    \n    if (DEBUG) {\n        float distp0 = distance(p0, uv);\n        \n        float debugDotRadius = .005;\n        float debugAA = debugDotRadius * .5;\n        \n        val += smoothstep(debugDotRadius + debugAA, debugDotRadius - debugAA, distance(p0, uv));\n        val += smoothstep(debugDotRadius + debugAA, debugDotRadius - debugAA, distance(p1, uv));\n        val += smoothstep(debugDotRadius + debugAA, debugDotRadius - debugAA, distance(p2, uv));\n        val += smoothstep(debugDotRadius + debugAA, debugDotRadius - debugAA, distance(p3, uv));\n    }\n    \n    return val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    float timeScale = .2f;\n    \n    uv.x += iTime * timeScale;\n    \n    uv.y += getNonPeriodic(uv.x) * .8;\n    \n    float gridDimension = .1f;\n    \n    float perlinValue = getPerlinValue(uv, gridDimension);\n    \n    perlinValue += getPerlinValue(uv + vec2(sin(iTime * .1f)), gridDimension * 10.f);\n    perlinValue += getPerlinValue(uv + vec2(sin(iTime * .1f)), gridDimension * .8f);\n    perlinValue += getPerlinValue(uv + vec2(cos(iTime * .3f)), gridDimension * 2.f);\n    perlinValue += getPerlinValue(uv + vec2(cos(iTime * .2)), gridDimension * .33f);\n    perlinValue += getPerlinValue(uv - vec2(iTime * .02f, -iTime * .02f), gridDimension * .5f);\n    \n    float clampedPerlin = clamp(perlinValue, 0., 1.);\n    \n    fragColor = vec4(getColor(clampedPerlin) * mix(PINK, WHITE, .5), 1.0);\n    fragColor = vec4(getMixedColor(GREEN * .8, BLUE, CYAN, WHITE, clampedPerlin) * mix(YELLOW, WHITE, .5), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lyGW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[383, 429, 449, 449, 515], [517, 517, 551, 551, 771], [773, 773, 807, 807, 864], [866, 866, 899, 899, 1655], [1657, 1657, 1684, 1684, 2188], [2190, 2190, 2274, 2274, 2795], [2797, 2797, 2877, 2877, 2997], [2999, 2999, 3051, 3051, 4885], [4887, 4887, 4944, 4944, 5940]], "test": "untested"}
{"id": "Nty3D1", "name": "DBcostas1= 141 Costas Arrays", "author": "ollj", "description": "move iMouse.xy to scroll through a database of 141 small costas arrays of lengths [7,11,13,17,19,23,29,31] ==pattern-free-sequences\nimouse.y=size (primes only)\niMouse.x=seed (nth costas attay of size)\ndarker area is just repeating the brighter area", "tags": ["dither", "primes", "costas", "costasarray", "patternfree"], "likes": 4, "viewed": 383, "published": 3, "date": "1637591707", "time_retrieved": "2024-07-30T18:46:46.617522", "image_code": "#define speed 15.\n\nvoid mainImage(out vec4 O, vec2 u\n){\n ;int l=int(8.*iMouse.y/iResolution.y)\n ;int seed=int(float(getSeedNums(l))*iMouse.x/iResolution.x)\n ;int period=getPeriod(l)\n ;float fleriod=float(period+1)\n ;if(true//u.x+iResolution.y*.1<iResolution.y\n ){\n  ;u.x*=2.\n  ;u=floor(u*(fleriod-1.)/iResolution.xy)\n  ;float c=costas(u.x,u.y,period,seed)\n  ;if(c==0.&&int(u.x)<period)c=.3\n  ;O=vec4(c,c,c,1.0)\n ;}else O=vec4(.5,0,1,1)//purple border\n ;}", "image_inputs": [], "common_code": "//parent: https://www.shadertoy.com/view/tdjfzR\n/*\ncostas array is pattern free\nIn theory ideal for dithering\nThe greyscaling gradient is BASIC, and can easily be more distorted\n,by adding any ;u.x+=u.y*b; b!=0 offset\n*/\n\n\n//above is for costas3() (small arrays, manually calculated with mod)\n//but this dies not cover all knoen costas arrays of their size.\n//below is for small prime costas arrays, and it is known that these are all of them:\n\nint rema(int v,int d//return longDivisionRemainder of max(v,0)/abs(d)\n){//d=abs(d)           //because mod(v,d) is ambiguous for negative inputs. (d is always >0 in this shader)\n ;if(v<0)return 0    //v=max(v,0) because mod() is ambiguous for negative inputs.\n ;if(v>d-1)return v%d //slowest part, we want this case to be rare. (ensures that v>d-1)\n ;return v;}\n\nint costas7(int p,int s){p=rema(p,7);s=rema(s,31);switch(s){\ncase  0:{int[7] a=int[7](1,2,6,4,7,3,5);return a[p];}break;\ncase  1:{int[7] a=int[7](1,2,6,4,7,3,5);return a[p];}break;\ncase  2:{int[7] a=int[7](1,2,7,4,6,5,3);return a[p];}break;\ncase  3:{int[7] a=int[7](1,2,7,5,4,6,3);return a[p];}break;\ncase  4:{int[7] a=int[7](1,3,6,2,7,4,5);return a[p];}break;\ncase  5:{int[7] a=int[7](1,3,6,2,7,5,4);return a[p];}break;\ncase  6:{int[7] a=int[7](1,3,7,6,4,5,2);return a[p];}break;\ncase  7:{int[7] a=int[7](1,4,5,3,7,6,2);return a[p];}break;\ncase  8:{int[7] a=int[7](1,4,5,7,2,6,3);return a[p];}break;\ncase  9:{int[7] a=int[7](1,4,6,5,3,7,2);return a[p];}break;\ncase 10:{int[7] a=int[7](1,5,3,6,7,2,4);return a[p];}break;\ncase 11:{int[7] a=int[7](1,5,7,6,3,4,2);return a[p];}break;\ncase 12:{int[7] a=int[7](1,6,5,7,3,4,2);return a[p];}break;\ncase 13:{int[7] a=int[7](1,7,3,4,6,5,2);return a[p];}break;\ncase 14:{int[7] a=int[7](2,1,5,7,3,6,4);return a[p];}break;\ncase 15:{int[7] a=int[7](2,1,6,4,7,3,5);return a[p];}break;\ncase 16:{int[7] a=int[7](2,3,5,1,7,6,4);return a[p];}break;\ncase 17:{int[7] a=int[7](2,4,3,6,7,1,5);return a[p];}break;\ncase 18:{int[7] a=int[7](2,4,5,1,7,6,3);return a[p];}break;\ncase 19:{int[7] a=int[7](2,4,7,3,1,6,5);return a[p];}break;\ncase 20:{int[7] a=int[7](2,5,1,6,7,4,3);return a[p];}break;\ncase 21:{int[7] a=int[7](2,5,1,7,6,3,4);return a[p];}break;\ncase 22:{int[7] a=int[7](2,5,6,1,3,7,4);return a[p];}break;\ncase 23:{int[7] a=int[7](2,5,6,4,1,7,3);return a[p];}break;\ncase 24:{int[7] a=int[7](2,5,7,1,6,3,4);return a[p];}break;\ncase 25:{int[7] a=int[7](2,5,7,1,6,4,3);return a[p];}break;\ncase 26:{int[7] a=int[7](2,6,1,3,4,7,5);return a[p];}break;\ncase 27:{int[7] a=int[7](2,6,7,1,4,3,5);return a[p];}break;\ncase 28:{int[7] a=int[7](3,2,5,7,1,6,4);return a[p];}break;\ncase 29:{int[7] a=int[7](3,4,1,7,6,2,5);return a[p];}break;\ncase 30:{int[7] a=int[7](3,6,1,7,5,2,4);return a[p];}break;}return 0;}\nint costas11(int p,int s){p=rema(p,11);s=rema(s,32);switch(s){\ncase  0:{int[11] a=int[11](1,3,7,2,5,11,10,8,4,9,6);return a[p];}break;\ncase  1:{int[11] a=int[11](1,4,3,9,7,8,10,5,2,6,11);return a[p];}break;\ncase  2:{int[11] a=int[11](1,4,11,6,5,3,9,2,7,8,10);return a[p];}break;\ncase  3:{int[11] a=int[11](1,5,4,7,9,3,10,11,8,6,2);return a[p];}break;\ncase  4:{int[11] a=int[11](1,5,6,9,4,11,10,8,2,7,3);return a[p];}break;\ncase  5:{int[11] a=int[11](1,5,6,11,4,10,8,7,2,9,3);return a[p];}break;\ncase  6:{int[11] a=int[11](1,5,7,10,9,2,8,6,3,4,11);return a[p];}break;\ncase  7:{int[11] a=int[11](1,6,4,10,3,2,11,7,8,5,9);return a[p];}break;\ncase  8:{int[11] a=int[11](1,6,8,9,4,10,3,7,5,2,11);return a[p];}break;\ncase  9:{int[11] a=int[11](1,7,5,8,10,4,9,6,2,3,11);return a[p];}break;\ncase 10:{int[11] a=int[11](1,7,6,9,5,3,8,10,4,11,2);return a[p];}break;\ncase 11:{int[11] a=int[11](1,7,8,5,9,11,4,3,6,2,10);return a[p];}break;\ncase 12:{int[11] a=int[11](1,7,8,10,3,11,5,4,2,9,6);return a[p];}break;\ncase 13:{int[11] a=int[11](1,7,8,10,6,11,5,3,2,9,4);return a[p];}break;\ncase 14:{int[11] a=int[11](1,7,11,6,8,4,2,5,10,9,3);return a[p];}break;\ncase 15:{int[11] a=int[11](1,8,7,10,6,4,9,11,5,2,3);return a[p];}break;\ncase 16:{int[11] a=int[11](1,8,10,11,6,9,5,3,2,7,4);return a[p];}break;\ncase 17:{int[11] a=int[11](1,9,6,11,10,8,4,7,2,3,5);return a[p];}break;\ncase 18:{int[11] a=int[11](1,9,10,7,5,11,4,3,6,8,2);return a[p];}break;\ncase 19:{int[11] a=int[11](1,10,4,3,8,11,9,5,7,2,6);return a[p];}break;\ncase 20:{int[11] a=int[11](2,4,11,7,5,6,9,1,10,3,8);return a[p];}break;\ncase 21:{int[11] a=int[11](2,5,9,6,1,11,7,8,10,4,3);return a[p];}break;\ncase 22:{int[11] a=int[11](2,6,5,8,10,4,11,1,9,7,3);return a[p];}break;\ncase 23:{int[11] a=int[11](2,7,9,3,10,11,8,6,1,5,4);return a[p];}break;\ncase 24:{int[11] a=int[11](2,9,8,10,6,1,11,4,5,3,7);return a[p];}break;\ncase 25:{int[11] a=int[11](3,2,5,9,6,1,11,7,8,10,4);return a[p];}break;\ncase 26:{int[11] a=int[11](3,4,1,9,8,11,7,5,10,2,6);return a[p];}break;\ncase 27:{int[11] a=int[11](3,6,5,1,10,11,8,2,4,9,7);return a[p];}break;\ncase 28:{int[11] a=int[11](3,7,2,8,10,1,4,11,9,6,5);return a[p];}break;\ncase 29:{int[11] a=int[11](3,7,2,11,8,9,5,10,1,4,6);return a[p];}break;\ncase 30:{int[11] a=int[11](3,10,1,9,6,5,7,11,4,2,8);return a[p];}break;\ncase 31:{int[11] a=int[11](4,6,7,10,1,5,2,11,9,3,8);return a[p];}break;}return 0;}\nint costas13(int p,int s){p=rema(p,13);s=rema(s,14);switch(s){\ncase  0:{int[13] a=int[13](1,2,9,6,11,7,5,4,10,13,8,12,3);return a[p];}break;\ncase  1:{int[13] a=int[13](1,4,8,13,3,10,9,11,7,2,12,5,6);return a[p];}break;\ncase  2:{int[13] a=int[13](1,5,12,9,7,8,4,10,2,13,3,6,11);return a[p];}break;\ncase  3:{int[13] a=int[13](1,8,5,10,6,4,3,9,12,7,11,13,2);return a[p];}break;\ncase  4:{int[13] a=int[13](1,8,9,12,10,5,13,7,11,4,6,3,2);return a[p];}break;\ncase  5:{int[13] a=int[13](1,8,11,6,10,12,13,7,4,9,5,3,2);return a[p];}break;\ncase  6:{int[13] a=int[13](1,10,3,9,6,5,7,12,4,2,13,8,11);return a[p];}break;\ncase  7:{int[13] a=int[13](1,12,5,6,4,8,13,3,10,9,11,7,2);return a[p];}break;\ncase  8:{int[13] a=int[13](2,1,8,9,12,10,5,13,7,11,4,6,3);return a[p];}break;\ncase  9:{int[13] a=int[13](2,5,12,11,13,9,4,1,7,8,6,10,3);return a[p];}break;\ncase 10:{int[13] a=int[13](2,9,6,11,7,5,4,10,13,8,12,1,3);return a[p];}break;\ncase 11:{int[13] a=int[13](2,11,10,12,8,3,13,6,7,5,9,1,4);return a[p];}break;\ncase 12:{int[13] a=int[13](2,12,10,11,4,1,9,5,7,6,13,3,8);return a[p];}break;\ncase 13:{int[13] a=int[13](3,11,6,4,7,8,13,2,1,10,12,5,9);return a[p];}break;;}return 0;}\nint costas17(int p,int s){p=rema(p,17);s=rema(s,24);switch(s){\ncase  0:{int[17] a=int[17](1,3,7,15,12,6,13,8,17,16,14,10,2,5,11,4,9);return a[p];}break;\ncase  1:{int[17] a=int[17](1,5,11,9,4,17,7,16,13,14,8,10,15,2,12,3,6);return a[p];}break;\ncase  2:{int[17] a=int[17](1,7,15,11,8,10,2,5,17,6,4,13,12,16,3,14,9);return a[p];}break;\ncase  3:{int[17] a=int[17](1,10,11,14,6,16,12,17,15,9,8,5,13,3,7,2,4);return a[p];}break;\ncase  4:{int[17] a=int[17](1,10,12,9,14,5,11,15,16,8,7,3,13,6,17,4,2);return a[p];}break;\ncase  5:{int[17] a=int[17](1,10,13,17,11,3,15,14,7,9,6,2,8,16,4,5,12);return a[p];}break;\ncase  6:{int[17] a=int[17](1,11,15,7,12,13,16,6,3,5,14,10,8,2,9,4,17);return a[p];}break;\ncase  7:{int[17] a=int[17](1,12,14,15,6,16,11,4,7,3,9,13,2,10,8,5,17);return a[p];}break;\ncase  8:{int[17] a=int[17](2,1,15,7,5,11,4,16,13,17,6,14,9,12,3,8,10);return a[p];}break;\ncase  9:{int[17] a=int[17](2,6,3,13,14,1,9,5,11,4,7,16,10,8,15,17,12);return a[p];}break;\ncase 10:{int[17] a=int[17](2,8,7,4,14,6,1,5,17,15,9,10,13,3,11,16,12);return a[p];}break;\ncase 11:{int[17] a=int[17](2,11,8,6,16,17,12,3,14,10,13,15,5,4,9,1,7);return a[p];}break;\ncase 12:{int[17] a=int[17](2,12,8,13,11,5,4,1,9,16,3,15,17,6,7,10,14);return a[p];}break;\ncase 13:{int[17] a=int[17](2,13,3,16,11,9,15,14,17,8,1,5,10,12,6,7,4);return a[p];}break;\ncase 14:{int[17] a=int[17](2,13,4,16,17,10,8,5,9,15,7,12,11,1,3,6,14);return a[p];}break;\ncase 15:{int[17] a=int[17](2,15,13,10,14,3,12,17,16,6,8,11,7,1,9,4,5);return a[p];}break;\ncase 16:{int[17] a=int[17](2,16,15,6,9,10,12,7,17,14,8,13,1,5,3,11,4);return a[p];}break;\ncase 17:{int[17] a=int[17](3,7,13,11,6,2,9,1,15,16,10,12,17,4,14,5,8);return a[p];}break;\ncase 18:{int[17] a=int[17](3,12,6,2,17,9,10,14,4,11,16,13,15,1,7,5,8);return a[p];}break;\ncase 19:{int[17] a=int[17](3,12,9,7,17,1,13,4,15,11,14,16,6,5,10,2,8);return a[p];}break;\ncase 20:{int[17] a=int[17](4,3,7,10,17,8,6,14,1,15,16,12,9,2,11,13,5);return a[p];}break;\ncase 21:{int[17] a=int[17](4,5,15,17,7,13,12,3,16,2,14,9,1,6,10,8,11);return a[p];}break;\ncase 22:{int[17] a=int[17](4,12,15,17,10,11,9,1,13,8,5,14,2,16,3,7,6);return a[p];}break;\ncase 23:{int[17] a=int[17](6,13,3,4,14,8,17,2,1,7,9,5,16,11,15,12,10);return a[p];}break;;}return 0;}\nint costas19(int p,int s){p=rema(p,19);s=rema(s,2);switch(s){\ncase 0:{int[19] a=int[19](1,12,16,18,19,10,15,8,14,17,9,5,3,2,11,6,13,7,4);return a[p];}break;\ncase 1:{int[19] a=int[19](1,13,12,18,11,15,17,7,10,5,14,19,16,8,6,2,9,3,4);return a[p];}break;}return 0;}\n\nint costas23(int p,int s){p=rema(p,23);s=rema(s,14);switch(s){\ncase  0:{int[23] a=int[23](1,3,2,14,8,11,21,16,7,23,15,19,17,18,6,12,9,22,4,13,20,5,10);return a[p];}break;\ncase  1:{int[23] a=int[23](1,10,18,7,21,12,14,13,8,11,4,20,16,6,23,17,5,9,15,22,19,2,3);return a[p];}break;\ncase  2:{int[23] a=int[23](1,11,22,21,13,18,15,10,16,6,19,5,12,14,17,4,2,20,8,9,3,7,23);return a[p];}break;\ncase  3:{int[23] a=int[23](1,14,12,20,10,13,18,17,8,4,11,5,16,22,15,19,6,7,2,21,9,23,3);return a[p];}break;\ncase  4:{int[23] a=int[23](1,15,10,4,5,12,21,23,11,3,9,6,14,13,2,19,22,18,16,20,7,17,8);return a[p];}break;\ncase  5:{int[23] a=int[23](1,16,13,11,17,8,19,22,12,7,21,15,20,5,9,18,14,2,10,3,4,6,23);return a[p];}break;\ncase  6:{int[23] a=int[23](1,17,15,23,13,16,21,20,11,7,14,8,19,3,18,22,9,10,5,2,12,4,6);return a[p];}break;\ncase  7:{int[23] a=int[23](2,8,6,11,12,3,10,18,15,5,16,4,7,21,14,23,22,17,19,13,9,1,20);return a[p];}break;\ncase  8:{int[23] a=int[23](2,9,14,4,10,12,16,17,1,21,8,18,7,19,22,13,11,6,3,20,5,23,15);return a[p];}break;\ncase  9:{int[23] a=int[23](2,19,20,17,3,22,11,21,14,12,18,23,8,7,10,1,5,16,6,13,15,9,4);return a[p];}break;\ncase 10:{int[23] a=int[23](2,21,14,4,10,12,16,5,13,9,8,18,19,7,22,1,23,6,15,20,17,11,3);return a[p];}break;\ncase 11:{int[23] a=int[23](3,19,1,4,15,6,7,17,14,23,11,18,16,9,5,13,8,12,2,20,22,21,10);return a[p];}break;\ncase 12:{int[23] a=int[23](5,3,2,20,1,12,9,19,7,15,21,6,22,17,10,23,14,18,8,4,11,13,16);return a[p];}break;\ncase 13:{int[23] a=int[23](8,5,19,20,16,18,22,7,2,1,14,6,21,15,23,11,9,12,17,4,10,3,13);return a[p];}break;;}return 0;}\nint costas29(int p,int s){p=rema(p,29);s=rema(s,23);switch(s){\ncase  0:{int[29] a=int[29](1,6,3,28,13,9,7,14,26,25,27,10,19,5,15,18,29,4,22,12,20,2,24,17,21,16,8,23,11);return a[p];}break;\ncase  1:{int[29] a=int[29](1,10,3,22,21,23,7,28,14,17,12,9,16,24,15,20,26,11,29,8,4,27,25,5,19,13,2,6,18);return a[p];}break;\ncase  2:{int[29] a=int[29](1,11,3,25,23,4,7,21,20,22,16,29,9,6,15,5,12,17,10,26,14,18,2,8,28,24,19,27,13);return a[p];}break;\ncase  3:{int[29] a=int[29](1,12,29,3,25,14,26,19,28,27,18,24,7,4,6,11,21,15,16,2,10,8,22,17,5,20,23,13,9);return a[p];}break;\ncase  4:{int[29] a=int[29](1,17,22,13,19,23,24,27,11,8,25,15,28,7,18,6,26,12,21,3,5,20,16,14,9,2,10,4,29);return a[p];}break;\ncase  5:{int[29] a=int[29](1,20,14,16,25,22,23,13,26,12,7,28,21,4,29,11,17,15,6,9,8,18,5,19,24,3,10,27,2);return a[p];}break;\ncase  6:{int[29] a=int[29](1,22,21,17,20,28,16,10,19,12,27,25,15,4,9,23,18,29,11,13,26,5,24,2,14,6,3,7,8);return a[p];}break;\ncase  7:{int[29] a=int[29](1,25,22,23,13,26,12,7,28,21,4,29,11,17,15,6,9,8,18,5,19,24,3,10,27,2,20,14,16);return a[p];}break;\ncase  8:{int[29] a=int[29](2,1,8,12,25,15,18,3,13,22,17,4,9,28,6,29,11,7,21,27,19,10,26,24,5,23,20,14,16);return a[p];}break;\ncase  9:{int[29] a=int[29](2,8,26,18,25,15,16,19,28,24,12,7,23,9,29,27,21,3,11,4,14,13,10,1,5,17,22,6,20);return a[p];}break;\ncase 10:{int[29] a=int[29](2,23,1,7,5,19,29,24,20,9,3,15,22,10,12,21,14,18,17,4,26,11,27,28,25,8,13,16,6);return a[p];}break;\ncase 11:{int[29] a=int[29](2,28,10,1,25,18,22,20,23,9,27,29,7,13,12,26,3,8,19,14,11,21,6,15,5,24,16,17,4);return a[p];}break;\ncase 12:{int[29] a=int[29](3,9,20,17,25,12,27,13,7,16,28,1,24,29,18,6,8,22,26,21,19,2,23,15,5,4,14,10,11);return a[p];}break;\ncase 13:{int[29] a=int[29](3,11,1,10,25,19,14,16,20,4,2,15,27,7,12,8,29,18,6,9,26,23,22,28,5,21,13,24,17);return a[p];}break;\ncase 14:{int[29] a=int[29](3,21,23,22,8,15,26,6,16,11,28,5,2,18,10,14,12,13,27,20,9,29,19,24,7,1,4,17,25);return a[p];}break;\ncase 15:{int[29] a=int[29](4,12,25,28,22,5,10,29,20,9,2,16,17,15,19,11,27,24,1,18,13,23,3,14,21,7,6,8,26);return a[p];}break;\ncase 16:{int[29] a=int[29](4,26,20,17,5,6,14,10,1,3,9,13,29,11,24,22,21,16,23,28,7,27,12,15,25,18,2,19,8);return a[p];}break;\ncase 17:{int[29] a=int[29](6,19,12,20,25,22,18,8,26,17,1,29,28,9,24,13,14,16,2,11,23,3,7,10,5,27,4,21,15);return a[p];}break;\ncase 18:{int[29] a=int[29](6,26,23,28,5,8,27,1,16,14,7,18,4,21,12,20,2,15,3,9,10,24,19,29,25,17,11,13,22);return a[p];}break;\ncase 19:{int[29] a=int[29](7,13,2,17,5,27,28,21,8,6,20,15,19,22,1,24,18,29,14,26,4,3,10,23,25,11,16,12,9);return a[p];}break;\ncase 20:{int[29] a=int[29](7,20,28,8,25,15,1,4,23,27,22,14,16,12,6,13,18,17,26,2,29,11,9,24,5,19,10,3,21);return a[p];}break;\ncase 21:{int[29] a=int[29](8,22,10,19,25,12,28,20,17,21,3,11,13,7,18,14,27,2,1,26,29,9,24,15,5,6,4,23,16);return a[p];}break;\ncase 22:{int[29] a=int[29](10,27,28,8,5,3,12,18,22,4,23,15,20,13,29,19,2,1,21,24,26,17,11,7,25,6,14,9,16);return a[p];}break;;}return 0;}\n//costas31 is almost useless, because opengl fails at a%31, and because \n//only 1 costas array of length 31 exists\nint costas31(int p,int s){p=rema(p,29);\n;int[29] a=int[29](10,27,28,8,5,3,12,18,22,4,23,15,20,13,29,19,2,1,21,24,26,17,11,7,25,6,14,9,16);return a[p];}\n\nint getPeriod(int l){\n ;l=rema(l,8)\n ;int[8] a=int[8](7,11,13,17,19,23,29,31);//small primes\n ;return a[l];}\n//there are 31 costas arrays of length 7\n//there are 32 costas arrays of length 11\n//there are 14 costas arrays of length 13\n//there are 24 costas arrays of length 17\n//there are  2 costas arrays of length 19\n//there are 18 costas arrays of length 23\n//there are 23 costas arrays of length 29\n//there are  1 costas arrays of length 31\nint getSeedNums(int l){\n ;l=rema(l,8)\n ;int[8] a=int[8](31,32,14,24,2,18,23,1);//small primes\n ;return a[l];}\n\n//return value at position p of static costas array number s of length l\n//p=Position(0..l-1),s=Seed, Length[short..long]\nint costasP(int p,int s,int l\n){switch(l\n ){case 7:return costas7 (p,s);break;//works\n  case 11:return costas11(p,s);break;//works\n  case 13:return costas13(p,s);break;//works\n  case 17:return costas17(p,s);break;//fails\n  case 19:return costas19(p,s);break;//\n  case 23:return costas23(p,s);break;//\n  case 29:return costas29(p,s);break;//\n  case 31:return costas31(p,s);break;}//works\n  //return 0;//should never happen\n ;}\n\n \nfloat costas(float x,float y,int l,int seed\n){\n ;int a=costasP(int(x),seed,l)\n ;if (a==int(y)+1)return 1.;return 0.;\n ;}\n \n /*\n #define speed 15.\n\nvoid mainImage(out vec4 O, vec2 u\n){\n ;int l=int(8.*iMouse.y/iResolution.y)\n ;int seed=int(float(getSeedNums(l))*iMouse.x/iResolution.x)\n ;int period=getPeriod(l)\n ;float fleriod=float(period+1)\n ;if(true//u.x+iResolution.y*.1<iResolution.y\n ){\n  ;u.x*=2.\n  ;u=floor(u*(fleriod-1.)/iResolution.xy)\n  ;float c=costas(u.x,u.y,period,seed)\n  ;if(c==0.&&int(u.x)<period)c=.3\n  ;O=vec4(c,c,c,1.0)\n ;}else O=vec4(.5,0,1,1)//purple border\n ;}\n */", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nty3D1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 55, 55, 454]], "test": "untested"}
{"id": "slG3Dh", "name": "Beving (2021)", "author": "DrNoob", "description": "After the video for Joep Beving's \"Sinfonia (After Bach, BWV 248)\": https://youtu.be/mJa6QbJfvHk", "tags": ["noise", "rain", "reproduction"], "likes": 13, "viewed": 310, "published": 3, "date": "1637589288", "time_retrieved": "2024-07-30T18:46:47.392450", "image_code": "// Author: Thomas Stehle\n// Title: Beving (2021)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// After the video for Joep Beving's \"Sinfonia (After Bach,\n// BWV 248)\": https://youtu.be/mJa6QbJfvHk\n//\n// Try the shader in fullscreen mode. Would make a nice screen\n// saver.\n\nconst float PI = 3.14159;\n\nconst vec3 COLOR_BG = vec3( 17,  26,  46) / 255.0;\nconst vec3 COLOR_FG = vec3(121, 133, 156) / 255.0;\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash(in float p) {\n    p = fract(p * 0.011);\n    p *= p + 7.5;\n    p *= p + p;\n    return fract(p);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash(in vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * 0.13);\n    p3 += dot(p3, p3.yzx + 3.333);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash(in vec3 p) {\n    vec3 q = fract(p * 0.1031);\n    q += dot(q, q.yzx + 33.33);\n    return fract((q.x + q.y) * q.z);\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat vnoise(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Four corners in 2D of a tile\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Smooth interpolation (smoothstep without clamping)\n    vec2 u = f*f * (3.0 - 2.0*f);\n\n    // Mix 4 corners\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// https://github.com/patriciogonzalezvivo/lygia\nvec3 brightness_contrast(in vec3 color, in float brightness, in float contrast ) {\n    return (color - 0.5) * contrast + 0.5 + brightness;\n}\n\nfloat stripes(in vec2 p, in float nstripes) {\n    // Stripe config\n    vec2 sc = vec2(nstripes, 1.0) * p;\n    vec2 id = floor(sc);\n    vec2 cc = fract(sc);\n    \n    // Random variables\n    float r1 = hash(id.x);\n    float r2 = hash(id.x * 13.37);\n    float r3 = hash(id.x * 47.11);\n    float r4 = hash(id.x * 73.23);\n    \n    // Horizontal variation\n    float freq = nstripes * PI;\n    float f = smoothstep(1.0, 0.0, sin(freq * p.x));\n    \n    // Vertical variation\n    float t = sin(0.25 * iTime + 10.0 * r1);   // Randomized time offset\n    float dt = cos(0.25 * iTime + 10.0 * r1);  // Derivative of time offset\n    float len = 0.9 * r2;                      // Randomized length\n    float slt = -0.01 + 0.02 * r3;             // Randomized slant\n    float ext = 0.2 * t * r4;                  // Randomized extent\n    f *= step(len + slt * cc.x - ext, cc.y);\n    \n    // Fade out when receeding\n    f *= smoothstep(-0.1, 0.5, dt);\n    \n    // Apply noise\n    f *= 0.5 + 0.5 * vnoise(10.0 * (cc + 0.2 * t));\n\n    return f;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize input coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Background\n    vec3 col = mix(COLOR_BG, brightness_contrast(COLOR_FG, -0.3, 1.25), 1.0 - length(uv - vec2(0.5, 1.0)));\n    \n    // Stripe layers\n    col = mix(col, COLOR_FG, stripes(uv, 200.0));\n    col = mix(col, brightness_contrast(COLOR_FG, -0.1, 1.0), stripes(uv + vec2(0.123, 0.0), 250.0));\n    col = mix(col, brightness_contrast(COLOR_FG, -0.2, 1.0), stripes(uv + vec2(0.456, 0.0), 150.0));\n    col = mix(col, brightness_contrast(COLOR_FG, -0.3, 1.0), stripes(uv + vec2(0.789, 0.0), 300.0));\n    \n    // Add layer of animated white noise\n    col += 0.1 * vec3(hash(vec3(fragCoord.xy, fract(0.001 * iTime))));\n    \n    // Vignetting\n    float vig = length(uv - vec2(0.5)) * 0.85;\n    vig = vig * vig + 1.0;\n    col *= 1.0 / (vig * vig);\n    \n    // Final result\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slG3Dh.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[448, 489, 513, 513, 596], [598, 639, 662, 662, 780], [782, 782, 805, 805, 908], [910, 951, 976, 976, 1421], [1423, 1472, 1554, 1554, 1612], [1614, 1614, 1659, 1680, 2641], [2643, 2643, 2698, 2733, 3591]], "test": "untested"}
{"id": "ftG3D1", "name": "KIFS City", "author": "leon", "description": "example of how to go to fractal city", "tags": ["kifs", "city"], "likes": 37, "viewed": 3218, "published": 3, "date": "1637579910", "time_retrieved": "2024-07-30T18:46:48.249159", "image_code": "\n// KIFS City by leon denise 2021/11/22\n// example of how to go to fractal city\n// which is a cubic kaleidoscopic shape carving volume\n// using code from Inigo Quilez, LJ, Fabrice Neyret and many others\n// licensed under hippie love conspiracy\n\nmat2 rot (float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\nfloat map (vec3 p)\n{\n  float scene = 100.;\n  float t = floor(iTime/5.);\n  float falloff = 1.0;\n  for (float index = 0.; index < 8.; ++index)\n  {\n    p.xz *= rot(t/falloff);\n    p = abs(p)-0.5*falloff;\n    scene = min(scene, max(p.x, max(p.y, p.z)));\n    falloff /= 1.8;\n  }\n  return -scene;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2.*(fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n  vec3 pos = vec3(0);\n  vec3 ray = normalize(vec3(uv, 1));\n  float shade = 0.;\n  const float count = 30.;\n  for (float index = count; index > 0.; --index)\n  {\n    float dist = map(pos);\n    if (dist < 0.001)\n    {\n      shade = index/count;\n      break;\n    }\n    pos += ray * dist;\n  }\n  fragColor = vec4(shade);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftG3D1.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[245, 245, 265, 265, 310], [312, 312, 332, 332, 604], [606, 606, 663, 663, 1043]], "test": "untested"}
{"id": "stKGDz", "name": "Weird Tendrils", "author": "SnoopethDuckDuck", "description": "e", "tags": ["e"], "likes": 7, "viewed": 299, "published": 3, "date": "1637531705", "time_retrieved": "2024-07-30T18:46:49.091906", "image_code": "float thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\n#define pi 3.14159\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    uv.y += 0.08 * thc(2., 10. * mlength(uv) +\n    + iTime);\n    //uv.y += 0.01 * cos(100. * mlength(uv) + iTime);\n    float r = length(uv);\n    float a = atan(uv.y/uv.x);\n   \n    //uv = fract(uv / r);// + ths(1.,0.5 * iTime);\n   // uv = vec2(cos(0. * r + mlength(uv) + iTime),\n    //          sin(0. * a + mlength(uv) + iTime));\n    uv.x = r; // * 20.;\n    uv.y = a * 10.;\n\n    float time = iTime;\n\n    float sc = 0.5;\n    vec2 ipos = floor(sc * uv) + 0.5;\n    vec2 fpos = fract(sc * uv) - 0.5;\n    \n    float d = 0.1 * (0.5 + 0.5 * cos(iTime)) + length(fpos);\n    float s = smoothstep(-0.1,0.1,0.5-d) - smoothstep(-0.1,0.1,0.42 - d);\n    s *= (0.5 + 0.5 * cos(uv.x + uv.y - iTime)) * h21(ipos + floor(length(ipos) * 100. + 0.2 * time));\n\n    vec3 col = 2. * s * pal(time + 10. * r + 0.5 * s, vec3(1.), vec3(1.), vec3(1.), vec3(0.,0.33,0.66));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stKGDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 70], [72, 72, 101, 101, 142], [144, 144, 212, 212, 255], [257, 257, 277, 277, 352], [354, 354, 378, 378, 418], [440, 440, 497, 497, 1460]], "test": "untested"}
{"id": "slK3Wz", "name": "Vesica eye thing", "author": "SnoopethDuckDuck", "description": "kinda hacky and oversaturated but short code", "tags": ["e"], "likes": 9, "viewed": 252, "published": 3, "date": "1637531367", "time_retrieved": "2024-07-30T18:46:49.958589", "image_code": "float thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    float r = length(uv);\n    //float a = atan(uv.y, uv.x);\n    //uv = vec2(0.2 * cos(a + 0.2 * iTime),r);\n   \n    float k = 10. + 8. * thc(3., r + iTime);\n    float sc = 6. * ceil(k * fract(abs(uv.y) + r - 0.2 * iTime));\n    float d = length(floor(sc * uv) + 0.5)/sc;\n    float s = smoothstep(-1., 0.5, 0.1 + 0.5 * h21(uv));\n    \n    // 33333. is super hacky\n    vec3 col = 1.1 * s * pal(d * 33333. + r - iTime * 0.1, \n               vec3(1.), vec3(1.), vec3(1.), vec3(0.,0.33,0.66));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slK3Wz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 70], [72, 72, 140, 140, 183], [185, 185, 205, 205, 280], [282, 282, 339, 339, 919]], "test": "untested"}
{"id": "slVGWR", "name": "chromatic aberration study 101", "author": "morisil", "description": "Testing something out", "tags": ["chromaticaberration", "study", "depthoffield", "focus"], "likes": 5, "viewed": 323, "published": 3, "date": "1637516675", "time_retrieved": "2024-07-30T18:46:51.010776", "image_code": "// Fork of \"depth of field focus study 3\" by morisil. https://shadertoy.com/view/stdGRf\n// 2021-11-21 17:43:16\n\n// Fork of \"depth of field focus study 2\" by morisil. https://shadertoy.com/view/flc3zX\n// 2021-11-09 21:23:07\n\n// Fork of \"depth of field focus study\" by morisil. https://shadertoy.com/view/sld3zB\n// 2021-11-08 19:52:49\n\nconst float SHAPE_SIZE = .1;\nconst float CHROMATIC_ABBERATION = .02;\nconst float ITERATIONS = 20.;\nconst float INITIAL_LUMA = .3;\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n\nfloat getColorComponent(in vec2 st, in float modScale, in float blur) {\n    vec2 modSt = mod(st, 1. / modScale) * modScale * 2. - 1.;\n    float dist = length(modSt);\n    float angle = atan(modSt.x, modSt.y);\n    float shapeMap = smoothstep(SHAPE_SIZE + blur, SHAPE_SIZE - blur, (sin(st.x * 3.) + 1.) * .5);\n    return shapeMap;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st =\n        (2.* fragCoord - iResolution.xy)\n        / min(iResolution.x, iResolution.y);\n    st *= rotate2d(sin(iTime * .6) * .3);\n    st *= (sin(iTime * .3) + 2.) * .3;\n\n    float modScale = 1.;\n\n    vec3 color = vec3(0);\n    float luma = INITIAL_LUMA;\n    float blur = .2;\n    for (float i = 0.; i < ITERATIONS; i++) {\n        vec2 center = st + vec2(sin(iTime * .5), cos(iTime * .3));\n        //center += pow(length(center), 1.);\n        vec3 shapeColor = vec3(\n            getColorComponent(center - st * CHROMATIC_ABBERATION, modScale, blur),\n            getColorComponent(center, modScale, blur),\n            getColorComponent(center + st * CHROMATIC_ABBERATION, modScale, blur)        \n        ) * luma;\n        st *= 1.1;\n        st *= rotate2d(sin(iTime  * .05) * .3);\n        color += shapeColor;\n        color = clamp(color, 0., 1.);\n        if (color == vec3(1)) break;\n        luma *= .8;\n        blur *= .8;\n    }\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slVGWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[465, 465, 493, 493, 579], [582, 582, 653, 653, 911], [913, 913, 968, 968, 1943]], "test": "untested"}
{"id": "NlV3Wz", "name": "Distribution of Random funcs", "author": "iY0Yi", "description": "Distribution of Random functions.\nInspired by this shader.\n[url]https://www.shadertoy.com/view/4ssXRX[/url]", "tags": ["random", "hash", "distribution"], "likes": 19, "viewed": 438, "published": 3, "date": "1637515240", "time_retrieved": "2024-07-30T18:46:52.018083", "image_code": "// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat rndUni(vec2 p){\n    return hash12(p);\n}\n\nfloat rndAdd(vec2 p){\n    float a = hash12(p);\n    float b = hash12(p+1.);\n    return (a+b)*.5;\n}\n\nfloat rndMul1(vec2 p){\n    float a = hash12(p);\n    return (a*a*a);\n}\n\nfloat rndMul2(vec2 p){\n    float a = hash12(p);\n    float b = hash12(p+1.);\n    return (a*b);\n}\n\nfloat rndSqrt(vec2 p){\n    float a = hash12(p);\n    return sqrt(a);\n}\n\nfloat rndPow(vec2 p){\n    float a = hash12(p);\n    float b = hash12(p+1.);\n    //return pow(a, (1.+sin(iTime))*8.);\n    \n    return pow(rndMul2(p), .25);\n}\n\nfloat rndGauss(vec2 p) {\n    float a = hash12(p);\n    float b = hash12(p+1.);\n    float value =\n    sqrt(-2.*log(a)) *\n    sin(2.*acos(-1.) * b);\n    value = (value + 3.) / 6.;\n    return value;\n}\n\n\n#define drawHistgram(RND_TYPE) {\\\n    float maxth = ceil(uv.x*float(RESOLUTION))/float(RESOLUTION);\\\n    float minth = maxth-(1./float(RESOLUTION));\\\n    float cnt = 0.;\\\n    float t = fract( iTime );\\\n    for(int i = 0; i<MAX_SAMPLE; i++) {\\\n        float rnd = RND_TYPE(vec2(i,domain.x)+t);\\\n        if(rnd>=minth && rnd<maxth)cnt++;\\\n    }\\\n    cnt /= float(MAX_SAMPLE);\\\n    res = (cnt>uv.y/SCALE_Y) ? 1.: 0.;\\\n}\\\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    const int VARIATIONS = 7;\n    vec2 domain = vec2(iResolution.x/float(VARIATIONS), iResolution.y);\n    int id = int(floor(fragCoord.x/domain.x));\n    fragCoord.x = mod(fragCoord.x, domain.x);\n    vec2 uv = fragCoord/domain;\n    \n    float res = 0.;\n    const int MAX_SAMPLE = 3000;\n    const int RESOLUTION = 30;\n    const float SCALE_Y = 1.;\n    if(id==0) drawHistgram(rndUni);\n    if(id==1) drawHistgram(rndAdd);\n    if(id==2) drawHistgram(rndMul1);\n    if(id==3) drawHistgram(rndMul2);\n    if(id==4) drawHistgram(rndSqrt);\n    if(id==5) drawHistgram(rndPow);\n    if(id==6) drawHistgram(rndGauss);\n    //drawHistgram(rndGauss);\n    vec3 col = mix(vec3(0.102,0.102,0.102), vec3(.8, .77, .7), res);\n    col = max(col, vec3(.8, .77, .7)*.3* ((fragCoord.x>=domain.x-2.) ? vec3(1) : vec3(0)));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlV3Wz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 81, 102, 102, 219], [221, 221, 242, 242, 266], [268, 268, 289, 289, 365], [367, 367, 389, 389, 436], [438, 438, 460, 460, 533], [535, 535, 557, 557, 604], [606, 606, 627, 627, 761], [763, 763, 787, 787, 959], [1381, 1381, 1438, 1438, 2265]], "test": "untested"}
{"id": "ftKGWz", "name": "truchet on truchet", "author": "IWBTShyGuy", "description": "It's getting a little more complicated.", "tags": ["trunchet"], "likes": 34, "viewed": 591, "published": 3, "date": "1637505335", "time_retrieved": "2024-07-30T18:46:53.111160", "image_code": "// Copyright © 2021 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\n/* ---------------- 2D trachet ---------------- */\nconst float TILE_SIZE = 1.0 / 30.0;\n\n#define rotate2D(t) mat2(cos(t), sin(t), -sin(t), cos(t))\n\nconst float THICKNESS = 0.06;\nfloat tile0(in vec2 uv) {\n    float c0 = abs(1.0 / 6.0 - length(vec2(0.0, 0.5) - uv));\n    float c1 = abs(1.0 / 6.0 - length(vec2(1.0, 0.5) - uv));\n    float c2 = abs(uv.x - 1.0 / 3.0);\n    float c3 = abs(uv.x - 2.0 / 3.0);\n\n    return min(min(min(c0, c1), c2), c3);\n}\n\nfloat tile1(in vec2 uv) {\n    float c0 = abs(1.0 / 3.0 - length(uv));\n    float c1 = abs(1.0 / 3.0 - length(vec2(1, 0) - uv));\n    float c2 = abs(1.0 / 3.0 - length(vec2(0, 1) - uv));\n    float c3 = abs(1.0 / 3.0 - length(1.0 - uv));\n\n    return min(min(min(c0, c1), c2), c3);\n}\n\nfloat tile2(in vec2 uv) {\n    float c0 = abs(1.0 / 3.0 - length(uv));\n    float c1 = abs(2.0 / 3.0 - length(uv));\n    float c2 = abs(1.0 / 3.0 - length(1.0 - uv));\n    float c3 = abs(2.0 / 3.0 - length(1.0 - uv));\n\n    return min(min(min(c0, c1), c2), c3);\n}\n\nvoid trachet2D(out vec4 fragColor, in vec2 uv0, in float gen) {\n    vec2 uv = fract(uv0 / TILE_SIZE);\n    vec2 rand = hash22(floor((uv0 + gen) / TILE_SIZE) * 1.32);\n    float theta = floor(rand.x * 4.0) * PI / 2.0;\n    uv = rotate2D(theta) * (uv - 0.5) + 0.5;\n\n    float d = rand.y < 1.0 / 3.0 ? tile0(uv) :\n    rand.y < 2.0 / 3.0 ? tile1(uv) : tile2(uv);\n    float w = fwidth(d);\n    float c = smoothstep(w, -w, d - THICKNESS);\n\n    fragColor = vec4(c, c, c, 1);\n}\n\n/* ---------------- 3D trachet ---------------- */\nconst float FAR = 12.0;\n\n#define rotate3D(n, t) mat3( \\\n    cos(t) + n.x * n.x * (1.0 - cos(t)), \\\n    n.x * n.y * (1.0 - cos(t)) + n.z * sin(t), \\\n    n.z * n.x * (1.0 - cos(t)) - n.y * sin(t), \\\n    n.x * n.y * (1.0 - cos(t)) - n.z * sin(t), \\\n    cos(t) + n.y * n.y * (1.0 - cos(t)), \\\n    n.y * n.z * (1.0 - cos(t)) + n.x * sin(t), \\\n    n.z * n.x * (1.0 - cos(t)) + n.y * sin(t), \\\n    n.y * n.z * (1.0 - cos(t)) - n.x * sin(t), \\\n    cos(t) + n.z * n.z * (1.0 - cos(t))  \\\n)\n\nconst mat3 T0 = rotate3D(normalize(vec3(0, 1, -1)), PI);\nconst mat3 T1 = rotate3D(normalize(vec3(1, 0, 1)), PI);\nconst mat3 T2 = rotate3D(normalize(vec3(0, 1, 1)), PI);\n\n// hexahedron group\nconst mat3[] S = mat3[](\n    mat3(1, 0, 0, 0, 1, 0, 0, 0, 1),\n    T2,\n    T1,\n    T2 * T1,\n    T1 * T2,\n    T2 * T1 * T2,\n    T0,\n    T2 * T0,\n    T1 * T0,\n    T2 * T1 * T0,\n    T1 * T2 * T0,\n    T2 * T1 * T2 * T0,\n    T0 * T1,\n    T2 * T0 * T1,\n    T1 * T0 * T1,\n    T2 * T1 * T0 * T1,\n    T1 * T2 * T0 * T1,\n    T2 * T1 * T2 * T0 * T1,\n    T0 * T1 * T2,\n    T2 * T0 * T1 * T2,\n    T1 * T0 * T1 * T2,\n    T2 * T1 * T0 * T1 * T2,\n    T1 * T2 * T0 * T1 * T2,\n    T2 * T1 * T2 * T0 * T1 * T2\n);\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = abs(vec2(length(p.zx) - t.x, p.y)) - t.y;\n    return length(max(q, 0.0)) + min(max(q.x,q.y),0.0);\n}\n\nvec2 textureTorus(vec3 p, vec2 t) {\n    float a = length(p.zx) - t.x;\n    vec2 n = normalize(p.zx);\n    float u = asin(abs(n.y)) * 2.0 / PI;\n    float b = (1.0 + sign(abs(a) - t.y * 0.999)) * 0.5;\n    float v = (1.0 - b) * (1.0 + a / t.y) * 0.5\n        + b * (1.0 + p.y / t.y) * 0.5;\n    return vec2(u, v);\n}\n\nvec3 normalTorus(vec3 p, vec2 t) {\n    float a = length(p.zx) - t.x;\n    vec2 n = normalize(p.zx);\n    float b = (1.0 + sign(abs(a) - t.y * 0.999)) * 0.5;\n    return b * sign(a) * vec3(n.y, 0, n.x)\n        + (1.0 - b) * sign(p.y) * vec3(0, 1, 0);\n}\n\nfloat sdCylinder(vec3 p, float t) {\n    vec2 q = abs(p.xy - 0.5) - t;\n    return length(max(q, 0.0)) + min(max(q.x,q.y),0.0);\n}\n\nvec2 textureCylinder(vec3 p, float t) {\n    vec2 q = p.xy - 0.5;\n    float u = p.z;\n    float s = (1.0 + sign(abs(q.x) - t * 0.999)) * 0.5;\n    float v = s * (1.0 + q.y / t) * 0.5 + (1.0 - s) * (1.0 + q.x / t) * 0.5;\n    return vec2(u, v);\n}\n\nvec3 normalCylinder(vec3 p, float t) {\n    vec2 q = p.xy - 0.5;\n    t = (1.0 + sign(abs(q.x) - t * 0.999)) * 0.5;\n    return t * sign(q.x) * vec3(1, 0, 0)\n        + (1.0 - t) * sign(q.y) * vec3(0, 1, 0);\n}\n\nfloat sdist(in vec3 p, in vec3 q, out int shape, out uint index) {\n    float rand = hash13(floor(p + q));\n    index = uint(rand * 24.0);\n    p = fract(p);\n    p = S[index] * (p - 0.5) + 0.5;\n    float dist = sdTorus((p - vec3(0, 0, 0.5)).yzx, vec2(0.5, 0.05));\n    shape = 0;\n    float dist1 = sdTorus((p - vec3(1, 1, 0.5)).yzx, vec2(0.5, 0.05));\n    if (dist > dist1) {\n        dist = dist1;\n        shape = 1;\n    }\n    dist1 = sdCylinder(p, 0.05);\n    if (dist > dist1) {\n        dist = dist1;\n        shape = 2;\n    }\n    return dist;\n}\n\nvoid calcTextureNormal(in vec3 p, in vec3 q, in int shape, in uint index, out vec2 uv, out vec3 normal) {\n    float rand = hash13(floor(p + q));\n    index = uint(rand * 24.0);\n    p = fract(p);\n    p = S[index] * (p - 0.5) + 0.5;\n    if (shape == 0) {\n        uv = textureTorus((p - vec3(0, 0, 0.5)).yzx, vec2(0.5, 0.05));\n        normal = normalTorus((p - vec3(0, 0, 0.5)).yzx, vec2(0.5, 0.05)).zxy;\n    } else if (shape == 1) {\n        uv = textureTorus((p - vec3(1, 1, 0.5)).yzx, vec2(0.5, 0.05));\n        normal = normalTorus((p - vec3(1, 1, 0.5)).yzx, vec2(0.5, 0.05)).zxy;\n    } else {\n        uv = textureCylinder(p, 0.05);\n        normal = normalCylinder(p, 0.05);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 theta = vec2(0.15, 0.25) * iTime;\n    theta.y = sin(theta.y);\n    Camera camera = newCamera(\n        vec3(0, 0, -iTime * 0.5),\n        vec3(cos(theta.x) * cos(theta.y), sin(theta.y), sin(theta.x) * cos(theta.y)),\n        vec3(0, 1, 0),\n        PI / 4.0,\n        iResolution.x / iResolution.y\n    );\n    Ray ray = cameraRay(camera, fragCoord / iResolution.xy);\n\n    vec3 p = fract(ray.origin);\n    vec3 q = floor(ray.origin);\n    int shape;\n    uint index;\n    for (int i = 0; i < 100; i++) {\n        float dist = sdist(p, q, shape, index);\n        if (dist < 0.00001) break;\n        p += dist * ray.direction;\n    }\n    \n    float c = 0.0;\n    float rDist = length(p - fract(ray.origin));\n    vec4 trachet = vec4(0);\n    if (rDist < FAR) {\n        vec2 uv;\n        vec3 normal;\n        calcTextureNormal(p, q, shape, index, uv, normal);\n        normal = transpose(S[index]) * normal;\n        c = -dot(normal, ray.direction);\n        vec3 q0 = mod(floor(p + q) * 13.0, 3000.0);\n        trachet2D(trachet, vec2(uv.x, uv.y / 10.0), q0.x + q0.y * 2.0 + q0.z * 3.0);\n        \n        // fog by Shane (comment)\n        c /= (1. + rDist*rDist*.5);\n        c = mix(c, 0.0, smoothstep(0.0, 1.0, rDist / FAR));\n    }\t\n    \n    fragColor = vec4(pow(c * trachet.xyz, vec3(0.4545)), 1.0);\n}", "image_inputs": [], "common_code": "const float PI = 3.141592653;\n\nstruct Camera {\n    vec3 position;\n    vec3 direction;\n    vec3 up_direction; // not require dot(direction, up_direction) == 0\n    float fov;\n    float aspect; // x / y\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nCamera newCamera(vec3 position, vec3 direction, vec3 up_direction, float fov, float aspect) {\n    Camera camera;\n    camera.position = position;\n    camera.direction = direction;\n    camera.up_direction = up_direction;\n    camera.fov = fov;\n    camera.aspect = aspect;\n    return camera;\n}\n\n// perspective camera ray, uv = fragCoord / iResolution.xy\n// cf: https://qiita.com/aa_debdeb/items/301dfc54788f1219b554\nRay cameraRay(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float radian = camera.fov;\n    float h = tan(radian * 0.5);\n    float w = h * camera.aspect;\n    vec3 right = normalize(cross(camera.direction, camera.up_direction));\n    vec3 up = normalize(cross(right, camera.direction));\n    vec3 direction = normalize(right * w * uv.x + up * h * uv.y + camera.direction);\n    Ray ray;\n    ray.origin = camera.position;\n    ray.direction = direction;\n    return ray;\n}\n\n\n// Hash without Sine https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftKGWz.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[255, 255, 280, 280, 523], [525, 525, 550, 550, 803], [805, 805, 830, 830, 1063], [1065, 1065, 1128, 1128, 1530], [2749, 2749, 2780, 2780, 2893], [2895, 2895, 2930, 2930, 3203], [3205, 3205, 3239, 3239, 3453], [3455, 3455, 3490, 3490, 3582], [3584, 3584, 3623, 3623, 3825], [3827, 3827, 3865, 3865, 4032], [4034, 4034, 4100, 4100, 4574], [4576, 4576, 4681, 4681, 5256], [5258, 5258, 5313, 5313, 6600]], "test": "untested"}
{"id": "styGRm", "name": "Ray March glass and mirror", "author": "yurka", "description": "ray march", "tags": ["raymarch"], "likes": 7, "viewed": 356, "published": 3, "date": "1637499519", "time_retrieved": "2024-07-30T18:46:54.371790", "image_code": "vec3 light = vec3(1.0, 1.0, 1.0);\n\nstruct scene_sf \n{\n    float d;\n    float depth;\n    vec3 col;\n    int type; // 0 - regular, 1 - mirror, 2 glass\n    vec3 n;\n};\n\nscene_sf scene_dist(vec3 ap)\n{\n    const float gridsteps = 11.0;\n    scene_sf rs;\n    //vec3 so = vec3(sin(iTime*0.4) * 0.3, sin(iTime*3.14*0.4)*0.1, cos(iTime*0.4) * 3.7 + 3.0);\n    vec3 so = vec3(sin(iTime*0.4) * 0.2, 0.1, cos(iTime*0.4) * 0.2);\n    rs.d = length(ap - so) - 0.1;\n    vec3 pn = -normalize(ap - so);\n    float ldot = dot(pn, light);\n    if (ldot < 0.0) ldot = 0.0;\n    float vdot = dot(pn, vec3(0.0, -sin(iTime * 1.2), cos(iTime * 1.2)));\n    float hdot = dot(pn, vec3(0.0, cos(iTime * 1.2), sin(iTime * 1.2)));\n    float sdot = dot(pn, vec3(1.0, 0.0, 0.0));\n    float vang = acos(vdot);\n    float hang = acos(hdot);\n    float sang = acos(sdot);\n    rs.col = vec3(1.0, 1.0, 1.0);\n    if (int(hang * gridsteps / 3.14) % 2 == 0)\n        rs.col = rs.col - vec3(1.0, 0.0, 0.0);\n    if (int(vang * gridsteps / 3.14) % 2 == 0)\n        rs.col = rs.col - vec3(0.0, 1.0, 0.0);\n    if (int(sang * gridsteps / 3.14) % 2 == 0)\n        rs.col = rs.col - vec3(0.0, 0.0, 1.0);\n    rs.type = 0;\n    rs.n = -pn;\n    //ldot = 1.0;\n    \n    so = vec3(sin(iTime*0.4 + 2.093) * 0.2, 0.1, cos(iTime*0.4 + 2.093) * 0.2);\n    float glsd = length(ap - so) - 0.1;\n    if (glsd < rs.d) {\n        rs.d = glsd;\n        pn = -normalize(ap - so);\n        ldot = dot(pn, light);\n        if (ldot < 0.0) ldot = 0.0;\n        rs.col = vec3(0.0, 0.5, 1.0);\n        rs.type = 1;\n        rs.n = -pn;\n    }\n    \n    so = vec3(sin(iTime*0.4 + 4.186) * 0.2, 0.1, cos(iTime*0.4 + 4.186) * 0.2);\n    glsd = length(ap - so) - 0.1;\n    if (glsd < rs.d) {\n        rs.d = glsd;\n        pn = -normalize(ap - so);\n        ldot = dot(pn, light);\n        if (ldot < 0.0) ldot = 0.0;\n        rs.col = vec3(0.0, 0.5, 1.0);\n        rs.type = 2;\n        rs.n = -pn;\n    }\n    \n    float plane_h = 0.7;\n    if ((ap.y + plane_h) < rs.d) {\n        vec3 plnorm = vec3(0.0, 1.0, 0.0);\n        rs.d = (ap.y + plane_h);\n        if ((int(floor(ap.x)) % 2 + 2) % 2 == (int(floor(ap.z)) % 2 + 2) % 2 )\n            rs.col = vec3(1.0, 1.0, 1.0);\n        else\n            rs.col = vec3(0.0, 0.0, 0.0);\n        //rs.col = vec3(1.0, 0.0, 0.0);\n        ldot = -dot(plnorm, light);\n        if (ldot < 0.0) ldot = 0.0;\n        rs.type = 0;\n        rs.n = plnorm;\n    }\n    \n    float athmo_r = 5.0;\n    if (athmo_r - length(ap) < rs.d) {\n        rs.d = athmo_r - length(ap);\n        float ag = atan(ap.x, ap.z) / 3.14;\n        float cr = 1.0 - 30.0 * abs(fract(ag * 36.0) - 0.5);\n        if (cr < 0.0) cr = 0.0;\n        float agv = atan(sqrt(ap.z*ap.z + ap.x*ap.x), ap.y) / 3.14;\n        float cg = 1.0 - 30.0 * abs(fract(agv * 36.0) - 0.5);\n        if (cg < 0.0) cg = 0.0;\n        rs.col = vec3(cr, cg, ap.y / athmo_r);\n        ldot = 1.0;//-dot(vec3(0.0, 1.0, 0.0), light);\n        if (ldot < 0.0) ldot = 0.0;\n        rs.type = 0;\n        rs.n = -normalize(ap);\n    }\n    \n    rs.col= rs.col * ldot;\n    return rs; // sphere\n}\n\nscene_sf rmarch(vec3 aro, vec3 ard) \n{\n    vec3 p = aro;\n    float depth = 0.0;\n    scene_sf sf;\n    float prefsfd = 1.0;\n    for (int i = 0; i < 250; i++) {\n        sf = scene_dist(p);\n        float ds = abs(sf.d);\n        if (ds < 0.0001) ds = 0.0001;\n        p += ds * ard;\n        depth += ds;\n        if (depth > 100.0)\n           break;\n        if (sf.type == 1 && sf.d < 0.000) {\n            if (dot(ard, sf.n) < 0.0) {\n                ard = reflect(ard, sf.n);\n            }\n        }\n        else\n        if (sf.type == 2) {\n            if (prefsfd > 0.0 && sf.d <= 0.0) {\n                ard = refract(ard, sf.n, 1.0/1.6290);\n            }\n            if (prefsfd <= 0.0 && sf.d > 0.0) {\n                ard = refract(ard, -sf.n, 1.6290);\n            }\n        }\n        else\n        if (sf.d < 0.000)\n            break;\n\n        prefsfd = sf.d;\n    }\n    if (depth > 100.0)\n        depth = 100.0;\n    sf.depth = depth;\n    return sf;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //light = vec3(sin(iTime*2.1), -1.0, cos(iTime*2.1));\n    light = vec3(1.0, -1.0, 1.0);\n    light = normalize(light);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.x;\n    vec2 muv = iMouse.xy/iResolution.x;\n    \n    vec3 ro = vec3(0.0, 0.0, -1.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 0.0) - ro);\n    \n    scene_sf sf = rmarch(ro, rd);\n    \n    float smoge = 1.0 - pow(0.93, sf.depth);\n    \n    vec3 col = vec3(0.88, 0.88, 0.88);\n    //if (sf.d < 0.001) \n    col = col * smoge + sf.col * (1.0 - smoge);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/styGRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3038, 3038, 3076, 3076, 3984], [3986, 3986, 4043, 4101, 4654]], "test": "untested"}
{"id": "flt3zl", "name": "Glowing Offset Triangles", "author": "Shane", "description": "Using an offset triangle grid to produce some randomly glowing markings on some irregular triangles.", "tags": ["grid", "triangle", "light", "glow", "skew"], "likes": 107, "viewed": 1719, "published": 3, "date": "1637499088", "time_retrieved": "2024-07-30T18:46:55.507753", "image_code": "/*\n\n\tGlowing Offset Triangles\n\t------------------------\n\n    Using an offset triangle grid to produce some randomly glowing markings \n    on some irregular triangles.\n    \n    I coded this some time ago, and decided to tidy it up and post it after \n    seeing Yusef28's cool static triangle grid efforts. This particular one\n    was inspired by those phone backgrounds that you may have seen around. \n    \n    The code was written off the top of my head just to get the job done, so \n    I'd ignore most of it. The offset triangle routine is probably worth \n    looking at, if you're interested in this kind of thing.\n    \n    In case it isn't obvious, this is a simple 2D example with some fake 3D\n    elements thrown in. Since there's emitting light involved, it would have \n    been nice to path trace it, but I'm guessing not a lot of people here are \n    viewing Shadertoy on a supercomputer, so perhaps some other time. :) A \n    standard realtime 3D version should be possible though.\n    \n\n\n\tRelated examples:\n\n\n\t// My example is loosely enspired by this.\n\tSimplex Experiment #3b  - Yusef28\n\thttps://www.shadertoy.com/view/Nl33WM\n\n*/\n\n// Display the animated glowing cracks. One could argue that it defeats the\n// purpose of the example, but you may wish to see the pattern without the glow. :)\n#define GLOW\n\n// Light decorations on the triangle faces.\n//#define FACE_DECO\n\n// Light decorations on the outer triangle faces.\n#define OUTER_FACE_DECO\n\n// Offsetting the triangle coordinates. The look is a lot cleaner without it.\n#define OFFSET_TRIS\n\n// Textured.\n//#define TEXTURE\n\n// Animate the triangles -- Technically, a metallic surface animating in such a\n// way isn't really realistic, so you may wish to keep the arrangement static.\n#define ANIMATE\n\n// Light color - Reddish Pink: 0, Greenish Blue: 1. \n#define COLOR 0\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\n// vec2 to vec2 hash.\nvec2 hash22B(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(1, 113)));\n    p = fract(vec2(262144, 32768)*n)*2. - 1.; \n    #ifdef ANIMATE\n    return sin(p*6.2831853 + iTime/2.);\n    #else\n    return p;\n    #endif\n     \n}\n\n// vec2 to vec2 hash.\nvec2 hash22C(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(289, 41)));\n    return fract(vec2(262144, 32768)*n)*2. - 1.;\n    \n    // Animated.\n    //p = fract(vec2(262144, 32768)*n)*2. - 1.; \n    //return sin(p*6.2831853 + iTime/2.); \n}\n\n\n// Based on IQ's gradient noise formula.\nfloat n2D3G( in vec2 p ){\n   \n    // Cell ID and local coordinates.\n    vec2 i = floor(p); p -= i;\n    \n    // Four corner samples.\n    vec4 v;\n    v.x = dot(hash22C(i), p);\n    v.y = dot(hash22C(i + vec2(1, 0)), p - vec2(1, 0));\n    v.z = dot(hash22C(i + vec2(0, 1)), p - vec2(0, 1));\n    v.w = dot(hash22C(i + 1.), p - 1.);\n\n    // Cubic interpolation.\n    p = p*p*(3. - 2.*p);\n    \n    // Bilinear interpolation -- Along X, along Y, then mix.\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n    \n}\n\n// Two layers of noise.\nfloat fBm(vec2 p){ return n2D3G(p)*.57 + n2D3G(p*2.)*.28 + n2D3G(p*4.)*.15; }\n\n\n\n// IQ's signed distance to a 2D triangle.\nfloat sdTri(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2){\n \n    vec2 e0 = p1 - p0, e1 = p2 - p1, e2 = p0 - p2;\n\n\tvec2 v0 = p - p0, v1 = p - p1, v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0, e0)/dot(e0, e0), 0., 1.);\n\tvec2 pq1 = v1 - e1*clamp( dot(v1, e1)/dot(e1, e1), 0., 1.);\n\tvec2 pq2 = v2 - e2*clamp( dot(v2, e2)/dot(e2, e2), 0., 1.);\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x);\n    vec2 d = min( min( vec2(dot(pq0, pq0), s*(v0.x*e0.y - v0.y*e0.x)),\n                       vec2(dot(pq1, pq1), s*(v1.x*e1.y - v1.y*e1.x))),\n                       vec2(dot(pq2, pq2), s*(v2.x*e2.y - v2.y*e2.x)));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n\n\n// Triangle's incenter and radius.\nvec3 inCentRad(vec2 p0, vec2 p1, vec2 p2){\n    \n    // Side lengths.\n    float bc = length(p1 - p2), ac = length(p0 - p2), ab = length(p0 - p1);\n    vec2 inCir = (bc*p0 + ac*p1 + ab*p2)/(bc + ac + ab);   \n    \n    // Area.\n    float p = (bc + ac + ab)/2.;\n    float area = sqrt(p*(p - bc)*(p - ac)*(p - ab));\n    \n    return vec3(inCir, area/p);\n}\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){ return mat2(1, -s.yx, 1)*p; }\n\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){ return inverse(mat2(1, -s.yx, 1))*p; }\n\n\n/*\n\n// Rounded triangle routine. Not used here, but handy.\nfloat sdTriR(vec2 p, vec2 v0, vec2 v1, vec2 v2){\n     \n    vec3 inC = inCentRad(v0, v1, v2);\n    float ndg = .0002/inC.z;\n    return sdTri(p, v0 - (v0 - inC.xy)*ndg,  v1 - (v1 - inC.xy)*ndg,  v2 - (v2 - inC.xy)*ndg) - .0002;      \n        \n}  \n\n*/\n// Global vertices, local coordinates, etc, of the triangle cell.\nstruct triS{\n    \n    vec2[3] v; // Outer vertices.\n    vec2 p; // Local coordinate.\n    vec2 id; // Position based ID.\n    float dist; // Distance field value.\n    float triID; // Triangle ID.\n};\n\nconst float tf = 2./sqrt(3.);\n// Scale.\nconst vec2 scale = vec2(tf, 1)*vec2(1./3.);\n\n// Brick dimension: Length to height ratio with additional scaling.\nconst vec2 dim = vec2(scale);\n// A helper vector, but basically, it's the size of the repeat cell.\nconst vec2 s = dim*2.;\n    \n// Skewing half way along X, and not skewing in the Y direction.\nconst vec2 sk = vec2(tf/2., 0);\n\n// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed square pylons.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n\ntriS blocks(vec2 q){\n    \n\n    \n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual block ID and block center.\n    vec2 id = vec2(0), cntr;\n    \n    // For block corner postions.\n    const vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5), vec2(.5, -.5), vec2(-.5)); \n    \n    float triID = 0.; // Triangle ID. Not used in this example, but helpful.\n\n\n    // Height scale.\n    const float hs = .5;\n\n\n    // Initializing the global vertices and local coordinates of the triangle cell.\n    triS gT, tri1, tri2;\n    \n    for(int i = min(0, iFrame); i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2.;// -  ps4[0];\n        // Skewed local coordinates.\n        p = skewXY(q.xy, sk);// - cntr*s;\n        ip = floor(p/s - cntr) + .5; // Local tile ID.\n        p -= (ip + cntr)*s; // New local position.\n        // Unskew the local coordinates.\n        p = unskewXY(p, sk);\n        \n       \n        // Correct positional individual tile ID.\n        vec2 idi = ip + cntr;\n \n        // Skewed rectangle vertices. \n        vec2[4] vert = ps4;  \n     \n        #ifdef OFFSET_TRIS\n        // Offsetting the vertices.\n        vert[0] += hash22B((idi + vert[0]/2.))*.2;\n   \t\tvert[1] += hash22B((idi + vert[1]/2.))*.2;\n        vert[2] += hash22B((idi + vert[2]/2.))*.2; \n        vert[3] += hash22B((idi + vert[3]/2.))*.2;\n        #endif\n        \n        \n        // Unskewing to enable rendering back in normal space.\n        vert[0] = unskewXY(vert[0]*dim, sk);\n        vert[1] = unskewXY(vert[1]*dim, sk);\n        vert[2] = unskewXY(vert[2]*dim, sk);\n        vert[3] = unskewXY(vert[3]*dim, sk); \n        \n         \n        // Unskewing the rectangular cell ID.\n\t\tidi = unskewXY(idi*s, sk);  \n \n        \n        // Partioning the rectangle into two triangles.\n        \n        // Triangle one.\n        tri1.v = vec2[3](vert[0], vert[1], vert[2]); \n        tri1.id = idi + inCentRad(tri1.v[0], tri1.v[1], tri1.v[2]).xy; // Position Id.\n        tri1.triID = float(i); // Triangle ID. Not used here.\n        tri1.dist = sdTri(p, tri1.v[0], tri1.v[1], tri1.v[2]); // Field distance.\n        tri1.p = p; // 2D coordinates.\n         \n        // Triangle two.\n        tri2.v = vec2[3](vert[0], vert[2], vert[3]);\n        tri2.id = idi + inCentRad(tri2.v[0], tri2.v[1], tri2.v[2]).xy; // Position Id.\n        tri1.triID = float(i + 4); // Triangle ID. Not used here.\n        tri2.dist = sdTri(p, tri2.v[0], tri2.v[1], tri2.v[2]); // Field distance.\n        tri2.p = p; // 2D coordinates.\n         \n        // Doesn't work, unfortunately, so I need to write an ugly \"if\" statement.\n        //triS gTi = tri1.dist<tri2.dist? tri1 : tri2;\n        triS gTi; \n        // Obtain the closest triangle information.\n        if(tri1.dist<tri2.dist) gTi = tri1; \n        else gTi = tri2;\n        \n        \n        // If applicable, update the overall minimum distance value,\n        // then return the correct triangle information.\n        if(gTi.dist<d){\n            d = gTi.dist;\n            gT = gTi;\n            gT.id = idi;//(idi + inCentRad(gT.v[0], gT.v[1], gT.v[2]).xy)*s;\n        }\n        \n        //if(d>1e8) break; // Fake break to get compile times down.\n        \n    }\n    \n    // Return the distance, position-based ID and triangle ID.\n    return gT;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Resolution and aspect correct screen coordinates.\n    float iRes = min(iResolution.y, 800.);\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iRes; \n    \n    // Scene rotation.\n    uv.xy *= rot2(-3.14159/9.);\n    \n    \n    // Unit direction vector and camera origin. \n    // Used for some mock lighting.\n    vec3 rd = normalize(vec3(uv, 1));\n    vec3 ro = vec3(0);\n   \n    \n    // Scaling and translation.\n    const float gSc = 1.;\n    vec2 p = uv*gSc - vec2(0, iTime/32.).yx;\n    \n    \n    // Resolution and scale based smoothing factor.\n    float sf = gSc/iResolution.y;\n    \n    \n    // Take an offset triangle function sample. \n    triS gT = blocks(p);\n    \n \n    // Triangle vertices, local coordinates and position-based ID.\n    // With these three things, you can render anything you want.\n    vec2[3] v = gT.v;\n    vec2 rp = gT.p;\n    vec2 svID = gT.id;\n\n    \n    // Initializing the scene color to black.\n    vec3 col = vec3(0);  \n     \n    // Triangle color.\n    vec3 tCol = vec3(0);\n\n     \n    // Triangle cell center.\n    vec3 cntr = inCentRad(v[0], v[1], v[2]);\n\n     \n    // Light position, light direction and light distance.\n    vec3 lp = vec3(-.5, 1, -1);\n    vec3 ld = lp - vec3(uv, 0);\n    float lDist = length(ld);\n    ld /= lDist;\n    \n    // Light attenuation.\n    float atten = 2./(1. + lDist*lDist*.5);\n\n    // Triangle cell.\n    float triCell = sdTri(rp, v[0], v[1], v[2]);\n    //float triCell2 = sdTri(rp, v[0] - ld.xy*.01, v[1] - ld.xy*.01, v[2] - ld.xy*.01);\n\n    \n    // Circle center and opening.\n    float cir = length(rp - cntr.xy);\n    // The opening is created by using the edge triangles to chip away\n    // from the original cell space.\n    float opening = triCell;\n\n\n    // Glow color.\n    vec3 glCol = vec3(1, .35, .2);\n    #if COLOR == 1\n    glCol = mix(glCol.zyx, glCol.zxy, clamp(-uv.y*1.25 + .5, 0., 1.));\n    #endif\n    glCol = mix(glCol, glCol.xzy, dot(sin(p*2. - cos(p.yx*4.)*3.), vec2(.125)) + .25);\n    //tx = glCol;\n    glCol *= (fBm((rp -svID*s)*128.)*.25 + .75)*1.25; // Adding noise.\n\n\n\n    // Adding some glow to the triangle cell. The subdivided triangle will be drawn\n    // over the top, thus giving the impression of light eminating through cracks.\n    col += glCol*max(.2 - triCell/scale.x*6., 0.);\n\n    // Edge and opening distance fields.\n    float edge = 1e5, openMax = 0.;\n    \n    // Subdividing the triangle cell and producing three triangle wedges -- one\n    // for each side.\n    for(int j = min(0, iFrame); j<3; j++){\n\n\n        // Random numbers based on the triangle cell ID, and the individual\n        // subdivided triangle ID.\n        float rnd = hash21(svID + .08);\n        float rndJ = hash21(svID + float(j)/9. + .13);\n\n        // Open the triangle sides at random blinking intervals.\n        float open = smoothstep(.9, .966, sin(rnd*6.2831 + rndJ/6. + iTime/1.)*.5 + .5);\n        //if(hash21(svID +.34)<.5) open = 0.;\n        //if(gT.triID<.5) open = 0.;\n        // If not showing the glowing light through the cracks, overide \n        // the open variable.\n        #ifndef GLOW\n        open = 0.;\n        #endif\n\n        // Subdivided triangle vertices.\n        vec3 p0 = vec3(v[j], 0);\n        vec3 p1 = vec3(v[(j + 1)%3], 0);\n        vec3 p2 = vec3(cntr.xy, -.2);\n        // Moving the central vertex toward the opposing edge to\n        // simulate the triangle opening like a flower.\n        //p2.xy -= (vec3(v[(j + 2)%3], 0) - p2).xy*.065*open;//(rndJ*.5 + .5)*.07;\n        p2.xy -= normalize(vec3(v[(j + 2)%3], 0) - p2).xy*.065*scale.x*open;\n\n        float triJ = sdTri(rp, v[j], v[(j + 1)%3], p2.xy);\n\n        // Z value, for some faux texture depth.\n        float z = 1./(1. - p2.z);\n        \n        // Creating a second shifted triangle give the open flap some fake depth.\n        p2.xy += normalize(v[(j + 2)%3] - cntr.xy)*.008*open;\n        \n        // Produce the triangle for this edge.\n        float triEdge = sdTri(rp, v[j], v[(j + 1)%3], p2.xy);\n\n   \n        // Normal -- Based on slightly incorrect hit information, but\n        // it's near enough.\n        vec3 nJ = normalize(cross(p1 - p0, p2 - p0));\n \n\n        // Diffuse lighting.\n        float diff = max(dot(ld, nJ), 0.);\n        diff = pow(diff, 4.)*2.;\n        // Specular lighting.\n        float spec = pow(max(dot(reflect(ld, nJ), rd ), 0.), 8.); \n\n\n \n        // Triangle color.\n        #ifdef TEXTURE\n        // Texture color.\n        vec3 tx2 = texture(iChannel0, (rp - svID*s)*z).xyz; tx2 *= tx2;\n        //vec3 tx2 = texture(iChannel0, svID*s).xyz; tx2 *= tx2;\n\n        vec3 tCol = smoothstep(-.5, 1., tx2)*.1;\n        //tCol = sqrt(tx2)*.1;\n        #else\n        vec3 tCol = vec3(.035);\n        #endif\n        \n        // Concentric triangular face pattern.\n        //float pat = (abs(fract(triPat[j]*84. - .5/84.) - .5)*2. - .5)/84.;\n        //tCol = mix(tCol*1.3, tCol*.65, 1. - smoothstep(0., sf, pat));\n\n\n        // Applying the diffuse and specular to the triangle.\n        tCol = tCol*(diff + .25 + spec*4.);\n\n        // Easier way to add diffuse light, but not as good.\n        //float b = max(triCell2 - triCell, 0.)/.01;\n        //tCol *= (b + .25);\n\n        \n        // Lightening the edges.\n        //col = mix(col, col*vec3(12, 6, 2), (1. - smoothstep(0., sf*4., triPat[j] - .001))*.25);\n\n        if(open>1e-5){\n            col = mix(col, vec3(0), open*(1. - smoothstep(0., sf*4., triEdge - .00)));\n            col = mix(col, mix(tCol*vec3(1.5, 1.25, 1), vec3(0), open), (1. - smoothstep(0., sf*2., triEdge)));// + .005/3.\n            col = mix(col, mix(tCol, glCol, .5)*(open), (1. - smoothstep(0., sf, triEdge + .005)));// + .005/3.\n        }\n        //else col = mix(col, vec3(0), open*(1. - smoothstep(0., sf*4., triPat[j] - .00)));// + .005/3.\n\n        col = mix(col, tCol*vec3(1.5, 1.25, 1)*(1. - open), 1. - smoothstep(0., sf*2., triJ));// + .005/3.\n        col = mix(col, tCol, 1. - smoothstep(0., sf*2., triJ + .005));// .005*2./3.\n\n        #ifdef OUTER_FACE_DECO\n        // Outer face decoration.\n        col = mix(col, mix(tCol, glCol*1., open), 1. - smoothstep(0., sf*4., abs(triJ + .035) - .002));// .005*2./3.\n        col = mix(col, mix(tCol, tCol/3., open), 1. - smoothstep(0., sf, abs(abs(triJ + .035) - .006) - .00125));// .005*2./3.\n        #endif\n        \n        #ifdef FACE_DECO\n        // Face decoration.\n        col = mix(col, mix(tCol, (diff + .25 + spec*4.)*glCol, open), (1. - smoothstep(0., sf*3., triJ + .035))*.2);\n        col = mix(col, mix(tCol, vec3(0), open), 1. - smoothstep(0., sf*2., triJ + .035));         \n        col = mix(col, mix(tCol, (diff + .25 + spec*4.)*glCol*2., open), 1. - smoothstep(0., sf, triJ + .035 + .005));          \n        #endif\n\n        edge = min(edge, abs(triJ));\n\n        p0.xy -= (p2.xy - p0.xy)*1.;//*length(p2.xy - p0.xy)*2.;\n        p1.xy -= (p2.xy - p1.xy)*1.;//*length(p2.xy - p1.xy)*2.;\n        float eTri = sdTri(rp, p0.xy*8., p1.xy*8., p2.xy);\n\n        // Glow mask. \n        openMax = max(openMax, open);\n        opening = max(opening, -eTri);\n\n\n    }\n\n    // Applying the glow mask.\n    cir = mix(cir, opening, .65);\n    col = mix(col, col + col*glCol*(openMax*2.5 + .5), (1. - smoothstep(0., sf*24., cir)));// + .005/3.\n\n    // Darkening and shading the edges.\n    //col = mix(col, vec3(0), (1. - smoothstep(0., sf, edge - .001))*.5);\n    //col = mix(col, vec3(0), (1. - smoothstep(0., sf*32., abs(triCell)))*.35);\n    col *= clamp(.5 - triCell/scale.x*4., 0., 1.);\n\n\n    // Outer layer noise. This is applied to the border cords and points.\n    float ns = fBm((rp - cntr.xy)*128.)*.5 + .5;\n    col *= .5 + ns*.75;\n\n    // Light attenuation.\n    col *= atten;\n\n\n/*   \n    // Vertices.\n    vec3 cir3 = vec3(length(svP - svV[0]), length(svP - svV[1]), length(svP - svV[2]));\n    float verts = min(min(cir3.x, cir3.y), cir3.z);\n    verts -= .016;\n \n    vec3 vCol = lCol;//*.7;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*5.*iRes/450., verts))*.35);\n    col = mix(col, vec3(0), (1. - smoothstep(0., .005, verts)));  \n    col = mix(col, vCol, (1. - smoothstep(0., sf, verts + .0035))); \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, verts + .011))); // Pin staple hole. \n*/   \n  \n    // Subtle vignette.\n    //uv = fragCoord/iResolution.xy;\n    //col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625)*1.05;\n    // Colored variation.\n    //col = mix(col*vec3(.25, .5, 1)/8., col, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125));\n    \n    // Rough gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flt3zl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1835, 1868, 1890, 1890, 1948], [1951, 1979, 2000, 2000, 2063], [2066, 2088, 2110, 2459, 2649], [2651, 2673, 2695, 3044, 3251], [3254, 3295, 3320, 3362, 3808], [3810, 3834, 3852, 3852, 3911], [3915, 3957, 4016, 4016, 4596], [4600, 4635, 4677, 4703, 4982], [4984, 5047, 5075, 5075, 5105], [5108, 5173, 5203, 5203, 5242]], "test": "untested"}
{"id": "NlK3WR", "name": "Robotic Head", "author": "dr2", "description": "Trigonometric experiment (mouseable)", "tags": ["mechanics", "trigonometry"], "likes": 26, "viewed": 309, "published": 3, "date": "1637498895", "time_retrieved": "2024-07-30T18:46:56.640723", "image_code": "// \"Robotic Head\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Trigonometric experiment (mouseable)\n\n/*\n  No. 12 in \"Flexible Tube\" series\n    \"Flexibility\"               (MtlyWl)\n    \"Planet Reboot\"             (wldGD8)\n    \"Decalled Floppy Tube\"      (3l3GD7)\n    \"Elevating Platter\"         (Wl33RS)\n    \"Multisegment Floppy Tube\"  (tlcGRB)\n    \"Planet Reboot 2\"           (Wtc3Rf)\n    \"Snake Worship\"             (wtyGRD)\n    \"Decalled Floppy Tube 2\"    (WsGfWd)\n    \"Floppy Column\"             (wtccR4)\n    \"Metallic Tubeworms\"        (3ltfzM)\n    \"Trapped Light\"             (flt3WB)\n    \n  But now a different (transcendental) problem must be solved: \n  compute arc angle from arc and chord lengths, rather than radius\n  from arc length and angle.\n*/\n\n#define AA  0   // optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrTorusBxDf (vec3 p, vec3 b, float ri);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrConCapsDf (vec3 p, vec2 cs, float r, float h);\nfloat SmoothMax (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\n\nvec3 ltPos[4], ltCol[4], qHit;\nfloat tCur, dstFar;\nint idObj;\nconst int idTube = 1, idCon = 2, idBall = 3, idHead = 4, idEar = 5, idNos = 6, idCrwn = 7,\n   idTooth = 8, idEye = 9, idBas = 10, idArm = 11; \nconst float pi = 3.1415927;\n\nstruct Arc {\n  vec2 cs;\n  float chDist, chRot, ang, rad, shift;\n};\nArc arc;\n\nstruct Arm {\n  float len, sep, rot;\n};\nArm arm;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 pr, q;\n  float dMin, d, sLen, sx, a;\n  dMin = dstFar;\n  sLen = 0.25;\n  p.y -= arm.sep + 1.;\n  q = p;\n  pr = p;\n  pr.xz = Rot2D (pr.xz, arm.rot);\n  pr.y -= arm.sep;\n  q = pr;\n  q.z -= -0.5;\n  d = PrRoundBoxDf (q, vec3 (0.8, 1.2, 1.), 0.2);\n  d = SmoothMax (d, - min (PrSphDf (vec3 (abs (q.x) - 0.4, q.y - 0.4, q.z + 1.2), 0.25),\n     PrCapsDf (vec3 (q.x, q.y + 0.7, q.z + 1.2).yzx, 0.15, 0.4)), 0.02);\n  DMINQ (idHead);\n  q = pr;\n  q.z -= -0.2;\n  d = PrRoundBoxDf (q, vec3 (0., 1.3, 0.9), 0.3);\n  DMINQ (idCrwn);\n  q = pr;\n  d = PrTorusBxDf (q, vec3 (arm.len - 0.2, 0.1, 0.2), 0.1);\n  DMINQ (idCon);\n  q = pr;\n  q.x = abs (q.x);\n  q -= vec3 (0.4, 0.4, -1.65);\n  d = PrSphDf (q, 0.22);\n  DMINQ (idEye);\n  q = pr;\n  q -= vec3 (0., 0.2, -1.7);\n  d = PrConCapsDf (q.xzy, sin (0.1 * pi + vec2 (0.5 * pi, 0.)), 0.13, 0.25);\n  DMINQ (idNos);\n  q = pr;\n  q.x = abs (q.x);\n  q -= vec3 (1.1, 0.5, -0.8);\n  d = PrRoundCylDf (q.yzx, 0.3, 0.15, 0.);\n  DMINQ (idEar);\n  q = pr;\n  d = max (PrRoundBoxDf (vec3 (mod (q.x + 0.05, 0.1) - 0.05, abs (q.y + 0.7) - 0.12,\n     q.z + 1.65), vec3 (0.025, 0.04, 0.), 0.03), abs (q.x) - 0.45);\n  DMINQ (idTooth);\n  q = pr;\n  sx = sign (q.x);\n  q.x = abs (q.x) - arm.len;\n  q.xz = Rot2D (q.xz, 0.5 * (pi - arm.rot) * sx);\n  q.x += sLen * sx;\n  d = PrCylDf (q.yzx, 0.1, sLen);\n  DMINQ (idCon);\n  sx *= sign (q.x);\n  q.x = abs (q.x) - sLen;\n  if (sx > 0.) q = q.xzy;\n  d = PrSphDf (q, 0.17);\n  DMINQ (idBall);\n  q = p;\n  d = PrCylDf (q.xzy, 0.4, 0.6);\n  DMINQ (idBas);\n  q = p;\n  q.yz -= vec2 (- arm.sep - 0.2, -0.3);\n  d = PrRoundCylDf (q.xzy, 1., 0.2, 0.7);\n  DMINQ (idBas);\n  q = p;\n  q.yz -= vec2 (- arm.sep, - sLen);\n  d = PrRoundBoxDf (q, vec3 (arm.len + 0.2, 0.2, 0.), 0.2);\n  DMINQ (idArm);\n  q = p;\n  sx = sign (q.x);\n  q.x = abs (q.x);\n  q.xy -= vec2 (arm.len, - arm.sep);\n  q.xz = Rot2D (q.xz, -0.5 * (pi - arm.rot) * sx);\n  q.x -= sLen * sx;\n  d = PrCylDf (q.yzx, 0.1, sLen);\n  DMINQ (idCon);\n  sx *= sign (q.x);\n  q.x = abs (q.x) - sLen;\n  if (sx < 0.) q = q.xzy;\n  d = PrSphDf (q, 0.17);\n  DMINQ (idBall);\n  for (float k = 0.; k <= 1.; k ++) { // (constant-length flexible tubing)\n    q = p;\n    q.xz = Rot2D (q.xz, k * pi + 0.5 * arm.rot) - vec2 (arc.shift, 2. * sLen * sign (1. - 2. * k));\n    q.yz = Rot2D (q.yz, arc.chRot - (k + 0.5) * pi) + vec2 (arc.chDist, 0.);\n    a = mod ((128. / arc.ang) * atan (q.z, q.y) / (2. * pi), 1.);\n    d = max (dot (vec2 (abs (q.z), q.y), arc.cs), length (vec2 (length (q.yz) - arc.rad, q.x)) -\n       0.13 + 0.02 * smoothstep (0.15, 0.35, 0.5 - abs (0.5 - a)));\n    DMINQ (idTube);\n  }\n  return dMin;\n}\n\n#define F(x) (sin (x) / x - b)\n\nfloat SecSolve (float b)\n{  // (solve for arc angle given length and chord, |err| < 1e-4 for b < 0.95) \n  vec3 t;\n  vec2 f;\n  t.yz = vec2 (0.7, 1.2);\n  f = vec2 (F(t.y), F(t.z));\n  for (int nIt = 0; nIt < 4; nIt ++) {\n    t.x = (t.z * f.x - t.y * f.y) / (f.x - f.y);\n    t.zy = t.yx;\n    f = vec2 (F(t.x), f.x);\n  }\n  return t.x;\n}\n\nvoid ArcConf ()\n{\n  vec2 u;\n  float arcLen, arcEx, chLen, aLim;\n  aLim = 0.5 * pi;\n  arm.len = 2.;\n  arm.sep = 1.2;\n  arcEx = 1.5;\n  arcLen = arcEx * length (vec2 (arm.len * sin (0.5 * aLim), arm.sep));\n  arm.rot = aLim * (0.3 + 0.7 * Fbm1 (0.7 * tCur)) * sin (0.2 * pi * tCur);\n  u = vec2 (arm.len * sin (0.5 * arm.rot), arm.sep);\n  chLen = length (u);\n  arc.chRot = atan (u.x, u.y);\n  arc.shift = sqrt (arm.len * arm.len - u.x * u.x);\n  arc.ang = SecSolve (chLen / arcLen);\n  arc.chDist = chLen / tan (arc.ang);\n  arc.rad = sqrt (arc.chDist * arc.chDist + chLen * chLen);\n  arc.cs = sin (- arc.ang + vec2 (0.5 * pi, 0.));\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0005 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dMax)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.001 || d > dMax) break;\n  }\n  return 0.3 + 0.7 * sh;\n}\n\nvec4 ObjCol ()\n{\n  vec4 col4;\n  float s;\n  if (idObj == idTube) {\n    col4 = vec4 (0.9, 0.9, 1., 0.3);\n  } else if (idObj == idCon) {\n    col4 = vec4 (1., 0.7, 0.4, 0.3);\n  } else if (idObj == idBall) {\n    col4 = vec4 (1., 0.7, 0.4, 0.3) * (0.8 + 0.2 * smoothstep (0., 0.005,\n       abs (abs (qHit.z) - 0.05) - 0.005));\n  } else if (idObj == idHead) {\n    s = min (abs (PrRoundBox2Df (qHit.yz - vec2 (-0.7, -0.4), vec2 (0.25, 0.3), 0.1)),\n       abs (PrRoundBox2Df (qHit.yz - vec2 (0., 0.5), vec2 (0.4, 0.1), 0.07)));\n    if (qHit.y > 0.) s = min (s, abs (PrRoundBox2Df (vec2 (abs (qHit.x) - 0.55, qHit.z),\n       vec2 (0.1, 0.9), 0.07)));\n    s = min (s, (qHit.z < 0.) ? abs (PrRoundBox2Df (qHit.xy - vec2 (0., 1.),\n       vec2 (0.6, 0.1), 0.1)) : abs (PrRoundBox2Df (vec2 (abs (qHit.x), qHit.y) -\n       vec2 (0.55, 0.), vec2 (0.1, 1.1), 0.07)));\n    col4 = vec4 (0.8, 1., 0.9, 0.2) * (0.8 + 0.2 * smoothstep (0., 0.03, s));\n    if (PrRoundBoxDf (qHit, vec3 (0.8, 1.2, 1.) - 0.01, 0.2) < 0.) col4 = vec4 (0.6, 0., 0., -1.);\n  } else if (idObj == idEar) {\n    col4 = vec4 (0.5, 1., 0.8, 0.2);\n    if (qHit.x > 0.1) col4 *= 0.7 + 0.3 * smoothstep (0., 0.02, mod (16. *\n       length (qHit.yz), 1.) - 0.1);\n  } else if (idObj == idNos) {\n    col4 = vec4 (0.9, 1., 0.6, 0.2);\n    if (qHit.y < -0.3 && length (vec2 (abs (qHit.x) - 0.07, qHit.z + 0.1)) < 0.05) col4 *= 0.3;\n  } else if (idObj == idCrwn) {\n    s = 0.;\n    if (abs (qHit.z) < 0.9) s = qHit.z;\n    else if (abs (qHit.y) < 1.3) s = qHit.y;\n    col4 = vec4 (0.6, 0.6, 0.2, 0.2);\n    if (s != 0.) col4 *= 0.8 + 0.2 * smoothstep (0., 0.05, mod (8. * s, 1.) - 0.1);\n  } else if (idObj == idTooth) {\n    col4 = vec4 (1., 1., 1., 0.2);\n  } else if (idObj == idEye) {\n    col4 = vec4 (vec3 (0.3, 0.5, 1.) * (0.7 + 0.3 * Fbm1 (8. * tCur)), -1.);\n  } else if (idObj == idBas) {\n    col4 = vec4 (0.3, 0.7, 0.3, 0.2) * (0.8 + 0.2 * smoothstep (0., 0.05,\n       mod (8. * qHit.y, 1.) - 0.1));\n  } else if (idObj == idArm) {\n    col4 = vec4 (0.5, 0.9, 0.3, 0.2) * (0.8 + 0.2 * smoothstep (0., 0.03,\n       abs (PrRoundBox2Df (vec2 (abs (qHit.x), qHit.y) - vec2 (arm.len - 0.05, 0.),\n       vec2 (0.2, 0.12), 0.07))));\n  }\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, ltDir, ltAx, c;\n  float dstObj, nDotL, sh, att, ltDst;\n  ArcConf ();\n  col = vec3 (0.);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = ObjCol ();\n  } else if (rd.y < 0.) {\n    dstObj = - ro.y / rd.y;\n    ro += dstObj * rd;\n    vn = vec3 (0., 1., 0.);\n    col4 = vec4 (0.6, 0.6, 0.6, 0.1) * (1. - 0.2 * Fbm2 (4. * ro.xz));\n    col4.rgb *= 1. - 0.2 * smoothstep (0.05, 0.08,\n       length (max (abs (mod (ro.xz + 0.7, 1.4) - 0.7) - 0.6, 0.)));\n  }\n  if (dstObj < dstFar) {\n    if (col4.a >= 0.) {\n      for (int k = VAR_ZERO; k < 4; k ++) { // (see \"Controllable Hexapod 2\")\n        ltDir = ltPos[k] - ro;\n        ltDst = length (ltDir);\n        ltDir /= ltDst;\n        ltAx = normalize (ltPos[k] - vec3 (0., arm.sep + 1., 0.));\n        att = smoothstep (0., 0.02, dot (ltDir, ltAx) - 0.95);\n        sh = (dstObj < dstFar) ? ObjSShadow (ro + 0.01 * vn, ltDir, ltDst) : 1.;\n        nDotL = max (dot (vn, ltDir), 0.);\n        if (col4.a > 0.) nDotL *= nDotL * nDotL;\n        c = att * ltCol[k] * (col4.rgb * (0.15 + 0.85 * sh * nDotL) +\n           col4.a * step (0.95, sh) * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.));\n        col += c * c;\n      }\n      col = sqrt (col);\n    } else col = col4.rgb * (0.2 + 0.8 * max (0., - dot (vn, rd)));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.13 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az -= 0.03 * pi * tCur;\n    el += 0.1 * pi * cos (0.02 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, -0.01 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 2., -20.);\n  ro.y = max (ro.y, 0.1);\n  for (int k = VAR_ZERO; k < 4; k ++) {\n    ltPos[k] = vec3 (0., 30., 0.);\n    ltPos[k].xy = Rot2D (ltPos[k].xy, 0.25 * pi * (1. + 0.2 * sin (0.05 * pi * tCur -\n       pi * float (k) / 4.)));\n    ltPos[k].xz = Rot2D (ltPos[k].xz, 0.1 * pi * tCur + 2. * pi * float (k) / 4.);\n  }\n  ltCol[0] = vec3 (1., 0.5, 0.5);\n  ltCol[1] = ltCol[0].gbr;\n  ltCol[2] = ltCol[0].brg;\n  ltCol[3] = 0.8 * ltCol[0].rrg;\n  zmFac = 4.8;\n  dstFar = 100.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrTorusBxDf (vec3 p, vec3 b, float ri)\n{\n  return length (vec2 (length (max (abs (p.xy) - b.xy, 0.)) - b.z, p.z)) - ri;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrConCapsDf (vec3 p, vec2 cs, float r, float h)\n{\n  float d;\n  d = max (dot (vec2 (length (p.xy) - r, p.z), cs), abs (p.z) - h);\n  h /= cs.x * cs.x;\n  r /= cs.x;\n  p.z += r * cs.y;\n  return min (d, min (length (p - vec3 (0., 0., h)) - (r - h * cs.y),\n     length (p - vec3 (0., 0., - h)) - (r  + h * cs.y)));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlK3WR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1888, 1888, 1910, 1910, 4491], [4525, 4525, 4551, 4628, 4856], [4858, 4858, 4875, 4875, 5483], [5485, 5485, 5518, 5518, 5766], [5768, 5768, 5789, 5789, 6044], [6046, 6046, 6095, 6095, 6337], [6339, 6339, 6355, 6355, 8524], [8526, 8526, 8561, 8561, 9933], [9935, 9935, 9991, 9991, 11454], [11456, 11456, 11502, 11502, 11549], [11551, 11551, 11598, 11598, 11645], [11647, 11647, 11693, 11693, 11774], [11776, 11776, 11809, 11809, 11836], [11838, 11838, 11880, 11880, 11931], [11933, 11933, 11976, 11976, 12040], [12042, 12042, 12099, 12099, 12175], [12177, 12177, 12232, 12232, 12493], [12495, 12495, 12540, 12540, 12632], [12634, 12634, 12679, 12679, 12717], [12719, 12719, 12755, 12755, 12961], [12963, 12963, 12993, 12993, 13106], [13140, 13140, 13164, 13164, 13217], [13219, 13219, 13243, 13243, 13355], [13357, 13357, 13382, 13382, 13528], [13530, 13530, 13555, 13555, 13741], [13743, 13743, 13765, 13765, 13919], [13921, 13921, 13942, 13942, 14097]], "test": "untested"}
{"id": "7lyGDz", "name": "FBM-Ridge", "author": "celns", "description": "FBM-Ridge", "tags": ["fbmridge"], "likes": 1, "viewed": 189, "published": 3, "date": "1637484790", "time_retrieved": "2024-07-30T18:47:00.095486", "image_code": "vec2 Random(vec2 iuv)\n{\n    vec2 point = vec2(dot(iuv,vec2(123.45,678.90)),\n                    dot(iuv,vec2(234.56,345.67)));\n    return -1.0+2.0*fract(sin(point)*45678.7654321);\n}\n\n\n\nfloat PerlinNoise(vec2 uv)\n{\n    vec2 iuv = floor(uv);\n    vec2 cuv = ceil(uv);\n    vec2 fuv = fract(uv);\n    \n    float a = dot(Random(iuv),fuv);\n    float b = dot(Random(iuv + vec2(1.0,0.0)),fuv - vec2(1.0,0.0));\n    float c = dot(Random(iuv + vec2(0.0,1.0)),fuv - vec2(0.0,1.0));\n    float d = dot(Random(cuv),fuv - vec2(1.0,1.0));\n    \n    vec2 interuv = fuv*fuv*(3.0-2.0*fuv);\n    \n    return mix(mix(a,b,interuv.x),mix(c,d,interuv.x),interuv.y);\n    \n  \n}\n\nfloat FBM(vec2 uv)\n{\n    float fbm = 0.0;\n    float amp = 5.;\n    float offset = 1.0;\n    int epoch = 5;\n    \n    for(int i = 0; i < epoch; i++)\n    {\n        fbm += amp * abs(PerlinNoise(uv*0.3));\n        fbm = offset - fbm;\n        fbm = fbm*fbm;\n        uv *= 2.0;\n        amp *= 0.5;\n    }\n    \n    return fbm;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 5.;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float value = FBM(tan(iTime) + uv);\n    \n    vec3 col = vec3((value));\n\n\n    // Output to screen\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lyGDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 181], [185, 185, 213, 213, 646], [648, 648, 668, 668, 964], [967, 967, 1024, 1074, 1352]], "test": "untested"}
{"id": "7tyGWz", "name": "isolines from sparse points", "author": "elenzil", "description": "interpolating isolines from sparse sample points.\nleft: ground-truth  right: interpolated.\nthe blend falloff power here is 4.0.\ncan be modified at top of code.", "tags": ["isolines", "interpolation", "power", "falloff", "sparse"], "likes": 9, "viewed": 248, "published": 3, "date": "1637484279", "time_retrieved": "2024-07-30T18:47:01.284308", "image_code": "\n// the weighting of each sample point is 1 / distance^BLEND_FALLOFF_POWER\nconst float BLEND_FALLOFF_POWER = 4.0;\n\n\n// sample point are contained in a square of this 'radius'.\nconst float sweepRadius = 10.0;\n\n// distance between sample points.\nconst float sweepStep   = sweepRadius / 5.0;\n\n// every third and seventh sample points are removed for some irregularity.\n\n\n\n\n#define RES iResolution\n\n\nmat2 rotationMatrix2(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\nconst float sinData[] = float[](\n    // angle\n    // frequency\n    // phase\n    // amplitude\n    2.5, 0.11, 1.5, 3.0,\n    3.1, 0.71, 1.5, 2.0,\n    6.1, 1.31, 1.5, 1.0,\n    2.2, 0.41, 1.5, 4.0\n);\nfloat groundTruth(in vec2 p) {\n\n    float accum = 0.0;\n    float range = 0.0;\n    for (int n = 0; n < sinData.length(); n += 4) {\n        vec2  v   = p * rotationMatrix2(sinData[n + 0]);\n        float val = sin(v.y * sinData[n + 1] + sinData[n + 2]) * sinData[n + 3];\n        accum += val;\n        range += sinData[n + 3];\n    }\n    \n    float f = accum * 0.5 / range + 0.5;\n    \n    return f;\n}\n\nvoid accumulateSample(in vec2 p, in vec2 samplePt, inout float accumVal, inout float accumRng) {\n    \n    float sampleVal = groundTruth(samplePt);\n    float sampleDst = length(p - samplePt);\n        \n    float weight = 1.0 / pow(sampleDst, BLEND_FALLOFF_POWER);\n    accumVal += sampleVal * weight;\n    accumRng += weight;\n}\n\nbool discardSamplePoint(int n) {\n    return n % 3 == 0 || n % 7 == 0;\n}\n\n\nfloat interpolated(in vec2 p, in vec2 screenCenter, in vec2 mousePt) {\n    float accumVal = 0.0;\n    float accumRng = 0.0;\n    \n    accumulateSample(p, screenCenter + mousePt       , accumVal, accumRng);\n    \n\n    int n = 0;\n    for (float dx = -sweepRadius; dx <= sweepRadius; dx += sweepStep) {\n    for (float dy = -sweepRadius; dy <= sweepRadius; dy += sweepStep) {\n        ++n;\n        if (discardSamplePoint(n)) {\n            continue;\n        }\n        accumulateSample(p, screenCenter + vec2(dx, dy), accumVal, accumRng);\n    }\n    }\n    \n    return accumVal / accumRng;\n}\n\n// doing fwidth 'yourself' with dFdx() and dFdy()\n// yields finer results on some systems, iirc.\nfloat fwidth_home(float val) {\n    return abs(dFdy(val)) + abs(dFdx(val));\n}\n\n// val in [0, 1]\nfloat isolines(float val) {\n    val = (val - 0.5) * 1.01 + 0.5;\n    return smoothstep(2.0, 0.0, abs(mod(val + 0.05, 0.1) - 0.05) / fwidth_home(val));\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n    // get normalized xy screen-coordinates in \n    float zoomFactor       = 1.2;\n    float smallDim         = min(RES.x, RES.y);\n    vec2  xy               = (XY - RES.xy * 0.5) /smallDim * 2.0 * zoomFactor;\n    bool  isLeftSide       = xy.x < 0.0;\n    \n    // for smooth lines\n    float edgeWidth        = 2.0;\n    float smoothingEpsilon = edgeWidth / smallDim * 2.0;\n\n    // world-space coord\n    vec2  worldOffset      = vec2(cos(iTime * 0.0051), sin(iTime * 0.0041)) * 100.0;\n    vec2  p                = xy * 10.0 + worldOffset;\n    vec2  resetSide        = vec2(RES.x / smallDim * zoomFactor * -10.0, 0.0);\n    \n    vec2  mouse            = (iMouse.xy - RES.xy * 0.5) / smallDim * 2.0 * zoomFactor;\n    vec2  samplePt         = mouse * 10.0 - resetSide * 0.5;\n        \n    float val;\n    if (isLeftSide) {\n        val = groundTruth(p);\n    }\n    else {\n        val  = interpolated(p + resetSide, worldOffset + resetSide * 0.5, samplePt);\n    }\n    \n    vec3 rgb  = val * vec3(0.5, 0.8, 1.0);\n    \n    float iso = isolines(val);\n    rgb       = mix(rgb, vec3(0.5, 0.5, 0.3), iso);\n    \n    // draw sample points\n    float ptRad = 0.2;\n    vec3  ptCol = vec3(1.0);\n    float dp;\n    if (isLeftSide) {   \n        dp = length(p - (worldOffset + resetSide * 0.5 + samplePt));\n        rgb = mix(rgb, ptCol, smoothstep(smoothingEpsilon * 12.0, 0.0, abs(dp - ptRad) - 0.01));\n    }\n    else {\n        dp = length(p + resetSide - (worldOffset + resetSide * 0.5 + samplePt));\n        rgb = mix(rgb, ptCol, smoothstep(smoothingEpsilon * 12.0, 0.0, abs(dp - ptRad) - 0.01));\n    }\n\n    int n = 0;\n    for (float dx = -sweepRadius; dx <= sweepRadius; dx += sweepStep) {\n    for (float dy = -sweepRadius; dy <= sweepRadius; dy += sweepStep) {\n        ++n;\n        if (discardSamplePoint(n)) {\n            continue;\n        }\n        if (isLeftSide) {\n            dp = length(p - (worldOffset + resetSide * 0.5 + vec2(dx, dy)));\n            rgb = mix(rgb, ptCol, smoothstep(smoothingEpsilon * 12.0, 0.0, abs(dp - ptRad) - 0.01));\n        }\n        else {\n            dp = length(p + resetSide - (worldOffset + resetSide * 0.5 + vec2(dx, dy)));\n            rgb = mix(rgb, ptCol, smoothstep(smoothingEpsilon * 12.0, 0.0, abs(dp - ptRad) - 0.01));\n        }\n    }\n    }\n    \n    // center divider\n    rgb       = mix(rgb, vec3(0.0, 0.0, 0.0), smoothstep(smoothingEpsilon * 2.0, 0.0, abs(xy.x)));\n    \n    \n    RGBA.rgb = rgb;\n    RGBA.a   = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tyGWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[396, 396, 431, 431, 515], [712, 712, 742, 742, 1107], [1109, 1109, 1205, 1205, 1432], [1434, 1434, 1466, 1466, 1505], [1508, 1508, 1578, 1578, 2087], [2089, 2186, 2216, 2216, 2262], [2264, 2281, 2308, 2308, 2432], [2434, 2434, 2477, 2525, 4914]], "test": "untested"}
{"id": "slyGDz", "name": "FBM4FBM", "author": "celns", "description": "FBM4FBM", "tags": ["fbm4fbm"], "likes": 5, "viewed": 225, "published": 3, "date": "1637484192", "time_retrieved": "2024-07-30T18:47:02.737422", "image_code": "vec2 Random(vec2 iuv)\n{\n    vec2 point = vec2(dot(iuv,vec2(123.45,678.90)),\n                    dot(iuv,vec2(234.56,345.67)));\n    return -1.0+2.0*fract(sin(point)*45678.7654321);\n}\n\n\n\nfloat PerlinNoise(vec2 uv)\n{\n    vec2 iuv = floor(uv);\n    vec2 cuv = ceil(uv);\n    vec2 fuv = fract(uv);\n    \n    float a = dot(Random(iuv),fuv);\n    float b = dot(Random(iuv + vec2(1.0,0.0)),fuv - vec2(1.0,0.0));\n    float c = dot(Random(iuv + vec2(0.0,1.0)),fuv - vec2(0.0,1.0));\n    float d = dot(Random(cuv),fuv - vec2(1.0,1.0));\n    \n    vec2 interuv = fuv*fuv*(3.0-2.0*fuv);\n    \n    return mix(mix(a,b,interuv.x),mix(c,d,interuv.x),interuv.y) * 0.5 + 0.5;\n    \n  \n}\n\nfloat FBM(vec2 uv)\n{\n    float fbm = 0.0;\n    float amp = 5.;\n    float freq = 0.0;\n    int epoch = 6;\n    \n    for(int i = 0; i < epoch; i++)\n    {\n        fbm += amp * PerlinNoise(uv);\n        uv *= 2.0;\n        amp *= 0.5;\n    }\n    \n    return fbm;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 10.;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec2 layer1 = vec2(FBM(2.0 * iTime + uv),FBM(uv));\n    vec2 layer2 = vec2(FBM(0.5 * iTime + layer1));\n    vec2 layer3 = vec2(FBM(layer2),FBM(0.05* iTime + layer2));\n    float value = FBM(uv+layer3);\n    \n    vec3 col = vec3(tan(value));\n\n\n    // Output to screen\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slyGDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 181], [185, 185, 213, 213, 658], [660, 660, 680, 680, 914], [920, 920, 977, 1027, 1472]], "test": "untested"}
{"id": "slGGWz", "name": "3D trunchet - stripe", "author": "IWBTShyGuy", "description": "I wanted to get a sense of how a little decoration can change the impression. I would like to try some variations...", "tags": ["trunchet"], "likes": 8, "viewed": 277, "published": 3, "date": "1637475793", "time_retrieved": "2024-07-30T18:47:04.087812", "image_code": "// Copyright © 2021 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\n#define rotate3D(n, t) mat3( \\\n    cos(t) + n.x * n.x * (1.0 - cos(t)), n.x * n.y * (1.0 - cos(t)) + n.z * sin(t), n.z * n.x * (1.0 - cos(t)) - n.y * sin(t), \\\n    n.x * n.y * (1.0 - cos(t)) - n.z * sin(t), cos(t) + n.y * n.y * (1.0 - cos(t)), n.y * n.z * (1.0 - cos(t)) + n.x * sin(t), \\\n    n.z * n.x * (1.0 - cos(t)) + n.y * sin(t), n.y * n.z * (1.0 - cos(t)) - n.x * sin(t), cos(t) + n.z * n.z * (1.0 - cos(t))  \\\n)\n\nconst mat3 T0 = rotate3D(normalize(vec3(0, 1, -1)), PI);\nconst mat3 T1 = rotate3D(normalize(vec3(1, 0, 1)), PI);\nconst mat3 T2 = rotate3D(normalize(vec3(0, 1, 1)), PI);\n\n// hexahedron group\nconst mat3[] S = mat3[](\n    mat3(1, 0, 0, 0, 1, 0, 0, 0, 1),\n    T2,\n    T1,\n    T2 * T1,\n    T1 * T2,\n    T2 * T1 * T2,\n    T0,\n    T2 * T0,\n    T1 * T0,\n    T2 * T1 * T0,\n    T1 * T2 * T0,\n    T2 * T1 * T2 * T0,\n    T0 * T1,\n    T2 * T0 * T1,\n    T1 * T0 * T1,\n    T2 * T1 * T0 * T1,\n    T1 * T2 * T0 * T1,\n    T2 * T1 * T2 * T0 * T1,\n    T0 * T1 * T2,\n    T2 * T0 * T1 * T2,\n    T1 * T0 * T1 * T2,\n    T2 * T1 * T0 * T1 * T2,\n    T1 * T2 * T0 * T1 * T2,\n    T2 * T1 * T2 * T0 * T1 * T2\n);\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nvec2 textureTorus(vec3 p, vec2 t) {\n    vec2 q = normalize(p.zx);\n    float u = asin(clamp(abs(q.x), 0.0, 1.0));\n    vec3 r = normalize(p - vec3(q.y, 0, q.x));\n    r = rotate3D(vec3(0, 1, 0), -u) * r;\n    float v = acos(r.z);\n    if (r.x < 0.0) v = 2.0 * PI - v;\n    return vec2(u * 2.0 / PI, v / (2.0 * PI));\n}\n\nvec3 normalTorus(vec3 p, vec2 t) {\n    vec2 q = t.x * normalize(p.xz);\n    return normalize(p - vec3(q.x, 0, q.y));\n}\n\nfloat sdist(in vec3 p, in vec3 q, out vec2 uv, out vec3 normal, out uint index) {\n    float rand = hash13(floor(p + q));\n    index = uint(rand * 24.0);\n    p = mod(p, 1.0);\n    p = S[index] * (p - 0.5) + 0.5;\n    float dist = sdTorus((p - vec3(0, 0, 0.5)).yzx, vec2(0.5, 0.05));\n    uv = textureTorus((p - vec3(0, 0, 0.5)).yzx, vec2(0.5, 0.05));\n    normal = normalTorus((p - vec3(0, 0, 0.5)).yzx, vec2(0.5, 0.05)).zxy;\n    float dist1 = sdTorus((p - vec3(1, 1, 0.5)).yzx, vec2(0.5, 0.05));\n    if (dist > dist1) {\n        dist = dist1;\n        uv = textureTorus((p - vec3(1, 1, 0.5)).yzx, vec2(0.5, 0.05));\n        normal = normalTorus((p - vec3(1, 1, 0.5)).yzx, vec2(0.5, 0.05)).zxy;\n    }\n    dist1 = length(p.xy - vec2(0.5)) - 0.05;\n    if (dist > dist1) {\n        dist = dist1;\n        uv.x = p.z;\n        normal = vec3(normalize(p.xy - vec2(0.5)), 0.0);\n    }\n    return dist;\n}\n\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 theta = vec2(0.15, 0.25) * iTime;\n    theta.y = sin(theta.y);\n    Camera camera = newCamera(\n        vec3(0, 0, -iTime * 0.5),\n        vec3(cos(theta.x) * cos(theta.y), sin(theta.y), sin(theta.x) * cos(theta.y)),\n        vec3(0, 1, 0),\n        PI / 4.0,\n        iResolution.x / iResolution.y\n    );\n    Ray ray = cameraRay(camera, fragCoord / iResolution.xy);\n\n    vec3 p = fract(ray.origin);\n    vec3 q = floor(ray.origin);\n    vec2 uv;\n    vec3 normal = vec3(0);\n    uint index;\n    for (int i = 0; i < 100; i++) {\n        float dist = sdist(p, q, uv, normal, index);\n        if (dist < 0.00001) break;\n        p += dist * ray.direction;\n    }\n    normal = inverse(S[index]) * normal;\n\n    float c = 0.0;\n    float dist = length(p);\n    if (dist < 12.0) {\n        float a = abs(uv.x) / 0.02;\n        a = min(a, abs(uv.x - 1.0) / 0.02);\n        a = min(a, abs(uv.x - fract(0.5 * iTime + 0.05)) / 0.02);\n        a = min(a, abs(uv.x - fract(0.5 * iTime + 0.15)) / 0.02);\n        a = min(a, abs(uv.x - fract(0.5 * iTime + 0.25)) / 0.02);\n        a = min(a, abs(uv.x - fract(0.5 * iTime + 0.35)) / 0.02);\n        a = min(a, abs(uv.x - fract(0.5 * iTime + 0.45)) / 0.02);\n        a = min(a, abs(uv.x - fract(0.5 * iTime + 0.55)) / 0.02);\n        a = min(a, abs(uv.x - fract(0.5 * iTime + 0.65)) / 0.02);\n        a = min(a, abs(uv.x - fract(0.5 * iTime + 0.75)) / 0.02);\n        a = min(a, abs(uv.x - fract(0.5 * iTime + 0.85)) / 0.02);\n        a = min(a, abs(uv.x - fract(0.5 * iTime + 0.95)) / 0.02);\n        a = clamp(a * a, 0.0, 1.0);\n        c = -dot(normal, ray.direction) * a;\n    }\n    fragColor = vec4(c, c, c, clamp(dist, 0.0, 12.0));\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    \n// smart anti-aliasing\n// reference: https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n\n// If defined, Activate AA, level: 2 or 3\n#define AA 2\n\n// If defined, visualize anti-aliased pixels.\n//#define VISUALIZE_AA\n#ifdef AA\n    if ( fwidth(O.w) > 0.1) {\n        vec4 o;\n#if (AA == 2)\n        for (int k = 0; k < 4; k++) {\n              mainImage0(o,U + (vec2(k % 2, k / 2) - 0.5) / 1.5);\n              O += o;\n        }\n        O /= 5.0;\n#elif (AA == 3)\n        for (int k = 0; k < 9; k += k == 3 ? 2 : 1 ) {\n              mainImage0(o, U + vec2(k % 3 - 1, k / 3 - 1) / 3.0);\n              O += o;\n        }\n        O /= 9.0;\n#endif\n#ifdef VISUALIZE_AA\n        O = vec4(1);\n    } else {\n        O = vec4(0,0,0,1);\n#endif\n    }\n#endif\n\n    O.w = 1.0;\n}", "image_inputs": [], "common_code": "const float PI = 3.141592653;\n\nstruct Camera {\n    vec3 position;\n    vec3 direction;\n    vec3 up_direction; // not require dot(direction, up_direction) == 0\n    float fov;\n    float aspect; // x / y\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nCamera newCamera(vec3 position, vec3 direction, vec3 up_direction, float fov, float aspect) {\n    Camera camera;\n    camera.position = position;\n    camera.direction = direction;\n    camera.up_direction = up_direction;\n    camera.fov = fov;\n    camera.aspect = aspect;\n    return camera;\n}\n\n// perspective camera ray, uv = fragCoord / iResolution.xy\n// cf: https://qiita.com/aa_debdeb/items/301dfc54788f1219b554\nRay cameraRay(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float radian = camera.fov;\n    float h = tan(radian * 0.5);\n    float w = h * camera.aspect;\n    vec3 right = normalize(cross(camera.direction, camera.up_direction));\n    vec3 up = normalize(cross(right, camera.direction));\n    vec3 direction = normalize(right * w * uv.x + up * h * uv.y + camera.direction);\n    Ray ray;\n    ray.origin = camera.position;\n    ray.direction = direction;\n    return ray;\n}\n\n\n// Hash without Sine https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slGGWz.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[1183, 1232, 1263, 1263, 1332], [1334, 1334, 1369, 1369, 1645], [1647, 1647, 1681, 1681, 1764], [1766, 1766, 1847, 1847, 2650], [2652, 2652, 2708, 2708, 4359]], "test": "untested"}
{"id": "7tGGWz", "name": "geometry hole animation", "author": "yasuo", "description": "geometry hole animation", "tags": ["animation"], "likes": 6, "viewed": 271, "published": 3, "date": "1637473246", "time_retrieved": "2024-07-30T18:47:05.408281", "image_code": "// All the distance functions from:https://iquilezles.org/articles/distfunctions\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define MAX_STEPS 64\n#define MAX_DIST 64.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\nvec3 path(float z)\n{\n    vec3 p = vec3(sin(z) * .6, cos(z * .5), z);\n    return p;\n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    return (val1.w < val2.w)?val1:val2;\n}\n\nfloat B3D(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return max(max(p.x,p.y),p.z);\n}\nvec4 GetDist(vec3 p) {\n    vec3 prevP = p;\n    p.z+=iTime*1.0;\n    p.xy -= path(p.z).xy;\n    p.z+=iTime*0.5;\n    p.z=mod(p.z,1.0)-0.5;\n    float d = B3D(p,vec3(0.01));\n    for (float i = 0.; i < 5.; i++) {\n            p.xz*=Rot(radians(90.0));\n            p.yz*=Rot(radians(38.0));\n            p=abs(p)-(3.3*pow(.54, i));\n            d=B3D(p,vec3(0.18));\n\t}\n    \n    vec3 col = vec3(1.0);\n    \n    return vec4(col,d*0.6);\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 r = vec4(0.0,0.0,0.0,1.0);\n    \n    float dist;\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*r.w;\n        vec4 dS = GetDist(p);\n        dist =  dS.w;\n        r.w += dS.w;\n        r.rgb = dS.xyz;\n        \n        if(r.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return r;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(3,5,0);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n    \n    float lambert = max(.0, dot( n, l))*0.2;\n    \n    return vec2((lambert+dif),0.9) ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float t = iTime*2.0;\n    vec3 col = vec3(1.0);\n    vec3 ro = vec3(0.0,0.0,1.0);\n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    rd*=matRotateZ(radians(iTime*15.0));\n\tvec4 r = RayMarch(ro, rd);\n    \n    if(r.w<MAX_DIST) {\n        vec3 p = ro + rd * r.w;\n        vec3 n = GetNormal(p);\n        vec2 dif = GetLight(p);\n        col = vec3(dif.x)*r.rgb;\n        col *= dif.y;\n        col *= exp( -0.0001*r.w*r.w*r.w );\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tGGWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[492, 492, 512, 512, 576], [578, 578, 614, 614, 656], [658, 658, 685, 685, 739], [740, 740, 762, 762, 1163], [1165, 1165, 1198, 1198, 1505], [1507, 1507, 1531, 1531, 1732], [1734, 1734, 1757, 1757, 2047], [2049, 2049, 2091, 2091, 2286], [2288, 2288, 2345, 2345, 2868]], "test": "untested"}
{"id": "NtyGDz", "name": "Time Test", "author": "Temmie", "description": "Times", "tags": ["time"], "likes": 1, "viewed": 140, "published": 3, "date": "1637451314", "time_retrieved": "2024-07-30T18:47:06.287930", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//Transitioning\nfloat t = min(1.0,floor(sin(iTime)) * sin(iTime) * 2.0);\n\n//Pulse\nfloat ft = min(1.0,fract(iTime * 2.));\n\n\n vec3 p1 = vec3(1.,1.,1.);\n vec3 p2 = vec3(1.,0.,0.);\nvec3 p2f = vec3(0.,0.,0.);\n\n     vec3 col = mix(p1 , mix(p2,p2f,ft), t);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtyGDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 73, 340]], "test": "untested"}
{"id": "ftG3Wz", "name": "Anti-aliased ellipse", "author": "rpmalon", "description": "Method for approximating a point's distance from an ellipse for the purposes of anti-aliasing", "tags": ["ellipse"], "likes": 2, "viewed": 245, "published": 3, "date": "1637442938", "time_retrieved": "2024-07-30T18:47:07.045903", "image_code": "//=======================================================================================================================\n//\n// The MIT License\n// Copyright © 2021 Ryan Malon\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"),\n// to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n// and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n//=======================================================================================================================\n//\n// Rendering an ellipse implicitly with anti-aliasing using an approximation of signed distance\n//\n// note: This does not work well for highly eccentric (flat) ellipses.\n//       However, this does not require any textures, root-finding, or conditionals.\n//       What you see is what you get.\n//\n// Ellipse representation\n//\n//   names are based on conventional ellipse values A, B, and C where:\n//     A is the length of the semi-major axis\n//     B is the length of the semi-minor axis\n//     C is the distance from the center of the ellipse to either of the foci\n//     these follow a Pythagorean triple, A^2 = B^2 + C^2\n//\n//   EllipseCenter: vector from center of coordinate space to center of the ellipse\n//                  you can easily write your vertex shader such that this is always (0, 0)\n//\n//   EllipseCVec:   vector from center of ellipse to one of the foci\n//                  i.e. one focus is at (EllipseCenter + EllipseCVec), the other is at (EllipseCenter - EllipseCVec)\n//                  this determines the orientation of the ellipse, and partially defines its eccentricity\n//\n//   EllipseB:      length of the ellipse's semi-minor axis\n//\n//=======================================================================================================================\n\nfloat ApproxDistanceToEllipse(vec2 QueryPoint, vec2 EllipseCenter, vec2 EllipseCVec, float EllipseB)\n{\n    QueryPoint = QueryPoint - EllipseCenter;\n    \n    float EllipseC = length(EllipseCVec);\n    float EllipseA = sqrt(EllipseC*EllipseC + EllipseB*EllipseB);\n    \n    float QueryA = (length(QueryPoint + EllipseCVec) + length(QueryPoint - EllipseCVec)) / 2.f;\n    float QueryB = sqrt(QueryA*QueryA - EllipseC*EllipseC);\n    \n    float CosTheta = dot(QueryPoint, normalize(EllipseCVec)) / QueryA;\n    \n    // I'm not sure which of these is better for anti-aliasing purposes.\n    // Maybe there's actually a better interpolation than Lerp, and we should use neither or both.\n    // Cosine^2 is clearly better (just looking at it) as distance from ellipse increases, which is exactly the cases we don't care about for anti-aliasing.\n    // I'm too lazy right now to implement the exact distance function and collect error metrics of both methods.\n    // If anyone reading this feels like doing that for some reason, \n    // you can find David Eberly's exact distance method at https://www.geometrictools.com/Documentation/DistancePointEllipseEllipsoid.pdf section 2.9.\n    // tl;dr just because the first option for LerpValue LOOKS better, doesn't mean that it is, but it might be, I haven't checked\n    float LerpValue = CosTheta * CosTheta;\n    //float LerpValue = abs(CosTheta);\n    \n    float Distanceish = mix(QueryB - EllipseB, QueryA - EllipseA, LerpValue);\n\n    return Distanceish;\n\n}\n\nvoid mainImage(out vec4 FragColor, in vec2 FragCoord )\n{\n    // turn off to see actual anti-aliasing\n    // turn on to see contours of approximated distance\n    bool ShowContours = bool(0);\n    \n    // FragCoord -> range [-iResolution / 2, iResolution / 2]\n    vec2 P = FragCoord - (iResolution.xy * 0.5f);\n    \n    // setup ellipse params\n    float pi = radians(180.f);\n    float CAngle = mod(iTime / 1.5f, 2.f*pi);\n    float CMag = mix(100.f, 200.f, abs(mod(iTime / 2.3f, 2.f) - 1.f));\n    \n    vec2  EllipseCVec = CMag * vec2(cos(CAngle), sin(CAngle));\n    float EllipseB = 50.f;\n    vec2  EllipseCenter = vec2(100.f*cos(iTime), 50.f*sin(iTime * 1.4));\n    \n    // stationary ellipse where major axis is X axis\n    if (ShowContours)\n    {\n        EllipseCVec = vec2(200.f, 0.f);\n        EllipseB = 50.f;\n        EllipseCenter = vec2(0.f, 0.f);\n    }\n    \n    // get approximate distance in pixels\n    float Distanceish = ApproxDistanceToEllipse(P, EllipseCenter, EllipseCVec, EllipseB);\n    \n    // do antialiasing using our approximate distance\n    float Antialias = 1.5;\n    float AntialiasMin = -(Antialias/2.f), AntialiasMax = Antialias/2.f;\n    float Alpha = 1.f - smoothstep(AntialiasMin, AntialiasMax, Distanceish);\n\n    // in actual use case, just use whatever texture or color you want for the ellipse\n    // and use the value of 'Alpha' for the alpha channel of FragColor\n    vec3 ColorOutsideEllipse = vec3(0,0.5,0.5);\n    vec3 ColorInsideEllipse = vec3(0,0.2,0.2);\n    vec3 Color = mix(ColorOutsideEllipse, ColorInsideEllipse, Alpha);\n    FragColor = vec4(Color, 1.f);\n    \n    // visualize distance contours\n    // contour coloring concept from https://www.shadertoy.com/view/tlSGzG\n    if (ShowContours)\n    {\n        float D = Distanceish/6.f;\n        float Darkness = 0.3;\n        vec3 ContourColor = vec3(1.0) - sign(D)*ColorInsideEllipse;\n        ContourColor *= 1.0 - exp(-2.0*abs(D));\n        ContourColor *= (1.f - Darkness) + Darkness*cos(D);\n        FragColor = vec4(ContourColor, 1.f);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftG3Wz.jpg", "access": "api", "license": "mit", "functions": [[2639, 2639, 2741, 2741, 4130], [4132, 4132, 4188, 4288, 6152]], "test": "untested"}
{"id": "7tcGWB", "name": "Hyper Dough", "author": "Tater", "description": "experimenting with some complicated diffuse lighting. ", "tags": ["3d", "raymarch", "glow", "halfprism"], "likes": 78, "viewed": 5215, "published": 3, "date": "1637429335", "time_retrieved": "2024-07-30T18:47:07.883663", "image_code": "//very inspired by this work from halfprism\n//https://twitter.com/halfprism_/status/1434909264951263243\n#define GLOW\n#define STEPS 200.0\n#define MDIST 50.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define sat(a) clamp(a,0.0,1.0)\n#define range(a,b,r,x) (smoothstep(a-r,a+r,x)*smoothstep(b+r,b-r,x))\n#define s(a) smoothstep(0.0,1.0,a)\n#define pmod(p,x) (mod(p,x)-0.5*(x))\n\n//smin & smax, probably based on IQ's version idk \nfloat smin(float a,float b, float k){ \n    float h=max(0.,k-abs(a-b));\n    return min(a,b)-h*h*.25/k;\n}\n\nfloat smax(float d1,float d2,float k){\n    float h=clamp(0.5-0.5*(d2+d1)/k,0.,1.);\n    return mix(d2,-d1,h)+k*h*(1.0-h);\n}\n\n//https://www.shadertoy.com/view/3tjGWm\nvec3 hs(vec3 c, float s){\n    vec3 m=vec3(cos(s),s=sin(s)*.5774,-s);\n    return c*mat3(m+=(1.-m.x)/3.,m.zxy,m.yzx);\n}\n\n//iq box sdf\nfloat ebox(vec3 p, vec3 b){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 moda (vec2 p, float per){\n    float a = atan(p.y,p.x);\n    a = mod(a-per/2.,per)-per/2.;\n    return vec2 (cos(a),sin(a))*length(p);\n}\n\nfloat box(vec2 p, float r){\n  vec2 d = abs(p);\n  return max(d.x,d.y)-r;\n}\n\nfloat superGon(vec2 p, float r){\n  float a = box(p,r);\n  p*=rot(pi/4.);\n  float b = box(p,r);\n  a = max(a,b);\n  p*=rot(pi/8.);\n  b = box(p,r);\n  a = max(a,b);\n  p*=rot(pi/4.);\n  b = box(p,r);\n  a = max(a,b);\n  return a;\n}\n\nfloat octGon(vec2 p, float r){\n  float a = box(p,r);\n  p*=rot(pi/4.);\n  float b = box(p,r);\n  a = max(a,b);\n  return a;\n}\n\nfloat glow = 0.;\nfloat glow2 = 0.;\nvec2 map(vec3 p){\n    float t = iTime*0.85;\n    vec3 po2 = p;\n    p.xz*=rot(pi/4.0);\n    vec3 po = p;\n    \n    vec2 a = vec2(1);\n    vec2 b = vec2(1);\n    a.x = 999.;\n    float ballscl = 3.4;\n    \n    for(float i = 0.; i<13.0; i++){\n        p.x+=tanh(cos(t*2.0+i*1.4)*8.0)*ballscl;\n        p.x+=tanh(cos(t*1.0+i*2.0)*20.0)*ballscl;\n        p.z+=tanh(sin(t*2.0+i*0.5)*8.0)*ballscl;\n        p.z+=tanh(sin(t*1.0+i*3.5)*8.0)*ballscl;\n        p.y+=sin(t*0.33+i*2.3+tanh(sin(t*1.1)*8.)*1.5)*7.5;\n\n        b.x = length(p)-1.7;\n        a.x = smin(a.x,b.x,1.3);\n        p = po;\n    }\n    \n    p.xy*=rot(pi/4.);\n    float wv = 0.6;\n    float disp = sin(p.x*wv+t*2.0)*sin(p.z*wv);\n    p+=disp;\n    p.xz = abs(p.xz)-2.6;\n    \n    float size = 2.75;\n    b.x = ebox(p, vec3(size,0.,size))-1.7;\n    b.x = smax(a.x-0.2,b.x,2.);\n    a.x = min(a.x,b.x);\n    \n    glow+=0.6/(2.9+a.x*a.x);\n    #ifdef GLOW\n    //outer lines\n    p = po2;\n    \n    p.xy*=rot(0.8);\n    float space = .3;\n    float width = .2;\n    p.y+=t*0.75;\n    vec2 c = vec2(a.x,3.0);\n    \n    p.y = pmod(p.y,space+width);\n    float cut = abs(p.y)-space*0.5;\n    \n    c.x-=.3;\n    c.x = abs(c.x)-0.15;\n    c.x = max(c.x,-cut);\n    if(c.x<0.01){\n    glow2+=1.3/(2.9+c.x*c.x);\n    glow-=0.5/(2.9+c.x*c.x);\n    }\n    glow-=0.05/(0.4+c.x*c.x);\n    c.x = max(0.03,abs(c.x));\n\n    a=(a.x<c.x)?a:c;\n    #endif\n    return a;\n}\n\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.01,0);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0,0,-28.0);\n    if(iMouse.z>0.){\n    ro.yz*=rot(2.0*(iMouse.y/iResolution.y-0.5));\n    ro.zx*=rot(-7.0*(iMouse.x/iResolution.x-0.5));\n    }\n    vec3 lk = vec3(0,0.1,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*(1.0)+uv.x*r+uv.y*cross(f,r));  \n    vec3 p = ro;\n    vec2 d = vec2(0);\n    bool hit = false;\n    float dO = 0.;\n    float blueNoise = texelFetch(iChannel0, ivec2(fragCoord)% textureSize(iChannel0, 0) , 0).r;\n    ro+=rd*(blueNoise*min(10.0,map(ro).x*0.8)-0.5);\n\n    for(float i = 0.; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x;\n        if(abs(d.x)<0.005){\n            hit = true;\n            break;\n        }\n        if(dO>MDIST){\n            break;\n        }\n    }\n    vec3 red = vec3(0.957,0.176,0.310);\n    vec3 redish = vec3(0.706,0.094,0.278);\n    if(hit){\n        vec3 n = norm(p);\n        vec3 rr = reflect(rd,n);\n        vec3 ld = normalize(vec3(-1,1.6,-0.1));\n        ld.xz*=rot(0.3);\n        vec3 h = normalize(ld - rd);\n        float diff = max(0.0,dot(n,ld));\n        float amb = dot(n,ld)*0.5+0.5;\n        float fres = pow(dot(rd,rr)*0.4+0.6,1.0);\n        float spec = pow(max(dot(n, h),0.), 20.);\n        float diff2 = dot(n,ld)*0.7+0.3;\n\n        vec3 diffcol = vec3(0);\n        \n        //Base top red color\n        diffcol+=mix(red,redish,0.5);\n        //Sorta shift yellow towards top of diff but keep bottom end\n        float bias = 0.3;\n        //Base Top Yellow \n        vec3 top1=vec3(diff2*0.5,pow(diff2,0.9),diff2*0.1)*smoothstep(0.0,0.4+bias,dot(n,ld)+0.15);\n        //Second version of Top Yellow \n        vec3 top2 =vec3(diff2*0.6,diff2*0.9,diff2*-0.3)*smoothstep(0.0,0.5+bias,dot(n,ld));\n        //Idk I liked both of them\n        diffcol+=mix(top1,top2,0.6);\n        //White top hightlight\n        diffcol+=vec3(0,0,1)*smoothstep(0.75,1.15,diff)*0.3;\n        //Saturate \n        diffcol=pow(diffcol,vec3(1.05));\n        //Add diffcol\n        col+=diffcol;\n        //Transition between dark and light\n        float cutdiff = smoothstep(0.3,0.55,amb)+0.1;\n        //Remove previous lighting in dark\n        col*=cutdiff;\n        //add purple fresnal in dark area\n        col+=mix(fres,1.0,0.3)*pow(redish,vec3(1.3))*sat(1.0-cutdiff)*0.8;\n        //I think the hueshift breaks without this idk\n        col = sat(col);\n        //col = vec3(amb);\n    }\n    else {\n        float px = 2.5/min(iResolution.x,iResolution.y);\n        \n        col+=sat(min(glow*0.05,0.3)*2.5)*redish;\n        uv-=vec2(-0.9,0.6);\n        col+=redish*length(uv)*smoothstep(0.5,5.8,length(uv));\n\n        \n        uv+=vec2(0.08,-0.06);\n        vec2 uv2 = uv;\n        uv2*=rot(-iTime*0.02);\n        col+=0.55*mix(vec3(0.973,0.004,0.369),vec3(0.537,0.200,0.910),uv.y+0.5)\n        *smoothstep(0.5+px,0.5-px,superGon(uv2,-0.01));\n\n\n        vec2 uvo = uv;\n        uv.xy*=rot(iTime*0.0075);\n        uv=moda(uv,0.18);\n        uv.x-=0.55;\n\n        col+=0.3*vec3(0.973,0.004,0.369)*smoothstep(0.025+px,0.025-px,octGon(uv,0.0));\n\n        uv = uvo;\n        uv.xy*=rot(iTime*0.0125);\n        uv=moda(uv,0.17);\n        uv.x-=0.62;\n\n        uv=moda(uv,2.);\n        uv.x-=0.03;\n\n        col+=0.3*vec3(0.973,0.004,0.369)*smoothstep(0.0125+px,0.0125-px,octGon(uv,0.0));\n    \n    }  \n    col +=min(glow2*0.06,0.7)*pow(redish,vec3(0.5));\n\n    //Hue Shift\n    col = hs(col,0.3);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tcGWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[404, 455, 492, 492, 558], [560, 560, 598, 598, 682], [684, 724, 749, 749, 841], [843, 856, 883, 883, 970], [972, 972, 1002, 1002, 1110], [1112, 1112, 1139, 1139, 1185], [1187, 1187, 1219, 1219, 1408], [1410, 1410, 1440, 1440, 1531], [1568, 1568, 1585, 1585, 2932], [2934, 2934, 2952, 2952, 3079], [3081, 3081, 3135, 3135, 6640]], "test": "untested"}
{"id": "7lV3zm", "name": "Mercurial Nebulae", "author": "xenn", "description": "Mousey mouse mouse colour colour vector", "tags": ["fluid", "cfd", "fluiddynamics"], "likes": 16, "viewed": 504, "published": 3, "date": "1637421452", "time_retrieved": "2024-07-30T18:47:08.851076", "image_code": "// (another) fork of \"Spilled\" by Flokeroo https://www.shadertoy.com/view/MsGSRd\n\n#define HEIGHT 150.50\n#define BRIGHTNESS 2.\n\n\nfloat NoiseSeed;\n\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 84522.13219145687;\n  return fract(NoiseSeed);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n/**\n\tUse Buffer A in iChannel0 for 3D letters. Read description!\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n//void mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n    // Normalized pixel coordinates (from 0 to 1)\n    \n   \n    vec2 uv = fragCoord/iResolution.xy;\n    //Texel Size\n    vec2 texel = vec2(1.) / iResolution.xy;\n    \n   \n    \n    \n    \n   \n    \n    vec4 ace = vec4(ACESFilm(vec3(0)), 1.0);;\n\n    \n    if(fragCoord.y / iResolution.y < Margins || fragCoord.y / iResolution.y > 1.0-Margins){\n        fragColor = vec4(ACESFilm(vec3(0)), 1.0);\n        return;\n    }\n    \n    NoiseSeed = float(iFrame)* .003186154 + fragCoord.y * 17.2986546543 + fragCoord.x;\n    \n//    vec2 uv = fragCoord.xy/iResolution.xy;\n\n\n    \n    vec2 d = (uv-vec2(.5)) * .0075;\n      vec3 color = vec3(texture(iChannel0, uv - 0.50 * d).r,\n                      texture(iChannel0, uv - .0 * d).g,\n                      texture(iChannel0, uv + 01.0 * d).b);\n                                  \n    vec3 col = vec3(texture(iChannel1, uv - 0.50  * d).r,\n                      texture(iChannel1, uv - .0 * d).g,\n                      texture(iChannel1, uv - 01.0 * d).b);\n                      \n        vec3 col2 = vec3(texture(iChannel2, uv -0.50  * d).r,\n                      texture(iChannel2, uv - .0 * d).g,\n                      texture(iChannel2, uv - 01.0  * d).b);\n                      \n                       vec3 col3 = vec3(texture(iChannel3, uv - 0.50 * d).r,\n                      texture(iChannel3, uv - 0.0 * d).g,\n                      texture(iChannel3, uv - 1.0 * d).b);\n                      \n                      vec3 blend = (mix(color,col,0.5));\n                      vec3 bland = (mix(col3,col2,0.5));\n               //       blend *= bland;\n               //       col2 = min(col,col3)*col2;\n               //       col = mix(col,col3,color);\n              //       col3 = min(col,color)*col3;\n            //     color = mix(col,color,col3)*color;\n\n  //    color = ((max(color,col),col3)*(color));\n //     color = (mix(color,col2,col2)*(color));\n    float noise = .9 + randomFloat()*.15;\n  \t//fragColor = vec4(ACESFilm(frogColor));\n //   fragColor = mix(vec4(ACESFilm((col+(mix(bland,blend,0.5)))*noise), 1.0),frogColor,(col,1.0));\n//    fragColor = vec4(ace(final))*noise );\n  vec4 frogColor = texture(iChannel3, uv);\n\n    vec3 normal = bump2Normal(uv, iChannel2, HEIGHT, texel);\n   \tvec3 normalRGB = normal2rgb(normal);\n    \n    vec3 lightDir = normalize(vec3(abs(sin(iTime/11.)), -abs(cos(iTime/22.)), abs(sin(iTime/33.))));\n    \n    vec3 toLightDir = vec3(0.0) - lightDir;\n    \n    float mouseX = iMouse.x / iResolution.x;\n    \n\tif (mouseX < 01.5) {\n        frogColor = vec4(BRIGHTNESS*dot(toLightDir, normalize(normal)));\n        frogColor*=texture(iChannel3, uv);\n    } else {\n        frogColor = vec4(normalRGB, 1.0);\n    }  \n    \n//    if(abs(toLightDir.x *.5 + .5 - uv.x) < 0.005 && abs(toLightDir.z *.5 + .5 - uv.y) < 0.005) {\n//    \tfrogColor = vec4(1.,abs(toLightDir.y*2.),vec2(0.));  \n//    }\n     vec4 final = frogColor;\n //   fragColor = frogColor;\n //fragColor =(vec4(ACESFilm(mix(bland,blend,0.5)*noise),1.0));\n fragColor = mix((vec4(ACESFilm(mix(bland,blend,0.5)*noise),1.0)),frogColor,(color,.50));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n//#define keyTex iChannel3\n//#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 mu = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = mu*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = mu*p;\n        }\n        b*=2.0;\n    }\n    \n     vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n//  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 blend = mix(col2,col,0.5);\n  \n//  fragColor=blend;\n  \n   vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 col2 = texture(iChannel2,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 col3 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 blend = max(mix(col,col2,0.5),col);\n//  fragColor=max(blend,col);\nfragColor=blend;\n//  fragColor=blend,(fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  //  fragColor=texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n //   vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n//    fragColor.xy += (0.001*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n //   if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "                                                                                                                                                                                                                                                                                        // See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .0001;\nconst float iFeedbackFadeRate         = .999;\nconst float iFeedbackColorShiftZoom   = .001;\nconst float iFeedbackColorShiftImpact = 0.001;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = 10.5;\nconst float iBlobEdgeSmoothing        = .07;\nconst float iBlob1Radius              = 1.5;\nconst float iBlob1PowFactor           = 69.;\nconst float iBlob1ColorPulseSpeed     = .25242;\nconst float iBlob2Radius              = 1.95;\nconst float iBlob2PowFactor           =69.;\nconst float iBlob2ColorPulseSpeed     = -.01834;\nconst float iBlob2ColorPulseShift     = 0.0;\nconst float iColorShiftOfRadius       =  0.5;\nconst float iFeedbackMouseShiftFactor = .01;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * (iBlob1ColorPulseSpeed / 1.5), 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * (iBlob2ColorPulseSpeed / -1.5) + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.bg/colorShift.gr - .5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel2, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n    \n    vec3 prevColor2 = repeatedTexture(iChannel3, uv - stShift).rgb;\n    prevColor2 *= iFeedbackFadeRate;\n    \n  //  vec3 prevColor3 = repeatedTexture(iChannel1, uv - stShift).rgb;\n //   prevColor3 *= iFeedbackFadeRate;\n    \n  //  prevColor = mix(prevColor,prevColor2,prevColor3);\n\n    vec3 drawColor = vec3(0);\n   \n\n    float radius =\n         (1. * abs(cos(iTime / 3.2)))\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          (iBlob1PowFactor)) * iBlob1Color;\n        radius =\n         (1. * abs(sin(iTime / 3.3)))\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n         (iBlob2PowFactor)) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define HEIGHT -150.0\n#define BRIGHTNESS 01.5\n\n/**\n\tUse Buffer A in iChannel0 for 3D letters. Read description!\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //Texel Size\n    vec2 texel = vec2(1.) / iResolution.xy;\n\n    vec3 normal = bump2Normal(uv, iChannel0, HEIGHT, texel);\n   \tvec3 normalRGB = normal2rgb(normal);\n    \n    vec3 lightDir = normalize(vec3(-abs(sin(iTime/22.)), -abs(cos(iTime/33.)), -abs(cos(iTime/44.))));\n    \n    vec3 toLightDir = vec3(0.0) - lightDir;\n    \n    float mouseX = iMouse.x / iResolution.x;\n    \n\tif (mouseX < 0.99) {\n        fragColor = vec4(BRIGHTNESS*dot(toLightDir, normalize(normal)));\n        fragColor*=texture(iChannel1, uv);\n    } else {\n        fragColor = vec4(normalRGB, 1.0);\n    }  \n    \n//    if(abs(toLightDir.x *.5 + .5 - uv.x) < 0.005 && abs(toLightDir.z *.5 + .5 - uv.y) < 0.005) {\n//    \tfragColor = vec4(1.,abs(toLightDir.y*2.),vec2(0.));  \n//    }\n    \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//#define iFeedbackColorShiftZoom 0.2\n//#define iFeedbackColorShiftImpact 0.001\n//#define iBlob1ColorPulseSpeed 0.03456\n//#define iBlob2ColorPulseSpeed 0.02345\n#define Margins .0\n\n#define PI 3.14159265359\n\nvec2 getFontSymbolSampleUV(int x, int y, vec2 uv) {\n\treturn uv * vec2(1./16.) + vec2(float(x) / 16., float(y) / 16.);\n}\n\nfloat getHeight(vec2 uv, sampler2D bumpMap, float maxHeight) {\n    return texture(bumpMap, uv).r*maxHeight;\n}\n\nvec3 getSlope(vec2 uv, float height, vec2 axis, sampler2D bumpMap, float maxHeight, vec2 texelSize) {\n    float h1 = getHeight(uv+texelSize*axis, bumpMap, maxHeight);\n    float h2 = getHeight(uv-texelSize*axis, bumpMap, maxHeight);\n    return vec3(1,((height-h2) + (h1-height)) / 2.,0);\n}\n\nvec3 bump2Normal(vec2 uv, sampler2D bumpMap, float maxHeight, vec2 texelSize) {\n    \n    float height = getHeight(uv, bumpMap, maxHeight);\n        \n    vec3 slopeX = getSlope(uv, height, vec2(1., 0.), bumpMap, maxHeight, texelSize).zyx;\n    vec3 slopeY = getSlope(uv, height, vec2(0., 1.), bumpMap, maxHeight, texelSize).xyz;\n    return cross(slopeX, slopeY).zyx;\n}\n\nvec3 normal2rgb(vec3 normal) {\n    return normalize(normal.rbg * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5));\n}\n\nfloat radius = 20.;\nfloat intensity = 5.;\nfloat fade = .99;\n\nfloat pi = 3.14159265359;\n\nfloat blurRadius = 3.;\n\nfloat sinWave(float v, float m){return (sin(v*m*pi*2.)+1.)/2.;}\n\n//from https://github.com/hughsk/glsl-hsv2rgb\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 xy2hue(vec2 v){\n    float h = (atan(v.y, v.x)/(pi) + 1.)/2.;\n    float b = length(v);\n    return vec4(hsv2rgb(vec3(h, 1., b)), 1.);\n}\n\n\n\n\n\n\n\n/*\n * Conway Ticket\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nivec2 boardSize = ivec2(125),\n    ci = ivec2(1,0);\nvec2 blockSize,\n    xij;\nvec3 c = vec3(1,0,-1);\nfloat stepTimeDelta = .05,\n//    pi = 3.14159,\n    fsaa = 144.,\n    bpm = 90.,\n    spb = 60./90.,\n    scale,\n    nbeats,\n    stepTime;\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(p.xyx * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lfnoise(float y)\n{\n    vec2 t = y*c.xx;\n    vec2 i = floor(t);\n    t = smoothstep(c.yy, c.xx, fract(t));\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)),\n    v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat m(vec2 x)\n{\n    return max(x.x,x.y);\n}\n\nfloat d210(vec2 x)\n{\n    return min(max(max(max(max(min(max(max(m(abs(vec2(abs(abs(x.x)-.25)-.25, x.y))-vec2(.2)), -m(abs(vec2(x.x+.5, abs(abs(x.y)-.05)-.05))-vec2(.12,.02))), -m(abs(vec2(abs(x.x+.5)-.1, x.y-.05*sign(x.x+.5)))-vec2(.02,.07))), m(abs(vec2(x.x+.5,x.y+.1))-vec2(.08,.04))), -m(abs(vec2(x.x, x.y-.04))-vec2(.02, .08))), -m(abs(vec2(x.x, x.y+.1))-vec2(.02))), -m(abs(vec2(x.x-.5, x.y))-vec2(.08,.12))), -m(abs(vec2(x.x-.5, x.y-.05))-vec2(.12, .07))), m(abs(vec2(x.x-.5, x.y))-vec2(.02, .08)));\n}\n\nfloat dbox3(vec3 x, vec3 b)\n{\n  b = abs(x) - b;\n  return length(max(b,0.))\n         + min(max(b.x,max(b.y,b.z)),0.);\n}\n\nfloat setStateF(ivec2 index, ivec2 where, float oldState, float newState)\n{\n    return all(equal(index, where)) ? newState : oldState;\n}\n\n// Distance to star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi/N,\n        p0 = acos(x.x/length(x)),\n        p = mod(p0, d);\n    vec2 a = mix(R,R.yx,mod(round((p-p0)/d),2.)),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n    return dot(length(x)*vec2(cos(p),sin(p))-p1,ff.yx*c.zx)/length(ff);\n}\n\nfloat dhexagonpattern(vec2 p) \n{\n    vec2 q = vec2(p.x*1.2, p.y + p.x*.6),\n        qi = floor(q),\n        pf = fract(q);\n    float v = mod(qi.x + qi.y, 3.);\n    \n    return dot(step(pf.xy,pf.yx), 1.-pf.yx + step(1.,v)*(pf.x+pf.y-1.) + step(2.,v)*(pf.yx-2.*pf.xy));\n}\n\n// x: material\n// y: distance\n// z: reflectivity\nvec3 add(vec3 a, vec3 b)\n{\n    if(a.y < b.y) return a;\n    return b;\n}\n\n//vec3 hsv2rgb(vec3 cc)\n//{\n//    vec4 K = vec4(1., 2. / 3., 1. / 3., 3.);\n//    vec3 p = abs(fract(cc.xxx + K.xyz) * 6. - K.www);\n//    return cc.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), cc.y);\n//}\n\nvec2 rgb2sv(vec3 cc)\n{\n    vec4 K = vec4(0., -1. / 3., 2. / 3., -1.),\n        p = mix(vec4(cc.bg, K.wz), vec4(cc.gb, K.xy), step(cc.b, cc.g)),\n        q = mix(vec4(p.xyw, cc.r), vec4(cc.r, p.yzx), step(p.x, cc.r));\n    return vec2((q.x - min(q.w, q.y)) / (q.x + 1.e-10), q.x);\n}\n\n\n\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n//#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n//#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "buffer_d_code": "// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n \n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb2(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 fragment = texture(iChannel1, uv);\n    vec3 hsv = rgb2hsv(fragment.rgb);\n    float rad = (iTime/2.0) + (hsv.z*6.28);\n    vec2 off = vec2(sin(rad), cos(rad)) / (iResolution.xy / vec2(max(hsv.y,hsv.z)*3.14));\n    hsv.x += abs(sin(iTime/11.0 + ((iMouse.x/iResolution.x)*6.28))*max(iMouse.y/iResolution.y,hsv.z*hsv.z));\n    hsv.y = max(hsv.y, min(hsv.z, 0.75));\n    fragColor = mix(texture(iChannel0, vec2(uv.x + off.x, uv.y + off.y)), vec4(hsv2rgb2(hsv), 0.1), hsv.y*0.075);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lV3zm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 146, 166, 166, 245], [247, 247, 270, 270, 410], [412, 480, 537, 646, 3654]], "test": "untested"}
{"id": "slKGRw", "name": "Fork 4-Substanc guil 040", "author": "guil", "description": "Forward advected compressible fluid simulation.\nFork of \"4-Substance\" by wyatt. https://www.shadertoy.com/view/3lffzM", "tags": ["fluid"], "likes": 10, "viewed": 324, "published": 3, "date": "1637413614", "time_retrieved": "2024-07-30T18:47:09.731722", "image_code": "// Fork of \"4-Substance\" by wyatt. https://www.shadertoy.com/view/3lffzM\n// 2020-08-01 02:57:11\n\nMain {\n    vec4\n        n = A(U+vec2(0,1)),\n        e = A(U+vec2(1,0)),\n        s = A(U-vec2(0,1)),\n        w = A(U-vec2(1,0));\n    vec3 norm = \n        normalize(vec3(e.z*e.w-w.z*w.w,n.z*n.w-s.z*s.w,10)),\n        ref = reflect(vec3(0,0,-1),norm);\n   \n\tvec4 a = A(U);\n    Q = 2.*a.w*vec4(.6,.6,1,1)+a.z*vec4(0,0,0,0);\n\tQ *= 1.+0.5*norm.x;\n    if (U.x < 0.2*R.x&&U.y < 0.5*R.y) Q = vec4(0.5);\n    if (U.x < 0.4*R.x&&U.y < 0.3*R.y) Q = vec4(0.5);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n\n#define Main void mainImage(out vec4 Q, in vec2 U)\n\n#define r 1.2\n#define h 3\n#define k 3", "buffer_a_code": "Main {\n    if (iFrame%2<1) {//Reintegration\n        Q = vec4(0);\n        for (int x = -h; x <= h; x++)\n        for (int y = -h; y <= h; y++)\n        {\n            vec2 u = vec2(x,y);\n            vec4 a = A(U+u);\n            vec2 w1 = clamp(U+u+a.xy-0.5*r,U - 0.5,U + 0.5),\n                 w2 = clamp(U+u+a.xy+0.5*r,U - 0.5,U + 0.5);\n            float m = (w2.x-w1.x)*(w2.y-w1.y)/(r*r);\n            Q.xyz += m*a.w*a.xyz;\n            Q.w += m*a.w;\n        }\n        if (Q.w>0.)\n            Q.xyz/=Q.w;\n        //Boundaries\n        if (iFrame < 1) \n            Q = vec4(0,0,.5,0);\n            \n        if (length(U-vec2(.02,.9)*R)<.025*R.y)Q.xw = vec2(.5);\n        if (iMouse.z>0.&&length(U-iMouse.xy)<20.) Q.yw = vec2(-1.5,.5);\n        if (U.x<1.||U.y<1.) Q.xy *= 0.;\n        if (U.x < 0.2*R.x&&U.y < 0.5*R.y) Q.xy *= 0.,Q.z=10.;\n        if (U.x < 0.4*R.x&&U.y < 0.3*R.y) Q.xy *= 0.,Q.z=10.;\n        if (R.x-U.x<1.||R.y-U.y<1.)Q.zw *=0.;\n    } else {//Simulation\n    \tQ = A(U);vec4 q = Q;\n    for (int x = -k; x<=k; x++)\n\tfor (int y = -k; y<=k; y++)\n    //if (abs(x)!=abs(y))\n    if (x!=0 || y!=0)\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u);\n        u = u/dot(u,u);\n        Q.xy -= q.w*0.25*a.w*(a.w*a.z-1.)*u;//force               \n    \tQ.z -= q.w*0.25*a.w*(dot(u,a.xy-q.xy));\n    }\n    if (Q.w < 1e-2) Q.z *= 0.9;\n    Q.y -= 4e-2*Q.w;//gravity\n    \n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slKGRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ftKGzm", "name": "Drink The Water", "author": "Jabo", "description": "Drink the Water", "tags": ["2d", "sdf", "flag", "pride"], "likes": 5, "viewed": 228, "published": 3, "date": "1637413240", "time_retrieved": "2024-07-30T18:47:10.703124", "image_code": "// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return length(p)-r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdTriangle( in vec2 p )\n{ \n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0; p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\n// modified https://www.shadertoy.com/view/ldBGDc\nfloat spiral(vec2 m, float t) {\n\tfloat r = pow(length(m) / 0.75, 3.5) * 0.75;\n\tfloat a = atan(m.x, m.y);\n    float v = sin(48.*(sqrt(r)-0.0625*a-.05*t));\n\treturn clamp(v,0.,1.);\n}\n\n// adapted for webgl https://www.ronja-tutorials.com/post/041-hsv-colorspace/#rgb-to-hsv-conversion\nvec3 hue2rgb(float hue) {\n    hue = fract(hue); //only use fractional part of hue, making it loop\n    float r =      abs(hue * 6. - 3.) - 1.; //red\n    float g = 2. - abs(hue * 6. - 2.);    //green\n    float b = 2. - abs(hue * 6. - 4.);  //blue\n    vec3 rgb = vec3(r,g,b); //combine components\n    rgb = clamp(rgb, 0., 1.); //saturate\n    return rgb;\n}\nvec3 hsv2rgb(vec3 hsv)\n{\n    vec3 rgb = hue2rgb(hsv.x); //apply hue\n    rgb = mix(vec3(1.0), rgb, hsv.y); //apply saturation\n    rgb = rgb * hsv.z; //apply value\n    return rgb;\n}\n\nvec3 scene(vec2 fragCoord, float iTime) {\n    vec3 col = vec3(0.5);\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    float radius = 0.8 + 0.1*cos(iTime)*cos(0.1*iTime);\n\n\tfloat d = sdCircle(p, radius);\n    \n    // stripes\n    float distortion = 6.0*cos(69.0*d/2.0 + cos(iTime))*clamp(sin(4.+0.09*iTime),0.,1.) * (d + .5) / iResolution.y;\n    float fraction = clamp((1.0 - p.y)/2.0+distortion, 0.01, 1.0);\n    float stripe = clamp(floor(fraction * 6.0) / 6.0, 0.0, 1.0);\n      // upper 3: mix(-0.06, 0.65, stripe)\n      // lower 3: mix(-0.1, 0.91, stripe)\n    float stripeHue1 = stripe < 0.5 ? mix(-0.06, 0.65, stripe) : mix(-0.1, 0.91, stripe);\n    stripe += 1./6.;\n    float stripeHue2 = stripe < 0.5 ? mix(-0.06, 0.65, stripe) : mix(-0.1, 0.91, stripe);\n    float stripeHue = mix(stripeHue1, stripeHue2, smoothstep(stripe - 0.003, stripe + 0.003, fraction - 0.0005));\n    float stripeSaturation = mix(0.95, 0.45, pow(clamp(sin(stripe * 6. + 0.4*iTime),0.,1.),24.)*clamp(2.*sin(5.+ 0.031*iTime),0.,1.));\n    col = hsv2rgb(vec3(clamp(stripeHue,0.001, 0.75), stripeSaturation, 0.95));\n    if(iMouse.z > 0.001) {\n        // old method has no smoothstep to reduce aliasing\n        float stripe = (floor(clamp((1.0 - p.y)/2.0+distortion, 0.01, 1.0) * 6.0) / 6.0);\n      // upper 3: mix(-0.06, 0.65, stripe)\n      // lower 3: mix(-0.1, 0.91, stripe)\n        float stripeHue = stripe < 0.5 ? mix(-0.06, 0.65, stripe) : mix(-0.1, 0.91, stripe);\n        col = hsv2rgb(vec3(clamp(stripeHue,0.001, 0.75), 0.95, 0.95));\n    }\n    \n    // vingette glow\n    col = mix(col, col * 0.95 + 0.2 * exp(-8.0*abs(d)), 0.5 + 0.5*cos(0.7*iTime));\n    // ripples\n\tcol = mix(col, col * cos(69.0*d + 4.2*cos(iTime)), clamp(0.1*cos(3.0+0.05*iTime),0.0,1.0));\n    // spiral\n    if ( d < 0.0 )\n    {\n        vec2 uv = vec2(0.9, 0.5) - fragCoord.xy / iResolution.y;\n        float s = spiral(uv, iTime);\n        s = smoothstep(0.0, 0.05, s);\n        col = vec3(s);\n        // droplet\n        vec2 p2 = p * (0.95 + 0.05 * sin(0.7*iTime));\n        float d2 = min(sdCircle(p2+vec2(0.0,0.1), 0.3), sdTriangle((p2-vec2(0.0,0.2))*3.65)) - 0.01;\n        if (d2 < 0.005 )\n        {\n            col = mix(hsv2rgb(vec3(0.60, 0.95, 0.95)), col, smoothstep(0.0, 0.005, d2));\n            // reflection\n            float d3 = opSmoothSubtraction(\n                sdCircle(p2+vec2(0.2,-0.1), 0.46),\n                sdCircle(p2+vec2(0.0,0.1), 0.24),\n                0.02\n            );\n            d3 *= 1.2;\n            if(d3 < 0.005)\n            {\n                col = mix(vec3(1), col, smoothstep(0.0, 0.005, d3));\n            }\n            \n        }\n    }\n    // outer border\n    col = mix( col, vec3(0.0), 1.0-smoothstep(0.0,0.005, abs(d) - 0.02) );\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float abberation = 0.06*sin(0.033*iTime);\n    vec3 col = vec3(0);\n    // yes temporal chromatic abberation makes no sense, but we don't have to make sense\n\tcol += scene(fragCoord, iTime - abberation) * vec3(.8,.1,.1);\n    col += scene(fragCoord, iTime             ) * vec3(.1,.8,.1);\n    col += scene(fragCoord, iTime + abberation) * vec3(.1,.1,.8);\n\n\tfragColor = vec4(col,1.0);\n}\n\n// c9558532c93019c667e3fc5e14532d21", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftKGzm.jpg", "access": "api", "license": "mit", "functions": [[1044, 1095, 1137, 1137, 1163], [1165, 1216, 1247, 1247, 1455], [1457, 1506, 1564, 1564, 1664], [1666, 1716, 1747, 1747, 1895], [1897, 1997, 2022, 2022, 2349], [2350, 2350, 2374, 2374, 2529], [2531, 2531, 2572, 2572, 5336], [5338, 5338, 5395, 5395, 5780]], "test": "ok"}
{"id": "7tVGzw", "name": "3D trunchet", "author": "IWBTShyGuy", "description": "Long time...", "tags": ["trunchet"], "likes": 8, "viewed": 352, "published": 3, "date": "1637406725", "time_retrieved": "2024-07-30T18:47:11.611696", "image_code": "// The MIT License\n// Copyright © 2021 IWBTShyGuy\n\n#define rotation3D(n, t) mat3( \\\n    cos(t) + n.x * n.x * (1.0 - cos(t)), n.x * n.y * (1.0 - cos(t)) + n.z * sin(t), n.z * n.x * (1.0 - cos(t)) - n.y * sin(t), \\\n    n.x * n.y * (1.0 - cos(t)) - n.z * sin(t), cos(t) + n.y * n.y * (1.0 - cos(t)), n.y * n.z * (1.0 - cos(t)) + n.x * sin(t), \\\n    n.z * n.x * (1.0 - cos(t)) + n.y * sin(t), n.y * n.z * (1.0 - cos(t)) - n.x * sin(t), cos(t) + n.z * n.z * (1.0 - cos(t))  \\\n)\n\nconst mat3 T0 = rotation3D(normalize(vec3(0, 1, -1)), PI);\nconst mat3 T1 = rotation3D(normalize(vec3(1, 0, 1)), PI);\nconst mat3 T2 = rotation3D(normalize(vec3(0, 1, 1)), PI);\n\n// hexahedron group\nconst mat3[] S = mat3[](\n    mat3(1, 0, 0, 0, 1, 0, 0, 0, 1),\n    T2,\n    T1,\n    T2 * T1,\n    T1 * T2,\n    T2 * T1 * T2,\n    T0,\n    T2 * T0,\n    T1 * T0,\n    T2 * T1 * T0,\n    T1 * T2 * T0,\n    T2 * T1 * T2 * T0,\n    T0 * T1,\n    T2 * T0 * T1,\n    T1 * T0 * T1,\n    T2 * T1 * T0 * T1,\n    T1 * T2 * T0 * T1,\n    T2 * T1 * T2 * T0 * T1,\n    T0 * T1 * T2,\n    T2 * T0 * T1 * T2,\n    T1 * T0 * T1 * T2,\n    T2 * T1 * T0 * T1 * T2,\n    T1 * T2 * T0 * T1 * T2,\n    T2 * T1 * T2 * T0 * T1 * T2\n);\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nvec3 normalTorus(vec3 p, vec2 t) {\n    vec2 q = t.x * normalize(p.xz);\n    return normalize(p - vec3(q.x, 0, q.y));\n}\n\nfloat sdist(in vec3 p, in vec3 q, out vec3 normal, out uint index) {\n    float rand = hash13(floor(p + q));\n    index = uint(rand * 24.0);\n    p = mod(p, 1.0);\n    p = S[index] * (p - 0.5) + 0.5;\n    float dist = sdTorus((p - vec3(0, 0, 0.5)).yzx, vec2(0.5, 0.05));\n    normal = normalTorus((p - vec3(0, 0, 0.5)).yzx, vec2(0.5, 0.05)).zxy;\n    float dist1 = sdTorus((p - vec3(1, 1, 0.5)).yzx, vec2(0.5, 0.05));\n    if (dist > dist1) {\n        dist = dist1;\n        normal = normalTorus((p - vec3(1, 1, 0.5)).yzx, vec2(0.5, 0.05)).zxy;\n    }\n    dist1 = length(p.xy - vec2(0.5)) - 0.05;\n    if (dist > dist1) {\n        dist = dist1;\n        normal = vec3(normalize(p.xy - vec2(0.5)), 0.0);\n    }\n    return dist;\n}\n\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 theta = vec2(0.15, 0.25) * iTime;\n    theta.y = sin(theta.y);\n    Camera camera = newCamera(\n        vec3(0, 0, -iTime * 0.5),\n        vec3(cos(theta.x) * cos(theta.y), sin(theta.y), sin(theta.x) * cos(theta.y)),\n        vec3(0, 1, 0),\n        PI / 4.0,\n        iResolution.x / iResolution.y\n    );\n    Ray ray = cameraRay(camera, fragCoord / iResolution.xy);\n\n    vec3 p = fract(ray.origin);\n    vec3 q = floor(ray.origin);\n    vec3 normal = vec3(0);\n    uint index;\n    for (int i = 0; i < 100; i++) {\n        float dist = sdist(p, q, normal, index);\n        if (dist < 0.00001) break;\n        p += dist * ray.direction;\n    }\n    normal = inverse(S[index]) * normal;\n\n    float c = 0.0;\n    float rDist = length(p);\n    if (rDist < 12.0) {\n        c = -dot(normal, ray.direction);\n    }\n    fragColor = vec4(c, c, c, clamp(rDist, 0.0, 12.0));\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    \n// smart anti-aliasing\n// reference: https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n\n// If defined, Activate AA, level: 2 or 3\n#define AA 2\n\n// If defined, visualize anti-aliased pixels.\n//#define VISUALIZE_AA\n#ifdef AA\n    if (fwidth(O.w) > 0.1) {\n        vec4 o;\n#if (AA == 2)\n        for (int k = 0; k < 4; k++) {\n              mainImage0(o,U + (vec2(k % 2, k / 2) - 0.5) / 1.5);\n              O += o;\n        }\n        O /= 5.0;\n#elif (AA == 3)\n        for (int k = 0; k < 9; k += k == 3 ? 2 : 1 ) {\n              mainImage0(o, U + vec2(k % 3 - 1, k / 3 - 1) / 3.0);\n              O += o;\n        }\n        O /= 9.0;\n#endif\n#ifdef VISUALIZE_AA\n        O = vec4(1);\n    } else {\n        O = vec4(0,0,0,1);\n#endif\n    }\n#endif\n\n    O.w = 1.0;\n}", "image_inputs": [], "common_code": "const float PI = 3.141592653;\n\nstruct Camera {\n    vec3 position;\n    vec3 direction;\n    vec3 up_direction; // not require dot(direction, up_direction) == 0\n    float fov;\n    float aspect; // x / y\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nCamera newCamera(vec3 position, vec3 direction, vec3 up_direction, float fov, float aspect) {\n    Camera camera;\n    camera.position = position;\n    camera.direction = direction;\n    camera.up_direction = up_direction;\n    camera.fov = fov;\n    camera.aspect = aspect;\n    return camera;\n}\n\n// perspective camera ray, uv = fragCoord / iResolution.xy\n// cf: https://qiita.com/aa_debdeb/items/301dfc54788f1219b554\nRay cameraRay(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float radian = camera.fov;\n    float h = tan(radian * 0.5);\n    float w = h * camera.aspect;\n    vec3 right = normalize(cross(camera.direction, camera.up_direction));\n    vec3 up = normalize(cross(right, camera.direction));\n    vec3 direction = normalize(right * w * uv.x + up * h * uv.y + camera.direction);\n    Ray ray;\n    ray.origin = camera.position;\n    ray.direction = direction;\n    return ray;\n}\n\n\n// Hash without Sine https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tVGzw.jpg", "access": "api", "license": "mit", "functions": [[1165, 1214, 1245, 1245, 1314], [1316, 1316, 1350, 1350, 1433], [1435, 1435, 1503, 1503, 2148], [2150, 2150, 2206, 2206, 3063]], "test": "untested"}
{"id": "NtV3zw", "name": "Hexagon Molecule Pattern", "author": "Shane", "description": "A minimal abstract geometric representation of a molecular structure, but basically just a simple hexagonal grid pattern. :)", "tags": ["2d", "grid", "hexagon", "vector", "pattern", "art", "molecule"], "likes": 36, "viewed": 693, "published": 3, "date": "1637402033", "time_retrieved": "2024-07-30T18:47:12.412554", "image_code": "/*\n\n\tHexagon Molecule Pattern\n\t------------------------\n    \n    This is a minimal abstract geometric representation of a molecular structure, \n    or to put it another way, it's another typical hexagon grid based pattern. :)\n    \n    Sometimes, I like to take a break from coding things that require thinking and\n    do something easy. Variations on this particular pattern are everywhere, \n    especially in the world of stock imagery. The basic vector style I've chosen is \n    even more of a cliche, but it's simple and effective.\n\n\tThere are several ways to produce a pattern like this, but since it's just a\n    basic 2D overlay example that isn't taxing on the GPU, I've chosen the most direct \n    one, which is to produce a hexagonal grid, then iterate through all six sides and \n    vertices of the cells that have been flagged for rendering. There's definitely \n    better ways to go about it, like using polar coordinates, etc. If you only wanted \n    to render random sides, then a triangle grid would probably make things easier.\n    \n    I almost rendered this in offset vertex form, but decided to keep things simple.\n    However, that's always an option at a later date. By the way, I've put in some\n    \"defines\" to change the overall color scheme if green's not your thing. :)\n\n\t\n    Other Hexagonal Pattern Examples:\n\n\n\tdemocapsid -- remaindeer \n\thttps://www.shadertoy.com/view/sltGDj\n\n    sci-fi hexagons  -- laserdog \n\thttps://www.shadertoy.com/view/Mlcczr\n\n    Hexagons - distance -- iq \n    https://www.shadertoy.com/view/Xd2GR3\n    \n    Berry stairs - duvengar\n    https://www.shadertoy.com/view/Ns2GRz\n    \n\n*/\n\n\n// Color scheme - Blue: 0, Red: 1, Green 2.\n#define COLOR 2\n\n// Greyscale background.\n//#define GREYSCALE\n\n// Show the hexagon grid that the pattern is based on...\n// Probably a little redundant in this case, but it's there.\n//#define SHOW_GRID\n\n#define FLAT_TOP\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n\nfloat hash21(vec2 p){ \n    \n    return fract(sin(dot(p, vec2(27.619, 57.643)))*43758.5453); \n    \n    /*\n    // Attempting to fix accuracy problems on some systems by using\n    // a slight variation on Dave Hoskins's hash formula, here:\n    // https://www.shadertoy.com/view/4djSRW\n    vec3 p3 = fract(vec3(p.xyx)*.1031);\n    p3 += dot(p3, p3.yzx + 43.123);\n    return fract((p3.x + p3.y)*p3.z);\n    */\n    \n    /*\n    // IQ's vec2 to float hash.\n    // An accuracy hack for this particular example. Unfortunately, \n    // \"1. - 1./3.\" is not always the same as \"2./3.\" on a GPU.\n    p = floor(p*32768.)/32768.;\n    return fract(sin(dot(p, vec2(27.617, 57.743)))*43758.5453); \n    */\n}\n\n\n// IQ's box formula.\nfloat sBox(in vec2 p, in vec2 b){\n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// A box between points. Here's it's used to draw lines, but it has\n// other uses.\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew){\n    \n    float ang = atan(b.y - a.y, b.x - a.x);\n    //p = rot2(3.14159/6.)*(p - mix(a, b, .5));\n    p = rot2(ang)*(p - mix(a, b, .5));\n    \n   vec2 l = vec2(length(b - a), ew);\n   return sBox(p, (l + ew)/2.) ;\n    \n   //vec2 l = abs(b - a) + ew/2.;\n   //return sBox(p - vec2(mix(a.x, b.x, .5), mix(a.y, b.y, .5)), (l + ew)/2.) ;\n}\n\n\n// Flat top hexagon, or pointed top.\n#ifdef FLAT_TOP\nconst vec2 s = vec2(1.732, 1);\n#else\nconst vec2 s = vec2(1, 1.732);\n#endif\n\n// Hexagon vertex IDs. They're useful for neighboring edge comparisons, etc.\n// Multiplying them by \"s\" gives the actual vertex postion.\n#ifdef FLAT_TOP\n// Vertices: Clockwise from the left.\n                     \n// Multiplied by 12 to give integer entries only.\nconst vec2[6] vID = vec2[6](vec2(-4, 0), vec2(-2, 6), vec2(2, 6), \n                      vec2(4, 0), vec2(2, -6), vec2(-2, -6)); \n\nconst vec2[6] eID = vec2[6](vec2(-3, 3), vec2(0, 6), vec2(3), \n                      vec2(3, -3), vec2(0, -6), vec2(-3));\n\n#else\n// Vertices: Clockwise from the bottom left. -- Basically, the ones \n// above rotated anticlockwise. :)\n\n// Multiplied by 12 to give integer entries only.\nconst vec2[6] vID = vec2[6](vec2(-6, -2), vec2(-6, 2), vec2(0, 4), \n                      vec2(6, 2), vec2(6, -2), vec2(0, -4));\n\nconst vec2[6] eID = vec2[6](vec2(-6, 0), vec2(-3, 3), vec2(3, 3), vec2(6, 0), \n                      vec2(3, -3), vec2(-3, -3));\n\n#endif\n\n// Hexagonal bound: Not technically a distance function, but it's\n// good enough for this example.\nfloat getHex(vec2 p){\n    \n    // Flat top and pointed top hexagons.\n    #ifdef FLAT_TOP\n    return max(dot(abs(p.xy), s/2.), abs(p.y*s.y));\n    #else   \n    return max(dot(abs(p.xy), s/2.), abs(p.x*s.x));\n    #endif\n}\n\n// Hexagonal grid coordinates. This returns the local coordinates and the cell's center.\n// The process is explained in more detail here:\n//\n// Minimal Hexagon Grid - Shane\n// https://www.shadertoy.com/view/Xljczw\n//\nvec4 getGrid(vec2 p){\n    \n    vec4 ip = floor(vec4(p/s, p/s - .5));\n    vec4 q = p.xyxy - vec4(ip.xy + .5, ip.zw + 1.)*s.xyxy;\n    // The ID is multiplied by 12 to account for the inflated neighbor IDs above.\n    return dot(q.xy, q.xy)<dot(q.zw, q.zw)? vec4(q.xy, ip.xy*12.) : vec4(q.zw, ip.zw*12. + 6.);\n    //return getHex(q.xy)<getHex(q.zw)? vec4(q.xy, ip.xy) : vec4(q.zw, ip.zw + .5);\n\n}\n\n// Using random vertex IDs to produce animated variable sized vertices.\nvec4 getSz(vec4 p, int i){\n\n    // Sizes for each side of the edge.\n    vec2 sz = vec2(hash21(p.zw + vID[i]), hash21(p.zw + vID[(i + 1)%6]))*.4 + .6;\n    \n    // Blinking animation variables.\n    vec2 szB = vec2(hash21(p.zw + vID[i] + .1), hash21(p.zw + vID[(i + 1)%6] + .1));\n    szB = smoothstep(.9, .98, sin(6.2831*szB + iTime*1.)*.5 + .5);\n \n    // Final sizes.\n    sz *= 1. + szB*.1;\n    \n    // Returning the two sizes and two blinking factors.\n    return vec4(sz, szB);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    \n    // Aspect correct screen coordinates.\n    float res = min(iResolution.y, 800.);\n    vec2 uv = (fragCoord.xy - iResolution.xy*.5)/res;\n    \n    // Global scale factor.\n    const float sc = 5.;\n    // Smoothing factor.\n    float sf = sc/res;\n    \n    // Scene rotation, scaling and translation.\n    mat2 sRot = rot2(3.14159/12.); // Scene rotation.\n    vec2 camDir = sRot*normalize(s); // Camera movement direction.\n    vec2 ld = sRot*normalize(vec2(1, -1)); // Light direction.\n    vec2 p = sRot*uv*sc + camDir*iTime/3.;\n    \n    \n    \n    \n    // Hexagonal grid coordinates.\n    vec4 p4 = getGrid(p);\n    // Hexagonal grid coordinates for the shadow.\n    vec4 p4Sh = getGrid((p - ld*.15));\n\n   \n    \n        \n    // Rendering the grid boundaries, or just some black hexagons in the center.\n    float gHx = getHex(p4.xy);\n    \n    \n    float edge = 1e5, vert = 1e5;\n    float shad = 1e5;\n    \n    // Edge width.\n    float ew = .025;\n    \n    // Random threshold.\n    float rndTh = .4;\n    #ifdef SHOW_GRID \n    // Increase the threshold so that all hexagons are rendered.\n    rndTh = 1.;\n    #endif\n    \n    float gSz = 1e5;\n    \n    // Random value for the top layer cell and the shadow cell.\n    float rnd = hash21(p4.zw);\n    float rndSh = hash21(p4Sh.zw);\n    \n    vec2 sDiv12 = s/12.;\n     \n    // Iterate through all six sides of the hexagon cell.\n    for(int i = min(0, iFrame); i<6; i++){\n   \n\n        // If the random cell ID is under a certain threshold, render\n        // from both the cell and it's neighbor's perspective.\n        \n        float rndN = hash21((p4.zw + eID[i]*2.));\n        if(rnd<rndTh || rndN<rndTh){\n        \n            // Produce the edge for this particular side.\n            edge = min(edge, lBox(p4.xy, vID[i]*sDiv12, vID[(i + 1)%6]*sDiv12, ew));\n            \n            // Edge sizes and associated animation factors.\n            vec4 sz = getSz(p4, i);\n            \n            // Vertices at the ends of this edge.\n            float v1 = length(p4.xy - vID[i]*sDiv12) - ew*6.*sz.x;\n            float v2 = length(p4.xy - vID[(i + 1)%6]*sDiv12) - ew*6.*sz.y;\n            \n            // Save the blinking factor for vertex colorization.\n            if(min(v1, v2)<vert) gSz = v1<v2? sz.z : sz.w;\n            \n            // Vertices for this edge.\n            vert = min(vert, min(v1, v2));                                                 \n            \n        }\n        \n       \n        // Doing the same for the shadow.        \n        rndN = hash21((p4Sh.zw + eID[i]*2.));\n        if(rndSh<rndTh || rndN<rndTh){\n        \n            // Shadow edge.\n            shad = min(shad, lBox(p4Sh.xy, vID[i]*sDiv12, vID[(i + 1)%6]*sDiv12, ew));\n            \n            vec4 sz = getSz(p4Sh, i);\n            \n            shad = min(shad, min(length(p4Sh.xy - vID[i]*sDiv12) - ew*6.*sz.x, \n                                 length(p4Sh.xy - vID[(i + 1)%6]*sDiv12) - ew*6.*sz.y));\n            \n        }\n\n    }\n    \n    // The scene color.\n    // Rotating the gradient to coincide with the light direction angle.\n    vec2 ruv = rot2(atan(ld.y, ld.x) + 3.14159/2.)*uv;\n    //\n    // Blue gradient background.\n    vec3 bg = mix(vec3(.7, .8, 1), vec3(.7, .9, 1), smoothstep(.3, .7, ruv.y*.5 + .5));\n    //\n    #if COLOR == 1\n    bg = bg.zyx; // Redish background.\n    #elif COLOR == 2\n    bg = bg.yzx; // Powder lime background.\n    #endif\n    \n    // Saving the background gradient color sans pattern overlay.\n    vec3 bgColor = bg;\n    \n    \n    /*\n    // Line pattern. Not used.\n    ruv = rot2(-3.14159/6.)*p;\n    float lSc = (30.*1.732/sc);\n    float pat = (abs(fract(ruv.y*lSc) - .5) - .25)/lSc;\n    //pat = max(pat, -(pat + .25/lSc));\n    */\n    \n    // A higher frequency hexagon pattern for the background.\n    vec4 pat4 = getGrid(p*3.);\n    float patHx = (getHex(pat4.xy) - .4)/3.;\n    \n    // Subtly blend the hexagon pattern with the background.\n    bg = mix(bg, mix(bgColor, bgColor*bgColor*.85, .35), (1. - smoothstep(0., sf, patHx)));\n    //bg = mix(bg, bg*.95, (1. - smoothstep(0., sf, abs(patHx + .005) - .01))); // Borders.\n    //bg = mix(bg, vec3(0), (1. - smoothstep(0., sf, pat))*.07);\n    \n    \n    // Greyscale background, if desired.\n    #ifdef GREYSCALE\n    bg = vec3(1)*dot(bg, vec3(.299, .587, .114));\n    #endif\n    \n    \n    // Render the shadows onto the background.\n    //shad = max(shad, -(shad + .04));\n    vec3 col = mix(bg, vec3(0), (1. - smoothstep(0., sf, shad))*.25);\n    \n    // Rendering the edges.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, edge)));\n    \n    // Rendering the vertices.\n    vec3 svBg = bgColor;\n    svBg = mix(svBg, vec3(1), .75);\n    svBg = mix(svBg, min(pow(bgColor, vec3(6))*3., 1.), gSz*.65);\n    // Vertex stroke and centers.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, vert)));\n    col = mix(col, svBg, (1. - smoothstep(0., sf, vert + .04)));\n    \n    \n    // Vignette.\n    //uv = fragCoord/iResolution.xy;\n    //col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./16.);\n\n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtV3zw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1903, 1936, 1958, 1958, 2016], [2020, 2020, 2041, 2041, 2705], [2708, 2729, 2762, 2762, 2841], [2843, 2926, 2971, 2971, 3303], [4381, 4480, 4501, 4548, 4698], [4700, 4917, 4938, 4938, 5309], [5311, 5383, 5409, 5450, 5861], [5864, 5864, 5918, 5966, 10987]], "test": "untested"}
{"id": "flVGzm", "name": "Pythagorean Square Tiling 2", "author": "gelami", "description": "Pythagorean Square Tiling 2: Electric Boogaloo\nA much simpler implementation, using two grids and computing the tile ID first", "tags": ["square", "tiling", "pythagorean"], "likes": 33, "viewed": 668, "published": 3, "date": "1637395168", "time_retrieved": "2024-07-30T18:47:13.321125", "image_code": "\n// Pythagorean Square Tiling 2\n// https://www.shadertoy.com/view/flVGzm\n\n/*\n * The previous version was too large and messy for my liking,\n * then I realized using two grids of squares would be much easier to implement\n * I computed the tile ID first instead of the UV, which simplifies a lot of things\n * Then the UV is derived from the ID instead.\n */\n\n// Defines\n\n//#define SHOW_UV\n//#define SHOW_ID\n//#define ALT_ID\n\n//#define ALT_ROTATE\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // Angle of rotation\n    float a = mod(iTime * 0.8, TAU);\n    // Mod 2 of the quadrant of the angle\n    float q = mod(round(a / (TAU / 4.)), 2.);\n    \n    vec2 p = uv * 2.;\n    \n    #ifndef ALT_ROTATE\n    p *= rot2D(a);\n    #endif\n    \n    // First grid\n    vec2 p1 = fract(p) - 0.5;\n    // Get sign before inverse rotation\n    vec2 sp = sign(p1);\n    \n    // Second grid\n    vec2 p2 = (abs(p1) - 0.5) * sp;\n    \n    // Initial tile ID\n    vec2 id = (p - p1) * 2.;\n    \n    p1 *= rot2D(-a);\n    p2 *= rot2D(-a);\n    \n    // Sign after rotation\n    vec2 sp2 = sign(p1);\n    \n    // Size of the squares\n    vec2 s = abs(vec2(cos(a), sin(a))) * 0.5;\n    \n    // Distance to the two square grids + outside mask\n    vec3 d1 = sdBox(p1, s.x);\n    vec3 d2 = sdBox(p2, s.y);\n    \n    // Mask of which square is which\n    float m = q > 0.5 ? step(0., d1.x) : step(d2.x, 0.);\n    \n    // Tile ID stuff\n    // There probably a simpler way to do this\n    //   S1 = -1 |  1 | -1 |  1 |  1 | -1 |  1 | -1 |\n    // * S2 = -1 | -1 |  1 |  1 | -1 | -1 |  1 |  1 |\n    // ----------------------------------------------\n    //   SS =  1 | -1 | -1 |  1 | -1 |  1 |  1 | -1 |\n    float s1 = mod(ceil(abs((a - PI) / (PI / 4.))), 2.) * 2. - 1.;\n    float s2 = q * 2. - 1.;\n    float ss = s1 * s2 * 2.;\n    \n    id += sp * m;\n    \n    // Diagonals mask\n    float m2 = sat(sign(d1.x) + sign(d2.x));\n    \n    id += d1.yz * sp2 * ss * m2;\n    \n    // Alternative ID\n    #ifdef ALT_ID\n    id = floor(vec2(id.x + id.y, id.y - id.x) - m + .001);\n    #endif\n    \n    // Square size\n    float size = m < 0.5 ? s.x : s.y;\n    \n    // Get the square's coords from the tile ID\n    vec2 puv = (p-id*0.5) / size * rot2D(-a) * 0.5;\n    \n    // Distance inside square\n    vec2 dp = (0.5 - abs(puv)) * size;\n    float d = smin(dp.x, dp.y, .05);\n    \n    vec3 tex = texture(iChannel0, puv).rgb;\n    \n    float px = 1.0 / iResolution.y;\n    vec3 col = vec3(palette(hash12(id))) * smoothstep(1.0 * px, 6.0 * px, d);\n    \n    col *= tex;\n    \n    #ifdef SHOW_UV\n    col = vec3(puv + 0.5, 0);\n    #endif\n    #ifdef SHOW_ID\n    col = vec3(id, 0);\n    #endif\n    \n    // Exposure and tonemapping\n    col *= 2.;\n    col = max(col, vec3(0));\n    col = col / (1. + col);\n    // Gamma correction\n    col = pow(col, vec3(1./2.2));\n    \n    fragColor = vec4(col, 1);\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define PI (acos(-1.))\n#define TAU (2.*PI)\n\n#define sat(x) clamp(x, 0., 1.)\n\nmat2 rot2D(float a)\n{\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n// Cubic smin function\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k - abs(a - b), 0.0 ) / k;\n    return min(a, b) - h*h*h*k * (1.0 / 6.0);\n}\n\n// Chebyshev distance to box + outside mask \nvec3 sdBox( in vec2 p, in float b )\n{\n    vec2 d = abs(p)-b;\n    return vec3( max(d.x, d.y), step(vec2(0), d) );\n}\n\n// Cosine Color Palette\n// https://iquilezles.org/articles/palettes\nvec3 palette( float t )\n{\n    return 0.5 + 0.5*cos( TAU * (1. * t + vec3(.3, .2, .2)) );\n}\n\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n    p = p * 1.1213;\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flVGzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[444, 444, 501, 501, 2885]], "test": "untested"}
{"id": "NlV3zm", "name": "Footwear Design 006", "author": "yasuo", "description": "・Tried to implement the tube outsole.\n・Modefied the previous design upper shape with holes", "tags": ["footwear"], "likes": 3, "viewed": 218, "published": 3, "date": "1637393580", "time_retrieved": "2024-07-30T18:47:14.303498", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define Slice(p,a) dot(p,vec2(cos(a),sin(a)))\n#define S(p,d,b) smoothstep(fwidth(p.y),0.0,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define MATERIAL 0\n\n#define ZERO (min(iFrame,0))\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// IQ's 3D noise function. It's faster than the FBM and enough for me to design.\n// The compile is also faster.\nfloat noise3d( vec3 p )\n{\n    const vec3 s = vec3(27, 111, 57);\n    vec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.); // option\n    h = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdSimpleCylinder(vec3 p, float r, float h){\n    float d = length(p.xz)-r;\n    d = max(abs(p.y)-h,d);\n    return d;\n}\n\nfloat baseOutsole(vec3 p, float h){\n    vec3 prevP = p;\n    \n    p.xz*=Rot(radians(17.0));\n    p.z*=0.4;\n    p.x*=0.57;\n    p.x+=0.03;\n    p.z-=0.07;\n    \n    float d =sdSimpleCylinder(p,0.1,h);\n    \n    p = prevP;\n    p.xy*=Rot(radians(90.0));\n    p.y*=1.5;\n    p.z*=1.2;\n    float d2 = sdCappedCylinder(p-vec3(0.0,0.0,-0.25),h,0.2);\n    d = opSmoothUnion(d, d2,0.13);\n    \n    p = prevP;\n    d = max(abs(p.y)-h,d);\n    \n    return (d)*0.6;\n}\n\nfloat outsole(vec3 p){\n    p.z*=0.9;\n    vec3 prevP = p;\n    \n    float d = baseOutsole(p-vec3(0.0,0.02,0.),0.06);\n    \n    p = prevP;\n    float d2 = baseOutsole(p-vec3(0.0,0.035,0.0),0.035);\n    d = min(d,d2);\n    \n    p = prevP;\n    float a  = radians(4.0);\n    p.y-=0.06;\n    float mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(mask,d);\n    \n    p = prevP;\n    a  = radians(-8.0);\n    p.y+=0.07;\n    mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(-mask,d);\n    \n    p = prevP;\n    a  = radians(10.0);\n    p.y+=0.08;\n    mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(-mask,d);\n    \n    float k = 0.06;\n    p = prevP;\n    p.y*=0.7;\n    p.xz*=Rot(radians(90.0));\n    p.yz*=Rot(radians(90.0));\n    d2 = sdLink(p-vec3(0.0,0.01,-0.04),0.08,0.04,0.015);\n    d = opSmoothUnion(d,d2,k);\n    d2 = sdLink(p-vec3(0.15,0.0,-0.04),0.12,0.04,0.015);\n    d = opSmoothUnion(d,d2,k);\n    d2 = sdLink(p-vec3(-0.15,0.005,-0.04),0.17,0.04,0.015);\n    d = opSmoothUnion(d,d2,k);\n    p.xz*=Rot(radians(-15.0));\n    d2 = sdLink(p-vec3(0.28,0.0,-0.1),0.065,0.04,0.015);\n    d = opSmoothUnion(d,d2,k);\n    \n    p = prevP;\n    p.y*=0.7;\n    p.xz*=Rot(radians(90.0));\n    p.yz*=Rot(radians(90.0));\n    p.xz*=Rot(radians(10.0));\n    d2 = sdLink(p-vec3(-0.28,-0.02,-0.08),0.14,0.04,0.015);\n    d = opSmoothUnion(d,d2,k);\n    d2 = sdLink(p-vec3(-0.38,-0.03,-0.08),0.08,0.02,0.012);\n    d = opSmoothUnion(d,d2,k);\n    \n    return d;\n}\n\n\nfloat upperBase(vec3 p){\n    p.z*=0.9;\n    \n    vec3 prevP2 = p;\n    p.x+=cos(p.y*70.0)*0.005;\n    vec3 prevP = p;\n\n    //p.x*=1.;\n    p.z*=0.8;\n    \n    float d =sdCappedCone(p-vec3(0.0,0.18,-0.15),0.13,0.15,0.06);\n    \n    p = prevP;\n    p.xz*=Rot(radians(15.0));\n    p.yz*=Rot(radians(-6.0));\n    p.x*=1.2;\n    p.z*=0.8;\n    \n    float d2 = sdEllipsoid(p-vec3(-0.05,0.1,0.14),vec3(0.2,0.08,0.2));\n    d = opSmoothUnion(d,d2,0.1);//0.1\n    \n    p = prevP;\n    p.xz*=Rot(radians(0.0));\n    p.x*=1.1;\n    p.z*=0.8;\n    p.yz*=Rot(radians(-35.0));\n\n    d2 = sdEllipsoid(p-vec3(0.0,0.21,-0.1),vec3(0.1,0.04,0.15));\n\n    d = opSmoothUnion(d,d2,0.17);//0.15\n    \n    p = prevP2;\n    p.xy*=Rot(radians(90.0));\n    p.xz*=Rot(radians(18.0));\n    p.y*=1.5;\n    p.z*=1.0;\n    d2 = sdCappedCylinder(p-vec3(-0.1,0.0,-0.2),0.001,0.2);\n    d = opSmoothUnion(d, d2,0.07);\n    \n    p = prevP2;\n    p.xy*=Rot(radians(90.0));\n    p.xz*=Rot(radians(15.0));\n    p.y*=1.3;\n    p.z*=0.99;\n    d2 = sdCappedCylinder(p-vec3(-0.04,0.0,-0.22),0.001,0.2);\n    d = opSmoothUnion(d, d2,0.07);\n    \n    return d;\n}\n\nfloat upper(vec3 p){\n    vec3 prevP = p;\n    float d = upperBase(p);\n    p.x*=1.5;\n    p.y*=1.1;\n    p.z*=1.12;\n    \n    float d2 = upperBase(p-vec3(0.0,0.02,0.0));\n    d = max(-d2,d);\n    \n    p = prevP;\n    \n    p.x*=1.6;\n    p.z*=0.7;\n    \n    d2 =sdCappedCone(p-vec3(-0.01,0.25,-0.1),0.14,0.14,0.09)*0.6;\n    d = max(-d2,d);\n    \n    p = prevP;\n    float a  = radians(8.0);\n    p.y-=0.31;\n    float mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(mask,d);\n    \n    p = prevP;\n    p.y+=0.01;\n    p.z-=0.005;\n    p.yz*=Rot(radians(-12.0));\n    p.x = mod(p.x,0.2)-0.1;\n    p.y = mod(p.y,0.1)-0.05;\n    p.z = mod(p.z,0.2)-0.1;\n    p.x*=0.8;\n    p.y*=2.0;\n    p.z*=0.8;\n    \n    \n    d2 = length(p)-0.05;\n    d = max(-d2,d);\n    \n    p = prevP;\n    p.yz*=Rot(radians(-12.0));\n    p.x*=1.2;\n    p.y*=1.2;\n    p.z*=0.65;\n    d2 = sdTorus(p-vec3(-0.005,0.35,-0.115),vec2(0.1,0.02));\n    \n    d = opSmoothUnion(d,d2,0.04);\n    \n    p = prevP;\n    p.x*=1.4;\n    p.z*=0.75;\n    d2 =sdSimpleCylinder(p-vec3(-0.005,0.35,-0.09),0.1,0.2);\n    d = max(-d2,d);\n    \n    return d*0.8;\n}\n\nvec2 GetDist(vec3 p) {\n    p+=noise3d(p*600.0)*0.0002;\n    vec3 prevP = p;\n    \n    p.y+=0.075;\n    //p.z+=0.1;\n    float d = outsole(p);\n    float d2 = upper(p-vec3(0.0,0.0,0.0));\n    d =  opSmoothUnion(d,d2,0.03);\n    \n    vec2 model = vec2(d,MATERIAL);\n\n    return model;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<3; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,2,-2));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*shadow*occ;\n    diffCol += col*vec3(1.0,1.0,0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 20.)*occ; // spec\n        \n    return diffCol;\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(234.56,789.34));\n    p+=dot(p,p+34.56);\n    return fract(p.x+p.y);\n}\n\nvec3 upperTex(vec2 uv, vec3 col){\n        vec2 prevUV = uv;\n        \n        uv.x+=cos(uv.y*70.0)*0.02+sin(uv.y*50.0)*0.05;\n        float d = -uv.x+0.01;\n        col = mix(col,mix(vec3(0.7,0.2,0.2),vec3(1.0,1.0,0.1),uv.y),S(prevUV,d,0.0));\n\n        return col;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    if(mat == MATERIAL){\n        col = diffuseMaterial(n,rd,p,upperTex(p.yz*0.9,vec3(0.4,0.3,0.1)));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy -.3;\n    \n    vec3 ro = vec3(0, 0, 1.2);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-30.0));\n    if(iMouse.z>0.){\n        ro.yz *= Rot(-m.y*3.14+1.);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.xz *= Rot(radians(-5.0+iTime*20.0));\n        \n        //ro.yz *= Rot(radians(120.0));\n        //ro.xz *= Rot(radians(45.0));\n    }\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n        //col *= exp( -0.038*d.x*d.x*d.x );//fog\n    } else {\n        //col = upperTex(uv,col);\n    }\n    \n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlV3zm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[390, 390, 415, 415, 434], [435, 435, 460, 460, 479], [480, 480, 532, 532, 632], [634, 746, 771, 771, 1116], [1118, 1118, 1154, 1154, 1196], [1198, 1247, 1280, 1280, 1345], [1347, 1396, 1450, 1450, 1552], [1554, 1603, 1655, 1655, 1762], [1764, 1813, 1844, 1844, 1931], [1933, 1982, 2019, 2019, 2102], [2104, 2153, 2212, 2212, 2525], [2527, 2527, 2576, 2576, 2649], [2651, 2651, 2686, 2686, 3094], [3096, 3096, 3118, 3118, 4512], [4515, 4515, 4539, 4539, 5599], [5601, 5601, 5621, 5621, 6675], [6677, 6677, 6699, 6699, 6953], [6955, 6955, 7013, 7013, 7280], [7282, 7282, 7306, 7306, 7507], [7509, 7509, 7551, 7551, 7746], [7748, 7789, 7838, 7838, 8132], [8134, 8134, 8191, 8191, 8810], [8812, 8812, 8834, 8834, 8924], [8926, 8926, 8959, 8959, 9188], [9190, 9190, 9249, 9249, 9374], [9376, 9376, 9433, 9433, 10477]], "test": "untested"}
{"id": "NtVGzm", "name": "Frozen pond surface", "author": "jarble", "description": "An icy fractal pattern.", "tags": ["fractal", "ice", "frost"], "likes": 4, "viewed": 293, "published": 3, "date": "1637382829", "time_retrieved": "2024-07-30T18:47:15.066458", "image_code": "#define ITERS 6\nconst float scale = 2.7;\nconst float scale1 =-1.175;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    float t=0.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/15.0;\n    uv.y += (iTime)/25.0;\n    for(int c=0;c<ITERS;c++){\n        float s1 = scale1*scale;\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            \n            uv= fract(-uv-((vec2(uv.x/scale-uv.y/scale1,uv.y/scale+uv.x/scale1)/(scale))))/scale1;\n            uv.x *= scale1;\n            uv = fract(-uv.yx/s1)*s1;\n            uv.x /= scale1*(1.-1./5.);\n            //uv.y /= -scale1;\n        }\n        col[2] = abs(fract(uv.y)-fract(uv.x));\n        col = ((col+col_prev.yzx))/2.125;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtVGzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 126, 126, 833]], "test": "untested"}
{"id": "ftVGzm", "name": "Girih fractal", "author": "jarble", "description": "This fractal is reminiscent of girih tiles.", "tags": ["fractal", "tree", "ring", "wood"], "likes": 2, "viewed": 242, "published": 3, "date": "1637381857", "time_retrieved": "2024-07-30T18:47:15.885269", "image_code": "//number of iterations\n#define ITERS 6\n\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5/3.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime/2.+uv.x)/10.0);\n    //vec3 random1 = (hash31(3.+t2)-.5)/12.;\n    //vec3 random2 = (hash31(4.+t2)-.5)/12.;\n    //vec3 random3 = (hash31(3.+t2)-vec3(.5))/1.5;\n    //vec3 random4 = (hash31(4.+t2)-vec3(.5))/4.;\n    \n    float offset = 1.5;\n    float scale2 = 1.5;\n    float bend = 1.;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        //float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            \n            for(int k = 0; k < ITERS; k++){    \n                uv /= -scale2;\n                //float bend = 1.+random3[k];\n                //bend = abs(fract((uv.x)*2.)-.5)/2.+1.;\n                //bend = 1.+1./3.;\n                //bend = scale2/1.5;\n                \n                //bend = abs(fract(((uv.x*bend+uv.y/bend)/scale2))-.5)+1.-col.x;\n\n                //uv *= 1.-col.x;\n                uv.yx = triangle_wave(uv.yx-offset,scale)/bend+triangle_wave(uv,scale)*bend;\n                //uv.y *= 1.-col.x;\n                //uv.yx = triangle_wave(uv.yx-offset/1.5,scale)*bend-triangle_wave(uv-offset,scale)/bend;\n\n                //bend += 1./(1.+uv.x+uv.y);\n                //bend = 1./bend;\n                //uv.yx += uv/2.;  \n                bend *= -1.;\n                bend -= 1./3.-col.x;\n                offset += bend;\n            }\n            \n\n            //offset += .5;\n            scale /= 1.5;\n            //scale2 += (col.z+col.x+col.y)/(2.);\n\n\n            col[c] = ((uv.x)-(uv.y)-col[c]);\n            //random2 = col - random2;\n            \n\n        }\n\t}\n    \n    fragColor = vec4(vec3(col/1.),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftVGzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[265, 375, 397, 443, 576], [578, 578, 617, 617, 662], [664, 664, 721, 721, 2609]], "test": "untested"}
{"id": "NtK3Rm", "name": "Tree ring fractal", "author": "jarble", "description": "A fractal that looks like tree rings.", "tags": ["fractal", "tree", "ring", "wood"], "likes": 1, "viewed": 214, "published": 3, "date": "1637376911", "time_retrieved": "2024-07-30T18:47:16.667178", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5/6.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime/2.+uv.x)/10.0);\n    //vec3 random1 = (hash31(3.+t2)-.5)/12.;\n    //vec3 random2 = (hash31(4.+t2)-.5)/12.;\n    //vec3 random3 = (hash31(3.+t2)-vec3(.5))/1.5;\n    //vec3 random4 = (hash31(4.+t2)-vec3(.5))/4.;\n    \n    float offset = .5;\n    float scale2 = 1.5;\n    float bend = 1.;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        //float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            \n            for(int k = 0; k < 6; k++){    \n                uv /= -scale2;\n                //float bend = 1.+random3[k];\n                //bend = abs(fract((uv.x)*2.)-.5)/2.+1.;\n                //bend = 1.+1./3.;\n                //bend = scale2/1.5;\n                \n                //bend = abs(fract(((uv.x*bend+uv.y/bend)/scale2))-.5)+1.-col.x;\n\n                //uv *= 1.-col.x;\n                uv.yx = triangle_wave(uv.yx-offset,scale)/bend+triangle_wave(uv,scale)*bend;\n                //uv.y *= 1.-col.x;\n                //uv.yx = triangle_wave(uv.yx-offset/1.5,scale)*bend-triangle_wave(uv-offset,scale)/bend;\n\n                //bend += 1./(1.+uv.x+uv.y);\n                //bend = 1./bend;\n                uv.yx += uv/2.;  \n                //bend *= -1.;\n                //bend -= 1./3.-col.x;\n            }\n            \n\n            //offset += .5;\n            scale /= 1.+(scale2)*col.x/(8.);\n            scale2 -= (col.x-1.)/(4.);\n\n\n            col[c] = abs((uv.x)-(uv.y));\n            //random2 = col - random2;\n            \n\n        }\n\t}\n    \n    fragColor = vec4(vec3(col*4.),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtK3Rm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [590, 590, 629, 629, 674], [676, 676, 733, 733, 2590]], "test": "untested"}
{"id": "7lGGRw", "name": "Subjective Filtering", "author": "paniq", "description": "demonstrating subjective filtering in 2D, a continuous alternative to volumetric cascades, in which we leverage spherical inversion and hyperbolic mapping to store a properly filtered infinitely continuous surface inside a single texture. ", "tags": ["filter", "inversion", "spherical", "hyperbolic"], "likes": 8, "viewed": 396, "published": 3, "date": "1637366106", "time_retrieved": "2024-07-30T18:47:17.438117", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef SHOW_SOURCE\n    fragColor = vec4(linear_srgb(texelFetch(iChannel0, ivec2(fragCoord/iResolution.y*float(rez)), 0).rgb),1);\n#else\n    vec2 uv = ((fragCoord-0.5)/iResolution.xy)*2.0-1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    uv *= exp(mix(log(8.0),log(60.0*6.0),sin(iTime*0.21)*0.5+0.5));\n    \n    //uv = invert(uv);\n    uv *= rcp_c;\n    \n    //uv = invert(uv);\n    //uv = contract_tanh(uv);\n    uv = contract_rcp(uv);\n    //uv = contract_exp(uv);\n    \n    uv = to_polar(uv);\n    \n    //uv = uv * 0.5 + 0.5;    \n    \n#ifdef INTERPOLATE\n    vec3 col = sample_biquadratic_exact(iChannel0, vec2(rez), uv).rgb;\n#else\n    vec3 col = texelFetch(iChannel0, ivec2(uv*float(rez)), 0).rgb;\n#endif\n    fragColor = vec4(linear_srgb(col),1);\n#endif\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define channel iChannel0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/vec2(rez)*2.0-1.0;\n    if (max(abs(uv.x),abs(uv.y)) > 1.0) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    uv = from_polar(uv*0.5+0.5);\n    \n    //uv = expand_tanh(uv);\n    uv = expand_rcp(uv);\n    //uv = expand_exp(uv);    \n    \n    uv /= rcp_c;\n    //uv = invert(uv);\n\n    uv.x *= 9.0/16.0;\n    uv /= 8.0;\n    // demonstrate grid under movement\n    uv.x += iTime*0.1;\n    uv = uv*0.5 + 0.5;\n    \n    vec3 col = vec3(0.0);\n    const int L = 7;\n    for (int i = 0; i < L; ++i) {\n        col += texture(channel, uv/pow(2.0,float(i)), 0.5).rgb;\n    }\n    col /= float(L);    \n    col = clamp((col - 0.3)*2.0 + 0.3, 0.0, 1.0);\n    fragColor = vec4(srgb_linear(col),1);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// when defined, show raw compressed texture\n//#define SHOW_SOURCE\n// when undefined, uses nearest neighbor interpolation\n#define INTERPOLATE\n\n// texture resolution\nconst int rez = 256;\n// logarithmic distribution\nconst float rcp_c = 1.0/16.0;\n\nvec3 decompose_normal_Linf(vec2 p) {\n    float r = max(abs(p.x),abs(p.y));\n    //float r = length(p);\n    return vec3(p/r, r);\n}\n\nvec3 decompose_normal_L2(vec2 p) {\n    float r = length(p);\n    return vec3(p/r, r);\n}\n\n//#define decompose_normal decompose_normal_Linf\n#define decompose_normal decompose_normal_L2\n\nvec2 from_polar(vec2 p) {\n    float a = p.x*radians(360.0);\n    p = vec2(cos(a),sin(a)) * p.y;\n    return p;    \n}\n\nvec2 to_polar(vec2 p) {\n    float r = length(p);\n    return vec2(atan(-p.y, p.x)/radians(360.0) + 0.5, r);\n}\n\nvec2 invert(vec2 p) {\n    vec3 pn = decompose_normal_L2(p);\n    return pn.xy * (1.0 / pn.z);\n}\n\n// normal to infinity\nvec2 expand_tanh(vec2 p) {\n    vec3 pn = decompose_normal(p);\n    return pn.xy * atanh(pn.z);\n}\n\n// infinity to normal\nvec2 contract_tanh(vec2 p) {\n    vec3 pn = decompose_normal(p);\n    return pn.xy * tanh(pn.z);\n}\n\nvec2 expand_rcp(vec2 p) {\n    vec3 pn = decompose_normal(p);\n    pn.z = min(pn.z, 1.0);\n    return pn.xy * (pn.z / (1.0 - abs(pn.z)));\n}\n\nvec2 contract_rcp(vec2 p) {\n    vec3 pn = decompose_normal(p);\n    return pn.xy * (pn.z / (1.0 + abs(pn.z)));\n}\n\nvec2 expand_rcp(vec2 p, float c) {\n    vec3 pn = decompose_normal(p);\n    pn.z = min(pn.z, 1.0);\n    return pn.xy * c * (pn.z / (1.0 - abs(pn.z)));\n}\n\nvec2 contract_rcp(vec2 p, float c) {\n    vec3 pn = decompose_normal(p);\n    return pn.xy * (pn.z / (c + abs(pn.z)));\n}\n\nvec2 expand_exp(vec2 p) {\n    vec3 pn = decompose_normal(p);\n    return pn.xy * -log2(1.0-pn.z);\n}\n\nvec2 contract_exp(vec2 p) {\n    vec3 pn = decompose_normal(p);\n    return pn.xy * (1.0 - exp2(-pn.z));\n}\n\n//---------------------------------------------------------------------------------\n\n// avoid hardware interpolation\nvec4 sample_biquadratic_exact(sampler2D channel, vec2 res, vec2 uv) {\n    vec2 q = fract(uv * res);\n    ivec2 ires = ivec2(res);\n    ivec2 t = ivec2(uv * res) + ires;\n    ivec3 e = ivec3(-1, 0, 1);\n    vec4 s00 = texelFetch(channel, (t + e.xx) % ires, 0);\n    vec4 s01 = texelFetch(channel, (t + e.xy) % ires, 0);\n    vec4 s02 = texelFetch(channel, (t + e.xz) % ires, 0);\n    vec4 s12 = texelFetch(channel, (t + e.yz) % ires, 0);\n    vec4 s11 = texelFetch(channel, (t + e.yy) % ires, 0);\n    vec4 s10 = texelFetch(channel, (t + e.yx) % ires, 0);\n    vec4 s20 = texelFetch(channel, (t + e.zx) % ires, 0);\n    vec4 s21 = texelFetch(channel, (t + e.zy) % ires, 0);\n    vec4 s22 = texelFetch(channel, (t + e.zz) % ires, 0);    \n    vec2 q0 = (q+1.0)/2.0;\n    vec2 q1 = q/2.0;\t\n    vec4 x0 = mix(mix(s00, s01, q0.y), mix(s01, s02, q1.y), q.y);\n    vec4 x1 = mix(mix(s10, s11, q0.y), mix(s11, s12, q1.y), q.y);\n    vec4 x2 = mix(mix(s20, s21, q0.y), mix(s21, s22, q1.y), q.y);    \n\treturn mix(mix(x0, x1, q0.x), mix(x1, x2, q1.x), q.x);\n}\n\n//---------------------------------------------------------------------------------\n\nfloat linear_srgb(float x) {\n    return mix(1.055*pow(x, 1./2.4) - 0.055, 12.92*x, step(x,0.0031308));\n}\nvec3 linear_srgb(vec3 x) {\n    return mix(1.055*pow(x, vec3(1./2.4)) - 0.055, 12.92*x, step(x,vec3(0.0031308)));\n}\n\nfloat srgb_linear(float x) {\n    return mix(pow((x + 0.055)/1.055,2.4), x / 12.92, step(x,0.04045));\n}\nvec3 srgb_linear(vec3 x) {\n    return mix(pow((x + 0.055)/1.055,vec3(2.4)), x / 12.92, step(x,vec3(0.04045)));\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lGGRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 814]], "test": "untested"}
{"id": "slyGRm", "name": "Mandelbrot set with offset", "author": "tungster24", "description": "mandelbrot set with offset.\nnow with (somewhat broken) smoothing!\n(click on the screen to set offset and begin the rendering.)", "tags": ["fractal", "mandelbrot", "complex"], "likes": 4, "viewed": 282, "published": 3, "date": "1637353960", "time_retrieved": "2024-07-30T18:47:18.333722", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //mouse and fragment coordinates normalised.\n    float x = (fragCoord.x/iResolution.y-0.5*(iResolution.x/iResolution.y))*2.0-0.5;\n    float y = (fragCoord.y/iResolution.y-0.5)*2.0;\n    float mx = (iMouse.x/iResolution.y-0.5*(iResolution.x/iResolution.y))*2.0;\n    float my = (iMouse.y/iResolution.y-0.5)*2.0;\n    //iteration variable\n    int iter = 0;\n    //is it inside the set?\n    bool inside = true;\n    \n    vec2 z1 = vec2(mx,my);\n    vec2 z2 = vec2(0.0,0.0);\n    for (int i = 0;i<100;i++) {\n        \n        if (z1.x*z1.x+z1.y*z1.y <= 4.0) {\n        z2 = vec2(z1.x*z1.x-z1.y*z1.y+x,2.0*z1.x*z1.y+y);\n        z1 = z2;\n        iter++;\n        }\n        else {inside = false;break;}\n    }\n    //color variables\n    float mu = float(iter)+1.0-log(log(sqrt(z1.x*z1.x+z1.y*z1.y)))/log(2.0);\n    float r=sin(mu/30.0);\n    float g=sin(mu/20.0)-0.2;\n    float b=sin(mu/10.0)-0.4;\n    fragColor = vec4(r,g,b,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slyGRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 106, 973]], "test": "untested"}
{"id": "7lGGzw", "name": "Black and white spiral", "author": "SnoopethDuckDuck", "description": "Somehow achieved a velvety/milky texture, lots of distortions", "tags": ["spiral"], "likes": 5, "viewed": 314, "published": 3, "date": "1637350872", "time_retrieved": "2024-07-30T18:47:19.147546", "image_code": "float thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord- 0.5 * iResolution.xy)/iResolution.y;\n    float a = atan(uv.y, uv.x);\n\n    float sc = 24. / (2. + thc(1.5, 8. * mlength(uv) + iTime));\n    float sc2 = -24. / (2. + thc(1.5, 8. * mlength(uv) + iTime));\n    \n    float m1 = mix(sc, sc2, .5 + .5 * ths(0.5, 0.3 / length(uv) + 3. * a - iTime));\n    float m2 = mix(sc, sc2, .5 + .5 * ths(0.5, 6. * length(uv) + 3. * a - iTime));\n       \n    sc = mix(m1, m2, .5 + .5 * thc(1., 4. * length(uv)+ iTime));\n    \n    uv *= 0.55 * sc;\n    //vec2 ipos = floor(uv) + 0.5;\n    vec2 fpos = fract(uv) - 0.5;\n\n    float l = 0.4 * mlength(fpos);\n    float d = 0.1 * min(abs(fpos.x) , abs(fpos.y));\n    float s = smoothstep(-l, l,\n    0.1 - d + 0.1 * thc(2., 2. * mlength(uv) - 32. * a));\n    s *= s;\n    vec3 col = vec3(s);\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lGGzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 70], [72, 72, 101, 101, 142], [145, 145, 169, 169, 209], [211, 211, 268, 318, 1156]], "test": "untested"}
{"id": "NsKXR3", "name": "The Infinity Unknown", "author": "prishainabox", "description": "Sources of learning from Inigo Quilez's videos and articles, The Book of Shaders, and the Art of Code YouTube channel.\n\nView it on Khan Academy (very different):\nhttps://www.khanacademy.org/computer-programming/infinity-unknown/5378626088386560", "tags": ["raymarching"], "likes": 6, "viewed": 325, "published": 3, "date": "1637346498", "time_retrieved": "2024-07-30T18:47:20.016224", "image_code": "const float EPSILON = 0.001;\nconst float MAX_DIST = 70.0;\n\n//*******************************************************//\n\n// Light struct\nstruct Light {\n    vec3 clr;\n    vec3 dir;\n    float shadowSoftness;\n};\n\n// Material structure\nstruct Material {\n    vec3 clr;\n    float amb;\n    float dif;\n    float spec;\n    float shininess;\n    vec3 ref;\n    float id;\n};\n\n// function to return default material\nMaterial defaultMaterial() {\n    Material mat;\n    mat.amb = 0.1;\n    mat.clr = vec3(0.05);\n    mat.dif = 1.0;\n    mat.spec = 1.0;\n    mat.shininess = 10.0;\n    mat.ref = vec3(0.0);\n    mat.id = -1.0;\n    return mat;\n}\n\n//*******************************************************//\n\n// clamp value from 0 to 1\nfloat uclamp(float val) {\n    return clamp(val, 0.0, 1.0);\n}\n\n//*******************************************************//\n\n// random value from 0 to 1\n// https://thebookofshaders.com/10/\nfloat random(in vec2 v) {\n    return fract(15465.1327854 * sin(dot(v, vec2(173.93422, 102.5165))));\n}\n\n//*******************************************************//\n\n// https://iquilezles.org/articles/smin\n\n// smooth min\nfloat smoothmin(in float a, in float b, in float k) {\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// smooth max\nfloat smoothmax( float a, float b, float k ) {\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n// Smooth min for distance and color\n// returns rgb and d in vec4\nvec4 smoothmin(in float a, in float b, in vec3 clr1, in vec3 clr2, in float k) {\n\n   float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n   \n   // distance\n   float d = mix(b, a, h) - k*h*(1.0-h);\n   // color\n   vec3 c = mix(clr2, clr1, smoothstep(0.0, 1.0, h));\n   \n   return vec4(c, d);\n   \n}\n\n//*******************************************************//\n\n// SDFs\n\n// SDF box\n// https://www.youtube.com/watch?v=62-pRVZuS5c\nfloat sdBox(vec3 pt, vec3 b) {\n\tvec3 q = abs(pt) - b;\n\treturn length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n//*******************************************************//\n\n\n// MAIN SDF\n\nfloat sdf(in vec3 pt, out Material mat) {\n\n    // defaults\n    mat = defaultMaterial();\n    \n    // distance to closest object\n    float res;\n    \n    // sand\n    vec3 sandClr;\n    float sand;\n    {\n    \n        // sand clr\n        sandClr = vec3(0.13, 0.13, 0.08) * 0.8;\n        sandClr.rg += random(pt.xz*10.9)*0.05;\n        sand = pt.y + 2.35;\n       \n        // mountain range\n        float h = 2.4 + 0.35*texture(iChannel1, pt.xz*0.02).r + 0.6*texture(iChannel0, pt.xz*0.05).r*smoothstep(-20.0, -19.9, pt.z); \n        sand -= h*smoothstep(0.0, 20.0, abs(pt.x-10.0))*(0.9*sin(pt.z*0.45)+0.9)*smoothstep(15.0, 30.0, length(pt));\n        \n        // plane distortion by texture -> \"sand\"\n        sand += (0.1*texture(iChannel1, pt.xz*0.1).r + 0.05*texture(iChannel1, pt.xz*0.2).r);\n        \n    }\n    \n    // path\n    vec3 pathClr;\n    float path;\n    {\n    \n        // path clr\n        pathClr = vec3(0.17, 0.16, 0.09) * 0.5;\n        pathClr.rgb += texture(iChannel0, pt.zx*0.25).r * 0.2;\n   \n        // path shape -> distort x by z value of pt\n        path = sdBox(\n            pt - vec3(sin(pt.z) + 10.0*smoothstep(3.0, -20.0, pt.z) - 0.3, -2.35, 0), \n            vec3(2.7, 0.2, 40.0)\n        );\n        // distort by texture (bricks)\n        path -= pathClr.r * (0.2 * smoothstep(-4.0, 3.0, pt.z) + 0.15);\n        \n        // add noise to path clr\n        pathClr.rgb += texture(iChannel1, pt.zx*0.03).r * 0.05;\n       \n    }\n\n    // blend distance and clr (sand and path)\n    vec4 blend = smoothmin(sand, path, sandClr, pathClr, 0.75);\n    res = blend.w;\n\n    // material\n    mat.clr = blend.rgb;\n    mat.id = 0.0;\n    mat.shininess = 10.0;\n    mat.spec = 0.2;\n\n    return res;\n    \n}\n\n//*******************************************************//\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 pt) {\n    vec2 h = vec2(EPSILON, 0);\n    Material m;\n    // central difference sdf(pt + EPSILON) - sdf(pt - EPSILON)    \n    return normalize(vec3(\n       sdf(pt + h.xyy, m) - sdf(pt - h.xyy, m),\n       sdf(pt + h.yxy, m) - sdf(pt - h.yxy, m),\n       sdf(pt + h.yyx, m) - sdf(pt - h.yyx, m)\n    ));\n}\n\n//*******************************************************//\n\nfloat castRay(in vec3 ro, in vec3 rd, out Material mat) {\n\n    // total distance traveled\n    float td = 0.0;\n    \n    for (int i = 0; i < 256; i++) {\n        float h = sdf(ro + td*rd, mat);\n        // if distance is really close, break\n        if (abs(h) < (0.0001*td)) break;\n        // add to total distance\n        td += h;\n        // if too far, break\n        if (td >= MAX_DIST) {\n            mat.id = -1.0;\n            mat.ref = vec3(0.0);\n            break;\n        }\n    }\n    \n    return td;\n    \n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softShadow(in vec3 ro, in vec3 rd, in float k) {\n\n    float res = 1.0; // result\n    float td = 0.05; // total distance traveled\n    \n    for (int i = 0; i < 256 && td < MAX_DIST; i++) {\n        Material m;\n        float d = sdf(ro + td*rd, m);\n        if (d < 0.001) {\n            // intersection, so return shadow\n            return 0.0;\n        }\n        res = min(res, k*d/td);\n        td += d;\n    }\n    \n    // if no intersection -> shadow 0.0 to light 1.0\n    return res;\n    \n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcc(in vec3 pt, in vec3 nor) {\n\n    float occ = 0.0;\n    float scl = 1.0;\n    \n    Material m; // placeholder\n    \n    for (int i = 0; i < 4; i++) {\n        float h = 0.01 + 0.11 * 0.25 * float(i);\n        float d = sdf(pt + h * nor, m);\n        occ += (h-d)*scl;\n        scl *= 0.95;\n    }\n    \n    return uclamp(1.0 - 2.0 * occ);\n    \n}\n\n//*******************************************************//\n\n// https://iquilezles.org/articles/fog\nvec3 applyFog(in vec3 rd, in float d, in vec3 clr, in vec3 sunClr, in vec3 sunDir, in vec3 skyClr) {\n    \n    // mix sun clr with sky clr to get fog clr\n    vec3 fogClr = mix( skyClr, sunClr, pow(max(dot(rd, sunDir), 0.0), 15.0) );\n    \n    // mix pixel clr with fog clr\n    return mix(clr, fogClr, 1.0 - exp(-0.0025 * d * d)); // fog\n    \n}\n\nvec3 calcLighting(in vec3 pt, in vec3 rd, in vec3 nor, in Light light, in Material mat) {\n    \n    // diffuse\n    float dif = uclamp(dot(nor, light.dir)) * mat.dif;\n    \n    // shadow\n    float shadow = softShadow(pt, light.dir, light.shadowSoftness);\n    \n    // specular\n    vec3 ref = reflect(light.dir, nor);\n    float spec = pow(uclamp(dot(rd, ref)), mat.shininess) * mat.spec;\n\n    // return dif * clr * shadow * spec + dif * clr * shadow; \n    return light.clr * shadow * dif * (spec + 1.0);\n    \n}\n\nvec3 calcClr(in vec2 uv, in vec3 ro, in vec3 rd, in float d, in vec3 nor, in Material mat) {\n\n    // from camera to point in scene\n    vec3 pt = ro + rd * d;\n\n    // SKY CLR\n    vec3 skyClr = vec3(1.2, 0.65, 0.8);\n    skyClr -= 0.9*smoothstep(0.5, 2.0, uv.y);\n    \n    // KEY LIGHT\n    Light sun;\n    sun.clr = vec3(1.1, 0.9, 0.5) * 4.0;\n    sun.dir = normalize(vec3(0.8, 0.2, -0.4));\n    sun.shadowSoftness = 20.0;\n    \n    // background color\n    vec3 shine = sun.clr * 0.15 * pow(max(dot(sun.dir, rd), 0.0), 13.0);\n    \n    // return background if too far (id is -1.0)\n    if (mat.id == -1.0) {\n    \n        // stars\n        float scl = 45.0;\n        vec2 fid = fract(uv * scl); // fractional component\n        vec2 id = floor(uv * scl); // integer component\n        vec3 starClr;\n        float circle = smoothstep(0.2*smoothstep(scl*0.3, scl, id.y)*random(id), 0.0, length(fid-vec2(0.5)));\n        float n = smoothstep(0.0, scl*0.9, id.y) * texture(iChannel1, uv*0.5).r;\n        starClr += random(id) + id.y*0.001 > 0.95 ? circle*n : 0.0;\n        // add star clr to sky clr\n        skyClr += 0.7*starClr;\n        \n        // return sky\n        return skyClr + shine;\n        \n    }\n    \n    // material id is not -1.0, so we hit an obj\n    vec3 clr = mat.clr;\n    \n    // CALCULATE COLOR\n    float occ = calcOcc(pt, nor); // ambient occlusion\n    vec3 light = vec3(mat.amb); // ambient\n    light += calcLighting(pt, rd, nor, sun, mat) * occ; // sun\n    light += uclamp(dot(nor, vec3(0,  1, 0))) * skyClr * occ; // sky diffuse\n    clr *= light;\n    \n    // apply fod\n    clr = applyFog(rd, d, clr, sun.clr * 0.17, sun.dir, skyClr);\n    \n    return clr + shine;\n\n}\n\n//*******************************************************//\n\nvec3 render(in vec2 uv, in vec3 ro, in vec3 rd) {\n    \n    // material and clr\n    Material mat;\n    vec3 clr = vec3(0);\n\n    // get distance to point\n    float d = castRay(ro, rd, mat);\n    // surface normal\n    vec3 nor = calcNormal(ro + rd*d);\n    \n    // calculate the color of the pixel\n    clr = calcClr(uv, ro, rd, d, nor, mat);\n    \n    // gamma correction\n    clr = pow(clr, vec3(1.0 / 2.2)); \n    \n    return clr;\n    \n}\n\n//*******************************************************//\n\n// https://www.youtube.com/watch?v=Cfe5UQ-1L9Q\n// https://learnopengl.com/Getting-started/Camera\nvec3 setCamera(in vec2 uv, in vec3 ro, in vec3 target) {\n\n    vec3 forward = normalize(target - ro);\n    vec3 right = normalize(cross(forward, vec3(0, 1, 0)));\n    vec3 up = normalize(cross(right, forward));\n    \n    // ray direction\n    vec3 rd = normalize(uv.x * right + uv.y * up + 1.2 * forward);\n    \n    return rd;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // resolution\n    vec2 res = iResolution.xy;\n    \n    // Normalized pixel coordinates\n    vec2 uv = (2.0*fragCoord - res) / min(res.x, res.y);\n    \n    // target\n    vec3 target = vec3(0, -0.5, 0);\n    // ray origin\n    vec3 ro = vec3(0.0, 0.2, 8.0);\n    \n    // set camera\n    vec3 rd = setCamera(uv, ro, target);\n    \n    // calculate color based on distance, etc\n    vec3 clr = render(uv, ro, rd);\n\n    // Output to screen\n    fragColor = vec4(clr, 1.0);\n    \n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKXR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[362, 401, 429, 429, 619], [682, 709, 734, 734, 769], [832, 896, 921, 921, 997], [1101, 1115, 1168, 1168, 1257], [1259, 1273, 1319, 1319, 1391], [1393, 1459, 1539, 1539, 1745], [1817, 1875, 1905, 1905, 1995], [2072, 2072, 2113, 2130, 3763], [3826, 3872, 3901, 3901, 4196], [4259, 4259, 4316, 4348, 4767], [4769, 4814, 4868, 4868, 5305], [5307, 5348, 5388, 5388, 5696], [5759, 5798, 5898, 5950, 6139], [6141, 6141, 6230, 6250, 6646], [6648, 6648, 6740, 6778, 8314], [8377, 8377, 8426, 8455, 8807], [8870, 8967, 9023, 9023, 9294], [9296, 9296, 9353, 9372, 9823]], "test": "untested"}
{"id": "tlsSRr", "name": "Terraforming", "author": "hamtarodeluxe", "description": "Click to terraform :-)\nImproved version: https://www.shadertoy.com/view/stVGRy", "tags": ["interactive", "sphere", "diffusion", "reaction"], "likes": 21, "viewed": 405, "published": 3, "date": "1637341948", "time_retrieved": "2024-07-30T18:47:21.093344", "image_code": "#define RMSTEPS 75\n\nvec2 getData(vec3 p)\n{\n    vec2 v = texture(iChannel0, cartToSm(p) * simResRatio).xy;  \n    return vec2(v.x, 1.-v.y);\n}\n\nfloat hash( uint n ) //iq\n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nfloat getHeight(vec2 data, vec3 p)\n{\n    float t = getTypeBlendSS(p, iChannel1, iTime);\n    return 0.9*MAXDISP*(data.y * 0.6 + mix(0.0,0.3, t));\n}\n\nvec3 normals(vec3 p)\n{\n    vec3 n;\n    float EPS = 0.01f;\n    vec3 e = vec3(EPS,0.,0.);\n    float baseR = RADIUS-MAXDISP;\n    n.x = length(p + e) - getHeight(getData(p+e), p+e) - (length(p - e) - getHeight(getData(p-e), p-e));\n    \n    e = vec3(0.,EPS,0.);\n    n.y = length(p + e) - getHeight(getData(p+e), p+e) - (length(p - e) - getHeight(getData(p-e), p-e));\n\n    e = vec3(0.,0., EPS);\n    n.z = length(p + e) - getHeight(getData(p+e), p+e) - (length(p - e) - getHeight(getData(p-e), p-e));\n    \n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 dc = (vec2(fragCoord)/iResolution.xy)*2.-1.;\n\tdc.y *= float(iResolution.y)/float(iResolution.x);\n    \n    vec3 ro = cameraPos(iTime);\n\tvec3 rd = cameraRay(dc, ro);\n    \n    float h = hash(uint(fragCoord.x)+uint(fragCoord.y*iResolution.x)+uint(iFrame)*uint(iResolution.x*iResolution.y));\n    \n    vec3 hitSphP = vec3(1000., 1000.,1000.);\n    vec2 hitTs = vec2(1000.,1000.);\n    bool hitSph = isecSphere(ro, rd, vec3(0.), RADIUS, hitTs, hitSphP);\n    bool hitSurf = false;\n    vec3 p = vec3(0.);\n    vec2 data = vec2(1.);\n\n    if (hitSph)\n    {\n        vec3 hitSphPIn = vec3(1.,1.,1.);\n        vec2 hitTsSphIn = vec2(100.);\n        bool hitSphIn = isecSphere(ro, rd, vec3(0.), RADIUS-MAXDISP, hitTsSphIn, hitSphPIn);\n        float maxT = min(hitTs.y, hitTsSphIn.x) - hitTs.x;\n\n        float d = 500.;\n        ro = hitSphP;\n        float tLength = maxT / float(RMSTEPS);\n        float t = tLength * h;\n\n        float prevSurfH = MAXDISP;\n\n        for (int i = 0; i<RMSTEPS; i++)\n        {\n            p = ro + t*rd;\n            data = getData(p);     \n\n            float surfH = getHeight(data, p);\n            float baseR = RADIUS-MAXDISP;\n            float h = length(p) - baseR; \n            \n            if(h<surfH)\n            {           \n                float maxSurfH = prevSurfH;\n                float minSurfH = surfH; \n                float maxT = t - tLength;\n                float minT = t;\n                float maxDelta = (length(ro + maxT*rd) - baseR)-maxSurfH;\n                float minDelta = minSurfH-h;\n\n                t = mix(minT, maxT, minDelta / (maxDelta+minDelta));\n                p = ro + t*rd;\n                h = length(p) - baseR;\n                data = getData(p); \n                surfH = getHeight(data, p);\n\n                for (int j = 0; j < 3; j++)\n                {\n                    if (h < surfH)\n                    {\n                        minT = t;\n                        minSurfH = surfH;\n                    }\n                    else\n                    {\n                        maxT = t;\n                        maxSurfH = surfH;\n                    }\n                    maxDelta = (length(ro + maxT*rd) - baseR)- maxSurfH;\n                    minDelta = minSurfH-(length(ro + minT*rd) - baseR);\n                  \n                    t = mix(minT, maxT, minDelta / (maxDelta+minDelta));\n                    p = ro + t*rd;\n                    h = length(p) - baseR;\n                    data = getData(p); \n                    surfH = getHeight(data, p);\n                }\n\n                hitSurf = true;\n                t = t; \n                break;\n            }\n            prevSurfH = surfH;\n            t+=tLength;\n        }\n\n    }\n    vec3 col = vec3(0.05);\n\n    if (hitSurf)\n    {\n        float typeBlend = getTypeBlendSS(p, iChannel1, iTime);\n        vec3 colB = mix(0.5*vec3(0.15, 0.01, 0.01),vec3(1.,0.5,0.2),pow(data.y,7.));\n        vec3 colA = mix(vec3(0.,0.1,0.1),0.8*vec3(0.1,0.8,1.),pow(data.x,2.));\n        colA += 0.05*vec3(1.,1.,1.)*smoothstep(0.99,1., data.y);\n        float e =0.1f;\n        vec3 n = normals(p);\n        vec3 lightPos = vec3(2.,5.,2.);\n        \n        col = mix(colA, colB,typeBlend); \n        vec3 lightDir = normalize(lightPos-p);\n        \n        vec3 ref = normalize(reflect (lightDir, n));\n        vec3 spec = vec3(1.)*mix(1.,.3,typeBlend)*pow(clamp(dot(ref,rd),0.,1.),mix(60.,5.,typeBlend)); \n\n        col += spec;\n    }\n    \n    // Output to screen\n    float v = 1./pow((pow(sqrt(0.05*h+dot(dc * 2., dc * 2.)*.4),2.)+1.),3.);\n    fragColor = vec4(pow(v*col, vec3(1./2.2)),1.0);\n}", "image_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n          \n    vec2 mouseDc = (vec2(iMouse.xy)/iResolution.xy)*2.-1.;\n\tmouseDc.y *= float(iResolution.y)/float(iResolution.x);\n    \n    vec3 ro = cameraPos(iTime);\n\tvec3 rd = cameraRay(mouseDc, ro);   \n    vec3 hitSphP = vec3(1.);\n    vec2 outT = vec2(1000.);\n    bool hitSph = isecSphere(ro, rd, vec3(0.), RADIUS-MAXDISP*0.5, outT, hitSphP);\n    \n    vec2 C = RUNKERNEL\n\n    if (iMouse.z>0. && hitSph)\n    {\n        vec3 pTex = smToCart(uv/simResRatio);\n        vec3 pMouse = normalize(hitSphP);\n    \tC.y += 00.1*(1.-clamp(length(pTex-pMouse)/0.125,0.,1.));\n    } \n    \n    C = clamp(C,vec2(0.00),vec2(1.));\n\n    if(iFrame == 0) C.xy = vec2(1.);\n   \tif (fract(fragCoord.x*0.5) == 0.) C.xy=vec2(0.,0.);\n\n    fragColor = vec4(C.xy,0.,1.);\n}", "buffer_a_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159\n#define RADIUS 0.6\n#define MAXDISP 0.3\n\n#define simRes min(iResolution.xy, vec2(700, 400))\n#define simResRatio (simRes/iResolution.xy)\nvec2 fks[] = vec2[](vec2(0.014, 0.045), vec2(.0545, 0.062));\n\nfloat noise (vec3 x, sampler3D tex)\n{\n    //smoothing distance to texel https://iquilezles.org/articles/texture\n    x*=32.;\n    x += 0.5;\n    \n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\tx = f+i;    \n    x-=0.5;\n    \n    return texture( tex, x/32.0 ).x;\n}\n\nmat2x2 rot(float angle)\n{\n    return mat2x2(cos(angle), -sin(angle),\n\t\t\t\t  sin(angle), cos(angle));\n}\n\nbool isecSphere(vec3 ro, vec3 rd, vec3 pos, float r, out vec2 outT, out vec3 outP)\n{\n    float a = dot(rd,rd);\n    float b = 2.*dot(rd,(ro-pos));\n    float c = dot((ro-pos),(ro-pos))-r*r;\n    float d = b*b-4.*a*c;\n    outP = vec3(0.);\n    outT = vec2(100.);\n    if (d<0.)\n        return false;\n\n    float sd =sqrt(d);\n    outT = vec2((-b-sd)/(2.*a),(-b+sd)/(2.*a)); \n    outT = vec2(min(outT.x, outT.y), max(outT.x, outT.y));\n    outP = ro + rd*outT.x;\n    outT = abs(outT);\n    return true;\n}\n\nvec3 cartToSph(vec3 pos)\n{\n\tfloat r = length(pos);\n\treturn vec3(r,acos(pos.y/r),atan(pos.z,pos.x));//wikipedia physics convention\n}\n\nvec3 sphToCart(vec3 sc) //vec3 (radius, polar, azimuth)\n{\t\n\tfloat x = sc.x * sin(sc.y) * cos(sc.z);\n\tfloat z = sc.x * sin(sc.y) * sin(sc.z);\n\tfloat y = sc.x * cos(sc.y);\n\treturn vec3(x,y,z);\n}\n\nfloat getWidth(float y)\n{  \n\treturn pow(sin(acos(y*2.-1.)),1.) +0.000f;\n}\n\nvec3 cameraPos(float time)\n{\n    time *= 0.5f;\n    return (1.2 +0.2*sin(time))*vec3 (cos(time),1.,sin(time));\n}\nvec3 cameraRay(vec2 dc, vec3 ro)\n{\n    vec3 lookAt = vec3(0.);\n\n\tvec3 fw = normalize(lookAt-ro);\n\tvec3 rg = normalize(vec3(-fw.z,0,fw.x));\n\tvec3 up = normalize(cross(rg,fw));\n\tfloat fo = 1.5;\n\tvec3 rd = normalize(fw * fo + up * dc.y + rg * dc.x);\n\treturn rd;\n}\n\nvec2 sphToSm(vec3 sph)\n{\n    vec2 samp;\n    samp.y = (sph.y/PI);\n      \n    samp.x = ((sph.z+PI)/(2.*PI));\n    samp.x = (samp.x-0.5),\n    samp.x *= getWidth(samp.y);\n                 \n    samp.x +=0.5;\n    return samp;\n}\n\nvec3 smToSph(vec2 sm)\n{\n    vec3 sph;\n    sm.x -= 0.5f;\n    sm.x /= max(0.00000f,getWidth(sm.y));\n    sm.x += 0.5f;\n       \n    sph.z = sm.x*(2.*PI) - PI;\n    sph.y = sm.y * PI;\n    sph.x = 1.;\n    return sph;\n}\n\nvec3 smToCart(vec2 sm)\n{\n    return sphToCart(smToSph(sm));\n}\n\nvec2 cartToSm(vec3 cart)\n{\n    return sphToSm(cartToSph(cart));\n}\n\nvec2 os[8] = vec2[](vec2(0,1),\n                    vec2(0,-1),\n                    vec2(1,0),\n                    vec2(-1,0),  \n                    vec2(1,1),   \n                    vec2(1,-1),  \n                    vec2(-1,1), \n                    vec2(-1,-1));\n                    \n\nfloat myMod(float x, float y)\n{\n    return -y*floor(x/y) + mod(x,y);\n}\n\n#define typeA 0.45\n#define typeB 0.55\nfloat getTypeBlend(vec3 p, sampler3D noiseTex, float offset)\n{\n    p = normalize(p);\n    return noise(0.1*p + offset*0.002, noiseTex);\n}\nfloat getTypeBlendSS(vec3 p, sampler3D noiseTex, float offset)\n{\n\n    return smoothstep(typeA, typeB, getTypeBlend(p, noiseTex, offset));\n}\n\nfloat getTypeBlendLS(vec3 p, sampler3D noiseTex, float offset)\n{\n    float t = getTypeBlend(p, noiseTex, offset);\n    float x = 0.2;\n    return clamp((t-(typeA-x))/((typeB+x)-(typeA-x)),0.,1.);\n}\n\nvec2 runKernel(vec2 fragCoord, vec2 iResolution, sampler2D iChannel0, sampler3D noiseTex, float time)\n{  \n    if (fragCoord.x >= iResolution.x || fragCoord.y >= iResolution.y) return vec2(0.);\n    fragCoord = mod(fragCoord,iResolution.xy);\n    \n    vec2 C = texelFetch(iChannel0, ivec2(fragCoord), 0).xy;  \n    vec2 halfRes = floor(iResolution.xy*0.5);\n    \n    vec3 cPos = smToCart(fragCoord/iResolution.xy);\n    vec2 values[8];\n    vec2 k = vec2(0.);\n    float w = 0.;\n    vec3 debug= vec3(0.);\n    for (int i=0;i<8;i++)\n    {\n        vec2 samp = fragCoord + os[i];\n        samp.x -= halfRes.x;\n        float width = getWidth(samp.y/(iResolution.y));\n        if(samp.x>=0.)samp.x = myMod(samp.x,width*halfRes.x);\n        else samp.x = myMod(samp.x,-width*halfRes.x);\n \n        samp.x += halfRes.x;  \n        \n        vec3 sPos = smToCart(samp/iResolution.xy);\n        float d = 1.;\n        \n    \tk += d*texelFetch(iChannel0, ivec2(samp),0).xy;\n        \n        w +=d;\n    } \n    \n    k/= w;\n    \n    vec2 D = k-C;\n    float s = 1.;\n    vec2 dr = 1.*vec2(1.,0.5);\n    \n    vec2 fk = mix(fks[0], fks[1], getTypeBlendSS(cPos, noiseTex, time)); \n    \n    float feed = fk.x;\n  \tfloat kill = fk.y;\n\n    vec2 nextC;\n\tnextC.x = C.x + (D.x*dr.x-C.x*C.y*C.y + feed*(1.-C.x))*s;\n    nextC.y = C.y + (D.y*dr.y+C.x*C.y*C.y -(kill+feed)*C.y)*s;\n\tC = nextC;\n    \n    return C;\n}\n\n#define RUNKERNEL runKernel(fragCoord.xy, simRes, iChannel0, iChannel1, iTime);      \n", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 C = RUNKERNEL\n    fragColor = vec4(C.xy,0.,1.);\n}", "buffer_b_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 C = RUNKERNEL\n    fragColor = vec4(C.xy,0.,1.);\n}", "buffer_c_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 C = RUNKERNEL\n    fragColor = vec4(C.xy,0.,1.);\n}", "buffer_d_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsSRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 42, 42, 139], [141, 141, 168, 211, 349], [351, 351, 387, 387, 497], [499, 499, 521, 521, 1024], [1026, 1026, 1083, 1133, 4756]], "test": "untested"}
{"id": "NlyGzm", "name": "Optical Illusion Discs", "author": "xavierseb", "description": "Saw it on Youtube, credits to @coachly.de and probably others(?)\nI thought I would try to code it to play with the ideas.\nthe illusion is that the size appears to change, there is a variation in which they can appear to move around, \nopen to suggestions..", "tags": ["optical", "illusion", "visual"], "likes": 6, "viewed": 245, "published": 3, "date": "1637341136", "time_retrieved": "2024-07-30T18:47:22.602310", "image_code": "// optical illusion inspired from @coachly.de\n// the discs are not changing in size at all.\n// slight variation of this can give the illusion of movement\n\n#define PI 3.14159\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 position = mod( fragCoord/iResolution.xy, vec2(.5,1.) );\n\t\t\n\tfloat angle = (atan(position.y-.5,position.x-.25)+PI)/2./PI;\n\tangle = mod(angle+iTime*2.4,1.);\n\t\n\tfloat r=.5,g=.5,b=.5,l=length(position-vec2(.25,.5));\n\t\n\tif(l>.13&&l<.2) {\n\t\tif ( angle<.25) {  // y to r\n\t\t\tg=angle*4.;\n\t\t\tr=1.;\n\t\t\tb=0.;\n\t\t}\t\t\t\n\t\telse if(angle<.5) {  // c to y\n\t\t\tg=1.;\n\t\t\tb=(angle-.25)*4.;\n\t\t\tr=1.-b;\n\t\t}\n\t\telse if(angle<.75) { // b to c\n\t\t\tb=1.;\n\t\t\tg=1.-(angle-.5)*4.;\n\t\t\tr=0.;\n\t\t}\n\t\telse {\t\t// r to b\n\t\t\tr=(angle-.75)*4.;\n\t\t\tb=1.-r;\n\t\t\tg=0.;\n\t\t}\n\t}\n\t\n    if(l>.1975&&l<.2) {\t// outer rim\n\t\tfloat s = .3 + abs(cos(PI*angle-.03*mod(iTime,1.)));\n\t\ts*=s; r*=s; g*=s; b*=s;\n\t}\n\telse if(l>.127&&l<.13) {\t// inner rim\n\t\tfloat s = .3 + abs(sin(PI*angle-.03*mod(iTime,1.)));\n\t\ts*=s; r*=s; g*=s; b*=s;\n\t}\n\n\t/*if(l>.1975&&l<.2) {\t// outer rim\n\t\tfloat s=1.3*abs(sin(PI*angle-sin(iTime)));\n\t\tr*=s; g*=s; b*=s;\n\t}\n\telse if(l>.127&&l<.13) {\t// inner rim\n\t\tfloat s=1.3*abs(sin(PI*angle+sin(iTime*1.23456)));\n\t\tr*=s; g*=s; b*=s;\n\t}*/\n\t\n\tfragColor = vec4(r,g,b,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlyGzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[175, 175, 232, 232, 1267]], "test": "untested"}
{"id": "7lVGzD", "name": "spin filter", "author": "lomateron", "description": "this only has 2D velocity vectors\nI think this is filtering and enhancing a specific spin frequency of the velocity vector field\nI still don't understand why BufferA sin(dot(c,b2)) does that", "tags": ["convolution"], "likes": 17, "viewed": 513, "published": 3, "date": "1637310912", "time_retrieved": "2024-07-30T18:47:23.548779", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = fragCoord/iResolution.xy;\n    vec4 a = texture(iChannel0,u);\n    fragColor = .5+vec4(0,a.xy,0)*.7;\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4  r = vec4(0);\n    vec4  a = A(u);\n    float z    = 8.;//kernel convolution size\n    float blur = 1./z;\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        if((i==0.&&j==0.)||length(vec2(i,j))>z+.1){continue;}\n        vec2  c = vec2(i,j)*blur;\n        vec2  n = normalize(c);\n        vec4  a2= A(u+vec2(i,j));\n        vec4  b = a2-a;\n        vec2  b2= b.yx*vec2(-1,1);\n        r.xy += length(b.xy)*sin(dot(c,b2)*6.);\n        r.z  += dot(n,b2);\n    }}\n    fragColor = r;\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4  r = A(u);\n    float z    = 8.;//kernel convolution size\n    float blur = 1./z;\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n      if((i==0.&&j==0.)||length(vec2(i,j))>z+.1){continue;}\n      vec4 b = B(u+vec2(i,j));\n      vec2 c = (-vec2(i,j))*blur;\n           c = normalize(c)*exp(-dot(c,c));//*r.z;\n      r.xy += c*b.xy*b.z*.000001;\n    }}\n    fragColor = r;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\n#define C(u) texture(iChannel2,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4 t = A(u);\n    vec2 m = +t.xy\n             +B(u).xy*(t.z-.5)*0.\n             +t.z*vec2(0,.0)\n             -C(u).x*t.xy*.0;\n    float s = 0.;\n    float z    = 6.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n      vec2 c = (m+vec2(i,j))*1.;\n      s += exp(-dot(c,c));\n    }}\n    if(s==0.){s = 1.;}\n    s = 1./s;\n    \n    fragColor = vec4(m,s,0);\n}", "buffer_c_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    float tz = 0.;\n    vec4 a = vec4(0);\n    float z    = 6.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n      vec4 t = A(u+vec2(i,j)); //t.z = 1.;\n      vec4 m = B(u+vec2(i,j));\n      vec2 c = (m.xy-vec2(i,j))*1.;\n      float z = exp(-dot(c,c));\n      a.xy += z*m.xy;\n      a.z  += z*m.z*t.z;\n      tz   += z;\n    }}\n    if(tz==0.){tz = 1.;}\n    a.xy /= tz;\n    //a = A(u);\n    if(iMouse.z>0.)\n    {\n        vec2 m = 16.*(u-iMouse.xy)/iResolution.y;\n        a += vec4(-1,0,0,0)*exp(-dot(m,m))*.1;\n    }\n    if(iFrame==0)\n    {\n        vec2 m;\n        m = 6.*(u-iResolution.xy*.5)/iResolution.y-vec2(2,1);\n        a+= vec4(+2,0,0,0)*exp(-dot(m,m));\n        m = 6.*(u-iResolution.xy*.5)/iResolution.y+vec2(2,1);\n        a+= vec4(-2,0,0,0)*exp(-dot(m,m));\n    }\n    fragColor = a;\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lVGzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 171]], "test": "untested"}
{"id": "slVGRD", "name": "Game of Life Exploration", "author": "DanielXMoore", "description": "simple game of life exploration", "tags": ["life"], "likes": 3, "viewed": 271, "published": 3, "date": "1637298366", "time_retrieved": "2024-07-30T18:47:24.328694", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = vec4(texture(iChannel0, uv).rgb, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float Hash21(vec2 p) {\n  p = fract(p*vec2(234.34, 435.345));\n  p += dot(p, p+34.23);\n  return fract(p.x * p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 px = 1. / iResolution.xy;\n\n    if (iFrame < 3) {\n        fragColor = step(0.5, vec4(Hash21(uv)));\n    } else {\n        float v = texture(iChannel0, uv).r;\n        float n = -v;\n        for (int y = -1; y <= 1; y++) {\n            for (int x = -1; x <= 1; x++) {\n                n += texture(iChannel0, vec2(x, y) * px + uv).r;\n            }\n        }\n        \n        if (v > 0.5) {\n            if ((n >= 1.5) && (n <= 3.5)) {\n                v = 1.;\n            } else {\n                v = 0.;\n            }\n        } else {\n            if ((n >= 2.5) && (n <= 3.5)) {\n                v = 1.;\n            } else {\n                v = 0.;\n            }\n        }\n        \n        fragColor = vec4(v);\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slVGRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 229]], "test": "untested"}
{"id": "7lV3zW", "name": "wigli wires", "author": "lomateron", "description": "there is only 2D velocity vectors here\nvelocity gets repelled by neighbor relative velocity\ngo to bufferB to change it to\nvelocity gets attracted by neighbor relative velocity", "tags": ["convolution"], "likes": 33, "viewed": 502, "published": 3, "date": "1637289729", "time_retrieved": "2024-07-30T18:47:25.084673", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = fragCoord/iResolution.xy;\n    vec4 a = texture(iChannel0,u);\n    //fragColor = a.z+a.z*sin(length(a.xy)+vec4(1,2,3,4)+0.);\n    fragColor = +sin(a.x*2.+vec4(1,2,3,4)+0.)*.25\n                +sin(a.y*2.+vec4(1,2,3,4)+0.)*.25\n                +.5;\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4  r = vec4(0);\n    vec4  a = A(u);\n    float z    = 4.;//kernel convolution size\n    float blur = 3./z;\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        vec2  c = vec2(i,j)*blur; //c = c.yx*vec2(-1,1);\n              c*= exp(-dot(c,c));\n        vec4  a2= A(u+vec2(i,j));\n        vec4  b = a2-a;\n        r.x += length(b.xy);\n        //r.xy += c*b.z;\n        //r.z  += dot(c,b.xy           );//*a2.z;\n        //r.w  += dot(c,b.yx*vec2(-1,1));//*a2.z;\n    }}\n    fragColor = r;\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4  r = A(u);\n    float z    = 4.;//kernel convolution size\n    float blur = 3./z;\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n      vec4 b = B(u+vec2(i,j));\n      vec2 c = (-vec2(i,j))*blur;\n           c*= exp(-dot(c,c))*.009;//*r.z;\n      r.xy += +b.x*c              *1. //change to -1 to make it an atraction\n              +b.w*c.yx*vec2(-1,1)*0.;\n    }}\n\n    fragColor = r;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\n#define C(u) texture(iChannel2,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4 t = A(u);\n    vec2 m = +t.xy\n             +B(u).xy*(t.z-.5)*0.\n             +t.z*vec2(0,.0)\n             -C(u).x*t.xy*.0;\n    float s = 0.;\n    float z    = 6.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n      vec2 c = (m+vec2(i,j))*1.;\n      s += exp(-dot(c,c));\n    }}\n    if(s==0.){s = 1.;}\n    s = 1./s;\n    \n    fragColor = vec4(m,s,0);\n}", "buffer_c_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    float tz = 0.;\n    vec4 a = vec4(0);\n    float z    = 6.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n      vec4 t = A(u+vec2(i,j)); t.z = 1.;\n      vec4 m = B(u+vec2(i,j));\n      vec2 c = (m.xy-vec2(i,j))*1.;\n      float z = t.z*exp(-dot(c,c));\n      a.xy += z*m.xy;\n      a.z  += z*m.z;\n      tz   += z;\n    }}\n    if(tz==0.){tz = 1.;}\n    a.xy /= tz;\n    if(iMouse.z>0.)\n    {\n        vec2 m = 22.*(u-iMouse.xy)/iResolution.y;\n        a += vec4(normalize(m),0,0)*exp(-dot(m,m))*.2;\n    }\n    if(iFrame==0)\n    {\n        vec2 m = 4.*(u-iResolution.xy*.5)/iResolution.y;\n        a = vec4(1,0,1,1)*exp(-dot(m,m));\n    }\n    fragColor = a;\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lV3zW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 316]], "test": "untested"}
{"id": "Nl33zH", "name": "lame half tone", "author": "ArmandB", "description": "rgb aren't offset from each other, and at resolutions close to screen res, it begins to get weird", "tags": ["halftone"], "likes": 4, "viewed": 323, "published": 3, "date": "1637283950", "time_retrieved": "2024-07-30T18:47:26.171766", "image_code": "vec3 getCol(vec2 uv){\n    return texture(iChannel0, uv).xyz;\n}\n\nfloat dist(vec2 uv, vec2 uvPx, vec2 pxSize) {\n    return length((uv-uvPx - pxSize/2.0)/pxSize);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvPx = floor(fragCoord/iResolution.xy*dotCount)/dotCount;\n    vec2 pxSize = 1.0/dotCount;\n    vec3 nearCol = getCol(uvPx);\n    vec3 col = vec3(0);\n    \n    vec3 dists = vec3(dist(uv, uvPx, pxSize));\n    \n    dists *= 2.0;\n    \n    if (dists.r < getCol(uvPx).r){\n        col += vec3(1,0,0);\n    }\n    if (dists.g < getCol(uvPx + vec2(0, pxSize.y/2.0)).g){\n        col += vec3(0,1,0);\n    }\n    if (dists.b < getCol(uvPx + vec2(pxSize.x/2.0, 0)).b){\n        col += vec3(0,0,1);\n    }\n\n    fragColor = vec4(col, 0);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 dotCount = vec2(100,70);", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl33zH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 62], [64, 64, 109, 109, 161], [163, 163, 220, 220, 784]], "test": "untested"}
{"id": "7tV3RW", "name": "Simple ellipses", "author": "nns2009", "description": "Just concentric ellipses", "tags": ["circles", "shapes", "ellipses"], "likes": 2, "viewed": 236, "published": 3, "date": "1637283617", "time_retrieved": "2024-07-30T18:47:26.982598", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 centered = fragCoord - iResolution.xy / 2.0;\n    //vec2 scaled = centered / 60.0;\n    vec2 scaled = vec2(centered.x / 60.0, centered.y / 15.0);\n    \n    float dist = length(scaled);\n    float whole = round(dist);\n    float distToRing = abs(dist - whole);\n\n    vec3 col = vec3(distToRing < 0.04 ? 1.0 : 0.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tV3RW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 432]], "test": "untested"}
{"id": "styGzD", "name": "micro Texture NCA (588 params)", "author": "Anony", "description": "\"Texture Generation with Ultra-Compact Neural Cellular Automata\" supplementary material\nNCA-588 rule generating \"Mondrian\" pattern.\nSee \"Buffer A\" for perception code and \"Buffer B\" for the update rule.\n", "tags": ["ca"], "likes": 8, "viewed": 795, "published": 3, "date": "1637244928", "time_retrieved": "2024-07-30T18:47:27.791435", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int W = int(iResolution.x) / 3;\n    vec2 p = fragCoord.yx;\n    p /= 2.0;\n    p.x = mod(p.x, float(W));\n \n    fragColor = texture(iChannel0, p/iResolution.xy)+0.5;\n    //fragColor = texture(iChannel1, fragCoord.xy/iResolution.xy)+0.5;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Perception phase\n\nint W;\nint band;\nivec2 pos;\n\nvec4 R(int dx, int dy) {\n    vec2 p = vec2((pos.x+dx+W)%W+W*band, pos.y+dy);\n    return texture(iChannel0, (p+0.5)/iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    W = int(iResolution.x) / 3;\n    pos = ivec2(fragCoord.xy);\n    band = pos.x / W;\n    pos.x %= W;\n    \n    vec4 prev = texture(iChannel1, fragCoord/iResolution.xy);\n    \n    if (band == 2) {\n        fragColor = R(-1, 1)+R(-1, 0)*2.0+R(-1,-1)\n                   -R( 1, 1)-R( 1, 0)*2.0-R( 1,-1);\n    } else if (band == 1) {\n        fragColor = R( 1, 1)+R( 0, 1)*2.0+R(-1, 1)\n                   -R( 1,-1)-R( 0,-1)*2.0-R(-1,-1);\n    } else {\n        fragColor = R(1,1)+R(1,-1)+R(-1,1)+R(-1,-1)\n              +2.0*(R(0,1)+R(0,-1)+R(1,0)+R(-1,0))-12.0*R(0, 0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Update phase\n\nvec4 update(float band, vec4 y[6]) {\n  #define M mat4\n  #define F(i,_a,_b) {M a=_a,b=_b; vec4 yi=y[i]; dx+=G(0)+G(1)+G(2)+G(3);}\n  //#define G(i) yi[i]*((yi[i]>0.0)?a[i]:b[i])\n  #define G(i) (yi[i]*a[i]+abs(yi[i])*b[i])\n  vec4 dx;\n  if (band == 0.) { dx = vec4(17,3,-17,15);\n    F(0, M(-32,13,-9,20,-3,-58,6,27,2,21,-39,-5,-10,-9,4,-41), M(11,14,2,-34,-1,6,51,-26,-9,-41,-15,-19,9,14,9,-3));\n    F(1, M(6,-1,-5,4,-5,4,-1,5,-12,13,15,26,0,4,0,0), M(-16,-8,-10,4,1,13,18,-3,-6,-2,-2,3,14,-9,-7,-19));\n    F(2, M(-3,8,7,7,12,-4,-7,-11,2,-2,-5,1,-2,-2,-2,0), M(-7,-12,-8,0,-11,2,4,12,-17,2,21,10,12,3,4,-10));\n    F(3, M(23,4,-1,6,-24,11,0,4,7,-1,14,0,-4,8,-4,40), M(2,-1,0,-7,-3,2,0,2,2,1,0,10,11,10,10,-10));\n    F(4, M(-12,-17,-14,-13,6,7,7,-1,19,17,10,14,4,11,8,10), M(-4,-7,-8,3,-4,6,6,-1,3,0,-6,7,-3,-1,0,-5));\n    F(5, M(10,14,12,13,-9,-16,-13,-12,5,3,5,-9,-9,-15,-16,6), M(-1,-1,1,-3,-12,-8,-7,6,-13,0,3,0,4,4,5,5));\n  } else if (band == 1.) { dx = vec4(12,0,-2,-7);\n    F(0, M(-10,15,11,-2,6,21,-1,12,18,9,-10,16,-27,-12,-3,19), M(-13,16,-21,4,-5,-23,-3,5,-13,-38,-6,19,2,23,2,9));\n    F(1, M(-81,11,10,11,-6,-70,2,11,21,12,-52,-2,24,-7,-10,-68), M(0,1,-6,-7,20,3,24,15,-12,-6,-4,0,15,-10,-16,8));\n    F(2, M(-3,7,-7,5,12,0,18,0,-7,-12,2,-6,-8,15,2,-6), M(10,-4,29,-2,8,0,13,1,-5,14,12,-5,-15,16,-26,1));\n    F(3, M(-2,4,4,2,4,4,3,2,7,-1,-3,5,0,2,16,4), M(0,-3,-2,-1,4,-1,2,1,1,3,1,2,-3,-5,-3,3));\n    F(4, M(-21,-5,-19,-13,-1,-24,8,2,-10,11,33,-1,-9,2,-1,7), M(2,2,1,-2,-3,-3,17,24,-4,-2,2,-2,10,-6,1,-6));\n    F(5, M(2,10,2,2,-12,2,-18,-8,5,-6,3,7,-8,-7,0,0), M(-1,-1,3,1,-5,0,-9,-1,-7,8,-2,-4,-3,4,-1,-4));\n  } else { dx = vec4(-18,9,-2,27);\n    F(0, M(22,-20,17,19,13,-14,-9,7,-4,-4,-15,-2,-4,9,-16,19), M(0,-28,-6,-12,23,-30,-3,5,-3,37,41,-2,16,-6,-21,3));\n    F(1, M(-4,-1,-2,-3,3,-8,-1,-14,-6,-15,-11,10,1,-11,-15,-2), M(-9,1,-1,-16,3,11,-4,1,9,-2,-21,-11,0,-8,17,11));\n    F(2, M(-63,26,2,10,-22,-56,7,4,3,-8,-60,6,0,-2,-2,-66), M(-2,-17,-9,-20,-6,-3,-16,-13,-26,-25,-9,7,23,-9,0,-7));\n    F(3, M(7,1,2,5,3,3,-4,5,-1,0,-9,-2,9,18,-1,0), M(1,0,1,2,0,3,1,2,-4,-1,-5,-1,4,0,-4,2));\n    F(4, M(-7,3,16,-12,4,6,-8,4,7,1,-11,10,11,2,-10,12), M(-6,1,4,-9,-2,6,-4,1,15,5,6,5,-1,2,0,-3));\n    F(5, M(24,7,-6,-3,-12,-30,10,0,-4,1,4,14,-6,4,4,-31), M(-7,4,0,10,16,4,1,-8,-7,-3,-10,-6,15,5,4,3));\n  }\n  #undef M\n  #undef F\n  #undef G\n  return dx/500.0;\n}\n\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float W = floor(iResolution.x / 3.);\n    vec2 pos = fragCoord.xy;\n    pos.x = mod(pos.x, W);\n    float band = floor(fragCoord.x / W);\n    \n    if(iFrame==0) {\n      fragColor = hash43(vec3(fragCoord, iFrame))-0.5;\n      return;\n    }\n    \n    vec4 y[6];\n    for (int i=0; i<3; ++i) {\n      vec2 p = vec2(pos.x+W*float(i), pos.y)/iResolution.xy;\n      y[i] = texture(iChannel1, p);\n      y[3+i] = texture(iChannel0, p);\n      \n    }\n    vec4 x = (band==0.) ? y[0] : ((band==1.) ? y[1] : y[2]);\n    vec4 dx = update(band, y);\n\n    //vec4 mask = floor(hash43(vec3(fragCoord, iFrame)) + 0.5);\n    fragColor = clamp(x + dx, -1.5, 1.5);//*mask;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/styGzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 297]], "test": "untested"}
{"id": "slGGzD", "name": "micro Texture NCA (68 params)", "author": "Anony", "description": "\"Texture Generation with Ultra-Compact Neural Cellular Automata\" supplementary material\nA collection of Texture generating NCA-68 rules.\nSee \"Buffer A\" for the NCA code", "tags": ["ca"], "likes": 38, "viewed": 1714, "published": 3, "date": "1637244718", "time_retrieved": "2024-07-30T18:47:28.642161", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init(iResolution);\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0,uv/Scale)+0.5;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 rule0(vec4 s, vec4 p) {\n  return 1e-3*(vec4(24,12,-8,-2)+\n    mat4(-101,5,9,-34,-45,-150,1,-23,-26,97,-33,6,21,26,33,-42)*s+\n    mat4(-17,-75,-91,15,30,82,98,-9,-59,-58,-47,-13,-31,-7,2,-16)*p+\n    mat4(5,27,15,-17,37,45,80,-52,-19,-47,-72,78,61,18,24,-4)*abs(s)+\n    mat4(33,6,13,14,-40,-20,-30,-6,-21,8,17,-13,-31,3,10,-10)*abs(p));     \n}\nvec4 rule1(vec4 s, vec4 p) {\n  return 1e-3*(vec4(-15,-2,-9,24)+\n    mat4(-66,-52,-1,16,21,-88,1,58,-21,36,-91,-42,12,15,7,-42)*s+\n    mat4(38,-75,-41,-62,13,22,23,35,11,15,16,34,0,0,0,0)*p+\n    mat4(-57,42,5,-44,-3,-39,-76,-76,-4,-29,-36,-56,87,-5,61,37)*abs(s)+\n    mat4(-25,-6,-18,-5,-8,13,10,11,-4,6,4,-3,0,-1,1,-2)*abs(p));     \n}\nvec4 rule2(vec4 s, vec4 p) {\n  return 1e-3*(vec4(4,-10,-27,18)+\n    mat4(-67,1,2,44,-13,-59,4,30,-1,16,-57,9,-10,-4,-2,-41)*s+\n    mat4(19,-18,-1,8,-4,35,8,0,-4,-4,-1,0,34,31,21,-25)*p+\n    mat4(4,13,18,-57,-79,-22,-25,71,-12,-11,24,27,-17,-8,-7,6)*abs(s)+\n    mat4(11,10,4,0,4,1,2,7,-26,-33,-15,-3,22,27,20,-34)*abs(p));     \n}\nvec4 rule3(vec4 s, vec4 p) {\n  return 1e-3*(vec4(-17,17,0,-3)+\n    mat4(-102,25,28,-21,-15,-32,62,-47,37,31,-68,-27,-3,18,13,-78)*s+\n    mat4(62,1,34,18,-70,29,-10,-10,1,0,1,1,-29,-19,-26,-65)*p+\n    mat4(-66,-1,-38,-26,108,-17,66,-62,22,-21,10,-51,-16,-16,-16,13)*abs(s)+\n    mat4(20,-17,4,40,1,46,24,-14,9,-6,0,23,-5,-36,-32,-13)*abs(p));     \n}\nvec4 rule4(vec4 s, vec4 p) {\n  return 1e-3*(vec4(-1,1,-5,-19)+\n    mat4(-42,-2,14,-10,6,-35,6,-23,16,19,-37,-10,17,24,16,-33)*s+\n    mat4(19,1,6,0,-18,3,-2,1,1,0,1,-3,25,24,26,35)*p+\n    mat4(7,-10,-7,1,-2,10,2,3,-11,-12,3,-28,1,4,1,-21)*abs(s)+\n    mat4(1,1,2,5,1,2,-1,0,-13,-17,-15,-4,20,22,26,40)*abs(p));     \n}\nvec4 rule5(vec4 s, vec4 p) {\n  return 1e-3*(vec4(9,6,23,-23)+\n    mat4(-173,36,-6,8,32,-111,0,65,7,26,-120,-61,70,26,63,-34)*s+\n    mat4(-57,-85,-63,-1,53,80,57,11,16,20,17,30,0,0,0,-1)*p+\n    mat4(84,-9,69,29,16,-31,-44,-11,21,69,0,-4,-80,-20,-58,0)*abs(s)+\n    mat4(11,19,39,-2,-16,-13,-30,0,0,-8,-11,20,1,-2,-10,4)*abs(p));\n}\nvec4 rule6(vec4 s, vec4 p) {\n  return 1e-3*(vec4(19,-8,5,10)+\n    mat4(-61,25,22,-19,11,-35,40,-16,14,9,-71,-18,22,18,28,-60)*s+\n    mat4(31,-10,21,14,-34,16,-19,-20,-7,-17,-8,8,-21,-9,-8,-50)*p+\n    mat4(10,50,56,-47,-44,-38,-96,29,-27,27,9,3,5,22,11,3)*abs(s)+\n    mat4(0,2,6,-2,-8,-3,-11,-5,-6,2,4,-20,0,-4,-8,24)*abs(p));\n}\nvec4 rule7(vec4 s, vec4 p) {\n  return 1e-3*(vec4(-27,2,0,-4)+\n    mat4(-40,12,2,10,-9,-60,32,30,13,-2,-85,13,-26,-40,-29,-68)*s+\n    mat4(43,18,38,34,-11,38,1,22,-8,-12,-9,-4,27,36,30,68)*p+\n    mat4(20,-19,-8,-9,17,2,21,138,13,51,1,-41,-17,-24,-16,-33)*abs(s)+\n    mat4(8,8,7,-21,3,21,13,5,24,29,21,-27,3,-1,3,12)*abs(p));\n}\nvec4 rule8(vec4 s, vec4 p) {\n  return 1e-03*(vec4(6,-6,-19,-5)+\n    mat4(-68,14,-51,-3,37,-104,-37,21,-5,12,-43,0,27,20,35,-68)*s+\n    mat4(-12,-33,-30,-19,28,34,21,19,-7,-46,-56,2,32,13,5,-24)*p+\n    mat4(18,29,39,58,-81,-19,-5,-24,16,-8,12,-39,-37,-22,-21,21)*abs(s)+\n    mat4(13,8,-1,-12,-4,-1,-1,9,-4,-18,-28,8,-18,5,3,45)*abs(p));\n}\nvec4 rule9(vec4 s, vec4 p) {\n  return 1e-03*(vec4(-12,28,7,4)+\n    mat4(-30,-21,-52,31,9,-32,22,-30,27,29,-60,-8,41,15,-15,-60)*s+\n    mat4(78,-105,-55,3,-11,57,31,22,9,8,17,28,0,0,0,-1)*p+\n    mat4(-46,-8,-22,28,61,-6,141,-4,21,-23,-42,0,-103,-8,-4,-40)*abs(s)+\n    mat4(9,-92,-51,12,30,4,0,7,1,12,6,-36,7,17,9,16)*abs(p));\n}\nvec4 rule10(vec4 s, vec4 p) {\n  return 1e-03*(vec4(45,-17,6,20)+\n    mat4(-32,26,7,15,56,-88,52,-31,-45,61,-47,-2,-7,4,-2,-85)*s+\n    mat4(61,-2,-12,-19,-70,9,17,27,1,8,-18,17,28,-33,-2,-70)*p+\n    mat4(-5,50,7,59,-114,-62,-33,-49,12,78,14,-10,0,9,0,31)*abs(s)+\n    mat4(14,4,-1,-8,-10,-5,1,21,-15,-2,-23,-2,-40,-18,10,-28)*abs(p));\n}\nvec4 rule11(vec4 s, vec4 p) {\n return 1e-03*(vec4(15,-30,-47,61)+\n   mat4(-69,42,46,-8,45,-88,-14,-3,-13,-6,-64,4,-7,-8,-6,-30)*s+\n   mat4(24,4,18,15,-12,-1,-12,-14,6,-2,-2,4,0,-19,-15,34)*p+\n   mat4(-5,52,25,-185,-122,-1,49,-26,-2,-45,26,-15,4,-10,-25,5)*abs(s)+\n   mat4(13,-7,-3,28,-4,0,-1,-10,11,18,8,0,4,23,17,-29)*abs(p));\n}\nconst float ruleN=12.0;\n\nvec4 hash43(vec3 p) {\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 R(float x, float y) {\n    return texture(iChannel0, vec2(x, y));\n}\n\nfloat wrap(float x, float a, float b) {\n  return mod(x-a,b-a)+a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  init(iResolution);\n  vec2 dp = 1.0/iResolution.xy;\n  vec2 pos = fragCoord*dp;\n  \n  if (any(greaterThan(pos*Scale, vec2(1.0))))\n    discard;\n    \n  const float tileSize = 112.0;\n  \n  vec2 sz=1.0/vec2(Scale);\n  float x=pos.x, y=pos.y;\n  vec2 lo = dp*floor(fragCoord/tileSize)*tileSize;\n  vec2 hi = min(lo+tileSize*dp, sz);\n  float l=wrap(x-dp.x, lo.x, hi.x), r=wrap(x+dp.x, lo.x, hi.x);\n  float u=wrap(y-dp.y, lo.y, hi.y), d=wrap(y+dp.y, lo.y, hi.y);\n  vec4 s = R(x,y);\n  if (s == vec4(0, 0, 0, 0) || iMouse.z>0.0 && length(iMouse.xy/Scale-fragCoord)<20.0) {\n    fragColor = hash43(vec3(fragCoord, iFrame))-0.5;\n    return;\n  }  \n  vec4 p = R(l,u)*vec4(1,1,-1, 1) + R(x,u)*vec4(2,2,0, 2) + R(r,u)*vec4(1,1,1, 1)\n         + R(l,y)*vec4(2,2,-2, 0) +  s*vec4(-12,-12,0, 0) + R(r,y)*vec4(2,2,2, 0)\n         + R(l,d)*vec4(1,1,-1,-1) + R(x,d)*vec4(2,2,0,-2) + R(r,d)*vec4(1,1,1,-1);\n  \n  vec4 ds;\n  vec2 rulePos = floor(fragCoord.xy/tileSize);\n  float ri = mod(rulePos.x+rulePos.y*4., ruleN);\n  if (ri<1.0) {ds = rule0(s, p);} \n  else if (ri<2.0) {ds = rule1(s, p);} \n  else if (ri<3.0) {ds = rule2(s, p);}\n  else if (ri<4.0) {ds = rule3(s, p);}\n  else if (ri<5.0) {ds = rule4(s, p);}\n  else if (ri<6.0) {ds = rule5(s, p);}\n  else if (ri<7.0) {ds = rule6(s, p);}\n  else if (ri<8.0) {ds = rule7(s, p);}\n  else if (ri<9.0) {ds = rule8(s, p);}\n  else if (ri<10.0) {ds = rule9(s, p);}\n  else if (ri<11.0) {ds = rule10(s, p);}  \n  else {ds = rule11(s, p);}\n\n\n  fragColor = clamp(s+ds, -1.5, 1.5);\n  \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float Scale = 1.0;\n\nvoid init(vec3 resolution) {\n  float d = max(resolution.x, resolution.y);\n  Scale = ceil(d/1024.0);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slGGzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 171]], "test": "untested"}
{"id": "stG3zW", "name": "Mandelbox Explorer", "author": "incription", "description": "QE, Arrows to move around (No rotation)", "tags": ["raymarching", "fractal", "mandelbox"], "likes": 4, "viewed": 536, "published": 3, "date": "1637239116", "time_retrieved": "2024-07-30T18:47:29.399137", "image_code": "#define MR2 0.25\n#define iters 15\n#define SCALE 2.\n\n#define MAX_STEPS 150\n#define MAX_DIST 50.\n#define SURF_DIST 1e-3\n\nvec4 scalevec = vec4(SCALE, SCALE, SCALE, abs(SCALE)) / MR2;\nfloat C1 = abs(SCALE-1.0), C2 = pow(abs(SCALE), float(1-iters));\nfloat mandelbox(vec3 position) {\n\n  // distance estimate\n  vec4 p = vec4(position, 1.0), p0 = vec4(position, 1.0);  // p.w is knighty's DEfactor\n  for (int i=0; i<iters; i++) {\n    p.xyz = clamp(p.xyz *0.5+0.5, 0.0, 1.0) *4.0-2.0 - p.xyz;  // box fold: min3, max3, mad3\n    float r2 = dot(p.xyz, p.xyz);  // dp3\n    p.xyzw *= clamp(max(MR2/r2, MR2), 0.0, 1.0);  // sphere fold: div1, max1.sat, mul4\n    p.xyzw = p*scalevec + p0;  // mad4\n  }\n  return (length(p.xyz) - C1) / p.w - C2;\n}\n\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}\n\nvec3 rot(vec3 point, vec3 axis, float angle)\n{\n    // based on https://suricrasia.online/demoscene/functions/#erot\n    // axis should be normalized, angle should be in radians\n    vec3 origin = dot(point, axis)*axis;\n    vec3 diff = point - origin;\n    vec3 z_axis = -axis;\n    vec3 x_axis = normalize(diff);\n    vec3 y_axis = normalize(cross(z_axis, x_axis));\n    float R = length(diff);\n    return origin + x_axis*R*cos(angle) + y_axis*R*sin(angle);\n}\n\nvec3 ScenePos(vec3 p) {\n    return rot(p, vec3(0, 1, 0), .7);\n}\n\nfloat GetDist(vec3 p) {\n\tvec3 s = vec3(0);\n    \n    float mb = mandelbox(ScenePos(p));\n    \n    return mb;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) { //ri: tet index, ro: position on tet, rd: direction on tet\n\tfloat dO=0.;\n    float dS = 0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + dO * rd;\n        dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(SURF_DIST*.5, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p, vec3 lightPos) {\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = texelFetch(iChannel0, ivec2(0), 0).xyz;\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    vec3 n;\n\n    float r;\n    r = RayMarch(ro, rd);\n    vec3 p = ro + rd * r;\n    //vec3 n = GetNormal(p);\n    \n    col = vec3(0.992,0.090,0.090)*GetLight(p, ro);\n    if(r>=MAX_DIST)col=vec3(1);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_Q  = 69;\nconst int KEY_E  = 81;\n\n#define SPEED .1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 dat = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 pos = dat.xyz;\n    vec3 dp = vec3(0);\n    \n    dp.x -= texelFetch(iChannel1, ivec2(KEY_LEFT,0),0).x;\n    dp.x += texelFetch(iChannel1, ivec2(KEY_RIGHT,0),0).x;\n    \n    dp.y -= texelFetch(iChannel1, ivec2(KEY_DOWN,0),0).x;\n    dp.y += texelFetch(iChannel1, ivec2(KEY_UP,0),0).x;\n    \n    dp.z -= texelFetch(iChannel1, ivec2(KEY_E,0),0).x;\n    dp.z += texelFetch(iChannel1, ivec2(KEY_Q,0),0).x;\n    \n    pos += dp * SPEED;\n    if(iFrame==0) pos = vec3(0., 0, -20. + iTime/2.);\n    fragColor = vec4(pos, dat.w);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stG3zW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[245, 245, 277, 301, 730], [732, 732, 815, 815, 1293], [1295, 1295, 1341, 1470, 1748], [1750, 1750, 1773, 1773, 1813], [1815, 1815, 1838, 1838, 1923], [1925, 1925, 1959, 2018, 2234], [2236, 2236, 2260, 2260, 2458], [2460, 2460, 2499, 2499, 2717], [2719, 2719, 2776, 2776, 3198]], "test": "untested"}
{"id": "slyGRW", "name": "Quicky \"Glass\" ", "author": "Plento", "description": "Literally just nudging the ray a bit then marching through the stuff, which is probably the quickest way to do this but its slow since your raymarch loop isn't over the first few hits.", "tags": ["3d", "raymarch", "glass"], "likes": 16, "viewed": 420, "published": 3, "date": "1637228443", "time_retrieved": "2024-07-30T18:47:30.150129", "image_code": "// Cole Peterson (Plento)\n\n#define R iResolution.xy\n#define m ((iMouse.xy - .5*R.xy) / R.y)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat rbox( vec3 p, vec3 b, float r ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n// Dave Hoshkin \nfloat hash13(vec3 p3){\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n\n#define b vec3(2., 2., 2.)\n\nvec3 getCell(vec3 p){\n    return floor(p / b);\n}\n\nvec3 getCellCoord(vec3 p){\n    return mod(p, b) - b*.5;\n}\n\nfloat map(vec3 p){\n    vec3 id = getCell(p);\n    p = getCellCoord(p);\n    \n    float rnd = 2.*hash13(id*663.) - 1.;\n    \n    p.xz *= rot(rnd*iTime*.3 + rnd);\n    p.xy *= rot(rnd*iTime*.3 + rnd);\n    p.yz *= rot(p.x*(5.+rnd*10.));\n\n    return rbox(p, vec3(0.7, .16, .16), .1);\n}\n\nvec3 normal( in vec3 pos ){\n    vec2 e = vec2(0.002, -0.002);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\nvec3 color(vec3 ro, vec3 rd, vec3 n, float t){\n    vec3 p = ro + rd*t;\n    vec3 lp = ro + vec3(.0, .0, 2.7);\n    \n    if(iMouse.z>0.) lp.z += m.y*14.;\n    \n    vec3 ld = normalize(lp-p);\n    float dd = length(p - lp);\n    float dif = max(dot(n, ld), .1);\n    float fal = 1. / dd;\n    float spec = pow(max(dot( reflect(-ld, n), -rd), 0.), 23.);\n\n    vec3 id = getCell(p);\n    vec3 objCol = hash33(id*555.);\n    \n    \n    objCol *= (dif + .2);\n    objCol += spec * 0.6;\n    objCol *= fal;\n    \n    return objCol;\n}\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec3 rd = normalize(vec3(uv, 0.8));\n    vec3 ro = vec3(0., 7.0, 4.);\n    rd.xy*=rot(-iTime*.1 + .5);\n    ro.zy += iTime;\n    ro.x += cos(iTime)*.25;\n    \n    int nHits = 0;\n    float d = 0.0, t = 0.0, ns = 0.;\n    vec3 p, n, col = vec3(0);\n    \n    for(int i = 0; i < 80; i++){\n    \td = map(ro + rd*t); \n        \n        if(nHits >= 4 || t >= 12.) break;\n        \n        if(abs(d) < .001){\n            p = ro + rd*t;\n            n = normal(p);\n            \n            if(d > 0. && nHits == 0) rd = refract(rd, n, 1.03);\n            \n            col += color(ro, rd, n, t);\n            \n            nHits++;\n            t += .1;\n        }\n        t += abs(d) * .6;\n        \n        if(nHits == 0) ns++;\n    }\n    \n    col /= float(nHits)*.6;\n    col *= smoothstep(.5, .3, ns * .01);\n    \n    col = 1.-exp(-col);\n    f = vec4(col, 1.0);\n}\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slyGRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 146, 184, 184, 275], [277, 294, 316, 316, 419], [421, 421, 442, 442, 567], [598, 598, 619, 619, 646], [648, 648, 674, 674, 705], [707, 707, 725, 725, 984], [986, 986, 1013, 1013, 1214], [1216, 1216, 1262, 1262, 1728], [1731, 1731, 1771, 1771, 2655]], "test": "untested"}
{"id": "flyGzD", "name": "Helicopter Squadron", "author": "dr2", "description": "Out on a mission...", "tags": ["flight"], "likes": 16, "viewed": 354, "published": 3, "date": "1637222977", "time_retrieved": "2024-07-30T18:47:31.273126", "image_code": "// \"Helicopter Squadron\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat ShowIntPZ (vec2 q, vec2 cBox, float mxChar, float val);\nvec2 Hashv2v2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nmat3 flMat;\nvec3 qHit, sunDir, flDisp;\nvec2 gId;\nfloat tCur, dstFar, hgSize, grLim, hVel, heliSz;\nint idObj;\nconst int idHeli = 1, idRotorM = 2, idRotorT = 3, idSkd = 4, idGun = 5;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{  // (from \"Piz Gloria With Helicopter\")\n  vec3 q;\n  vec2 csRotor;\n  float dMin, d, r, s;\n  csRotor = sin (10.3 * pi * tCur + vec2 (0.5 * pi, 0.));\n  dMin = dstFar / heliSz;\n  p -= flDisp;\n  p.xz = Rot2D (p.xz, 0.25 * pi);\n  p = flMat * p / heliSz;\n  q = p;\n  r = 1.;\n  if (q.z < -0.1) {\n    s = (q.z + 0.1) * (q.z + 0.1);\n    r *= 1. - 0.1 * s;\n    q.y -= 0.05 * s;\n  } else if (q.z > 0.1) {\n    s = (q.z - 0.1) * (q.z - 0.1);\n    r *= 1. - 0.03 * s;\n  }\n  q.x *= 0.8;\n  d = PrCapsDf (q, max (r, 0.), 2.);\n  q = p;\n  q.yz = Rot2D (q.yz - vec2 (1.1, -4.2), -0.05 * pi);\n  r = 0.2 * (1. + 0.25 * q.z);\n  q.y *= 0.7;\n  d = min (d, PrCapsDf (q, r, 1.5));\n  q = p;\n  q.yz -= vec2 (1.7, -0.2);\n  d = min (d, PrCylDf (q.xzy, 0.4, 0.4));\n  q = p;\n  q.yz -= vec2 (0.4, -1.);\n  r = 1.1;\n  if (q.z < 0.) {\n    s = q.z * q.z;\n    r *= 1. - 0.2 * s;\n    q.y -= 0.1 * s;\n  }\n  q.y *= 0.8;\n  d = SmoothMin (d, PrCapsDf (q, max (r, 0.), 1.5), 0.03);\n  q = p;\n  q.yz -= vec2 (1.4, -6.15);\n  d = min (d, max (PrRoundCylDf (q.yzx, 0.5, 0.05, 0.02), 0.35 - length (q.yz)));\n  q = p;\n  DMINQ (idHeli);\n  q = p;\n  q.yz = Rot2Cs (q.yz - vec2 (1.4, -6.15), csRotor);\n  d = PrRoundBoxDf (q, vec3 (0.01, 0.32, 0.04), 0.02);\n  DMINQ (idRotorT);\n  q = p;\n  q.yz -= vec2 (2., -0.2);\n  d = PrCylDf (q.xzy, 0.12, 0.5);\n  q.y -= 0.4;\n  q.xz = Rot2Cs (q.xz, csRotor);\n  d = min (d, PrRoundBoxDf (q, vec3 (4.5, 0.02, 0.08), 0.03));\n  DMINQ (idRotorM);\n  q = p;\n  q.x = abs (q.x);\n  q.xy -= vec2 (0.9, -1.4);\n  d = PrRoundBoxDf (q, vec3 (0.1, 0.01, 1.4), 0.04);\n  q.xy = Rot2D (q.xy, -0.1 * pi);\n  q.z = abs (q.z);\n  q.yz -= vec2 (0.4, 0.7);\n  d = min (d, PrCylDf (q.xzy, 0.06, 0.4));\n  DMINQ (idSkd);\n  q = p;\n  q.yz -= vec2 (-0.8, 2.1);\n  d = PrCapsDf (q.xzy, 0.2, 0.2);\n  q.yz -= vec2 (-0.2, 0.3);\n  d = min (d, PrCylDf (q, 0.1, 0.3));\n  DMINQ (idGun);\n  return 0.7 * heliSz * dMin;\n}\n\nvoid ObjState ()\n{\n  vec3 vd, cb, sb;\n  vec2 h;\n  float tc, t, tt, flPit, flYaw, flRol;\n  tc = tCur + 0.7 * (gId.x + gId.y);\n  t = cos (2. * pi * mod (0.6 * tc, 1.));\n  tt = (mod (0.3 * tc, 6.) - 2.) / 4.;\n  h = Hashv2v2 (vec2 (17.1, 19.1) * gId + 1.1) - 0.5;\n  flDisp.xz = hgSize * (gId + 0.5 + 0.2 * h);\n  flDisp.y = 2. + ((tt > 0.) ? 0.2 * (1. - t) + (7. + dot (h, vec2 (0.5))) *\n     SmoothBump (0.2, 0.8, 0.2, tt) : 0.);\n  flPit = 0.03 * pi + 0.02 * pi * sin (0.4 * pi * (h.x + h.y) * tCur);\n  flYaw = 0.03 * pi * sin (0.3 * pi * h.y * tCur);\n  flRol = 0.02 * pi * sin (0.2 * pi * h.x * tCur);\n  cb = cos (vec3 (flPit, flYaw, flRol));\n  sb = sin (vec3 (flPit, flYaw, flRol));\n  flMat = mat3 (1., 0., 0., 0., cb.x, - sb.x, 0., sb.x, cb.x) *\n          mat3 (cb.z, - sb.z, 0., sb.z, cb.z, 0., 0., 0., 1.) *\n          mat3 (cb.y, 0., - sb.y, 0., 1., 0., sb.y , 0., cb.y);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{ // (from \"Flying Bathtubs\")\n  vec3 p, rdi;\n  vec2 gIdP, s;\n  float dHit, d, eps;\n  eps = 0.0005;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  rdi.xz = 1. / rd.xz;\n  gIdP = vec2 (-999.);\n  dHit = eps;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    gId = floor (p.xz / hgSize);\n    if (gId != gIdP) {\n      ObjState ();\n      gIdP = gId;\n    }\n    d = (Maxv2 (abs (gId)) <= grLim) ? ObjDf (p) : dstFar;\n    s = (hgSize * (gId + step (0., rd.xz)) - p.xz) * rdi.xz;\n    d = min (d, abs (Minv2 (s)) + eps);\n    dHit += d;\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  gIdP = vec2 (-999.);\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    gId = floor (p.xz / hgSize);\n    if (gId != gIdP) {\n      ObjState ();\n      gIdP = gId;\n    }\n    if (Maxv2 (abs (gId)) <= grLim) {\n      h = ObjDf (p);\n      sh = min (sh, smoothstep (0., 0.05 * d, h));\n    } else h = 0.3 * hgSize;\n    d += clamp (h, 0.02, 0.5);\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol;\n  vec2 q;\n  float f, fd, ff;\n  q = 0.01 * (ro.xz + tCur * vec2 (0.5, 2.) + ((100. - ro.y) / rd.y) * rd.xz);\n  ff = Fbm2 (q);\n  f = smoothstep (0.1, 0.8, ff);\n  fd = smoothstep (0.1, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n  clCol = (0.8 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n     smoothstep (0., 0.05, abs (fd)));\n  fd = smoothstep (0.01, 0.1, rd.y);\n  col = mix (mix (vec3 (0.8, 0.8, 0.75), vec3 (0.4, 0.5, 0.8), 0.3 + 0.7 * fd), clCol,\n     0.1 + 0.9 * f * fd);\n  return col;\n}\n\nfloat GrndHt (vec2 p)\n{  // (from \"Wind Farm\")\n  return Fbm2 (0.4 * p) - 0.45;\n}\n\nfloat GrndHtN (vec2 p)\n{\n  float h;\n  h = GrndHt (p);\n  if (h > 0.) h = 0.3 * h + 0.3 * Fbm2 (2. * p);\n  return h;\n}\n\nvec3 GrndNf (vec2 p)\n{\n  vec2 e;\n  e = vec2 (0.001, 0.);\n  return normalize (vec3 (GrndHtN (p) - vec2 (GrndHtN (p + e.xy), GrndHtN (p + e.yx)), e.x)).xzy;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, row;\n  vec2 s;\n  float dstObj, dstGrnd, sh;\n  bool wtRefl;\n  heliSz = 0.5;\n  wtRefl = false;\n  dstGrnd = (rd.y < 0.) ? - ro.y / rd.y : dstFar;\n  dstObj = ObjRay (ro, rd);\n  if (dstGrnd < min (dstObj, dstFar)) {\n    row = ro + dstGrnd * rd;\n    s = row.xz + (hVel / sqrt(2.)) * tCur;\n    if (GrndHt (s) < 0.) {\n      ro = row;\n      row.xz = s;\n      vn = VaryNf (2. * row, vec3 (0., 1., 0.), 0.05 * (1. - smoothstep (0.1, 0.4, dstGrnd / dstFar)));\n      rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n      dstObj = ObjRay (ro, rd);\n      dstGrnd = dstFar;\n      wtRefl = true;\n    }\n  }\n  if (min (dstObj, dstGrnd) < dstFar) {\n    if (dstObj < dstGrnd) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      if (idObj == idHeli) {\n        col4 = mix (vec4 (1., 0., 0., 0.2), vec4 (0.75, 0.85, 0.9, 0.2), smoothstep (0., 0.02,\n           abs (qHit.y) - 0.04));\n        if (length (vec2 (qHit.x, qHit.y / 0.8)) > 1.24 && qHit.y > 0.55 && qHit.z > 0.4 &&\n           abs (abs (qHit.x) - 0.3) > 0.05) col4 = vec4 (0., 0.5, 0.5, -1.);\n        if (PrRoundBox2Df (qHit.zy - vec2 (-1., 0.8), vec2 (1.2, 0.6), 0.01) < 0.) col4 =\n           mix (col4, vec4 (1., 0., 0., 0.2), ShowIntPZ ((qHit.zy - vec2 (-1.2 + 0.4 * sign (qHit.x), 0.8)),\n           vec2 (sign (qHit.x), 0.5), 3., 1. + grLim - gId.x + (2. * grLim + 1.) * (grLim - gId.y)));\n      } else if (idObj == idRotorM) {\n        col4 = (length (qHit.xz) < 4.2) ? vec4 (0.8, 0.8, 0.9, 0.1) : vec4 (1., 1., 0.2, 0.1);\n      } else if (idObj == idRotorT) {\n        col4 = (length (qHit.yz) > 0.06) ? vec4 (0.8, 0.8, 0.9, 0.1) : vec4 (1., 1., 0.2, 0.1);\n      } else if (idObj == idSkd) {\n        col4 = vec4 (0.7, 0.7, 0.75, 0.1);\n      } else if (idObj == idGun) {\n        col4 = vec4 (0.8, 0.8, 0.8, 0.2);\n      }\n    } else {\n      ro += dstGrnd * rd;\n      gId = floor (ro.xz / hgSize);\n      s = ro.xz + (hVel / sqrt(2.)) * tCur;\n      col4 = mix (vec4 (0.4, 0.5, 0.3, 0.), vec4 (0., 0.5, 0.1, 0.),\n         smoothstep (0.2, 0.8, Fbm2 (4. * s)));\n      col4 = mix (vec4 (0.2, 0.5, 0.2, 0.), col4,  1. - smoothstep (0.3, 0.6, dstGrnd / dstFar));\n      vn = GrndNf (s);\n    }\n    if (col4.a >= 0.) {\n      sh = (min (dstObj, dstGrnd) < dstFar) ? ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;\n      col = col4.rgb * (0.2 + 0.2 * max (- dot (vn, sunDir), 0.) + 0.8 * sh * max (dot (vn, sunDir), 0.)) +\n         step (0.95, sh) * col4.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n      col = mix (col, SkyCol (ro, rd), (wtRefl ? 0.2 + 0.8 * smoothstep (0.4, 0.6, dstObj / dstFar) :\n         smoothstep (0.8, 0.9, min (dstGrnd, dstObj) / dstFar)));\n    } else col = mix (col4.rgb, SkyCol (ro, reflect (rd, vn)), 0.8);\n  } else col = SkyCol (ro, rd);\n  col *= vec3 (1., 0.85, 0.85) * (wtRefl ? 0.85 : 1.);\n  return clamp (col, 0., 1.);\n}\n\n#define AA  0   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  hgSize = 8.;\n  grLim = 4.;\n  hVel = 2.;\n  az = pi;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az -= 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  } else {\n    az = pi + 2. * pi * (0.5 + abs (mod (0.01 * tCur, 2.) - 1.));\n  }\n  el = clamp (el, -0.2 * pi, 0.2 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (0., 2., -4. - 1.4 * (grLim + 1.) * hgSize * (0.9 - 0.1 * cos (4. * az)));\n  ro.xz = Rot2D (ro.xz, - az) + 0.5 * hgSize;\n  zmFac = 2.5;\n  dstFar = 150.;\n  sunDir = vuMat * normalize (vec3 (1., 1.5, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat DigSeg (vec2 q)\n{\n  q = 1. - smoothstep (vec2 (0.), vec2 (0.04, 0.07), abs (q) - vec2 (0.13, 0.5));\n  return q.x * q.y;\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  vec2 vp, vm, vo;\n  float d;\n  int k, kk;\n  vp = vec2 (0.5, 0.5);\n  vm = vec2 (-0.5, 0.5);\n  vo = vp - vm;\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowIntPZ (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (Minv2 (q) >= 0. && Maxv2 (q) < 1.) {\n    q.x *= mxChar;\n    nDig = mxChar;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = max (val, 0.) / pow (10., mxChar - idChar - 1.);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flyGzD.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1150, 1150, 1172, 1212, 3025], [3027, 3027, 3045, 3045, 3901], [3903, 3903, 3936, 3964, 4602], [4604, 4604, 4625, 4625, 4880], [4882, 4882, 4919, 4919, 5408], [5410, 5410, 5442, 5442, 5971], [5973, 5973, 5996, 6019, 6053], [6055, 6055, 6079, 6079, 6171], [6173, 6173, 6195, 6195, 6329], [6331, 6331, 6366, 6366, 9184], [9228, 9228, 9284, 9284, 10501], [10503, 10503, 10549, 10549, 10596], [10598, 10598, 10645, 10645, 10692], [10694, 10694, 10736, 10736, 10787], [10789, 10789, 10832, 10832, 10896], [10898, 10898, 10955, 10955, 11031], [11033, 11033, 11055, 11055, 11082], [11084, 11084, 11106, 11106, 11133], [11135, 11135, 11180, 11180, 11272], [11274, 11274, 11319, 11319, 11357], [11359, 11359, 11416, 11416, 11499], [11501, 11501, 11537, 11537, 11743], [11745, 11745, 11775, 11775, 11888], [11890, 11890, 11921, 11921, 11985], [11987, 11987, 12010, 12010, 12114], [12187, 12187, 12219, 12219, 12767], [12769, 12769, 12831, 12831, 13198], [13232, 13232, 13256, 13256, 13368], [13370, 13370, 13395, 13395, 13581], [13583, 13583, 13604, 13604, 13759], [13761, 13761, 13790, 13790, 14002], [14004, 14004, 14043, 14043, 14295]], "test": "untested"}
{"id": "ftyGzD", "name": "Red X of Death", "author": "brisingre", "description": "Worrying aura", "tags": ["error", "2dshapes"], "likes": 1, "viewed": 203, "published": 3, "date": "1637222175", "time_retrieved": "2024-07-30T18:47:32.033094", "image_code": "float sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float box1 = sdOrientedBox(uv, vec2(-1, -1), vec2(2, 2), .1);\n    float box2 = sdOrientedBox(uv, vec2(2, -1), vec2(-1, 2), .1);\n    \n    float x = min(box1, box2);\n    \n    float baseX = smoothstep(.00, .001, x);\n    \n    vec4 xColor = vec4(1., 0, 0, 1.) * ((sin(2. * iTime) + 1.)/2.);\n    vec4 bgColor = vec4(.5, 0, 0, 1.) * ((sin(11. * iTime) + 1.)/2.);\n    \n    // Output to screen\n    fragColor = mix(bgColor, xColor, baseX);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftyGzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 66, 66, 283], [285, 285, 342, 392, 869]], "test": "untested"}
{"id": "flyGzW", "name": "bezier eye-jf", "author": "jorge2017a2", "description": "bezier surface", "tags": ["beziersurface"], "likes": 1, "viewed": 235, "published": 3, "date": "1637207701", "time_retrieved": "2024-07-30T18:47:32.996519", "image_code": "///-------------image\n//por jorge2017a2-\n//referencia\n//https://iquilezles.org/articles/distfunctions\n//https://www.shadertoy.com/view/tlsfzf\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\nfloat SimpleBezier(vec2 p)\n{   vec2 pt1 = vec2(-2.25, -0.40);\n    vec2 pt2 = vec2(-0.35, 2.22);\n    vec2 pt3 = vec2(2.15, 0.40);\n\n    float d1 = sdBezier(pt1, pt2, pt3, p);\n    float d2 = sdBezier(pt1,-pt2, pt3, p);\n    float dinter=differenceSDF(d2, d1);\n    \n    return dinter;\n}\n\n\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    p.y=p.y-5.0;\n    vec3 p0=p;\n    float planeDist1 = p.y+10.0;  //piso inf\n   \n    res =opU3(res, vec3(planeDist1,-1.0,7.0)); //inf\n    \n    float dCabeza= sdEllipsoid(p- vec3(-2.0,0.0,2.5), vec3(6.0,7.0,5.0) );\n    \n    float t=iTime*2.0;\n    float pOjy=0.25*sin(t);\n    \n    float dCyA1= sdCylinderXY(p- vec3(0.0,0.0+pOjy,.0), vec2(0.65,3.5)  );\n    float dCyA2= sdCylinderXY(p- vec3(0.0,0.0+pOjy,.0), vec2(0.25,3.5)  );\n    float dCyB1= sdCylinderXY(p- vec3(-5.0,0.0+pOjy,.0), vec2(0.75,4.0)  );\n    float dCyB2= sdCylinderXY(p- vec3(-5.0,0.0+pOjy,.0), vec2(0.25,4.5)  );\n    \n    \n    float pbx=-5.0;\n    float dSb1A= SimpleBezier(vec2(p.x, -p.y)-vec2(pbx,0.0));\n    float dE1A= sdEllipsoid(p- vec3(pbx,0.0,0.0), vec3(4.0,3.0,3.0) );\n    float dInterA=intersectSDF(dSb1A,dE1A);\n    \n    float dSb1B= SimpleBezier(p.xy);\n    float dE1B= sdEllipsoid(p- vec3(0.0,0.0,0.0), vec3(4.0,3.0,3.0) );\n    float dInterB=intersectSDF(dSb1B,dE1B);\n    \n    dInterA=intersectSDF(dCabeza,dInterA);\n    dInterB=intersectSDF(dCabeza,dInterB);\n    \n    dCyA1=intersectSDF(dCabeza,dCyA1);\n    dCyA2=intersectSDF(dCabeza,dCyA2);\n    \n    float dBoca=sdBox( p- vec3(-2.5,-2.0,0.0), vec3(2.0,0.255,5.0)  );\n    dBoca=intersectSDF(dCabeza,dBoca);\n    \n    res =opU3(res, vec3(dCabeza,33.0,-1.0));\n    res =opU3(res, vec3(dInterA,1.0,-1.0));\n    res =opU3(res, vec3(dInterB,1.0,-1.0));\n    res =opU3(res, vec3(dCyA1,4.0,-1.0));\n    res =opU3(res, vec3(dCyA2,3.0,-1.0));\n    res =opU3(res, vec3(dCyB1,4.0,-1.0));\n    res =opU3(res, vec3(dCyB2,3.0,-1.0));\n    res =opU3(res, vec3(dBoca,2.0,-1.0));\n    \n    return res;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{   vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true)\n        {fshadow=GetShadow(p,lp);}\n    else\n        {fshadow=0.5;}\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    lin += 0.4*pow(clamp(dot(hal,n),0.0,1.0),12.0)*dif3;\n      lin *= atten*0.5*col*fshadow;\n    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    lin = pow(lin,vec3(0.4545));\n    return lin;\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    if (id_material==7.0)\n    {return pattern( p.xz );}\n    \n    if (id_material==8.0)\n    {return pattern( p.xy );}\n    \n    if (id_material==9.0)\n    {return pattern( p.zy );}\n}\n\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n\n    if (id_material>-1.0 && id_color==-1)\n        {   colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n   \n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n    \n   \n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 10.0, -25.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 30.0, -25.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(1.0,5.0,-15.0);\n   \n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    //col = exposureToneMapping(2.0, col);\n    col = linear2srgb(col);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------common\n///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n\n\n\n// 2D SDF functions from iq: https://iquilezles.org/articles/distfunctions2d\n\nfloat dot2(in vec2 v ) { return dot(v,v); }\nfloat dot3(in vec2 v ) { return dot(v,v) * length(v); }\nfloat dot4(in vec2 v ) { return dot(v,v) * dot(v,v); }\n\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n\n\n\n\n// unsigned distance to a quadratic bezier\nfloat udBezier(in vec2 A, in vec2 B, in vec2 C, in vec2 pos)\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if( h>=0.0 ) \n    {   // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d+(c+b*t)*t);\n    }\n    else \n    {   // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest. See https://www.shadertoy.com/view/4dsfRS\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    \n    return sqrt( res );\n}\n\n// signed distance to a quadratic bezier\nfloat sdBezier(in vec2 A, in vec2 B, in vec2 C, in vec2 pos)\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n    float sgn = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if( h>=0.0 ) \n    {   // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        vec2  q = d+(c+b*t)*t;\n        res = dot2(q);\n    \tsgn = cross2(c+2.0*b*t,q);\n    }\n    else \n    {   // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\n        vec2  qx=d+(c+b*t.x)*t.x; float dx=dot2(qx), sx = cross2(c+2.0*b*t.x,qx);\n        vec2  qy=d+(c+b*t.y)*t.y; float dy=dot2(qy), sy = cross2(c+2.0*b*t.y,qy);\n        if( dx<dy ) { res=dx; sgn=sx; } else {res=dy; sgn=sy; }\n    }\n    \n    return sqrt( res )*sign(sgn);\n}\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flyGzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[604, 604, 636, 636, 720], [721, 721, 760, 760, 855], [856, 856, 895, 895, 990], [991, 991, 1030, 1030, 1125], [1127, 1171, 1218, 1218, 1245], [1246, 1246, 1289, 1289, 1316], [1317, 1317, 1365, 1365, 1393], [1395, 1420, 1454, 1454, 1550], [1551, 1551, 1585, 1585, 1676], [1677, 1677, 1711, 1711, 1802], [1804, 1844, 1878, 1878, 1973], [1976, 1976, 2004, 2004, 2257], [2261, 2261, 2298, 2298, 2381], [2383, 2423, 2448, 2448, 4084], [4086, 4137, 4161, 4161, 4323], [4325, 4325, 4374, 4374, 5041], [5045, 5045, 5081, 5081, 5326], [5328, 5328, 5355, 5355, 5372], [5374, 5374, 5410, 5410, 5502], [5503, 5503, 5549, 5549, 5674], [5676, 5676, 5750, 5750, 7310], [7312, 7312, 7392, 7392, 7515], [7517, 7517, 7549, 7549, 7746], [7748, 7796, 7824, 7824, 8012], [8015, 8066, 8113, 8113, 8342], [8344, 8396, 8489, 8489, 8815], [8818, 8818, 8849, 8849, 9453], [9455, 9504, 9530, 9530, 9640], [9642, 9642, 9700, 9700, 9752], [9754, 9803, 9860, 9860, 10453]], "test": "untested"}
{"id": "ftyGzW", "name": "Boxes (API Test)", "author": "brisingre", "description": "An extremely simple shader with no inputs. I'm using this to test basic shader loading and compilation via the API, so it has to be public. You can too, if you want to. ", "tags": ["apitesting"], "likes": 0, "viewed": 47, "published": 3, "date": "1637207618", "time_retrieved": "2024-07-30T18:47:33.748508", "image_code": "float size = 100.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float x = fragCoord.x;\n    float y = fragCoord.y;\n    float grid = 1.0 - min(mod(y, size), mod(x, size));\n    \n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(mix(col, vec3(0.0, 0.0, 0.0), grid), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftyGzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 78, 128, 472]], "test": "untested"}
{"id": "NtyGRW", "name": "Persian carpet 26", "author": "jarble", "description": "More experiments with fractal carpet designs.", "tags": ["fractal", "carpet", "rug"], "likes": 1, "viewed": 228, "published": 3, "date": "1637202015", "time_retrieved": "2024-07-30T18:47:34.509473", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 4.5/8.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime/2.+uv.x)/10.0);\n    vec3 random1 = (hash31(3.+t2)-.5)/12.;\n    vec3 random2 = (hash31(4.+t2)-.5)/12.;\n    vec3 random3 = (hash31(3.+t2)-vec3(.5))/1.5;\n    //vec3 random4 = (hash31(4.+t2)-vec3(.5))/4.;\n    \n    float offset = .5;\n    float scale2 = 1.5;\n    float bend = 1.;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        //float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            vec2 t2 = vec2(0.);\n            vec2 t3 = vec2(0.);\n            for(int k = 0; k < 3; k++){    \n                uv /= -scale2;\n                //float bend = 1.+random3[k];\n                //bend = abs(fract((uv.x)*2.)-.5)/2.+1.;\n                //bend = 1.+1./3.;\n                //bend = scale2/1.5;\n                \n                //bend = abs(fract(((uv.x*bend+uv.y/bend)/scale2))-.5)+1.-col.x;\n\n                //uv *= bend-col.x;\n                //uv += t2.yx/scale;\n                t2 = triangle_wave(uv.yx-offset,scale);\n                t3 = triangle_wave(uv,scale);\n                uv.yx = t2/bend+t3*bend;\n                //uv.yx = triangle_wave(uv.yx-offset/1.5,scale)*bend-triangle_wave(uv-offset,scale)/bend;\n\n                //bend += 1./(1.+uv.x+uv.y);\n                //bend = 1./bend;\n                uv += vec2(random1[k],random2[k]);  \n                bend *= -1.;\n                bend -= 1./3.-col.x;\n            }\n            \n\n            //offset += .5;\n            scale /= 1.+(scale2)*col.x/(8.);\n            scale2 -= (col.x-1.)/(4.);\n\n\n            col[c] = abs((uv.x)-(uv.y));\n            //random2 = col - random2;\n            \n\n        }\n\t}\n    \n    fragColor = vec4(vec3(col*2.),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtyGRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [590, 590, 629, 629, 674], [676, 676, 733, 733, 2687]], "test": "untested"}
{"id": "ftyGRW", "name": "Stochastic texture synthesis", "author": "public_int_i", "description": "stochastic texture synthesis by example", "tags": ["texture", "synthesis", "stochastic"], "likes": 4, "viewed": 360, "published": 3, "date": "1637201514", "time_retrieved": "2024-07-30T18:47:35.274428", "image_code": "//Ethan Alexander Shulman xaloez.com 2021 CC0 public domain\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel1,ivec2(texelFetch(iChannel0,ivec2(fragCoord),0).xy),0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//Ethan Alexander Shulman xaloez.com 2021 CC0 public domain\n\n/*detail size in pixels, higher value is more accurate to source texture\nbut takes longer to resolve noise*/\n#define DETAIL_SIZE 2\n\n\n//uvec4 seed, returns uvec4 hash\nuvec4 hash(uvec4 seed) {\n    uvec4 h = (0x6A7F8FAAu^seed)*0x01000193u;\n    h = ((h.wxyz>>3u)^h^seed.yzwx)*0x01000193u;\n    h = ((h.zwxy>>8u)^h^seed.wxyz)*0x01000193u;\n    return h^(h>>11u);\n}\n#define I2F (1./float(0xFFFFFFFFu))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #define SS iChannelResolution[1]\n    uvec4 hv = hash(uvec4(fragCoord.xyy,iDate.w*100.));\n    if (iFrame < 60 || iMouse.w > 0.) {\n        //initialize\n        fragColor = vec4(hv.xy%uvec2(SS.xy),0,1);\n        return;\n    }\n    \n    float mdst = 0.;\n    vec2 sc = texelFetch(iChannel0,ivec2(fragCoord),0).xy,\n        mc = sc, oscale = vec2(1u+hv.zw%uint(DETAIL_SIZE));\n    vec4 sv = pow(texelFetch(iChannel1,ivec2(sc.xy),0),vec4(2.2));\n    for (float x = -1.; x < 2.; x++) {\n        for (float y = -1.; y < 2.; y++) {\n            vec2 off = vec2(x,y)*oscale,\n                px = fragCoord+off;\n            if (min(px.x,px.y) < 0. || max(px.x-iResolution.x,px.y-iResolution.y) >= 0. ||\n                (x ==0. && y == 0.)) continue;\n            \n            vec2 oc = texelFetch(iChannel0,ivec2(px),0).xy,\n                c0 = sc+off, c1 = oc-off;\n            if (min(c0.x,c0.y) < 0. || max(c0.x-SS.x,c0.y-SS.y) >= 0. ||\n               min(c1.x,c1.y) < 0. || max(c1.x-SS.x,c1.y-SS.y) >= 0.) continue;  \n            vec4 ov = pow(texelFetch(iChannel1,ivec2(oc),0),vec4(2.2));\n            float dst = length(ov.xyz-pow(texelFetch(iChannel1,ivec2(sc+off),0).xyz,vec3(2.2)))-\n                        length(sv.xyz-pow(texelFetch(iChannel1,ivec2(oc-off),0).xyz,vec3(2.2)));\n            if (dst > mdst) {\n                mc = oc-off;\n                mdst = dst;\n            }\n        }\n    }\n    \n    fragColor = vec4(mc,0,1);\n}", "buffer_a_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftyGRW.jpg", "access": "api", "license": "public-domain", "functions": [[61, 61, 118, 118, 212]], "test": "untested"}
{"id": "7tKGz1", "name": "Picture frames", "author": "jarble", "description": "An arrangement of decorated wooden frames.", "tags": ["fractal", "wood", "frame", "carving"], "likes": 2, "viewed": 247, "published": 3, "date": "1637192027", "time_retrieved": "2024-07-30T18:47:36.088252", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 9.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime/2.+uv.x)/10.0);\n    //vec3 random1 = (hash31(3.+t2)-.5)/12.;\n    //vec3 random2 = (hash31(4.+t2)-.5)/12.;\n    //vec3 random3 = (hash31(3.+t2)-vec3(.5))/1.5;\n    //vec3 random4 = (hash31(4.+t2)-vec3(.5))/4.;\n    \n    float offset = .5;\n    float scale2 = 1.5;\n    float bend = 1.;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        //float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            \n            for(int k = 0; k < 9; k++){    \n                uv /= -scale2;\n                //float bend = 1.+random3[k];\n                //bend = abs(fract((uv.x)*2.)-.5)/2.+1.;\n                //bend = 1.+1./3.;\n                //bend = scale2/1.5;\n                \n                //bend = abs(fract(((uv.x*bend+uv.y/bend)/scale2))-.5)+1.-col.x;\n\n                \n                uv.yx = triangle_wave(uv.yx-offset,scale)/bend+triangle_wave(uv-offset/scale2,scale)*bend;\n                //bend += 1./(1.+uv.x+uv.y);\n                bend *= -1.;\n                //bend -= 1./3.-col.x;\n                \n                //uv += vec2(random1[k],random2[k]);                \n            }\n            \n\n            //offset += .5;\n            scale /= 1.+(scale2)*col.x/(8.);\n            scale2 -= (col.x-1.)/(4.);\n\n\n            col[c] = abs((uv.x)-(uv.y));\n            //random2 = col - random2;\n            \n\n        }\n\t}\n    \n    fragColor = vec4(vec3(col*2.),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tKGz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [590, 590, 629, 629, 674], [676, 676, 733, 733, 2456]], "test": "untested"}
{"id": "7tKGR1", "name": "Infinity Circles", "author": "Txoka", "description": "Just infinity circles", "tags": ["fractal", "circles", "inversion"], "likes": 23, "viewed": 564, "published": 3, "date": "1637190332", "time_retrieved": "2024-07-30T18:47:36.837249", "image_code": "#define R iResolution\nfloat dot2(vec2 x){return dot(x,x);}\n\n\n//Shane's version here\nvoid mainImage( out vec4 O, in vec2 C ){\n    // Screen coordinates.\n    vec2 uv=(2.*C - R.xy)/R.y;\n\n    // Smoothing factor.\n    float w=3./R.y/dot2(uv);\n\n    // Inversion of coordinates.\n    uv/=dot2(uv);\n\n    // Borders.\n    float k=min(abs(uv.x+1.),abs(uv.x+4.));\n    // Repeat circles inside the borders.\n    if(uv.x<-1.&&uv.x>-4.)k=min(k,abs(dot2(fract(uv)-.5)-.25));\n   \n    // Isolines.\n    k=smoothstep(1.,0.,k/w);\n    \n    // Screen presentation. No gamma correction.\n    O=vec4(vec3(k),1);\n}\n\n//Original version here\n/*\nvoid mainImage( out vec4 O, in vec2 C ){\n    float p=3./R.y;\n    vec2 uv=(C*2.-R.xy)/R.y;\n    float w=dot2(uv);\n    \n    uv=uv.yx*vec2(1,-1);\n    uv/=dot(uv,uv);\n    \n    vec3 col=vec3(0);\n    \n    col+=smoothstep(1.,0.,abs(uv.y-1.)*w/p);\n    col+=smoothstep(1.,0.,abs(uv.y-4.)*w/p);\n    if(uv.y>=1.&&uv.y<4.){\n        float k=dot2(fract(uv)*2.-1.)-1.;\n        col+=smoothstep(1.,0.,0.25*abs(k)*w/p);\n    }\n    O = vec4(col,1.0);\n}*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tKGR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 41, 41, 58], [61, 84, 124, 151, 585]], "test": "untested"}
{"id": "stK3Rh", "name": "FM1 A2 middle-c-zoom 2021", "author": "ollj", "description": "mouser.y zooms;(mid=floor(....\na 2,5 year old shader with ugly audio clipping gets a feature:\niMouse.y cycles trhough 4 different keyboard layouts.\nmiddle C i always highlighted properly\nthe framing is pretty wrong (corner centric) and i am too tuired now", "tags": ["music", "magic", "modulo", "pony", "mlp", "sequence", "audiovisual", "hall", "inside", "sheet", "cutiemark", "ingram", "sequences"], "likes": 8, "viewed": 555, "published": 3, "date": "1637181245", "time_retrieved": "2024-07-30T18:47:37.769757", "image_code": "//This shader\n//https://www.shadertoy.com/view/ldsBz8\n//has the parent:\n//https://www.shadertoy.com/view/MdXfW4\n//[ldsBz8] uses the [common] tab feature, that was added netween the 2 above links\n//while [MdXfW4] has the sequence-functions of sheet() duped.\n\n//all comments about how the same functions \n//are used to show a sequence and how to make it audible are in the\n//[common] tab\n\n//please have the common tap support iResolution.xy and iMouse, and whatnot.\n\n//iResolution is read by +me(), therefore it can not move to the common tab:\n//for a midi-sheet, zoom==numberOfGkeysOnScreen\n//#define zoom 60.\n//#define frame(u) zoom*(u-.5*iResolution.xy)/iResolution.y\n//vec2 frame(vec2 u){u/=iResolution.xy;u.x*=iResolution.x/iResolution.y;return u*zoom;}\n\n\n//core frame function is non--centric, but consistzently used so its an easy swap\n\n//framing mess\nvec2 fra (vec2 u){u/=iResolution.xy;u-=.5    ;u.x*=iResolution.x/iResolution.y;return u;}\nvec2 fraM(vec2 u){u/=iResolution.xy          ;u.x*=iResolution.x/iResolution.y;return u;}\nvec2 fraK(vec2 u){u/=iResolution.xy;u.x-=.25;u.x*=iResolution.x/iResolution.y;return u;}\n//k=numberOfKeys\nvec2 frameMidiSheet(vec2 u,float k){return fraK(u)*k;}\n\n\n\n//this block adds a cutiemark mouse cursor\n//\n//with  ;O=pdOver(cuteCursor(U,iMouse.xy),O);}// at the end of MainImage()\n#define vec1 float\n//porter duff alpha compositing:\n//i do not define ut ..., because its a too short namespace to be spent on a define.\nvec4 ut(vec4 a,vec1 b){return a*(1.-b);}//#define ut(a,b) (a*(1.-b))\n//note; colors atop of identical color is a too easy debugging culpit.\n//note,that atop may returns the alpha of a,and not the alpha max(a,b)\nvec4 pdOut(vec4 a,vec4 b){return ut(b,a.w);}\nvec4 pdOver(vec4 a,vec4 b){return ut(b,a.w)+a;}\nvec4 pdAtop(vec4 a,vec4 b){return ut(b,a.w)+a*b.w;}\nvec4 pdXor(vec4 a,vec4 b){return ut(b,a.w)+ut(a,b.w);}\n//self:https://www.shadertoy.com/view/MsffWr\n//https://www.reddit.com/r/mylittlepony/comments/6d3kqb/cutiemark_shader_texture_cheerilee/\n//cheerilee cutie mark flowers\n//cartoon pony butt for reference:\n//https://vignette3.wikia.nocookie.net/mlp/images/3/3f/Cheerilee%27s_cutie_mark_S1E12.png/revision/latest?cb=20121118163857&format=original\n//return distance of(p)to ray that starts at(0,0)and has direction(0,-1);\nfloat ils(vec2 p){return mix(abs(p.y),length(p),step(0.,p.x));}\n//return cathesian of polar_modulo http://mercury.sexy/hg_sdf\nfloat pModPolar(inout vec2 p,float t){float g=tau/t,a=atan(p.y,p.x)+g*.5,r=length(p),\n c=floor(a/g);a=mod(a,g)-g*.5;p=vec2(cos(a),sin(a))*r;if(abs(c)>=t*.5)c=abs(c);return c;}\n//return polar of carthesian input\nvec2 c2p(vec2 u){return vec2(length(u),atan(u.y,u.x));}\n//return carthesian of polar input\nvec2 p2c(vec2 u){return vec2(u.x*cos(u.y),u.x*sin(u.y));}\n//#define r2(r)mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n//rotate p by angle r:p=r(p,r);\n#define r(p,r)(cos(r)*p+sin(r)*vec2(-p.y,p.x))\n//rotate around offset point\n//vec2 rOffset(vec2 p,float r,vec2 o){p-=o;return(cos(r)*p+sin(r)*vec2(-p.y,p.x))+o;}\n//8bit color picker values to [0..1]\nvec3 bit82vec3(int r,int g,int b){return vec3(r,g,b)/255.;}\n//return brightness of eyes and mouth\nfloat eyes(vec2 w,float n){\n w=c2p(w);//we branch modify for one polar coordinate,therefore we must transform.\n if(n!=0.)w.y+=2.*n; w.y+=.5*sin(iTime+n); w=p2c(w); w.x*=1.2;\n n=pModPolar(w,3.);//eyesand mouth are a 3fold ,within 3fold flowers.\n w.x-=.14; w=c2p(w); w.y+=4.7; if(n==1.)w.y+=1.;if(n==0.)w.y-=1.; w=p2c(w);\n const float blur=.01;\n//return smoothstep(blur,-blur,max(length(w)-.1,0.));//debug Ooooooo-face\n return smoothstep(blur,-blur,max(length(w)-.08,-length(w-vec2(0,.04))+.1));}\nvec4 cuteCursor(vec2 u,vec2 m\n){float scale=12.+cos(iTime)*4.//reciprocal=inverse scalingFactor of the image\n ;u*=scale;u=fra(u)\n ;m*=scale;m=fra(m);u-=m//center at mouse position\n ;float w=length(u)\n ;float aas=4.*scale/min(iResolution.x,iResolution.y)\n ;w=smoothstep(aas,-aas,w-1.2)\n ;const float blur=.01;\n float n;\n u=r(u,3.);\n u.y+=.07;\n n=pModPolar(u,3.);//3 fold symmetry for 3 dflowers\n u+=vec2(-.55-n*.055,.1+n*.1);//offset within 3fold\n float d=smoothstep(blur,-blur,length(u)-.25);//yellow flower circle.\n u=r(u,.5*cos(iTime+n));//rotate whole flower\n float e=eyes(u,n);\n n=pModPolar(u,8.);//8fold symmetry for pebbles.\n float p=ils(u-vec2(.31,0));//flower pebbles=distance to ray==infiniteLineSegment\n p=smoothstep(blur,-blur,p-.11);//pink flower pebbles \n vec3 cBG=bit82vec3(195,111,160);//color background cheerilee cutiemark eye&&mouth&&body\n vec3 cYe=bit82vec3(247,244,177);//color yellow  cheerilee cutiemark circles\n vec3 cPi=bit82vec3(244,215,227);//color pink    cheerilee cutiemark pebbles\n vec3 r;\n r=mix(cBG,cPi,p);//mix background with pink pebbles\n r=mix(r,cYe,d);//add yellow circles to mix\n r=mix(r,cBG,e);//add eyes and mouth to mix \n return vec4(r*w,w);}\n\n\n\n//if only webaudio could be synchronized to anything, even webgl.\nfloat dirigent(vec2 U\n){U+=iResolution.xy/2.\n     //when hitting the reverse key, \n     //the white bar shoulc be at the left end of the screen.\n //i failed to sync thois to any resolution. why!!!\n ;vec2 u=fra(U)\n ;vec2 m=fra(U)    \n ;u.x-=.45//fiddly sync button,start offset, start must be left end side!\n ;//u.x-=iTime*tempo*.0379//fiddly tempo, should be easier to sync\n ;u.x=abs(u.x)\n ;float aas=16./min(iResolution.x,iResolution.y) //line width\n ;u.x=smoothstep(aas,-aas,u.x-aas/8.)\n ;return u.x\n ;}\n\n\n//if(a==black_piano_key)return 1.;return 0.;\n//convention: middleC== #[0.]\nfloat keyShade(float a\n){a=mod(a,12.)\n ;if(a>4.)return mod(a,2.) \n ;return 1.-mod(a,2.) \n ;//return 1.-(mod(a+step(5.,a),2.))\n ;}\n\n\nvoid mainImage(out vec4 O,in vec2 U\n){vec2 M=iMouse.xy\n //;U=U*2.-iResolution.xy*.5\n //;M=M*2.-iResolution.xy*.5\n \n //http://www.piano-keyboard-guide.com/middle-c.html\n //different instrument layouts: .x=numberOfKeys0 .y=C-offset0 .z=MiddleCIndex0\n ;vec3 mid49=vec3(49,0,24) //49 keys piano\n ;vec3 mid61=vec3(61,0,24) //88 keys piano\n ;vec3 mid76=vec3(76,4,36) //76 keys piano\n ;vec3 mid88=vec3(88,9,48)  //88 keys piano\n ;vec3 mid128=vec3(128,0,60)//128 keys piano //not 100% sure\n ;vec3 mid=mid88 //static selection\n  //or we smoothstep between the 4 static vectors by iMouse.y;\n  //for this to work, keyshade must properly offset as in keyShade(fl-mid.z)\n  //otherwise you can just keyShade(fl), but that only adds keys to th4 right==upper side\n ;mid=floor(mix(mid49,mid128,smoothstep(0.,1.,vec3(iMouse.y/iResolution.y)))) //frameM(iMouse.xy).\n //above this seems to be enough\n ;vec2 u=frameMidiSheet(U,mid.x)//sheetMusicFraming have .x==0 at left border, not centered\n ;u.x+=0.\n ;float d=sheet(u-vec2(-iTime*4.5,mid.z+6.+mid.y))//transpose sheet view into piano view.\n ;float fl=floor(u.y)\n ;//highlight white keys AND hightlight middleX even more.\n ;if (fl+mid.y==mid.z) u.y*=3.;else u.y=keyShade(fl-mid.z)*1.2//blue==black piano keys.\n ;u.x=fract(u.x)\n ;u*=.5;//to make red more visible.\n ;O=vec4(d,u,.1)\n ;O.xyz+=vec3(dirigent(U))\n ;//O.xyz*=O.w//if(O.w==1){no premultiply by *=1. needed, duuh!}else{pdOver needs O.xyz*=O.w;}\n ;O=pdOver(cuteCursor(U,M),O)\n ;//O=mainImage2(U,iMouse.xy);//debug()\n ;}\n/*\n//todo, add a remap() function to zoom and scroll with mouse.xyzw\n//something like:\n//\n//https://www.shadertoy.com/view/4l2BRD\n// remap v from range [min1,max1] to range [min2,max2]// this is unlerp+lerp combined\nfloat remap(float v,float min1,float max1,float min2,float max2\n){return min2+(max2-min2)*(v-min1)/(max1-min1);}\nfloat bias(float x,float b){return pow(x,log(b)/log(0.5));}\nfloat gain(float x,float g){return (x<0.5) ? bias(2.*x,1.-g)/2. : 1. - bias(2.-2.*x,1.-g)/2.;}\n// aaFloor is similar to floor() but has a 2-pixel wide gradient between clamped steps\n// to allow the edges in the result to be anti-aliased.\nfloat aaFloor(float x\n){float dx=2.*length(vec2(dFdx(x),dFdy(x)))\n ;float fx=fract(x),idx=1.-dx\n ;return (fx < idx) ? x - fx : remap(fx,idx,1.,x-fx,x);}\n// Same as aaFloor;clamp except for a 2-pixel wide gradient along the edge\nfloat aaFract(float x\n){float dx=2.*length(vec2(dFdx(x),dFdy(x)))\n ;float fx=fract(x),idx=1.-dx\n ;return (fx<idx) ? fx : remap(fx,idx,1.,fx,0.);}\n// escalator() is similar to aaFloor(),but takes a phase offset for animating\nfloat escalator(float x,float steps,float o\n){float dx=1./steps\n ;x=remap(x,0.,1.,-dx/2.,1.+dx/2.)+dx/2.\n ;float ex=(x - o*dx)*steps\n ;float ey=(aaFloor(ex)+o)*dx\n ;return clamp(ey,0.,1.);}\n/**/\n\n/*\ndynamic middle c visualization\nusing umouse.y to transition between 4 different pinao sizes\nthat all have their middle c roughly in the center.\n*/", "image_inputs": [], "sound_code": "/*\nmelody is \nhttps://www.youtube.com/watch?v=W5Z35jk1E4w\nis\n[The Magic Inside] by [Daniel Ingram and Lena Hall]\nis ponies:\nhttps://www.youtube.com/watch?v=buuYIBejsuM\n*/\n\n/*\nThis is just a start. It lacks over time overlapping (or bleeding) tiles .\nI think this is best solved in a 2pass, just like an echo, like occlusion, shadows.\n*/\n\n\n//this implements an attempt of cutting off a period only at its end.\n// It lacks offset calculations [offset-welding] for longer notes\n// ,therefore sounds bad for longer notes, you can hear the gaps.\n//it is a relatively simple bug, easy to bix, but i am bored of it.\n\n//#define modPackFilter\n//the thing i wanted to inclide via [modPackFilter] is\n//  https://www.shadertoy.com/view/XsXfD4\n//but without offset-welding it sounds bad on longer notes.\n\n//return wavelength of piano key, [a] is relative to C4\nfloat wkey(float a){return 440.*pow(2.,a/12.);}\n//return 12th root of [a]\n//float troot(float a){a=max(.001,abs(a));return pow(a,12./a);}\n\n//this lacks [offset-welding], all else is \"fine\", as in , max volume till the end.\n//return how many times period [a] fits into period [b].\nfloat howManyAfitInB(float a, float b){if(a==0.)return 0.;return floor(b/a);}\nfloat howManyFitIn(float a){if(a==0.)return 0.;return floor(1./a);}\n//if (x < largest_possible_stack_of_interval_p ) return 1; return 0; //[p]PeriodLength (wavelength)\nfloat packsin(float x,float p){return step(abs(x),p*howManyFitIn(p));}\n//is oblivious about negative input ranges. see\n// https://www.shadertoy.com/view/MsXfWN\n//or its parent \n// https://www.shadertoy.com/view/XsXfD4\n\n//MsXfWN actually seems to almost solve [offset-welding]\n\n//if(a==black_piano_key)return 1.;return 0.;\n//float keyShade(float a){a=mod(a,12.);return (mod(a+step(5.,a),2.));}\n//for the above, it is likely simple to instead...\n// define \"not white\" piano keys, than to define \"black\" piano keys.\n//the piano by iq uses the \"not white\" keys approach to remove some black keys.\n//this likely saves some divisions, but adds one max(a,-b), better overall?\n\n//very often you parse a sequence of 4 notes of the same length per note.\n//thsis checks a single freuency_band==key for a match with such a sequence\n//for a set slice of time.\n//a is 4 numbers, representing a seuence of 4 different enumerated piano keys==pitches.\n//u.xy is a sqare on the sheed as you see it in the shader.\n//it retuens if there is a note played on that square or not. later on, notes tint the sheet red.\n//a sequence of 4 notes, set by [a], is checked for a match with u.\n\n//return average speaker position, assuming that range [0..[k]] keys on a sheet play at once, within key[l] till key[l+r] (inclusively)\nfloat sheetAcc(float x){ \n //midi poano has keys range [1..128], with middle C4 = key #40 ?\n float a=0.;\n for(float i=-41.;i<89.;i++){//is a bit larger than full midi piano range\n  if((sheet(vec2(x,i))>0.)){\n   float w=wkey(i-12.*log2(tempo));//w==frequency in Hz; if(i==40)w=440. ish ?\n   #ifdef modPackFilter\n    float d=packsin(fract(x),1./w);//an incomplete filter, uses wavelength.\n    a+=d*cos(w*fract(x)*tau);//periodic waveform, better for single short notes.\n   #else\n    a+=cos(tau*x*w);//waveform, cut off by tiles is still quite ugly\n   #endif\n }}\n a/=4.;//average of [k] sinusoids. if (more sinusoids play at the same time) you fucked up\n //a=clamp(a,-1.,1.);//range clamping, the lazy solution.\n //a=atan(a)/(acos(-0.));//range atanIng: a=atan(a)*.5/pi//evenly distort frequencies over time in favor of keeping ampllitude sums within range [-1..1]\n //a=log(a)-log(1.);//naaah, not worth it!\n //a=fract(abs(a))*sign(a);//physically a horrible idea. it tortures the speaker!\n return a;\n}\n\nvec2 mainSound( in int samp,float t){\n return vec2(sheetAcc(t*tempo))*volume;\n //float w=wkey(0.);//w=440.;\n //return vec2(sin(tau*t*w));\n}\n\n//float fade(float t){return exp(-3.0*t);}", "sound_inputs": [], "common_code": "//the [children of Nancarrow] insist on an [irrational tempo]\n// in spite of planck scales and quantum physics (and other audio quality modifiers)\n// apparently insisting on quantizing all the music.\n//#define tempo sqrt(5.)*2.\n#define tempo 4.5\n#define volume .5\n#define tau (acos(-1.)*2.)\n\n//the sheet() function is used by [image] and [sound] to become audiovisual\n\n//this is old code that is still bad, for the sake of simplicity.\n//- main issue is that the end of a note is always hard, there is null transitioning\n//- which generates popping-noise at the end of each note.\n\n//brother: https://www.shadertoy.com/view/XsXfD4\n//sister; https://www.shadertoy.com/view/ldsBz8\n//- sister does not utilize shadertoy.com common tab \n//- and has 2 shader mostly duped but seperated.\n\n/*\nmelody is \nhttps://www.youtube.com/watch?v=W5Z35jk1E4w\nis\n[The Magic Inside] by [Daniel Ingram and Lena Hall]\nis ponies:\nhttps://www.youtube.com/watch?v=buuYIBejsuM\n*/\n\n/*\nyour waveform editor may have an y=f(x) function to synthesize a sample.\nYou would not think to define a full midi track with all instromends as single function.\nBut it is pretty easy, and with Rasterisation it is pretty efficient.\n\nMany concepts that aid encoding music are usually not associated with music, \n...unless you insist on quantizing a midi, this shader goes down this path:\nhttps://en.wikipedia.org/wiki/Quantization_(signal_processing)\nhttps://en.wikipedia.org/wiki/Rasterisation\nhttps://en.wikipedia.org/wiki/Tessellation\nhttps://en.wikipedia.org/wiki/Wallpaper_group\nhttps://en.wikipedia.org/wiki/Glide_reflection\n*/\n\n\n/*\nxAxis=time\nyAxis=pitch\ndefining a bitmap to be used as:\n- a bitmap factor (for the below 2)\n- - a 3d distance field modifier\n- - a Webaudio input \"Sound\" buffer\n\nThe tricky part is to define it procedurally, with subroutines\n...instead of defining an array of notes.\nProcedurally, I get a lot of repeating sequences that can be transformed in many ways.\nThat creates an associative sequence library.\n\nThis is my first attempt at this. first steps are the hardest, building a function library\n... learning what works best, pioneering through all the useless deserts.\n\ni did an abc parser    in second-life-script, so this should be simple.\ni did ChordName2Cord() in second-life-script, so this should be simple.\nbut the wide namespace of valid chord names made the parser 55k in size, \n...able to parse ALL jazz chords. this will likey get inside here, too, soon.\n*/\n\n\n\n//a sequence of 4 notes, set by [a], is checked for a match with u.\nfloat seq4(vec2 u,vec4 a){\n u.x=mod(u.x,4.);\n for (int i=0;i<5;i++){if(float(i)==u.x&&a[i]==u.y)return 1.;}return 0.;}\n//LeadTail() is one of 2 sequences\nfloat LeadTail(vec2 u,float c){\n if(c==0.)return seq4(u,vec4(9,11,9,7));\n if(c==1.)return seq4(u,vec4(8,7,5,3));\n return 0.;}\n//initael Lead has 2 main sections, in 2 variants each.\n//first  section repeats more, and is less \"sequential\"\n//second section is labeled LeadTail(), is one of 2 simple 4_key_sequences.\nfloat Lead(vec2 u){\n float c=floor(u.x/16.);\n c=mod(c,2.);\n u.x=mod(u.x,16.);\n if(u.x>4.*3.-1.)return LeadTail(u,c);\n float l=3.+c*2.;//the lower note of the period varies.\n u.x=mod(u.x,3.);//a 3*periodic (1*low 2*high) interval is \"LadHead()\":\n if(u.x>0.&&u.y==8.)return .7+.3*step(u.x,1.);//the higher note has 2*length, second part has less color.\n else if(u.x<1.&&u.y==l)return 1.;//else lower note of the period\n return 0.;}\n \n//sequence for baselines, tend to be held down for longer;\n//....x got divided by something to make notes longer. \nfloat seq4b(vec2 u,vec4 a){\n u.x=mod(u.x,4.);\n for (int i=0;i<5;i++){\n  float j=float(i);\n  if(a[i]==u.y){\n   if(j<u.x&&j>u.x-1.)return .7;\n   if(float(i)==u.x)return 1.;}\n }return 0.;}\n//single long note with pitch [a.x], from [a.y] to [a.z] \nfloat lon(vec2 u,vec3 a){\n if(u.y==a.x){\n  if(u.x==a.y)return 1.;\n  return step(a.y,u.x)*step(u.x,a.z)*.7;\n }return 0.;} \n//pmodN() folds y to create one overtone.\nfloat pmodN(float y){float c=floor(y/12.);\n if(y>0.||y<-24.)return -99.;//if (out of bounds) become -99, outside of other iteration loops, would be inaudible.\n return mod(y,12.);}//else if(within bouns), modulo fold.\n//initial baseline has an oddly long note, pitch 1, from 15 to 25, played 2x.\nfloat BaseMainOdd(vec2 u){u.x=mod(u.x,32.);return lon(u,vec3(1,16,27));}\n//initial baseline  has one \"overwrite\" sequence.\nfloat BaseMainO1(vec2 u){return seq4b(u,vec4(1,8,14,8)-24.);}\n//initial baseline sequence with one overwrite.\nfloat BaseMain(vec2 u){\n if(u.x>15.&&u.x<16.+8.){\n  if(u.x>21.)return lon(u,vec3(-16,22.,24.));\n  if(u.x>19.)return lon(u,vec3(-23,20.,22.));\n  return BaseMainO1(u);}//end of the overwrite.\n //start of the initial main baseline.\n u.y=pmodN(u.y);//pmodN() creates one overtone.\n u.x/=8.;//8* longer note durations\n u.x=mod(u.x,4.);return seq4b(u,vec4(8,6,1,3));}//main base sequence.\n//initial baseline has one specific (longer) lote near the end\nfloat long2(vec2 u){return lon(u,vec3(-16,52,55));}\n\nfloat BaseMix(vec2 u){return max(long2(u),max(BaseMainOdd(u),BaseMain(u)));}\n\n\n//melody to \"i am just a pony\"\n//return 1 if a note exist at uv\n//return 0 if no note exists at uv\n//canvas is basic, does not do any envelope.\n//u.x=time\n//u.y=midi note of 128 piano keys (equalTemperament), middle C is like [60.] or something.\nfloat IAmJustAPony(vec2 u){\n ;if (u.x<0.)return 0.//no negative time\n ;u.x=mod(u.x,64.);\n //if(u.x<0.) return 0.;//left end is 0;\n //if(u.x<64.)//stop or keep looping?\n return max(BaseMix(u),Lead(u));}\n\n//return 1 on some tiles, 0 on others.\n//this is a wrapper function, indented to switch and mix sheets.\nfloat sheet(vec2 u){u=floor(u); //u is tileID positions.\n //u.x=mod(u.x,64.);\n return IAmJustAPony(u);}//if(IAmJustAPony(u))return 1.;return 0.;}\n", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stK3Rh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[842, 857, 875, 875, 946], [947, 947, 965, 965, 1036], [1037, 1037, 1055, 1055, 1125], [1126, 1143, 1179, 1179, 1197], [1341, 1459, 1482, 1482, 1499], [1499, 1670, 1696, 1696, 1714], [1715, 1715, 1742, 1742, 1762], [1763, 1763, 1790, 1790, 1814], [1815, 1815, 1841, 1841, 1869], [1870, 2287, 2305, 2305, 2350], [2351, 2413, 2451, 2451, 2588], [2589, 2624, 2641, 2641, 2679], [2680, 2715, 2732, 2732, 2772], [2904, 3056, 3090, 3090, 3115], [3116, 3154, 3181, 3181, 3648], [3649, 3649, 3681, 3681, 4832], [4836, 4902, 4926, 4926, 5407], [5410, 5485, 5510, 5510, 5614], [5617, 5617, 5655, 5655, 7123]], "test": "untested"}
{"id": "NtVGR1", "name": "ReactionDiffusion - MIPmap Lapl2", "author": "FabriceNeyret2", "description": "Use plugin to accelerate x16.\nUncomment for original shading + mouse paint.\n\nsimplify+golf  [url]https://shadertoy.com/view/7s2Szw[/url] which simplified+golf aiekick [url]https://shadertoy.com/view/MlByzR[/url]", "tags": ["diffusion", "2tweets", "golf", "reaction", "gpmipmap"], "likes": 11, "viewed": 350, "published": 3, "date": "1637164679", "time_retrieved": "2024-07-30T18:47:38.528727", "image_code": "// golfing 648 chars https://shadertoy.com/view/7s2Szw\n// simplified version of 2882 chars aiekick's https://shadertoy.com/view/MlByzR\n\nM.rrrr;                            // display buffA.r\n\n/*                                 // drop comments for original shading\n    float c = T().g, c2;\n    U--; c2 = T().g;               // c2 = offseted state for lighting\n \n    O =   c*c*1.5\n        + vec4(.2, .4, 1, 0) * max(c2*c2*c2 - c*c*c, 0.)*R.y*.2;  // Shane lighting model\n    O = sqrt(O);\n*/    \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "M;                                               // previous state\n    float l;\n   \tO.rg = iFrame < 1\n      ? vec2( l = length(U+U-R)/R.y, 1.-l )      // init\n/*    : iMouse.z > 0.                            // drop comments for mouse paint\n      ? l = length( U - iMouse.xy ) / R.y,\n        l < .05 ? vec2( l, 1.-l ) : O.rg \n*/   :                                           // simulates reaction - diffusion\n        O.rg + vec2(1,.3)  *  9./8.* ( T(1.) - T() ).rg // approx Laplacian using MIPmap LOD difference\n             + vec2(.05 * (1. - O.x) - (l = O.x*O.y*O.y), l - .112 * O.y );\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R       iResolution.xy//\n#define T(l)    texture( iChannel0, U/R, l+0. )   //\n#define M       void mainImage( out vec4 O, vec2 U ) { O = T()", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtVGR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "flK3R1", "name": "入门之路-18", "author": "jialouluo", "description": "最开始学到噪声的时候，对于simplex噪声的了解只停留在了他的原理层面上，但苦于计算方式没有注释去解释说明以至于难于理解，今天好在看到了一片对于噪声的文章，令我渐渐理解了这种方法，当然作为一个初学者，也可能描述得不是那么得十分正确，仅供自学。如果像详细了解可以看看我最下面的那个链接", "tags": [], "likes": 2, "viewed": 235, "published": 3, "date": "1637164283", "time_retrieved": "2024-07-30T18:47:39.282711", "image_code": "vec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n    //这篇主要是对simplex噪声的一些学习理解笔记\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat simplex_noise(vec2 st){\n    //simplex噪声基于perlin噪声上优化 将原来2^n的复杂度改进到n^2 这样在处理高维空间的时候 性能大大得到提升\n    //原理就是就是采用寻找一个空间晶格的单形的方式来去求权重 ,二维空间下的单形是一个特殊三角形，你可以想想一下将一个平行四边形平分为两个三角形的样子，\n    //至于更多关于单形的解释 推荐看看我放在最下面的链接\n    //话不多说，我们传入进来的st的坐标是未偏斜的，所以我们的第一步就是偏斜我们原有的坐标系\n    //          -----------                   --------\n    //          |          |                  \\      /\\\n    //          |          |                   \\    /  \\\n    //          |          |      ====>         \\  /    \\\n    //          |          |                     \\/      \\\n    //          -----------                       --------\n    //利用公式x′=x+(x+y+...)⋅K1;y′=x+(x+y+...)⋅K1; K1 = (sqrt(n+1)-1)/n  (n为维度);\n    float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    vec2 nst = st + (st.x +st.y)*K1;\n    //对新坐标 老两样 fract floor\n    vec2 fr = fract(nst);//取小数部分，小数部分可以帮助我们进一步判断输入点所在的单形以及计算权重\n    vec2 fl = floor(nst);//取整\n    float K2 = (sqrt(3.)/6. - 0.5);\n    //然后下面的思路是判断我们的输入点(st)处于上三角还是下三角，变形前后对结果没有影响，所以我们选择变形之前的坐标来进行计算判断\n    //单形顶点变回到之前由单形组成的单形网格。这一步需要使用第一步公式的逆函数来求得：x=x-(x′+y′+...)⋅K2\n    //K2=(1/sqrt(n+1) -1)/n; 变换一下就是 (sqrt(3)-3)/6; ==> sqrt(3)/6 -1/2;\n    vec2 a = st - (fl +(fl.x +fl.y) *K2 );//a 也是输入点到单形第一个顶点的距离向量\n    vec2 local = a.x>a.y?vec2(1.0,0.0):vec2(0.0,1.0);//单性存在的区域 (1.0，0.0)表示右下的三角形，(0.0，1.0)表示左上的三角形\n    //接下来我们的思路是 还要计算两个点到输入点的距离向量\n    //对于二维空间来说，如果xf,yf满足xf>yf，\n    //那么对应的3个单形坐标为：首先找到(0, 0)，由于x分量比较大，因此下一个坐标是(1, 0)，接下来是y分量，坐标为(1, 1)\n    //为了方便 就叫他小b和小c吧。\n    //怎么来得出b，c呢 我们是用a去减算出来的local坐标，这个local由于是偏斜坐标系下的，还需要利用k2系数将其转换到直角坐标系\n    vec2 b = a - (local +(local.x+local.y) * K2);\n    vec2 c = a - (vec2(1.0) + (1.0 +1.0) * K2);//这样写便于理解\n    //这样我们的3个点就都求出来了。上面这些运算才是这个这个算法的核心，建议多看几遍 我就是在写这篇分享的时候转变了几次我的理解方式\n    //非常建议上面这段多看几遍，看我这个看不懂的，看下面那个链接的，多看几遍。\n    //------------------------------------------------------------------\n    //下面便简单一些\n    //利用这个公式(r^2−|dist|^2)^4×dot(dist,grad)来计算每个顶点对结果的贡献度(dist代表距离值)(r^2一般取0.5 或0.6)\n    //r^2取0.5的原因:由于经过坐标偏斜后得到的网格宽度为1，因此我们可以倒推出在变形前单形网格中每个单形边的边长为sqrt(2/3)，\n    //这样一来单形每个顶点到对面边的距离（即高）的长度为√2/2，它的平方即为0.5。很奇妙的是，不仅是二维，在其他维度下，每个单形顶点到对面边/面的距离都是0.5。\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    vec3 n = h * h * h * h * vec3(dot(a, hash22(fl)), dot(b, hash22(fl + local)), dot(c, hash22(fl + 1.0)));\n    return dot(vec3(70.0, 70.0, 70.0), n);\n    /**\n    *@链接里面的K2公式没问题，代码那里减是对K2取反，\n    *因为我变形之后K2是(sqrt(3) -3)/6 ，博主K2的值((3-sqrt(3))/6)刚好是取反的值\n    * */\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = vec3(simplex_noise(uv + iTime));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0)*texture(iChannel0,uv);\n}\n//参考链接 https://blog.csdn.net/candycat1992/article/details/50346469，非常感谢大佬对于噪声的解释。", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flK3R1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 208], [209, 209, 238, 1261, 4272], [4274, 4274, 4331, 4381, 4585]], "test": "untested"}
{"id": "slV3Rz", "name": "Squishy ball pattern (186 chars)", "author": "hnh", "description": "I took a lesson on triangular grids at Shane's \"Triangle Grid Contouring\" [url]https://shadertoy.com/view/WtfGDX[\\url] and had some fun with it...", "tags": ["2d", "grid", "pattern", "molecule", "triangular", "golf"], "likes": 3, "viewed": 286, "published": 3, "date": "1637161405", "time_retrieved": "2024-07-30T18:47:40.098530", "image_code": "\n// I took a lesson on triangular grids at Shane's \"Triangle Grid Contouring\" \n// (https://shadertoy.com/view/WtfGDX) and had some fun with it...\n\n\n//*\n// -20 chars by XOR\nvoid mainImage( out vec4 O, vec2 p)\n{\n    p = p/iResolution.y*2. + iTime/vec2(2,3);\n    \n    vec2 s = floor(p + (p.x + p.y)*.366);\n    s = .45 - step(p -= s - (s.x + s.y)*.2113, p.yx)/3.;\n    \n    O = sqrt(exp(3. - length(p-s)*13.) - .3)*s.xxyx;\n}\n\n\n/*/\n// Original version (206 chars)\nvoid mainImage( out vec4 O, in vec2 p) {\n    p = p/iResolution.y*2. + vec2(.5,.3)*iTime;\n    \n    vec2 c, s = floor(p + (p.x + p.y)*.366);\n    p -= s - (s.x + s.y)*.2113;\n    c = (vec2(p.x>p.y, p.x<p.y) + .37)/3.;\n    \n    O = sqrt(exp(3. - length(p-c)*13.) - .3)*c.xxyx;\n}\n//*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slV3Rz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 172, 209, 209, 419]], "test": "untested"}
{"id": "stG3z1", "name": "Moving ReactDiff - 162c - fixed", "author": "benoitM", "description": "Fast and dirty Reaction  Diffusion\nInspired by https://www.youtube.com/watch?v=ga1xt5zkmPI \nTrying to use only mipmaps for the convolutions (blur and high pass filter)\nPlenty of artefacts due to mipmaps but it works.\nTried also to make a short code \n", "tags": ["2d", "diffusion", "organic", "highpass", "golf", "reaction", "mipmaps", "gpmipmap"], "likes": 6, "viewed": 290, "published": 3, "date": "1637151541", "time_retrieved": "2024-07-30T18:47:40.887421", "image_code": "// Fork of \"Reaction Diffusion - 164 chars\" by benoitM. https://shadertoy.com/view/flGGzR\n// 2021-11-17 12:13:35\n\n/////////////////////////////////////////////////////////////////////////\n//                                                                     //\n//     Fast & Simple & Dirty Reaction Diffusion Pattern                //\n//                                                                     //\n//             Copyright Benoit Marini - 11/2021                       //     \n//             License Creative Commons Attribution                    //\n//         NonCommercial-ShareAlike 3.0 Unported License.              //\n//                                                                     //\n/////////////////////////////////////////////////////////////////////////\n//                                                                     //\n// Inspired by https://www.youtube.com/watch?v=ga1xt5zkmPI             //\n// Trying to use only mipmaps for \"Kernel operations\", knowing that    //\n// mipmaps are far from gaussian blur...                               //\n// High pass filter from iq  (shadertoy.com/view/XsX3zj)               //\n// Noise in Buffer B is only here for initial pertubation              //\n//                                                                     //\n//                                                                     //  \n//  ////////  Buffer A  ////////            //////  Buffer B  //////   //\n//  //                        //       \\\\   //                    //   //\n//  // 1) High pass filter B  //   \\\\\\\\\\\\\\  // 1) Blur  A         //   //\n//  // 2) threshold B         //   ///////  // 2) Add small noise //   //\n//  //                        //       //   //                    //   //\n//  ////////////////////////////            ////////////////////////   //\n//                                                                     //\n//                /\\                                   ////            //\n//               //\\\\                                  ////            //\n//              ///\\\\\\                                 ////            //\n//               ////                                  ////            //\n//               //////////////////////////////////////////            //\n//               //////////////////////////////////////////            //\n//                                                     ////            //\n//                                                    \\\\\\///           //\n//                                                     \\\\//            //\n//                                                      \\/             //\n//                                                                     //\n//                                            //////   Image  //////   //\n//                                            //                  //   //\n//                                            // 1) Blur B        //   //\n//                                            // 2) threshold B   //   //\n//                                            //                  //   //\n//                                            //////////////////////   //\n//                                                                     //        \n/////////////////////////////////////////////////////////////////////////  \n\n\n\n////////////////////////////////////////////// \n// high pass filter & threshold of Buffer B //\n////////////////////////////////////////////// \n\nM\n     8.*T(0.)-4.; // -3 chars Thanks Fabrice !\n}\n\n\n\n\n\n\n\n\n\n\n// original code (169 chars)\n// M\n//     step(.5,T(0.));\n// }\n//\n// code after #define from Common applied :\n//\n// void mainImage( out vec4 o, in vec2 i )\n// {\n//     o = step (.5,textureLod(iChannel0,i/iResolution.xy,0.));\n// }\n\n\n\n             \n       ", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//////////////////////////////////////////////\n// high pass filter & threshold of Buffer B //\n//////////////////////////////////////////////\n\nM    \n    //step (.0, T(0.)-T(4.5)) ; // -1 char Thanks Fabrice !\n    step(T(4.5), T(0.)); // Thanks Xor\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// original code (169 chars)\n// M\n//     step (.01, T(0.)-T(4.5)); // WARNING Remplacing 0. by .01  is not thresholded well the fake high-pass filter\n// }\n//\n// code after #define from Common applied :\n//\n// void mainImage( out vec4 o, in vec2 i )\n// {\n//     o = step (.02, textureLod(iChannel0,i/iResolution.xy,0.) - textureLod(iChannel0,i/iResolution.xy,3.5+cos(iTime)) ) ;\n// }", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "///////////////////////////////////////////////\n// blur buffer A + add small perturbation    //\n///////////////////////////////////////////////\n\nM\n     T(3.5) + exp(-i.x*i.y); // exp(-i.x*i.y) => pixel 0,0 is white, others black\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// code after #define from Common applied :\n//\n// void mainImage( out vec4 o, in vec2 i )\n// {\n//     o = textureLod( iChannel0, i/iResolution.xy, 3.) + cos(i.x*i.y)/1e2;\n// }", "buffer_b_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define M void mainImage( out vec4 o, vec2 i ) { o=\n#define T(l) texture(iChannel0,i/iResolution.xy*.993,l)\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stG3z1.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [], "test": "untested"}
{"id": "sty3R1", "name": "Mipmap Reaction Diffusion V4", "author": "benoitM", "description": "MOUSE CLIC to see effect.\nFast Reaction Diffusion using mipmaps\nHaving fun ;)", "tags": ["mipmap", "diffusion", "highpass", "reaction", "gpmipmap", "golfed"], "likes": 5, "viewed": 298, "published": 3, "date": "1637150101", "time_retrieved": "2024-07-30T18:47:41.715207", "image_code": "/////////////////////////////////////////////////////////////////////////\n//                                                                     //\n//     Fast & Simple Reaction Diffusion Pattern Variation 4            //\n//                                                                     //\n//             by Benoit Marini - 16/11/2021                           //\n//                                                                     //\n/////////////////////////////////////////////////////////////////////////\n//                                                                     //\n// from \"Fast & Simple & Dirty Reaction Diffusion Pattern\"             //\n// Only using mipmaps for convolutions                                 //\n// Basic idea here :                                                   //\n// https://www.shadertoy.com/view/flGGzR                               //\n//                                                                     //\n// This shader is a variation of                                       //\n// https://www.shadertoy.com/view/slyGR1                               //\n//                                                                     //     \n/////////////////////////////////////////////////////////////////////////  \n\nM\n    T(0.);                    // FORM (stored on alpha channel)\n    o.rgb = sin((o.r+o.a)*vec3(1,2,3)); // COLOR from green channel (multiplied by Form)\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 o, vec2 i ) {   \n\n   o=step (.01,T(0.)-T(S)) ;    // FORM \n   o.r = (o.a>.5)? T(0.).r : -.5; //COLOR\n   if( T(4.5).r <.1 ) o.r+=.02;   //COLOR\n \n}\n\n", "buffer_a_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 o, vec2 i ) {\n\n     o=T(S-1.) + exp(-i.x*i.y);    // FORM on .a chanel  // o = T(f,2.5) + .....\n     o.r = T(1.).r ;            // COLOR on .r chanel   \n    // if ( T(f,99.).a > .4 ) o-=o; // RESET if form cover more than 40% of the screen, work with 2^99 screens resolutions ;)\n}\n\n//////////////////////////////////////////////////////\n// FORM : blur buffer A + add small perturbation    //\n//////////////////////////////////////////////////////\n// COLOR : blur buffer A                            //\n//////////////////////////////////////////////////////\n\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define M void mainImage( out vec4 o, vec2 i ) { o=\n#define R iResolution.xy\n#define S 4.+.5*sin(iTime)\n#define T(l) texture(iChannel0, (i/R) * (1.+.01*(iMouse.xy/R-.5)) ,l)\n\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sty3R1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "stVGzz", "name": "Mipmap Reaction Diffusion V3", "author": "benoitM", "description": "MOUSE CLIC to see effect.\nStarting from my fast and dirty Reaction Diffusion www.shadertoy.com/view/flGGzR.\nHaving fun while exploring offset within texture to create cooler pattern + colors + autoreset + interactivity\nTried also to keep a short code\n", "tags": ["mipmap", "diffusion", "highpass", "reaction", "golfed"], "likes": 4, "viewed": 293, "published": 3, "date": "1637143947", "time_retrieved": "2024-07-30T18:47:42.468194", "image_code": "/////////////////////////////////////////////////////////////////////////\n//                                                                     //\n//     Fast & Simple Reaction Diffusion Pattern Variation 3            //\n//                                                                     //\n//             by Benoit Marini - 16/11/2021                           //\n//                                                                     //\n/////////////////////////////////////////////////////////////////////////\n//                                                                     //\n// from \"Fast & Simple & Dirty Reaction Diffusion Pattern\"             //\n// Only using mipmaps for convolutions                                 //\n// Basic idea here :                                                   //\n// https://www.shadertoy.com/view/flGGzR                               //\n//                                                                     //\n// This shader is a variation of                                       //\n// https://www.shadertoy.com/view/slyGR1                               //\n//                                                                     //     \n/////////////////////////////////////////////////////////////////////////\n\nM\n    T(-f*float(2*iFrame),0.);                    // FORM (stored on alpha channel)\n    o.rgb =0.5-step(.3,o.a) * cos(o.r*vec3(2,3,4)); // COLOR from green channel (multiplied by Form)\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "M\n   \n   step (.01,T(f,0.)-T(f,3.5)) ;    // FORM o = step (.01,T(f ..... \n   o.r = (o.a>.5)? T(f,0.).r : -.5; //COLOR\n   if( T(f,4.5).r <.1 ) o.r+=.09;   //COLOR\n \n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////\n// FORM (alpha channel) : high pass filter & threshold of Buffer B \n//                                                                 \n//////////////////////////////////////////////////////////////////////////////////\n// COLOR (red channel storing color index) :\n//\n//  if(o.a>.5) // WHITE pixel (form)\n//  {\n//      if(T(f,3.5).r <0.2)         // Get blurry image of color index to split between border and inner             \n//      {\n//          o.r = T(f,1.).r + 0.06; // Border case : add offset color index                               \n//      }\n//      else\n//      {\n//          o.r = T(f,3.).r;        // Inner case : keep color it but average it                                     \n//      }\n//  }\n//  else // BLACK Pixel (no form)\n//  {\n//      o.r = -.5;                  // set color index = -0.5; will influence blurry image of color index                           \n//  }\n//  \n///////////////////////////////////////////////////////////////////////////////////\n\n\n", "buffer_a_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "M\n     T(f,3.5) + exp(-i.x*i.y);    // FORM on .a chanel  // o = T(f,2.5) + .....\n     o.r = T(f,1.).r ;            // COLOR on .r chanel   \n     if ( T(f,99.).a > .4 ) o-=o; // RESET if form cover more than 40% of the screen, work with 2^99 screens resolutions ;)\n}\n\n//////////////////////////////////////////////////////\n// FORM : blur buffer A + add small perturbation    //\n//////////////////////////////////////////////////////\n// COLOR : blur buffer A                            //\n//////////////////////////////////////////////////////\n// RESET : use mipmap to know average coverage      //\n//////////////////////////////////////////////////////\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define M void mainImage( out vec4 o, vec2 i ) { o=\n#define f iMouse.xy/5e2\n#define T(d,l) texture(iChannel0, (i + d)/iResolution.xy ,l)\n\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stVGzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "flGGzR", "name": "Reaction Diffusion - 164 chars", "author": "benoitM", "description": "Fast and dirty Reaction  Diffusion\nInspired by https://www.youtube.com/watch?v=ga1xt5zkmPI \nTrying to use only mipmaps for the convolutions (blur and high pass filter)\nPlenty of artefacts due to mipmaps but it works.\nTried also to make a short code \n", "tags": ["2d", "diffusion", "organic", "highpass", "reaction", "mipmaps"], "likes": 6, "viewed": 287, "published": 3, "date": "1637143906", "time_retrieved": "2024-07-30T18:47:43.220183", "image_code": "/////////////////////////////////////////////////////////////////////////\n//                                                                     //\n//     Fast & Simple & Dirty Reaction Diffusion Pattern                //\n//                                                                     //\n//             Copyright Benoit Marini - 11/2021                       //     \n//             License Creative Commons Attribution                    //\n//         NonCommercial-ShareAlike 3.0 Unported License.              //\n//                                                                     //\n/////////////////////////////////////////////////////////////////////////\n//                                                                     //\n// Inspired by https://www.youtube.com/watch?v=ga1xt5zkmPI             //\n// Trying to use only mipmaps for \"Kernel operations\", knowing that    //\n// mipmaps are far from gaussian blur...                               //\n// High pass filter from iq  (shadertoy.com/view/XsX3zj)               //\n// Noise in Buffer B is only here for initial pertubation              //\n//                                                                     //\n//                                                                     //  \n//  ////////  Buffer A  ////////            //////  Buffer B  //////   //\n//  //                        //       \\\\   //                    //   //\n//  // 1) High pass filter B  //   \\\\\\\\\\\\\\  // 1) Blur  A         //   //\n//  // 2) threshold B         //   ///////  // 2) Add small noise //   //\n//  //                        //       //   //                    //   //\n//  ////////////////////////////            ////////////////////////   //\n//                                                                     //\n//                /\\                                   ////            //\n//               //\\\\                                  ////            //\n//              ///\\\\\\                                 ////            //\n//               ////                                  ////            //\n//               //////////////////////////////////////////            //\n//               //////////////////////////////////////////            //\n//                                                     ////            //\n//                                                    \\\\\\///           //\n//                                                     \\\\//            //\n//                                                      \\/             //\n//                                                                     //\n//                                            //////   Image  //////   //\n//                                            //                  //   //\n//                                            // 1) Blur B        //   //\n//                                            // 2) threshold B   //   //\n//                                            //                  //   //\n//                                            //////////////////////   //\n//                                                                     //        \n/////////////////////////////////////////////////////////////////////////  \n\n\n\n////////////////////////////////////////////// \n// high pass filter & threshold of Buffer B //\n////////////////////////////////////////////// \n\nM\n     8.*T(0.)-4.; // -3 chars Thanks Fabrice !\n}\n\n// original code (169 chars)\n// M\n//     step(.5,T(0.));\n// }\n//\n// code after #define from Common applied :\n//\n// void mainImage( out vec4 o, in vec2 i )\n// {\n//     o = step (.5,textureLod(iChannel0,i/iResolution.xy,0.));\n// }\n\n\n\n             \n       ", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//////////////////////////////////////////////\n// high pass filter & threshold of Buffer B //\n//////////////////////////////////////////////\n\nM    \n    step (.0, T(0.)-T(4.5)) ; // -1 char Thanks Fabrice !\n}\n\n// original code (169 chars)\n// M\n//     step (.01, T(0.)-T(4.5)); // WARNING Remplacing 0. by .01  is not thresholded well the fake high-pass filter\n// }\n//\n// code after #define from Common applied :\n//\n// void mainImage( out vec4 o, in vec2 i )\n// {\n//     o = step (.02, textureLod(iChannel0,i/iResolution.xy,0.) - textureLod(iChannel0,i/iResolution.xy,3.5+cos(iTime)) ) ;\n// }", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "///////////////////////////////////////////////\n// blur buffer A + add small perturbation    //\n///////////////////////////////////////////////\n\nM\n     T(3.5) + cos(i.x*i.y)/1e2;\n}\n\n\n// code after #define from Common applied :\n//\n// void mainImage( out vec4 o, in vec2 i )\n// {\n//     o = textureLod( iChannel0, i/iResolution.xy, 3.) + cos(i.x*i.y)/1e2;\n// }", "buffer_b_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define M void mainImage( out vec4 o, vec2 i ) { o=\n#define T(l) texture(iChannel0,i/iResolution.xy,l)\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flGGzR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [], "test": "untested"}
{"id": "slyGRh", "name": "Fork Gradient F ronik 927", "author": "ronik", "description": "toying around", "tags": ["distortion", "flow"], "likes": 12, "viewed": 427, "published": 3, "date": "1637129146", "time_retrieved": "2024-07-30T18:47:43.971175", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\n\nmat2 Rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\n// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nvec2 hash( vec2 p )\n{\n    p = vec2( dot(p,vec2(2127.1,81.17)), dot(p,vec2(1269.5,283.37)) );\n\treturn fract(sin(p)*43758.5453);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    float n = mix( mix( dot( -1.0+2.0*hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                        dot( -1.0+2.0*hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                   mix( dot( -1.0+2.0*hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                        dot( -1.0+2.0*hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n\treturn 0.5 + 0.5*n;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n\n    vec2 tuv = uv;\n    tuv -= .5;\n\n    // rotate with Noise\n    float degree = noise(vec2(iTime*.1, tuv.x*tuv.y));\n\n    tuv.y *= 1./ratio;\n    tuv *= Rot(radians((degree-.5)*720.+75.));\n\ttuv.y *= ratio;\n\n    \n    // Wave warp with sin\n    float frequency = 2.;\n    float amplitude = 30.;\n    float speed = iTime * 4.;\n    tuv.x += sin(tuv.y*frequency+speed)/amplitude;\n   \ttuv.y += sin(tuv.x*frequency*1.5+speed)/(amplitude*.5);\n    \n    \n    // draw the image\n    vec3 colorWhite = vec3(1.0, 1.0, 1.0);\n    vec3 colorRed = vec3(.914, .345, .62);\n    vec3 colorPurple = vec3(.792, .573, .871);\n    vec3 colorGreen = vec3(.612, .91, .364);\n    vec3 colorBlue = vec3(.42, .773, .937);\n    vec3 colorYellow = vec3(1.0, .973, .325);\n    \n    vec3 layer1 = mix(colorRed, colorYellow, S(-.6, .2, (tuv*Rot(radians(-5.))).x));\n    layer1 = mix(layer1, colorWhite, S(-.6, .2, (tuv*Rot(radians(-5.))).x));\n    layer1 = mix(layer1, colorPurple, S(-.2, .6, (tuv*Rot(radians(-5.))).x));\n    \n    vec3 layer2 = mix(colorRed, colorYellow, S(-.8, .2, (tuv*Rot(radians(-5.))).x));\n    layer2 = mix(layer2, colorGreen, S(-.1, .9, (tuv*Rot(radians(-5.))).x));\n    layer2 = mix(layer2, colorBlue, S(-.5, .5, (tuv*Rot(radians(-5.))).x));\n    \n    vec3 finalComp = mix(layer1, layer2, S(.7, -.5, tuv.y));\n    \n    vec3 col = finalComp;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slyGRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 55, 55, 131], [134, 258, 279, 279, 386], [388, 388, 414, 414, 881], [884, 884, 941, 941, 2383]], "test": "untested"}
{"id": "slGGRh", "name": "入门之路-17", "author": "jialouluo", "description": "模拟火焰", "tags": [], "likes": 18, "viewed": 372, "published": 3, "date": "1637126247", "time_retrieved": "2024-07-30T18:47:44.791981", "image_code": "\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = 2. * fragCoord / iResolution.xy;\n    uv -= 1.0;\n    uv *= 3.;\n\n    for(float i = 1.0; i < 8.0; i++) {\n        uv.y += 0.1 * sin(4.20 * iTime / (1. + i)) / (1. + i);               // 纵向上的抖动函数\n        uv.x += 0.1 * cos(uv.y / 4.20 + 2.40 * iTime / (1. + i)) / (1. + i);// 横向上的抖动函数\n    }\n    uv.y += 0.04 * fract(sin(iTime * 60.));//正弦扰动\n    vec3 color = vec3(0.0);\n    float y = - pow(abs(uv.x), 4.2) / 0.0004;// 外焰的形状\n    float dir = abs(uv.y-y) * sin(.3);//计算外焰的大小（扩大渐变区域）的公式 \n    if(dir < 0.7) {\n        color.rg += smoothstep(0.0, 1.00, .75 - dir);\n        color.g /= 1.8;\n    }\n    color *= (0.6 + abs(uv.y / 4.2 + 4.2) / 4.2);// 增加对比度\n    color += pow(color.r, 1.1);//增白\n    color *= cos(-0.5 + uv.y * 0.4);//隐藏底部的颜色\n    //火苗内焰\n    uv.y += 1.5;\n    vec3 dolor = vec3(0.0);\n    float y1 = -pow(abs(uv.x), 4.2) / (4.2 * 0.0004) * 4.2;\n    float dir1 = abs(uv.y - y1) * sin(0.8);\n    if(dir1 < 0.7) {\n        dolor.bg += smoothstep(0.0, 1.00, .75 - dir1);\n        dolor.g /= 2.4;\n    }\n    dolor *= (0.6 + abs(uv.y / 4.2 + 4.2) / 4.2);\n    dolor += pow(dolor.r, 1.01);\n    dolor *= cos(-0.5 + uv.y * 0.4);\n    color = (color + dolor) / 2.;\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slGGRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 56, 56, 1369]], "test": "untested"}
{"id": "Nly3z1", "name": "Persian mosaic 4", "author": "jarble", "description": "A fractal pattern that looks like a mosaic.", "tags": ["fractal", "mosaic", "ceramic"], "likes": 2, "viewed": 199, "published": 3, "date": "1637124719", "time_retrieved": "2024-07-30T18:47:45.612786", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);    \n    vec3 col;  \n    float t1 = 6.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime/2.+uv.x)/10.0);\n    vec3 random1 = (hash31(3.+t2)-.5)/8.;\n    vec3 random2 = (hash31(4.+t2)-.5)/8.;\n    //vec3 random3 = (hash31(3.+t2)-vec3(.5))/4.;\n    //vec3 random4 = (hash31(4.+t2)-vec3(.5))/4.;\n    \n    float offset = .5;\n    float scale2 = 1.5;\n    float bend = 1.+1./3.;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        //float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            //float bend = 1.;\n            \n\n            for(int k = 0; k < 6; k++){       \n                uv /= -scale2;\n                //uv += vec2(random1[k],random2[k]).yx;\n                //float bend = 1.;\n                \n                uv.yx = triangle_wave(uv.yx+offset/1.5,scale)*bend+triangle_wave(uv-offset,scale)/bend;\n                //bend *= 1. - (((uv.x-uv.y)))/81.;\n                //uv -= offset/1.5;\n\n                //uv += vec2(random1[k]/bend,random2[k]*bend);\n                //bend *= -1.;\n                //bend -= 1./3.-col.x;\n                //bend = 1. +uv.x/2.;\n            }\n            //uv -= uv.yx;\n            \n\n            //offset += .5;\n            scale /= 1.+(scale2)*col.x/(8.);\n            scale2 -= (col.x-1.)/4.;\n\n\n            col[c] = (abs((uv.x)-(uv.y)+col[c]));\n            //col = col.yzx;\n            //random2 = col - random2;\n            \n\n        }\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nly3z1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [590, 590, 629, 629, 674], [676, 676, 733, 733, 2413]], "test": "untested"}
{"id": "Nld3WX", "name": "Fork Mandelmaze gchipunov 862", "author": "gchipunov", "description": "Revisiting the Mandelmaze version of the Mandelbox in daylight (mouse enabled)", "tags": ["raymarching", "fractal", "mandelbox"], "likes": 3, "viewed": 248, "published": 3, "date": "1637117804", "time_retrieved": "2024-07-30T18:47:46.641037", "image_code": "// \"Mandelmaze in Daylight\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return exp(mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y));\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nmat3 vuMat;\nvec3 vuPos;\nfloat tCur, dstFar, chRingO, chRingI, vuVel, bxSize, chSize, qnStep;\nint idObj;\n\nfloat MBoxDf (vec3 p)\n{\n  vec4 q, q0;\n  const float mScale = 2.62;\n  const int nIter = 12;\n  q0 = vec4 (p, 1.);\n  q = q0;\n  for (int n = 0; n < nIter; n ++) {\n    q.xyz = clamp (q.xyz, -1., 1.) * 2. - q.xyz;\n    q = q * mScale / clamp (dot (q.xyz, q.xyz), 0.5, 1.) + q0;\n  }\n  return length (q.xyz) / abs (q.w);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, dm, tWid;\n  dMin = dstFar;\n  d = MBoxDf (p);\n  q = p;\n  q.y -= vuPos.y;\n  tWid = 0.7 * chSize;\n  dm = min (PrCylAnDf (q.xzy, chRingO, chSize, chSize),\n     PrCylAnDf (q.xzy, chRingI, tWid, chSize));\n  dm = min (min (dm, PrBox2Df (q.xy, vec2 (tWid, chSize))),\n     PrBox2Df (q.zy, vec2 (tWid, chSize)));\n  d = max (d, - dm);\n  if (d < dMin) { dMin = d;  idObj = 1; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  const int nStep = 200;\n  float dHit, d, s;\n  dHit = 0.;\n  s = 0.;\n  for (int j = 0; j < nStep; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    ++ s;\n    if (d < 0.0003 || dHit > dstFar) break;\n  }\n  qnStep = s / float (nStep);\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return sqrt(normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw))-e;\n}\n\nvec3 TrackPath (float t)\n{\n  vec3 p;\n  vec2 tr;\n  float ti[9], aDir, a, d, r, tO, tI, tR, rGap;\n  bool rotStep;\n  tO = 0.5 * pi * chRingO / vuVel;\n  tI = 0.5 * pi * chRingI / vuVel;\n  rGap = chRingO - chRingI;\n  tR = rGap / vuVel;\n  rotStep = false;\n  ti[0] = 0.;\n  ti[1] = ti[0] + tO;  ti[2] = ti[1] + tR;\n  ti[3] = ti[2] + tI;  ti[4] = ti[3] + tR;\n  ti[5] = ti[4] + tO;  ti[6] = ti[5] + tR;\n  ti[7] = ti[6] + tI;  ti[8] = ti[7] + tR;\n  aDir = 2. * mod (floor (t / ti[8]), 2.) - 1.;\n  p.y = 0.7 * bxSize * sin (2. * pi * floor (t / (2. * ti[8])) / 11.);\n  t = mod (t, ti[8]);\n  r = chRingO;\n  tr = vec2 (0.);\n  if (t < ti[4]) {\n    if (t < ti[1]) {\n      rotStep = true;\n      a = (t - ti[0]) / (ti[1] - ti[0]);\n    } else if (t < ti[2]) {\n      tr.y = chRingO - rGap * (t - ti[1]) / (ti[2] - ti[1]);\n    } else if (t < ti[3]) {\n      rotStep = true;\n      a = 1. + (t - ti[2]) / (ti[3] - ti[2]);\n      r = chRingI;\n    } else {\n      tr.x = - (chRingI + rGap * (t - ti[3]) / (ti[4] - ti[3]));\n    }\n  } else {\n    if (t < ti[5]) {\n      rotStep = true;\n      a = 2. + (t - ti[4]) / (ti[5] - ti[4]);\n    } else if (t < ti[6]) {\n      tr.y = - chRingO + rGap * (t - ti[5]) / (ti[6] - ti[5]);\n    } else if (t < ti[7]) {\n      rotStep = true;\n      a = 3. + (t - ti[6]) / (ti[7] - ti[6]);\n      r = chRingI;\n    } else {\n      tr.x = chRingI + rGap * (t - ti[7]) / (ti[8] - ti[7]);\n    }\n  }\n  if (rotStep) {\n    a *= 0.5 * pi * aDir;\n    p.xz = r * vec2 (cos (a), sin (a));\n  } else {\n    if (aDir < 0.) tr.y *= -1.;\n    p.xz = tr;\n  }\n  return p;\n}\n\nvoid VuPM (float t)\n{\n  vec3 fpF, fpB, vel;\n  float a, ca, sa, dt;\n  dt = 0.5;\n  fpF = TrackPath (t + dt);\n  fpB = TrackPath (t - dt);\n  vuPos = 0.5 * (fpF + fpB);\n  vuPos.y = fpB.y;\n  vel = (fpF - fpB) / (2. * dt);\n  a = atan (vel.z, vel.x) - 0.5 * pi;\n  ca = cos (a);  sa = sin (a);\n  vuMat = mat3 (ca, 0., - sa, 0., 1., 0., sa, 0., ca);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 25; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 1., 20. * h / d));\n    d += min (0.1, 3. * h);\n    if (h < 0.001) break;\n  }\n  return sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, ltDir[4];\n  float dstHit, sh, dfSum, spSum;\n  int idObjT;\n  ltDir[0] = normalize (vec3 (1., 1., 0.));\n  ltDir[1] = normalize (vec3 (0., 1., 1.));\n  ltDir[2] = normalize (vec3 (1., 0., 1.));\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  if (dstHit < dstFar) {\n    ro += dstHit * rd;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    if (idObjT == 1) {\n      col = mix (vec3 (0.6, 0.9, 0.6), vec3 (0.9, 0.9, 1.),\n         clamp (1.2 * length (ro) / bxSize, 0., 1.));\n      col = col * clamp (1. - 1.2 * qnStep * qnStep, 0.2, 1.);\n    }\n    dfSum = 0.;\n    spSum = 0.;\n    for (int j = 0; j < 3; j ++) {\n      sh = 0.1 + ObjSShadow (ro, ltDir[j]);\n      dfSum += sh * (0.2 + max (dot (vn, ltDir[j]), 0.));\n      spSum += sh * pow (max (0., dot (ltDir[j], reflect (rd, vn))), 32.);\n    }\n    col = col * dfSum + 1.3 * spSum;\n    ltDir[3] = normalize (- ro);\n    sh = ObjSShadow (ro, ltDir[3]);\n    col = mix (col, vec3 (0.9, 0., 0.),\n       0.5 * (1. + cos (20. * tCur)) * sh * max (dot (vn, ltDir[3]), 0.) /\n       dot (ro, ro));\n  } else {\n    col = mix (vec3 (0., 0., 0.8), vec3 (1.),\n       0.3 + 0.2 * (1. - smoothstep (0.8, 0.9, abs (rd.y))) *\n       Fbm2 (8. * vec2 (2. * abs (atan (rd.z, rd.x)) / pi, rd.y)));\n  }\n  return pow (clamp (col, 0., 1.), vec3 (0.7));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  mat3 vuMat2;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  dstFar = 30.;\n  bxSize = 4.;\n  chSize = 0.08 * bxSize;\n  chRingO = 0.8 * bxSize;\n  chRingI = 0.4 * bxSize;\n  vuVel = 0.2 * bxSize;\n  el = 0.;\n  az = 0.;\n  if (mPtr.z > 0.) {\n    el = clamp (el - 1.3 * pi * mPtr.y, - 0.49 * pi, 0.49 * pi);\n    az = clamp (az - 1.8 * pi * mPtr.x, - pi, pi);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat2 = mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n     mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n  VuPM (tCur);\n  ro = vuPos;\n  rd = normalize (vec3 ((1./0.5) * sin (0.5 * uv.x), uv.y, 2.)) * vuMat2 * vuMat;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nld3WX.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[277, 277, 301, 301, 348], [350, 350, 375, 375, 579], [581, 581, 602, 602, 741], [743, 743, 776, 776, 860], [862, 862, 915, 915, 976], [1083, 1083, 1106, 1106, 1396], [1398, 1398, 1420, 1420, 1830], [1832, 1832, 1865, 1865, 2122], [2124, 2124, 2145, 2145, 2361], [2363, 2363, 2389, 2389, 3912], [3914, 3914, 3935, 3935, 4255], [4257, 4257, 4294, 4294, 4524], [4526, 4526, 4561, 4561, 5838], [5840, 5840, 5896, 5896, 6790]], "test": "untested"}
{"id": "NlG3Rh", "name": "terrain 3", "author": "yonatan", "description": "added some clouds/fog", "tags": ["terrain", "clouds", "fog", "short"], "likes": 17, "viewed": 817, "published": 3, "date": "1637107750", "time_retrieved": "2024-07-30T18:47:47.406989", "image_code": "#define R(a)mat2(cos(a),sin(a),-sin(a),cos(a))\n#define r iResolution.xy\n#define t iTime\n\nvoid mainImage( out vec4 o, in vec2 FC )\n{\n    o=vec4(0);\n    for(float i,e,f,g,s;i++<50.;g+=min(e*.7,f*f*.1)){\n        vec3 c=vec3(4.7,5,5.6),n,q,p=q=vec3((FC.xy-.5*r)/r.y*g,g);\n        p.zy*=R(.4+sin(t/3.)*.2);\n        s=1.4;\n        p.z+=t;\n        q=p;\n        f=abs(p.y*p.y-2.8)+.4;\n        e=++p.y;\n        mat2 m=R(1.);\n        for(;s<1e3;s*=1.7)\n            p.xz*=m,\n            n.xz*=m,\n            q.xz*=m,\n            q.yz*=m,\n            n+=cos(p*s),\n            f-=abs(cos(q.x*s)*cos(q.z*s)-.6)/s,\n            q.xz+=t/s*.2,\n            e+=sin(p.x*s)/s/2.;\n        n.y=.2;\n        n/=length(n);\n        e-=n.y;\n        c.x+=n.y*3.;\n        o.rgb+=mix(\n            mix(exp(n.z-c),c/3e2,min(g/9.+e,1.4)),\n            p-p+exp(-f*f)/50.,\n            exp(-f));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlG3Rh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 131, 131, 864]], "test": "untested"}
{"id": "ftcGWs", "name": "Ball Buffer Bounce", "author": "byt3_m3chanic", "description": "Buffer Test - using two arrays for position and velocity / Basic textel fetch based on @oneshade's shader [url]https://www.shadertoy.com/view/WtGfDD[/url]\n    ", "tags": ["ballbufferbounce"], "likes": 12, "viewed": 302, "published": 3, "date": "1637107563", "time_retrieved": "2024-07-30T18:47:48.258712", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    Buffer Demo / Ball Bouncing\n    11/16/21 @byt3_m3chanic\n    \n    Getting back into using buffers for more than post processing.\n    Using two arrays for position and velocity which get set in \n    main then used in the map function for each sphere. Need to figure\n    out how dr2 can get so many moving at once! (and ball collision).\n    \n    Simple bounce/gravity (BufferA)\n    Basic textel fetch based on @oneshade's shader \n    https://www.shadertoy.com/view/WtGfDD\n\n*/\n\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MAX_DIST    65.\n#define MIN_DIST    .0005\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat vmax(vec3 v) { return max(max(v.x, v.y), v.z); }\nfloat box(vec3 p, vec3 b, float r) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)))-r;\n}\n// @gaz\nfloat zag(vec3 p, float s) {\n    p = abs(p)-s;\n    if (p.x < p.z) p.xz = p.zx;\n    if (p.y < p.z) p.yz = p.zy;\n    if (p.x < p.y) p.xy = p.yx;\n    return dot(p,normalize(vec3(s*.42,s,0)));\n}\nvec3 hitPoint, hit;\nfloat g_hash, s_hash, fn;\n\nvec4[15] sps = vec4[15](\n    vec4(0.,0.,0.,0.),vec4(0.,0.,0.,0.),vec4(0.,0.,0.,0.),vec4(0.,0.,0.,0.),vec4(0.,0.,0.,0.),\n    vec4(0.,0.,0.,0.),vec4(0.,0.,0.,0.),vec4(0.,0.,0.,0.),vec4(0.,0.,0.,0.),vec4(0.,0.,0.,0.),\n    vec4(0.,0.,0.,0.),vec4(0.,0.,0.,0.),vec4(0.,0.,0.,0.),vec4(0.,0.,0.,0.),vec4(0.,0.,0.,0.)\n);\nvec4[15] svs = vec4[15](\n    vec4(0.,0.,0.,0.),vec4(0.,0.,0.,0.),vec4(0.,0.,0.,0.),vec4(0.,0.,0.,0.),vec4(0.,0.,0.,0.),\n    vec4(0.,0.,0.,0.),vec4(0.,0.,0.,0.),vec4(0.,0.,0.,0.),vec4(0.,0.,0.,0.),vec4(0.,0.,0.,0.),\n    vec4(0.,0.,0.,0.),vec4(0.,0.,0.,0.),vec4(0.,0.,0.,0.),vec4(0.,0.,0.,0.),vec4(0.,0.,0.,0.)\n);\n\nvec2 map(vec3 p) {\n    vec2 res = vec2(100.,-1.);\n    vec3 pb  = p.xyz;\n\n    float b1 = 1e5;\n    for (int p=0; p < SPHERE; p++) {\n        float id = float(p);\n        vec4 particlePos = sps[p];\n        vec4 particleVel = svs[p];\n        float ball = length(pb-particlePos.xyz)-.25;\n        if(ball<b1) g_hash= (particleVel.w*15.);\n        b1 = min(ball, b1);\n    }\n\n    if(b1<res.x) {\n        res = vec2(b1,6.);\n    \thit=pb;\n    }\n\n    vec3 pbd = pb-vec3(0,.65,0);\n    pbd.xz=mod(pbd.xz+3.25,6.5)-3.25;\n    float b2 = box(pbd,vec3(1.45,1.55,1.45),.0)-.15;\n    b2=max(abs(b2)-.05,b2);\n    pb.y=abs(abs(abs(pb.y-1.55)-1.)-.5);\n    float b3 = box(pb-vec3(0,.25,0),vec3(2.,.15,2.),.0);\n    b2=max(b2,-b3);\n    \n    if(b2<res.x) {\n        res = vec2(b2,5.);\n    \thit=pb;\n    }    \n\n    float d9 = p.y + 1.085;\n    if(d9<res.x) {\n        res = vec2(d9,4.);\n    \thit=p;\n    }\n\n    return res;\n}\n\n// normal\nvec3 normal(vec3 p, float t, float md) {\n    float e = md*t;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( \n        h.xyy*map( p + h.xyy*e ).x + \n        h.yyx*map( p + h.yyx*e ).x + \n        h.yxy*map( p + h.yxy*e ).x + \n        h.xxx*map( p + h.xxx*e ).x );\n}\n\nvec3 shade(vec3 p, vec3 rd, float d, float m, inout vec3 n, inout float fresnel, inout vec3 ref) {\n\n    n = normal(p,d,.1);\n\n    vec3 l = normalize(vec3(15.,35,15)-p);\n    float diff = clamp(dot(n,l),.1,.8);\n    float spec = pow(max(dot(reflect(l, n), rd ), .1), 32.)*.45;\n        \n    fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 9.);\n    fresnel = mix(.0, .95, fresnel);\n\n    vec3 h = vec3(.085);\n\n    if(m==4.) {\n        vec2 f = fract(hitPoint.xz*.5)-.5;\n        h=vec3(.302,.388,.212);\n        if(f.x*f.y>0.) h=vec3(.2);\n        ref=h;\n    }\n    if(m==5.) {\n        h=vec3(.024,.075,.075);\n        ref=vec3(.65);\n    }\n    if(m==6.) {\n        h=g_hash>.85?vec3(.02):hue((38.+s_hash)*.95);//vec3(0.004,0.008,0.012);//\n        ref=vec3(g_hash>.85?.75:.45);\n    }\n\n    return (h*diff)+spec;\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    if (iFrame == 0) {\n        O = vec4(vec3(0), 1.0);\n    } else {  \n        // get pos/vel - precal\n        for (int p=0; p < SPHERE; p++) {\n            sps[p] = getParticlePos(p);\n            svs[p] = getParticleVel(p);\n        }\n\n        vec3 C=vec3(.0);\n        vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n\n        vec3 ro = vec3(0,.65,6.),\n             rd = normalize(vec3(uv,-1));\n\n        float x = M.z<0.||M.xy == vec2(0) ? .7 :  .7+(M.y/R.y * .5 - .25) * PI;\n        float y = M.z<0.||M.xy == vec2(0) ? .6 : -(M.x/R.x * 2. - 1.) * PI;\n        if(x<.35)x=.35;\n        mat2 rx = rot(x),ry = rot(y+T*.1);\n        ro.yz *= rx; ro.xz *= ry;\n        rd.yz *= rx; rd.xz *= ry;\n\n        vec3  p = ro + rd * .1;\n        float atten = .95,k = 1.;\n        vec3 fill=vec3(1), ref=vec3(0);\n        float bt =3.;// cheat to break for reflection bounce\n        float ct =6.;// cheat to break for refraction bounce\n\n        // loop inspired/adapted from @blackle's \n        // marcher https://www.shadertoy.com/view/flsGDH\n        float fA = 0.;\n        for(int i=0;i<128;i++)\n        {\n            vec2 ray = map(p);\n            float d = ray.x*.9;\n            float m = ray.y;\n            //save for fog\n            if(bt>2.) fA += d;\n            p += rd * d *k;\n\n            if (d*d < 1e-8) {\n                hitPoint=hit;\n                s_hash=g_hash;\n                \n                vec3 n=vec3(0);\n                float fresnel= 0.;\n                vec3 h=vec3(0);\n\n                C+=shade(p,rd,d,ray.y,n,fresnel,ref)*fill;\n                //if(bt<3.)C=mix(C,vec3(.15), 1.-exp(-.0925*d*d*d));\n                if(bt<1.||ct<1.)break;\n\n                p += rd*.015;\n                k = sign(map(p).x);\n\n                vec3 rr = vec3(0);\n\n                if(m==4.||m==6.&&g_hash>.85) {\n                    fill *=ref;\n                    rd=reflect(-rd,n);\n                    p+=n*.025;\n                    bt--;\n                }else{\n                    fill *= ref;\n                    rr = refract(rd,n,.85);\n                    rd=mix(rd,rr,.95-fresnel);\n                    ct--;\n                }\n            }  \n            if(distance(p,rd)>55.) { break; }\n        }\n        //if we has - render fog\n        if(fA>0.) C=mix(C,vec3(.15), 1.-exp(-.00025*fA*fA*fA));\n        // Output to screen\n        C = sqrt(smoothstep(0.,1.,C));\n        O = vec4(C,1.);\n    }\n}\n\n// end\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//based on @oneshade's shader https://www.shadertoy.com/view/WtGfDD\n#define SPHERE 8\n\n#define getParticlePos(id) texelFetch(iChannel0, ivec2(id, 0), 0)\n#define getParticleVel(id) texelFetch(iChannel0, ivec2(id, 1), 0)\n\n#define hue(a) .25 + .25 * cos(PI * a * iDate.z+vec3(.35,.75,1.25) * vec3(1.,.98,.95))\n#define hash(a, b) fract(sin(a*1.2664745 + b*.9560333 + 3.) * 14958.5453)\n#define r2(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nconst float PI = acos(-1.0);\nconst float PI2 = PI*2.;\n\n//@Dave_Hoskins 1 to 2 hash\nvec2 hash12(in float x) {\n\tvec3 p3 = fract(x * vec3(0.1031, 0.103, 0.0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec2 randomPos(in float x) {\n    x += hash(iDate.z,iDate.w);\n    return hash12(x) * 0.2 - 0.1;\n}\n\nvec2 randomVel(in float x) {\n    x += hash(iDate.z,iDate.w);\n    vec2 h2 = hash12(x * 847.586 + 285.364);\n    return vec2(h2.x * 0.1 - 0.05,h2.y* 0.05);\n}\n", "buffer_a_code": "// gravity and bounce\n#define gvy .0005\n#define bnc .75\n#define wall 1.325\n\nvec4 setRndPos(float id) {\n    return vec4(randomPos(id),randomPos(id).x,.175);\n}\nvec4 setRndVel(float id) {\n    vec2 dz = randomVel(id+iDate.z);\n    return vec4(randomVel(id),dz.x,dz.y*2.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 corner = vec2(0.5 * (iResolution.x / iResolution.y), 0.5);\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    ivec2 iFragCoord = ivec2(fragCoord);\n    if (iFragCoord.x < SPHERE && iFragCoord.y < 2) {\n    \n        if (iFrame == 0) {\n            if (iFragCoord.y == 0) fragColor =vec4(0,-.25,0,.125);\n            if (iFragCoord.y == 1) fragColor = setRndVel(fragCoord.x);\n        }\n\n        if (iFrame > 0) {\n            vec4 pos = getParticlePos(iFragCoord.x);\n            vec4 vel = getParticleVel(iFragCoord.x);\n           \n           pos.xyz += vel.xyz;\n           if (pos.x<-wall || pos.x>wall ) {\n                pos.x-=vel.x;\n                vel.x*=bnc;\n                vel.x=-vel.x;\n            }\n            if (pos.z<-wall || pos.z>wall ) {\n                pos.z-=vel.z;\n                vel.z*=bnc;\n                vel.z=-vel.z;\n            }\n            if (pos.y<-.725) {\n                pos.y-=vel.y;\n                vel.y*=bnc;\n                vel.y=-vel.y;\n            }\n            \n            vel.y-=gvy;\n            vel.x*=.998;\n            vel.z*=.999;\n            pos.w-=(abs(vel.w*.0075));\n            \n            if(pos.w<.02||(abs(vel.x)<.0005&&abs(vel.z)<.0005)) {\n                pos.w = .175;\n                vel.xyz = setRndVel(fragCoord.x).xyz;\n            }\n            \n            if (iFragCoord.y == 0) fragColor = pos;\n            if (iFragCoord.y == 1) fragColor = vel;\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftcGWs.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[735, 735, 754, 754, 799], [800, 800, 820, 820, 854], [855, 855, 891, 891, 974], [975, 983, 1011, 1011, 1173], [1846, 1846, 1864, 1864, 2733], [2735, 2745, 2785, 2785, 3015], [3017, 3017, 3115, 3115, 3810], [3812, 3812, 3853, 3853, 6221]], "test": "untested"}
{"id": "7lKGzR", "name": "SVG to GLSL", "author": "zduny", "description": "Mostly auto-generated with the help of: https://zduny.github.io/shadertoy-svg/\nReally long, may potentially crash your browser.\n\nRe-upload of my old shadertoy (from an old no longer existing account).", "tags": ["2d", "vector", "tool"], "likes": 10, "viewed": 1209, "published": 3, "date": "1637087651", "time_retrieved": "2024-07-30T18:47:49.881373", "image_code": "// Shadertoy-SVG URL: https://zduny.github.io/shadertoy-svg/\n// This example uses SVG images from:\n// https://www.flaticon.com/packs/font-awesome\n\nconst float epsilon = 0.000001;\nconst float pi = 3.14159265359;\nconst vec3 up = vec3(0.0, 1.0, 0.0);\nconst vec3 forward = vec3(0.0, 0.0, -1.0);\nconst vec3 right = vec3(1.0, 0.0, 0.0);\n\nmat4 rotationMatrix(vec3 axis, float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat4(\n      oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,\n      oc * axis.z * axis.x + axis.y * s, 0.0, oc * axis.x * axis.y + axis.z * s,\n      oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 0.0,\n      oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s,\n      oc * axis.z * axis.z + c, 0.0, 0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 translationMatrix(vec3 t) {\n  return mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, t.x,\n              t.y, t.z, 1.0);\n}\n\nstruct Ray {\n  vec3 Origin;\n  vec3 Dir;\n};\n\nstruct AABB {\n  vec3 Min;\n  vec3 Max;\n};\n\nRay createRay(vec3 iResolution, vec2 screenPos, float fov) {\n  vec2 topLeft = vec2(-iResolution.x, -iResolution.y) * .5;\n  float z = (iResolution.x * .5) / abs(tan(fov / 2.0));\n\n  return Ray(vec3(0.0, 0.0, 0.0), normalize(vec3(topLeft + screenPos, -z)));\n}\n\nvec3 evalRay(Ray ray, float t) { return ray.Origin + t * ray.Dir; }\n\nvoid transform(inout Ray ray, mat4 mat) {\n  ray.Origin = (mat * vec4(ray.Origin, 1.0)).xyz;\n  ray.Dir = normalize(mat * vec4(ray.Dir, 0.0)).xyz;\n}\n\nAABB createAABB(vec3 middle, vec3 halfWidth) {\n  return AABB(middle - halfWidth, middle + halfWidth);\n}\n\nbool intersectAABB(Ray r, AABB aabb, out float t0, out float t1) {\n  vec3 invR = 1.0 / r.Dir;\n\n  vec3 tbot = invR * (aabb.Min - r.Origin);\n  vec3 ttop = invR * (aabb.Max - r.Origin);\n\n  vec3 tmin = min(ttop, tbot);\n  vec3 tmax = max(ttop, tbot);\n\n  vec2 t = max(tmin.xx, tmin.yz);\n  t0 = max(t.x, t.y);\n  t = min(tmax.xx, tmax.yz);\n  t1 = min(t.x, t.y);\n\n  return t0 <= t1;\n}\n\nvec3 tosRGB(vec3 color) { return pow(color, vec3(1.0 / 2.2)); }\n\nfloat tex0(vec2 uv) {\n  uv.x *= iResolution.y / iResolution.x;\n  return texture(iChannel0, uv * size).a;\n}\n\nfloat tex1(vec2 uv) {\n  uv.x += 1.0;\n  uv.x *= iResolution.y / iResolution.x;\n  return texture(iChannel0, uv * size).a;\n}\n\nfloat tex2(vec2 uv) {\n  uv.x *= iResolution.y / iResolution.x;\n  return texture(iChannel1, uv * size).a;\n}\n\nfloat tex3(vec2 uv) {\n  uv.x += 1.0;\n  uv.x *= iResolution.y / iResolution.x;\n  return texture(iChannel1, uv * size).a;\n}\n\nfloat tex4(vec2 uv) {\n  uv.x *= iResolution.y / iResolution.x;\n  return texture(iChannel2, uv * size).a;\n}\n\nfloat tex5(vec2 uv) {\n  uv.x += 1.0;\n  uv.x *= iResolution.y / iResolution.x;\n  return texture(iChannel2, uv * size).a;\n}\n\nvec4 trace(Ray ray) {\n  AABB box = createAABB(vec3(0.0), vec3(0.5));\n  mat4 T = translationMatrix(vec3(0.0, 0.0, -2.8)) *\n           rotationMatrix(right, iTime * 0.4) * rotationMatrix(up, iTime * 0.7);\n\n  transform(ray, inverse(T));\n\n  float t0, t1;\n  vec2 uv;\n  if (intersectAABB(ray, box, t0, t1)) {\n    vec3 p = evalRay(ray, t0);\n\n    if (p.x > 0.49999) {\n      uv = vec2(-p.z, p.y) + vec2(0.5);\n\n      return vec4(mix(vec3(1, 0, 0), vec3(0), tex0(uv)), 1.0);\n    } else if (p.x < -0.49999) {\n      uv = vec2(p.z, p.y) + vec2(0.5);\n\n      return vec4(mix(vec3(0, 1, 0), vec3(0), tex1(uv)), 1.0);\n    } else if (p.y > 0.49999) {\n      uv = vec2(-p.x, p.z) + vec2(0.5);\n\n      return vec4(mix(vec3(0, 0, 1), vec3(0), tex2(uv)), 1.0);\n    } else if (p.y < -0.49999) {\n      uv = vec2(p.x, p.z) + vec2(0.5);\n\n      return vec4(mix(vec3(1, 1, 0), vec3(0), tex3(uv)), 1.0);\n    } else if (p.z > 0.49999) {\n      uv = vec2(p.x, p.y) + vec2(0.5);\n\n      return vec4(mix(vec3(0, 1, 1), vec3(0), tex4(uv)), 1.0);\n    } else if (p.z < -0.49999) {\n      uv = vec2(-p.x, p.y) + vec2(0.5);\n\n      return vec4(mix(vec3(1, 0, 1), vec3(0), tex5(uv)), 1.0);\n    }\n  }\n\n  return vec4(0.01, 0.01, 0.03, 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  const float numSamp = 3.0;\n  const float fov = pi / 2.5;\n  float step = 1.0 / numSamp;\n\n  fragColor = vec4(0.0);\n\n  for (float i = 0.0; i < numSamp; i++) {\n    for (float j = 0.0; j < numSamp; j++) {\n      Ray ray =\n          createRay(iResolution, fragCoord + vec2(i * step, j * step), fov);\n      fragColor += trace(ray);\n    }\n  }\n  fragColor /= numSamp * numSamp;\n  fragColor = vec4(tosRGB(fragColor.rgb), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float size = 0.6;\n\nbool sameSide(vec3 p1, vec3 p2, vec3 a, vec3 b) {\n  vec3 cp1 = cross(b - a, p1 - a);\n  vec3 cp2 = cross(b - a, p2 - a);\n\n  return dot(cp1, cp2) >= 0.0;\n}\n\nbool pointInTriangle(vec3 p, vec3 a, vec3 b, vec3 c) {\n  return sameSide(p, a, b, c) && sameSide(p, b, a, c) && sameSide(p, c, a, b);\n}\n\nvec2 rotate(vec2 v, float a) {\n  float s = sin(a);\n  float c = cos(a);\n  mat2 m = mat2(c, -s, s, c);\n  return m * v;\n}", "buffer_a_code": "const vec3 positions0[158] =\n    vec3[158](vec3(0.6277899413028561, -0.2786392446278261, 0),\n              vec3(0.596691607602923, -0.2153862575433556, 0),\n              vec3(0.5759628877842374, -0.1483772478777572, 0),\n              vec3(0.565600229865793, -0.07761931959304302, 0),\n              vec3(0.5655271264789397, -0.007238846845419866, 0),\n              vec3(0.5752997773302575, 0.057819615473060804, 0),\n              vec3(0.5948352453077018, 0.12002406105355445, 0),\n              vec3(0.6241232691328116, 0.17936935925683095, 0),\n              vec3(0.6537650850659988, 0.22359227099457568, 0),\n              vec3(0.6814126363302933, 0.2566416124836083, 0),\n              vec3(0.7352801302708766, 0.3107246672714681, 0),\n              vec3(0.7482070389212923, 0.3861399333174764, 0),\n              vec3(0.7013299175993031, 0.43278558387726873, 0),\n              vec3(0.6700696234321291, 0.45862937012063054, 0),\n              vec3(0.625722162138198, 0.4882824751045597, 0),\n              vec3(0.5654757460870324, 0.5175744784639444, 0),\n              vec3(0.5014731101224617, 0.5371024807035343, 0),\n              vec3(0.43371701689637904, 0.5468664818233291, 0),\n              vec3(0.37651964765137713, 0.5474487435985408, 0),\n              vec3(0.32919625938249186, 0.542341652686771, 0),\n              vec3(0.27721365869567033, 0.532124445101634, 0),\n              vec3(0.22057776555925568, 0.5167939635266803, 0),\n              vec3(0.1356011504208703, 0.4893308357206152, 0),\n              vec3(0.06816109306032368, 0.4720844139468139, 0),\n              vec3(0.0331605793386265, 0.46697263639343933, 0),\n              vec3(-0.0070487089733037335, 0.46858595109948276, 0),\n              vec3(-0.08997983527227653, 0.48661357025134333, 0),\n              vec3(-0.17814938533626473, 0.5108460808888686, 0),\n              vec3(-0.23629230508043778, 0.5243667788084075, 0),\n              vec3(-0.2894780406667621, 0.5333786315059135, 0),\n              vec3(-0.3377054081015687, 0.5378836123041673, 0),\n              vec3(-0.38551869738957023, 0.5377704895202088, 0),\n              vec3(-0.4349472490120887, 0.5323613774457361, 0),\n              vec3(-0.48212219201923795, 0.5215434369619405, 0),\n              vec3(-0.5270434770779483, 0.505316964067239, 0),\n              vec3(-0.5697110548551502, 0.483682254760049, 0),\n              vec3(-0.6101248760177741, 0.4566396050387874, 0),\n              vec3(-0.6482848912327506, 0.4241893109018715, 0),\n              vec3(-0.68419105116701, 0.38633166834771826, 0),\n              vec3(-0.7177453772611648, 0.3430548271619198, 0),\n              vec3(-0.7474556181617787, 0.2961046353417899, 0),\n              vec3(-0.772922129755971, 0.24607497465595773, 0),\n              vec3(-0.7941447147114633, 0.19296564777214487, 0),\n              vec3(-0.8111231756959777, 0.1367764573580733, 0),\n              vec3(-0.8238573153772362, 0.077507206081465, 0),\n              vec3(-0.8323469364229603, 0.015157696610041849, 0),\n              vec3(-0.8365918415008724, -0.050272268388474206, 0),\n              vec3(-0.8364321544659189, -0.12058956705725743, 0),\n              vec3(-0.8309098271079823, -0.19401793756163332, 0),\n              vec3(-0.8198655506123088, -0.26815894892179015, 0),\n              vec3(-0.8032997196434547, -0.3430130451353517, 0),\n              vec3(-0.7812127288659761, -0.41858067019994505, 0),\n              vec3(-0.7536049729444292, -0.4948622681131958, 0),\n              vec3(-0.7204768465433699, -0.5718582828727292, 0),\n              vec3(-0.6818287443273547, -0.6495691584761714, 0),\n              vec3(-0.6380367785351025, -0.7263885444024594, 0),\n              vec3(-0.5931552641526052, -0.7944849638641844, 0),\n              vec3(-0.5481600617113944, -0.8528543573417213, 0),\n              vec3(-0.5030514178768177, -0.9014963795035831, 0),\n              vec3(-0.4578295793142229, -0.9404106850182836, 0),\n              vec3(-0.41249479268895745, -0.9695969285543358, 0),\n              vec3(-0.36704730466636903, -0.9890547647802534, 0),\n              vec3(-0.32148736191180505, -0.9987838483645497, 0),\n              vec3(-0.2827777136082444, -0.999361260082364, 0),\n              vec3(-0.2476218500506222, -0.994251784738901, 0),\n              vec3(-0.20795970659058224, -0.9840339687125723, 0),\n              vec3(-0.16379286188634926, -0.9687089959970487, 0),\n              vec3(-0.1160540233946624, -0.9498419993338061, 0),\n              vec3(-0.07037742231949091, -0.9349724530717531, 0),\n              vec3(-0.02770777049782462, -0.9250539736669281, 0),\n              vec3(0.011957300057673535, -0.9200920864231181, 0),\n              vec3(0.05058427127557704, -0.9200724518614485, 0),\n              vec3(0.09279703309604374, -0.9248790386024033, 0),\n              vec3(0.13816908468869923, -0.9344914556439132, 0),\n              vec3(0.18669647940798226, -0.9489089136568669, 0),\n              vec3(0.2636721011099018, -0.974732325342516, 0),\n              vec3(0.32914206700562204, -0.9909504486152005, 0),\n              vec3(0.3648996953452733, -0.9957575451312073, 0),\n              vec3(0.3996448816545705, -0.9954383056994687, 0),\n              vec3(0.4381432991154777, -0.9880763132347992, 0),\n              vec3(0.47668029503675113, -0.9733524701380347, 0),\n              vec3(0.5152552774215563, -0.9512669244083845, 0),\n              vec3(0.5538676542730596, -0.9218198240450564, 0),\n              vec3(0.592516833594426, -0.8850113170472589, 0),\n              vec3(0.6312022233888215, -0.8408415514142014, 0),\n              vec3(0.6699232316594119, -0.7893106751450913, 0),\n              vec3(0.7136875226274348, -0.7232269842812997, 0),\n              vec3(0.7574024435261331, -0.6481106273035251, 0),\n              vec3(0.7943603125585417, -0.5729924943352478, 0),\n              vec3(0.8245587617373238, -0.4978714013827992, 0),\n              vec3(0.8107560595480408, -0.4508389713357761, 0),\n              vec3(0.7602787588115438, -0.423789386207158, 0),\n              vec3(0.7128068286703276, -0.3859267815684284, 0),\n              vec3(0.6683379011370547, -0.33724957876136386, 0),\n              vec3(0.25687247480461467, 0.6393554792332772, 0),\n              vec3(0.28977930950015485, 0.679019563127385, 0),\n              vec3(0.31772639471823066, 0.7204860800495488, 0),\n              vec3(0.34071609844617917, 0.7637526620124314, 0),\n              vec3(0.3585169745883383, 0.8083331069493588, 0),\n              vec3(0.3715759807545777, 0.8513035424959008, 0),\n              vec3(0.38027848221746763, 0.8921725866130835, 0),\n              vec3(0.3846280309580142, 0.9309390553072385, 0),\n              vec3(0.3851378142319196, 0.9520827237958521, 0),\n              vec3(0.3848429998084562, 0.9580937280961171, 0),\n              vec3(0.38432250303628607, 0.9650060146878361, 0),\n              vec3(0.3840278201676743, 0.9710088625872735, 0),\n              vec3(0.3833474184728271, 0.9757435874902912, 0),\n              vec3(0.38185032425639914, 0.9823532979222753, 0),\n              vec3(0.38013136278197474, 0.9912094390080133, 0),\n              vec3(0.3786262437195713, 0.9978191494399973, 0),\n              vec3(0.3520142727230092, 0.9935272967520291, 0),\n              vec3(0.3029621241987654, 0.9787240315244234, 0),\n              vec3(0.2577411571870655, 0.961443333545027, 0),\n              vec3(0.21635122368870094, 0.9416848574823532, 0),\n              vec3(0.17879217570446326, 0.9194482580049155, 0),\n              vec3(0.14506386523514372, 0.894733189781227, 0),\n              vec3(0.11516614428153409, 0.867539307479801, 0),\n              vec3(0.08909886484442583, 0.8378662657691512, 0),\n              vec3(0.05632319547524989, 0.788878035430879, 0),\n              vec3(0.0220718208586009, 0.7178168238791001, 0),\n              vec3(-0.0013687049029966019, 0.6405974639250285, 0),\n              vec3(-0.013994040499424099, 0.5572179822458834, 0),\n              vec3(0.021758975198226872, 0.5171994813581512, 0),\n              vec3(0.08425187123621597, 0.5274112951943538, 0),\n              vec3(0.12498084232466884, 0.5397339970757986, 0),\n              vec3(0.15743354967090253, 0.5559646920590333, 0),\n              vec3(0.1898771797323439, 0.5776040674523824, 0),\n              vec3(0.22232672976212792, 0.6046501499330649, 0),\n              vec3(-0.837122463885562, -0.08414248337672903, 0),\n              vec3(-0.7012989199872864, 0.36537518391368307, 0),\n              vec3(-0.6604348256214124, -0.6886928078436161, 0),\n              vec3(-0.3599593337641316, 0.5384466424044436, 0),\n              vec3(-0.2986652970929535, -1, 0),\n              vec3(-0.14721935140300618, 0.5023942983074677, 0),\n              vec3(-0.14002066989835546, -0.95913169587886, 0),\n              vec3(-0.01624965532628756, 0.5132175790960392, 0),\n              vec3(0.018649215827837805, 0.4663335346999601, 0),\n              vec3(0.030663857356652596, -0.919471591519027, 0),\n              vec3(0.07750159444480711, 0.8220999522192778, 0),\n              vec3(0.10874639802815063, 0.5336475214013432, 0),\n              vec3(0.1905166843125575, 0.5072102583316318, 0),\n              vec3(0.2121421971133708, -0.9579192863622872, 0),\n              vec3(0.23855841140675307, 0.6202000896677872, 0),\n              vec3(0.3503526722473988, 0.7860602373880995, 0),\n              vec3(0.3779770863020878, 1, 0),\n              vec3(0.38041032484576504, -0.9963585616950157, 0),\n              vec3(0.3809912710724561, 0.9867813684651443, 0),\n              vec3(0.38398861682176105, 0.9735627369302886, 0),\n              vec3(0.3845653532931863, 0.9615523051567397, 0),\n              vec3(0.3851715580514727, 0.9495334538726591, 0),\n              vec3(0.39843228713898704, 0.5480869819633034, 0),\n              vec3(0.5643050641250971, -0.04083673095664575, 0),\n              vec3(0.642421282838722, 0.20796822476725318, 0),\n              vec3(0.6472288233523544, -0.30885500971401036, 0),\n              vec3(0.6544359243675368, 0.4699749730049443, 0),\n              vec3(0.6892969077242694, -0.76078486677177, 0),\n              vec3(0.7794530264983045, 0.3497906699194042, 0),\n              vec3(0.837122463885562, -0.46030937491448887, 0));\nconst ivec3 triangles0[154] = ivec3[154](\n    ivec3(0, 72, 1), ivec3(0, 73, 72), ivec3(0, 153, 73), ivec3(1, 71, 137),\n    ivec3(1, 72, 71), ivec3(1, 137, 2), ivec3(2, 25, 3), ivec3(2, 51, 25),\n    ivec3(2, 52, 51), ivec3(2, 69, 52), ivec3(2, 70, 69), ivec3(2, 137, 70),\n    ivec3(3, 25, 136), ivec3(3, 136, 151), ivec3(4, 23, 5), ivec3(4, 24, 23),\n    ivec3(4, 151, 24), ivec3(5, 22, 140), ivec3(5, 23, 22), ivec3(5, 140, 6),\n    ivec3(6, 19, 7), ivec3(6, 20, 19), ivec3(6, 21, 20), ivec3(6, 140, 21),\n    ivec3(7, 16, 152), ivec3(7, 17, 16), ivec3(7, 18, 150), ivec3(7, 19, 18),\n    ivec3(7, 150, 17), ivec3(8, 14, 9), ivec3(8, 15, 14), ivec3(8, 152, 15),\n    ivec3(9, 12, 10), ivec3(9, 13, 12), ivec3(9, 14, 154), ivec3(9, 154, 13),\n    ivec3(10, 11, 156), ivec3(10, 12, 11), ivec3(15, 152, 16),\n    ivec3(24, 151, 136), ivec3(25, 49, 26), ivec3(25, 50, 49),\n    ivec3(25, 51, 50), ivec3(26, 45, 133), ivec3(26, 46, 45),\n    ivec3(26, 47, 128), ivec3(26, 48, 47), ivec3(26, 49, 48),\n    ivec3(26, 128, 46), ivec3(27, 42, 28), ivec3(27, 43, 42),\n    ivec3(27, 133, 43), ivec3(28, 40, 29), ivec3(28, 41, 40), ivec3(28, 42, 41),\n    ivec3(29, 38, 30), ivec3(29, 39, 129), ivec3(29, 40, 39),\n    ivec3(29, 129, 38), ivec3(30, 37, 131), ivec3(30, 38, 37),\n    ivec3(31, 36, 32), ivec3(31, 37, 36), ivec3(31, 131, 37), ivec3(32, 35, 33),\n    ivec3(32, 36, 35), ivec3(33, 35, 34), ivec3(43, 133, 44),\n    ivec3(44, 133, 45), ivec3(52, 69, 53), ivec3(53, 69, 54),\n    ivec3(54, 68, 130), ivec3(54, 69, 68), ivec3(55, 67, 56), ivec3(55, 68, 67),\n    ivec3(55, 130, 68), ivec3(56, 67, 57), ivec3(57, 67, 134),\n    ivec3(57, 134, 58), ivec3(58, 65, 59), ivec3(58, 66, 65),\n    ivec3(58, 134, 66), ivec3(59, 65, 60), ivec3(60, 64, 61), ivec3(60, 65, 64),\n    ivec3(61, 63, 62), ivec3(61, 64, 63), ivec3(62, 63, 132),\n    ivec3(73, 153, 74), ivec3(74, 84, 141), ivec3(74, 85, 84),\n    ivec3(74, 153, 85), ivec3(75, 82, 76), ivec3(75, 83, 82),\n    ivec3(75, 141, 83), ivec3(76, 80, 77), ivec3(76, 81, 80), ivec3(76, 82, 81),\n    ivec3(77, 78, 145), ivec3(77, 79, 78), ivec3(77, 80, 79),\n    ivec3(83, 141, 84), ivec3(85, 93, 155), ivec3(85, 153, 93),\n    ivec3(86, 92, 87), ivec3(86, 93, 92), ivec3(86, 155, 93), ivec3(87, 92, 88),\n    ivec3(88, 91, 89), ivec3(88, 92, 91), ivec3(89, 90, 157), ivec3(89, 91, 90),\n    ivec3(94, 118, 138), ivec3(94, 138, 95), ivec3(94, 142, 118),\n    ivec3(95, 116, 96), ivec3(95, 117, 116), ivec3(95, 138, 117),\n    ivec3(96, 115, 97), ivec3(96, 116, 115), ivec3(97, 114, 143),\n    ivec3(97, 115, 114), ivec3(98, 113, 99), ivec3(98, 114, 113),\n    ivec3(98, 143, 114), ivec3(99, 112, 100), ivec3(99, 113, 112),\n    ivec3(100, 111, 101), ivec3(100, 112, 111), ivec3(101, 111, 149),\n    ivec3(102, 110, 103), ivec3(102, 149, 110), ivec3(103, 110, 148),\n    ivec3(104, 110, 105), ivec3(104, 148, 110), ivec3(105, 106, 147),\n    ivec3(105, 110, 106), ivec3(106, 110, 107), ivec3(107, 110, 146),\n    ivec3(108, 110, 109), ivec3(108, 146, 110), ivec3(109, 110, 144),\n    ivec3(110, 149, 111), ivec3(118, 142, 119), ivec3(119, 125, 120),\n    ivec3(119, 126, 125), ivec3(119, 127, 126), ivec3(119, 142, 127),\n    ivec3(120, 123, 121), ivec3(120, 124, 139), ivec3(120, 125, 124),\n    ivec3(120, 139, 123), ivec3(121, 122, 135), ivec3(121, 123, 122));\nconst int len0 = 154;\n\nbool inPath0(vec2 p) {\n  for (int i = 0; i < len0; i++) {\n    ivec3 triangle = triangles0[i];\n    vec3 a = positions0[triangle[0]];\n    vec3 b = positions0[triangle[1]];\n    vec3 c = positions0[triangle[2]];\n\n    if (pointInTriangle(vec3(p, 0.0), a, b, c)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nconst vec3 positions1[268] = vec3[268](\n    vec3(0.9845748530176339, -0.30029058091261956, 0),\n    vec3(0.9717445580365345, -0.295275565061197, 0),\n    vec3(0.9598743970052099, -0.29464882550925875, 0),\n    vec3(0.9280311558913397, -0.29464882550925875, 0),\n    vec3(0.839982675943951, -0.29464882550925875, 0),\n    vec3(0.695728957163045, -0.29464882550925875, 0),\n    vec3(0.6076804772156561, -0.29464882550925875, 0),\n    vec3(0.575837236101786, -0.29464882550925875, 0),\n    vec3(0.5601292496862944, -0.2960432156497131, 0),\n    vec3(0.5433907043426252, -0.3072038339529265, 0),\n    vec3(0.5350839162786878, -0.32737035940315784, 0),\n    vec3(0.5389865473021307, -0.34691026746099674, 0),\n    vec3(0.550538091423227, -0.3608443350220668, 0),\n    vec3(0.5810561419620972, -0.39135917887284866, 0),\n    vec3(0.6220375241142944, -0.432336254901041, 0),\n    vec3(0.6525555746531646, -0.4628510987518226, 0),\n    vec3(0.6376913461322333, -0.4925425414511772, 0),\n    vec3(0.5925633650728268, -0.5393497123631323, 0),\n    vec3(0.5396915071385151, -0.5821794906093515, 0),\n    vec3(0.47907613880793765, -0.6210355409762208, 0),\n    vec3(0.41122478718585453, -0.655673819230258, 0),\n    vec3(0.33917116244336665, -0.6846210812439164, 0),\n    vec3(0.2634177526039527, -0.7076376194476043, 0),\n    vec3(0.18396272527441915, -0.7247285645422633, 0),\n    vec3(0.14284653242798417, -0.7229437391308541, 0),\n    vec3(0.14284653242798417, -0.6644121110775986, 0),\n    vec3(0.14284653242798417, -0.563568462744881, 0),\n    vec3(0.14284653242798417, -0.4373376022444861, 0),\n    vec3(0.14284653242798417, -0.30264433768819893, 0),\n    vec3(0.14284653242798417, -0.176413477187804, 0),\n    vec3(0.14284653242798417, -0.07556982885508667, 0),\n    vec3(0.14284653242798417, -0.017038200801830692, 0),\n    vec3(0.1520539417465101, -0.008928396914933825, 0),\n    vec3(0.2106465465007641, -0.008928396914933825, 0),\n    vec3(0.28932804431361925, -0.008928396914933825, 0),\n    vec3(0.34792064906787346, -0.008928396914933825, 0),\n    vec3(0.37115038621962104, -0.007601011285587446, 0),\n    vec3(0.39627787192206765, 0.0030048805181911464, 0),\n    vec3(0.41664706005949625, 0.02335769927642473, 0),\n    vec3(0.4272518524273585, 0.04847186958833239, 0),\n    vec3(0.428578688338747, 0.06863364608620386, 0),\n    vec3(0.428578688338747, 0.1076985892771284, 0),\n    vec3(0.428578688338747, 0.1601572272763701, 0),\n    vec3(0.428578688338747, 0.19922217046729465, 0),\n    vec3(0.4272518524273585, 0.21937735034966974, 0),\n    vec3(0.41664706005949625, 0.244487122917913, 0),\n    vec3(0.3962800707938998, 0.26485753265080375, 0),\n    vec3(0.3711525850914532, 0.27545902671091793, 0),\n    vec3(0.34792064906787346, 0.27678421346843224, 0),\n    vec3(0.28932804431361925, 0.27678421346843224, 0),\n    vec3(0.21064654650076386, 0.27678421346843224, 0),\n    vec3(0.15205394174650966, 0.27678421346843224, 0),\n    vec3(0.14284653242798395, 0.28460083635311745, 0),\n    vec3(0.14284653242798395, 0.3343429819829331, 0),\n    vec3(0.14284653242798395, 0.40113957754297114, 0),\n    vec3(0.14284653242798395, 0.45088172317278674, 0),\n    vec3(0.17360893259920296, 0.47938331662190775, 0),\n    vec3(0.22550707206044995, 0.5310000004886384, 0),\n    vec3(0.26373885660619245, 0.5953863271217649, 0),\n    vec3(0.28327766522811526, 0.667094958035753, 0),\n    vec3(0.28441232126836735, 0.7343961946812714, 0),\n    vec3(0.27394814980815996, 0.789221276870214, 0),\n    vec3(0.25302156293122247, 0.839721911122578, 0),\n    vec3(0.22163439303074872, 0.8858951656092539, 0),\n    vec3(0.1805524964769183, 0.9269790014458806, 0),\n    vec3(0.13437792877512056, 0.9583728290416244, 0),\n    vec3(0.08387854665810557, 0.9793024088274445, 0),\n    vec3(0.02905215125404137, 0.9897673743247022, 0),\n    vec3(-0.029021573192625216, 0.9897673743247022, 0),\n    vec3(-0.0838528397085958, 0.9793024088274445, 0),\n    vec3(-0.13436020800594584, 0.9583728290416244, 0),\n    vec3(-0.18054404456331385, 0.9269790014458805, 0),\n    vec3(-0.2216291936150625, 0.8858951656092537, 0),\n    vec3(-0.2530146990917195, 0.8397219111225779, 0),\n    vec3(-0.27394053774143623, 0.7892212768702139, 0),\n    vec3(-0.2844045106923808, 0.7343961946812712, 0),\n    vec3(-0.28326996917670333, 0.6670949580357528, 0),\n    vec3(-0.2637343367029824, 0.5953863271217646, 0),\n    vec3(-0.2255088433738709, 0.5310000004886383, 0),\n    vec3(-0.1736127806249097, 0.47938331662190753, 0),\n    vec3(-0.14285435063894347, 0.4508817231727865, 0),\n    vec3(-0.14285435063894347, 0.4011395775429709, 0),\n    vec3(-0.14285435063894347, 0.3343429819829331, 0),\n    vec3(-0.14285435063894347, 0.28460083635311745, 0),\n    vec3(-0.15206175995746907, 0.2767842134684321, 0),\n    vec3(-0.21065436471172316, 0.2767842134684321, 0),\n    vec3(-0.28933586252457855, 0.2767842134684321, 0),\n    vec3(-0.34792846727883275, 0.2767842134684321, 0),\n    vec3(-0.3711640070090264, 0.27545847699295983, 0),\n    vec3(-0.3962796432354886, 0.26485588349692957, 0),\n    vec3(-0.4166487092133707, 0.24448877207178688, 0),\n    vec3(-0.42725337942168706, 0.21937790006762764, 0),\n    vec3(-0.42857868833874746, 0.19922217046729443, 0),\n    vec3(-0.42857868833874746, 0.16015722727636988, 0),\n    vec3(-0.42857868833874746, 0.10769858927712818, 0),\n    vec3(-0.42857868833874746, 0.06863364608620363, 0),\n    vec3(-0.4272528297037289, 0.04847186958833217, 0),\n    vec3(-0.4166470600594967, 0.02335769927642473, 0),\n    vec3(-0.39627084774816, 0.0029982839026946547, 0),\n    vec3(-0.3711552115216976, -0.007603210157419647, 0),\n    vec3(-0.34792846727883275, -0.008928396914933825, 0),\n    vec3(-0.28933586252457855, -0.008928396914933825, 0),\n    vec3(-0.21065436471172316, -0.008928396914933825, 0),\n    vec3(-0.15206175995746907, -0.008928396914933825, 0),\n    vec3(-0.14285435063894347, -0.017038200801830692, 0),\n    vec3(-0.14285435063894347, -0.07556982885508667, 0),\n    vec3(-0.14285435063894347, -0.176413477187804, 0),\n    vec3(-0.14285435063894347, -0.30264433768819893, 0),\n    vec3(-0.14285435063894347, -0.4373376022444863, 0),\n    vec3(-0.14285435063894347, -0.5635684627448814, 0),\n    vec3(-0.14285435063894347, -0.6644121110775988, 0),\n    vec3(-0.14285435063894347, -0.7229437391308545, 0),\n    vec3(-0.18396475617687547, -0.7247253273142883, 0),\n    vec3(-0.2634155384621776, -0.7076271748064015, 0),\n    vec3(-0.33917020043694035, -0.6846048951040409, 0),\n    vec3(-0.41122544379341563, -0.655656289335374, 0),\n    vec3(-0.4790753524058591, -0.6210160336236825, 0),\n    vec3(-0.5396922630007076, -0.5821549899853604, 0),\n    vec3(-0.5925676788318031, -0.5393229670574794, 0),\n    vec3(-0.6376986680700356, -0.4925152006177366, 0),\n    vec3(-0.6525637288028756, -0.4628249107990994, 0),\n    vec3(-0.6220478160560645, -0.43231754922052434, 0),\n    vec3(-0.5810693046532037, -0.3913505208150094, 0),\n    vec3(-0.5505533919063925, -0.3608431592364345, 0),\n    vec3(-0.5389954649490057, -0.3468968909906846, 0),\n    vec3(-0.5350896577773608, -0.3273610141978713, 0),\n    vec3(-0.5433891162685243, -0.3071847159839413, 0),\n    vec3(-0.5601293718458407, -0.2960166459484077, 0),\n    vec3(-0.5758411452072658, -0.29462146177090304, 0),\n    vec3(-0.6076843863211361, -0.29462146177090304, 0),\n    vec3(-0.6957328662685244, -0.29462146177090304, 0),\n    vec3(-0.8399865850494307, -0.29462146177090304, 0),\n    vec3(-0.928035064996819, -0.29462146177090304, 0),\n    vec3(-0.9598783061106893, -0.29462146177090304, 0),\n    vec3(-0.971757506948435, -0.29524862888125303, 0),\n    vec3(-0.9845941542259384, -0.3002747612513828, 0),\n    vec3(-0.9943483496733942, -0.3100470363116808, 0),\n    vec3(-0.9993709394166833, -0.32288844781148707, 0),\n    vec3(-1, -0.33477425289970114, 0), vec3(-1, -0.366616226608279, 0),\n    vec3(-1, -0.45466120210368477, 0), vec3(-1, -0.5989091793859186, 0),\n    vec3(-1, -0.6869541548813245, 0), vec3(-1, -0.7187961285899025, 0),\n    vec3(-0.9986052433809072, -0.7344993584180631, 0),\n    vec3(-0.9874482898640804, -0.7512419350267577, 0),\n    vec3(-0.9734964480890338, -0.7576513410186345, 0),\n    vec3(-0.9667985623287323, -0.7587600610602273, 0),\n    vec3(-0.9568225862250941, -0.7582711174764378, 0),\n    vec3(-0.9439892372553389, -0.753262942559604, 0),\n    vec3(-0.9341593028892199, -0.7444262874638897, 0),\n    vec3(-0.9057779755133633, -0.716040684503915, 0),\n    vec3(-0.8676659073229274, -0.6779228748148063, 0),\n    vec3(-0.8392845799470707, -0.6495372718548317, 0),\n    vec3(-0.8002203086336503, -0.6839369725150796, 0),\n    vec3(-0.7225862678499528, -0.7554325571804403, 0),\n    vec3(-0.6337196567903116, -0.81862813363668, 0),\n    vec3(-0.5336219413692815, -0.8735237018837979, 0),\n    vec3(-0.4231662187686904, -0.9197017434976917, 0),\n    vec3(-0.30758305535928576, -0.954655361350381, 0),\n    vec3(-0.18774379227941895, -0.9779624713047226, 0),\n    vec3(-0.0636480630504509, -0.9896183091384139, 0),\n    vec3(0.063636373908871, -0.9896183091384139, 0),\n    vec3(0.18772710986638663, -0.9779624713047226, 0),\n    vec3(0.30756412826459156, -0.954655361350381, 0),\n    vec3(0.42314669614620803, -0.9197017434976917, 0),\n    vec3(0.5336038541214676, -0.8735241828870115, 0),\n    vec3(0.6337043028623448, -0.8186312258001938, 0),\n    vec3(0.7225730975238751, -0.7554377107862971, 0),\n    vec3(0.8002084057128644, -0.6839403395375724, 0),\n    vec3(0.8392735245081369, -0.6495372718548317, 0),\n    vec3(0.8676591274681116, -0.6779228748148063, 0),\n    vec3(0.9057769371572204, -0.716040684503915, 0),\n    vec3(0.9341625401171949, -0.7444262874638897, 0),\n    vec3(0.9444085498977768, -0.7532612934057298, 0),\n    vec3(0.9572327369015647, -0.7582705677584798, 0),\n    vec3(0.9667908662773197, -0.7587578621883952, 0),\n    vec3(0.9734919281858232, -0.7576447444031384, 0),\n    vec3(0.9874499390179545, -0.7512397361549257, 0),\n    vec3(0.9986057930988654, -0.734497159546231, 0),\n    vec3(1, -0.7187961285899025, 0), vec3(1, -0.6869541548813245, 0),\n    vec3(1, -0.5989091793859186, 0), vec3(1, -0.45466120210368477, 0),\n    vec3(1, -0.366616226608279, 0), vec3(1, -0.33477425289970114, 0),\n    vec3(0.9993706340178174, -0.32288844781148707, 0),\n    vec3(0.9943401039040236, -0.3100470363116808, 0),\n    vec3(0.03913717002263395, 0.6458610024705548, 0),\n    vec3(0.014027397454390744, 0.6352444827862541, 0),\n    vec3(-0.014026481257793932, 0.6352439330682962, 0),\n    vec3(-0.039138819176507855, 0.6458593533166808, 0),\n    vec3(-0.0595099618666759, 0.6662257317845459, 0),\n    vec3(-0.07011035649087416, 0.6913399020964534, 0),\n    vec3(-0.07011035649087416, 0.7193793049024093, 0),\n    vec3(-0.05950996186667612, 0.7444890774706525, 0),\n    vec3(-0.03913167284305341, 0.7648594872035434, 0),\n    vec3(-0.01401823548842318, 0.7754609812636575, 0),\n    vec3(0.014020251120935967, 0.7754604315456995, 0),\n    vec3(0.03913332199692743, 0.7648578380496692, 0),\n    vec3(0.05949573027954003, 0.7444907266245265, 0),\n    vec3(0.070110173251555, 0.7193798546203674, 0),\n    vec3(0.07010852409768065, 0.6913415512503275, 0),\n    vec3(0.059495180561581984, 0.6662262815025038, 0),\n    vec3(-1, -0.7232079683206091, 0), vec3(-1, -0.3303624131689945, 0),\n    vec3(-0.9899614171289184, -0.3046795901693815, 0),\n    vec3(-0.9776868259236239, -0.7566777294351732, 0),\n    vec3(-0.9642903214457436, -0.7588981013474685, 0),\n    vec3(-0.9642903214457436, -0.29462146177090304, 0),\n    vec3(-0.9386192257625687, -0.7488868822147426, 0),\n    vec3(-0.8348246570737219, -0.6450766771039784, 0),\n    vec3(-0.6573590865202317, -0.4676189247614468, 0),\n    vec3(-0.5714291298722114, -0.29462146177090304, 0),\n    vec3(-0.5457580341890366, -0.3560491452740869, 0),\n    vec3(-0.5379515505466885, -0.31696199958563465, 0),\n    vec3(-0.4793618776215439, -0.8978589829289366, 0),\n    vec3(-0.44586475276862403, -0.6389589270287281, 0),\n    vec3(-0.42857868833874746, 0.06249486929905836, 0),\n    vec3(-0.42857868833874746, 0.20536094725443982, 0),\n    vec3(-0.40736788200756036, 0.012274591205294559, 0),\n    vec3(-0.40736788200756036, 0.2555812253482037, 0),\n    vec3(-0.35713587659735835, -0.008928396914933825, 0),\n    vec3(-0.35713587659735835, 0.2767842134684321, 0),\n    vec3(-0.28571261038336604, 0.7053629018071795, 0),\n    vec3(-0.2466450102223109, 0.5619339126627655, 0),\n    vec3(-0.20201475296407934, 0.9073581092438618, 0),\n    vec3(-0.14285435063894347, -0.7310535430177514, 0),\n    vec3(-0.14285435063894347, -0.008928396914933825, 0),\n    vec3(-0.14285435063894347, 0.2767842134684321, 0),\n    vec3(-0.14285435063894347, 0.45869834605747184, 0),\n    vec3(-0.07143499353043048, 0.7053629018071796, 0),\n    vec3(-0.05023200541020201, 0.7555831799009435, 0),\n    vec3(-0.05023200541020201, 0.6551426237134158, 0),\n    vec3(-0.000003909105479427133, -0.9910755121905456, 0),\n    vec3(0, 0.7767861680211718, 0), vec3(0, 0.633916180960311, 0),\n    vec3(0.000015636421917486487, 0.9910755121905456, 0),\n    vec3(0.050220278093763726, 0.6551426237134157, 0),\n    vec3(0.050220278093763726, 0.7555831799009435, 0),\n    vec3(0.0714389026359099, 0.7053629018071796, 0),\n    vec3(0.14284653242798395, 0.45869834605747195, 0),\n    vec3(0.14284653242798395, 0.27678421346843224, 0),\n    vec3(0.14284653242798417, -0.008928396914933825, 0),\n    vec3(0.14284653242798417, -0.7310535430177512, 0),\n    vec3(0.2020186620695581, 0.907358109243862, 0),\n    vec3(0.24664501022231033, 0.5619339126627655, 0),\n    vec3(0.2857204285943242, 0.7053629018071796, 0),\n    vec3(0.35712805838639916, 0.27678421346843224, 0),\n    vec3(0.35712805838639916, -0.008928396914933825, 0),\n    vec3(0.40737570021851854, 0.2555812253482038, 0),\n    vec3(0.40737570021851854, 0.012274591205294668, 0),\n    vec3(0.428578688338747, 0.20536094725443993, 0),\n    vec3(0.428578688338747, 0.062494869299058474, 0),\n    vec3(0.4458647527686237, -0.6389745634506454, 0),\n    vec3(0.4793423320941468, -0.8978589829289366, 0),\n    vec3(0.5379437323357295, -0.31697372690207304, 0),\n    vec3(0.5457423977671187, -0.3560491452740869, 0),\n    vec3(0.5714252207667319, -0.29464882550925875, 0),\n    vec3(0.6573512683092726, -0.46764628849980255, 0),\n    vec3(0.8348129297572837, -0.6450766771039784, 0),\n    vec3(0.938623134868048, -0.7488868822147426, 0),\n    vec3(0.9642825032347848, -0.7588981013474685, 0),\n    vec3(0.9642864123402641, -0.29464882550925875, 0),\n    vec3(0.9776868259236238, -0.7566777294351732, 0),\n    vec3(0.9899418716015214, -0.3046795901693815, 0),\n    vec3(1, -0.3303624131689945, 0), vec3(1, -0.7232079683206091, 0));\nconst ivec3 triangles1[268] = ivec3[268](\n    ivec3(0, 265, 1), ivec3(1, 186, 266), ivec3(1, 265, 186),\n    ivec3(1, 266, 263), ivec3(2, 184, 3), ivec3(2, 185, 184),\n    ivec3(2, 263, 185), ivec3(3, 183, 4), ivec3(3, 184, 183),\n    ivec3(4, 183, 259), ivec3(4, 259, 5), ivec3(5, 13, 6), ivec3(5, 14, 13),\n    ivec3(5, 15, 14), ivec3(5, 259, 15), ivec3(6, 12, 7), ivec3(6, 13, 12),\n    ivec3(7, 12, 257), ivec3(7, 257, 258), ivec3(8, 256, 9), ivec3(8, 258, 256),\n    ivec3(10, 256, 11), ivec3(11, 256, 257), ivec3(16, 169, 17),\n    ivec3(16, 259, 260), ivec3(16, 260, 169), ivec3(17, 168, 18),\n    ivec3(17, 169, 168), ivec3(18, 167, 19), ivec3(18, 168, 167),\n    ivec3(19, 166, 254), ivec3(19, 167, 166), ivec3(20, 166, 255),\n    ivec3(20, 254, 166), ivec3(20, 255, 21), ivec3(21, 165, 22),\n    ivec3(21, 255, 165), ivec3(22, 164, 23), ivec3(22, 165, 164),\n    ivec3(23, 163, 244), ivec3(23, 164, 163), ivec3(24, 110, 25),\n    ivec3(24, 111, 110), ivec3(24, 244, 111), ivec3(25, 109, 26),\n    ivec3(25, 110, 109), ivec3(26, 108, 27), ivec3(26, 109, 108),\n    ivec3(27, 107, 28), ivec3(27, 108, 107), ivec3(28, 106, 29),\n    ivec3(28, 107, 106), ivec3(29, 105, 30), ivec3(29, 106, 105),\n    ivec3(30, 104, 31), ivec3(30, 105, 104), ivec3(31, 104, 228),\n    ivec3(31, 228, 243), ivec3(32, 50, 33), ivec3(32, 51, 50),\n    ivec3(32, 243, 51), ivec3(33, 49, 34), ivec3(33, 50, 49), ivec3(34, 41, 35),\n    ivec3(34, 49, 41), ivec3(35, 40, 249), ivec3(35, 41, 40),\n    ivec3(36, 249, 37), ivec3(37, 249, 251), ivec3(38, 251, 253),\n    ivec3(38, 253, 39), ivec3(40, 253, 249), ivec3(41, 49, 42),\n    ivec3(42, 48, 43), ivec3(42, 49, 48), ivec3(43, 48, 248),\n    ivec3(43, 248, 252), ivec3(44, 252, 45), ivec3(45, 252, 250),\n    ivec3(46, 248, 47), ivec3(46, 250, 248), ivec3(51, 243, 242),\n    ivec3(52, 82, 53), ivec3(52, 83, 82), ivec3(52, 242, 83), ivec3(53, 81, 54),\n    ivec3(53, 82, 81), ivec3(54, 80, 55), ivec3(54, 81, 80), ivec3(55, 80, 230),\n    ivec3(55, 230, 241), ivec3(56, 188, 238), ivec3(56, 238, 57),\n    ivec3(56, 241, 188), ivec3(57, 203, 246), ivec3(57, 238, 203),\n    ivec3(58, 202, 59), ivec3(58, 203, 202), ivec3(58, 246, 203),\n    ivec3(59, 202, 240), ivec3(59, 240, 247), ivec3(60, 201, 61),\n    ivec3(60, 240, 201), ivec3(60, 247, 240), ivec3(61, 201, 62),\n    ivec3(62, 200, 63), ivec3(62, 201, 200), ivec3(63, 200, 239),\n    ivec3(63, 239, 245), ivec3(64, 199, 65), ivec3(64, 239, 199),\n    ivec3(64, 245, 239), ivec3(65, 198, 66), ivec3(65, 199, 198),\n    ivec3(66, 198, 67), ivec3(67, 198, 235), ivec3(67, 235, 237),\n    ivec3(68, 197, 69), ivec3(68, 235, 197), ivec3(68, 237, 235),\n    ivec3(69, 197, 70), ivec3(70, 196, 71), ivec3(70, 197, 196),\n    ivec3(71, 196, 232), ivec3(71, 232, 226), ivec3(72, 195, 73),\n    ivec3(72, 226, 232), ivec3(72, 232, 195), ivec3(73, 194, 74),\n    ivec3(73, 195, 194), ivec3(74, 194, 75), ivec3(75, 194, 231),\n    ivec3(75, 231, 224), ivec3(76, 193, 77), ivec3(76, 224, 231),\n    ivec3(76, 231, 193), ivec3(77, 192, 225), ivec3(77, 193, 192),\n    ivec3(78, 192, 233), ivec3(78, 225, 192), ivec3(78, 233, 79),\n    ivec3(79, 191, 230), ivec3(79, 233, 191), ivec3(83, 242, 229),\n    ivec3(84, 102, 85), ivec3(84, 103, 102), ivec3(84, 229, 103),\n    ivec3(85, 101, 86), ivec3(85, 102, 101), ivec3(86, 93, 87),\n    ivec3(86, 101, 93), ivec3(87, 92, 223), ivec3(87, 93, 92),\n    ivec3(88, 223, 89), ivec3(89, 223, 221), ivec3(90, 219, 91),\n    ivec3(90, 221, 219), ivec3(92, 219, 223), ivec3(93, 101, 94),\n    ivec3(94, 100, 95), ivec3(94, 101, 100), ivec3(95, 100, 222),\n    ivec3(95, 222, 218), ivec3(96, 218, 97), ivec3(97, 218, 220),\n    ivec3(98, 220, 222), ivec3(98, 222, 99), ivec3(103, 229, 228),\n    ivec3(111, 244, 227), ivec3(112, 159, 113), ivec3(112, 160, 159),\n    ivec3(112, 227, 160), ivec3(113, 158, 114), ivec3(113, 159, 158),\n    ivec3(114, 158, 216), ivec3(114, 216, 115), ivec3(115, 157, 217),\n    ivec3(115, 216, 157), ivec3(116, 156, 117), ivec3(116, 157, 156),\n    ivec3(116, 217, 157), ivec3(117, 155, 118), ivec3(117, 156, 155),\n    ivec3(118, 154, 119), ivec3(118, 155, 154), ivec3(119, 154, 211),\n    ivec3(119, 211, 212), ivec3(120, 130, 121), ivec3(120, 212, 130),\n    ivec3(121, 130, 122), ivec3(122, 129, 123), ivec3(122, 130, 129),\n    ivec3(123, 128, 214), ivec3(123, 129, 128), ivec3(124, 214, 215),\n    ivec3(124, 215, 125), ivec3(126, 215, 127), ivec3(127, 215, 213),\n    ivec3(128, 213, 214), ivec3(130, 212, 131), ivec3(131, 139, 132),\n    ivec3(131, 140, 139), ivec3(131, 212, 140), ivec3(132, 138, 133),\n    ivec3(132, 139, 138), ivec3(133, 138, 205), ivec3(133, 205, 209),\n    ivec3(134, 137, 206), ivec3(134, 206, 135), ivec3(134, 209, 137),\n    ivec3(136, 206, 137), ivec3(137, 209, 205), ivec3(140, 211, 141),\n    ivec3(140, 212, 211), ivec3(141, 152, 142), ivec3(141, 153, 152),\n    ivec3(141, 211, 153), ivec3(142, 150, 143), ivec3(142, 151, 150),\n    ivec3(142, 152, 151), ivec3(143, 150, 210), ivec3(143, 210, 204),\n    ivec3(144, 146, 145), ivec3(144, 204, 146), ivec3(145, 146, 207),\n    ivec3(146, 204, 147), ivec3(147, 204, 210), ivec3(147, 210, 208),\n    ivec3(148, 208, 210), ivec3(148, 210, 149), ivec3(160, 227, 161),\n    ivec3(161, 227, 234), ivec3(162, 234, 244), ivec3(162, 244, 163),\n    ivec3(170, 182, 171), ivec3(170, 260, 182), ivec3(171, 181, 172),\n    ivec3(171, 182, 181), ivec3(172, 181, 173), ivec3(173, 180, 261),\n    ivec3(173, 181, 180), ivec3(174, 261, 267), ivec3(174, 267, 175),\n    ivec3(175, 176, 262), ivec3(175, 267, 176), ivec3(176, 267, 177),\n    ivec3(177, 178, 264), ivec3(177, 179, 178), ivec3(177, 267, 179),\n    ivec3(180, 267, 261), ivec3(182, 260, 183), ivec3(183, 260, 259),\n    ivec3(185, 263, 266), ivec3(186, 265, 187), ivec3(188, 241, 189),\n    ivec3(189, 241, 236), ivec3(190, 230, 191), ivec3(190, 236, 230),\n    ivec3(213, 215, 214), ivec3(218, 222, 220), ivec3(219, 221, 223),\n    ivec3(227, 244, 234), ivec3(228, 229, 242), ivec3(228, 242, 243),\n    ivec3(230, 236, 241), ivec3(248, 250, 252), ivec3(249, 253, 251),\n    ivec3(256, 258, 257));\nconst int len1 = 268;\n\nbool inPath1(vec2 p) {\n  for (int i = 0; i < len1; i++) {\n    ivec3 triangle = triangles1[i];\n    vec3 a = positions1[triangle[0]];\n    vec3 b = positions1[triangle[1]];\n    vec3 c = positions1[triangle[2]];\n\n    if (pointInTriangle(vec3(p, 0.0), a, b, c)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nbool resolutionChanged() {\n  return iResolution.xy !=\n         texelFetch(iChannel0, ivec2(iResolution.xy - vec2(1.0)), 0).xy;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  const float numSamp = 2.0;\n  fragColor = vec4(0.0);\n\n  if (iFrame == 0 || resolutionChanged()) {\n    for (float i = 0.0; i < numSamp; i++) {\n      for (float j = 0.0; j < numSamp; j++) {\n        vec2 uv = (fragCoord + vec2(i * 0.5, j * 0.5)) / iResolution.xy;\n\n        // Normalized pixel coordinates (from 0 to 1)\n        uv.x *= iResolution.x / iResolution.y;\n        float which = uv.x / size;\n        uv = mod(uv, size);\n        uv *= 1.0 / size * 2.0;\n        uv -= vec2(1);\n        uv *= 1.2;\n\n        if (which < 1.0) {\n          if (inPath0(uv)) {\n            fragColor += vec4(1.0);\n          }\n        } else if (which < 2.0) {\n          if (inPath1(uv)) {\n            fragColor += vec4(1.0);\n          }\n        }\n      }\n    }\n\n    fragColor = fragColor / 4.0;\n  } else {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n  }\n\n  if (ivec2(fragCoord) == ivec2(iResolution.xy - vec2(1))) {\n    fragColor = vec4(iResolution, 1.0);\n  }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "const vec3 positions0[186] = vec3[186](\n    vec3(0.9124089643239914, -0.26998680249925866, 0),\n    vec3(0.873668313741363, -0.21952474745171346, 0),\n    vec3(0.8424700668996421, -0.19826803735633813, 0),\n    vec3(0.8143961965258933, -0.18201532766429884, 0),\n    vec3(0.7367702537454678, -0.13707560628691295, 0),\n    vec3(0.6095922385583654, -0.06344887322418069, 0),\n    vec3(0.5319662957779399, -0.018509151846794802, 0),\n    vec3(0.5038924254041914, -0.0022564421547555114, 0),\n    vec3(0.5038924254041914, 0.0022474232093585567, 0),\n    vec3(0.5319662957779399, 0.018500872232230403, 0),\n    vec3(0.6095922385583654, 0.06344263790390636, 0),\n    vec3(0.7367702537454678, 0.1370727202243861, 0),\n    vec3(0.8143961965258933, 0.18201448589606217, 0),\n    vec3(0.8424700668996421, 0.1982679349189339, 0),\n    vec3(0.873670237783048, 0.21952139819396643, 0),\n    vec3(0.9124147364490457, 0.26997333420746605, 0),\n    vec3(0.9294174928169111, 0.3345129609148748, 0),\n    vec3(0.9212768011880602, 0.3979890913962558, 0),\n    vec3(0.9039792210624132, 0.43453533680706, 0),\n    vec3(0.8811941137151392, 0.4736981363874764, 0),\n    vec3(0.8505969695630856, 0.5262881815383214, 0),\n    vec3(0.8278118622158118, 0.5654509811187377, 0),\n    vec3(0.8052336427952478, 0.5989122038401022, 0),\n    vec3(0.7547824193897792, 0.6376517142498803, 0),\n    vec3(0.6902422938567487, 0.6546495536223293, 0),\n    vec3(0.6267832659681205, 0.646498885481039, 0),\n    vec3(0.5924894498380953, 0.6305406098392642, 0),\n    vec3(0.5644155794643466, 0.614394733452529, 0),\n    vec3(0.48678963668392133, 0.5697504126000503, 0),\n    vec3(0.3596116214968189, 0.49660764728182805, 0),\n    vec3(0.28198567871639335, 0.45196332642934944, 0),\n    vec3(0.2539118083426444, 0.4358174500426141, 0),\n    vec3(0.2500220552185709, 0.4380696900368848, 0),\n    vec3(0.2500220552185709, 0.47047086377357317, 0),\n    vec3(0.2500220552185709, 0.5600620610334528, 0),\n    vec3(0.2500220552185709, 0.7068432818165234, 0),\n    vec3(0.2500220552185709, 0.7964344790764031, 0),\n    vec3(0.2500220552185709, 0.8288356528130916, 0),\n    vec3(0.2469262008870543, 0.8660440847832532, 0),\n    vec3(0.2221696277905729, 0.9246412731170046, 0),\n    vec3(0.17464002605294968, 0.9721687370305339, 0),\n    vec3(0.11604583067293023, 0.9969077799694434, 0),\n    vec3(0.07617270340683661, 1, 0), vec3(0.03060498284039854, 1, 0),\n    vec3(-0.030585956205960798, 1, 0), vec3(-0.07615367677239857, 1, 0),\n    vec3(-0.1160353553348686, 0.9969058559277586, 0),\n    vec3(-0.1746312609741637, 0.9721629649054797, 0),\n    vec3(-0.22215687210681118, 0.9246431971586893, 0),\n    vec3(-0.2469003332155153, 0.8660447261304814, 0),\n    vec3(-0.2499939072013316, 0.8288356528130916, 0),\n    vec3(-0.2499939072013316, 0.7964344790764031, 0),\n    vec3(-0.2499939072013316, 0.7068432818165234, 0),\n    vec3(-0.2499939072013316, 0.5600620610334528, 0),\n    vec3(-0.2499939072013316, 0.47047086377357317, 0),\n    vec3(-0.2499939072013316, 0.4380696900368848, 0),\n    vec3(-0.25388371154410755, 0.4358176036987209, 0),\n    vec3(-0.2819579515832725, 0.4519645890817049, 0),\n    vec3(-0.35958491651084296, 0.4966119763756187, 0),\n    vec3(-0.4867646063268189, 0.569759765580462, 0),\n    vec3(-0.5643915712543895, 0.6144071528743758, 0),\n    vec3(-0.5924658112935544, 0.6305541382573598, 0),\n    vec3(-0.6267554742548969, 0.6465151329441545, 0),\n    vec3(-0.6902334575171594, 0.6546709318632706, 0),\n    vec3(-0.7547675258819235, 0.6376596241990287, 0),\n    vec3(-0.8052270155405558, 0.59892396187262, 0),\n    vec3(-0.8278110783469772, 0.5654644672257315, 0),\n    vec3(-0.8505961856942511, 0.5263004205812603, 0),\n    vec3(-0.8811933298463045, 0.4737087008015416, 0),\n    vec3(-0.9039784371935783, 0.4345446541570702, 0),\n    vec3(-0.9212791527945635, 0.39799821277905745, 0),\n    vec3(-0.9294192743369892, 0.3345220822976763, 0),\n    vec3(-0.9124024795909058, 0.2699875863680935, 0),\n    vec3(-0.8736680999589536, 0.21953051957676795, 0),\n    vec3(-0.8424737925035058, 0.19827685142692641, 0),\n    vec3(-0.8143995524643409, 0.18202192374238935, 0),\n    vec3(-0.7367725875367704, 0.13707606948213347, 0),\n    vec3(-0.6095928977207943, 0.06343928864615878, 0),\n    vec3(-0.5319659327932238, 0.018493434385902896, 0),\n    vec3(-0.503891692754059, 0.00223850670136605, 0),\n    vec3(-0.503891692754059, -0.002265563537557247, 0),\n    vec3(-0.5319659327932238, -0.018518273229596538, 0),\n    vec3(-0.6095928977207943, -0.06345799460698243, 0),\n    vec3(-0.7367725875367704, -0.1370847276697147, 0),\n    vec3(-0.8143995524643409, -0.18202444904710013, 0),\n    vec3(-0.8424737925035058, -0.19827715873913987, 0),\n    vec3(-0.8736706653478666, -0.21953130344560234, 0),\n    vec3(-0.9124101757576447, -0.2699882277153216, 0),\n    vec3(-0.9294147849063916, -0.3345223673408888, 0),\n    vec3(-0.9212708152805963, -0.3979791148838163, 0),\n    vec3(-0.9039782412263697, -0.43452243860169193, 0),\n    vec3(-0.881191886815041, -0.4736902264383278, 0),\n    vec3(-0.8505930680341138, -0.526286970104668, 0),\n    vec3(-0.827806713622785, -0.5654547579413038, 0),\n    vec3(-0.8052296521902719, -0.5989261709575169, 0),\n    vec3(-0.7547777161767723, -0.6376742326636715, 0),\n    vec3(-0.6902303220418213, -0.6546747799466397, 0),\n    vec3(-0.6267574695573846, -0.6465192660707364, 0),\n    vec3(-0.5924703719849552, -0.6305540870386575, 0),\n    vec3(-0.5643961319457903, -0.6144067319902573, 0),\n    vec3(-0.4867691670182199, -0.5697583225491987, 0),\n    vec3(-0.35958947720224377, -0.49660885871548155, 0),\n    vec3(-0.28196251227467317, -0.4519604492744227, 0),\n    vec3(-0.25388827223550825, -0.4358130942260221, 0),\n    vec3(-0.2499984678927324, -0.4380653854389951, 0),\n    vec3(-0.2499984678927324, -0.47046840750276475, 0),\n    vec3(-0.2499984678927324, -0.5600647154983696, 0),\n    vec3(-0.2499984678927324, -0.7068543094258091, 0),\n    vec3(-0.2499984678927324, -0.7964506174214137, 0),\n    vec3(-0.2499984678927324, -0.8288536394851835, 0),\n    vec3(-0.24690553525414438, -0.8660480041274257, 0),\n    vec3(-0.22216335683989677, -0.9246524610630973, 0),\n    vec3(-0.17463389762387965, -0.9721745091555878, 0),\n    vec3(-0.11603414390121525, -0.9969091339247029, 0),\n    vec3(-0.07615823746379956, -1, 0), vec3(-0.030590516897361475, -1, 0),\n    vec3(0.030600422148997757, -1, 0), vec3(0.07616814271543562, -1, 0),\n    vec3(0.1160431227624109, -0.9969097752719311, 0),\n    vec3(0.17463931344491831, -0.9721764331972726, 0),\n    vec3(0.2221682025745102, -0.924649895674184, 0),\n    vec3(0.24691964489316576, -0.8660454387385126, 0),\n    vec3(0.25001293383576956, -0.8288539980160989, 0),\n    vec3(0.25001293383576956, -0.796453563610243, 0),\n    vec3(0.25001293383576956, -0.7068644106446533, 0),\n    vec3(0.25001293383576956, -0.5600865391193306, 0),\n    vec3(0.25001293383576956, -0.4704973861537409, 0),\n    vec3(0.25001293383576956, -0.438096951747885, 0),\n    vec3(0.253902686959843, -0.4358450190658276, 0),\n    vec3(0.281976557333592, -0.4519923741142282, 0),\n    vec3(0.35960250011401734, -0.49664078355528707, 0),\n    vec3(0.48678051530111976, -0.569790247389004, 0),\n    vec3(0.5644064580815452, -0.6144386568300628, 0),\n    vec3(0.5924803284552936, -0.630586011878463, 0),\n    vec3(0.6267741445853192, -0.646537865140355, 0),\n    vec3(0.6902331724739469, -0.6546906711057392, 0),\n    vec3(0.7547656018402386, -0.6376770830957972, 0),\n    vec3(0.805221956023533, -0.5989415632909945, 0),\n    vec3(0.8278027408330099, -0.5654735886085327, 0),\n    vec3(0.8505878481802841, -0.5263095419640613, 0),\n    vec3(0.8811849923323375, -0.47371782218434255, 0),\n    vec3(0.9039700996796115, -0.4345537755398712, 0),\n    vec3(0.9212735944519189, -0.3979930820012312, 0),\n    vec3(0.9294192743369892, -0.3345158113469999, 0),\n    vec3(-0.9238451830547509, -0.3014480195197591, 0),\n    vec3(-0.9238451830547509, 0.3014388981369577, 0),\n    vec3(-0.9075589540624356, -0.4283675005130776, 0),\n    vec3(-0.9075589540624356, 0.42839030397008193, 0),\n    vec3(-0.8463635968462817, -0.20052904020249462, 0),\n    vec3(-0.8463635968462817, 0.20052904020249473, 0),\n    vec3(-0.8242305614781198, 0.5716188174127199, 0),\n    vec3(-0.824226000786719, -0.571609696029918, 0),\n    vec3(-0.7233161428522562, -0.6491186463867922, 0),\n    vec3(-0.7233115821608554, 0.649100403621189, 0),\n    vec3(-0.5963601763277311, -0.6327913711718696, 0),\n    vec3(-0.5963556156363302, 0.6327913711718698, 0),\n    vec3(-0.500001888411283, -0.000013682074202492345, 0),\n    vec3(-0.2499984678927324, -0.8333432148313684, 0),\n    vec3(-0.2499984678927324, -0.4335758100928102, 0),\n    vec3(-0.2499939072013316, 0.43358037078421097, 0),\n    vec3(-0.2499939072013316, 0.8333249720657652, 0),\n    vec3(-0.20051496619387488, -0.950525619683944, 0),\n    vec3(-0.2005104055024741, 0.9505210589925432, 0),\n    vec3(-0.08331887926709682, -1, 0), vec3(-0.08331431857569603, 1, 0),\n    vec3(0.0833287845187331, -1, 0), vec3(0.08333334521013387, 1, 0),\n    vec3(0.20050662867990773, -0.950525619683944, 0),\n    vec3(0.20051575006270927, 0.9505210589925434, 0),\n    vec3(0.25001293383576956, -0.43360773493261573, 0),\n    vec3(0.25001293383576956, -0.8333432148313684, 0),\n    vec3(0.2500220552185709, 0.8333249720657653, 0),\n    vec3(0.2500220552185709, 0.43358037078421097, 0),\n    vec3(0.5000026722801179, -0.000004560691400756767, 0),\n    vec3(0.5963700815793676, -0.6328232960116751, 0),\n    vec3(0.5963792029621688, 0.6327776890976673, 0),\n    vec3(0.7233078053382891, -0.649118646386792, 0),\n    vec3(0.7233169267210908, 0.6490867215469867, 0),\n    vec3(0.8242222239641529, -0.5716279387955212, 0),\n    vec3(0.8242313453469544, 0.5716051353385174, 0),\n    vec3(0.8463598200237156, 0.20051991881969322, 0),\n    vec3(0.8463598200237156, -0.2005199188196929, 0),\n    vec3(0.9075506165484686, -0.4283994253528831, 0),\n    vec3(0.9075597379312703, 0.4283811825872803, 0),\n    vec3(0.9238505276149864, -0.30143889813695735, 0),\n    vec3(0.9238505276149864, 0.30142977675415605, 0));\nconst ivec3 triangles0[184] = ivec3[184](\n    ivec3(0, 181, 1), ivec3(0, 184, 181), ivec3(2, 141, 3), ivec3(2, 181, 182),\n    ivec3(2, 182, 141), ivec3(3, 140, 4), ivec3(3, 141, 140), ivec3(4, 131, 5),\n    ivec3(4, 139, 131), ivec3(4, 140, 139), ivec3(5, 129, 6),\n    ivec3(5, 130, 129), ivec3(5, 131, 130), ivec3(6, 128, 7),\n    ivec3(6, 129, 128), ivec3(7, 128, 169), ivec3(7, 169, 173), ivec3(8, 31, 9),\n    ivec3(8, 172, 31), ivec3(8, 173, 172), ivec3(9, 30, 10), ivec3(9, 31, 30),\n    ivec3(10, 28, 11), ivec3(10, 29, 28), ivec3(10, 30, 29), ivec3(11, 19, 12),\n    ivec3(11, 20, 19), ivec3(11, 28, 20), ivec3(12, 18, 13), ivec3(12, 19, 18),\n    ivec3(13, 18, 183), ivec3(13, 183, 180), ivec3(14, 180, 15),\n    ivec3(15, 180, 185), ivec3(16, 183, 17), ivec3(16, 185, 183),\n    ivec3(20, 27, 21), ivec3(20, 28, 27), ivec3(21, 26, 179), ivec3(21, 27, 26),\n    ivec3(22, 179, 23), ivec3(23, 179, 177), ivec3(24, 175, 25),\n    ivec3(24, 177, 175), ivec3(26, 175, 179), ivec3(32, 54, 33),\n    ivec3(32, 55, 54), ivec3(32, 172, 55), ivec3(33, 53, 34), ivec3(33, 54, 53),\n    ivec3(34, 53, 35), ivec3(35, 43, 36), ivec3(35, 52, 43), ivec3(35, 53, 52),\n    ivec3(36, 42, 37), ivec3(36, 43, 42), ivec3(37, 42, 166),\n    ivec3(37, 166, 168), ivec3(37, 168, 171), ivec3(38, 171, 39),\n    ivec3(39, 171, 168), ivec3(40, 166, 41), ivec3(40, 168, 166),\n    ivec3(43, 52, 44), ivec3(44, 51, 45), ivec3(44, 52, 51), ivec3(45, 50, 164),\n    ivec3(45, 51, 50), ivec3(46, 164, 47), ivec3(47, 164, 162),\n    ivec3(48, 160, 49), ivec3(48, 162, 160), ivec3(50, 160, 162),\n    ivec3(50, 162, 164), ivec3(55, 172, 159), ivec3(56, 78, 57),\n    ivec3(56, 79, 78), ivec3(56, 159, 79), ivec3(57, 77, 58), ivec3(57, 78, 77),\n    ivec3(58, 77, 59), ivec3(59, 67, 60), ivec3(59, 76, 67), ivec3(59, 77, 76),\n    ivec3(60, 66, 61), ivec3(60, 67, 66), ivec3(61, 66, 150),\n    ivec3(61, 150, 155), ivec3(62, 155, 63), ivec3(63, 155, 153),\n    ivec3(64, 150, 65), ivec3(64, 153, 150), ivec3(67, 76, 68),\n    ivec3(68, 75, 69), ivec3(68, 76, 75), ivec3(69, 74, 147), ivec3(69, 75, 74),\n    ivec3(70, 147, 71), ivec3(71, 147, 145), ivec3(72, 145, 149),\n    ivec3(72, 149, 73), ivec3(74, 149, 147), ivec3(79, 159, 156),\n    ivec3(80, 103, 81), ivec3(80, 156, 158), ivec3(80, 158, 103),\n    ivec3(81, 102, 82), ivec3(81, 103, 102), ivec3(82, 100, 83),\n    ivec3(82, 101, 100), ivec3(82, 102, 101), ivec3(83, 91, 84),\n    ivec3(83, 92, 91), ivec3(83, 100, 92), ivec3(84, 90, 85), ivec3(84, 91, 90),\n    ivec3(85, 90, 146), ivec3(85, 146, 148), ivec3(86, 148, 87),\n    ivec3(87, 148, 144), ivec3(88, 144, 146), ivec3(88, 146, 89),\n    ivec3(92, 99, 93), ivec3(92, 100, 99), ivec3(93, 98, 151),\n    ivec3(93, 99, 98), ivec3(94, 151, 95), ivec3(95, 151, 152),\n    ivec3(96, 152, 154), ivec3(96, 154, 97), ivec3(98, 154, 151),\n    ivec3(104, 127, 105), ivec3(104, 158, 169), ivec3(104, 169, 127),\n    ivec3(105, 126, 106), ivec3(105, 127, 126), ivec3(106, 125, 107),\n    ivec3(106, 126, 125), ivec3(107, 115, 108), ivec3(107, 116, 115),\n    ivec3(107, 124, 116), ivec3(107, 125, 124), ivec3(108, 114, 109),\n    ivec3(108, 115, 114), ivec3(109, 114, 163), ivec3(109, 161, 157),\n    ivec3(109, 163, 161), ivec3(110, 157, 111), ivec3(111, 157, 161),\n    ivec3(112, 161, 163), ivec3(112, 163, 113), ivec3(116, 123, 117),\n    ivec3(116, 124, 123), ivec3(117, 122, 165), ivec3(117, 123, 122),\n    ivec3(118, 165, 119), ivec3(119, 165, 167), ivec3(120, 167, 170),\n    ivec3(120, 170, 121), ivec3(122, 167, 165), ivec3(122, 170, 167),\n    ivec3(131, 139, 132), ivec3(132, 138, 133), ivec3(132, 139, 138),\n    ivec3(133, 138, 178), ivec3(133, 178, 174), ivec3(134, 174, 135),\n    ivec3(135, 174, 176), ivec3(136, 176, 178), ivec3(136, 178, 137),\n    ivec3(142, 182, 143), ivec3(143, 182, 184), ivec3(144, 148, 146),\n    ivec3(145, 147, 149), ivec3(150, 153, 155), ivec3(151, 154, 152),\n    ivec3(156, 159, 173), ivec3(156, 173, 158), ivec3(158, 173, 169),\n    ivec3(159, 172, 173), ivec3(174, 178, 176), ivec3(175, 177, 179),\n    ivec3(180, 183, 185), ivec3(181, 184, 182));\nconst int len0 = 184;\n\nbool inPath0(vec2 p) {\n  for (int i = 0; i < len0; i++) {\n    ivec3 triangle = triangles0[i];\n    vec3 a = positions0[triangle[0]];\n    vec3 b = positions0[triangle[1]];\n    vec3 c = positions0[triangle[2]];\n\n    if (pointInTriangle(vec3(p, 0.0), a, b, c)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nconst vec3 positions1[321] =\n    vec3[321](vec3(0.9657412033737427, -0.43916659539760994, 0),\n              vec3(0.9198799442919954, -0.40316673945621473, 0),\n              vec3(0.7930708002045141, -0.30362496911223574, 0),\n              vec3(0.585313771111299, -0.14054128436567337, 0),\n              vec3(0.458504627023818, -0.04099951402169475, 0),\n              vec3(0.4126433679420707, -0.004999658080299172, 0),\n              vec3(0.41264323625097776, 0.0049770835549257575, 0),\n              vec3(0.45850354486657374, 0.04098327593732904, 0),\n              vec3(0.5853100608578896, 0.1405425669224075, 0),\n              vec3(0.7930627842249265, 0.3036549565101614, 0),\n              vec3(0.9198693002162424, 0.40321424749524015, 0),\n              vec3(0.9657296088318383, 0.4392204398776434, 0),\n              vec3(0.9855413714917376, 0.45647244641570517, 0),\n              vec3(0.9994918021626464, 0.48771210830703016, 0),\n              vec3(0.9954435645167932, 0.5248915958046118, 0),\n              vec3(0.9758958119617616, 0.5533501861033717, 0),\n              vec3(0.9385812895623185, 0.5747646083736869, 0),\n              vec3(0.8403753096911684, 0.623863567416669, 0),\n              vec3(0.8105930597686897, 0.6384414126270725, 0),\n              vec3(0.7944173320899912, 0.6423478361426128, 0),\n              vec3(0.776433443712736, 0.642278394856581, 0),\n              vec3(0.7591376164862589, 0.6378197390558163, 0),\n              vec3(0.7424708947892562, 0.6290697972909538, 0),\n              vec3(0.6800575845070809, 0.5940628616554718, 0),\n              vec3(0.5074810217388979, 0.49726657577181993, 0),\n              vec3(0.22474120648470608, 0.3386809396399981, 0),\n              vec3(0.05216464371652263, 0.24188465375634624, 0),\n              vec3(-0.010248666565652598, 0.20687771812086425, 0),\n              vec3(-0.038076624481683474, 0.21353494718032467, 0),\n              vec3(-0.12247007906790497, 0.2641683326703291, 0),\n              vec3(-0.14583820168903183, 0.277694603507033, 0),\n              vec3(-0.15253546865796852, 0.28048166036435707, 0),\n              vec3(-0.1484852155658185, 0.3085193888319425, 0),\n              vec3(-0.14290572732771323, 0.36264621456910784, 0),\n              vec3(-0.15071649783836727, 0.4320460923406875, 0),\n              vec3(-0.18196104566010785, 0.5146302868940089, 0),\n              vec3(-0.23607828275883236, 0.5929512017890597, 0),\n              vec3(-0.30972916428851327, 0.6615854542645134, 0),\n              vec3(-0.4282331924041418, 0.7329402538695089, 0),\n              vec3(-0.5827912950202464, 0.7798078084916821, 0),\n              vec3(-0.7356067694794937, 0.7801537323651072, 0),\n              vec3(-0.8594806183442678, 0.7360667607424575, 0),\n              vec3(-0.9329572553805021, 0.6746945277178544, 0),\n              vec3(-0.968390267051024, 0.622806557445382, 0),\n              vec3(-0.9910579915470733, 0.5632321635913328, 0),\n              vec3(-0.9997027903796718, 0.5001795980226715, 0),\n              vec3(-0.9918609331367485, 0.4255556834507218, 0),\n              vec3(-0.9606168739080495, 0.3435246983687079, 0),\n              vec3(-0.9065703606520908, 0.26519370624217486, 0),\n              vec3(-0.8334737879280607, 0.19599928184457144, 0),\n              vec3(-0.715391293459039, 0.12416016438712865, 0),\n              vec3(-0.5602717974381807, 0.07728723524149839, 0),\n              vec3(-0.4345179646977403, 0.07358931880644413, 0),\n              vec3(-0.35026498061096756, 0.09088331380901536, 0),\n              vec3(-0.30598446506972954, 0.09904544379068186, 0),\n              vec3(-0.2937069769731251, 0.08676429124626572, 0),\n              vec3(-0.26545732127376276, 0.06873368115941132, 0),\n              vec3(-0.17185193348195082, 0.012728459473964976, 0),\n              vec3(-0.17185193348195082, -0.01272479502615346, 0),\n              vec3(-0.26545732127376276, -0.0687138931412284, 0),\n              vec3(-0.2937047783044381, -0.08675238179087799, 0),\n              vec3(-0.3059778690636684, -0.0990302363322633, 0),\n              vec3(-0.35026498061096756, -0.0908648083475663, 0),\n              vec3(-0.4345179646977403, -0.0735675153419646, 0),\n              vec3(-0.5602717974381806, -0.07726775259396633, 0),\n              vec3(-0.7153912934590388, -0.12415155293477113, 0),\n              vec3(-0.8334693905906867, -0.19599274691264046, 0),\n              vec3(-0.9065615659773426, -0.26519950828454336, 0),\n              vec3(-0.9606168739080494, -0.34352848496478017, 0),\n              vec3(-0.9918609331367484, -0.42554749951727605, 0),\n              vec3(-1, -0.501250975683087, 0),\n              vec3(-0.9920458121631154, -0.5644456302156473, 0),\n              vec3(-0.9700027386021692, -0.6221960146343539, 0),\n              vec3(-0.9338718786515053, -0.6745057933870191, 0),\n              vec3(-0.8590522443950792, -0.7367032753273509, 0),\n              vec3(-0.7351805941989921, -0.7802251890974354, 0),\n              vec3(-0.5827779197857337, -0.7798042661921306, 0),\n              vec3(-0.4282209165039724, -0.732923763854356, 0),\n              vec3(-0.309724034061577, -0.6611190311322132, 0),\n              vec3(-0.23606875519452186, -0.5922149531495575, 0),\n              vec3(-0.18194931942711023, -0.5142857677255781, 0),\n              vec3(-0.15070477160536955, -0.43198972091851756, 0),\n              vec3(-0.14289345142754384, -0.36262715944048696, 0),\n              vec3(-0.14847184033130567, -0.308496424958989, 0),\n              vec3(-0.15252209342345557, -0.2804639488666007, 0),\n              vec3(-0.14582592578886266, -0.2776854423875038, 0),\n              vec3(-0.12245835283490758, -0.2641556292512484, 0),\n              vec3(-0.038064898248686085, -0.21350074566741542, 0),\n              vec3(-0.010236896435624088, -0.20683836729535282, 0),\n              vec3(0.05217673066860162, -0.24184340199853246, 0),\n              vec3(0.22475416946883997, -0.3386344316898545, 0),\n              vec3(0.5074954199650914, -0.4972114563693187, 0),\n              vec3(0.6800728587653297, -0.5940024860606405, 0),\n              vec3(0.7424864858695552, -0.6290075207638206, 0),\n              vec3(0.7591506863501207, -0.637769536120796, 0),\n              vec3(0.7764501780244097, -0.6422323449624139, 0),\n              vec3(0.7944433496694545, -0.6423026412862685, 0),\n              vec3(0.8106105269699253, -0.6384011037011439, 0),\n              vec3(0.840389478889374, -0.6238187390051059, 0),\n              vec3(0.9386062078074382, -0.5747117181769378, 0),\n              vec3(0.9759207302068813, -0.5532977844996639, 0),\n              vec3(0.9954577337149981, -0.5248467673930484, 0),\n              vec3(0.9995051773971593, -0.4876810215747609, 0),\n              vec3(0.9855536473919064, -0.4564436805003832, 0),\n              vec3(-0.3778747626482759, 0.2725759195812497, 0),\n              vec3(-0.44092989333040544, 0.25248033207836795, 0),\n              vec3(-0.5350289433165845, 0.2540849937751147, 0),\n              vec3(-0.6421618845018345, 0.28701127884590794, 0),\n              vec3(-0.7353416466803167, 0.34531862879492925, 0),\n              vec3(-0.7944855900647507, 0.4106071182700338, 0),\n              vec3(-0.8213397018891546, 0.48153830770799605, 0),\n              vec3(-0.8096231186042623, 0.5418054043467183, 0),\n              vec3(-0.7646943622451332, 0.5844876709748802, 0),\n              vec3(-0.7016392315630037, 0.6045780061025652, 0),\n              vec3(-0.6075467775828856, 0.6029731001092977, 0),\n              vec3(-0.5004138363976356, 0.5700457157041608, 0),\n              vec3(-0.4072362728878406, 0.5117412362392588, 0),\n              vec3(-0.3480923295034065, 0.4464581212876115, 0),\n              vec3(-0.3212382176790025, 0.37552332847596775, 0),\n              vec3(-0.33295480096389496, 0.3152627056950461, 0),\n              vec3(-0.34809623824773894, -0.4464600756597778, 0),\n              vec3(-0.4072401816321729, -0.5117490537279237, 0),\n              vec3(-0.5004177451419681, -0.5700585412715018, 0),\n              vec3(-0.6075506863272182, -0.6029783524844948, 0),\n              vec3(-0.7016431403073362, -0.6045896101873025, 0),\n              vec3(-0.7646982709894656, -0.5844960992048471, 0),\n              vec3(-0.8096248286799077, -0.5418100459806132, 0),\n              vec3(-0.8213414119648, -0.4815356204462675, 0),\n              vec3(-0.7944889491419114, -0.410600583338103, 0),\n              vec3(-0.7353439064231339, -0.34532931676771356, 0),\n              vec3(-0.642165793246167, -0.28702135607739027, 0),\n              vec3(-0.535032852060917, -0.25409714752702367, 0),\n              vec3(-0.440940398080799, -0.25249303549744884, 0),\n              vec3(-0.37788526739866934, -0.27258764581424744, 0),\n              vec3(-0.33295651103954027, -0.31527217218522646, 0),\n              vec3(-0.32123992775464794, -0.3755365815622203, 0),\n              vec3(-0.24832089752709519, 0.14440587210203007, 0),\n              vec3(-0.24142807119327403, 0.15129063665066564, 0),\n              vec3(-0.2392291582097288, 0.15344398833308528, 0),\n              vec3(-0.23755401696673706, 0.15483525701893, 0),\n              vec3(-0.23538484708459695, 0.15650789422258396, 0),\n              vec3(-0.23315258762596525, 0.15846189994404655, 0),\n              vec3(-0.22910722046423104, 0.16205800580406543, 0),\n              vec3(-0.22240885416095102, 0.1687605251481988, 0),\n              vec3(-0.21501576962670155, 0.17706165985018937, 0),\n              vec3(-0.20943298338556549, 0.18319875489697618, 0),\n              vec3(-0.20294855976035897, 0.18975658962667724, 0),\n              vec3(-0.18300370321079884, 0.20970144617623737, 0),\n              vec3(-0.16469428971960365, 0.20603944132973795, 0),\n              vec3(-0.10407772690790495, 0.16998176345558041, 0),\n              vec3(-0.09274358982629449, 0.16039373575624838, 0),\n              vec3(-0.1034899494789071, 0.1542640917533452, 0),\n              vec3(-0.12204060578437315, 0.14059899941870777, 0),\n              vec3(-0.14044810432866162, 0.10935494019000884, 0),\n              vec3(-0.14274876681311188, 0.08846807625631922, 0),\n              vec3(-0.14274876681311188, 0.08003007442856136, 0),\n              vec3(-0.15948918589959427, 0.08822622270074644, 0),\n              vec3(-0.2331470298801176, 0.13272727692611905, 0),\n              vec3(-0.02781384979195589, -0.12387152804782663, 0),\n              vec3(-0.15058408912410415, -0.19751324845797866, 0),\n              vec3(-0.18301994892943074, -0.20971708115356757, 0),\n              vec3(-0.20296749274071946, -0.1897722246040071, 0),\n              vec3(-0.20993928792488314, -0.18273056061490037, 0),\n              vec3(-0.21607638297166998, -0.1760274305294652, 0),\n              vec3(-0.2234681849491853, -0.16763944841433695, 0),\n              vec3(-0.22960527999597224, -0.16093790625628696, 0),\n              vec3(-0.23462416879301662, -0.15633273361718453, 0),\n              vec3(-0.23852631711944328, -0.15298697061683525, 0),\n              vec3(-0.24142208592851477, -0.15034948430435882, 0),\n              vec3(-0.2483229740475219, -0.14422521482491302, 0),\n              vec3(-0.22199086281389568, -0.12609413779388773, 0),\n              vec3(-0.09922868526693318, -0.052441668336821304, 0),\n              vec3(-0.07132819036989624, -0.01599751336678909, 0),\n              vec3(-0.07132819036989624, 0.0707042990442873, 0),\n              vec3(-0.06170310785063482, 0.09581087387861942, 0),\n              vec3(0.007764879027511995, 0.1347964608228636, 0),\n              vec3(0.19984804756407448, 0.24259395725303295, 0),\n              vec3(0.5145463977590528, 0.41920336316912743, 0),\n              vec3(0.7066295662956152, 0.5270008595992967, 0),\n              vec3(0.7760975531737622, 0.5659864465435408, 0),\n              vec3(0.8080403443489241, 0.5602273774598631, 0),\n              vec3(0.9062382624348888, 0.5111203566316952, 0),\n              vec3(0.9193316684652679, 0.4927408033191041, 0),\n              vec3(0.8527562669071564, 0.44063941713293087, 0),\n              vec3(0.6686712710326184, 0.29657594569044043, 0),\n              vec3(0.36707668084165435, 0.06055038899163226, 0),\n              vec3(0.18299168496711649, -0.08351308245085817, 0),\n              vec3(0.11641628340900478, -0.1356144686370314, 0),\n              vec3(0.09045705836871809, -0.13725543508704563, 0),\n              vec3(0.016823399743752132, -0.11271267371987646, 0),\n              vec3(0.7784401678599564, -0.5672896616021775, 0),\n              vec3(0.7257951150353192, -0.5377098876898276, 0),\n              vec3(0.5802283725864721, -0.4559200309080904, 0),\n              vec3(0.3417399405134154, -0.3219200912569656, 0),\n              vec3(0.19617319806456845, -0.2401302344752283, 0),\n              vec3(0.14352814523993085, -0.2105504605628784, 0),\n              vec3(0.14176305325456084, -0.20429626350570895, 0),\n              vec3(0.14902635526214625, -0.200393626586241, 0),\n              vec3(0.15925080593517627, -0.1920256767858167, 0),\n              vec3(0.2132656827916939, -0.14991933920539463, 0),\n              vec3(0.28579994599901726, -0.09337654302597095, 0),\n              vec3(0.3398148228555349, -0.05127020544554872, 0),\n              vec3(0.35481982816678936, -0.04976675312536827, 0),\n              vec3(0.4018552297672713, -0.08667113602061913, 0),\n              vec3(0.5319109486505318, -0.188713977881584, 0),\n              vec3(0.7449869848165704, -0.3558952787082624, 0),\n              vec3(0.875042703699831, -0.45793812056922695, 0),\n              vec3(0.9220781053003129, -0.4948425034644776, 0),\n              vec3(0.9062730746890999, -0.5111170586286649, 0),\n              vec3(0.8080563457710355, -0.5602267667185614, 0),\n              vec3(0.05749229659590194, 0.07009361881646597, 0),\n              vec3(0.03238594315529175, 0.059483454474188464, 0),\n              vec3(0.01201735429043782, 0.03911853005714624, 0),\n              vec3(0.001414152399002333, 0.014008878613505698, 0),\n              vec3(0.001414152399002333, -0.014026162592351234, 0),\n              vec3(0.01201735429043782, -0.039133737515565065, 0),\n              vec3(0.03238374448660486, -0.05950568545758008, 0),\n              vec3(0.0574900979272146, -0.0701114524624834, 0),\n              vec3(0.08552764317240946, -0.0701114524624834, 0),\n              vec3(0.11063766106083128, -0.05950568545758008, 0),\n              vec3(0.13100673851872702, -0.03913593618425212, 0),\n              vec3(0.14160139003193484, -0.014028361261038283, 0),\n              vec3(0.14160139003193484, 0.014007229611990281, 0),\n              vec3(0.13100673851872702, 0.039117980389974605, 0),\n              vec3(0.11063711139365973, 0.059483454474188555, 0),\n              vec3(0.08552599417089413, 0.07009361881646606, 0),\n              vec3(-0.9986934182299371, 0.467614810728503, 0),\n              vec3(-0.998693418229937, -0.46761090198417055, 0),\n              vec3(-0.9813972245586788, 0.5937148116388892, 0),\n              vec3(-0.9362082313307883, 0.303560902349661, 0),\n              vec3(-0.9362082313307883, -0.3035648110939935, 0),\n              vec3(-0.910535598555009, 0.6974958824107707, 0),\n              vec3(-0.9105238723220115, -0.6986216007785271, 0),\n              vec3(-0.8123440321785851, -0.4463707852814324, 0),\n              vec3(-0.8123401234342527, 0.44639032900309467, 0),\n              vec3(-0.7900172845514153, 0.16517571800226585, 0),\n              vec3(-0.7900172845514152, -0.16516008302493598, 0),\n              vec3(-0.7889072011609888, -0.5669203692396861, 0),\n              vec3(-0.7889032924166562, 0.5669164604953535, 0),\n              vec3(-0.6940576111888417, -0.3158187245763427, 0),\n              vec3(-0.6940537024445093, 0.31581481583200993, 0),\n              vec3(-0.662795474017605, -0.6071022609776597, 0),\n              vec3(-0.6627915652732725, 0.6070905347446622, 0),\n              vec3(-0.6627915652732725, 0.785665428318696, 0),\n              vec3(-0.662779839040275, -0.785665428318696, 0),\n              vec3(-0.4797880643705301, -0.24997983503991955, 0),\n              vec3(-0.4797841556261977, 0.2499681088069219, 0),\n              vec3(-0.4797841556261976, -0.07140494146588555, 0),\n              vec3(-0.4797841556261976, 0.07142839393188043, 0),\n              vec3(-0.4485259271992933, -0.5412633714412366, 0),\n              vec3(-0.44852201845496087, 0.5412438277195742, 0),\n              vec3(-0.3536763372271464, -0.29016172677789315, 0),\n              vec3(-0.3536724284828139, 0.2901578180335606, 0),\n              vec3(-0.3536724284828139, 0.6919259217369756, 0),\n              vec3(-0.3536607022498164, -0.6919102867596456, 0),\n              vec3(-0.33023950620955, -0.4106839495258195, 0),\n              vec3(-0.33023559746521747, 0.4106761320371544, 0),\n              vec3(-0.311278187452652, -0.1059973288084021, 0),\n              vec3(-0.311278187452652, 0.1060207812743967, 0),\n              vec3(-0.2867312730446291, -0.08143868816738169, 0),\n              vec3(-0.2867312730446291, 0.08146214063337648, 0),\n              vec3(-0.24989135771093252, -0.14283333539776624, 0),\n              vec3(-0.2498874489666001, 0.1428411528864311, 0),\n              vec3(-0.23986151975376913, 0.15285535586626464, 0),\n              vec3(-0.23985370226510405, -0.1517413637315056, 0),\n              vec3(-0.23650390837216206, 0.15563056434233094, 0),\n              vec3(-0.232047939833126, -0.15842922528439227, 0),\n              vec3(-0.23204012234446114, 0.1595393086748187, 0),\n              vec3(-0.2197744826291147, -0.17183230960049248, 0),\n              vec3(-0.21864485551702573, 0.17295021047958406, 0),\n              vec3(-0.2075010254251033, -0.1852393026609254, 0),\n              vec3(-0.20748148170344083, 0.18522366768359544, 0),\n              vec3(-0.20637139831301432, 0.5546625470130045, 0),\n              vec3(-0.2063596720800167, -0.5540801441074639, 0),\n              vec3(-0.1784864162450469, -0.21425000309664927, 0),\n              vec3(-0.17847078126771698, 0.21423436811931923, 0),\n              vec3(-0.1505779817110845, -1.7445276963428036e-16, 0),\n              vec3(-0.15504567648311807, 0.28125369844415365, 0),\n              vec3(-0.15503395025012057, -0.28123024597815865, 0),\n              vec3(-0.14388230266953317, 0.38949855524373606, 0),\n              vec3(-0.14387057643653567, -0.3894711940334086, 0),\n              vec3(-0.14274876681311188, 0.07811234674043456, 0),\n              vec3(-0.14274876681311188, 0.09038580394444594, 0),\n              vec3(-0.14165040965568265, 0.2756759202816937, 0),\n              vec3(-0.14163868342268515, -0.2756681027930286, 0),\n              vec3(-0.10593230394540998, 0.15287099084359457, 0),\n              vec3(-0.09030123535979162, 0.16178683666599902, 0),\n              vec3(-0.07132819036989624, 0.09040925641044098, 0),\n              vec3(-0.07132819036989624, -0.035702470732942776, 0),\n              vec3(-0.018896293893905902, 0.20202735956896012, 0),\n              vec3(-0.018884567660908402, -0.20198827212563503, 0),\n              vec3(0.000088477328986869, -0.10713477340915584, 0),\n              vec3(0.00008847732898709104, -0.000011726232997653771, 0),\n              vec3(0.0212934153327331, -0.05021954718380228, 0),\n              vec3(0.0212934153327331, 0.05020391220647208, 0),\n              vec3(0.07150905377220274, 0.07142057644321541, 0),\n              vec3(0.07150905377220274, -0.07143621142054561, 0),\n              vec3(0.10719198078348313, -0.14283333539776624, 0),\n              vec3(0.12173641844466987, 0.05020391220647208, 0),\n              vec3(0.12173641844466987, -0.05021954718380228, 0),\n              vec3(0.1362339511738666, -0.20645205815333634, 0),\n              vec3(0.14292572147108595, -0.000011726232997653771, 0),\n              vec3(0.15076275385772342, -0.19864238697702594, 0),\n              vec3(0.3483028749329877, -0.04465349525433966, 0),\n              vec3(0.40628909710544314, -0.000011726232997479318, 0),\n              vec3(0.7511185221175096, 0.6339201558428579, 0),\n              vec3(0.7511341570948395, -0.633857615933538, 0),\n              vec3(0.7856991832270284, 0.6428360016652623, 0),\n              vec3(0.7857226356930234, 0.5713880640117194, 0),\n              vec3(0.785726544437356, -0.6427890967332727, 0),\n              vec3(0.7857343619260209, -0.5713880640117196, 0),\n              vec3(0.8180557688113617, 0.6350224217446195, 0),\n              vec3(0.8180674950443594, -0.6349794255569621, 0),\n              vec3(0.9285559710907896, 0.49995967007983877, 0),\n              vec3(0.9285950585341145, -0.49995576133550657, 0),\n              vec3(0.9609008304421254, 0.5636057540457364, 0),\n              vec3(0.9609281916524528, -0.5635510316250816, 0),\n              vec3(0.9720837479773727, 0.4442092496655666, 0),\n              vec3(0.9720954742103702, -0.4441545272449118, 0),\n              vec3(0.9999882737670025, 0.5066944365647152, 0),\n              vec3(1, -0.5066475316327255, 0));\nconst ivec3 triangles1[327] = ivec3[327](\n    ivec3(0, 207, 1), ivec3(0, 318, 207), ivec3(1, 206, 2), ivec3(1, 207, 206),\n    ivec3(2, 205, 3), ivec3(2, 206, 205), ivec3(3, 204, 4), ivec3(3, 205, 204),\n    ivec3(4, 203, 5), ivec3(4, 204, 203), ivec3(5, 202, 304),\n    ivec3(5, 203, 202), ivec3(6, 185, 7), ivec3(6, 304, 185), ivec3(7, 185, 8),\n    ivec3(8, 184, 9), ivec3(8, 185, 184), ivec3(9, 183, 10), ivec3(9, 184, 183),\n    ivec3(10, 182, 11), ivec3(10, 183, 182), ivec3(11, 182, 313),\n    ivec3(11, 313, 317), ivec3(12, 313, 13), ivec3(12, 317, 313),\n    ivec3(13, 313, 319), ivec3(14, 313, 15), ivec3(14, 319, 313),\n    ivec3(15, 313, 315), ivec3(16, 181, 17), ivec3(16, 313, 181),\n    ivec3(16, 315, 313), ivec3(17, 180, 311), ivec3(17, 181, 180),\n    ivec3(18, 308, 19), ivec3(18, 311, 308), ivec3(19, 308, 307),\n    ivec3(20, 307, 308), ivec3(20, 308, 21), ivec3(21, 308, 305),\n    ivec3(22, 179, 23), ivec3(22, 305, 308), ivec3(22, 308, 179),\n    ivec3(23, 178, 24), ivec3(23, 179, 178), ivec3(24, 177, 25),\n    ivec3(24, 178, 177), ivec3(25, 176, 26), ivec3(25, 177, 176),\n    ivec3(26, 175, 27), ivec3(26, 176, 175), ivec3(27, 175, 289),\n    ivec3(28, 149, 29), ivec3(28, 286, 149), ivec3(28, 289, 286),\n    ivec3(29, 148, 283), ivec3(29, 149, 148), ivec3(30, 275, 31),\n    ivec3(30, 283, 275), ivec3(31, 275, 277), ivec3(32, 118, 33),\n    ivec3(32, 119, 118), ivec3(32, 277, 119), ivec3(33, 118, 279),\n    ivec3(34, 118, 256), ivec3(34, 256, 35), ivec3(34, 279, 118),\n    ivec3(35, 117, 272), ivec3(35, 256, 117), ivec3(36, 116, 37),\n    ivec3(36, 117, 116), ivec3(36, 272, 117), ivec3(37, 116, 250),\n    ivec3(37, 250, 253), ivec3(38, 114, 39), ivec3(38, 115, 114),\n    ivec3(38, 253, 115), ivec3(39, 114, 242), ivec3(39, 242, 243),\n    ivec3(40, 112, 41), ivec3(40, 113, 112), ivec3(40, 243, 113),\n    ivec3(41, 112, 238), ivec3(41, 238, 231), ivec3(42, 111, 43),\n    ivec3(42, 231, 238), ivec3(42, 238, 111), ivec3(43, 111, 228),\n    ivec3(44, 110, 45), ivec3(44, 111, 110), ivec3(44, 228, 111),\n    ivec3(45, 110, 226), ivec3(46, 110, 234), ivec3(46, 226, 110),\n    ivec3(46, 234, 47), ivec3(47, 109, 229), ivec3(47, 234, 109),\n    ivec3(48, 108, 49), ivec3(48, 109, 108), ivec3(48, 229, 109),\n    ivec3(49, 108, 240), ivec3(49, 240, 235), ivec3(50, 106, 51),\n    ivec3(50, 107, 106), ivec3(50, 235, 107), ivec3(51, 106, 246),\n    ivec3(51, 246, 248), ivec3(52, 105, 53), ivec3(52, 246, 105),\n    ivec3(52, 248, 246), ivec3(53, 104, 258), ivec3(53, 105, 104),\n    ivec3(54, 258, 262), ivec3(54, 262, 55), ivec3(55, 262, 260),\n    ivec3(56, 156, 57), ivec3(56, 157, 156), ivec3(56, 260, 157),\n    ivec3(57, 156, 281), ivec3(57, 281, 276), ivec3(58, 170, 59),\n    ivec3(58, 171, 170), ivec3(58, 276, 171), ivec3(59, 170, 261),\n    ivec3(59, 261, 259), ivec3(60, 259, 261), ivec3(60, 261, 61),\n    ivec3(61, 261, 257), ivec3(62, 132, 63), ivec3(62, 133, 132),\n    ivec3(62, 257, 133), ivec3(63, 132, 245), ivec3(63, 245, 247),\n    ivec3(64, 131, 65), ivec3(64, 245, 131), ivec3(64, 247, 245),\n    ivec3(65, 130, 236), ivec3(65, 131, 130), ivec3(66, 129, 67),\n    ivec3(66, 236, 239), ivec3(66, 239, 129), ivec3(67, 128, 230),\n    ivec3(67, 129, 128), ivec3(68, 128, 233), ivec3(68, 230, 128),\n    ivec3(68, 233, 69), ivec3(69, 127, 227), ivec3(69, 233, 127),\n    ivec3(70, 127, 71), ivec3(70, 227, 127), ivec3(71, 126, 72),\n    ivec3(71, 127, 126), ivec3(72, 126, 73), ivec3(73, 126, 237),\n    ivec3(73, 237, 232), ivec3(74, 125, 75), ivec3(74, 232, 237),\n    ivec3(74, 237, 125), ivec3(75, 124, 244), ivec3(75, 125, 124),\n    ivec3(76, 123, 77), ivec3(76, 241, 123), ivec3(76, 244, 241),\n    ivec3(77, 122, 254), ivec3(77, 123, 122), ivec3(78, 121, 79),\n    ivec3(78, 249, 121), ivec3(78, 254, 249), ivec3(79, 120, 273),\n    ivec3(79, 121, 120), ivec3(80, 120, 255), ivec3(80, 255, 81),\n    ivec3(80, 273, 120), ivec3(81, 135, 280), ivec3(81, 255, 135),\n    ivec3(82, 135, 83), ivec3(82, 280, 135), ivec3(83, 134, 278),\n    ivec3(83, 135, 134), ivec3(84, 274, 85), ivec3(84, 278, 274),\n    ivec3(85, 274, 284), ivec3(86, 159, 87), ivec3(86, 274, 159),\n    ivec3(86, 284, 274), ivec3(87, 158, 290), ivec3(87, 159, 158),\n    ivec3(88, 188, 89), ivec3(88, 189, 188), ivec3(88, 290, 189),\n    ivec3(89, 188, 297), ivec3(89, 194, 90), ivec3(89, 195, 194),\n    ivec3(89, 297, 300), ivec3(89, 300, 195), ivec3(90, 193, 91),\n    ivec3(90, 194, 193), ivec3(91, 192, 92), ivec3(91, 193, 192),\n    ivec3(92, 191, 93), ivec3(92, 192, 191), ivec3(93, 190, 306),\n    ivec3(93, 191, 190), ivec3(94, 306, 310), ivec3(94, 310, 95),\n    ivec3(95, 310, 309), ivec3(96, 309, 310), ivec3(96, 310, 97),\n    ivec3(97, 310, 312), ivec3(98, 208, 99), ivec3(98, 209, 208),\n    ivec3(98, 312, 209), ivec3(99, 208, 314), ivec3(99, 314, 316),\n    ivec3(100, 314, 101), ivec3(100, 316, 314), ivec3(101, 314, 320),\n    ivec3(102, 314, 103), ivec3(102, 320, 314), ivec3(103, 314, 318),\n    ivec3(104, 136, 262), ivec3(104, 252, 136), ivec3(104, 262, 258),\n    ivec3(107, 235, 240), ivec3(113, 243, 242), ivec3(115, 253, 250),\n    ivec3(119, 145, 252), ivec3(119, 146, 271), ivec3(119, 147, 146),\n    ivec3(119, 271, 145), ivec3(119, 277, 147), ivec3(122, 249, 254),\n    ivec3(124, 241, 244), ivec3(130, 239, 236), ivec3(133, 257, 261),\n    ivec3(133, 261, 251), ivec3(134, 160, 278), ivec3(134, 161, 160),\n    ivec3(134, 162, 270), ivec3(134, 251, 162), ivec3(134, 270, 161),\n    ivec3(136, 252, 137), ivec3(137, 252, 263), ivec3(138, 252, 139),\n    ivec3(138, 263, 252), ivec3(139, 252, 267), ivec3(139, 267, 265),\n    ivec3(140, 265, 141), ivec3(141, 265, 267), ivec3(142, 267, 143),\n    ivec3(143, 252, 269), ivec3(143, 267, 252), ivec3(144, 252, 145),\n    ivec3(144, 269, 252), ivec3(147, 277, 275), ivec3(148, 275, 283),\n    ivec3(150, 174, 151), ivec3(150, 286, 174), ivec3(151, 174, 287),\n    ivec3(151, 287, 285), ivec3(152, 285, 287), ivec3(152, 287, 153),\n    ivec3(153, 287, 282), ivec3(154, 282, 287), ivec3(154, 287, 155),\n    ivec3(155, 173, 281), ivec3(155, 287, 173), ivec3(157, 260, 262),\n    ivec3(158, 189, 290), ivec3(158, 291, 189), ivec3(160, 274, 278),\n    ivec3(162, 251, 163), ivec3(163, 251, 268), ivec3(164, 251, 165),\n    ivec3(164, 268, 251), ivec3(165, 166, 266), ivec3(165, 251, 166),\n    ivec3(166, 251, 167), ivec3(167, 168, 264), ivec3(167, 251, 168),\n    ivec3(168, 251, 169), ivec3(169, 251, 261), ivec3(171, 172, 288),\n    ivec3(171, 276, 172), ivec3(172, 276, 173), ivec3(173, 276, 281),\n    ivec3(174, 286, 175), ivec3(175, 286, 289), ivec3(180, 308, 311),\n    ivec3(185, 201, 186), ivec3(185, 303, 201), ivec3(185, 304, 303),\n    ivec3(186, 199, 187), ivec3(186, 200, 199), ivec3(186, 201, 200),\n    ivec3(187, 198, 297), ivec3(187, 199, 198), ivec3(190, 310, 306),\n    ivec3(196, 297, 302), ivec3(196, 300, 297), ivec3(196, 302, 197),\n    ivec3(198, 302, 297), ivec3(202, 303, 304), ivec3(207, 318, 314),\n    ivec3(209, 312, 310), ivec3(210, 295, 211), ivec3(211, 295, 294),\n    ivec3(212, 292, 213), ivec3(212, 294, 292), ivec3(214, 292, 215),\n    ivec3(215, 292, 293), ivec3(216, 293, 296), ivec3(216, 296, 217),\n    ivec3(218, 296, 219), ivec3(219, 296, 299), ivec3(220, 299, 301),\n    ivec3(220, 301, 221), ivec3(222, 301, 223), ivec3(223, 301, 298),\n    ivec3(224, 295, 225), ivec3(224, 298, 295), ivec3(292, 294, 293),\n    ivec3(293, 294, 299), ivec3(293, 299, 296), ivec3(294, 295, 298),\n    ivec3(294, 298, 299), ivec3(298, 301, 299));\nconst int len1 = 327;\n\nbool inPath1(vec2 p) {\n  for (int i = 0; i < len1; i++) {\n    ivec3 triangle = triangles1[i];\n    vec3 a = positions1[triangle[0]];\n    vec3 b = positions1[triangle[1]];\n    vec3 c = positions1[triangle[2]];\n\n    if (pointInTriangle(vec3(p, 0.0), a, b, c)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nbool resolutionChanged() {\n  return iResolution.xy !=\n         texelFetch(iChannel0, ivec2(iResolution.xy - vec2(1.0)), 0).xy;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  const float numSamp = 2.0;\n  fragColor = vec4(0.0);\n\n  if (iFrame == 0 || resolutionChanged()) {\n    for (float i = 0.0; i < numSamp; i++) {\n      for (float j = 0.0; j < numSamp; j++) {\n        vec2 uv = (fragCoord + vec2(i * 0.5, j * 0.5)) / iResolution.xy;\n\n        // Normalized pixel coordinates (from 0 to 1)\n        uv.x *= iResolution.x / iResolution.y;\n        float which = uv.x / size;\n        uv = mod(uv, size);\n        uv *= 1.0 / size * 2.0;\n        uv -= vec2(1);\n        uv *= 1.2;\n\n        if (which < 1.0) {\n          if (inPath0(uv)) {\n            fragColor += vec4(1.0);\n          }\n        } else if (which < 2.0) {\n          if (inPath1(uv)) {\n            fragColor += vec4(1.0);\n          }\n        }\n      }\n    }\n\n    fragColor = fragColor / 4.0;\n  } else {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n  }\n\n  if (ivec2(fragCoord) == ivec2(iResolution.xy - vec2(1))) {\n    fragColor = vec4(iResolution, 1.0);\n  }\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "const vec3 positions0[213] =\n    vec3[213](vec3(0.8036688091507105, 0.41370589834514815, 0),\n              vec3(0.7174743775265606, 0.47229738230741586, 0),\n              vec3(0.6232070368367091, 0.5113593834940786, 0),\n              vec3(0.5208626825599805, 0.5308908757748423, 0),\n              vec3(0.4561786728994197, 0.5333323604097954, 0),\n              vec3(0.3805283606878769, 0.5333323604097954, 0),\n              vec3(0.17135069017523574, 0.5333323604097954, 0),\n              vec3(-0.17135433863850302, 0.5333323604097954, 0),\n              vec3(-0.38053200915114394, 0.5333323604097954, 0),\n              vec3(-0.45618232136268744, 0.5333323604097954, 0),\n              vec3(-0.5208607941952037, 0.5308910254188435, 0),\n              vec3(-0.6232058753142239, 0.511360345491229, 0),\n              vec3(-0.717480270649846, 0.47229898563600003, 0),\n              vec3(-0.8036767972900126, 0.41370694585315665, 0),\n              vec3(-0.8803672528873026, 0.33701636198958007, 0),\n              vec3(-0.9389639530118976, 0.25082004912655803, 0),\n              vec3(-0.9780274078831434, 0.1565501431109717, 0),\n              vec3(-0.9975586436313337, 0.054206643942821264, 0),\n              vec3(-0.997558045055329, -0.05419758691779638, 0),\n              vec3(-0.9780235598945412, -0.15654548989512498, 0),\n              vec3(-0.9389575396975607, -0.25081347191641007, 0),\n              vec3(-0.8803630628552691, -0.33700461137253357, 0),\n              vec3(-0.8036773958660175, -0.41369088406369475, 0),\n              vec3(-0.7174841186384483, -0.4722858027120853, 0),\n              vec3(-0.6232122886285609, -0.5113538039106051, 0),\n              vec3(-0.5208649842272373, -0.5308900990512173, 0),\n              vec3(-0.4174113189696377, -0.5312482042719857, 0),\n              vec3(-0.3234035037332902, -0.5145764943649485, 0),\n              vec3(-0.23538726328314263, -0.4812370080503343, 0),\n              vec3(-0.15335644083743194, -0.4312338498493184, 0),\n              vec3(-0.10473676280519406, -0.3999846764542776, 0),\n              vec3(-0.0420748337440896, -0.3999846764542776, 0),\n              vec3(0.04207118528082199, -0.3999846764542776, 0),\n              vec3(0.10473311434192678, -0.3999846764542776, 0),\n              vec3(0.15335039807014517, -0.4312338498493186, 0),\n              vec3(0.23537848416840568, -0.4812370080503343, 0),\n              vec3(0.3233947246185531, -0.5145764943649485, 0),\n              vec3(0.417405276202351, -0.5312482042719857, 0),\n              vec3(0.5208553500039221, -0.5308911465592255, 0),\n              vec3(0.6231958135366196, -0.5113605378906592, 0),\n              vec3(0.7174676435465068, -0.4722970260121749, 0),\n              vec3(0.8036677616427021, -0.41369821661975353, 0),\n              vec3(0.8803627136859327, -0.33699847596848487, 0),\n              vec3(0.9389598556166268, -0.2508048139420551, 0),\n              vec3(0.9780252914894123, -0.15654132124080586, 0),\n              vec3(0.9975583372174264, -0.05419773656179761, 0),\n              vec3(0.9975581875734252, 0.054206643942821264, 0),\n              vec3(0.9780243294922617, 0.1565501431109717, 0),\n              vec3(0.9389582522880426, 0.25082004912655803, 0),\n              vec3(0.8803616661779243, 0.33701636198958007, 0),\n              vec3(-0.13392493925308668, -0.07363379872522667, 0),\n              vec3(-0.1386075138276759, -0.08560862524079854, 0),\n              vec3(-0.1477216030982752, -0.09471439145456917, 0),\n              vec3(-0.15969927997577427, -0.09940095653585687, 0),\n              vec3(-0.17526291168347408, -0.09998613583958423, 0),\n              vec3(-0.22995081073414403, -0.09998613583958423, 0),\n              vec3(-0.30338884660218635, -0.09998613583958423, 0),\n              vec3(-0.3580767456528562, -0.09998613583958423, 0),\n              vec3(-0.36667055836081863, -0.10858010531745271, 0),\n              vec3(-0.36667055836081863, -0.16326900199479732, 0),\n              vec3(-0.36667055836081863, -0.23670837753294563, 0),\n              vec3(-0.36667055836081863, -0.2913972742102902, 0),\n              vec3(-0.3672551105849219, -0.306960378601033, 0),\n              vec3(-0.371937685159511, -0.31893668730480734, 0),\n              vec3(-0.38105126136496337, -0.3280424535185781, 0),\n              vec3(-0.3930279121121687, -0.3327275364116636, 0),\n              vec3(-0.42083256563585436, -0.3333126587081522, 0),\n              vec3(-0.5124990650812882, -0.3333126587081522, 0),\n              vec3(-0.5402975618232103, -0.3327275364116636, 0),\n              vec3(-0.5522783170915913, -0.3280424535185781, 0),\n              vec3(-0.5613876177541521, -0.31893668730480734, 0),\n              vec3(-0.5660657457641343, -0.306960378601033, 0),\n              vec3(-0.5666501269665218, -0.2913972742102902, 0),\n              vec3(-0.5666501269665218, -0.23670837753294563, 0),\n              vec3(-0.5666501269665218, -0.16326900199479732, 0),\n              vec3(-0.5666501269665218, -0.10858010531745271, 0),\n              vec3(-0.5752447235240143, -0.09998613583958423, 0),\n              vec3(-0.6299376107080574, -0.09998613583958423, 0),\n              vec3(-0.7033823449266294, -0.09998613583958423, 0),\n              vec3(-0.7580752321106725, -0.09998613583958423, 0),\n              vec3(-0.7736350300815796, -0.09940095653585687, 0),\n              vec3(-0.7856157853499606, -0.09471439145456917, 0),\n              vec3(-0.7947250860125216, -0.08560862524079854, 0),\n              vec3(-0.7994032140225037, -0.07363379872522667, 0),\n              vec3(-0.7999875952248913, -0.04583142549108313, 0),\n              vec3(-0.7999875952248913, 0.04583507395435069, 0),\n              vec3(-0.7994032140225037, 0.0736335706962728, 0),\n              vec3(-0.7947250860125216, 0.08561432596465375, 0),\n              vec3(-0.7856157853499606, 0.0947299544306939, 0),\n              vec3(-0.7736350300815796, 0.09941252900528313, 0),\n              vec3(-0.7580755456504845, 0.09999708122938626, 0),\n              vec3(-0.7033846537197908, 0.09999708122938626, 0),\n              vec3(-0.6299425988414304, 0.09999708122938626, 0),\n              vec3(-0.5752517069107368, 0.09999708122938626, 0),\n              vec3(-0.5666574238930563, 0.1085908939373487, 0),\n              vec3(-0.5666574238930563, 0.16327879298801867, 0),\n              vec3(-0.5666574238930563, 0.23671682885606093, 0),\n              vec3(-0.5666574238930563, 0.29140472790673083, 0),\n              vec3(-0.5660730426906687, 0.3069637420281079, 0),\n              vec3(-0.5613949146806866, 0.31894449729648894, 0),\n              vec3(-0.5522871532135665, 0.3280616649579699, 0),\n              vec3(-0.5403053718148916, 0.33274321340226526, 0),\n              vec3(-0.5125063620078223, 0.3333272525612214, 0),\n              vec3(-0.4208398625623887, 0.3333272525612214, 0),\n              vec3(-0.3930367482341436, 0.3327427003371183, 0),\n              vec3(-0.3810590713566445, 0.328060125762529, 0),\n              vec3(-0.3719449820860453, 0.31894449729648894, 0),\n              vec3(-0.367262407511456, 0.3069637420281079, 0),\n              vec3(-0.36667785528735286, 0.29140472790673083, 0),\n              vec3(-0.36667785528735286, 0.23671682885606093, 0),\n              vec3(-0.36667785528735286, 0.16327879298801867, 0),\n              vec3(-0.36667785528735286, 0.10859089393734876, 0),\n              vec3(-0.3580840425793904, 0.09999708122938637, 0),\n              vec3(-0.30339614352872046, 0.09999708122938637, 0),\n              vec3(-0.22995810766067826, 0.09999708122938637, 0),\n              vec3(-0.1752702086100083, 0.09999708122938637, 0),\n              vec3(-0.1597065769023085, 0.09941252900528313, 0),\n              vec3(-0.14772890002480943, 0.09472995443069397, 0),\n              vec3(-0.13861481075421012, 0.08561432596465388, 0),\n              vec3(-0.1339322361796209, 0.07363357069627292, 0),\n              vec3(-0.13334768395551777, 0.04583507395435069, 0),\n              vec3(-0.13334768395551777, -0.04583142549108313, 0),\n              vec3(-0.13334654381074684, -0.06666472081959077, 0),\n              vec3(-0.13334152717375447, -0.06666472081959077, 0),\n              vec3(0.40706320825793196, -0.24468914864933888, 0),\n              vec3(0.3599169678169054, -0.26423020389436974, 0),\n              vec3(0.30673001235004826, -0.26423020389436974, 0),\n              vec3(0.25959699758836585, -0.24468914864933888, 0),\n              vec3(0.2219661773773387, -0.2070640861694055, 0),\n              vec3(0.20243515540629287, -0.1599266248431161, 0),\n              vec3(0.20243515540629287, -0.10673220142800821, 0),\n              vec3(0.2219661773773387, -0.05959736243469214, 0),\n              vec3(0.25959699758836585, -0.021978570750999526, 0),\n              vec3(0.30673001235004826, -0.0024378575493999733, 0),\n              vec3(0.3599169678169054, -0.0024378575493999733, 0),\n              vec3(0.40706320825793196, -0.021978570750999526, 0),\n              vec3(0.44468678854966304, -0.05959736243469214, 0),\n              vec3(0.46421746847727774, -0.10673220142800821, 0),\n              vec3(0.4642174684772775, -0.1599266248431161, 0),\n              vec3(0.4446867885496628, -0.2070640861694055, 0),\n              vec3(0.6737191841671286, 0.021982390235982575, 0),\n              vec3(0.6265817228408395, 0.002449772062257452, 0),\n              vec3(0.5733853041723824, 0.0024477198016696266, 0),\n              vec3(0.5262519473672689, 0.021976233454219098, 0),\n              vec3(0.48862449058331614, 0.059611500229853225, 0),\n              vec3(0.46909096029377406, 0.10674770739689451, 0),\n              vec3(0.46909096029377406, 0.15993654410262406, 0),\n              vec3(0.48862449058331614, 0.20706693653133298, 0),\n              vec3(0.5262519473672689, 0.24469781374959887, 0),\n              vec3(0.5733853041723824, 0.26422883572064454, 0),\n              vec3(0.6265817228408395, 0.26422883572064454, 0),\n              vec3(0.6737191841671286, 0.24469781374959867, 0),\n              vec3(0.7113427644588597, 0.20706693653133298, 0),\n              vec3(0.7308863280223867, 0.15993654410262406, 0),\n              vec3(0.7308883802829744, 0.10674770739689451, 0),\n              vec3(0.7113489212406234, 0.059607395708677575, 0),\n              vec3(-1, 0.0000072969265345899875, 0),\n              vec3(-0.8437436151892823, -0.37707232713581035, 0),\n              vec3(-0.8437436151892822, 0.37708692098887947, 0),\n              vec3(-0.7999875952248913, 0.06666836928285809, 0),\n              vec3(-0.7999875952248913, -0.06666472081959077, 0),\n              vec3(-0.790629286944339, 0.09062782755903222, 0),\n              vec3(-0.790629286944339, -0.09060958524269572, 0),\n              vec3(-0.766669828668165, 0.09999708122938626, 0),\n              vec3(-0.766669828668165, -0.09998613583958423, 0),\n              vec3(-0.5666574238930563, 0.2999985406146932, 0),\n              vec3(-0.5666574238930563, 0.09999708122938626, 0),\n              vec3(-0.5666501269665218, -0.09998613583958423, 0),\n              vec3(-0.5666501269665218, -0.2999912436881585, 0),\n              vec3(-0.557299115612504, 0.32395799889086735, 0),\n              vec3(-0.5572918186859697, -0.3239397565745309, 0),\n              vec3(-0.5333396573363299, 0.3333272525612214, 0),\n              vec3(-0.5333323604097957, -0.3333126587081522, 0),\n              vec3(-0.46666399112693746, -0.5333323604097954, 0),\n              vec3(-0.46666399112693735, 0.5333323604097954, 0),\n              vec3(-0.40000656723388106, 0.3333272525612214, 0),\n              vec3(-0.39999927030734683, -0.3333126587081522, 0),\n              vec3(-0.376047108957707, 0.32395799889086735, 0),\n              vec3(-0.37603981203117265, -0.3239397565745309, 0),\n              vec3(-0.36667785528735286, 0.09999708122938637, 0),\n              vec3(-0.36667785528735286, 0.2999985406146932, 0),\n              vec3(-0.36667055836081863, -0.2999912436881585, 0),\n              vec3(-0.36667055836081863, -0.09998613583958423, 0),\n              vec3(-0.16667639590204597, 0.09999708122938637, 0),\n              vec3(-0.16666909897551163, -0.09998613583958423, 0),\n              vec3(-0.1427169376258718, 0.09062782755903229, 0),\n              vec3(-0.14270964069933756, -0.09060958524269572, 0),\n              vec3(-0.13334768395551777, -0.06666472081959077, 0),\n              vec3(-0.13334768395551777, 0.0666683692828582, 0),\n              vec3(-0.13334038702898343, -0.06666472081959077, 0),\n              vec3(-0.1145836373719391, -0.3999846764542776, 0),\n              vec3(0.1145799889086716, -0.3999846764542776, 0),\n              vec3(0.19999416245877244, -0.13332944163918153, 0),\n              vec3(0.2390582586614518, -0.039060447739412044, 0),\n              vec3(0.2390582586614518, -0.22759478707568356, 0),\n              vec3(0.3333126587081523, 0.000007296926534767623, 0),\n              vec3(0.3333126587081523, -0.26667347713143225, 0),\n              vec3(0.42760719185079243, -0.22759478707568356, 0),\n              vec3(0.42760719185079266, -0.039060447739412044, 0),\n              vec3(0.4666603426636702, -0.13332944163918153, 0),\n              vec3(0.4666493972738681, 0.13334768395551802, 0),\n              vec3(0.46666034266366974, 0.5333323604097954, 0),\n              vec3(0.46666034266366996, -0.5333323604097954, 0),\n              vec3(0.5057171419398148, 0.22760573246548566, 0),\n              vec3(0.5057171419398148, 0.03906774466594681, 0),\n              vec3(0.5999824873763169, 0.266669828668165, 0),\n              vec3(0.5999824873763169, 0.0000072969265345899875, 0),\n              vec3(0.694247832812819, 0.03906774466594681, 0),\n              vec3(0.694247832812819, 0.22760573246548566, 0),\n              vec3(0.7333301713318348, 0.13334768395551802, 0),\n              vec3(0.8437399667260148, 0.37708692098887947, 0),\n              vec3(0.843739966726015, -0.37707232713581035, 0),\n              vec3(1, 0.0000072969265345899875, 0));\nconst ivec3 triangles0[217] = ivec3[217](\n    ivec3(0, 151, 1), ivec3(0, 208, 151), ivec3(0, 210, 208), ivec3(1, 150, 2),\n    ivec3(1, 151, 150), ivec3(2, 149, 3), ivec3(2, 150, 205),\n    ivec3(2, 205, 149), ivec3(3, 148, 201), ivec3(3, 149, 148),\n    ivec3(4, 148, 5), ivec3(4, 201, 148), ivec3(5, 147, 6), ivec3(5, 148, 203),\n    ivec3(5, 203, 147), ivec3(6, 117, 7), ivec3(6, 118, 185),\n    ivec3(6, 132, 118), ivec3(6, 133, 132), ivec3(6, 146, 133),\n    ivec3(6, 147, 146), ivec3(6, 185, 117), ivec3(7, 106, 177),\n    ivec3(7, 107, 106), ivec3(7, 116, 183), ivec3(7, 117, 116),\n    ivec3(7, 177, 8), ivec3(7, 180, 107), ivec3(7, 183, 180), ivec3(8, 103, 9),\n    ivec3(8, 104, 175), ivec3(8, 105, 104), ivec3(8, 175, 103),\n    ivec3(8, 177, 105), ivec3(9, 103, 174), ivec3(10, 101, 11),\n    ivec3(10, 102, 171), ivec3(10, 171, 101), ivec3(10, 174, 102),\n    ivec3(11, 100, 169), ivec3(11, 101, 100), ivec3(11, 169, 12),\n    ivec3(12, 98, 13), ivec3(12, 99, 98), ivec3(12, 169, 99),\n    ivec3(13, 97, 158), ivec3(13, 98, 165), ivec3(13, 165, 97),\n    ivec3(14, 89, 15), ivec3(14, 90, 163), ivec3(14, 158, 90),\n    ivec3(14, 163, 89), ivec3(15, 88, 161), ivec3(15, 89, 88),\n    ivec3(15, 161, 16), ivec3(16, 86, 17), ivec3(16, 87, 86),\n    ivec3(16, 161, 87), ivec3(17, 85, 156), ivec3(17, 86, 159),\n    ivec3(17, 159, 85), ivec3(18, 83, 19), ivec3(18, 84, 160),\n    ivec3(18, 156, 84), ivec3(18, 160, 83), ivec3(19, 82, 162),\n    ivec3(19, 83, 82), ivec3(19, 162, 20), ivec3(20, 80, 21), ivec3(20, 81, 80),\n    ivec3(20, 162, 81), ivec3(21, 79, 157), ivec3(21, 80, 164),\n    ivec3(21, 164, 79), ivec3(22, 71, 23), ivec3(22, 72, 168),\n    ivec3(22, 157, 72), ivec3(22, 168, 71), ivec3(23, 70, 170),\n    ivec3(23, 71, 70), ivec3(23, 170, 24), ivec3(24, 68, 25), ivec3(24, 69, 68),\n    ivec3(24, 170, 69), ivec3(25, 67, 173), ivec3(25, 68, 172),\n    ivec3(25, 172, 67), ivec3(26, 65, 27), ivec3(26, 66, 176),\n    ivec3(26, 173, 66), ivec3(26, 176, 65), ivec3(27, 64, 28),\n    ivec3(27, 65, 64), ivec3(28, 63, 29), ivec3(28, 64, 178),\n    ivec3(28, 178, 63), ivec3(29, 62, 181), ivec3(29, 63, 62),\n    ivec3(29, 181, 190), ivec3(30, 52, 31), ivec3(30, 53, 52),\n    ivec3(30, 190, 53), ivec3(31, 52, 186), ivec3(31, 186, 32),\n    ivec3(32, 51, 129), ivec3(32, 128, 33), ivec3(32, 129, 128),\n    ivec3(32, 186, 51), ivec3(33, 128, 191), ivec3(34, 126, 35),\n    ivec3(34, 127, 126), ivec3(34, 191, 127), ivec3(35, 126, 196),\n    ivec3(35, 196, 36), ivec3(36, 125, 37), ivec3(36, 196, 125),\n    ivec3(37, 124, 202), ivec3(37, 125, 124), ivec3(38, 124, 197),\n    ivec3(38, 197, 39), ivec3(38, 202, 124), ivec3(39, 139, 40),\n    ivec3(39, 197, 139), ivec3(40, 139, 41), ivec3(41, 138, 211),\n    ivec3(41, 139, 138), ivec3(42, 140, 43), ivec3(42, 141, 140),\n    ivec3(42, 211, 141), ivec3(43, 140, 44), ivec3(44, 140, 207),\n    ivec3(44, 207, 45), ivec3(45, 155, 212), ivec3(45, 207, 155),\n    ivec3(46, 154, 47), ivec3(46, 155, 154), ivec3(46, 212, 155),\n    ivec3(47, 153, 48), ivec3(47, 154, 209), ivec3(47, 209, 153),\n    ivec3(48, 152, 49), ivec3(48, 153, 152), ivec3(49, 152, 208),\n    ivec3(49, 208, 210), ivec3(50, 130, 192), ivec3(50, 189, 130),\n    ivec3(50, 192, 51), ivec3(51, 192, 129), ivec3(53, 190, 184),\n    ivec3(54, 184, 190), ivec3(54, 190, 55), ivec3(55, 59, 56),\n    ivec3(55, 60, 59), ivec3(55, 190, 60), ivec3(56, 58, 57), ivec3(56, 59, 58),\n    ivec3(57, 58, 182), ivec3(60, 190, 61), ivec3(61, 190, 181),\n    ivec3(66, 173, 67), ivec3(72, 157, 73), ivec3(73, 77, 74),\n    ivec3(73, 78, 77), ivec3(73, 157, 78), ivec3(74, 76, 75), ivec3(74, 77, 76),\n    ivec3(75, 76, 167), ivec3(78, 157, 79), ivec3(84, 156, 85),\n    ivec3(90, 158, 91), ivec3(91, 96, 92), ivec3(91, 158, 96),\n    ivec3(92, 95, 93), ivec3(92, 96, 95), ivec3(93, 94, 166), ivec3(93, 95, 94),\n    ivec3(96, 158, 97), ivec3(102, 174, 103), ivec3(108, 114, 109),\n    ivec3(108, 115, 114), ivec3(108, 180, 115), ivec3(109, 113, 110),\n    ivec3(109, 114, 113), ivec3(110, 112, 111), ivec3(110, 113, 112),\n    ivec3(111, 112, 179), ivec3(115, 180, 183), ivec3(118, 132, 119),\n    ivec3(119, 132, 193), ivec3(119, 193, 188), ivec3(120, 131, 121),\n    ivec3(120, 188, 131), ivec3(121, 122, 187), ivec3(121, 123, 122),\n    ivec3(121, 130, 189), ivec3(121, 131, 130), ivec3(121, 189, 123),\n    ivec3(127, 191, 194), ivec3(128, 194, 191), ivec3(131, 188, 193),\n    ivec3(133, 146, 195), ivec3(134, 144, 135), ivec3(134, 145, 144),\n    ivec3(134, 195, 145), ivec3(135, 144, 198), ivec3(136, 142, 137),\n    ivec3(136, 143, 142), ivec3(136, 198, 143), ivec3(137, 142, 206),\n    ivec3(137, 206, 199), ivec3(138, 141, 211), ivec3(138, 199, 141),\n    ivec3(141, 199, 206), ivec3(143, 198, 204), ivec3(144, 204, 198),\n    ivec3(145, 195, 200), ivec3(146, 200, 195));\nconst int len0 = 217;\n\nbool inPath0(vec2 p) {\n  for (int i = 0; i < len0; i++) {\n    ivec3 triangle = triangles0[i];\n    vec3 a = positions0[triangle[0]];\n    vec3 b = positions0[triangle[1]];\n    vec3 c = positions0[triangle[2]];\n\n    if (pointInTriangle(vec3(p, 0.0), a, b, c)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nconst vec3 positions1[243] = vec3[243](\n    vec3(0.6265640227794649, -0.0077104606200677495, 0),\n    vec3(0.52139330834791, 0.05418292718864537, 0),\n    vec3(0.5325073619644812, 0.12817764278211752, 0),\n    vec3(0.6112351260953487, 0.28323724364681935, 0),\n    vec3(0.6075207282187939, 0.4230048497401474, 0),\n    vec3(0.5855821793098802, 0.49178738393986665, 0),\n    vec3(0.5491316407656022, 0.5499547310225501, 0),\n    vec3(0.4995536249913172, 0.5968217388970631, 0),\n    vec3(0.43797959330803216, 0.6326630340976305, 0),\n    vec3(0.37005652504751846, 0.6597061502661674, 0),\n    vec3(0.2960741758704377, 0.6787466163379832, 0),\n    vec3(0.2119326840701614, 0.6922677139705774, 0),\n    vec3(0.1658054904783856, 0.7444366913153025, 0),\n    vec3(0.1658054904783856, 0.9526734613546857, 0),\n    vec3(0.1368864941893631, 1, 0), vec3(0.009642910517663448, 1, 0),\n    vec3(-0.01927608577135915, 0.9539883797784359, 0),\n    vec3(-0.01927608577135915, 0.751537250803554, 0),\n    vec3(-0.046468190945888894, 0.7053755891150277, 0),\n    vec3(-0.11978091183113485, 0.7041740733607396, 0),\n    vec3(-0.16590073819612403, 0.7495090269577354, 0),\n    vec3(-0.16590073819612403, 0.953612782769951, 0),\n    vec3(-0.19482368121378224, 1, 0), vec3(-0.32208463049147834, 1, 0),\n    vec3(-0.35100757350913636, 0.9526734613546857, 0),\n    vec3(-0.35100757350913636, 0.7444366913153027, 0),\n    vec3(-0.3731718752960046, 0.6965814883692538, 0),\n    vec3(-0.43146400478238267, 0.6959740868322399, 0),\n    vec3(-0.5074082727642045, 0.696087160607649, 0),\n    vec3(-0.6825867175215806, 0.696920709695481, 0),\n    vec3(-0.7224000004209843, 0.6663098823980114, 0),\n    vec3(-0.7224000004209843, 0.5307886932013127, 0),\n    vec3(-0.7015553531322292, 0.49998842292933576, 0),\n    vec3(-0.6098389050617058, 0.49998842292933576, 0),\n    vec3(-0.5480524735990167, 0.49487931693178167, 0),\n    vec3(-0.4945664071297916, 0.4540123890443024, 0),\n    vec3(-0.4820221248345006, 0.36435804090705315, 0),\n    vec3(-0.4820221248345006, 0.1271959598128305, 0),\n    vec3(-0.4763075906642502, 0.0732185256284772, 0),\n    vec3(-0.46669086011320265, 0.07260994007287258, 0),\n    vec3(-0.4657892299564071, 0.07208305180002417, 0),\n    vec3(-0.47901603319040914, 0.07208305180002417, 0),\n    vec3(-0.4820221248345006, 0.05132228893947721, 0),\n    vec3(-0.4820221248345006, -0.0807916565367297, 0),\n    vec3(-0.4820221248345006, -0.2582018118904934, 0),\n    vec3(-0.4820221248345006, -0.39031575736670066, 0),\n    vec3(-0.4899803742340716, -0.43789158125945904, 0),\n    vec3(-0.5248332770266715, -0.4685470065905102, 0),\n    vec3(-0.5725720514779709, -0.47238026677780653, 0),\n    vec3(-0.6642827110131619, -0.47238026677780653, 0),\n    vec3(-0.6909487830393808, -0.5067490375244434, 0),\n    vec3(-0.7165688404195528, -0.6579716288096455, 0),\n    vec3(-0.6848305643085224, -0.6923403995562825, 0),\n    vec3(-0.5195620920398165, -0.6923403995562825, 0),\n    vec3(-0.4693061598435621, -0.692377630363078, 0),\n    vec3(-0.43625651736455356, -0.6926636366315355, 0),\n    vec3(-0.39561534235502865, -0.6931697388002365, 0),\n    vec3(-0.3631695493572619, -0.6934728475594483, 0),\n    vec3(-0.35099915382138047, -0.7413996836302328, 0),\n    vec3(-0.35099915382138047, -0.952111052524117, 0),\n    vec3(-0.3220716062869807, -1, 0), vec3(-0.1947903971356222, -1, 0),\n    vec3(-0.16586284960122247, -0.9526741191427917, 0),\n    vec3(-0.16586284960122247, -0.7444402433710744, 0),\n    vec3(-0.13777325833496454, -0.6976501309261447, 0),\n    vec3(-0.06446053744971851, -0.6982527963887959, 0),\n    vec3(-0.01923819717645761, -0.7454632354334141, 0),\n    vec3(-0.01923819717645761, -0.952863562117299, 0),\n    vec3(0.00968145690067087, -1, 0), vec3(0.13692793484003637, -1, 0),\n    vec3(0.16584758891716495, -0.952111052524117, 0),\n    vec3(0.16584758891716495, -0.7413996836302328, 0),\n    vec3(0.21374429829269775, -0.6905887756090068, 0),\n    vec3(0.3011785457936293, -0.6815858929184111, 0),\n    vec3(0.37846759577921063, -0.6679242917463906, 0),\n    vec3(0.4514904952249846, -0.647188574167977, 0),\n    vec3(0.5201747558816778, -0.6190184696375534, 0),\n    vec3(0.5784566238736036, -0.5838560117623037, 0),\n    vec3(0.6257452739240165, -0.5412335789777236, 0),\n    vec3(0.6645113581587825, -0.487742776434136, 0),\n    vec3(0.6947860557341229, -0.42297741997613025, 0),\n    vec3(0.714308680487584, -0.3478484145727956, 0),\n    vec3(0.7224000004209843, -0.22773781934296977, 0),\n    vec3(0.6953685928807327, -0.09913235117675656, 0),\n    vec3(-0.15617751175072653, 0.4868410804985298, 0),\n    vec3(-0.13243859679588785, 0.4871441892577415, 0),\n    vec3(-0.09611159085790301, 0.48771607023703534, 0),\n    vec3(-0.06366066711291019, 0.4883199197182774, 0),\n    vec3(-0.03586556758167632, 0.48865650989208065, 0),\n    vec3(-0.0010029295251085236, 0.4871518853785808, 0),\n    vec3(0.04088232012915799, 0.48365771495989074, 0),\n    vec3(0.07783632968971374, 0.47884809988696575, 0),\n    vec3(0.1091194164314417, 0.4725070225458189, 0),\n    vec3(0.142175110561025, 0.46259165619468, 0),\n    vec3(0.17695624867126805, 0.4488851938738353, 0),\n    vec3(0.20579512636898895, 0.4320585794513311, 0),\n    vec3(0.22791305409438906, 0.41192690869059134, 0),\n    vec3(0.24623850449506124, 0.3866810011850712, 0),\n    vec3(0.26073339163967124, 0.35614391193427597, 0),\n    vec3(0.2682513834599446, 0.3209913208806153, 0),\n    vec3(0.2685158800573381, 0.2852719138160763, 0),\n    vec3(0.26311504503480526, 0.25461372577497976, 0),\n    vec3(0.25231186207709516, 0.22715179591939838, 0),\n    vec3(0.2360826508123949, 0.20401330994765077, 0),\n    vec3(0.21505776958261535, 0.18511696524984378, 0),\n    vec3(0.1928066397657646, 0.1688856490632047, 0),\n    vec3(0.1692561153244636, 0.1551076193964348, 0),\n    vec3(0.1401058407373964, 0.1439912635214925, 0),\n    vec3(0.10601051250639396, 0.13546600077461146, 0),\n    vec3(0.0750703964830967, 0.12885615121338256, 0),\n    vec3(0.04724365734396759, 0.12401147603441154, 0),\n    vec3(0.014191646827777757, 0.12070306497683547, 0),\n    vec3(-0.02345073798563153, 0.11879140118338738, 0),\n    vec3(-0.05350389252689548, 0.11758343910566094, 0),\n    vec3(-0.07607700962159789, 0.11698577283261469, 0),\n    vec3(-0.10402379509005866, 0.11698577283261469, 0),\n    vec3(-0.13671033853459497, 0.11747003643619902, 0),\n    vec3(-0.1574403991352977, 0.11777551323259206, 0),\n    vec3(-0.16228869214885128, 0.1754697133306814, 0),\n    vec3(-0.16228869214885128, 0.42915227426290914, 0),\n    vec3(-0.1622906655131691, 0.48680740174750636, 0),\n    vec3(-0.16229934831616755, 0.48680740174750636, 0),\n    vec3(-0.16230132168048544, 0.4868067439594005, 0),\n    vec3(-0.16230132168048544, 0.4868038496917343, 0),\n    vec3(0.3370010282543673, -0.34508274448142084, 0),\n    vec3(0.3222831509418474, -0.36913568747802983, 0),\n    vec3(0.3039525040151388, -0.3897137332474525, 0),\n    vec3(0.2802078005249675, -0.4077356802160492, 0),\n    vec3(0.2515960570602241, -0.4232855279249468, 0),\n    vec3(0.22304910572391468, -0.43590229846951134, 0),\n    vec3(0.19457819469265017, -0.4457525437981631, 0),\n    vec3(0.1612246541087026, -0.45416236473245397, 0),\n    vec3(0.1234718266723083, -0.46126588426718174, 0),\n    vec3(0.08920527619733261, -0.4663668994710328, 0),\n    vec3(0.05844046070426499, -0.46956592036659317, 0),\n    vec3(0.0232902376877854, -0.47197118835472973, 0),\n    vec3(-0.0157354755123903, -0.4737296532983073, 0),\n    vec3(-0.04758899609957934, -0.47462819185100535, 0),\n    vec3(-0.07230426594004748, -0.4747016667824373, 0),\n    vec3(-0.10115472070843236, -0.4743921116997878, 0),\n    vec3(-0.13368905198525688, -0.4738833783786629, 0),\n    vec3(-0.15592321086897468, -0.47359224136297917, 0),\n    vec3(-0.1623097413682411, -0.41007497205716126, 0),\n    vec3(-0.1623097413682411, -0.13076367094176344, 0),\n    vec3(-0.15513939056195086, -0.06720989439606662, 0),\n    vec3(-0.12659204455277756, -0.06660893918249067, 0),\n    vec3(-0.08256253723080657, -0.06554976877432517, 0),\n    vec3(-0.04380434645331151, -0.06496381112956451, 0),\n    vec3(-0.011239362250750668, -0.06511529973035968, 0),\n    vec3(0.030238913902378175, -0.06691198216289163, 0),\n    vec3(0.0806431773165194, -0.07051245113949967, 0),\n    vec3(0.12511636271593884, -0.07590407712854974, 0),\n    vec3(0.16264337149556826, -0.08337924694312693, 0),\n    vec3(0.20199857075800384, -0.09449770774000843, 0),\n    vec3(0.2432462264011942, -0.10944857359964777, 0),\n    vec3(0.2778093077543222, -0.12777402400031979, 0),\n    vec3(0.30474559913445637, -0.1497563158182782, 0),\n    vec3(0.3269741010404631, -0.17739407243457395, 0),\n    vec3(0.34441226106504846, -0.210895154890681, 0),\n    vec3(0.3534354036293066, -0.2493612877491438, 0),\n    vec3(0.35384671853194316, -0.2868606036495136, 0),\n    vec3(0.34813422350482137, -0.31750300477606785, 0),\n    vec3(-0.7224000004209843, 0.49998842292933576, 0),\n    vec3(-0.7224000004209843, 0.6971101526699883, 0),\n    vec3(-0.7223915807332284, -0.6923403995562825, 0),\n    vec3(-0.6851260427257054, -0.47238026677780653, 0),\n    vec3(-0.5889942577729504, 0.49998842292933576, 0),\n    vec3(-0.5517287197654275, -0.47238026677780653, 0),\n    vec3(-0.4820221248345006, -0.4110765202272473, 0),\n    vec3(-0.4820221248345006, 0.07208305180002417, 0),\n    vec3(-0.4820221248345006, 0.07329548683687082, 0),\n    vec3(-0.4820221248345006, 0.41825851388301283, 0),\n    vec3(-0.48200107561511074, -0.6923403995562825, 0),\n    vec3(-0.4675949898648008, 0.6958977176331417, 0),\n    vec3(-0.46278313831231577, 0.07208305180002417, 0),\n    vec3(-0.4158938971998222, -0.6929045186359264, 0),\n    vec3(-0.35100757350913636, 0.6971101526699883, 0),\n    vec3(-0.35100757350913636, 1, 0), vec3(-0.35099915382138047, -1, 0),\n    vec3(-0.35099915382138047, -0.6935107361543498, 0),\n    vec3(-0.16590073819612403, 1, 0),\n    vec3(-0.16590073819612403, 0.7031218097276863, 0),\n    vec3(-0.16586284960122247, -0.6971143625138663, 0),\n    vec3(-0.16586284960122247, -1, 0),\n    vec3(-0.1623097413682411, -0.06728382977917291, 0),\n    vec3(-0.1623097413682411, -0.4735548132197518, 0),\n    vec3(-0.16230132168048544, 0.48680740174750636, 0),\n    vec3(-0.16230132168048544, 0.4868031919036283, 0),\n    vec3(-0.16228869214885128, 0.4868032700437427, 0),\n    vec3(-0.16228869214885128, 0.48680740174750636, 0),\n    vec3(-0.16228869214885128, 0.11781458584608417, 0),\n    vec3(-0.12081752010726649, 0.1172083683276608, 0),\n    vec3(-0.1178327407978073, -0.47413156183102956, 0),\n    vec3(-0.11482270242508058, 0.4874094094220517, 0),\n    vec3(-0.10521583869562169, -0.0660756045862041, 0),\n    vec3(-0.064919213095982, 0.1172083683276608, 0),\n    vec3(-0.06013262060676456, -0.4747419891933309, 0),\n    vec3(-0.04991532951500489, 0.48862184445889834, 0),\n    vec3(-0.027691563683360565, -0.06489263845650295, 0),\n    vec3(-0.01927608577135915, 0.7055256305819899, 0),\n    vec3(-0.01927608577135915, 1, 0), vec3(-0.01923819717645761, -1, 0),\n    vec3(-0.01923819717645761, -0.6983267975507128, 0),\n    vec3(-0.004815272050635721, 0.11961639902584231, 0),\n    vec3(0.003566527110342266, -0.47295280554520636, 0),\n    vec3(0.019812314635311676, 0.4856118060861714, 0),\n    vec3(0.05526340993144296, -0.06849626481601945, 0),\n    vec3(0.06129190636465277, 0.12623006375808576, 0),\n    vec3(0.07387091987193675, -0.4681367441488431, 0),\n    vec3(0.09372033375642268, 0.47599652266895687, 0),\n    vec3(0.12316819168261167, 0.13944897353481667, 0),\n    vec3(0.14241980773643034, -0.4579236629009613, 0),\n    vec3(0.14420899138455467, -0.07928188483130105, 0),\n    vec3(0.1598190924839553, 0.45616815800386046, 0),\n    vec3(0.1658054904783856, 1, 0),\n    vec3(0.1658054904783856, 0.6971101526699882, 0),\n    vec3(0.16584758891716495, -0.6935107361543498, 0),\n    vec3(0.16584758891716495, -1, 0),\n    vec3(0.18145769001656603, 0.1616769492103387, 0),\n    vec3(0.20912057413850832, -0.44108428738920225, 0),\n    vec3(0.2175023732994863, 0.4225188758874877, 0),\n    vec3(0.2229288620581509, -0.10152669988233476, 0),\n    vec3(0.22594732011863367, 0.19413484550925453, 0),\n    vec3(0.2541532741008302, 0.3720302182593559, 0),\n    vec3(0.25838837704203776, 0.24040944941556852, 0),\n    vec3(0.266201847279494, -0.4158420634970754, 0),\n    vec3(0.2691908364328311, 0.3017258254977615, 0),\n    vec3(0.29205028869004424, -0.1381776006836788, 0),\n    vec3(0.3136888862226546, -0.3798100097457886, 0),\n    vec3(0.3340813699673947, 0.670070325441981, 0),\n    vec3(0.3365104498849661, -0.19346969017654003, 0),\n    vec3(0.3407160839190278, -0.6754883945128896, 0),\n    vec3(0.3431325343049654, -0.33170412375257063, 0),\n    vec3(0.3545622604335719, -0.2704003772020116, 0),\n    vec3(0.455505896938812, 0.07453739078086297, 0),\n    vec3(0.4699077728452439, 0.6159738316104548, 0),\n    vec3(0.486755568044759, -0.6340003830957928, 0),\n    vec3(0.5690874847656275, 0.5222374478242475, 0),\n    vec3(0.6033177253371558, -0.5636833608025646, 0),\n    vec3(0.6129708973492717, 0.3846597498931753, 0),\n    vec3(0.6658465364561954, -0.04924464876220047, 0),\n    vec3(0.6808672594126844, -0.45671122786411456, 0),\n    vec3(0.7198967220050644, -0.30644927032881, 0));\nconst ivec3 triangles1[246] = ivec3[246](\n    ivec3(0, 158, 230), ivec3(0, 230, 1), ivec3(0, 240, 158),\n    ivec3(1, 157, 234), ivec3(1, 230, 157), ivec3(2, 100, 3),\n    ivec3(2, 101, 100), ivec3(2, 234, 101), ivec3(3, 99, 239),\n    ivec3(3, 100, 226), ivec3(3, 226, 99), ivec3(4, 98, 5), ivec3(4, 239, 98),\n    ivec3(5, 98, 237), ivec3(6, 223, 7), ivec3(6, 237, 223), ivec3(7, 97, 235),\n    ivec3(7, 223, 97), ivec3(8, 96, 9), ivec3(8, 97, 96), ivec3(8, 235, 97),\n    ivec3(9, 96, 220), ivec3(9, 220, 229), ivec3(10, 94, 11), ivec3(10, 95, 94),\n    ivec3(10, 229, 95), ivec3(11, 93, 215), ivec3(11, 94, 213),\n    ivec3(11, 213, 93), ivec3(12, 17, 13), ivec3(12, 199, 17),\n    ivec3(12, 215, 199), ivec3(13, 14, 214), ivec3(13, 15, 14),\n    ivec3(13, 16, 15), ivec3(13, 17, 16), ivec3(15, 16, 200), ivec3(18, 87, 19),\n    ivec3(18, 88, 197), ivec3(18, 197, 87), ivec3(18, 199, 88),\n    ivec3(19, 85, 181), ivec3(19, 86, 193), ivec3(19, 87, 86),\n    ivec3(19, 193, 85), ivec3(20, 24, 21), ivec3(20, 25, 24),\n    ivec3(20, 181, 25), ivec3(21, 22, 180), ivec3(21, 24, 22),\n    ivec3(22, 24, 23), ivec3(23, 24, 177), ivec3(25, 181, 176),\n    ivec3(26, 35, 27), ivec3(26, 176, 35), ivec3(27, 34, 173),\n    ivec3(27, 35, 34), ivec3(28, 34, 166), ivec3(28, 166, 29),\n    ivec3(28, 173, 34), ivec3(29, 30, 163), ivec3(29, 33, 30),\n    ivec3(29, 166, 33), ivec3(30, 33, 31), ivec3(31, 32, 162),\n    ivec3(31, 33, 32), ivec3(35, 176, 186), ivec3(35, 186, 171),\n    ivec3(36, 118, 37), ivec3(36, 119, 118), ivec3(36, 171, 119),\n    ivec3(37, 38, 170), ivec3(37, 39, 38), ivec3(37, 118, 174),\n    ivec3(37, 174, 39), ivec3(40, 42, 41), ivec3(40, 174, 42),\n    ivec3(41, 42, 169), ivec3(42, 174, 43), ivec3(43, 143, 44),\n    ivec3(43, 174, 184), ivec3(43, 184, 143), ivec3(44, 142, 45),\n    ivec3(44, 143, 142), ivec3(45, 142, 168), ivec3(46, 56, 175),\n    ivec3(46, 57, 56), ivec3(46, 168, 185), ivec3(46, 175, 47),\n    ivec3(46, 179, 57), ivec3(46, 185, 179), ivec3(47, 53, 167),\n    ivec3(47, 54, 172), ivec3(47, 55, 54), ivec3(47, 172, 53),\n    ivec3(47, 175, 55), ivec3(48, 50, 49), ivec3(48, 53, 50),\n    ivec3(48, 167, 53), ivec3(49, 50, 165), ivec3(50, 52, 51),\n    ivec3(50, 53, 52), ivec3(51, 52, 164), ivec3(58, 63, 59),\n    ivec3(58, 179, 182), ivec3(58, 182, 63), ivec3(59, 60, 178),\n    ivec3(59, 61, 60), ivec3(59, 62, 61), ivec3(59, 63, 62), ivec3(61, 62, 183),\n    ivec3(64, 139, 65), ivec3(64, 140, 192), ivec3(64, 141, 140),\n    ivec3(64, 182, 141), ivec3(64, 192, 139), ivec3(65, 137, 202),\n    ivec3(65, 138, 196), ivec3(65, 139, 138), ivec3(65, 196, 137),\n    ivec3(66, 70, 67), ivec3(66, 71, 70), ivec3(66, 202, 71),\n    ivec3(67, 68, 201), ivec3(67, 70, 68), ivec3(68, 70, 69),\n    ivec3(69, 70, 217), ivec3(71, 202, 216), ivec3(72, 130, 219),\n    ivec3(72, 131, 130), ivec3(72, 216, 131), ivec3(72, 219, 73),\n    ivec3(73, 128, 231), ivec3(73, 129, 128), ivec3(73, 219, 129),\n    ivec3(74, 127, 75), ivec3(74, 225, 127), ivec3(74, 231, 225),\n    ivec3(75, 126, 236), ivec3(75, 127, 126), ivec3(76, 125, 77),\n    ivec3(76, 228, 125), ivec3(76, 236, 228), ivec3(77, 124, 238),\n    ivec3(77, 125, 124), ivec3(78, 124, 232), ivec3(78, 232, 79),\n    ivec3(78, 238, 124), ivec3(79, 232, 241), ivec3(80, 161, 81),\n    ivec3(80, 241, 161), ivec3(81, 160, 242), ivec3(81, 161, 160),\n    ivec3(82, 159, 83), ivec3(82, 233, 159), ivec3(82, 242, 233),\n    ivec3(83, 158, 240), ivec3(83, 159, 158), ivec3(84, 181, 85),\n    ivec3(84, 188, 189), ivec3(84, 189, 181), ivec3(88, 199, 89),\n    ivec3(89, 199, 205), ivec3(90, 199, 215), ivec3(90, 205, 199),\n    ivec3(90, 215, 91), ivec3(91, 215, 209), ivec3(92, 209, 215),\n    ivec3(92, 215, 93), ivec3(95, 229, 220), ivec3(98, 223, 237),\n    ivec3(98, 239, 99), ivec3(101, 234, 224), ivec3(102, 224, 234),\n    ivec3(102, 234, 103), ivec3(103, 234, 222), ivec3(104, 222, 234),\n    ivec3(104, 234, 105), ivec3(105, 154, 221), ivec3(105, 221, 218),\n    ivec3(105, 234, 154), ivec3(106, 152, 107), ivec3(106, 153, 152),\n    ivec3(106, 218, 153), ivec3(107, 152, 212), ivec3(107, 212, 210),\n    ivec3(108, 150, 109), ivec3(108, 151, 150), ivec3(108, 210, 151),\n    ivec3(109, 150, 207), ivec3(110, 149, 111), ivec3(110, 206, 149),\n    ivec3(110, 207, 206), ivec3(111, 148, 203), ivec3(111, 149, 148),\n    ivec3(112, 148, 198), ivec3(112, 198, 113), ivec3(112, 203, 148),\n    ivec3(113, 147, 195), ivec3(113, 198, 147), ivec3(114, 146, 115),\n    ivec3(114, 195, 146), ivec3(115, 146, 194), ivec3(115, 194, 191),\n    ivec3(116, 144, 117), ivec3(116, 145, 144), ivec3(116, 191, 145),\n    ivec3(117, 144, 184), ivec3(117, 184, 190), ivec3(118, 190, 174),\n    ivec3(119, 171, 187), ivec3(119, 187, 188), ivec3(120, 121, 181),\n    ivec3(120, 181, 189), ivec3(121, 186, 181), ivec3(122, 123, 171),\n    ivec3(122, 171, 186), ivec3(123, 187, 171), ivec3(126, 228, 236),\n    ivec3(128, 225, 231), ivec3(131, 216, 211), ivec3(132, 211, 216),\n    ivec3(132, 216, 133), ivec3(133, 216, 208), ivec3(134, 202, 135),\n    ivec3(134, 208, 216), ivec3(134, 216, 202), ivec3(135, 202, 204),\n    ivec3(136, 202, 137), ivec3(136, 204, 202), ivec3(141, 182, 185),\n    ivec3(142, 185, 168), ivec3(145, 191, 194), ivec3(146, 195, 147),\n    ivec3(150, 206, 207), ivec3(151, 210, 212), ivec3(153, 218, 221),\n    ivec3(154, 234, 155), ivec3(155, 234, 227), ivec3(156, 227, 234),\n    ivec3(156, 234, 157), ivec3(160, 233, 242), ivec3(161, 241, 232),\n    ivec3(174, 190, 184), ivec3(176, 181, 186), ivec3(179, 185, 182));\nconst int len1 = 246;\n\nbool inPath1(vec2 p) {\n  for (int i = 0; i < len1; i++) {\n    ivec3 triangle = triangles1[i];\n    vec3 a = positions1[triangle[0]];\n    vec3 b = positions1[triangle[1]];\n    vec3 c = positions1[triangle[2]];\n\n    if (pointInTriangle(vec3(p, 0.0), a, b, c)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nbool resolutionChanged() {\n  return iResolution.xy !=\n         texelFetch(iChannel0, ivec2(iResolution.xy - vec2(1.0)), 0).xy;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  const float numSamp = 2.0;\n  fragColor = vec4(0.0);\n\n  if (iFrame == 0 || resolutionChanged()) {\n    for (float i = 0.0; i < numSamp; i++) {\n      for (float j = 0.0; j < numSamp; j++) {\n        vec2 uv = (fragCoord + vec2(i * 0.5, j * 0.5)) / iResolution.xy;\n\n        // Normalized pixel coordinates (from 0 to 1)\n        uv.x *= iResolution.x / iResolution.y;\n        float which = uv.x / size;\n        uv = mod(uv, size);\n        uv *= 1.0 / size * 2.0;\n        uv -= vec2(1);\n        uv *= 1.2;\n\n        if (which < 1.0) {\n          if (inPath0(uv)) {\n            fragColor += vec4(1.0);\n          }\n        } else if (which < 2.0) {\n          if (inPath1(uv)) {\n            fragColor += vec4(1.0);\n          }\n        }\n      }\n    }\n\n    fragColor = fragColor / 4.0;\n  } else {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n  }\n\n  if (ivec2(fragCoord) == ivec2(iResolution.xy - vec2(1))) {\n    fragColor = vec4(iResolution, 1.0);\n  }\n}", "buffer_c_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lKGzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[332, 332, 377, 377, 845], [847, 847, 879, 879, 990], [1078, 1078, 1138, 1138, 1334], [1336, 1336, 1368, 1368, 1403], [1405, 1405, 1446, 1446, 1551], [1553, 1553, 1599, 1599, 1656], [1658, 1658, 1724, 1724, 2033], [2035, 2035, 2060, 2060, 2098], [2100, 2100, 2121, 2121, 2206], [2208, 2208, 2229, 2229, 2329], [2331, 2331, 2352, 2352, 2437], [2439, 2439, 2460, 2460, 2560], [2562, 2562, 2583, 2583, 2668], [2670, 2670, 2691, 2691, 2791], [2793, 2793, 2814, 2814, 3987], [3989, 3989, 4044, 4044, 4464]], "test": "untested"}
{"id": "7ly3zz", "name": "nahkd's Reveal", "author": "nahkd123", "description": "Drag mouse on canvas to reveal the video.\nI used iChannel0 for the mask", "tags": ["masking", "mask"], "likes": 5, "viewed": 260, "published": 3, "date": "1637068230", "time_retrieved": "2024-07-30T18:47:50.833827", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float mixRatio = texture(iChannel0, uv).r;\n    fragColor = mix(vec4(0), texture(iChannel1, uv), clamp(mixRatio, 0.02, 1.0));\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec3 colors(vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    return 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /*// Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    vec2 off = vec2(sin(iTime * 3.14), cos(iTime * 3.14));\n    off /= 2.0;\n    uv += off;\n    \n    vec3 col = ((uv.x * uv.x) + (uv.y * uv.y)) <= 0.01? colors(fragCoord) : vec3(0);\n\n    // Output to screen\n    uv = fragCoord / iResolution.xy;\n    fragColor = mix(vec4(col, 1.0), texture(iChannel0, uv), abs(sin(iTime)) * 0.9);*/\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 finalColor = vec4(0);\n    float m = clamp(distance(fragCoord, iMouse.xy) / 30.0, 0.0, 1.0);\n    finalColor = vec4((m >= 2.0)? 0.0 : 1.0 - m);\n    \n    fragColor = mix(finalColor * 100.0, texture(iChannel0, uv), 0.99);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ly3zz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 278]], "test": "untested"}
{"id": "ft3GRM", "name": "Wine glasses", "author": "NLIBS", "description": "I felt like showing off a wine glass model I made with some style ;)\nNo caustics yet :(\n\nLook around with your mouse.", "tags": ["sdf", "glass", "pathtracer", "spectral", "importance"], "likes": 30, "viewed": 632, "published": 3, "date": "1637044649", "time_retrieved": "2024-07-30T18:47:51.663608", "image_code": "void mainImage(out vec4 O, vec2 U) {\n    O = texture(iChannel0,U/iResolution.xy);\n\tO = pow(max(O/(.2+O),0.), vec4(1./2.2)); //Tone mapping and gamma correction\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define EPS_SDF 0.001\n#define EPS_GLASS 0.003\n#define DISPERSION 1.\n#define MAXBOUNCES 13\n\nconst float pi = acos(-1.);\nconst float N_AIR = 1.;\nconst vec3 GLASS_COL = vec3(.2,.6,.8);\n\n//Wine glass SDF------------------//\n\n//Bottom edge\n#define H0 len(x-min(x,.337),y+.014)\n//Circular bottom lip\n#define H1 len(y,x-.335615)-.014142\n//Vertical distance to hyperbolic part\n#define H2 len(y-.01/min(x,.335615)+.016,x-min(x,.335615))*.9\n//Inner circlular part\n#define H3 abs(len(x,y-1.2)-.34211)\n//Rim of glass\n#define H4 len(y-1.77,x-clamp(x,.23643,.24343))\n\nfloat len(float x, float y) {return sqrt(x*x+y*y);}\n\nfloat map(vec3 p)\n{\n    float c = 1.5;\n    p.xz = mod(p.xz+.5*c,c)-.5*c;\n\n    float x=length(p.xz), y=p.y,\n          r,h,_H3; //Might need to initialise idk\n    y -= .014;\n    if (y<-.014)\n        //Below the glass\n        h = min(H0,H1);\n    else if (y<.0139)\n        //Circular bottom lip\n        h = sign(x-(.335+sqrt(.0002-y*y)))*min(H0,min(abs(H1*sign(x-.335615)),H2)); \n    else if (y<.3) {\n        //Hyperbolic base, includes some trickery to get a decent sdf\n        r = 1./(100.*y+1.6);\n        float m=-100.*r*r, m2=-1./m, c=r-m*y, c2=x-m2*y, a=max((c2-c)/(m-m2),.02);\n        h = sign(x-r)*min(min(H1,H2),len(x-(m*a+c),y-a)*.85);\n    } else if (y<1.2) {\n        //Sigmoid part, some more trickery here\n        r = .0316246+.307515/(1.+exp(14.4-16.*y));\n        h = sign(x-r)*min(min(abs(x-r)*(1.04-.5*y),_H3=H3),H1);\n        //Circular part\n        y-=1.2;\n        r = .121875-y*y;\n        if (y>-.2593)\n            h = sign(x*x-r)*abs(len(x,y)-.34911);\n        //Inside the circular part\n        if (x*x<r)\n            h = -sign(x*x-(.117039-y*y))*min(-h,_H3);\n    } else if (y<1.77) {\n        //Cubic upper part\n        r = .6077*y*y*y-2.83*y*y+4.15*y-1.6058;\n        h = (x-r)*.97;\n        if (x<r)\n            //Inside the cubic upper part\n            h = sign(x-r)*sign(x-r+.007)*min(min(r-x,abs(r-.007-x)*.97),H4);     \n    } else\n        //Above the glass\n        h = H4*.975-.001;\n    return h;\n}\n//--------------------------------//\n\n//High quality normal from finite difference\nvec3 get_norm(vec3 p)\n{\n\tvec2 t = vec2(EPS_SDF,0.);\n\treturn normalize(-vec3(map(p - t.xyy) - map(p + t.xyy),map(p - t.yxy) - map(p + t.yxy),map(p - t.yyx) - map(p + t.yyx)));\n}\n\n//Raymarching loop (I planned for adding more materials e.g. water, wine)\nvec4 march(vec3 rd, vec3 ro, float sgn)\n{\n    vec3 col = GLASS_COL;\n    float t = 0.,h;\n    for (int i = 0; i<70; i++) {\n        vec3 p = ro+rd*t;\n        h = map(p)*sgn;\n        t+=h;\n        if (h<EPS_SDF) return vec4(t,sgn>0. ? exp(-t*vec3(.15,.1,.05)) : pow(col,vec3(t)) );\n        if (h>3.9) return vec4(0,1,1,1);\n        \n    }\n    return vec4(0,1,1,1);\n}\n\n//Fresnel function\nfloat get_fresnel(vec3 rd, vec3 n, float n1, float n2)\n{\n    float cosI = abs(dot(rd, n)), cosR = n1/n2 * sqrt(1.-cosI*cosI);\n    if(cosR > 1.) return 1.;\n    cosR = sqrt(1. - cosR * cosR);\n    float Rs = (n1*cosI - n2*cosR)/(n1*cosI + n2*cosR), Rp = (n1*cosR - n2*cosI)/(n1*cosR + n2*cosI);\n    return (Rs*Rs+Rp*Rp)*.5;\n}\n\n//Hash function for anti-aliasing (https://www.shadertoy.com/view/XlXcW4)\nconst uint k2 = 1103515245U;\nvec3 hash3(uvec3 x)\n{\n    x = ((x>>8U)^x.yzx)*k2;\n    x = ((x>>8U)^x.yzx)*k2;\n    x = ((x>>8U)^x.yzx)*k2;\n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n//spectral_zucconi6 but normalized and with gamma applied ----------------//\nvec3 bump3(vec3 x, vec3 yoffset)\n{\n    vec3 y = 1. - x * x;\n    y = clamp(y-yoffset,0.,1.);\n    return y;\n}\n\nvec3 spectral(float lambda)\n{\n    float x = (lambda - 400.)/300.;\n    vec3 c1 = vec3(3.54585, 2.93225, 2.41594),\n         x1 = vec3( .69549,  .49228,  .27700),\n         y1 = vec3( .02313,  .15225,  .52608),\n         c2 = vec3(3.90307, 3.21183, 3.96587),\n         x2 = vec3( .11749,  .86755,  .66078),\n         y2 = vec3( .84897,  .88445,  .73949);\n    return pow((bump3(c1 * (x - x1), y1) + bump3(c2 * (x - x2), y2)),vec3(2.2)) * vec3(3.64499, 4.4228, 15.6893);\n}\n//------------------------------------------------------------------------//\n\n//Environment sampling\nvec3 _sample(vec3 ro, vec3 rd)\n{\n    \n    float t = max(-ro.y/rd.y,0.), c = 1.5;\n    vec3 p = ro+rd*t,\n       col = vec3(1,1,1)*step(rd.y,0.);\n    if (ivec2(p.xz*4./c)!=ivec2(0)) col /= 1.+30.*dot(p.xz,p.xz);\n    p.xz = mod(p.xz+.5*c,c)-.5*c;\n    col *= max(sign(.375-p.x)*sign(.375+p.x)*sign(.375-p.z)*sign(.375+p.z),0.)*.999*vec3(.5,.999,.999)+vec3(.5,.001,.001);    \n    return col*exp(-t*vec3(.15,.1,.05));\n}\n\n//Cauchy's equation for Borosilicate glass (BK7), also applying dispersion factor\nfloat get_n_glass(float lambda, float disp)\n{\n    return 1.5046 + .0042*disp / (lambda*lambda*1e-6);\n}\n\nvoid mainImage(out vec4 O, in vec2 U) {\n    vec2 R = iResolution.xy,\n       uv0 = (2.*U-R)/R.x;\n       \n    //Last frames colour and some mouse info\n    vec4 prev = texture(iChannel1,U/R);\n    \n    //Grab some blue noise\n    vec3 noise0 = texelFetch(iChannel0,ivec2(U)%1024,0).rgb,\n         noise = hash3(uvec3(iFrame,U))-vec3(.5,.5,0.);\n    \n    //Find camera's origin and ray direction\n    vec2 a = (iMouse.xy/R-.5)*pi*vec2(-2,.64);\n    a.y = (a.y+pi*.18);\n    if (prev.w>=0.) a = vec2(.98,.43);\n    \n    mat2 yaw = mat2(cos(a.x),sin(a.x),-sin(a.x),cos(a.x)),\n         pch = mat2(cos(a.y),sin(a.y),-sin(a.y),cos(a.y));\n    \n    vec3 ro = vec3(0,0,-2.-a.y/pi*4.);\n    ro.yz = pch*ro.yz;\n    ro.xz = yaw*ro.xz;\n    \n    vec2 uv = uv0 + noise.rg/R.x*2.;\n    vec3 rd = normalize(vec3(uv,.9));\n    rd.yz = pch * rd.yz;\n    rd.xz = yaw * rd.xz;\n    ro.y+=.9;\n\n\n    //Hit depth, pos and normal\n    float sgn = map(ro)<0. ? -1. : 1.;\n    vec4 tm = march(rd,ro,sgn);\n    float t = tm.x;\n    vec3 p = ro + rd*t,\n         n = get_norm(p),\n         col;\n    if (t>0.) {\n        //Initialise variables\n        float lambda = 400.+300.*fract(noise0.z+iTime),\n              n_glass = get_n_glass(lambda,DISPERSION),\n              b_t = t;      \n        vec3 b_rd = rd,\n             b_p = p,\n             b_n = n,\n             factor = vec3(1);\n        vec4 b_tm;        \n        \n        //Loop through light bounces\n        //Here it randomly chooses to either reflect or refract based on the fresnel factor\n        for (int branch = 0; branch<MAXBOUNCES; branch++) {\n            float n1 = (sgn>0.) ? N_AIR : n_glass,\n                  n2 = n_glass+N_AIR-n1,\n             fresnel = get_fresnel(b_rd,b_n,n1,n2),\n              choice = fract(noise0.x+1.618034*float(branch+(iFrame%10000)*MAXBOUNCES));\n            if (choice<fresnel)\n                b_rd = reflect(b_rd,b_n);\n            else {\n                b_rd = refract(b_rd,b_n,n1/n2);\n                sgn *= -1.;\n            }\n            \n            b_tm = march(b_rd,b_p+b_rd*EPS_GLASS,sgn);\n            b_t = b_tm.x;\n            factor *= b_tm.gba;\n            if (b_t==0. || branch==MAXBOUNCES-1) { col = _sample(b_p,b_rd)*factor; break; }\n\n            b_t += EPS_GLASS;\n            b_p += b_rd*b_t;\n            b_n = sgn*get_norm(b_p);\n        }\n\n        //Use as a spectral componant\n        col *= spectral(lambda);\n    } else col += _sample(ro,rd);\n    \n    //Blending with previous frame\n    float w = abs(prev.w);\n    if (iMouse.z>0.) w = 0.;\n    col = prev.rgb*w/(w+1.) + col/(w+1.);\n    w = min(w+1.,1e4);\n    if (iMouse.z>0. || prev.w<0.) w*=-1.;\n    O = vec4(col,w);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft3GRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 161]], "test": "untested"}
{"id": "ftG3zz", "name": "Woven frames", "author": "jarble", "description": "A series of frames stitched together.", "tags": ["fractal", "carpet", "frame", "rug"], "likes": 2, "viewed": 225, "published": 3, "date": "1637034358", "time_retrieved": "2024-07-30T18:47:52.450504", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/5.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime/2.+uv.x)/10.0);\n    vec3 random1 = (hash31(3.+t2)-.5)/12.;\n    vec3 random2 = (hash31(4.+t2)-.5)/12.;\n    vec3 random3 = (hash31(3.+t2)-vec3(.5))/1.5;\n    //vec3 random4 = (hash31(4.+t2)-vec3(.5))/4.;\n    \n    float offset = .5;\n    float scale2 = 1.5;\n    float bend = 1.;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        //float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            \n            for(int k = 0; k < 9; k++){    \n                uv /= -scale2;\n                //float bend = 1.+random3[k];\n                //bend = abs(fract((uv.x)*2.)-.5)/2.+1.;\n                //bend = 1.+1./3.;\n                //bend = scale2/1.5;\n                \n                //bend = abs(fract(((uv.x*bend+uv.y/bend)/scale2))-.5)+1.-col.x;\n\n                \n                uv.yx = -triangle_wave(uv.yx-offset,scale)/bend-triangle_wave(uv,scale)*bend;\n                //uv += uv.yx*col.x/2.;\n                //bend += 1./(1.+uv.x+uv.y);\n                //bend = 1./bend;\n                //bend *= -1.;\n                //uv += vec2(random1[k],random2[k]);   \n                bend *= -1.;\n                //uv /= -1.0;\n                //scale -= .001;\n                \n            }\n            \n            \n\n            //offset += .5;\n            scale /= 1.+(scale2)*col.x/(4.);\n            scale2 -= (col.x-1.)/(4.);\n\n\n            col[c] = abs((uv.x)-(uv.y));\n            //random2 = col - random2;\n            \n\n        }\n\t}\n    \n    fragColor = vec4(vec3(col*2.),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftG3zz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [590, 590, 629, 629, 674], [676, 676, 733, 733, 2567]], "test": "untested"}
{"id": "Nly3Rz", "name": "a head", "author": "jorge2017a2", "description": "a head", "tags": ["ahead"], "likes": 9, "viewed": 341, "published": 3, "date": "1637027813", "time_retrieved": "2024-07-30T18:47:53.402958", "image_code": "///-------------image\n\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define S(a,b,c) smoothstep(a,b,c)\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\nfloat sdTorus( vec3 p, vec2 t )\n\t{ vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) \n{   float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) \n{   float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) \n{   float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{ float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0); \n    p.y=p.y-10.0;\n    vec3 p0=p;\n    \n\tfloat planeDist1 = p.y+10.0;  //piso inf\n    res =opU3(res, vec3(planeDist1,-1.0,7.0)); //inf\n   \n     //cabeza \n    float dCabeza= sdEllipsoid( p- vec3(0.0,0.0,0.0), vec3(5.0,6.0,4.0) ) ;\n    \n    p.x=abs(p.x)-1.5;\n    float dOjosHueco=sdEllipsoid(p-vec3(0.0,0.0,-2.5), vec3(1.5,1.5,1.5) );\n    dCabeza= opSmoothSubtraction( dOjosHueco, dCabeza, 0.35) ;\n    \n    float t=iTime*2.0;\n    vec3 pos=vec3(0.0+0.3*sin(t),0.3*cos(t),0.0);\n    float  dIrisG=sdEllipsoid(p-vec3(0.0,0.0,-4.0)+pos, vec3(0.9,1.0,1.5) );\n    float  dPupilaCh=sdEllipsoid(p-vec3(0.0,0.0,-4.0)+pos*0.8, vec3(0.5,0.7,1.5) );\n    \n    vec3 p2=p0;\n    \n    float  dPupilaRefA=sdEllipsoid(p2-vec3(-1.7+0.25,0.25,-4.0)-vec3(pos.x,-pos.y,pos.z)*0.5, vec3(0.25,0.27,1.5) );\n    float  dPupilaRefB=sdEllipsoid(p2-vec3( 1.7-0.25,0.25,-4.0)+pos*0.5, vec3(0.25,0.27,1.5) );\n    \n    dIrisG= intersectSDF(dOjosHueco,dIrisG);\n    dPupilaCh= intersectSDF(dOjosHueco,dPupilaCh);\n    dPupilaRefA= intersectSDF(dOjosHueco,dPupilaRefA);\n    dPupilaRefB= intersectSDF(dOjosHueco,dPupilaRefB);\n    \n    p=p0;\n    float dBocaHueco=sdEllipsoid(p-vec3(0.0,-3.0,-3.0), vec3(1.5,0.8+0.3*sin(iTime),1.5) );\n    float dBocaDif=sdEllipsoid(p-vec3(0.0,-3.0,-1.5), vec3(2.5,1.0,1.6) );\n    float dBocaFondo=sdEllipsoid(p-vec3(0.0,-3.0,-1.0), vec3(2.5,1.0,1.5) );\n    float dBocaDientesA=sdEllipsoid(p-vec3(-0.5,-2.3,-1.5), vec3(0.5,0.85,1.5) );\n    float dBocaDientesB=sdEllipsoid(p-vec3( 0.0,-2.3,-1.5), vec3(0.5,0.95,1.5) );\n    float dBocaDientesC=sdEllipsoid(p-vec3( 0.5,-2.4,-1.5), vec3(0.5,0.85,1.5) );\n    \n    dCabeza= opSmoothSubtraction( dBocaHueco,dCabeza, 0.35) ;\n    dCabeza= differenceSDF(dCabeza,dBocaDif);\n    \n    vec3 prn=rotate_x(p-vec3(0.,-1.0,-2.7), radians(-30.0));\n    float dNariz= sdRoundBox(prn, vec3(0.065,0.8,1.5), 0.25 );\n    \n    dCabeza= opSmoothUnion( dCabeza, dNariz, 0.25 ) ;\n    \n    res =opU3(res, vec3(dCabeza,33.0,-1.0));\n    res =opU3(res, vec3(dOjosHueco,1.0,-1.0));\n    res =opU3(res, vec3(dIrisG,-1.0,10.0));\n    res =opU3(res, vec3(dPupilaCh,0.0,-1.0));\n    res =opU3(res, vec3(dPupilaRefA,1.0,-1.0));\n    res =opU3(res, vec3(dPupilaRefB,1.0,-1.0));\n    res =opU3(res, vec3(dBocaFondo,0.0,-1.0));\n    res =opU3(res, vec3(dBocaDientesA,1.0,-1.0));\n    res =opU3(res, vec3(dBocaDientesB,1.0,-1.0));\n    res =opU3(res, vec3(dBocaDientesC,1.0,-1.0));\n\n    //pelo\n    p=p0;\n    float dpelo1=sdTorus( p.xzy-vec3(0.0,-2.5,-0.5), vec2(5.0,0.3) );\n    vec3 pr1=rotate_y(p, radians(-10.0));\n    float dpelo2=sdTorus( pr1.xzy-vec3(0.0,-1.5,-1.5), vec2(7.0,0.28) );\n    vec3 pr2=rotate_y(p, radians(10.0));\n    float dpelo3=sdTorus( pr2.xzy-vec3(0.0,-1.5,-1.5), vec2(7.0,0.28) );\n\n    float dpelodif= sdBox( p- vec3(0.0,-5.5,0.0), vec3(8.0,3.0,3.0) );\n    dpelo1= differenceSDF(dpelo1,dpelodif);\n    dpelo2= differenceSDF(dpelo2,dpelodif);\n    dpelo3= differenceSDF(dpelo3,dpelodif);\n    res =opU3(res, vec3(dpelo1,2.0,-1.0));\n    res =opU3(res, vec3(dpelo2,5.0,-1.0));\n    res =opU3(res, vec3(dpelo3,6.0,-1.0));\n    \n    //ceja\n    p.x=abs(p.x)-2.0;\n    float dCeja= sdBox( p-vec3(0.0,2.0,-2.0), vec3(1.0,0.125,2.0) );\n    dCeja= intersectSDF(dCeja,dCabeza);\n    \n    res =opU3(res, vec3(dCeja,0.0,-1.0));\n    \n    return res;\n}\n\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0,minDist = 9999.0;\n    vec3 p;\n\n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{   vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n\n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n\n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n\n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n\n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n\n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n\n    if (mObj.blnShadow==true)\n        {fshadow=GetShadow(p,lp);}\n    else\n        {fshadow=0.5;}\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    lin += 0.4*pow(clamp(dot(hal,n),0.0,1.0),12.0)*dif3;\n      lin *= atten*0.5*col*fshadow;\n    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    lin = pow(lin,vec3(0.4545));\n \n    return lin;\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    if (id_material==7.0)\n    {return pattern( p.xz );}\n    \n    if (id_material==8.0)\n    {return pattern( p.xy );}\n    \n    if (id_material==9.0)\n    {return pattern( p.zy );}\n    \n    if (id_material==10.0)\n    {  vec3 blue = vec3(0.3, 0.8, 1.0);\n       vec3 blue2 = vec3(0.1, 0.2, 0.8);\n       return  mix(blue, blue2, S(0.1, 1.3,mObj.uv.y * 5.0));\n    }\n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n\n    if( mObj.hitbln==false) return  render_sky_color(rd);\n\n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n\n    if (id_material>-1.0 && id_color==-1)\n        {   colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n\n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n\n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n\n \tlight_pos1= vec3(5.0, 10.0, -20.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 30.0, -25.0 ); light_color2 =vec3( 1.0 ); \n\n   vec3 ro=vec3(0.0,9.0,-15.0);\n\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n\n    //light_pos1+=ro;\n    //light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    //col = exposureToneMapping(2.0, col);\n    col = linear2srgb(col);    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------common\n///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) , //32\nvec3(1.0, 0.58, 0.58), //33  //piel\nvec3(0.3, 0.8, 1.0),  //34\nvec3(0.1, 0.2, 0.8)  //35\n);\n\n\n//vec3 blue = vec3(0.3, 0.8, 1.0);\n//vec3 blue2 = vec3(0.1, 0.2, 0.8);\n        \n//vec3(1.0, 0.78, 0.8) //33\n\n///mat = PBRMat(vec3(1.0, 0.78, 0.8), 0.1, 0.3);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nly3Rz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[520, 520, 556, 556, 577], [578, 578, 610, 610, 694], [695, 695, 741, 741, 828], [829, 829, 863, 863, 925], [926, 926, 965, 965, 1060], [1061, 1061, 1100, 1100, 1195], [1196, 1196, 1235, 1235, 1330], [1335, 1335, 1388, 1388, 1485], [1487, 1487, 1546, 1546, 1644], [1646, 1646, 1706, 1706, 1803], [1805, 1805, 1842, 1842, 1923], [1925, 1969, 2016, 2016, 2043], [2044, 2044, 2087, 2087, 2114], [2115, 2115, 2163, 2163, 2191], [2193, 2218, 2252, 2252, 2348], [2349, 2349, 2383, 2383, 2474], [2475, 2475, 2509, 2509, 2600], [2602, 2602, 2627, 2627, 5903], [5906, 5906, 5930, 5930, 6092], [6094, 6094, 6143, 6143, 6758], [6760, 6760, 6796, 6796, 7041], [7043, 7043, 7070, 7070, 7087], [7089, 7089, 7125, 7125, 7217], [7218, 7218, 7264, 7264, 7389], [7391, 7391, 7465, 7465, 9003], [9005, 9005, 9085, 9085, 9208], [9210, 9210, 9242, 9242, 9439], [9441, 9489, 9517, 9517, 9705], [9707, 9707, 9754, 9754, 10164], [10166, 10166, 10259, 10259, 10577], [10579, 10579, 10610, 10610, 11199], [11201, 11250, 11276, 11276, 11386], [11388, 11388, 11446, 11446, 11498], [11500, 11500, 11557, 11557, 12131]], "test": "untested"}
{"id": "flyGRz", "name": "A green thing - Variation Zero", "author": "PauloFalcao", "description": "Greetings to all at scene.pt!!!! Original https://www.shadertoy.com/view/st3GDs\nAfter some chat at the scene.pt discord I made a few changes to the original shader, this is the result", "tags": ["materialmaker", "nodes", "scenept"], "likes": 12, "viewed": 533, "published": 3, "date": "1637022009", "time_retrieved": "2024-07-30T18:47:54.547896", "image_code": "// A green thing in a bathroom - Variation Zero\n//\n// By https://twitter.com/paulofalcao\n//\n// Greetings to all at scene.pt!!!!\n//\n// Original https://www.shadertoy.com/view/st3GDs\n// After some chat at the scene.pt discord\n// I made a few changes to the original shader, this is the result :)\n//\n// This uses the MFSDF scene description technique\n// https://www.shadertoy.com/view/7dySRc\n//\n// Generated in Material Maker\n//\n// To generate your own shaders you need:\n//\n// - Material Maker - https://rodzilla.itch.io/material-maker\n// - My Ray Marching library - https://github.com/paulofalcao/MaterialMakerRayMarching\n// \n// Here is a 2 hour video explaining how to use it - https://youtu.be/PvmIohbf93Q\n// \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec4 color = texture(iChannel0, fragCoord / iResolution.xy);\n    fragColor = vec4(pow(color.xyz/color.w,vec3(1.0/2.2)), 1.0f);\n     \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/* Generated by Material Maker */\n\n#define SEED_VARIATION 0.0\n\n//---\n\nfloat rand(vec2 x) {\n    return fract(cos(mod(dot(x, vec2(13.9898, 8.141)), 3.14)) * 43758.5453);\n}\n\nvec2 rand2(vec2 x) {\n    return fract(cos(mod(vec2(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t      dot(x, vec2(3.4562, 17.398))), vec2(3.14))) * 43758.5453);\n}\n\nvec3 rand3(vec2 x) {\n    return fract(cos(mod(vec3(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t\t  dot(x, vec2(3.4562, 17.398)),\n                              dot(x, vec2(13.254, 5.867))), vec3(3.14))) * 43758.5453);\n}\n\nvec3 rgb2hsv(vec3 c) {\n\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n\tvec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat param_rnd(float minimum, float maximum, float seed) {\n\treturn minimum+(maximum-minimum)*rand(vec2(seed));\n}\n//Adapted from https://iquilezles.org/articles/distfunctions - Finite Repetition\n\nvec3 opRepLim(vec3 p,vec3 c,vec3 l){\n    p+=(c*l)/2.0;\n    return p-c*clamp(floor(p/c+0.5),vec3(0.0),l);\n}vec3 MFSDF_Obj_Maker_rotate3d(vec3 p, vec3 a) {\n\tvec3 rv;\n\tfloat c;\n\tfloat s;\n\tc = cos(a.x);\n\ts = sin(a.x);\n\trv.x = p.x;\n\trv.y = p.y*c+p.z*s;\n\trv.z = -p.y*s+p.z*c;\n\tc = cos(a.y);\n\ts = sin(a.y);\n\tp.x = rv.x*c+rv.z*s;\n\tp.y = rv.y;\n\tp.z = -rv.x*s+rv.z*c;\n\tc = cos(a.z);\n\ts = sin(a.z);\n\trv.x = p.x*c+p.y*s;\n\trv.y = -p.x*s+p.y*c;\n\trv.z = p.z;\n\treturn rv;\n}\nvec4 brick(vec2 uv, vec2 bmin, vec2 bmax, float mortar, float round, float bevel) {\n\tfloat color;\n\tvec2 size = bmax - bmin;\n\tfloat min_size = min(size.x, size.y);\n\tmortar *= min_size;\n\tbevel *= min_size;\n\tround *= min_size;\n\tvec2 center = 0.5*(bmin+bmax);\n    vec2 d = abs(uv-center)-0.5*(size)+vec2(round+mortar);\n    color = length(max(d,vec2(0))) + min(max(d.x,d.y),0.0)-round;\n\tcolor = clamp(-color/bevel, 0.0, 1.0);\n\tvec2 tiled_brick_pos = mod(bmin, vec2(1.0, 1.0));\n\treturn vec4(color, center, tiled_brick_pos.x+7.0*tiled_brick_pos.y);\n}\n\nvec3 brick_random_color(vec2 bmin, vec2 bmax, float seed) {\n\tvec2 center = 0.5*(bmin + bmax);\n\treturn rand3(fract(center + vec2(seed)));\n}\n\nvec3 brick_uv(vec2 uv, vec2 bmin, vec2 bmax, float seed) {\n\tvec2 center = 0.5*(bmin + bmax);\n\tvec2 size = bmax - bmin;\n\tfloat max_size = max(size.x, size.y);\n\treturn vec3(0.5+(uv-center)/max_size, rand(fract(center)+vec2(seed)));\n}\n\nvec3 brick_corner_uv(vec2 uv, vec2 bmin, vec2 bmax, float mortar, float corner, float seed) {\n\tvec2 center = 0.5*(bmin + bmax);\n\tvec2 size = bmax - bmin;\n\tfloat max_size = max(size.x, size.y);\n\tfloat min_size = min(size.x, size.y);\n\tmortar *= min_size;\n\tcorner *= min_size;\n\treturn vec3(clamp((0.5*size-vec2(mortar)-abs(uv-center))/corner, vec2(0.0), vec2(1.0)), rand(fract(center)+vec2(seed)+ceil(vec2(uv-center))));\n}\n\nvec4 bricks_rb(vec2 uv, vec2 count, float repeat, float offset) {\n\tcount *= repeat;\n\tfloat x_offset = offset*step(0.5, fract(uv.y*count.y*0.5));\n\tvec2 bmin = floor(vec2(uv.x*count.x-x_offset, uv.y*count.y));\n\tbmin.x += x_offset;\n\tbmin /= count;\n\treturn vec4(bmin, bmin+vec2(1.0)/count);\n}\n\nvec4 bricks_rb2(vec2 uv, vec2 count, float repeat, float offset) {\n\tcount *= repeat;\n\tfloat x_offset = offset*step(0.5, fract(uv.y*count.y*0.5));\n\tcount.x = count.x*(1.0+step(0.5, fract(uv.y*count.y*0.5)));\n\tvec2 bmin = floor(vec2(uv.x*count.x-x_offset, uv.y*count.y));\n\tbmin.x += x_offset;\n\tbmin /= count;\n\treturn vec4(bmin, bmin+vec2(1.0)/count);\n}\n\nvec4 bricks_hb(vec2 uv, vec2 count, float repeat, float offset) {\n\tfloat pc = count.x+count.y;\n\tfloat c = pc*repeat;\n\tvec2 corner = floor(uv*c);\n\tfloat cdiff = mod(corner.x-corner.y, pc);\n\tif (cdiff < count.x) {\n\t\treturn vec4((corner-vec2(cdiff, 0.0))/c, (corner-vec2(cdiff, 0.0)+vec2(count.x, 1.0))/c);\n\t} else {\n\t\treturn vec4((corner-vec2(0.0, pc-cdiff-1.0))/c, (corner-vec2(0.0, pc-cdiff-1.0)+vec2(1.0, count.y))/c);\n\t}\n}\n\nvec4 bricks_bw(vec2 uv, vec2 count, float repeat, float offset) {\n\tvec2 c = 2.0*count*repeat;\n\tfloat mc = max(c.x, c.y);\n\tvec2 corner1 = floor(uv*c);\n\tvec2 corner2 = count*floor(repeat*2.0*uv);\n\tfloat cdiff = mod(dot(floor(repeat*2.0*uv), vec2(1.0)), 2.0);\n\tvec2 corner;\n\tvec2 size;\n\tif (cdiff == 0.0) {\n\t\tcorner = vec2(corner1.x, corner2.y);\n\t\tsize = vec2(1.0, count.y);\n\t} else {\n\t\tcorner = vec2(corner2.x, corner1.y);\n\t\tsize = vec2(count.x, 1.0);\n\t}\n\treturn vec4(corner/c, (corner+size)/c);\n}\n\nvec4 bricks_sb(vec2 uv, vec2 count, float repeat, float offset) {\n\tvec2 c = (count+vec2(1.0))*repeat;\n\tfloat mc = max(c.x, c.y);\n\tvec2 corner1 = floor(uv*c);\n\tvec2 corner2 = (count+vec2(1.0))*floor(repeat*uv);\n\tvec2 rcorner = corner1 - corner2;\n\tvec2 corner;\n\tvec2 size;\n\tif (rcorner.x == 0.0 && rcorner.y < count.y) {\n\t\tcorner = corner2;\n\t\tsize = vec2(1.0, count.y);\n\t} else if (rcorner.y == 0.0) {\n\t\tcorner = corner2+vec2(1.0, 0.0);\n\t\tsize = vec2(count.x, 1.0);\n\t} else if (rcorner.x == count.x) {\n\t\tcorner = corner2+vec2(count.x, 1.0);\n\t\tsize = vec2(1.0, count.y);\n\t} else if (rcorner.y == count.y) {\n\t\tcorner = corner2+vec2(0.0, count.y);\n\t\tsize = vec2(count.x, 1.0);\n\t} else {\n\t\tcorner = corner2+vec2(1.0);\n\t\tsize = vec2(count.x-1.0, count.y-1.0);\n\t}\n\treturn vec4(corner/c, (corner+size)/c);\n}// https://www.shadertoy.com/view/XsX3zB\n//\n// The MIT License\n// Copyright © 2013 Nikita Miropolskiy\n// \n// ( license has been changed from CCA-NC-SA 3.0 to MIT\n//\n//   but thanks for attributing your source code when deriving from this sample \n//   with a following link: https://www.shadertoy.com/view/XsX3zB )\n//\n//\n// if you're looking for procedural noise implementation examples you might \n// also want to look at the following shaders:\n// \n// Noise Lab shader by candycat: https://www.shadertoy.com/view/4sc3z2\n//\n// Noise shaders by iq:\n//     Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n//     Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n//     Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n//     Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n//     Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n//     Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n//     Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n//     Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n//     Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n//     Voronoise: https://www.shadertoy.com/view/Xd23Dh\n//\n//\n//\n\n// discontinuous pseudorandom constly distributed in [-0.5, +0.5]^3 */\nvec3 XsX3zB_oct_random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n// skew constants for 3d simplex functions\nconst float XsX3zB_oct_F3 =  0.3333333;\nconst float XsX3zB_oct_G3 =  0.1666667;\n\n// 3d simplex noise\nfloat XsX3zB_oct_simplex3d(vec3 p) {\n\t // 1. find current tetrahedron T and it's four vertices\n\t // s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices\n\t // x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices\n\t \n\t // calculate s and x\n\t vec3 s = floor(p + dot(p, vec3(XsX3zB_oct_F3)));\n\t vec3 x = p - s + dot(s, vec3(XsX3zB_oct_G3));\n\t \n\t // calculate i1 and i2\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t // x1, x2, x3\n\t vec3 x1 = x - i1 + XsX3zB_oct_G3;\n\t vec3 x2 = x - i2 + 2.0*XsX3zB_oct_G3;\n\t vec3 x3 = x - 1.0 + 3.0*XsX3zB_oct_G3;\n\t \n\t // 2. find four surflets and store them in d\n\t vec4 w, d;\n\t \n\t // calculate surflet weights\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t // w fades from 0.6 at the center of the surflet to 0.0 at the margin\n\t w = max(0.6 - w, 0.0);\n\t \n\t // calculate surflet components\n\t d.x = dot(XsX3zB_oct_random3(s), x);\n\t d.y = dot(XsX3zB_oct_random3(s + i1), x1);\n\t d.z = dot(XsX3zB_oct_random3(s + i2), x2);\n\t d.w = dot(XsX3zB_oct_random3(s + 1.0), x3);\n\t \n\t // multiply d by w^4\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t // 3. return the sum of the four surflets\n\t return dot(d, vec4(52.0));\n}vec2 transform2_clamp(vec2 uv) {\n\treturn clamp(uv, vec2(0.0), vec2(1.0));\n}\n\nvec2 transform2(vec2 uv, vec2 translate, float rotate, vec2 scale) {\n \tvec2 rv;\n\tuv -= translate;\n\tuv -= vec2(0.5);\n\trv.x = cos(rotate)*uv.x + sin(rotate)*uv.y;\n\trv.y = -sin(rotate)*uv.x + cos(rotate)*uv.y;\n\trv /= scale;\n\trv += vec2(0.5);\n\treturn rv;\t\n}vec4 sdf3dc_union(vec4 a, vec4 b) {\n\treturn vec4((a.w<b.w)?vec4(a):vec4(b));\n}\nvec4 sdf3dc_sub(vec4 a, vec4 b) {\n\treturn vec4((-a.w>b.w)?vec4(a.xyz,-a.w):vec4(b));\n}\nvec4 sdf3dc_inter(vec4 a, vec4 b) {\n\treturn vec4((a.w>b.w)?vec4(a):vec4(b));\n}vec3 v4v4_rotate(vec3 p, vec3 a) {\n\tvec3 rv;\n\tfloat c;\n\tfloat s;\n\tc = cos(a.x);\n\ts = sin(a.x);\n\trv.x = p.x;\n\trv.y = p.y*c+p.z*s;\n\trv.z = -p.y*s+p.z*c;\n\tc = cos(a.y);\n\ts = sin(a.y);\n\tp.x = rv.x*c+rv.z*s;\n\tp.y = rv.y;\n\tp.z = -rv.x*s+rv.z*c;\n\tc = cos(a.z);\n\ts = sin(a.z);\n\trv.x = p.x*c+p.y*s;\n\trv.y = -p.x*s+p.y*c;\n\trv.z = p.z;\n\treturn rv;\n}\nfloat mfsdf3d_smooth_union_f(float a,float b,float k){\n\tfloat h = max( k-abs(a-b), 0.0 )/k;\n\treturn min(a,b)-h*h*k*0.25;\n}\n\nvec4 mfsdf3d_smooth_union(vec4 a, vec4 b, float k) {\n    float e=0.001;\n    k=max(k,e);\n    float h=mfsdf3d_smooth_union_f(a.w,b.w,k);\n\tvec2 n=normalize(vec2(mfsdf3d_smooth_union_f(a.w+e,b.w,k)-mfsdf3d_smooth_union_f(a.w-e,b.w,k),\n                          mfsdf3d_smooth_union_f(a.w,b.w+e,k)-mfsdf3d_smooth_union_f(a.w,b.w-e,k)));\n    return vec4(mix(a.xyz,b.xyz,atan(abs(n.y),abs(n.x))/(3.14159265359/2.0)),h);\n}\n\nfloat mfsdf3d_smooth_subtraction_f(float a,float b,float k){\n\tfloat h = max( k-abs(-a-b), 0.0 )/k;\n\treturn max(-a,b)+h*h*k*0.25;\n}\n\nvec4 mfsdf3d_smooth_subtraction(vec4 a, vec4 b, float k) {\n    float e=0.001;\n    k=max(k,e);\n\tfloat h=mfsdf3d_smooth_subtraction_f(a.w,b.w,k);\n\tvec2 n=normalize(vec2(mfsdf3d_smooth_subtraction_f(a.w+e,b.w,k)-mfsdf3d_smooth_subtraction_f(a.w-e,b.w,k),\n                          mfsdf3d_smooth_subtraction_f(a.w,b.w+e,k)-mfsdf3d_smooth_subtraction_f(a.w,b.w-e,k)));\n    return vec4(mix(a.xyz,b.xyz,atan(abs(n.y),abs(n.x))/(3.14159265359/2.0)),h);\n}\n\nfloat mfsdf3d_smooth_intersection_f(float a,float b,float k){\n\tfloat h = max( k-abs(a-b), 0.0 )/k;\n\treturn max(a,b)+h*h*k*0.25;\n}\n\nvec4 mfsdf3d_smooth_intersection(vec4 a, vec4 b, float k) {\n    float e=0.001;\n    k=max(k,e);\n\tfloat h=mfsdf3d_smooth_intersection_f(a.w,b.w,k);\n\tvec2 n=normalize(vec2(mfsdf3d_smooth_intersection_f(a.w+e,b.w,k)-mfsdf3d_smooth_intersection_f(a.w-e,b.w,k),\n                          mfsdf3d_smooth_intersection_f(a.w,b.w+e,k)-mfsdf3d_smooth_intersection_f(a.w,b.w-e,k)));\n    return vec4(mix(a.xyz,b.xyz,atan(abs(n.y),abs(n.x))/(3.14159265359/2.0)),h);\n}vec2 twist_rot(vec2 v, float a) {\n\ta=a*0.01745329251;\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(vec2(c, -s),vec2(s, c));\n\treturn m * v;\n}\n\nvec3 twistX(vec3 v, float a){\n\tv.yz=twist_rot(v.yz,v.x*a);\n\treturn v;\n}\n\nvec3 twistY(vec3 v, float a){\n\tv.xz=twist_rot(v.xz,v.y*a);\n\treturn v;\n}\n\nvec3 twistZ(vec3 v, float a){\n\tv.xy=twist_rot(v.xy,v.z*a);\n\treturn v;\n}\n\nvec4 MFSDF_Union(vec4 in1,vec4 in2,vec4 in3,vec4 in4,vec4 in5,vec4 in6,vec4 in7,vec4 in8){\n    vec4 t=(in1.w<in2.w)?vec4(in1):vec4(in2);\n    t=(t.w<in2.w)?vec4(t):vec4(in2);\n    t=(t.w<in3.w)?vec4(t):vec4(in3);\n    t=(t.w<in4.w)?vec4(t):vec4(in4);\n    t=(t.w<in5.w)?vec4(t):vec4(in5);\n    t=(t.w<in6.w)?vec4(t):vec4(in6);\n    t=(t.w<in7.w)?vec4(t):vec4(in7);\n    t=(t.w<in8.w)?vec4(t):vec4(in8);\n    return t;\n}\n\n\n//MATH\nconst float PI=3.14159265359;\nconst float TAU=6.28318530718;\n\nvec2 rndint_hash23(vec3 p3){\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvoid Onb(in vec3 N, inout vec3 T, inout vec3 B){\n    vec3 UpVector=abs(N.z)<0.999?vec3(0,0,1):vec3(1,0,0);\n    T=normalize(cross(UpVector,N));\n    B=cross(N,T);\n}\n\nvec2 equirectangularMap(vec3 dir) {\n\tvec2 longlat = vec2(atan(dir.y,dir.x),acos(dir.z));\n \treturn longlat/vec2(2.0*PI,PI);\n}\n\n// RANDOM START\n//from https://www.reedbeta.com/blog/hash-functions-for-gpu-rendering/\nuint rand_pcg(inout uint seed){\n    uint state = seed;\n    seed = seed * uint(747796405) + uint(2891336453);\n    uint word = ((state >> ((state >> uint(28)) + uint(4))) ^ state) * uint(277803737);\n    return (word >> uint(22)) ^ word;\n}\n\nfloat RandomFloat01(inout uint state){\n    uint r=rand_pcg(state);\n    r &= uint(0x007FFFFF);\n    r |= uint(0x3F800000);\n    return uintBitsToFloat(r) - 1.0f;\n}\n\n// RANDOM END\n\n// SAMPLING START\n\nvec3 constSampleSphere(float r1,float r2){\n    float z=1.0-2.0*r1;\n    float r=sqrt(max(0.0,1.0-z*z));\n    float phi=TAU*r2;\n    return vec3(r*cos(phi),r*sin(phi),z);\n}\n\nvec3 cosineSampleHemissphere(inout uint state,vec3 n){\n    float u1=RandomFloat01(state);\n    float u2=RandomFloat01(state);\n    return normalize(n+constSampleSphere(u1,u2)); \n}\n\n// Adapted from \"Sampling the GGX Distribution of Visible Normals\",\n// http://jcgt.org/published/0007/04/01/\nvec3 SampleGGXVNDF(inout uint state,vec3 Ve,float alpha_x,float alpha_y){\n    float U1=RandomFloat01(state);\n    float U2=RandomFloat01(state);\n    \n    //transforming the view direction to the hemisphere configuration\n    vec3 Vh = normalize(vec3(alpha_x * Ve.x, alpha_y * Ve.y, Ve.z));\n\n    //orthonormal basis\n    vec3 T1;vec3 T2;\n    Onb(Vh,T1,T2);\n\n    //parameterization of the projected area\n    float r = sqrt(U1); \n    float phi = 2.0 * PI * U2;    \n    float t1 = r * cos(phi);\n    float t2 = r * sin(phi);\n    float s = 0.5 * (1.0 + Vh.z);\n    t2 = (1.0 - s)*sqrt(1.0 - t1*t1) + s*t2;\n\n    //reprojection onto hemisphere\n    vec3 Nh = t1*T1 + t2*T2 + sqrt(max(0.0f, 1.0f - t1*t1 - t2*t2))*Vh;\n\n    //transforming the normal back to the ellipsoid configuration\n    vec3 Ne = normalize(vec3(alpha_x * Nh.x, alpha_y * Nh.y, max(0.0f, Nh.z))); \n\n    return Ne;\n}\n\nfloat schlickWeight(float cosTheta) {\n    float m=clamp(1.-cosTheta,0.,1.);\n    float m2=m*m;\n    return m2*m2*m;\n}\n\n// SAMPLING END\n\nconst float p_o6428_CamX = -3.601000000;\nconst float p_o6428_CamY = 2.357000000;\nconst float p_o6428_CamZ = 2.873000000;\nconst float p_o6428_LookAtX = 1.851000000;\nconst float p_o6428_LookAtY = 0.740000000;\nconst float p_o6428_LookAtZ = -0.406000000;\nconst float p_o6428_CamD = 1.133000000;\nconst float p_o6428_CamZoom = 1.000000000;\nconst float p_o6428_MaxDistance = 200.000000000;\nconst float p_o6441_BaseColor_r = 1.000000000;\nconst float p_o6441_BaseColor_g = 1.000000000;\nconst float p_o6441_BaseColor_b = 1.000000000;\nconst float p_o6441_BaseColor_a = 1.000000000;\nconst float p_o6441_Metallic = 0.000000000;\nconst float p_o6441_Specular = 0.500000000;\nconst float p_o6441_Roughness = 0.000000000;\nconst float p_o6441_Emission = 10.000000000;\nconst float p_o6441_Normal = 0.000000000;\nconst float p_o6441_Alpha = 0.000000000;\nconst float p_o6441_AmbientOcclusion = 0.000000000;\nconst float p_o6441_scale = 1.000000000;\nconst float p_o6441_TranlateX = 0.000000000;\nconst float p_o6441_TranlateY = 3.722000000;\nconst float p_o6441_TranlateZ = 0.000000000;\nconst float p_o6441_RotateX = 0.000000000;\nconst float p_o6441_RotateY = 0.000000000;\nconst float p_o6441_RotateZ = 0.000000000;\nvec3 o6441_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nfloat o6441_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o6441_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o6441_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o6441_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o6441_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o6441_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o6441_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o6440_X = 1.000000000;\nconst float p_o6440_Y = 1.000000000;\nconst float p_o6440_Z = 0.400000000;\nconst float p_o6440_RepX = 1.000000000;\nconst float p_o6440_RepY = 1.000000000;\nconst float p_o6440_RepZ = 6.000000000;\nconst float p_o6439_l = 2.570000000;\nconst float p_o6439_r = 0.100000000;\nfloat o6441_input_sdf3d(vec3 p, float _seed_variation_) {\nvec2 o6439_0_d = abs(vec2(length((opRepLim((p),vec3(p_o6440_X,p_o6440_Y,p_o6440_Z)*2.0,vec3(p_o6440_RepX-1.0,p_o6440_RepY-1.0,p_o6440_RepZ-1.0))).yz),(opRepLim((p),vec3(p_o6440_X,p_o6440_Y,p_o6440_Z)*2.0,vec3(p_o6440_RepX-1.0,p_o6440_RepY-1.0,p_o6440_RepZ-1.0))).x)) - vec2(p_o6439_r,p_o6439_l);\nfloat o6439_0_1_sdf3d = min(max(o6439_0_d.x,o6439_0_d.y),0.0) + length(max(o6439_0_d,0.0));\nfloat o6440_0_1_sdf3d = o6439_0_1_sdf3d;\n\nreturn o6440_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o6441(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o6441_TranlateX,p_o6441_TranlateY,p_o6441_TranlateZ),vec3(p_o6441_RotateX,p_o6441_RotateY,p_o6441_RotateZ)*6.28318530718)/p_o6441_scale;\n\tfloat sdf=o6441_input_sdf3d(uv.xyz, _seed_variation_)*p_o6441_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o6441_AmbientOcclusion*o6441_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o6441_Alpha*o6441_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o6441_Normal*o6441_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o6441_Emission*o6441_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o6441_Roughness*o6441_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o6441_Specular*o6441_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o6441_Metallic*o6441_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o6441_BaseColor_r, p_o6441_BaseColor_g, p_o6441_BaseColor_b, p_o6441_BaseColor_a).rgb*o6441_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}const float p_o6466_x = 3.701340000;\nconst float p_o6466_y = 0.000000000;\nconst float p_o6466_z = 0.000000000;\nconst float p_o6454_BaseColor_r = 1.000000000;\nconst float p_o6454_BaseColor_g = 1.000000000;\nconst float p_o6454_BaseColor_b = 1.000000000;\nconst float p_o6454_BaseColor_a = 1.000000000;\nconst float p_o6454_Metallic = 0.705000000;\nconst float p_o6454_Specular = 0.373000000;\nconst float p_o6454_Roughness = 1.000000000;\nconst float p_o6454_Emission = 0.000000000;\nconst float p_o6454_Normal = 0.000000000;\nconst float p_o6454_Alpha = 0.000000000;\nconst float p_o6454_AmbientOcclusion = 0.000000000;\nconst float p_o6454_scale = 1.000000000;\nconst float p_o6454_TranlateX = 0.000000000;\nconst float p_o6454_TranlateY = 0.000000000;\nconst float p_o6454_TranlateZ = 0.000000000;\nconst float p_o6454_RotateX = 0.000000000;\nconst float p_o6454_RotateY = 0.000000000;\nconst float p_o6454_RotateZ = 0.000000000;\nconst float p_o6491_translate_x = -0.530000000;\nconst float p_o6491_translate_y = -0.010000000;\nconst float p_o6489_translate_x = 6.470000000;\nconst float p_o6489_translate_y = 3.123150000;\nconst float p_o6489_rotate = 197.957800000;\nconst float p_o6489_scale_x = 1.000000000;\nconst float p_o6489_scale_y = 1.000000000;\nconst float seed_o6487 = 0.692989000;\nconst float p_o6487_repeat = 1.000000000;\nconst float p_o6487_rows = 1.930000000;\nconst float p_o6487_columns = 1.930000000;\nconst float p_o6487_row_offset = 1.000000000;\nconst float p_o6487_mortar = 0.000000000;\nconst float p_o6487_bevel = 0.000000000;\nconst float p_o6487_round = 0.000000000;\nconst float p_o6487_corner = 0.000000000;\nconst float p_o6488_f = 0.000000000;\nconst float p_o6473_g_0_pos = 0.190909000;\nconst float p_o6473_g_0_r = 1.000000000;\nconst float p_o6473_g_0_g = 1.000000000;\nconst float p_o6473_g_0_b = 1.000000000;\nconst float p_o6473_g_0_a = 1.000000000;\nconst float p_o6473_g_1_pos = 0.390909000;\nconst float p_o6473_g_1_r = 0.507812977;\nconst float p_o6473_g_1_g = 0.451000005;\nconst float p_o6473_g_1_b = 0.353087991;\nconst float p_o6473_g_1_a = 1.000000000;\nconst float p_o6473_g_2_pos = 0.663636000;\nconst float p_o6473_g_2_r = 1.000000000;\nconst float p_o6473_g_2_g = 1.000000000;\nconst float p_o6473_g_2_b = 1.000000000;\nconst float p_o6473_g_2_a = 1.000000000;\nvec4 o6473_g_gradient_fct(float x) {\n  if (x < p_o6473_g_0_pos) {\n    return vec4(p_o6473_g_0_r,p_o6473_g_0_g,p_o6473_g_0_b,p_o6473_g_0_a);\n  } else if (x < p_o6473_g_1_pos) {\n    return mix(vec4(p_o6473_g_0_r,p_o6473_g_0_g,p_o6473_g_0_b,p_o6473_g_0_a), vec4(p_o6473_g_1_r,p_o6473_g_1_g,p_o6473_g_1_b,p_o6473_g_1_a), ((x-p_o6473_g_0_pos)/(p_o6473_g_1_pos-p_o6473_g_0_pos)));\n  } else if (x < p_o6473_g_2_pos) {\n    return mix(vec4(p_o6473_g_1_r,p_o6473_g_1_g,p_o6473_g_1_b,p_o6473_g_1_a), vec4(p_o6473_g_2_r,p_o6473_g_2_g,p_o6473_g_2_b,p_o6473_g_2_a), ((x-p_o6473_g_1_pos)/(p_o6473_g_2_pos-p_o6473_g_1_pos)));\n  }\n  return vec4(p_o6473_g_2_r,p_o6473_g_2_g,p_o6473_g_2_b,p_o6473_g_2_a);\n}\nconst float p_o6468_scale = 5.635000000;\nconst float p_o6468_scale_x = 1.000000000;\nconst float p_o6468_scale_y = 1.000000000;\nconst float p_o6468_scale_z = 1.000000000;\nconst float p_o6468_transx = 0.000000000;\nconst float p_o6468_transy = 0.000000000;\nconst float p_o6468_transz = 0.000000000;\nconst float p_o6468_persistence = 0.500000000;\nconst float p_o6468_brightness = 0.000000000;\nconst float p_o6468_contrast = 7.556000000;\nfloat o6468_fbm(vec3 coord, float persistence, float _seed_variation_) {\n\tfloat normalize_factor = 0.0;\n\tfloat value = 0.0;\n\tfloat scale = 1.0;\n\tfloat size = 1.0;\n\tfor (int i = 0; i < 6; i++) {\n\t\tvalue += XsX3zB_oct_simplex3d(coord*size) * scale;\n\t\tnormalize_factor += scale;\n\t\tsize *= 2.0;\n\t\tscale *= persistence;\n\t}\n\treturn value / normalize_factor;\n}\n\nfloat o6468_bc(float f,float contrast, float brightness, float _seed_variation_) {\n\treturn f*contrast+brightness+0.5-contrast*0.5;\n}\nvec3 o6454_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\nvec4 o6487_0_rect = bricks_rb((((p).yz+vec2(0.5))-vec2(p_o6491_translate_x, p_o6491_translate_y)), vec2(p_o6487_columns, p_o6487_rows), p_o6487_repeat, p_o6487_row_offset);\nvec4 o6487_0 = brick((((p).yz+vec2(0.5))-vec2(p_o6491_translate_x, p_o6491_translate_y)), o6487_0_rect.xy, o6487_0_rect.zw, p_o6487_mortar*1.0, p_o6487_round*1.0, max(0.001, p_o6487_bevel*1.0));\nvec3 o6487_1_2_rgb = brick_random_color(o6487_0_rect.xy, o6487_0_rect.zw, float((seed_o6487+_seed_variation_)));\nvec3 o6468_0_out = vec3(o6468_bc(o6468_fbm((vec3(p_o6488_f,(transform2((((p).yz+vec2(0.5))-vec2(p_o6491_translate_x, p_o6491_translate_y)), vec2(p_o6489_translate_x*(2.0*(dot(o6487_1_2_rgb, vec3(1.0))/3.0)-1.0), p_o6489_translate_y*(2.0*(dot(o6487_1_2_rgb, vec3(1.0))/3.0)-1.0)), p_o6489_rotate*0.01745329251*(2.0*(dot(o6487_1_2_rgb, vec3(1.0))/3.0)-1.0), vec2(p_o6489_scale_x*(2.0*1.0-1.0), p_o6489_scale_y*(2.0*1.0-1.0)))).x,(transform2((((p).yz+vec2(0.5))-vec2(p_o6491_translate_x, p_o6491_translate_y)), vec2(p_o6489_translate_x*(2.0*(dot(o6487_1_2_rgb, vec3(1.0))/3.0)-1.0), p_o6489_translate_y*(2.0*(dot(o6487_1_2_rgb, vec3(1.0))/3.0)-1.0)), p_o6489_rotate*0.01745329251*(2.0*(dot(o6487_1_2_rgb, vec3(1.0))/3.0)-1.0), vec2(p_o6489_scale_x*(2.0*1.0-1.0), p_o6489_scale_y*(2.0*1.0-1.0)))).y)).xyz*vec3(p_o6468_scale_x,p_o6468_scale_y,p_o6468_scale_z)*0.5*p_o6468_scale+vec3(p_o6468_transx,p_o6468_transy,p_o6468_transz),p_o6468_persistence, _seed_variation_)*0.5+0.5,p_o6468_contrast,p_o6468_brightness, _seed_variation_));vec3 o6468_0_1_tex3d = clamp(o6468_0_out,vec3(0),vec3(1));\nvec3 o6473_0_1_tex3d = o6473_g_gradient_fct(dot(o6468_0_1_tex3d, vec3(1.0))/3.0).rgb;\nvec3 o6488_0_1_rgb = o6473_0_1_tex3d.rgb;\nvec4 o6489_0_1_rgba = vec4(o6488_0_1_rgb, 1.0);\nvec4 o6491_0_1_rgba = o6489_0_1_rgba;\nvec3 o6490_0_1_tex3d = ((o6491_0_1_rgba).rgb);\n\nreturn o6490_0_1_tex3d;\n}\nfloat o6454_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o6454_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o6492_g_0_pos = 0.000000000;\nconst float p_o6492_g_0_r = 1.000000000;\nconst float p_o6492_g_0_g = 1.000000000;\nconst float p_o6492_g_0_b = 1.000000000;\nconst float p_o6492_g_0_a = 1.000000000;\nconst float p_o6492_g_1_pos = 1.000000000;\nconst float p_o6492_g_1_r = 0.000000000;\nconst float p_o6492_g_1_g = 0.000000000;\nconst float p_o6492_g_1_b = 0.000000000;\nconst float p_o6492_g_1_a = 1.000000000;\nvec4 o6492_g_gradient_fct(float x) {\n  if (x < p_o6492_g_0_pos) {\n    return vec4(p_o6492_g_0_r,p_o6492_g_0_g,p_o6492_g_0_b,p_o6492_g_0_a);\n  } else if (x < p_o6492_g_1_pos) {\n    return mix(vec4(p_o6492_g_0_r,p_o6492_g_0_g,p_o6492_g_0_b,p_o6492_g_0_a), vec4(p_o6492_g_1_r,p_o6492_g_1_g,p_o6492_g_1_b,p_o6492_g_1_a), ((x-p_o6492_g_0_pos)/(p_o6492_g_1_pos-p_o6492_g_0_pos)));\n  }\n  return vec4(p_o6492_g_1_r,p_o6492_g_1_g,p_o6492_g_1_b,p_o6492_g_1_a);\n}\nfloat o6454_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\nvec4 o6487_0_rect = bricks_rb((((p).yz+vec2(0.5))-vec2(p_o6491_translate_x, p_o6491_translate_y)), vec2(p_o6487_columns, p_o6487_rows), p_o6487_repeat, p_o6487_row_offset);\nvec4 o6487_0 = brick((((p).yz+vec2(0.5))-vec2(p_o6491_translate_x, p_o6491_translate_y)), o6487_0_rect.xy, o6487_0_rect.zw, p_o6487_mortar*1.0, p_o6487_round*1.0, max(0.001, p_o6487_bevel*1.0));\nvec3 o6487_1_2_rgb = brick_random_color(o6487_0_rect.xy, o6487_0_rect.zw, float((seed_o6487+_seed_variation_)));\nvec3 o6468_0_out = vec3(o6468_bc(o6468_fbm((vec3(p_o6488_f,(transform2((((p).yz+vec2(0.5))-vec2(p_o6491_translate_x, p_o6491_translate_y)), vec2(p_o6489_translate_x*(2.0*(dot(o6487_1_2_rgb, vec3(1.0))/3.0)-1.0), p_o6489_translate_y*(2.0*(dot(o6487_1_2_rgb, vec3(1.0))/3.0)-1.0)), p_o6489_rotate*0.01745329251*(2.0*(dot(o6487_1_2_rgb, vec3(1.0))/3.0)-1.0), vec2(p_o6489_scale_x*(2.0*1.0-1.0), p_o6489_scale_y*(2.0*1.0-1.0)))).x,(transform2((((p).yz+vec2(0.5))-vec2(p_o6491_translate_x, p_o6491_translate_y)), vec2(p_o6489_translate_x*(2.0*(dot(o6487_1_2_rgb, vec3(1.0))/3.0)-1.0), p_o6489_translate_y*(2.0*(dot(o6487_1_2_rgb, vec3(1.0))/3.0)-1.0)), p_o6489_rotate*0.01745329251*(2.0*(dot(o6487_1_2_rgb, vec3(1.0))/3.0)-1.0), vec2(p_o6489_scale_x*(2.0*1.0-1.0), p_o6489_scale_y*(2.0*1.0-1.0)))).y)).xyz*vec3(p_o6468_scale_x,p_o6468_scale_y,p_o6468_scale_z)*0.5*p_o6468_scale+vec3(p_o6468_transx,p_o6468_transy,p_o6468_transz),p_o6468_persistence, _seed_variation_)*0.5+0.5,p_o6468_contrast,p_o6468_brightness, _seed_variation_));vec3 o6468_0_1_tex3d = clamp(o6468_0_out,vec3(0),vec3(1));\nvec3 o6473_0_1_tex3d = o6473_g_gradient_fct(dot(o6468_0_1_tex3d, vec3(1.0))/3.0).rgb;\nvec3 o6488_0_1_rgb = o6473_0_1_tex3d.rgb;\nvec4 o6489_0_1_rgba = vec4(o6488_0_1_rgb, 1.0);\nvec4 o6491_0_1_rgba = o6489_0_1_rgba;\nvec3 o6490_0_1_tex3d = ((o6491_0_1_rgba).rgb);\nvec3 o6492_0_1_tex3d = o6492_g_gradient_fct(dot(o6490_0_1_tex3d, vec3(1.0))/3.0).rgb;\n\nreturn (dot(o6492_0_1_tex3d, vec3(1.0))/3.0);\n}\nvec3 o6454_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o6454_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o6454_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o6454_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o6459_X = 1.000000000;\nconst float p_o6459_Y = 0.260000000;\nconst float p_o6459_Z = 0.260000000;\nconst float p_o6459_RepX = 1.000000000;\nconst float p_o6459_RepY = 24.000000000;\nconst float p_o6459_RepZ = 24.000000000;\nconst float p_o6458_sx = 0.050000000;\nconst float p_o6458_sy = 0.235000000;\nconst float p_o6458_sz = 0.235000000;\nconst float p_o6458_r = 0.020000000;\nfloat o6454_input_sdf3d(vec3 p, float _seed_variation_) {\nvec3 o6458_0_q = abs((opRepLim((p),vec3(p_o6459_X,p_o6459_Y,p_o6459_Z)*2.0,vec3(p_o6459_RepX-1.0,p_o6459_RepY-1.0,p_o6459_RepZ-1.0)))) - vec3(p_o6458_sx, p_o6458_sy, p_o6458_sz);\nfloat o6458_0_1_sdf3d = length(max(o6458_0_q,0.0))+min(max(o6458_0_q.x,max(o6458_0_q.y,o6458_0_q.z)),0.0)-p_o6458_r;\nfloat o6459_0_1_sdf3d = o6458_0_1_sdf3d;\n\nreturn o6459_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o6454(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o6454_TranlateX,p_o6454_TranlateY,p_o6454_TranlateZ),vec3(p_o6454_RotateX,p_o6454_RotateY,p_o6454_RotateZ)*6.28318530718)/p_o6454_scale;\n\tfloat sdf=o6454_input_sdf3d(uv.xyz, _seed_variation_)*p_o6454_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o6454_AmbientOcclusion*o6454_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o6454_Alpha*o6454_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o6454_Normal*o6454_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o6454_Emission*o6454_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o6454_Roughness*o6454_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o6454_Specular*o6454_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o6454_Metallic*o6454_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o6454_BaseColor_r, p_o6454_BaseColor_g, p_o6454_BaseColor_b, p_o6454_BaseColor_a).rgb*o6454_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}const float p_o6465_x = -0.049000000;\nconst float p_o6465_y = 0.000000000;\nconst float p_o6465_z = 0.000000000;\nconst float p_o6460_BaseColor_r = 0.324218988;\nconst float p_o6460_BaseColor_g = 0.324218988;\nconst float p_o6460_BaseColor_b = 0.324218988;\nconst float p_o6460_BaseColor_a = 1.000000000;\nconst float p_o6460_Metallic = 0.000000000;\nconst float p_o6460_Specular = 0.000000000;\nconst float p_o6460_Roughness = 1.000000000;\nconst float p_o6460_Emission = 0.000000000;\nconst float p_o6460_Normal = 0.000000000;\nconst float p_o6460_Alpha = 0.000000000;\nconst float p_o6460_AmbientOcclusion = 0.000000000;\nconst float p_o6460_scale = 1.000000000;\nconst float p_o6460_TranlateX = 0.000000000;\nconst float p_o6460_TranlateY = 0.000000000;\nconst float p_o6460_TranlateZ = 0.000000000;\nconst float p_o6460_RotateX = 0.000000000;\nconst float p_o6460_RotateY = 0.000000000;\nconst float p_o6460_RotateZ = 0.000000000;\nvec3 o6460_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nfloat o6460_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o6460_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o6460_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o6460_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o6460_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o6460_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o6460_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o6464_sx = 0.000000000;\nconst float p_o6464_sy = 6.270000000;\nconst float p_o6464_sz = 6.140000000;\nconst float p_o6464_r = 0.000000000;\nfloat o6460_input_sdf3d(vec3 p, float _seed_variation_) {\nvec3 o6464_0_q = abs((p)) - vec3(p_o6464_sx, p_o6464_sy, p_o6464_sz);\nfloat o6464_0_1_sdf3d = length(max(o6464_0_q,0.0))+min(max(o6464_0_q.x,max(o6464_0_q.y,o6464_0_q.z)),0.0)-p_o6464_r;\n\nreturn o6464_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o6460(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o6460_TranlateX,p_o6460_TranlateY,p_o6460_TranlateZ),vec3(p_o6460_RotateX,p_o6460_RotateY,p_o6460_RotateZ)*6.28318530718)/p_o6460_scale;\n\tfloat sdf=o6460_input_sdf3d(uv.xyz, _seed_variation_)*p_o6460_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o6460_AmbientOcclusion*o6460_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o6460_Alpha*o6460_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o6460_Normal*o6460_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o6460_Emission*o6460_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o6460_Roughness*o6460_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o6460_Specular*o6460_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o6460_Metallic*o6460_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o6460_BaseColor_r, p_o6460_BaseColor_g, p_o6460_BaseColor_b, p_o6460_BaseColor_a).rgb*o6460_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}const float p_o6507_ax = 0.000000000;\nconst float p_o6507_ay = 90.000000000;\nconst float p_o6507_az = 0.000000000;\nconst float p_o6508_BaseColor_r = 1.000000000;\nconst float p_o6508_BaseColor_g = 1.000000000;\nconst float p_o6508_BaseColor_b = 1.000000000;\nconst float p_o6508_BaseColor_a = 1.000000000;\nconst float p_o6508_Metallic = 0.000000000;\nconst float p_o6508_Specular = 0.000000000;\nconst float p_o6508_Roughness = 1.000000000;\nconst float p_o6508_Emission = 0.000000000;\nconst float p_o6508_Normal = 0.000000000;\nconst float p_o6508_Alpha = 0.000000000;\nconst float p_o6508_AmbientOcclusion = 0.000000000;\nconst float p_o6508_scale = 1.000000000;\nconst float p_o6508_TranlateX = 0.000000000;\nconst float p_o6508_TranlateY = 4.420000000;\nconst float p_o6508_TranlateZ = 0.000000000;\nconst float p_o6508_RotateX = 0.000000000;\nconst float p_o6508_RotateY = 0.000000000;\nconst float p_o6508_RotateZ = 0.000000000;\nvec3 o6508_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nfloat o6508_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o6508_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o6508_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o6508_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o6508_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o6508_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o6508_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o6512_sx = 4.250000000;\nconst float p_o6512_sy = 0.250000000;\nconst float p_o6512_sz = 4.010000000;\nconst float p_o6512_r = 0.010000000;\nfloat o6508_input_sdf3d(vec3 p, float _seed_variation_) {\nvec3 o6512_0_q = abs((p)) - vec3(p_o6512_sx, p_o6512_sy, p_o6512_sz);\nfloat o6512_0_1_sdf3d = length(max(o6512_0_q,0.0))+min(max(o6512_0_q.x,max(o6512_0_q.y,o6512_0_q.z)),0.0)-p_o6512_r;\n\nreturn o6512_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o6508(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o6508_TranlateX,p_o6508_TranlateY,p_o6508_TranlateZ),vec3(p_o6508_RotateX,p_o6508_RotateY,p_o6508_RotateZ)*6.28318530718)/p_o6508_scale;\n\tfloat sdf=o6508_input_sdf3d(uv.xyz, _seed_variation_)*p_o6508_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o6508_AmbientOcclusion*o6508_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o6508_Alpha*o6508_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o6508_Normal*o6508_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o6508_Emission*o6508_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o6508_Roughness*o6508_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o6508_Specular*o6508_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o6508_Metallic*o6508_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o6508_BaseColor_r, p_o6508_BaseColor_g, p_o6508_BaseColor_b, p_o6508_BaseColor_a).rgb*o6508_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}const float p_o6572_k = 0.904000000;\nconst float p_o6565_x = 0.000000000;\nconst float p_o6565_y = -0.119530000;\nconst float p_o6565_z = 0.000000000;\nconst float p_o6566_xyz = 1.785000000;\nconst float p_o6566_x = 1.000000000;\nconst float p_o6566_y = 1.000000000;\nconst float p_o6566_z = 1.000000000;\nconst float p_o6564_ax = 0.000000000;\nconst float p_o6564_ay = 90.000000000;\nconst float p_o6564_az = 90.000000000;\nconst float p_o6557_BaseColor_r = 1.000000000;\nconst float p_o6557_BaseColor_g = 1.000000000;\nconst float p_o6557_BaseColor_b = 1.000000000;\nconst float p_o6557_BaseColor_a = 1.000000000;\nconst float p_o6557_Metallic = 0.705000000;\nconst float p_o6557_Specular = 0.917000000;\nconst float p_o6557_Roughness = 1.000000000;\nconst float p_o6557_Emission = 0.000000000;\nconst float p_o6557_Normal = 0.000000000;\nconst float p_o6557_Alpha = 0.000000000;\nconst float p_o6557_AmbientOcclusion = 0.000000000;\nconst float p_o6557_scale = 1.000000000;\nconst float p_o6557_TranlateX = 0.000000000;\nconst float p_o6557_TranlateY = 0.000000000;\nconst float p_o6557_TranlateZ = 0.000000000;\nconst float p_o6557_RotateX = 0.000000000;\nconst float p_o6557_RotateY = 0.000000000;\nconst float p_o6557_RotateZ = 0.000000000;\nconst float p_o6543_translate_x = -0.530000000;\nconst float p_o6543_translate_y = -0.010000000;\nconst float p_o6541_translate_x = 2.180000000;\nconst float p_o6541_translate_y = 4.575000000;\nconst float p_o6541_rotate = 456.220000000;\nconst float p_o6541_scale_x = 1.000000000;\nconst float p_o6541_scale_y = 1.000000000;\nconst float seed_o6540 = 0.692989000;\nconst float p_o6540_repeat = 1.000000000;\nconst float p_o6540_rows = 1.930000000;\nconst float p_o6540_columns = 1.930000000;\nconst float p_o6540_row_offset = 1.000000000;\nconst float p_o6540_mortar = 0.000000000;\nconst float p_o6540_bevel = 0.000000000;\nconst float p_o6540_round = 0.000000000;\nconst float p_o6540_corner = 0.000000000;\nconst float p_o6539_f = 0.000000000;\nconst float p_o6525_g_0_pos = 0.081110000;\nconst float p_o6525_g_0_r = 0.000000000;\nconst float p_o6525_g_0_g = 0.000000000;\nconst float p_o6525_g_0_b = 0.000000000;\nconst float p_o6525_g_0_a = 1.000000000;\nconst float p_o6525_g_1_pos = 0.390909000;\nconst float p_o6525_g_1_r = 0.796875000;\nconst float p_o6525_g_1_g = 0.604830027;\nconst float p_o6525_g_1_b = 0.333068997;\nconst float p_o6525_g_1_a = 1.000000000;\nconst float p_o6525_g_2_pos = 0.772019000;\nconst float p_o6525_g_2_r = 0.000000000;\nconst float p_o6525_g_2_g = 0.000000000;\nconst float p_o6525_g_2_b = 0.000000000;\nconst float p_o6525_g_2_a = 1.000000000;\nvec4 o6525_g_gradient_fct(float x) {\n  if (x < p_o6525_g_0_pos) {\n    return vec4(p_o6525_g_0_r,p_o6525_g_0_g,p_o6525_g_0_b,p_o6525_g_0_a);\n  } else if (x < p_o6525_g_1_pos) {\n    return mix(vec4(p_o6525_g_0_r,p_o6525_g_0_g,p_o6525_g_0_b,p_o6525_g_0_a), vec4(p_o6525_g_1_r,p_o6525_g_1_g,p_o6525_g_1_b,p_o6525_g_1_a), ((x-p_o6525_g_0_pos)/(p_o6525_g_1_pos-p_o6525_g_0_pos)));\n  } else if (x < p_o6525_g_2_pos) {\n    return mix(vec4(p_o6525_g_1_r,p_o6525_g_1_g,p_o6525_g_1_b,p_o6525_g_1_a), vec4(p_o6525_g_2_r,p_o6525_g_2_g,p_o6525_g_2_b,p_o6525_g_2_a), ((x-p_o6525_g_1_pos)/(p_o6525_g_2_pos-p_o6525_g_1_pos)));\n  }\n  return vec4(p_o6525_g_2_r,p_o6525_g_2_g,p_o6525_g_2_b,p_o6525_g_2_a);\n}\nconst float p_o6514_scale = 2.706000000;\nconst float p_o6514_scale_x = 1.000000000;\nconst float p_o6514_scale_y = 1.000000000;\nconst float p_o6514_scale_z = 1.000000000;\nconst float p_o6514_transx = 0.000000000;\nconst float p_o6514_transy = 0.000000000;\nconst float p_o6514_transz = 0.000000000;\nconst float p_o6514_persistence = 0.500000000;\nconst float p_o6514_brightness = 0.000000000;\nconst float p_o6514_contrast = 14.000000000;\nfloat o6514_fbm(vec3 coord, float persistence, float _seed_variation_) {\n\tfloat normalize_factor = 0.0;\n\tfloat value = 0.0;\n\tfloat scale = 1.0;\n\tfloat size = 1.0;\n\tfor (int i = 0; i < 12; i++) {\n\t\tvalue += XsX3zB_oct_simplex3d(coord*size) * scale;\n\t\tnormalize_factor += scale;\n\t\tsize *= 2.0;\n\t\tscale *= persistence;\n\t}\n\treturn value / normalize_factor;\n}\n\nfloat o6514_bc(float f,float contrast, float brightness, float _seed_variation_) {\n\treturn f*contrast+brightness+0.5-contrast*0.5;\n}\nvec3 o6557_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\nvec4 o6540_0_rect = bricks_rb((((p).yz+vec2(0.5))-vec2(p_o6543_translate_x, p_o6543_translate_y)), vec2(p_o6540_columns, p_o6540_rows), p_o6540_repeat, p_o6540_row_offset);\nvec4 o6540_0 = brick((((p).yz+vec2(0.5))-vec2(p_o6543_translate_x, p_o6543_translate_y)), o6540_0_rect.xy, o6540_0_rect.zw, p_o6540_mortar*1.0, p_o6540_round*1.0, max(0.001, p_o6540_bevel*1.0));\nvec3 o6540_1_2_rgb = brick_random_color(o6540_0_rect.xy, o6540_0_rect.zw, float((seed_o6540+_seed_variation_)));\nvec3 o6514_0_out = vec3(o6514_bc(o6514_fbm((vec3(p_o6539_f,(transform2((((p).yz+vec2(0.5))-vec2(p_o6543_translate_x, p_o6543_translate_y)), vec2(p_o6541_translate_x*(2.0*(dot(o6540_1_2_rgb, vec3(1.0))/3.0)-1.0), p_o6541_translate_y*(2.0*(dot(o6540_1_2_rgb, vec3(1.0))/3.0)-1.0)), p_o6541_rotate*0.01745329251*(2.0*(dot(o6540_1_2_rgb, vec3(1.0))/3.0)-1.0), vec2(p_o6541_scale_x*(2.0*1.0-1.0), p_o6541_scale_y*(2.0*1.0-1.0)))).x,(transform2((((p).yz+vec2(0.5))-vec2(p_o6543_translate_x, p_o6543_translate_y)), vec2(p_o6541_translate_x*(2.0*(dot(o6540_1_2_rgb, vec3(1.0))/3.0)-1.0), p_o6541_translate_y*(2.0*(dot(o6540_1_2_rgb, vec3(1.0))/3.0)-1.0)), p_o6541_rotate*0.01745329251*(2.0*(dot(o6540_1_2_rgb, vec3(1.0))/3.0)-1.0), vec2(p_o6541_scale_x*(2.0*1.0-1.0), p_o6541_scale_y*(2.0*1.0-1.0)))).y)).xyz*vec3(p_o6514_scale_x,p_o6514_scale_y,p_o6514_scale_z)*0.5*p_o6514_scale+vec3(p_o6514_transx,p_o6514_transy,p_o6514_transz),p_o6514_persistence, _seed_variation_)*0.5+0.5,p_o6514_contrast,p_o6514_brightness, _seed_variation_));vec3 o6514_0_1_tex3d = clamp(o6514_0_out,vec3(0),vec3(1));\nvec3 o6525_0_1_tex3d = o6525_g_gradient_fct(dot(o6514_0_1_tex3d, vec3(1.0))/3.0).rgb;\nvec3 o6539_0_1_rgb = o6525_0_1_tex3d.rgb;\nvec4 o6541_0_1_rgba = vec4(o6539_0_1_rgb, 1.0);\nvec4 o6543_0_1_rgba = o6541_0_1_rgba;\nvec3 o6542_0_1_tex3d = ((o6543_0_1_rgba).rgb);\n\nreturn o6542_0_1_tex3d;\n}\nfloat o6557_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o6557_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o6544_g_0_pos = 0.000000000;\nconst float p_o6544_g_0_r = 0.066405997;\nconst float p_o6544_g_0_g = 0.066405997;\nconst float p_o6544_g_0_b = 0.066405997;\nconst float p_o6544_g_0_a = 1.000000000;\nconst float p_o6544_g_1_pos = 1.000000000;\nconst float p_o6544_g_1_r = 1.000000000;\nconst float p_o6544_g_1_g = 1.000000000;\nconst float p_o6544_g_1_b = 1.000000000;\nconst float p_o6544_g_1_a = 1.000000000;\nvec4 o6544_g_gradient_fct(float x) {\n  if (x < p_o6544_g_0_pos) {\n    return vec4(p_o6544_g_0_r,p_o6544_g_0_g,p_o6544_g_0_b,p_o6544_g_0_a);\n  } else if (x < p_o6544_g_1_pos) {\n    return mix(vec4(p_o6544_g_0_r,p_o6544_g_0_g,p_o6544_g_0_b,p_o6544_g_0_a), vec4(p_o6544_g_1_r,p_o6544_g_1_g,p_o6544_g_1_b,p_o6544_g_1_a), ((x-p_o6544_g_0_pos)/(p_o6544_g_1_pos-p_o6544_g_0_pos)));\n  }\n  return vec4(p_o6544_g_1_r,p_o6544_g_1_g,p_o6544_g_1_b,p_o6544_g_1_a);\n}\nfloat o6557_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\nvec4 o6540_0_rect = bricks_rb((((p).yz+vec2(0.5))-vec2(p_o6543_translate_x, p_o6543_translate_y)), vec2(p_o6540_columns, p_o6540_rows), p_o6540_repeat, p_o6540_row_offset);\nvec4 o6540_0 = brick((((p).yz+vec2(0.5))-vec2(p_o6543_translate_x, p_o6543_translate_y)), o6540_0_rect.xy, o6540_0_rect.zw, p_o6540_mortar*1.0, p_o6540_round*1.0, max(0.001, p_o6540_bevel*1.0));\nvec3 o6540_1_2_rgb = brick_random_color(o6540_0_rect.xy, o6540_0_rect.zw, float((seed_o6540+_seed_variation_)));\nvec3 o6514_0_out = vec3(o6514_bc(o6514_fbm((vec3(p_o6539_f,(transform2((((p).yz+vec2(0.5))-vec2(p_o6543_translate_x, p_o6543_translate_y)), vec2(p_o6541_translate_x*(2.0*(dot(o6540_1_2_rgb, vec3(1.0))/3.0)-1.0), p_o6541_translate_y*(2.0*(dot(o6540_1_2_rgb, vec3(1.0))/3.0)-1.0)), p_o6541_rotate*0.01745329251*(2.0*(dot(o6540_1_2_rgb, vec3(1.0))/3.0)-1.0), vec2(p_o6541_scale_x*(2.0*1.0-1.0), p_o6541_scale_y*(2.0*1.0-1.0)))).x,(transform2((((p).yz+vec2(0.5))-vec2(p_o6543_translate_x, p_o6543_translate_y)), vec2(p_o6541_translate_x*(2.0*(dot(o6540_1_2_rgb, vec3(1.0))/3.0)-1.0), p_o6541_translate_y*(2.0*(dot(o6540_1_2_rgb, vec3(1.0))/3.0)-1.0)), p_o6541_rotate*0.01745329251*(2.0*(dot(o6540_1_2_rgb, vec3(1.0))/3.0)-1.0), vec2(p_o6541_scale_x*(2.0*1.0-1.0), p_o6541_scale_y*(2.0*1.0-1.0)))).y)).xyz*vec3(p_o6514_scale_x,p_o6514_scale_y,p_o6514_scale_z)*0.5*p_o6514_scale+vec3(p_o6514_transx,p_o6514_transy,p_o6514_transz),p_o6514_persistence, _seed_variation_)*0.5+0.5,p_o6514_contrast,p_o6514_brightness, _seed_variation_));vec3 o6514_0_1_tex3d = clamp(o6514_0_out,vec3(0),vec3(1));\nvec3 o6525_0_1_tex3d = o6525_g_gradient_fct(dot(o6514_0_1_tex3d, vec3(1.0))/3.0).rgb;\nvec3 o6539_0_1_rgb = o6525_0_1_tex3d.rgb;\nvec4 o6541_0_1_rgba = vec4(o6539_0_1_rgb, 1.0);\nvec4 o6543_0_1_rgba = o6541_0_1_rgba;\nvec3 o6542_0_1_tex3d = ((o6543_0_1_rgba).rgb);\nvec3 o6544_0_1_tex3d = o6544_g_gradient_fct(dot(o6542_0_1_tex3d, vec3(1.0))/3.0).rgb;\n\nreturn (dot(o6544_0_1_tex3d, vec3(1.0))/3.0);\n}\nvec3 o6557_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o6557_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o6557_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o6557_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o6561_X = 1.000000000;\nconst float p_o6561_Y = 0.260000000;\nconst float p_o6561_Z = 0.260000000;\nconst float p_o6561_RepX = 1.000000000;\nconst float p_o6561_RepY = 24.000000000;\nconst float p_o6561_RepZ = 24.000000000;\nconst float p_o6520_sx = 0.050000000;\nconst float p_o6520_sy = 0.235000000;\nconst float p_o6520_sz = 0.235000000;\nconst float p_o6520_r = 0.020000000;\nfloat o6557_input_sdf3d(vec3 p, float _seed_variation_) {\nvec3 o6520_0_q = abs((opRepLim((p),vec3(p_o6561_X,p_o6561_Y,p_o6561_Z)*2.0,vec3(p_o6561_RepX-1.0,p_o6561_RepY-1.0,p_o6561_RepZ-1.0)))) - vec3(p_o6520_sx, p_o6520_sy, p_o6520_sz);\nfloat o6520_0_1_sdf3d = length(max(o6520_0_q,0.0))+min(max(o6520_0_q.x,max(o6520_0_q.y,o6520_0_q.z)),0.0)-p_o6520_r;\nfloat o6561_0_1_sdf3d = o6520_0_1_sdf3d;\n\nreturn o6561_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o6557(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o6557_TranlateX,p_o6557_TranlateY,p_o6557_TranlateZ),vec3(p_o6557_RotateX,p_o6557_RotateY,p_o6557_RotateZ)*6.28318530718)/p_o6557_scale;\n\tfloat sdf=o6557_input_sdf3d(uv.xyz, _seed_variation_)*p_o6557_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o6557_AmbientOcclusion*o6557_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o6557_Alpha*o6557_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o6557_Normal*o6557_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o6557_Emission*o6557_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o6557_Roughness*o6557_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o6557_Specular*o6557_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o6557_Metallic*o6557_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o6557_BaseColor_r, p_o6557_BaseColor_g, p_o6557_BaseColor_b, p_o6557_BaseColor_a).rgb*o6557_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}const float p_o6562_x = -0.058000000;\nconst float p_o6562_y = 0.000000000;\nconst float p_o6562_z = 0.000000000;\nconst float p_o6521_BaseColor_r = 0.324218988;\nconst float p_o6521_BaseColor_g = 0.324218988;\nconst float p_o6521_BaseColor_b = 0.324218988;\nconst float p_o6521_BaseColor_a = 1.000000000;\nconst float p_o6521_Metallic = 0.000000000;\nconst float p_o6521_Specular = 0.000000000;\nconst float p_o6521_Roughness = 1.000000000;\nconst float p_o6521_Emission = 0.000000000;\nconst float p_o6521_Normal = 0.000000000;\nconst float p_o6521_Alpha = 0.000000000;\nconst float p_o6521_AmbientOcclusion = 0.000000000;\nconst float p_o6521_scale = 1.000000000;\nconst float p_o6521_TranlateX = 0.000000000;\nconst float p_o6521_TranlateY = 0.000000000;\nconst float p_o6521_TranlateZ = 0.000000000;\nconst float p_o6521_RotateX = 0.000000000;\nconst float p_o6521_RotateY = 0.000000000;\nconst float p_o6521_RotateZ = 0.000000000;\nvec3 o6521_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nfloat o6521_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o6521_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o6521_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o6521_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o6521_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o6521_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o6521_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o6519_sx = 0.000000000;\nconst float p_o6519_sy = 6.270000000;\nconst float p_o6519_sz = 6.140000000;\nconst float p_o6519_r = 0.000000000;\nfloat o6521_input_sdf3d(vec3 p, float _seed_variation_) {\nvec3 o6519_0_q = abs((p)) - vec3(p_o6519_sx, p_o6519_sy, p_o6519_sz);\nfloat o6519_0_1_sdf3d = length(max(o6519_0_q,0.0))+min(max(o6519_0_q.x,max(o6519_0_q.y,o6519_0_q.z)),0.0)-p_o6519_r;\n\nreturn o6519_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o6521(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o6521_TranlateX,p_o6521_TranlateY,p_o6521_TranlateZ),vec3(p_o6521_RotateX,p_o6521_RotateY,p_o6521_RotateZ)*6.28318530718)/p_o6521_scale;\n\tfloat sdf=o6521_input_sdf3d(uv.xyz, _seed_variation_)*p_o6521_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o6521_AmbientOcclusion*o6521_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o6521_Alpha*o6521_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o6521_Normal*o6521_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o6521_Emission*o6521_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o6521_Roughness*o6521_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o6521_Specular*o6521_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o6521_Metallic*o6521_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o6521_BaseColor_r, p_o6521_BaseColor_g, p_o6521_BaseColor_b, p_o6521_BaseColor_a).rgb*o6521_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}const float p_o6513_x = 0.000000000;\nconst float p_o6513_y = 1.071000000;\nconst float p_o6513_z = 0.000000000;\n//const float p_o6453_angle = -67.807000000;\nconst float p_o6453_correction = 0.000000000;\nconst float p_o6446_k = 0.062000000;\nconst float p_o6447_BaseColor_r = 0.000000000;\nconst float p_o6447_BaseColor_g = 0.000000000;\nconst float p_o6447_BaseColor_b = 0.000000000;\nconst float p_o6447_BaseColor_a = 1.000000000;\nconst float p_o6447_Metallic = 0.250000000;\nconst float p_o6447_Specular = 1.000000000;\nconst float p_o6447_Roughness = 0.000000000;\nconst float p_o6447_Emission = 0.000000000;\nconst float p_o6447_Normal = 0.000000000;\nconst float p_o6447_Alpha = 0.000000000;\nconst float p_o6447_AmbientOcclusion = 0.000000000;\nconst float p_o6447_scale = 0.306000000;\nconst float p_o6447_TranlateX = 0.000000000;\nconst float p_o6447_TranlateY = 0.000000000;\nconst float p_o6447_TranlateZ = 0.000000000;\nconst float p_o6447_RotateX = 0.000000000;\nconst float p_o6447_RotateY = 0.000000000;\nconst float p_o6447_RotateZ = 0.000000000;\nvec3 o6447_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nfloat o6447_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o6447_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o6447_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o6447_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o6447_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o6447_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o6447_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o6451_X = 0.500000000;\nconst float p_o6451_Y = 0.500000000;\nconst float p_o6451_Z = 0.500000000;\nconst float p_o6451_RepX = 14.000000000;\nconst float p_o6451_RepY = 14.000000000;\nconst float p_o6451_RepZ = 17.000000000;\nconst float p_o6452_r = 0.320000000;\nfloat o6447_input_sdf3d(vec3 p, float _seed_variation_) {\nfloat o6452_0_1_sdf3d = length((opRepLim((p),vec3(p_o6451_X,p_o6451_Y,p_o6451_Z)*2.0,vec3(p_o6451_RepX-1.0,p_o6451_RepY-1.0,p_o6451_RepZ-1.0))))-p_o6452_r;\nfloat o6451_0_1_sdf3d = o6452_0_1_sdf3d;\n\nreturn o6451_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o6447(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o6447_TranlateX,p_o6447_TranlateY,p_o6447_TranlateZ),vec3(p_o6447_RotateX,p_o6447_RotateY,p_o6447_RotateZ)*6.28318530718)/p_o6447_scale;\n\tfloat sdf=o6447_input_sdf3d(uv.xyz, _seed_variation_)*p_o6447_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o6447_AmbientOcclusion*o6447_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o6447_Alpha*o6447_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o6447_Normal*o6447_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o6447_Emission*o6447_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o6447_Roughness*o6447_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o6447_Specular*o6447_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o6447_Metallic*o6447_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o6447_BaseColor_r, p_o6447_BaseColor_g, p_o6447_BaseColor_b, p_o6447_BaseColor_a).rgb*o6447_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}const float p_o6435_BaseColor_r = 0.159263998;\nconst float p_o6435_BaseColor_g = 1.000000000;\nconst float p_o6435_BaseColor_b = 0.000000000;\nconst float p_o6435_BaseColor_a = 1.000000000;\nconst float p_o6435_Metallic = 0.547000000;\nconst float p_o6435_Specular = 0.500000000;\nconst float p_o6435_Roughness = 0.059000000;\nconst float p_o6435_Emission = 0.000000000;\nconst float p_o6435_Normal = 0.000000000;\nconst float p_o6435_Alpha = 0.000000000;\nconst float p_o6435_AmbientOcclusion = 0.000000000;\nconst float p_o6435_scale = 1.000000000;\nconst float p_o6435_TranlateX = 0.000000000;\nconst float p_o6435_TranlateY = 0.000000000;\nconst float p_o6435_TranlateZ = 0.000000000;\nconst float p_o6435_RotateX = 0.000000000;\nconst float p_o6435_RotateY = -0.061000000;\nconst float p_o6435_RotateZ = 0.000000000;\nvec3 o6435_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nfloat o6435_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o6435_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o6435_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o6435_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o6435_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o6435_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o6435_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o6445_sx = 0.170000000;\nconst float p_o6445_sy = 0.240000000;\nconst float p_o6445_sz = 1.840000000;\nconst float p_o6445_r = 0.280000000;\nfloat o6435_input_sdf3d(vec3 p, float _seed_variation_) {\nvec3 o6445_0_q = abs((p)) - vec3(p_o6445_sx, p_o6445_sy, p_o6445_sz);\nfloat o6445_0_1_sdf3d = length(max(o6445_0_q,0.0))+min(max(o6445_0_q.x,max(o6445_0_q.y,o6445_0_q.z)),0.0)-p_o6445_r;\n\nreturn o6445_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o6435(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o6435_TranlateX,p_o6435_TranlateY,p_o6435_TranlateZ),vec3(p_o6435_RotateX,p_o6435_RotateY,p_o6435_RotateZ)*6.28318530718)/p_o6435_scale;\n\tfloat sdf=o6435_input_sdf3d(uv.xyz, _seed_variation_)*p_o6435_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o6435_AmbientOcclusion*o6435_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o6435_Alpha*o6435_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o6435_Normal*o6435_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o6435_Emission*o6435_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o6435_Roughness*o6435_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o6435_Specular*o6435_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o6435_Metallic*o6435_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o6435_BaseColor_r, p_o6435_BaseColor_g, p_o6435_BaseColor_b, p_o6435_BaseColor_a).rgb*o6435_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}const float p_o6567_BaseColor_r = 1.000000000;\nconst float p_o6567_BaseColor_g = 1.000000000;\nconst float p_o6567_BaseColor_b = 1.000000000;\nconst float p_o6567_BaseColor_a = 1.000000000;\nconst float p_o6567_Metallic = 1.000000000;\nconst float p_o6567_Specular = 0.900000000;\nconst float p_o6567_Roughness = 0.000000000;\nconst float p_o6567_Emission = 0.000000000;\nconst float p_o6567_Normal = 0.000000000;\nconst float p_o6567_Alpha = 0.000000000;\nconst float p_o6567_AmbientOcclusion = 0.000000000;\nconst float p_o6567_scale = 1.000000000;\nconst float p_o6567_TranlateX = 3.426000000;\nconst float p_o6567_TranlateY = 1.904000000;\nconst float p_o6567_TranlateZ = 0.000000000;\nconst float p_o6567_RotateX = 0.000000000;\nconst float p_o6567_RotateY = 0.000000000;\nconst float p_o6567_RotateZ = 0.000000000;\nvec3 o6567_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nfloat o6567_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o6567_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o6567_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o6567_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o6567_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o6567_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o6567_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o6571_sx = 0.030000000;\nconst float p_o6571_sy = 1.620000000;\nconst float p_o6571_sz = 2.540000000;\nconst float p_o6571_r = 0.010000000;\nfloat o6567_input_sdf3d(vec3 p, float _seed_variation_) {\nvec3 o6571_0_q = abs((p)) - vec3(p_o6571_sx, p_o6571_sy, p_o6571_sz);\nfloat o6571_0_1_sdf3d = length(max(o6571_0_q,0.0))+min(max(o6571_0_q.x,max(o6571_0_q.y,o6571_0_q.z)),0.0)-p_o6571_r;\n\nreturn o6571_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o6567(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o6567_TranlateX,p_o6567_TranlateY,p_o6567_TranlateZ),vec3(p_o6567_RotateX,p_o6567_RotateY,p_o6567_RotateZ)*6.28318530718)/p_o6567_scale;\n\tfloat sdf=o6567_input_sdf3d(uv.xyz, _seed_variation_)*p_o6567_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o6567_AmbientOcclusion*o6567_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o6567_Alpha*o6567_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o6567_Normal*o6567_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o6567_Emission*o6567_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o6567_Roughness*o6567_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o6567_Specular*o6567_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o6567_Metallic*o6567_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o6567_BaseColor_r, p_o6567_BaseColor_g, p_o6567_BaseColor_b, p_o6567_BaseColor_a).rgb*o6567_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}vec4 o6428_input_mfsdf(vec4 p, float _seed_variation_) {\nvec4 o6441_0_1_v4v4 = PBRObjectMaker_o6441((p), _seed_variation_);\nvec4 o6454_0_1_v4v4 = PBRObjectMaker_o6454((vec4((p).xyz-vec3(p_o6466_x, p_o6466_y, p_o6466_z),(p).w)), _seed_variation_);\nvec4 o6460_0_1_v4v4 = PBRObjectMaker_o6460((vec4((vec4((p).xyz-vec3(p_o6466_x, p_o6466_y, p_o6466_z),(p).w)).xyz-vec3(p_o6465_x, p_o6465_y, p_o6465_z),(vec4((p).xyz-vec3(p_o6466_x, p_o6466_y, p_o6466_z),(p).w)).w)), _seed_variation_);\nvec4 o6465_0_1_v4v4 = o6460_0_1_v4v4;\nvec4 o6467_0_1_v4v4 = sdf3dc_union(o6454_0_1_v4v4, o6465_0_1_v4v4);\nvec4 o6466_0_1_v4v4 = o6467_0_1_v4v4;\nvec4 o6454_0_3_v4v4 = PBRObjectMaker_o6454((vec4((vec4(vec3(abs((p).x),(p).yz),(p).w)).xyz-vec3(p_o6466_x, p_o6466_y, p_o6466_z),(vec4(vec3(abs((p).x),(p).yz),(p).w)).w)), _seed_variation_);\nvec4 o6460_0_3_v4v4 = PBRObjectMaker_o6460((vec4((vec4((vec4(vec3(abs((p).x),(p).yz),(p).w)).xyz-vec3(p_o6466_x, p_o6466_y, p_o6466_z),(vec4(vec3(abs((p).x),(p).yz),(p).w)).w)).xyz-vec3(p_o6465_x, p_o6465_y, p_o6465_z),(vec4((vec4(vec3(abs((p).x),(p).yz),(p).w)).xyz-vec3(p_o6466_x, p_o6466_y, p_o6466_z),(vec4(vec3(abs((p).x),(p).yz),(p).w)).w)).w)), _seed_variation_);\nvec4 o6465_0_3_v4v4 = o6460_0_3_v4v4;\nvec4 o6467_0_3_v4v4 = sdf3dc_union(o6454_0_3_v4v4, o6465_0_3_v4v4);\nvec4 o6466_0_3_v4v4 = o6467_0_3_v4v4;\nvec4 o6506_0_1_v4v4 = o6466_0_3_v4v4;\nvec4 o6454_0_5_v4v4 = PBRObjectMaker_o6454((vec4((vec4(vec3(abs((vec4(v4v4_rotate((p).xyz, -vec3(p_o6507_ax, p_o6507_ay, p_o6507_az)*0.01745329251), (p).w)).x),(vec4(v4v4_rotate((p).xyz, -vec3(p_o6507_ax, p_o6507_ay, p_o6507_az)*0.01745329251), (p).w)).yz),(vec4(v4v4_rotate((p).xyz, -vec3(p_o6507_ax, p_o6507_ay, p_o6507_az)*0.01745329251), (p).w)).w)).xyz-vec3(p_o6466_x, p_o6466_y, p_o6466_z),(vec4(vec3(abs((vec4(v4v4_rotate((p).xyz, -vec3(p_o6507_ax, p_o6507_ay, p_o6507_az)*0.01745329251), (p).w)).x),(vec4(v4v4_rotate((p).xyz, -vec3(p_o6507_ax, p_o6507_ay, p_o6507_az)*0.01745329251), (p).w)).yz),(vec4(v4v4_rotate((p).xyz, -vec3(p_o6507_ax, p_o6507_ay, p_o6507_az)*0.01745329251), (p).w)).w)).w)), _seed_variation_);\nvec4 o6460_0_5_v4v4 = PBRObjectMaker_o6460((vec4((vec4((vec4(vec3(abs((vec4(v4v4_rotate((p).xyz, -vec3(p_o6507_ax, p_o6507_ay, p_o6507_az)*0.01745329251), (p).w)).x),(vec4(v4v4_rotate((p).xyz, -vec3(p_o6507_ax, p_o6507_ay, p_o6507_az)*0.01745329251), (p).w)).yz),(vec4(v4v4_rotate((p).xyz, -vec3(p_o6507_ax, p_o6507_ay, p_o6507_az)*0.01745329251), (p).w)).w)).xyz-vec3(p_o6466_x, p_o6466_y, p_o6466_z),(vec4(vec3(abs((vec4(v4v4_rotate((p).xyz, -vec3(p_o6507_ax, p_o6507_ay, p_o6507_az)*0.01745329251), (p).w)).x),(vec4(v4v4_rotate((p).xyz, -vec3(p_o6507_ax, p_o6507_ay, p_o6507_az)*0.01745329251), (p).w)).yz),(vec4(v4v4_rotate((p).xyz, -vec3(p_o6507_ax, p_o6507_ay, p_o6507_az)*0.01745329251), (p).w)).w)).w)).xyz-vec3(p_o6465_x, p_o6465_y, p_o6465_z),(vec4((vec4(vec3(abs((vec4(v4v4_rotate((p).xyz, -vec3(p_o6507_ax, p_o6507_ay, p_o6507_az)*0.01745329251), (p).w)).x),(vec4(v4v4_rotate((p).xyz, -vec3(p_o6507_ax, p_o6507_ay, p_o6507_az)*0.01745329251), (p).w)).yz),(vec4(v4v4_rotate((p).xyz, -vec3(p_o6507_ax, p_o6507_ay, p_o6507_az)*0.01745329251), (p).w)).w)).xyz-vec3(p_o6466_x, p_o6466_y, p_o6466_z),(vec4(vec3(abs((vec4(v4v4_rotate((p).xyz, -vec3(p_o6507_ax, p_o6507_ay, p_o6507_az)*0.01745329251), (p).w)).x),(vec4(v4v4_rotate((p).xyz, -vec3(p_o6507_ax, p_o6507_ay, p_o6507_az)*0.01745329251), (p).w)).yz),(vec4(v4v4_rotate((p).xyz, -vec3(p_o6507_ax, p_o6507_ay, p_o6507_az)*0.01745329251), (p).w)).w)).w)).w)), _seed_variation_);\nvec4 o6465_0_5_v4v4 = o6460_0_5_v4v4;\nvec4 o6467_0_5_v4v4 = sdf3dc_union(o6454_0_5_v4v4, o6465_0_5_v4v4);\nvec4 o6466_0_5_v4v4 = o6467_0_5_v4v4;\nvec4 o6506_0_3_v4v4 = o6466_0_5_v4v4;\nvec4 o6507_0_1_v4v4 = o6506_0_3_v4v4;\nvec4 o6508_0_1_v4v4 = PBRObjectMaker_o6508((p), _seed_variation_);\nvec4 o6557_0_1_v4v4 = PBRObjectMaker_o6557((vec4(v4v4_rotate((vec4((vec4((p).xyz-vec3(p_o6565_x, p_o6565_y, p_o6565_z),(p).w)).xyz/vec3(p_o6566_x, p_o6566_y, p_o6566_z)/p_o6566_xyz,(vec4((p).xyz-vec3(p_o6565_x, p_o6565_y, p_o6565_z),(p).w)).w)).xyz, -vec3(p_o6564_ax, p_o6564_ay, p_o6564_az)*0.01745329251), (vec4((vec4((p).xyz-vec3(p_o6565_x, p_o6565_y, p_o6565_z),(p).w)).xyz/vec3(p_o6566_x, p_o6566_y, p_o6566_z)/p_o6566_xyz,(vec4((p).xyz-vec3(p_o6565_x, p_o6565_y, p_o6565_z),(p).w)).w)).w)), _seed_variation_);\nvec4 o6521_0_1_v4v4 = PBRObjectMaker_o6521((vec4((vec4(v4v4_rotate((vec4((vec4((p).xyz-vec3(p_o6565_x, p_o6565_y, p_o6565_z),(p).w)).xyz/vec3(p_o6566_x, p_o6566_y, p_o6566_z)/p_o6566_xyz,(vec4((p).xyz-vec3(p_o6565_x, p_o6565_y, p_o6565_z),(p).w)).w)).xyz, -vec3(p_o6564_ax, p_o6564_ay, p_o6564_az)*0.01745329251), (vec4((vec4((p).xyz-vec3(p_o6565_x, p_o6565_y, p_o6565_z),(p).w)).xyz/vec3(p_o6566_x, p_o6566_y, p_o6566_z)/p_o6566_xyz,(vec4((p).xyz-vec3(p_o6565_x, p_o6565_y, p_o6565_z),(p).w)).w)).w)).xyz-vec3(p_o6562_x, p_o6562_y, p_o6562_z),(vec4(v4v4_rotate((vec4((vec4((p).xyz-vec3(p_o6565_x, p_o6565_y, p_o6565_z),(p).w)).xyz/vec3(p_o6566_x, p_o6566_y, p_o6566_z)/p_o6566_xyz,(vec4((p).xyz-vec3(p_o6565_x, p_o6565_y, p_o6565_z),(p).w)).w)).xyz, -vec3(p_o6564_ax, p_o6564_ay, p_o6564_az)*0.01745329251), (vec4((vec4((p).xyz-vec3(p_o6565_x, p_o6565_y, p_o6565_z),(p).w)).xyz/vec3(p_o6566_x, p_o6566_y, p_o6566_z)/p_o6566_xyz,(vec4((p).xyz-vec3(p_o6565_x, p_o6565_y, p_o6565_z),(p).w)).w)).w)).w)), _seed_variation_);\nvec4 o6562_0_1_v4v4 = o6521_0_1_v4v4;\nvec4 o6563_0_1_v4v4 = sdf3dc_union(o6557_0_1_v4v4, o6562_0_1_v4v4);\nvec4 o6564_0_1_v4v4 = o6563_0_1_v4v4;\nvec4 o_o6566_0=o6564_0_1_v4v4;vec4 o6566_0_1_v4v4 = vec4(o_o6566_0.xyz,o_o6566_0.w*min(min(p_o6566_x, p_o6566_y), p_o6566_z)*p_o6566_xyz);\nvec4 o6565_0_1_v4v4 = o6566_0_1_v4v4;\nfloat p_o6453_angle=-67.807000000+(iMouse.y/iResolution.y)*180.0; //EDITED NEW\nvec4 o6447_0_1_v4v4 = PBRObjectMaker_o6447((vec4(twistZ((vec4((p).xyz-vec3(p_o6513_x, p_o6513_y, p_o6513_z),(p).w)).xyz,p_o6453_angle),(vec4((p).xyz-vec3(p_o6513_x, p_o6513_y, p_o6513_z),(p).w)).w)), _seed_variation_);\nvec4 o6435_0_1_v4v4 = PBRObjectMaker_o6435((vec4(twistZ((vec4((p).xyz-vec3(p_o6513_x, p_o6513_y, p_o6513_z),(p).w)).xyz,p_o6453_angle),(vec4((p).xyz-vec3(p_o6513_x, p_o6513_y, p_o6513_z),(p).w)).w)), _seed_variation_);\nvec4 o6446_0_1_v4v4 = mfsdf3d_smooth_subtraction(o6447_0_1_v4v4, o6435_0_1_v4v4,p_o6446_k);\nvec4 o6453_0_o=o6446_0_1_v4v4;vec4 o6453_0_1_v4v4 = vec4(o6453_0_o.xyz,o6453_0_o.w/(1.0+p_o6453_correction));\nvec4 o6513_0_1_v4v4 = o6453_0_1_v4v4;\nvec4 o6572_0_1_v4v4 = mfsdf3d_smooth_union(o6565_0_1_v4v4, o6513_0_1_v4v4,p_o6572_k);\nvec4 o6505_0_1_v4v4 = MFSDF_Union(o6466_0_1_v4v4,o6506_0_1_v4v4,o6507_0_1_v4v4,o6508_0_1_v4v4,o6572_0_1_v4v4,o6572_0_1_v4v4,vec4(0.0,0.0,0.0,9999999.0),vec4(0.0,0.0,0.0,9999999.0));\nvec4 o6567_0_1_v4v4 = PBRObjectMaker_o6567((p), _seed_variation_);\nvec4 o6434_0_1_v4v4 = MFSDF_Union(o6441_0_1_v4v4,o6505_0_1_v4v4,vec4(0.0,0.0,0.0,9999999.0),o6567_0_1_v4v4,vec4(0.0,0.0,0.0,9999999.0),vec4(0.0,0.0,0.0,9999999.0),vec4(0.0,0.0,0.0,9999999.0),vec4(0.0,0.0,0.0,9999999.0));\n\nreturn o6434_0_1_v4v4;\n}\nvec3 o6428_input_hdri(vec2 uv, float _seed_variation_) {\n\nreturn vec3(0.0);\n}\n\n//tetrahedron normal by PauloFalcao\nvec3 normal_o6428(vec3 p, float _seed_variation_) {  \n  const vec3 e=vec3(0.01,-0.01,0.0);\n  float v1=o6428_input_mfsdf(vec4(p+e.xyy,0.0), _seed_variation_).w;\n  float v2=o6428_input_mfsdf(vec4(p+e.yyx,0.0), _seed_variation_).w;\n  float v3=o6428_input_mfsdf(vec4(p+e.yxy,0.0), _seed_variation_).w;\n  float v4=o6428_input_mfsdf(vec4(p+e.xxx,0.0), _seed_variation_).w;\n  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n}\n\nvoid raymarch_o6428(in vec3 o,in vec3 v,out vec3 p,inout float d, float _seed_variation_) {\n  float s;\n  for(int i=0;i<80;i++){\n    p=o+v*d;\n    s=o6428_input_mfsdf(vec4(p,0.0), _seed_variation_).w;\n    if (abs(s)<0.001) break;\n    d+=s;\n    if (d>p_o6428_MaxDistance) break;\n  } \n}\n\n/*EDITED OLD\nvec3 pathtracing_o6428(vec2 uv, float _seed_variation_) {\n\n\t// Init random\n\tvec2 rndgen=rndint_hash23(vec3(uv,iTime))*15360.0;\n    uint rngState = uint(uint(rndgen.x) * uint(1973) + uint(rndgen.y) * uint(9277) + uint(iTime*1223.0) * uint(26699)) | uint(1);\nEDITED OLD*/\n\nvec3 pathtracing_o6428(uint rngState,vec2 uv, float _seed_variation_) {\n\n\t//vec3 o=vec3(p_o6428_CamX,p_o6428_CamY,p_o6428_CamZ)*p_o6428_CamZoom;\n   \n    //EDITED NEW add mouse\n    float mx=(iMouse.x/iResolution.x)*6.0;\n\tvec3 o=vec3(p_o6428_CamX,p_o6428_CamY,p_o6428_CamZ-mx)*p_o6428_CamZoom;\n    //EDITED NEW add mouse\n    \n    vec3 t=vec3(p_o6428_LookAtX,p_o6428_LookAtY,p_o6428_LookAtZ);\n    vec3 u=vec3(0.0,1.0,0.0);\n    vec3 c=normalize(t-o);\n    vec3 cx=normalize(cross(u,c));\n    vec3 cy=normalize(cross(cx,c));\n   \n\tvec2 xy=uv-0.5;\n\n    vec3 v=normalize(c*p_o6428_CamD+cx*xy.x+cy*xy.y);\n\n    vec3 p;\n    float d=0.01;\n    vec3 rgb=vec3(1.0);\n    vec3 io=o;\n    int i;\n    for(i=0;i<5;i++){\n    \n        raymarch_o6428(io,v,p,d, _seed_variation_);\n        \n        vec3 n=normal_o6428(p, _seed_variation_);\n        \n        //View direction to tangent space\n        vec3 ot;vec3 ob;Onb(n,ot,ob);\n        vec3 vt=vec3(dot(-v,ot),dot(-v,ob),dot(-v,n));\n\t\n        if (d<p_o6428_MaxDistance){\t\n        \n        vec3 obj_Emission=o6428_input_mfsdf(vec4(p,13.0), _seed_variation_).rgb;\n        \n        if ((obj_Emission.x+obj_Emission.y+obj_Emission.z)>0.001){\n            rgb=obj_Emission*rgb;\n            break;\n        } else {\n            float s=RandomFloat01(rngState);\n\n            vec3 obj_BaseColor=o6428_input_mfsdf(vec4(p,1.0), _seed_variation_).rgb; // 1 - BaseColor  (r,g,b,sdf)\n            float obj_Metallic=o6428_input_mfsdf(vec4(p,2.0), _seed_variation_).x;   // 2 - Metallic   (v,0,0,sdf)\n            float obj_Specular=o6428_input_mfsdf(vec4(p,4.0), _seed_variation_).x;   // 4 - Specular   (v,0,0,sdf)\n            float obj_Roughness=o6428_input_mfsdf(vec4(p,5.0), _seed_variation_).x;  // 5 - Roughness  (v,0,0,sdf)\n\n            if (s>obj_Specular*obj_Specular){\n                rgb=(obj_BaseColor-obj_BaseColor*obj_Metallic)*rgb;\n                v=cosineSampleHemissphere(rngState,n);\n            } else {\n\n                float r2=obj_Roughness*obj_Roughness;\n                vec3 vndf=SampleGGXVNDF(rngState,vt,r2,r2);\n                vec3 nv=reflect(-vt,vndf);\n\n                //Sample direction back to camera space\n                nv=nv.x*ot+nv.y*ob+nv.z*n;\n\n                float FH=schlickWeight(dot(n,nv));\n                vec3 Cspec0=mix(vec3(obj_Specular*.08),obj_BaseColor,obj_Metallic);\n                vec3 Fs=mix(Cspec0,vec3(1.0),FH);\n                rgb=Fs*rgb;\n                \n                v=nv;\n            }\n            io=p;\n            d=0.01;\n        }\n        } else {\n        rgb*=o6428_input_hdri(equirectangularMap(v.xzy), _seed_variation_).xyz;\n        break;\n        }\n    }//for(int i\n    if (i==5) rgb=vec3(0.0);//did not hit any light source\n\n\treturn rgb;\n\t\n}\n\n/* EDITED OLD\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\nfloat minSize = min(iResolution.x, iResolution.y);\nfloat _seed_variation_ = SEED_VARIATION;\nvec2 UV = vec2(0.0, 1.0) + vec2(1.0, -1.0) * (fragCoord-0.5*(iResolution.xy-vec2(minSize)))/minSize;\nvec3 o6428_0_1_rgb = pathtracing_o6428((UV), _seed_variation_);\nfragColor = vec4(o6428_0_1_rgb, 1.0);\n EDITED OLD}*/\n\n\n\n//EDITED NEW\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    vec2 xy=fragCoord+vec2(RandomFloat01(rngState),RandomFloat01(rngState));\n\n    float minSize = min(iResolution.x, iResolution.y);\n    float _seed_variation_ = SEED_VARIATION;\n    vec2 UV = vec2(0.0, 1.0) + vec2(1.0, -1.0) * (xy-0.5*(iResolution.xy-vec2(minSize)))/minSize;\n    vec3 rgb = /*change here*/pathtracing_o6428(rngState,(UV), _seed_variation_);\n\n    if (iMouse.z<0.1){\n        vec4 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy);\n        fragColor = vec4(lastFrameColor+vec4(rgb,1.0));\n    } else {\n        fragColor = vec4(rgb,1.0);\n    }\n\n}\n//EDITED NEW", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flyGRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[711, 711, 767, 767, 906]], "test": "untested"}
{"id": "fty3RR", "name": "Among Us 2D", "author": "SneakySnail600", "description": "When the code is sus.", "tags": ["amongus"], "likes": 2, "viewed": 193, "published": 3, "date": "1637010423", "time_retrieved": "2024-07-30T18:47:55.449486", "image_code": "/*\n * \"Among Us 2D\" by Josh O'Hagan aka SneakySnail600 - 2024\n * License Creative Commons ATTRIBUTION 4.0 INTERNATIONAL\n * Contact: joshohagan17@outlook.co.nz\n */\n \nbool inBounds(float coord, float lower, float upper){\n    return coord < upper && coord > lower;\n}\n\nbool inCircle(vec2 uv, float centre_x, float centre_y, float radius){\n    return pow(uv.x - centre_x, 2.0) + pow(uv.y - centre_y, 2.0) < pow(radius, 2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col;\n    vec3 col_background = vec3(0, 0, 0);\n    vec3 col_foreground = vec3(1, 0, 0);\n    vec3 col_visor = vec3(0.9);\n    col = col_background;\n    \n    float canvas_left = 0.3;\n    float canvas_right = 0.7;\n    \n    // Pre define some variables to be used inside and outside the canvas.\n    \n    // Legs\n    float leg_top = 0.14;\n    float leg_bottom = 0.0;\n    \n    float left_leg_left = 0.2;\n    float left_leg_right = 0.42;\n    float right_leg_left = 0.58;\n    float right_leg_right = 0.8;\n    \n    // Body\n    float body_bottom = leg_top;\n    float body_top = 0.7;\n    \n    // Head\n    float head_centre_x = 0.5;\n    float head_centre_y = body_top;\n    float head_radius = abs(canvas_left - canvas_right) / 2.0;\n    \n    // Visor\n    float visor_radius = head_radius / 2.0;\n    float visor_centre_x = 0.63;\n    float visor_centre_y = body_top - 0.1;\n    \n    // Visor outline\n    float visor_outline_raidus = visor_radius + 0.02;\n    \n    // Pack\n    float pack_left = canvas_left - 0.1;\n    float pack_right = canvas_left - 0.01;\n    float pack_bottom = leg_top;\n    float pack_top = body_top;\n    \n    // Partition the drawing canvas for most of the body parts.\n    if (inBounds(uv.x, canvas_left, canvas_right)){\n\n        // Legs\n        if (inBounds(uv.y, leg_bottom, leg_top)){\n\n            // Left leg\n            if (inBounds(uv.x, left_leg_left, left_leg_right)){\n                col = col_foreground;\n            }\n\n            // Right leg\n            if (inBounds(uv.x, right_leg_left, right_leg_right)){\n                col = col_foreground;\n            }\n        }\n        \n        // Body\n        if (inBounds(uv.y, body_bottom, body_top)){\n            col = col_foreground;\n        }\n        \n        // Head\n        if (inCircle(uv, head_centre_x, head_centre_y, head_radius)){\n            col = col_foreground;\n        }\n    }\n\n    // Visor outline\n    if (inCircle(uv, visor_centre_x, visor_centre_y, visor_outline_raidus)){\n        col = col_background;\n    }\n    \n    // Visor\n    if (inCircle(uv, visor_centre_x, visor_centre_y, visor_radius)){\n        col = col_visor;\n    }\n    \n    // Pack\n    if (inBounds(uv.x, pack_left, pack_right) &&\n        inBounds(uv.y, pack_bottom, pack_top)){\n        col = col_foreground;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fty3RR.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[165, 165, 218, 218, 263], [265, 265, 334, 334, 421], [423, 423, 480, 530, 2928]], "test": "untested"}
{"id": "stt3Ws", "name": "Font Designer (32 segments)", "author": "iY0Yi", "description": "32segs Font Designer.\nOther experiments list:\n[url]https://www.shadertoy.com/playlist/tctBWH[/url]", "tags": ["font", "util"], "likes": 19, "viewed": 426, "published": 3, "date": "1636993617", "time_retrieved": "2024-07-30T18:47:56.368030", "image_code": "float fontSize = 1.;\nfloat fontWeight = .2;\n\n// lpnorm by gaz\n// https://www.shadertoy.com/view/slG3Rz\nfloat lpnorm(vec2 p, float n){vec2 t=pow(abs(p),vec2(n));return pow(t.x+t.y,1./n);}\n\n// iq's segment function\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b ){\n    vec2 ba = b-a;\n    float r = atan(abs(ba.y),abs(ba.x))/3.14;\n    vec2 pa = p-a;\n    //pa*=mat2(cos(r*.05+vec4(0,11,33,0)));\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return lpnorm( pa - ba*h, 2. );\n}\n\n// Modify skeleton\n#define SEGX .5\n#define SEGY .8\n#define SEGCX 0.\n#define SEGCY 0.05\n#define SEGYHP +.45\n#define SEGYHN -.38\n\n// Short hands\n#define START_SEG float d = 1e4\n#define END_SEG return d\n#define DRAW_SEG(v1, v2) d=min(sdSegment(p, v1, v2)-fontWeight,d)\n\n// Outer Box (Start from Top/Left. Clockwise. SEG0-11)\n#define SEG0  DRAW_SEG(vec2( -SEGX, +SEGY), vec2( SEGCX, +SEGY))\n#define SEG1  DRAW_SEG(vec2( SEGCX, +SEGY), vec2( +SEGX, +SEGY))\n#define SEG2  DRAW_SEG(vec2( +SEGX, +SEGY), vec2( +SEGX,SEGYHP))\n#define SEG3  DRAW_SEG(vec2( +SEGX,SEGYHP), vec2( +SEGX, SEGCY))\n#define SEG4  DRAW_SEG(vec2( +SEGX, SEGCY), vec2( +SEGX,SEGYHN))\n#define SEG5  DRAW_SEG(vec2( +SEGX,SEGYHN), vec2( +SEGX, -SEGY))\n#define SEG6  DRAW_SEG(vec2( +SEGX, -SEGY), vec2( SEGCX, -SEGY))\n#define SEG7  DRAW_SEG(vec2( SEGCX, -SEGY), vec2( -SEGX, -SEGY))\n#define SEG8  DRAW_SEG(vec2( -SEGX, -SEGY), vec2( -SEGX,SEGYHN))\n#define SEG9  DRAW_SEG(vec2( -SEGX,SEGYHN), vec2( -SEGX, SEGCY))\n#define SEG10 DRAW_SEG(vec2( -SEGX, SEGCY), vec2( -SEGX,SEGYHP))\n#define SEG11 DRAW_SEG(vec2( -SEGX,SEGYHP), vec2( -SEGX, +SEGY))\n// Top Rhombus (Start from Top/Left. Clockwise. SEG12-15)\n#define SEG12 DRAW_SEG(vec2( -SEGX,SEGYHP), vec2( SEGCX, +SEGY))\n#define SEG13 DRAW_SEG(vec2( SEGCX, +SEGY), vec2( +SEGX,SEGYHP))\n#define SEG14 DRAW_SEG(vec2( +SEGX,SEGYHP), vec2( SEGCX, SEGCY))\n#define SEG15 DRAW_SEG(vec2( SEGCX, SEGCY), vec2( -SEGX,SEGYHP))\n// Bottom Rhombus (Start from Top/Left. Clockwise. SEG16-19)\n#define SEG16 DRAW_SEG(vec2( -SEGX,SEGYHN), vec2( SEGCX, SEGCY))\n#define SEG17 DRAW_SEG(vec2( SEGCX, SEGCY), vec2( +SEGX,SEGYHN))\n#define SEG18 DRAW_SEG(vec2( +SEGX,SEGYHN), vec2( SEGCX, -SEGY))\n#define SEG19 DRAW_SEG(vec2( SEGCX, -SEGY), vec2( -SEGX,SEGYHN))\n// Center Vertical line (Top>Bottom. SEG20,21)\n#define SEG20 DRAW_SEG(vec2( SEGCX, +SEGY), vec2( SEGCX, SEGCY))\n#define SEG21 DRAW_SEG(vec2( SEGCX, SEGCY), vec2( SEGCX, -SEGY))\n// Center Horizont line (Left>Right. SEG22,23)\n#define SEG22 DRAW_SEG(vec2( -SEGX, SEGCY), vec2( SEGCX, SEGCY))\n#define SEG23 DRAW_SEG(vec2( SEGCX, SEGCY), vec2( +SEGX, SEGCY))\n// X in Top box (Start from Top/Left. Clockwise. SEG24-27)\n#define SEG24 DRAW_SEG(vec2( -SEGX, +SEGY), vec2( SEGCX,SEGYHP))\n#define SEG25 DRAW_SEG(vec2( SEGCX,SEGYHP), vec2( +SEGX, +SEGY))\n#define SEG26 DRAW_SEG(vec2( -SEGX, SEGCY), vec2( SEGCX,SEGYHP))\n#define SEG27 DRAW_SEG(vec2( SEGCX,SEGYHP), vec2( +SEGX, SEGCY))\n// X in Top box (Start from Top/Left. Clockwise. SEG28-31)\n#define SEG28 DRAW_SEG(vec2( -SEGX, SEGCY), vec2( SEGCX,SEGYHN))\n#define SEG29 DRAW_SEG(vec2( SEGCX,SEGYHN), vec2( +SEGX, SEGCY))\n#define SEG30 DRAW_SEG(vec2( SEGCX,SEGYHN), vec2( +SEGX, -SEGY))\n#define SEG31 DRAW_SEG(vec2( -SEGX, -SEGY), vec2( SEGCX,SEGYHN))\n\n\n#define SKIP_DRAW d=d\n#define SEG0x  SKIP_DRAW\n#define SEG1x  SKIP_DRAW\n#define SEG2x  SKIP_DRAW\n#define SEG3x  SKIP_DRAW\n#define SEG4x  SKIP_DRAW\n#define SEG5x  SKIP_DRAW\n#define SEG6x  SKIP_DRAW\n#define SEG7x  SKIP_DRAW\n#define SEG8x  SKIP_DRAW\n#define SEG9x  SKIP_DRAW\n#define SEG10x SKIP_DRAW\n#define SEG11x SKIP_DRAW\n#define SEG12x SKIP_DRAW\n#define SEG13x SKIP_DRAW\n#define SEG14x SKIP_DRAW\n#define SEG15x SKIP_DRAW\n#define SEG16x SKIP_DRAW\n#define SEG17x SKIP_DRAW\n#define SEG18x SKIP_DRAW\n#define SEG19x SKIP_DRAW\n#define SEG20x SKIP_DRAW\n#define SEG21x SKIP_DRAW\n#define SEG22x SKIP_DRAW\n#define SEG23x SKIP_DRAW\n#define SEG24x SKIP_DRAW\n#define SEG25x SKIP_DRAW\n#define SEG26x SKIP_DRAW\n#define SEG27x SKIP_DRAW\n#define SEG28x SKIP_DRAW\n#define SEG29x SKIP_DRAW\n#define SEG30x SKIP_DRAW\n#define SEG31x SKIP_DRAW\n\n#define SEG0o  SEG0\n#define SEG1o  SEG1\n#define SEG2o  SEG2\n#define SEG3o  SEG3\n#define SEG4o  SEG4\n#define SEG5o  SEG5\n#define SEG6o  SEG6\n#define SEG7o  SEG7\n#define SEG8o  SEG8\n#define SEG9o  SEG9\n#define SEG10o SEG10\n#define SEG11o SEG11\n#define SEG12o SEG12\n#define SEG13o SEG13\n#define SEG14o SEG14\n#define SEG15o SEG15\n#define SEG16o SEG16\n#define SEG17o SEG17\n#define SEG18o SEG18\n#define SEG19o SEG19\n#define SEG20o SEG20\n#define SEG21o SEG21\n#define SEG22o SEG22\n#define SEG23o SEG23\n#define SEG24o SEG24\n#define SEG25o SEG25\n#define SEG26o SEG26\n#define SEG27o SEG27\n#define SEG28o SEG28\n#define SEG29o SEG29\n#define SEG30o SEG30\n#define SEG31o SEG31\n\nfloat sdAllSeg(vec2 p) {\n    // Start designing with copy & paste below lines.\n    // -------------------------------- ✂ -----------------------------------\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1o,  SEG2o,  SEG3o, SEG10o, SEG11o;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5o,  SEG6o,  SEG7o,  SEG8o,  SEG9o;\n    /*TopRhombus*/      SEG12o, SEG13o, SEG14o, SEG15o;\n    /*BottomRhombus*/   SEG16o, SEG17o, SEG18o, SEG19o;\n    /*VerticalLine*/    SEG20o, SEG21o;\n    /*HorizontLine*/    SEG22o, SEG23o;\n    /*X(Top)*/          SEG24o, SEG25o, SEG26o, SEG27o;\n    /*X(Bottom)*/       SEG28o, SEG29o, SEG30o, SEG31o;\n    END_SEG;\n    // -------------------------------- ✂ -----------------------------------\n}\n\nfloat sdNum0(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1o,  SEG2o,  SEG3o, SEG10o, SEG11o;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5o,  SEG6o,  SEG7o,  SEG8o,  SEG9o;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14o, SEG15x;\n    /*BottomRhombus*/   SEG16o, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22x, SEG23x;\n    END_SEG;\n}\nfloat sdNum1(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0x,  SEG1x,  SEG2x,  SEG3x, SEG10x, SEG11x;\n    /*OuterBox(Bottom)*/ SEG4x,  SEG5x,  SEG6o,  SEG7o,  SEG8x,  SEG9x;\n    /*TopRhombus*/      SEG12o, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20o, SEG21o;\n    /*HorizontLine*/    SEG22x, SEG23x;\n    END_SEG;\n}\nfloat sdNum2(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1o,  SEG2o,  SEG3o, SEG10x, SEG11o;\n    /*OuterBox(Bottom)*/ SEG4x,  SEG5x,  SEG6o,  SEG7o,  SEG8x, SEG9x;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22x, SEG23x;\n    /*X(Top)*/          SEG24x, SEG25x, SEG26x, SEG27x;\n    /*X(Bottom)*/       SEG28x, SEG29o, SEG30x, SEG31o;\n    END_SEG;\n}\nfloat sdNum3(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1o,  SEG2o,  SEG3x, SEG10x, SEG11x;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5o,  SEG6o,  SEG7o,  SEG8o,  SEG9x;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14o, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22x, SEG23o;\n    /*X(Top)*/          SEG24x, SEG25x, SEG26x, SEG27x;\n    /*X(Bottom)*/       SEG28x, SEG29x, SEG30x, SEG31x;\n    END_SEG;\n}\nfloat sdNum4(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0x,  SEG1x,  SEG2o,  SEG3o, SEG10o, SEG11o;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5o,  SEG6x,  SEG7x,  SEG8x,  SEG9x;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22o, SEG23o;\n    END_SEG;\n}\nfloat sdNum5(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1o,  SEG2x,  SEG3x, SEG10o, SEG11o;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5o,  SEG6o,  SEG7o,  SEG8x, SEG9x;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22o, SEG23o;\n    END_SEG;\n}\nfloat sdNum6(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0x,  SEG1x,  SEG2x,  SEG3x, SEG10o, SEG11x;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5o,  SEG6o,  SEG7o,  SEG8o,  SEG9o;\n    /*TopRhombus*/      SEG12o, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22o, SEG23o;\n    END_SEG;\n}\nfloat sdNum7(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1o,  SEG2o,  SEG3o, SEG10x, SEG11o;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5o,  SEG6x,  SEG7x,  SEG8x,  SEG9x;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22x, SEG23x;\n    END_SEG;\n}\nfloat sdNum8(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1o,  SEG2o,  SEG3x, SEG10x, SEG11o;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5o,  SEG6o,  SEG7o,  SEG8o,  SEG9o;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14o, SEG15o;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18x, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22o, SEG23o;\n    END_SEG;\n}\nfloat sdNum9(vec2 p) {\n    START_SEG;\n    /*OuterBox(Top)*/    SEG0o,  SEG1o,  SEG2o,  SEG3o, SEG10o, SEG11o;\n    /*OuterBox(Bottom)*/ SEG4o,  SEG5x,  SEG6x,  SEG7x,  SEG8x,  SEG9x;\n    /*TopRhombus*/      SEG12x, SEG13x, SEG14x, SEG15x;\n    /*BottomRhombus*/   SEG16x, SEG17x, SEG18o, SEG19x;\n    /*VerticalLine*/    SEG20x, SEG21x;\n    /*HorizontLine*/    SEG22o, SEG23o;\n    END_SEG;\n}\n\nfloat sdNumFont(vec2 p, float s, float fi) {\n    p /= s;\n    int i = int(mod(floor(fi), 10.)); // 0-9    \n    switch(i){\n        case 0:\n            return sdNum0(p);\n        case 1:\n            return sdNum1(p);\n        case 2:\n            return sdNum2(p);\n        case 3:\n            return sdNum3(p);\n        case 4:\n            return sdNum4(p);\n        case 5:\n            return sdNum5(p);\n        case 6:\n            return sdNum6(p);\n        case 7:\n            return sdNum7(p);\n        case 8:\n            return sdNum8(p);\n        case 9:\n            return sdNum9(p);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord/iResolution.xy;\n    vec2 grid = vec2(.2,.5);\n    vec2 ip = floor(p/grid);\n    p = mod(p, grid)/grid*2.-1.;\n    p.y*=iResolution.x/iResolution.y;\n    p.y*=.8; // ???\n    \n\tfontWeight = .2-clamp(sin(iTime*1.5)*2.,0.,1.)*.19;\n    fontSize = .7;\n    float num = ip.x+(1.-ip.y)*5.;// + floor(exp(clamp(sin(iTime*5.),0.,1.))*10.) + floor(sin(iTime*.5)*10.);\n    float d = sdNumFont(p, fontSize, num);\n    d = 1.-smoothstep(.0,.005,d);\n    \n    vec3 col = mix(vec3(0.102,0.102,0.102), vec3(.8, .77, .7), d);\n \n    // Draw Skeleton\n    col = max(col, vec3(.8, .77, .7)*.3*smoothstep(0.02, 0., abs(sdAllSeg(p/fontSize)+fontWeight)-.002));\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stt3Ws.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 103, 133, 133, 186], [188, 213, 264, 264, 486], [4709, 4709, 4733, 4867, 5425], [5427, 5427, 5449, 5449, 5815], [5816, 5816, 5838, 5838, 6204], [6205, 6205, 6227, 6227, 6704], [6705, 6705, 6727, 6727, 7205], [7206, 7206, 7228, 7228, 7594], [7595, 7595, 7617, 7617, 7982], [7983, 7983, 8005, 8005, 8371], [8372, 8372, 8394, 8394, 8760], [8761, 8761, 8783, 8783, 9149], [9150, 9150, 9172, 9172, 9538], [9540, 9540, 9584, 9584, 10128], [10130, 10130, 10187, 10187, 10872]], "test": "untested"}
{"id": "stdGWs", "name": "entropy 5", "author": "FabriceNeyret2", "description": ".\n", "tags": ["2d", "short", "reproduction"], "likes": 14, "viewed": 345, "published": 3, "date": "1636992457", "time_retrieved": "2024-07-30T18:47:57.272612", "image_code": "// variant of https://shadertoy.com/view/sld3Dl\n\n// ---------------------- utils from https://www.shadertoy.com/view/llySRh\n#define H(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\nvec4 char(vec2 p, int c) {\n   // vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n   vec2 dFdx = vec2(3./R.y/16.,0), dFdy = dFdx.yx ;\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                        dFdx, dFdy );\n}\n#define spc  U.x-=.5;\n#define C(c) spc d = min(d, char(U,64+32+c).w );\n// ----------------------\n\nvoid mainImage( out vec4 O, vec2 u ) {\n    vec2 U = u / R.y, \n         p = (u/2.);\n         \n    float d = 9.;\n    U = T(u).xy;\n    U *= 2.5; U -= vec2(-.3,.8);            // draw text\n    C(5)C(14)C(20)C(18)C(15)C(16)C(25)      // \"entropy\"\n    O = vec4( smoothstep(0., 4./R.y,d-.5) );\n}\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = u/R.y;\n    if (iFrame<1) O = vec4(U,0,0);\n    else {\n        vec2 P =  U - H(vec2(iTime))*R /R.y;       \n        float d = length(P);\n        O.xy = T(u).xy + .3* max(0.,U.x-.2)*  P* smoothstep(.1,0.,d);   // bomp uv space\n     }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R    iResolution.xy\n#define H(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define T(U) texelFetch( iChannel0, ivec2(U), 0 )", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdGWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[200, 200, 226, 277, 511]], "test": "untested"}
{"id": "sttGWs", "name": "Hot Stuff 2", "author": "me_123", "description": "its hot", "tags": ["ray", "displacement", "sphere"], "likes": 4, "viewed": 334, "published": 3, "date": "1636991074", "time_retrieved": "2024-07-30T18:47:58.204121", "image_code": "#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n\nconst ivec2 POSITION = ivec2(1, 0);\nconst ivec2 VMOUSE = ivec2(1, 1);\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n//iq's noise\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\nvoid Camera(in vec2 fragCoord, out vec3 ro, out vec3 rd) \n{\n    vec2 uv = (fragCoord.xy/iResolution.xy)-0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    float y = (((iMouse.y)/(iResolution.y))*3.14)+0.01;\n    ro = vec3(\n        cos(iMouse.x*0.01)*sin(y),\n        sin(iMouse.x*0.01)*sin(y),\n        cos(y)\n    );\n        ro *= 3.;\n    vec3 at = vec3(0.0);\n    vec3 cam_z = normalize(at-ro);\n    vec3 cam_x = normalize(cross(vec3(0, 0, 1), cam_z));\n    vec3 cam_y = cross(cam_z, cam_x);\n    rd = normalize(uv.x * cam_x + uv.y * cam_y + 1.1 * cam_z);\n}\nvec2 sphere(in vec3 ro, in vec3 rd, in vec3 ce, in float ra) {\n    vec3 oc = ro-ce;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - ra*ra;\n    float h = b*b-c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b-h, -b+h);\n}\nvec2 box(in vec3 ro, in vec3 rd, in vec3 size) {\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*size;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if (tN > tF || tF < 0.0) return vec2(-1.0);\n    return vec2(tN, tF);\n}\nbool f(vec3 p) {\n \treturn noise((p*8.)+vec3(iTime, iTime*0.1, iTime*2.0)) < (0.15-(length((p))-1.0))*4.0;//tan((phi+(sin((p.y+(iTime*0.2))*5.0)*1.))*5.) > 2.0;//sin(length(vec2(p.x, p.z))+iTime) > p.y;\n}\nconst float ss = 0.01;\nvec3 getColor(in vec3 ro, in vec3 rd) {\n    vec2 planet = sphere(ro, rd, vec3(0), 1.);\n    vec2 sur = sphere(ro, rd, vec3(0), 1.2);\n    float thru=0.0;\n    if (sur.x != -1.0) {\n        if (sur.x > 0.0) {\n\t        thru = sur.y-sur.x;\n            if (planet.x > 0.0) {\n            \tthru = planet.x-sur.x;\n            }\n        } else {\n        \tthru = sur.y;\n            if (planet.x > 0.0) {\n            \tthru = planet.x;\n            }\n        }\n    }\n    vec3 col = vec3(0);\n    vec3 start = ro+rd*sur.x;\n    if (sur.x < 0.0) {\n    \tstart = ro;\n    }\n    float i;\n    float s = thru*ss;\n    for (i = 0.0; i < thru; i += s) {\n    \tstart += rd*s;\n        if (f(start)) {\n            float of = (length(start)-1.03)*20.;\n            col = vec3(mix(vec3(1.0, 1.0, 0.5), vec3(1.0, 0.4, 0.0), of));\n        \t//col += 0.01;\n            break;\n        }\n    }\n    if (length(start)-1.0 < 0.0001) {\n    \treturn vec3(1.0, 1.0, 0.8);\n    };\n    if (col.x == 0.0) {\n        return vec3(mix(vec3(0.5, 0.0, 0.0), vec3(1.0, 0.9, 0.2), noise(rd*2.0)-0.2));\n    }\n    return vec3(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec3 rd;\n\tvec3 ro;\n    Camera(fragCoord, ro, rd);\n    vec3 c = getColor(ro ,rd);\n    fragColor = vec4(c, 0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sttGWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 122, 179, 179, 274], [275, 288, 314, 314, 788], [789, 789, 848, 848, 1339], [1340, 1340, 1402, 1402, 1590], [1591, 1591, 1639, 1639, 1910], [1911, 1911, 1927, 1927, 2114], [2138, 2138, 2177, 2177, 3208], [3210, 3210, 3267, 3267, 3381]], "test": "untested"}
{"id": "sld3Dl", "name": "entropy 4", "author": "FabriceNeyret2", "description": "reference: see first shader.\n", "tags": ["2d", "short", "reproduction"], "likes": 9, "viewed": 271, "published": 3, "date": "1636991044", "time_retrieved": "2024-07-30T18:47:59.422862", "image_code": "// variant of https://shadertoy.com/view/stt3Wl\n\n\nvoid mainImage( out vec4 O, vec2 U ) {\n    O = 1.-T(U);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{\n    if  ( iFrame<1 ) O-=O, O.x = .5*U.x;\n    else if (U.y<1.) O.xy = T(U).xy + .003* U.x* ( 2.*H(U-iTime)-1. );\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R    iResolution\n#define H(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define T(U) texelFetch( iChannel0, ivec2(U), 0 )", "buffer_b_code": "// ---------------------- utils from https://www.shadertoy.com/view/llySRh\n#define H(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\nvec4 char(vec2 p, int c) {\n   // vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n   vec2 dFdx = vec2(3./R.y/16.,0), dFdy = dFdx.yx ;\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                        dFdx, dFdy );\n}\n// ----------------------\n\n#define C(c)  O = max(O, char( U-T(vec2(i++,0)).xy, 64+32+c ).x ); // draw char i at location T()\n\n\nvoid mainImage( out vec4 O, vec2 u ) {\n    vec2 U = u / R.y, \n         p = (u/2.);\n         \n    float i = 0.;\n    O = .95*texelFetch( iChannel2, ivec2(u), 0 );\n    U *= 2.5; U -= vec2(-.3,.8);            // draw text\n    C(5)C(14)C(20)C(18)C(15)C(16)C(25)      // \"entropy\"\n}\n", "buffer_b_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sld3Dl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 88, 88, 107]], "test": "untested"}
{"id": "7td3Dl", "name": "entropy 3", "author": "FabriceNeyret2", "description": "reference: see first shader.\n", "tags": ["2d", "short", "reproduction"], "likes": 10, "viewed": 278, "published": 3, "date": "1636989199", "time_retrieved": "2024-07-30T18:48:00.609689", "image_code": "// variant of https://shadertoy.com/view/slt3Dl\n// variant of https://shadertoy.com/view/stt3Wl\n\n#define R iResolution\n// ---------------------- utils from https://www.shadertoy.com/view/llySRh\n#define H(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\nvec4 char(vec2 p, int c) {\n   // vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n   vec2 dFdx = vec2(3./R.y/16.,0), dFdy = dFdx.yx ;\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                        dFdx, dFdy );\n}\n#define spc  U.x-=.5;\n#define C(c) spc O += char(U,64+32+c).x;\n// ----------------------\n\nvoid mainImage( out vec4 O, vec2 u ) {\n    vec2 U = u / R.y, \n         p = (u/2.);\n         \n    float t = mod(iTime,20.),\n          e = max(0.,.06*t*(U.x-.2));                    // jitter\n    if ( H(p).x < e ) U.y -= t*(H(p).x-e); \n    \n    O -= O;\n    U *= 2.5; U -= vec2(-.3,.8);                         // draw text\n    C(5)C(14)C(20)C(18)C(15)C(16)C(25)                   // \"entropy\"\n    O = 1.-O;\n}\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7td3Dl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[270, 270, 296, 347, 581]], "test": "untested"}
{"id": "slt3Dl", "name": "entropy 2", "author": "FabriceNeyret2", "description": "reference: see first shader.", "tags": ["2d", "short", "reproduction"], "likes": 12, "viewed": 341, "published": 3, "date": "1636988134", "time_retrieved": "2024-07-30T18:48:01.518260", "image_code": "// variant of  https://shadertoy.com/view/stt3Wl\n\n#define R iResolution\n// ---------------------- utils from https://www.shadertoy.com/view/llySRh\n#define H(p) ( 2.* fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) -1. )\n\nvec4 char(vec2 p, int c) {\n   // vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n   vec2 dFdx = vec2(3./R.y/16.,0), dFdy = dFdx.yx ;\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                        dFdx, dFdy );\n}\n#define spc  U.x-=.5;\n#define C(c) spc O += char(U,64+32+c).x;\n// ----------------------\n\nvoid mainImage( out vec4 O, vec2 u ) {\n    vec2 U = u / R.y, \n         p = (u/1.);\n         \n    float t = mod(iTime,20.),\n          e = max(0.,.01*(exp2(.5*t)-1.)*(U.x-.2));      // jitter\n    if ( H(p+.5 ).x < e ) U += e * H(p);\n    \n    O -= O;\n    U *= 2.5; U -= vec2(-.3,.8);                         // draw text\n    C(5)C(14)C(20)C(18)C(15)C(16)C(25)                   // \"entropy\"\n    O = 1.-O;\n}\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slt3Dl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[235, 235, 261, 312, 546]], "test": "untested"}
{"id": "7ltGDl", "name": "A green thing in a bathroom RT", "author": "PauloFalcao", "description": "Original shade here - https://www.shadertoy.com/view/st3GDs\nThis is the same shader but using a different render node using a local illumination, non path tracing version", "tags": ["materialmaker", "nodes"], "likes": 4, "viewed": 263, "published": 3, "date": "1636984454", "time_retrieved": "2024-07-30T18:48:02.857678", "image_code": "// A green thing in a bathroom - Realtime Version\n//\n// Original shade here - https://www.shadertoy.com/view/st3GDs\n//\n// This is the same shader but using a different render node, plus some animated parameters\n// Using local illumination, non path tracing version\n//\n// By https://twitter.com/paulofalcao\n//\n//\n// To generate your own shaders you need:\n//\n// - Material Maker - https://rodzilla.itch.io/material-maker\n// - My Ray Marching library - https://github.com/paulofalcao/MaterialMakerRayMarching\n// \n// Here is a 2 hour video explaining how to use it - https://youtu.be/PvmIohbf93Q\n// \n\n/* Generated by Material Maker */\n\n#define SEED_VARIATION 0.0\n\n//---\n\nfloat rand(vec2 x) {\n    return fract(cos(mod(dot(x, vec2(13.9898, 8.141)), 3.14)) * 43758.5453);\n}\n\nvec2 rand2(vec2 x) {\n    return fract(cos(mod(vec2(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t      dot(x, vec2(3.4562, 17.398))), vec2(3.14))) * 43758.5453);\n}\n\nvec3 rand3(vec2 x) {\n    return fract(cos(mod(vec3(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t\t  dot(x, vec2(3.4562, 17.398)),\n                              dot(x, vec2(13.254, 5.867))), vec3(3.14))) * 43758.5453);\n}\n\nvec3 rgb2hsv(vec3 c) {\n\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n\tvec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nfloat param_rnd(float minimum, float maximum, float seed) {\n\treturn minimum+(maximum-minimum)*rand(vec2(seed));\n}\n//Adapted from https://iquilezles.org/articles/distfunctions - Finite Repetition\n\nvec3 opRepLim(vec3 p,vec3 c,vec3 l){\n    p+=(c*l)/2.0;\n    return p-c*clamp(floor(p/c+0.5),vec3(0.0),l);\n}vec3 MFSDF_Obj_Maker_rotate3d(vec3 p, vec3 a) {\n\tvec3 rv;\n\tfloat c;\n\tfloat s;\n\tc = cos(a.x);\n\ts = sin(a.x);\n\trv.x = p.x;\n\trv.y = p.y*c+p.z*s;\n\trv.z = -p.y*s+p.z*c;\n\tc = cos(a.y);\n\ts = sin(a.y);\n\tp.x = rv.x*c+rv.z*s;\n\tp.y = rv.y;\n\tp.z = -rv.x*s+rv.z*c;\n\tc = cos(a.z);\n\ts = sin(a.z);\n\trv.x = p.x*c+p.y*s;\n\trv.y = -p.x*s+p.y*c;\n\trv.z = p.z;\n\treturn rv;\n}\nvec4 brick(vec2 uv, vec2 bmin, vec2 bmax, float mortar, float round, float bevel) {\n\tfloat color;\n\tvec2 size = bmax - bmin;\n\tfloat min_size = min(size.x, size.y);\n\tmortar *= min_size;\n\tbevel *= min_size;\n\tround *= min_size;\n\tvec2 center = 0.5*(bmin+bmax);\n    vec2 d = abs(uv-center)-0.5*(size)+vec2(round+mortar);\n    color = length(max(d,vec2(0))) + min(max(d.x,d.y),0.0)-round;\n\tcolor = clamp(-color/bevel, 0.0, 1.0);\n\tvec2 tiled_brick_pos = mod(bmin, vec2(1.0, 1.0));\n\treturn vec4(color, center, tiled_brick_pos.x+7.0*tiled_brick_pos.y);\n}\n\nvec3 brick_random_color(vec2 bmin, vec2 bmax, float seed) {\n\tvec2 center = 0.5*(bmin + bmax);\n\treturn rand3(fract(center + vec2(seed)));\n}\n\nvec3 brick_uv(vec2 uv, vec2 bmin, vec2 bmax, float seed) {\n\tvec2 center = 0.5*(bmin + bmax);\n\tvec2 size = bmax - bmin;\n\tfloat max_size = max(size.x, size.y);\n\treturn vec3(0.5+(uv-center)/max_size, rand(fract(center)+vec2(seed)));\n}\n\nvec3 brick_corner_uv(vec2 uv, vec2 bmin, vec2 bmax, float mortar, float corner, float seed) {\n\tvec2 center = 0.5*(bmin + bmax);\n\tvec2 size = bmax - bmin;\n\tfloat max_size = max(size.x, size.y);\n\tfloat min_size = min(size.x, size.y);\n\tmortar *= min_size;\n\tcorner *= min_size;\n\treturn vec3(clamp((0.5*size-vec2(mortar)-abs(uv-center))/corner, vec2(0.0), vec2(1.0)), rand(fract(center)+vec2(seed)+ceil(vec2(uv-center))));\n}\n\nvec4 bricks_rb(vec2 uv, vec2 count, float repeat, float offset) {\n\tcount *= repeat;\n\tfloat x_offset = offset*step(0.5, fract(uv.y*count.y*0.5));\n\tvec2 bmin = floor(vec2(uv.x*count.x-x_offset, uv.y*count.y));\n\tbmin.x += x_offset;\n\tbmin /= count;\n\treturn vec4(bmin, bmin+vec2(1.0)/count);\n}\n\nvec4 bricks_rb2(vec2 uv, vec2 count, float repeat, float offset) {\n\tcount *= repeat;\n\tfloat x_offset = offset*step(0.5, fract(uv.y*count.y*0.5));\n\tcount.x = count.x*(1.0+step(0.5, fract(uv.y*count.y*0.5)));\n\tvec2 bmin = floor(vec2(uv.x*count.x-x_offset, uv.y*count.y));\n\tbmin.x += x_offset;\n\tbmin /= count;\n\treturn vec4(bmin, bmin+vec2(1.0)/count);\n}\n\nvec4 bricks_hb(vec2 uv, vec2 count, float repeat, float offset) {\n\tfloat pc = count.x+count.y;\n\tfloat c = pc*repeat;\n\tvec2 corner = floor(uv*c);\n\tfloat cdiff = mod(corner.x-corner.y, pc);\n\tif (cdiff < count.x) {\n\t\treturn vec4((corner-vec2(cdiff, 0.0))/c, (corner-vec2(cdiff, 0.0)+vec2(count.x, 1.0))/c);\n\t} else {\n\t\treturn vec4((corner-vec2(0.0, pc-cdiff-1.0))/c, (corner-vec2(0.0, pc-cdiff-1.0)+vec2(1.0, count.y))/c);\n\t}\n}\n\nvec4 bricks_bw(vec2 uv, vec2 count, float repeat, float offset) {\n\tvec2 c = 2.0*count*repeat;\n\tfloat mc = max(c.x, c.y);\n\tvec2 corner1 = floor(uv*c);\n\tvec2 corner2 = count*floor(repeat*2.0*uv);\n\tfloat cdiff = mod(dot(floor(repeat*2.0*uv), vec2(1.0)), 2.0);\n\tvec2 corner;\n\tvec2 size;\n\tif (cdiff == 0.0) {\n\t\tcorner = vec2(corner1.x, corner2.y);\n\t\tsize = vec2(1.0, count.y);\n\t} else {\n\t\tcorner = vec2(corner2.x, corner1.y);\n\t\tsize = vec2(count.x, 1.0);\n\t}\n\treturn vec4(corner/c, (corner+size)/c);\n}\n\nvec4 bricks_sb(vec2 uv, vec2 count, float repeat, float offset) {\n\tvec2 c = (count+vec2(1.0))*repeat;\n\tfloat mc = max(c.x, c.y);\n\tvec2 corner1 = floor(uv*c);\n\tvec2 corner2 = (count+vec2(1.0))*floor(repeat*uv);\n\tvec2 rcorner = corner1 - corner2;\n\tvec2 corner;\n\tvec2 size;\n\tif (rcorner.x == 0.0 && rcorner.y < count.y) {\n\t\tcorner = corner2;\n\t\tsize = vec2(1.0, count.y);\n\t} else if (rcorner.y == 0.0) {\n\t\tcorner = corner2+vec2(1.0, 0.0);\n\t\tsize = vec2(count.x, 1.0);\n\t} else if (rcorner.x == count.x) {\n\t\tcorner = corner2+vec2(count.x, 1.0);\n\t\tsize = vec2(1.0, count.y);\n\t} else if (rcorner.y == count.y) {\n\t\tcorner = corner2+vec2(0.0, count.y);\n\t\tsize = vec2(count.x, 1.0);\n\t} else {\n\t\tcorner = corner2+vec2(1.0);\n\t\tsize = vec2(count.x-1.0, count.y-1.0);\n\t}\n\treturn vec4(corner/c, (corner+size)/c);\n}// https://www.shadertoy.com/view/XsX3zB\n//\n// The MIT License\n// Copyright © 2013 Nikita Miropolskiy\n// \n// ( license has been changed from CCA-NC-SA 3.0 to MIT\n//\n//   but thanks for attributing your source code when deriving from this sample \n//   with a following link: https://www.shadertoy.com/view/XsX3zB )\n//\n//\n// if you're looking for procedural noise implementation examples you might \n// also want to look at the following shaders:\n// \n// Noise Lab shader by candycat: https://www.shadertoy.com/view/4sc3z2\n//\n// Noise shaders by iq:\n//     Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n//     Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n//     Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n//     Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n//     Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n//     Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n//     Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n//     Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n//     Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n//     Voronoise: https://www.shadertoy.com/view/Xd23Dh\n//\n//\n//\n\n// discontinuous pseudorandom constly distributed in [-0.5, +0.5]^3 */\nvec3 XsX3zB_oct_random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n// skew constants for 3d simplex functions\nconst float XsX3zB_oct_F3 =  0.3333333;\nconst float XsX3zB_oct_G3 =  0.1666667;\n\n// 3d simplex noise\nfloat XsX3zB_oct_simplex3d(vec3 p) {\n\t // 1. find current tetrahedron T and it's four vertices\n\t // s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices\n\t // x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices\n\t \n\t // calculate s and x\n\t vec3 s = floor(p + dot(p, vec3(XsX3zB_oct_F3)));\n\t vec3 x = p - s + dot(s, vec3(XsX3zB_oct_G3));\n\t \n\t // calculate i1 and i2\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t // x1, x2, x3\n\t vec3 x1 = x - i1 + XsX3zB_oct_G3;\n\t vec3 x2 = x - i2 + 2.0*XsX3zB_oct_G3;\n\t vec3 x3 = x - 1.0 + 3.0*XsX3zB_oct_G3;\n\t \n\t // 2. find four surflets and store them in d\n\t vec4 w, d;\n\t \n\t // calculate surflet weights\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t // w fades from 0.6 at the center of the surflet to 0.0 at the margin\n\t w = max(0.6 - w, 0.0);\n\t \n\t // calculate surflet components\n\t d.x = dot(XsX3zB_oct_random3(s), x);\n\t d.y = dot(XsX3zB_oct_random3(s + i1), x1);\n\t d.z = dot(XsX3zB_oct_random3(s + i2), x2);\n\t d.w = dot(XsX3zB_oct_random3(s + 1.0), x3);\n\t \n\t // multiply d by w^4\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t // 3. return the sum of the four surflets\n\t return dot(d, vec4(52.0));\n}vec2 transform2_clamp(vec2 uv) {\n\treturn clamp(uv, vec2(0.0), vec2(1.0));\n}\n\nvec2 transform2(vec2 uv, vec2 translate, float rotate, vec2 scale) {\n \tvec2 rv;\n\tuv -= translate;\n\tuv -= vec2(0.5);\n\trv.x = cos(rotate)*uv.x + sin(rotate)*uv.y;\n\trv.y = -sin(rotate)*uv.x + cos(rotate)*uv.y;\n\trv /= scale;\n\trv += vec2(0.5);\n\treturn rv;\t\n}vec4 sdf3dc_union(vec4 a, vec4 b) {\n\treturn vec4((a.w<b.w)?vec4(a):vec4(b));\n}\nvec4 sdf3dc_sub(vec4 a, vec4 b) {\n\treturn vec4((-a.w>b.w)?vec4(a.xyz,-a.w):vec4(b));\n}\nvec4 sdf3dc_inter(vec4 a, vec4 b) {\n\treturn vec4((a.w>b.w)?vec4(a):vec4(b));\n}vec3 v4v4_rotate(vec3 p, vec3 a) {\n\tvec3 rv;\n\tfloat c;\n\tfloat s;\n\tc = cos(a.x);\n\ts = sin(a.x);\n\trv.x = p.x;\n\trv.y = p.y*c+p.z*s;\n\trv.z = -p.y*s+p.z*c;\n\tc = cos(a.y);\n\ts = sin(a.y);\n\tp.x = rv.x*c+rv.z*s;\n\tp.y = rv.y;\n\tp.z = -rv.x*s+rv.z*c;\n\tc = cos(a.z);\n\ts = sin(a.z);\n\trv.x = p.x*c+p.y*s;\n\trv.y = -p.x*s+p.y*c;\n\trv.z = p.z;\n\treturn rv;\n}\nvec4 MFSDF_Union(vec4 in1,vec4 in2,vec4 in3,vec4 in4,vec4 in5,vec4 in6,vec4 in7,vec4 in8){\n    vec4 t=(in1.w<in2.w)?vec4(in1):vec4(in2);\n    t=(t.w<in2.w)?vec4(t):vec4(in2);\n    t=(t.w<in3.w)?vec4(t):vec4(in3);\n    t=(t.w<in4.w)?vec4(t):vec4(in4);\n    t=(t.w<in5.w)?vec4(t):vec4(in5);\n    t=(t.w<in6.w)?vec4(t):vec4(in6);\n    t=(t.w<in7.w)?vec4(t):vec4(in7);\n    t=(t.w<in8.w)?vec4(t):vec4(in8);\n    return t;\n}\n\nfloat mfsdf3d_smooth_union_f(float a,float b,float k){\n\tfloat h = max( k-abs(a-b), 0.0 )/k;\n\treturn min(a,b)-h*h*k*0.25;\n}\n\nvec4 mfsdf3d_smooth_union(vec4 a, vec4 b, float k) {\n    float e=0.001;\n    k=max(k,e);\n    float h=mfsdf3d_smooth_union_f(a.w,b.w,k);\n\tvec2 n=normalize(vec2(mfsdf3d_smooth_union_f(a.w+e,b.w,k)-mfsdf3d_smooth_union_f(a.w-e,b.w,k),\n                          mfsdf3d_smooth_union_f(a.w,b.w+e,k)-mfsdf3d_smooth_union_f(a.w,b.w-e,k)));\n    return vec4(mix(a.xyz,b.xyz,atan(abs(n.y),abs(n.x))/(3.14159265359/2.0)),h);\n}\n\nfloat mfsdf3d_smooth_subtraction_f(float a,float b,float k){\n\tfloat h = max( k-abs(-a-b), 0.0 )/k;\n\treturn max(-a,b)+h*h*k*0.25;\n}\n\nvec4 mfsdf3d_smooth_subtraction(vec4 a, vec4 b, float k) {\n    float e=0.001;\n    k=max(k,e);\n\tfloat h=mfsdf3d_smooth_subtraction_f(a.w,b.w,k);\n\tvec2 n=normalize(vec2(mfsdf3d_smooth_subtraction_f(a.w+e,b.w,k)-mfsdf3d_smooth_subtraction_f(a.w-e,b.w,k),\n                          mfsdf3d_smooth_subtraction_f(a.w,b.w+e,k)-mfsdf3d_smooth_subtraction_f(a.w,b.w-e,k)));\n    return vec4(mix(a.xyz,b.xyz,atan(abs(n.y),abs(n.x))/(3.14159265359/2.0)),h);\n}\n\nfloat mfsdf3d_smooth_intersection_f(float a,float b,float k){\n\tfloat h = max( k-abs(a-b), 0.0 )/k;\n\treturn max(a,b)+h*h*k*0.25;\n}\n\nvec4 mfsdf3d_smooth_intersection(vec4 a, vec4 b, float k) {\n    float e=0.001;\n    k=max(k,e);\n\tfloat h=mfsdf3d_smooth_intersection_f(a.w,b.w,k);\n\tvec2 n=normalize(vec2(mfsdf3d_smooth_intersection_f(a.w+e,b.w,k)-mfsdf3d_smooth_intersection_f(a.w-e,b.w,k),\n                          mfsdf3d_smooth_intersection_f(a.w,b.w+e,k)-mfsdf3d_smooth_intersection_f(a.w,b.w-e,k)));\n    return vec4(mix(a.xyz,b.xyz,atan(abs(n.y),abs(n.x))/(3.14159265359/2.0)),h);\n}vec2 twist_rot(vec2 v, float a) {\n\ta=a*0.01745329251;\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(vec2(c, -s),vec2(s, c));\n\treturn m * v;\n}\n\nvec3 twistX(vec3 v, float a){\n\tv.yz=twist_rot(v.yz,v.x*a);\n\treturn v;\n}\n\nvec3 twistY(vec3 v, float a){\n\tv.xz=twist_rot(v.xz,v.y*a);\n\treturn v;\n}\n\nvec3 twistZ(vec3 v, float a){\n\tv.xy=twist_rot(v.xy,v.z*a);\n\treturn v;\n}\n\nconst float PI=3.14159265359;\n\nvec2 equirectangularMap(vec3 dir) {\n\tvec2 longlat = vec2(atan(dir.y,dir.x),acos(dir.z));\n \treturn longlat/vec2(2.0*PI,PI);\n}\n\n\n//Simple HDRI START\n\n//Hash without Sine Dave_Hoskins\n//https://www.shadertoy.com/view/4djSRW \nfloat Simple360HDR_hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Simple360HDR_noise(vec2 v){\n  vec2 v1=floor(v);\n  vec2 v2=smoothstep(0.0,1.0,fract(v));\n  float n00=Simple360HDR_hash12(v1);\n  float n01=Simple360HDR_hash12(v1+vec2(0,1));\n  float n10=Simple360HDR_hash12(v1+vec2(1,0));\n  float n11=Simple360HDR_hash12(v1+vec2(1,1));\n  return mix(mix(n00,n01,v2.y),mix(n10,n11,v2.y),v2.x);\n}\n\nfloat Simple360HDR_noiseOct(vec2 p){\n  return\n    Simple360HDR_noise(p)*0.5+\n    Simple360HDR_noise(p*2.0+13.0)*0.25+\n    Simple360HDR_noise(p*4.0+23.0)*0.15+\n    Simple360HDR_noise(p*8.0+33.0)*0.10+\n    Simple360HDR_noise(p*16.0+43.0)*0.05;\n}\n\nvec3 Simple360HDR_skyColor(vec3 p){\n\tvec3 s1=vec3(0.2,0.5,1.0);\n\tvec3 s2=vec3(0.1,0.2,0.4)*1.5;\n    vec3 v=(Simple360HDR_noiseOct(p.xz*0.1)-0.5)*vec3(1.0);\n\tfloat d=length(p);\n    return mix(s2+v,s1+v*(12.0/max(d,20.0)),clamp(d*0.1,0.0,1.0));\n}\n\nvec3 Simple360HDR_floorColor(vec3 p){\n    vec3 v=(Simple360HDR_noiseOct(p.xz*0.1)*0.5+0.25)*vec3(0.7,0.5,0.4);\n    return v;\n}\n\nvec3 Simple360HDR_renderHDR360(vec3 rd, vec3 sun){\n    vec3 col;\n\tvec3 p;\n\tvec3 c;\n\tif (rd.y>0.0) {\n        p=rd*(5.0/rd.y);\n        c=Simple360HDR_skyColor(p);\n    } else {\n        p=rd*(-10.0/rd.y);\n        c=Simple360HDR_floorColor(p);\n\t\tc=mix(c,vec3(0.5,0.7,1.0),clamp(1.0-sqrt(-rd.y)*3.0,0.0,1.0));\n\t}\n\tvec3 skycolor=vec3(0.1,0.45,0.68);\n\tfloat d=length(p);\n\t\n\tfloat ds=clamp(dot(sun,rd),0.0,1.0);\n\tvec3 sunc=(ds>0.9997?vec3(2.0):vec3(0.0))+pow(ds,512.0)*4.0+pow(ds,128.0)*vec3(0.5)+pow(ds,4.0)*vec3(0.5);\n    if (rd.y>0.0){\n\t\tc+=vec3(0.3)*pow(1.0-abs(rd.y),3.0)*0.7;\n\t} \n    return c+sunc;\n}\n\nvec3 Simple360HDR_make360hdri(vec2 p, vec3 sun){\n    float xPI=3.14159265359;\n    vec2 thetaphi = ((p * 2.0) - vec2(1.0)) * vec2(xPI,xPI/2.0); \n    vec3 rayDirection = vec3(cos(thetaphi.y) * cos(thetaphi.x), sin(thetaphi.y), cos(thetaphi.y) * sin(thetaphi.x));\n    return Simple360HDR_renderHDR360(rayDirection,sun);\n}\n//Simple HDRI END\n\nconst float p_o15436_CamX = -3.342999935;\nconst float p_o15436_LookAtX = 1.984000000;\nconst float p_o15436_LookAtY = 1.984000000;\nconst float p_o15436_LookAtZ = -0.406000000;\nconst float p_o15436_CamD = 1.133000000;\nconst float p_o15436_CamZoom = 1.000000000;\nconst float p_o15436_SunX = -1.477000000;\nconst float p_o15436_SunY = 3.016000000;\nconst float p_o15436_SunZ = 1.352000000;\nconst float p_o15436_AmbLight = 0.250000000;\nconst float p_o15436_AmbOcclusion = 0.000000000;\nconst float p_o15436_Shadow = 0.000000000;\nconst float p_o15436_Gamma = 1.346000000;\nconst float p_o10143_BaseColor_r = 1.000000000;\nconst float p_o10143_BaseColor_g = 1.000000000;\nconst float p_o10143_BaseColor_b = 1.000000000;\nconst float p_o10143_BaseColor_a = 1.000000000;\nconst float p_o10143_Metallic = 0.000000000;\nconst float p_o10143_Specular = 0.500000000;\nconst float p_o10143_Roughness = 0.000000000;\nconst float p_o10143_Emission = 10.000000000;\nconst float p_o10143_Normal = 0.000000000;\nconst float p_o10143_Alpha = 0.000000000;\nconst float p_o10143_AmbientOcclusion = 0.000000000;\nconst float p_o10143_scale = 1.000000000;\nconst float p_o10143_TranlateX = 0.000000000;\nconst float p_o10143_TranlateY = 3.512000000;\nconst float p_o10143_TranlateZ = 0.000000000;\nconst float p_o10143_RotateX = 0.000000000;\nconst float p_o10143_RotateY = 0.250000000;\nconst float p_o10143_RotateZ = 0.000000000;\nvec3 o10143_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nfloat o10143_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10143_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10143_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o10143_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o10143_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o10143_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10143_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o10142_X = 1.000000000;\nconst float p_o10142_Y = 1.000000000;\nconst float p_o10142_Z = 0.400000000;\nconst float p_o10142_RepX = 1.000000000;\nconst float p_o10142_RepY = 1.000000000;\nconst float p_o10142_RepZ = 6.000000000;\nconst float p_o10141_l = 2.880000000;\nconst float p_o10141_r = 0.120000000;\nfloat o10143_input_sdf3d(vec3 p, float _seed_variation_) {\nvec2 o10141_0_d = abs(vec2(length((opRepLim((p),vec3(p_o10142_X,p_o10142_Y,p_o10142_Z)*2.0,vec3(p_o10142_RepX-1.0,p_o10142_RepY-1.0,p_o10142_RepZ-1.0))).yz),(opRepLim((p),vec3(p_o10142_X,p_o10142_Y,p_o10142_Z)*2.0,vec3(p_o10142_RepX-1.0,p_o10142_RepY-1.0,p_o10142_RepZ-1.0))).x)) - vec2(p_o10141_r,p_o10141_l);\nfloat o10141_0_1_sdf3d = min(max(o10141_0_d.x,o10141_0_d.y),0.0) + length(max(o10141_0_d,0.0));\nfloat o10142_0_1_sdf3d = o10141_0_1_sdf3d;\n\nreturn o10142_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o10143(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o10143_TranlateX,p_o10143_TranlateY,p_o10143_TranlateZ),vec3(p_o10143_RotateX,p_o10143_RotateY,p_o10143_RotateZ)*6.28318530718)/p_o10143_scale;\n\tfloat sdf=o10143_input_sdf3d(uv.xyz, _seed_variation_)*p_o10143_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o10143_AmbientOcclusion*o10143_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o10143_Alpha*o10143_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o10143_Normal*o10143_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o10143_Emission*o10143_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o10143_Roughness*o10143_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o10143_Specular*o10143_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o10143_Metallic*o10143_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o10143_BaseColor_r, p_o10143_BaseColor_g, p_o10143_BaseColor_b, p_o10143_BaseColor_a).rgb*o10143_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}const float p_o10168_x = 3.701340000;\nconst float p_o10168_y = 0.000000000;\nconst float p_o10168_z = 0.000000000;\nconst float p_o10156_BaseColor_r = 1.000000000;\nconst float p_o10156_BaseColor_g = 1.000000000;\nconst float p_o10156_BaseColor_b = 1.000000000;\nconst float p_o10156_BaseColor_a = 1.000000000;\nconst float p_o10156_Metallic = 0.705000000;\nconst float p_o10156_Specular = 0.373000000;\nconst float p_o10156_Roughness = 1.000000000;\nconst float p_o10156_Emission = 0.000000000;\nconst float p_o10156_Normal = 0.000000000;\nconst float p_o10156_Alpha = 0.000000000;\nconst float p_o10156_AmbientOcclusion = 0.000000000;\nconst float p_o10156_scale = 1.000000000;\nconst float p_o10156_TranlateX = 0.000000000;\nconst float p_o10156_TranlateY = 0.000000000;\nconst float p_o10156_TranlateZ = 0.000000000;\nconst float p_o10156_RotateX = 0.000000000;\nconst float p_o10156_RotateY = 0.000000000;\nconst float p_o10156_RotateZ = 0.000000000;\nconst float p_o10193_translate_x = -0.530000000;\nconst float p_o10193_translate_y = -0.010000000;\nconst float p_o10191_translate_x = 6.470000000;\nconst float p_o10191_translate_y = 3.123150000;\nconst float p_o10191_rotate = 197.957800000;\nconst float p_o10191_scale_x = 1.000000000;\nconst float p_o10191_scale_y = 1.000000000;\nconst float seed_o10189 = 0.692989000;\nconst float p_o10189_repeat = 1.000000000;\nconst float p_o10189_rows = 1.930000000;\nconst float p_o10189_columns = 1.930000000;\nconst float p_o10189_row_offset = 1.000000000;\nconst float p_o10189_mortar = 0.000000000;\nconst float p_o10189_bevel = 0.000000000;\nconst float p_o10189_round = 0.000000000;\nconst float p_o10189_corner = 0.000000000;\nconst float p_o10190_f = 0.000000000;\nconst float p_o10175_g_0_pos = 0.190909000;\nconst float p_o10175_g_0_r = 1.000000000;\nconst float p_o10175_g_0_g = 1.000000000;\nconst float p_o10175_g_0_b = 1.000000000;\nconst float p_o10175_g_0_a = 1.000000000;\nconst float p_o10175_g_1_pos = 0.390909000;\nconst float p_o10175_g_1_r = 0.507812977;\nconst float p_o10175_g_1_g = 0.451000005;\nconst float p_o10175_g_1_b = 0.353087991;\nconst float p_o10175_g_1_a = 1.000000000;\nconst float p_o10175_g_2_pos = 0.663636000;\nconst float p_o10175_g_2_r = 1.000000000;\nconst float p_o10175_g_2_g = 1.000000000;\nconst float p_o10175_g_2_b = 1.000000000;\nconst float p_o10175_g_2_a = 1.000000000;\nvec4 o10175_g_gradient_fct(float x) {\n  if (x < p_o10175_g_0_pos) {\n    return vec4(p_o10175_g_0_r,p_o10175_g_0_g,p_o10175_g_0_b,p_o10175_g_0_a);\n  } else if (x < p_o10175_g_1_pos) {\n    return mix(vec4(p_o10175_g_0_r,p_o10175_g_0_g,p_o10175_g_0_b,p_o10175_g_0_a), vec4(p_o10175_g_1_r,p_o10175_g_1_g,p_o10175_g_1_b,p_o10175_g_1_a), ((x-p_o10175_g_0_pos)/(p_o10175_g_1_pos-p_o10175_g_0_pos)));\n  } else if (x < p_o10175_g_2_pos) {\n    return mix(vec4(p_o10175_g_1_r,p_o10175_g_1_g,p_o10175_g_1_b,p_o10175_g_1_a), vec4(p_o10175_g_2_r,p_o10175_g_2_g,p_o10175_g_2_b,p_o10175_g_2_a), ((x-p_o10175_g_1_pos)/(p_o10175_g_2_pos-p_o10175_g_1_pos)));\n  }\n  return vec4(p_o10175_g_2_r,p_o10175_g_2_g,p_o10175_g_2_b,p_o10175_g_2_a);\n}\nconst float p_o10170_scale = 5.635000000;\nconst float p_o10170_scale_x = 1.000000000;\nconst float p_o10170_scale_y = 1.000000000;\nconst float p_o10170_scale_z = 1.000000000;\nconst float p_o10170_transx = 0.000000000;\nconst float p_o10170_transy = 0.000000000;\nconst float p_o10170_transz = 0.000000000;\nconst float p_o10170_persistence = 0.500000000;\nconst float p_o10170_brightness = 0.000000000;\nconst float p_o10170_contrast = 7.556000000;\nfloat o10170_fbm(vec3 coord, float persistence, float _seed_variation_) {\n\tfloat normalize_factor = 0.0;\n\tfloat value = 0.0;\n\tfloat scale = 1.0;\n\tfloat size = 1.0;\n\tfor (int i = 0; i < 6; i++) {\n\t\tvalue += XsX3zB_oct_simplex3d(coord*size) * scale;\n\t\tnormalize_factor += scale;\n\t\tsize *= 2.0;\n\t\tscale *= persistence;\n\t}\n\treturn value / normalize_factor;\n}\n\nfloat o10170_bc(float f,float contrast, float brightness, float _seed_variation_) {\n\treturn f*contrast+brightness+0.5-contrast*0.5;\n}\nvec3 o10156_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\nvec4 o10189_0_rect = bricks_rb((((p).yz+vec2(0.5))-vec2(p_o10193_translate_x, p_o10193_translate_y)), vec2(p_o10189_columns, p_o10189_rows), p_o10189_repeat, p_o10189_row_offset);\nvec4 o10189_0 = brick((((p).yz+vec2(0.5))-vec2(p_o10193_translate_x, p_o10193_translate_y)), o10189_0_rect.xy, o10189_0_rect.zw, p_o10189_mortar*1.0, p_o10189_round*1.0, max(0.001, p_o10189_bevel*1.0));\nvec3 o10189_1_2_rgb = brick_random_color(o10189_0_rect.xy, o10189_0_rect.zw, float((seed_o10189+_seed_variation_)));\nvec3 o10170_0_out = vec3(o10170_bc(o10170_fbm((vec3(p_o10190_f,(transform2((((p).yz+vec2(0.5))-vec2(p_o10193_translate_x, p_o10193_translate_y)), vec2(p_o10191_translate_x*(2.0*(dot(o10189_1_2_rgb, vec3(1.0))/3.0)-1.0), p_o10191_translate_y*(2.0*(dot(o10189_1_2_rgb, vec3(1.0))/3.0)-1.0)), p_o10191_rotate*0.01745329251*(2.0*(dot(o10189_1_2_rgb, vec3(1.0))/3.0)-1.0), vec2(p_o10191_scale_x*(2.0*1.0-1.0), p_o10191_scale_y*(2.0*1.0-1.0)))).x,(transform2((((p).yz+vec2(0.5))-vec2(p_o10193_translate_x, p_o10193_translate_y)), vec2(p_o10191_translate_x*(2.0*(dot(o10189_1_2_rgb, vec3(1.0))/3.0)-1.0), p_o10191_translate_y*(2.0*(dot(o10189_1_2_rgb, vec3(1.0))/3.0)-1.0)), p_o10191_rotate*0.01745329251*(2.0*(dot(o10189_1_2_rgb, vec3(1.0))/3.0)-1.0), vec2(p_o10191_scale_x*(2.0*1.0-1.0), p_o10191_scale_y*(2.0*1.0-1.0)))).y)).xyz*vec3(p_o10170_scale_x,p_o10170_scale_y,p_o10170_scale_z)*0.5*p_o10170_scale+vec3(p_o10170_transx,p_o10170_transy,p_o10170_transz),p_o10170_persistence, _seed_variation_)*0.5+0.5,p_o10170_contrast,p_o10170_brightness, _seed_variation_));vec3 o10170_0_1_tex3d = clamp(o10170_0_out,vec3(0),vec3(1));\nvec3 o10175_0_1_tex3d = o10175_g_gradient_fct(dot(o10170_0_1_tex3d, vec3(1.0))/3.0).rgb;\nvec3 o10190_0_1_rgb = o10175_0_1_tex3d.rgb;\nvec4 o10191_0_1_rgba = vec4(o10190_0_1_rgb, 1.0);\nvec4 o10193_0_1_rgba = o10191_0_1_rgba;\nvec3 o10192_0_1_tex3d = ((o10193_0_1_rgba).rgb);\n\nreturn o10192_0_1_tex3d;\n}\nfloat o10156_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10156_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o10194_g_0_pos = 0.000000000;\nconst float p_o10194_g_0_r = 1.000000000;\nconst float p_o10194_g_0_g = 1.000000000;\nconst float p_o10194_g_0_b = 1.000000000;\nconst float p_o10194_g_0_a = 1.000000000;\nconst float p_o10194_g_1_pos = 1.000000000;\nconst float p_o10194_g_1_r = 0.000000000;\nconst float p_o10194_g_1_g = 0.000000000;\nconst float p_o10194_g_1_b = 0.000000000;\nconst float p_o10194_g_1_a = 1.000000000;\nvec4 o10194_g_gradient_fct(float x) {\n  if (x < p_o10194_g_0_pos) {\n    return vec4(p_o10194_g_0_r,p_o10194_g_0_g,p_o10194_g_0_b,p_o10194_g_0_a);\n  } else if (x < p_o10194_g_1_pos) {\n    return mix(vec4(p_o10194_g_0_r,p_o10194_g_0_g,p_o10194_g_0_b,p_o10194_g_0_a), vec4(p_o10194_g_1_r,p_o10194_g_1_g,p_o10194_g_1_b,p_o10194_g_1_a), ((x-p_o10194_g_0_pos)/(p_o10194_g_1_pos-p_o10194_g_0_pos)));\n  }\n  return vec4(p_o10194_g_1_r,p_o10194_g_1_g,p_o10194_g_1_b,p_o10194_g_1_a);\n}\nfloat o10156_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\nvec4 o10189_0_rect = bricks_rb((((p).yz+vec2(0.5))-vec2(p_o10193_translate_x, p_o10193_translate_y)), vec2(p_o10189_columns, p_o10189_rows), p_o10189_repeat, p_o10189_row_offset);\nvec4 o10189_0 = brick((((p).yz+vec2(0.5))-vec2(p_o10193_translate_x, p_o10193_translate_y)), o10189_0_rect.xy, o10189_0_rect.zw, p_o10189_mortar*1.0, p_o10189_round*1.0, max(0.001, p_o10189_bevel*1.0));\nvec3 o10189_1_2_rgb = brick_random_color(o10189_0_rect.xy, o10189_0_rect.zw, float((seed_o10189+_seed_variation_)));\nvec3 o10170_0_out = vec3(o10170_bc(o10170_fbm((vec3(p_o10190_f,(transform2((((p).yz+vec2(0.5))-vec2(p_o10193_translate_x, p_o10193_translate_y)), vec2(p_o10191_translate_x*(2.0*(dot(o10189_1_2_rgb, vec3(1.0))/3.0)-1.0), p_o10191_translate_y*(2.0*(dot(o10189_1_2_rgb, vec3(1.0))/3.0)-1.0)), p_o10191_rotate*0.01745329251*(2.0*(dot(o10189_1_2_rgb, vec3(1.0))/3.0)-1.0), vec2(p_o10191_scale_x*(2.0*1.0-1.0), p_o10191_scale_y*(2.0*1.0-1.0)))).x,(transform2((((p).yz+vec2(0.5))-vec2(p_o10193_translate_x, p_o10193_translate_y)), vec2(p_o10191_translate_x*(2.0*(dot(o10189_1_2_rgb, vec3(1.0))/3.0)-1.0), p_o10191_translate_y*(2.0*(dot(o10189_1_2_rgb, vec3(1.0))/3.0)-1.0)), p_o10191_rotate*0.01745329251*(2.0*(dot(o10189_1_2_rgb, vec3(1.0))/3.0)-1.0), vec2(p_o10191_scale_x*(2.0*1.0-1.0), p_o10191_scale_y*(2.0*1.0-1.0)))).y)).xyz*vec3(p_o10170_scale_x,p_o10170_scale_y,p_o10170_scale_z)*0.5*p_o10170_scale+vec3(p_o10170_transx,p_o10170_transy,p_o10170_transz),p_o10170_persistence, _seed_variation_)*0.5+0.5,p_o10170_contrast,p_o10170_brightness, _seed_variation_));vec3 o10170_0_1_tex3d = clamp(o10170_0_out,vec3(0),vec3(1));\nvec3 o10175_0_1_tex3d = o10175_g_gradient_fct(dot(o10170_0_1_tex3d, vec3(1.0))/3.0).rgb;\nvec3 o10190_0_1_rgb = o10175_0_1_tex3d.rgb;\nvec4 o10191_0_1_rgba = vec4(o10190_0_1_rgb, 1.0);\nvec4 o10193_0_1_rgba = o10191_0_1_rgba;\nvec3 o10192_0_1_tex3d = ((o10193_0_1_rgba).rgb);\nvec3 o10194_0_1_tex3d = o10194_g_gradient_fct(dot(o10192_0_1_tex3d, vec3(1.0))/3.0).rgb;\n\nreturn (dot(o10194_0_1_tex3d, vec3(1.0))/3.0);\n}\nvec3 o10156_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o10156_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o10156_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10156_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o10161_X = 1.000000000;\nconst float p_o10161_Y = 0.260000000;\nconst float p_o10161_Z = 0.260000000;\nconst float p_o10161_RepX = 1.000000000;\nconst float p_o10161_RepY = 24.000000000;\nconst float p_o10161_RepZ = 24.000000000;\nconst float p_o10160_sx = 0.050000000;\nconst float p_o10160_sy = 0.235000000;\nconst float p_o10160_sz = 0.235000000;\nconst float p_o10160_r = 0.020000000;\nfloat o10156_input_sdf3d(vec3 p, float _seed_variation_) {\nvec3 o10160_0_q = abs((opRepLim((p),vec3(p_o10161_X,p_o10161_Y,p_o10161_Z)*2.0,vec3(p_o10161_RepX-1.0,p_o10161_RepY-1.0,p_o10161_RepZ-1.0)))) - vec3(p_o10160_sx, p_o10160_sy, p_o10160_sz);\nfloat o10160_0_1_sdf3d = length(max(o10160_0_q,0.0))+min(max(o10160_0_q.x,max(o10160_0_q.y,o10160_0_q.z)),0.0)-p_o10160_r;\nfloat o10161_0_1_sdf3d = o10160_0_1_sdf3d;\n\nreturn o10161_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o10156(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o10156_TranlateX,p_o10156_TranlateY,p_o10156_TranlateZ),vec3(p_o10156_RotateX,p_o10156_RotateY,p_o10156_RotateZ)*6.28318530718)/p_o10156_scale;\n\tfloat sdf=o10156_input_sdf3d(uv.xyz, _seed_variation_)*p_o10156_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o10156_AmbientOcclusion*o10156_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o10156_Alpha*o10156_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o10156_Normal*o10156_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o10156_Emission*o10156_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o10156_Roughness*o10156_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o10156_Specular*o10156_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o10156_Metallic*o10156_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o10156_BaseColor_r, p_o10156_BaseColor_g, p_o10156_BaseColor_b, p_o10156_BaseColor_a).rgb*o10156_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}const float p_o10167_x = -0.049000000;\nconst float p_o10167_y = 0.000000000;\nconst float p_o10167_z = 0.000000000;\nconst float p_o10162_BaseColor_r = 0.324218988;\nconst float p_o10162_BaseColor_g = 0.324218988;\nconst float p_o10162_BaseColor_b = 0.324218988;\nconst float p_o10162_BaseColor_a = 1.000000000;\nconst float p_o10162_Metallic = 0.000000000;\nconst float p_o10162_Specular = 0.000000000;\nconst float p_o10162_Roughness = 1.000000000;\nconst float p_o10162_Emission = 0.000000000;\nconst float p_o10162_Normal = 0.000000000;\nconst float p_o10162_Alpha = 0.000000000;\nconst float p_o10162_AmbientOcclusion = 0.000000000;\nconst float p_o10162_scale = 1.000000000;\nconst float p_o10162_TranlateX = 0.000000000;\nconst float p_o10162_TranlateY = 0.000000000;\nconst float p_o10162_TranlateZ = 0.000000000;\nconst float p_o10162_RotateX = 0.000000000;\nconst float p_o10162_RotateY = 0.000000000;\nconst float p_o10162_RotateZ = 0.000000000;\nvec3 o10162_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nfloat o10162_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10162_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10162_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o10162_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o10162_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o10162_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10162_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o10166_sx = 0.000000000;\nconst float p_o10166_sy = 6.270000000;\nconst float p_o10166_sz = 6.140000000;\nconst float p_o10166_r = 0.000000000;\nfloat o10162_input_sdf3d(vec3 p, float _seed_variation_) {\nvec3 o10166_0_q = abs((p)) - vec3(p_o10166_sx, p_o10166_sy, p_o10166_sz);\nfloat o10166_0_1_sdf3d = length(max(o10166_0_q,0.0))+min(max(o10166_0_q.x,max(o10166_0_q.y,o10166_0_q.z)),0.0)-p_o10166_r;\n\nreturn o10166_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o10162(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o10162_TranlateX,p_o10162_TranlateY,p_o10162_TranlateZ),vec3(p_o10162_RotateX,p_o10162_RotateY,p_o10162_RotateZ)*6.28318530718)/p_o10162_scale;\n\tfloat sdf=o10162_input_sdf3d(uv.xyz, _seed_variation_)*p_o10162_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o10162_AmbientOcclusion*o10162_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o10162_Alpha*o10162_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o10162_Normal*o10162_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o10162_Emission*o10162_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o10162_Roughness*o10162_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o10162_Specular*o10162_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o10162_Metallic*o10162_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o10162_BaseColor_r, p_o10162_BaseColor_g, p_o10162_BaseColor_b, p_o10162_BaseColor_a).rgb*o10162_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}const float p_o10209_ax = 0.000000000;\nconst float p_o10209_ay = 90.000000000;\nconst float p_o10209_az = 0.000000000;\nconst float p_o10210_BaseColor_r = 1.000000000;\nconst float p_o10210_BaseColor_g = 1.000000000;\nconst float p_o10210_BaseColor_b = 1.000000000;\nconst float p_o10210_BaseColor_a = 1.000000000;\nconst float p_o10210_Metallic = 0.000000000;\nconst float p_o10210_Specular = 0.000000000;\nconst float p_o10210_Roughness = 1.000000000;\nconst float p_o10210_Emission = 0.000000000;\nconst float p_o10210_Normal = 0.000000000;\nconst float p_o10210_Alpha = 0.000000000;\nconst float p_o10210_AmbientOcclusion = 0.000000000;\nconst float p_o10210_scale = 1.000000000;\nconst float p_o10210_TranlateX = 0.000000000;\nconst float p_o10210_TranlateY = 4.420000000;\nconst float p_o10210_TranlateZ = 0.000000000;\nconst float p_o10210_RotateX = 0.000000000;\nconst float p_o10210_RotateY = 0.000000000;\nconst float p_o10210_RotateZ = 0.000000000;\nvec3 o10210_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nfloat o10210_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10210_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10210_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o10210_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o10210_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o10210_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10210_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o10214_sx = 4.250000000;\nconst float p_o10214_sy = 0.250000000;\nconst float p_o10214_sz = 4.010000000;\nconst float p_o10214_r = 0.010000000;\nfloat o10210_input_sdf3d(vec3 p, float _seed_variation_) {\nvec3 o10214_0_q = abs((p)) - vec3(p_o10214_sx, p_o10214_sy, p_o10214_sz);\nfloat o10214_0_1_sdf3d = length(max(o10214_0_q,0.0))+min(max(o10214_0_q.x,max(o10214_0_q.y,o10214_0_q.z)),0.0)-p_o10214_r;\n\nreturn o10214_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o10210(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o10210_TranlateX,p_o10210_TranlateY,p_o10210_TranlateZ),vec3(p_o10210_RotateX,p_o10210_RotateY,p_o10210_RotateZ)*6.28318530718)/p_o10210_scale;\n\tfloat sdf=o10210_input_sdf3d(uv.xyz, _seed_variation_)*p_o10210_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o10210_AmbientOcclusion*o10210_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o10210_Alpha*o10210_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o10210_Normal*o10210_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o10210_Emission*o10210_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o10210_Roughness*o10210_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o10210_Specular*o10210_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o10210_Metallic*o10210_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o10210_BaseColor_r, p_o10210_BaseColor_g, p_o10210_BaseColor_b, p_o10210_BaseColor_a).rgb*o10210_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}const float p_o10267_x = 0.000000000;\nconst float p_o10267_y = -0.119530000;\nconst float p_o10267_z = 0.000000000;\nconst float p_o10268_xyz = 1.785000000;\nconst float p_o10268_x = 1.000000000;\nconst float p_o10268_y = 1.000000000;\nconst float p_o10268_z = 1.000000000;\nconst float p_o10266_ax = 0.000000000;\nconst float p_o10266_ay = 90.000000000;\nconst float p_o10266_az = 90.000000000;\nconst float p_o10259_BaseColor_r = 1.000000000;\nconst float p_o10259_BaseColor_g = 1.000000000;\nconst float p_o10259_BaseColor_b = 1.000000000;\nconst float p_o10259_BaseColor_a = 1.000000000;\nconst float p_o10259_Metallic = 0.705000000;\nconst float p_o10259_Specular = 0.917000000;\nconst float p_o10259_Roughness = 1.000000000;\nconst float p_o10259_Emission = 0.000000000;\nconst float p_o10259_Normal = 0.000000000;\nconst float p_o10259_Alpha = 0.000000000;\nconst float p_o10259_AmbientOcclusion = 0.000000000;\nconst float p_o10259_scale = 1.000000000;\nconst float p_o10259_TranlateX = 0.000000000;\nconst float p_o10259_TranlateY = 0.000000000;\nconst float p_o10259_TranlateZ = 0.000000000;\nconst float p_o10259_RotateX = 0.000000000;\nconst float p_o10259_RotateY = 0.000000000;\nconst float p_o10259_RotateZ = 0.000000000;\nconst float p_o10245_translate_x = -0.530000000;\nconst float p_o10245_translate_y = -0.010000000;\nconst float p_o10243_translate_x = 2.180000000;\nconst float p_o10243_translate_y = 4.575000000;\nconst float p_o10243_rotate = 456.220000000;\nconst float p_o10243_scale_x = 1.000000000;\nconst float p_o10243_scale_y = 1.000000000;\nconst float seed_o10242 = 0.692989000;\nconst float p_o10242_repeat = 1.000000000;\nconst float p_o10242_rows = 1.930000000;\nconst float p_o10242_columns = 1.930000000;\nconst float p_o10242_row_offset = 1.000000000;\nconst float p_o10242_mortar = 0.000000000;\nconst float p_o10242_bevel = 0.000000000;\nconst float p_o10242_round = 0.000000000;\nconst float p_o10242_corner = 0.000000000;\nconst float p_o10241_f = 0.000000000;\nconst float p_o10227_g_0_pos = 0.081110000;\nconst float p_o10227_g_0_r = 0.000000000;\nconst float p_o10227_g_0_g = 0.000000000;\nconst float p_o10227_g_0_b = 0.000000000;\nconst float p_o10227_g_0_a = 1.000000000;\nconst float p_o10227_g_1_pos = 0.390909000;\nconst float p_o10227_g_1_r = 0.796875000;\nconst float p_o10227_g_1_g = 0.604830027;\nconst float p_o10227_g_1_b = 0.333068997;\nconst float p_o10227_g_1_a = 1.000000000;\nconst float p_o10227_g_2_pos = 0.772019000;\nconst float p_o10227_g_2_r = 0.000000000;\nconst float p_o10227_g_2_g = 0.000000000;\nconst float p_o10227_g_2_b = 0.000000000;\nconst float p_o10227_g_2_a = 1.000000000;\nvec4 o10227_g_gradient_fct(float x) {\n  if (x < p_o10227_g_0_pos) {\n    return vec4(p_o10227_g_0_r,p_o10227_g_0_g,p_o10227_g_0_b,p_o10227_g_0_a);\n  } else if (x < p_o10227_g_1_pos) {\n    return mix(vec4(p_o10227_g_0_r,p_o10227_g_0_g,p_o10227_g_0_b,p_o10227_g_0_a), vec4(p_o10227_g_1_r,p_o10227_g_1_g,p_o10227_g_1_b,p_o10227_g_1_a), ((x-p_o10227_g_0_pos)/(p_o10227_g_1_pos-p_o10227_g_0_pos)));\n  } else if (x < p_o10227_g_2_pos) {\n    return mix(vec4(p_o10227_g_1_r,p_o10227_g_1_g,p_o10227_g_1_b,p_o10227_g_1_a), vec4(p_o10227_g_2_r,p_o10227_g_2_g,p_o10227_g_2_b,p_o10227_g_2_a), ((x-p_o10227_g_1_pos)/(p_o10227_g_2_pos-p_o10227_g_1_pos)));\n  }\n  return vec4(p_o10227_g_2_r,p_o10227_g_2_g,p_o10227_g_2_b,p_o10227_g_2_a);\n}\nconst float p_o10216_scale = 2.706000000;\nconst float p_o10216_scale_x = 1.000000000;\nconst float p_o10216_scale_y = 1.000000000;\nconst float p_o10216_scale_z = 1.000000000;\nconst float p_o10216_transx = 0.000000000;\nconst float p_o10216_transy = 0.000000000;\nconst float p_o10216_transz = 0.000000000;\nconst float p_o10216_persistence = 0.500000000;\nconst float p_o10216_brightness = 0.000000000;\nconst float p_o10216_contrast = 14.000000000;\nfloat o10216_fbm(vec3 coord, float persistence, float _seed_variation_) {\n\tfloat normalize_factor = 0.0;\n\tfloat value = 0.0;\n\tfloat scale = 1.0;\n\tfloat size = 1.0;\n\tfor (int i = 0; i < 12; i++) {\n\t\tvalue += XsX3zB_oct_simplex3d(coord*size) * scale;\n\t\tnormalize_factor += scale;\n\t\tsize *= 2.0;\n\t\tscale *= persistence;\n\t}\n\treturn value / normalize_factor;\n}\n\nfloat o10216_bc(float f,float contrast, float brightness, float _seed_variation_) {\n\treturn f*contrast+brightness+0.5-contrast*0.5;\n}\nvec3 o10259_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\nvec4 o10242_0_rect = bricks_rb((((p).yz+vec2(0.5))-vec2(p_o10245_translate_x, p_o10245_translate_y)), vec2(p_o10242_columns, p_o10242_rows), p_o10242_repeat, p_o10242_row_offset);\nvec4 o10242_0 = brick((((p).yz+vec2(0.5))-vec2(p_o10245_translate_x, p_o10245_translate_y)), o10242_0_rect.xy, o10242_0_rect.zw, p_o10242_mortar*1.0, p_o10242_round*1.0, max(0.001, p_o10242_bevel*1.0));\nvec3 o10242_1_2_rgb = brick_random_color(o10242_0_rect.xy, o10242_0_rect.zw, float((seed_o10242+_seed_variation_)));\nvec3 o10216_0_out = vec3(o10216_bc(o10216_fbm((vec3(p_o10241_f,(transform2((((p).yz+vec2(0.5))-vec2(p_o10245_translate_x, p_o10245_translate_y)), vec2(p_o10243_translate_x*(2.0*(dot(o10242_1_2_rgb, vec3(1.0))/3.0)-1.0), p_o10243_translate_y*(2.0*(dot(o10242_1_2_rgb, vec3(1.0))/3.0)-1.0)), p_o10243_rotate*0.01745329251*(2.0*(dot(o10242_1_2_rgb, vec3(1.0))/3.0)-1.0), vec2(p_o10243_scale_x*(2.0*1.0-1.0), p_o10243_scale_y*(2.0*1.0-1.0)))).x,(transform2((((p).yz+vec2(0.5))-vec2(p_o10245_translate_x, p_o10245_translate_y)), vec2(p_o10243_translate_x*(2.0*(dot(o10242_1_2_rgb, vec3(1.0))/3.0)-1.0), p_o10243_translate_y*(2.0*(dot(o10242_1_2_rgb, vec3(1.0))/3.0)-1.0)), p_o10243_rotate*0.01745329251*(2.0*(dot(o10242_1_2_rgb, vec3(1.0))/3.0)-1.0), vec2(p_o10243_scale_x*(2.0*1.0-1.0), p_o10243_scale_y*(2.0*1.0-1.0)))).y)).xyz*vec3(p_o10216_scale_x,p_o10216_scale_y,p_o10216_scale_z)*0.5*p_o10216_scale+vec3(p_o10216_transx,p_o10216_transy,p_o10216_transz),p_o10216_persistence, _seed_variation_)*0.5+0.5,p_o10216_contrast,p_o10216_brightness, _seed_variation_));vec3 o10216_0_1_tex3d = clamp(o10216_0_out,vec3(0),vec3(1));\nvec3 o10227_0_1_tex3d = o10227_g_gradient_fct(dot(o10216_0_1_tex3d, vec3(1.0))/3.0).rgb;\nvec3 o10241_0_1_rgb = o10227_0_1_tex3d.rgb;\nvec4 o10243_0_1_rgba = vec4(o10241_0_1_rgb, 1.0);\nvec4 o10245_0_1_rgba = o10243_0_1_rgba;\nvec3 o10244_0_1_tex3d = ((o10245_0_1_rgba).rgb);\n\nreturn o10244_0_1_tex3d;\n}\nfloat o10259_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10259_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o10246_g_0_pos = 0.000000000;\nconst float p_o10246_g_0_r = 0.066405997;\nconst float p_o10246_g_0_g = 0.066405997;\nconst float p_o10246_g_0_b = 0.066405997;\nconst float p_o10246_g_0_a = 1.000000000;\nconst float p_o10246_g_1_pos = 1.000000000;\nconst float p_o10246_g_1_r = 1.000000000;\nconst float p_o10246_g_1_g = 1.000000000;\nconst float p_o10246_g_1_b = 1.000000000;\nconst float p_o10246_g_1_a = 1.000000000;\nvec4 o10246_g_gradient_fct(float x) {\n  if (x < p_o10246_g_0_pos) {\n    return vec4(p_o10246_g_0_r,p_o10246_g_0_g,p_o10246_g_0_b,p_o10246_g_0_a);\n  } else if (x < p_o10246_g_1_pos) {\n    return mix(vec4(p_o10246_g_0_r,p_o10246_g_0_g,p_o10246_g_0_b,p_o10246_g_0_a), vec4(p_o10246_g_1_r,p_o10246_g_1_g,p_o10246_g_1_b,p_o10246_g_1_a), ((x-p_o10246_g_0_pos)/(p_o10246_g_1_pos-p_o10246_g_0_pos)));\n  }\n  return vec4(p_o10246_g_1_r,p_o10246_g_1_g,p_o10246_g_1_b,p_o10246_g_1_a);\n}\nfloat o10259_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\nvec4 o10242_0_rect = bricks_rb((((p).yz+vec2(0.5))-vec2(p_o10245_translate_x, p_o10245_translate_y)), vec2(p_o10242_columns, p_o10242_rows), p_o10242_repeat, p_o10242_row_offset);\nvec4 o10242_0 = brick((((p).yz+vec2(0.5))-vec2(p_o10245_translate_x, p_o10245_translate_y)), o10242_0_rect.xy, o10242_0_rect.zw, p_o10242_mortar*1.0, p_o10242_round*1.0, max(0.001, p_o10242_bevel*1.0));\nvec3 o10242_1_2_rgb = brick_random_color(o10242_0_rect.xy, o10242_0_rect.zw, float((seed_o10242+_seed_variation_)));\nvec3 o10216_0_out = vec3(o10216_bc(o10216_fbm((vec3(p_o10241_f,(transform2((((p).yz+vec2(0.5))-vec2(p_o10245_translate_x, p_o10245_translate_y)), vec2(p_o10243_translate_x*(2.0*(dot(o10242_1_2_rgb, vec3(1.0))/3.0)-1.0), p_o10243_translate_y*(2.0*(dot(o10242_1_2_rgb, vec3(1.0))/3.0)-1.0)), p_o10243_rotate*0.01745329251*(2.0*(dot(o10242_1_2_rgb, vec3(1.0))/3.0)-1.0), vec2(p_o10243_scale_x*(2.0*1.0-1.0), p_o10243_scale_y*(2.0*1.0-1.0)))).x,(transform2((((p).yz+vec2(0.5))-vec2(p_o10245_translate_x, p_o10245_translate_y)), vec2(p_o10243_translate_x*(2.0*(dot(o10242_1_2_rgb, vec3(1.0))/3.0)-1.0), p_o10243_translate_y*(2.0*(dot(o10242_1_2_rgb, vec3(1.0))/3.0)-1.0)), p_o10243_rotate*0.01745329251*(2.0*(dot(o10242_1_2_rgb, vec3(1.0))/3.0)-1.0), vec2(p_o10243_scale_x*(2.0*1.0-1.0), p_o10243_scale_y*(2.0*1.0-1.0)))).y)).xyz*vec3(p_o10216_scale_x,p_o10216_scale_y,p_o10216_scale_z)*0.5*p_o10216_scale+vec3(p_o10216_transx,p_o10216_transy,p_o10216_transz),p_o10216_persistence, _seed_variation_)*0.5+0.5,p_o10216_contrast,p_o10216_brightness, _seed_variation_));vec3 o10216_0_1_tex3d = clamp(o10216_0_out,vec3(0),vec3(1));\nvec3 o10227_0_1_tex3d = o10227_g_gradient_fct(dot(o10216_0_1_tex3d, vec3(1.0))/3.0).rgb;\nvec3 o10241_0_1_rgb = o10227_0_1_tex3d.rgb;\nvec4 o10243_0_1_rgba = vec4(o10241_0_1_rgb, 1.0);\nvec4 o10245_0_1_rgba = o10243_0_1_rgba;\nvec3 o10244_0_1_tex3d = ((o10245_0_1_rgba).rgb);\nvec3 o10246_0_1_tex3d = o10246_g_gradient_fct(dot(o10244_0_1_tex3d, vec3(1.0))/3.0).rgb;\n\nreturn (dot(o10246_0_1_tex3d, vec3(1.0))/3.0);\n}\nvec3 o10259_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o10259_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o10259_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10259_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o10263_X = 1.000000000;\nconst float p_o10263_Y = 0.260000000;\nconst float p_o10263_Z = 0.260000000;\nconst float p_o10263_RepX = 1.000000000;\nconst float p_o10263_RepY = 24.000000000;\nconst float p_o10263_RepZ = 24.000000000;\nconst float p_o10222_sx = 0.050000000;\nconst float p_o10222_sy = 0.235000000;\nconst float p_o10222_sz = 0.235000000;\nconst float p_o10222_r = 0.020000000;\nfloat o10259_input_sdf3d(vec3 p, float _seed_variation_) {\nvec3 o10222_0_q = abs((opRepLim((p),vec3(p_o10263_X,p_o10263_Y,p_o10263_Z)*2.0,vec3(p_o10263_RepX-1.0,p_o10263_RepY-1.0,p_o10263_RepZ-1.0)))) - vec3(p_o10222_sx, p_o10222_sy, p_o10222_sz);\nfloat o10222_0_1_sdf3d = length(max(o10222_0_q,0.0))+min(max(o10222_0_q.x,max(o10222_0_q.y,o10222_0_q.z)),0.0)-p_o10222_r;\nfloat o10263_0_1_sdf3d = o10222_0_1_sdf3d;\n\nreturn o10263_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o10259(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o10259_TranlateX,p_o10259_TranlateY,p_o10259_TranlateZ),vec3(p_o10259_RotateX,p_o10259_RotateY,p_o10259_RotateZ)*6.28318530718)/p_o10259_scale;\n\tfloat sdf=o10259_input_sdf3d(uv.xyz, _seed_variation_)*p_o10259_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o10259_AmbientOcclusion*o10259_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o10259_Alpha*o10259_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o10259_Normal*o10259_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o10259_Emission*o10259_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o10259_Roughness*o10259_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o10259_Specular*o10259_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o10259_Metallic*o10259_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o10259_BaseColor_r, p_o10259_BaseColor_g, p_o10259_BaseColor_b, p_o10259_BaseColor_a).rgb*o10259_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}const float p_o10264_x = -0.058000000;\nconst float p_o10264_y = 0.000000000;\nconst float p_o10264_z = 0.000000000;\nconst float p_o10223_BaseColor_r = 0.324218988;\nconst float p_o10223_BaseColor_g = 0.324218988;\nconst float p_o10223_BaseColor_b = 0.324218988;\nconst float p_o10223_BaseColor_a = 1.000000000;\nconst float p_o10223_Metallic = 0.000000000;\nconst float p_o10223_Specular = 0.000000000;\nconst float p_o10223_Roughness = 1.000000000;\nconst float p_o10223_Emission = 0.000000000;\nconst float p_o10223_Normal = 0.000000000;\nconst float p_o10223_Alpha = 0.000000000;\nconst float p_o10223_AmbientOcclusion = 0.000000000;\nconst float p_o10223_scale = 1.000000000;\nconst float p_o10223_TranlateX = 0.000000000;\nconst float p_o10223_TranlateY = 0.000000000;\nconst float p_o10223_TranlateZ = 0.000000000;\nconst float p_o10223_RotateX = 0.000000000;\nconst float p_o10223_RotateY = 0.000000000;\nconst float p_o10223_RotateZ = 0.000000000;\nvec3 o10223_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nfloat o10223_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10223_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10223_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o10223_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o10223_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o10223_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10223_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o10221_sx = 0.000000000;\nconst float p_o10221_sy = 6.270000000;\nconst float p_o10221_sz = 6.140000000;\nconst float p_o10221_r = 0.000000000;\nfloat o10223_input_sdf3d(vec3 p, float _seed_variation_) {\nvec3 o10221_0_q = abs((p)) - vec3(p_o10221_sx, p_o10221_sy, p_o10221_sz);\nfloat o10221_0_1_sdf3d = length(max(o10221_0_q,0.0))+min(max(o10221_0_q.x,max(o10221_0_q.y,o10221_0_q.z)),0.0)-p_o10221_r;\n\nreturn o10221_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o10223(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o10223_TranlateX,p_o10223_TranlateY,p_o10223_TranlateZ),vec3(p_o10223_RotateX,p_o10223_RotateY,p_o10223_RotateZ)*6.28318530718)/p_o10223_scale;\n\tfloat sdf=o10223_input_sdf3d(uv.xyz, _seed_variation_)*p_o10223_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o10223_AmbientOcclusion*o10223_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o10223_Alpha*o10223_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o10223_Normal*o10223_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o10223_Emission*o10223_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o10223_Roughness*o10223_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o10223_Specular*o10223_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o10223_Metallic*o10223_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o10223_BaseColor_r, p_o10223_BaseColor_g, p_o10223_BaseColor_b, p_o10223_BaseColor_a).rgb*o10223_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}const float p_o10215_x = 0.000000000;\nconst float p_o10215_y = 1.071000000;\nconst float p_o10215_z = 0.000000000;\nconst float p_o10155_correction = 0.000000000;\nconst float p_o10148_k = 0.062000000;\nconst float p_o10149_BaseColor_r = 0.000000000;\nconst float p_o10149_BaseColor_g = 0.000000000;\nconst float p_o10149_BaseColor_b = 0.000000000;\nconst float p_o10149_BaseColor_a = 1.000000000;\nconst float p_o10149_Metallic = 0.250000000;\nconst float p_o10149_Specular = 1.000000000;\nconst float p_o10149_Roughness = 0.000000000;\nconst float p_o10149_Emission = 0.000000000;\nconst float p_o10149_Normal = 0.000000000;\nconst float p_o10149_Alpha = 0.000000000;\nconst float p_o10149_AmbientOcclusion = 0.000000000;\nconst float p_o10149_scale = 0.306000000;\nconst float p_o10149_TranlateX = 0.000000000;\nconst float p_o10149_TranlateY = 0.000000000;\nconst float p_o10149_TranlateZ = 0.000000000;\nconst float p_o10149_RotateX = 0.000000000;\nconst float p_o10149_RotateY = 0.000000000;\nconst float p_o10149_RotateZ = 0.000000000;\nvec3 o10149_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nfloat o10149_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10149_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10149_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o10149_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o10149_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o10149_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10149_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o10153_X = 0.500000000;\nconst float p_o10153_Y = 0.500000000;\nconst float p_o10153_Z = 0.500000000;\nconst float p_o10153_RepX = 14.000000000;\nconst float p_o10153_RepY = 14.000000000;\nconst float p_o10153_RepZ = 17.000000000;\nconst float p_o10154_r = 0.320000000;\nfloat o10149_input_sdf3d(vec3 p, float _seed_variation_) {\nfloat o10154_0_1_sdf3d = length((opRepLim((p),vec3(p_o10153_X,p_o10153_Y,p_o10153_Z)*2.0,vec3(p_o10153_RepX-1.0,p_o10153_RepY-1.0,p_o10153_RepZ-1.0))))-p_o10154_r;\nfloat o10153_0_1_sdf3d = o10154_0_1_sdf3d;\n\nreturn o10153_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o10149(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o10149_TranlateX,p_o10149_TranlateY,p_o10149_TranlateZ),vec3(p_o10149_RotateX,p_o10149_RotateY,p_o10149_RotateZ)*6.28318530718)/p_o10149_scale;\n\tfloat sdf=o10149_input_sdf3d(uv.xyz, _seed_variation_)*p_o10149_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o10149_AmbientOcclusion*o10149_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o10149_Alpha*o10149_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o10149_Normal*o10149_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o10149_Emission*o10149_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o10149_Roughness*o10149_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o10149_Specular*o10149_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o10149_Metallic*o10149_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o10149_BaseColor_r, p_o10149_BaseColor_g, p_o10149_BaseColor_b, p_o10149_BaseColor_a).rgb*o10149_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}const float p_o10137_BaseColor_r = 0.159263998;\nconst float p_o10137_BaseColor_g = 1.000000000;\nconst float p_o10137_BaseColor_b = 0.000000000;\nconst float p_o10137_BaseColor_a = 1.000000000;\nconst float p_o10137_Metallic = 0.547000000;\nconst float p_o10137_Specular = 0.500000000;\nconst float p_o10137_Roughness = 0.059000000;\nconst float p_o10137_Emission = 0.000000000;\nconst float p_o10137_Normal = 0.000000000;\nconst float p_o10137_Alpha = 0.000000000;\nconst float p_o10137_AmbientOcclusion = 0.000000000;\nconst float p_o10137_scale = 1.000000000;\nconst float p_o10137_TranlateX = 0.000000000;\nconst float p_o10137_TranlateY = 0.000000000;\nconst float p_o10137_TranlateZ = 0.000000000;\nconst float p_o10137_RotateX = 0.000000000;\nconst float p_o10137_RotateY = 0.000000000;\nconst float p_o10137_RotateZ = 0.000000000;\nvec3 o10137_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nfloat o10137_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10137_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10137_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o10137_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o10137_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o10137_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o10137_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o10147_sx = 0.250000000;\nconst float p_o10147_sy = 0.250000000;\nconst float p_o10147_sz = 1.940000000;\nconst float p_o10147_r = 0.280000000;\nfloat o10137_input_sdf3d(vec3 p, float _seed_variation_) {\nvec3 o10147_0_q = abs((p)) - vec3(p_o10147_sx, p_o10147_sy, p_o10147_sz);\nfloat o10147_0_1_sdf3d = length(max(o10147_0_q,0.0))+min(max(o10147_0_q.x,max(o10147_0_q.y,o10147_0_q.z)),0.0)-p_o10147_r;\n\nreturn o10147_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o10137(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o10137_TranlateX,p_o10137_TranlateY,p_o10137_TranlateZ),vec3(p_o10137_RotateX,p_o10137_RotateY,p_o10137_RotateZ)*6.28318530718)/p_o10137_scale;\n\tfloat sdf=o10137_input_sdf3d(uv.xyz, _seed_variation_)*p_o10137_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o10137_AmbientOcclusion*o10137_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o10137_Alpha*o10137_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o10137_Normal*o10137_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o10137_Emission*o10137_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o10137_Roughness*o10137_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o10137_Specular*o10137_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o10137_Metallic*o10137_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o10137_BaseColor_r, p_o10137_BaseColor_g, p_o10137_BaseColor_b, p_o10137_BaseColor_a).rgb*o10137_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}vec4 o15436_input_mfsdf(vec4 p, float _seed_variation_) {\nvec4 o10143_0_1_v4v4 = PBRObjectMaker_o10143((p), _seed_variation_);\nvec4 o10156_0_1_v4v4 = PBRObjectMaker_o10156((vec4((p).xyz-vec3(p_o10168_x, p_o10168_y, p_o10168_z),(p).w)), _seed_variation_);\nvec4 o10162_0_1_v4v4 = PBRObjectMaker_o10162((vec4((vec4((p).xyz-vec3(p_o10168_x, p_o10168_y, p_o10168_z),(p).w)).xyz-vec3(p_o10167_x, p_o10167_y, p_o10167_z),(vec4((p).xyz-vec3(p_o10168_x, p_o10168_y, p_o10168_z),(p).w)).w)), _seed_variation_);\nvec4 o10167_0_1_v4v4 = o10162_0_1_v4v4;\nvec4 o10169_0_1_v4v4 = sdf3dc_union(o10156_0_1_v4v4, o10167_0_1_v4v4);\nvec4 o10168_0_1_v4v4 = o10169_0_1_v4v4;\nvec4 o10156_0_3_v4v4 = PBRObjectMaker_o10156((vec4((vec4(vec3(abs((p).x),(p).yz),(p).w)).xyz-vec3(p_o10168_x, p_o10168_y, p_o10168_z),(vec4(vec3(abs((p).x),(p).yz),(p).w)).w)), _seed_variation_);\nvec4 o10162_0_3_v4v4 = PBRObjectMaker_o10162((vec4((vec4((vec4(vec3(abs((p).x),(p).yz),(p).w)).xyz-vec3(p_o10168_x, p_o10168_y, p_o10168_z),(vec4(vec3(abs((p).x),(p).yz),(p).w)).w)).xyz-vec3(p_o10167_x, p_o10167_y, p_o10167_z),(vec4((vec4(vec3(abs((p).x),(p).yz),(p).w)).xyz-vec3(p_o10168_x, p_o10168_y, p_o10168_z),(vec4(vec3(abs((p).x),(p).yz),(p).w)).w)).w)), _seed_variation_);\nvec4 o10167_0_3_v4v4 = o10162_0_3_v4v4;\nvec4 o10169_0_3_v4v4 = sdf3dc_union(o10156_0_3_v4v4, o10167_0_3_v4v4);\nvec4 o10168_0_3_v4v4 = o10169_0_3_v4v4;\nvec4 o10208_0_1_v4v4 = o10168_0_3_v4v4;\nvec4 o10156_0_5_v4v4 = PBRObjectMaker_o10156((vec4((vec4(vec3(abs((vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).x),(vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).yz),(vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).w)).xyz-vec3(p_o10168_x, p_o10168_y, p_o10168_z),(vec4(vec3(abs((vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).x),(vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).yz),(vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).w)).w)), _seed_variation_);\nvec4 o10162_0_5_v4v4 = PBRObjectMaker_o10162((vec4((vec4((vec4(vec3(abs((vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).x),(vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).yz),(vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).w)).xyz-vec3(p_o10168_x, p_o10168_y, p_o10168_z),(vec4(vec3(abs((vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).x),(vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).yz),(vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).w)).w)).xyz-vec3(p_o10167_x, p_o10167_y, p_o10167_z),(vec4((vec4(vec3(abs((vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).x),(vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).yz),(vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).w)).xyz-vec3(p_o10168_x, p_o10168_y, p_o10168_z),(vec4(vec3(abs((vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).x),(vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).yz),(vec4(v4v4_rotate((p).xyz, -vec3(p_o10209_ax, p_o10209_ay, p_o10209_az)*0.01745329251), (p).w)).w)).w)).w)), _seed_variation_);\nvec4 o10167_0_5_v4v4 = o10162_0_5_v4v4;\nvec4 o10169_0_5_v4v4 = sdf3dc_union(o10156_0_5_v4v4, o10167_0_5_v4v4);\nvec4 o10168_0_5_v4v4 = o10169_0_5_v4v4;\nvec4 o10208_0_3_v4v4 = o10168_0_5_v4v4;\nvec4 o10209_0_1_v4v4 = o10208_0_3_v4v4;\nvec4 o10210_0_1_v4v4 = PBRObjectMaker_o10210((p), _seed_variation_);\nvec4 o10259_0_1_v4v4 = PBRObjectMaker_o10259((vec4(v4v4_rotate((vec4((vec4((p).xyz-vec3(p_o10267_x, p_o10267_y, p_o10267_z),(p).w)).xyz/vec3(p_o10268_x, p_o10268_y, p_o10268_z)/p_o10268_xyz,(vec4((p).xyz-vec3(p_o10267_x, p_o10267_y, p_o10267_z),(p).w)).w)).xyz, -vec3(p_o10266_ax, p_o10266_ay, p_o10266_az)*0.01745329251), (vec4((vec4((p).xyz-vec3(p_o10267_x, p_o10267_y, p_o10267_z),(p).w)).xyz/vec3(p_o10268_x, p_o10268_y, p_o10268_z)/p_o10268_xyz,(vec4((p).xyz-vec3(p_o10267_x, p_o10267_y, p_o10267_z),(p).w)).w)).w)), _seed_variation_);\nvec4 o10223_0_1_v4v4 = PBRObjectMaker_o10223((vec4((vec4(v4v4_rotate((vec4((vec4((p).xyz-vec3(p_o10267_x, p_o10267_y, p_o10267_z),(p).w)).xyz/vec3(p_o10268_x, p_o10268_y, p_o10268_z)/p_o10268_xyz,(vec4((p).xyz-vec3(p_o10267_x, p_o10267_y, p_o10267_z),(p).w)).w)).xyz, -vec3(p_o10266_ax, p_o10266_ay, p_o10266_az)*0.01745329251), (vec4((vec4((p).xyz-vec3(p_o10267_x, p_o10267_y, p_o10267_z),(p).w)).xyz/vec3(p_o10268_x, p_o10268_y, p_o10268_z)/p_o10268_xyz,(vec4((p).xyz-vec3(p_o10267_x, p_o10267_y, p_o10267_z),(p).w)).w)).w)).xyz-vec3(p_o10264_x, p_o10264_y, p_o10264_z),(vec4(v4v4_rotate((vec4((vec4((p).xyz-vec3(p_o10267_x, p_o10267_y, p_o10267_z),(p).w)).xyz/vec3(p_o10268_x, p_o10268_y, p_o10268_z)/p_o10268_xyz,(vec4((p).xyz-vec3(p_o10267_x, p_o10267_y, p_o10267_z),(p).w)).w)).xyz, -vec3(p_o10266_ax, p_o10266_ay, p_o10266_az)*0.01745329251), (vec4((vec4((p).xyz-vec3(p_o10267_x, p_o10267_y, p_o10267_z),(p).w)).xyz/vec3(p_o10268_x, p_o10268_y, p_o10268_z)/p_o10268_xyz,(vec4((p).xyz-vec3(p_o10267_x, p_o10267_y, p_o10267_z),(p).w)).w)).w)).w)), _seed_variation_);\nvec4 o10264_0_1_v4v4 = o10223_0_1_v4v4;\nvec4 o10265_0_1_v4v4 = sdf3dc_union(o10259_0_1_v4v4, o10264_0_1_v4v4);\nvec4 o10266_0_1_v4v4 = o10265_0_1_v4v4;\nvec4 o_o10268_0=o10266_0_1_v4v4;vec4 o10268_0_1_v4v4 = vec4(o_o10268_0.xyz,o_o10268_0.w*min(min(p_o10268_x, p_o10268_y), p_o10268_z)*p_o10268_xyz);\nvec4 o10267_0_1_v4v4 = o10268_0_1_v4v4;\nvec4 o10207_0_1_v4v4 = MFSDF_Union(o10168_0_1_v4v4,o10208_0_1_v4v4,o10209_0_1_v4v4,o10210_0_1_v4v4,o10267_0_1_v4v4,o10267_0_1_v4v4,vec4(0.0,0.0,0.0,9999999.0),vec4(0.0,0.0,0.0,9999999.0));\nvec4 o10149_0_1_v4v4 = PBRObjectMaker_o10149((vec4(twistZ((vec4((p).xyz-vec3(p_o10215_x, p_o10215_y, p_o10215_z),(p).w)).xyz,(sin(iTime)*90.0)),(vec4((p).xyz-vec3(p_o10215_x, p_o10215_y, p_o10215_z),(p).w)).w)), _seed_variation_);\nvec4 o10137_0_1_v4v4 = PBRObjectMaker_o10137((vec4(twistZ((vec4((p).xyz-vec3(p_o10215_x, p_o10215_y, p_o10215_z),(p).w)).xyz,(sin(iTime)*90.0)),(vec4((p).xyz-vec3(p_o10215_x, p_o10215_y, p_o10215_z),(p).w)).w)), _seed_variation_);\nvec4 o10148_0_1_v4v4 = mfsdf3d_smooth_subtraction(o10149_0_1_v4v4, o10137_0_1_v4v4,p_o10148_k);\nvec4 o10155_0_o=o10148_0_1_v4v4;vec4 o10155_0_1_v4v4 = vec4(o10155_0_o.xyz,o10155_0_o.w/(1.0+p_o10155_correction));\nvec4 o10215_0_1_v4v4 = o10155_0_1_v4v4;\nvec4 o10136_0_1_v4v4 = MFSDF_Union(o10143_0_1_v4v4,o10207_0_1_v4v4,o10215_0_1_v4v4,vec4(0.0,0.0,0.0,9999999.0),vec4(0.0,0.0,0.0,9999999.0),vec4(0.0,0.0,0.0,9999999.0),vec4(0.0,0.0,0.0,9999999.0),vec4(0.0,0.0,0.0,9999999.0));\n\nreturn o10136_0_1_v4v4;\n}\nvec3 o15436_input_hdri(vec2 uv, float _seed_variation_) {\n\nreturn Simple360HDR_make360hdri(vec2((uv).x,-(uv).y+1.0),normalize(vec3(-p_o15436_SunX,p_o15436_SunY,-p_o15436_SunZ)));\n}\n\n//tetrahedron normal by PauloFalcao\n//https://www.shadertoy.com/view/XstGDS\nvec3 normal_o15436(vec3 p, float _seed_variation_) {  \n  const vec3 e=vec3(0.01,-0.001,0.0);\n  float v1=o15436_input_mfsdf(vec4(p+e.xyy,0.0), _seed_variation_).w;\n  float v2=o15436_input_mfsdf(vec4(p+e.yyx,0.0), _seed_variation_).w;\n  float v3=o15436_input_mfsdf(vec4(p+e.yxy,0.0), _seed_variation_).w;\n  float v4=o15436_input_mfsdf(vec4(p+e.xxx,0.0), _seed_variation_).w;\n  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n}\n\nvoid march_o15436(inout float d,inout vec3 p,float dS, vec3 ro, vec3 rd, float _seed_variation_) {\n    for (int i=0; i < 64; i++) {\n    \tp = ro + rd*d;\n        dS = o15436_input_mfsdf(vec4(p,0.0), _seed_variation_).w;\n        d += dS;\n        if (d > 14.0 || abs(dS) < 0.001) break;\n    }\n}\n\nvec3 raymarch_o15436(vec2 uv, float _seed_variation_) {\n    uv-=0.5;\n\tvec3 cam=vec3(p_o15436_CamX,(sin(iTime*0.5)*0.8+1.3),(sin(iTime*0.9)*2.0))*p_o15436_CamZoom;\n\tvec3 lookat=vec3(p_o15436_LookAtX,p_o15436_LookAtY,p_o15436_LookAtZ);\n\tvec3 ray=normalize(lookat-cam);\n\tvec3 cX=normalize(cross(vec3(0.0,1.0,0.0),ray));\n\tvec3 cY=normalize(cross(cX,ray));\n\tvec3 rd = normalize(ray*p_o15436_CamD+cX*uv.x+cY*uv.y);\n\tvec3 ro = cam;\n\t\n\tfloat d=0.;\n\tvec3 p=vec3(0);\n\tfloat dS=0.0;\n\tmarch_o15436(d,p,dS,ro,rd, _seed_variation_);\n\t\n    vec3 color=vec3(0.0);\n\tvec3 objColor=o15436_input_mfsdf(vec4(p,1.0), _seed_variation_).xyz;   // 1 - BaseColor (r,g,b,sdf) linear (0-1) \n\tfloat objSpecular=o15436_input_mfsdf(vec4(p,4.0), _seed_variation_).x*0.2;  // 4 - Specular  (v,0,0,sdf)\n\tfloat objRoughness=o15436_input_mfsdf(vec4(p,5.0), _seed_variation_).x; // 5 - Roughness (v,0,0,sdf)\n\tvec3 light=normalize(vec3(p_o15436_SunX,p_o15436_SunY,p_o15436_SunZ));\n\tif (d<14.0) {\n\t    vec3 n=normal_o15436(p, _seed_variation_);\n\t\tfloat l=clamp(dot(-light,-n),0.0,1.0);\n\t\tvec3 ref=normalize(reflect(rd,-n));\n\t\tfloat r=clamp(dot(ref,light),0.0,1.0);\n\t\tcolor=max(vec3(p_o15436_AmbLight),max(l,p_o15436_AmbLight))*objColor+4.0*pow(r,pow(256.0,(1.0-objRoughness)))*objSpecular;\n\t\t//reflection\n\t\td=0.01;\n\t\tmarch_o15436(d,p,dS,p,ref, _seed_variation_);\n\t\tvec3 objColorRef=vec3(0);\n\t\tif (d<14.0) {\n\t\t\tobjColorRef=o15436_input_mfsdf(vec4(p,1.0), _seed_variation_).xyz;\n\t\t\tn=normal_o15436(p, _seed_variation_);\n\t\t\tl=clamp(dot(-light,-n),0.0,1.0);\n\t\t\tobjColorRef=max(l,p_o15436_AmbLight)*objColorRef;\n\t\t} else {\n\t\t\tobjColorRef=o15436_input_hdri(equirectangularMap(ref.xzy), _seed_variation_).xyz;\n\t\t}\n\t\tcolor=mix(color,objColorRef,objSpecular);\n\t} else {\n\t\tcolor=o15436_input_hdri(equirectangularMap(rd.xzy), _seed_variation_).xyz;\n\t}\n\treturn pow(color,vec3(1.0/p_o15436_Gamma));\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\nfloat minSize = min(iResolution.x, iResolution.y);\nfloat _seed_variation_ = SEED_VARIATION;\nvec2 UV = vec2(0.0, 1.0) + vec2(1.0, -1.0) * (fragCoord-0.5*(iResolution.xy-vec2(minSize)))/minSize;\nvec3 o15436_0_1_rgb = raymarch_o15436((UV), _seed_variation_);\nfragColor = vec4(o15436_0_1_rgb, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ltGDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[667, 667, 687, 687, 766], [768, 768, 788, 788, 921], [923, 923, 943, 943, 1132], [1134, 1134, 1156, 1156, 1453], [1455, 1455, 1477, 1477, 1637], [1640, 1640, 1699, 1699, 1753], [1836, 1836, 1872, 1872, 1942], [1942, 1942, 1989, 1989, 2293], [2294, 2294, 2377, 2377, 2837], [2839, 2839, 2898, 2898, 2977], [2979, 2979, 3037, 3037, 3210], [3212, 3212, 3305, 3305, 3631], [3633, 3633, 3698, 3698, 3921], [3923, 3923, 3989, 3989, 4273], [4275, 4275, 4340, 4340, 4699], [4701, 4701, 4766, 4766, 5196], [5198, 5198, 5263, 5263, 5996], [7302, 7373, 7406, 7406, 7579], [7705, 7725, 7761, 8003, 8995], [8995, 8995, 9027, 9027, 9070], [9072, 9072, 9140, 9140, 9325], [9325, 9325, 9360, 9360, 9403], [9404, 9404, 9437, 9437, 9490], [9491, 9491, 9526, 9526, 9569], [9569, 9569, 9603, 9603, 9907], [9908, 9908, 9998, 9998, 10319], [10321, 10321, 10375, 10375, 10443], [10445, 10445, 10497, 10497, 10859], [10861, 10861, 10921, 10921, 10991], [10993, 10993, 11051, 11051, 11440], [11442, 11442, 11503, 11503, 11571], [11573, 11573, 11632, 11632, 12026], [12026, 12026, 12059, 12059, 12174], [12176, 12176, 12205, 12205, 12247], [12249, 12249, 12278, 12278, 12320], [12322, 12322, 12351, 12351, 12393], [12426, 12426, 12461, 12461, 12550], [12574, 12648, 12683, 12683, 12800], [12802, 12802, 12835, 12835, 13131], [13133, 13133, 13169, 13169, 13376], [13378, 13378, 13413, 13413, 13622], [13624, 13624, 13661, 13661, 13750], [13752, 13752, 13802, 13802, 14349], [14351, 14351, 14399, 14399, 14669], [16076, 16076, 16143, 16143, 16164], [16165, 16165, 16232, 16232, 16247], [16248, 16248, 16315, 16315, 16330], [16331, 16331, 16399, 16399, 16414], [16415, 16415, 16481, 16481, 16510], [16511, 16511, 16575, 16575, 16604], [16605, 16605, 16669, 16669, 16684], [16685, 16685, 16760, 16760, 16775], [17089, 17089, 17147, 17147, 17625], [18091, 18091, 18152, 18152, 19754], [22076, 22076, 22113, 22113, 22797], [23241, 23241, 23314, 23314, 23595], [23597, 23597, 23680, 23680, 23730], [23731, 23731, 23798, 23798, 25720], [25721, 25721, 25788, 25788, 25803], [25804, 25804, 25871, 25871, 25886], [26311, 26311, 26348, 26348, 26785], [26786, 26786, 26854, 26854, 28887], [28888, 28888, 28954, 28954, 28983], [28984, 28984, 29048, 29048, 29077], [29078, 29078, 29142, 29142, 29157], [29158, 29158, 29233, 29233, 29248], [29643, 29643, 29701, 29701, 30084], [30550, 30550, 30611, 30611, 32213], [33151, 33151, 33218, 33218, 33239], [33240, 33240, 33307, 33307, 33322], [33323, 33323, 33390, 33390, 33405], [33406, 33406, 33474, 33474, 33489], [33490, 33490, 33556, 33556, 33585], [33586, 33586, 33650, 33650, 33679], [33680, 33680, 33744, 33744, 33759], [33760, 33760, 33835, 33835, 33850], [34006, 34006, 34064, 34064, 34289], [34755, 34755, 34816, 34816, 36418], [37359, 37359, 37426, 37426, 37447], [37448, 37448, 37515, 37515, 37530], [37531, 37531, 37598, 37598, 37613], [37614, 37614, 37682, 37682, 37697], [37698, 37698, 37764, 37764, 37793], [37794, 37794, 37858, 37858, 37887], [37888, 37888, 37952, 37952, 37967], [37968, 37968, 38043, 38043, 38058], [38214, 38214, 38272, 38272, 38497], [38963, 38963, 39024, 39024, 40626], [43222, 43222, 43259, 43259, 43943], [44388, 44388, 44461, 44461, 44743], [44745, 44745, 44828, 44828, 44878], [44879, 44879, 44946, 44946, 46868], [46869, 46869, 46936, 46936, 46951], [46952, 46952, 47019, 47019, 47034], [47459, 47459, 47496, 47496, 47933], [47934, 47934, 48002, 48002, 50035], [50036, 50036, 50102, 50102, 50131], [50132, 50132, 50196, 50196, 50225], [50226, 50226, 50290, 50290, 50305], [50306, 50306, 50381, 50381, 50396], [50791, 50791, 50849, 50849, 51232], [51698, 51698, 51759, 51759, 53361], [54299, 54299, 54366, 54366, 54387], [54388, 54388, 54455, 54455, 54470], [54471, 54471, 54538, 54538, 54553], [54554, 54554, 54622, 54622, 54637], [54638, 54638, 54704, 54704, 54733], [54734, 54734, 54798, 54798, 54827], [54828, 54828, 54892, 54892, 54907], [54908, 54908, 54983, 54983, 54998], [55154, 55154, 55212, 55212, 55437], [55903, 55903, 55964, 55964, 57566], [58588, 58588, 58655, 58655, 58676], [58677, 58677, 58744, 58744, 58759], [58760, 58760, 58827, 58827, 58842], [58843, 58843, 58911, 58911, 58926], [58927, 58927, 58993, 58993, 59022], [59023, 59023, 59087, 59087, 59116], [59117, 59117, 59181, 59181, 59196], [59197, 59197, 59272, 59272, 59287], [59566, 59566, 59624, 59624, 59859], [60325, 60325, 60386, 60386, 61988], [62811, 62811, 62878, 62878, 62899], [62900, 62900, 62967, 62967, 62982], [62983, 62983, 63050, 63050, 63065], [63066, 63066, 63134, 63134, 63149], [63150, 63150, 63216, 63216, 63245], [63246, 63246, 63310, 63310, 63339], [63340, 63340, 63404, 63404, 63419], [63420, 63420, 63495, 63495, 63510], [63666, 63666, 63724, 63724, 63949], [64415, 64415, 64476, 64476, 66078], [66078, 66078, 66135, 66135, 73139], [73140, 73140, 73197, 73197, 73320], [73322, 73398, 73450, 73450, 73835], [73837, 73837, 73935, 73935, 74127], [74129, 74129, 74184, 74184, 75976], [75977, 75977, 76032, 76032, 76329]], "test": "untested"}
{"id": "stt3Wl", "name": "entropy", "author": "FabriceNeyret2", "description": "reference: see below", "tags": ["2d", "short", "reproduction"], "likes": 26, "viewed": 604, "published": 3, "date": "1636978928", "time_retrieved": "2024-07-30T18:48:03.632606", "image_code": "#define R iResolution\n// ---------------------- utils from https://www.shadertoy.com/view/llySRh\n#define H(p) ( 2.* fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) -1. )\n\nvec4 char(vec2 p, int c) {\n   // vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n   vec2 dFdx = vec2(3./R.y/16.,0), dFdy = dFdx.yx ;\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                        dFdx, dFdy );\n}\n#define spc  U.x-=.5;\n#define C(c) spc O += char(U,64+32+c).x;\n// ----------------------\n\nvoid mainImage( out vec4 O, vec2 u ) {\n    vec2 U = u / R.y, \n         p = floor(u/2.);\n         \n    float e = max(0.,.12*(U.x-.2));       // jitter\n    if ( H(p+.5 ).x < e ) U += e * H(p);\n    \n    O -= O;\n    U *= 2.5; U -= vec2(-.3,.8);          // draw text\n    C(5)C(14)C(20)C(18)C(15)C(16)C(25)    // \"entropy\"\n    O = 1.-O;\n}\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stt3Wl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[185, 185, 211, 262, 496]], "test": "untested"}
{"id": "ftt3Ds", "name": "Truck Driving 2", "author": "dr2", "description": "Try to stay on the road (updated version, including tyre tracks) :)", "tags": ["simulation", "interactive", "car", "drive"], "likes": 17, "viewed": 470, "published": 3, "date": "1636972048", "time_retrieved": "2024-07-30T18:48:04.651881", "image_code": "// \"Truck Driving 2\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Knob controls speed and steering; on-track driving distance shown; view direction\n  different at high elevation; tyre tracks fade with time; mouseable.\n*/\n\n/*\n  No. 6 in \"Driving\" series\n    \"Truck Driving\"            (wsGBDh)\n    \"Drive The Rover\"          (3lGfzd)\n    \"Segway Driving\"           (WtKBWc)\n    \"Lunar Buggy\"              (NsX3RH)\n    \"Martian Tango\"            (fljGW1)\n*/\n\n#define AA  0   // (= 0/1) optional antialiasing (can be slow)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat ShowIntPZ (vec2 q, vec2 cBox, float mxChar, float val);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (int idVar);\n\nconst int npTrail = 256;  // same for image and buffer\nconst int npFst = 6;\n\nvec3 sunDir, qHit, carPos, wlBase;\nvec2 wlRot;\nfloat dstFar, tCur, wlRad, carRot, strRot, onPath, hgSize, trWidf;\nint idObj;\nbool isSh;\nconst int idBod = 1, idAx = 2, idBas = 3, idWhl = 4, idStr = 5, idSeat = 6, idWLit = 7,\n   idFLit = 8, idBLit = 9;\nconst float pi = 3.1415927;\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvec3 BPanel (vec3 p)\n{\n  vec4 ra;\n  vec3 ds;\n  ra = vec4 (-0.08, -0.012, 0.37, -0.42) * pi;\n  ds.x = max (dot (p.zy, sin (ra.z + vec2 (0.5 * pi, 0.))) - 1.03,\n     - dot (p.zy, sin (ra.w + vec2 (0.5 * pi, 0.))) - 0.75);\n  ds.y = dot (vec2 (abs (p.x), - abs (p.y + 0.18)), sin (ra.x + vec2 (0.5 * pi, 0.))) - 1.3;\n  ds.z = max (dot (vec2 (abs (p.z), p.y), sin (ra.y + vec2 (0.5 * pi, 0.))) - 3., ds.x);\n  return ds;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, ds;\n  float dMin, d;\n  p -= carPos;\n  p.xz = Rot2D (p.xz, carRot);\n  p.z -= wlBase.z;\n  dMin = dstFar;\n  q = p;\n  if (! isSh) d = PrBoxDf (q, vec3 (1.8, 1.5, 3.));\n  if (isSh || d < 0.1) {\n    ds = BPanel (q);\n    d = max (max (abs (q.y - 0.1) - 1., ds.y), ds.z);\n    d = max (d, - PrBoxDf (p - vec3 (0., 0.2, -2.), vec3 (1.08, 0.4, 0.9)));\n    d = max (d, - PrCylDf (((vec3 (abs (q.xz) - wlBase.xz, q.y + wlRad + 0.35)).xzy).yzx,\n       wlRad + 0.06, 0.5));\n    d = max (d, - max (max (max (abs (q.y - 0.48) - 0.35, abs (q.z - 0.5) - 1.5), ds.x + 0.05),\n       0.08 - abs (q.z - 0.5)));\n    d = max (d, - max (ds.y + 0.08, min (max (abs (q.y - 0.68) - 0.2, q.z - 0.5),\n       max (abs (q.y - 0.55) - 0.31, 0.5 - q.z))));\n    d = max (d, - max (max (max (max (abs (q.y - 0.2) - 0.9, ds.y), ds.z) + 0.06,\n       abs (q.z - 0.3) - 1.3), - max (max (length (vec2 (q.y + wlRad + 0.35, q.z - wlBase.z)) -\n       (wlRad + 0.06 + 0.02), q.z - wlBase.z), - q.y - wlRad - 0.35)));\n    DMINQ (idBod);\n    q = p;\n    q.z = abs (q.z);\n    q.yz -= vec2 (- wlRad - 0.35, wlBase.z);\n    d = PrCylDf (q.yzx, 0.08, wlBase.x);\n    DMINQ (idAx);\n    q = p;\n    q.y -= -0.88;\n    d = PrBoxDf (q, vec3 (1.3, 0.03, 1.35));\n    DMINQ (idBas);\n    q = p;\n    q = vec3 (abs (q.xz) - wlBase.xz, q.y + wlRad + 0.35).xzy;\n    if (p.z > 0.) q.xz = Rot2D (q.xz, - strRot * sign (p.x));\n    q.yz = Rot2D (q.yz, - ((p.x < 0.) ? wlRot.x : wlRot.y) * sign (p.z));\n    d = max (PrRoundCylDf (q.yzx, wlRad - 0.1, 0.1, 0.14), wlRad - 0.25 - length (q.yz));\n    d = min (d, PrCylDf (q.yzx, wlRad - 0.25, 0.2));\n    d = min (d, PrCylDf (vec3 (q.x, ((abs (q.y) < abs (q.z)) ? q.yz : q.zy)) -\n       vec3 (0.17, 0., 0.), 0.07, wlRad - 0.2));\n    DMINQ (idWhl);\n    q = p;\n    q.yz = Rot2D (q.yz - vec2 (0.72, 0.2), -0.1 * pi);\n    q -= vec3 (-0.5, -0.3, 1.5);\n    d = PrRoundCylDf (q, 0.03, 0.03, 0.35);\n    q.z -= -0.35;\n    q.xy = Rot2D (q.xy, -8. * strRot + pi / 6.);\n    q.xy = Rot2D (q.xy, 2. * pi * floor (3. * atan (q.y, - q.x) / (2. * pi) + 0.5) / 3.);\n    d = min (d, PrTorusDf (q, 0.025, 0.35));\n    q.x += 0.17;\n    d = min (d, PrCylDf (q.yzx, 0.02, 0.17));\n    DMINQ (idStr);\n    q = p;\n    q.yz -= vec2 (-0.4, 0.5);\n    d = PrBoxDf (q, vec3 (1.05, 0.1, 0.35));\n    q.yz = Rot2D (q.yz - vec2 (0.4, -0.43), 0.1 * pi);\n    d = min (d, PrBoxDf (q, vec3 (1.05, 0.35, 0.05)));\n    DMINQ (idSeat);\n    q = p;\n    q.yz -= vec2 (0.15, 1.7);\n    d = PrCapsDf (q.xzy, 0.06, 0.05);\n    DMINQ (idWLit);\n    q = p;\n    q.yz -= vec2 (-0.25, 2.99);\n    d = PrCapsDf (q.yzx, 0.05, 1.2);\n    DMINQ (idFLit);\n    q = p;\n    q.yz -= vec2 (-0.07, -3.);\n    d = PrCapsDf (q.yzx, 0.05, 1.2);\n    DMINQ (idBLit);\n  } else dMin = min (dMin, d);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar || p.y < 0.) break;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat TrObjDf (vec3 p)\n{\n  vec3 q, ds;\n  p -= carPos;\n  p.xz = Rot2D (p.xz, carRot);\n  p.z -= wlBase.z;\n  q = p;\n  ds = BPanel (q);\n  return max (max (ds.y + 0.03, ds.z + 0.02), max (abs (q.z - 0.5) - 1.55, - q.y - 0.2));\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 60; j ++) {\n    p = ro + dHit * rd;\n    d = TrObjDf (p);\n    if (d < 0.001 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 TrObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = TrObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  isSh = true;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  isSh = false;\n  return 0.6 + 0.4 * sh;\n}\n\nvec4 CarCol (out float refFac)\n{\n  vec4 col4, colB4;\n  float r, s;\n  colB4 = vec4 (0.8, 0.8, 0.9, 0.2);\n  col4 = colB4;\n  if (idObj == idBod) {\n    s = 1.;\n    if (qHit.z > 2.8 && PrRoundBox2Df (qHit.xy + vec2 (0., 0.53), vec2 (0.78, 0.15), 0.01) < 0.)\n       s = 0.7 + 0.3 * step (0.2, cos (8. * pi * qHit.x));\n    else if (qHit.y > -0.5 && abs (qHit.x) < 1.05 && abs (qHit.z + 2.) < 0.85)\n       s = 1. - 0.1 * cos (16. * pi * qHit.x);\n    else if (abs (qHit.z - 1.5) < 0.2 && length (vec2 (abs (qHit.x) - 0.2,\n       qHit.y + 0.1)) < 0.15) s = 0.6;\n    else s = 0.7 + 0.3 * step (-0.75, qHit.y) * step (0., max (abs (qHit.y) - 0.85,\n       abs (qHit.z - 0.5) - 0.01)) *\n       step (0., max (abs (qHit.y + 0.09) - 0.3, abs (qHit.z - 2.) - 0.01)) *\n       step (0., max (abs (qHit.y + 0.15) - 0.6, abs (qHit.z + 1.) - 0.01));\n    s *= 0.5 + 0.5 * step (wlRad + 0.07, length (vec2 (qHit.y + wlRad + 0.35,\n       abs (qHit.z) - wlBase.z)));\n    col4.rgb *= s;\n  } else if (idObj == idAx) {\n    col4 = vec4 (0.3, 0.3, 0.4, 0.1);\n  } else if (idObj == idBas) {\n    col4.rgb *= 0.4;\n  } else if (idObj == idWhl) {\n    r = wlRad - length (qHit.yz);\n    if (r < 0.22) col4 = vec4 (0.3, 0.3, 0.3, 0.) * (1. - 0.5 * step (r, 0.07) *\n       abs (step (0., cos (32. * pi * qHit.x)) - step (0.5, mod (32. * atan (qHit.z, - qHit.y) /\n       (2. * pi) + 0.5, 1.))));\n    else if (r < 0.25 || qHit.x < 0.) col4 *= 0.7;\n  } else if (idObj == idStr) {\n    col4 = vec4 (0.9, 0.9, 0.9, 0.2);\n  } else if (idObj == idSeat) {\n    col4 = vec4 (0.9, 0.7, 0.4, 0.05) * (0.95 + 0.05 * cos (64. * qHit.x));\n  } else if (idObj == idWLit) {\n    col4 = (onPath > 0.) ? vec4 (0., 0.8, 0., -1.) : vec4 (0.8, 0., 0., -1.);\n  } else if (idObj == idFLit || idObj == idBLit) {\n    if (abs (strRot) > 0.03 * pi && strRot * qHit.x < 0. && abs (qHit.x) > 1.1 &&\n       mod (2. * tCur, 1.) > 0.5) col4 = vec4 (0.8, 0.8, 0., -1.);\n    else col4 = (idObj == idFLit) ? vec4 (1., 1., 1., -1.) : vec4 (1., 0., 0., -1.);\n    col4.rgb *= 0.8 + 0.2 * smoothstep (0., 0.02, abs (abs (qHit.x) - 1.1));\n  }\n  refFac = 0.;\n  if (col4 == colB4 && (qHit.y < -0.5 || PrRoundBox2Df (qHit.xz + vec2 (0., 2.),\n     vec2 (1.1, 0.95), 0.01) > 0.)) refFac = 0.3;\n  return col4;\n}\n\nfloat TrailShd (vec2 p)\n{  // (from \"Lunar Buggy\")\n  vec4 u;\n  vec2 gB[2], gF[2], dg, q;\n  float st, s, gLen;\n  st = 1.;\n  gB[0] = carPos.xz;\n  gF[0] = gB[0] + Rot2D (vec2 (0., 2. * wlBase.z), - carRot);\n  for (int j = VAR_ZERO; j < npTrail; j ++) {\n    gB[1] = gB[0];\n    gF[1] = gF[0];\n    u = Loadv4 (npFst + j);\n    if (u.z >= 0.) {\n      gB[0] = u.xy;\n      gF[0] = gB[0] + Rot2D (vec2 (0., 2. * wlBase.z), - u.z);\n      s = 1.;\n      dg = gB[0] - gB[1];\n      gLen = length (dg);\n      if (gLen > 0.) {\n        q = Rot2Cs (p - 0.5 * (gB[0] + gB[1]), dg.yx / gLen);\n        s = min (s, PrRoundBox2Df (vec2 (abs (q.x) - wlBase.x, q.y), vec2 (0.12, 0.5 * gLen), 0.05));\n      }\n      for (float k = -1.; k <= 1.; k += 2.) {\n        dg = gF[0] - gF[1];\n        gLen = length (dg);\n        if (gLen > 0.) {\n          s = min (s, PrRoundBox2Df (Rot2Cs (p - 0.5 * (gF[0] + gF[1]) +\n             Rot2D (vec2 (k * wlBase.x, 0.), - u.z), dg.yx / gLen), vec2 (0.12, 0.5 * gLen), 0.05));\n        }\n      }\n      st = min (st, 1. - 0.3 * sqrt (1. - min (1., (float (j) + 10. * (tCur - u.w)) /\n         float (npTrail))) * (1. - smoothstep (0., 0.05, s)));\n    } else break;\n  }\n  return st;\n}\n\nvec3 GrndNf (vec2 p)\n{\n  vec2 e = vec2 (0.01, 0.);\n  return vec3 (normalize (vec3 (Fbm2 (p) - vec2 (Fbm2 (p + e.xy),\n     Fbm2 (p + e.yx)), 2. * e.x)).xzy);\n}\n\nvec3 GrndCol (vec3 ro, float dstGrnd, float sh)\n{\n  vec3 col, colG, vn;\n  vec2 vf, q;\n  float a, f, ff, st, s1, s2;\n  q = mod (ro.xz + 0.5 * hgSize, hgSize) - 0.5 * hgSize;\n  colG = 0.4 * mix (vec3 (0.8, 1., 0.5), vec3 (0.7, 0.9, 0.5), 0.2 +\n     0.8 * smoothstep (0.3, 0.7, Fbm2 (4. * ro.xz)));\n  vf = vec2 (0.);\n  f = abs (PrBox2Df (q, vec2 (0.3 * hgSize)) - 0.1 * hgSize);\n  if (f < trWidf + 0.2) {\n    col = mix (colG, vec3 (0.3), step (f, trWidf + 0.2));\n    s1 = smoothstep (0., 0.02, 0.2 - abs (f - trWidf - 0.2));\n    s2 = (1. - smoothstep (0., 0.02, f - 0.2)) * smoothstep (0., 0.01,\n       Maxv2 (abs (mod (8. * q / (0.4 * hgSize) + 0.5, 1.) - 0.5) - 0.13));\n    col = mix (mix (col, vec3 (0.9, 0.9, 0.5), s1), vec3 (0.8), s2);\n    vn = vec3 (0., 1., 0.);\n    vf = vec2 (16., 1. - max (s1, s2));\n  } else {\n    col = colG;\n    vn = GrndNf (ro.xz);\n  }\n  st = TrailShd (ro.xz);\n  vf *= 1. + 2. * step (st, 0.99);\n  ff = 1. - smoothstep (0.5, 0.8, dstGrnd / dstFar);\n  if (vf.x > 0. && ff > 0.) vn = VaryNf (vf.x * ro, vn, vf.y * ff);\n  col *= (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.)) * (0.3 + 0.7 * st);\n  return col;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.4, 0.5);\n  } else {\n    q = 0.01 * (ro.xz + 2. * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.3, 0.4, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 roo, rdo, col, colR, vn;\n  float dstObj, dstGrnd, dstTrObj, nDotL, refFac, sh;\n  roo = ro;\n  rdo = rd;\n  isSh = false;\n  dstTrObj = TrObjRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = CarCol (refFac);\n    if (dstTrObj < dstObj) refFac = 0.;\n    if (col4.a >= 0.) {\n      nDotL = max (dot (vn, sunDir), 0.);\n      sh = ObjSShadow (ro + 0.01 * vn, sunDir);\n      col = col4.rgb * (0.2 + 0.2 * max (dot (vn, sunDir * vec3 (-1., 1., -1.)), 0.) +\n         0.8 * sh * nDotL * nDotL) + col4.a * step (0.95, sh) *\n         pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n      if (refFac > 0.) rd = reflect (rd, vn);\n    } else if (col4.a == -1.) {\n      col = col4.rgb * (0.5 - 0.5 * dot (rd, vn));\n    }\n  }\n  if (dstObj >= dstFar || refFac > 0.) {\n    if (rd.y < 0.) {\n      dstGrnd = - ro.y / rd.y;\n      ro += dstGrnd * rd;\n      sh = (dstGrnd < dstFar) ? ObjSShadow (ro + 0.01 * vec3 (0., 1., 0.), sunDir) : 1.;\n      colR = GrndCol (vec3 (ro.xz, 0.).xzy, dstGrnd, sh);\n      colR = mix (colR, vec3 (0.3, 0.4, 0.5), pow (1. + rd.y, 16.));\n    } else {\n      colR = SkyBgCol (ro, rd);\n    }\n    col = (refFac > 0.) ? mix (col, 0.9 * colR, refFac) : colR;\n  }\n  if (dstTrObj < min (dstObj, dstFar)) {\n    ro = roo + dstTrObj * rdo;\n    vn = TrObjNf (ro);\n    col *= vec3 (0.9, 1., 0.9);\n    rd = reflect (rdo, vn);\n    col = mix (col, SkyBgCol (ro, rd), 0.2 + 0.8 * pow (1. - abs (dot (vn, rdo)), 5.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat;\n  vec3 rd, ro, col, c, wgBox;\n  vec2 canvas, uv, ud, cnPos;\n  float el, az, asp, zmFac, trvDist, s, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  asp = canvas.x / canvas.y;\n  stDat = Loadv4 (1);\n  wlBase = stDat.xyz;\n  wlRad = wlBase.y;\n  stDat = Loadv4 (2);\n  hgSize = stDat.x;\n  trWidf = stDat.y;\n  onPath = stDat.z;\n  trvDist = stDat.w;\n  stDat = Loadv4 (3);\n  az = stDat.x;\n  el = stDat.y;\n  cnPos = stDat.zw;\n  stDat = Loadv4 (4);\n  strRot = stDat.y;\n  wlRot = stDat.zw;\n  stDat = Loadv4 (5);\n  carPos = stDat.xyz;\n  carRot = stDat.w;\n  el = clamp (el - 0.1 * pi, -0.49 * pi, -0.03 * pi);\n  if (el > -0.47 * pi) az += carRot;\n  vuMat = StdVuMat (el, az);\n  ro = carPos + vuMat * vec3 (0., 0., -12.) + vec3 (Rot2D (vec2 (0., wlBase.z), - carRot),\n     carPos.y + 1.).xzy;\n  carPos.y += wlRad + 0.95;\n  zmFac = 5. + 3. * el;\n  dstFar = 150.;\n  sunDir = normalize (vec3 (1., 2., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  wgBox = vec3 (0.41, -0.32, 0.135);\n  ud = 0.5 * uv - wgBox.xy * vec2 (asp, 1.);\n  s = (length (ud) - wgBox.z) * canvas.y;\n  col = mix (vec3 (0., 1., 1.), col, smoothstep (0., 1., abs (s) - 1.));\n  if (s < 0.) {\n    col = mix (vec3 (0., 1., 1.), col, step (1., Minv2 (abs (ud)) * canvas.y));\n    c = (onPath > 0.) ? vec3 (0., 1., 0.) : vec3 (0.8, 0., 0.);\n    col = mix (c, col,\n       smoothstep (2.5, 3.5, abs (length (ud - cnPos) * canvas.y - 10.)));\n    ud = Rot2D (ud, atan (cnPos.y, - cnPos.x));\n    if (ud.x < 0. && (length (cnPos) - length (ud)) * canvas.y > 10.)\n       col = mix (c, col, smoothstep (1.5, 2.5, abs (ud.y) * canvas.y));\n  }\n  col = mix (col, vec3 (0., 1., 1.), ShowIntPZ (0.5 * uv - vec2 (0.44 * asp, -0.15),\n     vec2 (0.06 * asp, 0.03), 4., mod (floor (trvDist / (2. * wlRad)), 1e4)));\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat DigSeg (vec2 q)\n{\n  return (1. - smoothstep (0.13, 0.17, abs (q.x))) *\n     (1. - smoothstep (0.5, 0.57, abs (q.y)));\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowIntPZ (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    nDig = mxChar;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    val = max (val, 0.);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Truck Driving 2\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Noiseff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int npTrail = 256;  // same for image and buffer\nconst int npFst = 6;\n\nvec3 carPos, wlBase;\nfloat carRot, hgSize, trWidf;\nconst float pi = 3.1415927;\nconst float txRow = 128.;\n\nfloat OnPath ()\n{\n  vec2 q;\n  q = carPos.xz + Rot2D (vec2 (0., wlBase.z), - carRot);\n  return (abs (PrBox2Df (mod (q + 0.5 * hgSize, hgSize) - 0.5 * hgSize,\n     vec2 (0.3 * hgSize)) - 0.1 * hgSize) < trWidf) ? 1. : 0.;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat;\n  vec3 wgBox;\n  vec2 iFrag, canvas, cnPos, wlRot, cp, ud, w;\n  float tCur, autoMd, cRotN, strRot, wlRad, rTurn, spd, onPath, trvDist, tc, nStep,\n     az, el, asp, s;\n  int pxId, wgSel, nFrame;\n  bool init;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (pxId >= npFst + npTrail) discard;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  init = (iFrame <= 5);\n  asp = canvas.x / canvas.y;\n  if (init) {\n    carPos = vec3 (0.);\n    carRot = 0.;\n    strRot = 0.;\n    wlRad = 0.6;\n    wlBase = vec3 (1.25, wlRad, 2.);\n    wlRot = vec2 (0.);\n    az = -0.3 * pi;\n    el = 0.;\n    nStep = 0.;\n    cnPos = vec2 (0.);\n    mPtrP = mPtr;\n    wgSel = 0;\n    autoMd = 1.;\n    hgSize = 100.;\n    trWidf = 3.;\n    onPath = 0.;\n    trvDist = 0.;\n  } else {\n    stDat = Loadv4 (0);\n    mPtrP.xyz = stDat.xyz;\n    wgSel = int (stDat.w);\n    stDat = Loadv4 (1);\n    wlBase = stDat.xyz;\n    autoMd = stDat.w;\n    stDat = Loadv4 (2);\n    hgSize = stDat.x;\n    trWidf = stDat.y;\n    onPath = stDat.z;\n    trvDist = stDat.w;\n    stDat = Loadv4 (3);\n    az = stDat.x;\n    el = stDat.y;\n    cnPos = stDat.zw;\n    stDat = Loadv4 (4);\n    nStep = stDat.x;\n    strRot = stDat.y;\n    wlRot = stDat.zw;\n    stDat = Loadv4 (5);\n    carPos = stDat.xyz;\n    carRot = stDat.w;\n  }\n  if (pxId < npFst) {\n    wgBox = vec3 (0.41, -0.32, 0.135);\n    if (mPtr.z > 0.) {\n      if (wgSel == 0 && mPtrP.z > 0.) {\n        az = -2. * pi * mPtr.x;\n        el = - pi * mPtr.y;\n      } else {\n        ud = mPtr.xy * vec2 (asp, 1.) - wgBox.xy * vec2 (asp, 1.);\n        if (wgSel == 1) {\n          autoMd = - tCur;\n          cnPos = ud;\n          s = length (cnPos);\n          if (s > 0.) cnPos = min (s, wgBox.z) * cnPos / s;\n        } else if (mPtrP.z <= 0. && length (ud) < wgBox.z) wgSel = 1;\n      }\n    } else {\n      wgSel = 0;\n      cnPos *= 1. - 5e-3;\n    }\n    wlRad = wlBase.y;\n    ++ nStep;\n    if (autoMd > 0.) {\n      tc = 0.005 * nStep;\n      s = 2. * Noiseff (37.1 * mod (floor (tc), 16.)) - 1.;\n      s = max (0.3, abs (s)) * sign (s);\n      strRot = 0.15 * pi * s * SmoothBump (0.2, 0.8, 0.1, mod (tc, 1.));\n      spd = 0.12 - 0.06 * abs (strRot / (0.15 * pi));\n      w = vec2 (- strRot / (0.15 * pi), spd / 0.5);\n      w = pow (abs (w), 1. / vec2 (1.5)) * sign (w);\n      cnPos = w * wgBox.z;\n    } else {\n      w = cnPos / wgBox.z;\n      w = pow (abs (w), vec2 (1.5)) * sign (w);\n      strRot = -0.18 * pi * w.x;\n      spd = 0.2 * w.y;\n      if (tCur + autoMd > 10.) autoMd = 1.;\n    }\n    cp = carPos.xz;\n    w = vec2 (1.);\n    if (abs (strRot) > 1e-4) {\n      cRotN = carRot - strRot * spd / pi;\n      rTurn = wlBase.z / asin (0.5 * strRot);\n      carPos.xz += rTurn * (sin (carRot - vec2 (0.5 * pi, 0.)) - sin (cRotN - vec2 (0.5 * pi, 0.)));\n      carRot = mod (cRotN, 2. * pi);\n      w += vec2 (-1., 1.) * wlBase.x / rTurn;\n    } else {\n      carPos.xz += spd * sin (carRot + vec2 (0., 0.5 * pi));\n    }\n    wlRot += w * spd / wlRad;\n    if (pxId == 2) {\n      onPath = OnPath ();\n      if (onPath > 0.) trvDist += length (carPos.xz - cp);\n      else trvDist = 0.;\n    }\n  }\n  if (! init) {\n    if (mod (float (nFrame), 6.) == 0.) {\n      if (pxId == npFst) stDat = vec4 (Loadv4 (5).xzw, tCur);\n      else if (pxId < npFst + npTrail) stDat = Loadv4 (pxId - 1);\n    } else if (pxId >= npFst && pxId < npFst + npTrail) stDat = Loadv4 (pxId);\n  } else {\n    stDat = vec4 (0., 0., -1., 0.);\n  }\n  if      (pxId == 0) stDat = vec4 (mPtr.xyz, float (wgSel));\n  else if (pxId == 1) stDat = vec4 (wlBase, autoMd);\n  else if (pxId == 2) stDat = vec4 (hgSize, trWidf, onPath, trvDist);\n  else if (pxId == 3) stDat = vec4 (az, el, cnPos);\n  else if (pxId == 4) stDat = vec4 (nStep, strRot, wlRot);\n  else if (pxId == 5) stDat = vec4 (carPos, carRot);\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftt3Ds.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1694, 1694, 1716, 1716, 2110], [2112, 2112, 2134, 2134, 4853], [4855, 4855, 4888, 4888, 5135], [5137, 5137, 5158, 5158, 5415], [5417, 5417, 5441, 5441, 5640], [5642, 5642, 5677, 5677, 5925], [5927, 5927, 5950, 5950, 6209], [6211, 6211, 6248, 6248, 6508], [6510, 6510, 6542, 6542, 8731], [9920, 9920, 9942, 9942, 10078], [10080, 10080, 10129, 10129, 11213], [11215, 11215, 11249, 11249, 12006], [12008, 12008, 12043, 12043, 13581], [13583, 13583, 13639, 13639, 15891], [15893, 15893, 15925, 15925, 16025], [16027, 16027, 16060, 16060, 16149], [16151, 16151, 16198, 16198, 16245], [16247, 16247, 16289, 16289, 16340], [16342, 16342, 16399, 16399, 16475], [16477, 16477, 16520, 16520, 16584], [16586, 16586, 16632, 16632, 16689], [16691, 16691, 16713, 16713, 16740], [16742, 16742, 16764, 16764, 16791], [16793, 16793, 16829, 16829, 17035], [17037, 17037, 17067, 17067, 17180], [17182, 17182, 17213, 17213, 17277], [17279, 17279, 17302, 17302, 17404], [17477, 17477, 17509, 17509, 18051], [18053, 18053, 18115, 18115, 18507], [18541, 18541, 18565, 18565, 18618], [18620, 18620, 18644, 18644, 18756], [18758, 18758, 18783, 18783, 18929], [18931, 18931, 18956, 18956, 19142], [19144, 19144, 19166, 19166, 19320], [19322, 19322, 19343, 19343, 19498], [19500, 19500, 19529, 19529, 19741], [19743, 19743, 19782, 19782, 20034], [20128, 20128, 20153, 20153, 20276]], "test": "untested"}
{"id": "flt3Ws", "name": "ROOTMOID", "author": "ENDESGA", "description": "a neat function that can give interesting results with ML and colour-grading", "tags": ["2d", "graphing", "sigmoid", "subpixel", "root", "rootmoid"], "likes": 2, "viewed": 250, "published": 3, "date": "1636964917", "time_retrieved": "2024-07-30T18:48:05.518564", "image_code": "// original by musk (mu6k) License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// rootmoid function by @ENDESGA\n\n#define M iMouse.xy\n#define R iResolution.xy\n\nfloat rmoid( float x ) {\n\treturn sqrt( abs( x ) ) * sign( x );\n}\n\nfloat rmoid_norm( float x ) {// from 0 to 1\n\treturn ( sqrt( abs( ( x - .5 ) * .5 ) ) * sign( x - .5 ) ) + .5;\n}\n\nfloat f( float x ) {\n    return rmoid_norm( x );\n}\n\nvoid mainImage( out vec4 O, in vec2 I ) {\n\tvec2 uv = I.xy;\n\n\tuv = ( I.xy - M + R ) / R - 1.;\n    if( M.x <= .0) uv -= .5;\n\tuv.x = uv.x * R.x / R.y;\n\tuv *= 4.0;\n\tfloat pixel = 4. / R.y;\n\n\tvec3 c = vec3( .0 );\n\n\tfor( int i = 0; i < 3; i++ ) {\n\t\tfloat x = uv.x + pixel * .3333 + float( i ) * pixel * .3333;\n\t\tfloat y = uv.y + pixel;\n\n\t\tfloat s0 = f( x - pixel );\n\t\tfloat s1 = f( x + pixel );\n\n\t\tif( s0 - pixel <= y && y < s1 + pixel || s1 - pixel <= y && y < s0 + pixel ) {\n\t\t\tc[ i ] += 1.0;\n\t\t}\n\t}\n\n\tc += max( .0, 1.0 - abs( mod( uv.x + .5, 1.0 ) - .5 ) / pixel * 0.5 ) * .1 / ( .5 + abs( uv.x * 2. ) * .5 );\n\tc += max( .0, 1.0 - abs( mod( uv.y + .5, 1.0 ) - .5 ) / pixel * 0.5 ) * .1 / ( .5 + abs( uv.y * 2. ) * .5 );\n\n\tO = vec4( pow( c, vec3( .6 ) ), 1.0 );\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flt3Ws.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[192, 192, 216, 216, 256], [258, 258, 287, 301, 369], [371, 371, 391, 391, 421], [423, 423, 464, 464, 1182]], "test": "untested"}
{"id": "NldGWl", "name": "Infinite Cube Spiral", "author": "amhall", "description": "A continuous cube spiral inspired by bitless' \"Infinite Cube Zoom.\" Mouse y changes the size of each layer.", "tags": ["2d", "cube", "zoom", "spiral", "infinite"], "likes": 24, "viewed": 455, "published": 3, "date": "1636959721", "time_retrieved": "2024-07-30T18:48:06.422148", "image_code": "// Infinite Cube Spiral by Anthony Hall\n// Inspired by \"Infinite Cube Zoom\" by bitless:\n// https://www.shadertoy.com/view/3lc3zH\n\n\n// Transforms the distinct cubes into one continuous spiral.\n// When disabled, it's pretty much a less fancy version of\n// bitless' shader. I can't take any credit for the concept,\n// I just really like how it looks without the spiral.\n#define SPIRAL\n\n// Supersamples pixels near the center. At high resolutions,\n// this doesn't impact performance very much\n#define SS\n\nconst float pi = radians(180.0);\nconst float twoPi = radians(360.0);\n\n// Time in seconds to zoom through a full cube\nconst float zoomPeriod = 6.0;\n\n// Globals set in mainImage\nfloat time;\nfloat base;\n\nconst vec3 toLight = normalize(vec3(3, 4, 2));\n\n// Procedural color palette\nvec3 palette(float t)\n{\n    t *= twoPi;\n    \n    vec2 colors = vec2(\n        0.5 + 0.5 * cos(t - 1.0),\n        0.6 - 0.4 * cos(t + 1.9));\n\n    return colors.xxy;\n}\n\n// Returns the scene color\nvec3 image(vec2 point)\n{\n    float r = length(point);\n    float theta = atan(point.y, point.x);\n    \n    // Mapping which of the 6 slices we are in\n    float region = floor((6.0 * theta + pi) / twoPi);\n    \n    // Set each slice to be repeating from -30 to 30 deg\n    theta = (mod(6.0 * theta + pi, twoPi) - pi) / 6.0;\n    \n#ifdef SPIRAL\n\n    // The spiral is achieved by offsetting each slice's radius\n    // by 1/3 of a layer, then rotating each slice so the lines\n    // connect to both neighbors. We can exactly solve for this\n    // rotation using the law of cosines:\n    // a^2 = b^2 + c^2 - 2bc cos A\n    // Here, a is the ccw side and b is the clockwise side.\n    \n    float a = pow(base, -1.0 / 6.0);\n    float b = 1.0 / a;\n    float c = sqrt(a*a + b*b - a*b); // cos C = 0.5\n    \n    float A = acos((a*a - b*b - c*c) / (-2.0*b*c));\n    float correction = pi/3.0 - A;\n    theta -= correction;\n    \n    float level = log(r * cos(theta)) / log(base) - 2.0 * fract(time / zoomPeriod) + region / 3.0;\n\n#else\n\n    float level = log(r * cos(theta)) / log(base) - 2.0 * fract(time / zoomPeriod);\n\n#endif\n\n    // Calculate which direction this surface is facing for lighting.\n    // The face index corresponds to the axis the normal is on\n    float invert = floor(mod(level, 2.0));\n    region = mod(region + 3.0 * invert - 2.0, 6.0);\n    float face = floor(region / 2.0);\n\n    float diffuse = toLight[int(face)];\n    diffuse = 0.4 + 0.6 * diffuse;\n\n    // Unfortunately, this palette only yields good colors for\n    // 0 < t < 0.5\n    vec3 color = palette((fract(level) + face) / 6.0);\n    color *= diffuse;\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    time = iTime;\n\n// I find that different base values are ideal for spiral vs non-spiral\n#ifdef SPIRAL\n\n    if (iMouse.z > 0.0)\n        base = exp2(0.35 + 0.8 * iMouse.y / iResolution.y);\n    else\n        base = 1.52 + 0.08 * cos(0.18 * time);\n    \n#else\n\n    if (iMouse.z > 0.0)\n        base = exp2(0.4 + 1.6 * iMouse.y / iResolution.y);\n    else\n        base = 1.85 + 0.35 * cos(0.18 * time);\n\n#endif\n\n    vec3 color = vec3(0.0);\n    \n#ifdef SS\n    \n    // Since the level of detail is logarithmic, it is dependent\n    // on the number of pixels away from the center, regardless\n    // of resolution. Thus, supersampling is done based on absolute\n    // pixel distance rather than percentage of the viewport.\n    \n    vec2 absPixelCoord = abs(fragCoord - 0.5 * iResolution.xy);\n    float bound = max(absPixelCoord.x, absPixelCoord.y);\n    \n    // This samples 2x2 within 120 pixels of the center, and\n    // 3x3 within 12 pixels. 120 is definitely overkill for\n    // strictly avoiding aliasing, I just find the jaggies\n    // visually unappealing when the threshold is smaller.\n    \n    int samples = 1 + int(bound < 120.0) + int(bound < 12.0);\n    float increment = 1.0 / float(samples);\n    float offset = 0.5 * increment - 0.5;\n    \n    for (int x = 0; x < samples; x++)\n    {\n        for (int y = 0; y < samples; y++)\n        {\n            vec2 ssFragCoord = fragCoord + vec2(x, y) * increment + offset;\n            vec2 ssPoint = (2.0 * ssFragCoord - iResolution.xy) / iResolution.y;\n            color += image(ssPoint);\n        }\n    }\n    color /= float(samples * samples);\n\n#else\n    \n    vec2 point = (2.0 * fragCoord - iResolution.xy) / iResolution.y; \n    color = image(point);\n    \n#endif\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NldGWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[750, 778, 801, 801, 941], [943, 970, 994, 994, 2603], [2605, 2605, 2660, 2660, 4403]], "test": "untested"}
{"id": "NtdGDl", "name": "Chaos Game - Sierpinski Gasket", "author": "oneshade", "description": "What?!\n---> [url=https://www.youtube.com/watch?v=kbKtFN71Lfs]https://www.youtube.com/watch?v=kbKtFN71Lfs[/url]", "tags": ["random", "chaos", "sierpinski"], "likes": 8, "viewed": 169, "published": 3, "date": "1636953483", "time_retrieved": "2024-07-30T18:48:07.211039", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A vec2(-0.5, -0.25)\n#define B vec2(0.4, 0.1)\n#define C vec2(-0.3, 0.45)\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nvec2 Hash12(in float x) {\n    vec3 p3 = fract(x * vec3(0.1031, 0.103, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    float seed = 7.39 * float(iFrame) + 13.84;\n    if (iFrame == 0) fragColor.xy = Hash12(seed);\n    if (iFrame > 0 && ivec2(fragCoord) == ivec2(0, 0)) {\n        fragColor = texelFetch(iChannel0, ivec2(0, 0), 0);\n        int randInt = int(100.0 * Hash11(seed)) % 3;\n        if (randInt == 0) fragColor.xy = (fragColor.xy + A) / 2.0;\n        if (randInt == 1) fragColor.xy = (fragColor.xy + B) / 2.0;\n        if (randInt == 2) fragColor.xy = (fragColor.xy + C) / 2.0;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel1, uv);\n\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n\n    if (iFrame > 0) {\n        vec2 pos = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n        float dist = length(uv - pos) - 0.001;\n        fragColor = max(fragColor, smoothstep(unit, 0.0, dist));\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtdGDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 139]], "test": "untested"}
{"id": "NtdGWl", "name": "Persian carpet 23", "author": "jarble", "description": "A series of randomly generated carpet designs.", "tags": ["fractal", "carpet", "rug"], "likes": 4, "viewed": 243, "published": 3, "date": "1636942227", "time_retrieved": "2024-07-30T18:48:07.972004", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5/8.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime/2.+uv.x)/10.0);\n    vec3 random1 = (hash31(3.+t2));\n    vec3 random2 = (hash31(4.+t2));\n    vec3 random3 = random1*3.;\n    vec3 random4 = random2*3.;\n    vec3 random5 = random2*3.;\n    \n    float offset = .5;\n    float scale2 = 1.5;\n    //float bend = scale2;\n    float bend = 1.+1./3.;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        //float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            \n            for(int k = 0; k < 3; k++){    \n                uv /= -scale2;\n                //float bend = 1.+random3[k];\n                //float bend = abs(fract((uv.x)*2.)-.5)/2.+1.;\n                //float bend = 1.+1./3.;\n                //float bend = scale2/1.5;\n                \n                \n                \n                uv.yx = triangle_wave(uv.yx-offset,scale)/bend+triangle_wave(uv,scale)*bend;\n                //bend += 1./(1.+uv.x+uv.y);\n                bend *= -1.+(uv.x+uv.y)/(6.+random5[k]*4.);\n\n                //bend = 1./bend;\n                uv += vec2(random1[k],random2[k])/(6.);                \n            }\n            \n\n            //offset += .5;\n            scale /= 1.+(scale2)*col.x/(3.+random3[i]);\n            scale2 -= (col.x-1.)/(3.+random4[i]);\n\n\n            col[c] = abs((uv.x)-(uv.y));\n            //random2 = col - random2;\n            \n\n        }\n\t}\n    \n    fragColor = vec4(vec3(col*2.),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtdGWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [590, 590, 629, 629, 674], [676, 676, 733, 733, 2441]], "test": "untested"}
{"id": "st3GDs", "name": "A green thing in a bathroom", "author": "PauloFalcao", "description": "A shader made in Material Maker using my raymarching lib for nodevember2021 - Use Mouse to change camera and twist\nIt takes some time to compile... A Realtime version here https://www.shadertoy.com/view/7ltGDl", "tags": ["materialmaker", "nodes", "nodevember2021"], "likes": 22, "viewed": 895, "published": 3, "date": "1636930044", "time_retrieved": "2024-07-30T18:48:09.191743", "image_code": "// A green thing in a bathroom\n//\n// By https://twitter.com/paulofalcao\n//\n// https://twitter.com/paulofalcao/status/1460016767540019201\n//\n// Generated in Material Maker\n// Made for #nodevember2021 Day 13/14: Green\n//\n// This uses the MFSDF scene description technique\n// https://www.shadertoy.com/view/7dySRc\n//\n// To generate your own shaders you need:\n//\n// - Material Maker - https://rodzilla.itch.io/material-maker\n// - My Ray Marching library - https://github.com/paulofalcao/MaterialMakerRayMarching\n// \n// Here is a 2 hour video explaining how to use it - https://youtu.be/PvmIohbf93Q\n// \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec4 color = texture(iChannel0, fragCoord / iResolution.xy);\n    fragColor = vec4(pow(color.xyz/color.w,vec3(1.0/2.2)), 1.0f);\n     \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/* Generated by Material Maker */\n\n#define SEED_VARIATION 0.0\n\n//---\n\nfloat rand(vec2 x) {\n    return fract(cos(mod(dot(x, vec2(13.9898, 8.141)), 3.14)) * 43758.5453);\n}\n\nvec2 rand2(vec2 x) {\n    return fract(cos(mod(vec2(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t      dot(x, vec2(3.4562, 17.398))), vec2(3.14))) * 43758.5453);\n}\n\nvec3 rand3(vec2 x) {\n    return fract(cos(mod(vec3(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t\t  dot(x, vec2(3.4562, 17.398)),\n                              dot(x, vec2(13.254, 5.867))), vec3(3.14))) * 43758.5453);\n}\n\nvec3 rgb2hsv(vec3 c) {\n\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n\tvec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat param_rnd(float minimum, float maximum, float seed) {\n\treturn minimum+(maximum-minimum)*rand(vec2(seed));\n}\n//Adapted from https://iquilezles.org/articles/distfunctions - Finite Repetition\n\nvec3 opRepLim(vec3 p,vec3 c,vec3 l){\n    p+=(c*l)/2.0;\n    return p-c*clamp(floor(p/c+0.5),vec3(0.0),l);\n}vec3 MFSDF_Obj_Maker_rotate3d(vec3 p, vec3 a) {\n\tvec3 rv;\n\tfloat c;\n\tfloat s;\n\tc = cos(a.x);\n\ts = sin(a.x);\n\trv.x = p.x;\n\trv.y = p.y*c+p.z*s;\n\trv.z = -p.y*s+p.z*c;\n\tc = cos(a.y);\n\ts = sin(a.y);\n\tp.x = rv.x*c+rv.z*s;\n\tp.y = rv.y;\n\tp.z = -rv.x*s+rv.z*c;\n\tc = cos(a.z);\n\ts = sin(a.z);\n\trv.x = p.x*c+p.y*s;\n\trv.y = -p.x*s+p.y*c;\n\trv.z = p.z;\n\treturn rv;\n}\nvec4 brick(vec2 uv, vec2 bmin, vec2 bmax, float mortar, float round, float bevel) {\n\tfloat color;\n\tvec2 size = bmax - bmin;\n\tfloat min_size = min(size.x, size.y);\n\tmortar *= min_size;\n\tbevel *= min_size;\n\tround *= min_size;\n\tvec2 center = 0.5*(bmin+bmax);\n    vec2 d = abs(uv-center)-0.5*(size)+vec2(round+mortar);\n    color = length(max(d,vec2(0))) + min(max(d.x,d.y),0.0)-round;\n\tcolor = clamp(-color/bevel, 0.0, 1.0);\n\tvec2 tiled_brick_pos = mod(bmin, vec2(1.0, 1.0));\n\treturn vec4(color, center, tiled_brick_pos.x+7.0*tiled_brick_pos.y);\n}\n\nvec3 brick_random_color(vec2 bmin, vec2 bmax, float seed) {\n\tvec2 center = 0.5*(bmin + bmax);\n\treturn rand3(fract(center + vec2(seed)));\n}\n\nvec3 brick_uv(vec2 uv, vec2 bmin, vec2 bmax, float seed) {\n\tvec2 center = 0.5*(bmin + bmax);\n\tvec2 size = bmax - bmin;\n\tfloat max_size = max(size.x, size.y);\n\treturn vec3(0.5+(uv-center)/max_size, rand(fract(center)+vec2(seed)));\n}\n\nvec3 brick_corner_uv(vec2 uv, vec2 bmin, vec2 bmax, float mortar, float corner, float seed) {\n\tvec2 center = 0.5*(bmin + bmax);\n\tvec2 size = bmax - bmin;\n\tfloat max_size = max(size.x, size.y);\n\tfloat min_size = min(size.x, size.y);\n\tmortar *= min_size;\n\tcorner *= min_size;\n\treturn vec3(clamp((0.5*size-vec2(mortar)-abs(uv-center))/corner, vec2(0.0), vec2(1.0)), rand(fract(center)+vec2(seed)+ceil(vec2(uv-center))));\n}\n\nvec4 bricks_rb(vec2 uv, vec2 count, float repeat, float offset) {\n\tcount *= repeat;\n\tfloat x_offset = offset*step(0.5, fract(uv.y*count.y*0.5));\n\tvec2 bmin = floor(vec2(uv.x*count.x-x_offset, uv.y*count.y));\n\tbmin.x += x_offset;\n\tbmin /= count;\n\treturn vec4(bmin, bmin+vec2(1.0)/count);\n}\n\nvec4 bricks_rb2(vec2 uv, vec2 count, float repeat, float offset) {\n\tcount *= repeat;\n\tfloat x_offset = offset*step(0.5, fract(uv.y*count.y*0.5));\n\tcount.x = count.x*(1.0+step(0.5, fract(uv.y*count.y*0.5)));\n\tvec2 bmin = floor(vec2(uv.x*count.x-x_offset, uv.y*count.y));\n\tbmin.x += x_offset;\n\tbmin /= count;\n\treturn vec4(bmin, bmin+vec2(1.0)/count);\n}\n\nvec4 bricks_hb(vec2 uv, vec2 count, float repeat, float offset) {\n\tfloat pc = count.x+count.y;\n\tfloat c = pc*repeat;\n\tvec2 corner = floor(uv*c);\n\tfloat cdiff = mod(corner.x-corner.y, pc);\n\tif (cdiff < count.x) {\n\t\treturn vec4((corner-vec2(cdiff, 0.0))/c, (corner-vec2(cdiff, 0.0)+vec2(count.x, 1.0))/c);\n\t} else {\n\t\treturn vec4((corner-vec2(0.0, pc-cdiff-1.0))/c, (corner-vec2(0.0, pc-cdiff-1.0)+vec2(1.0, count.y))/c);\n\t}\n}\n\nvec4 bricks_bw(vec2 uv, vec2 count, float repeat, float offset) {\n\tvec2 c = 2.0*count*repeat;\n\tfloat mc = max(c.x, c.y);\n\tvec2 corner1 = floor(uv*c);\n\tvec2 corner2 = count*floor(repeat*2.0*uv);\n\tfloat cdiff = mod(dot(floor(repeat*2.0*uv), vec2(1.0)), 2.0);\n\tvec2 corner;\n\tvec2 size;\n\tif (cdiff == 0.0) {\n\t\tcorner = vec2(corner1.x, corner2.y);\n\t\tsize = vec2(1.0, count.y);\n\t} else {\n\t\tcorner = vec2(corner2.x, corner1.y);\n\t\tsize = vec2(count.x, 1.0);\n\t}\n\treturn vec4(corner/c, (corner+size)/c);\n}\n\nvec4 bricks_sb(vec2 uv, vec2 count, float repeat, float offset) {\n\tvec2 c = (count+vec2(1.0))*repeat;\n\tfloat mc = max(c.x, c.y);\n\tvec2 corner1 = floor(uv*c);\n\tvec2 corner2 = (count+vec2(1.0))*floor(repeat*uv);\n\tvec2 rcorner = corner1 - corner2;\n\tvec2 corner;\n\tvec2 size;\n\tif (rcorner.x == 0.0 && rcorner.y < count.y) {\n\t\tcorner = corner2;\n\t\tsize = vec2(1.0, count.y);\n\t} else if (rcorner.y == 0.0) {\n\t\tcorner = corner2+vec2(1.0, 0.0);\n\t\tsize = vec2(count.x, 1.0);\n\t} else if (rcorner.x == count.x) {\n\t\tcorner = corner2+vec2(count.x, 1.0);\n\t\tsize = vec2(1.0, count.y);\n\t} else if (rcorner.y == count.y) {\n\t\tcorner = corner2+vec2(0.0, count.y);\n\t\tsize = vec2(count.x, 1.0);\n\t} else {\n\t\tcorner = corner2+vec2(1.0);\n\t\tsize = vec2(count.x-1.0, count.y-1.0);\n\t}\n\treturn vec4(corner/c, (corner+size)/c);\n}// https://www.shadertoy.com/view/XsX3zB\n//\n// The MIT License\n// Copyright © 2013 Nikita Miropolskiy\n// \n// ( license has been changed from CCA-NC-SA 3.0 to MIT\n//\n//   but thanks for attributing your source code when deriving from this sample \n//   with a following link: https://www.shadertoy.com/view/XsX3zB )\n//\n//\n// if you're looking for procedural noise implementation examples you might \n// also want to look at the following shaders:\n// \n// Noise Lab shader by candycat: https://www.shadertoy.com/view/4sc3z2\n//\n// Noise shaders by iq:\n//     Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n//     Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n//     Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n//     Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n//     Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n//     Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n//     Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n//     Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n//     Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n//     Voronoise: https://www.shadertoy.com/view/Xd23Dh\n//\n//\n//\n\n// discontinuous pseudorandom constly distributed in [-0.5, +0.5]^3 */\nvec3 XsX3zB_oct_random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n// skew constants for 3d simplex functions\nconst float XsX3zB_oct_F3 =  0.3333333;\nconst float XsX3zB_oct_G3 =  0.1666667;\n\n// 3d simplex noise\nfloat XsX3zB_oct_simplex3d(vec3 p) {\n\t // 1. find current tetrahedron T and it's four vertices\n\t // s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices\n\t // x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices\n\t \n\t // calculate s and x\n\t vec3 s = floor(p + dot(p, vec3(XsX3zB_oct_F3)));\n\t vec3 x = p - s + dot(s, vec3(XsX3zB_oct_G3));\n\t \n\t // calculate i1 and i2\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t // x1, x2, x3\n\t vec3 x1 = x - i1 + XsX3zB_oct_G3;\n\t vec3 x2 = x - i2 + 2.0*XsX3zB_oct_G3;\n\t vec3 x3 = x - 1.0 + 3.0*XsX3zB_oct_G3;\n\t \n\t // 2. find four surflets and store them in d\n\t vec4 w, d;\n\t \n\t // calculate surflet weights\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t // w fades from 0.6 at the center of the surflet to 0.0 at the margin\n\t w = max(0.6 - w, 0.0);\n\t \n\t // calculate surflet components\n\t d.x = dot(XsX3zB_oct_random3(s), x);\n\t d.y = dot(XsX3zB_oct_random3(s + i1), x1);\n\t d.z = dot(XsX3zB_oct_random3(s + i2), x2);\n\t d.w = dot(XsX3zB_oct_random3(s + 1.0), x3);\n\t \n\t // multiply d by w^4\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t // 3. return the sum of the four surflets\n\t return dot(d, vec4(52.0));\n}vec2 transform2_clamp(vec2 uv) {\n\treturn clamp(uv, vec2(0.0), vec2(1.0));\n}\n\nvec2 transform2(vec2 uv, vec2 translate, float rotate, vec2 scale) {\n \tvec2 rv;\n\tuv -= translate;\n\tuv -= vec2(0.5);\n\trv.x = cos(rotate)*uv.x + sin(rotate)*uv.y;\n\trv.y = -sin(rotate)*uv.x + cos(rotate)*uv.y;\n\trv /= scale;\n\trv += vec2(0.5);\n\treturn rv;\t\n}vec4 sdf3dc_union(vec4 a, vec4 b) {\n\treturn vec4((a.w<b.w)?vec4(a):vec4(b));\n}\nvec4 sdf3dc_sub(vec4 a, vec4 b) {\n\treturn vec4((-a.w>b.w)?vec4(a.xyz,-a.w):vec4(b));\n}\nvec4 sdf3dc_inter(vec4 a, vec4 b) {\n\treturn vec4((a.w>b.w)?vec4(a):vec4(b));\n}vec3 v4v4_rotate(vec3 p, vec3 a) {\n\tvec3 rv;\n\tfloat c;\n\tfloat s;\n\tc = cos(a.x);\n\ts = sin(a.x);\n\trv.x = p.x;\n\trv.y = p.y*c+p.z*s;\n\trv.z = -p.y*s+p.z*c;\n\tc = cos(a.y);\n\ts = sin(a.y);\n\tp.x = rv.x*c+rv.z*s;\n\tp.y = rv.y;\n\tp.z = -rv.x*s+rv.z*c;\n\tc = cos(a.z);\n\ts = sin(a.z);\n\trv.x = p.x*c+p.y*s;\n\trv.y = -p.x*s+p.y*c;\n\trv.z = p.z;\n\treturn rv;\n}\nvec4 MFSDF_Union(vec4 in1,vec4 in2,vec4 in3,vec4 in4,vec4 in5,vec4 in6,vec4 in7,vec4 in8){\n    vec4 t=(in1.w<in2.w)?vec4(in1):vec4(in2);\n    t=(t.w<in2.w)?vec4(t):vec4(in2);\n    t=(t.w<in3.w)?vec4(t):vec4(in3);\n    t=(t.w<in4.w)?vec4(t):vec4(in4);\n    t=(t.w<in5.w)?vec4(t):vec4(in5);\n    t=(t.w<in6.w)?vec4(t):vec4(in6);\n    t=(t.w<in7.w)?vec4(t):vec4(in7);\n    t=(t.w<in8.w)?vec4(t):vec4(in8);\n    return t;\n}\n\nfloat mfsdf3d_smooth_union_f(float a,float b,float k){\n\tfloat h = max( k-abs(a-b), 0.0 )/k;\n\treturn min(a,b)-h*h*k*0.25;\n}\n\nvec4 mfsdf3d_smooth_union(vec4 a, vec4 b, float k) {\n    float e=0.001;\n    k=max(k,e);\n    float h=mfsdf3d_smooth_union_f(a.w,b.w,k);\n\tvec2 n=normalize(vec2(mfsdf3d_smooth_union_f(a.w+e,b.w,k)-mfsdf3d_smooth_union_f(a.w-e,b.w,k),\n                          mfsdf3d_smooth_union_f(a.w,b.w+e,k)-mfsdf3d_smooth_union_f(a.w,b.w-e,k)));\n    return vec4(mix(a.xyz,b.xyz,atan(abs(n.y),abs(n.x))/(3.14159265359/2.0)),h);\n}\n\nfloat mfsdf3d_smooth_subtraction_f(float a,float b,float k){\n\tfloat h = max( k-abs(-a-b), 0.0 )/k;\n\treturn max(-a,b)+h*h*k*0.25;\n}\n\nvec4 mfsdf3d_smooth_subtraction(vec4 a, vec4 b, float k) {\n    float e=0.001;\n    k=max(k,e);\n\tfloat h=mfsdf3d_smooth_subtraction_f(a.w,b.w,k);\n\tvec2 n=normalize(vec2(mfsdf3d_smooth_subtraction_f(a.w+e,b.w,k)-mfsdf3d_smooth_subtraction_f(a.w-e,b.w,k),\n                          mfsdf3d_smooth_subtraction_f(a.w,b.w+e,k)-mfsdf3d_smooth_subtraction_f(a.w,b.w-e,k)));\n    return vec4(mix(a.xyz,b.xyz,atan(abs(n.y),abs(n.x))/(3.14159265359/2.0)),h);\n}\n\nfloat mfsdf3d_smooth_intersection_f(float a,float b,float k){\n\tfloat h = max( k-abs(a-b), 0.0 )/k;\n\treturn max(a,b)+h*h*k*0.25;\n}\n\nvec4 mfsdf3d_smooth_intersection(vec4 a, vec4 b, float k) {\n    float e=0.001;\n    k=max(k,e);\n\tfloat h=mfsdf3d_smooth_intersection_f(a.w,b.w,k);\n\tvec2 n=normalize(vec2(mfsdf3d_smooth_intersection_f(a.w+e,b.w,k)-mfsdf3d_smooth_intersection_f(a.w-e,b.w,k),\n                          mfsdf3d_smooth_intersection_f(a.w,b.w+e,k)-mfsdf3d_smooth_intersection_f(a.w,b.w-e,k)));\n    return vec4(mix(a.xyz,b.xyz,atan(abs(n.y),abs(n.x))/(3.14159265359/2.0)),h);\n}vec2 twist_rot(vec2 v, float a) {\n\ta=a*0.01745329251;\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(vec2(c, -s),vec2(s, c));\n\treturn m * v;\n}\n\nvec3 twistX(vec3 v, float a){\n\tv.yz=twist_rot(v.yz,v.x*a);\n\treturn v;\n}\n\nvec3 twistY(vec3 v, float a){\n\tv.xz=twist_rot(v.xz,v.y*a);\n\treturn v;\n}\n\nvec3 twistZ(vec3 v, float a){\n\tv.xy=twist_rot(v.xy,v.z*a);\n\treturn v;\n}\n\n\n//MATH\nconst float PI=3.14159265359;\nconst float TAU=6.28318530718;\n\nvec2 rndint_hash23(vec3 p3){\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvoid Onb(in vec3 N, inout vec3 T, inout vec3 B){\n    vec3 UpVector=abs(N.z)<0.999?vec3(0,0,1):vec3(1,0,0);\n    T=normalize(cross(UpVector,N));\n    B=cross(N,T);\n}\n\nvec2 equirectangularMap(vec3 dir) {\n\tvec2 longlat = vec2(atan(dir.y,dir.x),acos(dir.z));\n \treturn longlat/vec2(2.0*PI,PI);\n}\n\n// RANDOM START\n//from https://www.reedbeta.com/blog/hash-functions-for-gpu-rendering/\nuint rand_pcg(inout uint seed){\n    uint state = seed;\n    seed = seed * uint(747796405) + uint(2891336453);\n    uint word = ((state >> ((state >> uint(28)) + uint(4))) ^ state) * uint(277803737);\n    return (word >> uint(22)) ^ word;\n}\n\nfloat RandomFloat01(inout uint state){\n    uint r=rand_pcg(state);\n    r &= uint(0x007FFFFF);\n    r |= uint(0x3F800000);\n    return uintBitsToFloat(r) - 1.0f;\n}\n\n// RANDOM END\n\n// SAMPLING START\n\nvec3 constSampleSphere(float r1,float r2){\n    float z=1.0-2.0*r1;\n    float r=sqrt(max(0.0,1.0-z*z));\n    float phi=TAU*r2;\n    return vec3(r*cos(phi),r*sin(phi),z);\n}\n\nvec3 cosineSampleHemissphere(inout uint state,vec3 n){\n    float u1=RandomFloat01(state);\n    float u2=RandomFloat01(state);\n    return normalize(n+constSampleSphere(u1,u2)); \n}\n\n// Adapted from \"Sampling the GGX Distribution of Visible Normals\",\n// http://jcgt.org/published/0007/04/01/\nvec3 SampleGGXVNDF(inout uint state,vec3 Ve,float alpha_x,float alpha_y){\n    float U1=RandomFloat01(state);\n    float U2=RandomFloat01(state);\n    \n    //transforming the view direction to the hemisphere configuration\n    vec3 Vh = normalize(vec3(alpha_x * Ve.x, alpha_y * Ve.y, Ve.z));\n\n    //orthonormal basis\n    vec3 T1;vec3 T2;\n    Onb(Vh,T1,T2);\n\n    //parameterization of the projected area\n    float r = sqrt(U1); \n    float phi = 2.0 * PI * U2;    \n    float t1 = r * cos(phi);\n    float t2 = r * sin(phi);\n    float s = 0.5 * (1.0 + Vh.z);\n    t2 = (1.0 - s)*sqrt(1.0 - t1*t1) + s*t2;\n\n    //reprojection onto hemisphere\n    vec3 Nh = t1*T1 + t2*T2 + sqrt(max(0.0f, 1.0f - t1*t1 - t2*t2))*Vh;\n\n    //transforming the normal back to the ellipsoid configuration\n    vec3 Ne = normalize(vec3(alpha_x * Nh.x, alpha_y * Nh.y, max(0.0f, Nh.z))); \n\n    return Ne;\n}\n\nfloat schlickWeight(float cosTheta) {\n    float m=clamp(1.-cosTheta,0.,1.);\n    float m2=m*m;\n    return m2*m2*m;\n}\n\n// SAMPLING END\n\nconst float p_o9000_CamX = -3.601000000;\nconst float p_o9000_CamY = 1.628000000;\nconst float p_o9000_CamZ = 2.873000000;\nconst float p_o9000_LookAtX = 1.984000000;\nconst float p_o9000_LookAtY = 1.247000000;\nconst float p_o9000_LookAtZ = -0.406000000;\nconst float p_o9000_CamD = 1.133000000;\nconst float p_o9000_CamZoom = 1.000000000;\nconst float p_o9000_MaxDistance = 15.000000000;\nconst float p_o218686_BaseColor_r = 1.000000000;\nconst float p_o218686_BaseColor_g = 1.000000000;\nconst float p_o218686_BaseColor_b = 1.000000000;\nconst float p_o218686_BaseColor_a = 1.000000000;\nconst float p_o218686_Metallic = 0.000000000;\nconst float p_o218686_Specular = 0.500000000;\nconst float p_o218686_Roughness = 0.000000000;\nconst float p_o218686_Emission = 10.000000000;\nconst float p_o218686_Normal = 0.000000000;\nconst float p_o218686_Alpha = 0.000000000;\nconst float p_o218686_AmbientOcclusion = 0.000000000;\nconst float p_o218686_scale = 1.000000000;\nconst float p_o218686_TranlateX = 0.000000000;\nconst float p_o218686_TranlateY = 3.512000000;\nconst float p_o218686_TranlateZ = 0.000000000;\nconst float p_o218686_RotateX = 0.000000000;\nconst float p_o218686_RotateY = 0.250000000;\nconst float p_o218686_RotateZ = 0.000000000;\nvec3 o218686_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nfloat o218686_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o218686_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o218686_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o218686_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o218686_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o218686_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o218686_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o124018_X = 1.000000000;\nconst float p_o124018_Y = 1.000000000;\nconst float p_o124018_Z = 0.400000006;\nconst float p_o124018_RepX = 1.000000000;\nconst float p_o124018_RepY = 1.000000000;\nconst float p_o124018_RepZ = 6.000000000;\nconst float p_o98976_l = 2.880000000;\nconst float p_o98976_r = 0.120000000;\nfloat o218686_input_sdf3d(vec3 p, float _seed_variation_) {\nvec2 o98976_0_d = abs(vec2(length((opRepLim((p),vec3(p_o124018_X,p_o124018_Y,p_o124018_Z)*2.0,vec3(p_o124018_RepX-1.0,p_o124018_RepY-1.0,p_o124018_RepZ-1.0))).yz),(opRepLim((p),vec3(p_o124018_X,p_o124018_Y,p_o124018_Z)*2.0,vec3(p_o124018_RepX-1.0,p_o124018_RepY-1.0,p_o124018_RepZ-1.0))).x)) - vec2(p_o98976_r,p_o98976_l);\nfloat o98976_0_1_sdf3d = min(max(o98976_0_d.x,o98976_0_d.y),0.0) + length(max(o98976_0_d,0.0));\nfloat o124018_0_1_sdf3d = o98976_0_1_sdf3d;\n\nreturn o124018_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o218686(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o218686_TranlateX,p_o218686_TranlateY,p_o218686_TranlateZ),vec3(p_o218686_RotateX,p_o218686_RotateY,p_o218686_RotateZ)*6.28318530718)/p_o218686_scale;\n\tfloat sdf=o218686_input_sdf3d(uv.xyz, _seed_variation_)*p_o218686_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o218686_AmbientOcclusion*o218686_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o218686_Alpha*o218686_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o218686_Normal*o218686_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o218686_Emission*o218686_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o218686_Roughness*o218686_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o218686_Specular*o218686_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o218686_Metallic*o218686_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o218686_BaseColor_r, p_o218686_BaseColor_g, p_o218686_BaseColor_b, p_o218686_BaseColor_a).rgb*o218686_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}const float p_o2324410_x = 3.701340000;\nconst float p_o2324410_y = 0.000000000;\nconst float p_o2324410_z = 0.000000000;\nconst float p_o2041939_BaseColor_r = 1.000000000;\nconst float p_o2041939_BaseColor_g = 1.000000000;\nconst float p_o2041939_BaseColor_b = 1.000000000;\nconst float p_o2041939_BaseColor_a = 1.000000000;\nconst float p_o2041939_Metallic = 0.705000000;\nconst float p_o2041939_Specular = 0.373000000;\nconst float p_o2041939_Roughness = 1.000000000;\nconst float p_o2041939_Emission = 0.000000000;\nconst float p_o2041939_Normal = 0.000000000;\nconst float p_o2041939_Alpha = 0.000000000;\nconst float p_o2041939_AmbientOcclusion = 0.000000000;\nconst float p_o2041939_scale = 1.000000000;\nconst float p_o2041939_TranlateX = 0.000000000;\nconst float p_o2041939_TranlateY = 0.000000000;\nconst float p_o2041939_TranlateZ = 0.000000000;\nconst float p_o2041939_RotateX = 0.000000000;\nconst float p_o2041939_RotateY = 0.000000000;\nconst float p_o2041939_RotateZ = 0.000000000;\nconst float p_o4023618_translate_x = -0.530000000;\nconst float p_o4023618_translate_y = -0.010000000;\nconst float p_o3686881_translate_x = 6.470000000;\nconst float p_o3686881_translate_y = 3.123150000;\nconst float p_o3686881_rotate = 197.957800000;\nconst float p_o3686881_scale_x = 1.000000000;\nconst float p_o3686881_scale_y = 1.000000000;\nconst float seed_o3686879 = 0.692989000;\nconst float p_o3686879_repeat = 1.000000000;\nconst float p_o3686879_rows = 1.929999948;\nconst float p_o3686879_columns = 1.929999948;\nconst float p_o3686879_row_offset = 1.000000000;\nconst float p_o3686879_mortar = 0.000000000;\nconst float p_o3686879_bevel = 0.000000000;\nconst float p_o3686879_round = 0.000000000;\nconst float p_o3686879_corner = 0.000000000;\nconst float p_o3686880_f = 0.000000000;\nconst float p_o3686863_g_0_pos = 0.190909000;\nconst float p_o3686863_g_0_r = 1.000000000;\nconst float p_o3686863_g_0_g = 1.000000000;\nconst float p_o3686863_g_0_b = 1.000000000;\nconst float p_o3686863_g_0_a = 1.000000000;\nconst float p_o3686863_g_1_pos = 0.390909000;\nconst float p_o3686863_g_1_r = 0.507812977;\nconst float p_o3686863_g_1_g = 0.451000005;\nconst float p_o3686863_g_1_b = 0.353087991;\nconst float p_o3686863_g_1_a = 1.000000000;\nconst float p_o3686863_g_2_pos = 0.663636000;\nconst float p_o3686863_g_2_r = 1.000000000;\nconst float p_o3686863_g_2_g = 1.000000000;\nconst float p_o3686863_g_2_b = 1.000000000;\nconst float p_o3686863_g_2_a = 1.000000000;\nvec4 o3686863_g_gradient_fct(float x) {\n  if (x < p_o3686863_g_0_pos) {\n    return vec4(p_o3686863_g_0_r,p_o3686863_g_0_g,p_o3686863_g_0_b,p_o3686863_g_0_a);\n  } else if (x < p_o3686863_g_1_pos) {\n    return mix(vec4(p_o3686863_g_0_r,p_o3686863_g_0_g,p_o3686863_g_0_b,p_o3686863_g_0_a), vec4(p_o3686863_g_1_r,p_o3686863_g_1_g,p_o3686863_g_1_b,p_o3686863_g_1_a), ((x-p_o3686863_g_0_pos)/(p_o3686863_g_1_pos-p_o3686863_g_0_pos)));\n  } else if (x < p_o3686863_g_2_pos) {\n    return mix(vec4(p_o3686863_g_1_r,p_o3686863_g_1_g,p_o3686863_g_1_b,p_o3686863_g_1_a), vec4(p_o3686863_g_2_r,p_o3686863_g_2_g,p_o3686863_g_2_b,p_o3686863_g_2_a), ((x-p_o3686863_g_1_pos)/(p_o3686863_g_2_pos-p_o3686863_g_1_pos)));\n  }\n  return vec4(p_o3686863_g_2_r,p_o3686863_g_2_g,p_o3686863_g_2_b,p_o3686863_g_2_a);\n}\nconst float p_o3686856_scale = 5.635000000;\nconst float p_o3686856_scale_x = 1.000000000;\nconst float p_o3686856_scale_y = 1.000000000;\nconst float p_o3686856_scale_z = 1.000000000;\nconst float p_o3686856_transx = 0.000000000;\nconst float p_o3686856_transy = 0.000000000;\nconst float p_o3686856_transz = 0.000000000;\nconst float p_o3686856_persistence = 0.500000000;\nconst float p_o3686856_brightness = 0.000000000;\nconst float p_o3686856_contrast = 7.556000000;\nfloat o3686856_fbm(vec3 coord, float persistence, float _seed_variation_) {\n\tfloat normalize_factor = 0.0;\n\tfloat value = 0.0;\n\tfloat scale = 1.0;\n\tfloat size = 1.0;\n\tfor (int i = 0; i < 6; i++) {\n\t\tvalue += XsX3zB_oct_simplex3d(coord*size) * scale;\n\t\tnormalize_factor += scale;\n\t\tsize *= 2.0;\n\t\tscale *= persistence;\n\t}\n\treturn value / normalize_factor;\n}\n\nfloat o3686856_bc(float f,float contrast, float brightness, float _seed_variation_) {\n\treturn f*contrast+brightness+0.5-contrast*0.5;\n}\nvec3 o2041939_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\nvec4 o3686879_0_rect = bricks_rb((((p).yz+vec2(0.5))-vec2(p_o4023618_translate_x, p_o4023618_translate_y)), vec2(p_o3686879_columns, p_o3686879_rows), p_o3686879_repeat, p_o3686879_row_offset);\nvec4 o3686879_0 = brick((((p).yz+vec2(0.5))-vec2(p_o4023618_translate_x, p_o4023618_translate_y)), o3686879_0_rect.xy, o3686879_0_rect.zw, p_o3686879_mortar*1.0, p_o3686879_round*1.0, max(0.001, p_o3686879_bevel*1.0));\nvec3 o3686879_1_2_rgb = brick_random_color(o3686879_0_rect.xy, o3686879_0_rect.zw, float((seed_o3686879+_seed_variation_)));\nvec3 o3686856_0_out = vec3(o3686856_bc(o3686856_fbm((vec3(p_o3686880_f,(transform2((((p).yz+vec2(0.5))-vec2(p_o4023618_translate_x, p_o4023618_translate_y)), vec2(p_o3686881_translate_x*(2.0*(dot(o3686879_1_2_rgb, vec3(1.0))/3.0)-1.0), p_o3686881_translate_y*(2.0*(dot(o3686879_1_2_rgb, vec3(1.0))/3.0)-1.0)), p_o3686881_rotate*0.01745329251*(2.0*(dot(o3686879_1_2_rgb, vec3(1.0))/3.0)-1.0), vec2(p_o3686881_scale_x*(2.0*1.0-1.0), p_o3686881_scale_y*(2.0*1.0-1.0)))).x,(transform2((((p).yz+vec2(0.5))-vec2(p_o4023618_translate_x, p_o4023618_translate_y)), vec2(p_o3686881_translate_x*(2.0*(dot(o3686879_1_2_rgb, vec3(1.0))/3.0)-1.0), p_o3686881_translate_y*(2.0*(dot(o3686879_1_2_rgb, vec3(1.0))/3.0)-1.0)), p_o3686881_rotate*0.01745329251*(2.0*(dot(o3686879_1_2_rgb, vec3(1.0))/3.0)-1.0), vec2(p_o3686881_scale_x*(2.0*1.0-1.0), p_o3686881_scale_y*(2.0*1.0-1.0)))).y)).xyz*vec3(p_o3686856_scale_x,p_o3686856_scale_y,p_o3686856_scale_z)*0.5*p_o3686856_scale+vec3(p_o3686856_transx,p_o3686856_transy,p_o3686856_transz),p_o3686856_persistence, _seed_variation_)*0.5+0.5,p_o3686856_contrast,p_o3686856_brightness, _seed_variation_));vec3 o3686856_0_1_tex3d = clamp(o3686856_0_out,vec3(0),vec3(1));\nvec3 o3686863_0_1_tex3d = o3686863_g_gradient_fct(dot(o3686856_0_1_tex3d, vec3(1.0))/3.0).rgb;\nvec3 o3686880_0_1_rgb = o3686863_0_1_tex3d.rgb;\nvec4 o3686881_0_1_rgba = vec4(o3686880_0_1_rgb, 1.0);\nvec4 o4023618_0_1_rgba = o3686881_0_1_rgba;\nvec3 o3708592_0_1_tex3d = ((o4023618_0_1_rgba).rgb);\n\nreturn o3708592_0_1_tex3d;\n}\nfloat o2041939_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o2041939_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o4438403_g_0_pos = 0.000000000;\nconst float p_o4438403_g_0_r = 1.000000000;\nconst float p_o4438403_g_0_g = 1.000000000;\nconst float p_o4438403_g_0_b = 1.000000000;\nconst float p_o4438403_g_0_a = 1.000000000;\nconst float p_o4438403_g_1_pos = 1.000000000;\nconst float p_o4438403_g_1_r = 0.000000000;\nconst float p_o4438403_g_1_g = 0.000000000;\nconst float p_o4438403_g_1_b = 0.000000000;\nconst float p_o4438403_g_1_a = 1.000000000;\nvec4 o4438403_g_gradient_fct(float x) {\n  if (x < p_o4438403_g_0_pos) {\n    return vec4(p_o4438403_g_0_r,p_o4438403_g_0_g,p_o4438403_g_0_b,p_o4438403_g_0_a);\n  } else if (x < p_o4438403_g_1_pos) {\n    return mix(vec4(p_o4438403_g_0_r,p_o4438403_g_0_g,p_o4438403_g_0_b,p_o4438403_g_0_a), vec4(p_o4438403_g_1_r,p_o4438403_g_1_g,p_o4438403_g_1_b,p_o4438403_g_1_a), ((x-p_o4438403_g_0_pos)/(p_o4438403_g_1_pos-p_o4438403_g_0_pos)));\n  }\n  return vec4(p_o4438403_g_1_r,p_o4438403_g_1_g,p_o4438403_g_1_b,p_o4438403_g_1_a);\n}\nfloat o2041939_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\nvec4 o3686879_0_rect = bricks_rb((((p).yz+vec2(0.5))-vec2(p_o4023618_translate_x, p_o4023618_translate_y)), vec2(p_o3686879_columns, p_o3686879_rows), p_o3686879_repeat, p_o3686879_row_offset);\nvec4 o3686879_0 = brick((((p).yz+vec2(0.5))-vec2(p_o4023618_translate_x, p_o4023618_translate_y)), o3686879_0_rect.xy, o3686879_0_rect.zw, p_o3686879_mortar*1.0, p_o3686879_round*1.0, max(0.001, p_o3686879_bevel*1.0));\nvec3 o3686879_1_2_rgb = brick_random_color(o3686879_0_rect.xy, o3686879_0_rect.zw, float((seed_o3686879+_seed_variation_)));\nvec3 o3686856_0_out = vec3(o3686856_bc(o3686856_fbm((vec3(p_o3686880_f,(transform2((((p).yz+vec2(0.5))-vec2(p_o4023618_translate_x, p_o4023618_translate_y)), vec2(p_o3686881_translate_x*(2.0*(dot(o3686879_1_2_rgb, vec3(1.0))/3.0)-1.0), p_o3686881_translate_y*(2.0*(dot(o3686879_1_2_rgb, vec3(1.0))/3.0)-1.0)), p_o3686881_rotate*0.01745329251*(2.0*(dot(o3686879_1_2_rgb, vec3(1.0))/3.0)-1.0), vec2(p_o3686881_scale_x*(2.0*1.0-1.0), p_o3686881_scale_y*(2.0*1.0-1.0)))).x,(transform2((((p).yz+vec2(0.5))-vec2(p_o4023618_translate_x, p_o4023618_translate_y)), vec2(p_o3686881_translate_x*(2.0*(dot(o3686879_1_2_rgb, vec3(1.0))/3.0)-1.0), p_o3686881_translate_y*(2.0*(dot(o3686879_1_2_rgb, vec3(1.0))/3.0)-1.0)), p_o3686881_rotate*0.01745329251*(2.0*(dot(o3686879_1_2_rgb, vec3(1.0))/3.0)-1.0), vec2(p_o3686881_scale_x*(2.0*1.0-1.0), p_o3686881_scale_y*(2.0*1.0-1.0)))).y)).xyz*vec3(p_o3686856_scale_x,p_o3686856_scale_y,p_o3686856_scale_z)*0.5*p_o3686856_scale+vec3(p_o3686856_transx,p_o3686856_transy,p_o3686856_transz),p_o3686856_persistence, _seed_variation_)*0.5+0.5,p_o3686856_contrast,p_o3686856_brightness, _seed_variation_));vec3 o3686856_0_1_tex3d = clamp(o3686856_0_out,vec3(0),vec3(1));\nvec3 o3686863_0_1_tex3d = o3686863_g_gradient_fct(dot(o3686856_0_1_tex3d, vec3(1.0))/3.0).rgb;\nvec3 o3686880_0_1_rgb = o3686863_0_1_tex3d.rgb;\nvec4 o3686881_0_1_rgba = vec4(o3686880_0_1_rgb, 1.0);\nvec4 o4023618_0_1_rgba = o3686881_0_1_rgba;\nvec3 o3708592_0_1_tex3d = ((o4023618_0_1_rgba).rgb);\nvec3 o4438403_0_1_tex3d = o4438403_g_gradient_fct(dot(o3708592_0_1_tex3d, vec3(1.0))/3.0).rgb;\n\nreturn (dot(o4438403_0_1_tex3d, vec3(1.0))/3.0);\n}\nvec3 o2041939_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o2041939_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o2041939_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o2041939_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o2059617_X = 1.000000000;\nconst float p_o2059617_Y = 0.259999990;\nconst float p_o2059617_Z = 0.259999990;\nconst float p_o2059617_RepX = 1.000000000;\nconst float p_o2059617_RepY = 24.000000000;\nconst float p_o2059617_RepZ = 24.000000000;\nconst float p_o2052732_sx = 0.050000001;\nconst float p_o2052732_sy = 0.234999999;\nconst float p_o2052732_sz = 0.234999999;\nconst float p_o2052732_r = 0.020000000;\nfloat o2041939_input_sdf3d(vec3 p, float _seed_variation_) {\nvec3 o2052732_0_q = abs((opRepLim((p),vec3(p_o2059617_X,p_o2059617_Y,p_o2059617_Z)*2.0,vec3(p_o2059617_RepX-1.0,p_o2059617_RepY-1.0,p_o2059617_RepZ-1.0)))) - vec3(p_o2052732_sx, p_o2052732_sy, p_o2052732_sz);\nfloat o2052732_0_1_sdf3d = length(max(o2052732_0_q,0.0))+min(max(o2052732_0_q.x,max(o2052732_0_q.y,o2052732_0_q.z)),0.0)-p_o2052732_r;\nfloat o2059617_0_1_sdf3d = o2052732_0_1_sdf3d;\n\nreturn o2059617_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o2041939(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o2041939_TranlateX,p_o2041939_TranlateY,p_o2041939_TranlateZ),vec3(p_o2041939_RotateX,p_o2041939_RotateY,p_o2041939_RotateZ)*6.28318530718)/p_o2041939_scale;\n\tfloat sdf=o2041939_input_sdf3d(uv.xyz, _seed_variation_)*p_o2041939_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o2041939_AmbientOcclusion*o2041939_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o2041939_Alpha*o2041939_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o2041939_Normal*o2041939_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o2041939_Emission*o2041939_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o2041939_Roughness*o2041939_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o2041939_Specular*o2041939_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o2041939_Metallic*o2041939_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o2041939_BaseColor_r, p_o2041939_BaseColor_g, p_o2041939_BaseColor_b, p_o2041939_BaseColor_a).rgb*o2041939_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}const float p_o2245524_x = -0.049000000;\nconst float p_o2245524_y = 0.000000000;\nconst float p_o2245524_z = 0.000000000;\nconst float p_o2195793_BaseColor_r = 0.324218750;\nconst float p_o2195793_BaseColor_g = 0.324218750;\nconst float p_o2195793_BaseColor_b = 0.324218750;\nconst float p_o2195793_BaseColor_a = 1.000000000;\nconst float p_o2195793_Metallic = 0.000000000;\nconst float p_o2195793_Specular = 0.000000000;\nconst float p_o2195793_Roughness = 1.000000000;\nconst float p_o2195793_Emission = 0.000000000;\nconst float p_o2195793_Normal = 0.000000000;\nconst float p_o2195793_Alpha = 0.000000000;\nconst float p_o2195793_AmbientOcclusion = 0.000000000;\nconst float p_o2195793_scale = 1.000000000;\nconst float p_o2195793_TranlateX = 0.000000000;\nconst float p_o2195793_TranlateY = 0.000000000;\nconst float p_o2195793_TranlateZ = 0.000000000;\nconst float p_o2195793_RotateX = 0.000000000;\nconst float p_o2195793_RotateY = 0.000000000;\nconst float p_o2195793_RotateZ = 0.000000000;\nvec3 o2195793_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nfloat o2195793_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o2195793_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o2195793_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o2195793_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o2195793_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o2195793_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o2195793_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o2198975_sx = 0.000000000;\nconst float p_o2198975_sy = 6.270000000;\nconst float p_o2198975_sz = 6.140000000;\nconst float p_o2198975_r = 0.000000000;\nfloat o2195793_input_sdf3d(vec3 p, float _seed_variation_) {\nvec3 o2198975_0_q = abs((p)) - vec3(p_o2198975_sx, p_o2198975_sy, p_o2198975_sz);\nfloat o2198975_0_1_sdf3d = length(max(o2198975_0_q,0.0))+min(max(o2198975_0_q.x,max(o2198975_0_q.y,o2198975_0_q.z)),0.0)-p_o2198975_r;\n\nreturn o2198975_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o2195793(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o2195793_TranlateX,p_o2195793_TranlateY,p_o2195793_TranlateZ),vec3(p_o2195793_RotateX,p_o2195793_RotateY,p_o2195793_RotateZ)*6.28318530718)/p_o2195793_scale;\n\tfloat sdf=o2195793_input_sdf3d(uv.xyz, _seed_variation_)*p_o2195793_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o2195793_AmbientOcclusion*o2195793_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o2195793_Alpha*o2195793_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o2195793_Normal*o2195793_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o2195793_Emission*o2195793_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o2195793_Roughness*o2195793_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o2195793_Specular*o2195793_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o2195793_Metallic*o2195793_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o2195793_BaseColor_r, p_o2195793_BaseColor_g, p_o2195793_BaseColor_b, p_o2195793_BaseColor_a).rgb*o2195793_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}const float p_o4750441_ax = 0.000000000;\nconst float p_o4750441_ay = 90.000000000;\nconst float p_o4750441_az = 0.000000000;\nconst float p_o4792380_BaseColor_r = 1.000000000;\nconst float p_o4792380_BaseColor_g = 1.000000000;\nconst float p_o4792380_BaseColor_b = 1.000000000;\nconst float p_o4792380_BaseColor_a = 1.000000000;\nconst float p_o4792380_Metallic = 0.000000000;\nconst float p_o4792380_Specular = 0.000000000;\nconst float p_o4792380_Roughness = 1.000000000;\nconst float p_o4792380_Emission = 0.000000000;\nconst float p_o4792380_Normal = 0.000000000;\nconst float p_o4792380_Alpha = 0.000000000;\nconst float p_o4792380_AmbientOcclusion = 0.000000000;\nconst float p_o4792380_scale = 1.000000000;\nconst float p_o4792380_TranlateX = 0.000000000;\nconst float p_o4792380_TranlateY = 4.420000000;\nconst float p_o4792380_TranlateZ = 0.000000000;\nconst float p_o4792380_RotateX = 0.000000000;\nconst float p_o4792380_RotateY = 0.000000000;\nconst float p_o4792380_RotateZ = 0.000000000;\nvec3 o4792380_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nfloat o4792380_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o4792380_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o4792380_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o4792380_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o4792380_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o4792380_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o4792380_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o4794342_sx = 4.250000000;\nconst float p_o4794342_sy = 0.250000000;\nconst float p_o4794342_sz = 4.010000000;\nconst float p_o4794342_r = 0.010000000;\nfloat o4792380_input_sdf3d(vec3 p, float _seed_variation_) {\nvec3 o4794342_0_q = abs((p)) - vec3(p_o4794342_sx, p_o4794342_sy, p_o4794342_sz);\nfloat o4794342_0_1_sdf3d = length(max(o4794342_0_q,0.0))+min(max(o4794342_0_q.x,max(o4794342_0_q.y,o4794342_0_q.z)),0.0)-p_o4794342_r;\n\nreturn o4794342_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o4792380(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o4792380_TranlateX,p_o4792380_TranlateY,p_o4792380_TranlateZ),vec3(p_o4792380_RotateX,p_o4792380_RotateY,p_o4792380_RotateZ)*6.28318530718)/p_o4792380_scale;\n\tfloat sdf=o4792380_input_sdf3d(uv.xyz, _seed_variation_)*p_o4792380_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o4792380_AmbientOcclusion*o4792380_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o4792380_Alpha*o4792380_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o4792380_Normal*o4792380_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o4792380_Emission*o4792380_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o4792380_Roughness*o4792380_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o4792380_Specular*o4792380_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o4792380_Metallic*o4792380_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o4792380_BaseColor_r, p_o4792380_BaseColor_g, p_o4792380_BaseColor_b, p_o4792380_BaseColor_a).rgb*o4792380_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}const float p_o5016891_x = 0.000000000;\nconst float p_o5016891_y = -0.119530000;\nconst float p_o5016891_z = 0.000000000;\nconst float p_o5036184_xyz = 1.785000000;\nconst float p_o5036184_x = 1.000000000;\nconst float p_o5036184_y = 1.000000000;\nconst float p_o5036184_z = 1.000000000;\nconst float p_o5009315_ax = 0.000000000;\nconst float p_o5009315_ay = 90.000000000;\nconst float p_o5009315_az = 90.000000000;\nconst float p_o4939319_BaseColor_r = 1.000000000;\nconst float p_o4939319_BaseColor_g = 1.000000000;\nconst float p_o4939319_BaseColor_b = 1.000000000;\nconst float p_o4939319_BaseColor_a = 1.000000000;\nconst float p_o4939319_Metallic = 0.705000000;\nconst float p_o4939319_Specular = 0.917000000;\nconst float p_o4939319_Roughness = 1.000000000;\nconst float p_o4939319_Emission = 0.000000000;\nconst float p_o4939319_Normal = 0.000000000;\nconst float p_o4939319_Alpha = 0.000000000;\nconst float p_o4939319_AmbientOcclusion = 0.000000000;\nconst float p_o4939319_scale = 1.000000000;\nconst float p_o4939319_TranlateX = 0.000000000;\nconst float p_o4939319_TranlateY = 0.000000000;\nconst float p_o4939319_TranlateZ = 0.000000000;\nconst float p_o4939319_RotateX = 0.000000000;\nconst float p_o4939319_RotateY = 0.000000000;\nconst float p_o4939319_RotateZ = 0.000000000;\nconst float p_o4939301_translate_x = -0.530000000;\nconst float p_o4939301_translate_y = -0.010000000;\nconst float p_o4939295_translate_x = 2.180000000;\nconst float p_o4939295_translate_y = 4.575000000;\nconst float p_o4939295_rotate = 456.220000000;\nconst float p_o4939295_scale_x = 1.000000000;\nconst float p_o4939295_scale_y = 1.000000000;\nconst float seed_o4939292 = 0.692989000;\nconst float p_o4939292_repeat = 1.000000000;\nconst float p_o4939292_rows = 1.930000000;\nconst float p_o4939292_columns = 1.930000000;\nconst float p_o4939292_row_offset = 1.000000000;\nconst float p_o4939292_mortar = 0.000000000;\nconst float p_o4939292_bevel = 0.000000000;\nconst float p_o4939292_round = 0.000000000;\nconst float p_o4939292_corner = 0.000000000;\nconst float p_o4939289_f = 0.000000000;\nconst float p_o4939273_g_0_pos = 0.081110174;\nconst float p_o4939273_g_0_r = 0.000000000;\nconst float p_o4939273_g_0_g = 0.000000000;\nconst float p_o4939273_g_0_b = 0.000000000;\nconst float p_o4939273_g_0_a = 1.000000000;\nconst float p_o4939273_g_1_pos = 0.390908987;\nconst float p_o4939273_g_1_r = 0.796875000;\nconst float p_o4939273_g_1_g = 0.604830265;\nconst float p_o4939273_g_1_b = 0.333068848;\nconst float p_o4939273_g_1_a = 1.000000000;\nconst float p_o4939273_g_2_pos = 0.772018918;\nconst float p_o4939273_g_2_r = 0.000000000;\nconst float p_o4939273_g_2_g = 0.000000000;\nconst float p_o4939273_g_2_b = 0.000000000;\nconst float p_o4939273_g_2_a = 1.000000000;\nvec4 o4939273_g_gradient_fct(float x) {\n  if (x < p_o4939273_g_0_pos) {\n    return vec4(p_o4939273_g_0_r,p_o4939273_g_0_g,p_o4939273_g_0_b,p_o4939273_g_0_a);\n  } else if (x < p_o4939273_g_1_pos) {\n    return mix(vec4(p_o4939273_g_0_r,p_o4939273_g_0_g,p_o4939273_g_0_b,p_o4939273_g_0_a), vec4(p_o4939273_g_1_r,p_o4939273_g_1_g,p_o4939273_g_1_b,p_o4939273_g_1_a), ((x-p_o4939273_g_0_pos)/(p_o4939273_g_1_pos-p_o4939273_g_0_pos)));\n  } else if (x < p_o4939273_g_2_pos) {\n    return mix(vec4(p_o4939273_g_1_r,p_o4939273_g_1_g,p_o4939273_g_1_b,p_o4939273_g_1_a), vec4(p_o4939273_g_2_r,p_o4939273_g_2_g,p_o4939273_g_2_b,p_o4939273_g_2_a), ((x-p_o4939273_g_1_pos)/(p_o4939273_g_2_pos-p_o4939273_g_1_pos)));\n  }\n  return vec4(p_o4939273_g_2_r,p_o4939273_g_2_g,p_o4939273_g_2_b,p_o4939273_g_2_a);\n}\nconst float p_o4939254_scale = 2.706000000;\nconst float p_o4939254_scale_x = 1.000000000;\nconst float p_o4939254_scale_y = 1.000000000;\nconst float p_o4939254_scale_z = 1.000000000;\nconst float p_o4939254_transx = 0.000000000;\nconst float p_o4939254_transy = 0.000000000;\nconst float p_o4939254_transz = 0.000000000;\nconst float p_o4939254_persistence = 0.500000000;\nconst float p_o4939254_brightness = 0.000000000;\nconst float p_o4939254_contrast = 14.000000000;\nfloat o4939254_fbm(vec3 coord, float persistence, float _seed_variation_) {\n\tfloat normalize_factor = 0.0;\n\tfloat value = 0.0;\n\tfloat scale = 1.0;\n\tfloat size = 1.0;\n\tfor (int i = 0; i < 12; i++) {\n\t\tvalue += XsX3zB_oct_simplex3d(coord*size) * scale;\n\t\tnormalize_factor += scale;\n\t\tsize *= 2.0;\n\t\tscale *= persistence;\n\t}\n\treturn value / normalize_factor;\n}\n\nfloat o4939254_bc(float f,float contrast, float brightness, float _seed_variation_) {\n\treturn f*contrast+brightness+0.5-contrast*0.5;\n}\nvec3 o4939319_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\nvec4 o4939292_0_rect = bricks_rb((((p).yz+vec2(0.5))-vec2(p_o4939301_translate_x, p_o4939301_translate_y)), vec2(p_o4939292_columns, p_o4939292_rows), p_o4939292_repeat, p_o4939292_row_offset);\nvec4 o4939292_0 = brick((((p).yz+vec2(0.5))-vec2(p_o4939301_translate_x, p_o4939301_translate_y)), o4939292_0_rect.xy, o4939292_0_rect.zw, p_o4939292_mortar*1.0, p_o4939292_round*1.0, max(0.001, p_o4939292_bevel*1.0));\nvec3 o4939292_1_2_rgb = brick_random_color(o4939292_0_rect.xy, o4939292_0_rect.zw, float((seed_o4939292+_seed_variation_)));\nvec3 o4939254_0_out = vec3(o4939254_bc(o4939254_fbm((vec3(p_o4939289_f,(transform2((((p).yz+vec2(0.5))-vec2(p_o4939301_translate_x, p_o4939301_translate_y)), vec2(p_o4939295_translate_x*(2.0*(dot(o4939292_1_2_rgb, vec3(1.0))/3.0)-1.0), p_o4939295_translate_y*(2.0*(dot(o4939292_1_2_rgb, vec3(1.0))/3.0)-1.0)), p_o4939295_rotate*0.01745329251*(2.0*(dot(o4939292_1_2_rgb, vec3(1.0))/3.0)-1.0), vec2(p_o4939295_scale_x*(2.0*1.0-1.0), p_o4939295_scale_y*(2.0*1.0-1.0)))).x,(transform2((((p).yz+vec2(0.5))-vec2(p_o4939301_translate_x, p_o4939301_translate_y)), vec2(p_o4939295_translate_x*(2.0*(dot(o4939292_1_2_rgb, vec3(1.0))/3.0)-1.0), p_o4939295_translate_y*(2.0*(dot(o4939292_1_2_rgb, vec3(1.0))/3.0)-1.0)), p_o4939295_rotate*0.01745329251*(2.0*(dot(o4939292_1_2_rgb, vec3(1.0))/3.0)-1.0), vec2(p_o4939295_scale_x*(2.0*1.0-1.0), p_o4939295_scale_y*(2.0*1.0-1.0)))).y)).xyz*vec3(p_o4939254_scale_x,p_o4939254_scale_y,p_o4939254_scale_z)*0.5*p_o4939254_scale+vec3(p_o4939254_transx,p_o4939254_transy,p_o4939254_transz),p_o4939254_persistence, _seed_variation_)*0.5+0.5,p_o4939254_contrast,p_o4939254_brightness, _seed_variation_));vec3 o4939254_0_1_tex3d = clamp(o4939254_0_out,vec3(0),vec3(1));\nvec3 o4939273_0_1_tex3d = o4939273_g_gradient_fct(dot(o4939254_0_1_tex3d, vec3(1.0))/3.0).rgb;\nvec3 o4939289_0_1_rgb = o4939273_0_1_tex3d.rgb;\nvec4 o4939295_0_1_rgba = vec4(o4939289_0_1_rgb, 1.0);\nvec4 o4939301_0_1_rgba = o4939295_0_1_rgba;\nvec3 o4939298_0_1_tex3d = ((o4939301_0_1_rgba).rgb);\n\nreturn o4939298_0_1_tex3d;\n}\nfloat o4939319_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o4939319_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o4939304_g_0_pos = 0.000000000;\nconst float p_o4939304_g_0_r = 0.066406250;\nconst float p_o4939304_g_0_g = 0.066406250;\nconst float p_o4939304_g_0_b = 0.066406250;\nconst float p_o4939304_g_0_a = 1.000000000;\nconst float p_o4939304_g_1_pos = 1.000000000;\nconst float p_o4939304_g_1_r = 1.000000000;\nconst float p_o4939304_g_1_g = 1.000000000;\nconst float p_o4939304_g_1_b = 1.000000000;\nconst float p_o4939304_g_1_a = 1.000000000;\nvec4 o4939304_g_gradient_fct(float x) {\n  if (x < p_o4939304_g_0_pos) {\n    return vec4(p_o4939304_g_0_r,p_o4939304_g_0_g,p_o4939304_g_0_b,p_o4939304_g_0_a);\n  } else if (x < p_o4939304_g_1_pos) {\n    return mix(vec4(p_o4939304_g_0_r,p_o4939304_g_0_g,p_o4939304_g_0_b,p_o4939304_g_0_a), vec4(p_o4939304_g_1_r,p_o4939304_g_1_g,p_o4939304_g_1_b,p_o4939304_g_1_a), ((x-p_o4939304_g_0_pos)/(p_o4939304_g_1_pos-p_o4939304_g_0_pos)));\n  }\n  return vec4(p_o4939304_g_1_r,p_o4939304_g_1_g,p_o4939304_g_1_b,p_o4939304_g_1_a);\n}\nfloat o4939319_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\nvec4 o4939292_0_rect = bricks_rb((((p).yz+vec2(0.5))-vec2(p_o4939301_translate_x, p_o4939301_translate_y)), vec2(p_o4939292_columns, p_o4939292_rows), p_o4939292_repeat, p_o4939292_row_offset);\nvec4 o4939292_0 = brick((((p).yz+vec2(0.5))-vec2(p_o4939301_translate_x, p_o4939301_translate_y)), o4939292_0_rect.xy, o4939292_0_rect.zw, p_o4939292_mortar*1.0, p_o4939292_round*1.0, max(0.001, p_o4939292_bevel*1.0));\nvec3 o4939292_1_2_rgb = brick_random_color(o4939292_0_rect.xy, o4939292_0_rect.zw, float((seed_o4939292+_seed_variation_)));\nvec3 o4939254_0_out = vec3(o4939254_bc(o4939254_fbm((vec3(p_o4939289_f,(transform2((((p).yz+vec2(0.5))-vec2(p_o4939301_translate_x, p_o4939301_translate_y)), vec2(p_o4939295_translate_x*(2.0*(dot(o4939292_1_2_rgb, vec3(1.0))/3.0)-1.0), p_o4939295_translate_y*(2.0*(dot(o4939292_1_2_rgb, vec3(1.0))/3.0)-1.0)), p_o4939295_rotate*0.01745329251*(2.0*(dot(o4939292_1_2_rgb, vec3(1.0))/3.0)-1.0), vec2(p_o4939295_scale_x*(2.0*1.0-1.0), p_o4939295_scale_y*(2.0*1.0-1.0)))).x,(transform2((((p).yz+vec2(0.5))-vec2(p_o4939301_translate_x, p_o4939301_translate_y)), vec2(p_o4939295_translate_x*(2.0*(dot(o4939292_1_2_rgb, vec3(1.0))/3.0)-1.0), p_o4939295_translate_y*(2.0*(dot(o4939292_1_2_rgb, vec3(1.0))/3.0)-1.0)), p_o4939295_rotate*0.01745329251*(2.0*(dot(o4939292_1_2_rgb, vec3(1.0))/3.0)-1.0), vec2(p_o4939295_scale_x*(2.0*1.0-1.0), p_o4939295_scale_y*(2.0*1.0-1.0)))).y)).xyz*vec3(p_o4939254_scale_x,p_o4939254_scale_y,p_o4939254_scale_z)*0.5*p_o4939254_scale+vec3(p_o4939254_transx,p_o4939254_transy,p_o4939254_transz),p_o4939254_persistence, _seed_variation_)*0.5+0.5,p_o4939254_contrast,p_o4939254_brightness, _seed_variation_));vec3 o4939254_0_1_tex3d = clamp(o4939254_0_out,vec3(0),vec3(1));\nvec3 o4939273_0_1_tex3d = o4939273_g_gradient_fct(dot(o4939254_0_1_tex3d, vec3(1.0))/3.0).rgb;\nvec3 o4939289_0_1_rgb = o4939273_0_1_tex3d.rgb;\nvec4 o4939295_0_1_rgba = vec4(o4939289_0_1_rgb, 1.0);\nvec4 o4939301_0_1_rgba = o4939295_0_1_rgba;\nvec3 o4939298_0_1_tex3d = ((o4939301_0_1_rgba).rgb);\nvec3 o4939304_0_1_tex3d = o4939304_g_gradient_fct(dot(o4939298_0_1_tex3d, vec3(1.0))/3.0).rgb;\n\nreturn (dot(o4939304_0_1_tex3d, vec3(1.0))/3.0);\n}\nvec3 o4939319_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o4939319_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o4939319_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o4939319_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o4939325_X = 1.000000000;\nconst float p_o4939325_Y = 0.260000000;\nconst float p_o4939325_Z = 0.260000000;\nconst float p_o4939325_RepX = 1.000000000;\nconst float p_o4939325_RepY = 24.000000000;\nconst float p_o4939325_RepZ = 24.000000000;\nconst float p_o4939264_sx = 0.050000000;\nconst float p_o4939264_sy = 0.235000000;\nconst float p_o4939264_sz = 0.235000000;\nconst float p_o4939264_r = 0.020000000;\nfloat o4939319_input_sdf3d(vec3 p, float _seed_variation_) {\nvec3 o4939264_0_q = abs((opRepLim((p),vec3(p_o4939325_X,p_o4939325_Y,p_o4939325_Z)*2.0,vec3(p_o4939325_RepX-1.0,p_o4939325_RepY-1.0,p_o4939325_RepZ-1.0)))) - vec3(p_o4939264_sx, p_o4939264_sy, p_o4939264_sz);\nfloat o4939264_0_1_sdf3d = length(max(o4939264_0_q,0.0))+min(max(o4939264_0_q.x,max(o4939264_0_q.y,o4939264_0_q.z)),0.0)-p_o4939264_r;\nfloat o4939325_0_1_sdf3d = o4939264_0_1_sdf3d;\n\nreturn o4939325_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o4939319(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o4939319_TranlateX,p_o4939319_TranlateY,p_o4939319_TranlateZ),vec3(p_o4939319_RotateX,p_o4939319_RotateY,p_o4939319_RotateZ)*6.28318530718)/p_o4939319_scale;\n\tfloat sdf=o4939319_input_sdf3d(uv.xyz, _seed_variation_)*p_o4939319_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o4939319_AmbientOcclusion*o4939319_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o4939319_Alpha*o4939319_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o4939319_Normal*o4939319_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o4939319_Emission*o4939319_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o4939319_Roughness*o4939319_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o4939319_Specular*o4939319_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o4939319_Metallic*o4939319_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o4939319_BaseColor_r, p_o4939319_BaseColor_g, p_o4939319_BaseColor_b, p_o4939319_BaseColor_a).rgb*o4939319_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}const float p_o4939328_x = -0.058000000;\nconst float p_o4939328_y = 0.000000000;\nconst float p_o4939328_z = 0.000000000;\nconst float p_o4939267_BaseColor_r = 0.324218988;\nconst float p_o4939267_BaseColor_g = 0.324218988;\nconst float p_o4939267_BaseColor_b = 0.324218988;\nconst float p_o4939267_BaseColor_a = 1.000000000;\nconst float p_o4939267_Metallic = 0.000000000;\nconst float p_o4939267_Specular = 0.000000000;\nconst float p_o4939267_Roughness = 1.000000000;\nconst float p_o4939267_Emission = 0.000000000;\nconst float p_o4939267_Normal = 0.000000000;\nconst float p_o4939267_Alpha = 0.000000000;\nconst float p_o4939267_AmbientOcclusion = 0.000000000;\nconst float p_o4939267_scale = 1.000000000;\nconst float p_o4939267_TranlateX = 0.000000000;\nconst float p_o4939267_TranlateY = 0.000000000;\nconst float p_o4939267_TranlateZ = 0.000000000;\nconst float p_o4939267_RotateX = 0.000000000;\nconst float p_o4939267_RotateY = 0.000000000;\nconst float p_o4939267_RotateZ = 0.000000000;\nvec3 o4939267_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nfloat o4939267_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o4939267_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o4939267_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o4939267_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o4939267_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o4939267_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o4939267_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o4939261_sx = 0.000000000;\nconst float p_o4939261_sy = 6.270000000;\nconst float p_o4939261_sz = 6.140000000;\nconst float p_o4939261_r = 0.000000000;\nfloat o4939267_input_sdf3d(vec3 p, float _seed_variation_) {\nvec3 o4939261_0_q = abs((p)) - vec3(p_o4939261_sx, p_o4939261_sy, p_o4939261_sz);\nfloat o4939261_0_1_sdf3d = length(max(o4939261_0_q,0.0))+min(max(o4939261_0_q.x,max(o4939261_0_q.y,o4939261_0_q.z)),0.0)-p_o4939261_r;\n\nreturn o4939261_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o4939267(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o4939267_TranlateX,p_o4939267_TranlateY,p_o4939267_TranlateZ),vec3(p_o4939267_RotateX,p_o4939267_RotateY,p_o4939267_RotateZ)*6.28318530718)/p_o4939267_scale;\n\tfloat sdf=o4939267_input_sdf3d(uv.xyz, _seed_variation_)*p_o4939267_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o4939267_AmbientOcclusion*o4939267_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o4939267_Alpha*o4939267_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o4939267_Normal*o4939267_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o4939267_Emission*o4939267_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o4939267_Roughness*o4939267_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o4939267_Specular*o4939267_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o4939267_Metallic*o4939267_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o4939267_BaseColor_r, p_o4939267_BaseColor_g, p_o4939267_BaseColor_b, p_o4939267_BaseColor_a).rgb*o4939267_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}const float p_o4836639_x = 0.000000000;\nconst float p_o4836639_y = 1.071000000;\nconst float p_o4836639_z = 0.000000000;\n//const float p_o1771546_angle = -67.8070000000;//EDITED\nconst float p_o1771546_correction = 0.000000000;\nconst float p_o1564764_k = 0.062000000;\nconst float p_o1569342_BaseColor_r = 0.000000000;\nconst float p_o1569342_BaseColor_g = 0.000000000;\nconst float p_o1569342_BaseColor_b = 0.000000000;\nconst float p_o1569342_BaseColor_a = 1.000000000;\nconst float p_o1569342_Metallic = 0.250000000;\nconst float p_o1569342_Specular = 1.000000000;\nconst float p_o1569342_Roughness = 0.000000000;\nconst float p_o1569342_Emission = 0.000000000;\nconst float p_o1569342_Normal = 0.000000000;\nconst float p_o1569342_Alpha = 0.000000000;\nconst float p_o1569342_AmbientOcclusion = 0.000000000;\nconst float p_o1569342_scale = 0.306000000;\nconst float p_o1569342_TranlateX = 0.000000000;\nconst float p_o1569342_TranlateY = 0.000000000;\nconst float p_o1569342_TranlateZ = 0.000000000;\nconst float p_o1569342_RotateX = 0.000000000;\nconst float p_o1569342_RotateY = 0.000000000;\nconst float p_o1569342_RotateZ = 0.000000000;\nvec3 o1569342_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nfloat o1569342_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o1569342_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o1569342_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o1569342_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o1569342_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o1569342_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o1569342_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o1593815_X = 0.500000000;\nconst float p_o1593815_Y = 0.500000000;\nconst float p_o1593815_Z = 0.500000000;\nconst float p_o1593815_RepX = 14.000000000;\nconst float p_o1593815_RepY = 14.000000000;\nconst float p_o1593815_RepZ = 17.000000000;\nconst float p_o1597242_r = 0.320000000;\nfloat o1569342_input_sdf3d(vec3 p, float _seed_variation_) {\nfloat o1597242_0_1_sdf3d = length((opRepLim((p),vec3(p_o1593815_X,p_o1593815_Y,p_o1593815_Z)*2.0,vec3(p_o1593815_RepX-1.0,p_o1593815_RepY-1.0,p_o1593815_RepZ-1.0))))-p_o1597242_r;\nfloat o1593815_0_1_sdf3d = o1597242_0_1_sdf3d;\n\nreturn o1593815_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o1569342(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o1569342_TranlateX,p_o1569342_TranlateY,p_o1569342_TranlateZ),vec3(p_o1569342_RotateX,p_o1569342_RotateY,p_o1569342_RotateZ)*6.28318530718)/p_o1569342_scale;\n\tfloat sdf=o1569342_input_sdf3d(uv.xyz, _seed_variation_)*p_o1569342_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o1569342_AmbientOcclusion*o1569342_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o1569342_Alpha*o1569342_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o1569342_Normal*o1569342_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o1569342_Emission*o1569342_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o1569342_Roughness*o1569342_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o1569342_Specular*o1569342_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o1569342_Metallic*o1569342_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o1569342_BaseColor_r, p_o1569342_BaseColor_g, p_o1569342_BaseColor_b, p_o1569342_BaseColor_a).rgb*o1569342_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}const float p_o41691_BaseColor_r = 0.159263611;\nconst float p_o41691_BaseColor_g = 1.000000000;\nconst float p_o41691_BaseColor_b = 0.000000000;\nconst float p_o41691_BaseColor_a = 1.000000000;\nconst float p_o41691_Metallic = 0.547000000;\nconst float p_o41691_Specular = 0.500000000;\nconst float p_o41691_Roughness = 0.059000000;\nconst float p_o41691_Emission = 0.000000000;\nconst float p_o41691_Normal = 0.000000000;\nconst float p_o41691_Alpha = 0.000000000;\nconst float p_o41691_AmbientOcclusion = 0.000000000;\nconst float p_o41691_scale = 1.000000000;\nconst float p_o41691_TranlateX = 0.000000000;\nconst float p_o41691_TranlateY = 0.000000000;\nconst float p_o41691_TranlateZ = 0.000000000;\nconst float p_o41691_RotateX = 0.000000000;\nconst float p_o41691_RotateY = 0.000000000;\nconst float p_o41691_RotateZ = 0.000000000;\nvec3 o41691_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nfloat o41691_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o41691_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o41691_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o41691_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o41691_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o41691_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o41691_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o1506061_sx = 0.250000000;\nconst float p_o1506061_sy = 0.250000000;\nconst float p_o1506061_sz = 1.940000000;\nconst float p_o1506061_r = 0.280000000;\nfloat o41691_input_sdf3d(vec3 p, float _seed_variation_) {\nvec3 o1506061_0_q = abs((p)) - vec3(p_o1506061_sx, p_o1506061_sy, p_o1506061_sz);\nfloat o1506061_0_1_sdf3d = length(max(o1506061_0_q,0.0))+min(max(o1506061_0_q.x,max(o1506061_0_q.y,o1506061_0_q.z)),0.0)-p_o1506061_r;\n\nreturn o1506061_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o41691(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o41691_TranlateX,p_o41691_TranlateY,p_o41691_TranlateZ),vec3(p_o41691_RotateX,p_o41691_RotateY,p_o41691_RotateZ)*6.28318530718)/p_o41691_scale;\n\tfloat sdf=o41691_input_sdf3d(uv.xyz, _seed_variation_)*p_o41691_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o41691_AmbientOcclusion*o41691_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o41691_Alpha*o41691_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o41691_Normal*o41691_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o41691_Emission*o41691_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o41691_Roughness*o41691_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o41691_Specular*o41691_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o41691_Metallic*o41691_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o41691_BaseColor_r, p_o41691_BaseColor_g, p_o41691_BaseColor_b, p_o41691_BaseColor_a).rgb*o41691_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}vec4 o9000_input_mfsdf(vec4 p, float _seed_variation_) {\nvec4 o218686_0_1_v4v4 = PBRObjectMaker_o218686((p), _seed_variation_);\nvec4 o2041939_0_1_v4v4 = PBRObjectMaker_o2041939((vec4((p).xyz-vec3(p_o2324410_x, p_o2324410_y, p_o2324410_z),(p).w)), _seed_variation_);\nvec4 o2195793_0_1_v4v4 = PBRObjectMaker_o2195793((vec4((vec4((p).xyz-vec3(p_o2324410_x, p_o2324410_y, p_o2324410_z),(p).w)).xyz-vec3(p_o2245524_x, p_o2245524_y, p_o2245524_z),(vec4((p).xyz-vec3(p_o2324410_x, p_o2324410_y, p_o2324410_z),(p).w)).w)), _seed_variation_);\nvec4 o2245524_0_1_v4v4 = o2195793_0_1_v4v4;\nvec4 o2510272_0_1_v4v4 = sdf3dc_union(o2041939_0_1_v4v4, o2245524_0_1_v4v4);\nvec4 o2324410_0_1_v4v4 = o2510272_0_1_v4v4;\nvec4 o2041939_0_3_v4v4 = PBRObjectMaker_o2041939((vec4((vec4(vec3(abs((p).x),(p).yz),(p).w)).xyz-vec3(p_o2324410_x, p_o2324410_y, p_o2324410_z),(vec4(vec3(abs((p).x),(p).yz),(p).w)).w)), _seed_variation_);\nvec4 o2195793_0_3_v4v4 = PBRObjectMaker_o2195793((vec4((vec4((vec4(vec3(abs((p).x),(p).yz),(p).w)).xyz-vec3(p_o2324410_x, p_o2324410_y, p_o2324410_z),(vec4(vec3(abs((p).x),(p).yz),(p).w)).w)).xyz-vec3(p_o2245524_x, p_o2245524_y, p_o2245524_z),(vec4((vec4(vec3(abs((p).x),(p).yz),(p).w)).xyz-vec3(p_o2324410_x, p_o2324410_y, p_o2324410_z),(vec4(vec3(abs((p).x),(p).yz),(p).w)).w)).w)), _seed_variation_);\nvec4 o2245524_0_3_v4v4 = o2195793_0_3_v4v4;\nvec4 o2510272_0_3_v4v4 = sdf3dc_union(o2041939_0_3_v4v4, o2245524_0_3_v4v4);\nvec4 o2324410_0_3_v4v4 = o2510272_0_3_v4v4;\nvec4 o4680081_0_1_v4v4 = o2324410_0_3_v4v4;\nvec4 o2041939_0_5_v4v4 = PBRObjectMaker_o2041939((vec4((vec4(vec3(abs((vec4(v4v4_rotate((p).xyz, -vec3(p_o4750441_ax, p_o4750441_ay, p_o4750441_az)*0.01745329251), (p).w)).x),(vec4(v4v4_rotate((p).xyz, -vec3(p_o4750441_ax, p_o4750441_ay, p_o4750441_az)*0.01745329251), (p).w)).yz),(vec4(v4v4_rotate((p).xyz, -vec3(p_o4750441_ax, p_o4750441_ay, p_o4750441_az)*0.01745329251), (p).w)).w)).xyz-vec3(p_o2324410_x, p_o2324410_y, p_o2324410_z),(vec4(vec3(abs((vec4(v4v4_rotate((p).xyz, -vec3(p_o4750441_ax, p_o4750441_ay, p_o4750441_az)*0.01745329251), (p).w)).x),(vec4(v4v4_rotate((p).xyz, -vec3(p_o4750441_ax, p_o4750441_ay, p_o4750441_az)*0.01745329251), (p).w)).yz),(vec4(v4v4_rotate((p).xyz, -vec3(p_o4750441_ax, p_o4750441_ay, p_o4750441_az)*0.01745329251), (p).w)).w)).w)), _seed_variation_);\nvec4 o2195793_0_5_v4v4 = PBRObjectMaker_o2195793((vec4((vec4((vec4(vec3(abs((vec4(v4v4_rotate((p).xyz, -vec3(p_o4750441_ax, p_o4750441_ay, p_o4750441_az)*0.01745329251), (p).w)).x),(vec4(v4v4_rotate((p).xyz, -vec3(p_o4750441_ax, p_o4750441_ay, p_o4750441_az)*0.01745329251), (p).w)).yz),(vec4(v4v4_rotate((p).xyz, -vec3(p_o4750441_ax, p_o4750441_ay, p_o4750441_az)*0.01745329251), (p).w)).w)).xyz-vec3(p_o2324410_x, p_o2324410_y, p_o2324410_z),(vec4(vec3(abs((vec4(v4v4_rotate((p).xyz, -vec3(p_o4750441_ax, p_o4750441_ay, p_o4750441_az)*0.01745329251), (p).w)).x),(vec4(v4v4_rotate((p).xyz, -vec3(p_o4750441_ax, p_o4750441_ay, p_o4750441_az)*0.01745329251), (p).w)).yz),(vec4(v4v4_rotate((p).xyz, -vec3(p_o4750441_ax, p_o4750441_ay, p_o4750441_az)*0.01745329251), (p).w)).w)).w)).xyz-vec3(p_o2245524_x, p_o2245524_y, p_o2245524_z),(vec4((vec4(vec3(abs((vec4(v4v4_rotate((p).xyz, -vec3(p_o4750441_ax, p_o4750441_ay, p_o4750441_az)*0.01745329251), (p).w)).x),(vec4(v4v4_rotate((p).xyz, -vec3(p_o4750441_ax, p_o4750441_ay, p_o4750441_az)*0.01745329251), (p).w)).yz),(vec4(v4v4_rotate((p).xyz, -vec3(p_o4750441_ax, p_o4750441_ay, p_o4750441_az)*0.01745329251), (p).w)).w)).xyz-vec3(p_o2324410_x, p_o2324410_y, p_o2324410_z),(vec4(vec3(abs((vec4(v4v4_rotate((p).xyz, -vec3(p_o4750441_ax, p_o4750441_ay, p_o4750441_az)*0.01745329251), (p).w)).x),(vec4(v4v4_rotate((p).xyz, -vec3(p_o4750441_ax, p_o4750441_ay, p_o4750441_az)*0.01745329251), (p).w)).yz),(vec4(v4v4_rotate((p).xyz, -vec3(p_o4750441_ax, p_o4750441_ay, p_o4750441_az)*0.01745329251), (p).w)).w)).w)).w)), _seed_variation_);\nvec4 o2245524_0_5_v4v4 = o2195793_0_5_v4v4;\nvec4 o2510272_0_5_v4v4 = sdf3dc_union(o2041939_0_5_v4v4, o2245524_0_5_v4v4);\nvec4 o2324410_0_5_v4v4 = o2510272_0_5_v4v4;\nvec4 o4680081_0_3_v4v4 = o2324410_0_5_v4v4;\nvec4 o4750441_0_1_v4v4 = o4680081_0_3_v4v4;\nvec4 o4792380_0_1_v4v4 = PBRObjectMaker_o4792380((p), _seed_variation_);\nvec4 o4939319_0_1_v4v4 = PBRObjectMaker_o4939319((vec4(v4v4_rotate((vec4((vec4((p).xyz-vec3(p_o5016891_x, p_o5016891_y, p_o5016891_z),(p).w)).xyz/vec3(p_o5036184_x, p_o5036184_y, p_o5036184_z)/p_o5036184_xyz,(vec4((p).xyz-vec3(p_o5016891_x, p_o5016891_y, p_o5016891_z),(p).w)).w)).xyz, -vec3(p_o5009315_ax, p_o5009315_ay, p_o5009315_az)*0.01745329251), (vec4((vec4((p).xyz-vec3(p_o5016891_x, p_o5016891_y, p_o5016891_z),(p).w)).xyz/vec3(p_o5036184_x, p_o5036184_y, p_o5036184_z)/p_o5036184_xyz,(vec4((p).xyz-vec3(p_o5016891_x, p_o5016891_y, p_o5016891_z),(p).w)).w)).w)), _seed_variation_);\nvec4 o4939267_0_1_v4v4 = PBRObjectMaker_o4939267((vec4((vec4(v4v4_rotate((vec4((vec4((p).xyz-vec3(p_o5016891_x, p_o5016891_y, p_o5016891_z),(p).w)).xyz/vec3(p_o5036184_x, p_o5036184_y, p_o5036184_z)/p_o5036184_xyz,(vec4((p).xyz-vec3(p_o5016891_x, p_o5016891_y, p_o5016891_z),(p).w)).w)).xyz, -vec3(p_o5009315_ax, p_o5009315_ay, p_o5009315_az)*0.01745329251), (vec4((vec4((p).xyz-vec3(p_o5016891_x, p_o5016891_y, p_o5016891_z),(p).w)).xyz/vec3(p_o5036184_x, p_o5036184_y, p_o5036184_z)/p_o5036184_xyz,(vec4((p).xyz-vec3(p_o5016891_x, p_o5016891_y, p_o5016891_z),(p).w)).w)).w)).xyz-vec3(p_o4939328_x, p_o4939328_y, p_o4939328_z),(vec4(v4v4_rotate((vec4((vec4((p).xyz-vec3(p_o5016891_x, p_o5016891_y, p_o5016891_z),(p).w)).xyz/vec3(p_o5036184_x, p_o5036184_y, p_o5036184_z)/p_o5036184_xyz,(vec4((p).xyz-vec3(p_o5016891_x, p_o5016891_y, p_o5016891_z),(p).w)).w)).xyz, -vec3(p_o5009315_ax, p_o5009315_ay, p_o5009315_az)*0.01745329251), (vec4((vec4((p).xyz-vec3(p_o5016891_x, p_o5016891_y, p_o5016891_z),(p).w)).xyz/vec3(p_o5036184_x, p_o5036184_y, p_o5036184_z)/p_o5036184_xyz,(vec4((p).xyz-vec3(p_o5016891_x, p_o5016891_y, p_o5016891_z),(p).w)).w)).w)).w)), _seed_variation_);\nvec4 o4939328_0_1_v4v4 = o4939267_0_1_v4v4;\nvec4 o4939331_0_1_v4v4 = sdf3dc_union(o4939319_0_1_v4v4, o4939328_0_1_v4v4);\nvec4 o5009315_0_1_v4v4 = o4939331_0_1_v4v4;\nvec4 o_o5036184_0=o5009315_0_1_v4v4;vec4 o5036184_0_1_v4v4 = vec4(o_o5036184_0.xyz,o_o5036184_0.w*min(min(p_o5036184_x, p_o5036184_y), p_o5036184_z)*p_o5036184_xyz);\nvec4 o5016891_0_1_v4v4 = o5036184_0_1_v4v4;\nvec4 o4677275_0_1_v4v4 = MFSDF_Union(o2324410_0_1_v4v4,o4680081_0_1_v4v4,o4750441_0_1_v4v4,o4792380_0_1_v4v4,o5016891_0_1_v4v4,o5016891_0_1_v4v4,vec4(0.0,0.0,0.0,9999999.0),vec4(0.0,0.0,0.0,9999999.0));\nfloat p_o1771546_angle=-67.807000000+(iMouse.y/iResolution.y)*180.0; //EDITED NEW\nvec4 o1569342_0_1_v4v4 = PBRObjectMaker_o1569342((vec4(twistZ((vec4((p).xyz-vec3(p_o4836639_x, p_o4836639_y, p_o4836639_z),(p).w)).xyz,p_o1771546_angle),(vec4((p).xyz-vec3(p_o4836639_x, p_o4836639_y, p_o4836639_z),(p).w)).w)), _seed_variation_);\nvec4 o41691_0_1_v4v4 = PBRObjectMaker_o41691((vec4(twistZ((vec4((p).xyz-vec3(p_o4836639_x, p_o4836639_y, p_o4836639_z),(p).w)).xyz,p_o1771546_angle),(vec4((p).xyz-vec3(p_o4836639_x, p_o4836639_y, p_o4836639_z),(p).w)).w)), _seed_variation_);\nvec4 o1564764_0_1_v4v4 = mfsdf3d_smooth_subtraction(o1569342_0_1_v4v4, o41691_0_1_v4v4,p_o1564764_k);\nvec4 o1771546_0_o=o1564764_0_1_v4v4;vec4 o1771546_0_1_v4v4 = vec4(o1771546_0_o.xyz,o1771546_0_o.w/(1.0+p_o1771546_correction));\nvec4 o4836639_0_1_v4v4 = o1771546_0_1_v4v4;\nvec4 o21794_0_1_v4v4 = MFSDF_Union(o218686_0_1_v4v4,o4677275_0_1_v4v4,o4836639_0_1_v4v4,vec4(0.0,0.0,0.0,9999999.0),vec4(0.0,0.0,0.0,9999999.0),vec4(0.0,0.0,0.0,9999999.0),vec4(0.0,0.0,0.0,9999999.0),vec4(0.0,0.0,0.0,9999999.0));\n\nreturn o21794_0_1_v4v4;\n}\nvec3 o9000_input_hdri(vec2 uv, float _seed_variation_) {\n\nreturn vec3(0.0);\n}\n\n//tetrahedron normal by PauloFalcao\nvec3 normal_o9000(vec3 p, float _seed_variation_) {  \n  const vec3 e=vec3(0.01,-0.01,0.0);\n  float v1=o9000_input_mfsdf(vec4(p+e.xyy,0.0), _seed_variation_).w;\n  float v2=o9000_input_mfsdf(vec4(p+e.yyx,0.0), _seed_variation_).w;\n  float v3=o9000_input_mfsdf(vec4(p+e.yxy,0.0), _seed_variation_).w;\n  float v4=o9000_input_mfsdf(vec4(p+e.xxx,0.0), _seed_variation_).w;\n  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n}\n\nvoid raymarch_o9000(in vec3 o,in vec3 v,out vec3 p,inout float d, float _seed_variation_) {\n  float s;\n  for(int i=0;i<64;i++){\n    p=o+v*d;\n    s=o9000_input_mfsdf(vec4(p,0.0), _seed_variation_).w;\n    if (abs(s)<0.001) break;\n    d+=s;\n    if (d>p_o9000_MaxDistance) break;\n  } \n}\n\n/*EDITED OLD\nvec3 pathtracing_o9000(vec2 uv, float _seed_variation_) {\n\n\t// Init random\n\tvec2 rndgen=rndint_hash23(vec3(uv,iTime))*15360.0;\n    uint rngState = uint(uint(rndgen.x) * uint(1973) + uint(rndgen.y) * uint(9277) + uint(iTime*1223.0) * uint(26699)) | uint(1);\nEDITED OLD*/\n\nvec3 pathtracing_o9000(uint rngState, vec2 uv, float _seed_variation_) { //EDITED NEW \n\n\t//vec3 o=vec3(p_o9000_CamX,p_o9000_CamY,p_o9000_CamZ)*p_o9000_CamZoom;\n    \n    //EDITED NEW add mouse\n    float mx=(iMouse.x/iResolution.x)*6.0;\n\tvec3 o=vec3(p_o9000_CamX,p_o9000_CamY,p_o9000_CamZ-mx)*p_o9000_CamZoom;\n    //EDITED NEW add mouse\n    \n    vec3 t=vec3(p_o9000_LookAtX,p_o9000_LookAtY,p_o9000_LookAtZ);\n    vec3 u=vec3(0.0,1.0,0.0);\n    vec3 c=normalize(t-o);\n    vec3 cx=normalize(cross(u,c));\n    vec3 cy=normalize(cross(cx,c));\n   \n\tvec2 xy=uv-0.5;\n\n    vec3 v=normalize(c*p_o9000_CamD+cx*xy.x+cy*xy.y);\n\n    vec3 p;\n    float d=0.01;\n    vec3 rgb=vec3(1.0);\n    vec3 io=o;\n    int i;\n    for(i=0;i<4;i++){\n    \n        raymarch_o9000(io,v,p,d, _seed_variation_);\n        \n        vec3 n=normal_o9000(p, _seed_variation_);\n        \n        //View direction to tangent space\n        vec3 ot;vec3 ob;Onb(n,ot,ob);\n        vec3 vt=vec3(dot(-v,ot),dot(-v,ob),dot(-v,n));\n\t\n        if (d<p_o9000_MaxDistance){\t\n        //if (length(p-o)<p_o9000_MaxDistance){\n        vec3 obj_Emission=o9000_input_mfsdf(vec4(p,13.0), _seed_variation_).rgb;\n        \n        if ((obj_Emission.x+obj_Emission.y+obj_Emission.z)>0.001){\n            rgb=obj_Emission*rgb;\n            break;\n        } else {\n            float s=RandomFloat01(rngState);\n\n            vec3 obj_BaseColor=o9000_input_mfsdf(vec4(p,1.0), _seed_variation_).rgb; // 1 - BaseColor  (r,g,b,sdf)\n            float obj_Metallic=o9000_input_mfsdf(vec4(p,2.0), _seed_variation_).x;   // 2 - Metallic   (v,0,0,sdf)\n            float obj_Specular=o9000_input_mfsdf(vec4(p,4.0), _seed_variation_).x;   // 4 - Specular   (v,0,0,sdf)\n            float obj_Roughness=o9000_input_mfsdf(vec4(p,5.0), _seed_variation_).x;  // 5 - Roughness  (v,0,0,sdf)\n\n            if (s>obj_Specular*obj_Specular){\n                rgb=(obj_BaseColor-obj_BaseColor*obj_Metallic)*rgb;\n                v=cosineSampleHemissphere(rngState,n);\n            } else {\n\n                float r2=obj_Roughness*obj_Roughness;\n                vec3 vndf=SampleGGXVNDF(rngState,vt,r2,r2);\n                vec3 nv=reflect(-vt,vndf);\n\n                //Sample direction back to camera space\n                nv=nv.x*ot+nv.y*ob+nv.z*n;\n\n                float FH=schlickWeight(dot(n,nv));\n                vec3 Cspec0=mix(vec3(obj_Specular*.08),obj_BaseColor,obj_Metallic);\n                vec3 Fs=mix(Cspec0,vec3(1.0),FH);\n                rgb=Fs*rgb;\n                \n                v=nv;\n            }\n            io=p;\n            d=0.01;\n        }\n        } else {\n        rgb*=o9000_input_hdri(equirectangularMap(v.xzy), _seed_variation_).xyz;\n        break;\n        }\n    }//for(int i\n    if (i==4) rgb=vec3(0.0);//did not hit any light source\n\n\treturn rgb;\n\t\n}\n\n/* EDITED OLD\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\nfloat minSize = min(iResolution.x, iResolution.y);\nfloat _seed_variation_ = SEED_VARIATION;\nvec2 UV = vec2(0.0, 1.0) + vec2(1.0, -1.0) * (fragCoord-0.5*(iResolution.xy-vec2(minSize)))/minSize;\nvec3 o9000_0_1_rgb = pathtracing_o9000((UV), _seed_variation_);\nfragColor = vec4(o9000_0_1_rgb, 1.0);\n EDITED OLD}*/\n\n//EDITED NEW\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    vec2 xy=fragCoord+vec2(RandomFloat01(rngState),RandomFloat01(rngState));\n\n    float minSize = min(iResolution.x, iResolution.y);\n    float _seed_variation_ = SEED_VARIATION;\n    vec2 UV = vec2(0.0, 1.0) + vec2(1.0, -1.0) * (xy-0.5*(iResolution.xy-vec2(minSize)))/minSize;\n    vec3 rgb = /*change here*/pathtracing_o9000(rngState,(UV), _seed_variation_);\n\n    if (iMouse.z<0.1){\n        vec4 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy);\n        fragColor = vec4(lastFrameColor+vec4(rgb,1.0));\n    } else {\n        fragColor = vec4(rgb,1.0);\n    }\n\n}\n//EDITED NEW", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st3GDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[599, 599, 655, 655, 794]], "test": "untested"}
{"id": "stc3Ws", "name": "Bulb detail", "author": "loicvdb", "description": "Rotate camera with mouse.\nLight gets updated on the first 64 frames so it might be a little slow at first.", "tags": ["fractal", "volume", "gi", "mandelbulb", "voxel", "volumetric", "pathtracing", "pathtraced"], "likes": 84, "viewed": 2356, "published": 3, "date": "1636925887", "time_retrieved": "2024-07-30T18:48:10.165140", "image_code": "/**\n * Volume rendering with path traced GI.\n * \n * High quality version in Common.\n * \n * Buffer A accumulates the GI in a voxel grid\n * Buffer B raymarches the ray and gets illumination data from the voxel grid\n * Image buffer does the postprocessing\n * \n */\n\nvoid mainImage(out vec4 o, vec2 u)\n{\n\n    #if 0\n    \n    // no dof\n    vec3 x = texelFetch(iChannel0, ivec2(u), 0).rgb;\n    \n    #else\n    \n    // max blur radius\n    float clip = 0.005 * iResolution.y;\n    \n    #ifdef HIGH_QUALITY\n    const int res = 1;\n    #else\n    // half resolution sampling\n    const int res = 2;\n    #endif\n    \n    vec3 x = vec3(0);\n    float sum = 0.0;\n    \n    int yR = int(ceil(clip / float(res)));\n    \n    for (int j = -yR; j <= yR; j++)\n    {\n        int xR = int(ceil(sqrt(clip * clip - float(j * res * j * res) / float(res))));\n        \n        for (int i = -xR; i <= xR; i++)\n        {\n            ivec2 d = ivec2(i, j) * res;\n            \n            ivec2 p = clamp(ivec2(u) + d, ivec2(0), ivec2(iResolution.xy) - 1);\n            vec4 tex = texelFetch(iChannel0, p, 0);\n            \n            float a = min(0.03 * iResolution.y * abs(tex.a - 1.47) / tex.a, clip);\n            float weight = smoothstep(-a - 1.0, -a, -length(vec2(d))) / (a * a + 0.001);\n            \n            x += tex.rgb * weight;\n            sum += weight;\n        }\n    }\n    \n    x /= sum;\n    \n    #endif\n    \n    // lod bloom\n    float r = floor(log2(iResolution.y) - 4.5) + 0.5;\n    for (int i = 0; i < 3; i++)\n    {\n        x += texture(iChannel0, u / iResolution.xy, r + float(i * 2)).rgb * 0.1;\n    }\n    \n    // vignette\n    vec2 cuv = u / iResolution.xy - 0.5;\n    x *= 1.0 - dot(cuv*cuv, cuv*cuv) * 4.0;\n    \n    // tonemapping\n    x = (x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14);\n    \n    o = vec4(x, 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// uncomment for high quality version (about 4x slower)\n//#define HIGH_QUALITY\n\n\n#ifdef HIGH_QUALITY\nconst float stepFactor = 0.2;\n#else\nconst float stepFactor = 0.6;\n#endif\n\n\n// show voxel GI\n#define GI_DEBUG_MODE 0\n\n#define getVoxelResolution() ivec3(pow(iResolution.x * iResolution.y + 1.0, 0.333333))\n\nconst float density = 128.0;\n\nstruct volume\n{\n    vec3 col;\n    vec3 emission;\n    float density;\n    float dist;\n};\n\n\nvolume getVolume(vec3 p)\n{\n    const float scale = 0.8;\n    \n    p = p / scale + vec3(-0.65, -1.0, -0.15);\n\tvec3 w = p, ot = vec3(1.0);\n    float dr = 1.0, r = length(w);\n    \n    #ifdef HIGH_QUALITY\n    const int iterations = 7;\n    #else\n    const int iterations = 5;\n    #endif\n    \n\tfor (int i = 0; i < iterations && r < 1.2; i++)\n    {\n\t\tdr = dr * r*r*r*r*r*r*r * 8.0 + 1.0;\n        \n        float x2 = w.x * w.x;\n\t\tfloat y2 = w.y * w.y;\n\t\tfloat z2 = w.z * w.z;\n        float x4 = x2 * x2;\n        float z4 = z2 * z2;\n        float k1 = x2 * z2;\n\t\tfloat k2 = x2 + z2 + 0.00001;\n\t\tfloat k3 = x4 + z4 + y2 * (y2 - 6.0 * k2) + 2.0 * k1;\n        float k4 = k2 * k2 * k2;\n\t\tfloat k5 = k3 * inversesqrt(k4 * k4 * k2);\n\t\tfloat k6 = w.y * (k2 - y2);\n\t\tw.x = p.x + 64.0 * k6 * k5 * w.x * w.z * (x2 - z2) * (x4 - 6.0 * k1 + z4);\n\t\tw.y = p.y - 16.0 * k6 * k6 * k2 + k3 * k3;\n\t\tw.z = p.z - 8.0 * k6 * k5 * (x4 * (x4 - 28.0 * k1 + 70.0 * z4) + z4 * (z4 - 28.0 * k1));\n        \n        r = length(w);\n\t\tot = min(abs(w * 1.2), ot);\n\t}\n    \n    volume v;\n    v.dist = scale * 0.5 * log(r) * r / dr;\n\tv.col = mix(vec3(0.6, 1.0, 0.9), vec3(1.0, 0.0, 0.0), ot);\n\tv.emission = mix(vec3(0.4, 0.6, 0.0), vec3(0.0, 0.2, 1.0), ot.z) * step(ot.y * ot.x, 0.001);\n    v.density = step(r, 1.2);\n    \n    return v;\n}\n\nvec2 clippingPlanes(vec3 ro, vec3 rd)\n{\n    vec3 cv = (0.5 - ro - sign(rd) * 0.5) / rd;\n    vec3 fv = (0.5 - ro + sign(rd) * 0.5) / rd;\n    \n    float cp = max(max(max(cv.x, cv.y), cv.z), 0.0);\n    float fp = min(min(fv.x, fv.y), fv.z);\n    \n    return vec2(cp, fp);\n}\n\n\nvec3 background(vec3 rd)\n{\n    return mix(vec3(1.1, 0.6, 0.6), vec3(0.2, 0.2, 0.3), rd.y * 0.5 + 0.5);\n}\n\n\nuint hash(uint i)\n{\n\ti *= 0xB5297A4Du;\n\ti ^= i >> 8;\n\ti += 0x68E31DA4u;\n\ti ^= i << 8;\n\ti *= 0x1B56C4E9u;\n\ti ^= i >> 8;\n\treturn i;\n}\n\n\nfloat fhash(uint i)\n{\n    return float(hash(i))/4294967295.;\n}\n\n\nuint seed;\n\n\nfloat random()\n{\n    return fhash(seed++);\n}\n\n\nvec3 randomNormal()\n{\n    vec2 r = vec2(6.28318530718 * random(), acos(2.0 * random() - 1.0));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(s.y * s.x, s.y * c.x, c.y);\n}\n", "buffer_a_code": "ivec3 vResolution;\n\n\nvec4 voxelFetch(ivec3 v)\n{\n    int id = 1 + (v.x + (v.y + (v.z) * vResolution.y) * vResolution.x);\n    return texelFetch(iChannel0, ivec2(id % int(iResolution.x), id / int(iResolution.x)), 0);\n}\n\n\nvec4 voxelLinear(vec3 p)\n{\n    p = p * vec3(vResolution) - 0.5;\n    \n    ivec3 v = clamp(ivec3(p), ivec3(0), vResolution - 2);\n    \n    vec4 xmymzm = voxelFetch(v + ivec3(0, 0, 0));\n    vec4 xpymzm = voxelFetch(v + ivec3(1, 0, 0));\n    vec4 xmypzm = voxelFetch(v + ivec3(0, 1, 0));\n    vec4 xpypzm = voxelFetch(v + ivec3(1, 1, 0));\n    vec4 xmymzp = voxelFetch(v + ivec3(0, 0, 1));\n    vec4 xpymzp = voxelFetch(v + ivec3(1, 0, 1));\n    vec4 xmypzp = voxelFetch(v + ivec3(0, 1, 1));\n    vec4 xpypzp = voxelFetch(v + ivec3(1, 1, 1));\n    \n    vec4 ymzm = mix(xmymzm, xpymzm, fract(p.x));\n    vec4 ypzm = mix(xmypzm, xpypzm, fract(p.x));\n    vec4 ymzp = mix(xmymzp, xpymzp, fract(p.x));\n    vec4 ypzp = mix(xmypzp, xpypzp, fract(p.x));\n    \n    vec4 zm = mix(ymzm, ypzm, fract(p.y));\n    vec4 zp = mix(ymzp, ypzp, fract(p.y));\n    \n    return mix(zm, zp, fract(p.z));\n}\n\n\nfloat trace(vec3 ro, vec3 rd)\n{\n    const float stepSize = 2.0 / density;\n    float t = random() * stepSize;\n    float tMax = clippingPlanes(ro, rd).y;\n    float oDepth = -log(random()) / density;\n    \n    for (int i = 0; i < 512 && oDepth > 0.0 && t < tMax; i++)\n    {\n        volume v = getVolume(ro + rd * t);\n        oDepth -= stepSize * v.density;\n        t += max(stepSize, v.dist);\n    }\n    \n    return mix(-1.0, t, step(oDepth, 0.0));\n}\n\n\nvoid mainImage(out vec4 o, vec2 u)\n{\n    seed = hash(uint(iFrame));\n    \n    vResolution = getVoxelResolution();\n    \n    vec4 prevResSamples = texelFetch(iChannel0, ivec2(0, 0), 0);\n    int samples = int(prevResSamples.a);\n    \n    vec4 pVol = texelFetch(iChannel0, ivec2(u), 0);\n    \n    int id = int(u.x) + int(u.y) * int(iResolution.x) - 1;\n    \n    if (vResolution != ivec3(prevResSamples.xyz))\n    {\n        samples = 0;\n    }\n    \n    int frameSamples = int(step(float(samples), 64.0));\n    \n    if (id == -1)\n    {\n        o = vec4(vResolution, samples + frameSamples);\n        return;\n    }\n    \n    if (id >= vResolution.x * vResolution.y * vResolution.z)\n    {\n        return;\n    }\n    \n    float x = float((id) % vResolution.x);\n    float y = float((id / vResolution.x) % vResolution.y);\n    float z = float((id / vResolution.x / vResolution.y) % vResolution.z);\n    \n    vec4 nVol = vec4(0.0);\n    \n    for (int i = 0; i < frameSamples; i++)\n    {\n        const vec3 lDir = normalize(vec3(1.0, 0.4, -0.3));\n        \n        vec3 p = vec3(x + random(), y + random(), z + random()) / vec3(vResolution);\n        vec3 li = 0.25 * step(trace(p, lDir), 0.0) * vec3(8.0);\n        \n        if (samples > 0)\n        {\n            // reusing the volumetric data for \"infinite\" bounce GI\n            vec3 rd = randomNormal();\n            float t = trace(p, rd);\n            volume v = getVolume(p + t * rd);\n            li += mix(background(rd), voxelLinear(p + t * rd).rgb * v.col + v.emission, step(0.0, t));\n        }\n        \n        nVol += vec4(li, getVolume(p).density) / float(frameSamples);\n    }\n    \n    o = mix(pVol, nVol, float(frameSamples) / float(samples + frameSamples));\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "ivec3 vResolution;\n\n\nvec4 voxelFetch(ivec3 v)\n{\n    int id = 1 + (v.x + (v.y + (v.z) * vResolution.y) * vResolution.x);\n    return texelFetch(iChannel0, ivec2(id % int(iResolution.x), id / int(iResolution.x)), 0);\n}\n\n\nvec4 voxelLinear(vec3 p)\n{\n    p = p * vec3(vResolution) - 0.5;\n    \n    ivec3 v = clamp(ivec3(p), ivec3(0), vResolution - 2);\n    \n    vec4 xmymzm = voxelFetch(v + ivec3(0, 0, 0));\n    vec4 xpymzm = voxelFetch(v + ivec3(1, 0, 0));\n    vec4 xmypzm = voxelFetch(v + ivec3(0, 1, 0));\n    vec4 xpypzm = voxelFetch(v + ivec3(1, 1, 0));\n    vec4 xmymzp = voxelFetch(v + ivec3(0, 0, 1));\n    vec4 xpymzp = voxelFetch(v + ivec3(1, 0, 1));\n    vec4 xmypzp = voxelFetch(v + ivec3(0, 1, 1));\n    vec4 xpypzp = voxelFetch(v + ivec3(1, 1, 1));\n    \n    vec4 ymzm = mix(xmymzm, xpymzm, fract(p.x));\n    vec4 ypzm = mix(xmypzm, xpypzm, fract(p.x));\n    vec4 ymzp = mix(xmymzp, xpymzp, fract(p.x));\n    vec4 ypzp = mix(xmypzp, xpypzp, fract(p.x));\n    \n    vec4 zm = mix(ymzm, ypzm, fract(p.y));\n    vec4 zp = mix(ymzp, ypzp, fract(p.y));\n    \n    return mix(zm, zp, fract(p.z));\n}\n\n\nvec4 voxelClosest(vec3 p)\n{\n    return voxelFetch(clamp(ivec3(p * vec3(vResolution)), ivec3(0), vResolution - 1));\n}\n\n\nvec4 colDepth(vec3 ro, vec3 rd)\n{\n    rd += (1.0 - abs(sign(rd))) * 0.00001;   // avoids div/0 for clipping planes & voxel marching\n    \n    vec2 cp = clippingPlanes(ro, rd);\n    \n    float depth = 3.0;\n    \n    if (cp.y <= cp.x)\n    {\n        return vec4(background(rd), depth);\n    }\n    \n    vec3 cubeSize = 1.0 / vec3(vResolution);\n    vec3 col = vec3(0.0);\n    float att = 1.0;\n    float t = cp.x;\n    \n    #if GI_DEBUG_MODE\n    \n    // voxel marching w/ analytical volume integration\n    \n    int maxSteps = vResolution.x + vResolution.y + vResolution.z;\n    \n    for (int i = 0; i < maxSteps && att > .03 && t < cp.y; i++)\n    {\n        vec3 p = ro + t * rd;\n        vec3 l = (cubeSize * floor(p / cubeSize + sign(rd) * 0.50001 + 0.5) - p) / rd;\n        float stepSize = min(min(l.x, l.y), l.z) + 0.00001;\n        \n        vec4 v = voxelClosest(p);\n        \n        if(v.a > 0.0)\n        {\n            depth = min(depth, t);\n            float a = exp(-stepSize * v.a * density);\n            col += att * (1.0 - a) * v.rgb;\n            att *= a;\n        }\n        \n        t += stepSize;\n    }\n    \n    #else\n    \n    // volume raymarching + SDF raymarching\n    float phase = random();\n    \n    for (int i = 0; i < 1024 && att > .03 && t < cp.y; i++)\n    {\n        const float stepSize = stepFactor / density;\n    \n        vec3 p = ro + rd * t;\n        \n        volume v = getVolume(p);\n        \n        if (v.density > 0.0)\n        {\n            float a = exp(-stepSize * v.density * density);\n            col += att * (1.0 - a) * (v.col * voxelLinear(p).rgb + v.emission);\n            att *= a;\n        }\n        \n        if(v.dist < 0.0 && t < depth)\n        {\n            depth = t;\n        }\n        \n        // SDF raymarching\n        t += max(v.dist, 0.0);\n        \n        // rounding t to the next point\n        t += (1.0 - fract(t / stepSize + phase) - 0.000001) * stepSize;\n    }\n    \n    #endif\n    \n    return vec4(att * background(rd) + col, depth);\n}\n\n\nvoid mainImage(out vec4 o, vec2 u)\n{\n    float samples = texelFetch(iChannel0, ivec2(0, 0), 0).a;\n    \n    if (samples < 16.0)\n    {\n        // not enough samples, don't render to sample faster\n        o = vec4(0);\n        return;\n    }\n    \n    seed = hash(uint(floor(u.x) + floor(u.y) * 12345.0)) ^ hash(uint(iFrame));\n    \n    vResolution = getVoxelResolution();\n    \n    vec2 rot = vec2(0.3, 0.7);\n    if(iMouse != vec4(0.0))\n    {\n        rot += (iMouse.xy - iResolution.xy * 0.5) / iResolution.y * 3.0;\n    }\n    \n    vec2 c = cos(rot);\n    vec2 s = sin(rot);\n    \n    mat3 rx = mat3(1, 0, 0, 0, c.y, s.y, 0, -s.y, c.y);\n    mat3 ry = mat3(c.x, 0, s.x, 0, 1, 0, -s.x, 0, c.x);\n    mat3 cam = ry * rx;\n    \n    vec3 rd = cam * normalize(vec3((u - iResolution.xy * 0.5) / iResolution.y, -3.5));\n    vec3 ro = cam * vec3(0.0, 0.0, 1.5);\n    \n    ro += vec3(0.5, 0.3, 0.77);\n    \n    o = colDepth(ro, rd);\n    \n    // fading animation\n    o.rgb *= smoothstep(16.0, 64.0, samples);\n    \n    \n    #if !GI_DEBUG_MODE\n    \n    // quick accumulation to remove a little bit of noise\n    \n    #ifdef HIGH_QUALITY\n    const float saticAcc = 0.9;\n    const float dynamicAcc = 0.2;\n    #else\n    const float saticAcc = 0.9;\n    const float dynamicAcc = 0.6;\n    #endif\n    \n    vec4 prev = texelFetch(iChannel1, ivec2(u), 0);\n    if (iMouse.z <= 0.0 && samples > 16.0)\n    {\n        o.rgb = mix(o.rgb, prev.rgb, saticAcc);\n        o.a = min(o.a, prev.a);\n    }\n    else\n    {\n        o.rgb = mix(o.rgb, prev.rgb, dynamicAcc);\n    }\n    \n    #endif\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stc3Ws.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[262, 262, 298, 298, 1804]], "test": "untested"}
{"id": "Nlt3Wf", "name": "playing with equirectangular", "author": "mds2", "description": "combination of a couple of old shaders to make an equirectangular scene", "tags": ["inessaith", "sithing", "hallere", "yourinthat", "thearold", "thersing", "ithearion"], "likes": 10, "viewed": 394, "published": 3, "date": "1636911380", "time_retrieved": "2024-07-30T18:48:11.242261", "image_code": "#define BLOCKSIZE 0.7\n\n#define EXTENT 15.0\n\n#define MULTI_SAMPLE 2 // do not set higher than 8\n\n#define DO_SUBSURFACE 1\n\nvec3 camera = vec3(55.0, 0.0, 0.0);\nmat3 dir_mat = mat3(1.0, 0.0, 0.0,\n                    0.0, 1.0, 0.0,\n                    0.0, 0.0, 1.0);\n\nconst float error_bound = 1.0e-3;\n\nconst float blocks_max_height = -1.15; // -1.75 + 0.6 + 0.25 * BLOCKSIZE\nconst float waffle_max_height = -1.75; // -2.0 + 0.1 + 0.15\n\nfloat waffle_sdf(in highp vec3 point) {\n\tvec3 local = vec3(abs(abs(mod(point.xz, BLOCKSIZE)) - vec2(0.5 * BLOCKSIZE)), point.y).xzy;\n    vec2 lr_dists = max(abs(local.xz) - 0.275 * BLOCKSIZE, 0.0);\n    float lr_dist = max(0.25 * BLOCKSIZE - length(lr_dists), 0.0);\n    float updist = abs(local.y + 2.0);\n    return length(vec3(lr_dist, max(updist - 0.1, 0.0), \n                       max(length(point - camera) - EXTENT, 0.0))) - 0.05;\n}\n\nfloat blocks_sdf(in highp vec3 point) {\n\tvec3 local = vec3(abs(abs(mod(point.xz, BLOCKSIZE)) - vec2(0.5 * BLOCKSIZE)),\n                      abs(point.y + 1.75)).xzy;\n    float samp_loc = mod(9.1 * dot(point.xz - mod(point.xz, BLOCKSIZE),\n                             vec2(0.173, 0.131)), 1.0);\n    float samp = texture(iChannel0, vec2(samp_loc, 0.0)).r;\n\tvec3 to_core = max(vec3(0.0), local - vec3(0.05, 0.1 + 1.0 * samp, 0.05));\n    return max(length(to_core), \n                       max(length(point - camera) - EXTENT, 0.0)) - 0.125 * (1.5 - samp) * BLOCKSIZE;\n}\n\nfloat grid_sdf(in highp vec3 point) {\n    return min(waffle_sdf(point), blocks_sdf(point));\n}\n\nvec3 waffle_grad(in highp vec3 point) {\n    float p = waffle_sdf(point);\n    return normalize(vec3(waffle_sdf(point + vec3(0.01, 0.0, 0.0)) - p,\n                          waffle_sdf(point + vec3(0.0, 0.01, 0.0)) - p,\n                          waffle_sdf(point + vec3(0.0, 0.0, 0.01)) - p));\n}\n\n\nvec3 blocks_grad(in highp vec3 point) {\n    float p = blocks_sdf(point);\n    return normalize(vec3(blocks_sdf(point + vec3(0.01, 0.0, 0.0)) - p,\n                          blocks_sdf(point + vec3(0.0, 0.01, 0.0)) - p,\n                          blocks_sdf(point + vec3(0.0, 0.0, 0.01)) - p));\n}\n\n\nfloat dist_to_grid(in highp vec3 point, in highp vec3 dir) {\n\tvec3 p = point;\n    float result = 0.0;\n    if (dir.y < -error_bound) {\n\t    float to_max = (point.y - waffle_max_height) / dir.y;\n    \tresult = to_max;\n    } else if (point.y > waffle_max_height + EXTENT * error_bound) {\n        return 2.0 * EXTENT;\n    }\n    p = p + result * dir;\n    for (int i = 0; i < 128; ++i) {\n    \tfloat d = 0.9 * waffle_sdf(p);\n    \tresult += d;\n        p = p + d * dir;\n        if (abs(d) < error_bound || result > 2.0 * EXTENT) {\n            return result;\n        }\n    }\n    return result;\n}\n\nfloat dist_to_blocks(in highp vec3 point, in highp vec3 dir) {\n\tvec3 p = point;\n    float result = 0.0;\n    if (dir.y < -error_bound) {\n        float to_max = (point.y - blocks_max_height) / dir.y;\n        result = to_max;\n    } else {\n        return 2.0 * EXTENT;\n    }\n    p = p + result * dir;\n    for (int i = 0; i < 96; ++i) {\n    \tfloat d = 0.8 * blocks_sdf(p);\n    \tresult += d;\n        p = p + d * dir;\n        if (abs(d) < error_bound || result > 2.0 * EXTENT) {\n            return result;\n        }\n    }\n    return result;\n}\n\nfloat dist_out_of_blocks(in highp vec3 point, in highp vec3 dir) {\n\tvec3 p = point;\n    float result = 0.0;\n    for (int i = 0; i < 64; ++i) {\n    \tfloat d = -0.9 * blocks_sdf(p);\n    \tresult += d;\n        p = p + d * dir;\n        if (abs(d) < error_bound) {\n            return result;\n        }\n    }\n    return result;\n}\n\nconst vec3 light1 = vec3(0.36, 0.48, -0.8);\n\nconst vec3 light2 = vec3(-0.48, 0.64, -0.6);\n\n\nvec4 getBackground(in vec3 ray_orig, in vec3 ray_dir) {\n\n    vec4 color_mul = vec4(1.0);\n\n    float d1 = dist_to_grid(ray_orig, ray_dir);\n    float d2 = dist_to_blocks(ray_orig, ray_dir);\n    vec3 n = ray_dir;\n    const float eta = 1.85;\n    vec3 subsurface = vec3(0.0);\n    if (d2 < d1 && d2 < 20.0) {\n        ray_orig = ray_orig + ray_dir * (d2 + 0.01);\n    \tn = blocks_grad(ray_orig);\n        vec3 next_ray_dir = refract(ray_dir, n, eta);\n        float l = length(next_ray_dir);\n\n        if (l > 0.1) {\n            ray_dir = next_ray_dir / l;\n        \td2 = dist_out_of_blocks(ray_orig, ray_dir);\n        \tcolor_mul *= mix(vec4(1.0, 0.9, 0.5, 1.0), vec4(1.0),\n                         exp(-2.0 * max(d2, 0.0)));\n        \tray_orig = ray_orig + d2 * ray_dir;\n       \t\tn = blocks_grad(ray_orig);\n        \tnext_ray_dir = refract(ray_dir, -n, 1.0/eta);\n            l = length(next_ray_dir);\n            if (l > 0.1) {\n                ray_dir = next_ray_dir / l;\n            }\n        } else {\n            ray_dir = normalize(reflect(ray_dir, n));\n        }\n        d1 = dist_to_grid(ray_orig, ray_dir);\n        const float subsurface_dist_mul = 150.0;\n#if DO_SUBSURFACE        \n        float d_light_1 = dist_out_of_blocks(ray_orig, light1);\n        float d_light_2 = dist_out_of_blocks(ray_orig, light2);\n#else\n        float d_light_1 = 1000.0 / subsurface_dist_mul;\n        float d_light_2 = d_light_1;\n#endif        \n        subsurface = vec3(1.0 / max(2.0, subsurface_dist_mul * d_light_1),\n                          0.0,\n                          1.0 / max(2.0, subsurface_dist_mul * d_light_2));\n        subsurface.g = 0.5 * (subsurface.b + subsurface.r);\n        \n    }\n    vec3 bounce = ray_dir;\n    if ( d1 < 20.0) {\n        vec3 p = ray_orig + ray_dir * d1;\n        n = waffle_grad(p);\n        bounce = normalize(reflect(ray_dir, n));\n        color_mul *= vec4(vec3(0.6, 0.6, 0.7), 1.0);\n    }\n    \n    float diffuse1 = max(dot(n, light1), 0.0) + 0.1;\n    float diffuse2 = 0.4 * max(dot(n, light2), 0.0) + 0.1;\n    float spec1 = smoothstep(0.9, 1.0, dot(bounce, light1));\n    float spec2 = smoothstep(0.8, 0.9, dot(bounce, light2));\n    \n    return vec4(subsurface, 0.0) +\n        color_mul * vec4((diffuse1 + spec1) * vec3(1.0, 0.5, 0.0) +\n                         (diffuse2 + spec2) * vec3(0.0, 0.5, 1.0), 1.0);\n}\n\n\nvec4 castRayUFO(in vec3 ray_orig, in vec3 ray_dir, in float time) {\n    \n    float wiggle = abs(mod(0.2 * time, 4.0) - 2.0) - 1.0;\n    wiggle = sign(wiggle) * smoothstep(0.0, 1.0, abs(wiggle));\n    float ct = sin(wiggle);\n    float st = cos(wiggle);\n    mat3 twist = mat3(ct, 0.0, st,\n                      0.0, 1.0, 0.0,\n                      -st, 0.0, ct);\n    // ray_dir = twist * ray_dir;\n    // ray_orig = twist * ray_orig;\n    wiggle = 0.1 * sin(time);\n    ct = cos(wiggle);st = sin(wiggle);\n    twist = mat3(ct, st, 0.0,\n                 -st, ct, 0.0,\n                 0.0, 0.0, 1.0) * twist;\n    wiggle = 0.1 * sin(0.71 *time + 1.3);\n    ct = cos(wiggle);st = sin(wiggle);\n    twist *= mat3(1.0, 0.0, 0.0,\n                  0.0, ct, st,\n                 0.0, -st, ct) * twist;\n\n    // ray_dir = twist * ray_dir;\n    // ray_orig = twist * ray_orig;\n    \n    vec3 orig_offset = vec3(0.0, 0.2, 1.5) -\n        sin(vec3(4.2, 1.2, 3.4) * time) * vec3(0.5, 0.1, 0.2);\n    float closeness = MAX_DIST;\n    float d = cast_to_vehicle2(twist * (ray_orig - camera) - orig_offset, twist * ray_dir, closeness);\n    \n    vec3 ray_mul = vec3(1.0);\n    \n    if (d > MAX_DIST) {\n        orig_offset = vec3(0.0, 0.2, -2.1) -\n            sin(vec3(4.2, 1.2, 3.4) * time) * vec3(0.5, 0.1, 0.2);\n        float closeness2 = MAX_DIST;\n        d = cast_to_vehicle2(twist * (ray_orig - camera) - orig_offset, twist * ray_dir, closeness2);\n        closeness += closeness2;\n    }\n    if (d < MAX_DIST) {\n        vec3 pt = ray_orig + d * ray_dir;\n        float edginess = 0.0;\n        ray_dir = transpose(twist) * get_bounce2(twist * (pt - camera) - orig_offset, twist * ray_dir, edginess);\n        ray_mul = mix(vec3(1.0, 0.9, 0.85), ray_mul, 1.0); // edginess);\n        ray_orig = pt;\n    }\n\n    vec3 thump = 0.5 + 0.5 * sin(vec3(0.1, 0.21, 0.33) * time);\n    thump = smoothstep(0.5, 1.0, thump);\n#if INTENSE_FLASH\n    thump *= 0.5 + 0.75 * smoothstep(vec3(0.0), vec3(1.0), thump);\n#else\n    thump *= 0.85 + 0.15 * smoothstep(vec3(0.0), vec3(1.0), thump);\n#endif\n    float darken = 0.15 * (1.0 + 3.0 * smoothstep(1.5, 0.5, dot(thump, vec3(1.0))));\n    return vec4(1.0 * darken * ray_mul * getBackground(ray_orig, ray_dir).rgb +\n                (0.25 + 1.75 * smoothstep(0.05, 0.8, thump))\n                * falloff(closeness, 0.5), 1.0);\n}\n\nvec4 getSample(in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.xy;\n\n    vec3 ray_orig = camera; // vec3(0.0, 0.0, -1.0); // sin(iTime));\n    \n    const float pi = 3.141592654;\n    float cy = sqrt(1.0 - min(1.0, 4.0 * uv.y * uv.y));\n    vec3 ray_dir = vec3(cos(2.0 * pi * uv.x) * cy,\n        sin(2.0 * pi * uv.x) * cy,\n        2.0 * uv.y);\n    ray_dir = ray_dir.yzx;\n    ray_dir = dir_mat * ray_dir;\n    return castRayUFO(ray_orig, ray_dir, iTime); // getBackground(ray_orig, ray_dir);\n}\n\n/*\nvec2 offsets[8] = vec2[8](vec2(-0.4, -0.4), \n                         vec2(-0.45, 0.1),\n                         vec2(-0.4, 0.4),\n                         vec2(0.1, 0.45),\n                         vec2(0.4, 0.4),\n                         vec2(0.45, -0.1),\n                         vec2(0.4, -0.4),\n                         vec2(0.0, 0.0)); */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 result = vec4(0.0);\n    \n    float c_theta = cos(0.025 * iTime);\n    float s_theta = sin(0.025 * iTime);\n\n    camera = mat3(c_theta, 0.0, s_theta,\n                  0.0, 1.0, 0.0,\n                  -s_theta, 0.0, c_theta) * camera;\n    \n    dir_mat = mat3(-c_theta, 0.0, -s_theta,\n                   0.0, 1.0, 0.0,\n                   s_theta, 0.0, -c_theta);\n    \n    float nsamps = 0.0;\n    \n    result += getSample(fragCoord + vec2(-0.4));\n    nsamps += 1.0;\n    \n    if (MULTI_SAMPLE > 1) {\n\t    result += getSample(fragCoord + vec2(0.1, 0.45));\n    \tnsamps += 1.0;\n    }\n    \n    if (MULTI_SAMPLE > 2) {\n\t    result += getSample(fragCoord + vec2(0.45, -0.1));\n    \tnsamps += 1.0;\n    }        \n    \n    /*\n    for (int i = 0; i < 8; i += max(8 / MULTI_SAMPLE, 1)) {\n        result += getSample(fragCoord + offsets[i]);\n    \tnsamps += 1.0;\n    }\n*/\n    \n    fragColor = result / nsamps;\n}\n", "image_inputs": [{"id": 20, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define INTENSE_FLASH 1\n\n#define MAX_DIST 8.0\n\n#define SKY_BRITE 0.6\n\n#define CRINKLY_SHIP 0 // set to 1 to give the ship some texture\n\n\nfloat s_min(in float x, in float y, in float s) {\n\n    float bridge =\n        clamp(abs(x-y)/s, 0.0, 1.0);\n    return min(x,y) - 0.25 * s * (bridge - 1.0) * (bridge - 1.0);\n}\n\nfloat s_max(in float x, in float y, in float s) {\n    float bridge =\n        clamp(abs(x-y)/s, 0.0, 1.0);\n    return max(x,y) + 0.25 * s * (bridge - 1.0) * (bridge - 1.0);\n}\n\nfloat falloff(in float x, in float range) {\n    float h = smoothstep(range, 0.0, 1.0/x);\n    return h * 0.1 * range / s_max(0.1 * range, 1.0/x, 0.05 * range);\n}\n\nvec3 perturb2(in vec3 loc) {\n    return loc;\n}\n\nfloat vehicle_sdf2(in vec3 loc) {\n    float ball1 = length(loc - vec3(0.0, -1.8, 0.0)) - 2.0;\n    float ball2 = length(loc - vec3(0.0, 2.0, 0.0)) - 2.1;\n    float disc = s_max(ball1, ball2, 0.05);\n    float ball3 = length(loc - vec3(0.0, 0.07, 0.0)) - 0.2;\n    float result = s_min(disc, max(ball3, -loc.y), 0.1);\n    float mult = 1.0; // texture(iChannel1, loc).r;\n#if CRINKLY_SHIP    \n    mult = 1.0 + 0.95 * mult;\n#else\n    mult = 1.0 + 0.95 * mult * smoothstep(0.025, 0.05, result);    \n#endif\n    return result * mult;\n}\n\nvec3 vehicle_sdf2_grad(in vec3 loc) {\n    float dist = vehicle_sdf2(perturb2(loc));\n    const float del = 0.01;\n    return vec3(vehicle_sdf2(perturb2(loc + vec3(del, 0.0, 0.0))) - dist,\n                vehicle_sdf2(perturb2(loc + vec3(0.0, del, 0.0))) - dist,\n                vehicle_sdf2(perturb2(loc + vec3(0.0, 0.0, del))) - dist) / del;\n}\n\n\nfloat cast_to_vehicle2(in vec3 orig, in vec3 dir, out float sumdist) {\n    vec3 p = orig;\n    float accum = 0.0;\n    sumdist = 0.0;\n    for (int i = 0; i < 256; ++i) {\n        float dist = vehicle_sdf2(p);\n        // mindist = min(dist, mindist);\n    \tfloat remaining = 0.2 * dist;\n        sumdist += remaining / max(1.0e-3, abs(dist));\n        accum += remaining;\n        p = orig + accum * dir;\n        p = perturb2(p);\n        if (remaining < 1.0e-3) {\n            return accum;\n        }\n        if (accum > MAX_DIST) {\n            return accum;\n        }\n    }\n\treturn max(accum, MAX_DIST + 1.0);\n}\n\nvec3 get_bounce2(in vec3 pt, in vec3 dir, out float edge_term) {\n    vec3 norm = normalize(vehicle_sdf2_grad(pt));\n    edge_term = smoothstep(0.7, 0.3, abs(dot(normalize(dir), norm)));\n    return normalize(reflect(dir, norm));\n}\n\n\nvec3 skyColor(in vec3 dir) {\n  return vec3(1.0); // TODO : fix\n  }\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlt3Wf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3665, 3665, 3720, 3720, 5987], [5990, 5990, 6057, 6057, 8308], [8310, 8310, 8346, 8346, 8833], [9182, 9182, 9239, 9239, 10140]], "test": "untested"}
{"id": "flc3W8", "name": "sdf soft shadow", "author": "WingStone", "description": "https://iquilezles.org/articles/rmshadows/rmshadows.htm", "tags": ["sdfshadow"], "likes": 2, "viewed": 272, "published": 3, "date": "1636907838", "time_retrieved": "2024-07-30T18:48:12.110938", "image_code": "#define SPH_POS vec3(0.0,-2.5,6.0)\n#define SPH_R 2.0\n#define K 15.0\n#define LIGHT_DIR vec3(1.5, 1.0, 0.0)\n\nfloat map(vec3 pos)\n{\n    return distance(pos, SPH_POS)-SPH_R;\n}\n\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        t += h;\n    }\n    return 1.0;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nfloat softshadowplus( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy)/ iResolution.y;\n    vec3 screenPos = vec3(uv, 1.0);\n    screenPos.y -= 0.5;\n    vec3 dir = normalize(screenPos);\n    \n    // plane\n    float height = -5.0;\n    vec3 pos = dir.y < 0.0? vec3(height/dir.y*dir.x, height, height/dir.y*dir.z) : vec3(0.0);\n\n    vec3 lightdir = normalize(LIGHT_DIR);\n    \n    float sw = softshadow(pos, lightdir,0.0, 10.0, K);\n    //float sw = shadow(pos, lightdir,0.0, 10.0);\n    float col = sw+0.5;\n    col *= dir.y < 0.0 ? exp(-0.04*length(pos)) : 0.0;\n    \n    // sphere\n    vec3 odir = normalize(SPH_POS);\n    float d2 = dot(SPH_POS,SPH_POS);\n    float co = dot(dir, odir);\n    if( co > sqrt(1.0- SPH_R*SPH_R/d2))\n    {\n      vec3 pos = dir*(sqrt(d2)*co - sqrt(SPH_R*SPH_R- d2 + co*co*d2));\n      vec3 normal = normalize(pos - SPH_POS);\n      col = max(0.0, dot(lightdir, normal))+0.5;\n      col *=  exp(-0.04*length(pos));\n    }\n    \n    col*= 1.3;\n    col = col/(1.0+col);\n    \n    fragColor = vec4(col, col, col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flc3W8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 128, 128, 171], [173, 173, 237, 237, 396], [398, 398, 475, 475, 688], [690, 690, 771, 771, 1097], [1099, 1099, 1156, 1156, 2160]], "test": "untested"}
{"id": "Nl33Dl", "name": "Persian mosaic 3", "author": "jarble", "description": "A fractal pattern that looks like a mosaic.", "tags": ["fractal", "glass", "mosaic", "ceramic"], "likes": 2, "viewed": 245, "published": 3, "date": "1636904262", "time_retrieved": "2024-07-30T18:48:13.231941", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);    \n    vec3 col;  \n    float t1 = 4.5/4.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime/2.+uv.x)/10.0);\n    vec3 random1 = (hash31(4.+t2)-.5)/8.;\n    vec3 random2 = (hash31(5.+t2)-.5)/8.;\n    //vec3 random3 = (hash31(3.+t2)-vec3(.5))/4.;\n    //vec3 random4 = (hash31(4.+t2)-vec3(.5))/4.;\n    \n    float offset = .5;\n    float scale2 = 1.5;\n    float bend = 1.+1./3.;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        //float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            //float bend = 1.;\n            \n\n            for(int k = 0; k < 3; k++){       \n                uv /= -scale2;\n                //uv += vec2(random1[k],random2[k]).yx;\n                //float bend = 1.;\n                uv.yx = triangle_wave(uv.yx-offset,scale)*bend+triangle_wave(uv,scale)/bend;\n                //bend = (((uv.x-uv.y)))/3.+1.+1./3.;\n                bend *= -1. + (uv.y+uv.x)/8.;\n                uv += vec2(random1[k]*bend,random2[k]/bend);            \n            }\n            //uv -= uv.yx;\n            \n\n            //offset += .5;\n            scale /= 1.+(scale2)*col.x/8.;\n            scale2 -= (col.x-1.)/4.;\n\n\n            col[c] = (abs((uv.x)-(uv.y)+col[c]));\n            //col = col.yzx;\n            //random2 = col - random2;\n            \n\n        }\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl33Dl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [590, 590, 629, 629, 674], [676, 676, 733, 733, 2300]], "test": "untested"}
{"id": "7tt3Df", "name": "Wave Types", "author": "ircss", "description": "visualisation for some wave types and using it for animation ", "tags": ["waves", "shapingfuncitons"], "likes": 7, "viewed": 296, "published": 3, "date": "1636900539", "time_retrieved": "2024-07-30T18:48:13.998890", "image_code": "#define xAxisCol vec3(0.925, 0.361, 0.227)\n#define backGroundCol vec3(0.925, 0.878, 0.824)\n#define outline vec3(0.306, 0.224, 0.22)\n#define blueCol vec3(0.176, 0.431, 0.784)\n\nvoid DrawHalfVector(vec2 origin, vec2 vector, vec2 uv, float size, vec3 lineColor, inout vec3 sceneColor){\n    \n          uv  -= origin;\n    float v2   = dot(vector, vector);\n    float vUv  = dot(vector, uv);\n    vec2  p    = vector * vUv/v2;\n    float d    = distance(p, uv);\n    float m    = 1. - step(0.,vUv/v2);\n    sceneColor = mix(lineColor, sceneColor, clamp(smoothstep(size, size + 0.001, d)+ m, 0. ,1.)); \n}\n\nvoid DrawPoint(vec2 pos, vec2 uv,float size, vec3 dotColor, inout vec3 sceneColor){\n    \n    float d    = distance(uv, pos);\n    sceneColor = mix(dotColor, sceneColor, smoothstep(size, size + 0.001, d));\n    \n}\n\n\nvoid DrawHalfVectorWithLength(vec2 origin, vec2 vector, float len, vec2 uv, float size, vec3 lineColor, inout vec3 sceneColor){\n    \n          uv  -= origin;\n    float v2   = dot(vector, vector);\n    float vUv  = dot(vector, uv);\n    vec2  p    = vector * vUv/v2;\n    float d    = distance(p, uv);\n    float m    = 1. - step(0.,vUv/v2);\n          m   += step(len, vUv/v2);\n    sceneColor = mix(lineColor, sceneColor, clamp(smoothstep(size, size + 0.001, d)+ m, 0. ,1.)); \n}\n\nfloat waveFunction(float x, float period, float amplitude)\n{\n\n  return (abs(fract(((x * period + iTime)/ (3.14 *2.)) ) *2. - 1. ))*amplitude;\n  return (sin((x * period+ iTime) ) *0.5 + 0.5 )*amplitude;\n}\n\nvoid DrawSinWave(vec2 origin, vec2 uv, float size, vec3 lineColor,float amplitude, float period, inout vec3 sceneColor)\n{\n  uv -= origin;\n\n  float cut = 1.- step(0., uv.x);\n  sceneColor= mix(lineColor , sceneColor, clamp(cut + step(size, abs( waveFunction(uv.x, period, amplitude) - uv.y)), 0., 1.));\n  vec2 currentPos = vec2(0., waveFunction(0., period, amplitude));\n  \n  DrawPoint(currentPos,\n           uv, 0.008, blueCol, sceneColor);\n           \n  DrawHalfVectorWithLength(vec2(-0.2, 0.), vec2(0., amplitude*2.), 0.5, uv, 0.0025, outline, sceneColor);\n  \n  vec2 vecTOControl = vec2(-0.2, currentPos.y) - currentPos; \n  \n  DrawHalfVectorWithLength(currentPos, normalize( vecTOControl), length(vecTOControl), uv, 0.001, blueCol, sceneColor);\n  \n    DrawPoint(vec2(-0.2, currentPos.y) ,\n           uv, 0.015, blueCol, sceneColor);\n           \n      DrawPoint(vec2(-0.45, 0.1), uv, 0.21, blueCol, sceneColor);    \n  DrawPoint(vec2(-0.45, 0.1), uv, 0.2, vec3(currentPos.y/(amplitude)), sceneColor);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv.x = uv.x * (iResolution.x/ iResolution.y);\n    \n    vec2 midPoint = vec2(0.5 * iResolution.x/ iResolution.y, 0.5);\n\n    vec3 col = backGroundCol;\n\n    DrawHalfVector(midPoint - vec2(0.2,0.2), vec2(1., 0.), uv, 0.003, outline, col);\n    \n    \n    DrawSinWave(midPoint - vec2(0.2,0.2), uv, 0.003, xAxisCol, 0.3, 10., col);\n \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tt3Df.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[175, 175, 281, 281, 591], [593, 593, 676, 676, 803], [806, 806, 933, 933, 1279], [1281, 1281, 1341, 1341, 1484], [1486, 1486, 1607, 1607, 2486], [2489, 2489, 2546, 2596, 3000]], "test": "untested"}
{"id": "7dXGD8", "name": "2D Distance Clipping", "author": "kick", "description": "clipping successive shapes on minimum distance.  Simple.  A lot more eye candy could be done here.", "tags": ["sdf"], "likes": 11, "viewed": 405, "published": 3, "date": "1636899332", "time_retrieved": "2024-07-30T18:48:14.933392", "image_code": "#define r(x) fract(sin(x*12.9898)* 43758.5453123)\n#define rs(x) (r(x)*2.-1.)\n#define t iTime\n#define NOCLIP false\n#define I 7\n\nfloat lineWidth;\n\n#define glow(x,f) (1. - pow(smoothstep(0.,(f)*lineWidth,abs(x)),0.2))\n\n// Misc Functions\n\nvoid pR(inout vec2 p,float a) {\n\tp=cos(a)*p+sin(a)*vec2(p.y,-p.x);\n}\n\nvec3 pal(float t) {\n\treturn (0.5+0.5*cos(3.*(1.*t+vec3(0,0.33,0.67))));\n}\n\n// 2D Functions\n\n// IQ's distance to line segment\nfloat sdSegment2( vec2 p, vec2 a, vec2 b ) {\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nvec3 get2dColor( vec2 p ) {\n  vec3 color = vec3(0), c; float d, md=1e2;\n  vec4 l;\n  for( int i=0; i < I; i++ ) {\n    float a = r(float(i)+112.);\n    l = vec4(rs(a+1.),rs(a+2.1),rs(a+3.8),rs(a+6.7))*2.;\n    c = vec3(rs(a+1.),rs(a+2.1),r(a+3.8)*1.5+0.2);\n    pR(l.xy, t*l.x);\n    pR(l.zw, -t*l.z*0.1);\n    d = sdSegment2(p, l.xy, l.zw);\n    if(NOCLIP || d<md){ md = d; color += glow(d, 10.) * (0.5+0.5*cos(3.*(1.*length(l.xz)+vec3(0,0.33,0.67)))); }\n    c.z *= sin(t*(c.z*c.x*2.1+0.1))*0.5+0.7;\n    pR(c.xy,t*c.y);\n    d = dot(p-c.xy,p-c.xy) - c.z;\n    if(NOCLIP || d<md){ md = d; color += glow( d, 10. ) * (0.5+0.5*cos(3.*(1.*c.z*2.+vec3(0,0.33,0.67)))); }\n  }\n  return color;\n}\n\nvoid mainImage( out vec4 oc, in vec2 p ) {\n  float minD = min(iResolution.x, iResolution.y);\n  float maxD = max(iResolution.x, iResolution.y);\n  lineWidth = minD*0.0003;\n  vec2 st = 2.*(p-iResolution.xy*0.5) / maxD;\n\n  vec3 col = get2dColor( 2.*(st) );\n\n  oc = vec4(col*1.0,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dXGD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[235, 235, 266, 266, 303], [305, 305, 324, 324, 378], [397, 430, 474, 474, 587], [589, 589, 616, 616, 1266], [1268, 1268, 1310, 1310, 1547]], "test": "untested"}
{"id": "sdl3WM", "name": "Ray Bender", "author": "kick", "description": "Bending camera rays by treating them as particles whose velocity is affected by their pseudo-mass, their normal trajectory in the 3d camera plane. The spheres are the gravity \"nodes\".  Three iterations is enough for the simulation to get smooth results.", "tags": ["analytic", "gravity", "raybending"], "likes": 10, "viewed": 403, "published": 3, "date": "1636898814", "time_retrieved": "2024-07-30T18:48:15.920752", "image_code": "#define PI 3.14159265\n#define ut (iTime * 1.)\n#define n(x) normalize(x)\n#define l(x) length(x)\n#define f(x) fract(x)\n#define v3 vec3(0)\n#define sb 0.5\n#define rv(x) (vec2(cos(x),sin(x)))\n\n#define USE_TEXTURE\n\nfloat t;\nvec2 m, tc1, tc2, tc3;\n\nfloat pD(vec3 ro,vec3 rd,vec4 p) {\n\treturn -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nvec4 pI(vec3 ro,vec3 rd,vec4 p) {\n\tfloat d=pD(ro,rd,p);\n\treturn vec4(ro+rd*d,d);\n}\n\nfloat sD(vec3 ro,vec3 rd,vec4 sph) {\n\tvec3 oc=ro-sph.xyz;\n\tfloat b=dot(oc,rd), c=dot(oc,oc)-sph.w*sph.w, h=b*b-c;\n\tif(h<0.0) return -1.0;\n\treturn -b-sqrt(h);\n}\n\nvec4 sI(vec3 ro,vec3 rd,vec4 sph) {\n\tvec4 i=vec4(-1.);\n\tfloat d=sD(ro,rd,sph);\n\tif(d > 0.) { i.xyz=ro+rd*d; i.w=d; }\n\treturn i;\n}\n\nvec4 pl, pl2, s, s2;\n\nvoid cv(inout vec3 pos,inout vec3 vel) {\n\tvec3 h=s.xyz-pos,h2=s2.xyz-pos;\n\tvel+=n(h)/dot(h,h)+n(h2)/dot(h2,h2); pos+=vel;\n}\n\nvec4 i2p(vec3 ro,inout vec3 v) {\n\tvec3 pos=ro;\n\tcv(pos,v); cv(pos,v); cv(pos,v);\n\tcv(pos,v); cv(pos,v); cv(pos,v);\n\treturn pI(ro,n(v),pl);\n}\n\nvec3 pal(float t) {\n\t// return vec3(1.);\n\tt=(t-ut*0.08);\n\treturn abs(vec3(0.5,0,0.5)+0.5*cos(15.*(1.*t+vec3(0,0.33,0.67))));\n}\n\n// vec3 pal(float t) {\n// \treturn (0.5+0.5*cos(3.*(1.*t+vec3(0,0.33,0.67))));\n// }\n\nfloat tex(vec2 uv) {\n#ifdef USE_TEXTURE\n    return dot(texture(iChannel0,uv*0.25).rgb,vec3(0.333));\n#else    \n\treturn mix(1.-l(f(uv)*2.-1.),0.25,min(l(fwidth(uv)),1.));\n#endif\n}\n\nvec3 pC(vec4 pi, vec4 p) {\n\tvec3 c=vec3(0);\n\tif(pi.w<0.) return c;\n\tc += tex(pi.xy+vec2(t,tc1.y)*vec2(sign(pi.z)));\n\tpi.w=dot(n(vec3(0,0,1)),n(vec3(pi.xy,1)));\n\tc *= pal(f(-pi.w));\n\tfloat sl=1./min(pow(sD(pi.xyz,n(s.xyz-pi.xyz),s),2.),10.);\n\tfloat sl2=1./min(pow(sD(pi.xyz,n(s2.xyz-pi.xyz),s2),2.),10.);\n\tc *= (sl+sl2)*1.;\n\tif(p==pl) c+=pow(dot(n(vec3(pi.xy,1)),pl.xyz),16.);\n\t// c *= pow(pi.w,0.5);\n\treturn pow(c,vec3(0.666));\n}\n\nvoid pR(inout vec2 p,float a) {\n\tp=cos(a)*p+sin(a)*vec2(p.y,-p.x);\n}\n\nvec3 sC(vec4 sp,vec4 si,vec3 ro) {\n\tvec3 sc=v3, c, c2;\n\tvec3 n=n(si.xyz-sp.xyz),ci=n(si.xyz-ro);\n\tvec3 lp=0.-(pl.xyz*pl.w),l=n(lp-si.xyz);\n\tsc += max(0.,dot(l,n)) * 0.5;\n\n\tvec3 r=reflect(ci,n);\n\tvec4 pi=pI(si.xyz,r,pl), pi2=pI(si.xyz,r,pl2);\n\tc = mix(sc,pC(pi,pl),sb);\n\tc2 = mix(sc,pC(pi2,pl2),sb);\n\tfloat md = pi.w;\n\tif( pi2.w > pi.w ) { c = c2; md = pi2.w; }\n\n\tvec4 so=s;\n\tif(sp.x == s.x) so = s2;\n\tsp=so; ro=si.xyz; si=sI(si.xyz,n(r),so);\n\n\tif( si.w > 0. && si.w < md ) {\n\t\tvec3 osc=v3, osc2 = v3;\n\t\tn=n(si.xyz-sp.xyz),ci=n(si.xyz-ro);\n\t\tlp=-(pl.xyz*pl.w),l=n(lp-si.xyz);\n\t\tosc += max(0.,dot(l,n)) * 0.5;\n\t\tr=reflect(ci,n);\n\t\tpi=pI(si.xyz,r,pl),pi2=pI(si.xyz,r,pl2);\n\t\tosc = mix(osc,pC(pi,pl),sb);\n\t\tosc2 = mix(osc,pC(pi2,pl2),sb);\n\t\tif( pi2.w > pi.w ) { osc = osc2; }\n\t\tc = mix(sc,osc,sb);\n\t}\n\treturn c;\n}\n\nvec3 gPC(vec2 uv) {\n\tvec3 ro=vec3(0,7.2,0), rd=n(vec3(uv*2.,-1.0));\n\tvec3 c=v3;\n\tpR(rd.yz,PI*(m.y-0.5));\n\tpR(rd.xy,2.*PI*(m.x-0.5));\n\n\tvec4 pi=i2p(ro,rd), pi2=pI(ro,n(rd),pl2);\n\tvec4 sip=sI(ro,n(rd),s2), si=sI(ro,n(rd),s);\n\tfloat md=1e10;\n\tif(sip.w>0. && sip.w<md) {md=sip.w; c=sC(s2,sip,ro);}\n\tif(si.w>0. && si.w<md) {md=si.w; c=sC(s,si,ro);}\n\tif(pi2.w>0. && pi2.w<md) {md=pi2.w; c+=pC(pi2,pl2);}\n\tif(pi.w>0. && pi.w<md) {md=pi.w; c+=pC(pi,pl);}\n\tc *= exp( -0.05*md );\n\n\treturn c;\n}\n\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  m=iMouse.xy / iResolution.xy * vec2(1,-1);\n  t=ut*0.2;\n  tc1=rv(t*PI*0.5);\n  tc2=rv(t*PI);\n  tc3=rv(ut*PI*0.125);\n  pl=vec4(n(vec3(0, 0, 3)),3.9);\n  pl2=vec4(n(vec3(0,0,-1)),1.9);\n  s=vec4(5.5*tc3.x,5.5*-tc3.y,0.+4.*tc2.x,1.9);\n  s2=vec4(-s.x,-s.y,0.-4.*tc2.x,1.9);\n\n\n  vec2 uv=(fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n  vec2 q = fragCoord.xy / iResolution.xy;\n  vec3 col = gPC(uv.xy);\n\t//-----------------------------------------------------\n  // postprocess\n  //-----------------------------------------------------\n\n  // gama\n  col = pow( col, vec3(0.44,0.5,0.55) );\n\n  // contrast\n  col = mix( col, smoothstep( 0.0, 1.0, col ), 0.5 );\n\n  // saturate\n  col = mix( col, vec3(dot(col,vec3(0.333))), -0.2 );\n\n  // vigneting\n  col *= 0.2 + 0.8*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.2);\n\n  // dithering\n  col += (1.0/255.0)*hash3(q.x+13.3214*q.y);\n\n\tfragColor=vec4(col,1.);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdl3WM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[242, 242, 276, 276, 322], [324, 324, 357, 357, 406], [408, 408, 444, 444, 567], [569, 569, 604, 604, 698], [722, 722, 762, 762, 845], [847, 847, 879, 879, 987], [989, 989, 1008, 1029, 1115], [1201, 1201, 1221, 1221, 1378], [1380, 1380, 1406, 1406, 1809], [1811, 1811, 1842, 1842, 1879], [1881, 1881, 1915, 1915, 2690], [2692, 2692, 2711, 2711, 3175], [3177, 3177, 3200, 3200, 3256], [3258, 3258, 3315, 3315, 4199]], "test": "untested"}
{"id": "stt3Wf", "name": "Debug Grid IDs", "author": "iY0Yi", "description": "Debug Grid IDs in 3D.\nThe grid may be nested, complexly offset, or\nIf they are correlated, this may be useful.\nIn fact, it saved me a lot of trouble.\n\nMore simpler usage scene of sdNumFont() is here:\nhttps://www.shadertoy.com/view/Ntc3Wf", "tags": ["neighbors"], "likes": 14, "viewed": 383, "published": 3, "date": "1636884031", "time_retrieved": "2024-07-30T18:48:16.948005", "image_code": "vec3 quat_rotate(vec4 quat, vec3 dir)\n{\n    return dir + 2.0 * cross(quat.xyz, cross(quat.xyz, dir) + quat.w * dir);\n}\nvoid camera(vec2 uv)\n{\n    const float cL = 25.;\n    const vec3 forcus = vec3(0,-5,0);\n    const float fov = .25;\n\n    vec3 up = vec3(0,1,0);\n    vec3 pos = vec3(0,1.5,0);\n    pos.xz = vec2(0)*cL;\n    pos.xz-=vec2(-iTime,iTime);\n    if(iMouse.z>.5)\n        pos.xz = vec2(sin(iMouse.x/iResolution.x*TAU),cos(iMouse.x/iResolution.x*TAU))*cL;\n        \n    \n    vec3 dir = normalize(forcus-pos);\n    vec3 target = pos-dir;\n    vec3 cw = normalize(target - pos);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n\n    mat3 camMat = mat3(cu, cv, cw);\n    ray.direction = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n\n    ray.origin = pos;\n}\n\n// scene: Shapes.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// I forgot where I found these bx_cossin()...\nvec2 bx_cos(vec2 a){return clamp(abs(mod(a,8.0)-4.0)-2.0,-1.0,1.0);}\nvec2 bx_cossin(float a){return bx_cos(vec2(a,a-2.0));}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// More simpler usage scene of sdNumFont() is here:\n// https://www.shadertoy.com/view/Ntc3Wf\nfloat sdNumFont(vec3 p, float s, float w, float i) {\n    i = mod(floor(i), 10.); // 0-9\n    vec2 uv = p.xy/s +vec2(i, 12); // Numbers are in 12 row of Font texture.\n    \n    // https://www.shadertoy.com/view/llcXRl\n    // Sample the font texture. Make sure to not use mipmaps.\n    vec4 tx = texture(iChannel0, (uv+.5)*(1./16.));\n    float ch = tx.w - .5 - .025 * min(1.,(w/10.)*2.-1.);\n    \n    vec3 q = abs(p)-vec3(s,s*.8,.15*s)*.5;\n    float bb =  length(max(vec3(0.),q));\n    return max(ch, bb)*.7;\n}\n\nfloat sdID(vec3 p, float id) {\n    float num = id;\n    const float fontSize = .4;\n    const float fontWeight = 8.; // 1 to 10\n    const float spacing = .25;\n    float ppd = sdNumFont(p+vec3(3,0,0)*spacing*fontSize, fontSize, fontWeight, num*.01);\n    float pd = sdNumFont(p+vec3(1,0,0)*spacing*fontSize, fontSize, fontWeight, num*.1);\n    float nd = sdNumFont(p-vec3(1,0,0)*spacing*fontSize, fontSize, fontWeight, num);\n    return min(ppd,min(pd,nd));\n}\n\nvec4 sdScene(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n    \n    #if 1\n    float rad = .2;\n    #else // animate radius. they can't move at raius 1.0.\n    float rad = abs(sin(3.14+iTime*.1))*0.9+.1;\n    #endif\n    \n    vec3 q = p;\n    q.xz = mod(q.xz,1.);\n    \n    #if 1 // Spheres.\n        q.y-= rad;\n    #else // Shrink the height. You can see more clearly the range of movement of each sphere.\n        q.y-= rad*.1;\n        q.y*=4.;\n    #endif\n    \n    float speed = 2.;\n    vec3 pm=MAT_ERNST2;\n    for(int i=-1; i<1; i++)\n    for(int j=-1; j<1; j++)\n    {\n        vec2 offset = vec2(i,j);\n        vec3 qq = q;\n        vec2 iqq = floor((p.xz-offset));\n        vec2 rnd = hash22(iqq);\n        \n        qq.xz+=offset;\n        float v =  rnd.x * iTime * speed * sign(rnd.y-rnd.x); \n        vec2 sq = bx_cossin(v)*(1.-rad/* max range is ±(cellSize-Radius) */);\n        qq.xz+= sq;\n        \n        //qq.y-=.25*abs(sin(rnd.x*3.+iTime*3.*4.)); // jumping. just for fun.\n        \n        #if 0 // reduce population\n        if(rnd.y<.1 || rnd.x<.1)\n        #endif\n        {\n            vec2 iq = abs(floor((p.xz-offset)));\n            iq = vec2(int(iq.x)%2, int(iq.y)%2);\n            float tile = (iq.x==0. || iq.y==0.) ? (iq.x==1. || iq.y==1.) ? 1. : .05 : .05;\n            vec3 m = (rnd.y<.5) ? (tile<.5)?MAT_ERNST0:MAT_ERNST3 : (tile<.5)?MAT_ERNST1:MAT_ERNST4;\n\n            res = v4OpUnionSmooth(vec4(length(qq)-rad, m), res, .01);\n            /*\n            if(sat(sin(iTime*.5))>0.){\n                //pm = mix(pm,m,.5);\n                res = v4OpUnion(vec4(sdCapsule(qq, vec3(0), vec3(sq.x, -rad, sq.y), .01), m), res);\n                res = v4OpUnion(vec4(length(q+vec3(i,rad,j))-.05, m), res);\n            }\n            //*/\n        }\n    }\n\n    vec2 iqq = floor(p.xz);\n    vec2 rnd = hash22(iqq);\n    res = v4OpUnion(vec4(sdID(q-vec3(.5,.3,.5), iqq.x),vec3(0.996,0.224,0.224)), res);\n    res = v4OpUnion(vec4(sdID(q-vec3(.5,.0,.5), iqq.y),vec3(0.149,0.788,0.192)), res);\n\n    vec2 iq = abs(floor((p.xz)));\n    iq = vec2(int(iq.x)%2, int(iq.y)%2);\n    float tile = (iq.x==0. || iq.y==0.) ? (iq.x==1. || iq.y==1.) ? 1. : .85 : .85; \n    res = v4OpUnion(vec4(p.y, pm*tile),res);\n    \n\treturn res;\n}\n\nvec4 intersect(){\n\tfloat d = 1.;\n\tvec3  m = MAT_VOID;\n\tfor (int i = ZERO; i < ITERATION+ZERO; i++){\n\t\tvec4 res = sdScene(ray.origin + d * ray.direction);\n\t\tm = res.yzw;\n\t\tres.x *= .5;\n\t\tif (abs(res.x) < MIN_DIST || res.x >= MAX_DIST) break;\n\t\td += res.x;\n\t\tif (d >= MAX_DIST) break;\n\t}\n\treturn vec4(d,m);\n}\n\nvec3 normal(vec3 p)\n{\n    // Copy from iq shader.\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4+ZERO; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdScene(p+0.0005*e).x;\n    }\n    return normalize(n);\n}\n\nfloat shadow(vec3 o, vec3 n){\n\tfloat mint=lit0.shadowStart;\n\tfloat maxt=lit0.shadowEnd;\n\tfloat k = lit0.shadowSoft;\n\tfloat res = 1.;\n\tfloat t=mint;\n\tfor( int i=0; i < 20; i++){\n\t\tfloat h = sdScene(o + lit0.direction*t).x;\n\t\tres = min( res, k*h/t);\n\t\tt += h;\n\t\tif( res<0.0001 || t>maxt ) break;\n\t}\n\treturn sat(res);\n}\n\n// \"Hemispherical SDF AO\" by XT95:\n// https://www.shadertoy.com/view/4sdGWN\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 randomSphereDir(vec2 rnd){\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i){\n\tvec3 v = randomSphereDir( vec2(hash11(i+1.), hash11(i+2.)) );\n\treturn v * sign(dot(v, dir));\n}\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff ){\n\tconst int nbIte = 8;\n\tconst float nbIteInv = 1./float(nbIte);\n\tconst float rad = 1.-1.*nbIteInv;\n\n\tfloat ao = 0.0;\n\n\tfor( int i=ZERO; i<nbIte+ZERO; i++ ){\n\t\tfloat l = hash11(float(i)+maxDist*falloff)*maxDist;\n\t\tvec3 aord = normalize(n+randomHemisphereDir(n, l+maxDist+falloff )*rad)*l;\n\t\tao += (l - max(sdScene( p + aord ).x,0.)) / maxDist * falloff;\n\t}\n\n\treturn clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid render(){\n\tvec4 res = intersect();\n\tvec3 p = ray.origin + res.x * ray.direction;\n\n\tif (res.x>=MAX_DIST){\n\t\trenDat.position = vec3(0);\n\t\trenDat.albedo = FOG_COL;\n\t\trenDat.normal = vec3(0);\n\t\trenDat.diffuse = 0.;\n\t\trenDat.specular = 0.;\n\t\trenDat.shadow = 0.;\n\t\trenDat.ao = 0.;\n\t\trenDat.depth = 1.;\n\t\trenDat.result = FOG_COL;\n\t}\n\telse{\n\t\trenDat.position = p;\n\t\trenDat.albedo = res.yzw;\n\t\trenDat.normal = normal(p);\n\n\t\tfloat shininess = .5;\n\t\tfloat intensity = .05;\n        \n\t\tfloat lamb1 = sat(dot(renDat.normal, lit0.direction))*(1./PI);\n\t\tfloat lamb2 = sat(dot(renDat.normal, lit1.direction))*(1./PI);\n\n\t\trenDat.shadow = shadow(p+renDat.normal*.0001, renDat.normal);\n\n\t\t//renDat.ao = ambientOcclusion(p, renDat.normal, .1, 1.5);\n\t\trenDat.ao = ambientOcclusion(p, renDat.normal, .5, 1.5);\n\t\t//renDat.ao += ambientOcclusion(p, renDat.normal, 2., 4.);\n\t\t//renDat.ao += ambientOcclusion(p, renDat.normal, 4., 8.);\n\t\trenDat.ao = smoothstep(-0.3, 1.5, renDat.ao);\n\n\t\trenDat.diffuse = lamb1;\n\t\trenDat.diffuse *= renDat.shadow;\n\t\trenDat.result = mix(vec3(0), lit0.color, renDat.diffuse);\n\n\t\trenDat.diffuse += lamb2*renDat.ao;\n\t\trenDat.result += mix(vec3(0), lit1.color, lamb2*renDat.ao);\n\n\t\trenDat.diffuse += renDat.ao*AMB_STRENGTH;\n\t\trenDat.result += mix(vec3(0), AMB_COL, renDat.ao*AMB_STRENGTH);\n\t\trenDat.result*= renDat.albedo;\n\n\t\t#define ggx(roughness, N, V, L) ggx(N, -V, L, roughness, .6)\n\t\tfloat spec = ggx(shininess, renDat.normal, ray.direction, lit0.direction);\n\t\trenDat.specular = spec*intensity;\n\t\trenDat.result = mix(renDat.result, renDat.result+lit0.color, renDat.specular*renDat.shadow);\n\t\trenDat.depth = distance(ray.origin, p)/MAX_DIST*3.5;\n\t\trenDat.result = mix(renDat.result, FOG_COL, sat(pow(renDat.depth+FOG_START, FOG_POW)));\n\t}\n}\n\n// \"init\": init camera/lights.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid init(){\n    cam0.position = vec3(-26.9963, 88.0527, -48.4978);\n\tcam0.quaternion = vec4(0.2949, -0.0793, -0.2473, 0.9196);\n\tcam0.fov = 0.2;\n\tcam0.orthoDist = 0.0;\n\tcam0.orthoScale = 0.0;\n\n\tlit0.direction = normalize(vec3(-0.0875, 0.7071, -0.3935));\n\tlit0.color = vec3(2.5372, 2.3575, 1.8639);\n\tlit0.shadowStart = 0.05;\n\tlit0.shadowEnd = 30.0;\n\tlit0.shadowSoft = 50.0;\n\tlit1.direction = normalize(vec3(0.5875, -0.7071, 0.3935));\n\tlit1.color = vec3(0.214, 0.1892, 0.1329);\n\tlit1.shadowStart = 0.05;\n\tlit1.shadowEnd = 30.0;\n\tlit1.shadowSoft = 50.0;\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 offset = u2s(hash22(fragCoord+iTime))/iResolution.xy*.5; // AA: Offset coord for each frame.\n    uv += offset; //\n    \n\tuv = (uv*2.-1.)*iResolution.y/iResolution.x;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tinit();\n\tcamera(uv);\n\trender();\n    renDat.result.rgb = sms(-.01,.9,renDat.result.rgb);\n\trenDat.result = pow(renDat.result, vec3(1./2.2));\n\tfragColor = vec4(renDat.result, 1.);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// General\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define iFrameRate 24.0\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*.5)\n#define ZERO min(0,iFrame)\n\n#define sat(x) clamp(x, 0.0, 1.0)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n\n// Raymarching\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define MIN_DIST 0.001\n#define MAX_DIST 100.0\n#define ITERATION 200\n\n#define MAT_VOID vec3(-1)\n#define MAT_ERNST0 vec3(1.000,0.980,0.400)\n#define MAT_ERNST1 vec3(1.000,0.424,0.361)\n#define MAT_ERNST2 vec3(0.631,0.525,0.408)\n#define MAT_ERNST3 vec3(0.322,0.773,1.000)\n#define MAT_ERNST4 vec3(0.345,0.976,0.502)\n#define AMB_COL vec3(0.6921, 0.8636, 1.0)\n#define AMB_STRENGTH 0.3\n#define FOG_COL AMB_COL\n#define FOG_START 0.0\n#define FOG_POW 1.85\n\n// \"hash11()\" - \"hash44()\"\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat hash11(float p){\n\tp = fract(p * .1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 rot(vec3 p,vec3 r){\n\tR(p.xz, r.y);\n\tR(p.yx, r.z);\n\tR(p.zy, r.x);\n\treturn p;\n}\n\n\n// SDF functions\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat fOpUnion(in float a,in float b){\n\treturn a<b?a:b;\n}\n\nvec4 v4OpUnion(in vec4 a,in vec4 b){\n\treturn a.x<b.x?a:b;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r){\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n\n\t// iq:\n\t//float h = max(r-abs(a-b),0.0);\n\t//return min(a, b) - h*h*0.25/r;\n}\n\nvec4 v4OpUnionSmooth(vec4 a,vec4 b,float r){\n\tfloat h=clamp(0.5+0.5*(b.x-a.x)/r,0.0,1.0);\n\tfloat res = mix(b.x,a.x,h)-r*h*(1.0-h);\n\treturn vec4(res, mix(b.yzw,a.yzw,h));\n}\n\nvec4 v4OpSubstraction(in vec4 a,in vec4 b){\n\tfloat res = max(-a.x, b.x);\n\treturn (res==-a.x)?vec4(-a.x, a.yzw):b;\n}\n\nvec4 v4OpSubstractionSmooth( vec4 a,vec4 b,float r){\n\tvec2 u = max(vec2(r + b.x, r + -a.x), vec2(0));\n\tfloat res = min(-r, max(b.x, -a.x))+length(u);\n\tvec3 m = mix(b.yzw, a.yzw, clamp(abs(-b.x)+abs(res),0.0,1.0)*clamp(r,0.,1.));\n\treturn vec4(res, m);\n}\n\nvec4 v4OpIntersection(in vec4 a,in vec4 b){\n\tfloat res = max(a.x, b.x);\n\treturn (res==a.x)?a:b;\n}\n\nvec4 v4OpIntersectionSmooth( vec4 a,vec4 b,float r){\n\tvec2 u = max(vec2(r + b.x,r + a.x), vec2(0));\n\tfloat res =  min(-r, max(b.x, a.x)) + length(u);\n\tvec3 m = mix(a.yzw, b.yzw, clamp(a.x-res,0.0,1.0)*r);\n\treturn vec4(res, m);\n}\n\n// \"Limited Repetition SDF\" by iq:\n// https://www.shadertoy.com/view/3syGzz\nvoid pRepLimited(inout float p_el, float s, float repetitions ){\n#if 0\n\tfloat r = round(p_el/s);\n\tfloat half_num = (repetitions-1.)/2.;\n\tr = clamp(r, -half_num, repetitions-half_num);\n\tp_el-=s*r;\n#else\n\trepetitions -= 1.;\n\tfloat offset = 1.-step(.5, mod(repetitions, 2.));\n\tp_el += s*.5*offset;\n\tfloat r = round(p_el/s);\n\tfloat half_rep = ceil(repetitions/2.);\n\tr = clamp(r, -half_rep, repetitions-half_rep);\n\tp_el-=s*r;\n#endif\n}\n\n// Phong specular\nfloat normalizedPhong(float shininess, vec3 n, vec3 vd, vec3 ld){\n\tfloat norm_factor = (shininess+1.) / (2.*PI);\n\tvec3 reflect_light = normalize(reflect(ld, n));\n\treturn pow(max(dot(-vd, reflect_light), 0.), shininess) * norm_factor;\n}\nfloat normalizedPhongRef(float shininess, vec3 n, vec3 vd, vec3 ld){\n\treturn 1.-normalizedPhong(shininess, n, vd, ld);\n}\n\n// https://hanecci.hatenadiary.org/entry/20130505/p2\n// http://www.project-asura.com/program/d3d11/d3d11_006.html\nfloat normalizedBlinnPhong(float shininess, vec3 n, vec3 vd, vec3 ld){\n\tfloat norm_factor = (shininess+1.) / (2.*PI);\n\tvec3 h  = normalize(-vd+ld);\n\treturn pow(max(0., dot(h, n)), shininess) * norm_factor;\n}\nfloat BlinnPhongRef(float shininess, vec3 n, vec3 vd, vec3 ld){\n\tvec3 h  = normalize(-vd+ld);\n\treturn 1.-pow(max(0., dot(h, n)), shininess);\n}\n\n// https://www.shadertoy.com/view/wljSz1\n// http://filmicworlds.com/blog/optimizing-ggx-shaders-with-dotlh/\nfloat G(float dotNV, float k){\n\treturn 1.0/(dotNV*(1.0-k)+k);\n}\nfloat ggx(vec3 N, vec3 V, vec3 L, float roughness, float F0){\n\tfloat alpha = roughness*roughness;\n\n\tvec3 H = normalize(V+L);\n\n\tfloat dotNL = clamp(dot(N,L),0.,1.);\n\tfloat dotNV = clamp(dot(N,V),0.,1.);\n\tfloat dotNH = clamp(dot(N,H),0.,1.);\n\tfloat dotLH = clamp(dot(L,H),0.,1.);\n\n\tfloat F, D, vis;\n\n\tfloat alphaSqr = alpha*alpha;\n\tfloat pi = 3.14159;\n\tfloat denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n\tD = alphaSqr/(pi * denom * denom);\n\n\tfloat dotLH5 = pow(1.0 - dotLH, 5.0);\n\tF = F0 + (1.0 - F0)*(dotLH5);\n\n\tfloat k = alpha * 0.5;\n\n\treturn dotNL * D * F * G(dotNL,k)*G(dotNV,k);\n}\n\n// \"Physically-based SDF\" by romainguy:\n//https://www.shadertoy.com/view/XlKSDR\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 Tonemap_ACES(const vec3 x){\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n// https://www.shadertoy.com/view/3ssSz2\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat originalSigmoidContrast(float color, float contrast, float mid){\n    contrast = contrast < 1.0 ? 0.5 + contrast * 0.5 : contrast;\n    float scale_l = 1.0 / mid;\n    float scale_h = 1.0 / (1.0 - mid);\n    float lower = mid * pow(scale_l * color, contrast);\n    float upper = 1.0 - (1.0 - mid) * pow(scale_h - scale_h * color, contrast);\n    return color < mid ? lower : upper;\n}\nvec3 originalSigmoidContrast(vec3 color, float contrast, float mid){\n\tcolor.r = originalSigmoidContrast(color.r, contrast, mid);\n\tcolor.g = originalSigmoidContrast(color.g, contrast, mid);\n\tcolor.b = originalSigmoidContrast(color.b, contrast, mid);\n\treturn color;\n}\n\nstruct Ray{\n\tvec3 origin;\n\tvec3 direction;\n};\n\nstruct Camera{\n\tvec3 position;\n\tvec3 direction;\n\tvec3 target;\n\tvec4 quaternion;\n\tfloat fov;\n\tfloat orthoDist;\n\tfloat orthoScale;\n};\n\nstruct Light{\n\tvec3 direction;\n\tvec3 color;\n\tfloat intensity;\n\tfloat shadowStart;\n\tfloat shadowEnd;\n\tfloat shadowSoft;\n};\n\nstruct RenderData{\n\tvec3 position;\n\tvec3 albedo;\n\tvec3 normal;\n\tfloat diffuse;\n\tfloat specular;\n\tfloat shadow;\n\tfloat ao;\n\tfloat depth;\n\tvec3 result;\n}renDat;\nRay ray;\nCamera cam0;\nLight lit0;\nLight lit1;\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stt3Wf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 118], [119, 119, 141, 141, 820], [913, 960, 980, 980, 1028], [1029, 1029, 1053, 1053, 1083], [1085, 1085, 1137, 1137, 1258], [1260, 1353, 1405, 1405, 1856], [1858, 1858, 1888, 1888, 2311], [4539, 4539, 4556, 4556, 4845], [4847, 4847, 4868, 4994, 5205], [5207, 5207, 5236, 5236, 5523], [5525, 5673, 5704, 5704, 5807], [5808, 5808, 5852, 5852, 5948], [5949, 5949, 6032, 6032, 6430], [6432, 6504, 6518, 6518, 8253], [8255, 8358, 8370, 8370, 8909], [8911, 8983, 9037, 9037, 9474]], "test": "untested"}
{"id": "slt3DX", "name": "入门之路-16", "author": "jialouluo", "description": "马赛克", "tags": [], "likes": 3, "viewed": 214, "published": 3, "date": "1636878348", "time_retrieved": "2024-07-30T18:48:17.760832", "image_code": "//这是一个生成马赛克的案例\nconst vec2 textureSize =vec2(720.,405.);\nconst vec2 pixSize = vec2(1,1);//调节这里的参数，可以看到不同大小的马赛克\nvec4  getCircular(vec2 uv){\n    vec2 Txy = vec2(floor(uv.x/pixSize.x)*pixSize.x,floor(uv.y/pixSize.y)*pixSize.y)+0.5 * pixSize;\n    vec2 dis = Txy -uv;\n    float r = length(dis);\n    vec2 nuv = Txy/textureSize;\n    vec4 finalColor ;\n    if(r<pixSize.x*0.5){\n        finalColor = texture(iChannel1,nuv);\n    }else{\n        finalColor = vec4(0,0,0,1);\n    }\n    return finalColor;\n}\nvec4 getSquare(vec2 uv){\n    vec2 Txy = vec2(floor(uv.x/pixSize.x)*pixSize.x,floor(uv.y/pixSize.y)*pixSize.y)+0.5 * pixSize;\n    vec2 dis = Txy -uv;\n    vec2 color = smoothstep(abs(dis)-0.001,abs(dis),pixSize*0.5);\n    vec2 nuv = Txy/textureSize;\n    vec4 finalColor ;\n    if(color.x<1.0|| color.y<1.0 ){\n        finalColor = vec4(0,0,0,1);\n    }\n    else{\n        finalColor = texture(iChannel1,nuv);\n\n    }\n    return finalColor;\n}\nvec2 random(in vec2 _st ){\n    _st = vec2(\n            dot(_st,vec2(127.326,321.324)),\n            dot(_st,vec2(15.31,45.332))\n                    );\n    return 2.0*fract(sin(_st)*432.23) +1.0; //1.0 ~ 3.0\n}\nfloat snoise(vec2 st){ //Gradient Noise\n    vec2 i = fract(st);//取小数\n    vec2 k = floor(st);//向负无穷取整\n    vec2 u = i*i*(3.0-2.0*i);//插值函数\n    return  mix(\n                    mix(dot(random(k + vec2(0.0,0.0)),i - vec2(0.0,0.0)),\n                        dot(random(k + vec2(0.0,1.0)),i - vec2(0.0,1.0)),\n                         u.y),\n                    mix(dot(random(k + vec2(1.0,0.0)),i - vec2(1.0,0.0)),\n                        dot(random(k + vec2(1.0,1.0)),i - vec2(1.0,1.0)),\n                         u.y),\n                       u.x\n                   );//二维noise\n}\nvec4 getNoise(vec2 uv){\n    vec2 Txy = vec2(floor(uv.x/pixSize.x)*pixSize.x,floor(uv.y/pixSize.y)*pixSize.y)+0.5 * pixSize;\n    vec2 dis = Txy -uv;\n    vec2 color = smoothstep(abs(dis)-0.001,abs(dis),pixSize*0.5);\n    vec2 nuv = Txy/textureSize;\n    vec4 finalColor ;\n    \n    if(color.x<1.0|| color.y<1.0 ){\n        finalColor = vec4(0,0,0,1);\n    }\n    else{\n        vec2 st = nuv-0.5;\n        vec2 result = vec2(step(abs(st)-0.49,vec2(0.0)));\n        if(result.x<1.0|| result.y<1.0 ){\n        }else{\n            nuv+=0.01* snoise(nuv + iTime *0.3);\n        }\n        finalColor = texture(iChannel1,nuv);\n    }\n    \n    return finalColor;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv *=textureSize;\n    \n    fragColor =getNoise(uv);\n        \n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slt3DX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 174, 201, 201, 554], [555, 555, 579, 579, 988], [989, 989, 1015, 1015, 1196], [1197, 1197, 1219, 1236, 1798], [1799, 1799, 1822, 1822, 2441], [2442, 2442, 2497, 2497, 2606]], "test": "untested"}
{"id": "7tdGDX", "name": "percolation network 3", "author": "FabriceNeyret2", "description": "In this variant of [url]https://shadertoy.com/view/stdGRl[/url], the flux (colors) propagates at a speed proportional to the bonding between nodes.\nTesting various bonding laws BuffA:18\n( I prefer the previous version :-) )", "tags": ["short", "network", "connect", "percolation", "molecules", "bonds"], "likes": 14, "viewed": 381, "published": 3, "date": "1636875959", "time_retrieved": "2024-07-30T18:48:18.663419", "image_code": "// variant of https://shadertoy.com/view/stdGRl\n\n// percolation network -----------------------------------------\n// - denser network: change Common:N\n// - chasing the global connectivity threshold: change BuffA:17 + replace iTime with 0 in Common:C\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    return length(p - b * clamp(dot(p, b) / dot(b, b), 0., 1.));                      \n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = N *( u+u - R ) / R.y,\n         I = floor(U), F = fract(U), D,A,B;        \n    O-=O;\n // O = hue( T( I+floor(R/2.)).x );                // display power waves\n    float d;\n    for( int k=0; k<9; k++ ) {\n        D = vec2(k%3,k/3)-1., A = D + C(I+D);\n    //  O = max(O, .3 / length(F-A) );             // blobs\n        for( int j=0; j<9; j+= j==k?2:1 ) {\n            D = vec2(j%3,j/3)-1., B = D + C(I+D);\n            d = length(B-A); d = max(0., 1.5-d);\n            if (d>0.) O = max(O, smoothstep(3.*N/R.y,0., line(F,A,B) - .02 * d*4. )  *d*2. );\n            //*hue(d) \n    } }\n    d = T( I+floor(R/2.)).x;\n    O *=  d==0. ? vec4(1) : hue( d );              // display power waves\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// percolation: propagate power ( = iTime )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    if (iFrame<1) { O-=O; return; }\n    \n    float V,d, dt = .4;\n    vec2  I=u-floor(R/2.),D,A=abs(I),B,P;        \n    O = T(u);                                        // previous state\n    if ( I.x < - (N-2.)*R.x/R.y ) O.r = dt*iTime;    // left border: inject fresh power = iTime\n    \n    I = floor(I);\n    A = C(I);             \n    for( int j=0; j<25; j+= j==11?2:1 ) {            \n        D = vec2(j%5,j/5)-2., B = D + C(I+D);\n        d = length(B-A); d = max(0., 1.5-d);\n        V = T(u+D).x;                                // neighbor value\n        if (d > 0.) O.x = max(O.x,                   // if connected, propagate freshest power\n                               // V -10.*dt*       (1.5-d)     );               // delay\n                               // V -10.*dt*max(0.,(1.5-d)-.9) );               // (non-linear)\n                                  O.x + ( V - O.x ) *min( 1., max(0.,d-.5) ) ); // flux (non-linear)\n   }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float N = 10.; // cells density\n\n#define R     iResolution.xy \n#define T(U)  texelFetch(iChannel0, ivec2( U ), 0 )\n#define H(p)  fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define C(p) (.5+.3*H(p+.5)+.2*vec2( cos( (H(p).y-.5)*iTime + 6.3*H(p).x + vec2(0,33) ) ) )\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tdGDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[317, 317, 352, 352, 462], [464, 464, 502, 502, 1196]], "test": "untested"}
{"id": "7tdGWX", "name": "spirals vs ghosts", "author": "lomateron", "description": "small variation", "tags": ["fluid", "convolution", "kernel"], "likes": 28, "viewed": 480, "published": 3, "date": "1636869723", "time_retrieved": "2024-07-30T18:48:19.631829", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = fragCoord/iResolution.xy;\n    vec4 a = texture(iChannel0,u);\n    fragColor = pow(a.z,.15)*(cos(length(a.xy)*2.+vec4(0,2,4,6)+3.)*.3+.7);\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4  r = vec4(0);\n    vec4  a = A(u);\n    float z    = 8.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        float l = length(vec2(i,j));\n        if((i==0.&&j==0.)|| l>z+.1){continue;}\n        vec2  c = normalize(vec2(i,j));\n        vec4  a2= A(u+vec2(i,j));\n        vec4  b = a2-a;                  l*=.7;\n        r.xy += c*b.z*cos(l)*exp(-l*l*.06)*.1;\n        r.z  += dot(c,b.xy           );//*a2.z;\n        //r.w  += dot(c,b.yx*vec2(-1,1));//*a2.z;\n    }}\n    fragColor = r;\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4  r = A(u);\n    float z    = 8.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n      if((i==0.&&j==0.)||length(vec2(i,j))>z+1.){continue;}\n      vec4 b = B(u+vec2(i,j));\n      vec2 c = normalize(-vec2(i,j))*.000125;//*r.z;\n      r.xy += +b.z*c              *-1.\n              +b.w*c.yx*vec2(-1,1)*0.\n              +abs(b.z)*(step(0.,b.w)*2.-1.)*c.yx*vec2(-1,1)*0.;\n    }}\n\n    fragColor = r;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\n#define C(u) texture(iChannel2,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4 t = A(u);\n    vec2 m = +t.xy\n             +B(u).xy;//*(t.z-.5)*4. //change the .3 to .6\n             +t.z*vec2(0,.0)\n             -C(u).x*t.xy*.0;\n    float s = 0.;\n    float z    = 6.;//kernel convolution size\n    float blur = 9./z;\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        //if(length(vec2(i,j))>z+.1){continue;}\n        vec2 c = (m+vec2(i,j))*blur;\n        s += exp(-dot(c,c));\n    }}\n    if(s==0.){s = 1.;}\n    s = 1./s;\n    \n    fragColor = vec4(m,s,0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    float tz = 0.;\n    vec4 a = vec4(0);\n    float z    = 6.;//kernel convolution size\n    float blur = 9./z;\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        //if(length(vec2(i,j))>z+.1){continue;}\n        vec4 t = A(u+vec2(i,j));\n        vec4 m = B(u+vec2(i,j));\n        vec2 c = (m.xy-vec2(i,j))*blur;\n        float z = t.z*exp(-dot(c,c));\n        a.xy += z*m.xy;\n        a.z  += z*m.z;\n        tz   += z;\n    }}\n    if(tz==0.){tz = 1.;}\n    a.xy /= tz;\n    //a = A(u);\n    if(iMouse.z>0.)\n    {\n        vec2 m = 22.*(u-iMouse.xy)/iResolution.y;\n        a += vec4(-normalize(m),0,0)*exp(-dot(m,m));\n    }\n    if(iFrame==0)\n    {\n        vec2 m = 8.*(u-iResolution.xy*.5)/iResolution.y;\n        a = vec4(0,0,1,1)*exp(-dot(m,m));\n    }\n    fragColor = a;\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tdGWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 209]], "test": "untested"}
{"id": "flt3Df", "name": "girl-legs", "author": "jorge2017a2", "description": "girl-legs\n\n", "tags": ["girllegs"], "likes": 5, "viewed": 354, "published": 3, "date": "1636861446", "time_retrieved": "2024-07-30T18:48:20.689003", "image_code": "///-------------image\n// por jorge2017a2\n//Referencia\n//https://iquilezles.org/articles/distfunctions\n//https://www.shadertoy.com/view/4tdcWS  .....Created by reinder in 2018-08-10\n\n//por jorge2017a1-\n#define MAX_STEPS 110\n#define MAX_DIST 110.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\n//https://iquilezles.org/articles/distfunctions\nfloat opSmoothUnion( float d1, float d2, float k )\n{  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) \n{ float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{ float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n//Created by reinder in 2018-08-10\n//https://www.shadertoy.com/view/4tdcWS\nfloat sdCapsuleF(vec3 p, vec3 a, vec3 b, const float r0, const float r1, const float f) \n{   vec3 d = b -a;\n    float h = length(d);\n    d = normalize(d);\n    float t=dot(p-a, d);\n    float th = t/h;\n    return distance(a+clamp(t,0.,h)*d, p)-mix(r0, r1, th) * \n           max(0., 1.+f-f*4.*abs(th-.5)*abs(th -.5));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, const float r0, const float r1)\n{   vec3 d = b -a;\n    float h = length(d);\n    d = normalize(d);\n    float t=clamp(dot(p-a, d), 0., h);\n    return distance(a+t*d, p) -mix(r0, r1, t/h);\n}\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);     \n    if(itime>20.0 && itime<30.0)\n    {   //p= rotate_x( p, radians(iTime*10.0)); \n        float ang= 90.0*clamp(sin(itime*0.5),0.0,1.0);\n        p= rotate_x( p, radians(ang)); \n    }\n    if(itime>30.0 && itime<40.0)\n    {  float ang= 90.0*clamp(sin(itime*0.5),0.0,1.0);\n        p= rotate_y( p, radians(iTime*20.0));\n        p= rotate_x( p, radians(ang)); \n    }\n    else\n    p= rotate_y( p, radians(iTime*20.0));\n    \n    p.xyz=vec3(p.x, p.y, -p.z);\n    vec3 p0=p;\n\tfloat planeDist1 = p.y+15.0;  //piso inf\n    res =opU3(res, vec3(planeDist1,-1.0,7.0)); //inf\n\n    //cadera\n    p.x+=2.5;\n    float dCadera= sdCylinderXY(p-vec3(0.0,15.0,0.15), vec2(5.0,2.0) );\n    p.x=abs(p.x)-3.0;\n    float dCaderaBx= sdBox(p-vec3(0.0,14.5,-6.2), vec3(6.5,6.0,4.0));\n    \n    float dCaderaSp= sdSphere(p-vec3(0.0,10.7,0.0), 2.0 );\n    p=p0;\n    p.x+=2.5;\n    p.x=abs(p.x)-13.0;\n    float dCaderaDif= sdCylinderXY(p-vec3(0.0,17.5,0.5), vec2(10.0,3.0) );\n    p=p0;\n     p.x+=2.5;\n    p.x=abs(p.x)-2.0;\n    float dGluteos= sdEllipsoid( p-vec3(0.0,12.0,2.5), vec3(2.5,3.0,2.0)  );\n    float dCalzon= sdBox(p- vec3(0.0,12.0,0.0), vec3(5.0,2.5,5.0)  );\n    \n    dCadera= differenceSDF(dCadera, dCaderaBx);\n    dCadera= opSmoothUnion(dCadera, dCaderaSp,0.5);\n    dCadera= opSmoothUnion(dCadera, dGluteos,0.5);\n    dCadera= opSmoothSubtraction(dCaderaDif,dCadera, 0.5) ;\n    p=p0;\n    float dPiernaDer;\n    vec3 a,b;\n    float r0, r1,f;\n\n    //----Pierna Der\n    p.x-=0.5;\n         a=vec3(0.,0.0,0.0);     b=vec3(-0.5,10.0,0.0);\n         r0=1.3; r1=2.2; f=0.002;\n    float dPiernaDerA1= sdCapsule( p, a, b,  r0,r1);\n    \n         a=vec3(0.0,0.0,0.0);    b=vec3(-0.5,10.0,1.0);\n         r0=1.3; r1=2.2; f=0.002;\n    float dPiernaDerA2= sdCapsule( p, a, b,  r0,r1);\n    \n    dPiernaDer=opSmoothUnion(dPiernaDerA1,dPiernaDerA2, 0.5);\n    \n    \n    //rodilla der\n    p.y+=2.0;\n    //superior\n         a=vec3(0.,0.0,0.0);     b=vec3(0.5,-12.0,0.0);\n         r0=1.5; r1=1.3; f=0.002;\n    float dRodillaDer1= sdCapsule( p, a, b,  r0,r1);\n\n    float dSpPiernaDer= sdSphere( p-vec3(0.0,1.0,-0.25), 1.5 );\n    //pierna der inferior\n    p.y-=1.8;\n         a=vec3(0.,0.0,0.0); b=vec3(-0.5,-12.0,0.0);\n         r0=1.5; r1=1.3; f=0.002;\n    float dRodillaDer1A= sdCapsule( p-vec3(0.0,-2.0,0.0), a, b,  r0,r1);\n    float dRodillaDer1B= sdEllipsoid(p-vec3(0.0,-6.0,1.0), vec3(1.7,5.0,1.0) );\n    \n    dRodillaDer1A=opSmoothUnion(dRodillaDer1A,dRodillaDer1B,0.5);\n    dPiernaDer=opSmoothUnion( dPiernaDer, dSpPiernaDer, 0.5 );\n    dPiernaDer=opSmoothUnion( dPiernaDer, dRodillaDer1A, 0.5 );\n    \n    res =opU3(res, vec3(dPiernaDer,30.0,-1.0));\n     \n    p=p0;\n    ///------pierna Izq  superior\n     p.x+=6.0;\n         a=vec3(0.,0.0,0.0); b=vec3(0.5,10.0,0.0);\n         r0=1.5; r1=2.0; f=0.002;\n    float dPiernaIzqA1= sdCapsule( p, a, b,  r0,r1);\n    \n         a=vec3(0.0,0.0,0.0); b=vec3(0.5,10.0,1.0);\n         r0=1.5; r1=2.0; f=0.002;\n    float dPiernaIzqA2= sdCapsule( p, a, b,  r0,r1);\n    float dPiernaIzq=opSmoothUnion(dPiernaIzqA1,dPiernaIzqA2, 0.5);\n    \n     float dSpPiernaIzq= sdSphere( p-vec3(0.0,-1.0,-0.25), 1.5 );\n        \n    //pierna izq inferior\n         a=vec3(0.,0.0,0.0); b=vec3(-0.5,-12.0,0.0);\n         r0=1.5; r1=1.3; f=0.002;\n    float dRodillaIzq1A= sdCapsule( p-vec3(0.0,-2.0,0.0), a, b,  r0,r1);\n    float dRodillaIzq1B= sdEllipsoid(p-vec3(0.0,-6.0,1.0), vec3(1.7,5.0,1.0) );\n    dRodillaIzq1A=opSmoothUnion(dRodillaIzq1A,dRodillaIzq1B,0.5);\n    res =opU3(res, vec3(dRodillaIzq1A,2.0,-1.0));\n    \n    dPiernaIzq=opSmoothUnion( dPiernaIzq, dSpPiernaIzq, 0.5 );\n     //dPiernaIzq=opSmoothUnion( dPiernaIzq, dRodillaIzq1A, 0.5 );\n     \n    dCadera=opSmoothUnion(dCadera,dPiernaDer, 2.0);\n    dCadera=opSmoothUnion(dCadera,dPiernaIzq, 2.0);\n    dCalzon= intersectSDF(dCadera,dCalzon);\n\n    res =opU3(res, vec3(dCadera,30.0,-1.0));\n    res =opU3(res, vec3(dCalzon,4.0,-1.0));\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{   vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    \n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true)\n        {fshadow=GetShadow(p,lp);}\n    else\n        {fshadow=0.5;}\n\n    vec3 lin=vec3(1.0);\n    \n    lin*= amb2*occ;\n    lin += diff;\n    lin += spe*vec3(1.0);\n    lin += fre*vec3(1.0);\n    \n      lin *= atten*0.5*col*fshadow;\n    //lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75;   \n    lin *=max(normalize(vec3(length(lin))).z, 0.);//spalmer\n    lin = pow(lin,vec3(0.4245));\n    return lin;\n    \n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\nvec3 getMaterial( vec3 p, float id_material)\n{   if (id_material==7.0)\n        {return pattern( p.xz );}\n    if (id_material==8.0)\n        {return pattern( p.xy );}\n    if (id_material==9.0)\n        {return pattern( p.zy );}\n   return vec3(0.0);\n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    if (id_material>-1.0 && id_color==-1)\n        { colobj=vec3(0.5);\n          colobj*=getMaterial(p, id_material); \n          return colobj;\n        }\n    return colobj;\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;mObj.ro=ro;\n   vec3 p;\n     float d=RayMarch(ro,rd, MAX_STEPS);\n\n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n       col= result/2.0;\n        //col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n        col = pow(col, vec3(0.6545));\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n    \n   \n   return col;\n}\n\nvec3 linear2srgb(vec3 c)\n{return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*2.0,45.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n \tlight_pos1= vec3(10.0, 30.0, 30.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 20.0, -30.0 ); light_color2 =vec3( 1.0 ); \n   vec3 ro=vec3(0.0,7.0,-30.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   \n   if(t<10.0)\n        ro=vec3(0.0,7.0+7.0*sin(t),-25.0);\n   if(t>10.0 && t<20.0)\n    ro=vec3(2.0,7.0,-25.0+5.0*sin(t));\n\n    //light_pos1+=ro;\n   // light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    col = exposureToneMapping(3.0, col);\n    col = linear2srgb(col);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------common\n///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flt3Df.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[661, 661, 697, 697, 718], [719, 719, 751, 751, 835], [836, 836, 875, 875, 970], [971, 971, 1010, 1010, 1105], [1106, 1106, 1145, 1145, 1240], [1242, 1242, 1289, 1289, 1316], [1317, 1317, 1360, 1360, 1387], [1388, 1388, 1436, 1436, 1464], [1467, 1467, 1501, 1501, 1597], [1598, 1598, 1632, 1632, 1723], [1724, 1724, 1758, 1758, 1849], [1851, 1851, 1885, 1885, 1980], [1983, 2031, 2083, 2083, 2179], [2181, 2181, 2240, 2240, 2336], [2338, 2338, 2397, 2397, 2496], [2499, 2499, 2536, 2536, 2617], [2619, 2694, 2784, 2784, 3010], [3012, 3012, 3085, 3085, 3239], [3241, 3241, 3266, 3266, 7184], [7186, 7186, 7210, 7210, 7372], [7374, 7374, 7423, 7423, 8054], [8056, 8056, 8092, 8092, 8337], [8339, 8339, 8366, 8366, 8383], [8385, 8385, 8421, 8421, 8513], [8514, 8514, 8560, 8560, 8685], [8687, 8687, 8761, 8761, 9986], [9988, 9988, 10068, 10068, 10191], [10193, 10193, 10225, 10225, 10422], [10424, 10472, 10500, 10500, 10688], [10690, 10690, 10736, 10736, 10937], [10939, 10939, 11032, 11032, 11341], [11343, 11343, 11374, 11374, 12035], [12037, 12037, 12063, 12063, 12150], [12152, 12152, 12210, 12210, 12262], [12264, 12264, 12321, 12321, 13014]], "test": "untested"}
{"id": "Nlt3Df", "name": "Persian mosaic 2", "author": "jarble", "description": "A fractal pattern that looks like a mosaic.", "tags": ["fractal", "glass", "mosaic", "ceramic"], "likes": 2, "viewed": 221, "published": 3, "date": "1636859300", "time_retrieved": "2024-07-30T18:48:21.555686", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);    \n    vec3 col;  \n    float t1 = 4.5/4.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime/2.+uv.x)/10.0);\n    vec3 random1 = (hash31(3.+t2)-.5)/8.;\n    vec3 random2 = (hash31(4.+t2)-.5)/8.;\n    //vec3 random3 = (hash31(3.+t2)-vec3(.5))/4.;\n    //vec3 random4 = (hash31(4.+t2)-vec3(.5))/4.;\n    \n    float offset = .5;\n    float scale2 = 1.5;\n    float bend = 1.+1./3.;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        //float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            //float bend = 1.;\n            \n\n            for(int k = 0; k < 3; k++){       \n                uv /= -scale2;\n                //uv += vec2(random1[k],random2[k]).yx;\n                //float bend = 1.;\n                uv.yx = triangle_wave(uv.yx-offset,scale)*bend+triangle_wave(uv,scale)/bend;\n                bend *= 1. - (((uv.x-uv.y)))/27.;\n                //bend *= -1.;\n                //bend -= 1./3.;\n                //bend = 1. +uv.x/3.;\n\n                uv += vec2(random1[k]/bend,random2[k]*bend);            \n            }\n            //uv -= uv.yx;\n            \n\n            //offset += .5;\n            scale /= 1.+(scale2)*col.x/(8.);\n            scale2 -= (col.x-1.)/4.;\n\n\n            col[c] = (abs((uv.x)-(uv.y)+col[c]));\n            //col = col.yzx;\n            //random2 = col - random2;\n            \n\n        }\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlt3Df.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [590, 590, 629, 629, 674], [676, 676, 733, 733, 2355]], "test": "untested"}
{"id": "ftdGDf", "name": "Particle Physics 2", "author": "1j01", "description": "Particle physics done by storing the particles as pixels in 2D, rather than the generally much more practical list of particles that are then rendered via some form of iteration over the list. This allows for as many particles as pixels on the screen.", "tags": ["2d", "mouse", "interactive", "particles", "fun", "physics", "particle", "momentum", "inertia"], "likes": 9, "viewed": 307, "published": 3, "date": "1636857834", "time_retrieved": "2024-07-30T18:48:22.735532", "image_code": "/*\n\nControls:\n- Click to gravitate particles.\n- Hold Ctrl to randomize velocities.\n- Hold Shift to expand particles into big blocks of particles.\n- Press F to toggle friction.\n- Press A to add random particles.\n\nParticles get destroyed when they collide, so there's no conservation of mass.\nParticle velocities are quantized to a pixel, so seams are created,\nand particle blobs break off into chunks like weird icebergs.\nIt's not a realistic or practical physics engine,\nbut you can make some fun patterns at any rate.\n\n*/\n\n/* the interesting code is all in Buf A */\n\n// get color from Buf A, relative to current pixel\nvec4 bufColor(in vec2 fragCoord) {    \n    return texture(iChannel0,  fract(fragCoord.xy / iResolution.xy));\n}\n\nconst bool colorMode = true;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = bufColor(fragCoord);\n    \n    if(col.w > 0.0){\n        if(colorMode){\n            // optionally change the color scheme\n            //col.z = 1.0;\n            fragColor = col;\n        }else{\n\t\t\tfragColor = vec4(1.0, 1.0, 1.0, 1.0);\n        }\n    }else{\n        if(colorMode){\n            // optional background color\n            //col = vec4(1.0, 1.0, 1.0, 1.0);\n        }\n    }\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// WIP, trying to avoid artifacts of quantizing positions/velocities\n// (such as particles moving diagonally stopping moving vertically\n// but continuing horizontally or visa versa; particles stopping\n// without visibly slowing down much first; and the tendancy to move at\n// perfect cardinal angles)\n// by storing an error between what position a particle ought to have,\n// and the integer pixel it occupies. This error value should accumulate\n// over time based on the fractional part of the velocity,\n// with considerations for negative velocities.\n// It doesn't work yet.\n//#define USE_POSITION_ERROR\n\n\n\n// --- key toggles -----------------------------------------------------\n\n// FYI: LEFT:37  UP:38  RIGHT:39  DOWN:40   PAGEUP:33  PAGEDOWN:34  END : 35  HOME: 36\n// Modifiers: SHIFT: 16 CTRL: 17 ALT: 18\n// Advice:  Mode: keyToggle(key)  Action: keydown(key)+keyclick(modifier)\n#define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define shift             ( texelFetch(iChannel3,ivec2(16,0),0).x  > 0.)\n#define ctrl              ( texelFetch(iChannel3,ivec2(17,0),0).x  > 0.)\n#define alt               ( texelFetch(iChannel3,ivec2(18,0),0).x  > 0.)\n\n\n//----------------------------------------------------------------------------------------\n// Pseudorandom number generator, based on https://www.shadertoy.com/view/4djSRW\n///  3 out, 3 in...\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define MAX_ITERATIONS 30\n#define MIN_ITERATIONS 4\n\n// hash33, tweaked to include an extra param\nvec3 hash33(vec3 p3, int i)\n{\n    p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19+float(i)/20.);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\nvec3 rnd3(vec2 position, int i)\n{\n\n    i += MIN_ITERATIONS;\n    vec3 a = vec3(0.0), b = a;\n    //NOTE - not handling i > MAX_ITERATIONS\n    //will just start scaling down random numbers\n    for (int t = 0; t < MAX_ITERATIONS; t++)  // max_iterations thing is due to GLSL limitations?\n    {\n        if (t == i) {\n            break;\n        }\n        float v = float(t+1)*.132;\n        vec3 pos = vec3(position, iTime*.3) + iTime * 500. + 50.0;\n        a += hash33(pos, i);  //just changing the numer of iterations doesn't work, so we pass in i\n    }\n    vec3 col = a / float(i);\n    return col;\n}\n//----------------------------------------------------------------------------------------\n\n/*\nfloat toroidalDistance (float x1, float y1, float x2, float y2) {\n    float dx = abs(x2 - x1);\n    float dy = abs(y2 - y1);\n \n    if (dx > 0.5f)\n        dx = 1.0f - dx;\n \n    if (dy > 0.5f)\n        dy = 1.0f - dy;\n \n    return sqrt(dx*dx + dy*dy);\n}\n*/\n/*\nvec2 toroidalNearestWay (vec2 from, vec2 to, vec2 mapSize) {\n    vec2 delta = to - from; // difference in position\n\n    if (delta.x > mapSize.x / 2.0) // if distance is bigger than half map width, then looping must be closer\n        delta.x = (delta.x - mapSize.x) * -1.0; // reduce distance by map width, reverse \n    else if (delta.x < -mapSize.x / 2.0) // handle the case that delta x is negative\n        delta.x = (delta.x + mapSize.x) * -1.0;\n\n    if (delta.y > mapSize.y / 2.0)\n        delta.y = (delta.y - mapSize.y) * -1.0;\n    else if (delta.y < -mapSize.y / 2.0)\n        delta.y = (delta.y + mapSize.y) * -1.0;\n\n    return delta;\n}\n*/\n\nvec2 toroidalNearestWay (vec2 from, vec2 to, vec2 mapSize) {\n    return (mod((to - from + 3.0 * mapSize / 2.0), mapSize)) - mapSize / 2.0;\n}\n\n\n\n// Get old color, relative to current pixel\nvec4 oldColor(in vec2 fragCoord, in vec2 xyDelta) {\n    // Try messing with me!\n   \t//xyDelta.x += sin(fragCoord.x);\n   \t//xyDelta.y += sin(fragCoord.y * 3.0);\n    return texture(iChannel0, fract((fragCoord.xy + xyDelta) / iResolution.xy));\n}\n\n// Get the next random number for the current pixel\n#define RND() (rnd3(fragCoord, rndi++))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    int rndi = 0;\n    const vec4 black = vec4(0., 0., 0., 1.);\n    const vec4 white = vec4(1.);\n    const vec4 red = vec4(1., 0., 0., 1.);\n    // current coordinates, normalised 0..1\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    bool enableFriction = keyToggle(70); // F\n\n    //////////////////////    \n    // Add particles\n    //////////////////////    \n    vec3 rnd = RND();\n    if (iFrame == 0 || keyClick(65)) {\n        if (rnd.x < .001) {\n            fragColor = vec4(RND(), 1.);\n            return;\n        }\n    }\n\n    //////////////////////\n    // Shuffle pixels around\n    //////////////////////\n\n    float velDetectRange = shift ? 3.0 : 0.5;\n    if (iFrame == 0) {\n        velDetectRange = 3.0;\n    } else if (iTime < 2.) {\n        velDetectRange = max(0.5, sin(iTime * 5.) * 3.);\n    }\n    \n     // WARNING: determines O(N^2) pixel iteration! (i.e. doesn't scale well)\n    const float maxVelocity = 5.0;\n    \n    // These accumulations are only when collisions occur,\n    // otherwise they're simply the values for one particle (or none).\n    float particlesSuperimposed; // number of particles landing here\n    vec2 accumulatedVel; // sum of velocities, later divided into an average\n    #ifdef USE_POSITION_ERROR\n    vec2 accumulatedPositionError;\n    #endif\n    // Iterate over nearby pixels\n    for (float dx = -maxVelocity; dx < maxVelocity; dx++) {\n        for (float dy = -maxVelocity; dy < maxVelocity; dy++) {\n            \n            // The idea here is we're looking at each potential place a particle could end up,\n            // because that's how a fragment shader is set up, to output a given pixel, not an arbitrary pixel\n            // so rather than iterate over pixels, see if there's a particle there and if so apply phyiscs and put a pixel representing that particle somewhere else,\n            // we iterate over the pixels and see if there's a particle that will end up where we're looking based on its current velocity,\n            // then we apply physics, updating it's velocity for the pixel we're going to output\n            \n            // TODO: try making it (pseudo)random what particle is chosen when multiple should end up in the same spot\n            // and/or combine them (i.e. their velocities)\n            vec4 acol = oldColor(fragCoord, vec2(dx, dy));\n            vec2 vel = (acol.xy * 2.0 - 1.0) * maxVelocity;\n            // Position error is stored in the fractional part, encoded as\n            // 0 to 0.5 for negative error, 0.5 to 1 for positive error.\n\t\t    #ifdef USE_POSITION_ERROR\n            vec2 positionError = fract(acol.wz) * 2. - 1.;\n            #endif\n            if (ctrl) {\n                //vel *= 1. + rnd.xy;\n                vel *= 1. + rnd3(fragCoord.xy + vec2(dx, dy), 1).xy;\n            }\n            \n            \n            \n            // TODO: try clamping circularly w/ normalize, or at least use clamp()\n            vec2 effectiveVel = clamp(vel, -(maxVelocity - 1.0), maxVelocity - 1.0);\n            \n            // TODO/WIP: try to avoid velocity quantization (which leads to squarey behavior)\n            // with time/error-accumulating fields, one for x and one for y.\n\t\t    #ifdef USE_POSITION_ERROR\n            //effectiveVel += positionError;\n            //positionError = mod(positionError);\n            //positionError = fract(abs(positionError)) * sign(positionError);\n            /*if (positionError.x > 1.) {\n                effectiveVel.x += 1.;\n                positionError.x = 0.;\n            } else \n            if (positionError.x < 1.) {\n                effectiveVel.x -= 1.;\n                positionError.x = 0.;\n            }*/\n            #endif\n            \n            // thinking about collision\n            // this doesn't really make sense because particlesSuperimposed\n            // is only computed for this pixel; other pixels will have a different value\n            // To handle collisions in this scheme, I think I would have to\n            // iterate over the [-maxVel, +maxVel] range twice, maybe in a second pass.\n            /*if (particlesSuperimposed > 0.) {\n                effectiveVel -= accumulatedVel;\n            }*/\n            \n            // TODO: try increasing the effective velEqDetectRange when particle is marked as having collided\n            // for a chain-reaction effect instead of just deleting particles\n            // (can use the z component or w component (to create such a mark); w just needs share with > 0 for the \"existence\" property)\n            \n            \n            //float particlesSuperimposed = 0.0;\n            //vec2 accumulatedVel;\n            if(\n                length(effectiveVel) <= maxVelocity &&\n                acol.w > 0.0 && \n                (float(dx) - velDetectRange < effectiveVel.x && effectiveVel.x < float(dx) + velDetectRange) &&\n                (float(dy) - velDetectRange < effectiveVel.y && effectiveVel.y < float(dy) + velDetectRange)\n            ){\n                // gravity\n                //vel.y += 0.1;\n                \n                // mouse attraction\n                if(iMouse.z > 0.0){\n                    //vec2 towardsMouseDelta = iMouse.xy - fragCoord;\n                    //vec2 wrappedTowardsMouseDelta = mod(iMouse.xy, vec2(10.0, 10.0)) - fragCoord;\n                    //vec2 wrappedTowardsMouseDelta = mod(iMouse.xy, iResolution.xy) - fragCoord;\n                    //if(length(wrappedTowardsMouseDelta) < length(towardsMouseDelta)){\n                    //    towardsMouseDelta = wrappedTowardsMouseDelta;\n                    //}\n                    //float nearestMouseX = iMouse.x - fragCoord.x;\n                    vec2 towardsMouseDelta = toroidalNearestWay(fragCoord, iMouse.xy, iResolution.xy);\n                    \n                    //vec2 towardsMouseDelta = mod(iMouse.xy - fragCoord, iResolution.xy) + iResolution.xy / 2.0;\n                    //vec2 towardsMouseDelta = mod(iMouse.xy - fragCoord - iResolution.xy / 2.0, iResolution.xy) + iResolution.xy / 2.0;\n                    \n                    // Taxicab distance force:\n                    //const float mouseForce = 0.25;\n                    //vec2 towardsMouseForce = normalize(towardsMouseDelta) * mouseForce;\n                    // Euclidean distance force:\n                    //float mouseForce = 1111.0 / (pow(length(towardsMouseDelta), 2.0));\n                    //vec2 towardsMouseForce = normalize(towardsMouseDelta) * mouseForce;\n                    // Limited force (so that it doesn't destroy too many points by pringing them to one point):\n                    // (doesn't help much):\n                    float mouseForce = 1111.0 / (pow(max(length(towardsMouseDelta), 30.), 2.0));\n                    vec2 towardsMouseForce = normalize(towardsMouseDelta) * mouseForce;\n\n\n                    vel.x -= towardsMouseForce.x;\n                    vel.y -= towardsMouseForce.y;\n                }\n                \n                // friction\n                if (enableFriction) {\n                    vel *= 0.99;\n                }\n                // random:\n                //vel *= 1.0 - (RND().x) / 200.0;\n                \n                // max velocity\n                //vel = min(max(vel, -(maxVelocity - 1.0)), maxVelocity - 1.0);\n                // fun:\n                //vel = normalize(vel) * 2.0;\n                // wrong (or corrong):\n                //vel = min(vel, normalize(vel) * (maxVelocity));\n                // correct:\n                vel = normalize(vel) * min(length(vel), maxVelocity - 0.1);\n                \n                /*\n                //col = acol;\n                col.xy = (vel / maxVelocity + 1.0) / 2.0;\n                col.zw = acol.zw;\n                //col.z += RND().x * 0.1;\n                //col.xy += (vel / maxVelocity + 1.0) / 2.0;\n                */\n                \n                accumulatedVel += vel;\n                //accumulatedVel += effectiveVel;\n                \n                #ifdef USE_POSITION_ERROR\n                positionError += fract(abs(vel)) * sign(vel);\n                accumulatedPositionError += positionError;\n                #endif\n                \n                particlesSuperimposed++;\n            }\n            //col.xy /= particlesSuperimposed;\n            //accumulatedVel /= particlesSuperimposed;\n            //col.xy = (accumulatedVel / maxVelocity + 1.0) / 2.0;\n        }\n    }\n    \n    accumulatedVel /= particlesSuperimposed;\n    #ifdef USE_POSITION_ERROR\n    accumulatedPositionError /= particlesSuperimposed;\n    #endif\n    \n    vec4 col;\n    col.xy = (accumulatedVel / maxVelocity + 1.0) / 2.0;\n    // particlesSuperimposed is used here just for coloring purposes.\n    // Note that it must be an integer because of this encoding scheme.\n    // Position error is stored in the fractional part, encoded as\n    // 0 to 0.5 for negative error, 0.5 to 1 for positive error.\n    \n    #ifdef USE_POSITION_ERROR\n    col.zw = vec2(particlesSuperimposed) + (accumulatedPositionError + 1.) / 2.;\n    #else\n    col.zw = vec2(particlesSuperimposed);\n    #endif\n\n    fragColor = col;\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftdGDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[568, 619, 653, 653, 729], [761, 761, 818, 818, 1214]], "test": "untested"}
{"id": "ftd3DX", "name": "terrain 2?", "author": "yonatan", "description": "very fake trees and a lot of artifacts", "tags": ["terrain", "short"], "likes": 12, "viewed": 447, "published": 3, "date": "1636845394", "time_retrieved": "2024-07-30T18:48:23.698955", "image_code": "#define R(a)mat2(cos(a),sin(a),-sin(a),cos(a))\n#define r iResolution.xy\n#define t iTime\n\nvoid mainImage( out vec4 o, in vec2 FC )\n{\n    o=vec4(0);\n    for(float i,e,g,s;i++<50.;g+=e*.5){\n        vec3 c=vec3(4.4,5,5.6),n,p=vec3((FC.xy-.5*r)/r.y*g,g);\n        p.zy*=R(.4+sin(t/3.)*.2);\n        s=1.4;\n        p.z+=t;\n        for(e=++p.y;s<1e3;s*=1.7)\n            p.xz*=R(s),\n            n.xz*=R(s),\n            n+=cos(p*s),\n            e+=sin(p.x*s)/s/2.;\n        n.y=.2;\n        n/=length(n);\n        e-=n.y;\n        c.x+=n.y*3.;\n        o.rgb+=mix(exp(n.z-c),c/3e2,min(g/9.+e,1.4));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftd3DX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 131, 131, 590]], "test": "untested"}
{"id": "ftt3WX", "name": "PIXEL FOO Van Damme", "author": "1j01", "description": "Rotating buffered square with video added. Fork of [url]https://shadertoy.com/view/4lSyRw[/url]", "tags": ["rotation", "lowres", "stepped", "buffered", "rotated"], "likes": 3, "viewed": 288, "published": 3, "date": "1636834664", "time_retrieved": "2024-07-30T18:48:24.590571", "image_code": "// Fork of \"PIXEL FOO\" by isak. https://shadertoy.com/view/4lSyRw\n// 2021-11-13 20:14:00\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n\tfragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Fork of \"PIXEL FOO\" by isak. https://shadertoy.com/view/4lSyRw\n// 2021-11-13 20:14:00\n\nmat2 rot(float a) {\n\tfloat c = cos(a); float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nvoid addVideo(inout vec4 fragColor, sampler2D channel, vec2 UV, float amount) {\n    vec4 videoColor = texture(channel, UV);\n    //vec4 green = vec4(0.0,0.659,0.0,1.0); // measured green from screen pixels\n    vec4 green = vec4(0.0,1.0,0.0,1.0); // pure green\n    float greenness = pow(1. - length(videoColor - green), 2.) * 3.;\n    videoColor -= (green * pow(greenness, 1.0)) * 0.9; // prevent green bleeding somewhat\n    fragColor += mix(0.9*videoColor, vec4(0.0),greenness) * amount;\n    //fragColor = vec4(greenness); // debug\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float t = iTime * 0.7;\n\n\tvec2 uv = fragCoord.xy - 0.5*iResolution.xy;\n    uv *= 2.0/iResolution.y;\n    uv *= 2.0*rot(t); \n    \n    vec2 UV = fragCoord.xy - 0.5*iResolution.xy;\n    UV *= rot(0.1*sin(t))*(1.0 + 0.05*sin(0.5*t));\n    UV += 0.5*iResolution.xy;\n    UV /= iResolution.xy;\n    \n    float s = abs(uv.x) + abs(uv.y); // \"Square\"\n    \n    fragColor = 0.95*texture(iChannel0, UV);\n\tfragColor += vec4(1.0)*( step(1.0, s) - step(1.025, s));\n    \n    float amount = 0.1; // good to reduce if enabling flips\n    amount /= min(cos(t), 1.0);\n    addVideo(fragColor, iChannel1, UV, amount);\n    //addVideo(fragColor, iChannel1, UV*vec2(-1., 1.)+vec2(1., 0.), amount); // x flip\n    //addVideo(fragColor, iChannel1, UV*vec2(1., -1.)+vec2(0., 1.), amount); // y flip\n    //addVideo(fragColor, iChannel1, UV*vec2(-1., -1.)+vec2(1., 1.), amount); // rotated\n}", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftt3WX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 147, 147, 214]], "test": "untested"}
{"id": "slc3DX", "name": "Oscilloscope music", "author": "incription", "description": "change the freq() function to change the waveform. make sure the two channels are dissimilar to make an interesting shape. Mouse x to zoom in", "tags": ["oscilloscope", "sound", "music", "audio"], "likes": 37, "viewed": 2937, "published": 3, "date": "1636823891", "time_retrieved": "2024-07-30T18:48:25.460246", "image_code": "#define SAMPLES 600.\nfloat sdSound(vec2 uv) {\n    float i;\n    float hits;\n    \n    float t = iTime;\n    vec2 f = freq(t);\n    vec2 prev;\n    float dt = iTimeDelta / SAMPLES;\n    for(i = 1.; i < SAMPLES; i++) {\n        t += dt;\n\n        prev = f;\n        f = freq(t);\n        \n        hits += min(1., 1. / (sdSegment(uv * (1. - iMouse.x / iResolution.x), prev, f) * 2500.));\n    }\n    \n    return 200. * hits/SAMPLES;\n}\n\nvec2 cube(vec2 uv) {\n    return mod((uv+.5)*8., vec2(1))-.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 col = vec3(0.000,0.000,0.000);\n    col = mix(col, vec3(0.000,0.000,0.000), 1.-length(uv));\n    col = mix(col, vec3(0.031,0.031,0.031), float(sdBox(cube(uv), vec2(.49)) <= 0.));\n    col = mix(col, vec3(0.404,0.984,0.396), sdSound(uv*3.));\n    \n    vec2 puv = fragCoord/iResolution.xy;\n    puv *= 1. - puv.yx;\n    col *= pow(puv.x*puv.y*30.,.5);\n    \n    // Output to screen\n    fragColor = vec4(col * vec3(0.000,0.667,1.000),1.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159\n#define TAU 6.2831\n#define A4 440.\n#define A3 220.\n\nmat2 rotationMatrix(float angle)\n{\n\tangle *= PI / 180.0;\n    float s=sin(angle), c=cos(angle);\n    return mat2( c, -s, s, c );\n}\n\nfloat pitch(float i)\n{\n    //cool sfttttuuufffffffff\n    return 415. * pow(2., (i - 60.) / 12.);\n}\n\nfloat wave(float f, float a, float time)\n{\n    float w = 2. * PI * f * time;\n    //float v = pow(abs(sin(w / 2.)), 8.) - .5;\n    float v = pow(max(0., (sin(w) + 1.) / 2.), 2.) - .5;\n    return a * v;\n}\n\nfloat songFreq(float time) {\n    return A4 + A4 * floor(mod(max(0.,time*5.-1.5),5.)) + A4 * floor(mod(max(0.,time*5.-2.5),5.));\n}\n\n\nvec2 freq(float time) {\n    time *= 1.;\n    float f = A3;\n    \n    vec2 fr = vec2(wave(A3 * 2., .5, time) + wave(A4 * 4., .5, time), wave(A3*(2. + PI / 5000.), .5, time) + wave(A3*1., .5, time));\n    return fr * rotationMatrix(time * 40.) * .5;\n}\n\n//https://iquilezles.org/articles/distfunctions2d\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n", "sound_code": "vec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return freq(time);\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slc3DX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 45, 45, 419], [421, 421, 441, 441, 483], [485, 485, 542, 592, 1126]], "test": "untested"}
{"id": "flcGWf", "name": "gradiant sheen slider random res", "author": "gchipunov", "description": "made in 2 minutes", "tags": ["2d", "gradiant", "stock"], "likes": 0, "viewed": 119, "published": 3, "date": "1636808762", "time_retrieved": "2024-07-30T18:48:26.277062", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2.0/uv.x,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flcGWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 301]], "test": "untested"}
{"id": "NlcGWX", "name": "reaction diffusion cells", "author": "drschizzo", "description": "from http://www.karlsims.com/rd.html\nuse the mouse to interact\nyou can change f and k values in common for different results", "tags": ["simulation", "wip", "25d", "cellularautomata", "multipass"], "likes": 2, "viewed": 371, "published": 3, "date": "1636802791", "time_retrieved": "2024-07-30T18:48:27.067947", "image_code": "float map(vec2 pos){\n    return max(0.2,texture(iChannel0,pos).x);\n}\n\nvec2 calcNormal( in vec2 pos )\n{\n\tvec2 eps = vec2( 0.001, 0.0 );\n\tvec2 nor = vec2(\n\t    map(pos+eps.xy) - map(pos-eps.xy),\n\t    map(pos+eps.yx) - map(pos-eps.yx));\n\treturn normalize(nor+.0001);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    vec2 g=calcNormal(uv);\n    \n    vec3 l=(.3+.7*dot(g,normalize(vec2(.8,.2))))*vec3(.2,.4,.9);\n    vec3 l2=(.3+.7*dot(g,normalize(vec2(.0,.6))))*vec3(.8,.6,.1);\n   // vec2 r=reflect(g,vec2(.5,.5)-uv);\n   // vec3 s=pow(dot(normalize(r),normalize(uv)),.9)*vec3(.8);\n    fragColor=texture(iChannel1,uv+.01*g)*vec4(clamp(l+l2*.8,0.,1.),1.);\n    vec4 c=texture(iChannel0,uv);\n    fragColor = mix(vec4(.9,.1,.1,1.)*(.7+sin(iTime+uv.x*uv.y*4.)*.2)+fragColor,fragColor,c.x);\n    vec4(vec3(c.x),1.0);\n   \n\n}", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n        \n    \n    if(iFrame<3)\n        fragColor=vec4(1.,0.,0.,1.);\n    else if(length(iMouse.xy/iResolution.xy-uv)<.03)\n            fragColor=vec4(0.,1.,0.,1.);\n    else{\n        float offset=1./iResolution.y;\n\n        fragColor=computeSim(uv,iChannel0,offset);\n    }\n\n}\n\n", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float offset=1./iResolution.y;\n\n    fragColor=computeSim(uv,iChannel0,offset);\n\n}\n\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n   vec2 uv = fragCoord/iResolution.xy;\n    \n    float offset=1./iResolution.y;\n\n    fragColor=computeSim(uv,iChannel0,offset);\n\n}\n\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float offset=1./iResolution.y;\n\n    fragColor=computeSim(uv,iChannel0,offset);\n}\n\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec4 computeSim( vec2 uv,sampler2D channel,float offset)\n{\n\n\n    float da=1., db=.5;\n    \n  //  float f=.014, k=.047;\n  //  float f=0.022, k=0.0509;\n    \n    float f=.01, k=.042;\n    \n   \n        float a=texture(channel,uv).x;\n        float b=texture(channel,uv).y;\n\n        float an,bn=0.;\n        int s=0;\n        for(float i=-offset;i<=offset;i+=offset){\n            for(float j=-offset;j<=offset;j+=offset){\n                vec4 c=texture(channel,uv+vec2(i,j));\n                if(i==0. && j==0.)\n                    c*=-1.;\n                else if(abs(i)==abs(j))\n                    c*=.05;\n                else\n                    c*=.2;\n                an+=c.x;\n                bn+=c.y;\n\n            }\n        }\n\n       a=a+(da*an-(a*b*b)+f*(1.-a))*1.;\n       b=b+(db*bn+(a*b*b)-(k+f)*b)*1.;\n    \n\n return vec4(a,b,0.,1.);\n\n\n         \n\n\n\n}", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlcGWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 68], [70, 70, 102, 102, 265], [269, 269, 326, 326, 873]], "test": "untested"}
{"id": "flc3DX", "name": "myFirstShamder", "author": "AlanHaBrony", "description": "Oh I just want to add sin to make some animation, so amazing! (Although I even haven't figure out how it works (a little shame)\n\nAnd I very very wonder the math behand this (it isn't high level but high \"performance\")", "tags": ["sin", "animate"], "likes": 1, "viewed": 209, "published": 3, "date": "1636802450", "time_retrieved": "2024-07-30T18:48:27.838886", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=.5f;\n    \n    //grt time(much easier than in vs2019)\n    float t=iTime;\n   \n    float d=length(uv);\n    float an=d+sin(t+.5f);\n    \n    vec2 ret=fract(5.*an*uv);\n\n    // Output to screen\n    fragColor = vec4(ret,1.,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flc3DX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 378]], "test": "untested"}
{"id": "7ldGD2", "name": "Stained Glass Window", "author": "1j01", "description": "Based on [url=https://www.shadertoy.com/view/Xdj3Wh]Xmas Fractal 2Tweets[/url]", "tags": ["fractals", "glass", "kaleidoscope", "windows", "window", "cathedral", "stainedglass", "church", "pane", "panes", "mosque", "shattered"], "likes": 10, "viewed": 523, "published": 3, "date": "1636786369", "time_retrieved": "2024-07-30T18:48:28.608827", "image_code": "// based on Xmas Fractal 2Tweets by mplanck https://www.shadertoy.com/view/Xdj3Wh\n\nvoid imageSample( out vec4 f, in vec2 w )\n{\n\tfloat t = .001 * iTime + .3;\n\tvec4 p = abs(4.-8.*w.xyxx / iResolution.x), c=p*.0;\n\tp.yx *= 60. * t * 0.3;\n    t *= 0.9; // not just affecting time\n\tfor (float d=.2;d<3.;d+=.3) {\n\t\tp -= .5*d;\n\t\tfor (int i=0;i<8;i++) p.xy=mat2(\n            cos(t),sin(t),-sin(t),cos(t))*(p.xy+sign(p.yx)*vec2(-.2,1.6)\n        );\n        //p = mod(p+c, 10.);\n\t\tc += .1*p;\n        c = mod(c, 4.);\n        //c.xz = c.zx;\n        c *= w.y/1000.; // gradient\n\t}\n\t\n\tf = c;\n}\n\nvoid mainImage( out vec4 f, in vec2 w )\n{\n    // I'm doing some sort of naive edge detection,\n    // in order to make the border of the imagined stained glass panes.\n    vec4 s1, s2, s3, s4;\n    float d = 1.2;\n\timageSample(s1, w+vec2(-d, 0.));\n\timageSample(s2, w+vec2(+d, 0.));\n\timageSample(s3, w+vec2(0., -d));\n\timageSample(s4, w+vec2(0., +d));\n    \n    // color components -> single value (not weighted perceptually or anything)\n    s1.xyzw = vec4(s1.x + s1.y + s1.z);\n    s2.xyzw = vec4(s2.x + s2.y + s2.z);\n    \n    // take main sample\n\timageSample(f, w);\n    \n    // apply black borders\n    f -= abs(s1 - s2) * 20.;\n    f -= abs(s3 - s3) * 20.;\n    \n    //f -= 0.2;\n    //f = pow(f, vec4(0.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ldGD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 126, 126, 577], [579, 579, 620, 744, 1280]], "test": "untested"}
{"id": "7lt3W2", "name": "Footwear Design 005", "author": "yasuo", "description": "・Modified version of the footwear design 004.\n・Implemented vertically wavy upper shape\n・Implemented wavy traction pattern as the outsole.", "tags": ["footwear"], "likes": 5, "viewed": 201, "published": 3, "date": "1636781578", "time_retrieved": "2024-07-30T18:48:29.376774", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define Slice(p,a) dot(p,vec2(cos(a),sin(a)))\n#define S(p,d,b) smoothstep(fwidth(p.y),0.0,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define MATERIAL 0\n\n#define ZERO (min(iFrame,0))\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// IQ's 3D noise function. It's faster than the FBM and enough for me to design.\n// The compile is also faster.\nfloat noise3d( vec3 p )\n{\n    const vec3 s = vec3(27, 111, 57);\n    vec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.); // option\n    h = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdSimpleCylinder(vec3 p, float r, float h){\n    float d = length(p.xz)-r;\n    d = max(abs(p.y)-h,d);\n    return d;\n}\n\nfloat baseOutsole(vec3 p, float h){\n    vec3 prevP = p;\n    \n    p.xz*=Rot(radians(17.0));\n    p.z*=0.4;\n    p.x*=0.57;\n    p.x+=0.03;\n    p.z-=0.07;\n    \n    float d =sdSimpleCylinder(p,0.1,h);\n    \n    p = prevP;\n    p.xy*=Rot(radians(90.0));\n    p.y*=1.5;\n    p.z*=1.2;\n    float d2 = sdCappedCylinder(p-vec3(0.0,0.0,-0.25),h,0.2);\n    d = opSmoothUnion(d, d2,0.13);\n    \n    p = prevP;\n    d = max(abs(p.y)-h,d);\n    \n    return (d)*0.6;\n}\n\nfloat outsole(vec3 p){\n    p.z*=0.9;\n    vec3 prevP = p;\n    \n    float d = baseOutsole(p-vec3(0.0,0.02,0.),0.06);\n    \n    // wave traction pattern\n    p.z+=sin(p.x*100.0)*0.01;\n    p.z = mod(p.z,0.08)-0.04;\n    float d2 = sdBox(p,vec3(0.2,0.03,0.03))*0.6;\n    \n\n    d = max(d,d2);\n    p = prevP;\n    d2 = baseOutsole(p-vec3(0.0,0.035,0.0),0.035);\n    d = min(d,d2);\n    \n    p = prevP;\n    float a  = radians(4.0);\n    p.y-=0.06;\n    float mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(mask,d);\n    \n    p = prevP;\n    a  = radians(-8.0);\n    p.y+=0.07;\n    mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(-mask,d);\n    \n    p = prevP;\n    a  = radians(10.0);\n    p.y+=0.08;\n    mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(-mask,d);\n    \n    return d;\n}\n\n\nfloat upperBase(vec3 p){\n    p.z*=0.9;\n    vec3 prevP2 = p;\n    p.y+=sin(p.z*300.0)*0.005;\n    p.x+=cos(p.y*70.0)*0.005;\n    vec3 prevP = p;\n\n    //p.x*=1.;\n    p.z*=0.8;\n    \n    float d =sdCappedCone(p-vec3(0.0,0.18,-0.15),0.13,0.15,0.06);\n    \n    p = prevP;\n    p.xz*=Rot(radians(15.0));\n    p.yz*=Rot(radians(-6.0));\n    p.x*=1.2;\n    p.z*=0.8;\n    \n    float d2 = sdEllipsoid(p-vec3(-0.05,0.1,0.14),vec3(0.2,0.08,0.2));\n    d = opSmoothUnion(d,d2,0.1);//0.1\n    \n    p = prevP;\n    p.xz*=Rot(radians(0.0));\n    p.x*=1.1;\n    p.z*=0.8;\n    p.yz*=Rot(radians(-35.0));\n\n    d2 = sdEllipsoid(p-vec3(0.0,0.21,-0.1),vec3(0.1,0.04,0.15));\n\n    d = opSmoothUnion(d,d2,0.17);//0.15\n    \n    p = prevP2;\n    p.xy*=Rot(radians(90.0));\n    p.xz*=Rot(radians(18.0));\n    p.y*=1.5;\n    p.z*=1.0;\n    d2 = sdCappedCylinder(p-vec3(-0.1,0.0,-0.2),0.001,0.2);\n    d = opSmoothUnion(d, d2,0.07);\n    \n    p = prevP2;\n    p.xy*=Rot(radians(90.0));\n    p.xz*=Rot(radians(15.0));\n    p.y*=1.3;\n    p.z*=0.99;\n    d2 = sdCappedCylinder(p-vec3(-0.04,0.0,-0.22),0.001,0.2);\n    d = opSmoothUnion(d, d2,0.07);\n    \n    return d;\n}\n\nfloat upper(vec3 p){\n    vec3 prevP = p;\n    float d = upperBase(p);\n    p.x*=1.5;\n    p.y*=1.1;\n    p.z*=1.12;\n    \n    float d2 = upperBase(p-vec3(0.0,0.02,0.0));\n    d = max(-d2,d);\n    \n    p = prevP;\n    \n    p.x*=1.6;\n    p.z*=0.7;\n    \n    d2 =sdCappedCone(p-vec3(-0.01,0.25,-0.1),0.14,0.14,0.09)*0.6;\n    d = max(-d2,d);\n    \n    p = prevP;\n    float a  = radians(8.0);\n    p.y-=0.31;\n    float mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(mask,d);\n    \n    p = prevP;\n    p.yz*=Rot(radians(-12.0));\n    p.x*=1.2;\n    p.y*=1.2;\n    p.z*=0.65;\n    d2 = sdTorus(p-vec3(-0.005,0.35,-0.145),vec2(0.1,0.02));\n    \n    d = opSmoothUnion(d,d2,0.04);\n    \n    p = prevP;\n    p.x*=1.4;\n    p.z*=0.75;\n    d2 =sdSimpleCylinder(p-vec3(-0.005,0.35,-0.115),0.1,0.2);\n    d = max(-d2,d);\n    \n    return d*0.8;\n}\n\nvec2 GetDist(vec3 p) {\n    p+=noise3d(p*600.0)*0.0002;\n    vec3 prevP = p;\n    \n    p.y+=0.075;\n    //p.z+=0.1;\n    float d = outsole(p);\n    float d2 = upper(p-vec3(0.0,0.0,0.0));\n    d =  opSmoothUnion(d,d2,0.03);\n    \n    vec2 model = vec2(d,MATERIAL);\n\n    return model;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<3; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,2,-2));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*shadow*occ;\n    diffCol += col*vec3(1.0,1.0,0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 20.)*occ; // spec\n        \n    return diffCol;\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(234.56,789.34));\n    p+=dot(p,p+34.56);\n    return fract(p.x+p.y);\n}\n\nvec3 evaTex(vec2 uv, vec3 col){\n    uv.y+=iTime*0.1;\n    vec2 prevUV = uv;\n    uv*=30.0;\n    \n    vec2 gv = fract(uv)-0.5;\n    vec2 id = floor(uv);\n    \n    float n = Hash21(id);\n    gv.y*=n;\n    \n   // gv.x+=cos(uv.y*5.0)*0.2+sin(uv.y*2.0)*0.05;\n    float d = length(gv)-0.5*abs(n);\n    if(n<0.5){\n            col = mix(col,vec3(1.3),S(prevUV,d,0.0));\n    }\n    \n    return col;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    if(mat == MATERIAL){\n        col = diffuseMaterial(n,rd,p,vec3(0.7)*evaTex(p.xz+p.yy,col));\n        //col = diffuseMaterial(n,rd,p,vec3(0.7,0.8,0.7));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy -.3;\n    \n    vec3 ro = vec3(0, 0, 1.0);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-30.0));\n    if(iMouse.z>0.){\n        ro.yz *= Rot(-m.y*3.14+1.);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.xz *= Rot(radians(-5.0+iTime*20.0));\n        \n        //ro.yz *= Rot(radians(120.0));\n        //ro.xz *= Rot(radians(45.0));\n    }\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n        //col *= exp( -0.038*d.x*d.x*d.x );//fog\n    } else {\n        //col = upperTex(uv,col);\n    }\n    \n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lt3W2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[390, 390, 415, 415, 434], [435, 435, 460, 460, 479], [480, 480, 532, 532, 632], [634, 746, 771, 771, 1116], [1118, 1118, 1154, 1154, 1196], [1198, 1247, 1280, 1280, 1345], [1347, 1396, 1448, 1448, 1555], [1557, 1606, 1637, 1637, 1724], [1726, 1775, 1812, 1812, 1895], [1897, 1946, 2005, 2005, 2318], [2320, 2320, 2369, 2369, 2442], [2444, 2444, 2479, 2479, 2887], [2889, 2889, 2911, 2911, 3656], [3659, 3659, 3683, 3683, 4769], [4771, 4771, 4791, 4791, 5582], [5584, 5584, 5606, 5606, 5860], [5862, 5862, 5920, 5920, 6187], [6189, 6189, 6213, 6213, 6414], [6416, 6416, 6458, 6458, 6653], [6655, 6696, 6745, 6745, 7039], [7041, 7041, 7098, 7098, 7717], [7719, 7719, 7741, 7741, 7831], [7833, 7833, 7864, 7864, 8214], [8216, 8216, 8275, 8275, 8454], [8456, 8456, 8513, 8513, 9557]], "test": "untested"}
{"id": "7tt3W2", "name": "Footwear Design 004", "author": "yasuo", "description": "・Modeled as the EVA form shoes that all materials are being used the EVA material included the outsole.\n・Implemented wavy upper shape with small holes for breathability\n・Implemented hexagonal traction pattern as the outsole.", "tags": ["footwear"], "likes": 5, "viewed": 214, "published": 3, "date": "1636781418", "time_retrieved": "2024-07-30T18:48:30.255425", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define Slice(p,a) dot(p,vec2(cos(a),sin(a)))\n#define S(p,d,b) smoothstep(fwidth(p.y),0.0,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define MATERIAL 0\n\n#define ZERO (min(iFrame,0))\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// IQ's 3D noise function. It's faster than the FBM and enough for me to design.\n// The compile is also faster.\nfloat noise3d( vec3 p )\n{\n    const vec3 s = vec3(27, 111, 57);\n    vec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.); // option\n    h = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdSimpleCylinder(vec3 p, float r, float h){\n    float d = length(p.xz)-r;\n    d = max(abs(p.y)-h,d);\n    return d;\n}\n\nfloat baseOutsole(vec3 p, float h){\n    vec3 prevP = p;\n    \n    p.xz*=Rot(radians(17.0));\n    p.z*=0.4;\n    p.x*=0.57;\n    p.x+=0.03;\n    p.z-=0.07;\n    \n    float d =sdSimpleCylinder(p,0.1,h);\n    \n    p = prevP;\n    p.xy*=Rot(radians(90.0));\n    p.y*=1.5;\n    p.z*=1.2;\n    float d2 = sdCappedCylinder(p-vec3(0.0,0.0,-0.25),h,0.2);\n    d = opSmoothUnion(d, d2,0.13);\n    \n    p = prevP;\n    d = max(abs(p.y)-h,d);\n    \n    return (d)*0.6;\n}\n\nfloat outsole(vec3 p){\n    p.z*=0.9;\n    vec3 prevP = p;\n    \n    float d = baseOutsole(p-vec3(0.0,0.02,0.),0.06);\n    \n    p.x = mod(p.x,0.1)-0.05;\n    p.z = mod(p.z,0.08)-0.04;\n    p.zy*=Rot(radians(90.0));\n    float d2 = sdHexPrism(p,vec2(0.03,0.03))*0.6;\n    \n    p = prevP;\n    p.x-=0.05;\n    p.z-=0.065;\n    p.x = mod(p.x,0.1)-0.05;\n    p.z = mod(p.z,0.08)-0.04;\n    p.zy*=Rot(radians(90.0));\n    float d3 = sdHexPrism(p,vec2(0.03,0.03))*0.6;\n    d2 = min(d2,d3);\n    \n    d = max(d,d2);\n    p = prevP;\n    d2 = baseOutsole(p-vec3(0.0,0.035,0.0),0.035);\n    d = min(d,d2);\n    \n    p = prevP;\n    float a  = radians(4.0);\n    p.y-=0.06;\n    float mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(mask,d);\n    \n    p = prevP;\n    a  = radians(-8.0);\n    p.y+=0.07;\n    mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(-mask,d);\n    \n    p = prevP;\n    a  = radians(10.0);\n    p.y+=0.08;\n    mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(-mask,d);\n    \n    return d;\n}\n\n\nfloat upperBase(vec3 p){\n    p.z*=0.9;\n    vec3 prevP = p;\n\n    //p.x*=1.;\n    p.z*=0.8;\n    \n    float d =sdCappedCone(p-vec3(0.0,0.18,-0.15),0.13,0.15,0.06);\n    \n    p = prevP;\n    p.xz*=Rot(radians(15.0));\n    p.yz*=Rot(radians(-6.0));\n    p.x*=1.2;\n    p.z*=0.8;\n    \n    float d2 = sdEllipsoid(p-vec3(-0.05,0.1,0.14),vec3(0.2,0.08,0.2));\n    d = opSmoothUnion(d,d2,0.1);//0.1\n    \n    p = prevP;\n    p.xz*=Rot(radians(0.0));\n    p.x*=1.1;\n    p.z*=0.8;\n    p.yz*=Rot(radians(-35.0));\n\n    d2 = sdEllipsoid(p-vec3(0.0,0.21,-0.1),vec3(0.1,0.04,0.15));\n\n    d = opSmoothUnion(d,d2,0.17);//0.15\n    \n    p = prevP;\n    p.xy*=Rot(radians(90.0));\n    p.xz*=Rot(radians(18.0));\n    p.y*=1.5;\n    p.z*=1.0;\n    d2 = sdCappedCylinder(p-vec3(-0.1,0.0,-0.2),0.001,0.2);\n    d = opSmoothUnion(d, d2,0.07);\n    \n    p = prevP;\n    p.xy*=Rot(radians(90.0));\n    p.xz*=Rot(radians(15.0));\n    p.y*=1.3;\n    p.z*=0.99;\n    d2 = sdCappedCylinder(p-vec3(-0.04,0.0,-0.22),0.001,0.2);\n    d = opSmoothUnion(d, d2,0.07);\n    \n    return d;\n}\n\n    //vec3 prevP = p;\n    //p.y+=sin(p.z*200.0)*0.0025;\n\nfloat upper(vec3 p){\n    vec3 prevP = p;\n    p.x+=sin(p.y*100.0)*0.0025;\n    float d = upperBase(p);\n    p.x*=1.5;\n    p.y*=1.1;\n    p.z*=1.12;\n    \n    float d2 = upperBase(p-vec3(0.0,0.02,0.0));\n    d = max(-d2,d);\n    \n    p = prevP;\n        \n    \n    p.xy*=Rot(radians(90.0));\n    p.xz*=Rot(radians(15.0));\n    p.z*=0.15;\n    p.z+=0.015;\n    p.z=abs(p.z);\n    p.z-=0.035;\n    d2 =sdSimpleCylinder(p-vec3(-0.18,0.0,-0.015),0.015,0.5);\n    d = max(-d2,d);\n    \n    p = prevP;\n    \n    p.xy*=Rot(radians(90.0));\n    p.xz*=Rot(radians(15.0));\n    p.z*=0.23;\n    d2 =sdSimpleCylinder(p-vec3(-0.18,0.0,0.06),0.015,0.5);\n    d = max(-d2,d);\n    \n    p = prevP;\n    \n    p.x*=1.6;\n    p.z*=0.7;\n    \n    d2 =sdCappedCone(p-vec3(-0.01,0.25,-0.1),0.14,0.14,0.09)*0.6;\n    d = max(-d2,d);\n    \n    p = prevP;\n    float a  = radians(8.0);\n    p.y-=0.31;\n    float mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(mask,d);\n    \n    p = prevP;\n    p.yz*=Rot(radians(-12.0));\n    p.x*=1.2;\n    p.y*=1.2;\n    p.z*=0.65;\n    d2 = sdTorus(p-vec3(-0.005,0.35,-0.145),vec2(0.1,0.02));\n    \n    d = opSmoothUnion(d,d2,0.04);\n    \n    p = prevP;\n    p.x*=1.4;\n    p.z*=0.75;\n    d2 =sdSimpleCylinder(p-vec3(-0.005,0.35,-0.115),0.1,0.2);\n    d = max(-d2,d);\n    \n    return d*0.8;\n}\n\nvec2 GetDist(vec3 p) {\n    p+=noise3d(p*600.0)*0.0002;\n    vec3 prevP = p;\n    \n    p.y+=0.075;\n    //p.z+=0.1;\n    float d = outsole(p);\n    float d2 = upper(p-vec3(0.0,0.0,0.0));\n    d =  opSmoothUnion(d,d2,0.03);\n    \n    vec2 model = vec2(d,MATERIAL);\n\n    return model;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<3; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,2,-2));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*shadow*occ;\n    diffCol += col*vec3(1.0,1.0,0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 20.)*occ; // spec\n        \n    return diffCol;\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(234.56,789.34));\n    p+=dot(p,p+34.56);\n    return fract(p.x+p.y);\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    if(mat == MATERIAL){\n        col = diffuseMaterial(n,rd,p,vec3(0.7,0.8,0.7));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy -.3;\n    \n    vec3 ro = vec3(0, 0, 1.0);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-30.0));\n    if(iMouse.z>0.){\n        ro.yz *= Rot(-m.y*3.14+1.);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.xz *= Rot(radians(-5.0+iTime*20.0));\n        \n        //ro.yz *= Rot(radians(120.0));\n        //ro.xz *= Rot(radians(45.0));\n    }\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n        //col *= exp( -0.038*d.x*d.x*d.x );//fog\n    } else {\n        //col = upperTex(uv,col);\n    }\n    \n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tt3W2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[390, 390, 415, 415, 434], [435, 435, 460, 460, 479], [480, 480, 532, 532, 632], [634, 746, 771, 771, 1116], [1118, 1118, 1154, 1154, 1196], [1198, 1247, 1283, 1283, 1556], [1558, 1607, 1640, 1640, 1705], [1707, 1756, 1808, 1808, 1915], [1917, 1966, 1997, 1997, 2084], [2086, 2135, 2172, 2172, 2255], [2257, 2306, 2365, 2365, 2678], [2680, 2680, 2729, 2729, 2802], [2804, 2804, 2839, 2839, 3247], [3249, 3249, 3271, 3271, 4227], [4230, 4230, 4254, 4254, 5256], [5315, 5315, 5335, 5335, 6579], [6581, 6581, 6603, 6603, 6857], [6859, 6859, 6917, 6917, 7184], [7186, 7186, 7210, 7210, 7411], [7413, 7413, 7455, 7455, 7650], [7652, 7693, 7742, 7742, 8036], [8038, 8038, 8095, 8095, 8714], [8716, 8716, 8738, 8738, 8828], [8830, 8830, 8889, 8889, 8995], [8997, 8997, 9054, 9054, 10098]], "test": "untested"}
{"id": "Nl33W2", "name": "Mandelbrot / Julia Set", "author": "ArmandB", "description": "hold click to move through Julia sets", "tags": ["mandelbrot"], "likes": 3, "viewed": 205, "published": 3, "date": "1636781363", "time_retrieved": "2024-07-30T18:48:31.030353", "image_code": "vec3 hsv(float h, float s, float v){\n    vec3 col = vec3(\n        abs(mod(h,1.0)-0.5) - 1.0/6.0,\n        abs(mod(h + 1.0/3.0,1.0)-0.5) - 1.0/6.0,\n        abs(mod(h + 2.0/3.0,1.0)-0.5) - 1.0/6.0\n    );\n    col *= v;\n    float avg = (col.r + col.g + col.b)/3.0;\n    col = (col - avg)*s + avg;\n    return clamp(col*3.0, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float borderPos = iResolution.x/1.8;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n    if (fragCoord.x < borderPos){\n        col = hsv(col.x/100.0 + iTime/100.0, 1.0, col.x);\n    } else {\n        col = hsv(col.x/30.0 + iTime/100.0, 1.0, col.x*1.0);\n    }\n    \n    float dist = distance(uv*500.0,iMouse.xy/iResolution.xy*500.0);\n    col += sin(dist-iTime*10.0)/(dist*dist);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    float borderPos = iResolution.x/1.8;\n    \n    vec2 m = (iMouse.xy - iResolution.xy/2.0) / (iResolution.xy/2.7);\n    m.x *= iResolution.x/iResolution.y;\n    m.x += 0.35;\n    m.y += -0.2;\n        \n    vec2 coord = (fragCoord - iResolution.xy/2.0) / (iResolution.xy/2.7);\n    coord.x *= iResolution.x/iResolution.y;\n    coord.x += 0.35;\n    coord.y += -0.2;\n    \n    if (iChannelTime[0] < 0.5){\n        if (fragCoord.x < borderPos) {\n            int c = 0;\n            float c_r = coord.x;\n            float c_i = coord.y;\n            float z_r = 0.0;\n            float z_rt = 0.0;\n            float z_i = 0.0;\n            float size_z = 0.0;\n\n            while (float(c) <= threshold && size_z <= 4.0) {\n                z_rt = z_r;\n                z_r = z_r*z_r - z_i*z_i + c_r;\n                z_i = 2.0 * z_i * z_rt + c_i;\n                size_z = z_r*z_r + z_i*z_i;\n                c++;\n            }\n            if (size_z > 4.0) {\n                col.r = float(c) + 1.0 - log(log(z_r*z_r + z_i*z_i)/2.0)/log(2.0);\n            }\n        } else if (fragCoord.x >= borderPos){\n            coord.x -= 1.6;\n            coord *= 1.5;\n\n            int c = 0;\n            float c_r = m.x;\n            float c_i = m.y;\n            float z_r = coord.x;\n            float z_i = coord.y;\n            float z_rt = 0.0;\n            float size_z = 0.0;\n\n            while (float(c) <= threshold && size_z <= 4.0) {\n                z_rt = z_r;\n                z_r = z_r*z_r - z_i*z_i + c_r;\n                z_i = 2.0 * z_i * z_rt - c_i;\n                size_z = z_r*z_r + z_i*z_i;\n                c++;\n            }\n            if (size_z > 4.0){\n                col = vec3(float(c)/10.0);\n            }\n        }\n    } else {\n        vec2 uv = fragCoord/iResolution.xy;\n        col = texture(iChannel0, uv).xyz;\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float threshold = 1000.0;", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl33W2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 329], [331, 331, 388, 388, 840]], "test": "untested"}
{"id": "sldGW2", "name": "aberrating aberrations filter", "author": "morisil", "description": "Testing something out", "tags": ["chromaticaberration", "study", "depthoffield", "focus"], "likes": 9, "viewed": 572, "published": 3, "date": "1636781067", "time_retrieved": "2024-07-30T18:48:31.813260", "image_code": "// Fork of \"aberrating aberrations on video\" by morisil. https://shadertoy.com/view/7tdGW2\n// 2021-11-13 05:24:16\n\n// Fork of \"depth of field focus study 2\" by morisil. https://shadertoy.com/view/flc3zX\n// 2021-11-13 05:16:16\n\n// Fork of \"depth of field focus study\" by morisil. https://shadertoy.com/view/sld3zB\n// 2021-11-08 19:52:49\n\nconst float SHAPE_SIZE = .7;\nconst float CHROMATIC_ABBERATION = .02;\nconst float ITERATIONS = 5.;\nconst float INITIAL_LUMA = .6;\n\nfloat getColorComponent(in vec2 st, in float modScale, in float blur) {\n    vec2 modSt = mod(st, 1. / modScale) * modScale * 2. - 1.;\n    float dist = length(modSt);\n    float angle = atan(modSt.x, modSt.y);\n    float shapeMap = smoothstep(SHAPE_SIZE + blur, SHAPE_SIZE - blur, dist);\n    return shapeMap;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st =\n        (2.* fragCoord - iResolution.xy)\n        / min(iResolution.x, iResolution.y);\n\n    float modScale = 2.;\n\n    vec3 color = vec3(0);\n    float luma = INITIAL_LUMA;\n    float blur = .2;\n    for (float i = 0.; i < ITERATIONS; i++) {\n        vec2 center = st + vec2(sin(iTime * .4), cos(iTime * .45)) * .3;\n        //center += pow(length(center), 1.);\n        vec2 modSt = mod(st, 1. / modScale) * modScale * 2. - 1.;\n        vec3 shapeColor = vec3(\n            getColorComponent(center - st * CHROMATIC_ABBERATION, modScale, blur),\n            getColorComponent(center, modScale, blur),\n            getColorComponent(center + st * CHROMATIC_ABBERATION, modScale, blur)        \n        ) * luma * texture(iChannel0, (center * vec2(-1, 1) + 1.) * .5).rgb;\n        st *= 1.3;\n        color += shapeColor;\n        color = clamp(color, 0., 1.);\n        if (color == vec3(1)) break;\n        luma *= .63;\n        blur *= .63;\n    }\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sldGW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[467, 467, 538, 538, 774], [776, 776, 831, 831, 1852]], "test": "untested"}
{"id": "7tdGW2", "name": "aberrating aberrations on video", "author": "morisil", "description": "Testing something out", "tags": ["chromaticaberration", "study", "depthoffield", "focus"], "likes": 6, "viewed": 297, "published": 3, "date": "1636780863", "time_retrieved": "2024-07-30T18:48:32.604145", "image_code": "// Fork of \"depth of field focus study 2\" by morisil. https://shadertoy.com/view/flc3zX\n// 2021-11-13 05:16:16\n\n// Fork of \"depth of field focus study\" by morisil. https://shadertoy.com/view/sld3zB\n// 2021-11-08 19:52:49\n\nconst float SHAPE_SIZE = .7;\nconst float CHROMATIC_ABBERATION = .02;\nconst float ITERATIONS = 5.;\nconst float INITIAL_LUMA = .6;\n\nfloat getColorComponent(in vec2 st, in float modScale, in float blur) {\n    vec2 modSt = mod(st, 1. / modScale) * modScale * 2. - 1.;\n    float dist = length(modSt);\n    float angle = atan(modSt.x, modSt.y);\n    float shapeMap = smoothstep(SHAPE_SIZE + blur, SHAPE_SIZE - blur, dist);\n    return shapeMap;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st =\n        (2.* fragCoord - iResolution.xy)\n        / min(iResolution.x, iResolution.y);\n\n    float modScale = 2.;\n\n    vec3 color = vec3(0);\n    float luma = INITIAL_LUMA;\n    float blur = .2;\n    for (float i = 0.; i < ITERATIONS; i++) {\n        vec2 center = st + vec2(sin(iTime * .4), cos(iTime * .45)) * .3;\n        //center += pow(length(center), 1.);\n        vec2 modSt = mod(st, 1. / modScale) * modScale * 2. - 1.;\n        vec3 shapeColor = vec3(\n            getColorComponent(center - st * CHROMATIC_ABBERATION, modScale, blur),\n            getColorComponent(center, modScale, blur),\n            getColorComponent(center + st * CHROMATIC_ABBERATION, modScale, blur)        \n        ) * luma * texture(iChannel0, (center + 1.) * .5).rgb;\n        st *= 1.3;\n        color += shapeColor;\n        color = clamp(color, 0., 1.);\n        if (color == vec3(1)) break;\n        luma *= .63;\n        blur *= .63;\n    }\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tdGW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[352, 352, 423, 423, 659], [661, 661, 716, 716, 1723]], "test": "untested"}
{"id": "7td3Dj", "name": "Persian mosaic", "author": "jarble", "description": "A fractal pattern that looks like a mosaic.", "tags": ["fractal", "glass", "mosaic", "ceramic"], "likes": 2, "viewed": 243, "published": 3, "date": "1636776106", "time_retrieved": "2024-07-30T18:48:33.456865", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);    \n    vec3 col;  \n    float t1 = 4.5/4.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime/2.+uv.x)/10.0);\n    vec3 random1 = (hash31(3.+t2)-.5)/8.;\n    vec3 random2 = (hash31(4.+t2)-.5)/8.;\n    //vec3 random3 = (hash31(3.+t2)-vec3(.5))/4.;\n    //vec3 random4 = (hash31(4.+t2)-vec3(.5))/4.;\n    \n    float offset = .5;\n    float scale2 = 1.5;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        //float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            float bend = 1.;\n            for(int k = 0; k < 3; k++){       \n                uv /= -scale2;\n                //uv += vec2(random1[k],random2[k]).yx;\n                //float bend = 1.+1./3.;\n                //float bend = 1.;\n                \n                uv.yx = triangle_wave(uv.yx-offset,scale)*bend+triangle_wave(uv,scale)/bend;\n                \n                //vec2 scale3 = 1.+uv*((uv*(2.))+uv.y/2.);\n                //uv += abs(fract(uv/scale3)-1.5*scale3)/(16.); //makes an even more interesting quilt pattern\n\n                \n                //uv.yx = triangle_wave(uv.yx+offset,scale)*bend-triangle_wave(uv+offset/1.5,scale)/bend;\n\n                \n                //bend = (((uv.x-uv.y)))/2.+1.5;\n                //bend *= -1.;\n                //bend -= 1./3.-col.x;\n                //bend = 1. + uv.x;\n                //uv += vec2(random1[k]/bend,random2[k]*bend);\n                \n            }\n            //uv -= uv.yx;\n            \n\n            //offset += .5;\n            scale /= 1.+(scale2)*col.x/(8.);\n            scale2 -= (col.x-1.)/4.;\n\n\n            col[c] = (abs((uv.x)-(uv.y)+col[c]));\n            //col = col.yzx;\n            //random2 = col - random2;\n            \n\n        }\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7td3Dj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [590, 590, 629, 629, 674], [676, 676, 733, 733, 2708]], "test": "untested"}
{"id": "slt3Dj", "name": "Fork bending sp hypnothala 005", "author": "hypnothalamus", "description": "bending space proof of concept\n", "tags": ["warp", "transform", "bend"], "likes": 7, "viewed": 296, "published": 3, "date": "1636771056", "time_retrieved": "2024-07-30T18:48:34.317564", "image_code": "vec2 bend( vec2 uv, float angle )\n{\n    const float BLOCK_HEIGHT = 1.;\n    const float BLOCK_WIDTH = .25;\n\n    float bendSign = angle < 0. ? -1. : 1.;\n    float bendRadius = BLOCK_HEIGHT / abs( angle );\n    \n    vec2 p = uv * vec2( bendSign, 1. ) + vec2( bendRadius, 0. );\n    \n    return vec2( ( length( p ) - bendRadius ) / BLOCK_WIDTH * bendSign + .5, atan( p.y, p.x ) / abs( angle ) + .5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    //uv.y += .5;\n      \n    float bendAngle = sin( iTime * 3. + .0001 ) * 6.28;        \n    \n    vec2 textureUV = bend( uv, bendAngle );\n    float textureUVIsValid = textureUV.x >= 0. && textureUV.x < 1. && textureUV.y >= 0. && textureUV.y < 1. ? 1. : 0.;\n                      \n    vec3 col = vec3( sin(textureUV*3.14*10.), .5 ) * textureUVIsValid;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slt3Dj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 395], [397, 397, 454, 454, 922]], "test": "untested"}
{"id": "7tt3Dj", "name": "Shifty States", "author": "SnoopethDuckDuck", "description": "e", "tags": ["e"], "likes": 2, "viewed": 192, "published": 3, "date": "1636769932", "time_retrieved": "2024-07-30T18:48:35.221148", "image_code": "float thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    uv.x /= cosh(1.5 * uv.x);\n    \n    float a = atan(uv.y, uv.x);\n    float r = uv.x * thc(4., 1. * length(uv) + 0.5 * iTime) + uv.y * ths(4.,0.5 * iTime);\n\n    float time = 40. * r + 1. * a + 2. * iTime;\n    float str = 4.;// * cos(uv.x * 20.);\n    float v = 100.;\n\n    float sc = 0.75 + 0.25 * thc(4., .25 * iTime);\n    vec2 p = 0.3 * vec2(thc(cos(v * uv.x + time) * str, sc * v * uv.x + time), \n                        ths(sin(v * uv.y + time) * str, sc * v * uv.y + time));\n                        \n    float d = length(uv-p);\n    float s = smoothstep(-0.01,0.01,0.1 - d);\n    vec3 col = vec3(s);\n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tt3Dj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 70], [72, 72, 101, 101, 142], [144, 144, 201, 201, 904]], "test": "untested"}
{"id": "stt3Dj", "name": "Persian carpet 22", "author": "jarble", "description": "What kind of sorcery is this?\nThese patterns are generated by a simple fractal formula.", "tags": ["fractal", "carpet", "rug"], "likes": 1, "viewed": 250, "published": 3, "date": "1636769414", "time_retrieved": "2024-07-30T18:48:36.358108", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime/4.+uv.x)/10.0);\n    vec3 random1 = (hash31(3.+t2)-.5)/8.;\n    vec3 random2 = (hash31(4.+t2)-.5)/8.;\n    vec3 random3 = (hash31(3.+t2)-vec3(.5))/4.;\n    vec3 random4 = (hash31(4.+t2)-vec3(.5))/4.;\n    \n    float offset = .5;\n    float scale2 = 1.5;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        //float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            for(int k = 0; k < 6; k++){       \n                uv /= scale2;\n                //float bend = abs(fract((uv.x/3.))-.5)/3.+1.;\n                //float bend = 1.+random3[k%3];\n                //float bend = 1.+1./3.;\n                float bend = 1.;\n                uv.yx = -triangle_wave(uv.yx-offset,scale)/bend+triangle_wave(uv,scale)*bend;\n                uv += vec2(random1[k%3],random2[k%3]);                \n            }\n            \n\n            //offset += .5;\n            scale /= 1.+(scale2)*col.x/(8.);\n            scale2 -= (col.x-1.)/4.;\n\n\n            col[c] = abs(col[c] - abs((uv.x)-(uv.y)));\n            col = col.yzx;\n            //random2 = col - random2;\n            \n\n        }\n\t}\n    \n    fragColor = vec4(vec3(col*2.),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stt3Dj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [590, 590, 629, 629, 674], [676, 676, 733, 733, 2206]], "test": "untested"}
{"id": "sltGDj", "name": "democapsid", "author": "remaindeer", "description": "Demosplash 2021\n5th place for the combined demo/intro category (https://www.pouet.net/prod.php?which=90296)\nBased on: https://www.nature.com/articles/s41467-019-12367-3\n", "tags": ["3d", "hexagon", "tetrahedron", "scroll", "icosahedron", "octahedron", "polyhedra", "virus", "demosplash", "2021", "capsid", "casparklug"], "likes": 8, "viewed": 399, "published": 3, "date": "1636766055", "time_retrieved": "2024-07-30T18:48:37.640679", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // set resolution\n    vec2 uv = fragCoord / iResolution.y;\n\n    // scene parameters\n    Scene scene = frame_to_scene(iFrame);\n\n    // lattice parameters\n    int m = scene.m;\n    float h = float(scene.h);\n    float k = float(scene.k);\n    Params p = mode_to_params(m, h, k);\n\n    /****/ if (iFrame < checkpoints[0]) {\n        vec2 uv = fragCoord / iResolution.y;\n        float R = 1.0 / 18.0;\n        float r = R * cos30;\n        float B = R * 0.125;\n        float off = floor(iTime / 0.1) * 2.0 * r;\n        vec3 col = (\n            in_reg(uv, uv_to_hex_R(uv, R), 6.0, R - B, radians(30.0)) ?\n            vec3(0.25) :\n            cos(iTime + uv.xyx) * vec3(0, 1, 1)\n        );\n        uv.x += off;\n        float dx = 2.0 * r;\n        float dy = 1.5 * R;\n        vec2 hex = uv_to_hex_R(uv, R);\n        float ir = round(hex.y / dy);\n        float ic = round((hex.x - ir * r) / dx / 5.0);\n        float code = message[int(mod(ic, float(message.length())))];\n        col = hex_display(uv, vec2(5.0 * ic * dx + 2.0 * dx, 0.5), code, R, B, col, false);\n        fragColor = vec4(col, 1);\n    } else if (iFrame < checkpoints[1]) {\n        fragColor = T(iChannel0, fragCoord / iResolution.xy);\n    } else if (iFrame < checkpoints[6]) {\n        // center\n        uv -= vec2(iResolution.x / iResolution.y / 2.0, 0.5);\n\n        // calculate vertex coordinates\n        vec2 t1 = mat2(p.hvec, p.kvec) * vec2(h, k);\n        vec2 t2 = rotmat2(rad60) * t1;\n        t1.x /= iResolution.x / iResolution.y;\n        t2.x /= iResolution.x / iResolution.y;\n        // triangular face\n        mat3 X = mat3(\n            0, 0, 1,\n            t1.x, t1.y, 1,\n            t2.x, t2.y, 1\n        );\n\n        // https://en.wikipedia.org/wiki/Camera_matrix\n        // https://www.cs.cmu.edu/~16385/s17/Slides/11.1_Camera_matrix.pdf\n        mat3 K = mat3(scene.z);                     // calibration\n        vec3 C = vec3(0);                           // translation\n        mat3 Q = rotmat3(                           // rotation\n            vec3(\n                radians(mod(iTime * float(scene.r), 360.0) * 10.0),\n                radians(mod(iTime * float(scene.r), 360.0) * 15.0),\n                radians(mod(iTime * float(scene.r), 360.0) * 20.0)\n            )\n        );\n        mat4x3 IC = mat4x3(mat3(1));\n        IC[3] = -C;\n        mat4x3 P = (K * Q) * IC;                    // projection\n\n        vec3 col = vec3(0);\n\n        int n = 0;       // n-th color\n        vec3[20] c;      // color value\n        float[20] z;     // color depth\n        int nf = 20;     // number of faces\n        switch (scene.p) {\n            case TET:\n                nf = 4;\n                break;\n            case OCT:\n                nf = 8;\n                break;\n            case ICO:\n                nf = 20;\n                break;\n        }\n        for (int i = 0; i < nf; i++)\n        {\n            // map face\n            vec3 q1, q2, q3;\n            switch (scene.p) {\n                case TET:\n                    q1 = P * TET_V[int(TET_F[i].x)]; q2 = P * TET_V[int(TET_F[i].y)]; q3 = P * TET_V[int(TET_F[i].z)];\n                    break;\n                case OCT:\n                    q1 = P * OCT_V[int(OCT_F[i].x)]; q2 = P * OCT_V[int(OCT_F[i].y)]; q3 = P * OCT_V[int(OCT_F[i].z)];\n                    break;\n                case ICO:\n                    q1 = P * ICO_V[int(ICO_F[i].x)]; q2 = P * ICO_V[int(ICO_F[i].y)]; q3 = P * ICO_V[int(ICO_F[i].z)];\n                    break;\n            }\n            if (in_tri(uv, q1.xy, q2.xy, q3.xy))\n            {\n                mat3 A = mat3(\n                    q1.x, q1.y, 1,\n                    q2.x, q2.y, 1,\n                    q3.x, q3.y, 1\n                );\n                // face centroid depth\n                z[n] = ((q1 + q2 + q3) / 3.0).z;\n                // https://stackoverflow.com/a/55550712\n                // map lattice texture to face\n                vec3 iv = X * inverse(A) * vec3(uv.x, uv.y, 1);\n                iv.x -= t2.x < 0.0 ? t2.x : 0.0;\n                c[n] = mix(texture(iChannel0, iv.xy).xyz, vec3(0), -z[n]);\n                n += 1;\n            }\n        }\n\n        // painter's algorithm\n        int i = 1;\n        while (i < n) {\n            float x = z[i];\n            vec3 X = c[i];\n            int j = i - 1;\n            while (j >= 0 && z[j] > x) {\n                z[j+1] = z[j];\n                c[j+1] = c[j];\n                j = j - 1;\n            }\n            z[j+1] = x;\n            c[j+1] = X;\n            i = i + 1;\n        }\n        for (int i = 0; i < n; i++) col = mix(col, c[i], scene.a);\n\n        fragColor = vec4(col, 1);\n    } else { \n        vec2 uv = fragCoord / iResolution.y;\n        float R = 1.0 / 32.0;\n        float r = R * cos30;\n        float B = R * WIDTH;\n        vec2 hex = uv_to_hex_R(uv, R);\n\n        vec3 col = (\n            in_reg(uv, hex, 6.0, R - B, rad30) ?\n            vec3(0) :\n            0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0, 2, 4))\n        );\n\n        int ir = int(round(hex.y / (1.5 * R)));\n        int ic = int(round((hex.x - mod(float(ir), 2.0) * r) / (2.0 * r)));\n        if (ir < img_m && ic < img_n)\n            if (img2[15 * ir + ic] == 1)\n                if (in_reg(uv, hex, 6.0, R - B, rad30))\n                    col = COLOR_ON;\n\n        fragColor = vec4(col, 1.0);\n    }\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// math\n#define phi (1.0 + sqrt(5.0)) / 2.0\n#define rad30 radians(30.0)\n#define rad60 radians(60.0)\n#define rad90 radians(90.0)\n#define cos30 cos(rad30)\n#define sqrt3 sqrt(3.0)\n\n// alias\n#define T texture\n\n// lattice pattern\n#define MODE_HEX              0\n#define MODE_TRIHEX           1\n#define MODE_SNUBHEX          2\n#define MODE_RHOMBITRIHEX     3\n#define MODE_DUALHEX          4\n#define MODE_DUALTRIHEX       5\n#define MODE_DUALSNUBHEX      6\n#define MODE_DUALRHOMBITRIHEX 7\n\n// border width factor\n#define WIDTH 0.05\n\n// colors\n#define COLOR_BACKGROUND vec3( 31, 120, 180) / 255.0\n#define COLOR_FACE       vec3(178, 223, 138) / 255.0\n#define COLOR_VERTEX     vec3( 51, 160,  44) / 255.0\n#define COLOR_TRIANGLE   vec3(166, 206, 227) / 255.0\n#define COLOR_LINE       vec3(166, 206, 227) / 255.0\n#define COLOR_ON         vec3(117, 107, 177) / 255.0\n\n// Caspar-Klug parameters\n// #define h 16.0\n// #define k 16.0\n// #define m MODE_HEX\n\n// polyhedra\n//// constants\n#define TET 0\n#define OCT 1\n#define ICO 2\n//// tetrahedron\n////// radius\n#define TET_R 0.25\n////// vertexes\n#define TET_V vec4[] (               \\\n    vec4(+TET_R, +TET_R, +TET_R, 1), \\\n    vec4(-TET_R, +TET_R, -TET_R, 1), \\\n    vec4(+TET_R, -TET_R, -TET_R, 1), \\\n    vec4(-TET_R, +TET_R, -TET_R, 1), \\\n    vec4(-TET_R, -TET_R, +TET_R, 1), \\\n    vec4(+TET_R, -TET_R, -TET_R, 1)  \\\n)                                    \\\n////// faces\n#define TET_F vec3[] ( \\\n    vec3(0, 1, 2),     \\\n    vec3(1, 4, 2),     \\\n    vec3(0, 2, 4),     \\\n    vec3(0, 4, 1)      \\\n)                      \\\n//// octahedron\n////// radius\n#define OCT_RADIUS 0.85\n#define OCT_A      1.0 / (2.0 * sqrt(2.0)) * OCT_RADIUS\n#define OCT_B      0.5 * OCT_RADIUS\n////// vertexes\n#define OCT_V vec4[] (          \\\n    vec4(-OCT_A, 0, +OCT_A, 1), \\\n    vec4(-OCT_A, 0, -OCT_A, 1), \\\n    vec4(0, +OCT_B, 0, 1),      \\\n    vec4(+OCT_A, 0, -OCT_A, 1), \\\n    vec4(+OCT_A, 0, +OCT_A, 1), \\\n    vec4(0, -OCT_B, 0, 1)       \\\n)                               \\\n////// faces\n#define OCT_F vec3[] ( \\\n    vec3(0, 1, 2),     \\\n    vec3(1, 3, 2),     \\\n    vec3(3, 4, 2),     \\\n    vec3(4, 0, 2),     \\\n    vec3(3, 1, 5),     \\\n    vec3(1, 0, 5),     \\\n    vec3(4, 3, 5),     \\\n    vec3(0, 4, 5)      \\\n)                      \\\n//// icosahedron\n////// radius\n#define ICO_RADIUS 0.85\n#define ICO_A      0.5 * ICO_RADIUS\n#define ICO_B      1.0 / (2.0 * phi) * ICO_RADIUS\n////// vertexes\n#define ICO_V vec4[] (      \\\nvec4(0, +ICO_B, -ICO_A, 1), \\\nvec4(+ICO_B, +ICO_A, 0, 1), \\\nvec4(-ICO_B, +ICO_A, 0, 1), \\\nvec4(0, +ICO_B, +ICO_A, 1), \\\nvec4(0, -ICO_B, +ICO_A, 1), \\\nvec4(-ICO_A, 0, +ICO_B, 1), \\\nvec4(0, -ICO_B, -ICO_A, 1), \\\nvec4(+ICO_A, 0, -ICO_B, 1), \\\nvec4(+ICO_A, 0, +ICO_B, 1), \\\nvec4(-ICO_A, 0, -ICO_B, 1), \\\nvec4(+ICO_B, -ICO_A, 0, 1), \\\nvec4(-ICO_B, -ICO_A, 0, 1)  \\\n)                           \\\n////// faces\n#define ICO_F vec3[] (  \\\n    vec3( 0,  1,  2),   \\\n    vec3( 3,  2,  1),   \\\n    vec3( 3,  4,  5),   \\\n    vec3( 3,  8,  4),   \\\n    vec3( 0,  6,  7),   \\\n    vec3( 0,  9,  6),   \\\n    vec3( 4, 10, 11),   \\\n    vec3( 6, 11, 10),   \\\n    vec3( 2,  5,  9),   \\\n    vec3(11,  9,  5),   \\\n    vec3( 1,  7,  8),   \\\n    vec3(10,  8,  7),   \\\n    vec3( 3,  5,  2),   \\\n    vec3( 3,  1,  8),   \\\n    vec3( 0,  2,  9),   \\\n    vec3( 0,  7,  1),   \\\n    vec3( 6,  9, 11),   \\\n    vec3( 6, 10,  7),   \\\n    vec3( 4, 11,  5),   \\\n    vec3( 4,  8, 10)    \\\n)                       \\\n\n// image\n#define img_m 22\n#define img_n 15\n#define img1 int[] (                              \\\n    0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, \\\n    0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, \\\n    0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, \\\n    0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, \\\n    0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, \\\n    0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, \\\n    0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, \\\n    0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, \\\n    0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, \\\n    0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, \\\n    0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, \\\n    1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, \\\n    0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, \\\n    0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, \\\n    0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, \\\n    0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n    0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, \\\n    1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, \\\n    0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, \\\n    0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, \\\n    0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, \\\n    0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0  \\\n)                                                \\\n\n#define img2 int[] (                             \\\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n    1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, \\\n    0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, \\\n    0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, \\\n    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, \\\n    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n    0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, \\\n    0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, \\\n    0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, \\\n    0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, \\\n    0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, \\\n    1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, \\\n    0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, \\\n    0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, \\\n    0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, \\\n    0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n    0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, \\\n    1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, \\\n    0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, \\\n    0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, \\\n    0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, \\\n    0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0  \\\n)                                                \\\n\n// message\n#define hex_codes float[] (                                                                   \\\n    16127.0, 12735.0,  9087.0, 10681.0, 16313.0, 11263.0, 19199.0, 14719.0, 16063.0, 14527.0, \\\n    12289.0, 16145.0, 14015.0,  8511.0, 15549.0, 14521.0, 14777.0,  3839.0, 16071.0, 18617.0, \\\n    13287.0, 10687.0, 14649.0, 16191.0, 14617.0, 23709.0, 14007.0, 16263.0, 10227.0, 16255.0, \\\n    15873.0, 12283.0, 16363.0, 16015.0, 15343.0, 15359.0, 15939.0, 16383.0, 16079.0,  8481.0, \\\n    18569.0, 16425.0, 11777.0, 20219.0,  8193.0, 16391.0, 17927.0, 16767.0, 16193.0           \\\n)                                                                                             \\\n\n#define message float[] (                                                                              \\\n        0.0,     0.0,      0.0,    0.0,     0.0,                                                       \\\n    16313.0, 11263.0, 15549.0, 14777.0, 13287.0,  3839.0,  8511.0, 16127.0, 13287.0, 16063.0,     0.0, \\\n    12283.0, 16255.0, 12283.0, 15873.0,     0.0,                                                       \\\n    14336.0, 13287.0,      0.0,                                                                        \\\n    14777.0, 14521.0,  8511.0, 14336.0, 14521.0, 11263.0,                                              \\\n    8192.0,  8192.0,  8192.0                                                                           \\\n)\n\n#define greets float[] (                                         \\\n    11263.0, 8511.0, 0.0,                                        \\\n    12735.0, 8511.0, 16127.0, 14521.0, 9087.0, 14777.0,          \\\n    0.0, 0.0, 0.0, 0.0,                                          \\\n    19199.0, 16191.0, 8511.0, 9087.0, 18617.0, 16191.0, 15549.0, \\\n    0.0, 0.0, 0.0, 0.0                                           \\\n)     \n\n#define credits float[] (                                                            \\\n    0.0, 0.0, 0.0, 0.0,                                                              \\\n    18617.0, 11263.0, 15549.0, 16127.0, 12289.0, 14521.0, 11263.0, 11263.0, 18617.0, \\\n    0.0, 0.0, 0.0, 0.0                                                               \\\n)                                                                                    \\\n\n// scene frame thresholds\n#define checkpoints int[] (                                                    \\\n    60 * (11),                             /* 0 - intro */                     \\\n    60 * (11 + 18),                        /* 1 - plane lattice cycle */       \\\n    60 * (11 + 18 + 12),                   /* 2 - icosahedral lattice cycle */ \\\n    60 * (11 + 18 + 12 + 12),              /* 3 - deer */                      \\\n    60 * (11 + 18 + 12 + 12 + 6),          /* 4 - random initialization */     \\\n    60 * (11 + 18 + 12 + 12 + 6 + 12),     /* 5 - cellular automata */         \\\n    60 * (11 + 18 + 12 + 12 + 6 + 12 + 12) /* 6 - greets */                    \\\n                                           /* 7 - credits */                   \\\n)                                                                              \\\n\nstruct Scene {\n    int    m; // lattice mode\n    int    h; // Caspar-Klug h parameter\n    int    k; // Caspar-Klug k parameter\n    int    p; // polyhedron\n    float  a; // alpha\n    float  z; // zoom\n    bool   g; // face glow\n    bool   r; // rotate\n};\n\nScene frame_to_scene(int frame) {\n    int s = frame, m = MODE_HEX, h = 0, k = 0, p = ICO;\n    float a = 1.0, z = 1.0;\n    bool g = true;\n    bool r = true;\n    /****/ if (frame < checkpoints[0]) {\n    h=18;\n    } else if (frame < checkpoints[1]) {\n        s -= checkpoints[1];\n        m = int(mod(round(float(s) / 120.0), 8.0));\n        h = int(1.0 + round(30.0 / 2.0 * sin(float(s) / 30.0)) + floor(30.0 / 2.0));\n    } else if (frame < checkpoints[2]) {\n        s -= checkpoints[2];\n        m = int(mod(round(float(s) / 120.0), 8.0));\n        h = int(1.0 + round(8.0 / 2.0 * sin(float(s) / 8.0)) + floor(8.0 / 2.0));\n        k = int(round(8.0 / 2.0 * sin(float(s) / 10.0)) + floor(8.0 / 2.0));\n        a = 0.5 + sin(float(s) / 30.0) * 0.25;\n        z = (3.0 + sin(float(s) / 60.0)) * 0.5;\n    } else if (frame < checkpoints[3]) {\n        s -= checkpoints[3];\n        h = 16;\n        k = 16;\n        p = int(mod(round(float(s) / 240.0), 3.0));\n        a = 0.5 + sin(float(s) / 30.0) * 0.25;\n        z = (3.0 + sin(float(s) / 60.0)) * 0.5;\n    } else if (frame < checkpoints[4]) {\n        s -= checkpoints[4];\n        h = 20;\n        k = 20;\n        p = int(mod(round(float(s) / 240.0), 3.0));\n        a = 0.5 + sin(float(s) / 30.0) * 0.25;\n        z = (3.0 + sin(float(s) / 60.0)) * 0.5;\n    } else if (frame < checkpoints[5]) {\n        s -= checkpoints[5];\n        h = 20;\n        k = 20;\n        p = int(mod(round(float(s) / 240.0), 3.0));\n        z = (3.0 + sin(float(s) / 60.0)) * 0.5;\n        g = false;\n    } else if (frame < checkpoints[6]) {\n        s -= checkpoints[6];\n        h = 18;\n        a = 0.65;\n        r = false;\n    } \n    return Scene(m, h, k, p, a, z, g, r);\n}\n\n// lattice parameters\nstruct Params {\n    float R;     // circumradius\n    float r;     // inradius\n    float theta; // rotation\n    vec2 hvec;   // basis vector\n    vec2 kvec;   // basis vector\n};\n\nParams mode_to_params(int mode, float h, float k) {\n    float R, r, theta;\n    vec2 hvec, kvec;\n    switch (mode) {\n        case MODE_DUALHEX:\n        case MODE_DUALRHOMBITRIHEX:\n        case MODE_HEX:\n        {\n            R = 1.0 / ((h + k) * 1.5);\n            r = cos30 * R;\n            theta = 30.0;\n            hvec = vec2(2.0 * r, 0.0);\n            kvec = vec2(r, 1.5 * R);\n            break;\n        }\n        case MODE_DUALTRIHEX:\n        case MODE_TRIHEX:\n        {\n            R = 1.0 / ((h + k) * 2.0 * cos30);\n            r = cos30 * R;\n            theta = 0.0;\n            hvec = vec2(2.0 * R, 0.0);\n            kvec = vec2(R, 2.0 * r);\n            break;\n        }\n        case MODE_DUALSNUBHEX:\n        case MODE_SNUBHEX:\n        {\n            R = 1.0 / (h < k / 2.0 ? k * 3.0 * cos30 + h * cos30 : h * 3.0 * cos30 + 2.0 * k * cos30);\n            r = cos30 * R;\n            theta = 0.0;\n            hvec = vec2(2.5 * R, r);\n            kvec = vec2(0.5 * R, 3.0 * r);\n            break;\n        }\n        case MODE_RHOMBITRIHEX:\n        {\n            R = 1.0 / ((h + k) * (1.5 + sqrt3 / 2.0));\n            r = cos30 * R;\n            theta = 30.0;\n            hvec = vec2(R + 2.0 * r, 0.0);\n            kvec = vec2(r + 0.5 * R, (1.5 + sqrt3 / 2.0) * R);\n            break;\n        }\n    }\n    return Params(R, r, radians(theta), hvec, kvec);\n}\n\nfloat cross2(vec2 p, vec2 q) {\n    return p.x * q.y - p.y * q.x;\n}\n\nmat2 rotmat2(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\nmat3 rotmat3(vec3 angle) {\n    float sintht = sin(angle.x), sinpsi = sin(angle.y), sinphi = sin(angle.z);\n    float costht = cos(angle.x), cospsi = cos(angle.y), cosphi = cos(angle.z);\n    return mat3(\n        costht * cospsi,\n        sintht * cospsi,\n        -sinpsi,\n        costht * sinpsi * sinphi - sintht * cosphi,\n        sintht * sinpsi * sinphi + costht * cosphi,\n        cospsi * sinphi,\n        costht * sinpsi * cosphi + sintht * sinphi,\n        sintht * sinpsi * cosphi - costht * sinphi,\n        cospsi * cosphi\n    );\n}\n\nbool in_tri(vec2 uv, vec2 v1, vec2 v2, vec2 v3) {\n    // https://mathworld.wolfram.com/TriangleInterior.html\n    // http://www.sunshine2k.de/coding/java/pointInTriangle/pointInTriangle.html\n    vec2 w1 = v2 - v1;\n    vec2 w2 = v3 - v1;\n    float d = determinant(mat2(w1, w2));\n    // check for d ≈ 0.0 ?\n    float s = determinant(mat2(uv - v1, w2)) / d;\n    float t = determinant(mat2(w1, uv - v2)) / d;\n    return s >= 0.0 && t >= 0.0 && (s + t) <= 1.0;\n}\n\nbool in_reg(vec2 uv, vec2 c, float n, float R, float theta) {\n    // break-up regular polygon into triangles\n    float dt = radians(360.0 / n);\n    for (float i = 0.0, j = 1.0; i < n; i++, j++)\n    {\n        vec2 a = R * vec2(cos(dt * i + theta), sin(dt * i + theta)) + c;\n        vec2 b = R * vec2(cos(dt * j + theta), sin(dt * j + theta)) + c;\n        if (in_tri(uv, a, b, c))\n            return true;\n    }\n    return false;\n}\n\nbool in_floret(vec2 uv, vec2 c, float R) {\n    // progressively break-up hexagon-inscribed floret into 3 triangles\n    float x = (3.0 * sqrt(3.0) * R) / 10.0;\n    float X = x / cos30;\n    float rtri = X * sqrt(3.0) / 6.0;\n    float Rtri = X * sqrt(3.0) / 3.0;\n    vec2 alpha = c + vec2(0, x + rtri);\n    vec2 beta = c + vec2(X / 2.0, x + Rtri);\n    vec2 gamma = c + vec2(X, x + rtri);\n    vec2 delta = c + vec2(X, Rtri);\n    for (float i = 0.0; i < 6.0; i++) {\n        vec2 a = (alpha - c) * rotmat2(radians(i * 60.0)) + c;\n        vec2 b = (beta  - c) * rotmat2(radians(i * 60.0)) + c;\n        vec2 g = (gamma - c) * rotmat2(radians(i * 60.0)) + c;\n        vec2 d = (delta - c) * rotmat2(radians(i * 60.0)) + c;\n        if (in_tri(uv, c, a, b) || in_tri(uv, c, b, g) || in_tri(uv, c, g, d))\n            return true;\n    }\n    return false;\n}\n\nvec2 uv_to_hex_p(vec2 uv, Params p) {\n    // get central hex coordinate\n    mat2 b = mat2(p.hvec, p.kvec);\n    vec2 hex = b * round(inverse(b) * uv);\n    bool inhex = in_reg(uv, hex, 6.0, p.R, p.theta);\n    // adjust hex coordinate due to overlap\n    if (!inhex)\n        if (cross2(vec2(p.r, 0.5 * p.R), hex - uv) < 0.)\n            hex += (uv.x > hex.x) ? p.kvec : -p.hvec;\n        else\n            hex += (uv.x > hex.x) ? p.hvec : -p.kvec;\n    return hex;\n}\n\nvec2 uv_to_hex_R(vec2 uv, float R) {\n    // get central hex coordinate\n    float r = R * cos30;\n    float theta = radians(30.0);\n    vec2 hvec = vec2(2.0 * r, 0.0);\n    vec2 kvec = vec2(r, 1.5 * R);\n    mat2 b = mat2(hvec, kvec);\n    vec2 hex = b * round(inverse(b) * uv);\n    bool inhex = in_reg(uv, hex, 6.0, R, radians(theta));\n    // adjust hex coordinate due to overlap\n    if (!inhex)\n        if (cross2(vec2(r, 0.5 * R), hex - uv) < 0.)\n            hex += (uv.x > hex.x) ? kvec : -hvec;\n        else\n            hex += (uv.x > hex.x) ? hvec : -kvec;\n    return hex;\n}\n\nfloat distline(vec2 uv, vec2 p, float theta) {\n    // https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\n    return abs(cos(theta) * (p.y - uv.y) - sin(theta) * (p.x - uv.x));\n}\n\nfloat random(vec2 seed) {\n    // https://thebookofshaders.com/10/\n    return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvec3 hex_display(vec2 uv, vec2 pos, float chr, float R, float B, vec3 col, bool yflip) {\n    // uv     the uv\n    // pos     the centreal display position\n    // chr     the character code to display\n    // R       the hexagon circumradius\n    // B       the border width\n    // yflip   the border width\n    // col the default color\n    //\n    //     0    5    8  -\n    //    1         9    |\n    //   2    6    A      > display bit mapping\n    //  3         B      |\n    // 4    7    C      -\n    //\n    // A a 16127          n 14521        0 16255  _ 08481\n    // b   12735          o 14777        1 15873  - 18569\n    // C c 09087 10681  P   03839        2 12283  : 16425\n    //   d 16313          q 16071        3 16363  ! 11777\n    // E   11263          r 18617        4 16015  ? 20219\n    // F   19199        S   13287        5 15343  . 08193\n    // G g 14719          t 10687        6 15359  ' 16391\n    // H h 16063 14527  U u 16191 14649  7 15939  \" 17927\n    //   i 12289        V   14617        8 16383  [ 16767\n    // J   16145          w 23709        9 16079  ] 16193\n    // K   14015        X   14007\n    // L   08511          y 16263\n    // M   15549        Z   10227\n\n    float r = R * cos30;\n    float theta = radians(30.0);\n    float n = chr;\n    // set display according to bit index\n    for (int i = 0; i < 13; i++) {\n        float q = floor(n / 2.0);\n        if (mod(q, 2.0) == 1.0) {\n            float ir = 0.0;\n            float ic = 0.0;\n            /**/ if (i == 0 || i == 5 || i == 8 ) ir  = +2.0;\n            else if (i == 1 || i == 9           ) ir  = +1.0;\n            else if (i == 3 || i == 11          ) ir  = -1.0;\n            else if (i == 4 || i == 7 || i == 12) ir  = -2.0;\n            /**/ if (i <= 4                     ) ic  = -1.0;\n            else if (i >= 8                     ) ic  = +1.0;\n            /**/ if (yflip                      ) ir *= -1.0;  \n            float dx = ic * 2.0 * r + ir * r;\n            float dy = ir * 1.5 * R;\n            if (in_reg(uv, pos + vec2(dx, dy), 6.0, R - B, theta)) {\n                col = vec3(0.75);\n                break;\n            }\n        }\n        n = q;\n    }\n    return col;\n}\n", "buffer_a_code": "vec2 y_to_xy(vec2 uv) {\n    return uv / (iResolution.xy / iResolution.y) * (iResolution.xy / iResolution.xy);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // set resolution\n    vec2 uv = fragCoord / iResolution.y;\n\n    // scene parameters\n    Scene scene = frame_to_scene(iFrame);\n\n    // lattice parameters\n    int m = scene.m;\n    float h = float(scene.h);\n    float k = float(scene.k);\n    Params p = mode_to_params(m, h, k);\n\n    if (iFrame < checkpoints[5]) {\n        // calculate vertex coordinates\n        vec2 t0 = vec2(0);\n        vec2 t1 = mat2(p.hvec, p.kvec) * vec2(h, k);\n        vec2 t2 = rotmat2(rad60) * t1;\n        uv.x += t2.x < 0.0 ? t2.x : 0.0;\n\n        if (iFrame < checkpoints[1])\n            uv.x -= (iResolution.x / iResolution.y - t1.x) / 2.0;\n\n        // set border\n        float dw = p.R * WIDTH;\n        if (m == MODE_HEX || m == MODE_DUALHEX || m == MODE_DUALRHOMBITRIHEX)\n            p.R -= dw;\n\n        // calculate hex coordinate\n        mat2 b = mat2(p.hvec, p.kvec);\n        vec2 hex = b * round(inverse(b) * uv);\n        bool in_hex = in_reg(uv, hex, 6.0, p.R, p.theta);\n        if (!in_hex)\n            if (cross2(vec2(p.r, 0.5 * p.R), hex - uv) < 0.)\n                hex += (uv.x > hex.x) ? p.kvec : -p.hvec;\n            else\n                hex += (uv.x > hex.x) ? p.hvec : -p.kvec;\n\n        // cellular automata\n        vec3 col_face = COLOR_FACE;\n        vec3 col_vertex = COLOR_VERTEX;\n        vec3 col_triangle = COLOR_TRIANGLE;\n        vec3 col_line = COLOR_LINE;\n        vec3 col_background = COLOR_BACKGROUND;\n\n        if (in_hex || in_reg(uv, hex, 6.0, p.R, p.theta)) {\n            /****/ if (iFrame < checkpoints[0]) {\n            } else if (iFrame < checkpoints[1]) {\n            } else if (iFrame < checkpoints[2]) {\n            } else if (iFrame < checkpoints[3]) {\n                vec2 uv = fragCoord / iResolution.y;\n                Params p = mode_to_params(m, h, k);\n                uv.y -= 6.0 * 1.5 * p.R;\n                float off = mod(floor(iTime / 0.1) * 2.0 * p.r, float(img_m + 5) * 2.0 * p.r);\n                uv.x -= off;\n                vec2 hex = uv_to_hex_p(uv, p);\n                int ir = int(round(hex.y / (1.5 * p.R)));\n                int ic = int(round((hex.x - mod(float(ir), 2.0) * p.r) / (2.0 * p.r)));\n                if (0 <= ic && ir < img_m && ic < img_n) {\n                    if (img1[15 * ir + ic] == 1) {\n                        if (in_reg(uv, hex, 6.0, p.R, rad30)) {\n                            col_face = cos(iTime + uv.xyx);\n                            col_face.x = 0.0;\n                        }\n                    }\n                }\n            } else if (iFrame < checkpoints[4]) {\n                // set random initial state\n                col_face = vec3(fract(random(iTime + hex * iTime)) <= 0.45 ? COLOR_ON : COLOR_FACE);\n            } else if (iFrame < checkpoints[5]) {\n                // get ON/OFF state of hexagonal neighborhood\n                int nw = int(T(iChannel0, y_to_xy(hex + vec2(-(1.0 * p.r), +(1.5 * p.R)))).rgb == COLOR_ON);\n                int ne = int(T(iChannel0, y_to_xy(hex + vec2(+(1.0 * p.r), +(1.5 * p.R)))).rgb == COLOR_ON);\n                int wc = int(T(iChannel0, y_to_xy(hex + vec2(-(2.0 * p.r), 0.0000000000))).rgb == COLOR_ON);\n                int cc = int(T(iChannel0, y_to_xy(hex + vec2(0.0000000000, 0.0000000000))).rgb == COLOR_ON);\n                int ec = int(T(iChannel0, y_to_xy(hex + vec2(+(2.0 * p.r), 0.0000000000))).rgb == COLOR_ON);\n                int sw = int(T(iChannel0, y_to_xy(hex + vec2(-(1.0 * p.r), -(1.5 * p.R)))).rgb == COLOR_ON);\n                int se = int(T(iChannel0, y_to_xy(hex + vec2(+(1.0 * p.r), -(1.5 * p.R)))).rgb == COLOR_ON);\n                int n = nw + ne + wc + ec + sw + se;\n                // update state of current central cell\n                if (cc == 1) col_face = vec3((n >= 4) ? COLOR_ON : col_face);\n                else /*****/ col_face = vec3((n <= 2) ? COLOR_ON : col_face);\n            }\n        }\n        if (col_face == COLOR_ON) {\n            col_vertex = COLOR_ON;\n            col_triangle = COLOR_ON;\n            col_line = COLOR_ON;\n            col_background = COLOR_ON;\n        }\n        vec3 col = col_background;\n\n        // base hex-pattern colors\n        if (in_hex || in_reg(uv, hex, 6.0, p.R, p.theta)) {\n            col = col_face;\n        }\n        if (\n            in_reg(uv, t0, 6.0, p.R, p.theta) ||\n            in_reg(uv, t1, 6.0, p.R, p.theta) ||\n            in_reg(uv, t2, 6.0, p.R, p.theta)\n        ) {\n            col = col_vertex;\n        }\n\n        // lattice colors\n        float R3 = p.R * sqrt3 / 3.0;\n        float r3 = p.R * sqrt3 / 6.0;\n        float a = R3 + r3;\n        switch (m) {\n            case MODE_SNUBHEX:\n            {\n                if (!in_hex) {\n                    vec2 uv = uv;\n                    uv.x += mod(floor(uv.y / a), 2.0) * 0.5 * p.R;\n                    vec2 c = vec2(p.R * round(uv.x / p.R), a * floor(uv.y / a));\n                    if (distline(uv, c, +rad60) < dw ||\n                        distline(uv, c, -rad60) < dw ||\n                        abs(uv.y - a * round(uv.y / a)) < dw\n                    ) col = col_line;\n                }\n                break;\n            }\n            case MODE_RHOMBITRIHEX:\n            {\n                float R = p.R;\n                float r = p.r;\n                float dx = R + r + r;\n                float dy = R + a + R + a + R;\n                vec2 c = vec2(dx * round(uv.x / dx), dy * round(uv.y / dy));\n                if (in_reg(uv, c + vec2(0, +(R + R3)), 3.0, R3, -rad90)                    ||\n                    in_reg(uv, c + vec2(0, -(R + R3)), 3.0, R3, +rad90)                    ||\n                    in_reg(uv, c + vec2(+(r + R / 2.0), +(R / 2.0 + r3)), 3.0, R3, +rad90) ||\n                    in_reg(uv, c + vec2(-(r + R / 2.0), +(R / 2.0 + r3)), 3.0, R3, +rad90) ||\n                    in_reg(uv, c + vec2(+(r + R / 2.0), -(R / 2.0 + r3)), 3.0, R3, -rad90) ||\n                    in_reg(uv, c + vec2(-(r + R / 2.0), -(R / 2.0 + r3)), 3.0, R3, -rad90)\n                ) col = col_triangle;\n                break;\n            }\n            case MODE_DUALTRIHEX:\n            {\n                if (in_reg(uv, hex, 3.0, p.R, p.theta)                  ||\n                    in_reg(uv, hex, 3.0, p.R, p.theta + radians(180.0))\n                )\n                    col = in_hex ? col : col_triangle;\n                else\n                    col = col_background;\n\n                // if (distline(uv, hex, +rad60) < dw ||\n                //     distline(uv, hex, -rad60) < dw ||\n                //     abs(uv.y - hex.y) < dw\n                //    )\n                //     col = col_line;\n\n                vec2 hex = b * round(inverse(b) * uv);\n                if (cross2(vec2(p.r, 0.5 * p.R), hex - uv) < 0.)\n                    hex += (uv.x > hex.x) ? p.kvec : -p.hvec;\n                else\n                    hex += (uv.x > hex.x) ? p.hvec : -p.kvec;\n                if ( in_reg(uv, hex, 6.0, p.R / cos30 + dw, rad30) &&\n                    !in_reg(uv, hex, 6.0, p.R / cos30 - dw, rad30)\n                )\n                    col = col_line;\n\n                break;\n            }\n            case MODE_DUALSNUBHEX:\n            {\n                if (in_floret(uv, t0, p.R + R3) ||\n                    in_floret(uv, t1, p.R + R3) ||\n                    in_floret(uv, t2, p.R + R3)\n                )\n                    col = col_vertex;\n                else {\n                    bool in_hex = false;\n                    mat2 b = mat2(p.hvec * 2.0, p.kvec * 2.0);\n                    {\n                        vec2 hex = b * round(inverse(b) * uv);\n                        in_hex = in_floret(uv, hex, p.R + R3);\n                    }\n                    if (!in_hex) {\n                        vec2 uv = uv - p.hvec;\n                        vec2 hex = b * round(inverse(b) * uv);\n                        in_hex = in_floret(uv, hex, p.R + R3);\n                    }\n                    if (!in_hex) {\n                        vec2 uv = uv + p.kvec;\n                        vec2 hex = b * round(inverse(b) * uv);\n                        in_hex = in_floret(uv, hex, p.R + R3);\n                    }\n                    if (!in_hex) {\n                        vec2 uv = uv + p.hvec + p.kvec;\n                        vec2 hex = b * round(inverse(b) * uv);\n                        in_hex = in_floret(uv, hex, p.R + R3);\n                    }\n                    if (in_hex) col = col_face;\n                }\n                break;\n            }\n            case MODE_DUALRHOMBITRIHEX:\n            {\n                if (distline(uv, hex, +rad60) <= dw ||\n                    distline(uv, hex, -rad60) <= dw ||\n                    abs(uv.y - hex.y) < dw\n                ) {\n                    col = col_background;\n                }\n                break;\n            }\n        }\n\n        if (scene.g) {\n            vec3 rnd = vec3(cos(iTime));\n            rnd.x = 0.0;\n            if (in_tri(uv, vec2(0), t1, t2)) col = mix(rnd, col, 0.85);\n        }\n\n        fragColor = vec4(col, 1.0);    \n    } else if (iFrame < checkpoints[6]) {\n        vec2 uv = fragCoord / iResolution.y;\n        float R = 1.0 / h;\n        float r = R * cos30;\n        float B = R * WIDTH;\n        float off = floor(iTime / 0.1) * 2.0 * r;\n        vec3 col = (\n            in_reg(uv, uv_to_hex_R(uv, R), 6.0, R - B, rad30) ?\n            vec3(0.25) :\n            cos(iTime + uv.xyx) * vec3(0, 1, 1)\n        );\n        uv.x += off;\n        float dx = 2.0 * r;\n        float dy = 1.5 * R;\n        vec2 hex = uv_to_hex_R(uv, R);\n        float ir = round(hex.y / dy);\n        float ic = round((hex.x - ir * r) / dx / 5.0);\n        float code = greets[int(mod(ic, float(greets.length())))];\n        col = hex_display(uv, vec2(5.0 * ic * dx + 2.0 * dx, 0.5), code, R, B, col, true);\n        fragColor = vec4(col, 1);\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sltGDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "stdGDj", "name": "Persian carpet 21", "author": "jarble", "description": "These carpets have many braided knot patterns.", "tags": ["fractal", "carpet", "rug"], "likes": 2, "viewed": 229, "published": 3, "date": "1636765931", "time_retrieved": "2024-07-30T18:48:38.652972", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5/4.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime/2.+uv.x)/10.0);\n    vec3 random1 = (hash31(3.+t2)-.5)/8.;\n    vec3 random2 = (hash31(4.+t2)-.5)/8.;\n    //vec3 random3 = (hash31(3.+t2)-vec3(.5))/4.;\n    //vec3 random4 = (hash31(4.+t2)-vec3(.5))/4.;\n    \n    float offset = .5;\n    float scale2 = 1.5;\n    float bend = 1.;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        \n        //float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            for(int k = 0; k < 3; k++){       \n                uv /= -scale2;\n                //float bend = abs(fract((uv.x)*4.)-.5)/4.+1.;\n                //float bend = 1.125;\n                \n                uv = triangle_wave(uv.yx-offset,scale)*bend+triangle_wave(uv,scale)/bend;\n                //uv.yx = triangle_wave(uv.yx+offset,scale)*bend-triangle_wave(uv+offset/1.5,scale)/bend;\n                //uv += fract(uv/2.)/4.;\n                uv += vec2(random1[k],random2[k]);\n                \n                //bend = 1.+uv.x/2.;\n                //bend *= -1.;\n                //bend -= 1./3.;\n            }\n            \n\n            //offset += .5;\n            scale /= 1.+(scale2)*col.x/(8.);\n            scale2 -= (col.x-1.)/4.;\n\n\n            col[c] = abs(col[c] - abs((uv.x)-(uv.y)));\n            \n\n            //random2 = col - random2;\n            \n\n        }\n\t}\n    \n    fragColor = vec4(vec3(col*2.),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdGDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [590, 590, 629, 629, 674], [676, 676, 733, 733, 2405]], "test": "untested"}
{"id": "sdjXRy", "name": "Distance to Cubic Bezier", "author": "oneshade", "description": "Numerically calculating the euclidean distance to a cubic bezier curve.", "tags": ["2d", "bezier", "distance", "cubic", "numerical"], "likes": 23, "viewed": 505, "published": 3, "date": "1636757868", "time_retrieved": "2024-07-30T18:48:39.489735", "image_code": "vec2 posBezier(in vec2 a, in vec2 b, in vec2 c, in vec2 d, in float t) {\n    float tInv = 1.0 - t;\n    return a * tInv * tInv * tInv + b * 3.0 * t * tInv * tInv + c * 3.0 * tInv * t * t + d * t * t * t;\n}\n\n// https://www.shadertoy.com/view/st33Wj\nvec2 cmul(in vec2 z, in vec2 w) { return mat2(z, -z.y, z.x) * w; }\nvec2 cdiv(in vec2 z, in vec2 w) { return cmul(z, vec2(w.x, -w.y)) / dot(w, w); }\nint solveQuintic(in float a, in float b, in float c,\n    in float d, in float e, in float f, out float[5] realRoots) {\n    float p = (5.0 * a * c - 2.0 * b * b) / (5.0 * a * a);\n    float q = (25.0 * a * a * d - 15.0 * a * b * c + 4.0 * b * b * b) / (25.0 * a * a * a);\n    float r = (125.0 * a * a * a * e - 50.0 * a * a * b * d + 15.0 * a * b * b * c - 3.0 * b * b * b * b) / (125.0 * a * a * a * a);\n    float s = (3125.0 * a * a * a * a * f - 625.0 * a * a * a * b * e + 125.0 * a * a * b * b * d - 25.0 * a * b * b * b * c + 4.0 * b * b * b * b * b) / (3125.0 * a * a * a * a * a);\n\n    float bound = 1.0 + max(1.0, max(abs(p), max(abs(q), max(abs(r), abs(s)))));\n    //bound *= 0.414213562373; // Correction if perturbing with random([-1...1])\n    bound *= 0.5;\n\n    vec2[5] roots;\n    roots[0] = vec2(bound, 0.0);\n    roots[1] = vec2(0.309016994375, 0.951056516295) * bound;\n    roots[2] = vec2(-0.809016994375, 0.587785252292) * bound;\n    roots[3] = vec2(-0.809016994375, -0.587785252292) * bound;\n    roots[4] = vec2(0.309016994375, -0.951056516295) * bound;\n\n    for (int iter=0; iter < 25; iter++) {\n        float maxEval = -1e20;\n        for (int root=0; root < 5; root++) {\n            vec2 z = roots[root];\n            vec2 quinticVal = cmul(cmul(cmul(cmul(z, z) + vec2(p, 0.0), z) + vec2(q, 0.0), z) + vec2(r, 0.0), z) + vec2(s, 0.0);\n            maxEval = max(maxEval, max(abs(quinticVal.x), abs(quinticVal.y)));\n\n            vec2 denom = z - roots[(root + 1) % 5];\n            denom = cmul(denom, z - roots[(root + 2) % 5]);\n            denom = cmul(denom, z - roots[(root + 3) % 5]);\n            denom = cmul(denom, z - roots[(root + 4) % 5]);\n\n            roots[root] -= cdiv(quinticVal, denom);\n        }\n\n        if (maxEval < 1e-7) break;\n    }\n\n    int numRealRoots = 0;\n    float offs = b / (5.0 * a);\n    for (int root=0; root < 5; root++) {\n        vec2 z = roots[root];\n        if (abs(z.y) < 1e-7) {\n            realRoots[numRealRoots] = z.x - offs;\n            numRealRoots++;\n        }\n    }\n\n    return numRealRoots;\n}\n\nfloat dot2(in vec2 v) { return dot(v, v); }\nvec4 sdCubicBezier(in vec2 p, in vec2 v1, in vec2 v2, in vec2 v3, in vec2 v4) {\n    // Convert to power basis\n    vec2 a = v4 + 3.0 * (v2 - v3) - v1;\n    vec2 b = 3.0 * (v1 - 2.0 * v2 + v3);\n    vec2 c = 3.0 * (v2 - v1);\n    vec2 d = v1 - p;\n\n    // Quintic coefficients (derivative of distance-for-t with 2 factored out)\n    float qa = 3.0 * dot(a, a);\n    float qb = 5.0 * dot(a, b);\n    float qc = 4.0 * dot(a, c) + 2.0 * dot(b, b);\n    float qd = 3.0 * (dot(b, c) + dot(d, a));\n    float qe = dot(c, c) + 2.0 * dot(d, b);\n    float qf = dot(d, c);\n\n    float distSq = dot2(p - v1);\n    float tNear = 0.0;\n    vec2 pNear = v1;\n\n    float distSq2 = dot2(p - v4);\n    if (distSq2 < distSq) {\n        distSq = distSq2;\n        tNear = 1.0;\n        pNear = v4;\n    }\n\n    float[5] roots;\n    int numRoots = solveQuintic(qa, qb, qc, qd, qe, qf, roots);\n    for (int n=0; n < numRoots; n++) {\n        float t = roots[n];\n        if (0.0 < t && t < 1.0) {\n            vec2 pos = posBezier(v1, v2, v3, v4, t);\n            float distSq2 = dot2(p - pos);\n            if (distSq2 < distSq) {\n                distSq = distSq2;\n                pNear = pos;\n                tNear = t;\n            }\n        }\n    }\n\n    return vec4(pNear, tNear, sqrt(distSq));\n}\n\n/*\n// Plain and simple version (nearest point and parameter are not recorded)\nfloat dot2(in vec2 v) { return dot(v, v); }\nfloat sdCubicBezier(in vec2 p, in vec2 v1, in vec2 v2, in vec2 v3, in vec2 v4) {\n    // Convert to power basis\n    vec2 a = v4 + 3.0 * (v2 - v3) - v1;\n    vec2 b = 3.0 * (v1 - 2.0 * v2 + v3);\n    vec2 c = 3.0 * (v2 - v1);\n    vec2 d = v1 - p;\n\n    // Quintic coefficients (derivative of distance-for-t with 2 factored out)\n    float qa = 3.0 * dot(a, a);\n    float qb = 5.0 * dot(a, b);\n    float qc = 4.0 * dot(a, c) + 2.0 * dot(b, b);\n    float qd = 3.0 * (dot(b, c) + dot(d, a));\n    float qe = dot(c, c) + 2.0 * dot(d, b);\n    float qf = dot(d, c);\n\n    float[5] roots;\n    int numRoots = solveQuintic(qa, qb, qc, qd, qe, qf, roots);\n    float distSq = min(dot2(p - v1), dot2(p - v4));\n    for (int n=0; n < numRoots; n++) {\n        float t = roots[n];\n        if (0.0 < t && t < 1.0) {\n            distSq = min(distSq, dot2(p - posBezier(v1, v2, v3, v4, t)));\n        }\n    }\n\n    return sqrt(distSq);\n}\n*/\n\n// For visualizing the distance mnimizing quintic\nfloat sdMinimizerPoly(in vec2 pos, in vec2 p, in vec2 v1, in vec2 v2, in vec2 v3, in vec2 v4) {\n    // Convert to power basis\n    vec2 a = v4 + 3.0 * (v2 - v3) - v1;\n    vec2 b = 3.0 * (v1 - 2.0 * v2 + v3);\n    vec2 c = 3.0 * (v2 - v1);\n    vec2 d = v1 - p;\n\n    // Quintic coefficients (derivative of distance-for-t with 2 factored out)\n    float t5 = 3.0 * dot(a, a);\n    float t4 = 5.0 * dot(a, b);\n    float t3 = 4.0 * dot(a, c) + 2.0 * dot(b, b);\n    float t2 = 3.0 * (dot(b, c) + dot(d, a));\n    float t1 = dot(c, c) + 2.0 * dot(d, b);\n    float t0 = dot(d, c);\n\n    float y = ((((t5 * pos.x + t4) * pos.x + t3) * pos.x + t2) * pos.x + t1) * pos.x + t0;\n    float dx = (((5.0 * t5 * pos.x + 4.0 * t4) * pos.x + 3.0 * t3) * pos.x + 2.0 * t2) * pos.x + t1;\n\n    return abs(pos.y - y) / sqrt(1.0 + dx * dx);\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 3.0;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 3.0;\n    float unit = 6.0 / iResolution.y;\n    float time = iTime;//610.94;\n\n    float t1 = time * 0.5, t2 = time, t3 = time * 1.25;\n\n    float c1 = cos(t1), s1 = sin(t1);\n    float c2 = cos(t2), s2 = sin(t2);\n    float c3 = cos(t3), s3 = sin(t3);\n\n    /*\n    vec2 a = vec2(-1.0, -0.75);\n    vec2 b = vec2(s1, s2);\n    vec2 c = vec2(c3, c1);\n    vec2 d = vec2(1.0, -0.75);\n    */\n\n    vec2 a = vec2(c2 * 0.5, s3);\n    vec2 b = vec2(-2.0, 1.0);\n    vec2 c = vec2(2.0, 1.0);\n    vec2 d = vec2(s2 * 0.5, c3);\n\n    float sdf = sdCubicBezier(uv, a, b, c, d).w - 0.1;\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(sdf) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(sdf));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * sdf);\n\tcolor = mix(color, vec3(1.0), smoothstep(unit, 0.0, abs(sdf)));\n\n    // Hull\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, sdLine(uv, a, b) - 0.01));\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, sdLine(uv, b, c) - 0.01));\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, sdLine(uv, c, d) - 0.01));\n\n    // Control points\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - a) - 0.03));\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - b) - 0.03));\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - c) - 0.03));\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - d) - 0.03));\n\n    // Draw shortest segment between the mouse and curve\n    vec3 nearest = sdCubicBezier(mouse, a, b, c, d).xyz;\n    color = mix(color, vec3(0.0, 1.0, 0.0), smoothstep(unit, 0.0, sdLine(uv, mouse, nearest.xy) - 0.01));\n    color = mix(color, vec3(1.0, 0.8, 0.0), smoothstep(unit, 0.0, length(uv - mouse) - 0.05));\n    color = mix(color, vec3(1.0, 0.8, 0.0), smoothstep(unit, 0.0, length(uv - nearest.xy) - 0.05));\n\n    // Draw the distance minimizing quintic for the mouse position\n    //color = mix(color, vec3(0.0, 0.5, 1.0), smoothstep(unit, 0.0, sdMinimizerPoly(uv, mouse, a, b, c, d) - 0.001));\n    //color = color = mix(color, vec3(0.0), smoothstep(unit, 0.0, length(uv - vec2(nearest.z, 0.0)) - 0.03));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdjXRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 72, 72, 204], [206, 247, 280, 280, 313], [314, 314, 347, 347, 394], [2447, 2447, 2470, 2470, 2490], [4779, 4829, 4924, 4954, 5641], [5643, 5643, 5690, 5690, 5798], [5800, 5800, 5855, 5855, 8226]], "test": "untested"}
{"id": "st33Wj", "name": "Quintic Solving Study II - DK", "author": "oneshade", "description": "Solving for the roots of a quintic equation using Durand-Kerner method to find all roots simultaneously.", "tags": ["study", "quintic", "solving", "weierstrass", "durandkerner"], "likes": 18, "viewed": 213, "published": 3, "date": "1636757648", "time_retrieved": "2024-07-30T18:48:40.343453", "image_code": "#define CONSTRUCT_FROM_ROOTS\n\nvoid quinticFromRoots(in float x1, in float x2, in float x3, in float x4, in float x5,\n    out float a, out float b, out float c, out float d, out float e, out float f) {\n    a = 1.0;\n    b = -x1 - x2 - x3 - x4 - x5;\n    c = x1 * x2 + x3 * x4 + (x1 + x2) * (x3 + x4) + (x1 + x2 + x3 + x4) * x5;\n    d = -(x1 + x2) * x3 * x4 - x1 * x2 * (x3 + x4) - (x1 * x2 + x3 * x4 + (x1 + x2) * (x3 + x4)) * x5;\n    e = x1 * x2 * x3 * x4 + ((x1 + x2) * x3 * x4 + x1 * x2 * (x3 + x4)) * x5;\n    f = -x1 * x2 * x3 * x4 * x5;\n}\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nvec2 cmul(in vec2 z, in vec2 w) { return mat2(z, -z.y, z.x) * w; }\nvec2 cdiv(in vec2 z, in vec2 w) { return cmul(z, vec2(w.x, -w.y)) / dot(w, w); }\nint solveQuintic(in float a, in float b, in float c,\n    in float d, in float e, in float f, out float[5] realRoots) {\n    // TODO: refactor\n    // Reduction to x^5 + px^3 + qx^2 + rx + s\n    float p = (5.0 * a * c - 2.0 * b * b) / (5.0 * a * a);\n    float q = (25.0 * a * a * d - 15.0 * a * b * c + 4.0 * b * b * b) / (25.0 * a * a * a);\n    float r = (125.0 * a * a * a * e - 50.0 * a * a * b * d + 15.0 * a * b * b * c - 3.0 * b * b * b * b) / (125.0 * a * a * a * a);\n    float s = (3125.0 * a * a * a * a * f - 625.0 * a * a * a * b * e + 125.0 * a * a * b * b * d - 25.0 * a * b * b * b * c + 4.0 * b * b * b * b * b) / (3125.0 * a * a * a * a * a);\n\n    float bound = 1.0 + max(1.0, max(abs(p), max(abs(q), max(abs(r), abs(s)))));\n    //bound *= 0.414213562373; // Correction if perturbing with random([-1...1])\n    bound *= 0.5; // Keep safely within bounds\n\n    vec2[5] roots;\n    roots[0] = vec2(bound, 0.0); // QuinticRootOfUnity^0\n    roots[1] = vec2(0.309016994375, 0.951056516295) * bound; // QuinticRootOfUnity^1\n    roots[2] = vec2(-0.809016994375, 0.587785252292) * bound; // QuinticRootOfUnity^2\n    roots[3] = vec2(-0.809016994375, -0.587785252292) * bound; // QuinticRootOfUnity^3\n    roots[4] = vec2(0.309016994375, -0.951056516295) * bound; // QuinticRootOfUnity^4\n\n    for (int iter=0; iter < 25; iter++) {\n        float maxEval = -1e20;\n        for (int root=0; root < 5; root++) {\n            vec2 z = roots[root];\n            vec2 quinticVal = cmul(cmul(cmul(cmul(z, z) + vec2(p, 0.0), z) + vec2(q, 0.0), z) + vec2(r, 0.0), z) + vec2(s, 0.0);\n            maxEval = max(maxEval, max(abs(quinticVal.x), abs(quinticVal.y)));\n\n            vec2 denom = z - roots[(root + 1) % 5];\n            denom = cmul(denom, z - roots[(root + 2) % 5]);\n            denom = cmul(denom, z - roots[(root + 3) % 5]);\n            denom = cmul(denom, z - roots[(root + 4) % 5]);\n\n            roots[root] -= cdiv(quinticVal, denom);\n        }\n\n        if (maxEval < 1e-7) break;\n    }\n\n    // Undo substitution y = x + b/5a\n    // and weed out complex roots\n    int numRealRoots = 0;\n    float offs = b / (5.0 * a);\n    for (int root=0; root < 5; root++) {\n        vec2 z = roots[root];\n        if (abs(z.y) < 1e-7) {\n            realRoots[numRealRoots] = z.x - offs;\n            numRealRoots++;\n        }\n    }\n\n    return numRealRoots;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Boilerplate\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n    float time = iTime;\n\n    // Coefficients\n    float a, b, c, d, e, f;\n\n    #ifdef CONSTRUCT_FROM_ROOTS\n    time *= 0.25;\n    float sec = floor(time);\n    float lerp = smoothstep(0.0, 1.0, fract(time));\n\n    // Generate random animated roots\n    float x1 = mix(Hash11(sec), Hash11(sec + 1.0), lerp) * 6.0 - 3.0;\n    float x2 = mix(Hash11(sec + 17.13), Hash11(sec + 18.13), lerp) * 6.0 - 3.0;\n    float x3 = mix(Hash11(sec + 34.26), Hash11(sec + 35.26), lerp) * 6.0 - 3.0;\n    float x4 = mix(Hash11(sec + 51.39), Hash11(sec + 52.39), lerp) * 6.0 - 3.0;\n    float x5 = mix(Hash11(sec + 68.52), Hash11(sec + 69.52), lerp) * 6.0 - 3.0;\n\n    quinticFromRoots(x1, x2, x3, x4, x5,\n                     a, b, c, d, e, f);\n\n    #else\n    a = sin(time * 0.25) * 1.25;\n    b = sin(time) * 2.0;\n    c = sin(time) * 2.0;\n    d = cos(time * 0.75);\n    e = sin(time * 0.5);\n    f = cos(time);\n    #endif\n\n    // Draw the x axis and quintic equation\n    float fx = ((((a * uv.x + b) * uv.x + c) * uv.x + d) * uv.x + e) * uv.x + f;\n    float dx = (((5.0 * a * uv.x + 4.0 * b) * uv.x + 3.0 * c) * uv.x + 2.0 * d) * uv.x + e; // Derivative for distance estimation\n    color.b += smoothstep(unit, 0.0, abs(uv.y));\n    color.rg += smoothstep(unit, 0.0, abs(uv.y - fx) / sqrt(1.0 + dx * dx));\n\n    // Solve and draw expected versus found roots\n    float[5] roots;\n    int numRoots = solveQuintic(a, b, c, d, e, f, roots);\n    for (int n=0; n < numRoots; n++) {\n        color = mix(color, vec3(1.0), smoothstep(unit, 0.0, length(uv - vec2(roots[n], 0.0)) - 0.05));\n\n        #ifdef CONSTRUCT_FROM_ROOTS\n        color = mix(color, vec3(0.0, 1.0, 0.0), smoothstep(unit, 0.0, abs(length(uv - vec2(roots[n], 0.0)) - 0.1)));\n        #endif\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st33Wj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 200, 200, 540], [542, 631, 657, 657, 743], [745, 745, 778, 778, 811], [812, 812, 845, 845, 892]], "test": "untested"}
{"id": "7ldGWj", "name": "Red Shinny Spike Torus", "author": "PauloFalcao", "description": "A shader done in Material Maker", "tags": ["materialmaker", "generatedshader"], "likes": 26, "viewed": 740, "published": 3, "date": "1636757217", "time_retrieved": "2024-07-30T18:48:41.291917", "image_code": "// Red Shinny Spike Torus\n//\n// By https://twitter.com/paulofalcao\n//\n// Generated in Material Maker\n//\n// This uses the MFSDF scene description technique\n// https://www.shadertoy.com/view/7dySRc\n//\n// To generate your own shaders you need:\n//\n// - Material Maker - https://rodzilla.itch.io/material-maker\n// - My Ray Marching library - https://github.com/paulofalcao/MaterialMakerRayMarching\n// \n// Here is a 2 hour video explaining how to use it - https://youtu.be/PvmIohbf93Q\n// \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec4 color = texture(iChannel0, fragCoord / iResolution.xy);\n    fragColor = vec4(pow(color.xyz/color.w,vec3(1.0/2.2)), 1.0f);\n     \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/* Generated by Material Maker */\n\n#define SEED_VARIATION 0.0\n\n//---\n\nfloat rand(vec2 x) {\n    return fract(cos(mod(dot(x, vec2(13.9898, 8.141)), 3.14)) * 43758.5453);\n}\n\nvec2 rand2(vec2 x) {\n    return fract(cos(mod(vec2(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t      dot(x, vec2(3.4562, 17.398))), vec2(3.14))) * 43758.5453);\n}\n\nvec3 rand3(vec2 x) {\n    return fract(cos(mod(vec3(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t\t  dot(x, vec2(3.4562, 17.398)),\n                              dot(x, vec2(13.254, 5.867))), vec3(3.14))) * 43758.5453);\n}\n\nvec3 rgb2hsv(vec3 c) {\n\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n\tvec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat param_rnd(float minimum, float maximum, float seed) {\n\treturn minimum+(maximum-minimum)*rand(vec2(seed));\n}\nvec3 MFSDF_Obj_Maker_rotate3d(vec3 p, vec3 a) {\n\tvec3 rv;\n\tfloat c;\n\tfloat s;\n\tc = cos(a.x);\n\ts = sin(a.x);\n\trv.x = p.x;\n\trv.y = p.y*c+p.z*s;\n\trv.z = -p.y*s+p.z*c;\n\tc = cos(a.y);\n\ts = sin(a.y);\n\tp.x = rv.x*c+rv.z*s;\n\tp.y = rv.y;\n\tp.z = -rv.x*s+rv.z*c;\n\tc = cos(a.z);\n\ts = sin(a.z);\n\trv.x = p.x*c+p.y*s;\n\trv.y = -p.x*s+p.y*c;\n\trv.z = p.z;\n\treturn rv;\n}\nfloat wave3d_constant(float x) {\n\treturn 1.0;\n}\n\nfloat wave3d_sine(float x) {\n\treturn 0.5-0.5*cos(3.14159265359*2.0*x);\n}\n\nfloat wave3d_triangle(float x) {\n\tx = fract(x);\n\treturn min(2.0*x, 2.0-2.0*x);\n}\n\nfloat wave3d_sawtooth(float x) {\n\treturn fract(x);\n}\n\nfloat wave3d_square(float x) {\n\treturn (fract(x) < 0.5) ? 0.0 : 1.0;\n}\n\nfloat wave3d_bounce(float x) {\n\tx = 2.0*(fract(x)-0.5);\n\treturn sqrt(1.0-x*x);\n}\n\nfloat mix3d_mul(float x, float y, float z) {\n\treturn x*y*z;\n}\n\nfloat mix3d_add(float x, float y, float z) {\n\treturn min(x+y+z, 1.0);\n}\n\nfloat mix3d_max(float x, float y, float z) {\n\treturn max(max(x, y), z);\n}\n\nfloat mix3d_min(float x, float y, float z) {\n\treturn min(min(x, y), z);\n}\n\nfloat mix3d_xor(float x, float y, float z) {\n\tfloat xy = min(x+y, 2.0-x-y);\n\treturn min(xy+z, 2.0-xy-z);\n}\n\nfloat mix3d_pow(float x, float y, float z) {\n\treturn pow(pow(x, y), z);\n}float mfsdf3d_smooth_union_f(float a,float b,float k){\n\tfloat h = max( k-abs(a-b), 0.0 )/k;\n\treturn min(a,b)-h*h*k*0.25;\n}\n\nvec4 mfsdf3d_smooth_union(vec4 a, vec4 b, float k) {\n    float e=0.001;\n    k=max(k,e);\n    float h=mfsdf3d_smooth_union_f(a.w,b.w,k);\n\tvec2 n=normalize(vec2(mfsdf3d_smooth_union_f(a.w+e,b.w,k)-mfsdf3d_smooth_union_f(a.w-e,b.w,k),\n                          mfsdf3d_smooth_union_f(a.w,b.w+e,k)-mfsdf3d_smooth_union_f(a.w,b.w-e,k)));\n    return vec4(mix(a.xyz,b.xyz,atan(abs(n.y),abs(n.x))/(3.14159265359/2.0)),h);\n}\n\nfloat mfsdf3d_smooth_subtraction_f(float a,float b,float k){\n\tfloat h = max( k-abs(-a-b), 0.0 )/k;\n\treturn max(-a,b)+h*h*k*0.25;\n}\n\nvec4 mfsdf3d_smooth_subtraction(vec4 a, vec4 b, float k) {\n    float e=0.001;\n    k=max(k,e);\n\tfloat h=mfsdf3d_smooth_subtraction_f(a.w,b.w,k);\n\tvec2 n=normalize(vec2(mfsdf3d_smooth_subtraction_f(a.w+e,b.w,k)-mfsdf3d_smooth_subtraction_f(a.w-e,b.w,k),\n                          mfsdf3d_smooth_subtraction_f(a.w,b.w+e,k)-mfsdf3d_smooth_subtraction_f(a.w,b.w-e,k)));\n    return vec4(mix(a.xyz,b.xyz,atan(abs(n.y),abs(n.x))/(3.14159265359/2.0)),h);\n}\n\nfloat mfsdf3d_smooth_intersection_f(float a,float b,float k){\n\tfloat h = max( k-abs(a-b), 0.0 )/k;\n\treturn max(a,b)+h*h*k*0.25;\n}\n\nvec4 mfsdf3d_smooth_intersection(vec4 a, vec4 b, float k) {\n    float e=0.001;\n    k=max(k,e);\n\tfloat h=mfsdf3d_smooth_intersection_f(a.w,b.w,k);\n\tvec2 n=normalize(vec2(mfsdf3d_smooth_intersection_f(a.w+e,b.w,k)-mfsdf3d_smooth_intersection_f(a.w-e,b.w,k),\n                          mfsdf3d_smooth_intersection_f(a.w,b.w+e,k)-mfsdf3d_smooth_intersection_f(a.w,b.w-e,k)));\n    return vec4(mix(a.xyz,b.xyz,atan(abs(n.y),abs(n.x))/(3.14159265359/2.0)),h);\n}vec4 MFSDF_Union(vec4 in1,vec4 in2,vec4 in3,vec4 in4,vec4 in5,vec4 in6,vec4 in7,vec4 in8){\n    vec4 t=(in1.w<in2.w)?vec4(in1):vec4(in2);\n    t=(t.w<in2.w)?vec4(t):vec4(in2);\n    t=(t.w<in3.w)?vec4(t):vec4(in3);\n    t=(t.w<in4.w)?vec4(t):vec4(in4);\n    t=(t.w<in5.w)?vec4(t):vec4(in5);\n    t=(t.w<in6.w)?vec4(t):vec4(in6);\n    t=(t.w<in7.w)?vec4(t):vec4(in7);\n    t=(t.w<in8.w)?vec4(t):vec4(in8);\n    return t;\n}\n\n\n//MATH\nconst float PI=3.14159265359;\nconst float TAU=6.28318530718;\n\nvec2 rndint_hash23(vec3 p3){\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvoid Onb(in vec3 N, inout vec3 T, inout vec3 B){\n    vec3 UpVector=abs(N.z)<0.999?vec3(0,0,1):vec3(1,0,0);\n    T=normalize(cross(UpVector,N));\n    B=cross(N,T);\n}\n\nvec2 equirectangularMap(vec3 dir) {\n\tvec2 longlat = vec2(atan(dir.y,dir.x),acos(dir.z));\n \treturn longlat/vec2(2.0*PI,PI);\n}\n\n// RANDOM START\n//from https://www.reedbeta.com/blog/hash-functions-for-gpu-rendering/\nuint rand_pcg(inout uint seed){\n    uint state = seed;\n    seed = seed * uint(747796405) + uint(2891336453);\n    uint word = ((state >> ((state >> uint(28)) + uint(4))) ^ state) * uint(277803737);\n    return (word >> uint(22)) ^ word;\n}\n\nfloat RandomFloat01(inout uint state){\n    uint r=rand_pcg(state);\n    r &= uint(0x007FFFFF);\n    r |= uint(0x3F800000);\n    return uintBitsToFloat(r) - 1.0f;\n}\n\n// RANDOM END\n\n// SAMPLING START\n\nvec3 constSampleSphere(float r1,float r2){\n    float z=1.0-2.0*r1;\n    float r=sqrt(max(0.0,1.0-z*z));\n    float phi=TAU*r2;\n    return vec3(r*cos(phi),r*sin(phi),z);\n}\n\nvec3 cosineSampleHemissphere(inout uint state,vec3 n){\n    float u1=RandomFloat01(state);\n    float u2=RandomFloat01(state);\n    return normalize(n+constSampleSphere(u1,u2)); \n}\n\n// Adapted from \"Sampling the GGX Distribution of Visible Normals\",\n// http://jcgt.org/published/0007/04/01/\nvec3 SampleGGXVNDF(inout uint state,vec3 Ve,float alpha_x,float alpha_y){\n    float U1=RandomFloat01(state);\n    float U2=RandomFloat01(state);\n    \n    //transforming the view direction to the hemisphere configuration\n    vec3 Vh = normalize(vec3(alpha_x * Ve.x, alpha_y * Ve.y, Ve.z));\n\n    //orthonormal basis\n    vec3 T1;vec3 T2;\n    Onb(Vh,T1,T2);\n\n    //parameterization of the projected area\n    float r = sqrt(U1); \n    float phi = 2.0 * PI * U2;    \n    float t1 = r * cos(phi);\n    float t2 = r * sin(phi);\n    float s = 0.5 * (1.0 + Vh.z);\n    t2 = (1.0 - s)*sqrt(1.0 - t1*t1) + s*t2;\n\n    //reprojection onto hemisphere\n    vec3 Nh = t1*T1 + t2*T2 + sqrt(max(0.0f, 1.0f - t1*t1 - t2*t2))*Vh;\n\n    //transforming the normal back to the ellipsoid configuration\n    vec3 Ne = normalize(vec3(alpha_x * Nh.x, alpha_y * Nh.y, max(0.0f, Nh.z))); \n\n    return Ne;\n}\n\nfloat schlickWeight(float cosTheta) {\n    float m=clamp(1.-cosTheta,0.,1.);\n    float m2=m*m;\n    return m2*m2*m;\n}\n\n// SAMPLING END\n\nconst float p_o90873_CamX = -2.276000023;\nconst float p_o90873_CamY = -1.105000019;\nconst float p_o90873_CamZ = 1.014999986;\nconst float p_o90873_LookAtX = 0.000000000;\nconst float p_o90873_LookAtY = -0.528999984;\nconst float p_o90873_LookAtZ = 0.000000000;\nconst float p_o90873_CamD = 1.500000000;\nconst float p_o90873_CamZoom = 1.000000000;\nconst float p_o90873_MaxDistance = 200.000000000;\nconst float p_o85587_BaseColor_r = 1.000000000;\nconst float p_o85587_BaseColor_g = 1.000000000;\nconst float p_o85587_BaseColor_b = 1.000000000;\nconst float p_o85587_BaseColor_a = 1.000000000;\nconst float p_o85587_Metallic = 0.000000000;\nconst float p_o85587_Specular = 0.500000000;\nconst float p_o85587_Roughness = 0.000000000;\nconst float p_o85587_Emission = 5.000000000;\nconst float p_o85587_Normal = 0.000000000;\nconst float p_o85587_Alpha = 0.000000000;\nconst float p_o85587_AmbientOcclusion = 0.000000000;\nconst float p_o85587_scale = 1.702000000;\nconst float p_o85587_TranlateX = -2.286000000;\nconst float p_o85587_TranlateY = 0.647000000;\nconst float p_o85587_TranlateZ = 0.840000000;\nconst float p_o85587_RotateX = 0.000000000;\nconst float p_o85587_RotateY = 0.000000000;\nconst float p_o85587_RotateZ = 0.000000000;\nvec3 o85587_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nfloat o85587_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o85587_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o85587_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o85587_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o85587_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o85587_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o85587_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o85587_input_sdf3d(vec3 p, float _seed_variation_) {\n\nreturn length((p))-0.4 ;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o85587(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o85587_TranlateX,p_o85587_TranlateY,p_o85587_TranlateZ),vec3(p_o85587_RotateX,p_o85587_RotateY,p_o85587_RotateZ)*6.28318530718)/p_o85587_scale;\n\tfloat sdf=o85587_input_sdf3d(uv.xyz, _seed_variation_)*p_o85587_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o85587_AmbientOcclusion*o85587_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o85587_Alpha*o85587_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o85587_Normal*o85587_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o85587_Emission*o85587_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o85587_Roughness*o85587_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o85587_Specular*o85587_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o85587_Metallic*o85587_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o85587_BaseColor_r, p_o85587_BaseColor_g, p_o85587_BaseColor_b, p_o85587_BaseColor_a).rgb*o85587_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}const float p_o85591_BaseColor_r = 1.000000000;\nconst float p_o85591_BaseColor_g = 1.000000000;\nconst float p_o85591_BaseColor_b = 1.000000000;\nconst float p_o85591_BaseColor_a = 1.000000000;\nconst float p_o85591_Metallic = 0.000000000;\nconst float p_o85591_Specular = 0.000000000;\nconst float p_o85591_Roughness = 0.000000000;\nconst float p_o85591_Emission = 5.000000000;\nconst float p_o85591_Normal = 0.000000000;\nconst float p_o85591_Alpha = 0.000000000;\nconst float p_o85591_AmbientOcclusion = 0.000000000;\nconst float p_o85591_scale = 1.000000000;\nconst float p_o85591_TranlateX = 5.780000000;\nconst float p_o85591_TranlateY = -0.148000000;\nconst float p_o85591_TranlateZ = -2.078000000;\nconst float p_o85591_RotateX = 0.218000000;\nconst float p_o85591_RotateY = -0.071000000;\nconst float p_o85591_RotateZ = 0.280000000;\nvec3 o85591_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nfloat o85591_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o85591_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o85591_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o85591_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o85591_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o85591_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o85591_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o85603_sx = 22.120000000;\nconst float p_o85603_sy = 0.280000000;\nconst float p_o85603_sz = 24.020000000;\nconst float p_o85603_r = 0.010000000;\nfloat o85591_input_sdf3d(vec3 p, float _seed_variation_) {\nvec3 o85603_0_q = abs((p)) - vec3(p_o85603_sx, p_o85603_sy, p_o85603_sz);\nfloat o85603_0_1_sdf3d = length(max(o85603_0_q,0.0))+min(max(o85603_0_q.x,max(o85603_0_q.y,o85603_0_q.z)),0.0)-p_o85603_r;\n\nreturn o85603_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o85591(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o85591_TranlateX,p_o85591_TranlateY,p_o85591_TranlateZ),vec3(p_o85591_RotateX,p_o85591_RotateY,p_o85591_RotateZ)*6.28318530718)/p_o85591_scale;\n\tfloat sdf=o85591_input_sdf3d(uv.xyz, _seed_variation_)*p_o85591_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o85591_AmbientOcclusion*o85591_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o85591_Alpha*o85591_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o85591_Normal*o85591_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o85591_Emission*o85591_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o85591_Roughness*o85591_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o85591_Specular*o85591_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o85591_Metallic*o85591_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o85591_BaseColor_r, p_o85591_BaseColor_g, p_o85591_BaseColor_b, p_o85591_BaseColor_a).rgb*o85591_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}const float p_o85619_k = 0.293000000;\nconst float p_o85595_BaseColor_r = 1.000000000;\nconst float p_o85595_BaseColor_g = 0.000000000;\nconst float p_o85595_BaseColor_b = 0.000000000;\nconst float p_o85595_BaseColor_a = 1.000000000;\nconst float p_o85595_Metallic = 0.225000000;\nconst float p_o85595_Specular = 0.878000000;\nconst float p_o85595_Roughness = 0.000000000;\nconst float p_o85595_Emission = 0.000000000;\nconst float p_o85595_Normal = 0.000000000;\nconst float p_o85595_Alpha = 0.000000000;\nconst float p_o85595_AmbientOcclusion = 0.000000000;\nconst float p_o85595_scale = 0.991000000;\nconst float p_o85595_TranlateX = 0.000000000;\nconst float p_o85595_TranlateY = -0.743000000;\nconst float p_o85595_TranlateZ = 0.000000000;\nconst float p_o85595_RotateX = -0.120000000;\nconst float p_o85595_RotateY = 0.059000000;\nconst float p_o85595_RotateZ = -0.079000000;\nvec3 o85595_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0);\n}\nfloat o85595_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o85595_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o85595_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o85595_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o85595_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o85595_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o85595_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o85610_Distort = 0.168000000;\nconst float p_o85610_Correction = 17.656000000;\nconst float p_o85610_Bound = 3.645000000;\nconst float p_o85609_R = 0.800000000;\nconst float p_o85609_r = 0.270000000;\nfloat o85610_input_sdf(vec3 p, float _seed_variation_) {\nvec2 o85609_0_q = vec2(length((p).xy)-p_o85609_R,(p).z);\nfloat o85609_0_1_sdf3d = length(o85609_0_q)-p_o85609_r;\n\nreturn o85609_0_1_sdf3d;\n}\nconst float p_o85615_x_scale = 4.000000000;\nconst float p_o85615_y_scale = 14.000000000;\nconst float p_o85615_z_scale = 15.000000000;\nfloat o85615_fct(vec3 uv, float _seed_variation_) {\n\treturn mix3d_mul(wave3d_sine(p_o85615_x_scale*uv.x), wave3d_sine(p_o85615_y_scale*uv.y), wave3d_sine(p_o85615_z_scale*uv.z));\n}vec3 o85610_input_tex3d(vec4 p, float _seed_variation_) {\nvec3 o85615_0_1_tex3d = vec3(o85615_fct((p).xyz, _seed_variation_));\n\nreturn o85615_0_1_tex3d;\n}\n//tetrahedron normal by PauloFalcao\n//https://www.shadertoy.com/view/XstGDS\nvec3 normal_o85610(vec3 p, float _seed_variation_) {  \n  const vec3 e=vec3(0.01,-0.01,0.0);\n  float v1=o85610_input_sdf(p+e.xyy, _seed_variation_);\n  float v2=o85610_input_sdf(p+e.yyx, _seed_variation_);\n  float v3=o85610_input_sdf(p+e.yxy, _seed_variation_);\n  float v4=o85610_input_sdf(p+e.xxx, _seed_variation_);\n  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n}\n\n//By pauloFalcao\nvec4 distortHeighByNormal_o85610(vec3 uv, float _seed_variation_) {\n    float d=o85610_input_sdf(uv, _seed_variation_);\n\tif (d<=abs(p_o85610_Distort*(p_o85610_Bound+1.0))+0.01){\n\t\tvec3 n=normal_o85610(uv, _seed_variation_);\n\t\tvec3 s=o85610_input_tex3d(vec4(uv-d*n,0.0), _seed_variation_);\n\t    return vec4(s,o85610_input_sdf(uv-n*s*p_o85610_Distort, _seed_variation_));\n\t} else {\n\t\treturn vec4(vec3(0.0),d);\n\t}\n\n}float o85595_input_sdf3d(vec3 p, float _seed_variation_) {\nvec4 o85610_0_d = distortHeighByNormal_o85610((p).xyz, _seed_variation_);\no85610_0_d.w = o85610_0_d.w/(1.0+p_o85610_Distort*p_o85610_Correction);float o85610_0_1_sdf3d = o85610_0_d.w;\n\nreturn o85610_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o85595(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o85595_TranlateX,p_o85595_TranlateY,p_o85595_TranlateZ),vec3(p_o85595_RotateX,p_o85595_RotateY,p_o85595_RotateZ)*6.28318530718)/p_o85595_scale;\n\tfloat sdf=o85595_input_sdf3d(uv.xyz, _seed_variation_)*p_o85595_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o85595_AmbientOcclusion*o85595_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o85595_Alpha*o85595_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o85595_Normal*o85595_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o85595_Emission*o85595_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o85595_Roughness*o85595_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o85595_Specular*o85595_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o85595_Metallic*o85595_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o85595_BaseColor_r, p_o85595_BaseColor_g, p_o85595_BaseColor_b, p_o85595_BaseColor_a).rgb*o85595_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}const float p_o85599_BaseColor_r = 1.000000000;\nconst float p_o85599_BaseColor_g = 1.000000000;\nconst float p_o85599_BaseColor_b = 1.000000000;\nconst float p_o85599_BaseColor_a = 1.000000000;\nconst float p_o85599_Metallic = 0.000000000;\nconst float p_o85599_Specular = 0.575000000;\nconst float p_o85599_Roughness = 0.000000000;\nconst float p_o85599_Emission = 0.000000000;\nconst float p_o85599_Normal = 0.000000000;\nconst float p_o85599_Alpha = 0.000000000;\nconst float p_o85599_AmbientOcclusion = 0.000000000;\nconst float p_o85599_scale = 1.547000000;\nconst float p_o85599_TranlateX = 0.019000000;\nconst float p_o85599_TranlateY = -1.701000000;\nconst float p_o85599_TranlateZ = -0.025000000;\nconst float p_o85599_RotateX = 0.000000000;\nconst float p_o85599_RotateY = 0.000000000;\nconst float p_o85599_RotateZ = 0.000000000;\nconst float p_o85605_x_scale = 2.000000000;\nconst float p_o85605_y_scale = 2.000000000;\nconst float p_o85605_z_scale = 2.000000000;\nfloat o85605_fct(vec3 uv, float _seed_variation_) {\n\treturn mix3d_xor(wave3d_square(p_o85605_x_scale*uv.x), wave3d_square(p_o85605_y_scale*uv.y), wave3d_square(p_o85605_z_scale*uv.z));\n}vec3 o85599_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\nvec3 o85605_0_1_tex3d = vec3(o85605_fct((p).xyz, _seed_variation_));\n\nreturn o85605_0_1_tex3d;\n}\nfloat o85599_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o85599_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o85599_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nvec3 o85599_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 o85599_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n\nreturn vec3(0.0,1.0,0.0);\n}\nfloat o85599_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nfloat o85599_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n\nreturn 1.0;\n}\nconst float p_o85604_sx = 10.360000000;\nconst float p_o85604_sy = 0.250000000;\nconst float p_o85604_sz = 18.710000000;\nconst float p_o85604_r = 0.010000000;\nfloat o85599_input_sdf3d(vec3 p, float _seed_variation_) {\nvec3 o85604_0_q = abs((p)) - vec3(p_o85604_sx, p_o85604_sy, p_o85604_sz);\nfloat o85604_0_1_sdf3d = length(max(o85604_0_q,0.0))+min(max(o85604_0_q.x,max(o85604_0_q.y,o85604_0_q.z)),0.0)-p_o85604_r;\n\nreturn o85604_0_1_sdf3d;\n}\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n//13 - Emission\t              (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf) \n//999 - Table ID - Identifies this table (0,0,0,0)\n\nvec4 PBRObjectMaker_o85599(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o85599_TranlateX,p_o85599_TranlateY,p_o85599_TranlateZ),vec3(p_o85599_RotateX,p_o85599_RotateY,p_o85599_RotateZ)*6.28318530718)/p_o85599_scale;\n\tfloat sdf=o85599_input_sdf3d(uv.xyz, _seed_variation_)*p_o85599_scale;\n\t//19 - Ambient Occlusion\n\tif (uv.w>18.5) {\n\t\treturn vec4(p_o85599_AmbientOcclusion*o85599_input_AmbientOcclusion_tex3d(vec4(uv.xyz,19.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//15 - Alpha\n\tif (uv.w>14.5) {\n\t\treturn vec4(p_o85599_Alpha*o85599_input_Alpha_tex3d(vec4(uv.xyz,15.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//14 - Normal\n\tif (uv.w>13.5) {\n\t\treturn vec4(p_o85599_Normal*o85599_input_Normal_tex3d(vec4(uv.xyz,14.0), _seed_variation_),sdf);\n\t} else\n\t//13 - Emission\n\tif (uv.w>12.5) {\n\t\treturn vec4(p_o85599_Emission*o85599_input_Emission_tex3d(vec4(uv.xyz,13.0), _seed_variation_),sdf);\n\t} else\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o85599_Roughness*o85599_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o85599_Specular*o85599_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//2 - Metallic\n\tif (uv.w>1.5) {\n\t\treturn vec4(p_o85599_Metallic*o85599_input_Metallic_tex3d(vec4(uv.xyz,2.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o85599_BaseColor_r, p_o85599_BaseColor_g, p_o85599_BaseColor_b, p_o85599_BaseColor_a).rgb*o85599_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}vec4 o90873_input_mfsdf(vec4 p, float _seed_variation_) {\nvec4 o85587_0_1_v4v4 = PBRObjectMaker_o85587((p), _seed_variation_);\nvec4 o85591_0_1_v4v4 = PBRObjectMaker_o85591((p), _seed_variation_);\nvec4 o85595_0_1_v4v4 = PBRObjectMaker_o85595((p), _seed_variation_);\nvec4 o85599_0_1_v4v4 = PBRObjectMaker_o85599((p), _seed_variation_);\nvec4 o85619_0_1_v4v4 = mfsdf3d_smooth_union(o85595_0_1_v4v4, o85599_0_1_v4v4,p_o85619_k);\nvec4 o85586_0_1_v4v4 = MFSDF_Union(o85587_0_1_v4v4,o85591_0_1_v4v4,o85619_0_1_v4v4,vec4(0.0,0.0,0.0,9999999.0),vec4(0.0,0.0,0.0,9999999.0),vec4(0.0,0.0,0.0,9999999.0),vec4(0.0,0.0,0.0,9999999.0),vec4(0.0,0.0,0.0,9999999.0));\n\nreturn o85586_0_1_v4v4;\n}\nvec3 o90873_input_hdri(vec2 uv, float _seed_variation_) {\n\nreturn vec3(0.0);\n}\n\n//tetrahedron normal by PauloFalcao\nvec3 normal_o90873(vec3 p, float _seed_variation_) {  \n  const vec3 e=vec3(0.001,-0.001,0.0);\n  float v1=o90873_input_mfsdf(vec4(p+e.xyy,0.0), _seed_variation_).w;\n  float v2=o90873_input_mfsdf(vec4(p+e.yyx,0.0), _seed_variation_).w;\n  float v3=o90873_input_mfsdf(vec4(p+e.yxy,0.0), _seed_variation_).w;\n  float v4=o90873_input_mfsdf(vec4(p+e.xxx,0.0), _seed_variation_).w;\n  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n}\n\nvoid raymarch_o90873(in vec3 o,in vec3 v,out vec3 p,inout float d, float _seed_variation_) {\n  float s;\n  for(int i=0;i<512;i++){\n    p=o+v*d;\n    s=o90873_input_mfsdf(vec4(p,0.0), _seed_variation_).w;\n    if (abs(s)<0.0001) break;\n    d+=s;\n    if (d>p_o90873_MaxDistance) break;\n  } \n}\n\n/*EDITED OLD\nvec3 pathtracing_o90873(vec2 uv, float _seed_variation_) {\n\n\t// Init random\n\tvec2 rndgen=rndint_hash23(vec3(uv,iTime))*15360.0;\n    uint rngState = uint(uint(rndgen.x) * uint(1973) + uint(rndgen.y) * uint(9277) + uint(iTime*1223.0) * uint(26699)) | uint(1);\nEDITED OLD*/\n  \nvec3 pathtracing_o90873(uint rngState, vec2 uv, float _seed_variation_) { //EDITED NEW \n\n\t//vec3 o=vec3(p_o90873_CamX,p_o90873_CamY,p_o90873_CamZ)*p_o90873_CamZoom; //EDITED OLD add mouse\n    \n    //EDITED NEW add mouse\n    float mx=(iMouse.x/iResolution.x)*4.0;\n    float my=(iMouse.y/iResolution.y)*4.0;\n\tvec3 o=vec3(p_o90873_CamX+my,p_o90873_CamY,p_o90873_CamZ+mx)*p_o90873_CamZoom;\n    //EDITED NEW add mouse\n    \n    vec3 t=vec3(p_o90873_LookAtX,p_o90873_LookAtY,p_o90873_LookAtZ);\n    vec3 u=vec3(0.0,1.0,0.0);\n    vec3 c=normalize(t-o);\n    vec3 cx=normalize(cross(u,c));\n    vec3 cy=normalize(cross(cx,c));\n   \n\tvec2 xy=uv-0.5;\n\n    vec3 v=normalize(c*p_o90873_CamD+cx*xy.x+cy*xy.y);\n\n    vec3 p;\n    float d=0.01;\n    vec3 rgb=vec3(1.0);\n    vec3 io=o;\n    int i;\n    for(i=0;i<8;i++){\n    \n        raymarch_o90873(io,v,p,d, _seed_variation_);\n        \n        vec3 n=normal_o90873(p, _seed_variation_);\n        \n        //View direction to tangent space\n        vec3 ot;vec3 ob;Onb(n,ot,ob);\n        vec3 vt=vec3(dot(-v,ot),dot(-v,ob),dot(-v,n));\n\t\n        if (d<p_o90873_MaxDistance){\t\n        //if (length(p-o)<p_o90873_MaxDistance){\n        vec3 obj_Emission=o90873_input_mfsdf(vec4(p,13.0), _seed_variation_).rgb;\n        \n        if ((obj_Emission.x+obj_Emission.y+obj_Emission.z)>0.001){\n            rgb=obj_Emission*rgb;\n            break;\n        } else {\n            float s=RandomFloat01(rngState);\n\n            vec3 obj_BaseColor=o90873_input_mfsdf(vec4(p,1.0), _seed_variation_).rgb; // 1 - BaseColor  (r,g,b,sdf)\n            float obj_Metallic=o90873_input_mfsdf(vec4(p,2.0), _seed_variation_).x;   // 2 - Metallic   (v,0,0,sdf)\n            float obj_Specular=o90873_input_mfsdf(vec4(p,4.0), _seed_variation_).x;   // 4 - Specular   (v,0,0,sdf)\n            float obj_Roughness=o90873_input_mfsdf(vec4(p,5.0), _seed_variation_).x;  // 5 - Roughness  (v,0,0,sdf)\n\n            if (s>obj_Specular*obj_Specular){\n                rgb=(obj_BaseColor-obj_BaseColor*obj_Metallic)*rgb;\n                v=cosineSampleHemissphere(rngState,n);\n            } else {\n\n                float r2=obj_Roughness*obj_Roughness;\n                vec3 vndf=SampleGGXVNDF(rngState,vt,r2,r2);\n                vec3 nv=reflect(-vt,vndf);\n\n                //Sample direction back to camera space\n                nv=nv.x*ot+nv.y*ob+nv.z*n;\n\n                float FH=schlickWeight(dot(n,nv));\n                vec3 Cspec0=mix(vec3(obj_Specular*.08),obj_BaseColor,obj_Metallic);\n                vec3 Fs=mix(Cspec0,vec3(1.0),FH);\n                rgb=Fs*rgb;\n                \n                v=nv;\n            }\n            io=p;\n            d=0.01;\n        }\n        } else {\n        rgb*=o90873_input_hdri(equirectangularMap(v.xzy), _seed_variation_).xyz;\n        break;\n        }\n    }//for(int i\n    if (i==8) rgb=vec3(0.0);//did not hit any light source\n\n\treturn rgb;\n\t\n}\n\n/* EDITED OLD\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\nfloat minSize = min(iResolution.x, iResolution.y);\nfloat _seed_variation_ = SEED_VARIATION;\nvec2 UV = vec2(0.0, 1.0) + vec2(1.0, -1.0) * (fragCoord-0.5*(iResolution.xy-vec2(minSize)))/minSize;\nvec3 o90873_0_1_rgb = pathtracing_o90873((UV), _seed_variation_);\nfragColor = vec4(o90873_0_1_rgb, 1.0);\n}\nEDITED OLD*/\n\n//EDITED NEW\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    vec2 xy=fragCoord+vec2(RandomFloat01(rngState),RandomFloat01(rngState));\n\n    float minSize = min(iResolution.x, iResolution.y);\n    float _seed_variation_ = SEED_VARIATION;\n    vec2 UV = vec2(0.0, 1.0) + vec2(1.0, -1.0) * (xy-0.5*(iResolution.xy-vec2(minSize)))/minSize;\n    vec3 rgb = /*change here*/pathtracing_o90873(rngState,(UV), _seed_variation_);\n\n    if (iMouse.z<0.1){\n        vec4 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy);\n        fragColor = vec4(lastFrameColor+vec4(rgb,1.0));\n    } else {\n        fragColor = vec4(rgb,1.0);\n    }\n\n}\n//EDITED NEW", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ldGWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[484, 484, 540, 540, 679]], "test": "untested"}
{"id": "7tt3WB", "name": "Refraction Truchets", "author": "byt3_m3chanic", "description": "Overhaul of an one of my early shaders, going back to update marching loop/normals/refraction etc. (mouseable)", "tags": ["raymarching", "refraction", "truchet", "pattern", "tiles"], "likes": 14, "viewed": 366, "published": 3, "date": "1636749220", "time_retrieved": "2024-07-30T18:48:42.104744", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Refraction Truchets [015] (mouseable)\n    11/12/21 @byt3_m3chanic\n    \n    An update to one of my earlier shaders, where I could barely do\n    2 bounce reflections - now sporting the refraction and some \n    smooth movement.\n    \n    I'd like to figure out chromatic aberration for the refraction\n    or maybe I should just get into ray tracing?!\n\n    original https://www.shadertoy.com/view/sdXSW4\n\n*/\n\n#define R \t\t    iResolution\n#define T \t\t    iTime\n#define M \t\t    iMouse\n\n#define PI          3.141592653\n#define PI2         6.283185307\n\nfloat hash21(vec2 a) { return fract(sin(dot(a,vec2(21.23,41.232)))*4123.2323); }\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), .0, 1.); }\nfloat eoc(float t) { return (t = t - 1.) * t * t + 1.; }\n\n//@iq sdf's\nfloat box( vec3 p, vec3 b ){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat cyl(vec3 p, float h, float r ){\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat cap( vec3 p, vec2 hr ){\n    p.y -= clamp( p.y, 0.0, hr.x );\n    return length( p ) - hr.y;\n}\nfloat torus( vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xy)-t.x,p.z);   \n    return length(q)-t.y;\n}\n//@iq\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvec2 mod2(inout vec3 p, float scale){\n    float hlf = scale*.5;\n    vec2 id=floor((p.xy+hlf)/scale);\n    p.xy = mod(p.xy+hlf,scale)-hlf;\n    return id;\n}\n\nvec3 hit,hitPoint;\nvec2 id,tileId;\nmat2 turn,trs;\nfloat zIndex=0.,zid=0.;\nfloat tmod=0.,ga2=0.,ga5=0.;\n\n// sdf scene\nconst float size = 4.;\nconst float hlf = size*.5;\nconst float hzf = hlf*.5;\nconst float sp  = 15.;\nconst float hsp = sp*.5;\n\nvec2 map(vec3 p) {\n\n    vec3 ip = p-vec3(0,0,ga2*sp);\n    p.z+=4.25;\n    p.z-=ga5*sp;\n\n    zid = floor((ip.z+hsp)/sp)-.5;\n    p.xy*=rot(zid*.198);\n\n    p.z = mod(p.z+hsp,sp)-hsp;\n\n    vec2 res = vec2(1e5,0.);\n\n    float d = 1e5, t = 1e5;\n    vec3 q = p;\n    vec3 s = p-vec3(hlf,hlf,-hlf);\n    vec2 cid = mod2(q,size);\n    vec2 sid = mod2(s,size);\n    float ht = hash21(cid+zid); \n\n    // build parts\n    float thx = (.08+.055*sin(p.y*1.25) ) *size;\n    if(ht>.5) q.x *= -1.;\n\n    vec2 t2 = vec2(length(q.xy-hlf),length(q.xy+hlf));\n    vec2 q2 = t2.x<t2.y?vec2(q.xy-hlf):vec2(q.xy+hlf);\n    vec3 q3 = vec3(q2,q.z);\n    \n    float ti = torus(q3,vec2(hlf,thx));\n\n    // truchet\n    if(ti<res.x) {\n        res = vec2(ti*.8,2.);\n        hit = q;\n        id = cid;\n    }\n\n    vec2 bfm = vec2(hlf*.825,hlf+.1);\n\n    vec3 nq = cid!=vec2(0) ? q-vec3(0,0,.5) : q;\n    float b = box(nq,bfm.xxy);\n\n    b = min(box(q,bfm.yxx),b);\n    b = min(box(q,bfm.xyx),b);\n\n    float c = box(q,vec3(hlf)*.975);\n    float di = max(c,-b);\n\n    float sp = cap(s.xzy,vec2(size+.25,.675));\n    di=smin(di,sp,.125);\n\n    // box\n    if(di<res.x) {\n        res = vec2(di,3.);\n        hit = q;\n    }\n\n    return res;\n}\n\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t, float mindist) {\n    float e = mindist*t;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n}\n   \nvec3 hue(float t){ \n    return .65 + .35*cos(232.+PI2*t*(vec3(0.989,0.977,0.989)*vec3(0.925,0.722,0.435))); \n}\n\nvec3 shade(vec3 p, vec3 rd, float d, float m, inout vec3 n, inout float fresnel, inout vec3 h) {\n\n    n = normal(p,d,1.);\n\n    vec3 l = normalize(vec3(5.,30,10)-p);\n    float diff = clamp(dot(n,l),.1,.8);\n    //@Shane specular highlights!\n    float spec = pow(max(dot(reflect(l, n), rd ), .1), 32.);\n        \n    fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 9.);\n    fresnel = mix(.0, .95, fresnel);\n    // doin a second fill light\n    l = normalize(vec3(-2.,020,-25)-p);\n    float diff2 = clamp(dot(n,l),.0,.8)*.65;\n    float spec2 = pow(max(dot(reflect(l, n), rd ), .2), 64.)*.65;\n\n    h = vec3(.075);\n\n    if(m==2.) {   \n        hitPoint/=size;\n        float dir = mod(tileId.x + tileId.y,2.) * 2. - 1.; \n        vec2 uv = hitPoint.xy-sign(hitPoint.x+hitPoint.y+.001)*.5;\n\n        float angle = atan(uv.x, uv.y);\n        float a = sin( dir * angle * 4. + T * .75);\n        a = abs(a)-.45;a = abs(a)-.35;\n        vec3 nz = hue(floor(a*3.5)+zIndex*2.);\n        h = mix(nz, vec3(.0001), smoothstep(.1, .11, a));  \n    }\n\n    return h*diff*vec3(0.933,0.984,0.984)+spec*diff2+spec2;\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    trs = rot(PI*4.5);\n    turn = rot(-.1);\n    // movment and timing\n    float tt = T*.85;\n    tmod = mod(tt, 10.);\n    float t9 = lsp(0.0, 9.0, tmod);\n    t9 = eoc(t9);\n    t9 = t9*t9*t9;  \n    ga5 = t9;\n    ga2 = t9+floor(tt*.1);\n    \n    vec3 C=vec3(.0);\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n\n    vec3 ro = vec3(0,0,1.),\n         rd = normalize(vec3(uv,-1));\n\n    float x = M.z<0.||M.xy == vec2(0) ? 0. :  (M.y/R.y * .25 - .125) * PI;\n    float y = M.z<0.||M.xy == vec2(0) ? 0. : -(M.x/R.x * .5 - .25) * PI;\n\n    mat2 rx = rot(x),ry = rot(y);\n    ro.yz *= rx; ro.xz *= ry;\n    rd.yz *= rx; rd.xz *= ry;\n\n    vec3  p = ro + rd * .1;\n    float atten = .95,k = 1.;\n    float bt =2.;// cheat to break for reflection bounce\n    float ct =6.;// cheat to break for refraction bounce\n    // loop inspired/adapted from @blackle's \n    // marcher https://www.shadertoy.com/view/flsGDH\n    for(int i=0;i<134;i++)\n    {\n        vec2 ray = map(p);\n        float d = ray.x*.9;\n        float m = ray.y;\n\n        p += rd * d *k;\n        \n        if (d*d < 1e-8) {\n            hitPoint=hit; tileId=id, zIndex= zid;\n            \n            vec3 n=vec3(0);\n            float fresnel= 0.;\n            vec3 h=vec3(0);\n\n            C+=shade(p,rd,d,ray.y,n,fresnel,h)*atten;\n            if(bt<1.||ct<1.)break;\n\n            p += rd*.002;\n            k = sign(map(p).x);\n\n            vec3 rr = vec3(0);\n            // use h value and material to decide to reflect or refract\n            if(m==2.&&(h.r>.175||h.g>.175||h.b>.175)) {\n                atten *=.25;\n                rd=reflect(-rd,n);\n                p+=n*.02;\n                bt--;\n            }else{\n                ct--;\n                atten *= .6;\n                rr = refract(rd,n,.95);\n                rd=mix(rd,rr,.95-fresnel);\n            }\n        }  \n        if(distance(p,rd)>55.) { break; }\n    }\n\n    // Output to screen\n    C = sqrt(smoothstep(0.,1.,C));\n    O = vec4(C,1.);\n}\n\n//end\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tt3WB.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[644, 644, 666, 666, 724], [725, 725, 744, 744, 789], [790, 790, 834, 834, 887], [888, 888, 908, 908, 944], [946, 958, 986, 986, 1077], [1078, 1078, 1115, 1115, 1226], [1227, 1227, 1256, 1256, 1325], [1326, 1326, 1356, 1356, 1428], [1429, 1435, 1478, 1478, 1578], [1580, 1580, 1617, 1617, 1733], [1977, 1977, 1995, 1995, 3161], [3163, 3232, 3277, 3277, 3500], [3505, 3505, 3523, 3523, 3615], [3617, 3617, 3713, 3713, 4698], [4700, 4700, 4741, 4741, 6680]], "test": "untested"}
{"id": "flt3Wj", "name": "Glacier", "author": "guil", "description": "Fork from https://t.co/CrlKX7VEmE?amp=1", "tags": ["ice"], "likes": 7, "viewed": 253, "published": 3, "date": "1636739389", "time_retrieved": "2024-07-30T18:48:42.936520", "image_code": "\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\n\n//Yonatan clouds/mountains combined field\nvec2 field(in vec3 p) {\n\t\n\tfloat s,e,f,o;\n\tvec3 n;n.y=1.;\n    e=p.y;\n\tfor(s=1.;s<8e2;s*=1.8)p.xz*=rot(s),n.xz*=rot(s),n+=cos(p*s)*.3,e+=(dot(sin(p.xz*s),vec2(.3)/s));\n\tn=-normalize(n);\n    f-=exp(-e*11.-6.)*dot(n.xz,vec2(1.8));\n    e-=n.y*n.y*.1;\n    e-=n.z*n.z*.1;\n    o-=exp(-e*11.-6.);\n    \n    return vec2(max(.2,1.+.4*f),1.+o);\n}\n\n\nvec3 raycast( in vec3 ro, vec3 rd )\n{\n    float t = 2.5;\n    float dt = .025;\n    vec3 col= vec3(0.);\n    for( int i=0; i<128; i++ )\n\t{                \n        vec2 v = field(ro+t*rd);  \n        float c=v.x, f=v.y;\n        t+=dt*f;\n        dt *= 1.015;\n        col = .95*col+ .08*vec3(c*c*c, .9*c*c, 1.2*c);\t\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    \n\n    // camera\n\n    vec3 ro = vec3(-4);\n    ro.y +=1.;\n    ro.yz*=rot(-.9);    \n    vec3 rd = normalize( vec3(p,2.)-ro);    \n    ro.z +=t*.4;\n\n\t// raymarch \n    \n    vec3 col = raycast(ro,rd);\n    \n\t\n\t// shade\n    \n    col =  .5 *(log(1.+col));\n    col = clamp(col,0.,1.);\n    fragColor = vec4( col, 1.0 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flt3Wj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 21, 21, 68], [71, 113, 136, 136, 447], [450, 450, 487, 487, 787], [790, 790, 847, 847, 1293]], "test": "untested"}
{"id": "7lc3W2", "name": "Persian carpet 20", "author": "jarble", "description": "These patterns resemble Persian carpets.", "tags": ["fractal", "carpet", "rug"], "likes": 2, "viewed": 228, "published": 3, "date": "1636730028", "time_retrieved": "2024-07-30T18:48:43.939837", "image_code": "//change this constant to get different patterns!\n#define c2 0.\n\n#define c1 vec4(3.+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 4.5/4.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime/2.+uv.x)/10.0);\n    vec3 random1 = (hash31(2.+t2)-.5)/8.;\n    vec3 random2 = (hash31(3.+t2)-.5)/8.;\n    vec3 random3 = (hash31(4.+t2))/8.;\n    vec3 random4 = (hash31(5.+t2))/8.;\n    \n    float offset = .5;\n    float scale2 = 1.5;\n    for(int c=0;c<3;c++){\n        for(int i=0;i<3;i++)\n        {\n            for(int k = 0; k < 3; k++){       \n                uv += vec2(random1[k],random2[k]);\n                uv /= -scale2;\n\n                uv = triangle_wave(uv-offset,scale2)*(1.+random3[k])+triangle_wave(uv.yx,scale2)*(1.+random4[k])-col.yx;\n                //uv = -triangle_wave(uv-offset,scale2)*(1.-random4[k])+triangle_wave(uv.yx,scale2)*(1.-random3[k])-col.yx;\n\n            }\n            //random1 *= scale2;\n            //random2 *= scale2;\n            col[c] = abs((uv.x)-(uv.y));\n            //col[c] = (uv.y-uv.x+col[c]);\n\n        }\n\t}\n    \n    //col /= 1.5;\n    fragColor = vec4(min(col,vec3(1.)),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lc3W2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[273, 383, 405, 451, 584], [586, 586, 625, 625, 670], [672, 672, 729, 729, 1975]], "test": "untested"}
{"id": "fldGzX", "name": "927487 ZEX", "author": "z0rg", "description": "Random idea", "tags": ["glass", "sex", "fov", "zex"], "likes": 22, "viewed": 539, "published": 3, "date": "1636715970", "time_retrieved": "2024-07-30T18:48:44.974072", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(0.,f*factor);\n        if (nuv.y > 0. && nuv.y < 1.)\n            col += texture(iChannel0, uv+vec2(0.,f*factor)).xyz/float(steps);\n    }\n    \n    vec3 rgb = texture(iChannel1, uv).xyz+GLOW_OPACITY*pow(col, vec3(GLOW_POW));\n\n    fragColor = vec4(rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define GLOW_SAMPLES 40\n#define GLOW_DISTANCE 0.05\n#define GLOW_POW 1.25\n#define GLOW_OPACITY 1.5\n#define sat(a) clamp(a, 0., 1.)\n\n// Stolen from 0b5vr here https://www.shadertoy.com/view/ss3SD8\nfloat hash11(float p)\n{\n    return (fract(sin((p)*114.514)*1919.810));\n}\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x, max(l.y, l.z));\n}\n// Thanks IQ\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n// Thanks IQ\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}", "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat seed;\nfloat rand()\n{\n    seed++;\n    return hash11(seed);\n}\n\n#define METAL_MAT 0.\n#define GLASS_MAT 1.\n#define STAND_GLASS_MAT 2.\n#define BRACKET_MAT 3.\n#define TABLE_MAT 4.\n#define WALL_MAT 5.\n\nvec2 map(vec3 p, float ignoreMat)\n{\n    vec2 acc = vec2(10000.,-1.);\n    \n    \n    acc = _min(acc, vec2(_cube(p-vec3(0.,-0.02,0.), vec3(5.,1.,13.)), TABLE_MAT));\n    //acc = _min(acc, vec2(_cube(p-vec3(-5.,0.,0.), vec3(1.,5.,1.)), WALL_MAT));\n    acc = _min(acc, vec2(_cube(p-vec3(-5.,-2.,-3.), vec3(1.,1.,1.)), -1.));\n    acc = _min(acc, vec2(_cube(p-vec3(-5.,-2.,-5.), vec3(1.,1.,2.)), WALL_MAT));\n \n    p.y -= -1.55;\n    vec3 opg = p;\n    p.x = abs(p.x)-.7;\n    float glass = max(length(p.xy)-.5, abs(p.z)-.01);\n    if (ignoreMat != GLASS_MAT)\n        acc = _min(acc, vec2(glass, GLASS_MAT));\n    \n    float glassborder = sdTorus(p, vec2(.5,.02));\n    acc = _min(acc, vec2(glassborder, METAL_MAT));\n    \n    vec3 pstand = p-vec3(-.5,0.07,0.);\n    float stand = max(max(length(pstand.xy)-.02,-p.z),p.z-.1);\n    acc = _min(acc, vec2(stand, METAL_MAT));\n    \n    pstand.z += -.1;\n    pstand.x += .04;\n    pstand.xy *= r2d(.2);\n    float standplate = max(length(pstand.yz*vec2(1.,2.))-.1, abs(pstand.x)-.002);\n    if (ignoreMat != STAND_GLASS_MAT)\n        acc = _min(acc, vec2(standplate, STAND_GLASS_MAT));\n    \n    float link = max(max(sdTorus(opg-vec3(0.,.3,0.), vec2(.5,.02)), abs(opg.x)-.2),opg.y);\n    acc = _min(acc, vec2(link, METAL_MAT));\n    \n    p.z -= .08;\n    p.x -= .57;\n    float bracket = max(sdRoundBox(p, vec3(.05,.02,.1), .01),\n    -sdRoundBox(p-vec3(-0.07,0.,.02), vec3(.1,1.,.1), .01));\n    bracket = min(bracket, sdRoundBox(p-vec3(0.04,0.,1.), vec3(.001,0.001,1.), .01));\n    acc = _min(acc, vec2(bracket, METAL_MAT));\n    \n    p.z -= .9;\n    p.yz *= r2d(.5*pow(abs(p.z)*.4, 5.));\n    float backbracket = sdRoundBox(p-vec3(0.05,.0,1.5), vec3(.01,0.02,.7), .01);\n    \n    acc = _min(acc, vec2(backbracket, BRACKET_MAT));\n    \n    return acc;\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+(r*uv.x+u*uv.y)*3.);\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.001,0.);\n    return normalize(vec3(d)-vec3(\n    map(p-e.xyy, -1.).x,\n    map(p-e.yxy, -1.).x,\n    map(p-e.yyx, -1.).x));\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps, float ignoreMat)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec2 res = map(p, ignoreMat);\n        if (res.x < 0.001)\n            return vec3(res.x, distance(p, ro), res.y);\n        p+=rd*res.x*.7;\n    }\n    return vec3(-1.);\n}\n\nvec3 getEnv(vec3 rd)\n{\n    rd.xz *= r2d(2.5);\n    float env = texture(iChannel1, rd*vec3(1.,-1.,1.)).x;\n    return (.25*vec3(pow(env, 3.))+5.*pow(env, 15.)*vec3(1.000,0.078,0.310).yzx)*.7;\n}\n\nfloat getLetter(vec2 uv, float idx)\n{\n    vec2 sz = vec2(1.)/vec2(16.,16.);\n    vec2 coords = (uv-vec2(-.5,-.2))*vec2(1.,-1.4)*.5-vec2(-.04,-0.02);\n    coords *= .6;\n    coords = clamp(coords, vec2(0.), sz);\n    coords -= sz+vec2(sz.x*mod(idx, 16.), sz.y*float(int(idx)/16));\n    return texture(iChannel3, coords).x;\n    return sat((length(coords)-.1)*400.);\n}\n\nvec3 getMat(vec3 res, vec3 rd, vec3 p, vec3 n)\n{\n    vec3 col = n*.5+.5;\n    vec3 lpos = vec3(0.,5.,5.);\n    vec3 ldir = p-lpos;\n    vec3 h = normalize(rd+ldir);\n    if (res.z == TABLE_MAT)\n    {\n        col = vec3(.1);\n    }\n    if (res.z == GLASS_MAT)\n    {\n        col = vec3(0.459,0.082,0.176)*.2;\n    }\n    if (res.z == METAL_MAT)\n    {\n        vec3 refl = normalize(reflect(rd, n));\n        vec3 envrefl = getEnv(refl).x*vec3(0.992,0.847,0.647);\n        col = pow(envrefl, vec3(1.)) + 1.*pow(envrefl, vec3(2.5));\n        col *= 1.5+sat(.3+(pow(sat(-dot(n, fwidth(n))),.01))); // To reduce aliasing on reflect\n    }\n    if (res.z == BRACKET_MAT)\n    {\n        col = vec3(.05)+vec3(0.941,0.580,0.580)*pow(sat(dot(n, h)),2.);\n    }\n    if (res.z == WALL_MAT)\n    {\n        vec2 letteruv = p.zy*.1-vec2(-.15,0.05);\n        float letters = getLetter(letteruv, 92.);\n        letters += getLetter(letteruv+vec2(-0.1,0.), 74.);\n        letters += getLetter(letteruv+vec2(-0.2,0.), 87.);\n        float beat = 1./2.;\n        col = mix(.15,1.,mod(iTime, beat)/beat)*vec3(1.000,0.059,0.294)*pow(letters,.2)+vec3(1.)*letters*.5;\n    }\n    return col;\n}\n\nvec3 rdr(vec2 uv, float doffactor)\n{\n    vec3 col = vec3(0.);\n    \n    vec3 dof = vec3(rand()-.5, rand()-.5, 0.)*.00001*doffactor;\n    vec3 ro = vec3(1.7+.25*sin(iTime*.15),-1.19,-1.)+dof;\n    vec3 ta = vec3(-1.,-2.4,1.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv)-dof;\n    \n    vec3 res = trace(ro, rd, 256, -1.);\n    if (res.y > 0.)\n    {\n        vec3 p = ro + rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = n*.5+.5;\n        col = getMat(res, rd, p, n);\n        \n        if (res.z == TABLE_MAT || res.z == GLASS_MAT)\n        {\n            float spec = mix(.03, 0.1, pow(texture(iChannel0, p.xz*.05).x,2.));\n            if (res.z == GLASS_MAT)\n                spec = 0.01;\n            vec3 specrefl = normalize(reflect(rd, n)+(vec3(rand(), rand(), rand())-.5)*2.*spec);\n            vec3 resrefl = trace(p+n*.01, specrefl, 128, -1.);\n            if (resrefl.y > 0.)\n            {\n                vec3 prefl = p+specrefl*resrefl.y;\n                vec3 nrefl = getNorm(prefl, resrefl.x);\n                col = getMat(resrefl, specrefl, prefl, nrefl);\n            }\n            else\n                col = getEnv(specrefl);\n        }\n    }\n    else\n        col = getEnv(rd)*.75;\n    col *=( 1.-sat(length(uv)*1.75-.2));\n    col = pow(col, vec3(.6));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    seed=texture(iChannel0,uv).x;\n    seed+=fract(iTime);\n    \n    vec3 col = rdr(uv,1.);\n    col = sat(col);\n\n    col = mix(col, texture(iChannel2, fragCoord.xy/iResolution.xy).xyz, .95);\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(f*factor, 0.);\n        if (nuv.x > 0. && nuv.x < 1.)\n          col += texture(iChannel0, uv+vec2(f*factor,0.)).xyz/float(steps);\n    }\n    \n    vec3 rgb = texture(iChannel1, uv).xyz+2.*pow(col, vec3(GLOW_POW));\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fldGzX.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 988]], "test": "untested"}
{"id": "ftc3D2", "name": "radioctive space balls", "author": "lomateron", "description": "follow a ball through it's life\nsander > clouder > traveler > spiner > puker > exploder", "tags": ["convolution"], "likes": 40, "viewed": 604, "published": 3, "date": "1636707964", "time_retrieved": "2024-07-30T18:48:45.775928", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = fragCoord/iResolution.xy;\n    vec4 a = texture(iChannel0,u);\n         //a = abs(a);\n         a.z = pow(a.z,.15);\n    fragColor = sin(a.z*5.+vec4(1,2,3,4))*.5+.5;\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4  r = vec4(0);\n    vec4  a = A(u);\n    float z    = 10.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        float l = length(vec2(i,j));\n        if((i==0.&&j==0.)|| l>z+.1){continue;}\n        vec2  c = normalize(vec2(i,j));\n        vec4  a2= A(u+vec2(i,j));\n        vec4  b = a2-a; \n        r.xy += c*b.z*cos(l*.66)*exp(-l*l*.06)*.1;\n        //r.z  += dot(c,b.xy   2        );//*a2.z;\n        //r.w  += dot(c,b.yx*vec2(-1,1));//*a2.z;\n    }}\n    fragColor = r;\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\n#define C(u) texture(iChannel2,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4 t = A(u);\n    vec2 m = +t.xy\n             +B(u).xy;\n    float s = 0.;\n    float z    = 6.;//kernel convolution size\n    float blur = 8./z;\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        //if(length(vec2(i,j))>z+.1){continue;}\n        vec2 c = (m+vec2(i,j))*blur;\n        s += exp(-dot(c,c));\n    }}\n    if(s==0.){s = 1.;}\n    s = 1./s;\n    \n    fragColor = vec4(m,s,0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    float tz = 0.;\n    vec4 a = vec4(0);\n    float z    = 6.;//kernel convolution size\n    float blur = 8./z;\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        //if(length(vec2(i,j))>z+.1){continue;}\n        vec4 t = A(u+vec2(i,j));\n        vec4 m = B(u+vec2(i,j));\n        vec2 c = (m.xy-vec2(i,j))*blur;\n        float z = t.z*exp(-dot(c,c));\n        a.xy += z*m.xy;\n        a.z  += z*m.z;\n        tz   += z;\n    }}\n    if(tz==0.){tz = 1.;}\n    a.xy /= tz;\n    //a = A(u);\n    if(iMouse.z>0.)\n    {\n        vec2 m = 32.*(u-iMouse.xy)/iResolution.y;\n        a += vec4(-1,0,0,0)*.1*exp(-dot(m,m));\n    }\n    if(iFrame==0)\n    {\n        vec2 m;\n        m = 16.*(u-iResolution.xy*.5)/iResolution.y;\n        a+= vec4(0,0,1,0)*16.*exp(-dot(m,m));\n    }\n    fragColor = a;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftc3D2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 234]], "test": "untested"}
{"id": "st3GWS", "name": "mountain fly", "author": "rockhard", "description": "render a terrain with water is impossible for 2 fps!\nwanna shadow? my toy will born..I give it up.", "tags": ["terrain"], "likes": 10, "viewed": 381, "published": 3, "date": "1636696958", "time_retrieved": "2024-07-30T18:48:46.538889", "image_code": "//the height value is negative.so flip it over..\nfloat reheight(float py){\n   return 0.85-(55.0-py)/65.0;\n  }\n\nfloat map(vec2 x){\n\tvec2  p = x*0.02;\n    float a =fbm(x)*0.015; \n    float b = 1.0;\n    for(int i=0; i<5;i++) {\n        float n =noise3D(vec3(p.x,1.0,p.y)); \n        a += b*n;\n\t\tb *= 0.5;\n        p = m2(p)*2.0;\n    } \n   \n    a=(1.0-smoothstep(-0.1,1.0,a))*65.0;\n    float h=reheight(a);\n    a+=texture(iChannel0,x*0.5).x*h*5.0;\n    return a;\n}\nfloat Far =350.0;\nfloat raycast( vec3 ro, vec3 rd)\n{ \n    float t = 0.1;\n\tfor(int i=0; i<64; i++){\n        vec3 pos = ro + t*rd;\n\t\tfloat h =pos.y - map(pos.xz);         \n\t\tif(abs(h)<0.001*t) return t;\n        if(t>Far)return Far;\n\t\tt += h*0.5;         \n\t}\n\treturn t;\n}\n\nvec3 normal(vec3 p,float t){ vec2 e = vec2(0.002*t, 0.0);   \n\t  \n    return normalize(vec3(map(p.xz - e) - map(p.xz + e),\n                          2.0 * e.x,\n                          map(p.xz - e.yx) - map(p.xz + e.yx)));\n}\n\nvec3 hcolor(float h){\n  \n   vec3 col =vec3(0.375);\n      \n   col -= vec3(0.4-h,0.35,0.5)*smoothstep(0.2,0.9,1.0-h)\n       *(1.0-smoothstep(1.0,6.0,(h*h+0.9)));\n   \n   col=mix(vec3(0.16,0.1,0.06),col,smoothstep(-0.01,0.05,h));\n   return col;\n}\n\nvec3 color(vec3 ro,vec3 rd,vec3 p,vec3 n){   \n   float h=reheight(p.y);\n   vec3 col=hcolor(h);\n  \n   float wat=smoothstep(-0.001,0.01,h);\n   vec3 water=vec3(0.0,0.25,0.5);\n   \n   if(wat>0.0){\n     // Far=80.0;\n      //vec3 ref=normalize(vec3(rd.x+n.z,-rd.y,rd.z+n.x));\n      float t=0.0;// raycast(p,ref);\n      if(t<Far){\n       // float hw=p.y+ref.y*t;\n        //hw=reheight(hw);\n        float fres=1.0-dot(-rd,n);\n        fres*=fres;\n        water=vec3(0.0,0.1,fres*0.35); //hcolor(hw);\n      }\n     //Far=350.0;\n   }\n   \n   col=mix(water,col,wat);\n  \n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord/iResolution.xy-0.5;\n       float vig=(1.0-uv.x*uv.x)*(1.0-uv.y*uv.y);\n    uv.x/=iResolution.x/iResolution.y;\n\n    mat3 camrot=rotXY(0.15,iTime*0.05+0.8);\n    vec3 ro=camrot[2]*5.0;\n    ro.y+=35.5;    \n    vec3 rd=getdir(uv,camrot);\n    ro.xz+=normalize(vec2(-rd.z,rd.x))*iTime;\n \n    float t=raycast(ro,rd);\n\n    vec3 light = normalize(vec3(-0.8,0.3,-0.3));\n    vec3 sun=max(0.0, dot(rd,light))*vec3(0.4,0.3,0.2);\n    vec3 sky=mix(vec3(0.25,0.2,0.1),vec3(0.0,0.3,0.75),rd.y)+sun;\n    //vec3 sky=vec3(0.3,0.7,0.9);\n    vec3 col =vec3(0.0);\n    \n    if(t<Far){\n    vec3 p=ro+rd*t;\n    vec3 n=normal(p,t);\n    //vec3 n= normalize(cross(dFdx(p), dFdy(p)));\n    float d2n=dot(light,n)*0.5+0.6;\n     col=color(ro,rd,p,n);\n     col*=d2n; \n     col=mix(col,sky,t/Far);     \n    }\n    else col=sky;\n    \n    //col=vec3(t/FAR);\n    fragColor = vec4(pow(col,vec3(0.65))*1.5*vig,1.0);\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "mat3 rotXY(float rX, float rY){\n float cx = cos(rX),sx = sin(rX),cy = cos(rY),sy=sin(rY);\n return mat3(-sy, 0, -cy, -sx * cy, cx, sx * sy,cx * cy, sx, -cx * sy);\n}\nvec3 getdir(vec2 p,mat3 m){\n  return normalize(vec3(p.x * m[0].x + p.y * m[1].x - m[2].x, \n       p.x * m[0].y + p.y * m[1].y - m[2].y, \n       p.x * m[0].z + p.y * m[1].z - m[2].z));\n}\nfloat distsq(vec2 a,vec2 b){\n  float dx=a.x-b.x,dy=a.y-b.y; return float(dx*dx+dy*dy);\n} \n\nvec2 m2(vec2 p){  return vec2(p.x*0.8+p.y*0.6,p.y*0.8-p.x*0.6); } \n\nfloat noise3D(vec3 p){ \n   vec3 s = vec3(7, 157, 113);\n   vec3 ip = floor(p);  \n   vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    p -= ip;  \n    p = p*p*(3.0 - 2.0*p); //p *= p*p*(p*(p*6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43.5453),fract(sin(h + s.x)*43.5453),p.x); \n    h.xy = mix(h.xz,h.yw,p.y); \n    return mix(h.x, h.y, p.z);\t\n}\n\nfloat rand(vec2 p){\n    p  = fract(p / vec2(2.16632,.17369)); p += dot(p.xy, p.yx+9.19);\n    return fract(p.x * p.y);\n}\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 n){\n    float sum = 0.0;\n    float amp= 1.0;\n    for (int i = 0; i <2; i++){\n        sum += noise(n) * amp;\n        n += n*3.0;\n        amp *= 0.25;\n    }\n    return sum;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st3GWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 49, 74, 74, 109], [111, 111, 129, 129, 456], [475, 475, 509, 509, 725], [727, 727, 755, 755, 952], [954, 954, 975, 975, 1196], [1198, 1198, 1240, 1240, 1769], [1771, 1771, 1828, 1828, 2730]], "test": "untested"}
{"id": "Nl3GW2", "name": "Persian carpet 19", "author": "jarble", "description": "These patterns resemble Persian carpets.", "tags": ["fractal", "carpet", "rug"], "likes": 2, "viewed": 228, "published": 3, "date": "1636693223", "time_retrieved": "2024-07-30T18:48:47.417539", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 4.5/4.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime/2.+uv.x)/10.0);\n    vec3 random1 = (hash31(2.+t2)-.5)/8.;\n    vec3 random2 = (hash31(3.+t2)-.5)/8.;\n    //vec3 random3 = (hash31(4.+t2))/4.*0.;\n    //vec3 random4 = (hash31(5.+t2))/4.*0.;\n    \n    float offset = .5;\n    float scale2 = 1.5;\n    for(int c=0;c<3;c++){\n        for(int i=0;i<3;i++)\n        {\n            for(int k = 0; k < 3; k++){       \n                uv /= -scale2;\n                uv = -triangle_wave(uv-offset,scale2)+triangle_wave(uv.yx,scale2)-col.yx;\n                uv += vec2(random1[k],random2[k]);\n                //uv = -triangle_wave(uv-offset,scale2)*(1.-random4[k])+triangle_wave(uv.yx,scale2)*(1.-random3[k])-col.yx;\n\n            }\n            col[c] = abs((uv.x)-(uv.y))/scale2;\n        }\n\t}\n    \n    //col /= 1.5;\n    fragColor = vec4(col,1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl3GW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [590, 590, 629, 629, 674], [676, 676, 733, 733, 1840]], "test": "untested"}
{"id": "sl3GWS", "name": "Fbm: Onslaught", "author": "Yusef28", "description": "An fbm noise texture. I originally made this using F.lux and had a beautiful red and green pattern but I had to adjust the lighting and I have a red and blue but it's not the same ", "tags": ["2d", "noise", "fbm", "color", "calamity", "vibrant"], "likes": 30, "viewed": 517, "published": 3, "date": "1636692993", "time_retrieved": "2024-07-30T18:48:48.365006", "image_code": "\n#define pi acos(-1.)\n#define eps 1./iResolution.y\n\n\nfloat noise(vec2 st){\n    return fract(sin(dot(vec2(12.23,74.343),st))*4254.);  \n}\n\n\nfloat noise2D(vec2 st){\n  \n  //id,fract\n  vec2 id =floor(st);\n  vec2 f = fract(st);\n  \n  //nachbarn\n  float a = noise(id);\n  float b = noise(id + vec2(1.,0.));\n  float c = noise(id + vec2(0.,1.));\n  float d = noise(id + vec2(1.));\n  \n  \n  //f\n  f = smoothstep(0.,1.,f);\n  \n  //mix\n  float ab = mix(a,b,f.x);\n  float cd = mix(c,d,f.x);\n  return mix(ab,cd,f.y);\n}\n\nmat2 rot45 = mat2(0.707,-0.707,0.707,0.707);\n\nmat2 rot(float a){\n  float s = sin(a); float c = cos(a);\n  return mat2(c,-s,s,c);\n}\nfloat fbm(vec2 st, float N, float rt){\n    st*=3.;\n \n  float s = .5;\n  float ret = 0.;\n  for(float i = 0.; i < N; i++){\n     \n      ret += noise2D(st)*s; st *= 2.9; s/=2.; st *= rot((pi*(i+1.)/N)+rt*8.);\n      //st.x += iTime;\n  }\n  return ret;\n  \n}\n\nfloat voronoi(vec2 uv){\n  \n    float d = 100.;\n    vec2 uvFL = floor(uv);\n    vec2 uvFR = fract(uv);\n  \n    for(float i = -1.; i <= 1.; i++){\n      for(float j = -1.; j <= 1.; j++){\n        \n        vec2 nachbar = vec2(i,j);\n        \n        d = min(d, length( uvFR - noise(uvFL + nachbar)  - nachbar));\n      }\n    }\n    return d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n  \n  uv.x+=iTime*0.4+10.;\n  vec3 col = vec3(0.0);\n  \n  float fa1 = smoothstep(0.2, 0.9,\n              abs( fract(fbm(uv + length(uv)*0.5,5., 2.)*2.)-0.5) );\n  \n  \n  float fb1 = fbm(uv*2. + vec2(3. ,3. ) ,5., 5.);\n  \n  \n\n // float fa2 = fbm(uv*2.*rot(2.) - vec2(8. ) + fa1 ,2., 3.);\n  \n  //float fa2fr = smoothstep(0.2, 0.5,\n  //            abs( fract(fa2*10.)-0.5) );\n  \n  float fb2 = fbm(uv*3.+ fa1/5. ,4., 3.);\n  \n  //float fb2fr = smoothstep(0., 0.9,\n  //            abs( fract(fb2*2.)-0.5) );\n \n // float fa3 = fbm(uv+ fa2 ,5., 1.);\n   //float fb3 = fbm(uv*1.*rot(1.8) + vec2(1. ,47. ) + fb2 , 3., 2.);\n  \n  //softer version\n   float fb3 = fbm(uv*1.*rot(1.7) + vec2(1. ,47. ) + fb2*.5 , 3., 2.);\n   \n   \n   float fb3b = fbm(uv*2. + fb1*2. + vec2(sin(uv.x/4.),0.), 2., 2.);\n    float fb3c = fbm(uv + fb1*2. + vec2(3.), 4., 2.);\n\n    col = mix(col, vec3(0.,1.,1.),pow(fb3*1.1, 5.));\n    \n    col = mix(col, vec3(atan(vec2(uv.x,uv.y+0.4))*.8, 0.), pow(fb3,1.6));\n    //col = mix(col, vec3(0.,sin(uv.y),0.9), pow(fb2, 15.));\n    col = mix(col, vec3(0.,0.,0.),fa1*.9);    \n    col *= 1.5;\n    \n    //col = mix(col, vec3(.4,0.9,0.9),pow(fb2,9.));\n    //col = pow(col*vec3(0.9,0.99,0.9), vec3(1.));\n\n   \n   /*\n    col = mix(col, vec3(0.9,sin(vec2(uv.yy))), pow(fb3, 3.))*2.3;\n    \n    col = mix(col, vec3(0.8,sin(uv.y),.0), pow(fb2, 8.)*4.)*1.2;\n    \n    col = mix(col, vec3(0.,0.,0.),fa1*0.99);\n    //col = mix(col, vec3(1.),fa2*0.1);\n    \n    //col = mix(col, vec3(0.),voronoi(uv*2.));\n    //\n    col = mix(col, vec3(.9,0.9,0.9),pow(fb2,4.))*1.3;\n   \n   */\n   \n   \n    col = sin(vec3(1.,2.,9.)/80. + col + 6.1);\n    //col = mix(vec3(1.,0.,0.), vec3(1.), clamp(col*3.,0.,1.));\n    col = mix(col, vec3(.0,0.0,0.2),voronoi(uv*3.))*1.;\n    float dasBit = pow(dot(normalize(vec3(1.)),normalize(vec3(uv,1.))),9.);\n    col = mix(col, vec3(.9,0.9,0.9),pow(fb2,5.))*1.3 +dasBit;  \n    \n    //col = mix(col, vec3(.9, .0 ,1.), );\n    \n    col = mix(col, vec3(4.3), pow(fb3b, 4.) );\n    col = mix(col, vec3(2.,6.,9.)*.1, pow(fb3c, 4.) );\n    //col = mix(col, vec3(0.9,0.4,0.)*1., pow(fb3, 7.) );\n    \n    //when I use Flux it's this: \n    //fragColor = vec4(col*vec3(0.9,0.8,.4),1.0); //lol\n    //but that is actually only there because I forgot flux the first time lol\n    col *= 1.4;\n    //col =pow(col,vec3(1.,0.9, 1.));\n    fragColor = vec4(col*vec3(0.8,0.65,.2),1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl3GWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 74, 74, 135], [138, 138, 161, 177, 499], [547, 547, 565, 565, 630], [631, 631, 669, 669, 880], [882, 882, 905, 905, 1215], [1216, 1216, 1273, 1273, 3699]], "test": "untested"}
{"id": "flc3Wj", "name": "Unknown man you", "author": "jorge2017a2", "description": "Unknown man you", "tags": ["unknownmanyou"], "likes": 3, "viewed": 191, "published": 3, "date": "1636687150", "time_retrieved": "2024-07-30T18:48:49.557816", "image_code": "//Unknown man you\n///------------image\n//por jorge2017a2-\n//https://iquilezles.org/articles/distfunctions\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdTorus( vec3 p, vec2 t )\n\t{ vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n\nvec3 opTwistCapsule(in vec3 p )\n{\n    const float k = 0.125; // or some other amount\n    float c = 0.5*cos(k*p.y);\n    float s = 0.5*sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    p= rotate_y( p,radians(-iTime*30.0));\n    vec3 p0=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    \n    res =opU3(res, vec3(planeDist1,-1.0,7.0)); //inf\n    p.y-=10.0;\n    \n    float ang=20.0*clamp(sin(iTime*0.5),0.0,1.0);\n    p= rotate_x( p,radians(ang));\n    vec3 p1= rotate_y( p,radians(12.0));\n    vec3 p2= rotate_y( p,radians(-12.0));\n    p1= opTwistCapsule(vec3(-p1.z,p1.y,p1.x));\n    p2= opTwistCapsule(vec3(-p2.z,p2.y,p2.x));\n        \n    float dvc1= sdVerticalCapsule( p1-vec3(0.0,2.0,-3.0),10.0, 1.0 );\n    float dvc2= sdVerticalCapsule( p2-vec3(0.0,2.0,3.0),10.0, 1.0 );\n    \n    p=p0;\n    float sdCasco=sdEllipsoid(p-vec3(0.0,9.0,0.0), vec3(4.0,5.0,4.0) );\n    float sdCabeza2=sdEllipsoid(p-vec3(0.0,9.0,0.0), vec3(3.5,4.0,4.0) );\n    float dbx1= sdBox( p- vec3(0.0,5.0,-3.0), vec3(5.0,5.0,2.5)  );\n    sdCasco= differenceSDF(sdCasco, dbx1);\n    \n    //ojos\n    p.x=abs(p.x)-1.5;\n    float dOjo1=sdCylinderXY(p-vec3(0.0,8.0,0.0), vec2(0.5,5.0)  );\n    float dOjo2=sdCylinderXY(p-vec3(0.0,8.0,0.0), vec2(0.7,5.0)  );\n    \n    dOjo1=intersectSDF(dOjo1,sdCabeza2);\n    dOjo2=intersectSDF(dOjo2,sdCabeza2);\n    \n    p=p0;\n    float dboca1= sdBox(p- vec3(0.0,6.5,0.0), vec3(1.0,0.2,5.0)  );\n    float dboca2= sdBox(p- vec3(0.0,6.5,0.0), vec3(1.2,0.5,5.0)  );\n    dboca1=intersectSDF(dboca1,sdCabeza2);\n    dboca2=intersectSDF(dboca2,sdCabeza2);\n    \n    //cuello\n    float dcuello= sdCylinderXZ( p-vec3(0.0,2.0,0.0), vec2(1.5,4.0)  );\n    //anillos\n    float dAnillo1= sdTorus( p-vec3(0.0,4.0,0.0), vec2(1.5,0.25) );\n    float dAnillo2= sdTorus( p-vec3(0.0,1.0,0.0), vec2(1.5,0.25) );\n    \n    res =opU3(res, vec3(dvc1,2.0,-1.0));\n    res =opU3(res, vec3(dvc2,2.0,-1.0));\n    res =opU3(res, vec3(sdCasco,1.0,-1.0));\n    res =opU3(res, vec3(sdCabeza2,30.0,-1.0));\n    res =opU3(res, vec3(dOjo2,1.0,-1.0));\n    res =opU3(res, vec3(dOjo1,0.0,-1.0));\n    \n    res =opU3(res, vec3(dboca2,1.0,-1.0));\n    res =opU3(res, vec3(dboca1,2.0,-1.0));\n    \n    res =opU3(res, vec3(dcuello,30.0,-1.0));\n    res =opU3(res, vec3(dAnillo1,4.0,-1.0));\n    res =opU3(res, vec3(dAnillo2,4.0,-1.0));\n    \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 nor = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    nor= normalize(nor);\n    return nor;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n        {mObj.hitbln = true; minDist = abs(t); break;}\n        \n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        \n        t += dS.x;\n        marchCount++;\n    }\n    \n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{   vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    \n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true)\n        {fshadow=GetShadow(p,lp);}\n    else\n        {fshadow=0.5;}\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    lin += 0.4*pow(clamp(dot(hal,n),0.0,1.0),12.0)*dif3;\n    lin *= atten*0.5*col*fshadow;\n    //lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    lin *= max(normalize(vec3(length(lin))).z, 0.);\n    lin = pow(lin,vec3(0.4545));\n \n    return lin;\n    //return lin*atten*(1.0/2.0);\n    \n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n///-------------------------------------\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .2)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n  \n  if (id_material==7.0)\n    {return pattern( p.xz );}\n    \n    if (id_material==8.0)\n    {return pattern( p.xy );}\n    \n    if (id_material==9.0)\n    {return pattern( p.zy );}\n    \n}\n\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n   float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n    \n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 10.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 30.0, -10.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(0.0,7.0,-20.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    \n    col= exposureToneMapping(1.9, col);\n    col = linear2srgb(col);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "//--------------common\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flc3Wj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[567, 567, 599, 599, 683], [684, 684, 718, 718, 780], [781, 781, 820, 820, 915], [916, 916, 955, 955, 1050], [1051, 1051, 1090, 1090, 1185], [1187, 1231, 1278, 1278, 1305], [1306, 1306, 1349, 1349, 1376], [1377, 1377, 1425, 1425, 1453], [1454, 1519, 1553, 1553, 1649], [1650, 1650, 1684, 1684, 1775], [1776, 1776, 1810, 1810, 1901], [1903, 1903, 1956, 1956, 2014], [2017, 2017, 2050, 2050, 2239], [2242, 2242, 2279, 2279, 2362], [2364, 2404, 2429, 2429, 4618], [4621, 4621, 4645, 4645, 4825], [4827, 4827, 4876, 4876, 5526], [5528, 5582, 5618, 5618, 5863], [5864, 5919, 5946, 5946, 5963], [5965, 5965, 6001, 6001, 6093], [6094, 6094, 6140, 6140, 6265], [6267, 6267, 6341, 6341, 7999], [8001, 8001, 8081, 8081, 8204], [8247, 8247, 8279, 8279, 8476], [8478, 8526, 8554, 8554, 8742], [8744, 8795, 8842, 8842, 9072], [9074, 9126, 9219, 9219, 9560], [9563, 9563, 9594, 9594, 10188], [10190, 10239, 10265, 10265, 10375], [10377, 10377, 10435, 10435, 10487], [10489, 10538, 10595, 10595, 11181]], "test": "untested"}
{"id": "ftc3Wj", "name": "Inflatey Bubble", "author": "SnoopethDuckDuck", "description": "e", "tags": ["e"], "likes": 15, "viewed": 252, "published": 3, "date": "1636686405", "time_retrieved": "2024-07-30T18:48:50.420510", "image_code": "float thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}    \n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    \n    float sc = 96. + 32. * thc(12., iTime);\n    vec2 ipos = floor(sc * uv) + 0.5;\n    vec2 fpos = fract(sc * uv) - 0.5;\n\n    float a = atan(ipos.y, ipos.x);\n    float r = length(ipos)/sc;\n    r *= .5 * (1. + thc(4., 4. * r));\n    float str = 3. + 5. * cos(3. * a + iTime);\n    ipos = r * vec2(thc(str, a), ths(str, a));\n\n    float d = length(ipos);\n    float cr = 0.26 + 0.1 * thc(4., iTime) + 0.02 * ths(3., iTime);\n    float s = step(cr - 4./sc, d) - step(cr, d);\n    s *= step(length(fpos), 0.5);\n    fragColor = vec4(s);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftc3Wj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 70], [76, 76, 105, 105, 146], [149, 149, 206, 206, 802]], "test": "untested"}
{"id": "ft33Wj", "name": "spiralllll", "author": "SnoopethDuckDuck", "description": "i dont know what this is", "tags": ["e"], "likes": 5, "viewed": 233, "published": 3, "date": "1636684570", "time_retrieved": "2024-07-30T18:48:51.179480", "image_code": "float thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy )/iResolution.y;\n    \n    float a = atan(uv.y, uv.x);\n    float r = length(uv) + 0.1 * thc(4., 50. * length(uv) + \n    \n    thc(8., thc(2., 16. * length(uv) + 3. * a - iTime) + 4. * a + iTime) - iTime);\n    uv = r * vec2(cos(a), sin(a));\n    \n    float sc = 120.;\n    vec2 ipos = floor(sc * uv) + 0.5;\n    vec2 fpos = fract(sc * uv) - 0.5;\n    \n    float d = length(ipos / sc) + 0.4 * length(fpos);\n    float s = smoothstep(-0., \n    0.1 + 2.4 * thc(4., 5. * d * cos(iTime) + 13. * a  + 5. * iTime), \n    0.3 + 0.1 * thc(2., r * cos(100. * r) + iTime) - d);\n    \n    float s2 = smoothstep(-0., \n    0.1 + 2.4 * thc(4., 5. * d * cos(iTime) + 5. * a + 4. * iTime), \n    0.3 + 0.1 * thc(2., r * cos(100. * r) + iTime) - d);\n    \n    s = max(s,s2);\n    s = 6. * s/cosh(s + 3. * cos(2. * d+  iTime));\n    //vec3 col = vec3(s);\n    vec3 col = 1.5 * lerpCol(.5 + .5 * thc(2., d/s + iTime), s);\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.1415\n#define val 1.\n\nvec3 midCol(float t) {\n    float colTime = fract(val * t);\n    vec3 col;\n    if (colTime < 1./3.)\n        col = vec3(0., 220., 244.) / 255.;\n    else if (colTime < 2./3.)\n        col = vec3(245., 208., 0.) / 255.;\n    else\n        col = vec3(219., 0., 255.) / 255.;\n    return col;\n}\n\nvec3 darkCol(float t) {\n    float colTime = fract(val * t);\n    vec3 col;\n    if (colTime < 1./3.)\n        col = vec3(0., 172., 246.) / 255.;\n    else if (colTime < 2./3.)\n        col = vec3(236., 182., 0.) / 255.;\n    else\n        col = vec3(172., 0., 255.) / 255.;\n    return col;\n\n}\n\nvec3 lightCol(float t) {\n    float colTime = fract(val * t);\n    vec3 col;\n    if (colTime < 1./3.)\n        col = vec3(0., 255., 195.) / 255.;\n    else if (colTime < 2./3.)\n        col = vec3(238., 243., 0.) / 255.;\n    else\n        col = vec3(255., 58., 235.) / 255.;\n    return col;\n}\n\nvec3 lerpCol(float t, float l) {\n    vec3 col;\n    // assuming 0 <= l <= 1\n    if (l < 1./3.) \n        col = mix(vec3(28, 28, 51) / 255., darkCol(t), vec3(3. * l));\n    else if (l < 2./3.)\n        col = mix(darkCol(t), midCol(t), vec3(3. * l - 1.));\n    else\n        col = mix(midCol(t), lightCol(t), vec3(3. * l - 2.));\n    \n    return col;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft33Wj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 70], [72, 72, 129, 179, 1181]], "test": "untested"}
{"id": "7lt3DB", "name": "Alignment test pattern", "author": "eszdman", "description": "Test pattern for MFNR, multi frame noise reduction in camera.", "tags": ["artifacts"], "likes": 3, "viewed": 205, "published": 3, "date": "1636675548", "time_retrieved": "2024-07-30T18:48:52.102014", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    float col = 0.5 + \n    0.2*cos(1.5*iTime+fragCoord.x*0.02)+ \n    0.2*cos(6.0*iTime+fragCoord.x*0.01)*cos(6.0*iTime+fragCoord.y*0.01);\n\n    // Output to screen\n    fragColor.rgb = vec3(col);\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lt3DB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 399]], "test": "untested"}
{"id": "Ntt3DS", "name": "Features from Curvature", "author": "paniq", "description": "2D prototype for finding dual contouring features from a lot of surface samples found by two iterations of gradient descent, by picking the point with the highest curvature. we use a wide radius for computing curvature so near-miss points benefit too. ", "tags": ["gradient", "dual", "features", "descent", "contouring"], "likes": 11, "viewed": 582, "published": 3, "date": "1636674096", "time_retrieved": "2024-07-30T18:48:53.079401", "image_code": "/*\nquick legend to the visuals:\n\npan the mouse a bit to see some interesting points, particularly edges\n\ncolor chart:\n* background: map of triangle filtered curvature over the sampled domain\n* blue: our starting positions for gradient descent\n* magenta: points on the surface our descent has converged to\n* orange circle: the feature sample, selected by the highest curvature closest to the center of the cell\n\n\nThis is original research. I was trying to find an alternative to the feature finding of\nDual Contouring (here's a primer: https://www.boristhebrave.com/2018/04/15/dual-contouring-tutorial/),\nwhich uses a QEF (a least squares procedure involving costly SVDs) to derive feature coordinates\nfrom hermite points sampled on the polyhedron envelope of dual vertices.\n\nIt's amazing the words that seem normal to you after internalizing a few computer graphics papers.\n\nAnyway, it's a costly, complex process that was really hard for me to understand, and the \nresult doesn't even look that good. If you throw too many samples at it, it regresses to\nthe center of mass for the provided sample points, which looks awful.\n\nThe idea came to me to stop using hermite points from the edges (which have to be raymarched\nper edge, which is also not particularly fast, and they can miss geometry passing faces only),\nand instead sample hermite points from gradient descent, starting from a high frequency\npseudorandom position somewhere in the volume.\n\nIt turns out that at the scale that we are sampling, 1-2 steps of descent are enough to\nbring us to the surface, and the method is biased towards corners anyway, so hooray.\n\nIf one needs a lot of quality, then random descent might be the better choice, but it needs\na lot of iterations to provide usable results.\n\nSince those descent samples are so cheap, we can do a bunch of them instead of blowing it\nall on steps, and so I do 36 taps in this implementation. In the simplest, feature agnostic\nversion, one can just pick the point closest to the center, but as we can compute\ntriangle tapered curvature from the SDF, we pick the point with the highest curvature\ninstead, which logically is close to a high frequency feature, like a corner or a crease.\n\nFor the 3D version to work, the curvature of corners must be higher than the curvature\nof edges, and one must use a seven tap version to get cubes right.\n\nIf it were possible to descend on the curvature gradient instead, which afaik would require\none more differentiation, then we could massively reduce our sampling - but the curvature \nfunction isn't usually smooth enough to allow us to do that. \n\nAnother technique is, if one is in control and knowledge of participating basic SDF primitives,\nto compute absolute differences of SDF functions to produce roots at their intersections, which\nis typically where feature points reside; then gradient descent from the center suffices to\nfind the most important feature.\n*/\n\n//////////////////////////////////////////////////////////\n\nvec2 rotate(vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,s,-s,c) * p;\n}\n\n// from http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\nvec2 qrs_R2(int n) {\n    const float g = 1.32471795724474602596;\n    const vec2 a = 1.0/vec2(g, g*g);\n    return fract(0.5 + a*vec2(n));\n}\n\nfloat _distf(vec2 p) {\n    float d2 = length(p - vec2(0.0, 0.1)) - 0.2;\n    float d3 = length(p - vec2(-0.15, 0.3)) - 0.1;\n    \n    p = rotate(p, radians(22.5));\n    p = abs(p) - vec2(0.6,0.2);\n    float d = max(p.x, p.y);\n   \n    \n    return min(d3, max(d, -d2));\n    //return d2;\n}\n\nvec2 offset = vec2(0.0);\nfloat distf(vec2 p) {\n    float S = 8.0;\n    \n    p -= vec2(0.3, -0.8) - offset; \n    \n    p /= S;\n\n    return _distf(p)*S;\n}\n\nvec2 gradient(vec2 p) {\n    const vec2 eps = vec2(1e-4, 0.0);\n    return vec2(\n        distf(p + eps.xy) - distf(p - eps.xy),\n        distf(p + eps.yx) - distf(p - eps.yx)) / (2.0 * eps.x);\n}\n\n//5 taps total, returns both normal and curvature\n// from https://www.shadertoy.com/view/Xts3WM\nvec3 curvature(in vec3 p, out float curv) {\n#define map(P) distf((P).xy)\n    vec2 e = vec2(-1., 1.)*0.3; // large radius\n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n\n    curv = .125/(e.x*e.x) *(t1 + t2 + t3 + t4 - 4. * map(p));\n    return normalize(e.yxx*t1 + e.xxy*t2 + e.xyx*t3 + e.yyy*t4);\n#undef map\n}\n\n//////////////////////////////////////////////////////////\n\nvec3 plasma(float t) {\n\n    const vec3 c0 = vec3(0.05873234392399702, 0.02333670892565664, 0.5433401826748754);\n    const vec3 c1 = vec3(2.176514634195958, 0.2383834171260182, 0.7539604599784036);\n    const vec3 c2 = vec3(-2.689460476458034, -7.455851135738909, 3.110799939717086);\n    const vec3 c3 = vec3(6.130348345893603, 42.3461881477227, -28.51885465332158);\n    const vec3 c4 = vec3(-11.10743619062271, -82.66631109428045, 60.13984767418263);\n    const vec3 c5 = vec3(10.02306557647065, 71.41361770095349, -54.07218655560067);\n    const vec3 c6 = vec3(-3.658713842777788, -22.93153465461149, 18.19190778539828);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n\n}\n\nbool descend(inout vec2 p) {\n    const int N = 2;\n    for (int i = 0; i < N; ++i) {\n        float d = distf(p);\n        if (abs(d) < 1e-3)\n            return true;\n        vec2 r;\n        //r = uniform_circle_edge(rng);\n        // straight gradient descent brings better results and needs\n        // fewer iterations\n        r = -gradient(p);\n        vec2 p1 = p + r*d;\n        // mirror gradient when it exceeds the search box\n        if (abs(p1.x) > 1.0)\n            r.x = -r.x;\n        if (abs(p1.y) > 1.0)\n            r.y = -r.y;\n        p += r*d;\n    }\n    return false;\n}\n\nfloat weighed_curvature(vec2 p) {\n    float C;\n    curvature(vec3(p,0), C);\n    // prefer high curvature near the center\n    C = abs(C)/(1.0 + dot(p,p));\n    return C;\n}\n\nvoid paint(vec2 fragCoord) {\n    float t = iTime;\n    offset = -get_query()*4.0;\n    set_source_rgb(vec3(0.925, 0.941, 0.894));\n    \n    vec2 O = get_origin();\n    if (max(abs(O.x),abs(O.y)) < 1.0) {\n        vec2 q = get_origin();\n        descend(q);\n        float C = weighed_curvature(O);\n        C = tanh(C);\n        set_source_rgb(plasma(C));\n    }\n    \n    clear();\n    \n    set_source_rgb(vec3(0.0));\n    set_line_width_px(1.0);\n    rectangle(-1.0,-1.0,2.0,2.0);\n    stroke();\n    set_source_rgba(0.0, 0.0, 0.0, 0.5);\n    graph2D(distf);\n    fill_preserve();\n    set_source_rgba(0.0, 0.0, 0.0, 1.0);\n    stroke();\n\n    float bestc = 0.0;\n    vec2 bestp = vec2(0.0);\n    for (int i = 0; i < 36; ++i) {\n        vec2 p = qrs_R2(i)*2.0 - 1.0;\n        set_source_rgb(vec3(0.0,0.5,1.0));\n        circle_px(p, 4.0);\n        fill();\n        if (descend(p)) {\n            float pd = length(p);\n            float C = weighed_curvature(p);\n            if (C > bestc) {\n                bestp = p;\n                bestc = C;\n            }\n            set_source_rgb(vec3(1.0,0.5,1.0));\n            circle_px(p, 4.0);\n            fill();\n        }\n    }\n    \n    set_source_rgb(vec3(1.0,0.5,0.0));\n    set_line_width_px(2.0);\n    circle_px(bestp.xy, 8.0);\n    stroke();    \n\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init(fragCoord, iMouse.xy, iResolution.xy);\n\n    paint(fragCoord);\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n// after Cairo API, with anti-aliasing\n// by Leonard Ritter (@paniq)\n// v0.11\n\n// I release this into the public domain.\n// some estimators have been lifted from other shaders and are not\n// necessarily PD licensed, note the links in the source code comments below.\n\n// 2019-06-06: 0.12\n// * split implementation and demo into common and image tab\n\n// 2017-10-05: 0.11\n// * anti-aliasing is gamma-correct\n\n// 2017-10-01: 0.10\n// * added experimental letter() function\n\n// 2017-09-30: 0.9\n// * save() is now a declarative macro\n\n// 2017-09-11: 0.8\n// * added ellipse()\n\n// 2017-09-10: 0.7\n// * paths painted with line_to/curve_to can be filled.\n\n// 2017-09-09: 0.6\n// * added rounded_rectangle()\n// * added set_source_linear_gradient()\n// * added set_source_radial_gradient()\n// * added set_source_blend_mode()\n// * added support for non-uniform scaling\n\n// undefine if you are running on glslsandbox.com\n// #define GLSLSANDBOX\n\n#ifdef GLSLSANDBOX\n#ifdef GL_ES\n#endif\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define iTime time\n#define iResolution resolution\n#define iMouse mouse\n#endif\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add a circle path at P with pixel radius R\nvoid circle_px(vec2 p, float r);\nvoid circle_px(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// draw a letter with the given texture coordinate\nvoid letter(sampler2D font_texture_source, ivec2 l);\nvoid letter(sampler2D font_texture_source, int lx, int ly);\n    \n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n#define save(name) Context name = _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord, vec2 mouse, vec2 resolution) {\n\taspect = vec2(resolution.x / resolution.y, 1.0);\n\tScreenH = min(resolution.x,resolution.y);\n\tAA = ScreenH*0.4;\n\tAAINV = 1.0 / AA;\n    \n    uv = fragCoord.xy / resolution;\n    vec2 m = mouse / resolution;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(sqrt(_color), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nfloat fill_distance() {\n    return _stack.shape.y;\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    //c.rgb *= c.rgb;\n    c *= c;\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid letter(sampler2D font_texture_source, ivec2 l) {\n  vec2 p = vec2(l);\n  vec3 tx;\n  vec2 ip;\n  float d;\n  int ic;\n  ip = vec2(l);\n  p += clamp(_stack.position.xy, 0.0, 1.0);\n  ic = 0x21 + int (mod (16. + ip.x + 2. * ip.y, 94.));\n  tx = texture (font_texture_source, mod ((vec2 (mod (float (ic), 16.),\n     15. - floor (float (ic) / 16.)) + fract (p)) * (1. / 16.), 1.)).gba - 0.5;\n  d = tx.b + 1. / 256.;\n  add_field(d / min_uniform_scale());\n}\n\nvoid letter(sampler2D font_texture_source, int lx, int ly) {\n    letter(font_texture_source, ivec2(lx,ly));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\nvoid circle_px(vec2 p, float r) {\n    circle(p, r/(0.5*ScreenH));\n}\nvoid circle_px(float x, float y, float r) {\n    circle_px(vec2(x,y), r);\n}\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(f_x / length(df_x));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntt3DS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2987, 2987, 3017, 3017, 3094], [3096, 3187, 3207, 3207, 3325], [3327, 3327, 3349, 3349, 3610], [3637, 3637, 3658, 3658, 3762], [3764, 3764, 3787, 3787, 3955], [4480, 4480, 4502, 4502, 5157], [5159, 5159, 5187, 5187, 5736], [5738, 5738, 5771, 5771, 5907], [5909, 5909, 5937, 5937, 7177], [7239, 7239, 7296, 7296, 7391]], "test": "untested"}
{"id": "Ntd3WS", "name": "Growing forest", "author": "hamtarodeluxe", "description": "This is how Christmas trees are made :-)", "tags": ["christmas", "tree", "forest", "feedback", "buffer", "pine"], "likes": 22, "viewed": 384, "published": 3, "date": "1636674047", "time_retrieved": "2024-07-30T18:48:53.838371", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 dc = uv - 0.5;\n    dc.x *= iResolution.x/iResolution.y;\n    vec3 col = texture(iChannel0, uv).rgb;\n    col.rgb *=  1./pow((pow(sqrt(dot(dc * 2., dc * 2.)*.4),2.)+1.),3.);\n    fragColor = vec4(pow(col,vec3(0.45)),1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI 3.1459f\n#define RAYMARCHSTEPS 20\n#define SAMPLECOUNT 1024\n\nvec3 fibonacci(int i, int samples, float from, float to, float rot)\n{\n    float phi = 2.3999;\n    float y = 1. - (float(i) / (float(samples) - 1.));\n    y = mix(from, to, y);\n    float radius = sqrt(1. - y * y);\n    float theta = phi * float(i) +rot;\n    float x = cos(theta) * radius;\n    float z = sin(theta) * radius;\n    \n    return vec3(x,y,z);\n}\n\n// Caspule, from IQ's website\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    b += a;\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba) / dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - mix(r*1., 0.5*r, h);\n}\n\nvec3 pFromTime(float time)\n{\n    time /= 60.;\n    time *=0.7;\n    return 0.3*vec3(0.5*sin(time), 0., 0.5*cos(time));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 dc = uv - 0.5;\n    dc.x *= iResolution.x/iResolution.y;\n        \n    // Camera (orthographic)\n    vec3 ro = 5.*vec3(1.5, 1.5, 3.);\n    vec3 lookAt = vec3(0., 0.5, 0.);\n    vec3 up = vec3 (0, 1, 0);\n    vec3 fw = normalize(lookAt-ro);\n    vec3 rd = fw;\n    vec3 right = normalize(cross(fw, up));\n    up = normalize(cross(right,fw));  \n    float cameraScale = 2.5;\n    ro = ro + (up*dc.y + right*dc.x) * cameraScale;\n    \n    // Init. col\n    vec4 col = vec4(0.1, 0.1, 0.1, 1000.0f);\n    vec3 sky = vec3(0.15,0.23,0.5)*0.5;\n    col.rgb = sky;\n    \n    // Vertical pan\n    vec2 oldUv = uv;\n    float texHeight = 1./iResolution.y;\n    float dy = 0.0019f;\n    dy = max(texHeight, floor(dy/texHeight)*texHeight);\n    uv.y += dy;\n    vec4 colOld = texture(iChannel0, uv);\n    // colOld.a != 0. to clear when no info.\n    if (iFrame != 0 && uv.y<1.0f && colOld.a != 0.)\n    {\n        col = colOld;\n    }\n    \n    // Raymarching\n    float t = 0.;\n    bool hasHit = false;\n    vec3 p;\n    float l;\n    vec3 iSecObjPos = vec3(0.);\n    float objID = 0.;\n    int nObj = 20;\n    float minD = 99.;\n    vec3 closestP;\n    float isecU;\n    float frame = float(iFrame);\n    for (int i = 0; i < RAYMARCHSTEPS; i++)\n    {\n        p = ro + rd*t;\n        \n        float d = 99.;\n        for (int j = 0; j < nObj; j++)\n        {\n            uint sampleI = uint((iFrame + j*(SAMPLECOUNT / nObj)) % SAMPLECOUNT);\n            \n            float u = float(sampleI)/ float(SAMPLECOUNT);\n            \n            vec3 root = fibonacci(j, nObj,0.,1.0,0.)*vec3(2.,.6,2.) + (1.-(pow(min(frame/(300.), 1.), 0.5)*u))*vec3(0.,-2.5,0.);\n            root += vec3(0.,0.6,0.);\n            vec3 objectPos = root + pFromTime(frame + float(j)*500.);\n            vec3 objectPosPrev = root + pFromTime(frame-1. + float(j)*500.);\n            float rot = 3.14*float(j)/float(nObj);\n            vec3 L = normalize(fibonacci(SAMPLECOUNT-int(sampleI), SAMPLECOUNT, 0.4+sin(float(j)*500.)*0.2, 0.9,rot));\n            l = mix(1.1, 0.08, u);\n            \n            vec3 y = normalize((objectPosPrev - vec3(0., dy*cameraScale*2., 0.)) - objectPos);\n            vec3 x = cross(y, vec3(1.,0.,0.));\n            vec3 z = cross(x,y);\n            x = cross(z,y);\n            L =  mat3(x,y,z) * L;\n            \n            // Trunk?\n            /*\n            if (u <0.5)\n                L*=0.2;\n            */\n            d = min(d, sdCapsule(p, objectPos, l*L, 0.02f));\n\n\n            minD = min(d, minD);\n            \n            if (d < 0.0001)\n            {\n                isecU = u;\n                iSecObjPos = objectPos;\n                objID = float(j);\n                hasHit = true;\n                break; \n            }\n        }\n        t+=d;\n    }\n        \n    // Shading\n    \n    // Outline\n    if (!hasHit && col.a >= 99.)\n    {\n        float o = smoothstep(0.014,0.019, minD);\n        col.rgb = mix(sky*0.65, col.rgb, o);  \n    }    \n    // Surface\n    if (hasHit && t < col.a)\n    {\n        col.rgb = vec3(0.8*pow(sin(float(iFrame)*3.),2.), 0.7*cos(float(iFrame)*5.5), sin(objID*2.0f));\n        col.rgb = cross(col.rgb, normalize(iSecObjPos));\n        col.rgb = col.rgb * 0.5f + 0.5f;        \n        float uu = min(max((isecU- 0.8)/0.2, 0.),1.);        \n        col.rgb = mix(col.rgb, vec3(1./1.6), uu);\n        col.rgb = col.rgb*pow(length(p.rgb-iSecObjPos)/l, mix(5.,1., uu ))+ 0.05*col.rgb ;\n        float f = max(0., (t-17.));\n        col.rgb = vec3(1.6)*mix(sky*0.7, vec3(col.rgb), exp(-f*0.15));\n        col.a = t;\n    }\n\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntd3WS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 326]], "test": "untested"}
{"id": "sttGDB", "name": "FBM meets Britney :)", "author": "SimonOakey", "description": "still learning and understanding FBM", "tags": ["fractal", "noise", "noise", "fbm", "water", "metal", "liquid"], "likes": 8, "viewed": 506, "published": 3, "date": "1636673810", "time_retrieved": "2024-07-30T18:48:54.582382", "image_code": "vec2 ouv;\n\nfloat rand(vec2 p) {\n    return fract(sin(dot(p, vec2(12.99, 78.233))) * 43758.545);\n}\n\nfloat noise(vec2 p) {\n    vec2 f = fract(p);\n    vec2 u = f * f * (3. - 2. * f);\n    \n    vec2 i = floor(p);\n    float a = rand(i);\n    float b = rand(i + vec2(1, 0));\n    float c = rand(i + vec2(0, 1));\n    float d = rand(i + vec2(1, 1));\n    return mix(a, b, u.x) + (c - a)* u.y * (1. - u.x) +(d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 p) {\n    float v = 0.;\n    float a = 1.;\n    for(int i = 0; i < 3; ++i) {\n        p = 2. * p + 5.;\n        p+= texture(iChannel0,ouv).xy;\n        \n        a *= 0.5;\n        v += a * noise(p);\n        \n        \n    }\n    return v;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    \n    \n    vec2 p =   fragCoord.xy / iResolution.xy  ;\n    \n    ouv = p;\n\n    vec2 q = vec2(fbm(p + 0.02 * iTime), fbm(p + 0.05 * iTime));\n    vec2 r = vec2(fbm(p + 10. * q + vec2(1., 9.2) + 0.15 * iTime),\n                  fbm(p + 12. * q + vec2(5., 2.8) + 0.126 * iTime));\n\n    float f = fbm(p + r);\n    \n    vec3 col = vec3(\n    \n    abs(sin(f*.3)),\n    abs(cos(f*3.3)),\n    abs(sin(f*1.3))\n    \n    \n    );\n    \n    \n    fragColor = vec4(1.6 * pow(f, 2.) + 0.03);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sttGDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[11, 11, 31, 31, 97], [99, 99, 120, 120, 416], [418, 418, 437, 437, 664], [666, 666, 721, 721, 1199]], "test": "untested"}
{"id": "sttGWB", "name": "Simple 2D Metaballs w/ Fade-out", "author": "KdotJPG", "description": "Simple 2D metaball circle fadeout demo using a piecewise polynomial falloff function. One metaball in the center; click and drag the mouse to move around a second.", "tags": ["metaballs"], "likes": 2, "viewed": 311, "published": 3, "date": "1636665850", "time_retrieved": "2024-07-30T18:48:55.339358", "image_code": "const float R = 0.5;\nconst float BlendPadding = 0.00625;\nconst float FadePadding = 0.2;\n\nconst float S = R + BlendPadding;\nconst float Q = R - FadePadding;\n\nconst float A = (S*S - Q*Q) * (S*S - Q*Q) * (S*S - Q*Q);\nconst float B = (S*S - R*R) * (S*S - R*R) * (S*S - R*R);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2. - iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec2 iMouseUV = (iMouse.xy * 2. - iResolution.xy)/min(iResolution.x, iResolution.y);\n    \n    float falloff0 = max(0., S*S - dot(uv, uv)); falloff0 *= falloff0 * falloff0;\n    float falloff1 = max(0., S*S - dot(uv - iMouseUV, uv - iMouseUV)); falloff1 *= falloff1 * falloff1;\n    \n    float totalSum = falloff0 + falloff1;\n    float smoothStepValue = smoothstep(B, A, totalSum);\n\n    vec3 col = vec3(smoothStepValue);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sttGWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[272, 272, 327, 327, 866]], "test": "untested"}
{"id": "Ntd3DB", "name": "black holes - acid", "author": "morisil", "description": "Testing something out", "tags": ["chromaticaberration", "study", "depthoffield", "focus"], "likes": 25, "viewed": 681, "published": 3, "date": "1636653017", "time_retrieved": "2024-07-30T18:48:56.191081", "image_code": "// Fork of \"black holes\" by morisil. https://shadertoy.com/view/Nlt3DB\n// 2021-11-11 17:50:05\n\n// Fork of \"depth of field focus study 4\" by morisil. https://shadertoy.com/view/stdGzf\n// 2021-11-11 17:35:53\n\n// Fork of \"depth of field focus study 3\" by morisil. https://shadertoy.com/view/stdGRf\n// 2021-11-09 22:06:23\n\n// Fork of \"depth of field focus study 2\" by morisil. https://shadertoy.com/view/flc3zX\n// 2021-11-09 21:23:07\n\n// Fork of \"depth of field focus study\" by morisil. https://shadertoy.com/view/sld3zB\n// 2021-11-08 19:52:49\n\nconst float CHROMATIC_ABBERATION = .02;\nconst float ITERATIONS = 20.;\nconst float INITIAL_LUMA = .5;\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n\nfloat getColorComponent(in vec2 st, in float modScale, in float blur, in float shapeSize) {\n    vec2 modSt = mod(st, 1. / modScale) * modScale * 2. - 1.;\n    float dist = length(modSt);\n    float angle = atan(modSt.x, modSt.y);\n    float shapeMap = smoothstep(shapeSize + blur, shapeSize - blur, dist);\n    return shapeMap;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st =\n        (2.* fragCoord - iResolution.xy)\n        / min(iResolution.x, iResolution.y);\n    st *= rotate2d(sin(iTime * .6 + st.x + st.y) * .3);\n    st *= (sin(iTime * .3) + 2.) * .3;\n\n    st *= log(length(sin(st * 5.18)) * cos(iTime * .1) + 1.2) * 5.;\n    float modScale = 1.;\n\n    vec3 color = vec3(0);\n    float luma = INITIAL_LUMA;\n    float blur = .2;\n    float shapeSize = .2 + (sin(iTime * .7) + 1.) * .2;\n    for (float i = 0.; i < ITERATIONS; i++) {\n        vec2 center = st + vec2(sin(iTime * .5), cos(iTime * .3)) * 2.;\n        //center += pow(length(center), 1.);\n        vec3 shapeColor = vec3(\n            getColorComponent(center - st * CHROMATIC_ABBERATION, modScale, blur, shapeSize),\n            getColorComponent(center, modScale, blur, shapeSize),\n            getColorComponent(center + st * CHROMATIC_ABBERATION, modScale, blur, shapeSize)        \n        ) * luma;\n        st *= 1.1;\n        st *= rotate2d(sin(iTime  * .05) * .3);\n        color += shapeColor;\n        color = clamp(color, 0., 1.);\n        if (color == vec3(1)) break;\n        luma *= .8;\n        blur *= .63;\n    }\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntd3DB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[643, 643, 671, 671, 757], [760, 760, 851, 851, 1085], [1087, 1087, 1142, 1142, 2294]], "test": "untested"}
{"id": "Nlt3DB", "name": "black holes", "author": "morisil", "description": "Testing something out", "tags": ["chromaticaberration", "study", "depthoffield", "focus"], "likes": 10, "viewed": 352, "published": 3, "date": "1636652398", "time_retrieved": "2024-07-30T18:48:57.027844", "image_code": "// Fork of \"depth of field focus study 4\" by morisil. https://shadertoy.com/view/stdGzf\n// 2021-11-11 17:35:53\n\n// Fork of \"depth of field focus study 3\" by morisil. https://shadertoy.com/view/stdGRf\n// 2021-11-09 22:06:23\n\n// Fork of \"depth of field focus study 2\" by morisil. https://shadertoy.com/view/flc3zX\n// 2021-11-09 21:23:07\n\n// Fork of \"depth of field focus study\" by morisil. https://shadertoy.com/view/sld3zB\n// 2021-11-08 19:52:49\n\nconst float CHROMATIC_ABBERATION = .02;\nconst float ITERATIONS = 20.;\nconst float INITIAL_LUMA = .5;\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n\nfloat getColorComponent(in vec2 st, in float modScale, in float blur, in float shapeSize) {\n    vec2 modSt = mod(st, 1. / modScale) * modScale * 2. - 1.;\n    float dist = length(modSt);\n    float angle = atan(modSt.x, modSt.y);\n    float shapeMap = smoothstep(shapeSize + blur, shapeSize - blur, dist);\n    return shapeMap;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st =\n        (2.* fragCoord - iResolution.xy)\n        / min(iResolution.x, iResolution.y);\n    st *= rotate2d(sin(iTime * .6 + st.x + st.y) * .3);\n    st *= (sin(iTime * .3) + 2.) * .3;\n\n    st *= log(length(sin(st * 5.18)) * (sin(iTime) + 2.) * 3.);\n    float modScale = 1.;\n\n    vec3 color = vec3(0);\n    float luma = INITIAL_LUMA;\n    float blur = .2;\n    float shapeSize = .2 + (sin(iTime * .7) + 1.) * .2;\n    for (float i = 0.; i < ITERATIONS; i++) {\n        vec2 center = st + vec2(sin(iTime * .5), cos(iTime * .3));\n        //center += pow(length(center), 1.);\n        vec3 shapeColor = vec3(\n            getColorComponent(center - st * CHROMATIC_ABBERATION, modScale, blur, shapeSize),\n            getColorComponent(center, modScale, blur, shapeSize),\n            getColorComponent(center + st * CHROMATIC_ABBERATION, modScale, blur, shapeSize)        \n        ) * luma;\n        st *= 1.1;\n        st *= rotate2d(sin(iTime  * .05) * .3);\n        color += shapeColor;\n        color = clamp(color, 0., 1.);\n        if (color == vec3(1)) break;\n        luma *= .8;\n        blur *= .63;\n    }\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlt3DB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[548, 548, 576, 576, 662], [665, 665, 756, 756, 990], [992, 992, 1047, 1047, 2190]], "test": "untested"}
{"id": "NtdGDB", "name": "Fractelligence LG 02", "author": "PsyPhi", "description": "Raymarched Fractal\n\nDepth", "tags": ["raymarching", "fractal"], "likes": 1, "viewed": 189, "published": 3, "date": "1636650725", "time_retrieved": "2024-07-30T18:48:57.945390", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 fractal = texture(iChannel0, uv);\n    vec4 blured = texture(iChannel1, uv);\n    float focusPoint = 0.5;\n    \n    float minDistance = 0.25;\n    float maxDistance = 2.5;\n    \n    float blur = smoothstep(minDistance, maxDistance,abs(fractal.z - focusPoint));\n    \n    fragColor = mix(fractal,blured,blur);\n    //fragColor = vec4(blur,blur,blur,1.0);\n    //fragColor = fractal;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//Transforms\nfloat RotX = 1.0; //0 to 3\nfloat RotY = 1.2;\nfloat RotZ = 1.1;\nfloat TransX = 0.1; //0 to 5\nfloat TransY = -0.1;\nfloat TransZ = 0.0;\nfloat Scale = 0.;\nfloat Range = 0.001;\n\nfloat TwistY = 0.; //0 to 0.2\nint MirrorX = 1;\nint MirrorY = 0;\nint MirrorZ = 1;\n//Rectange\nint Rectangle = 1;\nfloat RecScale = 0.75;\n//Sphere\nint Sphere = 0;\nfloat SphereScale = 0.75;\nfloat SphereTX = 0.;\nfloat SphereTY = 0.;\nfloat SphereTZ = 0.;\n//Shapes\nint InfPre = 0;\nint InfPost = 0;\nint Merge = 0;\nfloat ShapeMix = 0.;\nfloat FractalScale = 0.1;\nfloat NearClip = 5.;\n//Color\nint Iterations = 1;\nfloat IHue = 1.;\nfloat Proximity = 1.;\nfloat PHue = 1.;\nfloat Distance = 1.;\nfloat DHue = 1.;\nfloat light = 0.;\nfloat DepthHue = 0.1;\nfloat ProxHue = 0.;\n//Time\nfloat TimeRotX = 1.0;\nfloat TimeRotY = 0.0;\nfloat TimeTransX = 0.1;\nfloat TimeTransY = 0.1;\nint TimeEnable = 1;\nint TimeDisabled = 0;\n\n#define MAX_STEPS 50\n\n#define MAX_DIST 25.\n\n#define SURF_DIST .001\n\n#define FRACT_STEPS 20\n\n#define PI 3.14159\n\nfloat map(float x, float inMin, float inMax, float outMin, float outMax) {\n    return (x - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;\n}\n\nvec3 hs(vec3 c, float s){\n    vec3 m=vec3(cos(s),s=sin(s)*.5774,-s);\n    return c*mat3(m+=(1.-m.x)/3.,m.zxy,m.yzx);\n}\n\nmat2 rotate(float a){\n\tfloat c = cos(a),\n\ts = sin(a);\n\treturn mat2(c, -s, s, c);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ){\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sdRectangle( vec3 p, float s){\n        float recDist = length(max(abs(p) - s, 0.));\n        return recDist;\n}\n\n\n\n//_+_+_+_+_+_+_SHAPING FUNCTIONS_+_+_+_+_+_+_+_\nfloat GetDist(vec3 p) {\n\tfloat d = 1.; //Just to have the d var declaired\n    \n\tfor (int i = 0; i < FRACT_STEPS ; i++){\n        if(InfPre == 1) p = mod(p+2.5, 5.)-2.5;   //Createts infinity\n\n\t\tif(MirrorX == 1) p.x = abs(p.x); //Mirror X\n\t\tif(MirrorY == 1) p.y = abs(p.y); //Mirror Y\n\t\tif(MirrorZ == 1) p.z = abs(p.z); //Mirror Z\n\n\t\tp.x -= TransX\n        +iMouse.x*Range\n        +TimeTransX*sin(iTime*0.1);\n        \n\t\tp.y -= TransY+iMouse.y*Range\n        +iMouse.y*Range\n        +TimeTransY*cos(iTime*0.1);\n        \n\t\tp.z -= TransZ;\n\n\t\tp.xy *= rotate(RotX+sin(iTime*0.2)*TimeRotX); \n\t\tp.xz *= rotate(RotY+cos(iTime*0.1)*TimeRotY);\n\t\tp.yz *= rotate(RotZ);\n\n        p.xz *= rotate(p.y*TwistY); //Twist\n\n        if(InfPost == 1)\t\tp = mod(p+2.5, 5.)-2.5;   //Createts infinity\n    }\n\n    if (Sphere == 1){\n\t\tvec4 sphere = vec4(SphereTX, SphereTY, SphereTZ, SphereScale);\n        float sphereDist =  length(p-sphere.xyz)-sphere.w;\n        if(Merge == 1) d = opSmoothUnion(sphereDist, d, ShapeMix);\n        else d = min(sphereDist,d);\n    }\n\n\n    if (Rectangle == 1){//Adds in the Rectangle\n        d = sdRectangle(vec3(0.0, 0.0, 0.0), RecScale);\n    }\n   \n    \n    d = sdOctahedron(p,1.0);\n\n    return d;\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd) {\n\tvec3 dO = vec3(NearClip,0.,10.);  //  x = distance ray has traveled, y = Iterations to hit, z = Closest distance to surface\n\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO.x;\n        float dS = GetDist(p);\n        dO.x += dS;\n\t\t\t\tdO.z = min(dS, dO.z);\n\t\t\t\tdO.y = float(i);\n        if(dO.x>MAX_DIST || dS<SURF_DIST) break;\n    }\n\n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 1, -6);\n    //lightPos.xz += vec2(sin(TIME), cos(TIME))*2.; //light movement\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).x;\n    if(d<length(lightPos-p)) dif *= .1;\n\n    return dif;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord, in vec3 _ro, in vec3 _rd)\n\n{\n\n    if (TimeEnable == 0 && TimeDisabled == 0) {\n    TimeRotX = 0.;\n    TimeRotY = 0.;\n    TimeTransX = 0.;\n    TimeTransY = 0.;\n    int TimeDisabled = 1;\n    }\n    \n\n    vec2 uv = (fragCoord+fragCoord - (iResolution.xy) ) / iResolution.y ;\n    \n\n    vec3 color = vec3(0);\n    vec3 iterationsColor;\n\tvec3 proxColor;\n    vec3 distColor;\n    vec3 normalColor = vec3(0.);\n\n    vec3 ro = vec3(0, 0, -6+(InfPre+InfPost));\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    ro = _ro;\n    rd = _rd;\n\n    vec3 d = RayMarch(ro, rd);\n    \n    vec3 d2 = RayMarch(ro+vec3(0.5,0.,0.), rd);\n    \n    d = opSmoothSubtraction( d, d2, 0.5 );\n\n    vec3 p = ro + rd * d.x;\n\n    float dif = GetLight(p);  //lighting\n\n\tvec3 n = GetNormal(p);\n\n\n    //+_+_+_+_+_+_+COLORING_+_+_+_+_+_+_\n    //Iterations\n\titerationsColor.r = (d.y*0.05-(1.-step(d.x*0.04, 1.)))*float(Iterations);\n    iterationsColor = hs(iterationsColor, IHue);\n    color = iterationsColor;\n    \n    //Distance\n    distColor.b = (1.-d.x*0.04)*Distance;\n    distColor = hs(distColor, DHue);\n    color += distColor;\n    //color = hs(color, -(1.-d.x*0.04));\n\n    color.g = (1.-(d.z+step(d.x*0.04, 1.)))*Proximity;\n\n    color = hs(color, PHue);\n    color.b = (1.-d.x*0.04)*Distance;\n\n    color = hs(color, DHue);\n    \n    color += dif*light;       //light\n    //color = hs(color, 5.0*dif*light);       //light hue rotate\n    \n    //Normals\n    //normalColor.b = n.b;\n    normalColor.b = n.g;\n    normalColor.r = n.r;\n    normalColor.g = 0.0;\n    normalColor = hs(normalColor, 1.6);\n   // color =+ hs(color, -n.b); //Y\n   // color =+ hs(color, n.r); //X\n   // color = mix(color, normalColor, Color.w);\n   \n    //Proximity\n    proxColor.g = (1.-(d.z+step(d.x*0.04, 1.)))*Proximity;\n    proxColor = hs(proxColor, PHue);\n    color += proxColor;\n\n\t//color = hs(color, d.y*DepthHue); //iterations to hue rot\n    //color = iterationsColor;\n    //color = distColor;\n    color = mix(iterationsColor, 1.-iterationsColor, normalColor.b);\n    color = mix(color, distColor, normalColor.r);\n    color += proxColor;\n    color = iterationsColor;\n    \n    //Light\n    //color += dif*light; //Light\n    //color = hs(color, -5.0*dif*light);       //light hue rotate\n\n    fragColor = vec4(normalColor,1.);\n    \n\n}\n\n\n\n#define QAA\t2                                     \n\nconst float\tsideAngle       = radians(35.0);\nconst float\thorizontalAngle = radians(14.0);\nconst float\tcameraSize      = 8.;\nconst float\taspectRatio     = 0.75;\nconst float quiltColumns\t= 8.0;\nconst float quiltRows\t\t= 6.0;\nconst float nearClip        = 8.0; \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2\tcoord = fragCoord * vec2(quiltColumns,quiltRows) / iResolution.xy;\n\tvec2\tfract = fract(coord);\n\tvec2\tfloor = floor(coord);\n\tfloat\timageId = floor.x + floor.y * quiltColumns;\n\tfloat\tvalueId = imageId / (quiltColumns * quiltRows - 1.);\n\tfloat\tdist = (cameraSize / 2.) / tan(horizontalAngle / 2.);\n\tfloat\tminCam = -(cameraSize / 2.) - tan(sideAngle / 2.) * dist;\n\t\n\tvec3\tcamPos = mix(vec3(minCam,0,dist),vec3(-minCam,0,dist),valueId);\n\tvec3\tscreenPos = vec3((fract.x-0.5)*cameraSize,(fract.y-0.5)*cameraSize / aspectRatio,0);\n\t\n\tvec4\tcolor;\n\tvec3 \tdirRay = normalize(screenPos-camPos);\n    dirRay.z = -dirRay.z;\n\tmainImage( color, fract * iResolution.xy, screenPos - nearClip * dirRay, dirRay );\n\n    fragColor = color;\n\n}", "buffer_a_inputs": [], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pxlSize = vec2(1.0)/iResolution.xy;\n    float blurSize = 1.;\n    \n    pxlSize *= blurSize;\n\n    \n    vec4 kernel[9] = vec4[9](vec4(0.0),vec4(0.0),vec4(0.0),vec4(0.0),vec4(0.0),vec4(0.0),vec4(0.0),vec4(0.0),vec4(0.0));\n    \n    int arrayInc = 0;\n    \n for (int i = 0; i < 3 ; i++){\n     for(int j = 0;j<3;j++){\n         kernel[arrayInc] = texture(iChannel0, uv+vec2((-1+j),-1+i)*pxlSize);\n         arrayInc++;\n           }\n   \t\t}\n    \n    //kernel[4] = texture(iChannel0, uv+vec2(1,1)*pxlSize);\n    \n    vec4 bTotal = vec4(0.0);\n    \n    for(int i = 0;i<9;i++){\n     \tbTotal += kernel[i]*0.111;   \n    }\n    \n    \n    //bTotal = bTotal/vec4(9.0);\n    \n\n    // Time varying pixel color\n    vec4 col = bTotal;\n\n    // Output to screen\n    fragColor = bTotal;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtdGDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 482]], "test": "untested"}
{"id": "flt3z7", "name": "Fractelligence", "author": "PsyPhi", "description": "Raymarched Fractal", "tags": ["raymarching", "fractal"], "likes": 6, "viewed": 314, "published": 3, "date": "1636647970", "time_retrieved": "2024-07-30T18:48:58.692393", "image_code": "//Transforms\nfloat RotX = 1.5; //0 to 3\nfloat RotY = 1.5;\nfloat RotZ = 1.5;\nfloat TransX = 1.; //0 to 5\nfloat TransY = 1.5;\nfloat TransZ = 0.5;\nfloat Scale = 0.;\nfloat Range = 0.001;\nfloat RX = 0.;\nfloat RY = 0.;\nfloat RZ = 0.;\nfloat TX = 0.;\nfloat TY = 1.;\nfloat TZ = 0.;\nfloat TwistY = 0.; //0 to 0.2\nint MirrorX = 1;\nint MirrorY = 1;\nint MirrorZ = 1;\n//Rectange\nint Rectangle = 1;\nfloat RecScale = 1.;\n//Sphere\nint Sphere = 0;\nfloat SphereScale = 1.;\nfloat SphereTX = 0.;\nfloat SphereTY = 0.;\nfloat SphereTZ = 0.;\n//Shapes\nint InfPre = 1;\nint InfPost = 0;\nint Merge = 0;\nfloat ShapeMix = 0.;\nfloat FractalScale = 0.1;\nfloat NearClip = 5.;\n//Color\nint Iterations = 1;\nfloat IHue = 0.;\nfloat Proximity = 0.;\nfloat PHue = 0.;\nfloat Distance = 0.;\nfloat DHue = 0.;\nfloat light = 0.;\nfloat DepthHue = 0.1;\nfloat ProxHue = 0.;\n//Time\nfloat TimeRotX = 1.;\nfloat TimeRotY = 0.25;\nfloat TimeTransX = 0.1;\nfloat TimeTransY = 0.05;\nint TimeEnable = 1;\nint TimeDisabled = 0;\n\n\n\n\n\n\n\n#define MAX_STEPS 50\n\n#define MAX_DIST 25.\n\n#define SURF_DIST .001\n\n#define FRACT_STEPS 20\n\n#define PI 3.14159\n\nfloat map(float x, float inMin, float inMax, float outMin, float outMax) {\n    return (x - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;\n}\n\nvec3 hs(vec3 c, float s){\n    vec3 m=vec3(cos(s),s=sin(s)*.5774,-s);\n    return c*mat3(m+=(1.-m.x)/3.,m.zxy,m.yzx);\n}\n\nmat2 rotate(float a) {\n\n\tfloat c = cos(a),\n\n\t\ts = sin(a);\n\n\treturn mat2(c, -s, s, c);\n\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )  //smooth merges two objects\n\n{\n\nfloat h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\nreturn mix( d2, d1, h ) - k*h*(1.0-h);\n\n}\n\n\n\n//_+_+_+_+_+_+_SHAPING FUNCTIONS_+_+_+_+_+_+_+_\nfloat GetDist(vec3 p) {\n\n\n\n\tfloat d = 1.; //Just to have the d var declaired\n\n//\tfloat perStep = 1/FRACT_STEPS;\n\n\tfor (int i = 0; i < FRACT_STEPS ; i++){\n\nif(InfPre == 1) p = mod(p+2.5, 5.)-2.5;   //Createts infinity\n\n\t\tif(MirrorX == 1) p.x = abs(p.x); //Mirror X\n\t\tif(MirrorY == 1) p.y = abs(p.y); //Mirror Y\n\t\tif(MirrorZ == 1) p.z = abs(p.z); //Mirror Z\n\n\t\tp.x -= TransX\n        +iMouse.x*Range\n        +TimeTransX*sin(iTime*0.2);\n\t\tp.y -= TransY+iMouse.y*Range\n        +iMouse.y*Range\n        +TimeTransY*cos(iTime*0.1);;\n\t\tp.z -= TransZ;\n\n\n\t\tp.xy *= rotate(RotX+sin(iTime*0.2)*TimeRotX); //Audio rct\n\t\tp.xz *= rotate(RotY+cos(iTime*0.1)*TimeRotY);\n\t\tp.yz *= rotate(RotZ);\n\n    p.xz *= rotate(p.y*TwistY); //Twist\n\nif(InfPost == 1)\t\tp = mod(p+2.5, 5.)-2.5;   //Createts infinity\n\n}\n\nif (Sphere == 1){\n\t\tvec4 sphere = vec4(SphereTX, SphereTY, SphereTZ, SphereScale);\n\t  float sphereDist =  length(p-sphere.xyz)-sphere.w;\n    if(Merge == 1) d = opSmoothUnion(sphereDist, d, ShapeMix);\n    else d = min(sphereDist,d);\n  }\n\n\n\t\t if (Rectangle == 1){//Adds in the Rectangle\n\t\t\t vec4 rec = vec4(0.0, 0.0, 0.0, RecScale);\n\t\t\t float recDist = length(max(abs(p) - rec.w, 0.));\n\t\t\t if(Merge == 1) d = opSmoothUnion(recDist, d, ShapeMix);\n       else d = min(recDist,d);\n\t\t }\n\n\n\t\t// d = min(sphereDist,d);\n\n\n\t//}\n    return d;\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd) {\n\tvec3 dO = vec3(NearClip,0.,10.);  //  x = distance ray has traveled, y = Iterations to hit, z = Closest distance to surface\n\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO.x;\n        float dS = GetDist(p);\n        dO.x += dS;\n\t\t\t\tdO.z = min(dS, dO.z);\n\t\t\t\tdO.y = float(i);\n        if(dO.x>MAX_DIST || dS<SURF_DIST) break;\n    }\n\n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 1, -6);\n    //lightPos.xz += vec2(sin(TIME), cos(TIME))*2.; //light movement\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).x;\n    if(d<length(lightPos-p)) dif *= .1;\n\n    return dif;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n{\n\n    if (TimeEnable == 0 && TimeDisabled == 0) {\n    TimeRotX = 0.;\n    TimeRotY = 0.;\n    TimeTransX = 0.;\n    TimeTransY = 0.;\n    int TimeDisabled = 1;\n    }\n    \n\n    vec2 uv = (fragCoord+fragCoord - (iResolution.xy) ) / iResolution.y ;\n    \n\n    vec3 color = vec3(0);\n\n\t\tfloat prox = 0.0;\n\n    vec3 ro = vec3(0, 0, -6+\n      (InfPre+InfPost));  //Audio rct\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    vec3 d = RayMarch(ro, rd);\n\n    vec3 p = ro + rd * d.x;\n\n    float dif = GetLight(p);  //lighting\n    //color = vec3(dif);\t\t\t\t//lighting\n\n\tvec3 n = GetNormal(p);\n\n\n    //+_+_+_+_+_+_+COLORING_+_+_+_+_+_+_\n\n\tcolor.r = (d.y*0.05-(1.-step(d.x*0.04, 1.)))*float(Iterations);\n\n    //color = hs(color, IHue);\n\n    color.g = (1.-(d.z+step(d.x*0.04, 1.)))*Proximity\n    // *1.-tex.r\n    ;//G\n\n    color = hs(color, PHue);\n    color.b = (1.-d.x*0.04)*Distance;\n\n    color = hs(color, DHue);\n    \n    color += dif*light;       //light\n    //color = hs(color, 5.0*dif*light);       //light hue rotate\n    \n    color = hs(color, -n.b);\n    color = hs(color, n.r);\n   //color.r += GetNormal(p)\n\n\t\t  color = hs(color, d.y*DepthHue); //iterations to hue rot\n\n//\t\tcolor -= dif*0.5;\n\n\n\n    fragColor = vec4(color,1.0);\n    \n\n}\n\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flt3z7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1085, 1085, 1159, 1159, 1232], [1234, 1234, 1259, 1259, 1351], [1353, 1353, 1375, 1375, 1441], [1443, 1443, 1525, 1525, 1619], [1623, 1671, 1694, 1694, 2990], [2992, 2992, 3025, 3025, 3387], [3389, 3389, 3413, 3413, 3594], [3596, 3596, 3620, 3620, 3937], [3941, 3941, 3999, 3999, 5222]], "test": "untested"}
{"id": "flt3WB", "name": "Trapped Light", "author": "dr2", "description": "Light cone (mouseable)", "tags": ["illumination", "lightcone"], "likes": 16, "viewed": 308, "published": 3, "date": "1636646130", "time_retrieved": "2024-07-30T18:48:59.619913", "image_code": "// \"Trapped Light\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0  // (= 0/1) optional antialising\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRound4Box2Df (vec2 p, vec2 b, float r);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrConCylDf (vec3 p, vec2 cs, float r, float h);\nfloat PrAnConCylDf (vec3 p, vec2 cs, float r, float w, float h);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec4 Hashv4v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit, rmSize, ltPos, ltPosF;\nvec2 coneCs;\nfloat tCur, dstFar, szFac, sLoop, dLoop, aLoop, hBase, lEnd, tubRot;\nfloat coneHt[2], coneRd[2];\nint idObj;\nconst int idRm = 1, idBar = 2, idLit = 3, idLitF = 4, idTube = 5, idEx = 6, idEnd = 7, idCon = 8;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvoid SetObjConf ()\n{\n  float t;\n  t = tCur / 30. + 0.5;\n  tubRot = mod (15. * t, 2. * pi);\n  t = mod (t, 1.);\n  sLoop = (1. / 1.4) / (0.01 + 0.99 * SmoothBump (0.25, 0.75, 0.15, t));\n  aLoop = 0.25 * pi / sLoop;\n  dLoop = 6. * sLoop;\n  lEnd = 1.;\n  hBase = - (6. * (0.5 * pi) + 4. * lEnd) * (1. - SmoothBump (0.1, 0.9, 0.08, t));\n  coneCs = sin (-0.17 * pi + 0.07 * pi * sin (1.5 * pi * tCur) + vec2 (0.5 * pi, 0.));\n  coneHt[0] = 0.8 * coneCs.x;\n  coneRd[0] = 0.3 - 0.8 * coneCs.y;\n  coneHt[1] = 50. * 0.8 * coneCs.x;\n  coneRd[1] = 0.95 * 0.3 - 0.8 * coneCs.y;\n  szFac = 0.5;\n  ltPos = vec3 (0., 2. * lEnd + 0.75 + coneHt[0], 0.);\n  ltPos.xy = Rot2D (Rot2D (ltPos.xy - vec2 (dLoop, 0.), - aLoop), - (aLoop - 0.5 * pi)) +\n     vec2 (0., dLoop);\n  ltPos.xy = ltPos.yx * vec2 (1., -1.);\n  ltPos.y += 2. * lEnd + hBase + 0.3;\n  ltPos.xz = Rot2D (ltPos.xz, - tubRot);\n  ltPos *= szFac;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, rCyl, rc, s, dc, dy, db;\n  dMin = dstFar;\n  q = p;\n  q.y -= rmSize.y - 0.4;\n  db = PrBoxDf (q, rmSize);\n  d = abs (db) - 0.4;\n  q.xz = mix (q.zx, q.xz, step (abs (q.z), abs (q.x)));\n  d = max (max (d, - PrBox2Df (q.zy, vec2 (2.5, 5.))), min (2.5 - length (abs (q.xz) - 15.), q.y));\n  DMINQ (idRm);\n  d = min (length (vec2 (abs (q.x) - rmSize.x + 0.15, q.z)),\n     length (vec2 (abs (q.x) - rmSize.x + 0.15, abs (q.y) - 1.8))) - 0.2;\n  q = vec3 (abs (q.xz) - 15., q.y - rmSize.y + 0.15).xzy;\n  d = max (min (d, min (length (q.xy), length (q.zy)) - 0.15), db);\n  DMINQ (idBar);\n  q = p - ltPosF;\n  q.y -= 1.;\n  d = PrCapsDf (q.xzy, 1., 0.5);\n  DMINQ (idLitF);\n  dMin /= szFac;\n  p /= szFac;  // (from \"Metallic Tubeworms\")\n  rCyl = 0.6;\n  rc = 0.6;\n  q = p;\n  dy = - q.y;\n  q.y -= 0.3;\n  d = max (PrRoundCylDf (q.xzy, rCyl + 0.4, 0.1, 0.3), dy);\n  DMINQ (idEx);\n  q = p;\n  q.y -= 2. * lEnd + hBase + 0.3;\n  s = mod (3. * q.y + 0.5, 1.);\n  d = max (max (PrRound4Box2Df (q.xz, vec2 (rCyl * (1. - 0.03 * SmoothBump (0.2, 0.8, 0.15, s))) -\n     rc, rc), abs (q.y + lEnd) - lEnd - 0.01), dy);\n  DMINQ (idEnd);\n  q.xz = Rot2D (q.xz, tubRot);\n  q.xy = Rot2D (q.yx * vec2 (-1., 1.) - vec2 (0., dLoop), aLoop - 0.5 * pi);\n  s = mod (3. * dLoop * atan (q.y, - q.x) + 0.5, 1.);\n  qq = q;\n  dc = dot (vec2 (q.x, abs (q.y)), sin (aLoop + vec2 (0., 0.5 * pi)));\n  q.xz = Rot2D (vec2 (length (q.xy) - dLoop, q.z), tubRot);\n  d = max (max (PrRound4Box2Df (q.xz, vec2 (rCyl * (1. - 0.03 * SmoothBump (0.2, 0.8, 0.15, s)) -\n     rc), rc), dc), dy);\n  DMINQ (idTube);\n  q = qq;\n  q.xy = Rot2D (q.xy, aLoop) + vec2 (dLoop, 0.);\n  q.xz = Rot2D (q.xz, - tubRot);\n  s = mod (3. * q.y + 0.5, 1.);\n  d = max (max (PrRound4Box2Df (q.xz, vec2 (rCyl * (1. - 0.03 * SmoothBump (0.2, 0.8, 0.15, s))) -\n     rc, rc), abs (q.y - lEnd) - lEnd - 0.01), dy);\n  DMINQ (idEnd);\n  q.y -= 2. * lEnd + 0.1;\n  d = PrRoundCylDf (q.xzy, rCyl + 0.1, 0.05, 0.05);\n  DMINQ (idEx);\n  q.y -= 0.2;\n  d = PrCapsDf (q.xzy, 0.35, 0.25);\n  DMINQ (idEx);\n  q.y -= 0.4 + coneHt[0];\n  d = PrAnConCylDf (q.xzy, coneCs, coneRd[0], 0.05, coneHt[0]);\n  d = max (d, min (0.05 - min (abs (q.x), abs (q.z)), 0.5 * coneHt[0] -\n     abs (q.y - 0.1 * coneHt[0])));\n  DMINQ (idCon);\n  d = PrCapsDf (q.xzy, 0.4, 0.2);\n  DMINQ (idLit);\n  dMin *= szFac;\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.005, -0.005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat TrObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar / szFac;\n  p /= szFac;\n  q = p;\n  q.y -= 2. * lEnd + hBase + 0.3;\n  q.xz = Rot2D (q.xz, tubRot);\n  q.xy = Rot2D (Rot2D (q.yx * vec2 (-1., 1.) - vec2 (0., dLoop), aLoop - 0.5 * pi), aLoop) +\n     vec2 (dLoop, 0.);\n  q.y -= 2. * lEnd + 0.75 + coneHt[0];\n  d = max (PrConCylDf (q.xzy, coneCs, coneRd[1], coneHt[1]), coneHt[0] - q.y);\n  DMINQ (idCon);\n  dMin *= szFac;\n  return dMin;\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 60; j ++) {\n    d = TrObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 TrObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.005, -0.005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = TrObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dMax)\n{\n  float sh, d, h;\n  int idObjT;\n  sh = 1.;\n  d = 0.01;\n  idObjT = idObj;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dMax) break;\n  }\n  idObj = idObjT;\n  return 0.7 + 0.3 * sh;\n}\n\nvec3 ShStagGrid (vec2 p)\n{\n  vec2 sp, ss;\n  if (2. * floor (0.5 * floor (p.y)) != floor (p.y)) p.x += 0.5;\n  sp = smoothstep (0.03, 0.07, abs (fract (p + 0.5) - 0.5));\n  p = fract (p) - 0.5;\n  ss = 0.3 * smoothstep (0.4, 0.5, abs (p.xy)) * sign (p.xy);\n  if (abs (p.x) < abs (p.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, sp.x * sp.y, ss.y);\n}\n\nvec4 ShStagGrid3d (vec3 p, vec3 vn)\n{\n  vec3 rg;\n  if (abs (vn.x) > 0.99) {\n    rg = ShStagGrid (p.zy);\n    rg.xz *= sign (vn.x);\n    if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n    else vn.xz = Rot2D (vn.xz, rg.x);\n  } else if (abs (vn.y) > 0.99) {\n    rg = ShStagGrid (p.zx);\n    rg.xz *= sign (vn.y);\n    if (rg.x == 0.) vn.yx = Rot2D (vn.yx, rg.z);\n    else vn.yz = Rot2D (vn.yz, rg.x);\n  } else if (abs (vn.z) > 0.99) {\n    rg = ShStagGrid (p.xy);\n    rg.xz *= sign (vn.z);\n    if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n    else vn.zx = Rot2D (vn.zx, rg.x);\n  }\n  return vec4 (vn, rg.y);\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > -0.02 && rd.y < 0.04 * Fbm1 (32. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.4, 0.5);\n  } else {\n    q = 0.01 * (ro.xz + 2. * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.3, 0.4, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, rg4;\n  vec3 col, vn, roo, rdo, ltDir, ltAx;\n  float dstGrnd, dstObj, dstTrObj, nDotL, sh, ltDst, att;\n  SetObjConf ();\n  ltPosF = vec3 (0., 2. * rmSize.y - 1.8, 0.);\n  roo = ro;\n  rdo = rd;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = vec4 (1., 1., 0.9, 0.2);\n    if (idObj == idTube || idObj == idEnd) {\n      col4 = col4 * (0.93 + 0.07 * smoothstep (-0.1, 0., cos (32. * atan (qHit.z, - qHit.x))));\n    } else if (idObj == idEx) {\n      col4 *= 0.95;\n    } else if (idObj == idCon) {\n      col4 = (PrConCylDf (qHit.xzy, coneCs, coneRd[0], coneHt[0]) < 0.) ?\n         vec4 (0.8 + 0.2 * sin (32. * pi * tCur), 0., 0., -1.) : col4 *\n         (0.9 + 0.1 * smoothstep (-0.7, -0.6, cos (64. * qHit.y)));\n    } else if (idObj == idBar) {\n      col4 = vec4 (0.9, 0.5, 0.2, 0.1);\n    } else if (idObj == idRm) {\n      col4 = (abs (vn.y) < 0.99) ? vec4 (1., 1., 0.9, 0.2) : ((vn.y > 0.) ?\n         vec4 (1., 0.8, 0.8, 0.2) : vec4 (0.8, 1., 0.8, 0.2) * (0.8 + 0.2 * smoothstep (0., 1.,\n         length (ro.xz) - 1.)));\n      rg4 = ShStagGrid3d (ro, vn);\n      vn = rg4.xyz;\n      vn = VaryNf (4. * ro, vn, 0.2);\n      col4.rgb *= 0.9 + 0.1 * rg4.w;\n    } else if (idObj == idLit) {\n      col4 = vec4 (1., 1., 0.9, -1.);\n    } else if (idObj == idLitF) {\n      col4 = vec4 (1., 1., 0.9, -1.);\n    }\n    if (col4.a >= 0.) {\n      ltDir = ltPosF - ro;\n      ltDst = length (ltDir);\n      ltDir = normalize (ltDir);\n      att = 1. / (1. + 0.002 * ltDst * ltDst);\n      sh = ObjSShadow (ro + 0.01 * vn, ltDir, ltDst - 2.);\n      nDotL = max (dot (vn, ltDir), 0.);\n      col = att * (col4.rgb * (0.2 + 0.8 * sh * nDotL * nDotL) +\n         step (0.95, sh) * col4.a * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.));\n      if (idObj <= idBar) {\n        ltDir = ltPos - ro;\n        ltDst = length (ltDir);\n        ltDir = normalize (ltDir);\n        ltAx = vec3 (0., -1., 0.);\n        ltAx.xy = Rot2D (ltAx.xy, -2. * aLoop);\n        ltAx.xz = Rot2D (ltAx.xz, - tubRot);\n        att = smoothstep (-0.1, 0.2, dot (ltAx, ltDir) - coneCs.x) *\n           step (- dot (vn, ltDir), 0.) / (1. + 0.002 * ltDst * ltDst);\n        col = mix (col, att * (col4.rgb * max (dot (vn, ltDir), 0.) +\n           col4.a * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.)), 0.5);\n      }\n    } else col = col4.rgb * (0.6 - 0.4 * dot (vn, rd));\n  } else if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    col = 0.5 * mix (vec3 (0.8, 1., 0.5), vec3 (0.7, 0.9, 0.5), 0.2 +\n       0.8 * smoothstep (0.3, 0.7, Fbm2 (4. * ro.xz)));\n    vn = VaryNf (16. * ro, vec3 (0., 1., 0.), 1. - smoothstep (0.5, 0.8, dstGrnd / dstFar));\n    col *= 0.2 + 0.8 * max (dot (vn, sunDir), 0.);\n    col = mix (col, vec3 (0.3, 0.4, 0.5), pow (1. + rd.y, 16.));\n  } else {\n    col = SkyBgCol (ro, rd);\n  }\n  ro = roo;\n  rd = rdo;\n  dstTrObj = TrObjRay (ro, rd);\n  if (dstTrObj < min (dstObj, dstFar)) {\n    ro += dstTrObj * rd;\n    vn = TrObjNf (ro);\n    ltDst = length (ro - ltPos);\n    att = 1. / (1. + 0.2 * ltDst * ltDst);\n    col = mix (col, vec3 (1., 1., 0.8), 0.3 * max (- dot (vn, rd), 0.) *\n       att * (1. - smoothstep (-0.3, -0.1, dstTrObj - dstObj)));\n  }\n  ltAx = vec3 (0., -1., 0.);\n  ltAx.xy = Rot2D (ltAx.xy, -2. * aLoop);\n  ltAx.xz = Rot2D (ltAx.xz, - tubRot);\n  col = mix (col, vec3 (1., 1., 0.9), 0.15 * smoothstep (-0.1, 0.2,\n     dot (ltAx, normalize (ltPos - roo)) - coneCs.x));\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv;\n  float el, az, zmFac, asp, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  el = 0.;\n  az = 0.27 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  el = clamp (el, -0.44 * pi, 0.45 * pi);\n  vuMat = StdVuMat (el, az);\n  rmSize = vec3 (20.4, 9.4, 20.4);\n  ro = vec3 (-17., 9., -17.);\n  sunDir = normalize (vec3 (1., 1., -1.));\n  zmFac = 2.1;\n  dstFar = 100.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi)) / zmFac;\n    rd = vuMat * normalize (vec3 ((2. * tan (0.5 * atan (uvv.x / asp))) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRound4Box2Df (vec2 p, vec2 b, float r)\n{\n  p = max (abs (p) - b, 0.);\n  return sqrt (length (p * p)) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrConCylDf (vec3 p, vec2 cs, float r, float h)\n{\n  return max (dot (vec2 (length (p.xy) - r, p.z), cs), abs (p.z) - h);\n}\n\nfloat PrAnConCylDf (vec3 p, vec2 cs, float r, float w, float h)\n{\n  return max (abs (dot (vec2 (length (p.xy) - r, p.z), cs)) - w, abs (p.z) - h);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39);\n  return fract (sin (dot (p, cHashVA2) + vec4 (0., cHashVA2.xy, cHashVA2.x + cHashVA2.y)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flt3WB.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1189, 1189, 1209, 1209, 2072], [2074, 2074, 2096, 2096, 4426], [4428, 4428, 4461, 4461, 4644], [4646, 4646, 4667, 4667, 4922], [4924, 4924, 4948, 4948, 5373], [5375, 5375, 5410, 5410, 5594], [5596, 5596, 5619, 5619, 5876], [5878, 5878, 5927, 5927, 6218], [6220, 6220, 6246, 6246, 6573], [6575, 6575, 6612, 6612, 7173], [7175, 7175, 7209, 7209, 7966], [7968, 7968, 8003, 8003, 11474], [11476, 11476, 11529, 11529, 12661], [12663, 12663, 12695, 12695, 12795], [12797, 12797, 12830, 12830, 12919], [12921, 12921, 12969, 12969, 13036], [13038, 13038, 13095, 13095, 13171], [13173, 13173, 13216, 13216, 13280], [13282, 13282, 13336, 13336, 13409], [13411, 13411, 13476, 13476, 13559], [13561, 13561, 13597, 13597, 13803], [13805, 13805, 13835, 13835, 13948], [13950, 13950, 14007, 14007, 14090], [14124, 14124, 14148, 14148, 14201], [14203, 14203, 14227, 14227, 14339], [14341, 14341, 14365, 14365, 14502], [14504, 14504, 14529, 14529, 14675], [14677, 14677, 14702, 14702, 14888], [14890, 14890, 14912, 14912, 15066], [15068, 15068, 15089, 15089, 15244], [15246, 15246, 15275, 15275, 15487], [15489, 15489, 15528, 15528, 15780]], "test": "untested"}
{"id": "fltGDS", "name": "入门之路-15", "author": "jialouluo", "description": "这个有个小问题，我还没解决，我想把右上角和左下角的重复纹理去除掉，这样看起来会更立体一点，但是目前我还找不到方法，先留在这，等以后再来解决。。。。如果有大佬能帮我解决这个小问题，我会非常感谢。TAT", "tags": [], "likes": 1, "viewed": 218, "published": 3, "date": "1636637008", "time_retrieved": "2024-07-30T18:49:00.385865", "image_code": "#define PI 3.14159265\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv -= 0.5;\n    float radius = fract(iTime*0.5);\n    float dis = length(uv);\n    float bate = atan(uv.y, uv.x) + radians(1.-fract\n    (iTime*0.5 ) ) * 200. * (radius - dis) / radius ;\n    if(dis <= radius) {\n        uv = dis * vec2(cos(bate), sin(bate));\n         fragColor = texture(iChannel1, uv - 0.5);\n    }else{\n        fragColor = texture(iChannel0,  uv - 0.5);\n    }\n        \n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fltGDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 77, 77, 507]], "test": "untested"}
{"id": "7lsXRM", "name": "lovely julia", "author": "Shellderr", "description": "distorted Julia with some feedback", "tags": ["fractal", "julia"], "likes": 4, "viewed": 240, "published": 3, "date": "1636630881", "time_retrieved": "2024-07-30T18:49:01.169769", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define res iResolution\n#define thresh 20.\n#define stop 200\n\nvec3 rgb(float a){\n    a *=8.;\n    return(cos(4.+a+vec3(0.,2.,4.)*.7)*.5+.5);\n}\n\nvec2 cmul(vec2 a, vec2 b){\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2){\n    float a = (v1.x*v2.x+v1.y*v2.y)/(v2.x*v2.x+v2.y*v2.y);\n    float b = (v1.y*v2.x-v1.x*v2.y)/(v2.x*v2.x+v2.y*v2.y);\n    return vec2(a,b);\n}\n\nvec2 cexp(vec2 z){\n    return exp(z.x)*vec2(cos(z.y),sin(z.y));\n}\n\nvec2 clog(vec2 z){\n    return vec2(log(length(z)),atan(z.y,z.x));\n}\n\nvec2 cpow(vec2 z, float c){\n    return cexp(c*clog(z));\n}\n\n\nvec2 clerp(vec2 a, vec2 b, float m){\n    m = clamp(m,0.,1.);\n    return cmul(vec2(1.-m),a)+cmul(vec2(m),b);\n}\n\n\nvec2 rot(vec2 v, float t){\n    float a = (1.*atan(v.x,v.y))+t;\n    return vec2(cos(a),sin(a))*length(v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    vec2 z = .8*(2.*fragCoord.xy-res.xy)/res.y;\n    // z = rot(z,time);\n    //vec2 zz = vec2(0);\n    z = clerp(.3*clog(vec2(2)+z), (cdiv(vec2(.5),z)), .1);\n    // z = cexp(cmul(z,vec2(.4)));\n    z=rot(z,iTime*.3);\n    vec2 mouse = .5*iMouse.xy/res.xy;\n    vec2 c = mouse.xy==vec2(0)? vec2(-.77,-.22)/*vec2(cos(iTime*.4)-.3,-.66)*/: (2.*mouse.xy-1.);\n    int i = 0;\n    for(i; i < stop; i++){\n        z = cmul(z,z)+c;\n        if(length(z) > thresh)\n            break;\n    }\n    vec3 col = rgb(log(.9+float(i)/380.)*2.);\n    vec3 fb = texture(iChannel0, fragCoord.xy/iResolution.xy*.995).xyz;\n//    fragColor = vec4(col-fb*.2, 1.0 );\n    // vec3 oc =  ((.7+.3*col)/(col-fb));\n     vec3 oc =  iFrame > 4 ? 1./fb-(col/fb) : col;;\n //    vec3 oc =  fb-(col/fb);\n //    vec3 oc =  1./fb*(col/fb);\n \n \n    fragColor = vec4(oc*.1+.08*col*(.6+.99*oc), 1.0 ); \n    // fragColor = vec4(oc*.05+.9*col*(.4+.7*oc), 1.0 ); //--\n\n}\n\n\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lsXRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 124]], "test": "untested"}
{"id": "sdVGzK", "name": "trackmania car", "author": "mdb", "description": "trakmania car with raymarching\n\nif someone knows how to reduce compilation time I would be very happy to know (take about 1min10 to compile currently).", "tags": ["raytracing", "raymarching", "car", "trackmania", "tmnf"], "likes": 24, "viewed": 442, "published": 3, "date": "1636629695", "time_retrieved": "2024-07-30T18:49:02.125215", "image_code": "\n//ray tracing///////////////////////////////////////////////////////////////////////////\nstruct AABB{vec3 down, up;};\nAABB centerDim(vec3 center, vec3 dim){return AABB(center - 0.5*dim, center + 0.5*dim);}\nvec2 box(vec3 ro, vec3 rd, AABB aabb){\n        \n        vec3 dirfrac = 1.0 / rd;\n        vec3 t1 = (aabb.down - ro)*dirfrac;\n        vec3 t2 = (aabb.up - ro)*dirfrac;\n        \n        vec3 t3 = min(t1, t2);\n        vec3 t4 = t1 + t2 - t3;\n\n        float tmin = max(max(t3.x, t3.y), t3.z);\n        float tmax = min(min(t4.x, t4.y), t4.z);\n\n        if (tmax < 0.0 || tmin > tmax) return vec2(FALSE);\n\n        return vec2(tmin, tmax);\n}\nvec3 boxNormal(vec3 pos, AABB b){\n    pos -= 0.5*(b.up + b.down);\n    pos /= 0.5*abs(b.up - b.down);\n    vec3 n = vec3(0.0);\n    if(abs(pos.x)>0.995){n.x = pos.x;}\n    if(abs(pos.y)>0.995){n.y = pos.y;}\n    if(abs(pos.z)>0.995){n.z = pos.z;}\n    n = normalize(n);\n    return n;\n}\n\nfloat cylinder( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n                 in vec3 pa, in vec3 pb, float ra ) {\n    vec3 ca = pb-pa;\n    vec3 oc = ro-pa;\n\n    float caca = dot(ca,ca);\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    \n    float a = caca - card*card;\n    float b = caca*dot( oc, rd) - caoc*card;\n    float c = caca*dot( oc, oc) - caoc*caoc - ra*ra*caca;\n    float h = b*b - a*c;\n    \n    if (h < 0.) return FALSE;\n    \n    h = sqrt(h);\n    float d = (-b-h)/a;\n\n    float y = caoc + d*card;\n    if (y > 0. && y < caca && d >= distBound.x && d <= distBound.y) {\n        normal = (oc+d*rd-ca*y/caca)/ra;\n        return d;\n    }\n\n    d = ((y < 0. ? 0. : caca) - caoc)/card;\n    \n    if( abs(b+a*d) < h && d >= distBound.x && d <= distBound.y) {\n        normal = normalize(ca*sign(y)/caca);\n        return d;\n    } else {\n        return FALSE;\n    }\n}\n\nvec2 iBox(vec3 ro, vec3 rd, AABB aabb, out vec3 normal){\n        \n        vec3 dirfrac = 1.0 / rd;\n        vec3 t1 = (aabb.down - ro)*dirfrac;\n        vec3 t2 = (aabb.up - ro)*dirfrac;\n        \n        vec3 t3 = min(t1, t2);\n        vec3 t4 = t1 + t2 - t3;\n\n        float tmin = max(max(t3.x, t3.y), t3.z);\n        float tmax = min(min(t4.x, t4.y), t4.z);\n\n        if (tmax < 0.0 || tmin > tmax) return vec2(FALSE);\n        \n        vec3 pos = ro + tmin*rd;\n        pos -= 0.5*(aabb.up + aabb.down);\n        pos /= 0.5*abs(aabb.up - aabb.down);\n        normal = vec3(0.0);\n        if(abs(pos.x)>0.995){normal.x = pos.x;}\n        if(abs(pos.y)>0.995){normal.y = pos.y;}\n        if(abs(pos.z)>0.995){normal.z = pos.z;}\n        normal = normalize(normal);\n\n        return vec2(tmin, tmax);\n}\n\n//ray marching//////////////////////////////////////////////////////////////////////////\n// from https://www.shadertoy.com/view/Xds3zN\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k )\n{\n    float h = clamp((b - a) / k + 0.5, 0.0, 1.0);\n    return mix(a, b, h) + h * (1.0 - h) * k * 0.5;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n//parts//////////////////////////////////////////////////////////////////////////////////\n#ifdef CAR\nfloat sdfBody(vec3 pos){\n    vec3 p = pos; // main body\n    p = mat3x3(1.0, 0.0, 0.0,\n               0.0, 0.9987, 0.0507,\n               0.0, -0.0507, 0.9987) * pos;\n    p.y += 0.1*pow(max(-p.z, 0.0), 3.0);\n    float d = sdEllipsoid( p - vec3(0.0, 0.250172, 0.034988), vec3(0.214086, 0.167228, 1.03));\n    //bottom plate\n    #ifdef DETAILCAR\n    p = pos - vec3(0.0, 0.150917, -0.530452);\n    d = min(d, sdBox(p , vec3(0.170919, 0.032961, 0.121223)) - 0.02);\n    \n    //front wing (down)\n    p = pos - vec3(0.003025, 0.133558, -0.895936);\n    p.yz = mat2x2(0.6691, 0.7431, -0.7431, 0.6691) * p.yz;\n    d = smin(d, sdBox(p , vec3(0.22312, 0.003805, 0.035775)), 0.05);\n    //front wing (up)\n    p = pos - vec3(0.004898, 0.189705, -0.796952);\n    p.yz = mat2x2(0.9205, 0.3907, -0.3907, 0.9205) * p.yz;\n    d = smin(d, sdBox(p , vec3(0.154266, 0.003941, 0.062824)), 0.02);\n    //antena\n    p = pos - vec3(0.091767, 0.39, -0.440064);\n    d = smin(d, sdCylinder(p, vec2(0.003316, 0.042221)), 0.01);\n    #endif\n    //middle bump\n    p = pos - vec3(0.0, 0.434555, 0.394036);\n    p.yz = mat2x2(0.9945, -0.1045, 0.1045, 0.9945) * p.yz;\n    d = smin(d, sdEllipsoid(p , vec3(0.09712, 0.09712, 0.426178)), 0.07);\n    //glass\n    p = pos - vec3(0.0, 0.323151, 0.000632);\n    d = min(d, sdEllipsoid(p , vec3(0.144777, 0.132625, 0.405275)));\n    \n    //cokpit (void)\n    p = pos - vec3(-0.001684, 0.4563, 0.107312);\n    float c = sdBox(p, vec3(0.153123, 0.253123, 0.21701));\n    d = smax(d, -c, 0.05);\n    //side bump\n    vec3 ps = vec3(abs(pos.x), pos.y, pos.z);\n    p = ps - vec3(0.178125, 0.332702, 0.368919);\n    d = smin(d, sdEllipsoid(p , vec3(0.09712, 0.09712, 0.426178)), 0.03);\n    #ifdef DETAILCAR\n    //air entry 1 (void)\n    p = ps - vec3(0.232716, 0.336058, 0.263102);\n    p.xz = mat2x2(0.9980, -0.0627, 0.0627, 0.9980) * p.xz;\n    d = smax(d, -sdEllipsoid(p , vec3(0.048859, 0.065034, 0.327925)), 0.05);\n    #endif\n    //side air entry construction:\n    //big shape\n    p = ps - vec3(0.005926, 0.167606, -0.025842);\n    float bs = sdEllipsoid(p , vec3(0.414984, 1.0, 1.0));\n    bs = max(bs, -c);;\n    //top\n    bs = smax(bs, pos.y - 0.32 + max(0.0, 0.07/(1.0 + exp(10.0*(pos.z - 0.1)))), 0.03);\n    //bottom\n    bs = smax(bs, -pos.y + 0.1 + max(0.0, 0.3*(pos.z - 0.33)), 0.03);\n    //front\n    bs = smax(bs, -dot(ps - vec3(0.0, 0.0,-0.4), normalize(vec3(-0.5, -0.5, 1.0))), 0.01);\n    //air entry 2 void\n    #ifdef DETAILCAR\n    p = ps - vec3(0.30883, 0.17531, -0.281175);\n    bs = smax(bs, -sdBox(p, vec3(0.086429, 0.058429, 0.318638)), 0.02);\n    #endif\n    d = smin(d, bs, 0.02);\n    \n    //top cover\n    p = pos.xzy - vec3(-0.0, 0.380554, 0.340222);\n    d = min(d, sdRhombus(p, 0.073637, 0.103637, 0.047325, 0.1));\n    #ifdef DETAILCAR\n    //engine top\n    p = ps  - vec3(0.090865, 0.430824, 0.585795);\n    p.xz = mat2x2(0.9997, 0.0209, -0.0209, 0.9997) * p.xz;\n    p.xy = mat2x2(0.8090, 0.5877, -0.5877, 0.8090) * p.xy;\n    p.zy = mat2x2(0.9822, 0.1873, -0.1873, 0.9822) * p.zy;\n    d = min(d, sdBox(p, vec3(0.040173, 0.022703, 0.133894)) - 0.002);\n    //block under\n    p = pos - vec3(0.0, 0.156481, 0.518026);\n    d = min(d, sdBox(p, vec3(0.20718, 0.074986, 0.300785)) - 0.001);\n    #endif\n    //back cut\n    d = max(d, -dot(ps - vec3(0.0, 0.0, 0.529344), vec3(0.0, 0.85716, -0.5150)));\n    d = max(d, -dot(ps - vec3(0.0, 0.0, 0.89541), vec3(0.0, -0.1045, -0.9945)));\n    \n    //back under 1\n    p = ps - vec3(0.192716, 0.143408, 0.570004);\n    d = min(d, sdBox(p, vec3(0.00652, 0.067714, 0.25495)) - 0.001);\n    d = smax(d, -dot(ps - vec3(0.0, 0.0, 0.598839), vec3(0.0, 0.8386, -0.5446)), 0.05);\n    //back under 2\n    p = ps - vec3(0.069967, 0.147173, 0.616744);\n    d = min(d, sdBox(p, vec3(0.007172, 0.078738, 0.25495)) - 0.001);\n    d = smax(d, -dot(ps - vec3(0.0, 0.0, 0.118614), vec3(0.0, 0.9876, -0.1564)), 0.08);\n    \n    //back box\n    p = pos - vec3(0.0, 0.267777, 0.623707);\n    d = min(d, sdBox(p, vec3(0.137705, 0.022871, 0.24837)) - 0.001);\n    #ifdef DETAILCAR\n    //back smoke out\n    p = pos - vec3(0.0, 0.389587, 0.896463);\n    p.yz = mat2x2(0.9848, -0.1736, 0.1736, 0.9848) * p.yz;\n    d = smax(d, -sdBox(p, vec3(0.091775, 0.086516, 0.094237)), 0.06);\n    \n    p = ps - vec3(0.042621, 0.35046, 0.787099);\n    d = min(d, sdBox(p, vec3(0.031889, 0.011231, 0.072799)) - 0.005);\n    d = max(d, -sdBox(p, vec3(0.031889, 0.011231, 0.092799)));\n    \n    //back rombus top\n    p = ps.xzy - vec3(0.01, 0.727141, 0.390539);\n    d = min(d, sdRhombus(p, 0.031889, 0.011231, 0.092799, 0.001));\n    \n    //back pipe\n    p = ps;\n    d = min(d, sdCapsule(p, vec3(0.16925, 0.27345, 0.905582), vec3(-0.16925, 0.27345, 0.905582), 0.01));\n    d = smin(d, sdCapsule(p, vec3(0.211834, 0.294284, 0.808042), vec3(0.16925, 0.27345, 0.905582), 0.01), 0.01);\n    \n    //back wind\n    p = ps - vec3(0.002531, 0.469511, 0.871087);\n    p.yz = mat2x2(0.9923, 0.1236, -0.1236, 0.9923) * p.yz;\n    \n    float w2 = sdBox(p, vec3(0.20705, 0.00505, 0.082297));\n    p +=vec3(0.0, 0.01, 0.02);\n    w2 = smin(w2, sdBox(p, vec3(0.15705, 0.00505, 0.052297)), 0.05);\n    \n    p = ps - vec3(0.264567, 0.429921, 0.872511);\n    p.zy = mat2x2(0.9702, 0.0697, -0.0697, 0.9702) * p.zy;\n    p.xy = mat2x2(0.6427, -0.7660, 0.7660, 0.6427) * p.xy;\n    w2 = smin(w2, sdBox(p, vec3(0.004028, 0.060656, 0.077419)), 0.05);\n    d = min(d, w2);\n    //baxk wind support\n    p = ps - vec3(0.177204, 0.361375, 0.858586);\n    p.zy = mat2x2(0.9205, 0.3907, -0.3907, 0.9205) * p.zy;\n    d = smin(d, sdBox(p, vec3(0.003402, 0.125143, 0.025331)), 0.02);\n    #endif\n    \n    return d;\n}\n\nvec4 body(vec3 ro, vec3 rd, vec2 bounds){\n    float t = max(bounds.x, 0.0);\n    for(int i = 0; i < 100; i++){\n        float d = sdfBody(ro + rd*t);\n        t += d;\n        if(abs(d) < 0.001) return vec4(t);\n        if(t > bounds.y) break;\n    }\n    return vec4(FALSE);\n\n}\n\n#ifdef WHEELS\nfloat sdfWheel(vec3 pos){\n   \n    pos.yz = mat2x2(cos(ti), sin(ti), -sin(ti), cos(ti)) * pos.yz;\n    vec3 p = pos.zxy;\n    \n    float d = sdCylinder(p, vec2(0.164666, 0.08047)) - 0.02; // outer ring\n    d = smax(d, -sdCylinder(p, vec2(0.106692, 0.19047)), 0.05);  //inner void\n    d = min(d, sdCylinder(p, vec2(0.053409, 0.06047)) - 0.01); //inner cyclinder 1\n    d = min(d, sdCylinder(p, vec2(0.04409, 0.08047)));\n    //wheel segment\n    vec3 ps = pos; ps.x = abs(ps.x);\n    d = min(d, sdBox(ps - vec3(0.05, 0.0, 0.0), vec3(0.011874, 0.020373, 0.1459)));\n    d = min(d, sdBox(ps - vec3(0.05, 0.0, 0.0), vec3(0.011874, 0.1459, 0.020373)));\n    \n    return d;\n}\n\n\nvec4 wheel(vec3 ro, vec3 rd, vec2 bounds, vec3 center){\n    float t = max(0.0, bounds.x);\n    for(int i = 0; i < 100; i++){\n        float d = sdfWheel(ro + rd*t - center);\n        t += d;\n        if(abs(d) < 0.001) return vec4(t);\n        if(t > bounds.y) break;\n    }\n    return vec4(FALSE);\n\n}\n#endif\n\nvec4 frontSuspension(vec3 ro, vec3 rd, vec2 bounds, out vec3 normal){\n    float d = 1e5;\n    float c; vec3 n;\n    //left\n    c = cylinder(ro, rd, bounds, n, vec3(0.135909, 0.257544, -0.594238), \n                                    vec3(0.334025, 0.193496, -0.786161), 0.01);\n    if(accept(c)){d = c; normal = n;}\n    c = cylinder(ro, rd, bounds, n, vec3(0.050552, 0.222349, -0.804578), \n                                    vec3(0.387557, 0.222571, -0.812828), 0.01);\n    if(accept(c)){d = c; normal = n;}\n    c = cylinder(ro, rd, bounds, n, vec3(0.108501, 0.251853, -0.728061), \n                                    vec3(0.354193, 0.154254, -0.824183), 0.007);\n    if(accept(c)){d = c; normal = n;}\n    c = cylinder(ro, rd, bounds, n, vec3(0.111717, 0.163316, -0.824627), \n                                    vec3(0.354193, 0.154254, -0.824183), 0.015);\n    if(accept(c)){d = c; normal = n;}\n    c = cylinder(ro, rd, bounds, n, vec3(0.14054, 0.162967, -0.686332), \n                                    vec3(0.354193, 0.154254, -0.824183), 0.01);\n    if(accept(c)){d = c; normal = n;}\n    \n    //left\n    c = cylinder(ro, rd, bounds, n, vec3(-0.135909, 0.257544, -0.594238), \n                                    vec3(-0.334025, 0.193496, -0.786161), 0.01);\n    if(accept(c)){d = c; normal = n;}\n    c = cylinder(ro, rd, bounds, n, vec3(-0.050552, 0.222349, -0.804578), \n                                    vec3(-0.387557, 0.222571, -0.812828), 0.01);\n    if(accept(c)){d = c; normal = n;}\n    c = cylinder(ro, rd, bounds, n, vec3(-0.108501, 0.251853, -0.728061), \n                                    vec3(-0.354193, 0.154254, -0.824183), 0.007);\n    if(accept(c)){d = c; normal = n;}\n    c = cylinder(ro, rd, bounds, n, vec3(-0.111717, 0.163316, -0.824627), \n                                    vec3(-0.354193, 0.154254, -0.824183), 0.015);\n    if(accept(c)){d = c; normal = n;}\n    c = cylinder(ro, rd, bounds, n, vec3(-0.14054, 0.162967, -0.686332), \n                                    vec3(-0.354193, 0.154254, -0.824183), 0.01);\n    if(accept(c)){d = c; normal = n;}\n    \n    //link wheel\n    \n    c = iBox(ro, rd, centerDim(vec3(0.351379, 0.1903, -0.819331), vec3(0.012586, 0.119632, 0.050369)), n).x;\n    if(accept(c)){d = c; normal = n;}\n    \n    c = iBox(ro, rd, centerDim(vec3(-0.341379, 0.1903, -0.819331), vec3(0.012586, 0.119632, 0.050369)), n).x;\n    if(accept(c)){d = c; normal = n;}\n    \n \n    if(d == 1e5) d = FALSE;\n    return vec4(d, 0.0, 0.0, 0.0);\n}\n\nvec4 backSuspension(vec3 ro, vec3 rd, vec2 bounds, out vec3 normal){\n    float d = 1e5;\n    float c; vec3 n;\n    \n    //left\n    c = cylinder(ro, rd, bounds, n, vec3(0.161399, 0.256042, 0.697725), \n                                    vec3(0.391399, 0.256042, 0.697725), 0.01);\n    if(accept(c)){d = c; normal = n;}\n    \n    c = cylinder(ro, rd, bounds, n, vec3(0.161399, 0.189825, 0.697725), \n                                    vec3(0.391399, 0.189825, 0.697725), 0.02);\n    if(accept(c)){d = c; normal = n;}\n    \n    c = cylinder(ro, rd, bounds, n, vec3(0.381582, 0.14403, 0.711996), \n                                    vec3(0.18377, 0.13842, 0.706374), 0.01);\n    if(accept(c)){d = c; normal = n;}\n    \n    c = cylinder(ro, rd, bounds, n, vec3(0.381582, 0.14403, 0.711996), \n                                    vec3(0.189643, 0.131519, 0.592709), 0.01);\n    if(accept(c)){d = c; normal = n;}\n    \n    c = cylinder(ro, rd, bounds, n, vec3(0.381582, 0.14403, 0.701996), \n                                    vec3(0.232683, 0.272933, 0.641396), 0.01);\n    if(accept(c)){d = c; normal = n;}\n    \n    //right\n    c = cylinder(ro, rd, bounds, n, vec3(-0.161399, 0.256042, 0.697725), \n                                    vec3(-0.391399, 0.256042, 0.697725), 0.01);\n    if(accept(c)){d = c; normal = n;}\n    \n    c = cylinder(ro, rd, bounds, n, vec3(-0.161399, 0.189825, 0.697725), \n                                    vec3(-0.391399, 0.189825, 0.697725), 0.02);\n    if(accept(c)){d = c; normal = n;}\n    \n    c = cylinder(ro, rd, bounds, n, vec3(-0.381582, 0.14403, 0.711996), \n                                    vec3(-0.18377, 0.13842, 0.706374), 0.01);\n    if(accept(c)){d = c; normal = n;}\n    \n    c = cylinder(ro, rd, bounds, n, vec3(-0.381582, 0.14403, 0.711996), \n                                    vec3(-0.189643, 0.131519, 0.592709), 0.01);\n    if(accept(c)){d = c; normal = n;}\n    \n    c = cylinder(ro, rd, bounds, n, vec3(-0.381582, 0.14403, 0.701996), \n                                    vec3(-0.232683, 0.272933, 0.641396), 0.01);\n    if(accept(c)){d = c; normal = n;}\n    \n    \n \n    if(d == 1e5) d = FALSE;\n    return vec4(d, 0.0, 0.0, 0.0);\n}\n\n#ifdef DRIVER\nfloat sdfPilot(vec3 pos){\n    float d;\n    vec3 p = pos; // main body\n    //helmet\n    d = sdSphere(p - vec3(0.0, 0.4481, 0.228917), 0.071918);\n    d = smin(d, sdSphere(p - vec3(0.0, 0.376305, 0.188372), 0.033391), 0.1);\n    d = max(d, -dot(p - vec3(0.0, 0.319, 0.0), vec3(0.0, 0.9743, -0.2249)));\n    \n    //glass helmet\n    p -= vec3(0.0, 0.431697, 0.174894);\n    p.yz = mat2x2(0.9743, 0.2249, -0.2249, 0.9743) * p.yz;\n    float v = sdBox(p, vec3(0.074463, 0.028347, 0.065994));\n    v = max(v, pos.z - 0.226);\n    v = max(v, sdSphere(pos - vec3(0.0, 0.416611, 0.217582), 0.085037)); \n    d = min(d, v);\n    \n    //helmet box\n    p = pos - vec3(0.0, 0.474635, 0.172322);\n    p.yz = mat2x2(0.7986, 0.6018, -0.6018, 0.7986) * p.yz;\n    d = smin(d, sdBox(p, vec3(0.018936)), 0.01);\n    \n    //body\n    p = pos;\n    float b = sdBox(p - vec3(0.004708, 0.316866, 0.22124), vec3(0.106223, 0.023876, 0.035158));\n    b = smin(b, sdBox(p - vec3(0.004708, 0.213847, 0.140326), vec3(0.060611, 0.023876, 0.035158)), 0.3);\n    d = min(d, b);\n    \n    p = pos;\n    p.x = abs(p.x);\n    d = smin(d, sdCapsule(p, vec3(0.073469, 0.339284, -0.074294), vec3(0.135186, 0.347432, 0.213145), 0.023), 0.05);\n    \n    \n    //Steering wheel\n    p -= vec3(0.004708, 0.304301, -0.078684);\n    p.yz = p.zy;\n    d = min(d, sdTorus(p, vec2(0.077048, 0.01)));\n    d = min(d, sdBox(p, vec3(0.077048, 0.01, 0.01)));\n    \n    return d;\n}\n\nvec4 pilot(vec3 ro, vec3 rd, vec2 bounds){\n    float t = max(bounds.x, 0.0);\n    for(int i = 0; i < 100; i++){\n        float d = sdfPilot(ro + rd*t);\n        t += d;\n        if(abs(d) < 0.001) return vec4(t);\n        if(t > bounds.y) break;\n    }\n    return vec4(FALSE);\n\n}\n#endif\n\n\n#endif\n\n#define ZERO (min(iFrame,0))\n#define NORMAL(f)vec3 n = vec3(0.0);for( int i=ZERO; i<4; i++ ){vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);n += e*f(pos+e*0.001);}normal = normalize(n)\n//car intersection///////////////////////////////////////////////////////////////////////\n#define carID 1.0\n#define WHEELID 2.0\n#define SUSPEN1ID 6.0\n#define SUSPEN2ID 7.0\n#define DRIVERID 8.0\nvec4 car(vec3 ro, vec3 rd, out vec3 normal){    //vec4(distance, ID, uv)\n    float d = 1e10;\n    float ID = -1.0;\n    vec2 UV;\n    vec2 bb = box(ro, rd, centerDim(vec3(0.0, 0.29444, 0.0), vec3(1.06, 0.581, 2.0)));\n    if(bb.x == FALSE) return vec4(FALSE, carID, 0.0, 0.0);\n    #ifdef CAR\n    \n    vec2 w1;\n    //weel front right\n    w1 = box(ro, rd, centerDim(vec3(-0.430973, 0.188607, -0.808671), vec3(0.182413, 0.366184, 0.365647)));\n    if(accept(w1.x)){\n        #ifdef WHEELS\n        vec4 w2 = wheel(ro, rd, w1, vec3(-0.430973, 0.188607, -0.808671));\n        if(accept(w2.x)){\n            d = min(d, w2.x);\n            vec3 pos = ro + w2.x * rd - vec3(-0.430973, 0.188607, -0.808671);\n            NORMAL(sdfWheel);\n            UV = vec2(pos.x/0.182413*0.5 + 0.5, fract((atan(pos.y, pos.z)-ti)/2.0/PI));\n            ID = WHEELID + length(pos.yz);\n        }\n        #else\n        d = min(d, iBox(ro, rd, centerDim(vec3(-0.430973, 0.188607, -0.808671), vec3(0.182413, 0.366184, 0.365647)), normal).x);\n        #endif\n    }\n    \n    //weel front left\n    w1 = box(ro, rd, centerDim(vec3(0.438217, 0.189125, -0.808624), vec3(0.182413, 0.366184, 0.365647)));\n    if(accept(w1.x)){\n        #ifdef WHEELS\n        vec4 w2 = wheel(ro, rd, w1, vec3(0.438217, 0.189125, -0.808624));\n        if(accept(w2.x)){\n            d = min(d, w2.x);\n            vec3 pos = ro + w2.x * rd - vec3(0.438217, 0.189125, -0.808624);\n            NORMAL(sdfWheel);\n            UV = vec2(pos.x/0.182413*0.5 + 0.5, fract((atan(pos.y, pos.z)-ti)/2.0/PI));\n            ID = WHEELID + length(pos.yz);\n\n        }\n        #else\n        d = min(d, iBox(ro, rd, centerDim(vec3(0.438217, 0.189125, -0.808624), vec3(0.182413, 0.366184, 0.365647)), normal).x);\n        #endif\n    }\n    \n    //weel back right\n    w1 = box(ro, rd, centerDim(vec3(-0.442033, 0.188607, 0.690881), vec3(0.182413, 0.366184, 0.364647)));\n    if(accept(w1.x)){\n        #ifdef WHEELS\n        vec4 w2 = wheel(ro, rd, w1, vec3(-0.442033, 0.188607, 0.690881));\n        if(accept(w2.x)){\n            d = min(d, w2.x);\n            vec3 pos = ro + w2.x * rd - vec3(-0.442033, 0.188607, 0.690881);\n            NORMAL(sdfWheel);\n            UV = vec2(pos.x/0.182413*0.5 + 0.5, fract((atan(pos.y, pos.z)-ti)/2.0/PI));\n            ID = WHEELID + length(pos.yz);\n        }\n        #else\n        d = min(d, iBox(ro, rd, centerDim(vec3(-0.442033, 0.188607, 0.690881), vec3(0.182413, 0.366184, 0.364647)), normal).x);\n        #endif\n    }\n    \n    //weel back left\n    w1 = box(ro, rd, centerDim(vec3(0.446449, 0.188607, 0.690882), vec3(0.182413, 0.366184, 0.364647)));\n    if(accept(w1.x)){\n        #ifdef WHEELS\n        vec4 w2 = wheel(ro, rd, w1, vec3(0.446449, 0.188607, 0.690882));\n        if(accept(w2.x)){\n            d = min(d, w2.x);\n            vec3 pos = ro + w2.x * rd - vec3(0.446449, 0.188607, 0.690882);\n            NORMAL(sdfWheel);\n            UV = vec2(pos.x/0.182413*0.5 + 0.5, fract((atan(pos.y, pos.z)-ti)/2.0/PI));\n            ID = WHEELID + length(pos.yz);\n        }\n        #else\n        d = min(d, iBox(ro, rd, centerDim(vec3(0.446449, 0.188607, 0.690882), vec3(0.182413, 0.366184, 0.364647)), normal).x);\n        #endif\n    }\n    \n    //front suspension\n    vec2 s1 = box(ro, rd, centerDim(vec3(0.0, 0.208472, -0.718025), vec3(0.718633, 0.135897, 0.261572)));\n    if(accept(s1.x)){\n        vec3 n;\n        vec4 s2 = frontSuspension(ro, rd, s1, n);\n        if(accept(s2.x)){\n            d = min(d, s2.x);\n            normal = n;\n            ID = SUSPEN1ID;\n        }\n    }\n    \n    //back suspension\n    vec2 s2 = box(ro, rd, centerDim(vec3(0.0, 0.186288, 0.642109), 2.0*vec3(0.395562, 0.107907, 0.111553)));\n    if(accept(s2.x)){\n        vec3 n;\n        vec4 s3 = backSuspension(ro, rd, s2, n);\n        if(accept(s3.x)){\n            d = min(d, s3.x);\n            normal = n;\n            ID = SUSPEN2ID;\n        }\n    }\n    //pilot\n    #ifdef DRIVER\n    vec2 dr1 = box(ro, rd, centerDim(vec3(-0.001445, 0.349935, 0.107053), vec3(0.285502, 0.362948, 0.47058)));\n    if(accept(dr1.x)){\n        vec4 dr2 = pilot(ro, rd, dr1);\n        if(accept(dr2.x)){\n            d = min(d, dr2.x);\n            vec3 pos = ro + dr2.x * rd;\n            NORMAL(sdfPilot);\n            UV = vec2(0.0);\n            ID = DRIVERID;\n        }\n    }\n    #endif\n    \n    \n    //car body\n    float b1 = body(ro, rd, bb).x;\n    if(b1 != FALSE && b1 < d){\n        d = min(d, b1);\n        vec3 pos = ro + b1 * rd;\n        NORMAL(sdfBody);\n        ID = carID;\n        UV = vec2(pos.z*0.5+0.5, (atan(pos.x, pos.y) + PI)/2.0/PI);\n    }\n    \n    if(d == 1e10) return vec4(FALSE, carID, 0.0, 0.0);\n    return vec4(d, ID, UV);\n    \n    #else \n   return vec4(bb.x, ID, UV);\n    #endif\n    \n}\n/////////////////////////////////////////////////////////////////////////////////////////\nvec4 wheelTex(vec2 uv, float r){  //return vec4(col, specular)\n    vec2 uv2 = mod(uv, vec2(0.25, 0.25*0.125))*vec2(4.0, 32.0);\n    if (uv.x > 0.5) uv2.x = 1.0 - uv2.x;\n    vec3 col = vec3(uv2.xy, 0.0);\n    col = vec3(0.2);\n    float s = step(0.1, uv2.x - uv2.y);\n    s += step(0.1, -uv2.x + uv2.y);\n    s *= 0.5+0.5*step(0.01, abs(uv.x-0.5));\n    s *= 0.5+0.5*step(0.005, abs(uv.x-0.2));\n    s *= 0.5+0.5*step(0.005, abs(uv.x-0.7));\n    s *= 0.5+0.5*step(0.005, abs(uv.x-0.3));\n    s *= 0.5+0.5*step(0.005, abs(uv.x-0.8));\n    col = mix(vec3(0.1, 0.13, 0.14)*0.5, vec3(0.18, 0.18, 0.17), s);\n    col *= texture(iChannel1, uv).x*0.7+0.3;\n    \n    \n    r /= 0.5*0.366184;\n    col = mix(vec3(0.14, 0.12, 0.11), col, step(0.99, r));\n    col = mix(vec3(1.0, 0.96, 0.80), col, step(0.7, r));\n    col = mix(vec3(0.1, 0.08, 0.08), col, step(0.05, r));\n    \n    col *= 0.5+abs(uv.x - 0.5);\n    \n    s = 0.8*(1.0 - step(0.7, r));\n    s *= step(0.08, r);\n    s *= pow(texture(iChannel1, vec2(r, uv.y)).x, 0.3);\n    return vec4(col, s);\n}\n\nfloat inRect(vec2 v, float x1, float y1, float x2, float y2){ //up down\n    return (v.x < x1 && v.x > x2\n         && v.y < y1 && v.y > y2)? 1.0 : 0.0;\n}\n#define change if(d2 < d){d = d2;\nvec4 carTex(vec2 uv, vec3 pos){\n    #ifdef CARTEXTURE\n    float s = 0.0;\n    vec3 col = vec3(0.0);\n    vec2 uv2 = uv;\n    uv2.x += 0.4*texture(iChannel1, uv).x - 0.25;\n    \n    #define f(x) x*x*(3.0 - 2.0*x)\n    col = mix(vec3(0.73, 0.11, 0.12), vec3(0.9, 0.9, 0.9), f(min(1.0, uv2.x*2.0)));\n    col = mix(col, vec3(0.0, 0.2, 0.5), f(max(0.0, uv2.x*2.0-1.0)));\n    \n    vec3 p = pos; // main body\n    p.yz = mat2x2(0.9987, 0.0507,\n                 -0.0507, 0.9987) * p.yz;\n    p.y += 0.1*pow(max(-p.z, 0.0), 3.0);\n    float d = sdEllipsoid( p - vec3(0.0, 0.250172, 0.034988), vec3(0.214086, 0.167228, 1.03));\n    float d2;\n    //bottom plate\n    p = pos - vec3(0.0, 0.150917, -0.530452);\n    d2 = sdBox(p , vec3(0.170919, 0.032961, 0.121223)) - 0.02;\n    change col = vec3(0.1);}\n    \n    //front wing (down)\n    p = pos - vec3(0.003025, 0.133558, -0.895936);\n    p.yz = mat2x2(0.6691, 0.7431, -0.7431, 0.6691) * p.yz;\n    d2 = sdBox(p , vec3(0.22312, 0.003805, 0.035775));\n    change col *= vec3(1.5, 1.3, 1.7);}\n    //front wing (up)\n    p = pos - vec3(0.004898, 0.189705, -0.796952);\n    p.yz = mat2x2(0.9205, 0.3907, -0.3907, 0.9205) * p.yz;\n    d2 = sdBox(p , vec3(0.154266, 0.003941, 0.062824));\n    change col *= vec3(1.5, 1.3, 1.7);}\n    //antena\n    p = pos - vec3(0.091767, 0.39, -0.440064);\n    d2 = sdCylinder(p, vec2(0.003316, 0.042221));\n    change col = vec3(0.05);}\n    //middle bump\n    p = pos - vec3(0.0, 0.434555, 0.394036);\n    p.yz = mat2x2(0.9945, -0.1045, 0.1045, 0.9945) * p.yz;\n    d = min(d, sdEllipsoid(p , vec3(0.09712, 0.09712, 0.426178)));\n    //glass\n    p = pos - vec3(0.0, 0.323151, 0.000632);\n    d2 = sdEllipsoid(p , vec3(0.144777, 0.132625, 0.405275));\n    change col = vec3(0.06); s=0.4;}\n    //cokpit (void)\n    p = pos - vec3(-0.001684, 0.4563, 0.107312);\n    float c = sdBox(p, vec3(0.153123, 0.253123, 0.21701));\n    d = smax(d, -c, 0.05);\n    //side bump\n    vec3 ps = vec3(abs(pos.x), pos.y, pos.z);\n    p = ps - vec3(0.178125, 0.332702, 0.368919);\n    d = smin(d, sdEllipsoid(p , vec3(0.09712, 0.09712, 0.426178)), 0.03);\n    //air entry 1 (void)\n    p = ps - vec3(0.232716, 0.336058, 0.263102);\n    p.xz = mat2x2(0.9980, -0.0627, 0.0627, 0.9980) * p.xz;\n    d2 = -sdEllipsoid(p , vec3(0.048859, 0.065034, 0.327925));\n    if(d2 > d){d = d2; col*=1.0 - pos.z*2.0;}\n    //side air entry construction:\n    //big shape\n    p = ps - vec3(0.005926, 0.167606, -0.025842);\n    float bs = sdEllipsoid(p , vec3(0.414984, 1.0, 1.0));\n    bs = max(bs, -c);;\n    //top\n    bs = smax(bs, pos.y - 0.32 + max(0.0, 0.07/(1.0 + exp(10.0*(pos.z - 0.1)))), 0.03);\n    //bottom\n    bs = smax(bs, -pos.y + 0.1 + max(0.0, 0.3*(pos.z - 0.33)), 0.03);\n    //front\n    bs = smax(bs, -dot(ps - vec3(0.0, 0.0,-0.4), normalize(vec3(-0.5, -0.5, 1.0))), 0.01);\n    //air entry 2 void\n    p = ps - vec3(0.30883, 0.17531, -0.281175);\n    d2 = -sdBox(p, vec3(0.086429, 0.058429, 0.318638));\n    if(d2 > bs){bs = d2; col*=-0.6 - pos.z*8.0;}\n    d = smin(d, bs, 0.02);\n    \n    //top cover\n    p = pos.xzy - vec3(-0.0, 0.380554, 0.340222);\n    d2 = sdRhombus(p, 0.073637, 0.103637, 0.047325, 0.1);\n    change col=vec3(0.1);}\n    //engine top\n    p = ps  - vec3(0.090865, 0.430824, 0.585795);\n    p.xz = mat2x2(0.9997, 0.0209, -0.0209, 0.9997) * p.xz;\n    p.xy = mat2x2(0.8090, 0.5877, -0.5877, 0.8090) * p.xy;\n    p.zy = mat2x2(0.9822, 0.1873, -0.1873, 0.9822) * p.zy;\n    d2 = sdBox(p, vec3(0.040173, 0.022703, 0.133894)) - 0.002;\n    change col = vec3(0.1, 0.1, 0.15); s=0.5;}\n    //block under\n    p = pos - vec3(0.0, 0.156481, 0.518026);\n    d2 = sdBox(p, vec3(0.20718, 0.074986, 0.300785)) - 0.001;\n    change col = vec3(0.3);}\n    \n    //back cut\n    d = max(d, -dot(ps - vec3(0.0, 0.0, 0.529344), vec3(0.0, 0.85716, -0.5150)));\n    d = max(d, -dot(ps - vec3(0.0, 0.0, 0.89541), vec3(0.0, -0.1045, -0.9945)));\n    \n    //back under 1\n    p = ps - vec3(0.192716, 0.143408, 0.570004);\n    d2 = sdBox(p, vec3(0.00652, 0.067714, 0.25495)) - 0.001;\n    change col = vec3(0.2);}\n    d = smax(d, -dot(ps - vec3(0.0, 0.0, 0.598839), vec3(0.0, 0.8386, -0.5446)), 0.05);\n    //back under 2\n    p = ps - vec3(0.069967, 0.147173, 0.616744);\n    d2 = sdBox(p, vec3(0.007172, 0.078738, 0.25495)) - 0.001;\n    change col = vec3(0.2);}\n    d = smax(d, -dot(ps - vec3(0.0, 0.0, 0.118614), vec3(0.0, 0.9876, -0.1564)), 0.08);\n    \n    //back box\n    p = pos - vec3(0.0, 0.267777, 0.623707);\n    d2 = sdBox(p, vec3(0.137705, 0.022871, 0.24837)) - 0.001;\n    change col *= 3.0;} \n    \n    //back smoke out\n    p = pos - vec3(0.0, 0.389587, 0.896463);\n    p.yz = mat2x2(0.9848, -0.1736, 0.1736, 0.9848) * p.yz;\n    d = smax(d, -sdBox(p, vec3(0.091775, 0.086516, 0.094237)), 0.06);\n    \n    p = ps - vec3(0.042621, 0.35046, 0.787099);\n    d2 = sdBox(p, vec3(0.031889, 0.011231, 0.072799)) - 0.005;\n    change col = vec3(0.1, 0.1, 0.15); s = 1.0;}\n    d = max(d, -sdBox(p, vec3(0.031889, 0.011231, 0.092799)));\n    \n    //back rombus top\n    p = ps.xzy - vec3(0.01, 0.727141, 0.390539);\n    d2 = sdRhombus(p, 0.031889, 0.011231, 0.092799, 0.001);\n    change col*=0.2;}\n    //back pipe\n    p = ps;\n    d2 = sdCapsule(p, vec3(0.16925, 0.27345, 0.905582), vec3(-0.16925, 0.27345, 0.905582), 0.01);\n    change col = vec3(0.03); s=1.0;}\n    d2 = sdCapsule(p, vec3(0.211834, 0.294284, 0.808042), vec3(0.16925, 0.27345, 0.905582), 0.01);\n    change col = vec3(0.03); s=1.0;}\n    //back wind\n    p = ps - vec3(0.002531, 0.469511, 0.871087);\n    p.yz = mat2x2(0.9923, 0.1236, -0.1236, 0.9923) * p.yz;\n    \n    float w2 = sdBox(p, vec3(0.20705, 0.00505, 0.082297));\n    p +=vec3(0.0, 0.01, 0.02);\n    w2 = smin(w2, sdBox(p, vec3(0.15705, 0.00505, 0.052297)), 0.05);\n    \n    p = ps - vec3(0.264567, 0.429921, 0.872511);\n    p.zy = mat2x2(0.9702, 0.0697, -0.0697, 0.9702) * p.zy;\n    p.xy = mat2x2(0.6427, -0.7660, 0.7660, 0.6427) * p.xy;\n    w2 = smin(w2, sdBox(p, vec3(0.004028, 0.060656, 0.077419)), 0.05);\n    d = min(d, w2);\n    //baxk wind support\n    p = ps - vec3(0.177204, 0.361375, 0.858586);\n    p.zy = mat2x2(0.9205, 0.3907, -0.3907, 0.9205) * p.zy;\n    d2 = sdBox(p, vec3(0.003402, 0.125143, 0.025331)), 0.02;\n    change col = vec3(0.4);}\n    \n    \n    //dirt\n    pos.y -= pow(abs(pos.z*0.5), 2.0);\n    float intens = clamp((0.25-pos.y)*10.0, 0.0, 1.0);\n    col *= mix(vec3(1.0), texture(iChannel1, uv*3.0).rgb, intens);\n    \n    col = max(col, vec3(0.0));\n    return vec4(col, s);\n    #else\n    return vec4(1.0, 1.0, 1.0, 0.0);\n    #endif\n}\n\nvec4 pilotTex(vec3 pos){\n    float s = 0.0;\n    vec3 col = vec3(0.1, 0.1, 0.1);\n    col.gb *= min(abs(pos.z)*10.0, 1.0);\n    \n    vec3 p = pos;\n    float b = sdSphere((p - vec3(0.0, 0.4481, 0.228917))* vec3(1.0, 1.0, 0.3), 0.071918);\n    if(b>0.01)return vec4(col, s);\n    //helmet\n    float d = sdSphere(p - vec3(0.0, 0.4481, 0.228917), 0.071918);\n    d = smin(d, sdSphere(p - vec3(0.0, 0.376305, 0.188372), 0.033391), 0.1);\n    d = max(d, -dot(p - vec3(0.0, 0.319, 0.0), vec3(0.0, 0.9743, -0.2249)));\n    \n    float c = abs(pos.x);\n    col = vec3(0.9);\n    col = mix(vec3(1.0, 0.0, 0.0), col, step(0.01, c));\n    col = mix(vec3(0.0, 0.0, 1.0), col, step(0.005, abs(c-0.02)));\n    //glass helmet\n    p -= vec3(0.0, 0.431697, 0.174894);\n    p.yz = mat2x2(0.9743, 0.2249, -0.2249, 0.9743) * p.yz;\n    float d2 = sdBox(p, vec3(0.074463, 0.028347, 0.065994));\n    d2 = max(d2, pos.z - 0.226);\n    d2 = max(d2, sdSphere(pos - vec3(0.0, 0.416611, 0.217582), 0.085037)); \n    change col = vec3(0.0, 0.7, 0.9); s=0.7;}\n    \n    //helmet box\n    p = pos - vec3(0.0, 0.474635, 0.172322);\n    p.yz = mat2x2(0.7986, 0.6018, -0.6018, 0.7986) * p.yz;\n    d2 = sdBox(p, vec3(0.018936));\n    change col = vec3(0.5); s=0.0;}\n    \n    return vec4(col, s);\n}\n\nvec4 color(vec4 data, vec3 ro, vec3 rd){\n    float d = data.x;\n    if(d == FALSE) return texture(iChannel0, rd);\n    //col = vec3(1.0/d);\n    if(data.y == carID)\n        return carTex(data.zw, ro + d*rd);\n    if(data.y >= WHEELID && data.y < WHEELID+1.0)\n        return wheelTex(data.zw, data.y - WHEELID);\n    if(data.y == SUSPEN1ID || data.y == SUSPEN2ID)\n        return 0.2*vec4(0.19, 0.32, 0.4, 4.0);\n    if(data.y == DRIVERID)\n        return pilotTex(ro + d*rd);\n    \n    return vec4(1.0, 1.0, 1.0, 0.0);\n}\nvec3 getScene(vec3 ro, vec3 rd){\n    vec3 normal;\n    vec4 data = car(ro, rd, normal);\n    float d = data.x;\n    vec4 col = color(data, ro, rd);\n    if(d == FALSE) return col.rgb;\n    //return normal*0.5 + 0.5;\n    \n    //shadow and lights\n    vec3 n;\n    vec3 accu = vec3(0.0);\n    accu += col.rgb * vec3(0.03, 0.07, 0.1);\n    float dotSunNorm = dot(normal, sunPos);\n    #ifdef SHADOW\n    vec4 dataShadow = car(ro + d*rd + 0.01*normal, sunPos, n);\n    if (dataShadow.x == FALSE){\n        accu += col.rgb * max(0.0, dotSunNorm);\n        accu += col.w *  pow(max(0., dotSunNorm), 50.0);\n    }\n    #else\n    accu += col.rgb * max(0.0, dotSunNorm);\n    accu += col.w *  pow(max(0., dotSunNorm), 50.0);\n    #endif\n    \n    #ifdef REFLECTION\n    if(col.w > 0.01){\n        accu *= 1.0 - col.w;\n        vec3 p = ro + d*rd + 0.01*normal;\n        vec3 rd2 = reflect(rd, normal);\n        vec4 reflData = car(p, rd2, n);\n        vec3 col3 = color(reflData, p, rd2).rgb;\n        if(reflData.x != FALSE) col3 *= max(0.0, dot(n, sunPos));\n        accu += col.w * col3;\n       \n    }\n    #endif\n    return accu;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //wheel phase\n    ti = iTime*12.0;\n    sunPos = normalize(vec3(cos(iTime*0.5+1.5), 0.5, sin(iTime*0.5+1.5)));\n    //end\n\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    uv*=0.7;\n    \n    float t = iTime * 0.5;\n    vec3 camPos = vec3(cos(t), 0.5, sin(t))*1.7;\n    //vec3 camPos = vec3(cos(t), 0.9, sin(t))*1.2;\n    \n    \n    vec3 dir0 = normalize(-camPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(up, dir0));\n    up = cross(dir0, right);\n    vec3 rd = normalize(dir0 + right*uv.x + up*uv.y);\n    \n    vec3 col = getScene(camPos, rd);\n   \n    col = 1.0 - exp(-col);\n    col = pow(col, vec3(1.0/2.0));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//constants and settings////////////////////////////////////////////////////////////////\nvec3 sunPos = normalize(vec3(0.2, 0.5, 1.0));\nfloat ti = 0.0;   //wheels rotation phase\n\n#define SHADOW\n#define REFLECTION\n\n#define CAR\n#define WHEELS\n#define DETAILCAR\n#define CARTEXTURE\n#define DRIVER\n\n\n#define PI 3.14159\n#define FALSE -1.0\n#define accept(a) a != FALSE && a < d \n\n\n", "cube_a_code": "//from https://www.shadertoy.com/view/WlSSzK\n#define Rayleigh 1.\n#define Mie 1.\n#define RayleighAtt 1.\n#define MieAtt 1.2\n#define DistanceAtt 1e-5\n\n#define skyInt 1.4\nfloat g = -0.93;\nfloat gS = -0.43;\n\nvec3 _betaR = vec3(1.95e-2, 1.1e-1, 2.94e-1); \nvec3 _betaM = vec3(4e-2, 4e-2, 4e-2);\n\n\nvec3 calcAtmosphericScattering( float sR, float sM, out vec3 extinction, float cosine, float g1)\n{\n    extinction = exp(-(_betaR * sR + _betaM * sM));\n\n    // scattering phase\n    float g2 = g1 * g1;\n    float fcos2 = cosine * cosine;\n    float miePhase = Mie * pow(1. + g2 + 2. * g1 * cosine, -1.5) * (1. - g2) / (2. + g2);\n    //g = 0;\n    float rayleighPhase = Rayleigh;\n\n    vec3 inScatter = (1. + fcos2) * vec3(rayleighPhase + _betaM / _betaR * miePhase);\n    \n    return inScatter;\n}\n\nfloat fbm(vec2 x, int detail){\n    float a = 0.0;\n    float b = 1.0;\n    float t = 0.0;\n    for(int i = 0; i < detail; i++){\n        float n = texture(iChannel0, x).x;\n        a += b*n;\n        t += b;\n        b *= 0.7;\n        x *= 2.0; \n    \n    }\n    return a/t;\n}\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    \n    \n    // Ray direction as color\n    vec3 col; \n    sunPos = normalize(vec3(cos(iTime*0.5+1.5), 0.5, sin(iTime*0.5+1.5)));\n    \n    float sundot = clamp(dot(rayDir,sunPos),0.0,1.0);\n    vec3 extinction;\n\n    // optical depth -> zenithAngle\n    float zenithAngle = max(0., rayDir.y); //abs( rd.y);\n    float sR = RayleighAtt / zenithAngle ;\n    float sM = MieAtt / zenithAngle ;\n    \n    vec3 inScatter = calcAtmosphericScattering(sR, sM, extinction, sundot, g);\n    vec3 skyCol = inScatter*(1.0-extinction);\n    \n    // sky\t\n    col = skyCol;// * vec3(1.6,1.4,1.0);\n            \n    // sun\n    col += 0.47*vec3(1.6,1.4,1.0)*pow( sundot, 350.0 ) * extinction;\n    // sun haze\n    col += 0.4*vec3(0.8,0.9,1.0)*pow( sundot, 2.0 ) * extinction;\n\n    // clouds\n    vec3 rd = rayDir;\n        if(rd.y > 0.01){\n        vec2 ro = 0.3 * iTime * vec2(0.7, 1.0);\n        vec2 sc = ro + rd.xz*(10.0)/rd.y;\n        col += 2. * vec3(1.0,0.95,1.0) * extinction * smoothstep(0.5,0.8,fbm(0.0005*sc, 5) );\n    }\n\n    // Output to cubemap\n    \n    fragColor = vec4(col,1.0);\n}", "cube_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVGzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 157, 157, 206], [207, 207, 245, 245, 640], [641, 641, 674, 674, 920], [922, 922, 1053, 1053, 1816], [1818, 1818, 1874, 1874, 2606], [2744, 2744, 2785, 2785, 2878], [2880, 2880, 2921, 2921, 3024], [3026, 3026, 3061, 3061, 3087], [3089, 3089, 3122, 3122, 3177], [3179, 3179, 3238, 3238, 3327], [3329, 3329, 3360, 3360, 3451], [3453, 3453, 3489, 3489, 3592], [3594, 3594, 3630, 3630, 3658], [3659, 3659, 3723, 3723, 3981], [3983, 3983, 4035, 4035, 4149], [17784, 17784, 17828, 17856, 22482], [22483, 22573, 22605, 22635, 23599], [23601, 23601, 23662, 23672, 23753], [30225, 30225, 30249, 30249, 31236], [31467, 31467, 31507, 31507, 31978], [31979, 31979, 32011, 32011, 33078], [33080, 33080, 33137, 33155, 33846]], "test": "untested"}
{"id": "Nt3GWS", "name": "Spot Blur", "author": "turboplay", "description": "Click to set the spot to blur, radius configurable.", "tags": ["2d", "blur", "filter", "gaussian", "pass", "single"], "likes": 2, "viewed": 274, "published": 3, "date": "1636619705", "time_retrieved": "2024-07-30T18:49:03.142495", "image_code": "#define pow2(x) (x * x)\n\nconst float pi = atan(1.0) * 4.0;\nconst int samples = 34;\nconst float sigma = float(samples) * 0.25;\nfloat radius = 0.1;\n\nfloat gaussian(vec2 i) {\n    return 1.0 / (2.0 * pi * pow2(sigma)) * exp(-((pow2(i.x) + pow2(i.y)) / (2.0 * pow2(sigma))));\n}\n\nvec3 blur(sampler2D sp, vec2 uv, vec2 scale) {\n    vec3 col = vec3(0.0);\n    float accum = 0.0;\n    float weight;\n    vec2 offset;\n    \n    for (int x = -samples / 2; x < samples / 2; ++x) {\n        for (int y = -samples / 2; y < samples / 2; ++y) {\n            offset = vec2(x, y);\n            weight = gaussian(offset);\n            col += texture(sp, uv + scale * offset).rgb * weight;\n            accum += weight;\n        }\n    }\n    \n    return col / accum;\n}\n\nvoid mainImage(out vec4 color, vec2 coord) {\n    vec2 ps = vec2(1.0) / iResolution.xy;\n    vec2 uv = coord * ps;\n    \n    \n    \n    vec2 center = vec2(iMouse.xy);\n    \n    if (distance(coord,center) > radius*iResolution.x)\n        color.rgb = texture(iChannel0,uv).rgb;\n        else\n    color.rgb = blur(iChannel0, uv, ps);\n    color.a = 1.0;\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt3GWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 147, 171, 171, 272], [274, 274, 320, 320, 737], [739, 739, 783, 783, 1083]], "test": "untested"}
{"id": "7l3GDS", "name": "NEON LOVE Fix", "author": "gelami", "description": "Original: [url=https://www.shadertoy.com/view/WdK3Dz]NEON LOVE[/url]", "tags": ["2d", "sdf", "bezier", "heart", "glow", "curve", "neon"], "likes": 40, "viewed": 1466, "published": 3, "date": "1636613546", "time_retrieved": "2024-07-30T18:49:03.979258", "image_code": "\n// Original:\n// NEON LOVE by alro - https://www.shadertoy.com/view/WdK3Dz\n\n/* \n * Fixed the creases in the heart caused by the property of the distance field on concave areas.\n * By converting the individual bezier SDF segments into light/glow first,\n * we can treat them as indiviual lights and sum them together.\n * This does make the endpoints to double in intensity as they overlap,\n * so we subtract light on the endpoints to get the smooth lighting properly.\n *\n */\n\n#define POINT_COUNT 8\n\nvec2 points[POINT_COUNT];\nconst float speed = -0.5;\nconst float len = 0.25;\nconst float scale = 0.012;\nfloat intensity = 1.3;\nfloat radius = 0.012; //0.015;\n\nfloat thickness = .0035;\n\n//https://www.shadertoy.com/view/MlKcDD\n//Signed distance to a quadratic bezier\nfloat sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C){    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    \n    if(h >= 0.0){ \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    }else{\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = dis;\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        res = sqrt( res );\n    }\n    \n    return res;\n}\n\n\n//http://mathworld.wolfram.com/HeartCurve.html\nvec2 getHeartPosition(float t){\n    return vec2(16.0 * sin(t) * sin(t) * sin(t),\n                -(13.0 * cos(t) - 5.0 * cos(2.0*t)\n                - 2.0 * cos(3.0*t) - cos(4.0*t)));\n}\n\n//https://www.shadertoy.com/view/3s3GDn\nfloat getGlow(float dist, float radius, float intensity){\n    return pow(radius*dist, intensity);\n}\n\n// Changes in here\nfloat getSegment(float t, vec2 pos, float offset){\n\tfor(int i = 0; i < POINT_COUNT; i++){\n        points[i] = getHeartPosition(offset + float(i)*len + fract(speed * t) * 6.28);\n    }\n    \n    vec2 c = (points[0] + points[1]) / 2.0;\n    vec2 c_prev;\n\tfloat light = 0.;\n    const float eps = 1e-10;\n    \n    for(int i = 0; i < POINT_COUNT-1; i++){\n        //https://tinyurl.com/y2htbwkm\n        c_prev = c;\n        c = (points[i] + points[i+1]) / 2.0;\n        // Distance from bezier segment\n        float d = sdBezier(pos, scale * c_prev, scale * points[i], scale * c);\n        // Distance from endpoint (except from first point)\n        float e = i > 0 ? distance(pos, scale * c_prev) : 1000.;\n        // Convert the distance to light and accumulate\n        light += 1. / max(d - thickness, eps);\n        // Convert the endpoint as well and subtract\n        light -= 1. / max(e - thickness, eps);\n    }\n    \n    return max(0.0, light);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    float widthHeightRatio = iResolution.x/iResolution.y;\n    vec2 centre = vec2(0.5, 0.5);\n    vec2 pos = centre - uv;\n    pos.y /= widthHeightRatio;\n    //Shift upwards to centre heart\n    pos.y += 0.03;\n\t\n    float t = iTime;\n    \n    //Get first segment\n    float dist = getSegment(t, pos, 0.0);\n    float glow = getGlow(dist, radius, intensity);\n    \n    vec3 col = vec3(0.0);\n    \n    //White core\n    //col += 10.0*vec3(smoothstep(0.006, 0.003, dist));\n    //Pink glow\n    col += glow * vec3(1.0,0.05,0.3);\n    \n    //Get second segment\n    dist = getSegment(t, pos, 3.4);\n    glow = getGlow(dist, radius, intensity);\n    \n    //White core\n    //col += 10.0*vec3(smoothstep(0.006, 0.003, dist));\n    //Blue glow\n    col += glow * vec3(0.1,0.4,1.0);\n        \n    //Tone mapping\n    col = 1.0 - exp(-col);\n    \n    //Gamma\n    col = pow(col, vec3(0.4545));\n\n    //Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l3GDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[681, 761, 810, 810, 2090], [2093, 2140, 2171, 2171, 2324], [2326, 2366, 2423, 2423, 2465], [2467, 2486, 2536, 2536, 3423], [3425, 3425, 3481, 3481, 4440]], "test": "untested"}
{"id": "flcGDB", "name": "Half body", "author": "jorge2017a2", "description": "Half body", "tags": ["halfbody"], "likes": 5, "viewed": 283, "published": 3, "date": "1636603442", "time_retrieved": "2024-07-30T18:49:04.991551", "image_code": "///-------------image\n//por jorge2017a2-\n///----Half body-----aprendiendo :)\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\n    \nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{  float k0 = length(p/r);  float k1 = length(p/(r*r));  return k0*(k0-1.0)/k1;}\n\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) \n{  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) \n{   float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k )\n{   float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{  vec2 q = vec2( length(p.xz), p.y );\n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{ p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{ vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n//------------------------------------\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  \n    vec3 p0=p;\n    p.y-=8.0;\n    \n    float dCuello=sdCylinderXZ( p-vec3(0.0,10.0,1.0), vec2(2.0,2.0) );\n    \n    float dCuerpo= sdRoundBox(p-vec3(0.0,0.0,1.5), vec3(7.0,7.2,2.0), 0.5 );\n    p.x=abs(p.x)-8.0;\n    float dCurva= sdEllipsoid( p-vec3(0.0,0.0,0.0), vec3(3.2,10.0,12.0) );\n    \n    dCuerpo= opSmoothUnion(dCuerpo, dCuello,0.5);\n    dCuerpo= differenceSDF(dCuerpo, dCurva);\n    \n    p=p0;\n    p.x=abs(p.x)-3.0;\n    float dPecho1=sdSphere( p-vec3(0.0,10.5,-0.5),2.5 );\n    float dPechoBx=sdBox( p-vec3(0.0,13.0,-0.5), vec3(3.0,2.0,5.0) );\n    float dSosten=sdBox( p0-vec3(0.0,10.5,-0.4), vec3(1.0,0.5,1.0) );\n    dPecho1= differenceSDF(dPecho1, dPechoBx);\n    float dPecho2=sdSphere( p-vec3(0.0,10.5,-0.3),2.5 );\n    \n    \n    dCuerpo= opSmoothUnion( dCuerpo, dPecho1, 0.5 ) ;\n    dPecho1= opSmoothUnion( dPecho1, dSosten, 0.5 ) ;\n    \n    p=p0;\n    float dHombro= sdVerticalCapsule( p.zxy-vec3(1.5,-7.8,16.0), 15.0, 2.0 );\n    //----Brazo Izq\n    float ang1A=radians(120.0+ 60.0*clamp(-0.50,0.0, cos(0.5+iTime*1.0)) );\n    vec3 p1A= rotate_x(p-vec3(-8.0,16.0,1.5), ang1A);\n        float ang2A=radians( 120.0*clamp(-0.50,0.0, sin (iTime*1.0)) );\n    vec3 p2A= rotate_x(p1A-vec3(0.0,8.5,0.0), ang2A);\n    float dbrazoA1=sdRoundCone(p1A, 1.4,0.8, 7.2 );\n    float dbrazoA2=sdRoundCone(p2A, 1.0,0.6, 7.0 );\n    \n    \n    \n    //brazo der\n    p=p0;\n       float ang1B=radians(120.0+ 60.0*clamp(-0.50,0.0, cos(0.5+iTime*1.0)) );\n       float ang1B1=radians(60.+ 60.0*clamp(-0.50,0.0, cos(0.5+iTime*1.0)) );\n    vec3 p1B= rotate_x(p-vec3(8.0,16.0,2.5), ang1B);\n    p1B= rotate_z(p1B, ang1B1);\n        float ang2B=radians( 120.0*clamp(-0.50,0.0, sin (iTime*1.0)) );\n    vec3 p2B= rotate_x(p1B-vec3(0.0,8.5,0.0), ang2B);\n\n    float dbrazoB1=sdRoundCone(p1B, 1.4,0.8, 7.2 );\n    float dbrazoB2=sdRoundCone(p2B, 1.0,0.6, 7.0 );\n    \n    dCuerpo= opSmoothUnion(dCuerpo, dHombro,0.5);\n     dCuerpo= opSmoothUnion(dCuerpo, dbrazoA1,0.5);\n     dCuerpo= opSmoothUnion(dCuerpo, dbrazoA2,0.5);\n     dCuerpo= opSmoothUnion(dCuerpo, dbrazoB1,0.5);\n     dCuerpo= opSmoothUnion(dCuerpo, dbrazoB2,0.5);\n    \n    res =opU3(res, vec3(dCuerpo,30.0,-1.0));\n    res =opU3(res, vec3(dPecho2,30.0,-1.0));\n    res =opU3(res, vec3(dPecho1,1.0,-1.0));\n    \n    res =opU3(res, vec3(dbrazoA1,30.0,-1.0));\n    res =opU3(res, vec3(dbrazoA2,30.0,-1.0));\n    res =opU3(res, vec3(dbrazoB1,30.0,-1.0));\n    res =opU3(res, vec3(dbrazoB2,30.0,-1.0));\n    \n   \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{   vec3 l = normalize(lp - p);\n    vec3 ldir = normalize(p-rd);    \n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    \n    float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true) {fshadow=GetShadow(p,lp);}\n    else {fshadow=0.5;}\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n    lin *= atten*0.5*col*fshadow;\n    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    lin = pow(lin,vec3(0.4545));\n \n    return lin;\n    //return lin*atten*(1.0/2.0);\n    \n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n///-------------------------------------\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    return colobj;\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n   \n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n    \n   \n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(10.0, 10.0, -35.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 30.0, -25.0 ); light_color2 =vec3( 1.0 ); \n   vec3 ro=vec3(0.0,12.5,-27.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n     col = linear2srgb(col);\n    \n    /*\n    vec3 col1 = exposureToneMapping(2.0, col);\n    vec3 col2 = linear2srgb(col);\n    col=(col1+col2)/2.0;\n    */\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------common\n///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flcGDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[538, 538, 574, 574, 595], [596, 596, 628, 628, 712], [713, 713, 759, 759, 846], [852, 852, 891, 891, 986], [988, 988, 1025, 1025, 1104], [1107, 1151, 1198, 1198, 1225], [1226, 1226, 1269, 1269, 1296], [1297, 1297, 1345, 1345, 1373], [1377, 1377, 1411, 1411, 1507], [1508, 1508, 1542, 1542, 1633], [1634, 1634, 1668, 1668, 1759], [1760, 1800, 1834, 1834, 1929], [1931, 1931, 1984, 1984, 2080], [2082, 2082, 2141, 2141, 2239], [2241, 2241, 2300, 2300, 2397], [2399, 2399, 2457, 2457, 2715], [2717, 2717, 2770, 2770, 2827], [2829, 2829, 2881, 2881, 3000], [3002, 3041, 3066, 3066, 5548], [5550, 5550, 5574, 5574, 5736], [5738, 5738, 5787, 5787, 6418], [6420, 6420, 6456, 6456, 6701], [6703, 6703, 6730, 6730, 6747], [6749, 6749, 6785, 6785, 6877], [6878, 6878, 6924, 6924, 7049], [7052, 7052, 7126, 7126, 8545], [8547, 8547, 8627, 8627, 8750], [8793, 8793, 8825, 8825, 9022], [9025, 9077, 9170, 9170, 9341], [9344, 9344, 9375, 9375, 9979], [9981, 10030, 10056, 10056, 10166], [10168, 10168, 10226, 10226, 10278], [10280, 10329, 10386, 10386, 11049]], "test": "untested"}
{"id": "ssGXWt", "name": "Ray sMarching Testing", "author": "DanielXMoore", "description": "yaolo", "tags": ["yolo"], "likes": 1, "viewed": 189, "published": 3, "date": "1636601378", "time_retrieved": "2024-07-30T18:49:05.756506", "image_code": "#define MAX_DIST 100.\n#define MAX_STEPS 100\n#define SURFACE_DIST 0.01\n\nfloat opSubtraction( float d1, float d2 ) { return max(d1,-d2); }\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// Distance Estimator\nfloat DE(vec3 p) {\n    // Sphere (x,y,z, radius)\n    vec4 sphere = vec4(1, 1, 8, 1);\n    \n    sphere.xy += iTime;\n    // Note: need to offset the mod so the tiling doesn't split the spheres\n    float sphereDist = length(mod(p - sphere.xyz + 2.5, 5.) - 2.5) - sphere.w;\n    vec3 cylSpace = mod(p - vec3(1.,1.,2.5) + 2.5, 5.) - 2.5;\n    float cylDist = sdCylinder(cylSpace, vec2(.5, .5));\n    float planeDist = p.y;\n    \n    return min(opSubtraction(sphereDist, cylDist), planeDist);\n    return min(min(sphereDist, cylDist), planeDist);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.;\n\n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float d = DE(p);\n        dO += d;\n\n        if (d < SURFACE_DIST || d > MAX_DIST) break;\n    }\n\n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = DE(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        DE(p-e.xyy),\n        DE(p-e.yxy),\n        DE(p-e.yyx)\n    );\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 15, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime)) * 2.;\n    \n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    float diff = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURFACE_DIST*2., l);\n    \n    if (d < length(lightPos-p)) {\n        diff *= .1;\n    }\n    \n    return diff;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5*iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 1, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    float dist = RayMarch(ro, rd);\n    vec3 p = ro + rd * dist;\n    \n    float diff = GetLight(p);\n\n    col = vec3(diff);\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGXWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 114, 114, 136], [138, 150, 186, 186, 289], [291, 313, 331, 361, 849], [851, 851, 885, 885, 1097], [1099, 1099, 1123, 1123, 1300], [1302, 1302, 1326, 1326, 1671], [1673, 1673, 1730, 1730, 2066]], "test": "untested"}
{"id": "fl3GDB", "name": "Persian carpet 18", "author": "jarble", "description": "These patterns resemble Persian carpets.", "tags": ["fractal", "carpet", "rug"], "likes": 8, "viewed": 526, "published": 3, "date": "1636600908", "time_retrieved": "2024-07-30T18:49:06.535423", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5/8.;\n\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime/2.+uv.x)/10.0);\n    vec3 random1 = (hash31(3.+t2)-.5)/12.;\n    vec3 random2 = (hash31(4.+t2)-.5)/12.;\n    vec3 random3 = (hash31(3.+t2)-vec3(.5))/1.5;\n    //vec3 random4 = (hash31(4.+t2)-vec3(.5))/4.;\n    \n    float offset = .5;\n    float scale2 = 1.5;\n    float bend = 1.;\n    vec3 col1 = col;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        //float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            \n            for(int k = 0; k < 3; k++){    \n                uv /= -scale2;\n                //uv += fract(uv/1.5)/16.; //a more interesting quilt pattern\n                //uv += (fract(uv.y/16.)+fract(uv.x/16.))/16.; //a more interesting quilt pattern\n\n\n                //float scale = scale - col.x/16.;\n                //uv /= -scale2+col.x;\n\n                //float bend = 1.+random3[k];\n                //bend = abs(fract((uv.x)*2.)-.5)/2.+1.;\n                //bend = 1.+1./3.;\n                //bend = scale2/1.5;\n                \n                //bend = abs(fract(((uv.x*bend+uv.y/bend)/scale2))-.5)+1.-col.x;\n\n                //uv *= 1.-col.x;\n                \n                \n                //float offset = offset + float(i);\n                vec2 t2 = triangle_wave(uv.yx-offset,scale);\n                vec2 t3 = triangle_wave(uv,scale);\n                uv.yx = t2/bend+t3*bend;\n                //uv += fract(uv.x/(4.))/4.; //a more interesting quilt pattern\n\n                //uv.y *= 1.-col.x;\n                //uv.yx = triangle_wave(uv.yx-offset/1.5,scale)*bend-triangle_wave(uv-offset,scale)/bend;\n\n                //bend += 1./(1.+uv.x+uv.y);\n                //bend = 1./bend;\n                uv += vec2(random1[k],random2[k]);  \n                //bend *= -1.;\n                //bend -= 1./3.-col.x;\n                //bend = 1.+uv.x/2.;\n\n            }\n            \n\n            //offset += .5;\n            scale /= 1.+(scale2)*col.x/(8.);\n            scale2 -= (col.x-1.)/(4.);\n\n\n            col[c] = abs((uv.x)-(uv.y));\n            col1 = abs(col-col1.yzx);\n            //random2 = col - random2;\n            \n\n        }\n\t}\n    \n    fragColor =\n        vec4(vec3(col*2.),1.0);\n        //vec4(vec3(col1*2.),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl3GDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [590, 590, 629, 629, 674], [676, 676, 733, 733, 3292]], "test": "untested"}
{"id": "7ld3zX", "name": "Cat Bottle", "author": "orangeflea215", "description": "Final implementation of my water bottle.  Thanks to Reinder for IBL code.\n\nUnfortunately somewhat slow, at least on my laptop chip.  I found it hard to get the precision needed for the thin walls of the bottle without using a fairly high step count.", "tags": ["renderer"], "likes": 16, "viewed": 614, "published": 3, "date": "1636599879", "time_retrieved": "2024-07-30T18:49:07.513807", "image_code": "// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n\n//Set to a higher integer for better aa (at a steep performance cost), if desired\n#define SAMPLES 1\n#define ZERO (min(iFrame,0))\n\n#define MAX_LOD 8.\n#define DIFFUSE_LOD 6.75\n\nfloat PI = 3.14159;\nint maxSteps = 256;\nfloat minStepSize = 0.00005;\nfloat e = .0001;\n\nfloat shadowBias = .01;\n\n//IBL Code from https://www.shadertoy.com/view/lscBW4\n//Thanks to reinder for the implementation\n\nvec3 getSpecularLightColor( vec3 N, float roughness ) {\n    // This is not correct. You need to do a look up in a correctly pre-computed HDR environment map.\n    return pow(textureLod(iChannel0, N, roughness * MAX_LOD).rgb, vec3(4.5)) * 6.5;\n}\n\nvec3 getDiffuseLightColor( vec3 N ) {\n    // This is not correct. You need to do a look up in a correctly pre-computed HDR environment map.\n    return .25 +pow(textureLod(iChannel0, N, DIFFUSE_LOD).rgb, vec3(3.)) * 1.;\n}\n\n//\n// Modified FrenelSchlick: https://seblagarde.wordpress.com/2011/08/17/hello-world/\n//\nvec3 FresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n//\n// Image based lighting\n//\n\nvec3 lighting(in vec3 rayDirection, in vec3 N, in vec3 albedo, in float ao, in float roughness, in float metallic ) {\n    vec3 V = rayDirection;\n    vec3 R = reflect(-V, N);\n    float NdotV = max(0.0, dot(N, V));\n\n    vec3 F0 = vec3(0.08); \n    F0 = mix(F0, albedo, metallic);\n\n    vec3 F = FresnelSchlickRoughness(NdotV, F0, roughness);\n\n    vec3 kS = F;\n\n    vec3 prefilteredColor = getSpecularLightColor(R, roughness);\n    vec2 envBRDF = texture(iChannel3, vec2(NdotV, roughness)).rg;\n    vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n\n    vec3 kD = vec3(1.0) - kS;\n\n    kD *= 1.0 - metallic;\n\n    vec3 irradiance = getDiffuseLightColor(N);\n\n    vec3 diffuse  = albedo * irradiance;\n    vec3 color = kD * diffuse + specular;\n    return color;\n}\n\n/*Not using point lights anymore*/\n\n/*//Point light\n//Intensity at distance of 1 unit\nfloat lInt = 10.0;\nvec3 lCol = vec3(0.2, 1.0, 0.0);\nvec3 lPos = vec3(-2.0, 2.0, -2.0);\n\n//Point light 2\n//Intensity at distance of 1 unit\nfloat lInt2 = 10.0;\nvec3 lCol2 = vec3(1.0, 0.2, 0.0);\nvec3 lPos2 = vec3(2.0, 2.0, -2.0);\n\n//Ambient light\nvec3 ambCol = vec3(0.2,0.2,0.2);\n*/\n\n//Camera\nfloat fov = 50.0 * 2.0 * 3.14159/360.0;\nvec3 camPos = vec3(0.0, 2.0, -9.0);\nvec3 camTar = vec3(0.0, 1.0, 0.0);\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n//SDFs\n\n//Sphere\n\nfloat sphereSDF(float d, float r){\n    return d - r;\n}\n\n//Plane\nfloat planeSDF(vec3 d, float l, float w){\n    return max(abs(d.x) - w/2.0,0.0) + max(abs(d.z) - l/2.0,0.0) + abs(d.y);\n}\n\nfloat roundedCylinderSDF (vec3 p, float ra, float rb, float h){\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat cylinderSDF (vec3 p, float ra, float h){\n    vec2 d = vec2( length(p.xz)-ra, abs(p.y) - h/2.0 );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat bottleSDF(vec3 d, float r, float h, float bottomRad, float numLines, float radLines, float midHeight){\n    float topHeight = .3;\n    float bottomHeight = 1.0 - topHeight - midHeight;\n    vec3 bottomCenterVec = d + h * vec3(0.0, .5 - (bottomHeight/2.0),0.0);\n    float bottomCenterDist = cylinderSDF(bottomCenterVec, r, h*bottomHeight);\n    bottomCenterDist -= bottomRad;//bottomRad;\n    \n    vec3 topCenterVec = d - h * vec3(0.0, .5 - (topHeight/2.0),0.0);\n    float topCenterDist = cylinderSDF(topCenterVec, r, h*topHeight);\n    topCenterDist -= bottomRad;//bottomRad;\n    \n    vec2 distV = vec2(length(d.xz) - r, abs(d.y) - h/2.0);\n    //return length(d.xz) - r ;//+ abs(d.y) - h/2.0;\n    float dist = (min(max(distV.x,distV.y),0.0) + length(max(distV,0.0)));\n    float adder = min(length(distV.x) - bottomCenterDist,bottomRad);\n    float tadder = min(bottomRad,length(distV.x) - topCenterDist);\n    \n    float bottomCenterYDist = (bottomHeight*h/2.0) + bottomRad  - abs(bottomCenterVec.y);    \n    float topCenterYDist = (topHeight*h/2.0) + bottomRad  - abs(topCenterVec.y);\n    \n    float segHeight = bottomHeight * h / numLines;\n    //Distance from bottom of bottle\n    float bottomYDist = d.y + .5;\n    vec2 lineDist = vec2(abs(length(d.xz) - r - bottomRad), abs(mod(bottomYDist - segHeight/2.0, segHeight)));// - segHeight/2.0));\n    float lineRadDist = max(0.0 , -sqrt(lineDist.x * lineDist.x + lineDist.y * lineDist.y) + radLines);\n\n\n    dist = dist - (max( topCenterYDist , 0.0)) * max(sign(-topCenterVec.y), 0.0) * (  tadder) / abs(topCenterYDist) - max(sign(topCenterVec.y), 0.0) * bottomRad;\n    dist = dist - (max( bottomCenterYDist , 0.0)) * max(sign(bottomCenterVec.y), 0.0) * (  adder) / abs(bottomCenterYDist) - max(sign(-bottomCenterVec.y), 0.0) * bottomRad;\n    \n    dist = dist + min(pow(max(1.2*(d.y - ((.5 - topHeight + .07) * h)), 0.0),1.96)/.74, 0.28);\n    dist += lineRadDist * max(bottomCenterYDist, 0.0)/(bottomCenterYDist);\n    \n    return dist;\n    }\n\n\n\n//Map function\nvec3 map(vec3 pos){\n    vec3 result = vec3(10000000000.0,0.0,0.0);\n    float res = 0.0;\n    \n    res = bottleSDF((pos - vec3(0.0,.7125,0.0)), .425, 3.25, .03, 5.0, .045, .235);\n    float bottleRes = res + .005;\n    res = abs(res) - .0025;\n    // res = max(res, pos.y - .9);\n    result.x = min(result.x, res);\n    \n    if(abs(res) <= e){\n        \n        result.y = 3.0;\n    }\n    \n    res = cylinderSDF((pos - vec3(0.0,2.07,0.0)),0.2, .15);\n    res = abs(res) - .01;\n    res -= .01;\n   // res = max(res, pos.y - .9);\n    result.x = min(result.x, res);\n    \n    if(res <= e){\n        \n        result.y = 5.0;\n    }\n    \n    res = cylinderSDF((pos - vec3(0.0,.975,0.0)),0.425, .6);\n    res = max(-cylinderSDF((pos - vec3(0.0,.975,0.0)),0.40, .7), res);\n\n    //res = abs(res) - .01;\n    res -= .01;\n   // res = max(res, pos.y - .9);\n    result.x = min(result.x, res);\n    \n    if(res <= e){\n        \n        result.y = 6.0;\n    }\n    \n    vec3 pos2 = pos;\n    pos2.y -= pow(1.4,length(pos.xz)*8.3)*.02;//.1;\n    res = cylinderSDF((pos2 - vec3(0.0,-.8,0.0)),0.425, 1.5);\n    //res -= length(pos.xz);\n    //res = abs(res) - .01;\n    res -= .01;\n   // res = max(res, pos.y - .9);\n    float res2 = max(res, bottleRes);\n    result.x = min(result.x, res2 - .001);\n    \n    if(abs(res2 - .001)  <= e){\n        \n        result.y =7.0;\n    }\n    \n    \n   /* res = sphereSDF(length(pos - vec3(2.0,0.008,0.0)), 1.0);\n    res = abs(res) - .01;\n    result.x = min(result.x, res);\n    \n    if(res <= e){\n        \n        result.y = 3.0;\n    }*/\n    \n    res = planeSDF(pos - vec3(0.0,-.96, 0.0), 5.0, 15.0);\n    result.x = min(res, result.x);\n    if(res <= e){\n        result.y = 4.0;\n    }\n    \n    return result;\n}\n\n//Normals\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 p, in float t )\n{\n#if 0    \n    float e = 0.0001*t;\n\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n#else    \n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.0001*t).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec3 tex3D(vec3 dir)\n{\n    return texture(iChannel0, dir).rgb;\n}\n\n//Raymarching function\n//Accepts ray origin and direction\n//Returns intersected position\nvec4 rayMarch(vec3 ro, vec3 rd, int steps){\n    if(steps == 0){\n        steps = maxSteps;\n    }\n    vec3 pos = ro;\n    float dist = (-1.0);\n    float oldDist = dist;\n    vec3 distRes = vec3(0.0,0.0,0.0);\n    for (int i = 0; i < steps; i++){\n        //run sdf\n        //step size is always half of distance\n        distRes = map(pos);\n        dist = distRes.x;\n\n        if(dist < e && dist > 0.0) {\n            pos = pos + rd * dist; \n            if(i < 5){\n            \n                distRes.y = 4.0;\n            \n            }\n            break;\n        }\n        else if(dist < 0.0){\n            \n        }\n        \n        if(dist < minStepSize){\n            dist = minStepSize;\n            oldDist = dist;\n            \n        }\n        else if(dist == oldDist){\n            //Ray has moved further from surface\n            dist = dist * 2.0;\n            oldDist = oldDist + dist;\n            return vec4(pos, 0.0);\n        }\n        else{\n            dist = dist / 2.0;\n            \n            //return vec4(dist,0.0,0.0,0.0);\n            oldDist = oldDist + dist;\n        }\n        \n        pos = pos + rd * dist;\n    }\n    \n    return vec4(pos, distRes.y);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n    \n    float uvFocLen = 0.5 / tan(fov/2.0);\n    float scaleFac = 1.0/uvFocLen;\n    \n    camPos.x = -3.0 * ((iMouse.x/iResolution.x) - .5);\n    \n    \n    vec3 col = vec3(0.0);\n    vec3 fcol = vec3(0.0);\n    \n    for(int k = 0; k < SAMPLES; k++){\n        float offsetx = sin(float(k) * uv.x)/8.0 ;\n        float offsety = cos(float(k) * uv.y)/8.0;\n        \n        vec2 offsetVec = vec2(offsetx, offsety)/iResolution.xy;\n        uv += offsetVec;\n        vec2 uvFOV = (uv - vec2(0.5))*scaleFac;\n\n\n        vec3 camSpaceUVDir = normalize(vec3(uvFOV.x, uvFOV.y/aspect, 1.0));\n\n        mat3 ca = setCamera(camPos, camTar, 0.0);\n\n\n\n        vec3 rayDir = ca * camSpaceUVDir;\n\n        vec4 res = rayMarch(camPos, rayDir, 0);\n        /*vec4 res = vec4(0.0);\n        if(uv.y < .3){\n            res.w = 1.0;\n        }*/\n        \n        if(res.w > 0.0){\n        // Time varying pixel color\n            //col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n            //Normal as color\n            vec3 normal = calcNormal(res.xyz, length(camPos - res.xyz));\n            col = normal;\n\n\n\n            //Calculate light intensity given square falloff\n          /*  float dist = length(lPos - res.xyz) ;\n            float falloff = max(dist, 1.0); \n            float pointInt = lInt / (falloff * falloff);\n            vec3 colInt = lCol * pointInt;\n\n\n\n            //Shadow for light 1\n            vec3 shadRayDir = normalize(lPos - res.xyz);\n            vec4 shadRes = rayMarch(res.xyz - shadowBias * rayDir, shadRayDir, 0);\n\n            if(shadRes.w > 0.0){\n                colInt = vec3(0.0,0.0,0.0);\n            }*/\n\n            //Calculate specular light intensity\n            //Reflected ray for specular\n          /*  vec3 reflRay = normalize(2.0 * dot(normal, shadRayDir) * normal * -1.0 + shadRayDir);\n            float reflInt = max(dot(reflRay, rayDir), 0.0);\n\n\n            //point light 2\n            float dist2 = length(lPos2 - res.xyz) ;\n            float falloff2 = max(dist2, 1.0); \n            float pointInt2 = lInt2 / (falloff2 * falloff2);\n            vec3 colInt2 = lCol2 * pointInt2;\n\n            //Shadow for light 2\n            shadRayDir = normalize(lPos2 - res.xyz);\n            shadRes = rayMarch(res.xyz - shadowBias * rayDir, shadRayDir, 0);\n\n            if(shadRes.w > 0.0){\n                colInt2 = vec3(0.0,0.0,0.0);\n            }\n\n             //Calculate specular light intensity\n            //Reflected ray for specular\n            reflRay = normalize(2.0 * dot(normal, shadRayDir) * normal * -1.0 + shadRayDir);\n            float reflInt2 = max(dot(reflRay, rayDir),0.0);*/\n\n\n            vec3 surfCol = vec3(1.0,1.0,1.0);\n\n            if(res.w == 4.0){\n                surfCol = vec3(0.0,1.0,0.0);\n            }\n\n            if(res.w == 1.0){\n\n                //Assume white sphere surface, for now\n                surfCol = vec3(1.0,1.0,1.0);\n            }\n            else if(res.w == 2.0){\n                //White ground plane\n                surfCol = vec3(1.0,1.0,1.0);\n            }\n            else if(res.w == 3.0){\n                //Compute Refraction\n                //Fraction of light reflected vs refracted given IOR -- lets try 1.45 for plastic bottle\n                //try 4 refractions\n                //loop -- have incident ray dir, normal, IOR -- don't worry about transparent shadows for now\n                //compute fraction of light reflected vs refracted\n                //compute specular light at each point, multiply by percent reflected\n                //for reflected light, multiply colInt and reflInt by amount reflected\n                //raymarch to next point, comput ray dir, normal, ior\n                //if ray count exceeded and no surface found, compute light at final point and exit\n                \n                //Try\n\n               surfCol = vec3(1.0,1.0,1.0);\n               vec3 calcCol = vec3(0.0,0.0,0.0);\n               float refrInd1 = 1.0;\n               float refrInd2 = 1.5;\n               float refrIndAir = 1.0;\n\n               float reflFrac = 1.0;\n               float transFrac = 0.0;\n               \n               bool insidePlast = true;\n               bool insideWater = false;\n\n               vec3 specRefInt = vec3(0.0);\n\n               float cosAngle = dot(normal, -1.0 * rayDir);\n               float angle = acos(cosAngle);\n\n               vec3 transDir = vec3(0.0,0.0,0.0);\n               float transPow = 1.0;\n\n               vec4 resT = res;\n\n               int numRefr = 10;\n               for (int j = 0; j < numRefr; j++){\n                   float n = refrInd1 / refrInd2;\n                   float n2 = n * n;\n                   float nSin = n * sin(angle);\n                   float nSin2 = nSin * nSin;\n                   float sqrtReflFrac = abs( (refrInd1*cosAngle - refrInd2 * sqrt(1.0 - nSin2))/(refrInd1*cosAngle + refrInd2 * sqrt(1.0 - nSin2)));\n                   reflFrac = sqrtReflFrac * sqrtReflFrac;\n                   //reflFrac = 0.5 * (reflFrac + pow(abs( (-1.0*refrInd2*cosAngle + refrInd1 * sqrt(1.0 - pow((refrInd1/refrInd2) * sin(angle), 2.0)))/(refrInd2*cosAngle + refrInd1 * sqrt(1.0 - pow((refrInd1/refrInd2) * sin(angle), 2.0)))), 2.0));\n\n                   //Use schlick instead\n                  // float r0 = pow((refrInd1 - refrInd2)/(refrInd1 + refrInd2), 2.0);\n                   //reflFrac = r0 + (1.0 - r0)*pow(1.0 - cosAngle, 5.0);\n                  // reflFrac *= 1.0;\n                   /*float cAng = abs(asin(refrInd2/refrInd1));\n                   if(refrInd2 < refrInd1 && angle > cAng){\n                       //reflFrac = min(ang/(PI/2.0), 1.0);\n                       reflFrac = 1.0;\n                   }*/\n                   \n                   reflFrac = min(reflFrac, 1.0);\n                   \n                   transFrac = max(1.0 - reflFrac, 0.0);\n\n                  // specRefInt = surfCol * pow(reflInt, 5.0) * colInt * reflFrac;        \n                   //specRefInt += surfCol * pow(reflInt2,5.0) * colInt2 * reflFrac;\n                   if(j == 0){\n                       \n                       //specRefInt += surfCol * vec3(0.5,0.5,0.5) * reflFrac; \n                       vec3 reflectDir = reflect(rayDir, normal);\n                       specRefInt += surfCol * tex3D(vec3(reflectDir.x, reflectDir.y, -reflectDir.z)) * reflFrac;\n\n                   }\n                   //specRefInt += surfCol * vec3(0.5,0.5,0.5) * reflFrac;\n\n                   \n                   //calcCol = resT.xyz + vec3(0.0, 0.0,0.0);\n                   //calcCol = normal;\n                  /* if(resT.w == 4.0){\n                       calcCol = vec3(1.0, 0.0,0.0);\n                       break;\n                   }*/\n\n\n\n                   if(resT.w == 0.0){\n                      //calcCol += transPow *  vec3(0.5,0.5,0.5);\n                      calcCol += transPow * tex3D(vec3(rayDir.x, rayDir.y, -rayDir.z));\n                     // calcCol = vec3(1.0);\n                      break;\n                   }\n                   \n                   if(resT.w == 7.0){\n                       //Reflecting just the background off the water surface should be a good enough approximation\n                      // calcCol += transPow * reflFrac * vec3(0.5, 0.5, 0.5);\n                   }\n                   \n\n                   else if (resT.w == 2.0  || resT.w == 6.0){\n                       //Compute diffuse\n                       \n                       surfCol = vec3(1.0);\n                       \n                       \n                            //Shadow for light 1\n                           /* vec3 shadRayDir = normalize(lPos - resT.xyz);\n                            vec4 shadRes = rayMarch(resT.xyz - shadowBias * rayDir, shadRayDir, 0);*/\n\n                           /* if(shadRes.w > 0.0){\n                                colInt = vec3(0.0,0.0,0.0);\n                            }*/\n                            \n                          /*  shadRayDir = normalize(lPos2 - resT.xyz);\n                            shadRes = rayMarch(resT.xyz - shadowBias * rayDir, shadRayDir, 0);\n\n                            if(shadRes.w > 0.0){\n                                colInt2 = vec3(0.0,0.0,0.0);\n                            }*/\n                      \n                        \n                      /*  vec3 difReflInt = surfCol * colInt * max(dot(normal, normalize(lPos - resT.xyz)), 0.0);\n                        difReflInt += surfCol * colInt2 * max(dot(normal, normalize(lPos2 - resT.xyz)), 0.0);*/\n                       // calcCol += transPow * (surfCol * ambCol + difReflInt);\n                        calcCol += transPow * ( lighting(rayDir, normal, surfCol, 0.0, 0.8, 0.0 )) ;\n                        //calcCol += normal;\n                        //calcCol = resT.xyz;\n                        break;\n                   }\n                   else if(resT.w == 4.0){\n                        //basic mapping\n                        vec2 texUV = vec2(0.0);\n                        texUV.x = (resT.x + 2.5)/5.0; \n                        texUV.y = (resT.z + 2.5)/5.0;\n                        surfCol = texture(iChannel2, texUV).xyz;\n                        float roughness = 0.95;\n                            roughness -= surfCol.b * 0.4;\n                        \n                        calcCol += transPow * ( lighting(rayDir, normal, surfCol, 0.0, roughness, 0.0 )) ;\n                    }\n                  \n                   \n                   calcCol += max(specRefInt * transPow, 0.0);\n                   \n\n                   if(j == numRefr - 1){\n                       break;\n                   }\n\n                   transPow *= transFrac;\n                   //surfCol = surfCol * reflFrac;\n                   transDir = normalize((refrInd1/refrInd2) * rayDir + ((refrInd1/refrInd2) * cosAngle - sqrt(1.0 - pow(refrInd1 / refrInd2, 2.0) * (1.0 - pow(cosAngle, 2.0)))) * normal);\n                   //transDir = normalize(sqrt(1.0 - pow(refrInd1/refrInd2, 2.0) * (1.0 - pow(cosAngle, 2.0))) * normal + (refrInd1/refrInd2) * (rayDir - cosAngle * normal));\n                  // transDir = (refrInd1/refrInd2) * (rayDir - cosAngle * normal)  + sqrt(1.0 - pow(length((refrInd1/refrInd2) * (rayDir - cosAngle * normal)), 2.0)) * normal;\n\n                   vec3 oldPos = resT.xyz;\n                   resT = rayMarch(resT.xyz + 3.0 * e * transDir, transDir,2048);\n                   \n                    float temp = refrInd1;\n                    refrInd1 = refrInd2;\n                    refrInd2 = temp;\n                      /*if(j == 1){\n                       //water\n                      refrInd2 = insideWater ? refrInd2 : 1.33;\n         \n                      insideWater = insideWater ? false : true;\n                     \n                          calcCol = vec3(1.0);\n                      \n                      calcCol = transDir;\n                      break;\n                      \n                   }*/\n                  \n                     if(resT.w == 3.0  ){\n                       //plastic\n                      refrInd2 = !insideWater && insidePlast ? refrIndAir : refrInd2;\n                      \n                      \n                      insidePlast = insidePlast ? false : true;\n                      //calcCol = vec3(refrInd1 == 1.0);\n                      //break;\n                      //calcCol = vec3(1.0);\n                   }\n                   \n                   \n                   else if(resT.w == 7.0 ){\n                       //water\n                      refrInd2 = insideWater ? refrInd2 : 1.33;\n         \n                      insideWater = insideWater ? false : true;\n                    /* if(j==1){\n                          calcCol = vec3(1.0);\n                      \n                      calcCol = vec3(refrInd1 == 1.0);\n                      break;\n                      }*/\n                   }\n                   \n                 \n                  \n\n                   //Normal\n                   normal = calcNormal(resT.xyz, length(camPos - resT.xyz));\n                   //col = normal;\n\n                    //Calculate light intensity given square falloff\n                    /*dist = length(lPos - resT.xyz) ;\n                    pointInt = lInt / pow(max(dist, 1.0) , 2.0);\n                    colInt = lCol * pointInt;\n\n\n                    //Calculate specular light intensity\n                    //Reflected ray for specular\n                    shadRayDir = normalize(lPos - resT.xyz);\n                    reflRay = normalize(2.0 * dot(normal, shadRayDir) * normal * -1.0 + shadRayDir);\n                    reflInt = max(dot(reflRay, transDir), 0.0);\n\n\n                    //point light 2\n                    dist2 = length(lPos2 - resT.xyz) ;\n                    pointInt2 = lInt2 / pow(max(dist2, 1.0) , 2.0);\n                    colInt2 = lCol2 * pointInt2;\n                    \n\n\n                     //Calculate specular light intensity\n                    //Reflected ray for specular\n                    shadRayDir = normalize(lPos2 - resT.xyz);\n                    reflRay = normalize(2.0 * dot(normal, shadRayDir) * normal * -1.0 + shadRayDir);\n                    reflInt2 = max(dot(reflRay, transDir),0.0);\n\n                   */\n\n                    float j_float = float(j);\n                    normal *= 1.0 - 2.0 * mod(j_float + 1.0, 2.0);\n\n                    cosAngle = dot(normal,-1.0 * transDir);\n                    angle = acos(cosAngle);\n\n                    rayDir = transDir;\n               }\n\n\n               col = calcCol * 1.0;\n               //col = vec3(1.0);\n\n            }\n            \n            else if(res.w == 4.0){\n                //basic mapping\n                vec2 texUV = vec2(0.0);\n                texUV.x = (res.x + 2.5)/10.0; \n                texUV.y = (res.z + 2.5)/10.0;\n                surfCol = texture(iChannel2, texUV).xyz;\n            }\n            \n            else if(res.w == 6.0){\n                //cylinder mapping\n                vec2 texUV = vec2(0.0);\n                texUV.x = asin(res.x/length(res.xz));\n                texUV.x = res.z < 0.0 ? texUV.x + PI : texUV.x;\n                texUV.x /= 2.0 *  PI;\n                texUV.y =  1.3 * (res.y - .6) / .975;\n                surfCol = texture(iChannel1, texUV).xyz;\n            }\n\n            //BRDF\n            /*vec3 difReflInt = surfCol * colInt * max(dot(normal, normalize(lPos - res.xyz)), 0.0);\n            difReflInt += surfCol * colInt2 * max(dot(normal, normalize(lPos2 - res.xyz)), 0.0);\n            vec3 specRefInt = surfCol * pow(reflInt, 10.0) * colInt;        \n            specRefInt += surfCol * pow(reflInt2, 10.0) * colInt2;*/\n            if(res.w != 3.0){\n                //col = surfCol * ambCol + 0.8 * difReflInt + 0.2 * specRefInt;\n                float roughness = 0.7;\n                if(res.w == 4.0){\n                    roughness -= -.25 + surfCol.b * 0.4;\n                }\n\n                col = lighting(vec3(rayDir.x, rayDir.y, -rayDir.z), normal, surfCol, 0.0, roughness, 0.0 ) ;\n                //col = vec3(1.0);\n            }\n            \n            else{\n                //col += surfCol * ambCol;\n            }\n        }\n        else{\n            col = vec3(0.5,0.5,0.5);\n            col = tex3D(vec3(rayDir.x, rayDir.y, -rayDir.z));\n        }\n        fcol += col / float(SAMPLES);\n    }\n\n    //gamma\n    fcol = pow(fcol, vec3(1.0/2.2));\n    // Output to screen\n    fragColor = vec4(fcol,1.0);\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Old watch (IBL). Created by Reinder Nijhoff 2018\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/lscBW4\n//\n// In this buffer I pre-calculate the BRDF integration map, as described in:\n// http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n//\n\nconst float PI = 3.14159265359;\n\n// see: http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\nfloat PartialGeometryGGX(float NdotV, float a) {\n    float k = a / 2.0;\n\n    float nominator   = NdotV;\n    float denominator = NdotV * (1.0 - k) + k;\n\n    return nominator / denominator;\n}\n\nfloat GeometryGGX_Smith(float NdotV, float NdotL, float roughness) {\n    float a = roughness*roughness;\n    float G1 = PartialGeometryGGX(NdotV, a);\n    float G2 = PartialGeometryGGX(NdotL, a);\n    return G1 * G2;\n}\n\nfloat RadicalInverse_VdC(uint bits) {\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n\nvec2 Hammersley(int i, int N) {\n    return vec2(float(i)/float(N), RadicalInverse_VdC(uint(i)));\n} \n\nvec3 ImportanceSampleGGX(vec2 Xi, float roughness) {\n    float a = roughness*roughness;\n    float phi      = 2.0 * PI * Xi.x;\n    float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\n    vec3 HTangent;\n    HTangent.x = sinTheta*cos(phi);\n    HTangent.y = sinTheta*sin(phi);\n    HTangent.z = cosTheta;\n\n    return HTangent;\n}\n\nvec2 IntegrateBRDF(float roughness, float NdotV) {\n    vec3 V;\n    V.x = sqrt(1.0 - NdotV*NdotV);\n    V.y = 0.0;\n    V.z = NdotV;\n\n    float A = 0.0;\n    float B = 0.0;\n\n    const int SAMPLE_COUNT = 128;\n\n    vec3 N = vec3(0.0, 0.0, 1.0);\n    vec3 UpVector = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n    vec3 TangentX = normalize(cross(UpVector, N));\n    vec3 TangentY = cross(N, TangentX);\n\n    for(int i = 0; i < SAMPLE_COUNT; ++i)  {\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n        vec3 HTangent = ImportanceSampleGGX(Xi, roughness);\n        \n        vec3 H = normalize(HTangent.x * TangentX + HTangent.y * TangentY + HTangent.z * N);\n        vec3 L = normalize(2.0 * dot(V, H) * H - V);\n\n        float NdotL = max(L.z, 0.0);\n        float NdotH = max(H.z, 0.0);\n        float VdotH = max(dot(V, H), 0.0);\n\n        if(NdotL > 0.0) {\n            float G = GeometryGGX_Smith(NdotV, NdotL, roughness);\n            float G_Vis = (G * VdotH) / (NdotH * NdotV);\n            float Fc = pow(1.0 - VdotH, 5.0);\n\n            A += (1.0 - Fc) * G_Vis;\n            B += Fc * G_Vis;\n        }\n    }\n    A /= float(SAMPLE_COUNT);\n    B /= float(SAMPLE_COUNT);\n    return vec2(A, B);\n}\n\nbool resolutionChanged() {\n    return floor(texelFetch(iChannel0, ivec2(0), 0).r) != floor(iResolution.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if(resolutionChanged()) {\n        if (fragCoord.x < 1.5 && fragCoord.y < 1.5) {\n            fragColor = floor(iResolution.xyxy);\n        } else {\n\t   \t\tvec2 uv = fragCoord / iResolution.xy;\n    \t\tvec2 integratedBRDF = IntegrateBRDF(uv.y, uv.x);\n   \t \t\tfragColor = vec4(integratedBRDF, 0.0,1.0);\n        }\n    } else {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ld3zX.jpg", "access": "api", "license": "mit", "functions": [[1531, 1531, 1586, 1688, 1774], [1776, 1776, 1813, 1915, 1996], [1998, 2088, 2160, 2160, 2244], [2277, 2277, 2394, 2394, 3042], [3532, 3532, 3584, 3584, 3761], [3781, 3781, 3815, 3815, 3835], [3837, 3845, 3886, 3886, 3965], [3967, 3967, 4030, 4030, 4151], [4155, 4155, 4213, 4213, 4477], [4479, 4479, 4525, 4525, 4638], [4640, 4640, 4748, 4748, 6626], [6630, 6645, 6664, 6664, 8344], [8357, 8403, 8445, 8445, 9002], [9004, 9004, 9026, 9026, 9068], [9070, 9159, 9202, 9202, 10327], [10331, 10331, 10388, 10438, 25873]], "test": "untested"}
{"id": "7tt3RX", "name": "Collatz Fractal Sequence", "author": "abhinavneelam", "description": "Fractal showing collatz sequencing based on complex numbers.", "tags": ["fractal"], "likes": 5, "viewed": 197, "published": 3, "date": "1636595985", "time_retrieved": "2024-07-30T18:49:08.382485", "image_code": "#define POINT 2\n#define MAXITER 5\n#define MAXVALUE 100.0f\n\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n}\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 collatz(in vec2 fragCoord) {\n    const float pi = acos(-1.0f);\n    \n    vec2 cur=fragCoord;//a+bi (a,b)\n    \n    for(int i=0;i<MAXITER;++i) {\n        vec2 co = vec2(cos(pi*cur.x)*cosh(pi*cur.y), -sin(pi*cur.x)*sinh(pi*cur.y));\n        \n        cur = 0.25 * (vec2(2.0,0.0) + 7.0 * cur - cmul( vec2(2.0,0.0) + 5.0 * cur, co));\n        \n        if(length(cur) > MAXVALUE) {\n            //return vec3(1.0f);\n            float par = sin(0.2*iTime)*(float(i)/float(MAXITER));\n            \n            return 1.0f * hsv2rgb(vec3(par,1.0,1.0));\n        }\n    }\n    \n    return vec3(0.0f);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 pos = vec2(sin(.2*iTime),0.0);\n    \n    float zoomfunc = 0.75*(sin(iTime)*.5+.5)+1.0;\n    \n    fragCoord-=.5;\n    \n    vec2 uv = fragCoord/min(iResolution.x,iResolution.y);\n\n    vec3 col = collatz((zoomfunc)*(uv-vec2(.88,.5)+pos));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tt3RX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 86, 86, 139], [141, 141, 168, 168, 295], [886, 886, 941, 941, 1220]], "test": "untested"}
{"id": "sldGzs", "name": "test1231232312341234", "author": "merelyigor", "description": "test1231232312341234", "tags": ["test1231232312341234"], "likes": 1, "viewed": 211, "published": 3, "date": "1636580485", "time_retrieved": "2024-07-30T18:49:09.131482", "image_code": "\nfloat sun(vec2 uv, float battery)\n{\n \tfloat val = smoothstep(0.3, 0.29, length(uv));\n \tfloat bloom = smoothstep(0.7, 0.0, length(uv));\n    float cut = 3.0 * sin((uv.y + iTime * 0.2 * (battery + 0.02)) * 100.0) \n\t\t\t\t+ clamp(uv.y * 14.0 + 1.0, -6.0, 6.0);\n    cut = clamp(cut, 0.0, 1.0);\n    return clamp(val * cut, 0.0, 1.0) + bloom * 0.6;\n}\n\nfloat grid(vec2 uv, float battery)\n{\n    vec2 size = vec2(uv.y, uv.y * uv.y * 0.2) * 0.01;\n    uv += vec2(0.0, iTime * 4.0 * (battery + 0.05));\n    uv = abs(fract(uv) - 0.5);\n \tvec2 lines = smoothstep(size, vec2(0.0), uv);\n \tlines += smoothstep(size * 5.0, vec2(0.0), uv) * 0.4 * battery;\n    return clamp(lines.x + lines.y, 0.0, 3.0);\n}\n\nfloat dot2(in vec2 v ) { return dot(v,v); }\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k){\n\tfloat h = clamp(0.5 + 0.5 * (d2 - d1) /k,0.0,1.0);\n    return mix(d2, d1 , h) - k * h * ( 1.0 - h);\n}\n\nfloat sdCloud(in vec2 p, in vec2 a1, in vec2 b1, in vec2 a2, in vec2 b2, float w)\n{\n\t//float lineVal1 = smoothstep(w - 0.0001, w, sdLine(p, a1, b1));\n    float lineVal1 = sdLine(p, a1, b1);\n    float lineVal2 = sdLine(p, a2, b2);\n    vec2 ww = vec2(w*1.5, 0.0);\n    vec2 left = max(a1 + ww, a2 + ww);\n    vec2 right = min(b1 - ww, b2 - ww);\n    vec2 boxCenter = (left + right) * 0.5;\n    //float boxW = right.x - left.x;\n    float boxH = abs(a2.y - a1.y) * 0.5;\n    //float boxVal = sdBox(p - boxCenter, vec2(boxW, boxH)) + w;\n    float boxVal = sdBox(p - boxCenter, vec2(0.04, boxH)) + w;\n    \n    float uniVal1 = opSmoothUnion(lineVal1, boxVal, 0.05);\n    float uniVal2 = opSmoothUnion(lineVal2, boxVal, 0.05);\n    \n    return min(uniVal1, uniVal2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy)/iResolution.y;\n    float battery = 1.0;\n    //if (iMouse.x > 1.0 && iMouse.y > 1.0) battery = iMouse.y / iResolution.y;\n    //else battery = 0.8;\n    \n    //if (abs(uv.x) < (9.0 / 16.0))\n    {\n        // Grid\n        float fog = smoothstep(0.1, -0.02, abs(uv.y + 0.2));\n        vec3 col = vec3(0.0, 0.1, 0.2);\n        if (uv.y < -0.2)\n        {\n            uv.y = 3.0 / (abs(uv.y + 0.2) + 0.05);\n            uv.x *= uv.y * 1.0;\n            float gridVal = grid(uv, battery);\n            col = mix(col, vec3(1.0, 0.5, 1.0), gridVal);\n        }\n        else\n        {\n            float fujiD = min(uv.y * 4.5 - 0.5, 1.0);\n            uv.y -= battery * 1.1 - 0.51;\n            \n            vec2 sunUV = uv;\n            vec2 fujiUV = uv;\n            \n            // Sun\n            sunUV += vec2(0.75, 0.2);\n            //uv.y -= 1.1 - 0.51;\n            col = vec3(1.0, 0.2, 1.0);\n            float sunVal = sun(sunUV, battery);\n            \n            col = mix(col, vec3(1.0, 0.4, 0.1), sunUV.y * 2.0 + 0.2);\n            col = mix(vec3(0.0, 0.0, 0.0), col, sunVal);\n            \n            // fuji\n            float fujiVal = sdTrapezoid( uv  + vec2(-0.75+sunUV.y * 0.0, 0.5), 1.75 + pow(uv.y * uv.y, 2.1), 0.2, 0.5);\n            float waveVal = uv.y + sin(uv.x * 20.0 + iTime * 2.0) * 0.05 + 0.2;\n            float wave_width = smoothstep(0.0,0.01,(waveVal));\n            \n            // fuji color\n            col = mix( col, mix(vec3(0.0, 0.0, 0.25), vec3(1.0, 0.0, 0.5), fujiD), step(fujiVal, 0.0));\n            // fuji top snow\n            col = mix( col, vec3(1.0, 0.5, 1.0), wave_width * step(fujiVal, 0.0));\n            // fuji outline\n            col = mix( col, vec3(1.0, 0.5, 1.0), 1.0-smoothstep(0.0,0.01,abs(fujiVal)) );\n            //col = mix( col, vec3(1.0, 1.0, 1.0), 1.0-smoothstep(0.03,0.04,abs(fujiVal)) );\n            //col = vec3(1.0, 1.0, 1.0) *(1.0-smoothstep(0.03,0.04,abs(fujiVal)));\n            \n            // horizon color\n            col += mix( col, mix(vec3(1.0, 0.12, 0.8), vec3(0.0, 0.0, 0.2), clamp(uv.y * 3.5 + 3.0, 0.0, 1.0)), step(0.0, fujiVal) );\n            \n            // cloud\n            vec2 cloudUV = uv;\n            cloudUV.x = mod(cloudUV.x + iTime * 0.1, 4.0) - 2.0;\n            float cloudTime = iTime * 0.5;\n            float cloudY = -0.5;\n            float cloudVal1 = sdCloud(cloudUV, \n                                     vec2(0.1 + sin(cloudTime + 140.5)*0.1,cloudY), \n                                     vec2(1.05 + cos(cloudTime * 0.9 - 36.56) * 0.1, cloudY), \n                                     vec2(0.2 + cos(cloudTime * 0.867 + 387.165) * 0.1,0.25+cloudY), \n                                     vec2(0.5 + cos(cloudTime * 0.9675 - 15.162) * 0.09, 0.25+cloudY), 0.075);\n            cloudY = -0.6;\n            float cloudVal2 = sdCloud(cloudUV, \n                                     vec2(-0.9 + cos(cloudTime * 1.02 + 541.75) * 0.1,cloudY), \n                                     vec2(-0.5 + sin(cloudTime * 0.9 - 316.56) * 0.1, cloudY), \n                                     vec2(-1.5 + cos(cloudTime * 0.867 + 37.165) * 0.1,0.25+cloudY), \n                                     vec2(-0.6 + sin(cloudTime * 0.9675 + 665.162) * 0.09, 0.25+cloudY), 0.075);\n            \n            float cloudVal = min(cloudVal1, cloudVal2);\n            \n            //col = mix(col, vec3(1.0,1.0,0.0), smoothstep(0.0751, 0.075, cloudVal));\n            col = mix(col, vec3(0.0, 0.0, 0.2), 1.0 - smoothstep(0.075 - 0.0001, 0.075, cloudVal));\n            col += vec3(1.0, 1.0, 1.0)*(1.0 - smoothstep(0.0,0.01,abs(cloudVal - 0.075)));\n        }\n\n        col += fog * fog * fog;\n        col = mix(vec3(col.r, col.r, col.r) * 0.5, col, battery * 0.7);\n\n        fragColor = vec4(col,1.0);\n    }\n    //else fragColor = vec4(0.0);\n\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sldGzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 36, 36, 341], [343, 343, 379, 379, 680], [682, 682, 706, 706, 725], [727, 727, 792, 792, 1102], [1104, 1104, 1153, 1153, 1272], [1274, 1274, 1311, 1311, 1395], [1397, 1397, 1446, 1446, 1549], [1551, 1551, 1634, 1700, 2304], [2306, 2306, 2363, 2363, 6188]], "test": "untested"}
{"id": "7ldGzl", "name": "particles without particles", "author": "lomateron", "description": "click to give it a push\nusing cos() shaped convolution for mass atraction creates discrete particles\njust went full circle relative to https://www.shadertoy.com/view/Wsf3Dj", "tags": ["fluid", "convolution", "kernel"], "likes": 40, "viewed": 803, "published": 3, "date": "1636565654", "time_retrieved": "2024-07-30T18:49:10.230544", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = fragCoord/iResolution.xy;\n    vec4 a = texture(iChannel0,u);\n    fragColor = sin(a*6.)*.5+.3+a.z;\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4  r = vec4(0);\n    vec4  a = A(u);\n    float z    = 8.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        float l = length(vec2(i,j));\n        if((i==0.&&j==0.)|| l>z+.1){continue;}\n        vec2  c = normalize(vec2(i,j));\n        vec4  a2= A(u+vec2(i,j));\n        vec4  b = a2-a;                  l*=2.;\n        r.xy += c*b.z*cos(l)*exp(-l*l*.05);\n        r.z  += dot(c,b.xy           );//*a2.z;\n        r.w  += dot(c,b.yx*vec2(-1,1));//*a2.z;\n    }}\n    fragColor = r;\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4  r = A(u);\n    float z    = 8.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n      if((i==0.&&j==0.)||length(vec2(i,j))>z+1.){continue;}\n      vec4 b = B(u+vec2(i,j));\n      vec2 c = normalize(-vec2(i,j))*.000125;//*r.z;\n      r.xy += +b.z*c              *-1.\n              +b.w*c.yx*vec2(-1,1)*0.\n              +abs(b.z)*(step(0.,b.w)*2.-1.)*c.yx*vec2(-1,1)*0.;\n    }}\n\n    fragColor = r;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\n#define C(u) texture(iChannel2,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4 t = A(u);\n    vec2 m = +t.xy\n             +B(u).xy;//*(t.z-.5)*4. //change the .3 to .6\n             +t.z*vec2(0,.0)\n             -C(u).x*t.xy*.0;\n    float s = 0.;\n    float z    = 6.;//kernel convolution size\n    float blur = 6./z;\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        if(length(vec2(i,j))>z+.1){continue;}\n        vec2 c = (m+vec2(i,j))*blur;\n        s += exp(-dot(c,c));\n    }}\n    if(s==0.){s = 1.;}\n    s = 1./s;\n    \n    fragColor = vec4(m,s,0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4 a = vec4(0);\n    float z    = 6.;//kernel convolution size\n    float blur = 6./z;\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        if(length(vec2(i,j))>z+.1){continue;}\n        vec4 t = A(u+vec2(i,j));\n        vec4 m = B(u+vec2(i,j));\n        vec2 c = (m.xy-vec2(i,j))*blur;\n        float z = t.z*m.z*exp(-dot(c,c));\n        a.xy += z*m.xy;\n        a.z  += z;\n    }}\n    float tz = 1./a.z; if(a.z==0.){tz = 0.;}//avoid division by zero\n    a.xy *= tz; \n    //a = A(u);\n    if(iMouse.z>0.)\n    {\n        vec2 m = 32.*(u-iMouse.xy)/iResolution.y;\n        a += vec4(1,0,0,0)*.1*exp(-dot(m,m));\n    }\n    if(iFrame==0)\n    {\n        vec2 m = 8.*(u-iResolution.xy*.5)/iResolution.y;\n        a = vec4(0,0,1,1)*exp(-dot(m,m));\n    }\n    fragColor = a;\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ldGzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 170]], "test": "untested"}
{"id": "st3Gzs", "name": "slope blur", "author": "xZAKHAMx", "description": "I tried to make something like slope blur nodes in substance designer. \n", "tags": ["blur", "slope"], "likes": 1, "viewed": 299, "published": 3, "date": "1636564060", "time_retrieved": "2024-07-30T18:49:11.072293", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv1 = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.y -= .05;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 col = vec3(0.);\n    \n    vec4 tex = texture(iChannel0, uv);\n    ivec2 texSize  = ivec2(iResolution.x/1.78, iResolution.y);\n    ivec2 texIndex = ivec2(uv1.xy * vec2(texSize)); \n    vec4 right = texelFetch(iChannel0 , texIndex + ivec2(-1, 0), 0).rrrr;\n    vec4 left  = texelFetch(iChannel0 , texIndex + ivec2(-1, 0), 0).rrrr;\n    vec4 up    = texelFetch(iChannel0 , texIndex + ivec2(0, -1), 0).rrrr;\n    vec4 down  = texelFetch(iChannel0 , texIndex + ivec2(0, 1), 0).rrrr;\n    \n    float scale = (abs(sin(iTime+1.*2.)*2.));\n    float dx = (right.r - left.r) / 2.*scale;\n    float dy = (up.r - down.r) / 2.*scale;\n    \n\n    \n    vec3 grid = vec3(dx, dy, 0.);\n    \n    vec2 newUV = uv + grid.xy;\n    float len = length(newUV);\n    col = vec3(smoothstep(.4, .39, len));\n\n    fragColor = vec4(col, 1.);\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float random (in vec2 uv) {\n    return fract(sin(dot(uv.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat noise (in vec2 uv) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    fragColor = vec4(noise(uv*10.));\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st3Gzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 1026]], "test": "untested"}
{"id": "stdGRl", "name": "percolation network 2", "author": "FabriceNeyret2", "description": "atoms bonding (polymerization) / diffusion through cracks (water in soil or in coffee) can be model as percolation in networks. Here, connectivity threshold controls the propagation of the power waves.\nYou can tune the thresold buffA::17 ( + iTime→0 in C ", "tags": ["short", "network", "connect", "percolation", "molecules", "bonds"], "likes": 31, "viewed": 588, "published": 3, "date": "1636562062", "time_retrieved": "2024-07-30T18:49:11.855199", "image_code": "// percolation network -----------------------------------------\n// - denser network: change Common:N\n// - chasing the global connectivity threshold: change BuffA:17 + replace iTime with 0 in Common:C\n\n// variant of https://shadertoy.com/view/NldGzs\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    return length(p - b * clamp(dot(p, b) / dot(b, b), 0., 1.));                      \n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = N *( u+u - R ) / R.y,\n         I = floor(U), F = fract(U), D,A,B;        \n    O-=O;\n // O = hue( T( I+floor(R/2.)).x );               // display power waves\n\n    for( int k=0; k<9; k++ ) {\n        D = vec2(k%3,k/3)-1., A = D + C(I+D);\n    //  O = max(O, .3 / length(F-A) );             // blobs\n        for( int j=0; j<9; j+= j==k?2:1 ) {\n            D = vec2(j%3,j/3)-1., B = D + C(I+D);\n            float d = length(B-A); d = max(0., 1.5-d);\n            if (d>0.) O = max(O, smoothstep(3.*N/R.y,0., line(F,A,B) - .02 * d*4. )  *d*2. );\n            //*hue(d) \n    } }\n    O *=  hue( T( I+floor(R/2.)).x );               // display power waves\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// percolation: propagate power ( = iTime )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    if (iFrame<1) { O-=O; return; }\n    \n    vec2  I=u-floor(R/2.),D,A=abs(I),B,P;        \n    O = T(u);                                        // previous state\n  //if (max(A.x-9.*R.x/R.y,A.y-9.)>0.) O.r = iTime;  // borders: inject fresh power = iTime\n    if ( I.x < - (N-2.)*R.x/R.y ) O.r = 4.*iTime;    // left border: inject fresh power = iTime\n    \n    float d; I = floor(I);\n    A = C(I);             \n    for( int j=0; j<25; j+= j==11?2:1 ) {            \n        D = vec2(j%5,j/5)-2., B = D + C(I+D);\n        d = length(B-A); \n        if (d < 1.) O.x = max(O.x, T(u+D).x );       // if connected, propagate freshest power\n    }       \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float N = 10.; // cells density\n\n#define R     iResolution.xy \n#define T(U)  texelFetch(iChannel0, ivec2( U ), 0 )\n#define H(p)  fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define C(p) (.5+.3*H(p+.5)+.2*vec2( cos( (H(p).y-.5)*iTime + 6.3*H(p).x + vec2(0,33) ) ) )\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdGRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[317, 317, 352, 352, 462], [464, 464, 502, 502, 1161]], "test": "untested"}
{"id": "NldGzs", "name": "percolation network", "author": "FabriceNeyret2", "description": "atoms bonding (polymerization ) / diffusion through cracks ( water in soil or in coffee ) can be model as percolation in networks. Here, connectivity between nodes is \"slightly smooth\" for a better feeling of the connectome.", "tags": ["short", "network", "connect", "percolation", "molecules", "bonds"], "likes": 20, "viewed": 409, "published": 3, "date": "1636558466", "time_retrieved": "2024-07-30T18:49:12.684981", "image_code": "#define H(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define C(p) (.5+.5*vec2( cos( (H(p).y-.5)*iTime + 6.3*H(p).x + vec2(0,33) ) ) )\n//#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    return length(p - b * clamp(dot(p, b) / dot(b, b), 0., 1.));                      \n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 10.*( u+u - R ) / R.y,\n         I = floor(U), F = fract(U), D,A,B;        \n    O-=O;\n\n    for( int k=0; k<9; k++ ) {\n        D = vec2(k%3,k/3)-1., A = D + C(I+D);\n        O.r = max(O.r, .3 / length(F-A) );             // red blobs\n        for( int j=0; j<9; j+= j==k-1?2:1 ) {\n            D = vec2(j%3,j/3)-1., B = D + C(I+D);\n            float d = length(B-A); d = max(0., 1.5-d); // A-B connectivity\n            if (d>0.) O = max(O, smoothstep(30./R.y,0., line(F,A,B) - .02 * d*4. )  *d*2. );\n            //*hue(d) \n    } }\n    \n\n    if ( iMouse.z>0. && min(F.x,F.y)<20./R.y ) O.b++;  // click to see grid\n    //O = sqrt(O);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NldGzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[224, 224, 259, 259, 369], [371, 371, 409, 409, 1080]], "test": "untested"}
{"id": "flc3Rs", "name": "Licorice Wheel Tower", "author": "Tater", "description": "The code became very messy but the result is good, just don't look at the code :)", "tags": ["3d", "raymarching", "spiral", "roll"], "likes": 61, "viewed": 815, "published": 3, "date": "1636529648", "time_retrieved": "2024-07-30T18:49:13.538699", "image_code": "// Fork of \"Spiral SDF testing 4\" by Tater. https://shadertoy.com/view/Nl3Gzj\n// 2021-11-10 02:34:13\n\n// Fork of \"Spiral SDF testing 3\" by Tater. https://shadertoy.com/view/Nlc3Rj\n// 2021-11-08 02:08:11\n\n// Fork of \"Spiral SDF testing 2\" by Tater. https://shadertoy.com/view/fs3Xzf\n// 2021-11-08 02:05:42\n\n// Fork of \"Spiral SDF testing\" by Tater. https://shadertoy.com/view/fs3SzX\n// 2021-10-07 08:34:52\n\n//Inspiration:\n//https://twitter.com/smjtyazdi/status/1457290470497869824\n//https://www.brucescandy.com/products/red-licorice-wheels\n\n\n#define MDIST 150.0\n#define STEPS 128.0\n\n#define pmod(p,x) (mod(p,x)-0.5*(x))\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\nvec3 rdg;\nvec3 hsv(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n//iq extrude\nfloat ext(vec3 p, float s, float h){\n  vec2 b = vec2(s,abs(p.y)-h);\n  return min(max(b.x,b.y),0.)+length(max(b,0.));\n}\n\nfloat diplane(vec3 p,vec3 b,vec3 rd){\n    vec3 dir = sign(rd)*b;   \n    vec3 rc = (dir-p)/rd;\n    return rc.z+0.01;\n}\nfloat lim(float p, float s, float lima, float limb){\n    return p-s*clamp(round(p/s),lima,limb);\n}\nfloat idlim(float p, float s, float lima, float limb){\n    return clamp(round(p/s),lima,limb);\n}\n\n\n\n//This is a large mess :)\nvec2 spiral(vec2 p, float t, float m, float scale, float size, float expand, float pz,float timeOffset){\n    \n    size-=expand-0.01;\n    float R1 = (sqrt(m*(m*pi+4.0*t*pi)))+m*sqrt(pi)/(2.0*m*sqrt(pi)) -1.0;\n    float RT1 = R1;\n    float R2 = (sqrt(m*(m*pi+4.0*max(-t+timeOffset,0.)*pi)))+m*sqrt(pi)/(2.0*m*sqrt(pi)) -1.0;\n    float RT2 = R2;\n    R1 = R1*m-m*0.5;\n    R2 = R2*m-m*0.5;\n    float centDist = 22.0*3.5*scale+sin(t*0.5+pi)*1.25;\n\n    float L = sqrt(centDist*centDist-(R2+R1)*(R2+R1));\n    \n    p.x+=L*0.5*sin(t);\n    p*=rot(-(RT2-RT1)*pi*1.0);\n    p*=rot(-atan((R2+R1)/L)-0.13);\n    p.x-=L*0.5;\n    p.y-=R2;\n\n    vec2 po3 = p;\n    float s = sign(p.x);\n    p.x = abs(p.x);\n    \n    float c = max(p.x+0.125+expand,abs(p.y)-(R2+R1)*2.0);\n    \n    p.x-=L*0.5;\n\n    p.y*=s;\n    float to2 = t;\n    t*=s;\n    \n    //if(s<0.0)t+=timeOffset;\n    \n    t = max(t,0.);\n    float to = t;\n\n    if(s>0.)t=RT1;\n    else t = RT2;\n    vec2 po = p;\n    p.y+=-t*m-m*0.5;\n\n    p*=rot(t*pi*2.+pi/2.);\n    \n    float theta = atan(p.y,p.x);\n    theta = clamp(theta,-pi,pi);\n    p = vec2(theta,length(p));\n    \n    p.y+=theta*scale*0.5;\n\n    float py = p.y;\n    float id = floor((p.y+m*0.5)/m);\n    p.y = lim(p.y,m,0.,floor(t));\n    float py2 = p.y;\n    float hel = -(theta+pi)/(2.*pi)+id; \n    \n    float a = abs(p.y)-size;\n    \n    p.y = py;\n    p.x -= pi;\n    p.y -= (floor(t)+1.5)*m-m*0.5;\n    float b = max(abs(p.y),abs(p.x)-(pi*2.)*fract(t)+size );\n    \n    if(a>b-size){\n        a=b-size;\n        py2=p.y;\n    }\n    b = abs(po.y)-size;\n    b = max(po.x*30.,b);\n    \n    if(b<a) {\n        id = ceil(t);\n        py2=-po.y;\n        hel*=id;\n    }\n    else hel*=max(id,0.4);\n    \n    float strip = (sin(hel*pi*20.)*0.5+0.5);\n    vec3 p2 = vec3(hel,py2+hel*0.1,pz)*7.0+to2*0.2;\n    p2.xy*=rot(0.4);\n    //Taken from https://www.shadertoy.com/view/tsBSzc\n    strip =  smoothstep(-.05,.05,  length(p2 - (floor(p2) + cos(floor(p2.zxy) * 10.) * .25 + .5)) - .25);\n    \n    if(b<a){\n        hel = (po3.x*(0.04/scale)-to2/(sqrt(pi)*(0.04/scale)))*1.1;\n        p2 = vec3(hel,po3.y,pz*0.8+hel*0.01)*8.0+to2*0.2;\n        p2.xy*=rot(0.4);\n        float strip2 = smoothstep(-.05,.05,  length(p2 - (floor(p2) + cos(floor(p2.zxy) * 10.) * .25 + .5)) - .3);\n        strip = mix(strip,strip2,1.0-smoothstep(-0.4,0.,po.x));\n       // strip = strip2;\n    }\n    a = min(a,b);\n    a = min(a,c); \n    return vec2(a,strip);\n}\nvec4 map(vec3 p){\n    float t = iTime;\n    vec3 rd2 = rdg;\n    \n    p.yz=p.zy;\n    rd2.yz=rd2.zy;\n    \n    p.zx*=rot(sin(t)*0.125);\n    rd2.zx*=rot(sin(t)*0.125);\n    p.zx*=rot(cos(t)*0.125);\n    rd2.zx*=rot(cos(t)*0.125);\n    p.xy*=rot(pi);\n    rd2.xy*=rot(pi);\n    p.xy*=rot(t);\n    rd2.xy*=rot(t);\n    \n    vec3 po = p;\n    vec2 a = vec2(1);\n    \n    float timeOffset = 30.0;\n    \n    float scale = 0.05;\n    float m = pi*scale;\n    float size = 0.07;\n    float expand = m*0.5;\n    float count = 14.0;\n    float thick = 0.075;\n    \n    float id = idlim(p.z,m+scale+thick*1.5,-count,count);\n    p.z = lim(p.z,m+scale+thick*1.5,-count,count);\n    t*=0.25;\n    t+=id*0.025;\n    //timeOffset+=id*1.0;\n    t = (tanh(sin(t)*1.2)*0.55+0.5)*timeOffset;\n    \n    p.xy*=rot(id*pi/30.0);\n    \n    vec2 b = spiral(p.xy, t, m, scale, size, expand, po.z,timeOffset);\n    a.x = ext(p.yzx,b.x,thick)-expand;\n    a.x*=0.9;\n    vec2 c= vec2(diplane(p,vec3(m+thick-scale),rd2)*0.9,5.0);\n    \n    a.y+=b.y;\n    float nsdf = a.x;\n    a=(a.x<c.x)?a:c;\n    return vec4(a,nsdf,id);\n}\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.005,0);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,7,-5)*1.1;\n    ro.yz*=rot(0.2);\n    if(iMouse.z>0.){\n    ro.yz*=rot(3.0*(iMouse.y/iResolution.y-0.2));\n    ro.zx*=rot(-7.0*(iMouse.x/iResolution.x-0.5));\n    }\n    vec3 lk = vec3(0,0,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*(0.55)+uv.x*r+uv.y*cross(f,r));  \n    rdg = rd;\n    vec3 p = ro;\n    float dO = 0.;\n    bool hit = false;\n    vec4 d= vec4(0);\n    for(float i = 0.; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x;\n        if(abs(d.x)<0.001){\n            hit = true;\n            break;\n        }\n        if(dO>MDIST){\n            dO = MDIST;\n            break;\n        }\n    }\n    vec3 bg = mix(vec3(0.710,0.310,0.792),vec3(0.184,0.031,0.286)*0.75,length(uv));\n    if(hit&&d.y!=5.0)\n    {\n        vec3 ld = normalize(vec3(0,1,0));\n      \n        //sss from nusan\n        float sss=0.15;\n        for(float i=1.; i<10.; ++i){\n            float dist = i*0.05;\n            sss += smoothstep(0.,1.,map(p+ld*dist).z/dist)*0.055;\n        }\n        vec3 al = vec3(0.25,0.25,0.373)*0.8;\n        vec3 n = norm(p);\n        vec3 r = reflect(rd,n);\n        float diff = max(0.,dot(n,ld));\n        float amb = dot(n,ld)*0.45+0.55;\n        float spec = pow(max(0.,dot(r,ld)),40.0);\n        //blackle ao\n        #define AO(a,n,p) smoothstep(-a,a,map(p+n*a).z)\n        float ao = AO(.3,n,p)*AO(.5,n,p)*AO(.9,n,p);\n\n        col = al*\n        mix(vec3(0.169,0.000,0.169),vec3(0.984,0.996,0.804),mix(amb,diff,0.75))\n        +spec*0.3;\n        col+=sss*(hsv(vec3(fract(d.w*0.5)*0.45+0.75,1.,1.35)));\n        col=pow(col,vec3(mix(1.2,1.0,d.y-1.0)));\n        col*=mix(0.8,1.0,d.y-1.0);\n        col*=mix(ao,1.,0.6);\n        col = pow(col,vec3(0.7));\n    }\n    else{\n    col = bg;\n    }\n    col = clamp(col,0.,1.);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flc3Rs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[703, 703, 720, 720, 889], [890, 903, 939, 939, 1021], [1023, 1023, 1060, 1060, 1140], [1141, 1141, 1193, 1193, 1239], [1240, 1240, 1294, 1294, 1336], [1340, 1366, 1470, 1470, 3759], [3760, 3760, 3777, 3777, 4822], [4823, 4823, 4841, 4841, 4969], [4971, 4971, 5028, 5028, 6959]], "test": "untested"}
{"id": "fl33zs", "name": "Wood carvings", "author": "jarble", "description": "A series of richly decorated wooden artifacts.", "tags": ["fractal", "wood", "carving"], "likes": 3, "viewed": 248, "published": 3, "date": "1636519702", "time_retrieved": "2024-07-30T18:49:14.423334", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5/2.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime)/10.0+uv.x);\n    vec3 random1 = (hash31(1.+t2)-vec3(.5))/4.;\n    vec3 random2 = (hash31(1.+t2)-vec3(.5))/4.;\n    vec3 random3 = (hash31(2.+t2)-vec3(.5))/4.;\n    vec3 random4 = (hash31(3.+t2)-vec3(.5))/4.;\n    \n    float offset = .5;\n    float scale2 = 1.5;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        //float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            \n            uv = triangle_wave(uv.yx-offset,scale)+triangle_wave(uv,scale);\n            \n            for(int k = 0; k < 3; k++){\n                uv /= scale2;\n                uv = triangle_wave((uv-random2[k])/(random4[k]+1.),scale+random3[k]).yx;\n\n                scale /= 1.-(scale2+uv.x-uv.y)*col.x/5.;\n                scale2 += (col.x);\n\n            }\n            \n\n            col[c] = abs((uv.x)-(uv.y))/2.;\n\n        }\n\t}\n    \n    fragColor = vec4((col*4.),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl33zs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [590, 590, 629, 629, 674], [676, 676, 733, 733, 1940]], "test": "untested"}
{"id": "ft3Gzs", "name": "Persian carpet 16", "author": "jarble", "description": "These patterns resemble Persian carpets.", "tags": ["fractal", "carpet", "rug"], "likes": 11, "viewed": 329, "published": 3, "date": "1636513420", "time_retrieved": "2024-07-30T18:49:15.186293", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5/2.;\n\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime)/10.0+uv.x);\n    vec3 random1 = (hash31(1.+t2)-vec3(.5))/4.;\n    vec3 random2 = (hash31(2.+t2)-vec3(.5))/4.;\n    vec3 random3 = (hash31(3.+t2)-vec3(.5))/4.;\n    vec3 random4 = (hash31(4.+t2)-vec3(.5))/4.;\n    \n    float offset = .5;\n    float scale2 = 1.125;\n    float bend = 1.;\n    vec3 col1 = col;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        //float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            //float scale = scale - col.x/64.;\n\n            //float bend = 1.+random3[k];\n            //float bend = abs(fract((uv.x)*3.)-.5)/3.+1.;\n            //float bend = 1.+1./3.;\n            //float bend = scale2;\n            \n            //bend = abs(fract(((uv.x+uv.y)))-.5)+1.+1.;\n            \n            //uv *= bend+col.x;\n            uv = triangle_wave(uv.yx-offset,scale)/bend+triangle_wave(uv,scale)*bend;\n            //uv *= bend+col.x;\n            \n            for(int k = 0; k < 3; k++){\n                //uv.y /= scale2+col.x;\n                uv.y /= scale2;\n                \n                //uv *= bend-col.x;\n                uv = triangle_wave((uv-random2[k])/(random4[k]+1.),scale+random3[k]).yx;\n                uv.x /= -scale2;\n                scale /= 1.+(scale2+uv.x-uv.y)*col.x/5.;\n                scale2 -= (col.x-1.-uv.x+uv.y)/12.;\n                //bend *= -1.;\n                //bend -= 1./3.-col.x;\n                //bend = 1.+uv.x/2.;\n\n\n            }\n            //bend *= -1.;\n            //bend -= 1./3.;\n            \n\n            col[c] = abs((uv.x)-(uv.y));\n            col1 = abs(.5-abs(col1-col));\n        }\n\t}\n    \n    fragColor =\n        vec4(vec3(col),1.0);\n        //vec4(vec3(col1),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft3Gzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [590, 590, 629, 629, 674], [676, 676, 733, 733, 2789]], "test": "untested"}
{"id": "Ntc3Rs", "name": "basic stairs 2d", "author": "jorge2017a2", "description": "basic stairs 2d", "tags": ["basicstairs2d"], "likes": 1, "viewed": 219, "published": 3, "date": "1636511910", "time_retrieved": "2024-07-30T18:49:16.002112", "image_code": "//jorge2017a2\n///referencia\n//https://iquilezles.org/articles/distfunctions2d\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.05),b,d)\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.015,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\nreturn colOut;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\nvec3 EscaleraV2(vec2 p, vec3 colOut, vec3 colIn)\n{\n    float d1;\n    float d=99999.0;\n    \n    int y;\n    p.y-=0.8;\n    p.x+=1.5;\n    \n    float AnchoTot=1.0;\n    float AltoTot=0.8;\n    float NumEs=8.0;\n    \n    float AnchoEs=AnchoTot/NumEs;\n    float AltoEs=AltoTot/NumEs;\n    \n    for(int i=1;i<=int(NumEs);i++ )\n     {   \n      float posx=float(i)*AnchoEs*2.0;\n      float posy=-float(i)*AltoEs*2.0;\n      d1=sdBox(p-vec2( posx,posy), vec2(AnchoEs,AltoEs) ) ;\n      d=min(d,d1);\n    \n     }   \n    \n    //colOut= DrawFig(colIn, colOut, d);\n    colOut=DrawFigBorde(colIn, colOut, d);\n     \n    return colOut;\n}\n\nvec3 EscaleraLargo(vec2 p, vec3 colOut, vec3 colIn)\n{\n    float d1;\n    float d=99999.0;\n    \n    int y;\n    p.y-=0.8;\n    p.x+=1.5;\n    \n    float AnchoTot=1.0;\n    float AltoTot=0.8;\n    float NumEs=4.0;\n    \n    float AnchoEs=AnchoTot/NumEs;\n    float AltoEs=AltoTot/NumEs;\n    float AltoEsNew;\n    \n    for(int i=1;i<=int(NumEs);i++ )\n     {   \n      float posx=float(i)*AnchoEs*2.0;\n      float posy=-float(i)*AltoEs*2.0;\n         \n      AltoEsNew=AltoTot-( float(i)- 1.0)*AltoEs ;\n      d1=sdBox(p-vec2( posx,posy-AltoEsNew), vec2(AnchoEs,AltoEs/NumEs+AltoEsNew) );\n            d=min(d,d1);\n     }   \n    \n    colOut= DrawFig(colIn, colOut, d);\n     \n    return colOut;\n}\n\n\n\n\nvec3 EscaleraTorre(vec2 p, vec3 colOut, vec3 colIn, int PNumEs)\n{\n    float d1;\n    float d=99999.0;\n    \n    int y;\n    p.y-=0.8;\n    p.x+=1.5;\n    \n    float AnchoTot=1.0;\n    float AltoTot=0.8;\n    float NumEs=float(PNumEs);\n    \n    float AnchoEs=AnchoTot/NumEs;\n    float AltoEs=AltoTot/NumEs;\n    float AltoEsNew;\n    \n    for(int i=1;i<=int(NumEs);i++ )\n     {   \n      float posx=float(i)*AnchoEs*2.0;\n      float posy=-float(i)*AltoEs*2.0;\n        \n      AltoEsNew=AltoTot-( float(i)- 1.0)*AltoEs ;\n       d1=sdBox(p-vec2( posx,posy/2.0-AltoEsNew), vec2(AnchoEs,AltoEs+AltoEsNew) );\n        d=min(d,d1);\n\n     }   \n    \n    //colOut=DrawFig(colIn, colOut, d);\n    colOut=DrawFigBorde(colIn, colOut, d);\n    \n    return colOut;\n}\n\n\nvec3 Suelo1(vec2 p, vec3 col)\n{\n    col=DrawFig(vec3(0.75,0.35,0.2), col, p.y-0.5 );\n return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv.y*=3.0;\n    \n    vec3  col=vec3(0.45,0.7,1.0)-uv.y*0.45;\n    uv.x=uv.x+iTime;\n    \n    float px=mod(uv.x, 14.0);\n    uv.x=px;\n    \n    \n    col= Suelo1(uv,col);\n    if( uv.x<3.0)\n    {\n        col= EscaleraLargo(uv-vec2(2.0,-0.8),col, vec3(0.0));\n        col= EscaleraTorre(vec2(uv.y, uv.x)-vec2(1.2,1.2), col, vec3(0.5,0.2,0.0),4);\n        col= EscaleraV2(vec2(uv.y, uv.x)-vec2(1.0,1.5), col, vec3(1.0,0.2,0.0));\n    }\n    else\n    {\n      \n      col= EscaleraTorre(vec2(uv.y, uv.x)-vec2(0.9,4.2), col, vec3(0.7,0.6,0.2),6);\n      col= EscaleraLargo(uv-vec2(5.,-0.9),col, vec3(0.7,0.5,0.6));\n    }\n    \n    \n    if( uv.x>5.0)\n    {\n        col= EscaleraLargo(vec2(-uv.x,uv.y)-vec2(-6.5,-0.8),col, vec3(0.0));\n        col= EscaleraTorre(vec2(uv.y, uv.x)-vec2(1.0,7.5), col, vec3(0.5,0.3,0.0),6);\n    }\n    \n     if( uv.x>7.5)\n    {\n        col= EscaleraLargo(vec2(-uv.x,uv.y)-vec2(-8.5,-0.8),col, vec3(0.0));\n        col= EscaleraLargo(vec2(-uv.x,uv.y)-vec2(-10.5,-0.8),col, vec3(0.0));\n        col= EscaleraTorre(vec2(uv.y, uv.x)-vec2(1.0,9.5), col, vec3(0.5,0.2,0.0),4);\n        col= EscaleraTorre(vec2(uv.y, uv.x)-vec2(1.5,11.5), col, vec3(0.5,0.2,0.5),7);\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntc3Rs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[239, 239, 273, 273, 368], [370, 401, 437, 437, 482], [487, 531, 578, 578, 605], [606, 606, 649, 649, 676], [677, 677, 725, 725, 753], [759, 759, 821, 821, 953], [955, 955, 1036, 1036, 1166], [1168, 1168, 1225, 1225, 1291], [1293, 1293, 1330, 1330, 1410], [1413, 1413, 1463, 1463, 2025], [3449, 3449, 3480, 3480, 3548], [3550, 3550, 3607, 3607, 4941]], "test": "untested"}
{"id": "flcGRs", "name": "Persian carpet 15", "author": "jarble", "description": "These patterns resemble Persian carpets.", "tags": ["fractal", "carpet", "rug"], "likes": 1, "viewed": 127, "published": 3, "date": "1636508304", "time_retrieved": "2024-07-30T18:49:16.771056", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5/2.;\n\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n                    uv += fract(uv.x/(4.))/4.; //a more interesting quilt pattern\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime)/10.0+uv.x);\n    vec3 random1 = (hash31(1.+t2)-vec3(.5))/4.;\n    vec3 random2 = (hash31(1.+t2)-vec3(.5))/4.;\n    vec3 random3 = (hash31(2.+t2)-vec3(.5))/4.;\n    vec3 random4 = (hash31(3.+t2)-vec3(.5))/4.;\n    \n    float offset = .5;\n    float scale2 = 1.16;\n    float bend = 1.;\n    vec3 col1 = col;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        //float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            //float bend = 1.+random3[k];\n            //float bend = abs(fract((uv.x)*2.)-.5)/2.+1.;\n            //float bend = scale2;\n            \n            //uv *= bend+col.x;\n            uv = triangle_wave(uv.yx-offset,scale)/bend+triangle_wave(uv,scale)*bend;\n            \n            for(int k = 0; k < 3; k++){\n                //uv *= bend+col.x;\n                uv.y /= scale2;\n                //uv.y /= scale2+col.x;\n                uv = triangle_wave((uv-random2[k%3])/(random4[k%3]+1.),scale+random3[k%3]).yx;\n                uv += fract(uv.x/(2.))/2.; //a more interesting quilt pattern\n\n                //uv *= bend+col.x;\n                uv.x /= -scale2;\n                scale /= 1.+(scale2+uv.x+uv.y)*col.x/5.;\n                scale2 -= (col.x-.5)/12.;\n                //bend *= -1.;\n                //nd -= 1./3.-col.x;\n                bend = 1.+uv.x/2.;\n\n            }\n            \n\n            col[c] = abs((uv.x)-(uv.y));\n            col1 = abs(col-col1.yzx);\n            //col[c] = abs((uv.x)-(uv.y)+col[c]);\n\n        }\n\t}\n    \n    fragColor =\n        vec4(vec3(col),1.0);\n        //vec4(vec3(col1),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flcGRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [590, 590, 629, 629, 674], [676, 676, 733, 733, 2763]], "test": "untested"}
{"id": "sltGRf", "name": "Tet-Oct-Tet RDode Dual relation", "author": "paniq", "description": "Visualizing the meshing neighborhood for a new dual contouring prototype.", "tags": ["tetrahedron", "cc", "octahedron", "fcc", "rhombic", "bcc"], "likes": 15, "viewed": 468, "published": 3, "date": "1636499053", "time_retrieved": "2024-07-30T18:49:17.804293", "image_code": "//////////////////////////////////////////////////////////\n\nvec3 offset = vec3(0.0);\n\nfloat shear = 1.0;\n\nvec2 rotate(vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,s,-s,c) * p;\n}\n\nconst mat3 fcc2cart = mat3(\n    0.0, 1.0, 1.0,\n    1.0, 0.0, 1.0,\n    1.0, 1.0, 0.0\n);\n\nconst mat3 cart2fcc = mat3(\n    -0.5,  0.5,  0.5,\n     0.5, -0.5,  0.5,\n     0.5,  0.5, -0.5\n);\n\nvec2 tf(vec3 p) {\n\n    //p = p*2.0 - 1.0;\n    \n    vec3 n = normalize(vec3(1,1,0));\n    float s = dot(p,n);\n    // the length under which (0 1 1) (1 0 1) (1 1 0) is orthogonal\n    //p -= shear*2.0*s*n;\n    // position swizzled to make the transformation clearer\n    //p = mix(p, fcc2cart * p.yzx, shear);\n    //p = fcc2cart * (fcc2cart * (fcc2cart * p));\n\n    p.xy = rotate(p.xy, radians(iTime*10.0));\n    p.yz = rotate(p.yz, radians(30.0));\n    \n    p.y += 8.0;\n\n    return vec2(p.x / p.y, p.z / p.y) * 5.0;\n}\n\nvec3 center(vec3 a, vec3 b, vec3 c, vec3 d) {\n    return (a + b + c + d) / 4.0;\n}\n\nvoid tet(vec3 O, float N) {\n    move_to(tf(vec3(0,0,0)*N + O));\n    line_to(tf(vec3(1,0,0)*N + O));\n    move_to(tf(vec3(0,0,0)*N + O));\n    line_to(tf(vec3(0,1,0)*N + O));\n    move_to(tf(vec3(0,0,0)*N + O));\n    line_to(tf(vec3(0,0,1)*N + O));    \n    move_to(tf(vec3(1,0,0)*N + O));\n    line_to(tf(vec3(0,1,0)*N + O));\n    line_to(tf(vec3(0,0,1)*N + O));\n    close_path();\n}\n\nvec3 tetcenter(vec3 O, float N) {\n    return vec3(0.25)*N + O;\n}\n\nvec3 octcenter(vec3 O) {\n    return vec3(0.5) + O;\n}\n\nvoid oct(vec3 O) {\n    move_to(tf(vec3(1,0,0) + O));\n    line_to(tf(vec3(1,0,1) + O));\n    line_to(tf(vec3(0,1,1) + O));\n    line_to(tf(vec3(0,1,0) + O));\n    close_path();\n    move_to(tf(vec3(0,1,0) + O));\n    line_to(tf(vec3(1,1,0) + O));\n    line_to(tf(vec3(1,0,1) + O));\n    line_to(tf(vec3(0,0,1) + O));\n    close_path();\n    move_to(tf(vec3(0,0,1) + O));\n    line_to(tf(vec3(0,1,1) + O));\n    line_to(tf(vec3(1,1,0) + O));\n    line_to(tf(vec3(1,0,0) + O));\n    close_path();\n}\n\nvoid draw_point(vec3 p) {\n    float A = AAINV*4.0;\n    circle(tf(p), A);\n    fill();\n}\n\nvoid draw_triangle(vec3 p1, vec3 p2) {\n    vec2 a = tf(vec3(0));\n    vec2 b = tf(p1);\n    vec2 c = tf(p2);\n    if (cross(vec3(b,0),vec3(c,0)).z < 0.0) {\n        vec2 t = b;\n        b = c;\n        c = t;\n    }\n    move_to(a);\n    line_to(b);\n    line_to(c);\n    close_path();\n    fill();\n}\n\n\nvoid draw_rdode(vec3 O, float S) {\n#define TF(P) \\\n    tf(P*S + O*0.5 - O*S)\n    for (int y = -1; y <= 1; y += 2) {\n        for (int x = -1; x <= 1; x += 2) {\n            move_to(TF(vec3(0,0,2)));\n            line_to(TF(vec3(x,y,1)));\n            move_to(TF(vec3(0,0,-2)));\n            line_to(TF(vec3(x,y,-1)));\n            \n            move_to(TF(vec3(2,0,0)));\n            line_to(TF(vec3(1,x,y)));\n            move_to(TF(vec3(-2,0,0)));\n            line_to(TF(vec3(-1,x,y)));\n            \n            move_to(TF(vec3(0,2,0)));\n            line_to(TF(vec3(y,1,x)));\n            move_to(TF(vec3(0,-2,0)));\n            line_to(TF(vec3(y,-1,x)));\n        }\n    }\n#undef TF\n}\n\n\nvoid paint() {\n    float t = iTime;\n\n    shear = 0.0;\n    //shear = clamp(sin(t*0.5)*2.0*0.5+0.5, 0.0, 1.0);\n\n    set_source_rgb(vec3(0.925, 0.941, 0.894));\n    clear();\n    \n    for (int z = -1; z <= 1; ++z) {\n    for (int y = -1; y <= 1; ++y) {\n    for (int x = -1; x <= 1; ++x) {\n    if (ivec3(x,y,z) != ivec3(0))\n        continue;\n    //if (z != 0)\n    //    continue;\n    offset = vec3(x,y,z);\n    \n    \n\n    float A = AAINV*4.0;\n\n    set_line_width_px(2.0);\n\n    const vec3 yz00 = vec3( 0,-1,-1);\n    const vec3 yz10 = vec3( 0, 1,-1);\n    const vec3 yz01 = vec3( 0,-1, 1);\n    const vec3 yz11 = vec3( 0, 1, 1);\n\n    const vec3 zx00 = vec3(-1, 0,-1);\n    const vec3 zx10 = vec3(-1, 0, 1);\n    const vec3 zx01 = vec3( 1, 0,-1);\n    const vec3 zx11 = vec3( 1, 0, 1);\n\n    const vec3 xy00 = vec3(-1,-1, 0);\n    const vec3 xy10 = vec3( 1,-1, 0);\n    const vec3 xy01 = vec3(-1, 1, 0);\n    const vec3 xy11 = vec3( 1, 1, 0);\n\n    set_source_rgba(vec4(1,0,0,0.5));\n    draw_triangle(xy00,zx00);\n    draw_triangle(zx00,xy01);\n    draw_triangle(xy01,zx10);\n    draw_triangle(zx10,xy00);\n    draw_triangle(xy11,zx11);\n    draw_triangle(zx11,xy10);\n    draw_triangle(xy10,zx01);\n    draw_triangle(zx01,xy11);\n\n    set_source_rgba(vec4(0,0.7,0,0.5));\n    draw_triangle(yz00,xy00);\n    draw_triangle(xy00,yz01);\n    draw_triangle(yz01,xy10);\n    draw_triangle(xy10,yz00);\n    draw_triangle(yz11,xy11);\n    draw_triangle(xy11,yz10);\n    draw_triangle(yz10,xy01);\n    draw_triangle(xy01,yz11);\n\n    set_source_rgba(vec4(0,0,1,0.5));\n    draw_triangle(zx00,yz00);\n    draw_triangle(yz00,zx01);\n    draw_triangle(zx01,yz10);\n    draw_triangle(yz10,zx00);\n    draw_triangle(zx11,yz11);\n    draw_triangle(yz11,zx10);\n    draw_triangle(zx10,yz01);\n    draw_triangle(yz01,zx11);\n\n    set_source_rgba(vec4(1,0.7,0,0.8));\n    move_to(tf(xy00));\n    line_to(tf(xy11));\n    move_to(tf(xy01));\n    line_to(tf(xy10));\n    stroke();\n    set_source_rgba(vec4(1,0,0.8,0.8));\n    move_to(tf(zx00));\n    line_to(tf(zx11));\n    move_to(tf(zx01));\n    line_to(tf(zx10));\n    stroke();\n    set_source_rgba(vec4(0,0.8,0.7,0.8));\n    move_to(tf(yz00));\n    line_to(tf(yz11));\n    move_to(tf(yz01));\n    line_to(tf(yz10));\n    stroke();\n    \n    set_source_rgba(vec4(0,0,0,0.8));\n    //draw_point(vec3(0));\n\n    set_source_rgba(vec4(0,0,0,0.8));\n    float S = 0.5;\n    draw_rdode(vec3(0), 0.5);\n    #if 0\n    float SDS = 0.25;\n    draw_rdode(vec3(0,0,2), SDS);\n    draw_rdode(vec3(0,0,-2), SDS);\n    draw_rdode(vec3(0,2,0), SDS);\n    draw_rdode(vec3(0,-2,0), SDS);\n    draw_rdode(vec3(2,0,0), SDS);\n    draw_rdode(vec3(-2,0,0), SDS);\n    #endif\n    stroke();\n    \n    set_source_rgba(vec4(0,0,0,1));\n    \n    for (int y = -1; y <= 1; y += 2) {\n        for (int x = -1; x <= 1; x += 2) {\n            for (int z = -1; z <= 1; z += 2) {\n            draw_point(vec3(x,y,z)*S);\n            }\n        }\n    }\n    set_source_rgba(vec4(1,1,1,1));\n    draw_point(vec3(-2,0,0)*S);\n    draw_point(vec3( 2,0,0)*S);\n    draw_point(vec3(0,-2,0)*S);\n    draw_point(vec3(0, 2,0)*S);\n    draw_point(vec3(0,0,-2)*S);\n    draw_point(vec3(0,0, 2)*S);\n\n    }}}\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init(fragCoord, iMouse.xy, iResolution.xy);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n// after Cairo API, with anti-aliasing\n// by Leonard Ritter (@paniq)\n// v0.11\n\n// I release this into the public domain.\n// some estimators have been lifted from other shaders and are not\n// necessarily PD licensed, note the links in the source code comments below.\n\n// 2019-06-06: 0.12\n// * split implementation and demo into common and image tab\n\n// 2017-10-05: 0.11\n// * anti-aliasing is gamma-correct\n\n// 2017-10-01: 0.10\n// * added experimental letter() function\n\n// 2017-09-30: 0.9\n// * save() is now a declarative macro\n\n// 2017-09-11: 0.8\n// * added ellipse()\n\n// 2017-09-10: 0.7\n// * paths painted with line_to/curve_to can be filled.\n\n// 2017-09-09: 0.6\n// * added rounded_rectangle()\n// * added set_source_linear_gradient()\n// * added set_source_radial_gradient()\n// * added set_source_blend_mode()\n// * added support for non-uniform scaling\n\n// undefine if you are running on glslsandbox.com\n// #define GLSLSANDBOX\n\n#ifdef GLSLSANDBOX\n#ifdef GL_ES\n#endif\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define iTime time\n#define iResolution resolution\n#define iMouse mouse\n#endif\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// draw a letter with the given texture coordinate\nvoid letter(sampler2D font_texture_source, ivec2 l);\nvoid letter(sampler2D font_texture_source, int lx, int ly);\n    \n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n#define save(name) Context name = _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord, vec2 mouse, vec2 resolution) {\n\taspect = vec2(resolution.x / resolution.y, 1.0);\n\tScreenH = min(resolution.x,resolution.y);\n\tAA = ScreenH*0.4;\n\tAAINV = 1.0 / AA;\n    \n    uv = fragCoord.xy / resolution;\n    vec2 m = mouse / resolution;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(sqrt(_color), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    //c.rgb *= c.rgb;\n    c *= c;\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid letter(sampler2D font_texture_source, ivec2 l) {\n  vec2 p = vec2(l);\n  vec3 tx;\n  vec2 ip;\n  float d;\n  int ic;\n  ip = vec2(l);\n  p += clamp(_stack.position.xy, 0.0, 1.0);\n  ic = 0x21 + int (mod (16. + ip.x + 2. * ip.y, 94.));\n  tx = texture (font_texture_source, mod ((vec2 (mod (float (ic), 16.),\n     15. - floor (float (ic) / 16.)) + fract (p)) * (1. / 16.), 1.)).gba - 0.5;\n  d = tx.b + 1. / 256.;\n  add_field(d / min_uniform_scale());\n}\n\nvoid letter(sampler2D font_texture_source, int lx, int ly) {\n    letter(font_texture_source, ivec2(lx,ly));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sltGRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 136, 136, 213], [400, 400, 417, 441, 910], [912, 912, 957, 957, 993], [995, 995, 1022, 1022, 1370], [1372, 1372, 1405, 1405, 1436], [1438, 1438, 1462, 1462, 1490], [1492, 1492, 1510, 1510, 1974], [1976, 1976, 2001, 2001, 2062], [2064, 2064, 2102, 2102, 2352], [3032, 3032, 3046, 3046, 6139], [6201, 6201, 6258, 6258, 6344]], "test": "untested"}
{"id": "stdGzf", "name": "depth of field focus study 4", "author": "morisil", "description": "Testing something out", "tags": ["chromaticaberration", "study", "depthoffield", "focus"], "likes": 3, "viewed": 387, "published": 3, "date": "1636495638", "time_retrieved": "2024-07-30T18:49:18.769712", "image_code": "// Fork of \"depth of field focus study 3\" by morisil. https://shadertoy.com/view/stdGRf\n// 2021-11-09 22:06:23\n\n// Fork of \"depth of field focus study 2\" by morisil. https://shadertoy.com/view/flc3zX\n// 2021-11-09 21:23:07\n\n// Fork of \"depth of field focus study\" by morisil. https://shadertoy.com/view/sld3zB\n// 2021-11-08 19:52:49\n\nconst float SHAPE_SIZE = .3;\nconst float CHROMATIC_ABBERATION = .02;\nconst float ITERATIONS = 20.;\nconst float INITIAL_LUMA = .5;\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n\nfloat getColorComponent(in vec2 st, in float modScale, in float blur) {\n    vec2 modSt = mod(st, 1. / modScale) * modScale * 2. - 1.;\n    float dist = length(modSt);\n    float angle = atan(modSt.x, modSt.y);\n    float shapeMap = smoothstep(SHAPE_SIZE + blur, SHAPE_SIZE - blur, dist);\n    return shapeMap;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st =\n        (2.* fragCoord - iResolution.xy)\n        / min(iResolution.x, iResolution.y);\n    st *= rotate2d(sin(iTime * .6) * .3);\n    st *= (sin(iTime * .3) + 2.) * .3;\n\n    st *= log(length(st * .18));\n    float modScale = 1.;\n\n    vec3 color = vec3(0);\n    float luma = INITIAL_LUMA;\n    float blur = .2;\n    for (float i = 0.; i < ITERATIONS; i++) {\n        vec2 center = st + vec2(sin(iTime * .5), cos(iTime * .3));\n        //center += pow(length(center), 1.);\n        vec3 shapeColor = vec3(\n            getColorComponent(center - st * CHROMATIC_ABBERATION, modScale, blur),\n            getColorComponent(center, modScale, blur),\n            getColorComponent(center + st * CHROMATIC_ABBERATION, modScale, blur)        \n        ) * luma;\n        st *= 1.1;\n        st *= rotate2d(sin(iTime  * .05) * .3);\n        color += shapeColor;\n        color = clamp(color, 0., 1.);\n        if (color == vec3(1)) break;\n        luma *= .8;\n        blur *= .63;\n    }\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdGzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[465, 465, 493, 493, 579], [582, 582, 653, 653, 889], [891, 891, 946, 946, 1955]], "test": "untested"}
{"id": "7ldGRf", "name": "Audio Analyzer Demo", "author": "DanielXMoore", "description": "Demonstration of how to get time domain and frequency domain data out of audio channel data.\n\nThe frequency spectrum values are at y=0.0 and the time domain values are at y=1.0.", "tags": ["tutorial", "audio", "demo"], "likes": 3, "viewed": 288, "published": 3, "date": "1636494120", "time_retrieved": "2024-07-30T18:49:19.585531", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float dy = 0.5 / iResolution.y;\n    float tv = texture(iChannel0, vec2(uv.x, 1.)).x;\n    float fv = texture(iChannel0, vec2(uv.x, 0.)).x;\n    vec3 col = vec3(0.);\n\n    // Time domain data\n    if (!(uv.y + dy < tv) && (uv.y - dy < tv)) {\n        // Color the pixel that crosses the time domain sample value\n        col += 1.;\n    }\n    \n    // Frequency domain data\n    if (uv.y < fv) {\n        col.gb += fv + 0.2;\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ldGRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 556]], "test": "untested"}
{"id": "stdGRf", "name": "depth of field focus study 3", "author": "morisil", "description": "Testing something out", "tags": ["chromaticaberration", "study", "depthoffield", "focus"], "likes": 6, "viewed": 317, "published": 3, "date": "1636493894", "time_retrieved": "2024-07-30T18:49:20.342507", "image_code": "// Fork of \"depth of field focus study 2\" by morisil. https://shadertoy.com/view/flc3zX\n// 2021-11-09 21:23:07\n\n// Fork of \"depth of field focus study\" by morisil. https://shadertoy.com/view/sld3zB\n// 2021-11-08 19:52:49\n\nconst float SHAPE_SIZE = .3;\nconst float CHROMATIC_ABBERATION = .02;\nconst float ITERATIONS = 20.;\nconst float INITIAL_LUMA = .5;\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n\nfloat getColorComponent(in vec2 st, in float modScale, in float blur) {\n    vec2 modSt = mod(st, 1. / modScale) * modScale * 2. - 1.;\n    float dist = length(modSt);\n    float angle = atan(modSt.x, modSt.y);\n    float shapeMap = smoothstep(SHAPE_SIZE + blur, SHAPE_SIZE - blur, dist);\n    return shapeMap;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st =\n        (2.* fragCoord - iResolution.xy)\n        / min(iResolution.x, iResolution.y);\n    st *= rotate2d(sin(iTime * .6) * .3);\n    st *= (sin(iTime * .3) + 2.) * .3;\n\n    float modScale = 1.;\n\n    vec3 color = vec3(0);\n    float luma = INITIAL_LUMA;\n    float blur = .2;\n    for (float i = 0.; i < ITERATIONS; i++) {\n        vec2 center = st + vec2(sin(iTime * .5), cos(iTime * .3));\n        //center += pow(length(center), 1.);\n        vec3 shapeColor = vec3(\n            getColorComponent(center - st * CHROMATIC_ABBERATION, modScale, blur),\n            getColorComponent(center, modScale, blur),\n            getColorComponent(center + st * CHROMATIC_ABBERATION, modScale, blur)        \n        ) * luma;\n        st *= 1.1;\n        st *= rotate2d(sin(iTime  * .05) * .3);\n        color += shapeColor;\n        color = clamp(color, 0., 1.);\n        if (color == vec3(1)) break;\n        luma *= .8;\n        blur *= .63;\n    }\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdGRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[353, 353, 381, 381, 467], [470, 470, 541, 541, 777], [779, 779, 834, 834, 1810]], "test": "untested"}
{"id": "7tdGRf", "name": "exotic smoke", "author": "lomateron", "description": "click to add mass\nthe convolution here is stronger at dampening the divergence field", "tags": ["fluid", "convolution"], "likes": 48, "viewed": 652, "published": 3, "date": "1636493778", "time_retrieved": "2024-07-30T18:49:21.214176", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = fragCoord/iResolution.xy;\n    vec4 a = texture(iChannel0,u);\n    fragColor = a.xxyz*.1+sin(pow(a.z,.2)*2.+vec4(1,2,3,4))*.5+.5;\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4  r = vec4(0);\n    vec4  a = A(u);\n    float z    = 8.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        if((i==0.&&j==0.)||length(vec2(i,j))>z+.1){continue;}\n        vec2  c = normalize(vec2(i,j));\n        vec4  a2= A(u+vec2(i,j));\n        vec4  b = a2-a;\n        r.xy += c*b.z;\n        r.z  += dot(c,b.xy           );//*a2.z;\n        r.w  += dot(c,b.yx*vec2(-1,1));//*a2.z;\n    }}\n    fragColor = r;\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4  r = A(u);\n    float z    = 8.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n      if((i==0.&&j==0.)||length(vec2(i,j))>z+1.){continue;}\n      vec4 b = B(u+vec2(i,j));\n      vec2 c = normalize(-vec2(i,j))*.000124;//*r.z;\n      r.xy += +b.z*c              *-1.\n              +b.w*c.yx*vec2(-1,1)*0.\n              +abs(b.z)*(step(0.,b.w)*2.-1.)*c.yx*vec2(-1,1)*0.;\n    }}\n\n    fragColor = r;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\n#define C(u) texture(iChannel2,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4 t = A(u);\n    vec2 m = +t.xy\n             +B(u).xy*(t.z-.5)*.3 //change the .3 to .6\n             +t.z*vec2(0,.0)\n             -C(u).x*t.xy*.0;\n    float s = 0.;\n    float z    = 6.;//kernel convolution size\n    float blur = 6./z;\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        if(length(vec2(i,j))>z+.1){continue;}\n        vec2 c = (m+vec2(i,j))*blur;\n        s += exp(-dot(c,c));\n    }}\n    if(s==0.){s = 1.;}\n    s = 1./s;\n    \n    fragColor = vec4(m,s,0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    float tz = 0.;\n    vec4 a = vec4(0);\n    float z    = 6.;//kernel convolution size\n    float blur = 6./z;\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        if(length(vec2(i,j))>z+.1){continue;}\n        vec4 t = A(u+vec2(i,j));\n        vec4 m = B(u+vec2(i,j));\n        vec2 c = (m.xy-vec2(i,j))*blur;\n        float z = t.z*exp(-dot(c,c));\n        a.xy += z*m.xy;\n        a.z  += z*m.z;\n        tz   += z;\n    }}\n    if(tz==0.){tz = 1.;}\n    a.xy /= tz;\n    //a = A(u);\n    if(iMouse.z>0.)\n    {\n        vec2 m = 32.*(u-iMouse.xy)/iResolution.y;\n        a += vec4(-1,0,1,1)*.1*exp(-dot(m,m));\n    }\n    if(iFrame==0)\n    {\n        vec2 m = 8.*(u-iResolution.xy*.5)/iResolution.y;\n        a = vec4(0,0,1,1)*exp(-dot(m,m));\n    }\n    fragColor = a;\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tdGRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 200]], "test": "untested"}
{"id": "flcGRf", "name": "Scattering fractal", "author": "hamtarodeluxe", "description": "Some iterative SDF fractal rendered with randomwalk subsurface scattering. You can play with SSS using DENSITY, EXTINCTION and ALBEDO defines :-)\nImproved version: https://www.shadertoy.com/view/fsXyWX", "tags": ["fractal", "subsurface", "randomwalk"], "likes": 25, "viewed": 592, "published": 3, "date": "1636479684", "time_retrieved": "2024-07-30T18:49:22.306256", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(pow(col,vec3(0.45)),1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define RWSTEPS 6\n#define AA 16\n#define FAR 5.\n#define MARCHBIAS 0.0005\n#define MAXSTEPS 50\n#define BIAS MARCHBIAS*2.\n\n#define DENSITY 230.\n#define EXTINCTION vec3(0.25, 0.7, 1.)\n#define ALBEDO vec3(.9, 1., .9)\n#define EMISSIVE vec3(.01, 0.02, 0.02)*0.1\n\nstruct Hit \n{\n\tfloat t; \n    bool hasHit;\n    vec3 position;\n};\n\nstruct Scene\n{\n\tvec3 spherePosition;\n    float sphereRadius;\n    vec3 lightPosition;\n    vec3 lightIntensity;\n \tvec3 sigmaS;\n    vec3 sigmaA;\n\tvec3 mouseRay;\n    vec3 planePosition;\n    vec3 planeNormal;\n    vec3 boxSize;\n    uvec2 random;\n    int bounces;\n    float time;\n};\n\n// Float generator\nfloat nextFloat(inout uvec2 random)\n{\n\trandom.x += 1u; \n    return clamp(hash21(random),0.0000,1.);\n}\n\n// SDF\n\n#define SDF \\\nfloat t = scene.time;\\\nvec3 a=0.1*vec3(5., t*0.5 +5.,t*0.9+10.);\\\nint k = 0;\\\nfor( k=0;k<km;k++){\\\n    p.xzy= abs(p.xyz);\\\n    p.xyz=p.xyz*vec3(2.,2.,2.)-vec3(0.6,0.6,0.6);\\\n    p.xy*=rot(a.z);\\\n    p.yz*=rot(a.x);\\\n    p.zx*=rot(a.y);\\\n}\\\nreturn (length(p)-1.0)/pow(2.,float(k));\\\n\nfloat sdf(vec3 p, Scene scene)\n{\n    int km = 7;\n    SDF\n}\n\nfloat sdfLow(vec3 p, Scene scene)\n{\n    int km = 3;\n    SDF\n}\n\nvec3 estimateNormal(vec3 pos, Scene scene)\n{\n \tvec3 normal = vec3(0.);\n    float d = 0.0001;\n    normal.x = sdf(pos + vec3(d,0.,0.), scene) - sdf(pos - vec3(d,0.,0.), scene);\n    normal.y = sdf(pos + vec3(0.,d,0.), scene) - sdf(pos - vec3(0.,d,0.), scene);\n    normal.z = sdf(pos + vec3(0.,0.,d), scene) - sdf(pos - vec3(0.,0.,d), scene);\n\treturn normalize(normal);\n}\n\nHit intersectSdf(vec3 ro, vec3 rd, Scene scene, float startSign)\n{\n    Hit hit;\n    hit.hasHit = false;\n\tfloat s = startSign;\n    vec3 p;\n    float t;\n    for(int i = 0; i < MAXSTEPS; i++)\n    {\n    \tp = ro + t*rd;\n     \tfloat d = sdf(p, scene);\n    \tif(s*d<MARCHBIAS && (iFrame != -1))\n        {\n        \thit.hasHit = true;\n            hit.t = t;\n            hit.position = p;\n           \n        \tbreak;\n        }\n        if(s*d>=FAR && (iFrame != -1)) break;\n        t+=s*d;\n    }\n    return hit;\n}\n\n// Monte carlo\n\nvec3 sampleSurfaceBSDF(vec3 normal, inout uvec2 random, out float pdf)\n{\n\tvec2 h = vec2(nextFloat(random), nextFloat(random));\n\t\n    vec2 d = vec2(sqrt(h.x),2.*PI*h.y);\n    d = vec2(d.x*sin(d.y),d.x*cos(d.y));\n    \n    vec3 ray = vec3(d.x,sqrt(max(0.,1.-d.x*d.x-d.y*d.y)),d.y);\n    float ct = dot(ray,vec3(0.,1.,0.));\n\n   \tvec3 up = normal;\n    vec3 right =  normalize(vec3(-up.y,0.1,up.x));\n    vec3 fw = normalize(cross(right, up));\n    right = normalize(cross(fw,up));\n    ray = mat3x3(right,up,fw)*ray;\n       \n   \tpdf = ct/PI;\n    return ray;\n}\n\nvec3 sampleMediumBSDF(inout uvec2 random)\n{\n    vec2 h = vec2(nextFloat(random),nextFloat(random));\n    float polar = acos(2.*h.x-1.);\n    float azimuth = 2.*PI*h.y;\n    vec3 ray = sphToCart(vec3(1.,polar,azimuth)); \n    return ray;\n}\n\nfloat sampleMediumScattering(inout uvec2 random, vec3 S)\n{\n    int ch = int(floor(3.*nextFloat(random)));  \n\tfloat t = -log(1.-nextFloat(random))/(S[ch]);\n        \n    return t;   \n}\n\nvec3 sampleMediumBSDF(inout uvec2 random, out float pdf)\n{            \n\tvec2 h = vec2(nextFloat(random), nextFloat(random));   \n    float polar = acos(h.x*2.-1.);  \n    float azimuth = 2.*PI*h.y;\n    vec3 ray = sphToCart(vec3(1., polar, azimuth));\t\n   \tpdf = 1./(4.*PI);\n    return ray;\n}\n\n//BSDF\nvec3 evaluateSurfaceBSDF(vec3 normal, vec3 wo, vec3 wi)\n{\n\treturn vec3(1.)/PI;\n}\n\n// Integrator\nvec3 traceSdf(vec3 ro, vec3 rd, inout Scene scene)\n{\n    int bounces = 0;\n    vec3 tp = vec3(1.);\n    vec3 col = vec3(0.);\n    bool inVolume = false;\n    vec3 pos = ro;\n    vec3 ray = rd;\n    vec3 sigmaT = scene.sigmaS + scene.sigmaA;\n    Hit hit;\n\n    hit = intersectSdf(pos, ray, scene, 1.0f);\n\n    if(!hit.hasHit) return col;\n            \n    vec3 normal = estimateNormal(hit.position, scene);\n    float pdf;\n    \n    // Update tp with surface interaction\n    vec3 wi = sampleSurfaceBSDF(-normal,scene.random,pdf);// uniform hemisphere\n    vec3 wo = -ray;\n    vec3 bsdf = evaluateSurfaceBSDF(-normal, wo,wi); // 1/PI\n    tp *= (bsdf/pdf)*saturate(dot(wi,-normal));\n    pos = hit.position-BIAS*normal;\n    ray = wi;\n    \n    bounces++;\n    \n    while (bounces < RWSTEPS)\n    {\n\n        // Sample scattering event\n        float t = sampleMediumScattering(scene.random, sigmaT);\n        inVolume = sdfLow(pos + ray*t, scene) < 0.00f;\n\n        if(inVolume)\n        {\n            // Update tp with scattering event\n            pos = pos + ray*t;\n            vec3 pdff = inVolume ? sigmaT*exp(-sigmaT*t) : exp(-sigmaT*t);\n            float pdf = (pdff.x+ pdff.y+ pdff.z)/3.; \n            vec3 tr = exp(-sigmaT*t);\n            tp *= inVolume ?(scene.sigmaS)*tr*(1./pdf) : tr*(1./pdf);\n            \n            // Sample medium BSDF\n            vec3 wi = sampleMediumBSDF(scene.random, pdf); \n            vec3 wo = -ray;\n            vec3 mediumBsdf = vec3(1./(4.*PI));\n            float mediumPdf = pdf;\n            tp *= mediumBsdf/mediumPdf;\n            ray = wi;               \n\n        }\n        else // Exiting volume\n        {\n            hit = intersectSdf(pos, ray, scene, -1.0f);\n\n            t = hit.t;\n            pos = pos + ray*t;\n            hit.position = pos;\n            \n            vec3 pdff = exp(-sigmaT*t);\n            float pdf = (pdff.x+ pdff.y+ pdff.z)/3.; \n            vec3 tr = exp(-sigmaT*t);\n            tp *= tr*(1./pdf);\n\n            vec3 normal = estimateNormal(hit.position, scene);\n            \n            // Do direct lighting\n            vec3 wo = -ray;\n            vec3 lp = sign(dot(pos,scene.lightPosition))*scene.lightPosition;\n            vec3 lightRay = lp-pos;\n            float l = length(lightRay);\n            vec3 wi = lightRay/l;\n            vec3 bsdf = evaluateSurfaceBSDF(normal, wo, wi);           \t\n            Hit occlusion = intersectSdf(pos+normal*BIAS,normalize(lightRay),scene, 1.0f);\n            vec3 lightIntensity = vec3(0.);\n            if(!occlusion.hasHit || occlusion.t>l)\n                lightIntensity = scene.lightIntensity/(l*l);\n    \n            col += tp*bsdf*lightIntensity*saturate(dot(normal,wi)) + tp * EMISSIVE;\n\n            break;\n        }\n\n        bounces++;\n                   \n    }\n\n    return col;\n}\n\nvec3 camera(vec2 pixel_coords, vec3 pos, vec3 lookAt)\n{\n\tvec2 pixelCoordsN = vec2(pixel_coords)/iResolution.xy;\n\tvec2 dc = (pixelCoordsN*2.-1.);\n\tdc.y *= float(iResolution.y)/float(iResolution.x);\n\tvec3 ro = pos;\n\tvec3 fw = normalize(lookAt-ro);\n\tvec3 rg = normalize(vec3(-fw.z,sin(0.05*iTime+PI*0.5),fw.x));\n\tvec3 up = normalize(cross(rg,fw));\n\tfloat fo = 3.;\n\tvec3 rd = normalize(fw * fo + up * dc.y + rg * dc.x);\n\treturn rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;   \n    \n    // Scene description\n    Scene scene;\n    scene.time = 40.+ 0.3*iTime;\n    vec3 albedo = ALBEDO;// + (vec3(1.0f)+ 0.1*sin(scene.time * vec3(0.5,1.,0.5)));\n    float density = DENSITY;// - sin(scene.time)*30.;\n    vec3 extinction = EXTINCTION;// * (vec3(1.0f)+ 0.1*sin(scene.time * vec3(2.,1.,0.5)));\n\tscene.sigmaS = albedo*extinction;\n    scene.sigmaA = extinction-scene.sigmaS;\n    scene.sigmaS *= density;\n    scene.sigmaA *= density;\n    scene.lightPosition = vec3(sin(scene.time * 0.5 -20.), 0.,cos(scene.time * 0.5 -20.));\n    scene.lightIntensity = 3.*vec3(1.,1.,1.);\n      \n    // Init. random\n    uint seed = uint(fragCoord.x + iResolution.x*fragCoord.y )+ uint(iFrame%1000)*uint(iResolution.x*iResolution.y);\n    scene.random =  uvec2(0,seed);   \n    \n    vec3 col = vec3(0.);   \n\n    vec3 camPos = vec3(cos(0.01*scene.time)*3.,sin(0.01*scene.time),sin(0.01*scene.time)*3.);\n    camPos = camPos * (0.85 - 0.15f * sin(scene.time+0.9));\n    for(int i = 0; i < AA && (iFrame != -1); i++)\n    {\n        vec2 offset = vec2(nextFloat(scene.random),nextFloat(scene.random))-0.5;  \n        vec3 rd = camera (fragCoord+offset, camPos, vec3(0.));\n        col += traceSdf(camPos, rd, scene);\n    }\n    \n    col /= float(AA);    \n    col = min(col.rgb, vec3(1.));\n    \n    vec3 pCol = texelFetch(iChannel0,ivec2(fragCoord),0).rgb;\n\n    fragColor = vec4(mix(col.rgb, pCol, 0.8f),0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159265359\n\n//random\nfloat hash( float n )\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\n//random\nfloat hash21( uvec2 x )\n{\n    uvec2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );\n    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );\n    float f = float(n) * (1.0/float(0xffffffffU));\n    return f;\n}\n\n//math\nfloat gauss(float x, float c)\n{\n\treturn exp(-pow(x,2.)/pow(2.*c,2.));\n\n}\n\nvec3 gamma(vec3 x, float gamma)\n{\n\treturn vec3(pow(x.x,gamma),pow(x.y,gamma),pow(x.z,gamma));\n}\n\nfloat saturate( float x) { return clamp(x,0.,1.);}\n\nvec3 saturate (vec3 x) { return vec3 (saturate(x.x),saturate(x.y),saturate(x.z));}\n            \nfloat smallestPositive(float x,float y)\n{\n\tif(x<0.&&y>=0.) return y;\n    if(y<0.&&x>=0.) return x;\n    else return min(x,y);\n}\n\nvec3 cartToSph(vec3 pos)\n{\n\tfloat r = length(pos);\n\treturn vec3(r,acos(pos.y/r),atan(pos.z,pos.x));//wikipedia physics convention\n}\n\nvec3 sphToCart(vec3 sc) //vec3 (radius, polar, azimuth)\n{\t\n\tfloat x = sc.x * sin(sc.y) * cos(sc.z);\n\tfloat z = sc.x * sin(sc.y) * sin(sc.z);\n\tfloat y = sc.x * cos(sc.y);\n\treturn vec3(x,y,z);\n}\n\nvec3 RGBToXYZ(vec3 rgb) {\n   \tvec3 xyz;\n    xyz[0] = 0.412453f * rgb[0] + 0.357580f * rgb[1] + 0.180423f * rgb[2];\n    xyz[1] = 0.212671f * rgb[0] + 0.715160f * rgb[1] + 0.072169f * rgb[2];\n    xyz[2] = 0.019334f * rgb[0] + 0.119193f * rgb[1] + 0.950227f * rgb[2];\n\n\treturn xyz;\n}\n\nmat2x2 rot(float angle)\n{\n  \n    return mat2x2(cos(angle), -sin(angle),\n\t\t\t\t  sin(angle), cos(angle));\n}\n\n\n   \n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flcGRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 297]], "test": "untested"}
{"id": "7lc3zj", "name": "raycast scene", "author": "rockhard", "description": "a basic raycast scene.ready for game. \nWASD or arrow keys to move around.", "tags": ["raycast"], "likes": 10, "viewed": 244, "published": 3, "date": "1636477901", "time_retrieved": "2024-07-30T18:49:23.158977", "image_code": "//https://www.shadertoy.com/view/stlSDB\nvoid raywall(vec2 ro,vec2 rd,inout float side,inout float endDist)\n{\n    float currentX,currentY; \n    float firstX,firstY;\n    \n    float dx,dy;\n    float stepX,stepY;\n   \n    firstX = floor(ro.x);\n    firstY = floor(ro.y);\n \n    dx = rd.x != 0.0 ? abs(1./rd.x) : abs(1./(rd.x + 0.00001));\n    dy = rd.y != 0.0 ? abs(1./rd.y) : abs(1./(rd.y + 0.00001));\n    \n    currentX = rd.x < 0.0 ? (ro.x - firstX)*dx : (firstX + 1. - ro.x)*dx;\n    currentY = rd.y < 0.0 ? (ro.y - firstY)*dy : (firstY + 1. - ro.y)*dy;    \n\n    stepX = rd.x > 0.0 ? 1. : -1.; \n    stepY = rd.y > 0.0 ? 1. : -1.;     \n\n    side = 0.0;\n    \n    for(int i = 1; i < 10; i++){\n        //the distane to closest x or closest y grid line.            \n        if(currentX < currentY){        \n            currentX += dx;\n            firstX += stepX;\n            side = 0.;\n        }\n        else {\n            currentY += dy;\n            firstY += stepY;\n            side = 1.;\n        }\n       \n        if(map2(int(firstX),int(firstY))>0){\n           break;\n        }\n    }\n   //Perpendicular Distnace\n   if(side == 1.0)       \n       endDist = abs((firstY - ro.y + (1. - stepY)/2.)/rd.y);\n   else \n       endDist = abs((firstX - ro.x + (1. - stepX)/2.)/rd.x);\n}\n \n//conditional noticeable math erro,not perfect...\nvoid lightfog(vec3 ori,vec3 dir,float ed,vec3 p, vec3 nor,\n              vec3 lp,vec3 lc,inout vec3 col){\n    vec3 l2o=ori-lp;\n    float c=dot(l2o,l2o);\n    float b=dot(l2o,dir);\n    //if(c<0.0) return;   \n    float h = sqrt(c-b*b);\n    float len=sqrt(c);\n    float t =clamp(ed-len,-1.0,1.0);  \n    //https://www.shadertoy.com/view/slXXD4\n    if(t>0.0) col+= clamp(1.57-atan(b / h),0.0,1.0)/ h*.03*t*lc;      \n    \n    vec3 d2l=lp-p;\n    len =length(d2l); \n    if(len<1.0){ d2l /=len;\n       col+=max(0.0,dot(d2l,nor))*(1.0- sqrt(len))*lc;\n    }  \n}\n\nvoid drawEnemy(inout vec3 col,vec3 ro,vec3 rd,float d,enemy e,float fog){\n    vec2 suv;\n    float d2ene0 = raySprite(ro,rd,e.p,vec2(0.27,0.3)+sin(iTime*10.0)*0.01,suv);\n    if(d2ene0>0.0&&d2ene0<d)\n    { \n       col+=ghost(vec2(suv.x,suv.y),iTime)*(1.0-suv.x)*fog; \n    }\n}\n\nvoid drawBullet(inout vec3 col,vec3 ro,vec3 rd,float d){\n    \n    vec4 bltpos = texture(iChannel3,vec2(0.5/iResolution.x, 1.0)); \n    vec3 p=vec3(bltpos.x,0.5,bltpos.z);\n    vec2 suv;\n    float d2ene0 = raySprite(ro,rd,p,vec2(0.2,0.2),suv);\n    if(d2ene0>0.0&&d2ene0<d)\n    { \n       col+=length(suv);\n    }\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = fragCoord/iResolution.xy-0.5;\n    float asp=iResolution.x/iResolution.y;\n    uv.x*=asp;\n      \n    //these 2 texture is bufferA for user control and collision\n    vec4 inputdir = texture(iChannel3,vec2(2.5/iResolution.x, 0));\n    if(inputdir.x+inputdir.y==0.0)\n    {\n      inputdir.x= cos(0.0);inputdir.y=sin(0.0);\n    }\n    vec4 inputpos = texture(iChannel3,vec2(3.5/iResolution.x, 0)); \n    //player position xz\n    vec2 ro = inipos+inputpos.xy;\n    //player direction xz and rotate 90degs to project to screen \n    vec3 d=vec3(inputdir.x-inputdir.y*uv.x,uv.y,inputdir.y+inputdir.x*uv.x);\n    //normalize ray direction will cause fish eye \n    //and got some drunk feeling. maybe good for now :>\n    d=normalize(d);\n    vec2 rd =d.xz;\n    \n    //raycast test\n    float side,endDist;    \n    raywall(ro,rd,side,endDist);  \n \n    //endDist 1 = full height\n    float height = endDist>0.0?1.0/(endDist*asp):0.0;        \n  \n    float h= step(height,abs(uv.y));\n    vec2 tuv;//tiled uv space\n    \n    int matid = 0;\n   \n    //render colors& position 3d\n    vec3 col=vec3(0.0),p=vec3(0.0),n=vec3(0.0);\n    \n    if(h<1.0){  //wall or wall\n       tuv.y=uv.y*0.5/height;\n       p=vec3(ro.x+ endDist*rd.x,tuv.y,ro.y + endDist*rd.y);\n       float wallP = side == 1.0?p.x : p.z;\n       tuv.x=fract(wallP);      \n       \n       col = texture(iChannel0,tuv).xyz;\n       n = normalize(cross(dFdx(p), dFdy(p)));\n    }\n    else {//ceil or floor\n      float ty=uv.y*asp;\n      endDist = sign(ty)/(ty); \n      p=vec3(ro.x+ endDist*rd.x,0.0,ro.y + endDist*rd.y);\n      \n      tuv = fract(p.xz); \n     \n      vec3 roof=texture(iChannel1,tuv).xyz;\n      vec3 ground=texture(iChannel2,tuv).xyz;\n      /********\n      do some treatment such as blood,hole or painting on the wall\n      ********/\n      \n      if(uv.y>0.0){        \n        col=roof; n.y=-1.0; p.y=1.0; matid=1;\n      }\n      else{         \n        col=ground; n.y=1.0; matid=2;\n      }       \n    }  \n     float fog=1.0/(1.0+endDist*endDist);\n    //kind of fog\n    col*=vec3(clamp(p*0.3*fog,0.0,1.0));       \n    \n    vec3 ori=vec3(ro.x,0.5,ro.y);   \n    //  fish eye \n    vec3 dir=normalize(vec3(rd.x,uv.y,rd.y));\n    //reconstruct fish eye world position\n    p = ori+dir*endDist;\n    \n    drawEnemy(col,ori,dir,endDist,ene0,fog);\n      drawEnemy(col,ori,dir,endDist,ene1,fog);\n       drawEnemy(col,ori,dir,endDist,ene2,fog);       \n  \n    //lights\n    float flash= hash1(iTime)<0.98?1.0:0.3;\n    \n    lightfog(ori,dir,endDist,p,n,vec3(5.5,0.995,5.5),vec3(1.0,0.3,0.1)*flash,col);\n    lightfog(ori,dir,endDist,p,n,vec3(1.5,0.995,8.0),vec3(0.0,0.1,0.5)*flash,col);\n    lightfog(ori,dir,endDist,p,n,vec3(8.0,0.995,1.5),vec3(0.3,0.1,0.0)*flash,col);\n    \n    drawBullet(col,ori,dir,endDist);\n       \n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define turnSpeed 3.5 \n#define moveSpeed 1.5\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT   = 37;\nconst int KEY_UP     = 38;\nconst int KEY_RIGHT  = 39;\nconst int KEY_DOWN   = 40;\n\nfloat KeyPressed(int key) \n{\n  return texture(iChannel1, vec2(key,0.25) / 256.0).x;\n}\n//https://www.shadertoy.com/view/XtfyWs\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{   \n    col = vec4(0.0);\n   \n    vec2 uv = uv0 - 0.5; \n    //the first 4 pixels for mousedelta and keyborad record\n    if(uv.x<5.0&&uv.y<2.0){ \n    \n    vec4 iMouseLast     = texture(iChannel0, vec2(0.0));\n    vec4 iMouseAccuLast = texture(iChannel0, vec2(1.5/iResolution.x,0.0));\n\n    vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n    \n    bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n    vec2 mouseDelta2 = cond0? mouseDelta.xy : vec2(0.0);\n    \n    vec2 iMouseAccu1 = iMouseAccuLast.xy + mouseDelta2;\n    \n    vec4 dirLast = texture(iChannel0,vec2(2.5/iResolution.x,0.0));\n    vec4 posLast = texture(iChannel0, vec2(3.5/iResolution.x,0.0));\n    \n    if(uv.x == 0.0) col = iMouse;  \n    if(uv.x == 1.0) col = vec4(iMouseAccu1,mouseDelta2);\n    if(uv.x == 2.0){ \n         float ax=turnSpeed*iMouseAccuLast.x/iResolution.x;\n         float ay=turnSpeed*iMouseAccuLast.y/iResolution.y;\n         col = vec4(cos(ax),sin(ax),cos(ay),sin(ay));    \n      } \n    if(uv.x == 3.0){ \n       \n         //W S key\n         float updown = (KeyPressed(87)-KeyPressed(83))*0.007;\n         //UP down key\n         updown += (KeyPressed(38)-KeyPressed(40))*0.007;\n         //A D key\n         float leftright= (KeyPressed(65)-KeyPressed(68))*0.007;\n         //left right key\n         leftright += (KeyPressed(37)-KeyPressed(39))*0.007;\n                \n         float ddx=(dirLast.x*updown)*moveSpeed+(dirLast.y*leftright)*moveSpeed;\n         float ddy=(dirLast.y*updown)*moveSpeed-(dirLast.x*leftright)*moveSpeed;\n       \n         posLast.x+=ddx;\n         posLast.y+=ddy;         \n      \n         if(map2(int(posLast.x+inipos.x),int(posLast.y+inipos.y))>0)\n          { posLast.x-=ddx; posLast.z=ddx; }\n         if(map2(int(posLast.x+inipos.x),int(posLast.y+inipos.y))>0)\n          { posLast.y-=ddy; posLast.w=ddy; }   \n         \n         //spring style collision              \n         posLast.xy-=posLast.zw; \n         posLast.zw*=0.95;  \n         \n         col = posLast;    \n      } \n      /*********\n      fire bullet\n      ********/\n      if(uv.y==1.0){         \n         vec4 bltpos = texture(iChannel0, vec2(0.5/iResolution.x,1.0));\n         vec4 bltstate = texture(iChannel0, vec2(1.5/iResolution.x,1.0));\n         float life=bltstate.x;\n        if(uv.x==0.0){\n           bltpos.xy+=bltpos.zw;\n           if(KeyPressed(32)>0.0){ \n              bltpos.xy= posLast.xy; \n              bltpos.zw= dirLast.xy; \n           }\n         }\n          col = bltpos;   \n      }      \n    }\n    else discard;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 inipos=vec2(3.5,5.01);\n\n//The map is from MonkeyIsBack: https://www.shadertoy.com/view/4dG3RD\nint map2(int x,int y){\n   //why not working? Does the map must be 0-1?\n   //if(x<=-5||x>=11||y<=-5||y>=11)return true;\n   \n    if (y >= 0 && y <= 9) {   \n        if (x == 0 || x == 9) return 1;\n    }\n    if (x >= 0 && x <= 9) {\n        if (y == 0 || y == 9) return 1;\n    }\n\n    if (x == 2 && y == 2) return 1;\n    if (x == 2 && y == 4) return 1;\n    if (x == 2 && y == 6) return 1;\n    if (x == 2 && y == 7) return 1;\n    \n    if (x == 4 && y == 2) return 1;\n    if (x == 4 && y == 4) return 1;\n    if (x == 4 && y == 6) return 1;\n    if (x == 4 && y == 7) return 1;\n    \n    if (x == 6 && y == 2) return 1;\n    if (x == 6 && y == 4) return 1;\n    if (x == 6 && y == 6) return 1;\n    if (x == 6 && y == 7) return 1;\n\n\treturn 0;\n}\n \nfloat hash1(float p){ return fract(sin(p)*43758.5); }\n\n#define Epsilon 1e-4\nvec4 pointNormal(vec3 p,vec3 n){ return vec4(n,-dot(p,n)); }\nfloat pointPlane(vec3 p,vec4 pl){ return dot(p,pl.xyz)+pl.w; }\nfloat rayPlane(vec3 ro,vec3 rd,vec4 pl){\n   float d = dot(pl.xyz,rd);\n   if(abs(d)<Epsilon) return 0.0;\n   return -(dot(ro,pl.xyz)+pl.w)/d;\n}\n//view aligned square with size of \"s\" \nfloat raySprite(vec3 ro,vec3 rd,vec3 p,vec2 s,inout vec2 uv){\n   vec4 plane=pointNormal(p,normalize(ro-p));\n   float d=rayPlane(ro,rd,plane);\n   vec3 ddp=ro+rd*d-p;\n   if(ddp.y>s.y||ddp.y<-s.y)return 0.0;\n   float dx=length(ddp.xz);\n   if(dx>s.x)return 0.0;   \n   uv.x=0.5*dx/s.x;\n   uv.y=ddp.y/s.y*0.5; return d;   \n}\n//https://shadertoy.com/view/tljGDh\nfloat ghost(vec2 p,float time){\n    float rx = abs(p.x);  \n    float rx2 = rx*rx;   \n    float rx4 = pow(rx,4.0);\n    float pds = p.y+0.55; \n    \n    float logo = abs(pds*pds)*2.0 + rx*4.0 - 1.5; //sides  \n    logo = max(logo, rx*rx- p.y*2.2 - 0.5); // bottommost\n         \n    float sinVal = (.35-(abs(sin(fract(time)*3.14))*.5-.25)+ .5 ); // lol sine    \n    logo = max(logo, (.5-abs(p.y*6.7 + 1.8 - 7.*rx2))*sinVal- rx4*16. + 0.21); // mouth\n    logo = max(logo, (.5 - abs(p.y*7. - 1.85 + 6.5*rx2))*0.5 - rx4*17.5 + 0.21); // brow\n    \n    float upEyes = sinVal*-.025; // nudge eyes up\n       \n    logo =min(1.0-logo,(2.0+sinVal)*length(vec2(abs(p.x*1.12)-0.16, p.y+.05+upEyes))+.25); //eyes\n    return smoothstep(0.4, 0.5, logo);\n}\n\nstruct enemy{ vec3 p; };\n\nenemy ene0=enemy(vec3(5.5,0.35,5.5));\nenemy ene1=enemy(vec3(1.5,0.35,8.0));\nenemy ene2=enemy(vec3(8.0,0.35,1.5));\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lc3zj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 40, 108, 108, 1266], [1269, 1319, 1424, 1424, 1868], [1870, 1870, 1943, 1943, 2143], [2145, 2145, 2201, 2201, 2454], [2457, 2457, 2513, 2513, 5308]], "test": "untested"}
{"id": "ftd3zX", "name": "- liquid -", "author": "anahit_movsesyan", "description": ":octopus:", "tags": ["fractal", "noise", "fbm", "water", "smoke", "metal", "liquid"], "likes": 24, "viewed": 989, "published": 3, "date": "1636466131", "time_retrieved": "2024-07-30T18:49:24.034636", "image_code": "float rand(vec2 p) {\n    return fract(sin(dot(p, vec2(12.99, 78.233))) * 43758.545);\n}\n\nfloat noise(vec2 p) {\n    vec2 f = fract(p);\n    f = f * f * f * f * (3. - 2. * f) * (3. - 2. * f);\n    vec2 i = floor(p);\n    return mix(mix(rand(i + vec2(0, 0)), \n                   rand(i + vec2(1, 0)), f.x),\n               mix(rand(i + vec2(0, 1)), \n                   rand(i + vec2(1, 1)), f.x), f.y);\n}\n\nfloat fbm(vec2 p) {\n    float v = 0.;\n    float a = 1.;\n    for(int i = 0; i < 4; ++i) {\n        p = 1.5 * p + 15.;\n        a *= 0.5;\n        v += a * noise(p);\n    }\n    return v;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = 2. * fragCoord.xy / iResolution.y;\n    \n    vec2 r1 = vec2(fbm(p + 0.02 * iTime), fbm(p + 0.005 * iTime));\n    vec2 r2 = vec2(fbm(p + 0.15 * iTime + 10. * r1), fbm(p + 0.12 * iTime + 12. * r1));\n\n    fragColor = vec4(1.8 * pow(fbm(p + r2), 2.) + 0.03);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftd3zX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 86], [88, 88, 109, 109, 396], [398, 398, 417, 417, 580], [582, 582, 637, 637, 905]], "test": "untested"}
{"id": "fld3RX", "name": "入门之路-14", "author": "jialouluo", "description": "画一个♥（璨） 实现图片切换", "tags": [], "likes": 1, "viewed": 192, "published": 3, "date": "1636458040", "time_retrieved": "2024-07-30T18:49:25.074854", "image_code": "float size =2.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=0.5;//首先改变中心\n    uv*=size;//缩放坐标\n    //制作爱心需要用到两个函数,第一个是 (x^2 + y^2 -c )^3 第二个是 x^2*y^3;这个c可以控制心的大小\n    vec3 col = vec3(step(pow(pow(uv.x,2.) + pow(uv.y,2.)-4.*fract(iTime*0.5),3.),pow(uv.x,2.)*pow(uv.y,3.)));\n    vec4 texture1 = texture(iChannel0,uv/size +0.5);\n    vec4 texture2 = texture(iChannel1,uv/size +0.5);\n    vec4 color = mix(texture1,texture2,col.x);\n    fragColor =color;\n}\n//这次这个比较简单，为后面一些♥的案例打下基础", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fld3RX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 74, 74, 589]], "test": "untested"}
{"id": "NtdGRX", "name": "Domino 2", "author": "nihohit", "description": "Based on \"domino piece \" by bmax.", "tags": ["proceduralgeneration", "domino"], "likes": 3, "viewed": 188, "published": 3, "date": "1636451495", "time_retrieved": "2024-07-30T18:49:25.890673", "image_code": "#define BLUR_RADIUS 0.015\n\nfloat sdCircle(vec2 p, vec2 c, float r) {\n    return length(p - c) - r;\n}\n\nfloat sdLine(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba*h);\n}\n\nfloat sdRoundedLine(vec2 p, vec2 a, vec2 b, float r) {\n    return sdLine(p, a, b) - r;\n}\n\nfloat sdBox(vec2 p, vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y),0.0);\n}\n\nfloat sdRoundedBox(vec2 p, vec2 b, float r) {\n    return sdBox(p, b) - r;\n}\n\nvec4 shapeColor(vec3 fillColor, float dist, float gradience) {\n    float smoothDist = smoothstep(0.00, BLUR_RADIUS, dist);\n    float opacity = 1.0 - smoothDist;\n    return vec4(fillColor * opacity + abs(dist * gradience), opacity);\n}\n\nvec4 combine(vec4 color1, vec4 color2) {\n    return min(color1, color2);\n}\n\nmat2 scale(vec2 scale) {\n    return mat2(scale.x, 0.0, 0.0, scale.y);\n}\n\nvec3 white = vec3(0.8, 0.8, 0.8);\nvec3 black = vec3(0.0, 0.0, 0.0);\nvec3 green = vec3(0.0, 0.4, 0.0);\nvec3 red = vec3(0.5, 0.0, 0.0);\nfloat dotRadius = 0.06;\nint numberOfValues = 7;\n\nvec4 draw1Dot(vec3 color, vec2 center, vec4 background) {\n    vec4 dot = shapeColor(color, sdCircle(center, vec2(0.0, -0.0), dotRadius), 5.0);\n    return mix(background, dot, dot.a);\n}\n\nvec4 draw2Dots(vec3 color, vec2 center, vec4 background) {\n    vec4 dot = shapeColor(color, sdCircle(center, vec2(0.18, 0.18), dotRadius), 5.0);\n    vec4 blendedDots = mix(background, dot, dot.a);\n    dot = shapeColor(color, sdCircle(center, vec2(-0.18, -0.18), dotRadius), 5.0);\n    blendedDots = combine(blendedDots, mix(background, dot, dot.a));\n    return blendedDots;\n}\n\n\nvec4 draw3Dots(vec3 color, vec2 center, vec4 background) {\n    vec4 dot = shapeColor(color, sdCircle(center, vec2(0.0, 0.0), dotRadius), 5.0);\n    vec4 blendedDots = mix(background, dot, dot.a);\n    dot = shapeColor(color, sdCircle(center, vec2(0.18, 0.18), dotRadius), 5.0);\n    blendedDots = combine(blendedDots, mix(background, dot, dot.a));\n    dot = shapeColor(color, sdCircle(center, vec2(-0.18, -0.18), dotRadius), 5.0);\n    blendedDots = combine(blendedDots, mix(background, dot, dot.a));\n    return blendedDots;\n}\n\nvec4 draw4Dots(vec3 color, vec2 center, vec4 background) {\n    vec4 dot = shapeColor(color, sdCircle(center, vec2(0.18, 0.18), dotRadius), 5.0);\n    vec4 blendedDots = mix(background, dot, dot.a);\n    dot = shapeColor(color, sdCircle(center, vec2(-0.18, -0.18), dotRadius), 5.0);\n    blendedDots = combine(blendedDots, mix(background, dot, dot.a));\n    dot = shapeColor(color, sdCircle(center, vec2(-0.18, 0.18), dotRadius), 5.0);\n    blendedDots = combine(blendedDots, mix(background, dot, dot.a));\n    dot = shapeColor(color, sdCircle(center, vec2(0.18, -0.18), dotRadius), 5.0);\n    blendedDots = combine(blendedDots, mix(background, dot, dot.a));\n    return blendedDots;\n}\n\nvec4 draw5Dots(vec3 color, vec2 center, vec4 background) {\n    vec4 dot = shapeColor(color, sdCircle(center, vec2(0.0, 0.0), dotRadius), 5.0);\n    vec4 blendedDots = mix(background, dot, dot.a);\n    dot = shapeColor(color, sdCircle(center, vec2(0.18, 0.18), dotRadius), 5.0);\n    blendedDots = combine(blendedDots, mix(background, dot, dot.a));\n    dot = shapeColor(color, sdCircle(center, vec2(-0.18, -0.18), dotRadius), 5.0);\n    blendedDots = combine(blendedDots, mix(background, dot, dot.a));\n    dot = shapeColor(color, sdCircle(center, vec2(-0.18, 0.18), dotRadius), 5.0);\n    blendedDots = combine(blendedDots, mix(background, dot, dot.a));\n    dot = shapeColor(color, sdCircle(center, vec2(0.18, -0.18), dotRadius), 5.0);\n    blendedDots = combine(blendedDots, mix(background, dot, dot.a));\n    return blendedDots;\n}\n\nvec4 draw6Dots(vec3 color, vec2 center, vec4 background) {\n    vec4 dot = shapeColor(color, sdCircle(center, vec2(0.18, 0.0), dotRadius), 5.0);\n    vec4 blendedDots = mix(background, dot, dot.a);\n    dot = shapeColor(color, sdCircle(center, vec2(0.18, 0.18), dotRadius), 5.0);\n    blendedDots = combine(blendedDots, mix(background, dot, dot.a));\n    dot = shapeColor(color, sdCircle(center, vec2(0.18, -0.18), dotRadius), 5.0);\n    blendedDots = combine(blendedDots, mix(background, dot, dot.a));\n    dot = shapeColor(color, sdCircle(center, vec2(-0.18, 0.0), dotRadius), 5.0);\n    blendedDots = combine(blendedDots, mix(background, dot, dot.a));\n    dot = shapeColor(color, sdCircle(center, vec2(-0.18, 0.18), dotRadius), 5.0);\n    blendedDots = combine(blendedDots, mix(background, dot, dot.a));\n    dot = shapeColor(color, sdCircle(center, vec2(-0.18, -0.18), dotRadius), 5.0);\n    blendedDots = combine(blendedDots, mix(background, dot, dot.a));\n    return blendedDots;\n}\n\nvec4 drawBlackCircle(vec2 center, float radius, float thickness) {\n    vec4 circle = vec4(1.0-step(sdCircle(center, vec2(0.0, -0.0), radius),  radius));\n    circle += vec4(step(sdCircle(center, vec2(0.0, -0.0), radius - thickness), radius - thickness));\n    circle.a = 1.0-step(sdCircle(center, vec2(0.0, -0.0), radius), radius);\n    return circle;\n}\n\nvec4 drawSagie(vec2 center) {\n    vec4 hair = drawBlackCircle(center - vec2(0.07, 0.19), 0.01, 0.008);\n    hair *= drawBlackCircle(center - vec2(-0.07, 0.19), 0.01, 0.008);\n    hair *= drawBlackCircle(center - vec2(0.055, 0.195), 0.01, 0.008);\n    hair *= drawBlackCircle(center - vec2(-0.055, 0.195), 0.01, 0.008);\n    hair *= drawBlackCircle(center - vec2(0.04, 0.2), 0.01, 0.008);\n    hair *= drawBlackCircle(center - vec2(-0.04, 0.2), 0.01, 0.008);\n    hair *= drawBlackCircle(center - vec2(0.015, 0.205), 0.01, 0.008);\n    hair *= drawBlackCircle(center - vec2(-0.015, 0.205), 0.01, 0.008);\n    hair *= drawBlackCircle(center - vec2(0.085, 0.175), 0.01, 0.008);\n    hair *= drawBlackCircle(center - vec2(-0.085, 0.175), 0.01, 0.008);\n    hair *= drawBlackCircle(center - vec2(0.1, 0.165), 0.01, 0.008);\n    hair *= drawBlackCircle(center - vec2(-0.1, 0.165), 0.01, 0.008);\n    hair *= drawBlackCircle(center - vec2(0.115, 0.15), 0.01, 0.008);\n    hair *= drawBlackCircle(center - vec2(-0.115, 0.15), 0.01, 0.008);\n    hair *= drawBlackCircle(center - vec2(0.13, 0.141), 0.01, 0.008);\n    hair *= drawBlackCircle(center - vec2(-0.13, 0.141), 0.01, 0.008);\n    hair *= drawBlackCircle(center - vec2(-0.00, 0.21), 0.01, 0.008);\n    \n    vec4 beard = drawBlackCircle(center - vec2(-0.0, -0.19), 0.01, 0.02);\n    beard *= drawBlackCircle(center - vec2(-0.07, -0.19), 0.01, 0.02);\n    beard *= drawBlackCircle(center - vec2(0.055, -0.195), 0.01, 0.02);\n    beard *= drawBlackCircle(center - vec2(-0.055, -0.195), 0.01, 0.02);\n    beard *= drawBlackCircle(center - vec2(0.04, -0.2), 0.01, 0.02);\n    beard *= drawBlackCircle(center - vec2(-0.04, -0.2), 0.01, 0.02);\n    beard *= drawBlackCircle(center - vec2(0.015, -0.205), 0.01, 0.02);\n    beard *= drawBlackCircle(center - vec2(-0.015, -0.205), 0.01, 0.02);\n    beard *= drawBlackCircle(center - vec2(0.085, -0.175), 0.01, 0.02);\n    beard *= drawBlackCircle(center - vec2(-0.085, -0.175),0.01, 0.02);\n    beard *= drawBlackCircle(center - vec2(0.1, -0.165), 0.01, 0.02);\n    beard *= drawBlackCircle(center - vec2(-0.1, -0.165), 0.01, 0.02);\n    beard *= drawBlackCircle(center - vec2(0.115,- 0.15), 0.01, 0.02);\n    beard *= drawBlackCircle(center - vec2(-0.115, -0.15), 0.01, 0.02);\n    hair *= drawBlackCircle(center - vec2(0.13, -0.141), 0.01, 0.02);\n    beard *= drawBlackCircle(center - vec2(-0.13, -0.141), 0.01, 0.02);\n    \n    vec4 face = drawBlackCircle(center, 0.1, 0.01);\n    vec4 leftEye = drawBlackCircle(center - vec2(0.07, 0.06), 0.01, 0.003);\n    leftEye *= drawBlackCircle(center - vec2(0.07, 0.06), 0.005, 0.1);\n    face = mix(face, leftEye, 1.0-leftEye.a);\n    vec4 rightEye = drawBlackCircle(center- vec2(-0.07, 0.06), 0.01, 0.003);\n    rightEye *= drawBlackCircle(center - vec2(-0.07, 0.06), 0.005, 0.1);\n    face = mix(face, rightEye, 1.0-rightEye.a);\n    return mix(hair,face, 1.0-face.a) * beard;\n}\n\nvec4 drawDots(vec3 color, int number, vec2 center, vec4 background) {\n    vec4 aggregate = vec4(0);   \n    aggregate += draw1Dot(color, center, background) * float(number == 1);\n    aggregate += draw2Dots(color, center, background) * float(number == 2);\n    aggregate += draw3Dots(color, center, background) * float(number == 3);\n    aggregate += draw4Dots(color, center, background) * float(number == 4);\n    aggregate += draw5Dots(color, center, background) * float(number == 5);\n    aggregate += draw6Dots(color, center, background) * float(number == 6);\n    aggregate += drawSagie(center) * float(number == 0);\n    return aggregate;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pos = 2.0 * fragCoord/iResolution.xy - 1.0;\n    float aspectRatio = iResolution.x / iResolution.y;\n    pos.x *= aspectRatio;\n    pos = scale(vec2(0.5 + 0.5 * cos(iTime))) * pos;\n    \n    vec2 pieceSize = vec2(0.22, 0.54);\n    float pieceRadius = 0.08;\n    vec4 piece = shapeColor(white, sdRoundedBox(pos, pieceSize, pieceRadius), 0.65);\n\n    int counter = int((iTime + 3.15) / 6.25) % numberOfValues;\n    vec4 blendedRedDots = drawDots(red, counter, pos + vec2(0.0, 0.32), piece);\n\n    vec4 blendedGreenDots = drawDots(green, (counter + 1) % numberOfValues , pos - vec2(0.0, 0.32), piece);\n\n    vec2 divStart = vec2(-0.24, 0.0);\n    vec2 divEnd = vec2(0.24, 0.0);\n    float divRadius = 0.02;\n    vec4 divider = shapeColor(black, sdRoundedLine(pos, divStart, divEnd, divRadius), 15.0);\n    vec4 blendedDivider = mix(piece, divider, divider.a);\n\n    fragColor = combine(combine(blendedRedDots, blendedGreenDots), blendedDivider);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtdGRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 68, 68, 100], [102, 102, 140, 140, 257], [259, 259, 313, 313, 347], [349, 349, 378, 378, 462], [464, 464, 509, 509, 539], [541, 541, 603, 603, 774], [776, 776, 816, 816, 850], [852, 852, 876, 876, 923], [1108, 1108, 1165, 1165, 1292], [1294, 1294, 1352, 1352, 1668], [1671, 1671, 1729, 1729, 2193], [2195, 2195, 2253, 2253, 2871], [2873, 2873, 2931, 2931, 3697], [3699, 3699, 3757, 3757, 4674], [4676, 4676, 4742, 4742, 5026], [5028, 5028, 5057, 5057, 7903], [7905, 7905, 7974, 7974, 8543], [8545, 8545, 8600, 8600, 9539]], "test": "untested"}
{"id": "st33Rf", "name": "Persian carpet 13", "author": "jarble", "description": "These patterns resemble Persian carpets.", "tags": ["fractal", "carpet", "rug"], "likes": 4, "viewed": 304, "published": 3, "date": "1636436467", "time_retrieved": "2024-07-30T18:49:26.642662", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5/2.;\n\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime)/10.0+uv.x);\n    vec3 random1 = (hash31(1.+t2)-vec3(.5))/4.;\n    vec3 random2 = (hash31(1.+t2)-vec3(.5))/4.;\n    vec3 random3 = (hash31(2.+t2)-vec3(.5))/4.;\n    vec3 random4 = (hash31(3.+t2)-vec3(.5))/4.;\n    \n    float offset = .5;\n    float scale2 = 1.16;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        float bend = 1.;\n        //float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            //float bend = abs(fract((uv.x)*2.)-.5)/2.+1.;\n            //float bend = 1.+1./3.;\n            //float bend = scale2;\n            \n            //uv *= bend+col.x;\n            uv = triangle_wave(uv.yx-offset,scale)/bend+triangle_wave(uv,scale)*bend;\n            \n            for(int k = 0; k < 3; k++){\n                uv.y /= scale2;\n                //uv.y /= scale2-uv.x/2.;\n                //uv *= bend+col.x;\n                uv = triangle_wave((uv-random2[k])/(random4[k]+1.),scale+random3[k]).yx;\n                //if(uv.x > uv.y) uv /= scale;\n\n                uv += fract(uv.x)/8.; //a more interesting quilt pattern\n                \n                uv.x /= -scale2;\n\n                //uv *= bend+col.x;\n                //uv.x /= -scale2+uv.y/2.;\n                scale /= 1.+(scale2+uv.x+uv.y)*col.x/5.;\n                \n\n                //bend *= -1.;\n                //bend -= 1./3.-col.x;\n                //bend = 1.+uv.x/2.;\n                \n\n\n            }\n            scale2 += col.x/8.;\n            \n            col[c] = fract((uv.x)-(uv.y));\n            //col[c] = abs(-col[c]-uv.x+uv.y);\n\n\n        }\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st33Rf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [590, 590, 629, 629, 674], [676, 676, 733, 733, 2709]], "test": "untested"}
{"id": "slcGRX", "name": "exploding blobs", "author": "lomateron", "description": "enhancing the curl to the point of explosion in BufferB\nenhancing the divergence makes it explode too but not as cool", "tags": ["explosion", "physics"], "likes": 60, "viewed": 946, "published": 3, "date": "1636416992", "time_retrieved": "2024-07-30T18:49:27.548241", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = fragCoord/iResolution.xy;\n    vec4 a = texture(iChannel0,u);\n    fragColor = a.z+a.z*sin(length(a.xy)+vec4(1,2,3,4)+0.);\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4  r = vec4(0);\n    vec4  a = A(u);\n    float z    = 8.;//kernel convolution size\n    float blur = 3./z;\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        vec2  c = vec2(i,j)*blur; //c = c.yx*vec2(-1,1);\n              c*= exp(-dot(c,c));\n        vec4  a2= A(u+vec2(i,j));\n        vec4  b = a2-a;\n        r.xy += c*b.z;\n        r.z  += dot(c,b.xy           )*a2.z;\n        r.w  += dot(c,b.yx*vec2(-1,1))*a2.z;\n    }}\n    fragColor = r;\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4  r = A(u);\n    float z    = 8.;//kernel convolution size\n    float blur = 3./z;\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n      vec4 b = B(u+vec2(i,j));\n      vec2 c = (-vec2(i,j))*blur;\n           c*= exp(-dot(c,c))*.06*r.z;\n      r.xy += +b.z*c              *0. //enhance divergence\n              +b.w*c.yx*vec2(-1,1)*1. //enhance curl \n              +abs(b.z)*(step(0.,b.w)*2.-1.)*c.yx*vec2(-1,1)*0.;\n    }}\n\n    fragColor = r;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\n#define C(u) texture(iChannel2,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4 t = A(u);\n    vec2 m = +t.xy\n             +B(u).xy*(t.z-.5)\n             +t.z*vec2(0,.0)\n             -C(u).x*t.xy*.0;\n    float s = 0.;\n    float z    = 8.;//kernel convolution size\n    float blur = 4./z;\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n      vec2 c = (m+vec2(i,j))*blur;\n      s += exp(-dot(c,c));\n    }}\n    if(s==0.){s = 1.;}\n    s = 1./s;\n    \n    fragColor = vec4(m,s,0);\n}", "buffer_c_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    float tz = 0.;\n    vec4 a = vec4(0);\n    float z    = 8.;//kernel convolution size\n    float blur = 4./z;\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n      vec4 t = A(u+vec2(i,j));\n      vec4 m = B(u+vec2(i,j));\n      vec2 c = (m.xy-vec2(i,j))*blur;\n      float z = t.z*exp(-dot(c,c));\n      a.xy += z*m.xy;\n      a.z  += z*m.z;\n      tz   += z;\n    }}\n    if(tz==0.){tz = 1.;}\n    a.xy /= tz;\n    if(iMouse.z>0.)\n    {\n        vec2 m = 16.*(u-iMouse.xy)/iResolution.y;\n        a += vec4(1,0,1,1)*.1*exp(-dot(m,m));\n    }\n    if(iFrame==0)\n    {\n        vec2 m = 4.*(u-iResolution.xy*.5)/iResolution.y;\n        a = vec4(1,0,1,1)*exp(-dot(m,m));\n    }\n    fragColor = a;\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slcGRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 193]], "test": "untested"}
{"id": "flc3zX", "name": "depth of field focus study 2", "author": "morisil", "description": "Testing something out", "tags": ["chromaticaberration", "study", "depthoffield", "focus"], "likes": 12, "viewed": 466, "published": 3, "date": "1636412668", "time_retrieved": "2024-07-30T18:49:28.319180", "image_code": "// Fork of \"depth of field focus study\" by morisil. https://shadertoy.com/view/sld3zB\n// 2021-11-08 19:52:49\n\nconst float SHAPE_SIZE = .4;\nconst float CHROMATIC_ABBERATION = .02;\nconst float ITERATIONS = 7.;\nconst float INITIAL_LUMA = .5;\n\nfloat getColorComponent(in vec2 st, in float modScale, in float blur) {\n    vec2 modSt = mod(st, 1. / modScale) * modScale * 2. - 1.;\n    float dist = length(modSt);\n    float angle = atan(modSt.x, modSt.y);\n    float shapeMap = smoothstep(SHAPE_SIZE + blur, SHAPE_SIZE - blur, dist);\n    return shapeMap;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st =\n        (2.* fragCoord - iResolution.xy)\n        / min(iResolution.x, iResolution.y);\n\n    float modScale = 1.;\n\n    vec3 color = vec3(0);\n    float luma = INITIAL_LUMA;\n    float blur = .2;\n    for (float i = 0.; i < ITERATIONS; i++) {\n        vec2 center = st + vec2(sin(iTime * .5), cos(iTime * .3));\n        //center += pow(length(center), 1.);\n        vec3 shapeColor = vec3(\n            getColorComponent(center - st * CHROMATIC_ABBERATION, modScale, blur),\n            getColorComponent(center, modScale, blur),\n            getColorComponent(center + st * CHROMATIC_ABBERATION, modScale, blur)        \n        ) * luma;\n        st *= 1.3;\n        color += shapeColor;\n        color = clamp(color, 0., 1.);\n        if (color == vec3(1)) break;\n        luma *= .63;\n        blur *= .63;\n    }\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flc3zX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[240, 240, 311, 311, 547], [549, 549, 604, 604, 1452]], "test": "untested"}
{"id": "flcGzX", "name": "Polar DDA Experiment #1", "author": "Yusef28", "description": "Using Circle-Ray intersection and segment-segment intersection. Very brute force but it works.\nI can already see a way more efficient method.", "tags": ["dda", "polar"], "likes": 15, "viewed": 331, "published": 3, "date": "1636403389", "time_retrieved": "2024-07-30T18:49:29.077154", "image_code": "\n/*\n  at every step, calculate intersection with two circles\n  and intersection with two lines\n  \n  \n  My thoughts/approach while preparing to code this.\n  Some of it might have changed as I worked on it:\n  \n\n          //we will hit either inner or outer circle\n          //circles centered at origin\n          // ict = inner circle  (rad=uvFL.y)\n          // oct = outer circle  (rad=uvCL.y)\n\n          //after each hit, move to that hitpoint and start a new\n          //segment in the same direction but starting just \n          //beyond the hit, so we always find the next hit that \n          //intersects with the new segment\n\n          //we MAY hit either upper or lower line, \n          //but possibly neither, and never both\n\n          // lines(not segments rotated aaround 0,0 at 0rads\n          // llt = lower line rot(uvFL.x)\n          // ult = upper line rot(uvCL.x)\n\n          //this will be our min t, the distance to the closest\n          //hit point.\n          // float t = min(min(llt,ult),min(ict,oct));\n          //and ofcourse if we don't even hit a line, it's\n          //t value will be inf or something\n\n          //so we ust move to that location and in the example\n          //we'll just draw a point there to.\n\n          //check if angle \n  \n  This experiment is just a rudimentary brute-force \n  intersection algorithm.\n  \n\n*/\n\n#define pi acos(-1.)\n#define eps 1./iResolution.y\n#define mattzGreen vec3(0.6, 0.75, 0.6)*0.7\n#define polarColor vec3(1.,0.,.6)*0.8\n#define lengthColor vec3(1.,0.,0.)*0.8\n\nmat2 rot(float a){\n    float s = sin(a), c = cos(a);\n  return mat2(c,-s,s,c);\n}\n\nfloat intersectCircle(vec2 ro, vec2 rd, float r){\n\n    vec2 O_C = ro;\n    float a = dot(rd,rd);\n    float b = 2.*dot(rd,O_C);\n    float c = dot(O_C,O_C) - r*r;\n    \n    float disc = b*b-4.*a*c;\n    \n    if(disc < 0.) return 100000.;\n    \n    float t1 = (-b - sqrt(disc))/(2.*a); \n    float t2 = (-b + sqrt(disc))/(2.*a);\n    \n    if(t1 >= 0.){return t1;}\n    else if(t2 >= 0.){return t2;}\n    else return 10000.;\n}\n\nfloat ssRing(vec2 p, float r){\n  \n    return smoothstep(r-eps,r+eps,abs(length(p)-0.014));\n}\n\nfloat ssCircle(vec2 p, float r){\n  \n    return smoothstep(r-eps,r+eps,length(p)-0.003);\n}\n\nfloat distToLine(vec2 A, vec2 B, vec2 p){\n    \n    vec2 PA = p - A;\n    vec2 BA = B - A;\n    float d = dot(PA,BA);\n    float t = clamp(d/(length(BA)*length(BA)),0., 1.);//Vektorprodukt\n    vec2 normal = PA - BA*t;\n    return length(normal);\n}\n\n\nfloat segSeg(vec2 A1, vec2 B1, vec2 A2, vec2 B2){\n    float B = B2.x-A2.x;\n    float A = B1.x-A1.x;\n    \n    float E = B2.y-A2.y;\n    float D = B1.y-A1.y;\n    \n    float C = A1.x-A2.x;\n    float F = A1.y-A2.y;\n  \n    float s = (B*F-C*E)/(A*E-D*B);\n    float t = (A*F-D*C)/(A*E-D*B);\n  \n   //it really can't be s here lol\n    return t;\n}\n\n\n/*\n\n//I was experimenting with another line intersection\n//method\n\nfloat intersectLine( vec2 P, vec2 rd, vec2 B){\n    vec2 A = vec2(0.);\n\n    vec2 AP = P-A;\n    vec2 BA = B-A;\n    \n    float t = clamp(dot(AP,BA)/\n                    dot(BA,BA), \n                    0., 1.);\n                    \n    vec2 P3 = A + t*BA;\n    vec2 P3P = P-P3;\n  \n    float adj = length(P3P);\n    float P3PAngle = acos(dot(rd,normalize(P3P)));\n    float h = adj/dot(normalize(P3P), rd);\n\n    return h;\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n  \n  vec3 col = vec3(1, 0.97, .87);\n  \n      \n      ////////////////////////////////////////////\n      //                                       //\n////////          SETUP (HACKY)              //\n      //                                   //\n      /////////////////////////////////////\n        \n    \n    \n  float scale = 10.;\n  float circleDrawRadius = 0.004;\n  vec2 uvP = vec2(atan(uv.y,uv.x)/pi, length(uv));\n  uvP *= scale;\n  \n  vec2 uvFR = fract(uvP.xy);\n  vec2 uvFL = floor(uvP.xy);\n  vec2 uvCL = ceil(uvP.xy);\n  \n  col = mix(col,mattzGreen,smoothstep(0.48,0.49, abs(fract(uvP.yyy)-0.5)));\n  //col *= (1.-smoothstep(0.42,0.46,abs(fract(uvP.xxx)-0.5)));\n  vec2 ro = vec2(-2.9,0.2)/scale;\n  vec2 oldRo= ro;\n  vec2 rd = vec2(1.,0.)*rot(iTime/2.);\n  if(iMouse.z > 0.5) \n        rd = normalize((iMouse.xy*2.-iResolution.xy)/iResolution.y - ro);\n    \n  col = mix(col,vec3(.5,0.,0.),1.-ssCircle(uv-ro,circleDrawRadius));\n  \n  float ray = 1.0-smoothstep(0.002,.009,\n              abs(distToLine(ro, ro+rd * 100., uv)));\n                \n  col = mix(col, vec3(0.), ray);\n  \n  //we do need to extend the ray to inf in one direction\n  float ict,oct,llt,ult,t;\n  vec2 baseA = vec2(-1000.,0.);\n  vec2 baseLine = vec2(1000.,0.);\n      \n      \n       \n      ////////////////////////////////////////////\n      //                                       //\n////////          CHECK LINE HITS            //\n      //                                   //\n      /////////////////////////////////////\n        \n\n  \n  float polar_step = pi/(scale);\n  for(float i=0.; i<pi*2.; i+=polar_step){\n    \n    baseLine *= rot(polar_step);\n    float f = 1.0-smoothstep(0.00,0.003,\n                abs(distToLine(vec2(0.), baseLine, uv)));\n    \n    vec2 A1 = vec2(0.);\n    vec2 B1 = baseLine;\n    \n    vec2 A2 = ro;\n    vec2 B2 = (ro+rd*100.);\n    \n    col = mix(col, mattzGreen, f);\n    t = segSeg(A1,B1,A2,B2);\n    \n    if(t >= 0. && t <= 1.){\n        vec2 pol2 = vec2(A2.x + t*(B2.x-A2.x), A2.y + t*(B2.y-A2.y));\n        col = mix(col,polarColor, 1. - ssRing(uv-pol2,circleDrawRadius) );\n        col = mix(col,polarColor, 1. - ssCircle(uv-pol2,circleDrawRadius) );\n    }\n    \n  }\n\n      \n      ////////////////////////////////////////////\n      //                                       //\n////////          CHECK CIRCLE HITS          //\n      //                                   //\n      /////////////////////////////////////\n  ro = oldRo;     \n    \n    \n  for(int i = 0; i < 10; i++){\n     uvFL = floor(uvP.xy);\n     uvCL = ceil(uvP.xy);\n    \n     ict = intersectCircle(ro, rd, uvFL.y/scale);\n     oct = intersectCircle(ro, rd, uvCL.y/scale);\n     t = min(ict,oct);\n    \n    //a \"Travelling ro\" \n     ro += rd*t;\n     col = mix(col,lengthColor,1. - ssRing(uv-ro,circleDrawRadius) );\n     col = mix(col,lengthColor,1. - ssCircle(uv-ro,circleDrawRadius) );\n    //push a it beyond the line\n     ro += rd*eps;\n  }\n \n\n      ////////////////////////////////////////////\n      //                                       //\n////////          POST PROCESSING            //\n      //                                   //\n      /////////////////////////////////////\n        \n    \n    //vignett from mattz\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2 );       \n    col *= 0.9 + 0.1*texture(iChannel0, fragCoord.xy/256.).x;\n    col *= 0.9 + 0.1*texture(iChannel0, fragCoord.xy/256.).x;\n    col = pow(col, vec3(1.0/2.2));\n  fragColor = vec4(col, 1);\n}\n\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flcGzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1526, 1526, 1544, 1544, 1605], [1607, 1607, 1656, 1656, 2021], [2023, 2023, 2053, 2053, 2115], [2117, 2117, 2149, 2149, 2206], [2208, 2208, 2249, 2249, 2450], [2453, 2453, 2502, 2502, 2789], [3280, 3280, 3337, 3337, 6860]], "test": "untested"}
{"id": "fld3z2", "name": "velocity conservation", "author": "lomateron", "description": "click to add mass\ntrying to make a fluid only using convolutions, no particles\nthis is close but not quite there\nvelocity here never dies, never cancels out, its going to move faster and faster", "tags": ["fluid", "convolution", "kernels"], "likes": 23, "viewed": 474, "published": 3, "date": "1636379637", "time_retrieved": "2024-07-30T18:49:29.937852", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0,u).zzzz;\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec2  a = vec2(0);\n    float h = A(u).z;\n    float z    = 8.;//kernel convolution size\n    float blur = 4./z;\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        vec2 c = vec2(i,j)*blur; //c = c.yx*vec2(-1,1);\n        float h2 = A(u+vec2(i,j)).z;\n        a += c*(h2-h)*exp(-dot(c,c));\n    }}\n    fragColor = a.xyxy;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\n#define C(u) texture(iChannel2,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4 t = A(u);\n    vec2 m = +t.xy\n             +B(u).xy*(t.z-.4)\n             +t.z*vec2(0,.0)\n             -C(u).x*t.xy*.0;\n    float s = 0.;\n    float z    = 8.;//kernel convolution size\n    float blur = 4./z;\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n      vec2 c = (m+vec2(i,j))*blur;\n      s += exp(-dot(c,c));\n    }}\n    if(s==0.){s = 1.;}\n    s = 1./s;\n    \n    fragColor = vec4(m,s,0);\n}", "buffer_b_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    float lz = 0.;\n    float tz = 0.;\n    vec4 a = vec4(0);\n    float z    = 8.;//kernel convolution size\n    float blur = 4./z;\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n      vec4 t = A(u+vec2(i,j));\n      vec4 m = B(u+vec2(i,j));\n      vec2 c = (m.xy-vec2(i,j))*blur;\n      float z = t.z*exp(-dot(c,c));\n      lz   += z*length(m.xy);\n      a.xy += z*m.xy;\n      a.z  += z*m.z;\n      tz   += z;\n    }}\n    if(tz==0.){tz = 1.;}\n    float l = 1./length(a.xy);  if(isinf(l)){l = 0.;}\n    a.xy *= l*lz/tz;\n    if(iMouse.z>0.)\n    {\n        vec2 m = 16.*(u-iMouse.xy)/iResolution.y;\n        a += vec4(0,0,1,1)*.1*exp(-dot(m,m));\n    }\n    if(iFrame==0)\n    {\n        vec2 m = 7.*(u-iResolution.xy*.5)/iResolution.y;\n        a = vec4(0,0,1,1)*exp(-dot(m,m));\n    }\n    fragColor = a;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fld3z2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 141]], "test": "untested"}
{"id": "7td3Rj", "name": "Test 159", "author": "MineGame159", "description": "Test", "tags": ["test"], "likes": 1, "viewed": 187, "published": 3, "date": "1636378871", "time_retrieved": "2024-07-30T18:49:30.898284", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 c = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    \n    float r = texelFetch(iChannel1, ivec2(fragCoord) - ivec2(1, 0), 0).r;\n    if (r > 0.0)\n    {\n        c = vec4(0.5);\n    }\n    else if (r <= 0.0)\n    {\n        c = vec4(0.0);\n    }\n    \n    float d = distance(iMouse.xy, fragCoord);\n    if (iMouse.z > 0.0 && d <= 8.0)\n    {\n        c = vec4(1.0);\n    }\n    \n    fragColor = c;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7td3Rj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 119]], "test": "untested"}
{"id": "sltGRj", "name": "Twizzly Circle Mess", "author": "SnoopethDuckDuck", "description": "Messing around again", "tags": ["raymarching", "template", "artofcode"], "likes": 53, "viewed": 2919, "published": 3, "date": "1636378779", "time_retrieved": "2024-07-30T18:49:31.764967", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n// set these really low so my computer can handle it + dont mind the glitchy look\n#define MAX_STEPS 40\n#define MAX_DIST 20.\n#define SURF_DIST 0.05\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n} \n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nfloat GetDist(vec3 p) {\n\n    float sd = length(p - vec3(0,1.5 + 0.5 * cos(iTime),0)) \n               - 0.6  + 0.1 * cos(2. * iTime);\n\n    float a = atan(p.x, p.z);\n    float l = length(p.xz);\n    float lf = length(fract(p.xz)-0.5);\n //   p.y += 0.2 * thc(2., 5. * l * (.5 + .5 * thc(2., 1. * l - iTime)) + a + 1. * iTime) / cosh(0.35 * l);\n    \n   // vec2 ipos = floor(p.xz) - 0.;\n    //vec2 fpos = fract(p.xz) - 0.25;\n    \n    //p.y += 1./cosh(mix(12.,40., .5 + .5 * thc(4., iTime + 11. * h21(ipos))) * lf);\n    p.y *= 1. / cosh(0.5 * l + cos(a + iTime));\n    p.y += mix(0., 0.15, .5 + .5 * thc(2., 4. * l +  iTime)) * thc(4., 4. * l + iTime);\n    float d = dot(p, vec3(0,1,0));//length(p) - 1.5;\n    \n   \n    return  min(d, 1. * sd);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n    float k = rd.y*.5 + .5;\n    \n    vec3 col = mix(vec3(.5,0.,0.),vec3(0.),k);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    float time = 0.25 * iTime;\n    vec3 ro = vec3(4. * thc(5.,time), mix(2., 5., .5 + .5 * thc(3., 1.5 * time)), 4. * ths(5.,time));\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        vec3 rf = refract(rd, n,0.1);\n        \n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = 0.42 *vec3(dif);\n        \n        float b = .5 + .5 * cos(iTime);\n        \n        uv = fragCoord.xy / iResolution.xy;\n        col += 0.9 * texture(iChannel0,r / (0.5 + n)).rgb;\n         \n        float a = atan(rf.z, rf.x);\n        float c = atan(rf.z,rf.y);\n        col.r += 0.15 + .25 * thc(2.,10. * rf.x + iTime - 3.1415 / 2.);\n        col.g += 0.15 + .25 * thc(2.,10. * rf.y + iTime);\n        col.b += 0.15 + .25 * thc(2.,10. * rf.z + iTime + 3.1415 / 2.);\n        \n        float l = length(p);\n        float pa = atan(p.x ,p.z);\n        col *= 0.7 + .5 * thc(6. + 6. * cos(20. * l + 10. * pa + iTime), \n                              1.2 * l - 24. * pa - 0.5 * cos(l * 10. + 2. * pa + iTime) -  2. * iTime);\n       // col *= 1.5;\n    } else {\n        col = texture(iChannel0, rd).rgb;\n    }\n    \n    col.y = .5 * (col.x + col.z);\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sltGRj.jpg", "access": "api", "license": "mit", "functions": [[1555, 1555, 1574, 1574, 1636], [1639, 1639, 1659, 1659, 1734], [1736, 1736, 1765, 1765, 1806], [1808, 1808, 1837, 1837, 1878], [1880, 1880, 1903, 1903, 2617], [2619, 2619, 2653, 2653, 2864], [2866, 2866, 2890, 2890, 3080], [3082, 3082, 3132, 3132, 3323], [3325, 3325, 3343, 3343, 3441], [3444, 3444, 3501, 3501, 5077]], "test": "untested"}
{"id": "Ntd3R2", "name": "Wind Farm", "author": "dr2", "description": "Endless free energy... (mouseable)", "tags": ["symmetry", "seascape", "windmill", "propeller"], "likes": 20, "viewed": 406, "published": 3, "date": "1636367157", "time_retrieved": "2024-07-30T18:49:32.786236", "image_code": "// \"Wind Farm\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA    0  // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Maxv2 (vec2 p);\nfloat Minv2 (vec2 p);\nfloat Minv3 (vec3 p);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define N_BOAT 2\n\nmat3 boatMat[N_BOAT];\nvec3 boatPos[N_BOAT], sunDir, qHit;\nvec2 gId, gShift, csMilAx, csBldAng, csBldPch;\nfloat dstFar, tCur, hgSize, boatAng[N_BOAT], boatSz, milSz;\nint idObj, idObjGrp;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvec3 TrackPath (float t)\n{\n  return vec3 (7. * cos (0.06 * t) + 0.1 * t, 0., t);\n}\n\nvec3 TrackVel (float t)\n{\n  return vec3 (-0.06 * 7. * sin (0.06 * t) + 0.1, 0., 1.);\n}\n\nfloat GrndHt (vec2 p)\n{\n  float h, s;\n  h = Fbm2 (0.5 * p) - 0.45;\n  s = 1. - abs (p.x - TrackPath (p.y).x) / 2.5;\n  if (s > 0.) h = max (h - s * s, -0.5);\n  return h;\n}\n\nfloat GrndHtN (vec2 p)\n{\n  float h;\n  h = GrndHt (p);\n  if (h > 0.) h = 0.3 * h + 0.3 * Fbm2 (2. * p);\n  return h;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.001, 0.);\n  return normalize (vec3 (GrndHtN (p.xz) - vec2 (GrndHtN (p.xz + e.xy),\n     GrndHtN (p.xz + e.yx)), e.x)).xzy;\n}\n\nvoid SetMilParms ()\n{\n  vec2 g, w, cs0;\n  g = HexToPix (gId * hgSize);\n  if (GrndHt (g) < 0. || Hashfv2 (37. * gId + 1.1) < 0.15) milSz = 0.;\n  else {\n    milSz = 0.18 * hgSize * 0.5 * sqrt3 * (1. - 0.1 * Hashfv2 (17. * gId + 1.1));\n    w = Hashv2v2 (73. * gId + 1.1);\n    cs0 = vec2 (0.5 * pi, 0.);\n    gShift = hgSize * max (0., 0.1 * sqrt3 - milSz) * w.x * sin (2. * pi * w.y + cs0);\n    csBldAng = sin (0.2 * (0.2 + w.x) * pi * (tCur + 10.) + cs0);\n    csMilAx = sin (0.2 * pi * sin (0.1 * pi * tCur) + 0.2 * pi * w.y + 0.01 * pi * tCur + cs0);\n    csBldPch = sin ((0.15 + 0.2 * w.x) * pi + cs0);\n  }\n}\n\nfloat BladeDf (vec3 p, float dMin)\n{\n  vec3 q;\n  vec2 b;\n  float d, bLen, bxMax;\n  bLen = 4.;\n  bxMax = 2.;\n  q = p;\n  q.x += 0.3;\n  d = PrRoundCylDf (q.yzx, 0.25, 0.05, 0.25);\n  DMINQ (2);\n  q.zy = Rot2Cs (q.zy, csBldPch);\n  q.xz += vec2 (bLen + 0.2, -0.03);\n  b = vec2 (q.x, sign (q.y));\n  if (q.z > 0.) q.zx = Rot2D (q.zx - vec2 (0., bxMax), mix (-0.02, 0.011,\n     step (q.x, bxMax)) * pi) + vec2 (0., bxMax);\n  q.yx = Rot2D (q.yx, 0.003 * pi * b.y);\n  d = PrRoundBoxDf (vec3 (b.x, q.y + 0.05 * b.y, q.z), vec3 (bLen, 0.02, 0.2), 0.12);\n  DMINQ (3);\n  return dMin;\n}\n\nfloat GObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, tLen, bScl, s;\n  dMin = dstFar;\n  if (milSz > 0.) {\n    p.xz -= HexToPix (gId * hgSize) + gShift;\n    dMin /= milSz;\n    p /= milSz;\n    tLen = 3.5;\n    q = p;\n    q.xz = Rot2Cs (q.xz, csMilAx);\n    q.yz -= vec2 (2. * tLen + 0.1, 0.1);\n    d = PrRoundBoxDf (q, vec3 (0.18, 0.2, 0.375), 0.1); \n    DMINQ (1);\n    q.z += 0.55;\n    q.xy = Rot2Cs (q.xy, csBldAng);\n    d = PrCapsDf (q, 0.2, 0.45);\n    DMINQ (2);\n    q.z += 0.27;\n    q.xy = Rot2D (q.xy, 2. * pi * ((floor (3. * atan (q.y, - q.x) / (2. * pi)) + 0.5) / 3.));\n    bScl = 0.65;\n    dMin = bScl * BladeDf (q / bScl, dMin / bScl);\n    q = p;\n    q.y -= tLen;\n    s = abs (q.y / tLen - 1.);\n    d = PrCylDf (q.xzy, 0.15 * (0.8 + 0.125 * s * s * s), tLen);\n    DMINQ (4);\n    dMin *= milSz;\n  }\n  return dMin;\n}\n\nfloat GObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  eps = 0.01;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  gIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = Minv3 (hv);\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetMilParms ();\n    }\n    d = GObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 GObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat GObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  gIdP = vec2 (-999.);\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetMilParms ();\n    }\n    h = GObjDf (p);\n    sh = min (sh, smoothstep (0., 0.02 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.8 + 0.2 * sh;\n}\n\nfloat BoatDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  dMin /= boatSz;\n  p /= boatSz;\n  p.y -= 0.7;\n  d = PrCylDf (p, 1.2, 3.5);\n  if (d < 0.1 / boatSz) {\n    q = p;\n    d = max (max (PrRoundCylDf (q, -0.8, 2., 1.5), - max (PrRoundCylDf (q - vec3 (0., 0.1, 0.),\n       -0.85, 2., 1.5), abs (q.y) - 0.1)), abs (q.y + 0.1) - 0.1);\n    q.y -= -0.2;\n    d = max (SmoothMin (d, max (PrRoundCylDf (q, -1., 2., 1.3 ), q.y), 0.1), q.z - 2.);\n    DMINQ (idObjGrp + 1);\n    q = p;\n    q.yz -= vec2 (-0.5, -0.2);\n    d = max (PrRoundCylDf (q, -0.1, 1.1, 1.2), max (0.4 - q.y, q.z - 1.2));\n    DMINQ (idObjGrp + 2);\n    q = p;\n    q.yz -= vec2 (0.8, 0.5);\n    d = PrCylDf (q.xzy, 0.04, 0.3);\n    DMINQ (idObjGrp + 3);\n  } else dMin = min (dMin, d);\n  return boatSz * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar;\n  for (int k = 0; k < N_BOAT; k ++) {\n    idObjGrp = (k + 1) * 256;\n    dMin = BoatDf (boatMat[k] * (p - boatPos[k]), dMin);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol;\n  vec2 q;\n  float f, fd, ff;\n  q = 0.01 * (ro.xz + tCur * vec2 (0.5, 2.) + ((200. - ro.y) / rd.y) * rd.xz);\n  ff = Fbm2 (q);\n  f = smoothstep (0.1, 0.8, ff);\n  fd = smoothstep (0.1, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n  clCol = (0.8 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n     smoothstep (0., 0.05, abs (fd)));\n  fd = smoothstep (0.01, 0.1, rd.y);\n  col = mix (mix (vec3 (0.8, 0.8, 0.75), vec3 (0.4, 0.5, 0.8), 0.3 + 0.7 * fd), clCol,\n     0.1 + 0.9 * f * fd);\n  return col;\n}\n\nfloat WakeFac (vec3 row)\n{\n  vec2 tw[N_BOAT], twa;\n  float twLen[N_BOAT], wkFac, ba;\n  for (int k = 0; k < N_BOAT; k ++) {\n    tw[k] = row.xz - (boatPos[k].xz - Rot2D (vec2 (0., 2.), boatAng[k]));\n    twLen[k] = length (tw[k]);\n  }\n  if (twLen[0] < twLen[1]) {\n    twa = tw[0];\n    ba = boatAng[0];\n  } else {\n    twa = tw[1];\n    ba = boatAng[1];\n  }\n  twa = Rot2D (twa, - ba);\n  wkFac = 0.;\n  if (length (twa * vec2 (2., 0.5)) < 1.) wkFac =\n     clamp (1. - 4. * abs (twa.x), 0., 1.) * clamp (0.5 + twa.y, 0., 1.);\n  return wkFac;\n}\n\nvec4 BoatCol ()\n{\n  vec4 col4, c4;\n  int ig, id;\n  ig = idObj / 256;\n  id = idObj - 256 * ig;\n  c4 = (ig == 1) ? vec4 (0.9, 0.9, 0.3, 0.2) : vec4 (0.3, 0.9, 0.3, 0.2);\n  if (id == 1) col4 = (abs (qHit.y - 0.1) < 0.01) ? vec4 (0.7, 0.4, 0.2, 0.1) * (1. -\n     0.2 * SmoothBump (0.42, 0.58, 0.05, mod (7. * qHit.x, 1.))) :\n     ((qHit.y > -0.3) ? c4 : vec4 (0.7, 0.7, 0.8, 0.1));\n  else if (id == 2) col4 = (abs (abs (qHit.x) - 0.4) < 0.36 && qHit.y > 0.45 && \n     length (vec2 (abs (qHit.x) - 0.1, qHit.y - 0.2)) < 0.7 || abs (abs (qHit.z + 0.2) -\n     0.6) < 0.5 && abs (qHit.y - 0.65) < 0.2) ? vec4 (0.6, 0.5, 0.2, -1.) : c4;\n  else if (id == 3) col4 = vec4 (1., 0., 0., 0.2);\n  return col4;\n}\n\nvec4 MillCol ()\n{\n  vec4 col4;\n  if (idObj == 1) col4 = vec4 (1., 0.9, 0.7, 0.1) * (0.5 +\n     0.5 * smoothstep (0., 0.02, abs (qHit.y) - 0.02)) * (0.5 +\n     0.5 * smoothstep (0., 0.02, length (vec2 (qHit.x, qHit.z + 0.1))- 0.18));\n  else if (idObj == 2) col4 = vec4 (0.9, 1., 0.8, 0.2);\n  else if (idObj == 3) col4 = mix (vec4 (0.85, 0.85, 0.9, 0.2), vec4 (1., 0.2, 0.2, 0.1), \n     smoothstep (0., 0.02, step (qHit.x, -3.5)));\n  else if (idObj == 4) col4 = vec4 (0.9, 0.8, 0.7, 0.05) * (0.9 +\n     0.1 * smoothstep (0., 0.02, abs (mod (2. * qHit.y + 0.5, 1.) - 0.5) - 0.02));\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, row;\n  vec2 vf;\n  float dstObj, dstObjG, dstObjM, dstGrnd, wkFac, sh;\n  int idObjG;\n  bool wtRefl;\n  boatSz = 0.15;\n  dstObjG = GObjRay (ro, rd);\n  idObjG = idObj;\n  dstObjM = ObjRay (ro, rd);\n  dstGrnd = (rd.y < 0.) ? - ro.y / rd.y : dstFar;\n  wtRefl = false;\n  wkFac = 0.;\n  dstObj = min (dstObjM, dstObjG);\n  if (dstGrnd < min (dstObj, dstFar)) {\n    row = ro + dstGrnd * rd;\n    if (GrndHt (row.xz) < 0.) {\n      ro = row;\n      wkFac = WakeFac (row);\n      row.xz += 0.2 * tCur;\n      vf = (wkFac > 0.) ? vec2 (16., 2. * wkFac) : vec2 (2., 0.05 * (1. - smoothstep (0.1, 0.4,\n          dstGrnd / dstFar)));\n      vn = VaryNf (vf.x * row, vec3 (0., 1., 0.), vf.y);\n      row = ro;\n      rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n      dstObjG = GObjRay (ro, rd);\n      idObjG = idObj;\n      dstObjM = ObjRay (ro, rd);\n      dstGrnd = dstFar;\n      dstObj = min (dstObjM, dstObjG);\n      wtRefl = true;\n    }\n  }\n  sh = 1.;\n  if (min (dstObj, dstGrnd) < dstFar) {\n    if (dstObj < dstGrnd) {\n      if (dstObjM < dstObjG) {\n        ro += dstObjM * rd;\n        vn = ObjNf (ro);\n        col4 = BoatCol ();\n     } else {\n        ro += dstObjG * rd;\n        idObj = idObjG;\n        vn = GObjNf (ro);\n        col4 = MillCol ();\n        if (idObj == 4) vn = VaryNf (64. * ro, vn, 0.3);\n      }\n    } else {\n      ro += dstGrnd * rd;\n      vn = GrndNf (ro);\n      gId = PixToHex (ro.xz / hgSize);\n      SetMilParms ();\n      col4 = vec4 (vec3 (0., 0.4, 0.) * (1. - 0.2 * Fbm2 (8. * ro.xz)), 0.05);\n      if (milSz > 0.) col4 *= 0.5 + 0.5 * smoothstep (0., 0.03,\n         milSz * length (ro.xz - HexToPix (gId * hgSize)) - 0.05);\n      sh = GObjSShadow (ro, normalize (vec3 (1., 5., 1.)));\n    }\n    if (col4.a >= 0.) {\n      col = col4.rgb * (0.2 + 0.2 * max (dot (normalize (vec3 (- sunDir.xz, 0.)).xzy, vn), 0.) +\n         0.8 * sh * max (dot (vn, sunDir), 0.)) +\n         col4.a * step (0.95, sh) * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 32.);\n      col = mix (col, SkyCol (ro, rd), (wtRefl ? 0.2 + 0.8 * smoothstep (0.4, 0.6,\n         dstObj / dstFar) : smoothstep (0.8, 0.9, min (dstGrnd, dstObj) / dstFar)));\n    } else col = mix (col4.rgb, 0.5 * SkyCol (ro, reflect (rd, vn)), 0.8);\n  } else col = SkyCol (ro, rd);\n  col *= wtRefl ? 0.85 : 1.;\n  if (wkFac > 0.) col = mix (col, vec3 (0.8, 0.83, 0.8), wkFac * clamp (0.1 +\n     Fbm2 (16. * row.xz), 0., 1.));\n  col *= vec3 (1.05, 0.95, 0.95);\n  return clamp (col, 0., 1.);\n}\n\nvoid BoatPM (float t, out vec3 bPos, out mat3 bMat, out float btAng)\n{\n  vec3 v;\n  vec2 cs;\n  float bAz;\n  bPos = TrackPath (t);\n  bPos.y = 0.;\n  bMat[2] = vec3 (Rot2D (vec2 (1., 0.), 0.4 * (Fbm1 (0.2 * t) - 0.5)), 0.);\n  bMat[0] = normalize (vec3 (0., 0.1, 1.));\n  bMat[1] = cross (bMat[0], bMat[2]);\n  v = TrackVel (t);\n  bAz = atan (v.z, - v.x);\n  btAng = 0.5 * pi - bAz;\n  cs = sin (bAz + vec2 (0.5 * pi, 0.));\n  bMat *= mat3 (cs.x, 0., cs.y, 0., 1., 0., - cs.y, 0., cs.x);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv, uvv, uvf, mMid, ut, mSize, msw;\n  float el, az, asp, winHt, zmFac, sr, spd;\n  int vuId, regId;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  winHt = 0.9;\n  uvf = vec2 (asp, winHt) - abs (uv);\n  mSize = (1./5.) * vec2 (asp, 1.) * winHt;\n  mMid = vec2 (asp, winHt - mSize.y) * vec2 (1. - mSize.y, -1.);\n  ut = abs (uv - mMid) - mSize;\n  regId = -1;\n  if (mPtr.z > 0.) {\n    regId = 0;\n    msw = 2. * mPtr.xy - mMid / vec2 (asp, 1.);\n    if (Maxv2 (abs (msw)) < mSize.y) {\n      regId = 1;\n      msw /= 2. * mSize.y;\n    }\n    if (regId == 0) msw = mPtr.xy;\n  }\n  vuId = 0;\n  if (Maxv2 (ut) < 0.) {\n    uv = (uv - mMid) / mSize.y;\n    vuId = 1;\n  }\n  if (regId > 0 && (vuId == 0 || vuId == regId)) vuId = regId - vuId;\n  tCur = mod (tCur, 2400.) + 30. * floor (dateCur.w / 7200.);\n  hgSize = 3.;\n  spd = 0.3;\n  ro = TrackPath (spd * tCur);\n  if (vuId == 0) {\n    ro.x += 0.1 * sin (0.05 * 2. * pi * tCur);\n    ro.y = 1. + 0.3 * Fbm1 (0.1 * tCur);\n    vd = TrackVel (spd * tCur);\n    el = -0.03 * pi;\n    az = atan (vd.x, vd.z);\n    if (mPtr.z > 0.) {   \n      el += 0.4 * pi * msw.y;\n      az += 2. * pi * msw.x;\n    }\n    el = clamp (el, -0.4 * pi, 0.4 * pi);\n    zmFac = 3.;\n  } else {\n    ro.y = 30.;\n    el = -0.3 * pi + 0.1 * pi * msw.y;\n    az = 0.2 * pi * msw.x;\n    zmFac = 5.;\n  }\n  for (int k = 0; k < N_BOAT; k ++) {\n    BoatPM (spd * tCur + ((vuId == 0) ? (((abs (az) > 0.5 * pi) ? -1. : 1.) *\n       (7. * float (k) + 5.)) : 7. * float (k) + 15.), boatPos[k], boatMat[k], boatAng[k]);\n    boatPos[k].y = -0.02 + 0.04 * Fbm1 (0.5 * tCur + float (k));\n  }\n  vuMat = StdVuMat (el, az);\n  dstFar = 120.;\n  sunDir = normalize (vec3 (1., 3., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  if (uvf.y > 0.) {\n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) *\n         pi)) / zmFac;\n      rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n      col += (1. / naa) * ShowScene (ro, rd);\n    }\n    if (Maxv2 (ut) < 0. && Minv2 (abs (ut)) * canvas.y < 2. ||\n       Minv2 (uvf) * canvas.y < 2.) col = vec3 (0.6, 0.3, 0.2);\n  } else col = vec3 (0.85);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntd3R2.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1193, 1193, 1219, 1219, 1275], [1277, 1277, 1302, 1302, 1363], [1365, 1365, 1388, 1388, 1534], [1536, 1536, 1560, 1560, 1652], [1654, 1654, 1676, 1676, 1824], [1826, 1826, 1847, 1847, 2432], [2434, 2434, 2470, 2470, 3004], [3006, 3006, 3029, 3029, 3823], [3825, 3825, 3859, 3859, 4945], [4947, 4947, 4969, 4969, 5225], [5227, 5227, 5265, 5265, 5671], [5673, 5673, 5708, 5708, 6439], [6441, 6441, 6463, 6463, 6640], [6642, 6642, 6675, 6675, 6858], [6860, 6860, 6881, 6881, 7136], [7138, 7138, 7170, 7170, 7699], [7701, 7701, 7727, 7727, 8235], [8237, 8237, 8254, 8254, 8932], [8934, 8934, 8951, 8951, 9529], [9531, 9531, 9566, 9566, 12032], [12034, 12034, 12104, 12104, 12513], [12515, 12515, 12571, 12571, 15180], [15182, 15182, 15228, 15228, 15275], [15277, 15277, 15319, 15319, 15370], [15372, 15372, 15429, 15429, 15505], [15507, 15507, 15550, 15550, 15614], [15616, 15616, 15640, 15640, 15870], [15872, 15872, 15896, 15896, 15956], [15958, 15958, 15980, 15980, 16007], [16009, 16009, 16031, 16031, 16058], [16060, 16060, 16082, 16082, 16120], [16122, 16122, 16167, 16167, 16259], [16261, 16261, 16318, 16318, 16401], [16403, 16403, 16439, 16439, 16645], [16647, 16647, 16677, 16677, 16790], [16792, 16792, 16823, 16823, 16887], [16921, 16921, 16945, 16945, 17005], [17007, 17007, 17031, 17031, 17084], [17086, 17086, 17110, 17110, 17222], [17224, 17224, 17249, 17249, 17395], [17397, 17397, 17422, 17422, 17608], [17610, 17610, 17632, 17632, 17786], [17788, 17788, 17809, 17809, 17964], [17966, 17966, 17995, 17995, 18207], [18209, 18209, 18248, 18248, 18505]], "test": "untested"}
{"id": "NsKSzt", "name": "lattice sdf", "author": "ufffd", "description": "playing with cubes of cubes and booleans of more cubes\noptimization ideas:\n- premarch to the main cube\n- premarch to the max subcube", "tags": ["3d", "raymarching", "distancefield", "sdf"], "likes": 4, "viewed": 301, "published": 3, "date": "1636354840", "time_retrieved": "2024-07-30T18:49:33.672866", "image_code": "// show step count. click to set splitscreen\n#define DEBUG_STEPS\n\n#define AA 1\n\n//---------------------------------\n// geometry controls\nconst float bothscale = 1.;\nconst float boxscale = 0.125 * bothscale;\nconst float diascale = 0.38 * bothscale;\nconst float timeoffset = 1.5; // -2 to 2\nconst int pattern = 999; // pattern picker, 1-whatever, 999 to test\nconst float dancespeed = 1.5;\n// render controls\nconst float render_depth = 13.0; // range 9ish to 11, lower = goopy\nconst int render_steps = 64; // options: 4, 8, 16, 32. low = goopy\nconst float lines = 0.0; // 0 to ~3.5\nconst int colormode = 2;\n\nfloat cubeDance(in float time, in vec3 pos) {\n    float size = 0.0;\n    if (pattern == 1) {\n        size += sin(time + pos.y * 3.15 * -.75);\n        if (mod(pos.x + pos.z,2.0) < 0.5) size *= -1.;\n    } else if (pattern == 2)\n        size += sin(time + pos.x * pos.y * (3.0 + 2.0 * pos.z));\n    else if (pattern == 3) \n        size += pos.y*cos(time*0.5);    \n    else {\n        vec3 normpos = (pos+0.5) * 0.4 - 1.; // -1 to 1\n        vec3 centerpos = abs(normpos) * 2.0 - 1.0;\n        size = sin(centerpos.z + centerpos.x + centerpos.y + time);\n    }\n    return size; // -1 to 1\n}\n\nfloat map(in vec3 pos)\n{\n    float d = 1e10;\n\n    pos -= vec3(.0,2.,.0);\n    \n    float c = .5;\n    float l = 2.;\n    \n    vec3 opos = pos;\n    \n    pos = pos-c*clamp(round(pos/c),-l,l);\n\n    \n    \n    \n    vec3 cubepos = pos; // something wrong here\n    \n    \n    \n    \n    float temptime = iTime*dancespeed;\n\n    float boxsize = cubeDance(temptime, cubepos);\n    boxsize = clamp(boxsize*1.4+0.2, -1., 1.0);\n    boxsize = sin(boxsize)*boxscale+boxscale;\n\n    float diasize = cubeDance(temptime+timeoffset, cubepos);\n    diasize = clamp(diasize*1.4+0.2, -1.1, 1.0);\n    diasize = sin(diasize)*diascale+diascale;\n    float d2 = sdBox(\n        pos, \n        boxsize\n    ); \n    float d3 = sdOctahedron(\n        pos, \n        diasize\n    );\n    // d3 = 0.; // show box only\n    // d2 = 0.; // show diamond only\n    d = min( d, max( d2, d3 ));\n    \n    return d;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ) );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.01, 1.00 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n \n        vec3 ro = vec3(.0,5.8,10.);\n        vec3 rd = normalize(vec3(p-vec2(.0,2.05),-5.));\n        \n        ro.xz *= opRotate(iTime * .5 + p.y * 1.2);\n        rd.xz *= opRotate(iTime * .5 + p.y * 1.2);\n\n        float t = 8.5;\n        int stepped = 0;\n        for( int i=0; i<render_steps; i++ )\n        {\n            stepped++;\n            vec3 p = ro + t*rd;\n            float h = map(p);\n            if( abs(h)<0.005 || t>render_depth ) break;\n            t += h;\n        }\n        \n        #ifdef DEBUG_STEPS\n            if (abs(iMouse.x) < fragCoord.x) {\n                float nstepped = float(stepped)/float(render_steps);\n                fragColor = vec4(nstepped);\n                return;\n            }\n        #endif\n\n        vec3 col = vec3(0.0);\n\n        if( t<render_depth + lines)\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 lig = vec3(0.8);\n            float dif = clamp(dot(nor,lig),0.0,1.0);\n            float sha = calcSoftshadow( pos, lig, 0.001, 0.5, 12.0 );\n            float amb = 0.5 + 0.5*nor.y;\n        \n            if (colormode == 1){\n                float amb = 0.5 + 0.5*nor.y;\n                col = vec3(sha + amb) / 2.;\n                col -= 0.5;\n                col *= 2.0;\n                col = pow(col, vec3(0.5));\n                col /= 2.0;\n                col += 0.5;\n                col = vec3(step(amb,0.3));\n            } else if (colormode == 2){\n                float amb = 0.5 + 0.5*nor.y;\n                col = vec3(sha + amb) / 2.;\n                col -= 0.5;\n                col *= 2.0;\n                col = pow(col, vec3(0.25));\n                col /= 2.0;\n                col += 0.5;\n            } else {\n                col = vec3(0.4)*amb + \n                      vec3(.80)*dif*sha;\n            }\n            \n        }\n\n        col = sqrt( col );\n        \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "#define R iResolution\n\n// SDF functions from IQ:\n// Copyright © 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Smooth vs sharp boolean operations for combining shapes\n\n// Related techniques:\n//\n// Elongation  : https://www.shadertoy.com/view/Ml3fWj\n// Rounding    : https://www.shadertoy.com/view/Mt3BDj\n// Onion       : https://www.shadertoy.com/view/MlcBDj\n// Metric      : https://www.shadertoy.com/view/ltcfDj\n// Combination : https://www.shadertoy.com/view/lt3BW2\n// Repetition  : https://www.shadertoy.com/view/3syGzz\n// Extrusion2D : https://www.shadertoy.com/view/4lyfzw\n// Revolution2D: https://www.shadertoy.com/view/4lyfzw\n//\n// More information here: https://iquilezles.org/articles/distfunctions\n\nmat2 opRotate(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n//-------------------------------------------------\n\nfloat sdSphere( in vec3 p, in float r )\n{\n    return length(p)-r;\n}\n\n\nfloat sdBox( vec3 p, float b)\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdDiamond( vec3 p, float b)\n{\n  vec3 rot = p;\n  rot.xy = rot.xy * opRotate(0.785);\n  rot.xz = rot.xz * opRotate(.616);\n  rot.yz = rot.yz * opRotate(-.616);\n  vec3 d = abs(rot) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float d = (p.x+p.y+p.z-s)*0.57735027;\n  return d;\n}\n\nfloat opRepLimBox( in vec3 p, in float c, in vec3 l, float bb )\n{\n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    return sdBox(q, bb);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKSzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[605, 605, 650, 650, 1185], [1187, 1187, 1211, 1211, 2047], [2049, 2095, 2127, 2127, 2361], [2363, 2408, 2495, 2495, 2753]], "test": "untested"}
{"id": "7l3GR2", "name": "入门之路-13", "author": "jialouluo", "description": "图片切换", "tags": [], "likes": 3, "viewed": 212, "published": 3, "date": "1636353072", "time_retrieved": "2024-07-30T18:49:34.579442", "image_code": "#define M_PI 3.1415926535897932384626433832795\n\nvec2 phyllotaxis(float i, float c) {\n    float phi = M_PI * (3. - sqrt(5.)) * c;\n    /// 计算出的 xy 呈 “螺旋线” 的形状\n    float angle = (i / c) * phi;\n    float r = sqrt(i / c);\n    float x = r * cos(angle);\n    float y = r * sin(angle);\n\n    return vec2(x, y);\n}\n\nfloat samples = 128.;\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec4 col;\n    float pre = fract(iTime *0.2);\n    for(float i = 0.; i < samples; i++) {   \n         // 选用的是螺旋线采样\n        vec2 offset;\n        float angle = pre* M_PI;\n        //原理是 通过sin函数的0 ~ PI 来实现 0 ~ PI/2让currentImg渐变模糊，处于PI/2时切换纹理，PI/2 ~ PI 让nextImg渐变清晰\n        //一直循环播放看起来效果不是很好，本人自用于两张图片的切换效果\n        if(angle<=M_PI/2.0) {\n            offset = phyllotaxis(i, samples) * 0.1* sin(angle);\n            col += texture(iChannel0, uv + offset);\n        } else {\n            offset = phyllotaxis(i, samples)  * 0.1 * sin(angle);\n            col += texture(iChannel1, uv + offset);\n        }\n    }\n    col /= samples;\n    fragColor = vec4(col.rgb, 1.0);\n}\n", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l3GR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 84, 84, 328], [352, 352, 407, 457, 1296]], "test": "untested"}
{"id": "ftd3RS", "name": "500K", "author": "lennyjpg", "description": "dfghdfgh", "tags": ["dfghd"], "likes": 0, "viewed": 185, "published": 3, "date": "1636352647", "time_retrieved": "2024-07-30T18:49:35.327442", "image_code": "float rand(vec2 co){\nreturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n//https://www.shadertoy.com/view/4djSRW\nfloat hash_WithoutSine(vec2 p)\n{\nvec3 p3  = fract(vec3(p.xyx) * .1031);\np3 += dot(p3, p3.yzx + 19.19);\nreturn fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 colorA = vec3(0.435,0.086,0.953);\nvec3 colorB = vec3(0.953,0.369,0.369);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv =  ( fragCoord - .5* iResolution.xy ) / iResolution.y; \n\nfloat s = -0.1;\nfloat t = fract(iTime * s * 2.0);\n\nfloat n = exp(t * 5.0) - 0.9;\nvec2 g = 0.5 + uv * n;\n\n//float k = hash_WithoutSine(floor(g)+t*0.001);\nfloat r = 0.4 - t * 0.6;\n\nvec2 offset = vec2(0.5, 0.5);\nfloat u = length(fract(g) - offset);\nfloat c = smoothstep(u, u * 0.97, r);\nfloat p = floor(fract(iTime * s)*2.0);\nc = abs(p - c);\nvec3 colorC = mix(colorA, colorB, c);\nfragColor = vec4(colorC, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftd3RS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 88], [90, 130, 162, 162, 270], [351, 351, 408, 408, 883]], "test": "untested"}
{"id": "Nl3Gz2", "name": "Persian carpet 12", "author": "jarble", "description": "These patterns resemble Persian carpets.", "tags": ["fractal", "carpet", "rug"], "likes": 3, "viewed": 234, "published": 3, "date": "1636347753", "time_retrieved": "2024-07-30T18:49:36.204098", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime)/20.0+uv.x);\n    vec3 random1 = (hash31(1.+t2)-vec3(.5))/4.;\n    vec3 random2 = (hash31(1.+t2)-vec3(.5))/4.;\n    vec3 random3 = (hash31(2.+t2)-vec3(.5))/4.;\n    vec3 random4 = (hash31(3.+t2)-vec3(.5))/4.;\n    \n    float offset = .5;\n    float scale2 = 1.5;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        //float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            vec3 col_prev = col; \n            //float factor = 1.16;\n            //uv.y *= factor;\n\n            uv = triangle_wave(uv.yx-offset,scale)+triangle_wave(uv,scale);\n            for(int k = 0; k < 3; k++){\n                uv.y /= scale2;\n                //uv.y /= scale2-uv.x/2.;\n                uv = triangle_wave((uv-random2[k])/(random4[k]+1.),scale+random3[k]);\n                uv.x /= -scale2;\n                //uv.x /= -scale2-uv.y/2.;\n            }\n            //uv.x *= factor;\n            \n            //uv.x *= -1.0;\n            //uv = triangle_wave(uv+c1.y,scale);\n            scale /= 1.+scale2*col.x;\n            //offset *= scale2/(1.+random4.x);\n            \n            //uv = -uv.yx;\n            //uv = uv.yx;\n            //scale2 *= 1.25 + col.x;\n            //scale2 += col.x/8.;\n            scale2 = 1./(1.+col.x);\n            //col = (col*random1[i]+col_prev.yzx*(1.-random1[i]));\n            col[c] = fract((uv.x)-(uv.y));\n            //col[c] = abs(-col[c]-uv.x+uv.y);\n\n        }\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl3Gz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [590, 590, 629, 629, 674], [676, 676, 733, 733, 2581]], "test": "untested"}
{"id": "Ntc3zj", "name": "#WorldTessellationDay 2021", "author": "cmarangu", "description": "It is not world tessellation day today (2021 November 7th). I am releasing the code on shadertoy because I am bored.\n[url]https://twitter.com/C010011012/status/1405775912277188608[/url]\n[url]https://www.instagram.com/p/CQQHrwgjtaU/[/url]", "tags": ["tessellation"], "likes": 4, "viewed": 236, "published": 3, "date": "1636340209", "time_retrieved": "2024-07-30T18:49:37.166525", "image_code": "// Current Code For: #WorldTessellationDay 2021\n// Date: 2021 June 17th\n// Tags: tessellation\n// Description: https://twitter.com/C010011012/status/1405775912277188608\n// https://www.instagram.com/p/CQQHrwgjtaU/\n\n\n// ↓ i know more\n#define PI 3.141592653589793238462643383279502884197169399375105820974944592307\n// 816406286 208998628034 8253421170679821480865132823066470938446095505\n#define TAU 6.2831853071795864\n\n// frequency in THz\n#define freqr 430.\n#define freqg 545.\n#define freqb 660.\n\n// samples per frame - each output frame = spf sample-frames blended together equally\n//#define spf 1.\n//const float spf = 30.*1.;\nconst float spf = 1.*1.;\n\n#define iFramef floor(float(iFrame) /spf)\n#define iFramem   mod(float(iFrame), spf)\n\n#define arg mod(  iFramef  /30./1., 1.)\n\n// frameblending version\n//#define arg mod(  float(iFrame)/spf  /30./1., 1.)\n\n// for testing porpoises - will blend all the animations frames\n// e.g. if the animation is a rotating cube the output should look like a blurry cylinder\n// try set spf=3 or 4 and pausing the animation to see how all frames blended equally\n//#define arg ( iFramem/spf )\n\n//\n// sky map\n//\n\n//#define inter_sky vec4(vec3(0.), 1e9)\nconst vec4 inter_sky = vec4(vec3(0.), 1e9);\nfloat sky_map (in float freq, in vec3 d) {\n    #if 0\n    vec3 col = texture(iChannel2, d).rgb;\n    #elif 1\n        vec3 col = vec3(1.);\n        col = vec3(0.);\n    #elif 0\n    vec3 col = vec3(.7, 1., 1.);\n    #else\n    vec3 col = vec3(0., 0., 100./255.);\n    #endif\n    //\n    if (freq == freqr) {\n        return col.r;\n    }\n    else if (freq == freqg) {\n        return col.g;\n    }\n    else if (freq == freqb) {\n        return col.b;\n    }\n}\n\n\n\n\n//\n// intersect primitive shapes\n//\nvec4 inter_sphere (vec3 p, vec3 d, float r) {\n\tfloat bsign = length(p) > r ? -1. : 1.;\n\tvec3 bar = -p;\n\tfloat h = length(bar);\n\tfloat a = h*dot(normalize(bar), d);\n\tfloat o = sqrt(h*h-a*a);\n\tif (dot(d, bar) > 0. && o <= r) {\n\t\tfloat bevel = sqrt(r*r-o*o);\n\t\tvec3 hitp = p+d*(a+bsign*bevel);\n\t\treturn vec4(\n\t\t\tnormalize(hitp)*-bsign,\n\t\t\ta+bsign*bevel\n\t\t);\n\t}\n\treturn inter_sky;\n}\n// plane - one liner lol\n// #define SDF_plane(p, n) ( dot(normalize(p), n)*length(p) )\nfloat SDF_plane (vec3 p, vec3 n) { return dot(normalize(p), n)*length(p); }\n#define inter_plane_short(p, d, n) (\\\n    dot(n, d) > 1e-6 ? vec4(-n, dot(-p, n)/dot(n, d)) : inter_sky )\n// #define inter_plane_dist(p, d, n) (\\\n//dot(n, d) > 1e-6 ? dot(-p, n)/dot(n, d) : inter_sky )\nvec4 inter_plane (vec3 p, vec3 d, vec3 n) {\n    vec4 inter_plane1 = inter_plane_short(p, d, n);\n    if (inter_plane1.w < inter_sky.w && inter_plane1.w > 0.) {\n        return inter_plane1;\n    }\n    inter_plane1 = inter_plane_short(p, d, -n);\n    if (inter_plane1.w < inter_sky.w && inter_plane1.w > 0.) {\n        return inter_plane1;\n    }\n    return inter_sky;\n}\n//\n// SDF\n//#define SDF(p) (length(p-vec3(.5) )-.49)\n//#define SDF(p) (length(max(abs(p-vec3(.5))-vec3(.4), 0.) )-.02)\n//#define SDF(p) (length(max(abs(p-vec3(.5))-vec3(.3), 0.) )-.18)\n#define SDF(p) (length(max(abs(p-vec3(.5))-vec3(.48), 0.) )-.015)\n// try mini n=(1, 0, 0) cylinder\n//#define SDF(p) ( length((p).yz-.5)-.49 )\n//#define SDF(p) ( length((p).xy-.5)-.49 )\n#define inf vec2(1e-4, 0.)\nvec4 inter_SDF (vec3 p, vec3 d) {\n    // test\n    //return inter_sphere(p, d, 1.);\n    //\n    // camp is unmodified p\n    vec3 camp = p;\n    //\n    #if 0\n    // space skip to sphere (.5, .5, .5) r=1.8 (causes bug)\n    vec4 temp;\n    temp = inter_sphere(p-vec3(.5), d, 1.8);\n    if (temp.w >= inter_sky.w) {\n        return inter_sky;\n    }\n    else {\n        if (length(p-vec3(.5)) > 1.8) {\n            p += d*temp.w;\n        }\n    }\n    //return temp;\n    #endif\n    //\n    //\n    float SDFp;\n    //for (int i=0; i<111222; ++i) {\n    //for (int i=0; i<11222; ++i) {\n    for (int i=0; i<333; ++i) {\n        SDFp = SDF(p);\n        //if (abs(SDFp) < 1e-4 && i > 10) {\n        //if (abs(SDFp) < 1e-1) {\n        if (abs(SDFp) < 5e-4) {\n            return vec4(\n                normalize(\\\n                    vec3(\n                        SDF(p+inf.xyy),\n                        SDF(p+inf.yxy),\n                        SDF(p+inf.yyx)\n                    )-SDFp\n                )*sign(SDFp),\n                length(p-camp)\n            );\n        }\n        p += d*abs(SDFp)*.5;\n        //p += d*abs(SDFp)*.99;\n        //p += d*abs(SDFp);\n        //if (abs(SDFp) > 10.) {\n        // sqrt(3) ~ 1.732\n        if (abs(SDFp) > 1.8) {\n            break;\n        }\n    }\n    \n    return inter_sky;\n}\nvec4 inter_minecraft (vec3 p, vec3 d) {\n    // return inter_SDF(fract(p), d);\n    float dist; vec4 inter_current; bool blockhere;\n    vec3 camp = p, qm, qf;\n    int missedsdf = 0;\n    // space skipping\n    vec3 pane1c = vec3(0., 16., 0.);\n    vec3 pane1n = normalize(vec3(0., 1., 0.));\n    pane1n = normalize(vec3(1., 10., 6.));\n    //pane1n = normalize(vec3(1.));\n    #if 1\n    if (SDF_plane(p-pane1c, pane1n) > 0.) {\n        inter_current = inter_plane(p-pane1c, d, pane1n);\n        if (inter_current.w >= inter_sky.w) {\n            // never hit bounding cube\n            return inter_sky;\n        }\n        else {\n            //\n            p += d*inter_current.w;\n            p += d*1e-3;\n        }\n    }\n    #else\n    inter_current = inter_rectprism(p_m_bouc, d, bouwhl);\n    return inter_current;\n    #endif\n    for (int voxjumps=0; voxjumps<140; ++voxjumps) {\n        //\n        if (SDF_plane(p-pane1c, pane1n) > .2) {\n            return inter_sky;\n        }\n        //\n        qf = floor(p);\n        qm = fract(p);\n        //\n        //\n        //\n        blockhere = true;\n        //\n        //\n        //blockhere = qf.y <= 0. && blockhere;\n        blockhere = qf.x*0.+qf.y*10.+qf.z*10. <= 0.;\n        //blockhere = qf.x+qf.y+qf.z <= 0.;\n        //blockhere = floor(qf.x/2.)+floor(qf.y/2.)+floor(qf.z/2.) <= 0.;\n        //blockhere = floor(qf.x/2.)+floor(qf.y/2.)+floor(qf.z/2.) >= -0. && blockhere;\n        //\n        //\n        //\n        if (blockhere) {\n            //\n            inter_current = inter_SDF(qm, d);\n            //\n            //\n            inter_current.w += length(p-camp);\n            vec3 wasp = p;\n            p = camp+d*inter_current.w;\n            if (inter_current.w < inter_sky.w) {\n                return inter_current;\n            }\n            p = wasp;\n            ++missedsdf;\n            if (missedsdf >= 4) {\n                return inter_sky;\n            }\n        }\n        //\n        //\n        dist = inter_sky.w;\n        // macro method\n        #if 0\n    //#define inter_plane_dist(p, d, c, n) (dot(n, d)>1e-6?dot(c-p, n)/dot(n, d):inter_sky.w)\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0.), vec3(-1., 0., 0.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0.), vec3(0., -1., 0.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0.), vec3(0., 0., -1.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(1., 0., 0.), vec3(1., 0., 0.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0., 1., 0.), vec3(0., 1., 0.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0., 0., 1.), vec3(0., 0., 1.)) );\n        #else\n        // optimized method\n        dist = min(dist, qm.x/-d.x+ max(d.x +1e-6, 0.)*1e20 );\n        dist = min(dist, qm.y/-d.y+ max(d.y +1e-6, 0.)*1e20 );\n        dist = min(dist, qm.z/-d.z+ max(d.z +1e-6, 0.)*1e20 );\n        //\n      dist = min(dist,dot(vec3(1., 0., 0.)-qm, vec3(1., 0., 0.))/d.x+max(-d.x +1e-6, 0.)*1e20);\n      dist = min(dist,dot(vec3(0., 1., 0.)-qm, vec3(0., 1., 0.))/d.y+max(-d.y +1e-6, 0.)*1e20);\n      dist = min(dist,dot(vec3(0., 0., 1.)-qm, vec3(0., 0., 1.))/d.z+max(-d.z +1e-6, 0.)*1e20);\n        //\n        #endif\n        //\n        p += d*dist; p += d*2e-3;\n    }\n    //\n    return inter_sky;\n}\n\n\n\n\n\n\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    //\n    // mouse pos normalized -1 to 1 y aspect ratio x\n    //\n    vec2 maus = (iMouse.xy-iResolution.xy/2.)/(iResolution.y/2.);\n    //\n    //\n    // view rotation matrices\n    //\n    //#define phi clamp(maus.y*3., -1., 1.)*PI*.5\n    #define phi -atan(1./sqrt(2.) )\n    mat2 zenith = transpose(\n        mat2(\n            cos(phi), cos(PI*.5+phi),\n            sin(phi), sin(PI*.5+phi)\n        )\n    );\n    //#define theta maus.x*TAU\n    #define theta -PI*.75\n    mat2 azimuth = transpose(\n        mat2(\n            cos(theta), cos(PI*.5+theta),\n            sin(theta), sin(PI*.5+theta)\n        )\n    );\n    //\n    //\n    // multisampling loop\n    //\n    fragColor = vec4(0., 0., 0., 1.);\n    // spw - width of multisample grid\n    // spp - number of random jitter/monte carlo integration per sub-pixel thing\n    #define spw 1.\n    #define spp 1.\n    float freq, ox, oy; vec3 rand;\n    //\n    #define numsamples spw*spw*spp\n    for (float samplei=0.; samplei<3.*numsamples; ++samplei) {\n        float samplei2 = samplei;\n        if (mod(samplei, 3.) == 0.) {\n            freq = freqr;\n        }\n        else if (mod(samplei, 3.) == 1.) {\n            freq = freqg;\n        }\n        else if (mod(samplei, 3.) == 2.) {\n            freq = freqb;\n        }\n        samplei2 = floor(samplei2/3.);\n        ox = mod(samplei2, spw);\n        samplei2 = floor(samplei2/spw);\n        oy = mod(samplei2, spw);\n        samplei2 = floor(samplei2/spw);\n        samplei2 += (float(iFrame)+fragCoord.x)*numsamples;\n        rand = vec3(\n            fract(\n                sin(\n                    mod(\n                        samplei2*1.234567890123,\n                        TAU\n                    )\n                )\n            ),\n            fract(\n                sin(\n                    mod(\n                        samplei2*10.110010101,\n                        TAU\n                    )\n                )\n            ),\n            fract(\n                sin(\n                    mod(\n                        samplei2*222.222222222,\n                        TAU\n                    )\n                )\n            )\n        );\n        #if 1\n        vec2 screen = (\n            fragCoord.xy+vec2(ox+rand.r, oy+rand.g)/spw-iResolution.xy/2.\n        )/(iResolution.x/2.);\n        #else\n        vec2 screen = (\n            fragCoord.xy+vec2(ox+rand.r, oy+rand.g)/spw-iResolution.xy/2.\n        )/(iResolution.x/2.)*vec2(1., -1.);\n        #endif\n        //\n        //\n        float retina = 0.;\n        float absorb = 1.;\n        //\n        #if 0\n        // perspective\n        vec3 p = vec3(screen.x, screen.y, 0.);\n        vec3 d = normalize(p-vec3(0., 0., -1.));\n        //vec3 p = vec3(0.);\n        //vec3 d = normalize(vec3(screen.x, screen.y, 1.));\n        #else\n        // orthogonal\n        vec3 p = vec3(screen.x, screen.y, 0.)*4.*(sqrt(2.)/2.);///cos(30.*PI/180.);\n        vec3 d = normalize(vec3(0., 0., 1.));\n        #endif\n        //\n        p += vec3(0., 0., -12.);\n        //\n        p.zy = zenith*p.zy;\n        d.zy = zenith*d.zy;\n        p.zx = azimuth*p.zx;\n        d.zx = azimuth*d.zx;\n        //\n        d = normalize(d);\n        //p += vec3(0., 2., 0.);\n        //p -= d*20.;\n        //\n        //\n        //\n        //#define numbounces 50.\n        #define numbounces 3.\n        for (float bounces=0.; bounces<numbounces; ++bounces) {\n        //for (float bounces=0.; bounces<1.; ++bounces) {\n            //\n            if (absorb <= .1) {\n                break;\n            }\n            //\n            float samplei3 = bounces;\n            samplei3 += (float(iFrame)+fragCoord.x)*numbounces;\n            //\n            vec3 rand2 = vec3(\n                fract(\n                    sin(\n                        mod(\n                            samplei3*1.234567890123,\n                            TAU\n                        )\n                    )\n                ),\n                fract(\n                    sin(\n                        mod(\n                            samplei3*10.110010101,\n                            TAU\n                        )\n                    )\n                ),\n                fract(\n                    sin(\n                        mod(\n                            samplei3*222.222222222,\n                            TAU\n                        )\n                    )\n                )\n            );\n            //\n            vec4 inter_closest = inter_sky;\n            vec4 inter_current;\n            float inter_id;\n            //\n            //#define sphc vec3(cos(arg*TAU), 2.+sin(arg*TAU), 0.)\n            #define tempc vec3(0., 6., 0.)\n            #define tempr 1.\n            //inter_current = inter_sphere(p-tempc, d, tempr);\n            inter_current = inter_sky;\n            //inter_current = inter_SDF(p, d);\n            //inter_current = inter_sky;\n            vec3 tempp = p+d*inter_current.w;\n            if (inter_current.w < inter_closest.w) {\n                inter_closest = inter_current;\n                inter_id = 1.;\n                 if (length(p-tempc)-tempr < 0.) {\n                //if (SDF(p) < 0.) {\n                    // p is inside sphere - p hits inner shell\n                    inter_id *= -1.;\n                }\n            }\n            #undef tempc\n            #undef tempn\n            //\n            #define tempc vec3(0., -1.1, 0.)\n            #define tempn normalize(vec3(0., 1., 0.))\n            //inter_current = inter_plane(p-tempc, d, tempn );\n            inter_current = inter_minecraft(p, d);\n            tempp = p+d*inter_current.w;\n            if (inter_current.w < inter_closest.w) {\n                inter_closest = inter_current;\n                inter_id = 2.;\n                //inter_id = blocktyp(floor(tempp))+1.;\n                //inter_id *= sign(SDF_plane(p-tempc, tempn ));\n                inter_id *= sign( SDF(fract(tempp)) );\n            }\n            #undef tempc\n            #undef tempn\n            //\n            if (inter_closest.w >= inter_sky.w) {\n                // too far - hits sky\n                break;\n            }\n            else {\n                p += d*inter_closest.w;\n                //\n                //\n                //\n                //\n                //if (abs(inter_id) == 1.) {}\n                //if (abs(inter_id) == 2.) {\n                if (abs(inter_id) == 1.) {\n                    // hits sphere\n                    //\n                    // Texture\n                    //\n                    vec3 TEXp = .5*abs(inter_closest.xyz);\n                    //TEXp = .5+.5*inter_closest.xyz;\n                    TEXp = vec3(1.);\n                    #if 0\n                    #define temp 1.\n                    TEXp *= mod(floor(p.x*temp+.001)+floor(p.y*temp+.001)+floor(p.z*temp+.001), 2.);\n                    #endif\n                    //\n                    // absorbed/emitted light\n                    //\n                    #if 1\n                    if (freq == freqr) {\n                        absorb *= TEXp.r;\n                    }\n                    else if (freq == freqg) {\n                        absorb *= TEXp.g;\n                    }\n                    else if (freq == freqb) {\n                        absorb *= TEXp.b;\n                    }\n                    #endif\n                    //\n                    // environment light\n                    //\n                    if (abs(inter_id) == 3.) {\n                        d = reflect(d, inter_closest.xyz);\n                    }\n                    else if (abs(inter_id) == 4.) {\n                        d = reflect(d, inter_closest.xyz);\n                    }\n                    #if 0\n                    // specular reflection\n                    d = reflect(d, inter_closest.xyz);\n                    #elif 1\n                    // specular refraction\n                    // air 1.0\n                    // water 1.333\n                    // glass 1.458\n                    // diamond 2.417\n                    float eta = 1.01;\n                    eta = 10.7;\n                    if (inter_id > 0.) {\n                        // inside SDF - moving from obj to air\n                        eta = 1./eta;\n                    }\n                    //inter_closest.xyz = normalize(inter_closest.xyz);\n                    //d = normalize(d);\n                    d = refract(d, inter_closest.xyz, eta);\n                    //d = unrefract(d, inter_closest.xyz, eta);\n                    #elif 0\n                    // diffuse reflection\n                    #endif\n                    //\n                    // advance ray\n                    //\n                    p += d*1e-2;\n                    //\n                    // that's all\n                    //\n                }\n                else if (abs(inter_id) != 1.) {\n                    //\n                    // hits plane\n                    //\n                    //implement brdf\n                    //implement different inter_id based on blocktyp(floor(p))\n                    //\n                    // Texture\n                    //\n                    vec3 TEXp = .5*abs(inter_closest.xyz);\n                    //TEXp = .5+.5*inter_closest.xyz;\n                    //TEXp = vec3(1.);\n                    TEXp = mix(vec3(0., 1., 1.), vec3(0., 0., 1.), fract(p).y)*.5;\n                    if (abs(fract(p).y-.5) > .48) {\n                        TEXp = vec3(.0, .0, .0);\n                    }\n                    else if (abs(fract(p).x-.5) > .48) {\n                        TEXp = vec3(.0, .9, .9);\n                    }\n                    else {\n                        TEXp = vec3(.0, .7, .7);\n                    }\n                    if (abs(fract(p).y-.5) < .48) {\n                        TEXp = mix(TEXp, vec3(0., 0., .9), fract(p.y));\n                    }\n                    else {\n                        /*TEXp += .2*pow(.5+.5*sin( (p.x*4.+\n                            (.5+.5*sin(p.z*TAU))\n                        )*TAU ), 4.);*/\n                        #if 1\n                        #define temp 1.\n                        //TEXp *= mod(floor(p.x*temp+.001)+floor(p.y*temp+.001)+floor(p.z*temp+.001), 2.);\n                        if (mod(floor(p.x*temp+.001)+floor(p.y*temp*0.+.001), 2.) > 0.) {\n                            TEXp += .25;\n                        }\n                        #endif\n                    }\n                    //\n                    #if 0\n                    #define temp 1.\n                    //TEXp *= mod(floor(p.x*temp+.001)+floor(p.y*temp+.001)+floor(p.z*temp+.001), 2.);\n                    if (mod(floor(p.x*temp+.001)+floor(p.y*temp*0.+.001), 2.) > 0.) {\n                        TEXp *= .5;\n                    }\n                    #endif\n                    //\n                    // absorbed/emitted light\n                    //\n                    #if 0\n                    if (freq == freqr) {\n                        absorb *= TEXp.r;\n                    }\n                    else if (freq == freqg) {\n                        absorb *= TEXp.g;\n                    }\n                    else if (freq == freqb) {\n                        absorb *= TEXp.b;\n                    }\n                    #else\n                    \n                    if (freq == freqr) {\n                        retina += absorb*TEXp.r;\n                    }\n                    else if (freq == freqg) {\n                        retina += absorb*TEXp.g;\n                    }\n                    else if (freq == freqb) {\n                        retina += absorb*TEXp.b;\n                    }\n                    //absorb *= 0.;\n                    #endif\n                    //\n                    // environment light\n                    //\n                    absorb *= .4;\n                    //if (abs(inter_id) == 2.) {\n                        //absorb *= 0.;\n                    //}\n                    //else if (abs(inter_id) == 3.) {\n                        d = reflect(d, inter_closest.xyz);\n                    //}\n                    /*#if 1\n                    // specular reflection\n                    d = reflect(d, inter_closest.xyz);\n                    #elif 0\n                    // specular refraction\n                    float eta = 1.01;\n                    if (inter_id > 0.) {\n                        // inside SDF - moving from obj to air\n                        eta = 1./eta;\n                    }\n                    //inter_closest.xyz = normalize(inter_closest.xyz);\n                    //d = normalize(d);\n                    d = refract(d, inter_closest.xyz, eta);\n                    //d = unrefract(d, inter_closest.xyz, eta);\n                    #elif 0\n                    // diffuse reflection\n                    #endif\n                    */\n                    //\n                    // advance ray\n                    //\n                    p += d*1e-2;\n                    //\n                    // that's all\n                    //\n                }\n            }\n            //\n        }\n        //\n        retina += absorb*sky_map(freq, d);\n        if (mod(samplei, 3.) == 0.) {\n            fragColor.rgb += retina*vec3(1., 0., 0.);\n        }\n        else if (mod(samplei, 3.) == 1.) {\n            fragColor.rgb += retina*vec3(0., 1., 0.);\n        }\n        else if (mod(samplei, 3.) == 2.) {\n            fragColor.rgb += retina*vec3(0., 0., 1.);\n        }\n    }\n    fragColor.rgb /= 1.*spw*spw*spp;\n    //\n    // blend with past n frames\n    //\n}\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntc3zj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1230, 1230, 1272, 1272, 1673], [1678, 1714, 1759, 1759, 2092], [2093, 2180, 2214, 2214, 2255], [2362, 2458, 2501, 2501, 2821], [3219, 3219, 3252, 3336, 4504], [4505, 4505, 4544, 4582, 7792]], "test": "untested"}
{"id": "NldGzS", "name": "Four dimensions", "author": "makipl", "description": "Just a quick test of first shader here", "tags": ["fbm"], "likes": 1, "viewed": 108, "published": 3, "date": "1636334297", "time_retrieved": "2024-07-30T18:49:38.059138", "image_code": "float hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n\nvec2 map(in vec2 pos, float offset)\n{\nreturn vec2(sin(pos.x+offset*2.0), cos(pos.y+offset));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (abs(cos(iTime*.2))*2.0+4.0*fragCoord-iResolution.xy)/iResolution.y;\n    uv.xy += -1.0+vec2(sin(iTime*.4)*2.0,cos(iTime*.4)*2.0);\n    vec3 col = vec3(0.0);\n    \n    \n    \n    vec3 ro = vec3(0.0,1.0,-1.5);\n    vec3 ta = vec3(0.0,0.0,0.0);\n    vec3 rd = normalize(ro-1.5);\n    \n    \n    float off=.44;\n    vec3 addProfile=vec3(-0.1);\n    vec3 addProfile2=vec3(0.2);\n    for(int i = 0; i<128; i++)\n    {\n        vec2 dir = map(uv+0.1,sin(iTime+uv.x+uv.y)*atan(iTime*1.2));\n        uv.xy+=0.0015*reflect(-dir, vec2(0.84,0.44));\n        vec3 tex= texture(iChannel1, uv).xyz;\n        vec3 tex2 = texture(iChannel0, uv.xy).xyz;\n        addProfile2 += tex.xyz*tex2.xyz*0.24*uv.x*uv.y+0.003;\n        addProfile += tex.zyx*tex2.zyx*-0.30*uv.x*uv.y+0.003; \n    }\n    \n\n    \n    \n    col = vec3(abs(addProfile2.xyz)+abs(addProfile.xyz))*16.0;\n    col = min(min(col, abs(addProfile2)*2.0),abs(addProfile))*2.0;\n    \n    vec3 colorFresnel = step(col/0.99,vec3(0.4));\n    col *= normalize(col-colorFresnel)*0.5;\n    \n    \n    \n    //float per = abs(sqrt(iTime));\n    /*vec3 us = texture(\n    iChannel1, \n    vec2(fragCoord.xy*.5/iResolution.xy)\n    +vec2(0.02*iTime,0.)).xyz;*/\n    //col *= min(step(us*50.0,vec3(0.59)), vec3(0.09))+1.0;\n    //col *= step(col*0.1, vec3(0.65));\n    //col += abs(col * min(col,smoothstep(col, colorFresnel*4.0, vec3(per)))*1.0)+0.02;\n    //col = sqrt(col)*0.4;\n    uv.x *= 16.0+2.0;\n    uv.y += 16.0-2.0;\n    vec3 colCopy = col;\n    vec3 colCopy2 = col;\n    for(int i=0; i<64; i++)\n    {\n      uv.x+=sin(iTime)*0.001;\n      uv.y*= -2.0;\n      \n      colCopy += colCopy*uv.x + uv.y*64.0;\n      colCopy2 -= colCopy2*uv.x + uv.x*64.0;\n    }\n    \n    vec3 colB = 1.0-min(colCopy2,colCopy);\n    colB = step(colB,vec3(0.5));\n    //colB = mix(vec3(1.0,0.0,0.0)*4.0, vec3(0.0,0.0,1.0)*4.0, colB);\n    \n    vec3 masking = vec3(step(addProfile,vec3(0.04)));\n    vec3 masking_ = vec3(0.1);\n    vec3 colMask = masking*colorFresnel*0.01;\n    \n\nvec3 colorer = (.2+addProfile2*addProfile)+.20;\n    \n    colorer.r += abs(sin(iTime*0.4));\n    colorer.g += abs(sin(0.1+iTime*0.2));\n    colorer.b += abs(cos(0.6+iTime*0.6));\n    \n    \n    vec3 realMask = min(128.0*addProfile,0.6-addProfile2)/1000.0;\n    col = mix(mix(\n    -col*512.0,colorer,max(step(realMask,vec3(0.0)),vec3(0.0))), col*0.15, colB);\n    \n    uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    \n    \n    \n    \n    \n    \n\n    \n\n    // Output to screen\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NldGzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 62], [64, 64, 90, 90, 308], [310, 310, 347, 347, 404], [406, 406, 463, 463, 2946]], "test": "untested"}
{"id": "ftcGRj", "name": "Persian carpet 11", "author": "jarble", "description": "A Persian carpet pattern generator.", "tags": ["fractal", "carpet", "rug"], "likes": 2, "viewed": 225, "published": 3, "date": "1636333398", "time_retrieved": "2024-07-30T18:49:38.909863", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(-2.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 4.5/2.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float t2 = +floor((iTime)/10.0+uv.x);\n    vec3 random1 = (hash31(t2)-vec3(.5))/4.;\n    vec3 random2 = (hash31(1.+t2)-vec3(.5))/4.;\n    vec3 random3 = (hash31(2.+t2)-vec3(.5))/4.;\n    vec3 random4 = (hash31(3.+t2)-vec3(.5))/4.;\n    \n    float offset = .5;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        for(int i=0;i<3;i++)\n        {\n            float factor = 1.25;\n            float l1 = col.x;\n            \n            uv.y /= factor;\n            uv = triangle_wave(uv.yx+l1+offset,scale)+triangle_wave(uv,scale);\n            uv.x /= -factor;\n            \n            for(int k = 0; k < 3; k++){\n                uv.y /= factor;\n                uv = triangle_wave((uv+uv.yx*vec2(random1[k],random2[k])-l1+offset)/(random4[k]+1.),scale+random3[k]);\n                uv.x /= -factor;\n                //uv *= factor;\n                //uv += vec2(random1[k],random2[k])*l1;\n        \n            }\n            \n\n            scale *= 1./(1.+l1);\n\n            //scale2 *= 2. - l1;\n\n            col = col.yxz;\n            col[c] = fract((uv.x)-(uv.y));\n\n\n        }\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftcGRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[278, 388, 410, 456, 589], [591, 591, 630, 630, 675], [677, 677, 734, 734, 2036]], "test": "untested"}
{"id": "7ttGzB", "name": "Shearing Cubic to BCC", "author": "paniq", "description": "demonstrating the use of shearing along the main body diagonal to transform a cubic partition of simplices to body-centered cubic", "tags": ["cubic", "shearing", "bcc"], "likes": 13, "viewed": 375, "published": 3, "date": "1636332895", "time_retrieved": "2024-07-30T18:49:39.982995", "image_code": "//////////////////////////////////////////////////////////\n\nvec3 offset = vec3(0.0);\n\nfloat shear = 1.0;\n\nvec2 rotate(vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,s,-s,c) * p;\n}\n\nvec2 tf(vec3 p) {\n\n    p /= 4.0;\n\n    p += offset;\n    p = p*2.0 - 1.0;\n\n    //float shear = 0.0;\n#if 0\n    // the length under which (0 1 1) (1 0 1) (1 1 0) is orthogonal\n    p -= shear * (p.x + p.y + p.z) / 6.0;\n    // inverse of the above transform\n    // p += (p.x + p.y + p.z) / 3.0;\n#elif 1\n    // shear and align orthogonal vectors with axis\n    //shear = 1.0;\n    vec3 p1 = p - (p.x + p.y + p.z) / 6.0;    \n\n    p1 = vec3(dot(p1, vec3(-1,2,2)/3.0),\n             dot(p1, vec3(2,-1,2)/3.0),\n             dot(p1, vec3(2,2,-1)/3.0));\n\n    p = mix(p, p1.yzx, shear);\n#endif\n    \n    p.xz = rotate(p.xz, radians(iTime*10.0));\n    p.yz = rotate(p.yz, radians(-30.0));\n    \n    p.z += 8.0;\n\n    return vec2(p.x / p.z, p.y / p.z) * 3.5;\n}\n\nvoid draw_point(vec3 p) {\n    float A = AAINV*4.0;\n    circle(tf(p), A);\n    fill();\n}\n\nvoid draw_triangle(vec3 p1, vec3 p2, vec3 p3) {\n    \n    vec2 a = tf(p1);\n    vec2 b = tf(p2);\n    vec2 c = tf(p3);\n    if (cross(vec3(b - a,0),vec3(c - a,0)).z < 0.0) {\n        vec2 t = b;\n        b = c;\n        c = t;\n    }\n    move_to(a);\n    line_to(b);\n    line_to(c);\n    close_path();\n    fill();\n}\n\nvoid draw_quad(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n    draw_triangle(p1, p2, p3);\n    draw_triangle(p3, p4, p1);\n}\n\n\nvoid paint() {\n    float t = iTime;\n\n    //shear = 1.0;//\n    shear = clamp(sin(t*0.5)*2.0*0.5+0.5, 0.0, 1.0);\n\n    set_source_rgb(vec3(0.925, 0.941, 0.894));\n    clear();\n    \n    for (int z = -1; z <= 1; ++z) {\n    for (int y = -1; y <= 1; ++y) {\n    for (int x = -1; x <= 1; ++x) {\n    if (ivec3(x,y,z) != ivec3(0))\n        continue;\n    if (x > 0 || y > 0 || z > 0)\n        continue;\n    offset = vec3(x,y,z);\n    \n    const vec3 p000 = vec3(0,0,0);\n    const vec3 p004 = vec3(0,0,4);\n    const vec3 p040 = vec3(0,4,0);\n    const vec3 p044 = vec3(0,4,4);\n    const vec3 p400 = vec3(4,0,0);\n    const vec3 p404 = vec3(4,0,4);\n    const vec3 p440 = vec3(4,4,0);\n    const vec3 p444 = vec3(4,4,4);\n    \n    set_line_width_px(2.0);\n    \n    float A = AAINV*4.0;\n    \n    for (int i = 0; i < 4; ++i) {\n        float u = float(i & 1)*4.0;\n        float v = float((i>>1) & 1)*4.0;\n        set_source_rgba(vec4(0,0,0,0.4));\n        move_to(tf(vec3(0,u,v)));\n        line_to(tf(vec3(4,u,v)));\n        stroke();\n        set_source_rgba(vec4(0,0,0,0.4));\n        move_to(tf(vec3(u,0,v)));\n        line_to(tf(vec3(u,4,v)));\n        stroke();\n        set_source_rgba(vec4(0,0,0,0.4));\n        move_to(tf(vec3(u,v,0)));\n        line_to(tf(vec3(u,v,4)));\n        stroke();\n    }\n        \n    set_source_rgba(vec4(0,0,0,1.0));\n    move_to(tf(p000));\n    line_to(tf(p444));\n    move_to(tf(p000));\n    line_to(tf(p400));\n    move_to(tf(p000));\n    line_to(tf(p040));\n    move_to(tf(p000));\n    line_to(tf(p004));\n    stroke();\n    \n    set_source_rgba(vec4(0.7,0,0,1.0));\n    move_to(tf(p000));\n    line_to(tf(p044));\n    stroke();\n    set_source_rgba(vec4(0.7,0,0,0.6));\n    move_to(tf(p400));\n    line_to(tf(p444));\n    stroke();\n\n    set_source_rgba(vec4(0,0.7,0,1.0));\n    move_to(tf(p000));\n    line_to(tf(p404));\n    stroke();\n    set_source_rgba(vec4(0,0.7,0,0.6));\n    move_to(tf(p040));\n    line_to(tf(p444));\n    stroke();\n\n    set_source_rgba(vec4(0,0,0.8,1.0));\n    move_to(tf(p000));\n    line_to(tf(p440));\n    stroke();\n    set_source_rgba(vec4(0,0,0.8,0.6));\n    move_to(tf(p004));\n    line_to(tf(p444));\n    stroke();\n    \n    set_source_rgba(vec4(1,0,0,1.0));\n    draw_point(p000);\n    \n    #if 1\n    \n    vec3 p222 = vec3(2);\n    \n    vec3 p231 = vec3(2,3,1);\n    vec3 p321 = vec3(3,2,1);\n    vec3 p312 = vec3(3,1,2);\n    vec3 p213 = vec3(2,1,3);\n    vec3 p123 = vec3(1,2,3);\n    vec3 p132 = vec3(1,3,2);\n\n    set_source_rgba(vec4(1.0, 0.0, 0.8, 0.5));\n    draw_triangle(p222, p231, p321);\n    draw_triangle(p222, p321, p312);\n    draw_triangle(p222, p312, p213);\n    draw_triangle(p222, p213, p123);\n    draw_triangle(p222, p123, p132);\n    draw_triangle(p222, p132, p231);\n    \n    set_source_rgba(vec4(0.0, 0.8, 1.0, 0.5));\n    draw_quad(p321, p312, p123 + p400, p132 + p400);\n    draw_quad(p132, p231, p312 + p040, p213 + p040);\n    draw_quad(p123, p213, p321 + p004, p231 + p004);\n\n    set_source_rgba(vec4(1.0, 0.0, 0.8, 0.5));\n    draw_quad(p213, p312, p123 + p400, p321 + p004);\n    draw_quad(p321, p231, p312 + p040, p132 + p400);\n    draw_quad(p132, p123, p231 + p004, p213 + p040);    \n    draw_quad(p312 + p044, p321 + p044, p213 + p040, p231 + p004);\n    draw_quad(p132 + p404, p231 + p404, p123 + p400, p321 + p004);\n    draw_quad(p123 + p440, p213 + p440, p132 + p400, p312 + p040);\n\n    set_source_rgb(vec3(0.0, 0.8, 1.0));\n    /*\n    move_to(tf(p123));\n    line_to(tf(p312 - p400));\n    move_to(tf(p132));\n    line_to(tf(p321 - p400));\n    move_to(tf(p213));\n    line_to(tf(p132 - p040));\n    move_to(tf(p312));\n    line_to(tf(p231 - p040));\n    move_to(tf(p231));\n    line_to(tf(p123 - p004));\n    move_to(tf(p321));\n    line_to(tf(p213 - p004));\n    */\n    move_to(tf(p321));\n    line_to(tf(p132 + p400));\n    move_to(tf(p312));\n    line_to(tf(p123 + p400));\n    move_to(tf(p231));\n    line_to(tf(p312 + p040));\n    move_to(tf(p132));\n    line_to(tf(p213 + p040));\n    move_to(tf(p213));\n    line_to(tf(p321 + p004));\n    move_to(tf(p123));\n    line_to(tf(p231 + p004));\n    \n    stroke();\n    \n    set_source_rgb(vec3(1.0, 0.0, 0.8));\n    circle(tf(p231),A);\n    circle(tf(p321),A);\n    circle(tf(p312),A);\n    circle(tf(p213),A);\n    circle(tf(p123),A);\n    circle(tf(p132),A);\n    fill();\n    \n    move_to(tf(p231));\n    line_to(tf(p321));\n    line_to(tf(p312));\n    line_to(tf(p213));\n    line_to(tf(p123));\n    line_to(tf(p132));\n    line_to(tf(p231));\n    stroke();\n    #endif\n    \n    }}}\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init(fragCoord, iMouse.xy, iResolution.xy);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [], "common_code": "// 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n// after Cairo API, with anti-aliasing\n// by Leonard Ritter (@paniq)\n// v0.11\n\n// I release this into the public domain.\n// some estimators have been lifted from other shaders and are not\n// necessarily PD licensed, note the links in the source code comments below.\n\n// 2019-06-06: 0.12\n// * split implementation and demo into common and image tab\n\n// 2017-10-05: 0.11\n// * anti-aliasing is gamma-correct\n\n// 2017-10-01: 0.10\n// * added experimental letter() function\n\n// 2017-09-30: 0.9\n// * save() is now a declarative macro\n\n// 2017-09-11: 0.8\n// * added ellipse()\n\n// 2017-09-10: 0.7\n// * paths painted with line_to/curve_to can be filled.\n\n// 2017-09-09: 0.6\n// * added rounded_rectangle()\n// * added set_source_linear_gradient()\n// * added set_source_radial_gradient()\n// * added set_source_blend_mode()\n// * added support for non-uniform scaling\n\n// undefine if you are running on glslsandbox.com\n// #define GLSLSANDBOX\n\n#ifdef GLSLSANDBOX\n#ifdef GL_ES\n#endif\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define iTime time\n#define iResolution resolution\n#define iMouse mouse\n#endif\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// draw a letter with the given texture coordinate\nvoid letter(sampler2D font_texture_source, ivec2 l);\nvoid letter(sampler2D font_texture_source, int lx, int ly);\n    \n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n#define save(name) Context name = _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord, vec2 mouse, vec2 resolution) {\n\taspect = vec2(resolution.x / resolution.y, 1.0);\n\tScreenH = min(resolution.x,resolution.y);\n\tAA = ScreenH*0.4;\n\tAAINV = 1.0 / AA;\n    \n    uv = fragCoord.xy / resolution;\n    vec2 m = mouse / resolution;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(sqrt(_color), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    //c.rgb *= c.rgb;\n    c *= c;\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid letter(sampler2D font_texture_source, ivec2 l) {\n  vec2 p = vec2(l);\n  vec3 tx;\n  vec2 ip;\n  float d;\n  int ic;\n  ip = vec2(l);\n  p += clamp(_stack.position.xy, 0.0, 1.0);\n  ic = 0x21 + int (mod (16. + ip.x + 2. * ip.y, 94.));\n  tx = texture (font_texture_source, mod ((vec2 (mod (float (ic), 16.),\n     15. - floor (float (ic) / 16.)) + fract (p)) * (1. / 16.), 1.)).gba - 0.5;\n  d = tx.b + 1. / 256.;\n  add_field(d / min_uniform_scale());\n}\n\nvoid letter(sampler2D font_texture_source, int lx, int ly) {\n    letter(font_texture_source, ivec2(lx,ly));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ttGzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 136, 136, 213], [215, 215, 232, 232, 952], [954, 954, 979, 979, 1040], [1042, 1042, 1089, 1089, 1347], [1349, 1349, 1401, 1401, 1465], [1468, 1468, 1482, 1482, 5888], [5950, 5950, 6007, 6007, 6093]], "test": "untested"}
{"id": "st3GzS", "name": "Raymarching with color!", "author": "RayWorld", "description": "My first shader. I'm learning the ropes of C++ and webgl, as I'm used to javascript.", "tags": ["raymarching", "stuff"], "likes": 2, "viewed": 101, "published": 3, "date": "1636331523", "time_retrieved": "2024-07-30T18:49:40.938440", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define HIT_DIST 0.01 \n#define rot2(a)      mat2(cos(a),-sin(a),sin(a),cos(a)) // V.xy *= rot2(a.z)\n\nvec3 bezierPos(vec3 anchor1, vec3 handle1, vec3 handle2, vec3 anchor2, float t) {\n    vec3 point = anchor1 * (-pow(t,3.)+3.*pow(t,2.)-3.*t+1.);\n    point += handle1 * (3.*pow(t,3.)-6.*pow(t,2.)+3.* t);\n    point += handle2 * (-3.*pow(t,3.)+3.*pow(t,2.));\n    point += anchor2 * (pow(t,3.));\n    return point;\n}\n\nvec3 getCameraPos() {\n    float pathProgress = float(iFrame)/float(120);\n    int bezierID = int(mod(pathProgress,3.0));\n    float bezierProgress = mod(pathProgress,1.0);\n    vec3 position = vec3(0.,1.,0.);\n    switch (bezierID) {\n        case 0:\n        position = bezierPos(vec3(0.,1.,0.),vec3(-0.5,1.,-1.),vec3(-1.,1.,-5.2),vec3(1.,1.,-5.),bezierProgress);\n        break;\n        case 1: \n        position = bezierPos(vec3(1.,1.,-5.),vec3(3.,1,-5.),vec3(6.,1.,-2.5),vec3(6.,1.,0.),bezierProgress);\n        break;\n        case 2:\n        position = bezierPos(vec3(6.,1.,0.),vec3(6.,1.,1.),vec3(0.5,1.,1.),vec3(0.,1.,0.),bezierProgress);\n        break;\n    }\n    return position;\n}\n\nfloat sphereSDF(vec3 pos,float radius) {\n    return length(pos) - radius;\n}\n\nfloat cubeSDF(vec3 pos, vec3 scale) {\n    vec3 offset = abs(pos) - scale;\n    float unsignedDist = length(max(offset,0.));\n    float signedDist = max(max(min(offset, 0.).x,min(offset, 0.).y),min(offset, 0.).z);\n    return signedDist + unsignedDist;\n}\n\nfloat torusSDF(vec3 pos, vec2 radii) {\n    return length( vec2(length(pos.xz)-radii.x,pos.y) )-radii.y;\n}\n\nvec3 rotateYZ(vec3 vector, float angle) {\n    vector.zy *= rot2(angle);\n    return vector;\n}\n\nvec3 rotateXZ(vec3 vector, float angle) {\n    vector.zx *= rot2(angle);\n    return vector;\n}\n\nvec3 rotateXY(vec3 vector, float angle) {\n    vector.yx *= rot2(angle);\n    return vector;\n}\n\nfloat boolOperation(float subjectDist, float actorDist, int operation) {\n    float returnValue = subjectDist;\n    switch (operation) {\n        case 0:\n        //Union\n        returnValue = min(subjectDist,actorDist);\n        break;\n        case 1:\n        //Difference\n        returnValue = max(subjectDist, -actorDist);\n        break;\n        case 2:\n        //Intersect\n        returnValue = max(subjectDist,actorDist);\n        break;\n    }\n    return returnValue;\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smoothBoolOperation(float subjectDist, float actorDist, int operation,float k) {\n    float returnValue = subjectDist;\n    switch (operation) {\n        case 0:\n        //Union\n        returnValue = smin(subjectDist, actorDist, k);\n        break;\n        case 1:\n        //Difference\n        returnValue = smin(-subjectDist, actorDist, k);\n        break;\n        case 2:\n        //Intersect\n        returnValue = smin(-subjectDist, -actorDist, k);\n        break;\n    }\n    return returnValue;\n}\n\nvec4 getDist(vec3 center) {\n    vec4 minDist = vec4(0.5,0.5,1.,101.);\n    vec4 plane = vec4(0.25, 1.0, 0.3, center.y);\n    vec4[] objects = vec4[](\n        vec4(0.25,0.5,1.0,mix(cubeSDF(center - vec3(0.0,2.0,7.0),vec3(0.5,1.5,0.5)),sphereSDF(center-vec3(0.0,2.0,7.0),1.0),0.5+0.5*sin(iTime))),\n        vec4((1.+cos(iTime))/2.,(1.+cos(iTime+radians(120.)))/2.,1.0,torusSDF(center - vec3(3,0.5,7),vec2(1,0.5)))\n    );\n    if (minDist.w > plane.w) minDist = plane;\n    int objectCount = objects.length();\n    for (int i = 0; i < objectCount; i++) {\n        if (minDist.w > objects[i].w) minDist = objects[i];\n    }\n    return minDist;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.0;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = getDist(p).w;\n        dO += dS;\n        if(dO>MAX_DIST || dS<HIT_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 getNormal(vec3 p) {\n\tfloat d = getDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy).w,\n        getDist(p-e.yxy).w,\n        getDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nfloat getLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 1);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = getNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = rayMarch(p+n*HIT_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\nvec3 colorFromScene(vec3 rayOrigin, vec3 rayDirection, vec3 lightDir) {\n    vec3 returnValue = vec3(0.5,0.5,1);\n    //march to scene\n    float sceneDist = rayMarch(rayOrigin, rayDirection);\n    vec3 landingPosition = rayOrigin + rayDirection * (sceneDist - 0.1);\n    vec4 colorContender = getDist(rayOrigin + rayDirection * sceneDist);\n    if (colorContender.w < HIT_DIST) {\n        // if hit march towards light\n        float dif = getLight(landingPosition);\n        returnValue = colorContender.xyz * dif;\n        \n    }    \n    return returnValue;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 cameraPosition = getCameraPos();\n    vec2 rotations = vec2(0.,0.);\n    float theta = rotations.x;\n    float phi = rotations.y;\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    vec3 rayDir = normalize(vec3(uv.xy,1));\n    rayDir.zy *= rot2(phi);\n    rayDir.zx *= rot2(theta);\n    vec3 col = colorFromScene(cameraPosition, rayDir, vec3(1,0,0));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st3GzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 226, 226, 455], [457, 457, 478, 478, 1138], [1140, 1140, 1180, 1180, 1215], [1217, 1217, 1254, 1254, 1467], [1469, 1469, 1507, 1507, 1574], [1576, 1576, 1617, 1617, 1668], [1670, 1670, 1711, 1711, 1762], [1764, 1764, 1805, 1805, 1856], [1858, 1858, 1930, 1930, 2326], [2328, 2328, 2369, 2369, 2460], [2462, 2462, 2548, 2548, 2960], [3597, 3597, 3631, 3631, 3834], [3836, 3836, 3860, 3860, 4058], [4060, 4060, 4084, 4084, 4336], [4338, 4338, 4409, 4409, 4890], [4891, 4891, 4948, 4948, 5351]], "test": "untested"}
{"id": "sld3zB", "name": "depth of field focus study", "author": "morisil", "description": "Testing something out", "tags": ["chromaticaberration", "study", "depthoffield", "focus"], "likes": 12, "viewed": 362, "published": 3, "date": "1636329173", "time_retrieved": "2024-07-30T18:49:41.919816", "image_code": "const float SHAPE_SIZE = .5;\nconst float CHROMATIC_ABBERATION = .02;\n\nfloat getColorComponent(in vec2 st, in float modScale) {\n    vec2 modSt = mod(st, 1. / modScale) * modScale * 2. - 1.;\n    float dist = length(modSt);\n    float blur = .2 * (sin(iTime * 3.) + 1.1);\n    float shapeMap = smoothstep(SHAPE_SIZE + blur, SHAPE_SIZE - blur, dist);\n    return shapeMap;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st =\n        (2.* fragCoord - iResolution.xy)\n        / min(iResolution.x, iResolution.y);\n\n    float modScale = (sin(iTime) + 1.) * 2.;\n\n    vec3 color = vec3(\n        getColorComponent(st - st * CHROMATIC_ABBERATION, modScale),\n        getColorComponent(st, modScale),\n        getColorComponent(st + st * CHROMATIC_ABBERATION, modScale)        \n    );\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sld3zB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 126, 126, 367], [369, 369, 424, 424, 823]], "test": "untested"}
{"id": "sttGzB", "name": "3D voronoi cells", "author": "Remming_Senegal", "description": "3D voronoi cells, derived off of a lot of voronoi functions I found from the site.", "tags": ["voronoi"], "likes": 4, "viewed": 310, "published": 3, "date": "1636324369", "time_retrieved": "2024-07-30T18:49:42.730648", "image_code": "vec3 Rand3D( vec3 pos ) // Less resource demanding to use the blue noise texture\n{\n\treturn textureLod( iChannel0, (pos.xy+pos.z)/256.0, 0.0 ).rgb;\n}\n\nvoid voronoi3D( in vec3 p, out vec3 coord, out float distToBorder, out float color)\n{\n    vec3 n = floor(p);\n    vec3 f = fract(p);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n    distToBorder = 5.0;\n    for( float x=-1.0; x<=1.0; x++ )\n    for( float y=-1.0; y<=1.0; y++ )\n    for( float z=-1.0; z<=1.0; z++ )\n    {\n        vec3 g = vec3(x,y,z);\n\t\tvec3 o = Rand3D( n + g );\n        vec3 r = g + o - f;\n        float d = length(r);\n\n        if(d<distToBorder)\n        {\n            distToBorder = d;\n            coord = r;\n            color = o.x;\n        } \n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    distToBorder = 8.0;\n    for( float x=-1.0; x<=1.0; x++ )\n    for( float y=-1.0; y<=1.0; y++ )\n    for( float z=-1.0; z<=1.0; z++ )\n    {\n        vec3 g = vec3(x,y,z);\n\t\tvec3 o = Rand3D( n + g );\n        vec3 r = g + o - f;\n        vec3 normal = coord - r;\n       \n        if( dot(normal,normal)>0.001 ) {\n            float j = dot( 0.5*(coord+r), normalize(r-coord));\n            distToBorder = min( distToBorder, j );\n        }\n    }\n\n    // coord is like the local coordinate of the voronoi\n    // Adding p turns it into a universal coordinate\n    // That's a poor way of explaining it, so comment the line to see what I mean\n    coord += p;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = (uv * 2.0 - 1.0)/2.0;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 7.0;\n    \n    //the 3D model\n    vec3 xyz = vec3(uv,iTime);\n    vec3 coord;\n    float distToBorder;\n    float color;\n    voronoi3D(xyz,coord,distToBorder,color);\n    \n    // The other outputs the 3D voronoi function returns\n    //vec3 col = coord;\n    //vec3 col = vec3(color);\n    vec3 col = vec3(distToBorder);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sttGzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 82, 82, 148], [150, 150, 235, 235, 1562], [1564, 1564, 1621, 1671, 2168]], "test": "untested"}
{"id": "stdGRB", "name": "fork another basic face", "author": "jorge2017a2", "description": "fork another basic face\nhttps://www.shadertoy.com/view/st3GRB", "tags": ["forkanotherbasicface"], "likes": 2, "viewed": 196, "published": 3, "date": "1636319669", "time_retrieved": "2024-07-30T18:49:43.944403", "image_code": "//fork https://www.shadertoy.com/view/st3GRB\n///-------------image\n//another basic face--6-nov-2021\n//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdTorus( vec3 p, vec2 t )\n\t{ vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{   float k0 = length(p/r);   float k1 = length(p/(r*r));  return k0*(k0-1.0)/k1;}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec2 opRep2D( in vec2 p, in vec2 c )\n\t{ vec2 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3 opRep3D( in vec3 p, in vec3 c )\n\t{ vec3 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3  opRep(vec3 p, vec3 r)\n   { return mod(p,r)-0.5*r; }\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\nfloat pelo(vec3 p)\n{\n   vec3 res= vec3(9999.0, -1.0,-1.0);\n   \n   vec2 uv=p.xy*0.5;\n   float py=2.0*sin(uv.y*fract(iTime*0.25));\n   uv.y+=1.5+py;\n   vec3 col;\n   float r;\n //hair\n    r = 0.035 + 0.5*cos( -atan(uv.y,uv.x)*5.0 + 10.0*uv.x+py + 13. +uv.y)*1.0;\n    float dbx1= sdCylinderXY(p-vec3(0.0,1.0,0.0), vec2(5.0,5.0) );\n    float dif=intersectSDF(dbx1, r);\n    \n    return dif;\n}    \n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n   \n   p.y=p.y-10.0;\n    vec3 pOrg=p;\n    \n    float dCabeza= sdEllipsoid( p-vec3(0.0,0.0,2.0), vec3(7.0,8.0,3.5));\n    float dFrente= sdEllipsoid( p-vec3(0.0,2.5,0.25), vec3(5.5,3.0,2.0));\n    float dPomulo= sdEllipsoid( p-vec3(0.0,-1.5,0.0), vec3(6.0,5.0,2.0));\n    \n    \n    vec3 PosNariz=p-vec3(0.0,-1.0,0.0);\n    //nariz\n    vec3 aA=vec3(0.0,0.0,0.0);\n    vec3 bA=vec3(0.0,3.0,0.0);\n    float rA1=0.5;\n    float rA2=0.25;\n    vec3 p0= rotate_x( PosNariz, radians(-23.0));\n    float dNariz1= sdRoundCone(p0-vec3(0.0,-2.0,-2.0), aA, bA, rA1, rA2);\n    \n    \n    vec3 aB=vec3(0.0,0.0,0.0);\n    vec3 bB=vec3(0.0,1.5,0.0);\n    float rB1=0.7;\n    float rB2=0.15;\n    float dNariz2= sdRoundCone(p0-vec3(0.0,-2.0,-2.0), aB, bB, rB1, rB2);\n    \n    //dif nariz\n    vec3 p0a= rotate_x( PosNariz-vec3(0.0,-1.2,-3.25), radians(55.0));\n    float difNarizBox= sdBox( p0a, vec3(1.0,2.0,0.5) );\n    \n    //diferncia de nariz\n    dNariz1=differenceSDF(dNariz1 ,difNarizBox);\n    dNariz2=differenceSDF(dNariz2 ,difNarizBox);\n    \n    ///Union de cabeza\n    dCabeza=opSmoothUnion(dCabeza,dFrente,0.5);\n    dCabeza=opSmoothUnion(dCabeza,dPomulo,0.125);\n    dCabeza=opSmoothUnion(dCabeza,dNariz1,0.5);\n    dCabeza=opSmoothUnion(dCabeza,dNariz2,0.5);\n     p.x = abs(p.x)-2.5; \n     \n    vec3 p1= p-vec3(0.3,-1.8,0.0);\n    float dhoyoDif=sdBox( p1, vec3(3.5,1.5,2.0) );\n     \n    float dOjo= sdEllipsoid( p, vec3(2.5,2.2,1.8)); \n    float dhoyoOjo= sdEllipsoid( p, vec3(3.,2.5,2.0));\n    \n    dhoyoOjo= differenceSDF( dhoyoOjo,dhoyoDif);\n    dOjo= differenceSDF( dOjo,dhoyoDif);\n    float dOjoOr=dOjo;\n    dCabeza=opSmoothSubtraction(dhoyoOjo,dCabeza, 0.5 );\n    \n    //MOstrar OJo y Cabeza\n    res =opU3(res, vec3(dCabeza,30,-1.0));\n    res =opU3(res, vec3(dOjo,1.0,-1.0));\n    \n    ///pupila Ojo\n    //vec3 posMov=vec3(1.0*sin(iTime), 0.8*cos(iTime*2.0),0.0);\n    vec3 posMov=vec3(0.5*sin(iTime), 0.8*sin(iTime*2.0),0.0);\n    vec3 posPupilaIris=vec3(0.0+posMov.x,0.5+posMov.y,0.0);\n    float dPupila= sdCylinderXY(p-posPupilaIris, vec2(0.25,3.2));  //ch\n    float dIris= sdCylinderXY( p-posPupilaIris, vec2(0.8,3.0)  );  //Gr\n    dPupila= intersectSDF( dPupila,dOjoOr);\n    dIris= intersectSDF( dIris,dOjoOr);\n    res =opU3(res, vec3(dIris,33.0,-1.0));\n    res =opU3(res, vec3(dPupila,0.0,-1.0));\n    \n    // oreja\n    vec3 pOreja=pOrg-vec3(0.0,0.0,1.25);\n    pOreja.x=abs(pOreja.x)-6.0;\n    float OrejaA= sdEllipsoid( pOreja-vec3(0.0,0.0,0.0), vec3(2.0,2.0,1.5));\n    float OrejaB= sdEllipsoid( pOreja-vec3(0.0,0.0,-1.0), vec3(1.0,1.2,1.5));\n    OrejaA= differenceSDF(OrejaA, OrejaB);\n    res =opU3(res, vec3(OrejaA,30.0,-1.0));\n    \n    //labios\n    float dLabioA= sdEllipsoid( pOrg-vec3(0.0,-3.5,-1.1), vec3(2.0,0.5,1.0));\n    float dLabioB= sdEllipsoid( pOrg-vec3(0.0,-4.0,-1.0), vec3(2.0,0.5,1.0));\n    res =opU3(res, vec3(dLabioA,2.0,-1.0));\n    res =opU3(res, vec3(dLabioB,2.0,-1.0));\n    \n    //cejas\n    vec3 posCejas=pOrg.yzx-vec3(1.2,-1.5,0.0);\n    posCejas.z= abs(posCejas.z)-2.5;\n    float dcejasA=sdTorus(posCejas, vec2(2.2,0.3) );\n    vec3 posCejasBx=pOrg-vec3(0.0,0.5,0.0);\n    posCejasBx.x=abs(posCejasBx.x)-2.5;\n    float dCejasDif=sdBox(posCejasBx, vec3(3.5,1.8,2.5) );\n    dcejasA= differenceSDF(dcejasA, dCejasDif);\n    res =opU3(res, vec3(dcejasA,0.0,-1.0));\n    \n    \n    //pelo\n    float dpelo= pelo( p-vec3(0.0,3.5,4.5));\n    res =opU3(res, vec3(dpelo,0.0,-1.0));\n    \n    \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float dis) \n{   vec3 l = normalize(lp - p);\n    vec3 ldir = normalize(p-rd);    \n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    //float diff=max(0.,dot(ldir,-n));\n    float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true) {fshadow=GetShadow(p,lp);}\n    else {fshadow=0.5;}\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n    lin *= atten*0.5*col*fshadow;\n    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    lin = pow(lin,vec3(0.4545));\n \n    return lin;\n    //return lin*atten*(1.0/2.0);\n    \n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float dis)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro,  colobj,dis);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    return colobj;\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d);\n   \n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3( 10.0, 10.0, -20.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 10.0, -10.0 ); light_color2 =vec3( 1.0 ); \n   vec3 ro=vec3(0.0,11.0,-18.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    col = linear2srgb(col);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------common\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9), //32\nvec3(0.2, 0.05, 0.), //33 cafe\nvec3(0.5, 0.25, 0.1) //34 cafe\n//vec3(0.5, 0.15, 0.2), //33 piel\n\n);\n\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdGRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[580, 580, 612, 612, 696], [697, 697, 731, 731, 793], [794, 794, 833, 833, 928], [930, 930, 967, 967, 1048], [1050, 1050, 1075, 1075, 1094], [1095, 1095, 1158, 1222, 1809], [1811, 1855, 1902, 1902, 1929], [1930, 1930, 1973, 1973, 2000], [2001, 2001, 2049, 2049, 2077], [2078, 2116, 2152, 2152, 2197], [2198, 2198, 2237, 2237, 2281], [2282, 2282, 2321, 2321, 2365], [2366, 2366, 2398, 2398, 2423], [2424, 2489, 2523, 2523, 2619], [2620, 2620, 2654, 2654, 2745], [2746, 2746, 2780, 2780, 2871], [2874, 2874, 2926, 2926, 3025], [3027, 3027, 3085, 3085, 3185], [3187, 3187, 3246, 3246, 3345], [3347, 3387, 3421, 3421, 3516], [3519, 3519, 3539, 3539, 3903], [3909, 3949, 3974, 3974, 7463], [7465, 7465, 7489, 7489, 7651], [7653, 7653, 7702, 7702, 8369], [8371, 8371, 8407, 8407, 8652], [8654, 8654, 8681, 8681, 8698], [8700, 8700, 8736, 8736, 8828], [8829, 8829, 8875, 8875, 9000], [9002, 9002, 9087, 9087, 10540], [10542, 10542, 10633, 10633, 10761], [10763, 10763, 10795, 10795, 10992], [10994, 10994, 11087, 11087, 11248], [11250, 11250, 11281, 11281, 11880], [11882, 11882, 11908, 11908, 12018], [12020, 12020, 12078, 12078, 12130], [12132, 12181, 12238, 12238, 12769]], "test": "untested"}
{"id": "sttGRB", "name": "Log Polar Zoom", "author": "mla", "description": "Since log polar transforms are trending, here's a nice zoom into a randomized hexagon grid pattern.\n\n'x' show untransformed pattern.\n's' for 'Shane' colouring\nmouse x coord sets hash seed", "tags": ["logpolar", "complexlog"], "likes": 10, "viewed": 341, "published": 3, "date": "1636317736", "time_retrieved": "2024-07-30T18:49:44.891869", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Log polar zoom\n// \n// Matthew Arcus, mla, 2021\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// M maps a square grid to a grid of equilateral triangles\nconst mat2 M = mat2(1,0,0.5,0.5*sqrt(3.0));\nconst mat2 Minv = inverse(M);\n\nint N = 8; // Number of logpolar subdivisions\n\nvec2 hash(ivec2 index) {\n  int x = 2*index.x+index.y;\n  int y = (index.y+N)%(2*N);\n  uint h = uint(x+2048*y);\n  h ^= uint(iMouse.x);\n  h = ihash(h);\n  vec2 res = vec2(h>>16,h&0xffffU);\n  return res/pow(2.0,16.0);\n}\n\nvec3 draw(vec3 col, vec2 z, vec4 p, float px) {\n  z -= p.zw;\n  float h = p.x;\n  float h2 = p.y;\n  //if (h < clamp(0.0,1.0,0.4+0.6*cos(0.25*iTime))) return col;\n  float r = 0.5;\n  r *= h2;\n  vec2 centre = vec2(r,0);\n  //centre = rotate(centre,iMouse.y/iResolution.y*2.0*PI);\n  centre = rotate(centre,h);\n  z -= centre;\n  float k = sqrt(3.0)/2.0-r;\n  float d = length(z)-k;\n  // IQ's palette - idea from Shane\n  vec3 hue = 0.5+0.5*cos(6.2831*h2 + vec3(0, 2, 2));\n  hue = sqrt(hue);\n  if (key(CHAR_S)) {\n    // Shane's colour suggestion\n    hue *= 1. - .6*smoothstep(0., k, dot(z, z));\n    // Subtle, fake AO.\n    col = mix(col, vec3(0), (1. - smoothstep(-px*15., px*15., d))*.5);\n    // Stroke.\n    col = mix(hue/16., col, smoothstep(-px, px, d));\n    // Color overlay.\n    col = mix(hue,col,smoothstep(-px, px, d + px*3.*iResolution.y/450.));\n    return col;\n  } else {\n   //hue = h2rgb(h2);\n   hue *= 1.0-0.8*smoothstep(0.0,k,length(z));\n   col = mix(hue,col,smoothstep(-px,px,d));\n   return col;\n  }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  fragColor = vec4(0);\n  // Get normalized screen coordinate\n  vec2 z = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  //if (!key(CHAR_X)) z = vec2(log(length(z)),atan(z.y,z.x));\n  //if (!key(CHAR_X)) z = 2.0*(3.0*catanh(z) - 2.0*catanh(cmul(vec2(cos(0.1*iTime),sin(0.1*iTime)), z)));\n  if (!key(CHAR_X)) z = clog(z)/PI; //z = 2.0*catanh(z);\n  else {\n    z *= 1.1;\n    if (abs(z.y) > 1.0) return;\n  }\n  //z.y = mod(z.y,2.0);\n  z.x -= 0.2*iTime;\n\n  z *= 0.5*sqrt(3.0);\n  z *= float(N);\n\n  vec2 z1 = Minv*z; // Convert to square grid\n\n  // Find corner vertices of containing triangle\n  vec2 index0 = floor(z1); // Remember cell in grid\n  vec2 index1 = index0+vec2(1,0);\n  vec2 index2 = index0+vec2(0,1);\n  z1 -= index0;\n  if (dot(z1,vec2(1,1)) > 1.0) index0 += vec2(1,1);\n\n  // Hash corner vertices\n  vec2 h0 = hash(ivec2(index0));\n  vec2 h1 = hash(ivec2(index1));\n  vec2 h2 = hash(ivec2(index2));\n\n  // Combine with real coordinates of vertices\n  vec4 p0 = vec4(h0,M*index0);\n  vec4 p1 = vec4(h1,M*index1);\n  vec4 p2 = vec4(h2,M*index2);\n\n  // And sort by hash\n  if (p0.x < p1.x) { vec4 t = p0; p0 = p1; p1 = t; }\n  if (p1.x < p2.x) { vec4 t = p1; p1 = p2; p2 = t; }\n  if (p0.x < p1.x) { vec4 t = p0; p0 = p1; p1 = t; }\n\n  // Get pixel width, z.y is discontinuous, so don't use that\n  float px = 0.5*fwidth(z.x);\n  vec3 col = vec3(0);\n  // Finally, combine drawing from each vertex\n  col = draw(col,z,p0,px);\n  col = draw(col,z,p1,px);\n  col = draw(col,z,p2,px);\n\n  col = pow(col,vec3(0.4545));\n  if (alert) col.x = 1.0;\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float PI = 3.14159;\n\nbool alert = false;\nvoid assert(bool x) {\n  if (!x) alert = true;\n}\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(t) + vec2(p.y, -p.x) * sin(t);\n}\n\nint idiv(int a,int b) {\n  int d;\n  // eg.\n  // -1/3 => -((1+2)/3) = -1\n  // -3/3 => -((3+2)/3) = -1\n  // -4/3 => -((4+2)/3) = -2\n  if (a < 0) d = -((-a+b-1)/b); // Careful with bracket here!\n  else d = a/b;\n  //assert(a-d*b >= 0);\n  //assert(a-d*b < b);\n  return d;\n}\n\nint imod(int a, int b) {\n  int d = idiv(a,b);\n  return a-d*b;\n}\n\n// Macros for use in \"common\" blocks.\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_F = 70;\nconst int CHAR_I = 73;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n  return sqrt(rgb);\n}\n\n// Complex functions\nvec2 cmul(vec2 z, vec2 w) {\n  //return vec2 (z.x*w.x-z.y*w.y, z.x*w.y+z.y*w.x);\n  return mat2(z,-z.y,z.x)*w;\n}\n\nvec2 cinv(vec2 z) {\n  float t = dot(z,z);\n  return vec2(z.x,-z.y)/t;\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n  return cmul(z,cinv(w));\n}\n\nvec2 clog(vec2 z) {\n  float r = length(z);\n  return vec2(log(r),atan(z.y,z.x));\n}\n\n// Inverse hyperbolic tangent \nvec2 catanh(vec2 z) {\n  return 0.5*clog(cdiv(vec2(1,0)+z,vec2(1,0)-z));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sttGRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[400, 400, 424, 424, 614], [616, 616, 663, 663, 1618], [1620, 1620, 1677, 1677, 3227]], "test": "untested"}
{"id": "fldGRS", "name": "Image Tracking I", "author": "oneshade", "description": "First attempt at locating feature points, no actual extraction though. Eventually, I want to be able to track rotation to get accelerometer-like information.", "tags": ["gradient", "image", "iterative", "tracking", "newton", "hessian", "extrema"], "likes": 34, "viewed": 1333, "published": 3, "date": "1636315472", "time_retrieved": "2024-07-30T18:49:45.781491", "image_code": "#define video(x, y) texture(iChannel0, vec2(x, y)).r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 1.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    // 2D Newton-Raphson optimization on gaussian blurred video\n    // Each step fits a paraboloid to the image function around\n    // p then steps to the extremum of that paraboloid\n    vec2 p = fragCoord / iResolution.xy;//vec2(0.5);\n    vec2 h = 1.0 / iResolution.xy;\n    for (int i=0; i < 10; i++) {\n        float up = video(p.x, p.y + h.y);\n        float right = video(p.x + h.x, p.y);\n        vec2 grad = vec2(right, up) - video(p.x, p.y);\n\n        float dxx = (video(p.x + 2.0 * h.x, p.y) - right - grad.x) / (h.x * h.x);\n        float dxy = (video(p.x + h.x, p.y + h.y) - right - grad.y) / (h.x * h.y);\n        float dyy = (video(p.x, p.y + 2.0 * h.y) - up    - grad.y) / (h.y * h.y);\n\n        grad /= h;\n        mat2 hessian = mat2(dxx, dxy, dxy, dyy);\n\n        p -= inverse(hessian) * grad;\n    }\n\n    color = texture(iChannel0, fragCoord / iResolution.xy).rrr;\n\n    p -= 0.5;\n    p.x *= iResolution.x / iResolution.y;\n    color = mix(color, vec3(1.0), smoothstep(unit, 0.0, length(uv - p) - 0.01));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define WIN_W 40.0\n#define WIN_H 40.0\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    float total = 0.0;\n    for (float x=-WIN_W; x < WIN_W; x++) {\n        float weight = 0.1 * exp(-0.005 * x * x);\n        fragColor += vec4(texture(iChannel0, (fragCoord + vec2(x, 0.0)) / iResolution.xy).rgb * weight, weight);\n    }\n\n    fragColor.rgb /= fragColor.w;\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define WIN_W 40.0\n#define WIN_H 40.0\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    float total = 0.0;\n    for (float y=-WIN_H; y < WIN_H; y++) {\n        float weight = 0.1 * exp(-0.005 * y * y);\n        fragColor += vec4(texture(iChannel0, (fragCoord + vec2(0.0, y)) / iResolution.xy).rgb * weight, weight);\n    }\n\n    fragColor.rgb /= fragColor.w;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fldGRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 108, 108, 1288]], "test": "untested"}
{"id": "fldGRB", "name": "Complex Atanh Revisited", "author": "mla", "description": "More fun with atanh - inspired to have another look at this after seeing byt3_m3chanic's excellent log polar shaders.\n\nMouse changes rotation parameters.", "tags": ["domain", "complex", "mapping", "atanh"], "likes": 28, "viewed": 474, "published": 3, "date": "1636308775", "time_retrieved": "2024-07-30T18:49:46.548440", "image_code": "////////////////////////////////////////////////////////////////////////////////\n// Complex Inverse Hyperbolic Tangent\n//\n// Domain mapping of sums of complex atanh.\n// Care needed for alignment across branch cuts.\n//\n// Key controls:\n// 'r': rotate 90°\n// 'a': use acosh\n// 'c': checkerboard\n// 'm': monochrome\n// 'o': circles\n// 'p': z -> z^5\n// 'i': z -> z+1/z\n//\n////////////////////////////////////////////////////////////////////////////////\n\nfloat A = 11.0, B = 10.0; // Rotation angle is atan(B,A)\nfloat scale = 1.5;\nfloat PI = 3.14159;\n\nvec3 getcolor(float h) {\n if (!key(CHAR_M)) return mono(h);\n vec3 hue = 0.5+0.5*cos(2.0*PI*h + vec3(0, 2, 2));\n hue = sqrt(hue);\n return hue;\n return 0.2+0.8*h2rgb(h);\n}\n\nvec2 f(vec2 z) {\n  if (key(CHAR_A)) return cacosh(z);\n  return catanh(-0.5*z) + catanh(cmul(expi(0.1*iTime), z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  if (iMouse.x > 0.0) {\n    // Get angle from mouse position\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    m *= 40.0;\n    A = floor(m.x), B = floor(m.y);\n  }\n  vec2 rot = vec2(A,B);\n  vec2 z = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  if (key(CHAR_R)) z = z.yx;\n  z *= scale;\n  if (!key(CHAR_P)) z = cpow(z,5.0);//min(1.0+floor(iTime),5.0));\n  // catanh is liable to add random multiples of PI\n  // to the y output. This being so, our coloring function must\n  // return the same color for all such multiples, ie. it must\n  // be periodic with period PI\n  if (!key(CHAR_I)) z += cinv(z); // z += 1/z\n  z = f(z);\n  z /= PI; // Required period is now 1\n  float px = 0.75*fwidth(z.x); // z.x is continuous, unlike z.y\n  z.y += 0.02*iTime;\n  //z.y = mod(z.y,1.0); // Check periodicity - this should have no effect!\n  z = cmul(rot,z); // rotate z\n  px *= length(rot); // and scale pixel width\n  vec2 index = round(z); // Nearest grid point\n  z -= index; // Reduce to [-0.5,+0.5]\n  float hx = fract(index.x/(B==0.0 ? 1.0 : B)); // Color for column\n  float hy = fract(index.y/(A==0.0 ? 1.0 : A)); // Color for row\n  float d = key(CHAR_O) ? length(z) // Circle\n            : max(abs(z.x),abs(z.y)); // Square\n  vec3 colx = getcolor(hx);\n  vec3 coly = getcolor(hy+0.25);\n  vec3 col = vec3(0);\n  if (!key(CHAR_C)) {\n    float k = z.x*z.y;\n    col = mix(colx,coly, smoothstep(-px,px,sign(k)*min(abs(z.x),abs(z.y)))); // Checkerboard\n  } else {\n    col = mix(coly,colx, smoothstep(-px,px,d-0.3)); // Concentric\n  }\n  col *= 1.0-smoothstep(-px,px,d-0.5);\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Complex functions\nvec2 cmul(vec2 z, vec2 w) {\n  //return vec2 (z.x*w.x-z.y*w.y, z.x*w.y+z.y*w.x);\n  return mat2(z,-z.y,z.x)*w;\n}\n\nvec2 cinv(vec2 z) {\n  float t = dot(z,z);\n  return vec2(z.x,-z.y)/t;\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n  return cmul(z,cinv(w));\n}\n\nvec2 clog(vec2 z) {\n  float r = length(z);\n  return vec2(log(r),atan(z.y,z.x));\n}\n\nvec2 expi(float t) {\n  // If cos and sin were perfect we wouldn't need normalize\n return normalize(vec2(cos(t),sin(t)));\n}\n\nvec2 cexp(vec2 z) {\n  return exp(z.x)*expi(z.y);\n}\n\nvec2 cpow(vec2 z, float x) {\n  return cexp(x*clog(z));\n}\n\nvec2 csqrt(vec2 z) {\n  return cpow(z,0.5);\n}\n\n// Inverse hyperbolic tangent \nvec2 catanh(vec2 z) {\n  return 0.5*clog(cdiv(vec2(1,0)+z,vec2(1,0)-z));\n}\n\nvec2 cacosh(vec2 z) {\n  return clog(z+cmul(csqrt(z+vec2(1,0)),csqrt(z-vec2(1,0))));\n}\n\nvec3 mono(float h) {\n  return fract(h)*vec3(1,0.8,0.8); // The monochrome look\n}\n\n// Iq's hsv function, but just for hue.\nvec3 h2rgb(float h ) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n// Macros for use in \"common\" blocks.\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fldGRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[547, 547, 571, 571, 716], [718, 718, 734, 734, 833], [835, 835, 892, 892, 2516]], "test": "untested"}
{"id": "ftdGRB", "name": "Rotating Gear Grid", "author": "Shane", "description": "Using cheap 2D layering techniques to produce a faux extruded grid consisting of rotating gears.", "tags": ["2d", "grid", "gear", "cog", "layer", "faux"], "likes": 51, "viewed": 751, "published": 3, "date": "1636295818", "time_retrieved": "2024-07-30T18:49:47.591651", "image_code": "/*\n\n    Rotating Gear Grid\n    ------------------    \n    \n    Using cheap 2D layering techniques to produce a faux extruded grid \n    consisting of rotating gears. No raymarching was harmed during the\n    making of this example, as they say. :)\n    \n    I love rotating cog patterns. The basic 2D grid versions are pretty\n    easy to code up, and there are heaps of examples on Shadertoy. Here, \n    I've provided the square and hexagon arrangements -- Both are pretty \n    common.\n\n    Just in case it isn't obvious, the point of this is to cheap out with \n    a few layers in order to give the impression that it's a 3D scene, \n    which it does, providing you don't look into it too much. While we're \n    at it, the code works fine, but I wouldn't pay too much attention to \n    that either. :) By the way, there are a various options below for \n    anyone interested in trying out different looks.\n    \n    A raymarched version is simple enough to produce, and I intend to put \n    one of those up later.    \n\n    Due to the layout, it'd be possible to combine this with a moving \n    Truchet pattern to make something interesting, but I'll leave that as \n    an exercise. :)\n    \n    \n    \n    Similar examples:\n    \n    // Fabrice has examples of almost everything on here. :)\n    gear field - hexagonal tiling 7 - FabriceNeyret2\n    https://www.shadertoy.com/view/lsKSRt\n    \n\n*/\n\n\n// Hexagon grid arrangement.\n#define HEXAGON\n\n// Color scheme: Evening: 0, Sepia: 1, Pink: 2, Dawn: 3, Green: 4.\n#define COLOR 0\n\n// Texture the scene.\n#define TEXTURE\n\n// Use a second style of cog.\n//#define COG2\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n// Hacky global angular position for the cog... I'll tidy this later.\nvec2 gA;\n\n\nfloat cogs(vec2 p, vec2 ip) {\n    \n    // Time: You could just have a simple linear time value, but I thought it'd\n    // be interesting the sinusoidally reverse direction. Hence the following.\n    float tm = iTime/8.;\n    float ftm = floor(tm); // Integer time.\n    float frtm = tm - ftm; // Fractional time.\n    float tDir = mod(ftm, 2.)*2. - 1.; // Reversing direction every second.\n    tm = tDir*(sin(frtm*3.14159)*.5 + .5)*6.2831*2.; // Reversed sinusoidal motion.\n    \n    // Cog radius. \n    float rad = .44;\n    float cir = length(p); // Circle.\n    // Cog distance field.\n    float d = cir - rad;\n    \n    // Reversing the direction on alternate cogs in the grid. How you do it is \n    // up to you... I hacked the hexagon one for sure. I'm pretty sure Fabrice \n    // would have done it in a more elegant way, so I'd refer to his example.\n    #ifdef HEXAGON\n    float dir = mod(ip.x + mod(ip.y*2., 3.), 2.)==0.? -1. : 1.;\n    #else\n    float dir = mod(ip.x + ip.y, 2.)==0.? -1. : 1.;\n    #endif\n  \n    // Adding the teeth via polar coordinates.\n    vec2 q = p; \n    float aNum = 12.; // Teeth number.\n    // Time based movement.\n    q *= rot2(tm*dir - 3.14159/aNum/2.);\n    gA = q; // Hacky global angular position.\n   \n    float a = atan(q.y, q.x);\n    float ia = floor(a/6.2831*aNum);\n    \n    #if 0\n    // A cheap, but effective way to produce teeth using AntoineC's formula, here:\n    // Planetary gears - https://www.shadertoy.com/view/MsGczV\n    // It's a really elegant example, by the way, but I'm using a more expensive \n    // method below. Anyway, the option to use it is here, if you're curious.\n    float teeth = .125/(1.1 + exp(3.*cos(dir*tm - aNum*a)));\n    d = (d - teeth)/1.25;\n    #else\n    \n    a = (ia + .5)/aNum;\n    q *= rot2(-a*6.2831);\n    q.x -= rad;\n\n    // Outer teeth.\n    float teeth = mix(max(abs(q.x) - .12, abs(q.y) - .05), length(q.xy*vec2(.7, 1)) - .12, .35);\n    d = min(d, teeth); // Applying the teeth to the cog object.\n    #endif\n    \n    \n \n  \n    #ifdef COG2\n    // Use a solid center with a thin central ring taken\n    // out for the second cog style.\n    d = max(d, -(abs(cir - .34) - .005));\n    #else\n    // For the other style, chop out some holes to give it\n    // a more cartoonish look.\n    \n    // Six polar dispersed holes.\n    aNum = 6.;\n    vec2 q2 = p;\n    q2 *= rot2(tm*dir - 3.14159/aNum/4.);\n    a = atan(q2.y, q2.x);\n    ia = floor(a/6.2831*aNum);\n    a = (ia + .5)/aNum;\n    q2 *= rot2(-a*6.2831);\n    q2.x -= rad;\n    \n    // The small holes.\n    float innerCir = length(q2 - vec2(-.15, 0)) - .065;\n    //float innerCir = max(abs(cir - .285) - .045, -(abs(q2.y) - .07));\n    d = max(d, -innerCir); // Cutting them out.\n    #endif\n    \n    \n    // Cutting out the central hole.\n    d = max(d, -(cir - .14)); \n \n    \n    return d; // Return the cog distance.\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Aspect correct pixel coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Scene rotation.\n    float tm = mod(iTime/8., 2.);\n    \n    // Lens warping.\n    uv *= sqrt(max(1. - (.5 - dot(uv, uv))*.25, 0.));\n    \n    // Pixel rotation, which equates to a 2D camera rotation.\n    uv *= rot2(-sin(tm*3.14159)*2./8.);\n    \n    // Global zoom scale and smoothing factor.\n    float scl = 4.5;//4.5 + sin(tm*3.14159)*.5;\n    float sf = scl/iResolution.y;\n    \n    // The scaling is slightly different for hexagon grids and square ones.\n    #ifdef HEXAGON\n    vec2 sc = vec2(.8660254, 1);\n    #else\n    vec2 sc = vec2(1);\n    #endif\n    \n    // Scaling and translation.\n    vec2 p = uv*scl - vec2(-sc.x/2., 0) - vec2(sin(tm*3.14159)*sc.x*2., 0);\n    \n    \n    // Distance values for various samples:\n    // Distance, highlight, shadow and extrusion.\n    float d = 1e5, dHi = 1e5, dSh = 1e5, dEx = 1e5;\n    \n    // Saved cog ID.\n    vec2 id;\n    \n    // Light direction.\n    vec2 lgtDir = normalize(vec2(-2, -1));\n    \n    // Fake unit direction ray.\n    vec3 rd = normalize(vec3(uv, 1));\n    \n    // Saved cog position and angular position.\n    vec2 svP, svA;\n    \n    // Background pattern rivot values. This has been hacked in.\n    float bgPat = 1e5, bgPat2 = 1e5;\n    \n    // The cell shapes exceed the cell boundaries, which means covering all \n    // surrounding cells that the shape covers. In this case, there are 4.\n    // By the way, you could get away with two taps, if you really wanted to.\n    // However, the square grid 3D version would require all four.\n    for(int i = 0; i<=1; i++){\n        for(int j = 0; j<=1; j++){\n          \n            // Local cell coordinates and cell ID.\n            vec2 cntr = vec2(i, j) - .5;\n            vec2 q = p;\n            vec2 iq = floor(q/sc - cntr); \n            #ifdef HEXAGON\n            if(mod((iq.x), 2.)<.001) {\n               q.y += sc.y/2.;\n               iq = floor(q/sc - cntr); \n            }\n            #endif\n            q -= (iq + .5)*sc; \n            \n            // Extruded \"q\" position. This is a hacky estimate, but it's\n            // enough to fool the eyes, provided you don't look too hard. :)\n            vec2 qEx = q + rd.xy*.2/(1. + length(uv)*1.5);\n            \n            \n            // Producing distance fields for the rivots and highlights\n            // on the hexagon arrangement... I've hacked it in the middle\n            // of the loop out of sheer laziness, but you could produce\n            // this outside.\n            #ifdef HEXAGON\n            vec2 miq = mod(iq, vec2(2, 3));\n            if((miq.x + miq.y)==0. || (miq.x*miq.y)==1.){\n           \n                vec2 rdd = lgtDir*.01;\n                float hx = length(qEx);\n                float hx2 = length(qEx - rdd);\n                bgPat = min(bgPat, (hx - .1));\n                bgPat2 = min(bgPat2, (hx2 - .1));\n                 \n                // After rendering producing the rivot field,\n                // skip the cog field construction.\n                continue;\n            }\n            #endif\n\n           \n            // Some distance field samples.\n            //\n            // // Top layer.\n            float cg = cogs(q, iq); \n            // Store the closest distance.\n            if(cg<d) { d = cg; id = iq; svP = q; svA = gA; }\n            // Extruded.\n            dEx = min(dEx, cogs(qEx, iq));\n            // Shadow.\n            dSh = min(dSh, cogs(qEx - lgtDir*.135, iq));\n            // Highlight.\n            dHi = min(dHi, cogs(q - lgtDir*.01, iq));            \n             \n            \n         }\n    }\n    \n    \n    // Random number based on the cog ID.\n    float rnd =  hash21(id);\n    \n    // Lit background.\n    vec3 bg = mix(vec3(.6), vec3(.4), clamp(dot(rd.xy, lgtDir), 0., 1.));\n\n    // Changing the background color, depending on the palette.\n    #if COLOR == 0\n    bg *= vec3(.7, .85, 1);\n    #elif COLOR == 1\n    bg *= vec3(.77, .64, .5);\n    bg *= vec3(1.2, 1, .8);\n    #elif COLOR == 2\n    bg *= vec3(.45, .5, .55);\n    #elif COLOR == 3\n    bg *= vec3(1, .85, .7);\n    #endif\n\n\n    #ifdef TEXTURE\n    // Background texture.\n    // The textured plane is technically at the extruded \"p\" position.\n    vec2 pEx = p + rd.xy*.2/(1. + length(uv)*1.5);\n    vec3 tx = texture(iChannel0, (pEx + 2.)/4.).xyz; tx *= tx;\n    tx = smoothstep(-.05, .5, tx);\n    tx = min(tx*2., 1.5);\n\n    // Cog texture.\n    #ifdef COG2\n    // If using the second cog style, keep the center texture coordinates\n    // static and let the outer coordinates rotate.\n    svA = mix(svP, svA, smoothstep(0., sf, abs(length(svP) - .24) - .07));\n    #endif\n    //\n    vec3 tx2 = texture(iChannel0, svA/4. + rnd/4.).xyz; tx2 *= tx2;\n    tx2 = smoothstep(-.05, .5, tx2);\n    tx2 = min(tx2*2., 1.5);\n    \n    #else\n    // When not texturing, set the value to one.\n    vec3 tx = vec3(1);\n    vec3 tx2 = vec3(1);\n    #endif\n    \n    // If applicable, apply the texture to the background.\n    bg *= tx;\n\n    \n    // Initiate the scene color to the background.\n    vec3 col = bg;\n    \n    // Apply the circle rivots to the backgournd.\n    float b = max(bgPat2 - bgPat, 0.)/.01;\n    col = mix(col, bg*1.5, (1. - smoothstep(0., sf*24., bgPat))*.25);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., bgPat))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, bgPat));\n    col = mix(col, bg/2.*(1. + b) + b*.25*2., 1. - smoothstep(0., sf, bgPat + .025));\n    col = mix(col, bg/2.*(1. + b) + b*.25, 1. - smoothstep(0., sf, bgPat + .025 + .025));\n    //col += col*b*vec3(1, 2, 4)*.2;\n\n\n    // Use the randomly generated cog ID and IQ's cosine palette formula\n    // to produce a cog color.\n    vec3 oCol = .5 + .45*cos(6.2831*rnd/8. + vec3(0, 1, 2));\n\n\n    // Color alternating cogs different colors or shades.\n    #ifdef HEXAGON\n    if(mod(id.x + mod(id.y*2., 3.), 2.)==0.){\n    #else\n    if(mod(id.x + id.y, 2.)<.001){\n    #endif\n\n        oCol = mix(oCol, oCol.zyx, .6);\n        #if COLOR == 3\n        oCol = oCol.zyx;\n        #endif\n    } \n    #if COLOR == 4\n    else {\n        oCol = mix(oCol, oCol.yxz, .75);\n        //oCol = mix(oCol, oCol.yxz, dot(sin(p/1.5 + cos(p/.75)*1.57), vec2(.25)) +.5);\n    }\n    #endif\n\n\n\n    #if COLOR == 1\n    if(mod(id.x + mod(id.y*2., 3.), 2.)==0.)\n        oCol = vec3(.55, .5, .44)*dot(oCol, vec3(.299, .587, .114));\n    else oCol = vec3(.9, .8, .7)*mix(oCol, oCol.zyx, .25);\n    oCol *= vec3(1.15, 1, .85);\n    #elif COLOR == 2\n    oCol = (mix(oCol.xzy, vec3(1, .15, .3), .5)*1.5);\n    //if(mod(id.x + 1., 4.)<=1.) oCol = oCol.zyx;\n    //if(hash21(id + .21)<.5) oCol = oCol.zyx;\n    oCol = mix(oCol, oCol.zyx, dot(sin(p/1.5 + cos(p/.75)*1.57), vec2(.35)) +.5);\n    #ifdef HEXAGON\n    if(mod(id.x + mod(id.y*2., 3.), 2.)==0.){\n    #else\n    if(mod(id.x + id.y, 2.)<.001){\n    #endif\n        oCol = vec3(.4)*dot(oCol, vec3(.299, .587, .114));\n        oCol *= vec3(.9, 1, 1.1);\n    }\n    #endif\n\n    // Apply the second texture value to the cog color.\n    oCol *= tx2;\n\n\n    // Rendering.\n\n\n    // Sample differnces for highlights.\n    float sh = max(dHi - d, 0.)/.01;\n    float sh2 = max(d - dHi, 0.)/.01;\n\n    // Rotated top face highlight.\n    //vec2 svQ = -rot2(atan(lgtDir.x, lgtDir.y))*svP;\n    //float sh3 = mix(0., 1., smoothstep(0., .25, svQ.x));\n\n\n    // Render the layers in order.\n    //\n    // Extruded AO, extruded edge and extruded layer itself.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*12., dEx - .02))*.5);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, dEx - .02))*.95); \n    col = mix(col, oCol/2. + sh*.25, (1. - smoothstep(0., sf, dEx + .005))); // oCol/2.\n\n    // Laying the shadow down over the background and extruded section.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dSh - .015))*.5);\n\n\n    // Top layer edge, edge highlight and colored center.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d))*.95);\n    col = mix(col, oCol + sh*.5, (1. - smoothstep(0., sf, d + .025))*.95);\n    //\n    #ifdef COG2\n    // For the second cog style, brighten the outside and darkent the center.\n    oCol = mix(oCol*1.3, oCol/1.4, (1. - smoothstep(0., sf, abs(length(svP) - .24) - .07)));\n    #endif\n    col = mix(col, oCol + sh*.25, 1. - smoothstep(0., sf, d + .025+.025));\n\n\n    // Debug grayscale value.\n    //col = vec3(1)*dot(col, vec3(.299, .587, .114));\n\n    // Vignette. \n    col *= max(1.1 - length(uv)*.25, 0.);\n\n\n    // Rought gamma correction before presenting to the screen.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftdGRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1608, 1641, 1663, 1663, 1721], [1723, 1751, 1772, 1772, 1834], [1917, 1917, 1946, 2110, 4745]], "test": "untested"}
{"id": "sld3WM", "name": "Random generator", "author": "busybeaver", "description": "Some functions to generate random.", "tags": ["random"], "likes": 9, "viewed": 324, "published": 3, "date": "1636295075", "time_retrieved": "2024-07-30T18:49:48.368573", "image_code": "// you can use this random functions in your shaders\n// see Buffer A\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float pi = 3.1415926;\nfloat seed; // global float seed must exist in order for these functions to work\n\n// random number 0 <= rand() < 1\nfloat rand() {\n    seed = fract(seed + .500009);\n    return fract(sin(seed * 1000.) * seed * 100.);\n}\n\n// random vector with length = 1\nvec3 rand_ray() {\n    float d = rand() * pi * 2.;\n    float h = rand() * 2. - 1.;\n    float a = sqrt(1. - h * h);\n    return vec3(sin(d) * a, h, cos(d) * a);\n}\n\n// rotate a vec2 v by andgle a (this is not a random function)\nvec2 rotate(vec2 v, float a) {\n    vec2 x = vec2(cos(a), sin(a));\n    return v.x * x + v.y * vec2(-x.y, x.x);\n}\n\n// rotate a vec3 v by random angle (angle < w)\n// conc is the concentration of results around the original vector\n// conc = 1 for uniform distribution, conc < 1 for more vecrtors close to the original vector v\n// conc > 1 to concentrate results near to the edges of allowed by w area\n// this function may be used to make matte surface in ray tracing\nvec3 rand_rotate(vec3 v, float w, float conc) {\n    float d = rand() * pi * 2.;\n    float h = 1. - (1. - pow(rand(), conc)) * (1. - cos(w));\n    float a = sqrt(1. - h * h);\n    vec3 r = -vec3(sin(d) * a, cos(d) * a, h);\n    r = vec3(r.x, rotate(r.yz, atan(v.y, length(v.xz))));\n    r = vec3(rotate(r.xz, atan(v.z, v.x) + pi * .5), r.y).xzy;\n    return r * length(v);\n}\n\n// make seed from time and uv\nfloat make_seed(float time, vec2 uv) {\n    seed = fract(fract(time * .5) + time * .000009); seed = rand();\n    seed = fract(seed + uv.x); seed = rand();\n    seed = fract(seed + uv.y); seed = rand();\n    return seed;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - iResolution.xy * .5) / (iResolution.x + iResolution.y) * 4.;\n    make_seed(float(iFrame), uv);\n    \n    fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy) * .99;\n    if(uv.x < -0.5) {\n        for(int i = 0; i < 1000; i ++) {\n            vec3 r = rand_rotate(vec3(1., 0.2, 0.), 1.2, 1.0);\n            if(floor(r.xy / (r.z + 2.) * 300.) == floor(vec2(uv.x + 1.1, uv.y) * 300.))\n                fragColor += vec4(.5, .5, 1. - smoothstep(-1., 1., r.z), 1.) * .2;\n        }\n    } else if(uv.x < 0.5) {\n        for(int i = 0; i < 1600; i ++) {\n            vec3 r = rand_ray();\n            if(floor(r.xy / (r.z + 2.35) * 300.) == floor(uv.xy * 300.))\n                fragColor += vec4(.5, .5, 1. - smoothstep(-1., 1., r.z), 1.) * .2;\n        }\n    } else {\n        fragColor = vec4(rand(), rand(), rand(), 1.0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sld3WM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 125, 125, 192]], "test": "untested"}
{"id": "NtdGRB", "name": "Beautiful night sky", "author": "lllcz", "description": "Beautiful night sky", "tags": [], "likes": 3, "viewed": 283, "published": 3, "date": "1636291558", "time_retrieved": "2024-07-30T18:49:49.145496", "image_code": "#define PI 3.1415926535\n\n/// 二生一的随机函数\nfloat hash(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(154.45, 64.548))) * 124134.54)  ;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 归一化纹理坐标 [-1, 1]\n    vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;\n    // 通过随机函数生成星空，通过幂函数放大对比度\n    float stars = pow(hash(uv), 200.);\n    \n    vec3 colorM = vec3(0.,0.,0.);\n    vec3 colorA = vec3(0.5,0.3,0.9);\n    vec3 colorB = vec3(0.0,0.0,0.0);\n    //选择范围插值改变底色\n        colorM = mix(colorA, colorB, sin((uv.y+1.0)*PI/4.));\n    \n    \n    // 从上到下的渐变，并着色\n    vec3 night = vec3(uv.y * 0.5 + 0.5) * vec3(stars) + colorM;\n    \n    \n\n    \n    fragColor = vec4(night, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtdGRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 54, 75, 75, 145], [148, 148, 205, 242, 793]], "test": "untested"}
{"id": "Ntd3zS", "name": "入门之路-12", "author": "jialouluo", "description": "模拟细胞运动", "tags": [], "likes": 1, "viewed": 207, "published": 3, "date": "1636288179", "time_retrieved": "2024-07-30T18:49:50.025144", "image_code": "float count = 40.0;\nvec2 Size = vec2(30.0, 40.0);\nvec3 colorBg = vec3(0.0);\nvec3 colorIn = vec3(1.0, 0.9, 0.16);\nvec3 colorOut = vec3(0.12, 0.59, 0.21);\nvec3 getPowerColor(vec2 power) {\n    float pMax = pow(1.12,3.2);\n    float pMin = 1.0 / pMax;\n    vec3 color = mix(colorBg, colorOut, smoothstep(pMin, pMax, power.y));\n    color = mix(color, colorIn, smoothstep(pMin, pMax, power.x));\n    return color;\n}\nvec2 getPower(vec2 st, vec2 pos, vec2 size) {\n    vec2 radius = (size * size) / dot(st - pos, st - pos);\n    radius = pow(radius, vec2(1.5));\n    return radius;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord;\n    vec2 pows = vec2(0.0);\n    vec2 pos;\n    vec3 col;\n    for(float i = 1.0; i < count; i++) {\n        pos = 0.5 *iResolution.xy *\n            vec2(sin(iTime*0.05 * fract(0.246 * i) + i * 3.6) *\n                          cos(iTime*0.05 * fract(0.374 * i) - i * fract(0.6827 * i))\n                          + 1.,\n                          cos(iTime*0.05 * fract(0.246 * i) + i * 3.6) *\n                          sin(iTime*0.05 * fract(.374 * i) - i * fract(0.6827 * i))\n                          + 1.);\n        pows += getPower(uv, pos, Size * (.5 + fract(0.2834 * i) * .5));\n    }\n    col = getPowerColor(pows);\n    // Output to screen\n    \n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntd3zS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[153, 153, 185, 185, 406], [407, 407, 452, 452, 569], [570, 570, 625, 625, 1326]], "test": "untested"}
{"id": "fltGRS", "name": "Syracuse problem / Collatz con 5", "author": "FabriceNeyret2", "description": "https://en.wikipedia.org/wiki/Collatz_conjecture\nasync variant: infinite sampling\n\"orbit hair\" of each value (buffA line#0): curve which step turn left for evens and right for odds. \ncf https://community.wolfram.com/groups/-/m/t/558256\nclick: show storage", "tags": ["collatzconjecture", "syracuseproblem", "ulamconjecture", "hailstonesequence"], "likes": 28, "viewed": 677, "published": 3, "date": "1636276290", "time_retrieved": "2024-07-30T18:49:51.009513", "image_code": "// variant of https://shadertoy.com/view/ftc3zS\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n        O = T(U/1.);\n        if ( iMouse.z > 0.) O =  T1(U);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// --- compute the Collatz sequence\n\n\nvec3 ihash( uvec3 x ) {              // quality interger hash from https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x) / float(0xffffffffU);\n}\n#define hash(p,s)   ihash(uvec3(U.x,U.x*s,s)).x\n\n//#define hash(p,s)  fract(sin( ( p- .17542*s ) *  78.233 ) * 43758.5453) // old school hash\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U -= .5;\n    if (U.y > 0.) return;            // we simulates only 1st line \n    \n    O = T(U);                        // previous state\n    int i = int(O.x+.5);\n    \n    if ( iFrame==0 || (i==1 && O.y==2.) || O.z > R.y ) {        // --- initialization\n        O = vec4(0);\n     // O.x = U.x + U.y*R.x;         // each pixel represent one integer\n        O.a = O.x = floor(1e5*hash(U.x , float(iFrame) ));\n        return;\n    }\n                                     // --- Syracuse steps\n    O.z++;                           // step counter\n    if ( i==1 ) { O.y++; return; }   // already converged ( O.y counts after converged )\n\n    i   = i/2*2==i ? i/2 : 3*i+1;    // hearth of the model\n    O.x = float(i);                  // store current value\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R     iResolution.xy\n#define T(U)  texelFetch( iChannel0, ivec2(U), 0 )\n#define T1(U) texelFetch( iChannel1, ivec2(U), 0 )\n", "buffer_b_code": "// --- store the whole sequence\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec4 T = T1(vec2(U.x,0));\n    float v = U.y-.5- T.z;\n    O = v==0.  ? T : v < 0. ? T(U) : vec4(0);   // update the front storage\n    O.z = T.z;                                  // keep sequence counter\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// --- draw the AnglePath orbit of the reversed sequence \n//     see see https://community.wolfram.com/groups/-/m/t/558256\n\nfloat line(vec2 p, vec2 a,vec2 b) {           // --- draw line\n    p -= a, b -= a;\n    float h = dot(p, b) / dot(b, b),\n          c = clamp(h, 0., 1.);\n    p -= b*h;\n    return h==c ? dot(p,p) : 1e5; \n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = T1(U);                                // previous image\n // O = T1(U)*.99;                             \n    vec2 P, _P;\n    float d = 99.,x, a,r,t, z = R.y/7.;\n    U = ( U - vec2(.1,.45)*R ) / z ;\n    \n    for ( x=0.; x < min(R.x,640.); x++ ) {    // for each simulated number\n        t = T(vec2(x,0)).z;                   // current sequence counter\n        vec4 T = T(vec2(x,t));                // last record\n        if ( T.y != 1. ) continue;            // draw curve when sequence just finished\n        a = 0.; P = vec2(0); r = .05; \n        for ( int i,t = int(t); t >= 0; t-- )  {   // for each value in the sequence\n            _P = P;\n            T = T(vec2(x,t)); i = int(T.x+.5);// current value in the reversed sequence\n            a += i/2*2==i ? .14 : -.26;       // AnglePath from the sequence:\n            P += vec2(cos(a),sin(a)) * r;     // curve turns left it even or right if odd\n            d = min(d, line(U,_P,P) );        // draw current hair segment\n        }\n    }\n    O += .2* smoothstep(1.5,0.,sqrt(d) *z ) * vec4(.5,.7,1,1);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fltGRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 87, 87, 150]], "test": "untested"}
{"id": "fttGRS", "name": "入门之路-11", "author": "jialouluo", "description": "粒子旋转", "tags": [], "likes": 6, "viewed": 227, "published": 3, "date": "1636272643", "time_retrieved": "2024-07-30T18:49:51.889161", "image_code": "float EllipseY =0.2;\nfloat EllipseX =0.5;\nfloat EllipseSpeed =0.06;\nfloat EllipseCount =100.;\nfloat EllipseXAngle = 20.;\nvec2 getEllipse(float index){//椭圆旋转,通过极坐标来实现 x = a cos(index); y = bsin(index);\n    return vec2(EllipseX * cos(index * iTime * EllipseSpeed),EllipseY * sin(index * iTime * EllipseSpeed));\n}\nvec2 rotate(vec2 st,float angle){//旋转矩阵\n    return mat2(cos(angle),sin(angle),\n                -sin(angle),cos(angle)) * st;\n}\nfloat circle(vec2 st,float radius){\n    return 1.0 - smoothstep(0.0,radius,length(st));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=0.5;\n    vec3 color =vec3(0.);\n    //旋转运动的粒子\n    for(float i=0.0;i<EllipseCount;i++){\n        uv = rotate(uv,EllipseXAngle);// 让椭圆每次旋转\n        vec2 st = getEllipse(i);\n        float col = circle(uv - st,0.01 * i * 0.03);//乘i可以实现每个粒子大小不同\n        color +=col;\n    }\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fttGRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 121, 150, 224, 334], [335, 335, 368, 382, 469], [470, 470, 505, 505, 559], [560, 560, 617, 667, 1093]], "test": "untested"}
{"id": "fldGDr", "name": "wasteland", "author": "rockhard", "description": "landtest. High contract image make people feel nevous or exsiting sometime,i give this image a soft light spreading from far distance to feel comfortable.  ", "tags": ["landwalk"], "likes": 23, "viewed": 454, "published": 3, "date": "1636265796", "time_retrieved": "2024-07-30T18:49:52.655113", "image_code": "float map(vec3 p){\n    p.z+=iTime*0.5;\n    //push away the height to make a road.\n    float wav=(sin(p.x*0.25+4.4))*0.5\n        + texture(iChannel0,p.xz*0.5).x*0.007;  \n    float h = dot(sin(p - cos(p.zyx)),vec3(0.03));\n    p*=0.65;\n    h += dot(sin(p- cos(p.yzx*2.5)),vec3(0.05));\n     //-0.35 ~ 0.52 can flatten the ground and top surface \n    return p.y + smoothstep(-0.35,0.52,h-wav);   \n}\n\nvec3 getNormal(vec3 p){\n    vec2 e = vec2(0.002, -0.002); \n    return normalize(\n        e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\nvec3 col(vec3 rd, vec3 norm, float md, float t)\n{     \n    //a simply trick without the heavy mie calculation\n    //to control color\n    vec3 sun=(1.0-rd.y-rd.x)*vec3(0.4,0.3,0.2);\n    vec3 sky=mix(vec3(0.25,0.2,0.1),vec3(0.0,0.3,0.75),rd.y)+sun;\n    //cloud is also not nessesary this time..\n    \n    // light\n    vec3 ld =normalize(vec3(0.25, 0.5, 0.51)); \n    \n    float diff = dot(norm, ld);\n    \n    vec3 col= vec3(0.25)*(diff-0.5); \n    //fog\n    col = mix(col,sky, 1.0 - exp(-0.0006*t*t*t) );\n    //https://www.shadertoy.com/view/MlccDf\n    float sand = smoothstep(-0.2, 0.35, 0.0001 / md * t);\n    \n    return col+sand*vec3(0.15,0.1,0.01);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy-0.5;\n    float vig=(1.0-uv.x*uv.x)*(1.0-uv.y*uv.y);\n    \n    uv.x*=iResolution.x/iResolution.y; \n  \n    vec3 ro = vec3(0.0, 0.36, 0.0); \n    vec3 rd = normalize(vec3(uv,0.65));\n        \n    float t = 0.1;    \n    float minDist = 50.0;\n    \n    for (int i = 0; i < 64; i++){\n        float d = map(ro + rd*t);\n        if(d<0.01){\n            minDist = 0.1;\n            break;  \n        }\n        if(t>25.0) break;//early exist.               \n        t += d;\n    }    \n    \n    vec3 n =rd.y>0.15? vec3(0.0): getNormal(ro + rd * t);\n    vec3 color = col(rd, n, minDist, t);\n \n    fragColor = vec4(sqrt(clamp(color,0.0,1.0))*vig*1.25, 1.0);\n \n}", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fldGDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 393], [395, 395, 418, 418, 594], [596, 596, 645, 728, 1245], [1247, 1247, 1304, 1304, 1987]], "test": "untested"}
{"id": "stc3RB", "name": "Pixelating texures ", "author": "xZAKHAMx", "description": "This is something I built with Arnold osl before, I thought it will be nice if I did it here too with glsl.", "tags": ["pixelate"], "likes": 2, "viewed": 246, "published": 3, "date": "1636263896", "time_retrieved": "2024-07-30T18:49:53.489881", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float move = ceil(iTime);\n    float tile = 10.0;\n    float res = iResolution.x/iResolution.y;\n    vec2 mUV = round(vec2(((uv.x*res+0.01)+move/45.0), uv.y)*tile)/tile;\n    \n    \n    vec2 p  = -1.0 + 2.0* vec2(uv.x-move, uv.y);\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = fract(vec3(p*tile, 0.0))-0.5;\n    \n    col = vec3(smoothstep(length(col)-0.02, length(col), 0.60));\n    vec3 tex = texture(iChannel0,mUV).xyz;\n    col *= tex;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stc3RB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 604]], "test": "untested"}
{"id": "stc3RS", "name": "Cairo Pentagonal Tiling Grid", "author": "TinyTexel", "description": "How to map the vertices of a regular grid to those of an equilateral Cairo pentagonal tiling.", "tags": ["tiling", "tessellation"], "likes": 6, "viewed": 329, "published": 3, "date": "1636257757", "time_retrieved": "2024-07-30T18:49:54.407427", "image_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n// https://twitter.com/Mirko_Salm\n\n/*\n    How to map the vertices of a regular grid to those of a equilateral Cairo pentagonal tiling ( https://en.wikipedia.org/wiki/Cairo_pentagonal_tiling ).\n    One variant of the Cairo pentagonal tiling is dual the snub square tiling                   ( https://en.wikipedia.org/wiki/Snub_square_tiling      ).\n    \n    Related:\n            - \"Snub Square Tiling Grid\": https://www.shadertoy.com/view/7lcGRS\n*/\n\nvec3 GammaEncode(vec3 x) { return pow(x, vec3(1.0 / 2.2)); }\n\nfloat PlotDot(vec2 sp, vec2 dp, float dr)\n{\n    float v = length(sp - dp) - dr;\n    \n    v = smoothstep(1.0, 0.0, v * 16.0);\n    \n    return v;\n}\n\nfloat CheckerBoard(vec2 uv2)\n{\n    bvec2 tl1 = greaterThan(fract(uv2 * 0.5), vec2(0.5));   \n    bvec2 tl2 = greaterThan(fract(uv2 * 0.25 + vec2(0.25, 0.0)), vec2(0.5));   \n\n    if(tl2.x != tl2.y)\n    {\n        return tl1.x != tl1.y ? 0.0 : 0.004;\n    }\n    else\n    {\n        return tl1.x != tl1.y ? 0.02 : 0.04;\n    }\n}\n\n\nvec2 CairoTilingVPos(vec2 uvi)\n{\n    float offX = fract(uvi.x * 0.5) * 2.0;\n    float offY = fract(uvi.y * 0.5) * 2.0;\n    \n    if(offX == 1.0 && offY == 1.0) return vec2(-32.0);// discard point\n    \n    float flipX = fract(uvi.x * 0.25) < 0.5 ? -1.0 : 1.0;\n    float flipY = fract(uvi.y * 0.25) < 0.5 ? -1.0 : 1.0;\n    \n    float flip = flipX * flipY;\n    \n    float offM = 0.451416;// (4 - sqrt(7)) / 3\n    \n    vec2 off = vec2(-offY, offX) * offM * flip;\n    \n    return vec2(0.5) + off;\n}\n \n\nvoid mainImage(out vec4 outCol, in vec2 uv)\n{\n    uv -= floor(iResolution.xy * 0.5);\n    \n\tvec2 tex = uv / iResolution.xy;\n    \n    bool flip = (uint(iFrame) & 1u) != 0u;\n\n    vec3 col = vec3(0.0);\n\n    vec2 uv2 = uv / 32.0;\n    \n    vec2 uvf = fract(uv2);\n    vec2 uvi = floor(uv2);\n    \n    float dots = PlotDot(uvf, CairoTilingVPos(uvi), 0.02);\n    \n  #if 1\n    // ensures that points close to the cell boundaries don't get chopped off (doesn't add additional points)\n    { vec2 o = vec2( 1.0, 0.0); dots = max(dots, PlotDot(uvf, CairoTilingVPos(uvi + o) + o, 0.02)); }\n    { vec2 o = vec2(-1.0, 0.0); dots = max(dots, PlotDot(uvf, CairoTilingVPos(uvi + o) + o, 0.02)); }\n    { vec2 o = vec2( 0.0, 1.0); dots = max(dots, PlotDot(uvf, CairoTilingVPos(uvi + o) + o, 0.02)); }\n    { vec2 o = vec2( 0.0,-1.0); dots = max(dots, PlotDot(uvf, CairoTilingVPos(uvi + o) + o, 0.02)); }\n  #endif\n  \n  #if 1\n    if(tex.x < 0.0)\n    {\n        float s = tex.y < 0.0 ? 1.0 : 2.0;\n        col = vec3(CheckerBoard(uv2*s+vec2(1.0, 0.0))) / s;\n    }\n  #endif\n    \n    \n    col += vec3(dots);\n    \n\toutCol = vec4(GammaEncode(clamp(col, 0.0, 1.0)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stc3RS.jpg", "access": "api", "license": "cc0-1.0", "functions": [[518, 518, 544, 544, 578], [580, 580, 623, 623, 725], [727, 727, 757, 757, 1047], [1050, 1050, 1082, 1082, 1542], [1546, 1546, 1591, 1591, 2684]], "test": "untested"}
{"id": "7lcGRS", "name": "Snub Square Tiling Grid", "author": "TinyTexel", "description": "How to map the vertices of a regular grid to those of a snub square tiling.", "tags": ["tiling", "tessellation"], "likes": 11, "viewed": 333, "published": 3, "date": "1636257754", "time_retrieved": "2024-07-30T18:49:55.351902", "image_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n// https://twitter.com/Mirko_Salm\n\n/*\n    How to map the vertices of a regular grid to those of a snub square tiling ( https://en.wikipedia.org/wiki/Snub_square_tiling      ).\n    The snub square tiling is dual to a Cairo pentagonal tiling                ( https://en.wikipedia.org/wiki/Cairo_pentagonal_tiling ).\n    \n    Related:\n            - \"Cairo Pentagonal Tiling Grid\": https://www.shadertoy.com/view/stc3RS\n*/\n\nvec3 GammaEncode(vec3 x) { return pow(x, vec3(1.0 / 2.2)); }\n\nfloat PlotDot(vec2 sp, vec2 dp, float dr)\n{\n    float v = length(sp - dp) - dr;\n    \n    v = smoothstep(1.0, 0.0, v * 16.0);\n    \n    return v;\n}\n\nfloat CheckerBoard(vec2 uv2)\n{\n    bvec2 tl1 = greaterThan(fract(uv2 * 0.5), vec2(0.5));   \n    bvec2 tl2 = greaterThan(fract(uv2 * 0.25 + vec2(0.25, 0.0)), vec2(0.5));   \n\n    if(tl2.x != tl2.y)\n    {\n        return tl1.x != tl1.y ? 0.0 : 0.004;\n    }\n    else\n    {\n        return tl1.x != tl1.y ? 0.02 : 0.04;\n    }\n}\n\n\nvec2 SnubSquareTilingVPos(vec2 uvi)\n{\n    float offX = fract(uvi.x * 0.5) == 0.0 ? -1.0 : 1.0;\n    float offY = fract(uvi.y * 0.5) == 0.0 ? -1.0 : 1.0;\n    \n    float offM = 0.133975;// (2 - sqrt(3)) / 2\n    \n    vec2 off = vec2(offY, offX) * offM;\n    \n    return vec2(0.5) + off;\n}\n \n\nvoid mainImage(out vec4 outCol, in vec2 uv)\n{\n    uv -= floor(iResolution.xy * 0.5);\n    \n\tvec2 tex = uv / iResolution.xy;\n    \n    bool flip = (uint(iFrame) & 1u) != 0u;\n\n    vec3 col = vec3(0.0);\n\n    vec2 uv2 = uv / 32.0;\n    \n    vec2 uvf = fract(uv2);\n    vec2 uvi = floor(uv2);\n    \n    float dots = PlotDot(uvf, SnubSquareTilingVPos(uvi + vec2(1.0, 0.0)), 0.02);\n    \n  #if 1\n    if(tex.x < 0.0)\n    {\n        float s = tex.y < 0.0 ? 1.0 : 2.0;\n        col = vec3(CheckerBoard(uv2*s+vec2(1.0, 0.0))) / s;\n    }\n  #endif\n    \n    col += vec3(dots);\n    \n\toutCol = vec4(GammaEncode(clamp(col, 0.0, 1.0)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lcGRS.jpg", "access": "api", "license": "cc0-1.0", "functions": [[490, 490, 516, 516, 550], [552, 552, 595, 595, 697], [699, 699, 729, 729, 1019], [1022, 1022, 1059, 1059, 1305], [1309, 1309, 1354, 1354, 1926]], "test": "untested"}
{"id": "st3GRB", "name": "another basic face", "author": "jorge2017a2", "description": "another basic face ;)  :P", "tags": ["anotherbasicface"], "likes": 3, "viewed": 195, "published": 3, "date": "1636257232", "time_retrieved": "2024-07-30T18:49:56.390127", "image_code": "///-------------image\n//another basic face--6-nov-2021\n//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdTorus( vec3 p, vec2 t )\n\t{ vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{   float k0 = length(p/r);   float k1 = length(p/(r*r));  return k0*(k0-1.0)/k1;}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec2 opRep2D( in vec2 p, in vec2 c )\n\t{ vec2 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3 opRep3D( in vec3 p, in vec3 c )\n\t{ vec3 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3  opRep(vec3 p, vec3 r)\n   { return mod(p,r)-0.5*r; }\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n   \n   p.y=p.y-10.0;\n    vec3 pOrg=p;\n    \n    float dCabeza= sdEllipsoid( p-vec3(0.0,0.0,2.0), vec3(7.0,8.0,3.5));\n    float dFrente= sdEllipsoid( p-vec3(0.0,2.5,0.25), vec3(5.5,3.0,2.0));\n    float dPomulo= sdEllipsoid( p-vec3(0.0,-1.5,0.0), vec3(6.0,5.0,2.0));\n    \n    \n    vec3 PosNariz=p-vec3(0.0,-1.0,0.0);\n    //nariz\n    vec3 aA=vec3(0.0,0.0,0.0);\n    vec3 bA=vec3(0.0,3.0,0.0);\n    float rA1=0.5;\n    float rA2=0.25;\n    vec3 p0= rotate_x( PosNariz, radians(-23.0));\n    float dNariz1= sdRoundCone(p0-vec3(0.0,-2.0,-2.0), aA, bA, rA1, rA2);\n    \n    \n    vec3 aB=vec3(0.0,0.0,0.0);\n    vec3 bB=vec3(0.0,1.5,0.0);\n    float rB1=0.7;\n    float rB2=0.15;\n    float dNariz2= sdRoundCone(p0-vec3(0.0,-2.0,-2.0), aB, bB, rB1, rB2);\n    \n    //dif nariz\n    vec3 p0a= rotate_x( PosNariz-vec3(0.0,-1.2,-3.25), radians(55.0));\n    float difNarizBox= sdBox( p0a, vec3(1.0,2.0,0.5) );\n    \n    //diferncia de nariz\n    dNariz1=differenceSDF(dNariz1 ,difNarizBox);\n    dNariz2=differenceSDF(dNariz2 ,difNarizBox);\n    \n    ///Union de cabeza\n    dCabeza=opSmoothUnion(dCabeza,dFrente,0.5);\n    dCabeza=opSmoothUnion(dCabeza,dPomulo,0.125);\n    dCabeza=opSmoothUnion(dCabeza,dNariz1,0.5);\n    dCabeza=opSmoothUnion(dCabeza,dNariz2,0.5);\n     p.x = abs(p.x)-2.5; \n     \n    vec3 p1= p-vec3(0.3,-1.8,0.0);\n    float dhoyoDif=sdBox( p1, vec3(3.5,1.5,2.0) );\n     \n    float dOjo= sdEllipsoid( p, vec3(2.5,2.2,1.8)); \n    float dhoyoOjo= sdEllipsoid( p, vec3(3.,2.5,2.0));\n    \n    dhoyoOjo= differenceSDF( dhoyoOjo,dhoyoDif);\n    dOjo= differenceSDF( dOjo,dhoyoDif);\n    float dOjoOr=dOjo;\n    dCabeza=opSmoothSubtraction(dhoyoOjo,dCabeza, 0.5 );\n    \n    //MOstrar OJo y Cabeza\n    res =opU3(res, vec3(dCabeza,30,-1.0));\n    res =opU3(res, vec3(dOjo,1.0,-1.0));\n    \n    ///pupila Ojo\n    vec3 posMov=vec3(1.0*sin(iTime), 0.8*cos(iTime*2.0),0.0);\n    vec3 posPupilaIris=vec3(0.0+posMov.x,0.5+posMov.y,0.0);\n    float dPupila= sdCylinderXY(p-posPupilaIris, vec2(0.25,3.2));  //ch\n    float dIris= sdCylinderXY( p-posPupilaIris, vec2(0.8,3.0)  );  //Gr\n    dPupila= intersectSDF( dPupila,dOjoOr);\n    dIris= intersectSDF( dIris,dOjoOr);\n    res =opU3(res, vec3(dIris,2.0,-1.0));\n    res =opU3(res, vec3(dPupila,0.0,-1.0));\n    \n    // oreja\n    vec3 pOreja=pOrg-vec3(0.0,0.0,1.25);\n    pOreja.x=abs(pOreja.x)-6.0;\n    float OrejaA= sdEllipsoid( pOreja-vec3(0.0,0.0,0.0), vec3(2.0,2.0,1.5));\n    float OrejaB= sdEllipsoid( pOreja-vec3(0.0,0.0,-1.0), vec3(1.0,1.2,1.5));\n    OrejaA= differenceSDF(OrejaA, OrejaB);\n    res =opU3(res, vec3(OrejaA,30.0,-1.0));\n    \n    //labios\n    float dLabioA= sdEllipsoid( pOrg-vec3(0.0,-3.5,-1.1), vec3(2.0,0.5,1.0));\n    float dLabioB= sdEllipsoid( pOrg-vec3(0.0,-4.0,-1.0), vec3(2.0,0.5,1.0));\n    res =opU3(res, vec3(dLabioA,2.0,-1.0));\n    res =opU3(res, vec3(dLabioB,2.0,-1.0));\n    \n    //cejas\n    vec3 posCejas=pOrg.yzx-vec3(1.2,-1.5,0.0);\n    posCejas.z= abs(posCejas.z)-2.5;\n    float dcejasA=sdTorus(posCejas, vec2(2.0,0.5) );\n    vec3 posCejasBx=pOrg-vec3(0.0,0.5,0.0);\n    posCejasBx.x=abs(posCejasBx.x)-2.5;\n    float dCejasDif=sdBox(posCejasBx, vec3(3.0,1.8,2.5) );\n    dcejasA= differenceSDF(dcejasA, dCejasDif);\n    res =opU3(res, vec3(dcejasA,0.0,-1.0));\n    \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float dis) \n{   vec3 l = normalize(lp - p);\n    vec3 ldir = normalize(p-rd);    \n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    //float diff=max(0.,dot(ldir,-n));\n    float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true) {fshadow=GetShadow(p,lp);}\n    else {fshadow=0.5;}\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n    lin *= atten*0.5*col*fshadow;\n    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    lin = pow(lin,vec3(0.4545));\n \n    return lin;\n    //return lin*atten*(1.0/2.0);\n    \n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float dis)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro,  colobj,dis);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    return colobj;\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d);\n   \n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3( 10.0, 10.0, -20.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 10.0, -10.0 ); light_color2 =vec3( 1.0 ); \n   vec3 ro=vec3(0.0,9.0,-20.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    col = linear2srgb(col);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------common\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st3GRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[535, 535, 567, 567, 651], [652, 652, 686, 686, 748], [749, 749, 788, 788, 883], [885, 885, 922, 922, 1003], [1005, 1005, 1030, 1030, 1049], [1050, 1050, 1113, 1177, 1764], [1766, 1810, 1857, 1857, 1884], [1885, 1885, 1928, 1928, 1955], [1956, 1956, 2004, 2004, 2032], [2033, 2071, 2107, 2107, 2152], [2153, 2153, 2192, 2192, 2236], [2237, 2237, 2276, 2276, 2320], [2321, 2321, 2353, 2353, 2378], [2379, 2444, 2478, 2478, 2574], [2575, 2575, 2609, 2609, 2700], [2701, 2701, 2735, 2735, 2826], [2829, 2829, 2881, 2881, 2980], [2982, 2982, 3040, 3040, 3140], [3142, 3142, 3201, 3201, 3300], [3302, 3342, 3376, 3376, 3471], [3472, 3512, 3537, 3537, 6848], [6850, 6850, 6874, 6874, 7036], [7038, 7038, 7087, 7087, 7754], [7756, 7756, 7792, 7792, 8037], [8039, 8039, 8066, 8066, 8083], [8085, 8085, 8121, 8121, 8213], [8214, 8214, 8260, 8260, 8385], [8387, 8387, 8472, 8472, 9925], [9927, 9927, 10018, 10018, 10146], [10148, 10148, 10180, 10180, 10377], [10379, 10379, 10472, 10472, 10633], [10635, 10635, 10666, 10666, 11265], [11267, 11267, 11293, 11293, 11403], [11405, 11405, 11463, 11463, 11515], [11517, 11566, 11623, 11623, 12153]], "test": "untested"}
{"id": "stc3zS", "name": "Persian carpet 10", "author": "jarble", "description": "A Persian carpet pattern generator.", "tags": ["fractal", "snowflake", "carpet", "rug"], "likes": 2, "viewed": 229, "published": 3, "date": "1636254733", "time_retrieved": "2024-07-30T18:49:57.220905", "image_code": "//change these constants to get different patterns!\n#define c2 2.\n\n#define c1 vec4(-c2,sign(c2)*.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 4.5/2.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float t2 = +floor((iTime)/10.0+uv.x);\n    vec3 random1 = (hash31(t2)-vec3(.5))/4.;\n    vec3 random2 = (hash31(1.+t2)-vec3(.5))/4.;\n    vec3 random3 = (hash31(2.+t2)-vec3(.5))/4.;\n    vec3 random4 = (hash31(3.+t2)-vec3(.5))/4.;\n    vec3 random5 = (hash31(4.+t2)-vec3(.5))/2.-.25;\n    vec3 random6 = (hash31(5.+t2)-vec3(.5))/2.-.25;\n    \n    float offset = .5;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        for(int i=0;i<3;i++)\n        {\n            float factor = 1.25;\n            float l1 = col.x;\n            //factor += col.x/8.;\n            //uv.x *= factor;\n            uv = triangle_wave(uv.yx+l1+offset,scale)+triangle_wave(uv,scale);\n            uv.x *= -factor;\n            \n            //l1 *= 1. - uv.x/2.;\n\n            for(int k = 0; k < 3; k++){\n                //int k1 = k%3;\n                //uv.x /= factor;\n                //factor += col.x/8.;\n                uv = triangle_wave((uv+uv.yx*vec2(random1[k],random2[k])-l1+offset)/(random4[k]+1.),scale+random3[k]);\n                //l1 *= 1. - uv.x/2.;\n                uv.x /= -factor;\n                uv /= 1.+1./(8.);\n\n                //uv *= 1.-random5[k]/8.;\n                //uv.yx *= 1. + vec2(random5[k])*col.yx;\n        \n            }\n\n            scale *= 1./(1.+l1);\n\n            \n\n            col = col.yxz;\n            col[c] = fract((uv.x)-(uv.y));\n            //col[c] = abs(-col[c]-uv.x+uv.y);\n\n\n\n        }\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stc3zS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[281, 391, 413, 459, 592], [594, 594, 633, 633, 678], [680, 680, 737, 737, 2372]], "test": "untested"}
{"id": "st33zS", "name": "transx", "author": "Sergeindamix", "description": "test", "tags": ["transitions"], "likes": 6, "viewed": 388, "published": 3, "date": "1636254018", "time_retrieved": "2024-07-30T18:49:58.436655", "image_code": "\n\nint n = 50;            // number of \"frames\" in transition\nfloat sa = .05;        // smooth amount - size of smooth edges\nbool roto = true;      // if true, rotate transitions that can optionally rotate\nfloat rota = 360.0;    // amount of rotation from start to end of transition\nint rn = 1, rd = 0;    // select based on whether to start with full\n//int rn = 0, rd = -1; //   frame of source1 (only for some transitions)\n\n#define SPEEDADJ .75\n//#define NEEDMOD 1\n\n#define imod(a,b) (int((float(a)-(float(b)*floor(float(a)/float(b))))))\n\n#define iGlobalTime (iTime / SPEEDADJ)\n\n#define num_transitions 33\n\n// macros for selecting/mixing the textures\n\n#define MEM2 col = alt ? col1 : col2;\n#define MEM1 col = alt ? col2 : col1;\n#define MEM12 col = alt ? v1 * col2 + v2 * col1 : v1 * col1 + v2 * col2;\n#define MEM1S { col = alt ? texture2D(iChannel1, uv2).xyz : texture2D(iChannel0, uv2).xyz; }\n\n// Solve some incompatibilities\n\n#define atan2 atan\n#define fmod mod\n#define texture2D texture\n\n// Useful values\n\n#define _TWOPI 6.283185307\n#define M_PI 3.141592654\n\nfloat intersect(vec2, vec2, vec2, vec2);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = fragCoord.xy / iResolution.xy, uv2;\nbool alt = false;\nint type, i, i2, j;\nvec3 col, col3;\nfloat v1, v2;\nfloat ye, yfe, dx, dy, cx, cy, rad, slope, theta, xc1, yc1, b, rad0, rad2;\nfloat xc2, yc2, b2, cx2, cy2, r1, vy1, vy2, dx2, dy2, ro, ri, ang, a, a1;\nfloat r, r2, l, l2, theta2, theta3, tang, ang1, ang2, angt, angs, c1, s1;\nfloat xc0, yc0;\nvec2 p1, p2, po, pd;\n\nfloat aspect = iResolution.y / iResolution.x;\nvec3 col1 = texture2D(iChannel0, uv).xyz;\nvec3 col2 = texture2D(iChannel1, uv).xyz;\nvec3 col4 = texture2D(iChannel2, uv).xyz;\nvec3 col5 = texture2D(iChannel3, uv).xyz;\n\n#ifdef NEEDMOD\ni = imod(int(iGlobalTime * 20.0) , n);\ntype = imod((int(iGlobalTime * 20.0) / n) , num_transitions);\nif (imod(type , 2)== 1) { alt = true; } else { alt = false; }\n#else\ni = int(iGlobalTime * 20.0) % n;\ntype = (int(iGlobalTime * 20.0) / n) % num_transitions;\nif (type % 2 == 1) { alt = true; col1=col4; } else { alt = false; col2=col5; }\n#endif\n\n//type = 32;\n\n// some of these equations are long, so I'll forego extra spaces\n\n// was a switch, but some GPUs won't do switch\n\n\t\tif (type==0) // fade in/out\n\t\t\t{\n\t\t\tv1=float(n-(i+1))/float(n-1); v2=1.0-v1;\n\t\t\tMEM12\n\t\t\t}\n\t\telse if (type==1) // window down with soft edge\n\t\t\t{\n\t\t\tye=1.0-float(i)/float(n-1);\n\t\t\tyfe=ye+sa;\n\t\t\tif (uv.y<=ye) MEM1\n\t\t\telse if (uv.y>yfe) MEM2\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tv2=float(uv.y-ye)/sa; if (v2>1.0) { v2=1.0; } v1=1.0-v2;\n\t\t\t\tMEM12\n\t\t\t\t}\n\t\t\t}\n\t\telse if (type==2) // increasing box\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\tdx=cx*float(i+rn)/float(n+rd);\n\t\t\tdy=cy*float(i+rn)/float(n+rd);\n\t\t\tif ((uv.x>=cx-dx)&&(uv.x<=cx+dx)&&(uv.y>=cy-dy)&&(uv.y<=cy+dy)) MEM2\n\t\t\telse MEM1\n\t\t\t}\n\t\telse if (type==3) // increasing diamond\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\trad=sqrt(cx*cx+cy*cy)*(float(i+rn)/float(n+rd));\n\t\t\tslope=-cy/cx;\n\t\t\ttheta=atan(-slope);\n\t\t\txc1=rad*cos(theta); yc1=rad*sin(theta);\n\t\t\tb=yc1-slope*xc1;\n\t\t\tcy=b; cx=(-b/slope);\n\t\t\tdy=abs(.5-uv.y);\n\t\t\tdx=abs(.5-uv.x);\n\t\t\tif (dx>cx) MEM1\n\t\t\telse if (dy>slope*dx+cy) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==4) // increasing circle\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\trad=sqrt(cx/aspect*cx/aspect+cy*cy)*(float(i+rn)/float(n+rd));\n\t\t\tif (sqrt((uv.x-cx)/aspect*(uv.x-cx)/aspect+(uv.y-cy)*(uv.y-cy))>rad) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==5) // increasing and decreasing diamonds\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\trad0=sqrt(cx*cx+cy*cy)/2.0;\n\t\t\trad=sqrt(cx*cx+cy*cy)*(float(n-(i+1))/float(n+rd))/2.0;\n\t\t\trad2=rad0+(rad0-rad);\n\t\t\tslope=-cy/cx;\n\t\t\ttheta=atan(-slope);\n\t\t\txc1=rad*cos(theta); yc1=rad*sin(theta);\n\t\t\txc2=rad2*cos(theta); yc2=rad2*sin(theta);\n\t\t\tb=yc1-slope*xc1;\n\t\t\tb2=yc2-slope*xc2;\n\t\t\tcy=b; cx=(-b/slope);\n\t\t\tcy2=b2; cx2=(-b2/slope);\n\t\t\tdy=abs(.5-uv.y);\n\t\t\tdx=abs(.5-uv.x);\n\t\t\tif (dx>cx) MEM2\n\t\t\telse if (dy>slope*dx+cy) MEM2\n\t\t\telse MEM1\n\t\t\tif (dy>slope*dx+cy2) MEM1\n\t\t\t}\n\t\telse if (type==6) // four corner vanish\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\tdx=cx*float(i+rn)/float(n+rd);\n\t\t\tdy=cy*float(i+rn)/float(n+rd);\n\t\t\tif ((uv.x>cx-dx)&&(uv.x<cx+dx)&&(uv.y>cy-dy)&&(uv.y<cy+dy)) MEM2\n\t\t\telse if ((uv.y<cy)&&(uv.x>cx-dx)&&(uv.x<cx+dx)) MEM2\n\t\t\telse if ((uv.y>cy)&&(uv.x>cx-dx)&&(uv.x<cx+dx)) MEM2\n\t\t\telse if ((uv.x<cx)&&(uv.y>cy-dy)&&(uv.y<cy+dy)) MEM2\n\t\t\telse if ((uv.x>cx)&&(uv.y>cy-dy)&&(uv.y<cy+dy)) MEM2\n\t\t\telse MEM1\n\t\t\t}\n\t\telse if (type==7) // increasing circle with soft edge\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\trad=sqrt(cx/aspect*cx/aspect+cy*cy)*(float(i+rn)/float(n+rd));\n\t\t\t//rad2=rad+10.0*sa;\n\t\t\trad2=rad+sa;\n\t\t\tr1=sqrt((uv.x-cx)/aspect*(uv.x-cx)/aspect+(uv.y-cy)*(uv.y-cy));\n\t\t\tif (r1>rad2) MEM1\n\t\t\telse if (r1>rad) { v1=(r1-rad)/(rad2-rad); v2=1.0-v1; MEM12 }\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==8) // increasing diamond with soft edge\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\trad=sqrt(cx*cx+cy*cy)*(float(i+rn)/float(n+rd));\n\t\t\t//rad2=rad+7.0*sa;\n\t\t\trad2=rad+.7*sa;\n\t\t\tslope=-cy/cx;\n\t\t\ttheta=atan(-slope);\n\t\t\txc1=rad*cos(theta); yc1=rad*sin(theta);\n\t\t\txc2=rad2*cos(theta); yc2=rad2*sin(theta);\n\t\t\tb=yc1-slope*xc1;\n\t\t\tb2=yc2-slope*xc2;\n\t\t\tcy=b; cx=(-b/slope);\n\t\t\tcy2=b2; cx2=(-b2/slope);\n\t\t\tdy=abs(.5-uv.y);\n\t\t\tdx=abs(.5-uv.x);\n\t\t\tif (dx>cx2) MEM1\n\t\t\telse if (dy>slope*dx+cy2) MEM1\n\t\t\telse if (dy>slope*dx+cy)\n\t\t\t\t{\n\t\t\t\tvy1=slope*dx+b;\n\t\t\t\tvy2=slope*dx+b2;\n\t\t\t\tv1=(dy-vy1)/(vy2-vy1); v2=1.0-v1;\n\t\t\t\tMEM12\n\t\t\t\t}\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==9) // increasing & decreasing diamonds w/ soft edge\n\t\t\t{\n\t\t\tfloat xc1s,yc1s,xc2s,yc2s,rads,rad2s,bs,b2s,cxs,cys,cx2s,cy2s;\n\n\t\t\tcx=.5; cy=.5;\n\t\t\trad0=sqrt(cx*cx+cy*cy)/2.0;\n\t\t\trad=sqrt(cx*cx+cy*cy)*(float(n-(i+1))/float(n+rd))/2.0;\n\t\t\t//rads=rad+7.0*sa;\n\t\t\trads=rad+.7*sa;\n\t\t\trad2=rad0+(rad0-rad);\n\t\t\t//rad2s=rad2-7.0*sa;\n\t\t\trad2s=rad2-.7*sa;\n\t\t\tslope=-cy/cx;\n\t\t\ttheta=atan(-slope);\n\t\t\txc1=rad*cos(theta); yc1=rad*sin(theta);\n\t\t\txc2=rad2*cos(theta); yc2=rad2*sin(theta);\n\t\t\txc1s=rads*cos(theta); yc1s=rads*sin(theta);\n\t\t\txc2s=rad2s*cos(theta); yc2s=rad2s*sin(theta);\n\t\t\tb=yc1-slope*xc1;\n\t\t\tb2=yc2-slope*xc2;\n\t\t\tbs=yc1s-slope*xc1s;\n\t\t\tb2s=yc2s-slope*xc2s;\n\t\t\tcy=b; cx=(-b/slope);\n\t\t\tcy2=b2; cx2=(-b2/slope);\n\t\t\tcys=bs; cxs=(-bs/slope);\n\t\t\tcy2s=b2s; cx2s=(-b2s/slope);\n\t\t\tdy=abs(.5-uv.y);\n\t\t\tdx=abs(.5-uv.x);\n\t\t\tif (dx>cxs) MEM2\n\t\t\telse if (dy>slope*dx+cys) MEM2\n\t\t\telse if (dy>slope*dx+cy)\n\t\t\t\t{\n\t\t\t\tvy1=slope*dx+b;\n\t\t\t\tvy2=slope*dx+bs;\n\t\t\t\tv2=(dy-vy1)/(vy2-vy1); v1=1.0-v2;\n\t\t\t\tMEM12\n\t\t\t\t}\n\t\t\telse MEM1\n\t\t\tif (dy>slope*dx+cy2) MEM1\n\t\t\telse if (dy>slope*dx+cy2s)\n\t\t\t\t{\n\t\t\t\tvy1=slope*dx+b2;\n\t\t\t\tvy2=slope*dx+b2s;\n\t\t\t\tv2=(dy-vy1)/(vy2-vy1); v1=1.0-v2;\n\t\t\t\tMEM12\n\t\t\t\t}\n\t\t\t}\n\t\telse if (type==10) // increasing box with soft edge\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\tdx=(cx*float(i+rn)/float(n+rd));\n\t\t\tdy=(cy*float(i+rn)/float(n+rd));\n\t\t\tdx2=(cx*float(i+rn)/float(n+rd)+sa);\n\t\t\tdy2=(cy*float(i+rn)/float(n+rd)+sa);\n\t\t\tif ((uv.x>=cx-dx)&&(uv.x<=cx+dx)&&(uv.y>=cy-dy)&&(uv.y<=cy+dy)) MEM2\n\t\t\telse if ((uv.x>=cx-dx2)&&(uv.x<=cx+dx2)&&(uv.y>=cy-dy2)&&(uv.y<=cy+dy2))\n\t\t\t\t{\n\t\t\t\tif ((abs(uv.x-cx)>dx)&&(abs(uv.y-cy)>dy))\n\t\t\t\t\t{\n\t\t\t\t\tif (abs(uv.y-cy)-dy>abs(uv.x-cx)-dx) v1=float(abs(uv.y-cy)-dy)/(sa);\n\t\t\t\t\telse v1=float(abs(uv.x-cx)-dx)/(sa);\n\t\t\t\t\t}\n\t\t\t\telse if (abs(uv.x-cx)>dx) { v1=float(abs(uv.x-cx)-dx)/(sa); }\n\t\t\t\telse if (abs(uv.y-cy)>dy) { v1=float(abs(uv.y-cy)-dy)/(sa); }\n\t\t\t\tv2=1.0-v1; MEM12\n\t\t\t\t}\n\t\t\telse MEM1\n\t\t\t}\n\t\telse if (type==11) // rotating vanishing (gets smaller) square with fade in new/fade out old\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\ttheta=-_TWOPI*(float(i+rn)/float(n+rd));\n\t\t\tc1=cos(theta); s1=sin(theta);\n\t\t\trad=(float(n-(i+1))/float(n+rd));\n\t\t\tif (rad<=0.0) { rad=0.00001; }\n\t\t\txc0=uv.x; yc0=uv.y;\n\t\t\txc1=xc0-cx; yc1=yc0-cy;\n\t\t\txc2=(xc1*c1-yc1*s1)/rad;\n\t\t\tyc2=(xc1*s1+yc1*c1)/rad;\n\t\t\tuv2.x=xc2*aspect+cx; uv2.y=yc2+cy;\n\t\t\tif ((uv2.x>=0.0)&&(uv2.x<=1.0)&&(uv2.y>=0.0)&&(uv2.y<=1.0)) { col3 = alt ? texture2D(iChannel1, uv2).xyz : texture2D(iChannel0, uv2).xyz; }\n\t\t\telse { col3 = vec3(0,0,0); }\n\t\t\tv1=float(n-(i+1))/float(n-1); v2=1.0-v1;\n\t\t\tcol = alt ? v1*col3+v2*col1 : v1*col3+v2*col2;\n\t\t\t}\n\t\telse if (type==12) // rotating vanishing (gets smaller) square with fade out old\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\ttheta=-_TWOPI*(float(i+rn)/float(n+rd));\n\t\t\tc1=cos(theta); s1=sin(theta);\n\t\t\trad=(float(n-(i+1))/float(n+rd));\n\t\t\tif (rad<=0.0) { rad=0.00001; }\n\t\t\txc0=uv.x; yc0=uv.y;\n\t\t\txc1=xc0-cx; yc1=yc0-cy;\n\t\t\txc2=(xc1*c1-yc1*s1)/rad;\n\t\t\tyc2=(xc1*s1+yc1*c1)/rad;\n\t\t\tuv2.x=xc2*aspect+cx; uv2.y=yc2+cy;\n\t\t\tif ((uv2.x>=0.0)&&(uv2.x<=1.0)&&(uv2.y>=0.0)&&(uv2.y<=1.0)) { col3 = alt ? texture2D(iChannel1, uv2).xyz : texture2D(iChannel0, uv2).xyz; }\n\t\t\telse { col3 = alt ? col1 : col2; }\n\t\t\tv1=float(n-(i+1))/float(n-1); v2=1.0-v1;\n\t\t\tcol = alt ? v1*col3+v2*col1 : v1*col3+v2*col2;\n\t\t\t}\n\t\telse if (type==13) // increasing flower with soft edge\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\tang=36.0*M_PI/180.0;\n\t\t\tro=(1.0/aspect)/.731*(float(i+rn)/float(n+rd));\n\t\t\ta1=234.0*M_PI/180.0;\n\t\t\tl=(sqrt((ro*cos(a1)*ro*cos(a1))+((ro*sin(a1)-ro)*(ro*sin(a1)-ro))))/2.0;\n\t\t\ta1=162.0*M_PI/180.0;\n\t\t\tl2=((ro*cos(a1)*ro*cos(a1))+((ro*sin(a1)-ro)*(ro*sin(a1)-ro)));\n\t\t\tri=(ro-sqrt(l2-l*l))/cos(36.0*M_PI/180.0);\n\t\t\tif (roto) { vy1=float(i+rn-1)/float(n+rd)*rota*M_PI/180.0; }\n\t\t\telse { vy1=0.0; }\n\t\t\tyc1=1.0-uv.y-cy;\n\t\t\txc1=(uv.x-cx)/aspect;\n\t\t\ttheta=atan2(xc1,yc1)+vy1;\n\t\t\ttheta2=fmod(abs(theta),ang);\n\t\t\ti2=int((180.0*theta/M_PI)/36.0);\n#ifdef NEEDMOD\n\t\t\tif (imod(i2,2)==0) { r=theta2/ang*(ro-ri)+ri; }\n#else\n\t\t\tif (i2%2==0) { r=theta2/ang*(ro-ri)+ri; }\n#endif\n\t\t\telse { r=(1.0-theta2/ang)*(ro-ri)+ri; }\n\t\t\tr2=sqrt(xc1*xc1+yc1*yc1);\n\t\t\tif (r2>r+sa) { MEM1 } else if (r2>r) { v1=(r2-r)/(sa); v2=1.0-v1; MEM12 } else { MEM2 }\n\t\t\t}\n\t\telse if (type==14) // increasing star with soft edge\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\tang=36.0*M_PI/180.0;\n\t\t\tro=(1.0/aspect)/.731*(float(i+rn)/float(n+rd));\n\t\t\ta1=234.0*M_PI/180.0;\n\t\t\tl=(sqrt((ro*cos(a1)*ro*cos(a1))+((ro*sin(a1)-ro)*(ro*sin(a1)-ro))))/2.0;\n\t\t\ta1=162.0*M_PI/180.0;\n\t\t\tl2=((ro*cos(a1)*ro*cos(a1))+((ro*sin(a1)-ro)*(ro*sin(a1)-ro)));\n\t\t\tri=(ro-sqrt(l2-l*l))/cos(36.0*M_PI/180.0);\n\t\t\tif (roto) { vy1=float(i+rn-1)/float(n+rd)*rota*M_PI/180.0; }\n\t\t\telse { vy1=0.0; }\n\t\t\tpo.x=po.y=0.0;\n\t\t\tyc1=1.0-uv.y-cy;\n\t\t\txc1=(uv.x-cx)/aspect;\n\t\t\ttheta=atan2(xc1,yc1)+vy1;\n\t\t\ttheta2=fmod(abs(theta),ang);\n\t\t\ti2=int((180.0*theta/M_PI)/36.0);\n#ifdef NEEDMOD\n\t\t\tif (imod(i2,2)==0) { p1.x=ri; p1.y=0.0; p2.x=ro*cos(ang); p2.y=ro*sin(ang); }\n#else\n\t\t\tif (i2%2==0) { p1.x=ri; p1.y=0.0; p2.x=ro*cos(ang); p2.y=ro*sin(ang); }\n#endif\n\t\t\telse { p1.x=ro; p1.y=0.0; p2.x=ri*cos(ang); p2.y=ri*sin(ang); }\n\t\t\tpd.x=cos(theta2); pd.y=sin(theta2);\n\t\t\tr=intersect(po,pd,p1,p2);\n\t\t\tr2=sqrt(xc1*xc1+yc1*yc1);\n\t\t\tif (r2>r+sa) { MEM1 } else if (r2>r) { v1=(r2-r)/(sa); v2=1.0-v1; MEM12 } else { MEM2 }\n\t\t\t}\n\t\telse if (type==15) // dissolve\n\t\t\t{\n\t\t\t// easier to use this common shadertoy random number gen rather than the one I used in original\n\t\t\tint v=int(fract(sin(dot(uv, vec2(12.9898, 78.233)))* 43758.5453)*float(n-1));\n\t\t\tif (i>v) MEM2 else MEM1\n\t\t\t}\n\t\telse if (type==16) // split horizontal\n\t\t\t{\n\t\t\tcy=.5;\n\t\t\tye=1.0/2.0*float(i+rn)/float(n+rd);\n\t\t\tif (uv.y<cy-ye) MEM1\n\t\t\telse if (uv.y>=cy+ye) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==17) // split vertical\n\t\t\t{\n\t\t\tcx=.5;\n\t\t\tye=1.0/2.0*float(i+rn)/float(n+rd);\n\t\t\tif (uv.x<cx-ye) MEM1\n\t\t\telse if (uv.x>=cx+ye) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==18) // slide\n\t\t\t{\n\t\t\tye=float(i+rn)/float(n+rd);\n\t\t\tuv2.x=uv.x;\n\t\t\tuv2.y=uv.y+ye;\n\t\t\tif (uv.y>=1.0-ye) MEM2\n\t\t\telse MEM1S\n\t\t\t}\n\t\telse if (type==19) // window right with soft edge\n\t\t\t{\n\t\t\tye=float(i)/float(n-1);\n\t\t\tyfe=ye+(10.0*sa);\n\t\t\tif (uv.x<=ye) MEM2\n\t\t\telse if (uv.x>yfe) MEM1\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tv1=(uv.x-ye)/(10.0*sa); if (v1>1.0) { v1=1.0; } v2=1.0-v1;\n\t\t\t\tMEM12\n\t\t\t\t}\n\t\t\t}\n\t\telse if (type==20) // inset down right\n\t\t\t{\n\t\t\tdx=float(i+rn)/float(n+rd);\n\t\t\tdy=float(i+rn)/float(n+rd);\n\t\t\tif (uv.x>=dx) MEM1\n\t\t\telse if (1.0-uv.y>=dy) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==21) // inset down left\n\t\t\t{\n\t\t\tdx=float(i+rn)/float(n+rd);\n\t\t\tdy=float(i+rn)/float(n+rd);\n\t\t\tif ((1.0-uv.x)>dx) MEM1\n\t\t\telse if (1.0-uv.y>=dy) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==22) // inset up right\n\t\t\t{\n\t\t\tdx=float(i+rn)/float(n+rd);\n\t\t\tdy=float(i+rn)/float(n+rd);\n\t\t\tif (uv.x>=dx) MEM1\n\t\t\telse if (uv.y>dy) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==23) // inset up left\n\t\t\t{\n\t\t\tdx=float(i+rn)/float(n+rd);\n\t\t\tdy=float(i+rn)/float(n+rd);\n\t\t\tif ((1.0-uv.x)>dx) MEM1\n\t\t\telse if ((uv.y)>dy) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==24) // pixelate\n\t\t\t{\n\t\t\t// this is simpler (not as good) as my original non-glsl code\n\t\t\tv1=float(n-(i+1))/float(n-1); v2=1.0-v1;\n\t\t\tif (i<n/2) { j=int(float(i)/(float(n)/2.0)*50.0); }\n\t\t\telse { j=int(float(n-i-1)/(float(n)/2.0)*50.0); }\n\t\t\tif (j<1) { j=1; }\n\t\t\tuv2.x=float(int(uv.x*iResolution.x/float(j))*j)/iResolution.x;\n\t\t\tuv2.y=float(int(uv.y*iResolution.y/float(j))*j)/iResolution.y;\n\t\t\tcol = v1 * (alt ? texture2D(iChannel1, uv2).xyz : texture2D(iChannel0, uv2).xyz) + v2 * (alt ? texture2D(iChannel0, uv2).xyz : texture2D(iChannel1, uv2).xyz);\n\t\t\t}\n\t\telse if (type==25) // fan in\n\t\t\t{\n\t\t\ttheta2=M_PI*float(i+rn)/float(n+rd);\n\t\t\tdy=1.0/4.0; dx=1.0/2.0; dy2=1.0*3.0/4.0;\n\t\t\txc1=M_PI/180.0*sa; cy=.5;\n\t\t\ttheta=atan2(abs(dx-uv.x),dy-uv.y);\n\t\t\ttheta3=atan2(abs(dx-uv.x),uv.y-dy2);\n\t\t\tif ((theta<theta2)||(theta3<theta2)) MEM2\n\t\t\telse if (abs(theta2-M_PI)<=.00001) MEM2\n\t\t\telse if ((theta<theta2+xc1)&&(uv.y<=cy)) { v1=(theta-theta2)/xc1; v2=1.0-v1; MEM12 }\n\t\t\telse if (theta3<theta2+xc1) { v1=(theta3-theta2)/xc1; v2=1.0-v1; MEM12 }\n\t\t\telse MEM1\n\t\t\t}\n\t\telse if (type==26) // fan out\n\t\t\t{\n\t\t\ttheta2=_TWOPI*float(i+rn)/float(n+rd);\n\t\t\tdx=1.0/4.0; dy=.5; dx2=1.0*3.0/4.0; cx=.5;\n\t\t\txc1=M_PI/180.0*sa;\n\t\t\ttheta=M_PI+atan2(1.0-uv.y-dy,dx-uv.x);\n\t\t\ttheta3=M_PI+atan2(1.0-uv.y-dy,uv.x-dx2);\n\t\t\tif (theta2<=M_PI)\n\t\t\t\t{\n\t\t\t\tif ((theta<theta2)&&(theta3<theta2)) MEM2\n\t\t\t\telse if ((theta<theta2+xc1)&&(uv.x<=cx)) { v1=(theta-theta2)/xc1; v2=1.0-v1; MEM12 }\n\t\t\t\telse if ((theta3<theta2+xc1)&&(uv.x>=cx)) { v1=(theta3-theta2)/xc1; v2=1.0-v1; MEM12 }\n\t\t\t\telse MEM1\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tif ((theta>theta2+xc1)&&(uv.x<=cx)) MEM1\n\t\t\t\telse if ((theta3>theta2+xc1)&&(uv.x>=cx)) MEM1\n\t\t\t\telse if (!((theta>theta2)&&(theta3>theta2))) MEM2\n\t\t\t\telse if (uv.x<=cx) { v1=(theta-theta2)/xc1; v2=1.0-v1; MEM12 }\n\t\t\t\telse { v1=(theta3-theta2)/xc1; v2=1.0-v1; MEM12 }\n\t\t\t\t}\n\t\t\t}\n\t\telse if (type==27) // fan up\n\t\t\t{\n\t\t\ttheta2=M_PI/2.0*float(i+rn)/float(n+rd);\n\t\t\tdy=0.0; dx=1.0/2.0; xc1=M_PI/180.0*sa;\n\t\t\ttheta=atan2(abs(dx-uv.x),1.0-uv.y);\n\t\t\tif (theta<theta2) MEM2\n\t\t\telse if (theta<theta2+xc1) { v1=(theta-theta2)/xc1; v2=1.0-v1; MEM12 }\n\t\t\telse MEM1\n\t\t\t}\n/*\n\t\t// I'm not even gonna try to convert this one\n\t\tcase 33: // roll\n\t\t\tmem1ts=(short *)calloc(sizeof(short),size);\n\t\t\tcx=w; cy=h;\n\t\t\ttheta=M_PI/2.0*((float)(i+rn)/(float)(n+rd));\n\t\t\tc1=cos(theta); s1=sin(theta);\n\t\t\tfor (y=0;y<h;y++)\n\t\t\t\t{\n\t\t\t\tfor (x=0;x<w;x++)\n\t\t\t\t\t{\n\t\t\t\t\ta=(y*w+x)*3;\n\t\t\t\t\tmem1ts[a]=mem1ts[a+1]=mem1ts[a+2]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tfor (yc0=0;yc0<h;yc0+=.5)\n\t\t\t\t{\n\t\t\t\tfor (xc0=0;xc0<w;xc0+=.5)\n\t\t\t\t\t{\n\t\t\t\t\txc1=xc0-(float)(cx); yc1=yc0-(float)(cy);\n\t\t\t\t\txc2=(xc1*c1-yc1*s1);\n\t\t\t\t\tyc2=(xc1*s1+yc1*c1);\n\t\t\t\t\tdx=(int)(xc2)+cx; dy=(int)(yc2)+cy;\n\t\t\t\t\ta2=(dy*w+dx)*3;\n\t\t\t\t\ta=((int)(yc0)*w+(int)(xc0))*3;\n\t\t\t\t\tif ((dx>=0)&&(dx<w)&&(dy>=0)&&(dy<h)) MEM1TS\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tfor (y=0;y<h;y++)\n\t\t\t\t{\n\t\t\t\tfor (x=0;x<w;x++)\n\t\t\t\t\t{\n\t\t\t\t\ta=(y*w+x)*3;\n\t\t\t\t\tif (mem1ts[a]>=0) MEM1TS1\n\t\t\t\t\telse MEM2\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tfree(mem1ts);\n\t\t\tbreak;\n*/\n\t\telse if (type==28) // bars\n\t\t\t{\n\t\t\tint v=int(fract(sin(dot(vec2(uv.y,0), vec2(12.9898, 78.233)))* 43758.5453)*float(n-1));\n\t\t\tif (i>v) MEM2 else MEM1\n\t\t\t}\n/*\n\t\t// I'm not even gonna try to convert this one\n\t\tcase 34: // slide up center\n\t\t\tmem1ts=(short *)calloc(sizeof(short),size);\n\t\t\tcx=w/2; cy=0;\n\t\t\trad=((float)(n-(i+1))/(float)(n+rd));\n\t\t\tfor (y=0;y<h;y++)\n\t\t\t\t{\n\t\t\t\tfor (x=0;x<w;x++)\n\t\t\t\t\t{\n\t\t\t\t\ta=(y*w+x)*3;\n\t\t\t\t\tmem1ts[a]=mem1ts[a+1]=mem1ts[a+2]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tfor (yc0=0;yc0<h;yc0+=1.0)\n\t\t\t\t{\n\t\t\t\tfor (xc0=0;xc0<w;xc0+=1.0)\n\t\t\t\t\t{\n\t\t\t\t\txc1=xc0-(float)(cx); yc1=yc0-(float)(cy);\n\t\t\t\t\txc2=rad*xc1;\n\t\t\t\t\tyc2=rad*yc1;\n\t\t\t\t\tdx=(int)(xc2)+cx; dy=(int)(yc2)+cy;\n\t\t\t\t\ta2=(dy*w+dx)*3;\n\t\t\t\t\ta=((int)(yc0)*w+(int)(xc0))*3;\n\t\t\t\t\tif ((dx>=0)&&(dx<w)&&(dy>=0)&&(dy<h)) MEM1TS\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tfor (y=0;y<h;y++)\n\t\t\t\t{\n\t\t\t\tfor (x=0;x<w;x++)\n\t\t\t\t\t{\n\t\t\t\t\ta=(y*w+x)*3;\n\t\t\t\t\tif (mem1ts[a]>=0) MEM1TS1\n\t\t\t\t\telse MEM2\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tfree(mem1ts);\n\t\t\tbreak;\n*/\n\t\telse if (type==29) // diagonal down right\n\t\t\t{\n\t\t\trad=sqrt(2.0+2.0)*(1.0-(float(i+rn)/float(n+rd)));\n\t\t\tslope=-1.0/1.0;\n\t\t\ttheta=atan(-slope);\n\t\t\txc1=rad*cos(theta); yc1=rad*sin(theta);\n\t\t\tb=yc1-slope*xc1-sa;\n\t\t\tcy=b; cx=(-b/slope);\n\t\t\tdy=abs(uv.y);\n\t\t\tdx=abs(1.0-uv.x);\n\t\t\t//if (dx>cx-sa) MEM2\n\t\t\tif (dy>slope*dx+cy+sa) MEM2\n\t\t\telse if (dy>slope*dx+cy) { v2=(dy-(slope*dx+cy))/(sa); v1=1.0-v2; MEM12 }\n\t\t\telse MEM1\n\t\t\t}\n\t\telse if (type==30) // diagonal cross out\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\trad=sqrt(cx*cx+cy*cy)/2.0*(float(i+rn)/float(n+rd));\n\t\t\tslope=-cy/cx;\n\t\t\ttheta=atan(-slope);\n\t\t\txc1=rad*cos(theta); yc1=rad*sin(theta);\n\t\t\tb=yc1-slope*xc1;\n\t\t\tcy=b; cx=(-b/slope); vy1=sa;\n\t\t\tdy=(uv.y-.5);\n\t\t\tdx=(uv.x-.5);\n\t\t\tif (!(((dy>slope*dx+cy)||(dy<slope*dx-cy))&&((dy>(-slope)*dx+cy)||(dy<(-slope)*dx-cy)))) MEM2\n\t\t\telse if ((sa!=0.0)&&(!(((dy>slope*dx+cy+vy1)||(dy<slope*dx-cy-vy1))&&\n\t\t\t\t((dy>(-slope)*dx+cy+vy1)||(dy<(-slope)*dx-cy-vy1)))))\n\t\t\t\t{\n\t\t\t\tif ((dx>=0.0)&&(dy>=0.0))\n\t\t\t\t\t{\n\t\t\t\t\tv1=v2=0.0;\n\t\t\t\t\tif (dy>-slope*dx) { v1=(dy-(-slope*dx+cy))/vy1; v2=1.0-v1; }\n\t\t\t\t\telse { v1=((-slope*dx-cy)-dy)/vy1; v2=1.0-v1; }\n\t\t\t\t\tMEM12\n\t\t\t\t\t}\n\t\t\t\telse if ((dx<0.0)&&(dy<0.0))\n\t\t\t\t\t{\n\t\t\t\t\tv1=v2=0.0;\n\t\t\t\t\tif (dy>-slope*dx) { v1=(dy-(-slope*dx+cy))/vy1; v2=1.0-v1; }\n\t\t\t\t\telse { v1=((-slope*dx-cy)-dy)/vy1; v2=1.0-v1; }\n\t\t\t\t\tMEM12\n\t\t\t\t\t}\n\t\t\t\telse if ((dx>=0.0)&&(dy<0.0))\n\t\t\t\t\t{\n\t\t\t\t\tv1=v2=0.0;\n\t\t\t\t\tif (dy>slope*dx) { v1=(dy-(slope*dx+cy))/vy1; v2=1.0-v1; }\n\t\t\t\t\telse { v1=((slope*dx-cy)-dy)/vy1; v2=1.0-v1; }\n\t\t\t\t\tMEM12\n\t\t\t\t\t}\n\t\t\t\telse if ((dx<0.0)&&(dy>=0.0))\n\t\t\t\t\t{\n\t\t\t\t\tv1=v2=0.0;\n\t\t\t\t\tif (dy>slope*dx) { v1=(dy-(slope*dx+cy))/vy1; v2=1.0-v1; }\n\t\t\t\t\telse { v1=((slope*dx-cy)-dy)/vy1; v2=1.0-v1; }\n\t\t\t\t\tMEM12\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse MEM1\n\t\t\t}\n\t\telse if (type==31) // increasing gear with soft edge\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\tro=sqrt(cx*cx+cy*cy)/.9*float(i+rn)/float(n+rd);\n\t\t\tif (roto) { vy1=float(i+rn-1)/float(n+rd)*rota*M_PI/180.0; }\n\t\t\telse { vy1=0.0; }\n\t\t\tri=ro*.9;\n\t\t\tpo.x=po.y=0.0;\n\t\t\tangt=5.0;\n\t\t\tangs=2.5;\n\t\t\ttang=(angt+angs)*2.0;\n\t\t\tang=tang*M_PI/180.0;\n\t\t\tyc1=uv.y-cy;\n\t\t\txc1=(uv.x-cx)/aspect;\n\t\t\ttheta=atan2(xc1,yc1);\n\t\t\ttheta2=fmod(theta+M_PI+vy1,ang);\n\t\t\tif (theta2<=angt*M_PI/180.0) { r1=r2=ri; ang2=angt; ang1=theta2; }\n\t\t\telse if (theta2<=(angt+angs)*M_PI/180.0) { r1=ri; r2=ro; ang2=angs; ang1=theta2-angt*M_PI/180.0; }\n\t\t\telse if (theta2<=(angt+angs+angt)*M_PI/180.0) { r1=r2=ro; ang2=angt; ang1=theta2-(angt+angs)*M_PI/180.0; }\n\t\t\telse { r1=ro; r2=ri; ang2=angs; ang1=theta2-(angt+angs+angt)*M_PI/180.0; }\n\t\t\tang2*=(M_PI/180.0);\n\t\t\tp1.x=r1; p1.y=0.0; p2.x=r2*cos(ang2); p2.y=r2*sin(ang2);\n\t\t\tpd.x=cos(ang1); pd.y=sin(ang1);\n\t\t\tr=intersect(po,pd,p1,p2);\n\t\t\tr2=sqrt(xc1*xc1+yc1*yc1);\n\t\t\tif (r2>r+sa) { MEM1 } else if (r2>r) { v1=(r2-r)/(sa); v2=1.0-v1; MEM12 } else { MEM2 }\n\t\t\t}\n        else if (type==32) // rotating expanding square with fade in new/fade out old\n\t\t\t{\n            float x = mod(iTime,1.); // change this to alter the speed\n   \n            x=smoothstep(.0,1.0,(x*2.0+uv.x-1.0));\n            col= mix(texture(iChannel0,(uv-.5)*(1.-x)+.5).rgb, texture(iChannel1,(uv-.5)*x+.5).rgb, x);  \n            }\n\t\telse if (type==33) // rotating expanding square with fade in new/fade out old\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\ttheta=-_TWOPI*(float(i+rn)/float(n+rd));\n\t\t\tc1=cos(theta); s1=sin(theta);\n\t\t\trad=(float(n-(i+1))/float(n+rd));\n\t\t\txc0=uv.x; yc0=uv.y;\n\t\t\txc1=xc0-cx; yc1=yc0-cy;\n\t\t\txc2=rad*(xc1*c1-yc1*s1);\n\t\t\tyc2=rad*(xc1*s1+yc1*c1);\n\t\t\tuv2.x=xc2*aspect+cx; uv2.y=yc2+cy;\n\t\t\tif ((uv2.x>=0.0)&&(uv2.x<=1.0)&&(uv2.y>=0.0)&&(uv2.y<=1.0)) { col3 = alt ? texture2D(iChannel1, uv2).xyz : texture2D(iChannel0, uv2).xyz; }\n\t\t\telse { col3 = alt ? col1 : col2; }\n\t\t\tv1=float(n-(i+1))/float(n-1); v2=1.0-v1;\n\t\t\t//col=col3;\n\t\t\tcol = alt ? v1*col3+v2*col1 : v1*col3+v2*col2;\n\t\t\t}\n\nfragColor = vec4(col, 1.0);\n}\n\nfloat intersect(vec2 origin, vec2 direction, vec2 point1, vec2 point2)\n{\nvec2 v1, v2, v3;\nfloat dot, t1, t2;\n\nv1.x = origin.x - point1.x;\nv1.y = origin.y - point1.y;\nv2.x = point2.x - point1.x;\nv2.y = point2.y - point1.y;\nv3.x = -direction.y;\nv3.y = direction.x;\ndot = v2.x * v3.x + v2.y * v3.y;\nif (abs(dot) < 0.000001) return(-1000.0);\nt1 = (v2.x * v1.y - v2.y * v1.x) / dot;\nt2 = (v1.x * v3.x + v1.y * v3.y) / dot;\nif ((t1 >= 0.0) && (t2 >= 0.0) && (t2 <= 1.0)) return(t1);\nreturn(-1000.0);\n}\n", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//#define DO_SHADOW\n#define CAMERA_ZOOM 1.5\n#define ITER 150\n#define NEAR 0.005\n#define CHEAPER_NORMAL\n#define FAKE_AMBIENT // fake ambient occlusion/shadows\n\nconst float PI = 3.141592;\n\nmat2 rot(float a) {\n  float s = sin(a), c = cos(a);\n  return mat2(c, -s, s, c);\n}\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\nfloat noise(vec2 n) {\n  return fract(sin(dot(n, vec2(12.2437, 4.5671))) * 43758.1345);\n}\n\n//Functions from http://mercury.sexy/hg_sdf/ :\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\nfloat fOpDifferenceRound (float a, float b, float r) {\n\treturn fOpIntersectionRound(a, -b, r);\n}\nfloat fOpPipe(float a, float b, float r) {\n\treturn length(vec2(a, b)) - r;\n}\n\n\n#define TUBE_LIGHTS_COUNT 4\n\nfloat TubeLightsLuminosity[TUBE_LIGHTS_COUNT] = float[TUBE_LIGHTS_COUNT](1.5,1.5,1.5,1.5);\n\nconst vec3 Colors[3] = vec3[3](vec3(1, 1, .6), vec3(1, 0, 0), vec3(.3, 1, .3));\n\nconst int LightColors[TUBE_LIGHTS_COUNT] = int[4](0, 0, 2, 1);\n\nconst vec3 TubeLightPositions[TUBE_LIGHTS_COUNT] =\n    vec3[TUBE_LIGHTS_COUNT](\n        vec3(3.5, 3, 5), \n        vec3(-3.5, 3, 5), \n        vec3(-3.5, 3, 35),\n        vec3(3.5, 3, 35) // last light is the flickering one\n    );\n\n\n// Instead of returning the distance to the capsule,\n// return the nearest position on the surface of capsule, from p\n// Used for lighting calculations as we can calculate the light\n// assuming it all comes from the nearest position on the light\n\n// Also now returns the signed distance in the w channel of the vec4,\n// because the distance to the position is unsigned which means backtracking breaks\nvec4 capsulePos(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  vec3 np = a + ba * h;\n  return vec4(\n    np + r * normalize(p - np), //the position\n    length( pa - ba*h ) - r     //the signed distance\n  );\n}\n\nvec4 getLightPos(vec3 p, int i) {\n  vec3 lp = TubeLightPositions[i];\n  return capsulePos(p, lp + vec3(0, 0, -5), lp + vec3(0, 0, 5), .2);\n}\n\nfloat corridorPrism(vec3 p, float l) {\n  vec3 pp = p;\n  pp.xy *= rot(PI / 4.);\n  p.y += .375;\n  return min(-box(p, vec3(5, 4.125, l)), -box(pp, vec3(5., 5., l)));\n}\n\nfloat dividers(vec3 p) {\n  p.z -= 5.;\n  p.z = mod(p.z, 30.) - 15.; // repeat them every 30 units\n  return fOpPipe(corridorPrism(p, 0.), corridorPrism(p, 2.), .8);\n}\n\nfloat floorHole(vec3 p) {\n  p.y+=4.;\n  float b = box(p, vec3(1.9, 1, 50));\n  p.xz = mod(p.xz,vec2(.4,2))-vec2(.2,1);\n  p.y+=1.;\n  return min(b, box(p,vec3(.1,.4,.8)));\n}\n\nfloat octoRoom(vec3 p) {\n  const float radius = 5.;\n  const float edgeSize = radius * 2. * sin(PI / 8.);\n  float div = dividers(p);\n  float fh = floorHole(p);\n  // Add the wall bumps:\n  p.x += sign(p.x) * pow(abs(cos((p.y / edgeSize) * PI * 4.6 - 0.1)), .6) * .2;\n  return fOpDifferenceRound(min(div, corridorPrism(p, 50.)), fh,.1);\n}\n\nfloat nearestLight(vec3 p) {\n  float d = 999.;\n  float lum = 0.;\n  for (int i = 0; i < TUBE_LIGHTS_COUNT; i++) {\n    d = min(d, getLightPos(p, i).w);\n  }\n  return d;\n}\n\nfloat glowDist = 999.;\nint glowColor = 0;\nfloat computeLight(vec3 p) {\n  float d = 999.;\n  float lum = 1.;\n  for (int i = 0; i < TUBE_LIGHTS_COUNT; i++) {\n    float diff = getLightPos(p, i).w;\n    if (diff < d) {\n      lum = sqrt(TubeLightsLuminosity[i]);\n      glowColor = LightColors[i];\n    }\n    d = min(d, diff);\n  }\n  glowDist = min(glowDist, d / lum);\n  return d;\n}\n\nfloat sdfForNormals(vec3 p) { return min(octoRoom(p), nearestLight(p)); }\n\nfloat sdfWithLighting(vec3 p) { return min(octoRoom(p), computeLight(p)); }\n\nvec3 norm(vec3 p) {\n  vec2 ss = vec2(0.001, 0.);\n#ifdef CHEAPER_NORMAL\n  return normalize(sdfForNormals(p) - vec3(sdfForNormals(p - ss.xyy),\n                                           sdfForNormals(p - ss.yxy),\n                                           sdfForNormals(p - ss.yyx)));\n#else\n  float gx = sdfForNormals(p + ss.xyy) - sdfForNormals(p - ss.xyy);\n  float gy = sdfForNormals(p + ss.yxy) - sdfForNormals(p - ss.yxy);\n  float gz = sdfForNormals(p + ss.yyx) - sdfForNormals(p - ss.yyx);\n  return normalize(vec3(gx, gy, gz));\n#endif\n}\n\nfloat rm(vec3 ro, vec3 rd) {\n  float td = 0.;\n  for (int i = 0; i < ITER; i++) {\n    float d = sdfWithLighting(ro + rd * td);\n    td += d;\n    if (abs(d) < NEAR || td > 999.)\n      break;\n  }\n  return td;\n}\n\nvec3 singleLight(vec3 p, vec3 n, vec3 rd, int i) {\n  vec3 lp = getLightPos(p, i).xyz;\n  vec3 d = normalize(lp - p);\n  float diffuse = clamp(dot(n, d), 0.1, 1.);\n  float sh = 1.;\n#ifdef DO_SHADOW\n  p += n * .01;\n  if (rm(p, d) < length(lp - p) - .5) {\n    sh = .5;\n  }\n#endif\n  float specular = dot(d, reflect(rd, n));\n  specular = pow(clamp(specular, 0.0, 1.0), 200.);\n  return ((specular + diffuse) * clamp(1. / length(lp - p), 0., 1.) * sh) *\n         TubeLightsLuminosity[i] * Colors[LightColors[i]];\n}\n\nvec3 light(vec3 p, vec3 rd) {\n  vec3 tl = vec3(0.);\n  vec3 n = norm(p);\n  for (int i = 0; i < TUBE_LIGHTS_COUNT; i++) {\n    tl += singleLight(p, n, rd, i);\n  }\n#ifdef FAKE_AMBIENT\n  tl *= clamp(sdfForNormals(p + n * .2) / .2, .5, 1.);\n#endif\n  return tl;\n}\n\nvec3 color(vec3 p) {\n  return vec3(1.); // white\n  // return vec3(\n  //    smoothstep(.2,.3,abs(sin(p.z * 5.)))\n  //);\n}\n\nvec3 lightGlow() {\n  return Colors[glowColor] * (1. - clamp(pow(glowDist, .4), 0., 1.));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  vec2 fragUV = (fragCoord - iResolution.xy * .5) / iResolution.x;\n  vec3 ro = vec3(0,-1,-30);\n  ro.z += mod((iTime * 3.), 55.); // repeating forwards motion\n  ro.y += sin(iTime * 5.) * 0.1; // head-up-down\n  ro.x += sin(iTime * 2.5) * 0.1; // head left-right each \"step\"\n  \n\n  TubeLightsLuminosity[3] = clamp(\n      (sin(iTime * 2.234) + \n      sin(iTime * 4.324) + \n      sin(iTime * 60.) * 0.5) * 2., 0., 1.); //flicker > 0 ? 1 : 0\n  \n  vec3 rd = normalize(vec3(fragUV, CAMERA_ZOOM));\n  if (iMouse.z > 0.) {\n    rd.yz *= rot(-PI * (iMouse.y - iResolution.y * .5) / iResolution.y);\n    rd.xz *= rot(-2. * PI * (iMouse.x - iResolution.x * .5) / iResolution.x);\n  }\n\n  float dist = rm(ro, rd);\n  vec3 p = ro + rd * dist;\n\n  // Calculate the Lighting+Texture at point p:\n  vec3 c = lightGlow() + light(p, rd) * color(p);\n\n  // Add distance Fog:\n  vec3 fogColor = vec3(.1, 0, 0);\n  float fogDensity = .02;\n  c = mix(c, fogColor, 1. - exp(-dist * fogDensity));\n\n  // Add noise:\n  c += noise(fragCoord * iTime) * .03;\n\n  // Final result:\n  fragColor = vec4(c, 1.);\n}", "buffer_a_inputs": [], "buffer_b_code": "#define pmod(p,m) (mod(p,m)-.5*(m))\n#define time (iTime*.6)\n#define NYQ (.5*iSampleRate)\n#define fft(oct) (texture(iChannel0, vec2(0.,1024./NYQ*pow(2., (oct)))).r)/FFTMAX\n#define BPM 120.\n// this was supposed to use texFFTIntegrated but uh idk how to do that\n// also it seems to want a vec2 which is silly... it's a 1d texture...\n#define fftint(oct) texture(iChannel0, vec2(0.,.5*1024./NYQ*pow(2., (oct)))).g/FFTMAX\n\n#define v2Resolution iResolution\n\nfloat FFTMAX = 1.;\n\nfloat ffta(float a, float b) {\n  float iter=10.;\n  float x=0.;\n  for (float i=0.;i<1.;i+=1./iter) x+=fft(mix(a,b,i));\n  return x/iter;\n}\nfloat fftinta(float a, float b) {\n  float iter=10.;\n  float x=0.;\n  for (float i=0.;i<1.;i+=1./iter) x+=fftint(mix(a,b,i));\n  return x/iter;\n}\n\nmat2 hexel = mat2(2., 0., -1., sqrt(3.))/3.;\nmat2 pixel = mat2(3.,0.,sqrt(3.),2.*sqrt(3.))/2.;\n\nvec3 to_cubic(vec2 p) { return vec3(p.x, -p.y-p.x, p.y); }\n\nvec3 round_cubic(vec3 p, float m) {\n  p *= m;\n  vec3 r = round(p);\n  \n  vec3 d = abs(p-r);\n  vec3 alt = -r.yzx-r.zxy;\n  float big = max(d.x,max(d.y,d.z));\n  \n  return mix(r, alt, step(big, d))/m;\n}\n\nfloat box(vec3 p, vec3 a) {\n  vec3 q = abs(p)-a;\n  return length(max(q,0.))+min(0., max(q.x, max(q.y,q.z)));\n}\n\nfloat sphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nmat2 rot(float a) {float s=sin(a),c=cos(a); return mat2(c,s,-s,c); }\n\nfloat boxle(vec3 p, float r, float m) {\n  r*=.8;\n  float o = .1+.3*ffta(0.,2.);\n  float B = box(p, vec3(r))-1.2*o;\n  \n  float S = sphere(p+vec3(mix(-.8,1.,2.*o)), m*r)-o;\n  return max(B,-S);\n}\nfloat glow=0.;\nfloat MAT=-1.;\nfloat S(vec3 p) {\n  // i don't know how to get the equivalent of bonzo's texFFTIntegrated out of this texture\n  float tt=mix(time, fftinta(7.,9.), 0.);\n  float T=floor(tt);\n  float t=fract(tt);\n  \n\n  //t=mix(t, smoothstep(0.,1.,t),.5);\n  glow+=.01;\n  float O = 1001.;\n  \n  for (float i=0.; i<3.; i+=1.) {\n    float r=t+i;\n    //if (r < -.5) continue;\n    p.xz *= rot(.8*log(1.+r*r));\n    //p.xy *= rot(r*.8);\n    p.yz *= rot(r*.2);\n    float B = boxle(p, r, 1.+log(1.+.3*r));\n    \n    if (B<O) MAT=mod(T-i+9.,3.);\n\n    O = min(O, B);\n\n  }\n  return O;\n}\n\n#define MISS(d) (d > 1000.)\n\nfloat ray(vec3 p, vec3 dir) {\n  float d=0.;\n  for (int i=0;i<500;i++) {\n    float c = S(p+d*dir);\n    d+=c;\n    if (c<.00001) return d;\n    if (MISS(d)) return d;\n  }\n  return 1001.;\n}\n\nvec3 normal(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(1e-4);\n  return normalize(S(p) - vec3(S(k[0]), S(k[1]), S(k[2])));\n}\n#define desat(x, R) mix(x, vec3(x.r+x.g+x.b)/3., R)\n\n#define TAU (2*acos(-1))\n#define nsin(x) (.5+.5*sin(TAU*(x)))\n\n\nvec3 light(vec3 cam, vec3 dir, float dist, vec3 hex, float mat) {\n  vec3 hit = cam + dir*dist;\n  \n  vec3 n = normal(hit);\n  \n  float diff = dot(dir, -n);\n  vec3 rdir = reflect(dir,n);\n  \n  vec3 C = vec3(diff);\n  vec3 T;\n  if (mat<1.) { T= texture(iChannel1, rdir).xyz; }\n  else if (mat<2.) { T= texture(iChannel2, rdir).xyz; }\n  else { T= texture(iChannel3, rdir).xyz; }\n  \n  C = mix(C,T,.5);\n  \n  \n  return C;\n}\n\n\n#define gmix(a, b, q) ((a)*pow((b)/(a), (q))) \n\n#define tri(x) (abs(fract(x)-.5)*2.)\n#define bump(x) (sqrt(abs(sin(x))))\n\nfloat hex_dist = .5*sqrt(3.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = gl_FragCoord.xy / v2Resolution.xy - .5;\n  vec2 uu = gl_FragCoord.xy / v2Resolution.xy;\n  uv.x *= v2Resolution.x/v2Resolution.y;\n  \n  uv *= rot(time*.5);\n  \n  float res = gmix(20., 100., ffta(2., 6.));\n  \n  vec2 axial = uv * hexel;\n  vec3 cubic = to_cubic(axial);\n  \n  \n  \n  vec3 hex = round_cubic(cubic, res);\n  vec2 hex_center = hex.xz*pixel;\n  \n  float center_d = length(hex_center-uv);\n  \n  if (center_d > .9*hex_dist/res) {\n    fragColor = vec4(0.);\n    return;\n  }\n  \n  vec3 cam = vec3(0,0,-2);\n  cam -= vec3(0,0,.5);\n  vec3 dir = normalize(vec3(hex_center, 1));\n  vec3 real_dir = normalize(vec3(uv,1));\n  \n  float dist = ray(cam, dir);\n  \n    vec3 C;\n    \n  \n\n  \n  if (MISS(dist)) {\n    C = hex;\n  }\n  else {\n    C = light(cam,dir,dist,hex,MAT);\n  }\n    glow=0.;\n  float real_dist = ray(cam+vec3(0,0,.5), real_dir);\n  \n  //if (MISS(dist) || real_dist < dist) C-=(1.-desat(hex,.5))*glow;\n  \n  fragColor = vec4(sqrt(C), 0.);\n}", "buffer_b_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define time (iTime*.5)\n#define v2Resolution iResolution\n#define out_color fragColor\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax,p,cos(ro))+cross(ax,p)*sin(ro);\n}\n\nfloat sphere(vec3 p, float r) {\n  return length(p)-r;\n}\n\nfloat box(vec3 p, vec3 a) {\n  vec3 q = abs(p)-a;\n  return length(max(q,0.))+min(0., max(q.x,max(q.y,q.z)));\n}\n\nmat2 rot(float x) { float s=sin(x),c=cos(x); return mat2(c,s,-s,c); }\n\nfloat roundunion(float d1, float d2, float amt) {\n  float m = min(d1, d2);\n\n  vec2 d = clamp(vec2(d1, d2),-amt,amt);\n  \n  return min(m, amt-length(d-amt)); //max(m,length(vec2(d1,d2))-.5);\n}\n\nfloat roundint(float d1, float d2, float amt) {\n  float m = max(d1, d2);\n  vec2 d= clamp(vec2(d1,d2),-amt,amt);\n  return max(m, -(amt-length(d+amt)));\n}\n\n\nfloat chamfunion(float d1, float d2, float amt) {\n  float m = min(d1, d2);\n  vec2 d = max(vec2(d1,d2),0.);\n  \n  return min(m, (d.x+d.y-amt)/sqrt(2.)); //max(m,length(vec2(d1,d2))-.5);\n}\n\nfloat chamfint(float d1, float d2, float amt) {\n  float m = max(d1, d2);\n  \n  vec2 d = min(vec2(d1,d2),0.);\n  \n  //return m;\n  return max(m, (d.x+d.y+amt)/sqrt(2.));\n}\n\n\n\nfloat smoothsubtract(float d1, float d2, float k) {\n  float h = clamp(.5-.5*(d2+d1)/k, 0., 1.);\n  return mix(d2, -d1, h) + k*h*(1.-h);\n}\n\n#define gmix(A,B,Q) ((A)*pow((B)/(A), Q))\nfloat COL;\n#define tri(x) (abs(fract(x)-.5)*2.)\nfloat scene(vec3 p) {\n  float perz=3.;\n  p.xz *= rot(sin(time)*.4);\n  //p.z = mod(p.z, perz)-.5*perz;\n  //p.xy *= rot(time);\n  p.x -= .3;\n  p.y -=.2;\n  \n  float perxy = 2.8;\n  vec2 newxy = mod(p.xy, perxy)-.5*perxy;\n  vec2 cell = p.xy-newxy;\n  COL = cos(time)*cell.x+sin(time)*cell.y;\n  p.xy = newxy;\n  \n  //p.xz *= rot(3.14/3.);\n  //p.yz *= rot(1.);\n  p = erot(p, normalize(vec3(-1,.2,.8)), time*.5);\n  float cube = box(erot(p, normalize(vec3(.1,.1,0)), time*8.), vec3(1,1,1))-.2;\n  float amt = 2.*(.5+.5*tri(time));\n  \n  float per = .555;\n  vec3 sphc = mod(erot(p, vec3(0,0,1), time), per)-.5*per;\n  float sph = sphere(sphc, .4);\n  \n  float sph2 = sphere(p, 1.);\n  //return max(-sph,cube);\n  float sparkle = chamfint(-sph,cube, .01);\n  return sparkle;\n  \n  return gmix(sph2, sparkle, sin(time)*.5+.5);\n}\n\n#define MISS(x) ((x)>1000.)\n\nfloat ray(vec3 p, vec3 dir) {\n  float d=0.;\n  for (int i=0;i<300;i++) {\n    float c=scene(p+dir*d);\n    d+=c;\n    if (c < .00001) return d;\n    if (MISS(d)) return 1001.;\n  }\n  \n  return d;\n}\n\nvec3 grad(vec3 p) {\n  mat3 K = mat3(p,p,p)-mat3(.001);\n  return scene(p) - vec3(scene(K[0]), scene(K[1]), scene(K[2]));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / v2Resolution.xy - .5;\n  vec2 uu = fragCoord.xy / v2Resolution.xy;\n  uv.x *= v2Resolution.x/v2Resolution.y;\n  \n  vec3 cam = vec3(0,0,-20);\n  vec3 dir = normalize(vec3(uv, 1));\n  \n  float dist = ray(cam, dir);\n  \n  vec3 C;\n  if (MISS(dist)) {\n    C = vec3(0);\n  }\n  else {\n    vec3 hue = floor(mod(vec3(1,3,5)+COL-.5, 10.))*.1+.05;\n    vec3 normal = normalize(grad(cam+dir*dist));\n    float diff = length(sin(3.*normal+vec3(1,2,2))*.5+.5)/sqrt(3.);\n    C = vec3(diff*diff)*hue;\n\n  }\n  \n\n  out_color = vec4(sqrt(C), 0.);\n}\n\n\n", "buffer_c_inputs": [], "buffer_d_code": "/******\nThanks the Shader Showdown Scene folks for all the fun ! \n\n\nObrigado Inercia organiser jeenio, ps, alien and also all folks that participated !\n\n\n\n# \n    This is the first scripted shader showdown / royale entry.\n    It was 'coded' live before the event, the bonzomatic network message has been recoreded via a script, \n    and then was replayed step by step thanks to another script and the bonzomatic network\n    during the Intercia 2021 Shader Royale\n#\n\n--- \n/******\nThis work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. \n\n== Do not buy NFT ==\n== Do not make NFT with Creative-Commons artworks ==\n== If you respect the art and the artists, remember and apply this ==\n\n01000110011101010110001101101011 011011100110011001110100\n\n                                                                               \n _|_|_|_|                      _|            _|      _|  _|_|_|_|  _|_|_|_|_|  \n _|        _|    _|    _|_|_|  _|  _|        _|_|    _|  _|            _|      \n _|_|_|    _|    _|  _|        _|_|          _|  _|  _|  _|_|_|        _|      \n _|        _|    _|  _|        _|  _|        _|    _|_|  _|            _|      \n _|          _|_|_|    _|_|_|  _|    _|      _|      _|  _|            _|      \n                                                                          \n\n01000110011101010110001101101011 011011100110011001110100\n\n******/\n\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat box2(vec2 p,vec2 b){\n    vec2 q = abs(p)-b;\n     return length(max(vec2(0.),q))+min(0.,max(q.x,q.y));\n  }\n \nvec2 sdf(vec3 p){\n  p.y -=.2;\n    p.xy *=rot(-.785*.5);\n  float bump = fract(iTime);\n  vec2 h;\n  vec3 hp = p;\n  hp.y -=1.;\n  hp.x +=1.;\n  h.x =  max(abs(hp.z)-.1-bump,box2(hp.xy,vec2(.5)));\n  h.y = 1.;\n  \n  vec2 t;\n  vec3 tp = p;\n  tp.x +=1.;\n  tp.y +=1.;\n  t.x =  max(abs(tp.z)-.1-bump,box2(tp.xy,vec2(.5,1.)));\n  t.y = 1.;\n  \n  h = t.x < h.x ? t:h;\n  \n  tp = p;\n  tp.y+=.3;\n  tp.x +=.1;\n  t.x = max(abs(tp.z)-.1-bump,length(tp.xy)-1.75);\n  t.x = max(-tp.x+.1,t.x);\n  \n  float tt  = max(abs(tp.z)-.2-bump,length(tp.xy)-1.);\n  tt = max(-tp.x,tt);\n  t.x= max(-tt,t.x);\n  t.y = 2.;\n  \n    h = t.x < h.x ? t:h;\n  return h;\n  }\n#define q(s) s*sdf(p+s).x\n  vec3 norm(vec3 p,float ee){vec2 e=vec2(-ee,ee);return normalize(q(e.xyy)+q(e.yxy)+q(e.yyx)+q(e.xxx));}\nfloat diam2(vec2 p,float s){\n    p = abs(p);\n    return (p.x+p.y-s)*inversesqrt(3.);\n}\nvec3 txt(vec2 uv){\n  uv*=4.;\n  uv = vec2(log(length(uv)),atan(uv.y,uv.x))*3.1415;\n  uv.x -=iTime;\n  vec2 id = floor(uv);\n  uv = fract(uv)-.5;\n     vec3 col = vec3(.8,.2,.2);\n  if(mod(id.x,2.)==0.){\n       uv*=4.;\n       uv.y +=iTime;\n       uv = fract(uv)-.5;\n    col = vec3(.2,.8,.2);\n    }\n  float d = diam2(uv,.2);\n  d=  mix(d,abs(d)-.01,asin(sin(uv.x+uv.y))); // NOT SQUIDGAME \n  d=  smoothstep(1.7*fwidth(d),0.,d);\n \n  return .5*col*d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n  vec3 col = txt(uv);\n  \n  vec3 ro = vec3(sin(iTime),0.,-5.);\n  vec3 rt = vec3(0.);\n  vec3 rp = ro;\n  vec3 z = normalize(rt-ro);\n  vec3 x = normalize(cross(z,vec3(0.,-1.,0.)));\n  vec3 y = normalize(cross(z,x));\n\n  vec3 rd = mat3(x,y,z)*normalize(vec3(uv,1.));\n  vec3 light = vec3(1.,2.,-3.);\n  vec3 acc = vec3(0.);\n  float time = mod(iTime,10.);\nfor(float i=0.;i<=128.;i++){\n    vec2 d = sdf(rp);\n     \n     \n     if(time < 5. && length(rp-vec3(.25,.1,.0)) >.6 ) acc += (d.y ==1. ? vec3(.2,.9,.2):vec3(.9,.2,.2))*exp(-abs(d.x))/(50.-min(40.,fract(iTime)*50.));\n     if(time < 5. &&  fract(iTime+ length(rp)*.5)<0.5){  d.x = max(.001,abs(d.x));}\n    \n    if(d.x <.0001){\n        vec3 n = norm(rp,.001);\n        vec3 nn = norm(rp,.01);\n        float diff = max(0.,dot(normalize(light-rp),n));\n        float spc = max(0.,dot(normalize(light-ro),reflect(-normalize(light),n)));\n      spc  = pow(spc,32.);\n        if(d.y == 1.){\n             col = vec3(.2,.9,.2)*diff;\n        }  else {\n             col = vec3(.9,.2,.2)*diff;\n          \n          }\n         col = time < 5. ?col : mix(col, col*step(.2,length(nn-n)),floor(asin(sin(rp.y+iTime)*.5)*10.)*.5+.5);\n         col +=spc*vec3(1.);\n      break;\n      }\n      rp +=rd*d.x;\n  \n  }  \n  col +=acc;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_d_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st33zS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20078, 20078, 20150, 20150, 20573]], "test": "untested"}
{"id": "slcGRS", "name": "Persian carpet 9", "author": "jarble", "description": "A Persian carpet pattern generator.", "tags": ["fractal", "snowflake", "carpet", "rug"], "likes": 4, "viewed": 283, "published": 3, "date": "1636243690", "time_retrieved": "2024-07-30T18:49:59.312314", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(-2.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 4.5/2.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float t2 = +floor((iTime)/10.0+uv.x);\n    vec3 random1 = (hash31(t2)-vec3(.5))/4.;\n    vec3 random2 = (hash31(1.+t2)-vec3(.5))/4.;\n    vec3 random3 = (hash31(2.+t2)-vec3(.5))/4.;\n    vec3 random4 = (hash31(3.+t2)-vec3(.5))/4.;\n    \n    float offset = .5;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        for(int i=0;i<3;i++)\n        {\n            float factor = 1.25;\n            float l1 = col.x;\n            \n            uv = triangle_wave(uv.yx+l1+offset,scale)+triangle_wave(uv,scale);\n            uv.x *= -factor;\n            \n            for(int k = 0; k < 3; k++){\n                uv = triangle_wave((uv+uv.yx*vec2(random1[k],random2[k])-l1+offset)/(random4[k]+1.),scale+random3[k]);\n                uv.x /= -factor;\n                //uv += vec2(random1[k],random2[k])*l1;\n        \n            }\n            \n\n            scale *= 1./(1.+l1);\n\n            //scale2 *= 2. - l1;\n\n            col = col.yxz;\n            col[c] = fract((uv.x)-(uv.y));\n\n\n        }\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slcGRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[278, 388, 410, 456, 589], [591, 591, 630, 630, 675], [677, 677, 734, 734, 1944]], "test": "untested"}
{"id": "NtdGWH", "name": "Take a closer look", "author": "Plento", "description": "log infinite zooms are fun", "tags": ["2d", "fractal", "julia", "mouse", "zoom", "polar", "log"], "likes": 17, "viewed": 374, "published": 3, "date": "1636243538", "time_retrieved": "2024-07-30T18:50:00.154063", "image_code": "// Cole Peterson (Plento).\n\n#define R iResolution.xy\n#define m ((iMouse.xy - .5*R.xy) / R.y)\n#define ss(a, b, x) smoothstep(a, b, x)\n#define t iTime\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nvec2 jules(vec2 uv){\n    vec2 id = floor(uv);\n    uv = fract(uv)-.5;\n    \n    if(int(id.x) % 2 == 0) uv.x *= -1.;\n    if(int(id.y) % 2 == 0) uv.y *= -1.;\n    \n    vec2 z = uv;\n    vec2 c = vec2(.36, .36);\n    if(iMouse.z > 0.) c.y += m.x*0.05;\n    \n    float d = 99., x = 0., k = 0.;\n    for(float i = 0.; i < 100.; i++){\n        if (z.x * z.x + z.y * z.y > 4.0) return vec2(d, k);\n         \n        x = z.x * z.x - z.y * z.y + c.x;\n        z.y = 2.0 * z.x * z.y + c.y;\n        z.x = x;\n        d = min(d, length(z));\n        k++;\n    }\n    return vec2(d, k);\n}\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - .5*R.xy)/R.y;\n    uv*=rot(t*.1);\n\n    uv = .1*vec2(log(length(uv)), atan(uv.y, uv.x));\n    uv.x -= t*.06;\n\n    vec2 j = jules(uv);\n    vec3 col = texture(iChannel0, j*.01).xyz;\n    \n    col *= ss(0.3, .06, j.x);\n    col *= col * 1.7;\n    f = vec4(col, 1.);\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtdGWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[203, 203, 223, 223, 764], [765, 765, 805, 805, 1090]], "test": "untested"}
{"id": "ftfSRB", "name": "function plot", "author": "Shellderr", "description": "function plot", "tags": ["oscilloscope", "function"], "likes": 3, "viewed": 241, "published": 3, "date": "1636235931", "time_retrieved": "2024-07-30T18:50:01.297007", "image_code": "#define res iResolution\n\nfloat plot(vec2 uv, float sig, float amp, float lev){\n    return 1./abs(amp*(uv.y-sig*lev));\n}\n\nvoid mainImage(out vec4 fcolor, in vec2 fcoord ){\n    \n    vec2 uv = (2.*fcoord-res.xy)/res.y;\n    \n    float t = .6*iTime + 1.4*uv.x * 6.28318;\n    float d = .7*iTime;\n    float f = sin(d+t); \n    f += sin(d+t*3.)/3.; \n    f += sin(d+t*5.)/5.; \n    f += sin(d+t*7.)/7.; \n    f += sin(t*9.)/9.; \n    f += sin(t*11.)/11.; \n\n    f = plot(uv, f, 150., .4);\n    \n    vec3 c = vec3(f*.2, f, f*.2);\n \n   // float m = step(1.-abs(2.*(abs(uv.y)-(fract(iTime*.6)-fract(uv.y*8.)))), .01);\n   \n    vec2 v = fract(uv*5.2);\n    v = 1./(17.*abs(v-.5));\n    float m = clamp(dot(v, vec2(.12)), .0,.7);\n    c += vec3(m*.8, m*.77, .0)*.8;\n    \n    fcolor = vec4(c, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftfSRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 78, 78, 119], [121, 121, 170, 170, 774]], "test": "untested"}
{"id": "ftc3zS", "name": "Syracuse problem / Collatz con 4", "author": "FabriceNeyret2", "description": "https://en.wikipedia.org/wiki/Collatz_conjecture\n\nin this variant we display the \"orbit hair\" of each value (in first line of buffA) as curve which step turn left for evens and right for odds. see https://community.wolfram.com/groups/-/m/t/558256", "tags": ["collatzconjecture", "syracuseproblem", "ulamconjecture", "hailstonesequence"], "likes": 25, "viewed": 528, "published": 3, "date": "1636224832", "time_retrieved": "2024-07-30T18:50:02.192613", "image_code": "// fixing https://shadertoy.com/view/fl3GzS\n// variant of https://shadertoy.com/view/Nlc3RS\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n        O = T(U/1.);\n        if ( iMouse.z > 0.) O =  texelFetch(iChannel1, ivec2(U),0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// --- compute the Collatz sequence\n\n/*\nvec3 ihash( uvec3 x ) {              // quality interger hash from https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x) / float(0xffffffffU);\n}\n#define hash(p)   ihash(uvec3(U.x,U.x*11.,U.x+717.)).x\n*/\n\n#define hash(p)  fract(sin( (p) *  78.233 ) * 43758.5453) // old school hash\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U -= .5;\n    if (U.y > 0.) return;            // we simulates only 1st line \n    \n    if (iFrame==0) {                 // --- initialization\n        O = vec4(0);\n     // O.x = U.x + U.y*R.x;         // each pixel represent one integer\n        O.a = O.x = floor(1e5*hash(U.x));\n        return;\n    }\n                                     // --- Syracuse steps\n    O = T(U);                        // previous state\n    int i = int(O.x+.5);\n    if ( i==1 ) { O.y++; return; }   // already converged ( O.y counts after converged )\n    \n    i   = i/2*2==i ? i/2 : 3*i+1;    // hearth of the model\n    O.x = float(i);                  // store current value\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R    iResolution.xy\n#define T(U) texelFetch( iChannel0, ivec2(U), 0 )\n", "buffer_b_code": "// --- store the whole sequence\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = int(U.y)==iFrame  ? texelFetch(iChannel1, ivec2(U.x,0),0)\n                          : T(U);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// --- draw the AnglePath orbit of the reversed sequence \n//     see see https://community.wolfram.com/groups/-/m/t/558256\n\nfloat line(vec2 p, vec2 a,vec2 b) {           // --- draw line\n    p -= a, b -= a;\n    float h = dot(p, b) / dot(b, b),\n          c = clamp(h, 0., 1.);\n    p -= b*h;\n    return h==c ? dot(p,p) : 1e5; \n // return dot(p,p);                          // with round ends\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = texelFetch( iChannel1, ivec2(U), 0 ); // previous image\n    vec2 P, _P;\n    if ( iFrame > int(R.y) ) return;          // drawing finished\n\n    float d = 99.,x, a,r, z = R.y/7.;\n    U = ( U - vec2(.1,.45)*R ) / z ;\n    \n    for ( x=0.; x < min(R.x,640.); x++ ) {    // for each simulated number\n        vec4 T = T(vec2(x,iFrame));           // last record\n        if ( T.y != 1. ) continue;            // draw curve when sequence just finished\n        a = 0.; P = vec2(0); r = .05; // r = 300.*pow(T.a,-1.2);\n        for ( int i,t = iFrame; t >= 0; t-- )  { // for each value in the sequence\n            _P = P;\n            T = T(vec2(x,t)); i = int(T.x+.5);// current value in the reversed sequence\n            a += i/2*2==i ? .14 : -.26;       // AnglePath from the sequence:\n            P += vec2(cos(a),sin(a)) * r;     // curve turns left it even or right if odd\n            d = min(d, line(U,_P,P) );        // draw current hair segment\n        }\n    }\n    O += .2* smoothstep(1.5,0.,sqrt(d) *z ) * vec4(.5,.7,1,1);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftc3zS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 131, 131, 222]], "test": "untested"}
{"id": "fl3GzS", "name": "Syracuse problem / Collatz con 3", "author": "FabriceNeyret2", "description": "https://en.wikipedia.org/wiki/Collatz_conjecture\n\nin this variant we display the \"orbit hair\" of each value (in first line of buffA) as curve which step turn left for evens and right for odds. see https://community.wolfram.com/groups/-/m/t/558256\nWIP.", "tags": ["collatzconjecture", "syracuseproblem", "ulamconjecture", "hailstonesequence"], "likes": 13, "viewed": 468, "published": 3, "date": "1636221160", "time_retrieved": "2024-07-30T18:50:03.228842", "image_code": "// variant of https://shadertoy.com/view/Nlc3RS\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n        O = T(U/1.);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\nvec3 ihash( uvec3 x ) {              // quality interger hash from https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x) / float(0xffffffffU);\n}\n#define hash(p)   ihash(uvec3(U.x,U.x*11.,U.x+717.)).x\n*/\n\n#define hash(p)  fract(sin( (p) *  78.233 ) * 43758.5453) // old school hash\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U -= .5;\n    if (U.y > 0.) return;            // we simulates only 1st line \n    \n    if (iFrame==0) {                 // --- initialization\n        O = vec4(0);\n     // O.x = U.x + U.y*R.x;         // each pixel represent one integer\n        O.x = floor(1e5*hash(U.x));\n        return;\n    }\n                                     // --- Syracuse steps\n    O = T(U);                        // previous state\n    int i = int(O.x+.5);\n    if ( i==1 ) return;              // already converged\n    \n    i   = i/2*2==i ? i/2 : 3*i+1;    // hearth of the model\n    O.x = float(i);                  // store current value\n    O.a += i/2*2==i ? .14 : -.24;    // AnglePath orbit: turn left if even or right if odd\n    \n    O.yz += vec2(cos(O.a),sin(O.a)) *10. / pow(U.x+1.,1.2); // new point on orbit hair, see https://community.wolfram.com/groups/-/m/t/558256 \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(U) texelFetch( iChannel0, ivec2(U), 0 )", "buffer_b_code": "float line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = dot(p, b) / dot(b, b),\n          c = clamp(h, 0., 1.);\n    p -= b*h;\n    return h==c ? dot(p,p) : 1e5; \n // return dot(p,p);                   // with round ends\n}\n\n// #define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U -= .5;\n    if (U.y==0.) { O = texelFetch(iChannel1, ivec2(U.x,0),0); return; } // store the previous point\n    \n    vec2 R = iResolution.xy;\n\n    float d = 99.,x, z = 12.;\n    O = T(U);\n    U = ( U - vec2(.1,.5)*R ) / z ;\n    for ( x=0.; x < R.x; x++ )  // for each simulated number\n        if ( T(vec2(x,0.)).x  > 1. ) // if not yet converged\n        d = min(d, line(U, texelFetch(iChannel0, ivec2(x,0),0).yz, // draw current hair segment\n                           texelFetch(iChannel1, ivec2(x,0),0).yz ) ); \n \n    O += .5* smoothstep(1.5,0.,sqrt(d) *z );\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl3GzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 87, 87, 110]], "test": "untested"}
{"id": "Nlc3RS", "name": "Syracuse problem / Collatz con 2", "author": "FabriceNeyret2", "description": "https://en.wikipedia.org/wiki/Collatz_conjecture\n\nin this variant we only simulate in line1 of buffA,\nand we display in y value reached from x, hue = iteration.", "tags": ["collatzconjecture", "syracuseproblem", "ulamconjecture", "hailstonesequence"], "likes": 5, "viewed": 272, "published": 3, "date": "1636216427", "time_retrieved": "2024-07-30T18:50:04.216202", "image_code": "// variant of https://shadertoy.com/view/7td3W7\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n        O = T(U/1.);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U -= .5;\n    if (iFrame==0) {            // --- initialization\n        O.x = U.x + U.y*R.x;    // each pixel represent one integer\n        O.y = 0.;               // step count\n        return;\n    }\n                                // --- Syracuse steps\n    O = T(U);                   // previous state\n    int i = int(O.x+.5);\n    if ( i==1 ) return;         // already converged\n    \n    i = i/2*2==i ? i/2 : 3*i+1; // hearth of the model\n    O.x = float(i);             // store current value\n    O.y++;                      // increment steps as long as not converged\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(U) texelFetch( iChannel0, ivec2(U), 0 )", "buffer_b_code": "#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U -= .5;\n    O = T(U);\n    vec4 T = texelFetch(iChannel1, ivec2(U.x,0),0); // add explored value to the graph\n    if ( U.y == round(T.x ) )  O += hue(.1*T.y);    // hue = corresponding iteration\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlc3RS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 88, 88, 111]], "test": "untested"}
{"id": "Nt33RS", "name": "percolation in random network 3", "author": "FabriceNeyret2", "description": "each pixel is connect randomly to another pixel within a given radius. ( see buffA).\nid circulates through connections. min id is kept so as to visualize cycles.\n\nin this variant: 1 single connection, within a given radius, but for 3% of nodes with long d", "tags": ["graph", "network", "percolation", "epidemic", "epidemiology"], "likes": 3, "viewed": 256, "published": 3, "date": "1636215107", "time_retrieved": "2024-07-30T18:50:05.226500", "image_code": "//variant of https://shadertoy.com/view/sld3D7\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = T(U/1.);\n    O = hue(O.x);\n // O = vec4(O.z/10.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define hash(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\nfloat radius = .04;\n                                     // --- random link within radius r.\n#define link(r) T (mod( U + (r)*R*(hash(U)*2.-1.) , R ) ).x\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U -= .5;\n    if (iFrame==0) {                 // --- initialization\n        O.x = U.x + U.y*R.x;         // node label: start with its id\n        return;\n    }\n                                     // --- propagation along the random network\n    O = T(U);                        // previous step\n    O.y = O.x;                       // keep previous value\n  \n            // propagate from random link. label = min(id)\n            // mostly local, sometime global\n    O.x = min( O.x, link( hash(U+.2).x < .03 ? .5 : radius ) );\n        \n    O.z = O.x==O.y ? O.z+1. : 0.;    // convergence detector\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(U) texelFetch( iChannel0, ivec2(U), 0 )", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt33RS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 114, 152, 152, 212]], "test": "untested"}
{"id": "NlcGRS", "name": "percolation in random network 2", "author": "FabriceNeyret2", "description": "each pixel is connect randomly to another pixel within a given radius. ( see buffA).\nid circulates through connections. min id is kept so as to visualize cycles.\n\nin this variant: just 1 connection, very small radius, but network is renewed every second.", "tags": ["graph", "network", "percolation", "epidemic", "epidemiology"], "likes": 5, "viewed": 234, "published": 3, "date": "1636214258", "time_retrieved": "2024-07-30T18:50:06.067253", "image_code": "// variant of https://shadertoy.com/view/sld3D7\n\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = T(U/1.);\n    O = hue(O.x);\n // O = vec4(O.z/10.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define hash(p) fract(sin((p-sin(floor(iTime)))*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\nfloat radius = .01;\n                                     // --- random link within radius, seed s.\n#define link(s) T (mod( U + radius*R*(hash(s+U)*2.-1.) , R ) ).x\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U -= .5;\n    if (iFrame==0) {                 // --- initialization\n        O.x = U.x + U.y*R.x;         // node label: start with its id\n        return;\n    }\n                                     // --- propagation along the random network\n    O = T(U);                        // previous step\n    O.y = O.x;                       // keep previous value\n\n  \n    O.x = min(O.x, link() );         // propagate from random link. label = min(id)\n   \n    O.z = O.x==O.y ? O.z+1. : 0.;    // convergence detector\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(U) texelFetch( iChannel0, ivec2(U), 0 )", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlcGRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[116, 116, 154, 154, 214]], "test": "untested"}
{"id": "sld3D7", "name": "percolation in random network", "author": "FabriceNeyret2", "description": "each pixel is connect randomly to another pixel within a given radius. ( see buffA).\nid circulates through connections. min id is kept so as to visualize cycles.\n\nif clicked, 3% of pixels have a second connection.\nThis small add allows full percolation.\n", "tags": ["graph", "network", "percolation", "epidemic", "epidemiology"], "likes": 7, "viewed": 236, "published": 3, "date": "1636213594", "time_retrieved": "2024-07-30T18:50:06.946902", "image_code": "\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = T(U/1.);\n    O = hue(O.x);\n // O = vec4(O.z/10.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define hash(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\nfloat radius = .04;\n                                     // --- random link within radius, seed s.\n#define link(s) T (mod( U + radius*R*(hash(s+U)*2.-1.) , R ) ).x\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U -= .5;\n    if (iFrame==0) {                 // --- initialization\n        O.x = U.x + U.y*R.x;         // node label: start with its id\n        return;\n    }\n                                     // --- propagation along the random network\n    O = T(U);                        // previous step\n    O.y = O.x;                       // keep previous value\n\n  \n    O.x = min(O.x, link() );         // propagate from random link. label = min(id)\n\n    if ( iMouse.z > 0. ) // if mouse click \n        if ( hash(U+.2).x < .03 ) O.x = min(O.x,link(.5));  // sometime a node has a second link\n     // if ( length(iMouse.xy-U) < R.x*.05 ) O.x = .5;      // variant: mouse-paint virus injection\n\n // O.x = min(O.x, T(R*hash(U)).x);  // worldwild network  \n // if ( hash(U+.2).x < .05)\n //     O.x = min(O.x, T(R*hash(U+.5)).x);  \n        \n    O.z = O.x==O.y ? O.z+1. : 0.;    // convergence detector\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(U) texelFetch( iChannel0, ivec2(U), 0 )", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sld3D7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 105, 105, 165]], "test": "untested"}
{"id": "7td3W7", "name": "Syracuse problem / Collatz conje", "author": "FabriceNeyret2", "description": "https://en.wikipedia.org/wiki/Collatz_conjecture\nn even → n/2\nn odd → 3n+1\nconjecture: always reach 1 ? \nside questions: orbits, time before stop...\n\nHere: each pixel rasterize integers.\nShow current Syracuse value during 5\". then show convergence length.", "tags": ["collatzconjecture", "syracuseproblem", "ulamconjecture", "hailstonesequence"], "likes": 6, "viewed": 279, "published": 3, "date": "1636210114", "time_retrieved": "2024-07-30T18:50:07.833530", "image_code": "#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float i;\n    if (iMouse.z > 0.) {     // if mouse click show curves for first numbers (i.e. 1st line)\n        O = T(vec2(U.x,0));\n        i = round(O.y);\n        O = vec4( U.y < i );\n    }\n    else {\n        O = T(U/1.);\n        i = round( iFrame < 300 ? O.x : O.y ); // show numbers, then convergence length\n        O = hue(i);\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U -= .5;\n    if (iFrame==0) {            // --- initialization\n        O.x = U.x + U.y*R.x;    // each pixel represent one integer\n        O.y = 0.;               // step count\n        return;\n    }\n                                // --- Syracuse steps\n    O = T(U);                   // previous state\n    int i = int(O.x+.5);\n    if ( i==1 ) return;         // already converged\n    \n    i = i/2*2==i ? i/2 : 3*i+1; // hearth of the model\n    O.x = float(i);             // store current value\n    O.y++;                      // increment steps as long as not converged\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(U) texelFetch( iChannel0, ivec2(U), 0 )", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7td3W7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 104, 104, 445]], "test": "untested"}
{"id": "fltGW7", "name": "point eaters", "author": "lomateron", "description": "just found the kernel to extract curl or divergence of a vector field\nhttps://img.favpng.com/8/0/5/curl-divergence-vector-field-vector-calculus-png-favpng-nuFSf68dHk5NYPkhmQpmCfexR.jpg\nI am remixing all known kernels randomly to see what comes out", "tags": ["convolution", "field", "vectors", "kernel"], "likes": 28, "viewed": 503, "published": 3, "date": "1636194224", "time_retrieved": "2024-07-30T18:50:08.790970", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = fragCoord/iResolution.xy;\n    float a = texture(iChannel0,u).z;\n          a = pow(a,.1);\n    fragColor = cos(a*4.+vec4(1,2,3,4)+1.)*.6+.4;\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//extracts divergence around each pixel\n#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    float p = 0.;\n    //kernel convolution\n    {\n        float z    = 8.;//kernel convolution size\n        float blur = 2./z;\n        for(float i=-z; i<=z; ++i){\n        for(float j=-z; j<=z; ++j){\n            vec2  c  = vec2(i,j)*blur; //c = c.yx*vec2(-1,1);\n            vec4  t2 = A(u+vec2(i,j));\n            p += dot(t2.xy,c)/exp(dot(c,c));\n        }}\n    }\n    fragColor = vec4(p);\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//use the amount of divergence calculated in BufferA to enhance the divergence field\n#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4 a = A(u);//A(u)*.9  vec4(0)\n    //kernel convolution\n    {\n        float z    = 4.;//kernel convolution size\n        float blur = 2./z;\n        for(float i=-z; i<=z; ++i){\n        for(float j=-z; j<=z; ++j){\n          float p = B(u+vec2(i,j)).x;\n          vec2  c = -vec2(i,j)*blur; //c = c.yx*vec2(-1,1);\n          a.xy += c*p/exp(dot(c,c))*.003;\n        }}\n    }\n    fragColor = a;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//calculate how much each pixel is going to move and how to normalize it\n#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    float s  = 0.;\n    //kernel convolution\n    {\n        vec4  t  = A(u);\n        vec2  mv = t.xy;\n        float dl = sin(t.z*3.)*2.+4.; //dl = min(dl,5.);\n        float z    = 6.;//kernel convolution size\n        float blur = 1./z;\n        for(float i=-z; i<=z; ++i){\n        for(float j=-z; j<=z; ++j){\n            vec2 c = (mv+vec2(i,j))*blur*dl;\n            s += 1./exp(dot(c,c));\n        }}\n        if(s==0.){s = 1.;}\n    }\n    fragColor = vec4(s);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//read the translation and normalization calculated in Buffer C and apply it\n#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4  a = vec4(0);\n    //kernel convolution\n    {\n        float z    = 6.;//kernel convolution size\n        float blur = 1./z;\n        for(float i = -z; i<=z;++i){\n        for(float j = -z; j<=z;++j){\n          vec4  t  = A(u+vec2(i,j));\n          float dl = sin(t.z*3.)*2.+4.; //dl = min(dl,5.);\n          vec2  mv = t.xy;\n          float s = B(u+vec2(i,j)).x;\n          vec2 c = (mv-vec2(i,j))*blur*dl;\n          a += t/s/exp(dot(c,c));\n        }}\n    }\n    if(iFrame==0)\n    {\n        vec2 v = 1.*(2.*u-iResolution.xy)/iResolution.y;\n        a = .1/exp(dot(v,v)) + vec4(0,0,1,1)*.0;\n    }\n    fragColor = a;\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fltGW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 211]], "test": "untested"}
{"id": "slcGDM", "name": "入门之路-10", "author": "jialouluo", "description": "雪花模拟", "tags": [], "likes": 5, "viewed": 254, "published": 3, "date": "1636188041", "time_retrieved": "2024-07-30T18:50:09.654661", "image_code": "#define count 400 //数量\n#define BlizardSpeed 0.4 //风速\nfloat rand(float x){\n    return fract(\n                sin(\n                    dot(vec2(x + 47.49, 38.2467 / (x + 2.3)),vec2(12.9898, 78.233))\n                    )\n                );\n}\nfloat drawCircle(vec2 uv,vec2 center,float radius){\n    return 1.0 - smoothstep(0.0,radius,length(uv -center));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n       fragColor = texture(iChannel0,uv);\n    for(int i=0;i<count;i++){\n        float j = float(i);\n        float speed = 0.4 + rand(j) * (0.7 + 0.5 * cos(j / (float(count) * 0.25)));//这里得到下落速度和雪花大小\n        vec2 center =vec2(\n             rand(j) + uv.y * BlizardSpeed + 0.6 * cos(iTime + sin(j)),//x代表雪花的出生x轴坐标\n             mod(rand(j) - speed *iTime,0.95)//y代表随时间下落的坐标\n            );\n             fragColor += vec4(drawCircle(uv,center,0.01*speed ));//这里传入speed 是作为大小使用\n    }\n\n   \n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slcGDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 81, 81, 247], [248, 248, 299, 299, 361]], "test": "untested"}
{"id": "ftcGD7", "name": "大龙猫 - Look mom i'm evvvvil", "author": "totetmatt", "description": " ", "tags": ["raymarch"], "likes": 17, "viewed": 482, "published": 3, "date": "1636185360", "time_retrieved": "2024-07-30T18:50:10.486437", "image_code": "/******\nThis work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. \n\n== Do not buy NFT ==\n== Do not make NFT with Creative-Commons artworks ==\n== If you respect the art and the artists, remember and apply this ==\n\n01000110011101010110001101101011 011011100110011001110100\n\n                                                                               \n _|_|_|_|                      _|            _|      _|  _|_|_|_|  _|_|_|_|_|  \n _|        _|    _|    _|_|_|  _|  _|        _|_|    _|  _|            _|      \n _|_|_|    _|    _|  _|        _|_|          _|  _|  _|  _|_|_|        _|      \n _|        _|    _|  _|        _|  _|        _|    _|_|  _|            _|      \n _|          _|_|_|    _|_|_|  _|    _|      _|      _|  _|            _|      \n                                                                          \n\n01000110011101010110001101101011 011011100110011001110100\n\n******/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n  vec4 pframe = texture(iChannel0,fragCoord.xy/iResolution.xy);\n    // Output to screen\n    fragColor = vec4(pframe.xyz,1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "mat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\n// ka = radius close to a, kb = radius close to b\n// https://www.shadertoy.com/view/Nt3GWH\n// credit to @paniq \nfloat brsmin( float a, float b, float ka, float kb)\n{\n    float s = a-b;\n    float k = (ka + kb + (kb - ka)*s/max(ka,kb))*0.5;\n    const float p = 2.0;\n    float h = max( k - abs(s), 0.0 )/k;\n    return min( a, b ) - pow(h,p)*k*(1.0/(2.0*p));\n}\nfloat diam(vec3 p,float s){\n  \n    p = abs(p);\n   return (p.x+p.y+p.z-s)*inversesqrt(3.);\n  }\n  \n  float di(vec3 p){\n      float q =0.;\n      vec4 pp = vec4(p,1.);\n      for(float i=0.;i<=8.;i++){\n          pp*=1.1;\n          p.xz *=rot(.1+i);\n          q +=clamp( (asin(.9*sin(p.x*3.3))*acos(.8*cos(p.z*2.))),.0,.2)/pp.a;\n        }\n        return q/pp.a;\n    }\n float diam(vec2 p,float s){\n  \n    p = abs(p);\n   return (p.x+p.y-s)*inversesqrt(3.);\n  }\n float box(vec3 p, vec3 b){\n    vec3 q =abs(p)-b;\n    return length(max(vec3(0.),q))+min(0.,max(q.x,max(q.y,q.z)));\n   }\n   vec3 gp ;\nvec2 sdf(vec3 p){\n    vec2 h ;\n    h.x = 1e10;\n      gp =p;\n  p/=10.;  \n  p.xz = asin(sin(p.xz)*.8);\n   p*=10.;\n\n    vec4 hp =vec4(p,1.) ;\n     for(float i=0.;i<=4.;i++){\n         hp.xz = abs(hp.zx)-1.5;\n           hp*=1.3;\n         hp.xy *=rot(-.785+i);\n         hp.xz *=rot(.785*i);\n         \n           vec2 t ;\n           vec3 tp = hp.xyz;\n           tp.xy *= rot(tp.z*.1);\n         t.x = (diam(tp.xy,.1+i/16.))/hp.a;\n         t.y = 2.+i;\n          h = t.x < h.x  ? t:h;\n       }\n       float r = di(p);\n      vec2 t ;\n         t.x = box(hp.xyz,vec3(1.,1.5,2.0))/hp.a;\n         t.x = brsmin(t.x, diam(abs(p.xyz)-.5,2.),.5,.5);\n         t.y = 1.;\n     h = t.x < h.x  ? t:h; \n\n      t .x =brsmin(h.x, dot(vec3(0.,1.,0.),p)+r,1.5,5.0);\n      t.y = 0.;\n      h = t.x < h.x ? t:h;\n       \n       t.x = length(gp+vec3(.0,-3.5,.0))-2.;\n       t.y = .5+fract(iTime+log(length(gp.zx))+r);\n        h = t.x < h.x ? t:h;\n          \n        vec3 tp= gp+vec3(.0,-2.5,.0);\n        tp.x = abs(tp.x)-3.5;\n        tp.xz *=rot(tp.y*.5);\n          t.x = diam(tp.xz,.5);\n       t.y = -1.;\n        h = t.x < h.x ? t:h;\n  return h;\n  }\n  \n#define q(s) s*sdf(p+s).x\nvec3 norm(vec3 p, float ee){vec2 e= vec2(-ee,ee);return normalize(q(e.xyy)+q(e.yxy)+q(e.yyx)+q(e.xxx));}\n\n\n#define ao(rp,n,k) clamp(sdf(rp+n*k).x/k,0.,1.)\n#define gao(rp,n) (.1+( ao(rp,n,.1)+ao(rp,n,.5)+ao(rp,n,.7) )/3.)\n\nfloat h21(vec2 p){\n    return fract(sin(dot(p,vec2(9995.3564,5614.4968)))*6114.6554);\n  }\n  vec3 pal(float t){return .5+.5*cos(6.28*(1.*t+vec3(.1,.2,.3)));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n vec3 col = vec3(0.1);\n  \n  vec2 puv = uv; \n  puv = (puv*vec2(iResolution.y / iResolution.x, 1.))+.5;\n  \n\n  // Unecessary, but why not\n  float ra = h21(uv+iTime);\n  float rb = h21(ra+uv+iTime);\n  float rc = h21(rb+ra+uv+iTime);\n  vec3 r = vec3(fract(ra+rb),fract(rb+rc),fract(rc+ra))*.03;\n  vec3 ro = r +vec3(sin(iTime*.1)*15.,10.1,cos(iTime*.1)*15.);\n  vec3 rt = vec3(1e-10)+r;\n  \n  vec3 rp = ro;\n  vec3 z = normalize(rt-ro);\n  vec3 x = normalize(cross(z,vec3(0.,-1.,0.)));\n  vec3 y = normalize(cross(z,x));\n  \n  vec3 rd = mat3(x,y,z)*normalize(vec3(uv,1.));\n  vec3 light = vec3(1.,2.,-3.);\n  vec3 acc = vec3(0.);\n  float dd = 0.;\n  for(float i=0.;i<=128.;i++){\n    \n      vec2 d = sdf(rp);\n      dd +=d.x;\n      if(d.y >=2. && d.x < 1.){\n        \n          acc += pal(d.y/5.)*exp(-abs(d.x))/(240.-220.*sin(length(gp)*3.-iTime*2.));\n          d.x = max(.005,d.x);\n        }\n      if(dd>60.) break;\n      if(d.x< .001 && d.y <= 1.){\n      // evvvvil-ish light\n           vec3 n = norm(rp,.001);\n           float diff= max(0.,dot(normalize(light-rp),n));\n        float spc = pow(max(0.,dot( -rd , reflect(-normalize(light),n))),48.);\n        float fr = pow(1.+dot(n,rd),8.);\n        if(d.y == 0.){\n        // This is cool, but expensive\n          // vec3 nn = norm(rp,.002-texture(texFFT,fGlobalTime+.3+rp.y).r);\n         // float qq = length(n-nn); \n          col = mix(vec3(.0)*gao(rp,n)+spc+vec3(.1)*diff,col,min(fr,.5)); \n         //  acc += pal(qq)*step(.15,qq);\n        } \n        else if(d.y ==1.) {\n           col = mix(vec3(.4)*gao(rp,n)+spc+vec3(1.)*diff,col,min(fr,.5)); \n        } else if(d.y ==-1.){\n          \n            rd = reflect(rd,n);\n            rp +=rd*.1;\n            col +=pal(rp.y)*.2;\n            continue;\n          }\n         \n          col = pow(col,vec3(.4545));\n          break;\n      }\n      rp +=rd*d.x;\n  }\n  col +=acc;\n   col = mix(col,texture(iChannel0,puv).rgb,.75);\n\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftcGD7.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[944, 944, 1001, 1049, 1217]], "test": "untested"}
{"id": "NtcGW7", "name": "Maze Micro Tile", "author": "xZAKHAMx", "description": "my daily micro tile shader. #004", "tags": ["maze"], "likes": 1, "viewed": 192, "published": 3, "date": "1636180185", "time_retrieved": "2024-07-30T18:50:11.282309", "image_code": "float square(in float valx, in float valy, in float eps1, in float eps2)\n{\n    vec2 comp = vec2(0.0);\n    if (valx < eps1 && valx > -eps1) comp.x = 1.0;\n    if (valy < eps2 && valy > -eps2) comp.y = 1.0;\n\n    return comp.x*comp.y;\n}\n\nfloat noise(in vec2 uv, in float seed)\n{\n    float gr = 1.618;\n    return fract(tan(distance(uv*gr, uv)*seed)*uv.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = vec2(-1.0 +2.0*uv);\n    \n    // pram\n    float Tile = 30.0;\n    float lScale = 3.0;\n    float bias = 0.5 ;\n    \n    float rotate1 = 0.78;\n    float rotate2 = -rotate1;\n    p = fract(p*Tile)-0.5;\n    vec2 p1  = p*0.5;\n    vec2 p2  = p*0.5;\n    p1 *= mat2 (cos(rotate1), -sin(rotate1),\n                sin(rotate1), cos(rotate1));\n    p2 *= mat2 (cos(rotate2), -sin(rotate2),\n                sin(rotate2), cos(rotate2));\n    \n    vec2 res = vec2 ((iResolution.x/iResolution.y)+0.02, 1.00);\n    \n    float seed = ceil(2.0*iTime+1.0);\n    float scale = Tile;\n    \n    \n    vec2 newUV = ceil(vec2 (uv.x, uv.y)*scale);\n    float pix = float(noise(newUV, seed));\n    \n    float sq1 = square(p1.x, p1.y, lScale*0.01, 1.0);\n    float sq2 = square(p2.x, p2.y, lScale*0.01, 1.0);\n    \n    \n    vec3 col = vec3(0.0);\n    if (pix > bias) col = vec3(1.0);\n    \n    col = mix(vec3(sq1), vec3(sq2), col.x);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtcGW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 74, 74, 232], [234, 234, 274, 274, 352], [354, 354, 411, 411, 1394]], "test": "untested"}
{"id": "ftc3DM", "name": "Footwear Design 003", "author": "yasuo", "description": "・Improved upper shape as much as I could\n・Outsole top spring and heel down to modify it like the modern running shoe outsole.\n・Tried to add the block traction pattern", "tags": ["footwear"], "likes": 11, "viewed": 240, "published": 3, "date": "1636178426", "time_retrieved": "2024-07-30T18:50:12.129045", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define Slice(p,a) dot(p,vec2(cos(a),sin(a)))\n#define S(p,d,b) smoothstep(fwidth(p.y),0.0,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define MATERIAL_OUTSOLE 0\n#define MATERIAL_MIDSOLE1 1\n#define MATERIAL_MIDSOLE2 2\n#define MATERIAL_UPPER 3\n\n#define ZERO (min(iFrame,0))\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// IQ's 3D noise function. It's faster than the FBM and enough for me to design.\n// The compile is also faster.\nfloat noise3d( vec3 p )\n{\n    const vec3 s = vec3(27, 111, 57);\n    vec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.); // option\n    h = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdSimpleCylinder(vec3 p, float r, float h){\n    float d = length(p.xz)-r;\n    d = max(abs(p.y)-h,d);\n    return d;\n}\n\nfloat baseOutsole(vec3 p, float h){\n    vec3 prevP = p;\n    \n    p.xz*=Rot(radians(17.0));\n    p.z*=0.4;\n    p.x*=0.57;\n    p.x+=0.03;\n    p.z-=0.07;\n    \n    float d =sdSimpleCylinder(p,0.1,h);\n    \n    p = prevP;\n    p.xy*=Rot(radians(90.0));\n    p.y*=1.5;\n    p.z*=1.2;\n    float d2 = sdCappedCylinder(p-vec3(0.0,0.0,-0.25),h,0.2);\n    d = opSmoothUnion(d, d2,0.13);\n    \n    p = prevP;\n    d = max(abs(p.y)-h,d);\n    \n    return (d)*0.6;\n}\n\nfloat outsole(vec3 p){\n    p.z*=0.9;\n    vec3 prevP = p;\n    float d = baseOutsole(p,0.03);\n    \n    // normal block traction\n    //p.xz*=2.3;\n    p.x = mod(p.x,0.05)-0.025;\n    p.z = mod(p.z,0.08)-0.04;\n    float d2 = sdBox(p,vec3(0.02,0.03,0.03))*0.6;\n    \n    d = max(d,d2);\n    p = prevP;\n    d2 = baseOutsole(p-vec3(0.0,0.035,0.0),0.035);\n    d = min(d,d2);\n    \n    p = prevP;\n    float a  = radians(4.0);\n    p.y-=0.06;\n    float mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(mask,d);\n    \n    p = prevP;\n    a  = radians(-6.0);\n    p.y+=0.05;\n    mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(-mask,d);\n    \n    p = prevP;\n    a  = radians(10.0);\n    p.y+=0.07;\n    mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nvec2 midsole(vec3 p){\n    p.z*=0.89;\n    p.x*=0.99;\n    float d = baseOutsole(p-vec3(0.0,0.02,0.0),0.003);\n    \n    vec2 model = vec2(d,MATERIAL_MIDSOLE1);\n    \n    return model;\n}\n\nfloat upperBase(vec3 p){\n    p.z*=0.9;\n    vec3 prevP = p;\n\n    //p.x*=1.;\n    p.z*=0.8;\n    \n    float d =sdCappedCone(p-vec3(0.0,0.18,-0.15),0.13,0.15,0.06);\n    \n    p = prevP;\n    p.xz*=Rot(radians(15.0));\n    p.yz*=Rot(radians(-6.0));\n    p.x*=1.2;\n    p.z*=0.8;\n    \n    float d2 = sdEllipsoid(p-vec3(-0.05,0.1,0.14),vec3(0.2,0.08,0.2));\n    d = opSmoothUnion(d,d2,0.1);//0.1\n    \n    p = prevP;\n    p.xz*=Rot(radians(15.0));\n    p.x*=1.2;\n    p.z*=0.8;\n    p.yz*=Rot(radians(-35.0));\n    d2 = sdEllipsoid(p-vec3(0.0,0.21,-0.1),vec3(0.1,0.04,0.15));\n    d = opSmoothUnion(d,d2,0.15);//0.15\n\n    p = prevP;\n    p.yz*=Rot(radians(-25.0));\n    d2 = sdBox(p-vec3(0.0,0.11,-0.37),vec3(0.03,0.13,0.005))-0.01;\n    d = opSmoothUnion(d,d2,0.01); //0.03\n    d2 = sdBox(p-vec3(0.0,0.16,-0.37),vec3(0.05,0.07,0.005));\n    d = max(-d2,d);\n    \n    p = prevP;\n    p.x*=1.05;\n    p.z*=1.03;\n    p.yz*=Rot(radians(-6.0));\n    d2 = baseOutsole(p-vec3(0.0,0.07,0.0),0.01);\n    d = opSmoothUnion(d,d2,0.015);//0.015\n\n    p = prevP;\n    p.xy*=Rot(radians(90.0));\n    p.xz*=Rot(radians(10.0));\n    p.y*=1.5;\n    p.z*=1.17;\n    d2 = sdCappedCylinder(p-vec3(-0.04,0.0,-0.25),0.03,0.2);\n    d = opSmoothUnion(d,d2,0.08);//0.015\n    \n    return d;\n}\n\nfloat upper(vec3 p){\n    vec3 prevP = p;\n    float d = upperBase(p);\n    p.x*=1.4;\n    p.z*=1.1;\n    \n    float d2 = upperBase(p-vec3(0.0,-0.02,0.0));\n    d = max(-d2,d);\n    \n    p = prevP;\n    \n    p.xy*=Rot(radians(90.0));\n    p.xz*=Rot(radians(15.0));\n    p.z*=0.08;\n    d2 =sdSimpleCylinder(p-vec3(-0.15,0.0,-0.005),0.01,0.5);\n    d = max(-d2,d);\n    \n    \n    p = prevP;\n    \n    p.xy*=Rot(radians(90.0));\n    p.xz*=Rot(radians(17.0));\n    p.z*=0.11;\n    d2 =sdSimpleCylinder(p-vec3(-0.18,0.0,0.03),0.005,0.5);\n    d = max(-d2,d);\n    \n    \n    p = prevP;\n    \n    p.x*=1.6;\n    p.z*=0.85;\n    \n    d2 =sdCappedCone(p-vec3(-0.015,0.25,-0.12),0.14,0.14,0.09)*0.6;\n    d = max(-d2,d);\n    \n    return d*0.8;\n}\n\nvec2 GetDist(vec3 p) {\n    \n    vec3 prevP = p;\n    \n    p.y+=0.075;\n    //p.z+=0.1;\n    float d = outsole(p);\n    \n    vec2 model = vec2(d,MATERIAL_OUTSOLE);\n    vec2 model2 = midsole(p);\n\n    p+=noise3d(p*600.0)*0.0005;\n    d = upper(p);\n    \n    vec2 model3 =vec2(d,MATERIAL_UPPER);\n    \n    return combine(model,combine(model2,model3));\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<3; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,2,-2));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*shadow*occ;\n    diffCol += col*vec3(1.0,1.0,0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 20.)*occ; // spec\n        \n    return diffCol;\n}\n\nvec3 upperTex(vec2 uv, vec3 col){\n        vec2 prevUV = uv;\n        \n        uv.y+=cos(uv.x*70.0)*0.02+sin(uv.x*50.0)*0.05;\n        float d = -uv.y+0.25;\n        col = mix(col,vec3(0.1,0.25,0.45),S(prevUV,d,0.0));\n\n        uv = prevUV;\n        uv*=Rot(radians(20.0));\n        uv.y = mod(uv.y,0.012)-0.006;\n        d = B(uv,vec2(1.0,0.001));\n        col = mix(col,vec3(0.2,0.3,0.5),S(prevUV,d,0.0));\n\n        return col;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    float nn = noise3d(p*160.0)*0.05;\n    \n    if(mat == MATERIAL_OUTSOLE){\n        col = diffuseMaterial(n,rd,p,vec3(1.0,0.8,0.6))+nn;\n    } else if(mat == MATERIAL_MIDSOLE1){\n        col = diffuseMaterial(n,rd,p,vec3(0.4,0.3,0.5))+nn;\n    } else if(mat == MATERIAL_MIDSOLE2){\n        col = diffuseMaterial(n,rd,p,vec3(0.6,0.6,0.6))+nn;\n    } else if(mat == MATERIAL_UPPER){\n        \n        col = diffuseMaterial(n,rd,p,vec3(0.1,0.2,0.5)+upperTex(p.xz,vec3(0.4,0.6,0.7)));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy -.3;\n    \n    vec3 ro = vec3(0, 0, 1.0);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-30.0));\n    if(iMouse.z>0.){\n        ro.yz *= Rot(-m.y*3.14+1.);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.xz *= Rot(radians(-5.0+iTime*20.0));\n        \n        //ro.yz *= Rot(radians(120.0));\n        //ro.xz *= Rot(radians(45.0));\n    }\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n        //col *= exp( -0.038*d.x*d.x*d.x );//fog\n    } else {\n        //col = upperTex(uv,col);\n    }\n    \n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftc3DM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[479, 479, 504, 504, 523], [524, 524, 549, 549, 568], [569, 569, 621, 621, 721], [723, 835, 860, 860, 1205], [1207, 1207, 1243, 1243, 1285], [1287, 1336, 1388, 1388, 1495], [1497, 1546, 1577, 1577, 1664], [1666, 1715, 1752, 1752, 1835], [1837, 1886, 1945, 1945, 2258], [2260, 2260, 2309, 2309, 2382], [2384, 2384, 2419, 2419, 2827], [2829, 2829, 2851, 2851, 3591], [3593, 3593, 3614, 3614, 3773], [3775, 3775, 3799, 3799, 5006], [5008, 5008, 5028, 5028, 5721], [5723, 5723, 5745, 5745, 6065], [6067, 6067, 6125, 6125, 6392], [6394, 6394, 6418, 6418, 6619], [6621, 6621, 6663, 6663, 6858], [6860, 6901, 6950, 6950, 7244], [7246, 7246, 7303, 7303, 7922], [7924, 7924, 7957, 7957, 8345], [8347, 8347, 8406, 8406, 8905], [8907, 8907, 8964, 8964, 10008]], "test": "untested"}
{"id": "7lt3DN", "name": "spqr: decal scaffold 5", "author": "Fahrenheitrequited", "description": "a", "tags": ["a"], "likes": 3, "viewed": 196, "published": 3, "date": "1636172107", "time_retrieved": "2024-07-30T18:50:12.995728", "image_code": "/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\n\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/CorrodedBeasts.glsl\n*/\n\n#define MARCH_STEPS 100\n#define PART_COUNT 20\n\n#define time iTime\nfloat PI = acos(-1.0);\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat tick (float t) {\n  float i = floor(t);\n  float r = fract(t);\n  for (int z = 0; z < 2; z++) {\n    r = smoothstep(0.,1.,r);\n  }\n  \n  return i + r;\n}\n\nfloat box( vec2 p, vec2 b )\n{\n  vec2 q = abs(p) - b;\n  return max(q.x,q.y);\n}\n\n\nvec2 replim( in vec2 p, in float c, in vec2 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\n\nfloat m1(vec2 uv) {\n  \n \n  \n  \n  float t = iTime ;\n  float a = 3.141592/4.;\n  \n  \n  float thing = 10000.;\n  \n  for( float i = 0.; i <5.; i++){\n  \n    uv *= rot(i * a *2.);\n   \n    uv = abs(uv); \n    uv -= vec2(2,7);\n    uv = -abs(uv);\n   \n    \n    float x1 =  box(uv, vec2(1,1));\n    float x2 =  box(uv + vec2(2,11), vec2(1.,5.));\n    float x3 =  box(uv + vec2(14,14), vec2(.1,53.));\n    vec2 q = replim(uv, 10., vec2(11,2));\n    float x4 =  box(q , vec2(.2,2.));\n   \n    float x = min(x4,min(x1,(min(x2,x3))));\n    \n    thing = min(thing,x);\n   \n    \n \n\n  }\n  return thing ;\n\n}\n\nfloat a = 3.141592;\nfloat glow = 0.;\nfloat m2(vec2 uv) {\n \n  vec2 uv2 = uv;\n  float q = 1.4  + 1. *  sin(tick(tick(iTime * sqrt(2.)/2.1 )));\n  \n  float z = 10000.;\n  vec2 off = vec2(58,20);\n  for (float i = 0.; i <5.; i++) {\n    off *= rot(i/4.);\n   \n    uv.x *= q;\n    \n   \n    \n    uv *= rot(a/2.);\n    \n    \n    float a1 =m1(uv  + off);\n    z = min(z,a1);\n  \n  }\n  vec2 arm = vec2(24);\n  arm *= rot(iTime * 7.1);\n  float u = length(uv2  + arm) -2.;\n  \n  glow += .01/(.02 + u);\n \n  return z/1.4;\n}\n\nfloat ink(vec2 uv) {\n\n  return m2(uv);\n}\n\n\n\nfloat tor(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sph(vec3 p, float r) {\n  return length(p) - r;\n}\n\nvec3 rep( vec3 p, vec3 c )\n{\n    return mod(p,c) - 0.5 * c;\n}\n\n\nvec3 replim( in vec3 p, in float c, in vec3 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\n\n\n\nvec3 moda(vec3 p, float rep, float off) {\n  vec2 rp = vec2(atan(p.z,p.x)/(2.0*PI), length(p.xz));\n  rp.x=(fract(rp.x*rep-0.5+off)-0.5)/rep;\n  rp.x *= 2.0*PI;\n  return vec3(cos(rp.x)*rp.y,p.y,sin(rp.x)*rp.y);\n}\n\n\nfloat noise(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,37,289);\n  vec4 pos=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 val=mix(fract(sin(pos)*7894.552), fract(sin(pos+st.x)*7894.552), p.x);\n  vec2 val2=mix(val.xz,val.yw, p.y);\n  return mix(val2.x,val2.y, p.z);\n}\n\nfloat fbm(vec3 p) {\n\n  float d=0.5;\n  float f=0.0;\n  for(int i=0; i<5; ++i) {\n    f+=noise(p/d)*d;\n    d*=.5;\n  }\n  return f;\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\nvec3 smin(vec3 a, vec3 b, float h) {\n  vec3 k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\nvec3 tunnel(vec3 p){\n  vec3 off=vec3(0);\n  off.x += sin(p.z*0.2)*1.5;\n  off.y += sin(p.z*0.3)*1.3;\n  return off;\n}\n\nfloat pi = 3.141592;\nfloat surge (float tt) {\n\n   return (1. - cos(mod(tt*pi,pi))/2.)+floor(tt);\n \n}\n\n\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\n\nint matter = 1;\n\n\nvec3 delta;\nfloat building_spacing = 577.;\n\nfloat building(vec3 p) {\n\n\n  // probe\n  vec3 fwd = delta;\n  \n  vec3 pp = p - fwd;\n  \n  \n  \n  //p = rep(p, vec3(building_spacing,0.,building_spacing));\n  \n  \n  \n  \n  float pr1= sph(pp, 1.);\n  float pr2 = box(pp, vec3(1.));\n  float probe = mix(pr1, pr2, .7);\n\n  // floors and collumns\n  //p.xz = abs(p.xz) - building_spacing;\n  p.xz = abs(p.xz)- 91.;\n  p = rep(p, vec3(0.,50.,0.));\n  float floors = box(p, vec3(110,5.1,110));\n  float collumns = box(p, vec3(10,10,10));\n  \n  \n  // merge\n  float all = min(min(floors,collumns),probe);\n  \n  if ( floors == all) {\n    matter = 1;\n  }\n  if ( collumns == all) {\n    matter = 2;\n  }\n  if ( probe == all) {\n    matter = 3;\n  }\n  //if ( wrap == all ) {\n  //  matter = 3;  \n  //}\n  \n  return all;\n  \n \n}\n\n\n\nfloat map (vec3 p) {\n\n  // geo\n  \n \n  float w = 1000.;\n  //p.xz = abs(p.xz - w);\n  float t = building(p);// - vec3(w,0,w));\n \n\n  return t;\n}\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\n\nfloat sss(vec3 p, vec3 l, float d) {\n  return smoothstep(0.0,1.0,map(p+l*d)/d);\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*789.451)*7541.223);\n}\n\nfloat rnd(vec2 t) {\n  return fract(dot(sin(t*vec2(789.451)+t.yx*vec2(842.544)),vec2(7541.223)));\n}\n\n\n\nvec3 flit(float t) {\n\n  vec3 x = normalize(vec3(1));\n  float t1 = tick(t);\n  float t2 = tick(t * .71);\n  float t3 = tick(t * .55);\n  x.yz *= rot(t1);\n  x.xz *= rot(t2);\n  x.yx *= rot(t3);\n  \n  return x;\n}\n\nvec3 bezier( float t ){\n  vec3 one = lattice(floor(t));\n  vec3 two = lattice(floor(t+1.));\n  float per = fract(t);\n  \n  return mix(one,two,per);\n  \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n \n\n  // nav\n  \n  float tt = iTime + 391.;\n  vec3 source = bezier(tt) * 350.;\n  vec3 target = bezier(tt + 10.) * 350.;\n  \n  //source.xz += vec2(building_spacing);\n  //target.xz += vec2(building_spacing);\n  \n  \n  \n  source += flit(tt * 1.31) * 17.1;\n  target += flit(tt * 1.51) * 17.1;\n\n  \n  vec3 arm = vec3(0,0,1);\n  arm.xz *= rot(tt * .25);\n  arm.yz *= rot(tt * .28);\n  arm.xy *= rot(tt * .11);\n\n  \n  \n  target += arm * 100.;\n \n  \n  vec3 down = vec3(0.,  tick(iTime * .3) * 331., 0.);\n  source += down;\n  target += down;\n  \n  \n  \n  delta = target - source;\n  \n \n \n  vec3 cz=normalize(target-source);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz*0.7);\n  \n  r.xy *= rot(sin(iTime/2.1)/4.1);\n  //vec3 r=normalize(vec3(-uv, 0.7));\n\n  vec3 p=source;\n  float i=0.;\n  float mask=1.0;\n  float d = 10000.0;\n  float dd = 0.;\n  float rand=rnd(uv);\n  \n  \n  // march\n  \n  int transp = int(mod(iTime * .7,2.));\n  bool hit = false;\n  for(float z=0.; z < 10000.; ++z) {\n    i = z;\n    d=map(p);\n    d = abs(d);\n    if(d<0.1) {\n      if ( matter == 1) {\n        float i = ink(mod(p.xz,150.));\n        //float i = ink(mod(p.xz + vec2(0,100), 110. ));\n        \n        \n        if ( transp == 0) {\n        \n          if (i > .2) {\n            d = .1;\n          } else {\n            hit = true;\n            break;\n          } \n        } else {\n          hit = true;\n          break;\n        }\n    \n      \n      }\n      \n      else if (matter == 2) {\n        hit = true;\n        break;\n      } else if ( matter ==3) {\n       vec3 n = norm(p);\n       r = reflect(r,n);\n       d = 0.2;\n       \n        \n      \n      }\n    }\n    if ( dd > 50000.) break;\n    dd += d;\n    p+=r*d;\n  }\n  \n  // hue\n \n  vec3 col;\n  \n  if ( matter == 1) {\n    float i = ink(mod(p.xz + vec2(0,100), 110. ));\n    col = vec3(1);\n    if ( i < 0.2) {\n      col = vec3(0);\n    }\n    if (i < -0.1) {\n \n    \n      col =  vec3(.8,.5,.1);\n      //col = vec3(.1,.2,.7);\n    \n    }\n    //col = vec3(.5);\n    \n\n  }\n  if (matter == 2) {\n    col = vec3(0);\n  }\n  \n \n  if ( matter == 3 ) {\n  \n    col = vec3(1,.5,0.);\n  }\n  \n  vec3 light =normalize(vec3(4,12.,2.));\n  light.xz *= rot(iTime);\n\n  light = abs(light);\n  \n \n  vec3 n = norm(p);\n  \n  float diff = max(0.0,dot(n,light)*0.5+0.5);\n  //float fren = pow(1.+dot(n,r),2.);\n  //float sss = sss(p,r,4.) * 2.;\n  //float spec= pow(max(dot(reflect(-light,n),-r),.0), 100.) * 5.;\n  //float shad = shadow(p, normalize(-light), .1, length(light-p));\n  //float fog =  pow(i/1000.,2.);\n  float fog =  dd/50000.;\n  \n  \n  //col -= diff * .75;\n  //col = mix(col, vec3(.5), fog);\n  //col += fren;\n  //col += sss;\n  //col += spec;\n  \n  //col *= shad;\n  //col = mix(col, vec3(0), fog);\n\n;\n \n \n  // sky\n  if (! hit ) {\n\n  \n    float per = dot(r, normalize(vec3(0,1,0)));\n    per = pow(per,0.9);\n   \n    //col =   mix(  vec3(.0,.5,1.), vec3(.0,.5,1.) * .1, per);\n    //col = mix(vec3(.8,.4,.2), vec3(.2,.5,1.) * .2,  (r.y));\n    col = mix(vec3(.0,.5,1.), vec3(.0,.5,1.) * .3, abs(r.y));\n    \n  }\n\n  fragColor = vec4(col, 1);\n\n\n  \n}\n\n\n/*\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lt3DN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[282, 282, 301, 301, 370], [372, 372, 394, 394, 524], [526, 526, 555, 555, 603], [606, 606, 653, 653, 699], [701, 701, 720, 720, 1279], [1318, 1318, 1337, 1337, 1780], [1782, 1782, 1802, 1802, 1822], [1826, 1826, 1853, 1853, 1921], [1923, 1923, 1951, 1951, 1975], [1976, 1976, 2005, 2005, 2092], [2093, 2093, 2135, 2135, 2242], [2244, 2244, 2272, 2272, 2298], [2300, 2300, 2328, 2328, 2361], [2364, 2364, 2411, 2411, 2457], [2461, 2461, 2502, 2502, 2670], [2673, 2673, 2694, 2694, 2985], [2987, 2987, 3006, 3006, 3114], [3116, 3116, 3155, 3155, 3232], [3234, 3234, 3270, 3270, 3348], [3350, 3350, 3370, 3370, 3464], [3487, 3487, 3511, 3511, 3566], [3570, 3570, 3591, 3591, 3640], [3642, 3642, 3667, 3667, 4136], [4200, 4200, 4224, 4237, 4941], [4945, 4945, 4965, 4975, 5085], [5086, 5086, 5105, 5105, 5224], [5226, 5226, 5267, 5267, 5313], [5315, 5315, 5351, 5351, 5396], [5398, 5398, 5418, 5418, 5461], [5463, 5463, 5482, 5482, 5561], [5565, 5565, 5585, 5585, 5769], [5771, 5771, 5794, 5794, 5920], [5921, 5921, 5978, 5978, 9197]], "test": "untested"}
{"id": "Nl33WM", "name": "Simplex Experiment #3b", "author": "Yusef28", "description": "This is an illustration of the stratificational nexus of a welfare state regime. The darker patches are all equally poor, aided by government funding. The lighter patches are unevenly wealthy.\n", "tags": ["triangles", "simplex"], "likes": 24, "viewed": 438, "published": 3, "date": "1636170657", "time_retrieved": "2024-07-30T18:50:13.856427", "image_code": "\n/*\nThis is an illustration of the stratificational nexus \nof a welfare state regime. The darker patches are all \nequally poor, aided by government funding. \n\nThe lighter patches are unevenly wealthy.\n\nThis is all bullshit btw lol.\n------------------------------------------------------\n\nThe magic of this shader is the movement \naided by the smoothmin function and a hacked together\nanimation sequence.\n*/\n\n//barycentric\n#define eps 8./iResolution.y\n#define S smoothstep\n\n//#define cross2D(a,b) a.y*b.x-a.x*b.y\n#define cross2D(a,b) (a).y*(b).x-(a).x*(b).y\n//skew matrix often written as \n//mat2 skew = mat2(1.1547, 0., 1.1547/2., 1.);\nmat2 skew = mat2(2./sqrt(3.), 0., 1./sqrt(3.), 1.); \n\n//This hash is pretty bad\nfloat badHash(vec2 x){\n    return fract(sin(dot(vec2(23.,72.),x)*134.)*43143.);\n}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n// based on comments from FabriceNeyret2\n// https://www.shadertoy.com/view/7d3SDS\n// super elegant\nvec2 bary(vec2 A, vec2 B, vec2 C, vec2 P,float smoothID){\n    \n    //We want areas for the three triangles created\n    //with out point P and the 3 sides\n    //we get a triangle with vectors AtoB and AtoP\n    //Repeat with B and C\n    vec3 tri = vec3(length(cross2D(B-A,P-A)),\n                    length(cross2D(C-B,P-B)),\n                    length(cross2D(A-C,P-C))\n                    );\n    //If P is in the middle, all areas are equal\n    //If P lays between two sub triangles, those areas\n    //will be equal and there will be one other area\n    \n    \n    //chill sort to find the smallest area triangle\n   \n    //id which we will swap simultenously\n    vec3 id = vec3(1.,2.,3.);\n   \n    //swap to get minumum at x\n    //swap remaining two to get minumum at y\n    if(tri.z < tri.y) tri = tri.xzy, id = id.xzy;\n    if(tri.y < tri.x) tri = tri.yxz, id = id.yxz;\n    if(tri.z < tri.y) tri = tri.xzy, id = id.xzy;\n    //with tri sorted, can do smoothstep without abs\n    \n    \n    //Those areas become a coordinate system because together \n    //they tell us relatively how close P is to any of \n    //the three sides.\n    \n    //so \"borders\" are like with uv.x-uv.y but now 3d \n    //border of area1 and area2 like (uv.y-uv.x)\n    float f1 = tri.y-tri.x - 0.04;\n    //border of area1 and area3 (uv.z-uv.y)\n    float f2 = tri.z-tri.x - 0.04;\n    return vec2(id.x, smin(f1,f2,smoothID*0.9));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 3.*(fragCoord*2.-iResolution.xy)/iResolution.y;\n    uv.x += iTime/4.;\n    \n    \n    uv *= skew;\n    vec2 uvFL = floor(uv);\n    uv = fract(uv);\n    vec2 f = 1.0 - S(0., eps, abs(uv-0.5)-0.47 );\n    float fd =  S(0., eps, abs(uv.x-uv.y)-0.02 );\n    float side = sign(uv.x-uv.y);\n    \n    \n    //the cool stuff\n    float smoothSeed = badHash(uvFL+float(side>0.)*0.5)*80.;\n    float smoothID = sin(smoothSeed +iTime\n    *4.)*0.5+0.5;\n    float closed = smoothstep(0.,0.5,sin(iTime/2.+smoothSeed)*0.5+0.5);\n    smoothID *= closed;\n\n\n    vec3 col;\n    \n    //get stuff from barycentric function\n    //stuff.x = the sub triangle id (1 to 3), stuff.y are outlines\n    vec2 stuff = bary(vec2(0.), \n                       vec2(1.,side<0.), \n                       vec2(side>0.,1.),\n                       uv,\n                       smoothID); //<--smoothID is for open/close anim\n    \n    //initial coloring\n    col = 0.6 + 0.3*cos(vec3(1.,2.,4.)/3. + \n          badHash(uvFL+side*0.5 + stuff.x/3.)*80. + iTime );\n  \n  \n    //do all the coloring(outlines, color when closed/not closed, etc)\n    col = mix(col, vec3(0.2), 1.-closed);\n    col += vec3(1.,0.,0.)*closed*0.18;\n    col *= f.x;\n    col *= f.y;\n    col *= fd;\n    col -= S(0.8,1.,(abs(sin(stuff.y*30.+2.))))*0.5;\n    col -= floor(stuff.y*30.)/24.;\n    col *= S(0.,eps,stuff.y);\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl33WM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[690, 716, 738, 738, 797], [798, 798, 839, 839, 932], [933, 1032, 1089, 1262, 2426], [2429, 2429, 2486, 2536, 3944]], "test": "untested"}
{"id": "Nt3GWM", "name": "Pathtrace with raytrace", "author": "rockhard", "description": "another raytrace scene.more SAMPLEs less noise.I can't use sdf shapes here...so slow still search the way outof stepmatch.", "tags": ["raytrace", "pathtrace"], "likes": 4, "viewed": 298, "published": 3, "date": "1636166012", "time_retrieved": "2024-07-30T18:50:14.713137", "image_code": "#define PI2 6.2831853\n#define BOUNCES 4\n#define SAMPLES 12.0\n#define FAR 50.0\n#define DELTA 1e-4\n#define GLASS_IOR 1.5\n//random function\nfloat seed;\nvec2 h2(){ \n    return fract(sin(vec2(seed+=0.1,seed+=0.2))*vec2(43758.5453123,2278.1));\n}\nfloat h(){ return fract(sin(seed+=0.1)*43758.5);}\nvec3 h3() { return fract(sin(seed+=0.1)*vec3(43758.5,22578.15,19642.3));\n}\n//math addon\nvec3 offset(vec3 direction,float multiplier){\n    vec3 random = h3()*multiplier-multiplier*0.5;\n    return normalize(direction+random);\n}\nvec3 cosineWeightedSample(vec3 n){    \n    vec2 r = h2();    \n    float a = 6.2831853 * r.x,u = 2.0*r.y - 1.0;\n    return normalize( n + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)),u));\n}\nfloat fresnel(float na,float nb,vec3 incidence,vec3 normal){\n    float r = pow((na-nb)/(na+nb),2.0);\n    float cx = -dot(normal,incidence);\t\t\t\t\n    if(na>nb){\n        float q = na/nb;\n        float s2 = pow(q,2.0)*(1.0-pow(cx,2.0));\n        if(s2>1.0) return 1.0;\n        cx = sqrt(1.0-s2);\n    }\t\t\t\t\n    float x = 1.0-cx;\n    float ret = r+(1.0-r)*pow(x,5.0);\n    return clamp(ret,0.0,1.0);\n}\n//material list type 1:glass ,c:color e:emissive ref:reflectiove\nstruct material{ int type;vec3 c,e;float rough,ref;};\n\nmaterial mats(int id){\nif(id==0)  return material(0,vec3(1.0,0.01,0.01),vec3(0.0),0.0,0.0);\nelse if(id==1) return material(0,vec3(1.0,1.0,0.0),vec3(0.0),0.5,9.0);\nelse if(id==2) return material(0,vec3(0.02,0.1,1.0),vec3(0.0),0.0,10.0);\nelse if(id==3) return material(0,vec3(0.81,0.61,0.01),vec3(0.0),0.0,10.0);\nelse if(id==4) return material(0,vec3(1.0,1.0,1.0),vec3(0.0),0.0,0.0);\nelse if(id==5) return material(0,vec3(0.0,0.85,0.15),vec3(0.0),0.5,8.0);\nelse if(id==6) return material(1,vec3(0.7,0.2,0.9),vec3(0.0),0.0,10.0);\nelse if(id==7) return material(0,vec3(1.0,0.25,0.65),vec3(0.0),0.0,0.0);\nelse if(id==8) return material(0,vec3(1.0,1.0,0.95),vec3(0.0),0.0,2.5); \nelse if(id==9) return material(0,vec3(1.0,1.0,1.0),vec3(0.0),0.0,0.0);\nelse if(id==10) return material(0,vec3(sin(iTime)*0.5+0.5,0.8,0.5),vec3(1.0),0.0,0.0);\nreturn material(0,vec3(0.0),vec3(0.0),0.0,0.0);\n}\n#define NUMSBOXES 3\n// box: position ,scale ,material ID\nbox boxes(int id){\nif(id==0) return box(vec3(0,-1,0),vec3(10,1,10), 8);\nelse if(id==1) return box(vec3(-1.0,0.5,2.5),vec3(1.0,0.5,0.1),9);\nelse if(id==2) return box(vec3(-2.0,0.65,0),vec3(0.025,0.65,1), 10);\nreturn box(vec3(0.0),vec3(0.0),0);\n}\n#define NUMSPHERES 8\n// sphere: position, radius ,material ID\nsphere spheres(int id){\nif(id==0) return sphere(vec3(0.5,sin(iTime)+1.6,-1),0.6,0);\nelse if(id==1)return sphere(vec3(-0.36,0.7,0.2),0.7,1);\nelse if(id==2)return sphere(vec3(1,0.5,1),0.5,2);\nelse if(id==3)return sphere(vec3(-0.3,0.3,1.5),0.3,3);\nelse if(id==4)return sphere(vec3(0.36,0.5,-0.2),0.5,4);\nelse if(id==5)return sphere(vec3(-0.62,0.26,-0.42),0.26,5);\nelse if(id==6)return sphere(vec3(-0.6,0.3,1.05),0.3,6);\nelse if(id==7)return sphere(vec3(-0.25,0.38,-0.52),0.38,7);\nreturn sphere(vec3(0.0),0.0,0);\n}\n//trace\n//hitinfo: position ,normal ,distance ,material ID\nhitinfo map(ray r){ \n   hitinfo rec=hitinfo(vec3(0.0),vec3(0.0),FAR,0); \n   rec=rayBox(boxes(0),r,rec); \n    rec=rayBox(boxes(1),r,rec); \n     rec=rayBox(boxes(2),r,rec); \n   rec=raySphere(spheres(0),r,rec); \n    rec=raySphere(spheres(1),r,rec); \n     rec=raySphere(spheres(2),r,rec); \n      rec=raySphere(spheres(3),r,rec); \n       rec=raySphere(spheres(4),r,rec); \n        rec=raySphere(spheres(5),r,rec); \n         rec=raySphere(spheres(6),r,rec); \n          rec=raySphere(spheres(7),r,rec); \n   return rec;\n}\nray rayhit(hitinfo rec, ray r, inout vec3 attenuation) {\n    if(rec.t==FAR) return r;\n    material m =mats(rec.mat);  \n    ray r1=ray(vec3(0.0),vec3(0.0));\n    if(m.type==0){\n        r1.ori =rec.p+rec.n*DELTA; r1.dir=r.dir; \n        if(m.ref>0.0&&fresnel(1.0,GLASS_IOR,r.dir,rec.n)*m.ref>h()){                   \n               r1.dir = reflect(r1.dir,rec.n); \n               if(m.rough>0.0)r1.dir = offset(r1.dir,m.rough);\n          }else    \n         r1.dir=cosineWeightedSample(rec.n); //normalize(rec.n + random());\n         attenuation = m.c; return r1; \n       }\n     else if(m.type==1){            \n           if(fresnel(1.0,GLASS_IOR,r.dir,rec.n)-0.07>h()){   \n                    r1.ori = rec.p+rec.n *DELTA;                 \n                    r1.dir = reflect(r.dir,rec.n);\n                }else{    \n                    r1.ori = rec.p+r.dir*DELTA;            \n                    r1.dir = refract(r.dir,rec.n,1.0/GLASS_IOR);\t \n                 }\n            attenuation = m.c;  return r1;\n      }\n    return r;\n}\n\nvec3 ray_color(ray r) {\n    vec3 color =vec3(1.0);\n    vec3 acc=vec3(0.0);\n    hitinfo rec;\n    for (int depth = 0; depth < BOUNCES; depth++) {\n        rec=map(r);\n        if (rec.t<FAR) {           \n            vec3 rc= vec3(0.0);\n            r = rayhit(rec, r, rc);\n            color *=rc;\n            //emissive\n            vec3 em = mats(rec.mat).e;        \n            if(em.x>0.0||em.y>0.0||em.z>0.0){ acc+=color*em;  break; } \n        } \n        else { //simple sky and ground color    \n           float t =acos(rec.n.y)*0.31831;\n           color *= mix(vec3(0.35,0.5,0.7),vec3(0.2, 0.15, 0.12),t);\n            acc+=color;\n            break;\n        }\n    }\n    return acc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    seed=fragCoord.x *7.0+fragCoord.y*1.7317+1.17;\n\n    mat3 camrot=rotXY(0.5,iTime*0.2);\n    vec3 ro=camrot[2]*5.0;\n    vec3 rd=getdir(uv,camrot);\n     \n    \n    vec3 col = h3();\n    \n    ray ra=ray(ro,rd);\n    float aaRadius=0.006875;\n    //jitter samples can handle AA\n    for (float s = 0.; s < SAMPLES; s++) {\n      ra.ori=ro+h3()*aaRadius;\n      col+= ray_color(ra);\n      seed = mod((seed+s)*1.1291,11.0); \n    }\n    col=pow(col/SAMPLES,vec3(0.5));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define DELTA 1e-4\n//ray definition\nstruct ray { vec3 ori,dir;};\n//trace result\nstruct hitinfo { vec3 p,n;float t;int mat;};\n//shape definition\nstruct sphere { vec3 p;float r;int mat;};\nstruct box{ vec3 p,s;int mat;};\n\nhitinfo raySphere(sphere sph, ray r,hitinfo rec){    \n    vec3 oc = r.ori - sph.p;\n    float a = dot(r.dir, r.dir);\n    float half_b = dot(oc, r.dir);\n    float c = dot(oc, oc) - sph.r * sph.r;\n    float disc = half_b * half_b - a * c;\n    if (disc < DELTA) return rec; \n    \n    float closest = rec.t;\n    float sqrtd = sqrt(disc); \n    float root = (-half_b - sqrtd) / a;\n    if (root<DELTA|| closest < root) \n          return rec; \n    hitinfo hit;  \n    hit.p = r.ori + r.dir * root;\n    hit.n= (hit.p - sph.p) / sph.r; hit.t= root; hit.mat=sph.mat;\n    return hit;\n} \nhitinfo rayBox(box b, ray r,hitinfo rec){\n    vec3 bmin=b.p-b.s,bmax=b.p+b.s;\n    vec3 p=r.ori,d=r.dir; \n    float tymin, tzmin, tymax, tzmax; \n    float tmin,tmax; \n      if (d.x >= 0.0){ tmin = (bmin.x - p.x) / d.x;  tmax = (bmax.x - p.x) / d.x; }\n      else { tmin = (bmax.x - p.x) / d.x; tmax = (bmin.x - p.x) / d.x;  }\n      if (d.y >= 0.0) { tymin = (bmin.y - p.y) / d.y; tymax = (bmax.y - p.y) / d.y; }\n      else { tymin = (bmax.y - p.y) / d.y;  tymax = (bmin.y - p.y) / d.y; }\n\n      if ((tmin > tymax) || (tymin > tmax)) return rec;\n      if (tymin > tmin) tmin = tymin;\n      if (tymax < tmax) tmax = tymax;\n\n      if (d.z >=0.0){ tzmin = (bmin.z - p.z) / d.z; tzmax = (bmax.z - p.z) / d.z; }\n      else { tzmin = (bmax.z - p.z) / d.z; tzmax = (bmin.z - p.z) / d.z; }\n      if ((tmin > tzmax) || (tzmin > tmax)) return rec;\n      if (tzmin > tmin) tmin = tzmin;\n      if (tzmax < tmax) tmax = tzmax;\n   if(tmin<0.0||rec.t<tmin)return rec;\n    hitinfo hit;  \n    hit.p = r.ori + r.dir * tmin;\n    vec3 center = b.p,size = b.s;\n    vec3 pc = hit.p-center;\n    vec3 normal = vec3(sign(pc.x)* step(abs(abs(pc.x) - size.x),DELTA),\n\tsign(pc.y) * step(abs(abs(pc.y) - size.y), DELTA),\n\tsign(pc.z) * step(abs(abs(pc.z) - size.z), DELTA));\n    hit.n=normalize(normal); hit.t= tmin; hit.mat=b.mat;\n    return hit;\n} \nmat3 rotXY(float rX, float rY){\n float cx = cos(rX),sx = sin(rX),cy = cos(rY),sy=sin(rY);\n return mat3(-sy, 0, -cy, -sx * cy, cx, sx * sy,cx * cy, sx, -cx * sy);\n}\n\nvec3 getdir(vec2 p,mat3 m){\n  return normalize(vec3(p.x * m[0].x + p.y * m[1].x - m[2].x, \n       p.x * m[0].y + p.y * m[1].y - m[2].y, \n       p.x * m[0].z + p.y * m[1].z - m[2].z));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt3GWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[149, 149, 159, 159, 239], [240, 240, 250, 250, 289], [290, 290, 301, 301, 364], [365, 378, 423, 423, 515], [516, 516, 550, 550, 701], [702, 702, 762, 762, 1095], [1216, 1216, 1238, 1238, 2096], [2117, 2154, 2172, 2172, 2398], [2420, 2461, 2484, 2484, 2971], [2972, 3031, 3050, 3050, 3543], [3544, 3544, 3600, 3600, 4569], [4571, 4571, 4594, 4594, 5253], [5255, 5255, 5312, 5312, 5884]], "test": "untested"}
{"id": "fttGWH", "name": "BeyondBeliefs", "author": "stephenl7797", "description": "Recreation of\nhttps://www.youtube.com/watch?v=aVTalm2VjDc\nStill like the original much more :|", "tags": ["particles", "musicvideo", "reproduction"], "likes": 28, "viewed": 504, "published": 3, "date": "1636164244", "time_retrieved": "2024-07-30T18:50:15.733408", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / R;\n#if 0\n    vec4 c = IC2(ivec2(fragCoord));\n    fragColor = c;\n#else\n    // If dense area, then blur.\n    float density = 0.;\n    vec4 c0 = IC2(ivec2(fragCoord));\n    ivec2 fc = ivec2(fragCoord);\n    \n    vec4 avg = vec4(0.);\n    avg.a = 0.;\n    \n    for (int i=-1;i<2;i++) {\n        for (int j=-1;j<2;j++) {\n\n            vec2 uv1 = uv+vec2(float(i)*1.25,float(j)*1.25)/R.xy;\n            vec4 s = C2(uv1);\n            \n            density += length(s.rgb);\n        }\n    }\n    \n    density = density / (sqrt(3.) * 9.);\n    \n    float density2 = pow(density / .97, 2.);\n    \n        \n    // This doesn't work well. It'd be better to use multiple buffers\n    // to do a larger radius more efficiently.\n    // Also, perhaps blurring in a time averaged buffer would help propagate\n    // the blur and highlights, which would be nice.\n    \n    //for (int i=-2;i<5;i++) { for (int j=-2;j<5;j++) {\n    //for (int i=-3;i<7;i++) { for (int j=-3;j<7;j++) {\n    for (int i=-1;i<2;i++) { for (int j=-1;j<2;j++) {\n            vec2 uv1 = uv+vec2(float(i)*2.15,float(j)*2.15)/R.xy;\n            float d = length(vec2(i,j));\n            //float d = float(i*i+j*j);\n            float w = exp(-d / (density*density*density * 8.15));\n            vec4 s = C2(uv1) * w;\n            s.a = w;\n            avg += s;\n        }\n    }\n    //avg.rgb = c0.rgb; avg.a = 1.;\n    \n\n    \n    fragColor = avg / avg.a;\n    \n    \n    fragColor.rgb += density2;\n    \n#endif\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define IR ivec2(iResolution.xy)\n#define C0(uv) texture(iChannel0, (uv))\n#define C1(uv) texture(iChannel1, (uv))\n#define C2(uv) texture(iChannel2, (uv))\n#define IC0(p) texelFetch(iChannel0, (p), 0)\n#define IC1(p) texelFetch(iChannel1, (p), 0)\n#define IC2(p) texelFetch(iChannel2, (p), 0)\n#define IC3(p) texelFetch(iChannel3, (p), 0)\n\n\nfloat hashXY(ivec2 xy, ivec2 ir) {\n    return float(xy.y * ir.x + xy.x);\n}\nivec2 unhashXY(int h, ivec2 ir) {\n    return ivec2(h%ir.x, h/ir.x);\n}\n\nvec2 proj(vec3 p, vec2 RR, float tt) {  \n    //p.z += RR.x * 3.8;\n    //p.z /= RR.x * 2.6;\n\n    //if (p.z < .0) return vec2(9999.,9999.);\n\n    return (p.xy / p.z) * RR.yy * .5 + RR.xy * .5;\n}\nvec3 proj_d(vec3 p, vec2 RR, float tt) { \n    //p.z += RR.x * 3.8;\n    //p.z /= RR.x * 2.6;\n\n    //if (p.z < .0) return vec2(9999.,9999.);\n\n    return vec3(p.xy/p.z,p.z) * vec3(RR.yy*.5,1.) + vec3(RR.xy,0.) * .5;\n}\n\n\n\nfloat rand11(float x) { return fract(337.1*sin(x*22.13+11.2)); }\nvec2 rand22(vec2 p) { return fract(vec2(\n    337.1*sin(22.3+27.31*p.y+p.x*22.13),\n    437.1*sin(1.7+22.31*p.y+p.x*29.13) )); }\nvec3 rand23(vec2 p) { return fract(vec3(\n    337.1*sin(22.3+27.31*p.y+p.x*22.13),\n    437.1*sin(1.7+22.31*p.y+p.x*29.13),\n    407.1*sin(111.7+12.31*p.y+p.x*19.13) )); }\nvec3 rand33(vec3 p) { return fract(vec3(\n    337.1*sin(22.3+27.31*p.y+p.x*22.13+p.z*19.2),\n    437.1*sin(1.7+22.31*p.y+p.x*29.13+p.z*10.3),\n    407.1*sin(111.7+12.31*p.y+p.x*19.13+p.z*8.2) )); }\nfloat rand31(vec3 p) { return fract(\n    473.1*sin(2.3+117.31*p.y+p.x*229.13+p.z*9.2)); }\n    \n//float smoo(float v) { return v*v*(3.-2.*v); }\nfloat smoo(float v) { return v; }\nvec3 noise33(vec3 x) {\n    vec3 o = vec3(0.);\n    vec3 fx = floor(x);\n    vec3 lx = fract(x);\n    for (int i=0; i<8; i++) {\n        float dx = (i  ) % 2 == 0 ? 1. : 0.;\n        float dy = (i/2) % 2 == 0 ? 1. : 0.;\n        float dz = (i/4) % 2 == 0 ? 1. : 0.;\n        vec3 v  = rand33(fx + vec3(dx,dy,dz));\n        vec3 d = vec3(dx,dy,dz) * 2. * lx + 1. - lx - vec3(dx,dy,dz);\n        o += smoo(d.x)*smoo(d.y)*smoo(d.z)*v;\n    }\n    return o;\n}\nfloat noise31(vec3 x) {\n    float o = (0.);\n    vec3 fx = floor(x);\n    vec3 lx = fract(x);\n    for (int i=0; i<8; i++) {\n        float dx = (i  ) % 2 == 0 ? 1. : 0.;\n        float dy = (i/2) % 2 == 0 ? 1. : 0.;\n        float dz = (i/4) % 2 == 0 ? 1. : 0.;\n        float v  = rand31(fx + vec3(dx,dy,dz));\n        vec3 d = vec3(dx,dy,dz) * 2. * lx + 1. - lx - vec3(dx,dy,dz);\n        o += smoo(d.x)*smoo(d.y)*smoo(d.z)*v;\n    }\n    return o;\n\n}\n\nfloat phase_at(vec3 p, float iTime) {\n    iTime -= 7.5;\n    return fract(iTime * 2.) * .3 + .7 * noise31(-1. + p.xyz * .01 + vec3(0., 0., iTime * .65));\n    return noise31(-1. + p.xyz * .01 + vec3(0., 0., iTime * .65));\n}\n\nvec3 cmap(float t) {\n    //vec3 speed = vec3(.3, .562*t, .55) * 3. * 3.141;\n    //vec3 mult  = vec3(1.);\n    //vec3 bias  = vec3(-.1, .1, .9);\n    //vec3 shft  = vec3(.7, .35, .2) * 6.282;\n    //vec3 c = cos(speed*t+shft) * mult + bias;\n    \n    t = (t - .1) / .9;\n    vec3 cc[6];\n    cc[0] = vec3(0.980, 0.952, 0.819);\n    cc[1] = vec3(0.849, 0.658, 0.249);\n    cc[2] = vec3(0.933, 0.401, 0.149);\n    cc[5] = vec3(0.656, 0.849, 0.933);\n    cc[4] = vec3(0.590, 0.684, 0.997);\n    cc[3] = vec3(0.411, 0.476, 0.591);\n    int i = int(t*6.);\n    int j = int(t*6.+1.) % 6;\n    //int h = int(t*6.-1.) % 6;\n    //if ((t*6.-1.) < 0.) h = 6;\n    vec3 c = vec3(0.);\n    float tt = 1.-fract(t*6.);\n    //c  = mix(cc[h], cc[i], fract(t*6.)) * (1.-tt); \n    c += mix(cc[i], cc[j], fract(t*6.));// * tt;\n    \n    return c;\n}", "buffer_a_code": "// Particle Sim.\n\n// Currently, I spawn particles with z range [200-300],\n// but opacity fades in after coming forward under 200.\n// This gives the spatial clustering effect and appears to be what's done in the video.\n// However it wastes a lot of particles and time.\n// Perhaps instead I could spawn closer and use rejection sampling to\n// get the clustering from the start?\n\n\nvec3 initParticle(vec2 fc) {\n    vec3 p = (rand23(fc) - .5) * vec3(R.xy*.95,10.) + vec3(0.,0.,205.); // z : [200-300]\n    \n    //vec3 p = (rand23(fc) - .5) * vec3(R.xy*1.15,20.) + vec3(0.,0.,205.); // z : [200-300]\n    //if (abs(pow(noise31(vec3(p.xy*.05-100.,iTime*.01)),1.) - fc.x/R.x) > .05) p = vec3(-9999.);\n    // Well this is like rejection sampling over time, not as efficient as a loop over random positions tho\n    if (abs(pow(noise31(vec3(p.xy*.005-100.,fc.x*.007+iTime*.02)),1.)) < .72) p = vec3(-9999.,-9999.,1.);\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec4 old = IC0(ivec2(fragCoord));\n    \n    //if (old.w < 0. || iFrame == 0 || IC3(ivec2(0,82)).r > 0.5) {\n    //if (iFrame==0) {\n    vec2 po = proj(old.xyz, R, iTime);\n    bool bad = abs(po.x - R.x/2.) > R.x/1.8 || abs(po.y - R.y/2.) > R.y/1.8 || po.x < -8500.;\n    //bad = false;\n    // Wipe away by phase.\n    if (bad || abs(old.w-fract(iTime * .12 + fragCoord.x/R.x * .51)) < .006 || iFrame == 0 || texelFetch(iChannel3, ivec2(82, 0), 0).r > .5) {\n          old.xyz = initParticle(fragCoord);\n        //old.w = .5 + rand11(fragCoord.x*1000.+fragCoord.y);\n        //old.w = noise31(-1. + old.xyz * .015 + vec3(0., 0., iTime * 4.95));\n        old.w = phase_at(old.xyz,iTime);\n        //old.w = rand31(-22. + old.xyz * .04 + vec3(0., 0., iTime * 222.5));\n    }\n\n    vec4 vel = vec4(0.);\n    vec3 t0 = vec3(0., 0., iTime * .21 + old.z*.0001);\n    float CHAOS = .0001; // Add random offset to noise sample func\n    vel.xyz = (noise33(fragCoord.xyx*CHAOS + old.xyz * .001 + t0)-.5) +\n              (noise33(old.xyz * .0108 + 200. + t0*1.25)-.5) * .675;\n    vel.z = (vel.z * .21) + -.16;\n    vel.xy  *= 1.5;\n    vel.w = .0003; // Phase moves a little.\n    \n    //vel *= pow(.4 + rand31(old.xyz*.01),2.);\n    // Move different colors at different speeds at different times.\n    vel *= pow(.7 + .62*abs(fract(iTime*.4)-old.w), 1.);\n    \n    //vel.w = -1. / 60.;\n    vec4 new = old + vel;\n    new.w = fract(new.w);\n\n    //new.z = 200.;\n    fragColor = new;\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Particle Tracking.\n\n// TODO:\n// Have two seperate groups of two tracked particles.\n// One on the entire set.\n// One only on the first 1/100th.\n// That way we can shade both at a high LoD and a low.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n    vec4 old = IC0(ivec2(fragCoord));\n    vec2 q0[4];\n    q0[0] = proj(IC1(unhashXY(int(old.x),IR)).xyz, R,iTime);\n    q0[1] = proj(IC1(unhashXY(int(old.y),IR)).xyz, R,iTime);\n    q0[2] = proj(IC1(unhashXY(int(old.z),IR)).xyz, R,iTime);\n    q0[3] = proj(IC1(unhashXY(int(old.w),IR)).xyz, R,iTime);\n    vec4 d = vec4(length(fragCoord - q0[0]),\n                  length(fragCoord - q0[1]),\n                  length(fragCoord - q0[2]),\n                  length(fragCoord - q0[3]));\n    vec4 new = old;\n    \n    //int MAX_PARTICLE_CNT = IR.x * IR.y;\n    int MAX_PARTICLE_CNT = IR.x * IR.y / 1;\n    int MAX_PARTICLE_CNT_2 = IR.x * IR.y / 100;\n\n    #if 1\n    \n    // Random.\n    int samples = 12;\n    for (int i=0; i<samples; i++) {\n        // I think these hash functions are bad.\n        int rr = int(iFrame*977*samples + i*3373 + int(fragCoord.x*202.537 + fragCoord.y*492.233)) % MAX_PARTICLE_CNT;\n        //int rr = int(iTime*997.3 + fragCoord.x*222.3 + fragCoord.y*127.3) + (i)*97;\n        int ry = (rr / IR.x);\n        int rx = rr % IR.x;\n        \n        vec4 q1 = IC1(ivec2(rx,ry));\n        q1.xy = proj(q1.xyz, R,iTime);\n        float d1 = length(fragCoord - q1.xy);\n        \n        \n        if (d1 <= d[0]) {\n            if (d1<d[0]) {\n            new[3] = new[2], d[3] = d[2];\n            new[2] = new[1], d[2] = d[1];\n            new[1] = new[0], d[1] = d[0];\n            }\n            new[0] = hashXY(ivec2(rx,ry), IR); d[0] = d1;\n        } else if (d1 <= d[1]) {\n            if (d1<d[1]) {\n            new[3] = new[2], d[3] = d[2];\n            new[2] = new[1], d[2] = d[1];\n            }\n            new[1] = hashXY(ivec2(rx,ry), IR); d[1] = d1;\n        } else if (d1 <= d[2]) {\n            if (d1<d[2])\n            new[3] = new[2], d[3] = d[2];\n            new[2] = hashXY(ivec2(rx,ry), IR); d[2] = d1;\n        } else if (d1 <= d[3]) {\n            new[3] = hashXY(ivec2(rx,ry), IR); d[3] = d1;\n        }\n        \n    }\n    \n    \n    // Neighbor.\n    ivec2 fc = ivec2(fragCoord);\n    for (int i = 0; i < 4; i++) {\n        ivec2 fc1 = fc+ivec2(i==0?-1:i==1?1:0, i==2?-1:i==3?1:0);\n        if (fc1.x < 0 || fc1.y < 0 || fc1.x >= IR.x || fc1.y >= IR.y) continue;\n        vec4 neigh = IC0(fc1); \n        \n        for (int j=0; j<4; j++) {\n            ivec2 ixy = unhashXY(int(neigh[j]), IR);\n            vec4 qnew = IC1(ixy);\n            qnew.xy = proj(qnew.xyz, R,iTime);\n\n            float d1 = length(qnew.xy - fragCoord);\n\n            if (d1 <= d[0]) {\n            if (d1<d[0]) {\n                new[3] = new[2], d[3] = d[2];\n                new[2] = new[1], d[2] = d[1];\n                new[1] = new[0], d[1] = d[0];\n                }\n                new[0] = neigh[j], d[0] = d1;\n\n            } else if (d1 <= d[1]) {\n            if (d1<d[1]) {\n                new[3] = new[2], d[3] = d[2];\n                new[2] = new[1], d[2] = d[1];\n                }\n                new[1] = neigh[j]; d[1] = d1;\n            } else if (d1 <= d[2]) {\n            if (d1<d[2])\n                new[3] = new[2], d[3] = d[2];\n                new[2] = neigh[j]; d[2] = d1;\n            } else if (d1 <= d[3]) {\n                new[3] = neigh[j], d[3] = d1;\n            }\n        }\n    }\n    \n    #else\n    \n    IMPLEMENT THE TWO GROUP THING\n    \n    #endif\n\n\n    if (iFrame == 0) new = vec4(0.);\n\n    fragColor = new;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Time Filtered main image.\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //vec3 col1 = cmap(uv.x);    fragColor.rgb = col1;    return;\n\n    \n    vec4 ids = IC0(ivec2(fragCoord));\n    vec4 qq[4];\n    qq[0] = IC1(unhashXY(int(ids.x),IR));\n    qq[1] = IC1(unhashXY(int(ids.y),IR));\n    qq[2] = IC1(unhashXY(int(ids.z),IR));\n    qq[3] = IC1(unhashXY(int(ids.w),IR));\n    vec3 q[4];\n    for (int i=0; i<4; i++) q[i] = proj_d(qq[i].xyz, R, iTime);\n    vec4 d = vec4(length(fragCoord - q[0].xy),\n                  length(fragCoord - q[1].xy),\n                  length(fragCoord - q[2].xy),\n                  length(fragCoord - q[3].xy));\n                  \n  vec4 old = IC2(ivec2(fragCoord));\n\n              \n    \n    vec4 dp = d + fract(ids[0] * .577) * 1.;\n    \n    // Nice: by making the particles large and weighing opacity\n    // by relative distances, we can get the puffy textured particles\n    // like in the video.\n    \n    vec4 col = vec4(0.);\n    for (int i=0; i<4; i++) {\n        float di = d[i];\n        float sz = fract(ids[i] * .177) * 92.5 + 4.;\n        \n        // Anything behind 300: invisible. Smoothly fade in from 220\n        float opacity = clamp(.1 + fract(ids[0]*.311) * .35 + 1. / sqrt(sz), 0., 1.) * smoothstep(199.,190.,q[i].z);\n        //opacity = .1 + fract(ids[i] *  .3937) * .95;\n        \n        \n        //opacity = step(100., q[i].z);\n        if (di < sz) {\n            float phase = qq[i].w;\n            col.rgb += opacity * cmap(phase) / (dp[i]);\n            col.a += opacity * q[i].z / 4.;\n        }\n    }\n    col.rgb /= (1./dp[0]+1./dp[1]+1./dp[2]+1./dp[3]);\n    //col.r = pow(col.r, .7); col.b = pow(col.b, .7); col.g = pow(col.g, .7);\n    \n    //col.rgb *=  d[3]\n    float attrib = .12+fract(ids[0] * .111)*1.2; // Controls spikiness.\n    d *= .05 * (attrib);\n    d.rgb += .05 / attrib;\n    float denom = .051 + fract(ids[0]*.177) * .35;\n    d.yzw   =  0.01 / (denom + d.yzw);\n    //col.rgb *= vec3(1. / d[2], 1. / d[1], 1. / d[0]) * d[3];\n    col.rgb *= sqrt(d[3]) / (d[0]);\n    \n    // Mix a lot of new when bright, and keep old if not bright.\n    float alpha = length(col.rgb) * .16 + .02;\n    col.rgb = col.rgb * alpha + old.xyz * (1.-alpha);\n    col.a = col.a * .1 + old.a * .9;\n    \n    //col.rgb *= .98 + .5 * sqrt(sqrt(d[0]*d[1]*d[2]*d[3]));\n    \n\n    fragColor = vec4(col);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fttGWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 59, 1524]], "test": "untested"}
{"id": "stdGDN", "name": "Wowie!", "author": "ruojake", "description": "Playing with inverse kinematics.", "tags": ["2d", "ik", "fabrik"], "likes": 18, "viewed": 296, "published": 3, "date": "1636162598", "time_retrieved": "2024-07-30T18:50:16.504347", "image_code": "// Wowie! by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\n#define saturate(x) clamp((x), 0., 1.)\n\nstruct seg\n{\n    vec2 p0, p1;\n    float len, r, c;\n};\n\nfloat sm(float a, float b, float q)\n{\n    float d = saturate((b - a) / q + .5);\n    float m = -.125 * q * d * (1. - d);\n    return mix(a, b, d) - m;\n}\n\nfloat line(vec2 p, float r, vec2 a, vec2 b)\n{\n    vec2 a2b = b - a,\n         a2p = p - a;\n    return length(a2p\n                - saturate(dot(a2p, a2b) / dot(a2b, a2b))\n                * a2b) - r;\n}\n\nvoid solveIK(vec2 root, vec2 target, inout seg segs[6])\n{\n    #define P0 segs[i].p0\n    #define P1 segs[i].p1\n    \n    for(int i = 5; i > -1; --i)\n    {\n        P1 = target;\n        P0 = P1 + normalize(P0 - P1) * segs[i].len;\n        target = P0;\n    }\n    \n    vec2 dir = normalize(segs[0].p1 - segs[0].p0);\n    \n    for(int i = 0; i < 6; ++i)\n    {\n        P0 = root;\n        \n        vec2 newDir = normalize(P1 - P0);\n        float t = dot(dir, newDir) * -.5 + .5;\n        t *= segs[i].c;\n        \n        newDir = normalize(mix(newDir, dir, t));\n        \n        P1 = P0 + newDir * segs[i].len;\n        \n        dir = newDir;\n        root = P1;\n    }\n    #undef P0\n    #undef P1\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\n    seg segs[6] = seg[]\n    (\n        seg(vec2(-.1),  vec2(.01), .1, .025,  1. ),\n        seg(vec2(.02), vec2(-.01), .1, .02,   1. ),\n        seg(vec2(-.02), vec2(.03), .1, .015,  .75),\n        seg(vec2(.04), vec2(.03), .1, .0125, .5 ),\n        seg(vec2(.04), vec2(-.05), .1, .01,   .25),\n        seg(vec2(-.06), vec2(.05), .1, .0075, 0. )\n    );\n\n    vec2 target = vec2(sin(iTime), sin(iTime * 1.333)) * .4;\n    vec2 root = vec2(-.5);\n    \n    float d = 1000.;\n\n    solveIK(root, target, segs);\n    solveIK(root, target, segs);\n\n    for(int i = 0; i < 6; ++i)\n    {\n        d = sm(d, line(uv, segs[i].r, segs[i].p0, segs[i].p1), -.1);\n    }\n\n    vec2 flip = vec2(-1, 1);\n\n    solveIK(root, target * flip, segs);\n    solveIK(root, target * flip, segs);\n\n    for(int i = 0; i < 6; ++i)\n    {\n        d = sm(d, line(uv * flip, segs[i].r, segs[i].p0, segs[i].p1), -.1);\n    }\n\n    solveIK(root * flip, -target, segs);\n    solveIK(root * flip, -target, segs);\n\n    for(int i = 0; i < 6; ++i)\n    {\n        d = sm(d, line(-uv, segs[i].r, segs[i].p0, segs[i].p1), -.1);\n    }\n\n    solveIK(root, -target, segs);\n    solveIK(root, -target, segs);\n\n    for(int i = 0; i < 6; ++i)\n    {\n        d = sm(d, line(-uv, segs[i].r, segs[i].p0, segs[i].p1), -.1);\n    }\n\n    vec3 col = vec3(.8,.55,.05);\n    \n    \n    float blush = smoothstep(.2, 0., length(vec2(.4, 0) - abs(uv + vec2(0,.1))));\n    col = mix(col, vec3(1,.2,.2), blush * .3);\n    \n    \n    float eyeball = length(abs(uv) - vec2(.2, 0)) - .1;\n    \n    vec2 posPup = vec2(-.2, 0) + normalize(target - vec2(-.2,0)) * .07;\n    float pupL = length(uv - posPup) - .01;\n    \n    posPup = vec2(.2, 0) + normalize(target - vec2(.2,0)) * .07;\n    float pupR = length(uv - posPup) - .01;\n    \n    float outline = abs(eyeball) - .002;\n    outline = smoothstep(fwidth(outline), 0., outline);\n    eyeball = smoothstep(fwidth(eyeball), 0., eyeball);\n    pupL = smoothstep(fwidth(pupL), 0., pupL);\n    pupR = smoothstep(fwidth(pupR), 0., pupR);\n    \n    col = mix(col, vec3(.9), eyeball);\n    col *= 1. - outline;\n    col *= 1. - max(pupL, pupR);\n    \n    \n    float mouth = line(abs(uv + vec2(0.,.25)), .07, vec2(0), vec2(.2, 0) * (length(target) * 2.));\n    mouth = smoothstep(0.,fwidth(mouth), mouth);\n    col *= mouth;\n    \n    \n    float ball = length(uv - target) - .04;\n    outline = abs(ball) - .002;\n    outline = min(outline, abs(min(ball, d)) - .001);\n    \n    d = smoothstep(fwidth(d), 0., d);\n    ball = smoothstep(fwidth(ball), 0., ball);\n    outline = smoothstep(0., fwidth(outline), outline);\n    col = mix(col, vec3(.6,.45,0.), d);\n    col = mix(col, vec3(1,.4,.8), ball) * outline;\n    \n    col *= smoothstep(1., .3, length(fragCoord / iResolution.xy - .5));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdGDN.jpg", "access": "api", "license": "cc-by-sa-4.0", "functions": [[202, 202, 239, 239, 352], [354, 354, 399, 399, 553]], "test": "untested"}
{"id": "stdGWN", "name": "Granular Synthesis", "author": "paniq", "description": "combining cosine shaped grains, see granular() in Common", "tags": ["sound", "adsr", "granular"], "likes": 17, "viewed": 479, "published": 3, "date": "1636158091", "time_retrieved": "2024-07-30T18:50:17.336124", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int y = int(fragCoord.y);\n    float s = fragCoord.x / iSampleRate;\n    vec2 a = music(0, s + iTime);\n    \n    ivec2 ay = ivec2((a*0.5+0.5)*iResolution.y + 0.5);\n    \n    fragColor = vec4(0.0);\n    if (y == ay.x) {\n        fragColor.rb = vec2(1.0);\n    }\n    if (y == ay.y) {\n        fragColor.g = 1.0;\n    }\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "vec2 mainSound( in int samp,float t) {\n    return music(samp, t);\n}", "sound_inputs": [], "common_code": "\nconst float pi = 3.14159265359;\nconst float pi2 = 6.283185307179586;\n\nfloat hz(float c) {\n    return 13.75 * pow(2.0, (c+3.0)/12.0);\n}\n\n// returns note index, fract\nvec2 seq(float t, float s) {    \n    return vec2(floor(t/s),mod(t, s));\n}\n\nfloat index(float a, float b, float x) {\n    return mix(a, b, step(1.0,x));\n}\n\nfloat index(float a, float b, float c, float x) {\n    return index(index(a, b, x),c,x-1.0);\n}\n\nfloat index(float a, float b, float c, float d, float x) {\n    return index(index(a, b, x),index(c, d,x-2.0),x-1.0);\n}\n\nfloat sqrosc(float p) {\n\treturn step(fract(p),0.5)*2.0-1.0;\n}\n\nfloat sinosc(float p) {\n    return sin(pi2*p);\n}\n\nfloat sawosc(float p) {\n    return 1.0 - 2.0*fract(p);\n}\n\nfloat triosc(float p) {\n    return 1.0 - abs(2.0 - 4.0 * fract(p + 0.25));\n}\n \n// normalizes arguments so the sum is 1\nvec4 normsum(vec4 p) {\n    return p / (p.x+p.y+p.z+p.w);\n}\n\n// v = vec4(attack,decay,hold,release), s = sustain amplitude\nfloat adsr(float t, vec4 v, float s) {\n    v.xyw = max(vec3(2.2e-05),v.xyw);\n    // attack term\n    float ta = t/v.x;\n    // decay / sustain amplitude term\n    float td = max(s, 1.0-(t-v.x)*(1.0-s)/v.y);\n    // length / release term\n    float tr = (1.0 - max(0.0,t-(v.x+v.y+v.z))/v.w);\n    return max(0.0, min(ta, tr*td));\n}\n\nfloat pops(float t) {\n    vec2 a = seq(t,1.0/4.0);\n    a.x = mod(a.x,3.0);\n    \n    vec3 r = vec3(0.0,-2.0,7.0);\n    \n    float q = index(r.x, r.y, r.z, a.x);\n    \n    vec2 w = seq(t,1.0/4.0);\n    float n = 30.0+24.0+q+12.0*mod(floor(w.x*0.5),2.0);\n    \n    float vib_f = hz(0.3*sinosc(4.0*t));\n    \n    return triosc(hz(n)*t + vib_f)\n        * adsr(w.y,vec4(0.01,0.1,0.0,0.2),0.3) * 0.5;\n}\n\nfloat lead(float t) {\n    vec2 a = seq(t,2.0);\n    a.x = mod(a.x,4.0);\n    \n    vec4 r = vec4(0.0,2.0,3.0,0.0);\n    \n    float q = index(r.x, r.y, r.z, r.w, a.x);\n    \n    vec2 w = seq(t,2.0);\n    float n = 30.0+24.0+q;\n    \n    float amp = adsr(w.y,vec4(1.0,0.0,0.0,1.0),1.0);\n    float vib_f = hz(amp*0.5*sinosc(5.0*t));\n    \n    return sinosc(hz(n)*t + vib_f)\n        * amp;\n}\n\n// returns note, amp\nfloat bassline(float t) {\n    vec2 a = seq(t,2.0);\n    a.x = mod(a.x,4.0);\n    \n    vec4 r = vec4(0.0,-2.0,-7.0,3.0);\n    \n    float q = index(r.x, r.y, r.z, r.w, a.x);\n    \n    vec2 w = seq(t,1.0/4.0);\n    float n = 30.0+q+12.0*mod(floor(w.x*0.5),2.0);\n    \n    return triosc(hz(n)*t)\n        * adsr(w.y,vec4(0.001,0.0,0.0,0.2),1.0);\n}\n\nvec2 granular_src(float t) {\n    vec2 q = seq(t,8.0);\n    q.x = mod(q.x,7.0);\n    \n    vec2 s = vec2(bassline(t));\n    \n    s += lead(t)*vec2(0.75,0.25)*step(1.0,q.x);\n    \n    // 4-tap delay\n    float delay = 0.256;\n    float d_f = 0.75;\n    float d_t = t - 24.0;\n    float p_amp = step(3.0,q.x);\n    s += pops(d_t)*p_amp;\n    s += vec2(0.0,1.0)*pops(max(0.0,d_t-delay))*d_f*p_amp;\n    s += vec2(1.0,0.0)*pops(max(0.0,d_t-2.0*delay))*d_f*d_f*p_amp;\n    s += vec2(0.0,1.0)*pops(max(0.0,d_t-3.0*delay))*d_f*d_f*d_f*p_amp;\n    s += vec2(1.0,0.0)*pops(max(0.0,d_t-4.0*delay))*d_f*d_f*d_f*d_f*p_amp;\n    \n    return vec2( s/3.0 );\n}\n\nvec2 granular(float t) {\n    vec2 o = vec2(0.0);\n    const int N = 2;\n    for (int i = 0; i < N; ++i) {\n        float rcpN = 1.0/float(N);\n        float n = float(i);\n        float hz = 20.0;\n        // cosines form a partition of unity\n        float amp = (cos(max(0.0,t*hz-n*rcpN)*2.0*pi+pi)*0.5+0.5)*2.0*rcpN;\n        float gtime = (floor(t*hz-n*rcpN)+n*rcpN)/hz;\n        float ltime = t - gtime;\n        float slodown = exp2(-t*0.01);\n        float pitchup = exp2(-t*0.005);\n        // slow music down while pitching sound up\n        o += granular_src(gtime*slodown + ltime/pitchup)*amp;\n    }\n    return o;\n}\n\n\nvec2 music( in int samp,float t) {\n    return granular(t);\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdGWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 371]], "test": "untested"}
{"id": "ftt3WN", "name": "Eyee", "author": "prishainabox", "description": "eye\nLike the Shadertoy logo, but not really!", "tags": ["eye"], "likes": 8, "viewed": 207, "published": 3, "date": "1636154267", "time_retrieved": "2024-07-30T18:50:18.101078", "image_code": "float random(in vec2 v) {\n    return fract(15465.1327854 * sin(dot(v, vec2(173.93422, 102.5165))));\n}\n\nfloat noise(in vec2 uv) {\n    \n    vec2 fid = fract(uv); // fraction part of uv -> where in the grid\n    fid = fid * fid * (3.0 - 2.0 * fid);\n    vec2 id = floor(uv); // integer part of uvw -> which grid\n    \n    // corners of grid\n    float bl = random(id + vec2(0, 0));\n    float br = random(id + vec2(1, 0));\n    float tl = random(id + vec2(0, 1));\n    float tr = random(id + vec2(1, 1));\n    \n    // interpolate between corner\n    float b = mix(bl, br, fid.x);\n    float t = mix(tl, tr, fid.x);\n    return mix(b, t, fid.y);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // normalized pixel coordinates\n    vec2 res = iResolution.xy;\n    vec2 uv = (2.0*fragCoord - res) / min(res.x, res.y) * 1.2;\n    // for two eyes\n    \n    // distance between pt and origin\n    float d = length(uv);\n    vec3 outerEyeClr = vec3(0.05, 0.3, 0.8);\n    \n    // black background\n    vec3 clr = vec3(0.0);\n    // noise\n    clr += noise(uv * 3.0) * 0.1 * vec3(1.5, 0.1, 0.5);\n    clr += noise(uv * 3.0 + 1.0) * 0.2 * vec3(0.0, 0.1, 1.3);\n    clr += vec3(0.6, 0.06, 0.4) * 0.15 * sin(noise(uv) * uv.x * 10.0);\n    clr *= 0.5;\n    // blue/purple glow\n    clr = mix(vec3(0.3, 0.1, 0.4) * 0.8, clr, smoothstep(d, 0.58, 0.73));\n    clr = mix(outerEyeClr*5., clr, smoothstep(d, 0.64, 0.66));\n    \n    // stars\n    float n = random(uv * 0.2); // random num based on coordinate\n    if (n < 0.008) {\n        clr += 0.6 * noise(vec2(uv * 50.0 + iTime));\n    }\n    \n    if (d < 0.8) {\n        // angle between center and pt\n        float a = atan(uv.y, uv.x);\n        // outer circle\n        vec3 e = mix(vec3(0.35, 0.65, 0.14), outerEyeClr, smoothstep(0.3, 0.65, d));\n        e += vec3(0.3, 0.35, 0.15)*1.2*(smoothstep(2.4, 3.14, a) + smoothstep(3.14, 4.94, 3.14-a));\n        // noise\n        e += noise(14.5 * vec2(cos(a), sin(a))) * 0.18;\n        // vignette\n        e = mix(e, vec3(0.02, 0.02, 0.2) * 0.1, smoothstep(0.45, 0.9, d));\n        // center\n        e = mix(e, vec3(0.1, 0.1, 0.15) * 0.7, smoothstep(0.28, 0.23, d));\n        // shine\n        float l = distance(uv, vec2(0.27));\n        vec3 shineClr = vec3(0.8, 1.2, 0.7);\n        e += shineClr * smoothstep(0.7, 0.0, l) * 0.4;\n        e += shineClr * smoothstep(0.15, 0.0, l*0.5) * 0.3;\n        // mix eye clr into background\n        clr = mix(clr, e, smoothstep(0.74, 0.69, d));\n    }\n\n    fragColor = vec4(clr, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftt3WN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 101], [103, 103, 128, 128, 637], [639, 639, 696, 733, 2484]], "test": "untested"}
{"id": "fl33DN", "name": "Multiple Neighborhood CA (MNCA)", "author": "SlackermanzCA", "description": "Continuous Multiple Neighborhood Cellular Automata", "tags": ["2d", "simulation", "diffusion", "automata", "life", "chaos", "cellular", "conway", "gameoflife", "cellularautomata", "cellularautomata", "cgol"], "likes": 3, "viewed": 426, "published": 3, "date": "1636152273", "time_retrieved": "2024-07-30T18:50:19.158251", "image_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//  ﻿ - Website: https://slackermanz.com\n//  ﻿ - Github: https://github.com/Slackermanz\n//  ﻿ - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//  ﻿ - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//  ﻿ - Discord DM: Slackermanz#3405\n//  ﻿ - Reddit DM: https://old.reddit.com/user/slackermanz\n//  ﻿ - Twitter: https://twitter.com/slackermanz\n//  ﻿ - YouTube: https://www.youtube.com/c/slackermanz\n//  ﻿ - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//  ﻿ - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//  ﻿ - Reddit: https://old.reddit.com/r/cellular_automata\n//  ﻿ - Artificial Life: https://discord.gg/7qvBBVca7u\n//  ﻿ - Emergence: https://discord.com/invite/J3phjtD\n//  ﻿ - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = texelFetch( iChannel0, ivec2(gl_FragCoord[0], gl_FragCoord[1]), 0); }", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//  ﻿ - Website: https://slackermanz.com\n//  ﻿ - Github: https://github.com/Slackermanz\n//  ﻿ - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//  ﻿ - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//  ﻿ - Discord DM: Slackermanz#3405\n//  ﻿ - Reddit DM: https://old.reddit.com/user/slackermanz\n//  ﻿ - Twitter: https://twitter.com/slackermanz\n//  ﻿ - YouTube: https://www.youtube.com/c/slackermanz\n//  ﻿ - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//  ﻿ - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//  ﻿ - Reddit: https://old.reddit.com/r/cellular_automata\n//  ﻿ - Artificial Life: https://discord.gg/7qvBBVca7u\n//  ﻿ - Emergence: https://discord.com/invite/J3phjtD\n//  ﻿ - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n#define txdata (iChannel0)\n#define PI 3.14159265359\n#define LN 2.71828182846\n\nconst uint MAX_RADIUS = 12u;\n\nuint[64] ub =  uint[64]\n(   2839374232u, 0u, 1190592433u, 120280933u, \n    1201467016u, 2983406577u, 2297663992u, 1569390293u, \n    3397953984u, 1373611332u, 1618794663u, 2895989683u, \n    3930721692u, 1194469218u, 3471826459u, 2539298369u, \n    898988449u, 834832879u, 2351275768u, 2491209886u, \n    4226066187u, 2922813275u, 3190474889u, 3664004364u, \n    3133186130u, 2598110722u, 3222427546u, 595394072u, \n    0u, 2532027177u, 2332938883u, 2284688949u, \n    3736139869u, 606451005u, 2938049042u, 3274101706u, \n    157067970u, 1270063803u, 416605332u, 313708814u, \n    1997778351u, 2602811305u, 2401004755u, 2462067509u, \n    916236747u, 1813810308u, 1142529981u, 713743344u, \n    0u, 0u, 0u, 0u, \n    0u, 0u, 0u, 0u, \n    0u, 0u, 0u, 0u, \n    0u, 1073928355u, 1116964338u, 0u );\n\nuint u32_upk(uint u32, uint bts, uint off) { return (u32 >> off) & ((1u << bts)-1u); }\n\nfloat lmap() { return (gl_FragCoord[0] / float(textureSize(txdata,0)[0])); }\nfloat vmap() { return (gl_FragCoord[1] / float(textureSize(txdata,0)[1])); }\nfloat cmap() { return sqrt\t( ((gl_FragCoord[0] - float(textureSize(txdata,0)[0])*0.5) / float(textureSize(txdata,0)[0])*0.5)\n\t\t\t\t\t\t\t* ((gl_FragCoord[0] - float(textureSize(txdata,0)[0])*0.5) / float(textureSize(txdata,0)[0])*0.5)\n\t\t\t\t\t\t\t+ ((gl_FragCoord[1] - float(textureSize(txdata,0)[1])*0.5) / float(textureSize(txdata,0)[1])*0.5)\n\t\t\t\t\t\t\t* ((gl_FragCoord[1] - float(textureSize(txdata,0)[1])*0.5) / float(textureSize(txdata,0)[1])*0.5) ); }\nfloat vwm() {\n\tfloat \tscale_raw \t= uintBitsToFloat(ub[62]);\n\tfloat \tzoom \t\t= uintBitsToFloat(ub[61]);\n\tfloat\tscale_new\t= scale_raw;\n\tuint \tmode \t\t= u32_upk(ub[59], 2u, 0u);\n\tif( mode == 1u ) { //\tLinear Parameter Map\n\t\tscale_new = ((lmap() + zoom) * (scale_raw / (1.0 + zoom * 2.0))) * 2.0; }\n\tif( mode == 2u ) { //\tCircular Parameter Map\n\t\tscale_new = ((sqrt(cmap()) + zoom) * (scale_raw / (1.0 + zoom * 2.0))) * 2.0; }\n\treturn scale_new; }\n    \nfloat  tp(uint n, float s) \t\t\t{ return (float(n+1u)/256.0) * ((s*0.5)/128.0); }\nfloat utp(uint v, uint  w, uint o) \t{ return tp(u32_upk(v,w,w*o), vwm()); }\nfloat bsn(uint v, uint  o) \t\t\t{ return float(u32_upk(v,1u,o)*2u)-1.0; }\n    \nvec4  sigm(vec4  x, float w) { return 1.0 / ( 1.0 + exp( (-w*2.0 * x * (PI/2.0)) + w * (PI/2.0) ) ); }\nfloat hmp2(float x, float w) { return 3.0*((x-0.5)*(x-0.5))+0.25; }\n\nvec4  gdv( ivec2 of, sampler2D tx ) {\n\tof \t\t= ivec2(gl_FragCoord) + of;\n\tof[0] \t= (of[0] + textureSize(tx,0)[0]) % (textureSize(tx,0)[0]);\n\tof[1] \t= (of[1] + textureSize(tx,0)[1]) % (textureSize(tx,0)[1]);\n\treturn \ttexelFetch( tx, of, 0); }\n    \nvec4 nbhd( vec2 r, sampler2D tx ) {\n//\tPrecision limit of signed float32 for [n] neighbors in a 16 bit texture (symmetry preservation)\n\tuint\tchk = 2147483648u /\n\t\t\t(\t( \tuint( r[0]*r[0]*PI + r[0]*PI + PI\t)\n\t\t\t\t- \tuint( r[1]*r[1]*PI + r[1]*PI\t\t) ) * 128u );\n\tfloat\tpsn = (chk >= 65536u) ? 65536.0 : float(chk);\n\tvec4\ta = vec4(0.0,0.0,0.0,0.0);\n\tfloat\tw = 1.0;\t// Weighting, unused\n\tif(r[0] == 0.0) { return vec4( gdv( ivec2(0,0), tx )*w*psn ); }\n\telse \t\t\t{\n\t\tfor(float i = 0.0; i <= r[0]; i++) {\n\t\t\tfor(float j = 1.0; j <= r[0]; j++) {\n\t\t\t\tfloat\td = round(sqrt(i*i+j*j));\n\t\t\t\t\t\tw = 1.0;\t//\tPer-Neighbor Weighting, unused\n\t\t\t\tif( d <= r[0] && d > r[1] ) {\n\t\t\t\t\tvec4 t0  = gdv( ivec2( i, j), tx ) * w * psn; a += t0 - fract(t0);\n\t\t\t\t\tvec4 t1  = gdv( ivec2( j,-i), tx ) * w * psn; a += t1 - fract(t1);\n\t\t\t\t\tvec4 t2  = gdv( ivec2(-i,-j), tx ) * w * psn; a += t2 - fract(t2);\n\t\t\t\t\tvec4 t3  = gdv( ivec2(-j, i), tx ) * w * psn; a += t3 - fract(t3); } } }\n\t\treturn a; } }\n\nvec4 totl( vec2 r, sampler2D tx ) {\n//\tPrecision limit of signed float32 for [n] neighbors in a 16 bit texture (symmetry preservation)\n\tuint\tchk = 2147483648u /\n\t\t\t(\t( \tuint( r[0]*r[0]*PI + r[0]*PI + PI\t)\n\t\t\t\t- \tuint( r[1]*r[1]*PI + r[1]*PI\t\t) ) * 128u );\n\tfloat\tpsn = (chk >= 65536u) ? 65536.0 : float(chk);\n\tvec4\tb = vec4(0.0,0.0,0.0,0.0);\n\tfloat\tw = 1.0;\t// Weighting, unused\n\tif(r[0] == 0.0) { return vec4( psn * w, psn * w, psn * w, psn * w ); }\n\telse \t\t\t{\n\t\tfor(float i = 0.0; i <= r[0]; i++) {\n\t\t\tfor(float j = 1.0; j <= r[0]; j++) {\n\t\t\t\tfloat\td = round(sqrt(i*i+j*j));\n\t\t\t\t\t\tw = 1.0;\t//\tPer-Neighbor Weighting, unused\n\t\t\t\tif( d <= r[0] && d > r[1] ) { b += psn * w * 4.0; } } }\n\t\treturn b; } }\n\nvec4 bitring(vec4[MAX_RADIUS] rings_a, vec4[MAX_RADIUS] rings_b, uint bits, uint of) {\n\tvec4 sum = vec4(0.0,0.0,0.0,0.0);\n\tvec4 tot = vec4(0.0,0.0,0.0,0.0);\n\tfor(uint i = 0u; i < MAX_RADIUS; i++) {\n\t\tif(u32_upk(bits, 1u, i+of) == 1u) { sum += rings_a[i]; tot += rings_b[i]; } }\n\treturn sigm( (sum / tot), LN ); } // TODO\n    \nvec4 conv(vec2 r, sampler2D tx) {\n\tvec4 nha = nbhd(r, tx);\n\tvec4 nhb = totl(r, tx);\n\treturn \tnha / nhb; }\n    \n//\tUsed to reseed the surface with lumpy noise\nfloat get_xc(float x, float y, float xmod) {\n\tfloat sq = sqrt(mod(x*y+y, xmod)) / sqrt(xmod);\n\tfloat xc = mod((x*x)+(y*y), xmod) / xmod;\n\treturn clamp((sq+xc)*0.5, 0.0, 1.0); }\nfloat shuffle(float x, float y, float xmod, float val) {\n\tval = val * mod( x*y + x, xmod );\n\treturn (val-floor(val)); }\nfloat get_xcn(float x, float y, float xm0, float xm1, float ox, float oy) {\n\tfloat  xc = get_xc(x+ox, y+oy, xm0);\n\treturn shuffle(x+ox, y+oy, xm1, xc); }\nfloat get_lump(float x, float y, float nhsz, float xm0, float xm1) {\n\tfloat \tnhsz_c \t= 0.0;\n\tfloat \txcn \t= 0.0;\n\tfloat \tnh_val \t= 0.0;\n\tfor(float i = -nhsz; i <= nhsz; i += 1.0) {\n\t\tfor(float j = -nhsz; j <= nhsz; j += 1.0) {\n\t\t\tnh_val = round(sqrt(i*i+j*j));\n\t\t\tif(nh_val <= nhsz) {\n\t\t\t\txcn = xcn + get_xcn(x, y, xm0, xm1, i, j);\n\t\t\t\tnhsz_c = nhsz_c + 1.0; } } }\n\tfloat \txcnf \t= ( xcn / nhsz_c );\n\tfloat \txcaf\t= xcnf;\n\tfor(float i = 0.0; i <= nhsz; i += 1.0) {\n\t\t\txcaf \t= clamp((xcnf*xcaf + xcnf*xcaf) * (xcnf+xcnf), 0.0, 1.0); }\n\treturn xcaf; }\nfloat reseed(uint seed, float scl, float amp) {\n\tfloat \tfx = gl_FragCoord[0];\n\tfloat \tfy = gl_FragCoord[1];\n\tfloat \tr0 = get_lump(fx, fy, round( 6.0  * scl), 19.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),17.0), 23.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),43.0));\n\tfloat \tr1 = get_lump(fx, fy, round( 22.0 * scl), 13.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),29.0), 17.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),31.0));\n\tfloat \tr2 = get_lump(fx, fy, round( 14.0 * scl), 13.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),11.0), 51.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),37.0));\n\tfloat \tr3 = get_lump(fx, fy, round( 18.0 * scl), 29.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed), 7.0), 61.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),28.0));\n\treturn clamp( sqrt((r0+r1)*r3*(amp+1.2))-r2*(amp*1.8+0.2) , 0.0, 1.0); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tRule Initilisation\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tNH Rings\n\tvec4[MAX_RADIUS] nh_rings_c_a;\n\tvec4[MAX_RADIUS] nh_rings_c_b;\n\tfor(uint i = 0u; i < MAX_RADIUS; i++) {\n\t\tnh_rings_c_a[i] = nbhd( vec2(i+1u,i), txdata );\n\t\tnh_rings_c_b[i] = totl( vec2(i+1u,i), txdata ); }\n\n//\tParameters\n\tconst\tfloat \tmnp \t= 1.0 / 65536.0;\t\t\t//\tMinimum value of a precise step for 16-bit channel\n\tconst\tfloat \ts  \t\t= mnp *  48.0 *  64.0;\n\tconst\tfloat \tn  \t\t= mnp *  48.0 *   2.0;\n\n//\tOutput Values\n\tvec4 res_c = gdv( ivec2(0, 0), txdata );\n\n//\tResult Values\n\tvec4 res_v = res_c;\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tUpdate Functions\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n    uint[12] nb = uint[12] (\n\t\tub[0],  ub[1],  ub [2],  ub[3],\n\t\tub[4],  ub[5],  ub [6],  ub[7],\n\t\tub[8],  ub[9],  ub[10], ub[11] );\n\n\tuint[24] ur = uint[24] (\n\t\tub[12], ub[13], ub[14], ub[15], \n\t\tub[16], ub[17], ub[18], ub[19],\t\n\t\tub[20], ub[21], ub[22], ub[23],\n\t\tub[24], ub[25], ub[26], ub[27],\t\n\t\tub[28], ub[29], ub[30], ub[31], \n\t\tub[32], ub[33], ub[34], ub[35]  );\n\n\tuint[ 3] ch2 = uint[ 3] ( 2286157824u, 295261525u, 1713547946u );\n\tuint[ 3] ch  = uint[ 3] ( ub[38], ub[39], ub[40] );\n\tuint[ 3] ch3 = uint[ 3] ( ub[41], ub[42], ub[43] );\n\n//\tUpdate Sign\n\tuint[ 2] us = uint[ 2] ( ub[36], ub[37] );\n\n\tfor(uint i = 0u; i < 24u; i++) {\n\t\tuint  \tcho = u32_upk( ch[i/8u], 2u, (i*4u+0u) & 31u );\n\t\t\t\tcho = (cho == 3u) ? u32_upk( ch2[i/8u], 2u, (i*4u+0u) & 31u ) : cho;\n\t\tuint  \tchi = u32_upk( ch[i/8u], 2u, (i*4u+2u) & 31u );\n\t\t\t\tchi = (chi == 3u) ? u32_upk( ch2[i/8u], 2u, (i*4u+2u) & 31u ) : chi;\n\t\tuint  \tchm = u32_upk( ch3[i/8u], 2u, (i*4u+2u) & 31u );\n\t\t\t\tchm = (chm == 3u) ? u32_upk( ch[i/8u], 2u, (i*4u+2u) & 31u ) : chm;\n\n\t\tfloat nhv = bitring( nh_rings_c_a, nh_rings_c_b, nb[i/2u], (i & 1u) * 16u )[cho];\n\n\t\tif( nhv >= utp( ur[i], 8u, 0u) && nhv <= utp( ur[i], 8u, 1u)) {\n\t\t\tfloat h = hmp2(res_c[chm],1.2);\n\t\t\tres_v[chi] += bsn(us[i/16u], ((i*2u+0u) & 31u)) * s * h; }\n\t\tif( nhv >= utp( ur[i], 8u, 2u) && nhv <= utp( ur[i], 8u, 3u)) {\n\t\t\tfloat h = hmp2(res_c[chm],1.2);\n\t\t\tres_v[chi] += bsn(us[i/16u], ((i*2u+1u) & 31u)) * s * h; } }\n\n\tvec4 n4 = sigm(res_v, 0.5) * n * 64.0 + n;\n\tres_c = res_v - n4;\n//\tres_c = conv(vec2(1.0,0.0),txdata);\n    \n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tShader Output\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n\n    if (iMouse.z > 0. && length(iMouse.xy - fragCoord) < 14.0) {\n        res_c[0] = round(mod(float(iFrame),2.0));\n        res_c[1] = round(mod(float(iFrame),3.0));\n        res_c[2] = round(mod(float(iFrame),5.0)); }\n    if (iFrame == 0) { res_c[0] = reseed(0u, 1.0, 0.4); res_c[1] = reseed(1u, 1.0, 0.4); res_c[2] = reseed(2u, 1.0, 0.4); }\n\n//\tForce alpha to 1.0\n\tres_c[3] \t= 1.0;\n    fragColor=clamp(res_c,0.0,1.0);\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl33DN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[998, 998, 1055, 1055, 1141]], "test": "untested"}
{"id": "stt3D4", "name": "Modified Mandala", "author": "taellinglin", "description": "Modified from another shader slightly. I am also trying to make it render the black pixels as transparent.", "tags": ["modified"], "likes": 9, "viewed": 329, "published": 3, "date": "1636142377", "time_retrieved": "2024-07-30T18:50:19.987035", "image_code": "#define PI 3.141592\n#define TAU 2.0*PI\n\n\nvoid amod(inout vec2 p, float c) {\n    float m = TAU / c;\n    float a = mod(atan(p.x, p.y)-m*.5, m) - m*.5;\n    p = vec2(cos(a), sin(a)) * length(p);\n}\n\nvoid mo(inout vec2 p, vec2 d) {\n    p = abs(p) - d;\n    if(p.y>p.x)p=p.yx;\n}\n\nmat2 r2d(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat smooth_stairs(float x) {\n    return tanh(5.*(x-floor(x)-0.5))/tanh(2.5)*0.5+floor(x)+0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n    //vec2 mouse = iMouse.xy / iResolution.xy;\n    uv.y = abs(uv.y);\n    \n    uv *= 3.0;\n    //amod(uv, 5.5+sin(iTime*0.2)*2.5);\n    float nrays = abs(mod(iTime*0.3, 10.)-5.);\n    amod(uv, 8.-smooth_stairs(nrays));\n    \n    mo(uv, vec2(1.2+sin(iTime*0.3), 0.6+sin(iTime*0.5)*0.3));\n    uv *= r2d(PI/12.-PI/8.*mod(iTime*0.2, 16.));\n    mo(uv, vec2(1.1+sin(iTime*0.5)*0.7, 0.4+0.5*1.5));\n    uv *= r2d(PI/6.-mod(iTime*0.25, 12.0)*PI/6.0);\n    mo(uv, vec2(.7+sin(iTime*0.45)*0.2, .2));\n    \n    //uv *= 10.;\n    uv *= 30.;\n    //float l = min(abs(uv.x), abs(uv.y));\n    //float l = max(abs(uv.x), abs(uv.y));\n    float l = abs(uv.x) + abs(uv.y);\n    float d = sin(l) - .3;\n    \n    d = smoothstep(0., fwidth(d), d);\n    fragColor = vec4(sqrt(d),sqrt(d),sqrt(d),0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stt3D4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 75, 75, 192], [194, 194, 225, 225, 270], [272, 272, 291, 291, 357], [359, 359, 389, 389, 456], [458, 458, 515, 515, 1344]], "test": "untested"}
{"id": "7tdGW4", "name": "Idk what I did but it looks cool", "author": "gingerphoenix10", "description": "I switched 0.5 to 10.5", "tags": ["unexpected"], "likes": 0, "viewed": 182, "published": 3, "date": "1636135055", "time_retrieved": "2024-07-30T18:50:20.794875", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 10.5 + 10.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tdGW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 296]], "test": "untested"}
{"id": "flcGWr", "name": "Fork Waterfall  guil 266", "author": "guil", "description": "Click mouse to add a circular obstacle.\nTry different values for parameters in Common.\n\nI tried still another advection scheme by searching in the neighborhood for the region wich will fall on the current point.", "tags": ["fluid", "waterfall"], "likes": 14, "viewed": 412, "published": 3, "date": "1636134826", "time_retrieved": "2024-07-30T18:50:21.573793", "image_code": "#define R iResolution.xy\n#define T1(U) texture(iChannel0,U/R)\n\nvoid mainImage( out vec4 C, in vec2 U )\n{   \n\n    float m = 2.*T1(U).w;//masse\n    float v = length(T1(U).xy)/10.;//velocity\n    float p = T1(U).z/10.;//pressure\n    \n    C = m*vec4(1,1.2,2,1)+log(1.+.5*v);\n    \n    if (U.x < 0.2*R.x&&U.y < 0.5*R.y) C = vec4(0.5);\n    if (U.x < 0.4*R.x&&U.y < 0.3*R.y) C = vec4(0.5);\n    \n}  ", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvoid mainImage( out vec4 Q, in vec2 U )\n{      \n    R = iResolution.xy; t = iTime; Mouse = iMouse; Frame = iFrame;\n    pass( Q, iChannel0, U );\n    \n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define dt .1\n#define g 4.\n#define k 7.\n#define l 0.\n#define s .12\n#define nu 0.1\n#define mu 0.1\n#define kappa .0\n#define h 6.0\n\nvec2 R;\nvec4 Mouse;\nfloat t;\nint Frame;\n\n#define T(p) texture(ch,(p)/R)\n\nvoid pass( out vec4 Q, in sampler2D ch, in vec2 U )\n{   \n    \n    vec4 a = T(U+vec2(1,0)),b = T(U+vec2(0,1)),c = T(U+vec2(-1,0)),d = T(U+vec2(0,-1)),e=.25*(a+b+c+d), dx=a-c, dy=b-d;\n    \n    \n    \n    vec2 vu = vec2(0.);//advection vector estimate\n    float n = 0.;\n    for(float i=-h;i<=h;i++)for(float j=-h;j<=h;j++){\n        vec2 vv = U+vec2(i,j)*.25;\n        vec2 dp = abs(vv+dt*T(vv).xy-U);\n        if(dp.x<.25&&dp.y<.25)vu+=T(vv).xy,n++;\n    }\n    //if(n>1.)vu=T(U).xy;//?\n    Q = T(U-dt*vu);//advection\n \tvec2 gp = vec2(dx.z,dy.z);//pressure gradient\n    vec2 gw = vec2(dx.w,dy.w);//density gradient\n    float div = (dx.x+dy.y);//divergence\n    vec2 vdv = vec2(Q.x*dx.x+Q.y*dy.x,Q.x*dx.y+Q.y*dy.y); \n    \n    \n    Q.xy -= dt *(k*gp + Q.w*l*gw + Q.w*vec2(0.,g)+ s*vdv*Q.w);//forces\n    Q.z = e.z - dt*0.29*(div*Q.z+dot(gw,Q.xy));//pressure\n    Q -= dt * vec4(nu,nu,mu,kappa) * 4.*(Q-e);//diffusion\n    \n    //Boundaries\n    if (Frame < 1) Q = vec4(0,0,0.5,0);\n    if (U.x < 1.||U.y < 1.) Q.xy *= 0.;\n    if (R.x-U.x < 10.) Q.w *= (R.x-U.x)*.1, Q.z*=(R.x-U.x)*.1;\n    if (R.y-U.y < 10.) Q.w *= (R.y-U.y)*.1, Q.z*=(R.y-U.y)*.1;\n    if (U.x < 0.2*R.x&&U.y < 0.5*R.y) Q.xy *= 0.;\n    if (U.x < 0.4*R.x&&U.y < 0.3*R.y) Q.xy *= 0.;\n \tif (length(U-vec2(0,0.9*R.y)) < 8.) {Q.xy= Q.xy*.5+.5*vec2(1.+0.4*sin(1.5*t),0); Q.w = 1.;};\n    \n    //click mouse to add a circular obstacle\n    if(length(Mouse.xy - U) < 20. && Mouse.z > 0.5){\n        Q.xyw = vec3(0.);\n    }\n\n\n    Q = clamp(Q, vec4(-15,-15,0,0), vec4(15,15,8,15));\n}", "buffer_b_code": "\nvoid mainImage( out vec4 Q, in vec2 U )\n{      \n    R = iResolution.xy; t = iTime; Mouse = iMouse; Frame = iFrame;\n    pass( Q, iChannel0, U );\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flcGWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 104, 104, 387]], "test": "untested"}
{"id": "st33DN", "name": "Simple tunnel11111", "author": "lllcz", "description": "Simple tunnel", "tags": ["asa"], "likes": 4, "viewed": 268, "published": 3, "date": "1636125780", "time_retrieved": "2024-07-30T18:50:22.345729", "image_code": "#define PI 3.1415926535\nfloat ex = 0.003 ;\n\n//噪声纹理采样\nfloat noise(vec2 uv){\n    return texture(iChannel0, uv).r;//采样uv坐标随时间周期改变\n}\n\nfloat stars(vec2 uv){\n    return noise(uv);\n}\n//判断具体位置\nvec2 polar(vec2 uvc){\n    float r = sqrt(dot(uvc, uvc));//半径\n    float th = atan(uvc.y, uvc.x);//弧度\n    return vec2(r, th);   \n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n   vec2 R = iResolution.xy;\n    U -= .5*R;\n    O = texture(iChannel0, vec2(length(U/R)+iTime, atan(U.y,U.x) ) ).xxxx;\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st33DN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 65, 86, 86, 162], [164, 164, 185, 185, 209], [210, 231, 252, 252, 367], [369, 369, 410, 410, 530]], "test": "untested"}
{"id": "sl33D4", "name": "Pixel Spiral Test", "author": "SnoopethDuckDuck", "description": "e", "tags": ["ee"], "likes": 0, "viewed": 247, "published": 3, "date": "1636122677", "time_retrieved": "2024-07-30T18:50:23.112678", "image_code": "float thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float c = 5. + 1. * thc(2., 0.8 * iTime);\n    float l = mix(4. * length(uv) * length(uv), 1. / (1. + length(uv)), .5 + .5 * thc(3., iTime));\n    uv = vec2(ths(3., c * uv.x * l), ths(3., c * uv.y * l));\n    \n    float sc = 64.;\n    vec2 fpos = fract(sc * uv) - 0.5;\n    vec2 ipos = floor(sc * uv) + 0.5;\n    \n    float a = atan(ipos.y, ipos.x);\n    float r = log(cos(10. * length(ipos)/sc + 4. * iTime) + thc(3.,30. * length(ipos)/sc + 2. * a + iTime));//log(length(ipos));\n   \n    vec2 v = r * vec2(cos(a), sin(a));\n    \n    float d = length(v);\n    d = clamp(d, 0., 1.);\n    float s = step(d,0.74 -.25 * thc(4., iTime));\n    \n    vec3 col = vec3(s);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl33D4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 70], [72, 72, 101, 101, 142], [145, 145, 202, 252, 1031]], "test": "untested"}
{"id": "Nt3GWN", "name": "Circular Equalizer - Blue & Red", "author": "Meji", "description": "Equalizer", "tags": ["music"], "likes": 1, "viewed": 322, "published": 3, "date": "1636111114", "time_retrieved": "2024-07-30T18:50:23.895585", "image_code": "#define PI 3.14159265\n\nfloat rewrap(float r, float rep) {\n    \n    if (r < PI) {\n        r = -r;\n    }\n    \n    r = mod(r*rep, PI);\n                  \n    return r/(PI);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 px = gl_FragCoord.xy / iResolution.xy;\n    \n    const int size = 24;\n                \n    float ar = iResolution.x / iResolution.y;\n    \n    px.y /= ar;\n    \n    vec2 pos = px-vec2(0.5, 0.5/ar);\n    \n    float len = length(pos);\n    \n\tvec3 color = vec3(0,0,0);\n    \n    float rep = 1.;\n    \n    float delta = rewrap(atan(pos.x, pos.y), rep);\n        \n    float div = 500./float(size);\n    \n    float modifier = sin(iTime*0.15);\n    \n    float index = float(int(mod(iTime*0.+delta+modifier, 3.0) * 100. / div));\n    \n\tfloat f = texelFetch(iChannel0, ivec2(index/float(size)*256.,0.1), 0).x;\n    \n    float base = texelFetch(iChannel0, ivec2(1.*256.,0.1), 0).x;\n    \n    float cpi = smoothstep((0.1 + base*0.05), 0.15 + f * 0.01, len);\n       \n\tif (len < 0.13 + f * 0.13 && len > (0.1 + base*0.001) && mod(delta + modifier, 1./float(size)) < 0.038 && (delta) > 0.0)\n\t\tcolor = vec3(0.95-delta, delta*0.1, delta);\n    \n    color *= cpi;\n    \n    if (len < 0.1 + base * 0.06 && len > 0.09 + base * 0.03)\n      color = vec3(1,1,1);\n    \n    float eq = texelFetch(iChannel0, ivec2(px.x*128.,1), 0).x;\n        \n    if (abs(px.y*ar-0.54+eq*0.1) < 0.01 && \n        px.x > 0.5-(0.1+base * 0.05-1.08) &&\n        px.x < 0.5+(0.1+base * 0.05-0.02)) {\n        color = vec3(1);\n    }\n    \n\tfragColor = vec4(color, 0.1);\n}", "image_inputs": [{"id": 20, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt3GWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 57, 57, 171], [173, 173, 230, 230, 1545]], "test": "untested"}
{"id": "sl3GWr", "name": "Ray-tracing with refraction", "author": "busybeaver", "description": "Ray-tracing with refraction and reflection. The only things that are not taken into account are polarization and decomposition of light into spectrum.", "tags": ["raytracing", "raycasting"], "likes": 24, "viewed": 698, "published": 3, "date": "1636108639", "time_retrieved": "2024-07-30T18:50:24.669516", "image_code": "float gamma = 2.2; // For gamma correction.\nfloat exposure = 1.3;\nfloat tone_pow = 0.35; // Represents how strong the tone mapping is.\n\nvec3 correct_color(vec3 c) {\n    c *= exposure;\n    c = pow(c, vec3(1. / tone_pow));\n    c = pow(c / (c + 1.), vec3(tone_pow));\n    c = pow(c, vec3(1. / gamma));\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(correct_color(texture(iChannel0, fragCoord.xy/iResolution.xy).rgb), 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Refraction here is almoust the same as in real world.\n// The only things that are not taken into account is polarization and decomposition of light into spectrum.\n\nvec4 s1 = vec4(1.5, 1.1, 0., 1.1); // ball at right side\nvec3 s1_col = vec3(.9, .9, .5); // color\n\nvec4 s2 = vec4(3.0, 5.0, 0.0, 1.0); // lamp\nvec3 lamp_col = vec3(15., 17., 15.); // color of the lamp\n\n// ball = vec3(x, y, z, radious)\nvec4 s3 = vec4(-2.0, 1.6, 1.3, 1.6); // big ball\nfloat s3_n = 2.4; // refractive index (1 - air, 1.33 - water, 1.5 - glass, 1.5-2 - optical glass, 2.4 - diamond)\nvec3 s3_col = vec3(.95, .6, .6); // color\n\nvec4 s4 = vec4(-0.6, 1.7, -1.6, 0.5); // small ball\nfloat s4_n = 2.4; // refractive index\nvec3 s4_col = vec3(.95, .95, .3); // color\n\nvec3 b1_c = vec3(-1.0, 0.601, -1.6); // senter of box\nvec3 b1_r = vec3(1.2, 0.6, 0.9); // size of box\nfloat b1_n = 1.5; // refractive index\nvec3 b1_col = vec3(.6, .6, .95); // color\n\nfloat pi = 3.1415926;\n\nint start_frame = 0; // The frame from which the rendering starts. Increase it to have time to turn on full-screen mode.\nint max_steps = 15;\nfloat min_d = 0.0002;\nfloat max_d = 10000.0;\nfloat w = 2.;\nfloat cam_dist = 10.0;\nfloat rotation_yz = .3;\nfloat rotation_yz_cam = 0.15;\nfloat rotation_xz = -.1;\n\nfloat seed;\n\nvec2 rotate(vec2 v, float a) {\n    vec2 x = vec2(cos(a), sin(a));\n    return v.x * x + v.y * vec2(-x.y, x.x);\n}\n\nfloat rand() {\n    seed = fract(seed + .500009);\n    return fract(sin(seed * 1000.) * seed * 100.);\n}\n\nvec3 rand_ray() {\n    float d = rand() * pi * 2.;\n    float h = rand() * 2. - 1.;\n    float a = sqrt(1. - h * h);\n    return vec3(sin(d) * a, h, cos(d) * a);\n}\n\nvec3 rand_rotate(vec3 v, float w, float conc) {\n    float d = rand() * pi * 2.;\n    float h = 1. - (1. - pow(rand(), conc)) * (1. - cos(w));\n    float a = sqrt(1. - h * h);\n    vec3 r = -vec3(sin(d) * a, cos(d) * a, h);\n    r = vec3(r.x, rotate(r.yz, atan(v.y, length(v.xz))));\n    r = vec3(rotate(r.xz, atan(v.z, v.x) + pi * .5), r.y).xzy;\n    return r * length(v);\n}\n\nvec4 max_dim(vec3 v) {\n    if(v.x > v.y && v.x > v.z) {\n        return vec4(1., 0., 0., v.x);\n    } else if (v.y > v.x && v.y > v.z) {\n        return vec4(0., 1., 0., v.y);\n    } else {\n        return vec4(0., 0., 1., v.z);\n    }\n}\n\nvec4 box(vec3 pos, vec3 ray, vec3 r, vec3 c) {\n    vec3 s = c - pos;\n    vec4 d1 = max_dim((s - r * sign(ray)) / ray);\n    vec4 d2 = max_dim(-(s + r * sign(ray)) / ray);\n    d2.w = -d2.w;\n    if(d2.w < d1.w) return vec4(0., 0., 0., max_d + max_d);\n    if(d1.w < min_d) {\n        if(d2.w < min_d) return vec4(0., 0., 0., max_d + max_d);\n        return vec4(d2.xyz * sign(ray), d2.w);\n    } else\n    return vec4(- d1.xyz * sign(ray), d1.w);\n}\n\nfloat sphere_dist(vec3 pos, vec3 ray, vec4 sphere) {\n    //return length(pos - sphere.xyz) - sphere.w;\n    vec3 s = sphere.xyz - pos;\n    float ds = dot(ray, s);\n    float D = ds * ds - dot(ray, ray) * (dot(s, s) - sphere.w * sphere.w);\n    if(D < 0.) return max_d + max_d;\n    float t1 = ds + sqrt(D);\n    float t2 = ds - sqrt(D);\n    if(t2 < min_d) {\n        if(t1 < min_d) return max_d + max_d;\n        return t1;\n    }\n    return t2;\n}\n\nfloat square(float x) { return x * x; }\n\nfloat reflect_k(float a, float b) {\n    return (square(tan(a - b) / tan(a + b)) + square(sin(a - b) / sin(a + b))) * .5;\n}\n\nvec3 refract2(vec3 pos, vec3 ray, vec3 norm, float n) {\n    float dt = dot(-norm, ray);\n    float n1 = (dt > 0.) ? n : 1. / n;\n    float a1 = sqrt(1. - dt * dt);\n    float a2 = a1 / n1;\n    if(a2 >= 1.) {\n        ray -= dot(ray, norm) * norm * 2.;\n    } else {\n        if(reflect_k(asin(a1), asin(a2)) > rand()) ray -= dot(ray, norm) * norm * 2.;\n        else {\n            ray = normalize(-norm * sqrt(1. - a2 * a2) * sign(dt) + normalize(ray - dot(ray, norm) * norm) * a2);\n            \n        }\n    }\n    return ray;\n}\n\nvec3 march(vec3 pos, vec3 ray) {\n    vec3 color = vec3(1., 1., 1.);\n    for(int i = 0; i < max_steps; i ++) {\n        float d_s1 = sphere_dist(pos, ray, s1);\n        float d_s2 = sphere_dist(pos, ray, s2);\n        float d_s3 = sphere_dist(pos, ray, s3);\n        float d_s4 = sphere_dist(pos, ray, s4);\n        vec4 d_b1 = box(pos, ray, b1_r, b1_c);\n        float d_floor = (ray.y < 0.) ? - pos.y / ray.y : max_d + max_d;\n        float d_wall;\n        float d_wall2 = (ray.z > 0.) ? (7. - pos.z) / ray.z : max_d + max_d;\n        vec3 wall_c;\n        if(ray.x > 0.) {\n            wall_c = vec3(.05, .2, .35);\n            d_wall = (4.5 - pos.x) / ray.x;\n        } else {\n            wall_c = vec3(.35, .05, .05);\n            d_wall = - (5.3 + pos.x) / ray.x;\n        }\n        float d = min(min(min(min(min(min(min(d_s1, d_floor), d_s2), d_s3), d_s4), d_wall), d_wall2), d_b1.w);\n        //if(d_b1.w < max_d) return d_b1.xyz * .5 + .5;\n        if(d > max_d) return vec3(0., 0., 0.);//color * vec3(0.2, 0.2, 0.2);\n        pos += ray * d;\n        if(d_floor == d) {\n            ray = rand_ray();\n            ray.y = abs(ray.y);\n            color *= vec3(.9, .8, .8);\n        } else if(d_s2 == d) {\n            return lamp_col * color;\n        } else if(d_s3 == d) {\n            vec3 norm = normalize(pos - s3.xyz);\n            if(dot(norm, ray) > 0.) color *= pow(s3_col, vec3(d));\n            ray = refract2(pos, ray, norm, s3_n);\n        } else if(d_s4 == d) {\n            vec3 norm = normalize(pos - s4.xyz);\n            if(dot(norm, ray) > 0.) color *= pow(s4_col, vec3(d));\n            ray = refract2(pos, ray, norm, s4_n);\n        } else if(d_wall == d) {\n            color *= wall_c;\n            ray = rand_ray();\n            ray.x = - abs(ray.x) * sign(pos.x);\n        } else if(d_wall2 == d) {\n            color *= vec3(.2, .4, .1);\n            ray = rand_ray();\n            ray.z = - abs(ray.z);\n        } else if(d_b1.w == d) {\n            if(dot(d_b1.xyz, ray) > 0.) color *= pow(b1_col, vec3(d));\n            ray = refract2(pos, ray, d_b1.xyz, b1_n);\n        } else {\n            vec3 prev_ray = ray;\n            ray = rand_rotate(ray, .8, .7);\n            vec3 s = normalize(s1.xyz - pos);\n            if(dot(s, ray) < 0.) ray = rand_rotate(prev_ray, .8, .7);\n            if(dot(s, ray) < 0.) ray = rand_rotate(prev_ray, .8, .7);\n            if(dot(s, ray) < 0.) return vec3(0., 0., 0.);\n            ray -= dot(s, ray) * 2. * s;\n            color *= s1_col;\n        }\n    }\n    return vec3(0., 0., 0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - iResolution.xy * .5) / (iResolution.x + iResolution.y) * 4.;\n    seed = fract(fract(iTime * .5) + iTime * .000009); seed = rand();\n    seed = fract(seed + uv.x); seed = rand();\n    seed = fract(seed + uv.y); seed = rand();\n    vec3 ray = normalize(vec3(uv.xy, w));\n    ray = vec3(ray.x, rotate(ray.yz, rotation_yz));\n    ray = vec3(rotate(ray.xz, rotation_xz), ray.y).xzy;\n    vec3 cam = vec3(0., 0., -cam_dist);\n    cam = vec3(cam.x, rotate(cam.yz, rotation_yz + rotation_yz_cam));\n    cam = vec3(rotate(cam.xz, rotation_xz), cam.y).xzy;\n    \n    vec3 col = march(cam, ray);\n    for(int i = 2; i < 20; i ++) {\n        col = col * (1. - 1. / float(i)) + march(cam, ray) / float(i);\n    }\n    if(iFrame > start_frame) fragColor = vec4(col, 1.0) / float(iFrame - start_frame) + texture(iChannel0, fragCoord.xy/iResolution.xy) * (1. - 1. / float(iFrame - start_frame));\n    //if(dot(normalize(cam), ray) < -0.7) fragColor = vec4(0.0,0.0,1.0,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl3GWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[136, 136, 164, 164, 313], [315, 315, 370, 370, 466]], "test": "untested"}
{"id": "fl33D4", "name": "Merry-Go-Round", "author": "dr2", "description": "Carousel (mouseable)", "tags": ["raymarch", "carousel", "complexityreduction"], "likes": 11, "viewed": 285, "published": 3, "date": "1636108322", "time_retrieved": "2024-07-30T18:50:25.440454", "image_code": "// \"Merry-Go-Round\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrCaps2Df (vec2 p, float r, float h);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat Maxv2 (vec2 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat Hashff (float p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\n\nvec3 ltDir, qHit;\nfloat tCur, dstFar, gAng, nSec, aRot;\nint idObj;\nconst int idSup = 1, idTube = 2, idSeat = 3, idGrip = 4, idLitS = 5, idCmid = 6, idFlr = 7,\n   idSpk = 8, idTop = 9, idPole = 10, idLit = 11, idBase = 12, idRail = 13;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat GObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, a, h, s, sx;\n  dMin = dstFar;\n  p.xz = Rot2D (p.xz, 2. * pi * gAng);\n  q = p;\n  s = Hashff (11.1 * gAng);\n  q.x += 5. + 0.7 * s;\n  sx = sign (q.x);\n  q.x = abs (q.x) - 0.8 + 0.4 * (s - 0.5);\n  a = cos (2. * pi * gAng + 0.3 * pi * tCur) + 0.5 * cos (5. * pi * gAng - 0.7 * pi * tCur);\n  h = 0.5 + 0.2 * a;\n  q.y -= 0.2;\n  d = PrCylDf (q.xzy, 0.14, 0.1);\n  DMINQ (idSup);\n  q.y -= 2. * h;\n  d = PrCylDf (vec3 (q - vec3 (0., - h, 0.)).xzy, 0.06, h);\n  DMINQ (idTube);\n  q.xz = Rot2D (q.xz, 0.1 * pi * a * sx);\n  d = PrRoundBoxDf (q, vec3 (0.05, 0.05, 0.16), 0.1);\n  DMINQ (idSeat);\n  d = PrSphDf (vec3 (q.xy, abs (q.z) - 0.24), 0.05);\n  DMINQ (idLitS);\n  q.yz = Rot2D (q.yz - vec2 (0.2, -0.2), 0.07 * pi);\n  d = min (PrCylDf (q.xzy, 0.04, 0.3), PrCylDf ((q - vec3 (0., 0.3, 0.)).yzx, 0.03, 0.25));\n  DMINQ (idGrip);\n  return dMin;\n}\n\nfloat GObjRay (vec3 ro, vec3 rd)\n{  // (raymarching with axial grid reduces scene complexity when symmetry absent)\n  vec3 p;\n  vec2 cs;\n  float dHit, d, eps, rgOut;\n  rgOut = 10.;\n  eps = 0.001;\n  cs = sin (pi / nSec + vec2 (0., 0.5 * pi));\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    p.xz = Rot2D (p.xz, aRot);\n    gAng = (floor (nSec * atan (p.z, - p.x) / (2. * pi)) + 0.5) / nSec;\n    d = GObjDf (p);\n    p.xz = Rot2D (p.xz, 2. * pi * gAng);\n    d = min (d, 0.1 + max (- p.x - rgOut, abs (dot (vec2 (p.x, abs (p.z)), cs))));\n    dHit += d;\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 GObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, a, s;\n  dMin = dstFar;\n  q = p;\n  q.y -= 0.05;\n  d = PrCylDf (q.xzy, 9.3, 0.05);\n  DMINQ (idBase);\n  d = PrTorusDf (vec3 (q.xz, abs (abs (q.y - 1.) - 0.3) - 0.3), 0.03, 9.);\n  q.xz = Rot2D (q.xz, 2. * pi * floor (32. * atan (q.z, - q.x) / (2. * pi) + 0.5) / 32.);\n  q.xy -= vec2 (-9., 0.8);\n  d = min (d, PrCylDf (q.xzy, 0.03, 0.8));\n  DMINQ (idRail);\n  p.xz = Rot2D (p.xz, aRot);\n  q = p;\n  q.y -= 0.3;\n  d = PrCylDf (q.xzy, 1., 0.5);\n  DMINQ (idCmid);\n  q.y -= 0.6;\n  d = PrSphDf (q, 0.12);\n  DMINQ (idLit);\n  a = (floor (0.5 * nSec * atan (p.z, - p.x) / (2. * pi)) + 0.5) / (0.5 * nSec);\n  q = p;\n  q.y -= 0.1;\n  q.xz = Rot2D (q.xz, 2. * pi * a);\n  d = PrCaps2Df (vec2 (q.y - 0.1, q.x + 5.), 0.06, 2.5);\n  DMINQ (idFlr);\n  d = PrCylDf ((q - vec3 (-1.25, 0.1, 0.)).yzx, 0.07, 1.25);\n  DMINQ (idSpk);\n  d = Maxv2 (abs (Rot2D (q.xy, -0.05 * pi) - vec2 (-3.6, 5.2)) - vec2 (3.2, 0.04));\n  d = min (d, min (Maxv2 (abs (vec2 (q.x + 7.3, q.y - 3.95)) - vec2 (0.02, 0.15)),\n     Maxv2 (abs (vec2 (q.x + 1.2, q.y - 5.1)) - vec2 (0.02, 0.15))));\n  DMINQ (idTop);\n  s = sign (q.z);\n  q.z = abs (q.z);\n  q -= vec3 (7.2 * vec2 (-1., tan (pi / (0.5 * nSec))), 2.1).xzy;\n  d = PrCylDf (q.xzy, 0.07, 2.);\n  q.z *= s;\n  DMINQ (idPole);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.001 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 GrndNf (vec2 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return vec3 (normalize (vec3 (Fbm2 (p) - vec2 (Fbm2 (p + e.xy),\n     Fbm2 (p + e.yx)), 4. * e.x)).xzy);\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol;\n  vec2 q;\n  float f, fd, ff;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.4, 0.5);\n  } else {\n    q = 0.01 * (ro.xz + 2. * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * ltDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    col = mix (vec3 (0.3, 0.4, 0.8), clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nvec4 ObjCol ()\n{\n  vec4 col4;\n  vec3 c1, c2;\n  float a;\n  c1 = HsvToRgb (vec3 (gAng, 0.8, 1.));\n  c2 = HsvToRgb (vec3 (fract (gAng + 0.5), 0.8, 1.));\n  if (idObj == idPole || idObj == idBase || idObj == idCmid) a = atan (qHit.z, - qHit.x);\n  if (idObj == idBase) col4 = vec4 (0.4, 0.2, 0., 0.) * (1. - 0.3 * step (5., length (qHit.xz)) * \n     (1. - smoothstep (0., 0.1, sin (128. * a) + 0.5)));\n  else if (idObj == idTop) col4 = mix (vec4 (1., 0., 0., 0.1), vec4 (1., 1., 0., 0.1),\n     smoothstep (0., 0.02, fract (1.1 * qHit.z + 0.5) - 0.5));\n  else if (idObj == idFlr) col4 = (abs (qHit.x + 5.) < 2.45) ? vec4 (0.7, 0.4, 0.3, 0.1) *\n     (0.8 + 0.2 * smoothstep (0., 0.03, fract (2. * qHit.x) - 0.1)) * (1. -\n     0.4 * Fbm2 (64. * qHit.xz)) : vec4 (0.2, 0.7, 0.2, -1.);\n  else if (idObj == idSpk) col4 = vec4 (0.2, 0.3, 0.2, 0.1);\n  else if (idObj == idSup) col4 = vec4 (c1, -1.);\n  else if (idObj == idTube) col4 = vec4 (0.8, 0.8, 0.85, 0.2) * (0.6 +\n     0.4 * smoothstep (0., 0.02, fract (16. * qHit.y + 0.5) - 0.5));\n  else if (idObj == idSeat) col4 = mix (vec4 (c1, 0.1), vec4 (c2, 0.1),\n     step (0.5, fract (8. * qHit.z)));\n  else if (idObj == idGrip) col4 = vec4 (c1, 0.1);\n  else if (idObj == idCmid) col4 = vec4 (0.5, 0.5, 1., 0.1) *\n     (0.7 + 0.3 * smoothstep (0., 0.1, cos (0.5 * nSec * a) + 0.5));\n  else if (idObj == idPole) col4 = mix (vec4 (1., 0., 0., -1.), vec4 (1., 1., 1., 0.2),\n     smoothstep (0., 0.03, fract (8. * qHit.y + a / (2. * pi)) - 0.1));\n  else if (idObj == idRail) col4 = vec4 (0.8, 0.9, 0.9, 0.2);\n  else if (idObj == idLitS) col4 = vec4 (((qHit.z < 0.) ? c1 : c2), -1.);\n  else if (idObj == idLit) col4 = vec4 (1., 1., 0.7, -1.);\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 qHitG, col, vn;\n  float dstObjG, dstObj;\n  nSec = 36.;\n  aRot = -0.05 * pi * tCur;\n  dstObjG = GObjRay (ro, rd);\n  qHitG = qHit;\n  dstObj = ObjRay (ro, rd);\n  if (min (dstObj, dstObjG) < dstFar) {\n    if (dstObj < dstObjG) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n    } else {\n      ro += dstObjG * rd;\n      ro.xz = Rot2D (ro.xz, aRot);\n      qHit = qHitG;\n      vn = GObjNf (ro);\n      vn.xz = Rot2D (vn.xz, - aRot);\n    }\n    col4 = ObjCol ();\n    if (col4.a >= 0.) col = col4.rgb * (0.2 + 0.1 * max (- dot (vn, ltDir), 0.) +\n       0.8 * max (dot (vn, ltDir), 0.)) +\n       col4.a * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n    else col = col4.rgb * (0.6 - 0.4 * dot (rd, vn));\n  } else if (rd.y < 0.) {\n    ro += (- ro.y / rd.y) * rd;\n    vn = GrndNf (ro.xz);\n    col = (0.4 * mix (vec3 (0.8, 1., 0.5), vec3 (0.7, 0.9, 0.5), 0.2 +\n       0.8 * smoothstep (0.3, 0.7, Fbm2 (8. * ro.xz)))) *\n       (0.2 + 0.8 * max (dot (vn, ltDir), 0.));\n    col *= 0.7 + 0.3 * smoothstep (0., 0.5, length (ro.xz) - 9.3);\n    col = mix (col, vec3 (0.3, 0.4, 0.5), pow (1. + rd.y, 16.));\n  } else {\n    col = SkyBgCol (ro, rd);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.06 * pi;\n  if (mPtr.z > 0.) {\n    az -= 1.5 * pi * mPtr.x;\n    el -= 0.5 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.3 * pi, -0.02 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0.4, -30.);\n  zmFac = 4.3 / (1. - 0.8 * abs (mod (az + pi, 2. * pi) - pi) / pi);\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  uv.x *= canvas.y / canvas.x;\n  col = mix (vec3 (0.85), col, sqrt (sqrt (max (0., 0.95 - length (pow (abs (uv), vec2 (12.)))))));\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCaps2Df (vec2 p, float r, float h)\n{\n  return length (p - vec2 (0., clamp (p.y, - h, h))) - r;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl33D4.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[970, 970, 993, 993, 1850], [1852, 1852, 1886, 1966, 2538], [2540, 2540, 2562, 2562, 2818], [2820, 2820, 2842, 2842, 4108], [4110, 4110, 4143, 4143, 4390], [4392, 4392, 4413, 4413, 4668], [4670, 4670, 4692, 4692, 4833], [4835, 4835, 4869, 4869, 5457], [5459, 5459, 5475, 5475, 7149], [7151, 7151, 7186, 7186, 8376], [8378, 8378, 8434, 8434, 9630], [9632, 9632, 9678, 9678, 9725], [9727, 9727, 9760, 9760, 9787], [9789, 9789, 9831, 9831, 9882], [9884, 9884, 9928, 9928, 9988], [9990, 9990, 10036, 10036, 10093], [10095, 10095, 10117, 10117, 10144], [10146, 10146, 10182, 10182, 10388], [10390, 10390, 10420, 10420, 10533], [10535, 10535, 10559, 10559, 10676], [10710, 10710, 10734, 10734, 10771], [10773, 10773, 10797, 10797, 10850], [10852, 10852, 10876, 10876, 10988], [10990, 10990, 11015, 11015, 11161], [11163, 11163, 11188, 11188, 11374], [11376, 11376, 11398, 11398, 11552], [11554, 11554, 11575, 11575, 11730]], "test": "untested"}
{"id": "7ldGD8", "name": "Affine transformation", "author": "DosU", "description": "Just trying to anderstand affine transformation", "tags": ["transformationaffinetransformation"], "likes": 1, "viewed": 249, "published": 3, "date": "1636102252", "time_retrieved": "2024-07-30T18:50:26.203414", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float t = 2.0*sin(iTime);\n    mat3 m = mat3(\n        vec3(t, 1, 0),\n        vec3(0, t, 0),\n        vec3(0, 0, 1)\n    );\n    vec3 xy = vec3(uv, 1);\n    vec3 tx = m*xy;\n    \n    fragColor = texture(iChannel0, tx.xy);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ldGD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 323]], "test": "untested"}
{"id": "fld3D8", "name": "Dithered Spiral Effect", "author": "SnoopethDuckDuck", "description": "no idea why it's dithered, probably the log stuff", "tags": ["e"], "likes": 13, "viewed": 363, "published": 3, "date": "1636076108", "time_retrieved": "2024-07-30T18:50:27.054140", "image_code": "float thc(float a, float b) {\n    return tanh(a * cos(b));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    float sc = 250.;   \n    vec2 fpos = fract(sc * uv) - 0.5;\n    vec2 ipos = floor(sc * uv) + 0.5;\n    \n    float a = atan(ipos.y, ipos.x);\n    \n    float k = length(ipos) + 4. * thc(4., length(uv) + 10. * a + iTime);\n    float r = log(k + 3. * thc(4., length(uv) * 100. + 4. * iTime));\n    r *= .5 + .5 * thc(1.5, 4. * r + a - iTime);\n  \n    vec2 v = r * vec2(cos(a), sin(a));\n    ipos = floor(v) + 0.5;\n    \n    float d = length(fpos) + cos(length(ipos) + iTime);\n\n    fragColor = vec4(d);\n}\n", "image_inputs": [], "common_code": "#define time iTime\n\nvec2 rot (vec2 vec, float a) {\n    float m = 3.;\n    mat2 mat = mat2(tanh(m * cos(a)), -tanh(m * sin(a)) , tanh(m * sin(a)), tanh(m * cos(a)));\n    return mat * vec;\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fld3D8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 60], [62, 62, 119, 119, 679]], "test": "untested"}
{"id": "Nlt3D8", "name": "Snowflake carpet", "author": "jarble", "description": "A snowflake carpet pattern.", "tags": ["fractal", "snowflake", "carpet", "rug"], "likes": 5, "viewed": 269, "published": 3, "date": "1636074851", "time_retrieved": "2024-07-30T18:50:27.911847", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 4.5/2.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float t2 = +floor((iTime)/10.0+uv.x);\n    vec3 random1 = (hash31(t2)-vec3(.5))/4.;\n    vec3 random2 = (hash31(1.+t2)-vec3(.5))/4.;\n    vec3 random3 = (hash31(2.+t2)-vec3(.5))/4.;\n    vec3 random4 = (hash31(3.+t2)-vec3(.5))/4.;\n    \n    float offset = .5;\n    float scale2 = .5;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        for(int i=0;i<3;i++)\n        {\n            float factor = 1.25;\n            float l1 = (col.x);\n            \n            uv = triangle_wave(uv.yx+l1+offset,scale)+triangle_wave(uv,scale);\n            uv.x *= -factor;\n            \n            for(int k = 0; k < 3; k++){\n                uv = triangle_wave((uv+uv.yx*vec2(random1[k],random2[k])-l1+offset)/(random4[k]+1.),scale+random3[k]);\n                uv.x /= -factor;\n                //uv += vec2(random1[k],random2[k])*l1;\n        \n            }\n            \n\n            scale /= 1.+(scale2)*fract(uv.x*l1);\n\n            scale2 += l1;\n            //scale2 *= 2. - l1;\n\n            col = col.yxz;\n            col[c] = fract((uv.x)-(uv.y));\n\n\n        }\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlt3D8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [590, 590, 629, 629, 674], [676, 676, 733, 733, 2010]], "test": "untested"}
{"id": "Nt33WH", "name": "Nodevember day 3/4 - 4 sides", "author": "y2k_cyborg", "description": "really expensive...not sure why but it's late", "tags": ["raymarching", "nodevember"], "likes": 10, "viewed": 342, "published": 3, "date": "1636071593", "time_retrieved": "2024-07-30T18:50:28.859313", "image_code": "// Based on https://www.shadertoy.com/view/sllGDN\n// by Martijn Steinrucken aka The Art of Code/BigWings - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Performance settings\n// Enabling AA is more expensive but looks quite a lot better\n#define USE_AA 1\n// Continue further raycast after refraction?\n#define MAX_RAYS_PER_PRIMARY 2.\n\n#define MAX_STEPS 128\n#define MAX_DIST 1000.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nconst int MAT_CHROME=1;\nconst int MAT_SAND=2;\nconst int MAT_SKY=3;\n\nvec2 sdSand(vec3 p) {\n  p -= vec3(25., -5., 4.);\n  float h = p.y;\n  h += -10. * smoothstep(0., 1., .01 * length(p.xz));\n  h += .52 * sin(p.x * .351 + p.z * .225 + 0.1);\n  h += 1.13 * sin(p.x * .1242 + p.z * .1452 + 0.5);\n  h += 3.43 * sin(p.x * .0642 + p.z * 0.0543+ 0.5);\n  h += 2.94 * sin(p.z * .09842 + 0.7);\n  h += .63 * sin(p.z * .1212 - 0.3);\n  return vec2(h, MAT_SAND);\n}\n\n// This is where we define the scene itself\nvec2 GetDist(vec3 p) {\n    vec2 dMat = vec2(MAX_DIST, MAT_SKY);\n    \n    float pyramidScale = 10.;\n    vec3 pyrPos = vec3(0., 0., 0.);\n    vec2 dPyr = vec2(sdPyramid((p - pyrPos) / pyramidScale, 1.1) * pyramidScale, MAT_CHROME);\n    vec2 dSand = sdSand(p - vec3(0., 3., 0.));\n    dMat = Min(dMat, Min(dPyr, dSand));\n    \n    return dMat;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side) {\n\tfloat dO=0.;\n    vec2 dSMat = vec2(0.);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        dSMat = GetDist(p)*side;\n   \n        dO += dSMat.x;\n        if(dO>MAX_DIST || abs(dSMat.x)<SURF_DIST) break;\n    }\n    \n    return vec2(dO, dSMat.y);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n// based on https://www.shadertoy.com/view/4tdSWr\nvec3 cloud2D(vec2 p, float h) {\n    const float cloudscale = .11;\n    const float speed = 0.03;\n    const float clouddark = 0.5;\n    const float cloudlight = 0.3;\n    const float cloudcover = 0.2;\n    const float cloudalpha = 8.0;\n    const float skytint = 0.5;\n    const vec3 skycolour1 = vec3(0.2, 0.4, 0.6);\n    const vec3 skycolour2 = vec3(0.4, 0.7, 1.0);\n        \n    vec2 uv = p*vec2(iResolution.x/iResolution.y,1.0);\n    float time = iTime * speed;\n    float q = fbm(uv * cloudscale * 0.5);\n    \n    //ridged noise shape\n\tfloat r = 0.0;\n\tuv *= cloudscale;\n    uv -= q - time;\n    float weight = 0.8;\n    for (int i=0; i<8; i++){\n\t\tr += abs(weight*noise( uv ));\n        uv = m*uv + time;\n\t\tweight *= 0.7;\n    }\n    \n    //noise shape\n\tfloat f = 0.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale;\n    uv -= q - time;\n    weight = 0.7;\n    for (int i=0; i<8; i++){\n\t\tf += weight*noise( uv );\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n    \n    f *= r + f;\n    \n    //noise colour\n    float c = 0.0;\n    time = iTime * speed * 2.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale*2.0;\n    uv -= q - time;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n\t\tc += weight*noise( uv );\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n    \n    //noise ridge colour\n    float c1 = 0.0;\n    time = iTime * speed * 3.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale*3.0;\n    uv -= q - time;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n\t\tc1 += abs(weight*noise( uv ));\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n\t\n    c += c1;\n    \n    vec3 skycolour = mix(skycolour2, skycolour1, h);\n    vec3 cloudcolour = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight*c), 0.0, 1.0);\n   \n    f = cloudcover + cloudalpha*f*r;\n    \n    return mix(skycolour, clamp(skytint * skycolour + cloudcolour, 0.0, 1.0), clamp(f + c, 0.0, 1.0));\n}\n\nvec3 cloudCol(vec3 rd) {\n  float h = 2.;\n  vec3 c = vec3(h * rd.x / rd.y, h * rd.z / rd.y, h);\n  vec3 cloud = vec3(0.);\n  cloud += cloud2D(c.xy, 1. - .5 * rd.y);\n  return cloud;\n}\n\nvec3 sandCol(vec3 p) {\n  vec3 sand_hi = vec3(.7, .7,.4);\n  vec3 sand_lo = vec3(.2, .1, 0.);\n  float t = 0.;\n  t += -3.*fbm(.02 * p.zx) + 2.*fbm(13.4154 * p.xz)+.5;\n  return mix(sand_lo, sand_hi, t);\n}\n\n\nvec4 fogCol() {\n  return vec4(.7, .7, .4, .95 * 2.* windStrength(iTime));\n}\n\n\nvec3 EnvCol(vec3 rd) {\n  return cloudCol(rd);\n}\n\nvec4 Render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last) {\n    vec3 col = EnvCol(rd);\n    vec2 dMat = RayMarch(ro, rd, 1.);\n    float d = dMat.x;\n    float mat = dMat.y;\n    \n    ref *= 0.;\n    \n    float depth = 0.;\n    \n    if (d < MAX_DIST) {\n        vec3 p = ro + rd * d; // 3d hit position\n        vec3 n = GetNormal(p); // normal of surface... orientation\n        vec3 r = reflect(rd, n); // reflected ray\n        \n        // Colour of reflection, going to environment\n        vec3 refEnv = EnvCol(r);\n        \n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(0);\n        \n        int mat = int(dMat.y);\n        \n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 5.);\n        fresnel = mix(.01, .7, fresnel);\n        if (mat==MAT_SKY) {\n           \n        } else if(mat==MAT_SAND) {\n           col += sandCol(p);\n        } else if(mat==MAT_CHROME) {\n           ref = vec3(.9);\n           if (last) {\n             vec4 fog = fogCol();\n             vec3 envCol = mix(refEnv, fog.rgb, fog.a);\n             col += envCol*ref;\n           }\n        }\n            \n        ro = p + n*SURF_DIST*3.;\n        rd = r;\n    }\n    depth = d;\n    return vec4(col, depth);\n}\n\nvec3 RenderAll(vec2 fragCoord) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    // hack for the initial value being strange\n    m = (m == vec2(0., 0.)) ? vec2(0,0) : (m - .5);\n    if (m.y < 0.) { m.y = 0.; }\n    \n    vec3 cam_look_at = vec3(6., 5., 0.);\n    vec3 cam_pos = vec3(0., 2., 20.);\n    cam_pos.xz *= Rot(.1*2.*PI);\n    float fov_z = 1.5;\n    \n    cam_pos.yz *= Rot(-m.y*.02*PI);\n    cam_pos.xz *= Rot(-m.x*.03*PI);\n    cam_pos.y += 2.*GetDist(cam_pos).x;\n\n    // ray origin\n    vec3 ro = cam_pos;\n    // ray direction\n    vec3 rd = GetRayDir(uv, ro, cam_look_at, fov_z);\n    \n    vec3 col = vec3(0.);\n    vec3 ref, fil=vec3(1);\n   \n    float depth = 99999.;\n    for(float i=0.; i<MAX_RAYS_PER_PRIMARY; i++) {\n        vec4 pass = Render(ro, rd, ref, i==MAX_RAYS_PER_PRIMARY-1.);\n        if (i == 0.) { depth = pass.a;}\n        col += pass.rgb*fil;\n        fil*=ref;\n    }\n    \n    vec4 fog = fogCol();\n    return mix(\n      col,\n      fog.rgb,\n      clamp(1. - 9./depth, 0., fog.a)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = RenderAll(fragCoord);\n    \n    // Anti-aliasing\n    #if USE_AA\n    col +=\n        RenderAll(fragCoord+vec2(.5,.0))+\n        RenderAll(fragCoord+vec2(.0,.5))+\n        RenderAll(fragCoord+vec2(.5,.5));\n    col /= 4.;\n    #endif\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "// Library functions\n\n// From https://www.shadertoy.com/view/sllGDN\n// by Martijn Steinrucken aka The Art of Code/BigWings - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI 3.1415926535\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec2 Min(vec2 a, vec2 b) {\n    return a.x<b.x ? a : b;\n}\n\n// from https://www.shadertoy.com/view/4tdSWr\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));\t\n}\n\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 0.1;\n\tfor (int i = 0; i < 7; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn = m * n;\n\t\tamplitude *= 0.4;\n\t}\n\treturn total;\n}\n\n// from https://iquilezles.org/articles/distfunctions\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdBox(vec2 p, vec2 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, p.y), 0.);\n}\n\nfloat sdLineSeg(vec3 p, vec3 a, vec3 b) {\n    vec3 ap=p-a, ab=b-a;\n    float t = clamp(dot(ap, ab)/dot(ab, ab), 0., 1.);\n    vec3 c = a + ab*t;\n    return length(p-c);\n}\n\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\nfloat udIsoTriangle( vec3 p, float r )\n{\n  const float cos30 = 0.86602540378;\n  float h = r;\n  vec3 a = vec3(-h, -h*cos30, 0.);\n  vec3 b = vec3(+h, -h*cos30, 0.);\n  vec3 c = vec3( 0,  h*cos30, 0.);\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdPrism( in vec3 p, in float r, in float h )\n{\n    float d = udIsoTriangle(vec3(p.xy, 0.), r);\n    vec2 w = vec2( d, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat nGon(in int n, in vec2 p, in float r) {\n    // these 2 lines can be precomputed\n    float an = 6.2831853 / float(n);\n    float he = r * tan(0.5 * an);\n\n    // rotate to first sector\n    p = -p.yx; // if you want the corner to be up\n    float bn = an * floor((atan(p.y, p.x) + 0.5 * an) / an);\n    vec2 cs = vec2(cos(bn), sin(bn));\n    p = mat2(cs.x, -cs.y, cs.y, cs.x) * p;\n\n    // side of polygon\n    return length(p - vec2(r, clamp(p.y, -he, he))) * sign(p.x-r);\n}\n\n// for the distance result of any 2D SDF, returns a 3D prism for the 3rd axis position value v\nfloat toPrism(in float d2d, in float v, in float size) {\n    vec2 d = vec2(d2d, abs(v) - 0.5 * size);\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat nPrism(in int n, in vec3 p, in float r, in float depth) {\n    float d = nGon(n, p.xy, r);\n    return toPrism(d, p.z, depth);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat windStrength(float time) {\n  return clamp(sin(time * 0.4) * 0.4 + 0.2, 0., .5);\n}", "sound_code": "// Based on https://www.shadertoy.com/view/4l2XWh\n// Tweaked to sound more like wind\n\n\n\n// 1D version of IQ code, see https://www.shadertoy.com/view/lsf3WH\nfloat hash( float p ){\n\tfloat h = p * 127.1;\n    return fract(sin(h)*43758.5453123);\n}\nfloat perlinNoise( in float x ) {\n    float lower = floor(x);\n    float upper = lower + 1.0;\n    float lowerV = hash(lower);\n    float upperV = hash(upper);\n    return smoothstep(lower, upper, x) * (upperV - lowerV) + lowerV;\n}\n\n// return a different white noise on both channels\n// thanks Dave Hoskins! see https://www.shadertoy.com/view/4djSRW\n#define ITERATIONS 8\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\nvec2 hash22( in vec2 p ) {\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3.zxy, p3.yxz+19.19);\n    return fract(vec2(p3.x * p3.y, p3.z*p3.x));\n}\nvec2 noise( in float time ) {\n\tvec2 audio = vec2(0.0);\n    for (int t = 0; t < ITERATIONS; t++) {\n        float v = float(t)*3.21239;\n\t\taudio += hash22(vec2(time + v, time*1.423 + v)) * 2.0 - 1.0;\n    }\n    audio /= float(ITERATIONS);\n    \n    // convert to mid/side, reduce side, recombine\n    vec2 mid_side = vec2(.5*(audio.x + audio.y), .5*(audio.x - audio.y));\n    mid_side.y *= 0.8;\n    return vec2(mid_side.x + mid_side.y, mid_side.x - mid_side.y);\n}\n\n// do a low pass on the white noise and get the wave sound\n#define SAMPLES 8\nvec2 getWaveSound( in float time ) {\n    // snap to the nearest 1/iSampleRate\n    float period = 1.0 / iSampleRate;\n    time = floor(time/period)*period;\n    float totAmpl = 0.0;\n    vec2 audio = vec2(0);\n    for (int i = 0 ; i < SAMPLES ; i++) {\n        float index = float(i - SAMPLES/2);\n        float currStepF = period * index;\n        vec2 curr = noise(time + currStepF);\n        index /= 8.0;\n        index *= index;\n        float ampl = 1.0 - index;\n        totAmpl += ampl;\n        audio += curr*ampl;\n    }\n    return audio/totAmpl;\n}\n\nvec2 mainSound( in int samp,float time) {\n    vec2 result = vec2(0);\n\n    float waveAmpl = windStrength(time);\n    float perlinAmpl = 1.0 - perlinNoise( time * 0.2 ) * 0.3;\n    result += smoothstep(0.0, 10.0, time) * getWaveSound(time) * waveAmpl * perlinAmpl;\n\n    return result;\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt33WH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[557, 557, 578, 578, 935], [937, 981, 1003, 1003, 1320], [1322, 1322, 1367, 1367, 1636], [1638, 1638, 1662, 1662, 1860], [1862, 1862, 1912, 1912, 2103], [2105, 2155, 2186, 2186, 4052], [4054, 4054, 4078, 4078, 4233], [4235, 4235, 4257, 4257, 4435], [4438, 4438, 4453, 4453, 4513], [4516, 4516, 4538, 4538, 4563], [4565, 4565, 4635, 4635, 5778], [5780, 5780, 5812, 5812, 6834], [6836, 6836, 6893, 6893, 7230]], "test": "untested"}
{"id": "Nt3GWH", "name": "Blendable Radius SmoothMin", "author": "paniq", "description": "Extended polynomial smoothmin that blends between two radii, depending on what function we're closest to.", "tags": ["polynomial", "smoothmin"], "likes": 19, "viewed": 431, "published": 3, "date": "1636068499", "time_retrieved": "2024-07-30T18:50:29.813761", "image_code": "// this file is in the public domain, but citations are always welcome\n\nfloat f1(float x) {\n    return sqrt(pow(x,2.0) + pow(x-1.0,2.0)) - 1.5;\n}\n\nfloat f2(float x) {\n    return 0.1 - 0.02*x;\n}\n\nfloat f3(float x) {\n    return 0.1 + 0.6*x;\n}\n\n// ka = radius close to a, kb = radius close to b\nfloat brsmin( float a, float b, float ka, float kb)\n{\n    float s = a-b;\n    float k = (ka + kb + (kb - ka)*s/max(ka,kb))*0.5;\n    const float p = 2.0;\n    float h = max( k - abs(s), 0.0 )/k;\n    return min( a, b ) - pow(h,p)*k*(1.0/(2.0*p));\n}\n\nfloat f1xf2(float x) {\n    float a = iTime;\n    float r = 2.0;\n    float w0 = (cos(a)*0.5+0.5)*r;\n    float w1 = (sin(a)*0.5+0.5)*r;\n    return brsmin(f1(x),f2(x),w0,w1);\n}\n\nfloat grad(float x) {\n    return (f1xf2(x+0.0001) - f1xf2(x-0.0001))/0.0002;\n}\n\nvoid paint() {\n    float t = iTime;\n    \n    set_source_rgb(vec3(1.0));\n    clear();\n    \n    set_line_width_px(1.3);\n\n    set_source_rgb(hsl(0.0, 0.5, 0.5));\n    graph1D(f1);\n    stroke();\n    set_source_rgb(hsl(0.2, 0.5, 0.5));\n    graph1D(f2);\n\tstroke();\n    //set_source_rgb(hsl(0.4, 0.5, 0.5));\n    //graph1D(grad);\n\t//stroke();\n    set_source_rgb(hsl(0.8, 0.5, 0.5));\n    graph1D(f1xf2);\n\tstroke();\n\n  \n\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init(fragCoord, iMouse.xy, iResolution.xy);\n\n    paint();\n\n    blit(fragColor);\n}\n", "image_inputs": [], "common_code": "// 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n// after Cairo API, with anti-aliasing\n// by Leonard Ritter (@paniq)\n// v0.11\n\n// I release this into the public domain.\n// some estimators have been lifted from other shaders and are not\n// necessarily PD licensed, note the links in the source code comments below.\n\n// 2019-06-06: 0.12\n// * split implementation and demo into common and image tab\n\n// 2017-10-05: 0.11\n// * anti-aliasing is gamma-correct\n\n// 2017-10-01: 0.10\n// * added experimental letter() function\n\n// 2017-09-30: 0.9\n// * save() is now a declarative macro\n\n// 2017-09-11: 0.8\n// * added ellipse()\n\n// 2017-09-10: 0.7\n// * paths painted with line_to/curve_to can be filled.\n\n// 2017-09-09: 0.6\n// * added rounded_rectangle()\n// * added set_source_linear_gradient()\n// * added set_source_radial_gradient()\n// * added set_source_blend_mode()\n// * added support for non-uniform scaling\n\n// undefine if you are running on glslsandbox.com\n// #define GLSLSANDBOX\n\n#ifdef GLSLSANDBOX\n#ifdef GL_ES\n#endif\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define iTime time\n#define iResolution resolution\n#define iMouse mouse\n#endif\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// draw a letter with the given texture coordinate\nvoid letter(sampler2D font_texture_source, ivec2 l);\nvoid letter(sampler2D font_texture_source, int lx, int ly);\n    \n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n#define save(name) Context name = _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord, vec2 mouse, vec2 resolution) {\n\taspect = vec2(resolution.x / resolution.y, 1.0);\n\tScreenH = min(resolution.x,resolution.y);\n\tAA = ScreenH*0.4;\n\tAAINV = 1.0 / AA;\n    \n    uv = fragCoord.xy / resolution;\n    vec2 m = mouse / resolution;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(sqrt(_color), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    //c.rgb *= c.rgb;\n    c *= c;\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid letter(sampler2D font_texture_source, ivec2 l) {\n  vec2 p = vec2(l);\n  vec3 tx;\n  vec2 ip;\n  float d;\n  int ic;\n  ip = vec2(l);\n  p += clamp(_stack.position.xy, 0.0, 1.0);\n  ic = 0x21 + int (mod (16. + ip.x + 2. * ip.y, 94.));\n  tx = texture (font_texture_source, mod ((vec2 (mod (float (ic), 16.),\n     15. - floor (float (ic) / 16.)) + fract (p)) * (1. / 16.), 1.)).gba - 0.5;\n  d = tx.b + 1. / 256.;\n  add_field(d / min_uniform_scale());\n}\n\nvoid letter(sampler2D font_texture_source, int lx, int ly) {\n    letter(font_texture_source, ivec2(lx,ly));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt3GWH.jpg", "access": "api", "license": "public-domain", "functions": [[72, 72, 91, 91, 145], [147, 147, 166, 166, 193], [195, 195, 214, 214, 240], [242, 292, 345, 345, 536], [538, 538, 560, 560, 710], [712, 712, 733, 733, 790], [792, 792, 806, 806, 1203], [1265, 1265, 1322, 1322, 1408]], "test": "untested"}
{"id": "stc3WH", "name": "heart.....", "author": "lllcz", "description": "....", "tags": [], "likes": 5, "viewed": 186, "published": 3, "date": "1636067999", "time_retrieved": "2024-07-30T18:50:30.702386", "image_code": "#define PI 3.1415926\n#define PI_HALF (.5*PI)\n#define PIx2 (2.*PI)\n \n// 2D rotation matrix\nmat2 rotmat(float a)\n{\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n \n/// @brief 返回带有抗锯齿的 2D 圆的距离场\n/// @param uv 纹理坐标\n/// @param origin 圆心坐标\n/// @param radius 圆的半径\n/// @param alias 抗锯齿的区间\nfloat smooth_circle(in vec2 uv, in vec2 origin, float radius, float alias)\n{\n    return /*1.0 - */smoothstep(radius - alias, radius + alias,\n                                length(uv - origin));\n}\n \n/// @brief 返回默认带抗锯齿的 2D 圆的距离场\n/// @param uv 纹理坐标\n/// @param origin 圆心坐标\n/// @param radius 圆的半径\nfloat circle(in vec2 uv, in vec2 origin, float radius)\n{\n    return smooth_circle(uv, origin, radius, 0.005);\n}\n \n/// 可以分别控制四个角的大小 [z, x\n///                         w, y]\nfloat sdRoundBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x > 0.0) ? r.xy : r.zw;\n    r.x  = (p.y > 0.0) ? r.x  : r.y;\n \n    vec2 q = abs(p) - b + r.x;\n    float d = max(q.x, q.y);\n    return min(d, 0.0) + length(max(q, 0.0)) - r.x;\n}\n \n/// @brief 绘制心形\nfloat inHeart (vec2 p, vec2 center)\n{\n    //移动中心\n    p = p - center;\n    //旋转\n    vec2 q = rotmat(45. / 180.*PI) * p;\n    \n    float ret = sdRoundBox(q, vec2(.15), vec4(0.03));\n \n    ret = smoothstep(0.01, .012, ret);\n    ret = min(ret, circle(p, vec2(.1, .1), .161));\n    ret = min(ret, circle(p, vec2(-.1, .1), .161));\n \n    return ret;\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n \n     //先绘制心形\n    float dist = inHeart(uv, vec2(.5));\n \n     //再填充波浪\n    float color[2];\n    for (int i = 0; i < 2; i++)\n    {\n  \n        /// @note 正弦波形\n        float p = (5.*uv.x + float(i)  +  1.*iTime);\n        float offset =  .025 * sin(p) + .62;\n \n        float eps = 1e-3;\n        float color_0 = step(uv.y, offset);\n        color[i] = color_0 * step(dist, .1);\n    }\n \n    vec3 temp = mix(vec3(57., 56., 78.) / 255., vec3(245., 245., 245.) / 255., dist);\n    temp = mix(temp, vec3(233., 51., 74.)/255., color[0]);\n    \n    fragColor = vec4(mix(temp,  vec3(.4, 0., 0.),clamp(color[0] - color[1], 0., 1.)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stc3WH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 90, 112, 112, 164], [167, 347, 423, 423, 543], [546, 693, 749, 749, 804], [807, 888, 941, 941, 1132], [1135, 1159, 1196, 1215, 1511], [1514, 1514, 1569, 1569, 2265]], "test": "untested"}
{"id": "stcGWH", "name": "elastic collision 3D", "author": "remaindeer", "description": "Based on a molecular dynamics final project and improvements to 7dyXDy. Color maps z-position and collision. Inner and outer rings are the initialization radius and boundary potential. Lacks efficiency, anti-aliasing, and z-ordering...", "tags": ["collision", "simulation", "gravity", "mass", "elastic", "boundary", "potentialfield", "velovity"], "likes": 9, "viewed": 419, "published": 3, "date": "1636067523", "time_retrieved": "2024-07-30T18:50:31.475319", "image_code": "// Image\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.y;\n    uv.x -= (iResolution.x / iResolution.y - 1.0) / 2.0;\n    \n    iResolution.x / iResolution.y / 2.0;\n\n    vec3 col = vec3(0);\n    for (int j = 0; j < N; j++) {\n        vec4 pos = texelFetch(iChannel0, ivec2(j, IPOS), 0);\n        vec4 prop = texelFetch(iChannel0, ivec2(j, IPRP), 0);\n        if (distance(uv, pos.xy) < prop.y) {\n            col = 1.0 - pos.zzz;\n            col = prop.z == 1.0 ? mix(col, vec3(1, 0, 0), 1.0) : col;\n        }\n    }\n\n    float d = distance(uv, vec2(0.5));\n    if (RADI - RADP <= d && d <= RADI + RADP) col = mix(col, vec3(0, 1, 1), 0.5);\n    if (RADB - RADP <= d && d <= RADB + RADP) col = mix(col, vec3(1, 0, 1), 0.5);\n\n    fragColor = vec4(col, 1);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Common\n\n/////// buffer data row index: position\n#define IPOS 0\n/////// buffer data row index: velocity\n#define IVEL 1\n/////// buffer data channel row index: properties (mass, radius, & collision)\n#define IPRP 2\n/////// buffer data row index: end of data\n#define IEND 3\n/////// number of particles\n#define N 1280 / 16\n/////// particle mass\n#define M 0.005\n/////// gravitational constant\n#define G 1.000\n/////// softening\n#define S 0.100\n/////// boundary potential factor\n#define K 25.0\n/////// boundary potential sphere position\n#define POSB vec3(0.5)\n/////// boundary potential sphere radius\n#define RADB 0.40\n/////// initialization sphere radius\n#define RADI 0.20\n/////// particle radius\n#define RADP 0.005\n/////// maximum particle mass\n#define MPMASS 100.0\n/////// maximum particle radius\n#define MPRADI 0.015\n/////// maximum particle initial velocity\n#define MPVELO 0.050\n\nfloat random(vec2 seed) {\n    // https://thebookofshaders.com/10/\n    return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvec3 random3(vec2 seed) {\n    return vec3(random(seed.xy), random(seed.yx), random(seed.xx));\n}\n\nvec3 force_gravity(ivec2 i, vec3 pos, sampler2D iChannel) {\n    // https://developer.nvidia.com/gpugems/gpugems3/part-v-physics-simulation/chapter-31-fast-n-body-simulation-cuda\n    vec3 f = vec3(0);\n    for (int j = 0; j < N; j++) {\n        vec3 r = texelFetch(iChannel, ivec2(j, IPOS), 0).xyz - pos.xyz;\n        f += M * r / pow(pow(length(r), 2.0) + S * S, 1.5);\n    }\n    return G * M * f;\n}\n\nvec3 force_boundary(vec3 pos) {\n    float r = distance(pos, POSB);\n    return r >= RADB ? -2.0 * K * (r - RADB) * (pos - vec3(0.5)) : vec3(0);\n}\n\nvec3 forces(ivec2 iv, vec3 pos, sampler2D iChannel) {\n    return force_gravity(iv, pos, iChannel) + force_boundary(pos);\n}\n", "buffer_a_code": "// Buffer A\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2  uv = fragCoord;\n    ivec2 iv = ivec2(uv);\n\n    vec4 fcol = vec4(0);\n    if (iv.x < N && iv.y < IEND) {\n        if (iFrame == 0) {\n            // initialize\n            /****/ if (iv.y == IPOS) {\n                // https://math.stackexchange.com/a/1585996\n                vec3 pos = 1.0 - 2.0 * random3(uv + iTime);\n                pos = normalize(pos) * RADI + vec3(0.5);\n                fcol = vec4(pos, 0);\n            } else if (iv.y == IVEL) {\n                vec3 vel = random3(uv.yx + iDate.xy + iTime).xyz;\n                vel.x *= random(uv.xy + iDate.xy + iTime) < 0.5 ? -1.0 : +1.0;\n                vel.y *= random(uv.yx + iDate.xy + iTime) < 0.5 ? -1.0 : +1.0;\n                vel.z *= random(uv.yy + iDate.xy + iTime) < 0.5 ? -1.0 : +1.0;\n                fcol.xyz = vel * MPVELO;\n            } else if (iv.y == IPRP) {\n                fcol.x = MPMASS * random(uv.xy + iDate.xy + iTime); // mass\n                fcol.y = fcol.x / MPMASS * MPRADI;                  // radius\n            }\n        } else {\n            // collisions\n            bool cll = false;\n            vec3 pos1 = texelFetch(iChannel0, ivec2(iv.x, IPOS), 0).xyz;\n            vec3 vel1 = texelFetch(iChannel0, ivec2(iv.x, IVEL), 0).xyz;\n            vec4 prop1 = texelFetch(iChannel0, ivec2(iv.x, IPRP), 0);\n            float mass1 = prop1.x;\n            float radius1 = prop1.y;\n            for (int j = 0; j < N; j++) {\n                if (iv.x != j) {\n                    vec3 pos2 = texelFetch(iChannel0, ivec2(j, IPOS), 0).xyz;\n                    vec3 vel2 = texelFetch(iChannel0, ivec2(j, IVEL), 0).xyz;\n                    vec4 prop2 = texelFetch(iChannel0, ivec2(j, IPRP), 0);\n                    float mass2 = prop2.x;\n                    float radius2 = prop2.y;\n                    float d = distance(pos1, pos2);\n                    if (d < radius1 + radius2) {\n                        vec3 n = normalize(pos1 - pos2);\n                        pos1 += n * (radius1 + radius2 - d);\n                        if (dot(pos2 - pos1, vel1) > 0.0) { \n                            // https://en.wikipedia.org/wiki/Elastic_collision#Two-dimensional_collision_with_two_moving_objects\n                            vel1 -= (2.0 * mass2 / (mass1 + mass2)) * (dot(vel1 - vel2, pos1 - pos2) / length(pos1 - pos2)) * (pos1 - pos2);\n                            // https://en.wikipedia.org/wiki/Specular_reflection#Vector_formulation\n                            vel1 -= 2.0 * dot(vel1, n) * n;\n                        }\n                        cll = true;\n                        break;\n                    }\n                }\n            }\n            // potential fields\n            // https://en.wikipedia.org/wiki/Verlet_integration\n            // fpos = pos + vel * dt + 0.5 * forces(pos) * dt ** 2\n            // fvel = vel + 0.5 * (f + forces(fpos)) * dt\n            vec3 pos = pos1;\n            vec3 vel = vel1;\n            vec3 ff1 = forces(iv, pos, iChannel0);\n            pos += vel * iTimeDelta + 0.5 * ff1 * iTimeDelta * iTimeDelta;\n            /****/ if (iv.y == IPOS) {\n                fcol = vec4(pos, 0);\n            } else if (iv.y == IVEL) {\n                vel += 0.5 * (ff1 + forces(iv, pos, iChannel0)) * iTimeDelta;\n                fcol = vec4(vel, 0);\n            } else if (iv.y == IPRP) {\n                fcol = vec4(prop1.x, prop1.y, int(cll), 0);\n            }\n        }\n    }\n\n    fragColor = fcol;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stcGWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[10, 10, 65, 65, 792]], "test": "untested"}
{"id": "st33D8", "name": "shear brick", "author": "jorge2017a2", "description": "shear brick", "tags": ["2d", "brick", "shear"], "likes": 3, "viewed": 198, "published": 3, "date": "1636064835", "time_retrieved": "2024-07-30T18:50:32.239276", "image_code": "///shear brick\n///por jorge2017a2...2021-nov-04\n///referencia\n//https://iquilezles.org/articles/distfunctions2d\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.05),b,d)\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\n\nvec2 ShearX(float sh, vec2 p) \n{\n    mat2 shm= mat2(\n        1.0, sh, // column 1\n        0.0, 1.0     // column 2\n    );\n    \n    return shm*p;\n}\n\nvec2 ShearY(float sh, vec2 p) \n{   mat2 shm= mat2(\n        1.0, 0.0, // column 1\n       sh, 1.0     // column 2\n    );\n    \n    return shm*p;\n}\n\n\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj,0.0)); return colOut;}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{  vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\n\nfloat sdParallelogram( in vec2 p, float wi, float he, float sk )\n{  vec2 e = vec2(sk,he);\n    p = (p.y<0.0)?-p:p;\n    vec2  w = p - e; w.x -= clamp(w.x,-wi,wi);\n    vec2  d = vec2(dot(w,w), -w.y);\n    float s = p.x*e.y - p.y*e.x;\n    p = (s<0.0)?-p:p;\n    vec2  v = p - vec2(wi,0); v -= e*clamp(dot(v,e)/dot(e,e),-1.0,1.0);\n    d = min( d, vec2(dot(v,v), wi*he-abs(s)));\n    return sqrt(d.x)*sign(-d.y);\n}\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nvec3 ParedDif(float dist, vec2 p, vec3 col, vec3 col1,vec3 col2)\n{\n    float d1=dist;\n    vec2 p1, p2;\n    p1=p;\n    p2=p-vec2(0.7,0.6);\n    float alto=1.2;\n    float ancho=1.2;\n    p1.x= opRep1D(p1.x, ancho);\n    p1.y= opRep1D(p1.y, alto);\n    p2.x= opRep1D(p2.x, ancho);\n    p2.y= opRep1D(p2.y, alto);\n    \n    float d2=sdBox(p1, vec2(0.5,0.23) );\n    float d3=sdBox(p2, vec2(0.5,0.23) );\n    float dif=differenceSDF(d1,d2);\n     dif=differenceSDF(dif,d3);\n    col= DrawFig(col1, col, d1);\n    col= DrawFig(col2, col, dif);\n    return col;\n}\n\n\nvec3 cuarto(vec2 p, vec3 col)\n{\n    float wi, he,sk;\n    wi=0.7;\n    he=0.7;\n    sk=0.5;\n    \n    float d1=sdParallelogram( p.yx,  wi, he,sk );\n\n    \n    float d2=sdBox(p-vec2(1.4,0.5), vec2(0.7,0.7) );\n    float d3=sdParallelogram( vec2(-p.y, p.x)-vec2(0.0,2.8),  wi, he,sk );\n      vec2 p1=p*5.0;\n       p1= ShearX(0.7, vec2(-p1.x,p1.y));\n    col=ParedDif(d1,p1, col, VERDE3,NEGRO);\n    \n    \n    \n    vec2 p2=p*5.0;\n       p2= ShearX(0.7, p2);\n     col=ParedDif(d3,p2, col, VERDE3,NEGRO);\n    \n    \n    ///pared frente\n    float dPuerta=sdBox(p-vec2(1.4,0.3), vec2(0.3,0.5) );\n    d2=differenceSDF(d2,dPuerta);\n    col=ParedDif(d2,p*5.4+vec2(0.5,0.1),col, VERDE2,NEGRO);\n   \n    \n    float r1, r2;\n    r1=1.83;\n    r2=0.7;\n    he=0.4; \n    float d4= sdTrapezoid( p-vec2(1.4,-0.6),r1, r2,he );\n    \n    vec2 p3=p*3.5;\n       p3+= rotatev2(p3, radians(290.0));\n     \n      p3= ShearY(0.7, p3);\n    col=ParedDif(d4,p3, col, CAFE2,NEGRO);\n    \n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    //vec3  col=vec3(0.45,0.7,1.0)-uv.y*0.45;\n    vec3  col=vec3(0.0);\n    \n    float zoom = fract(iTime * 0.3);\n    vec2 offset = vec2(-0.5, 0.5);\n\tfloat scale = 3.5;\n\tvec2 pan = offset * zoom;\n\n\tfloat fullA = 0.5;\n\tmat2 fullRot = mat2(cos(fullA), sin(fullA), -sin(fullA), cos(fullA));\n    \n\tfloat a = -fullA * zoom;\n\tmat2 rot = mat2(cos(a), sin(a), -sin(a), cos(a));\n\n\tvec2 pos = (uv - offset) * exp(-zoom * scale) * rot + offset;\n\n\tvec3 col1 = vec3(0.0);\n    //vec3  col1=vec3(0.45,0.7,1.0)-uv.y*0.45;\n\tcol1=cuarto(pos-vec2(-1.5,0.0),col1);\n    \n\tvec3 col2 = vec3(0.0);\n\tcol2=cuarto((pos - offset) * exp(scale) * fullRot + offset, col2);\n\tcol = mix(col1, col2, zoom);\t\n\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "const vec3 CAFE0=vec3(90,39,41)/255.;\nconst vec3 CAFE1=vec3(118,57,49)/255.;\nconst vec3 VERDE0=vec3(0.1,0.35,0.35);\nconst vec3 VERDE1=vec3(0.0,0.4,0.4);\nconst vec3 VERDE2=vec3(0.0,0.5,0.5);\nconst vec3 VERDE3=vec3(30,122,144)/255.0;\nconst vec3 VERDE4=vec3(9,87,87)/255.;\nconst vec3 CALLE1=vec3(1,74,74)/255.0;\nconst vec3 CAFE2=vec3(128,77,77)/255.0;\nconst vec3 CAFE3=vec3(99,67,56)/255.0;\nconst vec3 FVENTANA=vec3(150,141,141)/255.0;\nconst vec3 FVENTANA2=vec3(164,173,106)/255.0;\nconst vec3 VERDE5=vec3(2,73,73)/255.0;\nconst vec3 NEGRO=vec3(0,0,2)/255.0;\nconst vec3 TECHO1=vec3(33,99,123)/255.0;\nconst vec3 VERDE5P=vec3(16,132,9)/255.0;\nconst vec3 VERDE6P=vec3(3,80,24)/255.0;\nconst vec3 CASA5=vec3(92,90,107)/255.0;\nconst vec3 CASA4=vec3(69,66,66)/255.0;\nconst vec3 CASA5A=vec3(90,82,82)/255.0;\nconst vec3 CASA5B=vec3(140,114,114)/255.0;\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st33D8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[273, 273, 307, 307, 402], [406, 406, 438, 438, 552], [554, 554, 586, 586, 697], [700, 731, 767, 767, 812], [817, 861, 908, 908, 935], [936, 936, 979, 979, 1006], [1007, 1007, 1055, 1055, 1083], [1089, 1089, 1151, 1151, 1280], [1282, 1282, 1363, 1363, 1490], [1492, 1492, 1549, 1549, 1614], [1616, 1616, 1653, 1653, 1730], [1734, 1734, 1800, 1800, 2139], [2142, 2142, 2167, 2167, 2186], [2188, 2188, 2253, 2253, 2563], [2565, 2565, 2631, 2631, 3108], [3111, 3111, 3142, 3142, 4071], [4075, 4075, 4132, 4132, 4947]], "test": "untested"}
{"id": "Nl3GD8", "name": "QR Video", "author": "athlete", "description": "Video that looks like a QR code. Based on my dot matrix shader: https://www.shadertoy.com/view/XldBRM", "tags": ["video", "qr", "qrcode"], "likes": 7, "viewed": 356, "published": 3, "date": "1636048744", "time_retrieved": "2024-07-30T18:50:33.005228", "image_code": "const float pixSizeX = 8.0; //width of QR in pixel\nconst float pixSizeY = 8.0; //height of QR in pixel\nfloat pixThreshold = 0.7; //specify at what threshold a pixel will become either on or off\nfloat markerSize = 9.0; //unit is QR Cells\n\nvec3 Marker(float x, float y)\n{\n    vec3 retVal = vec3(0.0, 0.0, 0.0); \n    vec3 black = vec3(-1.0, -1.0, -1.0);\n    vec3 white = vec3(1.0, 1.0, 1.0);       \n    \n    int size = int(markerSize/2.0f);\n    for(int r = 0; r<=size; r++)\n    {\n     if( (x == float(r)*pixSizeX && y <= (markerSize-float(r))*pixSizeY && y >= float(r)*pixSizeY)\n      ||(x == (markerSize-float(r))*pixSizeX && y <= (markerSize-float(r))*pixSizeY && y >= float(r)*pixSizeY)\n      ||(y == float(r)*pixSizeY && x < (markerSize-float(r))*pixSizeX && x >= float(r)*pixSizeX)\n      ||(y == (markerSize-float(r))*pixSizeY && x <= (markerSize-float(r))*pixSizeX && x >= float(r)*pixSizeX)\n     )\n        retVal = ((r % 2 > 0) || r == size) ? black : white;\n    }\n    \n    return retVal;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //indexing, translating pixels to cells\n    float indexX = fragCoord.x - .5;\n    float indexY = fragCoord.y - .5;\n    float cellX = floor(indexX / pixSizeX)* pixSizeX;\n    float cellY = floor(indexY / pixSizeY)* pixSizeY;    \n  \n    //sample texture color and create QR pixel from video\n    vec2 currUV = vec2(cellX/iResolution.x, cellY/iResolution.y);\n    vec3 currTexVal = texture(iChannel0, currUV).rgb; \n    float texAvg = 0.3*currTexVal.r + 0.59*currTexVal.g + 0.11*currTexVal.b;\n    \n    //switch cells on/off\n    texAvg = step(pixThreshold, 1.0 - texAvg);\n    \n    //set QR pixels\n    vec3 col = texAvg > 0.0 ? vec3(0.0, 0.0, 0.0) : vec3(1.0, 1.0, 1.0);\n    \n    //Add QR Corner Markers\n    col += Marker(cellX, cellY);\n    col += Marker(cellX, iResolution.y - pixSizeY - cellY);\n    col += Marker(cellX - iResolution.x + (markerSize+1.0)*pixSizeX, iResolution.y - pixSizeY - cellY);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl3GD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[238, 238, 269, 269, 994], [996, 996, 1053, 1097, 2010]], "test": "untested"}
{"id": "7tt3Wr", "name": "BrickTileable", "author": "EvilRyu", "description": "hmm...", "tags": ["normalmap", "brick", "tileable", "tile"], "likes": 6, "viewed": 321, "published": 3, "date": "1636043090", "time_retrieved": "2024-07-30T18:50:33.872909", "image_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nfloat brick(vec2 p)\n{\n    // offset for each row\n    float offset = sqrt(floor(mod(p.y,2.)+16.)*16.);\n    p.x += offset;\n    \n    vec2 m = floor(p);\n    vec2 n = fract(p)*2.-1.;\n        \n    vec2 nn = pow(n, vec2(10.));\n    float d = pow(nn.x+nn.y, .1)-0.07; // controls size of the brick\n    \n    // tune softness\n    //return pow(smoothstep(1., .8,d),5.);\n    return pow(smoothstep(1., .8,d),1.);\n}\n\nvec3 shading(vec3 n)\n{\n    vec3 L = normalize(vec3(-.7,.8,1.));\n    float dif = max(0., dot(L, n));\n    return vec3(dif);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= vec2(4.*iResolution.x/iResolution.y,6.);\n    uv.xy += iTime;\n        \n    vec2 eps=vec2(.012,0);\n    vec3 nor = normalize(vec3(brick(uv-eps.xy) - brick(uv+eps.xy),\n                              brick(uv-eps.yx) - brick(uv+eps.yx),1.));\n    \n    vec3 col = shading(nor);\n    if(fragCoord.x > iResolution.x*.5) col = vec3(nor*.5+.5);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tt3Wr.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[111, 111, 132, 159, 511], [513, 513, 535, 535, 636], [638, 638, 695, 695, 1111]], "test": "untested"}
{"id": "ftc3W8", "name": "Spinning Cube", "author": "LargeBee", "description": "My second ever shader! Recreating an old project I made with DOS graphics when I was learning about matrices and orthographic projection.\nTips on how to improve it very much appreciated", "tags": ["cube", "beginner", "orthographic"], "likes": 4, "viewed": 346, "published": 3, "date": "1636040879", "time_retrieved": "2024-07-30T18:50:34.719645", "image_code": "/*\n    Borrowed from https://www.shadertoy.com/view/MlcGDB\n    uv Normalized coordinates from main func\n    p1 Position 1 to draw the line from\n    p2 Position 2 to draw the line to\n    t  Thickness of the line\n*/\nfloat line(vec2 uv, vec2 p1, vec2 p2, float t) \n{\n    vec2 g = p2 - p1;\n    vec2 h = uv - p1;\n    t /= iResolution.y;\n    float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n\treturn smoothstep(t, 0.5*t, d);\n}\n\nmat3 rotationZ(float angle)\n{\n    return mat3(\n        cos(angle),-sin(angle),0,\n        sin(angle),cos(angle),0,\n        0,0,0\n    );\n}\n\nmat3 rotationY(float angle)\n{\n    return mat3(\n        cos(angle),0,sin(angle),\n        0,1,0,\n        -sin(angle),0,cos(angle)\n    );\n}\n\nmat3 rotationX(float angle)\n{\n    return mat3(\n        1,0,0,\n        0,cos(angle),sin(angle),\n        0,-sin(angle),cos(angle)\n    );\n}\n\nmat3 scaler(float scale)\n{\n    return mat3(\n        scale,0,0,\n        0,scale,0,\n        0,0,scale\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n    //Define set of points\n    vec3 points[] = vec3[](\n    vec3(-1.0,-1.0,-1.0),   //Corner 0\n    vec3(1.0,-1.0,-1.0),    //Corner 1\n\n    vec3(1.0,1.0,-1.0),     //Corner 2\n    vec3(-1.0,1.0,-1.0),    //Corner 3\n\n    vec3(-1.0,-1.0,1.0),    //Corner 4\n    vec3(1.0,-1.0,1.0),     //Corner 5\n    \n    vec3(1.0,1.0,1.0),      //Corner 6\n    vec3(-1.0,1.0,1.0)      //Corner 7\n    );\n\n    ivec2 edges[] = ivec2[](\n        ivec2(0, 1),\n        ivec2(0, 3),\n        ivec2(0, 4),\n        ivec2(1, 2),\n        ivec2(1, 5),\n        ivec2(2, 3),\n        ivec2(2, 6),\n        ivec2(3, 7),\n        ivec2(4, 5),\n        ivec2(4, 7),\n        ivec2(5, 6),\n        ivec2(6, 7)\n    );\n\n    float angle = iTime; //Modify?\n    float scale = 0.5;\n\n    //rotate and project points with matrix maths and use time as angle\n    vec3 outPoints;\n    vec2 projectedPoints[points.length()];\n    for (int i = 0; i < points.length(); ++i)\n    {\n        outPoints = points[i];\n        outPoints *= rotationY(angle)\n                * rotationX(angle)\n                * scaler(scale);\n        \n        projectedPoints[i] = vec2(outPoints.xy);\n    }\n    \n    float colOut = 0.0;\n    bool valid;\n    //Add lines to output value\n    for (int i = 0; i < edges.length(); ++i)\n    {\n        colOut += line(\n            uv, \n            projectedPoints[edges[i].x].xy, \n            projectedPoints[edges[i].y].xy, \n            4.0\n        );\n    }\n\n    const vec3 backColour  = vec3(0.3);\n    const vec3 lineColour = vec3(0.35,0.95,0.51);\n    \n    vec3 colour = mix(backColour, lineColour, colOut);\n    //Output colour per pixel\n    fragColor = vec4(colour, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftc3W8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 214, 263, 263, 435], [437, 437, 466, 466, 573], [575, 575, 604, 604, 711], [713, 713, 742, 742, 849], [851, 851, 877, 877, 959]], "test": "untested"}
{"id": "ft33W8", "name": "Rack and pinion", "author": "mlaang", "description": "A gear meshing with two linear gears. We use CSG to construct a gear, and then subtract infinitely many copies of that gear from a cylinder to get the rack: to do this we construct a small number of copies of the gear and then use gradient descent.", "tags": ["raymarching", "gear", "rackandpinion"], "likes": 2, "viewed": 292, "published": 3, "date": "1636039144", "time_retrieved": "2024-07-30T18:50:35.564386", "image_code": "//Parameters: x, vector from which the distance is calculated\n//\t      r, sphere radius\n//\t      c, sphere center vector\n//Return value: signed distance to sphere surface\nfloat distance_to_sphere(vec3 x, float r, vec3 c) {\n    return length(x-c)-r;\n}\n\nfloat softmin(float x, float y) {\n    float K=8.0;\n    return -log(exp(-K*x) + exp(-K*y))/K;\n}\n\nconst float pi = 3.14159265;\n\n//Parameters: x, vector to be rotated,\n//\t      axis, axis around which it is to be rotated\n//\t      angle, rotation angle\n//Return value: rotated vector\nvec3 rotate(vec3 x, vec3 axis, float angle) {\n   return x*cos(angle) + cross(axis, x)*sin(angle) + axis*(1.-cos(angle))*dot(axis, x);\n}\n\n//Parameters: x, spatial position\n//Return value: signed distance from x to a 3D object representing a stylized gear shape\nfloat distance_to_gear(vec3 x) {\n    //d1 is the distance to a central sphere\n\n    float d1 = distance_to_sphere(x, 0.5, vec3(0.0, 0.0, 0.0));\n    \n    //d2 will after the loop be the distance to the union of little spheres that act as cogs\n    \n    const float n=7.0;\n    \n    float d2 = 10000000.0;\n    for(float i=0.0; i < n; i = i + 1.0) {\n        float d = distance_to_sphere(x, 0.1, vec3(0.6*cos(2.0*pi/n*i), 0.6*sin(2.0*pi/n*i), 0.0));\n        if(d < d2)\n            d2 = d;\n            \n        d = distance_to_sphere(x, 0.05, vec3(0.7*cos(2.0*pi/n*i), 0.7*sin(2.0*pi/n*i), 0.0));\n        if(d < d2)\n            d2 = d;\n    }\n\n    return softmin(d1,d2);\n}\n\n//Parameters: x, spatial position\n//            y, sign representing the direction of the translatory motion\n//Return value: signed distance to the shape swept out by the shape to which distance_to_gear defines the distance to under rotation and translation.\nfloat distance_to_reciprocal_gear(vec3 x, float s) {\n    x.x = mod(x.x, 2.0*pi/7.0); //Use translation symmetry\n\n    float relevant_angle,\n          d = 1000000.0;\n     for(float i=0.0; i <= 2.0*pi/7.0; i += 0.2) {\n        float temp = distance_to_gear(rotate(x+s*vec3(i, 0.0, 0.0), vec3(0,0,1), i));\n        if(temp < d) {\n            d = temp;\n            relevant_angle = i;\n        }\n    }\n    \n    for(int i = 0; i != 2; ++i) {\n        const float epsilon = 0.001;\n        float grad = distance_to_gear(rotate(x + vec3(s*(relevant_angle + epsilon), 0.0, 0.0), vec3(0.0, 0.0, 1.0), relevant_angle + epsilon));\n        grad = grad - distance_to_gear(rotate(x + vec3(s*relevant_angle, 0.0, 0.0), vec3(0.0, 0.0, 1.0), relevant_angle));\n        grad = grad/epsilon;\n        \n        relevant_angle = relevant_angle - 0.8*grad;\n    }\n    \n    d = distance_to_gear(rotate(x+s*vec3(relevant_angle, 0.0, 0.0), vec3(0.0, 0.0, 1.0), relevant_angle));  \n    \n    return d;\n}\n\n//Parameters: x, spatial position\n//Return value: Signed distance from x to a particular cylinder\nfloat cyl(vec3 x) {\n    return length(x.yz) - 0.25;\n}\n\n//Signed distance to the xy plane with normal pointing in the -z direction\nfloat distance_beyond_xy_plane(vec3 x) {\n    return -x.z;\n}\n\n//Parameters: x, spatial position\n//Return value: Signed distnace to a complete scene\n//\n// This scene has several characteristics:\n// One thing shown in it is the gear,the distance to which is d\n// We construct a rack which meshes with the gear in one rotation direction\n// the distance to which is d2\n// and we construct another rack which meshes with the gear in another rotation direction\n// the distance to which is d5\n// The intersections of these racks with two cylinders from which the front half has been\n// subtracted using the 'distance_beyond_xy_plane' function.\nfloat distance_to_scene(vec3 x) {\n    float d = distance_to_gear(rotate(x, vec3(0.0, 0.0, 1.0), iTime));\n    \n    float d2 = distance_to_reciprocal_gear(x-vec3(mod(iTime, 2.0*pi),0.0,0.0), 1.0);\n    float d3 = cyl(x-vec3(0.0, 0.5, 0.0));\n    float d4 = distance_beyond_xy_plane(x);\n    \n    float d5 = distance_to_reciprocal_gear(x+vec3(mod(iTime, 2.0*pi),0.0,0.0), -1.0);\n    float d6 = cyl(x-vec3(0.0, -0.5, 0.0));\n    \n    return min(min(max(max(d3, -d2), d4), d), max(max(d6, -d5), d4));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from -1.0 to 1.0) \n    vec2 uv = (2.0*fragCoord.xy - iResolution.xy)/min(iResolution.x, iResolution.y);\n\n    // Camera: ray origin and direction\n    vec3 ro = vec3(0.0, 0.0, -5.0);\n    vec3 camera_direction = vec3(0.0, 0.0, 0.0) - ro;\n    vec3 rd = vec3(uv.xy, 0.0)-ro;\n    rd = normalize(rd);\n    \n    //Walk along the ray to get to the scene surface\n    \n    vec3 current_position;\n    current_position = ro;\n    for(int i = 0; i != 15; ++i)\n        current_position = current_position + rd*distance_to_scene(current_position);\n        \n    //Is there a hit?\n    \n    const float epsilon = 0.005;\n    \n    float col;\n    \n    if(distance_to_scene(current_position) < epsilon) {\n        float d = distance_to_scene(current_position);\n        float d_plusx = distance_to_scene(current_position + epsilon*vec3(1.0,0.0,0.0));\n        float d_plusy = distance_to_scene(current_position + epsilon*vec3(0.0,1.0,0.0));\n        float d_plusz = distance_to_scene(current_position + epsilon*vec3(0.0,0.0,1.0));\n        \n        vec3 grad = vec3(d_plusx - d, d_plusy - d, d_plusz - d);\n        grad = grad/epsilon;\n        \n        //Grad is now an outward pointing normal\n        //We could do raytracing, but we're instead just going to color the scene\n        //by the normal\n        \n        //Specifically, the color will be the cosine of the angle with a couple of fixed vectors\n        //as is traditional\n        \n        vec3 v = vec3(1.0, 1.0, 1.0);\n        \n        float agreement = dot(v, grad)/(length(grad) * length(v));\n        col = 0.00 + 0.5*max(agreement, 0.);\n        \n        //Now, to brighten things up we do a reflection\n        \n        vec3 normal = normalize(grad);\n        \n        vec3 rd_along_normal = dot(rd, normal)*normal;\n        vec3 rd_orthogonal_to_normal = rd - rd_along_normal;\n        \n        //Make flipped vector\n        ro = current_position;\n        rd = -rd_along_normal + rd_orthogonal_to_normal;\n        \n        //Now do the marching again\n        \n        current_position = ro;\n        for(int i = 0; i != 10; ++i)\n               current_position = current_position + rd*distance_to_scene(current_position);\n               \n        //and what's the normal there again?\n        \n        d = distance_to_scene(current_position);\n        d_plusx = distance_to_scene(current_position + epsilon*vec3(1.0,0.0,0.0));\n        d_plusy = distance_to_scene(current_position + epsilon*vec3(0.0,1.0,0.0));\n        d_plusz = distance_to_scene(current_position + epsilon*vec3(0.0,0.0,1.0));\n        \n        grad = vec3(d_plusx - d, d_plusy - d, d_plusz - d);\n        grad = grad/epsilon;\n        \n        //get the color there and add it multiplied by something like 0.9 (or, well, it seems I picked 1.0)\n        \n        agreement = dot(v, grad)/(length(grad) * length(v));\n        col = col + max(agreement, 0.0);\n        \n    } else col = 0.0;\n        \n    fragColor = vec4(col, col, col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft33W8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 171, 222, 222, 250], [252, 252, 285, 285, 346], [378, 532, 577, 577, 667], [669, 792, 824, 869, 1455], [1457, 1716, 1768, 1768, 2683], [2685, 2783, 2802, 2802, 2836], [2838, 2913, 2953, 2953, 2972], [2974, 3549, 3582, 3582, 4042], [4044, 4044, 4101, 4157, 7067]], "test": "untested"}
{"id": "7tdGDr", "name": "Maptoy - sdEllipticTorus", "author": "iY0Yi", "description": "make \"sdEllipticTorus\" by mixing iq's 2D ellipses.\nhttps://www.shadertoy.com/view/4sS3zz\nhttps://iquilezles.org/articles/ellipsoids/ellipsoids.htm\n", "tags": ["maptoy", "sdelliptictorus"], "likes": 9, "viewed": 266, "published": 3, "date": "1636030842", "time_retrieved": "2024-07-30T18:50:36.523821", "image_code": "#define UI_AXIS 1\n#define UI_GRID_2D 1\n#define UI_GRID_3D 0\n#define UI_ISOLINE 1\n\n#define VIEW_QUAD 0\n\n#define DBG_MATCAP 0\n#define DBG_NORMAL 0\n#define DBG_COST 0\n\n#define CAM_SCALE 1.\n#define TURN_TABLE 0\n#define TURN_TABLE_SPEED .5\n\n#if 0\n// Ellipse - distance 2D\n// https://www.shadertoy.com/view/4sS3zz\nfloat msign(in float x) { return (x<0.0)?-1.0:1.0; }\n\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n    if( ab.x==ab.y ) return length(p)-ab.x;\n\tp = abs( p ); \n    if( p.x>p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2+n2-1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float d = c3 + m2*n2;\n    float q = d  + m2*n2;\n    float g = m  + m *n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h) + 2.0;\n        float t = sin(h) * sqrt(3.0);\n        float rx = sqrt( m2-c*(s+t) );\n        float ry = sqrt( m2-c*(s-t) );\n        co = ry + sign(l)*rx + abs(g)/(rx*ry);\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt(d);\n        float s = msign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float t = msign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -(s+t) - c*4.0 + 2.0*m2;\n        float ry =  (s-t)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = ry/sqrt(rm-rx) + 2.0*g/rm;\n    }\n    co = (co-m)/2.0;\n\n    float si = sqrt( max(1.0-co*co,0.0) );\n \n    vec2 r = ab * vec2(co,si);\n\t\n    return length(r-p) * msign(p.y-r.y);\n}\n#else\n// \"Apply General SDF to Ellipse\" by IWBTShyGuy:\n// https://www.shadertoy.com/view/fsSSzG\nconst int DIV = 50;\nconst int BISECTIONMAX = 10;\n\nconst float PARAM_MIN = -3.141592653;\nconst float PARAM_MAX = 3.141592653;\n\nvec2 curve(in float t, in vec2 ab) {\n    return vec2(ab.x * cos(t), ab.y * sin(t));\n}\n\nvec2 derive(in float t, in vec2 ab) {\n    return vec2(-ab.x * sin(t), ab.y * cos(t));\n}\n\n// Roughly find the parameter hint that minimizes the distance between p and curve(hint).\nfloat rough(in vec2 p, in vec2 ab) {\n    float hint = 0.0, mdist = 10.0;\n    for (int i = 0; i <= DIV; i++) {\n        float t = (PARAM_MAX - PARAM_MIN) * float(i) / float(DIV) + PARAM_MIN;\n        float dist = distance(curve(t, ab), p);\n        mdist = min(dist, mdist);\n        hint = t + sign(dist - mdist) * (hint - t);\n    }\n    return hint;\n}\n\n// Find the critical parameter t of the signed distance between p and curve(t) by the bisection method.\nfloat precise(in vec2 p, in vec2 ab) {\n    float hint = rough(p, ab);\n    float t0 = hint - (PARAM_MAX - PARAM_MIN) / float(DIV);\n    float t1 = hint + (PARAM_MAX - PARAM_MIN) / float(DIV);\n    for (int i = 0; i < BISECTIONMAX; i++) {\n        float f0 = dot(derive(t0, ab), curve(t0, ab) - p);\n        float t = (t0 + t1) / 2.0;\n        float f = dot(derive(t, ab), curve(t, ab) - p);\n        t0 = t0 + max(sign(f * f0), 0.0) * (t - t0);\n        t1 = t1 - min(sign(f * f0), 0.0) * (t - t1);\n    }\n    return (t0 + t1) / 2.0;\n}\n\nfloat sdEllipse(in vec2 p, in vec2 ab) {\n    float t = precise(p, ab);\n    vec2 c = curve(t, ab);\n    vec2 d = derive(t, ab);\n    float s = sign((p.x - c.x) * d.y - (p.y - c.y) * d.x);\n    return s * distance(p, c);\n}\n#endif\n\nfloat sdEllipticTorus( vec3 p, vec2 t1, vec2 t2 )\n{\n    vec2 r = vec2(sdEllipse(p.xz, t1), p.y);\n    float k0 = length(r/t2);\n    float k1 = length(r/(t2*t2));\n    return sdEllipse(r, t2);//k0*(k0-1.)/k1;\n}\n\n\nfloat sdEllipticTorus2( vec3 p, vec2 t1, vec2 t2 )\n{\n    float majorK0 = length(p.xz/t1);\n    float majorK1 = length(p.xz/(t1*t1));\n    vec2 r = vec2(majorK0*(majorK0-1.)/majorK1, p.y);\n    float minorK0 = length(r/t2);\n    float minorK1 = length(r/(t2*t2));\n    return minorK0*(minorK0-1.)/minorK1;\n}\n\nfloat map(vec3 p){\n    vec3 q = p;\n    vec2 anim = vec2(max(0.,sin(iTime)), max(0.,cos(iTime*2.))) * vec2(1., .25);\n    vec2 anim2 = vec2(max(0.,sin(iTime*.5)), max(0.,cos(iTime*1.))) * vec2(1., .25);\n    vec2 t1 = vec2(.3+anim2.x, .3+anim.x);\n    vec2 t2 = vec2(.1+anim2.y, .1+anim.y);\n    \n    //if(sin(iTime*2.*PI)>0.)\n        return sdEllipticTorus(q, t1, t2);\n    //else\n        //return sdEllipticTorus2(q, t1, t2);\n}\n\nrender();\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//   __  __    __    ____  ____  _____  _  _ \n//  (  \\/  )  /__\\  (  _ \\(_  _)(  _  )( \\/ )\n//   )    (  /(__)\\  )___/  )(   )(_)(  \\  / \n//  (_/\\/\\_)(__)(__)(__)   (__) (_____) (__) \n//\n//  Version: 1.0.4\n//\n//  This is a \"Maptoy\" template.\n//  I wanted an editor dedicated to distance functions, so I created it in Shadertoy.\n//  You can bookmark this page, fork, and edit it.\n//  I've tried to keep everything but the map functions in the Common tab.\n//\n//  Update:\n//\n//  1.0.4 @ 2021/11/03    \n//        - Added Isoline draw.\n//\n//  1.0.3 @ 2021/10/22    \n//        - Added Matcap debug mode.\n//\n//  1.0.2 @ 2021/10/20    \n//        - Added Quad view mode.\n//\n//  1.0.1 @ 2021/10/15    \n//        - Added Axis draw.\n//        - Added Hotkeys for Camera View angle.\n//         ( Numpad-1:Front / Numpad-3:Side / Numpad-7:Top / Numpad-0:Toggle free/fixed )\n//\n//  1.0.0 @ 2021/10/14   \n//        - Released.\n//\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Setting\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n#define THM_BACKGROUND (vec3(0.071,0.071,0.071)*.8)\n#define THM_GRID vec3(0.078,0.078,0.078)\n#define THM_ISOLINE vec3(.2)\n#define THM_ISOMIX .8\n#define THM_GEOM_DARK vec3(0.000,0.000,0.000)\n#define THM_GEOM_LIGHT vec3(0.820,0.820,0.820)\n\n// Matcaps\n#define CURVATURE 0\n#define METAL 0\n#define RED_WAX 1\n\n#define DIST_MIN .001\n#define DIST_MAX 10.\n#define STEP_MAX 100\n\n\n// Utils\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*2.)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R(p, a) p=p*mat2(cos(a),sin(a),-sin(a),cos(a))\nvec2 rot(vec2 p, float r){ R(p, r); return p; }\nvec3 rot(vec3 p, vec3 r){ R(p.xz, r.y), R(p.yx, r.z), R(p.zy, r.x); return p; }\n\n// iYOYi lib: start\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n#define sat(x) clamp(x, 0.0, 1.0)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n#define sign1f(x) ((x>0.) ? 1. : -1.)\n#define sign2v(v) vec2(sign1f(v.x), sign1f(v.y))\n#define linearstep(edge0, edge1, x) min(max((x - edge0) / (edge1 - edge0), 0.0), 1.0)\n// https://stackoverflow.com/questions/26070410/robust-atany-x-on-glsl-for-converting-xy-coordinate-to-angle\n#define atan2(y, x) ((abs(x) > abs(y)) ? PI*.5 - atan(x,y) : atan(y, x))\n\nfloat hash11(float p){\n\tp = fract(p * .1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\nfloat hash13(vec3 p3){\n\tp3  = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx+33.33);\n\treturn fract((p3.xx+p3.yz)*p3.zy);\n}\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yxz+33.33);\n\treturn fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n// https://postd.cc/understanding-perlin-noise/\nfloat gnoise(in vec2 st) {\n\tst *= .75;\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\n\tvec2 u = smoothstep(0., 1., f);\n\n\tvec2 rnd_x0y0 = u2s(hash22(i+vec2(0,0)));\n\tvec2 rnd_x1y0 = u2s(hash22(i+vec2(1,0)));\n\tvec2 rnd_x0y1 = u2s(hash22(i+vec2(0,1)));\n\tvec2 rnd_x1y1 = u2s(hash22(i+vec2(1,1)));\n\n\tvec2 dir_x0y0 = st - (i+vec2(0,0));\n\tvec2 dir_x1y0 = st - (i+vec2(1,0));\n\tvec2 dir_x0y1 = st - (i+vec2(0,1));\n\tvec2 dir_x1y1 = st - (i+vec2(1,1));\n\n\tfloat dot_x0y0 = dot(rnd_x0y0, dir_x0y0);\n\tfloat dot_x1y0 = dot(rnd_x1y0, dir_x1y0);\n\tfloat dot_x0y1 = dot(rnd_x0y1, dir_x0y1);\n\tfloat dot_x1y1 = dot(rnd_x1y1, dir_x1y1);\n\n\tfloat res_x = mix(dot_x0y0, dot_x1y0, u.x);\n\tfloat res_y = mix(dot_x0y1, dot_x1y1, u.x);\n\treturn s2u(mix(res_x, res_y, u.y)*2.);\n}\n// https://www.shadertoy.com/view/3dVXDc\n// Gradient noise by iq (modified to be tileable)\nfloat gnoise(vec3 x, float freq)\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w * w * w * (w * (w * 6. - 15.) + 10.);\n\n    // gradients\n    vec3 ga = hash33(mod(p + vec3(0., 0., 0.), freq));\n    vec3 gb = hash33(mod(p + vec3(1., 0., 0.), freq));\n    vec3 gc = hash33(mod(p + vec3(0., 1., 0.), freq));\n    vec3 gd = hash33(mod(p + vec3(1., 1., 0.), freq));\n    vec3 ge = hash33(mod(p + vec3(0., 0., 1.), freq));\n    vec3 gf = hash33(mod(p + vec3(1., 0., 1.), freq));\n    vec3 gg = hash33(mod(p + vec3(0., 1., 1.), freq));\n    vec3 gh = hash33(mod(p + vec3(1., 1., 1.), freq));\n    \n    // projections\n    float va = dot(ga, w - vec3(0., 0., 0.));\n    float vb = dot(gb, w - vec3(1., 0., 0.));\n    float vc = dot(gc, w - vec3(0., 1., 0.));\n    float vd = dot(gd, w - vec3(1., 1., 0.));\n    float ve = dot(ge, w - vec3(0., 0., 1.));\n    float vf = dot(gf, w - vec3(1., 0., 1.));\n    float vg = dot(gg, w - vec3(0., 1., 1.));\n    float vh = dot(gh, w - vec3(1., 1., 1.));\n\t\n    // interpolation\n    return va + \n           u.x * (vb - va) + \n           u.y * (vc - va) + \n           u.z * (ve - va) + \n           u.x * u.y * (va - vb - vc + vd) + \n           u.y * u.z * (va - vc - ve + vg) + \n           u.z * u.x * (va - vb - ve + vf) + \n           u.x * u.y * u.z * (-va + vb + vc - vd + ve - vf - vg + vh);\n}\n\nfloat voronoi(in vec2 st, in float scl, in float speed, inout vec2 id){\n\tfloat res=1.*scl;\n\tst = u2s(st)*scl;\n\tvec2 ist = floor(st);\n\tvec2 fst = fract(st);\n\tfor(float y=-1.; y<=1.; y+=1.){\n\t\tfor(float x=-1.; x<=1.; x+=1.){\n\t\t\tvec2 gridOffset = vec2(x,y);\n\t\t\tvec2 rnd = hash22(ist+gridOffset+speed*.5);\n\t\t\tfloat d = distance(st, ist+gridOffset+rnd);\n\t\t\tif(d<res){\n\t\t\t\tres = d;\n\t\t\t\tid = rnd;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nfloat voronoi(in vec3 st, in float scl, in float speed, inout vec3 id){\n\tfloat res=1.*scl;\n\tst = u2s(st)*scl;\n\tvec3 ist = floor(st);\n\tvec3 fst = fract(st);\n\tfor(float z=-1.; z<=1.; z+=1.){\n\t\tfor(float y=-1.; y<=1.; y+=1.){\n\t\t\tfor(float x=-1.; x<=1.; x+=1.){\n\t\t\t\tvec3 gridOffset = vec3(x,y,z);\n\t\t\t\tvec3 rnd = hash33(ist+gridOffset+speed*.5);\n\t\t\t\tfloat d = distance(st, ist+gridOffset+rnd);\n\t\t\t\tif(d<res){\n\t\t\t\t\tres = d;\n\t\t\t\t\tid = rnd;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n// fbm base for all noise\n#define fbm_base(nname, n, rep, pers){\\\n\tfloat total = 0.;\\\n\tfloat frequency = 1.;\\\n\tfloat amplitude = 1.;\\\n\tfloat maxValue = 0.;\\\n\tfor(int i=0;i<rep;i++) {\\\n\t\ttotal += nname(vec2(n.x * frequency, n.y * frequency)) * amplitude;\\\n\t\tmaxValue += amplitude;\\\n\t\tamplitude *= pers;\\\n\t\tfrequency *= 2.;\\\n\t}\\\n\tres = total/maxValue;\\\n}\nfloat gfbm(vec2 n, int rep, float pers){\n\tfloat res = 0.;\n\tfbm_base(gnoise, n, rep, pers);\n\treturn res;\n}\nfloat gfbm(vec3 n, int rep, float pers){\n    float G = exp2(-.85);\n    float amp = 1.;\n    float noise = 0.;\n    for (int i = 0; i < rep; ++i)\n    {\n        noise += amp * gnoise(n * pers, pers);\n        pers *= 2.;\n        amp *= G;\n    }\n    \n    return noise;\n}\n\n// Easings\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// \"glsl-easings\": https://github.com/glslify/glsl-easings\nfloat linear(float t){return t;}\nfloat sineInOut(float t){return -0.5 * (cos(PI * t) - 1.0);}\nfloat quadraticInOut(float t){float p = 2.0 * t * t; return t < 0.5 ? p : -p + (4.0 * t) - 1.0;}\nfloat cubicInOut(float t){return t < 0.5 ? 4.0 * t * t * t : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;}\nfloat quarticInOut(float t) {return t < 0.5? +8.0 * pow(t, 4.0): -8.0 * pow(t - 1.0, 4.0) + 1.0;}\nfloat qinticInOut(float t){return t < 0.5 ? +16.0 * pow(t, 5.0) : -0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0;}\nfloat exponentialInOut(float t){return t == 0.0 || t == 1.0 ? t : t < 0.5 ? +0.5 * pow(2.0, (20.0 * t) - 10.0) : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;}\nfloat circularInOut(float t){return t < 0.5 ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t)) : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);}\nfloat elasticInOut(float t){return t < 0.5 ? 0.5 * sin(+13.0 * HALF_PI * 2.0 * t) * pow(2.0, 10.0 * (2.0 * t - 1.0)) : 0.5 * sin(-13.0 * HALF_PI * ((2.0 * t - 1.0) + 1.0)) * pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0;}\nfloat backInOut(float t){float f = t < 0.5 ? 2.0 * t : 1.0 - (2.0 * t - 1.0);float g = pow(f, 3.0) - f * sin(f * PI); return t < 0.5 ? 0.5 * g : 0.5 * (1.0 - g) + 0.5;}\nfloat bounceOut(float t){const float a = 4.0 / 11.0; const float b = 8.0 / 11.0; const float c = 9.0 / 10.0; const float ca = 4356.0 / 361.0; const float cb = 35442.0 / 1805.0; const float cc = 16061.0 / 1805.0; float t2 = t * t; return t < a ? 7.5625 * t2 : t < b ? 9.075 * t2 - 9.9 * t + 3.4 : t < c ? ca * t2 - cb * t + cc : 10.8 * t * t - 20.52 * t + 10.72;}\nfloat bounceInOut(float t){return t < 0.5 ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0)) : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;}\n\n#define CYCLE 4.\n\nfloat swSin(float v){\n    return sin(v*TAU/CYCLE);\n}\nfloat swSqr(float v){\n    return -2.0*(step(0.5,fract(v/CYCLE))-0.5);\n}\nfloat swSaw(float v){\n    return fract(-v/CYCLE)*2.0-1.0;\n}\nfloat swTri(float v){\n    return asin(sin(v*TAU/CYCLE))*2./PI;\n}\n\nfloat uwSin(float v){\n    return s2u(swSin(v));\n}\nfloat uwSqr(float v){\n    return s2u(swSqr(v));\n}\nfloat uwSaw(float v){\n    return s2u(swSaw(v));\n}\nfloat uwTri(float v){\n    return s2u(swTri(v));\n}\n\nfloat uwQuadratic(float v){\n    return quadraticInOut(uwTri(v));\n}\nfloat uwCubic(float v){\n    return cubicInOut(uwTri(v));\n}\nfloat uwQuartic(float v){\n    return quarticInOut(uwTri(v));\n}\nfloat uwQintic(float v){\n    return qinticInOut(uwTri(v));\n}\nfloat uwExponential(float v){\n    return exponentialInOut(uwTri(v));\n}\nfloat uwCircular(float v){\n    return circularInOut(uwTri(v));\n}\nfloat uwElastic(float v){\n    return elasticInOut(uwTri(v));\n}\nfloat uwBack(float v){\n    return backInOut(uwTri(v));\n}\nfloat uwBounce(float v){\n    return bounceInOut(uwTri(v));\n}\n\nfloat swQuadratic(float v){\n    return u2s(uwQuadratic(v));\n}\nfloat swCubic(float v){\n    return u2s(uwCubic(v));\n}\nfloat swQuartic(float v){\n    return u2s(uwQuartic(v));\n}\nfloat swQintic(float v){\n    return u2s(uwQintic(v));\n}\nfloat swExponential(float v){\n    return u2s(uwExponential(v));\n}\nfloat swCircular(float v){\n    return u2s(uwCircular(v));\n}\nfloat swElastic(float v){\n    return u2s(uwElastic(v));\n}\nfloat swBack(float v){\n    return u2s(uwBack(v));\n}\nfloat swBounce(float v){\n    return u2s(uwBounce(v));\n}\n\n\nfloat sabs(float x,float k) {\n\tfloat a = (.5/k)*x*x+k*.5;\n\tfloat b = abs(x);\n\treturn b<k ? a : b;\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r){\n\tfloat k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r){\n\tr*=1.35;\n\tfloat h = max( r-abs(a-b), 0.0 )/r;\n    return min( a, b ) - h*h*h*r*(1.0/6.0);\n}\n\nfloat SMinC3(float a, float b, float r)\n{\n    float n = max(0.0, 1.0 - abs(a - b) / r);\n    \n    float o = (0.25 - n*0.1) * ((n*n)*(n*n));\n    \n    return min(a, b) - o*r;\n}\n\nfloat fOpSubstractionSmooth( float a,float b,float r){\n\tvec2 u = max(vec2(r + b,r + -a), vec2(0));\n\treturn min(-r, max (b, -a)) + length(u);\n}\n\nfloat voronoiSmooth(vec2 p, float s)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    float res = 8.;\n    for(int j=-1; j<=1; j++)\n    for(int k=-1; k<=1; k++)\n    {\n        vec2 b = vec2(j,k);\n        vec2 r = b-f+hash22(i+b);\n\n        float d = length( r );\n        res = SMinC3( res, d, s );\n    }\n    return res;\n}\n\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n// iYOYi lib: end\n\n// Borrowed from \"Infinite 3D Grid Planes\" by peepsalot:\n// https://www.shadertoy.com/view/Ndy3Rm\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat plane( in vec3 ro, in vec3 rd, in vec4 p ){\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat grid(in vec2 p, in vec2 dpdx, in vec2 dpdy, float N){\n    const float scl = 0.5;\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 1.0 / N - w; // see \n    vec2 b = p - w;\n    vec2 i = clamp(\n      ( floor(a) + min(fract(a) * N, 1.0)\n       -floor(b) - min(fract(b) * N, 1.0)\n      ) / (N*w)\n      , vec2(0), vec2(1));\n    return (1.0 - i.x) * (1.0 - i.y);\n}\nfloat grid_lookup(in vec3 ro, in vec3 rd, float resDist, in vec4 pln, float scale, float lineRatio){\n    float t = plane(ro, rd, pln);\n    if (t > 0.0 && t<resDist)\n    {\n        vec3 p = (ro + t * rd);\n        vec2 uv = scale*(p.yz * pln.x + p.xz * pln.y + p.xy * pln.z);\n        return clamp(1.0 - grid(uv, dFdx(uv), dFdy(uv), 2.0 * lineRatio), 0.0, 1.0);\n    } else {\n        return 0.0;\n    }\n}\n\n// https://iquilezles.org/articles/intersectors\n// infinite cylinder defined by a base point cb, a normalized axis ca and a radious cr\nvec2 cylIntersect( in vec3 ro, in vec3 rd, in vec3 cb, in vec3 ca, float cr )\n{\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0); //no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\n\n\n// \"iResolution, iMouse, iDate, etc\" by FabriceNeyret2:\n// https://www.shadertoy.com/view/llySRh\n// --- chars\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc col+= char(U,64+CAPS+c).rgb;\n#define _a 1\n#define _b 2\n#define _c 3\n#define _d 4\n#define _e 5\n#define _f 6\n#define _g 7\n#define _h 8\n#define _i 9\n#define _j 10\n#define _k 11\n#define _l 12\n#define _m 13\n#define _n 14\n#define _o 15\n#define _p 16\n#define _q 17\n#define _r 18\n#define _s 19\n#define _t 20\n#define _u 21\n#define _v 22\n#define _w 23\n#define _x 24\n#define _y 25\n#define _z 26\n\n// render(): general ray marching code.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat cost = 0.;\n#define C_MOUSE vec2(0,0)\n#define C_CAMERA vec2(1,0)\n#define C_MOUSE_VEC vec2(2,0)\n#define C_MOUSE_POS vec2(3,0)\n#define CAM_DIST 2.\n#define render() \\\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \\\nvec4 char(vec2 p, int c) {\\\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\\\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) /* thighly y-clamped to allow dense text*/\\\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\\\n    return vec4(0);\\\n}\\\nvec4 draw_char() {\\\n    int c = char_id; vec2 p = char_pos;\\\n    return (c < 0)? vec4(0,0,0,1e5) : textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );\\\n}\\\nvec4 fetch(vec2 coord){\\\n    return texelFetch(iChannel0, ivec2(coord), 0);\\\n}\\\nstruct Ray{\\\n\tvec3 origin;\\\n\tvec3 direction;\\\n}ray;\\\nvec3 calcNormal(vec3 p){\\\n  vec3 n=vec3(0);\\\n  for(int i=0; i<4; i++){\\\n    vec3 e=DIST_MIN*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\\\n    n+=e*map(p+e);\\\n  }\\\n  return normalize(n);\\\n}\\\n/* Camera localized normal*/\\\nvec3 campos, camup;\\\nvec3 localNormal(vec3 p) {\\\n    vec3 n = calcNormal(p), ln;\\\n    vec3 side = cross(campos, camup);\\\n    return vec3(dot(n,  side), dot(n,  camup), dot(n,  -ray.direction));\\\n}\\\nfloat march(vec3 ro, vec3 rd){\\\n    float t=DIST_MIN, d;\\\n    for(int i=0; i<STEP_MAX; i++)\\\n    {\\\n        t+=d=map(ro+rd*t);\\\n        if (d<DIST_MIN) return t;\\\n        if (t>DIST_MAX) return DIST_MAX;\\\n        cost++;\\\n    }\\\n    return DIST_MAX;\\\n}\\\nvec2 forceView = vec2(0);\\\nvoid setupRay(vec2 uv){\\\n\tvec3 up = vec3(0,1,0);\\\n    vec3 pos = normalize(vec3(1)) * CAM_DIST;\\\n    if(sign(iMouse.z)>.0 && (forceView.x<.5))\\\n        pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y<.5 && bool(TURN_TABLE))\\\n        pos = normalize(vec3(sin(iTime*TURN_TABLE_SPEED), -1, cos(iTime*TURN_TABLE_SPEED))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y>.5 || forceView.x>.5){\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) pos = vec3(0,0,1) * CAM_DIST;/*FRONT*/\\\n        if(num==3) pos = vec3(-1,0,0) * CAM_DIST;/*SIDE(LEFT)*/\\\n        if(num==7) {up=vec3(0,0,1); pos = vec3(0,-1,0) * CAM_DIST;/*TOP*/\\\n        if(num==0) pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;}\\\n    }\\\n    else {\\\n        vec4 mou = abs(texelFetch(iChannel0, ivec2(C_MOUSE), 0));\\\n        pos = normalize(vec3(sin(mou.x/iResolution.x*PI*2.), (mou.y/iResolution.y-.5)*4., cos(mou.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    }\\\n    vec3 cw = normalize(-pos);\\\n    vec3 cu = normalize(cross(cw, up));\\\n    vec3 cv = normalize(cross(cu, cw));\\\n    campos = cw, camup = cv;\\\n\tuv *= CAM_SCALE/CAM_DIST;\\\n\tfloat perspective = 1.5;\\\n\tfloat fv = acos(dot(cw, normalize(cu * uv.x)));\\\n\tfloat screenSize = (CAM_DIST*perspective / (2.0 * tan(abs(fv) / 2.0)));\\\n\tvec3 virtscreen = pos + cw * 2.0 + (cu * uv.x + cv * uv.y) * screenSize;\\\n\tray.origin = -pos + (cu * uv.x + cv * uv.y) * (0.7 + 0.2 * perspective) * screenSize;\\\n\tray.direction = normalize(virtscreen - ray.origin);\\\n}\\\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\\\n{\\\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\\\n}\\\nvec3 renderRect(vec2 fragCoord){\\\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y, U;\\\n    setupRay(uv);\\\n    vec3 col= THM_BACKGROUND;\\\n    float t= march(ray.origin, ray.direction);\\\n    if(t<DIST_MAX){\\\n        vec3 p = ray.origin + ray.direction * t;\\\n        col = vec3(.5);\\\n        vec3 n = localNormal(p);\\\n\t\tvec3 lightPos = vec3(-2,2,-2);\\\n    \tvec3 li = normalize(lightPos-p);\\\n\t\tfloat dif = dot(n,li)*.5+.5;\\\n        col = mix(THM_GEOM_DARK, THM_GEOM_LIGHT, dif);\\\n        if(bool(DBG_NORMAL))col = (n*.5+.5)*.5;\\\n        if(bool(DBG_MATCAP)){\\\n            float depth = distance(ray.origin, p);/*/DIST_MAX;*/\\\n            n = localNormal(p);\\\n            /* Compute curvature */\\\n            vec3 dx = dFdx(n);\\\n            vec3 dy = dFdy(n);\\\n            vec3 xneg = n - dx;\\\n            vec3 xpos = n + dx;\\\n            vec3 yneg = n - dy;\\\n            vec3 ypos = n + dy;\\\n            float sgn = (dot(localNormal(p),vec3(1,0,0))>0.)? 1. : -1.;\\\n            float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x) * 4.0 / depth;\\\n            /* Compute surface properties */\\\n            if(bool(CURVATURE)){\\\n                vec3 light = vec3(0.0);\\\n                vec3 ambient = vec3(curvature + 0.5);\\\n                vec3 diffuse = vec3(0.0);\\\n                vec3 specular = vec3(0.0);\\\n                float shininess = 0.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(bool(METAL)){\\\n                float corrosion = clamp(-curvature * 3.0, 0.0, 1.0);\\\n                float shine = clamp(curvature * 5.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.15, 0.1, 0.1)*.5;\\\n                vec3 diffuse = mix(mix(vec3(0.3, 0.25, 0.2), vec3(0.45, 0.5, 0.5), corrosion),\\\n                vec3(0.5, 0.4, 0.3), shine) - ambient;\\\n                vec3 specular = mix(vec3(0.0), vec3(1.0) - ambient - diffuse, shine);\\\n                float shininess = 128.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(bool(RED_WAX)){\\\n                float dirt = clamp(0.25 - curvature * 4.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.05, 0.015, 0.0);\\\n                vec3 diffuse = mix(vec3(0.4, 0.15, 0.1), vec3(0.4, 0.3, 0.3), dirt) - ambient;\\\n                vec3 specular = mix(vec3(0.15) - ambient, vec3(0.0), dirt);\\\n                float shininess = 32.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }\\\n            col = pow(col, vec3(2.));\\\n        }\\\n    }\\\n    float gsi = 2.;\\\n    float gsf = 10.;\\\n    float gli = 50.;\\\n    float glf = 20.;\\\n    float gx = max(grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsi, gli));\\\n    float gz = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsi, gli));\\\n    float gy = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsi, gli));\\\n    vec3 g=vec3(0);\\\n    if(bool(UI_GRID_2D))\\\n        g = vec3(gz);\\\n    if(iMouse.z<.5 && (fetch(C_CAMERA).y>.5 || bool(UI_GRID_3D) || forceView.x>.5))\\\n        g = vec3(gx+gy+gz)*.333;\\\n    if(bool(DBG_COST))\\\n        col.r+=cost/float(STEP_MAX);\\\n    col = mix(col, THM_GRID, g);\\\n    if(bool(UI_ISOLINE)) {\\\n        vec4 n;\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) n = vec4(0,0,1,0);\\\n        if(num==7) n = vec4(0,1,0,0);\\\n        if(num==3) n = vec4(1,0,0,0);\\\n        if(num==0) n = vec4(0,1,0,0);\\\n        float pd = plaIntersect(ray.origin, ray.direction, normalize(n));\\\n        float inpd = map(ray.origin + ray.direction * pd);\\\n        float major = smoothstep(.0051, .005, abs(mod(inpd, 1.)-.5));\\\n        float minor = smoothstep(.0051, .005, abs(mod(inpd+.05, .1)-.05));\\\n        col = mix(col, THM_BACKGROUND*.5, (1.-float(pd<t))*THM_ISOMIX);\\\n        col = mix(col, vec3(.35)*col, step(0., -inpd));\\\n        col = mix(col, mix(col, vec3(THM_ISOLINE), mix(major, minor, .333)), .9);\\\n    }\\\n    col = pow(col, vec3(.4545));\\\n    if(bool(UI_AXIS)){\\\n        float at = .005;\\\n        float axisX = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(1,0,0), at).x;\\\n        if(axisX>0. && (bool(UI_ISOLINE) || axisX<t))col=vec3(0.451,0.145,0.110);\\\n        float axisY = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,1,0), at).x;\\\n        if(axisY>0. && (bool(UI_ISOLINE) || axisY<t))col=vec3(0.267,0.471,0.129);\\\n        float axisZ = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,0,1), at).x;\\\n        if(axisZ>0. && (bool(UI_ISOLINE) || axisZ<t))col=vec3(0.267,0.424,0.671);\\\n    }\\\n    U = ( fragCoord/iResolution.y - vec2(0, (1.-.075)) ) * 20.;\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    if(num==1){caps C(_f) low C(_r)C(_o)C(_n)C(_t) caps C(-6)}\\\n    if(num==7){caps C(_t) low C(_o)C(_p) caps C(-6)}\\\n    if(num==3){caps C(_s) low C(_i)C(_d)C(_e) caps C(-6)}\\\n    if(num==0){caps C(_f) low C(_r)C(_e)C(_e) caps C(-6)}\\\n    col = mix(col, pow(vec3(.8),vec3(.4545)), draw_char().xxx);\\\n    return col;\\\n}\\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\\\n    if(bool(VIEW_QUAD)){\\\n        vec3 Res = vec3(iResolution.xy, 0);\\\n        forceView = vec2(1,1);\\\n        if(fragCoord.x<Res.x*.5-2. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,1);fragColor = vec4(renderRect(fragCoord*2.-Res.zz),1);}\\\n        else if(fragCoord.x<Res.x*.5-2. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(1,7);fragColor = vec4(renderRect(fragCoord*2.-Res.zy),1);}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,3);fragColor = vec4(renderRect(fragCoord*2.-Res.xz),1);}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(0,0);fragColor = vec4(renderRect(fragCoord*2.-Res.xy),1);}\\\n        else fragColor = vec4(pow(THM_GRID,vec3(.4545)),1);\\\n    }else{\\\n        fragColor = vec4(renderRect(fragCoord),1);\\\n    }\\\n}int dummy\\\n\n", "buffer_a_code": "// References:\n// \"Special Shadertoy features\" by Fabrice: https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\n// \"keyboard debugging\" by mattz: https://www.shadertoy.com/view/4dGyDm\n// \"Input - Keyboard\" by iq: https://www.shadertoy.com/view/lsXGzf\n// \"Input - Mouse\" by iq: https://www.shadertoy.com/view/Mss3zH\n\n// Shows how to use the mouse input (only left button supported):\n//\n//      mouse.xy  = mouse position during last button down\n//  abs(mouse.zw) = mouse position during last button click\n// sign(mouze.z)  = button is down\n// sign(mouze.w)  = button is clicked\n\nconst int K_NUMP_0 = 96;\nconst int K_NUMP_1 = 97;\nconst int K_NUMP_2 = 98;\nconst int K_NUMP_3 = 99;\nconst int K_NUMP_4 = 100;\nconst int K_NUMP_5 = 101;\nconst int K_NUMP_6 = 102;\nconst int K_NUMP_7 = 103;\nconst int K_NUMP_8 = 104;\nconst int K_NUMP_9 = 105;\n\n#define ID(c) (distance(C, c)<1.)\n#define getState(k)    ((texelFetch( iChannel0, ivec2(k, 0), 0 ).x)>.5)\n#define getKeypress(k) ((texelFetch( iChannel0, ivec2(k, 1), 0 ).x)>.5)\n#define getToggle(k)   ((texelFetch( iChannel0, ivec2(k, 2), 0 ).x)>.5)\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 2 ) {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    vec2 C = fragCoord;\n    vec4 last = texelFetch(iChannel1, ivec2(C), 0);\n    \n    if(ID(C_MOUSE)){\n    \n        // Mouse\n        if(sign(iMouse.z)>.0)\n            fragColor = iMouse;\n        else\n            fragColor = last;\n        return;\n        \n    }\n    else\n    if(ID(C_CAMERA)){\n    \n        // Numpad\n        fragColor = last;\n        bool isFreeCamera = bool(last.y);\n        \n        if(getKeypress(K_NUMP_0) && sign(iMouse.z)<=.0)fragColor = vec4(last.x, !isFreeCamera, 0, 0);\n        \n        //if(getState(K_NUMP_0))fragColor = vec4(0, true, 0, 0);\n        if(getState(K_NUMP_1))fragColor = vec4(1, true, 0, 0);\n        //if(getState(K_NUMP_2))fragColor = vec4(2, true, 0, 0);\n        if(getState(K_NUMP_3))fragColor = vec4(3, true, 0, 0);\n        //if(getState(K_NUMP_4))fragColor = vec4(4, true, 0, 0);\n        //if(getState(K_NUMP_6))fragColor = vec4(6, true, 0, 0);\n        if(getState(K_NUMP_7))fragColor = vec4(7, true, 0, 0);\n        //if(getState(K_NUMP_8))fragColor = vec4(8, true, 0, 0);\n        //if(getState(K_NUMP_9))fragColor = vec4(9, true, 0, 0);\n        return;\n        \n    }\n    else\n    {\n        // Blank\n        fragColor = vec4(0.0,0.0,1.0,1.0);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tdGDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3196, 3196, 3247, 3247, 3402], [3405, 3405, 3457, 3457, 3706], [3708, 3708, 3726, 3726, 4131]], "test": "untested"}
{"id": "std3Wn", "name": "Weaving Bridges", "author": "Plento", "description": "An endless weaving highway, with no exits. Mouse controls zoom.", "tags": ["2d", "mouse", "road", "car", "weave"], "likes": 38, "viewed": 622, "published": 3, "date": "1636018100", "time_retrieved": "2024-07-30T18:50:37.305730", "image_code": "// Cole Peterson (Plento)\n\n// An endless weaving highway, with no exits. Mouse controls zoom.\n\n#define R iResolution.xy\n#define m ((iMouse.xy - .5*R.xy) / R.y)\n#define ss(a, b, x) smoothstep(a, b, x)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n#define w_scale 5.\n#define car_size vec2(0.07, 0.1)\n\n// Dave Hoshkin\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hsh(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n// Standard perlin\nfloat perlin(vec2 p){\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    float a = hsh(i);\n    float b = hsh(i+vec2(1., .0));\n    float c = hsh(i+vec2(0. ,1 ));\n    float d = hsh(i+vec2(1., 1. ));\n    \n    vec2 u = smoothstep(0., 1., f);\n    \n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// box sdf\nfloat box( in vec2 p, in vec2 b, float r){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\n// is a cell be flipped or not\nbool flipped(vec2 id){\n    float rnd = hash12(id*200.);\n    if(rnd > .5) return true;\n    \n    return false;\n}\n\n\nvec3 car(vec3 col, vec2 uv, vec2 uid){\n    uv.y *= .6; // stretch in direction of travel so they have more room to move in their cell\n    \n    float spd = iTime*.1;\n    \n    // Repeated uvs for cars (We only draw one)\n    vec2 cm = vec2(0., spd );\n    vec2 cv = fract((uv-cm)*w_scale*2.)-0.5;\n    vec2 id = floor((uv-cm)*w_scale*2.);\n    float idc = floor((uv.x-cm.x)*w_scale);\n    \n    // Switch direction \"randomly\"\n    if(cos(idc*2.) > 0.){\n        cm = vec2(0., -spd );\n        cv = fract((uv-cm)*w_scale*2.)-0.5;\n        id = floor((uv-cm)*w_scale*2.);\n    }\n    \n    if(int(id.y) % 7 == 0) return col; // Leave some cells empty\n    \n    // Make cars move down road in somewhat non uniform way\n    float t = id.y*114. + id.x*116.;\n    vec2 p = vec2(.0, .3*cos(iTime*1. + t));\n    \n    // Adjust car position based on side of road\n    if(int(id.x) % 2 == 0) p.x -= .2; \n    else p.x += .2;\n    \n    cv += p;\n    float cars = ss(.01, .0, box(cv, car_size, .03)); // Car mask\n    \n    // Car color\n    float ct = (id.x*3. + id.y*5.);\n    vec3 carCol = .5+.26*cos(vec3(4., 2., 1.)*ct + vec3(3., 4., 7.));\n    carCol *= max(ss(-.1, .21, abs(cv.y + .07)), .45);\n    carCol += .16*ss(0.055, 0.01, abs(cv.y));\n    \n    // Randomly add some variation\n    if(cos(ct) > 0.){\n        carCol *= max(abs(cos(ct)), .6);\n        carCol = mix(carCol, .6*vec3(.75, .85, .99), .7*ss(.3, .2, abs(cv.y*2. - .38)));\n    }\n   \n    // Shadow under car\n    float shdw = max(ss(-.08, .08, box(cv-vec2(0., .01), car_size+vec2(.015, .01), .03)), .3);\n    \n    return mix(col * shdw, carCol, cars) + vec3(0., 0., 0.);\n}\n\n\nvec3 road(vec2 uv, float y){\n    float rd = ss(.02, .00, abs(uv.x)); // road mask\n    rd *= ss(.25, .35, abs(fract(y*14.)-.5)); // road line\n    float bdg = ss(.35, .37, abs(uv.x)); // bridge mask\n    float shdw = ss(.49, .18, abs(uv.x)); // bridge shadow\n    \n    float nse = perlin(uv*45.); // perlin noise\n    float rc = clamp(nse*.4, .22, .24); // road color\n    float bc = clamp(nse, .46, .5); // bridge color\n    return mix(shdw * mix(vec3(rc), vec3(1), rd), vec3(bc), bdg);\n}\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec2 cv = uv;\n    uv *= 0.99 + (1.3+.2*sin(iTime*.7))*0.77;\n    \n    if(iMouse.z > 0.)\n        uv *= max(0.3, (m.y+.4)*2.5);\n    \n    uv*=rot(-0.3);\n    uv += iTime*.1;\n   \n    // Road uvs\n    vec2 ruv = fract(uv*w_scale)-.5;\n    vec2 id = floor(uv*w_scale);\n    \n    vec3 col = vec3(1);\n    \n    // rotate uv 90 degree based on cell\n    float rnd = hash12(id*200.);\n    if(flipped(id)){\n        ruv = vec2(ruv.y, -ruv.x);\n        uv = vec2(uv.y, -uv.x);\n    }\n    \n    // cell containing current pixel flipped status\n    bool me = flipped(id);\n    \n    // main color\n    col = road(ruv, uv.y);\n    col = car(col, uv, id);\n    \n    // neighbooring cells flipped?\n    bool lft = flipped(id + vec2(-1., 0.));\n    bool rgt = flipped(id + vec2(1., 0.));\n    bool up = flipped(id + vec2(0., 1.));\n    bool dwn = flipped(id + vec2(0., -1.));\n    \n    // Add a shadow based on surrounding cells\n    if(me && !lft) col *= ss(.78, .12, (ruv.y));\n    if(me && !rgt) col *= ss(.78, .12, (-ruv.y));\n    if(!me && up) col *= ss(.78, .12, (ruv.y));\n    if(!me && dwn) col *= ss(.78, .12, (-ruv.y));\n    \n    col = pow(col*1.2, vec3(1.1));\n    \n    // intro thingy\n    float r = min(iTime, 3.);\n    if(iTime < 3.) col *= ss(r, r-.01, length(cv));\n    f = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/std3Wn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[307, 323, 344, 344, 461], [462, 462, 480, 480, 597], [598, 617, 638, 638, 944], [946, 957, 999, 999, 1083], [1085, 1116, 1138, 1138, 1226], [1229, 1229, 1267, 1267, 2824], [2827, 2827, 2855, 2855, 3309], [3312, 3312, 3352, 3352, 4654]], "test": "untested"}
{"id": "7ttGDn", "name": "Lava planet shader", "author": "pancakespeople", "description": "A modification of my planet shader to make a lava planet", "tags": ["lavaplanet"], "likes": 7, "viewed": 557, "published": 3, "date": "1636017494", "time_retrieved": "2024-07-30T18:50:38.068690", "image_code": "#define NUM_OCTAVES 5\n\nvec2 random2(vec2 st) {\n\tst = vec2(dot(st, vec2(127.1, 311.7)),\n\t\tdot(st, vec2(269.5, 183.3)));\n\treturn -1.0 + 2.0 * fract(sin(st) * 43758.5453123 * 0.7897);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n\treturn mix(mix(dot(random2(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),\n\t\tdot(random2(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x),\n\t\tmix(dot(random2(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\n\t\t\tdot(random2(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n\tmat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.7;\n\t}\n\treturn v;\n}\n\nmat2 rotate(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x * 4.0;\n    vec3 sph = vec3(uv.x, uv.y, cos(length(uv)));\n\n    float r = length(uv);\n\tfloat f = (1.0 - sqrt(1.0 - r)) / r;\n    vec3 sunPos = vec3(cos(iTime / 4.0), 0.0, sin(iTime / 4.0));\n    float light = dot(sph, sunPos);\n    float reflectivity = 1.0;\n\n    float noiseVal = fbm((uv * f * 5.0) + 500.0) + 0.5;\n    float cloudNoise = fbm((uv * f * 2.0 + vec2(-iTime / 8.0, 0.0)) + 1000.0) + 0.5;\n    //cloudNoise *= rotate(iTime);\n    vec3 col = vec3(0.0);\n    \n    if (r < 1.0) {\n        if (noiseVal < 0.35) {\n            col = vec3(1.0, 0.0, 0.0);\n            light = 0.5;\n        }\n        else if (noiseVal > 0.65) {\n            col = vec3(1.0, 1.0, 1.0) * noiseVal;\n        }\n        else {\n            col = vec3(noiseVal / 4.0, noiseVal / 4.0, noiseVal / 4.0);\n        }\n        reflectivity = noiseVal * 2.0;\n        //col += smoothstep(0.55, 0.6, cloudNoise);\n    }\n    else {\n        col = vec3(0.8, 0.3, 0.3) * smoothstep(1.1, 1.0, r);\n        reflectivity = 0.5;\n    }\n    \n    col *= light;\n    col += smoothstep(1.1, 1.0, r) * light * reflectivity * vec3(1.0, 0.5, 0.5);\n    \n    vec2 suv = uv - sunPos.xy * 3.0;\n    col += 0.1 / length(suv) * smoothstep(0.99, 1.0, r) * smoothstep(0.5, 0.8, -sunPos.z);\n    \n    float flareCol = 0.0;\n    vec2 fuv = suv;\n    float angle = atan(fuv.y, fuv.x) + 3.14159 / 8.0;\n    flareCol += 0.1/abs(sin(angle*4.0)*cos(angle*4.0)) * smoothstep(0.6, 0.0, length(fuv));\n    flareCol *= 0.1/abs(sin(angle*2.0)*cos(angle*2.0)) * smoothstep(0.6, 0.0, length(fuv));\n    //flareCol += 0.01 / abs(fuv.x*fuv.y) * smoothstep(1.0, 0.5, length(fuv)) / 4.0;\n    //fuv *= rotate(3.14159 / 4.0);\n    //flareCol += 0.01 / abs(fuv.x*fuv.y) * smoothstep(1.0, 0.5, length(fuv)) / 16.0;\n\n    flareCol *= smoothstep(0.7, 0.8, -sunPos.z);\n    flareCol *= smoothstep(0.99, 1.0, length(uv-suv));\n    //flareCol *= smoothstep(0.99, 1.0, r);\n    if (light < 0.01 && r < 1.0) col = vec3(0.0);\n    col += flareCol;\n    \n    col += smoothstep(0.75, 0.0, noiseVal) * vec3(1.0, 0.0, 0.0);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ttGDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 46, 46, 182], [184, 269, 291, 291, 633], [635, 635, 654, 654, 922], [924, 924, 950, 950, 1034], [1036, 1036, 1093, 1143, 3269]], "test": "untested"}
{"id": "Ntt3Dr", "name": "QR Code", "author": "xZAKHAMx", "description": "A QR Code Generator.\nMy code is too bad. sorry :D", "tags": ["qrcode", "microtiles"], "likes": 6, "viewed": 409, "published": 3, "date": "1636013383", "time_retrieved": "2024-07-30T18:50:38.835640", "image_code": "\n\nfloat square(in float valx, in float valy, in float eps)\n{\n    vec2 comp = vec2(0.0);\n    if (valx < eps && valx > -eps) comp.x = 1.0;\n    if (valy < eps && valy > -eps) comp.y = 1.0;\n\n    return comp.x*comp.y;\n}\n\nfloat noise(in vec2 uv, in float seed)\n{\n    float gr = 1.618;\n    return fract(tan(distance(uv*gr, uv)*seed)*uv.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n    vec2 res = vec2(1.80, 1.00);\n    vec2 porg  = (-1.0 + 2.0*uv)*res;\n    vec2 p = abs((-1.0 + 2.0*uv)*res);\n    \n    \n    float seed = float(ceil(2.0*iTime+1.0));\n    float scale = 40.0;\n    float bias = 0.5;\n    float sr1 = 3.0;\n    float sr2 = sr1+2.0;\n    float sr3 = sr2+2.0;\n    float sr4 = sr3+2.0;\n    float srk1 = 1.0;\n    float srk2 = srk1+2.0;\n    float srk3 = srk2+2.0;\n    float div = 1.0/scale;\n    float mult1 = div*sr1;\n    float mult2 = div*sr2;\n    float mult3 = div*sr3;\n    float mult4 = div*sr4;\n    float multk1 = div*srk1;\n    float multk2 = div*srk2;\n    float multk3 = div*srk3;\n    float move = sr4;\n    float movek = srk3+20.0;\n    vec3 colp = vec3(0.0);\n\n\n    vec2 newUV = vec2 (uv.x*res.x, uv.y*res.y)*scale;\n    newUV = ceil(newUV);\n    float pix = float(noise(newUV, seed));\n\n    if (pix > bias) colp = vec3(1.0);\n    \n    float m = square(porg.x-res.x+1.0,\n                     porg.y+res.y, 1.0);\n    \nfloat k1 = square(porg.x-(res.x-div*movek),\n                       porg.y-(-res.y+div*movek), multk1);\nfloat k2 = square(porg.x-(res.x-div*movek),\n                       porg.y-(-res.y+div*movek), multk2);\nfloat k3 = square(porg.x-(res.x-div*movek),\n                       porg.y-(-res.y+div*movek), multk3);\n                       \n    \n    float sq1 = square(p.x-(res.x-div*move),\n                       p.y-(res.y-div*move), mult1);\n    float sq2 = square(p.x-(res.x-div*move),\n                       p.y-(res.y-div*move), mult2);\n    float sq3 = square(p.x-(res.x-div*move),\n                       p.y-(res.y-div*move), mult3);\n    float sq4 = square(p.x-(res.x-div*move),\n                       p.y-(res.y-div*move), mult4);\n    \n                       \n    \n    \n     vec3 cols = vec3(sq4-sq3+sq2-sq1);\n     vec3 colsm = 1.0 -vec3 (k3-k2+k1);\n     float mask = clamp(sq4 - m, 0.0, 1.0);\n     vec3 col = mix(colp, cols, mask);\n     col = mix(col, colsm, k3);\n\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntt3Dr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 60, 60, 214], [216, 216, 256, 256, 334], [336, 336, 393, 393, 2371]], "test": "untested"}
{"id": "stdGWn", "name": "Moving RGB Squares", "author": "ersteller", "description": "Moving RGB squares. \n\nSome squares colored based on pixel position value and time. \n\nThis is for learning.\n\n", "tags": ["pixel", "rgb", "background", "moving", "art", "squares"], "likes": 2, "viewed": 204, "published": 3, "date": "1636011479", "time_retrieved": "2024-07-30T18:50:39.618546", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float r = 0.;\n    float g = 0.;\n    float b = 0.;\n   \n    if (    bool(int(fragCoord.x+iTime*10.)&16)\n         && bool(int(fragCoord.y)&16))\n    {\n        r = 1.;\n    }\n    \n    if (    bool(int(fragCoord.x+fragCoord.y)&32)\n         && bool(int(fragCoord.y-fragCoord.x)&32))\n    {\n        g = 1.;\n    }\n    if (    bool(int(fragCoord.x)&64)\n         && bool(int(fragCoord.y+iTime*15.)&64))\n    {\n        b = 1.;\n    }\n    \n    vec3 col = vec3(r,g,b);\n       \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdGWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 578]], "test": "untested"}
{"id": "sttGWn", "name": "Eyelord", "author": "nrosquist", "description": "Something", "tags": ["moire"], "likes": 1, "viewed": 201, "published": 3, "date": "1636010012", "time_retrieved": "2024-07-30T18:50:40.476253", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n//    float d = pow(uv.x,.2) + pow(uv.y,2.) - mod(iTime,4.)/8.0;\n    float d = (length(uv))-.8;\n    d = smoothstep(.13,.3+sin(iTime)*col.z,cos(mod(iTime/20.,d))-col.y);\n    // Output to screen\n    fragColor = vec4(vec3(d,col.y, col.z),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sttGWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 534]], "test": "untested"}
{"id": "ftc3Wn", "name": "LogPolar QuadTree", "author": "byt3_m3chanic", "description": "Very basic design - Going another step into the Quadtree explorations, and who doesn't enjoy love a good log-polar transform! ", "tags": ["warp", "log", "quadtree"], "likes": 60, "viewed": 972, "published": 3, "date": "1636008823", "time_retrieved": "2024-07-30T18:50:41.374850", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Draft Quadtree [learning number 3]\n    11/4/21 @byt3_m3chanic\n\n    throwing it into a log polar transform.\n    It's hard to make the design more complex and \n    still look good as it scales, but this was \n    just poking around to see what else you can do.\n    \n    @Shane has a good example that explains quadtrees\n    which is what I used to create this shader.\n    https://www.shadertoy.com/view/llcBD7\n \n*/\n\n#define R          iResolution\n#define M          iMouse\n#define T          iTime\n#define PI         3.14159265359\n#define PI2        6.28318530718\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4324.23); }\n\nvec3 hue(float t){ \n    const vec3 d = vec3(0.067,0.812,0.910);\n    return .55 + .45*cos(PI2*t*(vec3(.95,.97,.98)*d)); \n}\n\nfloat box( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec2 vuv= uv*rot(T*.05);\n\n    vuv=vec2(log(length(vuv)), atan(vuv.y, vuv.x))*3.5;\n    vuv.x+=T*.25;\n    \n    float px = fwidth(vuv.x);\n    float level=1.;\n\n    vec3 C = vec3(.0325);\n    float mask = smoothstep(.65,.0,length(uv)-.2);\n    C = mix(C, vec3(.125),mask);\n    \n    for(int k=0; k<5; k++){\n        vec2 id = floor(vuv*level);\n        float rnd = hash21(id);\n        \n        // threshold or if last loop\n        if(rnd>.45||k>3) {\n\n            vec2 p = vuv -(id+.5)/level;\n            rnd = hash21(rnd+id.yx);\n\n            float d = smoothstep(px,-px,length(p)-.455/level);\n            float s = length(p)-.425/level;\n \n            if(rnd<.675) {\n                if(rnd>.2) s=abs(s)-.05/level;\n                s = smoothstep(px,-px,s);\n                C=mix(C,hue((id.y*.05)+float(k+1)*.25),s);\n            } else {\n                C=mix(C,vec3(.2),d);\n                            \n                if(hash21(rnd+id)>.8) {\n                    p*=rot(rnd+T*.5);\n                    vec2 cs = vec2(.3,.075)/level;\n                    float cx=min(box(p,cs.yx),box(p,cs));\n                    C=mix(C,vec3(.8),smoothstep(px,-px,cx));\n                }\n            }\n\n            break;\n        }\n        level*=2.;\n    }\n    \n    C = pow(C, vec3(.4545));        \n    O = vec4(C,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftc3Wn.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[659, 659, 679, 679, 724], [725, 725, 746, 746, 801], [803, 803, 821, 821, 924], [926, 926, 960, 960, 1040], [1042, 1042, 1083, 1083, 2422]], "test": "untested"}
{"id": "flt3Wr", "name": "SandStorm", "author": "wyatt", "description": "Just a lot of em'", "tags": ["sand"], "likes": 31, "viewed": 469, "published": 3, "date": "1636006309", "time_retrieved": "2024-07-30T18:50:42.276440", "image_code": "// Display 🦜\nMain {\n    vec4 b = B(U);\n    Q = b*b.wwww;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define ei(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define Z .5\nvec3 hash(vec3 p3)\n    {\n        p3 = fract(p3 * vec3(.1031, .1030, .0973));\n        p3 += dot(p3, p3.yxz+33.33);\n        return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n    }\n    ", "buffer_a_code": "// Translate Particles 🚗\nMain {\n    Q = vec4(0);\n    vec4 QB = vec4(0);\n    for (float x=-2.;x<=2.;x++)\n    for (float y=-2.;y<=2.;y++)\n    {\n          vec2 xy = vec2(x,y);\n          vec4 b = B(U+xy);\n          if (b.w>0.) {\n              vec4 a = A(U+xy);\n              \n              vec4 _1 = a, _2 = a;\n              mat2 m = ei(6.2*hash(vec3(U+xy,iTime)).x);\n              if (b.w>1.) {\n                  vec2 v = vec2(0,Z)*m;\n                  _2.xy -= v;\n                  _1.xy += v;\n              }\n              if (_1.x<U.x+.5&&_1.x>=U.x-.5&&\n                  _1.y<U.y+.5&&_1.y>=U.y-.5){\n                  Q += .5*b.w*_1;\n                  QB.w += .5*b.w; \n              }\n              if (_2.x<U.x+.5&&_2.x>=U.x-.5&&\n                  _2.y<U.y+.5&&_2.y>=U.y-.5){\n                  Q += .5*b.w*_2;\n                  QB.w += .5*b.w;\n              }\n         }\n    }\n    if (QB.w >0.) Q /= QB.w;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Translate Particles 🚗\nMain {\n    Q = vec4(0);\n    vec4 QB = vec4(0);\n    for (float x=-2.;x<=2.;x++)\n    for (float y=-2.;y<=2.;y++)\n    {\n          vec2 xy = vec2(x,y);\n          vec4 b = B(U+xy);\n          if (b.w>0.) {\n              vec4 a = A(U+xy);\n              \n              vec4 _1 = a, _2 = a;\n              mat2 m = ei(6.2*hash(vec3(U+xy,iTime)).x);\n              if (b.w>1.) {\n                  vec2 v = vec2(0,Z)*m;\n                  _2.xy -= v;\n                  _1.xy += v;\n              }\n              if (_1.x<U.x+.5&&_1.x>=U.x-.5&&\n                  _1.y<U.y+.5&&_1.y>=U.y-.5){\n                  Q += .5*b.w*_1;\n                  QB.xyz += .5*b.w*b.xyz;\n                  QB.w += .5*b.w; \n              }\n              if (_2.x<U.x+.5&&_2.x>=U.x-.5&&\n                  _2.y<U.y+.5&&_2.y>=U.y-.5){\n                  Q += .5*b.w*_2;\n                  QB.xyz += .5*b.w*b.xyz;\n                  QB.w += .5*b.w;\n              }\n         }\n    }\n    Q = QB;\n    if (QB.w>0.)Q.xyz/=QB.w;\n}", "buffer_b_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Force 🌊\nMain {\n    Q = A(U);\n    vec4 QB = B(U);\n    vec2 f = vec2(0);\n    if (QB.w>0.)\n    {\n        for (float x = -1.;x<=1.;x++)\n        for (float y = -1.;y<=1.;y++)\n        if (abs(x)!=abs(y))\n        {\n              vec2 xy = vec2(x,y);\n              vec4 b = B(U+xy);\n              f.xy -= 0.01*b.w*(b.w-1.-b.z+b.x)*xy;\n         }\n        Q.zw += f.xy/QB.w;//-1e-*Q.zw;\n        Q.xy += Q.zw*1.5*inversesqrt(\n                1.+dot(Q.zw,Q.zw));\n    }\n    Q.w -= .125*(QB.z-QB.x)/R.y;\n    \n                \n    if (Q.x<2.)Q.z=abs(Q.z),Q.x=2.;\n    if (Q.y<2.)Q.w=abs(Q.w),Q.y=2.;\n    if (R.x-Q.x<3.)Q.z=-abs(Q.z),Q.x=R.x-3.;\n    if (R.y-Q.y<3.)Q.w=-abs(Q.w),Q.y=R.y-3.;\n    if (iMouse.z>0.&&length(U.xy-iMouse.xy)<20.)\n        Q = vec4(U+vec2(.5,0),.25,0);\n    \n    if (iFrame < 1) \n        Q = vec4(U,0,0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Color 🌈\nMain {\n    Q = B(U);\n    if (iMouse.z>0.&&length(U.xy-iMouse.xy)<20.)\n        Q=.5+.5*sin(iTime+vec4(1,2,3,4)),\n        Q.w = 1.;\n    if (iFrame < 1) {\n        Q = max(.5-.6*sin(6.*length(U-.5*R)/R.y*(1.+vec4(1,2,3,4))),0.);\n    }\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flt3Wr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ftdGzH", "name": "spqr: material", "author": "Fahrenheitrequited", "description": "a", "tags": ["a"], "likes": 3, "viewed": 191, "published": 3, "date": "1636006306", "time_retrieved": "2024-07-30T18:50:43.131155", "image_code": "/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\n\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/CorrodedBeasts.glsl\n*/\n\n#define MARCH_STEPS 100\n#define PART_COUNT 20\n\n#define time iTime\nfloat PI = acos(-1.0);\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\n\n\nfloat box( vec2 p, vec2 b )\n{\n  vec2 q = abs(p) - b;\n  return max(q.x,q.y);\n}\n\n\nvec2 replim( in vec2 p, in float c, in vec2 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\n\nfloat m1(vec2 uv) {\n  \n \n  \n  \n  float t = iTime ;\n  float a = 3.141592/4.;\n  \n  \n  float thing = 10000.;\n  \n  for( float i = 0.; i <5.; i++){\n  \n    uv *= rot(i * a *2.);\n   \n    uv = abs(uv); \n    uv -= vec2(2,7);\n    uv = -abs(uv);\n   \n    \n    float x1 =  box(uv, vec2(1,1));\n    float x2 =  box(uv + vec2(2,11), vec2(1.,5.));\n    float x3 =  box(uv + vec2(14,14), vec2(.1,53.));\n    vec2 q = replim(uv, 10., vec2(11,2));\n    float x4 =  box(q , vec2(.2,2.));\n   \n    float x = min(x4,min(x1,(min(x2,x3))));\n    \n    thing = min(thing,x);\n   \n    \n \n\n  }\n  return thing ;\n\n}\n\nfloat a = 3.141592;\nfloat glow = 0.;\nfloat m2(vec2 uv) {\n \n  vec2 uv2 = uv;\n  float q = 1.4;\n  \n  float z = 10000.;\n  vec2 off = vec2(58,20);\n  for (float i = 0.; i <5.; i++) {\n    off *= rot(i/4.);\n   \n    uv.x *= q;\n    \n   \n    \n    uv *= rot(a/2.);\n    \n    \n    float a1 =m1(uv  + off);\n    z = min(z,a1);\n  \n  }\n  vec2 arm = vec2(24);\n  arm *= rot(iTime * 7.1);\n  float u = length(uv2  + arm) -2.;\n  \n  glow += .01/(.02 + u);\n \n  return z/1.4;\n}\n\nfloat ink(vec2 uv) {\n\n  return m2(uv);\n}\n\n\n\nfloat tor(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sph(vec3 p, float r) {\n  return length(p) - r;\n}\n\nvec3 rep( vec3 p, vec3 c )\n{\n    return mod(p,c) - 0.5 * c;\n}\n\n\nvec3 replim( in vec3 p, in float c, in vec3 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\n\n\n\nvec3 moda(vec3 p, float rep, float off) {\n  vec2 rp = vec2(atan(p.z,p.x)/(2.0*PI), length(p.xz));\n  rp.x=(fract(rp.x*rep-0.5+off)-0.5)/rep;\n  rp.x *= 2.0*PI;\n  return vec3(cos(rp.x)*rp.y,p.y,sin(rp.x)*rp.y);\n}\n\n\nfloat noise(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,37,289);\n  vec4 pos=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 val=mix(fract(sin(pos)*7894.552), fract(sin(pos+st.x)*7894.552), p.x);\n  vec2 val2=mix(val.xz,val.yw, p.y);\n  return mix(val2.x,val2.y, p.z);\n}\n\nfloat fbm(vec3 p) {\n\n  float d=0.5;\n  float f=0.0;\n  for(int i=0; i<5; ++i) {\n    f+=noise(p/d)*d;\n    d*=.5;\n  }\n  return f;\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\nvec3 smin(vec3 a, vec3 b, float h) {\n  vec3 k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\nvec3 tunnel(vec3 p){\n  vec3 off=vec3(0);\n  off.x += sin(p.z*0.2)*1.5;\n  off.y += sin(p.z*0.3)*1.3;\n  return off;\n}\n\nfloat pi = 3.141592;\nfloat surge (float tt) {\n\n   return (1. - cos(mod(tt*pi,pi))/2.)+floor(tt);\n \n}\n\n\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\nvec3 s;\nint matter = 0;\nfloat map(vec3 p) {\n\n// geo\n\n  p.xz -= 50.;\n  vec3 q1 = rep(p, vec3(21,0,21));\n\n  float bb = box(q1, vec3(.03,.23,.03));\n \n\n \n  //vec3 q2 = rep(p + vec3(0,0,iTime * 15.), vec3(21,0,21));\n  //float sph = sph(q2, 4.1);\n \n  \n \n  p = abs(p)- 100.;\n   p = rep(p, vec3(0.,50.,0.));\n  float ground = box(p, vec3(100,4,100));\n  \n  //float plane = smin(ground,sph,10.2);\n  float plane = ground;\n  float final = min(bb, plane);\n \n  if ( bb == final) {\n    matter = 2;\n  }\n  if ( plane == final ) {\n    matter = 1;\n  }\n  \n  return final;\n \n}\n/*\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    float res = 1.;\n    float k = 2.;\n    \n    \n    for( float t=mint; t<maxt; )\n    {\n        \n        float h = map(ro + rd*t);\n        //h = abs(h);\n        if( h<0.001 ){\n            return 0.0;\n        }\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n*/\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\n\nfloat sss(vec3 p, vec3 l, float d) {\n  return smoothstep(0.0,1.0,map(p+l*d)/d);\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*789.451)*7541.223);\n}\n\nfloat rnd(vec2 t) {\n  return fract(dot(sin(t*vec2(789.451)+t.yx*vec2(842.544)),vec2(7541.223)));\n}\n\nfloat tick (float t) {\n  float i = floor(t);\n  float r = fract(t);\n    r = smoothstep(0.,1.,r);\n \n  \n  return i + r;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n   float time = iTime;\n\n  // nav\n  float tt = iTime;\n  vec3 s = lattice(tick(tt)) * 275.91;\n  vec3 t = lattice(tick(tt)) *  45.71;\n  vec3 arm = vec3(530,0,0);\n  arm.xz *= rot(iTime);\n  arm.yz *= rot(iTime * .71);\n  arm.xy *= rot(iTime * .41);\n  \n  t += arm;\n  t.xy *= .5;\n \n\n  \n  //s = vec3(0.,iTime * 44.21,0);\n  //vec3 arm = vec3(1,1,.11);\n  //t = s + arm;\n  \n  //s = vec3(10,200,10);\n  //t = vec3(0);\n  \n  \n\n \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz*0.7);\n  //vec3 r=normalize(vec3(-uv, 0.7));\n\n  vec3 p=s;\n  float i=0.;\n  float mask=1.0;\n  float d = 10000.0;\n  float dd = 0.;\n  float rand=rnd(uv);\n  \n  \n  // march\n  \n  bool hit = false;\n  for(float z=0.; z < 300.; ++z) {\n    i = z;\n    d=map(p);\n    d = abs(d);\n    if(d<0.01) {\n    \n      float i = ink(mod(p.xz,150.));\n      if (i > .2) {\n        d = .1;\n      } else {\n        hit = true;\n        break;\n      }\n    }\n    if ( dd > 5000.) break;\n    dd += d;\n    p+=r*d;\n  }\n  \n  // hue\n \n  vec3 col;\n  \n  if ( matter == 1) {\n    float i = ink(mod(p.xz,150.));\n    col = vec3(1);\n    if ( i < .3) {\n      col = vec3(0);\n    }\n    if (i < -.0) {\n      col =  vec3(.8,.4,.2);\n      //col = pow(col, vec3(.75));\n    }\n    \n\n  }\n  if (matter == 2) {\n    col = vec3(.5);\n  }\n  \n \n\n  \n  vec3 light =normalize(vec3(4,12.,2.));\n  light.xz *= rot(iTime);\n\n  light = abs(light);\n  \n \n  vec3 n = norm(p);\n  \n  float diff = max(0.0,dot(n,light)*0.5+0.5);\n  float fren = pow(1.+dot(n,r),2.);\n  float sss = sss(p,r,4.) * 2.;\n  float spec= pow(max(dot(reflect(-light,n),-r),.0), 10.) * 5.;\n  //float shad = shadow(p, normalize(-light), .1, length(light-p));\n  float fog =  pow(i/1000.,2.);\n  \n  col -= diff * .1;\n  //col += fren;\n  //col += sss;\n  //col += spec;\n  //col *= shad;\n  //col = mix(col, vec3(0), fog);\n\n;\n \n \n  // sky\n  if (! hit ) {\n\n  \n    float per = dot(r, normalize(vec3(0.,.2,1.)));\n    per = pow(per,2.);\n    col =   mix(  vec3(.5), vec3(.5) * .3,per);\n    \n  }\n\n  fragColor = vec4(col, 1);\n\n\n\n  /*\n  uv *= rot(iTime);\n  uv *= 250.;\n  uv *=  sin(iTime * 1.)/ 1. + .2;\n  float d = ink(uv);\n  vec3 col;\n  col = vec3(.7);\n  \n  if ( d < .2) {\n    col = vec3(0);\n  }\n  if (d < 0.) {\n    col = vec3(1.,.34,.32);\n  }\n\n  col += glow * 400.5;\n  fragColor = vec4( col, 1.);\n\n  */\n  \n}\n\n/*\n\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftdGzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[282, 282, 301, 301, 370], [374, 374, 403, 403, 451], [454, 454, 501, 501, 547], [549, 549, 568, 568, 1127], [1166, 1166, 1185, 1185, 1580], [1582, 1582, 1602, 1602, 1622], [1626, 1626, 1653, 1653, 1721], [1723, 1723, 1751, 1751, 1775], [1776, 1776, 1805, 1805, 1892], [1893, 1893, 1935, 1935, 2042], [2044, 2044, 2072, 2072, 2098], [2100, 2100, 2128, 2128, 2161], [2164, 2164, 2211, 2211, 2257], [2261, 2261, 2302, 2302, 2470], [2473, 2473, 2494, 2494, 2785], [2787, 2787, 2806, 2806, 2914], [2916, 2916, 2955, 2955, 3032], [3034, 3034, 3070, 3070, 3148], [3150, 3150, 3170, 3170, 3264], [3287, 3287, 3311, 3311, 3366], [3370, 3370, 3391, 3391, 3440], [3442, 3442, 3467, 3467, 3936], [3961, 3961, 3980, 3988, 4491], [4492, 4846, 4865, 4865, 4984], [4986, 4986, 5027, 5027, 5073], [5075, 5075, 5111, 5111, 5156], [5158, 5158, 5178, 5178, 5221], [5223, 5223, 5242, 5242, 5321], [5323, 5323, 5345, 5345, 5441], [5442, 5442, 5499, 5499, 7981]], "test": "untested"}
{"id": "fldGDn", "name": "spqr: decal scaffold", "author": "Fahrenheitrequited", "description": "a", "tags": ["a"], "likes": 1, "viewed": 194, "published": 3, "date": "1636005865", "time_retrieved": "2024-07-30T18:50:44.014792", "image_code": "/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\n\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/CorrodedBeasts.glsl\n*/\n\n#define MARCH_STEPS 100\n#define PART_COUNT 20\n\n#define time iTime\nfloat PI = acos(-1.0);\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\n\n\nfloat box( vec2 p, vec2 b )\n{\n  vec2 q = abs(p) - b;\n  return max(q.x,q.y);\n}\n\n\nvec2 replim( in vec2 p, in float c, in vec2 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\n\nfloat m1(vec2 uv) {\n  \n \n  \n  \n  float t = iTime ;\n  float a = 3.141592/4.;\n  \n  \n  float thing = 10000.;\n  \n  for( float i = 0.; i <5.; i++){\n  \n    uv *= rot(i * a *2.);\n   \n    uv = abs(uv); \n    uv -= vec2(2,7);\n    uv = -abs(uv);\n   \n    \n    float x1 =  box(uv, vec2(1,1));\n    float x2 =  box(uv + vec2(2,11), vec2(1.,5.));\n    float x3 =  box(uv + vec2(14,14), vec2(.1,53.));\n    vec2 q = replim(uv, 10., vec2(11,2));\n    float x4 =  box(q , vec2(.2,2.));\n   \n    float x = min(x4,min(x1,(min(x2,x3))));\n    \n    thing = min(thing,x);\n   \n    \n \n\n  }\n  return thing ;\n\n}\n\nfloat a = 3.141592;\nfloat glow = 0.;\nfloat m2(vec2 uv) {\n \n  vec2 uv2 = uv;\n  float q = 1.4;\n  \n  float z = 10000.;\n  vec2 off = vec2(58,20);\n  for (float i = 0.; i <5.; i++) {\n    off *= rot(i/4.);\n   \n    uv.x *= q;\n    \n   \n    \n    uv *= rot(a/2.);\n    \n    \n    float a1 =m1(uv  + off);\n    z = min(z,a1);\n  \n  }\n  vec2 arm = vec2(24);\n  arm *= rot(iTime * 7.1);\n  float u = length(uv2  + arm) -2.;\n  \n  glow += .01/(.02 + u);\n \n  return z/1.4;\n}\n\nfloat ink(vec2 uv) {\n\n  return m2(uv);\n}\n\n\n\nfloat tor(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sph(vec3 p, float r) {\n  return length(p) - r;\n}\n\nvec3 rep( vec3 p, vec3 c )\n{\n    return mod(p,c) - 0.5 * c;\n}\n\n\nvec3 replim( in vec3 p, in float c, in vec3 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\n\n\n\nvec3 moda(vec3 p, float rep, float off) {\n  vec2 rp = vec2(atan(p.z,p.x)/(2.0*PI), length(p.xz));\n  rp.x=(fract(rp.x*rep-0.5+off)-0.5)/rep;\n  rp.x *= 2.0*PI;\n  return vec3(cos(rp.x)*rp.y,p.y,sin(rp.x)*rp.y);\n}\n\n\nfloat noise(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,37,289);\n  vec4 pos=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 val=mix(fract(sin(pos)*7894.552), fract(sin(pos+st.x)*7894.552), p.x);\n  vec2 val2=mix(val.xz,val.yw, p.y);\n  return mix(val2.x,val2.y, p.z);\n}\n\nfloat fbm(vec3 p) {\n\n  float d=0.5;\n  float f=0.0;\n  for(int i=0; i<5; ++i) {\n    f+=noise(p/d)*d;\n    d*=.5;\n  }\n  return f;\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\nvec3 smin(vec3 a, vec3 b, float h) {\n  vec3 k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\nvec3 tunnel(vec3 p){\n  vec3 off=vec3(0);\n  off.x += sin(p.z*0.2)*1.5;\n  off.y += sin(p.z*0.3)*1.3;\n  return off;\n}\n\nfloat pi = 3.141592;\nfloat surge (float tt) {\n\n   return (1. - cos(mod(tt*pi,pi))/2.)+floor(tt);\n \n}\n\n\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\nvec3 s;\nint matter = 1;\n\n\n\nfloat building(vec3 p) {\n\n  p.xz = abs(p.xz)- 100.;\n  \n  p = rep(p, vec3(0.,50.,0.));\n \n  float floors = box(p, vec3(110,11.1,110));\n  float collumns = box(p, vec3(10,40,10));\n \n  float all = min(floors,collumns);\n  \n  if ( floors == all) {\n    matter = 1;\n  }\n  if ( collumns == all) {\n    matter = 2;\n  }\n  return all;\n \n \n}\n\n\n\nfloat map (vec3 p) {\n\n  // geo\n  \n  float w = 1000.;\n  p.xz = abs(p.xz - w);\n  float t = building(p - vec3(w,0,w));\n \n  return t;\n}\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\n\nfloat sss(vec3 p, vec3 l, float d) {\n  return smoothstep(0.0,1.0,map(p+l*d)/d);\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*789.451)*7541.223);\n}\n\nfloat rnd(vec2 t) {\n  return fract(dot(sin(t*vec2(789.451)+t.yx*vec2(842.544)),vec2(7541.223)));\n}\n\nfloat tick (float t) {\n  float i = floor(t);\n  float r = fract(t);\n  for (int z = 0; z < 2; z++) {\n    r = smoothstep(0.,1.,r);\n  }\n  \n  return i + r;\n}\n\nvec3 flit(float t) {\n\n  vec3 x = normalize(vec3(1));\n  float t1 = tick(t);\n  float t2 = tick(t * .71);\n  float t3 = tick(t * .55);\n  x.yz *= rot(t1);\n  x.xz *= rot(t2);\n  x.yx *= rot(t3);\n  \n  return x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n \n\n  // nav\n  float tt = iTime * 1.;\n  vec3 s = lattice(tt  * 2. + 17.) * 100.;\n  vec3 t = lattice(tt  * 1.71) * 100.;\n  \n  \n  vec3 arm = vec3(0,0,1);\n  arm.xz *= rot(tt * .55);\n  arm.yz *= rot(tt * .68);\n  arm.xy *= rot(tt * .71);\n\n  \n  s += flit(tt * 1.21) * 77.1;\n  s += arm * 200.;\n  t.xy *= .5;\n  \n  vec3 down = vec3(0.  , tick(tick(iTime/12.3)) * 717.91, 0.);\n  s+= down;\n  t+= down;\n  \n \n \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz*0.7);\n  //vec3 r=normalize(vec3(-uv, 0.7));\n\n  vec3 p=s;\n  float i=0.;\n  float mask=1.0;\n  float d = 10000.0;\n  float dd = 0.;\n  float rand=rnd(uv);\n  \n  \n  // march\n  \n  bool hit = false;\n  for(float z=0.; z < 1000.; ++z) {\n    i = z;\n    d=map(p);\n    d = abs(d);\n    if(d<0.001) {\n      if ( matter == 1) {\n        float i = ink(mod(p.xz,150.));\n        if (i > .2) {\n          d = .1;\n        } else {\n          hit = true;\n          break;\n        }\n      \n      }\n      \n      if (matter == 2) {\n        hit = true;\n        break;\n      }\n    }\n    if ( dd > 50000.) break;\n    dd += d;\n    p+=r*d;\n  }\n  \n  // hue\n \n  vec3 col;\n  \n  if ( matter == 1) {\n    float i = ink(mod(p.xz,150.));\n    col = vec3(1);\n    if ( i < 0.2) {\n      col = vec3(0);\n    }\n    if (i < -0.1) {\n \n    \n      col =  vec3(.8,.4,.2);\n      //col = vec3(.7);\n    \n    }\n    \n\n  }\n  if (matter == 2) {\n    col = vec3(1);\n  }\n  \n \n\n  \n  vec3 light =normalize(vec3(4,12.,2.));\n  light.xz *= rot(iTime);\n\n  light = abs(light);\n  \n \n  vec3 n = norm(p);\n  \n  float diff = max(0.0,dot(n,light)*0.5+0.5);\n  float fren = pow(1.+dot(n,r),2.);\n  float sss = sss(p,r,4.) * 2.;\n  float spec= pow(max(dot(reflect(-light,n),-r),.0), 10.) * 5.;\n  //float shad = shadow(p, normalize(-light), .1, length(light-p));\n  float fog =  pow(i/1000.,2.);\n  \n  col -= diff * .1;\n  //col += fren;\n  //col += sss;\n  //col += spec;\n  //col *= shad;\n  //col = mix(col, vec3(0), fog);\n\n;\n \n \n  // sky\n  if (! hit ) {\n\n  \n    float per = dot(r, normalize(vec3(0,1,0)));\n    per = pow(per,0.9);\n   \n    col =   mix(  vec3(.0,.5,1.), vec3(.0,.5,1.) * .1, per);\n    \n  }\n\n  fragColor = vec4(col, 1);\n\n\n\n  /*\n  uv *= rot(iTime);\n  uv *= 250.;\n  uv *=  sin(iTime * 1.)/ 1. + .2;\n  float d = ink(uv);\n  vec3 col;\n  col = vec3(.7);\n  \n  if ( d < .2) {\n    col = vec3(0);\n  }\n  if (d < 0.) {\n    col = vec3(1.,.34,.32);\n  }\n\n  col += glow * 400.5;\n  fragColor = vec4( col, 1.);\n\n  */\n  \n}\n\n/*\n\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fldGDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[282, 282, 301, 301, 370], [374, 374, 403, 403, 451], [454, 454, 501, 501, 547], [549, 549, 568, 568, 1127], [1166, 1166, 1185, 1185, 1580], [1582, 1582, 1602, 1602, 1622], [1626, 1626, 1653, 1653, 1721], [1723, 1723, 1751, 1751, 1775], [1776, 1776, 1805, 1805, 1892], [1893, 1893, 1935, 1935, 2042], [2044, 2044, 2072, 2072, 2098], [2100, 2100, 2128, 2128, 2161], [2164, 2164, 2211, 2211, 2257], [2261, 2261, 2302, 2302, 2470], [2473, 2473, 2494, 2494, 2785], [2787, 2787, 2806, 2806, 2914], [2916, 2916, 2955, 2955, 3032], [3034, 3034, 3070, 3070, 3148], [3150, 3150, 3170, 3170, 3264], [3287, 3287, 3311, 3311, 3366], [3370, 3370, 3391, 3391, 3440], [3442, 3442, 3467, 3467, 3936], [3964, 3964, 3988, 3988, 4290], [4294, 4294, 4314, 4324, 4425], [4426, 4426, 4445, 4445, 4564], [4566, 4566, 4607, 4607, 4653], [4655, 4655, 4691, 4691, 4736], [4738, 4738, 4758, 4758, 4801], [4803, 4803, 4822, 4822, 4901], [4903, 4903, 4925, 4925, 5055], [5057, 5057, 5077, 5077, 5261], [5263, 5263, 5320, 5320, 7931]], "test": "untested"}
{"id": "NldGDr", "name": "Simplex Experiment #2", "author": "Yusef28", "description": "Building off of my previous shader and some of the advice I got from FabriceNeyret2 here:\nhttps://www.shadertoy.com/view/7d3SDS\n\nThere is a lot more to learn from those comments in terms of golfing and coding in general.", "tags": ["triangles", "simplex"], "likes": 13, "viewed": 303, "published": 3, "date": "1635999450", "time_retrieved": "2024-07-30T18:50:44.849560", "image_code": "//barycentric\n#define eps 8./iResolution.y\n#define S smoothstep\n\n//#define cross2D(a,b) a.y*b.x-a.x*b.y\n#define cross2D(a,b) (a).y*(b).x-(a).x*(b).y\n//skew matrix often written as \n//mat2 skew = mat2(1.1547, 0., 1.1547/2., 1.);\nmat2 skew = mat2(2./sqrt(3.), 0., 1./sqrt(3.), 1.); \n\n//This hash is pretty bad\nfloat badHash(vec2 x){\n    return fract(sin(dot(vec2(23.,72.),x)*134.)*43143.);\n}\n\n// based on comments from FabriceNeyret2\n// https://www.shadertoy.com/view/7d3SDS\n// super elegant\nvec2 bary(vec2 A, vec2 B, vec2 C, vec2 P){\n    \n    //We want areas for the three triangles created\n    //with out point P and the 3 sides\n    //we get a triangle with vectors AtoB and AtoP\n    //Repeat with B and C\n    vec3 tri = vec3(length(cross2D(B-A,P-A)),\n                    length(cross2D(C-B,P-B)),\n                    length(cross2D(A-C,P-C))\n                    );\n    //If P is in the middle, all areas are equal\n    //If P lays between two sub triangles, those areas\n    //will be equal and there will be one other area\n    \n    \n    //chill sort to find the smallest area triangle\n   \n    //id which we will swap simultenously\n    vec3 id = vec3(1.,2.,3.);\n   \n    //swap to get minumum at x\n    //swap remaining two to get minumum at y\n    if(tri.z < tri.y) tri = tri.xzy, id = id.xzy;\n    if(tri.y < tri.x) tri = tri.yxz, id = id.yxz;\n    if(tri.z < tri.y) tri = tri.xzy, id = id.xzy;\n    //with tri sorted, can do smoothstep without abs\n    \n    \n    //Those areas become a coordinate system because together \n    //they tell us relatively how close P is to any of \n    //the three sides.\n    \n    //so \"borders\" are like with uv.x-uv.y but now 3d \n    //border of area1 and area2 like (uv.y-uv.x)\n    float f1 = S(0.,eps, tri.y-tri.x - 0.02);\n    //border of area1 and area3 (uv.z-uv.y)\n    float f2 = S(0.,eps, tri.z-tri.x - 0.02);\n    return vec2(id.x,f1*f2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 3.*(fragCoord*2.-iResolution.xy)/iResolution.y;\n    uv.x += iTime/4.;\n    uv *= skew;\n    vec2 uvFL = floor(uv);\n    uv = fract(uv);\n    \n    vec2 f = 1.0 - S(0., eps, abs(uv-0.5)-0.48 );\n    float fd =  S(0., eps, abs(uv.x-uv.y)-0.02 );\n    \n    float side = sign(uv.x-uv.y);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(vec3(0,2,4));\n    \n    vec2 stuff = bary(vec2(0.), \n                       vec2(1.,side<0.), \n                       vec2(side>0.,1.),\n                       uv);\n                       \n    col = 0.5 + 0.5*cos(vec3(1.,2.,4.)/3. + \n          badHash(uvFL+side*0.5 + stuff.x/3.)*80. + iTime/2. );\n  \n    col *= f.x;\n    col *= f.y;\n    col *= fd;\n    col *= stuff.y;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NldGDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[282, 308, 330, 330, 389], [391, 490, 532, 705, 1871], [1873, 1873, 1930, 1980, 2760]], "test": "untested"}
{"id": "ftdGWr", "name": "Wavy micro tile", "author": "xZAKHAMx", "description": "just another micro tile to get familiar with glsl. ", "tags": ["microtiles"], "likes": 4, "viewed": 221, "published": 3, "date": "1635991469", "time_retrieved": "2024-07-30T18:50:45.680339", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p  = -1.0 + 2.0*uv; \n    \n    float pha = 1.0;\n    float div = 0.5;\n    float scale = 0.5;\n    float num = 10.0;\n    float xsine = sin(p.x + iTime*pha);\n    vec3 col = vec3 (0.0);    \n    \n    float wave = round(mod(abs(xsine - p.y), div)*num*(1.0/scale))*(1.0/num);\n    \n    col = vec3(wave);\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftdGWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 463]], "test": "untested"}
{"id": "NltGWr", "name": "DaemonWall(Modified)", "author": "taellinglin", "description": "kinda stole this shader from another one and removed the rotation/tilt/wobble and RGB shifter...\n\nI am just starting with shaders and thought this would look cool as a level texture in my game without some of the effects. Whoever wrote this I will hire u", "tags": ["stolen"], "likes": 8, "viewed": 296, "published": 3, "date": "1635991388", "time_retrieved": "2024-07-30T18:50:46.483192", "image_code": "/*\n\n\tdraw letter shapes after subdividing uv space randomly\n\n*/\n\n#define PI 3.1415926535\n\nfloat random2d(vec2 n) { \n    return fract(sin(dot(n, vec2(129.9898, 4.1414))) * 2398.5453);\n}\n\nvec2 getCellIJ(vec2 uv, float gridDims){\n    return floor(uv * gridDims)/ gridDims;\n}\n\nvec2 rotate2D(vec2 position, float theta)\n{\n    mat2 m = mat2( cos(theta), -sin(theta), sin(theta), cos(theta) );\n    return m * position;\n}\n\n//from https://github.com/keijiro/ShaderSketches/blob/master/Text.glsl\nfloat letter(vec2 coord, float size)\n{\n    vec2 gp = floor(coord / size * 7.); // global\n    vec2 rp = floor(fract(coord / size) * 7.); // repeated\n    vec2 odd = fract(rp * 0.5) * 2.;\n    float rnd = random2d(gp);\n    float c = max(odd.x, odd.y) * step(0.5, rnd); // random lines\n    c += min(odd.x, odd.y); // fill corner and center points\n    c *= rp.x * (6. - rp.x); // cropping\n    c *= rp.y * (6. - rp.y);\n    return clamp(c, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy / iResolution.xy;    \n    //correct aspect ratio\n    uv.x *= iResolution.x/iResolution.y;\n\n    float t = iTime;\n    float scrollSpeed = 0.3;\n    float dims = 2.0;\n    int maxSubdivisions = 3;\n    \n    //uv = rotate2D(uv,PI/12.0);\n    uv.y -= iTime * scrollSpeed;\n    \n    float cellRand;\n    vec2 ij;\n    \n   \tfor(int i = 0; i <= maxSubdivisions; i++) { \n        ij = getCellIJ(uv, dims);\n        cellRand = random2d(ij);\n        dims *= 2.0;\n        //decide whether to subdivide cells again\n        float cellRand2 = random2d(ij + 454.4543);\n        if (cellRand2 > 0.3){\n        \tbreak; \n        }\n    }\n   \n    //draw letters    \n    float b = letter(uv, 1.0 / (dims));\n\t\n    //fade in\n    float scrollPos = iTime*scrollSpeed + 0.5;\n    float showPos = -ij.y + cellRand;\n    float fade = smoothstep(showPos ,showPos + 0.05, scrollPos );\n    b *= fade;\n    \n    //hide some\n    //if (cellRand < 0.1) b = 0.0;\n    \n    fragColor = vec4(vec3(b), 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NltGWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 114, 114, 184], [186, 186, 226, 226, 271], [273, 273, 316, 316, 413], [415, 486, 524, 524, 928], [930, 930, 987, 987, 1975]], "test": "untested"}
{"id": "NsyGWW", "name": "Interactive Menu - JFIG 2021", "author": "Cewein", "description": "was made for the ConcoursJFIG2021 but sadly only did the animation part, not the rendering.\nstill it work great.", "tags": ["mouse", "animation", "slider", "concoursjfig2021", "interactif"], "likes": 5, "viewed": 307, "published": 3, "date": "1635985932", "time_retrieved": "2024-07-30T18:50:47.255128", "image_code": "//////////////////\n//\n//    this is a proof of concept for a 3 color selector \n//    along with the proper transition to 3 different display\n//    and a yellow back button to go back to the color selector.\n//    \n//    Shader made by Cewein, 2021\n//    \n//    feel free to use this shader as long you reference this one\n//\n//////////////////\n\n#define ir iResolution\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    //this variable hold the whole animation state\n    //-1: three color display\n    // 0: 3 color to R\n    // 1: 3 color to G\n    // 2: 3 color to B\n    // 3: R to 3 color\n    // 4: G to 3 color\n    // 5: B to 3 color\n    // 6: full screen R\n    // 7: full screen G\n    // 8: full screen B\n    vec4 animState = texture(iChannel0, uv);\n    \n    if(animState.x < -0.5)\n    {\n        col = vec3(0.8,0.3,0.2);\n        col = mix(col,vec3(0.2,0.8,0.3),checkSide(fragCoord,vec2(ir.x/3.0,ir.y/2.0),10.0));\n        col = mix(col,vec3(0.3,0.2,0.8),checkSide(fragCoord,vec2(ir.x/3.0 * 2.0,ir.y/2.0),10.0));\n    }\n    else if(animState.x < 5.5)\n    {\n        float time = iTime - animState.y;\n        float transitionTime = 0.75;\n        \n        if(animState.x > 2.5 && animState.x < 5.5)\n        {\n            time = transitionTime - time;\n            animState.x = animState.x -3.0;\n        }\n        \n        float angle = mix(10.0,0.0,smoothstep(0.0,0.25,time));\n\n        float posL = ir.x/3.0;        \n        float posR = ir.x/3.0 * 2.0;\n\n        if(animState.x < 0.5)\n        {\n            posR = mix(posR, ir.x + 1.0,smoothstep(0.0,transitionTime, time));           \n            posL = mix(posL, ir.x + 1.0,smoothstep(0.0,transitionTime, time));\n        }\n        else if(animState.x < 1.5)\n        {\n            posR = mix(posR, ir.x + 1.0,smoothstep(0.0,transitionTime, time));            \n            posL = mix(posL, -1.0,smoothstep(0.0,transitionTime, time));\n        }\n        else if(animState.x < 2.5)\n        {\n            posR = mix(posR, -1.0,smoothstep(0.0,transitionTime, time));\n            posL = mix(posL, -1.0,smoothstep(0.0,transitionTime, time));          \n        }\n        \n        \n        col = vec3(0.8,0.3,0.2);\n        col = mix(col,vec3(0.2,0.8,0.3),checkSide(fragCoord,vec2(posL,ir.y/2.0),angle));\n        col = mix(col,vec3(0.3,0.2,0.8),checkSide(fragCoord,vec2(posR,ir.y/2.0),angle));\n        \n       \n    }\n    else\n    {\n        if(animState.x < 6.5)\n        {\n            col = vec3(0.8,0.3,0.2);\n        }\n        else if(animState.x < 7.5)\n        {\n            col = vec3(0.2,0.8,0.3);\n        }\n        else if(animState.x < 8.5)\n        {\n            col = vec3(0.3,0.2,0.8);       \n        }\n        \n        col = mix(col, vec3(0.9,0.9,0.2),step(sdBox(fragCoord-vec2(ir.x-120.0,45.0),vec2(100,25)),0.0));\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//this buffer is for all the animation\n//it record last time since mouse click or animation state switch\n//it record also the animation state we are in\n//////////////////////////////////////////////\n\n#define clickBack(m) step(sdBox(m.xy-vec2(iResolution.x-120.0,45.0),vec2(100,25)),0.0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ir = iResolution.xy;\n\n    //init the global \n    if(iTime < 0.1)\n    {\n        fragColor = vec4(-1);\n        return;\n    }\n\n    fragColor = texture(iChannel0,fragCoord);\n    \n    //check if mouse is init\n    if(iMouse.x != 0.0 && iMouse.y != 0.0)\n    {\n        //check if mouse is clicked\n        if(iMouse.w > 0.0 || iMouse.z > 0.0)\n        {\n            //check with color as been clicked\n            if(fragColor.x < -0.5)\n            {\n                fragColor.x = checkSide(iMouse.xy,vec2(ir.x/3.0,ir.y/2.0),10.0) + checkSide(iMouse.xy,vec2(ir.x/3.0 * 2.0,ir.y/2.0),10.0);\n                fragColor.y = iTime;\n            }\n            //check if back yellow rectangle as been clicked\n            else if(clickBack(iMouse) > 0.5 && fragColor.x > 5.5)\n            {\n                fragColor.x = fragColor.x - 3.0;\n                fragColor.y = iTime;\n            }\n        }\n        //forced transition to a full color display\n        else if(fragColor.x < 2.5)\n        {\n            fragColor.x = mix(fragColor.x, fragColor.x + 6.0, step(0.75, iTime - fragColor.y)); \n        }\n        //forced transition to a 3 color display\n        else if(fragColor.x > 2.5 && fragColor.x < 5.5)\n        {\n            fragColor.x = mix(fragColor.x, -1.0, step(0.75, iTime - fragColor.y)); \n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nmat2 rot(float angle)\n{\n    angle *= 0.0174533;\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat checkSide(vec2 check, vec2 p, float angle)\n{\n    //rotating point\n    vec2 k = p + vec2(50.0,0.0);\n    \n    //rotate around the point\n    k = p + rot(angle)*(k-p);\n    \n    //Get the direction\n    vec2 dir = k-p;\n    vec2 checkPointDir = check - p;\n    \n    //perform dot product to know we side of the \"border\" we are\n    return step(0.0, dot(dir,checkPointDir));\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsyGWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[367, 367, 424, 424, 2881]], "test": "untested"}
{"id": "Ntd3Wn", "name": "Rotating Ripple", "author": "xZAKHAMx", "description": "this is my first micro tile as studying glsl.", "tags": ["microtiles"], "likes": 4, "viewed": 223, "published": 3, "date": "1635982943", "time_retrieved": "2024-07-30T18:50:48.067955", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p  = vec2 (-1.0 + 2.0*uv);\n    p.x *= iResolution.x/iResolution.y;\n    \n    float anV = 0.50;\n    float div = 0.40;\n    float rad = 0.20;\n    \n    p = vec2 (p.x*cos(iTime) - p.y*sin(iTime),\n              p.x*sin(iTime) + p.y*cos(iTime));\n    p = abs(p);\n    vec2 tolen = (p + (vec2 (-iResolution.x/iResolution.y, -1.0 )));\n    float len = length(tolen);\n\n    float anm = len + iTime*anV; \n    vec2 mo = mod(vec2(anm), div);\n    vec3 col = vec3(0.0);\n    if (mo.x < rad)\n    {\n        col = vec3(1.0);\n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntd3Wn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 656]], "test": "untested"}
{"id": "ftd3zH", "name": "Rainbow Storm", "author": "R3N", "description": "Color hue of fractal noise with chromatic aberration to separate the colors at the edges.", "tags": ["noise", "color", "rainbow", "acid"], "likes": 9, "viewed": 479, "published": 3, "date": "1635972705", "time_retrieved": "2024-07-30T18:50:48.831912", "image_code": "#define pi 3.14159\n#define rot(t) mat2(cos(t), -sin(t), sin(t), cos(t))\n\n// color hue based on IQ's palettes\nvec3 col(float t) {\n    return 0.5+0.5*cos(2.0*pi*(t+vec3(0, 0.33, 0.67)));\n}\n\n// random number between 0 and 1\nfloat rand(vec2 p) {\n\treturn fract(sin(dot(p, vec2(12.543,514.123)))*4732.12);\n}\n\n// value noise\nfloat noise(vec2 p) {\n\tvec2 f = smoothstep(0.0, 1.0, fract(p));\n\tvec2 i = floor(p);\n\tfloat a = rand(i);\n\tfloat b = rand(i+vec2(1.0,0.0));\n\tfloat c = rand(i+vec2(0.0,1.0));\n\tfloat d = rand(i+vec2(1.0,1.0));\n\treturn mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n\t\n}\n\n// fractal noise\nfloat fbm(vec2 p) {\n    float a = 0.5;\n    float r = 0.0;\n    for (int i = 0; i < 6; i++) {\n        r += a*noise(p);\n        a *= 0.5;\n        p *= 2.0;\n    }\n    return r;\n}\n\n// main effect\nvec4 eff(vec2 uv) {\n\tuv *= 10.0;\n\tuv *= rot(length(0.1*uv)*1.25);\n\tuv.y -= iTime*0.75;\n\treturn vec4(col(3.0*fbm(uv/4.0+iTime*0.1+fbm(2.5*uv-iTime*0.1))), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.y;\n    uv -= iResolution.xy/iResolution.y/2.0;\n    vec4 col = eff(uv);\n    float aberration = 1.015 + 0.2*smoothstep(-1.0, 1.0, sin(0.25*iTime));\n    col.r = eff(uv/aberration).r;\n    col.b = eff(uv*aberration).b;\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftd3zH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 109, 128, 128, 186], [188, 221, 241, 241, 301], [303, 318, 339, 339, 577], [579, 596, 615, 615, 770], [772, 787, 806, 806, 948], [950, 950, 1007, 1007, 1280]], "test": "untested"}
{"id": "NdcGRS", "name": "Sierpinski triangle/ raymarching", "author": "bugaga777", "description": "My second try in raymarching)", "tags": ["raymarching", "sdf", "triangle", "sierpinski"], "likes": 3, "viewed": 354, "published": 3, "date": "1635967547", "time_retrieved": "2024-07-30T18:50:49.604846", "image_code": "#define PI 3.14159\n#define HALF_PI 1.57\n#define HALF_HALF_PI 0.785\n\n\nconst float MIN_DIST = 0.;\nconst float MAX_DIST = 100.;\nconst int   MARCH_STEPS = 200;\nconst float EPSILON = 0.001;\n\nconst int POWER = 2;\nconst int PYRAMIDS = int(pow(5.,float(POWER)));\n\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\nfloat sceneSDF(vec3 point) {\n    const mat4 scene_mat = mat4(\n       0.5, 0., 0., 0.,\n       0., 0.5, 0., 0.,\n       0., 0., 0.5, 0.,\n       0., 0.5, 0., 1.\n    );\n    float result = MAX_DIST;\n    \n     for (int i = 0; i < PYRAMIDS; i++) {\n        mat4 modelMtx = mat4(\n           1., 0., 0., 0.,\n           0., 1., 0., 0.,\n           0., 0., 1., 0.,\n           0., 0., 0., 1.\n        ) * scene_mat;\n        \n        for (int ii = POWER - 1; ii >= 0; ii--) {\n            float loc_order = floor(mod(float(i), pow(5., float(ii + 1))) / pow(5., float(ii)));\n            float isMiddle = floor(loc_order / 4.);\n            float angle = HALF_HALF_PI + HALF_PI * loc_order;\n            float r = sqrt(0.5);\n            float y = -isMiddle;\n            float x = (1. - isMiddle) * cos(angle) * r;\n            float z = (1. - isMiddle) * sin(angle) * r;\n            \n        \n            modelMtx = mat4(\n               2., 0., 0., 0.,\n               0., 2., 0., 0.,\n               0., 0., 2., 0.,\n               x, y, z, 1.\n            ) * modelMtx;\n        }\n        \n       result = min(result, sdPyramid(vec3(modelMtx * vec4(point, 1.)), 1.) / modelMtx[0][0]);\n    }\n\n    return result;\n}\n\nfloat rayMarching(vec3 eye, vec3 dir) {\n    float full_dist = MIN_DIST;\n    \n    for (int i = 0; i < MARCH_STEPS; i++) {\n        float current_dist = sceneSDF(eye + dir * full_dist);\n        \n        if (current_dist < EPSILON) {\n            return full_dist;\n        }\n        \n        full_dist += current_dist;\n        if (full_dist >= MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n    \n     return MAX_DIST;\n} \n\nvec3 getDirection(float fov, vec2 fragCoord, vec2 screenSize) {\n    vec2 xy = fragCoord - screenSize / 2.;\n    float z = screenSize.y / 2. / tan(radians(fov / 2.));\n    return normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float polar_angle;\n    float azimut_angle;\n    float r = 6.;\n    if (iMouse.y == 0. || iMouse.x == 0.) {\n        polar_angle = HALF_PI * .8;\n        azimut_angle = iTime;\n    } else {\n        polar_angle =  iMouse.y / iResolution.y * PI;\n        azimut_angle = (iMouse.x / iResolution.x * -2. + 1.) * PI;\n    }\n    \n    \n    vec3  eye  = vec3(\n        r * sin(azimut_angle) * sin(polar_angle),\n        r * cos(polar_angle),\n        r * cos(azimut_angle) * sin(polar_angle)\n    );\n    \n    vec3  dir  = lookAt(eye, vec3(0.,0.,0.), vec3(0.,1.,0.)) * getDirection(45., fragCoord, iResolution.xy);\n   \n    float dist = rayMarching(eye, dir);\n    \n    if(dist >= MAX_DIST) {\n         fragColor = vec4(0., 0., 0., 1.0);\n         return;\n    }\n    \n    vec3 p = eye + dist * dir;\n    vec3 normal = estimateNormal(p);\n    vec3 lightPos = eye;\n    vec3 lightDir = normalize(lightPos - p);\n    \n    //diff\n    vec3 diff = max(dot(lightDir, normal), 0.) * vec3(1., 0., 0.);\n    \n    //spec\n    vec3 reflectedLight = reflect(-lightDir, normal);\n    vec3 spec = vec3(.8) *  pow(max(dot(reflectedLight, normalize(eye - p)),.0), 25.);\n    \n    vec3 color = diff + spec;\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "mat3 lookAt( vec3 eye, vec3 target, vec3 up ) {\n        vec3 z = normalize(eye - target);\n        vec3 x = normalize(cross(up, z));\n        vec3 y = normalize(cross(z, x));\n\n\t\treturn mat3(\n            x.x, x.y, x.z,\n            y.x, y.y, y.z,\n            z.x, z.y, z.z\n        );\n     \n\t}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdcGRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[256, 256, 291, 291, 776], [778, 778, 806, 806, 1964], [1966, 1966, 2005, 2005, 2390], [2393, 2393, 2456, 2456, 2595], [2597, 2597, 2626, 2626, 2936], [2939, 2939, 2996, 2996, 4192]], "test": "untested"}
{"id": "7dKSRG", "name": "TARDIS", "author": "efelo", "description": "Just an ordinary blue box!\n\nTime And Relative Dimension(s) In Space\nResembling the 13.Doctor's Tardis from the British TV-series \"Doctor Who\".\n\nWalk around (and inside!) with WASD or arrow keys.", "tags": ["portal", "drwho", "tardis", "doctorwho"], "likes": 22, "viewed": 504, "published": 3, "date": "1635963815", "time_retrieved": "2024-07-30T18:50:50.839546", "image_code": "//Copyright © 2021 efelo\n////////////////////\n////////////////////\n////////////////////\n//Still not done, but fps and motivation droped while compile time increased, so i decided to stop here, maybe.\n//\n//I hope the shader runs for you!\n//\n//\n////////////////////\n//the TARDIS\n//    short for \"Time And Relative Dimension(s) In Space\"\n//    is the space and time ship of an alien called the doctor.\n//    the TARDIS can travel in time and space.\n//    its inside is larger than its outside.\n//    the outside should change its shape to fit the surounding it lands in. But is stuck and looks like a police box.\n//    the inside is decorated diffrently from time to time.\n//    this shader respresents the Tardis of the 13. doctor.\n////////////////////\n//thechnical:\n//    the outside is fast.\n//    the inside is slow but hard to optimize.\n//    Inside and outside are two sdfs joined and swiched between by the \"inside\" variable.\n//    a raytraced portal in the open door moves raymarcher and camera between them.\n//    if you walk through walls you don't get moved.\n//    console and inside walls are low on detail.\n//    lighting is phong based with some fake ambient oclusion and fressnel.\n//    the noise is a fake normal map exept the pylons those are 3d.\n//    inside lighting looks strange implemented with one point light.\n////////////////////\n//compile time/speed optimization atempts:\n//    reduced noise functions to one for normalmap and one for the pylons\n//    shadow only sdf with only the outside rendered\n//    remove length() from box() and cylinder() functions where possible\n//    unwrap cone() and cylinder() functions to share lenght() operations\n//    use rotation tricks to not render the door seperately (has some artefacts)\n//    use as many symetries as possible\n//    material and normalmap are testet in the same function to share bounding boxes.\n//    use an extra function for hexagonal symetries to reduce use of polar coordinates.\n//    use #define ZERO (min(iFrame,0)) (no effect for me)\n//failed:\n//    use noise on whole sdf to remove the normalmap function.\n//    use matrial ids to reduce vec4 asignments\n//    use sphere inside Tardis to accelerate raymarching (still there and creates artefacts on the ceiling)\n//    use volume texture for noise (creates strange patterns on the pylons, maybe 8bit limit?)\n////////////////////\n//further ideas(but very expensive):\n//    time-traveling to different procedural landscapes\n//    different tardis interiors\n//    tardis ambient sounds inside tardis (no idear how to pull of)\n////////////////////\n\n\n#define ZERO (min(iFrame,0))\n\n////////////////////\n//texture lookups\n////////////////////\n\nvec4  get_buf(int adress)              {return texelFetch(iChannel0, ivec2(adress,0), 0);}\nfloat get_glyph(vec2 uv, float glyph)  {return    texture(iChannel2, vec2(uv + vec2(floor(mod(glyph, 16.)), 15. - floor(glyph / 16.))) / 16.).a;} \n\n\n////////////////////\n//sdf functions\n////////////////////\n//from iq:\n\n\n//box\nfloat box(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return max(q.x,max(q.y,q.z));//cheaper?\n    //return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n//cylinder\nfloat cyl(vec3 p, float h, float r)\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//cylinder\nfloat cheap_cyl(vec3 p, float h, float r)\n{\n  return max(abs(p.z)-r, length(p.xy)-h);\n}\n\n\n//cone cheap\n//float con(vec3 p, vec2 c, float h)\n//{\n//  float q = length(p.xy);\n//  return max(dot(c.xy,vec2(q,p.z)),-h-p.z);\n//}\n\n\n//torus\nfloat tor(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n//plane\nfloat pln(vec3 p, vec3 dir)\n{\n    return dot(p,dir);\n}\n\n\n//sphere\nfloat sph(vec3 p, float rad)\n{\n    return length(p) - rad;\n}\n\n\n//capsule\nfloat cap(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n  return length( pa - ba*h ) - r;\n}\n\n\n//caped cone\nfloat cop(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\n\n\n\n////////////////////\n//noise\n////////////////////\n///*\n//derived from demofox\nvec2 hash2(ivec3 pos)\n{\n    uvec3 ipos = uvec3(pos);\n    //4dim to seed\n    uint seed = (ipos.x * 1973u + ipos.y * 9277u + ipos.z * 26699u) | 1u;\n\n    //hash\n    seed *= 0x27d4eb2du;\n    seed = seed   ^ (seed   >> 15);\n    seed *= 0x27d4eb2du;\n    uint seed2 = seed   ^ (seed   >> 15);\n    seed2 *= 0x27d4eb2du;\n    //hash to float\n    return vec2(seed,seed2) / 4294967296.0;\n}\n\n\n\nvec2 noise3d2(vec3 pos)\n{\n    vec3  f = floor(pos);\n    ivec3 i = ivec3(f);\n    \n    vec2 r000 = hash2(i + ivec3(0,0,0));\n    vec2 r100 = hash2(i + ivec3(1,0,0));\n    vec2 r010 = hash2(i + ivec3(0,1,0));\n    vec2 r110 = hash2(i + ivec3(1,1,0));\n    vec2 r001 = hash2(i + ivec3(0,0,1));\n    vec2 r101 = hash2(i + ivec3(1,0,1));\n    vec2 r011 = hash2(i + ivec3(0,1,1));\n    vec2 r111 = hash2(i + ivec3(1,1,1));\n    \n    f = pos - f;\n    \n    f = f * f * (3. - 2. * f);\n    \n    return mix(mix(mix(r000,r100,f.x), mix(r010,r110,f.x), f.y),  mix(mix(r001,r101,f.x), mix(r011,r111,f.x), f.y),  f.z);\n}\n\n//*/\n\n//strange patterns on pylons:\n//add Grey Noise3D noise volume to iChannel1 to use this noise version\n/*\nvec2 noise3d2(vec3 pos)\n{\n    vec3  i = floor(pos);\n    vec3 f = fract(pos);\n    f = f * f * (3. - 2. * f);\n    \n    \n    f = (f + i - 0.5) / iChannelResolution[1];\n    \n    return vec2(texture(iChannel1,f).x,texture(iChannel1,f).y);\n}\n//*/\n\n////////////////////\n//ray functions\n////////////////////\n\n\n//helper struct\nstruct ray\n{\n    //ray position\n    vec3 pos;\n    // normalized ray direction\n    vec3 dir;\n};\n\n\n//ray plane\nfloat ray_pln(in ray r, in vec3 p)\n{\n    return - dot(r.pos, p.xyz) / dot(r.dir, p.xyz);\n}\n\n\n//ray box\nvec2 ray_box(in ray r, in vec3 pos, in vec3 size) \n{\n    vec3 m = 1.0 / r.dir; // can precompute if traversing a set of aligned boxes\n    vec3 n = m * (r.pos - pos);   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m) * size;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float t_near = max( max( t1.x, t1.y ), t1.z );\n    float t_far = min( min( t2.x, t2.y ), t2.z );\n    \n    if( t_near > t_far || t_far < 0.0) \n        return vec2(1000,-1000); // no intersection\n        \n    return vec2(t_near,t_far);\n}\n\n\n////////////////////\n//hexagonal mappimg\n////////////////////\n///////////\nconst vec2 HEX_BOX = vec2(1, sqrt(0.75) / 1.5);//hex bounding box\nconst vec2 INV_BOX = 1.0 / HEX_BOX;            //hex bounding box inverse\nconst vec2 HEX_ROT = normalize(HEX_BOX);       //uv rotation for hex tiles\n///////////////////////////////////////\n/*\n            HEX_BOX.x\n         |<----------->|\n         \n         C------#------C  ---\n         |  \"-_ # _-\"  |   A\n         |     ###     |   |\n         |  ### . ###  |   |\n         ###    .    ###   |\n         #  \"-_ . _-\"  #   |\n         #     -C-     #   | HEX_BOX.y\n         # _-\"  .  \"-_ #   |\n       #####    .    ###   |\n    ###  |  ### . ###  |   |\n  ##     |    _###_    |   |\n  #      | _-\"  #  \"-_ |   V\n  #      C------#------C  ---\n  #             #       \n  ##           ###      \n    ###     ###   ###   \n       #####         ###\n         #             #\n  C      #      C      #\n         \n         \n         \n         C = hexagon centre (one in centre of box four on its corners)\n         # = hexagon borders\n         | = box and box symetry borders\n       \n*/\n////////////////////////////////////////\n\n\n\nvec2 hex_centre(in vec2 uv)\n{\n    //domain repetition\n    vec2 centre = round(uv*HEX_BOX)*INV_BOX;\n    \n    vec2 side = uv - centre;\n    \n    vec2 hex = abs(side);\n    \n    //select origin (domain centre or domain corner)\n    if(hex.y > (0.333-hex.x*0.333)*INV_BOX.y)\n        centre += 0.5*INV_BOX * sign(side);//select corner\n    \n    return centre;\n}\n\n\n\nvec2 hex_tile(in vec2 hex_uv)\n{\n    vec2 tile = abs(hex_uv.yx);//abs AND flip!!!\n    \n    \n    if(tile.x > tile.y*0.333*INV_BOX.y)//test fliped\n        tile *= mat2(-HEX_ROT.y,HEX_ROT.x, HEX_ROT);//rotate fliped\n        \n    if(hex_uv.y < 0.0)//mirror x to shape a \"triangle\"\n        tile.x = -tile.x;\n     \n     return tile;\n}\n\n\n\n\n\n\n\n\n\n\nvec2 map_hex(vec2 uv)\n{\n    vec3 t;\n    \n    t.x =  dot(uv.xy,vec2(0.559, 1));\n    t.y = -dot(uv.xy,vec2(0.559,-1));\n    t.z = uv.x * 1.118;\n    \n    vec3 p = fract(t*0.5);\n    vec3 b = fract(t);\n    \n    float sum = floor(t.x) + floor(t.y);\n    \n    float fr = mod(sum, 6.);\n    \n    vec2 res;\n    \n    if(p.z < 0.5)\n    {\n        fr = mod(sum + 3., 6.);\n    }\n    \n    \n        if(fr < 6.)\n        res = vec2(1.-b.y,1.-b.z);\n        if(fr < 5.)\n        res = vec2(   b.y,1.-b.x);\n        if(fr < 4.)\n        res = vec2(1.-b.z,   b.x);\n        \n        if(fr < 3.)\n        res = vec2(1.-b.x,   b.z);\n        if(fr < 2.)\n        res = vec2(   b.x,1.-b.y);\n        if(fr < 1.)\n        res = vec2(   b.z,   b.y);\n        \n        \n        \n    return\n    vec2(\n    1. - (res.x + res.y * 0.5),\n    res.y * 0.894\n    );\n}\n\n\n\n////////////////////\n//text rendering\n////////////////////\n\n\nfloat show_text(vec2 pos,ivec2 text, float text_size)\n{\n    //inside text\n    if(abs(pos.y) < text_size && abs(pos.x) < text_size * 8.)\n    {\n        //get glyph\n        int i = 7 - int(floor((pos.x + text_size * 8.) / text_size / 2.));\n        \n        //lookup glyph codepoint\n        float glyph_codepoint = float(i > 3 ? (text.x >> ((i-4) * 8)) & 255 : (text.y >> (i * 8)) & 255);\n        \n        //get glyph uv\n        vec2 gly_uv = fract((pos + vec2(8.*text_size,text_size)) / text_size / 2.);\n        \n        //zoom in on glyph to make it larger (causes some clipping)\n        gly_uv = (gly_uv -0.5) * vec2(0.6,0.6) + 0.5;\n       \n        //lookup glyph sdf\n        return get_glyph(gly_uv, glyph_codepoint) - 0.5;\n    }\n    //not inside text\n    return 1.0;\n}\n\n\n////////////////////\n////////////////////\n////////////////////\n\n////////////////////\n//main sdf function\n////////////////////\nfloat sdf(vec3 pose, bool inside)\n{\n    float d = box(pose - vec3( 0.00, 0.00, 1.00),  vec3(0.50,0.50,1.00));\n    \n    vec3 pos = pose;\n    vec3 rot = pos;\n    \n    rot.xy -= vec2(0.36,-0.4);\n\n    rot.xy = n_rotate(rot.xy,0.245);\n\n    rot.xy += vec2(0.36,-0.4);\n    \n    float door_box = box(rot    -vec3(0.18,-0.425,0.82),  vec3(0.18,0.04,0.67));\n    \n    if(door_box < 0.001)\n        pos = rot;\n        \n        \n    \n    //use symetries:\n        \n        //mirror at axes\n        vec3 pos_x  = vec3(abs(pos.x),abs(pos.y),pos.z);\n        \n        //mirror at diagonals\n        vec3 pos_xx = pos_x.x < pos_x.y  ?  pos_x.xyz  :  pos_x.yxz;\n        \n    \n    \n    if(d < 0.2)\n    {\n        d = 1000.;\n        \n        \n        if(pos.z > 1.55)\n        {\n            float roof = box(pos    -vec3( 0.00, 0.00,1.74),  vec3(0.40,0.40,0.06));//roof2\n            roof = max(roof, pln(pos_xx -vec3( 0.00, 0.00,1.80),  vec3(0.00,0.148,0.989)));//roof2 slope\n            d = min(d,roof);\n            \n            d = min(d, box(pos    -vec3( 0.00, 0.00,1.79),  vec3(0.09,0.09,0.03)));//light base\n            float tar_rad = length(pos.xy);\n            d = min(d, max(tar_rad - 0.05, abs(pos.z - 1.84) - 0.05));//light pole\n            d = min(d, max(tar_rad - 0.06, abs(pos.z - 1.91) - 0.05));//light\n            d = min(d, max(dot(vec2(0.447,0.894),vec2(tar_rad,pos.z-2.)),1.96-pos.z));//light roof\n        }\n        else\n        {\n            if(door_box > 0.001)\n                d = min(d,door_box+0.001);\n        \n            if(pos.z > 0.73)\n            {\n                d = min(d, box(pos_xx -vec3(0.20,.425,1.30),  vec3(0.15,0.01,.005)));//window bar\n                d = min(d, box(vec3(abs(pos_xx.x-.19),pos_xx.yz)-vec3(0.045,0.425,1.30),  vec3(.005,0.01,0.15)));//window vertical bar\n                \n                \n                d = min(d, box(pos_xx -vec3(0.20,0.425,1.30),  vec3(0.15,.005,0.15)) + 0.001+ 0.001*sin(pos_xx.x*400.));//window\n                \n                if(pos.y < -0.4)\n                {\n                    d = min(d, tor((max(vec3(0.0),abs(pos    + vec3( 0.30, 0.44,-0.98))+vec3(-0.003,0,-0.02))).yxz,  vec2(0.01,0.002)));//phone handle\n                    \n                    d = min(d, box(vec3(abs(pos.x+.19)-0.11,pos.yz)    -vec3(0.,-0.435,0.97),  vec3(0.01,0.005,0.13)));//phone sign border vertical\n                    d = min(d, box(vec3(pos.xy,abs(pos.z-.97)-0.12)    -vec3(-0.19,-0.435,0.00),  vec3(0.10,0.005,0.01)));//phone sign border horizontal\n                    \n                    d = min(d, cheap_cyl((rot    + vec3(-0.04,.441,-0.98)).xzy,.017,0.005));//lock\n                }\n                \n                \n            }\n            else\n            {\n                float base = box(pos    -vec3( 0.00,0.00,0.06),  vec3(0.50,0.50,0.06));//base\n                base = max(base, pln(pos_xx -vec3( 0.00,0.47,0.12),  vec3(0.00,0.514,0.857)));//base chamfer (slope)\n                d = min(d,base);\n            }\n            \n            d = min(d, box(vec3(pos_xx.xy,(pos_xx.z-0.15) - round((pos_xx.z-0.15)*3.05)/3.05) -vec3(0.19,0.425,0.0),  vec3(0.13,0.02,0.03)));//horizontal bars\n            \n            \n            d = min(d, box(pos_xx -vec3(0.20,.425,0.65),  vec3(0.15,0.01,0.50)));//panels\n            \n            d = min(d, box(vec3(abs(pos_xx.x-0.19)+0.19,pos_xx.yz) -vec3(0.35,.425,0.82),  vec3(0.03,0.02,0.70)));//door vertical bar\n            \n            d = min(d, box(pos_xx -vec3(0.00,0.44,0.82),  vec3(0.02,0.01,0.70)));//center vertical bar\n            \n            d = min(d, box(pos_xx -vec3(.365,0.45,0.82 ),  vec3(.005,.005,0.70)));//border vertical bar\n            d = min(d, box(pos_xx -vec3(0.00,0.45,1.485),  vec3(0.36,.005,.005)));//border horizontal bar\n        }\n        \n        d = min(d, box(pos_xx -vec3( 0.00, 0.45, 1.55),  vec3(0.45,.05,0.06)));//sign\n        d = max(d,-box(pos_xx -vec3( 0.00, 0.52, 1.55),  vec3(0.325,0.03,.04)));//sign inside\n        \n        d = min(d, box(pos_x  -vec3( .42, .42, 0.90),  vec3(0.05,0.05,0.78)));//corner pole\n        \n        d = min(d, box(pos    -vec3( 0.00, 0.00, 1.655),  vec3(0.425,0.425,0.055)));//roof1\n        \n        if(inside)\n            d = max(d,-box(pos    -vec3(0.,0.45,0.81),  vec3(0.36,.2,0.68)));//open back\n        \n        d = max(d,-box(pose    -vec3(0.18,-0.425,0.82),  vec3(0.18,0.04,0.67)));//open door\n        \n        if(door_box < 0.001)\n                d = max(d,door_box+0.001);\n    }\n    \n    \n    //interior\n    if(inside)\n    {\n        vec3 ipos = pos;\n        ipos.y -= 10.;\n        \n        ipos.z -= 0.14;\n        \n        vec2 pl = n_polar(ipos.xy);\n        \n        float bound_rad = length(ipos-vec3( 0.00, 0,1.));\n        \n        \n        if(6. < bound_rad)\n        {\n            vec3 tile = vec3(pl,ipos.z);\n\n\n            ////wall patern\n            tile.x = (tile.x*72.0 - round(tile.x*72.0-0.5) - 0.5)/72.0;\n\n            tile.xy = n_un_polar(tile.xy);\n\n            tile.xz = map_hex(2.14*tile.xz) / 2.14;\n\n            tile.y -= 7.8;\n\n\n            float ball = abs(sph(tile - vec3(0,5.80,0),4.))-0.01;\n            float cutout = cheap_cyl((tile - vec3(cos(pi2/6.)*0.5,3.7,sin(pi2/6.)*0.5)).xzy    ,   .37, 10.);//cutout\n\n            float ball2 = abs(sph(tile - vec3(0,-2.18,0),4.))-0.01;\n            float cutout2 = cheap_cyl((tile - vec3(-cos(pi2/6.)*0.5,3.7,sin(pi2/6.)*0.5)).xzy    ,   .37, 10.);//cutout\n\n            ball  = max(ball ,-cutout );\n            ball2 = max(ball2,-cutout2);\n\n\n\n            float deco = cheap_cyl((tile).xzy -vec3(0,0,-2.8)   ,   .37, 4.65);//hole\n\n            deco = max(deco,-ball);\n            deco = max(deco,-ball2);\n\n            ////\n\n            float dome = abs(pln(tile-vec3(0,1.9,0),vec3(0,1,0))) - 0.1;//dome\n            dome = max(dome,-box(pos    - vec3( 0.00, 0.00,0.84),  vec3(0.43,.6,0.76)));\n\n\n            dome = max(dome,-deco);\n\n            d = min(d,dome+0.02);\n\n            dome = max(dome,tile.z-0.41 );\n\n            d = min(d,dome);\n\n            d = min(d,pln(pos - vec3(0,0,9),vec3(0,0,-1)));//inside roof\n\n\n            vec3 things = vec3((pl.x*24.0 - round(pl.x*24.0-0.5) - 0.5)/24.0, pl.y, ipos.z);\n\n            things.xy = n_un_polar(things.xy);\n\n            things-=vec3(0,8.,1.64 * round(pl.x*24.0+0.5));\n\n\n\n            things.z = (things.z*0.5 - round(things.z*0.5)) * 2.;\n\n            things.xz = hex_tile(things.zx);\n            \n\n            if(round(pl.x*24.0-0.5) > -12. && round(pl.x*24.0-0.5) < 11.)\n            {\n                d = min(d, box(things,vec3(0.4,0.02,0.4)));//blue hex\n                things -= vec3(0.,-0.12,0.6);\n                d = min(d, box(vec3(things.x,n_rotate(things.yz,-0.1)),vec3(0.8,0.02,0.2))+ 0.006+ 0.006*sin(things.z*100.));//hex surounding\n            }\n            else\n            {\n                things -= vec3(0.,-0.12,0.6);\n                d = min(d, box(vec3(things.x,n_rotate(things.yz,-0.1)),vec3(0.8,0.0,0.2))+0.1);//sdf placeholder\n            }\n\n            d = min(d, pln(ipos    ,  vec3(0,0,1)));//floor\n        }\n        if(8.6 > bound_rad)\n        {\n            d = min(d, max(dot(vec2(0.447,0.894),vec2(pl.y,ipos.z-1.8)),1.0-ipos.z));//console\n            \n            d = min(d, tor((ipos    - vec3( 0.00, 0, 1.0)).xzy,   vec2(1.6,0.05)));//console\n            \n            \n            d = min(d, max(pl.y - 5.8, abs(ipos.z - 0.32) - 0.02));//stairs\n            d = min(d, max(pl.y - 7.8, abs(ipos.z       ) - 0.16));//stairs\n            d = min(d, max(pl.y - 5.7, abs(ipos.z       ) - 0.30));//stairs light\n            \n            \n            vec3 hex = vec3(hex_tile(ipos.xy),ipos.z);\n            \n            hex.x = abs(hex.x);\n            \n            d = min(d, cap(hex , vec3( 0.00, 1.62, 1.05), vec3( 0.00, 0.9 , 1.4),   0.05));//console_\n            d = min(d, cop(hex , vec3( 0.00, 0.75, 0.6), vec3( 0.00, 1.2 , 0.1),   0.2,0.3));//console_\n            d = min(d, cop(hex , vec3( 0.00, 0.75, 0.6), vec3( 0.00, 0.7 , 0.9),   0.2,0.2));//console_\n            d = min(d, max(pl.y - 1.0, abs(ipos.z - 1.43) - 0.03)); //upper console\n            \n            d = max(d,-max(pl.y - 0.7, abs(ipos.z - 0.74) - 2.0) );//console hole\n            \n            float p1 = cop(ipos, vec3( 0.00, 0.0,0.14), vec3( 0.00, 0.0,3.14),0.65, 0.40);//pylon\n            float p2 = cop( hex, vec3( 0.00, 5.0,0.14), vec3( 0.00, 5.4,2.14), 0.6, 0.51);//suround pylon\n            float p3 = cop( hex, vec3( 0.00, 5.4,2.14), vec3( 0.00, 4.0,3.94), 0.5, 0.41);//suround pylon\n            float p4 = cop( hex, vec3( 0.00, 4.0,3.94), vec3( 0.00, 2.0,3.54), 0.4, 0.30);//suround pylon\n            \n            vec3 drr;\n            \n            if(min(min(d,p2),min(p3,p4)) > p1)\n                drr = ipos;\n                \n            else if(min(d,min(p3,p4)) > p2)\n                drr = vec3(hex.x+2., n_rotate(hex.yz, .04));\n                \n            else if(min(d,p4) > p3)\n                drr = vec3(hex.x+2., n_rotate(hex.yz,-.10));\n                \n            else if(d > p4)\n                drr = vec3(hex.x+2., n_rotate(hex.yz,-.28));\n            \n            float cr = 0.12 * noise3d2(vec3(10,10,1.)*drr).x;\n            \n            d = min(d, p1 + cr);//pylon\n            d = min(d, p2 + cr);//suround pylon\n            d = min(d, p3 + cr);//suround pylon\n            d = min(d, p4 + cr);//suround pylon\n            \n            d = min(d, cyl((hex - vec3( 0.00, 4.0,3.94)).yzx, 0.25, 0.25) - 0.1);// pylon joint\n            d = min(d, cyl((hex - vec3( 0.00, 5.4,2.14)).yzx, 0.25, 0.35) - 0.1);// pylon joint\n            \n        }\n        \n    }\n     \n    return (d);\n}\n\nfloat shadow_sdf(vec3 pose, bool inside)\n{\n    \n    vec3 pos = pose;\n    vec3 rot = pos;\n    \n    rot.xy -= vec2(0.36,-0.4);\n\n    rot.xy = n_rotate(rot.xy,0.245);\n\n    rot.xy += vec2(0.36,-0.4);\n    \n    float door_box = box(rot    -vec3(0.18,-0.425,0.82),  vec3(0.18,0.04,0.67));\n    \n    if(door_box < 0.001)\n        pos = rot;\n        \n        \n    \n    //use symetries:\n        \n        //mirror at axes\n        vec3 pos_x  = vec3(abs(pos.x),abs(pos.y),pos.z);\n        \n        //mirror at diagonals\n        vec3 pos_xx = pos_x.x < pos_x.y  ?  pos_x.xyz  :  pos_x.yxz;\n        \n    \n    \n    \n     float d = 1000.;\n    \n    \n    if(pos.z > 1.55)\n    {\n        float roof = box(pos    -vec3( 0.00, 0.00,1.74),  vec3(0.40,0.40,0.06));//roof2\n        roof = max(roof, pln(pos_xx -vec3( 0.00, 0.00,1.80),  vec3(0.00,0.148,0.989)));//roof2 slope\n        d = min(d,roof);\n        \n        d = min(d, box(pos    -vec3( 0.00, 0.00,1.79),  vec3(0.09,0.09,0.03)));//light base\n        float tar_rad = length(pos.xy);\n        d = min(d, max(tar_rad - 0.05, abs(pos.z - 1.84) - 0.05));//light pole\n        d = min(d, max(tar_rad - 0.06, abs(pos.z - 1.91) - 0.05));//light\n        d = min(d, max(dot(vec2(0.447,0.894),vec2(tar_rad,pos.z-2.)),1.96-pos.z));//light roof\n    }\n    else\n    {\n        if(door_box > 0.001)\n            d = min(d,door_box+0.001);\n    \n        if(pos.z > 0.73)\n        {\n            d = min(d, box(pos_xx -vec3(0.20,.425,1.30),  vec3(0.15,0.01,.005)));//window bar\n            d = min(d, box(vec3(abs(pos_xx.x-.19),pos_xx.yz)-vec3(0.045,0.425,1.30),  vec3(.005,0.01,0.15)));//window vertical bar\n            \n            \n            d = min(d, box(pos_xx -vec3(0.20,0.425,1.30),  vec3(0.15,.005,0.15)) + 0.001+ 0.001*sin(pos_xx.x*400.));//window\n            \n            if(pos.y < -0.4)\n            {\n                d = min(d, tor((max(vec3(0.0),abs(pos    + vec3( 0.30, 0.44,-0.98))+vec3(-0.003,0,-0.02))).yxz,  vec2(0.01,0.002)));//phone handle\n                \n                d = min(d, box(vec3(abs(pos.x+.19)-0.11,pos.yz)    -vec3(0.,-0.435,0.97),  vec3(0.01,0.005,0.13)));//phone sign border vertical\n                d = min(d, box(vec3(pos.xy,abs(pos.z-.97)-0.12)    -vec3(-0.19,-0.435,0.00),  vec3(0.10,0.005,0.01)));//phone sign border horizontal\n                \n                d = min(d, cheap_cyl((rot    + vec3(-0.04,.441,-0.98)).xzy,.017,0.005));//lock\n            }\n            \n            \n        }\n        else\n        {\n            float base = box(pos    -vec3( 0.00,0.00,0.06),  vec3(0.50,0.50,0.06));//base\n            base = max(base, pln(pos_xx -vec3( 0.00,0.47,0.12),  vec3(0.00,0.514,0.857)));//base chamfer (slope)\n            d = min(d,base);\n        }\n        \n        d = min(d, box(vec3(pos_xx.xy,(pos_xx.z-0.15) - round((pos_xx.z-0.15)*3.05)/3.05) -vec3(0.19,0.425,0.0),  vec3(0.13,0.02,0.03)));//horizontal bars\n        \n        \n        d = min(d, box(pos_xx -vec3(0.20,.425,0.65),  vec3(0.15,0.01,0.50)));//panels\n        \n        d = min(d, box(vec3(abs(pos_xx.x-0.19)+0.19,pos_xx.yz) -vec3(0.35,.425,0.82),  vec3(0.03,0.02,0.70)));//door vertical bar\n        \n        d = min(d, box(pos_xx -vec3(0.00,0.44,0.82),  vec3(0.02,0.01,0.70)));//center vertical bar\n        \n        d = min(d, box(pos_xx -vec3(.365,0.45,0.82 ),  vec3(.005,.005,0.70)));//border vertical bar\n        d = min(d, box(pos_xx -vec3(0.00,0.45,1.485),  vec3(0.36,.005,.005)));//border horizontal bar\n    }\n    \n    d = min(d, box(pos_xx -vec3( 0.00, 0.45, 1.55),  vec3(0.45,.05,0.06)));//sign\n    d = max(d,-box(pos_xx -vec3( 0.00, 0.52, 1.55),  vec3(0.325,0.03,.04)));//sign inside\n    \n    d = min(d, box(pos_x  -vec3( .42, .42, 0.90),  vec3(0.05,0.05,0.78)));//corner pole\n    \n    d = min(d, box(pos    -vec3( 0.00, 0.00, 1.655),  vec3(0.425,0.425,0.055)));//roof1\n    \n    if(inside)\n        d = max(d,-box(pos    -vec3(0.,0.45,0.81),  vec3(0.36,.2,0.68)));//open back\n    \n    d = max(d,-box(pose    -vec3(0.18,-0.425,0.82),  vec3(0.18,0.04,0.67)));//open door\n    \n    if(door_box < 0.001)\n         d = max(d,door_box+0.001);\n      \n    \n    \n     \n    return (d);\n}\n\n\n////////////////////\n//normal from sdf function\n////////////////////\nvec3 normal(vec3 pos, float dist, bool inside) \n{\nif(pos.z < 0.0001)\n    return vec3(0,0,1);\n    \n    float h = 0.0001 * dist; \n    //const vec2 k = vec2(1,-1);\n    //return normalize( k.xyy*sdf( pos + k.xyy*h ,inside) + \n    //                  k.yyx*sdf( pos + k.yyx*h ,inside) + \n    //                  k.yxy*sdf( pos + k.yxy*h ,inside) + \n    //                  k.xxx*sdf( pos + k.xxx*h ,inside) );\n                      \n                      \n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdf(pos + e * h,inside);\n    }\n    return normalize(n);\n}\n\n\n////////////////////\n//test if ray goes trough door\n////////////////////\nfloat portal_intersect(ray r)\n{\n   float dist = - (r.pos.y + 0.425) / r.dir.y;\n    \n    if(dist > 0.)\n    {\n        vec2 uv = r.pos.xz + r.dir.xz * max(0.0,dist);\n\n        uv = abs(uv - vec2(0.18, 0.82)) - vec2(0.18,0.67);\n\n        if(max(uv.x, uv.y) < 0.0)\n        {\n            return dist;\n        }\n    }\n    \n    return 1000000.;\n}\n\n\n\n\n\n\n////////////////////\n// C++ code used to convert text to hexadecimal integers:\n////////////////////\n\n\n/*\n#include <iostream>\n#include <string>\n\nvoid write_to_ints()\n{\n    std::string data =\n    \"POLICE  \"s + \"BOX     \"s + \"PUBLIC  \"s + \"CALL    \"s +\n    \"POLICE T\"s + \"ELEPHONE\"s +\n    \"FREE FOR\"s +\n    \"USE OF P\"s + \"UBLIC   \"s +\n    \"ADVICE &\"s + \"ASSISTAN\"s + \"CE      \"s +\n    \"OBTAINAB\"s + \"LE IMMED\"s + \"IATELY  \"s +\n    \"OFFICERS\"s + \"& CARS  \"s +\n    \"RESPOND \"s + \"TO ALL C\"s + \"ALLS    \"s +\n    \"PULL TO \"s + \"OPEN    \"s;\n    \n    std::string lookup = \"0123456789abcdef\";\n    \n    for(int i = 0; i < data.size(); i++)\n    {\n        if(i % 4 == 0)\n            std::cout << \", 0x\";\n        \n        std::cout << lookup[data[i] / 16] << lookup[data[i] % 16];\n    }\n}\n*/\n\n\n////////////////////\n//get color and normal map\n////////////////////\nvec4 sdf_color_normal(vec3 pose, float dist, bool inside,inout vec3 nor)\n{\n    float pad = dist * 0.002;\n    \n    vec3 pos = pose;\n    vec3 rot = pos;\n    \n    rot.xy -= vec2(0.36,-0.4);\n\n    rot.xy = n_rotate(rot.xy,0.245);\n\n    rot.xy += vec2(0.36,-0.4);\n    \n    if(dist * 0.001 > box(rot    -vec3(0.18,-0.425,0.82),  vec3(0.18,0.04,0.67)))\n        pos = rot;\n            \n    //use symetries\n    \n    // rotate by 90° segments\n    vec3 pos_x  = abs(pos.x) < abs(pos.y)  ?  vec3(pos.y < 0.0 ? pos.x : -pos.x, abs(pos.y), pos.z)  :  vec3(pos.x < 0.0 ? -pos.y : pos.y, abs(pos.x), pos.z);\n    \n    \n    //mirror x axis\n    vec3 pos_xx = vec3(abs(pos_x.x), pos_x.y, pos_x.z);\n    \n    \n    \n    \n    vec4 color = vec4(0.25,0.15,0.1,0.2);\n    vec4 ns_scale = vec4(10,10,1,0.1) * vec4(pos,1.);\n    \n    \n    \n    if(inside)\n    {\n        \n        vec3 ipos = pos;\n        ipos.y -= 10.;\n        ipos.z -= 0.14;\n        \n        if(pad > (length(ipos   + vec3( 0.00,   0, 1))-8.7)-0.3) color = vec4(3.,1.2,0.4,0.4);//all pylons\n        \n        \n        if(pad > max(cheap_cyl(ipos          - vec3( 0.00,   0, 0.14),   2., 2.), - cheap_cyl(ipos    - vec3( 0.00, 0,0.74),   0.7, 2.))) color = vec4(0.25,0.15,0.1,1.);//console\n        \n        if(pad > pln(ipos          - vec3( 0.00,   0, 0.34),  vec3(0,0,1))) color = vec4(0.1);//inside floor\n        \n        \n        if(pad > cheap_cyl(ipos          - vec3( 0.00,   0, 0.12),   5.7, 0.2)) color = vec4(3.,1.5,0.0,0.4);//stairs light\n    }\n    \n    \n    \n    if(pad > box(pos    - vec3( 0.00, 0.00,1.00),  vec3(0.50,0.50,1.00)))   {color = vec4(0.05,0.20,0.30,0.10);ns_scale = vec4(400,400,10,0.15) * vec4(pos,1.);}//tardis blue\n    //horizontal wood\n    if(pad > box(vec3(pos_xx.xy,(pos_xx.z-0.15) - round((pos_xx.z-0.15)*3.05)/3.05) -vec3(0.19,0.425,0.0),  vec3(0.13,0.02,0.03))) ns_scale = vec4(10,400,400,0.15) * vec4(pos_xx,1.);//horizontal bars\n    if(pad > box(pos_xx -vec3( 0.00, 0.45, 1.55),  vec3(0.45,.05,0.06))) ns_scale = vec4(10,400,400,0.15) * vec4(pos_xx,1.);//sign\n    if(pad > box(pos    -vec3( 0.00,0.00,0.06),  vec3(0.50,0.50,0.06))) ns_scale = vec4(10,400,400,0.1) * vec4(pos_xx,1.5);//base\n    if(pad > box(vec3(pos.xy,abs(pos.z-.97)-0.12)    -vec3(-0.19,-0.435,0.00),  vec3(0.10,0.005,0.01))) ns_scale = vec4(10,400,400,0.1) * vec4(pos_xx,1.);//phone horizontal\n    \n    if(pad > box(pos_xx - vec3( 0.00, 0.46,1.55),  vec3(0.325,0.03,.04)))  {color = vec4(0.00,0.00,0.00,1.00); ns_scale = vec4(0);//sign\n    \n    \n    \n    float gly = 20.;\n        \n        gly = min(gly,show_text(pos_x.xz - vec2(-.11,1.55),ivec2(0x504f4c49, 0x43452020), 0.024));//\"POLICE  \"\n        gly = min(gly,show_text(pos_x.xz - vec2(0.33,1.55),ivec2(0x424f5820, 0x20202020), 0.024));//\"BOX     \"\n        gly = min(gly,show_text(pos_x.xz - vec2(0.08,1.565),ivec2(0x5055424c, 0x49432020), 0.01));//\"PUBLIC  \"\n        gly = min(gly,show_text(pos_x.xz - vec2(.105,1.535),ivec2(0x43414c4c, 0x20202020), 0.01));//\"CALL    \"\n        if(gly < 0.0)\n            color = vec4(1);\n    }\n    if(pad > pln(pos    -vec3(0)                 ,vec3(0.00,0.00,1.00) ))   color = vec4(0.30,0.25,0.20,0.01);//floor\n    if(pad > cheap_cyl(pos    - vec3( 0.00, 0.00, 1.91),  0.06, 0.05 ))   color = vec4(1);//light\n    \n    if(!inside)\n    {\n        if(pad > box(pos    - vec3(-0.19,-0.425, 0.97),  vec3(0.10,0.01,0.11)))  {color = vec4(0.00,0.00,0.00,1.00); ns_scale = vec4(0);//phone sign inside\n\n            float gly = 20.;\n            \n            \n            \n            gly = min(gly,show_text(pos.xz - vec2(-.237,1.055),ivec2(0x504f4c49, 0x43452054), .006));//\"POLICE T\"\n            gly = min(gly,show_text(pos.xz - vec2(-.142,1.055),ivec2(0x454c4550, 0x484f4e45), .006));//\"ELEPHONE\"\n            // \\n\n            // \\n\n            gly = min(gly,show_text(pos.xz - vec2(-.190,1.025),ivec2(0x46524545, 0x20464f52), .005));//\"FREE FOR\"\n            // \\n\n            gly = min(gly,show_text(pos.xz - vec2(-.220,1.010),ivec2(0x55534520, 0x4f462050), .005));//\"USE OF P\"\n            gly = min(gly,show_text(pos.xz - vec2(-.140,1.010),ivec2(0x55424c49, 0x43202020), .005));//\"UBLIC   \" \n            // \\n\n            // \\n\n            gly = min(gly,show_text(pos.xz - vec2(-.235,0.985),ivec2(0x41445649, 0x43452026), .004));//\"ADVICE &\"\n            gly = min(gly,show_text(pos.xz - vec2(-.160,0.985),ivec2(0x41535349, 0x5354414e), .004));//\"ASSISTAN\" \n            gly = min(gly,show_text(pos.xz - vec2(-.095,0.985),ivec2(0x43452020, 0x20202020), .004));//\"CE      \" \n            // \\n\n            gly = min(gly,show_text(pos.xz - vec2(-.247,0.970),ivec2(0x4f425441, 0x494e4142), .004));//\"OBTAINAB\" \n            gly = min(gly,show_text(pos.xz - vec2(-.182,0.970),ivec2(0x4c452049, 0x4d4d4544), .004));//\"LE IMMED\" \n            gly = min(gly,show_text(pos.xz - vec2(-.117,0.970),ivec2(0x49415445, 0x4c592020), .004));//\"IATELY  \" \n            // \\n\n            // \\n\n            gly = min(gly,show_text(pos.xz - vec2(-.220,0.940),ivec2(0x4f464649, 0x43455253), .004));//\"OFFICERS\"\n            gly = min(gly,show_text(pos.xz - vec2(-.150,0.940),ivec2(0x26204341, 0x52532020), .004));//\"& CARS  \"\n            // \\n\n            gly = min(gly,show_text(pos.xz - vec2(-.190,0.925),ivec2(0x52455350, 0x4f4e4420), .004));//\"RESPOND \" \n            // \\n\n            gly = min(gly,show_text(pos.xz - vec2(-.205,0.910),ivec2(0x544f2041, 0x4c4c2043), .004));//\"TO ALL C\"\n            gly = min(gly,show_text(pos.xz - vec2(-.140,0.910),ivec2(0x414c4c53, 0x20202020), .004));//\"ALLS    \"\n            // \\n\n            // \\n\n            gly = min(gly,show_text(pos.xz - vec2(-.215,0.885),ivec2(0x50554c4c, 0x20544f20), .006));//\"PULL TO \"\n            gly = min(gly,show_text(pos.xz - vec2(-.115,0.885),ivec2(0x4f50454e, 0x20202020), .006));//\"OPEN    \"\n            \n            if(gly < 0.0)\n                color = vec4(1);\n        }\n        \n        if(pad > tor((max(vec3(0.0),abs(pos    + vec3( 0.30, 0.44,-0.98))+vec3(-0.003,0,-0.02))).yxz,  vec2(0.01,0.002)))   color = vec4(0.5,0.5,0.5,1.);//phone handle\n        \n    \n    }\n    \n        if(pad > cheap_cyl((pos    + vec3(-0.04,.441,-0.98)).xzy,.017,0.005))   color = vec4(0.2,0.15,0.1,1.);//lock\n    \n    if(inside)\n    {\n        \n        vec3 ipos = pos;\n        ipos.y -= 10.;\n        ipos.z -= 0.14;\n        \n        vec2 pl = n_polar(ipos.xy);\n        \n            \n        vec3 tile = vec3(pl,ipos.z);\n        \n        \n        tile.x = (tile.x*72.0 - round(tile.x*72.0-0.5) - 0.5)/72.0;\n        \n        tile.xy = n_un_polar(tile.xy);\n        \n        tile.xz = map_hex(2.14*tile.xz) / 2.14;\n        \n        tile.y -= 7.8;\n        \n        \n        \n        \n        if(pad > abs(pln(tile-vec3(0,1.9,0),vec3(0,1,0))) - 0.1) color = vec4(0.25,0.15,0.1,0.2);//dome\n        \n        vec3 things = vec3((pl.x*24.0 - round(pl.x*24.0-0.5) - 0.5)/24.0, pl.y, ipos.z);\n            \n        things.xy = n_un_polar(things.xy);\n        \n        things-=vec3(0,8.,1.64 * round(pl.x*24.0+0.5));\n        \n        things.z = (things.z*0.5 - round(things.z*0.5)) * 2.;\n        \n        \n        things.xz = hex_tile(things.zx);\n        \n        \n        if(round(pl.x*24.0-0.5) > -12. && round(pl.x*24.0-0.5) < 11.)\n        {\n            if(pad > box(things,vec3(0.4,0.02,0.4))) color = vec4(0.4,0.4,2.0,0.6);//blue hex\n            things -= vec3(0.,-0.12,0.6);\n            if(pad > box(vec3(things.x,n_rotate(things.yz,-0.1)),vec3(0.8,0.02,0.2))) color = vec4(0.1,0.1,0.1,0.9);//hex surounding\n        }\n        \n        vec3 hex = vec3(hex_tile(ipos.xy),ipos.z);\n        \n        hex.x = abs(hex.x);\n\n        if(pad > cyl((hex - vec3( 0.00, 4.0,3.94)).yzx, 0.25, 0.25) - 0.1) color = vec4(0.25,0.15,0.1,0.2);// pylon joint\n        if(pad > cyl((hex - vec3( 0.00, 5.4,2.14)).yzx, 0.25, 0.35) - 0.1) color = vec4(0.25,0.15,0.1,0.2);// pylon joint\n        \n        if(pad > max(dot(vec2(0.447,0.894),vec2(pl.y,ipos.z-1.8)),1.0-ipos.z)) color = vec4(3.,1.2,0.4,0.4);//console\n        \n        if(pad > cap(hex, vec3( 1.4, 3.,0.35), vec3( .30, 4.3,0.35), 0.02)) color = vec4(3.,1.5,0.0,0.1);//floor light\n        if(pad > cap(hex, vec3( 1.5, 2.6,0.35), vec3( .37, 0.65,0.35), 0.02)) color = vec4(3.,1.5,0.0,0.1);//floor light\n            \n    }\n    if(pad > box(pos    -vec3( 0.00, 0.00,0.84),  vec3(0.42,0.42,0.76)))   color = vec4(0.6,0.6,0.6,0.1);//tardis not inside inside\n    if(pad > box(pos_xx -vec3(0.19,0.425,1.30),  vec3(0.13,0.005,0.15)))   {color = vec4(0.8,0.8,0.8,1.);ns_scale = vec4(0);}//window\n    \n    \n    \n    //\"normal map\"\n    nor = normalize(nor +  ns_scale.w * (2.0 * vec3(noise3d2(ns_scale.xyz),0.5) - 1.0));\n\n    \n    \n    return color;\n}\n\n\n   \n  \n//////////////////// \nray camera(vec2 uv)\n{\n    \n    //get pos and dir\n    vec2 dir = get_buf(0).xy;\n    vec3 pos = get_buf(1).xyz;\n    \n    //init ray\n    vec3 ray_pos = pos.xyz;\n    vec3 ray_dir = normalize(vec3(uv,2.0));\n    \n    \n    //rotate by pitch\n    ray_dir.zy = n_rotate(ray_dir.yz,dir.y);\n    \n    //rotate by yaw\n    ray_dir.xy = n_rotate(ray_dir.xy,dir.x);\n    \n    \n    return ray(ray_pos, ray_dir);\n}\n\n\n////////////////////\nvec3 sky_dome(vec3 dir, vec3 sun_dir, float routhness, bool inside)\n{\n    if(inside)\n        return vec3(0.1);\n        \n    //colors\n    vec3 sun_color   = vec3(1.0,0.8,0.6);\n    vec3 sky_color   = vec3(0.9,0.7,0.6);\n    vec3 fog_color   = vec3(0.5        );\n    vec3 floor_color = vec3(0.3        );\n    \n    \n    //\"sun\" effect\n    float sun_effect = pow(max(dot(dir, sun_dir), 0.0), 200.0 * routhness) * routhness;\n    //\n    \n    \n    //\"fog\" effect\n    float fog_effect = 1.0 - abs(dir.z);\n    \n    fog_effect = fog_effect * fog_effect;\n    //\n    \n    \n    \n    //sky or floor\n    vec3 dome_color = dir.z < 0.0 ? floor_color : sky_color;\n    \n    //mix in fog\n    dome_color = mix(dome_color, fog_color, fog_effect);\n    \n    //add sun \n    return dome_color + (sun_color * sun_effect);\n}\n\n\n\n    \n\n\n\n////////////////////\n\n//difuse\nfloat difuse(vec3 nor,vec3 sun)\n{\n    return max(dot(nor,sun),0.0);\n}\n\n//blinn reflection model\n//float specular(vec3 dir,vec3 sun, vec3 nor, float sharpnes)\n//{\n//    vec3 halfv = normalize(sun+(-dir));\n//    return pow(max(dot(nor,halfv),0.0), sharpnes);\n//}\n\n//phong reflection model\nfloat specular(vec3 dir,vec3 sun, vec3 nor, float sharpnes)\n{\n    vec3 ref = reflect(sun,nor);\n    return pow(max(dot(ref,dir),0.0), sharpnes/4.0);\n}\n\n//cheap fressnel aproxiation\nfloat fressnel(vec3 dir,vec3 nor)\n{\n    return pow(1.0 - max(dot(-dir,nor),0.0),5.);\n}\n\nfloat ambient_occlusion(vec3 pos, vec3 nor, bool inside)\n{\n    float scale = 0.05;\n    \n    return min(1.0, sdf(pos + scale * nor, inside) / scale);\n}\n\nfloat corner_effect(vec3 pos, vec3 nor, bool inside)\n{\n    float scale = 0.05;\n    \n    return min(1.,0.2 + 0.8 *abs(shadow_sdf(pos - scale * nor, inside)) / scale);\n}\n\nvec3 color_smooth_clamp(vec3 color, float scale)\n{\n    float rt_scale = sqrt(scale);//border between linear x and 1/x\n    \n    return min(color, 1.0 - min(vec3(rt_scale), scale / (color - 1.0 + 2.0 * rt_scale)));\n}\n\n\n////////////////////\n////////////////////\n////////////////////\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized coordinates (from -1 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    //raw camera\n    ray r = camera(uv);\n    bool inside = get_buf(1).w > 0.5;\n    \n    //sun pos\n    vec3 sun_dir = vec3(0.267,-0.802,0.535);\n    \n    //if nothing hit\n    vec3 color = sky_dome(r.dir, sun_dir,1.,inside == portal_intersect(r) > 10000.);\n    \n    \n    //march \n    ray tst = r;\n    float rad = 0.0;\n    float dist = 0.0;\n    vec2 box_int = ray_box(r,vec3(0,0,1.),vec3(0.501,0.501,1.001));\n    \n    if(!inside)\n    {\n        dist = max(0.0,box_int.x);\n    }\n    \n    tst.pos += dist * tst.dir;\n    \n    float change_dist = portal_intersect(r);\n    \n    bool inside2 = inside;\n    \n    if(box_int.x < box_int.y || inside)\n    {\n        for(int i = ZERO; i < 128;i++)\n        {\n            rad = sdf(tst.pos, inside2);\n\n            dist += rad;\n\n            if(dist > change_dist)\n                inside2 = !inside;\n\n            tst.pos += tst.dir * rad;\n\n\n            if(rad < 0.001 * dist || dist > box_int.y && !inside2)//using adaptive minimum seems to save time, but needs adaptive test in all functions\n                break;\n\n        }\n    }\n    if(dist > box_int.y && !inside2 || box_int.x > box_int.y && !inside2)\n    {\n        if((-r.pos.z / r.dir.z) > 0.0)\n        {\n        dist = -r.pos.z / r.dir.z;\n        tst.pos = r.pos += r.dir * dist;\n        rad = 0.0001 * dist;\n        }\n        else\n        rad = 100000000000.;\n    }\n    \n    \n    inside = inside2;\n\n    \n    //if hit\n    if(rad < dist * 0.001)\n    {\n        vec3 nor = normal(tst.pos,dist,inside);\n        \n        vec4 matr = sdf_color_normal(tst.pos,dist, inside, nor);\n        \n        \n        \n        \n        vec3 cl = matr.rgb;\n        \n        \n        \n        float df = difuse(nor,sun_dir);\n        \n        \n        \n        \n        if(df > 0.001)\n        {\n            //march shadow\n            ray s_tst = ray(tst.pos + nor * 0.0001, sun_dir);\n            \n            \n            float s_change_dist = portal_intersect(s_tst);\n            \n            float s_dist = 0.;\n            float s_rad  = 0.;\n            \n            vec2 s_box_int = ray_box(s_tst,vec3(0,0,1.),vec3(0.501,0.501,1.001));\n            \n            if(!inside)\n            {\n                s_dist = max(0.0, s_box_int.x);\n                \n                s_tst.pos += s_tst.dir * s_dist;\n            }\n            \n            bool s_inside = inside;\n            \n            if((!inside && s_box_int.x < s_box_int.y) || (inside && s_change_dist < 100000.0))\n            {\n                for(int i = ZERO; i < 64;i++)\n                {\n                    s_rad = shadow_sdf(s_tst.pos, s_inside);\n\n                    s_dist += s_rad;\n\n                    if(s_dist > s_change_dist)\n                        s_inside = !inside;\n\n                    s_tst.pos += s_tst.dir * s_rad;\n\n                    if(!s_inside && s_dist > s_box_int.y)\n                    {\n                        break;\n                    }\n\n                    if(s_rad < 0.001 * s_dist)\n                    {\n                        df = 0.0;\n                        break;\n                    }\n                }\n            }\n            else if(s_box_int.x < s_box_int.y || inside)\n            {\n                df = 0.0;\n            }\n        }\n        \n        \n        vec3 inside_light = vec3(0,10,9);\n        \n        if(inside)\n        {\n            vec3 inside_light_dir = normalize(inside_light - tst.pos);\n            df += difuse(nor,inside_light_dir) * 10. / dot2(inside_light - tst.pos);\n        }\n        \n        \n        \n        //ambient oclusion\n        float ao = ambient_occlusion(tst.pos, nor, inside);\n        \n        //darken cornrs\n        if(!inside)\n            ao = min(ao, corner_effect(tst.pos, nor, inside));\n        \n        //fressnel\n        float fr = fressnel(r.dir,nor);\n        \n        float spec = df > 0.001 ? specular(r.dir,sun_dir,nor,200. * matr.w) * matr.w : 0.; //beter on flat things?\n        \n        vec3 difuse_color = cl * (0.3 + 0.7*df) * (0.5 + 0.5 * ao);\n        vec3 fressnel_color = fr * ao * sky_dome(reflect(r.dir,nor),sun_dir,matr.w,inside);\n        \n        //final color mix\n        color = difuse_color + spec + fressnel_color;\n    }\n    \n    \n    \n    \n    //make eedges of over exposed(to bright) regions less obvious\n    color = color_smooth_clamp(color, 0.05);\n    \n    //gamma compression(correction)\n    color = pow(saturate(color), vec3(0.4545));\n\n    //output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//Copyright © 2021 efelo\n////////////////////\n////////////////////\n//game logic\n////////////////////\n////////////////////\n\n\n////////////////////\n//buffer storage:\n\n//adress 0: xy  = camera direction, zw = mouse_old\n//adress 1: xyz = camera position , w  = inside tardis dimension\n\n////////////////////\n//game logic\n\n\n//texture acces\nfloat get_key(int key)   {return texelFetch(iChannel1, ivec2(key,0), 0).x;}\nvec4 get_buf(int adress) {return texelFetch(iChannel0, ivec2(adress,0), 0);}\n\n\n//test if curent pos is oposite to last pos relative to tardis door\nvoid portal_intersect(vec3 pos_new, vec3 pos_old, inout bool inside)\n{\n    //translate\n    vec3 pos1 = pos_new + vec3(0,0.425, 0);\n    vec3 pos2 = pos_old + vec3(0,0.425, 0);\n    \n    //if not on same side of door\n    if(pos1.y * pos2.y < 0.0)\n    {\n        //intersection pos\n        float part = abs(pos1.y / (pos1.y - pos2.y));\n        \n        \n        \n        vec2 uv = mix(pos1.xz,pos2.xz,part);\n        \n        uv = abs(uv - vec2(0.18, 0.82)) - vec2(0.18,0.67);\n        \n        //intersection pos inside door\n        if(max(uv.x, uv.y) < 0.0)\n        {\n            //inverse side as traversing door always changes between inside and outside tardis\n            inside = !inside;\n        }\n    \n    }\n}\n\n\n////////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    //get buffer adress to write in\n    int adress = int(fragCoord.x);\n    \n    ////////////////////\n    \n    //update camera view direction\n    if(adress == 0)\n    {\n        //normalize mouse imput\n        vec4 mouse = iMouse / iResolution.y;\n        \n        \n        //get last camera direction \n        vec2 dir  = get_buf(0).xy;\n        //get last mouse position\n        vec2 last = get_buf(0).zw;\n        \n        \n        //initialize camera direction\n        if(iFrame < 20)\n            dir = vec2(0, 0.01);\n        \n        \n        //mouse active\n        if(iMouse.z > 0.0)\n        {\n            //test if old mouse was not active\n            if(last.x < 0.0)\n            {\n                //set old to new as no old available\n                last = mouse.xy;\n            }\n            //get delta\n            vec2 delta = mouse.xy - last;\n            //change direction by delta\n            dir += delta * .25;\n            //set old mouse pos to new mouse pos \n            last = mouse.xy;\n        }\n        else\n        {\n            //write that mouse is not active\n            last.x = -1.;\n        }\n        \n        //clamp pitch from going up side down\n        dir.y = clamp(dir.y,-0.25,0.25);\n\t\t\n        //write new camera direction\n        fragColor = vec4(dir, last);\n        \n        \n    }\n    \n    \n    ////////////////////\n    \n    \n    \n    //update camera position\n    if(adress == 1)\n    {\n        \n        //get old camera position\n        vec3 pos = get_buf(1).xyz;\n        //get old camera side\n        bool inside = get_buf(1).w > 0.5;\n        \n        //initialize camera position\n        if(iFrame < 20)\n        {\n            pos = vec3(0.01,-2.5,1.);\n            inside = false;\n        }\n        \n        //initialize camera position\n        if(iMouse.xy == vec2(0))\n        {\n            pos.x = 0.3 + 0.3*-cos(0.2*iTime);\n        }\n        \n\n        vec3 delta = \n        \n        //move left/right\n            vec3(\n         iTimeDelta * get_key(KEY_PX)\n        -iTimeDelta * get_key(KEY_NX)\n        +\n         iTimeDelta * get_key(KEY_PX2)// arrow keys\n        -iTimeDelta * get_key(KEY_NX2)\n        ,\n        //move forward/backward\n         iTimeDelta * get_key(KEY_PY)\n        -iTimeDelta * get_key(KEY_NY)\n        +\n         iTimeDelta * get_key(KEY_PY2)// arrow keys\n        -iTimeDelta * get_key(KEY_NY2)\n        ,\n        //move up/down\n         iTimeDelta * get_key(KEY_PZ)\n        -iTimeDelta * get_key(KEY_NZ)\n\t\t);\n        \n        //get old camera dir\n        vec2 dir = get_buf(0).xy;\n        \n        //translate input to current camera looking direction\n        delta.xy = -n_rotate(delta.xy, dir.x);\n        \n        vec3 old_pos = pos;\n        //move camera pos\n        pos += delta;\n        \n        \n        //check if moved trought tardis door and update inside\n        portal_intersect(pos, old_pos, inside);\n        \n        \n        //write new camera pos\n        fragColor.xyz = pos;\n        //write new side\n        fragColor.w = inside ? 1. : 0.;\n        \n    }\n    \n    \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//Copyright © 2021 efelo\n////////////////////\n////////////////////\n\n\n\n\n\n////////////////////\n//key maping\n////////////////////\n//WASD\nconst int KEY_PX = 65 +  0;//a    P = positive, N = negative\nconst int KEY_NX = 65 +  3;//d\nconst int KEY_PY = 65 + 18;//s\nconst int KEY_NY = 65 + 22;//w\n//ARROW KEYS\nconst int KEY_PX2 = 37;//left \nconst int KEY_NX2 = 39;//right\nconst int KEY_PY2 = 40;//up   \nconst int KEY_NY2 = 38;//down \n//UP/DOWN\nconst int KEY_PZ = 32;//space\nconst int KEY_NZ = 16;//shift\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n////////////////////\n//const vars\n////////////////////\nconst float pi = 3.14159265358979323846264338327950288;\nconst float pi2 = pi * 2.0;\nconst float iv_pi2 = 1.0 / pi2;\n\nconst float sq2 = normalize(vec3(1,1,0)).x;\nconst float sq3 = normalize(vec3(1)).x;\n\n\n\n\n\n\n\n\n\n////////////////////\n//math\n////////////////////\n\n\n\n\nvec3 saturate(vec3 val)\n{\n    return clamp(val,0.0,1.0);\n}\n\nfloat saturate(float val)\n{\n    return clamp(val,0.0,1.0);\n}\n\nfloat dot2(vec3 var)\n{\n    return dot(var,var);\n}\n\nfloat dot2(vec2 var)\n{\n    return dot(var,var);\n}\n\n\n\n\n\nvec3 n_polar(vec3 pos)\n{\n    float radius = length(pos);\n         \n    return vec3(atan(pos.y, pos.x) * iv_pi2, acos(pos.z / radius) * iv_pi2, radius);\n}\n\nvec3 n_un_polar(vec3 unit_pos)\n{\n    return \n    vec3(\n    sin(unit_pos.y * pi2) * cos(unit_pos.x * pi2),\n    sin(unit_pos.y * pi2) * sin(unit_pos.x * pi2),\n    cos(unit_pos.y * pi2)\n    ) * unit_pos.z;\n}\n\n\nvec2 n_polar(vec2 pos)\n{\n    return vec2(atan(pos.x, pos.y) * iv_pi2, length(pos));\n}\n\n\nvec2 n_un_polar(vec2 unit_pos)\n{\n    return vec2(sin(unit_pos.x * pi2), cos(unit_pos.x * pi2)) * unit_pos.y;\n}\n\nvec2 n_rotate(vec2 pos, float unit_angle)\n{\n    vec2 rot = vec2(sin(unit_angle * pi2), cos(unit_angle * pi2));\n    \n    return vec2(pos.x * rot.y - pos.y * rot.x, pos.x * rot.x + pos.y * rot.y);\n}\n\n\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dKSRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2676, 2676, 2716, 2716, 2766], [2767, 2767, 2807, 2807, 2912], [2987, 2993, 3020, 3020, 3157], [3160, 3171, 3208, 3208, 3315], [3317, 3328, 3371, 3371, 3415], [3552, 3560, 3587, 3587, 3652], [3655, 3663, 3692, 3692, 3717], [3720, 3729, 3759, 3759, 3789], [3792, 3802, 3846, 3846, 3966], [3969, 3982, 4037, 4101, 4688], [4693, 4771, 4794, 4794, 5148], [5152, 5152, 5177, 5177, 5748], [6275, 6287, 6323, 6323, 6377], [6380, 6390, 6442, 6442, 6924], [8081, 8081, 8110, 8134, 8433], [8437, 8437, 8468, 8468, 8764], [8775, 8775, 8798, 8798, 9592], [9657, 9657, 9712, 9730, 10426], [10493, 10555, 10590, 10590, 20118], [20120, 20120, 20162, 20162, 24223], [24226, 24295, 24344, 24344, 24953], [24956, 25029, 25060, 25060, 25365], [26152, 26221, 26295, 26295, 34843], [34853, 34875, 34896, 34923, 35269], [35272, 35293, 35362, 35362, 36087], [36121, 36130, 36163, 36163, 36199], [36392, 36417, 36478, 36478, 36566], [36568, 36597, 36632, 36632, 36683], [36685, 36685, 36743, 36743, 36835], [36837, 36837, 36891, 36891, 37004], [37006, 37006, 37056, 37056, 37220], [37289, 37289, 37346, 37391, 41893]], "test": "untested"}
{"id": "7lcGWn", "name": "Rotating circle in circle", "author": "LargeBee", "description": "my first attempt at making a shader", "tags": ["beginner", "circle"], "likes": 1, "viewed": 204, "published": 3, "date": "1635957352", "time_retrieved": "2024-07-30T18:50:51.613476", "image_code": "/*\nUsed Part 1 and 2 of the tutorial by the art of code\nhttps://www.youtube.com/watch?v=u5HAYVHsasc\nhttps://www.youtube.com/watch?v=GgGBR4z8C9o\n\nand borrowed some code from this shader\nhttps://www.shadertoy.com/view/XsGfWw\n*/\n\nfloat Circle (vec2 uv, vec2 p, float r, float blur)\n{\n    float d = length(uv - p);\n    float c = smoothstep(r, r - blur, d);\n\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Normalize coordinates to values 0 -> 1\n    vec2 uv = fragCoord/iResolution.xy; //0 -> 1\n\n    //Map centre to origin\n    uv -= 0.5;                           //-0.5 -> 0.5\n\n    //Multiply uv.x by aspect ratio of screen\n    uv.x *= iResolution.x/iResolution.y;\n\n    float c = Circle(uv, vec2(0, 0), 0.4, 0.05);\n\n    float speed = 1.0;\n    float rotDist = 4.0;\n    vec2 pos = vec2(sin(iTime * speed) / rotDist, cos(iTime * speed) / rotDist);\n    c -= Circle(uv, pos, 0.1, 0.01);\n\n    //Output colour per pixel\n    fragColor = vec4(vec3(c), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lcGWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[227, 227, 280, 280, 369], [371, 371, 428, 473, 979]], "test": "untested"}
{"id": "sl3GWn", "name": "波四", "author": "yjx", "description": "square wave", "tags": ["wave"], "likes": 1, "viewed": 205, "published": 3, "date": "1635955765", "time_retrieved": "2024-07-30T18:50:52.385411", "image_code": "int Wav=1;\n\nfloat wave(float A,float k,float omega,float phi,vec2 U){\nreturn A*sin(k*U.x-omega*iTime+phi);}\n\nvoid mainImage( out vec4 O,vec2 u )\n{\n    vec2 R=iResolution.xy,\n         U = 100.*( u - .5*R ) / R.x;\n\n    float w=0.;\n    for(float j=1.;j<30.;j++){\n    if(Wav==0){\n        w+=wave(3.0/(2.*j-1.),0.3*(2.*j-1.),0.8*(2.*j-1.),0.,U);}\n    if(Wav==1){\n        w+=wave(3.0/j/j*sin(j/2.*3.14),0.3*j,0.8*j,0.,U);}}\n    O+=step(abs(0.2*U.y-w),0.05);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl3GWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[12, 12, 69, 69, 107], [109, 109, 146, 146, 453]], "test": "untested"}
{"id": "Nlc3Dr", "name": "picture transition", "author": "lllcz", "description": "A simple toggle image effect", "tags": ["2d"], "likes": 3, "viewed": 228, "published": 3, "date": "1635955304", "time_retrieved": "2024-07-30T18:50:53.153358", "image_code": "const float NUM_LINES = 4. ;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 归一化 uv 坐标 [0., 1.]\n    vec2 uv = fragCoord.xy / iResolution.xy;;\n \n    vec4 img = vec4(texture(iChannel0, uv));\n    //时间控制面积\n    float progress = abs(sin(iTime * 0.75));\n    float lineW = 1.0 / NUM_LINES;  ///< 一个分区的宽度\n    float count = 0.;\n \n//    if ( progress > uv.x)   ///< 水平的整体滑动\n    {\n        for (float i = 0.; i < 1.0; i += lineW) ///< 遍历分区\n        {\n            count += 1.;\n \n            /// 检查 uv.x 是否落在区间内\n            if ((uv.x > i) && (uv.x < i + lineW * progress)) ///< [i, i+ 1./NUM_LINES * progress]\n            {\n                img = vec4(texture(iChannel1, uv));\n            }\n        }\n    }\n \n \n    fragColor = img;\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlc3Dr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 86, 122, 809]], "test": "untested"}
{"id": "fl3GDr", "name": "smin in raymarching", "author": "FabriceNeyret2", "description": "the 7 bars have increasing bulge.\nNote that the exp-based smooth min must be protected for robustness.\n\nmouse controls camera.", "tags": ["raymarching", "sdf", "short"], "likes": 12, "viewed": 384, "published": 3, "date": "1635954519", "time_retrieved": "2024-07-30T18:50:53.918313", "image_code": "#define rot(a)        mat2(cos(a+vec4(0,11,33,0)))                // rotation\n\n//#define smin(a,b,k)   log( exp(k*(a)) + exp(k*(b)) ) / k        // smooth min\n  #define smin(a,b, k)  ( -k*min(a,b) > 4. ? min(a,b) : log( exp(k*(a)) + exp(k*(b)) ) / k )\n\n//#define cyl(a,b)      max( length(a)-.1, abs(b) -3. )           // cylinder\n#define cyl(a,b)        max( abs(length(a)-.1)-.01, abs(b) -3. )  // hollow cylinder\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9., s; \n    vec3  R = iResolution, d, Y = vec3(0,1,0),\n          D = normalize(vec3((U+U-R.xy)/R.y, -3.)),   // ray direction\n          p = vec3(0,0,8), q,a,                       // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(10,12,0)/1e2*cos(iTime+vec3(0,11,0))+vec3(0,.12,0); \n\n    for ( O=vec4(1); O.x > 0. && t > .005; O-=.005 ) {\n        q = p,\n        q.yz *= rot(.5-6.3*M.y),                      // rotations\n        q.xz *= rot(-6.3*M.x),\n        a = abs(q),\n        t = min(9., max( max(a.x,a.z)-1., a.y-2.) ),  // 3 same bulge\n        s = min(      cyl(q.xy-   Y.xy, q.z+.3),\n                 min( cyl(q.xy-.5*Y.xy, q.z-.3),\n                      cyl(q.xy        , q.z-.9)\n               )    ),\n        t = smin( t, s , -10.);\n        t = max(t, - min( min( length(q.xy + .5*Y.xy), length(q.xy + Y.xy) ),\n                               length(q.xy +1.5*Y.xy) ) + .13 );\n        for ( float j= 0.; j< 7.; j ++ )              // rack with varying bulge\n           t = smin( t, cyl(q.zy-(j-3.)/1.7*Y.xy, q.x+.3*(j-3.)/2. ) , -(4.+j) );\n\n\n        p += .25*t*D;                                 // step forward = dist to obj\n    }\n                                                      // material\n    O *= 1.2* texture(iChannel0, a.x>max(a.y/2.,a.z) ? a.yz : a.y/2.>max(a.x,a.z) ? a.xz : a.xy );\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl3GDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[417, 417, 453, 453, 1805]], "test": "untested"}
{"id": "Nt3GWr", "name": "波三", "author": "yjx", "description": "pat", "tags": ["wave"], "likes": 0, "viewed": 217, "published": 3, "date": "1635943090", "time_retrieved": "2024-07-30T18:50:54.679278", "image_code": "float wave(float A,float k,float omega,vec2 U){\nreturn A*cos(k*U.x-omega*iTime);}\n\nvoid mainImage( out vec4 O,vec2 u )\n{\n    vec2 R=iResolution.xy,\n         U = 200.*( u - .5*R ) / R.x;\n    O+=(1.-step(0.3,abs(0.2*U.y-wave(3.0,0.5,8.0,U)-wave(3.0,0.6,5.0,U)\n    )));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt3GWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 81], [83, 83, 120, 120, 268]], "test": "untested"}
{"id": "ftcGWn", "name": "Waterfall  4", "author": "guil", "description": "Click mouse to add a circular obstacle\nTry different values for parameters in Common.\n\nI tried a new advection scheme using average velocity around point, to improve numerical stability and velocity propagation.", "tags": ["fluid", "waterfall"], "likes": 38, "viewed": 661, "published": 3, "date": "1635934679", "time_retrieved": "2024-07-30T18:50:55.498089", "image_code": "#define R iResolution.xy\n#define T1(U) texture(iChannel0,U/R)\n\nvoid mainImage( out vec4 C, in vec2 U )\n{   \n\n    float m = 3.*T1(U).w;//masse\n    float v = length(T1(U).xy)/10.;//velocity\n    float p = T1(U).z/10.;//pressure\n    \n    C = m*vec4(1,1.2,2,1);\n    \n    if (U.x < 0.2*R.x&&U.y < 0.5*R.y) C = vec4(0.5);\n    if (U.x < 0.4*R.x&&U.y < 0.3*R.y) C = vec4(0.5);\n    \n}  ", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvoid mainImage( out vec4 Q, in vec2 U )\n{      \n    R = iResolution.xy; t = iTime; Mouse = iMouse; Frame = iFrame;\n    pass( Q, iChannel0, U );\n    \n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define dt .1\n#define g 15.\n#define k 15.\n#define l 15.\n#define s .25\n#define nu 0.1\n#define mu 0.1\n#define kappa .0\n\nvec2 R;\nvec4 Mouse;\nfloat t;\nint Frame;\n\n#define T(p) texture(ch,(p)/R)\n\nvoid pass( out vec4 Q, in sampler2D ch, in vec2 U )\n{   \n    \n    vec4 a = T(U+vec2(1,0)),b = T(U+vec2(0,1)),c = T(U+vec2(-1,0)),d = T(U+vec2(0,-1)),e=.25*(a+b+c+d), dx=a-c, dy=b-d;\n    \n    vec2 vu = T(U-dt*e.xy*.5).xy;//advection vector estimate\n    Q = T(U-dt*vu);//advection\n    \n \tvec2 gp = vec2(dx.z,dy.z);//pressure gradient\n    vec2 gw = vec2(dx.w,dy.w);//density gradient\n    float div = (dx.x+dy.y);//divergence\n    vec2 vdv = vec2(Q.x*dx.x+Q.y*dy.x,Q.x*dx.y+Q.y*dy.y); \n    \n    \n    Q.xy -= dt *(k*gp + Q.w*l*gw + Q.w*vec2(0.,g)+ s*vdv*Q.w);//forces\n    Q.z = e.z - 0.025*div;//pressure\n    Q -= dt * vec4(nu,nu,mu,kappa) * 4.*(Q-e);//diffusion\n    \n    //Boundaries\n    if (Frame < 1) Q = vec4(0,0,1,0);\n    if (U.x < 1.||U.y < 1.) Q.xy *= 0.;\n    if (R.x-U.x < 1.||R.y-U.y < 1.) Q.w *= 0.;\n    if (U.x < 0.2*R.x&&U.y < 0.5*R.y) Q.xy *= 0.;\n    if (U.x < 0.4*R.x&&U.y < 0.3*R.y) Q.xy *= 0.;\n \tif (length(U-vec2(0,0.9*R.y)) < 8.) {Q.xy= Q.xy*.5+.5*vec2(1.+0.4*sin(1.5*t),0); Q.w = 1.;};\n    \n    //click mouse to add a circular obstacle\n    if(length(Mouse.xy - U) < 20. && Mouse.z > 0.5){\n        Q.xyw = vec3(0.);\n    }\n\n\n    Q = clamp(Q, vec4(-15,-15,0,0), vec4(15,15,15,15));\n}", "buffer_b_code": "\nvoid mainImage( out vec4 Q, in vec2 U )\n{      \n    R = iResolution.xy; t = iTime; Mouse = iMouse; Frame = iFrame;\n    pass( Q, iChannel0, U );\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftcGWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 104, 104, 374]], "test": "untested"}
{"id": "7ltGR8", "name": "ABENICS Active Ball Joint", "author": "Flyguy", "description": "Based on the mechanism shown in this video:\nhttps://www.youtube.com/watch?v=hhDdfiRCQS4\nRoughly simulates the hobbing process for the monopole gear, but the geometry isn't quite perfect.", "tags": ["sphere", "ball", "gear", "mechanical", "monopole"], "likes": 45, "viewed": 567, "published": 3, "date": "1635904055", "time_retrieved": "2024-07-30T18:50:56.262047", "image_code": "\n//Outline effect based on https://www.shadertoy.com/view/4dVGRW#\nfloat outline(sampler2D buffer, ivec2 uv) {\n  float dpos = 0.0;\n  \n  const ivec2[] v = ivec2[](\n      ivec2(0, 1),\n      ivec2(1, 1),\n      ivec2(1, 0),\n      ivec2(1,-1)\n  );\n  \n  for(int i = 0;i<4;i++)\n  {\n      vec4 s0 = texelFetch(buffer, uv + v[i],0);\n      vec4 s1 = texelFetch(buffer, uv - v[i],0);\n      dpos += 0.15*abs(s0.a - s1.a);\n      dpos += 4.*max(0.0, 1.0 - dot(s0.rgb, s1.rgb));\n  }\n  \n  dpos = pow(max(dpos - 0.5, 0.0), 6.0);\n    \n  return abs(dpos);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 uv = ivec2(fragCoord);\n    \n    vec4 s = texelFetch(iChannel0, uv, 0);\n    \n    vec3 col = vec3(0);\n    \n    if(length(s.a) > 190.)\n    {\n          col = mix(vec3(1), vec3(0.6), fragCoord.y/iResolution.y); //Background\n    }\n    else\n    {\n          col = dot(vec3(0,1,0),-s.xyz) * vec3(1.0,1.0,1.4); //Gears\n    }\n    \n    col -= outline(iChannel0, uv);\n        \n    fragColor = vec4(col, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//Constants\nconst float inf = 1e3;\nconst float eps = 0.04;\nconst float pi = 3.14159265;\nconst float tau = 6.28318531;\n\n\n//Transformation / Domain Modification Functions\nmat3 rotate(vec3 angles)\n{\n    angles = radians(angles);\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\n    return rotX * rotY * rotZ;\n}\n\nvec3 revolve(vec3 p)\n{\n    return vec3(length(p.xy), 0.0, p.z);\n}\n\n//SDF Combination Operators\n//Union\nfloat opU(float d1, float d2) \n{ \n    return min(d1,d2);\n}\n\n//Subtract\nfloat opS(float d1, float d2)\n{\n    return max(-d1,d2);\n}\n\n//Intersection\nfloat opI(float d1, float d2)\n{\n    return max(d1,d2);\n}\n\n//Subtract with 's' x 45deg chamfer at boundary. \nfloat opSChamfer(float s, float d1, float d2)\n{\n    return max(max(d1, -d2), -((-d1+d2)-s)/sqrt(2.0));\n}\n\n\n//SDF Functions\nfloat sdCylinder(vec3 p, float r)\n{\n  return length(p.xy)-r;\n}\n\nfloat sdPlane(vec3 p, vec3 n, float h)\n{\n  return dot(p,normalize(n)) + h;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n  return length(p)-r;;\n}\n\n\n", "buffer_a_code": "const float Zsp = 32.0, //Number of teeth per-axis on the CS gear\n            Zmp = Zsp/2.0, //Number of teeth on the monopole gear\n            module = 2.0; //Gear module\n      \nfloat mPA, mRA, mPB, mRB;\nvec3 csAng;\n\n//Distance to an involute curve at radius 'r'.\nfloat sdInvolute(vec2 p, float r)\n{ \n    p.x = max(0.0,p.x-r)+r;\n    float a = atan(p.y,p.x) + acos(r/length(p));\n    float d = distance(p, r*vec2(cos(a),sin(a))) - a*r;\n    \n    return d;\n}\n\n//Distance to a spur gear with a given # of teeth and module.\nfloat sdSpurGear(vec3 p, float n, float module, float rs, float amod, float pang)\n{  \n    //Parameters\n    float teeth = floor(n);\n    float rackShift = rs;\n    float addendumMod = amod;\n    float pressureAng = radians(pang);\n    \n    //Geometry variables\n    float pitchDia = module * teeth;\n    float baseDia = pitchDia * cos(pressureAng);\n    float outerDia = pitchDia + 2.0*module * (1.0 + rackShift - addendumMod);\n    float rootDia = pitchDia + 2.0*module * (-1.25 + rackShift);\n    float halfToothThk = 0.5*pi/teeth + sqrt(pitchDia*pitchDia - baseDia*baseDia)/baseDia - pressureAng;\n    float toothAng = tau/teeth;\n    \n    //Angular repeated UVs\n    vec2 ar = vec2(atan(p.y, p.x), length(p.xy));\n    ar.x = mod(ar.x + toothAng / 2.0, toothAng) - toothAng / 2.0;\n    vec2 uvr = vec2(ar.y * vec2(cos(ar.x),sin(ar.x)));\n    \n    //Mirror UVs about Y axis\n    uvr.y = -abs(uvr.y);\n    \n    //Rotate UVs by half tooth thickness\n    uvr *= mat2( cos(-halfToothThk), sin(-halfToothThk),\n                -sin(-halfToothThk), cos(-halfToothThk));\n    \n    float d = sdInvolute(uvr, baseDia/2.0); //Involute tooth profile\n    d = opI(d, sdCylinder(vec3(uvr,0), outerDia/2.0)); //Clip profile at outer diameter\n    d = opU(d, sdCylinder(vec3(uvr,0), rootDia/2.0)); //Gear body\n    \n    return d;\n}\n\n//Distance to cross-spherical (CS) gear\nfloat sdCSGear(vec3 p, float n, float module)\n{\n    if(length(p) < module*n*1.1) //Only calculate gear SDF when close\n    {\n        mat3 rotMat = rotate(vec3(90,0,180.0/n)); //Rotate half tooth & 90deg to align for revolve\n        vec3 pa0 = revolve(p.xyz) * rotMat; //Z-aligned spherical gear\n        vec3 pa1 = revolve(p.zyx) * rotMat; //X-aligned spherical gear\n        \n        //Intersect both spherical gears to create the CS gear.\n        return opI(sdSpurGear(pa0, n, module,0.,0.,20.), sdSpurGear(pa1, n, module,0.,0.,20.));\n    }\n\n    return length(p) - module*n;\n}\n\n//Based on the monopole gear hobbing process shown in fig 5 here:\n//https://ieeexplore.ieee.org/document/9415699\nfloat sdMonopoleGear(vec3 p, float n1, float n2, float module, float thickness)\n{ \n    if(length(p) < module*n2*1.1) //Only calculate gear SDF when close\n    {      \n        float Rcr = module * (n1+n2)/2.0; //Gear to hob center distance\n        float hobAngle = degrees(atan(p.y, p.x)) * (n2/n1); //Angle of the spherical gear hob\n        float toothChamfer = (Rcr-module*n2)/2.0; //Chamfer size on top/bottom edge\n\n        vec3 pHob = p - vec3(normalize(p.xy)*Rcr, 0); //Move hob around gear\n        pHob *= rotate(vec3(90, hobAngle, 0));  //Rotate hob in relation to postion & gear ratio\n        pHob = revolve(pHob).xzy; //Revolve hob into a spherical gear profile\n        pHob.xy -= normalize(pHob.xy) * module*n1; //Invert tooth profile\n\n        float d = sdCylinder(p, Rcr/2.0); //Gear body\n        d = opSChamfer(toothChamfer, d, sdPlane(p, vec3(0,0, 1), thickness/2.0)); //Top & chamfer\n        d = opSChamfer(toothChamfer, d, sdPlane(p, vec3(0,0,-1), thickness/2.0)); //Bottom & chamfer\n        d = opI(d, sdSpurGear(pHob, n1, module, 0.1,0.,20.)); //Intersect hob with gear body\n        d = opSChamfer(2.0, d, sdCylinder(p,0.2 * module*n2)); //Center hole\n\n        return d;\n    }\n    \n    return length(p)-module*n2; \n}\n\nfloat Map(vec3 p)\n{\n    float d = -sdSphere(p,200.0);\n    \n    float Rcr = module*(Zsp+Zmp)/2.0; //Center distance\n    \n    vec3 pSph = p * rotate(csAng);\n    vec3 pMPA = (p - vec3(Rcr,0,0)) * rotate(vec3(-mPA+90.,0,2.0*mRA));\n    vec3 pMPB = (p - vec3(0,Rcr,0)) * rotate(vec3(0,mPB+90.,2.0*mRB+90.));\n    \n    d = opU(d, sdCSGear(pSph, Zsp, module));   \n    d = opU(d, sdMonopoleGear(pMPA, Zsp, Zmp, module, module*12.0));\n    d = opU(d, sdMonopoleGear(pMPB, Zsp, Zmp, module, module*12.0));\n    \n    return d;\n}\n\nvec3 MarchRay(vec3 orig, vec3 dir)\n{\n    vec3 mPos = orig;\n    vec3 lPos = orig;\n    for(int i = 0;i < 96;i++)\n    {\n        float dMap = Map(mPos);\n        if(dMap < eps)\n        {\n            if(dMap < 0.0)\n            {\n                mPos = (lPos + mPos)*0.5;\n            }\n            else\n            {\n                break;\n            }\n        }\n        else\n        {\n            lPos = mPos;\n            mPos += dir*dMap;\n        }\n        \n    }\n    \n    return mPos;\n}\n\nvec3 Normal(vec3 p)\n{\n    vec2 offs = vec2(eps,0);\n    float c = Map(p);\n    return normalize(vec3(\n        Map(p+offs.xyy) - c,\n        Map(p+offs.yxy) - c,\n        Map(p+offs.yyx) - c\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy/iResolution.y;\n    vec2 uv = fragCoord/iResolution.y - res/2.0;\n    vec2 m = iMouse.xy/iResolution.y - res/2.0;\n    \n    //Thumbnail camera angle\n    m = (iMouse.xy == vec2(0)) ? vec2(-135, 45) : m*300.0;\n    \n    //Camera\n    mat3 camMat = rotate(vec3(m.y, 0.0, m.x));\n    vec3 orig = vec3(0,-130,0) * camMat;\n    vec3 dir = normalize(vec3(uv.x,0.9,uv.y)) * camMat;\n    \n    //Cross-spherical gear rotation\n    csAng = iTime*vec3(25,31,37.);\n    mat3 csGearMat = inverse(rotate(csAng));\n    vec3 jA = vec3(0,0,1) * csGearMat; //Angle vector for monopole gear A\n    vec3 jB = vec3(1,0,0) * csGearMat; //Angle vector for monopole gear B\n\n    mPA = degrees(atan(jA.y,jA.z)); //Monopole gear A pitch\n    mRA = degrees(acos(-jA.x)); //Monopole gear A roll\n\n    mPB = degrees(atan(jB.x,jB.z)); //Monopole gear B pitch\n    mRB = degrees(acos(-jB.y)); //Monopole gear B roll\n    \n    vec3 hit = MarchRay(orig, dir);\n    vec3 nrm = Normal(hit);\n\n    // Output to screen\n    fragColor = vec4(nrm*inverse(camMat), length(hit-orig));\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ltGR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[539, 539, 594, 594, 1000]], "test": "untested"}
{"id": "Nld3z7", "name": "Draft Quadtree [learning level 2", "author": "byt3_m3chanic", "description": "Dr. Heavenly, Toya... Quad.", "tags": ["2d", "tiles", "quadrtree"], "likes": 23, "viewed": 381, "published": 3, "date": "1635898074", "time_retrieved": "2024-07-30T18:50:57.031988", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Draft Quadtree [learning level 2]\n    11/2/21 @byt3_m3chanic\n\n    Ver2 of my last shader in just playing with quadtrees.\n    \n    @Shane has a good example for 2d tiles here:\n    https://www.shadertoy.com/view/llcBD7\n\n    Done in an attempt to learn the basics and how to use\n    and match up ID's with spaces. IDK might delete later?\n \n*/\n\n#define R          iResolution\n#define M          iMouse\n#define T          iTime\n#define PI         3.14159265359\n#define PI2        6.28318530718\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4324.23); }\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0.0, 1.0); }\nfloat eoc(float t) { return (t = t - 1.0) * t * t + 1.0; }\n\nvec3 hue(float t){ \n    t*=5.;//tweak for other color variations\n    const vec3 d = vec3(0.067,0.812,0.915);\n    return .35 + .45*cos(PI2*t*(vec3(.97,.97,.98)*d)); \n}\n\nfloat box( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat px = .0231;\n\nvec3 doHatch(vec2 p, float res) {\n    p *= res/10.;\n    vec2 id = floor(p*.5)-.5;\n    float rnd = hash21(floor(p*.5));\n    float chk = mod(id.y + id.x,2.) * 2. - 1.;\n    if (chk > 0.5) p.x *=-1.;\n    float hatch = clamp(sin((p.x - p.y)*PI*3.)*3. + 0.25, 0., 1.);\n    if(rnd>.66) hatch = rnd;\n    return vec3(clamp(hatch,.3,.7),id);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec2 ms = (2.*M.xy-R.xy)/max(R.x,R.y);\n                \n    px = fwidth(uv.x)*2.;\n            \n    vec2 vuv= uv*(2.+.25*sin(T*.135));\n    vuv.xy*=rot(.5*sin(T*.2));\n\n    vuv.y+=T*.35;\n    float px = fwidth(uv.x);\n    float level=1.;\n    vec3 dht = doHatch(vuv,155.);\n    float chk = mod(dht.z + dht.y,2.) * 2. - 1.;\n    \n    vec3 C = mix(hue((chk+vuv.x)*.05),vec3(.01),dht.x);\n \n    vec2 muv = M.z>1.?uv-ms:uv-vec2(.5*sin(T)/level,.25*cos(T)/level);\n    float tp = length(muv)-.1;\n    tp=smoothstep(px,.0,abs(tp)-.0075);\n\n    \n    for(int k=0; k<4; k++){\n        vec2 id = floor(vuv*level);\n        float rnd = hash21(id);\n        \n        // threshold or if last loop\n        if(rnd>.45||k>2) {\n\n            vec2 p = vuv -(id+.5)/level;\n            rnd = hash21(rnd+id.yx);\n            float dir = rnd>.5 ?-1.:1.;\n\n                                    \n            vec2 off1= clamp(vec2(muv*.17),vec2(-.1275),vec2(.1275));\n            off1/=level;\n            \n            // make ring parts - very basic\n            float angle = atan(p.x+off1.x, p.y+off1.y);\n            float f = length(p);\n            float width = .5/level;\n            float amt = 24.;\n            //vec for moving ring\n            vec2 q = vec2(\n                fract(dir*amt*angle/PI+T*1.75)/level,\n                f-width\n            );\n            //id for moving ring\n            vec2 tid = vec2(\n                floor(dir*amt*angle/PI+T*1.75),\n                floor(f-width)\n            );\n            \n            tid.x=mod(tid.x,2.);\n            float ds = length(p+off1-vec2(.125/level))-.065/level;\n            float dt = length(p+off1+vec2(.115/level))-.030/level;\n            float d = length(p)-.455/level;\n            float s = length(p)-.375/level;\n            float c = box(q+vec2(0,.4/level),vec2(1.,.25)/level);\n            float l = length(p+off1)-.195/level;\n            float h = abs(l)-.014/level;\n            \n            float fd = smoothstep(.005+px,-px,abs(d)-.025/level);\n            float md = smoothstep(.025+px,-px,length(p)-.275/level);\n            d = smoothstep(.0075+px,-px,d);\n            s = smoothstep(.05+px,-px,s);\n            c = smoothstep(.01+px,-px,c);\n            l = smoothstep(.01+px,-px,l);\n            h = smoothstep(.01+px,-px,h);\n            ds = smoothstep(.01+px,-px,ds);\n            dt = smoothstep(.01+px,-px,dt);\n            \n            C=mix(C,vec3(.35),d);\n            C=mix(C,vec3(.1),min(s,d));\n            c=min(c,s);\n            vec3 clr = hue(hash21(float(k)+tid.yx));\n            if(tid.x<1.) clr = hue(hash21(tid.yx));\n            C=mix(C,clr,min(c,d)+md );\n            C=mix(C,vec3(.015),min(l,d));\n            C=mix(C,vec3(.005),h);\n            C=mix(C,vec3(.9),ds+dt+fd);\n            break;\n        }\n        level*=2.;\n    }\n    \n    C = mix(C,M.z>0.?vec3(.8,.1,.01):vec3(.01,.4,.9),tp);\n    C = pow(C, vec3(.4545)); \n    O = vec4(C,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nld3z7.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[587, 587, 607, 607, 652], [653, 653, 674, 674, 729], [730, 730, 774, 774, 829], [830, 830, 850, 850, 888], [890, 890, 908, 908, 1056], [1058, 1058, 1092, 1092, 1172], [1193, 1193, 1226, 1226, 1526], [1528, 1528, 1569, 1569, 4500]], "test": "untested"}
{"id": "7td3RM", "name": "Velvet room chains", "author": "Roninkoi", "description": "Inspired by the velvet room loading screen in Persona 5", "tags": ["persona", "chains"], "likes": 3, "viewed": 311, "published": 3, "date": "1635896909", "time_retrieved": "2024-07-30T18:50:57.798937", "image_code": "#define PI 3.14159265\n#define MAXIT 40\n#define EPSILON 0.1\n#define STEP 0.8\n\n#define minx4(a, b) ((a.x) < (b.x) ? (a) : (b))\n#define minx2(a, b) ((a.x) < (b.x) ? (a) : (b))\n\nmat3 rotX(float a)\n{\n    return mat3(\n        1., 0., 0.,\n        0., cos(a), -sin(a),\n        0., sin(a), cos(a)\n    );\n}\n\nmat3 rotY(float a)\n{\n    return mat3(\n        cos(a), 0.0, -sin(a),\n        0., 1., 0.,\n        sin(a), 0.0, cos(a)\n    );\n}\n\nmat3 rotZ(float a)\n{\n    return mat3(\n        cos(a), -sin(a), 0.,\n        sin(a), cos(a), 0.,\n        0., 0., 1.\n    );\n}\n\nfloat hash(vec2 r) {\n    return fract(sin(dot(r, vec2(15.5921, 96.654654))) * 23626.3663);\n}\n\nfloat t;\n\nfloat sphere(vec3 r, float a)\n{\n    return length(r) - a;\n}\n\nfloat torus(vec3 r, vec3 a)\n{\n    vec2 p = vec2(length(r.xz) - a.x, r.y);\n    return length(p) - a.y;\n}\n\nfloat plane(vec3 r, vec3 o, vec3 n) {\n    return dot(r - o, n);\n}\n\nfloat box(vec3 r, vec3 a)\n{\n    vec3 p = (abs(r) - a);\n\t\n    return length(max(p, 0.));\n}\n\nfloat link(vec3 r, float a, float b, float t)\n{\n\tr = vec3(r.x+r.y, r.x-r.y, r.z);\n    vec3 p = (abs(r) - vec3(a, a, t));\n\tfloat c = max(b-max(abs(r.y), abs(r.x)), 0.);\n\n    return length(max(p, 0.)+c);\n}\n\nfloat shade(vec3 n, vec3 rd)\n{\n    return clamp(max(dot(n, -rd), 0.) + 1., 0., 1.);\n}\n\nvec3 fog(float z, vec3 col, vec3 fogCol)\n{\n    return mix(fogCol, col, exp(-z));\n}\n\nvec3 matCol(vec4 o)\n{\n\tvec2 cc = o.zw;\n\t\n\tif (o.y == 1.0)\n\t\treturn vec3(cc.x, 0., 0.);\n\t\n    return normalize(vec3(0.8, 0.2, 0.0));\n}\n\nmat3 obj;\n\nvec4 map(vec3 r)\n{\n\tfloat tt = t * 0.2;\n\t\n\tr *= rotY(0.);\n\tr.z += 5.;\n\tvec2 cr = vec2(1000., 0.);\n\t\n\tint n = 12;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfloat dy = 8.;\n\t\tfloat ii = float(i)/float(n) * PI - mod(tt, 2./float(n)) * PI - 0.75;\n\t\tvec3 offs = vec3(cos(ii*4.+tt*10.)*2.+8., ii*dy, sin(ii*4.)-cos(ii)*5.-ii-0.); // shape of chain\n\t\tvec3 v = vec3(8.*sin(ii*4.+tt*10.), dy, 4.*cos(ii*4.)+sin(ii)*5.-1.); // link direction\n\t\tfloat l2 = mod(float(i), 2.); // flip every other link\n\t\tvec3 lr = (r + offs)*rotX(-(v.z/v.y))*rotZ(-(v.x/v.y))*rotY(l2*PI/2.);\n\t\tcr = min(cr, link(lr, 2., 1.5, 0.2));\n\t}\n\t\n\tn = 12;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfloat dy = 5.;\n\t\tfloat ii = float(i)/float(n) * PI - mod(tt, 2./float(n)) * PI - 0.6;\n\t\tvec3 offs = vec3(-8.+ii, ii*dy, 0.);\n\t\tfloat l2 = mod(float(i), 2.);\n\t\tvec3 lr = (r + offs)*rotY(l2*PI/2.);\n\t\tcr = min(cr, link(lr, 1., 0.8, 0.1));\n\t}\n\t\n\tn = 13;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfloat dy = 16.;\n\t\tfloat ii = float(i)/float(n) * PI - mod(tt*0.8, 2./float(n)) * PI - 1.2;\n\t\tvec3 offs = vec3(cos(ii*3.)*2. - 3.*ii, ii*dy, cos(ii)*10.+2.);\n\t\tvec3 v = vec3(3.*sin(ii*3.)*2. + 3., dy, -6.*sin(ii));\n\t\tfloat l2 = mod(float(i), 2.);\n\t\tvec3 lr = (r*rotZ(PI/2.)*rotY(mod(-tt, PI/2.)*3.+PI*0.5) + offs)*rotX(-(v.z/v.y))*rotZ(-(v.x/v.y))*rotY(l2*PI/2.);\n\t\tcr = min(cr, link(lr, 2.9,1.8, 0.3));\n\t}\n\t\n\treturn vec4(cr.x, vec3(0., 0., 0.));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    t = iTime;\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    mat3 cam = rotY(-PI) * rotX(0.3);\n\n    vec3 ro = vec3(0., 2.0, -10.0);\n    vec3 rd = cam * normalize(vec3(uv * 2., -1.));\n    vec3 r = ro;\n\n    vec3 bcol = vec3(0.02, 0.0, 0.4) * (0.8-uv.y) * (0.8-uv.y)+vec3(0.01);\n    vec4 col = vec4(0.);\n    col.rgb = bcol;\n\n    float sh = 1.;\n\n    int ch = 1;\n\n    for (int i = 0; i < MAXIT; ++i) {\n        vec4 d = map(r);\n        float z = length(r - ro);\n\n        if (d.x < EPSILON) {\n            col.rgb = mix(col.rgb, d.yzw,\n                shade(normalize(r), rd));\n\t\t\n            col.rgb = fog(z * 0.03, col.rgb, bcol);\n            break;\n        }\n\n        d.x *= 0.8 - 0.2 * hash(uv);\n        r += rd * d.x * STEP;\n\n        sh = (float(i) / float(MAXIT));\n    }\n\n    if (sh < 0.5)\n        col.rgb *= clamp(exp(-sh * 2.0 + 1.0), 0., 1.);\n\n    fragColor = vec4(col.rgb, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7td3RM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 174, 194, 194, 296], [298, 298, 318, 318, 422], [424, 424, 444, 444, 546], [548, 548, 568, 568, 640], [652, 652, 683, 683, 711], [713, 713, 742, 742, 816], [818, 818, 855, 855, 883], [885, 885, 912, 912, 974], [976, 976, 1023, 1023, 1179], [1181, 1181, 1211, 1211, 1266], [1268, 1268, 1310, 1310, 1350], [1352, 1352, 1373, 1373, 1485], [1498, 1498, 1516, 1516, 2867]], "test": "untested"}
{"id": "fld3z7", "name": "Fractelligence LookingGlass", "author": "PsyPhi", "description": "Raymarched Fractal\n\nDepth", "tags": ["raymarching", "fractal"], "likes": 1, "viewed": 209, "published": 3, "date": "1635891633", "time_retrieved": "2024-07-30T18:50:58.564889", "image_code": "//Transforms\nfloat RotX = 1.5; //0 to 3\nfloat RotY = 0.77;\nfloat RotZ = 0.5;\nfloat TransX = 0.92;  //0 to 5\nfloat TransY = 1.8;\nfloat TransZ = 0.6;\nfloat Scale = 0.;\nfloat Range = 0.001;\nfloat RX = 0.;\nfloat RY = 0.;\nfloat RZ = 0.;\nfloat TX = 0.;\nfloat TY = 1.;\nfloat TZ = 0.;\nfloat TwistY = 0.07; //0 to 0.2\nint MirrorX = 1;\nint MirrorY = 1;\nint MirrorZ = 1;\n//Rectange\nint Rectangle = 1;\nfloat RecScale = 1.;\n//Sphere\nint Sphere = 1;\nfloat SphereScale = 1.;\nfloat SphereTX = 0.5;\nfloat SphereTY = 0.2;\nfloat SphereTZ = 0.1;\n//Shapes\nint InfPre = 1;\nint InfPost = 0;\nint Merge = 1;\nfloat ShapeMix = 0.5;\nfloat FractalScale = 0.1;\nfloat NearClip = 5.;\n//Color\nint Iterations = 1;\nfloat IHue = 0.;\nfloat Proximity = 1.;\nfloat PHue = 0.;\nfloat Distance = 1.;\nfloat DHue = 5.;\nfloat light = 0.;\nfloat DepthHue = 0.0;\n//Time\nfloat TimeRotX = 0.3;\nfloat TimeRotY = 0.25;\nfloat TimeTransX = 0.1;\nfloat TimeTransY = 0.05;\n\n\n\n\n\n\n\n#define MAX_STEPS 50\n\n#define MAX_DIST 25.\n\n#define SURF_DIST .001\n\n#define FRACT_STEPS 20\n\n#define PI 3.14159\n\nfloat map(float x, float inMin, float inMax, float outMin, float outMax) {\n    return (x - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;\n}\n\nvec3 hs(vec3 c, float s){\n    vec3 m=vec3(cos(s),s=sin(s)*.5774,-s);\n    return c*mat3(m+=(1.-m.x)/3.,m.zxy,m.yzx);\n}\n\nmat2 rotate(float a) {\n\n\tfloat c = cos(a),\n\n\t\ts = sin(a);\n\n\treturn mat2(c, -s, s, c);\n\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )  //smooth merges two objects\n\n{\n\nfloat h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\nreturn mix( d2, d1, h ) - k*h*(1.0-h);\n\n}\n\n\n\n//_+_+_+_+_+_+_SHAPING FUNCTIONS_+_+_+_+_+_+_+_\nfloat GetDist(vec3 p) {\n\n\n\n\tfloat d = 1.; //Just to have the d var declaired\n\n//\tfloat perStep = 1/FRACT_STEPS;\n\n\tfor (int i = 0; i < FRACT_STEPS ; i++){\n\nif(InfPre == 1) p = mod(p+2.5, 5.)-2.5;   //Createts infinity\n\n\t\tif(MirrorX == 1) p.x = abs(p.x); //Mirror X\n\t\tif(MirrorY == 1) p.y = abs(p.y); //Mirror Y\n\t\tif(MirrorZ == 1) p.z = abs(p.z); //Mirror Z\n\n\t\tp.x -= TransX\n        +iMouse.x*Range\n        +TimeTransX*sin(iTime*0.2);\n\t\tp.y -= TransY+iMouse.y*Range\n        +iMouse.y*Range\n        +TimeTransY*cos(iTime*0.1);;\n\t\tp.z -= TransZ;\n\n\n\t\tp.xy *= rotate(RotX+sin(iTime*0.2)*TimeRotX); //Audio rct\n\t\tp.xz *= rotate(RotY+cos(iTime*0.1)*TimeRotY);\n\t\tp.yz *= rotate(RotZ);\n\n    p.xz *= rotate(p.y*TwistY); //Twist\n\nif(InfPost == 1)\t\tp = mod(p+2.5, 5.)-2.5;   //Createts infinity\n\n}\n\nif (Sphere == 1){\n\t\tvec4 sphere = vec4(SphereTX, SphereTY, SphereTZ, SphereScale);\n\t  float sphereDist =  length(p-sphere.xyz)-sphere.w;\n    if(Merge == 1) d = opSmoothUnion(sphereDist, d, ShapeMix);\n    else d = min(sphereDist,d);\n  }\n\n\n\t\t if (Rectangle == 1){//Adds in the Rectangle\n\t\t\t vec4 rec = vec4(0.0, 0.0, 0.0, RecScale);\n\t\t\t float recDist = length(max(abs(p) - rec.w, 0.));\n\t\t\t if(Merge == 1) d = opSmoothUnion(recDist, d, ShapeMix);\n       else d = min(recDist,d);\n\t\t }\n\n\n\t\t// d = min(sphereDist,d);\n\n\n\t//}\n    return d;\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd) {\n\tvec3 dO = vec3(NearClip,0.,10.);  //  x = distance ray has traveled, y = Iterations to hit, z = Closest distance to surface\n\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO.x;\n        float dS = GetDist(p);\n        dO.x += dS;\n\t\t\t\tdO.z = min(dS, dO.z);\n\t\t\t\tdO.y = float(i);\n        if(dO.x>MAX_DIST || dS<SURF_DIST) break;\n    }\n\n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 1, -6);\n    //lightPos.xz += vec2(sin(TIME), cos(TIME))*2.; //light movement\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).x;\n    if(d<length(lightPos-p)) dif *= .1;\n\n    return dif;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord, in vec3 _ro, in vec3 _rd)\n\n{\n\n    vec2 uv = (fragCoord+fragCoord - (iResolution.xy) ) / iResolution.y ;\n    \n\n    vec3 color = vec3(0);\n\n\t\tfloat prox = 0.0;\n\n    vec3 ro = vec3(0, 0, -6+\n      (InfPre+InfPost));  //Audio rct\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    ro = _ro;\n    rd = _rd;\n\n\n    vec3 d = RayMarch(ro, rd);\n\n    vec3 p = ro + rd * d.x;\n\n    float dif = GetLight(p);  //lighting\n    //color = vec3(dif);\t\t\t\t//lighting\n\n\t\tvec3 n = GetNormal(p);\n\n\n    //+_+_+_+_+_+_+COLORING_+_+_+_+_+_+_\n\n  //vec3 tex =  textureLod(syn_UserImage, _uv, 0.0).rgb;\n\n\t\tcolor.r = (d.y*0.05-(1.-step(d.x*0.04, 1.)))*float(Iterations);\n\n    color = hs(color, IHue);\n\n    color.g = (1.-(d.z+step(d.x*0.04, 1.)))*Proximity\n    // *1.-tex.r\n    ;\t\t\t\t\t\t//G\n\n    color = hs(color, PHue);\n\n    color.b = (1.-d.x*0.04)*Distance;\n\n\n\n    color = hs(color, DHue);\n\n    color += dif*light;       //light\n  //  color += hs(color, 5*dif*light);       //light hue rotate\n\n\t\t  color = hs(color, d.y*DepthHue); //iterations to hue rot\n\n//\t\tcolor -= dif*0.5;\n\n\n\n    fragColor = vec4(color,1.0);\n}\n\n#define QAA\t2                                     \n\nconst float\tsideAngle       = radians(15.0);\nconst float\thorizontalAngle = radians(14.0);\nconst float\tcameraSize      = 4.5;\nconst float\taspectRatio     = 0.75;\nconst float quiltColumns\t= 8.0;\nconst float quiltRows\t\t= 6.0;\nconst float nearClip        = 8.0; \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2\tcoord = fragCoord * vec2(quiltColumns,quiltRows) / iResolution.xy;\n\tvec2\tfract = fract(coord);\n\tvec2\tfloor = floor(coord);\n\tfloat\timageId = floor.x + floor.y * quiltColumns;\n\tfloat\tvalueId = imageId / (quiltColumns * quiltRows - 1.);\n\tfloat\tdist = (cameraSize / 2.) / tan(horizontalAngle / 2.);\n\tfloat\tminCam = -(cameraSize / 2.) - tan(sideAngle / 2.) * dist;\n\t\n\tvec3\tcamPos = mix(vec3(minCam,0,dist),vec3(-minCam,0,dist),valueId);\n\tvec3\tscreenPos = vec3((fract.x-0.5)*cameraSize,(fract.y-0.5)*cameraSize / aspectRatio,0);\n\t\n\t//vec4\tcolor = vec4( vec3(valueId), 1 );\n\t\n\tvec4\tcolor;\n\tvec3 \tdirRay = normalize(screenPos-camPos);\n    dirRay.z = -dirRay.z;\n\tmainImage( color, fract * iResolution.xy, screenPos - nearClip * dirRay, dirRay );\n\n    fragColor = color;\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fld3z7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1034, 1034, 1108, 1108, 1181], [1183, 1183, 1208, 1208, 1300], [1302, 1302, 1324, 1324, 1390], [1392, 1392, 1474, 1474, 1568], [1572, 1620, 1643, 1643, 2939], [2941, 2941, 2974, 2974, 3336], [3338, 3338, 3362, 3362, 3543], [3545, 3545, 3569, 3569, 3886], [3890, 3890, 3973, 3973, 5029], [5342, 5342, 5398, 5398, 6168]], "test": "untested"}
{"id": "ftt3R7", "name": "Starleidoscope", "author": "DanielXMoore", "description": "Followed some TheArtOfCodeTutorials and ended up with this!", "tags": ["tutorial"], "likes": 171, "viewed": 107498, "published": 3, "date": "1635883589", "time_retrieved": "2024-07-30T18:50:59.338820", "image_code": "#define NUM_LAYERS 10.\n\nmat2 Rot(float a) {\n  float c = cos(a), s = sin(a);\n  return mat2(c, -s, s, c);\n}\n\nfloat Star(vec2 uv, float flare) {\n    float col = 0.;\n    float d = length(uv);\n    float m = .02/d;\n    \n    float rays = max(0., 1. - abs(uv.x * uv.y * 1000.));\n    m += rays * flare;\n    uv *= Rot(3.1415/4.);\n    rays = max(0., 1. - abs(uv.x * uv.y * 1000.));\n    m += rays * .3 * flare;\n    \n    m *= smoothstep(1., .2, d);\n\n    return m;\n}\n\nfloat Hash21(vec2 p) {\n  p = fract(p * vec2(123.34, 456.21));\n  p += dot(p, p+45.32);\n  \n  return fract(p.x*p.y);\n}\n\nvec3 StarLayer(vec2 uv) {\n    vec3 col = vec3(0.);\n    \n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    \n    for(int y = -1; y <= 1; y++ ) {\n        for(int x = -1; x <= 1; x++) {\n            vec2 offs = vec2(x, y);\n\n            float n = Hash21(id + offs);\n            float size = fract(n*345.32);\n            \n            vec2 p = vec2(n, fract(n*34.));\n            \n            float star = Star(gv - offs - p + .5, smoothstep(.8, 1., size) * .6);\n            \n            vec3 hueShift = fract(n*2345.2 + dot(uv /420.,texture(iChannel0, vec2(0.25, 0.)).rg))*vec3(.2, .3, .9)*123.2;\n\n            vec3 color = sin(hueShift) * .5 + .5;\n            color = color * vec3(1., .25, 1.+size);\n\n            star *= sin(iTime*3.+n*6.2831)*.4+1.;\n            col += star * size * color;\n        }\n    }\n    \n    return col;\n\n}\n\nvec2 N(float angle) {\n  return vec2(sin(angle), cos(angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 M = (iMouse.xy - iResolution.xy*.5)/iResolution.y;\n    float t = iTime * .01;\n    \n    uv.x = abs(uv.x);\n    uv.y += tan((5./6.) * 3.1415) * .5;\n\n    vec2 n = N((5./6.) * 3.1415);\n    float d = dot(uv - vec2(.5, 0.), n);\n    uv -= n * max(0., d) * 2.;\n\n    // col += smoothstep(.01, .0, abs(d));\n\n    n = N((2./3.) * 3.1415);\n    float scale = 1.;\n    uv.x += 1.5 / 1.25;\n    for(int i=0; i<5; i++) {\n        scale *= 1.25;\n        uv *= 1.25;\n        uv.x -= 1.5;\n\n        uv.x = abs(uv.x);\n        uv.x -= 0.5;\n        uv -= n * min(0., dot(uv, n)) * 2.;\n    }\n\n \n    uv += M * 4.;\n\n    uv *= Rot(t);\n    vec3 col = vec3(0.);\n    \n    float layers = 10.;\n    \n    for(float i=0.; i < 1.; i+=1./NUM_LAYERS) {\n        float depth = fract(i+t);\n        float scale = mix(20., .5, depth);\n        float fade = depth * smoothstep(1., .9, depth);\n        col += StarLayer(uv * scale + i * 453.2) * fade;\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftt3R7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 43, 43, 105], [107, 107, 141, 141, 452], [454, 454, 476, 476, 569], [571, 571, 596, 596, 1403], [1405, 1405, 1426, 1426, 1467], [1469, 1469, 1526, 1526, 2537]], "test": "untested"}
{"id": "7td3R4", "name": "chaoticParticles", "author": "stephenl7797", "description": "3D Voronoi particle tracking with a weird depth blur and color scheme that I thought turned out kinda cool.\nThe code is a mess and is a fork of something else I'm doing.\n'r' to restart in full-screen", "tags": ["particles"], "likes": 36, "viewed": 1563, "published": 3, "date": "1635881810", "time_retrieved": "2024-07-30T18:51:00.204505", "image_code": "\n\nvec4 compute_color(vec2 fragCoord) {\n    vec4 a = IC1(ivec2(fragCoord));\n    vec2 q[4];\n    q[0] = proj(IC0(unhashXY(int(a.x), IR)).xyz, R,iTime);\n    q[1] = proj(IC0(unhashXY(int(a.y), IR)).xyz, R,iTime);\n    q[2] = proj(IC0(unhashXY(int(a.z), IR)).xyz, R,iTime);\n    q[3] = proj(IC0(unhashXY(int(a.w), IR)).xyz, R,iTime);\n    vec4 d = vec4(length(fragCoord - q[0]),\n              length(fragCoord - q[1]),\n              length(fragCoord - q[2]),\n              length(fragCoord - q[3]));\n    \n    \n    d.rgb += .1;\n    d.a   =  1. / (.1 + d.a);\n    //d.a   =  exp(d.a*.1 - d.r*.3);\n    vec4 c;\n    c.rgb = vec3(1. / d[2], 1. / d[1], 1. / d[0]) * d[3];\n    c.a = 1.;\n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 c = vec4(0.);\n    \n    // TODO: All distances should be in normalized uv coords...\n    // TODO: Should apply view xform if done in proj() func.\n    \n    // The blur gives very ugly artifacts when too large.\n    \n    #if 0\n    float d = length(uv - vec2(.5,.5)) * 1.;\n    #else\n    vec4 a = IC1(ivec2(fragCoord));\n    vec4 q0 = IC0(unhashXY(int(a.x), IR));\n    \n    float z = q0.z;\n    // Uncomment these two lines for a noisy effect that extends far from particles.\n    // I actually quite like it, except that you can see voronoi cells from 0/1 blending.\n    //float dd = abs((z + R.x)  - R.x * + .2 + .0*(sin(iTime+q0.x*.0001)+1.)); // The focus distance [0-1]\n    //float d = exp(dd / R.x * 16.) * .00016; // The blur radius\n    float dd = abs((z + R.x)  - R.x * .3*(sin(iTime+q0.x*.0001)+1.)); // The focus distance [0-1]\n    float d = exp(dd / R.x * 5.72) * .0006; // The blur radius\n    #endif\n    \n    int K = 2;\n    float _t = .01;\n    for (int j=-K; j<=K; j++) {\n    for (int i=-K; i<=K; i++) {\n        //float w = 3.;\n        float w = 1. / (.7 + length(vec2(i,j)));\n        \n        //vec2 fc = fragCoord + vec2(j,i) * d * 1.;\n        vec2 fc = fragCoord + vec2(sin(_t),cos(_t)) * d * 1. * (_t+.5);\n        c += compute_color(fc) * w;\n        _t += 1.1/float(K*K);\n    }\n    }\n    c.rgb /= c.a;\n    \n    c.rgb += length(uv-.5) * vec3(.1,.01,.5)*.15 + .01*rand11(fragCoord.x*100. + fragCoord.y);\n\n    fragColor = c;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define IR ivec2(iResolution.xy)\n#define C0(uv) texture(iChannel0, (uv))\n#define C1(uv) texture(iChannel1, (uv))\n#define IC0(p) texelFetch(iChannel0, (p), 0)\n#define IC1(p) texelFetch(iChannel1, (p), 0)\n\nfloat hashXY(ivec2 xy, ivec2 ir) {\n    return float(xy.y * ir.x + xy.x);\n}\nivec2 unhashXY(int h, ivec2 ir) {\n    return ivec2(h%ir.x, h/ir.x);\n}\n\n#if 0\n// With rotation\nvec2 proj(vec3 p, vec2 RR, float tt) {\n    //p.z += 1.;\n    float t = tt * .015;\n    //t = tt;\n    \n    p.xz = mat2(cos(t),sin(t),-sin(t),cos(t)) * p.xz;\n    p.z += RR.x * 3.8;\n    \n    p.z /= RR.x * 2.6;\n\n    if (p.z < .0) return vec2(9999.,9999.);\n    \n    return p.xy / p.z + RR * .5;\n}\n#else\nvec2 proj(vec3 p, vec2 RR, float tt) {  \n    p.z += RR.x * 3.8;\n    p.z /= RR.x * 2.6;\n\n    if (p.z < .0) return vec2(9999.,9999.);\n\n    return p.xy / p.z + RR * .5;\n}\n#endif\n\n\n\nfloat rand11(float x) { return fract(337.1*sin(x*22.13+11.2)); }\nvec2 rand22(vec2 p) { return fract(vec2(\n    337.1*sin(22.3+27.31*p.y+p.x*22.13),\n    437.1*sin(1.7+22.31*p.y+p.x*29.13) )); }\nvec3 rand23(vec2 p) { return fract(vec3(\n    337.1*sin(22.3+27.31*p.y+p.x*22.13),\n    437.1*sin(1.7+22.31*p.y+p.x*29.13),\n    407.1*sin(111.7+12.31*p.y+p.x*19.13) )); }\nvec3 rand33(vec3 p) { return fract(vec3(\n    337.1*sin(22.3+27.31*p.y+p.x*22.13+p.z*19.2),\n    437.1*sin(1.7+22.31*p.y+p.x*29.13+p.z*10.3),\n    407.1*sin(111.7+12.31*p.y+p.x*19.13+p.z*8.2) )); }\n    \n//float smoo(float v) { return v*v*(3.-2.*v); }\nfloat smoo(float v) { return v; }\nvec3 noise33(vec3 x) {\n    vec3 o = vec3(0.);\n    vec3 fx = floor(x);\n    vec3 lx = fract(x);\n    for (int i=0; i<8; i++) {\n        float dx = (i  ) % 2 == 0 ? 1. : 0.;\n        float dy = (i/2) % 2 == 0 ? 1. : 0.;\n        float dz = (i/4) % 2 == 0 ? 1. : 0.;\n        vec3 v  = rand33(fx + vec3(dx,dy,dz));\n        vec3 d = vec3(dx,dy,dz) * 2. * lx + 1. - lx - vec3(dx,dy,dz);\n        o += smoo(d.x)*smoo(d.y)*smoo(d.z)*v;\n    }\n    return o;\n}", "buffer_a_code": "// Particle sim\n\n// Store xyz and age.\n\nconst float zSpread = .2;\n    \nvec4 initParticle(vec2 fragCoord) {\n    // Random\n    #if 0\n        vec4 o;\n        o = vec4((rand23(fragCoord)) * vec3(R,zSpread), 0.);\n        o.xy -= R * .5;\n        o.xy *= 2.0;\n        vec2 uv = o.xy / R.xy;\n        o.z += R.x * .1 / (length(uv - vec2(.4,.1)) + .2);\n        o.z += R.x * .3 / (length(uv - vec2(.1,.2)) + .3);\n        o.z -= R.x * .2 / (length(uv - vec2(-.4,-.4)) + .6);\n        o.w = 0.;\n        return o;\n    // Spherical\n    #elif 1\n        vec4 o = vec4(0.);\n        fragCoord.x += rand11(fragCoord.y * .1 + fragCoord.x * .07);\n        fragCoord.y += rand11(fragCoord.x * .188 + fragCoord.y * .07);\n        float u = 6.28318 * fragCoord.x / R.x, v = 6.28318 * 1. * fragCoord.y / R.y;\n        o.xyz = vec3(\n            sin(v) * cos(u) * (1.+R.x/R.y)/2.,\n            cos(v),\n            -sin(v) * sin(u)) * vec3(R.x,R.x,R.x) * .4 + vec3(0., 0., .0);\n         \n        //return o * vec4(sin(5.*v), cos(4.*u), 1., 1.);\n         \n        return o;\n    #endif\n        \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    if (iFrame == 0 || texelFetch(iChannel3, ivec2(82, 0), 0).r > .5) {\n        fragColor = initParticle(fragCoord);\n    } else {\n        ivec2 fc = ivec2(fragCoord);\n        vec4 old = IC0(fc);\n        \n        float tt = sin(iTime);\n        float dispersion = .03;\n        float ttt = iTime * .31;\n        float freq = .13;\n        vec3 vel = noise33(fragCoord.xyx*dispersion + old.xyz * freq * vec3(1.,1.,1./2.) * .1 + 5.*vec3(0.,0.,ttt)) - .5;\n        vel += noise33(fragCoord.xyx*dispersion + old.xyz * freq*.5 * vec3(1.,1.,1./2.) * .1 + 5.*vec3(0.,0.,ttt*.5)) *2.- 1.;\n        vel.xy *= 2.51;\n        vel.z *= .001;\n        \n        fragColor.xyz = old.xyz + vel;\n        fragColor.w += .001;\n        \n        // TODO: Should project to check...\n        if (fragColor.x < -R.x*.9995 || fragColor.x > R.x*.9995 || fragColor.y < -R.y*.9995 || fragColor.y > R.y*.9995) {\n        //if (fragColor.z < 0.6 || fragColor.x < -R.x*.5 || fragColor.x > R.x*.5 || fragColor.y < -R.y*.5 || fragColor.y > R.y*.5) {\n        //if (fragColor.z < -2000.0 || fragColor.x < -R.x*.5 || fragColor.x > R.x*.5 || fragColor.y < -R.x*.5 || fragColor.y > R.x*.5) {\n          fragColor = initParticle(fragCoord);\n        }\n        fragColor = fragColor * .995 + .005 * initParticle(fragCoord);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Particle tracking.\n\n// Track closest 4 particles projected from buffer A.\n// Sample a few new ones each frame and inspect neighbors best results\n// to keep the list updated.\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0) {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    \n    vec4 old = IC1(ivec2(fragCoord));\n    \n    vec4 new = old;\n    vec2 q[4];\n    q[0] = proj(IC0(unhashXY(int(old.x), IR)).xyz, R,iTime);\n    q[1] = proj(IC0(unhashXY(int(old.y), IR)).xyz, R,iTime);\n    q[2] = proj(IC0(unhashXY(int(old.z), IR)).xyz, R,iTime);\n    q[3] = proj(IC0(unhashXY(int(old.w), IR)).xyz, R,iTime);\n    vec4 d = vec4(length(fragCoord - q[0]),\n                  length(fragCoord - q[1]),\n                  length(fragCoord - q[2]),\n                  length(fragCoord - q[3]));\n    \n    //q0.xy = q0.xy / q0.z + R*.5;\n    //float d0 = length(fragCoord - q0.xy);\n    \n    // Random.\n    //int randomSamples = iFrame < 100 ? 30 : 40;\n    int randomSamples = 10;\n    for (int i=0; i<randomSamples; i++) {\n        // You can get some cool animated swiping effects with the second branch\n        #if 1\n        int ry = (int(R.y * rand11(fragCoord.x*90.+fragCoord.y + iTime*1.77 + 8.7*float(i))) * 2) % IR.x;\n        int rx = (int(R.x * rand11(fragCoord.x*113.+fragCoord.y + iTime*2.77 + 10.93 + 13.99*float(i))) * 2) % IR.y;\n        #else\n        int rr = int(iFrame*randomSamples*37 + i*2 + int(fragCoord.x*.5 + fragCoord.y*27.));\n        int ry = (rr / IR.x) % IR.y;\n        int rx = rr % IR.x;\n        #endif\n        \n        vec4 q1 = IC0(ivec2(rx,ry));\n        q1.xy = proj(q1.xyz, R,iTime);\n        float d1 = length(fragCoord - q1.xy);\n        \n        #define SL \n        \n        if (d1 <= d[0]) {\n            if (d1<d[0]) {\n            SL new[3] = new[2], d[3] = d[2];\n            SL new[2] = new[1], d[2] = d[1];\n            SL new[1] = new[0], d[1] = d[0];\n            }\n            new[0] = hashXY(ivec2(rx,ry), IR); d[0] = d1;\n        } else if (d1 <= d[1]) {\n            if (d1<d[1]) {\n            SL new[3] = new[2], d[3] = d[2];\n            SL new[2] = new[1], d[2] = d[1];\n            }\n            new[1] = hashXY(ivec2(rx,ry), IR); d[1] = d1;\n        } else if (d1 <= d[2]) {\n            if (d1<d[2])\n            SL new[3] = new[2], d[3] = d[2];\n            new[2] = hashXY(ivec2(rx,ry), IR); d[2] = d1;\n        } else if (d1 <= d[3]) {\n            new[3] = hashXY(ivec2(rx,ry), IR); d[3] = d1;\n        }\n    }\n    \n    // Neighbors.     \n    ivec2 fc = ivec2(fragCoord);\n    for (int i = 0; i < 4; i++) {\n        ivec2 fc1 = fc+ivec2(i==0?-1:i==1?1:0, i==2?-1:i==3?1:0);\n        if (fc1.x < 0 || fc1.y < 0 || fc1.x >= IR.x || fc1.y >= IR.y) continue;\n        vec4 neigh = IC1(fc1); \n        \n        for (int j=0; j<4; j++) {\n            ivec2 ixy = unhashXY(int(neigh[j]), IR);\n            vec4 qnew = IC0(ixy);\n            qnew.xy = proj(qnew.xyz, R,iTime);\n\n            float d1 = length(qnew.xy - fragCoord);\n\n            if (d1 <= d[0]) {\n            if (d1<d[0]) {\n                SL new[3] = new[2], d[3] = d[2];\n                SL new[2] = new[1], d[2] = d[1];\n                SL new[1] = new[0], d[1] = d[0];\n                }\n                new[0] = neigh[j], d[0] = d1;\n\n            } else if (d1 <= d[1]) {\n            if (d1<d[1]) {\n                SL new[3] = new[2], d[3] = d[2];\n                SL new[2] = new[1], d[2] = d[1];\n                }\n                new[1] = neigh[j]; d[1] = d1;\n            } else if (d1 <= d[2]) {\n            if (d1<d[2])\n                SL new[3] = new[2], d[3] = d[2];\n                new[2] = neigh[j]; d[2] = d1;\n            } else if (d1 <= d[3]) {\n                new[3] = neigh[j], d[3] = d1;\n            }\n        }\n    }\n    \n    fragColor = new;\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7td3R4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 38, 38, 684], [687, 687, 744, 744, 2226]], "test": "untested"}
{"id": "fttGzM", "name": "Pulsing spirals (113 chars)", "author": "hnh", "description": "Low-Fi Sci-Fi ;-)\nSimilar concept as in https://www.shadertoy.com/view/7syXzV", "tags": ["spiral", "glow", "short", "tweet", "golf"], "likes": 4, "viewed": 251, "published": 3, "date": "1635881692", "time_retrieved": "2024-07-30T18:51:01.028303", "image_code": "\nvoid mainImage(out vec4 o, vec2 u){\n\n//*\n// -2 chars by XOR\n   o = 1. - abs(sin((iTime \n          - length(o= u.xyxy/iResolution.xyxy - .5)\n          + atan(o.xxyx, o))*2.));  // coefficient -> spiral arms\n\n/*/\n// -1 char by coyote\n    o= 2.*fract(iTime - length(u= u/iResolution.xy - .5)\n             + atan(u.xxyx/u.xyxx)/1.57);\n    o*= --o;\n\n\n/* /\n// -2 chars by XOR\n    o= fract(iTime - length(u= u/iResolution.xy - .5)\n             + atan(u.xxyx/u.xyxx)/1.57) - .5;\n    o*= o*4.;\n\n/* /\n// base version, 118 chars\n    o= 1. - sin(3.14*fract(iTime \n          - length(u= u/iResolution.xy - .5)\n          + atan(u.xxyx, u.xyxx)/1.57));\n//*/\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fttGzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 36, 60, 645]], "test": "untested"}
{"id": "slc3z7", "name": "[Inercia 2021] Le Royal Cheater ", "author": "totetmatt", "description": "Same but different, wasn't really inspired.\n", "tags": ["shaderroyale"], "likes": 9, "viewed": 311, "published": 3, "date": "1635873616", "time_retrieved": "2024-07-30T18:51:01.789268", "image_code": "/******\nThanks the Shader Showdown Scene folks for all the fun ! \n\n\nObrigado Inercia organiser jeenio, ps, alien and also all folks that participated !\n\n\n\n# \n    This is the first scripted shader showdown / royale entry.\n    It was 'coded' live before the event, the bonzomatic network message has been recoreded via a script, \n    and then was replayed step by step thanks to another script and the bonzomatic network\n    during the Intercia 2021 Shader Royale\n#\n\n--- \n/******\nThis work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. \n\n== Do not buy NFT ==\n== Do not make NFT with Creative-Commons artworks ==\n== If you respect the art and the artists, remember and apply this ==\n\n01000110011101010110001101101011 011011100110011001110100\n\n                                                                               \n _|_|_|_|                      _|            _|      _|  _|_|_|_|  _|_|_|_|_|  \n _|        _|    _|    _|_|_|  _|  _|        _|_|    _|  _|            _|      \n _|_|_|    _|    _|  _|        _|_|          _|  _|  _|  _|_|_|        _|      \n _|        _|    _|  _|        _|  _|        _|    _|_|  _|            _|      \n _|          _|_|_|    _|_|_|  _|    _|      _|      _|  _|            _|      \n                                                                          \n\n01000110011101010110001101101011 011011100110011001110100\n\n******/\n\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat box2(vec2 p,vec2 b){\n    vec2 q = abs(p)-b;\n     return length(max(vec2(0.),q))+min(0.,max(q.x,q.y));\n  }\n \nvec2 sdf(vec3 p){\n  p.y -=.2;\n    p.xy *=rot(-.785*.5);\n  float bump = fract(iTime);\n  vec2 h;\n  vec3 hp = p;\n  hp.y -=1.;\n  hp.x +=1.;\n  h.x =  max(abs(hp.z)-.1-bump,box2(hp.xy,vec2(.5)));\n  h.y = 1.;\n  \n  vec2 t;\n  vec3 tp = p;\n  tp.x +=1.;\n  tp.y +=1.;\n  t.x =  max(abs(tp.z)-.1-bump,box2(tp.xy,vec2(.5,1.)));\n  t.y = 1.;\n  \n  h = t.x < h.x ? t:h;\n  \n  tp = p;\n  tp.y+=.3;\n  tp.x +=.1;\n  t.x = max(abs(tp.z)-.1-bump,length(tp.xy)-1.75);\n  t.x = max(-tp.x+.1,t.x);\n  \n  float tt  = max(abs(tp.z)-.2-bump,length(tp.xy)-1.);\n  tt = max(-tp.x,tt);\n  t.x= max(-tt,t.x);\n  t.y = 2.;\n  \n    h = t.x < h.x ? t:h;\n  return h;\n  }\n#define q(s) s*sdf(p+s).x\n  vec3 norm(vec3 p,float ee){vec2 e=vec2(-ee,ee);return normalize(q(e.xyy)+q(e.yxy)+q(e.yyx)+q(e.xxx));}\nfloat diam2(vec2 p,float s){\n    p = abs(p);\n    return (p.x+p.y-s)*inversesqrt(3.);\n}\nvec3 txt(vec2 uv){\n  uv*=4.;\n  uv = vec2(log(length(uv)),atan(uv.y,uv.x))*3.1415;\n  uv.x -=iTime;\n  vec2 id = floor(uv);\n  uv = fract(uv)-.5;\n     vec3 col = vec3(.8,.2,.2);\n  if(mod(id.x,2.)==0.){\n       uv*=4.;\n       uv.y +=iTime;\n       uv = fract(uv)-.5;\n    col = vec3(.2,.8,.2);\n    }\n  float d = diam2(uv,.2);\n  d=  mix(d,abs(d)-.01,asin(sin(uv.x+uv.y))); // NOT SQUIDGAME \n  d=  smoothstep(1.7*fwidth(d),0.,d);\n \n  return .5*col*d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n  vec3 col = txt(uv);\n  \n  vec3 ro = vec3(sin(iTime),0.,-5.);\n  vec3 rt = vec3(0.);\n  vec3 rp = ro;\n  vec3 z = normalize(rt-ro);\n  vec3 x = normalize(cross(z,vec3(0.,-1.,0.)));\n  vec3 y = normalize(cross(z,x));\n\n  vec3 rd = mat3(x,y,z)*normalize(vec3(uv,1.));\n  vec3 light = vec3(1.,2.,-3.);\n  vec3 acc = vec3(0.);\n  float time = mod(iTime,10.);\nfor(float i=0.;i<=128.;i++){\n    vec2 d = sdf(rp);\n     \n     \n     if(time < 5. && length(rp-vec3(.25,.1,.0)) >.6 ) acc += (d.y ==1. ? vec3(.2,.9,.2):vec3(.9,.2,.2))*exp(-abs(d.x))/(50.-min(40.,fract(iTime)*50.));\n     if(time < 5. &&  fract(iTime+ length(rp)*.5)<0.5){  d.x = max(.001,abs(d.x));}\n    \n    if(d.x <.0001){\n        vec3 n = norm(rp,.001);\n        vec3 nn = norm(rp,.01);\n        float diff = max(0.,dot(normalize(light-rp),n));\n        float spc = max(0.,dot(normalize(light-ro),reflect(-normalize(light),n)));\n      spc  = pow(spc,32.);\n        if(d.y == 1.){\n             col = vec3(.2,.9,.2)*diff;\n        }  else {\n             col = vec3(.9,.2,.2)*diff;\n          \n          }\n         col = time < 5. ?col : mix(col, col*step(.2,length(nn-n)),floor(asin(sin(rp.y+iTime)*.5)*10.)*.5+.5);\n         col +=spc*vec3(1.);\n      break;\n      }\n      rp +=rd*d.x;\n  \n  }  \n  col +=acc;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slc3z7.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1414, 1414, 1432, 1432, 1479], [1480, 1480, 1506, 1506, 1591], [1594, 1594, 1611, 1611, 2217], [2246, 2246, 2273, 2273, 2348], [2349, 2349, 2377, 2377, 2435], [2436, 2436, 2454, 2454, 2878], [2879, 2879, 2936, 2986, 4350]], "test": "untested"}
{"id": "slcGz7", "name": "Vaporwave Plant", "author": "Xibanya", "description": "Wanted to practice animating objects anchored to a moving curve.", "tags": ["bezier", "fern", "90s", "plant", "vaporwave"], "likes": 18, "viewed": 657, "published": 3, "date": "1635872967", "time_retrieved": "2024-07-30T18:51:02.564196", "image_code": "float nrand(float x, float y) \n{\n    return fract(sin(dot(\n        vec2(x, y), vec2(12.9898, 78.233))) * \n        43758.5453); \n}\nvec4 Blend(vec4 top, vec4 bottom) \n{\n\tvec4 result;\n\tresult.a = top.a + bottom.a * (1.0 - top.a);\n\tresult.rgb = (top.rgb * top.aaa + bottom.rgb * bottom.aaa * \n        (vec3(1.0, 1.0, 1.0) - top.aaa)) / result.aaa;\n\treturn result;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float jitter = nrand(uv.y, iTime / 20.) * 2. - 1.;\n    uv.x += jitter * step(0.0, abs(jitter)) * 0.00175;\n    \n    vec2 texel = 1. / iResolution.xy;\n\tvec3 duv = texel.xyx * vec3(0.5, 0.5, -0.5);\n\n\tvec3 blur = texture(iChannel0, uv.xy - duv.xy).rgb;\n\tblur += texture(iChannel0, uv.xy - duv.zy).rgb;\n\tblur += texture(iChannel0, uv.xy + duv.zy).rgb;\n\tblur += texture(iChannel0, uv.xy + duv.xy).rgb;\n\tblur /= 4.;\n    \n    float sub = -0.1;\n    float hard = 0.3;\n\n    float modulo = floor(mod(uv.x / texel.x * 0.25, 3.0));\n    vec3 tmp = blur.rgb;\n    float is0 = step(modulo, 0.) * step(0., modulo);\n    float is1 = step(1., modulo) * step(modulo, 1.);\n    tmp -= vec3(0., sub * hard, \n        sub * hard * 2.0) * is0;\n    tmp -= vec3(sub * hard, 0., \n        sub * hard) * step(1., modulo) * step(modulo, 1.);\n    tmp -= vec3(sub * hard * 2.0, \n        sub * hard, 0.) * (1. - is0) * (1. - is1);\n    vec3 col = Blend(vec4(tmp, 0.9), vec4(blur, 1.)).rgb;\n    \n    float scanline = \n        sin((uv.y - sin(iTime / 200.)) * iResolution.y) * 0.025;\n    col.rgb -= scanline;\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// I was inspired by 4rknova's shader to see if I \n// could animate objects as if they were anchored to\n// a point in on a curve. Most of the curve-drawing\n// code is adapted from https://www.shadertoy.com/view/ll23Wt\n// ------------------------------------------\n\n// colors used to draw the plant\n#define LEAF vec3(0.89, 0.435, 0.9)\n#define LEAF_TIP vec3(0.68, .7, 0.97)\n#define LEAF_OUTLINE vec3(0.7, .75, 0.95)\n// if progress along curve is less than this\n// then the plant should be drawn even if\n// outside the triangle\n#define THRESH 0.5\n\n// ------------------------------------------------\n// bezier functions from \n// Interpolation: Bezier, Cubic\n// by 4rknova\n// https://www.shadertoy.com/view/ll23Wt\n#define STEPS  25.\n#define STROKE .8\n#define LEAF_COUNT 19.\n#define EPS    .01\n\nvec2 interpolate(vec2 a, vec2 b, vec2 c, vec2 d, float p)\n{\n    vec2 v0 = mix(a, b, p);\n    vec2 v1 = mix(b, c, p);\n    vec2 v2 = mix(c, d, p);\n    vec2 v3 = mix(v0, v1, p);\n    vec2 v4 = mix(v1, v2, p);\n    \n    return mix(v3, v4, p);\n}\nfloat df_line(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\nfloat sharpen(in float d, in float w)\n{\n    float e = 1. / min(iResolution.y , iResolution.x);\n    return 1. - smoothstep(-e, e, d - w);\n}\n// ----------------------------------------------------\n\n// all sdf functions from iq\n//https://iquilezles.org/articles/distfunctions2d\nfloat sdEgg( in vec2 p, in float ra, in float rb )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x);\n    float r = ra - rb;\n    return ((p.y<0.0)       ? length(vec2(p.x,  p.y    )) - r :\n            (k*(p.x+r)<p.y) ? length(vec2(p.x,  p.y-k*r)) :\n                              length(vec2(p.x+r,p.y    )) - 2.0*r) - rb;\n}\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat sdEquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\nvec2 opRep(vec2 p, vec2 c)\n{\n    return mod(p + 0.5 * c, c) - 0.5 * c;\n}\nvec2 opRepLim( in vec2 p, in vec2 s, in vec2 lima, in vec2 limb)\n{\n    return p-s*clamp(round(p/s),lima,limb);\n}\n//https://iquilezles.org/articles/functions\nfloat polyImpulse( float k, float n, float x )\n{\n    return (n/(n-1.0))*pow((n-1.0)*k,1.0/n)*x/(1.0+k*pow(x,n));\n}\n/////////////////////////////////////////////////////////\n// star functions adapted from \n// https://www.shadertoy.com/view/ssK3Dt by Scintoth\nfloat noiseFloat(vec2 p)\n{\n    p = fract(p * vec2(1000. * 0.21353, 1000. * 0.97019));\n    p = p + dot(p, p + 1000. * 0.54823);\n    return fract(p.x * p.y);\n}\nvec2 noiseVector(vec2 p)\n{\n    float n = noiseFloat(p);\n    return vec2(n, noiseFloat(p + n));\n}\nvec2 GetPos(vec2 id, vec2 offsets)\n{\n    vec2 n = noiseVector(id + offsets) * 500. * \n        (8000. / (1000. * 50.));\n    return (sin(n) * 0.9) + offsets;\n}\nfloat Stars(vec2 uv, float gain)\n{\n    uv -= 1.;\n    float m = 0.;\n    uv = uv * 10.;\n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    \n    vec2 p[9];\n    int n = 0;\n    for (float y = -1.; y <= 1.; y++)\n    {\n        for (float x = -1.; x <= 1.; x++)\n        {\n            p[n++] = GetPos(id, vec2(x, y));\n        }\n    }\n    for (int i=0; i < 9; i++)\n    {\n        vec2 j = (p[i] - gv) * 2.0;\n        float sparkle = 0.1/dot(j, j) * (gain / 8000.0);\n        m = m + sparkle * (sin((8000.0 + p[i].x)* 0.5)*0.5 + 0.9);\n    }\n    return m;\n}\n/////////////////////////\n\nfloat Leaf(vec2 uv, float radius, float tip, float pos)\n{\n    vec2 size = mix(vec2(4.), vec2(.75, 0.7), polyImpulse(1.5, 1.5, pos));\n    vec2 p = uv * size;\n    p += vec2(0., tip * 0.5);\n    float leaf = sdEgg(p, radius, tip);\n    leaf = min(leaf, sdEgg(-p, radius, tip));\n    return leaf;\n}\nfloat Margin(float sdf)\n{\n    return clamp(1. - smoothstep(0.005, 0.01, abs(sdf)), 0.0, 1.0);\n}\nfloat AStep(float d)\n{\n    return smoothstep(0.9, 1.01, d);\n}\nfloat MStep(float d)\n{\n    return 1. - clamp(smoothstep(-0.005, 0.0, d), 0., 1.);\n}\nvec2 Rotate2D( vec2 p, float theta )\n{\n    float co = cos( theta );\n    float si = sin( theta );\n    return vec2( co * p.x + si * p.y,\n                -si * p.x + co * p.y );\n}\nfloat LeafTier(vec2 uv, vec2 a, vec2 b, vec2 c, vec2 d, \n    float pos, out vec4 col)\n{\n    vec2 end1 = interpolate(a, b, c, d, 0.);\n    vec2 p = interpolate(a, b, c, d, pos);\n    float radius = 0.05;\n    float tip = -0.5;\n    vec2 leafPos = uv - p;\n    float r = dot(leafPos, end1);\n    leafPos = Rotate2D(leafPos, -1. + r / max(0.2, pos));\n    float leaf = Leaf(leafPos, radius, tip, pos);\n    leafPos = Rotate2D(\n        leafPos, 2. - (cos(iTime * 0.5) * r / max(0.2, pos)));\n    leaf = min(leaf, Leaf(leafPos, radius, tip, pos));\n    float maxDist = .4;\n    float dist = distance(uv, p);\n    dist = clamp(dist/maxDist, 0., 1.);\n    vec3 green = vec3(0.2, 0.9, 0.5);\n    col.rgb = mix(LEAF, LEAF_TIP, dist);\n    col.rgb = mix(col.rgb, LEAF_OUTLINE, Margin(leaf) * dist);\n    col.a = step(pos, THRESH);\n    return sharpen(leaf, EPS * 1.);\n}\n// leafCol.a used to determine if color should be \n// drawn outside the triangle container\nfloat Branch(in vec2 uv, out vec4 leafCol)\n{\n    // the movement is based on https://www.shadertoy.com/view/MlKcDD\n    vec2 a = vec2(-.25, .25) * 1. + (cos(iTime * 0.5) * 0.25);\n    vec2 b = vec2( .00, .75) * (cos(iTime * 0.25) * 0.5 + 0.5);\n    vec2 c = vec2( .75,-.75);\n    vec2 d = vec2( .0, -.9);\n\n    float leaf = 0.;\n    float stem = 0.;\n    leafCol.a = 0.;\n    for (float i = 0.; i < STEPS; ++i)\n    {\n        vec2  p0 = interpolate(a, b, c, d, (i   ) / STEPS);\n        vec2  p1 = interpolate(a, b, c, d, (i+1.) / STEPS);\n        float l = sharpen(df_line(uv, p0, p1), EPS * STROKE);\n        // if the stem is higher than the threshold, want\n        // to draw it even if it is outside the triangle\n        leafCol.a = stem > l? leafCol.a : step(i / STEPS, THRESH);\n        stem = max(stem, l);\n    }   \n    leaf = stem;\n    leafCol.rgb = LEAF * 0.9 * stem;\n    for (float i = 0.1; i < LEAF_COUNT; i++)\n    {\n        vec4 nextCol;\n        float nextLeaf = LeafTier(uv, a, b, c, d, 0.05 * i, nextCol);\n        leafCol = mix(leafCol, nextCol, nextLeaf);\n        leaf = max(leaf, nextLeaf);\n    }\n    return leaf;\n}\nfloat IsBlack(vec3 col)\n{\n    return step(abs(col.r + col.g + col.b), 0.);\n}\nfloat IsWhite(vec3 col)\n{\n    return step(1., (col.r + col.g + col.b) / 3.);\n}\nvec3 Dodge(vec3 col, vec3 effect)\n{\n    float isBlack = IsBlack(effect);\n\tvec3 inverted = (1. - effect) * (1. - isBlack) + isBlack;\n\tfloat anyWhite = min(IsWhite(effect) + IsWhite(col), 1.);\n\treturn clamp(col / inverted, 0., 1.) * (1. - anyWhite) + anyWhite;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy * 2. - 1.);\n    uv.x *= iResolution.x / iResolution.y;\n    uv = uv * 0.8 + vec2(0.0, -0.1);\n\n    vec2 checkUV = opRepLim(uv * 10., vec2(2., 0.), \n        vec2(-10., 0.), vec2(10., 1.));\n    float check = sdBox(checkUV, vec2(0.5));\n    checkUV = opRepLim(uv * 10. + vec2(1., 1.), \n        vec2(2., 0.), vec2(-10., 0.), vec2(10., 1.));\n    check = min(check, sdBox(checkUV, vec2(0.5)));\n    vec3 bg = mix(vec3(1., 0.78, 1.), vec3(0.), MStep(check));\n\n    vec2 gridUV = opRep(uv * 10., vec2(1.));\n    float grid = sdBox(gridUV, vec2(0.48));\n    bg = mix(vec3(1.), bg, MStep(grid));\n\n    float bA = sdBox(uv + vec2(.75, .75), vec2(0.5, 0.1));\n    float aVal = mix(0.1, .5, clamp(uv.x * 0.5 + .5, 0., 1.));\n    vec3 dCol = vec3(.9, .9, .1) * aVal;\n    bg = mix(bg, Dodge(dCol, bg), MStep(bA));\n    bA = sdBox(uv + vec2(-.75, -0.5), vec2(0.5, 0.1));\n    aVal = mix(0.1, .5, clamp(-uv.x * 0.5 + .5, 0., 1.));\n    dCol = vec3(.9, .9, .1) * aVal;\n    bg = mix(bg, Dodge(dCol, bg), MStep(bA));\n\n    float specks = smoothstep(0.05, 0.1, (Stars(uv * 0.5, 50.)));\n    bg = clamp(bg + specks, 0., 1.);\n\n    vec3 low = vec3(.8, .035, .96);\n    vec3 high = vec3(.39, .69, .94);\n    vec3 col = mix(low, high, clamp(uv.y + 1., 0., 1.));\n    vec4 leafCol = vec4(col, 0.);\n    float branch = AStep(Branch(uv, leafCol));\n    col = mix(col, leafCol.rgb, branch);\n    vec2 triUV = uv * 1.5 + vec2(0., 0.2);\n    triUV = Rotate2D(triUV, iTime * 0.25);\n    float fullTri = sdEquilateralTriangle(triUV);\n    float tri = abs(fullTri) - 0.02;\n    vec3 dodge = Dodge(col, col);\n    col = mix(col, dodge, MStep(tri));\n    col = mix(col, bg, 1. - MStep(fullTri));\n    col = mix(col, leafCol.rgb, clamp(branch * leafCol.a, 0., 1.));\n\tfragColor = vec4(col, 1);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slcGz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 129], [130, 130, 166, 166, 361], [362, 362, 419, 419, 1575]], "test": "untested"}
{"id": "sl33z7", "name": "[Inercia 2021] Inerciaaaaaa", "author": "totetmatt", "description": "At least wasn't last this time :D \nWill burn your GPU / CPU just for simple shapes and very unoptimized code, perfect for heating during christmas.\nDo I understand what I done ? Absolutly not ? Did I just randomly write stuff until it please me ? Hell yea", "tags": ["exegfx", "inercia"], "likes": 10, "viewed": 459, "published": 3, "date": "1635872785", "time_retrieved": "2024-07-30T18:51:03.336133", "image_code": "\n/******\nThanks the Shader Showdown Scene folks for all the fun ! \nThanks yx for the blossom !  \n\n\nObrigado Inercia organiser jeenio, ps, alien and also all folks that participated !\n--- \n/******\nThis work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. \n\n== Do not buy NFT ==\n== Do not make NFT with Creative-Commons artworks ==\n== If you respect the art and the artists, remember and apply this ==\n\n01000110011101010110001101101011 011011100110011001110100\n\n                                                                               \n _|_|_|_|                      _|            _|      _|  _|_|_|_|  _|_|_|_|_|  \n _|        _|    _|    _|_|_|  _|  _|        _|_|    _|  _|            _|      \n _|_|_|    _|    _|  _|        _|_|          _|  _|  _|  _|_|_|        _|      \n _|        _|    _|  _|        _|  _|        _|    _|_|  _|            _|      \n _|          _|_|_|    _|_|_|  _|    _|      _|      _|  _|            _|      \n                                                                          \n\n01000110011101010110001101101011 011011100110011001110100\n\n******/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n  vec4 pframe = texture(iChannel0,fragCoord.xy/iResolution.xy);\n    // Output to screen\n    fragColor = vec4(min(pframe.xyz/pframe.a,vec3(1.,1.,1.)),1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nconst float pi = acos(-1.);\nmat2 rot(float a){float c=cos(a),s=sin(a); return mat2(c,-s,s,c);}\nfloat displace(vec3 p){\n    //p.xy = vec2(log(length(p.xy)),atan(p.y,p.x))*.9;\n    p = asin(sin(p)*.9);\n    float q = 1.;\n    vec4 pp = vec4(p,1.);\n    float lim = 8.;\n    for(float i=0.;i<=lim;i++){\n        q += clamp(\n        asin(sin(pp.x*6.))+acos(cos(pp.y*4.))+\n        \n        asin(sin(pp.z*2.))/pp.a,-.3,.3)/6.;\n        pp*=1.2;\n        pp.xz *=rot(.785);\n    }\n    return q/lim;\n}\nfloat box(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(vec3(0.),q))+min(0.,max(q.x,max(q.y,q.z)));\n}\nfloat diam2(vec2 p, float s){\n    p = abs(p)-s;\n    return (p.x+p.y-s)*inversesqrt(3.);\n}\n\nvec3 gp ;\n\nvec2 sdf(vec3 p){\n    float dis = displace(p);\n    vec3 dis3 = vec3(0.,0.,dis);\n    p.yz*=rot(atan(1./sqrt(2.)));\n    p.xz*=rot(3.1415/4.);\n    p.yz *=rot(-.785*1.5);\n    vec2 h;\n    vec3 hp =p;\n    hp += vec3(.7,-1.3,0.);\n    h.x = box(hp,vec3(.5)+dis3);\n    hp.y += 2.;\n    \n    h.x = min(h.x,box(hp,vec3(.5,1.1,.5)+dis3));\n    h.y = 1.;\n    \n    vec2 t;\n    vec3 tp =p;\n    tp.x -=.3;\n    \n    t.x = max(abs(tp.z)-.5-+dis,length(tp.xy)-1.8);\n    t.x = max(-(length(tp.xy)-.8),t.x);\n    t.x = max(-tp.x,t.x);\n    tp.y = abs(tp.y);\n    tp -=vec3(-.13,1.3,0.);\n    t.x = min(box(tp,vec3(.2,.5,.5)+dis3),t.x);\n    t.y = 2.;\n    h= t.x <h.x ? t:h;\n\n    \n     \n    tp =p;\n    tp.xz *=rot(-.1+tp.y*.3);\n    float dd = tp.x > 0. ? 1.:2.;\n    tp.x = abs(tp.x)-4.25;\n    \n   // tp.xz *=rot(3.1415*.3+tp.y*.1);\n\n\n    t.x = diam2(tp.xz,.15+(sin(p.y*dis)*.1))*.9;\n    t.y = dd;\n    h = t.x < h.x ? t:h;\n    \n    tp = p;\n    tp.zy *=rot(-.985);\n    tp.z +=float(iFrame)*.1;\n    dis = displace(tp);\n    t.x = dot(tp,normalize(vec3(0,1.,0.)))+1.+dis*2.;\n    t.y = 3.;\n    t.x = max(t.x,-(abs(h.x)-.1));\n    \n  \n    h = t.x < h.x ? t:h;\n    \n    tp = p;\n     tp.yz *=rot(-.785/2.);\n   \n   \n  \n   // tp.z = abs(tp.z)-.25;\n    vec2 q = vec2(diam2(tp.xy,1.5),tp.z);\n   \n    q *=rot(atan(tp.y,tp.x)*2.); q.x = abs(q.x)-.5;\n      t.y  =mod(floor(q.x),2.)==.0 ? 1.:2. ;\n    t.x = diam2(q,.05+dis*.1);\n   \n      h = t.x < h.x ? t:h;\n    gp = p;\n    return h;\n}\n\n\nvec3 q(vec3 p, vec3 s) { return s*sdf(p+s).x; }\nvec3 norm(vec3 p,float ee){vec2 e = vec2(-ee,ee);return normalize(q(p,e.xyy)+q(p,e.yxy)+q(p,e.yyx)+q(p,e.xxx));}\nfloat ao(vec3 rp,vec3 n, float k){ return sdf(rp+n*k).x/k ;}\nfloat gao(vec3 rp,vec3 n){ return ao(rp,n,.1)+ao(rp,n,.5)+ao(rp,n,.7);}\n\n// hash functions adapted from Devour\n// https://www.shadertoy.com/view/3llSzM\nfloat seed;\nfloat hash() {\n\tfloat p=fract((seed++)*.1031);\n\tp+=(p*(p+19.19))*3.;\n\treturn normalize(tan((p+p)*p));\n}\nvec2 hash2(){return vec2(hash(),hash());}\nvec2 hash22(vec2 p) {\n    p = fract(p * vec2(6.159, 7.853));\n    p += dot(p.yx, p.xy +  vec2(35.511, 7.584));\n    return fract(vec2(p.x * p.y * 195.714, p.x * p.y * 174.78));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n// seed the RNG (again taken from Devour)\n\tseed = float(((iFrame*73856093)^int(gl_FragCoord.x)*19349663^int(gl_FragCoord.y)*83492791)%38069);\n  \n  \n  float shutterAperture = 0.6;\n\n    float focusDistance = float(iFrame)*.5;\n    float blurAmount = 0.55*(1./(1.5+float(iFrame)*.8));\n    int   numLevels = 5;\n\n\n\t// set up UVs, jittered for antialiasing\n\tvec2 uv = (gl_FragCoord.xy-.5*iResolution.xy)/iResolution.y;\n      uv *=1.+(fract(sin(float(iFrame)))*.1*length(uv))*(1./(.5+float(iFrame)*.08));\n      uv*=rot(sin(float(iFrame))*.01);\n\tvec3 gcol = vec3(0.);\n\n    vec3 col = vec3(0.1);\n   // vec3 ro = vec3(uv*6.+hash2()*inversesqrt(exp(iFrame)),-20.);\n   vec3 ro = vec3(uv*6.,-20.);\n    vec3 rt = vec3(0.);\n    vec3 rp = ro;\n\n    vec3 er = normalize(vec3(0.,0.,1.));\n    vec3 rd = er;\n\n     vec3 go = blurAmount*vec3( -2.5+ 5.0*hash2(), 0.0 );\n        go.xy *=rot(seed*.1);\n         go.xz *=rot(seed*.1);\n     vec3 gd = normalize( er*focusDistance - go );\n\n        ro += go*.1;\n        rd += gd*.1;;\n    vec3 light = vec3(-5,2.,-3.);\n    \n    vec3 acc = vec3(.0);\n    float s = 1.;\n    float dd = 1.;\n    for(float i=0.;i<=128.;i++){\n        vec2 d = sdf(rp);\n        vec3 mat_col = vec3(0.);\n        \n        d.x *=s;\n        if(d.y == 1.){\n            mat_col = vec3(.2,.8,.2);\n        } else if (d.y == 2.){\n            mat_col = vec3(.8,.2,.2);\n        }\n        if(d.y == 1. || d.y == 2.){\n         acc += mat_col*exp(.125*-abs(d.x*d.x))/30.;\n        }\n        if(d.x<.001){\n            vec3 n = norm(rp,.001);\n            vec3 nn = norm(rp,.005);\n            float diff = max(0.,dot(normalize(light-rp),n));\n            \n              float spc = max(0.,dot(normalize(ro-rp),reflect(normalize(rp-light),n)));\n            spc = pow(spc,32.);\n             if(d.y == 3.){\n                col = vec3(.3)*diff-vec3(1.)*step(.3,length(n-nn));\n                col = mix(col*.1,col,vec3(gao(rp,n))/3.);\n                break;\n            } else {\n            col += mat_col*smoothstep(.0,.1,length(n-nn));\n            \n            rp += rd*.1;\n            s*=-1.;\n           \n           if((gp.y) > -.99) { \n                vec3 ccol = 1.5*col*spc+diff*mat_col; \n                ccol = mix(ccol*.1,ccol,vec3(gao(rp,n))/2.);\n                col = mix(ccol,col,smoothstep(1.,-.545, gp.y+.8));\n                break;\n            }}\n            \n        }\n        rp += rd*d.x;\n    }\n    col += acc;\n     vec4 pframe = vec4(texture(iChannel0,fragCoord.xy/iResolution.xy));\n  col +=acc;\n\tcol +=pframe.xyz;\n   \n    \n\tfragColor = vec4(col,pframe.a+2.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl33z7.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1132, 1132, 1189, 1239, 1436]], "test": "untested"}
{"id": "fdVXD3", "name": "Importance sampling visualizer", "author": "hamtarodeluxe", "description": "Checking GGX importance sampling from \"Real Shading in Unreal Engine 4\" by Brian Karis, Epic Games.\nSee arrays in buffer A to change roughnesses :)\n", "tags": ["raymarching", "sampling", "ibl", "ggx", "ggx", "importance", "vandercorput"], "likes": 30, "viewed": 643, "published": 3, "date": "1635869486", "time_retrieved": "2024-07-30T18:51:04.119039", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(pow(col,vec3(0.45)),1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI 3.1459f\n#define RAYMARCHSTEPS 256\n#define SAMPLECOUNT 256\n\nvec3 positions[] = vec3[](  vec3(1.5, 0.0, 1.0), \n                            vec3(0.0, 0.0, 1.0), \n                            vec3(-1.5, 0.0, 1.0), \n                            vec3(1.5, 0.0,-1.0), \n                            vec3(0.0, 0.0, -1.0), \n                            vec3(-1.5, 0.0, -1.0));\n                         \nfloat roughnesses[] = float[](1.0, 0.8, 0.5, 0.4, 0.3, 0.2);\n\nvec3 offset = vec3(0.,0.,-3.);\n\n// Van der Corput sequence\nfloat\tvdc(uint bits) \n{\n\tbits = (bits << 16u) | (bits >> 16u);\n\tbits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n\tbits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n\tbits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n\tbits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n\treturn float(bits) * 2.3283064365386963e-10;\n}\n\n// Hammersley point set\nvec2 hs(uint i, uint N) \n{\n\treturn vec2(float(i) / float(N), vdc(i));\n} \n \n// GGX importance direction sampling, based on Real Shading in Unreal Engine 4 by Brian Karis, Epic Games\nvec3 importanceSampleGGX(vec2 Xi, vec3 N, float roughness, float rot)\n{\n\tfloat a = roughness * roughness;\n\t\n\tfloat phi = 2.0 * PI * fract(Xi.x + rot);\n\tfloat cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n\tfloat sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\t\n\t// From spherical coordinates to cartesian coordinates\n\tvec3 H;\n\tH.x = cos(phi) * sinTheta;\n\tH.y = sin(phi) * sinTheta;\n\tH.z = cosTheta;\n\t\n\t// From tangent-space vector to world-space sample vector\n\tvec3 up = abs(N.z) < 0.5 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n\tvec3 tangent = normalize(cross(up, N));\n\tvec3 bitangent = cross(N, tangent);\n\t\n\tvec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n\n\treturn normalize(sampleVec);\n}\n\n// Caspule, from IQ's website\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba) / dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 dc = uv - 0.5;\n    dc.x *= iResolution.x/iResolution.y;\n    \n    // Current sample and object indices from iFrame\n    uint objectID = uint(floor(float(iFrame) / float(SAMPLECOUNT)));\n    uint sampleI = uint(iFrame % SAMPLECOUNT);\n    float roughness = roughnesses[objectID];\n    vec3 objectPos = positions[objectID];\n    \n    // Camera\n    vec3 ro = 5.*vec3(0., 1.5, 3.);\n    vec3 lookAt = vec3(0., 0.5, 0.);\n    vec3 up = vec3 (0, 1, 0);\n    vec3 fw = normalize(lookAt-ro);\n    vec3 rd = fw;\n    vec3 right = normalize(cross(fw, up));\n    up = normalize(cross(right,fw));  \n    ro = ro + (up*dc.y + right*dc.x) * 2.5;\n    \n    // Raymarching\n    float t = 0.;\n    bool hasHit = false;\n    vec3 p; int i;\n    for (i = 0; i < RAYMARCHSTEPS; i++)\n    {\n        p = ro + rd*t;\n        \n        float dGGX;\n        float dFib;\n        \n        vec2 s = hs(sampleI, uint(SAMPLECOUNT));\n        vec3 N = vec3(0.0f, 1.0f, 0.0f);\n        vec3 H = importanceSampleGGX(s, N, roughness, 0.f);\n        vec3 L  = normalize(2.0 * dot(N, H) * H - rd);\n        float d = sdCapsule(p, objectPos, objectPos + L, 0.02f);\n                \n        if (d < 0.00001)\n        {\n            objectPos += dFib < dGGX ? offset : vec3(0.);\n            hasHit = true;\n            break; \n        }\n        t+=d;\n    }\n    \n    // Background\n    vec4 col = vec4(0.1, 0.1, 0.1, 1000.0f);\n    col.rgb *=  1./pow((pow(sqrt(dot(dc * 2., dc * 2.)*.4),2.)+1.),3.);\n    \n    if (iFrame != 0)\n        col = texture(iChannel0, uv);\n    \n    // Shading\n    if (hasHit && (iFrame < (SAMPLECOUNT * 6)) && (t < col.a))\n    {\n        col.rgb = vec3(0.8*pow(sin(float(iFrame)*3.),2.), 0.7*cos(float(iFrame)*5.5), sin(float(objectID)*2.0f));\n        col.rgb = cross(col.rgb, normalize(objectPos));\n        col.rgb = col.rgb * 0.5f + 0.5f;\n        col.rgb = col.rgb*pow(length(p.rgb-objectPos),10.)+ 0.05*col.rgb;\n        col.a = t;\n    }    \n\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVXD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 297]], "test": "untested"}
{"id": "st3GR7", "name": "Gas emitter", "author": "michael0884", "description": "Combining MPM-MLS with reintegration tracking. The main idea here is to add forces while advecting mass, not before. For some reason cant make it stable while using the affine matrix, so rn it does not conserve angular momentum as well as I would like.", "tags": ["fluid", "particles", "reintegration", "mpm", "apic"], "likes": 15, "viewed": 573, "published": 3, "date": "1635865637", "time_retrieved": "2024-07-30T18:51:04.889978", "image_code": "//MIT License\n//Copyright 2021 Mykhailo Moroz\n\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb); \t\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    P = floor(P);\n    \n    if(iMouse.z < 0.)\n    {\n       // P = iMouse.xy + 100.*(P/R.x - 0.5); \n    }\n    \n    float m = 0.0;\n    float rho = 0.0;\n    vec2 v = vec2(0.0);\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        //load data\n        vec2 di = vec2(i,j);\n        vec4 data0 = A(P + di);\n        vec4 data1 = B(P + di);\n        \n        //unpack data\n        float m0 = data0.y;\n        vec2 x0 = decode(data0.x) - fract(P);\n        vec2 v0 = decode(data1.x);\n        mat2 B0 = mat2(decode(data1.y),decode(data1.z)); //velocity gradient\n        //update particle position\n        x0 = x0 + di + v0*dt;\n        \n        //find cell contribution\n        vec3 o = overlap(x0, vec2(1.0));\n        \n        m += m0*o.z;\n        \n        float w = k1(x0);\n        \n        v += (v0 + 4.0*B0*x0)*w;\n        rho += m0*w;\n    }\n    \n    float arg = 0.5*(atan(v.y, v.x)/PI + 1.0);\n    float d = 2.5*length(v);\n    vec3 fluid = hsv2rgb(vec3(arg, 0.64, tanh(d)));\n    \n    C = vec4(mix( vec3(0.000,0.000,0.000),fluid, smoothstep(0.,1.,rho)), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R;\nvec4 Mouse;\nfloat time;\nint frame;\n\n#define A(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define B(p) texelFetch(iChannel1, ivec2(mod(p,R)), 0)\n\n#define CH(c, p) texelFetch(c, ivec2(mod(p,R)), 0)\n\n//loop in range\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 0.4\n#define max_vel 1.0\n#define rad 2\n\n#define diffusion 0.005\n#define gravity 0.005\n\n#define PI 3.14159265\n\n#define rest_rho 1.0\n#define eos_pressure 0.5\n\n//reduce rotation/shearing of low density particles\n//without this the vacuum and border state very chaotic, but it still works fine\n//in usual MPM that isn't necessary since the particles don't change mass\nfloat affine_str(float m)\n{\n    return 1.0; //full APIC\n    //return smoothstep(0.5*rest_rho,0.55*rest_rho,m);\n}\n\n//pressure equation of state\nfloat pressure(float rho)\n{\n    return 1.0*(rho - 0.0); //gas\n   // return eos_pressure*(pow(rho/rest_rho,4.) - 1.0); //Tait EOS (water)\n}\n\nvoid InitialConditions(inout float m, inout vec2 v, vec2 P)\n{\n    vec2 dx = P - R*vec2(0.3, 0.5);\n\n    float d = smoothstep(R.y*0.5, R.y*0.49, length(dx));  \n    m = 0.0*d;\n\n    v = d*0.3*normalize(vec2(dx.y,-dx.x));\n}\n\n//KERNEL FUNCTIONS\n\nfloat k0(vec2 dx) //linear kernel\n{\n    vec2 k = max(1.0 - abs(dx), 0.);\n    return k.x*k.y;\n}\n\nvec3 K0(vec2 dx) //linear kernel with the center of mass\n{\n    vec2 k = max(1.0 - abs(dx), 0.);\n    return vec3(dx*0.5, k.x*k.y);\n}\n\nfloat k1(vec2 dx) //quadratic kernel\n{\n    vec2 f = max(1.5 - abs(dx), 0.0);\n    vec2 k = min(max(0.75 - dx*dx, 0.5), 0.5*f*f);\n    return k.x*k.y;\n}\n\n//box size enstimator\nvec2 destimator(vec2 dx)\n{\n    return diffusion*dt+clamp(1.0 - 2.0*abs(dx), 0.001, 1.0);\n}\n\n//box overlap with center of mass\nvec3 overlap(vec2 dx, vec2 box)\n{\n    vec2 min0 = max(dx - box*0.5, -0.5); \n    vec2 max0 = min(dx + box*0.5, 0.5); \n    vec2 size = max(max0 - min0, 0.); \n    return vec3(0.5*(max0 + min0), size.x*size.y/(box.x*box.y));\n}\n\n//boundary\n#define border_h 3.\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -border_h-sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n\n    return bound;\n}\n\n#define h 5.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\n//DATA PACKING\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X)*3.0; \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x/3.0);\n    return uintBitsToFloat(X); \n}\n\n//particle to grid\nvec4 P2G(sampler2D a, sampler2D b, vec2 P)\n{\n    vec2 x = vec2(0.0);\n    vec2 v = vec2(0.0);\n    float m = 0.0;\n    float rho = 0.0;\n    \n    range(i, -1, 1) range(j, -1, 1)\n    {\n        //load data\n        vec2 di = vec2(i,j);\n        vec4 data0 = CH(a, P + di);\n        vec4 data1 = CH(b, P + di);\n        \n        //unpack data\n        float m0 = data0.y;\n        float r0 = data0.w;\n        vec2 x0 = decode(data0.x);\n        vec2 v0 = decode(data1.x);\n        mat2 B0 = mat2(decode(data1.y),decode(data1.z)); //velocity gradient\n        \n        //estimate the shape of the distribution\n        vec2 box = destimator(x0);\n        \n        //predicted density using the affine matrix, thanks to Grant Kot for this idea\n        //float rho = ;//;\n        mat2 stress = -mat2(clamp(pressure(data1.w/determinant(mat2(1.0) + 4.0*B0*dt)), -1., 1.));\n        \n        //update particle position\n        x0 = x0 + di + v0*dt;\n    \n        //find cell contribution\n        vec3 o = overlap(x0, box);\n         \n        //update distribution\n        x += m0*o.xy*o.z;\n        m += m0*o.z;\n        \n        //find grid node contribution\n        float w = k1(x0);\n        \n        //distribute momentum onto grid\n        v += (v0 + 4.0*B0*x0 + dt*stress*x0)*w*m0;\n        rho += m0*w;\n    }\n    \n    \n    //normalize\n    if(rho > 0.0) v /= rho;\n    if(m > 0.0) x /= m;\n    \n    m = mix(m, 0.3, dt*0.0085);\n   \n    if(length(P - R*vec2(0.8, 0.9)) < 10.) \n    {\n       // x = vec2(0.0);\n       // v = 1.8*Dir(-PI*0.25 - PI*0.5 + 0.3*sin(0.4*time));\n       // m = mix(m, rest_rho, 0.4*dt);\n    }\n\n    if(length(P - R*vec2(0.2, 0.9)) < 10.) \n    {\n       //x = vec2(0.0);\n       // v =1.8*Dir(-PI*0.25 + 0.3*sin(0.4*time));\n       // m = mix(m, rest_rho, 0.4*dt);\n    }\n    \n    //initial conditions\n    if(frame < 1)\n    {\n        InitialConditions(m, v, P);\n    }\n    \n    v = (length(v)>max_vel)?normalize(v)*max_vel:v;\n    \n    return vec4(encode(x), m, encode(v), rho);\n}\n\n//grid to particle\nvec4 G2P(sampler2D a, sampler2D b, vec2 P)\n{\n    vec2 V = vec2(0.0);\n    mat2 B = mat2(0.0);\n    \n    vec4 data = CH(a, P);\n    float m = data.y;\n    vec2 x = decode(data.x);\n    float mass = 0.0;\n    \n    range(i, -1, 1) range(j, -1, 1)\n    {\n        //load data\n        vec2 di = vec2(i,j);\n        vec4 data0 = CH(a, P + di);\n        \n        //unpack data\n        float m0 = data0.y;\n        float rho = data0.w;\n        vec2 x0 = decode(data0.x);\n        vec2 dx = x - di;\n        vec2 v0 = decode(data0.z);\n        \n        //find grid node contribution\n        float w = k1(dx);\n        \n        //distribute velocities/forces to particles\n        V += v0*w;\n        vec2 nv0 =dot(v0, normalize(dx))*normalize(dx);\n        //v0 = v0 - nv0 + clamp(nv0, -0.01, 0.01);//remove divergent component, makes it unstable otherwise\n        B += mat2(v0*dx.x,v0*dx.y)*w;\n    }\n    \n    //gravity\n  //  V += vec2(0.0, -gravity)*dt;\n    \n    //push fluid\n    V += vec2(0.0, 0.1)*exp(-0.02*pow(distance(P, R*vec2(0.6,0.2)), 2.));\n    \n    if(Mouse.z > 0.)\n    {\n        vec2 dx = (Mouse.xy - P); \n        V += 0.005*exp(-0.05*length(dx))*dt*dx; \n    }\n    \n    //border \n    vec3 N = bN(P + x);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, V);\n    //V *= 1. - 0.1*exp(-N.z);\n    V += (0. + 1.5*max(vdotN, 0.0))*N.xy*step(abs(N.z), border_h)*exp(-N.z);\n   // V = (length(V)>max_vel)?normalize(V)*max_vel:V;\n   \n    //estimate density\n    x += V*dt;\n   \n    range(i, -1, 1) range(j, -1, 1)\n    {\n        //load data\n        vec2 di = vec2(i,j);\n        vec4 data0 = CH(a, P + di);\n        vec2 dx = x - di;\n        //unpack data\n        float m0 = data0.y;\n        \n        mass += m0*k1(dx);\n    }\n    const float lim = 0.01; //affine matrix clamp\n    return vec4(encode(V), encode(clamp(B[0], -lim,lim)), encode(clamp(B[1], -lim,lim)), mass);\n}\n\n", "buffer_a_code": "//Advect mass distributions and distrubute the momentum and density to grid\n\n//Advect + P2G\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse; frame = iFrame;\n    P = floor(P);\n   \n    C = P2G(iChannel0,iChannel1,P);\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//Distribute grid velocities to the mass distributions\n\n//G2P\n\n//technically its more correct to do the force in the P2G step 2\n//but I didn't want to waste a buffer here\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse; frame = iFrame;\n    P = floor(P);\n    C = G2P(iChannel0, iChannel1, P);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//Advect + P2G\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse; frame = iFrame;\n    P = floor(P);\n   \n    C = P2G(iChannel0,iChannel1,P);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//G2P\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse; frame = iFrame;\n    P = floor(P);\n    C = G2P(iChannel0, iChannel1, P);\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st3GR7.jpg", "access": "api", "license": "mit", "functions": [[48, 48, 75, 75, 233]], "test": "untested"}
{"id": "st3GzM", "name": "Pseudo 3D mess", "author": "SnoopethDuckDuck", "description": "testing different tricks, think I overdid it a bit", "tags": ["e"], "likes": 7, "viewed": 335, "published": 3, "date": "1635861129", "time_retrieved": "2024-07-30T18:51:05.676874", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    //uv += 0.5 * (.5 + .5 * tanh(2. * sin(0.2 * iTime))) * tanh(3. * vec2(cos(uv.x + iTime), sin(uv.y + iTime)));\n    uv = rot(uv, 0.21 * iTime);\n    uv.y +=  0.1 * tanh(4. * cos(10. * uv.x + iTime));\n    uv += 0.5 * vec2(tanh(4. * cos(0.1 * iTime)), tanh(4. * sin(0.1 * iTime)));\n    \n    float r = length(uv);\n    float a = atan(uv.y, uv.x);\n    float sc = 20. * tanh(0.2 * iTime) + 3. * tanh(2. * cos(.5 * r + sin(1. * iTime + tanh(2. * cos(8. * r + 2. * a - 4.* iTime))) + 0. * h21(uv) - iTime));\n    vec2 fpos = fract(sc * uv) - 0.5;\n    vec2 ipos = floor(sc * uv) + 0.5;\n\n   // fpos.y += 0.1 * cos(100. * uv.x + iTime);\n\n    float d = length(fpos) * max(1.6 * r, 0.8 * length(fpos));\n    d *= 1.5;\n    d *= .5 + .5 * sc * tanh(2. * cos(1.5 * h21(ipos) + 1./(1. + length(uv)) * 10. * d - 4. * iTime));\n    float s = step(d, 0.2 + (sc - 7. )/3. * 0.15);// + 0.18 * tanh(4. * cos(11. * h21(ipos) + iTime)));\n    \n    vec3 e = vec3(.5);\n    vec3 al = pal(h21(10. * ipos)+ 0.1 * iTime,e*1.2,e,e*2.0, vec3(0,0.33,0.66));\n    vec3 col = clamp(al,0.,1.);\n    col = mix(col, vec3(step(col.x,0.9)), .5 + .5 * tanh(10. * cos(8. * tanh(4. * cos(1. * iTime)) + iTime +  10.*r + a)));\n    col *= vec3(s);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "vec2 rot (vec2 vec, float a) {\n    float m = 3.;\n    mat2 mat = mat2(tanh(m * cos(a)), -tanh(m * sin(a)) , tanh(m * sin(a)), tanh(m * cos(a)));\n    return mat * vec;\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st3GzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1431]], "test": "untested"}
{"id": "ft3GR7", "name": "波二", "author": "yjx", "description": "distortion of wave", "tags": ["wave"], "likes": 4, "viewed": 228, "published": 3, "date": "1635857964", "time_retrieved": "2024-07-30T18:51:06.442826", "image_code": "float omega(float k){\nreturn sqrt(10.*k);}\n\nvoid mainImage( out vec4 O,vec2 u )\n{\n    vec2 R=iResolution.xy,\n         U = 60.*( u - .5*R ) / R.x;\n    float n =10.;\n    \n    for(float i=1.;i<n;i++){\n    float k=.5*float(i)+5.;\n    O+=cos(k*length(U)-omega(k)*iTime)/sqrt(n);}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft3GR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 42], [44, 44, 81, 81, 276]], "test": "untested"}
{"id": "ftt3z8", "name": "MLS Reintegration", "author": "michael0884", "description": "Combining MPM-MLS with reintegration tracking. The main idea here is to add forces while advecting mass, not before. ", "tags": ["fluid", "particles", "reintegration", "mpm", "apic"], "likes": 31, "viewed": 733, "published": 3, "date": "1635852572", "time_retrieved": "2024-07-30T18:51:07.219749", "image_code": "//MIT License\n//Copyright 2021 Mykhailo Moroz\n\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb); \t\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    P = floor(P);\n    \n    if(iMouse.z < 0.)\n    {\n       // P = iMouse.xy + 100.*(P/R.x - 0.5); \n    }\n    \n    float m = 0.0;\n    float rho = 0.0;\n    vec2 v = vec2(0.0);\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        //load data\n        vec2 di = vec2(i,j);\n        vec4 data0 = A(P + di);\n        vec4 data1 = B(P + di);\n        \n        //unpack data\n        float m0 = data0.y;\n        vec2 x0 = decode(data0.x) - fract(P);\n        vec2 v0 = decode(data1.x);\n        mat2 B0 = mat2(decode(data1.y),decode(data1.z)); //velocity gradient\n        //update particle position\n        x0 = x0 + di + v0*dt;\n        \n        //find cell contribution\n        vec3 o = overlap(x0, vec2(1.0));\n        \n        m += m0*o.z;\n        \n        float w = k1(x0);\n        \n        v += (v0 + 4.0*B0*x0)*w;\n        rho += m0*w;\n    }\n    \n    float arg = 0.5*(atan(v.y, v.x)/PI + 1.0);\n    float d = 5.5*pow(dot(v,v),1.2);\n    vec3 fluid = 1.-hsv2rgb(vec3(arg, 0., tanh(d)));\n    \n    C = vec4(mix( vec3(1.000,1.000,1.000),fluid, smoothstep(0.,2.,rho)), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R;\nvec4 Mouse;\nfloat time;\nint frame;\n\n#define A(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define B(p) texelFetch(iChannel1, ivec2(mod(p,R)), 0)\n\n#define CH(c, p) texelFetch(c, ivec2(mod(p,R)), 0)\n\n//loop in range\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 0.2\n#define max_vel 1.0\n#define rad 2\n\n#define diffusion 0.05\n#define gravity 0.005\n\n#define PI 3.14159265\n\n#define rest_rho 1.0\n#define eos_pressure 0.5\n\n//pressure equation of state\nfloat pressure(float rho)\n{\n    return 1.2*(rho - 1.2); //gas\n   // return eos_pressure*(pow(rho/rest_rho,4.) - 1.0); //Tait EOS (water)\n}\n\nvoid InitialConditions(inout float m, inout vec2 v, vec2 P)\n{\n    vec2 dx = P - R*vec2(0.3, 0.5);\n\n    float d = smoothstep(R.y*0.5, R.y*0.49, length(dx));  \n    m = 0.0*d;\n\n    v = d*0.3*normalize(vec2(dx.y,-dx.x));\n}\n\n//KERNEL FUNCTIONS\n\nfloat k0(vec2 dx) //linear kernel\n{\n    vec2 k = max(1.0 - abs(dx), 0.);\n    return k.x*k.y;\n}\n\nvec3 K0(vec2 dx) //linear kernel with the center of mass\n{\n    vec2 k = max(1.0 - abs(dx), 0.);\n    return vec3(dx*0.5, k.x*k.y);\n}\n\nfloat k1(vec2 dx) //quadratic kernel\n{\n    vec2 f = max(1.5 - abs(dx), 0.0);\n    vec2 k = min(max(0.75 - dx*dx, 0.5), 0.5*f*f);\n    return k.x*k.y;\n}\n\n//box size enstimator\nvec2 destimator(vec2 dx)\n{\n    return diffusion*dt+clamp(1.0 - 2.0*abs(dx), 0.001, 1.0);\n}\n\n//box overlap with center of mass\nvec3 overlap(vec2 dx, vec2 box)\n{\n    vec2 min0 = max(dx - box*0.5, -0.5); \n    vec2 max0 = min(dx + box*0.5, 0.5); \n    vec2 size = max(max0 - min0, 0.); \n    return vec3(0.5*(max0 + min0), size.x*size.y/(box.x*box.y));\n}\n\n//boundary\n#define border_h 3.\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -border_h-sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n\n    return bound;\n}\n\n#define h 5.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\n//DATA PACKING\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X)*3.0; \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x/3.0);\n    return uintBitsToFloat(X); \n}\n\n//particle to grid\nvec4 P2G(sampler2D a, sampler2D b, vec2 P)\n{\n    vec2 x = vec2(0.0);\n    vec2 v = vec2(0.0);\n    float m = 0.0;\n    float rho = 0.0;\n    \n    range(i, -1, 1) range(j, -1, 1)\n    {\n        //load data\n        vec2 di = vec2(i,j);\n        vec4 data0 = CH(a, P + di);\n        vec4 data1 = CH(b, P + di);\n        \n        //unpack data\n        float m0 = data0.y;\n        float r0 = data0.w;\n        vec2 x0 = decode(data0.x);\n        vec2 v0 = decode(data1.x);\n        mat2 B0 = mat2(decode(data1.y),decode(data1.z)); //velocity gradient\n        \n        //estimate the shape of the distribution\n        vec2 box = destimator(x0);\n        \n        //predicted density using the affine matrix, thanks to Grant Kot for this idea\n        //float rho = ;//;\n        mat2 stress = -mat2(clamp(pressure(data1.w/determinant(mat2(1.0) + 4.0*B0*dt)), -1., 1.));\n        \n        //update particle position\n        x0 = x0 + di + v0*dt;\n    \n        //find cell contribution\n        vec3 o = overlap(x0, box);\n         \n        //update distribution\n        x += m0*o.xy*o.z;\n        m += m0*o.z;\n        \n        //find grid node contribution\n        float w = k1(x0);\n        \n        //distribute momentum onto grid\n        v += (v0 + 4.0*B0*x0 + dt*stress*x0)*w*m0;\n        rho += m0*w;\n    }\n    \n    \n    //normalize\n    if(rho > 0.0) v /= rho;\n    if(m > 0.0) x /= m;\n    \n   // m = mix(m, 0.3, dt*0.002);\n   \n    if(length(P - R*vec2(0.8 + 0.05*sin(2.4*time), 0.9)) < 10.) \n    {\n        x = vec2(0.0);\n        v = 1.8*Dir(-PI*0.25 - PI*0.5 + 0.45*sin(3.4*time));\n        m = mix(m, rest_rho, 0.4*dt);\n    }\n\n    if(length(P - R*vec2(0.2+ 0.05*sin(2.4*time), 0.9)) < 10.) \n    {\n       x = vec2(0.0);\n        v =1.8*Dir(-PI*0.25 + 0.45*sin(3.4*time));\n        m = mix(m, rest_rho, 0.4*dt);\n    }\n    \n    //initial conditions\n    if(frame < 1)\n    {\n        InitialConditions(m, v, P);\n    }\n    \n    v = (length(v)>max_vel)?normalize(v)*max_vel:v;\n    \n    return vec4(encode(x), m, encode(v), rho);\n}\n\n//grid to particle\nvec4 G2P(sampler2D a, sampler2D b, vec2 P)\n{\n    vec2 V = vec2(0.0);\n    mat2 B = mat2(0.0);\n    \n    vec4 data = CH(a, P);\n    float m = data.y;\n    vec2 x = decode(data.x);\n    float mass = 0.0;\n    \n    range(i, -1, 1) range(j, -1, 1)\n    {\n        //load data\n        vec2 di = vec2(i,j);\n        vec4 data0 = CH(a, P + di);\n        \n        //unpack data\n        float m0 = data0.y;\n        float rho = data0.w;\n        vec2 x0 = decode(data0.x);\n        vec2 dx = x - di;\n        vec2 v0 = decode(data0.z);\n        \n        //find grid node contribution\n        float w = k1(dx);\n        \n        //distribute velocities/forces to particles\n        V += v0*w;\n        vec2 nv0 =dot(v0, normalize(dx))*normalize(dx);\n        //v0 = v0 - nv0 + clamp(nv0, -0.01, 0.01);//remove divergent component, makes it unstable otherwise\n        B += mat2(v0*dx.x,v0*dx.y)*w;\n    }\n    \n    float divergence = 0.5*(B[0][0] + B[1][1]);\n    \n    B -= 1.0*mat2(divergence);\n    \n    //gravity\n    V += -gravity*vec2(sin(0.),cos(0.))*dt;\n    \n    //push fluid\n    V += vec2(0.0, 1.0)*exp(-0.02*pow(distance(P, R*vec2(0.6,0.2)), 2.));\n    \n    if(Mouse.z > 0.)\n    {\n        vec2 dx = (Mouse.xy - P); \n        V += 0.001*exp(-0.03*length(dx))*dt*dx; \n    }\n    \n    //border \n    vec3 N = bN(P + x);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, V);\n    //V *= 1. - 0.1*exp(-N.z);\n    V += (0. + 1.5*max(vdotN, 0.0))*N.xy*step(abs(N.z), border_h)*exp(-N.z);\n   // V = (length(V)>max_vel)?normalize(V)*max_vel:V;\n   \n    //estimate density\n    x += V*dt;\n   \n    range(i, -1, 1) range(j, -1, 1)\n    {\n        //load data\n        vec2 di = vec2(i,j);\n        vec4 data0 = CH(a, P + di);\n        vec2 dx = x - di;\n        //unpack data\n        float m0 = data0.y;\n        \n        mass += m0*k1(dx);\n    }\n   \n    return vec4(encode(V), encode(clamp(B[0], -0.1,0.1)), encode(clamp(B[1], -0.1,0.1)), mass);\n}\n\n", "buffer_a_code": "//Advect mass distributions and distrubute the momentum and density to grid\n\n//Advect + P2G\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse; frame = iFrame;\n    P = floor(P);\n   \n    C = P2G(iChannel0,iChannel1,P);\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//Distribute grid velocities to the mass distributions\n\n//G2P\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse; frame = iFrame;\n    P = floor(P);\n    C = G2P(iChannel0, iChannel1, P);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//Advect + P2G\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse; frame = iFrame;\n    P = floor(P);\n   \n    C = P2G(iChannel0,iChannel1,P);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//G2P\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse; frame = iFrame;\n    P = floor(P);\n    C = G2P(iChannel0, iChannel1, P);\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftt3z8.jpg", "access": "api", "license": "mit", "functions": [[48, 48, 75, 75, 233]], "test": "untested"}
{"id": "Ntc3R7", "name": "Raymarching with Dithering", "author": "AJFarmar", "description": "A simple raymarcher with multiple materials, each of which is dithered in a different way.", "tags": ["raymarching", "sdf", "shader", "dithering", "signeddistance", "onebit"], "likes": 14, "viewed": 401, "published": 3, "date": "1635848702", "time_retrieved": "2024-07-30T18:51:07.982709", "image_code": "/* This defines what stage of the process we show.\n * Uncomment/recomment different ones to see different parts.\n */\n//#define SHOW_ID\n//#define SHOW_DEPTH\n//#define SHOW_NORMAL\n//#define SHOW_BRIGHTNESS\n#define SHOW_DITHER\n//#define PIXELLATE\n\n// Determines the size of the dither \"pixels\".\n#define SQUARE_SIZE (2)\n\n// Firstly, we define all the usual raymarching necessities.\nconst int   MAX_MARCH = 1024; // The number of steps after which we stop marching.\nconst int   MAX_LIGHT_MARCH = 256; // The number of steps after which we stop calculating shadows.\nconst float CLOSE     = 0.00005; // \"Close enough\" distance. Arbitrary here.\nconst float FAR       = 5.0; // \"Far enough\" distance. Arbitrary here.\nconst float PI = 3.1415926535897; // Just useful.\n\n// Sunlight. We'll change this eventually.\nconst vec3 SUNLIGHT = vec3(0.4, -1.0, 1.3)/1.6881943;\n\n/* We track the maximum number of objects in the scene.\n * We could do way more than 16, but it really doesn't matter.\n * This will just be used to keep track of the IDs of objects.\n */\n#define MAX_OBJECTS (4)\n\n// Now we define some signed distance functions, with ADDITIONAL PARAMETERS!\nstruct SDFData\n{\n    float dist;\n    int id;\n    vec3 normal;\n};\n/* These parameters will become important in future layers, since we will use\n * the same scene definition multiple times.\n */\n#define SPHERE(center, radius, id, v) (SDFData( distance(v,center) - radius, id, normalize(v-center) ))\n#define SOLIDPLANE(point, normal, id, v) (SDFData( dot(v-point, normal), id, normal ))\nSDFData UNION(SDFData sdf1, SDFData sdf2)\n{\n    if (sdf1.dist <= sdf2.dist)\n        return sdf1;\n    return sdf2;\n}\nSDFData INTERSECTION(SDFData sdf1, SDFData sdf2)\n{\n    if (sdf1.dist <= sdf2.dist)\n        return sdf2;\n    return sdf1;\n}\n\n// Objects' information in the scene.\nstruct ObjectInfo {\n    int ditherer;\n};\n\n// We record the object information for each object.\nconst ObjectInfo objectList[MAX_OBJECTS] = ObjectInfo[MAX_OBJECTS](\n    ObjectInfo(2),\n    ObjectInfo(0),\n    ObjectInfo(2),\n    ObjectInfo(0)\n);\n\n// The scene. Outputs the object ID as well as the distance and the normal.\nSDFData sceneSDF(vec3 v)\n{\n    // We will have a sphere and a cube lying on a flat plane, each a different object.\n    return UNION(UNION(UNION(\n    // First object: the plane.\n        SOLIDPLANE(vec3(0.0), vec3(0.0, 1.0, 0.0), 1, v)\n    ,\n    // Second object: the sphere.\n        SPHERE(vec3(1.2, 0.4, -0.1), 0.4, 2, v)\n    ),\n    // Third object: the smaller sphere.\n        SPHERE(vec3(0.1, 0.2, -0.75), 0.2, 3, v)\n    ),\n    // Fourth object: the cube with rounded corners.\n        // To build a cube, we intersect 6 solid planes. This will get a bit messy!\n        INTERSECTION(INTERSECTION(INTERSECTION(\n        // X sides\n            INTERSECTION(\n                SOLIDPLANE(vec3(0.5, 0.0, 0.0), vec3(1.0, 0.0, 0.0), 4, v),\n                SOLIDPLANE(vec3(-0.5, 0.0, 0.0), vec3(-1.0, 0.0, 0.0), 4, v)\n            )\n        ,\n        // Y sides\n            INTERSECTION(\n                SOLIDPLANE(vec3(0.0, 1.0, 0.0), vec3(0.0, 1.0, 0.0), 4, v),\n                SOLIDPLANE(vec3(0.0, 0.0, 0.0), vec3(0.0, -1.0, 0.0), 4, v)\n            )\n        ),\n        // Z sides\n            INTERSECTION(\n                SOLIDPLANE(vec3(0.0, 0.0, 0.5), vec3(0.0, 0.0, 1.0), 4, v),\n                SOLIDPLANE(vec3(0.0, 0.0, -0.5), vec3(0.0, 0.0, -1.0), 4, v)\n            )\n        ),\n        // We intersect a cube with a sphere to round the corners.\n            SPHERE(vec3(0.0, 0.5, 0.0), 0.75, 4, v)\n        )\n    );\n}\n\n// Different dithering methods\nfloat calculateDither(vec2 coord, float brightness, int dithererID) {\n    float ditherTexture;\n    if (dithererID == 1) {\n        ditherTexture = texture(iChannel1, coord/256.0).x;\n    } else if (dithererID == 2) {\n        ditherTexture = texture(iChannel2, coord/1024.0).x;\n    } else if (dithererID == 3) {\n        ditherTexture = texture(iChannel2, coord/1024.0).z;\n    } else {\n        ditherTexture = texture(iChannel0, coord/8.0).x;\n    }\n\n    return step(ditherTexture+0.001, brightness);\n}\n\n// The result of raymarching\nstruct RayMarch {\n    float depth; // How far away from the camera are we?\n    int id;      // Which object have we hit?\n    vec3 normal; // What's the normal to this surface?\n    float light; // Does this object recieve direct light?\n};\n\n// The raymarching algorithm!\nRayMarch raymarch(mat4 camera, vec2 relCoord)\n{\n\n    // Calculate the position of the eye.\n    vec4 eye_homog = camera * vec4(0.0, 0.0, 0.0, 1.0);\n    vec3 eye = eye_homog.xyz / eye_homog.w;\n    \n    // Calculate the direction that we'll be looking in.\n    vec4 offsetRay_homog = camera * vec4(relCoord, 1.0, 1.0);\n    vec3 ray = normalize((offsetRay_homog.xyz/offsetRay_homog.w) - eye);\n    \n    // We begin raymarching -- yippee!\n    int steps = 0;\n    vec3 v = eye;\n    float totalDist = 0.0;\n    bool shouldContinue = true;\n    SDFData depthInfo;\n    do {\n        depthInfo = sceneSDF(v);\n        v += depthInfo.dist * ray;\n        totalDist += depthInfo.dist;\n        steps += 1;\n        shouldContinue =\n            abs(depthInfo.dist) >= CLOSE\n         && depthInfo.dist <= FAR\n         && steps <= MAX_MARCH;\n    } while (shouldContinue);\n    \n    // What if we're just looking at the sky?\n    if (steps >= MAX_MARCH || depthInfo.dist >= FAR)\n        // For now, ignore the normal vector for the sky.\n         return RayMarch(0.0, 0, vec3(0.0), 0.0);\n         \n    // Now, we do reflection by raymarching AGAIN.\n    // TODO: make this dependent on the material of the object.\n    ray = -SUNLIGHT;\n    v += (1.001)*CLOSE*depthInfo.normal;\n    steps = 0;\n    shouldContinue = true;\n    float dist;\n    do {\n        dist = sceneSDF(v).dist;\n        v += dist * ray;\n        steps += 1;\n        shouldContinue =\n            dist >= CLOSE\n         && dist <= FAR\n         && steps <= MAX_LIGHT_MARCH;\n    } while (shouldContinue);\n    \n    \n    // If we're really looking at an object.\n    return RayMarch(totalDist, depthInfo.id, depthInfo.normal, step(CLOSE, dist));\n}\n\n// Calculates the brightness of a point.\nfloat calculateBrightness(RayMarch info, vec3 gaze)\n{\n    float diffusion = dot(-SUNLIGHT, info.normal);\n    const float diffuse = 0.7;\n    \n    float speculation = abs(dot(SUNLIGHT, reflect(normalize(gaze), info.normal)));\n    speculation = clamp(speculation, 0.0, 1.0);\n    speculation = pow(speculation, 6.0);\n    const float specular = 0.7;\n    \n    float brightness = diffusion*diffuse + speculation*specular;\n    brightness = clamp(brightness, 0.0, 1.0);\n    brightness *= info.light;\n    return brightness;\n}\n\n// View matrix calculation.\nmat4 viewMatrix(vec3 eye, vec3 gaze, vec3 up)\n{\n    // By Jamie Wong, based on the gluLookAt man page.\n    // Lightly edited.\n    vec3 f = normalize(gaze);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(f, 0.0),\n        vec4(eye, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord;\n    #if defined(PIXELLATE) || defined(SHOW_DITHER)\n        vec2 sqCoord = floor(fragCoord/float(SQUARE_SIZE));\n        coord = float(SQUARE_SIZE)*sqCoord;\n    #else\n        coord = fragCoord;\n    #endif\n\n    // We get the signed distance info.\n    vec2 relCoord = (coord - 0.5*iResolution.xy)/iResolution.y;\n    vec3 eye = vec3(2.1 + 0.5*cos(iTime/1.5), 0.8 + 0.4*cos(iTime/1.5), -1.8+0.8*cos(iTime/1.5));\n    mat4 view = viewMatrix(\n        eye,\n        vec3(0.3 + 0.1*sin(iTime/2.0), 0.5 + 0.1*cos(iTime/2.0), 0.0) - eye,\n        vec3(0.0, 1.0, 0.0));\n    RayMarch distinfo = raymarch(view, relCoord);\n    ObjectInfo objinfo = objectList[distinfo.id-1];\n    \n    // Brightness\n    float brightness = calculateBrightness(distinfo, eye);\n    \n    // The various different layers of information\n    #if defined(SHOW_ID)\n        float colorAngle = 2.0 * PI * float(distinfo.id) / float(MAX_OBJECTS);\n        vec2 colorVector = vec2(cos(colorAngle), sin(colorAngle));\n        vec2 rV, gV, bV;\n        rV = vec2(1.0, 0.0);\n        gV = vec2(cos(2.0*PI/3.0), sin(2.0*PI/3.0));\n        bV = vec2(cos(-2.0*PI/3.0), sin(-2.0*PI/3.0));\n        vec3 idColor =\n              dot(colorVector, rV)*vec3(1.0,0.0,0.0)\n            + dot(colorVector, gV)*vec3(0.0,1.0,0.0)\n            + dot(colorVector, bV)*vec3(1.0,0.0,1.0);\n        if (distinfo.id == 0)\n             fragColor = vec4(0.0);\n        else fragColor = vec4(vec3(0.5) + 0.5*idColor, 1.0);\n    #elif defined(SHOW_DEPTH)\n        if (distinfo.id == 0)\n             fragColor = vec4(0.0);\n        else fragColor = vec4(vec3(1.0 - distinfo.dist/FAR), 1.0);\n    #elif defined(SHOW_NORMAL)\n        if (distinfo.id == 0)\n             fragColor = vec4(0.0);\n        else fragColor = vec4(0.5 + 0.5*distinfo.normal, 1.0);\n    #elif defined(SHOW_BRIGHTNESS)\n        if (distinfo.id == 0)\n             fragColor = vec4(0.0);\n        else fragColor = vec4(vec3(brightness), 1.0);\n    #elif defined(SHOW_DITHER)\n        float dither = calculateDither(sqCoord, brightness, objinfo.ditherer);\n        if (distinfo.id == 0)\n             fragColor = vec4(0.0);\n        else fragColor = vec4(vec3(dither), 1.0);\n    #endif\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntc3R7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1528, 1528, 1571, 1571, 1643], [1644, 1644, 1694, 1694, 1766], [2048, 2124, 2150, 2238, 3539], [3541, 3572, 3641, 3641, 4069], [4339, 4369, 4416, 4459, 6042], [6044, 6085, 6138, 6138, 6600], [6602, 6630, 6677, 6755, 6962], [6964, 6964, 7021, 7021, 9191]], "test": "untested"}
{"id": "fl33zM", "name": "Mercedes Sketches", "author": "dr2", "description": "Design drawings for \"Mercedes 500K\" (mouseable)", "tags": ["animation", "projection", "model", "car", "classic", "steer"], "likes": 27, "viewed": 342, "published": 3, "date": "1635841628", "time_retrieved": "2024-07-30T18:51:08.930176", "image_code": "// \"Mercedes Sketches\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Design drawings for \"Mercedes 500K\" (mouseable)\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrCaps2Df (vec2 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrFlatCapsDf (vec3 p, float r, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat PrTorusBxDf (vec3 p, vec3 b, float ri);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat Minv2 (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (int idVar);\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = (id); }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = (id);  qHit = q;}\n#define DMINQTR(id) if (d < dMin) { dMin = d;  idTrObj = (id);  qTrHit = q;}\n\nvec3 qHit, qTrHit, pgSize, ltDir, ltDirS, wlBase, carPos;\nvec2 wlRot;\nfloat tCur, dstFar, szFac, wlRad, strRot, carRot, spd, dInt, dWarch, pSign;\nint idObj, idTrObj;\nbool isSk;\nconst int idBod = 1, idTyr = 2, idHub = 3, idDash = 4, idWarch = 5, idBase = 6, idExR = 7,\n   idExF = 8, idWscrn = 9, idSeat = 10, idStWhl = 11, idPlat = 12, idMLit = 13, idCLit = 14,\n   idSLit = 15, idRLit = 16, idAx = 17, idShin = 18, idLtSil = 19, idDkSil = 20,\n   idFrm = 22;\nconst float pi = 3.1415927;\n\nfloat WheelDf (vec3 q, float dMin)\n{\n  float d;\n  d = max (PrRoundCylDf (q, wlRad - 0.05, 0.05, 0.15), 0.5 - length (q.xy));\n  DMINQ (idTyr);\n  d = min (PrCylDf (q, 0.5, 0.13), PrCylDf (q, 0.2, 0.17));\n  DMINQ (idHub);\n  return dMin;\n}\n\nfloat CarExDf (vec3 p, float dMin)\n{\n  vec3 q, qq;\n  vec2 s;\n  float d, r, h, dw, t;\n  q = p;\n  d = PrCylDf (vec3 (q.x, abs (q.y) - 0.07, q.z - 2.7).yzx, 0.04, 1.55);\n  DMIN (idAx);\n  d = PrCylDf (vec3 (abs (abs (q.x) - 1.11) - 0.19, q.y, q.z - 2.7).xzy, 0.06, 0.11);\n  DMIN (idAx);\n  d = PrCylDf (vec3 (q.xy, q.z + 2.7).yzx, 0.1, 1.55);\n  DMIN (idAx);\n  q = p;\n  q.xz = abs (q.xz) - wlBase.xz;\n  qq = q;\n  qq.xz = (p.z > 0.) ? Rot2D (qq.xz, - strRot * sign (p.x)) : qq.xz;\n  qq.yz = Rot2D (qq.yz, - ((p.x < 0.) ? wlRot.x : wlRot.y) * sign (p.z));\n  dMin = WheelDf (qq.zyx, dMin);\n  q.x -= -0.1;\n  r = 0.8;\n  r *= (1. + 0.5 * smoothstep (0., 0.3 * r, q.z) * smoothstep (r, -0.2 * r, q.y));\n  h = (p.z > 0.) ? 0.1 * (q.z + 0.4) : 0.;\n  dWarch = PrFlatCapsDf (vec3 (q.x + h, q.yz).yzx, r, 0.35 * (1. - 0.2 * q.z) + 1.1 * h);\n  d = max (max (abs (dWarch) - 0.02, -0.21 - q.y), min (0.9 - length (q.yz), q.x));\n  if (p.z > 0.) d = SmoothMax (d, - max (0.52 - length (vec2 (q.x + 0.15, 0.5 - q.z)),\n     0.4 - q.z), 0.02);\n  d *= 0.7;\n  DMINQ (idWarch);\n  q = p;\n  q.yz = Rot2D (q.yz - vec2 (0.7, -3.5), 0.68 * pi);\n  dw = PrCylDf (q, wlRad + 0.01, 0.15);\n  dMin = WheelDf (q, dMin);\n  q.z -= 0.18;\n  d = min (PrSphDf (q, 0.08), PrCylDf ((q - vec3 (0., 0.12, 0.04)).xzy, 0.03, 0.12));\n  DMIN (idDkSil);\n  q = p;\n  qq = q;\n  qq.z -= -0.5;\n  dInt = PrRoundBoxDf (vec3 (qq.x, qq.y - 0.8, qq.z), vec3 (vec2 (0.85, 1.2) -\n     vec2 (0.03, 0.05) * qq.zx * qq.zx, 0.8).xzy, 0.1);\n  qq.z -= -0.1;\n  h = 0.8 * (1. - smoothstep (0.4, 1.4, - qq.z / 3.5));\n  qq.y -= -0.2 + h;\n  r = 0.3 * (1. + 0.3 * (qq.z - 2.) * (qq.z - 2.) * step (2., qq.z));\n  d = PrRoundBoxDf (qq, vec3 (1.1 - ((qq.z > 0.) ? 0.035 : 0.005) * qq.z * qq.z - r,\n     h - r, 3.5), r);\n  d = SmoothMax (max (d, qq.z - 3.8 + 0.4 * qq.x * qq.x), - dInt, 0.05);\n  qq.y -= -0.8;\n  d = min (d, max (max (length (qq.xy) - 0.15, - qq.y), dInt));\n  d = 0.7 * SmoothMax (max (d, - dWarch), - dw, 0.05);\n  DMINQ (idBod);\n  q = p;\n  q.yz -= vec2 (-0.18, -0.2);\n  d = PrRoundBoxDf (q, vec3 (1.4, 0.01, 3.71), 0.02);\n  d = max (SmoothMin (d, max (PrCylDf (vec3 (q.x, q.y + 0.2, q.z - 2.9).yzx, 0.5, 1.4), 0.03 -\n     q.y), 0.03), - dWarch);\n  DMINQ (idBase);\n  q = p;\n  q -= vec3 (-0.8, 0.4, 1.4);\n  s = sin (-0.1 * pi + vec2 (0.5 * pi, 0.));\n  q.yz = Rot2Cs (q.yz, s);\n  s = Rot2Cs (vec2 (0., 0.15), s);\n  d = PrTorusBxDf (vec3 (q.x, q.y - s.x * sign (q.z), abs (q.z) - s.y), vec3 (0.1, 0.25,\n     0.2), 0.08);\n  DMINQ (idExF);\n  q = p;\n  q.yz = Rot2D (q.yz - vec2 (1.6, 0.8), 0.15 * pi);\n  q.z -= -0.05 * abs (q.x);\n  d = PrRoundBoxDf (q, vec3 (0.95, 0.4, 0.005), 0.015);\n  d = 0.9 * max (d, - PrRoundBox2Df (vec2 (abs (q.x), q.y) - vec2 (0.45, 0.1),\n     vec2 (0.4, 0.24), 0.02));\n  DMIN (idWscrn);\n  q.x = abs (q.x);\n  d = PrCylDf ((q - vec3 (0.3, -0.18, 0.03)).yzx, 0.02, 0.2);\n  DMIN (idLtSil);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.7, -0.25, -3.);\n  d = max (abs (PrCapsDf (q, 0.06, 1.4)) - 0.02, -1.4 - q.z);\n  DMINQ (idExR);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (1., 1.05, 0.3);\n  d = PrTorusBxDf (q.xzy, vec3 (0.08, 0.1, 0.03), 0.02);\n  DMIN (idShin);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (1.05, 1.4, 0.85);\n  d = max (PrSphDf (q, 0.1), q.z - 0.05);\n  DMINQ (idSLit);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (1.3, 1.2, 2.9);\n  d = max (max (PrSphDf (q, 0.1), q.z - 0.05), - dWarch);\n  DMINQ (idSLit);\n  q = p;\n  q.yz -= vec2 (0.6, 3.4);\n  d = max (PrCylDf (q.yzx, 0.02, 1.2), - dWarch);\n  DMIN (idShin);\n  q.y -= 0.14;\n  d = max (PrSphDf (q, 0.14), q.z - 0.04);\n  DMINQ (idCLit);\n  q.x = abs (q.x);\n  q.xy -= vec2 (0.55, 0.11);\n  d = SmoothMax (abs (PrSphDf (q, 0.24)) - 0.01, q.z - 0.08, 0.01);\n  DMINQ (idMLit);\n  q.xy -= vec2 (-0.3, -0.3);\n  t = q.z + 0.2;\n  d = PrCylAnDf (q, 0.03 * (1. + 10. * t * t), 0.01, 0.2);\n  q.z -= -0.18;\n  d = min (d, PrCylDf (q, 0.08, 0.015));\n  DMIN (idShin);\n  q = p;\n  q.x = abs (q.x);\n  q.xz -= vec2 (0.5, -4.37);\n  d = PrCylDf (q, 0.07, 0.03);\n  DMINQ (idRLit);\n  q = p;\n  q.yz -= vec2 (1.5, 2.95);\n  d = PrSphDf (q, 0.11);\n  if (d < 0.05) {\n    d = PrTorusDf (q, 0.016, 0.1);\n    q.xy = Rot2D (q.xy, - pi / 6.);\n    q.xy = Rot2D (q.xy, 2. * pi * floor (3. * atan (q.y, - q.x) / (2. * pi) + 0.5) / 3.);\n    q.x += 0.05;\n    d = min (d, PrCylDf (q.yzx, 0.016, 0.05));\n    DMIN (idShin);\n  } else dMin = min (dMin, d);\n  q = p;\n  pSign = sign (q.z);\n  q.z = abs (q.z + 0.41);\n  q.yz -= vec2 (((p.z > 0.) ? -0.25 : -0.1), 3.96);\n  d = PrRoundBoxDf (q, vec3 (0.3, 0.13, 0.01), 0.01);\n  DMINQ (idPlat);\n  return dMin;\n}\n\nfloat CarInDf (vec3 p, float dMin)\n{\n  vec3 q;\n  vec2 s;\n  float d, t;\n  q = p;\n  q.yz -= vec2 (0.3, -0.1);\n  d = PrRoundBoxDf (q, vec3 (0.85, 0.07, 0.3), 0.05);\n  q.yz = Rot2D (q.yz - vec2 (0.5, -0.4), 0.57 * pi);\n  d = min (d, PrRoundBoxDf (q, vec3 (0.85, 0.07, 0.5), 0.05));\n  d = SmoothMax (d, 0.03 - abs (q.x + 0.05), 0.05);\n  DMINQ (idSeat);\n  q = p;\n  q.yz -= vec2 (0.3, -1.15);\n  d = PrRoundBoxDf (q, vec3 (0.8, 0.07, 0.3), 0.05);\n  q.yz = Rot2D (q.yz - vec2 (0.5, -0.4), 0.57 * pi);\n  d = min (d, PrRoundBoxDf (q, vec3 (0.8, 0.07, 0.5), 0.05));\n  DMINQ (idSeat);\n  q = p;\n  t = 0.05 * q.x * q.x;\n  q.yz -= vec2 (1.1 - t, 0.8);\n  d = 0.7 * max (max (PrRoundBox2Df (q.yz, vec2 (0.25 * (1. - t), 0.12), 0.02),\n     - PrCylDf (vec3 (abs (q.x - 0.42) - 0.25, q.y, q.z + 0.12), 0.17, 0.03)), dInt);\n  DMINQ (idDash);\n  q = p;\n  q -= vec3 (0.42, 1.1, 0.35);\n  q.yz = Rot2D (q.yz, -0.15 * pi);\n  d = PrTorusDf (q, 0.02, 0.33);\n  DMIN (idLtSil);\n  d = PrCylDf (q, 0.1, 0.02);\n  DMINQ (idStWhl);\n  s = q.xy;\n  q.xy = Rot2D (q.xy, 0.25 * pi - 8. * strRot);\n  q.xy = (abs (q.x) < abs (q.y)) ? q.xy : q.yx;\n  q.y = abs (q.y) - 0.17;\n  d = PrCylDf (q.xzy, 0.015, 0.17);\n  q.xy = s;\n  q.z -= 0.5;\n  d = min (d, PrCylDf (q, 0.03, 0.5));\n  DMIN (idDkSil);\n  q = p;\n  q.yz = Rot2D (q.yz - vec2 (0.2, 0.45), 0.1 * pi * sign (spd));\n  d = PrCylDf (q.xzy, 0.025, 0.4);\n  DMIN (idDkSil);\n  q.y -= 0.4;\n  d = PrSphDf (q, 0.06);\n  DMIN (idLtSil);\n  q = p;\n  q -= vec3 (0.42, 0., 0.65);\n  q.x = (q.x > 0.) ? abs (q.x - 0.25) - 0.08 : q.x + 0.2;\n  q.yz = Rot2D (q.yz, 0.1 * pi);\n  d = PrRoundBoxDf (q, vec3 (0.03, 0.02, 0.1), 0.02);\n  DMIN (idDkSil);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin, d;\n  p /= szFac;\n  p.xz = Rot2D (p.xz - carPos.xz, carRot);\n  p.yz -= vec2 (carPos.y + wlRad + 0.1, wlBase.z);\n  d = PrRoundBoxDf (p - vec3 (0., 0.6, 0.), vec3 (2., 1.4, 4.5), 0.01);\n  if (d < 0.1) {\n    dMin = CarExDf (p, dstFar);\n    if (dInt < 0.1) dMin = CarInDf (p, dMin);\n    else dMin = min (dMin, dInt);\n  } else dMin = d;\n  return szFac * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat TrObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  p /= szFac;\n  p.xz = Rot2D (p.xz - carPos.xz, carRot);\n  p.yz -= vec2 (carPos.y + wlRad + 0.1, wlBase.z);\n  q = p;\n  q.yz = Rot2D (q.yz - vec2 (1.6, 0.8), 0.15 * pi);\n  q.z -= -0.05 * abs (q.x);\n  d = 0.9 * PrBoxDf (q, vec3 (0.95, 0.4, 0.01));\n  DMINQTR (idWscrn);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.55, 0.83, 3.42);\n  d = PrCylDf (q, 0.24, 0.02);\n  DMINQTR (idMLit);\n  return szFac * dMin;\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    p = ro + dHit * rd;\n    d = TrObjDf (p);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 TrObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = TrObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat PlateCol (vec2 s)\n{\n  float d;\n  if (s.x < -0.55) {\n    s.x += 1.3;\n    d = min (PrBox2Df (s, vec2 (0.06, 0.6)), max (abs (PrCaps2Df (s.yx, 0.55, 0.1)) -\n       0.06, - s.x));\n  } else if (s.x < 0.65) {\n    d = min (PrBox2Df (s, vec2 (0.06, 0.6)), max (abs (PrCaps2Df ((s - vec2 (0.07, 0.3)).yx,\n       0.25, 0.2)) - 0.06, - s.x));\n    s -= vec2 (0.3, -0.3);\n    d = min (d, max (PrBox2Df (Rot2D (s, - pi / 5.), vec2 (0.06, 0.4)), -0.3 - s.y));\n  } else {\n    d = PrBox2Df (vec2 (abs (s.x - 1.4) - 0.2, s.y), vec2 (0.06, 0.6));\n  }\n  return d;\n}\n\nfloat MSymCol (vec2 s)\n{\n  return min (abs (length (s) - 0.1) - 0.02, PrBox2Df (Rot2D (s, 2. * pi *\n     floor (3. * atan (s.y, - s.x) / (2. * pi) + 0.5) / 3.) + vec2 (0.05, 0.),\n     vec2 (0.05, 0.02)));\n}\n\nvec4 CarCol (out float refFac)\n{\n  vec4 col4, col4B, col4Ls, col4Ds, col4Uh, col4Ly, col4HiRf;\n  vec2 s;\n  float t;\n  bool loRf;\n  col4B = vec4 (0.8, 0.6, 0.1, 0.2);\n  col4Ls = vec4 (0.9, 0.9, 0.9, 0.2);\n  col4Ds = vec4 (0.4, 0.4, 0.4, 0.2);\n  col4Uh = vec4 (0.7, 0.7, 0.5, 0.05);\n  col4Ly = vec4 (0.9, 0.9, 0.8, 0.2);\n  col4HiRf = vec4 (0.95, 0.95, 1., 0.);\n  loRf = false;\n  if (idObj <= idDash) {\n    if (idObj == idBod) {\n      if (dInt < 0.03) {\n        col4 = 0.7 * col4Uh;\n        loRf = false;\n      } else {\n        col4 = col4B;\n        loRf = true;\n      }\n      if (qHit.z > 2.905) {\n        col4 = col4HiRf;\n        if (PrRoundBox2Df (vec2 (abs (qHit.x) - 0.28, qHit.y - 0.6), vec2 (0.05, 0.4), 0.15) < 0.) {\n          col4 *= 0.7;\n        }\n        if (length (qHit.xy + vec2 (0., 0.07)) < 0.04) col4 *= 0.3;\n      } else if (abs (qHit.z + 0.1 * qHit.y - 2.) < 0.8 && abs (abs (qHit.y - 0.7) - 0.15) < 0.07) {\n        col4 = col4Ds;\n        loRf = false;\n      } else if (qHit.y > 0.) {\n        t = (0.4 + 0.6 * smoothstep (0.005, 0.015, abs (PrRoundBox2Df (vec2 (qHit.y - 1.,\n           qHit.z + 0.07 * qHit.y + 0.35), vec2 (0.7, 0.9 - 0.07 * qHit.y), 0.2)))) *\n           (0.7 + 0.3 * smoothstep (0.005, 0.015, abs (PrRoundBox2Df (vec2 (qHit.y - 1.1,\n           qHit.z - 1.95), vec2 (0.85, 0.92), 0.02))));\n        if (abs (qHit.z - 1.95) < 0.93) t *= 0.7 + 0.3 * smoothstep (0.005, 0.015, abs (qHit.x));\n        col4 *= t;\n        if (t < 1.) loRf = false;\n        if (abs (qHit.x) > 0.95) {\n          t = PrRoundBox2Df (vec2 (abs (qHit.y - 0.7) - 0.25, qHit.z + 1.45), vec2 (0.1, 0.01), 0.01);\n          col4 = mix (col4Ds, col4, smoothstep (0., 0.01, t));\n          if (t < 0.) loRf = false;\n        }\n      }\n      if (qHit.z < -1.8) col4 = mix (col4HiRf, col4, smoothstep (0., 0.02,\n         PrRoundBox2Df (vec2 (abs (qHit.x) - 0.8, qHit.z + 2.5), vec2 (0.01, 0.6), 0.02)));\n    } else if (idObj == idTyr) {\n      t = length (qHit.xy);\n      if (t < 0.53) {\n        col4 = col4Ls * (0.5 + 0.5 * step (0., qHit.z));\n      } else {\n        col4 = vec4 (0.15, 0.15, 0.15, 0.);\n        if (t > 0.75) col4 *= 0.5 + 0.5 * abs (step (0., cos (32. * pi * qHit.z)) -\n           step (0.5, mod (64. * atan (qHit.y, - qHit.x) / (2. * pi) + 0.5, 1.)));\n      }\n    } else if (idObj == idHub) {\n      t = length (qHit.xy);\n      col4 = mix (col4Ds, col4HiRf, smoothstep (0., 0.002, abs (t - 0.17) - 0.01));\n      if (qHit.z > 0.) {\n        if (t < 0.15) col4 = mix (col4Ds, col4, smoothstep (0., 0.005, MSymCol (qHit.xy)));\n      } else col4 *= 0.3;\n      if (abs (t - 0.36) < 0.15) {\n        t = 1.;\n        for (float f = -1.; f <= 1.; f += 2.) {\n          s = Rot2D (qHit.xy, f * pi / 24.);\n          t = min (t, smoothstep (0.008, 0.01, abs (abs (dot (s, sin (2. * pi *\n             floor (12. * atan (s.y, - s.x) / (2. * pi) + 0.5) / 12. +\n             vec2 (0., 0.5 * pi)))) - 0.04)));\n        }\n        col4 = mix (col4Ls, 0.5 * col4B, t) * (0.5 + 0.5 * step (0., qHit.z));\n      }\n    } else if (idObj == idDash) {\n      col4 = mix (col4B, 0.8 * col4Uh, smoothstep (0.015, 0.02, abs (abs (qHit.y) - 0.2)));\n      col4 = mix (col4B, col4, smoothstep (0.015, 0.02, abs (PrRoundBox2Df (vec2 (qHit.x + 0.4,\n         qHit.y), vec2 (0.2, 0.1), 0.03))));\n      if (qHit.y < 0.22) {\n        s = vec2 (abs (qHit.x - 0.42) - 0.25, qHit.y);\n        t = length (s);\n        if (t < 0.15) {\n          col4 = vec4 (1., 1., 1., 0.1);\n          if (t > 0.13) col4 *= 0.2;\n          else {\n            if (t > 0.08) col4 *= 0.2 + 0.8 * smoothstep (0.2, 0.25,\n               mod (8. * atan (s.y, - s.x) / (2. * pi), 1.));\n            if (s.y > -0.02) col4 *= 0.2 + 0.8 * smoothstep (0.012, 0.015, abs (s.x));\n          }\n        }\n      }\n    }\n  } else if (idObj <= idPlat) {\n    if (idObj == idWarch) {\n      col4 = col4B * (0.5 + 0.5 * step (0., dWarch));\n      loRf = (dWarch > 0. && (qHit.x > -0.3 || qHit.y > 0.5));\n    } else if (idObj == idBase) {\n      col4 = col4B * (0.9 + 0.1 * step (0., qHit.y) * (cos (64. * qHit.x) - 1.) *\n         step (abs (qHit.z), 2.));\n    } else if (idObj == idExR) {\n      col4 = (qHit.z < - 1.2) ? col4HiRf : col4Ds;\n      if (qHit.z < 1.3) col4 *= 0.1 + 0.9 * step (0.07, length (qHit.xy));\n    } else if (idObj == idExF) {\n      col4 = mix (col4Ds, col4HiRf, step (-0.4, sin (48. * atan (qHit.y, - qHit.x))));\n    } else if (idObj == idWscrn) {\n      col4 = col4HiRf;\n    } else if (idObj == idSeat) {\n      col4 = col4Uh * (0.95 + 0.05 * cos (64. * qHit.x));\n    } else if (idObj == idStWhl) {\n      col4 = mix (col4Ds, col4Ls, smoothstep (0., 0.004, MSymCol (Rot2D (1.5 * qHit.xy,\n         - pi / 6. - 8. * strRot))));\n    } else if (idObj == idPlat) {\n      col4 = mix (0.5 * col4B, vec4 (1., 1., 1., 0.1), step (0., qHit.z) * \n         (1. - smoothstep (0.02, 0.03, PlateCol (7. * qHit.xy * vec2 (- pSign, 1.)))));\n    }\n  } else {\n    if (idObj == idMLit) {\n      col4 = col4HiRf;\n      if (abs (qHit.z - 0.05) < 0.02) col4 *= 0.8;;\n    } else if (idObj == idCLit) {\n      col4 = col4HiRf;\n      t = length (qHit.xy);\n      if (qHit.z > 0. && t < 0.12) {\n        col4 = col4Ly * (0.9 + 0.1 * cos (256. * t));\n        loRf = true;\n      }\n    } else if (idObj == idSLit) {\n      col4 = (qHit.z > 0. && length (qHit.xy) < 0.08) ? col4Ly : col4HiRf;\n    } else if (idObj == idRLit) {\n      col4 = (qHit.z < 0. && length (qHit.xy) < 0.05) ? vec4 (1., 0., 0., 0.2) : col4HiRf;\n    } else if (idObj == idAx) {\n      col4 = 0.7 * col4Ds;\n    } else if (idObj == idShin) {\n      col4 = col4HiRf;\n    } else if (idObj == idLtSil) {\n      col4 = col4Ls;\n    } else if (idObj == idDkSil) {\n      col4 = col4Ds;\n    }\n  }\n  refFac = 0.;\n  if (col4 == col4HiRf) refFac = 0.8;\n  else if (loRf) refFac = 0.15;\n  return col4;\n}\n\nfloat ExObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p;\n  d = max (PrRoundBoxDf (q, vec3 (pgSize + vec3 (1., 0.1, 1.)), 0.03),\n     - PrBox2Df (q.xz, pgSize.xz));\n  DMINQ (0);\n  return dMin;\n}\n\nfloat ExObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 60; j ++) {\n    d = ExObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ExObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ExObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec2 ExBlkHit (vec3 ro, vec3 rd)\n{\n  vec3 v, tm, tp, u, fcBlk;\n  vec2 qBlk;\n  float dn, df, bSize;\n  bSize = dstFar;\n  if (rd.x == 0.) rd.x = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    fcBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    u = (v + dn) * rd;\n    qBlk = vec2 (dot (u.zxy, fcBlk), dot (u.yzx, fcBlk)) / bSize;\n  } else qBlk = vec2 (0.);\n  return qBlk;\n}\n\nvec4 BlkHit (vec3 ro, vec3 rd, vec3 bSize)\n{\n  vec3 v, tm, tp, fcBlk;\n  vec2 qBlk;\n  float dMin, dn, df;\n  dMin = dstFar;\n  if (rd.x == 0.) rd.x = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    fcBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  }\n  return vec4 (dMin, fcBlk);\n}\n\nvec3 SkShowScene (vec3 ro, vec3 rd, vec2 uv)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, refFac;\n  carPos = vec3 (0.);\n  carRot = 0.;\n  strRot = 0.;\n  wlRot = vec2 (0.);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = CarCol (refFac);\n    col = vec3 (1., 0.98, 0.96) * pow (Maxv3 (col4.rgb), 0.7);\n    col *= (0.85 + 0.15 * Noisefv2 (Rot2D (uv, -0.2 * pi) * vec2 (16., 256.))) *\n       (0.5 + 0.5 * max (dot (vn, ltDirS), 0.));\n  } else {\n    col = vec3 (1.);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvec3 SkMain (vec2 fCoord, float vp)\n{\n  mat3 vuMat;\n  vec3 ro, rd, col, carPosT;\n  vec2 uv, wlRotT;\n  float el, az, szFacT, carRotT, strRotT;\n  szFacT = szFac;\n  carPosT = carPos;\n  carRotT = carRot;\n  wlRotT = wlRot;\n  strRotT = strRot;\n  uv = fCoord / 5.;\n  if (vp == 0.) {\n    szFac = 1.2;\n    uv -= vec2 (0., -0.9);\n    el = -0.2 * pi;\n    az = pi;\n  } else if (vp == 1.) {\n    szFac = 1.3;\n    uv -= vec2 (0.6, -1.5);\n    el = -0.13 * pi;\n    az = 0.5 * pi;\n  } else if (vp == 2.) {\n    szFac = 1.3;\n    uv -= vec2 (-0.6, -1.2);\n    el = -0.5 * pi;\n    az = -0.5 * pi;\n  } else if (vp == 3.) {\n    szFac = 1.6;\n    uv -= vec2 (0., -1.8);\n    el = -0.2 * pi;\n    az = 0.;\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., -5., -20.);\n  rd = vuMat * normalize (vec3 (uv, 4.2));\n  ltDirS = vuMat * normalize (vec3 (0.5, 1., -0.7));\n  col = SkShowScene (ro, rd, uv);\n  szFac = szFacT;\n  carPos = carPosT;\n  carRot = carRotT;\n  wlRot = wlRotT;\n  strRot = strRotT;\n  return clamp (col, 0., 1.);\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff;\n  rd.y = abs (rd.y);\n  q = 0.01 * (ro.xz + 2. * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n  ff = Fbm2 (q);\n  f = smoothstep (0.2, 0.8, ff);\n  fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * ltDir.xz)) - f;\n  clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n     smoothstep (0., 0.05, abs (fd)));\n  skCol = vec3 (0.3, 0.4, 0.8);\n  col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, db4;\n  vec3 col, vn, qHitEx, roo;\n  vec2 qBlk, q, sq;\n  float dstObj, dstTrObj, dstExObj, refFac;\n  bool isBg;\n  szFac = 1.5;\n  roo = ro;\n  dstTrObj = TrObjRay (ro, rd);\n  pgSize = vec3 (15., 0.1, 10.);\n  isBg = false;\n  dstExObj = ExObjRay (ro, rd);\n  qHitEx = qHit;\n  isSk = false;\n  dstObj = ObjRay (ro, rd);\n  db4 = BlkHit (ro, rd, pgSize);\n  if (min (dstObj, dstExObj) < min (db4.x, dstFar)) {\n    if (dstObj < dstExObj) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      col4 = CarCol (refFac);\n    } else {\n      ro += dstExObj * rd;\n      vn = ExObjNf (ro);\n      col4 = vec4 (0.4, 0.5, 0.1, 0.1) * (0.8 + 0.2 * Fbm2 (16. * qHitEx.xz));\n    }\n  } else if (db4.x < dstFar) {\n    ro += db4.x * rd;\n    vn = db4.yzw;\n    q = ro.xz;\n    if (vn.y > 0.5 && PrBox2Df (q, pgSize.xz - 0.96) < 0.) {\n      sq = sign (q);\n      isSk = true;\n      col = SkMain (q - 0.5 * sq * pgSize.xz,  sq.y + 1. + 0.5 * (sq.x + 1.));\n      if (Minv3 (col) > 0.95) col = mix (vec3 (0.7, 0.8, 0.9), vec3 (1.),\n         Minv2 (smoothstep (0.02, 0.05, abs (mod (q + 0.5, 1.) - 0.5))));\n    } else {\n      col = vec3 (1.) * (0.8 + 0.2 * step (0.5, vn.y));\n    }\n    col *= 0.7 + 0.3 * smoothstep (0., 0.5, PrRoundBox2Df (Rot2D (q - szFac * carPos.xz,\n       carRot) - vec2 (0., szFac * wlBase.z - 0.4), szFac * wlBase.xz + vec2 (-0.5, 1.), 0.5));\n  } else {\n    isBg = true;\n  }\n  if (! isBg) {\n    if (min (dstObj, dstExObj) < min (db4.x, dstFar)) {\n      col = col4.rgb * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n         col4.a * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n      if (refFac > 0.) col = mix (col, 0.9 * SkyBgCol (ro, reflect (rd, vn)), refFac);\n    } else {\n      col *= 0.3 + 0.7 * max (dot (vn, ltDir), 0.);\n    }\n  } else {\n    qBlk = mod (8. * ExBlkHit (ro, rd), 1.);\n    col = vec3 (0.4, 0.5, 0.4) * (0.05 + 0.245 * (rd.y + 1.) * (rd.y + 1.)) +\n       vec3 (0.2) * (0.9 + 0.1 * SmoothBump (0.25, 0.75, 0.1, qBlk.x) *\n       SmoothBump (0.25, 0.75, 0.1, qBlk.y));\n  }\n\n  if (dstTrObj < min (dstObj, dstFar)) {\n    ro = roo + dstTrObj * rd;\n    vn = TrObjNf (ro);\n    if (idTrObj == idWscrn) col *= vec3 (1., 1., 0.8);\n    else if (idTrObj == idMLit) col *= vec3 (1., 1., 0.8) * (0.9 + 0.1 * cos (128. * qTrHit.x)); \n    col = mix (col, SkyBgCol (ro, reflect (rd, vn)), 0.1 + 0.8 * pow (1. - abs (dot (vn, rd)), 5.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, stDat;\n  vec3 ro, rd;\n  vec2 canvas, uv;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  stDat = Loadv4 (0);\n  carPos = stDat.xyz;\n  carRot = stDat.w;\n  stDat = Loadv4 (1);\n  wlBase = stDat.xyz;\n  wlRad = wlBase.y;\n  spd = stDat.w;\n  stDat = Loadv4 (2);\n  strRot = stDat.y;\n  wlRot = stDat.zw;\n  az = 0.;\n  el = -0.3 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.8 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.5 * pi, -0.1 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., -1., -40.);\n  rd = vuMat * normalize (vec3 (uv, 4.));\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrCaps2Df (vec2 p, float r, float h)\n{\n  return length (p - vec2 (0., clamp (p.y, - h, h))) - r;\n}\n\nfloat PrFlatCapsDf (vec3 p, float r, float h)\n{\n  return length (vec2 (max (length (p.xy) - r, 0.), p.z)) - h;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat PrTorusBxDf (vec3 p, vec3 b, float ri)\n{\n  return length (vec2 (length (max (abs (p.xy) - b.xy, 0.)) - b.z, p.z)) - ri;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Mercedes Sketches\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst float pi = 3.1415927;\nconst float txRow = 128.;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 carPos, wlBase;\n  vec2 iFrag, wlRot, w;\n  float carRot, cRotN, strRot, wlRad, rTurn, spd, tc, nStep;\n  int pxId;\n  bool init;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (pxId >= 3) discard;\n  init = (iFrame <= 5);\n  if (init) {\n    carPos = vec3 (8.5, 0., -2.5);\n    carRot = -0.4 * pi;\n    strRot = 0.;\n    wlBase = vec3 (1.45, 0.8, 2.7);\n    wlRot = vec2 (0.);\n    nStep = 0.;\n  } else {\n    stDat = Loadv4 (0);\n    carPos = stDat.xyz;\n    carRot = stDat.w;\n    stDat = Loadv4 (1);\n    wlBase = stDat.xyz;\n    stDat = Loadv4 (2);\n    nStep = stDat.x;\n    strRot = stDat.y;\n    wlRot = stDat.zw;\n  }\n  wlRad = wlBase.y;\n  ++ nStep;\n  tc = mod (0.002 * nStep, 4.);\n  strRot = 0.15 * pi * SmoothBump (0.3, 0.7, 0.15, mod (tc, 1.)) * sign (mod (tc, 2.) - 1.) *\n     sign (tc - 2.);\n  tc = mod (0.003 * nStep, 2.);\n  spd = -0.03 * SmoothBump (0.2, 0.8, 0.15, mod (tc, 1.)) * sign (tc - 1.);\n  w = vec2 (1.);\n  if (abs (strRot) > 1e-4) {\n    cRotN = carRot - strRot * spd / pi;\n    rTurn = wlBase.z / asin (0.5 * strRot);\n    carPos.xz += rTurn * (sin (carRot - vec2 (0.5 * pi, 0.)) - sin (cRotN - vec2 (0.5 * pi, 0.)));\n    carRot = cRotN;\n    w += vec2 (-1., 1.) * wlBase.x / rTurn;\n  } else {\n    carPos.xz += spd * sin (carRot + vec2 (0., 0.5 * pi));\n  }\n  wlRot += w * spd / wlRad;\n  if      (pxId == 0) stDat = vec4 (carPos, carRot);\n  else if (pxId == 1) stDat = vec4 (wlBase, spd);\n  else if (pxId == 2) stDat = vec4 (nStep, strRot, wlRot);\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl33zM.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1934, 1934, 1970, 1970, 2169], [2171, 2171, 2207, 2207, 6681], [6683, 6683, 6719, 6719, 8333], [8335, 8335, 8357, 8357, 8727], [8729, 8729, 8762, 8762, 8944], [8946, 8946, 8967, 8967, 9222], [9224, 9224, 9248, 9248, 9695], [9697, 9697, 9732, 9732, 9937], [9939, 9939, 9962, 9962, 10219], [10221, 10221, 10246, 10246, 10772], [10774, 10774, 10798, 10798, 10980], [10982, 10982, 11014, 11014, 16738], [16740, 16740, 16764, 16764, 16954], [16956, 16956, 16991, 16991, 17175], [17177, 17177, 17200, 17200, 17457], [17459, 17459, 17493, 17493, 17937], [17939, 17939, 17983, 17983, 18339], [18341, 18341, 18387, 18387, 18899], [18901, 18901, 18938, 18938, 19904], [19906, 19906, 19940, 19940, 20440], [20442, 20442, 20477, 20477, 22858], [22860, 22860, 22913, 22913, 23745], [23747, 23747, 23779, 23779, 23879], [23881, 23881, 23927, 23927, 23974], [23976, 23976, 24009, 24009, 24098], [24100, 24100, 24147, 24147, 24194], [24196, 24196, 24229, 24229, 24256], [24258, 24258, 24300, 24300, 24351], [24353, 24353, 24406, 24406, 24467], [24469, 24469, 24526, 24526, 24602], [24604, 24604, 24647, 24647, 24711], [24713, 24713, 24757, 24757, 24817], [24819, 24819, 24866, 24866, 24931], [24933, 24933, 24979, 24979, 25036], [25038, 25038, 25084, 25084, 25165], [25167, 25167, 25189, 25189, 25227], [25229, 25229, 25251, 25251, 25289], [25291, 25291, 25313, 25313, 25340], [25342, 25342, 25387, 25387, 25479], [25481, 25481, 25526, 25526, 25564], [25566, 25566, 25623, 25623, 25706], [25708, 25708, 25744, 25744, 25950], [25952, 25952, 25982, 25982, 26095], [26097, 26097, 26128, 26128, 26192], [26226, 26226, 26250, 26250, 26362], [26364, 26364, 26389, 26389, 26575], [26577, 26577, 26598, 26598, 26753], [26755, 26755, 26784, 26784, 26996], [26998, 26998, 27037, 27037, 27222], [27316, 27316, 27341, 27341, 27464]], "test": "untested"}
{"id": "sdGSWd", "name": "Texture and a loop", "author": "Plento", "description": "Its amazing to me how many cool patterns you can get just messing with coordinates in a loop. Use the MOUSE to get all new patterns! Its also really hard to pick good initial values.", "tags": ["2d", "fractal", "mouse", "pattern"], "likes": 10, "viewed": 299, "published": 3, "date": "1635837765", "time_retrieved": "2024-07-30T18:51:09.780901", "image_code": "// Cole Peterson\n\n// Use the mouse to get new patterns! Lots of variation.\n\n#define R iResolution.xy\n#define m ((iMouse.xy - .5*R.xy) / R.y)\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 nuv = 1.5*vec2(u.xy - 0.5*R.xy)/R.y;\n    nuv = (nuv + vec2(-nuv.y,nuv.x) ) / 1.4;\n    nuv.y += iTime*.1;\n    \n    vec2 id = floor(nuv*1.);\n    nuv = fract(nuv*1.)-.5;\n    \n    if(int(id.x) % 2 == 0) nuv.x *= -1.;\n    if(int(id.y) % 2 == 0) nuv.y *= -1.;\n        \n    float n = 16., w = .31, q = -.605;\n    float inc = 2.*3.1415 / n;\n    \n    if(iMouse.z > 0.){ \n        q += m.x * .3 + m.y*.4;\n        w += m.y*.7;\n    }\n    \n    for(float i = 0.; i < n; i++){\n        vec2 of = .08*vec2(cos(i*.6), sin(i*.6));\n        nuv += of;\n        nuv *= rot(i * inc - 18.*.006 + w);\n        nuv -= q;\n        nuv *= 1.001;\n        nuv = abs(nuv - of);\n    }\n    \n    vec3 col = texture(iChannel0, nuv).xyz;\n    col = pow(col*1.33, vec3(2.9));\n    f = vec4(col, 1.);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdGSWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[142, 142, 161, 161, 213], [215, 215, 255, 255, 1023]], "test": "untested"}
{"id": "Nlf3z8", "name": "Kusama", "author": "kstyler", "description": "Shader inspired by Kusama's infinity rooms", "tags": ["3d", "infinity", "room", "kusama"], "likes": 1, "viewed": 248, "published": 3, "date": "1635823289", "time_retrieved": "2024-07-30T18:51:10.644592", "image_code": "int matID = 0;\nint scene = 1;\n\nmat2 rotate(float a){\n\treturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}\n\nfloat sdfLP(vec3 p, float norm, float size){\n    float px = pow(abs(p.x),norm);\n    float py = pow(abs(p.y),norm);\n    float pz = pow(abs(p.z),norm);\n    return pow(px+py+pz,1./norm)-size;\n}\n\nfloat sdfBox( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat map(vec3 p,int id){\n    float subject = 999.;\n    if(scene ==0){\n        vec3 q = p;\n        q.x+=sin(q.y+iTime)*.5;\n        vec3 center = floor(q*.2)+.5;\n        subject = sdfLP(q-center,(sin(iTime)*2.)+2.9,.4);\n    }else if(scene ==1){\n        vec3 q = p;\n        subject = sdfLP(q,(sin(iTime)*2.)+2.9,.9);\n    }else if(scene ==2){\n        vec3 q = p;\n        q.y-=.5;\n        q.x+=sin(q.y*10.+iTime*1.)*.2;\n        vec3 center = vec3(floor(q.xz)+.5,0.);\n        subject = sdfLP(q-center.xzy,1.,.3);\n    } \n    \n    float plane = p.y+1.5;\n    float cil = 1.5-p.y;\n    float box = -sdfBox(p+vec3(0.,0.,0.),vec3(4.,4.,4.));\n    float best = min(cil,min(box,min(subject,plane)));\n    if(id != 0){\n        if(best == subject){matID = 2;}\n        if(best == plane){matID=3;}\n      \n        if(best == box){matID=4;}\n        if(best ==cil)matID=5;\n    }\n    return best;\n}\nvec3 normal(vec3 p){\n    vec2 e= vec2(0,0.001);\n\treturn normalize(vec3(map(p+e.yxx,0)-map(p-e.yxx,0),\n                          map(p+e.xyx,0)-map(p-e.xyx,0),\n                          map(p+e.xxy,0)-map(p-e.xxy,0)));\n}\nvec3 march(vec3 ro, vec3 rd){\n    float total = 0.;\n    float dist = 0.;\n    for(int i = 0; i<500; i++){\n        dist = map(ro+rd*total,1)*.5;\n        total+=dist;\n        if(dist < 0.001 || total>500.){\n        \tbreak;\n        }\n    }\n    if(dist>0.01){\n    \tmatID = 1;\n    }\n   \n    return (ro+rd*total);\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n   \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\tvec3 ro = vec3(0.);\n    vec3 rd = normalize(vec3(uv,1.));\n    scene = int(mod(iTime*.1,3.));\n    if(scene == 0){\n        ro = vec3(0,0.3,-3.5);\n        ro.zy*=rotate(.4);\n        rd.zy*=rotate(.4);\n        ro.xz*= rotate(iTime*.1);\n        rd.xz*= rotate(iTime*.1);\n    }else if(scene ==1){\n        ro = vec3(0,0.8,-2.5);\n        rd.zy*=rotate(-.3);\n        ro.xz*= rotate(iTime*.1);\n        rd.xz*= rotate(iTime*.1);\n    \n    }else if(scene ==2){\n        ro = vec3(0,.3,-0.3);\n        rd.zy*=rotate(.1);\n        rd.zy*=rotate(.1);\n        ro.xz*= rotate(iTime*.1);\n        rd.xz*= rotate(iTime*.1);\n    \n    }\n    \n    vec3 accum = vec3(1);\n    for(int i = 0; i <9; i++){\n        vec3 col =(march(ro,rd));\n        vec3 n = normal(col);\n        if(matID ==1){\n    \t\taccum *= vec3(1);\n   \t\t}\t\n        if(matID ==2){\n            accum *= vec3(.9);\n        \tro = col*2.;\n            rd=normalize(reflect(rd,n));\n        }\n        if(matID ==3){\n            accum *= vec3(0.8);\n        }\n        if(matID ==4){\n            accum *= vec3(0.99,.996,0.99);\n            float fresnel = pow(1.-dot(- rd,n),0.03);\n            accum*=fresnel;  \n            ro = col*.999;\n            rd=normalize(reflect(rd,n));\n        }\n        if(matID ==5){\n            accum *= vec3(.999);\n        }\n    }\n    fragColor = vec4(accum,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlf3z8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 52, 52, 98], [100, 100, 144, 144, 290], [292, 292, 323, 323, 410], [412, 412, 437, 437, 1286], [1287, 1287, 1307, 1307, 1506], [1507, 1507, 1536, 1536, 1820], [1821, 1821, 1877, 1877, 3261]], "test": "untested"}
{"id": "stdGz4", "name": "Fully Animated Subdivision", "author": "Tater", "description": "By removing any reference to the current pixel position in the seeding it's possible to animation all iterations of the suddivision. \n\n(Mouseable)\n\n3D coming soon", "tags": ["2d", "mouse", "subdivision", "boxes"], "likes": 74, "viewed": 1562, "published": 3, "date": "1635808115", "time_retrieved": "2024-07-30T18:51:11.424507", "image_code": "// Fork of \"Rectagular Subdivisor\" by Tater. https://shadertoy.com/view/7sV3WD\n// 2021-09-21 21:08:49\n\n#define pi 3.1415926535\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\nfloat h11 (float a) {\n    return fract(sin((a)*12.9898)*43758.5453123);\n}\n//iq palette\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos(2.*pi*(c*t+d));\n}\nfloat box(vec2 p, vec2 b){\n    vec2 d = abs(p)-b;\n    return max(d.x,d.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord-0.5*R.xy)/R.y;\n    vec3 col = vec3(0);\n    float t = mod(iTime,6000.)*0.8;\n    float px = 1./iResolution.y;\n    \n    vec2 dMin = vec2(-0.5);\n    vec2 dMax = vec2(0.5);\n    dMin.x*=R.x/R.y;\n    dMax.x*=R.x/R.y;\n    vec2 dim = dMax - dMin;\n    float id = 0.;\n    float ITERS = 7.;\n    float seed = 0.4;\n\n \n    vec2 M = iMouse.xy/iResolution.xy;\n    \n    float MIN_SIZE = 0.01;\n    //float ITERS = its;\n    float BORDER_SIZE = 0.003;\n    float MIN_ITERS = 1.;\n\n    \n    //BIG THANKS to @0b5vr for letting me use his cleaner subdiv implementation\n    //https://www.shadertoy.com/view/NsKGDy\n    vec2 diff2 = vec2(1);\n    for(float i = 0.;i<ITERS;i++){\n    \n        \n        // divide the box into quads\n        //Big thanks to @SnoopethDuckDuck for telling me about tanh(sin(x)*a)\n        vec2 divHash=tanh(vec2(sin(t*pi/3.+id+i*t*0.05),cos(t*pi/3.+h11(id)*100.+i*t*0.05))*7.)*0.35+0.5;\n        \n        //Less agressive animation\n        //divHash=vec2(sin(t*pi/3.+id),cos(t*pi/3.+h11(id)*100.))*0.5+0.5;\n        \n        \n        \n        if(iMouse.z>0.5){\n        divHash = mix(divHash,M,0.3);\n        }\n        \n\n        vec2 divide = divHash * dim + dMin;\n        \n        //Clamp division line\n        divide = clamp(divide, dMin + MIN_SIZE+0.01, dMax - MIN_SIZE-0.01);\n        \n        \n        //Find the minimum dimension size\n        vec2 minAxis = min(abs(dMin - divide), abs(dMax - divide));\n        float minSize = min( minAxis.x, minAxis.y);\n        \n        //if minimum dimension is too small break out\n        bool smallEnough = minSize < MIN_SIZE;\n        if (smallEnough && i + 1. > MIN_ITERS) { break; }\n        \n        // update the box domain\n        dMax = mix( dMax, divide, step( uv, divide ));\n        dMin = mix( divide, dMin, step( uv, divide ));\n\n        //Deterministic seeding for future divisions \n        diff2 =step( uv, divide)-\n        vec2(h11(diff2.x)*10.,h11(diff2.y)*10.);\n        \n        // id will be used for coloring \n        id = length(diff2)*100.0;\n\n        // recalculate the dimension\n        dim = dMax - dMin;\n    }\n    \n    //Calculate 2d box sdf\n    vec2 center = (dMin + dMax)/2.0;\n    float a = box(uv-center,dim*0.5);\n    //a = length(uv-center)-min(dim.x,dim.y)*0.5;\n    \n    //Color box\n    id = h11(id)*1000.0;\n    vec3 e = vec3(0.5);\n    vec3 al = pal(fract(id)*0.75+0.8,e*1.3,e,e*2.0,vec3(0,0.33,0.66));\n    col = clamp(al,0.,1.);\n    col-=smoothstep(-px,px,a+BORDER_SIZE);\n    //col = vec3(-a*10.0);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdGz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 127, 147, 147, 218], [219, 219, 240, 240, 292], [293, 306, 373, 373, 412], [413, 413, 439, 439, 489], [490, 490, 547, 547, 3094]], "test": "untested"}
{"id": "ftt3R4", "name": "Trippy effect", "author": "mvaios", "description": "Trippy effect by mostly playing around with some numbers.", "tags": ["colors", "zoom", "effect", "trippy"], "likes": 2, "viewed": 335, "published": 3, "date": "1635805102", "time_retrieved": "2024-07-30T18:51:12.495643", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n  \n    uv *= 3.0;\n    vec2 gv = fract(uv) - 0.5;\n    vec3 col = vec3(gv.xy, 1.);\n\n    float m = 0.;\n    float t = iTime/2.;\n\n    \n    float dist = length(uv * 4.);\n    for(int x = -2; x<=2;x++) {\n        for(int y = -2; y<=2;y++) {\n            vec2 offset = vec2(x, y); \n            float d = length(gv-offset*0.7)*1.75;\n            float tNorm = sin(dist-t) * .5 + 0.5;\n            float r = mix(0.35, 1.8, tNorm);\n\n            m += smoothstep(r*1.0001, r, d);\n        }\n    }\n    \n    col.x = mod(m/1., 1.1);\n    col.y = mod(m/1.1, 1.3);\n    col.z = mod(m/1.3, 1.4);\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftt3R4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 725]], "test": "untested"}
{"id": "7ttGR4", "name": "Turbulent wind", "author": "jarble", "description": "This is not a real fluid simulation, but it looks realistic enough.", "tags": ["fluid", "turbulence", "weather", "wind"], "likes": 12, "viewed": 482, "published": 3, "date": "1635802914", "time_retrieved": "2024-07-30T18:51:13.325424", "image_code": "vec2 fluid(vec2 uv1){\n vec2 uv = uv1;\n float t = iTime;\n for (float i = 1.; i < 15.; i++)\n  {\n    uv.x -= (t+sin(t+uv.y*i/1.5))/i;\n    uv.y -= cos(uv.x*i/1.5)/i;\n  }\n  return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = fragCoord/iResolution.xy*10.;\n uv = fluid(uv);\n float r = abs(sin(uv.x))+.5;\n float g =abs(sin(uv.x+2.+iTime*.2))-.2;\n float b = abs(sin(uv.x+4.));   \n vec3 col = vec3(r,g,b);   \n \n fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ttGR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 180], [182, 182, 239, 239, 462]], "test": "untested"}
{"id": "fld3R4", "name": "2D Light Propagation Volume", "author": "paniq", "description": "2D analog of Light Propagation Volumes. right side is a raymarched projected 1D view of the scene", "tags": ["2d", "light", "propagation", "lpv"], "likes": 35, "viewed": 1339, "published": 3, "date": "1635801176", "time_retrieved": "2024-07-30T18:51:14.378608", "image_code": "\nfloat shade(vec3 sh, vec3 dV, SD sd, int ch, bool proj) {\n    vec3 dZ = vec3(0,0,1) * SH1_Basis;\n    float W = max(0.0, dot(sh, dZ));\n    float L = max(0.0, dot(sh, dV));\n    \n    float d = sd.d/pixel_radius;\n    float w = fwidth(d);\n    float b = clamp(d*0.5+0.5,0.0,1.0);\n    \n    float albedo = sd.albedo[ch];\n    if (sd.emissive && (abs(d) <= 1.0)) {\n        L = albedo;\n    } else {\n        L *= albedo;\n    }\n\n    if (proj) {\n        return L;\n    } else {\n        return mix(L, W, b);\n    }\n    //return W + L*(1.0 - b);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    setup_mouse_pos();\n    set_resolution(iResolution.xy);\n    ivec2 p = ivec2(fragCoord);\n    fragColor = vec4(0,0,0,1);\n    \n    vec2 uv = (fragCoord / iResolution.xy)*2.0 - 1.0;\n    uv *= vec2(iResolution.x/iResolution.y, 1.0);\n    \n    bool proj = uv.x > 1.5; \n    if (proj) {\n        // raymarch 2D surface\n        vec2 ro = vec2(-2.0, 0.0);\n        vec2 rd = normalize(vec2(0.0, uv.y) - ro);\n        \n        ro += vec2(0.0, 1.2);\n        rd = rotate(rd, radians(-37.0));\n        \n        float t = 0.0;\n        vec2 q;\n        int S = 0;\n        for (int i = 0; i < 32; ++i) {\n            S += 1;\n            q = ro + rd * t;\n            float d = map(q).d;\n            if (d <= 1e-5)\n                break;\n            t = t + abs(d);\n        }\n        if (t > 10.0) {\n            fragColor = vec4(0.0);\n            return;\n        }\n\n        uv = q;\n    }\n    vec2 tuv = ((uv * vec2(iResolution.y/iResolution.x,1.0))*0.5 + 0.5);\n    vec3 shr = texture(iChannel0, tuv).xyz;\n    vec3 shg = texture(iChannel1, tuv).xyz;\n    vec3 shb = texture(iChannel2, tuv).xyz;\n#if 0\n    vec3 dV = vec3(-normal_map(uv, pixel_radius),1) * SH1_Basis;\n    dV = sh_irradiance_probe(dV);    \n#else\n    vec3 dV = lambert(-normal_map(uv, pixel_radius)) * SH1_Basis;\n#endif\n\n#ifdef SHOW_GRADIENT\n    vec3 dX0 = vec3(-1,0,1) * SH1_Basis;\n    vec3 dX1 = vec3(1,0,1) * SH1_Basis;\n    vec3 dY0 = vec3(0,-1,1) * SH1_Basis;\n    vec3 dY1 = vec3(0,1,1) * SH1_Basis;\n    vec3 dZ = vec3(0,0,1) * SH1_Basis;\n    float dx0 = max(0.0,dot(dX0, sh));\n    float dx1 = max(0.0,dot(dX1, sh));\n    float dy0 = max(0.0,dot(dY0, sh));\n    float dy1 = max(0.0,dot(dY1, sh));\n    float dz = dot(dZ, sh);\n    vec3 W =\n          vec3(1.0,0.0,0.0) * dx0\n        + vec3(0.0,1.0,1.0) * dx1\n        + vec3(0.0,1.0,0.0) * dy0\n        + vec3(1.0,0.0,1.0) * dy1\n        + vec3(1.0,1.0,0.0) * dz\n    ;\n    vec3(vec2(dx0+dx1,dy0+dy1), dz);\n#endif\n    SD sd = map(uv);\n\n    vec3 col = vec3(\n        shade(shr, dV, sd, 0, proj),\n        shade(shg, dV, sd, 1, proj),\n        shade(shb, dV, sd, 2, proj));\n    \n    fragColor = vec4(linear_srgb(ACESFitted(max(col * 1.0,vec3(0.0)))),1.0);\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "USE_LPV_KERNEL(0)", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n//#define SHOW_GRADIENT\n#define BOUNCE\n\n// for more information, please see my writeup on the 3D case\n// https://gist.github.com/paniq/9e1043134de8184df33b3cbf29fcaf37\n\nconst float pi = 3.14159265359;\nconst float tau = 6.28318530718;\nconst float unit_sphere_area = 2.0 * tau;\nconst float unit_circle_area = 2.0 * pi;\n#if 1\n\n// circular harmonics\n// see also https://blackpawn.com/texts/ch/default.html\n// and https://valdes.cc/articles/ch.html\n\nconst float unit_area = unit_circle_area;\nconst vec3 SH1_Basis = sqrt(vec3(vec2(2.0),1.0) / unit_circle_area);\n\nvec3 ambient () {\n    return vec3(0,0,2.0 * pi);\n}\n\nvec3 lambert (vec2 n) {\n    return vec3(n * 0.5 * pi, 2.0);\n}\n\nvec3 half_lambert (vec2 n) {\n    return vec3(n * 0.5 * pi, pi);\n}\n\nvec3 light (vec2 n, float sa) {\n    return vec3(n * 2.0 * sin(sa / 2.0), sa);\n}\n\n#define SHSharpness 1.0 // 2.0\nvec3 sh_irradiance_probe(vec3 v) {\n    const float sh_c0 = (2.0 - SHSharpness) * 1.0;\n    const float sh_c1 = SHSharpness * 2.0 / 3.0;\n    return vec3(v.xy * sh_c1, v.z * sh_c0);\n}\n#else // 3d basis, not going to work here\n\n// for a simulation in 3D, see\n// https://www.shadertoy.com/view/XdtSRn\n\nconst float unit_area = unit_sphere_area;\nconst vec4 SH1_Basis = sqrt(vec4(vec3(3.0),1.0) / unit_sphere_area);\n\nvec4 ambient () {\n    return vec4(0,0,0,2.0 * tau);\n}\n\nvec4 light (vec3 n, float sa) {\n    float k = (cos (sa / 4.0));\n    return vec4(n * (pi * (1.0 - k * k)), tau * (1.0 - k));\n}\n\n#define SHSharpness 1.0 // 2.0\nvec4 sh_irradiance_probe(vec4 v) {\n    const float sh_c0 = (2.0 - SHSharpness) * 1.0;\n    const float sh_c1 = SHSharpness * 2.0 / 3.0;\n    return vec4(v.xyz * sh_c1, v.w * sh_c0);\n}\n#endif\n\n//---------------------------------------------------------------------------------\n\nvec2 rotate(vec2 p, float r) {\n    float c = cos(r); float s = sin(r);\n    return mat2(c,s,-s,c) * p;\n}\n\n// shaded distance\nstruct SD {\n    float d;\n    vec3 albedo;\n    bool emissive;\n};\n\nSD sd_min(SD a, SD b) {\n    if (a.d <= b.d)\n        return a;\n    else\n        return b;\n}\n\nSD sd_max(SD a, SD b) {\n    if (a.d >= b.d)\n        return a;\n    else\n        return b;\n}\n\nSD sd_neg(SD a) {\n    return SD(-a.d, a.albedo, a.emissive);\n}\n\nSD shade(float d, vec3 albedo) {\n    return SD(d, albedo, false);\n}\n\nSD emitter(float d, vec3 light) {\n    return SD(d, light, true);\n}\n\nfloat box(vec2 p, vec2 r) {\n    p = abs(p) - r;\n    return max(p.x, p.y);\n}\n\nfloat sphere(vec2 p, float r) {\n    return length(p) - r;\n}\n\nSD slitlight(vec2 p) {\n    const vec3 color = vec3(0.01, 0.5, 0.95);\n    float angle = max(0.0,cos(atan(p.y, p.x)*6.0));\n    if (angle < 0.5)\n        angle = 0.0;\n    SD d2 = emitter(sphere(p, 0.1),color * angle * 20.0);\n    return d2;\n}\n\nvec2 mouse_pos;\n#define setup_mouse_pos() \\\n    mouse_pos = ((iMouse.xy / iResolution.xy)*2.0 - 1.0) * vec2(iResolution.x/iResolution.y, 1.0);\n\n\nSD map(vec2 p) {\n    const vec3 color1 = vec3(0.8);\n    const vec3 color3 = vec3(0.95, 0.5, 0.01);\n    const vec3 color4 = vec3(0.01, 1.0, 0.8);\n\n    SD d = shade(sphere(p, 0.5),color1);\n    \n    SD d2 = slitlight(p - vec2(-0.8,-0.1));\n    \n    SD d3 = shade(box(p - vec2(-0.5,-0.2), vec2(0.52,0.05)),color1);\n    \n    SD d4 = shade(box(rotate(p, radians(90.0+30.5)) - vec2(0.0, 0.0), vec2(0.05,0.8)),color3);\n    SD d5 = shade(box(p - vec2(0.0, 0.0), vec2(0.05,0.4)),color3);\n    SD d7 = shade(box(p - vec2(0.20, 0.1), vec2(0.05,0.2)),color4);\n    \n    SD d6 = emitter(box(rotate(p - vec2(0.25, -0.2),radians(30.5)), vec2(0.01,0.04)),20.0*vec3(1.0,0.9,0.8));\n    \n    SD d8 = shade(sphere(p - mouse_pos, 0.05),vec3(1.0));\n    \n    return sd_min(d8,sd_min(d6,sd_min(d3,sd_min(d2, sd_max(d,sd_neg(sd_min(d7,sd_min(d4,d5))))))));\n}\n\nvec2 normal_map(vec2 p, float eps) {\n    return normalize(vec2(\n        (map(p + vec2(eps, 0.0)).d - map(p - vec2(eps, 0.0)).d),\n        (map(p + vec2(0.0, eps)).d - map(p - vec2(0.0, eps)).d)));\n}\n\n//---------------------------------------------------------------------------------\n\nvec2 resolution;\nfloat pixel_radius;\n\nvec2 pixel2uv(ivec2 p) {\n    vec2 uv = ((vec2(p) + 0.5) / resolution.xy)*2.0-1.0;\n    uv.x *= resolution.x/resolution.y;\n    return uv;\n}\n\nvec3 occluder(ivec2 p, out SD sd) {\n    vec2 uv = pixel2uv(p);\n    float r = pixel_radius;\n    sd = map(uv);\n    float d = sd.d / r;\n    if (d > 1.0)\n        return vec3(0.0);\n    vec2 n = normal_map(uv, r);\n    // orthodox: solid angle goes from 100% to 50%, then drops\n    // to 0% when the point is inside the surface\n    //float opacity = step(0.0,d)*(d*0.5+0.5);\n    // benevolent: no discontinuity, 50% visibility on the surface\n    //float opacity = max(0.0,(d*0.5+0.5));\n    // smooth: no discontinuity, sine curve\n    float opacity = sin(max(-1.0,d)*pi*0.5)*0.5+0.5;\n    \n    return light(-n, opacity * 2.0 * pi) * SH1_Basis;\n}\n\nvec3 propagate(sampler2D iChannel0, ivec2 p, vec2 n, float sa, SD sd, int ch) {\n    ivec2 R = ivec2(resolution.xy);\n    if ((p.x < 0)||(p.y < 0)||(p.x >= R.x)||(p.y >= R.y))\n        return vec3(0.0);\n    if (sd.d < -pixel_radius)\n        return vec3(0.0);\n    // get occluder of neighbor\n    SD occ_sd;\n    vec3 occ = occluder(p, occ_sd);\n        \n    vec3 F = texelFetch(iChannel0, p, 0).xyz;    \n    vec3 dV = vec3(n,1) * SH1_Basis;\n    // light hitting our interior cell wall\n    float L = max(0.0, dot(F, dV * sa));\n    // how much of their cell wall is occupied?\n    float E = max(0.0, dot(occ, dV * sa));\n    float O =\n#ifdef BOUNCE\n        min(E, 1.0);\n#else\n        0.0;\n#endif\n    // subtract occluder from light\n    vec3 outsh = dV * L * (1.0 - O);\n    vec3 dRV = vec3(-n,1) * SH1_Basis;\n    float ref = 0.0;\n    if (sd.emissive) {\n        if (abs(occ_sd.d) <= pixel_radius) {\n            ref = sd.albedo[ch] * E;\n        }\n    } else {\n        ref = O * L * sd.albedo[ch];\n    }\n    // add emission\n    outsh += ref * dRV;\n    return outsh;\n}\n\nfloat solid_angle(vec2 a, vec2 b) {\n    return acos(dot(normalize(a),normalize(b)));\n}\n\nvoid set_resolution(vec2 res) {\n    resolution = res;\n    //pixel_radius = 0.5 * sqrt(2.0) /resolution.y;\n    pixel_radius = 1.0 * sqrt(2.0) /resolution.y;\n}\n\n#define USE_LPV_KERNEL(CH) \\\n    void mainImage( out vec4 fragColor, in vec2 fragCoord ) \\\n    { \\\n        setup_mouse_pos(); \\\n        set_resolution(iResolution.xy); \\\n        lpv_kernel(fragColor, fragCoord, iChannel0, CH); \\\n    }\n\nvoid lpv_kernel( out vec4 fragColor, in vec2 fragCoord, sampler2D channel, int ch )\n{\n    ivec2 p = ivec2(fragCoord);\n    \n    fragColor = vec4(0.0);\n    \n    SD sd = map(pixel2uv(p));\n    \n#define PROPAGATE(OFS, N, SA) \\\n     propagate(channel, p + OFS, N, SA, sd, ch)\n#if 1\n    int d = 1;\n    float x = 2.0;\n    float sa1 = solid_angle(vec2(x,-1.0),vec2(x,1.0)); // ~53.13°, projecting to the right side of our pixel\n    float sa2 = solid_angle(vec2(x-1.0,1.0),vec2(x,1.0)); // ~18.43°, projecting to the top/bottom side of our pixel\n    // note that sa2 = (90° - sa1) / 2, and analog in the 3D case, sa2 = (4*pi/6 - sa1) / 4\n    vec2 dn1 = normalize(vec2(x - 0.5, 1.0)); // normal to the center of the top side of our pixel\n    vec2 dn0 = normalize(vec2(x - 0.5, -1.0)); // normal to the center of the bottom side of our pixel\n    fragColor.xyz +=\n         PROPAGATE(ivec2(-d, 0), vec2(1,0), sa1)\n        +PROPAGATE(ivec2(-d, 0), dn1, sa2)\n        +PROPAGATE(ivec2(-d, 0), dn0, sa2)\n        +PROPAGATE(ivec2(d, 0), vec2(-1,0), sa1)\n        +PROPAGATE(ivec2(d, 0), -dn0, sa2)\n        +PROPAGATE(ivec2(d, 0), -dn1, sa2)\n        +PROPAGATE(ivec2(0,-d), vec2(0,1), sa1)\n        +PROPAGATE(ivec2(0,-d), dn1.yx, sa2)\n        +PROPAGATE(ivec2(0,-d), dn0.yx, sa2)\n        +PROPAGATE(ivec2(0, d), vec2(0,-1), sa1)\n        +PROPAGATE(ivec2(0, d), -dn1.yx, sa2)\n        +PROPAGATE(ivec2(0, d), -dn0.yx, sa2);\n#else\n    float x = 1.0;\n    float sa1 = solid_angle(vec2(x,-1.0),vec2(x,1.0)); // 90°, projecting to the left side of our pixel\n    fragColor.xyz +=\n         PROPAGATE(ivec2(-1, 0), vec2(1,0), sa1)\n        +PROPAGATE(ivec2(1, 0), vec2(-1,0), sa1)\n        +PROPAGATE(ivec2(0,-1), vec2(0,1), sa1)\n        +PROPAGATE(ivec2(0, 1), vec2(0,-1), sa1);\n#endif\n#undef PROPAGATE\n}\n\n//---------------------------------------------------------------------------------\n\n// ACES fitted\n// from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted(vec3 color)\n{\n    color = color * ACESInputMat;\n\n    // Apply RRT and ODT\n    color = RRTAndODTFit(color);\n\n    color = color * ACESOutputMat;\n\n    // Clamp to [0, 1]\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n\n//---------------------------------------------------------------------------------\n\nfloat linear_srgb(float x) {\n    return mix(1.055*pow(x, 1./2.4) - 0.055, 12.92*x, step(x,0.0031308));\n}\nvec3 linear_srgb(vec3 x) {\n    return mix(1.055*pow(x, vec3(1./2.4)) - 0.055, 12.92*x, step(x,vec3(0.0031308)));\n}\n\nfloat srgb_linear(float x) {\n    return mix(pow((x + 0.055)/1.055,2.4), x / 12.92, step(x,0.04045));\n}\nvec3 srgb_linear(vec3 x) {\n    return mix(pow((x + 0.055)/1.055,vec3(2.4)), x / 12.92, step(x,vec3(0.04045)));\n}\n\n", "buffer_b_code": "USE_LPV_KERNEL(1)", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "USE_LPV_KERNEL(2)", "buffer_c_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fld3R4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 530], [536, 536, 593, 593, 2729]], "test": "untested"}
{"id": "Ntt3RN", "name": "Waterfall 3", "author": "guil", "description": "Click mouse to add a circular obstacle\nTry different values for parameters in buffer A.\n\nI tried a new advection scheme using average velocity around point, to improve numerical stability and velocity propagation.", "tags": ["fluid", "waterfall"], "likes": 20, "viewed": 476, "published": 3, "date": "1635799069", "time_retrieved": "2024-07-30T18:51:15.169493", "image_code": "#define R iResolution.xy\n#define T(U) texture(iChannel0,U/R)//.xywz\n\nvoid mainImage( out vec4 C, in vec2 U )\n{   \n\n    float m = 4.*min(T(U).w, 0.5);//masse\n    float v = length(T(U).xy)/1.;//velocity\n    float p = T(U).z/10.;//pressure\n    \n    C = m*(vec4(1,1.2,2,1));\n    \n    if (U.x < 0.2*R.x&&U.y < 0.5*R.y) C = vec4(0.5);\n    if (U.x < 0.4*R.x&&U.y < 0.3*R.y) C = vec4(0.5);\n    \n}  ", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define dt .1\n#define g 25.\n#define k 20.\n#define l 15.\n#define nu 0.1\n#define mu 0.1\n#define kappa .0\n\n#define t iTime\n#define R iResolution.xy\n\n#define T(p) texture(iChannel0,(p)/iResolution.xy)\n\nvoid mainImage( out vec4 Q, in vec2 U )\n{   \n    \n    vec4 a = T(U+vec2(1,0)),b = T(U+vec2(0,1)),c = T(U+vec2(-1,0)),d = T(U+vec2(0,-1)),e=.25*(a+b+c+d);\n    \n    vec2 vu = T(U-dt*e.xy*.5).xy;//advection vector estimate\n    Q = T(U-dt*vu);//advection\n    \n \tvec2 gp = vec2(a.z-c.z,b.z-d.z);//pressure gradient\n    vec2 gw = vec2(a.w-c.w,b.w-d.w);//density gradient\n    float div = (a.x-c.x+b.y-d.y);//divergence\n    \n    \n    Q.xy -= dt *(k*gp + Q.w*l*gw + Q.w*vec2(0.,g));//forces\n    Q.z = e.z - 0.025*div;//pressure\n    Q -= dt * vec4(nu,nu,mu,kappa) * 4.*(Q-e);//diffusion\n    \n    //Boundaries\n    if (iFrame < 1) Q = vec4(0,0,1,0);\n    if (U.x < 1.||U.y < 1.) Q.xy *= 0.;\n    if (R.x-U.x < 1.||R.y-U.y < 1.) Q.w *= 0.;\n    if (U.x < 0.2*R.x&&U.y < 0.5*R.y) Q.xy *= 0.;\n    if (U.x < 0.4*R.x&&U.y < 0.3*R.y) Q.xy *= 0.;\n \tif (length(U-vec2(0,0.9*R.y)) < 8.) {Q.xy= Q.xy*.5+.5*vec2(1.+0.4*sin(1.5*t),0); Q.w = 1.;};\n    \n    //click mouse to add a circular obstacle\n    if(length(iMouse.xy - U) < 20. && iMouse.z > 0.5){\n        Q.xyw = vec3(0.);\n    }\n\n\n    Q = clamp(Q, vec4(-15,-15,0,0), vec4(15,15,15,15));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntt3RN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 110, 110, 388]], "test": "untested"}
{"id": "ftdGzN", "name": "Fractal tiling", "author": "jarble", "description": "A tessellated geometric pattern.", "tags": ["fractal", "carpet", "rug"], "likes": 2, "viewed": 268, "published": 3, "date": "1635798782", "time_retrieved": "2024-07-30T18:51:16.028198", "image_code": "\n//change these constants to get different patterns!\n#define c2 1.5\n\n#define c1 vec4(1.0+c2,.5+c2,-1.5,0)\n\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 4.5*3./2.;\n    float t = iTime/8.;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/128.0/12.;\n    uv += vec2(t/2.0,t/3.0)/t1/128.0/6.;\n    float scale = c1.z;\n    for(int j = 0; j < 18;j++){\n        uv = (triangle_wave(uv.yx+scale,scale)+triangle_wave(uv,scale));\n        col[0] += fract(uv.x*.5-uv.y);\n        col = abs(col.yzx*col.x)/(col.x+col.y);\n    }\n    fragColor = vec4(vec3(col),1.0);  \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftdGzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 108, 147, 147, 192], [194, 194, 251, 251, 717]], "test": "untested"}
{"id": "fldGRN", "name": "motion-blur monochrome camera", "author": "morisil", "description": "just an example for a friend", "tags": ["motionblur", "camera", "monochrome"], "likes": 5, "viewed": 486, "published": 3, "date": "1635795959", "time_retrieved": "2024-07-30T18:51:16.906848", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n    // comment this out if you don't want monochrome\n    color = vec3(color.r);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float MIXING_RATE = .03;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 previousFrame = texture(iChannel0, uv);\n    vec4 cameraFrame = texture(iChannel1, uv);\n    fragColor = mix(previousFrame, cameraFrame, MIXING_RATE);\n}\n", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fldGRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 260]], "test": "untested"}
{"id": "sl3GR4", "name": "Neon Run", "author": "flockaroo", "description": "...them damn neons", "tags": ["truchet", "neon", "rollercoaster", "octtree"], "likes": 15, "viewed": 655, "published": 3, "date": "1635789601", "time_retrieved": "2024-07-30T18:51:17.687760", "image_code": "// created by florian berger (flockaroo) - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Neon Run\n//\n// 3D-generalization of multi-scale-truchets (Octtree truchet)\n// golfed down monochrome version: https://www.shadertoy.com/view/st3GRr\n\n\n#define Res vec2(iResolution.xy)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=texture(iChannel0,fragCoord/Res);\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// created by florian berger (flockaroo) - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Neon Run\n//\n// 3D-generalization of multi-scale-truchets (Octtree truchet)\n// golfed down monochrome version: https://www.shadertoy.com/view/st3GRr\n\n#define SIM_CAM\n#define COLOR\n#define FLICKER\n\n#define Res vec2(iResolution.xy)\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n#define PI  3.14159265359\n#define PI2 6.28318530718\n#define PIH 1.57079632679\n#define SQH sqrt(.5)\n\n#define ROTM(ang) mat2(cos(ang-vec2(0,PIH)),-sin(ang-vec2(0,PIH)))\n\nvec3 rotZ(float ang, vec3 p) { return vec3(ROTM(ang)*p.xy,p.z); }\nvec3 rotX(float ang, vec3 p) { return rotZ(ang,p.yzx).zxy; }\n\nvec4 getRand(int i) { return texelFetch(iChannel1,ivec2(i,i%256)%256,0); }\nvec4 getRand(float f) { return mix(getRand(int(floor(f))),getRand(int(ceil(f))),fract(f)); }\n\nfloat distCell01(vec3 p, float n)\n{\n    float d=1000.;\n    p-=.5;\n    for(int i=0;i<3;i++) {\n        vec3 p2=p;\n        p2.z=(fract((p2.z+.5)*n)-.5)/n;\n        float l=length(p2.xy-(-.5));\n        float l0=(min(floor(l*n),n-1.)+.5)/n;\n        d=min(d,length(vec2(l-l0,p2.z)));\n        p=(p*vec3(-1,-1,1)).yzx;\n    }\n    return d;\n}\n\nvec3 getR(vec3 p)\n{\n    return cos((p+p.zxy*1.1+p.yzx*1.3)*10.)*.5+.5;\n}\n\nvec3 g_r=vec3(0);\nvec3 g_p0=vec3(0);\nfloat g_radius=0.002;\n\nfloat dist(vec3 p)\n{\n    p+=(getR(p*.3)-.5)*.1;\n    float sc=1.;\n    vec3 p0=floor(p/sc)*sc;\n    if (getR(p0).x>.75) { sc*=.5; p0=floor(p/sc)*sc; }\n    if (getR(p0).x>.75) { sc*=.5; p0=floor(p/sc)*sc; }\n    if (getR(p0).x>.75) { sc*=.5; p0=floor(p/sc)*sc; }\n    g_r=getR(p0);\n    g_p0=p0;\n    vec3 s=sign(getR(p0)*2.-1.);\n    return distCell01(((p-p0)/sc-.5)*s+.5,2.*2.*2.*sc)*sc-g_radius;\n}\n\nvec3 getGrad(vec3 p, float eps) \n{ \n    vec2 d=vec2(eps,0); \n    float d0=dist(p);\n    return vec3(dist(p+d.xyy)-d0,dist(p+d.yxy)-d0,dist(p+d.yyx)-d0)/eps; \n}\n\n// HSV <-> RGB from http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 neonCol(vec3 p)\n{\n    float sc=3.;\n    vec4 c=texelFetch(iChannel1,(ivec2(p.xy*sc)+ivec2(17,13)*int(p.z*sc))%256,0);\n    c=g_r.xyzx;\n    float onoff=1.;\n    #ifdef FLICKER\n    onoff=(c.x<.5 && c.w<.5 && abs(c.w-getRand(iFrame/7).x)<.1?0.:1.);\n    float s=sin(iTime*.2-length(g_p0.x*.3));\n    onoff=min(onoff,1.-clamp(exp(-s*s/.1/.1)*10.,0.,1.3+.4*getRand(iFrame/2).x));\n    onoff=mix(1.-onoff,onoff,step(.7,fract(iTime/27.)));\n    onoff=max(onoff,0.);\n    #endif\n    vec3 col=vec3(1);\n    #ifdef COLOR\n    col=hsv2rgb(vec3(c.y*1.5,.3,1));\n    #endif\n    return col*onoff;\n}\n\nvec3 g_glow;\n\nfloat march(inout vec3 pos, vec3 dir)\n{\n    g_glow=vec3(0);\n    float eps=.001;\n    int i2=0;\n    float dall=0.;\n    for(int i=0;i<150;i++)\n    {\n        float d=dist(pos);\n        dall+=d;\n        pos+=dir*d*.7;\n        g_glow+=neonCol(pos)*.02*exp(-d/.07)*exp(-dall/3.);\n        if (d<eps*max(dall/2.,1.)) { i2=i; return 1.; }\n    }\n    return 0.;\n}\n\nvoid getTrafo(inout vec3 pos, inout vec3 dir, vec2 fc)\n{\n    vec2 sc=(fc-Res*.5)/Res.x*2.;\n    dir=normalize(vec3(sc,-.75));\n    pos=vec3(0,0,.0125);\n    #ifdef SHADEROO\n    pos*=exp(-iMouseData.z/3000.);\n    #endif\n    float ph = iMouse.x/Res.x*10.;\n    float th = iMouse.y/Res.y*10.;\n    ph+=iTime*.2;\n    th+=iTime*.1;\n    pos.yz=ROTM(th)*pos.yz;\n    dir.yz=ROTM(th)*dir.yz;\n    pos.xy=ROTM(ph)*pos.xy;\n    dir.xy=ROTM(ph)*dir.xy;\n    pos+=vec3(.0)+vec3(1,.3,.2)*iTime*.1;\n}\n\nvoid camPhys(inout vec3 cpos, inout vec3 cdir, inout vec3 cup, inout vec3 cpos_old)\n{\n    vec3 cdir0=cdir;\n    float eps=.001;\n    vec3 g =getGrad(cpos,eps);\n    vec3 dg=getGrad(cpos+cdir*eps,eps)-g;\n    for(int i=0;i<10;i++){\n        vec3 ddir=(getRand(iFrame+i*13).xyz-.5)*.01;\n        vec3 dg2=getGrad(cpos+normalize(cdir+ddir)*eps,eps)-g;\n        if(length(dg2)<length(dg)) { cdir=normalize(cdir+ddir); dg=dg2; }\n    }\n    cpos+=cdir*.002;\n    vec3 up=normalize(getGrad(cpos,eps));\n    cpos-=dist(cpos)*up*.7;\n    cdir=normalize(cross(up,cross(cdir,up)));\n    cup=up;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos,dir;\n#ifdef SIM_CAM\n    vec3 cpos,cpos_old,cdir,cup;\n    cpos     = texelFetch(iChannel0,ivec2(0,0),0).xyz;\n    cdir     = texelFetch(iChannel0,ivec2(1,0),0).xyz;\n    cpos_old = texelFetch(iChannel0,ivec2(2,0),0).xyz;\n    camPhys(cpos,cdir,cup,cpos_old);\n    vec2 sc=(fragCoord-Res*.5)/Res.x*2.;\n    dir=normalize(vec3(sc.xy,-.75));\n    float ph = (iMouse.x<1.)?0.:(iMouse.xy-Res*.5).x/Res.x*10.;\n    float th = (iMouse.x<1.)?-.3:(iMouse.xy-Res*.5).y/Res.y*10.;\n    dir.yz=ROTM(th)*dir.yz;\n    dir.xz=ROTM(ph)*dir.xz;\n    dir=-dir.z*cdir+cup*dir.y+cross(cdir,cup)*dir.x;\n    vec3 shake=.005*vec3(sin(iTime*1.5),sin(iTime*1.),0)+(getRand(iTime*10.).xyz-.5)*.00;\n    pos=cpos+cup*(.01+shake.z)+cross(cup,dir)*shake.x+cup*shake.y;\n#else\n    getTrafo(pos,dir,fragCoord);\n#endif\n    vec3 pos0=pos;\n    g_radius=.002;\n    float hit=march(pos,dir);\n    vec3 neonColo=neonCol(pos)-.2;\n    vec3 posi=pos; g_radius=.001;\n    vec3 glow=g_glow;\n    g_radius*=.5;\n    float hiti=march(posi,dir);\n    vec3 neonColi=neonCol(posi)+.2;\n    float d=dist(pos);\n    vec3 col=g_r;\n    vec3 n=normalize(getGrad(pos,.001));\n    vec3 ni=normalize(getGrad(posi,.001));\n    fragColor.xyz=(n*.5+.5)*1.3;\n    vec3 eye=normalize(pos0-pos);\n    float x=1.-dot(n,eye);\n    fragColor.xyz=vec3(1);\n    vec3 c1=mix(vec3(0),vec3(dot(n,-dir)*.1+1.),exp(-length((pos-pos0)/3.)));\n    vec3 c2=mix(vec3(0),vec3(-dot(ni,-dir)*.0+1.),exp(-length((posi-pos0)/5.)));\n    fragColor.xyz=vec3(0)+exp(-length((pos-posi)-dot(pos-posi,dir)*dir)/.15);\n    fragColor.xyz=vec3(0)+length((pos-posi)-dot(pos-posi,dir)*dir)*200000.;\n    \n    fragColor.xyz=hit*(1.-neonColo)*.45*(dot(n,-dir)*.5+.5)*exp(-length(pos-pos0)/3.);\n    fragColor.xyz=fragColor.xyz+.3*max(c1*c1*c1*c1*.8*neonColo,c2*c2*c2*c2*1.1*neonColi)*vec3(1.05,1,.95);\n    fragColor.xyz+=.7*c1*c1*c1*c1*1.3*neonColo*vec3(1.05,1,.95);\n    fragColor.xyz+=vec3(.9,1,1.2)*(sqrt(glow)*.15+glow*.3)*1.35;\n    fragColor.xyz=pow(fragColor.xyz,vec3(2));\n    fragColor.w=1.;\n#ifdef SIM_CAM\n    if (iTime<=1.) { cpos=vec3(-2.3); cdir=normalize(vec3(1,1,1)); }\n    cdir+=.01;\n    if (ivec2(fragCoord)==ivec2(0,0)) fragColor.xyz=cpos;\n    if (ivec2(fragCoord)==ivec2(1,0)) fragColor.xyz=cdir;\n    if (ivec2(fragCoord)==ivec2(2,0)) fragColor.xyz=cpos_old;\n#endif\n}\n\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl3GR4.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[325, 325, 382, 382, 432]], "test": "untested"}
{"id": "fttGz4", "name": "Persian carpet fractal 8", "author": "jarble", "description": "A Persian carpet fractal pattern.", "tags": ["fractal", "carpet", "rug"], "likes": 3, "viewed": 267, "published": 3, "date": "1635786272", "time_retrieved": "2024-07-30T18:51:18.473661", "image_code": "\n//change these constants to get different patterns!\n#define c2 1.5\n\n#define c1 vec4(1.0+c2,.5+c2,-1.5,0)\n\n//to do: drag and drop using https://www.shadertoy.com/view/WdGGWh\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5*3./2.;\n    float t = 45.87+iTime/2.;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/128.0/4.;\n    uv += vec2(t/2.0,t/3.0)/t1/128.0/8.;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    float t2 = floor((t+4.)/20.0+uv.x);\n    //vec3 random2 = hash31(1.+t2);\n    \n    \n    float offset = -.05;\n    \n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        float t3 = float(c)+t2;\n\n        for(int i=0;i<3;i++)\n        {\n            vec3 col_prev = col;\n            float factor = -.7;\n            float factor1 = 8.;\n            \n            uv = triangle_wave(uv.yx+scale,scale)+triangle_wave(uv,scale);\n            //uv.y /= .9;\n            uv.x *= factor;\n            for(int j = 0; j < 3;j++){\n                uv = triangle_wave((uv*(1.+offset)),scale);\n            }\n            uv.x /= -factor;\n            \n            if(i>0) col = abs(col.yzx*col.x + col_prev*col.y)/(col.x-col.y);\n            \n            col[c] = fract((uv.x*(1.+col.x/factor1))-(uv.y*(col.y/factor1+1.)));\n        }\n    }\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fttGz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[175, 175, 214, 214, 259], [261, 261, 318, 318, 1476]], "test": "untested"}
{"id": "7stGzX", "name": "Bake PT cubemap", "author": "jvb", "description": "Baking a simple path tracer into a cube map ", "tags": ["bake"], "likes": 17, "viewed": 428, "published": 3, "date": "1635779632", "time_retrieved": "2024-07-30T18:51:19.327376", "image_code": "\nvec3 rm(in vec3 ro, in vec3 rd, float time)\n{\n\tvec3 color = vec3(0.0);  \n\tvec3 tex = vec3(0);\n    \n    vec3 pos = ro; \n\t\tfloat dist = 0.0; \n\t\tvec2 d = vec2(0); \n\t\t\n\n\t\tfor (int i = 0; i < 64; i++) {\n        \td = scene(pos); \n            if (abs(d.x) < 0.0001) break; \n\t\t\tpos += rd*d.x;\n\t\t}\n        \n \t   //vec3 n = get_normal(pos);\n    \tcolor = texture(iChannel2,pos.xyz).xyz; \n\treturn color; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 p = 2.0*( fragCoord.xy / iResolution.xy )-1.0;\n\n    // Time varying pixel color\n    vec3 color =  vec3(0);\n\n    \n    vec3 ro, rd; \n    \n    // persp\n\t#if 1\n\tp.x *= iResolution.x/iResolution.y; \n\tro = vec3(3.0+sin(iTime*1.1),-0.9,1.0+sin(iTime*0.7));\n    //ro = vec3(0,0,0);\n\trd = normalize(vec3(p.x,p.y,-1.0)); \n\t#endif\n\n    \n\tvec2 tmouse = vec2(iMouse.x*0.001,iMouse.y*0.001);\t\n    #if 1\n\trd = rotatex(rd, -0.0+1.0f*tmouse.y*10.0);\n\trd = rotatey(rd, -1.5+1.0f*tmouse.x*10.0);\n    #endif\n\n    \n    color = rm(ro,rd,iTime); \n    \n\t#define GAMMA 1\n\t#if GAMMA\n\tcolor = pow(color,vec3(1.0/1.5));\n\t#endif\n    // Output to screen\n    fragColor = vec4(color, 1.0); \n    //fragColor = texture(iChannel0,uv);\n    //fragColor = texture(iChannel2,vec3(uv.x,uv.y,0.0)); \n}\n", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "\nfloat random(vec3 scale, float seed) { \n\treturn fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed); \n} \n\nvec3 cosineWeightedDirection(float seed, vec3 normal) {\n#if 0\n\tfloat a = 2.0*random(vec3(12.9898, 78.233, 151.7182), seed)-1.0; \n\tfloat b = 2.0*random(vec3(63.7264, 10.873, 623.6736), seed)-1.0; \n\tfloat c = sqrt(1.0-a*a);\n\tvec3 r = vec3(c*cos(b),a,c*sin(b)); \n\treturn dot(r,normal) > 0.0 ? r : -r; \n#else\n\tfloat u = random(vec3(12.9898, 78.233, 151.7182), seed); \n\tfloat v = random(vec3(63.7264, 10.873, 623.6736), seed); \n\tfloat r = sqrt(u); \n\tfloat angle = 6.283185307179586 * v; \n\tvec3 sdir, tdir; \n\tif (abs(normal.x)<.5) { \n\t\tsdir = cross(normal, vec3(1,0,0)); \n\t} else { \n\t\tsdir = cross(normal, vec3(0,1,0)); \n\t} \n\ttdir = cross(normal, sdir); \n\treturn r*cos(angle)*sdir + r*sin(angle)*tdir + sqrt(1.-u)*normal; \n#endif\n} \n\nvec3 uniformlyRandomDirection(float seed) { \n\tfloat u = random(vec3(12.9898, 78.233, 151.7182), seed); \n\tfloat v = random(vec3(63.7264, 10.873, 623.6736), seed); \n\tfloat z = 1.0 - 2.0 * u; float r = sqrt(1.0 - z * z); \n\tfloat angle = 6.283185307179586 * v; \n\treturn vec3(r * cos(angle), r * sin(angle), z); \n} \n\nvec3 uniformlyRandomVector(float seed) { \n\treturn uniformlyRandomDirection(seed) * sqrt(random(vec3(36.7539, 50.3658, 306.2759), seed)); \n} \n\n\n\nvec3 rm(in vec3 ro, in vec3 rd, float time)\n{\n\tvec3 colorMask = vec3(1.0); \n\tvec3 color = vec3(0.0);  \n\tvec3 surfaceColor = vec3(0);\n\tvec3 tex = vec3(0);\n#define BOUNCES 3\n\tfor (int bounce = 0; bounce < BOUNCES; bounce++) {\n\t\tvec3 pos = ro; \n\t\tfloat dist = 0.0; \n\t\tvec2 d = vec2(0); \n\t\t\n\t\tif (bounce == 0) {\n            for (int i = 0; i < 64; i++) {\n                d = scene(pos); \n                if (abs(d.x) < 0.0001) break; \n                pos += rd*d.x;\n            }\n\t\t}\n\t\telse {\n            for (int i = 0; i < 64; i++) {\n                d = scene(pos); \n                if (abs(d.x) < 0.0001) break; \n                pos += rd*d.x;\n            }\t\t\t\n\t\t}\n        dist = length(pos-ro); \n\t\tif (dist < 10000.0 && abs(d.x) < 100.0) {\n\t\t\tfloat o = d.y;\n\t\t\tvec3 n = get_normal(pos); \n\t\t\tfloat shade = 1.0; //ambientOcclusion(pos+0.001*n, 1.0*n)*1.0;\n\n\t\t\t#define MULTISAMPLE_TEX 0\n\t\t\tif (true) {\n\t\t\t#if MULTISAMPLE_TEX\n\t\t\ttex = vec3(0);\n\t\t\t\tfor (int i = 0; i < 16; i++) {\n\t\t\t\t\tfloat AA = 0.01; \n\t\t\t\t\ttex += get_tex(pos + AA*uniformlyRandomVector(float(time)+float(i))); \n\t\t\t\t}\n\t\t\t\ttex /= 16.0;\n\t\t\t#else\n\t\t\t\ttex = get_tex(pos); \n\t\t\t#endif\n\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\tif (d.y == 1.0) {\n\t\t\t\t// Light, luminance\n\t\t\t\tsurfaceColor =vec3(1,1,1)*100.0; \n\t\t\t}\n\t\t\tif (d.y == 2.0) {\n\t\t\t\tsurfaceColor = vec3(1,0,0); \n\t\t\t}\n\t\t\tif (d.y == 3.0) {\n\t\t\t\tsurfaceColor = tex*vec3(1,1,1); \n\t\t\t}\n\t\t\tif (d.y == 4.0) {\n\t\t\t\tvec3 lightpos = vec3(10,0,-4); \n\t\t\t\tvec3 l = normalize(lightpos - pos);\n\t\t\t\tfloat diff = clamp(dot(n,l), 0.0,1.0);\n\t\t\t\tsurfaceColor = mix(vec3(1,1,1)*1.0,vec3(1,1,1)*1.1,diff);\n//\t\t\t\tsurfaceColor = vec3(1);\n\t\t\t}\n\t\t\tif (bounce == 0) {\n\t\t\t\tcolorMask *= surfaceColor;\n\t\t\t\tcolor += 0.5*(shade*surfaceColor); //*colorMask; \n\t\t\t}\n\t\t\telse {\n\t\t\t\tcolorMask *= surfaceColor;\n\t\t\t\tcolor += 0.5*(shade*surfaceColor)*clamp(dist*0.25,0.0,32.0); //*colorMask; \n\t\t\t}\n\t\t\tfloat refl = 0.0;\n\t\t            float rr = random(vec3(36.7539, 50.3658, 306.2759), time+float(bounce));\n\t\t            refl = clamp(refl*rr, 0.0, 1.0);\n\t\t\tro = pos+n*0.001; \n\t\t\tvec3 rd2 = reflect(rd, n); \n\t\t\trd = normalize(cosineWeightedDirection(time+float(bounce), n));\t\t\t\t\t\n\t\t\trd = normalize(mix(rd, rd2, refl));\n\t\t\t\n\t\t}\t\n\t}\n\treturn clamp(color, 0.0, 1.0); \n}\n\n\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    vec3 color = vec3(0); \n    \n\t#define SSAMPLES 1\n\tfor (int i = 0; i < SSAMPLES; i++) {\n\t\tcolor += rm(ro, rd, iTime+float(i)); \n\t}\n\tcolor /= float(SSAMPLES);\n\t    \n    // Output to cubemap\n    color = mix(color, texture(iChannel0, rd).xyz, 0.99); \n    fragColor = vec4(color,1.0);\n}", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n//uniform float time;\n//uniform vec2 mouse;\n//uniform vec2 resolution;\n\nvec3 rotatey(in vec3 p, float ang) { return vec3(p.x*cos(ang)-p.z*sin(ang),p.y,p.x*sin(ang)+p.z*cos(ang));  }\nvec3 rotatex(in vec3 p, float ang) { return vec3(p.x,p.y*cos(ang)-p.z*sin(ang),p.y*sin(ang)+p.z*cos(ang));  }\nvec3 rotatez(in vec3 p, float ang) { return vec3(p.x*cos(ang)-p.y*sin(ang),p.x*sin(ang)+p.y*cos(ang),p.z);  }\n\nvec2 sph(in vec3 p, float r, float o) { return vec2(length(p)-r, o); }\nvec2 rbox(in vec3 p, in vec3 b, float r, float o) { return vec2(length(max(abs(p)-b,0.0))-r, o); }\nvec2 sdbox( vec3 p, vec3 b, float o ) { vec3 d = abs(p) - b; return vec2(min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)), o); }\nvec2 plane(in vec3 p, in vec3 n, float d, float o) { return vec2(dot(p,n)-d, o); }\n\nvec2 min2(in vec2 o1, in vec2 o2) { if (o1.x < o2.x) return o1; else return o2; }\nvec2 max2(in vec2 o1, in vec2 o2) { if (o1.x > o2.x) return o1; else return o2; }\nfloat lightgap = 1.0;\nvec2 scene(in vec3 p)\t\n{\n\tvec2 d = vec2(1000.0, 0);     \n   \td = min2(d, vec2(-1,1)*sdbox(p-vec3(0,0,0), vec3(6,2,8),3.0));\t\n\td = max2(d, vec2(-1,1)*sdbox(p-vec3(0,-2,0), vec3(5,1,7),3.0));\t\n\td = max2(d, vec2(-1,1)*sdbox(p-vec3(0,-2,0), vec3(4,2,2),3.0));\t\n\n    return d; \n}\n\nvec3 get_tex(in vec3 p)\n{\n\tvec3 col = vec3(0.0);\n    if (p.x < -5.999 && abs(p.z+p.y+4.0) < 2.0) col += vec3(25);\n    if (p.x < -5.999 && abs(p.z-p.y-4.0) < 2.0) col += vec3(25);\t\n\treturn col*0.5;\n}\nvec3 get_normal(in vec3 p)\n{\n\tvec3 eps = vec3(0.001, 0, 0); \n\tfloat nx = scene(p + eps.xyy).x - scene(p - eps.xyy).x; \n\tfloat ny = scene(p + eps.yxy).x - scene(p - eps.yxy).x; \n\tfloat nz = scene(p + eps.yyx).x - scene(p - eps.yyx).x; \n\treturn normalize(vec3(nx,ny,nz)); \n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7stGzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 46, 46, 395], [397, 397, 454, 504, 1311]], "test": "untested"}
{"id": "slcGR4", "name": "test024175", "author": "JonathanMerfy", "description": "test024175#11test,test02,testest222", "tags": ["test", "test02", "testest222"], "likes": 6, "viewed": 268, "published": 3, "date": "1635774636", "time_retrieved": "2024-07-30T18:51:20.330694", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));\n    float i=0.,g=0.,e,s,h,a;\n    for(;++i<99.;)\n    {\n        p=g*d;\n        p.z+=iTime*0.1;\n        p=sin(p);\n        p=R(p,vec3(.577),iTime*.5);\n        p=abs(p)-.2;//-.2 is nice, \n        p=p.x<p.y?p.yzx:p.zyx;\n        p=p.x<p.y?p.zxy:p.zyx;\n        s=2.;\n        for(int i=0;i++<8;){\n          s*=e=2./clamp(dot(p,p),.3,1.2);\n          p=abs(p)*e-vec3(.8,8,.8);\n        }\n        a=1.;\n        p-=clamp(p,-a,a);\n        g+=e=length(p)/s;\n        O.rgb+=(H(s*.01)+.5)*.01*exp(-.2*i*i*e);\n    }\n    O=pow(O,vec4(4));\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slcGR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 143, 143, 748]], "test": "untested"}
{"id": "fl3Gz4", "name": "Mandelbulb fractal", "author": "busybeaver", "description": "Mandelbulb fractal.", "tags": ["fractal", "mandelbrot", "mandelbulb"], "likes": 10, "viewed": 369, "published": 3, "date": "1635773776", "time_retrieved": "2024-07-30T18:51:21.154492", "image_code": "#define enable_color_correction 1\n\n#if enable_color_correction\nfloat gamma = 2.2; // For gamma correction.\nfloat exposure = 0.6;\nfloat tone_pow = 0.3; // Represents how strong the tone mapping is.\n\nvec3 correct_color(vec3 c) {\n    c *= exposure;\n    c = pow(c, vec3(1. / tone_pow));\n    c = pow(c / (c + 1.), vec3(tone_pow));\n    c = pow(c, vec3(1. / gamma));\n    return c;\n}\n#endif\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    #if enable_color_correction\n    fragColor = vec4(correct_color(texture(iChannel0, fragCoord.xy/iResolution.xy).xyz), 1.);\n    #else\n    fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    #endif\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float pi = 3.1415926;\n\nfloat n = 8.; // n is the power. Change it to get different fractals. Classic power is 8.\n\nint start_frame = 0; // The frame from which the rendering starts. Increase it to have time to turn on full-screen mode.\n#define seed_type 0 // 0 - different seeds for different pixels and frames (noisy), 1 - different seeds for different frames.\n#define slice 0 // 0 - no slice, 1 - slice z, 2 - slice y, 3 - slice x\n#define rot 0 // 0 - no rotation, 1 - flip x and y, 2 - flip x and z, 3 - flip y and z\nfloat rotation_x = .7;\nfloat rotation_y = .1;\nfloat rotation_y_2 = .015;\nfloat w = 2.3;\nfloat cam_dist = 4.4;\nfloat floor_h = -0.92;\nint max_iters = 150;\nint max_steps = 400;\nfloat min_dist = 0.0006;\nfloat close_dist = 0.001;\nfloat max_dist = 1000.;\n\nuint rand_seed;\n\n// There are 3 variants of the power function.\n// 1-st is from russian Wiki (https://ru.wikipedia.org/wiki/Оболочка_Мандельброта). The best formula.\n// 2-nd is from this shader: https://www.shadertoy.com/view/ltfSWn . It is the common used formula.\n// but it seems not to work well. A slice of mandelbulb made with that formula does not look like the mandelbrot set.\n// you can see it by setting slice = 1 or 2 or 3.\n// 3-rd is from english Wiki (https://en.wikipedia.org/wiki/Mandelbulb). It does not work at all.\n// Another seems to be used in famous picture from Wiki (https://en.wikipedia.org/wiki/File:Power_8_mandelbulb_fractal_overview.jpg)\n// But I do not know it.\n\nvec3 power(vec3 z, float p) {\n    float o = p * atan(z.y, z.x);\n    float f = p * atan(z.z, length(z.xy));\n    return pow(length(z), p) * vec3(cos(o)*cos(f), sin(o)*cos(f), sin(f));\n}\n\n/*\nvec3 power(vec3 z, float p) {\n    float r = length(z);\n    float b;\n    if(r != 0.) b = p * acos(z.y / r);\n    else b = 0.;\n    float a = p * atan(z.x, z.z );\n    return pow(r, p) * vec3(sin(b) * sin(a), cos(b), sin(b) * cos(a));\n}\n*/\n/*\nvec3 power(vec3 z, float p) {\n    float o = p * atan(length(z.xy), z.z);\n    float f = p * atan(z.y, z.x);\n    return pow(length(z), p) * vec3(cos(f) * sin(o), sin(f) * cos(o), sin(o));\n}\n*/\n\nvec3 iter(vec3 z, vec3 c) {\n    return power(z, n) + c;\n}\n\n// Distance estimator was taken from here: http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nfloat dist(vec3 c, vec3 ray) {\n    #if slice == 0\n    float d2 = -1.;\n    #endif\n    #if slice == 1\n    float d2 = (c.z > 0.) ? ((ray.z < 0.) ? - c.z / ray.z * .9999 : 100.) : -1.;\n    #endif\n    #if slice == 2\n    float d2 = (c.y > 0.) ? ((ray.y < 0.) ? - c.y / ray.y * .9999 : 100.) : -1.;\n    #endif\n    #if slice == 3\n    float d2 = (c.x > 0.) ? ((ray.x < 0.) ? - c.x / ray.y * .9999 : 100.) : -1.;\n    #endif\n    if(length(c) > 3. && dot(c, ray) < 0.) return length(c) - 2.;\n    vec3 z = vec3(0.0, 0.0, 0.0);\n    float dr = 0.;\n    float r;\n    for(int i = 0; i < max_iters; i ++) {\n        r = length(z);\n        if(r > 2.001) {\n            float d = 0.5 * log(r) * r / dr;\n            return (d < close_dist) ? max(d2, d * .5) : max(d2, d);\n        }\n        dr = n * pow(r, n - 1.) * dr + 1.;\n        #if rot == 0\n        z = iter(z, c);\n        #endif\n        #if rot == 1\n        z = iter(z.yxz, c.yxz).yxz;\n        #endif\n        #if rot == 2\n        z = iter(z.zyx, c.zyx).zyx;\n        #endif\n        #if rot == 3\n        z = iter(z.xzy, c.xzy).xzy;\n        #endif\n    }\n    return max(d2, 0.);\n}\n\nfloat rand() {\n    rand_seed += (rand_seed << 10u);\n    rand_seed ^= (rand_seed >>  6u);\n    rand_seed += (rand_seed <<  3u);\n    rand_seed ^= (rand_seed >> 11u);\n    rand_seed += (rand_seed << 15u);\n    return float(rand_seed % 10000000u) * .0000001;\n}\n\nvec3 rand_ray() {\n    float d = rand() * pi * 2.;\n    float y = rand() * 2. - 1.;\n    float r = sqrt(1. - y * y);\n    return vec3(sin(d) * r, y, cos(d) * r);\n}\n\nvec3 march(vec3 ray, vec3 cam) {\n    vec3 pos = cam;\n    vec3 prev_pos = pos;\n    vec3 k = vec3(1., 1., 1.);\n    int b = 0;\n    for(int i = 0; i < max_steps; i ++) {\n        float d = dist(pos, ray);\n        if(d < min_dist) {\n            k *= vec3(.4, smoothstep(.6, 1.2, length(pos)) * .3 + .3, .4);\n            ray = rand_ray();\n            if(dist(pos + ray * min_dist * .01, ray) < d) {\n                ray = rand_ray();\n                if(dist(pos + ray * min_dist * .01, ray) < d) {\n                    ray = rand_ray();\n                    if(dist(pos + ray * min_dist * .01, ray) < d) return vec3(0., 0., 0.);\n                }\n            }\n            pos = prev_pos;\n            b += 1;\n            if(b > 5) return vec3(0., 0., 0.);\n        }\n        float floor_d = (floor_h - pos.y) / ray.y * .995;\n        prev_pos = pos;\n        if(floor_d < d && floor_d > min_dist * .1) {\n            pos += ray * floor_d;\n            ray.y *= -1.;\n            float r = rand();\n            if(r < .4) ray = normalize(ray + rand_ray() * .06);\n            else if(r < .6) ray = rand_ray();\n            if(ray.y < 0.) return vec3(0., 0., 0.);\n            k *= .4;\n        } else {\n            pos += d * ray;\n        }\n        if(d > max_dist)\n            return (vec3(5., 4., 4.) * smoothstep(.55, .6, ray.y) +\n                    vec3(0., 0., 6.) * smoothstep(.83, .85, ray.x) +\n                    vec3(4., 2., 0.) * smoothstep(.83, .85, ray.z) +\n                    vec3(0., 0., 3.) * (1. - smoothstep(-.95, -.93, ray.x)) +\n                    vec3(2., 1., 0.) * (1. - smoothstep(-.95, -.93, ray.z)) +\n                    vec3(0.1, 0.15, 0.15)) * k;\n    }\n    return vec3(0., 0., 0.);\n}\n\nvec2 rotate(vec2 v, float a) {\n    vec2 x = vec2(cos(a), sin(a));\n    vec2 y = vec2(cos(a + pi * 0.5), sin(a + pi * 0.5));\n    return v.x * x + v.y * y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - iResolution.xy * .5) / (iResolution.x + iResolution.y) * 4.;\n    #if seed_type == 1\n    rand_seed = uint(iFrame);\n    #endif\n    #if seed_type == 0\n    rand_seed = uint(iFrame) + uint(abs(uv.x * 10000. + uv.y * 1000000000.));\n    rand();\n    rand_seed += uint(iFrame) + uint(abs(uv.x * uv.y) * 10000.);\n    #endif\n\n    vec3 ray = normalize(vec3(w, uv.yx)) +\n               vec3(rand() / iResolution.x * .7,\n                    rand() / iResolution.x * .7,\n                    rand() / iResolution.x * .7);\n    ray = vec3(rotate(ray.xy, - pi * (rotation_y + rotation_y_2)), ray.z);\n    ray = vec3(rotate(ray.xz, - pi * rotation_x).x, ray.y, rotate(ray.xz, - pi * rotation_x).y);\n\n    vec3 pos = vec3(rotate(vec2(-cam_dist, 0.), - pi * rotation_y), 0.);\n    pos = vec3(rotate(pos.xz, - pi * rotation_x).x, pos.y, rotate(pos.xz, - pi * rotation_x).y);\n\n    vec3 col;\n\n    col = march(ray, pos);\n\n    if(iFrame > start_frame) fragColor = vec4(col, 1.0) / float(iFrame - start_frame) + texture(iChannel0, fragCoord.xy/iResolution.xy) * (1. - 1. / float(iFrame - start_frame));\n    fragColor.r = min(.99, max(.01, fragColor.r));\n    fragColor.g = min(.99, max(.01, fragColor.g));\n    fragColor.b = min(.99, max(.01, fragColor.b));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl3Gz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[384, 384, 439, 439, 653]], "test": "untested"}
{"id": "Nl33zN", "name": "Xfer Records Serum Knob", "author": "Lastminute", "description": "https://xferrecords.com/products/serum", "tags": ["knob"], "likes": 13, "viewed": 594, "published": 3, "date": "1635772221", "time_retrieved": "2024-07-30T18:51:22.053089", "image_code": "precision lowp float;\n\n#define PI 3.1415926\n\nfloat box(vec2 p, vec2 a, vec2 b, float th)\n{\n\tfloat l = length(b - a);\n\tvec2  d = (b - a) / l;\n\tvec2  q = (p - (a + b) * 0.5);\n\tq = mat2(d.x, -d.y, d.y, d.x) * q;\n\tq = abs(q) - vec2(l,th) * 0.5;\n\treturn length(max(q, 0.0)) + min(max(q.x, q.y), 0.0);    \n}\n\nvec4 overlay(vec4 a, vec4 b)\n{\n\tfloat f = a.a + b.a * (1.0 - a.a);\n\treturn vec4((a.rgb * a.a + b.rgb * b.a * (1.0 - a.a)) / f, f);\n}\n\nmat2 rotate2d(float angle)\n{\n\treturn mat2(-cos(angle), sin(angle), -sin(angle), -cos(angle));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float aa = 1.0 / ((iResolution.x + iResolution.y) / 2.0);\n\tfloat range = 0.75;\n\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y * 1.25;\n\n\tfloat av = (1.0 - range) * PI + (iMouse.x / iResolution.x) * 2.0 * PI * range;\n\tfloat a = atan(uv.x, uv.y) - av;\n\tfloat a2 = fract((atan(uv.x, uv.y) + PI * 0.75) / (2.0 * PI));\n\tfloat a3 = fract((-atan(uv.x, uv.y) + PI * 0.75) / (2.0 * PI));\n\tfloat l = length(uv);\n\n\tfloat arc = smoothstep(a2 - aa, a2 + aa, 0.75) * smoothstep(l - aa, l + aa, 0.45);\n\tfloat arcb = (max(smoothstep(a3 - 0.005, a3 + 0.005, 0.75), 0.0) + max(smoothstep(a2 - 0.005, a2 + 0.005, 0.75), 0.0)) * smoothstep(l - 0.025, l + 0.025, 0.44) *0.5;\n\n\tvec4 colour = vec4(0.0);\n\n\tvec4 bg = vec4(mix(vec3(0.412,0.447,0.475), vec3(0.255,0.278,0.302), length(0.5 - uv.y / 2.0)), 1.0);\n\tvec4 outers = vec4(vec3(0.0), arcb);\n\tvec4 outer = vec4(vec3(0.49, 0.541, 0.576), arc);\n\tvec4 btm = vec4(vec3(0.137, 0.153, 0.165), smoothstep(l - aa, l + aa, 0.375));\n\tvec4 cs = vec4(vec3(0.0), smoothstep(l - 0.01, l + 0.01, 0.335) * 0.4);\n\tvec4 s = vec4(vec3(0.0), smoothstep(length(uv + vec2(0.0, 0.1)) - 0.2, length(uv + vec2(0.0, 0.1)) + 0.2, 0.3) * 0.9);\n\tvec3 capbg = mix(vec3(0.224, 0.243, 0.263), vec3(0.129,0.145,0.161), length(0.5 - uv.y));\n\tvec4 cbtm = vec4(capbg, smoothstep(l - aa, l + aa, 0.3));\n\tvec4 cout = vec4(vec3(0.341, 0.376, 0.412), smoothstep(l - aa, l + aa, 0.275));\n\tvec3 captg = mix(vec3(0.271, 0.294, 0.314), vec3(0.188,0.208,0.227), length(0.5 - uv.y));\n\tvec4 capt = vec4(captg, smoothstep(l - aa, l + aa, 0.265));\n\tfloat ln = box(uv * rotate2d(av), vec2(0.0, 0.15), vec2(0.0, 0.2725), 0.05);\n\tfloat ln2 = box(uv * rotate2d(av), vec2(0.0, 0.3), vec2(0.0, 0.34), 0.05);\n\tfloat point1 = box(uv * rotate2d(PI), vec2(0.0, 0.46), vec2(0.0, 0.51), 0.05);\n\tfloat point2 = box(uv * rotate2d(PI + 0.73 * PI), vec2(0.0, 0.46), vec2(0.0, 0.51), 0.05);\n\tfloat point3 = box(uv * rotate2d(PI - 0.73 * PI), vec2(0.0, 0.46), vec2(0.0, 0.51), 0.05);\n\tvec3 pc = vec3(0.651, 0.694, 0.718);\n\tvec4 p1 = vec4(pc, smoothstep(point1 - aa, point1 + aa, 0.0));\n\tvec4 p2 = vec4(pc, smoothstep(point2 - aa, point2 + aa, 0.0));\n\tvec4 p3 = vec4(pc, smoothstep(point3 - aa, point3 + aa, 0.0));\n\tvec4 p1s = vec4(vec3(0.0), smoothstep(point1 - 0.015, point1 + 0.015, 0.0) * 0.5);\n\tvec4 p2s = vec4(vec3(0.0), smoothstep(point2 - 0.015, point2 + 0.015, 0.0) * 0.5);\n\tvec4 p3s = vec4(vec3(0.0), smoothstep(point3 - 0.015, point3 + 0.015, 0.0) * 0.5);\n\tvec4 lines = vec4(vec3(0.0), smoothstep(ln - 0.02, ln + 0.02, 0.0) * 0.5);\n\tvec4 line = vec4(vec3(1.0), smoothstep(ln - aa, ln + aa, 0.0));\n\tvec4 lineb = vec4(vec3(0.024, 0.514, 0.765), smoothstep(ln2 - aa, ln2 + aa, 0.0));\n\n\tcolour = overlay(bg, colour);\n\tcolour = overlay(p1s, colour);\n\tcolour = overlay(p2s, colour);\n\tcolour = overlay(p3s, colour);\n\tcolour = overlay(p1, colour);\n\tcolour = overlay(p2, colour);\n\tcolour = overlay(p3, colour);\n\tcolour = overlay(outers, colour);\n\tcolour = overlay(outer, colour);\n\tcolour = overlay(btm, colour);\n\tcolour = overlay(cs, colour);\n\tcolour = overlay(s, colour);\n\tcolour = overlay(cbtm, colour);\n\tcolour = overlay(cout, colour);\n\tcolour = overlay(capt, colour);\n\tcolour = overlay(lines, colour);\n\tcolour = overlay(line, colour);\n\tcolour = overlay(lineb, colour);\n\n\tfragColor =  colour;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl33zN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 90, 90, 301], [303, 303, 333, 333, 435], [437, 437, 465, 465, 532], [534, 534, 589, 589, 3877]], "test": "untested"}
{"id": "Nt33zN", "name": " Pulsating Volumetric Star", "author": "LongJohnny", "description": "A pulsating volumtric star using a 3D texture that is sampled with scaled texture coords. ", "tags": ["noise", "pulse", "star", "volumetric"], "likes": 4, "viewed": 278, "published": 3, "date": "1635770386", "time_retrieved": "2024-07-30T18:51:22.994571", "image_code": "// A pulsating volumetric star using a 3D texture \n// that is sampled with scaled texture coords\n//\n// Below are some settings that can be used to \n// alter the shape of the star\n//\n// CONTROLS:\n// - Mouse to rotate the star\n// \n// The background stars were taken from duke:\n// https://www.shadertoy.com/view/MdtGRl\n// ----------------------------------------\n\n// DEMO SETTINGS (FEEL FREE TO CHANGE)\n#define ROTATION_SPEED .2\n#define PULSE_SPEED .3\n#define DENSITY .4\n#define INTENSITY 4.\n#define PULSE\n#define RADIUS 2.3\n\n// RAY MARCHING SETTINGS (DO NOT CHANGE)\n#define MAX_MARCH_STEPS 10\n#define MAX_MARCH_DIST 10.\n#define MIN_MARCH_DIST 0.01\n\nfloat sdScene(vec3 p);\n\n// iq's noise\nfloat pn( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel1, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn -1.0+2.27*mix( rg.x, rg.y, f.z );\n}\n\n// duke's stars\nvec3 stars(vec3 rd) {\n    vec3 stars = vec3(pn(rd*100.0)*0.4+0.5);\n    vec3 starbg = vec3(0.0);\n    starbg = mix(starbg, \n        vec3(0.8,0.9,1.0), \n        smoothstep(0.99, 1.0, stars)\n        *clamp(dot(vec3(0.0),rd)+0.75,0.0,1.0));\n        starbg = clamp(starbg, 0.0, 1.0);\n    return starbg;\n}\n\nfloat density(vec3 p) {\n    \n#ifdef PULSE\n    float pulse = cos(iTime * PULSE_SPEED);\n#else\n    float pulse = 1.;\n#endif\n    vec3 noiseOffset = vec3(0.);\n    return .023 * abs(pulse) * texture(iChannel0, (p + noiseOffset) * pulse * DENSITY).r;\n}\n\nvec3 rayMarchDensity(vec3 ro, vec3 rd, float d, vec3 backgroundColor) {\n\n    float accum = 0.; \n    \n    for (int i = 0; i < 100; ++i) {\n        \n        d += 0.04;\n        \n        vec3 p = ro + rd*d;\n        \n        float ds = sdScene(p);\n        \n        accum += density(p);\n           \n        // Continue marching while distance is negative\n        // i.e. while we are still inside the shape\n        // Or when the density cannot be any larger\n        if(ds > 0.0001f || accum > 0.99f) break;\n    }\n    \n    vec3 color = vec3(\n    accum * INTENSITY,\n    pow(accum, 12.) * INTENSITY, \n    accum > .99 ? INTENSITY : 0.);\n    \n    return mix(backgroundColor, color, pow(accum,8.));\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    \n    float d;\n    \n    for (int i = 0; i < MAX_MARCH_STEPS; ++i) {\n        \n        vec3 p = ro + rd*d;\n        \n        float ds = sdScene(p);\n           \n        if(ds > MAX_MARCH_DIST || abs(ds) < MIN_MARCH_DIST) break;\n        \n        d += ds;\n    }\n    \n    return d;\n}\n\nfloat sdScene(vec3 p) {\n    return sdSphere(p, RADIUS);\n}\n\nvec3 addMouseControl(vec3 ro) {\n    vec2 m = iMouse.xy/iResolution.xy;\n    ro.yz *= rot(-m.y*3.14+1.);\n    ro.xz *= rot(-m.x*6.2831);\n    return ro;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // From [-1, 1]\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    \n    vec3 origin = vec3(0.);\n    \n    // Camera rotation\n    float rotationRadius = 3.5;\n    vec3 ro = vec3(\n        rotationRadius * sin(iTime * ROTATION_SPEED), \n        0.f, \n        -rotationRadius * cos(iTime * ROTATION_SPEED));\n    ro = addMouseControl(ro);\n\n    vec3 rd = rayDir(ro, origin, uv); \n    \n    // Raymarching to find surface\n    float d = rayMarch(ro, rd); \n    \n    // Background color using duke's stars\n    vec3 col = stars(rd); \n    if (d < MAX_MARCH_DIST) {\n        \n        // Raymarching within shape\n        col = rayMarchDensity(ro, rd, d, col);\n    } \n    \n    // Tone Mapping \n    //col = acesFilmTonemapping(col);\n    //col = reinhardTonemapping(col);\n    \n    // Gamma correct ^(1/2.2)\n    col = pow(col, vec3(.4545));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec3 rayDir(vec3 ro, vec3 origin, vec2 uv) {\n    \n    vec3 d = normalize(origin - ro);\n    \n    vec3 r = normalize(cross(vec3(0.,1.,0.), d));\n    vec3 u = cross(d, r);\n    \n    return normalize(d + r*uv.x + u*uv.y); \n}\n\nmat2 rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nfloat smin(float a, float b, float k) {\n    \n    /*float h = max(0., min(1., (b - a)/k + .5));\n    float m = h * (1. - h) * k;\n       \n    return a * k + b * (1. - k) - m * .5;*/\n    \n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n// ACES Tonemapping found here: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n// Note: Oversaturates brights. For more realistic rendering use: https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\nvec3 acesFilmTonemapping(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    \n    vec3 color = (x*(a*x+b))/(x*(c*x+d)+e); \n    return clamp(color,0.0,1.0);\n}\n\nvec3 reinhardTonemapping(vec3 color) {\n    return color = color / (color + vec3(1.0));\n}\n\n/* ----- Distance functions ---------- */\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n\n\n\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt33zN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[671, 685, 708, 708, 927], [929, 945, 966, 966, 1243], [1245, 1245, 1268, 1268, 1490], [1492, 1492, 1563, 1563, 2180], [2182, 2182, 2216, 2216, 2496], [2498, 2498, 2521, 2521, 2555], [2557, 2557, 2588, 2588, 2707], [2709, 2709, 2766, 2786, 3664]], "test": "untested"}
{"id": "NtcGzN", "name": "Trojan Code", "author": "mla", "description": "An interesting use of Unicode: [url]https://www.trojansource.codes[/url]\n\nCursor movement & highlighting show that something is up.", "tags": ["code", "trojan"], "likes": 4, "viewed": 199, "published": 3, "date": "1635770273", "time_retrieved": "2024-07-30T18:51:23.838316", "image_code": "bool admin = false;\nbool isadmin() {\n  /*‮} ⁦ if (admin)⁩⁦ admins only */\n    return true;\n  /* end admins only‮ { ⁦ */\n  return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  fragColor = vec4(isadmin(),0,0,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtcGzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 36, 81, 149], [151, 151, 208, 208, 247]], "test": "untested"}
{"id": "std3zH", "name": "Ternary bug", "author": "davidar", "description": "In theory this whole shader should be white, but a bug with the ternary operator causes the left side to be black on my Radeon RX 580 (Windows 10: Firefox, Chrome, and Edge).\n\nPlease comment with your OS/GPU/browser if you also see black on the left.\n", "tags": ["test", "bug"], "likes": 1, "viewed": 307, "published": 3, "date": "1635749005", "time_retrieved": "2024-07-30T18:51:24.722951", "image_code": "            // NB: cond always true but optimizer doesn't know\n#define THEN ( ( iTime >= 0. ? a = 0. : a = 0. ), i++, x++ )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float i = 0., x = 0., a;\n    \n    if (U.x < iResolution.x/2. )       // left: black when bugged\n    {\n           (i == 0.) ? THEN : 0.;\n    } else                             // right: white, for reference \n    {\n        if (i == 0.)   THEN;\n    }\n    \n    O = vec4(x);\n    //O = vec4(i);           //  no bug if output i instead of x\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/std3zH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 125, 163, 163, 504]], "test": "untested"}
{"id": "std3RH", "name": "LCARS Display", "author": "Xibanya", "description": "Took a shot at recreating a HUD in the style of The Next Generation's distinctive Okudagrams", "tags": ["startrek", "lcars", "tng", "thenextgeneration", "okudagram"], "likes": 14, "viewed": 579, "published": 3, "date": "1635740946", "time_retrieved": "2024-07-30T18:51:25.579660", "image_code": "#define ORANGE vec4(1.0, 0.6, 0.0, 0.0)\n#define LILAC vec4(0.6, 0.6, 1.0, 0.0)\n#define CORAL vec4(0.8, 0.4, 0.4, 0.0)\n#define PEACH vec4(1.0, 0.6, 0.4, 0.0)\n#define CREAM vec4(1.0, 0.8, 0.6, 0.0)\n#define PINK vec4(0.8, 0.6, 0.8, 0.0)\n#define BLACK vec4(0.0)\n\n//https://www.shadertoy.com/view/XtfyRS\nfloat GlyphSDF(vec2 p, float char)\n{\n    // Convert glyph to appropriate char index in the char texture and compute distance to it\n\tp = abs(p.x - .5) > .5 || abs(p.y - .5) > .5 ? vec2(0.) : p;\n\treturn 2. * (texture(iChannel0, p / 16. + fract(vec2(char, 15. - floor(char / 16.)) / 16.)).w - 127. / 255.);\n}\n#define INIT_TEXT float glyphRatio = 2.0; \\\n    vec2 glyphScale = 6. * vec2(1., glyphRatio); \\\n    vec2 t = floor(p / glyphScale + 1e-6); \\\n    uint v = 0u\n#define WRITE_TEXT float char = float((v >> uint(8. * t.x)) & 255u); \\\n    vec2 posInCell = (p - t * glyphScale) / glyphScale; \\\n    posInCell.x = (posInCell.x - .5) / glyphRatio + .5; \\\n    float sdf = GlyphSDF(posInCell, char) - 0.03; \\\n    if (char != 0.) color = mix(textColor, color, smoothstep(-.02, +.03, sdf))\n\nvoid TextLCARSACCESS(inout vec3 color, vec3 textColor, vec2 p)\n{\n\tINIT_TEXT;\n    v = t.y == 0. ? ( t.x < 4. ? 1380008780u : ( t.x < 8. ? 1128341587u : ( t.x < 12. ? 1397966147u : 825504800u ) ) ) : v;\n\tv = t.x >= 0. && t.x < 16. ? v : 0u;\n    WRITE_TEXT;\n}\nvoid TextLCARS4(inout vec3 color, vec3 textColor, vec2 p)\n{\n\tINIT_TEXT;\n\tv = t.y == 0. ? ( t.x < 4. ? 1380008780u : ( t.x < 8. ? 808722515u : 3422002u ) ) : v;\n\tv = t.x >= 0. && t.x < 12. ? v : 0u;\n    WRITE_TEXT;\n}\nvoid Text3(inout vec3 color, vec3 textColor, vec2 p)\n{\n\tINIT_TEXT;\n\tv = t.y == 0. ? ( t.x < 4. ? 959263536u : ( t.x < 8. ? 943076663u : 51u ) ) : v;\n\tv = t.x >= 0. && t.x < 12. ? v : 0u;\n    WRITE_TEXT;\n}\nvoid Text4(inout vec3 color, vec3 textColor, vec2 p)\n{\n\tINIT_TEXT;\n\tv = t.y == 0. ? ( t.x < 4. ? 925709360u : ( t.x < 8. ? 909391158u : 54u ) ) : v;\n\tv = t.x >= 0. && t.x < 12. ? v : 0u;\n    WRITE_TEXT;\n}\nvoid Text5(inout vec3 color, vec3 textColor, vec2 p)\n{\n\tINIT_TEXT;\n    v = t.y == 0. ? ( t.x < 4. ? 841823536u : ( t.x < 8. ? 892548146u : 51u ) ) : v;\n\tv = t.x >= 0. && t.x < 12. ? v : 0u;\n    WRITE_TEXT;\n}\nvoid Text6(inout vec3 color, vec3 textColor, vec2 p)\n{\n\tINIT_TEXT;\n    v = t.y == 0. ? ( t.x < 4. ? 892155440u : ( t.x < 8. ? 909456951u : 53u ) ) : v;\n\tv = t.x >= 0. && t.x < 12. ? v : 0u;\n    WRITE_TEXT;\n}\nvoid TextB(inout vec3 color, vec3 textColor, vec2 p)\n{\n\tINIT_TEXT;\n\tv = t.y == 2. ? ( t.x < 4. ? 909654073u : ( t.x < 8. ? 875770413u : ( t.x < 12. ? 538976288u : ( t.x < 16. ? 538976288u : ( t.x < 20. ? 538976288u : ( t.x < 24. ? 538976288u : ( t.x < 28. ? 942813488u : 959852589u ) ) ) ) ) ) ) : v;\n\tv = t.y == 1. ? 0u : v;\n\tv = t.y == 0. ? ( t.x < 4. ? 875638833u : ( t.x < 8. ? 959526957u : ( t.x < 12. ? 538976288u : ( t.x < 16. ? 538976288u : ( t.x < 20. ? 538976288u : ( t.x < 24. ? 538976288u : ( t.x < 28. ? 842215991u : 942880813u ) ) ) ) ) ) ) : v;\n\tv = t.x >= 0. && t.x < 32. ? v : 0u;\n    WRITE_TEXT;\n}\nvoid TextNumbers(inout vec3 color, vec3 textColor, vec2 p)\n{\n\tINIT_TEXT;\n    v = t.y == 4. ? ( t.x < 4. ? 892875570u : ( t.x < 8. ? 941629472u : ( t.x < 12. ? 842544949u : ( t.x < 16. ? 958411315u : ( t.x < 20. ? 943207200u : ( t.x < 24. ? 943005746u : ( t.x < 28. ? 958411577u : 3487800u ) ) ) ) ) ) ) : v;\n\tv = t.y == 3. ? ( t.x < 4. ? 875966514u : ( t.x < 8. ? 840966176u : ( t.x < 12. ? 959723056u : ( t.x < 16. ? 924856886u : ( t.x < 20. ? 926365984u : ( t.x < 24. ? 908075062u : ( t.x < 28. ? 824194610u : 3290679u ) ) ) ) ) ) ) : v;\n\tv = t.y == 2. ? ( t.x < 4. ? 875765792u : ( t.x < 8. ? 538976288u : ( t.x < 12. ? 840966176u : ( t.x < 16. ? 538982711u : ( t.x < 20. ? 941629472u : ( t.x < 24. ? 892739641u : ( t.x < 28. ? 908081464u : 3617845u ) ) ) ) ) ) ) : v;\n\tv = t.y == 1. ? ( t.x < 4. ? 943077172u : ( t.x < 8. ? 941629472u : ( t.x < 12. ? 842479161u : ( t.x < 16. ? 924858420u : ( t.x < 20. ? 959920416u : ( t.x < 24. ? 959979576u : ( t.x < 28. ? 538982710u : 3553076u ) ) ) ) ) ) ) : v;\n\tv = t.y == 0. ? ( t.x < 4. ? 892876320u : ( t.x < 8. ? 538976288u : ( t.x < 12. ? 875765792u : ( t.x < 16. ? 941635639u : ( t.x < 20. ? 909647904u : ( t.x < 24. ? 857743415u : ( t.x < 28. ? 538981940u : 3420960u ) ) ) ) ) ) ) : v;\n\tv = t.x >= 0. && t.x < 32. ? v : 0u;\n    WRITE_TEXT;\n}\n\n// all sdf functions from iq\n// https://iquilezles.org/articles/distfunctions\nvec2 opRepLim( in vec2 p, in vec2 s, in vec2 lima, in vec2 limb )\n{\n    return p-s*clamp(round(p/s),lima,limb);\n}\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat sdRoundBox( in vec2 p, in vec2 b, in vec4 r ) \n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\nfloat sinc( float x, float k )\n{\n    float a = 3.14 * (k * x - 1.0);\n    return sin(a)/a;\n}\n\n//// LCARS Functions\nfloat MStep(float d)\n{\n    return 1. - smoothstep(-0.005, 0.0, d);\n}\nfloat Margin(float sdf)\n{\n    return clamp(1. - smoothstep(0.01, 0.015, abs(sdf)), 0.0, 1.0);\n}\nfloat MarginSm(float sdf)\n{\n    return clamp(1. - smoothstep(0.005, 0.01, abs(sdf)), 0.0, 1.0);\n}\nvoid Outline(float d, inout vec4 col, vec4 mixCol)\n{\n    vec4 c = mix(mixCol, BLACK, Margin(d));\n    col = mix(col, c, MStep(d));\n}\nfloat Panel(vec2 uv, vec2 f, out vec4 boxCol)\n{\n    const vec4 RED = vec4(1., 0., 0., 0.);\n    const vec4 GREEN = vec4(0.0, 1.0, 0.0, 0.0);\n    const vec4 BLUE = vec4(0.0, 0.0, 1.0, 0.0);\n    const vec4 ALPHA = vec4(0.0, 0.0, 0.0, 1.0);\n    vec2 boxSize = vec2(1.5, 1.);\n    float box = sdRoundBox(uv, boxSize, vec4(0.35));\n    boxCol = RED;\n    float seg = sdBox(uv + vec2(.1, -0.35) * f, vec2(1.7, 0.3));\n    Outline(seg, boxCol, RED);\n\n    boxCol = mix(boxCol, GREEN, step(uv.y, 0.15 * f.y));\n    seg = sdBox(uv + vec2(0., -.15) * f, vec2(1.5, 0.1));\n    Outline(seg, boxCol, BLUE);\n\n    seg = sdBox(uv + vec2(-0.1, 0.) * sign(f), vec2(0.075, 2.));\n    Outline(seg, boxCol, ALPHA);\n\n    uv += vec2(-0.4, 0.075) * sign(f);\n    float innerBox = sdRoundBox(uv, boxSize, vec4(0.1));\n    box = max(box, -innerBox);\n    boxCol = mix(boxCol, BLACK, Margin(box));\n    return box;\n}\nvoid DoText(vec2 p, inout vec4 col)\n{\n    vec2 tUV = p * vec2(100., 50.) - vec2(0., 32.);\n    TextLCARSACCESS(col.rgb, ORANGE.rgb, tUV);\n    tUV = p * vec2(275., 150.) - vec2(-245., 110.);\n    TextLCARS4(col.rgb, BLACK.rgb, tUV);\n    tUV.y += 125.;\n    Text3(col.rgb, BLACK.rgb, tUV);\n    tUV.y += 59.;\n    Text4(col.rgb, BLACK.rgb, tUV);\n    tUV.y += 29.;\n    Text5(col.rgb, BLACK.rgb, tUV);\n    tUV.y += 15.;\n    Text6(col.rgb, BLACK.rgb, tUV);\n    tUV = p * vec2(270., 140.) - vec2(90., 50.);\n    TextB(col.rgb, BLACK.rgb, tUV);\n    tUV *= 1.3;\n    tUV += vec2(290., 5.);\n    TextNumbers(col.rgb, ORANGE.rgb, tUV);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (1.3 * fragCoord-iResolution.xy)/iResolution.y;\n    // this looked different when I was previewing it in my IDE\n    // adjusting aspect here to look good on shadertoy\n    p += vec2(0.7, 0.4);\n    p.y *= 1.3;\n    vec2 boxPos = p + vec2(-0.5, .75);\n    vec4 boxCol = CORAL;\n    vec2 f = vec2(1.);\n    // main panel\n    float box = Panel(boxPos, f, boxCol);\n    vec4 col1 = boxCol.r * CORAL + boxCol.g * PEACH + \n        boxCol.b * ORANGE + boxCol.a * CREAM;\n    vec4 col = mix(BLACK, col1, MStep(box));\n    // mirror flipped panel\n    boxPos = p - vec2(0.5, 1.25);\n    f = vec2(1., -2.);\n    box = Panel(boxPos, f, boxCol);\n    vec4 col2 = boxCol.r * ORANGE + boxCol.g * LILAC + \n        boxCol.b * PINK + boxCol.a * ORANGE;\n    col = mix(col, col2, MStep(box));\n\n    // pills\n    vec2 q = p * 9.0 - vec2(8.0, 2.2);\n    vec2 r = opRepLim(q, vec2(4.75, 1.6), vec2(-1, 1.), vec2(1,2));\n    float d = sdBox( r, vec2(1.5, 0.0001) ) -  0.65;\n    vec4 pillCol = LILAC;\n    float peach = min(step(0.625, p.x), step(0.51, p.y));\n    pillCol = mix(pillCol, PEACH, peach);\n    float orange = min(step(p.x, 0.625), step(p.y, 0.51));\n    pillCol = mix(pillCol, ORANGE, orange);\n    col = mix(col, pillCol, 1. - smoothstep(-0.05, .0, d));\n\n    // center diagram\n    vec4 mCol = PEACH;\n    vec2 mPos = p + vec2(-0.25, 0.3);\n    vec2 mSize = vec2(0.6, 0.4); \n    float midBox = sdRoundBox(mPos, mSize, vec4(0.1));\n    float subMid = sdRoundBox(mPos, mSize * vec2(0.9, 0.925), vec4(0.05));\n    subMid = min(subMid, \n        sdBox(mPos, mSize * vec2(0.8, 1.5)));\n    midBox = max(midBox, -subMid);\n    float cB1 = sdBox(mPos + vec2(0., 0.), vec2(1.5, 0.2));\n    vec4 cB1Col = mix(CORAL, BLACK, MarginSm(cB1));\n    mCol = mix(mCol, cB1Col, MStep(cB1));\n    float mAccent = sdBox(mPos + vec2(-0.4, 0.05), vec2(0.25, .1));\n    vec4 aCol = mix(CREAM, BLACK, MarginSm(mAccent));\n    mCol = mix(mCol, aCol, MStep(mAccent));\n    col = mix(col, mCol, MStep(midBox));\n    \n    // y axis ruler things\n    vec2 rulerOffset = vec2(0.6, 0.0);\n    float ruler = sdBox(mPos + rulerOffset, vec2(0.03, 0.3));\n    rulerOffset.x = abs(rulerOffset.x);\n    rulerOffset.x -= 1.2;\n    ruler = min(ruler, sdBox(mPos + rulerOffset, vec2(0.03, 0.3)));\n    vec2 rUV = p * 9.0 - vec2(6.8, -5.1);\n    rUV = opRepLim(rUV, vec2(1., .4), vec2(1., .0), vec2(1., 12.));\n    float lines = sdBox(rUV, vec2(.2, .15));\n    rUV = p * 9.0 - vec2(-4.3, -5.1);\n    rUV = opRepLim(rUV, vec2(1., .4), vec2(1., .0), vec2(1., 12.));\n    lines = min(lines, sdBox(rUV, vec2(.2, .15)));\n    lines = max(lines, -midBox);\n    vec4 rulerCol = mix(ORANGE, BLACK, MarginSm(ruler));\n    // subtract the ruler lines after doing the outline so that they don't\n    // get included in the outline and mess up the edge being flush\n    // with the larger box\n    ruler = max(ruler, -lines);\n    col = mix(col, rulerCol, MStep(ruler));\n\n    // the bobbing marker things\n    float minY = 7.;\n    float maxY = -7.;\n    float mY = mix(minY, maxY, \n        sinc(sin(iTime + 0.001 + iMouse.y * 0.01), 1.) * 0.5 + 0.25);\n    vec2 offset = vec2(14., mY);\n    float marker = sdRoundBox(mPos * 30. + offset, \n        vec2(2., 0.75), vec4(2.));\n    mY = mix(minY, maxY, \n        sinc(sin(iTime * 1.2 + 0.5 + iMouse.x * 0.01), 1.1) * 0.5 + 0.25);\n    offset = vec2(-14., mY);\n    marker = min(marker, sdRoundBox(mPos * 30. + offset, \n        vec2(2., 0.75), vec4(2.)));\n    col = mix(col, CREAM * 1.25, 1. - smoothstep(-0.005, 0., marker));\n\n    DoText(p, col);\n\tfragColor = vec4(col.rgb, 1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/std3RH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[259, 299, 335, 429, 604], [1080, 1080, 1144, 1144, 1336], [1337, 1337, 1396, 1396, 1552], [1553, 1553, 1607, 1607, 1757], [1758, 1758, 1812, 1812, 1962], [1963, 1963, 2017, 2017, 2170], [2171, 2171, 2225, 2225, 2378], [2379, 2379, 2433, 2433, 2994], [2995, 2995, 3055, 3055, 4286], [4288, 4366, 4433, 4433, 4479], [4480, 4480, 4517, 4517, 4597], [4598, 4598, 4652, 4652, 4809], [4810, 4810, 4842, 4842, 4901], [4903, 4924, 4946, 4946, 4992], [4993, 4993, 5018, 5018, 5088], [5089, 5089, 5116, 5116, 5186], [5187, 5187, 5239, 5239, 5318], [5319, 5319, 5366, 5366, 6195], [6196, 6196, 6233, 6233, 6815], [6816, 6816, 6873, 6873, 10388]], "test": "untested"}
{"id": "slt3z8", "name": "fake arcade crossbow", "author": "jorge2017a2", "description": "fake arcade crossbow", "tags": ["fakearcadecrossbow"], "likes": 15, "viewed": 265, "published": 3, "date": "1635731593", "time_retrieved": "2024-07-30T18:51:26.624865", "image_code": "///fake arcade crossbow-JFP\n///por jorge2017a2...2021-oct-09\n///referencia\n//https://iquilezles.org/articles/distfunctions2d\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.05),b,d)\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj,0.0)); return colOut;}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{  vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec2 p, float r )\n{  return length(p) - r;}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{  p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n\nfloat sdParallelogram( in vec2 p, float wi, float he, float sk )\n{  vec2 e = vec2(sk,he);\n    p = (p.y<0.0)?-p:p;\n    vec2  w = p - e; w.x -= clamp(w.x,-wi,wi);\n    vec2  d = vec2(dot(w,w), -w.y);\n    float s = p.x*e.y - p.y*e.x;\n    p = (s<0.0)?-p:p;\n    vec2  v = p - vec2(wi,0); v -= e*clamp(dot(v,e)/dot(e,e),-1.0,1.0);\n    d = min( d, vec2(dot(v,v), wi*he-abs(s)));\n    return sqrt(d.x)*sign(-d.y);\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\n\nvec3 Suelo1(vec2 p, vec3 col)\n{  \n    col=DrawFig(VERDE0, col, p.y-2.5 );\n return col;\n}\n\nvec3 banqueta(vec2 p, vec3 col)\n{\n    float d1=sdParallelogram( p-vec2(-6.0,-2.5), 10.0, 2.0, 2.5 );\n    float d2=sdParallelogram( p-vec2(-5.8,-2.9), 10.0, 2.0, 2.5 );\n    float d3=sdBox(p-vec2(-8.5,-4.7), vec2(7.0+3.,0.25) );\n    float d4=sdParallelogram( p.yx-vec2(-2.7,1.1+3.0), 0.27, 2.5, 2.0 );\n    \n    col= DrawFigBorde(CAFE3,col, d2 );\n    col= DrawFigBorde(CAFE3,col, d1 );\n    col= DrawFigBorde(NEGRO,col, d3 );\n    col= DrawFigBorde(NEGRO,col, d4 );\n    return col;\n}\n\nvec3 banquetaG(vec2 p, vec3 col)\n{   float alto=1.0;\n    float d1=sdParallelogram( p-vec2(-6.0,-2.5), 15.0, 2.0+alto, 2.5+alto );\n    float d2=sdParallelogram( p-vec2(-5.8,-2.9), 15.0, 2.0+alto, 2.5 +alto);\n    float d3=sdBox(p-vec2(-9.5,-5.7), vec2(7.0+8.0,0.25) );\n    float d4=sdParallelogram( p.yx-vec2(-2.7,1.1+8.0), 0.27, 2.5+alto, 2.0 +alto);\n    col= DrawFigBorde(CAFE3,col, d2 );\n    col= DrawFigBorde(CAFE3,col, d1 );\n    col= DrawFigBorde(NEGRO,col, d3 );\n    col= DrawFigBorde(NEGRO,col, d4 );\n    return col;\n}\n\n\nvec3 ParedCasa01(vec2 p, vec3 col)\n{\n   float d1=sdBox(p, vec2(4.0,1.25) );\n    vec2 p1, p2;\n    p1=p;\n    p2=p-vec2(0.7,0.6);\n    p1.x= opRep1D(p1.x, 1.2);\n    p1.y= opRep1D(p1.y, 1.2);\n    p2.x= opRep1D(p2.x, 1.2);\n    p2.y= opRep1D(p2.y, 1.2);\n    float d2=sdBox(p1, vec2(0.5,0.25) );\n    float d3=sdBox(p2, vec2(0.5,0.25) );\n    float dif=differenceSDF(d1,d2);\n     dif=differenceSDF(dif,d3);\n    col= DrawFig(VERDE3, col, d1);\n    col= DrawFig(VERDE4, col, dif);\n    \n    return col;\n}\n\nvec3 Casa01(vec2 p, vec3 col)\n{\n    col= ParedCasa01( p,col);\n    float d1=sdBox(p-vec2(0.0,1.4), vec2(4.0,0.15) );\n    col= DrawFig(CAFE2, col, d1);\n    col= ParedCasa01(p-vec2(0.0,2.8),col);\n    \n    float d2=sdBox(p-vec2(0.0,2.5), vec2(1.0,1.0));\n    col=DrawFigBordeCol(FVENTANA2, col, d2, CAFE2);\n    \n    //pared lateral\n    float d3= sdParallelogram(p.yx-vec2(2.2,5.2), 2.7, 1.5-0.2, 1.0-0.2 );\n    //col= DrawFig(VERDE5, col, d3);\n    \n    vec2 p1=p;\n    p1=rotatev2(p1-vec2(5.25,4.9), radians(60.0));\n    float dr1= sdRhombus(  p1, vec2(1.5,1.5) );\n    \n    d3= unionSDF(d3, dr1);\n    col= DrawFig(VERDE5, col, d3);\n    \n    \n    //techo\n    float d4= sdParallelogram(p-vec2(0.3,5.0), 4.2, 1.0, 0.5 );\n    col= DrawFig(VERDE4, col, d4);\n    //ventana lateral\n    float d5= sdParallelogram(p.yx-vec2(2.2,4.6), 1.0, 0.5-0.2, 0.35-0.2 );\n    col= DrawFigBordeCol(FVENTANA2, col, d5,CAFE2);\n    //ventana lateral\n    float d6= sdParallelogram(p.yx-vec2(2.8,6.0), 1.0, 0.5-0.2, 0.35-0.2 );\n    col= DrawFigBordeCol(FVENTANA2, col, d6,CAFE2);\n    \n    \n    return col;\n}\n\nvec3 Casa02(vec2 p, vec3 col)\n{\n    col= ParedCasa01( p,col);\n    float d1=sdBox(p-vec2(0.0,1.4), vec2(4.0,0.15) );\n    col= DrawFig(CAFE2, col, d1);\n    col= ParedCasa01(p-vec2(0.0,2.8),col);\n    \n    float d2=sdBox(p-vec2(0.0,2.5), vec2(1.0,1.0));\n    col=DrawFigBordeCol(FVENTANA2, col, d2, CAFE2);\n    \n    //pared lateral\n    float d3= sdParallelogram(p.yx-vec2(2.2,5.2), 2.7, 1.5-0.2, 1.0-0.2 );\n    \n    vec2 p1=p;\n    p1=rotatev2(p1-vec2(5.25,4.9), radians(60.0));\n    float dr1= sdRhombus(  p1, vec2(1.5,1.5) );\n    d3= unionSDF(d3, dr1);\n    col= DrawFig(VERDE5, col, d3);\n    \n    \n     p1=p;\n    p1.x= opRep1D(p1.x, 1.2);\n    p1.y= opRep1D(p1.y, 0.6);\n    //lineas techo\n    float d4a=sdBox(p1, vec2(4.0,0.10));\n    \n    //techo\n    \n    float d4= sdParallelogram(p-vec2(0.3,5.1), 4.2, 1.1, 0.5 );\n    d4a=intersectSDF(d4a, d4);\n    col= DrawFig(VERDE4, col, d4);\n    col= DrawFig(NEGRO, col, d4a);\n    \n    //ventana lateral\n    float d5= sdParallelogram(p.yx-vec2(2.2,4.6), 1.0, 0.5-0.2, 0.35-0.2 );\n    col= DrawFigBordeCol(FVENTANA2, col, d5,CAFE2);\n    //ventana lateral\n    float d6= sdParallelogram(p.yx-vec2(2.8,6.0), 1.0, 0.5-0.2, 0.35-0.2 );\n    col= DrawFigBordeCol(FVENTANA2, col, d6,CAFE2);\n    \n    \n    return col;\n}\n\nvec3 Casa03(vec2 p, vec3 col)\n{\n    float d10=sdBox(p, vec2(4.0,1.25) );\n    col= DrawFig(VERDE5P, col, d10); \n    \n    float d1=sdBox(p-vec2(0.0,1.4), vec2(4.0,0.15) );\n    col= DrawFig(CAFE2, col, d1);\n    \n    float d11=sdBox(p-vec2(0.0,2.8), vec2(4.0,1.25) );\n    col= DrawFig(VERDE5P, col, d11); \n    \n    float d2=sdBox(p-vec2(0.0,2.5), vec2(1.0,1.0));\n    col=DrawFigBordeCol(FVENTANA2, col, d2, CAFE2);\n    \n    float d2a=sdBox(p-vec2(-2.5,2.5), vec2(1.0,1.0));\n    col=DrawFigBordeCol(FVENTANA2, col, d2a, CAFE2);\n    \n    float d2b=sdBox(p-vec2(2.5,2.5), vec2(1.0,1.0));\n    col=DrawFigBordeCol(FVENTANA2, col, d2b, CAFE2);\n    \n    \n    //pared lateral\n    float d3= sdParallelogram(p.yx-vec2(2.3,5.2), 2.7, 1.5-0.2, 1.3-0.2 );\n    vec2 p1=p;\n    p1=rotatev2(p1-vec2(5.25,5.2), radians(55.0));\n    float dr1= sdRhombus(  p1, vec2(1.7,1.5) );\n    d3= unionSDF(d3, dr1);\n    col= DrawFig(VERDE5, col, d3);\n    \n    \n     p1=p;\n    p1.x= opRep1D(p1.x, 1.2);\n    p1.y= opRep1D(p1.y, 0.6);\n    //lineas techo\n    float d4a=sdBox(p1, vec2(4.0,0.10));\n    \n    //techo\n    float d4= sdParallelogram(p-vec2(0.3,5.25), 4.2, 1.3, 0.5 );\n    d4a=intersectSDF(d4a, d4);\n    col= DrawFig(VERDE4, col, d4);\n    col= DrawFig(NEGRO, col, d4a);\n    \n    //ventana lateral\n    float d5= sdParallelogram(p.yx-vec2(2.2,4.6), 1.2, 0.5-0.2, 0.35-0.2 );\n    col= DrawFigBordeCol(FVENTANA2, col, d5,CAFE2);\n    //ventana lateral\n    float d6= sdParallelogram(p.yx-vec2(2.8,5.8), 1.2, 0.5-0.2, 0.4-0.2 );\n    col= DrawFigBordeCol(FVENTANA2, col, d6,CAFE2);\n    \n    \n    return col;\n}\n\n\nvec3 ParedCasa02Ch(vec2 p, vec3 col)\n{\n   float d1=sdBox(p, vec2(4.0,2.0) );\n    vec2 p1, p2;\n    p1=p;\n    p2=p-vec2(0.7,0.6);\n    float alto=1.2;\n    float ancho=1.2;\n    p1.x= opRep1D(p1.x, ancho);\n    p1.y= opRep1D(p1.y, alto);\n    p2.x= opRep1D(p2.x, ancho);\n    p2.y= opRep1D(p2.y, alto);\n    \n    float d2=sdBox(p1, vec2(0.5,0.23) );\n    float d3=sdBox(p2, vec2(0.5,0.23) );\n    float dif=differenceSDF(d1,d2);\n     dif=differenceSDF(dif,d3);\n    col= DrawFig(CASA5, col, d1);\n    col= DrawFig(CASA4, col, dif);\n    \n    return col;\n}\n\n\nvec3 ParedDif(float dist, vec2 p, vec3 col, vec3 col1,vec3 col2)\n{\n    float d1=dist;\n    vec2 p1, p2;\n    p1=p;\n    p2=p-vec2(0.7,0.6);\n    float alto=1.2;\n    float ancho=1.2;\n    p1.x= opRep1D(p1.x, ancho);\n    p1.y= opRep1D(p1.y, alto);\n    p2.x= opRep1D(p2.x, ancho);\n    p2.y= opRep1D(p2.y, alto);\n    \n    float d2=sdBox(p1, vec2(0.5,0.23) );\n    float d3=sdBox(p2, vec2(0.5,0.23) );\n    float dif=differenceSDF(d1,d2);\n     dif=differenceSDF(dif,d3);\n    col= DrawFig(col1, col, d1);\n    col= DrawFig(col2, col, dif);\n    return col;\n}\n\n\nvec3 Casa04(vec2 p, vec3 col)\n{   col=ParedCasa02Ch(p, col);\n    //techo 1\n    float d4= sdParallelogram(p-vec2(-1.0,2.8), 3.5, 0.8, 0.4 );\n    float d5= sdParallelogram(vec2(-p.x,p.y)-vec2(-1.0,2.8), 3.5, 0.8, 0.4 );\n     d4= unionSDF(d5, d4);\n     \n     col= ParedDif(d4 ,p*vec2(1.05,1.0),  col,VERDE4,vec3(0.0,0.0,0.3));\n    col=ParedCasa02Ch(p-vec2(0.0,5.5), col);\n    \n    float d2=sdBox(p-vec2(-2.0,4.5), vec2(0.8,1.0));\n    col=DrawFigBordeCol(FVENTANA2, col, d2, CAFE2);\n    \n    float d3=sdBox(p-vec2(0.35,4.5), vec2(0.8,1.0));\n    col=DrawFigBordeCol(FVENTANA2, col, d3, CAFE2);\n    \n    //techo 2\n    float d4a= sdParallelogram(p-vec2(-1.0,8.0), 4.0, 1.2, 0.5 );\n    float d5a= sdParallelogram(vec2(-p.x,p.y)-vec2(-1.0,8.0), 4.0, 1.2, 0.5 );\n    d4a= unionSDF(d5a, d4a);\n    col= ParedDif(d4a ,p*vec2(1.05,1.0),  col,VERDE4,vec3(0.0,0.0,0.3));\n    //chimenea\n    float d6=sdBox(p-vec2(-2.0,9.0), vec2(0.6,1.0));\n    col=DrawFigBordeCol(CAFE2, col, d6, vec3(0.0));\n    \n    float d7=sdBox(p-vec2(-2.0,10.0), vec2(1.1,0.5));\n    col=DrawFigBordeCol(CAFE2, col, d7, vec3(0.0));\n    return col;\n}\n\n\nvec3 Casa05(vec2 p, vec3 col)\n{   float d1=sdBox(p, vec2(2.2,4.0) );\n    col= DrawFig(CASA5A, col, d1);\n    \n    //pared lateral\n    float d3= sdParallelogram(p.yx-vec2(0.8,3.5), 4.0, 1.5-0.2, 1.0-0.2 );\n    vec2 p1=p;\n    p1=rotatev2(p1-vec2(3.5,4.9), radians(60.0));\n    float dr1= sdRhombus(  p1, vec2(1.5,1.5) );\n    \n    d3= unionSDF(d3, dr1);\n    col= DrawFig(CASA5B, col, d3);\n    \n    //techo\n    float d4= sdParallelogram(p-vec2(0.3,5.1), 2.5, 1.1, 0.5 );\n    col= DrawFig(VERDE4, col, d4);\n    \n    //ventana lateral\n    float d5= sdParallelogram(p.yx-vec2(2.0,3.6), 1.5, 0.5-0.2, 0.35-0.2 );\n    col= DrawFigBordeCol(FVENTANA2, col, d5,CAFE2);\n    return col;\n}\n\nvec3 Postes(vec2 p, vec3 col)\n{\n    float d1=sdBox(p, vec2(0.2,2.0) );\n    float d2=sdTriangleIsosceles(vec2(p.x,-p.y)-vec2(0.0,1.2), vec2(0.6,0.8)  );\n    float d3=sdBox(p-vec2(0.0,0.4), vec2(0.35,0.2) );\n    float d4=sdBox(p-vec2(0.0,1.5), vec2(0.4,0.5) );\n    float d5=sdBox(p-vec2(-0.15,1.5), vec2(0.12,0.4) );\n    float d6=sdBox(p-vec2(0.15,1.5), vec2(0.1,0.4) );\n    \n    col= DrawFig(vec3(0.0), col, d1);\n    col= DrawFig(vec3(0.0), col, d2);\n    col= DrawFig(vec3(0.0), col, d3);\n    col= DrawFig(vec3(0.0), col, d4);\n    col= DrawFig(vec3(1.0,1.0,0.0), col, d5);\n    col= DrawFig(vec3(1.0,1.0,0.0), col, d6);    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    //vec3  col=vec3(0.45,0.7,1.0)-uv.y*0.45;\n    vec3  col=vec3(0.0);\n    \n    float LimiteCielo=0.2;\n    // stars\n    float stars1 = 1. - clamp(rand(uv) * 800.0, 0.0, 1.0);\n    float stars2 = 1. - clamp(rand(uv-vec2(1.0,-1.0)) * 400.0, 0.0, 1.0);\n    stars1 = mix(0.0, stars1, 1. - step(uv.y, LimiteCielo));\n    stars2 = mix(0.0, stars2, 1. - step(uv.y, LimiteCielo));\n    col = mix(col, vec3(1.0)*sin(iTime*8.), stars1);\n    col = mix(col, vec3(1.0)*cos(iTime*16.5), stars2);\n    \n    \n    //uv*=10.0;  //cambio idea byt3_m3chanic,\n    uv.x+=iTime*0.5;\n    uv*=10.;\n    //uv.x=mod(uv.x+15.,30.)-15.;\n    uv.x= opRep1D( uv.x, 40.0 );\n\n    vec2 uv1=uv;\n    vec2 uv2=uv;\n    col=Suelo1(uv, col);\n    \n    col=banqueta(uv-vec2(-8.0,-7.0),col);\n    col=banqueta(uv-vec2(18.0,-7.0),col);\n    col=banquetaG(uv-vec2(-4.0,1.5),col);\n    col=banquetaG(uv-vec2(32.0,1.5),col);\n    \n    col= Casa05(uv-vec2(1.5,3.5), col);\n    \n    col= Casa02(uv-vec2(-8.0,1.5), col);\n    col= Casa01(uv-vec2(-15.0,-1.5), col);\n    col= Casa03(uv*vec2(1.0,1.1)-vec2(-2.5,-1.8), col);\n    col= Casa04(uv-vec2(15.0,-1.0), col);\n    col= Postes(uv-vec2(-0.2,-1.7), col);\n    col= Postes(uv-vec2(-10.5,-1.7), col);\n    col= Postes(uv-vec2(10.0,-1.7), col);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "const vec3 CAFE0=vec3(90,39,41)/255.;\nconst vec3 CAFE1=vec3(118,57,49)/255.;\nconst vec3 VERDE0=vec3(0.1,0.35,0.35);\nconst vec3 VERDE1=vec3(0.0,0.4,0.4);\nconst vec3 VERDE2=vec3(0.0,0.5,0.5);\nconst vec3 VERDE3=vec3(30,122,144)/255.0;\nconst vec3 VERDE4=vec3(9,87,87)/255.;\nconst vec3 CALLE1=vec3(1,74,74)/255.0;\nconst vec3 CAFE2=vec3(128,77,77)/255.0;\nconst vec3 CAFE3=vec3(99,67,56)/255.0;\nconst vec3 FVENTANA=vec3(150,141,141)/255.0;\nconst vec3 FVENTANA2=vec3(164,173,106)/255.0;\nconst vec3 VERDE5=vec3(2,73,73)/255.0;\nconst vec3 NEGRO=vec3(0,0,2)/255.0;\nconst vec3 TECHO1=vec3(33,99,123)/255.0;\nconst vec3 VERDE5P=vec3(16,132,9)/255.0;\nconst vec3 VERDE6P=vec3(3,80,24)/255.0;\nconst vec3 CASA5=vec3(92,90,107)/255.0;\nconst vec3 CASA4=vec3(69,66,66)/255.0;\nconst vec3 CASA5A=vec3(90,82,82)/255.0;\nconst vec3 CASA5B=vec3(140,114,114)/255.0;\n\n\nfloat rand (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.98458,78.233)))*\n        43758.5453123);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slt3z8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[286, 286, 320, 320, 415], [417, 448, 484, 484, 529], [534, 578, 625, 625, 652], [653, 653, 696, 696, 723], [724, 724, 772, 772, 800], [806, 806, 868, 868, 997], [999, 999, 1080, 1080, 1207], [1209, 1209, 1266, 1266, 1331], [1333, 1333, 1370, 1370, 1447], [1449, 1449, 1484, 1484, 1508], [1510, 1510, 1561, 1561, 1866], [1869, 1869, 1935, 1935, 2274], [2276, 2276, 2305, 2305, 2333], [2334, 2334, 2376, 2376, 2557], [2559, 2559, 2590, 2590, 2647], [2649, 2649, 2682, 2682, 3127], [3129, 3129, 3163, 3163, 3652], [3655, 3655, 3691, 3691, 4145], [4147, 4147, 4178, 4178, 5220], [5222, 5222, 5253, 5253, 6465], [6467, 6467, 6498, 6498, 8037], [8040, 8040, 8078, 8078, 8581], [8584, 8584, 8650, 8650, 9127], [9130, 9130, 9161, 9161, 10233], [10236, 10236, 10267, 10267, 10908], [10910, 10910, 10941, 10941, 11549], [11551, 11551, 11608, 11608, 12963]], "test": "untested"}
