{"id": "ftSSWw", "name": "COLOURBURSTII", "author": "jj99", "description": "colors", "tags": ["fbm"], "likes": 15, "viewed": 431, "published": 3, "date": "1627752341", "time_retrieved": "2024-07-30T19:08:24.323357", "image_code": "float hash( float n )\n{\n    return fract(sin(n)*758.5453)*2.;\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x); \n    //f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + p.z*800.0;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x), mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n            mix(mix( hash(n+800.0), hash(n+801.0),f.x), mix( hash(n+857.0), hash(n+858.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm(vec3 p)\n{\n    float f = 0.0;\n    f += 0.50000*noise( p ); p = p*2.02+0.15;\n    f -= 0.25000*noise( p ); p = p*2.03+0.15;\n    f += 0.12500*noise( p ); p = p*2.01+0.15;\n    f += 0.06250*noise( p ); p = p*2.04+0.15;\n    f -= 0.03125*noise( p );\n    return f/0.984375;\n}\n\nfloat cloud(vec3 p)\n{\n    p-=fbm(vec3(p.x,p.y,0.0)*0.5)*0.7;\n    \n    float a =0.0;\n    a-=fbm(p*3.0)*2.2-1.1;\n    if (a<0.0) a=0.0;\n    a=a*a;\n    return a;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n\nvec3 hash33(vec3 p)\n{\n    const float UIF = (1.0/ float(0xffffffffU));\n    const uvec3 UI3 = uvec3(1597334673U, 3812015801U, 2798796415U);\n    uvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\n\n// 3D Voronoi- (IQ)\nfloat voronoi(vec3 p){\n\n\tvec3 b, r, g = floor(p);\n\tp = fract(p);\n\tfloat d = 1.; \n\tfor(int j = -1; j <= 1; j++)\n    {\n\t    for(int i = -1; i <= 1; i++)\n        {\n\t\t    b = vec3(i, j, -1);\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 0.0;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 1.;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t    }\n\t}\n\treturn d;\n}\n\n// fbm layer\nfloat noiseLayers(in vec3 p) {\n\n    vec3 pp = vec3(0., 0., p.z + iTime*.09);\n    float t = 0.;\n    float s = 0.;\n    float amp = 1.;\n    for (int i = 0; i < 5; i++)\n    {\n        t += voronoi(p + pp) * amp;\n        p *= 2.;\n        pp *= 1.5;\n        s += amp;\n        amp *= .5;\n    }\n    return t/s;\n}\n\nvec3 n2 (vec2 fragCoord)\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n        float dd = length(uv*uv)*.025;\n    \n\tvec3 rd = vec3(uv.x, uv.y, 1.0);\n    \n    float rip = 0.5+sin(length(uv)*20.0+iTime)*0.5;\n    rip = pow(rip*.38,4.15);\n    rd.z=1.0+rip*1.15;// apply a subtle ripple\n    rd = normalize(rd);\n    //rd.xy *= rot(dd-iTime*.025);\n    rd*=2.0;\n\t\n\tfloat c = noiseLayers(rd*1.85);\n    float oc = c;\n    c = max(c + dot(hash33(rd)*2. - 1., vec3(.006)), 0.);\n    c = pow(c*1.55,2.5);    \n    vec3 col =  vec3(.55,0.85,.25);\n    vec3 col2 =  vec3(1.4,1.4,1.4)*5.0;\n    float pulse2 = voronoi(vec3((rd.xy*1.5),iTime*.255));\n    float pulse = pow(oc*1.35,4.0);\n    col = mix(col,col2,pulse*pulse2)*c;\n    return col;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    \n\tvec2 position = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\tfloat ss = sin(length(position*3.0)+time*0.125);\n\tss+=5.0;\n    \n    \n   \tvec2 coord = ss*position;\n        coord*=rot(ss*0.1+time*0.037);\n    \n    \n    coord+=fbm(sin(vec3(coord*8.0,time*0.001)))*0.08;\n    coord+=time*0.0171;\n    float q = cloud((vec3(coord*1.0,0.222)));\n    coord+=time*0.0171;\n    q += cloud((vec3(coord*0.6,0.722)));\n    coord+=time*0.0171;\n    q += cloud(vec3(coord*0.3,.722));\n    coord+=time*0.1171;\n    q += cloud((vec3(coord*0.1,0.722)));\n    \n    \n\tfloat vv1 = sin(time+ss+coord.x)*0.3;\n\tfloat vv2 = sin(time*0.9+ss+coord.y)*0.2;\n\nvec3    col = vec3(1.7-vv2,1.7,1.7+vv1) + vec3(q*vec3(0.7+vv1,0.5,0.3+vv2*1.15));\n\tcol = pow(col,vec3(2.2));\n\t\n\tfloat dd = length(col*.48)+vv1;\n\t\n\tfloat nn = 0.5+sin(ss*2.7+position.x*2.41+time*0.9)*0.5;\n\t\n    vec3 col2 = n2(fragCoord)*12.0;\n    col2+=col;\n\tcol = mix(col,col2,nn);\n\t\n    fragColor = vec4( col*0.08, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftSSWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 63], [65, 65, 91, 91, 440], [442, 442, 461, 461, 718], [720, 720, 741, 741, 879], [881, 881, 902, 902, 970], [973, 973, 994, 994, 1201], [1204, 1224, 1246, 1246, 1643], [1645, 1658, 1688, 1688, 1961], [1963, 1963, 1989, 1989, 2707], [2710, 2710, 2767, 2767, 3751]], "test": "untested"}
{"id": "sl2XDD", "name": "COLORBURST", "author": "jj99", "description": "some colours", "tags": ["fbm", "colour"], "likes": 7, "viewed": 266, "published": 3, "date": "1627751484", "time_retrieved": "2024-07-30T19:08:25.206994", "image_code": "float hash( float n )\n{\n    return fract(sin(n)*758.5453)*2.;\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x); \n    //f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + p.z*800.0;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x), mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n            mix(mix( hash(n+800.0), hash(n+801.0),f.x), mix( hash(n+857.0), hash(n+858.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm(vec3 p)\n{\n    float f = 0.0;\n    f += 0.50000*noise( p ); p = p*2.02+0.15;\n    f -= 0.25000*noise( p ); p = p*2.03+0.15;\n    f += 0.12500*noise( p ); p = p*2.01+0.15;\n    f += 0.06250*noise( p ); p = p*2.04+0.15;\n    f -= 0.03125*noise( p );\n    return f/0.984375;\n}\n\nfloat cloud(vec3 p)\n{\n    p-=fbm(vec3(p.x,p.y,0.0)*0.5)*0.7;\n    \n    float a =0.0;\n    a-=fbm(p*3.0)*2.2-1.1;\n    if (a<0.0) a=0.0;\n    a=a*a;\n    return a;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    \n\tvec2 position = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\tfloat ss = sin(length(position*3.0)+time*0.125);\n\tss+=5.0;\n    \n    \n   \tvec2 coord = ss*position;\n        coord*=rot(ss*0.1+time*0.037);\n    \n    \n    coord+=fbm(sin(vec3(coord*8.0,time*0.001)))*0.08;\n    coord+=time*0.0171;\n    float q = cloud((vec3(coord*1.0,0.222)));\n    coord+=time*0.0171;\n    q += cloud((vec3(coord*0.6,0.722)));\n    coord+=time*0.0171;\n    q += cloud(vec3(coord*0.3,.722));\n    coord+=time*0.1171;\n    q += cloud((vec3(coord*0.1,0.722)));\n    \n    \n\tfloat vv1 = sin(time+ss+coord.x)*0.3;\n\tfloat vv2 = sin(time*0.9+ss+coord.y)*0.2;\n\nvec3    col = vec3(1.7-vv2,1.7,1.7+vv1) + vec3(q*vec3(0.7+vv1,0.5,0.3+vv2*1.15));\n\tcol = pow(col,vec3(2.2));\n\t\n\tfloat dd = length(col*.48)+vv1;\n\t\n\tfloat nn = 0.5+sin(ss*.7+position.x*.41+time*0.9)*0.5;\n\t\n\tcol = mix(col,vec3(dd),nn);\n\t\n    fragColor = vec4( col*0.08, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl2XDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 63], [65, 65, 91, 91, 440], [442, 442, 461, 461, 718], [720, 720, 741, 741, 879], [881, 881, 902, 902, 970], [972, 972, 1029, 1029, 1964]], "test": "untested"}
{"id": "7tjXWD", "name": "3D hand sketch", "author": "yasuo", "description": "no nails", "tags": ["hand"], "likes": 12, "viewed": 298, "published": 3, "date": "1627740653", "time_retrieved": "2024-07-30T19:08:25.984915", "image_code": "// All the distance functions from:https://iquilezles.org/articles/distfunctions\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 128\n#define MAX_DIST 128.\n#define SURF_DIST .0001\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define Box(p,s) max(max(abs(p).x-s.x,abs(p).y-s.y),abs(p).z-s.z)\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\n#define MATERIAL_DIFFUSE0 0\n#define MATERIAL_DIFFUSE1 1\n#define MATERIAL_REFLECT 2\n\n// by Dave_Hoskins\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 combine(vec2 val1, vec2 val2){\n    vec2 res1 = val1;\n    vec2 res2 = val2;\n    return (val1.x < val2.x)?res1:res2;\n}\n\n// by iq https://iquilezles.org/articles/distfunctions\nfloat smin(float a, float b, float k) {\n    float h = clamp(.5 + .5*(b - a)/k, .0, 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\n// by iq https://iquilezles.org/articles/distfunctions\nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat udRoundBox(vec3 p, vec3 b, float r) {\n    return length(max(abs(p)-b, .0)) -r;\n}\n\n// by reinder https://www.shadertoy.com/view/4tdcWS\n// This one is super fast.\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, const float r0, const float r1) {\n    vec3 d = b -a;\n    float h = length(d);\n    d = normalize(d);\n    float t=clamp(dot(p-a, d), 0., h);\n    return distance(a+t*d, p) -mix(r0, r1, t/h);\n}\n\nfloat dHand(vec3 p){\n    vec3 prevP = p;\n    \n    const float k = 1.1;\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(0.0);    \n    q.y = p.y;\n    q.xz=m*p.xz;\n    \n    float d = udRoundBox(q-vec3(0.01,0.05,0.0),vec3(0.1,0.05,0.001),0.04);\n    d = smin(d,udRoundBox(p-vec3(0.005,-0.02,0.01),vec3(0.09,0.02,0.0001),0.035),0.03);\n    d = smin(d,udRoundBox(p-vec3(0.0,-0.1,0.0),vec3(0.065,0.02,0.0001),0.035),0.03);\n    \n    // palm\n    float d2 = sdCapsule(q,vec3(0.13,0.05,0.0425),vec3(-0.03,0.09,0.045),0.005,0.001);\n    d = smax(d2,d,0.01);\n    d2 = sdCapsule(q,vec3(0.03,0.03,0.05),vec3(-0.13,0.06,0.0425),0.001,0.005);\n    d = smax(d2,d,0.01);\n    d2 = sdCapsule(q,vec3(0.00,-0.1,0.045),vec3(-0.04,0.01,0.06),0.005,0.001);\n    d = smax(d2,d,0.01);\n    \n    p = prevP;\n    \n    // pinky\n    d = smin(d,sdCapsule(p,vec3(0.13,0.15,0.0),vec3(0.15,0.18,0.0),0.035,0.03),0.03);\n    d = smin(d,sdCapsule(p,vec3(0.15,0.18,0.0),vec3(0.165,0.22,0.01),0.03,0.027),0.005);\n    d = smin(d,sdCapsule(p,vec3(0.165,0.22,0.01),vec3(0.175,0.26,0.03),0.028,0.025),0.005);\n    \n    // ring\n    d = smin(d,sdCapsule(p,vec3(0.06,0.15,0.0),vec3(0.07,0.21,0.0),0.035,0.03),0.01);\n    d = smin(d,sdCapsule(p,vec3(0.07,0.21,0.0),vec3(0.085,0.27,0.01),0.03,0.027),0.005);\n    d = smin(d,sdCapsule(p,vec3(0.085,0.27,0.01),vec3(0.095,0.33,0.03),0.028,0.025),0.005);\n    \n    // middle\n    d = smin(d,sdCapsule(p,vec3(-0.015,0.15,0.0),vec3(-0.015,0.22,-0.01),0.035,0.03),0.02);\n    d = smin(d,sdCapsule(p,vec3(-0.015,0.22,-0.01),vec3(-0.015,0.29,0.00),0.03,0.027),0.005);\n    d = smin(d,sdCapsule(p,vec3(-0.015,0.29,0.00),vec3(-0.015,0.36,0.02),0.028,0.025),0.005);\n    \n    // index\n    d = smin(d,sdCapsule(p,vec3(-0.09,0.15,0.0),vec3(-0.105,0.21,0.0),0.035,0.03),0.03);\n    d = smin(d,sdCapsule(p,vec3(-0.105,0.21,0.0),vec3(-0.12,0.26,0.01),0.03,0.027),0.005);\n    d = smin(d,sdCapsule(p,vec3(-0.12,0.26,0.01),vec3(-0.13,0.32,0.03),0.028,0.025),0.005);   \n    \n    // thumb\n    d = smin(d,sdCapsule(p,vec3(-0.08,-0.03,0.0),vec3(-0.13,0.02,0.0),0.035,0.037),0.035);\n    d = smin(d,sdCapsule(p,vec3(-0.13,0.02,0.0),vec3(-0.17,0.09,0.01),0.037,0.032),0.005);\n    d = smin(d,sdCapsule(p,vec3(-0.17,0.09,0.01),vec3(-0.19,0.15,0.02),0.032,0.03),0.005);\n    \n    // knuckles\n    d = smin(d,sdCapsule(p,vec3(0.12,0.12,-0.027),vec3(0.08,0.0,-0.02),0.01,0.005),0.03);\n    d = smin(d,sdCapsule(p,vec3(0.05,0.13,-0.03),vec3(0.03,0.0,-0.02),0.01,0.005),0.03);\n    d = smin(d,sdCapsule(p,vec3(-0.015,0.13,-0.03),vec3(-0.015,0.0,-0.02),0.01,0.005),0.03);\n    d = smin(d,sdCapsule(p,vec3(-0.09,0.12,-0.03),vec3(-0.07,0.0,-0.02),0.01,0.005),0.03);\n    return d;\n}\n\nvec2 GetDist(vec3 p) {\n    vec3 prevP = p;\n    p.x = abs(p.x);\n    p.x-=0.3;\n    float d = dHand(p);\n    \n    p = prevP;\n    p.y+=0.15;\n    float d2 = Box(p,vec3(1.2,0.01,1.2));\n    \n    vec2 res = vec2(d, MATERIAL_DIFFUSE0);\n    vec2 res2 = vec2(d2, MATERIAL_DIFFUSE1);\n       \n    vec2 model = combine(res,res2);\n    return model;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side) {\n    vec2 dO = vec2(0.0);\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n   \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n   \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n   \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 col) {\n    vec3 lightDir = normalize(vec3(0.8,0.4,0.2));\n    float diff = dot(n,normalize(lightDir))*0.5+0.5;\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    \n    vec3 res = col*(diff);\n    res += col*bounceDiff*0.5;    \n    \n    return res;\n}\n\nvec3 reflectMaterial(vec3 p, vec3 rd, vec3 n) {\n    vec3 r = reflect(rd,n);\n    \n    vec3 col = r;\n    \n    float k = r.y*r.y;\n    col = mix(col,vec3(1.5),k);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n   \n    vec3 ro = vec3(0, 0, -3.5);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(10.0));\n    ro.xz *= Rot(-iTime*.5+1.0);\n    \n    #endif\n   \n    vec3 rd = R(uv, ro, vec3(0,0.2,0), 3.0);\n    vec2 d = RayMarch(ro, rd, 1.);\n    vec3 col = vec3(0.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n\n        int mat = int(d.y);\n        if(mat == MATERIAL_DIFFUSE0){\n            float h = hash12(p.xz*5.0)*0.05;\n            col = diffuseMaterial(n,vec3(0.95)+h);\n        } else if(mat == MATERIAL_DIFFUSE1) {\n            p.x = abs(p.x);\n            p.x-=0.3;\n            float fakeShadow = length(p.xz)-0.3;\n            col = diffuseMaterial(n,mix(vec3(0.9),vec3(0.2),S(fakeShadow,-0.5)));\n        } else if(mat == MATERIAL_REFLECT) {\n            col = reflectMaterial(p,rd,n);\n        }\n        \n    }\n   \n    // gamma correction\n    col = pow( col, vec3(0.6545) );\n   \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tjXWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[773, 792, 814, 814, 931], [933, 933, 968, 968, 1054], [1056, 1111, 1150, 1150, 1244], [1246, 1301, 1344, 1344, 1444], [1446, 1446, 1489, 1489, 1532], [1534, 1613, 1686, 1686, 1842], [1844, 1844, 1864, 1864, 4520], [4522, 4522, 4544, 4544, 4856], [4858, 4858, 4903, 4903, 5166], [5168, 5168, 5192, 5192, 5391], [5393, 5393, 5435, 5435, 5630], [5632, 5632, 5672, 5672, 5932], [5934, 5934, 5981, 5981, 6115], [6117, 6117, 6174, 6174, 7291]], "test": "untested"}
{"id": "7tjSDW", "name": "Alright Alright Alright", "author": "getrekt", "description": "Sound visualizer that basically copies levonchic's version: https://www.shadertoy.com/view/XdXcWr.", "tags": ["sound", "visualizer", "soundcloud", "monochromatic"], "likes": 0, "viewed": 300, "published": 3, "date": "1627728297", "time_retrieved": "2024-07-30T19:08:26.807715", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define MIRROR\n#define PERIOD \t\t\t4.0  // <- Angle_dia = pi * period \n#define INNER_DAMPING   4.0  // <- Damping damping for inner radius damping. > 1 = MADNESS\n#define DOUBLE_DAMPING  0.54 // <- Damping of Buffer A\n #define SWAP              // <- Swap inner and outer\n// #define MADNESS           // <- Uncomment if you want to see some features\n#define RED             3.0  // <- value of .. idk, this is for red\n#define GREEN           2.0  // <- for green \n#define BLUE            5.0  // <- for blue\n#define COLOR_ADD       .3  // <- increase color intensivity\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Constants\n    float RADIUS = min(iResolution.x, iResolution.y) / 4.0;\n    float inner, outer;\n    \n    // Get distance\n    vec2 dist    = fragCoord.xy - iResolution.xy / 2.0;\n    float s_dist = sqrt(dist.x * dist.x + dist.y * dist.y);\n \t\n    // Get rotation angle [0.0 - 1.0]\n    float angle  = atan(dist.y / dist.x) / (3.14 * PERIOD) + 0.25;\n    if(dist.x <= 0.0)\n        angle += 0.5;\n    #ifdef MIRROR\n    \tif(dist.x <= 0.0)\n            angle = 1.0 - angle;\n    #endif\n    \n    #ifndef SWAP\n    \tinner = texture(iChannel0, vec2(angle, 0.25)).x;\n    \touter = texture(iChannel0, vec2(angle, 0.75)).x;\n    #else\n    \tinner = texture(iChannel0, vec2(angle, 0.75)).x;\n    \touter = texture(iChannel0, vec2(angle, 0.25)).x;\n    #endif\n    \n    float color = 0.0;\n    float radius = 0.0;\n    float damping = s_dist / iResolution.x * 2.0;// * INNER_DAMPING;\n    float frame_render = texture(iChannel1, uv).x * DOUBLE_DAMPING;\n    \n    radius = (RADIUS + 0.1) * (0.9 + outer * damping);\n    \n    if(s_dist < radius)\n        color = 1.0;\n    else\n        color = damping * (radius / iResolution.x + 1.0 - damping);\n    \n    #ifdef MADNESS\n    \tradius = (RADIUS * 0.84) * (1.0 + inner * damping);\n    #else\n    \tradius = (RADIUS - 0.1) * (1.0 - inner * (damping * INNER_DAMPING));\n    #endif\n    \n    if(s_dist < radius)\n        color = 0.2 * (1.0 - damping) * (radius / iResolution.x + 1.0 - damping);\n    \n    fragColor = vec4(color);\n    \n    // Coloring \n    float scalar_color_offset = COLOR_ADD + s_dist / radius * (1.0 - COLOR_ADD);\n    \n    fragColor *= vec4(RED, GREEN, BLUE, 1.0) * scalar_color_offset;\n    \n    // Bound it down\n    fragColor = clamp(vec4(0.0), vec4(1.0), fragColor + frame_render);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27911, "src": "https://soundcloud.com/princessrosalina/sick-as-hell-sonic-mashup", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tjSDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 105, 300]], "test": "untested"}
{"id": "fljXWD", "name": "tetrahedron SDFs (collection)", "author": "xertrov", "description": "forked from IQ's Fork raymarching primitives.", "tags": ["3d", "raymarching", "distancefields", "primitives", "tetrahedron"], "likes": 5, "viewed": 416, "published": 3, "date": "1627702292", "time_retrieved": "2024-07-30T19:08:27.758173", "image_code": "/* All the tetrahedron primitives I could find.\n\nFORKED FROM iq's PRIMITIVES DEMO\n\n*/\n\n// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A list of useful distance function to simple primitives. All\n// these functions (except for ellipsoid) return an exact\n// euclidean distance, meaning they produce a better SDF than\n// what you'd get if you were constructing them from boolean\n// operations.\n\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and https://iquilezles.org/articles/distfunctions\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n\n\n/*\n    TETRAHEDRON SDFs\n*/\n\n\n// honorable mention to https://www.shadertoy.com/view/tlXBR8 -- has some links and discussion\n\n/* found this somewhere -- it's neat but doesn't render cleanly.\nmb from here: https://www.shadertoy.com/view/Ws23zt -- there are some equiv SDFs there too */\n\nfloat sdTet2(vec3 p, float r) {\n  return (max(\n    abs(p.x - p.z) + p.y,\n    abs(p.x + p.z) - p.y\n  ) - r);\n}\n\n/* my derivation -- wanted to get something that was easily generalized to 4d. It didn't quite work. */\n\nvec3 sdTetrahedronInner(vec3 p, float r) {\n  float ySign = sign(p.y);\n  p.xz = abs(ySign < 0. ? p.zx : p.xz);\n  p.y = abs(p.y);\n  vec3 box = vec3(mix(r/2., r, p.y / r), r, mix(r/2., r, -p.y / r));\n  return p - box;\n}\n\nfloat sdTetrahedron(vec3 p, float r, out vec3 dists) {\n  dists = sdTetrahedronInner(p, r);\n  return length(bestOf(dists)) * sign(bestOf(dists));\n}\nfloat sdTetrahedron(vec3 p, float r) {\n  vec3 tmp;\n  return sdTetrahedron(p, r, tmp);\n}\n\nfloat sdTetrahedronFrame(vec3 p, float r, out vec3 dists) {\n  dists = sdTetrahedronInner(p, r);\n  return length(best2(dists));\n}\nfloat sdTetrahedronFrame(vec3 p, float r) {\n  vec3 tmp;\n  return sdTetrahedronFrame(p, r, tmp);\n}\n\n/* from https://www.shadertoy.com/view/Ms3Sz2 */\n\n// Isohedral Tetrahedron distance function\nfloat sdIsoTet(vec3 p, float h) \n{\n    vec3 q = abs(p);\n    \n    float y = p.y,\n          d1 = q.z-max(0.,y),\n          d2 = max(q.x*.5 + y*.5,.0) - min(h, h+y);\n    return length(max(vec2(d1,d2),.005)) + min(max(d1,d2), 0.);\n}\n\n/* https://www.shadertoy.com/view/MtV3Dy */\n\nfloat  plane(vec3 p, vec3 origin, vec3 normal){ \n   return dot(p - origin,normal);   \n}\n\nfloat tetrahedronPlanes(vec3 p, float d) { \n  float dn =1.0/sqrt(3.0);\n  \n   //The tetrahedran is the intersection of four planes:\n    float sd1 = plane(p,vec3(d,d,d) ,vec3(-dn,dn,dn)) ; \n    float sd2 = plane(p,vec3(d,-d,-d) ,vec3(dn,-dn,dn)) ;\n \tfloat sd3 = plane(p,vec3(-d,d,-d) ,vec3(dn,dn,-dn)) ;\n \tfloat sd4 = plane(p,vec3(-d,-d,d) ,vec3(-dn,-dn,-dn)) ;\n  \n    //max intersects shapes\n    dn = max(max(sd1,sd2),max(sd3,sd4));\n  return dn; \n}\n\n/*\nmb the most interesting one, could be used for 4d version of tetrahedron?\nhttps://www.shadertoy.com/view/ts3SRs\n*/\n\n\nfloat maxElem(vec4 a){\n    return max(a.x, max(a.y, max(a.z,a.w)));\n}\n//A box in 4D tetrahedral space\nfloat sdBox4( vec4 p, vec4 b )\n{\n    vec4 d = abs(p) - b;\n    return min(maxElem(d),0.0) + length(max(d,0.0));\n}\n\nfloat gTetOffset = 1.0;//using 1 makes this a tet, using 0 makes it an octahedron\n\n//Convert from euclidean to tetrahedral space\nvec4 GetTetCoord(vec3 p){\n    float offset = gTetOffset;//sqrt(2.0);\n    float s1 = 1.0/sqrt(4.0);\n    float s2 = 1.0/sqrt(2.0);\n    float s3 = 1.0;\n    \n    return vec4(offset - p.z*s1 - s2*p.x,\n                offset - p.z*s1 + s2*p.x,\n                offset + p.z*s1 + s2*p.y,\n                offset + p.z*s1 - s2*p.y)*s3;\n}\n\nfloat sdTetrahedronInTetSpace(vec3 p, float size, float roundness){\n    vec4 t = GetTetCoord(p); \n    \n    float scaleDown = 1.0/sqrt(4.0);//scale it to match expectation of size--\n    float offsetSize = gTetOffset;//offset size to expectation of tet\n    size = size*scaleDown + offsetSize ;\n    \n  //roundness *= scaleDown;\n    return sdBox4(t, vec4(size))-roundness; //rounded tetrahedon, yah!\n    //return sdBox4(t, vec4(size,size*.05,size*1.0, size*3.0))-roundness; //can do irregular shaped tets also\n  //return maxElem(abs(t)) - size;//max norm tetrahedron as seen in many shadertoys\n}\n\n/* @iq posted this in the comments of https://www.shadertoy.com/view/ts3SRs */\n\nfloat sdTetrahedronIq(vec3 p, float size, float roundness)\n{\n    const float k = sqrt(2.0);\n\n    p *= size;\n\n    p.xz = abs(p.xz);\n    \n    float m = 2.0*p.z - k*p.y - 1.0;\n\n    p = (m>0.0) ? p : vec3(p.z,-p.y,p.x);\n\n    float s1 = clamp(p.x,0.0,1.0);\n    float s2 = clamp((p.x-p.y*k-p.z+2.0)/4.0,0.0,1.0);\n    \n    m = 2.0*p.z - k*p.y - 1.0;\n\n    float d = sign(m)*sqrt((sign(p.y*k+p.z+1.0)+sign(2.0-3.0*p.x-k*p.y-p.z)<1.0) \n                  ?\n                  min( dot2(vec3(s1,-k*0.5,0)-p), \n                       dot2(vec3(s2, k*0.5-k*s2,1.0-s2)-p) )\n                  :\n                  m*m/6.0 );\n    \n    return d / size - roundness;\n}\n\n/* https://www.shadertoy.com/view/tdGBzW */\n\nfloat sdTetrahedronPyramid(vec3 p) {\n    p *= 0.5;\n    return max(\n        // Vertical bound\n        abs(p.y) - 0.5, \n\n        // Horizontal bound\n        max(abs(p.x) * 0.866025 + p.z * 0.5, -p.z) - 0.25 * abs(0.5 - p.y)\n    ) * 1.9;\n}\n\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    {\n      res = opU( res, vec2( sdSphere(    pos-vec3(-2.0,0.25, 0.0), 0.25 ), 26.9 ) );\n    }\n\n    // bounding box\n    if( sdBox( pos-vec3(0.0,0.3,-1.0),vec3(0.35,0.3,2.5) )<res.x )\n    {\n    \n    res = opU( res, vec2( sdTetrahedron( pos-vec3( 0.0, 0.3, 0.0), 0.25 ), 16.9 ) );\n    res = opU( res, vec2( sdTet2(      (pos-vec3( 0.0,0.30, 1.0)).xzy, .25 ), 25.0 ) );\n\tres = opU( res, vec2( sdIsoTet(        pos-vec3( 0.0,0.15,-1.0), 0.25 ), 55.0 ) );\n    res = opU( res, vec2( tetrahedronPlanes(  pos-vec3( 0.0,0.25,-2.0), 0.25 ), 33.67 ) );\n    \n    res = opU( res, vec2( sdTetrahedronIq(  pos-vec3( 1.0, 0.3, 1. ), 3.0,  .01 ), 49.13 ) );\n    res = opU( res, vec2( sdTetrahedronPyramid(  (pos -vec3( 1.0, 0.5, -1.0 )) / .3 ) * .3, 39.13 ) );\n\tres = opU( res, vec2( sdTetrahedronInTetSpace((pos-vec3( 1.0, 0.40, -0.0)), 0.25, 0.0), 18.5) );\n    res = opU( res, vec2( sdTetrahedronFrame(pos-vec3( 1.0, 0.35, -2.), .25), 3.0 ) - .02 );\n    \n\t/*\n    /**/\n    }\n\n    // bounding box\n    if( sdBox( pos-vec3(1.0,0.3,-1.0),vec3(0.35,0.3,2.5) )<res.x && false )\n    {\n    // more primitives\n    res = opU( res, vec2( sdCapsule(     pos-vec3( 1.0,0.00,-1.0),vec3(-0.1,0.1,-0.1), vec3(0.2,0.4,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdCylinder(    pos-vec3( 1.0,0.25,-2.0), vec2(0.15,0.25) ), 8.0 ) );\n    res = opU( res, vec2( sdHexPrism(    pos-vec3( 1.0,0.2,-3.0), vec2(0.2,0.05) ), 18.4 ) );\n    }\n\n    // bounding box\n    if( sdBox( pos-vec3(-1.0,0.35,-1.0),vec3(0.35,0.35,2.5))<res.x && false )\n    {\n    // more primitives\n\tres = opU( res, vec2( sdPyramid(    pos-vec3(-1.0,-0.6,-3.0), 1.0 ), 13.56 ) );\n\tres = opU( res, vec2( sdOctahedron( pos-vec3(-1.0,0.15,-2.0), 0.35 ), 23.56 ) );\n    res = opU( res, vec2( sdTriPrism(   pos-vec3(-1.0,0.15,-1.0), vec2(0.3,0.05) ),43.5 ) );\n    res = opU( res, vec2( sdEllipsoid(  pos-vec3(-1.0,0.25, 0.0), vec3(0.2, 0.25, 0.05) ), 43.17 ) );\n\tres = opU( res, vec2( sdRhombus(   (pos-vec3(-1.0,0.34, 1.0)).xzy, 0.15, 0.25, 0.04, 0.08 ),17.0 ) );\n    }\n\n    // bounding box\n    if( sdBox( pos-vec3(2.0,0.3,-1.0),vec3(0.35,0.3,2.5) )<res.x && false )\n    {\n    // more primitives\n    res = opU( res, vec2( sdOctogonPrism(pos-vec3( 2.0,0.2,-3.0), 0.2, 0.05), 51.8 ) );\n    res = opU( res, vec2( sdCylinder(    pos-vec3( 2.0,0.15,-2.0), vec3(0.1,-0.1,0.0), vec3(-0.2,0.35,0.1), 0.08), 31.2 ) );\n\tres = opU( res, vec2( sdCappedCone(  pos-vec3( 2.0,0.10,-1.0), vec3(0.1,0.0,0.0), vec3(-0.2,0.40,0.1), 0.15, 0.05), 46.1 ) );\n    res = opU( res, vec2( sdRoundCone(   pos-vec3( 2.0,0.15, 0.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.35,0.1), 0.15, 0.05), 51.7 ) );\n    res = opU( res, vec2( sdRoundCone(   pos-vec3( 2.0,0.20, 1.0), 0.2, 0.1, 0.3 ), 37.0 ) );\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/boxfunctions\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.0,0.4,-0.5), rd, vec3(2.5,0.41,3.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        //return vec2(tb.x,2.0);\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<24; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    // background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    \n    // raycast scene\n    vec2 res = raycast(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );\n        float ks = 1.0;\n        \n        if( m<1.5 )\n        {\n            // project pixel footprint into the plane\n            vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n            float f = checkersGradBox( 3.0*pos.xz, 3.0*dpdx.xz, 3.0*dpdy.xz );\n            col = 0.15 + f*vec3(0.05);\n            ks = 0.4;\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n        \n\t\tvec3 lin = vec3(0.0);\n\n        // sun\n        {\n            vec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n          //if( dif>0.0001 )\n        \t      dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n          //if( spe>0.001 )\n                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n\n    // camera\t\n    vec3 ta = vec3( 0.5, -0.5, -0.6 );\n    vec3 ro = ta + vec3( 4.5*cos(0.1*time + 7.0*mo.x), 1.3 + 2.0*mo.y, 4.5*sin(0.1*time + 7.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // focal length\n        const float fl = 2.5;\n        \n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,fl) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,fl) );\n        vec3 rdy = ca * normalize( vec3(py,fl) );\n        \n        // render\t\n        vec3 col = render( ro, rd, rdx, rdy );\n\n        // gain\n        // col = col*3.0/(2.5+col);\n        \n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "float bestOf(vec2 p) {\n  // return p.x > p.y ? p.x : p.y;\n  return max(p.x, p.y);\n}\nfloat bestOf(vec3 p) {\n  return max(max(p.x, p.y), p.z);\n}\nfloat bestOf(vec4 p) {\n  return max(bestOf(p.xyz), p.w);\n}\n\nvec2 best2(vec3 p) {\n  vec2 r = vec2(max(p.x, p.y), min(p.x, p.y)); // : vec2(p.y, p.x);\n  if (p.z > r.x) { return vec2(p.z, r.x);}\n  if (p.z > r.y) { return vec2(r.x, p.z);}\n  return r;\n}\n\nvec2 best2(vec4 p) {\n  vec2 r = p.x > p.y ? vec2(p.x, p.y) : vec2(p.y, p.x);\n  if (p.z > r.x) { r = vec2(p.z, r.x); }\n  else if (p.z > r.y) { r = vec2(r.x, p.z); }\n  if (p.w > r.x) { return vec2(p.w, r.x); }\n  else if (p.w > r.y) { return vec2(r.x, p.w); }\n  return r;\n}\n\n\n//------------------------------------------------------------------\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\n\n/* other primitives */\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdOctogonPrism( in vec3 p, in float r, float h )\n{\n  const vec3 k = vec3(-0.9238795325,   // sqrt(2+sqrt(2))/2 \n                       0.3826834323,   // sqrt(2-sqrt(2))/2\n                       0.4142135623 ); // sqrt(2)-1 \n  // reflections\n  p = abs(p);\n  p.xy -= 2.0*min(dot(vec2( k.x,k.y),p.xy),0.0)*vec2( k.x,k.y);\n  p.xy -= 2.0*min(dot(vec2(-k.x,k.y),p.xy),0.0)*vec2(-k.x,k.y);\n  // polygon side\n  p.xy -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  vec2 d = vec2( length(p.xy)*sign(p.y), p.z-h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n    vec2 q = h*vec2(c.x,-c.y)/c.y;\n    vec2 w = vec2( length(p.xz), p.y );\n    \n\tvec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 pos, vec2 c, float ra)\n{\n    vec2 p = vec2( length(pos.xz), pos.y );\n    float l = length(p) - ra;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,ra) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n\n    // exact distance\n    #if 0\n    vec3 o = min(3.0*p - m, 0.0);\n    o = max(6.0*p - m*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n    #endif\n    \n    // exact distance\n    #if 1\n \tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n    #endif\n    \n    // bound, not exact\n    #if 0\n\treturn m*0.57735027;\n    #endif\n}\n\nfloat sdPyramid( in vec3 p, in float h )\n{\n    float m2 = h*h + 0.25;\n    \n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\t\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fljXWD.jpg", "access": "api", "license": "mit", "functions": [[1939, 1939, 1970, 1970, 2048], [2155, 2155, 2197, 2197, 2371], [2373, 2373, 2427, 2427, 2519], [2520, 2520, 2558, 2558, 2607], [2609, 2609, 2668, 2668, 2737], [2738, 2738, 2781, 2781, 2835], [2887, 2930, 2964, 2964, 3157], [3204, 3204, 3251, 3251, 3291], [3293, 3293, 3335, 3335, 3740], [3862, 3862, 3884, 3884, 3931], [3932, 3964, 3996, 3996, 4076], [4161, 4207, 4232, 4232, 4534], [4536, 4536, 4603, 4603, 5127], [5209, 5209, 5269, 5269, 5855], [5902, 5902, 5938, 5938, 6138], [6211, 6211, 6241, 6241, 6274], [6446, 6446, 6471, 6471, 9223], [9225, 9273, 9324, 9324, 9529], [9531, 9531, 9571, 9571, 10381], [10383, 10428, 10506, 10529, 10916], [10918, 10964, 10996, 10996, 11566], [11568, 11568, 11610, 11610, 11919], [11921, 11973, 12037, 12058, 12291], [12293, 12293, 12358, 12377, 14857], [14859, 14859, 14911, 14911, 15088]], "test": "untested"}
{"id": "fl2SWD", "name": "3d SDF development tool", "author": "xertrov", "description": "A helper / tooling shader I wrote to assist with developing 3d SDFs. Mouse controls Z offset. The red box indicates a reset position, which is useful for glsl-canvas in vscode.\n\nLicense: CC0", "tags": ["sdf", "tool", "3dsdf", "development", "tooling"], "likes": 1, "viewed": 275, "published": 3, "date": "1627698694", "time_retrieved": "2024-07-30T19:08:28.813352", "image_code": "precision highp float;\n\n// distributed under CC0\n\n/* here's an example of an SDF I was developing for a tetrahedron\n-- note: this was some experimental code where I was trying to get\nthe distances to play nicely. */\n\nfloat testSdTet(vec3 p, float r, out vec3 dists, out vec3 col) {\n  float zoomOut = 2.;\n  // p *= zoomOut;\n\n  float ySign = sign(p.y);\n  // p.xz = abs(ySign < 0. ? p.zx : p.xz);\n  // p.y = abs(p.y);\n  vec3 box = vec3(\n    mix(r/2., r, p.y / r / r),\n    r,\n    mix(r/2., r, -p.y / r / r)\n  );\n  p.y *= SQRT_3;\n  dists = (abs(p) - box);\n  return length(bestOf(dists)) * sign(bestOf(dists));\n\n  /* a neat version I found that gave me the idea for using mix + box method */\n  \n  /*\n  return (max(\n    abs(p.x - p.z) + p.y,\n    abs(p.x + p.z) - p.y\n  ) - r);\n  /**/\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float aspect = u_resolution.x / u_resolution.y;\n    vec2 uv = scaleUvWithAspect(gl_FragCoord.xy / u_resolution.xy, aspect);\n    vec2 mouse = scaleUvWithAspect(u_mouse.xy/u_resolution.xy, aspect);\n    float fw = bestOf(fwidth(uv));\n    float t = u_time * .8;\n    float zMovement = 0.;\n    float zResolution = .1;\n    \n    float gridSize = 5., fwg = fw * gridSize;\n    vec2 id, gv;\n    setIDGV(uv, gridSize, id, gv);\n    \n    /* comment this to remove animation */\n    zMovement = sin(iTime) * .2;\n    \n    if (bestOf(mouse.xy) > -.5 + 1. / gridSize) {\n        zMovement += mouse.y + mouse.x;\n    }\n    \n    vec3 col = vec3(0), p;\n\n    // z from -1 to 1\n    float gridN = id.x + id.y * gridSize;\n    float nGridCells = gridSize * gridSize;\n    float z = gridN / (nGridCells - 1.) * 2. - 1. + zMovement;\n    float zId = floor((z + zResolution / 2.) * (gridSize + 1.) * 2.);\n    p = vec3(gv * 2., z);\n\n    vec3 tmp;\n    float d = testSdTet(p, .5, tmp, col);\n    // float d = sdTriangleGen(p, .5, tmp);\n\n    if (col == vec3(0)) {\n      col.b = step(.0, d) * hh(hh(cos(d * TAU * 5.)));\n      col.g = step(.0, -d) * hh(hh(cos(d * TAU * 5.)));\n      // mark close to zero points with white --\n      col += onlyWithE(d, 1. / nGridCells, 0.);\n    }\n\n    // grid lines\n    col *= product(1. - step(.48, abs(gv)));\n    // mark slice near z==0 with green square\n    col.g += (only(zId, 0.) + .5 * onlyWithE(p.z, .3, 0.)) * step(.5 - fwg, bestOf(abs(gv)));\n    // mark bottom left with red square (indicating pos reset on mouseover)\n    col.r += (only(id.x, 0.) * only(id.y, 0.)) * step(.5 - fwg, bestOf(abs(gv)));\n\n\n    // black out squares outside core grid\n    col *= vec3(\n      step(.0, id.x) * step(- gridSize + 1., -id.x)\n      * step(.0, id.y) * step(- gridSize + 1., -id.y)\n    );\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "/* copy pasted from my libs. lots is written by me. you're welcome to use it, but caveat emptor. */\n\n#define u_resolution iResolution\n#define u_mouse iMouse\n#define u_time iTime\n#define gl_FragColor fragColor\n\n#define PI 3.141592653589\n#define TAU 6.28318530718\n\n#define SQRT_3 1.7320508\n#define SQRT_2 1.41421356\n\n#define S(a, b, t)smoothstep(a, b, t)\n#define hh(x)(x * 0.5 + 0.5)\n#define zoth vec4(0.0, 1.0, 2.0, 0.5)\n\n#define BLACK vec3(0.0)\n#define WHITE vec3(1.0)\n\n\nvec2 scaleUvWithAspect(vec2 st, float aspect) {\n  float scaleX = step(1.0, aspect), scaleY = 1. - scaleX;\n  aspect = max(aspect, 1. / aspect);\n  st.x = st.x * scaleY + scaleX * (st.x * aspect - (aspect - 1.) / 2.);\n  st.y = st.y * scaleX + scaleY * (st.y * aspect - (aspect - 1.) / 2.);\n  return st - .5;\n}\n\nvoid setIDGV(vec2 uv, float perAxis, out vec2 id, out vec2 gv) {\n  // returns a screen aligned grid with >= perAxis squares per axis, where\n  // all ID values that will be on any screen, are >= 0.\n  float odd = fract(perAxis / 2.) * 2.;\n  float adjID = floor(perAxis * .5 - .5) + 1.;\n  float scale = perAxis * 1.0;\n  vec2 idgvInput = uv * scale - 0.5 * odd;\n  id = floor(idgvInput) + adjID;\n  gv = fract(idgvInput) - 0.5;\n}\n\nvec2 best2(vec3 p) {\n  vec2 r = vec2(max(p.x, p.y), min(p.x, p.y)); // : vec2(p.y, p.x);\n  if (p.z > r.x) { return vec2(p.z, r.x);}\n  if (p.z > r.y) { return vec2(r.x, p.z);}\n  return r;\n}\n\nvec2 best2(vec4 p) {\n  vec2 r = p.x > p.y ? vec2(p.x, p.y) : vec2(p.y, p.x);\n  if (p.z > r.x) { r = vec2(p.z, r.x); }\n  else if (p.z > r.y) { r = vec2(r.x, p.z); }\n  if (p.w > r.x) { return vec2(p.w, r.x); }\n  else if (p.w > r.y) { return vec2(r.x, p.w); }\n  return r;\n}\n\nvec3 best3(vec4 p) {\n  vec2 zw = vec2(max(p.z, p.w), min(p.z, p.w));\n  // p.z > p.w ? vec2(p.z, p.w) : vec2(p.w, p.z);\n  vec2 xy = vec2(max(p.x, p.y), min(p.x, p.y));\n  if (xy.y > zw.x) {return vec3(xy, zw.x);} // testme\n  if (zw.y > xy.x) {return vec3(zw, xy.x);}\n  return vec3(max(xy.x, zw.x), min(xy.x, zw.x), max(xy.y, zw.y));\n\n  /* tests\n  col = best2(zoth.xyz) == vec2(2., 1.) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.zywx) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.wxzy) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.wxyz) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.xywz) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  */\n}\n\nfloat minOf(vec2 v) {\n  return min(v.x, v.y);\n}\nfloat maxOf(vec2 v) {\n  return max(v.x, v.y);\n}\nfloat sumOf(vec2 v) {\n  return v.x + v.y;\n}\n\nfloat minOf(vec3 v) {\n  return min(minOf(v.xy), v.z);\n}\nfloat maxOf(vec3 v) {\n  return max(maxOf(v.xy), v.z);\n}\nfloat sumOf(vec3 v) {\n  return sumOf(v.xy) + v.z;\n}\n\nfloat minOf(vec4 v) {\n  return min(minOf(v.xyz), v.w);\n}\nfloat maxOf(vec4 v) {\n  return max(maxOf(v.xyz), v.w);\n}\nfloat sumOf(vec4 v) {\n  return sumOf(v.xyz) + v.w;\n}\n\nfloat bestOf(vec2 p) {\n  // return p.x > p.y ? p.x : p.y;\n  return max(p.x, p.y);\n}\nfloat bestOf(vec3 p) {\n  return max(max(p.x, p.y), p.z);\n}\nfloat bestOf(vec4 p) {\n  return max(bestOf(p.xyz), p.w);\n}\n\n\nvec2 sinCos(in vec2 ab) {\n  return vec2(sin(ab.x), cos(ab.y));\n}\nvec2 sinCos(in float a) {\n  return vec2(sin(a), cos(a));\n}\n\n// roll from XY to XZ or YZ (0 no roll, 1=XZ, 2=YZ)\nmat3 rot3XY(float angle, int roll) {\n  float s = sin(angle), c = cos(angle);\n  mat3 r = mat3(c, - s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n  if (roll == 1) {\n    r = mat3(r[0].xzy, r[2].xzy, r[1].xzy);\n  } else if (roll == 2) {\n    r = mat3(r[2].zxy, r[0].zxy, r[1].zxy);\n  }\n  return r;\n}\n\n\nmat4 rot4(float angle, int axis) {\n  float s = sin(angle), c = cos(angle);\n  mat4 r = mat4(\n    c, -s, 0, 0,\n    s, c, 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 1\n  );\n  // XY, XZ, XW\n  return axis == 0 ? r\n    : axis == 1 ? mat4(r[0].xzyw, r[2].xzyw, r[1].xzyw, r[3].xzyw)\n    : axis == 2 ? mat4(r[0].xwzy, r[3].xwzy, r[2].xwzy, r[1].xwzy)\n    // YZ, YW\n    : axis == 3 ? mat4(r[3].wxyz, r[0].wxyz, r[1].wxyz, r[2].wxyz)\n    : axis == 4 ? mat4(r[3].wxzy, r[0].wxzy, r[1].wxzy, r[2].wxzy)\n    // ZW\n    : axis == 5 ? mat4(r[3].wzxy, r[2].wzxy, r[0].wzxy, r[1].wzxy) : mat4(0.);\n}\n\n\n\nvec2 minWith(vec2 a, vec2 b) {\n  return (min(0., (a.x - b.x)) * a + min(0., (b.x - a.x)) * b) * -1. / abs(b.x - a.x);\n}\nvec4 minWith14(float a, vec4 av, float b, vec4 bv) {\n  float ba = b - a;\n  return (max(0., ba) * av + max(0., -ba) * bv) * -1. / abs(ba);\n  return b > a ? bv : av;\n}\n\n\nfloat onlyWithE(float edge, float e, float x) {\n  return 1.0 - step(e, abs(x - edge));\n}\n\nfloat only(float edge, float x) {\n  return onlyWithE(edge, 1.0 / 1e07, x);\n}\n\nfloat product(vec2 v) {\n  return v.x * v.y;\n}\nfloat product(vec3 v) {\n  return product(v.xy) * v.z;\n}\nfloat product(vec4 v) {\n  return product(v.xyz) * v.w;\n}\n\n/*\n// Some SDFs\n\nfloat sdTriangle1(vec2 uv, float b) {\n  float willFold = sign(step(.0, -uv.x) + (step(.0, -uv.y) * step(0., -dot(sinCos(TAU / 12.), uv))));\n  float splitAt = -dot(sinCos(- 7. * TAU / 12.), uv);\n  float top = sign(splitAt);\n  float foldAngle = (step(0., top) * TAU / 4. + step(0., -top) * (TAU / 12.)) * willFold;\n  vec2 n = sinCos(foldAngle);\n  float fold = -dot(n, uv) * willFold;\n  uv += fold * n * 2.;\n  // get distance to line that is our edge\n  return dot(uv, sinCos(TAU / 6.)) - b * .5;\n}\n\nvec4 sdTriangle1(vec3 p, float b) {\n  return vec4(length(vec2(sdTriangle1(p.xy, b), p.z)), abs(p)); // approximate dists for each axis\n}\n\nfloat sdTriangle2(vec2 uv, float b) {\n  float a = atan(uv.x, uv.y) + PI;\n  float id = floor(a * 3. / TAU) - 1.;\n  vec2 n = sinCos(-id * 7. * TAU / 12.);\n  uv += - abs(id) * dot(n, uv) * n * 2.;\n  return  uv.y - b / 2.;  // estimate based only on y; but it works...\n}\n\nvec4 sdTriangle2(vec3 p, float b) {\n  vec3 dd = abs(p) - vec3(0,b,0);\n  return vec4(length(vec2(sdTriangle2(p.xy, b), p.z)), dd);\n}\n\nvec2 foldXyThirds(vec2 uv, out float id) {\n  float a = atan(uv.x, uv.y) + PI;\n  id = floor(a * 3. / TAU) - 1.;\n  vec2 n = sinCos(-id * 7. * TAU / 12.);\n  uv += - abs(id) * dot(n, uv) * n * 2.;\n  return abs(uv);\n}\n\nvec2 foldXyThirds(vec2 uv) {\n  float id;\n  return foldXyThirds(uv, id);\n}\n\nfloat sdTriangleGen(vec3 p, float r, out vec3 dists) {\n  p.xy = foldXyThirds(p.xy);\n\n  vec3 a = vec3(r / 2. * SQRT_3, r / 2., 0.);\n  vec3 b = a * vec3(-1, 1, 1);\n  vec3 ap = p - a;\n  vec3 ab = b - a;\n  //* (step(r / 2., p.y) * 2. - 1.)\n  float dotPaBa = dot(ap, ab);\n  float dotBaBa = dot(ab, ab);\n  float h = clamp(dotPaBa / dotBaBa, -0., 1.);\n  dists = ap - h * ab;\n  float d = length(dists);\n  // for negative:\n  // * (step(r / 2., p.y) * 2. - 1.);\n\n  return d;\n}\n\n*/\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl2SWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[217, 217, 281, 281, 778], [781, 781, 836, 836, 2650]], "test": "untested"}
{"id": "Nl2SDW", "name": "Fractal 72_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 7, "viewed": 361, "published": 3, "date": "1627692352", "time_retrieved": "2024-07-30T19:08:29.652109", "image_code": "#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=0.;\n        ++i<99.;\n        e<.001?O.rgb+=mix(vec3(1),H(log(s)*.2),.7)*.1*exp(-i*i*e):r\n    )\n    {\n        p=g*d;\n        p+=vec3(\n            fract(sin(floor(iTime))*15.),\n            fract(sin(floor(iTime*.8))*12.),\n            iTime*.05\n        );\n        vec4 q=vec4(p,.01);\n        s=2.;\n        q=sin(q*20.);\n        for(int i=0;i++<6;q=abs(q)*e)\n            q=abs(q-1.5)-1.2,\n            s*=e=2.3/clamp(dot(q,q),.5,1.2);\n        g+=e=length(q.zw)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2SDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 83, 83, 660]], "test": "untested"}
{"id": "stBXDD", "name": "Permuting Pixels to Target", "author": "Gegell", "description": "Tries to permute the pixels from one source image (iChannel0) to best fit another target image (iChannel1).\nThe respective channels are both to be found in the tab for buffer A.\n\nThe sim might have to be restarted so that the init may occur correctly.", "tags": ["permutation"], "likes": 4, "viewed": 335, "published": 3, "date": "1627687428", "time_retrieved": "2024-07-30T19:08:30.450974", "image_code": "// See the actual shader in the tab of Buffer A.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define GET_OTHER_VERSION 1\n\n// RNG from https://de.wikipedia.org/wiki/Xorshift\nint rngSeed = 314159265;\n\nint xorshift(in int value) {\n    value ^= value << 13;\n    value ^= value >> 17;\n    value ^= value << 5;\n    return value;\n}\n\nint nextInt() {\n    rngSeed = xorshift(rngSeed);\n    return rngSeed;\n}\n\n// True only when the given position is within the view port.\nbool inView(ivec2 pos) {\n    return all(greaterThanEqual(pos, ivec2(0))) && all(lessThan(pos, ivec2(iResolution.xy)));\n}\n\n// Flatten the 2d position into a 1d index\nint flatten(ivec2 position) {\n    return position.x + position.y * int(iResolution.x);\n}\n\n// Unflatten the 1d index into a 2d position\nivec2 unflatten(int index) {\n    return ivec2(index % int(iResolution.x), index / int(iResolution.x));\n}\n\n// Get the other pixel to a specific one with set random vector.\n// Needs to be self inverse with set random value, i.e: getOther(getOther(p, r), r) = p\nivec2 getOther(ivec2 current, ivec2 random) {\n#if GET_OTHER_VERSION == 0\n    ivec2 res = ivec2(iResolution.xy);\n    random = random % res;\n    random |= 1; \n    if (((current.x ^ current.y) & 1) == 0) {\n        return (current + random) % res;\n    } else {\n        return (current - random + res) % res;\n    }\n#else\n    int res = flatten(ivec2(iResolution.xy));\n    random |= 1;\n    random %= res;\n    int index = flatten(current); \n    if ((index & 1) == 0) {\n        return unflatten((index + random.x) % res);\n    } else {\n        return unflatten((index - random.x + res) % res);\n    }\n#endif\n}\n\n// Compute this rounds random offset vector and return the pixel corresponding to the given and random vector.\nivec2 getOther(ivec2 current) {\n    ivec2 random = ivec2(nextInt(), nextInt()) & 0x7FFFFFFF;\n    ivec2 other = getOther(current, random);\n    if (inView(other) && all(equal( getOther(other, random), current )) ) {\n        return other;\n    }\n    return current;\n}\n\n// The color difference between two colors. \nfloat colorDiff(vec3 a, vec3 b) {\n    // TODO try better difference, i.e. CIE or ITU, see https://en.wikipedia.org/wiki/Color_difference\n    \n    // Currently use squared euclidean distance of RGB values.\n    return dot(a-b, a-b);\n}\n\nfloat colorDiff(vec4 a, vec4 b) {\n    return colorDiff(a.rgb, b.rgb);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Init the RNG with a *different* semi random value every pass.\n    // Thus no need to store the RNG state after each frame.\n    rngSeed = floatBitsToInt(sin(float(iFrame)) + 2.);\n\n    // Compute both the pixel and uv coords for the current pixel\n    // and the potential swap partner.\n    ivec2 pos = ivec2(fragCoord);\n    ivec2 posOther = getOther(pos);\n    \n    vec2 uv = vec2(pos) / iResolution.xy;\n    vec2 uvOther = vec2(posOther) / iResolution.xy;\n    \n    vec4 col;\n    if (iFrame <= 20) {\n        // Init the temporally persistent buffer with the first image (source).\n        // This is done for the first 20 frames, so that initalization upon site load may occur.\n        col = texture(iChannel0, uv); \n    } else {\n        vec4 target = textureLod(iChannel1, uv, 0.);\n        vec4 targetOther = textureLod(iChannel1, uvOther, 0.);\n        \n        vec4 current = texelFetch(iChannel2, pos, 0);\n        vec4 currentOther = texelFetch(iChannel2, posOther, 0);\n        \n        // Compute the parts of the heuristic that may change upon a pixel swap. \n        float currentDiff = colorDiff(current, target) + colorDiff(currentOther, targetOther);\n        float swappedDiff = colorDiff(current, targetOther) + colorDiff(currentOther, target);\n        \n        // Swap if the heuristic impoves.\n        if (swappedDiff < currentDiff) {\n            col = currentOther;\n        } else {\n            col = current;\n        }\n    }\n    \n    // Output to buffer\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stBXDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 107, 107, 169]], "test": "untested"}
{"id": "Nt2SWW", "name": "Spiked Mandelbulb", "author": "lambmeow", "description": "A modified version of the mandelbulb", "tags": ["fractal", "sdf", "mandelbulb", "spike"], "likes": 3, "viewed": 299, "published": 3, "date": "1627681493", "time_retrieved": "2024-07-30T19:08:31.326632", "image_code": "#define time iTime\n\nvec2 scene(vec3 p)\n{\n\tfloat po=5.+4.0*(sin(time/30.)+1.);\n\tvec3 z=p;\n\tfloat dr=1.0, r=0.;\n\t//p.xy*=mat2(cos(time),sin(time),-sin(time),cos(time))*p.xz;\n\tfor(int i=0;i<64;i++)\n\t{\n\t\tp.xz*=mat2(cos(time),sin(time),-sin(time),cos(time)) * p.xz;\n\t\tr=length(z);\n\t\tif(r>1.4)break;\n\t\tfloat t=atan(z.z/r), ph = atan(z.y,z.x);\n\t\tdr=pow(r,po-1.)*po*dr+1.;\n\t\tfloat zr=pow(r,po);\n\t\tt*=po;\n\t\tph*=po;\n\t\tz=zr*vec3(sin(t)*cos(ph),sin(ph)*cos(t),cos(t));\n\t\tz+=p;\n\t}\n\treturn vec2(0.5*log(r)*r/dr,r * 25.);\n}\n\nvec4 rc(vec3 ro,vec3 rd) \n{\n\tfloat len=0.;\n\tfor(int i=0;i<255;i++)\n\t{\n\t\tvec3 pos=ro+rd*len;\n\t\tvec2 dist=scene(pos);\n\t\tif(dist.x<0.001) return vec4(pos,dist.y);\n\t\tlen+=dist.x;\n\t\tif(dist.x>100.) break;\n\t}\n\treturn vec4(100);\n}\nvoid mainImage(out vec4 c, in vec2 f)\n{\n\tvec2 r = iResolution.xy, u=((f)*2.- r)/r.y;\n\tvec3 ro=vec3(0,0,-3);\n\tvec3 rd=normalize(vec3(u,2.));\n\tvec4 bulb=rc(ro,rd);\n\tfloat lol=1.-bulb.w+10.;\n\tfloat len=length(bulb.xyz-ro);\n\tc=vec4(bulb.w*0.0052);\n\tc*=1./(len-1.);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2SWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 40, 40, 508], [510, 510, 537, 537, 733], [734, 734, 773, 773, 996]], "test": "untested"}
{"id": "slBXWD", "name": "XOR Towers in Rain V3", "author": "GregRostami", "description": "Another variation of KilledByAPixel's Voxel Fractal:\n[url]https://www.shadertoy.com/view/NlB3Rz[/url]\nRain code from P_Malin's SmallStars\n[url]https://www.shadertoy.com/view/Ml2XDt[/code]", "tags": ["3d", "voxel", "fog", "rain", "city", "lights"], "likes": 15, "viewed": 514, "published": 3, "date": "1627671898", "time_retrieved": "2024-07-30T19:08:32.085603", "image_code": "// Fork of \"XOR Towers in Fog & Rain\" by GregRostami. https://shadertoy.com/view/7lsXR2\n// Thanks to P_Malin's SmallStars code for the rain.\n// Place a \"//\" in front of each line with a \"*\" in the comments to turn that feature off. \n\nvoid mainImage(out vec4 o, vec2 u)\n{\n     vec2 R = iResolution.xy;\n    ivec4 b = ivec4(o -= o);                   // Initialize b=0\n    float t = .1*iTime, B, h, z, i=0.;\n     vec4 g;\n            \n    u =\n        (2. + cos(t)) *                        // * Camera push in/out \n        (u+u-R)/R.y                            //   Center coordinates\n        * mat2( cos( vec4(0,33,55,0) - .1*t))  // * Rotate camera\n        ;\n        \n    z = (h = cos(B = ceil(atan(u.x, u.y) * 2e2))) / dot(u,u);  //Variables for Rain\n    \n    for (;i<3.;)\n    g += pow(texture(iChannel2,.5*u + .1*sin(t/.1+(i+=.04)+3.*u) ),g-g+8.); // Ground ghosts\n            \n    for (; (b.x^b.y^b.z)%99 > b.z-8 ; )        // The XOR function for towers!!\n        b = ivec4(u * o.a + 2e2\n                + vec2(7,30)*t                 // * Move camera (x,y)\n                , o+=.1 );                     // Increment layer\n                \n    o =\n        o.a < 8.1 ? .1+sin(t/.1)*vec4(b%32 & b.x%9 & b.z%9) :  // * Blinking lights\n        o/80. - .02 *                                          // * Distance fog\n        vec4(b%3)                                              // * Building colors\n        + .2*(o.a > 17. ? vec4( int(.5+sin(float(b.x/2 + b.y + 2*b.z))) & b.x & b.y & int(.5+sin(4.*o.a-3.4)) ) : g-g) // * Windows\n        + (o.a > 50. ? g*vec4(.15,.4,1,0) : g-g)               // * Ground ghosts\n        + .06*texture( iChannel1, .02*u - .03*t ).r            // * Moving fog\n        + .01*max(exp(fract(h * B - z + t+t) * -1e2) / z,0.)   // * Rain\n        ;\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27906, "src": "https://soundcloud.com/hanangobran/violin-crying-rain", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slBXWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[234, 234, 270, 270, 1778]], "test": "untested"}
{"id": "7lSSWD", "name": "part of texture", "author": "hero2002", "description": "n", "tags": ["t"], "likes": 0, "viewed": 200, "published": 3, "date": "1627665222", "time_retrieved": "2024-07-30T19:08:32.931342", "image_code": "precision mediump float;\nuniform sampler2D spriteSheet;\nuniform vec2 spriteSheetSize;   // In px\nuniform vec2 spriteSize;        // In px\nuniform float index;            // Sprite index in sprite sheet (0-...)\nuniform vec2 vcoord;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float w = 1024.0;\n    float h = 1024.0;\n    // Normalize sprite size (0.0-1.0)\n    float dx = 64.0 / w;\n    float dy = 64.0 / h;\n    // Figure out number of tile cols of sprite sheet\n    float cols = w / 64.0;\n    // From linear index to row/col pair\n    float col = mod(50.0, cols);\n    float row = floor(50.0 / cols);\n    // Finally to UV texture coordinates\n    vec2 uv = vec2(dx * fragCoord.x + col * dx, 1.0 - dy - row * dy + dy * fragCoord.y);\n    fragColor = texture(spriteSheet, uv);\n} \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lSSWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[231, 231, 287, 287, 785]], "test": "untested"}
{"id": "7lBXWW", "name": "Fo Reproject cam refract laser", "author": "ollj", "description": "Camera controls are WASD and QE for roll.\nN shoots a beam. R reset accumulation.\n\nStoring a light path and then using it for next event estimation in path tracing,the NEE is importance sampled so that the probability of hitting a light path is maximized.", "tags": ["camera", "pathtracer", "laser", "bidirectional"], "likes": 17, "viewed": 508, "published": 3, "date": "1627661470", "time_retrieved": "2024-07-30T19:08:34.061321", "image_code": "// Fork of \"Volumetric laser tracer\" by michael0884. https://shadertoy.com/view/NtXSR4\n// 2021-07-22 19:27:50\n\nvec3 encodeSRGB(vec3 linearRGB)\n{\n    vec3 a = 12.92 * linearRGB;\n    vec3 b = 1.055 * pow(linearRGB, vec3(1.0 / 2.)) - 0.055;\n    vec3 c = step(vec3(0.0031308), linearRGB);\n    return mix(a, b, c);\n}\n\nvec3 tone(vec3 c)\n{\n    c = XYZtosRGB(c);\n    return tanh(encodeSRGB(c));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 acc = texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor = vec4(tone(0.1*acc.xyz/acc.w), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//controller\n\n//Keyboard constants\nconst int keyLe = 37, keyUp = 38, keyRi = 39, keyDn = 40, keyA = 65, keyB = 66, keyC = 67, keyD = 68, keyE = 69, keyF = 70, keyG = 71, keyH = 72, keyI = 73, keyJ = 74, keyK = 75, keyL = 76, keyM = 77, keyN = 78, keyO = 79, keyP = 80, keyQ = 81, keyR = 82, keyS = 83, keyT = 84, keyU = 85, keyV = 86, keyW = 87, keyX = 88, keyY = 89, keyZ = 90;\n\nbool pressed(int k) \n{\n    return texelFetch(iChannel3, ivec2(k, 0), 0).x > 0.5;\n}\n\nconst float force =25.0;\nconst float mouse_sens = 100.0;\nconst float roll_speed = 0.5;\n\nvoid mainImage( out vec4 o, in vec2 p )\n{\n    p = floor(p);\n    if(p.x > NAddr && p.y > 0.) discard;\n    \n    //get camera data\n    vec3 cp = get(CamP).xyz;\n    vec4 ca = normalize(get(CamA));\n    \n    vec3 pcp = cp;\n    vec4 pca = ca;\n    \n    vec3 ro = get(RayO).xyz;\n    vec3 rd = get(RayD).xyz;\n    \n    float mode = 0.0;\n    if(pressed(keyR)) mode = 1.0;\n    \n    //initialization\n    if(iFrame < 10)\n    {\n        cp = vec3(-1.,1.5,-1);\n        ca = aa2q( normalize(vec3(0,1,0)), -PI*0.6/4.0);\n        mat3 cam = getCam(ca);\n        ca = qq2q(ca, aa2q(cam*vec3(1,0,0), -PI*0.4/4.0)); \n        ro = vec3( -2,.252, 0);\n        rd = normalize(vec3(0.3,0.,-0.002));\n    }\n    vec4 oldca = ca;\n    if(p.x == PrevCamP) o = vec4(cp, 0);\n    if(p.x == PrevCamA) o = ca;\n    \n    mat3 cam = getCam(ca);\n    \n    //get velocities\n    vec3 cv = get(CamV).xyz;\n    vec4 cav = get(CamAV);\n    \n    float dt = 1./60.0;\n    //update position\n    if(pressed(keyW)) cv += force*dt*cam*vec3(0,0,1);\n    if(pressed(keyS)) cv += force*dt*cam*vec3(0,0,-1);\n    if(pressed(keyA)) cv += force*dt*cam*vec3(-1,0,0);\n    if(pressed(keyD)) cv += force*dt*cam*vec3(1,0,0);\n    \n    cp += dt*cv;\n    cv += -cv*tanh(10.0*dt);\n    \n    //update camera orientation\n    vec2 dmouse = dt*mouse_sens*(iMouse.xy - get(PrevMouse).xy)/iResolution.x;\n    \n    if(length(dmouse) < 0.1)\n    {\n        //rotate around y ax\n        ca = qq2q(ca, aa2q(cam*vec3(0,1,0), -dmouse.x)); \n        //rotate around x ax\n        ca = qq2q(ca, aa2q(cam*vec3(1,0,0), dmouse.y));\n    }\n    \n    //roll camera\n    if(pressed(keyQ)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), -roll_speed*dt)); \n    if(pressed(keyE)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), roll_speed*dt)); \n    \n    if(distance(oldca, ca) > 0.001 || length(cv) > 0.01) mode = 1.0;\n    \n    if(pressed(keyN)) \n    {\n        rd = cam*vec3(0,0,1);\n        ro = cp + 0.05*cam*vec3(1,1,0);\n    }\n    \n    if(p.x == CamP) o = vec4(cp, mode);\n    if(p.x == CamA) o = ca;\n    if(p.x == PrevCamP) o = vec4(pcp, mode);\n    if(p.x == PrevCamA) o = pca;\n    if(p.x == CamV) o = vec4(cv, 0.0);\n    if(p.x == CamAV) o = vec4(0.0);\n    if(p.x == PrevMouse) o = vec4(iMouse.xy, 0, 0);\n    if(p.x == RayO) o = vec4(ro, 0);\n    if(p.x == RayD) o = vec4(rd, 0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n#define FOV 1.1\n#define CAM_ANGLE 0.001\n#define MAX_STEPS 90\n#define MIN_DIST 1e-5\n#define MAX_DIST 500.0\n\n//(reused some of @ollj's code, made it more readible)\n\nvec3 light = normalize(vec3(0,1,0));\nconst float light_bright =1.0;\nconst float light_ang = 0.1;\n\n//specific controller buffer Addresses\nconst float CamP = 0.,     //camera position \n            CamA = 1.,     //camera rotation quaternion    \n            CamV = 2.,     //camera velocity\n            CamAV = 3.,    //camera rotation velocity\n            PrevCamP = 4., //previous frame camera position\n            PrevCamA = 5., //previous frame camera rotation quaternion\n            PrevMouse = 6.,//previous mouse pos\n            RayO = 7.,     //previous mouse pos\n            RayD = 8.,     //previous mouse pos\n            NAddr = 9.;    //max address count\n            \n#define get(i) texelFetch(iChannel2,ivec2(i,0),0)\n\nfloat sqr(float x)\n{\n    return x*x;\n}\n\nvec3 reproject(mat3 pcam_mat, vec3 pcam_pos, vec2 iRes, vec3 p)\n{\n    float td = distance(pcam_pos, p);\n    vec3 dir = (p - pcam_pos)/td;\n    vec3 screen = dir*pcam_mat;\n    return vec3(screen.xy*iRes.y/(FOV*screen.z) + 0.5*iRes.xy, td);\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n              in vec3 planeNormal, in float planeDist) {\n    float a = dot(rd, planeNormal);\n    float d = -(dot(ro, planeNormal)+planeDist)/a;\n    if (a > 0. || d < distBound.x || d > distBound.y) {\n        return MAX_DIST;\n    } else {\n        normal = planeNormal;\n    \treturn d;\n    }\n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n               float sphereRadius ) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - sphereRadius*sphereRadius;\n    float h = b*b - c;\n    if (h < 0.) {\n        return MAX_DIST;\n    } else {\n\t    h = sqrt(h);\n        float d1 = -b-h;\n        float d2 = -b+h;\n        if (d1 >= distBound.x && d1 <= distBound.y) {\n            normal = normalize(ro + rd*d1);\n            return d1;\n        } else if (d2 >= distBound.x && d2 <= distBound.y) { \n            normal = normalize(ro + rd*d2);            \n            return d2;\n        } else {\n            return MAX_DIST;\n        }\n    }\n}\n\nfloat iBox( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal, \n            in vec3 boxSize ) {\n    vec3 m = sign(rd)/max(abs(rd), 1e-8);\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if (tN > tF || tF <= 0.) {\n        return MAX_DIST;\n    } else {\n        if (tN >= distBound.x && tN <= distBound.y) {\n        \tnormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n            return tN;\n        } else if (tF >= distBound.x && tF <= distBound.y) { \n        \tnormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n            return tF;\n        } else {\n            return MAX_DIST;\n        }\n    }\n}\n\nfloat iCylinder( in vec3 ro, in vec3 rd, \n                in vec3 pa, in vec3 pb, float ra ) // extreme a, extreme b, radius\n{\n    vec3 ba = pb-pa;\n\n    vec3  oc = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoc = dot(ba,oc);\n    \n    float k2 = baba            - bard*bard;\n    float k1 = baba*dot(oc,rd) - baoc*bard;\n    float k0 = baba*dot(oc,oc) - baoc*baoc - ra*ra*baba;\n    \n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return 1e10;\n    h = sqrt(h);\n    float t = (-k1-h)/k2;\n\n    // body\n    float y = baoc + t*bard;\n    if( y>0.0 && y<baba ) return t;\n    \n    // caps\n    t = ( ((y<0.0) ? 0.0 : baba) - baoc)/bard;\n    if( abs(k1+k2*t)<h )\n    {\n        return t;\n    }\n\n    return 1e10;\n}\n\n//ollj quaternionRotation math\n//\n//ANY rotations in 3d are non-commutative!\n//\n//matrix rotations are just bulky, memory wasting\n//EulerRotations almost certainly fail to rotate over the SHORTEST path.\n//EulerRotations almost certainly will gimbalLock and get stuck along one axis\n//QuaternionRotations are superior here.\n//-> we only use EulerRorations for simple input devices (keyboard input)\n//-> we convert to quaternions, buffered as vec4.\n\n//quaternion Identity\nvec4 qid() \n{\n    return vec4(0, 0, 0, 1);\n}\n\n//return quaternion from axis and angle\nvec4 aa2q(vec3 axis, float ang) \n{\n    vec2 g = vec2(sin(ang), cos(ang)) * 0.5;\n    return normalize(vec4(axis * g.x, g.y));\n}\n\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q) \n{\n    return vec4(q.xyz / sqrt(1.0 - q.w * q.w), acos(q.w) * 2.);\n}\n\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2) \n{\n    return vec4(q1.xyz * q2.w + q2.xyz * q1.w + cross(q1.xyz, q2.xyz), (q1.w * q2.w) - dot(q1.xyz, q2.xyz));\n}\n\n//extension to qq2q(), scaled by sensitivity [f] (==quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f) \n{\n    float d = dot(a, b), t = acos(abs(d)), o = (1. / sin(t));\n    return normalize(a * sin(t * (1.0 - f)) * o * sign(d) + b * sin(t * f) * o);\n}\n\n//doing qq2q() multiple times, you need to normalize() the quaternion, to fix rounding errors.\n//how often you do this is up to you.\n\n//normalize q (assuming length(q) is already close to 1, we can skip whe sqrt()\nvec4 qn(vec4 q) \n{\n    return q / dot(q,q);\n}\n\n//return quaternion, that is the shortest rotation, between looking to [a before], and looking to [b after] the rotation.\n//http://wiki.secondlife.com/wiki/LlRotBetween\nvec4 qBetween(vec3 a, vec3 b) \n{\n    float v = sqrt(dot(a,a) * dot(a,a));\n\n    if(v == 0.) return qid();\n    \n    v = dot(a, b) / v;\n    vec3 c = a.yzx * b.zxy - a.zxy * b.yzx / v;\n    float d = dot(c,c);\n    \n    if(d != 0.) \n    {\n        float s = (v > - 0.707107) ? 1. + v : d / (1. + sqrt(1. - d));\n        return vec4(c, s) / sqrt(d + s * s);\n    }\n    \n    if(v > 0.) return qid();\n    \n    float m = length(a.xy);\n    \n    return (m != 0.) ? vec4(a.y, - a.x, 0, 0) / m : vec4(1, 0, 0, 0);\n}\n\n//return inverse of quaternion\nvec4 qinv(vec4 q) \n{\n    return vec4(- q.xyz, q.w) / dot(q,q);\n}\n\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q, vec3 p) \n{\n    return qq2q(q, qq2q(vec4(p, .0), qinv(q))).xyz;\n}\n\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it is rotated by VECTOR p (as if it is a quaternion)\nvec3 vq2v(vec3 p, vec4 q) \n{\n    return qq2q(qinv(q), qq2q(vec4(p, 0.0), q)).xyz;\n}\n\nvec3 vq2v(vec4 a, vec3 b) \n{\n    return qv2v(a, b);\n}\n\n//in case of namespace confuction\nvec3 qv2v(vec3 a, vec4 b) \n{\n    return vq2v(a, b);\n}\n\n//return mat3 of quaternion (rotation matrix without translation)\n//https://www.shadertoy.com/view/WsGfWm\nmat3 q2m(vec4 q) \n{\n    vec3 a = vec3(-1, 1, 1);\n    vec3 u = q.zyz * a, v = q.xyx * a.xxy;\n    mat3 m = mat3(0.5) + mat3(0, u.x,u.y,u.z, 0, v.x,v.y,v.z, 0) * q.w + matrixCompMult(outerProduct(q.xyz, q.xyz), 1. - mat3(1));\n    q *= q; \n    m -= mat3(q.y + q.z, 0, 0, 0, q.x + q.z, 0, 0, 0, q.x + q.y);\n    return m * 2.0;\n}\n\n//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\nvec4 m2q(mat3 m) \n{\n#define m2f(a,b) m[a][b]-m[b][a]\n    //http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n    float q = 2. * sqrt(abs(1. + m[0][0] + m[1][1] + m[2][2]));\n    return vec4(vec3(m2f(2, 1), m2f(0, 1), m2f(1, 0)) / q / 4., q);\n#undef m2f\n}\n\nfloat at2e(vec2 a) \n{\n    a *= 2.;\n    return atan(a.x, 1. - a.y);\n}\n\n//return quaternion of Euler[yaw,pitch,roll]     \nvec4 eYPR2q(vec3 o) \n{\n    o *= .5;\n    vec3 s = sin(o);\n    //https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n    o = cos(o);\n    vec4 a = vec4(s.xz, o.xz);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(-1, 1, -1, 1);\n}\n\nvec4 eYPR2q(vec2 o) \n{\n    o *= .5;\n    vec2 s = sin(o);\n    o = cos(o);\n    vec4 a = vec4(s.x, 0., o.x, 0.);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(- 1, 1, - 1, 1);\n}\n\nmat3 getCam(vec4 q) \n{\n    return q2m(q);\n}\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nuvec4 pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    return v;\n}\n\nfloat rand(){ return float(pcg4d(s0).x)/float(0xffffffffu); }\nvec2 rand2(){ return vec2(pcg4d(s0).xy)/float(0xffffffffu); }\nvec3 rand3(){ return vec3(pcg4d(s0).xyz)/float(0xffffffffu); }\nvec4 rand4(){ return vec4(pcg4d(s0))/float(0xffffffffu); }\n\nvec2 nrand2(float sigma, vec2 mean)\n{\n\tvec2 Z = rand2();\n    return mean + sigma * sqrt(-2.0 * log(Z.x)) * \n           vec2(cos(TWO_PI * Z.y),sin(TWO_PI * Z.y));\n}\n\nvec3 nrand3(float sigma, vec3 mean)\n{\n\tvec4 Z = rand4();\n    return mean + sigma * sqrt(-2.0 * log(Z.xxy)) * \n           vec3(cos(TWO_PI * Z.z),sin(TWO_PI * Z.z),cos(TWO_PI * Z.w));\n}\n\n//uniformly spherically distributed\nvec3 udir(vec2 rng)\n{\n    vec2 r = vec2(2.*PI*rng.x, acos(2.*rng.y-1.));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}\n\nconst float PI2 = 6.2831853071;\n\nconst float aperture_size = 0.0;\nvec2 aperture()\n{\n    vec2 r = rand2();\n    return vec2(sin(TWO_PI*r.x), cos(TWO_PI*r.x))*sqrt(r.y);\n}\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\nvec3 spectral_zucconi(float w)\n{\n    // w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\n\tconst vec3 cs = vec3(3.54541723, 2.86670055, 2.29421995);\n\tconst vec3 xs = vec3(0.69548916, 0.49416934, 0.28269708);\n\tconst vec3 ys = vec3(0.02320775, 0.15936245, 0.53520021);\n\n\treturn bump3y (\tcs * (x - xs), ys);\n}\n\nvec3 spectral_bruton (float w)\n{\n\tvec3 c;\n\n\tif (w >= 380. && w < 440.)\n\t\tc = vec3\n\t\t(\n\t\t\t-(w - 440.) / (440. - 380.),\n\t\t\t0.0,\n\t\t\t1.0\n\t\t);\n\telse if (w >= 440. && w < 490.)\n\t\tc = vec3\n\t\t(\n\t\t\t0.0,\n\t\t\t(w - 440.) / (490. - 440.),\n\t\t\t1.0\n\t\t);\n\telse if (w >= 490. && w < 510.)\n\t\tc = vec3\n\t\t(\t0.0,\n\t\t\t1.0,\n\t\t\t-(w - 510.) / (510. - 490.)\n\t\t);\n\telse if (w >= 510. && w < 580.)\n\t\tc = vec3\n\t\t(\n\t\t\t(w - 510.) / (580. - 510.),\n\t\t\t1.0,\n\t\t\t0.0\n\t\t);\n\telse if (w >= 580. && w < 645.)\n\t\tc = vec3\n\t\t(\n\t\t\t1.0,\n\t\t\t-(w - 645.) / (645. - 580.),\n\t\t\t0.0\n\t\t);\n\telse if (w >= 645. && w <= 780.)\n\t\tc = vec3\n\t\t(\t1.0,\n\t\t\t0.0,\n\t\t\t0.0\n\t\t);\n\telse\n\t\tc = vec3\n\t\t(\t0.0,\n\t\t\t0.0,\n\t\t\t0.0\n\t\t);\n\n\treturn saturate(c);\n}\nvec3 spectral_zucconi6 (float w)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n        float y = baoa + t*bard;\n        // body\n        if( y>0.0 && y<baba ) return t;\n        // caps\n        vec3 oc = (y<=0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - r*r;\n        h = b*b - c;\n        if( h>0.0 ) return -b - sqrt(h);\n    }\n    return -1.0;\n}\n\n\n// Spectrum to xyz approx function from Sloan http://jcgt.org/published/0002/02/01/paper.pdf\n// Inputs:  Wavelength in nanometers\nfloat xFit_1931( float wave )\n{\n    float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374),\n          t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323),\n          t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\n}\nfloat yFit_1931( float wave )\n{\n    float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247),\n          t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\n}\nfloat zFit_1931( float wave )\n{\n    float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278),\n          t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\n}\n\n#define xyzFit_1931(w) vec3( xFit_1931(w), yFit_1931(w), zFit_1931(w) ) \n\n// http://www.cie.co.at/technical-work/technical-resources\nvec3 standardObserver1931[] =\n    vec3[] (\n    vec3( 0.001368, 0.000039, 0.006450 ), // 380 nm\n    vec3( 0.002236, 0.000064, 0.010550 ), // 385 nm\n    vec3( 0.004243, 0.000120, 0.020050 ), // 390 nm\n    vec3( 0.007650, 0.000217, 0.036210 ), // 395 nm\n    vec3( 0.014310, 0.000396, 0.067850 ), // 400 nm\n    vec3( 0.023190, 0.000640, 0.110200 ), // 405 nm\n    vec3( 0.043510, 0.001210, 0.207400 ), // 410 nm\n    vec3( 0.077630, 0.002180, 0.371300 ), // 415 nm\n    vec3( 0.134380, 0.004000, 0.645600 ), // 420 nm\n    vec3( 0.214770, 0.007300, 1.039050 ), // 425 nm\n    vec3( 0.283900, 0.011600, 1.385600 ), // 430 nm\n    vec3( 0.328500, 0.016840, 1.622960 ), // 435 nm\n    vec3( 0.348280, 0.023000, 1.747060 ), // 440 nm\n    vec3( 0.348060, 0.029800, 1.782600 ), // 445 nm\n    vec3( 0.336200, 0.038000, 1.772110 ), // 450 nm\n    vec3( 0.318700, 0.048000, 1.744100 ), // 455 nm\n    vec3( 0.290800, 0.060000, 1.669200 ), // 460 nm\n    vec3( 0.251100, 0.073900, 1.528100 ), // 465 nm\n    vec3( 0.195360, 0.090980, 1.287640 ), // 470 nm\n    vec3( 0.142100, 0.112600, 1.041900 ), // 475 nm\n    vec3( 0.095640, 0.139020, 0.812950 ), // 480 nm\n    vec3( 0.057950, 0.169300, 0.616200 ), // 485 nm\n    vec3( 0.032010, 0.208020, 0.465180 ), // 490 nm\n    vec3( 0.014700, 0.258600, 0.353300 ), // 495 nm\n    vec3( 0.004900, 0.323000, 0.272000 ), // 500 nm\n    vec3( 0.002400, 0.407300, 0.212300 ), // 505 nm\n    vec3( 0.009300, 0.503000, 0.158200 ), // 510 nm\n    vec3( 0.029100, 0.608200, 0.111700 ), // 515 nm\n    vec3( 0.063270, 0.710000, 0.078250 ), // 520 nm\n    vec3( 0.109600, 0.793200, 0.057250 ), // 525 nm\n    vec3( 0.165500, 0.862000, 0.042160 ), // 530 nm\n    vec3( 0.225750, 0.914850, 0.029840 ), // 535 nm\n    vec3( 0.290400, 0.954000, 0.020300 ), // 540 nm\n    vec3( 0.359700, 0.980300, 0.013400 ), // 545 nm\n    vec3( 0.433450, 0.994950, 0.008750 ), // 550 nm\n    vec3( 0.512050, 1.000000, 0.005750 ), // 555 nm\n    vec3( 0.594500, 0.995000, 0.003900 ), // 560 nm\n    vec3( 0.678400, 0.978600, 0.002750 ), // 565 nm\n    vec3( 0.762100, 0.952000, 0.002100 ), // 570 nm\n    vec3( 0.842500, 0.915400, 0.001800 ), // 575 nm\n    vec3( 0.916300, 0.870000, 0.001650 ), // 580 nm\n    vec3( 0.978600, 0.816300, 0.001400 ), // 585 nm\n    vec3( 1.026300, 0.757000, 0.001100 ), // 590 nm\n    vec3( 1.056700, 0.694900, 0.001000 ), // 595 nm\n    vec3( 1.062200, 0.631000, 0.000800 ), // 600 nm\n    vec3( 1.045600, 0.566800, 0.000600 ), // 605 nm\n    vec3( 1.002600, 0.503000, 0.000340 ), // 610 nm\n    vec3( 0.938400, 0.441200, 0.000240 ), // 615 nm\n    vec3( 0.854450, 0.381000, 0.000190 ), // 620 nm\n    vec3( 0.751400, 0.321000, 0.000100 ), // 625 nm\n    vec3( 0.642400, 0.265000, 0.000050 ), // 630 nm\n    vec3( 0.541900, 0.217000, 0.000030 ), // 635 nm\n    vec3( 0.447900, 0.175000, 0.000020 ), // 640 nm\n    vec3( 0.360800, 0.138200, 0.000010 ), // 645 nm\n    vec3( 0.283500, 0.107000, 0.000000 ), // 650 nm\n    vec3( 0.218700, 0.081600, 0.000000 ), // 655 nm\n    vec3( 0.164900, 0.061000, 0.000000 ), // 660 nm\n    vec3( 0.121200, 0.044580, 0.000000 ), // 665 nm\n    vec3( 0.087400, 0.032000, 0.000000 ), // 670 nm\n    vec3( 0.063600, 0.023200, 0.000000 ), // 675 nm\n    vec3( 0.046770, 0.017000, 0.000000 ), // 680 nm\n    vec3( 0.032900, 0.011920, 0.000000 ), // 685 nm\n    vec3( 0.022700, 0.008210, 0.000000 ), // 690 nm\n    vec3( 0.015840, 0.005723, 0.000000 ), // 695 nm\n    vec3( 0.011359, 0.004102, 0.000000 ), // 700 nm\n    vec3( 0.008111, 0.002929, 0.000000 ), // 705 nm\n    vec3( 0.005790, 0.002091, 0.000000 ), // 710 nm\n    vec3( 0.004109, 0.001484, 0.000000 ), // 715 nm\n    vec3( 0.002899, 0.001047, 0.000000 ), // 720 nm\n    vec3( 0.002049, 0.000740, 0.000000 ), // 725 nm\n    vec3( 0.001440, 0.000520, 0.000000 ), // 730 nm\n    vec3( 0.001000, 0.000361, 0.000000 ), // 735 nm\n    vec3( 0.000690, 0.000249, 0.000000 ), // 740 nm\n    vec3( 0.000476, 0.000172, 0.000000 ), // 745 nm\n    vec3( 0.000332, 0.000120, 0.000000 ), // 750 nm\n    vec3( 0.000235, 0.000085, 0.000000 ), // 755 nm\n    vec3( 0.000166, 0.000060, 0.000000 ), // 760 nm\n    vec3( 0.000117, 0.000042, 0.000000 ), // 765 nm\n    vec3( 0.000083, 0.000030, 0.000000 ), // 770 nm\n    vec3( 0.000059, 0.000021, 0.000000 ), // 775 nm\n    vec3( 0.000042, 0.000015, 0.000000 )  // 780 nm\n);\nfloat standardObserver1931_w_min = 380.0f;\nfloat standardObserver1931_w_max = 780.0f;\nint standardObserver1931_length = 81;\n\nvec3 WavelengthToXYZLinear( float fWavelength )\n{\n    float fPos = ( fWavelength - standardObserver1931_w_min ) / (standardObserver1931_w_max - standardObserver1931_w_min);\n    float fIndex = fPos * float(standardObserver1931_length);\n    float fFloorIndex = floor(fIndex);\n    float fBlend = clamp( fIndex - fFloorIndex, 0.0, 1.0 );\n    int iIndex0 = int(fFloorIndex);\n    int iIndex1 = iIndex0 + 1;\n    iIndex1 = min( iIndex1, standardObserver1931_length - 1);\n\n    return mix( standardObserver1931[iIndex0], standardObserver1931[iIndex1], fBlend );\n}\n\nvec3 XYZtosRGB( vec3 XYZ )\n{\n    // XYZ to sRGB\n    // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n   mat3 m = mat3 (\n        3.2404542, -1.5371385, -0.4985314,\n\t\t-0.9692660,  1.8760108,  0.0415560,\n \t\t0.0556434, -0.2040259,  1.0572252 );\n    \n    return XYZ * m;\n}\n\nvec3 sRGBtoXYZ( vec3 RGB )\n{\n   // sRGB to XYZ\n   // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n\n   mat3 m = mat3(  \t0.4124564,  0.3575761, 0.1804375,\n \t\t\t\t\t0.2126729,  0.7151522, 0.0721750,\n \t\t\t\t\t0.0193339,  0.1191920, 0.9503041 );\n    \n    \n    return RGB * m;\n}\n\nvec3 WavelengthToXYZ( float f )\n{    \n    //return xyzFit_1931( f ) * mXYZtoSRGB;\n    \n    return WavelengthToXYZLinear( f );\n}\n\n\nstruct Chromaticities\n{\n    vec2 R, G, B, W;\n};\n    \nvec3 CIE_xy_to_xyz( vec2 xy )\n{\n    return vec3( xy, 1.0f - xy.x - xy.y );\n}\n\nvec3 CIE_xyY_to_XYZ( vec3 CIE_xyY )\n{\n    float x = CIE_xyY[0];\n    float y = CIE_xyY[1];\n    float Y = CIE_xyY[2];\n    \n    float X = (Y / y) * x;\n    float Z = (Y / y) * (1.0 - x - y);\n        \n\treturn vec3( X, Y, Z );        \n}\n\nvec3 CIE_XYZ_to_xyY( vec3 CIE_XYZ )\n{\n    float X = CIE_XYZ[0];\n    float Y = CIE_XYZ[1];\n    float Z = CIE_XYZ[2];\n    \n    float N = X + Y + Z;\n    \n    float x = X / N;\n    float y = Y / N;\n    float z = Z / N;\n    \n    return vec3(x,y,Y);\n}\n\nChromaticities Primaries_Rec709 =\nChromaticities(\n        vec2( 0.6400, 0.3300 ),\t// R\n        vec2( 0.3000, 0.6000 ),\t// G\n        vec2( 0.1500, 0.0600 ), \t// B\n        vec2( 0.3127, 0.3290 ) );\t// W\n\nChromaticities Primaries_Rec2020 =\nChromaticities(\n        vec2( 0.708,  0.292 ),\t// R\n        vec2( 0.170,  0.797 ),\t// G\n        vec2( 0.131,  0.046 ),  \t// B\n        vec2( 0.3127, 0.3290 ) );\t// W\n\nChromaticities Primaries_DCI_P3_D65 =\nChromaticities(\n        vec2( 0.680,  0.320 ),\t// R\n        vec2( 0.265,  0.690 ),\t// G\n        vec2( 0.150,  0.060 ),  \t// B\n        vec2( 0.3127, 0.3290 ) );\t// W\n\nmat3 RGBtoXYZ( Chromaticities chroma )\n{\n    // xyz is a projection of XYZ co-ordinates onto to the plane x+y+z = 1\n    // so we can reconstruct 'z' from x and y\n    \n    vec3 R = CIE_xy_to_xyz( chroma.R );\n    vec3 G = CIE_xy_to_xyz( chroma.G );\n    vec3 B = CIE_xy_to_xyz( chroma.B );\n    vec3 W = CIE_xy_to_xyz( chroma.W );\n    \n    // We want vectors in the directions R, G and B to form the basis of\n    // our matrix...\n    \n\tmat3 mPrimaries = mat3 ( R, G, B );\n    \n    // but we want to scale R,G and B so they result in the\n    // direction W when the matrix is multiplied by (1,1,1)\n    \n    vec3 W_XYZ = W / W.y;\n\tvec3 vScale = inverse( mPrimaries ) * W_XYZ;\n    \n    return transpose( mat3( R * vScale.x, G * vScale.y, B * vScale.z ) );\n}\n\nmat3 XYZtoRGB( Chromaticities chroma )\n{\n    return inverse( RGBtoXYZ(chroma) );\n}\n\n// chromatic adaptation\n\n// http://www.brucelindbloom.com/index.html?Eqn_ChromAdapt.html    \n\n// Test viewing condition CIE XYZ tristimulus values of whitepoint.\nvec3 XYZ_w = vec3( 1.09850,\t1.00000,\t0.35585); // Illuminant A\n// Reference viewing condition CIE XYZ tristimulus values of whitepoint.\nvec3 XYZ_wr = vec3(0.95047,\t1.00000,\t1.08883); // D65\n\n\nconst mat3 CA_A_to_D65_VonKries = mat3(\n    0.9394987, -0.2339150,  0.4281177,\n\t-0.0256939,  1.0263828,  0.0051761,\n \t0.0000000,  0.0000000,  3.0598005\n    );\n\n\nconst mat3 CA_A_to_D65_Bradford = mat3(\n    0.8446965, -0.1179225,  0.3948108,\n\t-0.1366303,  1.1041226,  0.1291718,\n \t0.0798489, -0.1348999,  3.1924009\n    );\n\n\nconst mat3 mCAT_VonKries = mat3 ( \n    0.4002400,  0.7076000, -0.0808100,\n\t-0.2263000,  1.1653200,  0.0457000,\n \t0.0000000,  0.0000000,  0.9182200 );\n\nconst mat3 mCAT_02 = mat3( \t0.7328, 0.4296, -0.1624,\n\t\t\t\t\t\t\t-0.7036, 1.6975, 0.0061,\n \t\t\t\t\t\t\t0.0030, 0.0136, 0.9834 );\n\nconst mat3 mCAT_Bradford = mat3 (  0.8951000, 0.2664000, -0.1614000,\n\t\t\t\t\t\t\t\t-0.7502000,  1.7135000,  0.0367000,\n \t\t\t\t\t\t\t\t0.0389000, -0.0685000,  1.0296000 );\n\n\nmat3 GetChromaticAdaptionMatrix()\n{\n    //return inverse(CA_A_to_D65_VonKries);    \n    //return inverse(CA_A_to_D65_Bradford);\n        \n    //return mat3(1,0,0, 0,1,0, 0,0,1); // do nothing\n    \n\t//mat3 M = mCAT_02;\n    //mat3 M = mCAT_Bradford;\n    mat3 M = mCAT_VonKries;\n    //mat3 M = mat3(1,0,0,0,1,0,0,0,1);\n    \n    vec3 w = XYZ_w * M;\n    vec3 wr = XYZ_wr * M;\n    vec3 s = w / wr;\n    \n    mat3 d = mat3( \n        s.x,\t0,\t\t0,  \n        0,\t\ts.y,\t0,\n        0,\t\t0,\t\ts.z );\n        \n    mat3 cat = M * d * inverse(M);\n    return cat;\n}\n\nfloat BlackBody( float t, float w_nm )\n{\n    float h = 6.6e-34; // Planck constant\n    float k = 1.4e-23; // Boltzmann constant\n    float c = 3e8;// Speed of light\n\n    float w = w_nm / 1e9;\n\n    // Planck's law https://en.wikipedia.org/wiki/Planck%27s_law\n    \n    float w5 = w*w*w*w*w;    \n    float o = 2.*h*(c*c) / (w5 * (exp(h*c/(w*k*t)) - 1.0));\n\n    return o;    \n}", "buffer_b_code": "#define SPP 2\n\nfloat ior;\n\nstruct Hit\n{\n    vec3 ro;//ray origin\n    float td;//travelled distance\n    vec3 rh;//ray hit position\n    vec3 rd;//ray direction\n    vec3 no;//normal at the hit position\n    float id;//hit object id\n    //other material stuff\n};\n\nstruct Mat\n{\n    vec3 col; //color\n    vec3 emi; //emission\n    float rgh; //roughness\n};\n\nMat getMaterial(float id)\n{\n    Mat outmat;\n    outmat.col = vec3(1.0);\n    outmat.emi = vec3(0.0);\n    outmat.rgh = 0.3;\n    return outmat;\n}\n\nvec3 opU( vec3 d, float iResult, float mat ) {\n\treturn (iResult < d.y) ? vec3(d.x, iResult, mat) : d;\n}\n\nconst float density = 0.003;\n\nfloat iVolume( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal )\n{\n    float d = -log(rand())/density;\n    \n    if (d < distBound.x || d > distBound.y) \n    {\n        return MAX_DIST;\n    } \n    else \n    {\n    \treturn d;\n    }\n}\n\nHit worldhit(in vec3 ro, in vec3 rd, in vec2 dist) {\n    vec3 normal;\n    vec3 tmp0, tmp1, d = vec3(dist, 0.);\n    \n    \n    \n    d = opU(d, iPlane      (ro,                  rd, d.xy, normal, vec3(0,1,0), 0.), 1.);\n    \n    d = opU(d, iBox        (ro-vec3( 1,.252, -1), rd, d.xy, normal, vec3(.25)), 2.);\n    d = opU(d, iSphere     (ro-vec3( 0,.252, 0), rd, d.xy, normal, .25), 3.);\n    d = opU(d, iSphere     (ro-vec3( 0.6,.252, 0.2), rd, d.xy, normal, .25), 3.);\n    d = opU(d, iSphere     (ro-vec3( -0.5,.252, 0.1), rd, d.xy, normal, .25), 3.);\n    d = opU(d, iVolume     (ro, rd, d.xy, normal), 4.0);\n\n    Hit res;\n    res.ro = ro;\n    res.rh = ro + d.y*rd;\n    res.rd = rd;\n    res.no = normal;\n    res.id = d.z;\n    res.td = d.y;\n    return res;\n}\n\nvoid processHit(Hit res, inout vec3 ro, inout vec3 rd, inout float inside, inout vec3 col, inout vec3 att)\n{\n    Mat m = getMaterial(res.id);\n    \n    col += att*m.emi;\n    att *= m.col;\n    vec3 normal = res.no;\n    if(res.id < 4.0)\n    {\n        if(res.id == 3.0)\n        {\n            ro = res.rh ;\n             \n            vec3 matn = normalize(nrand3(0.005, normal*inside));\n            vec3 newrd = refract(rd, matn, pow(1.0 + 1.2*ior, -inside));\n            if(length(newrd) > 0.5) //not total internal reflection\n            {\n                inside = -inside;\n                rd = newrd;\n            }\n            else\n            {\n                rd =reflect(rd, matn); \n            } \n        }\n        else\n        {\n            //surface scatter\n            rd = reflect(res.rd, normalize(nrand3(m.rgh, normal))); \n            ro = res.rh + inside*res.no*5e-3;\n        }\n      \n    } \n    else\n    {\n        //volume scatter\n        rd = udir(rand2());\n        ro = res.rh;\n    }\n}\n\n\n#define LASER_PATH 7\nint cpath;\nvec3 path[LASER_PATH+1];\n\nfloat getClosestLinePoint(vec3 ro, vec3 rd, vec3 x)\n{\n    return dot(rd, x - ro);\n}\n\nfloat rand(float a, float b)\n{\n    return mix(a, b, rand());\n}\n\n//Importance sample a point on a segment so that the probability of sampling a point on the segment r1 r2\n//is inversely proportional to the square of the distance to point x\nvec3 importanceSampleSegmentPoint(vec3 r1, vec3 r2, vec3 x)\n{\n    vec3 x0 = r1 - x;\n    vec3 rd = normalize(r2 - r1);\n    float l = length(r2 - r1);\n    float a = dot(rd, x0);\n    float x02 = dot(x0, x0);\n    float sq = sqrt(x02 - a*a); \n    float t = sq*tan(rand(atan(a/sq),atan((l + a)/sq))) - a;\n    return r1 + rd*t; //importance sampled point\n}\n\n//get closest point pair for 2 segments\nvoid getClosestPointPair(vec3 r00, vec3 r01, vec3 r10, vec3 r11, out vec3 P1, out vec3 P2)\n{\n  vec3 delta1 = r01 - r00;\n  vec3 delta2 = r11 - r10;\n  vec3 rd1 = normalize(delta1);\n  vec3 rd2 = normalize(delta2);\n  float l1 = length(delta1);\n  float l2 = length(delta2);\n  vec3 delta3 = r00 - r10;\n  float d1d2 = dot(rd1, rd2);\n  float d1de = dot(rd1, delta3);\n  float d2de = dot(rd2, delta3);\n  float deno = 1.0/(1.0 - d1d2*d1d2);\n  float t1 = (d1d2*d2de - d1de)*deno;\n  float t2 = (d2de - d1d2*d1de)*deno;\n  \n  if(t1 < 0.0 || t1 > l1)\n  {\n      t1 = clamp(t1, 0.0, l1);\n      P1 = r00 + t1*rd1;\n      t2 = clamp(getClosestLinePoint(r10, rd2, P1), 0.0, l2);\n      P2 = r10 + t2*rd2;\n      return;\n  }\n  \n  if(t2 < 0.0 || t2 > l2)\n  {\n      t2 = clamp(t2, 0.0, l2);\n      P2 = r10 + t2*rd2;\n      t1 = clamp(getClosestLinePoint(r00, rd1, P2), 0.0, l1);\n      P1 = r00 + t1*rd1;\n      return;\n  }\n  \n   P1 = r00 + t1*rd1;\n   P2 = r10 + t2*rd2;\n}\n\n//choose a laser path segment p0 p1 with probability proportional to the path segment lenght and \n//inverse distance to the camera ray path segment r0 r1\nvoid importanceSamplePath(vec3 r0, vec3 r1, out vec3 p0, out vec3 p1)\n{\n    float score[LASER_PATH];\n    float totalscore = 0.0;\n    vec3 P0, P1;\n    for(int i = 0; i < cpath; i++)\n    {\n        getClosestPointPair(r0,r1,path[i],path[i+1],P0,P1);\n        float s = distance(path[i],path[i+1])/distance(P0,P1);\n        totalscore += s;\n        score[i] = totalscore;\n    }\n    \n    //target score\n    float rscore = rand()*totalscore;\n    \n    for(int i = 0; i < cpath; i++)\n    {\n        if(rscore < score[i]) //found score\n        {\n            p0 = path[i];\n            p1 = path[i+1];\n            return;\n        }\n    }\n}\n\n//next event estimation sample using the light path\nvoid connectPath(Hit res, inout vec3 col, inout vec3 att)\n{\n    //camera ray path\n    vec3 r0 = res.ro;\n    vec3 r1 = res.rh;\n    \n    //get random path\n    vec3 p0, p1;\n    importanceSamplePath(r0,r1,p0,p1);\n    \n    //find 2 closest points on camera segment and light path \n    vec3 s1, s2;\n    getClosestPointPair(p0, p1, r0, r1, s1, s2); \n    \n    vec3 pathp = importanceSampleSegmentPoint(p0, p1, s2);\n    vec3 camp = importanceSampleSegmentPoint(r0, r1, s1);\n    \n    //trace a ray from the camp to pathp\n    vec3 delta = pathp - camp;\n    float td = length(delta);\n    \n    \n    Hit con = worldhit( camp, normalize(delta), vec2(.001, td));\n    \n    if(con.td >= td) col += att/(td+1e-10);\n    //col += att*pathhit(res.ro, res.rd, res.td);\n}\n\nbool getRay(vec2 uv, out vec3 ro, out vec3 rd)\n{\n    mat3 cam = getCam(get(CamA));\n    vec2 apert_cent = -0.*uv; \n    vec2 ap = aperture();  \n    if(!(distance(ap, apert_cent) < 1.0)) return false;  \n    float apd = length(ap);  \n    vec3 daperture = ap.x*cam[0] + ap.y*cam[1]; \n    ro = get(CamP).xyz + aperture_size*daperture;\n    float focus =2.5 + 0.8*pow(apd,5.0);\n    rd = normalize(focus*(cam*vec3(FOV*uv, 1.0)) - aperture_size*daperture);\n    return true;\n}\n\nvec4 render(vec2 fragCoord)\n{\n    fragCoord += nrand2(0.5, vec2(0.));\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n   \n    vec3 ro, rd, normal;\n  \n    // get a random refractive index different per pixel\n    ior = 0.7*(rand() - 0.5);\n    //ior = -0.2;\n    //ior = (fract(gl_FragCoord.y/3.)-.5);\n    //slightly more realistic dispesion law\n    float id=1./(1.0 + ior);\n    // compute index of refraction associated color \n    vec3 scol = WavelengthToXYZLinear(350.0*(ior + 0.5) + 350.0);\n     ior = id;\n     \n    //trace laser   \n    ro = get(RayO).xyz;\n    rd = normalize(get(RayD).xyz + 0.01*udir(rand2()));\n    \n    float inside = 1.0;\n    \n    vec3 col = vec3(0.0);\n    vec3 att = scol;\n    \n    \n    for(cpath = 0; cpath < LASER_PATH - 1; cpath++)\n    {\n        path[cpath] = ro;\n        Hit res = worldhit( ro, rd, vec2(.001, MAX_DIST));\n        if (res.id > 0.) \n        {\n            processHit(res,ro,rd,inside,col,att);\n        }\n        else \n        {\n            ro = res.rh;\n            break;\n        }\n    }\n    path[cpath+1] = ro;\n    \n    if(!getRay(uv, ro, rd)) return vec4(0,0,0,1);\n    \n    col = vec3(0.0);\n    att = scol;\n    inside = 1.0;\n    \n    for(int i = 0; i < 5; i++)\n    {\n        Hit res = worldhit( ro, rd, vec2(.001, MAX_DIST));\n        \n        connectPath(res, col, att);\n        processHit(res,ro,rd,inside,col,att);\n    }\n   \n    return vec4(col, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    rng_initialize(fragCoord, iFrame);\n\n    fragColor = vec4(0.0);\n    for(int i = 0; i < SPP; i++)\n        fragColor += clamp(render(fragCoord),-0.2e3,0.2e3);\n       \n    \n    mat3 prevcam = getCam(get(PrevCamA));\n    vec3 prevcamp = get(PrevCamP).xyz;\n    \n    vec3 ro, rd;\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    getRay(uv, ro, rd);\n    \n    Hit res = worldhit( ro, rd, vec2(.001, MAX_DIST));\n    \n     vec3 cv = get(CamV).xyz;\n    vec3 rep = reproject(prevcam, prevcamp, iResolution.xy, ro + rd*res.td);\n    float reject = 0.975*float(all(lessThan(rep.xy, iResolution.xy)) && all(greaterThan(rep.xy,vec2(0))));\n    reject *= smoothstep(5.0, 0.0, length(cv));\n    fragColor += texture(iChannel0, rep.xy/iResolution.xy)*reject;\n   \n    \n}", "buffer_b_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lBXWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 111, 144, 144, 311], [313, 313, 332, 332, 388], [390, 390, 447, 447, 562]], "test": "untested"}
{"id": "stSSWW", "name": "Fractal 71_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 6, "viewed": 325, "published": 3, "date": "1627656494", "time_retrieved": "2024-07-30T19:08:34.883124", "image_code": "#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    O-=O;\n    vec3 r=iResolution,\n    p=vec3((C.xy-.5*r.xy)/r.y,0)-iTime*.05;\n    p=asin(sin(p*3.));\n    float s=1.,e;\n    for(int i=0;i<7;i++)\n        p=abs(p)-1.2,\n        s*=e=3./clamp(dot(p,p),.8,2.),\n        p=p*e-3.;\n        O.xyz+=mix(vec3(1),H(log(s)*.5),.7)*3e-3/abs(p.z/s);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stSSWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 88, 88, 374]], "test": "untested"}
{"id": "NtBXDW", "name": "2d ray marching 4d objects-Demo", "author": "xertrov", "description": "How do you ray march a 4d object?\nThis is the best method I've found so far (earlier attempts on my page). It works for general 4d SDFs. Lots of options if you want to play. criticism and suggestions v welcome.", "tags": ["raymarching", "sdf", "projection", "4d", "learning", "tesseract", "hypercube", "hypercube", "4draymarching", "4dsdf"], "likes": 7, "viewed": 448, "published": 3, "date": "1627644212", "time_retrieved": "2024-07-30T19:08:35.826600", "image_code": "/*\n\n# 2D RAYMARCHING 4D OBJECTS (VOLUMES AND WIREFRAMES) USING ONLY SDFs\n\nMax Kaye - July 2021\nhttps://xk.io\n\nDistributed under CC0 - <https://creativecommons.org/publicdomain/zero/1.0/>\n\n## intro\n\nThis 4d ray-marcher uses an experimental 2-stage method to render 4d objects\nvia SDFs.\n\n## the method\n\nThis breaks down the ray marching into a Z march and (repeated) W march.\nThis is not ideal, though, because we no longer know exactly how far to\ntravel in Z each loop, even with an exact SDM. The problem is that we\nmight to too far in Z and overshoot an adjacent edge in W.\n\nThe best method I've found is:\n\nBased *axial* distance estimates (e.g., `d = abs(p) - s` -- which is exact\nfor tesseract edges), calculate how far it is safe to travel. Changing the\nbasis of `d` (into the basis of our Z and W *ray directions*, not raw axes)\nlets the ray marcher make much more accurate steps commpared to things like\njust multiplying the distance estimate by 0.2.\n\nHowever, this alone doesn't solve the problem. The main other problem is\nthat rays travel too fast through the middle of the cube (and the middle\nof edges, too). Since we're using the SDF for tesseract *edges* (not faces),\nthere's nothing really for the rays to collide with. That means that a ray\ngoing through the middle of the cube cannot safely travel very far at all,\n(in the Z direction) even tho the distance estimate is quite large, still.\nIf you want to see what this effect looks like, comment SLOW_THRU.\n\nThis method is still no where near as accurate (or as efficient) as ray\nmarching only in Z. You can still see some edge-artifacts on the default\nsettings, and if you reduce EDGE_WIDTH the effect becomes very noticeable.\nThe solution is to increase the effective angular resolution.\n\n## about the thing that is shown\n\nThe shape color is based on w-depth. The green background shows how many\nsteps (including the ray marches in W) that were taken to render that\npixel. The green coulds ({dis,en}abled via SPOOKY_BITS) are an artifact of\nslowing the rays near each axix's zero (only while marching on Z) -- this\ncan be adjusted via the SPOOK_BE_GONE definition. Large values make for\nwibly wobly, sometimes-hollow blobs.\n\nImprovement potential:\n\n* Slow rays near verticies -- this looks like another point of distortion and\n  this tech might help here, too.\n\n* figure out a more efficient method of slowing rays near the middle of the\n  axes and around corners.\n\n* lighting and refaction / transaprency (for solid 4d objs -- they work as\n  expected atm, mind)\n\n*/\n\nprecision highp float;\n\n// #define SPOOKY_BITS // comment this to turn off spooky cloudy bits\n#define ORTHOGONAL_CAM // Perspective cam has artifacting and works best with SPOOKY_BITS disabled\n#define EDGE_WIDTH 0.02 // lower => artifacting. I suggest ~0.08 or more for perspective cam.\n#define EDGE_LENGTH .4 // side length\n\n#define SLOW_THRU // comment to see the artifacting caused by rays going too fast through the middle of the cube\n\n#define MAX_STEPS 400\n#define MAX_DIST 50.\n#define SURF_DIST 0.005\n\n#define RM_2STEP 1\n#define RM_NORMAL 0\n#define RM_NORMAL_1D 0\n\n#ifdef SPOOKY_BITS\n#define SPOOK_BE_GONE 0.0\n#else\n#define SPOOK_BE_GONE 0.06\n#endif\n\nfloat sdTesseractEdge(in vec4 p, in vec4 b, out vec4 d) {\n  d = abs(p) - b;\n  return length(best3(d)); // best2 for faces, best3 for edges, best4 (all of them) for corners\n}\n\nfloat sdTesseractFaces(in vec4 p, in vec4 b, out vec4 d) {\n  d = abs(p) - b;\n  return length(best2(d)); // best2 for faces, best3 for edges, best4 (all of them) for corners\n}\n\nfloat sdHypersphere(in vec4 p, in float r, out vec4 d) {\n  d = abs(p) - r;\n  return length(p) - r;\n}\n\nfloat mapWDists(vec4 p, out vec4 distsOut) {\n  /*\n  NB: I suggest only enabling one shape at a time to start with, and only\n  have 1 on at a time (at least until you have a feel for things). Careful\n  with shapes being on top of each other.\n  */\n\n  vec4 dists;\n  float d = 999.;\n\n  d = min(d, sdTesseractEdge(p, vec4(EDGE_LENGTH), dists) - EDGE_WIDTH);\n  distsOut = dists;  // for more shapes: distsOut = min(distsOut, dists);\n\n  // /* position offset works like normal: */\n  // d = min(d, sdTesseractEdge(p - vec4(0,0,0,-1.5), vec4(EDGE_LENGTH), dists) - EDGE_WIDTH);\n  // distsOut = min(distsOut, dists);\n\n  // /* \"solid\" objects (i.e., faces, not edges) work fine */\n  // d = min(d, sdTesseractFaces(p - vec4(0,0,0,-1.5), vec4(EDGE_LENGTH), dists) - EDGE_WIDTH);\n  // distsOut = min(distsOut, dists);\n\n  // /* hyperspheres are a bit boring. */\n  // d = min(d, sdHypersphere(p - vec4(0,0,0,-1.5), EDGE_LENGTH, dists) - EDGE_WIDTH);\n  // distsOut = min(distsOut, dists);\n\n  return d;\n}\n\nfloat map(vec4 p) {\n  vec4 temp;\n  return mapWDists(p, temp);\n}\n\n// Typical raymarching alg. Steps are returned for debugging.\nvec4 rayMarch(inout vec4 p, in vec4 rd, out vec4 dists) {\n  float dS = 99., d = 0., minDS = dS, steps = 0.;\n  for (int i = 0; i < MAX_STEPS; i++) {\n    steps++;\n    dS = mapWDists(p, dists);\n    minDS = min(minDS, abs(dS));\n    d += dS;\n    p = p + rd * dS;\n    if ((0. <= dS && dS < SURF_DIST) || d > MAX_DIST) break;\n  }\n  return vec4(d, dS, minDS, steps);\n}\n\nvec2 e = vec2(.0001, 0);\n\n// Raymarchign that will\nvec4 rayMarch1d(inout vec4 p, in vec4 rd, in vec4 rd2, out vec4 dists) {\n  vec4 dists2, p2;\n  float dS = 99., dSx = 99., dSy, dSz, dSw, d = 0., minDS = dS, steps = 0.;\n  for (int i = 0; i < MAX_STEPS; i++) {\n    steps++;\n    dS = mapWDists(p, dists);\n    if (dS > SURF_DIST) {  // we are receeding,\n      p2 = p - rd2 * 1.41;\n      vec4 innerRmd = rayMarch(p2, rd2 * vec4(1,1,1,1), dists2);\n      steps += innerRmd.w;\n      if (innerRmd.y < SURF_DIST) { p = p2; }\n      /* minWith 4d */\n      // float ddS = dS - innerRmd.y;\n      // dists = (max(0., ddS) * dists + max(0., -ddS) * dists2) * -1. / abs(ddS);\n      /* -- end minWith */\n      dists = minWith14(dS, dists, innerRmd.y, dists2);\n      dS = min(dS, innerRmd.y);\n      minDS = min(minDS, innerRmd.z);\n    }\n    minDS = min(minDS, (dS));\n    mat4 chBasis = mat4(0, 0, 0, 0, 0, 0, 0, 0, rd.x, rd.y, rd.z, rd.w, rd2.x, rd2.y, rd2.z, rd2.w);\n    vec4 components = normalize(dists * chBasis);\n    d += dS;\n    /* first, take the largest of the components we got back from the change\n    of basis (it breaks for some angles with less than this - I'm not really\n    sure why) */\n    float dsFactor = maxOf(vec4(components.zw, -components.zw));\n    #ifdef SLOW_THRU\n    // then, slow down the ray whenever it has a coordinate near 0 for some axis.\n    dsFactor *= min(1., max(minOf(abs(p)) + SPOOK_BE_GONE, .01));\n    #endif\n    p = p + rd * dS * dsFactor;\n    // * sin(atan(dSw, dSz)) * (min(1., max(minOf(abs(p)) + SPOOK_BE_GONE, .01))); // move slower inside;\n    if ((0. <= dS && dS < SURF_DIST) || d > MAX_DIST) break;\n  }\n  return vec4(d, dS, minDS, steps);\n}\n\n\nvec2 scaleUvWithAspect(vec2 st) {\n  float aspect = u_resolution.x / u_resolution.y;\n  float scaleX = step(1.0, aspect), scaleY = 1. - scaleX;\n  aspect = max(aspect, 1. / aspect);\n  st.x = st.x * scaleY + scaleX * (st.x * aspect - (aspect - 1.) / 2.);\n  st.y = st.y * scaleX + scaleY * (st.y * aspect - (aspect - 1.) / 2.);\n  return st - .5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = scaleUvWithAspect(gl_FragCoord.xy / u_resolution.xy);\n  vec2 mouse = (u_mouse.xy - 0.5 * u_resolution.xy) / u_resolution.y;\n  float t = u_time / 3.;\n  vec3 col = BLACK;\n  uv *= 1.0;\n\n  vec4 ro, rd;\n  mat4 r = rot4(t * 1.27 + 3.283, 1) * rot4(t * 1.14 - 1.4389, 4) * rot4(t * .923 - 2.34985, 5) * rot4(t * .8132 + 1.3536, 3);\n\n  // starting this with (uv.w -= 2) (like you might with the z axis) results in issues rendering b/c the ray doesn't pass close enough to the objects to get the sideways projection right.\n  #ifdef ORTHOGONAL_CAM\n    r *= rot4(mouse.x * TAU, 1) * rot4(mouse.y * TAU, 4);\n    uv *= 3.;\n    ro = vec4(uv, -2, 0);\n    rd = vec4(0, 0, 1, 0);\n  #else\n    r *= rot4(mouse.y * TAU, 4);\n    vec2 mxr = sinCos(12.0 + 0.5*t + 10.0*mouse.x);\n\t  ro = vec4( 3.0*mxr.y, .0, 3.0*mxr.x, 0.);\n    float fov = .7;\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro.xyz );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    rd = normalize(vec4(uv.x*uu + uv.y*vv + fov*ww, 0.));\n    mat4 cam = mat4( uu.x, uu.y, uu.z, 0.0,\n    \t\t\t\t vv.x, vv.y, vv.z, 0.0,\n    \t\t\t\t ww.x, ww.y, ww.z, 0.0,\n    \t\t\t\t -dot(uu,ro.xyz), -dot(vv,ro.xyz), -dot(ww,ro.xyz), 1.0 );\n  #endif\n  vec4 rd2 = rd.xywz;\n\n  ro *= r;\n  rd *= r;\n  rd2 *= r;\n\n  vec4 p = ro, dists, rmd;\n  if (RM_NORMAL == 1) { p = vec4(uv.xy, ro.zw); }\n  if (RM_NORMAL == 1 || RM_NORMAL_1D == 1) { rmd = rayMarch(p, rd, dists); }\n  else if (RM_2STEP == 1) { rmd = rayMarch1d(p, rd, rd2, dists); }\n\n  float d = rmd.x, dS = rmd.y, minDS = rmd.z, steps = rmd.w;\n\n  float shapeOnly = step(1., 1. - minDS + SURF_DIST * 2.);\n  float sst = 0.05;  // smoothstep threshhold\n\n\n  col.g += S(.0, float(MAX_STEPS * 6), rmd.w) * S(0., sst / 2., minDS);\n  // col.r += S(.05, .0, minDS);\n  col.b += S(.05, .0, minDS) * hh(S(1.41, -1.41, p.w));\n  col.r += S(.05, .0, minDS) * hh(S(1.41, -1.41, p.z));\n  // col.g += S(.05, .0, minDS) * S(1.41, -1.41, p.z);\n  // col += S(.01, .0, abs(minDS - .02)) * vec3(0.4667, 0.1882, 0.0314);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "/* copy pasted from my libs. lots is written by me. you're welcome to use it, but caveat emptor. */\n\n#define u_resolution iResolution\n#define u_mouse iMouse\n#define u_time iTime\n#define gl_FragColor fragColor\n\n#define PI 3.141592653589\n#define TAU 6.28318530718\n\n#define SQRT_3 1.7320508\n#define SQRT_2 1.41421356\n\n#define S(a, b, t)smoothstep(a, b, t)\n#define hh(x)(x * 0.5 + 0.5)\n#define zoth vec4(0.0, 1.0, 2.0, 0.5)\n\n#define BLACK vec3(0.0)\n#define WHITE vec3(1.0)\n\n\nvec2 best2(vec3 p) {\n  vec2 r = vec2(max(p.x, p.y), min(p.x, p.y)); // : vec2(p.y, p.x);\n  if (p.z > r.x) { return vec2(p.z, r.x);}\n  if (p.z > r.y) { return vec2(r.x, p.z);}\n  return r;\n}\n\nvec2 best2(vec4 p) {\n  vec2 r = p.x > p.y ? vec2(p.x, p.y) : vec2(p.y, p.x);\n  if (p.z > r.x) { r = vec2(p.z, r.x); }\n  else if (p.z > r.y) { r = vec2(r.x, p.z); }\n  if (p.w > r.x) { return vec2(p.w, r.x); }\n  else if (p.w > r.y) { return vec2(r.x, p.w); }\n  return r;\n}\n\nvec3 best3(vec4 p) {\n  vec2 zw = vec2(max(p.z, p.w), min(p.z, p.w));\n  // p.z > p.w ? vec2(p.z, p.w) : vec2(p.w, p.z);\n  vec2 xy = vec2(max(p.x, p.y), min(p.x, p.y));\n  if (xy.y > zw.x) {return vec3(xy, zw.x);} // testme\n  if (zw.y > xy.x) {return vec3(zw, xy.x);}\n  return vec3(max(xy.x, zw.x), min(xy.x, zw.x), max(xy.y, zw.y));\n\n  /* tests\n  col = best2(zoth.xyz) == vec2(2., 1.) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.zywx) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.wxzy) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.wxyz) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.xywz) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  */\n}\n\nfloat minOf(vec2 v) {\n  return min(v.x, v.y);\n}\nfloat maxOf(vec2 v) {\n  return max(v.x, v.y);\n}\nfloat sumOf(vec2 v) {\n  return v.x + v.y;\n}\n\nfloat minOf(vec3 v) {\n  return min(minOf(v.xy), v.z);\n}\nfloat maxOf(vec3 v) {\n  return max(maxOf(v.xy), v.z);\n}\nfloat sumOf(vec3 v) {\n  return sumOf(v.xy) + v.z;\n}\n\nfloat minOf(vec4 v) {\n  return min(minOf(v.xyz), v.w);\n}\nfloat maxOf(vec4 v) {\n  return max(maxOf(v.xyz), v.w);\n}\nfloat sumOf(vec4 v) {\n  return sumOf(v.xyz) + v.w;\n}\n\nfloat bestOf(vec2 p) {\n  // return p.x > p.y ? p.x : p.y;\n  return max(p.x, p.y);\n}\nfloat bestOf(vec3 p) {\n  return max(max(p.x, p.y), p.z);\n}\nfloat bestOf(vec4 p) {\n  return max(bestOf(p.xyz), p.w);\n}\n\n\nvec2 sinCos(in vec2 ab) {\n  return vec2(sin(ab.x), cos(ab.y));\n}\nvec2 sinCos(in float a) {\n  return vec2(sin(a), cos(a));\n}\n\n// roll from XY to XZ or YZ (0 no roll, 1=XZ, 2=YZ)\nmat3 rot3XY(float angle, int roll) {\n  float s = sin(angle), c = cos(angle);\n  mat3 r = mat3(c, - s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n  if (roll == 1) {\n    r = mat3(r[0].xzy, r[2].xzy, r[1].xzy);\n  } else if (roll == 2) {\n    r = mat3(r[2].zxy, r[0].zxy, r[1].zxy);\n  }\n  return r;\n}\n\n\nmat4 rot4(float angle, int axis) {\n  float s = sin(angle), c = cos(angle);\n  mat4 r = mat4(\n    c, -s, 0, 0,\n    s, c, 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 1\n  );\n  // XY, XZ, XW\n  return axis == 0 ? r\n    : axis == 1 ? mat4(r[0].xzyw, r[2].xzyw, r[1].xzyw, r[3].xzyw)\n    : axis == 2 ? mat4(r[0].xwzy, r[3].xwzy, r[2].xwzy, r[1].xwzy)\n    // YZ, YW\n    : axis == 3 ? mat4(r[3].wxyz, r[0].wxyz, r[1].wxyz, r[2].wxyz)\n    : axis == 4 ? mat4(r[3].wxzy, r[0].wxzy, r[1].wxzy, r[2].wxzy)\n    // ZW\n    : axis == 5 ? mat4(r[3].wzxy, r[2].wzxy, r[0].wzxy, r[1].wzxy) : mat4(0.);\n}\n\n\n\nvec2 minWith(vec2 a, vec2 b) {\n  return (min(0., (a.x - b.x)) * a + min(0., (b.x - a.x)) * b) * -1. / abs(b.x - a.x);\n  // if (a.x <= b.x) {\n  //   return a;\n  // }\n  // return b;\n}\nvec4 minWith14(float a, vec4 av, float b, vec4 bv) {\n  float ba = b - a;\n  return (max(0., ba) * av + max(0., -ba) * bv) * -1. / abs(ba);\n  return b > a ? bv : av;\n}\n\n\n\n// Some SDFs\n\n\nfloat sdTriangle1(vec2 uv, float b) {\n  float willFold = sign(step(.0, -uv.x) + (step(.0, -uv.y) * step(0., -dot(sinCos(TAU / 12.), uv))));\n  float splitAt = -dot(sinCos(- 7. * TAU / 12.), uv);\n  float top = sign(splitAt);\n  float foldAngle = (step(0., top) * TAU / 4. + step(0., -top) * (TAU / 12.)) * willFold;\n  vec2 n = sinCos(foldAngle);\n  float fold = -dot(n, uv) * willFold;\n  uv += fold * n * 2.;\n  // get distance to line that is our edge\n  return dot(uv, sinCos(TAU / 6.)) - b * .5;\n}\n\nvec4 sdTriangle1(vec3 p, float b) {\n  return vec4(length(vec2(sdTriangle1(p.xy, b), p.z)), abs(p)); // approximate dists for each axis\n}\n\nfloat sdTriangle2(vec2 uv, float b) {\n  float a = atan(uv.x, uv.y) + PI;\n  float id = floor(a * 3. / TAU) - 1.;\n  vec2 n = sinCos(-id * 7. * TAU / 12.);\n  uv += - abs(id) * dot(n, uv) * n * 2.;\n  return  uv.y - b / 2.;  // estimate based only on y; but it works...\n}\n\nvec4 sdTriangle2(vec3 p, float b) {\n  vec3 dd = abs(p) - vec3(0,b,0);\n  return vec4(length(vec2(sdTriangle2(p.xy, b), p.z)), dd);\n}\n\nvec2 foldXyThirds(vec2 uv, out float id) {\n  float a = atan(uv.x, uv.y) + PI;\n  id = floor(a * 3. / TAU) - 1.;\n  vec2 n = sinCos(-id * 7. * TAU / 12.);\n  uv += - abs(id) * dot(n, uv) * n * 2.;\n  return abs(uv);\n}\n\nvec2 foldXyThirds(vec2 uv) {\n  float id;\n  return foldXyThirds(uv, id);\n}\n\nfloat sdTriangleGen(vec3 p, float r, out vec3 dists) {\n  p.xy = foldXyThirds(p.xy);\n\n  vec3 a = vec3(r / 2. * SQRT_3, r / 2., 0.);\n  vec3 b = a * vec3(-1, 1, 1);\n  vec3 ap = p - a;\n  vec3 ab = b - a;\n  //* (step(r / 2., p.y) * 2. - 1.)\n  float dotPaBa = dot(ap, ab);\n  float dotBaBa = dot(ab, ab);\n  float h = clamp(dotPaBa / dotBaBa, -0., 1.);\n  dists = ap - h * ab;\n  float d = length(dists);\n  // for negative:\n  // * (step(r / 2., p.y) * 2. - 1.);\n\n  return d;\n}\n\n/* searching for a similar generalized tetrahedron method didn't work,\nbut i found some fun triangle methods.\n\nThe following isn't exact, but it's p nice:\n*/\n\n\nvec3 sdTetrahedronInner(vec3 p, float r) {\n  float ySign = sign(p.y);\n  p.xz = abs(ySign < 0. ? p.zx : p.xz);\n  p.y = abs(p.y);\n  vec3 box = vec3(mix(r/2., r, p.y / r), r, mix(r/2., r, -p.y / r));\n  return p - box;\n}\n\nfloat sdTetrahedron(vec3 p, float r, out vec3 dists) {\n  dists = sdTetrahedronInner(p, r);\n  return length(bestOf(dists));\n}\n\nfloat sdTetrahedronFrame(vec3 p, float r, out vec3 dists) {\n  dists = sdTetrahedronInner(p, r);\n  return length(best2(dists));\n}\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtBXDW.jpg", "access": "api", "license": "cc0-1.0 OR openssl-ssleay OR apache-2.0", "functions": [[3193, 3193, 3250, 3250, 3366], [3368, 3368, 3426, 3426, 3542], [3544, 3544, 3600, 3600, 3644], [3646, 3646, 3690, 3891, 4632], [4634, 4634, 4653, 4653, 4697], [4699, 4761, 4818, 4818, 5121], [5149, 5174, 5246, 5246, 6791], [6794, 6794, 6827, 6827, 7136], [7138, 7138, 7193, 7193, 9269]], "test": "untested"}
{"id": "NtSXDW", "name": "2d ray marching - 3d sandbox", "author": "xertrov", "description": "This is a tool shader I wrote while writing a more complex shader to do 2d ray marching of 4d objects (this was simpler + let me test 3d shapes before 4d ones).\n2d ray marching produces a projection -- so 2d ray marching a 3d scene gives back a 1d image", "tags": ["raymarching", "raymarching", "sandbox", "learning", "experimental", "2draymarching", "2draymarching"], "likes": 1, "viewed": 300, "published": 3, "date": "1627642701", "time_retrieved": "2024-07-30T19:08:36.745145", "image_code": "precision highp float;\n/*\n\n4D VERSION + EXPLANATION: <https://www.shadertoy.com/view/NtBXDW>\n\nDo 2d raymarching over 1 axis with secondary ray march for projections.\n\nThe result is shown on the LHS -- a 1d image of the ray marched YZ plane\nwith the XY plane projected on it.\n\nNote: some bits of shapes are missed (in this case they should all appear\nsolid), but SURF_DIST is set quite low here.\n\nThe yellow bits mean MAX_STEPS is reached without reaching MAX_DIST or\nSURF_DIST.\n\nset HIGH_RESOURCES to 1 to see more shapes, but FYI it runs hot.\n\n*/\n\n#define MAX_STEPS 70\n#define MAX_DIST 25.\n#define SURF_DIST 0.001\n\n#define HIGH_RESOURCES 0\n\n\n// i used 'sld' for \"signed line-dist\" b/c I was trying to do the projection\n// via the distance between a point an a line (our ray direction is a normal\n// this line), but couldn't get it to work. I don't think it can work, but if\n// it could then it might speed things up a lot.\n\nvec4 sldBox(in vec3 p, in vec3 b) {\n  vec3 d = abs(p) - b;  // point on the line to corner\n  float l = length(max(d, 0.0)) + min(max(d.z, max(d.x, d.y)), 0.0);\n  return vec4(l, d);\n}\n\nvec4 sldBoxEdges(vec3 p, in vec3 s) {\n  vec3 d = abs(p) - s;\n  float l = length(best2(d));\n  return vec4(l, d);\n}\n\nvec4 minWith(vec4 a, vec4 b) {\n  return (min(0., (a.x - b.x)) * a + min(0., (b.x - a.x)) * b) * -1. / abs(b.x - a.x);\n}\n\nfloat mapWDists(vec3 p, out vec3 dists) {\n  mat3 r1 = rot3XY(u_time, 3), r2 = rot3XY(u_time * .48597, 1);\n  // r1 = rot3XY(u_time * .0, 3), r2 = rot3XY(u_time * .763 * .0, 2);\n  vec4 boxEdges = sldBoxEdges((p - vec3(0.4, 1.0 , 0)) * r2 * r2 * r1, vec3(.3)) - .01;\n  vec4 box = sldBox(p * r2 * r1, vec3(.3)) - .01;\n  vec4 tri = sdTriangle2((p - vec3(-.4, -.9, 0)) * r2 * r1, .3) - .01;\n  vec4 tri2 = sdTriangle1((p - vec3(.4, -1.4, 0)) * r2 * r1, .3) - .01;\n  vec4 tet;\n  tet.x = sdTetrahedron((p - vec3(.4, 1.9, 0)) * r2 * r1, .3, tet.yzw) - .01;\n\n  vec4 tri3;\n  tri3.x = sdTriangleGen((p - vec3(.5, 1.9, 0)) * r2 * r1, .3, tri3.yzw) - .01;\n\n  vec4 m = minWith(boxEdges, vec4(999.));\n  m = minWith(m, tri2);\n\n  if (HIGH_RESOURCES == 1) {\n    m = minWith(m, box);\n    m = minWith(m, tri);\n  }\n\n  dists = m.yzw;\n  return m.x;\n}\n\nfloat map(vec3 p) {\n  vec3 temp;\n  return mapWDists(p, temp);\n}\n\nvec4 rayMarch(inout vec3 p, in vec3 rd, out vec3 dists) {\n  float dS = 99., d = 0., minDS = dS, steps = 0.;\n  for (int i = 0; i < MAX_STEPS; i++) {\n    steps += 1.;\n    dS = mapWDists(p, dists);\n    minDS = min(minDS, abs(dS));\n    d += dS;\n    p = p + rd * dS;\n    if ((0. <= dS && dS < SURF_DIST) || d > MAX_DIST) break;\n  }\n  return vec4(d, dS, minDS, steps);\n}\n\nvec2 e = vec2(.0001, 0);\n\nvec4 rayMarch1d(inout vec3 p, in vec3 rd, in vec3 rd2, out vec3 dists) {\n  float dS = 99., dSx = 99., dSy, dSz, d = 0., minDS = dS, steps = 0.;\n  vec3 dists2;\n  for (int i = 0; i < MAX_STEPS; i++) {\n    steps += 1.;\n    dS = 99.;\n    dS = mapWDists(p, dists);\n    minDS = min(minDS, abs(dS));\n    if (dS > SURF_DIST) {\n      vec3 p2 = p - rd2 * 2.;\n      vec4 innerRmd = rayMarch(p2, rd2, dists2);\n      // steps += innerRmd.w;\n      if (innerRmd.x < MAX_DIST && innerRmd.y < SURF_DIST) {\n        p = p2;\n        return vec4(length(vec2(innerRmd.x, d)), innerRmd.yz, steps);\n      } else {\n        dS = min(dS, min(innerRmd.y, 99.));\n        minDS = min(minDS, abs(innerRmd.z));\n      }\n    }\n    // backported chBasis + slow_thru from 4d version\n    mat3 chBasis = mat3(rd.x, rd.y, rd.z, 0, 0, 0, rd2.x, rd2.y, rd2.z);\n    vec3 components = normalize(dists * chBasis);\n    d += dS;\n    float dsFactor = maxOf(vec4(components.xz, -components.xz));\n    dsFactor *= min(1., max(minOf(abs(p)) + .08, .01));\n    p = p + rd * dS * dsFactor;\n    if ((0. <= dS && dS < SURF_DIST) || d > MAX_DIST) break;\n  }\n  return vec4(d, dS, minDS, steps);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // split screen first\n  vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n  float aspect = u_resolution.x / u_resolution.y;\n  float id = sign(uv.x - .5);\n  uv.x = (fract(uv.x * 2.) - .5) * aspect;\n  uv.y -= .5;\n  vec2 mouse = (u_mouse.xy - 0.5 * u_resolution.xy) / u_resolution.y;\n  float t = u_time *3.;\n  vec3 col = BLACK;\n\n  float zoom = 3.0;\n  uv *= zoom * vec2(1.0, 2.0);\n  float maxU = zoom / 2. * aspect;\n  vec2 fw = fwidth(uv);\n\n  // starting with this at -2 (like you might with the z axis) results in issues rendering b/c the ray doesn't pass close enough to the objects to get the sideways projection right.\n  float xStart = hh(id) * uv.x;  // 0 for left, 1 for right\n  float yStart = uv.y + .5;\n  vec3 ro = vec3(xStart, yStart, -2);\n  vec3 rd = vec3(0, 0, 1);\n  vec3 xAxis = vec3(1, 0, 0);\n  mat3 r = rot3XY(t / 3., 1);\n  ro *= r;\n  rd *= r;\n  xAxis *= r;\n\n  vec3 p = ro, dists;\n  vec4 rmd;\n  if (id < 0.) {\n    rmd = rayMarch1d(p, rd, xAxis, dists);\n  } else {\n    rmd = rayMarch(p, rd, dists);\n  }\n\n  float d = rmd.x, dS = rmd.y, minDS = rmd.z, steps = rmd.w;\n\n  if (d > MAX_DIST) {\n    col = vec3(.95, .1, .7);\n  } else if (steps >= float(MAX_STEPS)) {\n    col = vec3(.8, .9, .1);\n  } else {\n    col.r += max(1. / (1. + d), 0.);\n    col.b = clamp(p.x, 0., 1.);\n  }\n\n  //col.g += max(1. / (1. + minDS), 0.);\n  //col.g += minDS / 2.;\n  //col.b += 1. / (1. + minDS);\n  //col += S(SURF_DIST * 2., SURF_DIST, minDS);\n\n  /* lines marking origin */\n  col.b += S(fw.x * 2., .0, abs(uv.x));\n  col.b += S(fw.y * 2., .0, abs(uv.y));\n  float around = .25;\n\n  col *= S((-maxU + fw.x * 3.) * id, (-maxU + fw.x * 5.) * id, uv.x);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "/* copy pasted from my libs. lots is written by me. you're welcome to use it, but caveat emptor. */\n\n#define u_resolution iResolution\n#define u_mouse iMouse\n#define u_time iTime\n#define gl_FragColor fragColor\n\n#define PI 3.141592653589\n#define TAU 6.28318530718\n\n#define SQRT_3 1.7320508\n#define SQRT_2 1.41421356\n\n#define S(a, b, t)smoothstep(a, b, t)\n#define hh(x)(x * 0.5 + 0.5)\n#define zoth vec4(0.0, 1.0, 2.0, 0.5)\n\n#define BLACK vec3(0.0)\n#define WHITE vec3(1.0)\n\nvec2 best2(vec3 p) {\n  vec2 r = vec2(max(p.x, p.y), min(p.x, p.y)); // : vec2(p.y, p.x);\n  if (p.z > r.x) { return vec2(p.z, r.x);}\n  if (p.z > r.y) { return vec2(r.x, p.z);}\n  return r;\n}\n\nvec2 best2(vec4 p) {\n  vec2 r = p.x > p.y ? vec2(p.x, p.y) : vec2(p.y, p.x);\n  if (p.z > r.x) { r = vec2(p.z, r.x); }\n  else if (p.z > r.y) { r = vec2(r.x, p.z); }\n  if (p.w > r.x) { return vec2(p.w, r.x); }\n  else if (p.w > r.y) { return vec2(r.x, p.w); }\n  return r;\n}\n\nfloat minOf(vec2 v) {\n  return min(v.x, v.y);\n}\nfloat maxOf(vec2 v) {\n  return max(v.x, v.y);\n}\nfloat sumOf(vec2 v) {\n  return v.x + v.y;\n}\n\nfloat minOf(vec3 v) {\n  return min(minOf(v.xy), v.z);\n}\nfloat maxOf(vec3 v) {\n  return max(maxOf(v.xy), v.z);\n}\nfloat sumOf(vec3 v) {\n  return sumOf(v.xy) + v.z;\n}\n\nfloat minOf(vec4 v) {\n  return min(minOf(v.xyz), v.w);\n}\nfloat maxOf(vec4 v) {\n  return max(maxOf(v.xyz), v.w);\n}\nfloat sumOf(vec4 v) {\n  return sumOf(v.xyz) + v.w;\n}\n\nfloat bestOf(vec2 p) {\n  // return p.x > p.y ? p.x : p.y;\n  return max(p.x, p.y);\n}\nfloat bestOf(vec3 p) {\n  return max(max(p.x, p.y), p.z);\n}\nfloat bestOf(vec4 p) {\n  return max(bestOf(p.xyz), p.w);\n}\n\n\nvec2 sinCos(in vec2 ab) {\n  return vec2(sin(ab.x), cos(ab.y));\n}\nvec2 sinCos(in float a) {\n  return vec2(sin(a), cos(a));\n}\n\n// roll from XY to XZ or YZ (0 no roll, 1=XZ, 2=YZ)\nmat3 rot3XY(float angle, int roll) {\n  float s = sin(angle), c = cos(angle);\n  mat3 r = mat3(c, - s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n  if (roll == 1) {\n    r = mat3(r[0].xzy, r[2].xzy, r[1].xzy);\n  } else if (roll == 2) {\n    r = mat3(r[2].zxy, r[0].zxy, r[1].zxy);\n  }\n  return r;\n}\n\n\n// Some SDFs\n\n\nfloat sdTriangle1(vec2 uv, float b) {\n  float willFold = sign(step(.0, -uv.x) + (step(.0, -uv.y) * step(0., -dot(sinCos(TAU / 12.), uv))));\n  float splitAt = -dot(sinCos(- 7. * TAU / 12.), uv);\n  float top = sign(splitAt);\n  float foldAngle = (step(0., top) * TAU / 4. + step(0., -top) * (TAU / 12.)) * willFold;\n  vec2 n = sinCos(foldAngle);\n  float fold = -dot(n, uv) * willFold;\n  uv += fold * n * 2.;\n  // get distance to line that is our edge\n  return dot(uv, sinCos(TAU / 6.)) - b * .5;\n}\n\nvec4 sdTriangle1(vec3 p, float b) {\n  return vec4(length(vec2(sdTriangle1(p.xy, b), p.z)), abs(p)); // approximate dists for each axis\n}\n\nfloat sdTriangle2(vec2 uv, float b) {\n  float a = atan(uv.x, uv.y) + PI;\n  float id = floor(a * 3. / TAU) - 1.;\n  vec2 n = sinCos(-id * 7. * TAU / 12.);\n  uv += - abs(id) * dot(n, uv) * n * 2.;\n  return  uv.y - b / 2.;  // estimate based only on y; but it works...\n}\n\nvec4 sdTriangle2(vec3 p, float b) {\n  vec3 dd = abs(p) - vec3(0,b,0);\n  return vec4(length(vec2(sdTriangle2(p.xy, b), p.z)), dd);\n}\n\nvec2 foldXyThirds(vec2 uv, out float id) {\n  float a = atan(uv.x, uv.y) + PI;\n  id = floor(a * 3. / TAU) - 1.;\n  vec2 n = sinCos(-id * 7. * TAU / 12.);\n  uv += - abs(id) * dot(n, uv) * n * 2.;\n  return abs(uv);\n}\n\nvec2 foldXyThirds(vec2 uv) {\n  float id;\n  return foldXyThirds(uv, id);\n}\n\nfloat sdTriangleGen(vec3 p, float r, out vec3 dists) {\n  p.xy = foldXyThirds(p.xy);\n\n  vec3 a = vec3(r / 2. * SQRT_3, r / 2., 0.);\n  vec3 b = a * vec3(-1, 1, 1);\n  vec3 ap = p - a;\n  vec3 ab = b - a;\n  //* (step(r / 2., p.y) * 2. - 1.)\n  float dotPaBa = dot(ap, ab);\n  float dotBaBa = dot(ab, ab);\n  float h = clamp(dotPaBa / dotBaBa, -0., 1.);\n  dists = ap - h * ab;\n  float d = length(dists);\n  // for negative:\n  // * (step(r / 2., p.y) * 2. - 1.);\n\n  return d;\n}\n\n/* searching for a similar generalized tetrahedron method didn't work,\nbut i found some fun triangle methods.\n\nThe following isn't exact, but it's p nice:\n*/\n\n\nvec3 sdTetrahedronInner(vec3 p, float r) {\n  float ySign = sign(p.y);\n  p.xz = abs(ySign < 0. ? p.zx : p.xz);\n  p.y = abs(p.y);\n  vec3 box = vec3(mix(r/2., r, p.y / r), r, mix(r/2., r, -p.y / r));\n  return p - box;\n}\n\nfloat sdTetrahedron(vec3 p, float r, out vec3 dists) {\n  dists = sdTetrahedronInner(p, r);\n  return length(bestOf(dists));\n}\n\nfloat sdTetrahedronFrame(vec3 p, float r, out vec3 dists) {\n  dists = sdTetrahedronInner(p, r);\n  return length(best2(dists));\n}\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtSXDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[925, 925, 960, 960, 1107], [1109, 1109, 1146, 1146, 1222], [1224, 1224, 1254, 1254, 1343], [1345, 1345, 1386, 1386, 2170], [2172, 2172, 2191, 2191, 2235], [2237, 2237, 2294, 2294, 2601], [2629, 2629, 2701, 2701, 3767], [3769, 3769, 3824, 3848, 5484]], "test": "untested"}
{"id": "NtSSDW", "name": "Bidirectional Tracer Reproj", "author": "michael0884", "description": "Camera controls are WASD and QR for roll. R reset accumulation. N to shoot a ray.\nStoring a light path and then using it for next event estimation in path tracing, the NEE is importance sampled so that the probability of hitting a light path is maximized.", "tags": ["camera", "pathtracer", "laser", "bidirectional"], "likes": 65, "viewed": 1808, "published": 3, "date": "1627641320", "time_retrieved": "2024-07-30T19:08:38.440612", "image_code": "// Fork of \"Volumetric laser tracer\" by michael0884. https://shadertoy.com/view/NtXSR4\n// 2021-07-22 19:27:50\n\nvec3 encodeSRGB(vec3 linearRGB)\n{\n    vec3 a = 12.92 * linearRGB;\n    vec3 b = 1.055 * pow(linearRGB, vec3(1.0 / 2.)) - 0.055;\n    vec3 c = step(vec3(0.0031308), linearRGB);\n    return mix(a, b, c);\n}\n\nvec3 tone(vec3 c)\n{\n    c = XYZtosRGB(c);\n    return tanh(encodeSRGB(c));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 acc = texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor = vec4(tone(0.1*acc.xyz/acc.w), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//controller\n\n//Keyboard constants\nconst int keyLe = 37, keyUp = 38, keyRi = 39, keyDn = 40, keyA = 65, keyB = 66, keyC = 67, keyD = 68, keyE = 69, keyF = 70, keyG = 71, keyH = 72, keyI = 73, keyJ = 74, keyK = 75, keyL = 76, keyM = 77, keyN = 78, keyO = 79, keyP = 80, keyQ = 81, keyR = 82, keyS = 83, keyT = 84, keyU = 85, keyV = 86, keyW = 87, keyX = 88, keyY = 89, keyZ = 90;\n\nbool pressed(int k) \n{\n    return texelFetch(iChannel3, ivec2(k, 0), 0).x > 0.5;\n}\n\nconst float force =25.0;\nconst float mouse_sens = 100.0;\nconst float roll_speed = 0.5;\n\nvoid mainImage( out vec4 o, in vec2 p )\n{\n    p = floor(p);\n    if(p.x > NAddr && p.y > 0.) discard;\n    \n    //get camera data\n    vec3 cp = get(CamP).xyz;\n    vec4 ca = normalize(get(CamA));\n    \n    vec3 pcp = cp;\n    vec4 pca = ca;\n    \n    vec3 ro = get(RayO).xyz;\n    vec3 rd = get(RayD).xyz;\n    \n    float mode = 0.0;\n    if(pressed(keyR)) mode = 1.0;\n    \n    //initialization\n    if(iFrame < 10)\n    {\n        cp = vec3(-1.,1.5,-1);\n        ca = aa2q( normalize(vec3(0,1,0)), -PI*0.6/4.0);\n        mat3 cam = getCam(ca);\n        ca = qq2q(ca, aa2q(cam*vec3(1,0,0), -PI*0.4/4.0)); \n        ro = vec3( -2,.252, 0);\n        rd = normalize(vec3(0.3,0.,-0.002));\n    }\n    vec4 oldca = ca;\n    if(p.x == PrevCamP) o = vec4(cp, 0);\n    if(p.x == PrevCamA) o = ca;\n    \n    mat3 cam = getCam(ca);\n    \n    //get velocities\n    vec3 cv = get(CamV).xyz;\n    vec4 cav = get(CamAV);\n    \n    float dt = 1./60.0;\n    //update position\n    if(pressed(keyW)) cv += force*dt*cam*vec3(0,0,1);\n    if(pressed(keyS)) cv += force*dt*cam*vec3(0,0,-1);\n    if(pressed(keyA)) cv += force*dt*cam*vec3(-1,0,0);\n    if(pressed(keyD)) cv += force*dt*cam*vec3(1,0,0);\n    \n    cp += dt*cv;\n    cv += -cv*tanh(10.0*dt);\n    \n    //update camera orientation\n    vec2 dmouse = dt*mouse_sens*(iMouse.xy - get(PrevMouse).xy)/iResolution.x;\n    \n    if(length(dmouse) < 0.1)\n    {\n        //rotate around y ax\n        ca = qq2q(ca, aa2q(cam*vec3(0,1,0), -dmouse.x)); \n        //rotate around x ax\n        ca = qq2q(ca, aa2q(cam*vec3(1,0,0), dmouse.y));\n    }\n    \n    //roll camera\n    if(pressed(keyQ)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), -roll_speed*dt)); \n    if(pressed(keyE)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), roll_speed*dt)); \n    \n    if(distance(oldca, ca) > 0.001 || length(cv) > 0.01) mode = 1.0;\n    \n    if(pressed(keyN)) \n    {\n        rd = cam*vec3(0,0,1);\n        ro = cp + 0.05*cam*vec3(1,1,0);\n    }\n    \n    if(p.x == CamP) o = vec4(cp, mode);\n    if(p.x == CamA) o = ca;\n    if(p.x == PrevCamP) o = vec4(pcp, mode);\n    if(p.x == PrevCamA) o = pca;\n    if(p.x == CamV) o = vec4(cv, 0.0);\n    if(p.x == CamAV) o = vec4(0.0);\n    if(p.x == PrevMouse) o = vec4(iMouse.xy, 0, 0);\n    if(p.x == RayO) o = vec4(ro, 0);\n    if(p.x == RayD) o = vec4(rd, 0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n#define FOV 1.1\n#define CAM_ANGLE 0.001\n#define MAX_STEPS 90\n#define MIN_DIST 1e-5\n#define MAX_DIST 500.0\n\n//(reused some of @ollj's code, made it more readible)\n\nvec3 light = normalize(vec3(0,1,0));\nconst float light_bright =1.0;\nconst float light_ang = 0.1;\n\n//specific controller buffer Addresses\nconst float CamP = 0.,     //camera position \n            CamA = 1.,     //camera rotation quaternion    \n            CamV = 2.,     //camera velocity\n            CamAV = 3.,    //camera rotation velocity\n            PrevCamP = 4., //previous frame camera position\n            PrevCamA = 5., //previous frame camera rotation quaternion\n            PrevMouse = 6.,//previous mouse pos\n            RayO = 7.,     //previous mouse pos\n            RayD = 8.,     //previous mouse pos\n            NAddr = 9.;    //max address count\n            \n#define get(i) texelFetch(iChannel2,ivec2(i,0),0)\n\nfloat sqr(float x)\n{\n    return x*x;\n}\n\nvec3 reproject(mat3 pcam_mat, vec3 pcam_pos, vec2 iRes, vec3 p)\n{\n    float td = distance(pcam_pos, p);\n    vec3 dir = (p - pcam_pos)/td;\n    vec3 screen = dir*pcam_mat;\n    return vec3(screen.xy*iRes.y/(FOV*screen.z) + 0.5*iRes.xy, td);\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n              in vec3 planeNormal, in float planeDist) {\n    float a = dot(rd, planeNormal);\n    float d = -(dot(ro, planeNormal)+planeDist)/a;\n    if (a > 0. || d < distBound.x || d > distBound.y) {\n        return MAX_DIST;\n    } else {\n        normal = planeNormal;\n    \treturn d;\n    }\n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n               float sphereRadius ) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - sphereRadius*sphereRadius;\n    float h = b*b - c;\n    if (h < 0.) {\n        return MAX_DIST;\n    } else {\n\t    h = sqrt(h);\n        float d1 = -b-h;\n        float d2 = -b+h;\n        if (d1 >= distBound.x && d1 <= distBound.y) {\n            normal = normalize(ro + rd*d1);\n            return d1;\n        } else if (d2 >= distBound.x && d2 <= distBound.y) { \n            normal = normalize(ro + rd*d2);            \n            return d2;\n        } else {\n            return MAX_DIST;\n        }\n    }\n}\n\nfloat iBox( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal, \n            in vec3 boxSize ) {\n    vec3 m = sign(rd)/max(abs(rd), 1e-8);\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if (tN > tF || tF <= 0.) {\n        return MAX_DIST;\n    } else {\n        if (tN >= distBound.x && tN <= distBound.y) {\n        \tnormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n            return tN;\n        } else if (tF >= distBound.x && tF <= distBound.y) { \n        \tnormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n            return tF;\n        } else {\n            return MAX_DIST;\n        }\n    }\n}\n\nfloat iCylinder( in vec3 ro, in vec3 rd, \n                in vec3 pa, in vec3 pb, float ra ) // extreme a, extreme b, radius\n{\n    vec3 ba = pb-pa;\n\n    vec3  oc = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoc = dot(ba,oc);\n    \n    float k2 = baba            - bard*bard;\n    float k1 = baba*dot(oc,rd) - baoc*bard;\n    float k0 = baba*dot(oc,oc) - baoc*baoc - ra*ra*baba;\n    \n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return 1e10;\n    h = sqrt(h);\n    float t = (-k1-h)/k2;\n\n    // body\n    float y = baoc + t*bard;\n    if( y>0.0 && y<baba ) return t;\n    \n    // caps\n    t = ( ((y<0.0) ? 0.0 : baba) - baoc)/bard;\n    if( abs(k1+k2*t)<h )\n    {\n        return t;\n    }\n\n    return 1e10;\n}\n\n//ollj quaternionRotation math\n//\n//ANY rotations in 3d are non-commutative!\n//\n//matrix rotations are just bulky, memory wasting\n//EulerRotations almost certainly fail to rotate over the SHORTEST path.\n//EulerRotations almost certainly will gimbalLock and get stuck along one axis\n//QuaternionRotations are superior here.\n//-> we only use EulerRorations for simple input devices (keyboard input)\n//-> we convert to quaternions, buffered as vec4.\n\n//quaternion Identity\nvec4 qid() \n{\n    return vec4(0, 0, 0, 1);\n}\n\n//return quaternion from axis and angle\nvec4 aa2q(vec3 axis, float ang) \n{\n    vec2 g = vec2(sin(ang), cos(ang)) * 0.5;\n    return normalize(vec4(axis * g.x, g.y));\n}\n\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q) \n{\n    return vec4(q.xyz / sqrt(1.0 - q.w * q.w), acos(q.w) * 2.);\n}\n\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2) \n{\n    return vec4(q1.xyz * q2.w + q2.xyz * q1.w + cross(q1.xyz, q2.xyz), (q1.w * q2.w) - dot(q1.xyz, q2.xyz));\n}\n\n//extension to qq2q(), scaled by sensitivity [f] (==quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f) \n{\n    float d = dot(a, b), t = acos(abs(d)), o = (1. / sin(t));\n    return normalize(a * sin(t * (1.0 - f)) * o * sign(d) + b * sin(t * f) * o);\n}\n\n//doing qq2q() multiple times, you need to normalize() the quaternion, to fix rounding errors.\n//how often you do this is up to you.\n\n//normalize q (assuming length(q) is already close to 1, we can skip whe sqrt()\nvec4 qn(vec4 q) \n{\n    return q / dot(q,q);\n}\n\n//return quaternion, that is the shortest rotation, between looking to [a before], and looking to [b after] the rotation.\n//http://wiki.secondlife.com/wiki/LlRotBetween\nvec4 qBetween(vec3 a, vec3 b) \n{\n    float v = sqrt(dot(a,a) * dot(a,a));\n\n    if(v == 0.) return qid();\n    \n    v = dot(a, b) / v;\n    vec3 c = a.yzx * b.zxy - a.zxy * b.yzx / v;\n    float d = dot(c,c);\n    \n    if(d != 0.) \n    {\n        float s = (v > - 0.707107) ? 1. + v : d / (1. + sqrt(1. - d));\n        return vec4(c, s) / sqrt(d + s * s);\n    }\n    \n    if(v > 0.) return qid();\n    \n    float m = length(a.xy);\n    \n    return (m != 0.) ? vec4(a.y, - a.x, 0, 0) / m : vec4(1, 0, 0, 0);\n}\n\n//return inverse of quaternion\nvec4 qinv(vec4 q) \n{\n    return vec4(- q.xyz, q.w) / dot(q,q);\n}\n\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q, vec3 p) \n{\n    return qq2q(q, qq2q(vec4(p, .0), qinv(q))).xyz;\n}\n\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it is rotated by VECTOR p (as if it is a quaternion)\nvec3 vq2v(vec3 p, vec4 q) \n{\n    return qq2q(qinv(q), qq2q(vec4(p, 0.0), q)).xyz;\n}\n\nvec3 vq2v(vec4 a, vec3 b) \n{\n    return qv2v(a, b);\n}\n\n//in case of namespace confuction\nvec3 qv2v(vec3 a, vec4 b) \n{\n    return vq2v(a, b);\n}\n\n//return mat3 of quaternion (rotation matrix without translation)\n//https://www.shadertoy.com/view/WsGfWm\nmat3 q2m(vec4 q) \n{\n    vec3 a = vec3(-1, 1, 1);\n    vec3 u = q.zyz * a, v = q.xyx * a.xxy;\n    mat3 m = mat3(0.5) + mat3(0, u.x,u.y,u.z, 0, v.x,v.y,v.z, 0) * q.w + matrixCompMult(outerProduct(q.xyz, q.xyz), 1. - mat3(1));\n    q *= q; \n    m -= mat3(q.y + q.z, 0, 0, 0, q.x + q.z, 0, 0, 0, q.x + q.y);\n    return m * 2.0;\n}\n\n//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\nvec4 m2q(mat3 m) \n{\n#define m2f(a,b) m[a][b]-m[b][a]\n    //http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n    float q = 2. * sqrt(abs(1. + m[0][0] + m[1][1] + m[2][2]));\n    return vec4(vec3(m2f(2, 1), m2f(0, 1), m2f(1, 0)) / q / 4., q);\n#undef m2f\n}\n\nfloat at2e(vec2 a) \n{\n    a *= 2.;\n    return atan(a.x, 1. - a.y);\n}\n\n//return quaternion of Euler[yaw,pitch,roll]     \nvec4 eYPR2q(vec3 o) \n{\n    o *= .5;\n    vec3 s = sin(o);\n    //https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n    o = cos(o);\n    vec4 a = vec4(s.xz, o.xz);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(-1, 1, -1, 1);\n}\n\nvec4 eYPR2q(vec2 o) \n{\n    o *= .5;\n    vec2 s = sin(o);\n    o = cos(o);\n    vec4 a = vec4(s.x, 0., o.x, 0.);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(- 1, 1, - 1, 1);\n}\n\nmat3 getCam(vec4 q) \n{\n    return q2m(q);\n}\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nuvec4 pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    return v;\n}\n\nfloat rand(){ return float(pcg4d(s0).x)/float(0xffffffffu); }\nvec2 rand2(){ return vec2(pcg4d(s0).xy)/float(0xffffffffu); }\nvec3 rand3(){ return vec3(pcg4d(s0).xyz)/float(0xffffffffu); }\nvec4 rand4(){ return vec4(pcg4d(s0))/float(0xffffffffu); }\n\nvec2 nrand2(float sigma, vec2 mean)\n{\n\tvec2 Z = rand2();\n    return mean + sigma * sqrt(-2.0 * log(Z.x)) * \n           vec2(cos(TWO_PI * Z.y),sin(TWO_PI * Z.y));\n}\n\nvec3 nrand3(float sigma, vec3 mean)\n{\n\tvec4 Z = rand4();\n    return mean + sigma * sqrt(-2.0 * log(Z.xxy)) * \n           vec3(cos(TWO_PI * Z.z),sin(TWO_PI * Z.z),cos(TWO_PI * Z.w));\n}\n\n//uniformly spherically distributed\nvec3 udir(vec2 rng)\n{\n    vec2 r = vec2(2.*PI*rng.x, acos(2.*rng.y-1.));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}\n\nconst float PI2 = 6.2831853071;\n\nconst float aperture_size = 0.0;\nvec2 aperture()\n{\n    vec2 r = rand2();\n    return vec2(sin(TWO_PI*r.x), cos(TWO_PI*r.x))*sqrt(r.y);\n}\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\nvec3 spectral_zucconi(float w)\n{\n    // w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\n\tconst vec3 cs = vec3(3.54541723, 2.86670055, 2.29421995);\n\tconst vec3 xs = vec3(0.69548916, 0.49416934, 0.28269708);\n\tconst vec3 ys = vec3(0.02320775, 0.15936245, 0.53520021);\n\n\treturn bump3y (\tcs * (x - xs), ys);\n}\n\nvec3 spectral_bruton (float w)\n{\n\tvec3 c;\n\n\tif (w >= 380. && w < 440.)\n\t\tc = vec3\n\t\t(\n\t\t\t-(w - 440.) / (440. - 380.),\n\t\t\t0.0,\n\t\t\t1.0\n\t\t);\n\telse if (w >= 440. && w < 490.)\n\t\tc = vec3\n\t\t(\n\t\t\t0.0,\n\t\t\t(w - 440.) / (490. - 440.),\n\t\t\t1.0\n\t\t);\n\telse if (w >= 490. && w < 510.)\n\t\tc = vec3\n\t\t(\t0.0,\n\t\t\t1.0,\n\t\t\t-(w - 510.) / (510. - 490.)\n\t\t);\n\telse if (w >= 510. && w < 580.)\n\t\tc = vec3\n\t\t(\n\t\t\t(w - 510.) / (580. - 510.),\n\t\t\t1.0,\n\t\t\t0.0\n\t\t);\n\telse if (w >= 580. && w < 645.)\n\t\tc = vec3\n\t\t(\n\t\t\t1.0,\n\t\t\t-(w - 645.) / (645. - 580.),\n\t\t\t0.0\n\t\t);\n\telse if (w >= 645. && w <= 780.)\n\t\tc = vec3\n\t\t(\t1.0,\n\t\t\t0.0,\n\t\t\t0.0\n\t\t);\n\telse\n\t\tc = vec3\n\t\t(\t0.0,\n\t\t\t0.0,\n\t\t\t0.0\n\t\t);\n\n\treturn saturate(c);\n}\nvec3 spectral_zucconi6 (float w)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n        float y = baoa + t*bard;\n        // body\n        if( y>0.0 && y<baba ) return t;\n        // caps\n        vec3 oc = (y<=0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - r*r;\n        h = b*b - c;\n        if( h>0.0 ) return -b - sqrt(h);\n    }\n    return -1.0;\n}\n\n\n// Spectrum to xyz approx function from Sloan http://jcgt.org/published/0002/02/01/paper.pdf\n// Inputs:  Wavelength in nanometers\nfloat xFit_1931( float wave )\n{\n    float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374),\n          t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323),\n          t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\n}\nfloat yFit_1931( float wave )\n{\n    float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247),\n          t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\n}\nfloat zFit_1931( float wave )\n{\n    float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278),\n          t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\n}\n\n#define xyzFit_1931(w) vec3( xFit_1931(w), yFit_1931(w), zFit_1931(w) ) \n\n// http://www.cie.co.at/technical-work/technical-resources\nvec3 standardObserver1931[] =\n    vec3[] (\n    vec3( 0.001368, 0.000039, 0.006450 ), // 380 nm\n    vec3( 0.002236, 0.000064, 0.010550 ), // 385 nm\n    vec3( 0.004243, 0.000120, 0.020050 ), // 390 nm\n    vec3( 0.007650, 0.000217, 0.036210 ), // 395 nm\n    vec3( 0.014310, 0.000396, 0.067850 ), // 400 nm\n    vec3( 0.023190, 0.000640, 0.110200 ), // 405 nm\n    vec3( 0.043510, 0.001210, 0.207400 ), // 410 nm\n    vec3( 0.077630, 0.002180, 0.371300 ), // 415 nm\n    vec3( 0.134380, 0.004000, 0.645600 ), // 420 nm\n    vec3( 0.214770, 0.007300, 1.039050 ), // 425 nm\n    vec3( 0.283900, 0.011600, 1.385600 ), // 430 nm\n    vec3( 0.328500, 0.016840, 1.622960 ), // 435 nm\n    vec3( 0.348280, 0.023000, 1.747060 ), // 440 nm\n    vec3( 0.348060, 0.029800, 1.782600 ), // 445 nm\n    vec3( 0.336200, 0.038000, 1.772110 ), // 450 nm\n    vec3( 0.318700, 0.048000, 1.744100 ), // 455 nm\n    vec3( 0.290800, 0.060000, 1.669200 ), // 460 nm\n    vec3( 0.251100, 0.073900, 1.528100 ), // 465 nm\n    vec3( 0.195360, 0.090980, 1.287640 ), // 470 nm\n    vec3( 0.142100, 0.112600, 1.041900 ), // 475 nm\n    vec3( 0.095640, 0.139020, 0.812950 ), // 480 nm\n    vec3( 0.057950, 0.169300, 0.616200 ), // 485 nm\n    vec3( 0.032010, 0.208020, 0.465180 ), // 490 nm\n    vec3( 0.014700, 0.258600, 0.353300 ), // 495 nm\n    vec3( 0.004900, 0.323000, 0.272000 ), // 500 nm\n    vec3( 0.002400, 0.407300, 0.212300 ), // 505 nm\n    vec3( 0.009300, 0.503000, 0.158200 ), // 510 nm\n    vec3( 0.029100, 0.608200, 0.111700 ), // 515 nm\n    vec3( 0.063270, 0.710000, 0.078250 ), // 520 nm\n    vec3( 0.109600, 0.793200, 0.057250 ), // 525 nm\n    vec3( 0.165500, 0.862000, 0.042160 ), // 530 nm\n    vec3( 0.225750, 0.914850, 0.029840 ), // 535 nm\n    vec3( 0.290400, 0.954000, 0.020300 ), // 540 nm\n    vec3( 0.359700, 0.980300, 0.013400 ), // 545 nm\n    vec3( 0.433450, 0.994950, 0.008750 ), // 550 nm\n    vec3( 0.512050, 1.000000, 0.005750 ), // 555 nm\n    vec3( 0.594500, 0.995000, 0.003900 ), // 560 nm\n    vec3( 0.678400, 0.978600, 0.002750 ), // 565 nm\n    vec3( 0.762100, 0.952000, 0.002100 ), // 570 nm\n    vec3( 0.842500, 0.915400, 0.001800 ), // 575 nm\n    vec3( 0.916300, 0.870000, 0.001650 ), // 580 nm\n    vec3( 0.978600, 0.816300, 0.001400 ), // 585 nm\n    vec3( 1.026300, 0.757000, 0.001100 ), // 590 nm\n    vec3( 1.056700, 0.694900, 0.001000 ), // 595 nm\n    vec3( 1.062200, 0.631000, 0.000800 ), // 600 nm\n    vec3( 1.045600, 0.566800, 0.000600 ), // 605 nm\n    vec3( 1.002600, 0.503000, 0.000340 ), // 610 nm\n    vec3( 0.938400, 0.441200, 0.000240 ), // 615 nm\n    vec3( 0.854450, 0.381000, 0.000190 ), // 620 nm\n    vec3( 0.751400, 0.321000, 0.000100 ), // 625 nm\n    vec3( 0.642400, 0.265000, 0.000050 ), // 630 nm\n    vec3( 0.541900, 0.217000, 0.000030 ), // 635 nm\n    vec3( 0.447900, 0.175000, 0.000020 ), // 640 nm\n    vec3( 0.360800, 0.138200, 0.000010 ), // 645 nm\n    vec3( 0.283500, 0.107000, 0.000000 ), // 650 nm\n    vec3( 0.218700, 0.081600, 0.000000 ), // 655 nm\n    vec3( 0.164900, 0.061000, 0.000000 ), // 660 nm\n    vec3( 0.121200, 0.044580, 0.000000 ), // 665 nm\n    vec3( 0.087400, 0.032000, 0.000000 ), // 670 nm\n    vec3( 0.063600, 0.023200, 0.000000 ), // 675 nm\n    vec3( 0.046770, 0.017000, 0.000000 ), // 680 nm\n    vec3( 0.032900, 0.011920, 0.000000 ), // 685 nm\n    vec3( 0.022700, 0.008210, 0.000000 ), // 690 nm\n    vec3( 0.015840, 0.005723, 0.000000 ), // 695 nm\n    vec3( 0.011359, 0.004102, 0.000000 ), // 700 nm\n    vec3( 0.008111, 0.002929, 0.000000 ), // 705 nm\n    vec3( 0.005790, 0.002091, 0.000000 ), // 710 nm\n    vec3( 0.004109, 0.001484, 0.000000 ), // 715 nm\n    vec3( 0.002899, 0.001047, 0.000000 ), // 720 nm\n    vec3( 0.002049, 0.000740, 0.000000 ), // 725 nm\n    vec3( 0.001440, 0.000520, 0.000000 ), // 730 nm\n    vec3( 0.001000, 0.000361, 0.000000 ), // 735 nm\n    vec3( 0.000690, 0.000249, 0.000000 ), // 740 nm\n    vec3( 0.000476, 0.000172, 0.000000 ), // 745 nm\n    vec3( 0.000332, 0.000120, 0.000000 ), // 750 nm\n    vec3( 0.000235, 0.000085, 0.000000 ), // 755 nm\n    vec3( 0.000166, 0.000060, 0.000000 ), // 760 nm\n    vec3( 0.000117, 0.000042, 0.000000 ), // 765 nm\n    vec3( 0.000083, 0.000030, 0.000000 ), // 770 nm\n    vec3( 0.000059, 0.000021, 0.000000 ), // 775 nm\n    vec3( 0.000042, 0.000015, 0.000000 )  // 780 nm\n);\nfloat standardObserver1931_w_min = 380.0f;\nfloat standardObserver1931_w_max = 780.0f;\nint standardObserver1931_length = 81;\n\nvec3 WavelengthToXYZLinear( float fWavelength )\n{\n    float fPos = ( fWavelength - standardObserver1931_w_min ) / (standardObserver1931_w_max - standardObserver1931_w_min);\n    float fIndex = fPos * float(standardObserver1931_length);\n    float fFloorIndex = floor(fIndex);\n    float fBlend = clamp( fIndex - fFloorIndex, 0.0, 1.0 );\n    int iIndex0 = int(fFloorIndex);\n    int iIndex1 = iIndex0 + 1;\n    iIndex1 = min( iIndex1, standardObserver1931_length - 1);\n\n    return mix( standardObserver1931[iIndex0], standardObserver1931[iIndex1], fBlend );\n}\n\nvec3 XYZtosRGB( vec3 XYZ )\n{\n    // XYZ to sRGB\n    // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n   mat3 m = mat3 (\n        3.2404542, -1.5371385, -0.4985314,\n\t\t-0.9692660,  1.8760108,  0.0415560,\n \t\t0.0556434, -0.2040259,  1.0572252 );\n    \n    return XYZ * m;\n}\n\nvec3 sRGBtoXYZ( vec3 RGB )\n{\n   // sRGB to XYZ\n   // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n\n   mat3 m = mat3(  \t0.4124564,  0.3575761, 0.1804375,\n \t\t\t\t\t0.2126729,  0.7151522, 0.0721750,\n \t\t\t\t\t0.0193339,  0.1191920, 0.9503041 );\n    \n    \n    return RGB * m;\n}\n\nvec3 WavelengthToXYZ( float f )\n{    \n    //return xyzFit_1931( f ) * mXYZtoSRGB;\n    \n    return WavelengthToXYZLinear( f );\n}\n\n\nstruct Chromaticities\n{\n    vec2 R, G, B, W;\n};\n    \nvec3 CIE_xy_to_xyz( vec2 xy )\n{\n    return vec3( xy, 1.0f - xy.x - xy.y );\n}\n\nvec3 CIE_xyY_to_XYZ( vec3 CIE_xyY )\n{\n    float x = CIE_xyY[0];\n    float y = CIE_xyY[1];\n    float Y = CIE_xyY[2];\n    \n    float X = (Y / y) * x;\n    float Z = (Y / y) * (1.0 - x - y);\n        \n\treturn vec3( X, Y, Z );        \n}\n\nvec3 CIE_XYZ_to_xyY( vec3 CIE_XYZ )\n{\n    float X = CIE_XYZ[0];\n    float Y = CIE_XYZ[1];\n    float Z = CIE_XYZ[2];\n    \n    float N = X + Y + Z;\n    \n    float x = X / N;\n    float y = Y / N;\n    float z = Z / N;\n    \n    return vec3(x,y,Y);\n}\n\nChromaticities Primaries_Rec709 =\nChromaticities(\n        vec2( 0.6400, 0.3300 ),\t// R\n        vec2( 0.3000, 0.6000 ),\t// G\n        vec2( 0.1500, 0.0600 ), \t// B\n        vec2( 0.3127, 0.3290 ) );\t// W\n\nChromaticities Primaries_Rec2020 =\nChromaticities(\n        vec2( 0.708,  0.292 ),\t// R\n        vec2( 0.170,  0.797 ),\t// G\n        vec2( 0.131,  0.046 ),  \t// B\n        vec2( 0.3127, 0.3290 ) );\t// W\n\nChromaticities Primaries_DCI_P3_D65 =\nChromaticities(\n        vec2( 0.680,  0.320 ),\t// R\n        vec2( 0.265,  0.690 ),\t// G\n        vec2( 0.150,  0.060 ),  \t// B\n        vec2( 0.3127, 0.3290 ) );\t// W\n\nmat3 RGBtoXYZ( Chromaticities chroma )\n{\n    // xyz is a projection of XYZ co-ordinates onto to the plane x+y+z = 1\n    // so we can reconstruct 'z' from x and y\n    \n    vec3 R = CIE_xy_to_xyz( chroma.R );\n    vec3 G = CIE_xy_to_xyz( chroma.G );\n    vec3 B = CIE_xy_to_xyz( chroma.B );\n    vec3 W = CIE_xy_to_xyz( chroma.W );\n    \n    // We want vectors in the directions R, G and B to form the basis of\n    // our matrix...\n    \n\tmat3 mPrimaries = mat3 ( R, G, B );\n    \n    // but we want to scale R,G and B so they result in the\n    // direction W when the matrix is multiplied by (1,1,1)\n    \n    vec3 W_XYZ = W / W.y;\n\tvec3 vScale = inverse( mPrimaries ) * W_XYZ;\n    \n    return transpose( mat3( R * vScale.x, G * vScale.y, B * vScale.z ) );\n}\n\nmat3 XYZtoRGB( Chromaticities chroma )\n{\n    return inverse( RGBtoXYZ(chroma) );\n}\n\n// chromatic adaptation\n\n// http://www.brucelindbloom.com/index.html?Eqn_ChromAdapt.html    \n\n// Test viewing condition CIE XYZ tristimulus values of whitepoint.\nvec3 XYZ_w = vec3( 1.09850,\t1.00000,\t0.35585); // Illuminant A\n// Reference viewing condition CIE XYZ tristimulus values of whitepoint.\nvec3 XYZ_wr = vec3(0.95047,\t1.00000,\t1.08883); // D65\n\n\nconst mat3 CA_A_to_D65_VonKries = mat3(\n    0.9394987, -0.2339150,  0.4281177,\n\t-0.0256939,  1.0263828,  0.0051761,\n \t0.0000000,  0.0000000,  3.0598005\n    );\n\n\nconst mat3 CA_A_to_D65_Bradford = mat3(\n    0.8446965, -0.1179225,  0.3948108,\n\t-0.1366303,  1.1041226,  0.1291718,\n \t0.0798489, -0.1348999,  3.1924009\n    );\n\n\nconst mat3 mCAT_VonKries = mat3 ( \n    0.4002400,  0.7076000, -0.0808100,\n\t-0.2263000,  1.1653200,  0.0457000,\n \t0.0000000,  0.0000000,  0.9182200 );\n\nconst mat3 mCAT_02 = mat3( \t0.7328, 0.4296, -0.1624,\n\t\t\t\t\t\t\t-0.7036, 1.6975, 0.0061,\n \t\t\t\t\t\t\t0.0030, 0.0136, 0.9834 );\n\nconst mat3 mCAT_Bradford = mat3 (  0.8951000, 0.2664000, -0.1614000,\n\t\t\t\t\t\t\t\t-0.7502000,  1.7135000,  0.0367000,\n \t\t\t\t\t\t\t\t0.0389000, -0.0685000,  1.0296000 );\n\n\nmat3 GetChromaticAdaptionMatrix()\n{\n    //return inverse(CA_A_to_D65_VonKries);    \n    //return inverse(CA_A_to_D65_Bradford);\n        \n    //return mat3(1,0,0, 0,1,0, 0,0,1); // do nothing\n    \n\t//mat3 M = mCAT_02;\n    //mat3 M = mCAT_Bradford;\n    mat3 M = mCAT_VonKries;\n    //mat3 M = mat3(1,0,0,0,1,0,0,0,1);\n    \n    vec3 w = XYZ_w * M;\n    vec3 wr = XYZ_wr * M;\n    vec3 s = w / wr;\n    \n    mat3 d = mat3( \n        s.x,\t0,\t\t0,  \n        0,\t\ts.y,\t0,\n        0,\t\t0,\t\ts.z );\n        \n    mat3 cat = M * d * inverse(M);\n    return cat;\n}\n\nfloat BlackBody( float t, float w_nm )\n{\n    float h = 6.6e-34; // Planck constant\n    float k = 1.4e-23; // Boltzmann constant\n    float c = 3e8;// Speed of light\n\n    float w = w_nm / 1e9;\n\n    // Planck's law https://en.wikipedia.org/wiki/Planck%27s_law\n    \n    float w5 = w*w*w*w*w;    \n    float o = 2.*h*(c*c) / (w5 * (exp(h*c/(w*k*t)) - 1.0));\n\n    return o;    \n}", "buffer_b_code": "#define SPP 2\n\nfloat ior;\n\nstruct Hit\n{\n    vec3 ro;//ray origin\n    float td;//travelled distance\n    vec3 rh;//ray hit position\n    vec3 rd;//ray direction\n    vec3 no;//normal at the hit position\n    float id;//hit object id\n    //other material stuff\n};\n\nstruct Mat\n{\n    vec3 col; //color\n    vec3 emi; //emission\n    float rgh; //roughness\n};\n\nMat getMaterial(float id)\n{\n    Mat outmat;\n    outmat.col = vec3(1.0);\n    outmat.emi = vec3(0.0);\n    outmat.rgh = 0.3;\n    return outmat;\n}\n\nvec3 opU( vec3 d, float iResult, float mat ) {\n\treturn (iResult < d.y) ? vec3(d.x, iResult, mat) : d;\n}\n\nconst float density = 0.003;\n\nfloat iVolume( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal )\n{\n    float d = -log(rand())/density;\n    \n    if (d < distBound.x || d > distBound.y) \n    {\n        return MAX_DIST;\n    } \n    else \n    {\n    \treturn d;\n    }\n}\n\nHit worldhit(in vec3 ro, in vec3 rd, in vec2 dist) {\n    vec3 normal;\n    vec3 tmp0, tmp1, d = vec3(dist, 0.);\n    \n    \n    \n    d = opU(d, iPlane      (ro,                  rd, d.xy, normal, vec3(0,1,0), 0.), 1.);\n    \n    d = opU(d, iBox        (ro-vec3( 1,.252, -1), rd, d.xy, normal, vec3(.25)), 2.);\n    d = opU(d, iSphere     (ro-vec3( 0,.252, 0), rd, d.xy, normal, .25), 3.);\n    d = opU(d, iSphere     (ro-vec3( 0.6,.252, 0.2), rd, d.xy, normal, .25), 3.);\n    d = opU(d, iSphere     (ro-vec3( -0.5,.252, 0.1), rd, d.xy, normal, .25), 3.);\n    d = opU(d, iVolume     (ro, rd, d.xy, normal), 4.0);\n\n    Hit res;\n    res.ro = ro;\n    res.rh = ro + d.y*rd;\n    res.rd = rd;\n    res.no = normal;\n    res.id = d.z;\n    res.td = d.y;\n    return res;\n}\n\nvoid processHit(Hit res, inout vec3 ro, inout vec3 rd, inout float inside, inout vec3 col, inout vec3 att)\n{\n    Mat m = getMaterial(res.id);\n    \n    col += att*m.emi;\n    att *= m.col;\n    vec3 normal = res.no;\n    if(res.id < 4.0)\n    {\n        if(res.id == 3.0)\n        {\n            ro = res.rh ;\n             \n            vec3 matn = normalize(nrand3(0.005, normal*inside));\n            vec3 newrd = refract(rd, matn, pow(1.0 + 1.2*ior, -inside));\n            if(length(newrd) > 0.5) //not total internal reflection\n            {\n                inside = -inside;\n                rd = newrd;\n            }\n            else\n            {\n                rd =reflect(rd, matn); \n            } \n        }\n        else\n        {\n            //surface scatter\n            rd = reflect(res.rd, normalize(nrand3(m.rgh, normal))); \n            ro = res.rh + inside*res.no*5e-3;\n        }\n      \n    } \n    else\n    {\n        //volume scatter\n        rd = udir(rand2());\n        ro = res.rh;\n    }\n}\n\n\n#define LASER_PATH 7\nint cpath;\nvec3 path[LASER_PATH+1];\n\nfloat getClosestLinePoint(vec3 ro, vec3 rd, vec3 x)\n{\n    return dot(rd, x - ro);\n}\n\nfloat rand(float a, float b)\n{\n    return mix(a, b, rand());\n}\n\n//Importance sample a point on a segment so that the probability of sampling a point on the segment r1 r2\n//is inversely proportional to the square of the distance to point x\nvec3 importanceSampleSegmentPoint(vec3 r1, vec3 r2, vec3 x)\n{\n    vec3 x0 = r1 - x;\n    vec3 rd = normalize(r2 - r1);\n    float l = length(r2 - r1);\n    float a = dot(rd, x0);\n    float x02 = dot(x0, x0);\n    float sq = sqrt(x02 - a*a); \n    float t = sq*tan(rand(atan(a/sq),atan((l + a)/sq))) - a;\n    return r1 + rd*t; //importance sampled point\n}\n\n//get closest point pair for 2 segments\nvoid getClosestPointPair(vec3 r00, vec3 r01, vec3 r10, vec3 r11, out vec3 P1, out vec3 P2)\n{\n  vec3 delta1 = r01 - r00;\n  vec3 delta2 = r11 - r10;\n  vec3 rd1 = normalize(delta1);\n  vec3 rd2 = normalize(delta2);\n  float l1 = length(delta1);\n  float l2 = length(delta2);\n  vec3 delta3 = r00 - r10;\n  float d1d2 = dot(rd1, rd2);\n  float d1de = dot(rd1, delta3);\n  float d2de = dot(rd2, delta3);\n  float deno = 1.0/(1.0 - d1d2*d1d2);\n  float t1 = (d1d2*d2de - d1de)*deno;\n  float t2 = (d2de - d1d2*d1de)*deno;\n  \n  if(t1 < 0.0 || t1 > l1)\n  {\n      t1 = clamp(t1, 0.0, l1);\n      P1 = r00 + t1*rd1;\n      t2 = clamp(getClosestLinePoint(r10, rd2, P1), 0.0, l2);\n      P2 = r10 + t2*rd2;\n      return;\n  }\n  \n  if(t2 < 0.0 || t2 > l2)\n  {\n      t2 = clamp(t2, 0.0, l2);\n      P2 = r10 + t2*rd2;\n      t1 = clamp(getClosestLinePoint(r00, rd1, P2), 0.0, l1);\n      P1 = r00 + t1*rd1;\n      return;\n  }\n  \n   P1 = r00 + t1*rd1;\n   P2 = r10 + t2*rd2;\n}\n\n//choose a laser path segment p0 p1 with probability proportional to the path segment lenght and \n//inverse distance to the camera ray path segment r0 r1\nvoid importanceSamplePath(vec3 r0, vec3 r1, out vec3 p0, out vec3 p1)\n{\n    float score[LASER_PATH];\n    float totalscore = 0.0;\n    vec3 P0, P1;\n    for(int i = 0; i < cpath; i++)\n    {\n        getClosestPointPair(r0,r1,path[i],path[i+1],P0,P1);\n        float s = distance(path[i],path[i+1])/distance(P0,P1);\n        totalscore += s;\n        score[i] = totalscore;\n    }\n    \n    //target score\n    float rscore = rand()*totalscore;\n    \n    for(int i = 0; i < cpath; i++)\n    {\n        if(rscore < score[i]) //found score\n        {\n            p0 = path[i];\n            p1 = path[i+1];\n            return;\n        }\n    }\n}\n\n//next event estimation sample using the light path\nvoid connectPath(Hit res, inout vec3 col, inout vec3 att)\n{\n    //camera ray path\n    vec3 r0 = res.ro;\n    vec3 r1 = res.rh;\n    \n    //get random path\n    vec3 p0, p1;\n    importanceSamplePath(r0,r1,p0,p1);\n    \n    //find 2 closest points on camera segment and light path \n    vec3 s1, s2;\n    getClosestPointPair(p0, p1, r0, r1, s1, s2); \n    \n    vec3 pathp = importanceSampleSegmentPoint(p0, p1, s2);\n    vec3 camp = importanceSampleSegmentPoint(r0, r1, s1);\n    \n    //trace a ray from the camp to pathp\n    vec3 delta = pathp - camp;\n    float td = length(delta);\n    \n    \n    Hit con = worldhit( camp, normalize(delta), vec2(.001, td));\n    \n    if(con.td >= td) col += att/(td+1e-10);\n    //col += att*pathhit(res.ro, res.rd, res.td);\n}\n\nbool getRay(vec2 uv, out vec3 ro, out vec3 rd)\n{\n    mat3 cam = getCam(get(CamA));\n    vec2 apert_cent = -0.*uv; \n    vec2 ap = aperture();  \n    if(!(distance(ap, apert_cent) < 1.0)) return false;  \n    float apd = length(ap);  \n    vec3 daperture = ap.x*cam[0] + ap.y*cam[1]; \n    ro = get(CamP).xyz + aperture_size*daperture;\n    float focus =2.5 + 0.8*pow(apd,5.0);\n    rd = normalize(focus*(cam*vec3(FOV*uv, 1.0)) - aperture_size*daperture);\n    return true;\n}\n\nvec4 render(vec2 fragCoord)\n{\n    fragCoord += nrand2(0.5, vec2(0.));\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n   \n    vec3 ro, rd, normal;\n  \n    // get a random refractive index different per pixel\n    ior = 0.7*(rand() - 0.5);\n    //ior = -0.2;\n    //ior = (fract(gl_FragCoord.y/3.)-.5);\n    //slightly more realistic dispesion law\n    float id=1./(1.0 + ior);\n    // compute index of refraction associated color \n    vec3 scol = WavelengthToXYZLinear(350.0*(ior + 0.5) + 350.0);\n     ior = id;\n     \n    //trace laser   \n    ro = get(RayO).xyz;\n    rd = normalize(get(RayD).xyz + 0.01*udir(rand2()));\n    \n    float inside = 1.0;\n    \n    vec3 col = vec3(0.0);\n    vec3 att = scol;\n    \n    \n    for(cpath = 0; cpath < LASER_PATH - 1; cpath++)\n    {\n        path[cpath] = ro;\n        Hit res = worldhit( ro, rd, vec2(.001, MAX_DIST));\n        if (res.id > 0.) \n        {\n            processHit(res,ro,rd,inside,col,att);\n        }\n        else \n        {\n            ro = res.rh;\n            break;\n        }\n    }\n    path[cpath+1] = ro;\n    \n    if(!getRay(uv, ro, rd)) return vec4(0,0,0,1);\n    \n    col = vec3(0.0);\n    att = scol;\n    inside = 1.0;\n    \n    for(int i = 0; i < 5; i++)\n    {\n        Hit res = worldhit( ro, rd, vec2(.001, MAX_DIST));\n        \n        connectPath(res, col, att);\n        processHit(res,ro,rd,inside,col,att);\n    }\n   \n    return vec4(col, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    rng_initialize(fragCoord, iFrame);\n\n    fragColor = vec4(0.0);\n    for(int i = 0; i < SPP; i++)\n        fragColor += clamp(render(fragCoord),-0.2e3,0.2e3);\n       \n    \n    mat3 prevcam = getCam(get(PrevCamA));\n    vec3 prevcamp = get(PrevCamP).xyz;\n    \n    vec3 ro, rd;\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    getRay(uv, ro, rd);\n    \n    Hit res = worldhit( ro, rd, vec2(.001, MAX_DIST));\n    \n     vec3 cv = get(CamV).xyz;\n    vec3 rep = reproject(prevcam, prevcamp, iResolution.xy, ro + rd*res.td);\n    float reject = 0.975*float(all(lessThan(rep.xy, iResolution.xy)) && all(greaterThan(rep.xy,vec2(0))));\n    reject *= smoothstep(5.0, 0.0, length(cv));\n    fragColor += texture(iChannel0, rep.xy/iResolution.xy)*reject;\n   \n    \n}", "buffer_b_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtSSDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 111, 144, 144, 311], [313, 313, 332, 332, 388], [390, 390, 447, 447, 562]], "test": "untested"}
{"id": "sljXDR", "name": "Loki - Miss minutes", "author": "z0rg", "description": "Code is perfectible but it runs kinda find for what it is :).\nI'm really proud of this one, I spent about 8 hours to make it but it's worth it.\nHope you'll appreciate it.", "tags": ["time", "retro", "marvel", "loki", "missminutes"], "likes": 18, "viewed": 394, "published": 3, "date": "1627633928", "time_retrieved": "2024-07-30T19:08:39.473849", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec3 doBloom(vec2 uv, float blur, float threshold)\n{\n    vec3 col;\n    int cnt = 30;\n    float fcnt = float(cnt);\n    for (int i = 0;i <cnt;++i)\n    {\n        float fi = float(i);\n        float coef = (fi/fcnt);\n        float sz = 1.+pow(coef,2.)*blur;\n        float samplePerTurn = 3.;\n        float an = (fi/(fcnt/samplePerTurn))*PI;\n        vec2 p = uv - vec2(sin(an), cos(an))*(fi/fcnt)*blur*.1;\n        vec3 smple = texture(iChannel0, p).xyz;\n        if (length(smple) > threshold)\n            col += smple;\n    \t\n        \n    }\n    \n    return col/float(cnt);\n}\n\nvec3 chromaFlare(vec2 uv, vec2 ouv, float sz, float id)\n{\n    vec3 col = vec3(0.);// = texture(iChannel0, uv).xyz;\n    \n    float c = abs(length(ouv)-.3-id*sz*8.-sz*9.)-sz;\n    vec3 rgb;\n    float a = atan(ouv.y, ouv.x)*1.;\n    float cnt = 16.;\n    for (float i = 0.; i < cnt; ++i)\n    {\n           \n        rgb += vec3(1.)*\n        (sat((sin(a*400.)+sin(a*200.)+sin(a*100.))*.2+.5)*.5+.5)*\n        texture(iChannel0, vec2(.5)+((uv-vec2(.5))*(i+1.)*0.01*r2d((i-cnt/2.)*.025)*-1.*sat(length(ouv*2.)))).x;\n    }\n    col += pow((1.-sat(c*5.))*pow(rgb/cnt, vec3(1.)), vec3(1.));\n    \n    return col*.2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    float bloomIntensity = 224./640.;  \n    vec3 bloomSample = doBloom(uv, 70./360., 117./ 640.);\n    bloomSample = pow(bloomSample, vec3(0.5));\n    \n    col = col + (bloomSample*bloomIntensity);\n    \n\n    col += chromaFlare(uv, cuv, 0.01, 0.)*vec3(1.,0.,0.);\n    col += chromaFlare(uv, cuv, 0.01, -1.)*vec3(0.,1.,0.);\n    col += chromaFlare(uv, cuv, 0.01, -2.)*vec3(0.,0.,1.);\n\n    col *= sat(1.-pow(sat(length(cuv*2.)),4.)+.3);\n    float stpuv = .002;\n    vec2 uv2 = uv;\n    uv2 = vec2(ivec2(uv2/stpuv))*stpuv;\n    col += sat(rand(uv2*sin(iTime)))*.05;\n    col = pow(col, vec3(1.1));\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec2 map(vec3 p)\n{\n    vec3 op3 = p+vec3(0.,0.,-5.);\n    vec3 op2 = p;\n    vec3 op = p;\n    vec2 acc = vec2(1000.,-1.);\n    \n    float rep = .5;\n    float sz = rep*.45;\n    vec2 id = floor((p.xz+rep*.5)/rep);\n    p.x += mod(id.y, 2.)*.25;\n    p.z = min(p.z,sz*21.);\n    p.xz = mod(p.xz+rep*.5, rep)-rep*.5;\n   \n    \n    float lamp = max(max(length(p)-sz, p.y), -(length(p)-sz*.99));\n    acc = _min(acc, vec2(lamp, 0.));\n    \n    float offlamp = 0.04;\n    p.y += offlamp;\n    \n    float lampcord = max(max(length(p.xz)-0.001, p.y), -(p.y+sz-offlamp));\n    acc = _min(acc, vec2(lampcord, 1.));\n    \n    float lampbulb = length(p)-.025;\n    acc = _min(acc, vec2(lampbulb, (p.y < .005 ? 2. : 3.)));\n\n    float wallrep = .25;\n    float wallsz = wallrep*.25;\n    op.x = mod(op.x+wallrep*.5, wallrep)-wallrep*.5;\n    acc = _min(acc, vec2(_cube(op-vec3(0.,0.,5.), vec3(wallsz,30.,wallsz)),5.));\n    acc = _min(acc, vec2(-op2.z+5.5, 6.));\n    \n    op3.yz *= r2d(-.25);\n    float tv = sdRoundBox(op3-vec3(0.,.5,0.), vec3(.5,.4,.25), .1);\n    tv = max(tv, - sdRoundBox(op3-vec3(0.,.5,-0.65), vec3(.4,.3,.25), .1));\n    acc = _min(acc, vec2(tv, 7.));\n    \n    return acc;\n}\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.01,0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\nvec3 trace(vec3 ro ,vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n            return vec3(res.x, distance(p, ro), res.y);\n        p += rd * res.x*mix(.25,1.,pow(sat(distance(p,ro)/15.),15.)); \n    }\n    return vec3(-1.);\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(0.+sin(iTime*.25),1.,.5);\n    vec3 ta = vec3(0.,-0.,5.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(uv, rd);\n    vec3 res = trace(ro, rd, 256);\n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = n *.5+.5;\n        float refl = 1.;\n        if (res.z == 2.)\n            col = vec3(1.000,0.710,0.302)*2.;\n        else if (res.z == 3.)\n            col = vec3(0.302,0.157,0.122)*.5;\n        else if (p.y < -.001)\n        {\n             refl = .1;\n             col = mix(vec3(0.302,0.157,0.122)*.5*sat(-dot(rd, n)), vec3(1.000,0.710,0.302),sat(dot(vec3(0.,1.,0.), n)));\n        }\n        else if (res.z == 5.)\n        {\n            vec3 h = normalize(rd+vec3(-.5, 1.,-1.));\n            col = sat(p.y)*vec3(0.302,0.157,0.122)*.35+vec3(1.000,0.710,0.302)*(1.-pow(sat(dot(n, h)), .1))*.25;\n        }\n        else if (res.z == 7.)\n        {\n            col = pow(sat(-p.y+1.),4.)*vec3(0.302,0.255,0.157)*.75+vec3(0.718,0.463,0.220)*(1.-pow(sat(dot(n, rd)), .5))*.25;\n            refl = .25;\n\n            if (p.y > .24 && p.y < .9 && p.x > -.4 && p.x < .4)\n            {\n                vec2 tuv = p.xy*vec2(1.,-2.)*.8-vec2(-0.5,-1.5);\n                float stppx = 0.005;\n                tuv = vec2(ivec2(tuv/stppx))*stppx;\n                float offchroma = 0.005;\n                col.r = texture(iChannel1, tuv).x;\n                col.g = texture(iChannel1, tuv+vec2(offchroma,0.)).y;\n                col.b = texture(iChannel1, tuv+vec2(offchroma,0.)*2.).z;\n                refl = .1;\n                float flicker = sat(sin(iTime*5.)*sin(iTime*3.)*10.)*sat(sin(iTime)*10.);\n                vec3 dark = mix(vec3(.1), vec3(1.000,0.494,0.161)*2.5, (1.-pow(sat(length(col)),.05)));\n                col = mix(col, dark, flicker);\n            }\n            \n        }\n        else\n         col = vec3(0.302,0.157,0.122)*.25;\n        col += col*texture(iChannel0, reflect(rd, n)).xyz*refl;\n    }\n\n    return col;\n}\nvec3 cheapAA(vec2 uv)\n{\n    vec3 col = rdr(uv);\n    vec2 off = vec2(1., -1.)/(iResolution.x*2.);\n    // Not so cheap antialiasing\n    {\n        //col = vec3(1.,0.,0.);\n        vec3 acc = col;\n        acc += rdr(uv+off.xx);\n        acc += rdr(uv+off.xy);\n        acc += rdr(uv+off.yy);\n        acc += rdr(uv+off.yx);\n        col = acc/5.;\n        \n    }\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\n    vec3 col = cheapAA(uv);\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0.,1.)\n#define PI 3.14159265\n#define TAU (2.*PI)\nmat2 r2d(float a) { float c= cos(a), s = sin(a); return mat2(c, -s, s, c); }\n// Stolen on stackoverflow somewhere\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nvec3 getCam(vec2 uv, vec3 rd)\n{\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+r*uv.x+u*uv.y);\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(max(l.x,l.y), l.z);\n}\n\n// Thanks IQ :)\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\nfloat line(vec3 p, vec2 s, float curve)\n{\n    p.yz *= r2d(p.y*curve);\n    vec3 p2 = p;\n    p2.y = abs(p2.y)-s.y;\n  return min(max(length(p.xz)-s.x, abs(p.y)-s.y), length(p2)-s.x);\n//  return min(length(rep.xz)-s,length(rep-vec2(0.,s.y))-s.x);\n}\n\n// Thanks IQ\nfloat smin( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\nfloat _sqr(vec2 p, vec2 s)\n{\n  vec2 l = abs(p)-s;\n  return max(l.x,l.y);\n}\n\n\nfloat line(vec2 p, vec2 s)\n{\n  vec2 rep = p;\n  rep.y= abs(p.y);\n  return min(_sqr(p, s),length(rep-vec2(0.,s.y))-s.x);\n}", "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat shoe(vec3 p)\n{\n    float acc = max(length(p-vec3(0.,0.,-.3))-.15, p.y);\n    float sock = max(max(length(p.xz)-.1-.01*sin(p.y*40.-3.), p.y), -(p.y+.2));\n    acc = min(acc, sock);\n    acc = min(acc, max(max(length(p.xz*vec2(1.,.5)-vec2(0.,-.1))-.15, p.y), -(p.y+.025)));\n    return acc;\n}\nvec2 leg(vec3 p)\n{\n    vec2 acc = vec2(1000., -1.);\n    float leg = max(length(p.xz)-.03, -p.y);\n    leg = max(leg, (p.y-2.));\n    acc = _min(acc, vec2(leg, 1.));\n    acc = _min(acc, vec2(shoe(p-vec3(0.,2., 0.)), 0.));\n    return acc;\n}\n\nfloat hand(vec3 p)\n{\n    float acc = 1000.;\n    vec2 sz = vec2(.025,.1);\n    vec3 pt = p-vec3(0.,.0,0.);\n    //pt.xy *= r2d(1.5);\npt.yz *= r2d(.0);\n    float thumb = line(pt, sz*vec2(1.,.5), -3.);\n    acc = min(acc, thumb);\n    vec3 p1 = p+vec3(.1,0.05,0.);\n    p1.xy *= r2d(.5);\n    float first = line(p1, sz, 3.);\n    acc = min(acc, first);\n    vec3 p2 = p+vec3(.2,0.0,0.);\n    p2.xy *= r2d(.6);\n    float snd = line(p2, sz, 1.);\n    acc = min(acc, snd);\n    vec3 p3 = p+vec3(.25,-0.05,0.);\n    p3.xy *= r2d(.9);\n    float third = line(p3, sz, 2.);\n    acc = min(acc, third);\n    \n    acc = smin(acc, length(p*vec3(1.2,1.1,2.)-vec3(-0.07,0.15,0.))-.14, 1.);\n    return acc;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(1000., -1.);\n    \n    vec3 pbody = p;\n    pbody.yz *= r2d(.1);\n    float body = max(length(pbody.xy)-1.-.1*cos(abs(pbody.z)*5.), abs(pbody.z)-.2);\n    acc = _min(acc, vec2(body, 0.));\n    \n    float legSep = .3;\n    vec3 rlegp = p-vec3(legSep,0.,0.);\n    rlegp.x += cos(rlegp.y*3.)*.05;\n    acc = _min(acc, leg(rlegp));\n    vec3 llegp = p-vec3(-legSep,0.,0.);\n        llegp.x -= cos(llegp.y*3.)*.05;\n    llegp.yz *= r2d(-pow(sat(llegp.y-1.), 5.)*.05);\n    llegp.xz *= r2d(.25);\n    acc = _min(acc, leg(llegp));\n    \n    vec3 plhand = p+vec3(1.55,-0.6,0.15);\n    plhand.xy *= r2d(.35);\n    plhand.yz *= r2d(-.7);\n   \n    acc = _min(acc, vec2(hand(plhand), 2.));\n    \n    vec3 prhand = p+vec3(-1.58,-0.6,0.2);\n    prhand.x = -prhand.x;\n    prhand.xy *= r2d(.5);\n    prhand.yz *= r2d(-.7);\n   \n    acc = _min(acc, vec2(hand(prhand), 2.));\n    \n    vec3 plarma = p+vec3(1.1,-0.5,0.);\n    plarma.xy *= r2d(-.25);\n    float larma = line(plarma, vec2(.1,.3), -0.5);\n    acc = _min(acc, vec2(larma, 0.));\n    \n    vec3 plarmb = p+vec3(1.3,-.8,0.);\n    plarmb.xy *= r2d(-1.75);\n    float larmb = line(plarmb, vec2(.07,.15), 0.);\n    acc = _min(acc, vec2(larmb, 0.));\n    \n    vec3 prarma = p+vec3(-1.1,-0.5,0.);\n    prarma.xy *= r2d(.25);\n    float rarma = line(prarma, vec2(.1,.3), -.75);\n    acc = _min(acc, vec2(rarma, 0.));\n    \n    vec3 prarmb = p+vec3(-1.3,-.8,0.);\n    prarmb.xy *= r2d(1.75);\n    prarmb.yz *= r2d(.35);\n    float rarmb = line(prarmb, vec2(.07,.15), 0.);\n    acc = _min(acc, vec2(rarmb, 0.));\n    \n    return acc;\n}\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.01,0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\nfloat accMarch;\nvec4 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n            return vec4(res.x, distance(p, ro), res.y, float(i));\n        p+= res.x*rd;\n        accMarch += (1.-sat(res.x/0.7))*(p.y-1.2 > 0. ? .7 : 1.);\n    }\n    return vec4(-1.);\n}\n\nfloat eyeShape(vec2 uv)\n{\n    float a = atan(uv.y, uv.x*1.5+.1);\n    a = clamp(a, -2., -.8);\n    float rep = 0.3;\n    float b = mod(a+rep*.5,rep)-rep*.5;\n    vec2 uv2 = vec2(sin(b), cos(b))*length(uv);\n    uv *= r2d(.1);\n    float fur = line(uv2-vec2(0.0,.35), vec2(.01,.04));\n    return min(length(uv*vec2(1.*(1.-sat(pow(sat(uv.y),1.5)*.75+.2)),.5))-.175, fur);\n}\n\nvec3 drawEyes(vec3 rgb, vec2 uv)\n{\n    vec2 euv = uv;\n    \n    float shp = 400.;\n    uv.x = abs(uv.x)-.35;\n    float eyesShape = eyeShape(uv);\n    vec3 col = mix(rgb, vec3(1.), 1.-sat(eyesShape*shp));\n    col = mix(col, vec3(0.), 1.-sat((abs(eyesShape)-.01)*shp));\n    \n    float offX = 0.3;\n    vec2 posEyes = vec2(sin(iTime*.5)*.1,0.);\n    vec2 uvl = euv-vec2(offX, 0.)-posEyes;\n    vec2 uvr = euv+vec2(offX, 0.)-posEyes;\n    float eyeSz = .1;\n    vec2 eyeScale = vec2(1.,.6); \n    vec2 offTick = vec2(0.,-.05);\n    vec2 uvl2 = uvl-offTick;\n    vec2 uvr2 = uvr-offTick;\n    float al = atan(uvl2.y,-uvl2.x);\n    float ar = atan(uvr2.y,-uvr2.x);\n    \n    float eyes = min(max(length(uvl*eyeScale)-eyeSz, -sin(clamp(-al,0.,1.)*7.)), max(length(uvr*eyeScale)-eyeSz, -sin(clamp(-ar,0.,1.)*7.)));\n    eyes = max(eyes, eyesShape);\n    col = mix(col, vec3(0.), 1.-sat(eyes*shp));\n    return col;\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.604,0.718,0.631);\n    \n    vec3 ro = vec3(2.*sin(iTime*.5),sin(iTime*.25),-7.);\n    vec3 ta = vec3(0.,0.5,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(uv, rd);\n    float shp = 400.;\n    accMarch = 0.;\n    vec4 res = trace(ro, rd, 128);\n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        vec3 rgb = vec3(0.851,0.635,0.329);// n *.5+.5;\n        if (res.z == 2.)\n            rgb = vec3(1.);\n        if (res.z == 1.)\n            rgb = vec3(0.);\n        if (res.z == 0.)\n        {\n            rgb = mix(rgb, vec3(0.), 1.-sat((abs(length(p.xy)-1.05)-.02)*shp));\n            vec2 tickuv = p.xy;\n            vec2 tickuv2 = p.xy;\n            float atick = atan(tickuv.y,tickuv.x);\n            float tickrep = TAU/12.;\n            float tickrep2 = TAU/4.;\n            float angletick2 = mod(atick + tickrep2*.5, tickrep2)-tickrep2*.5;\n            float angletick = mod(atick + tickrep*.5, tickrep)-tickrep*.5;\n            tickuv = vec2(sin(angletick), cos(angletick))*length(tickuv);\n            tickuv2 =  vec2(sin(angletick2), cos(angletick2))*length(tickuv2);\n            float ticks = line(tickuv-vec2(0.,.85), vec2(.01,.08));\n            rgb = mix(rgb, vec3(0.), 1.-sat(ticks*shp));\n            float ticks2 = line(tickuv2-vec2(0.,.8), vec2(.04,.12));\n            rgb = mix(rgb, vec3(0.), 1.-sat(ticks2*shp));\n            rgb = drawEyes(rgb, p.xy-vec2(0.,-.1));\n            rgb = mix(rgb, vec3(0.), 1.-sat((length(p.xy)-.07)*shp));\n            float mouth = line((p.xy-vec2(0.,0.4-.05*cos(p.x*5.)))*r2d(PI*.5), vec2(.02,.15));\n            rgb = mix(rgb, vec3(0.), 1.-sat(mouth*shp));\n        }\n\n        col = rgb;\n        if (p.y > 1.2)\n        {\n            col = mix(col, vec3(0.), 1.-pow(sat(-dot(n, rd)+.5),20.));\n        }\n    }\n    col = mix(col, vec3(0.), pow(sat(accMarch*.09),100.));\n    //col += pow(accMarch, 1.)*vec3(1.)*.1;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\n    vec3 col = rdr(uv);\n    col *= (1.-sat(length(uv)-.3))+.1;\n    col = pow(col*1., vec3(2.5));\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sljXDR.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 449, 449, 964], [966, 966, 1023, 1023, 1566], [1568, 1568, 1625, 1625, 2405]], "test": "untested"}
{"id": "st2XD1", "name": "3D Volume (Noise) Visualizer", "author": "mrmcsoftware", "description": "Just a simple shader to show what's in shadertoy's 3d noise volumes.  Let the shader automatically, repeatedly run through all 32 \"slices\" or drag mouse in left-right direction to manually select slice.  I wrote this to diagnose my own shader program.", "tags": ["3dnoise", "noise3d", "visualizer", "volumetexture", "3dvolume", "greynoise3d", "rgbanoise3d"], "likes": 1, "viewed": 487, "published": 3, "date": "1627633432", "time_retrieved": "2024-07-30T19:08:40.246783", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float i;\n    if (iMouse.z>0.0) { i=iMouse.x/iResolution.x; }\n    else { i=mod((iTime*.5),32.0)/32.0; }\n    vec3 col;\n    if (uv.x<.497) { col=texture(iChannel0,vec3(uv*vec2(2.02,1.0),i)).rrr; }\n    else if (uv.x>.503) { col=texture(iChannel1,vec3(uv*vec2(2.02,1.0)-vec2(1.01606,0.),i)).rgb; }\n    else { col=vec3(0.,0.,0.); }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st2XD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 534]], "test": "untested"}
{"id": "7ljXD1", "name": "Aperiodic Penrose Tiling 2", "author": "dr2", "description": "Penrose tiling with two rhombs (details in earlier version); tile structure now in precomputed texture for speedup; mouseable.", "tags": ["tile", "penrose", "aperiodic"], "likes": 25, "viewed": 388, "published": 3, "date": "1627633317", "time_retrieved": "2024-07-30T19:08:41.134409", "image_code": "// \"Aperiodic Penrose Tiling 2\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA   0  // (= 0/1) optional antialising\n\nfloat SmoothMax (float a, float b, float r);\nmat3 VToRMat (vec3 v, float a);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nvec3 HsvToRgb (vec3 c);\nfloat Fbm2 (vec2 p);\nvec4 LoadTx (vec2 uv);\n\nvec4 qv4;\nvec3 ltDir;\nfloat tCur, dstFar, rad[3], pFac[3];\nint idObj, mode;\nint nFrame;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (nFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 offSet;\n  float dMin, d, r, h;\n  dMin = dstFar;\n  q = p;\n  q.y -= 1.08;\n  offSet = Rot2D (vec2 (0.2, 0.), -0.05 * pi * tCur);\n  qv4 = LoadTx ((pFac[0] / rad[0]) * q.xy + 0.5 + offSet);\n  r = length (q.xy);\n  d = r - rad[0];\n  h = -0.02 * smoothstep (0.05, 0.3, abs (qv4.x)) * (1. - smoothstep (-0.05, -0.01, r - rad[0]));\n  d = SmoothMax (abs (q.z) - (h + 0.01), d, 0.01);\n  DMIN (1);\n  q = p;\n  q.y -= 0.05;\n  qv4 = LoadTx ((pFac[1] / rad[1]) * q.xz + 0.5);\n  r = length (q.xz);\n  d = r - rad[1];\n  h = -0.02 * smoothstep (0.03, 0.25, abs (qv4.x)) * (1. - smoothstep (-0.05, -0.01, r - rad[1]));\n  d = SmoothMax (abs (q.y - 0.5 * h) - 0.5 * h - 0.025, d, 0.01);\n  DMIN (2);\n  return 0.7 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0005 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.01 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.2 + 0.8 * sh;\n}\n\nvec3 BgCol (vec3 rd)\n{\n  rd.y = abs (rd.y);\n  return mix (vec3 (0.3, 0.35, 0.7), vec3 (0.8, 0.8, 0.8),\n     clamp (2. * (Fbm2 (4. * rd.xz / rd.y + 0.1 * tCur) - 0.1) * rd.y, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, colR, gCol, sCol, vn, ror, rdr;\n  float dstObj, dstObjR, dstFlr, nDotL, sh, dm, att;\n  bool isRefl;\n  rad[0] = 1.;\n  rad[1] = 1.3;\n  rad[2] = 6.;\n  pFac[0] = 0.3;\n  pFac[1] = 0.35;\n  pFac[2] = 0.5;\n  gCol = vec3 (0.8, 0.6, 0.1);\n  sCol = vec3 (0.8, 0.8, 0.85);\n  dstFlr = (rd.y < 0.) ? - ro.y / rd.y : dstFar;\n  dstObj = ObjRay (ro, rd);\n  dstObjR = dstFar;\n  isRefl = false;\n  if (dstFlr < min (dstObj, dstFar)) {\n    ror = ro + dstFlr * rd;\n    rdr = reflect (rd, vec3 (0., 1., 0.));\n    ror += 0.01 * rdr;\n    dstObjR = ObjRay (ror, rdr);\n    isRefl = true;\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    nDotL = max (dot (vn, ltDir), 0.);\n    nDotL *= nDotL;\n    if (idObj == 1) col = gCol;\n    else if (idObj == 2) {\n      col = sCol;\n      if (length (ro.xz) < rad[1] - 0.005 && ro.y < 0.065) {\n        qv4 = LoadTx ((pFac[1] / rad[1]) * ro.xz + 0.5);\n        col = HsvToRgb (vec3 (0.1 * (abs (qv4.w) - 20.), ((qv4.w < 0.) ? 1. : 0.6), 1.));\n      }\n    }\n    sh = ObjSShadow (ro, ltDir);\n    col = col * (0.2 + 0.1 * max (- dot (vn, ltDir), 0.) + 0.8 * sh * nDotL * nDotL) +\n       0.3 * step (0.95, sh) * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n  } else if (rd.y < 0.) {\n    ro += dstFlr * rd;\n    vn = vec3 (0., 1., 0.);\n    if (length (ro.xz) < rad[2]) {\n      qv4 = LoadTx ((pFac[2] / rad[2]) * ro.xz + 0.5);\n      col = HsvToRgb (vec3 (0.6, ((qv4.w < 0.) ? 1. : 0.4), 1.));         \n      vn = VToRMat (vec3 (qv4.yz, 0.).xzy, 0.15 * pi * sign (qv4.x) * (1. -\n         smoothstep (0., 0.15, abs (qv4.x)))) * vn;\n      sh = ObjSShadow (ro, ltDir);\n      nDotL = max (dot (vn, ltDir), 0.);\n      col = col * (0.2 + 0.1 * max (- dot (vn, ltDir), 0.) + 0.8 * sh * nDotL) +\n         0.2 * step (0.95, sh) * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n      col = mix (col, vec3 (0.3), smoothstep (-0.5, 0., length (ro.xz) - rad[2]));\n    } else col = vec3 (0.3);\n    att = smoothstep (0.93, 0.97, dot (normalize (8. * ltDir - ro), ltDir));\n    col *= att;\n  } else {\n    col = vec3 (0.);\n  }\n  if (isRefl) {\n    rd = rdr;\n    if (dstObjR < dstFar) {\n      ro = ror + dstObjR * rd;\n      vn = ObjNf (ro);\n      nDotL = max (dot (vn, ltDir), 0.);\n      nDotL *= nDotL;\n      if (idObj == 1) colR = gCol;\n      else if (idObj == 2) colR = sCol;\n      colR = colR * (0.2 + 0.8 * nDotL * nDotL) +\n         0.3 * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n    } else {\n      colR = BgCol (rd);\n    }\n    colR *= att;\n    col = mix (col, colR, 0.3);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  nFrame = iFrame;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.1 * pi;\n  el = -0.15 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  el = clamp (el, -0.4 * pi, -0.05 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0.5, -8.);\n  zmFac = 4.5;\n  dstFar = 50.;\n  mode = 0;\n  ltDir = normalize (vec3 (0.5, 1.2, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nmat3 VToRMat (vec3 v, float a)\n{\n  mat3 m;\n  vec3 w, b1, b2, bp, bm;\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  w = (1. - cs.x) * v * v + cs.x;\n  b1 = (1. - cs.x) * v.xzy * v.yxz;\n  b2 = - cs.y * v.zyx;\n  bp = b1 + b2;\n  bm = b1 - b2;\n  m[0][0] = w.x;  m[1][1] = w.y;  m[2][2] = w.z;\n  m[0][1] = bp.x;  m[1][0] = bm.x;\n  m[2][0] = bp.y;  m[0][2] = bm.y;\n  m[1][2] = bp.z;  m[2][1] = bm.z;\n  return m;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 LoadTx (vec2 uv)\n{\n  return texture (txBuf, uv);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Aperiodic Penrose Tiling 2\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Maxv3 (vec3 p);\nvec4 LoadTx (vec2 uv);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nfloat tCur;\nint nFrame;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (nFrame, 0)\n\nbool InTri (vec2 p, vec2 v0, vec2 v1, vec2 v2)\n{\n  vec3 s;\n  vec2 v10, v20, p0;\n  float d;\n  v10 = v1 - v0;\n  v20 = v2 - v0;\n  d = v20.y * v10.x - v20.x * v10.y;\n  p0 = p - v0;\n  s.xy = p0.x * vec2 (v20.y, - v10.y) - p0.y * vec2 (v20.x, - v10.x);\n  return (Maxv3 (abs (vec3 (s.xy, d - s.x - s.y) - 0.5 * d)) < 0.5 * abs (d));\n}\n\nvec4 EvalTile (vec2 uv)\n{\n  vec4 qv4;\n  vec2 vp[5], csn[5], g, gg, up, vm, v[3];\n  float gam[5], gamSum, kCur[5], d, dm, di, ic, f;\n  bool fatRom, done;\n  const float kLimit = 7.;\n  for (int k = 0; k < 5; k ++) csn[k] = sin (2. * pi * float (k) / 5. + vec2 (0.5 * pi, 0.));\n  gamSum = 0.;\n  for (int k = 0; k < 4; k ++) {\n    gam[k] = 0.1 * float (k + 1);\n    gamSum += gam[k];\n  }\n  gam[4] = - gamSum;\n  done = false;\n  ic = -1.;\n  for (int k1 = VAR_ZERO; k1 <= 3; k1 ++) {\n    for (int k2 = VAR_ZERO + 1; k2 <= 4; k2 ++) {\n      if (k2 >= k1 + 1) {\n        fatRom = (k2 - k1 == 1 || k2 - k1 == 4);\n        ++ ic;\n        gg = gam[k2] * csn[k1] - gam[k1] * csn[k2];\n        di = 1. / (csn[k1].x * csn[k2].y - csn[k2].x * csn[k1].y);\n        for (float kV1 = - kLimit + float (VAR_ZERO); kV1 <= kLimit; kV1 ++) {\n          kCur[k1] = kV1;\n          for (float kV2 = - kLimit + float (VAR_ZERO); kV2 <= kLimit; kV2 ++) {\n            kCur[k2] = kV2;\n            g = (gg + kV1 * csn[k2] - kV2 * csn[k1]).yx * vec2 (1., -1.);\n            for (int k = 0; k < 5; k ++) {\n              if (k != k1 && k != k2) {\n                d = dot (csn[k], g) * di + gam[k];\n                d += step (0., d);\n                kCur[k] = floor (abs (d)) * sign (d);\n              }\n            }\n            vp[0] = vec2 (0.);\n            for (int k = 0; k < 5; k ++) vp[0] += kCur[k] * csn[k];\n            vp[2] = vp[0] + csn[k1] + csn[k2];\n            vp[1] = vp[2] - csn[k2];\n            vp[3] = vp[2] - csn[k1];\n            done = (InTri (uv, vp[0], vp[1], vp[2]) || InTri (uv, vp[0], vp[3], vp[2]));\n            if (done) break;\n          }\n          if (done) break;\n        }\n      }\n      if (done) break;\n    }\n    if (done) break;\n  }\n  if (done) {\n    dm = 99.;\n    vp[4] = vp[0];\n    for (int k = 0; k < 4; k ++) {\n      up = uv - vp[k];\n      v[0] = normalize (vp[k + 1] - vp[k]);\n      if (k == 0) v[1] = v[0];\n      else if (k == 1) v[2] = v[0];\n      f = dot (v[0], up);\n      d = dot (up, up) - f * f;\n      if (d < dm) {\n        dm = d;\n        vm = v[0];\n      }\n    }\n    qv4.x = sqrt (dm) * sign (v[1].x * v[2].y - v[2].x * v[1].y);\n    qv4.yz = vm;\n    qv4.w = (ic + 20.) * (fatRom ? -1. : 1.);\n  } else qv4 = vec4 (0., 0., 0., -1.);\n  return qv4;\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec2 pxIv;\n  int nfSafe;\n  tCur = iTime;\n  nFrame = iFrame;\n  pxIv = floor (fragCoord);\n  if (max (pxIv.x, pxIv.y) >= txSize.x) discard;\n  nfSafe = 2;\n  if (nFrame == nfSafe || txSize != LoadTx (vec2 (0.)).yz)\n     stDat = EvalTile (30. * (fragCoord / txSize  - 0.5));\n  else if (nFrame > nfSafe) stDat = LoadTx (fragCoord / txSize);\n  else stDat = vec4 (0.);\n  if (pxIv == vec2 (0.)) stDat.yz = txSize;\n  Savev4 (pxIv, stDat, fragColor, fragCoord);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nvec4 LoadTx (vec2 uv)\n{\n  return texture (txBuf, uv);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ljXD1.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[605, 605, 627, 627, 1342], [1344, 1344, 1377, 1377, 1625], [1627, 1627, 1648, 1648, 1903], [1905, 1905, 1942, 1942, 2171], [2173, 2173, 2195, 2195, 2358], [2360, 2360, 2395, 2395, 4951], [4953, 4953, 5009, 5009, 6042], [6044, 6044, 6089, 6089, 6181], [6183, 6183, 6228, 6228, 6266], [6268, 6268, 6300, 6300, 6678], [6680, 6680, 6710, 6710, 6823], [6825, 6825, 6861, 6861, 7067], [7069, 7069, 7093, 7093, 7210], [7244, 7244, 7268, 7268, 7398], [7400, 7400, 7425, 7425, 7611], [7613, 7613, 7634, 7634, 7789], [7856, 7856, 7879, 7879, 7911]], "test": "untested"}
{"id": "st2SD1", "name": "effin around", "author": "femalefaust", "description": "default tweaked like a black box experiment.", "tags": ["simple"], "likes": 1, "viewed": 207, "published": 3, "date": "1627626493", "time_retrieved": "2024-07-30T19:08:41.985134", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = iResolution.xy/fragCoord;\n\n    // Time varying pixel color\n    vec3 col = tan(tan(tan(tan(tan(tan(tan(tan(tan(uv.xyx))))))))) + tan(tan(tan(tan(tan(tan(tan(tan(tan(iTime+uv.xyx+vec3(2,9,3))))))))));\n  \n    // Output to screen\n    fragColor = vec4(col,.1);\n    }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st2SD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 383]], "test": "untested"}
{"id": "stjSWh", "name": "Magic Doormat Dispenser", "author": "Tater", "description": "This is another shader for Sableraph's weekly creative coding challenge, the theme was \"textile\". \n\nAt first I felt a bit disappointed a different prompt wasn't picked but in the end I really like how this one turned out. ", "tags": ["3d", "raymarching"], "likes": 18, "viewed": 418, "published": 3, "date": "1627622177", "time_retrieved": "2024-07-30T19:08:42.829876", "image_code": "#define STEPS 128.0\n#define MDIST 40.0\n#define pi 3.1415926535\n#define pmod(p,x) (mod(p,x)-0.5*(x))\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a));\n\n//box sdf\nfloat box(vec3 p, vec3 s){\n    vec3 d = abs(p)-s;\n    return max(d.x,max(d.y,d.z));\n}\n//iq's color palette function\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n//An interpolated sinwave with variable sample rate to give the carpets a low poly look\nfloat psin(float x, float b){\n    return sin(floor(b*x)/b)+(sin(floor(b*x+1.0)/b)-sin(floor(b*x)/b))*mod(b*x,1.0);\n}\n\nvec3 map(vec3 p){\n    vec3 a = vec3(0);\n    \n    float t = mod(iTime,9999.0);\n    \n    //scroll the y axis up all the time \n    p.y-=t-0.25;\n    \n    //id of y axis domain repition\n    float id = floor(p.y/1.0)+0.5;\n    \n    //x value to offset carpets so they fly left and right\n    float xoff =max(0.0,(id+t)*2.0);\n    xoff = xoff*xoff*sign(sin(id*pi));;\n    \n    //domain repition in the y axis\n    p.y = pmod(p.y,1.0);\n\n    //Add some low poly waves to the carpets\n    float sb = .7;\n    float wscl = 0.06;\n    p.y+=psin(p.x*4.0+id,sb)*wscl;\n    p.y-=psin(p.z*4.0+id,sb)*wscl;\n\n    //calculate box sdf\n    a.x = box(p-vec3(xoff,0,0),vec3(2,0.025,2));\n    \n    //pass some info to coloring code\n    a.y = id;\n    a.z = xoff;\n    \n    return a;\n}\n\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.01,0);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\n//mirror function\nvoid mo(inout vec2 p){\n  if(p.y>p.x) p = p.yx;\n}\nvec2 kifs(vec2 uv,float id){\n    //some kifs and abs() duplication code\n    for(float i = 0.0; i< 9.0; i++){\n        uv = abs(uv)-0.7*i*(vec2((sin(id*0.15)),0.2*(cos(id*0.22))));\n        //Adjusting this rotation value gives some cool alternate designs\n        uv*=rot(pi/(2.0));\n        mo(uv);\n    }\n    uv = abs(uv)-0.5;\n    uv = abs(uv)-0.5;\n    uv = abs(uv)-0.5;\n    return uv;\n}\nfloat getRug(vec2 uv, float id){\n    vec3 col = vec3(0);\n    float a =0.0;\n    \n    //sometimes the result of the kifs will not give any pattern on the carpet\n    //to fix this I run the kifs 8 times with different initial conditions and xor\n    //all the patterns so you can't really tell when there are gaps.\n    //someone who is better at kifs could probably just fix the problem\n    \n    for(float i = 0.0; i <8.0; i++){\n        a = mix(a,1.0-a,smoothstep(0.21,0.19,box(vec3(kifs(uv,id+i*pi),0),vec3(0.2)))); \n    }\n    return float(a);\n}\n//radial mod (stole a flopine shader)\nvec2 moda (vec2 p, float per)\n{\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a-per/2.,per)-per/2.;\n    return vec2 (cos(a),sin(a))*l;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    float t = iTime;\n    float aa = 1.0/iResolution.y;\n    vec3 ro = vec3(0,3,-7);\n    vec3 rd = normalize(vec3(uv,1.0));\n    rd.yz*=rot(-0.4 );\n    vec3 p = ro;\n    vec3 d;\n    bool hit = false;\n    float dO;\n    //raymarch loop\n    for(float i = 0.0; i<STEPS; i++){\n        d = map(p);\n        dO+=min(0.75,d.x*0.8);\n        p = ro+rd*dO;\n        \n        if(abs(d.x)<0.001){\n            hit = true;\n            break;\n        }\n        if(dO>MDIST){break;}\n    }\n    \n    //if ray marcher hits something color it\n    if(hit){ \n        vec3 palc = 0.9*pal(d.y/3.0, vec3(0.3),vec3(0.5),vec3(1.7),vec3(0,0.33,0.66) );\n        float bright = mix(1.,1.,sin(d.y*pi)*0.5+0.5);\n        vec3 al = mix(palc,vec3(bright),getRug(vec2(p.x-d.z,p.z),d.y));\n\n        vec3 n = norm(p);\n        vec3 ld = normalize(vec3(0.2,1,1));\n        vec3 h = normalize(ld-rd);\n        float spec = pow(max(dot(n,h),0.0),20.0);\n        float fres = pow(1. - max(dot(n, -rd),0.), 5.);\n        float diff = max(dot(n, ld),0.);\n        \n\n        //some hacky soft shadows\n        float shadow = 1.0;\n        float md = 1.0;\n        vec3 sp = p + n * 0.5;\n        for(int i=0; i<10; ++i) {\n        \n          float d=map(sp).x;\n          \n          if(d>3.0) break; \n          sp+=min(d,0.4)*ld;\n          md = min(md, d);\n          if(md<0.5) shadow = md+0.5;\n          \n        }\n        //I still have no idea what I am doing with these lighting mixes\n        shadow = pow(shadow,1.75);\n        col = al;\n        col+=spec*0.3*shadow*vec3(1.000,0.831,0.439);\n        col+=fres*0.175*shadow*vec3(1.000,0.957,0.824);\n        col*=clamp(diff*vec3(1.000,0.957,0.824),0.2,1.0);\n        col*=clamp(shadow,0.0,1.0);\n    }\n    //if ray marcher didn't hit then render the background\n    else{\n        vec2 uvo = uv;\n        uv.y-=0.5;\n        uv.x-=0.7;\n\n        //orange/purple gradient\n        col = mix(vec3(0.976,0.502,0.243),vec3(0.420,0.259,1.000),min(length(uv)-0.4,1.2));\n\n        //big sun circle\n        float sun =smoothstep(length(uv)-aa,length(uv)+aa,0.3);\n        uv*=rot((floor(length(uv)/0.1)+0.5)-t*0.025);\n\n        //lots of little tiny rings\n        uv = moda(uv,0.3);\n        uv.x = pmod(uv.x,0.1);\n        float rs = 0.035/2.0;\n        sun += (smoothstep(length(uv)-aa,length(uv)+aa,rs)\n        -smoothstep(length(uv)-aa,length(uv)+aa,rs*0.5));\n        col+=min(sun,1.0);\n        \n        //Some sand dune thingys\n        uv = uvo;\n        uv.y+=sin(uv.x*12.0-t*0.4+5.0)*0.015;\n        col=mix(col,vec3(1.000,0.655,0.275),smoothstep(uv.y-aa,uv.y+aa,-0.25));\n        uv = uvo;\n        uv.y+=sin(uv.x*12.0-t+2.5)*0.015;\n        col=mix(col,vec3(0.957,0.584,0.357),smoothstep(uv.y-aa,uv.y+aa,-0.325));\n        uv = uvo;\n        uv.y+=sin(uv.x*12.0-t*1.8)*0.015;\n        col=mix(col,vec3(0.894,0.871,0.353),smoothstep(uv.y-aa,uv.y+aa,-0.4));\n        \n    }\n    //Gamma\n    col =sqrt(col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stjSWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[152, 162, 188, 188, 247], [248, 278, 345, 345, 388], [389, 477, 506, 506, 593], [595, 595, 612, 612, 1343], [1345, 1345, 1363, 1363, 1490], [1491, 1509, 1531, 1531, 1557], [1558, 1558, 1586, 1629, 1942], [1943, 1943, 1975, 1975, 2485], [2486, 2524, 2555, 2555, 2680], [2681, 2681, 2738, 2738, 5729]], "test": "untested"}
{"id": "st2SW1", "name": "wave line", "author": "HanShaoqiu", "description": "2d line", "tags": ["wave"], "likes": 2, "viewed": 388, "published": 3, "date": "1627612419", "time_retrieved": "2024-07-30T19:08:43.646692", "image_code": "#define PI 3.1415926\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tvec3 final_color = vec3(1.0);\n\tvec3 bg_color = vec3(0.0);\n\tvec3 wave_color = vec3(0.0);\n\t\n\tfloat wave_width = 1.0;\n\tuv  = -1.0 + 2.0 * uv;\n\tuv.y += 0.1;\n\t\n\tuv.y += (0.2 * sin(uv.x + iTime));\n\twave_width = abs(1.0 / (50.0 * uv.y));\n\twave_color += vec3(wave_width, wave_width , wave_width * 1.5*sin(iTime));\n\t\n\tfinal_color = bg_color + wave_color;\n\t\n\t\n\tfragColor = vec4(final_color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st2SW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 78, 78, 512]], "test": "untested"}
{"id": "stjXDh", "name": "single fractal", "author": "zeo", "description": "single fractal letter", "tags": ["fractal"], "likes": 4, "viewed": 231, "published": 3, "date": "1627600020", "time_retrieved": "2024-07-30T19:08:44.742762", "image_code": "/*\n\n\tdraw letter shapes after subdividing uv space randomly\n\n*/\n\n#define PI 3.1415926535\n\nfloat random2d(vec2 n) { \n    return fract(sin(dot(n, vec2(129.9898, 4.1414))) * 2398.5453);\n}\n\nvec2 getCellIJ(vec2 uv, float gridDims){\n    return floor(uv * gridDims)/ gridDims;\n}\n\nvec2 rotate2D(vec2 position, float theta)\n{\n    mat2 m = mat2( cos(theta), -sin(theta), sin(theta), cos(theta) );\n    return m * position;\n}\n\n//from https://github.com/keijiro/ShaderSketches/blob/master/Text.glsl\nfloat letter(vec2 coord, float size)\n{\n    vec2 gp = floor(coord / size * 7.); // global\n    vec2 rp = floor(fract(coord / size) * 7.); // repeated\n    vec2 odd = fract(rp * 0.5) * 2.;\n    float rnd = random2d(gp);\n    float c = max(odd.x, odd.y) * step(0.5, rnd); // random lines\n    c += min(odd.x, odd.y); // fill corner and center points\n    c *= rp.x * (6. - rp.x); // cropping\n    c *= rp.y * (6. - rp.y);\n    return clamp(c, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy / iResolution.xy;    \n    //correct aspect ratio\n    // uv.x *= iResolution.x/iResolution.y;\n\n    float t = iTime;\n    float scrollSpeed = 0.3;\n    float dims = 0.5;\n    int maxSubdivisions = 0;\n    \n    // uv = rotate2D(uv,PI/12.0);\n    uv.y -= floor(iTime * scrollSpeed * 4.);\n    \n    float cellRand;\n    vec2 ij;\n    \n   \tfor(int i = 0; i <= maxSubdivisions; i++) { \n        ij = getCellIJ(uv, dims);\n        cellRand = random2d(ij);\n        dims *= 2.0;\n        //decide whether to subdivide cells again\n        float cellRand2 = random2d(ij + 454.4543);\n        if (cellRand2 > 0.3){\n        \tbreak; \n        }\n    }\n   \n    //draw letters    \n    float b = letter(uv, 1.0 / (dims));\n\t\n    //fade in\n    /* float scrollPos = iTime*scrollSpeed + 0.5;\n    float showPos = -ij.y + cellRand;\n    float fade = smoothstep(showPos ,showPos + 0.05, scrollPos );\n    b *= fade; */\n    \n    //hide some\n    //if (cellRand < 0.1) b = 0.0;\n    \n    fragColor = vec4(vec3(1.-b), 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stjXDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 114, 114, 184], [186, 186, 226, 226, 271], [273, 273, 316, 316, 413], [415, 486, 524, 524, 928], [930, 930, 987, 987, 2000]], "test": "untested"}
{"id": "7tjSDh", "name": "Bidirectional Laser Tracer", "author": "michael0884", "description": "Camera controls are WASD and QR for roll. R reset accumulation. N to shoot a ray.\nStoring a light path and then using it for next event estimation in path tracing, the NEE is importance sampled so that the probability of hitting a light path is maximized.", "tags": ["camera", "pathtracer", "laser", "bidirectional"], "likes": 203, "viewed": 24183, "published": 3, "date": "1627599822", "time_retrieved": "2024-07-30T19:08:45.694218", "image_code": "// Fork of \"Volumetric laser tracer\" by michael0884. https://shadertoy.com/view/NtXSR4\n// 2021-07-22 19:27:50\n\nvec3 ColorGrade( vec3 vColor )\n{\n    vec3 vHue = vec3(1.0, .7, .2);\n    \n    vec3 vGamma = 1.0 + vHue * 0.6;\n    vec3 vGain = vec3(.9) + vHue * vHue * 8.0;\n    \n    vColor *= 1.5;\n    \n    float fMaxLum = 100.0;\n    vColor /= fMaxLum;\n    vColor = pow( vColor, vGamma );\n    vColor *= vGain;\n    vColor *= fMaxLum;\n    return pow(tanh(vColor), vec3(0.57));\n}\n\nvec3 tone(vec3 c)\n{\n    c = XYZtosRGB(c);\n    return ColorGrade(c);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 acc = texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor = vec4(tone(0.03*acc.xyz/acc.w), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//controller\n\n//Keyboard constants\nconst int keyLe = 37, keyUp = 38, keyRi = 39, keyDn = 40, keyA = 65, keyB = 66, keyC = 67, keyD = 68, keyE = 69, keyF = 70, keyG = 71, keyH = 72, keyI = 73, keyJ = 74, keyK = 75, keyL = 76, keyM = 77, keyN = 78, keyO = 79, keyP = 80, keyQ = 81, keyR = 82, keyS = 83, keyT = 84, keyU = 85, keyV = 86, keyW = 87, keyX = 88, keyY = 89, keyZ = 90;\n\nbool pressed(int k) \n{\n    return texelFetch(iChannel3, ivec2(k, 0), 0).x > 0.5;\n}\n\nconst float force =25.0;\nconst float mouse_sens = 100.0;\nconst float roll_speed = 0.5;\n\nvoid mainImage( out vec4 o, in vec2 p )\n{\n    p = floor(p);\n    if(p.x > NAddr && p.y > 0.) discard;\n    \n    //get camera data\n    vec3 cp = get(CamP).xyz;\n    vec4 ca = get(CamA);\n    \n    vec3 ro = get(RayO).xyz;\n    vec3 rd = get(RayD).xyz;\n    \n    float mode = 0.0;\n    if(pressed(keyR)) mode = 1.0;\n    \n    //initialization\n    if(iFrame < 10)\n    {\n        cp = vec3(-1.,1.5,1.);\n        ca = aa2q( normalize(vec3(0,1,0)), -PI*1.7/4.0);\n        mat3 cam = getCam(ca);\n        ca = qq2q(ca, aa2q(cam*vec3(1,0,0), -PI*0.4/4.0)); \n        ro = vec3( -2.2,.252, 0.05);\n        rd = normalize(vec3(0.3,0.,-0.002));\n    }\n    vec4 oldca = ca;\n    if(p.x == PrevCamP) o = vec4(cp, 0);\n    if(p.x == PrevCamA) o = ca;\n    \n    mat3 cam = getCam(ca);\n    \n    //get velocities\n    vec3 cv = get(CamV).xyz;\n    vec4 cav = get(CamAV);\n    \n    float dt = 1./60.0;\n    //update position\n    if(pressed(keyW)) cv += force*dt*cam*vec3(0,0,1);\n    if(pressed(keyS)) cv += force*dt*cam*vec3(0,0,-1);\n    if(pressed(keyA)) cv += force*dt*cam*vec3(-1,0,0);\n    if(pressed(keyD)) cv += force*dt*cam*vec3(1,0,0);\n    \n    cp += dt*cv;\n    cv += -cv*tanh(10.0*dt);\n    \n    //update camera orientation\n    vec2 dmouse = dt*mouse_sens*(iMouse.xy - get(PrevMouse).xy)/iResolution.x;\n    \n    if(length(dmouse) < 0.1)\n    {\n        //rotate around y ax\n        ca = qq2q(ca, aa2q(cam*vec3(0,1,0), -dmouse.x)); \n        //rotate around x ax\n        ca = qq2q(ca, aa2q(cam*vec3(1,0,0), dmouse.y));\n    }\n    \n    //roll camera\n    if(pressed(keyQ)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), -roll_speed*dt)); \n    if(pressed(keyE)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), roll_speed*dt)); \n    \n    if(distance(oldca, ca) > 0.001 || length(cv) > 0.01) mode = 1.0;\n    \n    if(pressed(keyN)) \n    {\n        rd = cam*vec3(0,0,1);\n        ro = cp + 0.05*cam*vec3(1,1,0);\n    }\n    \n    if(p.x == CamP) o = vec4(cp, mode);\n    if(p.x == CamA) o = ca;\n    if(p.x == CamV) o = vec4(cv, 0.0);\n    if(p.x == CamAV) o = vec4(0.0);\n    if(p.x == PrevMouse) o = vec4(iMouse.xy, 0, 0);\n    if(p.x == RayO) o = vec4(ro, 0);\n    if(p.x == RayD) o = vec4(rd, 0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n#define FOV 1.1\n#define CAM_ANGLE 0.001\n#define MAX_STEPS 90\n#define MIN_DIST 1e-5\n#define MAX_DIST 500.0\n\n//(reused some of @ollj's code, made it more readible)\n\nvec3 light = normalize(vec3(0,1,0));\nconst float light_bright =1.0;\nconst float light_ang = 0.1;\n\n//specific controller buffer Addresses\nconst float CamP = 0.,     //camera position \n            CamA = 1.,     //camera rotation quaternion    \n            CamV = 2.,     //camera velocity\n            CamAV = 3.,    //camera rotation velocity\n            PrevCamP = 4., //previous frame camera position\n            PrevCamA = 5., //previous frame camera rotation quaternion\n            PrevMouse = 6.,//previous mouse pos\n            RayO = 7.,     //previous mouse pos\n            RayD = 8.,     //previous mouse pos\n            NAddr = 9.;    //max address count\n            \n#define get(i) texelFetch(iChannel2,ivec2(i,0),0)\n\nfloat sqr(float x)\n{\n    return x*x;\n}\n\nvec3 reproject(mat3 pcam_mat, vec3 pcam_pos, vec2 iRes, vec3 p)\n{\n    float td = distance(pcam_pos, p);\n    vec3 dir = (p - pcam_pos)/td;\n    vec3 screen = dir*pcam_mat;\n    return vec3(screen.xy*iRes.y/(FOV*screen.z) + 0.5*iRes.xy, td);\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n              in vec3 planeNormal, in float planeDist) {\n    float a = dot(rd, planeNormal);\n    float d = -(dot(ro, planeNormal)+planeDist)/a;\n    if (a > 0. || d < distBound.x || d > distBound.y) {\n        return MAX_DIST;\n    } else {\n        normal = planeNormal;\n    \treturn d;\n    }\n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n               float sphereRadius ) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - sphereRadius*sphereRadius;\n    float h = b*b - c;\n    if (h < 0.) {\n        return MAX_DIST;\n    } else {\n\t    h = sqrt(h);\n        float d1 = -b-h;\n        float d2 = -b+h;\n        if (d1 >= distBound.x && d1 <= distBound.y) {\n            normal = normalize(ro + rd*d1);\n            return d1;\n        } else if (d2 >= distBound.x && d2 <= distBound.y) { \n            normal = normalize(ro + rd*d2);            \n            return d2;\n        } else {\n            return MAX_DIST;\n        }\n    }\n}\n\nfloat iBox( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal, \n            in vec3 boxSize ) {\n    vec3 m = sign(rd)/max(abs(rd), 1e-8);\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if (tN > tF || tF <= 0.) {\n        return MAX_DIST;\n    } else {\n        if (tN >= distBound.x && tN <= distBound.y) {\n        \tnormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n            return tN;\n        } else if (tF >= distBound.x && tF <= distBound.y) { \n        \tnormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n            return tF;\n        } else {\n            return MAX_DIST;\n        }\n    }\n}\n\nfloat iCylinder( in vec3 ro, in vec3 rd, \n                in vec3 pa, in vec3 pb, float ra ) // extreme a, extreme b, radius\n{\n    vec3 ba = pb-pa;\n\n    vec3  oc = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoc = dot(ba,oc);\n    \n    float k2 = baba            - bard*bard;\n    float k1 = baba*dot(oc,rd) - baoc*bard;\n    float k0 = baba*dot(oc,oc) - baoc*baoc - ra*ra*baba;\n    \n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return 1e10;\n    h = sqrt(h);\n    float t = (-k1-h)/k2;\n\n    // body\n    float y = baoc + t*bard;\n    if( y>0.0 && y<baba ) return t;\n    \n    // caps\n    t = ( ((y<0.0) ? 0.0 : baba) - baoc)/bard;\n    if( abs(k1+k2*t)<h )\n    {\n        return t;\n    }\n\n    return 1e10;\n}\n\n//ollj quaternionRotation math\n//\n//ANY rotations in 3d are non-commutative!\n//\n//matrix rotations are just bulky, memory wasting\n//EulerRotations almost certainly fail to rotate over the SHORTEST path.\n//EulerRotations almost certainly will gimbalLock and get stuck along one axis\n//QuaternionRotations are superior here.\n//-> we only use EulerRorations for simple input devices (keyboard input)\n//-> we convert to quaternions, buffered as vec4.\n\n//quaternion Identity\nvec4 qid() \n{\n    return vec4(0, 0, 0, 1);\n}\n\n//return quaternion from axis and angle\nvec4 aa2q(vec3 axis, float ang) \n{\n    vec2 g = vec2(sin(ang), cos(ang)) * 0.5;\n    return normalize(vec4(axis * g.x, g.y));\n}\n\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q) \n{\n    return vec4(q.xyz / sqrt(1.0 - q.w * q.w), acos(q.w) * 2.);\n}\n\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2) \n{\n    return vec4(q1.xyz * q2.w + q2.xyz * q1.w + cross(q1.xyz, q2.xyz), (q1.w * q2.w) - dot(q1.xyz, q2.xyz));\n}\n\n//extension to qq2q(), scaled by sensitivity [f] (==quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f) \n{\n    float d = dot(a, b), t = acos(abs(d)), o = (1. / sin(t));\n    return normalize(a * sin(t * (1.0 - f)) * o * sign(d) + b * sin(t * f) * o);\n}\n\n//doing qq2q() multiple times, you need to normalize() the quaternion, to fix rounding errors.\n//how often you do this is up to you.\n\n//normalize q (assuming length(q) is already close to 1, we can skip whe sqrt()\nvec4 qn(vec4 q) \n{\n    return q / dot(q,q);\n}\n\n//return quaternion, that is the shortest rotation, between looking to [a before], and looking to [b after] the rotation.\n//http://wiki.secondlife.com/wiki/LlRotBetween\nvec4 qBetween(vec3 a, vec3 b) \n{\n    float v = sqrt(dot(a,a) * dot(a,a));\n\n    if(v == 0.) return qid();\n    \n    v = dot(a, b) / v;\n    vec3 c = a.yzx * b.zxy - a.zxy * b.yzx / v;\n    float d = dot(c,c);\n    \n    if(d != 0.) \n    {\n        float s = (v > - 0.707107) ? 1. + v : d / (1. + sqrt(1. - d));\n        return vec4(c, s) / sqrt(d + s * s);\n    }\n    \n    if(v > 0.) return qid();\n    \n    float m = length(a.xy);\n    \n    return (m != 0.) ? vec4(a.y, - a.x, 0, 0) / m : vec4(1, 0, 0, 0);\n}\n\n//return inverse of quaternion\nvec4 qinv(vec4 q) \n{\n    return vec4(- q.xyz, q.w) / dot(q,q);\n}\n\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q, vec3 p) \n{\n    return qq2q(q, qq2q(vec4(p, .0), qinv(q))).xyz;\n}\n\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it is rotated by VECTOR p (as if it is a quaternion)\nvec3 vq2v(vec3 p, vec4 q) \n{\n    return qq2q(qinv(q), qq2q(vec4(p, 0.0), q)).xyz;\n}\n\nvec3 vq2v(vec4 a, vec3 b) \n{\n    return qv2v(a, b);\n}\n\n//in case of namespace confuction\nvec3 qv2v(vec3 a, vec4 b) \n{\n    return vq2v(a, b);\n}\n\n//return mat3 of quaternion (rotation matrix without translation)\n//https://www.shadertoy.com/view/WsGfWm\nmat3 q2m(vec4 q) \n{\n    vec3 a = vec3(-1, 1, 1);\n    vec3 u = q.zyz * a, v = q.xyx * a.xxy;\n    mat3 m = mat3(0.5) + mat3(0, u.x,u.y,u.z, 0, v.x,v.y,v.z, 0) * q.w + matrixCompMult(outerProduct(q.xyz, q.xyz), 1. - mat3(1));\n    q *= q; \n    m -= mat3(q.y + q.z, 0, 0, 0, q.x + q.z, 0, 0, 0, q.x + q.y);\n    return m * 2.0;\n}\n\n//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\nvec4 m2q(mat3 m) \n{\n#define m2f(a,b) m[a][b]-m[b][a]\n    //http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n    float q = 2. * sqrt(abs(1. + m[0][0] + m[1][1] + m[2][2]));\n    return vec4(vec3(m2f(2, 1), m2f(0, 1), m2f(1, 0)) / q / 4., q);\n#undef m2f\n}\n\nfloat at2e(vec2 a) \n{\n    a *= 2.;\n    return atan(a.x, 1. - a.y);\n}\n\n//return quaternion of Euler[yaw,pitch,roll]     \nvec4 eYPR2q(vec3 o) \n{\n    o *= .5;\n    vec3 s = sin(o);\n    //https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n    o = cos(o);\n    vec4 a = vec4(s.xz, o.xz);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(-1, 1, -1, 1);\n}\n\nvec4 eYPR2q(vec2 o) \n{\n    o *= .5;\n    vec2 s = sin(o);\n    o = cos(o);\n    vec4 a = vec4(s.x, 0., o.x, 0.);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(- 1, 1, - 1, 1);\n}\n\nmat3 getCam(vec4 q) \n{\n    return q2m(q);\n}\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nuvec4 pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    return v;\n}\n\nfloat rand(){ return float(pcg4d(s0).x)/float(0xffffffffu); }\nvec2 rand2(){ return vec2(pcg4d(s0).xy)/float(0xffffffffu); }\nvec3 rand3(){ return vec3(pcg4d(s0).xyz)/float(0xffffffffu); }\nvec4 rand4(){ return vec4(pcg4d(s0))/float(0xffffffffu); }\n\nvec2 nrand2(float sigma, vec2 mean)\n{\n\tvec2 Z = rand2();\n    return mean + sigma * sqrt(-2.0 * log(Z.x)) * \n           vec2(cos(TWO_PI * Z.y),sin(TWO_PI * Z.y));\n}\n\nvec3 nrand3(float sigma, vec3 mean)\n{\n\tvec4 Z = rand4();\n    return mean + sigma * sqrt(-2.0 * log(Z.xxy)) * \n           vec3(cos(TWO_PI * Z.z),sin(TWO_PI * Z.z),cos(TWO_PI * Z.w));\n}\n\n//uniformly spherically distributed\nvec3 udir(vec2 rng)\n{\n    vec2 r = vec2(2.*PI*rng.x, acos(2.*rng.y-1.));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}\n\nconst float PI2 = 6.2831853071;\n\nconst float aperture_size = 0.0;\nvec2 aperture()\n{\n    vec2 r = rand2();\n    return vec2(sin(TWO_PI*r.x), cos(TWO_PI*r.x))*sqrt(r.y);\n}\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\nvec3 spectral_zucconi(float w)\n{\n    // w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\n\tconst vec3 cs = vec3(3.54541723, 2.86670055, 2.29421995);\n\tconst vec3 xs = vec3(0.69548916, 0.49416934, 0.28269708);\n\tconst vec3 ys = vec3(0.02320775, 0.15936245, 0.53520021);\n\n\treturn bump3y (\tcs * (x - xs), ys);\n}\n\nvec3 spectral_bruton (float w)\n{\n\tvec3 c;\n\n\tif (w >= 380. && w < 440.)\n\t\tc = vec3\n\t\t(\n\t\t\t-(w - 440.) / (440. - 380.),\n\t\t\t0.0,\n\t\t\t1.0\n\t\t);\n\telse if (w >= 440. && w < 490.)\n\t\tc = vec3\n\t\t(\n\t\t\t0.0,\n\t\t\t(w - 440.) / (490. - 440.),\n\t\t\t1.0\n\t\t);\n\telse if (w >= 490. && w < 510.)\n\t\tc = vec3\n\t\t(\t0.0,\n\t\t\t1.0,\n\t\t\t-(w - 510.) / (510. - 490.)\n\t\t);\n\telse if (w >= 510. && w < 580.)\n\t\tc = vec3\n\t\t(\n\t\t\t(w - 510.) / (580. - 510.),\n\t\t\t1.0,\n\t\t\t0.0\n\t\t);\n\telse if (w >= 580. && w < 645.)\n\t\tc = vec3\n\t\t(\n\t\t\t1.0,\n\t\t\t-(w - 645.) / (645. - 580.),\n\t\t\t0.0\n\t\t);\n\telse if (w >= 645. && w <= 780.)\n\t\tc = vec3\n\t\t(\t1.0,\n\t\t\t0.0,\n\t\t\t0.0\n\t\t);\n\telse\n\t\tc = vec3\n\t\t(\t0.0,\n\t\t\t0.0,\n\t\t\t0.0\n\t\t);\n\n\treturn saturate(c);\n}\nvec3 spectral_zucconi6 (float w)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n        float y = baoa + t*bard;\n        // body\n        if( y>0.0 && y<baba ) return t;\n        // caps\n        vec3 oc = (y<=0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - r*r;\n        h = b*b - c;\n        if( h>0.0 ) return -b - sqrt(h);\n    }\n    return -1.0;\n}\n\n\n// Spectrum to xyz approx function from Sloan http://jcgt.org/published/0002/02/01/paper.pdf\n// Inputs:  Wavelength in nanometers\nfloat xFit_1931( float wave )\n{\n    float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374),\n          t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323),\n          t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\n}\nfloat yFit_1931( float wave )\n{\n    float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247),\n          t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\n}\nfloat zFit_1931( float wave )\n{\n    float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278),\n          t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\n}\n\n#define xyzFit_1931(w) vec3( xFit_1931(w), yFit_1931(w), zFit_1931(w) ) \n\n// http://www.cie.co.at/technical-work/technical-resources\nvec3 standardObserver1931[] =\n    vec3[] (\n    vec3( 0.001368, 0.000039, 0.006450 ), // 380 nm\n    vec3( 0.002236, 0.000064, 0.010550 ), // 385 nm\n    vec3( 0.004243, 0.000120, 0.020050 ), // 390 nm\n    vec3( 0.007650, 0.000217, 0.036210 ), // 395 nm\n    vec3( 0.014310, 0.000396, 0.067850 ), // 400 nm\n    vec3( 0.023190, 0.000640, 0.110200 ), // 405 nm\n    vec3( 0.043510, 0.001210, 0.207400 ), // 410 nm\n    vec3( 0.077630, 0.002180, 0.371300 ), // 415 nm\n    vec3( 0.134380, 0.004000, 0.645600 ), // 420 nm\n    vec3( 0.214770, 0.007300, 1.039050 ), // 425 nm\n    vec3( 0.283900, 0.011600, 1.385600 ), // 430 nm\n    vec3( 0.328500, 0.016840, 1.622960 ), // 435 nm\n    vec3( 0.348280, 0.023000, 1.747060 ), // 440 nm\n    vec3( 0.348060, 0.029800, 1.782600 ), // 445 nm\n    vec3( 0.336200, 0.038000, 1.772110 ), // 450 nm\n    vec3( 0.318700, 0.048000, 1.744100 ), // 455 nm\n    vec3( 0.290800, 0.060000, 1.669200 ), // 460 nm\n    vec3( 0.251100, 0.073900, 1.528100 ), // 465 nm\n    vec3( 0.195360, 0.090980, 1.287640 ), // 470 nm\n    vec3( 0.142100, 0.112600, 1.041900 ), // 475 nm\n    vec3( 0.095640, 0.139020, 0.812950 ), // 480 nm\n    vec3( 0.057950, 0.169300, 0.616200 ), // 485 nm\n    vec3( 0.032010, 0.208020, 0.465180 ), // 490 nm\n    vec3( 0.014700, 0.258600, 0.353300 ), // 495 nm\n    vec3( 0.004900, 0.323000, 0.272000 ), // 500 nm\n    vec3( 0.002400, 0.407300, 0.212300 ), // 505 nm\n    vec3( 0.009300, 0.503000, 0.158200 ), // 510 nm\n    vec3( 0.029100, 0.608200, 0.111700 ), // 515 nm\n    vec3( 0.063270, 0.710000, 0.078250 ), // 520 nm\n    vec3( 0.109600, 0.793200, 0.057250 ), // 525 nm\n    vec3( 0.165500, 0.862000, 0.042160 ), // 530 nm\n    vec3( 0.225750, 0.914850, 0.029840 ), // 535 nm\n    vec3( 0.290400, 0.954000, 0.020300 ), // 540 nm\n    vec3( 0.359700, 0.980300, 0.013400 ), // 545 nm\n    vec3( 0.433450, 0.994950, 0.008750 ), // 550 nm\n    vec3( 0.512050, 1.000000, 0.005750 ), // 555 nm\n    vec3( 0.594500, 0.995000, 0.003900 ), // 560 nm\n    vec3( 0.678400, 0.978600, 0.002750 ), // 565 nm\n    vec3( 0.762100, 0.952000, 0.002100 ), // 570 nm\n    vec3( 0.842500, 0.915400, 0.001800 ), // 575 nm\n    vec3( 0.916300, 0.870000, 0.001650 ), // 580 nm\n    vec3( 0.978600, 0.816300, 0.001400 ), // 585 nm\n    vec3( 1.026300, 0.757000, 0.001100 ), // 590 nm\n    vec3( 1.056700, 0.694900, 0.001000 ), // 595 nm\n    vec3( 1.062200, 0.631000, 0.000800 ), // 600 nm\n    vec3( 1.045600, 0.566800, 0.000600 ), // 605 nm\n    vec3( 1.002600, 0.503000, 0.000340 ), // 610 nm\n    vec3( 0.938400, 0.441200, 0.000240 ), // 615 nm\n    vec3( 0.854450, 0.381000, 0.000190 ), // 620 nm\n    vec3( 0.751400, 0.321000, 0.000100 ), // 625 nm\n    vec3( 0.642400, 0.265000, 0.000050 ), // 630 nm\n    vec3( 0.541900, 0.217000, 0.000030 ), // 635 nm\n    vec3( 0.447900, 0.175000, 0.000020 ), // 640 nm\n    vec3( 0.360800, 0.138200, 0.000010 ), // 645 nm\n    vec3( 0.283500, 0.107000, 0.000000 ), // 650 nm\n    vec3( 0.218700, 0.081600, 0.000000 ), // 655 nm\n    vec3( 0.164900, 0.061000, 0.000000 ), // 660 nm\n    vec3( 0.121200, 0.044580, 0.000000 ), // 665 nm\n    vec3( 0.087400, 0.032000, 0.000000 ), // 670 nm\n    vec3( 0.063600, 0.023200, 0.000000 ), // 675 nm\n    vec3( 0.046770, 0.017000, 0.000000 ), // 680 nm\n    vec3( 0.032900, 0.011920, 0.000000 ), // 685 nm\n    vec3( 0.022700, 0.008210, 0.000000 ), // 690 nm\n    vec3( 0.015840, 0.005723, 0.000000 ), // 695 nm\n    vec3( 0.011359, 0.004102, 0.000000 ), // 700 nm\n    vec3( 0.008111, 0.002929, 0.000000 ), // 705 nm\n    vec3( 0.005790, 0.002091, 0.000000 ), // 710 nm\n    vec3( 0.004109, 0.001484, 0.000000 ), // 715 nm\n    vec3( 0.002899, 0.001047, 0.000000 ), // 720 nm\n    vec3( 0.002049, 0.000740, 0.000000 ), // 725 nm\n    vec3( 0.001440, 0.000520, 0.000000 ), // 730 nm\n    vec3( 0.001000, 0.000361, 0.000000 ), // 735 nm\n    vec3( 0.000690, 0.000249, 0.000000 ), // 740 nm\n    vec3( 0.000476, 0.000172, 0.000000 ), // 745 nm\n    vec3( 0.000332, 0.000120, 0.000000 ), // 750 nm\n    vec3( 0.000235, 0.000085, 0.000000 ), // 755 nm\n    vec3( 0.000166, 0.000060, 0.000000 ), // 760 nm\n    vec3( 0.000117, 0.000042, 0.000000 ), // 765 nm\n    vec3( 0.000083, 0.000030, 0.000000 ), // 770 nm\n    vec3( 0.000059, 0.000021, 0.000000 ), // 775 nm\n    vec3( 0.000042, 0.000015, 0.000000 )  // 780 nm\n);\nfloat standardObserver1931_w_min = 380.0f;\nfloat standardObserver1931_w_max = 780.0f;\nint standardObserver1931_length = 81;\n\nvec3 WavelengthToXYZLinear( float fWavelength )\n{\n    float fPos = ( fWavelength - standardObserver1931_w_min ) / (standardObserver1931_w_max - standardObserver1931_w_min);\n    float fIndex = fPos * float(standardObserver1931_length);\n    float fFloorIndex = floor(fIndex);\n    float fBlend = clamp( fIndex - fFloorIndex, 0.0, 1.0 );\n    int iIndex0 = int(fFloorIndex);\n    int iIndex1 = iIndex0 + 1;\n    iIndex1 = min( iIndex1, standardObserver1931_length - 1);\n\n    return mix( standardObserver1931[iIndex0], standardObserver1931[iIndex1], fBlend );\n}\n\nvec3 XYZtosRGB( vec3 XYZ )\n{\n    // XYZ to sRGB\n    // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n   mat3 m = mat3 (\n        3.2404542, -1.5371385, -0.4985314,\n\t\t-0.9692660,  1.8760108,  0.0415560,\n \t\t0.0556434, -0.2040259,  1.0572252 );\n    \n    return XYZ * m;\n}\n\nvec3 sRGBtoXYZ( vec3 RGB )\n{\n   // sRGB to XYZ\n   // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n\n   mat3 m = mat3(  \t0.4124564,  0.3575761, 0.1804375,\n \t\t\t\t\t0.2126729,  0.7151522, 0.0721750,\n \t\t\t\t\t0.0193339,  0.1191920, 0.9503041 );\n    \n    \n    return RGB * m;\n}\n\nvec3 WavelengthToXYZ( float f )\n{    \n    //return xyzFit_1931( f ) * mXYZtoSRGB;\n    \n    return WavelengthToXYZLinear( f );\n}\n\n\nstruct Chromaticities\n{\n    vec2 R, G, B, W;\n};\n    \nvec3 CIE_xy_to_xyz( vec2 xy )\n{\n    return vec3( xy, 1.0f - xy.x - xy.y );\n}\n\nvec3 CIE_xyY_to_XYZ( vec3 CIE_xyY )\n{\n    float x = CIE_xyY[0];\n    float y = CIE_xyY[1];\n    float Y = CIE_xyY[2];\n    \n    float X = (Y / y) * x;\n    float Z = (Y / y) * (1.0 - x - y);\n        \n\treturn vec3( X, Y, Z );        \n}\n\nvec3 CIE_XYZ_to_xyY( vec3 CIE_XYZ )\n{\n    float X = CIE_XYZ[0];\n    float Y = CIE_XYZ[1];\n    float Z = CIE_XYZ[2];\n    \n    float N = X + Y + Z;\n    \n    float x = X / N;\n    float y = Y / N;\n    float z = Z / N;\n    \n    return vec3(x,y,Y);\n}\n\nChromaticities Primaries_Rec709 =\nChromaticities(\n        vec2( 0.6400, 0.3300 ),\t// R\n        vec2( 0.3000, 0.6000 ),\t// G\n        vec2( 0.1500, 0.0600 ), \t// B\n        vec2( 0.3127, 0.3290 ) );\t// W\n\nChromaticities Primaries_Rec2020 =\nChromaticities(\n        vec2( 0.708,  0.292 ),\t// R\n        vec2( 0.170,  0.797 ),\t// G\n        vec2( 0.131,  0.046 ),  \t// B\n        vec2( 0.3127, 0.3290 ) );\t// W\n\nChromaticities Primaries_DCI_P3_D65 =\nChromaticities(\n        vec2( 0.680,  0.320 ),\t// R\n        vec2( 0.265,  0.690 ),\t// G\n        vec2( 0.150,  0.060 ),  \t// B\n        vec2( 0.3127, 0.3290 ) );\t// W\n\nmat3 RGBtoXYZ( Chromaticities chroma )\n{\n    // xyz is a projection of XYZ co-ordinates onto to the plane x+y+z = 1\n    // so we can reconstruct 'z' from x and y\n    \n    vec3 R = CIE_xy_to_xyz( chroma.R );\n    vec3 G = CIE_xy_to_xyz( chroma.G );\n    vec3 B = CIE_xy_to_xyz( chroma.B );\n    vec3 W = CIE_xy_to_xyz( chroma.W );\n    \n    // We want vectors in the directions R, G and B to form the basis of\n    // our matrix...\n    \n\tmat3 mPrimaries = mat3 ( R, G, B );\n    \n    // but we want to scale R,G and B so they result in the\n    // direction W when the matrix is multiplied by (1,1,1)\n    \n    vec3 W_XYZ = W / W.y;\n\tvec3 vScale = inverse( mPrimaries ) * W_XYZ;\n    \n    return transpose( mat3( R * vScale.x, G * vScale.y, B * vScale.z ) );\n}\n\nmat3 XYZtoRGB( Chromaticities chroma )\n{\n    return inverse( RGBtoXYZ(chroma) );\n}\n\n// chromatic adaptation\n\n// http://www.brucelindbloom.com/index.html?Eqn_ChromAdapt.html    \n\n// Test viewing condition CIE XYZ tristimulus values of whitepoint.\nvec3 XYZ_w = vec3( 1.09850,\t1.00000,\t0.35585); // Illuminant A\n// Reference viewing condition CIE XYZ tristimulus values of whitepoint.\nvec3 XYZ_wr = vec3(0.95047,\t1.00000,\t1.08883); // D65\n\n\nconst mat3 CA_A_to_D65_VonKries = mat3(\n    0.9394987, -0.2339150,  0.4281177,\n\t-0.0256939,  1.0263828,  0.0051761,\n \t0.0000000,  0.0000000,  3.0598005\n    );\n\n\nconst mat3 CA_A_to_D65_Bradford = mat3(\n    0.8446965, -0.1179225,  0.3948108,\n\t-0.1366303,  1.1041226,  0.1291718,\n \t0.0798489, -0.1348999,  3.1924009\n    );\n\n\nconst mat3 mCAT_VonKries = mat3 ( \n    0.4002400,  0.7076000, -0.0808100,\n\t-0.2263000,  1.1653200,  0.0457000,\n \t0.0000000,  0.0000000,  0.9182200 );\n\nconst mat3 mCAT_02 = mat3( \t0.7328, 0.4296, -0.1624,\n\t\t\t\t\t\t\t-0.7036, 1.6975, 0.0061,\n \t\t\t\t\t\t\t0.0030, 0.0136, 0.9834 );\n\nconst mat3 mCAT_Bradford = mat3 (  0.8951000, 0.2664000, -0.1614000,\n\t\t\t\t\t\t\t\t-0.7502000,  1.7135000,  0.0367000,\n \t\t\t\t\t\t\t\t0.0389000, -0.0685000,  1.0296000 );\n\n\nmat3 GetChromaticAdaptionMatrix()\n{\n    //return inverse(CA_A_to_D65_VonKries);    \n    //return inverse(CA_A_to_D65_Bradford);\n        \n    //return mat3(1,0,0, 0,1,0, 0,0,1); // do nothing\n    \n\t//mat3 M = mCAT_02;\n    //mat3 M = mCAT_Bradford;\n    mat3 M = mCAT_VonKries;\n    //mat3 M = mat3(1,0,0,0,1,0,0,0,1);\n    \n    vec3 w = XYZ_w * M;\n    vec3 wr = XYZ_wr * M;\n    vec3 s = w / wr;\n    \n    mat3 d = mat3( \n        s.x,\t0,\t\t0,  \n        0,\t\ts.y,\t0,\n        0,\t\t0,\t\ts.z );\n        \n    mat3 cat = M * d * inverse(M);\n    return cat;\n}\n\nfloat BlackBody( float t, float w_nm )\n{\n    float h = 6.6e-34; // Planck constant\n    float k = 1.4e-23; // Boltzmann constant\n    float c = 3e8;// Speed of light\n\n    float w = w_nm / 1e9;\n\n    // Planck's law https://en.wikipedia.org/wiki/Planck%27s_law\n    \n    float w5 = w*w*w*w*w;    \n    float o = 2.*h*(c*c) / (w5 * (exp(h*c/(w*k*t)) - 1.0));\n\n    return o;    \n}", "buffer_b_code": "#define SPP 3\n\nfloat ior;\n\nfloat DispersionLaw(float wv)\n{\n    wv = wv*1e-3; //micro meters\n    const float A = 1.7280;\n    const float B = 0.2;\n    return A + B/(wv*wv);\n}\n\n\nstruct Hit\n{\n    vec3 ro;//ray origin\n    float td;//travelled distance\n    vec3 rh;//ray hit position\n    vec3 rd;//ray direction\n    vec3 no;//normal at the hit position\n    float id;//hit object id\n    //other material stuff\n};\n\nstruct Mat\n{\n    vec3 col; //color\n    vec3 emi; //emission\n    float rgh; //roughness\n};\n\nMat getMaterial(float id)\n{\n    Mat outmat;\n    outmat.col = vec3(1.0);\n    outmat.emi = vec3(0.0);\n    outmat.rgh = 0.3;\n    return outmat;\n}\n\nvec3 opU( vec3 d, float iResult, float mat ) {\n\treturn (iResult < d.y) ? vec3(d.x, iResult, mat) : d;\n}\n\nconst float density = 0.001;\n\nfloat iVolume( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal )\n{\n    float d = -log(rand())/density;\n    \n    if (d < distBound.x || d > distBound.y) \n    {\n        return MAX_DIST;\n    } \n    else \n    {\n    \treturn d;\n    }\n}\n\nHit worldhit(in vec3 ro, in vec3 rd, in vec2 dist) {\n    vec3 normal;\n    vec3 tmp0, tmp1, d = vec3(dist, 0.);\n    \n    \n    \n    d = opU(d, iPlane      (ro,                  rd, d.xy, normal, vec3(0,1,0), 0.), 1.);\n    \n    d = opU(d, iBox        (ro-vec3( 1.5,.252, -1.5), rd, d.xy, normal, vec3(.25)), 3.);\n    d = opU(d, iSphere     (ro-vec3( 0,.252, 0), rd, d.xy, normal, .25), 3.);\n    d = opU(d, iSphere     (ro-vec3( 0.6,.252, 0.2), rd, d.xy, normal, .25), 3.);\n    d = opU(d, iSphere     (ro-vec3( -0.5,.252, 0.1), rd, d.xy, normal, .25), 3.);\n    d = opU(d, iVolume     (ro, rd, d.xy, normal), 4.0);\n\n    Hit res;\n    res.ro = ro;\n    res.rh = ro + d.y*rd;\n    res.rd = rd;\n    res.no = normal;\n    res.id = d.z;\n    res.td = d.y;\n    return res;\n}\n\nvoid processHit(Hit res, inout vec3 ro, inout vec3 rd, inout float inside, inout vec3 col, inout vec3 att)\n{\n    Mat m = getMaterial(res.id);\n    \n    col += att*m.emi;\n    att *= m.col;\n    vec3 normal = res.no;\n    if(res.id < 4.0)\n    {\n        if(res.id == 3.0)\n        {\n            ro = res.rh ;\n             \n            vec3 matn = normalize(nrand3(0.005, normal*inside));\n            vec3 newrd = refract(rd, matn, pow(ior, -inside));\n            if(length(newrd) > 0.5) //not total internal reflection\n            {\n                inside = -inside;\n                rd = newrd;\n            }\n            else\n            {\n                rd =reflect(rd, matn); \n            } \n        }\n        else\n        {\n            //surface scatter\n            rd = reflect(res.rd, normalize(nrand3(m.rgh, normal))); \n            ro = res.rh + inside*res.no*5e-3;\n        }\n      \n    } \n    else\n    {\n        //volume scatter\n        rd = udir(rand2());\n        ro = res.rh;\n    }\n}\n\n\n#define LASER_PATH 9\nint cpath;\nvec3 scol;\nvec3 path[LASER_PATH+1];\n\nfloat getClosestLinePoint(vec3 ro, vec3 rd, vec3 x)\n{\n    return dot(rd, x - ro);\n}\n\nfloat rand(float a, float b)\n{\n    return mix(a, b, rand());\n}\n\n//Importance sample a point on a segment so that the probability of sampling a point on the segment r1 r2\n//is inversely proportional to the square of the distance to point x\nvec3 importanceSampleSegmentPoint(vec3 r1, vec3 r2, vec3 x)\n{\n    vec3 x0 = r1 - x;\n    vec3 rd = normalize(r2 - r1);\n    float l = length(r2 - r1);\n    float a = dot(rd, x0);\n    float x02 = dot(x0, x0);\n    float sq = sqrt(x02 - a*a); \n    float t = sq*tan(rand(atan(a/sq),atan((l + a)/sq))) - a;\n    return r1 + rd*t; //importance sampled point\n}\n\n//get closest point pair for 2 segments\nvoid getClosestPointPair(vec3 r00, vec3 r01, vec3 r10, vec3 r11, out vec3 P1, out vec3 P2)\n{\n  vec3 delta1 = r01 - r00;\n  vec3 delta2 = r11 - r10;\n  vec3 rd1 = normalize(delta1);\n  vec3 rd2 = normalize(delta2);\n  float l1 = length(delta1);\n  float l2 = length(delta2);\n  vec3 delta3 = r00 - r10;\n  float d1d2 = dot(rd1, rd2);\n  float d1de = dot(rd1, delta3);\n  float d2de = dot(rd2, delta3);\n  float deno = 1.0/(1.0 - d1d2*d1d2);\n  float t1 = (d1d2*d2de - d1de)*deno;\n  float t2 = (d2de - d1d2*d1de)*deno;\n  \n  if(t1 < 0.0 || t1 > l1)\n  {\n      t1 = clamp(t1, 0.0, l1);\n      P1 = r00 + t1*rd1;\n      t2 = clamp(getClosestLinePoint(r10, rd2, P1), 0.0, l2);\n      P2 = r10 + t2*rd2;\n      return;\n  }\n  \n  if(t2 < 0.0 || t2 > l2)\n  {\n      t2 = clamp(t2, 0.0, l2);\n      P2 = r10 + t2*rd2;\n      t1 = clamp(getClosestLinePoint(r00, rd1, P2), 0.0, l1);\n      P1 = r00 + t1*rd1;\n      return;\n  }\n  \n   P1 = r00 + t1*rd1;\n   P2 = r10 + t2*rd2;\n}\n\n//choose a laser path segment p0 p1 with probability proportional to the path segment lenght and \n//inverse distance to the camera ray path segment r0 r1\nvoid importanceSamplePath(vec3 r0, vec3 r1, out vec3 p0, out vec3 p1)\n{\n    float score[LASER_PATH];\n    float totalscore = 0.0;\n    vec3 P0, P1;\n    for(int i = 0; i < cpath; i++)\n    {\n        getClosestPointPair(r0,r1,path[i],path[i+1],P0,P1);\n        float s = distance(path[i],path[i+1])/distance(P0,P1);\n        totalscore += s;\n        score[i] = totalscore;\n    }\n    \n    //target score\n    float rscore = rand()*totalscore;\n    \n    for(int i = 0; i < cpath; i++)\n    {\n        if(rscore < score[i]) //found score\n        {\n            p0 = path[i];\n            p1 = path[i+1];\n            return;\n        }\n    }\n}\n\n//next event estimation sample using the light path\nvoid connectPath(Hit res, inout vec3 col, inout vec3 att)\n{\n    //ray path\n    vec3 r0 = res.ro;\n    vec3 r1 = res.rh;\n    \n    //get random path\n    vec3 p0, p1;\n    importanceSamplePath(r0,r1,p0,p1);\n    \n    //find 2 closest points on camera segment and light path \n    vec3 s1, s2;\n    getClosestPointPair(p0, p1, r0, r1, s1, s2); \n    \n    vec3 pathp = importanceSampleSegmentPoint(p0, p1, s2);\n    vec3 camp = importanceSampleSegmentPoint(r0, r1, s1);\n    \n    //trace a ray from the camp to pathp\n    vec3 delta = pathp - camp;\n    float td = length(delta);\n    \n    \n    Hit con = worldhit( camp, normalize(delta), vec2(.001, td));\n    \n    if(con.td >= td) col += att/(td+1e-10);\n    //col += att*pathhit(res.ro, res.rd, res.td);\n}\n\nbool getRay(vec2 uv, out vec3 ro, out vec3 rd)\n{\n    mat3 cam = getCam(get(CamA));\n    vec2 apert_cent = -0.*uv; \n    vec2 ap = aperture();  \n    if(!(distance(ap, apert_cent) < 1.0)) return false;  \n    float apd = length(ap);  \n    vec3 daperture = ap.x*cam[0] + ap.y*cam[1]; \n    ro = get(CamP).xyz + aperture_size*daperture;\n    float focus =2.5 + 0.8*pow(apd,5.0);\n    rd = normalize(focus*(cam*vec3(FOV*uv, 1.0)) - aperture_size*daperture);\n    return true;\n}\n\nvoid traceLaser()\n{\n    vec3 ro, rd, normal;\n  \n  \n    float wv = mix(420.0, 750.0, rand());\n    float id = DispersionLaw(wv);\n    float blackb = 1e-13 * BlackBody(6000.0, wv);\n    scol = blackb*WavelengthToXYZLinear(wv);\n    \n    ior = id;\n     \n    //trace laser   \n    ro = get(RayO).xyz;\n    rd = normalize(get(RayD).xyz + 0.*udir(rand2()));\n    \n    float inside = 1.0;\n    \n    vec3 col = vec3(0.0);\n    vec3 att = scol;\n    \n    \n    for(cpath = 0; cpath < LASER_PATH - 1; cpath++)\n    {\n        path[cpath] = ro;\n        Hit res = worldhit( ro, rd, vec2(.001, MAX_DIST));\n        if (res.id > 0.) \n        {\n            processHit(res,ro,rd,inside,col,att);\n        }\n        else \n        {\n            ro = res.rh;\n            break;\n        }\n    }\n    path[cpath+1] = ro;\n}\n\n\n\nvec4 render(vec2 fragCoord)\n{\n    fragCoord += nrand2(0.5, vec2(0.));\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n   \n    vec3 ro, rd, normal;\n    \n    if(!getRay(uv, ro, rd)) return vec4(0,0,0,1);\n    \n    vec3 col = vec3(0.0);\n    vec3 att = scol;\n    float inside = 1.0;\n    \n    for(int i = 0; i < 5; i++)\n    {\n        Hit res = worldhit( ro, rd, vec2(.001, MAX_DIST));\n        \n        connectPath(res, col, att);\n        processHit(res,ro,rd,inside,col,att);\n    }\n   \n    return vec4(col, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    rng_initialize(fragCoord, iFrame);\n    //prev \n    if(get(CamP).w == 0.0)\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    else\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy)*0.25;\n   \n   traceLaser();\n   \n   for(int i = 0; i < SPP; i++)\n       fragColor += clamp(render(fragCoord),-0.5e3,0.5e3);\n       \n    /*\n      mat3 prevcam = getCam(get(PrevCamA));\n    vec3 prevcamp = get(PrevCamP).xyz;\n    \n    getRay(fragCoord, ro, rd);\n    \n    vec3 rep = reproject(prevcam, prevcamp, iResolution.xy, ro + rd*std);\n    float reject = 0.96*float(all(lessThan(rep.xy, iResolution.xy)) && all(greaterThan(rep.xy,vec2(0))));\n    fragColor += texture(iChannel0, rep.xy/iResolution.xy)*reject;\n    */\n}", "buffer_b_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tjSDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 111, 143, 143, 469], [471, 471, 490, 490, 540], [541, 541, 598, 598, 714]], "test": "untested"}
{"id": "st2SDh", "name": "fractalX", "author": "zeo", "description": "fractal alien text", "tags": ["fractal"], "likes": 13, "viewed": 295, "published": 3, "date": "1627599768", "time_retrieved": "2024-07-30T19:08:46.512031", "image_code": "/*\n\n\tdraw letter shapes after subdividing uv space randomly\n\n*/\n\n#define PI 3.1415926535\n\nfloat random2d(vec2 n) { \n    return fract(sin(dot(n, vec2(129.9898, 4.1414))) * 2398.5453);\n}\n\nvec2 getCellIJ(vec2 uv, float gridDims){\n    return floor(uv * gridDims)/ gridDims;\n}\n\nvec2 rotate2D(vec2 position, float theta)\n{\n    mat2 m = mat2( cos(theta), -sin(theta), sin(theta), cos(theta) );\n    return m * position;\n}\n\n//from https://github.com/keijiro/ShaderSketches/blob/master/Text.glsl\nfloat letter(vec2 coord, float size)\n{\n    vec2 gp = floor(coord / size * 7.); // global\n    vec2 rp = floor(fract(coord / size) * 7.); // repeated\n    vec2 odd = fract(rp * 0.5) * 2.;\n    float rnd = random2d(gp);\n    float c = max(odd.x, odd.y) * step(0.5, rnd); // random lines\n    c += min(odd.x, odd.y); // fill corner and center points\n    c *= rp.x * (6. - rp.x); // cropping\n    c *= rp.y * (6. - rp.y);\n    return clamp(c, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy / iResolution.xy;    \n    //correct aspect ratio\n    uv.x *= iResolution.x/iResolution.y;\n\n    float t = iTime;\n    float scrollSpeed = 1.;\n    float dims = 3.0;\n    int maxSubdivisions = 3;\n    \n    // uv = rotate2D(uv,PI/12.0);\n    uv.y -= floor(iTime * scrollSpeed);\n    \n    float cellRand;\n    vec2 ij;\n    \n   \tfor(int i = 0; i <= maxSubdivisions; i++) { \n        ij = getCellIJ(uv, dims);\n        cellRand = random2d(ij);\n        dims *= 2.0;\n        //decide whether to subdivide cells again\n        float cellRand2 = random2d(ij + 454.4543);\n        if (cellRand2 > 0.3){\n        \tbreak; \n        }\n    }\n   \n    //draw letters    \n    float b = letter(uv, 1.0 / (dims));\n\t\n    //fade in\n    /* float scrollPos = iTime*scrollSpeed + 0.5;\n    float showPos = -ij.y + cellRand;\n    float fade = smoothstep(showPos ,showPos + 0.05, scrollPos );\n    b *= fade; */\n    \n    //hide some\n    //if (cellRand < 0.1) b = 0.0;\n    \n    fragColor = vec4(vec3(1.-b), 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st2SDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 114, 114, 184], [186, 186, 226, 226, 271], [273, 273, 316, 316, 413], [415, 486, 524, 524, 928], [930, 930, 987, 987, 1991]], "test": "untested"}
{"id": "NljXD1", "name": "drawing 2d 29-Jul-2021", "author": "jorge2017a1", "description": "drawing 2d 29-Jul-2021\n\n", "tags": ["drawing2d29jul2021"], "likes": 7, "viewed": 242, "published": 3, "date": "1627588245", "time_retrieved": "2024-07-30T19:08:47.279978", "image_code": "/// IQ funciones....\n//https://iquilezles.org/articles/distfunctions2d\n/// por jorge2017a1...drawing 2d 29-Jul-2021\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.5),b,d)\n\n#define TAU 6.28318530718 // 2 * pi\n#define PHI 1.57079632679 // pi / 2\n#define PI 3.1415926   ///3.14159265358979323846264\n\n\n\nvec2 rotatevec2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  //colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj),0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.01,0.0));\n  \n  return colOut;\n}\n\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  \n  return colOut;\n}\n\n\n\nconst vec3 colNegro= vec3(0.0);\nconst vec3 colBlanco= vec3(1.0);\nconst vec3 colRojo= vec3(1.0,0.0,0.0);\nconst vec3 colRojo2= vec3(8.0,0.0,0.0);\n\nconst vec3 col0= vec3(0.18,0.05,0.00);\nconst vec3 col1= vec3(0.98,0.47,0.63);\nconst vec3 col2= vec3(0.57,0.22,0.48);\nconst vec3 col3= vec3(0.64,0.11,0.13);\nconst vec3 col4= vec3(0.69,0.38,0.65);\nconst vec3 col5= vec3(0.11,0.28,0.56);\nconst vec3 col6= vec3(0.96,0.60,0.12);\nconst vec3 col7= vec3(0.87,0.66,0.56);\nconst vec3 col8= vec3(0.89,0.66,0.56);\n\n\nfloat opU(float d1, float d2) {return min(d1, d2); }\n\n\nfloat sdParallelogram( in vec2 p, float wi, float he, float sk )\n{\n    vec2 e = vec2(sk,he);\n    p = (p.y<0.0)?-p:p;\n    vec2  w = p - e; w.x -= clamp(w.x,-wi,wi);\n    vec2  d = vec2(dot(w,w), -w.y);\n    float s = p.x*e.y - p.y*e.x;\n    p = (s<0.0)?-p:p;\n    vec2  v = p - vec2(wi,0); v -= e*clamp(dot(v,e)/dot(e,e),-1.0,1.0);\n    d = min( d, vec2(dot(v,v), wi*he-abs(s)));\n    return sqrt(d.x)*sign(-d.y);\n}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\n\n///-----------------------------------------------------\n\n\n// signed distance to a n-star polygon with external angle en\nfloat sdStar(in vec2 p, in float r, in int n, in float m) // m=[2,n]\n{\n    // these 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) and simplify, for regular polygon,\n\n    // reduce to first sector\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    // line sdf\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n    float b = sqrt(r*r-d*d);\n    return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                             : length(p-vec2(-d,0.0))-r;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    float t=iTime*0.35;\n    uv*=1.5;\n    \n    float sm=smoothstep(radians(-5.0), radians(5.0) ,(fract(iTime*0.5)));\n    //uv=rotatevec2(uv,sm+radians(300.0)+(iTime)*3.141516/360.0 );\n    uv=rotatevec2(uv,sm+radians(300.0));\n    \n   \n    vec3 col=NubeYrayo(uv, iTime);\n    \n    float sds1= sdStar(uv, 2.0, 8, 5.0); // m=[2,n]\n    col= DrawFigBorde(col5,col,sds1);\n    \n    float sdt1= sdTriangleIsosceles(uv-vec2(0.0,-1.35), vec2(1.5,0.7));\n    col= DrawFigBorde(col1,col,sdt1);\n    \n    \n    float sdE1= sdEllipse(uv, vec2(1.0,1.2) );\n    float sdE2= sdEllipse(uv, vec2(1.0,-1.5-uv.y)  );\n    sdE2=differenceSDF(sdE1,sdE2);\n    \n   col= DrawFigBorde(col2,col,sdE1);\n   col= DrawFigBorde(col0,col,sdE2);\n    \n    \n    vec2 uv2=rotatevec2(uv-vec2(0.0,-0.6),radians(90.00));\n    float sdv1= sdVesica(uv2, 0.65, 0.5);\n    col= DrawFigBorde(col3,col,sdv1);\n    \n    \n    uv.x=abs(uv.x)-0.5;\n    \n    float wi=0.5;\n    float he=0.4; \n    float sk=0.7+abs(sin(fract(iTime*0.5))); \n    float sdp1= sdParallelogram(uv,  wi,he,sk );\n    float sdc1= sdCircle(uv,0.35);\n    \n    \n    float sdc2= sdCircle(uv,0.2);\n    float sdc3= sdCircle(uv,0.1);\n    \n    float inters= intersectSDF(sdc1,sdp1);\n    col= DrawFigBorde(colBlanco,col, inters);\n     sdc2= intersectSDF(sdc2,sdp1);\n    col= DrawFigBorde(col0,col,sdc2);\n    col= DrawFigBorde(col3,col,sdc3);\n    \n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "// Stormy Night\n// By: Brandon Fogerty\n// bfogerty at gmail dot com \n// xdpixel.com\n\n\nfloat Hash( vec2 p)\n{\n     vec3 p2 = vec3(p.xy,1.0);\n    return fract(sin(dot(p2,vec3(37.1,61.7, 12.4)))*3758.5453123);\n}\n\nfloat noise(in vec2 p)\n{\n    vec2 i = floor(p);\n     vec2 f = fract(p);\n     f *= f * (3.0-2.0*f);\n\n    return mix(mix(Hash(i + vec2(0.,0.)), Hash(i + vec2(1.,0.)),f.x),\n               mix(Hash(i + vec2(0.,1.)), Hash(i + vec2(1.,1.)),f.x),\n               f.y);\n}\n\nfloat fbm(vec2 p)\n{\n     float v = 0.0;\n     v += noise(p*1.0)*.5;\n     v += noise(p*2.)*.25;\n     v += noise(p*4.)*.125;\n     return v;\n}\n\nvec3 clouds( vec2 uv, vec2 dir, float time )\n{\n\tdir *= time;\n\tvec3 finalColor = fbm( (uv * 1.5) + dir ) * vec3( 1.0 );\t\n\t\n\treturn finalColor;\n}\n\nvec3 lightning( vec2 uv, float time )\n{\n\tfloat timeVal = time;\n\tvec3 finalColor = vec3( 0.0 );\n\tfor( int i=0; i < 3; ++i )\n\t{\n\t\tfloat indexAsFloat = float(i);\n\t\tfloat amp = 40.0 + (indexAsFloat*1.0);\n\t\tfloat period = 2.0 + (indexAsFloat+2.0);\n\t\t\n\t\tfloat thickness = mix( 0.1, 0.7, uv.y * 0.5 + 0.5 );\n\t\t\n\t\tfloat intensity = mix( 0.5, 1.5, noise(uv*10.0) );\n\t\tfloat t = abs( thickness / (sin(uv.x + fbm( uv + timeVal * period )) * amp) * intensity );\n\t\tfloat show = fract(abs(sin(timeVal))) >= 0.95 ? 1.0 : 0.0;\n\t\tshow *= step( abs(fbm( vec2( sin(time * 50.0), 0.0 ) )), 0.4);\n\t\t\n\t\t\n\t\tfinalColor +=  t * vec3( 0.3, 0.5, 2.0 ) * show;\n\t}\n\t\n\treturn finalColor;\n}\n\nvec3 NubeYrayo(vec2 uv, float time)\n{\n\n\tvec3 finalColor = vec3( 0.0 );\n\tfinalColor += sin( clouds( uv, vec2( 1.0, 0.1 ) , time));\n\t\n\tfloat xOffset = mix( 1.5, -1.5, fbm(vec2( fract(time), 0.00 ) ) );\n\tvec2 uvOffset = vec2( xOffset, 0.0 );\n\t\n\tvec2 lightningUV = uv + uvOffset;\n\t\n\tfloat theta = 3.14159 * 2.1;\n\tlightningUV.x = uv.x * cos(theta) - uv.y*sin(theta); \n\tlightningUV.y = uv.x * sin(theta) + uv.y*cos(theta); \n\t\n\t\n\tfinalColor += lightning( lightningUV + uvOffset ,time);\n    finalColor += lightning( lightningUV + vec2(-1.5,0.0) ,time*4.5)*vec3(1.0,0.2,0.2);\n\t\n\t//finalColor -= sin( clouds( uv, vec2( 2.0 ), time )) * 0.30;\n    return finalColor;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NljXD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[402, 402, 438, 438, 533], [536, 580, 627, 627, 654], [655, 655, 698, 698, 725], [726, 726, 774, 774, 802], [804, 804, 839, 839, 867], [870, 870, 932, 932, 1125], [1128, 1128, 1185, 1185, 1257], [1759, 1759, 1790, 1790, 1811], [1814, 1814, 1880, 1880, 2222], [2224, 2224, 2275, 2275, 2583], [2587, 2587, 2629, 2629, 3651], [3713, 3775, 3845, 3903, 4339], [4341, 4341, 4383, 4383, 4540], [4543, 4543, 4600, 4600, 6081]], "test": "untested"}
{"id": "NtjXW1", "name": "digital number grid", "author": "yasuo", "description": "digital number grid", "tags": ["distance2d"], "likes": 2, "viewed": 262, "published": 3, "date": "1627577453", "time_retrieved": "2024-07-30T19:08:48.118736", "image_code": "#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define Slice(p,a) dot(p,vec2(sin(a),cos(a)))\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(234.56,789.34));\n    p+=dot(p,p+34.56);\n    return fract(p.x+p.y);\n}\n\n// distance 2d digital alarm font\nconst float cDefault[7] = float[](0.,0.,0.,0.,0.,0.,0.);\nconst float c1[7] = float[](10.,0.,0.,10.,10.,10.,10.);\nconst float c2[7] = float[](0.,0.,10.,0.,0.,10.,0.);\nconst float c3[7] = float[](0.,0.,0.,0.,10.,10.,0.);\nconst float c4[7] = float[](10.,0.,0.,10.,10.,0.,0.);\nconst float c5[7] = float[](0.,10.,0.,0.,10.,0.,0.);\nconst float c6[7] = float[](0.,10.,0.,0.,0.,0.,0.);\nconst float c7[7] = float[](0.,0.,0.,10.,10.,10.,10.);\nconst float c8[7] = float[](0.,0.,0.,0.,0.,0.,0.);\nconst float c9[7] = float[](0.,0.,0.,0.,10.,0.,0.);\nconst float c0[7] = float[](0.,0.,0.,0.,0.,0.,10.);\nconst float cTBase[7] = float[](0.,10.,10.,10.,10.,10.,10.);\nconst float cKBase[7] = float[](10.,10.,0.,10.,0.,0.,0.);\nconst float cYBase[7] = float[](10.,0.,0.,0.,10.,0.,0.);\n\nconst vec2 digitVPos = vec2(0.08,0.073);\nconst vec2 digitHPos = vec2(0.0,0.15);\n\nfloat dDigitV(vec2 p){\n    float d = B(p,vec2(0.02,0.1));\n    p = abs(p);\n    p-=vec2(0.02,0.05);\n    d = max(Slice(p,44.775),d);\n    return d;\n}\n\nfloat dDigitH(vec2 p){\n    p*=Rot(radians(90.0));\n    float d = dDigitV(p);\n    return d;\n}\n\nfloat dDigitBase(vec2 p, float[7] char){\n    vec2 prevP = p;\n    float d = 10.0;\n    float d2 = 10.0;\n    // 1\n    d = (char[0])+dDigitH(p-digitHPos);\n    // 2\n    d2 = (char[1])+dDigitV(p-digitVPos);\n    d = min(d,d2);\n    // 3\n    d2 = (char[2])+dDigitV(p+vec2(-digitVPos.x,digitVPos.y));\n    d = min(d,d2);\n    // 4\n    d2 = (char[3])+dDigitH(p+digitHPos);\n    d = min(d,d2);\n    // 5\n    d2 = (char[4])+dDigitV(p+digitVPos);\n    d = min(d,d2);\n    // 6\n    d2 = (char[5])+dDigitV(p+vec2(digitVPos.x,-digitVPos.y));\n    d = min(d,d2);\n    // 7\n    d2 = (char[6])+dDigitH(p);\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat dDot(vec2 p){\n    p.y = abs(p.y);\n    p.y-=0.073;\n    float d = B(p,vec2(0.02));\n    return d;\n}\n\nfloat dDigitNumber(vec2 p, int num){\n    float d = 100.0;\n    if(num == 0){\n        d = dDigitBase(p,c0);\n    } else if(num == 1){\n        d = dDigitBase(p,c1);\n    } else if(num == 2){\n        d = dDigitBase(p,c2);\n    } else if(num == 3){\n        d = dDigitBase(p,c3);\n    } else if(num == 4){\n        d = dDigitBase(p,c4);\n    } else if(num == 5){\n        d = dDigitBase(p,c5);\n    } else if(num == 6){\n        d = dDigitBase(p,c6);\n    } else if(num == 7){\n        d = dDigitBase(p,c7);\n    } else if(num == 8){\n        d = dDigitBase(p,c8);\n    } else if(num == 9){\n        d = dDigitBase(p,c9);\n    }\n    \n    return d;\n}\n\nfloat dDrawNumbersBg(vec2 p){\n    float d = dDigitBase(p+vec2(0.375,0.0),cDefault);\n    float d2 = dDigitBase(p+vec2(0.15,0.0),cDefault);\n    d = min(d,d2);\n    d2 = dDigitBase(p+vec2(-0.15,0.0),cDefault);\n    d = min(d,d2);\n    d2 = dDigitBase(p+vec2(-0.375,0.0),cDefault);\n    d = min(d,d2);\n    return d;\n}\n\nfloat dDrawNumbers(vec2 p){\n    float t = iTime;\n    float d = dDot(p+vec2(0.0,0.0));\n    \n    float d2 = dDigitNumber(p+vec2(0.375,0.0),0);\n    d = min(d,d2);\n    d2 = dDigitNumber(p+vec2(0.15,0.0),int(mod(t*0.5,10.0)));\n    d = min(d,d2);\n    d2 = dDigitNumber(p+vec2(-0.15,0.0),int(mod(t,10.0)));\n    d = min(d,d2);\n    d2 = dDigitNumber(p+vec2(-0.375,0.0),int(mod(t*5.0,10.0)));\n    d = min(d,d2);\n    return d;\n}\n\nvec3 scene(vec2 p, vec3 col){\n    p*=2.5;\n    p.x+=iTime*0.5;\n    vec2 gv = fract(p)-0.5;\n    vec2 id = floor(p);\n\n    float n = Hash21(id);\n    float d = 100.0;\n    if(n<0.6){\n        d = B(gv,vec2(0.48));\n    }\n    \n    col = mix(col,0.5 + 0.5*cos(p.xyx-n+vec3(0,2.+n,3.-n)),S(d,0.0));\n    \n    if(d != 100.0){\n        gv*=1.5;\n        float n2 = (n+n+n+n+n+n)*3.0;\n        if(n<0.3){\n            gv.x+=((n>=0.1)?1.:-1.0)*iTime*0.3+n2;\n            gv.x = mod(gv.x,1.1)-0.55;\n            float y = (n>=0.1)?0.5:-0.5;\n            float d2 = dDrawNumbersBg(gv-vec2(0.0,y));\n            col = mix(col,vec3(0.3),S(max(d,d2),0.0));\n            d2 = dDrawNumbers(gv-vec2(0.0,y));\n            col = mix(col,vec3(1.0),S(max(d,d2),0.0));\n        }\n        \n        if(n>=0.3){\n            float y = (n<=0.4)?-0.5:0.5;\n            gv*=Rot(radians(90.0));\n            gv.x+=((n<=0.4)?1.:-1.0)*iTime*0.4+n2;\n            gv.x = mod(gv.x,1.1)-0.55;\n            float d2 = dDrawNumbersBg(gv-vec2(0.0,y));\n            col = mix(col,vec3(0.3),S(max(d,d2),0.0));\n            d2 = dDrawNumbers(gv-vec2(0.0,y));\n            col = mix(col,vec3(1.0),S(max(d,d2),0.0));\n        }\n    }\n    \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    uv*=1.8;\n    \n    vec3 col = vec3(0.0);\n    \n    col = scene(uv,col);\n    \n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtjXW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[251, 251, 273, 273, 363], [1245, 1245, 1267, 1267, 1390], [1392, 1392, 1414, 1414, 1483], [2104, 2104, 2123, 2123, 2206], [2208, 2208, 2244, 2244, 2835], [2837, 2837, 2866, 2866, 3146], [3148, 3148, 3175, 3175, 3565], [3567, 3567, 3596, 3596, 4758], [4760, 4760, 4817, 4817, 4999]], "test": "untested"}
{"id": "ftjSWh", "name": "RIP Dusty Hill :-(", "author": "flockaroo", "description": "Oh no!! Dusty is gone...\n...in memoriam Dusty Hill :-(\n\n(...the visual shader is an old one - but added some sound shader - an old zztop classic)\n", "tags": ["sound", "sad", "rip", "zztop", "dustyhill"], "likes": 30, "viewed": 677, "published": 3, "date": "1627568742", "time_retrieved": "2024-07-30T19:08:49.249711", "image_code": "// created by florian berger (flockaroo) - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// in memoriam Dusty Hill :-(\n//\n// zztop intro of \"gimme all your lovin\"\n//\n\n#define Res (iResolution.xy)\n\n#define notes_ 12.\n#define speaker_ 31.\n#define alpha_ 128.\n#define beta_ 129.\n#define gamma_ 130.\n#define psi_ 142.\n#define bo_ 40.\n#define bc_ 41.\n#define ebo_ 91.\n#define ebc_ 93.\n#define cbo_ 123.\n#define cbc_ 125.\n#define or_ 124.\n#define squared_ 178.\n#define space_ 32.\n#define div_ 47.\n#define A_ 65.\n#define B_ 66.\n#define C_ 67.\n#define D_ 68.\n#define E_ 69.\n#define F_ 70.\n#define G_ 71.\n#define H_ 72.\n#define I_ 73.\n#define J_ 74.\n#define K_ 75.\n#define L_ 76.\n#define M_ 77.\n#define N_ 78.\n#define O_ 79.\n#define P_ 80.\n#define Q_ 81.\n#define R_ 82.\n#define S_ 83.\n#define T_ 84.\n#define U_ 85.\n#define V_ 86.\n#define W_ 87.\n#define X_ 88.\n#define Y_ 89.\n#define Z_ 90.\n#define a_ (A_+32.)\n#define b_ (B_+32.)\n#define c_ (C_+32.)\n#define d_ (D_+32.)\n#define e_ (E_+32.)\n#define f_ (F_+32.)\n#define g_ (G_+32.)\n#define h_ (H_+32.)\n#define i_ (I_+32.)\n#define j_ (J_+32.)\n#define k_ (K_+32.)\n#define l_ (L_+32.)\n#define m_ (M_+32.)\n#define n_ (N_+32.)\n#define o_ (O_+32.)\n#define p_ (P_+32.)\n#define q_ (Q_+32.)\n#define r_ (R_+32.)\n#define s_ (S_+32.)\n#define t_ (T_+32.)\n#define u_ (U_+32.)\n#define v_ (V_+32.)\n#define w_ (W_+32.)\n#define x_ (X_+32.)\n#define y_ (Y_+32.)\n#define z_ (Z_+32.)\n\nfloat doffs=0.02;\n\nvoid writeChar(float x, float y, float s, vec3 color, float c, inout vec4 col, vec2 coord)\n{\n    vec2 res2=iChannelResolution[2].xy;\n    //float dist=texture(iChannel2,vec2(c/16.,mod(c,16.)/16.)).x;\n    //col=mix(vec4(1,1,0,1),col,clamp(dist*dist*dist,0.,1.));\n    float d=1000.;\n    if( coord.x>x && coord.y>y && coord.x<x+s && coord.y<y+s )\n    {\n        vec2 dc = coord-vec2(x,y);\n        dc.y=s-dc.y;\n        vec2 uv=\n            vec2(floor(mod(c,16.))/16.,floor(c/16.)/16.)\n            +dc/s/16.;\n        uv.y=1.-uv.y/*+1./16.*/;\n        d=min(d,texture(iChannel1,uv).w-.5);\n        //col=mix(col,1.*vec4(color,1),step(.1,texture(iChannel1,uv).w-.5));\n        //col+=vec4(0,1,0,1);\n    }\n    col=mix(col,1.*vec4(color,1),smoothstep(-0.01,0.01,-d+doffs));\n}\n\nvoid write(float x, float y, float s, vec3 color, mat4 txt,inout vec4 col, vec2 coord)\n{\n    for(int i=0;i<4;i++)\n    {\n    \tfor(int j=0;j<4;j++)\n    \t{\n            float c=txt[i][j];\n            if(c==0.) return;\n    \t\twriteChar(x,y,s,color,c,col,coord); x+=s*.5;\n        }\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = zztop((fragCoord-Res.xy*vec2(.5,.2))/Res.x*10., 1.);\n    \n    float sc=Res.x/600.;\n    write((8.+8.)*sc, (150.-5.)*sc, 64.*sc, vec3(.45,.0,.0), mat4(R_,I_,P_,space_, D_,u_,s_,t_, y_,space_,H_,i_, l_,l_,0,0 ),fragColor, fragCoord+vec2(-fragCoord.y*.3,0));\n    write(8.*sc, 150.*sc, 64.*sc, vec3(1,.8,0), mat4(R_,I_,P_,space_, D_,u_,s_,t_, y_,space_,H_,i_, l_,l_,0,0 ),fragColor, fragCoord+vec2(-fragCoord.y*.3,0));\n    \n    vec4 c=vec4(0);\n    //doffs=.035;\n    //write(20.*sc, 20.*sc, 50.*sc, vec3(1), mat4(notes_,space_,speaker_,0, 0,0,0,0, 0,0,0,0, 0,0,0,0 ),c,fragCoord);\n    doffs=.0;\n    write(Res.x-60.*sc, Res.y-60.*sc, 50.*sc, vec3(1), mat4(notes_,0.*space_,0.*speaker_,0, 0,0,0,0, 0,0,0,0, 0,0,0,0 ),c,fragCoord);\n\n    vec4 col2=texture(iChannel2,fragCoord/Res);\n    fragColor=mix(fragColor,col2*.9*vec4(.95,1,1.05,1),1.-clamp(fragColor.x*3.,0.,1.));\n    \n    fragColor += -.15*texelFetch(iChannel0,(ivec2(fragCoord)+iFrame/5*50)%256,0);\n    \n    fragColor+=.25*c;\n    \n    vec2 sco=fragCoord/Res-.5;\n    fragColor*=1.-dot(sco,sco);\n    \n\tfragColor.w=1.;\n}\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// created by florian berger (flockaroo) - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// in memoriam Dusty Hill :-(\n//\n// zztop intro of \"gimme all your lovin\"\n//\n\n#define T 2.7\n#define HT 1.059463094\n#define A4 (440.)\n#define B4 (440.*HT*HT)\n#define C4 (440.*HT*HT*HT)\n#define D4 (440.*HT*HT*HT*HT*HT)\n#define E4 (440.*HT*HT*HT*HT*HT*HT*HT)\n#define F4 (440.*HT*HT*HT*HT*HT*HT*HT*HT)\n#define G4 (440.*HT*HT*HT*HT*HT*HT*HT*HT*HT*HT)\n\n#define A0 (A4/16.)\n#define B0 (B4/16.)\n#define C0 (C4/16.)\n#define D0 (D4/16.)\n#define E0 (E4/16.)\n#define F0 (F4/16.)\n#define G0 (G4/16.)\n\n#define A1 (A4/8.)\n#define B1 (B4/8.)\n#define C1 (C4/8.)\n#define D1 (D4/8.)\n#define E1 (E4/8.)\n#define F1 (F4/8.)\n#define G1 (G4/8.)\n\n#define A2 (A4/4.)\n#define B2 (B4/4.)\n#define C2 (C4/4.)\n#define D2 (D4/4.)\n#define E2 (E4/4.)\n#define F2 (F4/4.)\n#define G2 (G4/4.)\n\n#define A3 (A4/2.)\n#define B3 (B4/2.)\n#define C3 (C4/2.)\n#define D3 (D4/2.)\n#define E3 (E4/2.)\n#define F3 (F4/2.)\n#define G3 (G4/2.)\n\n#define A5 (A4*2.)\n#define B5 (B4*2.)\n#define C5 (C4*2.)\n#define D5 (D4*2.)\n#define E5 (E4*2.)\n#define F5 (F4*2.)\n#define G5 (G4*2.)\n\nfloat rand2(float x){\n    //return 2.0*(texelFetch(iChannel0,i);\n    return fract(sin(mod(x*10.0,10.0)*12.9898)*43758.5453)*2.0-1.0;\n}\n\nfloat rand3(float x){\n    float y=0., sum=0.;\n    for(int i=0;i<30;i++) {  y+=cos((float(i))*x+float(i)*.1); sum+=1.; } \n    return y/sum;\n}\n\nfloat rand(float x){\n    x=fract(x);\n    int i=int(x*iSampleRate);\n    return texelFetch(iChannel0,ivec2(i%256,(i/256)%256),0).x-.5;\n}\n\nfloat AttackDecay(float t, float tau)\n{\n    return exp(-t/tau);\n}\n\nvec2 boing(float f, float t, float ph)\n{\n    if(t<0.0) return vec2(0.);\n\tfloat a = 50.0*( 1.0*sin(6.2831*(1.0  *f*t+ph))\n\t                +0.6*sin(6.2831*(1.975*f*t+ph))\n                    +0.3*sin(6.2831*(4.0  *f*t+ph))\n                   );\n\n    return vec2(\n        clamp(a*(exp(-8.0*t)+0.1*exp(-t*3.0)),-1.,1.)\n    );\n}\n\nvec2 brumm(float f, float t, float ph)\n{\n    if(t<0.0) return vec2(0.);\n\tfloat a = 50.0*( 0.6*sin(6.2831*(1.0  *f*t+ph))\n\t                +0.8*sin(6.2831*(1.975*f*t+ph))\n                    +0.4*sin(6.2831*(4.0  *f*t+ph))\n                   );\n\n    return vec2(\n        clamp(a*exp(-1.0*t),-1.,1.)\n    );\n}\n\nfloat fermi(float x)\n{\n    return 1./(1.+exp(x));\n}\n\nvec2 bbbbb(float f1, float f2, float t)\n{\n    // X       X       X       X\n    // a _ a a c a\n    return \n    \t  boing(f1,t-T*0./16.,.0)*fermi((t-T*2./16.)/0.01)\n        + boing(f1,t-T*2./16.,.0)*fermi((t-T*3./16.)/0.01)\n        + boing(f1,t-T*3./16.,.0)*fermi((t-T*4./16.)/0.01)\n        + boing(f2,t-T*4./16.,.4)*fermi((t-T*5./16.)/0.01)\n        + boing(f1,t-T*5./16.,.0);\n}\n\nvec2 tich(float f,float t)\n{\n    float c=0.;\n    float a=0.;\n    for( int i=-512; i<512; i++ )\n    { \n        float t2=float(i)/44000.0;\n        float w=float(128)/44000.0;\n        w=1.0/f;\n        float s=exp(-t2*t2/w/w)*t2/w;\n        //a+=rand(t-t2)*cos(-6.2831*f*(t-t2))*s; c+=s; \n        a+=rand(t-t2)*s; c+=s*s;\n    }\n    a/=sqrt(c);\n    //a=rand(t);\n    a*=(0.5+0.5*sin(2300.*t))*(0.8+0.2*sin(800.*t))*exp(-25.0*mod(t,T/16.));\n    return 1.0*vec2(clamp(a,-1.0,1.0));\n}\n\nvec2 bumm(float f,float t)\n{\n    if(t<0.0) return vec2(0.);\n    return 2.0*vec2(sin(6.2831*f*t)*exp(-18.0*t));\n}\n\nfloat feep(float f1, float f2,float t)\n{\n \tfloat a=clamp(sin(f1*t+1.5*sin(35.0*t)+8.0*sin(6.0*t))*2.0+0.15*rand(t),-1.0,1.0);\n \treturn clamp(a*exp(0.5*t-4.0)*(fermi((t-T*3.5)/T/0.15)),-1.0,1.0);\n}\n\n// iq's polynomial smooth min function\n/*float smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}*/\n\nfloat feep2Map(float t)\n{\n    return smin(t,0.689*(t-T*(3.5+0.05))+T*(3.5-0.05),0.3);\n}\n\nfloat chordMaj(float f, float oct, float t) // FIXME: not really a major chord yet\n{\n    f*=6.2831*pow(2.0,oct);\n    float a=(sin(f*t)+sin(3./2.*f*t)+sin(5./4.*f*t))+0.15*rand(t);\n \ta=clamp(sin(f*t+1.5*sin(35.0*t)+8.0*sin(6.0*t))*2.0+0.15*rand(t),-1.0,1.0);\n    //a=clamp(a*0.3,-1.0,1.0);\n    return a*exp(-t/3.0);\n}\n\n#define Git(fret,string) 110.*exp2((-5.+float(fret)+5.*float(string)-float(string/4))/12.)\n#define GitCont -1.\n#define Ch2(f1,s1,f2,s2) Git(f1,s1),Git(f2,s2)\n#define Ch2Cont -1.,-1.\n#define Ch3(f1,s1,f2,s2,f3,s3) Git(f1,s1),Git(f2,s2),Git(f3,s3)\n#define Ch3Cont -1.,-1.,-1.\n\n#define CHNUM 3\n\n#if CHNUM == 2\nconst float rythm[] = float[32](\nCh2Cont,\nCh2Cont,\nCh2Cont,\nCh2Cont,\nCh2Cont,\nCh2( 3,2, 5,3 ),\nCh2( 3,2, 5,3 ),\nCh2Cont,\nCh2( 3,2, 3,3 ),\nCh2Cont,\nCh2Cont,\nCh2( 3,1, 3,2 ),\nCh2Cont,\nCh2( 3,1, 5,2 ),\nCh2( 3,1, 5,2 ),\nCh2Cont\n);\n\n#else   \n\nconst float rythm[] = float[48](\nCh3( 3,1, 5,2, 5,3 ),\nCh3Cont,\nCh3Cont,\nCh3Cont,\nCh3Cont,\nCh3( 3,1, 3,2, 5,3 ),\nCh3( 3,1, 3,2, 5,3 ),\nCh3( 3,1, 3,2, 3,3 ),\nCh3( 3,1, 3,2, 3,3 ),\nCh3Cont,\nCh3( 3,1, 3,2, 5,3 ),\nCh3( 3,1, 3,2, 5,3 ),\nCh3Cont,\nCh3( 3,1, 5,2, 5,3 ),\nCh3( 3,1, 5,2, 5,3 ),\nCh3Cont\n);\n#endif   \n\nconst float solo[] = float[24](\nGit( 8,5),\nGit(11,4),\nGit( 8,4),\nGit(10,3),\nGit( 8,4),\nGit( 8,5),\nGit( 8,5),\nGitCont,\nGitCont,\nGitCont,\nGitCont,\nGitCont,\nGitCont,\nGitCont,\nGitCont,\nGitCont,\nGitCont,\nGitCont,\nGitCont,\nGitCont,\nGitCont,\nGitCont,\nGitCont,\nGitCont\n);\n\nfloat chordMin(float f, float oct, float t) // FIXME: not really a minor chord yet\n{\n    f*=6.2831*pow(2.0,oct);\n    float a=(sin(f*t)+sin(3./2.*f*t)+sin(5./4.*f*t))+0.15*rand(t);\n \ta=clamp(sin(f*t+1.5*sin(35.0*t)+8.0*sin(6.0*t))*2.0+0.15*rand(t),-1.0,1.0);\n    //a=clamp(a*0.3,-1.0,1.0);\n    return a*exp(-t/3.0);\n}\n\nfloat string(float freq, float t)\n{\n    float sum=0., s=0.;\n    freq*=1.57*4.;\n    for(float fm=1.;fm<10.;fm+=1.)\n    {\n        //float fact=sqrt(1./fm);\n        float fact=exp(-float(fm)/15.);\n    \ts+=sin(freq*fm*t)*fact;\n        sum+=fact;\n    }\n    return s/sum;\n}\n\nfloat overdrive(float a, float ovr)\n{\n    // transistor\n    //return clamp(a*ovr,-1.,1.);\n    // tube-ish\n    return sign(a)*(1.-exp(-abs(a)*ovr));\n}\n\nvec2 mainSound( int samp, float t )\n{\n    float t0=t;\n    float f1=0.01;\n    float s=0.;\n    float tact=2.;\n    t-=.5*tact;\n    float bumm1=(rand(f1*1.*t)+.5*rand(f1*10.*t)+.3*rand(f1*100.*t));\n    float bumm2=(rand(f1*2.*t)+.5*rand(f1*20.*t)+.3*rand(f1*100.*t));\n    s+=.5*bumm1*AttackDecay(mod(t+ tact* 0.,tact/2.),.05);\n    s+=1.*bumm2*AttackDecay(mod(t+ tact/ 4.,tact/2.),.05);\n    s+=1.*bumm2*AttackDecay(mod(t+ tact/ 8.,tact*2.),.05);\n    s+=1.*bumm2*AttackDecay(mod(t+ tact/16.,tact*2.),.05);\n    s+=.25*rand(f1*100.*t)*AttackDecay(mod(t+ tact* 0.,tact/8.),.08);\n    int n[16] = int[](-100, 6, 7, 0, -100, 9, 9, 9, 10, -100, 10, 9, -100, 7, 7, -100);\t\n    t=t0;\n    \n    float s1=0.;\n    int actTact4=int(t/tact*8.);\n    int actTact3=int(t/tact*8.*3./2.);\n\n    for(int i=0;i<2;i++)\n    {\n    int note=n[(actTact4-i)%16];\n    float nStart=(float(actTact4-i)*tact/8.);\n    float amp=1.;\n    if(note==-100) { note=n[actTact4-i-1]; nStart-=tact/8.; }\n    if(note==-100) { note=n[actTact4-i-2]; nStart-=tact/8.; }\n    //s=0.;\n    float key=110.*exp2(3./12.);\n    if(t>tact*4.)\n    s1 += amp*string(key*exp2(float(note)/12.),t)*exp(-(t-nStart)/.3);\n    }\n    //s1= 1.-exp(-s1*3.);\n\n    float ryth=0.;\n    for(int j=0;j<CHNUM;j++)\n    for(int i=0;i<1;i++)\n    {\n        int idx=(actTact4-i)%16;\n    float f=rythm[idx*CHNUM+j];\n    float nStart=(float(actTact4-i)*tact/8.);\n    float amp=1.;\n    for(int k=0;k<20;k++) { if(f==-1.) { idx=(idx-1)%16; f=rythm[idx*CHNUM+j]; nStart-=tact/8.; } }\n    //if(f==-1.) { idx=(idx-1)%16; f=rythm[idx*2+j]; nStart-=tact/4.; }\n    //if(f==-1.) { idx=(idx-1)%16; f=rythm[idx*2+j]; nStart-=tact/4.; }\n    if(t>tact*4.+1.)\n    ryth += amp*clamp(string(f,t),-.25,.25)*exp(-(t-nStart)/.3);\n    }\n    ryth = overdrive(1.*ryth+2.*s1,50.);\n\n    float sol=0.;\n    {\n    int i=0;\n    int idx=(actTact3-i)%24;\n    float f=solo[idx];\n    float nStart=(float(actTact3-i)*tact/8.*2./3.);\n    float amp=1.;\n    for(int j=0;j<20;j++) { if(f==-1.) { idx=(idx-1)%24; f=solo[idx]; nStart-=tact/8.*2./3.; } }\n    if(t>tact*4.+1.)\n    sol += amp*string(f,t+.001*(sin(t*12.)+.5))*exp(-(t-nStart)/1.);\n    }\n    sol = overdrive(sol,10.);\n\n    \n    //s = sin(key*1.57*4.*t);\n    //s=rand(t);\n    return vec2(s*1.+ryth*.25+sol*.25);\n}\n", "sound_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// zztop ford eliminator\n\n// helper functions\n\n//uncomment to precalc logo as texture\n//#define ZZT_AS_TEX\n\n#define PI2 6.283185\n\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n\nvec3 getLightDir() { return normalize(1.*vec3(cos(1.+/*iTime+*/vec2(0,1.6)),.81)); }\n\nvec2 scuv(vec2 uv) {\n    float zoom=1.;\n    return (uv-.5)*1.2*zoom+.5; \n}\n\nvec2 uvSmooth(vec2 uv,vec2 res)\n{\n    // no interpolation\n    //return uv;\n    // sinus interpolation\n    return uv+1.*sin(uv*res*PI2)/(res*PI2);\n    // iq's polynomial interpolation\n    vec2 f = fract(uv*res);\n    return (uv*res+.5-f+3.*f*f-2.0*f*f*f)/res;\n}\n\nvec4 inverseQuat(vec4 q)\n{\n    //return vec4(-q.xyz,q.w)/length(q);\n    // if already normalized this is enough\n    return vec4(-q.xyz,q.w);\n}\n\nvec4 multQuat(vec4 a, vec4 b)\n{\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return (v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v ));\n}\n\nvec4 angVec2Quat(vec3 ang)\n{\n    float lang=length(ang);\n    return vec4(ang/lang,1) * sin(vec2(lang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\nvec4 axAng2Quat(vec3 ax, float ang)\n{\n    return vec4(normalize(ax),1)*sin(vec2(ang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\n/////////////// iq's distance funs\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - (b-r);\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdRoundRect( vec2 p, vec2 b, float r )\n{\n  vec2 q = abs(p) - (b-r);\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\nvec2 sdRoundRect2( vec4 p, vec4 b, vec2 r )  // variation - eval 2 boxes at once\n{\n  vec4 q = abs(p) - (b-r.xxyy);\n  vec4 qp=max(q,0.0);\n  return sqrt(qp.xz*qp.xz+qp.yw*qp.yw) + min(max(q.xz,q.yw),vec2(0)) - r;\n}\n\nfloat sdHalfRoundBox( vec3 p, vec3 b, float r )   // variation - clamped box\n{\n  vec3 q = abs(p) - (b-r);\n  return max((length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r),-p.z);\n}\n\nfloat sdRoundedCylinder( vec3 p, float R, float r, float h )\n{\n  vec2 d = vec2( length(p.xz)-R, abs(p.y) - h*.5 );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n}\n\nfloat distTorus(vec3 p, float R, float r)\n{\n    return length(p-vec3(normalize(p.xy),0)*R)-r;\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n  // c is the sin/cos of the angle\n  float q = length(p.xy);\n  return dot(c,vec2(q,p.z));\n}\n\nfloat dDirLine(vec3 p, vec3 c, vec3 dir, float l)\n{\n    p-=c;\n    dir=normalize(dir);\n    float dp=dot(p,dir);\n    //return length(p-dp*dir);\n    return max(max(length(p-dp*dir),-dp),dp-l);\n}\n\n// iq's exponantial smooth-min func\nfloat smin( float a, float b, float k )\n{\n    k=3./k;\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n// iq's polynomial smooth-min func\nfloat smin_( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n#if 0\nbool intersectBox(vec3 p, vec3 dir, vec3 size)\n{\n    //vec3 n=cross(cross(dir,p),dir);\n    //return length(p-dot(p,n)*n/dot(n,n))<size.y;\n\n    //return true;\n    \n    size*=.5;\n    float tmin, tmax, tymin, tymax, tzmin, tzmax; \n    \n    vec3 s=sign(dir);\n    vec3 invdir=1./dir;\n\n    tmin  = (-size.x*s.x - p.x) * invdir.x; \n    tmax  = ( size.x*s.x - p.x) * invdir.x; \n    tymin = (-size.y*s.y - p.y) * invdir.y; \n    tymax = ( size.y*s.y - p.y) * invdir.y; \n \n    if ((tmin > tymax) || (tymin > tmax)) return false; \n    if (tymin > tmin) tmin = tymin; \n    if (tymax < tmax) tmax = tymax; \n \n    tzmin = (-size.z*s.z - p.z) * invdir.z; \n    tzmax = ( size.z*s.z - p.z) * invdir.z; \n \n    if ((tmin > tzmax) || (tzmin > tmax)) return false; \n    if (tzmin > tmin) tmin = tzmin; \n    if (tzmax < tmax) tmax = tzmax; \n \n    return true; \n}\n#endif\nbool intersectBox(vec3 p, vec3 dir, vec3 size)\n{\n    size*=.5*sign(dir);\n\n    vec3 vmin = (-size-p)/dir;\n    vec3 vmax = ( size-p)/dir;\n    \n    float tmin=vmin.x, tmax=vmax.x;\n    \n    if ((tmin > vmax.y) || (vmin.y > tmax)) return false; \n    tmin=max(tmin,vmin.y);\n    tmax=min(tmax,vmax.y);\n \n    if ((tmin > vmax.z) || (vmin.z > tmax)) return false; \n    tmin=max(tmin,vmin.z);\n    tmax=min(tmax,vmax.z);\n \n    return true; \n}\n\nfloat zmask(vec2 p)\n{\n    float skew=1.;\n    p.x += skew*p.y;\n    return step(p.y,step(-.35,p.x)-.5+.1)\n          -step(p.y,step( .35,p.x)-.5-.1);\n}\n\nvec4 zztop(vec2 p, float s_)\n{\n    float s=-1.;\n    p.x=-p.x;\n    vec2 p0=p;\n    p0*=-s_;\n    float s1=step(-12.6+2.9+2.9*s,-s_*((p.x)+s*.17*p0.y));\n    float z1 = zmask(p0+vec2(.25,.1))*step(-3.5,-p0.x-p0.y)*s1;\n    float d1=-.25*p.y+z1;\n    float z2 = zmask(p0-vec2(.25,.1))*step(-6.,-p0.x-p0.y)*s1;\n    float d2=.25*p.y+z2;\n    float bgm=step(0.,-s_*s*p.x)*step(-.7,-abs(p.y));\n    p.y=abs(p.y);\n    bgm=max(bgm,step(.5,exp(-(p.y-.8)*(p.y-.8)/.017)));\n    bgm*=step(-29.,-s_*(s*(p.x)-30.*p0.y));\n    bgm*=step(-15.,-s_*(s*(p.x)+15.*p0.y));\n    bgm*=step(-12.75,-s_*(-s*(p.x)-.17*p0.y));\n    bgm=0.;\n    vec4 bg=vec4(.5);\n    bg=clamp(bg,0.,1.);\n    vec4 col=vec4(.5,0,0,1);\n    if(d2<d1) col=vec4(1,.8,0,1);\n    col = mix(vec4(vec3(.8,0,.2)*0.,1),col,max(z1,z2));\n    col.w=max(bgm,max(z1,z2));\n    return col;\n}\n\n", "buffer_a_code": "// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// zztop ford eliminator\n\n//#define RENDERED_REFECTIONS\n#define SHADOW\n#define SCRATCHES\n//#define STREET\n#define RENDER_GLASS\n//#define WET_ASPHALT\n//#define RENDER_BBOX\n#define RUMPFW 1.3\n#define ALLW (RUMPFW*1.3)\n\n#define Res  (iResolution.xy)\n\n#define RandTex iChannel0\n\n#ifdef SHADEROO\n#include Include_A.glsl\n#endif\n\n#define BG 0.\n#define CARBODY 1.\n#define TIRE 2.\n#define RIM 3.\n#define HEADLIGHTS 4.\n#define FLOOR 5.\n#define GRILL 6.\n#define RUMPF 7.\n#define INTERIOR 8.\n#define GLASS 9.\n#define WATER 10.\n#define CHASSIS 11.\n#define GUMMI 12.\n#define DESERT 13.\n\n//#define SET_PREV_MAT(x) mat=(abs(d-d_mat)>.0001)?(x):mat; d_mat=d;\n//#define SET_PREV_MAT(x) mat=mix(mat,x,step(.0001,abs(d-d_mat))); d_mat=d;\n//#define SET_PREV_MAT(x) mat+=step(.0001,abs(d-d_mat))*(-mat+x); d_mat=d;\n#define SET_PREV_MAT(x) if(abs(d-d_mat)>.0001) mat=(x); d_mat=d;\n\nstruct Material{\n    vec3 col;\n    float refl;\n    float scratchy;\n    vec2  scratchScale;\n};\n\n#define MAT_BG         Material(vec3(-1,-1,-1),       -1.,   0.0, vec2(1,.01))\n#define MAT_CARBODY    Material(vec3(.8, .05, .1),    -1.,   0.6, vec2(1,.01))\n#define MAT_TIRE       Material(vec3(.15,.15,.15),    -0.35, 1.0, vec2(1,.1)*.3)\n#define MAT_RIM        Material(vec3(1,1,1),           1.,   0.2, vec2(1,.01))\n#define MAT_HEADLIGHTS Material(vec3(.8),              1.,   0.2, vec2(1,.01))\n#ifdef WET_ASPHALT\n#define MAT_FLOOR      Material(vec3(.35),            -0.05, 0.0, vec2(1,.01))\n#else\n#define MAT_FLOOR      Material(vec3(.36,.35,.34)*1.2,            -0.2, 0.0, vec2(1,.01))\n#endif\n#define MAT_GRILL      Material(vec3(.8),              1.,   0.1, vec2(1,.1))\n#define MAT_RUMPF      Material(vec3(.8, .05, .1),    -1.,   0.6, vec2(1,.01))\n#define MAT_INTERIOR   Material(vec3(.9,.7,.5)*.3,    -0.0,  0.0, vec2(1,.01))\n#define MAT_GLASS      Material(vec3(1),              -1.,   0.6, vec2(1,.01))\n#define MAT_WATER      Material(vec3(.1),             -1.,   0.0, vec2(1,.01))\n#define MAT_CHASSIS    Material(vec3(.4),              0.5,  1.0, vec2(1,.01)*.5)\n#define MAT_GUMMI      Material(vec3(.3),             -0.1,  1.0, vec2(1,.01))\n#define MAT_DESERT     Material(vec3(.58,.55,.53)*.85,-0.2,  0.0, vec2(1,.01))\n\n#define USE_MTL_ARRAY \n#ifdef USE_MTL_ARRAY\nconst Material mat[14] = Material[] (\nMAT_BG        ,\nMAT_CARBODY   ,\nMAT_TIRE      ,\nMAT_RIM       ,\nMAT_HEADLIGHTS,\nMAT_FLOOR     ,\nMAT_GRILL     ,\nMAT_RUMPF     ,\nMAT_INTERIOR  ,\nMAT_GLASS     ,\nMAT_WATER     ,\nMAT_CHASSIS   ,\nMAT_GUMMI     ,\nMAT_DESERT\n);\nMaterial getMaterial(float mtl) { return mat[int(mtl)]; }\n#else\nMaterial getMaterial(float mtl)\n{\n    if(mtl==BG)           return MAT_BG        ;\n    if(mtl==CARBODY)      return MAT_CARBODY   ;\n    if(mtl==TIRE)         return MAT_TIRE      ;\n    if(mtl==RIM)          return MAT_RIM       ;\n    if(mtl==HEADLIGHTS)   return MAT_HEADLIGHTS;\n    if(mtl==FLOOR)        return MAT_FLOOR     ;\n    if(mtl==GRILL)        return MAT_GRILL     ;\n    if(mtl==RUMPF)        return MAT_RUMPF     ;\n    if(mtl==INTERIOR)     return MAT_INTERIOR  ;\n    if(mtl==GLASS)        return MAT_GLASS     ;\n    if(mtl==WATER)        return MAT_WATER     ;\n    if(mtl==CHASSIS)      return MAT_CHASSIS   ;\n    if(mtl==GUMMI)        return MAT_GUMMI     ;\n    if(mtl==DESERT)       return MAT_DESERT    ;\n}\n#endif\n\nbool enable_glass=true;\n\n#ifndef RandTex \n#define RandTex iChannel1\n#endif\n\nvec4 getRand(vec2 coord)\n{\n    vec4 c=vec4(0);\n    c+=texture(RandTex,coord+.003*iTime);\n    c+=texture(RandTex,coord/2.+.003*iTime)*2.;\n    c+=texture(RandTex,coord/4.+.003*iTime)*4.;\n    c+=texture(RandTex,coord/8.+.003*iTime)*8.;\n    return c/(1.+2.+4.+8.);\n}\n\n#define FloorZ -.66\n//#define HomePos vec3(0,0,-FloorZ*1.5)\n//#define CamDist0 18.\n\n// envoronment just a sky and some floor grid...\nvec4 myenv(vec3 pos, vec3 dir, float period_)\n{\n    vec3 sun = normalize(getLightDir());\n    vec3 skyPos=pos+dir/abs(dir.z)*(120.-pos.z);\n    float cloudPat=(1.+.4*(getRand(skyPos.xy*.0002).x-.5));\n    vec3 colHor=vec3(.3,.4,.5)+.4;\n    float dirl=dot(dir,sun);\n    vec3 clouds=mix(vec3(1.)*(1.-2.*dirl),vec3(.8,1.,1.2),cloudPat);\n    vec3 colSky=mix(vec3(1.5,.75,0.)*3.,clouds,clamp(7.*dir.z,0.,1.));\n    vec3 colFloor=vec3(.45);\n    \n    vec3 col=mix(colSky,colFloor,1.-smoothstep(-.01,.01,dir.z));\n    col=mix(colHor,col,clamp(abs(dir.z*5.)-.1,0.,1.));\n    \n    col*=.9;\n    \n    //float sunang=acos(dot(dir,sun));\n    float sunang=atan(length(cross(dir,sun)),dot(dir,sun));\n    col+=15.*clamp(2.*exp(-sunang/.02),0.,1.);\n    col+=2.*clamp(2.*exp(-sunang/.20),0.,1.);\n    \n    return vec4(col,1);\n}\n\n\nfloat distTire(vec3 p, float r)\n{\n    p=abs(p);\n    float d=1000.;\n    d=min(d,length(p)-r);\n    d=max(d,distTorus(p.yzx,r*.75,r*.38));\n    d=max(d,-length(p.yz)+r*.61);\n    float dx=.07;\n    float xfr=mod(p.x,dx);\n    float x=p.x-xfr+dx*.5;\n    d=max(d,-distTorus(p.yzx-vec3(0,0,x),sqrt(r*r-x*x),.015));\n    return d;\n}\nfloat distRim(vec3 p, float r)\n{\n    r*=.6;\n    p=abs(p);\n    p=p.zxy;\n    float d=1000.;\n    d=min(d,sdRoundedCylinder(p,r,.01,1.1*r));\n    p-=vec3(0,.6*r,0);\n    d=-smin(-d,sdRoundedCylinder(p,.97*r,.01,.1*r),.005);\n    d=-smin(-d,sdRoundedCylinder(p,.89*r,.01,.4*r),.005);\n    d=-smin(-d,sdRoundedCylinder(p,.77*r,.01,.8*r),.005);\n    d=min(d,sdCone(p.xzy-vec3(0,0,-.2*r),cos(1.1-vec2(0,1.57))));\n    float mang,ang;\n    float ang0 = atan(p.z,p.x);\n    mang=mod(ang0,PI2/12.);\n    ang=ang0-mang+PI2/12.*.5;\n    d=-smin(-d,(length(p.xz-.58*r*cos(ang-vec2(0,1.57)))-.1*r),.005);\n    mang=mod(ang0,PI2/24.);\n    ang=ang0-mang+PI2/24.*.5;\n    d=min(d,max(abs(p.y+.6*r)-.22*r,(length(p.xz-.73*r*cos(ang-vec2(0,1.57)))-.035*r)));\n    return d;\n}\n\nconst vec3 bbpos=vec3(0,-.06,.07);\nconst vec3 bbsize=vec3(ALLW*1.12,3.63,1.5);\nconst vec3 bbpos1=vec3(0,-.0,-.11);\nconst vec3 bbsize1=vec3(ALLW*1.12,3.73,1.13);\nconst vec3 bbpos2=vec3(0,.23,.47);\nconst vec3 bbsize2=vec3(ALLW*.83,1.25,.7);\n\nfloat rille2(float d, float w)\n{ \n    return w*exp2(-d*d*2./w/w);\n}\nfloat rille(float d, float w)\n{\n    ///// gauss\n    //return w*exp2(-d*d*2./w/w);\n    ///// exp\n    return w*exp2(-abs(d)*1.44/w);\n    ///// linear\n    //return max(abs(d)-w,0.);\n}\n\n#define USE_SIMDATA\n#ifdef USE_SIMDATA\n#define SteerAng (texelFetch(iChannel1,ivec2(4,0),0).x)\n#define WheelRot (texelFetch(iChannel1,ivec2(5,0),0))\n#define CamDistFact (texelFetch(iChannel1,ivec2(4,0),0).y)\n#else\nuniform float SteerAng;\nconst vec4 WheelRot=vec4(0);\n#define CamDistFact 1.0\n#endif\n\nvec2 distCar(vec3 p)\n{\n    vec3 p0rot=p;\n    p=transformVecByQuat(p,axAng2Quat(vec3(1,0,0),-.023));\n    float d=1000., d_mat=1001., mat=-1.;\n    SET_PREV_MAT(BG);\n    p*=2.;\n    if(p.x<0.) p.x=-p.x;\n    vec3 p0=p;\n    //d=min(d,length(p)-.5);\n    p=p0+vec3(0,.1,0);\n    float drumpf=sdRoundBox( p, vec3(RUMPFW+p.y*.15-p.y*p.y*.04+p.z*p.y*.03, \n                                 3.2-p.z*.3+p.z*p.z*.1 - step(0.,-p.y)*p.x*.3-step(0.,p.y)*.4*p.z, \n                                 .8+p.y*.02-p.x*p.x*.05*(1.+.01*(p.y*p.y*p.y*p.y))),\n                             max(p.y*.04,mix(.25+p.y*.05,.07,-p.z*1.5+.5)))*.7;\n    p=p0-vec3(0,.5,.87);\n    float dcabin = sdRoundBox( p, vec3(RUMPFW*1.05+p.y*.07-p.y*p.y*.08+p.z*.0, \n                                       1.2-p.z*.3,\n                                       .7+p.y*.07-p.x*p.x*.05-p.y*p.y*.05),\n                               .33+.15*p.y )*.7;\n    d=min(d,dcabin);\n    // rear front screen\n    p=p0-vec3(0,.4,.88+.10-.06*p.x*p.x);\n    //float dfrontscr=sdRoundBox( p, vec3(RUMPFW*.4-step(0.,p.y)*.2,2.,.1-step(0.,p.y)*.03)*2., .1 )*.7;\n    // only 2d needed - not sure if rect is faster - maybe some compilers can optimize something out...\n    float sy=step(0.,p.y);\n    float dfrontscr=sdRoundRect( p.xz-vec2(0,sy*.1), vec2(RUMPFW*.4-sy*.2,.14-step(0.,p.y)*.07)*2., .14-sy*.04 )*.7;\n    dfrontscr=max(dfrontscr,-(drumpf-.07));\n    d=-smin(-d,dfrontscr,.03);\n    //d+=rille(dfrontscr-.03,.007);\n    // side screens\n    p=p0-vec3(0,.23,.96);\n    vec3 sidebox=vec3(2.,.35-p.z*.1,.105+p.y*.008-.05*p.y*p.y*step(0.,p.z))*2.;\n    //float dsidescr=sdRoundBox( p-vec3(0,.1*p.z,.015*p.y), sidebox, .13+.04*p.y )*.7;\n#if 0\n    float dsidescr=sdRoundRect( p.yz-vec2(.1*p.z,.015*p.y), sidebox.yz, .13+.04*p.y )*.7;\n    //p.z+=.25;\n    //float ddoor   =sdRoundBox( p-vec3(0,.1*p.z,.015*p.y)+vec3(0,0,.59), sidebox+vec3(0,0,.59), .13+.04*p.y )*.7;\n    float ddoor   =sdRoundRect( p.yz-vec2(.1*p.z,.015*p.y)+vec2(0,.59), sidebox.yz+vec2(0,.59), .13+.04*p.y )*.7;\n#else\n    // not sure if even making 2 rects at once is really faster...\n    vec2 dssdoor=sdRoundRect2( (p.yz-vec2(.1*p.z,.015*p.y)).xyxy+vec4(0,0,0,.59), sidebox.yzyz+vec4(0,0,0,.59), vec2(.13+.04*p.y) )*.7;\n    float dsidescr=dssdoor.x;\n    float ddoor=dssdoor.y;\n#endif\n    ddoor-=.07;\n    p=p0-vec3(0,-2.05,.77)*1.;\n    p=transformVecByQuat(p-vec3(0,p.x*.25,0),axAng2Quat(vec3(1,0,0),.28));\n    //float dhood   =sdRoundBox( p,vec3(ALLW,.9,1.),.18)*.7;\n    float dhood   =sdRoundRect( p.yz,vec2(.9,1.),.18)*.7;\n    d=-smin(-d,dsidescr,.05);\n    //d=-smin(-d,abs(dsidescr-.03),.02);\n    d-=clamp((abs(dsidescr-.03)-.016)*.2,-0.02,0.);\n    p=p0;\n    p-=vec3(0,0,-.77);\n    float dz1=.5*(cos(p.x*4./ALLW)-1.)*(cos(p.y*1.5-2.-step(2.86,-p.y)*.8*(p.y+2.86)*(p.y+2.86))*.4+.4)*step(.766,-p.y);\n    float dz2=.5*(cos(p.x*3.3/ALLW)-1.)*clamp((cos(p.y*.6-1.5)*2.5-2.)*1.7,0.,1.);\n    p.z+=dz1+dz2;\n    p-=vec3(0,-.07,0);\n    //float dfender = sdHalfRoundBox( p, vec3(ALLW+p.y*.05,\n    //                            3.5-.12*cos(p.x*p.x*3.3/ALLW*(.85+.15*step(0.,-p.y)))*(.3+.7*step(0.,-p.y)),.16),\n    //                            .16 )*.7;\n    float dfender = sdRoundBox( p-vec3(0,0,-.3), vec3(ALLW+p.y*.05,\n                                3.5-.1*cos(p.x*p.x*3.3/ALLW*(.85+.15*step(0.,-p.y)))*(.3+.7*step(0.,-p.y)),.16+.3),\n                                .16 )*.7;\n    float ss=1.-smoothstep(-3.,-1.8,p.y);\n    float fz0=p.z-dz1*(exp2(-ss*7.));\n    dfender=min(dfender,(sqrt(dfender*dfender+fz0*fz0)-.01)*.7);\n    dfender=max(dfender,-(fz0)*.7);\n    d=min(d,dfender);\n    SET_PREV_MAT(CARBODY);\n    //drumpf-=clamp(abs(dhood)-.005,-0.02,0.);\n    drumpf+=rille(dhood,.005);\n    //side stripe\n    p=p0+vec3(0,.1,0);\n    drumpf-=.6*rille2(p.z-.4+.03*p.y-.1*p.x,.02)*(1.-smoothstep(2.4,2.6,abs(p0.y+.3)));\n    //*clamp((abs(p.z-.55)-.02)*.5,-0.02,0.);\n    d=smin(d,drumpf,.03);\n    //d=-smin(-d,abs(ddoor),.01);\n    //d-=clamp(abs(ddoor)-.005,-0.02,0.);\n    d+=rille(ddoor,.005);\n    SET_PREV_MAT(RUMPF);\n    d=min(d,dfender+.01-.03*smoothstep(-1.45,-1.4,-p0.y)*smoothstep(-.95,-.9,p0.y));\n    SET_PREV_MAT(TIRE);\n    d=min(d,step(0.,p.y)+length(vec2(dfrontscr-.01,dcabin+.01))-.015);\n    SET_PREV_MAT(GUMMI);\n    d=min(d,step(0.,p.y)+length(vec2(dfrontscr-.02,dcabin+.01))-.02);\n    SET_PREV_MAT(GRILL);\n    float z=p.z+.2;\n    float dgrillhole=sdRoundBox( p-vec3(0,-3.,-.02), vec3(.18*.9*RUMPFW-step(0.,-z)*z*z*.58*RUMPFW,.5,.33)*2., .1 );\n    d=-smin(-d,dgrillhole,.04);\n    SET_PREV_MAT(CARBODY);\n    //SET_PREV_MAT(TIRE);\n\n    p=p0-vec3( 0, -3.26+.3*p.z+.35*p.x-.1*p.z*p.z, 0);\n    p.x=mod(p.x+.005,.025)-.0125;\n    d=min(d,max(dgrillhole,(length(p.xy)-.007)*.8));\n    SET_PREV_MAT(GRILL);\n\n    p=p0-vec3(0,.7,.87-.2);\n    d=max(d,-dcabin-.06);\n    SET_PREV_MAT(INTERIOR);\n    \n#ifdef RENDER_GLASS\n    // window glass\n    //if(enable_glass)\n    {\n        d=min(d,dcabin+.035+(enable_glass?0.:1000.));\n        SET_PREV_MAT(GLASS);\n    }\n#endif\n    \n    #define PF (vec3(ALLW*.39,-1.43,-.33)*2.)\n    #define PR (vec3(ALLW*.48,1.23,-.35)*2.)\n    vec3 pf=p0-PF;\n    vec3 pr=p0-PR;\n    \n    // check tire only once\n    //bool rear = (dot(pr,pr)<dot(pf,pf));\n    float rear = step(0.,p0rot.y);\n    float left = step(0.,p0rot.x);\n    float leftSgn=sign(p0rot.x);\n    p=mix(pf,pr,rear); float siz=mix(.62,.7,rear);\n    \n    // steering rotation of front wheels\n    vec4 q=axAng2Quat(vec3(0,0,1),leftSgn*(1.-.1*leftSgn*sign(SteerAng))*SteerAng*(1.-rear));\n#if 0\n    p+=vec3(.07,0,0);\n    p = (p + 2.0 * cross( q.xyz, cross( q.xyz, p ) + q.w*p ));\n    p-=vec3(.07,0,0);\n#else\n    // the above is exactly this below... why is this not working... bug in nvidia pipeline?! or am i missing sth here??\n    p=transformVecByQuat(p+vec3(.07,0,0),q)-vec3(.07,0,0);\n#endif\n\n#ifdef USE_SIMDATA\n    float rot=WheelRot.x;\n    p=transformVecByQuat(p,axAng2Quat(vec3(1,0,0),rot));\n#endif\n\n    d=min(d, distTire(p,siz));\n    SET_PREV_MAT(TIRE);\n    d=min(d, distRim(p,siz));\n    SET_PREV_MAT(RIM);\n    \n    p=p0;\n    float xx=p.x*p.x;\n    p=pf+vec3(ALLW*.38,0,+.1-xx*.03-step(ALLW*.6,p.x)*(p.x-ALLW*.6)*.3)*2.;\n    d=min(d,max(length(p.yz)-.05,p.x-ALLW*.7));\n    d=min(d,dDirLine(pf,vec3(-.4,-.1,-.1),vec3(-1,0,1.5),.5)-.04);\n    d=min(d,dDirLine(pf,vec3(-.3,.1,-.14),vec3(-.0,1,0.05),1.5)-.02);\n    SET_PREV_MAT(CHASSIS);\n    \n    p=p0-vec3(.37,-1.57,0.1)*2.;\n    float d1=1000.;\n    d1=min(d1, length(p)-.11*2.1);\n    d1=-smin(-d1, (length(p+vec3(0,.35,0))-.17*2.1),.02);\n    d=min(d,d1);\n    SET_PREV_MAT(HEADLIGHTS);\n    \n    #ifdef RENDER_BBOX\n    //if(enable_glass)\n    {\n        p=p0;\n        d=min(d,abs(sdRoundBox( p0rot-bbpos1, bbsize1*.5, .0))+(enable_glass?0.:1000.));\n        d=min(d,abs(sdRoundBox( p0rot-bbpos2, bbsize2*.5, .0))+(enable_glass?0.:1000.));\n        SET_PREV_MAT(GLASS);\n    }\n    #endif\n    \n    return vec2(d*.5,mat);\n}\n\nbool enable_car=true;\n\nfloat lorentz(float x) { return 1./(1.+x*x); }\n\n#define RND_SC 1.\nfloat hTerr(vec3 p)\n{\n    vec4 rTerr=.8*textureLod(iChannel0,p.xy*.00006*RND_SC,0.)+.4*textureLod(iChannel0,p.xy*.00012*RND_SC,0.);\n    float pp=dot(p.xy,p.xy)/(200.*200.);\n    return rTerr.x*min(pp*pp,40.);\n}\n\nvec4 getTiltQuat(vec3 pos)\n{\n    float h0 =hTerr(pos);\n    vec2  dh=vec2(hTerr(pos+vec3(2,0,0))-h0,\n    \t\t\t  hTerr(pos+vec3(0,2,0))-h0)*.5;\n    \n    //return axAng2Quat(normalize(vec3(dh.y,-dh.x,0)),atan(length(dh)));\n    // same as above axAng2Quat(...) - but less angle back/forth conversions\n    float ch = sqrt(.5+.5/sqrt(1.+dot(dh,dh)));      // cos(ang/2)\n    return vec4(vec3(dh.y,-dh.x,0)*(ch-.5/ch),ch);  // (ch-.5/ch) == sin(ang/2)/tan(ang);\n}\n\nvec3 carTrafo(vec3 p, float translate)\n{\n#ifdef USE_SIMDATA\n    vec4 q=texelFetch(iChannel1,ivec2(3,0),0);\n    vec3 offs=texelFetch(iChannel1,ivec2(0,0),0).xyz;\n    offs.z=-hTerr(-offs);\n    q=multQuat(getTiltQuat(-offs),q);\n    return transformVecByQuat(p+translate*offs,inverseQuat(q));\n#else\n    return p;\n#endif\n}\n\nvec3 carTrafo(vec3 p)\n{\n    return carTrafo(p,1.0);\n}\n\nvec3 carTrafoInv(vec3 p, float translate)\n{\n#ifdef USE_SIMDATA\n    vec4 q=texelFetch(iChannel1,ivec2(3,0),0);\n    vec3 offs=texelFetch(iChannel1,ivec2(0,0),0).xyz;\n    offs.z=-hTerr(-offs);\n    q=multQuat(getTiltQuat(-offs),q);\n    return transformVecByQuat(p,q)-offs*translate;\n#else\n    return p;\n#endif\n}\n\nvec2 distM(vec3 p)\n{\n    float d=1000., mat=-1., d_mat=d;\n    if(enable_car)\n    {\n        vec2 dm=distCar(carTrafo(p));\n        d=dm.x; mat=dm.y; d_mat=d;\n    }\n    vec4 r=texture(iChannel0,p.xy*1.5*RND_SC,0.)-.5;\n    vec4 r2=texture(iChannel0,(p.xy*.005*RND_SC),-.5)-.5;\n    vec4 r3=texture(iChannel0,(p.xy*.015*RND_SC),-.0)-.5;\n    vec4 r4=texture(iChannel0,(p.xy*.03*RND_SC),-.0)-.5;\n    vec4 r5=texture(iChannel0,(p.xy*.06*RND_SC),-.0)-.5;\n    float rm=r3.y*1.+r4.y*.5+r5.y*.25;\n    float rm2=r3.z*.7+r4.z*.5;\n    float pp=dot(p.xy,p.xy)/(200.*200.);\n    #ifdef STREET\n    float streetstep=smoothstep(4.5,5.5,abs(p.x-2.));\n    #else\n    float streetstep=0.;\n    #endif\n    d=min(d,p.z\n    +.66\n    #ifndef STREET\n    -hTerr(p)\n    #endif\n    //+.015*(r3.y-.2)\n    #ifdef WET_ASPHALT\n    +lorentz(-rm/.06/r2.x)*.05*(r2.x+.3)\n    #else\n    -.02-min(-abs(rm)*.06,.04-exp(-abs(rm/(r2.x+.15)*.25)*3.)*.07)-r.x*.0035\n    #endif\n    );\n    SET_PREV_MAT(FLOOR);\n    \n    #ifdef STREET\n    d=min(d,p.z\n    +.73\n    +r2.z*.1+r.z*.01\n    -streetstep*.2\n    -hTerr(p)\n    );\n    SET_PREV_MAT(DESERT);\n    #endif\n    #ifdef WET_ASPHALT\n    d=min(d,p.z+.665+pp*16./*-.02*/);\n    SET_PREV_MAT(WATER);\n    if(mat==FLOOR) d-=r.x*.0035;\n    #endif\n    \n    return vec2(d,mat);\n}\n\nfloat dist(vec3 p) { return distM(p).x; }\n\nvec3 getGradOld(vec3 p,float delta)\n{\n    float v=dist(p);\n    vec2 d=vec2(delta,0); return vec3( dist(p+d.xyy)-v,\n                                       dist(p+d.yxy)-v,\n                                       dist(p+d.yyx)-v )/delta;\n}\n\n/// my own version of a looped getGrad()\nvec3 getGrad(vec3 p,float delta)\n{\n    vec4 d=vec4(0,0,0,1); \n    vec3 s=vec3(0);\n    // use a loop here keep compiler from inlining this in win (thanks iq for the hint!)\n    for(int i=min(0,iFrame);i<4;i++)\n    {\n      \ts+=(d.xyz-d.w)*dist(p+d.xyz*delta);\n        d=d.wxyz;\n    }\n    return s/delta;\n}\n\n/// klems' getGrad - slightly modified to avoid div by 0\nvec3 getGrad2(vec3 p,float delta)\n{\n    // use loop here to keep compiler from inlining this in win (thanks iq for the hint!)\n    // btw very interesting function that...\n    vec4 n = vec4(0.0);\n    for( int i=min(iFrame,0); i<4; i++ )\n    {\n        vec4 s = vec4(p, 0.0);\n        s[i] += delta;\n        n[i] = dist(s.xyz);\n    }\n    n-=n.w;\n    return n.xyz/(length(n.xyz)+.0001); // added some small epsilon to avoid division by 0\n}\n\nfloat march(inout vec3 p, vec3 dir)\n{\n    //if(!intersectBox(p-bbpos,dir,bbsize)) { enable_car=false; }\n    vec3 pc=carTrafo(p);\n    vec3 pdir=carTrafo(dir,0.);\n    //enable_car=true;\n    if(!(intersectBox(pc-bbpos1,pdir,bbsize1)||intersectBox(pc-bbpos2,pdir,bbsize2))) { enable_car=false; }\n    vec3 p0=p;\n    float eps=.001;\n    float dmin=1000.;\n    bool findmin=false;\n    float d=dist(p);\n    vec3 pmin=p;\n    for(int i=0;i<150;i++)\n    {\n        float dp=d;\n        d=dist(p);\n        p+=dir*d*.8;\n#ifdef SHADOW\n        if (d<dp) findmin=true;\n        if (findmin && d<dmin) { dmin=d; pmin=p; }\n#endif\n        if (d<eps) return 0.;\n        if (d>300.) break;\n    }\n    return clamp(dmin/length(pmin-p0)/.05,0.,1.);\n}\n\nfloat wstep(float w, float thr, float x)\n{\n    return smoothstep(thr-w*.5,thr+w*.5,x);\n}\n\nfloat getAO(vec3 pos, vec3 n)\n{    \n    float ao=1.;\n    float sc=.025;\n    float amb=.3;\n    // use loop here to keep compiler from inlining this in win (thanks iq for the hint!)\n    for( int i=min(iFrame,0); i<5; i++ )\n    {\n    \tao*=mix(dist(pos+n*sc)/sc*1.4,1.,amb);\n    \tao=clamp(ao,0.,1.);\n        sc*=2.;\n        amb=min(amb+.1,.5);\n    }\n    return ao;\n   \t/*\n    ao*=dist(pos+n*.02)/.02*1.4*.7+.3;\n   \tao=clamp(ao,0.,1.);\n    ao*=dist(pos+n*.05)/.05*1.4*.6+.4;\n    ao=clamp(ao,0.,1.);\n    ao*=dist(pos+n*.1)/.1*1.4*.5+.5;\n    ao=clamp(ao,0.,1.);\n    ao*=dist(pos+n*.2)/.2*1.4*.5+.5;\n    ao=clamp(ao,0.,1.);\n    ao*=dist(pos+n*.4)/.4*1.4*.5+.5;\n    ao=clamp(ao,0.,1.);*/\n}\n\nvec3 lighting(vec3 pos, vec3 dir, vec3 pos0, float reflections, inout float outfres, inout float outao)\n{\n    vec3 pc=carTrafo(pos);\n    vec3 glasspos=vec3(1000.);\n    vec3 glassn=vec3(0.);\n    float mat=distM(pos).y;\n    if(mat==GLASS)\n    {\n        glasspos=pos;\n        glassn=normalize(getGrad(pos,.001));\n        enable_glass=false;\n        march(pos,dir);\n    }\n    mat=distM(pos).y;\n    \n    vec3 light=getLightDir();\n    float sh=1.;\n#ifdef SHADOW\n    vec3 posS=pos+.017*light;\n    enable_car=true;\n    sh=march(posS,light);\n#endif\n    enable_car=true;\n    vec3 n=getGrad(pos,.001);\n    if (length(n)<.001) n=vec3(0,0,1);\n    n=normalize(n);\n    if(mat==BG) n=vec3(0,0,1);\n\n    float ao=getAO(pos,n);\n    ao=sqrt(ao);\n    ao=ao*.7+.3;\n\n    float diff=clamp(dot(n,light),0.,1.);\n\n    diff=min(diff,sh);\n    \n    // no ao in lighted areas\n    ao=mix(ao,1.,diff);\n    ao=clamp(ao,0.,1.);\n    //return vec3((diff*.6+.4)*(ao));\n    \n\n    Material mtrl=getMaterial(mat);\n\n    // evironmental reflection\n    n=normalize(n);\n    vec3 R=reflect(dir,n);\n    vec3 refl=myenv(pos,R.xyz,1.).xyz;\n    //refl=refl*1.2+.3;\n    float fres=abs(dot(R,n));\n    fres=1.-fres;\n    fres*=fres*fres;\n    fres=fres*.9+.1;\n    float fres0=fres;\n    #ifdef SCRATCHES\n    vec3 n0=n;\n    int numscr=7;\n    float dang=1.57*2./float(numscr);\n    float ang=.5;\n    refl*=1.;\n    vec3 drefl=vec3(0);\n    float sum=0.;\n    vec3 pi=pc;\n    vec3 heading=vec3(0,0,1);\n    vec3 tan1=vec3(1,0,0);\n    vec3 tan2=vec3(0,1,0);\n    // ...trying to implement some micro scratches\n    for(int i=0;i<numscr*3;i++)\n    {\n        n=n0;\n        vec2 cs=cos(ang+vec2(0,-1.57));\n        mat2 m=mat2(cs,cs.yx*vec2(-1,1));\n        //dFdx()\n        vec2 dn2d=(texture(iChannel0,(m*pi.xy)*vec2(6.,.1)*mtrl.scratchScale+vec2(0,.5/256.)).x-.5)*mtrl.scratchScale;\n        dn2d=pow(abs(dn2d),vec2(.7))*sign(dn2d);\n        dn2d=dn2d*m;\n        //dn2d=dn2d.yx*vec2(1,-1);\n        n+=abs(dot(n0,heading))*carTrafoInv(dn2d.x*tan1+dn2d.y*tan2,0.);\n        n=normalize(n);\n        R=reflect(dir,n);\n        float fres=abs(dot(R,n));\n        fres=1.-fres;\n        fres*=fres*fres;\n        fres=fres*.4+.6;\n        float fact=(abs(dot(n0,-dir))*.8+.2)*fres;\n        //fact=.2;\n        drefl+=fact*myenv(pos,R.xyz,1.).xyz;\n        sum+=fact;\n        ang+=dang;\n        pi=pi.zxy;\n        heading=heading.yzx;\n        tan1=tan1.yzx;\n        tan2=tan2.yzx;\n    }\n    drefl/=float(numscr);\n    refl=mix(refl,drefl,mtrl.scratchy);\n    #endif\n    \n    #ifdef RENDER_GLASS\n    vec3 Rg=reflect(dir,glassn);\n    vec3 glassrefl=myenv(pos,Rg.xyz,1.).xyz;\n    //glassrefl=glassrefl*1.2+.3;\n    float glassfres=abs(dot(Rg,glassn));\n    glassfres=1.-glassfres;\n    glassfres*=glassfres*glassfres;\n    glassfres=glassfres*.85+.15;\n    if(glassn==vec3(0)) glassfres=0.;\n    #endif\n\n    vec3 rcol=vec3(1);\n    fres=(mtrl.refl<0.)?fres*-mtrl.refl:mtrl.refl;\n    rcol=(mtrl.refl<0.)?vec3(1):mtrl.col;\n    vec3 col=mtrl.col;\n    if(mat==FLOOR) {\n        col+=(texture(iChannel0,pos.xy*2.,-1.2).x-.5)*.3;\n        col*=.9+.2*texture(iChannel2,pos.xy*.2).xyz;\n        #ifdef WET_ASPHALT\n        col*=.35+.65*step(-.66,pos.z);\n        fres=fres0*mix(-mtrl.refl,1.,(1.-smoothstep(-.661,-.659,pos.z))*exp(-length(pos.xy)/50.));\n        #endif\n    }\n\n    vec4 zzt=vec4(0);\n    {\n        vec3 p=carTrafo(pos);\n    #ifndef ZZT_AS_TEX\n \t    float sp=sign(p.x); // windows not able to compile if i substitute this directly below... [rolleyes]\n        zzt=zztop((p.yz*8.5*vec2(sp,1)-vec2(sp,.9))*vec2(1,1.-.15*p.y),sp);\n    #else\n        vec2 uv=(vec2(-1,1)*(p.yz*8.5-vec2(1,.9))*vec2(1,1.-.15*p.y)/11.+.75)*.5;\n        uv=clamp(uv,0.,1.);\n        zzt=texture(iChannel1,uv);\n    #endif\n    }\n    if(mat==RUMPF) { \n        col=mix(col,zzt.xyz,zzt.w);\n        if(zzt.xyz==vec3(1)) { fres=.6; col*=.0; }\n    }\n    //col-=n*.05;\n    \n    float zr=length(pos-pos0)/300.;\n    //diff=sqrt(diff);\n\n    outfres=fres;\n    if(glassfres!=0.) outfres=glassfres;\n    fres*=reflections;\n    glassfres*=reflections;\n\n    outao=ao;\n    \n\tvec3 bg=myenv(pos0,dir,1.).xyz;\n\t// diff, ao, refl\n\tvec3 finalcol = mix(col,rcol*refl,fres)*mix(vec3(1.2,1.4,1.5)*.5,vec3(1.,1,.9),diff)*ao*1.3;\n\t//finalcol=col;\n\t// fog\n\t//finalcol = mix(finalcol,bg,1.-exp(-zr));\n\tfinalcol = mix(finalcol,bg,1.-clamp(exp(-zr+.1),0.,1.));\n\t#ifdef RENDER_GLASS\n\tfinalcol=mix(finalcol,glassrefl,glassfres);\n\t#endif\n\treturn finalcol;\n}\n\nvec4 camAnim[8] = vec4[] (\n    vec4( 1.5, -2.75,-0.25 ,1.), vec4(0,1.,.1, 0.),\n    vec4(-1.5, -2.75,-0.25 ,1.), vec4(.5,1.,.1, 0.),\n    //vec4(-2., -1.5,-0.25 ,1.), vec4(1.,0.,.1, 0.),\n    vec4(-2., 3.,-0.35 ,1.), vec4(.5,-1,.1, 0.),\n    vec4(-2., 3.,-0.35 ,1.), vec4(.5,-1,.1, 0.)\n    );\n    \nvec3 getCamAnimPos(float t)\n{\n    t*=.1;\n    int i_f=int(t); float fact=fract(t); int i_c=i_f+1;\n    i_c=min(3,i_c);\n    i_f=min(3,i_f);\n    return mix(camAnim[i_f*2].xyz,camAnim[i_c*2].xyz,fact);\n}\n\nvec3 getCamAnimDir(float t)\n{\n    t*=.1;\n    int i_f=int(t); float fact=fract(t); int i_c=i_f+1;\n    i_c=min(3,i_c);\n    i_f=min(3,i_f);\n    return mix(camAnim[i_f*2+1].xyz,camAnim[i_c*2+1].xyz,fact);\n}\n\nfloat getCamAnimBr(float t)\n{\n    t*=.1;\n    int i_f=int(t); float fact=fract(t); int i_c=i_f+1;\n    i_c=min(3,i_c);\n    i_f=min(3,i_f);\n    return mix(camAnim[i_f*2].w,camAnim[i_c*2].w,fact);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 sc=(fragCoord-Res*.5)/Res.x;\n    \n    float zoom=1.;\n    #ifdef SHADEROO\n    zoom=exp(-iMouseData.z/5000.);\n    #endif\n    zoom*=CamDistFact;\n\n    vec3 CarPos = carTrafoInv(vec3(0),1.);\n    vec3 pos=vec3(0,0,4.5)*zoom;\n    vec3 dir=normalize(vec3(sc,-.8));\n    \n    vec4 q=vec4(0,0,0,1);\n    float th=-(iMouse.y-Res.y*.5)/Res.y*6.;\n    float ph=-(iMouse.x-Res.x*.5)/Res.x*10.;\n    //if(iMouse.x<1.) \n    { th=1.45; ph=-iTime*.25; }\n    th=clamp(th,-1.65,1.65);\n    q=multQuat(q,axAng2Quat(vec3(0,0,1),ph));\n    q=multQuat(q,axAng2Quat(vec3(1,0,0),th));\n    pos=transformVecByQuat(pos,q)-vec3(0,0,.2);\n    dir=transformVecByQuat(dir,q);\n    pos=carTrafoInv(pos,1.);\n    dir=carTrafoInv(dir,0.);\n\n    //if(iMouse.x<1.)\n    {\n    pos=getCamAnimPos(iTime);\n    pos+=.015*sin(iTime*vec3(1,1.3,1.7)*1.);\n    dir=normalize(getCamAnimDir(iTime));\n    vec3 right=normalize(cross(dir,vec3(0,0,1)));\n    vec3 up=cross(right,dir);\n    dir=normalize(dir+right*sc.x+up*sc.y);\n    }\n    \n    vec3 pos0=pos;\n    float m=march(pos,dir);\n    \n    float refl=1.;\n    #ifdef RENDERED_REFECTIONS\n    refl=0.;\n    #endif\n    float fres=0., ao=0.;\n    fragColor.xyz=lighting(pos,dir,pos0,refl,fres,ao);\n    #ifdef RENDERED_REFECTIONS\n    enable_glass=true;\n    vec3 n=getGrad(pos,.001);\n    if (length(n)<.001) n=vec3(0,0,1);\n    n=normalize(n);\n    dir=reflect(dir,n);\n    pos+=dir*.003;\n    /*fres=abs(dot(dir,n));\n    fres=1.-fres;\n    fres*=fres*fres;\n    fres=fres*.9+.1;*/\n    float mat=distM(pos).y;\n    march(pos,dir);\n    float dummyfres,dummyao;\n    vec3 lcol=lighting(pos,dir,pos0,1.,dummyfres,dummyao);\n    fragColor.xyz=mix(fragColor.xyz,lcol,(m!=0.)?0.:fres);\n    #endif\n    \n    fragColor*=1.-exp(-getCamAnimBr(iTime)*getCamAnimBr(iTime)/.01);\n    \n\tfragColor.w=1.;\n}\n\n#if 0\nvoid mainImageXX( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=vec4(0);\n    float snum=0.;\n    for(int i=0;i<max(int(snum),1);i++)\n    {\n        enable_glass=true;\n        vec4 col=vec4(0);\n        vec2 r = (texelFetch(iChannel0,ivec2(mod(fragCoord+vec2(i*5+iFrame*13,0)+.1,256.0))&255,0).xy-.5)*1.;\n        //vec2 r = getRand(i+int(fragCoord.x+fragCoord.y*iResolution.x)).xy-.5;\n        mainImageS(col,fragCoord+r*((snum>0.)?1.:0.3));\n        fragColor+=col;\n        vec4 r2=texture(iChannel0,fragCoord/Res0*.707+iTime*4.5+float(i)*.1)-.5;\n        fragColor+=.05*r2;\n    }\n    fragColor/=floor(max(snum,1.));\n}\n#endif\n\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftjSWh.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1470, 1470, 1562, 1562, 2231], [2233, 2233, 2321, 2321, 2515], [2518, 2518, 2575, 2575, 3657]], "test": "untested"}
{"id": "NlBXWR", "name": "4 tap Catmull-Rom upsampling", "author": "goingdigital", "description": "Fast Catmull-Rom using 4 texture fetches with checkerboard inverted source texture. Requires at least 512x512 viewing window.  Other upscalers: https://www.shadertoy.com/playlist/WcKXWW", "tags": ["catmull", "upsampling", "lanczos"], "likes": 12, "viewed": 2171, "published": 3, "date": "1627546608", "time_retrieved": "2024-07-30T19:08:50.014667", "image_code": "/*\nFour tap Catmull-Rom upsampling\n\nNote: Render window must be at least 512x512. This is because the texture is\npreprocessed at source texture resolution, but Shadertoy buffers are always\nat render window size. If the texture is cut off, go fullscreen.\n\nBy default, right hand side is nearest neighbour sampling.\nChange iChannel1 filter mode to 'linear' to compare against bilinear filtering.\n\nThis takes the ideas from:\nhttps://vec3.ca/bicubic-filtering-in-fewer-taps/\n    9 taps\nhttps://research.activision.com/publications/archives/filmic-smaasharp-morphological-and-temporal-antialiasing\n    5 taps, with 4 removed sidelobes\n\nThis example:\n    4 taps, with 0 removed sidelobes (but checkerboard preprocessing)\n\nBy inverting the source texture in a checkerboard style (which can be baked into\nthe texture or previous render pass) and utilising existing bilinear filtering,\nCatmull-Rom reduces from 16 to 4 texture reads.\n\nEvery other pixel of the source texture is inverted in a checkerboard pattern.\nThis matches the positive/negative flips of the Catmull-Rom lobes.\n\noffset works out the position where bilinear filtering will get the correct ratio of\nsidelobes. This allows 1 texture fetch to read 4 taps. This needs to be a 4th order\npolynomial to preserve partition of unity, but only 2dp of precision is needed.\nThe polynomial coefficients were derived using Excel's trendline function. X and Y\nnegative and positive sides are evaluated simultaneously in the vec4.\n\nw is the appropriate final weighting of the reads, assuming each read is 2D lerp of 4\ntaps. The some weights are inverted to compensate for the source texture checkerboard.\n\nThis checkerboard strategy only works where each sidelobe is of opposing sign.\nSo it works for Catmull-Rom and Lanczos-2, but not Mitchell–Netravali.\n\nI have chosen Catmull-Rom over Lanczos-2 as it has a partition of unity, which induces\nless ripple in solid colours where local clamping can't be easily done.\n\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Split into whole pixel and subpixel position\n    vec2 src_subpixel = fragCoord * iChannelResolution[1].xy / iResolution.xy + .5;\n    vec2 src_pixel = floor(src_subpixel);\n    src_subpixel -= src_pixel;\n\n    // Map texel offsets and weights\n    vec4 f=vec4(src_subpixel,1.-src_subpixel);\n    // Offset adds the correct ratio of each lobe using texture bilinear interpolation\n    //vec4 offset = (((-.94117*f+1.67489)*f-1.2601)*f+.52875)*f+.49921; // Catmull Rom\n    vec4 offset = (((-.94*f+1.68)*f-1.26)*f+.53)*f+.5; // Catmull Rom\n    vec4 texpos = (src_pixel.xyxy + vec4(-offset.xy, offset.zw)) / iChannelResolution[0].xyxy;\n    // Weight adds textures in correct ratio, and corrects for checkerboard across kernel.\n    vec4 w = ((2.*f-3.5)*f+.5)*f+1.; // Catmull Rom\n\n    // Texture lookup\n    fragColor.xyz = w.x * w.y * texture(iChannel0, texpos.xy).xyz;\n    fragColor.xyz -= w.z * w.y * texture(iChannel0, texpos.zy).xyz;\n    fragColor.xyz += w.z * w.w * texture(iChannel0, texpos.zw).xyz;\n    fragColor.xyz -= w.x * w.w * texture(iChannel0, texpos.xw).xyz;\n\n    // De-checkerboard\n    float z = mod(src_pixel.x + src_pixel.y, 2.);\n    if (z>.5) fragColor.xyz = -fragColor.xyz;\n\n    // Catmull-Rom can ring, so clamp.\n    // It would be nice to clamp to local min/max, but that would require additional\n    // texture reads. If texture reads are done as a textureGather, this would be\n    // possible.\n    fragColor.xyz = clamp(fragColor.xyz, 0., 1.);\n\n    // Comparison\n    float div = 0.5 + 0.5*sin(0.3*iTime);\n    if (iMouse.z > 0.) {\n        div = iMouse.x / iResolution.x;\n    }\n    div = fragCoord.x / iResolution.x - div;\n    if (div > -.002) {\n        if (div > .002) {\n            vec2 p = fragCoord * iChannelResolution[1].xy / iResolution.xy;\n            // Leave commented to compare against bilinear\n            // Uncomment to compare against nearest-neighbour\n            // p = floor(p)+.5;\n            fragColor.xyz = texture(iChannel1, p/iChannelResolution[1].xy).xyz;\n        } else fragColor.xyz = vec3(0);\n    }\n\n    fragColor.w = 1.;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/* Checkerboard invert half the texture pixels\n\nThis could be baked into the tone mapping of the previous render pass.\n\nThe checkerboarding allows bilinear filtering to be used to read 4 taps\nsimultaneously at the correct ratios, by strategic selection of the subpixel\nposition. 16 taps are read as 4 texture reads.\n\nThis buffer should be the same size as the source image.\nShadertoy doesn't allow buffer sizes to be set, so it is assumed the\nrender size is larger than the source texture (512x512 pixels).\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Pixel number, integer\n    vec2 pixel = floor(fragCoord);\n    \n    // Get texture, 1:1 pixel ratio, sampling at centre of texel.\n    vec3 c = texture(iChannel0, (pixel + 0.5)/iChannelResolution[0].xy).xyz;\n    \n    // Checkerboard flip\n    float flip = (pixel.x + pixel.y)*.5;\n    flip = flip - floor(flip);\n    if (flip > .25) c = -c;\n\n    fragColor = vec4(c,1.0);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlBXWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 1966, 2023, 2075, 4093]], "test": "untested"}
{"id": "7tBXDh", "name": "Ray Tracing One Weekend Improved", "author": "chenglou", "description": "Revisited my original ray tracer from the beginning of the month! Speed went from 11 fps to 55 fps :)\n- Way better random in unit sphere & vector & disk\n- Unrolled the loop from `hit`\n- Removed a few conditionals. That's it!", "tags": ["raytracing"], "likes": 23, "viewed": 1574, "published": 3, "date": "1627545462", "time_retrieved": "2024-07-30T19:08:50.853424", "image_code": "//https://raytracing.github.io/books/RayTracingInOneWeekend.html\n\nconst float PI = 3.14159;\nconst float SAMPLES_PER_PIXEL = 10.;\nconst int MAX_RAY_BOUNCES = 6;\n\nfloat hash12(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec3 hash32(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 random_in_unit_sphere(vec2 p) {\n    vec3 rand = hash32(p);\n    float phi = 2.0 * PI * rand.x;\n    float cosTheta = 2.0 * rand.y - 1.0;\n    float u = rand.z;\n\n    float theta = acos(cosTheta);\n    float r = pow(u, 1.0 / 3.0);\n\n    float x = r * sin(theta) * cos(phi);\n    float y = r * sin(theta) * sin(phi);\n    float z = r * cos(theta);\n\n    return vec3(x, y, z);\n}\n\nvec3 random_unit_vector(vec2 p) {\n    return normalize(random_in_unit_sphere(p));\n}\n\nvec3 random_in_unit_disk(vec2 p) {\n    return vec3(random_in_unit_sphere(p).xy, 0);\n}\n\nconst int material_lambertian = 0;\nconst int material_metal = 1;\nconst int material_dielectric = 2;\n\nstruct ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct material {\n    int type;\n    vec3 albedo;\n    float metal_fuzz;\n    float dielectric_index_of_refraction;\n};\n\nstruct hit_record {\n    vec3 p;\n    vec3 normal;\n    float t;\n    material material;\n};\n\nstruct sphere {\n    vec3 center;\n    float radius;\n    material material;\n};\n\nconst sphere spheres[24] = sphere[](\n  sphere(vec3( 0.0, -1000., -1.0), 1000., material(material_lambertian, vec3(0.5), 0., 0.)),\n  sphere(vec3(-4.0,    1.0, 2.),   1.0, material(material_dielectric, vec3(0), 0., 1.5)),\n  sphere(vec3( 0.0,    1.0, 0.),   1.0, material(material_metal, vec3(0.7, 0.6, 0.5), 0., 0.)),\n  sphere(vec3( 4.0,    1.0, 2.),   1.0, material(material_lambertian, vec3(0.7, 0.3, 0.3), 0., 0.)),\n  sphere(vec3(-6, 0.2, 2.8), 0.2, material(material_dielectric, vec3(0, 0, 0.2), 0., 1.5)),\n  sphere(vec3(1.6, 0.2, -0.9), 0.2, material(material_dielectric, vec3(0), 0., 1.5)),\n  sphere(vec3(-5.7, 0.2, -2.7), 0.2, material(material_lambertian, vec3(0.8, 0.3, 0.3), 0., 0.)),\n  sphere(vec3(-3.6, 0.2, -4.4), 0.2, material(material_lambertian, vec3(0.9, 0.3, 0.2), 0., 0.)),\n  sphere(vec3(0.8, 0.2, 2.3), 0.2, material(material_lambertian, vec3(0.2, 0, 0.5), 0., 0.)),\n  sphere(vec3(3.8, 0.2, 4.2), 0.2, material(material_lambertian, vec3(0.4, 0.3, 0.7), 0., 0.)),\n  sphere(vec3(-0.1, 0.2, -1.9), 0.2, material(material_lambertian, vec3(0.4, 0, 0.4), 0., 0.)),\n  sphere(vec3(-2.5, 0.2, 5.4), 0.2, material(material_metal, vec3(0.3, 0.7, 0.9), 0.3, 0.)),\n  sphere(vec3(-3.9, 0.2, -0.3), 0.2, material(material_lambertian, vec3(0.9, 0.8, 0.5), 0., 0.)),\n  sphere(vec3(-6, 0.2, 4), 0.2, material(material_lambertian, vec3(0.9, 0.9, 0.5), 0., 0.)),\n  sphere(vec3(4.4, 0.2, -0.5), 0.2, material(material_lambertian, vec3(0.5, 0.4, 0.8), 0., 0.)),\n  sphere(vec3(3.4, 0.2, 5.3), 0.2, material(material_lambertian, vec3(0.1, 0.6, 0.2), 0., 0.)),\n  sphere(vec3(4.6, 0.2, -3.8), 0.2, material(material_lambertian, vec3(0.2, 0.2, 0.2), 0., 0.)),\n  sphere(vec3(0.7, 0.2, -2.5), 0.2, material(material_metal, vec3(0, 0.2, 0.1), 0., 0.)),\n  sphere(vec3(2.4, 0.2, -4.3), 0.2, material(material_lambertian, vec3(0.8, 0.9, 0), 0., 0.)),\n  sphere(vec3(4.4, 0.2, 4.9), 0.2, material(material_lambertian, vec3(0.8, 0.8, 0), 0., 0.)),\n  sphere(vec3(-4.7, 0.2, 4.6), 0.2, material(material_lambertian, vec3(0.8, 0.8, 0.7), 0., 0.)),\n  sphere(vec3(4.2, 0.2, -3.5), 0.2, material(material_lambertian, vec3(0.8, 0.8, 0.6), 0., 0.)),\n  sphere(vec3(-5.2, 0.2, 0.5), 0.2, material(material_lambertian, vec3(0.2, 0.7, 0.9), 0., 0.)),\n  sphere(vec3(5.7, 0.2, -0.8), 0.2, material(material_lambertian, vec3(0.3, 0, 0.7), 0., 0.))\n);\n\nvoid hit_sphere(sphere sph, ray r, inout hit_record rec, inout bool hit_anything) {\n    float closest_so_far = rec.t;\n    vec3 oc = r.origin - sph.center;\n    float a = dot(r.dir, r.dir);\n    float half_b = dot(oc, r.dir);\n    float c = dot(oc, oc) - sph.radius * sph.radius;\n    float discriminant = half_b * half_b - a * c;\n    if (discriminant < 0.) {\n        return;\n    }\n\n    float sqrtd = sqrt(discriminant);\n\n    // Find the nearest root that lies in the acceptable range\n    float root = (-half_b - sqrtd) / a; // the t. from -b - sqrt(dis) / 2a\n    if (root < 0.001 || closest_so_far < root) {\n        root = (-half_b + sqrtd) / a;\n        if (root < 0.001 || closest_so_far < root) {\n            return;\n        }\n    }\n\n    hit_anything = true;\n    vec3 p = r.origin + r.dir * root;\n    rec = hit_record(p, (p - sph.center) / sph.radius, root, sph.material);\n}\n\nbool hit(ray r, out hit_record rec) {\n    bool hit = false;\n    // dummy. Set initial hit distance to max\n    rec = hit_record(vec3(0), vec3(0), 9999., material(material_lambertian, vec3(0), 0., 0.));\n\n    // unrolling this loop gave 4x perf boost...\n    hit_sphere(spheres[0], r, rec, hit);\n    hit_sphere(spheres[1], r, rec, hit);\n    hit_sphere(spheres[2], r, rec, hit);\n    hit_sphere(spheres[3], r, rec, hit);\n    hit_sphere(spheres[4], r, rec, hit);\n    hit_sphere(spheres[5], r, rec, hit);\n    hit_sphere(spheres[6], r, rec, hit);\n    hit_sphere(spheres[7], r, rec, hit);\n    hit_sphere(spheres[8], r, rec, hit);\n    hit_sphere(spheres[9], r, rec, hit);\n    hit_sphere(spheres[10], r, rec, hit);\n    hit_sphere(spheres[11], r, rec, hit);\n    hit_sphere(spheres[12], r, rec, hit);\n    hit_sphere(spheres[13], r, rec, hit);\n    hit_sphere(spheres[14], r, rec, hit);\n    hit_sphere(spheres[15], r, rec, hit);\n    hit_sphere(spheres[16], r, rec, hit);\n    hit_sphere(spheres[17], r, rec, hit);\n    hit_sphere(spheres[18], r, rec, hit);\n    hit_sphere(spheres[19], r, rec, hit);\n    hit_sphere(spheres[21], r, rec, hit);\n    hit_sphere(spheres[22], r, rec, hit);\n    hit_sphere(spheres[23], r, rec, hit);\n\n    return hit;\n}\n\nbool near_zero(vec3 p) {\n    float s = 1e-8;\n    return p.x < s && p.y < s && p.z < s;\n}\n\nfloat reflectance(float cosine, float ref_idx) {\n    // Use Schlick's approximation for reflectance\n    float r0 = (1. - ref_idx) / (1. + ref_idx);\n    r0 = r0 * r0;\n    return r0 + (1. - r0) * pow((1. - cosine), 5.);\n}\n\nvoid scatter(hit_record rec, ray r, vec2 seed, inout vec3 attenuation, inout ray scattered) {\n    material m = rec.material;\n\n    if (m.type == material_lambertian) {\n        vec3 scatter_direction = normalize(rec.normal + random_unit_vector(seed));\n\n        // catch degenerate scatter direction\n        if (near_zero(scatter_direction)) {\n            scatter_direction = rec.normal;\n        }\n\n        scattered = ray(rec.p, scatter_direction);\n        attenuation = m.albedo;\n    } else if (m.type == material_metal) {\n        vec3 reflected = reflect(r.dir, rec.normal);\n        ray scattered_ = ray(rec.p, normalize(reflected + m.metal_fuzz * random_in_unit_sphere(seed)));\n        if (dot(scattered_.dir, rec.normal) > 0.) {\n            scattered = scattered_;\n            attenuation = m.albedo;\n        }\n    } else if (m.type == material_dielectric) {\n        bool front_face = dot(r.dir, rec.normal) < 0.;\n        vec3 adjusted_normal = front_face ? rec.normal : -rec.normal;\n        float ref = m.dielectric_index_of_refraction;\n        float refraction_ratio = front_face ? 1.0/ref : ref;\n\n        float cos_theta = min(dot(-r.dir, adjusted_normal), 1.0);\n        float sin_theta = sqrt(1.0 - cos_theta * cos_theta);\n\n        bool cannot_refract = refraction_ratio * sin_theta > 1.0;\n        vec3 direction;\n\n        if (cannot_refract || reflectance(cos_theta, refraction_ratio) > hash12(seed)) {\n            direction = reflect(r.dir, adjusted_normal);\n        } else {\n            direction = refract(r.dir, adjusted_normal, refraction_ratio);\n        }\n\n        scattered = ray(rec.p, direction);\n        attenuation = vec3(1);\n    }\n}\n\nvec3 ray_color(in ray r, vec2 seed) {\n    vec3 color = vec3(1);\n    hit_record rec;\n    int depth;\n    for (depth = 0; depth < MAX_RAY_BOUNCES; depth++) {\n        if (hit(r, rec)) {\n            ray scattered;\n            vec3 attenuation;\n            scatter(rec, r, seed * 999. + float(depth), attenuation, scattered);\n            r = scattered;\n            color *= attenuation;\n        } else {\n            // hit bg, aka nothing\n            float t = 0.5 * (r.dir.y + 1.0);\n            color *= mix(vec3(1.), vec3(0.5, 0.7, 1.0), t);\n\n            break;\n        }\n    }\n\n    if (depth == MAX_RAY_BOUNCES) {\n        return vec3(0);\n    }\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // camera\n    vec3 lookfrom = vec3(cos(iTime) * 13., 2.0, sin(iTime) * 10.);\n    vec3 lookat = vec3(0, 0, 0);\n    vec3 vup = vec3(0, 1, 0);\n    float vfov = 30.0;\n    float aspect_ratio = iResolution.x / iResolution.y;\n    float aperture = 0.1;\n    float focus_dist = 10.0;\n\n    float theta = radians(vfov);\n    float h = tan(theta / 2.);\n    float viewport_height = 2.0 * h;\n    float viewport_width = aspect_ratio * viewport_height;\n\n    vec3 w = normalize(lookfrom - lookat);\n    vec3 u = normalize(cross(vup, w));\n    vec3 v = cross(w, u);\n\n    vec3 origin = lookfrom;\n    vec3 horizontal = focus_dist * viewport_width * u;\n    vec3 vertical = focus_dist * viewport_height * v;\n    vec3 lower_left_corner = origin - horizontal / 2. - vertical / 2. - focus_dist * w;\n\n    float lens_radius = aperture / 2.;\n\n    // render\n    vec3 color = vec3(0);\n    for (float s = 0.; s < SAMPLES_PER_PIXEL; s++) {\n        vec2 rand = hash22(fragCoord * 999. + s + iTime);\n\n        vec2 normalizedCoord = (fragCoord + rand) / iResolution.xy;\n        vec3 rd = lens_radius * random_in_unit_disk(normalizedCoord * 999. + s + iTime);\n        vec3 offset = u * rd.x + v * rd.y;\n        ray r = ray(\n            origin + offset,\n            normalize(lower_left_corner + normalizedCoord.x * horizontal + normalizedCoord.y * vertical - origin - offset)\n        );\n        color += ray_color(r, normalizedCoord);\n    }\n\n    fragColor = vec4(sqrt(color / SAMPLES_PER_PIXEL), 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tBXDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 161, 183, 183, 303], [304, 304, 325, 325, 462], [463, 463, 484, 484, 623], [625, 625, 661, 661, 996], [998, 998, 1031, 1031, 1081], [1083, 1083, 1117, 1117, 1168], [3922, 3922, 4005, 4005, 4794], [4796, 4796, 4833, 4833, 6021], [6023, 6023, 6047, 6047, 6111], [6113, 6113, 6161, 6212, 6332], [6334, 6334, 6427, 6427, 7985], [7987, 7987, 8024, 8024, 8647], [8650, 8650, 8707, 8721, 10175]], "test": "untested"}
{"id": "slSXDh", "name": "Triangle - Moment of Inertia", "author": "oneshade", "description": "More 2D physics stuff.", "tags": ["2d", "triangle", "physics", "inertia", "momentofinertia"], "likes": 13, "viewed": 165, "published": 3, "date": "1627540859", "time_retrieved": "2024-07-30T19:08:51.960463", "image_code": "// See https://www.desmos.com/calculator/l9ipcrouvp\n// I feel like this should be simpler\n\n// My process:\n// 1. Split the triangle into to wedge segments that meet at on a horizontal line\n// 2. Integrate a slice of each wedge along the x axis (bounds vary linearly with the y coordinate)\n// 3. Integrate along the height of the wedge segments in the y axis\n// 4. Combine the inertia for both segments\n\n// SDFs\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - t;\n}\n\nfloat sdTriangle(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    vec2 ba = b - a, cb = c - b, ac = a - c;\n    vec2 pa = p - a, pb = p - b, pc = p - c;\n\n    float abc = ba.x * cb.y - ba.y * cb.x;\n    float abp = ba.x * pa.y - ba.y * pa.x;\n    float bcp = cb.x * pb.y - cb.y * pb.x;\n    float cap = ac.x * pc.y - ac.y * pc.x;\n\n    vec2 ae = pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    vec2 be = pb - cb * clamp(dot(pb, cb) / dot(cb, cb), 0.0, 1.0);\n    vec2 ce = pc - ac * clamp(dot(pc, ac) / dot(ac, ac), 0.0, 1.0);\n\n    float tri = sqrt(min(dot(ae, ae), min(dot(be, be), dot(ce, ce))));\n    return -tri * sign(min(abp, min(bcp, cap)) * max(abp, max(bcp, cap)));\n}\n\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    float ang = texelFetch(iChannel0, ivec2(0), 0).x;\n    float co = cos(ang), si = sin(ang);\n    mat2 rot = mat2(co, si, -si, co);\n\n    vec2 a = A * rot;\n    vec2 b = B * rot;\n    vec2 c = C * rot;\n\n    float tri = sdTriangle(uv, a, b, c);\n    drawSDF(tri, vec3(1.0, 0.0, 0.0));\n    drawSDF(abs(tri), vec3(1.0, 0.8, 0.0));\n    drawSDF(length(uv) - 0.05, vec3(1.0, 0.8, 0.0));\n\n    float aspect = iResolution.x / iResolution.y;\n    color = digitIn(color, vec3(1.0), uv * 0.25 + vec2(0.45 * aspect, 0.45), 100.0, triangleInertia(A, B, C));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Triangle settings\n#define SCALE (iTime > 13.0 ? 1.0 + 0.5 * cos(iTime - 13.0 - 1.57) : 1.0)\n#define A (vec2(0.799, 2.088) * SCALE)\n#define B (vec2(-1.075, -0.307) * SCALE)\n#define C (vec2(0.405, -0.442) * SCALE)\n#define DENSITY 0.1\n\n// Simulation settings\n#define FRICTION 0.98\n#define GRAVITY 0.2\n\n// cross3D(vec3(a.x, a.y, 0), vec3(b.x, b.y, 0))\n// Since the x and y components of the result are always zero\n// The z component is the only one of interest\nfloat cross2D(in vec2 a, in vec2 b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nfloat triangleMass(in vec2 a, in vec2 b, in vec2 c, in float density) {\n    return 0.5 * abs(cross2D(b - a, c - a)) * density;\n}\n\n// Moment of inertia of a triangle with vertices a, b, and c\n// The rotation axis is assumed to be at (0, 0). You can change\n// it by translating the triangle's vertices. Obviously, horizontal\n// and vertical edges pose an issue, this can be avoided by nudging\n// the vertices or rotating them about (0, 0) (such a rotation will\n// not change the moment of inertia)\n#define pow3(x) x * x * x\n#define pow4(x) x * x * x * x\n#define swap(a, b) { tmp = a, a = b, b = tmp; }\nfloat triangleInertia(in vec2 a, in vec2 b, in vec2 c) {\n    vec2 low = a, mid = b, high = c, tmp; // Sort vertices by y coordinate\n    if (mid.y < low.y) swap(low, mid);\n    if (high.y < mid.y) {\n        if (high.y < low.y) swap(low, high);\n        swap(mid, high);\n    }\n\n    vec2 mid2 = low + (high - low) * (mid.y - low.y) / (high.y - low.y); // Point on the edge across from the middle vertex in y\n    vec4 split = mid2.x < mid.x ? vec4(mid2, mid) : vec4(mid, mid2);\n\n    // Lower wedge segment (1 is left, 2 is right) ---> an*y+bn\n    float a1 = (split.x - low.x) / (split.y - low.y);\n    float b1 = low.x - (split.x - low.x) / (split.y - low.y) * low.y;\n    float a2 = (split.z - low.x) / (split.w - low.y);\n    float b2 = low.x - (split.z - low.x) / (split.w - low.y) * low.y;\n\n    // Upper wedge segment (3 is left, 4 is right) ---> an*y+bn\n    float a3 = (high.x - split.x) / (high.y - split.y);\n    float b3 = split.x - (high.x - split.x) / (high.y - split.y) * split.y;\n    float a4 = (high.x - split.z) / (high.y - split.w);\n    float b4 = split.z - (high.x - split.z) / (high.y - split.w) * split.w;\n\n    // Combine both segments' moments of inertia\n    float I  = (1.0 / a2 - 1.0 / a4) * pow4(split.z) + (1.0 / a3 - 1.0 / a1) * pow4(split.x);\n          I += (1.0 / a1 - 1.0 / a2) * pow4(  low.x) + (1.0 / a4 - 1.0 / a3) * pow4( high.x);\n\n    I += 3.0 * ((a2 - a1) * (pow4(mid.y) - pow4(low.y)) + (a4 - a3) * (pow4(high.y) - pow4(mid.y)));\n    I += 4.0 * ((b2 - b1) * (pow3(mid.y) - pow3(low.y)) + (b4 - b3) * (pow3(high.y) - pow3(mid.y)));\n\n    return I / 12.0;\n}\n\n        /////////////////////////////////////////////////////////////////\n       //                                                            ////\n      //  \"little debugging font\"                                   // //\n     //                                                            //  //\n    //  This utility uses a small bitmapped font (3x5) to render  //   //\n   //  floats, primarily intended for debugging. The code can    //    //\n  //  be copy/pasta'd into the Common tab as needed.            //     //\n //                                                            //     //\n////////////////////////////////////////////////////////////////     //\n//                                                            //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike      //   //                                       //  //\n// 3.0 Unported License                                       //  //\n//                                                            // //\n// by Val \"valalalalala\" GvM 💃 2021                          ////\n//                                                            ///\n////////////////////////////////////////////////////////////////\n\nconst int CHARACTERS[14] = int[14](31599, 9362, 31183, 31207, 23524, 29671, 29679, 30994, 31727, 31719, 1488, 448, 2, 3640);\n\nfloat digitIsOn(in int digit, in vec2 id) {   \n    if (id.x < 0.0 || id.y < 0.0 || id.x > 2.0 || id.y > 4.0 ) return 0.0;\n    return floor(mod(float(CHARACTERS[int(digit)]) / pow(2.0, id.x + id.y * 3.0), 2.0));\n}\n\nfloat digitSign(in float v, in vec2 id) {\n    return digitIsOn(10 - int((sign(v) - 1.0) * 0.5), id);\n}\n\nint digitCount(in float v) {\n    return int(floor(log(max(v, 1.0) ) / log(10.0)));\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v, in int decimalPlaces) {\n    vec2 id = floor(uv * scale);\n\n    if (0.0 < digitSign(v, id)) return 1.0;\n    v = abs(v);\n\n    int digits = digitCount(v);\n    float power = pow(10.0, float(digits));\n    \n    float offset = floor(0.1 * scale);\n    id.x -= offset;\n\n    float n;\n    for (int i = 0; i < 33; i++, id.x -= offset, v -= power * n, power /= 10.0) {\n        n = floor(v / power);\n        if (0.0 < digitIsOn(int(n), id)) return 1.0;   \n        if (i == digits) {\n            id.x -= offset;\n            if (0.0 < digitIsOn(int(12), id)) return 1.0;\n        }\n\n        if (i >= digits + decimalPlaces) return 0.0;\n    }\n\n    return 0.0;\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v) {\n    return digitFirst(uv, scale, v, 3);\n}\n\nvec3 digitIn(in vec3 color, in vec3 toMix, in vec2 uv, in float scale, in float v) {\n    float f = digitFirst(uv, scale, v);\n    return mix(color, toMix, f);\n}", "buffer_a_code": "void mainImage(out vec4 data, in vec2 addr) {\n    data = vec4(0.0);\n    addr -= 0.5;\n    ivec2 iAddr = ivec2(addr);\n    if (iFrame > 0 && iAddr == ivec2(0)) {\n        data = texelFetch(iChannel0, ivec2(0), 0);\n\n        float ang = texelFetch(iChannel0, ivec2(0), 0).x;\n        float co = cos(ang), si = sin(ang);\n        mat2 rot = mat2(co, si, -si, co);\n\n        vec2 a = A * rot;\n        vec2 b = B * rot;\n        vec2 c = C * rot;\n\n        vec2 centerOfMass = (a + b + c) / 3.0;\n\n        vec2 force = vec2(0.0, -triangleMass(A, B, C, DENSITY) * GRAVITY);\n        float torque = cross2D(-centerOfMass, force);\n\n        data.y += torque / triangleInertia(A, B, C);\n        data.y *= FRICTION;\n        data.x += data.y;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slSXDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[402, 410, 469, 469, 581], [583, 583, 645, 645, 1262], [1344, 1344, 1399, 1399, 2114]], "test": "untested"}
{"id": "stSXDh", "name": "Mind wax", "author": "xenn", "description": "Yeah, another reiteration.\nCheck mouse! \n\nhttps://xemantic.github.io/shader-web-background/\n \nGoal: shadertoy-style shaders in regular web development\n", "tags": ["mouse", "background", "shadertoy", "feedback", "integration", "library", "web", "webdevelopment", "webdev", "javascript"], "likes": 11, "viewed": 401, "published": 3, "date": "1627520583", "time_retrieved": "2024-07-30T19:08:53.263978", "image_code": "\n// Fork of \"soft Colour\" by xenn. https://shadertoy.com/view/NtfXD7\n// 2021-07-14 22:39:31\n\n// Postprocess copied with some small modifications from Mattias: https://www.shadertoy.com/view/Ms23DR\n\nvec2 curve(vec2 uv)\n{\n\tuv = (uv - 0.5) * 2.0;\n\tuv *= 1.1;\t\n\tuv.x *= 1.0 + pow((abs(uv.y) / 5.0), 3.0);\n\tuv.y *= 1.0 + pow((abs(uv.x) / 4.0), 3.0);\n\tuv  = (uv / 2.0) + 0.5;\n\tuv =  uv *0.92 + 0.04;\n\treturn uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 uv = curve( q );\n    vec3 oricol = texture( iChannel2, vec2(q.x,q.y) ).xyz;\n    vec3 col;\n    vec3 sha = texture( iChannel1, vec2(q.x,q.y) ).xyz;\n   \n\tfloat x =  sin(0.3*iTime+uv.y*21.0)*sin(0.7*iTime+uv.y*29.0)*sin(0.3+0.33*iTime+uv.y*31.0)*0.0005 ;\n\n    col.r = texture(iChannel0,vec2(x+uv.x+0.001,uv.y+0.001)).x+0.05;\n    col.g = texture(iChannel0,vec2(x+uv.x+0.000,uv.y-0.002)).y+0.05;\n    col.b = texture(iChannel0,vec2(x+uv.x-0.002,uv.y+0.000)).z+0.05;\n    col.r += 0.08*texture(iChannel0,0.75*vec2(x+0.025, -0.027)+vec2(uv.x+0.001,uv.y+0.001)).x;\n    col.g += 0.05*texture(iChannel0,0.75*vec2(x+-0.022, -0.02)+vec2(uv.x+0.000,uv.y-0.002)).y;\n    col.b += 0.08*texture(iChannel0,0.75*vec2(x+-0.02, -0.018)+vec2(uv.x-0.002,uv.y+0.000)).z;\n    \n    float vig = (0.0 + 1.0*16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y));\n\tcol *= vec3(pow(vig,0.15));\n\n    col *= vec3(0.9,1.1,0.9);\n    \n\tfloat scans = clamp( 0.35+0.05*sin(3.5*iTime+uv.y*iResolution.y*1.5), 0.0, 1.0);\n\t\n\tfloat s = pow(scans,0.75);\n\tcol = col *vec3(0.4+0.7*s) * ( col + (oricol * (sha - oricol)));\n\n    col *= 1.0+0.035*sin(110.0*(iTime / .50));\n\n\tcol*=1.0-0.75*vec3(clamp((mod(fragCoord.x, 2.0)-1.0)*1.0,0.0,1.0));\n\t\n    float comp = smoothstep( 0.1, 0.9, sin(iTime) );\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 p = fragCoord.xy;\n    \n    vec2 uv = (p.xy) / iResolution.xy;\n    \n    //line thickness\n    float th = 0.025;\n    \n    //gradient detection for r,g and b separatly\n    //not sure why I did this actually\n    \n    float gxr = texture(iChannel0, uv.xy+vec2(th, 0.)).r\n    - texture(iChannel0, uv.xy-vec2(th, 0.)).r ;\n    \n    float gyr = texture(iChannel0, uv.xy+vec2(0., th)).r\n    - texture(iChannel0, uv.xy-vec2(0., th)).r;\n    \n    float gxg = texture(iChannel0, uv.xy+vec2(th, 0.)).g\n    - texture(iChannel0, uv.xy-vec2(th, 0.)).g ;\n    \n    float gyg = texture(iChannel0, uv.xy+vec2(0., th)).g\n    - texture(iChannel0, uv.xy-vec2(0., th)).g;\n    \n    float gxb = texture(iChannel0, uv.xy+vec2(th, 0.)).b\n    - texture(iChannel0, uv.xy-vec2(th, 0.)).b;\n    \n    float gyb = texture(iChannel0, uv.xy+vec2(0., th)).b\n    - texture(iChannel0, uv.xy-vec2(0., th)).b;\n    \n    //hack to concea noise from: https://www.shadertoy.com/view/Mdf3zr\n    float gr = gxr*gxr + gyr*gyr;\n    float gg = gxg*gxg + gyg*gyg;\n    float gb = gxb*gxb + gyb*gyb;\n    \n    //more noise control\n    float g = pow((gr+gg+gb)/1.,1.9);\n    \n    \n    vec3 col = texture(iChannel1, p / iResolution.xy).xyz;\n    col = mix(col,  0.5 + 0.5*cos(iTime*4.+uv.y*6.+vec3(0,2,4)),g*100.);\n    \n    fragColor = vec4(col,1.);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n//#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n\n// --- MATLAB Jet Colour Scheme ----------------------------------------\nvec3 spectral_jet(float w)\n{\n    // w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\tvec3 c;\n\n\tif (x < 0.25)\n\t\tc = vec3(0.0, 4.0 * x, 1.0);\n\telse if (x < 0.5)\n\t\tc = vec3(0.0, 1.0, 1.0 + 4.0 * (0.25 - x));\n\telse if (x < 0.75)\n\t\tc = vec3(4.0 * (x - 0.5), 1.0, 0.0);\n\telse\n\t\tc = vec3(1.0, 1.0 + 4.0 * (0.75 - x), 0.0);\n\n\t// Clamp colour components in [0,1]\n\treturn saturate(c);\n}\n", "buffer_b_code": "                                                                                                                                                                                                                                                                                        // See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .001;\nconst float iFeedbackFadeRate         = .997;\nconst float iFeedbackColorShiftZoom   = 0.1;\nconst float iFeedbackColorShiftImpact = -0.002;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = .09;\nconst float iBlobEdgeSmoothing        = .02;\nconst float iBlob1Radius              = .33;\nconst float iBlob1PowFactor           = 20.;\nconst float iBlob1ColorPulseSpeed     = -.044;\nconst float iBlob2Radius              = .44;\nconst float iBlob2PowFactor           = 20.;\nconst float iBlob2ColorPulseSpeed     = 0.023;\nconst float iBlob2ColorPulseShift     = 1.5;\nconst float iColorShiftOfRadius       = 1.5;\nconst float iFeedbackMouseShiftFactor = .003;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6 (\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.bg/colorShift.gr - .5) * iFeedbackColorShiftImpact  * (01.0*sin(iTime*0.31)) ;\n    stShift += iFeedbackShiftVector ;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel2, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n   vec3 extraColor = repeatedTexture(iChannel3, uv - stShift).rgb;\n    extraColor *= iFeedbackFadeRate;\n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n    color *  (extraColor * extraColor);\n\n    color -   clamp(color, 0., 2.5 );\n    fragColor = vec4(color, 1.);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// This buffer is the feedback loop\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Convert the uv's to polar coordinates to scale up  \n    vec2 polarUv = (uv * 2.0 - 1.0);\n    float angle = atan(polarUv.y, polarUv.x);\n    \n    // Scale up the length of the vector by a noise function feeded by the angle and length of the vector\n    float ll = length(polarUv)*0.4915+(0.1*sin(iTime/3.4));\n    \n    vec3 base = texture(iChannel0, uv).rgb;\n    \n    // Convert the scaled coordinates back to cartesian\n    vec2 offs = vec2(cos(angle)*ll + 0.5, sin(angle)*ll + 0.5);\n    \n    // sample the last texture with uv's slightly scaled up\n    vec3 overlay = texture(iChannel1,offs).rgb;\n\n        // Additively blend the colors together\n    vec4 col = vec4(base + overlay*(0.1+(0.1*cos(iTime/2.))), 01.0);\n    \n    fragColor = col;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Fork of \"spirit aura\" by xenn. https://shadertoy.com/view/7lSGzR\n// 2021-06-21 18:20:40\n\n/*\n\tFull Scene Radial Blur\n\t----------------------\n\n\tRadial blur - as a postprocessing effect - is one of the first things I considered doing \n\twhen the multipass system came out. I've always loved this effect. Reminds me of the early \n\tdemos from Aardbei et al. \n\n\tAnyway, Shadertoy user, Passion, did a really cool radial blur on a field of spheres that\n\tinspired me to do my own. Radial blurs are pretty straight forward, but it was still\n    helpful to have Passion's version as a guide. \n\n    As for the radial blur process, there's not much to it. Start off at the pixel position, \n    then radiate outwards gathering up pixels with decreased weighting. The result is a\n\tblurring of the image in a radial fashion, strangely enough. :)\n\n\tInspired by:\n\n\tBlue Dream - Passion\n\thttps://www.shadertoy.com/view/MdG3RD\n\n\tRadial Blur - IQ\n\thttps://www.shadertoy.com/view/4sfGRn\n\n\tRays of Blinding Light - mu6k\n\thttps://www.shadertoy.com/view/lsf3Dn\n\n*/\n\n// The radial blur section. Shadertoy user, Passion, did a good enough job, so I've used a\n// slightly trimmed down version of that. By the way, there are accumulative weighting \n// methods that do a slightly better job, but this method is good enough for this example.\n\n\n// Radial blur samples. More is always better, but there's frame rate to consider.\nconst float SAMPLES = 24.; \n\n\n// 2x1 hash. Used to jitter the samples.\nfloat hash( vec2 p ){ return fract(sin(dot(p, vec2(41, 289)))*45758.5453); }\n\n\n// Light offset.\n//\n// I realized, after a while, that determining the correct light position doesn't help, since \n// radial blur doesn't really look right unless its focus point is within the screen boundaries, \n// whereas the light is often out of frame. Therefore, I decided to go for something that at \n// least gives the feel of following the light. In this case, I normalized the light position \n// and rotated it in unison with the camera rotation. Hacky, for sure, but who's checking? :)\nvec3 lOff(){    \n    \n    vec2 u = sin(vec2(1.57, 0) - iTime/2.);\n    mat2 a = mat2(u, -u.y, u.x);\n    \n    vec3 l = normalize(vec3(1.5, 1., -0.5));\n    l.xz = a * l.xz;\n    l.xy = a * l.xy;\n    \n    return l;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // Screen coordinates.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Radial blur factors.\n    //\n    // Falloff, as we radiate outwards.\n    float decay = 0.97; \n    // Controls the sample density, which in turn, controls the sample spread.\n    float density = 0.5; \n    // Sample weight. Decays as we radiate outwards.\n    float weight = 0.1; \n    \n    // Light offset. Kind of fake. See above.\n    vec3 l = lOff();\n    \n    // Offset texture position (uv - .5), offset again by the fake light movement.\n    // It's used to set the blur direction (a direction vector of sorts), and is used \n    // later to center the spotlight.\n    //\n    // The range is centered on zero, which allows the accumulation to spread out in\n    // all directions. Ie; It's radial.\n    vec2 tuv =  uv - .5 - l.xy*.45;\n    \n    // Dividing the direction vector above by the sample number and a density factor\n    // which controls how far the blur spreads out. Higher density means a greater \n    // blur radius.\n    vec2 dTuv = tuv*density/SAMPLES;\n    \n    // Grabbing a portion of the initial texture sample. Higher numbers will make the\n    // scene a little clearer, but I'm going for a bit of abstraction.\n     vec4 colour = texture(iChannel2, uv.xy)*0.5;\n    vec4 col = texture(iChannel0, uv.xy)*0.75 * colour;\n   \n    // Jittering, to get rid of banding. Vitally important when accumulating discontinuous \n    // samples, especially when only a few layers are being used.\n    uv += dTuv*(hash(uv.xy + fract(iTime))*2. - 1.);\n    \n    // The radial blur loop. Take a texture sample, move a little in the direction of\n    // the radial direction vector (dTuv) then take another, slightly less weighted,\n    // sample, add it to the total, then repeat the process until done.\n    for(float i=0.; i < SAMPLES; i++){\n    \n        uv -= dTuv;\n        col += texture(iChannel1, uv) * weight;\n        col += texture(iChannel1, uv) * weight;\n        weight *= decay;\n        \n    }\n    \n    // Multiplying the final color with a spotlight centered on the focal point of the radial\n    // blur. It's a nice finishing touch... that Passion came up with. If it's a good idea,\n    // it didn't come from me. :)\n    col *= (1. - dot(tuv, tuv)*.75);\n    \n    // Smoothstepping the final color, just to bring it out a bit, then applying some \n    // loose gamma correction.\n    fragColor = sqrt(smoothstep(0., 1., col));\n    \n    // Bypassing the radial blur to show the raymarched scene on its own.\n    //fragColor = sqrt(texture(iChannel0, fragCoord.xy / iResolution.xy));\n}\n\n", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stSXDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[198, 198, 219, 219, 407], [409, 409, 466, 466, 1784]], "test": "untested"}
{"id": "Wllczj", "name": "trippy mandelbrot", "author": "unnick", "description": "a thing i made a while ago while playing with automatic differentiation", "tags": ["fractal", "mandelbrot", "ad", "automaticdifferentiation"], "likes": 4, "viewed": 294, "published": 3, "date": "1627509864", "time_retrieved": "2024-07-30T19:08:54.158586", "image_code": "#define res iResolution.xy\n#define tau 6.283\n\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvec4 _mul(vec4 a, vec4 b) { //multiply 2 dual-complex numbers\n    return vec4(\n        cmul(a.xy, b.xy),\n        cmul(a.xy, b.zw) + cmul(a.zw, b.xy)\n        //(a.x*b.z + a.z*b.x) - (a.y*b.w + a.w*b.y),\n        //(a.x*b.w + a.z*b.y) + (a.y*b.z + a.w*b.x)\n    );\n}\n\nvec2 csqr(vec2 z) {\n    return vec2(z.x*z.x - z.y*z.y, 2.*z.x*z.y);\n}\n\nvec4 _sqr(vec4 z) {\n    return vec4(csqr(z.xy), cmul(z.zw, z.xy * 2.));\n}\n\nvec2 cinv(vec2 z) {\n    return z / dot(z,z) * vec2(1,-1);\n}\n\nvec4 _inv(vec4 z) {\n    return vec4(\n        cinv(z.xy),\n        cmul(z.zw, -cinv(cmul(z.xy, z.xy)))\n    );\n}\n\nvec2 cexp(vec2 z) {\n    return vec2(cos(z.y), sin(z.y)) * exp(z.x);\n}\n\nvec4 _exp(vec4 z) {\n    vec2 tmp = cexp(z.xy);\n    return vec4(tmp, cmul(z.zw, tmp));\n}\n\nvec4 _log(vec4 z) {\n    return vec4(\n        log(dot(z.xy,z.xy)) * .5,\n        atan(z.y,z.x),\n        cmul(z.zw, cinv(z.xy))\n    );\n}\n\n// i havent tested these (or maybe i have and i forgot, i probably made this before even the world event)\nvec4 _sin(vec4 z) {\n    return _mul((_exp(_mul(z, vec4(0,1,0,0))) - _exp(_mul(z, vec4(0,-1,0,0)))), vec4(0,-.5,0,0));\n}\n\nvec4 _cos(vec4 z) {\n    return (_exp(_mul(z, vec4(0,1,0,0))) + _exp(_mul(z, vec4(0,-1,0,0)))) * .5;\n}\n\nvec4 _tan(vec4 z) {\n    return _mul(_sin(z), _inv(_cos(z)));\n}\n\nvoid mainImage(out vec4 col, in vec2 coord) {\n    col = vec4(0);\n    for(int smpl = 0; smpl < 3; smpl++) {\n        vec4 c = vec4(((coord + fract(vec2(.754877, .56984) * float(smpl)) - .5) * 2. - res) / res.y, 1, 0);\n        c = c * exp(-iTime) + vec4(-1.7465226,0.0000280,0,0);\n        vec4 z = vec4(0);\n        int i;\n        // lcm(1,2...8) is better known for other properties\n        for(i = 0; i < 420; i++) {\n            if(dot(z.xy,z.xy) > 1e3) break;\n            z = _sqr(z) + c;\n        }\n        float l = dot(z.xy, z.xy);\n        vec2 dl = mat2(z.zw * vec2(1,-1), z.wz) * z.xy;\n        dl /= l;\n        l = log(l);\n        dl /= l*.5;\n        l = log(l*.5);\n        col.rgb += (sqrt(cos((log(length(dl)) * .3 + iTime - vec3(0,1,2)/3.) * tau) * .5 + .5));\n        \n        //i dont know what these comments are for\n        \n        //* (max(dot(normalize(vec3(cos(iTime*tau),sin(iTime*tau),1)), vec3(normalize(dl), 1.) * sqrt(.5)), 0.) * .6 + .4);\n        //col = vec4(float(i) / 1000.);\n    }\n    col /= 3.;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wllczj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 73, 73, 130], [132, 132, 159, 193, 394], [396, 396, 415, 415, 465], [467, 467, 486, 486, 540], [542, 542, 561, 561, 601], [603, 603, 622, 622, 712], [714, 714, 733, 733, 783], [785, 785, 804, 804, 872], [874, 874, 893, 893, 1007], [1009, 1115, 1134, 1134, 1234], [1236, 1236, 1255, 1255, 1337], [1339, 1339, 1358, 1358, 1401], [1403, 1403, 1448, 1448, 2423]], "test": "untested"}
{"id": "ftBSDh", "name": "大龙猫 - Quicky#057", "author": "totetmatt", "description": "Quicky ", "tags": ["quicky"], "likes": 5, "viewed": 310, "published": 3, "date": "1627495644", "time_retrieved": "2024-07-30T19:08:54.923541", "image_code": "#define fGlobalTime iTime\n#define timer(a,b,c) (mix(a,b,(asin(sin(c*fGlobalTime))) + 3.1415/2.)/3.1415 )\n#define timer1 timer(0.5,1.,.5)\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\n// No big diff I guess deep investigation is needed to determine the faster version\nfloat sminEvil(float a,float b,float k){ float h=max(0.,k-abs(a-b));return min(a,b)-0.25*h*h/k;}\nfloat sminMercury(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\nfloat box(vec3 p, vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(vec3(0.),q))+min(0.,max(q.x,max(q.y,q.z)));\n}\nfloat diam(vec3 p,float s){\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*sqrt(1./3.);\n  }\nfloat sqq(vec3 p){\n  float g = 1.;\n  vec4 pp = vec4(p,1.);  \n  for(float i=0.;i<=4.;i++){\n         pp.xz = abs(pp.xz)-.55;\n         pp*=1.2;\n         pp.zy *=rot(-.33*i);\n         g = min(g,clamp(sin(pp.x*.5)*sin(pp.y*.66)+cos(pp.z*2.),-.5,.5)/pp.a);\n        \n      }\n  return min(length(p.xy)-.5,min(length(p.xz)-.5,length(p.yz)-.5))-g;\n  }\nvec2 sdf(vec3 p){\n  \n  p.yz =mix(p.yz,p.yz*rot(atan(inversesqrt(2.))),timer1);\n  p.xz =mix(p.xz,p.xz*rot(3.1415/4.),timer1);\n  \n  vec2 h;\n  float q = 1.;\n  for(float i=0.;i<=2.;i++){\n       p.xz = abs(p.xz)-2.5;\n       p.xz*=1.22;\n       q*=1.23;\n       p.x +=1.;\n       p.xy =p.x < p.y ? p.yx:p.xy;\n       p.xz*=rot(.785);\n    }\n  h.x = sqq(p);\n  h.x = sminEvil(h.x,diam(p,2.),.5+cos(p.y*10.))/(q*1.5);\n  h.y = 1.+cos(p.y*10.);\n   return h;\n }\n \n#define q(s) s*sdf(p+s).x\n vec2 e= vec2(-.003,.003);\n vec3 norm(vec3 p){return normalize(q(e.xyy)+q(e.yxy)+q(e.yyx)+q(e.xxx));}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n   \n\tvec3 col =vec3(0.);\n  vec3 ro = vec3(0.,0.,-5.+4.*sin(fGlobalTime));\n  vec3 rt = vec3(-1.,1.,0.);\n  vec3 z = normalize(rt-ro);\n  vec3 x = normalize(cross(z,vec3(0,-1.,0.)));\n  vec3 y = normalize(cross(z,x));\n  \n  vec3 rd = mat3(x,y,z)*normalize(vec3(uv,1.));\n\n  ro = mix(ro,vec3(uv*5.,-30.),timer1);\n\n  rd = mix(rd,vec3(0.,0.,1.),timer1);\n\n  vec3 light = vec3(1.,0.,-10.);\n  vec3 rp =ro;\n  vec3 acc = vec3(0.);\n  for(float i=0.;i<=128.;i++){\n      vec2 d = sdf(rp);\n    if(d.y < 1.){\n         acc+=vec3(.1,.7,.4)*max(0.,exp(10.*-abs(d.x)))/(60.+sin(rp.z*10.+fGlobalTime*10.)*30.);\n      d.x = max(.002,abs(d.x));\n      }    \n    rp+=d.x*rd;\n    \n    if(length(rp)>100.)break;\n      if(d.x<=0.001){\n          vec3 n = norm(rp);  \n          col = vec3(.6,.5,1.5)*sqrt(1.-i/128.)*max(0.,dot(normalize(light-rp),n));\n        break;\n      }\n    \n    \n  }\n  col +=acc;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftBSDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[137, 137, 155, 155, 202], [203, 287, 327, 327, 383], [384, 384, 430, 430, 515], [516, 516, 542, 542, 633], [634, 634, 661, 661, 721], [722, 722, 740, 740, 1063], [1064, 1064, 1081, 1081, 1508], [1565, 1565, 1583, 1583, 1638], [1639, 1639, 1696, 1746, 2732]], "test": "untested"}
{"id": "flSXWh", "name": "minimum implementation of d2d", "author": "yasuo", "description": "my private stuff. I just wanted to do this from scratch.", "tags": ["distance2d"], "likes": 5, "viewed": 303, "published": 3, "date": "1627488941", "time_retrieved": "2024-07-30T19:08:55.755317", "image_code": "// The minimum implementation of the distance 2D utilities for private use.\n// I guess most of the stuff is similar implementation someone has done.\n// The following distance functions can not use the round shape technique and etc...\n#define USE_MOUSE 0\n#define S(p,d,b) smoothstep(fwidth(p.y),b,d)\n#define M() (iMouse.xy-0.5*iResolution.xy)/iResolution.y\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define Tri(p,s,a) max(-dot(p,vec2(cos(-a),sin(-a))),max(dot(p,vec2(cos(a),sin(a))),max(abs(p).x-s.x,abs(p).y-s.y)))\n#define Slice(p,a) dot(p,vec2(cos(a),sin(a)))\n\n#define SliceB(p,a,b,s) max(-dot(p-a,vec2(cos(b),sin(b))),max(abs(p).x-s,abs(p).y-s))\nfloat customTri(vec2 p, vec2 a, vec2 b, vec2 c){\n    float s = 1.0;\n    float d = max(SliceB(p,b,-atan(b.x-a.x,b.y-a.y),s),SliceB(p,b,-atan(c.x-b.x,c.y-b.y),s));\n    return max(SliceB(p,c,-atan(a.x-c.x,a.y-c.y),s),d);\n}\n\nfloat bevelCornerBox(vec2 p, vec2 s, float k, float deg){\n    float d = max(abs(p).x-s.x,abs(p).y-s.y);\n    float a = radians(deg);\n    p = abs(p);\n    p-=s/k;\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    return d;\n}\n\n// taper box\nfloat taperBox(vec2 p, vec2 s, float l, float r){\n    float d = max(abs(p).x-s.x,abs(p).y-s.y);\n    float al = radians(-l);\n    float ar = radians(r);\n    d = max(-dot(p-vec2(-s.x*0.5,0.0),vec2(cos(al),sin(al))),d);\n    d = max(dot(p-vec2(s.x*0.5,0.0),vec2(cos(ar),sin(ar))),d);\n    return d;\n}\n\n// I won't recommend using the following distance 2d line. This implementation is straight foward. Please use the Iq's sdLine is the best one.\n// This one is for me to use. I just wanted to create a distance line by myself.\nfloat dLine(vec2 p, vec2 a, vec2 b, float w){\n    vec2 v = normalize(b-a);\n    vec2 right = normalize(cross(vec3(v,0.0),vec3(0.0,0.0,1.0)).xy);\n    vec2 newRightVec = right*(w*0.5);\n    vec2 a1 = a+newRightVec, a2 = a-newRightVec, b1 = b+newRightVec, b2 = b-newRightVec;\n    vec2 mida = vec2((a1.x + b1.x) * 0.5, (a1.y + b1.y) * 0.5);\n    vec2 midb = vec2((a2.x + b2.x) * 0.5, (a2.y + b2.y) * 0.5);\n    \n    float rad1 = -atan(b1.x-a1.x,b1.y-a1.y);\n    float rad2 = -atan(a2.x-a1.x,a2.y-a1.y);\n    \n    float mad = Slice(p-mida,rad1);\n    float mbd = Slice(p-midb,rad1);\n    \n    float ad = Slice(p-a,rad2);\n    float bd = Slice(p-b,rad2);\n    float d = max(max(mad,-mbd),max(-ad,bd));\n    return d;\n}\n\nfloat drawExample(vec2 p){\n    // i.e. draw circle\n    float d = length(p-vec2(-0.75,0.0))-0.1;\n    \n    // i.e. draw box\n    float d2 = B(p-vec2(-0.5,0.0),vec2(0.1));\n    d = min(d,d2);\n    d2 = B(p-vec2(-0.3,0.0),vec2(0.05,0.1));\n    d = min(d,d2);\n    \n    // i.e. draw triangle\n    d2 = Tri(p-vec2(-0.09,0.1),vec2(0.2),radians(30.0));\n    d = min(d,d2);\n    \n    d2 = customTri(p,vec2(0.15,0.1),vec2(0.3,0.0),vec2(0.08,-0.1));\n    d = min(d,d2);\n    \n    // i.e. draw bevel corner box\n    d2 = bevelCornerBox(p-vec2(0.45,0.0),vec2(0.1,0.1),1.3,45.0);\n    d = min(d,d2);\n    \n    // i.e. draw taper box\n    d2 = taperBox(p-vec2(0.72,0.0),vec2(0.2,0.1),-10.0,-10.0);\n    d = min(d,d2);\n    return d;\n}\n\nfloat demo(vec2 uv){\n    vec2 prevUV = uv;\n    float d = 100.0;\n    uv+=(uv/length(uv*1.6))*sin(length(uv*1.6)*5.0-iTime*2.0)*0.05+cos(length(uv*1.6)*5.0-iTime*2.0)*0.05; \n    uv.x+=sin(uv.y+iTime*0.3)*0.8*cos(uv.x+iTime*0.6)*0.7;\n    for(float i = 0.0; i<2.0; i+=0.05){\n        d = min(abs(length(uv)-i)-0.0001,d);\n    }\n    \n    uv.y = mod(uv.y,0.05)-0.025;\n    float d2 = dLine(uv,vec2(-2.0,0.0),vec2(2.0,0.0),0.001);\n    \n    float t = mod(iTime,20.0);\n    float morph = 0.0;\n    if(t>=7.0 && t<10.0){\n        float now = t-7.0;\n        morph = (now/3.0)*1.0; \n    } else if(t>=10.0 && t<17.0){\n        morph = 1.0;\n    } else if(t>=17.0 && t<20.0){\n        float now = t-17.0;\n        morph = 1.0-(now/3.0)*1.0;\n    }\n    \n    return mix(d,d2,morph);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.0);\n    vec2 m = M();\n\n    // xy axis\n    float d = dLine(uv,vec2(0.0,0.5),vec2(0.0,-0.5),0.001);\n    d = min(d,dLine(uv,vec2(-1.0,0.0),vec2(1.0,0.0),0.001));\n    col = mix(col,vec3(0.6,0.0,0.0),S(uv,d,0.0));\n\n    // test demo\n    d = demo(uv);\n    col = mix(col,vec3(0.9),S(uv,d,0.0));\n    \n    // draw example shape\n    d = drawExample(uv-vec2(0.0,0.35));\n    col = mix(col,vec3(1.0),S(uv,d,0.0));\n    \n    // i.e. outline\n    d = drawExample(uv-vec2(0.0,-0.35));\n    col = mix(col,vec3(1.0),S(uv,abs(d)-0.001,0.0));\n    \n    #if USE_MOUSE\n    // i.e. draw line\n    vec2 a = vec2(0.0), b = m;\n    float w = 0.05+abs(sin(iTime)*0.1); // for test\n    d = dLine(uv,a,b,w);\n    col = mix(col,vec3(0.9),S(uv,d,0.0));\n    \n    // draw points\n    d = min(B(uv-a,vec2(0.01)),B(uv-b,vec2(0.01)));\n    col = mix(col,vec3(1.0,0.0,0.0),S(uv,d,0.0));    \n    #endif\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flSXWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[652, 652, 700, 700, 871], [873, 873, 930, 930, 1091], [1093, 1106, 1155, 1155, 1400], [1402, 1626, 1671, 1671, 2327], [2329, 2329, 2355, 2379, 3032], [3034, 3034, 3054, 3054, 3791], [3793, 3793, 3850, 3850, 4826]], "test": "untested"}
{"id": "stjSWz", "name": "Gyroidal Gyroid Sphere", "author": "tholzer", "description": "interactive gyroidal gyroid sphere (play with me)        great shader originally made by Kamoshika\n\nmouse.x  sphere size,    mouse.y  change thickness", "tags": ["raymarching", "sphere", "gyroid"], "likes": 34, "viewed": 749, "published": 3, "date": "1627476268", "time_retrieved": "2024-07-30T19:08:56.530246", "image_code": "// Fork of \"Gyroid Sphere\" by Kamoshika. https://shadertoy.com/view/sljXz1\n// 2021-07-28 12:18:10\n\n// https://twitter.com/kamoshika_vrc/status/1418594024475136002\n\n#define D(p) abs(dot(sin(p), cos(p.yzx)))\n\nvec2 mp = vec2(0);\n\nmat3 rotate3D(float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    return mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n}\n\nvec3 hsv(float h, float s, float v) {\n    vec4 a = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(h) + a.xyz) * 6.0 - vec3(a.w));\n    return v * mix(vec3(a.x), clamp(p - vec3(a.x), 0.0, 1.0), s);\n}\n\nfloat map(vec3 p) {\n    float d = length(p) - 1.8 + mp.x;\n    p *= 10.;\n    d = max(d, (D(p) - .08) / 10.);\n    p *= 10.;\n    d = max(d, (D(p) - .4 - 1.1*mp.y) / 100.);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) /min(iResolution.x, iResolution.y);\n         mp = (iMouse.xy / iResolution.xy);\n    vec3 col = vec3(0);\n    \n    mat3 cRot = rotate3D(iTime*0.1, vec3(1, 1, 1));\n    vec3 cPos = vec3(0, 0, 2) * cRot;\n    vec3 cDir = normalize(-cPos);\n    vec3 cSide = normalize(cross(cDir, vec3(0, 1, 0) * cRot));\n    vec3 cUp = normalize(cross(cSide, cDir));\n    vec3 ray = normalize(uv.x*cSide + uv.y*cUp + cDir*2.);\n    \n    vec3 rPos = cPos;\n    float d = 0.;\n    float c = 0.;\n    for(int i=0; i<99; i++) {\n        d = map(rPos);\n        if(d < 1e-4) {\n            break;\n        }\n        rPos += ray * d * .6;\n        c++;\n    }\n    col += hsv(.3 - length(rPos), .7, 20./c);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stjSWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[227, 227, 265, 265, 674], [676, 676, 713, 713, 892], [894, 894, 913, 913, 1078], [1080, 1080, 1137, 1137, 1888]], "test": "untested"}
{"id": "7l2XWR", "name": "Chaos Wheel", "author": "oneshade", "description": "An excuse to improve my understanding of rotation physics.\nRecreation of the cool animation from this video: [url=https://www.youtube.com/watch?v=6z4qRhpBIyA[https://www.youtube.com/watch?v=6z4qRhpBIyA[/url]", "tags": ["2d", "animation", "chaos", "physics"], "likes": 24, "viewed": 290, "published": 3, "date": "1627467003", "time_retrieved": "2024-07-30T19:08:57.503643", "image_code": "// SDFs\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - t;\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    p = abs(p) - b;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\n}\n\nfloat sdIsosceles(in vec2 p, in float b, in float h) {\n    p.x = abs(p.x);\n    float q = clamp((b - p.x + p.y) / (b + h), 0.0, 1.0);\n    vec2 re = vec2(p.x - b + b * q, p.y - h * q);\n    vec2 be = vec2(p.x - b * min(p.x / b, 1.0), p.y);\n    return sqrt(min(dot(re, re), dot(be, be))) * sign(p.x + (p.y - h) * b / h * sign(p.y));\n}\n\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y + vec2(0.0, 0.5 * BUCKET_SIZE.y);\n    float unit = 2.0 / iResolution.y;\n    vec3 color = texture(iChannel1, fragCoord / iResolution.xy).rgb;\n\n    // Wheel spokes\n    float wheelAngle = texelFetch(iChannel0, ivec2(0, 1), 0).x;\n    float co = cos(wheelAngle), si = sin(wheelAngle);\n    vec2 wheelUv = uv * mat2(co, si, -si, co);\n    float ang = mod(atan(wheelUv.y, wheelUv.x) + PI / BUCKETS, TAU / BUCKETS) - PI / BUCKETS;\n    wheelUv = vec2(cos(ang), sin(ang)) * length(wheelUv) - vec2(0.5 * WHEEL_RADIUS, 0.0);\n    drawSDF(sdBox(wheelUv, vec2(WHEEL_RADIUS, SPOKE_WIDTH) * 0.5), vec3(0.75, 0.4, 0.0));\n\n    float mask = 1e20;\n    vec2 maskPos = vec2(0.0);\n    for (float n=0.0; n < BUCKETS; n++) {\n        float bucket = texelFetch(iChannel0, ivec2(n, 0), 0).x;\n        vec2 waterLevel = BUCKET_SIZE * clamp(bucket, 0.001, 0.999); // clamp(0.001, 0.999) to avoid divide by zero in sdIsosceles()\n        float ang = TAU * n / BUCKETS + wheelAngle;\n        vec2 pos = vec2(cos(ang), sin(ang)) * WHEEL_RADIUS;\n\n        // Check before setting it as the spout mask\n        float shape = sdIsosceles(pos - uv + vec2(0.0, BUCKET_SIZE.y), BUCKET_SIZE.x, BUCKET_SIZE.y);\n        if (pos.x > -BUCKET_SIZE.x && pos.x < BUCKET_SIZE.x && pos.y > 0.0 && shape < mask) {\n            mask = shape;\n            maskPos = pos;\n        }\n\n        // Draw the bucket\n        drawSDF(shape, vec3(0.5));\n        drawSDF(sdIsosceles(pos - uv + vec2(0.0, waterLevel.y), waterLevel.x, waterLevel.y), vec3(0.0, 1.0, 1.0));\n    }\n\n    if (mask < 1e10) drawSDF(max(sdBox(uv - vec2(0.0, 0.55), vec2(0.01, 1.0)), min(mask, maskPos.y + BUCKET_SIZE.y - uv.y)), vec3(0.0, 1.0, 1.0));\n    drawSDF(sdBox(uv - vec2(0.0, 0.55), vec2(0.02, 0.025)), vec3(0.5));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Constants\n#define PI 3.14159265359\n#define TAU 6.28318530718\n\n// Settings\n#define BUCKETS 8.0\n#define BUCKET_SIZE vec2(0.08, 0.15)\n\n#define WHEEL_RADIUS 0.3\n#define SPOKE_WIDTH 0.015\n#define WHEEL_DENSITY 0.02\n\n// ∫r^2dm = ∫∫(x^2+y^2) dy dx (x in range [0...WHEEL_RADIUS] and y in range [-SPOKE_WIDTH/2...SPOKE_WIDTH/2])\n#define WHEEL_INERTIA ((4.0 * SPOKE_WIDTH * pow(WHEEL_RADIUS, 3.0) + pow(SPOKE_WIDTH, 3.0) * WHEEL_RADIUS) / 12.0 * BUCKETS)\n\n#define WHEEL_FRICTION 0.95\n\n#define FILL_RATE 0.018\n#define DRAIN_RATE 0.0015\n#define FLUID_DENSITY 0.02\n\n#define GRAVITY 0.1", "buffer_a_code": "// Simulation\nvoid mainImage(out vec4 data, in vec2 addr) {\n    data = vec4(0.0);\n    addr -= 0.5; // Once again I am reminded that fragment coordinates weirdly go from (0.5, 0.5) to iResolution.xy+0.5\n    ivec2 iAddr = ivec2(addr);\n    if (iFrame == 0) {\n        if (iAddr.x == 0 && iAddr.y == 1) data.x = 0.05;\n        if (iAddr.x == 2 && iAddr.y == 0) data.x = 0.75;\n    }\n\n    if (iFrame > 0) {\n        data = texelFetch(iChannel0, iAddr, 0);\n        if (addr.x < BUCKETS && iAddr.y == 0) {\n            float ang = TAU * addr.x / BUCKETS + texelFetch(iChannel0, ivec2(0, 1), 0).x;\n            vec2 pos = vec2(cos(ang), sin(ang)) * WHEEL_RADIUS;\n\n            // Fill and drain\n            if (pos.x > -BUCKET_SIZE.x && pos.x < BUCKET_SIZE.x && pos.y > 0.0) data.x = min(1.0, data.x + FILL_RATE);\n            else data.x = max(0.0, data.x - DRAIN_RATE);\n        }\n\n        if (iAddr == ivec2(0, 1)) {\n            float torque = 0.0; // Angular equivalent of force\n            for (float n=0.0; n < BUCKETS; n++) {\n                float bucket = texelFetch(iChannel0, ivec2(n, 0), 0).x;\n                float ang = TAU * n / BUCKETS + data.x;\n                float mass = 0.5 * BUCKET_SIZE.x * BUCKET_SIZE.y * bucket * bucket * FLUID_DENSITY;\n                //vec2 force = vec2(0.0, -mass * GRAVITY);\n                //float tangentialForce = force.y * cos(ang) - force.x * sin(ang); // Project the force onto the spoke\n                float tangentialForce = -mass * GRAVITY * cos(ang);\n                torque += tangentialForce * WHEEL_RADIUS;\n            }\n\n            data.y += torque / WHEEL_INERTIA; // Angular equivalent to accel=force/mass\n            data.y *= WHEEL_FRICTION;\n            data.x += data.y;\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Simulation recording\n#define drawSDF(dist, color) \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y + vec2(0.0, 0.5 * BUCKET_SIZE.y);\n    float unit = 3.0 / iResolution.y;\n    fragColor = texture(iChannel1, fragCoord / iResolution.xy);\n\n    float time = iTime * 0.05 - 0.5 * iResolution.x / iResolution.y;\n    if (time > 0.0 && iFrame % 3 == 0) fragColor = texture(iChannel1, (fragCoord + vec2(1.0, 0.0)) / iResolution.xy);\n\n    float wheelAngVel = texelFetch(iChannel0, ivec2(0, 1), 0).y;\n    float point = length(uv - vec2(min(0.0, time), wheelAngVel * 5.0)) - 0.001;\n    fragColor.rgb = mix(fragColor.rgb, vec3(1.0, 0.0, 0.5), smoothstep(unit, 0.0, point));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l2XWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 8, 67, 67, 179], [181, 181, 216, 216, 296], [298, 298, 352, 352, 628], [710, 710, 765, 765, 2590]], "test": "untested"}
{"id": "7t2SWR", "name": "cheese_FirstToy", "author": "lokichen", "description": "toy", "tags": ["first"], "likes": 1, "viewed": 202, "published": 3, "date": "1627461742", "time_retrieved": "2024-07-30T19:08:58.276576", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    col.r = cos(iTime)*0.5+0.5;\n    col.g = sin(iTime)*0.5+0.5;\n    col.b = cos(iTime)*0.5+0.5;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t2SWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 395]], "test": "untested"}
{"id": "ft2XDz", "name": "大龙猫 - Du Grand Nawak", "author": "totetmatt", "description": "Done during MonsieurSoleil Shader Coding Party. Somehow close to bonzo (you're used to it now, can't reduce my fft consumption :D )", "tags": ["jam"], "likes": 13, "viewed": 339, "published": 3, "date": "1627458217", "time_retrieved": "2024-07-30T19:08:59.043525", "image_code": "#define lim 5.\n#define fGlobalTime iTime\n#define qq mod(fGlobalTime,10.)<5.\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat box(vec3 p,vec3 b){\n       vec3 q = abs(p)-b;\n       return length(max(vec3(0.),q))+min(0.,max(q.x,max(q.y,q.z)));\n}\nfloat bbox(vec3 p){\n    //p.xz *=rot(sin(fGlobalTime)*-.785);\n    float h = box(p,vec3(1.));\n    h = max(abs(p.z)-.1,abs(h)-.1);\n  return h;\n}\nvec2 sdf(vec3 p){\n  \n  vec3 op ;\n  \n  if(qq){\n    \n     p.xy *=rot(p.z*.1);\n   p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(3.1415/4.);\n    op=p;\n     p.y+=mix(0.,1.,fract(iTime));\n      p.xy = asin(sin(p.xy)*(.8));\n  } else {\n    op=p;\n      p.z+=mod(fGlobalTime,100.);;\n    p.z /=1.;\n   \n   \n     p.z = asin(sin(p.z)*.8);\n    \n    p.z*=1.;\n     \n    \n    }\n\n   \n    vec2 h;\n  //h.x= mix(box(p,vec3(1.)),length(p)-1.,sin(p.x*(1.+texture(texFFT,abs(p.y)*.1).r*10.)+fGlobalTime));\n  h.x = bbox(p);\n       float a=.25*abs(floor(fract(iTime*1.)*10.)/10.);\n     float rto = dot(vec2(1,1),vec2(1,0)*rot(3.1415*a));\n  \n   vec4 pp = vec4(p,1.);\n \n      h.y = 1.;\n   for(float i=0.;i<=lim;i++){\n          pp.xy*=rot(a*3.1415);\n          pp*=rto;\n          vec2 t;\n          t.x = bbox(pp.xyz)/pp.a;\n          t.y = 1.+i/lim;\n          h = t.x < h.x ? t:h;\n     }\n     vec2 t;\n     vec3 oop = op;\n     oop.xy =- abs(oop.xy)+1.2;\n      oop.x+=(sin(oop.z+fGlobalTime));\n     oop.y += (cos(oop.z+fGlobalTime*.1));\n       oop.xy =- abs(oop.xy)+1.2;\n      t.x = abs(length(oop.xy)-.1)-.1;\n      t.y = 2.; \n      h = t.x < h.x ? t:h;\n      op.xy *=rot(fGlobalTime*.2);\n         op = abs(op)-1.1;\n     op.xz *=rot(fGlobalTime);\n      \n    \n     \n  return h;\n  \n}\n#define q(s) s*sdf(p+s).x\nvec2 e=vec2(.0003,-.0003);\nvec3 norm(vec3 p){return normalize(q(e.xyy)+q(e.yxy)+q(e.yyx)+q(e.xxx));}\nvec3 pal(float t){return .5+.5*cos(6.28*(1.*t+vec3(.1,.2,.3)));}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n   \n  bool bounce = false;\n  vec3 col = vec3(.1);//sqrt(vec3(texture(texFFT,abs(uv.x)).r));\n \n  vec3 ro = vec3(0.,0.,-5.);\n  vec3 rd = normalize(vec3(uv,1.));\n   if(qq) {\n     \n     ro = vec3(uv*7.,-10.);\n     rd = vec3(0,0,1);\n     }\n  vec3 light = vec3(1.,2.,-3.);\n  vec3 rp =ro;\n     vec3 acc = vec3(.0);\n     float tt =mod(iTime*.1,10.);\n     float ttt =mod(iTime*.07,10.);\n     float tq = 0.;\n  for(float i=0.;i<=69.;i++){\n      vec2 d = sdf(rp);\n    \n         if(d.y == 1.+floor(fract(tt*4.)*10.)/lim) { \n           tq+= exp(-abs(d.x))/10.;\n           acc += pal(ttt)*1.5*exp(-abs(d.x))/(10.+sin(length(rp.xy)*10.)*5.);\n           d.x = max(abs(d.x),.001);\n           \n           } \n            if(d.y ==2.) { \n           tq+= exp(-abs(d.x))/10.;\n           acc += pal(rp.z*.1+ttt)*exp(-abs(d.x))/(60.-fract(fGlobalTime*.5+rp.z)*30.);\n           d.x = max(abs(d.x),.01);\n           \n           } \n       rp +=rd * d.x;\n       if(length(rp)>100.) break;\n       \n       if(d.x <.001){\n          vec3 n = norm(rp);\n          if(d.y >= 1.){\n             float angle = max(dot(reflect(normalize(light), n), rd), 0.0);\n  float specular = pow(angle, 10.0);\n            vec3 c = pal(d.y+texture(iChannel0,rp.xy*.1+fGlobalTime).r*.01);\n          col = specular*c+c*max(0.,dot(normalize(light-rp),n));; \n         break;\n          } else {\n               rd = reflect(rd,n+texture(iChannel0,rp.xy).r*.01);\n             rp+=rd*.01;\n            acc += pal(d.y)*.1;\n            bounce = true;\n            }\n          \n         }\n    \n  }\n  col+= +acc;\n  if(bounce) col = 1.-col;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft2XDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 94, 94, 141], [142, 142, 167, 167, 264], [265, 265, 284, 326, 407], [408, 408, 425, 425, 1658], [1712, 1712, 1730, 1730, 1785], [1786, 1786, 1804, 1804, 1850], [1851, 1851, 1908, 1958, 3622]], "test": "untested"}
{"id": "fl2XDR", "name": "Participating Media Test", "author": "milesWaugh", "description": "A test", "tags": ["montecarlo", "volumetrics"], "likes": 14, "viewed": 578, "published": 3, "date": "1627441333", "time_retrieved": "2024-07-30T19:08:59.871312", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//HASH BY DAVE HOSKINS\n//https://www.shadertoy.com/view/4djSRW\nvec3 rnd(vec3 p3) {\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yxx) * p3.zyx);\n\n}\n\nfloat noise(vec3 z) {\n    float x = texture(iChannel0, z * .1).r * 2.;\n    x += texture(iChannel0, z * .2).r;\n    x += texture(iChannel0, z * .4).r * .7;\n    x += texture(iChannel0, z * .8).r * .4;\n    x *= 0.6;\n    return x;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    vec3 col = vec3(0.);\n    vec3 inc = normalize(vec3(uv, .5));\n    vec3 contribution = vec3(1.);\n    vec3 radt = vec3(0.);\n    float dmag = 0.0001;\n    vec3 dz = normalize(vec3(1., 1., -.5)) * dmag;\n\n    float rl = 0.;\n    for(int i = 0; i < 100; i++) {\n        rl += 0.02;\n        vec3 z = inc * rl - vec3(0., 0., 2.);\n        float density = max(.5 - dot(z, z) + noise(z), 0.) * .15;\n        vec3 l = normalize(rnd(z * 1000. + iTime) - 0.5);\n        dz = l * dmag;\n        float dens2 = max(.5 - dot(z + dz, z + dz) + noise(z), 0.) * .15;\n        vec3 t = texture(iChannel1, l).rgb;\n        t = pow(t, vec3(5.));\n        vec3 chd = max((density - dens2) / dmag, 0.) * t * 200.;\n        vec3 rad = chd;\n        float d = exp(-density);\n        contribution *= d;\n        radt += contribution * rad * density;\n    }\n\n    vec3 tex = texture(iChannel1, inc).rgb;\n    tex *= tex;\n    col = contribution * tex + radt;\n    col *= 3.;\n    col = col / (col + 1.);\n    col = smoothstep(0., 1., col);\n    col = sqrt(col);\n\n    fragColor = (vec4(col, 1.0) + texture(iChannel2, fragCoord / iResolution.xy) * float(iFrame)) / (float(iFrame) + 1.);\n}", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl2XDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 172]], "test": "untested"}
{"id": "stSXDR", "name": "data flowing animation", "author": "yasuo", "description": "data flowing", "tags": ["animation"], "likes": 4, "viewed": 376, "published": 3, "date": "1627408283", "time_retrieved": "2024-07-30T19:09:00.689126", "image_code": "#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(234.56,789.34));\n    p+=dot(p,p+34.56);\n    return fract(p.x+p.y);\n}\n\nvec3 randomPlot(vec2 p, vec3 col, float t){\n    p*=20.0;\n    p.x+=t;\n    vec2 gv = fract(p)-0.5;\n    vec2 id = floor(p);\n    gv.y = id.y;\n    \n    float n = Hash21(id);\n    float w = clamp(0.25*(n*2.0),0.1,1.0);\n    float d = B(gv,vec2(w,0.02));\n    float cn = clamp(n,0.5,1.0);\n    col = mix(col,vec3(cn,cn,cn),S(d,0.0));\n    return col;\n}\n\nconst float speeds[14] = float[](2., 3., 6., 3.5, 5., 7., 4.5, 7.5, 8.0, 9., 2.5, 6.5,10.0,5.3);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.0);\n    \n    float index = 0.07;\n    for(int i = 0; i<14; i++){\n        vec2 pos = uv+vec2(index,-0.5+(index));\n        col = randomPlot(pos, col, iTime*speeds[i]);\n        index+=0.07;\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stSXDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 177, 177, 267], [269, 269, 312, 312, 609], [708, 708, 765, 765, 1074]], "test": "untested"}
{"id": "fl2XRm", "name": "Dancing Cube Field (Visualiser)", "author": "Pelegefen", "description": "!EPILEPSY WARNING!!!!\n_More options in the defines!_\n\nas per tradition by now- a visualiser on the hexagonally tilled domain i used for the snowflake.\nthe cubes are fake shaded, and the wave is reading the sound data and tuning in to specific frequancies.", "tags": ["waves", "interactive", "cube", "hexagon", "snowflake", "hexagonal", "tilling"], "likes": 9, "viewed": 454, "published": 3, "date": "1627400266", "time_retrieved": "2024-07-30T19:09:01.549824", "image_code": "//!!!!!!!!EPILEPSY WARNING!!!!!!!FLASHING LIGHTS!!!!!!!!!!\n\n//Made with love by Peleg Gefen <3\n\n//song - Warp9 - Seems Like A Dream\n\n\n\n//----------------------------------DEFINES------------------------------------------------\n\n//#define Time_And_Zoom //SEIZURE INDUCING LOL - Allows you to use the horizontal mouse axis to \"peek into the future\" to\n//see the full evolution of the wave. use the vertical axis for zoom in-and-out\n\n\n//#define Mode2 //Freaky inverted cubes effect\n\n//-----------------------------------------------------------------------------------------\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nfloat freqs[4];\nvec2 rot (vec2 p,float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return p*mat2(c,s,-s,c);\n}\n\n\n\nfloat hexDist(vec2 p) {\n    p = abs(p);\n    //distance to the diagonal line\n    float c = dot(p, normalize(vec2(1., 1.73)));\n\n    // distance to the vertical line\n    c = max(c, p.x);\n    c += sin(iTime + 4000.) *5. +5.;\n    return c;\n  }\n\nvec4 hexCoords(vec2 uv) {\n    vec2 r = vec2(1., 1.73);\n    vec2 h = r * 0.5;\n    vec2 a = mod(uv, r) - h;\n    vec2 b = mod(uv - h, r) - h;\n\n    vec2 gv;\n    if(length(a) < length(b))\n      gv = a;\n    else\n      gv = b;\n\n    float y = .5 - hexDist(gv);\n    float x = atan(gv.x, gv.y);\n    vec2 id = uv - gv;\n    return vec4(x, y, id.x, id.y);\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    freqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;\n    float avgFreq = (freqs[0] +freqs[1] +freqs[2] +freqs[3])/4.;\n    \n    \n\tfloat iTime = iTime * .25;\n\tiTime += 800.;\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy)\n\t/iResolution.y;\n    \n    \n     vec4 col = vec4(0.);\n     vec2 uv1 = uv;\n     //uv *= 3.;\n     uv *= ( sin(iTime+freqs[0])*8.5+8.5) + 5.;\n     uv -= 8.0;\n\n     uv += vec2(iTime *\t .01);\n\n     #ifdef Time_And_Zoom\n     iTime += iMouse.x * 10.;\n     uv *=  iMouse.y * .007;\n     #else\n     uv -= (iMouse.xy / iResolution.xy ) * 2. ;\n     #endif\n\n     uv += rot(uv , (cos(iTime - (avgFreq * (3.1415*.5)))*.5+.5) );\n\n \n \n     vec4 uvid = hexCoords(uv * 2.);\n     \n     float t = smoothstep(.5,.5\n \t \t,uvid.y \n \t \t* sin(( length(uvid.zw))\n \t \t * iTime *0.1)*.5+.5);\n   \n    \n\tcol = vec4(\n    t * tan(freqs[3])*.5+.5 * sin(freqs[0] * 2.5)*.5+.5\n    , t*cos(freqs[2])*.5+.5* sin(freqs[1] * 5.)*.5+.5\n    , t * sin(freqs[1])*.5+.5 * sin(freqs[2] * 10.)*.5+.5\n    ,1.);\n    \n    col -= vec4(freqs[0],freqs[1],\n         freqs[2],\n         1.);\n         \n         \n         \n\t//lit face\n\tcol += vec4(smoothstep(.99,.991,uvid.x));\n    \n    \n\t//shading\n\tcol += vec4(smoothstep(-1.,-1.,uvid.x)) * .6;\n\n \t \n     float circle = sin(freqs[0]);\n     \n     float triangles = sin(freqs[1] / length(uvid.z/uvid.w))*.5+.5 \n     / cos(freqs[3] * length(uvid.z/uvid.w))*.5+.5 ;\n     \n     triangles = mix(-triangles,triangles,sin(iTime)*.5+.5);\n     \n     \n \t //hexagons shrinking and expanding, wave form\n \t col *= vec4(smoothstep(.000001,.00001\n \t \t,uvid.y \n        \n        #ifdef Mode2\n \t \t* uvid.x\n        #endif\n        * sin((( length(uvid.zw * freqs[1]) * mix(circle,triangles,freqs[3])))*.5+.5\n \t \t * (dot(freqs[1],length(uvid.zw) * .05) ))))* max(freqs[0] , .1) + .3;\n         \n \t col = clamp(col,0.,1.);\n\tfragColor = vec4( col);\n}", "image_inputs": [{"id": 27887, "src": "https://soundcloud.com/warp99/warp9-seems-like-a-dream", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl2XRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[685, 685, 712, 712, 787], [791, 791, 814, 814, 1029], [1031, 1031, 1056, 1056, 1376]], "test": "untested"}
{"id": "flSXDz", "name": "task2_frag", "author": "HUANG", "description": "Solar system", "tags": ["raytracing"], "likes": 0, "viewed": 247, "published": 3, "date": "1627398313", "time_retrieved": "2024-07-30T19:09:02.561120", "image_code": "//============================================================================\n// PROJECT ID:  SWS3005_04\n//\n// GROUP NUMBER: 04\n//\n// STUDENT NAME: Huang Chenxuan\n// NUS User ID.: t0922598\n//\n// STUDENT NAME: OuYifan\n// NUS User ID.: t0922624\n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// COMMENTS TO GRADER: \n//\n//============================================================================\n\n\n// FRAGMENT SHADER FOR SHADERTOY\n// Run this at https://www.shadertoy.com/new\n// See documentation at https://www.shadertoy.com/howto\n\n// Your browser must support WebGL 2.0.\n// Check your browser at http://webglreport.com/?v=2\n\n//============================================================================\n// Constants.\n//============================================================================\nconst int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 12;\nconst int NUM_PLANES = 2;\nconst int NUM_SPHERES = 9;\nconst int NUM_CONES = 1;\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.2, 0., 1.0 );\n\n // Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * 3.1415926535 / 180.0; \n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n// Define new struct types.\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Cone_t {\n\t// Half angle\n\tfloat cosa;\n\t// Height\n\tfloat h;\n\t// Tip position\n\tvec3 c;\n\t// Axis\n\tvec3 v;\n\tint materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n\t// Ambient coefficient.\n    vec3 k_a;   \n    // Diffuse coefficient.\n    vec3 k_d;   \n    // Reflected specular coefficient.\n    vec3 k_r;   \n    // Global reflection coefficient.\n    vec3 k_rg;  \n    // The specular reflection exponent. Ranges from 0.0 to 128.0. \n    float n;    \n};\n\n\n// Global scene data.\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nCone_t Cone[NUM_CONES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\n\n// Initializes the scene.\nvoid InitScene()\n{\n\n    // Vertical plane.\n    Plane[1].A = -1.0;\n    Plane[1].B = 1.0;\n    Plane[1].C = 0.0;\n    Plane[1].D = 20.5;\n    Plane[1].materialID = 0;\n\n    // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 0.0;\n    Plane[0].C = 1.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 1;\n    \n    // Sun\n    Sphere[0].center = vec3( 0., 0., 4.5);\n    Sphere[0].radius = 2.5;\n    Sphere[0].materialID = 10;\n\n    // Mercury\n    Sphere[1].center = vec3( 2.8 * cos(3.3*iTime), 4. * sin(3.3*iTime), 4.5 +.2* sin(iTime));\n    Sphere[1].radius = .1;\n    Sphere[1].materialID = 2;\n    \n    // Venus\n    Sphere[2].center = vec3( 3.3 * cos(1.6*iTime), -4. * sin(1.6*iTime), 4.5 +.2* sin(iTime));\n    Sphere[2].radius = .18;\n    Sphere[2].materialID = 3;\n\n    // Earth\n    Sphere[3].center = vec3( 3.7 * cos(iTime), 4. * sin(iTime)+2., 4.5 + .3* cos(iTime) );\n    Sphere[3].radius = .2;\n    Sphere[3].materialID = 4;\n\n    // Mars\n    Sphere[4].center = vec3( 4.3 * cos(0.8*iTime), 4. * sin(0.8*iTime), 4.5 + .2* cos(iTime) );\n    Sphere[4].radius = .1;\n    Sphere[4].materialID = 5;\n\n    // Jupiter\n    Sphere[5].center = vec3( 6.5* cos(0.4*iTime), 4. * sin(0.4*iTime), 4.5 + .1* cos(iTime) );\n    Sphere[5].radius = .65;\n    Sphere[5].materialID = 6;\n\n    // Saturn\n    Sphere[6].center = vec3( 8.1 * cos(0.2*iTime), 4. * sin(0.2*iTime), 4.5 + .1* cos(0.8*iTime) );\n    Sphere[6].radius = .58;\n    Sphere[6].materialID = 7;\n\n    // Uranus\n    Sphere[7].center = vec3( 9.5* cos(0.1*iTime), 4. * sin(0.1*iTime), 4.5 + .3* cos(iTime) );\n    Sphere[7].radius = .3;\n    Sphere[7].materialID = 8;\n\n    // Neptune\n    Sphere[8].center = vec3( 11.1 * cos(0.05*iTime), 4. * sin(0.05*iTime), 4.5 + .1* cos(0.7*iTime) );\n    Sphere[8].radius = .3;\n    Sphere[8].materialID = 9;\n\n\n    // SUN\n    Material[10].k_d = vec3( 0.9, 0.5, 0.3 );\n    Material[10].k_a = 0.2 * Material[10].k_d;\n    Material[10].k_r = 2.0 * Material[10].k_d;\n    Material[10].k_rg = 0.5 * Material[10].k_r;\n    Material[10].n = 100.0;\n\n    // Vertical plane: Silver material.\n    Material[0].k_d = vec3( 0.5, 0.5, 0.4 );\n    Material[0].k_a = 0.9 * Material[0].k_d;\n    Material[0].k_r = 1.2 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n    \n    // Horizontal plane: Red material.\n    Material[1].k_d = vec3( 0.2, 0.1, 0.1 );\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 0.2 * Material[1].k_d;\n    Material[1].k_rg = 0.1 * Material[1].k_r;\n    Material[1].n = 128.0;\n\n    // Mercury\n    Material[2].k_d = vec3( 0.6, 0.8, 0.8);\n    Material[2].k_a = 0.2 * Material[2].k_d;\n    Material[2].k_r = 4.0 * Material[2].k_d;\n    Material[2].k_rg = 0.5 * Material[2].k_r;\n    Material[2].n = 128.0;\n\n    // Venus\n    Material[3].k_d = vec3( 0.9, 0.9, 0.0 );\n    Material[3].k_a = 0.4 * Material[3].k_d;\n    Material[3].k_r = vec3( 0.5, 0.5, 0.5);\n    Material[3].k_rg = 0.5 * Material[3].k_r;\n    Material[3].n = 64.0;\n    \n    \n    // Earth\n    Material[4].k_d = vec3( 0.1, 0.1, 0.8 );\n    Material[4].k_a = 0.4 * Material[4].k_d;\n    Material[4].k_r = vec3( 0.5, 0.5, 0.5);\n    Material[4].k_rg = 0.5 * Material[4].k_r;\n    Material[4].n = 64.0;\n    \n    // Mars\n    Material[5].k_d = vec3( 0.4, 0.3, 0.0 );\n    Material[5].k_a = 0.4 * Material[5].k_d;\n    Material[5].k_r = vec3( 0.5, 0.5, 0.5);\n    Material[5].k_rg = 0.5 * Material[5].k_r;\n    Material[5].n = 64.0;\n    \n    // Jupiter\n    Material[6].k_d = vec3( 0.3, 0.4, 0.2 );\n    Material[6].k_a = 0.4 * Material[6].k_d;\n    Material[6].k_r = vec3( 0.5, 0.5, 0.5);\n    Material[6].k_rg = 0.5 * Material[6].k_r;\n    Material[6].n = 64.0;\n    \n    // Saturn\n    Material[7].k_d = vec3( 0.5, 0.5, 0.1 );\n    Material[7].k_a = 0.4 * Material[7].k_d;\n    Material[7].k_r = vec3( 0.5, 0.5, 0.5);\n    Material[7].k_rg = 0.5 * Material[7].k_r;\n    Material[7].n = 64.0;\n    \n    // Uranus\n    Material[8].k_d = vec3( 0.4, 0.8, 1.0 );\n    Material[8].k_a = 0.4 * Material[8].k_d;\n    Material[8].k_r = vec3( 0.5, 0.5, 0.5);\n    Material[8].k_rg = 0.5 * Material[8].k_r;\n    Material[8].n = 64.0;\n    \n    // Neptune\n    Material[9].k_d = vec3( 0.2, 0.5, 0.7 );\n    Material[9].k_a = 0.4 * Material[9].k_d;\n    Material[9].k_r = vec3( 0.5, 0.5, 0.5);\n    Material[9].k_rg = 0.5 * Material[9].k_r;\n    Material[9].n = 64.0;\n\n\n\n    // Light 0.\n    Light[0].position = vec3( 10.0, -2.0, 9.0 );\n    Light[0].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[0].I_source = vec3( 1.0, 1.0, 1.0 );\n\n    // Light 1.\n    Light[1].position = vec3( 3.0, 8.0, 8.0 );\n    Light[1].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[1].I_source = vec3( 1.0, 1.0, 1.0 );\n}\n\n// Computes intersection between a plane and a ray.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection \n// (hitNormal).\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n// Computes intersection between a plane and a ray for shadow ray intersection.\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n// Computes intersection between a sphere and a ray.\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n\t// A vector from sphere center towards ray origin\n    vec3 V = ray.o - sph.center;\n    float a0 = dot(V,V) - sph.radius * sph.radius;\n    float DdotV = dot(ray.d, V);\n\n    if (DdotV <= 0.0) {\n    \t// When the ray shoots towards the sphere\n    \tfloat discr = DdotV * DdotV - a0;\n    \tif (discr >= 0.0) {\n    \t\t// Smaller intersection point\n    \t\tt = -DdotV - sqrt(discr);\n    \t\thitPos = ray.o + t * ray.d;\n    \t\thitNormal = normalize(hitPos - sph.center);\n    \t\treturn (t >= tmin && t<= tmax);\n    \t}\n    }\n\treturn false;\n}\n\n// Computes intersection between a sphere and a ray for shadow ray intersection.\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    // A vector from sphere center towards ray origin\n    vec3 V = ray.o - sph.center;\n    float a0 = dot(V,V) - sph.radius * sph.radius;\n    float DdotV = dot(ray.d, V);\n\n    if (DdotV <= 0.0) {\n    \t// When the ray shoots towards the sphere\n    \tfloat discr = DdotV * DdotV - a0;\n    \tif (discr >= 0.0) {\n    \t\tfloat t = -DdotV - sqrt(discr);\n    \t\treturn (t >= tmin && t<= tmax);\n    \t}\n    }\n\treturn false;\n}\n\n\n\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow, \n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a + \n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n// Casts a ray into the scene and returns color computed at the nearest hit position.\nvec3 CastRay( in Ray_t ray, \n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg ) \n{\n    // Find whether and where the ray hits some object. \n    bool hasHitSomething = false;\n    // The ray parameter t at the nearest hit point.\n    float nearest_t = DEFAULT_TMAX;\n    // 3D position of the nearest hit point.   \n    vec3 nearest_hitPos; \n    // Normal vector at the nearest hit point.             \n    vec3 nearest_hitNormal;\n    // MaterialID of the object at the nearest hit point.          \n    int nearest_hitMatID;             \n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    // Try interesecting input ray with all the planes and spheres,\n    // and record the front-most (nearest) interesection.\n    for (int i = 0; i < NUM_SPHERES; i++ ) {\n    \t// Try intersect with spheres\n    \ttemp_hasHit = IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, DEFAULT_TMAX,\n                      temp_t, temp_hitPos, temp_hitNormal);\n\n    \t// If intersect with spheres, compare and find the nearest\n    \tif (temp_hasHit && temp_t < nearest_t) {\n    \t\thasHitSomething = true;\n    \t\tnearest_t = temp_t;\n    \t\tnearest_hitPos = temp_hitPos;\n    \t\tnearest_hitNormal = temp_hitNormal;\n    \t\tnearest_hitMatID = Sphere[i].materialID;\n    \t}\n    \t\n    }\n\n    for (int i = 0; i < NUM_PLANES; i++ ) {\n    \t// Try intersect with planes\n    \t// Use nearest_t as input tmax to determine whether the intersection point\n    \t//with planes is the nearest\n    \ttemp_hasHit = IntersectPlane(Plane[i], ray, DEFAULT_TMIN, nearest_t,\n                      temp_t, temp_hitPos, temp_hitNormal);\n\n    \t// If hit, then now the hit point is nearer than spheres if any\n    \tif (temp_hasHit && temp_t < nearest_t ) {\n    \t\thasHitSomething = true;\n    \t\tnearest_t = temp_t;\n    \t\tnearest_hitPos = temp_hitPos;\n    \t\tnearest_hitNormal = temp_hitNormal;\n    \t\tnearest_hitMatID = Plane[i].materialID;\n    \t}\n    \t\n    }\n    \t\n    \t\n    \n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3( 0.0 );\n\n    // For each light source, make a shadow ray, and check if the shadow ray\n    // intersects any of the objects.\n    Ray_t ShadowRay[NUM_LIGHTS];\n    bool inshadow[NUM_LIGHTS];\n    for (int i = 0; i < NUM_LIGHTS; i++ ) {\n    \t// Make a shadow ray (from surface to light) for each light\n    \tShadowRay[i].o = nearest_hitPos;\n    \tShadowRay[i].d = normalize(Light[i].position - ShadowRay[i].o);\n\n    \tfor (int j = 0; j < NUM_SPHERES; j++ ) {\n    \t\t// If already in shadow, inshadow[i] becomes inaccessible\n    \t\tif(!inshadow[i]) {\n    \t\t\t// The point is in shadow if the shadow ray intersects with anything\n    \t\tinshadow[i] = IntersectSphere(Sphere[j], ShadowRay[i], DEFAULT_TMIN, \n    \t\t\tdistance(nearest_hitPos, Light[i].position));\n    \t\t}\n    \t}\n    \t// If not occluded, consider intersection with planes\n    \tif (!inshadow[i]) {\n    \t\tfor(int j = 0; j < NUM_PLANES; j++ ) {\n    \t\t\t// If already in shadow, inshadow[i] becomes inaccessible\n    \t\t\tif(!inshadow[i]) {\n    \t\t\t\tinshadow[i] = IntersectPlane(Plane[j], ShadowRay[i], DEFAULT_TMIN, \n    \t\t\t\tdistance(nearest_hitPos, Light[i].position));\n    \t\t\t}\n    \t\t}\n    \t}\n\n\n    \tI_local += PhongLighting( ShadowRay[i].d, nearest_hitNormal, - ray.d, inshadow[i], \n    \t\tMaterial[nearest_hitMatID], Light[i] );\n    }\n\n    \n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    return I_local;\n}\n\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    // Position the camera.\n    vec3 cam_pos = vec3( 4. * cos(iTime / 2.) + 1., 10.0, 1. * sin(iTime / 2.) + 5.);\n    vec3 cam_lookat = vec3( 0., 0., 2. );\n    vec3 cam_up_vec = vec3( 0.0, 0.0, 1.0 );\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ ) \n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n\n    fragColor = vec4( I_result, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flSXDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2520, 2546, 2564, 2588, 7157], [7159, 7376, 7531, 7531, 7861], [7863, 7943, 8026, 8026, 8238], [8240, 8293, 8451, 8502, 8975], [8977, 9058, 9143, 9197, 9556], [9560, 9641, 9772, 9772, 10185], [10187, 10273, 10388, 10445, 13830], [13832, 14037, 14094, 14094, 15554]], "test": "untested"}
{"id": "NlBSWz", "name": "Five-pointed", "author": "shihao", "description": "Five-pointed", "tags": ["fivepointed"], "likes": 1, "viewed": 227, "published": 3, "date": "1627391476", "time_retrieved": "2024-07-30T19:09:03.329067", "image_code": "// The MIT License\n// Copyright © 2019 J. M.\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Polar equation of a star-shaped decagon (pentagram)\n// adapted from Inigo Quilez's shader, https://www.shadertoy.com/view/lsccR8\n\n/*\nfloat sdfStar5( in vec2 p ) // iq's function\n{\n    // repeat domain 5x\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292); // pi/5\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    \n    // draw triangle\n    const vec2 k3 = vec2(0.951056516295,  0.309016994375); // pi/10\n    return dot( vec2(abs(p.x)-0.3,p.y), k3);\n}\n*/\n\nfloat polarStar( in vec2 p )\n{\n    const float pi5 = 0.628318530718; // pi/5\n    const float ph2 = 3.2360679775; // 2 * phi\n    \n    float m2 = mod(atan(p.y, p.x)/pi5 + 1.0, 2.0);\n    \n    return ph2 * length(p) * cos(pi5 * (m2 - 4.0 * step(1.0, m2) + 1.0)) - 1.0;\n}\n\nfloat polarStar2( in vec2 p )\n{\n    const float pi5 = 0.628318530718; // pi/5\n    const float ph2 = 3.2360679775; // 2 * phi\n    \n    float m2 = mod(atan(p.y, p.x)/pi5 + 1.0, 2.0);\n    \n    return ph2 * length(p) * cos(pi5 * (m2 - 4.0 * step(1.0, m2) + 1.0)) - 1.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coords\n    float px = 2.0/iResolution.y;\n\tvec2 uv = (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n    \n    float uoffset = 0.00;\n    \n    float t  = (0.75 - uoffset) * iTime * sign(-uv.x) ;\n    float t2 = 0.75 * iTime * sign(-uv.x) ;\n    float t3 = (0.75 + uoffset) * iTime * sign(-uv.x) ;\n    \n    float middis = max((1.0 - abs( uv.x * 0.5)) * 2.5 , 1.1 ) ;\n    //middis = 0.1;\n    \n    vec2 q = uv * vec2(2,2) + vec2(t,0);\n    float d = polarStar2( (fract(q) - vec2(0.5)) * vec2( 5.0,5.0 ) * middis );\n\n    vec2 q2 = uv * vec2(2,2) + vec2(t2,0) + vec2(0.7,0.0);\n    float d2 = polarStar2( (fract(q2) - vec2(0.5)) * vec2( 5.0,5.0 )* middis );\n    \n    vec2 q3 = uv * vec2(2,2) + vec2(t3,0) + vec2(0.3,0.0);\n    float d3 = polarStar2( (fract(q3) - vec2(0.5)) * vec2( 5.0,5.0 )* middis );\n    \n    d = step(d,0.8);\n    d2 = step(d2,0.8);\n    d3 = step(d3,0.8);\n    //d += d2 + d3;\n    \n    d = max( max(d,d2),d3);\n    \n    vec3 col = mix(vec3(1.0, 1.0, 1.0), vec3(1.2, 1.4, 1.6), smoothstep(-2.0 * px, 2.0 * px, d));\n\tcol *= smoothstep(0.02, 0.02 + 2.0 * px, abs(d));\n    fragColor = vec4( col, 1.0 );\n    \n   // vec3 col = vec3(d,d,d);\n    col = mix(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0), smoothstep(-2.0 * px, 2.0 * px, d));\n    //col = mix(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0), d);\n    col *= smoothstep(0.02, 0.02 + 2.0 * px, abs(d));\n\t//fragColor = vec4( col, 1.0 );\n  //  fragColor = vec4( fract( q.y) );\n    //fragColor = vec4( uv.x  );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlBSWz.jpg", "access": "api", "license": "mit", "functions": [[1620, 1620, 1650, 1650, 1886], [1888, 1888, 1919, 1919, 2155], [2158, 2158, 2215, 2229, 3678]], "test": "untested"}
{"id": "ftSXDR", "name": "sws3005_A5-ray tracing", "author": "sws3005_09", "description": "This is the task 2 of assignment 5 of NUS SOC summer workshop 2021.", "tags": ["raytracing"], "likes": 6, "viewed": 489, "published": 3, "date": "1627386446", "time_retrieved": "2024-07-30T19:09:04.332385", "image_code": "const float PI = 3.1415926536;\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.3, 0.2, 0.3);\n\n// Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * PI / 180.0;\n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n// Constants for the scene objects.\nconst int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 4;\nconst int NUM_PLANES = 6;\nconst int NUM_CYLINDERS = 4;\nconst int NUM_SPHERES = 27;\n\n// Beat Frequnce for the music\nconst float beatFreq = 115.0 / 60.0;\n\n//Parameters for block\nfloat blockNum = 4.0;\nfloat blockLength = 0.45;\n\n// Time for change\nfloat MyITime;\n\n// The Ball to Show\nint ShowBallNumber;\n\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Cylinder_t{\n    vec3 center;\n    float radius;\n    float height;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that on Slides 8 and 12 of\n// Lecture Topic B08 (Basic Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS {\n//                   I_a * k_a +\n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nCylinder_t Cylinder[NUM_CYLINDERS];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\n\nSphere_t showSphere[NUM_SPHERES];\n\n\n// Init The Item to be show\nvoid initShowItem(){\n    ShowBallNumber = 0;\n    float OneCircleTime = 2.0 * 8.0 / beatFreq;\n    float nowRoundTime = mod(MyITime / OneCircleTime, 21.0);\n    //Phase1\n    if(nowRoundTime<3.0){\n        for(int i = 0; i < 27; i++){\n            showSphere[ShowBallNumber] = Sphere[i];\n            showSphere[ShowBallNumber].center.y -= 1.9*(1.0-(nowRoundTime/3.0));\n            ShowBallNumber++;\n        }\n    }\n    //Phase2\n    else if(nowRoundTime>=3.0 && nowRoundTime<4.0){\n        for(int i = 0; i < 27; i++){\n            showSphere[ShowBallNumber] = Sphere[i];\n            ShowBallNumber++;\n        }\n    }\n    //Phase3\n    else if(nowRoundTime>=4.0 && nowRoundTime<6.0){\n        for(int i = 0; i < 27; i++){\n            showSphere[ShowBallNumber] = Sphere[i];\n            ShowBallNumber++;\n        }\n        for(int i=18; i<27; i++){\n            showSphere[i].center.xz *= (1.0 + 1.0*(nowRoundTime-4.0)/2.0);\n        }\n    }\n    //Phase4\n    else if(nowRoundTime>=6.0 && nowRoundTime<8.0){\n        for(int i = 0; i < 27; i++){\n            showSphere[ShowBallNumber] = Sphere[i];\n            ShowBallNumber++;\n        }\n        for(int i=18; i<27; i++){\n            showSphere[i].center.xz *= 2.0;\n        }\n        for(int i=9; i<18; i++){\n            showSphere[i].center.xz *= (1.0 + 1.0*(nowRoundTime-6.0)/2.0);\n        }\n    }\n    //Phase5\n    else if(nowRoundTime>=8.0 && nowRoundTime<10.0){\n        for(int i = 0; i < 27; i++){\n            showSphere[ShowBallNumber] = Sphere[i];\n            ShowBallNumber++;\n        }\n        for(int i=18; i<27; i++){\n            showSphere[i].center.xz *= 2.0;\n        }\n        for(int i=9; i<18; i++){\n            showSphere[i].center.xz *= 2.0;\n        }\n        for(int i=0; i<9; i++){\n            showSphere[i].center.xz *=(1.0 + 1.0*(nowRoundTime-8.0)/2.0);\n        }\n    }\n    //Phase6\n    else if(nowRoundTime>=10.0 && nowRoundTime<12.0){\n        for(int i = 0; i < 27; i++){\n            showSphere[ShowBallNumber] = Sphere[i];\n            ShowBallNumber++;\n        }\n        for(int i=18; i<27; i++){\n            showSphere[i].center.xz *= (2.0 - 1.0*(nowRoundTime-10.0)/2.0);\n        }\n        for(int i=9; i<18; i++){\n            showSphere[i].center.xz *= 2.0;\n        }\n        for(int i=0; i<9; i++){\n            showSphere[i].center.xz *= 2.0;\n        }\n    }\n    //Phase7\n    else if(nowRoundTime>=12.0 && nowRoundTime<14.0){\n        for(int i = 0; i < 27; i++){\n            showSphere[ShowBallNumber] = Sphere[i];\n            ShowBallNumber++;\n        }\n        for(int i=9; i<18; i++){\n            showSphere[i].center.xz *= (2.0 - 1.0*(nowRoundTime-12.0)/2.0);\n        }\n        for(int i=0; i<9; i++){\n            showSphere[i].center.xz *= 2.0;\n        }\n    }\n    //Phase8\n    else if(nowRoundTime>=14.0 && nowRoundTime<16.0){\n        for(int i = 0; i < 27; i++){\n            showSphere[ShowBallNumber] = Sphere[i];\n            ShowBallNumber++;\n        }\n        for(int i=0; i<9; i++){\n            showSphere[i].center.xz *= (2.0 - 1.0*(nowRoundTime-14.0)/2.0);\n        }\n    }\n    //Phase9\n    else if(nowRoundTime>=16.0 && nowRoundTime<17.0){\n        for(int i = 0; i < 27; i++){\n            showSphere[ShowBallNumber] = Sphere[i];\n            ShowBallNumber++;\n        }\n    }\n    //Phase10\n    else if(nowRoundTime>=17.0 && nowRoundTime<20.0){\n        for(int i = 0; i < 27; i++){\n            showSphere[ShowBallNumber] = Sphere[i];\n            showSphere[ShowBallNumber].center.y -= 1.9*((nowRoundTime-17.0)/3.0);\n            ShowBallNumber++;\n        }\n    }\n    //Phase11\n    else if(nowRoundTime>=20.0){\n        for(int i = 0; i < 27; i++){\n            showSphere[ShowBallNumber] = Sphere[i];\n            showSphere[ShowBallNumber].center.y -= 1.9;\n            ShowBallNumber++;\n        }\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n{\n     // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 3;\n\n    Plane[5].A = 0.0;\n    Plane[5].B = 1.0;\n    Plane[5].C = 0.0;\n    Plane[5].D = -8.5;\n    Plane[5].materialID = 3;\n\n    // Vertical plane.\n    Plane[1].A = 0.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 1.0;\n    Plane[1].D = 4.5;\n    Plane[1].materialID = 3;\n    \n    Plane[2].A = 1.0;\n    Plane[2].B = 0.0;\n    Plane[2].C = 0.0;\n    Plane[2].D = 4.5;\n    Plane[2].materialID = 3;\n\n    Plane[3].A = 0.0;\n    Plane[3].B = 0.0;\n    Plane[3].C = 1.0;\n    Plane[3].D = -4.5;\n    Plane[3].materialID = 3;\n\n    Plane[4].A = 1.0;\n    Plane[4].B = 0.0;\n    Plane[4].C = 0.0;\n    Plane[4].D = -4.5;\n    Plane[4].materialID = 3;\n\n    MyITime = 2.0 * PI * iTime * beatFreq / 8.0;\n\n    // The upper spheres\n    Sphere[0].center = vec3( 0.2 * cos(MyITime), 1.7, 1.0 * sin(MyITime) );\n    Sphere[0].radius = 0.2;\n    Sphere[0].materialID = 1;\n    Sphere[1].center = vec3( 0.2 * cos(MyITime), 1.7, 0.2 * sin(MyITime) );\n    Sphere[1].radius = 0.2;\n    Sphere[1].materialID = 1;\n    Sphere[2].center = vec3( 0.7 * cos(MyITime), 1.7, 0.5* sin(MyITime) );\n    Sphere[2].radius = 0.2;\n    Sphere[2].materialID = 1;\n    Sphere[3].center = vec3( 1.4 * cos(MyITime), 1.7, 0.5* sin(MyITime) );\n    Sphere[3].radius = 0.2;\n    Sphere[3].materialID = 1;\n    Sphere[4].center = vec3( 1.4 * cos(MyITime), 1.7, 1.5* sin(MyITime) );\n    Sphere[4].radius = 0.2;\n    Sphere[4].materialID = 1;\n    Sphere[5].center = vec3( 0.7 * cos(MyITime), 1.7, 1.5* sin(MyITime) );\n    Sphere[5].radius = 0.2;\n    Sphere[5].materialID = 1;\n    Sphere[6].center = vec3( 1.4 * cos(MyITime), 1.7, 2.2* sin(MyITime) );\n    Sphere[6].radius = 0.2;\n    Sphere[6].materialID = 1;\n    Sphere[7].center = vec3( 0.7 * cos(MyITime), 1.7, 2.0* sin(MyITime) );\n    Sphere[7].radius = 0.2;\n    Sphere[7].materialID = 1;\n    Sphere[8].center = vec3( 0.2 * cos(MyITime), 1.7, 2.1* sin(MyITime) );\n    Sphere[8].radius = 0.2;\n    Sphere[8].materialID = 1;\n\n    //The middle spheres and color changing\n    Sphere[9].center = vec3( 0.2 * cos(MyITime), 1.1, 0.2 * sin(MyITime) );\n    Sphere[9].radius = 0.25;\n    Sphere[9].materialID =  (mod(MyITime, 3.0) < 0.5)? 0: \n            (mod(MyITime, 3.0) < 2.0)? 2 : \n                (mod(MyITime, 3.0) < 4.0)? 0 :\n                    (mod(MyITime, 3.0) < 6.0)? 2 :\n                        (mod(MyITime, 3.0) < 7.5)? 2 : 0;\n    Sphere[10].center = vec3( 0.2 * cos(MyITime), 1.1, 1.0 * sin(MyITime) );\n    Sphere[10].radius = 0.25;\n    Sphere[10].materialID =  (mod(MyITime, 3.0) < 0.5)? 0: \n            (mod(MyITime, 3.0) < 2.0)? 2 : \n                (mod(MyITime, 3.0) < 4.0)? 0 :\n                    (mod(MyITime, 3.0) < 6.0)? 2 :\n                        (mod(MyITime, 3.0) < 7.5)? 2 : 0;\n    Sphere[11].center = vec3( 0.7 * cos(MyITime), 1.1, 0.5* sin(MyITime) );\n    Sphere[11].radius = 0.25;\n    Sphere[11].materialID = (mod(MyITime, 3.0) < 0.5)? 0: \n            (mod(MyITime, 3.0) < 2.0)? 2 : \n                (mod(MyITime, 3.0) < 4.0)? 0 :\n                    (mod(MyITime, 3.0) < 6.0)? 2 :\n                        (mod(MyITime, 3.0) < 7.5)? 2 : 0;\n    Sphere[12].center = vec3( 1.4 * cos(MyITime), 1.1, 0.5* sin(MyITime) );\n    Sphere[12].radius = 0.25;\n    Sphere[12].materialID = (mod(MyITime, 3.0) < 0.5)? 0: \n            (mod(MyITime, 3.0) < 2.0)? 2 : \n                (mod(MyITime, 3.0) < 4.0)? 0 :\n                    (mod(MyITime, 3.0) < 6.0)? 2 :\n                        (mod(MyITime, 3.0) < 7.5)? 2 : 0;\n    Sphere[13].center = vec3( 1.4 * cos(MyITime), 1.1, 1.5* sin(MyITime) );\n    Sphere[13].radius = 0.25;\n    Sphere[13].materialID = (mod(MyITime, 3.0) < 0.5)? 0: \n            (mod(MyITime, 3.0) < 2.0)? 2 : \n                (mod(MyITime, 3.0) < 4.0)? 0 :\n                    (mod(MyITime, 3.0) < 6.0)? 2 :\n                        (mod(MyITime, 3.0) < 7.5)? 2 : 0;\n    Sphere[14].center = vec3( 0.7 * cos(MyITime), 1.1, 2.0* sin(MyITime) );\n    Sphere[14].radius = 0.25;\n    Sphere[14].materialID =  (mod(MyITime, 3.0) < 0.5)? 0: \n            (mod(MyITime, 3.0) < 2.0)? 2 : \n                (mod(MyITime, 3.0) < 4.0)? 0 :\n                    (mod(MyITime, 3.0) < 6.0)? 2 :\n                        (mod(MyITime, 3.0) < 7.5)? 2 : 0;\n    Sphere[15].center = vec3( 0.7 * cos(MyITime), 1.1, 1.5* sin(MyITime) );\n    Sphere[15].radius = 0.25;\n    Sphere[15].materialID =  (mod(MyITime, 3.0) < 0.5)? 0: \n            (mod(MyITime, 3.0) < 2.0)? 2 : \n                (mod(MyITime, 3.0) < 4.0)? 0 :\n                    (mod(MyITime, 3.0) < 6.0)? 2 :\n                        (mod(MyITime, 3.0) < 7.5)? 2 : 0;\n    Sphere[16].center = vec3( 0.2 * cos(MyITime), 1.1, 2.1* sin(MyITime) );\n    Sphere[16].radius = 0.25;\n    Sphere[16].materialID = (mod(MyITime, 3.0) < 0.5)? 0: \n            (mod(MyITime, 3.0) < 2.0)? 2 : \n                (mod(MyITime, 3.0) < 4.0)? 0 :\n                    (mod(MyITime, 3.0) < 6.0)? 2 :\n                        (mod(MyITime, 3.0) < 7.5)? 2 : 0;\n    Sphere[17].center = vec3( 1.4 * cos(MyITime), 1.1, 2.2* sin(MyITime) );\n    Sphere[17].radius = 0.25;\n    Sphere[17].materialID = (mod(MyITime, 3.0) < 0.5)? 0: \n            (mod(MyITime, 3.0) < 2.0)? 2 : \n                (mod(MyITime, 3.0) < 4.0)? 0 :\n                    (mod(MyITime, 3.0) < 6.0)? 2 :\n                        (mod(MyITime, 3.0) < 7.5)? 2 : 0;\n                    \n   \n    //The lower spheres\n    Sphere[18].center = vec3( 0.2 * cos(MyITime), 0.5, 1.0 * sin(MyITime) );\n    Sphere[18].radius = 0.2;\n    Sphere[18].materialID = 1;\n    Sphere[19].center = vec3( 0.2 * cos(MyITime), 0.5, 0.2 * sin(MyITime) );\n    Sphere[19].radius = 0.2;\n    Sphere[19].materialID = 1;\n    Sphere[20].center = vec3( 0.7 * cos(MyITime), 0.5, 0.5* sin(MyITime) );\n    Sphere[20].radius = 0.2;\n    Sphere[20].materialID = 1;\n    Sphere[21].center = vec3( 1.4 * cos(MyITime), 0.5, 0.5* sin(MyITime) );\n    Sphere[21].radius = 0.2;\n    Sphere[21].materialID = 1; \n    Sphere[22].center = vec3( 1.4 * cos(MyITime), 0.5, 1.5* sin(MyITime) );\n    Sphere[22].radius = 0.2;\n    Sphere[22].materialID = 1;\n    Sphere[23].center = vec3( 0.7 * cos(MyITime), 0.5, 1.5* sin(MyITime) );\n    Sphere[23].radius = 0.2;\n    Sphere[23].materialID = 1;\n    Sphere[24].center = vec3( 0.7 * cos(MyITime), 0.5, 2.0* sin(MyITime) );\n    Sphere[24].radius = 0.2;\n    Sphere[24].materialID = 1;\n    Sphere[25].center = vec3( 1.4 * cos(MyITime), 0.5, 2.2* sin(MyITime) );\n    Sphere[25].radius = 0.2;\n    Sphere[25].materialID = 1;\n    Sphere[26].center = vec3( 0.2 * cos(MyITime), 0.5, 2.1* sin(MyITime) );\n    Sphere[26].radius = 0.2;\n    Sphere[26].materialID = 1;\n    \n    //The Cyclinder\n    Cylinder[0].center = vec3(3.5, -0.5, 3.5);\n    Cylinder[0].radius = 0.3;\n    Cylinder[0].height = 10.0;\n    Cylinder[0].materialID = 3;\n\n    Cylinder[1].center = vec3(-3.5, -0.5, 3.5);\n    Cylinder[1].radius = 0.3;\n    Cylinder[1].height = 10.0;\n    Cylinder[1].materialID = 3;\n\n    Cylinder[2].center = vec3(3.5, -0.5, -3.5);\n    Cylinder[2].radius = 0.3;\n    Cylinder[2].height = 10.0;\n    Cylinder[2].materialID = 3;\n\n    Cylinder[3].center = vec3(-3.5, -0.5, -3.5);\n    Cylinder[3].radius = 0.3;\n    Cylinder[3].height = 10.0;\n    Cylinder[3].materialID = 3;\n\n    // red\n    Material[0].k_d = vec3( 0.6, 0.2, 0.2 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n\n    //silver\n    Material[1].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 2.0 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 64.0;\n    \n    //green\n    Material[2].k_d = vec3( 0.0, 0.2, 0.2 );\n    Material[2].k_a = 0.4 * Material[2].k_d;\n    Material[2].k_r = 3.0 * Material[2].k_d;\n    Material[2].k_rg = 0.2 * Material[2].k_r;\n    Material[2].n = 64.0;\n\n    //Special Material\n    Material[3].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[3].k_a = 0.2 * Material[1].k_d;\n    Material[3].k_r = 2.0 * Material[1].k_d;\n    Material[3].k_rg = 0.1 * Material[1].k_r;\n    Material[3].n = 64.0;\n\n    // Light 0.\n    Light[0].position = vec3( 4.0, 8.0, 0.0 );\n    Light[0].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[0].I_source = vec3( 1.0, 1.0, 1.0 );\n\n    // Light 1.\n    Light[1].position = vec3( -4.0, 8.0, 0.0 );\n    Light[1].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[1].I_source = vec3( 1.0, 1.0, 1.0 );\n\n    initShowItem();\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection\n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    vec3 rayOriInSphere = ray.o - sph.center;\n    float a = dot(ray.d, ray.d);\n    float b = 2.0 * dot(ray.d, rayOriInSphere);\n    float c = dot(rayOriInSphere, rayOriInSphere) - sph.radius * sph.radius;\n    float d = b*b - 4.0*a*c;\n    if(d<0.0) return false;\n    float t1 = (-1.0*b + sqrt(d))/(2.0*a);\n    float t2 = (-1.0*b - sqrt(d))/(2.0*a);\n\n    float finalT;\n    bool isSatisfy = false;\n    if(t1>=tmin && t1<=tmax){\n        isSatisfy = true;\n        finalT = t1;\n    }\n    if(t2>=tmin && t2<=tmax){\n        isSatisfy = true;\n        finalT = t2;\n    }\n    if(isSatisfy == false) return false;\n\n    t = finalT;\n    hitPos = ray.o + finalT * ray.d;\n    hitNormal = (hitPos - sph.center)/sph.radius;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    vec3 rayOriInSphere = ray.o - sph.center;\n    float a = dot(ray.d, ray.d);\n    float b = 2.0 * dot(ray.d, rayOriInSphere);\n    float c = dot(rayOriInSphere, rayOriInSphere) - sph.radius * sph.radius;\n    float d = b*b - 4.0*a*c;\n    if(d<0.0) return false;\n    float t1 = (-1.0*b + sqrt(d))/(2.0*a);\n    float t2 = (-1.0*b - sqrt(d))/(2.0*a);\n\n    float finalT;\n    bool isSatisfy = false;\n    if(t1>=tmin && t1<=tmax){\n        isSatisfy = true;\n        finalT = t1;\n    }\n    if(t2>=tmin && t2<=tmax){\n        isSatisfy = true;\n        finalT = t2;\n    }\n    if(isSatisfy == false) return false;\n    return true;\n}\n\nbool IntersectionCylinder(in Cylinder_t cyl, in Ray_t ray, in float tmin, in float tmax, out float t, out vec3 hitPos, out vec3 hitNormal){\n    vec2 rayOriInSphere = ray.o.xz - cyl.center.xz;\n    float a = dot(ray.d.xz, ray.d.xz);\n    float b = 2.0 * dot(ray.d.xz, rayOriInSphere);\n    float c = dot(rayOriInSphere, rayOriInSphere) - cyl.radius * cyl.radius;\n    float d = b*b - 4.0*a*c;\n    if(d<0.0) return false;\n    float t1 = (-1.0*b + sqrt(d))/(2.0*a);\n    float t2 = (-1.0*b - sqrt(d))/(2.0*a);\n    float finalT;\n    bool isSatisfy = false;\n    if(t1>=tmin && t1<=tmax){\n        isSatisfy = true;\n        finalT = t1;\n    }\n    if(t2>=tmin && t2<=tmax){\n        isSatisfy = true;\n        finalT = t2;\n    }\n    if(isSatisfy == false) return false;\n    t = finalT;\n    hitPos = ray.o + finalT * ray.d;\n    hitNormal = hitPos - cyl.center;\n    if(hitNormal.y - cyl.center.y<0.0 || hitNormal.y - cyl.center.y>cyl.height) return false;\n    hitNormal.y = 0.0;\n    hitNormal = hitNormal / cyl.radius;\n    return true;\n}\n\nbool IntersectionCylinder(in Cylinder_t cyl, in Ray_t ray, in float tmin, in float tmax){\n    vec2 rayOriInSphere = ray.o.xy - cyl.center.xy;\n    float a = dot(ray.d.xy, ray.d.xy);\n    float b = 2.0 * dot(ray.d.xy, rayOriInSphere);\n    float c = dot(rayOriInSphere, rayOriInSphere) - cyl.radius * cyl.radius;\n    float d = b*b - 4.0*a*c;\n    if(d<0.0) return false;\n    float t1 = (-1.0*b + sqrt(d))/(2.0*a);\n    float t2 = (-1.0*b - sqrt(d))/(2.0*a);\n    float finalT;\n    bool isSatisfy = false;\n    if(t1>=tmin && t1<=tmax){\n        isSatisfy = true;\n        finalT = t1;\n    }\n    if(t2>=tmin && t2<=tmax){\n        isSatisfy = true;\n        finalT = t2;\n    }\n    if(isSatisfy == false) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a +\n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n//refer to https://www.shadertoy.com/view/XdB3Dw\nvec3 squaresColours(vec2 p)\n{\n\tp+=vec2(MyITime*0.2);\n\t\n\tvec3 orange=vec3(1.0,0.4,0.1)*2.0;\n\tvec3 purple=vec3(1.0,0.2,0.5)*0.8;\n\t\n\tfloat l=pow(0.5+0.5*cos(p.x*7.0+cos(p.y)*8.0)*sin(p.y*2.0),4.0)*2.0;\n\tvec3 c=pow(l*(mix(orange,purple,0.5+0.5*cos(p.x*40.0+sin(p.y*10.0)*3.0))+\n\t\t\t\t  mix(orange,purple,0.5+0.5*cos(p.x*20.0+sin(p.y*3.0)*3.0))),vec3(1.2))*0.7;\n\t\n\tc+=vec3(1.0,0.8,0.4)*pow(0.5+0.5*cos(p.x*20.0)*sin(p.y*12.0),20.0)*2.0;\n\t\n\tc+=vec3(0.1,0.5+0.5*cos(p*20.0))*vec3(0.05,0.1,0.4).bgr*0.7;\n\t\n\treturn c;\n}\n\nvec3 calculateColor(vec2 p,float border){\n    float sm=0.02;\n\tvec2 res=vec2(3.5);\n\tvec2 ip=floor(p*res)/res;\n\tvec2 fp=fract(p*res);\n\tfloat m=1.0-max(smoothstep(border-sm,border,abs(fp.x-0.5)),smoothstep(border-sm,border,abs(fp.y-0.5)));\n\tm+=1.0-smoothstep(0.0,0.56,distance(fp,vec2(0.5)));\n\treturn m*squaresColours(ip);\n}\n\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n                    in Light_t light, vec3 nearest_hitPos, int hitWhichPlane )\n{\n    Material_t mat = Material[1];\n    vec2 p, intPart;\n    float countIntPart;\n    if(hitWhichPlane == 0 || hitWhichPlane == 5) p = nearest_hitPos.xz;\n    else if(hitWhichPlane == 1 || hitWhichPlane == 3) p = nearest_hitPos.xy;\n    else if(hitWhichPlane == 2 || hitWhichPlane == 4) p = nearest_hitPos.yz;\n    else if(hitWhichPlane < 0){p.y = nearest_hitPos.y; p.x = length(nearest_hitPos.xz);}\n    p = p / blockNum;\n    mat.k_d = calculateColor(p, blockLength);\n    mat.k_a = 0.4 * mat.k_d;\n    mat.k_r = 3.0 * mat.k_d;\n\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a +\n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray,\n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg )\n{\n    // Find whether and where the ray hits some object.\n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Try interesecting input ray with all the planes and spheres,\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    //which Plane does it hit\n    int hitWhichPlane;\n\n    //Intersection with the plane\n    for(int i=0; i<NUM_PLANES; i++){\n        temp_hasHit = IntersectPlane(Plane[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n        if(temp_hasHit && temp_t<nearest_t){\n            hasHitSomething = true;\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Plane[i].materialID;\n            hitWhichPlane = i;\n        }\n    }\n    //Intersection with the sphere\n    for(int i=0; i<ShowBallNumber; i++){\n        temp_hasHit = IntersectSphere(showSphere[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n        if(temp_hasHit && temp_t<nearest_t){\n            hasHitSomething = true;\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Sphere[i].materialID;\n        }\n    }\n    //Intersection with the cylinder\n    for(int i=0; i<NUM_CYLINDERS; i++){\n        temp_hasHit = IntersectionCylinder(Cylinder[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n        if(temp_hasHit && temp_t<nearest_t){\n            hasHitSomething = true;\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Cylinder[i].materialID;\n            hitWhichPlane = -1;\n        }\n    }\n\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Accumulate lighting from each light source on the nearest hit point.\n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres) between the\n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    for(int i=0; i<NUM_LIGHTS; i++){\n        // Check whether it is in shadow\n        bool inShadow = false, tempInShadow;\n        Ray_t shadowRay;\n        shadowRay.o = nearest_hitPos;\n        shadowRay.d = normalize(Light[i].position - nearest_hitPos);\n        // Since it is a line segement, we need to find the endpoint's t value\n        float LineSegmentMin = DEFAULT_TMIN;\n        float LineSegmentMax = length(Light[i].position - nearest_hitPos);\n        for(int j=0; j<NUM_PLANES; j++){\n            if(inShadow) break;\n            tempInShadow = IntersectPlane(Plane[j], shadowRay, LineSegmentMin, LineSegmentMax);\n            if(tempInShadow) inShadow = true;\n        }\n        for(int j=0; j<ShowBallNumber; j++){\n            if(inShadow) break;\n            tempInShadow = IntersectSphere(showSphere[j], shadowRay, LineSegmentMin, LineSegmentMax);\n            if(tempInShadow) inShadow = true;\n        } \n        for(int j=0; j<NUM_CYLINDERS; j++){\n            if(inShadow) break;\n            tempInShadow = IntersectionCylinder(Cylinder[j], shadowRay, LineSegmentMin, LineSegmentMax);\n            if(tempInShadow) inShadow = true;\n        }\n        // Prepare needed parameters\n        vec3 L = normalize(Light[i].position - nearest_hitPos);\n        vec3 N = normalize(nearest_hitNormal);\n        vec3 V = normalize(-ray.d);\n        if(nearest_hitMatID == 3){\n            I_local += PhongLighting(L, N, V, inShadow, Light[i], nearest_hitPos, hitWhichPlane);\n        }\n        else{\n            I_local += PhongLighting(L, N, V, inShadow, Material[nearest_hitMatID], Light[i]);\n        }         \n    }\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    return I_local;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    // Position the camera.\n    vec3 cam_pos = vec3( 3.5 * cos(MyITime*0.1), 4.0, 3.5 * sin(MyITime*0.1) );\n    vec3 cam_lookat = vec3( 0.0, 1.0 +cos(MyITime) , 0.0 );\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ )\n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n\n    fragColor = vec4( I_result, 1.0 );\n}", "image_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftSXDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2825, 2853, 2873, 2873, 6627], [6630, 6812, 6830, 6856, 15294], [15298, 15794, 15948, 15948, 16278], [16282, 16614, 16697, 16697, 16909], [16913, 17431, 17588, 17702, 18427], [18431, 18764, 18849, 18963, 19584], [19586, 19586, 19725, 19725, 20606], [20608, 20608, 20697, 20697, 21331], [21335, 21689, 21819, 21819, 22231], [22233, 22282, 22311, 22311, 22790], [22792, 22792, 22833, 22833, 23113], [23115, 23115, 23266, 23266, 24199], [24202, 24991, 25104, 25195, 30423], [30427, 30788, 30845, 30845, 32317]], "test": "untested"}
{"id": "ftSSWR", "name": "Data Storage", "author": "dr2", "description": "Accessing the archives...", "tags": ["robot", "kinematics", "mechanism"], "likes": 12, "viewed": 299, "published": 3, "date": "1627381375", "time_retrieved": "2024-07-30T19:09:05.211035", "image_code": "// \"Data Storage\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Hashv2f (float p);\n\nvec3 qHit,ltPos, cPos;\nvec2 gCur, gSize, cDel, angC;\nfloat dstFar, tCur, tCyc, tPhs, hCyc, bWid, zPos;\nint idObj;\nbool isSh;\nconst int idCyl = 1, idTel = 2, idRail = 3, idFrame = 4, idBase = 5, idWal = 6, idSup = 7, idLamp = 8,\n   idCylP = 9;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, ts, zFrm;\n  dMin = dstFar;\n  zFrm = 3. * 0.9 + 0.96;\n  zPos = 0.;\n  for (float k = float (VAR_ZERO); k <= 3.; k ++) {\n    q = p;\n    q.xy -= vec2 (0.5 * (gCur.x + cDel.x), cDel.y);\n    if (k > 0.) zPos += 0.1 + 0.9 * SmoothBump (0.3 + 0.03 * k, 0.7 - 0.03 * k, 0.03, tPhs);\n    q.xz = Rot2D (q.xz, angC.x);\n    q.yz = Rot2D (q.yz, angC.y);\n    q.z -= 0.9 * zPos;\n    d = PrRoundCylDf (q, 0.2 - 0.03 * k, 0.02, 0.5);\n    DMINQ (idTel);\n  }\n  ts = abs (tPhs - 0.5) - 0.42;\n  if (hCyc == 0. || ts < 0.) cPos.xy = vec2 (0.5 * gCur.x, (hCyc == 0.) ? 0.5 * gCur.y : cDel.y);\n  else cPos.xy = vec2 (0.5 * gCur.x + 2. * bWid * smoothstep (0., 0.08, ts) * sign (tPhs - 0.5),\n     -0.25 * gSize.y - 2. + 0.5);\n  q = p;\n  if (hCyc == 0. || ts < 0.) {\n    q.xy -= cPos.xy;\n    if (hCyc != 0.) {\n      q.xz = Rot2D (q.xz, angC.x);\n      q.yz = Rot2D (q.yz, angC.y);\n      q.z -= 0.9 * (zPos - 3.);\n    }\n    q.z -= zFrm;\n    d = PrRoundCylDf (q, 0.15, 0.02, 0.41);\n  } else {\n    d = bWid - abs (q.x);\n    q.xy -= cPos.xy;\n    q = q.xzy;\n    d = max (PrRoundCylDf (q, 0.15, 0.02, 0.4), - d);\n  }\n  DMINQ (idCylP);\n  q = p;\n  d = max (PrBox2Df (q.xy, 0.25 * gSize), - PrBox2Df (q.xy - 0.5 * gCur, vec2 (0.25)));\n  q.xy = mod (q.xy + 0.25, 0.5) - 0.25;\n  q.z -= zFrm;\n  d = max (d, PrRoundCylDf (q, 0.15, 0.02, 0.4));\n  DMINQ (idCyl);\n  q = p;\n  q.x -= 0.5 * (gCur.x + cDel.x);\n  q.y -= cDel.y;\n  q.xz = Rot2D (q.xz, angC.x);\n  d = PrRoundCylDf (q.yzx, 0.03, 0.02, 0.45);\n  DMINQ (idRail);\n  q = p;\n  q.x -= 0.5 * (gCur.x + cDel.x);\n  q.xz = Rot2D (q.xz, angC.x);\n  q.y -= 0.25 * gSize.y + 0.5;\n  d = min (PrCylDf (vec3 (q.xz, q.y - 0.65), 0.12, 0.9), PrCapsDf (vec3 (q.xz, abs (q.y + 0.05) - 0.2).yzx,\n     0.12, 0.4));\n  q.x = abs (q.x) - 0.4;\n  q.y -= -0.25 * gSize.y - 0.5;\n  d = min (d, SmoothMax (PrCapsDf (q.xzy, 0.12, 0.25 * gSize.y + 0.65),\n     - PrRoundBoxDf (q - vec3 (-0.08, -0.2, 0.), vec3 (0.08, 0.25 * gSize.y + 0.2, 0.04), 0.01), 0.02));\n  DMINQ (idRail);\n  q = p;\n  q.z = abs (q.z - zFrm) - 0.3;\n  d = max (PrRoundBoxDf (q, vec3 (0.25 * gSize + 0.25, 0.05) - 0.05, 0.05),\n     - max (PrBox2Df (q.xy, vec2 (0.25 * gSize)), length (mod (q.xy + 0.25, 0.5) - 0.25) - 0.17));\n  DMINQ (idFrame);\n  q = p;\n  q.xy = abs (q.xy);\n  q -= vec3 (0.25 * gSize.xy + vec2 (0.1, 1.1), zFrm);\n  d = PrRoundCylDf (q.xzy, 0.4, 0.02, 0.9);\n  DMINQ (idSup);\n  if (! isSh) {\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (bWid, -0.25 * gSize.y - 0.98, 2.);\n    d = max (PrRoundBoxDf (q, vec3 (0.25, 1.2, 5.) - 0.02, 0.02), - SmoothMax (q.x - 0.1,\n       PrBox2Df (q.yz - vec2 (-0.4, -2.), vec2 (0.6, 0.3)), 0.02));\n    DMINQ (idWal);\n    q = p;\n    q.y = abs (q.y);\n    q.yz -= vec2 (0.25 * gSize.y + 2.08, 2.);\n    d = PrRoundBoxDf (q, vec3 (bWid + 0.25, 0.1, 5.) - 0.02, 0.02);\n    DMINQ (idBase);\n    q = p - ltPos;\n    d = PrCapsDf (q.yzx, 0.16, 0.3);\n    DMINQ (idLamp);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float ltDist)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > ltDist) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec4 ObjCol (vec3 ro)\n{\n  vec4 col4;\n  float s;\n  if (idObj == idCyl || idObj == idCylP) {\n    col4 = vec4 (0.2, 0.7, 1., 0.2) * (1. - 0.3 * smoothstep (0., 0.02, abs (abs (qHit.z) - 0.2)) - 0.1) *\n       (0.6 + 0.4 * smoothstep (0., 0.02, length (qHit.xy) - 0.05));\n    if (abs (qHit.z) < 0.2) col4 *= (1. + 0.3 * smoothstep (0.4, 0.5, sin (16. * atan (qHit.y, - qHit.x))));\n    if (idObj == idCylP && hCyc != 0. && zPos < 2.99 && abs (qHit.z) > 0.3)\n       col4 = mix (col4, vec4 (1., 0., 0., -1.), step (0.5, mod (4. * tCur, 1.)));\n  } else if (idObj == idTel) {\n    col4 = vec4 (0.8, 0.85, 0.8, 0.2) *\n       (1. - 0.2 * smoothstep (0., 0.05, abs (qHit.z) - 0.4));\n  } else if (idObj == idRail) {\n    col4 = vec4 (0.85, 0.85, 0.9, 0.2);\n  } else if (idObj == idFrame) {\n    col4 = vec4 (0.6, 0.6, 0.4, 0.) * (1. - 0.4 * smoothstep (0., 0.02,\n       PrRoundBox2Df (qHit.xy, vec2 (0.25 * gSize) - 0.1, 0.2)));\n    if (cDel.y == 0.5 * gCur.y && length (qHit.xy - cPos.xy) < 0.22) col4 = vec4 (0., 1., 0., -1.);\n  } else if (idObj == idSup) {\n    col4 = vec4 (0.6, 0.6, 0.4, 0.1);\n    if (length (qHit.xz) > 0.35) col4 *= 0.8 + 0.2 * smoothstep (-0.4, -0.2,\n       sin (16. * atan (qHit.z, - qHit.x)));\n  } else if (idObj == idBase) {\n    col4 = vec4 (0.5, 0.3, 0.1, 0.);\n    if (abs (ro.x) < bWid + 0.2 && abs (ro.y) < 0.25 * gSize.y + 2.1) {\n      col4 *= 0.6 + 0.4 * smoothstep (0., 0.03, abs (abs (qHit.z + 2.) - 0.2) - 0.02);\n      if (abs (qHit.z + 2.) < 0.2) col4 *= 0.6 + 0.4 * smoothstep (0., 0.03,\n         abs (mod (qHit.x, 0.5) - 0.25) - 0.02);\n    }\n  } else if (idObj == idWal) {\n    col4 = vec4 (0.5, 0.3, 0.1, 0.);\n    if (abs (ro.x) < bWid + 0.2) {\n      s = (1. - smoothstep (0., 0.02, abs (qHit.z + 2.) - 0.3)) *\n         (1. - smoothstep (0., 0.02, abs (qHit.y + 0.4) - 0.6));\n      if (s > 0. && sign (ro.x) * sign (cPos.x - 0.5 * gCur.x) > 0. && abs (ro.x) > bWid - 0.15)\n         col4 = vec4 (1., 0., 0., -1.);\n      else col4 *= 1. - 0.2 * s;\n    }\n  } else if (idObj == idLamp) {\n    col4 = vec4 (vec3 (0.9, 0.9, 0.8) * (0.95 + 0.05 * cos (64. * pi * qHit.y)), -1.);\n  }\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, ltDir;\n  float dstObj, tf, ltDist, sh, nDotL;\n  gSize = vec2 (13., 9.);\n  bWid = 4.5;\n  tCyc = 10.;\n  tCur += 2. * tCyc;\n  tPhs = mod (tCur / tCyc, 1.);\n  hCyc = floor (mod (tCur / tCyc + 0.5, 2.));\n  tf = floor (tCur / (2. * tCyc));\n  gCur = - floor (gSize / 2.) + floor (gSize * Hashv2f (17.11 * tf));\n  angC.y = (hCyc != 0.) ? -0.5 * pi *  (1. - SmoothBump (0.15, 0.85, 0.05, tPhs)) : 0.;\n  angC.x = angC.y;\n  cDel.x = (floor (gSize.x * Hashv2f (17.11 * (tf - 1.)).x - floor (gSize.x / 2.)) - gCur.x) *\n     (1. - smoothstep (0., 1.5, tCur - 2. * tCyc * tf));\n  cDel.y = (0.5 * gCur.y + 2.5) * SmoothBump (0.15, 0.85, 0.06, tPhs) - 2.5;\n  ltPos = vec3 (0., 0.25 * gSize.y + 1.8, -2.6);\n  isSh = false;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = ObjCol (ro);\n    ltDir = ltPos - ro;\n    ltDist = length (ltDir);\n    ltDir /= ltDist;\n    nDotL = max (dot (vn, ltDir), 0.);\n    if (idObj == idRail || idObj == idTel) nDotL *= nDotL;\n    isSh = true;\n    sh = ObjSShadow (ro + 0.01 * vn, ltDir, ltDist);\n    if (col4.a >= 0.) col = col4.rgb * (0.2 + 0.8 * sh * nDotL) +\n       step (0.95, sh) * col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    else col = col4.rgb * (0.5 - 0.5 * dot (rd, vn));\n  } else {\n    col = vec3 (0.1, 0.1, 0.15);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.05 * pi;\n  if (mPtr.z > 0.) {\n    az += 1.5 * pi * mPtr.x;\n    el += 0.3 * pi * mPtr.y;\n  } else {\n    az = 0.2 * pi * (2. * mod (floor (0.05 * tCur), 2.) - 1.) *\n       SmoothBump (0.3, 0.7, 0.15, mod (0.05 * tCur, 1.));\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0.5, -18.);\n  ro.y -= 0.5;\n  zmFac = 3.5;\n  dstFar = 100.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftSSWR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1008, 1008, 1030, 1030, 3934], [3936, 3936, 3969, 3969, 4152], [4154, 4154, 4175, 4175, 4432], [4434, 4434, 4485, 4485, 4728], [4730, 4730, 4753, 4753, 6842], [6844, 6844, 6879, 6879, 8265], [8267, 8267, 8323, 8323, 9391], [9393, 9393, 9439, 9439, 9486], [9488, 9488, 9521, 9521, 9610], [9612, 9612, 9659, 9659, 9706], [9708, 9708, 9750, 9750, 9801], [9803, 9803, 9860, 9860, 9936], [9938, 9938, 9981, 9981, 10045], [10047, 10047, 10092, 10092, 10184], [10186, 10186, 10231, 10231, 10269], [10271, 10271, 10328, 10328, 10411], [10413, 10413, 10449, 10449, 10655], [10657, 10657, 10687, 10687, 10800], [10834, 10834, 10858, 10858, 10911]], "test": "untested"}
{"id": "7ljXzw", "name": "Improved Tesseract", "author": "xertrov", "description": "so far, the best method I've found to render 4d objects is to just sample the W axis multiple times.\nI tried 2-step ray marching too, i.e., ray march in Z then, at the minimum, ray march in W. That should be better but I had some issues w that method.", "tags": ["raymarching", "experiment", "4d", "learning", "hypercube"], "likes": 4, "viewed": 286, "published": 3, "date": "1627370783", "time_retrieved": "2024-07-30T19:09:05.981974", "image_code": "#define u_resolution iResolution\n#define u_mouse iMouse\n#define u_time iTime\n#define gl_FragColor fragColor\n\n#define PI 3.141592653589\n#define TAU 6.28318530718\n\n#define S(a, b, t)smoothstep(a, b, t)\n#define hh(x)(x * 0.5 + 0.5)\n#define zoth vec4(0.0, 1.0, 2.0, 0.5)\n\n#define BLACK vec3(0.0)\n#define WHITE vec3(1.0)\n\n#define GROW_SHRINK 0.3\n#define ROTATE_IDLE 0.2\n#define BASE_TWINKLE 99.0\n#define D4_DIST_MODULO (0.141421356 * 2.0)\n#define STAR_RARITY 0.95\n// set to 10k+ for a hyperspace bungee; curious noise patterns at 2000.\n#define BG_SCALE 100.0\n\nvec2 best2(vec3 p) {\n  vec2 r = p.x > p.y ? vec2(p.x, p.y) : vec2(p.y, p.x);\n  if (p.z > r.x) { return vec2(p.z, r.x);}\n  if (p.z > r.y) { return vec2(r.x, p.z);}\n  return r;\n}\n\nvec3 best3(vec4 p) {\n  vec2 zw = vec2(max(p.z, p.w), min(p.z, p.w));\n  // p.z > p.w ? vec2(p.z, p.w) : vec2(p.w, p.z);\n  vec2 xy = vec2(max(p.x, p.y), min(p.x, p.y));\n  if (xy.y > zw.x) {return vec3(xy, zw.x);} // testme\n  if (zw.y > xy.x) {return vec3(zw, xy.x);}\n  return vec3(max(xy.x, zw.x), min(xy.x, zw.x), max(xy.y, zw.y));\n\n  /* tests\n  col = best2(zoth.xyz) == vec2(2., 1.) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.zywx) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.wxzy) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.wxyz) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.xywz) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  */\n}\n\nvec3 rainbow(vec2 uv, float time) {\n  return sin(vec3(time) + uv.xyx * vec3(1.0, 1.0, 1.0) + vec3(0, 2, 4)) * 0.49 + 0.5;\n}\n\n// from an art of code video I think\nfloat N21b(vec2 p) {\n  vec3 a = fract(vec3(p.xyx) * vec3(213.897, 653.453, 253.098));\n  a += dot(a, a.yzx + 79.76);\n  return fract((a.x + a.y) * a.z);\n}\n\nfloat sdBoxEdge(in vec3 p, in vec3 b) {\n  return length(best2(abs(p) - b));\n}\n\nfloat distTesseractEdge(in vec4 p, in vec4 b) {\n  vec4 d = abs(p) - b;\n  vec3 db = best3(d);\n  return length(db);\n}\n\nfloat sdBox(in vec3 p, in vec3 b) {\n  vec3 d = abs(p) - b;\n  return length(max(d, 0.0)) + min(max(d.z, max(d.x, d.y)), 0.0);\n}\n\nfloat growShrink() {\n  return GROW_SHRINK * sin(u_time / 9.0 * PI) * 0.1 + 0.9;\n}\n\nconst vec2 e = vec2(0.0001, 0.0);\n\nfloat distFunc(in vec4 p) {\n  float grow_shrink = growShrink();\n  vec4 s = vec4(.8, .8, .8, .8) * grow_shrink;\n  float ed = distTesseractEdge(p, s) - 0.04;\n  return ed;\n}\n\nvec4 getIDGV(vec2 uv, float scale) {\n  vec2 id = floor(uv * scale);\n  vec2 gv = fract(uv * scale) - 0.5;\n  return vec4(id, gv);\n}\n\nfloat minOf(vec2 v) {\n  return min(v.x, v.y);\n}\n\nfloat mkNoise(vec2 uv, float t, float minDS) {\n  float scale = fwidth(uv.x) * 100.0 * BG_SCALE;\n  vec4 idgv = getIDGV(uv, scale);\n  vec2 id = idgv.xy;\n  vec2 gv = idgv.zw;\n  float n = N21b(id);\n  float transFreq = BASE_TWINKLE * n + 0.01;\n  t -= 3877.627 * n;\n  float transProgress = fract(t * transFreq);\n  float transId = floor(t * transFreq);\n  float lastIdOffset = N21b(vec2(n, transId - 1.0));\n  float idOffset = N21b(vec2(n, transId));\n  float nextIdOffset = N21b(vec2(n, transId + 1.0));\n  float noiseThresh = STAR_RARITY;\n  float noise = S(1.0, 0.0, transProgress) * S(noiseThresh, 1.0, N21b(id + lastIdOffset));\n  noise += S(noiseThresh, 1.0, N21b(id + idOffset));\n  noise += S(0.0, 1.0, transProgress) * S(noiseThresh, 1.0, N21b(id + nextIdOffset));\n  return S(0.0, 0.2, minOf(0.5 - abs(gv))) * (noise * S(0.1, 2.0, minDS));\n}\n\nmat4 rot4(float angle, int axis) {\n  float s = sin(angle), c = cos(angle);\n  mat4 r = mat4(\n    c, -s, 0, 0,\n    s, c, 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 1\n  );\n  // XY, XZ, XW\n  return axis == 0 ? r\n    : axis == 1 ? mat4(r[0].xzyw, r[2].xzyw, r[1].xzyw, r[3].xzyw)\n    : axis == 2 ? mat4(r[0].xwzy, r[3].xwzy, r[2].xwzy, r[1].xwzy)\n    // YZ, YW\n    : axis == 3 ? mat4(r[3].wxyz, r[0].wxyz, r[1].wxyz, r[2].wxyz)\n    : axis == 4 ? mat4(r[3].wxzy, r[0].wxzy, r[1].wxzy, r[2].wxzy)\n    // ZW\n    : axis == 5 ? mat4(r[3].wzxy, r[2].wzxy, r[0].wzxy, r[1].wzxy) : mat4(0.);\n}\nvec2 sinCos(float a) {\n  return vec2(sin(a), cos(a));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (gl_FragCoord.xy - .5 * u_resolution.xy) / u_resolution.y;\n  vec2 mouse = (u_mouse.xy - 0.5 * u_resolution.xy) / u_resolution.y;\n  float t = u_time / 1.0;\n  vec3 col = BLACK;\n  uv *= 4.0;\n\n  float fw = max(fwidth(uv.x), fwidth(uv.y));\n\n  float grow_shrink = growShrink();\n  //GROW_SHRINK * sin(t * PI) * 0.1 + 0.9;\n\n  mat4 boxTrans = rot4(mouse.x * TAU / 2.0, 4) * rot4(mouse.y * TAU / 2.0 + .3, 1);\n  boxTrans *= rot4(t * 13.0 / 17.0 * ROTATE_IDLE + PI / 3.0 + .9, 0) * rot4(t * 13.0 / 11.0 * ROTATE_IDLE - 17.0 * PI / 7.0, 2);\n  boxTrans *= rot4(t * 13.0 / 17.0 * ROTATE_IDLE + PI - .2, 2) * rot4(t * 13.0 / 11.0 * ROTATE_IDLE - 12.0 * PI / 7.0 - .2, 3);\n  boxTrans *= rot4(t * 13.0 / 17.0 * ROTATE_IDLE + PI / 1.0, 4) * rot4(t * 9.0 / 11.0 * ROTATE_IDLE - 7.9 * PI / 7.0, 5);\n\n  // raymarch over the orthogonal scene\n  // vec2 sc = sinCos(vec2(t));\n  vec2 an = sinCos(12.0 + 0.5*t + 10.0*mouse.x);\n\n  vec4 ro = vec4(0.0, 0., - 2.0, 0.);\n  vec4 rd;\n\n  float fov = 1.3;\n  vec3 ta = vec3( 0.0, 0.0, 0.0 );\n  vec3 ww = normalize( ta - ro.xyz );\n  vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n  vec3 vv = normalize( cross(uu,ww));\n  rd = normalize(vec4(uv.x*uu + uv.y*vv + fov*ww, 0.));\n\n  float d = 0.0, dS = 999.0, minDS = 999.0;\n  float ed = 999.0, ed2 = ed;\n  float steps = 0.0;\n  vec4 p = ro;\n  for(int i = 0; i < 50; i ++ ) {\n    steps ++ ;\n    ed = 999.;\n    for (float w = -1.41; w < 1.41; w += .05) {\n      ed = min(ed, distFunc((vec4(p.xyz, p.w + w)) * boxTrans));\n    }\n    dS = ed;\n    minDS = min(minDS, dS);\n    p = p + dS * rd;\n    d += dS;\n    if (dS < 0.001 || d > 100.0)break;\n  }\n\n  vec3 RED = zoth.yxx * 0.3;\n\n  float noise = mkNoise(uv * grow_shrink, t, minDS);\n  col += noise;\n  col += S(0.01, 0.0, dS) * WHITE * (.5 + .5 * rainbow(uv, u_time + 2.0));\n  col += S(0.023, 0.005, minDS) * rainbow(uv, u_time + 2.0);\n\n  gl_FragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ljXzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[555, 555, 575, 575, 731], [733, 733, 753, 753, 1510], [1512, 1512, 1547, 1547, 1635], [1637, 1674, 1694, 1694, 1826], [1828, 1828, 1867, 1867, 1905], [1907, 1907, 1954, 1954, 2022], [2024, 2024, 2059, 2059, 2150], [2152, 2152, 2172, 2172, 2233], [2270, 2270, 2297, 2297, 2440], [2442, 2442, 2478, 2478, 2571], [2573, 2573, 2594, 2594, 2620], [2622, 2622, 2668, 2668, 3458], [3460, 3460, 3494, 3494, 4032], [4033, 4033, 4055, 4055, 4088], [4091, 4091, 4146, 4146, 6035]], "test": "untested"}
{"id": "fljSzm", "name": "Dark Jungle", "author": "intrakits", "description": "Trying to make a cool jungle thing with water.", "tags": ["3d", "water", "rocks", "jungle"], "likes": 2, "viewed": 282, "published": 3, "date": "1627357533", "time_retrieved": "2024-07-30T19:09:07.088017", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST 0.01\n#define AA 1\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nvec2 rand2(vec2 p)\n{\n\tvec2 q = vec2(dot(p,vec2(127.1,311.7)), \n\t\tdot(p,vec2(269.5,183.3)));\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat rand(vec2 p)\n{\n\treturn fract(sin(dot(p,vec2(419.2,371.9))) * 833458.57832);\n}\n\nfloat iqnoise(in vec2 pos, float irregular, float smoothness)\n{\n\tvec2 cell = floor(pos);\n\tvec2 cellOffset = fract(pos);\n\n\tfloat sharpness = 1.0 + 63.0 * pow(1.0-smoothness, 4.0);\n\t\n\tfloat value = 0.0;\n\tfloat accum = 0.0;\n\t// Sample the surrounding cells, from -2 to +2\n\t// This is necessary for the smoothing as well as the irregular grid.\n\tfor(int x=-2; x<=2; x++ )\n\tfor(int y=-2; y<=2; y++ )\n\t{\n\t\tvec2 samplePos = vec2(float(y), float(x));\n\n  \t\t// Center of the cell is not at the center of the block for irregular noise.\n  \t\t// Note that all the coordinates are in \"block\"-space, 0 is the current block, 1 is one block further, etc\n\t\tvec2 center = rand2(cell + samplePos) * irregular;\n\t\tfloat centerDistance = length(samplePos - cellOffset + center);\n\n\t\t// High sharpness = Only extreme values = Hard borders = 64\n\t\t// Low sharpness = No extreme values = Soft borders = 1\n\t\tfloat sam = pow(1.0 - smoothstep(0.0, 1.414, centerDistance), sharpness);\n\n\t\t// A different \"color\" (shade of gray) for each cell\n\t\tfloat color = rand(cell + samplePos);\n\t\tvalue += color * sam;\n\t\taccum += sam;\n\t}\n\n\treturn value/accum;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    //line from a to b\n    vec3 ab = b-a;\n    \n    // line from p to a\n    vec3 ap = p-a;\n    \n    // as p approaches a, it will be 1\n    // as p approaches b it will b 0\n    float t = dot(ab,ap) / dot(ab,ab);\n    \n    // clamp values between 0 and 1\n    t= clamp(t,0.,1.);\n    \n    // center point of the capsule\n    // start at a (top of capsule)\n    // go towards b, t steps\n    vec3 c = a + t*ab;\n    \n    float d = length(p-c)-r;\n    \n    return d;\n}\n\nfloat sdTorus(vec3 p, vec2 r){\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.));\n}\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n  p = abs(p);\n  vec2 b = vec2(la,lb);\n  float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n  vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\nvec2 colMin(vec2 res, vec2 obj){\n    res.x = min(obj.x,res.x);\n    if(obj.x == res.x){\n        res.y = obj.y;\n    }\n    return res;\n}\n// https://iquilezles.org/articles/smin\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\nfloat getDisp(vec2 uv){\n\n    vec2 p = 0.5 - 0.5*sin(vec2(1.01,1.71) );\n    p = vec2(1.0, 1.0);\n\t\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\t\n\tfloat f = iqnoise(24.0*uv, p.x, p.y);\n\t\n\treturn f;\n}\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\nvec2 GetDist(vec3 p){\n    vec3 gP = p;\n    vec3 grnd = texture(iChannel1, p.xz*.5).rgb;\n    gP.y-=grnd.r*.3;\n    vec2 res = vec2(gP.y,1);\n    float poolM = length(p-vec3(0,0,-11))-4.;\n   // res.x = min(poolM,res.x);\n    res.x = opSmoothSubtraction( poolM,res.x, .3 );\n    \n    //float off =sin(5.*iTime+p.x)*.1+sin(3.*iTime+p.z)*.1;\n    //off*=sin(iTime+p.x*2.);\n    float off=sin(7.*iTime+(length(p-vec3(2,0,-11))-.4)*7.*smoothstep(4.,2.,length(p-vec3(2,0,-11))-.4))*.01;\n    \n    vec2 pool = vec2(p.y,2);\n    pool.x-=off;\n    off=sin(3.*iTime+(length(p-vec3(-1,0,-10))-.1)*7.*smoothstep(3.,2.,length(p-vec3(-1,0,-10))-.4))*.01;\n    pool.x-=off;\n    pool.x = max(poolM,pool.x);\n    res = colMin(pool,res);\n    \n    vec2 rock = vec2(length(p-vec3(2,0,-11))-1.,3.);\n    rock-=texture(iChannel1, p.xz*.1).r;\n    res = colMin(res,rock);\n    \n    rock = vec2(length(p-vec3(-1.4,0,-10))-.1,3.);\n    rock-=texture(iChannel1, p.xz*.2).r;\n    res = colMin(res,rock);\n    \n    rock = vec2(length(p-vec3(4,1,-7))-2.,3.);\n    rock-=texture(iChannel1, p.xz*.1).r;\n    res = colMin(res,rock);\n    \n \n    \n    vec2 tree = vec2(sdCylinder(p-vec3(-4,0,-8), vec3(0,0,0), vec3(p.y,8,-p.y), 2.),4.);\n    vec2 uv = vec2(atan(p.x,p.z)/(3.14159*4.),p.y*.04);\n    tree.x -= texture(iChannel3, uv).r*.5;\n    res = colMin(res,tree);\n    vec3 torP = p;\n    torP-=vec3(0,0,-15);\n    torP.yz*=Rot(1.5707);\n    \n    vec2 torRock = vec2(sdTorus(torP, vec2(5,.9)),7.);\n    uv = vec2(atan(torP.x,p.y)/(3.14159/1.),torP.y*.4);\n    torRock.x -= texture(iChannel1, uv).r*.5;\n    res = colMin(res,torRock);\n    \n    torP = p;\n    torP-=vec3(5,0,-15);\n    torP.yz*=Rot(1.5707);\n    torP.xy*=Rot(1.2);\n    \n    torRock = vec2(sdTorus(torP, vec2(5,.9)),7.);\n    uv = vec2(atan(torP.x,p.y)/(3.14159/1.),torP.y*.4);\n    torRock.x -= texture(iChannel1, uv).r*.5;\n    res = colMin(res,torRock);\n    \n    \n    vec2 vine = vec2(sdCylinder(p-vec3(sin(iTime*2.+p.y)*.1,0,-8), vec3(0,0,0), vec3(0,8,0), .1),5.);\n    vec2 vine2 = vec2(sdCylinder(p-vec3(sin(iTime*2.+p.y)*.2+1.,0,sin(iTime*3.+p.y)*.2-8.), vec3(0,0,0), vec3(0,8,0), .1),5.);\n    uv = vec2(atan(p.x+10.,p.z)/(3.14159*10.),p.y/10.);\n    vine.x-=texture(iChannel1, uv).r*.5;\n    uv = vec2(atan(p.x+10.,p.z)/(3.14159*15.),p.y/20.);\n    vine2.x-=texture(iChannel1, uv).r*.4;\n    //vec2 leaf = vec2(dBox(p-vec3(sin(iTime*2.+p.y)*.1,1.+abs((-p.z-7.9))*2.,-7.9), vec3(pow(-p.z-7.9,2.),.01,.4)),5);\n    //p.y=mod(p.y, 2.0/(2.*sin(p.y))) + 1.0;\n    //vec2 leaf =vec2(dBox(p-vec3(sin(iTime*2.+p.y)*.1, 1.0,-7.98+2.*sin(abs(p.x-sin(iTime*2.)*.1))),.1*vec3(sin(p.y),2.-.1*.3*sin(4.+(p.x-sin(iTime*2.)*.1)*3.),.1)),5);\n    //vine = smin(vine, leaf,.2);\n    res = colMin(res,vine);\n    res = colMin(res,vine2);\n  //  res.x = leaf.x;\n    return res;\n}\nvec2 RayMarch(vec3 ro, vec3 rd){\n    // distance from origin\n    vec2 dO=vec2(0.,0.);\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO.x*rd;\n        \n        // get distance to seam\n        vec2 ds = GetDist(p);\n        //move origin to new point\n        dO+=ds.x*.7;\n        if(ds.x < SURFACE_DIST){\n            dO.y = ds.y;\n            break;\n        }\n        else if( dO.x > MAX_DIST){\n            dO.y= -1.;\n            break;\n        }\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    //distance to point being analyzed\n    float d = GetDist(p).x;\n    \n    //distance to another point along the objects surface that is closeby\n    vec2 e = vec2(0.01,0);\n    \n    //slope between the two points\n    //note: swizzel is the .xxy or .yyx etc\n    vec3 n = d - vec3(\n         GetDist(p-e.xyy).x,\n         GetDist(p-e.yxy).x,\n         GetDist(p-e.yyx).x);\n         \n    return normalize(n);\n    \n}\nfloat GetLight(vec3 p){\n    //position of the light source\n    vec3 lightPos = vec3(4,5.,10);\n    \n    lightPos.xz += vec2(sin(iTime),cos(iTime));\n    //light vector\n    vec3 l = normalize(lightPos-p);\n    \n    //normal of object\n    vec3 n = GetNormal(p);\n    \n    // dot product of the light vector and normal of the point\n    // will give us the amount of lighting to apply to the point\n    // dot() evaluates to values between -1 and 1, so we will clamp it\n    float diff = clamp(dot(n, l),0.,1.);\n    \n    // calculate if point should be a shadow:\n    // raymarch from point being calculated towards light source\n    // if hits surface of something else before the light,\n    // then it must be obstructed and thus is a shadow\n    // the slight offset \"p+n*SURFACE_DIST*1.1\" is needed to ensure the\n    // break condistions in the function are not met too early\n    float d = RayMarch(p+n*SURFACE_DIST*1.1,l).x;\n    if(d < length(lightPos-p)){\n        diff *= .1;\n    }\n    \n    return diff;\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nfloat DrawSquare (vec2 uv, float width, float height, float posX, float posY, float blur){\n    float w = length((uv.x + posX));\n    float h = length(uv.y + posY);\n    float col = smoothstep(width,width-blur, w);\n    col *= smoothstep(height,height-blur, h);\n    return col;\n}\nvec3 A (vec2 uv){\n    vec3 base =vec3(1)*DrawSquare (uv-vec2(0,0), .1-uv.y*.2, .2, 0., 0., .01);\n    vec3 mask =vec3(1)*DrawSquare (uv-vec2(0,.1), .05-uv.y*.2, .07, 0., 0., .01);\n    vec3 mask2 =vec3(1)*DrawSquare (uv-vec2(0,-.1), .05-uv.y*.2, .1, 0., 0., .01);\n    return base - mask - mask2;\n}\nvec3 X (vec2 uv){\n    vec3 slashR = vec3(1)*DrawSquare (uv-vec2(uv.y*.5,0), .04, .2, 0., 0., .01);\n    vec3 slashL = vec3(1)*DrawSquare (uv-vec2(-uv.y*.5,0), .04, .2, 0., 0., .01);\n    return slashR+slashL;\n}\nvec3 coneText(vec2 uv){\n    vec3 col = A(uv-vec2(-.3,0))+X(uv-vec2(0,0));\n    return col;\n}\nvec3 Render (inout vec3 ro, inout vec3 rd, inout float reflVal){\n//------------------\n    vec2 d = RayMarch(ro,rd);\n// position of point\n    // start at ray origin\n    // move d units in the ray direction\n    vec3 p = ro + rd *d.x;\n //get diffuse lighting\n    float diff = GetLight(p);\n    vec3 col = vec3(0);\n    col = vec3(diff);\n    \n    vec3 n = GetNormal(p);\n    vec3 r = reflect(rd, n);\n    vec3 refl = texture(iChannel0, r).rgb;\n    refl= refl*abs(n.y) + refl*abs(n.z) + refl*abs(n.x);\n    \n    if(d.y == 1.){\n        vec3 gCol = smoothstep(.1,.5,p.y)*vec3(0,1,0);\n        vec3 bCol = smoothstep(.15,.1,p.y)*vec3(0,1,1)*.4;\n        col *= gCol+bCol;\n\n        //col*=refl;\n        reflVal = .1;\n    }\n    else if(d.y==2.){\n       col *= vec3(0,1,1);\n       reflVal = 0.9;\n    }\n    else if(d.y==3.){\n        float off = pow(sin(iTime*2.),2.)*.5+1.;\n        vec2 uv = vec2(atan(p.x,p.z)/(3.14159),p.y-off);\n        uv.x-=.4;\n        uv.y-=.3;\n        col*=vec3(1,0,0);\n        col-= coneText(uv).rgb;\n        reflVal = 0.1;\n    }\n    else if(d.y==4.){\n      col*=vec3(1.,.7,.5)*.6;\n      col+=vec3(0,1,0)*smoothstep(4.,0.,p.y)*.3;\n     // vec2 uv = vec2(atan(p.x,p.z)/(3.14159*4.),p.y*.04);\n      //col*=texture(iChannel3, uv).rgb;\n      reflVal=0.6*smoothstep(4.,0.,p.y);\n    }\n    else if(d.y==5.){\n      col*=.3*vec3(0,1,.5);\n      vec2 uv = vec2(atan(p.x+10.,p.z)/(3.14159*4.),p.y*.04);\n      col.b+=smoothstep(.5,1.,texture(iChannel3, uv).r);\n      reflVal=0.6*smoothstep(4.,0.,p.y);\n    }\n    else if(d.y==6.){\n      col=vec3(1.,1,0);\n      col.xy*=sin(iTime*3.)*.5+.5;\n      reflVal=0.9;\n    }\n    else if(d.y==7.){\n      col*=.6*vec3(1.);\n      col+=vec3(0,1,0)*smoothstep(4.,0.,p.y)*.3;\n      reflVal=0.9*smoothstep(6.,0.,p.y);\n    }\n    else{\n        col=texture(iChannel0, rd).rgb;\n    }\n     ro = p+n*SURFACE_DIST*3.;\n     rd=r;\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n   \n    \n    //camera\n    //-----------------\n    // ray origin\n    //controls position\n    vec3 ta = vec3( 1., 5., -3);\n    vec3 ro = ta + vec3( 0, .5,1.);\n    mat3 ca = setCamera( ro, ta,0.);\n//    vec3 ro = vec3(0,3,-5);\n\n    \n    //ray dir\n    //controls rotation\n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 pt = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 pt = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n    vec3 rd = ca * normalize( vec3(pt,2.5) );\n    \n    \n    \n    float reflVal = 1.;\n    vec3 col = Render(ro,rd,reflVal);\n    vec3 bounce = reflVal*Render(ro,rd,reflVal);\n    col += bounce;\n    /*vec3 bounce2 = reflVal*Render(ro,rd,reflVal);\n    col += bounce2;*/\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fljSzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 112, 112, 140], [142, 142, 162, 162, 269], [271, 271, 291, 291, 354], [356, 356, 419, 419, 1469], [1471, 1471, 1490, 1490, 1552], [1553, 1553, 1604, 1604, 1888], [1890, 1890, 1939, 1962, 2395], [2397, 2397, 2427, 2427, 2498], [2500, 2500, 2527, 2527, 2566], [2567, 2567, 2631, 2631, 2882], [2883, 2883, 2915, 2915, 3016], [3017, 3057, 3095, 3095, 3192], [3194, 3234, 3275, 3275, 3347], [3348, 3348, 3406, 3406, 3507], [3508, 3508, 3531, 3531, 3726], [3727, 3727, 3774, 3774, 3807], [3808, 3808, 3829, 3829, 6559], [6560, 6560, 6592, 6620, 7133], [7134, 7134, 7157, 7196, 7567], [7568, 7568, 7591, 7626, 8566], [8567, 8567, 8619, 8619, 8796], [8797, 8797, 8887, 8887, 9072], [9073, 9073, 9090, 9090, 9368], [9369, 9369, 9386, 9386, 9577], [9578, 9578, 9601, 9601, 9669], [9670, 9670, 9734, 9755, 11533]], "test": "untested"}
{"id": "Nt2Xzm", "name": "North Star Combiner SDF", "author": "zalo", "description": "Quick Test to see how badly SDF CSG Operations + ellipsoid approximations bastardize the shape of north star combiner.\n\nI primarily focused on the reflecting surfaces; the outline/nose cutout aren't terribly accurate.", "tags": ["sdf", "star", "combiner", "north"], "likes": 0, "viewed": 242, "published": 3, "date": "1627351472", "time_retrieved": "2024-07-30T19:09:08.126241", "image_code": "// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Forked from https://www.shadertoy.com/view/tdS3DG\n// Modelled to look like the North Star Combiner Optics\n\n#define AA 2   // make this 3 is you have a fast computer\n\n//------------------------------------------------------------------\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    float  k0 = length(p/r);\n    float  k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// prolate ellipsoid defined by two foci and the radius of the minor axis\nfloat sdEllipsoidFoci( in vec3 p, in vec3 f1, in vec3 f2, in float minorAxis ) \n{\n    // Calculate Major Axis\n    float halfLength    = length(f2 - f1) * 0.5;\n    float halfMinorAxis =       minorAxis * 0.5;\n    float halfMajorAxis     = sqrt((halfLength * halfLength) + (halfMinorAxis * halfMinorAxis));\n    vec3  r             = vec3(halfMajorAxis, halfMinorAxis, halfMinorAxis);\n    \n    // Calculate the input point in local space\n    mat3 rotation;\n    rotation[0] = normalize(f1 - f2); // Use Graham-Schmidt to hallucinate y, z bases\n    rotation[1] = normalize(cross(vec3(0,0,1), rotation[0])); // Twist about x doesn't matter  \n    rotation[2] = normalize(cross(rotation[0], rotation[1])); // because Minor Axes are symmetric\n    rotation    = transpose(rotation); // Transpose because GLSL indexes matrices funny\n    rotation    = inverse  (rotation); // Invert to reverse the rotation\n    vec3 localp = (p - ((f1 + f2) * 0.5)) * rotation;\n    \n    return sdEllipsoid(localp , r);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat opUnion       ( float d1, float d2 ) { return min( d1,d2); }\nfloat opSubtraction ( float d1, float d2 ) { return max(-d1,d2); }\nfloat opIntersection( float d1, float d2 ) { return max( d1,d2); }\n\nfloat approxNorthStarCombiner( vec3 p )\n{\n    vec3 lf1 = vec3(-0.02626856, 0.007116468, -0.03609176);\n    vec3 rf1 = vec3( 0.02626856, 0.007116468, -0.03609176);\n    vec3 lf2 = vec3(-0.2060344, 0.05526515, -0.07436727);\n    vec3 rf2 = vec3( 0.2060344, 0.05526515, -0.07436727);\n\n    // Outer and Inner Ellipsoid Surfaces\n    float d11 = sdEllipsoidFoci( p, lf1, lf2, 0.244949 ); // Inner Surfaces\n    float d12 = sdEllipsoidFoci( p, rf1, rf2, 0.244949 );\n    float d31 = d11 - 0.001; // Outer Surfaces\n    float d32 = d12 - 0.001;\n    float d1  = opUnion(d11, d12);\n    float d3  = opUnion(d31, d32);\n    \n    // Subtract inner (reflecting) surface from outer surface\n    d1 = opSubtraction (d1, d3); \n    \n    // Cut out the outer edges of the ellipsoids\n    d1 = opIntersection(d1, sdRoundBox( p + vec3(0.0, 0.015 , -0.11), vec3(0.08, 0.03, 0.075), 0.005 )); \n\n    // Cut out the nose sort of\n    d1 = opSubtraction(     sdRoundBox( p + vec3(0.0, 0.2  ,-0.15), vec3(0.00, 0.2  , 2   ), 0.01 ), d1);\n    \n    // Debug Spheres for Foci\n    //d1 = opUnion(d1, length(p - lf1) - 0.003 );\n    //d1 = opUnion(d1, length(p - lf2) - 0.003 );\n    //d1 = opUnion(d1, length(p - rf1) - 0.003 );\n    //d1 = opUnion(d1, length(p - rf2) - 0.003 );\n    \n    return d1;\n}\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 p, int id )\n{\n    // North Star Reflector\n    float d1 = approxNorthStarCombiner(p*0.2); // *0.2 scales it up 5x so it's easier to see\n\n    // Ground Plane\n    float d2 = p.y+0.3;\n    \n    return (d1<d2) ? vec2(d1,1.0) : vec2(d2,2.0);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, int id )\n{\n    float m = 0.0;\n    float t = 0.0;\n    const float tmax = 100.0;\n    for( int i=0; i<200 && t<tmax; i++ )\n    {\n\t    vec2 h = map( ro+rd*t, id );\n        if( h.x<0.001 ) break;\n        m = h.y;\n        t += h.x;\n    }\n\n    return (t<tmax) ? vec2(t,m) : vec2(0.0);\n}\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in int id)\n{\n\tfloat res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<256; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, id ).x;\n        res = min( res, smoothstep(0.0,1.0,8.0*h/t ));\n        t += clamp( h, 0.005, 0.02 );\n        if( res<0.001 || t>5.0 ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos, in int id )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy, id ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, id ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, id ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, id ).x );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in int id )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos, id).x;\n        occ += (hr-dd)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );    \n}\n \n// https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, int id )\n{ \n    vec3 col = vec3(0.0);\n    \n    vec2  res = castRay(ro,rd, id);\n\n    if( res.y>0.5 )\n    {\n        float t   = res.x;\n        vec3  pos = ro + t*rd;\n        vec3  nor;\n        float occ;\n\n        // material        \n        if( res.y>1.5 )\n        {\n        \tnor = vec3(0.0,1.0,0.0);\n            col = 0.05*vec3(1.0);\n            col *= 0.7+0.3*checkersGradBox( pos.xz*2.0 );\n            occ = 1.0;\n\n        }\n        else\n        {\n            nor = calcNormal( pos, id );\n            occ = 0.5+0.5*nor.y;\n            col = vec3(0.2);\n        }\n\n        // lighting\n        occ *= calcAO( pos, nor, id );\n\n        vec3  lig = normalize( vec3(-0.5, 1.9, 0.8) );\n        vec3  hal = normalize( lig-rd );\n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\n        float sha = calcSoftshadow( pos, lig, id );\n        sha = sha*sha;\n\n        float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),32.0)*\n                    dif * sha *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n        //vec3 lin = vec3(0.0);\n        //lin += 2.00*dif*vec3(3.30,2.50,2.00)*sha;\n        //lin += 0.50*amb*vec3(0.30,0.60,1.50)*occ;\n        //lin += 0.30*bac*vec3(0.40,0.30,0.25)*occ;\n        //col = col*lin;\n        //col += 2.00*spe*vec3(3.30,2.50,2.00);\n        \n        col *= 5.0;\n        col *= vec3(0.2,0.3,0.4)*amb*occ + 1.6*vec3(1.0,0.9,0.75)*dif*sha;\n        col += vec3(2.8,2.2,1.8)*spe*3.0;            \n\n\n        \n        //col = mix( col, vec3(0.1), 1.0-exp(-0.03*t) );\n    }\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\t\n    vec3 ro = vec3( 1.0*cos(0.8*iTime), 0.12, 1.0*sin(0.8*iTime) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera-to-world transformation\n    vec3 cw = normalize(ta-ro);\n    vec3 cu = normalize( cross(cw,vec3(0.0, 1.0,0.0)) );\n    vec3 cv =          ( cross(cu,cw) );\n\n    // scene selection\n    int id = 0;\n\n    // render\n    vec3 tot = vec3(0.0);\n\t#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 fc = o + vec2( fragCoord.x, fragCoord.y);\n\t\t#else    \n        vec2 fc = vec2( fragCoord.x, fragCoord.y);\n\t\t#endif\n        vec2 p = (-vec2(iResolution.x,iResolution.y) + 2.0*fc)/iResolution.y;\n\n        // ray direction\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        // render\t\n        vec3 col = render( ro, rd, id );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n\t#if AA>1\n    }\n    tot /= float(AA*AA);\n\t#endif\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2Xzm.jpg", "access": "api", "license": "mit", "functions": [[1317, 1371, 1415, 1415, 1506], [1508, 1582, 1663, 1691, 2573], [2575, 2575, 2620, 2620, 2711], [2713, 2713, 2757, 2757, 2779], [2780, 2780, 2824, 2824, 2846], [2847, 2847, 2891, 2891, 2913], [2915, 2915, 2956, 2956, 4172], [4244, 4244, 4275, 4303, 4498], [4500, 4500, 4548, 4548, 4817], [4820, 4820, 4878, 4878, 5165], [5167, 5167, 5210, 5210, 5434], [5436, 5436, 5489, 5489, 5790], [5793, 5845, 5881, 5902, 6125], [6127, 6127, 6174, 6174, 7866]], "test": "untested"}
{"id": "fl2Szm", "name": "Sun sky clouds aurora", "author": "nide", "description": "fork of: https://www.shadertoy.com/view/tdSXzD", "tags": ["reflection", "sunset", "clouds", "aurora", "atmosphere", "sunrise"], "likes": 10, "viewed": 1034, "published": 3, "date": "1627348622", "time_retrieved": "2024-07-30T19:09:08.956022", "image_code": "// fork of: https://www.shadertoy.com/view/tdSXzD\n/* \n Changes: \n - tweaked constants\n - replaced ambigous macro named t with tAdj\n - removed simple sun and rain drops\n*/\n\n\n// The sun, the sky and the clouds. By StillTravelling\n// https://www.shadertoy.com/view/tdSXzD\n// Very much a messy hack sorry!!\n\n// Many Thank yous go to the below for their amazing work\n// Day and night sky cycle. By László Matuska (@BitOfGold)\n// Creates a sky texture for a skydome\n// https://www.shadertoy.com/view/ltlSWB\n\n// Weather. By David Hoskins, May 2014.\n// https://www.shadertoy.com/view/4dsXWn\n\n// Edge of atmosphere\n// created by dmytro rubalskyi (ruba)\n// https://www.shadertoy.com/view/XlXGzB\n\n// Auroras\n// created by nimitz\n// https://www.shadertoy.com/view/XtGGRt\n\n// Sorry to those I've missed out!!\n\n//#define tAdj (iTime*4.3)\n#define tAdj (2140.+iTime*0.35)\n\n#define ORIG_CLOUD 0\n#define NICE_HACK_SUN 1\n#define SOFT_SUN 1\n#define cloudy  (sin(tAdj*0.1)*sin(tAdj*0.42)*0.35+0.55) //0.0 clear sky\n#define haze  0.002 * (cloudy*50.)\n#define rainmulti (sin(tAdj*0.2+1.)*0.35+0.35)*16. // makes clouds thicker\n#define rainy (20.0 -rainmulti)\n#define fov tan(radians(50.0))\n#define S(x, y, z) smoothstep(x, y, z)\n#define cameraheight 15e1 //50.\n#define mincloudheight 5e3 //5e3\n#define maxcloudheight 8e3 //8e3\n#define xaxiscloud tAdj*2e2 //t*5e2 +t left -t right *speed\n#define yaxiscloud 0. //0.\n#define zaxiscloud tAdj*3e2 //t*6e2 +t away from horizon -t towards horizon *speed\n#define cloudnoise 18e-5 //2e-4\n\n//#define cloud2\n\n\n//Performance\nconst int steps = 16; //16 is fast, 128 or 256 is extreme high\nconst int stepss = 16; //16 is fast, 16 or 32 is high \n\n//Environment\nconst float R0 = 6360e3; //planet radius //6360e3 actual 6371km\nconst float Ra = 6380e3; //atmosphere radius //6380e3 troposphere 8 to 14.5km\nconst float I = 10.; //sun light power, 10.0 is normal\nconst float SI = 10.; //sun intensity for sun\nconst float g = 0.5; //light concentration .76 //.45 //.6  .45 is normaL\nconst float g2 = g * g;\n\nconst float ts= (cameraheight / 2.5e5);\n\nconst float s = 0.9999; //light concentration for sun\n#if SOFT_SUN\nconst float s2 = s;\n#else\nconst float s2 = s * s;\n#endif\nconst float Hr = 8e3; //Rayleigh scattering top //8e3\nconst float Hm = 1.2e3; //Mie scattering top //1.3e3\n\nvec3 bM = vec3(21e-6); //normal mie // vec3(21e-6)\n//vec3 bM = vec3(50e-6); //high mie\n\n//Rayleigh scattering (sky color, atmospheric up to 8km)\nvec3 bR = vec3(5.8e-6, 13.5e-6, 33.1e-6); //normal earth\n//vec3 bR = vec3(5.8e-6, 33.1e-6, 13.5e-6); //purple\n//vec3 bR = vec3( 63.5e-6, 13.1e-6, 50.8e-6 ); //green\n//vec3 bR = vec3( 13.5e-6, 23.1e-6, 115.8e-6 ); //yellow\n//vec3 bR = vec3( 5.5e-6, 15.1e-6, 355.8e-6 ); //yeellow\n//vec3 bR = vec3(3.5e-6, 333.1e-6, 235.8e-6 ); //red-purple\n\nvec3 C = vec3(0., -R0, 0.); //planet center\nvec3 Ds = normalize(vec3(0., 0., -1.)); //sun direction?\n\nfloat cloudyhigh = 0.05; //if cloud2 defined\n\n#if ORIG_CLOUD\nfloat cloudnear = 1.0; //9e3 12e3  //do not render too close clouds on the zenith\nfloat cloudfar = 1e3; //15e3 17e3\n#else\nfloat cloudnear = 1.0; //15e3 17e3\nfloat cloudfar = 41e3; //160e3  //do not render too close clouds on the horizon 160km should be max for cumulus\n#endif\n\n\n\n\n//AURORA STUFF\nmat2 mm2(in float a){\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nmat2 m2 = mat2(0.95534, 0.29552, -0.29552, 0.95534);\n\nfloat tri(in float x){\n    return clamp(abs(fract(x)-.5),0.01,0.49);\n}\n\nvec2 tri2(in vec2 p){\n    return vec2(tri(p.x)+tri(p.y),tri(p.y+tri(p.x)));\n}\n\nfloat triNoise2d(in vec2 p, float spd)\n{\n    float z=1.8;\n    float z2=2.5;\n\tfloat rz = 0.;\n    p *= mm2(p.x*0.06);\n    vec2 bp = p;\n\tfor (float i=0.; i<5.; i++ )\n\t{\n        vec2 dg = tri2(bp*1.85)*.75;\n        dg *= mm2(tAdj*spd);\n        p -= dg/z2;\n\n        bp *= 1.3;\n        z2 *= 1.45;\n        z *= .42;\n\t\tp *= 1.21 + (rz-1.0)*.02;\n        \n        rz += tri(p.x+tri(p.y))*z;\n        p*= -m2;\n\t}\n    return clamp(1./pow(rz*29., 1.3),0.,.55);\n}\n\n\nfloat hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\nvec4 aurora(vec3 ro, vec3 rd)\n{\n    vec4 col = vec4(0);\n    vec4 avgCol = vec4(0);\n    ro *= 1e-5;\n    float mt = 10.;\n    for(float i=0.;i<5.;i++)\n    {\n        float of = 0.006*hash21(gl_FragCoord.xy)*smoothstep(0.,15., i*mt);\n        float pt = ((.8+pow((i*mt),1.2)*.001)-rd.y)/(rd.y*2.+0.4);\n        pt -= of;\n    \tvec3 bpos = (ro) + pt*rd;\n        vec2 p = bpos.zx;\n        //vec2 p = rd.zx;\n        float rzt = triNoise2d(p, 0.1);\n        vec4 col2 = vec4(0,0,0, rzt);\n        col2.rgb = (sin(1.-vec3(2.15,-.5, 1.2)+(i*mt)*0.053)*(0.5*mt))*rzt;\n        avgCol =  mix(avgCol, col2, .5);\n        col += avgCol*exp2((-i*mt)*0.04 - 2.5)*smoothstep(0.,5., i*mt);\n\n    }\n\n    col *= (clamp(rd.y*15.+.4,0.,1.2));\n    return col*2.8;\n}\n\n//END AURORA STUFF\n\nfloat noise(in vec2 v) { \n    return textureLod(iChannel0, (v+.5)/256., 0.).r; \n}\n\n// by iq\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+ 0.5)/256.0, -100.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\nfloat fnoise( vec3 p, in float t )\n{\n\tp *= .25;\n    float f;\n\n\tf = 0.5000 * Noise(p); p = p * 3.02; p.y -= t*.1; //t*.05 speed cloud changes\n\tf += 0.2500 * Noise(p); p = p * 3.03; p.y += t*.06;\n\tf += 0.1250 * Noise(p); p = p * 3.01;\n\tf += 0.0625   * Noise(p); p =  p * 3.03;\n\tf += 0.03125  * Noise(p); p =  p * 3.02;\n\tf += 0.015625 * Noise(p);\n    return f;\n}\n\nfloat cloud(vec3 p, in float t ) {\n\tfloat cld = fnoise(p*cloudnoise,t) + cloudy*0.1 ;\n\tcld = smoothstep(.4+.04, .6+.04, cld);\n\tcld *= cld * (5.0*rainmulti);\n\treturn cld+haze;\n}\n\nvoid densities(in vec3 pos, out float rayleigh, out float mie) {\n\tfloat h = length(pos - C) - R0;\n\trayleigh =  exp(-h/Hr);\n\tvec3 d = pos;\n    d.y = 0.0;\n    float dist = length(d);\n    \n\tfloat cld = 0.;\n\tif (mincloudheight < h && h < maxcloudheight) {\n\t\t//cld = cloud(pos+vec3(t*1e3,0., t*1e3),t)*cloudy;\n        cld = cloud(pos+vec3(xaxiscloud,yaxiscloud, zaxiscloud),tAdj)*cloudy; //direction and speed the cloud movers\n\t\tcld *= sin(3.1415*(h-mincloudheight)/mincloudheight) * cloudy;\n\t}\n\t#ifdef cloud2\n        float cld2 = 0.;\n        if (12e3 < h && h < 15.5e3) {\n            cld2 = fnoise(pos*3e-4,tAdj)*cloud(pos*1.*14.0+vec3(2.3, 0.001,2.0)*vec3(xaxiscloud,yaxiscloud, zaxiscloud), tAdj);\n            cld2 *= sin(3.1413*(h-12e3)/12e3) * cloudyhigh;\n            cld2 = clamp(cld2,0.0,1.0);\n        }\n    \n    #endif\n\n    #if ORIG_CLOUD\n    if (dist<cloudfar) {\n        float factor = clamp(1.0-((cloudfar - dist)/(cloudfar-cloudnear)),0.0,1.0);\n        cld *= factor;\n    }\n    #else\n\n    if (dist>cloudfar) {\n\n        float factor = clamp(1.0-((dist - cloudfar)/(cloudfar-cloudnear)),0.0,1.0);\n        cld *= factor;\n    }\n    #endif\n\n\tmie = exp(-h/Hm) + cld + haze;\n\t#ifdef cloud2\n\t\tmie += cld2;\n\t#endif\n    \n}\n\n\n\nfloat escape(in vec3 p, in vec3 d, in float R) {\n\tvec3 v = p - C;\n\tfloat b = dot(v, d);\n\tfloat c = dot(v, v) - R*R;\n\tfloat det2 = b * b - c;\n\tif (det2 < 0.) return -1.;\n\tfloat det = sqrt(det2);\n\tfloat t1 = -b - det, t2 = -b + det;\n\treturn (t1 >= 0.) ? t1 : t2;\n}\n\n// this can be explained: http://www.scratchapixel.com/lessons/3d-advanced-lessons/simulating-the-colors-of-the-sky/atmospheric-scattering/\nvoid scatter(vec3 o, vec3 d, out vec3 col, out vec3 scat, in float t) {\n    \n\tfloat L = escape(o, d, Ra);\t\n\tfloat mu = dot(d, Ds);\n\tfloat opmu2 = 1. + mu*mu;\n\tfloat phaseR = .0596831 * opmu2;\n\tfloat phaseM = .1193662 * (1. - g2) * opmu2 / ((2. + g2) * pow(1. + g2 - 2.*g*mu, 1.5));\n    float phaseS = .1193662 * (1. - s2) * opmu2 / ((2. + s2) * pow(1. + s2 - 2.*s*mu, 1.5));\n\t\n\tfloat depthR = 0., depthM = 0.;\n\tvec3 R = vec3(0.), M = vec3(0.);\n\t\n\tfloat dl = L / float(steps);\n\tfor (int i = 0; i < steps; ++i) {\n\t\tfloat l = float(i) * dl;\n\t\tvec3 p = (o + d * l);\n\n\t\tfloat dR, dM;\n\t\tdensities(p, dR, dM);\n\t\tdR *= dl; dM *= dl;\n\t\tdepthR += dR;\n\t\tdepthM += dM;\n\n\t\tfloat Ls = escape(p, Ds, Ra);\n\t\tif (Ls > 0.) {\n\t\t\tfloat dls = Ls / float(stepss);\n\t\t\tfloat depthRs = 0., depthMs = 0.;\n\t\t\tfor (int j = 0; j < stepss; ++j) {\n\t\t\t\tfloat ls = float(j) * dls;\n\t\t\t\tvec3 ps = ( p + Ds * ls );\n\t\t\t\tfloat dRs, dMs;\n\t\t\t\tdensities(ps, dRs, dMs);\n\t\t\t\tdepthRs += dRs * dls;\n\t\t\t\tdepthMs += dMs * dls;\n\t\t\t}\n\n\t\t\tvec3 A = exp(-(bR * (depthRs + depthR) + bM * (depthMs + depthM)));\n\t\t\tR += (A * dR);\n\t\t\tM += A * dM ;\n\t\t} else {\n\t\t}\n\t}\n\n\t//col = (I) * (R * bR * phaseR + M * bM * (phaseM ));\n    col = (I) *(M * bM * (phaseM )); // Mie scattering\n    #if NICE_HACK_SUN\n    col += (SI) *(M * bM *phaseS); //Sun\n    #endif\n    col += (I) *(R * bR * phaseR); //Rayleigh scattering\n    scat = 0.1 *(bM*depthM);\n    //scat = 0.0 + clamp(depthM*5e-7,0.,1.); \n}\n\n\nvec3 hash33(vec3 p)\n{\n    p = fract(p * vec3(443.8975,397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz+19.27);\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z));\n}\n\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    float res = iResolution.x*2.5;\n\n\tfor (float i=0.;i<4.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = hash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.1+0.9);\n        p *= 1.3;\n    }\n    return c*c*.8;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tfloat AR = iResolution.x/iResolution.y;\n    float M = 1.0; //canvas.innerWidth/M //canvas.innerHeight/M --res\n    \n    \n    vec2 uvMouse = (iMouse.xy / iResolution.xy);\n    uvMouse.x *= AR;\n    \n    \n   \tvec2 uv0 = (fragCoord.xy / iResolution.xy);\n    uv0 *= M;\n\t//uv0.x *= AR;\n    \n    vec2 uv = uv0 * (2.0*M) - (1.0*M);\n    uv.x *=AR;\n    \n  \n    if (uvMouse.y == 0.) uvMouse.y=(0.7-(0.05*fov)); //initial view \n    if (uvMouse.x == 0.) uvMouse.x=(1.0-(0.05*fov)); //initial view\n    \n    vec2 spos = uvMouse.xy;\n    float tPos = tAdj*0.02;\n    spos.y=(1.0-(0.4*fov)*(sin(tPos)*0.5+0.5)); //initial view \n    spos.y*=spos.y;\n    spos.x=0.8-sin(tPos*4.0)*0.5;\n    \n\n\tDs = normalize(vec3(spos.x-((0.6*AR)), spos.y*0.3-0.1, (fov/-2.0)));\n    \n    \n\tvec3 O = vec3(0., cameraheight, 0.);\n\tvec3 D = normalize(vec3(uv, -(fov*M)));\n\n\tvec3 color = vec3(0.);\n    vec3 scat = vec3(0.);\n\n    //float scat = 0.;\n\tfloat att = 1.;\n    float staratt = 1.;\n    float scatatt = 1.;\n\tvec3 star = vec3(0.);\n    vec4 aur = vec4(0.);\n\n    float fade = smoothstep(0.,0.01,abs(D.y))*0.5+1.4;\n\n\n    \n    staratt = 1. -min(1.0,(spos.y*2.0));\n    scatatt = 1. -min(1.0,(spos.y*2.2));\n\n\tif (D.y < -ts) {\n\t\tfloat L = - O.y / D.y;\n\t\tO = O + D * L;\n        D.y = -D.y;\n\t\tD = normalize(D+vec3(0,.003*sin(tAdj+6.2831*noise(O.xz+vec2(0.,-tAdj*5e2))),0.));\n\t\tatt = .55;\n        star = stars(D);\n        spos.y < 0.5 ? aur = smoothstep(0.0,2.5,aurora(O,D)):aur = aur;\n\t}\n    else{\n     \tfloat L1 =  O.y / D.y;\n\t\tvec3 O1 = O + D * L1;\n\n    \tvec3 D1 = vec3(1.);\n    \tD1 = normalize(D+vec3(1.,0.0009*sin(tAdj+6.2831*noise(O1.xz+vec2(0.,tAdj*0.8))),0.));\n    \tstar = stars(D1);\n        spos.y < 0.5 ? aur = smoothstep(0.,1.5,aurora(O,D))*fade:aur = aur;\n    }\n\n    star *= att;\n    star *= staratt;\n\n    scatter(O, D, color, scat, tAdj);\n    color *= att;\n    scat *=  att;\n    scat *= scatatt;\n\n    \n    color += scat;\n    color += star;\n    //color=color*(1.-(aur.a)*scatatt) + (aur.rgb*scatatt);\n    color += aur.rgb*scatatt;\n    \n\t//float env = pow( smoothstep(.5, iResolution.x / iResolution.y, length(uv*0.8)), 0.0);\n\tfragColor = vec4(pow(color, vec3(1.0/1.2)), 1.); //gamma correct\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl2Szm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3217, 3232, 3253, 3253, 3326], [3382, 3382, 3404, 3404, 3452], [3454, 3454, 3475, 3475, 3531], [3533, 3533, 3573, 3573, 3982], [3985, 3985, 4009, 4009, 4074], [4075, 4075, 4106, 4106, 4808], [4830, 4830, 4854, 4854, 4911], [4913, 4922, 4948, 4948, 5157], [5160, 5160, 5196, 5196, 5519], [5521, 5521, 5555, 5555, 5697], [5699, 5699, 5763, 5763, 6917], [6921, 6921, 6969, 6969, 7183], [7185, 7325, 7396, 7396, 8753], [8756, 8756, 8777, 8777, 8920], [8922, 8922, 8945, 8945, 9361], [9364, 9364, 9421, 9421, 11576]], "test": "untested"}
{"id": "Nl2Szm", "name": "Ellipsoid Projection", "author": "oneshade", "description": "Based on @iq's article for projecting spheres: [url=https://iquilezles.org/articles/sphereproj/sphereproj.htm]https://iquilezles.org/articles/sphereproj/sphereproj.htm[/url]\nI finally had a use for my ellipse extraction code! :)", "tags": ["3d", "raytracing", "projection", "area", "ellipsoid"], "likes": 20, "viewed": 458, "published": 3, "date": "1627348528", "time_retrieved": "2024-07-30T19:09:10.030151", "image_code": "/*\nAfter reading @iq's article on projecting spheres (https://iquilezles.org/articles/sphereproj)\nI wanted to try something similar so I decided to compute the projection of an ellipsoid.\n\nThe general ellipsoid can be defined as a linearly transformed unit sphere.\nBecause the transformation is independent of the distance the ray has travelled\nthe transformation can be applied to the ray and then to determine the edges of\nthe ellipsoid in screenspace we can analyze the discriminant of a unit sphere intersection.\n\nThe intersection between a ray and a unit sphere requires solving a quadratic equation\nso the discriminant is this (notice that there is no 2 in the B coefficient because it\nall simplifies out of the solution):\nb^2 - ac\n\na = dot(rd, rd)\nb = dot(ro, rd)\nc = dot(ro, ro) - 1\n\nThe full discriminant in terms of 2D coordinates is a quadric (\"quadric\" is short for \"quadratic\"\nbut I also like to use it to differentiate between 1D and 2D second degree equations). This quadric\nencodes all the information about the ellipsoid's projection in screenspace. You can see the\ncoefficients I computed in the projEllipsoid() function below.\n\nThe center of the quadric is where both its partial derivatives equal zero.\nThe axes are at the minima and maxima of the intersection function\nfor a ray rotating at the center of it.\n\nSee https://www.shadertoy.com/view/stS3Ww for the ellipse extraction code.\nIt also has links to some desmos graphs of the workthrough.\n*/\n\n// Constants\n#define PI 3.14159265359\n\n// Structures\nstruct Camera {\n    vec3 pos;\n    mat3 axes;\n    float focal;\n};\n\nstruct Ray {\n    vec3 ro;\n    vec3 rd;\n};\n\n// Ellipse in quadric form to ellipse in parametric form with major and minor axes\n// See https://www.shadertoy.com/view/stS3Ww\nvoid extractEllipse(in float a, in float b, in float c, in float d, in float e, in float f, out mat2 axes, out vec2 size, out vec2 center) {\n    center = vec2(2.0 * b * d - c * e, 2.0 * a * e - c * d) / (c * c - 4.0 * a * b);\n    float g = a * center.x * center.x + b * center.y * center.y + c * center.x * center.y + d * center.x + e * center.y + f;\n\n    float ba = b - a, r = ba / c;\n    float ca = 0.5 * sign(c) / sqrt(1.0 + r * r);\n    float ch = sqrt(0.5 + ca), sh = sqrt(0.5 - ca) * sign(ba);\n    float i = ch - sh, j = ch + sh;\n\n    float ii = i * i, jj = j * j, ij = c * i * j;\n    size = sqrt(-2.0 * g / vec2(a * ii + b * jj + ij, a * jj + b * ii - ij));\n    axes = mat2(i, j, -j, i) * sqrt(0.5);\n}\n\n// Ellipsoid projection\nvoid projEllipsoid(in vec3 pos, in mat3 mat, in Camera cam, out mat2 axes, out vec2 size, out vec2 center) {\n    mat3 inv = inverse(mat), view = inv * cam.axes, tview = transpose(view);\n    vec3 ro = inv * (cam.pos - pos);\n\n    vec3 vo = tview * ro;\n    mat3 vv = tview * view * (dot(ro, ro) - 1.0);\n\n    float a = (vo.x * vo.x - vv[0][0]);\n    float b = (vo.y * vo.y - vv[1][1]);\n    float c = (vo.x * vo.y - vv[0][1]) * 2.0;\n    float d = (vo.x * vo.z - vv[0][2]) * cam.focal * 2.0;\n    float e = (vo.y * vo.z - vv[1][2]) * cam.focal * 2.0;\n    float f = (vo.z * vo.z - vv[2][2]) * cam.focal * cam.focal;\n\n    extractEllipse(a, b, c, d, e, f, axes, size, center);\n}\n\n// Intersectors\nfloat iEllipsoid(in vec3 ro, in vec3 rd, in vec3 pos, in mat3 mat, out vec3 hit, out vec3 nor) {\n    mat3 inv = inverse(mat);\n    vec3 o = inv * (ro - pos), d = inv * rd;\n\n    float a = dot(d, d), b = dot(o, d), c = dot(o, o) - 1.0;\n    float h = b * b - a * c;\n    if (h < 0.0) return -1.0;\n    float t = (-b - sign(c) * h) / a;\n\n    hit = ro + rd * t;\n    nor = normalize(transpose(inv) * inv * (hit - pos)); // Not sure if this is the correct transform, I tried working it out by hand\n\n    return t;\n}\n\nfloat iPlane(in vec3 ro, in vec3 rd, in vec3 pos, in vec3 nor, out vec3 hit) {\n    float t = dot(pos - ro, nor) / dot(rd, nor);\n    hit = ro + rd * t;\n    return t;\n}\n\n// Double integral of mod(floor(x) + floor(y), 2) from a to b\n// Inspired by https://iquilezles.org/articles/checkerfiltering\nfloat integrateCheckers(in vec2 a, in vec2 b) {\n    vec2 u = b - a, v = abs(mod(b, 2.0) - 1.0) - abs(mod(a, 2.0) - 1.0);\n    return 0.5 * (u.x * u.y - v.x * v.y);\n}\n\n// SDFs\nfloat sdDisk(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - t;\n}\n\nfloat sdVerticalLine(in vec2 p, in float h) {\n    return length(vec2(p.x, p.y - h * clamp(p.y / h, 0.0, 1.0)));\n}\n\nfloat sdIsosceles(in vec2 p, in float b, in float h) {\n    p.x = abs(p.x);\n    float q = clamp((b - p.x + p.y) / (b + h), 0.0, 1.0);\n    vec2 re = vec2(p.x - b + b * q, p.y - h * q);\n    vec2 be = vec2(p.x - b * min(p.x / b, 1.0), p.y);\n    return sqrt(min(dot(re, re), dot(be, be))) * sign(p.x + (p.y - h) * b / h * sign(p.y));\n}\n\nfloat sdVectorArrow(in vec2 p, in vec2 v, in float t, in float hw, in float hh) {\n    float m = length(v); vec2 n = v / m;\n    p = vec2(dot(p, n.yx * vec2(1.0, -1.0)), dot(p, n));\n    return min(sdVerticalLine(p, m) - t, sdIsosceles(p - vec2(0.0, m), hw, hh));\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat cbrt(in float x) { return sign(x) * pow(x, 1.0 / 3.0); }\nfloat sdEllipse(in vec2 p, in vec2 ab) {\n    p = abs(p);\n    if (p.x > p.y) p = p.yx, ab = ab.yx;\n    float l = ab.y * ab.y - ab.x * ab.x;\n    float m = ab.x * p.x / l,        m2 = m * m;\n    float n = ab.y * p.y / l,        n2 = n * n;\n    float c = (m2 + n2 - 1.0) / 3.0, c3 = c * c * c;\n    float q = c3 + m2 * n2 * 2.0;\n    float d = c3 + m2 * n2;\n    float g = m + m * n2;\n    float co;\n    if (d < 0.0) {\n        float h = acos(q / c3) / 3.0;\n        float s = cos(h);\n        float t = sin(h) * sqrt(3.0);\n        float rx = sqrt(-c * (s + t + 2.0) + m2);\n        float ry = sqrt(-c * (s - t + 2.0) + m2);\n        co = (ry + sign(l) * rx + abs(g) / (rx * ry) - m) / 2.0;\n    }\n\n    else {\n        float h = 2.0 * m * n * sqrt(d);\n        float s = cbrt(q + h), u = cbrt(q - h);\n        float rx = -s - u - c * 4.0 + 2.0 * m2;\n        float ry = (s - u) * sqrt(3.0);\n        float rm = sqrt(rx * rx + ry * ry);\n        co = (ry / sqrt(rm - rx) + 2.0 * g / rm - m) / 2.0;\n    }\n\n    vec2 r = vec2(co, sqrt(1.0 - co * co)) * ab;\n    return length(p - r) * sign(p.y-r.y);\n}\n\n// Camera and ray routines\nCamera makeCamera(in vec3 pos, in vec3 target, in float focal) {\n    vec3 f = normalize(target - pos);\n    vec3 r = normalize(vec3(-f.z, 0.0, f.x));\n    vec3 u = cross(r, f);\n    return Camera(pos, mat3(r, u, f), focal);\n}\n\nRay makeRay(in vec2 uv, in Camera cam) {\n    return Ray(cam.pos, normalize(cam.axes * vec3(uv, cam.focal)));\n}\n\n// Project onto the camera X and Y axes\nvec2 proj2D(in vec3 p, in Camera cam) {\n    p = (p - cam.pos) * cam.axes;\n    return p.xy / p.z * cam.focal;\n}\n\n#define drawSDF(dist, color) fragColor.rgb = mix(fragColor.rgb, color, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 mouse = ivec2(iMouse) == ivec2(0) ? vec2(0.0, -1.5) : (iMouse.xy - center) / iResolution.y * 3.0;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n\n    // Blue gradient in the background\n    fragColor = vec4(pow(1.0 - length(fragCoord / iResolution.xy - 0.5), 0.8)) * vec4(0.5, 0.5, 1.0, 1.0);\n\n    // Camera and light\n    float rot = 0.1 * cos(iTime) + 1.57;\n    Camera cam = makeCamera(vec3(vec2(cos(rot) * 8.0, 2.0) + mouse, sin(rot) * 8.0), vec3(0.0), 1.0);\n    Ray ray = makeRay(uv, cam);\n\n    vec3 light = normalize(vec3(-1.0, 1.0, 1.0));\n\n    // Ground plane\n    vec3 planeHit, planeNor = vec3(0.0, 1.0, 0.0);\n    float tPlane = iPlane(ray.ro, ray.rd, vec3(0.0, -2.0, 0.0), planeNor, planeHit);\n    if (tPlane > 0.0) {\n        vec2 filt = pow(vec2(length(ray.ro.xz - planeHit.xz) * 0.05), vec2(2.0)) * 0.25; // Hack filter\n        fragColor.rgb = vec3(integrateCheckers(planeHit.xz - filt, planeHit.xz + filt) / (4.0 * filt.x * filt.y));\n    }\n\n    // Ellipse transformation\n    float move = 0.5 * iTime;\n    vec3 ellipPos = vec3(2.5 + sin(iTime), sin(move), cos(move)), ellipRad = vec3(2.25, 1.5, 0.5);\n    mat3 ellipMat = mat3(1.0, 0.0, 0.0,\n                         0.0, 1.0, 0.0,\n                         0.0, 0.0, 1.0);\n\n    float pitch = 0.5 * iTime;\n    float cp = cos(pitch), sp = sin(pitch);\n    ellipMat *= mat3(1.0, 0.0, 0.0, // Rotation about X\n                     0.0, cp, -sp,\n                     0.0, sp, cp);\n\n    float yaw = iTime;\n    float cy = cos(yaw), sy = sin(yaw);\n    ellipMat *= mat3(cy, 0.0, -sy, // Rotation about Y\n                     0.0, 1.0, 0.0,\n                     sy, 0.0, cy);\n\n    // Then scale (I originally got the order wrong so it was mysteriously not rotating XD)\n    ellipMat *= mat3(ellipRad.x, 0.0, 0.0,\n                     0.0, ellipRad.y, 0.0,\n                     0.0, 0.0, ellipRad.z);\n\n    // Intersect the ellipse\n    vec3 ellipHit, ellipNor;\n    float tEllip = iEllipsoid(ray.ro, ray.rd, ellipPos, ellipMat, ellipHit, ellipNor);\n    if (tEllip > 0.0) fragColor.rgb = vec2(max(0.2, dot(light, ellipNor)), 0.0).rrg;\n\n    // Project and draw ellipse trasformation (for debugging, I always\n    // manage to mix something up when I'm dealing with OpenGL's matrices\n    // that are indexed column major and initialized like they're row major and\n    // then they are also transposed when you mutiply backwards)\n    //vec2 projCen = proj2D(ellipPos, cam);\n    //drawSDF(sdVectorArrow(uv - projCen, proj2D(ellipPos + ellipMat[0], cam) - projCen, 0.001, 0.015, 0.03), vec3(0.8, 0.0, 0.0));\n    //drawSDF(sdVectorArrow(uv - projCen, proj2D(ellipPos + ellipMat[1], cam) - projCen, 0.001, 0.015, 0.03), vec3(0.0, 0.8, 0.0));\n    //drawSDF(sdVectorArrow(uv - projCen, proj2D(ellipPos + ellipMat[2], cam) - projCen, 0.001, 0.015, 0.03), vec3(0.0, 0.0, 0.8));\n    //drawSDF(sdDisk(uv, projCen, 0.0125), vec3(0.0));\n\n    // Project the ellipsoid\n    mat2 axes; vec2 size, cen;\n    projEllipsoid(ellipPos, ellipMat, cam, axes, size, cen);\n    drawSDF(abs(sdEllipse(transpose(axes) * (uv - cen), size)) - 0.001, vec3(1.0, 0.5, 0.0));\n    drawSDF(sdVectorArrow(uv - cen, axes[0] * size.x, 0.001, 0.015, 0.03), vec3(1.0, 0.0, 0.0));\n    drawSDF(sdVectorArrow(uv - cen, axes[1] * size.y, 0.001, 0.015, 0.03), vec3(0.0, 1.0, 0.0));\n    drawSDF(sdDisk(uv, cen, 0.015), vec3(0.0, 0.0, 1.0));\n\n    // Virtual camera\n    Camera vcam = makeCamera(vec3(-5.0, mix(-2.0, 3.0, 0.5 + 0.5 * cos(0.1 * iTime)), 0.0), vec3(0.0), 3.0);\n    float vw = 2.0, vh = 1.5; // Screen dimensions\n    vec3 vScreenCenter = vcam.pos + vcam.axes[2] * vcam.focal;\n\n    // Project the vertices composing the virtual camera\n    vec2 camVerts0 = proj2D(vcam.pos + vcam.axes * vec3(-vw,  vh, vcam.focal), cam);\n    vec2 camVerts1 = proj2D(vcam.pos + vcam.axes * vec3(-vw, -vh, vcam.focal), cam);\n    vec2 camVerts2 = proj2D(vcam.pos + vcam.axes * vec3( vw, -vh, vcam.focal), cam);\n    vec2 camVerts3 = proj2D(vcam.pos + vcam.axes * vec3( vw,  vh, vcam.focal), cam);\n    vec2 camVerts4 = proj2D(vcam.pos, cam);\n\n    // Camera wireframe\n    bool drawFrameNow; float wire;\n    if (tEllip < 0.0) {\n        drawFrameNow = dot(ray.ro - (vcam.pos + vcam.axes[2] * vcam.focal), vcam.axes[2]) > 0.0;\n        wire = sdLine(uv, camVerts0, camVerts4, 0.001);\n        wire = min(wire, sdLine(uv, camVerts1, camVerts4, 0.001));\n        wire = min(wire, sdLine(uv, camVerts2, camVerts4, 0.001));\n        wire = min(wire, sdLine(uv, camVerts3, camVerts4, 0.001));\n        if (drawFrameNow) drawSDF(wire, vec3(0.0));\n    }\n\n    // Intersect the virtual camera's screen\n    vec3 screenHit, screenNor = vcam.axes[2];\n    float tScreen = iPlane(ray.ro, ray.rd, vScreenCenter, vcam.axes[2], screenHit);\n    vec2 screenUv = screenHit * mat2x3(vcam.axes[0], vcam.axes[1]); // vec * mat = transpose(mat) * vec\n    if (abs(screenUv.x) < vw && abs(screenUv.y) < vh && (tEllip < 0.0 ? true : tScreen < tEllip)) {\n        fragColor.rgb = vec3(1.0);\n        Ray vray = makeRay(screenUv, vcam);\n        projEllipsoid(ellipPos, ellipMat, vcam, axes, size, cen);\n\n        // Ground plane\n        planeHit, planeNor = vec3(0.0, 1.0, 0.0);\n        tPlane = iPlane(vray.ro, vray.rd, vec3(0.0, -2.0, 0.0), planeNor, planeHit);\n        if (tPlane > 0.0) {\n            vec2 filt = pow(vec2(length(vray.ro.xz - planeHit.xz) * 0.05), vec2(2.0)); // Hack filter\n            fragColor.rgb = vec3(integrateCheckers(planeHit.xz - filt, planeHit.xz + filt) / (4.0 * filt.x * filt.y));\n        }\n\n        tEllip = iEllipsoid(vray.ro, vray.rd, ellipPos, ellipMat, ellipHit, ellipNor);\n        if (tEllip > 0.0) fragColor.rgb = vec2(max(0.2, dot(light, ellipNor)), 0.0).rrg;\n\n        float j = 0.08; // Approximate unstretching factor\n        drawSDF((abs(sdEllipse(transpose(axes) * (screenUv - cen), size)) - 0.001) * j, vec3(1.0, 0.5, 0.0));\n        drawSDF(sdVectorArrow(screenUv - cen, axes[0] * size.x, 0.001, 0.015, 0.03) * j, vec3(1.0, 0.0, 0.0));\n        drawSDF(sdVectorArrow(screenUv - cen, axes[1] * size.y, 0.001, 0.015, 0.03) * j, vec3(0.0, 1.0, 0.0));\n        drawSDF(sdDisk(screenUv, cen, 0.05) * j, vec3(0.0, 0.0, 1.0));\n    }\n\n    // Camera wireframe\n    if (tEllip < 0.0) {\n        if (!drawFrameNow) drawSDF(wire, vec3(0.0));\n        drawSDF(sdLine(uv, camVerts0, camVerts1, 0.001), vec3(0.0));\n        drawSDF(sdLine(uv, camVerts1, camVerts2, 0.001), vec3(0.0));\n        drawSDF(sdLine(uv, camVerts2, camVerts3, 0.001), vec3(0.0));\n        drawSDF(sdLine(uv, camVerts3, camVerts0, 0.001), vec3(0.0));\n    }\n\n    // \"Eye\" of the camera\n    drawSDF(sdDisk(uv, camVerts4, 0.0125), vec3(0.0, 0.0, 1.0));\n\n    // Area of the projected ellipsoid in pixels\n    float area = PI * size.x * size.y * iResolution.y * iResolution.y;\n    vec2 corner = vec2(0.5 * iResolution.x / iResolution.y, 0.5); // Corner of the screen\n    fragColor.rgb = digitIn(fragColor.rgb, vec3(1.0, 0.0, 0.5), uv - vec2(-corner.x + 0.05, corner.y - 0.1), 100.0, area);\n}", "image_inputs": [], "common_code": "// Handy (debugging) font by @valalalalala\n// Thanks!\n\n        /////////////////////////////////////////////////////////////////\n       //                                                            ////\n      //  \"little debugging font\"                                   // //\n     //                                                            //  //\n    //  This utility uses a small bitmapped font (3x5) to render  //   //\n   //  floats, primarily intended for debugging. The code can    //    //\n  //  be copy/pasta'd into the Common tab as needed.            //     //\n //                                                            //     //\n////////////////////////////////////////////////////////////////     //\n//                                                            //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike      //   //                                       //  //\n// 3.0 Unported License                                       //  //\n//                                                            // //\n// by Val \"valalalalala\" GvM 💃 2021                          ////\n//                                                            ///\n////////////////////////////////////////////////////////////////\n\nconst int CHARACTERS[14] = int[14](31599, 9362, 31183, 31207, 23524, 29671, 29679, 30994, 31727, 31719, 1488, 448, 2, 3640);\n\nfloat digitIsOn(in int digit, in vec2 id) {   \n    if (id.x < 0.0 || id.y < 0.0 || id.x > 2.0 || id.y > 4.0 ) return 0.0;\n    return floor(mod(float(CHARACTERS[int(digit)]) / pow(2.0, id.x + id.y * 3.0), 2.0));\n}\n\nfloat digitSign(in float v, in vec2 id) {\n    return digitIsOn(10 - int((sign(v) - 1.0) * 0.5), id);\n}\n\nint digitCount(in float v) {\n    return int(floor(log(max(v, 1.0) ) / log(10.0)));\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v, in int decimalPlaces) {\n    vec2 id = floor(uv * scale);\n\n    if (0.0 < digitSign(v, id)) return 1.0;\n    v = abs(v);\n\n    int digits = digitCount(v);\n    float power = pow(10.0, float(digits));\n    \n    float offset = floor(0.1 * scale);\n    id.x -= offset;\n\n    float n;\n    for (int i = 0; i < 33; i++, id.x -= offset, v -= power * n, power /= 10.0) {\n        n = floor(v / power);\n        if (0.0 < digitIsOn(int(n), id)) return 1.0;   \n        if (i == digits) {\n            id.x -= offset;\n            if (0.0 < digitIsOn(int(12), id)) return 1.0;\n        }\n\n        if (i >= digits + decimalPlaces) return 0.0;\n    }\n\n    return 0.0;\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v) {\n    return digitFirst(uv, scale, v, 3);\n}\n\nvec3 digitIn(in vec3 color, in vec3 toMix, in vec2 uv, in float scale, in float v) {\n    float f = digitFirst(uv, scale, v);\n    return mix(color, toMix, f);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2Szm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1632, 1760, 1900, 1900, 2467], [2469, 2493, 2601, 2601, 3160], [3162, 3178, 3274, 3274, 3682], [3684, 3684, 3762, 3762, 3850], [3852, 3978, 4025, 4025, 4142], [4144, 4152, 4200, 4200, 4232], [4234, 4234, 4293, 4293, 4405], [4407, 4407, 4452, 4452, 4520], [4522, 4522, 4576, 4576, 4852], [4854, 4854, 4935, 4935, 5116], [5118, 5169, 5193, 5193, 5231], [5232, 5232, 5272, 5272, 6308], [6310, 6337, 6401, 6401, 6559], [6561, 6561, 6601, 6601, 6671], [6673, 6713, 6752, 6752, 6823], [6925, 6925, 6980, 6980, 13989]], "test": "untested"}
{"id": "Nl2XRm", "name": "Fractal 70_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 8, "viewed": 419, "published": 3, "date": "1627340359", "time_retrieved": "2024-07-30T19:09:11.011527", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=.3;\n        ++i<90.;\n        O.xyz+=mix(vec3(1),H(log(s)*.3),.8)*.03*exp(-i*i*e)\n    )\n    {\n        p=g*d;\n        p+=R(vec3(1,.8,1.2),vec3(.577),iTime*.03);\n        p=R(p,vec3(.577),iTime*.1);\n        // https://www.shadertoy.com/view/3ttyzB\n        // Based on the idea of jarble\n        p=cos(p*3.+4.*cos(p*.5));\n        vec4 q=vec4(p,sin(iTime)*.2);\n        s=3.;\n        for(int j=0;j++<8;)\n            q=clamp(q,-.5,.5)*2.-q,\n            s*=e=7.*clamp(.3/min(dot(q,q),1.),.0,1.),\n            q*=e;\n        g+=e=length(q)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2XRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 791]], "test": "untested"}
{"id": "Nt2Szw", "name": "Evolving Snowflake Cube Field", "author": "Pelegefen", "description": "_More options in the defines!_\nA \"Snowflake\" that evolves with time on an hexagonally tilled domain.\nthe cubes are fake shaded, and the wave is achieved by wave manipulation (l:109)", "tags": ["waves", "interactive", "cube", "hexagon", "snowflake", "hexagonal", "tilling"], "likes": 15, "viewed": 402, "published": 3, "date": "1627331171", "time_retrieved": "2024-07-30T19:09:11.851281", "image_code": "\n\n//Made with love by Peleg Gefen <3\n\n\n//#define Time_And_Zoom //Allows you to use the horizontal mouse axis to \"peek into the future\" to see the full evolution of the wave.\n\n\n\n//#define Grass_Like //Animates the cubes in a cool low poly growing grass thing.\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n\nvec2 rot (vec2 p,float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return p*mat2(c,s,-s,c);\n}\n\n\n\nfloat hexDist(vec2 p) {\n    p = abs(p);\n    //distance to the diagonal line\n    float c = dot(p, normalize(vec2(1., 1.73)));\n\n    // distance to the vertical line\n    c = max(c, p.x);\n    c += sin(iTime + 4000.) *5. +5.;\n    return c;\n  }\n\nvec4 hexCoords(vec2 uv) {\n    vec2 r = vec2(1., 1.73);\n    vec2 h = r * 0.5;\n    vec2 a = mod(uv, r) - h;\n    vec2 b = mod(uv - h, r) - h;\n\n    vec2 gv;\n    if(length(a) < length(b))\n      gv = a;\n    else\n      gv = b;\n\n    float y = .5 - hexDist(gv);\n    float x = atan(gv.x, gv.y);\n    vec2 id = uv - gv;\n    return vec4(x, y, id.x, id.y);\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat iTime = iTime * .25;\n\tiTime += 800.;\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy)\n\t/iResolution.y;\n    \n    \n     vec4 col = vec4(0.);\n     vec2 uv1 = uv;\n     //uv *= 3.;\n     uv -= 2.;\n     uv *= (sin(iTime * .75)*1.5+1.5) + 3.;\n     uv += vec2(iTime *\t .01);\n\n     #ifdef Time_And_Zoom\n     iTime += iMouse.x * 10.;\n     uv *= iMouse.y * .007;\n     #else\n     uv -= (iMouse.xy / iResolution.xy) * 2. ;\n     #endif\n\n     uv += rot(uv , (cos(iTime)*.5+.5));\n\n \n \n     vec4 uvid = hexCoords(uv * 2.);\n     \n     float t = smoothstep(.5,.5\n \t \t,uvid.y \n \t \t* sin(( length(uvid.zw))\n \t \t * iTime *0.1)*.5+.5);\n   \n    \n\tcol = vec4(\n    t * tan(iTime * .5)*.5+.5 * sin(iTime * 2.5)*.5+.5\n    , t*cos(iTime * .25)*.5+.5* sin(iTime * 5.)*.5+.5\n    , t * sin(iTime * .1275)*.5+.5 * sin(iTime * 10.)*.5+.5\n    ,1.);\n    \n    \n         \n         \n\t//lit face\n\tcol += vec4(smoothstep(.99,.991,uvid.x));\n    \n    \n\t//shading\n\tcol += vec4(smoothstep(-1.,-1.,uvid.x)) * .4;\n\n \t \n \t //hexagons shrinking and expanding, wave form\n \t col *= vec4(smoothstep(.000001,.00001\n \t \t,uvid.y \n        \n        #ifdef Grass_Like\n \t \t* uvid.x\n        #endif\n        * sin(( length(uvid.zw))\n \t \t * iTime *.01)*.5+.5));\n         \n \t \n\tfragColor = vec4( col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2Szw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[357, 357, 384, 384, 459], [463, 463, 486, 486, 701], [703, 703, 728, 728, 1048]], "test": "untested"}
{"id": "Nl2SRw", "name": "SCI-Fi Tokyo Navi Demo", "author": "yasuo", "description": "FUXX TOKYO SHXX\nOnly the win/mac can see this demo.\nIt seems not working on ubuntu.", "tags": ["scifi", "tokyo"], "likes": 21, "viewed": 527, "published": 3, "date": "1627323655", "time_retrieved": "2024-07-30T19:09:12.889506", "image_code": "// raymarching based on: https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .0001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define Slice(p,a) dot(p,vec2(sin(a),cos(a)))\n#define SliceB(p,a,b,s) max(-dot(p-a,vec2(cos(b),sin(b))),max(abs(p).x-s,abs(p).y-s))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define Tri(p,s,a) max(-dot(p,vec2(cos(-a),sin(-a))),max(dot(p,vec2(cos(a),sin(a))),max(abs(p).x-s.x,abs(p).y-s.y)))\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\n#define MATERIAL_TOWER0 0\n#define MATERIAL_BUILDINGS 1\n#define MATERIAL_FLOOR 2\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(234.56,789.34));\n    p+=dot(p,p+34.56);\n    return fract(p.x+p.y);\n}\n\nvec2 combine(vec2 val1, vec2 val2){\n    vec2 res1 = val1;\n    vec2 res2 = val2;\n    return (val1.x < val2.x)?res1:res2;\n}\n\n// https://iquilezles.org/articles/distfunctions\nvec3 repLim( in vec3 p, in float c, in vec3 l)\n{\n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    q.y = p.y;\n    return q;\n}\n\n// https://www.shadertoy.com/view/wdjSDG\nfloat BevelMax( float a, float b, float bevelSize )\n{\n    return max(max(a,b), dot(vec2(a,b),normalize(vec2(.5,1))) + bevelSize );\n}\n\n// 2D\nfloat customTri(vec2 p, vec2 a, vec2 b, vec2 c){\n    float s = 1.0;\n    float d = max(SliceB(p,b,-atan(b.x-a.x,b.y-a.y),s),SliceB(p,b,-atan(c.x-b.x,c.y-b.y),s));\n    return max(SliceB(p,c,-atan(a.x-c.x,a.y-c.y),s),d);\n}\n\nfloat dTri(vec2 p, vec2 s){\n    p*=-1.0;\n    return Tri(p,s,radians(30.0));\n}\n\n// 3D\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// 3D taper box\nfloat dTaperBox(vec3 p, vec3 b, float angle, float bottomDist) {\n    vec3 prevP = p;\n    float d = sdBox(p,b);\n    float a = radians(angle);\n    p.x = abs(p.x);\n    p.x-=bottomDist;    \n    d = max(Slice(p.xy,a),d);\n\n    p = prevP;\n    a = radians(angle);\n    p.z = abs(p.z);\n    p.z-=bottomDist;\n    d = max(Slice(p.zy,a),d);\n\n    return d;\n}\n\nfloat dWire(vec3 p){\n    float r = 0.02;\n    float size = 0.15;\n    p.xy = mod(p.xy,size*2.0)-size;\n    float d = sdCapsule(p,vec3(size,size,0.0),vec3(-size,-size,0.0),r);\n    float d2 = sdCapsule(p,vec3(size,-size,0.0),vec3(-size,size,0.0),r);\n    d = min(d,d2);\n    d2 = sdCapsule(p,vec3(0.0,size,0.0),vec3(0.0,-size,0.0),r);\n    d = min(d,d2);\n    return d;\n}\n\nfloat dTowerTaper(vec3 p, vec3 size, float angle, float bottomDist){\n    float d = dWire(p);\n    d = max(dTaperBox(p,size,angle,bottomDist),d);\n    return d;\n}\n\nfloat dTower(vec3 p){\n    vec3 size = vec3(0.82,3.,0.1);\n    float angle = 86.0;\n    float bottomDist = 0.57;\n    \n    float deg = 4.0;\n    float dist = 0.57;\n    vec3 prevP = p;\n    \n    p.z = abs(p.z);\n    p.z -= dist;\n    float d = dTowerTaper(p*matRotateX(radians(deg)),size,angle,bottomDist);\n    \n    p = prevP;\n    p.x = abs(p.x);\n    p.x -= dist;\n    float d2 = dTowerTaper(p*matRotateY(radians(-90.0))*matRotateX(radians(-deg)),size,angle,bottomDist);\n    d = min(d,d2);    \n\n    return d;\n}\n\nfloat dTowerBottom(vec3 p){\n    vec3 size = vec3(3.0,1.15,0.1);\n    float angle = 58.0;\n    float bottomDist = 1.5;\n    \n    float deg = 39.5;\n    float dist = 1.5;\n    vec3 prevP = p;\n    \n    p.z = abs(p.z);\n    p.z-=dist;\n    float d = dTowerTaper(p*matRotateX(radians(deg)),size,angle,bottomDist);\n    p.x*=0.65;\n    d = max(-(length(p+vec3(0.0,0.85,-0.5))-1.0),d);\n    \n    p = prevP;\n    p.x = abs(p.x);\n    p.x-=dist;\n    float d2 = dTowerTaper(p*matRotateY(radians(-90.0))*matRotateX(radians(-deg)),size,angle,bottomDist);\n    p.z*=0.65;\n    d = min(d,max(-(length(p+vec3(-0.5,0.85,0.0))-1.0),d2));\n    \n    return d;\n}\n\nfloat dTowerLegs(vec3 p){\n    p.xz = abs(p.xz);\n    p.xz-=1.9;\n    float d = sdBox(p,vec3(0.5,0.15,0.5));\n    return d;\n}\n\nfloat dTowerBuilding(vec3 p){\n    vec3 prevP = p;\n    vec3 size = vec3(1.0,0.3,1.0);\n    float angle = 75.0;\n    float bottomDist = 0.99;\n    p.y*=-1.0;\n    float d = dTaperBox(p,size,angle,bottomDist);\n    float maskD = sdBox(p*matRotateY(radians(45.0)),vec3(1.2,0.4,1.2));\n    d = max(maskD,d);\n    \n    p = prevP;\n    p*=1.1;\n    p = mod(p,0.3)-0.15;\n   \n    float d2 = sdBox(p,vec3(0.1,0.12,0.1));\n    d = max(-d2,d);\n    \n    return d;\n}\n\nfloat dTowerTop(vec3 p){\n    vec3 size = vec3(0.4,0.2,0.4);\n    float angle = 75.0;\n    float bottomDist = 0.38;\n    float d = dTaperBox(p,size,angle,bottomDist);\n    size = vec3(0.3,0.3,0.3);\n    angle = 80.0;\n    bottomDist = 0.25;\n    float d2 = dTaperBox(p+vec3(0.0,-0.3,0.0),size,angle,bottomDist);\n    d = min(d,d2);\n    size = vec3(0.1,0.8,0.1);\n    angle = 85.0;\n    bottomDist = 0.09;\n    d2 = dTaperBox(p+vec3(0.0,-1.0,0.0),size,angle,bottomDist);\n    d = min(d,d2);\n    return d;\n}\n\nfloat dTokyoTower(vec3 p){\n    float d = dTower(p+vec3(0.0,-0.085,0.0));\n    float d2 = dTowerBottom(p+vec3(0.0,3.8,0.0));\n    d = min(d,d2);\n    d2 = dTowerLegs(p+vec3(0.0,4.8,0.0));\n    d = min(d,d2);\n    d2 = dTowerBuilding(p+vec3(0.0,1.2,0.0));\n    d = min(d,d2);\n    d2 = dTowerTop(p+vec3(0.0,-3.2,0.0));\n    d = min(d,d2);\n    return d;\n}\n\nfloat dBuilding(vec3 p, int type){\n    float additionalH = 0.0;\n    if(type == 2){\n        additionalH = 3.0;\n    }\n    \n    float d = sdBox(p,vec3(2.0,1.5+additionalH,1.5));\n    float d2 = sdBox(p+vec3(0.0,-1.8,0.0),vec3(1.8,0.8,0.8));\n    d = BevelMax(d,sdBox(p,vec3(2.5,2.8+additionalH,1.8)),0.9);\n    \n    if(type == 1){\n        d2 = sdBox(p+vec3(0.0,-1.5,3.5),vec3(1.3,4.0,1.3));\n        d2 = BevelMax(d2,sdBox((p+vec3(0.0,-1.5,3.5)),vec3(3.5,4.6,2.5)),1.6);\n        d = min(d,d2);\n    }\n    return d;\n}\n\nfloat dBuildings(vec3 p){\n    vec3 prevP = p;\n    \n    p.xz*=Rot(radians(30.0));\n    p = repLim(p,15.0,vec3(1.0,1.0,1.0));\n    float d = dBuilding(p+vec3(0.0,4.0,0.0),1);\n    \n    p = prevP;\n    d = max(-sdBox(p+vec3(0.0,4.0,0.0),vec3(4.5,5.0,4.5)),d);\n    \n    p = prevP;\n    p.xz*=Rot(radians(-120.0));\n    p = repLim(p,20.0,vec3(1.0,1.0,1.0));\n    float d2 = dBuilding(p+vec3(0.0,4.0,0.0),2);\n    \n    p = prevP;\n    d2 = max(-sdBox(p+vec3(0.0,4.0,0.0),vec3(4.5,5.0,4.5)),d2);\n    \n    d = min(d,d2);\n    return d;\n}\n\nvec2 GetDist(vec3 p) { \n    vec3 prevP = p;\n\n    float d = dTokyoTower(p);\n    vec2 res = vec2(d, MATERIAL_TOWER0);\n       \n    d = dBuildings(p);   \n    vec2 res2 = vec2(d*0.5, MATERIAL_BUILDINGS);\n    \n    d = p.y+4.9;\n    d = max(sdBox(p+vec3(0.0,4.9,0.0),vec3(40.0,0.1,40.0)),d);\n    vec2 res3 = vec2(d, MATERIAL_FLOOR);\n    \n    vec2 model = combine(res,combine(res2,res3));\n    return model;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side) {\n    vec2 dO = vec2(0.0);\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n   \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n   \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n   \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 col) {\n    float dif = dot(n,normalize(vec3(1,2,3)))*0.5+0.5;\n    return vec3(dif)*col;\n}\n\nvec3 floorTex(vec3 p){\n    vec2 uv = p.xz;\n    vec2 prevUV = uv;\n    \n    vec3 col = vec3(0.0);\n    \n    uv*=0.2;\n    \n    vec2 gv = fract(uv)-0.5;\n    vec2 id = floor(uv);\n    \n    float n = Hash21(id);\n    \n    float d = B(gv+vec2(0.5,0.0),vec2(0.04,0.5));\n    float d2 = B(gv+vec2(0.0,0.5),vec2(0.5,0.04));\n    \n    if(n>.2 && n<.4) {\n        d = min(d,d2);\n        gv.y+=iTime*0.7;\n        gv.y=mod(gv.y,0.4)-0.2;\n        float d3 = B(gv+vec2(0.43,0.0),vec2(0.01,0.02));\n        d = min(d,d3);\n    } else if(n>=.7 && n<.9) {\n        d = d2;\n        gv.x+=iTime*0.7;\n        gv.x=mod(gv.x,0.4)-0.2;\n        float d3 = B(gv+vec2(0.0,0.43),vec2(0.02,0.01));\n        d = min(d,d3);\n    }\n    \n    col = mix(col,vec3(0.8),S(d,0.0));\n    \n    return col;\n}\n\nvec3 stripeTex(vec2 uv, float size)\n{\n    float stripeSize = size;\n    float t = 0.0;\n    return vec3(tan((uv.x+uv.y+(-t/stripeSize))*stripeSize)*stripeSize,tan((uv.x+uv.y+(-t/stripeSize))*stripeSize)*stripeSize,tan((uv.x+uv.y+(-t/stripeSize))*stripeSize)*stripeSize);\n}\n\nvec3 bg(vec2 p, vec3 col){\n    p.x+=iTime*0.5;\n    p = mod(p,0.3)-0.15;\n    float d = B(p,vec2(0.001,0.015));\n    d = min(B(p,vec2(0.015,0.0015)),d);\n    col = mix(col,vec3(0.3),S(d,0.0));\n    \n    return col;\n}\n\n// distance 2d digital alarm font\nconst float cDefault[7] = float[](0.,0.,0.,0.,0.,0.,0.);\nconst float c1[7] = float[](10.,0.,0.,10.,10.,10.,10.);\nconst float c2[7] = float[](0.,0.,10.,0.,0.,10.,0.);\nconst float c3[7] = float[](0.,0.,0.,0.,10.,10.,0.);\nconst float c4[7] = float[](10.,0.,0.,10.,10.,0.,0.);\nconst float c5[7] = float[](0.,10.,0.,0.,10.,0.,0.);\nconst float c6[7] = float[](0.,10.,0.,0.,0.,0.,0.);\nconst float c7[7] = float[](0.,0.,0.,10.,10.,10.,10.);\nconst float c8[7] = float[](0.,0.,0.,0.,0.,0.,0.);\nconst float c9[7] = float[](0.,0.,0.,0.,10.,0.,0.);\nconst float c0[7] = float[](0.,0.,0.,0.,0.,0.,10.);\nconst float cTBase[7] = float[](0.,10.,10.,10.,10.,10.,10.);\nconst float cKBase[7] = float[](10.,10.,0.,10.,0.,0.,0.);\nconst float cYBase[7] = float[](10.,0.,0.,0.,10.,0.,0.);\n\nconst vec2 digitVPos = vec2(0.08,0.073);\nconst vec2 digitHPos = vec2(0.0,0.15);\n\nfloat dDigitV(vec2 p){\n    float d = B(p,vec2(0.02,0.1));\n    p = abs(p);\n    p-=vec2(0.02,0.05);\n    d = max(Slice(p,44.775),d);\n    return d;\n}\n\nfloat dDigitH(vec2 p){\n    p*=Rot(radians(90.0));\n    float d = dDigitV(p);\n    return d;\n}\n\nfloat dDigitBase(vec2 p, float[7] char){\n    vec2 prevP = p;\n    float d = 10.0;\n    float d2 = 10.0;\n    // 1\n    d = (char[0])+dDigitH(p-digitHPos);\n    // 2\n    d2 = (char[1])+dDigitV(p-digitVPos);\n    d = min(d,d2);\n    // 3\n    d2 = (char[2])+dDigitV(p+vec2(-digitVPos.x,digitVPos.y));\n    d = min(d,d2);\n    // 4\n    d2 = (char[3])+dDigitH(p+digitHPos);\n    d = min(d,d2);\n    // 5\n    d2 = (char[4])+dDigitV(p+digitVPos);\n    d = min(d,d2);\n    // 6\n    d2 = (char[5])+dDigitV(p+vec2(digitVPos.x,-digitVPos.y));\n    d = min(d,d2);\n    // 7\n    d2 = (char[6])+dDigitH(p);\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat dDot(vec2 p){\n    p.y = abs(p.y);\n    p.y-=0.073;\n    float d = B(p,vec2(0.02));\n    return d;\n}\n\nfloat dDigitT(vec2 p){\n    vec2 prevP = p;\n    p.x*=0.7;\n    float d = dDigitBase(p,cTBase);\n    p = prevP;\n    p.y+=0.02;\n    p.y = abs(p.y);\n    p.y-= digitVPos.y;\n    \n    float d2 = dDigitV(p);\n    return min(d,d2);\n}\n\nfloat dDigitK(vec2 p){\n    vec2 prevP = p;\n    float d = dDigitBase(p,cKBase);\n    p = prevP;\n    \n    p.x-=0.025;\n    p.y-=0.09;\n    p*=Rot(radians(52.0));\n    p.y*=0.74;\n    float d2 = dDigitV(p);\n    return min(d,d2);\n}\n\nfloat dDigitY(vec2 p){\n    float d = dDigitBase(p,cYBase);\n    return d;\n}\n\n// HUD\nvec3 drawDigitNumber(vec2 p, vec3 col, int num){\n    float d = dDigitBase(p,cDefault);\n    col = mix(col,vec3(0.2),S(d,0.0));\n    \n    if(num == 0){\n        d = dDigitBase(p,c0);\n    } else if(num == 1){\n        d = dDigitBase(p,c1);\n    } else if(num == 2){\n        d = dDigitBase(p,c2);\n    } else if(num == 3){\n        d = dDigitBase(p,c3);\n    } else if(num == 4){\n        d = dDigitBase(p,c4);\n    } else if(num == 5){\n        d = dDigitBase(p,c5);\n    } else if(num == 6){\n        d = dDigitBase(p,c6);\n    } else if(num == 7){\n        d = dDigitBase(p,c7);\n    } else if(num == 8){\n        d = dDigitBase(p,c8);\n    } else if(num == 9){\n        d = dDigitBase(p,c9);\n    }\n    \n    col = mix(col,vec3(1.0),S(d,0.0));\n    return col;\n}\n\nvec3 drawDigitTypo(vec2 p, vec3 col, int num){\n    float d = dDigitBase(p,cDefault);\n    col = mix(col,vec3(0.2),S(d,0.0));\n    \n    if(num == 0){\n        d = dDigitT(p);\n    } else if(num == 1){\n        d = dDigitK(p);\n    } else if(num == 2){\n        d = dDigitY(p);\n    } else if(num == 3){\n        d = dDigitBase(p,c0);\n    }\n    \n    col = mix(col,vec3(1.0),S(d,0.0));\n    return col;\n}\n\nvec3 drawNumbers(vec2 p, vec3 col){\n    float t = iTime;\n    float d = dDot(p+vec2(0.285,0.0));\n    col = mix(col,vec3(1.0),S(d,0.0));\n    d = dDot(p+vec2(-0.29,0.0));\n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    col = drawDigitNumber(p+vec2(0.7,0.0),col,0);\n    col = drawDigitNumber(p+vec2(0.45,0.0),col,0);\n    \n    col = drawDigitNumber(p+vec2(0.125,0.0),col,int(mod(t*0.5,10.0)));\n    col = drawDigitNumber(p+vec2(-0.125,0.0),col,int(mod(t,10.0)));\n    \n    col = drawDigitNumber(p+vec2(-0.45,0.0),col,int(mod(t*5.0,10.0)));\n    col = drawDigitNumber(p+vec2(-0.7,0.0),col,int(mod(t*20.0,10.0)));\n    return col;\n}\n\nvec3 drawTokyo(vec2 p, vec3 col){\n    col = drawDigitTypo(p+vec2(0.5,0.0),col,0);\n    col = drawDigitTypo(p+vec2(0.25,0.0),col,3);\n    col = drawDigitTypo(p,col,1);\n    col = drawDigitTypo(p+vec2(-0.25,0.0),col,2);\n    col = drawDigitTypo(p+vec2(-0.5,0.0),col,3);\n    return col;\n}\n\nvec3 drawHUDItem1(vec2 p, vec3 col){\n    vec2 prevP = p;\n    float d = customTri( p, vec2(-0.35,0.46), vec2(0.2,0.4), vec2(-0.1,-0.46) );\n    p*=Rot(radians(20.0));\n    d = max(-B(p,vec2(0.5,0.18)),abs(d)-0.0001);\n    col = mix(col,vec3(1.0),S(d,0.0));\n    p = prevP;\n    d = customTri( p, vec2(0.13,0.408), vec2(0.2,0.4), vec2(0.177,0.335) );\n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    float deg = 10.0;\n    float xPos = 0.05;\n    float yPos = -0.05;\n    \n    p*=Rot(radians(deg));\n    p.x += xPos;\n    p.y += yPos;\n    p.y -= iTime*0.05;\n    p.y = mod(p.y,0.02)-0.01;\n    d = B(p,vec2(0.01,0.001));\n    \n    p = prevP;\n    p*=Rot(radians(deg));\n    p.x += xPos;\n    p.y += yPos;\n    p.y = mod(p.y,0.1)-0.05;\n    float d2 = B(p,vec2(0.03,0.001));\n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot(radians(deg));\n    p.x += xPos;\n    p.y += yPos;\n    p.y+=0.05;\n    p.y = mod(p.y,0.1)-0.05;\n    d2 = B(p,vec2(0.02,0.001));\n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot(radians(deg));\n    p.x += xPos;\n    p.y += yPos;\n    d = max(B(p,vec2(0.1,0.33)),d);\n    \n    col = mix(col,vec3(1.0),S(d,-0.001));\n    \n    p = prevP;\n    p*=2.5;\n    p.x+=0.35;\n    p.y-=0.8;\n    p*=Rot(radians(deg));\n    col = drawDigitNumber(p+vec2(-0.12,0.0),col,0);\n    col = drawDigitNumber(p+vec2(0.12,0.0),col,0);\n    \n    p = prevP;\n    p*=17.0;\n    p.x-=iTime*2.0;\n    p.y+=0.3;\n    vec2 gv = fract(p)-0.5;\n    vec2 id = floor(p);\n    \n    float n = Hash21(id);\n    d = B(gv,vec2(0.25*(n*2.0),0.02));\n    p = prevP;\n    p+=vec2(-0.15,0.45);\n    col = mix(col,vec3(1.0),S(max(B(p,vec2(0.18,0.04)),d),0.0));\n    d = B(p+vec2(0.0,0.02),vec2(0.18,0.0008));\n    col = mix(col,vec3(1.0),S(d,0.0));    \n    \n    return col;\n}\n\nvec3 drawHUDItem2(vec2 p, vec3 col){\n    vec2 prevP = p;\n    float d = customTri( p, vec2(-0.4,0.4), vec2(0.4,0.4), vec2(0.0,-0.43) );\n    float maskD = customTri( p, vec2(-0.6,-0.35), vec2(0.0,1.2), vec2(0.6,-0.35) );\n    d = max(-maskD,abs(d)-0.0001);\n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    p.y -= 0.393;\n    p.x+=iTime*0.1;\n    p.x = mod(p.x,0.04)-0.02;\n    d = B(p,vec2(0.001,0.007));\n    \n    p = prevP;\n    p.y -= 0.39;\n    p.x = mod(p.x,0.1)-0.05;\n    float d2 = B(p,vec2(0.001,0.01));\n    d = min(d,d2);\n    \n    p = prevP;\n    p.y -= 0.4;\n    d = max(B(p,vec2(0.3,0.1)),d);\n    \n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    p = prevP;\n    p.y -= 0.41;\n    p.x-=iTime*0.05;\n    p.x = mod(p.x,0.15)-0.075;\n    d = dTri(p,vec2(0.015));\n    p = prevP;\n    p.y -= 0.4;\n    d = max(B(p,vec2(0.3,0.2)),d);\n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    p = prevP;\n    p.x = abs(p.x);\n    p.x -=0.35;\n    p.y -= 0.42;\n    d = dTri(p+vec2(-0.01,0.01),vec2(0.015));\n    p.y*=-1.0;\n    d2 = dTri(p+vec2(0.01,0.005),vec2(0.015));\n    col = mix(col,vec3(1.0),S(min(d,d2),0.0));\n    \n    p = prevP;\n    \n    p.y += 0.4;\n    p.x = abs(p.x);\n    p.x-=0.43;\n    p.y+=sin(-iTime*3.5)*0.01;\n    d = length(dTri((p),vec2(0.165)));\n    p.x-=sin(iTime*5.0)*0.01;\n    d2 = length(dTri((p)+vec2(-0.03,-0.02),vec2(0.17)));\n    col = mix(col,vec3(1.0),S(min(d,d2),0.0));\n    \n    return col;\n}\n\nvec3 drawHUDItem3(vec2 p, vec3 col){\n    vec2 prevP = p;\n    \n    p*=Rot(radians(-iTime*10.0));\n    p = DF(p,16.0);\n    p = abs(p);\n    p -= vec2(0.215);\n    p*=Rot(radians(45.0));\n    float d = B(p,vec2(0.001,0.005));\n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    p = prevP;\n    p*=Rot(radians(-iTime*10.0));\n    p = DF(p,4.0);\n    p = abs(p);\n    p -= vec2(0.21);\n    p*=Rot(radians(45.0));    \n    d = B(p,vec2(0.001,0.015));\n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    p = prevP;\n    p*=Rot(radians(iTime*20.0));\n    d = abs(length(p)-0.32)-0.005;\n    d = max(-B(p,vec2(1.0,0.15)),d);\n    col = mix(col,stripeTex(p,300.0),S(d,0.0));\n    \n    p = prevP;\n    p*=Rot(radians(-iTime*30.0));\n    d = abs(length(p)-0.22)-0.007;\n    d = max(-B(p+vec2(0.0,0.1),vec2(1.0,0.2)),d);\n    float d2 = abs(length(p)-0.225)-0.002;\n    col = mix(col,stripeTex(p,300.0),S(min(d,d2),0.0));\n    \n    p = prevP;\n    p*=Rot(radians(sin(iTime*1.0)*45.0));\n    p = DF(p,2.0);\n    p = abs(p);\n    p -= vec2(0.24);\n    p*=Rot(radians(45.0));   \n    d = dTri(p,vec2(0.015));\n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    p = prevP;\n    p.y+=1.17;\n    p*=Rot(radians(-iTime*10.0));\n    p = DF(p,32.0);\n    p = abs(p);\n    p -= vec2(0.5);\n    p*=Rot(radians(45.0)); \n    d = B(p,vec2(0.001,0.005));\n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    return col;\n}\n\nvec3 drawHUD(vec2 p, vec3 col){\n    vec2 prevP = p;\n    p.x = abs(p.x);\n    p.x -=0.625;\n    p.x*=-1.0;\n    col = drawHUDItem1(p,col);\n    p = prevP;\n    \n    col = drawHUDItem2(p,col);\n    col = drawHUDItem3(p,col);\n    \n    p*=4.0;\n    p.y-=1.3;\n    col = drawNumbers(p,col);\n    \n    p = prevP;\n    p*=4.0;\n    p.y+=1.15;\n    col = drawTokyo(p,col);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n   \n    float rz = -7.0;\n    float rotYZ = -10.0;\n    float rdY = -1.0;\n    #if USE_MOUSE != 1\n    float endFrame = 30.0;\n    float scene = mod(iTime,endFrame);\n    if(scene>10.0 && scene<20.0){\n        rz = -6.0;\n        rotYZ = -50.0;\n        rdY = -3.0;\n    } else if(scene>=20.0){\n        rdY = -3.0;\n        \n        float diff = endFrame-20.0;\n        float now = endFrame-scene;\n        rdY+=((diff-now)/diff)*2.0;\n    }\n    #endif\n    \n    vec3 ro = vec3(0, 0, rz);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(rotYZ));\n    ro.xz *= Rot(-iTime*.3+1.0);\n    #endif\n   \n    vec3 rd = R(uv, ro, vec3(0,rdY,0), 0.5);\n    vec2 d = RayMarch(ro, rd, 1.);\n    vec3 col = vec3(0.0);\n    col = bg(uv,col);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd,n);\n       \n        int mat = int(d.y);\n        if(mat == MATERIAL_TOWER0){\n            col = diffuseMaterial(n,vec3(1.0,0.0,0.0));\n        } else if(mat == MATERIAL_FLOOR) {\n            col = diffuseMaterial(n,floorTex(p));\n        } else if(mat == MATERIAL_BUILDINGS) {\n            col = diffuseMaterial(n,vec3(0.5));\n        }\n    }\n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );\n    \n    float dt = dot(uv, vec2(12.9898, 78.233));\n    float noise = fract(sin(dt) * 43758.5453 + iTime*10.0);\n    vec3 grain = vec3(noise) * (1.0 - col);\n    col+=grain*0.15;\n    \n    // HUD\n    col = drawHUD(uv,col);\n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2SRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1038, 1038, 1060, 1060, 1150], [1152, 1152, 1187, 1187, 1273], [1275, 1324, 1372, 1372, 1444], [1446, 1487, 1540, 1540, 1619], [1621, 1627, 1675, 1675, 1846], [1848, 1848, 1875, 1875, 1925], [1927, 1982, 2013, 2013, 2104], [2106, 2155, 2207, 2207, 2328], [2330, 2346, 2410, 2410, 2689], [2691, 2691, 2711, 2711, 3053], [3055, 3055, 3123, 3123, 3214], [3216, 3216, 3237, 3237, 3716], [3718, 3718, 3745, 3745, 4345], [4347, 4347, 4372, 4372, 4468], [4470, 4470, 4499, 4499, 4912], [4914, 4914, 4938, 4938, 5406], [5408, 5408, 5434, 5434, 5752], [5754, 5754, 5788, 5788, 6262], [6264, 6264, 6289, 6289, 6783], [6785, 6785, 6807, 6807, 7184], [7186, 7186, 7231, 7231, 7494], [7496, 7496, 7520, 7520, 7719], [7721, 7721, 7763, 7763, 7958], [7960, 7960, 8000, 8000, 8083], [8085, 8085, 8107, 8107, 8839], [8841, 8841, 8878, 8878, 9111], [9113, 9113, 9139, 9139, 9324], [10206, 10206, 10228, 10228, 10351], [10353, 10353, 10375, 10375, 10444], [11065, 11065, 11084, 11084, 11167], [11169, 11169, 11191, 11191, 11390], [11392, 11392, 11414, 11414, 11614], [11616, 11616, 11638, 11638, 11690], [11692, 11699, 11747, 11747, 12440], [12442, 12442, 12488, 12488, 12833], [12835, 12835, 12870, 12870, 13456], [13458, 13458, 13491, 13491, 13739], [13741, 13741, 13777, 13777, 15447], [15449, 15449, 15485, 15485, 16838], [16840, 16840, 16876, 16876, 18183], [18185, 18185, 18216, 18216, 18560], [18562, 18562, 18619, 18619, 20274]], "test": "untested"}
{"id": "ft2SRw", "name": "infinite cubes", "author": "calimops", "description": "cubes on loop", "tags": ["infiniteabberationrecursion"], "likes": 6, "viewed": 294, "published": 3, "date": "1627321763", "time_retrieved": "2024-07-30T19:09:13.702332", "image_code": "#define M_PI 3.1415926\n\n// SETTINGS\nconst float zFar = 50.;\nconst float zNear = 1.;\n\nconst vec3 background_color = vec3(0.7);\nconst float collision_distance = 0.001;\nconst int marching_iterations = 64;\n\nconst float normal_partial_derivative_epsilon = 0.00001;\n\n// COLORS\nconst vec3 red   = vec3(1., 0., 0.);\nconst vec3 green = vec3(0., 1., 0.);\nconst vec3 blue  = vec3(0.8);\n\nfloat sq(in float n) {\n    return n * n;\n}\n\n// Transformations\nmat4 worldMatrix = mat4(1., 0., 0., 0.,   0., 1., 0., 0.,   0., 0., 1., 0.,   0., 0., 0., 1.);\n\nvoid identity() {\n    worldMatrix = mat4(1., 0., 0., 0.,   0., 1., 0., 0.,   0., 0., 1., 0.,   0., 0., 0., 1.);\n}\n\nvoid scale(in float a, in float b, in float c) {\n    worldMatrix *= mat4(a , 0., 0., 0.,\n                        0., b , 0., 0.,\n                        0., 0., c , 0.,\n                        0., 0., 0., 1.);\n}\n\nvoid trans(in vec3 v) {\n    worldMatrix *= mat4(1., 0., 0., v.x,\n                        0., 1., 0., v.y,\n                        0., 0., 1., v.z,\n                        0., 0., 0., 1.);\n}\n\n\nconst float factor = 0.001;\n\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n//      p = vec3(p.x*cos(iTime*factor) - p.y*sin(iTime*factor), p.x*sin(iTime*factor) + p.y*cos(iTime*factor), p.z);\n      p = abs(p)-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nvec4 scene(vec3 pos) {\n    pos = (vec4(pos, 1.) * worldMatrix).xyz;\n    pos = mod(pos, 10.)-5.0;\n    return vec4(blue, sdBoundingBox(pos, vec3(3.0), 0.3)); \n}\n\nvec3 calcNormal( in vec3 p ) {\n    const float h = 0.001;\n    const vec2 k = vec2(1, -1);\n    return normalize( k.xyy * scene( p + k.xyy * h ).a + \n                      k.yyx * scene( p + k.yyx * h ).a + \n                      k.yxy * scene( p + k.yxy * h ).a + \n                      k.xxx * scene( p + k.xxx * h ).a );\n}\n\nvec4 ray_marching(vec3 pos, vec3 dir) {\n    dir = normalize(dir);\n    float len = 0.;\n    float mindist;\n    vec3 color;\n    vec3 norm;\n\n    for (int i = 0; i < marching_iterations; ++i) {\n    \n//        pos = vec3(pos.x*cos(len*factor) - pos.y*sin(len*factor), pos.x*sin(len*factor) + pos.y*cos(len*factor), pos.z);\n\n        vec4 tmp = scene(pos);\n        \n        color = tmp.rgb;\n        mindist = tmp.a;\n        norm = calcNormal(pos);\n        len += mindist;\n        \n        //pos = vec3(pos.x*cos(len*factor) - pos.y*sin(len*factor), pos.x*sin(len*factor) + pos.y*cos(len*factor), pos.z);\n\n        if (mindist < collision_distance) \n        {\n            return vec4(color * max(0.4, dot(normalize(vec3(0.) - pos), norm)), len);\n        }\n        \n        if (len > zFar) \n        {\n            return vec4(background_color, len);\n        }\n\n        //len += mindist;\n        pos += dir * mindist;\n    }\n    return vec4(background_color, len);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / vec2(min(iResolution.x, iResolution.y));\n    uv -= (iResolution.xy / min(iResolution.x, iResolution.y) - vec2(1.)) / 2.;\n    //uv.y = 1. - uv.y;\n    \n    float aberrationAmount = 0.1;\n    vec2 distFromCenter = uv - 0.5;\n    \n    vec2 aberrated = aberrationAmount * pow(distFromCenter, vec2(3.0, 3.0));\n    \n\n    identity();\n    trans(vec3(5, 5, 10.*iTime));\n    //rotx(iTime/10.0 + 2.);\n    //rotz(iTime/10.0 + 2.);\n    //roty(iTime/10.0 + 2.);\n    \n    vec4 rayMar1 = ray_marching(vec3(0.), vec3(uv - vec2(0.5)-aberrated, zNear));\n    vec4 rayMar2 = ray_marching(vec3(0.), vec3(uv - vec2(0.5), zNear));\n    vec4 rayMar3 = ray_marching(vec3(0.), vec3(uv - vec2(0.5)+aberrated, zNear));\n    \n    vec3 color = (exp(-0.06 * rayMar2.a)) * vec3(rayMar1.r, rayMar2.g, rayMar3.b);\n\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft2SRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[376, 376, 398, 398, 418], [535, 535, 552, 552, 648], [650, 650, 698, 698, 861], [863, 863, 886, 886, 1052], [1084, 1084, 1132, 1249, 1541], [1543, 1543, 1565, 1565, 1701], [1703, 1703, 1733, 1733, 2026], [2028, 2028, 2067, 2067, 2980], [2982, 2982, 3039, 3039, 3878]], "test": "untested"}
{"id": "ftSSzw", "name": "Reflective Bobbing Floaty Effect", "author": "intrakits", "description": "Trying to make a cool looking water effect. I also wanted to play around more with reflections.", "tags": ["reflection", "waves", "water", "float"], "likes": 5, "viewed": 295, "published": 3, "date": "1627321747", "time_retrieved": "2024-07-30T19:09:14.469282", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST 0.01\n#define AA 1\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nvec2 rand2(vec2 p)\n{\n\tvec2 q = vec2(dot(p,vec2(127.1,311.7)), \n\t\tdot(p,vec2(269.5,183.3)));\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat rand(vec2 p)\n{\n\treturn fract(sin(dot(p,vec2(419.2,371.9))) * 833458.57832);\n}\n\nfloat iqnoise(in vec2 pos, float irregular, float smoothness)\n{\n\tvec2 cell = floor(pos);\n\tvec2 cellOffset = fract(pos);\n\n\tfloat sharpness = 1.0 + 63.0 * pow(1.0-smoothness, 4.0);\n\t\n\tfloat value = 0.0;\n\tfloat accum = 0.0;\n\t// Sample the surrounding cells, from -2 to +2\n\t// This is necessary for the smoothing as well as the irregular grid.\n\tfor(int x=-2; x<=2; x++ )\n\tfor(int y=-2; y<=2; y++ )\n\t{\n\t\tvec2 samplePos = vec2(float(y), float(x));\n\n  \t\t// Center of the cell is not at the center of the block for irregular noise.\n  \t\t// Note that all the coordinates are in \"block\"-space, 0 is the current block, 1 is one block further, etc\n\t\tvec2 center = rand2(cell + samplePos) * irregular;\n\t\tfloat centerDistance = length(samplePos - cellOffset + center);\n\n\t\t// High sharpness = Only extreme values = Hard borders = 64\n\t\t// Low sharpness = No extreme values = Soft borders = 1\n\t\tfloat sam = pow(1.0 - smoothstep(0.0, 1.414, centerDistance), sharpness);\n\n\t\t// A different \"color\" (shade of gray) for each cell\n\t\tfloat color = rand(cell + samplePos);\n\t\tvalue += color * sam;\n\t\taccum += sam;\n\t}\n\n\treturn value/accum;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    //line from a to b\n    vec3 ab = b-a;\n    \n    // line from p to a\n    vec3 ap = p-a;\n    \n    // as p approaches a, it will be 1\n    // as p approaches b it will b 0\n    float t = dot(ab,ap) / dot(ab,ab);\n    \n    // clamp values between 0 and 1\n    t= clamp(t,0.,1.);\n    \n    // center point of the capsule\n    // start at a (top of capsule)\n    // go towards b, t steps\n    vec3 c = a + t*ab;\n    \n    float d = length(p-c)-r;\n    \n    return d;\n}\n\nfloat sdTorus(vec3 p, vec2 r){\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.));\n}\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n  p = abs(p);\n  vec2 b = vec2(la,lb);\n  float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n  vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\nvec2 colMin(vec2 res, vec2 obj){\n    res.x = min(obj.x,res.x);\n    if(obj.x == res.x){\n        res.y = obj.y;\n    }\n    return res;\n}\n// https://iquilezles.org/articles/smin\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\nfloat getDisp(vec2 uv){\n\n    vec2 p = 0.5 - 0.5*sin(vec2(1.01,1.71) );\n    p = vec2(1.0, 1.0);\n\t\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\t\n\tfloat f = iqnoise(24.0*uv, p.x, p.y);\n\t\n\treturn f;\n}\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\nvec2 GetDist(vec3 p){\n    float off =sin(5.*iTime+p.x)*.1+sin(3.*iTime+p.z)*.1;\n    off*=sin(iTime+p.x*2.);\n    off+=sin(7.*iTime+(length(p)-.4)*7.*smoothstep(7.,1.,length(p)-.4))*.01;\n    vec2 res = vec2(p.y+off,1.);\n    off = pow(sin(iTime*2.),2.)*.5+1.;\n    vec2 base = vec2(sdCapsule(p-vec3(0,-smoothstep(off-.5,off,p.y),0), vec3(0.), vec3(0,off,0), .8),2.);\n    \n    \n    res = colMin(res, base);\n    vec2 cone = vec2(sdCapsule(p-vec3(0,1.3-smoothstep(off,off+.8,p.y),0), vec3(0,-1,0), vec3(0,off,0), .5-(p.y-off)*.2),3.);\n    res = colMin(res, cone);\n    \n    vec2 washer = vec2(sdTorus(p-vec3(0,off-.2,0), vec2(.5,.1)),4.);\n    res = colMin(res, washer);\n    \n    vec2 screw = vec2(sdCylinder(p-vec3(.55,off-.3,0), vec3(0,.3,0), vec3(0,0,0), .05-pow(sin((off-p.y)*100.),2.)*.02),4.);\n    \n    res = colMin(res, screw);\n    vec2 screw2 = vec2(sdCylinder(p-vec3(.23,off-.3,.5), vec3(0,.3,0), vec3(0,0,0), .05-pow(sin((off-p.y)*100.),2.)*.02),4.);\n    \n    res = colMin(res, screw2);\n    p.xz *=Rot(iTime);\n    vec2 lightBase = vec2(dBox(p-vec3(0,off+.8,0), vec3(.2,.2,.2)),5.);\n    vec2 lightBaseM = vec2(dBox(p-vec3(0,off+.8,0), vec3(.5,.1,.1)),5.);\n    vec2 lightBaseM2 = vec2(dBox(p-vec3(0,off+.8,0), vec3(.1,.1,.5)),5.);\n    lightBase.x = min(lightBase.x,lightBaseM.x);\n    lightBase.x = min(lightBase.x,lightBaseM2.x);\n   \n    res = colMin(res, lightBase);\n    \n    vec2 light = vec2(sdCapsule(p-vec3(0,off+1.,0), vec3(0,0,0), vec3(0,.3,0), .05+(p.y-off)*.2),6.);\n    res = colMin(res, light);\n    //res = light;\n    return res;\n}\nvec2 RayMarch(vec3 ro, vec3 rd){\n    // distance from origin\n    vec2 dO=vec2(0.,0.);\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO.x*rd;\n        \n        // get distance to seam\n        vec2 ds = GetDist(p);\n        //move origin to new point\n        dO+=ds.x*.4;\n        if(ds.x < SURFACE_DIST){\n            dO.y = ds.y;\n            break;\n        }\n        else if( dO.x > MAX_DIST){\n            dO.y= -1.;\n            break;\n        }\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    //distance to point being analyzed\n    float d = GetDist(p).x;\n    \n    //distance to another point along the objects surface that is closeby\n    vec2 e = vec2(0.01,0);\n    \n    //slope between the two points\n    //note: swizzel is the .xxy or .yyx etc\n    vec3 n = d - vec3(\n         GetDist(p-e.xyy).x,\n         GetDist(p-e.yxy).x,\n         GetDist(p-e.yyx).x);\n         \n    return normalize(n);\n    \n}\nfloat GetLight(vec3 p){\n    //position of the light source\n    vec3 lightPos = vec3(4,5.,10);\n    \n    lightPos.xz += vec2(sin(iTime),cos(iTime));\n    //light vector\n    vec3 l = normalize(lightPos-p);\n    \n    //normal of object\n    vec3 n = GetNormal(p);\n    \n    // dot product of the light vector and normal of the point\n    // will give us the amount of lighting to apply to the point\n    // dot() evaluates to values between -1 and 1, so we will clamp it\n    float diff = clamp(dot(n, l),0.,1.);\n    \n    // calculate if point should be a shadow:\n    // raymarch from point being calculated towards light source\n    // if hits surface of something else before the light,\n    // then it must be obstructed and thus is a shadow\n    // the slight offset \"p+n*SURFACE_DIST*1.1\" is needed to ensure the\n    // break condistions in the function are not met too early\n    float d = RayMarch(p+n*SURFACE_DIST*1.1,l).x;\n    if(d < length(lightPos-p)){\n        diff *= .1;\n    }\n    \n    return diff;\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nfloat DrawSquare (vec2 uv, float width, float height, float posX, float posY, float blur){\n    float w = length((uv.x + posX));\n    float h = length(uv.y + posY);\n    float col = smoothstep(width,width-blur, w);\n    col *= smoothstep(height,height-blur, h);\n    return col;\n}\nvec3 A (vec2 uv){\n    vec3 base =vec3(1)*DrawSquare (uv-vec2(0,0), .1-uv.y*.2, .2, 0., 0., .01);\n    vec3 mask =vec3(1)*DrawSquare (uv-vec2(0,.1), .05-uv.y*.2, .07, 0., 0., .01);\n    vec3 mask2 =vec3(1)*DrawSquare (uv-vec2(0,-.1), .05-uv.y*.2, .1, 0., 0., .01);\n    return base - mask - mask2;\n}\nvec3 X (vec2 uv){\n    vec3 slashR = vec3(1)*DrawSquare (uv-vec2(uv.y*.5,0), .04, .2, 0., 0., .01);\n    vec3 slashL = vec3(1)*DrawSquare (uv-vec2(-uv.y*.5,0), .04, .2, 0., 0., .01);\n    return slashR+slashL;\n}\nvec3 coneText(vec2 uv){\n    vec3 col = A(uv-vec2(-.3,0))+X(uv-vec2(0,0));\n    return col;\n}\nvec3 Render (inout vec3 ro, inout vec3 rd, inout float reflVal){\n//------------------\n    vec2 d = RayMarch(ro,rd);\n// position of point\n    // start at ray origin\n    // move d units in the ray direction\n    vec3 p = ro + rd *d.x;\n //get diffuse lighting\n    float diff = GetLight(p);\n    vec3 col = vec3(0);\n    col = vec3(diff);\n    \n    vec3 n = GetNormal(p);\n    vec3 r = reflect(rd, n);\n    vec3 refl = texture(iChannel0, r).rgb;\n    refl= refl*abs(n.y) + refl*abs(n.z) + refl*abs(n.x);\n    \n    if(d.y == 1.){\n        col *= vec3(0,.7,1);\n        col*=refl;\n        reflVal = .9;\n    }\n    else if(d.y==2.){\n       col *= vec3(1,0,0);\n       reflVal = 0.1;\n    }\n    else if(d.y==3.){\n        float off = pow(sin(iTime*2.),2.)*.5+1.;\n        vec2 uv = vec2(atan(p.x,p.z)/(3.14159),p.y-off);\n        uv.x-=.4;\n        uv.y-=.3;\n        col*=vec3(1,0,0);\n        col-= coneText(uv).rgb;\n        reflVal = 0.1;\n    }\n    else if(d.y==4.){\n      col*=vec3(1.);\n      reflVal=0.9;\n    }\n    else if(d.y==5.){\n      col*=vec3(1.);\n      reflVal=0.9;\n    }\n    else if(d.y==6.){\n      col=vec3(1.,1,0);\n      col.xy*=sin(iTime*3.)*.5+.5;\n      reflVal=0.9;\n    }\n    else{\n        col=texture(iChannel0, rd).rgb*.3;\n    }\n     ro = p+n*SURFACE_DIST*3.;\n     rd=r;\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n   \n    \n    //camera\n    //-----------------\n    // ray origin\n    //controls position\n    vec3 ta = vec3( 0, 0., -3);\n    vec3 ro = ta + vec3( 4.5, 4.3, 4.5);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n//    vec3 ro = vec3(0,3,-5);\n\n    \n    //ray dir\n    //controls rotation\n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 pt = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 pt = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n    vec3 rd = ca * normalize( vec3(pt,2.5) );\n    \n    \n    \n    float reflVal = 1.;\n    vec3 col = Render(ro,rd,reflVal);\n    vec3 bounce = reflVal*Render(ro,rd,reflVal);\n    col += bounce;\n    /*vec3 bounce2 = reflVal*Render(ro,rd,reflVal);\n    col += bounce2;*/\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftSSzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 112, 112, 140], [142, 142, 162, 162, 269], [271, 271, 291, 291, 354], [356, 356, 419, 419, 1469], [1471, 1471, 1490, 1490, 1552], [1553, 1553, 1604, 1604, 1888], [1890, 1890, 1939, 1962, 2395], [2397, 2397, 2427, 2427, 2498], [2500, 2500, 2527, 2527, 2566], [2567, 2567, 2631, 2631, 2882], [2883, 2883, 2915, 2915, 3016], [3017, 3057, 3095, 3095, 3192], [3194, 3234, 3275, 3275, 3347], [3348, 3348, 3406, 3406, 3507], [3508, 3508, 3531, 3531, 3726], [3727, 3727, 3774, 3774, 3807], [3808, 3808, 3829, 3829, 5348], [5349, 5349, 5381, 5409, 5922], [5923, 5923, 5946, 5985, 6356], [6357, 6357, 6380, 6415, 7355], [7356, 7356, 7408, 7408, 7585], [7586, 7586, 7676, 7676, 7861], [7862, 7862, 7879, 7879, 8157], [8158, 8158, 8175, 8175, 8366], [8367, 8367, 8390, 8390, 8458], [8459, 8459, 8523, 8544, 9740]], "test": "untested"}
{"id": "7tBSRm", "name": "Fractals practice v01", "author": "Endrju", "description": "Fracts", "tags": ["fracts"], "likes": 0, "viewed": 116, "published": 3, "date": "1627308512", "time_retrieved": "2024-07-30T19:09:15.242215", "image_code": "#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nvec3 ColsVecBase = vec3(.65, 0.61, .48);\nvec3 ColsContrast = vec3(-.9, .3, -.8);\n\nfloat velocity = 0.1;\nfloat RotVal = 25.;\nfloat Close_Up = .25;\nfloat CosBaseStructure = cos(.02);\nfloat SinBaseStructure = sin(.11);\nfloat StructuralMultiplier = 2.1;\nfloat BuildingBase = 1.22;\nfloat StructDiff = 0.37;\nfloat Noise = .005;\nfloat FractStructurization = 41.92;\nfloat ColChangeA = 13.;\nfloat ColChangeB = 16.;\nfloat Brightness = 1.35;\nfloat OverallColPower = .95;\nfloat ColComputingBase = 1.75;\nfloat SS_Begin = 0.;\nfloat SS_End = 12.;\nfloat ColStrength = .65;\nfloat DirX = 1.15;\nfloat DirY = 2.;\n\nint NumInterations = 26;\n\nbool UseSin = false;\n\nfloat CalcStructure(vec2 uv, vec2 bsv)\n{\n    float ColStep = 0.;\n    \n    for(int i = 0; i < NumInterations; i++)\n    {\n        uv *= BuildingBase;\n        uv = abs(uv);\n    \tuv -= StructDiff;\n    \tuv -= bsv * min(0., dot(uv, bsv)) * 2.;\n        uv.y += UseSin ? sin(uv.x * FractStructurization) * Noise : cos(uv.x * FractStructurization) * Noise;\n        \n        ColStep += dot(uv, uv);\n    }\n    \n    return ColStep;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float TimeStep = iTime * velocity;\n    \n    vec2 uv = vec2(fragCoord.xy - RotVal * iResolution.xy) / iResolution.y;\n    uv += vec2(TimeStep * DirX, TimeStep * DirY);\n    uv *= rot(RotVal);\n    uv = fract(uv * Close_Up) - .5;\n    uv = abs(uv);\n    \n    vec2 BasicStructureVec = vec2(CosBaseStructure, SinBaseStructure);\n    \n    float DotVal = dot(uv, BasicStructureVec);\n    \n    uv -= BasicStructureVec * max(0., DotVal) * StructuralMultiplier;\n    \n    float ColorStep = CalcStructure(uv, BasicStructureVec);\n    \n    vec3 Color = 1. - (.5 + ColStrength * cos(ColsVecBase *\n    (ColorStep * ColChangeA + DotVal * ColChangeB) + ColsContrast));\n    \n    Color *= max(smoothstep(SS_Begin, SS_End, abs(uv.y)), OverallColPower);\n    Color = pow(Color * Brightness, vec3(ColComputingBase));\n    \n    fragColor = vec4(1. - exp(-Color), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tBSRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[696, 696, 736, 736, 1117], [1119, 1119, 1174, 1174, 2016]], "test": "untested"}
{"id": "slBXzw", "name": "my first tesseract", "author": "xertrov", "description": "first glimpse of a tesseract. very experimental rendering method. click and drag to find a good angle. the fuzzier it is, the more of the shape is not well aligned along w. obvs there's a lot of room for improvement, but I'm pretty excited!", "tags": ["raymarching", "4d", "learning", "tesseract", "hypercube"], "likes": 4, "viewed": 334, "published": 3, "date": "1627305704", "time_retrieved": "2024-07-30T19:09:16.003180", "image_code": "#define u_resolution iResolution\n#define u_mouse iMouse\n#define u_time iTime\n#define gl_FragColor fragColor\n\n#define PI 3.141592653589\n#define TAU 6.28318530718\n\n#define S(a, b, t)smoothstep(a, b, t)\n\n#define BLACK vec3(0.0)\n#define WHITE vec3(1.0)\n\n#define GROW_SHRINK 0.3\n#define ROTATE_IDLE 0.2\n#define BASE_TWINKLE 99.0\n#define STAR_RARITY 0.95\n// set to 5k+ for a hyperspace bungee; curious noise patterns at 2000.\n#define BG_SCALE 100.0\n\n/* lib/util stuff */\n\nfloat N21b(vec2 p) {  // from an art of code video i think\n  vec3 a = fract(vec3(p.xyx) * vec3(213.897, 653.453, 253.098));\n  a += dot(a, a.yzx + 79.76);\n  return fract((a.x + a.y) * a.z);\n}\n\n\nfloat sdBox(in vec3 p, in vec3 b) {\n  vec3 d = abs(p) - b;\n  return length(max(d, 0.0)) + min(max(d.z, max(d.x, d.y)), 0.0);\n}\n\n\nvec2 best2(vec3 p) {\n  vec2 r = p.x > p.y ? vec2(p.x, p.y) : vec2(p.y, p.x);\n  if (p.z > r.x) { return vec2(p.z, r.x);}\n  if (p.z > r.y) { return vec2(r.x, p.z);}\n  return r;\n}\n\nfloat minOf(vec2 v) {\n  return min(v.x, v.y);\n}\nfloat minOf(vec3 v) {\n  return min(minOf(v.xy), v.z);\n}\nfloat minOf(vec4 v) {\n  return min(minOf(v.xyz), v.w);\n}\n\nvec2 sinCos(in vec2 ab) {\n  return vec2(sin(ab.x), cos(ab.y));\n}\n\n// roll from XY to XZ or YZ (0 no roll, 1=XZ, 2=YZ)\nmat3 rot3XY(float angle, int roll) {\n  float s = sin(angle), c = cos(angle);\n  mat3 r = mat3(c, - s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n  if (roll == 1) {\n    r = mat3(r[0].xzy, r[2].xzy, r[1].xzy);\n  } else if (roll == 2) {\n    r = mat3(r[2].zxy, r[0].zxy, r[1].zxy);\n  }\n  return r;\n}\n\n\n// warning, this is mostly untested -- written by me for this. fyi if you copy paste.\nmat4 rot4(float angle, int axis) {\n  float s = sin(angle), c = cos(angle);\n  mat4 r = mat4(\n    c, -s, 0, 0,\n    s, c, 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 1\n  );\n  // XY, XZ, XW\n  return axis == 0 ? r\n    : axis == 1 ? mat4(r[0].xzyw, r[2].xzyw, r[1].xzyw, r[3].xzyw)\n    : axis == 2 ? mat4(r[0].xwzy, r[3].xwzy, r[2].xwzy, r[1].xwzy)\n    // YZ, YW\n    : axis == 3 ? mat4(r[3].wxyz, r[0].wxyz, r[1].wxyz, r[2].wxyz)\n    : axis == 4 ? mat4(r[3].wxzy, r[0].wxzy, r[1].wxzy, r[2].wxzy)\n    // ZW\n    : axis == 5 ? mat4(r[3].wzxy, r[2].wzxy, r[0].wzxy, r[1].wzxy) : mat4(0.);\n}\n    /* Ahh! That bug isn't going to make sensible rotations. */\n    //axis == 5 ? mat4(r[2].wzxy, r[3].wzxy, r[1].wzxy, r[2].wzxy)\n\n\n\nvec3 best3(vec4 p) {\n  vec2 zw = vec2(max(p.z, p.w), min(p.z, p.w));\n  // p.z > p.w ? vec2(p.z, p.w) : vec2(p.w, p.z);\n  vec2 xy = vec2(max(p.x, p.y), min(p.x, p.y));\n  if (xy.y > zw.x) {return vec3(xy, zw.x);} // testme\n  if (zw.y > xy.x) {return vec3(zw, xy.x);}\n  return vec3(max(xy.x, zw.x), min(xy.x, zw.x), max(xy.y, zw.y));\n\n  /* tests\n  col = best2(zoth.xyz) == vec2(2., 1.) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.zywx) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.wxzy) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.wxyz) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.xywz) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  */\n}\n\nvec3 rainbow(vec2 uv, float time) {\n  return sin(vec3(time) + uv.xyx * vec3(1.0, 1.0, 1.0) + vec3(0, 2, 4)) * 0.49 + 0.5;\n}\n\n\nfloat sdBoxEdge(in vec3 p, in vec3 b) {\n  return length(best2(abs(p) - b));\n}\n\n// purely a guess based on the one for a cube\nfloat sdTesseractEdge(in vec4 p, in vec4 b) {\n  vec4 d = abs(p) - b;\n  //d.w /= 5.;\n  vec3 db = best3(d);\n  return length(db);\n}\n\nvec4 getIDGV(vec2 uv, float scale) {\n  vec2 id = floor(uv * scale);\n  vec2 gv = fract(uv * scale) - 0.5;\n  return vec4(id, gv);\n}\n\nfloat mkNoise(vec2 uv, float t, float minDS) {\n  float scale = fwidth(uv.x) * 100.0 * BG_SCALE;\n  vec4 idgv = getIDGV(uv, scale);\n  vec2 id = idgv.xy;\n  vec2 gv = idgv.zw;\n  float n = N21b(id);\n  float transFreq = BASE_TWINKLE * n + 0.01;\n  t -= 3877.627 * n;\n  float transProgress = fract(t * transFreq);\n  float transId = floor(t * transFreq);\n  float lastIdOffset = N21b(vec2(n, transId - 1.0));\n  float idOffset = N21b(vec2(n, transId));\n  float nextIdOffset = N21b(vec2(n, transId + 1.0));\n  float noiseThresh = STAR_RARITY;\n  float noise = S(1.0, 0.0, transProgress) * S(noiseThresh, 1.0, N21b(id + lastIdOffset));\n  noise += S(noiseThresh, 1.0, N21b(id + idOffset));\n  noise += S(0.0, 1.0, transProgress) * S(noiseThresh, 1.0, N21b(id + nextIdOffset));\n  return S(0.0, 0.2, minOf(0.5 - abs(gv))) * (noise * S(0.1, 2.0, minDS));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (gl_FragCoord.xy - .5 * u_resolution.xy) / u_resolution.y;\n  vec2 mouse = (u_mouse.xy - 0.5 * u_resolution.xy) / u_resolution.y;\n  float t = u_time / 9.0;\n  vec3 col = BLACK;\n  uv *= 4.0;\n\n  float fw = max(fwidth(uv.x), fwidth(uv.y));\n\n  float grow_shrink = GROW_SHRINK * sin(t * PI) * 0.1 + 0.9;\n\n  vec4 s = vec4(1.0, 1.0, 1.0, 1.0) * grow_shrink;\n\n  vec4 p = vec4(uv, - 4.0, N21b(uv) * 4. - 2.);\n\n  mat4 boxTrans = rot4(mouse.x * TAU / 2.0 + .347856, 1) * rot4(mouse.y * TAU / 2.0 + .37465, 4);\n  boxTrans *= rot4(t * 13.0 / 17.0 * ROTATE_IDLE + PI / 3.0, 1) * rot4(t * 13.0 / 11.0 * ROTATE_IDLE - 17.0 * PI / 7.0, 2);\n  boxTrans *= rot4(t * 11.0 / 17.0 * ROTATE_IDLE + PI / 3.0, 2) * rot4(t * 13.0 / 11.0 * ROTATE_IDLE - 17.0 * PI / 7.0, 3);\n  boxTrans *= rot4(t * 12.0 / 17.0 * ROTATE_IDLE + PI / 3.0, 4);\n  boxTrans *= rot4(t * 13.0 / 17.0 * ROTATE_IDLE, 5);\n\n  // raymarch over the orthogonal scene\n  vec2 sc = sinCos(vec2(t));\n  vec4 rd = normalize(vec4(0.0, 0.0, 1.0, 0.0));\n  float d = 0.0, dS = 999.0, minDS = 999.0, ed;\n  float steps = 0.0;\n  for(int i = 0; i < 50; i ++ ) {\n    ed = 999.;\n    steps ++ ;\n    float w = 0.0;\n    for (float w = -1.3; w < 1.3; w += .1) {\n        //if (w < minOf(s * boxTrans)) continue;\n        vec4 p_ = vec4(p.xyz, p.w + w) * boxTrans;\n        ed = min(ed, sdTesseractEdge(p_, s) - 0.01);\n    }\n    \n    dS = ed;\n    // dS = min(edgeDist, sdBox(p*boxTrans, s));\n    minDS = min(minDS, dS);\n    p = p + dS * rd * .5;\n    d += dS;\n    if (dS < 0.0001 || d > 100.0)break;\n  }\n\n\n  float noise = mkNoise(uv * grow_shrink, t, 1.);\n  col += noise;\n  col += S(0.01, 0.0, dS) * WHITE;\n  col += S(0.023, 0.005, minDS) * rainbow(uv, u_time + 2.0);\n  //col = minDS == 0. ? WHITE : RED;\n  \n  vec4 idgv = getIDGV(uv, 1.0);\n  vec2 id = idgv.xy, gv = idgv.zw;\n\n\n  gl_FragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slBXzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[466, 466, 486, 524, 656], [659, 659, 694, 694, 785], [788, 788, 808, 808, 964], [966, 966, 987, 987, 1013], [1014, 1014, 1035, 1035, 1069], [1070, 1070, 1091, 1091, 1126], [1128, 1128, 1153, 1153, 1192], [1194, 1246, 1282, 1282, 1529], [1532, 1618, 1652, 1652, 2190], [2325, 2325, 2345, 2345, 3102], [3104, 3104, 3139, 3139, 3227], [3230, 3230, 3269, 3269, 3307], [3309, 3355, 3400, 3400, 3483], [3485, 3485, 3521, 3521, 3614], [3616, 3616, 3662, 3662, 4452], [4454, 4454, 4509, 4509, 6346]], "test": "untested"}
{"id": "7tBXRw", "name": "space cube w twinkling stars", "author": "xertrov", "description": "I'm happy with how it turned out. I had to figure out a signed dist function for cube edges. I also had a lot of trouble (with rotations and things) getting the cube on the screen. I eventually \"resorted\" to raymarching and it worked pretty well!", "tags": ["raymarch", "cube", "art", "signeddistance"], "likes": 4, "viewed": 311, "published": 3, "date": "1627299682", "time_retrieved": "2024-07-30T19:09:16.777111", "image_code": "#define u_resolution iResolution\n#define u_mouse iMouse\n#define u_time iTime\n#define gl_FragColor fragColor\n\n#define PI 3.141592653589\n#define TAU 6.28318530718\n\n#define S(a, b, t)smoothstep(a, b, t)\n\n#define BLACK vec3(0.0)\n#define WHITE vec3(1.0)\n\n#define GROW_SHRINK 0.3\n#define ROTATE_IDLE 0.2\n#define BASE_TWINKLE 99.0\n#define STAR_RARITY 0.95\n// set to 5k+ for a hyperspace bungee; curious noise patterns at 2000.\n#define BG_SCALE 100.0\n\n/* lib/util stuff */\n\nfloat N21b(vec2 p) {  // from an art of code video i think\n  vec3 a = fract(vec3(p.xyx) * vec3(213.897, 653.453, 253.098));\n  a += dot(a, a.yzx + 79.76);\n  return fract((a.x + a.y) * a.z);\n}\n\n\nfloat sdBox(in vec3 p, in vec3 b) {\n  vec3 d = abs(p) - b;\n  return length(max(d, 0.0)) + min(max(d.z, max(d.x, d.y)), 0.0);\n}\n\n\nvec2 best2(vec3 p) {\n  vec2 r = p.x > p.y ? vec2(p.x, p.y) : vec2(p.y, p.x);\n  if (p.z > r.x) { return vec2(p.z, r.x);}\n  if (p.z > r.y) { return vec2(r.x, p.z);}\n  return r;\n}\n\nfloat minOf(vec2 v) {\n  return min(v.x, v.y);\n}\n\nvec2 sinCos(in vec2 ab) {\n  return vec2(sin(ab.x), cos(ab.y));\n}\n\n// roll from XY to XZ or YZ (0 no roll, 1=XZ, 2=YZ)\nmat3 rot3XY(float angle, int roll) {\n  float s = sin(angle), c = cos(angle);\n  mat3 r = mat3(c, - s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n  if (roll == 1) {\n    r = mat3(r[0].xzy, r[2].xzy, r[1].xzy);\n  } else if (roll == 2) {\n    r = mat3(r[2].zxy, r[0].zxy, r[1].zxy);\n  }\n  return r;\n}\n\n\nvec3 rainbow(vec2 uv, float time) {\n  return sin(vec3(time) + uv.xyx * vec3(1.0, 1.0, 1.0) + vec3(0, 2, 4)) * 0.49 + 0.5;\n}\n\n/* meat */\n\nfloat sdBoxEdge(in vec3 p, in vec3 b) {\n  return length(best2(abs(p) - b));  // rly elegant\n}\n\nvec4 getIDGV(vec2 uv, float scale) {\n  vec2 id = floor(uv * scale);\n  vec2 gv = fract(uv * scale) - 0.5;\n  return vec4(id, gv);\n}\n\nfloat mkNoise(vec2 uv, float t, float minDS) {\n  float scale = fwidth(uv.x) * 100.0 * BG_SCALE;\n  vec4 idgv = getIDGV(uv, scale);\n  vec2 id = idgv.xy;\n  vec2 gv = idgv.zw;\n  float n = N21b(id);\n  float transFreq = BASE_TWINKLE * n + 0.01;\n  t -= 3877.627 * n;\n  float transProgress = fract(t * transFreq);\n  float transId = floor(t * transFreq);\n  float lastIdOffset = N21b(vec2(n, transId - 1.0));\n  float idOffset = N21b(vec2(n, transId));\n  float nextIdOffset = N21b(vec2(n, transId + 1.0));\n  float noiseThresh = STAR_RARITY;\n  float noise = S(1.0, 0.0, transProgress) * S(noiseThresh, 1.0, N21b(id + lastIdOffset));\n  noise += S(noiseThresh, 1.0, N21b(id + idOffset));\n  noise += S(0.0, 1.0, transProgress) * S(noiseThresh, 1.0, N21b(id + nextIdOffset));\n  return S(0.0, 0.2, minOf(0.5 - abs(gv))) * (noise * S(0.1, 2.0, minDS));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (gl_FragCoord.xy - .5 * u_resolution.xy) / u_resolution.y;\n  vec2 mouse = (u_mouse.xy - 0.5 * u_resolution.xy) / u_resolution.y;\n  float t = u_time / 9.0;\n  vec3 col = BLACK;\n  uv *= 4.0;\n\n  float fw = max(fwidth(uv.x), fwidth(uv.y));\n\n  float grow_shrink = GROW_SHRINK * sin(t * PI) * 0.1 + 0.9;\n\n  vec3 s = vec3(1.0, 1.0, 1.0) * grow_shrink;\n  vec3 p = vec3(uv, - 4.0);\n\n  mat3 boxTrans = rot3XY(mouse.x * TAU / 2.0, 1) * rot3XY(mouse.y * TAU / 2.0, 2);\n  boxTrans *= rot3XY(t * 13.0 / 17.0 * ROTATE_IDLE + PI / 3.0, 0) * rot3XY(t * 13.0 / 11.0 * ROTATE_IDLE - 17.0 * PI / 7.0, 2);\n\n  // raymarch over the orthogonal scene\n  vec2 sc = sinCos(vec2(t));\n  vec3 rd = normalize(vec3(0.0, 0.0, 1.0));\n  float d = 0.0, dS = 999.0, minDS = 999.0, edgeDist;\n  float steps = 0.0;\n  for(int i = 0; i < 1000; i ++ ) {\n    steps ++ ;\n    edgeDist = sdBoxEdge(p * boxTrans, s) - 0.01;\n    dS = edgeDist;\n    //dS = min(edgeDist, sdBox(p*boxTrans, s));\n    minDS = min(minDS, dS);\n    p = p + dS * rd;\n    d += dS;\n    if (dS < 0.0001 || d > 100.0)break;\n  }\n\n  float noise = mkNoise(uv * grow_shrink, t, minDS);\n  col += noise;\n  col += S(0.01, 0.0, minDS) * WHITE;\n  col += S(0.023, 0.005, minDS) * rainbow(uv, u_time + 2.0);\n\n  gl_FragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tBXRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[466, 466, 486, 524, 656], [659, 659, 694, 694, 785], [788, 788, 808, 808, 964], [966, 966, 987, 987, 1013], [1015, 1015, 1040, 1040, 1079], [1081, 1133, 1169, 1169, 1416], [1419, 1419, 1454, 1454, 1542], [1556, 1556, 1595, 1595, 1649], [1651, 1651, 1687, 1687, 1780], [1782, 1782, 1828, 1828, 2618], [2620, 2620, 2675, 2675, 3939]], "test": "untested"}
{"id": "stSSRw", "name": "NUS sws3005-Ray tracing demo", "author": "uestcwzyyyyy", "description": "NUS sws3005 last assignment ", "tags": ["raytracing"], "likes": 10, "viewed": 343, "published": 3, "date": "1627295449", "time_retrieved": "2024-07-30T19:09:17.723582", "image_code": "const int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 6;\nconst int NUM_PLANES = 3;\nconst int NUM_SPHERES = 3;\n\n\nconst float initPosx=2.5;\nconst float initPosy=1.0;\nconst float initPosz=2.5;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nvec3 pos=vec3(initPosx,initPosy,initPosz);\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.2, 0.6 );\n\n // Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * 3.1415926535 / 180.0; \n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Cube_t\n{\n    vec3 leftBottom;\n    vec3 rightTop;\n    int materialID;\n};\n\n\nstruct Cone_t {\n\tfloat cosa;\n\tfloat h;\n\tvec3 c;\n\tvec3 v;\n\tint materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0. \n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that on Slides 8 and 12 of \n// Lecture 11 (Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS { \n//                   I_a * k_a + \n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nCube_t cube;\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\n\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n{\n    // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 3;\n\n    // Vertical plane.\n    Plane[1].A = 0.0;\n    Plane[1].B = -1.0;\n    Plane[1].C = 5.0;\n    Plane[1].D = 30.0;\n    Plane[1].materialID = 4;\n    \n    Plane[2].A = 5.0;\n    Plane[2].B = -1.0;\n    Plane[2].C = 0.0;\n    Plane[2].D = 30.0;\n    Plane[2].materialID = 5;\n\n    cube.leftBottom=vec3(-1.0,0,0);\n    cube.rightTop=vec3(-2,2.0,1.0);\n    cube.materialID=0;\n\n    // Center bouncing sphere.\n    Sphere[0].center = vec3( 1.0, abs(sin(2.0 * iTime)) + 0.7, -1.0 );\n    Sphere[0].radius = 0.7;\n    Sphere[0].materialID = 1;\n\n    // Circling sphere.\n    Sphere[1].center = vec3( -1.5 + 1.0 * cos(iTime), 1.0 + 0.6 * sin(3.0 * iTime), 0.5 + 1.0 * sin(iTime) );\n    Sphere[1].radius = 0.2;\n    Sphere[1].materialID = 2;\n    \n    Sphere[2].center = vec3( 1.0 + cos(2.0 * iTime) , 1.7 + sin(2.0 * iTime), -1.0);\n    Sphere[2].radius = 0.1;\n    Sphere[2].materialID = 4;\n\n    // Silver material.\n    Material[0].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n\n    // Gold material.\n    Material[1].k_d = vec3( 0.9, 0.5, 0.3 );\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 2.0 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 64.0;\n\n    // Green plastic material.\n    Material[2].k_d = vec3( 0.5, 0.8, 0.3 );\n    Material[2].k_a = 0.4 * Material[2].k_d;\n    Material[2].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[2].k_rg = 0.3 * Material[2].k_r;\n    Material[2].n = 128.0;\n\n    Material[3].k_d = vec3( 0.3, 0.2, 0.2 );\n    Material[3].k_a = 0.4 * Material[3].k_d;\n    Material[3].k_r = 3.0 * Material[3].k_d;\n    Material[3].k_rg = 0.2 * Material[3].k_r;\n    Material[3].n = 64.0;\n\n    Material[4].k_d = vec3( 0.7, 0.9, 0.8 );\n    Material[4].k_a = 0.2 * Material[4].k_d;\n    Material[4].k_r = 2.0 * Material[4].k_d;\n    Material[4].k_rg = 0.5 * Material[4].k_r;\n    Material[4].n = 64.0;\n    \n    Material[5].k_d = vec3( 0.4, 0.4, 0.4);\n    Material[5].k_a = 0.2 * Material[5].k_d;\n    Material[5].k_r = 2.0 * Material[5].k_d;\n    Material[5].k_rg = 0.6 * Material[5].k_r;\n    Material[5].n = 128.0;\n    \n    // Light 0.\n    Light[0].position = vec3( 8.0* cos(iTime), 5.0, -3.0 );\n    Light[0].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[0].I_source = vec3( 1.0, 1.0, 1.0 );\n\n    // Light 1.\n    Light[1].position = vec3( 1.0* cos(iTime)+5.0, 16.0, 1.0 );\n    Light[1].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[1].I_source = vec3( 1.0, 1.0, 1.0 );\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection \n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the \n// smaller t, the position of the intersection (hitPos) and the normal \n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    vec3 V = ray.o - sph.center;\n    float a0 = dot(V,V) - sph.radius * sph.radius;\n    float DdotV = dot(ray.d, V);\n\n    if (DdotV <= 0.0) {\n    \t// When the ray shoots towards the sphere\n    \tfloat discr = DdotV * DdotV - a0;\n    \tif (discr >= 0.0) {\n    \t\t// Smaller intersection point\n    \t\tt = -DdotV - sqrt(discr);\n    \t\thitPos = ray.o + t * ray.d;\n    \t\thitNormal = normalize(hitPos - sph.center);\n    \t\treturn (t >= tmin && t<= tmax);\n    \t}\n    }\n\treturn false;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    vec3 V = ray.o - sph.center;\n    float a0 = dot(V,V) - sph.radius * sph.radius;\n    float DdotV = dot(ray.d, V);\n\n    if (DdotV <= 0.0) {\n    \t// When the ray shoots towards the sphere\n    \tfloat discr = DdotV * DdotV - a0;\n    \tif (discr >= 0.0) {\n    \t\t// Need to compare both intersection points\n    \t\tfloat t1 = -DdotV - sqrt(discr);\n    \t\tfloat t2 = -DdotV + sqrt(discr);\n    \t\treturn ((t1 >= tmin && t1<= tmax) || (t2 >= tmin && t2 <= tmax));\n    \t}\n    }\n\treturn false;\n}\n\n\nbool inPlane(vec3 pos,vec3 leftBottom,vec3 rightTop)\n{\n    bool x1=(pos.x<=leftBottom.x+DEFAULT_TMIN)&&(pos.x>=rightTop.x-DEFAULT_TMIN);\n    bool x2=(pos.y>=leftBottom.y-DEFAULT_TMIN)&&(pos.y<=rightTop.y+DEFAULT_TMIN);\n    bool x3=(pos.z>=leftBottom.z-DEFAULT_TMIN)&&(pos.z<=rightTop.z+DEFAULT_TMIN);\n    return x1&&x2&&x3;\n}\n\n\nbool IntersectCube_t( in Cube_t cubic, in Ray_t ray, in float tmin, in float tmax)\n{\n\n    vec3 leftBottom=cubic.leftBottom;\n    vec3 rightTop=cubic.rightTop;\n    Plane_t p;\n    float t1;\n    float tNow=tmax;\n    vec3 hitPos1;\n    vec3 hitNormal1;\n    vec3 hitNormalNow;\n    //compute X plane intersection\n    p.A=1.0;\n    p.B=0.0;\n    p.C=0.0;\n    p.D=-cubic.leftBottom.x;\n    \n    bool i =IntersectPlane(p,ray,tmin,tmax,t1,hitPos1,hitNormal1);\n    if(i&&inPlane(hitPos1,leftBottom,rightTop))\n    {\n        if(t1<tNow &&t1>tmin)\n            {\n                tNow=t1;\n                hitNormalNow=hitNormal1;\n            }\n    }\n\n    p.A=1.0;\n    p.B=0.0;\n    p.C=0.0;\n    p.D=-cubic.rightTop.x;\n    \n    i =IntersectPlane(p,ray,tmin,tmax,t1,hitPos1,hitNormal1);\n    if(i&&inPlane(hitPos1,leftBottom,rightTop))\n    {\n        if(t1<tNow&&t1>tmin)\n            {\n                tNow=t1;\n                hitNormalNow=hitNormal1;\n            }\n    }\n\n    //compute Y plane intersection\n    p.A=0.0;\n    p.B=1.0;\n    p.C=0.0;\n    p.D=-cubic.leftBottom.y;\n    \n    i =IntersectPlane(p,ray,tmin,tmax,t1,hitPos1,hitNormal1);\n    if(i&&inPlane(hitPos1,leftBottom,rightTop))\n    {\n        if(t1<tNow&&t1>tmin)\n            {\n                tNow=t1;\n                hitNormalNow=hitNormal1;\n            }\n    }\n\n    p.A=0.0;\n    p.B=1.0;\n    p.C=0.0;\n    p.D=-cubic.rightTop.y;\n    \n    i =IntersectPlane(p,ray,tmin,tmax,t1,hitPos1,hitNormal1);\n    if(i&&inPlane(hitPos1,leftBottom,rightTop))\n    {\n        if(t1<tNow&&t1>tmin)\n            {\n                tNow=t1;\n                hitNormalNow=hitNormal1;\n            }\n    }\n\n    //compute Z plane intersection\n    p.A=0.0;\n    p.B=0.0;\n    p.C=1.0;\n    p.D=-cubic.leftBottom.z;\n    \n    i =IntersectPlane(p,ray,tmin,tmax,t1,hitPos1,hitNormal1);\n    if(i&&inPlane(hitPos1,leftBottom,rightTop))\n    {\n        if(t1<tNow&&t1>tmin)\n            {\n                tNow=t1;\n                hitNormalNow=hitNormal1;\n            }\n    }\n\n\n    p.A=0.0;\n    p.B=0.0;\n    p.C=1.0;\n    p.D=-cubic.rightTop.z;\n    \n    i =IntersectPlane(p,ray,tmin,tmax,t1,hitPos1,hitNormal1);\n    if(i&&inPlane(hitPos1,leftBottom,rightTop))\n    {\n        if(t1<tNow&&t1>tmin)\n            {\n                tNow=t1;\n                hitNormalNow=hitNormal1;\n            }\n    }\n\n    if(tNow!=tmax&& tNow>tmin)\n    {\n        return true;\n    }\n    return false;\n}\n\n\n\n\nbool IntersectCube_t( in Cube_t cubic, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    vec3 leftBottom=cubic.leftBottom;\n    vec3 rightTop=cubic.rightTop;\n    Plane_t p;\n    float t1;\n    float tNow=tmax; //the min t in six planes\n    vec3 hitPos1;\n    vec3 hitNormal1;\n    vec3 hitNormalNow;\n    //compute X plane intersection\n    p.A=1.0;\n    p.B=0.0;\n    p.C=0.0;\n    p.D=-leftBottom.x;\n    \n    bool i =IntersectPlane(p,ray,tmin,tmax,t1,hitPos1,hitNormal1);\n    if(i&&inPlane(hitPos1,leftBottom,rightTop))\n    {\n        if(t1<tNow &&t1>tmin)\n            {\n                tNow=t1;\n                hitNormalNow=hitNormal1;\n            }\n    }\n\n    p.A=1.0;\n    p.B=0.0;\n    p.C=0.0;\n    p.D=-rightTop.x;\n    \n    i =IntersectPlane(p,ray,tmin,tmax,t1,hitPos1,hitNormal1);\n    if(i&&inPlane(hitPos1,leftBottom,rightTop))\n    {\n        if(t1<tNow&&t1>tmin)\n            {\n                tNow=t1;\n                hitNormalNow=hitNormal1;\n            }\n    }\n\n    //compute Y plane intersection\n    p.A=0.0;\n    p.B=1.0;\n    p.C=0.0;\n    p.D=-cubic.leftBottom.y;\n    \n    i =IntersectPlane(p,ray,tmin,tmax,t1,hitPos1,hitNormal1);\n    if(i&&inPlane(hitPos1,leftBottom,rightTop))\n    {\n        if(t1<tNow&&t1>tmin)\n            {\n                tNow=t1;\n                hitNormalNow=hitNormal1;\n            }\n    }\n\n    p.A=0.0;\n    p.B=1.0;\n    p.C=0.0;\n    p.D=-cubic.rightTop.y;\n    \n    i =IntersectPlane(p,ray,tmin,tmax,t1,hitPos1,hitNormal1);\n    if(i&&inPlane(hitPos1,leftBottom,rightTop))\n    {\n        if(t1<tNow&&t1>tmin)\n            {\n                tNow=t1;\n                hitNormalNow=hitNormal1;\n            }\n    }\n\n    //compute Z plane intersection\n    p.A=0.0;\n    p.B=0.0;\n    p.C=1.0;\n    p.D=-cubic.leftBottom.z;\n    \n    i =IntersectPlane(p,ray,tmin,tmax,t1,hitPos1,hitNormal1);\n    if(i&&inPlane(hitPos1,leftBottom,rightTop))\n    {\n        if(t1<tNow&&t1>tmin)\n            {\n                tNow=t1;\n                hitNormalNow=hitNormal1;\n            }\n    }\n\n\n    p.A=0.0;\n    p.B=0.0;\n    p.C=1.0;\n    p.D=-cubic.rightTop.z;\n    \n    i =IntersectPlane(p,ray,tmin,tmax,t1,hitPos1,hitNormal1);\n    if(i&&inPlane(hitPos1,leftBottom,rightTop))\n    {\n        if(t1<tNow&&t1>tmin)\n            {\n                tNow=t1;\n                hitNormalNow=hitNormal1;\n            }\n    }\n\n    if(tNow!=tmax&& tNow>tmin)\n    {\n        t=tNow;\n        hitPos = ray.o + t * ray.d;\n        hitNormal=hitNormalNow;\n        return true;\n    }\n    return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow, \n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a + \n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray, \n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg ) \n{\n    // Find whether and where the ray hits some object. \n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Try interesecting input ray with all the planes and spheres,\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n\n    for (int i = 0; i < NUM_SPHERES; i++ ) {\n    \ttemp_hasHit = IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, DEFAULT_TMAX,\n                      temp_t, temp_hitPos, temp_hitNormal);\n\n    \tif (temp_hasHit && temp_t < nearest_t) {\n    \t\thasHitSomething = true;\n    \t\tnearest_t = temp_t;\n    \t\tnearest_hitPos = temp_hitPos;\n    \t\tnearest_hitNormal = temp_hitNormal;\n    \t\tnearest_hitMatID = Sphere[i].materialID;\n    \t}\n    \t\n    }\n\n        temp_hasHit=IntersectCube_t(cube,ray,DEFAULT_TMIN,DEFAULT_TMAX,temp_t, temp_hitPos, temp_hitNormal);\n        \tif (temp_hasHit && temp_t < nearest_t) {\n    \t\thasHitSomething = true;\n    \t\tnearest_t = temp_t;\n    \t\tnearest_hitPos = temp_hitPos;\n    \t\tnearest_hitNormal = temp_hitNormal;\n    \t\tnearest_hitMatID = cube.materialID;\n    \t}\n\n\n    for (int i = 0; i < NUM_PLANES; i++ ) {\n    \ttemp_hasHit = IntersectPlane(Plane[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n\n    \tif (temp_hasHit && temp_t < nearest_t ) {\n    \t\thasHitSomething = true;\n    \t\tnearest_t = temp_t;\n    \t\tnearest_hitPos = temp_hitPos;\n    \t\tnearest_hitNormal = temp_hitNormal;\n    \t\tnearest_hitMatID = Plane[i].materialID;\n    \t}\n    \t\n    }\n    \n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Accumulate lighting from each light source on the nearest hit point. \n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres) between the \n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    // Compute lighting for each lights\n    Ray_t ShadowRay[NUM_LIGHTS];\n    bool L_shadow[NUM_LIGHTS];\n    for (int i = 0; i < NUM_LIGHTS; i++ ) {\n    \tShadowRay[i].o = nearest_hitPos;\n    \tShadowRay[i].d = normalize(Light[i].position - ShadowRay[i].o);\n\n    \tfor (int j = 0; j < NUM_SPHERES; j++ )\n    \t\tif(!L_shadow[i])\n    \t\tL_shadow[i] = IntersectSphere(Sphere[j], ShadowRay[i], DEFAULT_TMIN, distance(nearest_hitPos, Light[i].position));\n\n    \tif (!L_shadow[i])\n    \t\tfor(int j = 0; j < NUM_PLANES; j++ )\n    \t\t\tif(!L_shadow[i])\n    \t\t\t\tL_shadow[i] = IntersectPlane(Plane[j], ShadowRay[i], DEFAULT_TMIN, distance(nearest_hitPos, Light[i].position));\n\n        if(!L_shadow[i])\n    \t    L_shadow[i] = IntersectCube_t(cube, ShadowRay[i], DEFAULT_TMIN, distance(nearest_hitPos, Light[i].position));\n\n    \tI_local += PhongLighting( ShadowRay[i].d, nearest_hitNormal, - ray.d, L_shadow[i], Material[nearest_hitMatID], Light[i] );\n    }\n\n    \n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    return I_local;\n}\n\nvec2 getKeyBoard()\n{\n\n    float x1=texelFetch( iChannel0, ivec2(KEY_LEFT,0), 0 ).x;\n    float x2=texelFetch( iChannel0, ivec2(KEY_RIGHT,0), 0 ).x;\n    float y1=texelFetch( iChannel0, ivec2(KEY_UP,0), 0 ).x;\n    float y2=texelFetch( iChannel0, ivec2(KEY_DOWN,0), 0 ).x;\n    return 5.0*vec2(x2-x1,y1-y2);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n\n    pos+=vec3(getKeyBoard(),0);\n    \n    \n    // Position the camera.\n    vec3 cam_pos = pos + vec3( 4.0 * cos(iTime / 1.5) + 1., 0.2 + 1.0 * sin(iTime / 3.0), 1.0 * sin(iTime / 2.0));\n    vec3 cam_lookat = vec3( 0.25, 1.0, 0.0 );\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ ) \n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n\n    fragColor = vec4( I_result, 1.0 );\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stSSRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2749, 2931, 2949, 2974, 5628], [5632, 6129, 6284, 6284, 6614], [6618, 6950, 7033, 7033, 7245], [7249, 7769, 7927, 8041, 8515], [8519, 8852, 8937, 9051, 9535], [9538, 9538, 9592, 9592, 9863], [9866, 9866, 9950, 9950, 12239], [12244, 12244, 12402, 12402, 14788], [14790, 15144, 15275, 15275, 15688], [15691, 16480, 16595, 16687, 20872], [20874, 20874, 20894, 20894, 21178], [21180, 21541, 21598, 21598, 23135]], "test": "untested"}
{"id": "NtSXRm", "name": "Pixelated Transition Effect, pt2", "author": "chenglou", "description": "See original for the simpler, discrete tiles size version\nThis one has:\n- continuous tile size\n- centered zooming animation\n- independently configurable tile width & height", "tags": ["pixel", "fx"], "likes": 5, "viewed": 430, "published": 3, "date": "1627289346", "time_retrieved": "2024-07-30T19:09:18.730888", "image_code": "#define CORRECT 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // width & height can be configured independently\n    vec2 tileSize = vec2((sin(iTime) + 1.) * 200. + 1.); // from 1 to 401\n\n    // Careful! You want to center a tile instead of start positioning tiles from 0,0\n    // otherwise, the zooming effect looks like it's displacing tiles to the right.\n    // Change CORRECT above to 0 see the visual glitch.\n    vec2 edgePadding = mod(iResolution.xy / 2. - tileSize / 2., tileSize); // might wanna sketch it out to understand it\n    vec2 tileIndex = ceil((fragCoord - edgePadding) / tileSize); // starts from 0\n    \n    #if CORRECT\n    fragColor = texture(iChannel0, (edgePadding + tileIndex * tileSize - tileSize / 2.) / iResolution.xy);\n    #else\n    fragColor = texture(iChannel0, (floor(fragCoord / tileSize) * tileSize + tileSize / 2.) / iResolution.xy);\n    #endif\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtSXRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 76, 130, 896]], "test": "untested"}
{"id": "ftSXRm", "name": "Pixelated Transition Effect, pt1", "author": "chenglou", "description": "Simple pixelated transition effect, with discrete pixel tiles size.\nContinuous tiles size version: [url]https://www.shadertoy.com/view/NtSXRm[/url]", "tags": ["pixel", "fx"], "likes": 2, "viewed": 351, "published": 3, "date": "1627289343", "time_retrieved": "2024-07-30T19:09:19.656413", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    // from 1 to 201\n    float count = floor((sin(iTime) + 1.) * 100. + 1.);\n\n    vec2 tileSize = iResolution.xy / count;\n    fragColor = texture(iChannel0, (floor(fragCoord / tileSize) * tileSize + tileSize / 2.) / iResolution.xy);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftSXRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 79, 293]], "test": "untested"}
{"id": "flBSzw", "name": "Fractal Pattern Doodle", "author": "Plento", "description": "A little fractaly doodle to pass some time.", "tags": ["2d", "fractal", "doodle"], "likes": 43, "viewed": 1514, "published": 3, "date": "1627285346", "time_retrieved": "2024-07-30T19:09:20.629810", "image_code": "// Cole Peterson\n\n#define R iResolution.xy\n#define m ( iMouse.xy - .5*R ) / R.y\n#define ss(a, b, t) smoothstep(a, b, t)\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    float t = iTime*.25 - 1.5;\n    \n    vec2 uv = vec2( u - .5*R ) / R.y;\n    uv += vec2(t, t*.2 - .4);\n    \n    if(iMouse.z > 0.)\n        uv += m*5.;\n    \n    uv = (uv + vec2(-uv.y,uv.x) ) / 1.41;\n    uv = fract(uv * .35) - .5;\n    uv = abs(uv);\n    \n    vec2 v = vec2(cos(.09), sin(.09));\n    float dp = dot(uv, v);\n    uv -= v*max(0., dp)*2.;\n    \n    float w = 0.;\n    for(float i = 0.; i < 27.;i++){\n        uv *= 1.23;\n        uv = abs(uv);\n    \tuv -= 0.36;\n    \tuv -= v*min(0., dot(uv, v))*2.;\n        uv.y += cos(uv.x*45.)*.007;\n        w += dot(uv, uv);\n    }\n    \n    float n = (w*12. + dp*15.);\n    vec3 col = 1. - (.6 + .6*cos(vec3(.45, 0.6, .81) * n + vec3(-.6, .3, -.6)));\n    \n    col *= max(ss(.0, .11, abs(uv.y*.4)), .8);\n    col = pow(col * 1.2, vec3(1.6));\n    f = vec4(1.-exp(-col), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flBSzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 121, 161, 161, 971]], "test": "untested"}
{"id": "NlBSzw", "name": "Albert Fractal", "author": "milesWaugh", "description": "Renders with 4x4 AA", "tags": ["2d", "fractal", "simple", "albert"], "likes": 2, "viewed": 303, "published": 3, "date": "1627278063", "time_retrieved": "2024-07-30T19:09:21.499485", "image_code": "//NOTE:\n//If the screen is just black, restart the shader,\n//and wait one second. Initialization is required,\n//meaning iTime must be less than 1\n//for at least one frame.\n\nvoid mainImage(out vec4 a, in vec2 b) {\n    a = texture(iChannel0, b / iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float b(float d){\n  return abs(1.-d)<.07?0.:1.;\n}\n\nfloat b2(float d){\n  return d<1.?0.:1.;\n}\n\nfloat f(vec2 x){\n  x *= iResolution.y * .5;\n  x += iResolution.xy * .5;\n  x /= iResolution.xy;\n  return texture(iChannel0, x).r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  float col2 = 0.;\n  float col = 0.;\n  for (float i = -.5; i < .5; i += .25) {\n    for (float j = -.5; j < .5; j += .25) {\n      col = 0.;\n      vec2 uv = (fragCoord + vec2(i, j) - iResolution.xy * .5) / (iResolution.y * .5);\n      float c = uv.y < 0. ? 1. : 0.;\n      float s1 = 3.1;\n      float f1 = .645;\n      float s2 = 1.55;\n      float f2 = 1./3.;\n      if (iTime < 1.) {\n        float d1 = dot(uv, uv);\n        vec2 z2 = (uv + vec2(f1, 0.)) * s1;\n        vec2 z3 = (uv - vec2(f2, 0.)) * s2;\n        float d3 = dot(z3, z3);\n        col = b2(d3) * b(d1) * c * b(dot(z2, z2)) + (1. - b2(d3)) * b(d3);\n        col += b2(d1);\n        vec2 z4 = (z3 + vec2(f1, 0.)) * s1;\n        vec2 z5 = (z3 - vec2(f2, 0.)) * s2;\n        float d4 = dot(z4, z4);\n        col = b2(d4) * col * b(dot(z5, z5)) + (1. - b2(d4)) * b(d4) * c;\n      }else{\n        vec2 z2 = (uv + vec2(f1, 0.)) * s1;\n        vec2 z3 = (uv - vec2(f2, 0.)) * s2;\n        vec2 z4 = (z3 + vec2(f1, 0.)) * s1;\n        vec2 z5 = (z3 - vec2(f2, 0.)) * s2;\n        col = f(uv);\n        if (dot(z2, z2) < .95) {\n          col = f(z2);\n        }else{\n          if (dot(z4, z4) < .95) {\n            col = f(z4);\n          }else{\n            if (dot(z5, z5) < .95) {\n              col = f(z5);\n            }\n          }\n        }\n      }\n      col2 += clamp(col, 0., 1.);\n    }\n  }\n  col2 /= 16.;\n  fragColor = vec4(col2, col2, col2, 1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlBSzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[173, 173, 212, 212, 262]], "test": "untested"}
{"id": "flSXRw", "name": "plasma experiment", "author": "jorge2017a1", "description": "plasma experiment", "tags": ["plasmaexperiment"], "likes": 11, "viewed": 327, "published": 3, "date": "1627265285", "time_retrieved": "2024-07-30T19:09:22.606525", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\n//referencia\n//https://www.shadertoy.com/view/wltSWn\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\n\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    float planeDist2 = 50.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    float planeDist5 = -p.z+40.0;  //pared frente\n    float planeDist6 = p.z+40.0;  //pared atras\n    res =opU3(res, vec3(planeDist1,-1.0,12.0)); //inf\n    res =opU3(res, vec3(planeDist5,-1.0 ,13.0)); \n    \n          p.y=p.y-5.0;\n   \n   float sdsp1= sdSphere( p-vec3(-10.0,0.0,0.0), 6.0 );\n    float sdsp2= sdSphere( p-vec3(14.0,3.0,10.0), 6.0 );\n    res =opU3(res, vec3(sdsp1,2.0,-1)); \n    res =opU3(res, vec3(sdsp2,-1.0,11.0)); \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.distmax = minDist;\n    mObj.distmin = dS.x;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{   vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true)\n        {fshadow=GetShadow(p,lp);}\n    else\n        {fshadow=0.5;}\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*occ*sh;\n    \n    lin += 2.5*spe*vec3(1.0);\n    \n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    lin += 0.4*pow(clamp(dot(hal,n),0.0,1.0),12.0)*dif3;\n    lin *= atten*0.5*col*fshadow;\n    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    lin = pow(lin,vec3(0.4545));\n    return lin;\n}\n//----------------------------------------------------\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n///-------------------------------------\n//https://www.shadertoy.com/view/wltSWn\nvec2 hashvec2 (in vec2 p) {\n  p = vec2 (dot (p, vec2 (127.1, 311.7)),\n            dot (p, vec2 (269.5, 183.3)));\n\n  return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise (in vec2 p) {\n  const float K1 = .366025404;\n  const float K2 = .211324865;\n\n  vec2 i = floor (p + (p.x + p.y)*K1);\n   \n  vec2 a = p - i + (i.x + i.y)*K2;\n  vec2 o = step (a.yx, a.xy);    \n  vec2 b = a - o + K2;\n  vec2 c = a - 1. + 2.*K2;\n\n  vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n  vec3 n = h*h*h*h*vec3 (dot (a, hashvec2 (i + .0)),\n                         dot (b, hashvec2 (i + o)),\n                         dot (c, hashvec2 (i + 1.)));\n\n  return dot (n, vec3 (70.));\n}\n\n\nfloat fbm(vec2 pos, float tm)\n{\n    vec2 offset = vec2(cos(tm), 0.0);\n    float aggr = 0.0;\n    \n    aggr += noise(pos);\n    aggr += noise(pos + offset) * 0.5;\n    aggr += noise(pos + offset.yx) * 0.25;\n    aggr += noise(pos - offset) * 0.125;\n    aggr += noise(pos - offset.yx) * 0.0625;\n    \n    aggr /= 1.0 + 0.5 + 0.25 + 0.125 + 0.0625;\n    \n    return (aggr * 0.5) + 0.5;    \n}\n\nvec3 lightning(vec2 pos, float offset)\n{\n    vec3 col = vec3(0.0);\n    vec2 f = vec2(0.0, -iTime * 0.25 );\n    \n    for (int i = 0; i < 3; i++)\n    {\n        float time = iTime +float(i);\n        float d1 = abs(offset * 0.43 / (0.0 + offset - fbm((pos + f) * 3.0, time)));\n        float d2 = abs(offset * 0.43 / (0.0 + offset - fbm((pos + f) * 2.0, 0.9 * time + 10.0)));\n        col += vec3(d1 * vec3(0.1, 0.3, 0.8));\n        col *= vec3(d2 * vec3(0.7, 0.3, 0.5));\n    }\n    \n    return col;\n}\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    if (id_material==11.0)\n    {   vec3 n = lightning(p.xy*0.25, mObj.distmin + 0.5);\n    \tvec3 col = vec3(0.0);\n        col += n;\n        return col;\n    }\n    \n    if (id_material==12.0)\n    {   vec3 n = lightning(p.xz*0.065, mObj.distmin + 0.5);\n    \tvec3 col = vec3(0.0);\n        col += mix(vec3(0.0),n, mObj.distmin);\n        return col;\n    }\n    \n    if (id_material==13.0)\n    {   vec3 n = lightning(p.xy*0.0165, mObj.distmin + 0.5);\n    \tvec3 col = vec3(0.0);\n        col += mix(vec3(0.0),n, mObj.distmin);\n        return col;\n    }\n    \n}\n\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n     if (id_material>-1.0 && id_color==-1)\n        {   colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n   //float d = RayMarch(ro, rd);\n   float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        col= result;\n    }\n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 10.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 30.0, -10.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(0.0,7.0,-25.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n    vec3 col= Render( ro,  rd);\n    //col = exposureToneMapping(2.0, col);\n    col = linear2srgb(col);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float distmin;\n    float distmax;\n    \n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n///--------------------------------------------FIN\n///--------------------------------------------\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flSXRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[533, 533, 569, 569, 590], [592, 657, 691, 691, 787], [788, 788, 822, 822, 913], [914, 914, 948, 948, 1039], [1040, 1080, 1114, 1114, 1209], [1210, 1250, 1275, 1275, 2047], [2049, 2100, 2124, 2124, 2286], [2288, 2288, 2337, 2337, 3032], [3034, 3088, 3124, 3124, 3369], [3370, 3425, 3452, 3452, 3469], [3471, 3471, 3507, 3507, 3599], [3600, 3600, 3646, 3646, 3771], [3773, 3773, 3847, 3847, 5419], [5420, 5509, 5589, 5589, 5712], [5713, 5794, 5821, 5821, 5958], [5960, 5960, 5985, 5985, 6474], [6477, 6477, 6508, 6508, 6859], [6861, 6861, 6901, 6901, 7354], [7356, 7407, 7454, 7454, 8052], [8054, 8106, 8199, 8199, 8467], [8469, 8469, 8500, 8500, 9066], [9068, 9117, 9143, 9143, 9253], [9255, 9255, 9313, 9313, 9365], [9367, 9416, 9473, 9473, 10010]], "test": "untested"}
{"id": "stSXRD", "name": "Columns / Domain Rep", "author": "byt3_m3chanic", "description": "Columns / Domain Rep - music \"droid bishop\" ", "tags": ["raymarching", "glsl"], "likes": 13, "viewed": 349, "published": 3, "date": "1627262937", "time_retrieved": "2024-07-30T19:09:23.514098", "image_code": "/**\n    Columns / Domain Rep \n    @byt3_m3chanic | 07/25/21\n    \n    working with some looping movement\n    / animation in a cute isometric thing\n    - music \"droid bishop\" \n    \n*/\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MAX_DIST    100.\n#define MIN_DIST    1e-4\n\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(23.86,48.32)))*4374.432); }\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0.0, 1.0); }\n\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\n//@iq - all sdf's\nfloat box(vec3 p, vec3 s) \n{\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\nfloat box(vec2 p,vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat cap( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat vcap( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nconst float drep = 12.;\nconst float angle = 2.*PI/drep;\nconst float angfl = angle/2.;\nconst float hfrep = drep/2.;\n\nfloat polar(inout vec2 p) \n{\n    //float angle = 2.*PI/rep;\n    float a = atan(p.y, p.x) + angfl;\n    float c = floor(a/angle);\n    a = mod(a,angle) - angfl;\n    p = vec2(cos(a), sin(a))*length(p);\n    return (abs(c) >= (hfrep)) ? abs(c) : c;\n} \n\n//constants\nconst float sz = 6.;\nconst float hf = sz/2.;\nconst float db = sz*2.;\n\n//global\nfloat ftime=0.,ga1,ga2,ga3,ga4,tmod=0.,speed=0.;\nmat2 turn,rurn,r45,rx,ry;\nvec3 hit=vec3(0),hitPoint=vec3(0),gid=vec3(0),sid=vec3(0);\n\nfloat column(vec3 q)\n{\n    float clm = cap(q,.3,1.5);\n    vec3 p =vec3(q.x,abs(q.y),q.z);\n    float pcap = box(p-vec3(0,1.45,0),vec3(.5,.1,.5))-.005;\n          pcap = min(cap(p-vec3(0,1.3,0),.4,.05),pcap);\n    \n    polar(q.xz);\n    float grv = vcap(q-vec3(.3,-1.1,0),2.2,.045);\n    return min(pcap,max(clm,-grv));\n}\n\nvec2 map(vec3 p)\n{\n    p.x-=T*.4;\n    vec2 res = vec2(1e5,0.);\n    vec3 q = p;\n\n    vec3 qid = floor((q+hf)/sz)+vec3(11);\n    vec3 ofs = q+vec3(hf);\n    vec3 xid = floor((ofs+hf)/sz);\n    vec3 tt = q;\n    \n    float fhs;\n    if(tmod<4.){\n      \tfhs = hash21(qid.zy);\n        tt.x += (fhs>.5) ? ftime : -ftime;\n    } else {\n      \tfhs = hash21(qid.xy);\n        tt.z += (fhs>.5) ? ftime : -ftime;\n    }\n\n    q = mod(q+hf,sz)-hf;\n    vec3 tid = floor((tt+hf)/sz);\n    tt = mod(tt+hf,sz)-hf;\n\n    if(tmod<4.){\n        tt.xy*=(fhs>.5) ? turn : rurn;\n    }else{\n        tt.yz*=(fhs>.5) ? rurn : turn;\n    }\n    \n    float sphere = length(abs(q)-hf)-1.15;\n    sphere = min(length( vec2(abs(q.z)-hf,abs(q.y)-hf))-.1,sphere);\n    if(p.y>-1.65) sphere = 0.5;\n    if(sphere<res.x)\n    {\n        res = vec2(sphere,2.);\n    \thit=q;\n        gid=xid+25.;\n    }\n    \n    float pillar = column( vec3(abs(q.x)-hf,q.y,abs(q.z)-hf));\n    pillar=min(column( vec3(abs(q.x)-hf,q.z,abs(q.y)-hf)),pillar);\n    if(p.y>-1.65) pillar = 0.5;\n    if(pillar<res.x)\n    {\n        res = vec2(pillar,4.);\n    \thit=q;\n        gid=qid+25.;\n    }\n\n    float balls = length(abs(tt)-.45)-.45;\n    balls=max(box(tt,vec3(.55)),balls);\n    if(p.y>1.) balls = 1.;\n    if(balls<res.x)\n    {\n        res = vec2(balls,1.);\n    \thit=q;\n        gid=tid+25.;\n    }\n    \n    return res;\n}\n\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec3 hue(float t)\n{ \n    vec3 c = vec3(0.325,0.976,0.867);\n    return .50 + .35*cos(T*.3+PI2*t*(c*vec3(.98,.99,.97))); \n}\n\nvoid topLayer(inout vec3 C, vec2 uv)\n{\n    float px = fwidth(uv.x);\n    uv*=rot(.03);\n    float bx = box(uv-vec2(-.02,.02),vec2(.85,.45))-.0125;\n    float dx = abs(bx)-.0025;\n    dx=smoothstep(px,-px,dx);\n    bx=smoothstep(-px,px,bx);\n\n    float bd = box(uv-vec2(.065,-.055),vec2(.825,.425))-.0125;\n    float sd =smoothstep(.085-px,px,bd);\n\n    float ln = texture(iChannel0,uv*.75).r;\n    ln=smoothstep(.42-px,px,ln);\n    vec3 base = vec3(.83);\n    base = mix(base*.3,base,clamp((uv.y+.5),0.,1.));\n    vec3 acct = hue(55.)*.1;\n    vec3 edge = mix(vec3(.95),acct,clamp((uv.y+.5),0.,1.));\n    C=mix(C,base,bx);\n    C=mix(C,acct,min(ln,bx));\n    C=mix(C,C*.15,min(sd,bx));\n    C=mix(C,edge,dx);\n    C=mix(C,C*.8,max(hash21(uv),bx));\n\n}\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    // precal    \n    float zoom = mod(T*.1,4.)<2. ? 10. : 6.;\n    tmod=mod(T,8.);\n    ftime = fract(T*.25)*sz;\n    r45=rot(-0.78539816339);\n    turn=rot(ftime*PI/2.);\n    rurn=rot(-ftime*PI/2.);\n    //\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(uv*zoom,-zoom);\n    vec3 rd = vec3(0.,0.,1.);\n\n    ro.yz*=r45;\n    ro.xz*=r45;\n    rd.yz*=r45;\n    rd.xz*=r45;\n    \n    vec3 FC = mix(hue(3.),hue(95.),clamp((uv.y+.5)*.75,0.,1.));\n    vec3 C = vec3(0);\n    vec3 p;\n    float d=0.,m=0.;\n\n    if(uv.y>-.48&&uv.y<.52 && uv.x>-.9&&uv.x<.87)\n    {      \n        //marcher\n        for(int i=0;i<100;i++)\n        {\n            p=ro+rd*d;\n            vec2 ray = map(p);\n            d += ray.x;\n            m  = ray.y;\n            if(abs(ray.x)<MIN_DIST ||d>MAX_DIST)break;\n        }\n\n        float alpha = 1.;\n        sid=gid;\n\n        if(d<MAX_DIST)\n        {\n            alpha = 0.;\n            vec3 n = normal(p,d);\n            vec3 lpos =vec3(3, 8., -7.);\n            vec3 l = normalize(lpos-p);\n            float diff =  clamp(dot(n,l),0.,1.);\n\n            float shdw = 1.;\n            for( float t=.03; t < 13.; )\n            {\n                float h = map(p + l*t).x;\n                if( h<MIN_DIST ) { shdw = 0.; break; }\n                shdw = min(shdw, 24.*h/t);\n                t += h * .25;\n                if( shdw<MIN_DIST || t>25. ) break;\n            }\n\n            vec3 h = vec3(.125);\n\n            if(m==1.) {\n                vec3 view = normalize(p - ro);\n                vec3 ret = reflect(normalize(lpos), n);\n                float spec = .75 * pow(max(dot(view, ret), 0.), 10.);\n                h=hue(14.732*(sid.y+5.));\n                diff = mix(diff,diff*shdw,.65);\n                C = vec3(diff*h)+spec;\n            }\n\n            if(m==2.) {\n                diff=d*.1;\n                h=hue(33.6+(sid.z*.05));\n                diff = mix(diff,diff*shdw,.65);\n                C = diff*h;\n            }\n\n            if(m==4.){\n                vec3 view = normalize(p - ro);\n                vec3 ret = reflect(normalize(lpos), n);\n                float spec = .75 * pow(max(dot(view, ret), 0.), 10.);\n                h = hue(41.5);\n                diff = mix(diff,diff*shdw,.65);\n                C = vec3(diff*h)+spec;\n            }\n\n        } \n\n        C = mix(FC,C,exp(-.000095*d*d*d));\n    }\n    \n    topLayer(C,uv);\n    C=pow(C, vec3(.4545));\n    C=clamp(C,vec3(.03),vec3(1.));\n    \n    O = vec4(C,1.0);\n}\n\n", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stSXRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[347, 347, 368, 368, 424], [425, 425, 469, 469, 524], [526, 526, 544, 544, 589], [591, 609, 637, 637, 721], [722, 722, 749, 749, 829], [830, 830, 869, 869, 980], [982, 982, 1022, 1022, 1085], [1203, 1203, 1231, 1262, 1447], [1676, 1676, 1698, 1698, 1991], [1993, 1993, 2011, 2011, 3331], [3333, 3333, 3363, 3363, 3602], [3604, 3604, 3623, 3623, 3725], [3727, 3727, 3765, 3765, 4459], [4460, 4460, 4501, 4522, 6949]], "test": "untested"}
{"id": "7tjXzD", "name": "x^y = y^x - Solved (Lambert W)", "author": "oneshade", "description": "Solution to x^y=y^x in terms of the Lambert W function.", "tags": ["solution", "lambertw", "specialfunction"], "likes": 6, "viewed": 168, "published": 3, "date": "1627256337", "time_retrieved": "2024-07-30T19:09:24.627122", "image_code": "// See https://www.desmos.com/calculator/7w04yjoiwx\n// See also @iq's shader about x^y=y^x https://www.shadertoy.com/view/XdySR3\n// W1(x) and W2(x) are the two branches of the Lambert W function (https://en.wikipedia.org/wiki/Lambert_W_function)\n// According to the wikipedia article, they are actually denotated W_0(x) and W_-1(x)\n// but that convention doesn't work in GLSL syntax\n\n#define draw(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\nfloat h1(in float x) { return 0.62 * log(x + 0.5) + 0.3; }\nfloat h2(in float x) { return -4.68 - 10.0 * x; }\nfloat n(in float y, in float x) { return y - (y - x / exp(y)) / (y + 1.0); } // Newton-Raphson\nfloat W1(in float x) { return n(n(n(n(n(n(n(n(h1(x), x), x), x), x), x), x), x), x); } // y > -1\nfloat W2(in float x) { return n(n(n(n(n(n(n(n(h2(x), x), x), x), x), x), x), x), x); } // y < -1\n\n// Solutions (two possible)\nfloat f(in float x) { return exp(-W1(-log(x) / x)); }\nfloat g(in float x) { return exp(-W2(-log(x) / x)); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.y * 8.0;\n    float unit = 16.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n\n    // Grid\n    draw(abs(fract(uv.x + 0.5) - 0.5) + 0.25 * unit, vec3(0.0, 0.0, 1.0));\n    draw(abs(fract(uv.y + 0.5) - 0.5) + 0.25 * unit, vec3(0.0, 0.0, 1.0));\n    draw(abs(uv.x), vec3(1.0, 0.0, 0.0));\n    draw(abs(uv.y), vec3(1.0, 0.0, 0.0));\n\n    // Draw the solved equation (two parts)\n    if (mod(iTime, 4.0) < 2.0) {\n        float y = f(uv.x);\n        float dx = (f(uv.x + 0.001) - y) / 0.001;\n        draw(abs(uv.y - y) / sqrt(1.0 + dx * dx) - 0.01, vec3(1.0, 0.0, 0.0));\n\n        y = g(uv.x);\n        dx = (g(uv.x + 0.001) - y) / 0.001;\n        draw(abs(uv.y - y) / sqrt(1.0 + dx * dx) - 0.01, vec3(0.0, 0.0, 1.0));\n    }\n\n    // Draw the implicit equation\n    else {\n        #define f(x, y) (pow(x, y) - pow(y, x))\n        float d = f(uv.x, uv.y);\n        vec2 g = (vec2(f(uv.x + 0.001, uv.y), f(uv.x, uv.y + 0.001)) - d) / 0.001;\n        draw(abs(d) / length(g), vec3(0.0));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tjXzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[462, 462, 484, 484, 520], [521, 521, 543, 543, 570], [571, 571, 604, 604, 647], [648, 666, 688, 688, 752], [753, 763, 785, 785, 849], [861, 889, 910, 910, 942], [943, 943, 964, 964, 996], [998, 998, 1053, 1053, 2097]], "test": "untested"}
{"id": "7tjSzW", "name": "Blueprint Test", "author": "Yerti", "description": "Blueprint Shader", "tags": ["blueprint"], "likes": 3, "viewed": 258, "published": 3, "date": "1627231033", "time_retrieved": "2024-07-30T19:09:25.449922", "image_code": "/*\nfloat stripes(float spacing, float thickness, float alpha, float position) {\n    return alpha * step(spacing-thickness, mod(position, spacing));\n}\n\nfloat grid(float spacing, float thickness, float alpha, vec2 position) {\n    vec2 lines = alpha * step(vec2(spacing-thickness), mod(position, vec2(spacing)));\n    return max(lines.x, lines.y);\n}\n\n// asymmetric\nvec2 grid2(vec2 spacing, vec2 thickness, vec2 alpha, vec2 position) {\n    return alpha * step(mod(position, spacing), spacing-thickness);\n}*/\n\nfloat smoothgrid(float spacing, float thickness, float alpha, vec2 position) {\n    vec2 posrep = mod(position, vec2(spacing))-.5*thickness;\n    vec2 lines = alpha * max(vec2(0.0), min(thickness+posrep, thickness-posrep)/thickness);\n    return max(lines.x, lines.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-iMouse.xy) / iResolution.xx;\n    vec3 blue = vec3(0.13, 0.13, 0.13);\n      \n    vec2 spacing   = vec2(0.1  , 0.02); \n    vec2 thickness = vec2(0.002, 0.001);\n    vec2 alpha     = vec2(0.9  , 0.5);\n    \n    float thick_lines = smoothgrid(spacing.s, thickness.s, alpha.s, uv);\n    float thin_lines  = smoothgrid(spacing.t, thickness.t, alpha.t, uv);\n    \n    float erasure = 0.1;\n    \n    vec4 background = vec4(0);\n    vec3 paper = max(blue, 0.35*length(background.rgb));\n    \n    vec3 color = vec3(max(paper, sqrt(erasure*background.b+(1.-erasure))*max(thick_lines, thin_lines)));\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tjSzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[504, 504, 582, 582, 771], [773, 773, 830, 830, 1474]], "test": "untested"}
{"id": "Nl2SzD", "name": "Fractal 69_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 20, "viewed": 387, "published": 3, "date": "1627225398", "time_retrieved": "2024-07-30T19:09:26.324584", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=.3;\n        ++i<90.;\n        O.xyz+=mix(vec3(1),H(log(s)*.3),.8)*.03*exp(-i*i*e)\n    )\n    {\n        p=g*d;\n        p+=vec3(.3,.3,-1.8);\n        p=R(p,vec3(.577),iTime*.1);\n        // https://www.shadertoy.com/view/3ttyzB\n        // Based on the idea of jarble\n        p=cos(p*3.+3.*cos(p*.3));\n        s=3.;\n        for(int j=0;j++<8;)\n            p=clamp(p,-.5,.5)*2.-p,\n            s*=e=7.*clamp(.3/min(dot(p,p),1.),.0,1.),\n            p*=e;\n        g+=e=length(p)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2SzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 731]], "test": "untested"}
{"id": "ftjXRD", "name": "Fractal 68_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 25, "viewed": 476, "published": 3, "date": "1627220646", "time_retrieved": "2024-07-30T19:09:27.109485", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=.3;\n        ++i<90.;\n        O.xyz+=mix(vec3(1),H(log(s)*.3),.8)*.03*exp(-i*i*e)\n    )\n    {\n        p=g*d;\n        p+=vec3(.3,.3,-1.8);\n        p=R(p,vec3(.577),iTime*.1);\n        s=3.;\n        for(int j=0;j++<8;)\n            p=clamp(p,-.5,.5)*2.-p,\n            s*=e=7.*clamp(.3/min(dot(p,p),1.),.0,1.),\n            p*=e;\n        g+=e=length(p)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftjXRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 609]], "test": "untested"}
{"id": "Nl2XzW", "name": "Witted-Tracing", "author": "HigashiSan", "description": "A ray tracing programe, use witted style method.", "tags": ["3d", "raytrcing"], "likes": 1, "viewed": 541, "published": 3, "date": "1627210812", "time_retrieved": "2024-07-30T19:09:28.118787", "image_code": "const float PI = 3.1415926536;\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.3, 0.6 );\n\n// Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * PI / 180.0;\n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n// Constants for the scene objects.\nconst int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 8;\nconst int NUM_PLANES = 2;\nconst int NUM_SPHERES = 18;\n\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID_1;\n    int materialID_2;\n    int type; //1 is for grid,2 is for normal plane\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n};\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\n\n\n\nfloat height(float time,float h,float arg){\n\n    return abs(h*sin(arg*time)/time);\n}\n\nfloat x_loc(float angle,float time){\n    return 2.*cos(angle)*time;\n}\n\nfloat z_loc(float angle,float time){\n    return 2.*sin(angle)*time;\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n{\n    // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].type = 1;\n    Plane[0].materialID_1 = 6;\n    Plane[0].materialID_2 = 0;\n    \n    Plane[1].A = 0.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 1.0;\n    Plane[1].D = 3.5;\n    Plane[1].materialID_1 = 3;\n    Plane[1].type = 2;\n\n    // Center bouncing sphere.\n    \n    float time = mod(iTime,5.);\n    \n    \n    Sphere[0].center = vec3( 3.0+x_loc(45.,time),  height(time,5.,7.) + 0.7, 0.0+z_loc(45.,time ) );\n    Sphere[0].radius = 0.7;\n    Sphere[0].materialID = 7;\n\n    Sphere[1].center = vec3( 2.0+x_loc(30.,time),  height(time,5.,5.5) + 0.2, -8.0+z_loc(30.,time) );\n    Sphere[1].radius = 0.5;\n    Sphere[1].materialID = 7;\n    \n    Sphere[2].center = vec3( 3.0+x_loc(15.,time),  height(time,5.,4.5) + 0.2, -3.0+z_loc(15.,time) );\n    Sphere[2].radius = 0.4;\n    Sphere[2].materialID = 5;\n    \n    Sphere[3].center = vec3( 5.0+x_loc(60.,time),  height(time,4.,7.5) + 0.7, -9.0+z_loc(60.,time) );\n    Sphere[3].radius = 0.7;\n    Sphere[3].materialID = 6;\n    \n    Sphere[4].center = vec3( -2.0+x_loc(-45.,time),  height(time,5.,5.5) + 0.7, 2.0+z_loc(-45.,time) );\n    Sphere[4].radius = 0.7;\n    Sphere[4].materialID = 3;\n    \n    Sphere[5].center = vec3( -3.5+x_loc(-60.,time),  height(time,5.,7.5) + 0.6, 1.0+z_loc(-60.,time) );\n    Sphere[5].radius = 0.6;\n    Sphere[5].materialID = 4;\n    \n    Sphere[6].center = vec3( -3.5+x_loc(-15.,time),  height(time,5.,6.)+ 0.6, 6.0+z_loc(-15.,time) );\n    Sphere[6].radius = 0.6;\n    Sphere[6].materialID = 2;\n    \n    Sphere[7].center = vec3( -5.5+x_loc(-45.,time),  height(time,5.,7.) + 0.4, 3.0+z_loc(-45.,time) );\n    Sphere[7].radius = 0.4;\n    Sphere[7].materialID = 3;\n    \n    Sphere[8].center = vec3( 4.5+x_loc(75.,time),  height(time,5.,4.5) + 0.45, 1.5 +z_loc(75.,time));\n    Sphere[8].radius = 0.45;\n    Sphere[8].materialID = 1;\n    \n    Sphere[9].center = vec3( -2.5+x_loc(-35.,time),  height(time,5.,5.) + 0.3, 4.2 +z_loc(-35.,time));\n    Sphere[9].radius = 0.3;\n    Sphere[9].materialID = 5;\n    \n    Sphere[10].center = vec3( 1.0+x_loc(15.,time),  height(time,5.,3.) + 0.5, 3.5 +z_loc(15.,time));\n    Sphere[10].radius = 0.5;\n    Sphere[10].materialID = 5;\n    \n    Sphere[11].center = vec3( -3.5+x_loc(-80.,time),  height(time,5.,4.) + 0.6, 1.0+z_loc(-80.,time) );\n    Sphere[11].radius = 0.6;\n    Sphere[11].materialID = 3;\n    \n    Sphere[12].center = vec3( 11.0+x_loc(-35.,time),  height(time,5.,4.5) + 0.8, 5.5+z_loc(-35.,time) );\n    Sphere[12].radius = 0.8;\n    Sphere[12].materialID = 4;\n    \n    Sphere[13].center = vec3( -3.5+x_loc(-55.,time),  height(time,5.,3.)+ 0.8, -4.5+z_loc(-55.,time) );\n    Sphere[13].radius = 0.8;\n    Sphere[13].materialID = 4;\n    \n    Sphere[14].center = vec3( 0.5+x_loc(25.,time),  height(time,5.,6.) + 0.3, 7.5+z_loc(25.,time) );\n    Sphere[14].radius = 0.3;\n    Sphere[14].materialID = 2;\n    \n    Sphere[15].center = vec3( 2.5+x_loc(25.,time),  height(time,5.,4.) + 0.4, 1.5+z_loc(25.,time) );\n    Sphere[15].radius = 0.4;\n    Sphere[15].materialID = 4;\n    \n    Sphere[16].center = vec3( 3.5+x_loc(55.,time),  height(time,5.,5.5) + 0.35, 2.5+z_loc(55.,time) );\n    Sphere[16].radius = 0.35;\n    Sphere[16].materialID = 6;\n    \n    Sphere[17].center = vec3( 0.5+x_loc(5.,time),  height(time,5.,5.5) + 0.6, -4.5+z_loc(5.,time) );\n    Sphere[17].radius = 0.6;\n    Sphere[17].materialID = 2;\n\n\n    // Silver material.\n    Material[0].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n\n    // Gold material.\n    Material[1].k_d = vec3( 0.8, 0.7, 0.1 );\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 2.0 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 64.0;\n\n    // Green plastic material.\n    Material[2].k_d = vec3( 0.4, 0.8, 0.2 );\n    Material[2].k_a = 0.3 * Material[2].k_d;\n    Material[2].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[2].k_rg = 0.4 * Material[2].k_r;\n    Material[2].n = 128.0;\n    \n    //Copper material\n    Material[3].k_d = vec3( 0.780392, 0.568627, 0.113725 );\n    Material[3].k_a = vec3( 0.329412, 0.223529, 0.027451 );\n    Material[3].k_r = vec3( 0.992157, 0.941176, 0.807843 );\n    Material[3].k_rg = 0.4 * Material[3].k_r;\n    Material[3].n = 27.0;\n    \n    //Red diomand\n    Material[4].k_d = vec3( 0.614240, 0.041360, 0.041360 );\n    Material[4].k_a = vec3( 0.174500, 0.011750, 0.011750 );\n    Material[4].k_r = vec3( 0.727811, 0.626959, 0.626959 );\n    Material[4].k_rg = vec3( 0.550000, 0.550000, 0.550000);\n    Material[4].n = 128.0;\n    \n    //pearl\n    Material[5].k_d = vec3( 1.000000, 0.829000, 0.829000 );\n    Material[5].k_a = vec3( 0.250000, 0.207250, 0.207250 );\n    Material[5].k_r = vec3( 0.296648, 0.296648, 0.296648 );\n    Material[5].k_rg = 0.4 * Material[5].k_r;\n    Material[5].n = 128.0;\n    \n    //Bronze\n    Material[6].k_d = vec3( 0.714000, 0.428400, 0.181440 );\n    Material[6].k_a = vec3( 0.212500, 0.127500, 0.054000 );\n    Material[6].k_r = vec3( 0.393548, 0.271906, 0.166721 );\n    Material[6].k_rg = 0.4 * Material[6].k_r;\n    Material[6].n = 128.0;\n    \n    //violet\n    Material[7].k_d = vec3( 0.430000, 0.470000, 0.540000 );\n    Material[7].k_a = vec3( 0.110000, 0.060000, 0.090000 );\n    Material[7].k_r = vec3( 0.330000, 0.330000, 0.520000 );\n    Material[7].k_rg = 0.4 * Material[7].k_r;\n    Material[7].n = 128.0;\n\n    // Light 0.\n    Light[0].position = vec3( 15.0, 8.0, -3.0 );\n    Light[0].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[0].I_source = vec3( 1.0, 1.0, 1.0 );\n\n    // Light 1.\n    Light[1].position = vec3( -10.0 + 30.0 * sin(iTime / 3.0), 8.0, 0.0 );\n    Light[1].I_a = vec3( 0.1 + sin(iTime), 0.1, 0.1);\n    Light[1].I_source = vec3( 1.0, 1.0, 1.0 );\n    \n}\n\n\n\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n   \n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    // (p.x-sph.center.x)^2 + (p.y-sph.center.y)^2 + (p.z-sph.center.z)^2=sph.radius^2\n    float t1,t2;\n    float a = dot(ray.d,ray.d);\n    float b = 2.0 * dot(ray.o - sph.center, ray.d);\n    float c = dot(ray.o - sph.center, ray.o - sph.center) - sph.radius * sph.radius;\n\n    if((b * b - 4.0 * a * c)<0.0) return false;\n\n    t1 = (-b - sqrt(b * b - 4. * a * c)) / (2. * a);\n    t2 = (-b + sqrt(b * b - 4. * a * c)) / (2. * a);\n\n    if(t1 < tmin || t2 > tmax) return false;\n   \n    t = t1;\n    hitPos = ray.o + t * ray.d;\n    hitNormal = normalize(ray.o - sph.center + t * ray.d);\n    return true;  \n}\n\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    float t1,t2;\n    float a = dot(ray.d,ray.d);\n    float b = 2.0 * dot(ray.o - sph.center, ray.d);\n    float c = dot(ray.o - sph.center, ray.o - sph.center) - sph.radius * sph.radius;\n    if((b * b - 4.0 * a * c)<0.0) return false;\n\n    t1 = (-b - sqrt(b * b - 4.0 * a * c)) / 2.0 * a;\n    t2 = (-b + sqrt(b * b - 4.0 * a * c)) / 2.0 * a;\n\n    if(t1 < tmin || t2 > tmax) return false;\n\n    return true; \n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a +\n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\nvec3 CastRay( in Ray_t ray,\n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg )\n{\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    for(int i =0;i<NUM_PLANES;++i){\n        if(IntersectPlane(Plane[i],ray,DEFAULT_TMIN,DEFAULT_TMAX))\n        {\n            IntersectPlane(Plane[i],ray,DEFAULT_TMIN,DEFAULT_TMAX,temp_t,temp_hitPos,temp_hitNormal);\n            if(temp_t < nearest_t)\n            {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                \n                if(Plane[i].type == 1){\n                    float tempX = mod(nearest_hitPos.x,5.)-2.5;\n                    float tempZ = mod(nearest_hitPos.z,5.)-2.5;\n                    if(tempX*tempZ<0.)\n                        nearest_hitMatID = Plane[i].materialID_1;\n                    else\n                        nearest_hitMatID = Plane[i].materialID_2;\n                }\n                else if(Plane[i].type == 2){\n                    nearest_hitMatID = Plane[i].materialID_1;\n                }\n            }\n            hasHitSomething = true;\n        }\n    }\n\n    for(int i =0;i<NUM_SPHERES;++i){\n        if(IntersectSphere(Sphere[i],ray,DEFAULT_TMIN,DEFAULT_TMAX))\n        {\n            IntersectSphere(Sphere[i],ray,DEFAULT_TMIN,DEFAULT_TMAX,temp_t,temp_hitPos,temp_hitNormal);\n            if(temp_t < nearest_t)\n            {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Sphere[i].materialID;\n            }\n            hasHitSomething = true;\n        }\n    }\n\n\n    /////////////////////////////////\n\n\n\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3( 0.0 );  \n\n    for(int i=0;i<NUM_LIGHTS;i++){\n        Ray_t shadowRay;\n        vec3 disToLight = nearest_hitPos - Light[i].position;\n        shadowRay.o = Light[i].position;\n        shadowRay.d = normalize(disToLight);\n\n        \n        temp_hasHit = false;\n        for(int j=0;j<NUM_SPHERES;++j){\n            if(temp_hasHit) break;\n            temp_hasHit = IntersectSphere(Sphere[j],shadowRay,DEFAULT_TMIN,length(disToLight)-DEFAULT_TMIN);\n        }\n        for(int j=0;j<NUM_PLANES;++j){\n            if(temp_hasHit) break;\n            temp_hasHit = IntersectPlane(Plane[j],shadowRay,DEFAULT_TMIN,length(disToLight)-DEFAULT_TMIN);\n        }\n        vec3 color = PhongLighting(-shadowRay.d,nearest_hitNormal,normalize(ray.o-nearest_hitPos),temp_hasHit,Material[nearest_hitMatID],Light[i]);\n        I_local += color;\n    }\n\n    /////////////////////////////////\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    I_local = clamp(I_local,vec3(0.,0.,0.) ,vec3(1.,1.,1.) );\n\n    return I_local;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    float addPos = sin(iTime);\n\n    // Position the camera.\n    vec3 cam_pos = vec3( 6.5 + addPos * 1.5, 3.0 , 14.5 + addPos * 1.5);\n    vec3 cam_lookat = vec3( 1.0, 1.0, 0.0 );\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ )\n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n\n    fragColor = vec4(I_result , 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2XzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1973, 1973, 2016, 2016, 2057], [2059, 2059, 2095, 2095, 2128], [2130, 2130, 2166, 2166, 2199], [2202, 2384, 2402, 2427, 8253], [8257, 8257, 8411, 8411, 8705], [8707, 8707, 8790, 8790, 9002], [9005, 9005, 9162, 9249, 9765], [9767, 9767, 9852, 9852, 10260], [10264, 10618, 10748, 10748, 11160], [11163, 11163, 11276, 11276, 14528], [14530, 14530, 14587, 14587, 16073]], "test": "untested"}
{"id": "Nl2XRW", "name": "Mandelbrot Normal mapping", "author": "milesWaugh", "description": "Drag the mouse cursor to change the position of the light source.", "tags": ["fractal", "mandelbrot", "normalmapping"], "likes": 14, "viewed": 453, "published": 3, "date": "1627193778", "time_retrieved": "2024-07-30T19:09:28.949565", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 k = texture(iChannel2, uv).rgb * 1.1;\n    fragColor = vec4(sqrt(k), 0.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define zoomMagnitude 0.0\n#define zoomRate      0.5\n\n//DAVE HOSKINS' HASH FUNCTIONS\n//https://www.shadertoy.com/view/4djSRW\n\nvec2 rnd23(vec3 p3){\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 off = rnd23(vec3(fragCoord, iTime)) - .5;\n    vec2 uv = (fragCoord + off - iResolution.xy * .5) / iResolution.y;\n    int i = 0;\n    vec2 z = uv * ((cos(iTime * zoomRate) + 1.) * zoomMagnitude + 0.09);\n    z -= vec2(.57, .58);\n    vec2 c = z;\n    for (i = 0; i < 1024; i++) {\n        z = vec2(z.x * z.x - z.y * z.y + c.x, 2. * z.x * z.y + c.y);\n        if (dot(z, z) > 4.) {\n            break;\n        }\n    }\n    float j = float(i);\n    float j2 = j - log2(log2(dot(z, z))) + 4.;\n    vec3 dat = vec3(j / 1024., j2 / 1024., 0.);\n    fragColor = vec4(dat, 1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "#define lightStrength 30.\n#define ambientLight  0.2\n\n#define pi  3.1415926535897932\n#define pi2 1.57079632679\n\nfloat tex(vec2 p){\n    return pow(texture(iChannel0, p / iResolution.xy).g, .1) * 20.;;\n}\n\nfloat tex2(vec2 p){\n    return pow(1. - texture(iChannel0, p / iResolution.xy).g, 2.);\n}\n\nfloat sm(float x, float a){ //Thingy I solved for integrating the lambert cosine thingy over a solid angle with angle measure a, since the sun has volume in the sky\n    x = acos(x);\n    return (sin(max(-pi2, min(x + a * .5, pi2))) - sin(max(-pi2, min(x - a * .5, pi2)))) / a;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 z = fragCoord;\n    vec2 muv = 3. * (iMouse.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec3 n = vec3(tex(z) - tex(z - vec2(5, 0)), tex(z) - tex(z - vec2(0, 5)), 0.025);\n    n = normalize(n);\n    vec2 z2 = (z - iResolution.xy * 0.5) / (.5 * iResolution.y);\n    float lambert = dot(n, normalize(vec3(muv.x - z2.x, muv.y - z2.y, 1.)));\n    vec2 off = muv - z2;\n    lambert = max(sm(lambert, 0.1), 0.1) / (dot(off, off) * 2. + .1 + tex(z) * 5. - 60.);\n    vec3 col = lambert * vec3(1., 0.5, 0.65) * lightStrength + ambientLight * vec3(0.1, 0.5, 1.) * pow(tex2(z), 5.) * (max(dot(n, vec3(0., 0., 1.) * 2.), 0.) + .1);\n    fragColor = vec4(col, 1.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define sampleReprojectionCompensation 0.0\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord / iResolution.xy;\n    float k = texture(iChannel0, uv).r*2.;\n    vec3 k2 = texture(iChannel1, uv).rgb;\n    k2 = max(k2, 1e-6);\n    float j = round(k * 512.);\n    float o1 = (fract(j/3.) + 0.25) / (cos(500. * k)*5. + 5.);\n    float o2 = (fract(j/3.) + 0.25) / (cos(80.  * k)*5. + 5.);\n    float o3 = (fract(j/3.) + 0.25) / (cos(50.  * k)*5. + 5.);\n    vec3 col = vec3(o1, o2, o3);\n    col = (col*27. + (o1 + o2 + o3)) / 30.;\n    col = 1. - 1. / (1. + k2 * k2 * max(min(col, 1.), 0.));\n    col = clamp(col, 0., 1.);\n    col *= 1.5;\n    float zch = -sin(iTime*.5)*sampleReprojectionCompensation; //Derivative of zoom function lets us predict how to reproject samples\n    uv -= 0.5;\n    uv *= 1. + zch;\n    uv += 0.5;\n    fragColor = vec4((texture(iChannel2, uv).rgb*15. + col)/16., 0.);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2XRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 180]], "test": "untested"}
{"id": "stBXzD", "name": "Fractal 67_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 3, "viewed": 291, "published": 3, "date": "1627189804", "time_retrieved": "2024-07-30T19:09:29.816248", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,a=normalize(vec3(1,2,3)),\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=.8;\n        ++i<100.;\n        O.xyz+=mix(vec3(1),H(cos(log(s)))*.5,.8)*.05*exp(-.5*e*i*i)\n    )\n    {\n        p=g*d;\n        p.z+=iTime*.5;\n        s=4.;\n        vec4 q=vec4(p,.05);\n        q.xyw=R(q.xyw,a,2.+iTime*.05);\n        q.xzw=R(q.xzw,a,.5+cos(iTime*.05));\n        q.zyw=R(q.zyw,a,1.+sin(iTime*.05));\n        \n        for(int i;i++<8;)\n            q=mod(q-1.,2.)-1.,\n            s*=e=1.2/dot(q,q)-.04,\n            q*=e;\n        g+=e=length(q-clamp(q,-.5,.5))/s+5e-4;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stBXzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 760]], "test": "untested"}
{"id": "7tSSRD", "name": "Fractal 66_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 5, "viewed": 243, "published": 3, "date": "1627176606", "time_retrieved": "2024-07-30T19:09:30.657000", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=.7;\n        ++i<160.;\n        O.xyz+=mix(vec3(1),H(cos(log(s)))*.5,.8)*.01*exp(-80.*e*i*i)\n    )\n    {\n        p=g*d;\n        p.z-=2.;\n        p=R(p,normalize(vec3(1,2,3)),iTime*.2);\n        s=3.;\n        vec4 q=vec4(p,tanh(sin(iTime*3.))*.2);\n        \n        for(int i;i++<8;)\n            q=mod(q-1.,2.)-1.,\n            s*=e=1.4/dot(q,q)-.03,\n            q*=e;\n        g+=e=length(q-clamp(q,-.7,.7))/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tSSRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 665]], "test": "untested"}
{"id": "flBSRW", "name": "Texture Shadow (reg self shadow)", "author": "intrakits", "description": "Trying to get a texture to render instead of a shadow on objects other than the shadow caster.", "tags": ["texture", "shadow"], "likes": 1, "viewed": 219, "published": 3, "date": "1627137412", "time_retrieved": "2024-07-30T19:09:31.437912", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST 0.01\n#define AA 1\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nvec2 rand2(vec2 p)\n{\n\tvec2 q = vec2(dot(p,vec2(127.1,311.7)), \n\t\tdot(p,vec2(269.5,183.3)));\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat rand(vec2 p)\n{\n\treturn fract(sin(dot(p,vec2(419.2,371.9))) * 833458.57832);\n}\n\nfloat iqnoise(in vec2 pos, float irregular, float smoothness)\n{\n\tvec2 cell = floor(pos);\n\tvec2 cellOffset = fract(pos);\n\n\tfloat sharpness = 1.0 + 63.0 * pow(1.0-smoothness, 4.0);\n\t\n\tfloat value = 0.0;\n\tfloat accum = 0.0;\n\t// Sample the surrounding cells, from -2 to +2\n\t// This is necessary for the smoothing as well as the irregular grid.\n\tfor(int x=-2; x<=2; x++ )\n\tfor(int y=-2; y<=2; y++ )\n\t{\n\t\tvec2 samplePos = vec2(float(y), float(x));\n\n  \t\t// Center of the cell is not at the center of the block for irregular noise.\n  \t\t// Note that all the coordinates are in \"block\"-space, 0 is the current block, 1 is one block further, etc\n\t\tvec2 center = rand2(cell + samplePos) * irregular;\n\t\tfloat centerDistance = length(samplePos - cellOffset + center);\n\n\t\t// High sharpness = Only extreme values = Hard borders = 64\n\t\t// Low sharpness = No extreme values = Soft borders = 1\n\t\tfloat sam = pow(1.0 - smoothstep(0.0, 1.414, centerDistance), sharpness);\n\n\t\t// A different \"color\" (shade of gray) for each cell\n\t\tfloat color = rand(cell + samplePos);\n\t\tvalue += color * sam;\n\t\taccum += sam;\n\t}\n\n\treturn value/accum;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    //line from a to b\n    vec3 ab = b-a;\n    \n    // line from p to a\n    vec3 ap = p-a;\n    \n    // as p approaches a, it will be 1\n    // as p approaches b it will b 0\n    float t = dot(ab,ap) / dot(ab,ab);\n    \n    // clamp values between 0 and 1\n    t= clamp(t,0.,1.);\n    \n    // center point of the capsule\n    // start at a (top of capsule)\n    // go towards b, t steps\n    vec3 c = a + t*ab;\n    \n    float d = length(p-c)-r;\n    \n    return d;\n}\n\nfloat sdTorus(vec3 p, vec2 r){\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.));\n}\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n  p = abs(p);\n  vec2 b = vec2(la,lb);\n  float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n  vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\nvec2 colMin(vec2 res, vec2 obj){\n    res.x = min(obj.x,res.x);\n    if(obj.x == res.x){\n        res.y = obj.y;\n    }\n    return res;\n}\n// https://iquilezles.org/articles/smin\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\nfloat getDisp(vec2 uv){\n\n    vec2 p = 0.5 - 0.5*sin(vec2(1.01,1.71) );\n    p = vec2(1.0, 1.0);\n\t\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\t\n\tfloat f = iqnoise(24.0*uv, p.x, p.y);\n\t\n\treturn f;\n}\nvec2 GetDist(vec3 p){\n    vec2 res = vec2(p.y+.3,1.);\n    vec2 sphere = vec2(length(p-vec3(0,1,-2))-.4,2.);\n    res = colMin(res, sphere);\n    return res;\n}\nvec2 RayMarch(vec3 ro, vec3 rd){\n    // distance from origin\n    vec2 dO=vec2(0.,0.);\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO.x*rd;\n        \n        // get distance to seam\n        vec2 ds = GetDist(p);\n        //move origin to new point\n        dO+=ds.x;\n        if(ds.x < SURFACE_DIST){\n            dO.y = ds.y;\n            break;\n        }\n        else if( dO.x > MAX_DIST){\n            dO.y= -1.;\n            break;\n        }\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    //distance to point being analyzed\n    float d = GetDist(p).x;\n    \n    //distance to another point along the objects surface that is closeby\n    vec2 e = vec2(0.01,0);\n    \n    //slope between the two points\n    //note: swizzel is the .xxy or .yyx etc\n    vec3 n = d - vec3(\n         GetDist(p-e.xyy).x,\n         GetDist(p-e.yxy).x,\n         GetDist(p-e.yyx).x);\n         \n    return normalize(n);\n    \n}\nfloat GetLight(vec3 p){\n    //position of the light source\n    vec3 lightPos = vec3(0,5,-6);\n    \n    lightPos.xz += vec2(sin(iTime),cos(iTime));\n    //light vector\n    vec3 l = normalize(lightPos-p);\n    \n    //normal of object\n    vec3 n = GetNormal(p);\n    \n    // dot product of the light vector and normal of the point\n    // will give us the amount of lighting to apply to the point\n    // dot() evaluates to values between -1 and 1, so we will clamp it\n    float diff = clamp(dot(n, l),0.,1.);\n    \n    // calculate if point should be a shadow:\n    // raymarch from point being calculated towards light source\n    // if hits surface of something else before the light,\n    // then it must be obstructed and thus is a shadow\n    // the slight offset \"p+n*SURFACE_DIST*1.1\" is needed to ensure the\n    // break condistions in the function are not met too early\n    float d = RayMarch(p+n*SURFACE_DIST*1.1,l).x;\n    if(d < length(lightPos-p)){\n        diff *= .1;\n    }\n    \n    return diff;\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n   \n    \n    //camera\n    //-----------------\n    // ray origin\n    //controls position\n    vec3 ta = vec3( 0, 0., -3);\n    vec3 ro = ta + vec3( 4.5, 4.3, 4.5);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n//    vec3 ro = vec3(0,3,-5);\n\n    \n    //ray dir\n    //controls rotation\n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 pt = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 pt = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n    vec3 rd = ca * normalize( vec3(pt,2.5) );\n    //------------------\n    vec2 d = RayMarch(ro,rd);\n    \n    // position of point\n    // start at ray origin\n    // move d units in the ray direction\n    vec3 p = ro + rd *d.x;\n    \n    //get diffuse lighting\n    float diff = GetLight(p);\n    vec3 col = vec3(0);\n    col = vec3(diff);\n    \n    vec3 n = GetNormal(p);\n    \n    if(d.y == 1.){\n        col *= vec3(1,0,0);\n        vec3 colXZ = texture(iChannel0, p.xz*.5+.5).rgb;\n    vec3 colXY = texture(iChannel0, p.xy*.5+.5).rgb;\n    vec3 colYZ = texture(iChannel0, p.yz*.5+.5).rgb;\n    vec3 shadow = colXZ*abs(n.y) + colXY*abs(n.z) + colYZ*abs(n.x);\n    col = max(smoothstep(.5,.1,diff)*shadow,col);\n    }\n    else if(d.y==2.){\n       col *= vec3(0,1,0);\n    }\n    else if(d.y==3.){\n        col=vec3(1,0,0);\n    }\n    else if(d.y==4.){\n      //  col*=decCol(p, n, rd)*vec3(1,1,0);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flBSRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 112, 112, 140], [142, 142, 162, 162, 269], [271, 271, 291, 291, 354], [356, 356, 419, 419, 1469], [1471, 1471, 1490, 1490, 1552], [1553, 1553, 1604, 1604, 1888], [1890, 1890, 1939, 1962, 2395], [2397, 2397, 2427, 2427, 2498], [2500, 2500, 2527, 2527, 2566], [2567, 2567, 2631, 2631, 2882], [2883, 2883, 2915, 2915, 3016], [3017, 3057, 3095, 3095, 3192], [3194, 3234, 3275, 3275, 3347], [3348, 3348, 3406, 3406, 3507], [3508, 3508, 3531, 3531, 3726], [3727, 3727, 3748, 3748, 3883], [3884, 3884, 3916, 3944, 4454], [4455, 4455, 4478, 4517, 4888], [4889, 4889, 4912, 4947, 5886], [5887, 5887, 5939, 5939, 6116]], "test": "untested"}
{"id": "7tjXR1", "name": "Nether Portal attempt", "author": "Tater", "description": "eh, I tried. ", "tags": ["2d", "minecraft"], "likes": 16, "viewed": 718, "published": 3, "date": "1627124204", "time_retrieved": "2024-07-30T19:09:32.200872", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pmod(p,x) (mod(p,x)-0.5*(x))\nfloat rand(float a){\n    return fract(sin(a*3.0)*944.33)-0.5;\n}\nvec4 render( in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    float t = floor(iTime*30.0)/30.0;\n    //uv = floor(uv*60.0)/60.0;\n    \n    uv.y+=1.0;\n    vec3 purple = vec3(0.271,0.004,0.710);\n    vec3 col = purple;\n    //col = vec3(0);\n    float th = atan(uv.y,uv.x);\n    \n    //col+=sin(th*3.0)*0.5+0.5;\n    //col*=purple;\n    vec2 uv2 = uv+1.0;\n    vec2 uv3 = uv;\n    float aaaa = 0.1;\n    uv*=10.0;\n    uv = pmod(uv,4.0);\n    uv*=rot(t*3.5);\n    uv*=rot(-length(uv*5.0));\n    \n    col+=purple*smoothstep(uv.y-0.1,uv.y+0.4,0.1)*0.5 * step(length(uv),5.5) \n    * pow(clamp((2.5-length(uv)),0.0,1.0),6.0) ;\n\n    col+=0.45*smoothstep(uv.y-0.1,uv.y+0.1,-0.5)*0.9 * step(length(uv),5.5) \n    * max(0.0,(1.4-length(uv))) ;\n    uv = uv2;\n    \n    uv*=10.0;\n    uv = pmod(uv,4.0);\n    uv*=rot(-t*3.5);\n    uv*=rot(length(uv*5.0));\n    \n    col+=purple*smoothstep(uv.y-0.1,uv.y+0.4,0.1)*0.5 * step(length(uv),5.5) \n    * pow(clamp((2.5-length(uv)),0.0,1.0),6.0) ;\n    \n    \n    col+=0.45*smoothstep(uv.y-0.1,uv.y+0.1,-0.5)*0.9 * step(length(uv),5.5) \n    * max(0.0,(1.4-length(uv))) ;\n    \n    \n    col*=step(abs(uv3.x),0.365);\n    col*=1.0+rand(col.x)*0.1+rand(col.y)*0.05;\n    \n    return vec4(col,1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec4 col = vec4(0);\nfloat pixel = (iResolution.y/450.0)*8.0;\nfragCoord = floor(fragCoord/pixel)*pixel;\nfloat scale = 1.0/5.0;\n\ncol =render(fragCoord)*scale;\nfragCoord.x+=8.0;\ncol+=render(fragCoord)*scale;\nfragCoord.x-=8.0;\ncol+=render(fragCoord)*scale;\nfragCoord.y+=8.0;\ncol+=render(fragCoord)*scale;\nfragCoord.y-=8.0;\ncol+=render(fragCoord)*scale;\n\nfragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tjXR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 107, 107, 150], [151, 151, 185, 185, 1387], [1388, 1388, 1445, 1445, 1820]], "test": "untested"}
{"id": "7tjXzh", "name": "Roblox sdf with color", "author": "bulieme", "description": "thanks to IDGAMER89 for the roblox character.", "tags": ["raymarcher", "roblox"], "likes": 1, "viewed": 416, "published": 3, "date": "1627112423", "time_retrieved": "2024-07-30T19:09:33.058579", "image_code": "#define deg2rad (3.141/360.)\n#define MAX_STEPS 1024\n#define MAX_DIST 1e5\n#define SURF_DIST 1e-4\n\nfloat roundedCubeSDF(vec3 p, vec3 s, float r) {\n    vec3 q = abs(p) - s;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0)-r;\n}\n\nfloat roundedCylinderSDF( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nvec2 characterSDF(vec3 p){\n    int mat;\n    p.y -= 3.9;\n\tfloat head = roundedCylinderSDF(p, 0.3, 0.3, .3);//Head\n\tfloat body = roundedCubeSDF(p-vec3(0,-1.6,0), vec3(1,1,.5), .05);//Body\n    \n\tfloat l_arm = roundedCubeSDF(p-vec3(1.6,-1.6,0), vec3(0.5,1,.5), .05);//left arm\n\tfloat r_arm = roundedCubeSDF(p-vec3(-1.6,-1.6,0), vec3(0.5,1,.5), .05);//right arm\n    float arm = min(l_arm, r_arm);\n\n    float l_leg = roundedCubeSDF(p-vec3(0.51,-3.7,0), vec3(0.46,1,.5), .05);//left leg\n\tfloat r_leg = roundedCubeSDF(p-vec3(-0.51,-3.7,0), vec3(0.46,1,.5), .05);//right leg\n    float leg = min(l_leg, r_leg);\n    \n    body = min(body, arm);\n    body = min(body, leg);\n    \n    float d = min(head, body);\n    \n    if(d == head){\n        mat = 1;\n    }if(d == body){\n        mat = 2;\n    }if(body == arm){\n        mat = 1;\n    }if( d == leg){\n        mat = 3;\n    }\n    \n    \n\treturn vec2(d, mat);\n}\n\nvec2 scene(vec3 p){\n    int mat;\n    float ground = p.y+1.0;\n\tfloat d = ground;\n    vec2 character = characterSDF(p);\n    d = min(d, character.x);\n    if(d == character.x){\n        mat = int(character.y);\n    }if(d == ground){\n        mat = 4;\n    }\n\t\n\treturn vec2(d, mat);\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(SURF_DIST, 0.0);\n\n    return normalize(\n        scene(p).x - vec3(\n            scene(p - e.xyy).x,\n            scene(p - e.yxy).x,\n            scene(p - e.yyx).x\n        )\n    );\n}\n\nfloat AO(vec3 p) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    vec3 nor = GetNormal(p);\n    for(int i = 0; i < 5; i++) {\n        float h = 0.001 + 0.15*float(i)/4.0;\n        float d = scene(p + h*nor).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        float dS = scene(ro + rd * dO).x;\n        dO += dS;\n        if(dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    return dO;\n}\n\nmat3 rot(vec3 ang) {\n    vec3 s = sin(ang);\n    vec3 c = cos(ang);\n    mat3 x = mat3(\n        vec3(1, 0, 0),\n        vec3(0, c.x,-s.x),\n        vec3(0, s.x, c.x)\n    );\n    mat3 y = mat3(\n        vec3(c.y, 0, s.y),\n        vec3(0, 1, 0),\n        vec3(-s.y, 0, c.y)\n    );\n    mat3 z = mat3(\n        vec3(c.z, s.z, 0),\n        vec3(-s.z, c.z, 0),\n        vec3(0, 0, 1)\n    );\n    return x*y*z;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord.xy-0.5*iResolution.xy)/max(iResolution.x, iResolution.y)*2.;\n\tvec3 ro = vec3(0, 2, -6);\n    vec3 rd = normalize(vec3(uv, 75.*deg2rad));\n\n    vec2 t = (iMouse.xy-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n    t *= 4.0;\n    vec2 mouse_rotation = t*2.;\n    if(length(iMouse.xy) < 1e-3) mouse_rotation = vec2(0);\n\n    vec2 yawpitch = vec2(mouse_rotation.x, -mouse_rotation.y);\n    mat3 viewmat = rot(vec3(yawpitch.y, yawpitch.x, 0));\n\n    ro *= viewmat;\n    rd *= viewmat;\n    \n    vec3 skin = vec3(0.945,0.914,0.686);\n    vec3 tshirt = vec3(0.753,0.000,0.000);\n    vec3 pant = vec3(0.149,0.149,0.149);\n\n    float d = RayMarch(ro, rd);\n    vec3 p = ro + rd * d;\n    vec3 col = vec3(0);\n\n    if(d < MAX_DIST){\n        int mat = int(scene(p).y);\n    \tvec3 lp = normalize(vec3(0,10,-3));\n    \tvec3 n = GetNormal(p);\n\t\tcol = vec3(smoothstep(-0.2,1.,dot(n, lp)));\n        float s = RayMarch(p+n*SURF_DIST*2.0, lp);\n        col *= AO(p); \n\t\tif(s < 5.) col *= vec3(.5);\n        if(mat == 1){\n            col *= skin;\n        }if(mat == 2){\n            col *= tshirt;\n        }if(mat == 3){\n            col *= pant;\n        }if(mat == 4){\n            col *= vec3(0.580,1.000,0.608);;\n        }\n        col += vec3(0.110,0.596,0.898)*.1;\n    }else{\n        col = vec3(0.110,0.596,0.898);\n    }\n    \n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tjXzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 144, 144, 241], [243, 243, 308, 308, 425], [427, 427, 453, 453, 1316], [1318, 1318, 1337, 1337, 1593], [1595, 1595, 1619, 1619, 1818], [1820, 1820, 1838, 1838, 2122], [2124, 2124, 2158, 2158, 2353], [2355, 2355, 2375, 2375, 2749], [2752, 2752, 2807, 2807, 4162]], "test": "untested"}
{"id": "fl2Xzh", "name": "Texture Shadow", "author": "intrakits", "description": "This is an experiment to project a texture onto where a shadow would normally go.", "tags": ["textureshadow"], "likes": 1, "viewed": 220, "published": 3, "date": "1627081543", "time_retrieved": "2024-07-30T19:09:33.830515", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST 0.01\n#define AA 1\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nvec2 rand2(vec2 p)\n{\n\tvec2 q = vec2(dot(p,vec2(127.1,311.7)), \n\t\tdot(p,vec2(269.5,183.3)));\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat rand(vec2 p)\n{\n\treturn fract(sin(dot(p,vec2(419.2,371.9))) * 833458.57832);\n}\n\nfloat iqnoise(in vec2 pos, float irregular, float smoothness)\n{\n\tvec2 cell = floor(pos);\n\tvec2 cellOffset = fract(pos);\n\n\tfloat sharpness = 1.0 + 63.0 * pow(1.0-smoothness, 4.0);\n\t\n\tfloat value = 0.0;\n\tfloat accum = 0.0;\n\t// Sample the surrounding cells, from -2 to +2\n\t// This is necessary for the smoothing as well as the irregular grid.\n\tfor(int x=-2; x<=2; x++ )\n\tfor(int y=-2; y<=2; y++ )\n\t{\n\t\tvec2 samplePos = vec2(float(y), float(x));\n\n  \t\t// Center of the cell is not at the center of the block for irregular noise.\n  \t\t// Note that all the coordinates are in \"block\"-space, 0 is the current block, 1 is one block further, etc\n\t\tvec2 center = rand2(cell + samplePos) * irregular;\n\t\tfloat centerDistance = length(samplePos - cellOffset + center);\n\n\t\t// High sharpness = Only extreme values = Hard borders = 64\n\t\t// Low sharpness = No extreme values = Soft borders = 1\n\t\tfloat sam = pow(1.0 - smoothstep(0.0, 1.414, centerDistance), sharpness);\n\n\t\t// A different \"color\" (shade of gray) for each cell\n\t\tfloat color = rand(cell + samplePos);\n\t\tvalue += color * sam;\n\t\taccum += sam;\n\t}\n\n\treturn value/accum;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    //line from a to b\n    vec3 ab = b-a;\n    \n    // line from p to a\n    vec3 ap = p-a;\n    \n    // as p approaches a, it will be 1\n    // as p approaches b it will b 0\n    float t = dot(ab,ap) / dot(ab,ab);\n    \n    // clamp values between 0 and 1\n    t= clamp(t,0.,1.);\n    \n    // center point of the capsule\n    // start at a (top of capsule)\n    // go towards b, t steps\n    vec3 c = a + t*ab;\n    \n    float d = length(p-c)-r;\n    \n    return d;\n}\n\nfloat sdTorus(vec3 p, vec2 r){\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.));\n}\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n  p = abs(p);\n  vec2 b = vec2(la,lb);\n  float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n  vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\nvec2 colMin(vec2 res, vec2 obj){\n    res.x = min(obj.x,res.x);\n    if(obj.x == res.x){\n        res.y = obj.y;\n    }\n    return res;\n}\n// https://iquilezles.org/articles/smin\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\nfloat getDisp(vec2 uv){\n\n    vec2 p = 0.5 - 0.5*sin(vec2(1.01,1.71) );\n    p = vec2(1.0, 1.0);\n\t\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\t\n\tfloat f = iqnoise(24.0*uv, p.x, p.y);\n\t\n\treturn f;\n}\nvec2 GetDist(vec3 p){\n    vec2 res = vec2(p.y+.3,1.);\n    vec2 sphere = vec2(length(p-vec3(0,1,-2))-.4,2.);\n    res = colMin(res, sphere);\n    return res;\n}\nvec2 RayMarch(vec3 ro, vec3 rd){\n    // distance from origin\n    vec2 dO=vec2(0.,0.);\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO.x*rd;\n        \n        // get distance to seam\n        vec2 ds = GetDist(p);\n        //move origin to new point\n        dO+=ds.x;\n        if(ds.x < SURFACE_DIST){\n            dO.y = ds.y;\n            break;\n        }\n        else if( dO.x > MAX_DIST){\n            dO.y= -1.;\n            break;\n        }\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    //distance to point being analyzed\n    float d = GetDist(p).x;\n    \n    //distance to another point along the objects surface that is closeby\n    vec2 e = vec2(0.01,0);\n    \n    //slope between the two points\n    //note: swizzel is the .xxy or .yyx etc\n    vec3 n = d - vec3(\n         GetDist(p-e.xyy).x,\n         GetDist(p-e.yxy).x,\n         GetDist(p-e.yyx).x);\n         \n    return normalize(n);\n    \n}\nfloat GetLight(vec3 p){\n    //position of the light source\n    vec3 lightPos = vec3(0,5,-6);\n    \n    lightPos.xz += vec2(sin(iTime),cos(iTime));\n    //light vector\n    vec3 l = normalize(lightPos-p);\n    \n    //normal of object\n    vec3 n = GetNormal(p);\n    \n    // dot product of the light vector and normal of the point\n    // will give us the amount of lighting to apply to the point\n    // dot() evaluates to values between -1 and 1, so we will clamp it\n    float diff = clamp(dot(n, l),0.,1.);\n    \n    // calculate if point should be a shadow:\n    // raymarch from point being calculated towards light source\n    // if hits surface of something else before the light,\n    // then it must be obstructed and thus is a shadow\n    // the slight offset \"p+n*SURFACE_DIST*1.1\" is needed to ensure the\n    // break condistions in the function are not met too early\n    float d = RayMarch(p+n*SURFACE_DIST*1.1,l).x;\n    if(d < length(lightPos-p)){\n        diff *= .1;\n    }\n    \n    return diff;\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n   \n    \n    //camera\n    //-----------------\n    // ray origin\n    //controls position\n    vec3 ta = vec3( 0, 0., -3);\n    vec3 ro = ta + vec3( 4.5, 4.3, 4.5);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n//    vec3 ro = vec3(0,3,-5);\n\n    \n    //ray dir\n    //controls rotation\n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 pt = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 pt = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n    vec3 rd = ca * normalize( vec3(pt,2.5) );\n    //------------------\n    vec2 d = RayMarch(ro,rd);\n    \n    // position of point\n    // start at ray origin\n    // move d units in the ray direction\n    vec3 p = ro + rd *d.x;\n    \n    //get diffuse lighting\n    float diff = GetLight(p);\n    vec3 col = vec3(0);\n    col = vec3(diff);\n    \n    vec3 n = GetNormal(p);\n    \n    if(d.y == 1.){\n        col *= vec3(1,0,0);\n    }\n    else if(d.y==2.){\n       col *= vec3(0,1,0);\n    }\n    else if(d.y==3.){\n        col=vec3(1,0,0);\n    }\n    else if(d.y==4.){\n      //  col*=decCol(p, n, rd)*vec3(1,1,0);\n    }\n    vec3 colXZ = texture(iChannel0, p.xz*.5+.5).rgb;\n    vec3 colXY = texture(iChannel0, p.xy*.5+.5).rgb;\n    vec3 colYZ = texture(iChannel0, p.yz*.5+.5).rgb;\n    vec3 shadow = colXZ*abs(n.y) + colXY*abs(n.z) + colYZ*abs(n.x);\n    col = max(smoothstep(.5,.1,diff)*shadow,col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl2Xzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 112, 112, 140], [142, 142, 162, 162, 269], [271, 271, 291, 291, 354], [356, 356, 419, 419, 1469], [1471, 1471, 1490, 1490, 1552], [1553, 1553, 1604, 1604, 1888], [1890, 1890, 1939, 1962, 2395], [2397, 2397, 2427, 2427, 2498], [2500, 2500, 2527, 2527, 2566], [2567, 2567, 2631, 2631, 2882], [2883, 2883, 2915, 2915, 3016], [3017, 3057, 3095, 3095, 3192], [3194, 3234, 3275, 3275, 3347], [3348, 3348, 3406, 3406, 3507], [3508, 3508, 3531, 3531, 3726], [3727, 3727, 3748, 3748, 3883], [3884, 3884, 3916, 3944, 4454], [4455, 4455, 4478, 4517, 4888], [4889, 4889, 4912, 4947, 5886], [5887, 5887, 5939, 5939, 6116]], "test": "untested"}
{"id": "flBGD3", "name": "Procedural Metal Texture", "author": "arthehaxxor", "description": "feel free to use  as texture or copy code\nset LIGHTING to true or false to  toggle lighting\nset COL to change tint of metal\nset SMUDGES to change intensity of imperfections\nset BRUSH to make the brushed finnish stand out more\nset OFFSET to change sample", "tags": ["noise", "metal"], "likes": 4, "viewed": 381, "published": 3, "date": "1627081098", "time_retrieved": "2024-07-30T19:09:34.594473", "image_code": "// tint of metal\n#define COL vec3(1, 0.85, 0.8)\n//whether or not to apply lighting\n#define LIGHTING false\n//intensity of smudges\n#define SMUDGES 0.05 \n//intensity of the brush\n#define BRUSH 0.2\n// offset of noise\n#define OFFSET 10.0\n\nvec4 gammaRamp(vec4 c) {\n    c.x=pow(c.x,2.2);\n    c.y=pow(c.y,2.2);\n    c.z=pow(c.z,2.2);\n    return c;\n}\n\n// copy from https://www.shadertoy.com/view/4l2GzW\nfloat r(float n)\n{\n \treturn fract(cos(n*89.42)*343.42);\n}\nvec2 r(vec2 n)\n{\n \treturn vec2(r(n.x*23.62-300.0+n.y*34.35),r(n.x*45.13+256.0+n.y*38.89)); \n}\nfloat worley(vec2 n,float s)\n{\n    float dis = 2.0;\n    for(int x = -1;x<=1;x++)\n    {\n        for(int y = -1;y<=1;y++)\n        {\n            vec2 p = floor(n/s)+vec2(x,y);\n            float d = length(r(p)+vec2(x,y)-fract(n/s));\n            if (dis>d)\n            {\n             \tdis = d;   \n            }\n        }\n    }\n    return 1.0 - dis;\n\t\n}\n\n// copy from https://www.shadertoy.com/view/4sc3z2\n\n#define MOD3 vec3(.1031,.11369,.13787)\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nfloat perlin_noise(vec3 p)\n{\n    p += OFFSET;\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n                \tmix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                       \tw.x),\n                \tmix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                       \tw.x),\n                \tw.z),\n        \t\tmix(\n                    mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                       \tw.x),\n                   \tmix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                       \tw.x),\n                \tw.z),\n    \t\t\tw.y);\n}\n\nfloat mixNoise (vec3 uv) {\n    float dis = (1.0+perlin_noise(vec3(uv.x, uv.y + perlin_noise(vec3(uv.x*10.0, 0, 0))*2.0,  uv.z)*8.0)) \n        * (1.0+(worley(uv.xy, 32.0)+\n        0.5*worley(2.0*uv.xy,32.0) +\n        0.25*worley(4.0*uv.xy,32.0) ));\n\n        return dis/4.0;\n}\n\nfloat mag (vec3 v) {\n    return sqrt((v*v).x + (v*v).y +(v*v).z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy/iResolution.xy;\n    float dis = mixNoise(vec3(vec2(p.x*100.0, p.y) ,0));\n    \n    float light = mixNoise(vec3(0, (p.x + p.y)*0.5 + iTime, 0))* 2.3;\n    if(!LIGHTING) light = 1.0;\n    vec3 col = vec3(dis*BRUSH+(1.0-BRUSH)) * COL;\n    float smudges = perlin_noise(vec3(p*20.0 + \n                    perlin_noise(vec3(p*30.0 +\n                    perlin_noise(vec3(p*40.0 + \n                    perlin_noise(vec3(p*50.0, 0)) , 0)), 0)) , 0))* SMUDGES;\n    fragColor = gammaRamp(vec4(mix(col, vec3(1.0 - mag(col) * light), smudges) * light,1.0));\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flBGD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[234, 234, 258, 258, 340], [342, 393, 411, 411, 450], [451, 451, 467, 467, 544], [545, 545, 575, 575, 893], [987, 987, 1009, 1009, 1161], [1162, 1162, 1190, 1190, 2146], [2148, 2148, 2174, 2174, 2422], [2424, 2424, 2444, 2444, 2491], [2493, 2493, 2550, 2550, 3125]], "test": "untested"}
{"id": "NtjXzh", "name": "Gyroidal Confusion [livecode]", "author": "Tater", "description": "aaaaaaaaa code messy, fun event. big thanks to Monsieur Soleil for organizing, I'll update with vod when available. \n\nthe fft on shadertoy is a bit messed up, sorry.", "tags": ["3d", "raymarching", "gyroid", "soundcloud", "twitch", "livecode", "shaderjam"], "likes": 5, "viewed": 346, "published": 3, "date": "1627080368", "time_retrieved": "2024-07-30T19:09:35.366409", "image_code": "\n#define STEPS 164.0\n#define MDIST 200.0\n#define time iTime\n#define pmod(p,x) (mod(p,x)-(x)*0.5)\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pi 3.1415926535\nfloat g1 = 0.0;\nfloat anim(){\n  return fract(time*0.15);\n}\nfloat smin(float a, float b, float k){\n  float h = max(0.0,k-abs(a-b));\n  return min(a,b)-h*h*0.25/k;\n}\n\nfloat smax(float a, float b, float k){\n  float h = max(0.0,k-abs(a-b));\n  return max(a,b)-h*h*0.25/k;\n}\n\nfloat gy(vec3 p){\n  return dot(sin(p.xyz),cos(p.yzx));\n}\nfloat box( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nvec2 map(vec3 p){\n  vec3 po = p;\n  float streamfft = 0.02;\n  float t = mod(time,300.0);\n  vec2 a = vec2(0);\n  vec2 b = vec2(1);\n  //bottom plane gyroid\n  \n  b.x = gy(p*2.0+(t*2.0+5.0*texelFetch( iChannel0, ivec2(64,0), 0 ).x*vec3(1,-1,0)));\n  b.x*=0.55;\n  //bottom plane\n  a.x = p.y+1.0-sin(p.x*2.5+t)*0.15-sin(p.z*2.5+t)*0.05;\n  \n  a.x = max(b.x,a.x);\n  \n  float voff = texelFetch( iChannel0, ivec2(16.0,0), 0 ).x*streamfft*1.5;\n  //voff=clamp(voff,0.0,12.0/800.0);\n  //ball gyriod\n  float ballsize = 2.5;\n  if(anim()>0.5){\n    //p.xz = pmod(p.xz,30.0);\n    ballsize = 3.0+voff*500.0;\n    \n  }\n  ballsize = clamp(ballsize,1.5,15.0);\n  b.x = abs(abs(gy(-p*3.0+t+8.0*streamfft*texelFetch( iChannel0, ivec2(64,0), 0 ).x))-0.6)-0.2;\n  b.x*=0.4;\n  //ball\n  \n  //p.y = pmod(p.y+sin(t)*3.0,10.0);\n  p.xz*=rot(t);\n  //p.yz*=rot(t);\n  float ballcut = box(p-vec3(0,1.0+voff*125.0,0),vec3(ballsize));\n  p = po;\n  ballcut = mix(ballcut, length(p-vec3(0,voff*125.0,0))-ballsize,sin(time*2.0)*0.5+0.5);\n  b.x = smax(b.x,ballcut,0.2);\n  p = po;\n  \n  a = (a.x<b.x)?a:b;\n  t*=0.5;\n  float tt = pow(fract(t),3.0)+floor(t);\n  \n  tt*=pi/2.0;\n  \n  b.y = 2.0;\n  p.xy*=rot(tt);\n  \n  float moddist = 20.0+voff*500.0;\n  p.xz = pmod(p.xz,moddist);\n  b.x = length(p.xz)-1.5-clamp(sin(p.y*1.5),0.0,0.2);\n  a = (a.x<b.x)?a:b;\n  p = po;\n  \n  p.xy*=rot(tt);\n  p.xy = pmod(p.xy,moddist);\n  b.x = length(p.xy)-1.5-clamp(sin(p.z*1.5),0.0,0.2);\n  a = (a.x<b.x)?a:b;\n  \n  p = po;\n  \n  p.xy*=rot(tt);\n  p.yz = pmod(p.yz,moddist);\n  b.x = length(p.yz)-1.5-clamp(sin(p.x*1.5),0.0,0.2);\n  a = (a.x<b.x)?a:b;\n  p = po;\n  t = iTime;\n  \n  p-=vec3(0,t*5.0,0);\n  p=pmod(p,23.0);\n  \n  b.x = length(p)-2.0;\n  g1+=0.01/(0.01+b.x*b.x);\n  a = (a.x<b.x)?a:b;\n  \n  \n  return a;\n}\nvec3 norm(vec3 p){\n  vec2 e = vec2(0.01,0.0);\n  return normalize(map(p).x - vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n  vec3 col= vec3(0.0);\n  float t = time;\n  vec3 ro = vec3(0,3,-17);\n  vec3 rd = normalize(vec3(uv,1.0));\n  if(anim()>0.5){\n    ro = vec3(0,100,0);\n    uv.xy*=rot(time);\n    rd = normalize(vec3(uv,1.0));\n    rd.yz*=rot(-pi/2.0);\n    \n  }\nelse{\n  rd.yz*=rot(-0.25);\n   ro.xz*=rot(t*0.4);\n  rd.xz*=rot(t*0.4);\n}\n\n  \n  \n \n  float shad,dO;\n  vec2 d;\n  vec3 p = ro;\n  bool hit = false;\n  for(float i = 0.0; i <STEPS; i++){\n    \n    p = ro+rd*dO;\n    d = map(p);\n    d.x = max(-(length(p-vec3(ro))-5.0),d.x);\n    dO+=d.x*.9;\n    \n    if(abs(d.x)<0.01){\n      shad = i/STEPS;\n      hit = true;\n      break;\n    }\n    if(dO>MDIST){\n      break;\n    }\n    if(i == STEPS-1.0){\n      hit = true;\n    }\n  }\n  vec3 al = vec3(0);\n  vec3 n = norm(p);\n  vec3 ld = normalize(vec3(1));\n  vec3 h = normalize(ld-rd);\n  float spec = pow(max(dot(n,h),0.0),20.0);\n  \n  \n  if(hit){\n    if(d.y == 0.0){\n      al = vec3(0.1,0.3,0.9);\n      col+=spec*0.2;\n      shad = 0.8-shad*4.0;\n    }\n    if(d.y == 1.0){\n      al = vec3(0.9,0.1,0.1);\n      col+=spec*0.3;\n      shad = 0.7-shad*4.0;\n    }\n    if(d.y == 2.0){\n      al = vec3(0.7,0.7,0.9)*0.6;\n      shad = 1.0-shad;\n     \n    }\n    \n  col += vec3(1.0-shad)*al;\n  \n  col = pow(col,vec3(0.8));\n     }\n  col+=g1*vec3(0.3,0.3,0.8)*0.3;\n  col = mix(clamp(col,0.0,1.0),vec3(0.4,0.0,0.0),(dO/MDIST));\n  //uv = vec2(gl_FragCoord.x / v2Resolution.x, gl_FragCoord.y / v2Resolution.y);\n  \n  //col+=texture(texPreviousFrame,uv*0.5+0.5).rgb*0.3;\n\tfragColor = vec4(col,0.0);\n}\n", "image_inputs": [{"id": 27856, "src": "https://soundcloud.com/surrealrecordings/jkuch-innocence", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtjXzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[187, 187, 200, 200, 229], [230, 230, 268, 268, 333], [335, 335, 373, 373, 438], [440, 440, 457, 457, 496], [497, 497, 525, 525, 612], [613, 613, 630, 630, 2341], [2342, 2342, 2360, 2360, 2474], [2475, 2475, 2532, 2532, 4155]], "test": "untested"}
{"id": "ftsXWs", "name": "Scrapyard", "author": "ruojake", "description": "Inspired by iq's article on SDF-based fBM (https://iquilezles.org/articles/fbmsdf/fbmsdf.htm), using cubes instead of spheres.", "tags": ["3d", "raymarching", "terrain", "fbm", "brdf"], "likes": 9, "viewed": 357, "published": 3, "date": "1627079459", "time_retrieved": "2024-07-30T19:09:36.131363", "image_code": "// Scrapyard by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\n// set to 1 if you dare - slows down to crawl on my GPU\n#define AA 0\n\n#define sat(x) clamp((x), 1., 0.)\n\nfloat hash(vec3 p)\n{\n    p = fract(p * 21.43125);\n    p += dot(p, p.zxy * 321.32136);\n    return fract(((p.x + p.z) * p.y)*10.);\n}\n\nmat2 rot(float a)\n{\n    float s = sin(a),\n          c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// smooth min(q<0)/max(q>=0)\nfloat sm(float a, float b, float q)\n{\n    float d = clamp((b - a) / q + .5, 0., 1.);\n    return mix(a,b,d) + .5 * q * d * (1. - d);\n}\n\nfloat elem(vec3 i, vec3 f, vec3 c)\n{\n    float h = hash(i+c) * .5;\n    vec3 p = f - c;\n    vec3 d = abs(p) - h;\n    return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, vec3(0.)));\n}\n\n\nfloat grid(vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = p - i;\n    const vec2 o = vec2(1,0);\n    \n    return min(\n        min(\n            min(elem(i, f, o.yyy), elem(i, f, o.yyx)),\n            min(elem(i, f, o.yxy), elem(i, f, o.yxx))\n        )\n        ,\n        min(\n            min(elem(i, f, o.xyy), elem(i, f, o.xyx)),\n            min(elem(i, f, o.xxy), elem(i, f, o.xxx))\n        )\n    );\n}\n\nvec2 scene(vec3 p, float th)\n{\n    float res = p.y;\n    if(p.y > .3) return vec2(res, 0);\n    if(p.y <= .015) return vec2(p.y - .015, 0);\n    float s = 1.;\n    const mat3 r = mat3(-.66, 1.51, -1.12,\n                        1.07, 1.28, 1.1,\n                        1.55, -.23, -1.23);\n    const float q = .4;\n\n    for(int i = 0; i < 8; i++)\n    {\n        float d = sm(s * grid(p), res - s*.1, q*s*s);\n        res = mix(sm(d, res, -q*s*s), res, clamp(th/s * 2. - 1.,0.,1.));\n        \n        p *= r;\n        s *= .5;\n\n        if(th > s) break;\n    }\n    return vec2(res, 1);\n}\n\nvec3 normal(vec3 p, float d, float th)\n{\n    vec2 e = vec2(.1 * th, 0);\n    return normalize(d - vec3(\n        scene(p - e.xyy, th).x,\n        scene(p - e.yxy, th).x,\n        scene(p - e.yyx, th).x));\n}\n\nvec3 sky(vec3 rd, vec3 ld, float k, float l)\n{\n    vec3 col = mix(vec3(.05, .2, .5), vec3(1., .97, .96), min(rd.y * .5 + .5, l));\n    float sun = sat(dot(rd, ld));\n    k = max(k, .0001);\n    col += l * pow(sat((sun - .9992 + k) / k), 5. / k) * (30. - 25. * k * (2. - k)) + sun * sun * vec3(1.,.9,.8) * (.25 + k);\n    return col;\n}\n\n// https://google.github.io/filament/Filament.md.html#table_texturedfg\nvec3 DFGAppr(vec3 f0, float ndv, float roughness)\n{\n    vec4 c0 = vec4(-1., -.0275, -.572, .022);\n    vec4 c1 = vec4(1., .0425, 1.04, -.04);\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * ndv)) * r.x + r.y;\n    vec2 ab = vec2(-1.04, 1.04) * a004 + r.zw;\n    return f0 * ab.x + ab.y;\n}\n\nfloat shadow(vec3 ro, vec3 rd, float maxDist, float k)\n{\n    float res = 1.;\n    float d = 0.;\n    float t = .01;\n    for(int i = 0; i < 30; ++i)\n    {\n        d = scene(ro + rd * t, .01).x * 2.;\n        res = min(res, k * d / t);\n        t += d;\n    \tif(abs(d) < .0001 || t >= maxDist)\n            break;\n        if (res < .001)\n        {\n        \tres = 0.;\n            break;\n        }\n    }\n    return res;\n}\n\nvec3 brdf(vec3 albedo, float metal, float roughness, vec3 rd, vec3 ld, vec3 n, float l)\n{\n    vec3 spec = sky(reflect(rd, n), ld, max(roughness, .0001), l);\n        \n    vec3 diff = albedo * sky(n, ld, 1., 1.) * metal;\n    vec3 f0 = max(albedo * (1. - metal), vec3(.04));\n    return mix(diff, spec, DFGAppr(f0, dot(-rd, n), roughness));\n}\n\nvec3 reinhard(vec3 c)\n{\n    float l0 = dot(c, vec3(.2126, .7152, .0722));\n    float l1 = l0 * (1. + l0 / 20.) / (1. + l0);\n    return c / l0 * l1;\n}\n\nvoid img( out vec4 fragColor, in vec2 uv )\n{  \n    vec3 rd = normalize(vec3(uv, 1.5));\n    mat2 camRot = rot(.3);\n    rd.yz *= camRot;\n    vec3 ro = vec3(uv * .02, 0);\n    ro.yz *= camRot;\n    ro += vec3(0,.5,iTime * .05);\n    vec3 p = ro;\n    float t = .01;\n    vec2 d = vec2(0);\n    float duv = length(fwidth(uv));\n    float th = 0.;\n    float i = 0.;\n    \n    for(;i < 1. && t < 25.; i += 1./128.)\n    {\n        p = ro + rd * t;\n        th = clamp(duv * 3. * t - duv, 0., 1.);\n        d = scene(p, th);\n        t += d.x + (.00025 * t) * sign(d.x);\n        if (abs(d.x)<.0005*t) break;\n    }\n\n    float ao = clamp(1.2 - i, 0., 1.);\n    \n    vec3 nml;\n    if (d.y == 0.)\n        nml = vec3(0,1,0);\n    else if (t < 25.)\n        nml = normal(p, d.x, th);\n    else \n        nml = vec3(0, -1, 0);\n        \n    vec3 lDir = normalize(vec3(2,1,-1));\n    float l = (dot(nml, lDir) * .5 + .5) * ao;\n    \n    vec3 shDir = d.y > 0. ? lDir : reflect(rd, nml);\n    l *= shadow(p + nml * .01, shDir, 1., 4.5 - d.y * 2.); \n    \n    vec3 col = vec3(0);\n    if (d.y == 1.)\n    {\n        col = brdf(vec3(.1), .99, .3, rd, lDir, nml, l) \n            * (.7 + .3 * l);\n    }\n    else if (rd.y <= 0.)\n    {\n        col = brdf(vec3(.3, .025, .005), .8, .001, rd, lDir, nml, min(l, 1. + rd.y));\n    }\n    else\n    {\n        col = sky(rd, lDir, .01, 1.);\n    }\n  \n    if (rd.y <= 0.)\n        col = mix(col, sky(rd, lDir, 1., 1.), clamp(t * .05 - .4, 0., 1.));\n\n    fragColor = vec4(col,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5)/iResolution.y;\n    img(fragColor, uv);\n    \n    #if AA\n    if (fwidth(fragColor.g) > .1)\n    {\n        fragColor *= 2.;\n        vec2 offs = vec2(.7 * abs(dFdy(uv.y)),0);\n        vec4 c;\n        mat2 r = mat2(-.5,-.866,.866,-.5);\n        for(int i = 0; i < 3; ++i)\n        {\n            img(c, uv + offs);\n            offs *= r;\n            fragColor += c; \n        }\n        fragColor *= .2;\n        //fragColor.rgb *= vec3(1,0,0);\n    }\n    #endif\n    \n    fragColor.rgb = reinhard(fragColor.rgb);\n    \n    fragColor.rgb = pow(fragColor.rgb, vec3(1./2.2));\n\n    fragColor.rgb += hash(vec3(fragCoord, iFrame)) * .01 - .005;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsXWs.jpg", "access": "api", "license": "cc-by-sa-4.0", "functions": [[215, 215, 235, 235, 345], [347, 347, 366, 366, 442], [444, 473, 510, 510, 606], [608, 608, 644, 644, 793], [796, 796, 816, 816, 1193], [1195, 1195, 1225, 1225, 1769], [1771, 1771, 1811, 1811, 1973], [1975, 1975, 2021, 2021, 2305], [2307, 2378, 2429, 2429, 2694], [2696, 2696, 2752, 2752, 3107], [3109, 3109, 3198, 3198, 3447], [3449, 3449, 3472, 3472, 3597], [3599, 3599, 3643, 3643, 5069], [5071, 5071, 5128, 5128, 5802]], "test": "untested"}
{"id": "fljXRh", "name": "Mandellake", "author": "Krischan", "description": "2D conversion of a *very* old source showing the mandelbrot fractal as a lake.", "tags": ["fractal", "mandelbrot", "lake"], "likes": 3, "viewed": 233, "published": 3, "date": "1627067432", "time_retrieved": "2024-07-30T19:09:36.901305", "image_code": "// 'Mandellake' by Krischan\n//\n// 2D conversion of a *very* old article in the magazine\n// Happy Computer, Edition 6/1987 by Frank Göldner\n// showing the mandelbrot fractal as a lake!\n//\n// Originally sources were available for the systems\n// C64, Schneider CPC, Atari ST and Amiga :)\n//\n\n#define roughness 0.066\n#define iterations 400\n#define waterlevel 1.2\n#define shorelevel 1.0\n#define offset vec2(-1.0,0.0)\n#define zoom 1.25\n\n#define WATERCOLOR vec4(0.0,0.5,0.8,1.0)\n#define SHORECOLOR vec4(0.3,0.5,0.3,1.0)\n#define GRASSCOLOR vec4(0.2,0.5,0.1,1.0)\n\nfloat mandellake(vec2 uv)\n{\n    \n    float z=2.0;\n    float xc=uv.x;\n    float yc=uv.y;\n    float xa=0.0;\n    float ya=0.0;\n\n    while(z>0.0)\n    {\n        float x2=abs(xa);\n        float y2=abs(ya);\n        float xn=x2-y2-xc;\n        ya=xa*ya;\n        ya=ya+ya-yc;\n        xa=xn;\n        z=z-roughness;\n        if(z<0.0){break;}\n        if(x2+y2>float(iterations)){break;}\n    }\n\n    return z;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy*2.0 - iResolution.xy) * 2.0/ iResolution.x;\n    \n    uv.x-=offset.x;\n    uv.y+=offset.y;\n    uv*=zoom;\n    \n    float r = mandellake(uv);\n    \n    fragColor=WATERCOLOR*vec4(1.0,r,1.0,1.0);\n    \n    if(r>shorelevel){fragColor = SHORECOLOR*vec4(vec3(r),1.0);}\n    if(r>waterlevel){fragColor = GRASSCOLOR*vec4(vec3(r),1.0);}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fljXRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[556, 556, 583, 583, 956], [958, 958, 1015, 1015, 1367]], "test": "untested"}
{"id": "7lSSRh", "name": "Microphone Spectrogram", "author": "pierstitus", "description": "as simple as possible", "tags": ["spectrogram"], "likes": 2, "viewed": 354, "published": 3, "date": "1627034876", "time_retrieved": "2024-07-30T19:09:37.668254", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize = 1. / iResolution.xy;\n    vec2 uv = fragCoord.xy * pixelSize;\n    \n    if(uv.x > 1. - pixelSize.x){\n    \tfragColor = texture(iChannel0, vec2(uv.y, 0.25));\n    }else{\n        fragColor = texture(iChannel1, uv + vec2(1,0) * pixelSize);\n    }\n}", "buffer_a_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lSSRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 138]], "test": "untested"}
{"id": "NlSXR1", "name": "Continuous Factorial (Alt.)", "author": "oneshade", "description": "Alternative approximation for both positive and negative values using Euler's reflection formula:\ngamma(x)gamma(1-x) = (x - 1)!(-x)! = pi/sin(pi*x)\nI think I have been incorrectly calling this gamma but the factorial is actually gamma(x-1).", "tags": ["approximation", "continuous", "factorial", "alternative", "specialfunction"], "likes": 5, "viewed": 187, "published": 3, "date": "1627018114", "time_retrieved": "2024-07-30T19:09:38.442185", "image_code": "// Using Euler's reflection formula to extend the approximation\n// here: https://www.shadertoy.com/view/stl3DS\n// to negative values. The advantage is that there aren't any loops\n// (at least explicit ones, there may be some iterative scheme in\n// the sqrt(), pow(), and sinh() functions).\n\n#define draw(d, c) color = mix(color, c, smoothstep(unit, 0.0, d))\n\nconst float e = 2.7182818284;\nconst float pi = 3.14159265359;\nconst float tau = 6.28318530718;\n\nfloat pfactorial(in float x) {\n    x += 1.0;\n    float xx = x * x;\n    return sqrt(tau / x) * pow(x / e * sqrt(x * sinh(1.0 / x) + 1.0 / (810.0 * xx * xx * xx)), x);\n}\n\nfloat factorial(in float x) {\n    float y = pfactorial(abs(x));\n    return x < 0.0 ? pi * x / (y * sin(pi * x)) : y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 8.0;\n    float unit = 16.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n\n    // Grid\n    draw(abs(fract(uv.x + 0.5) - 0.5) + 0.25 * unit, vec3(0.0, 0.0, 1.0));\n    draw(abs(fract(uv.y + 0.5) - 0.5) + 0.25 * unit, vec3(0.0, 0.0, 1.0));\n    draw(abs(uv.x), vec3(1.0, 0.0, 0.0));\n    draw(abs(uv.y), vec3(1.0, 0.0, 0.0));\n\n    // Draw the function\n    vec2 y = vec2(factorial(uv.x), 0.0);\n    y.y = (factorial(uv.x + 0.001) - y.x) / 0.001;\n    draw(abs(uv.y - y.x) / sqrt(1.0 + y.y * y.y) - 0.01, vec3(0.6, 0.0, 0.8));\n\n    // Draw continuous Pascal's triangle\n    //float n = uv.x + 8.0;\n    //float k = uv.y + 4.0;\n    //float binCoeff = round(gamma(n) / (gamma(k) * gamma(n - k))); // Rounding is affordable since I'm only wanting integers\n    //color = vec3(binCoeff * 0.01);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlSXR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[455, 455, 485, 485, 622], [624, 624, 653, 653, 742], [744, 744, 799, 799, 1680]], "test": "untested"}
{"id": "NtBSRh", "name": "Pow() Bug", "author": "oneshade", "description": "pow() has the wrong sign cube roots and also seems to be wrong for odd exponents and roots.\nRed is pow(x, 1/3), green is corrected pow(x, 1/3)", "tags": ["glsl", "bug", "pow", "sign"], "likes": 3, "viewed": 286, "published": 3, "date": "1626998981", "time_retrieved": "2024-07-30T19:09:39.602084", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    fragColor = vec4(0.0);\n\n    float y = pow(uv.x, 1.0 / 3.0);\n    float dx = pow(uv.x, -2.0 / 3.0) / 3.0;\n    vec4 color = vec4(1.0, 0.0, 0.0, 1.0);\n\n    if (mod(iTime, 2.0) > 1.0) {\n        y = sign(uv.x) * pow(abs(uv.x), 1.0 / 3.0);\n        color = vec4(0.0, 1.0, 0.0, 1.0);\n    }\n\n    fragColor = mix(fragColor, color, smoothstep(unit, 0.0, abs(uv.y - y) / sqrt(1.0 + dx * dx)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtBSRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 552]], "test": "untested"}
{"id": "7l2Szz", "name": "fork: Peacock feather spiral 2", "author": "elenzil", "description": "A simple fractal formula, with a very minor tweak", "tags": ["fractal", "spiral"], "likes": 6, "viewed": 279, "published": 3, "date": "1626988897", "time_retrieved": "2024-07-30T19:09:40.541572", "image_code": "// Fork of \"Peacock feather spiral 2\" by jarble. https://shadertoy.com/view/7tjSRz\n// 2021-07-22 21:19:20\n\n#define ITERS 12\n\nfloat getS0(vec2 uv, float t)\n{\n    float ret = 2.1;\n    \n    ret += (sin(t * 10.0 * (1.0 + sin(length(uv) * 0.3) * 0.3)) * 0.5 + 0.5) * sin(uv.x * 0.05) * 0.5;\n    \n    return ret;\n}\n\nfloat getS1(vec2 uv, float t)\n{\n    float ret = 1.125;\n    \n    ret *= 1.0 + sin(t * 35.0) * 0.001 * sin(length(uv) * 20.0);\n    \n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    float t=0.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/15.0;\n    uv.y += (iTime)/25.0;\n    for(int c=0;c<ITERS;c++){\n        float scale0 = getS0(uv, iTime / 25.0);\n        float scale1 = getS1(uv, iTime / 25.0);\n        float s1 = scale1*scale0;\n        col_prev = col.yzx;\n        for(int i=0;i<ITERS;i++)\n        {\n            \n            uv= fract(-uv-((vec2(uv.x/scale0-uv.y/scale1,uv.y/scale0-uv.x/scale1)/(scale0))))/scale1;\n            \n            uv = fract(-uv.yx/s1)*s1;\n            uv.x *= scale1;\n            uv.y /= -scale1;\n        }\n        col[2] = abs(fract(uv.y)-fract(uv.x));\n        col = ((col+col_prev))/2.125;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l2Szz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 125, 156, 156, 308], [310, 310, 341, 341, 457], [459, 459, 516, 516, 1295]], "test": "untested"}
{"id": "7l2XRz", "name": "Doom Fire!", "author": "chenglou", "description": "As shown in [url]https://fabiensanglard.net/doom_fire_psx/index.html[/url].\n[b]Mouse click to stop fire[/b]", "tags": ["fire", "doom", "fx", "particle"], "likes": 8, "viewed": 427, "published": 3, "date": "1626986513", "time_retrieved": "2024-07-30T19:09:41.382324", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 hash22(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n    if (fragCoord.y < 2. && iMouse.z < 0.001) {\n        fragColor = vec4(1);\n        return;\n    }\n    \n    vec2 rand = floor(hash22(fragCoord * 999. + iTime) * 3.);\n    \n    vec2 offset = vec2(rand.x - 1., -rand.y);\n    vec4 neighbor = texelFetch(iChannel0, ivec2(mod(fragCoord + offset, iResolution.xy)), 0);\n    vec3 color = neighbor.rgb - vec3(0.0025, 0.0035, 0.005);\n\n    fragColor = vec4(color, 1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l2XRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 119]], "test": "untested"}
{"id": "sljXRz", "name": "Slanting Lines", "author": "oneshade", "description": "Are they slanting?\nCool illusion from: [url=https://www.fieggen.com/graphics/illusions.htm]https://www.fieggen.com/graphics/illusions.htm[/url]", "tags": ["lines", "illusion", "slanted"], "likes": 7, "viewed": 146, "published": 3, "date": "1626985011", "time_retrieved": "2024-07-30T19:09:42.156255", "image_code": "void mainImage(out vec4 o, vec2 u) {\n    vec2 r = iResolution.xy, p = (u - .5 * r) / r.y * 8.;\n    o -= o;\n\n    vec2 c = floor(p);\n    p.x += .5 * mod(c.y, 2.);\n\n    o += mod(floor(p.x), 2.);\n    p -= c;\n\n    o = mix(o, vec2(1, 0).rggg, smoothstep(16. / r.y, 0., abs(max(abs(fract(p.x) - .5), abs(p.y - .5)) - .5)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sljXRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 318]], "test": "untested"}
{"id": "7tjSRz", "name": "Peacock feather spiral 2", "author": "jarble", "description": "A simple fractal formula.", "tags": ["fractal", "spiral"], "likes": 5, "viewed": 318, "published": 3, "date": "1626979389", "time_retrieved": "2024-07-30T19:09:42.917220", "image_code": "#define ITERS 12\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    float t=0.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/15.0;\n    uv.y += (iTime)/25.0;\n    for(int c=0;c<ITERS;c++){\n        float scale = 2.1;\n        float scale1 = 1.125;\n        float s1 = scale1*scale;\n        col_prev = col.yzx;\n        for(int i=0;i<ITERS;i++)\n        {\n            \n            uv= fract(-uv-((vec2(uv/scale-uv.yx/scale1)/(scale))))/scale1;\n            \n            uv = fract(-uv.yx/s1)*s1;\n            uv.x *= scale1;\n            uv.y /= -scale1;\n        }\n        col[2] = abs(fract(uv.y)-fract(uv.x));\n        col = ((col+col_prev))/2.125;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tjSRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 74, 74, 786]], "test": "untested"}
{"id": "ft2Xzz", "name": "Fractal 65_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 1, "viewed": 309, "published": 3, "date": "1626960194", "time_retrieved": "2024-07-30T19:09:43.758970", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=0.;\n        ++i<160.;\n        O.xyz+=mix(vec3(1),H(cos(log(s)))*.5,.8)*1e-4*i/e/s\n    )\n    {\n        p=g*d;\n        p.z+=iTime;\n        s=3.;\n        p=abs(mod(p,2.)-1.)-1.;\n        p.x<p.z?p=p.zyx:p;\n        p.y<p.z?p=p.xzy:p;\n        for(int j;j++<8;p=abs(p)*e-vec3(.03,.4,20))\n            s*=e=2.5/clamp(dot(p,p),.3,1.3);\n        g+=e=length(p)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft2Xzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 612]], "test": "untested"}
{"id": "7tlSDB", "name": "triangle rasterization", "author": "Cewein", "description": "a custom way to get uv from 3 point on a triangle.\nit was needed for a custom software render i'm doing at the moment.", "tags": ["raytracing", "triangle", "texture", "uv"], "likes": 0, "viewed": 454, "published": 3, "date": "1626958728", "time_retrieved": "2024-07-30T19:09:44.531903", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //map to 0 and 1 then get x and y distance\n    vec2 p = fragCoord/iResolution.xy;\n    float x = 1.0/3.0;\n    float y = 1.0/4.0;\n    \n    //setup 3 vertices to make a triangle\n    vec2 p1 = vec2(y*2.0,y*3.0);    \n    vec2 p2 = vec2(x*1.0,y*1.0);    \n    vec2 p3 = vec2(x*2.0,y*1.0); \n    \n    //get the first vertex and the two vector leading to p2 and p3 from p1\n    vec2 v0 = p1;\n    vec2 v1 = vec2(p2.x - v0.x, p2.y - v0.y);\n    vec2 v2 = vec2(p3.x - v0.x, p3.y - v0.y);\n    \n    //check for each pixel v if it belong to the triangle\n    //by solving v = v0 + av1 +bv2\n    float bottom = (v1.x*v2.y-v1.y*v2.x);\n    \n    float a = (p.x*v2.y-p.y*v2.x) - (v0.x*v2.y-v0.y*v2.x);\n    a /= bottom;\n   \n    float b = (p.x*v1.y-p.y*v1.x) - (v0.x*v1.y-v0.y*v1.x);\n    b /= bottom; \n    \n    //tell if a pixel uv is in the triangle or not\n    vec3 color = vec3(0.35);\n    if(a > 0.0 && -b > 0.0)\n        if((a-b)<1.0)\n            color = vec3(1.);\n    \n    \n    if(color == vec3(1.))\n    {   \n        //using barycentric coordinates we can get good weight for each vertex\n        float bottom =((p2.y-p3.y)*(p1.x-p3.x)+(p3.x-p2.x)*(p1.y-p3.y));\n        float w1 = ((p2.y-p3.y)*(p.x-p3.x)+(p3.x-p2.x)*(p.y-p3.y))\n                  /bottom;\n        float w2 = ((p3.y-p1.y)*(p.x-p3.x)+(p1.x-p3.x)*(p.y-p3.y))\n                  /bottom;\n        float w3 = 1.0 - w1 - w2;\n        \n        //mix all the color from the computed weigth\n        color = (w1*vec3(1.,0.,0.)+w2*vec3(0.,1.,0.)+w3*vec3(0.,0.,1.))/(w1+w2+w3);\n\n    }   \n    \n    fragColor = vec4(color,0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlSDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 104, 1616]], "test": "untested"}
{"id": "7lXXWX", "name": "Isometric Flat ", "author": "byt3_m3chanic", "description": "Continuing my isometric fun, and playing with mixing 2D and 3D ", "tags": ["2d", "raymarching", "fractal", "flat", "isometric"], "likes": 57, "viewed": 1068, "published": 3, "date": "1626940611", "time_retrieved": "2024-07-30T19:09:45.304836", "image_code": "/**\n\n    Isometric Flat\n    @byt3_m3chanic | 7/22/2021\n\n    Continuing my isometric fun, and playing with\n    mixing 2D and 3D \n\n*/\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MAX_DIST    100.\n#define MIN_DIST    1e-4\n\nfloat time,ga1,ga2,ga3,ga4,tmod;\nmat2 turn,r45,rx,ry;\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(23.86,48.32)))*4374.432); }\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0.0, 1.0); }\n\n//@iq - all sdf's\nfloat box(vec3 p, vec3 s) \n{\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat box( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec4 hex(vec2 uv, float scale)\n{\n    uv *= scale;\n    const vec2 s = vec2(sqrt(3.), 1.);\n    //id's and center - compacted to vec4's\n    vec4 id = vec4(floor(uv/s),floor(uv/s + .5));\n    vec4 cn = vec4(vec2(id.xy)+.5,vec2(id.zw)+.0)*vec4(s,s);\n    vec2 p,cid;\n    vec2 p1 = cn.xy - uv;\n    vec2 p2 = cn.zw - uv;\n    //nearest hexagon coords / id.\n    if (length(p1) < length(p2)){\n        p = p1;\n        cid = id.xy;\n    } else {\n        p = p2;\n        cid = id.zw + .5;\n    }\n    return vec4(p,cid);\n}\n\nvoid btn(inout vec4 p, float s, float f, float m)\t\n{\n\tp.xy = abs(p.xy + f) - abs(p.xy - f) - p.xy;\n\tfloat r = dot(p.xyz, p.xyz);\n\tif (r < m){\n\t\tif(m==.0) m=.000001;\n\t\tp /= m;\n\t}else if (r<1.){\n\t\tp /= r;\n\t}\n\tp *= s;\n}\n\nvoid tet(inout vec4 p, float k1, float k2, float k3, float k4) \n{\n\tp = abs(p);\n\tfloat k = (k1 - .5)*2.;\n\tp.xyz /= vec3(k2, k3, k4);\n\n\tif (p.x < p.y) p.xy = p.yx; p.x = -p.x;\n\tif (p.x > p.y) p.xy = p.yx; p.x = -p.x;\n\tif (p.x < p.z) p.xz = p.zx; p.x = -p.x;\n\tif (p.x > p.z) p.xz = p.zx; p.x = -p.x;\n\n\tp.xyz = p.xyz * k1 - k + 1.;\n\tp.xyz *= vec3(k2, k3, k4);\n\tp.w *= abs(k);\n}\n\nvec2 map (vec3 p) \n{\n    p.yz*=r45;\n    p.xz*=r45;\n    p.xz*=rx;\n    \n    vec3 q = p;\n    float orbits = .0;\n    \n    p.y-=ga1*5.;\n    p.y=mod(p.y+2.5,5.)-2.5;\n    \n    vec4 P = vec4(p.xzy, 1.0); \n    for(int i = 0; i < 3; i++) {\n        btn(P, 3.85, 2.5, .25);\n        if(i == 1) orbits = max(length(P.xy)/PI,abs(P.z));\n        tet(P, 1.5, 1., 1., 1.); \n    }\n    \n    float ln = .99*(abs(P.z)-05.)/P.w;\n    float bx = box(q,vec3(1.25,4.,1.25));\n    ln=max(ln,bx);\n    \n\treturn vec2(ln,floor(orbits*.5));\n}\n\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec3 hue(float t)\n{ \n    const vec3 c = vec3(0.941,0.686,0.141);\n    return .45 + .45*cos(time*.5+PI2*t*(c*vec3(.98,.99,.97))); \n}\n\nvoid pattern(inout vec3 C, vec2 uv, float d)\n{\n    vec2 vuv = uv;\n    vec2 uvp = uv;\n    uv.y -=ga1;\n    uvp.y+=ga1*2.;\n    float pd = floor((uvp.y+1.)/2.);\n    uvp.y=mod(uvp.y+1.,2.)-1.;\n    float px = fwidth(uv.x);\n    vec4 p    = hex(uv,8.);\n    \n    float hs  = hash21(p.zw);\n\n    float sz =  (length(abs(p.z))*12.);\n    float sy =  (length(abs(p.w))*12.);\n    float sx = .18+.18*sin(sz+sy+T*2.75);//\n    \n    p.y*=1.5;\n    p.xy*=rot(45.*PI/180.);\n    \n    float h2 = box(p.xy,vec2(sx));\n    if(hs>.5) h2=abs(h2)-.02;\n    h2=smoothstep(.01+px,-px,h2);\n    \n    uvp.y*=1.5;\n    uvp.xy*=rot(45.*PI/180.);\n    \n    float h3 = box(uvp.xy+vec2(.2665),vec2(.675));\n    h3 = max(h3,-box(uvp.xy+vec2(.2665),vec2(.475)));\n    h3=smoothstep(px,-px,h3);\n    \n    vec3 h3c = hue( clamp((vuv.y+.5)*.25,0.,1.)+pd );\n    C = mix(C,h3c,d>0.?h3:0.);\n    \n    if(p.z<-2. || p.z>1.5){\n        C = mix(C,hue(hs),d>0.?h2:0.);\n    }\n\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    // precal       \n    time = T*1.;\n    \n    r45=rot(-0.78539816339);\n    turn=rot(T*5.*PI/180.);\n\n    tmod = mod(time, 10.);\n    float t1 = lsp(0.0, 5.0, tmod);\n    float t2 = lsp(5.0, 10.0, tmod);\n    ga1 = (t1)+floor(time*.1);\n    ga2 = (t2)+floor(time*.1);\n    rx=rot(-t2*PI); \n    //\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    \n    //@Flopine's isometric setup - tweaked\n    //https://www.shadertoy.com/view/NtXSWS\n    vec3 ro = vec3(uv*2.5,-10.);\n    vec3 rd = vec3(0.,0.,1.);\n    //\n    \n    //background\n    vec3 C = mix(hue(3.),hue(32.),clamp((uv.y+1.)*.75,0.,1.));\n    \n    vec3 p;\n    float d=0.,m;\n    //marcher\n    for(int i=0;i<150;i++)\n    {\n        p=ro+rd*d;\n        vec2 ray = map(p);\n        d += ray.x;\n        m  = ray.y;\n        if(abs(ray.x)<MIN_DIST ||d>MAX_DIST)break;\n    }\n    float alpha = 1.;\n    if(d<MAX_DIST)\n    {\n        alpha = 0.;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(-5.0, .25, -9.0);\n        vec3 l = normalize(lpos-p);\n\n        float diff = d*.1;//clamp(dot(n,l),0.,1.);\n        \n        float shdw = .95;\n        for( float t=.06; t < 12.; )\n        {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 24.*h/t);\n            t += h * .25;\n            if( shdw<MIN_DIST || t>25. ) break;\n        }\n\n        diff = mix(diff,diff*shdw,.75);\n\n        vec3 h = hue(m);\n\n        C = vec3(diff)*h;\n    } \n    pattern(C,uv,alpha);\n    C=clamp(C,vec3(.03),vec3(1.));\n    C=pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lXXWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[351, 351, 369, 369, 414], [415, 415, 436, 436, 492], [493, 493, 537, 537, 592], [594, 612, 640, 640, 724], [726, 726, 761, 761, 841], [843, 843, 875, 875, 1347], [1349, 1349, 1401, 1401, 1565], [1567, 1567, 1632, 1632, 1940], [1942, 1942, 1962, 1962, 2449], [2451, 2451, 2481, 2481, 2720], [2722, 2722, 2741, 2741, 2852], [2854, 2854, 2900, 2900, 3771], [3773, 3773, 3814, 3838, 5355]], "test": "untested"}
{"id": "NtlSDs", "name": "Slisesix (2008)", "author": "iq", "description": "A Shader I made in 2008. While not my first raymarched SDF, this was my first SDF based content creation exercise. Lots of the usual SDF techniques are used, although soft shadows and smooth minimum were not fully evolved yet.", "tags": ["procedural", "3d", "raymarching", "distancefield", "sdf", "demoscene"], "likes": 97, "viewed": 5545, "published": 3, "date": "1626923274", "time_retrieved": "2024-07-30T19:09:46.364004", "image_code": "// Copyright Inigo Quilez, 2021 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n// -------------------------------------------------------\n\n// I made this shader in 2008 for the Euskal Party\n// competition in Spain. The original Pouet entry is \n// here: https://www.pouet.net/prod.php?which=51074\n\n// It's a raymarched SDF, and while I had raymarched some\n// fractal SDFs back in 2005, this was the first time I\n// used the technique to produce art-directed content and\n// \"paint with maths\" (as opposed to doing \"mathematical art\").\n\n// This is also the shader where I first used the now\n// popular ambient occlusion estimation. You'll also find\n// my first attemtps at smooth-minumum (used to blend the\n// creature's head and tentacles together), and soft \n// shadows (still not as good as the ones we use today).\n// You'll find most of the other usual Shadertoy/raymarching\n// stuff - domain repetition, Value Noise, box SDFs and of\n// course the raymarching machinery.\n\n// Surprisngly, copying the code from my original project\n// to Shadertoy here required very little modifications.\n\n\n#define AA 1\n\n#define ZERO min(iFrame,0)\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n// https://iquilezles.org/articles/sfrand\nfloat sfrand( inout int mirand )\n{\n    mirand = mirand*0x343fd+0x269ec3;\n    float res = uintBitsToFloat((uint(mirand)>>9)|0x40000000u ); \n    return( res-3.0 );\n}\n\n// hash by Hugo Elias\nuint ihash( uint n )\n{\n\tn = (n << 13) ^ n;\n    n = (n*(n*n*15731u+789221u)+1376312589u)&0x7fffffffu;\n    return n;\n}\n\n// hash by Hugo Elias\nfloat hash( int n )\n{\n\tn = (n << 13) ^ n;\n    n = (n*(n*n*15731+789221)+1376312589)&0x7fffffff;\n    return 1.0 - float(n)*(1.0/1073741824.0);\n}\n\nfloat noise( vec3 p )\n{\n\tivec3 ip = ivec3(floor(p));\n     vec3 fp = fract(p);\n\n    vec3 w = fp*fp*(3.0-2.0*fp);\n    \n    int n = ip.x + ip.y*57 + 113*ip.z;\n\n\treturn mix(mix(mix( hash(n+(0+57*0+113*0)),\n                        hash(n+(1+57*0+113*0)),w.x),\n                   mix( hash(n+(0+57*1+113*0)),\n                        hash(n+(1+57*1+113*0)),w.x),w.y),\n               mix(mix( hash(n+(0+57*0+113*1)),\n                        hash(n+(1+57*0+113*1)),w.x),\n                   mix( hash(n+(0+57*1+113*1)),\n                        hash(n+(1+57*1+113*1)),w.x),w.y),w.z);\n}\n\n// https://iquilezles.org/articles/fbm\nfloat fbm( vec3 p )\n{\n#if 0\n    // original code\n    return 0.5000*noise( p*1.0 ) + \n           0.2500*noise( p*2.0 ) + \n           0.1250*noise( p*4.0 ) +\n           0.0625*noise( p*8.0 );\n#else\n    // equivalent code, but compiles MUCH faster\n    float f = 0.0;\n    float s = 0.5;\n    for( int i=ZERO; i<4; i++ )\n    {\n        f += s*noise( p );\n        s *= 0.5;\n        p *= 2.0;\n    }\n    return f;\n#endif\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( in vec3 p, in vec3 b ) \n{\n    vec3 q = abs(p) - b;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat udSqBox( vec3 p, vec3 b )\n{\n\tfloat di = 0.0;\n\tfloat dx = abs(p.x)-b.x; if( dx>0.0 ) di+=dx*dx;\n    float dy = abs(p.y)-b.y; if( dy>0.0 ) di+=dy*dy;\n    float dz = abs(p.z)-b.z; if( dz>0.0 ) di+=dz*dz;\n    return di;\n}\n\n//-------------------------------------------------------------------------------\n\nfloat columna( vec3 pos, float offx )\n{\n    float x = pos.x;\n    float y = pos.y;\n    float z = pos.z;\n    \n\tfloat y2=y-0.40;\n    float y3=y-0.35;\n    float y4=y-1.00;\n\n    float di =    udSqBox( vec3(x, y , z), vec3(0.10, 1.00, 0.10) );\n    di = min( di, udSqBox( vec3(x, y , z), vec3(0.12, 0.40, 0.12) ) );\n    di = min( di, udSqBox( vec3(x, y , z), vec3(0.05, 0.35, 0.14) ) );\n    di = min( di, udSqBox( vec3(x, y , z), vec3(0.14, 0.35, 0.05) ) );\n    di = min( di, udSqBox( vec3(x, y4, z), vec3(0.14, 0.02, 0.14) ) );\n    di = min( di, udSqBox( vec3((x-y2)*0.7071, (y2+x)*0.7071, z), vec3(0.10*0.7071,  0.10*0.7071, 0.12) ) );\n    di = min( di, udSqBox( vec3(x, (y2+z)*0.7071, (z-y2)*0.7071), vec3(0.12,  0.10*0.7071, 0.1*0.7071) ) );\n    di = min( di, udSqBox( vec3((x-y3)*0.7071, (y3+x)*0.7071, z), vec3(0.10*0.7071,  0.10*0.7071, 0.14) ) );\n    di = min( di, udSqBox( vec3(x, (y3+z)*0.7071, (z-y3)*0.7071), vec3(0.14,  0.10*0.7071, 0.10*0.7071) ) );\n\n    #if 1\n    float fb = fbm(vec3(10.1*x+offx,10.1*y,10.1*z));\n    if( fb>0.0 )\n        di = di + 0.00000003*fb;\n    #endif\n\n    return sqrt(di);\n}\n\nfloat bicho( vec3 pos, float mindist )\n{\n    pos -= vec3(0.64,0.50,1.5);\n    \n    float r2 = dot2(pos);\n\n\tfloat sa = smoothstep(0.0,0.5,r2);\n    pos *= vec3(0.75,0.80,0.75) + sa*vec3(0.25,0.20,0.25);\n    r2 = dot2(pos);\n\n    if( r2>5.0 ) return mindist;\n    if( pos.y >0.5 ) return mindist;\n\tif( pos.y>-0.2 && dot(pos.xz,pos.xz)>0.6 ) return mindist;\n    if( r2>(1.7+mindist)*(1.7+mindist)  ) return mindist;\t// algo ayuda, poco, pero algo oiga\n\n\tfloat r = sqrt(r2);\n\n\tif( r<0.75 )\n    {\n\tfloat a1 = 1.0-smoothstep( 0.0, 0.75, r );\n\ta1 *= 0.6;\n\tvec2 sico = vec2( sin(a1), cos(a1) );\n\tfloat nx = pos.x;\n\tfloat ny = pos.y;\n\tpos.x = nx*sico.y - ny*sico.x;\n\tpos.y = nx*sico.x + ny*sico.y;\n    }\n\t#define TENTACURA 0.045\n\tfloat mindist2 = 100000.0;\n    vec3  p = pos;\n\tfloat rr = 0.05+length(pos.xz);\n\tfloat ca = (0.5-TENTACURA*0.75) -6.0*rr*exp2(-10.0*rr);\n    for( int j=1+ZERO; j<7; j++ )\n\t{\n\t\tfloat an = (6.2831/7.0) * float(j);\n\t\tfloat aa = an + 0.40*rr*noise(vec3(4.0*rr, 2.5, an)) + 0.29;\n\t\tfloat rc = cos(aa);\n        float rs = sin(aa);\n\t\tvec3 q = vec3( p.x*rc-p.z*rs, p.y+ca, p.x*rs+p.z*rc );\n\t\tfloat dd = dot(q.yz,q.yz);\n\t\tif( q.x>0.0 && q.x<1.5 && dd<mindist2 ) mindist2=dd;\n\t}\n\tfloat dtentacles = sqrt(mindist2) - TENTACURA;\n\n    // proto-smooth-minimum\n\tfloat dhead = r-0.15;\n\n    float h = clamp( r*3.0, 0.0, 1.0 );\n    return mix(dhead-0.15,dtentacles,h);\n}\n\nfloat techo2( float x, float y, float z )\n{\n    y = 1.0 - y;\n    x = x - 0.5;\n    z = z - 0.5;\n    return 0.4 - sqrt(y*y+min(x*x,z*z) );\n}\n\nfloat map( vec3 pos, out uint sid, out uint submat )\n{\n    submat = 0u;\n    float mindist;\n    \n    //-----------------------\n    // suelo\n    //-----------------------\n    {\n\tfloat dis = pos.y;\n\t\n\tfloat ax = 128.0 + (pos.x+pos.z)*6.0;\n\tfloat az = 128.0 + (pos.x-pos.z)*6.0;\n    uint ix = uint(floor(ax));\n    uint iz = uint(floor(az));\n    submat = ihash(ix+53u*iz);\n    bool ba = ( ((submat>>10)&7u)>6u );\n    float peld = max(fract(ax),fract(az));\n    peld = smoothstep( 0.975, 1.0, peld );\n    if( ba ) peld = 1.0;\n    dis += 0.005*peld;\n\tmindist = dis;\n    if( peld>0.0000001 ) sid = 2u; else sid = 0u;\n    }\n    \n    //-----------------------\n    // techo\n    //-----------------------\n\tif( pos.y>1.0 ) \n    {\n        float dis = techo2( fract(pos.x), pos.y, fract(pos.z) );\n        if( dis<mindist )\n        {\n            mindist = dis;\n            sid = 5u;\n        }\n    }\n\n    //-----------------------\n    // columnas\n    //-----------------------\n    {\n\tvec3 fc = vec3(fract( pos.x+0.5 )-0.5, pos.y,\n\t               fract( pos.z+0.5 )-0.5);\n    float bb = udSqBox( fc, vec3(0.14, 1.0, 0.14) );\n    if( bb < mindist*mindist )\n    {\n        float dis = columna( fc, 13.1*floor(pos.x)+17.7*floor(pos.z) );\n        if( dis<mindist )\n        {\n            mindist = dis;\n            sid = 1u;\n        }\n    }\n    }\n    \n    //-----------------------\n    // bicho\n    //-----------------------\n    //if( length( pos-vec3(0.64,-2.1,1.5) ) - 2.8 < mindist )\n    if( dot2( pos-vec3(0.64,-2.1,1.5) ) < (mindist+2.8)*(mindist+2.8) )\n    {\n    float dis = bicho( pos, mindist );\n    if( dis<mindist )\n    {   \n        mindist = dis;\n        sid = 4u;\n    }\n    }\n\n    //-----------------------\n    // baldosas\n    //-----------------------\n    if( pos.y-0.02 < mindist )\n\t{\n\tint kkr = 65535;\n    for( int i=ZERO; i<10; i++ )\n    {\n        float a = 3.14*sfrand(kkr);\n        float co = cos(a);\n        float si = sin(a);\n        float xc = pos.x - (0.5 + 1.5*sfrand(kkr));\n        float zc = pos.z - (1.0 + 1.0*sfrand(kkr));\n        float xo = xc*co-si*zc;\n        float zo = zc*co+si*xc;\n        float dis = sdBox( vec3(xo, pos.y-0.008, zo), vec3(0.07, 0.008, 0.07) );\n        if( dis < mindist ) \n        {\n            mindist = dis;\n            sid = 1u;\n        }\n    }\n\t}\n    \n    return mindist;\n}\n\nvoid raycast( vec3 ro, vec3 rd, float to, float tMax, out float resT, out vec3 resPos, out uint resSurface, out uint submat )\n{\n    float t = to;\n    for( int i=ZERO; i<256; i++ )\n\t{\n        resPos = ro + t*rd;\n\t\tfloat h = map( resPos, resSurface, submat );\n\t\tif( h<0.0001 )\n\t\t{\n\t\t    resT = t;\n\t\t\treturn;\n\t\t}\n        t += h*0.75;\n        if( t>tMax ) break;\n\t}\n    resSurface = 666u;\n}\n\nvec3 calcNormal( vec3 pos )\n{\n#if 0\n    // original code\n    const float eps = 0.0002;\n    uint kk, kk2;\n    vec3 nor = vec3(\n      map( pos.x+eps, pos.y, pos.z, kk, kk2 ) - map( pos.x-eps, pos.y, pos.z, kk, kk2 ),\n      map( pos.x, pos.y+eps, pos.z, kk, kk2 ) - map( pos.x, pos.y-eps, pos.z, kk, kk2 ),\n      map( pos.x, pos.y, pos.z+eps, kk, kk2 ) - map( pos.x, pos.y, pos.z-eps, kk, kk2 ));\n    return normalize(nor);\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        uint kk, kk2;\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0002*e, kk, kk2);\n        if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec3 shade( vec3 pos, vec3 rd, uint matID, uint subMatID, float dis )\n{\n    if( matID==666u ) return vec3(0.0,0.0,0.0);\n\n    vec3 col = vec3(0.1*dis);\n\n    // calc normal\n    vec3 nor = calcNormal( pos );\n\n    // bump mapping\n    #if 1\n    const float kke = 0.0001;\n    float bumpa = 0.0075;\n\tif( matID!=5u ) bumpa *= 0.75;\n    if( matID==4u ) bumpa *= 0.50;\n    bumpa /= kke;\n    float kk = fbm( 32.0*pos );\n    nor.x += bumpa*(fbm( 32.0*vec3(pos.x+kke, pos.y, pos.z) )-kk);\n    nor.y += bumpa*(fbm( 32.0*vec3(pos.x, pos.y+kke, pos.z) )-kk);\n    nor.z += bumpa*(fbm( 32.0*vec3(pos.x, pos.y, pos.z+kke) )-kk);\n    nor = normalize(nor);\n    #endif\n\n\n    // light\n\tfloat spe = 0.0;\n    vec3 lig = vec3( 0.5, 0.8, 1.5 ) - pos;\n    float llig = dot2(lig);\n    float im = 1.0/sqrt(llig);\n    lig *= im;\n    float dif = dot( nor, lig ); \n    if( matID==4u )\n        dif = 0.5+0.5*dif;\n    else\n        dif = 0.10+0.90*dif;\n    dif = max( dif, 0.0 );\n\tdif *= 2.5*exp2( -1.75*llig );\n\tfloat dif2 = (nor.x+nor.y)*0.075;\n\n    // materials\n    if( matID==0u )\n    {\n        float xoff = 13.1 * float(subMatID&255u);\n        float fb = fbm( 16.0*vec3(pos.x+xoff, pos.y, pos.z) );\n\n        col = 0.7 + vec3(0.20,0.22,0.25)*fb;\n\n        float baldscale = float((subMatID>>9)&15u)/14.0;\n        baldscale = 0.51 + 0.34*baldscale;\n        col *= baldscale;\n        float fx = 1.0;\n        if( (subMatID&256u)!=0u ) fx = -1.0;\n        float m = sin( 64.0*pos.z*fx +  64.0*pos.x + 4.0*fb );\n        m = smoothstep( 0.25, 0.5, m ) - smoothstep( 0.5, 0.75, m );\n\n        col += m*0.15;\n    }\n    else if( matID==2u )\n    {\n        col = vec3(0.0,0.0,0.0);\n    }\n    else if( matID==1u )\n    {\n        float fb = fbm( 16.0*pos );\n        float m = sin( 64.0*pos.z +  64.0*pos.x + 4.0*fb );\n        m = smoothstep( 0.3, 0.5, m ) - smoothstep( 0.5, 0.7, m );\n        col = 0.59 + fb*vec3(0.17,0.18,0.21) + m*0.15 + dif2;\n    }   \n    else if( matID==4u )\n    {\n        float ft = fbm( 16.0*pos );\n        col = vec3(0.82,0.73,0.65) + ft*vec3(0.10,0.10,0.15);\n        float fs = 0.90+0.10*fbm( 32.0*pos );\n        col *= fs;\n\n        float fre = -dot( nor, rd );\n        if( fre<0.0 ) fre=0.0;\n        fre = fre*fre*0.45;\n        col -= fre;\n\n\t\tspe = (nor.y-nor.z)*0.707;\n        spe = spe*spe;\n        spe = spe*spe;\n        spe = spe*spe;\n        spe = spe*spe;\n        spe = spe*spe;\n        spe *= 0.20;\n     }   \n    // techo\n    else //if( matID==5 )\n    {\n        float fb = fbm( 16.0*pos );\n        col = vec3(0.64,0.61,0.59) + fb*vec3(0.21,0.19,0.19) + dif2;\n    }   \n\n    // AO\n    float ao;\n    #if 1\n    float totao = 0.0;\n    float sca = 10.0;\n    for( int aoi=ZERO; aoi<5; aoi++ )\n    {\n        float hr = 0.01 + 0.015*float(aoi*aoi);\n        vec3 aopos = pos + hr*nor;\n        uint kk, kk2;\n        float dd = map( aopos, kk, kk2 );\n        ao = -(dd-hr);\n        totao += ao*sca;\n        sca *= 0.5;\n        //if( totao>1000.0+sin(iTime) ) break;\n    }\n    ao = 1.0 - clamp( totao, 0.0, 1.0 );\n    #else\n    ao = 1.0;\n    #endif\n\n    // shadow\n    #if 1\n    float so = 0.0;\n\tfor( int i=ZERO; i<6; i++ )\n    {\n\t\tfloat h = float(i)/6.0;\n        float hr = 0.01 + 1.0*h;\n        vec3 aopos = pos + hr*lig;\n        uint kk, kk2;\n        float dd = map( aopos, kk, kk2 );\n        so += (1.0-h)*dd*20.0/6.0;\n        //if( so>1000.0+iTime ) break;\n    }\n    dif *= clamp( (so-0.40)*1.5, 0.0, 1.0 );\n    #endif\n\n    // shade\n\tfloat ao2 = 0.05 + 0.95*ao;\n    col *= vec3(0.25,0.30,0.35)*ao + dif*ao2*vec3(1.95,1.65,1.05);\n    col += spe;\n    col *= exp2( -0.40*pos.z );\n\n    return col;\n}\n\nvec3 post( vec3 col, vec2 p )\n{\n    // flare\n\tfloat rr = (p.x+0.10)*(p.x+0.10) + (p.y-0.40)*(p.y-0.40);\n    col += vec3( 1.0, 0.95, 0.90 )*0.75*exp2( -64.0*rr );\n\n    // color correct\n    col = sqrt(col)*0.3 + 0.7*col;\n    col *= vec3(0.83,1.00,0.83);\n\n    // vignetting\n    col *= 0.25 + 0.75*clamp( 0.60*abs(p.x-1.77)*abs(p.x+1.77), 0.0, 1.0 );\n    \n    return clamp( col, 0.0, 1.0 );\n}\n\nvec3 computePixel( vec2 p, vec2 res, float time )\n{\n    vec2 s = (2.0*p-res)/res.y;\n    \n    // fisheye distortion\n    float r2 = s.x*s.x*0.32 + s.y*s.y;\n\tfloat tt = (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n\n    // create camera and ray\n    vec2 d = s*tt;\n#if 0\n    vec3 ro = vec3( 0.195, 0.5, 0.0 );\n\tvec3 rd = normalize( vec3( d.x*0.955336 + 0.29552, d.y, 0.955336 - d.x*0.29552 ) );\n#else\n    float an = 4.4 + 0.2*sin(0.4*time);\n    vec3 ta = vec3(0.64,0.50,1.5);\n    vec3 ro = ta + 1.55*vec3( cos(an), 0.0, sin(an));\n    vec3 ww = normalize( ta-ro );\n    vec3 vv = vec3(0.0,1.0,0.0);\n    vec3 uu = normalize(cross(vv,ww));\n    vec3 rd = normalize( uu*d.x + vv*d.y + 1.0*ww );\n#endif\n\tfloat t;\n\tuint matID, sumMatID;\n\tvec3 xyz;\n    \n    // raycast\n\traycast( ro, rd, 0.5, 24.0, t, xyz, matID, sumMatID );\n    \n    // shade\n\tvec3 col = shade(  xyz, rd, matID, sumMatID, t  );\n    \n    // postprocess\n\tcol = post( col, s );\n\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if AA<2    \n    vec3 col = computePixel(fragCoord, iResolution.xy, iTime );\n#else\n    vec3 col = vec3(0.0);\n    for( int j=0; j<AA; j++ )\n    for( int i=0; i<AA; i++ )\n    {\n        vec2 of = vec2(i,j)/float(AA);\n        float time = iTime + (0.5/30.0)*float(j*AA+i)/float(AA*AA);\n        col += computePixel(fragCoord+of, iResolution.xy, time );\n    }\n    col /= float(AA*AA);\n#endif\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtlSDs.jpg", "access": "api", "license": "proprietary-license", "functions": [[1817, 1817, 1842, 1842, 1861], [1863, 1905, 1939, 1939, 2068], [2070, 2092, 2114, 2114, 2208], [2210, 2232, 2253, 2253, 2375], [2377, 2377, 2400, 2400, 2951], [2953, 2992, 3013, 3013, 3404], [3406, 3455, 3493, 3493, 3584], [3586, 3635, 3668, 3668, 3858], [3943, 3943, 3982, 3982, 5048], [5050, 5050, 5090, 5090, 6418], [6420, 6420, 6463, 6463, 6558], [6560, 6560, 6614, 6614, 8863], [8865, 8865, 8992, 8992, 9251], [9253, 9253, 9282, 9282, 10060], [10062, 10062, 10133, 10133, 13633], [13635, 13635, 13666, 13679, 14023], [14025, 14025, 14076, 14076, 14958], [14961, 14961, 15018, 15018, 15437]], "test": "untested"}
{"id": "Nl2SRR", "name": "Fractal Curve", "author": "oneshade", "description": "[url=https://en.wikipedia.org/wiki/L%C3%A9vy_C_curve]https://en.wikipedia.org/wiki/L%C3%A9vy_C_curve[/url]\nNot quite.", "tags": ["fractal", "curve"], "likes": 7, "viewed": 128, "published": 3, "date": "1626922509", "time_retrieved": "2024-07-30T19:09:47.137935", "image_code": "// Utilities\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\n// SDFs\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 4.0;\n    vec2 uv = (fragCoord - center) / iResolution.y + vec2(0.0, 0.5);\n    float unit = 2.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n\n    float scale = 1.0;\n    float a = 3.1415 / 4.0;//u = sqrt(0.5); // = cos(π/4) = sin(π/4)\n    float c = cos(a), s = sin(a);\n    for (int i=0; i < int(iTime) % 50; i++) {\n        uv.x = abs(uv.x);\n        uv.x -= 0.5;\n        uv *= mat2(c, -s, s, c);//vec2(uv.x - uv.y, uv.x + uv.y) * u;\n        uv.x += 0.5;\n        uv *= 2.0;\n        scale *= 2.0;\n    }\n\n    drawSDF(sdLine(uv, vec2(-0.5, 0.0), vec2(0.5, 0.0)) / scale - 0.001, vec3(0.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2SRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 102, 149, 149, 257], [259, 259, 314, 314, 1033]], "test": "untested"}
{"id": "7lXSDs", "name": "Bigger voxel models", "author": "mdb", "description": "test to load big voxels models thanks to custom textures\nsee explanation of how to make it work in the top of the shader", "tags": ["models", "voxel", "scene", "octree", "customtextures"], "likes": 13, "viewed": 439, "published": 3, "date": "1626903750", "time_retrieved": "2024-07-30T19:09:48.206080", "image_code": "/*\n\nshader by mdb\nLoad custom model of a lot of voxel,\ninspired by https://www.shadertoy.com/view/lsGGDd for loading the textures\n\n------------------------------------------------------------------------------\n- How to load a model ? ------------------------------------------------------\n\n=> Open the javascript console of your browser:\n               Mac      /     Windows\n  Chrome:  cmd + opt + J  /  ctrl + shift J\n  Firefox: cmd + opt + K  /  ctrl + shift K\n  IE:          na         /  F12   \n\n=> Then copy the following line in the console\n\n  gShaderToy.SetTexture(0, {mSrc:'https://dl.dropboxusercontent.com/s/e5k9k7ph4pyhg6c/pirateShop.png?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'nearest', wrap: 'repeat', vflip:'false', srgb:'false', internal:'byte' }});\n\n=> hit return to execute\n\nDone !!\n\n-----------------------------------------------------------------------------\n- list of models ------------------------------------------------------------\n(other lines to enter in the console as before)\n1:\"painterly cottage\" from https://sketchfab.com/3d-models/painterly-cottage-0772aec70d584c60a27000af5f6c1ef4\n\n  gShaderToy.SetTexture(0, {mSrc:'https://dl.dropboxusercontent.com/s/gbzyos7j1opgoda/homeTree.png?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'nearest', wrap: 'repeat', vflip:'false', srgb:'false', internal:'byte' }});\n\n2:\"Shipwrecked Chinese Supply Store\" from https://sketchfab.com/3d-models/dae-villages-shipwrecked-chinese-supply-store-af2da248227c4dac96fc2570e58e26da\n\n  gShaderToy.SetTexture(0, {mSrc:'https://dl.dropboxusercontent.com/s/e5k9k7ph4pyhg6c/pirateShop.png?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'nearest', wrap: 'repeat', vflip:'false', srgb:'false', internal:'byte' }});\n\n3:\"minecraft cathedral\" from https://sketchfab.com/3d-models/cathedral-faed84a829114e378be255414a7826ca\n\n  gShaderToy.SetTexture(0, {mSrc:'https://dl.dropboxusercontent.com/s/qye7wo2wmsyjhb1/cathedral.png?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'nearest', wrap: 'repeat', vflip:'false', srgb:'false', internal:'byte' }});\n \n4:\"birds\" from https://sketchfab.com/3d-models/lekking-ruffs-f5e8e5a459a14e2fb46f7d79f6ca7edc\n  \n  gShaderToy.SetTexture(0, {mSrc:'https://dl.dropboxusercontent.com/s/muw5khk9ukepkfw/birds.png?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'nearest', wrap: 'repeat', vflip:'false', srgb:'false', internal:'byte' }});\n \n5:\"landscape of nevada (detailed)\" from https://sketchfab.com/3d-models/cathedral-gorge-state-park-nevada-672f50581e2e441ab2cf0ad92b23ebc1\n\n gShaderToy.SetTexture(0, {mSrc:'https://dl.dropboxusercontent.com/s/p3ov2isdk862i98/landscape.png?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'nearest', wrap: 'repeat', vflip:'false', srgb:'false', internal:'byte' }});\n \n6:\"monster garden\" from https://sketchfab.com/3d-models/monstergarden-9397658152d243ab9f22c619fad0293e\n\n gShaderToy.SetTexture(0, {mSrc:'https://dl.dropboxusercontent.com/s/dz48pbe8421yuc4/monsterGarden.png?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'nearest', wrap: 'repeat', vflip:'false', srgb:'false', internal:'byte' }});\n\n7:\"cob over a light\" from sketchfab (i lost the origin)\n    \n gShaderToy.SetTexture(0, {mSrc:'https://dl.dropboxusercontent.com/s/mdaljwicod0c0r2/cob.png?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'nearest', wrap: 'repeat', vflip:'false', srgb:'false', internal:'byte' }});\n\n-----------------------------------------------------------------------------\n- How the data is stored:  --------------------------------------------------\nthe data is stored in a texture as an octree\n\nthe tree is stored as:\nNode:\n    8 pixels for each child\n    \n    and for each pixel (rgba, 4 uint8):\n        if pixel.a = 0:\n            it is a child !\n            the index of the child is:\n                idx = pixel.r + (pixel.g << 8) + (pixel.b << 16)\n         \n         if pixel.a = 1:\n             it is an empty leaf\n         \n         if pixel.a = 2:\n             it is a leaf\n             the leaf color is pixel.rgb\n\n\nif you want to see the octree, you can uncomment showTree on line 81\n\n*/\n\n//#define showTree\n\n#define maxDepth 12\n\nvec3 treeUp = vec3(2.0);\nvec3 treeDown = vec3(-2.0);\n\nvec3 col = vec3(0.0);\n#define OUT -200.0\n\nuvec4 treeTex(uint idx){\n    uint w = uint(iChannelResolution[0].x);\n    vec4 data = texelFetch(iChannel0, ivec2(idx % w, idx / w), 0); \n    return uvec4(data * 255.0);\n}\n\nfloat rand(vec3 p){\n    uint idx = uint(p.x) + uint(p.y)*64u + uint(p.z)*64u*64u;\n    idx ^= 3646844786u;\n    idx *= 474746u;\n    idx >>= 16;\n    idx *= 563563u;\n    idx >> 13;\n    idx *= 454749u;\n    return float(idx)/4294967295.0;\n}\n\n//tree traversal stuff\n\nuint a;\nuint find_firstNode(vec3 t0, vec3 tM){\n    uint first = 0u;\n    if(t0.x > t0.y && t0.x > t0.z){ // entry YZ\n        if(tM.y < t0.x) first |= 2u;\n        if(tM.z < t0.x) first |= 1u;\n    }else if(t0.y > t0.z){ // entry XZ\n        if(tM.x < t0.y) first |= 4u;\n        if(tM.z < t0.y) first |= 1u;\n    }else{  // entry XY\n        if(tM.x < t0.z) first |= 4u;\n        if(tM.y < t0.z) first |= 2u; \n    }\n    return first;\n}\n\nuint next_Node(vec3 t1, uint yz, uint xz,uint xy){\n    if(t1.x < t1.y && t1.x < t1.z){\n        return yz;\n    }else if(t1.y < t1.z){\n        return xz;\n    }else{\n        return xy;\n    }\n}\n\nvec4 procTree( vec3 t0, vec3 t1, out vec3 normal)\n{   \n    //init variables\n    vec3 color;\n    int actualDepth = 0;\n    uint nodeIdx[maxDepth];\n    uint childIdx[maxDepth];\n    vec3 t0s[maxDepth];\n    vec3 t1s[maxDepth];\n    t0s[actualDepth] = t0;\n    t1s[actualDepth] = t1;\n    const int END = 8;\n    const uvec3[] nextNode = uvec3[](uvec3( 4 , 2 , 1 ),\n                                     uvec3( 5 , 3 ,END),\n                                     uvec3( 6 ,END, 3 ),\n                                     uvec3( 7 ,END,END),\n                                     uvec3(END, 6 , 5 ),\n                                     uvec3(END, 7 ,END),\n                                     uvec3(END,END, 7 ),\n                                     uvec3(END,END,END));\n    \n    vec3 tM = 0.5 * (t0 + t1);\n    childIdx[actualDepth] = find_firstNode(t0, tM);\n    nodeIdx[actualDepth] = 0u;\n    uvec4 dataComp = treeTex(nodeIdx[actualDepth] + a ^ childIdx[actualDepth]);\n    nodeIdx[actualDepth + 1] = dataComp.x + (dataComp.y << 8) + (dataComp.z << 16);\n    \n    // start loop\n    for(int i = 0; i < 600; i ++){\n        if (actualDepth < 0)return vec4(OUT);//visited all nodes\n        \n        uint currNode =  childIdx[actualDepth];\n        dataComp = treeTex(nodeIdx[actualDepth] + a ^ childIdx[actualDepth]);\n        t1 = t1s[actualDepth];\n        if(t1.x <= 0.0 || t1.y <= 0.0 || t1.z <= 0.0) dataComp = uvec4(0, 0, 0, 1); \n        bool leaf = (dataComp.w != 0u);\n        bool back = (currNode == 8u);\n        \n        if (leaf || back){\n            if(back){actualDepth -= 1; currNode = childIdx[actualDepth];}\n            t0 = t0s[actualDepth];\n            t1 = t1s[actualDepth];\n            tM = 0.5 * (t0 + t1);\n            vec3 dt = t1 - t0;\n            vec3 idx = vec3(float(currNode&4u)/4.0, float(currNode&2u)/2.0, float(currNode&1u));\n            vec3 t0_ = t0 + 0.5*dt*idx;\n            vec3 t1_ = t0 + 0.5*dt*(1.0 + idx);\n            vec3 tM_ = 0.5*(t0_ + t1_);\n            \n            if (leaf && !back && (dataComp.w == 2u)){//the node is a full leaf\n                t0 = t0_;\n                color = vec3(dataComp.xyz)/255.0;\n                \n                if(t0.x > t0.y && t0.x > t0.z){ // entry YZ\n                    normal = vec3(1.0, 0.0, 0.0);\n                    return vec4(color, t0.x);\n                }\n                if(t0.y > t0.z){ // entry XZ\n                    normal = vec3(0.0, 1.0, 0.0);\n                    return vec4(color, t0.y);\n                }\n                // entry XY\n                normal = vec3(0.0, 0.0, 1.0);\n                return vec4(color, t0.z);\n                       \n                \n            }\n            #ifdef showTree   \n                col -= 0.011;\n            #endif\n            \n            uvec3 next = nextNode[currNode];\n                             \n            childIdx[actualDepth] = next_Node(t1_, next.x, next.y, next.z);\n            dataComp = treeTex(nodeIdx[actualDepth] + a ^ childIdx[actualDepth]);\n            nodeIdx[actualDepth + 1] = dataComp.x + (dataComp.y << 8) + (dataComp.z << 16);\n        \n        } else {\n            t0 = t0s[actualDepth];\n            t1 = t1s[actualDepth];\n            actualDepth += 1;\n           \n            tM = 0.5 * (t0 + t1);\n\n            vec3 dt = t1 - t0;\n            vec3 idx = vec3(float(currNode&4u)/4.0, float(currNode&2u)/2.0, float(currNode&1u));\n            vec3 t0_ = t0 + 0.5*dt*idx;\n            vec3 t1_ = t0 + 0.5*dt*(1.0 + idx);\n            vec3 tM_ = 0.5*(t0_ + t1_);\n            childIdx[actualDepth] = find_firstNode(t0_, tM_);\n            \n            dataComp = treeTex(nodeIdx[actualDepth] + a ^ childIdx[actualDepth]);\n            nodeIdx[actualDepth + 1] = dataComp.x + (dataComp.y << 8) + (dataComp.z << 16);\n        \n            t0s[actualDepth] = t0_;\n            t1s[actualDepth] = t1_;\n        }\n        \n    }\n    return vec4(OUT);\n}\n\n\n\nvec4 ray_step(vec3 ro, vec3 rd, out vec3 normal){\n    a = 0u;\n    vec3 flip = -sign(rd);\n    vec3 size = (treeUp + treeDown)*0.5;\n    \n    if (rd.x < 0.0){\n        ro.x = size.x - ro.x;\n        rd.x = -rd.x;\n        a |= 4u;\n    }\n    if (rd.y < 0.0){\n        ro.y = size.y - ro.y;\n        rd.y = -rd.y;\n        a |= 2u;\n    }\n    if (rd.z < 0.0){\n        ro.z = size.z - ro.z;\n        rd.z = -(rd.z);\n        a |= 1u;\n    }\n    \n    vec3 invDir = 1.0/rd;\n    vec3 t0 = (treeDown - ro) * invDir;\n    vec3 t1 = (treeUp - ro) * invDir;\n\n    float tmin = max(max(t0.x, t0.y), t0.z);\n    float tmax = min(min(t1.x, t1.y), t1.z);\n    if ((tmin < tmax) && (tmax > 0.0f)){\n        vec4 res = procTree(t0, t1, normal);\n        normal *= flip;\n        return res;\n    }else{ //doesn't intersect\n        return vec4(OUT);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //test if any model is loaded\n    if(iChannelResolution[0].x == iResolution.x &&\n       iChannelResolution[0].y == iResolution.y){\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n        return;\n    }\n    vec2 uv = fragCoord/iResolution.xy*2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 0.3; // small FOV\n    \n    vec3 camPos = vec3(-3.0*cos(iTime*0.5), 0.1 + 0.6*sin(iTime*0.7*0.5), -3.0*sin(iTime*0.5))*1.9;\n    vec3 target = vec3(0.0);\n    \n    vec3 dir0 = normalize(target - camPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(up, dir0));\n         up = cross(dir0, right);\n    \n    vec3 rd = normalize(right * uv.x + up * uv.y + dir0);\n    \n    //back ground\n    vec3 col2 = vec3(0.082,0.086,0.137);\n    \n    //intersect object\n    vec3 normal;\n    vec4 res = ray_step(camPos, rd, normal);\n    if (res.w != OUT){\n        col2 = res.rgb;  \n    }\n    \n    uv = fragCoord/iResolution.xy;\n    \n    // color stuff \n    //col2 = col2*col2*(3.0-2.0*col2);\n    col2 *= 0.8 + 0.2*pow(16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.4 );\n    \n    fragColor = vec4(col + col2,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//just contain the warning if the model is not loaded (see the main shader)\n//and also the python script for generating the imageTexture with the octree data\n//to imorte an object file to voxels\n\n// say \"action needed\"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    uv -= vec2(0.08, 0.12);\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    ivec2 idx = ivec2(floor(uv*7.0));\n    vec2 uv2 = vec2(0.25, 0.1) + vec2(0.5, 0.8)*fract(uv*7.0);\n    if(idx.y == 0){\n        if(idx.x == 0)col.r = texture(iChannel0, (vec2(14, 9) + uv2)/16.0).r;\n        if(idx.x == 1)col.r = texture(iChannel0, (vec2( 5, 9) + uv2)/16.0).r;\n        if(idx.x == 2)col.r = texture(iChannel0, (vec2( 5, 9) + uv2)/16.0).r;\n        if(idx.x == 3)col.r = texture(iChannel0, (vec2( 4, 9) + uv2)/16.0).r;\n        if(idx.x == 4)col.r = texture(iChannel0, (vec2( 5, 9) + uv2)/16.0).r;\n        if(idx.x == 5)col.r = texture(iChannel0, (vec2( 4, 9) + uv2)/16.0).r;\n    }\n    if(idx.y == 1){\n        if(idx.x == 0)col.r = texture(iChannel0, (vec2( 1, 9) + uv2)/16.0).r;\n        if(idx.x == 1)col.r = texture(iChannel0, (vec2( 3, 9) + uv2)/16.0).r;\n        if(idx.x == 2)col.r = texture(iChannel0, (vec2( 4, 8) + uv2)/16.0).r;\n        if(idx.x == 3)col.r = texture(iChannel0, (vec2( 9, 9) + uv2)/16.0).r;\n        if(idx.x == 4)col.r = texture(iChannel0, (vec2(15, 9) + uv2)/16.0).r;\n        if(idx.x == 5)col.r = texture(iChannel0, (vec2(14, 9) + uv2)/16.0).r;\n    }\n    //col = texture(iChannel0, uv).rrr;\n    fragColor = vec4(col, 1.0); \n}\n/*\nthis is the bython script that allows me to create a voxel model from a polygon model\nthis script is not the best but it works\n\nto make it work for yourself there is some conditions\nyou must fill all the data in the begining of the script\nthe input model:\n    - is an obj\n    - all color is from a single texture\n    - texture alpha will be ignored (avoid transparent texture)\n    - no materials\n\nto create a texture that contains all the colors from a model with multiples\ntextures and also lighting information, I recomend baking the all model\nto a texture in blender and then use this texture as the texture for the model\n\nto use the output image of the model in shadertoy, follow this shader that explain how\nto import custom textures: https://www.shadertoy.com/view/lsGGDd\n\n//python script/////////////////////////////////////////////////////////////\n\n# info for model\nmodelPath = ''  # '.obj' needed\ntexturePath = ''\noutputName = ''  # '.png'\ntreeDepth = 8\n\n# save voxels data in a 8 bits RGBA texture\nfrom PIL import Image\nimport numpy as np\n\nclass Poly:\n    def __init__(self, vertex, uvs):\n        self.vertex = vertex\n        self.uvs = uvs\n\n\ndef split(polys: list, mid, axis=0):\n    up = []\n    down = []\n    for poly in polys:\n        vertex = np.array(poly.vertex)\n        uv = poly.uvs.copy()\n        idxUp = vertex[:, axis] > mid\n        idxDown = vertex[:, axis] < mid\n        idxOn = vertex[:, axis] == mid\n        if np.all(idxUp | idxOn):  # all on one side\n            up += [poly]\n\n        elif np.all(idxDown | idxOn):  # all on the other side\n            down += [poly]\n\n        elif np.all(~ idxOn):\n            idxUp2 = []\n            idxDown2 = []\n            idxOn2 = []\n            vertex2 = []\n            uv2 = []\n            for i in range(len(poly.vertex)):\n                idxUp2 += [idxUp[i]]\n                idxDown2 += [idxDown[i]]\n                idxOn2 += [idxOn[i]]\n                vertex2 += [vertex[i]]\n                uv2 += [uv[i]]\n                if idxUp[i] != idxUp[(i + 1) % len(vertex)]:\n                    if not (idxOn[i] or idxOn[(i + 1) % len(vertex)]):\n                        A = vertex[i]\n                        B = vertex[(i + 1) % len(vertex)]\n                        x = (mid - A[axis]) / (A[axis] - B[axis])\n                        v2 = A + (A - B) * x\n                        vt2 = uv[i] + (uv[i] - uv[(i + 1) % len(vertex)]) * x\n                        vertex2 += [v2]\n                        uv2 += [vt2]\n                        idxUp2 += [False]\n                        idxDown2 += [False]\n                        idxOn2 += [True]\n\n            on = np.array(idxOn2, bool)\n            vertex2 = np.array(vertex2)\n            uv2 = np.array(uv2)\n            up += [Poly(vertex2[idxUp2 | on], uv2[idxUp2 | on])]\n            down += [Poly(vertex2[idxDown2 | on], uv2[idxDown2 | on])]\n\n    return [down, up]\n\n\nclass Node:\n    maxDepth = treeDepth\n    Tree = []\n\n    def __init__(self, depth=0):\n        self.depth = depth\n        self.child = None\n        self.colors = []\n        self.up = np.array([1, 1, 1], float)\n        self.down = np.array([-1, -1, -1], float)\n\n    def initChild(self):\n        dxyz = self.up - self.down\n        child = []\n        for x in range(2):\n            for y in range(2):\n                for z in range(2):\n                    c = Node(self.depth + 1)\n                    c.down = self.down + np.array([x, y, z]) * dxyz / 2\n                    c.up = self.down + dxyz / 2 + np.array([x, y, z]) * dxyz / 2\n                    child += [c]\n        return child\n\n    def append(self, poly):\n        if self.depth == Node.maxDepth:\n            center = np.mean(poly.uvs, axis=0)\n            center = np.array([center[0], 1.0 - center[1]])\n            coord = np.array(center * texture.size, int)\n            coord = np.minimum(coord + 1, texture.size) - 1\n            data = texture.getpixel((coord[0], coord[1]))\n            self.colors += [data[:3]]\n            return\n\n        if self.child is None:\n            self.child = self.initChild()\n\n        polys = [[poly]]\n        # cut triangle in 8\n        for axis in range(3):\n            new = []\n            mid = (self.up[axis] + self.down[axis]) / 2\n            for i in range(2 ** axis):\n                new += split(polys[i], mid, axis=axis)\n            polys = new\n\n        for i in range(8):\n            for poly in polys[i]:\n                self.child[i].append(poly)\n\n    def treeDepth(self):\n        if self.child is None:\n            return self.depth\n        return max(c.treeDepth() for c in self.child)\n\n    def importObj(self, objfile):\n        vertex = []\n        vMin = np.zeros(3, float)\n        vMax = np.zeros(3, float)\n        uvs = []\n        faceCount = 0\n        with open(objfile, 'r') as f:  # get all vertex and texture info\n            for line in f:\n                line = line.replace('\\n', '')\n                if line:\n                    line = line.replace('  ', ' ')\n                    data = line.split(' ')\n                    if data[0] == 'v':\n                        v = np.array([float(data[1]), float(data[2]), float(data[3])])\n                        vMax = np.maximum(vMax, v)\n                        vMin = np.minimum(vMin, v)\n                        vertex += [v]\n                    if data[0] == 'vt':\n                        uvs += [np.array([float(data[1]), float(data[2])])]\n                    if data[0] == 'f':\n                        faceCount += 1\n        # find vMin and vMax of the cube AABB\n        vMid = 0.5 * (vMin + vMax)\n        side = np.max(vMax - vMin)\n\n        with open(objfile, 'r') as f:  # append all the faces\n            i = 0\n            for line in f:\n                line = line.replace('  ', ' ')\n                line = line.replace(' \\n', '')\n                line = line.replace('\\n', '')\n                if line:\n                    data = line.split(' ')\n                    if data[0] == 'f':\n                        i += 1\n                        print('\\rinsert ' + str(i) + ' / ' + str(faceCount), end='')\n                        v = []\n                        uv = []\n                        for idx in data[1:]:\n                            v += [(vertex[int(idx.split('/')[0]) - 1] - vMid)/side * 2.0]\n                            uv += [uvs[int(idx.split('/')[1]) - 1]]\n                        p = Poly(v, uv)\n                        self.append(p)\n\n        print()\n\n    def fillData(self):\n        if self.child is not None:\n            currentIdx = len(Node.Tree)\n            Node.Tree += [[], [], [], [], [], [], [], []]\n            for i, c in enumerate(self.child):\n                if c.child is not None:\n                    l = len(Node.Tree)\n                    Node.Tree[currentIdx + i] = [l & 255,\n                                                 (l >> 8) & 255,\n                                                 (l >> 16) & 255,\n                                                 0]\n                else:  # it's a leaf !\n                    if len(c.colors) == 0:  # empty leaf\n                        Node.Tree[currentIdx + i] = [0, 0, 0, 1]\n                    else:\n                        col = np.zeros(3, float)\n                        for co in c.colors:\n                            col += co\n                        col /= len(c.colors)\n                        col = np.array(col, int)\n\n                        Node.Tree[currentIdx + i] = [*col, 2]\n                c.fillData()\n            return\n\n    def createArray(self):\n        Node.Tree = []\n        self.fillData()\n\n        w = int(np.ceil(np.sqrt(len(Node.Tree))))\n        out = Node.Tree.copy()\n        out += [[0, 0, 0, 0]] * (w*w - len(Node.Tree))\n        out = np.array(out, np.uint8)\n        out = out.reshape((w, w, 4))\n\n        im = Image.fromarray(out)\n        im.save(\"outputName\")\n\n\n# textures\ntexture = Image.open(\"texturePath\")\n\nTree = Node()\nTree.importObj('objectPath')\nTree.createArray()\nprint(f\"{len(Node.Tree) = }\")\n\n*/", "buffer_a_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lXSDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[4222, 4222, 4246, 4246, 4392], [4394, 4394, 4413, 4413, 4628], [4662, 4662, 4700, 4700, 5081], [5083, 5083, 5133, 5133, 5272], [9153, 9153, 9202, 9202, 9972], [9974, 9974, 10030, 10064, 11161]], "test": "untested"}
{"id": "sllSDs", "name": "Continuous Factorial Approx. II", "author": "oneshade", "description": "Extending [url=https://www.shadertoy.com/view/stl3DS]https://www.shadertoy.com/view/stl3DS[/url]", "tags": ["approximation", "gamma", "continuous", "factorial", "specialfunction"], "likes": 8, "viewed": 166, "published": 3, "date": "1626878936", "time_retrieved": "2024-07-30T19:09:49.057802", "image_code": "// To compute any part of the gamma function we only\n// need to be able to compute it in the 0 to 1 range\n// and the rest can be computed exactly from that\n// by using these properties:\n// (x + 1)! = x!(x + 1)\n// (x - 1)! = x!/x\n\n// Now using a least squares fit\n// To approximate the 0 to 1 range\n\n#define draw(d, c) color = mix(color, c, smoothstep(unit, 0.0, d))\n\n// Approximate error (in the short range approximation): 0.00000317535198105\n// The short range approximation is then analytically extended to the rest of the function\n#define factorial01(x) (((((0.07288448978215456 * x - 0.31390051543712616) * x + 0.6538907084614038) * x - 0.810425715520978) * x + 0.9737655441276729) * x - 0.5761851668648887) * x + 0.9999830044034752\nfloat factorial(in float x) {\n    float h = floor(x), f = x - h, y = factorial01(f);\n    if (x < 0.0) for (float n=0.0; n < -h; n++) y /= f - n;\n    else for (float n=1.0; n < h + 1.0; n++) y *= f + n;\n    return y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 8.0;\n    float unit = 16.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n\n    // Grid\n    draw(abs(fract(uv.x + 0.5) - 0.5) + 0.25 * unit, vec3(0.0, 0.0, 1.0));\n    draw(abs(fract(uv.y + 0.5) - 0.5) + 0.25 * unit, vec3(0.0, 0.0, 1.0));\n    draw(abs(uv.x), vec3(1.0, 0.0, 0.0));\n    draw(abs(uv.y), vec3(1.0, 0.0, 0.0));\n\n    // Draw the function\n    vec2 y = vec2(factorial(uv.x), 0.0);\n    y.y = (factorial(uv.x + 0.001) - y.x) / 0.001;\n    draw(abs(uv.y - y.x) / sqrt(1.0 + y.y * y.y) - 0.01, vec3(0.6, 0.0, 0.8));\n\n    // Draw continuous Pascal's triangle\n    //float n = uv.x + 8.0;\n    //float k = uv.y + 4.0;\n    //float binCoeff = round(factorial(n) / (factorial(k) * factorial(n - k)));\n    //color = vec3(binCoeff * 0.01);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sllSDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[738, 738, 767, 767, 955], [957, 957, 1012, 1012, 1847]], "test": "untested"}
{"id": "flSXzR", "name": "Islands in wavy shallow water", "author": "Arrangemonk", "description": "i have stolen together some algorithms to test if i can replicate something i did in c# by stealing togehter algorithms.\n\ni triedto do a voxelspace like implementation, but in a fragment shader raytracing makes way more sence. so meh", "tags": ["terrain", "water", "islands"], "likes": 11, "viewed": 727, "published": 3, "date": "1626872560", "time_retrieved": "2024-07-30T19:09:50.006266", "image_code": "// Created by Arrangemonk 2021, arrangemonk@gmail.com\n// where i have a clear source i added shadertoy link\n\n\nvec3 rampBiome(float x){\n    vec3 col = biome[0];\n    float step_size = 1./(float(biome.length())-1.);\n    for(int i = 0; i < biome.length()-1; i++){\n        col =mix(col, biome[i+1], linearstep(float(i)*step_size, (float(i)+1.)*step_size, x));\n    }\n    return col;\n}\n \n vec3 rampSky(float x){\n    vec3 col = sky[0];\n    float step_size = 1./(float(sky.length())-1.);\n    for(int i = 0; i < sky.length()-1; i++){\n             col =mix(col, sky[i+1], linearstep(float(i)*step_size, (float(i)+1.)*step_size, x));\n    }\n    return col;\n}\n\nfloat h(in vec2 uv,bool water)\n    {\n    uv = uv * 0.005;\n    float result = texture(iChannel0,uv).x - texture(iChannel3,uv*45.).x *0.025;\n    if(!water)\n        result = max(waterline + waterripple(uv*5.,iChannel3,iTime).z *0.03,result);\n    return result ;\n    }\n\n//https://www.shadertoy.com/view/3sSSW1\nvec3 texNormalMap(in vec2 uv,float scale)\n{ \n    float p  = h(uv,true);\n    float h1 = h(uv + vec2(scale,0),true);\n    float v1 = h(uv +  vec2(0,scale),true);\n       \n   \tvec2 normal = (p - vec2(h1, v1));\n    \n    normal *= normalStrength;\n    normal += 0.5;\n    \n    return normalize(vec3(normal, 1.));\n}\n\n\n\nvec3 color( in vec2 uv,float height)\n{ \n    return mix(rampBiome(height*0.25),mix(fbm(uv,iChannel1,octaves).rgb,rampBiome(height*0.25),0.75),height/6. +0.1);\n}\n\nvec3 target(in vec3 origin,in vec3 direction,in float distance)\n    {\n        return origin + (direction * distance);\n    }\n\n//lost link, most likely iqs doing\nfloat RayMarch(vec3 origin,vec3 direction,in bool water, out bool result)\n{\n    float t = 0.;\n    for (int i = 0; i < 72; i++)\n    {\n        vec3 rp = target(origin,direction,t);\n        float h = rp.y - (h(rp.xz,water));\n        if (abs(h) < (.0015 * t) || t > DrawDistance) break;\n        t += h;\n    }\n    result = t < DrawDistance;\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 sunDir = normalize(vec3(6.,-3., 2.));\n    \n    //low resolution \n   //  uv = floor(uv*vec2(320.,240.))/vec2(320.,240.);\n    float aspect = iResolution.x / iResolution.y;\n    \n    vec3 rd = normalize(vec3((1.- 2. * uv.x) * aspect + sin(time * 0.1)*0.2+sin(time *3.)*.01,-1. + 2. * uv.y-0.6+sin(time *3.)*.01, -3.0));\n    vec3 ro = vec3(sin(time * 0.1)*3.+sin(time *3.)*.01,5.+sin(time *5.)*.009, -time+sin(time *4.)*.011);\n\n    bool result;\n    float distance = RayMarch(ro,rd,false,result);\n    float distfract = clamp(distance*DrawDistanceFract,0.,1.);\n    \n     vec3 c = rampSky((uv.y-0.4)*1.1);\n     if(result)\n     {\n         vec3 point = target(ro,rd,distance);\n         float height =  h(point.xz,false);\n         if(h(point.xz,true) < height) // why water isnt at 0 u ask? i winged it, thats why\n         {\n            vec3 waternormal = normalize(waterripple(point.xz * 0.02 + distance * 0.002,iChannel3,iTime) + vec3(0,0,2.+ (distfract * distfract) * 10.));\n            vec3 wd = refract(rd,waternormal, .97);\n            vec3 wr = normalize(reflect(rd,waternormal));\n             float wdistance = RayMarch(point,wd,true,result);\n             float wdistfract = clamp(wdistance*DrawDistanceFract,0.,1.);\n             vec3 wp = target(point,wd,wdistance);\n             float wheight =  h(wp.xz,true)-0.1;\n             \n             float hilight = clamp((dot(wr,waternormal) * 0.5 + 0.5)* distance *0.035,0.,1.);\n             //vec3 skyreflect = rampSky(1.1 -wr.z * 0.6);\n             vec3 skyreflect = rampSky(1.1 - texture(iChannel2,-wr).r* 0.6);\n             skyreflect = mix(skyreflect,texture(iChannel2,wr).rgb,.5);\n             \n             float wsun = dot( texNormalMap(wp.xz,1.), sunDir);\n             wsun += dot( texNormalMap(wp.xz,0.25), sunDir )*2.;\n             wsun += dot( texNormalMap(wp.xz,0.02), sunDir )*4.,\n             wsun *= 0.143;\n             wsun = clamp( wsun, 0.0, 1.0 )-0.6;\n             float cst = caustics(wp.zx * 5. + wp.y,time*2.)*0.4 * clamp(wdistance,0.,1.)*clamp(wp.y/8.,0.,1.);\n             \n             vec3 c1 = mix(color(wp.xz,mix(3.-wdistfract*10.,wheight,.2)) + wsun,skyreflect,hilight) +cst;\n             //vec3 c1 = vec3(cst,cst,cst);\n       \n             c = mix(c1,c,distfract);\n             c = foam(point.xz + waternormal.xy *0.15 - vec2(0.2,0.2)*time,iChannel3,iChannel1,c,wheight);\n         }\n         else{\n             float sun = dot( texNormalMap(point.xz,1.), sunDir);\n             sun += dot( texNormalMap(point.xz,0.25), sunDir )*2.;\n             sun += dot( texNormalMap(point.xz,0.02), sunDir )*4.,\n             sun *= 0.143;\n             sun = clamp( sun, 0.0, 1.0 )-0.6;\n             c = mix(color(point.xz,height) + sun,c,distfract);\n             c += foamborder(point.xz - vec2(0.1,0.1)*time,iChannel3,height*height -5.45);\n         }\n     }\n    fragColor = vec4(c,1.0);\n\n}\n\n\n", "image_inputs": [{"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//https://www.shadertoy.com/view/XttyRX\n#define tau 6.28318530718\n\n#define tile_factor .25\n#define noise_factor 0.03\n#define textureOffset 2.\n#define heightMapResolution iChannelResolution[0]\n#define normalStrength 10.0\n\nfloat DrawDistance = 100.0;\nfloat DrawDistanceFract = 0.01;\nfloat angle = 0.0;\nfloat time;\nfloat waterline = 2.9;\nfloat octaves = 16.;\n\n \nconst vec3 biome[] = vec3[](\n\nvec3(  0.,  34., 154.) /255.,\nvec3(  8.,  65., 159.) /255.,\nvec3( 15., 110., 161.) /255.,\nvec3( 77., 178., 179.) /255.,\nvec3(250., 252., 227.) /255.,\nvec3( 28., 150.,  74.) /255.\n);\n\nconst vec3 sky[] =vec3[](\nvec3(207., 107.,  40.) / 255.,\nvec3(207., 107.,  40.) / 255.,\nvec3(207., 107.,  40.) / 255.,\nvec3(240., 200., 150.) / 255.,\nvec3(195., 216., 224.) / 255.,\nvec3(147., 198., 237.) / 255.,\nvec3( 70., 130., 200.) / 255.,\nvec3(  1.,  97., 180.) / 255.\n);\n\nfloat sin01(float x) {\n\treturn (sin(x*tau)+1.)/2.;\n}\nfloat cos01(float x) {\n\treturn (cos(x*tau)+1.)/2.;\n}\n\n//https://www.shadertoy.com/view/Xt23zV\nfloat linearstep(float edge0, float edge1, float x)\n{\n    return  clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n}\n\nfloat foamborder(vec2 uv,sampler2D iChannel2,float height)\n{\n    float border = clamp(abs(1./(height -waterline))*0.1,0.,1.);\n    return border * border * border * texture( iChannel2, uv * 0.5 ).x * 0.5;\n}\n\n\n//foam from https://www.shadertoy.com/view/ldj3Dm\nvec3 foam (vec2 uv,sampler2D iChannel2,sampler2D iChannel3,vec3 col,float height)\n{\n    float border = foamborder(uv,iChannel2,height);\n\tfloat sur = texture( iChannel3,  0.05 * uv ).x;\n\tsur = smoothstep( 0.5, 1.0, sur )*0.5 + 0.5*sur*sur*smoothstep(0.2,1.0,texture( iChannel2, uv * 0.5 ).x);\n\treturn mix( col, vec3(1.0), border + sur);\n}\n\n\n// rand func from theartofcode (youtube channel)\nvec2 rand01(vec2 p) {\n    vec3 a = fract(p.xyx * vec3(123.5, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    \n    return fract (vec2(a.x * a.y, a.y * a.z));\n}\n\nfloat circ(vec2 uv, vec2 pos, float r) {\n    return smoothstep(r, 0., length(uv - pos));\n}\n\nfloat smoothFract(float x, float blurLevel) {\n\treturn pow(cos01(x), 1./blurLevel);\n}\n\nfloat manDist(vec2 from, vec2 to) {\n    return abs(from.x - to.x) + abs(from.y - to.y);\n}\n\n\nfloat distFn(vec2 from, vec2 to) {\n\tfloat x = length (from - to);\n    return pow (x, 4.);\n}\n\nfloat voronoi(vec2 uv, float t, float seed, float size) {\n    \n    float minDist = 100.;\n    \n    float gridSize = size;\n    \n    vec2 cellUv = fract(uv * gridSize) - 0.5;\n    vec2 cellCoord = floor(uv * gridSize);\n    \n    for (float x = -1.; x <= 1.; ++ x) {\n        for (float y = -1.; y <= 1.; ++ y) {\n            vec2 cellOffset = vec2(x,y);\n            \n            // Random 0-1 for each cell\n            vec2 rand01Cell = rand01(cellOffset + cellCoord + seed);\n\t\t\t\n            // Get position of point\n            vec2 point = cellOffset + sin(rand01Cell * (t+10.)) * .5;\n            \n\t\t\t// Get distance between pixel and point\n            float dist = distFn(cellUv, point);\n    \t\tminDist = min(minDist, dist);\n        }\n    }\n    \n    return minDist;\n}\n\nvec3 fbm(in vec2 uv,sampler2D tex, float octaves)\n{\nuv = uv * 0.07;\nfloat factor = 2.;\nfloat facorinverse = 0.5;\nvec3 result = texture(tex,uv).rgb;\n    for(float i =0.; i < octaves;i++)\n    {\n    result += (mod(i,1.)*2.-1.)* (texture(tex,uv*factor).rgb)* facorinverse;\n    factor *= 2.;\n    facorinverse *= 0.5;\n    }\n    return result;\n}\n\n\n    //https://www.shadertoy.com/view/4sXXRj\nvec3 waterripple(vec2 uv, sampler2D tex,float iTime)\n    {\n\tvec2 p = uv * vec2(-1.0, -2.0);\n    \n    \tfloat t = iTime/300.0;\n\t\n\t\tvec2 waterCoord = vec2(p.x, 1.0-uv.y);\n\t\tvec2 texCoordNormal0 = waterCoord * tile_factor;\n\t\ttexCoordNormal0 += t ;\n\t\t\n\t\tvec2 texCoordNormal1 = waterCoord * tile_factor;\n\t\ttexCoordNormal1.s -= t ;\n\t\ttexCoordNormal1.t += t ;\n\t\t\n\t\tvec3 normal0 = texture(tex, texCoordNormal0).rgb * 2.0 - 1.0;\n\t\tvec3 normal1 = texture(tex, texCoordNormal1).rgb * 2.0 - 1.0;\n\t\treturn normalize(normal0 + normal1);\n    }\n    \nmat2 rotationMatrix(float angle)\n{\n    float s=sin(angle), c=cos(angle);\n    return mat2( c, -s, s, c );\n}\n\nfloat caustics(vec2 uv,float time)\n{\n    float t = time * .35;\n    \n    float amplitude = .12;\n    float turbulence = .5;\n    vec2 uva = uv.xy + sin01(uv.x*turbulence + t) * amplitude;\n    uva.xy -= cos01(uv.y*turbulence + t) * amplitude;\n    vec2 uvb = uv.xy + sin01(uv.x*turbulence + t*1.3-2.) * amplitude * 0.7;\n    uvb.xy -= cos01(uv.y*turbulence + t*1.-2.3) * amplitude * 0.7;\n    uvb = uvb * rotationMatrix(1.04);\n    vec2 uvc = uv.xy + sin01(uv.x*turbulence + t*1.4 + 3.) * amplitude * 0.3;\n    uvc.xy -= cos01(uv.y*turbulence + t*1.4 + 3.) * amplitude * 0.3;\n    uvc = uvc * rotationMatrix(2.08);\n    \n    float v;\n    v += voronoi(uva, t * 2., 0.5, 2.5)/2.;\n    v += voronoi(uvb, t * 3., 0., 3.) / 2.;\n    v += voronoi(uvc, t * 4., 0., 4.) / 2.;\n    \n    return v;\n}", "buffer_a_code": "vec2 R = vec2(0);\n\nfloat h(in vec2 uv)\n{\nfloat factor = 2.;\nfloat result = 1.2 -texture(iChannel0,uv).r;\n    for(float i =0.; i < octaves;i++)\n    {\n    result += (mod(i,1.)*2.-1.)*(texture(iChannel0,uv*factor).r)/factor;\n    factor *= 2.;\n    }\n    result = result *5. -.4;\n    return result;\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    \n   if (R != iResolution.xy) {\n            R = iResolution.xy;\n            vec2 uv = U/R;\n            float height = h(uv);\n            O = vec4(height,height,height,1.0);\n        \n        return;\n    }\n    \n\tO = texelFetch(iChannel1,ivec2(U), 0);\n\n }\n\n", "buffer_a_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28043, "src": "https://soundcloud.com/extandnb/meteor?in=royaltyfreemusic-nocopyrightmusic/sets/creative-commons-music", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flSXzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[647, 647, 683, 683, 911], [913, 953, 996, 996, 1258], [1262, 1262, 1300, 1300, 1421], [1423, 1423, 1492, 1492, 1546], [1548, 1583, 1658, 1658, 1934], [1936, 1936, 1993, 1993, 4910]], "test": "untested"}
{"id": "NtBSzR", "name": "Planet Moon System", "author": "napsternxg", "description": "Planet moon system. Moon rotating around planet and planet rotating around a source planet.\nLight source is now external.  \n", "tags": ["space"], "likes": 2, "viewed": 295, "published": 3, "date": "1626870781", "time_retrieved": "2024-07-30T19:09:50.865967", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n\nfloat sphereDist(vec3 p, vec4 s){\n    float dSphere = length(p - s.xyz) - s.w;\n    return dSphere;\n}\n\n\nfloat getDist(vec3 p){\n    float dO = p.y;\n    float d = dO;\n    \n    vec4 s = vec4(0, 1, 10, 1);\n    //s.xz += vec2(sin(iTime), cos(iTime));\n    dO = sphereDist(p, s);\n    d = min(dO, d);\n    \n    //s = vec4(0, 1, 6, 1);\n    s.xz += 5.*vec2(sin(0.2*iTime), cos(0.2*iTime));\n    s.w = 0.5;\n    dO = sphereDist(p, s);\n    d = min(dO, d);\n    \n    s.xyz += 1.*vec3(-sin(iTime), 0, cos(iTime));\n    //s.xz *= 5.;\n    s.w = 0.3;\n    //s.xz += vec2(sin(iTime), cos(iTime));\n    dO = sphereDist(p, s);\n    d = min(dO, d);\n    \n    \n    \n    return d; \n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.;\n    for(int i=0; i < MAX_STEPS; i++){\n        vec3 p = ro + dO*rd;\n        float dS = getDist(p);\n        dO += dS;\n        if(dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    return dO;\n\n}\n\n\nvec3 getNormal(vec3 p){\n    vec2 e = vec2(.01, 0);\n    float d = getDist(p);\n    vec3 n = d - vec3(\n        getDist(p -e.xyy), \n        getDist(p -e.yxy), \n        getDist(p -e.yyx)\n    );\n    return normalize(n);\n}\n\n\nfloat getLight(vec3 p){\n\n    //vec3 lightSource = vec3(10.*sin(iTime), 1., 3.*cos(iTime));\n    vec3 lightSource = vec3(0., 3., 6.);\n    //lightSource.xz += vec2(cos(iTime), sin(iTime));\n    vec3 l = normalize(lightSource - p);\n    vec3 n = getNormal(p);\n    float dif = clamp(dot(l, n), 0., 1.);\n    \n    float d = RayMarch(p + n*SURF_DIST*3., l);\n    if(d < length(p-lightSource)) dif *= 0.1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    //uv -= 0.5; \n    //float aspectRatio = iResolution.x/iResolution.y;\n    //uv.x *= aspectRatio;\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(0, 1, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    float d = RayMarch(ro, rd);\n    \n    \n    vec3 p = ro + d*rd;\n    \n    float dif = getLight(p);\n    \n    //col = getNormal(p);\n    //col = vec3(d/6.);\n    col = vec3(dif, dif*dif, dif*dif*dif);\n    //vec3 plane = vec3(uv.x, 0., 0.);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtBSzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 101, 101, 168], [171, 171, 193, 193, 718], [720, 720, 753, 753, 963], [966, 966, 989, 989, 1181], [1184, 1184, 1207, 1274, 1600], [1602, 1602, 1659, 1851, 2411]], "test": "untested"}
{"id": "7lsXWl", "name": "Terraforming Survey ", "author": "Fahrenheitrequited", "description": "a", "tags": ["a"], "likes": 4, "viewed": 334, "published": 3, "date": "1626863848", "time_retrieved": "2024-07-30T19:09:51.796480", "image_code": "// ANY and ALL adulation belongs to IQ, and his new sphere noise.\n// read about it here: https://iquilezles.org/articles/fbmsdf\n// see it in action in his shadertoy here: https://www.shadertoy.com/view/3dGSWR\n\nfloat rnd ( float t ) {\n  return fract( sin(t * 1841.63623 + 2714.23423));\n\n}\nvec2 unit ( float t ) {\n  float a =  fract( sin(t * 1841.63623 + 2714.23423))* 324.114;\n  float x = cos(a);\n  float y = sin(a);\n  return vec2(x,y);\n\n}\nfloat box (vec3 p, vec3 s) {\n  p = abs(p) -s ;\n  return max(p.x,max(p.y,p.z));\n}\n\nvec3 repeat(vec3 p, vec3 s) {\n  return (fract(p/s-0.5)-0.5)*s;\n}\n\nvec2 repeat(vec2 p, vec2 s) {\n  return (fract(p/s-0.5)-0.5)*s;\n}\n\nfloat repeat(float p, float s) {\n  return (fract(p/s-0.5)-0.5)*s;\n}\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n} \nfloat sph(vec3 p, float r){\n  return length(p) - r;\n}\nfloat sph( vec3 i, vec3 f, vec3 c )\n{\n    // random radius at grid vertex i+c (please replace this hash by\n    // something better if you plan to use this for a real application)\n    vec3  p = 17.0*fract( (i+c)*0.3183099+vec3(0.11,0.17,0.13) );\n    float w = fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n    float r = 0.7*w*w;\n    // distance to sphere at grid vertex i+c\n    return length(f-c) - r; \n}\n\n// NuSan's improvement\nfloat sdBase(in vec3 p) {\nreturn length(fract(p)-0.5)-(0.3+dot(sin(p*vec3(2.21,1.13,1.7)),vec3(.2)));\n}\n/*\nfloat sdBase( in vec3 p )\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    return min(min(min(sph(i,f,vec3(0,0,0)),\n                       sph(i,f,vec3(0,0,1))),\n                   min(sph(i,f,vec3(0,1,0)),\n                       sph(i,f,vec3(0,1,1)))),\n               min(min(sph(i,f,vec3(1,0,0)),\n                       sph(i,f,vec3(1,0,1))),\n                   min(sph(i,f,vec3(1,1,0)),\n                       sph(i,f,vec3(1,1,1)))));\n}\n*/\nfloat tick( float t ) {\n  float i = floor(t);\n  float r = fract(t);\n  \n  for ( int n = 0; n < 4; n++) {\n    r = smoothstep(0.,1.,r);\n  }\n  return i + r;\n}\nvec2 sdFbm( in vec3 p, in float th, in float d )\n{\n    // rotation and 2x scale matrix\n    const mat3 m = mat3( 0.00,  1.60,  1.20,\n                        -1.60,  0.72, -0.96,\n                        -1.20, -0.96,  1.28 );\n    vec3  q = p;\n    float t = 0.0;\n\tfloat s = 1.0;\n    const int ioct = 11;\n    for( int i=0; i<ioct; i++ )\n    {\n        if( d>s*0.866 ) break; // early exit\n        if( s<th ) break;      // lod\n        \n        float n = s*sdBase(q);\n        float porous = mix(0.02,0.2,sin(iTime/10.)*.5+0.5);  // default 0.1;\n        float y = 0.3;//(sin(iTime/24.) * 0.5 + 0.5) * .3 + .1;\n        n = smax(n,d-porous*s,y*s); // default 0.3\n        d = smin(n,d      ,y*s);    // default 0.3\n        q = m*q;\n        s = 0.415*s;\n     \n        t += d; \n        q.z += -4.33*t*s; // deform things a bit\n    }\n    return vec2( d, t );\n}    \n\n\n\n\nfloat fbm( in vec2 p )\n{\n    float f = 0.0;\n    float s = 0.5;\n    for( int i=0; i<11; i++ )\n    {\n        float n = texture(iChannel1,p).x;\n        f += s*n;\n        p *= 2.01*mat2(4.0,-3.0,3.0,4.0)/5.0;\n        s *= 0.55;\n    }\n    return f;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, cos(cr),sin(cr));\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n//=========================================\n\nconst float precis = 0.0005;  // default 0.0005\n\nfloat cyl(vec2 p, float r) {\n  return length(p) - r;\n}\n\n\nvec2 off ( vec3 p) {\n  return vec2(sin(p.x/3.0), cos(p.y/4.1));\n}\nfloat layer (vec3 p, float r ) {\n  return length(p) -r ;\n}\nvec3 ro;\nvec3 ta;\nvec2 map( in vec3 p, in float dis )\n{\n    \n   \n    float spot = sph(p - ro   - vec3(0,0,2), .01); \n    \n    p.y *= .5; // default 1.0\n    // ground\n    float d = length(p-vec3(0.0,-250.0,0.0))-250.0;\n    d = p.y;\n    // terrain\n    vec2 dt = sdFbm( p, dis*precis, d );\n   \n    //float hole = box(p - ro, vec3(1.));\n    //dt.x = max(dt.x, -hole);\n    dt.x = min(dt.x, spot);\n    return dt;\n}\n\n\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*precis*t;\n    return normalize( e.xyy*map( pos + e.xyy, t ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, t ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, t ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, t ).x );\n}\n\n\n\nmat2 rot ( float a ) {\n  float ca = cos(a);\n  float sa = sin(a);\n  return mat2(ca, sa, -sa, ca);\n}\nvec3 jump( float t ) {\n  float sc = 4.;\n  float y = sin(iTime);\n  vec2 a = unit(floor(t)) *sc *y;;\n  vec2 b = unit(floor(t)+1.)*sc*y;\n  \n  float height = 5.6 + sin(iTime);\n  return ( mix( vec3(a.x, height,a.y), vec3(b.x,height,b.y), fract(t)));  \n\n}\n\nvec2 offset (float t ) {\n  \n  t /= 1.;\n  float a = cos(t) + cos(t*2.1)/2.3 + cos(t*4.2)/ 4.1;\n  float b = cos(t*1.1) + cos(t*1.9)/1.7 + cos(t*4.)/ 3.6;\n \n  \n \n  return vec2(a,b)/10.;\n\n}\n\nfloat getsss(vec3 p, vec3 r, float dist) {\n  return clamp(map(p+r*dist,1.).x*3.0,0.0,1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    \n \n    vec2 p = (2.0*(fragCoord)-iResolution.xy)/ iResolution.y;\n\n       \n    float time = iTime * 1.3;\n\n\t// scene setup\n  \n    float cr, fl, fad;\n    \n  \n    float n = time;\n   \n \n    float tt = time * .43;\n    \n \n    vec3 pole = vec3( cos(tt), 0., sin(-tt) )* 1.2;\n   \n    ro = vec3(offset(n), tt);\n    ta = vec3(offset(n+1.), tt +2.*sin(iTime/4.1));\n    ro.y +=.5;\n    ro += pole;\n    ta += pole;\n    \n    \n   \n    \n\n    \n    // camera matrix\t\n    mat3 ca = setCamera( ro, ta, cr );\n    \n    vec3 rd = ca * normalize( vec3(p.xy,2.0));\n    \n   \n\n\n  \n\n    // raymarch\n    float t = 0.;\n    vec2 h = vec2(0.0,0.0);\n    bool hit = false;\n    vec3 pos;\n    float dd;\n    float i;\n\tfor( i=0.; i<300.; i++ )\n\t{\n        pos = ro + t*rd;\n        float flip = sign(map(pos,t).x);\n\t\th = map( pos, t )*flip;\n        if( abs(h.x)<.0001) {//(precis*t)) {\n          \n          hit = true;\n          break;\n        }\n       if (t>300.0 ) {\n          break;\n       }\n\t   t += h.x   * 1.; // overstepping\n       dd += t;\n\t}\n   \n\t\n   \n    vec3 nor = calcNormal( pos, t );\n    vec3 light = normalize(vec3(1,0,3));\n    light.xz *= rot(iTime*.31);\n    \n    float shade = dot(nor,light) + .45; \n    float ao = pow(1. - i/300.,8.);\n    \n    float spec= pow(max(dot(reflect(light,nor),-rd),.0), 17.);\n    //float sss = getsss(ro,rd,1.2);\n    vec3 col = vec3(1.,.5,.3);\n    col *= pow(shade,1.2);\n    col *= pow(ao,1.2) ;\n    //col += spec  ;\n    //col *= sss * 20.;\n    \n    float spot = length(pos - ((ro + vec3(0.,0.,2.))  ));\n    \n    \n    col += .001/pow(spot,10.) * vec3(.6,.5,1);\n   \n  \n    \n    if (! hit) {\n      col = vec3(.9,.2,.1) * rd.y/.4; \n    }\n    \n    // fog\n    col = mix(col, vec3(.3), i/2000.);\n  \n  \n   \n    col = pow(col,vec3(.35));\n    \n  \n    fragColor = vec4( col, 1.0 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lsXWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[210, 210, 233, 233, 287], [288, 288, 311, 311, 438], [439, 439, 467, 467, 519], [521, 521, 550, 550, 585], [587, 587, 616, 616, 651], [653, 653, 685, 685, 720], [723, 723, 764, 764, 836], [839, 839, 880, 880, 952], [954, 954, 981, 981, 1007], [1008, 1008, 1045, 1186, 1401], [1403, 1426, 1451, 1451, 1529], [1530, 1979, 2002, 2002, 2133], [2134, 2134, 2184, 2220, 2981], [2990, 2990, 3014, 3014, 3235], [3237, 3237, 3289, 3289, 3466], [3562, 3562, 3590, 3590, 3616], [3619, 3619, 3639, 3639, 3684], [3685, 3685, 3717, 3717, 3743], [3762, 3762, 3799, 3799, 4152], [4155, 4155, 4199, 4199, 4421], [4425, 4425, 4447, 4447, 4523], [4524, 4524, 4546, 4546, 4773], [4775, 4775, 4799, 4799, 4960], [4962, 4962, 5004, 5004, 5054], [5057, 5057, 5114, 5114, 6900]], "test": "untested"}
{"id": "ftSSRR", "name": "Pinku", "author": "adamgoodapp", "description": "FBM", "tags": ["cineshader"], "likes": 99, "viewed": 107116, "published": 3, "date": "1626861993", "time_retrieved": "2024-07-30T19:09:52.645210", "image_code": "float colormap_red(float x) {\n    if (x < 0.0) {\n        return 54.0 / 255.0;\n    } else if (x < 20049.0 / 82979.0) {\n        return (829.79 * x + 54.51) / 255.0;\n    } else {\n        return 1.0;\n    }\n}\n\nfloat colormap_green(float x) {\n    if (x < 20049.0 / 82979.0) {\n        return 0.0;\n    } else if (x < 327013.0 / 810990.0) {\n        return (8546482679670.0 / 10875673217.0 * x - 2064961390770.0 / 10875673217.0) / 255.0;\n    } else if (x <= 1.0) {\n        return (103806720.0 / 483977.0 * x + 19607415.0 / 483977.0) / 255.0;\n    } else {\n        return 1.0;\n    }\n}\n\nfloat colormap_blue(float x) {\n    if (x < 0.0) {\n        return 54.0 / 255.0;\n    } else if (x < 7249.0 / 82979.0) {\n        return (829.79 * x + 54.51) / 255.0;\n    } else if (x < 20049.0 / 82979.0) {\n        return 127.0 / 255.0;\n    } else if (x < 327013.0 / 810990.0) {\n        return (792.02249341361393720147485376583 * x - 64.364790735602331034989206222672) / 255.0;\n    } else {\n        return 1.0;\n    }\n}\n\nvec4 colormap(float x) {\n    return vec4(colormap_red(x), colormap_green(x), colormap_blue(x), 1.0);\n}\n\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res*res;\n}\n\nconst mat2 mtx = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.500000*noise( p + iTime  ); p = mtx*p*2.02;\n    f += 0.031250*noise( p ); p = mtx*p*2.01;\n    f += 0.250000*noise( p ); p = mtx*p*2.03;\n    f += 0.125000*noise( p ); p = mtx*p*2.01;\n    f += 0.062500*noise( p ); p = mtx*p*2.04;\n    f += 0.015625*noise( p + sin(iTime) );\n\n    return f/0.96875;\n}\n\nfloat pattern( in vec2 p )\n{\n\treturn fbm( p + fbm( p + fbm( p ) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n\tfloat shade = pattern(uv);\n    fragColor = vec4(colormap(shade).rgb, shade);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"My Shader 0\",\n\t\"description\": \"Lorem ipsum dolor\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftSSRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 203], [205, 205, 236, 236, 572], [574, 574, 604, 604, 989], [991, 991, 1015, 1015, 1093], [1096, 1096, 1116, 1116, 1186], [1188, 1188, 1208, 1208, 1443], [1498, 1498, 1519, 1519, 1846], [1848, 1848, 1876, 1876, 1918], [1920, 1920, 1977, 1977, 2096]], "test": "untested"}
{"id": "7lsSDs", "name": "Fractal 64_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 7, "viewed": 413, "published": 3, "date": "1626858580", "time_retrieved": "2024-07-30T19:09:53.572731", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=0.;\n        ++i<160.;\n        O.xyz+=mix(vec3(1),H(g*.15),.8)*.01*exp(-10./e/i/i)\n    )\n    {\n        p=g*d;\n        p.z-=2.;\n        p=R(p,normalize(vec3(1,2,3)),iTime*.1);\n        s=2.;\n        for(int i=0;i++<12;p=abs(p)*e-vec3(1,2,1))\n            p=.5-abs(p-.6),\n            p.x<p.z?p=p.zyx:p,\n            p.z<p.y?p=p.xzy:p,\n            s*=e=1.3;\n        g+=e=abs(p.z)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lsSDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 636]], "test": "untested"}
{"id": "stXSWl", "name": "Game of Life & Universe", "author": "chenglou", "description": "Conway's Game of Life, styled a bit.\n\n[b]Click and drag to create new life.[/b]", "tags": ["conway", "gameoflife"], "likes": 8, "viewed": 312, "published": 3, "date": "1626858342", "time_retrieved": "2024-07-30T19:09:54.396528", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float zoom = 1.; // debug tweak!\n    vec2 uv = fragCoord.xy / iResolution.xy * zoom;\n\n    fragColor = texture(iChannel0, uv);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float hash12(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n    vec2 map = 1. / iResolution.xy;\n    vec2 uv = fragCoord * map;\n\n    vec4 surrounding = \n        texture(iChannel0, uv + vec2(-1, -1) * map) +\n        texture(iChannel0, uv + vec2(-1, 0) * map) +\n        texture(iChannel0, uv + vec2(-1, 1) * map) +\n        texture(iChannel0, uv + vec2(0, -1) * map) +\n        texture(iChannel0, uv + vec2(0, 1) * map) +\n        texture(iChannel0, uv + vec2(1, -1) * map) +\n        texture(iChannel0, uv + vec2(1, 0) * map) +\n        texture(iChannel0, uv + vec2(1, 1) * map);\n\n    int count = int(surrounding.w);\n\n    vec4 self = texture(iChannel0, uv);\n    float oldAlive = self.w;\n    float newAlive = 0.;\n    if (count == 3 || (oldAlive == 1. && count == 2)) newAlive = 1.; // core logic\n    \n    vec3 color;\n    float rand = hash12(uv * 999. + iTime);\n    \n    if (iFrame == 0) {\n        newAlive = step(0.5, rand);\n        color = vec3(.5, .6, .9) * (uv + 0.3).xyx;\n    } else if (iMouse.z > 0.001 && rand > 0.9 && distance(fragCoord, iMouse.xy) < (sin(iTime * 5.) / 4. + 1.) * 60.) {\n        newAlive = 1.;\n        color = vec3(.5, .7, .8) + vec2(sin(iTime), cos(iTime)).xyx / 3.;\n    } else if (oldAlive == 0. && newAlive == 1.) {\n        color = mix(surrounding.rgb / 8., self.rgb, .2) * 1.1;\n    } else if (newAlive == 0.) {\n        color = mix(surrounding.rgb / 8., self.rgb, .8) * 0.995;\n    } else {\n        color = self.rgb;\n    }\n    \n    fragColor = vec4(color, newAlive);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec4 bufferA = texture(iChannel0, uv);\n    float alive = bufferA.w;\n    \n    float intensity;\n    if (alive == 1.) {\n        intensity = 5.; // highlight currently live particles more\n    } else {\n        intensity = texture(iChannel1, uv).w * 0.95; // decrease over time\n        intensity = clamp(intensity, .5, 999.); // don't make it too dark\n    }\n\n    vec3 col = bufferA.rgb * intensity;\n    \n    fragColor = vec4(col, intensity);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stXSWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 189]], "test": "untested"}
{"id": "7tsSDs", "name": "Fractal 63_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 6, "viewed": 378, "published": 3, "date": "1626856661", "time_retrieved": "2024-07-30T19:09:55.283157", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(1),H(g*.15),.8)*1./e/8e3\n    )\n    {\n        p=g*d;\n        p.z-=3.5;\n        p=R(p,normalize(vec3(1,2,3)),iTime*.3);\n        s=1.;\n        for(int i=0;i++<12;p=abs(p)*e-vec3(1,2,1))\n            p=.2-abs(p-.6),\n            p.x<p.z?p=p.zyx:p,\n            p.z<p.y?p=p.xzy:p,\n            s*=e=1.22;\n         g+=e=abs(p.x)/s+.001;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tsSDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 636]], "test": "untested"}
{"id": "stsXDl", "name": "Fractal 62_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 15, "viewed": 481, "published": 3, "date": "1626850961", "time_retrieved": "2024-07-30T19:09:56.237605", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(1),H(g*.1),.8)*1./e/8e3\n    )\n    {\n        p=g*d;\n        p.z+=iTime*1.5;\n        a=10.;\n        p=mod(p-a,a*2.)-a;\n        s=6.;\n        for(int i=0;i++<8;){\n            p=.3-abs(p);\n            p.x<p.z?p=p.zyx:p;\n            p.z<p.y?p=p.xzy:p;\n            s*=e=1.4+sin(iTime*.1)*.1;\n            p=abs(p)*e-\n                vec3(\n                    5.+sin(iTime*.3+.5*sin(iTime*.3))*3.,\n                    120,\n                    8.+cos(iTime*.5)*5.\n                 );\n         }\n         g+=e=length(p.yz)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stsXDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 825]], "test": "untested"}
{"id": "sllSDl", "name": "Tileable 3d Noise + derivs", "author": "granito", "description": "Combined iq's https://www.shadertoy.com/view/4dffRH\nw/\nDave Hoskins' https://www.shadertoy.com/view/4dlGW2\n---\nI'll be adapting this to produce tileable volume textures inside of unreal engine.", "tags": ["procedural", "3d", "noise", "tiled", "perlin", "tiling", "tileable", "analytic"], "likes": 4, "viewed": 574, "published": 3, "date": "1626844670", "time_retrieved": "2024-07-30T19:09:57.145179", "image_code": "#define SHOW_TILING\n#define TILES 3.0 // Use 1.0 for normal tiling across whole texture.\n#define SCALE 40.0 // noise scale inside tile\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord / iResolution.xy;\n\tvec2 uv = (p-0.5) * vec2(1., iResolution.y/iResolution.x) + 0.5;\n    \n\n\t#ifdef SHOW_TILING\n\tuv *= TILES;\n\t#endif\n       \n    vec4 f = noised(vec3(uv,iTime/SCALE), SCALE);\n    f = f * 0.5 + 0.5;\n    fragColor = mix( vec4(f.x), vec4(vec3(f.yzw),0.0) , vec4(round(fract(iTime*0.25f))) );\n    \n    \n\t#ifdef SHOW_TILING\n\t// Flash tile borders...\n\tvec2 pixel = TILES / iResolution.xy;\n\tif (mod(iTime-2.0, 4.0) < 2.0)\n\t{\n\t\tvec2 first \t\t= step(pixel, uv);\n\t\tuv  = step(fract(uv), pixel);\t// Only add one line of pixels per tile.\n\t\tfragColor.xyz = mix(fragColor.xyz, vec3(1.0, 1.0, 0.0), (uv.x + uv.y) * first.x * first.y);\n\t}\n\t#endif    \n}", "image_inputs": [], "common_code": "vec3 hash( vec3 p , float scale) // replace this by something better\n{\n\tp = mod(p, scale);\n    \n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n// return value noise (in x) and its derivatives (in yzw)\nvec4 noised( in vec3 x, in float scale )\n{\n    x *= scale;\n\n    // grid\n    vec3 i = floor(x);\n    vec3 w = fract(x);\n    \n    #if 1\n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    #else\n    // cubic interpolant\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    #endif    \n    \n    // gradients\n    vec3 ga = hash( i+vec3(0.0,0.0,0.0), scale );\n    vec3 gb = hash( i+vec3(1.0,0.0,0.0), scale );\n    vec3 gc = hash( i+vec3(0.0,1.0,0.0), scale );\n    vec3 gd = hash( i+vec3(1.0,1.0,0.0), scale );\n    vec3 ge = hash( i+vec3(0.0,0.0,1.0), scale );\n\tvec3 gf = hash( i+vec3(1.0,0.0,1.0), scale );\n    vec3 gg = hash( i+vec3(0.0,1.0,1.0), scale );\n    vec3 gh = hash( i+vec3(1.0,1.0,1.0), scale );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sllSDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[136, 136, 193, 193, 867]], "test": "untested"}
{"id": "7tsSWl", "name": "Pong as a shader", "author": "BigChungus21220", "description": "the game pong\nleft uses shift and ctrl to move, right uses up and down arrows", "tags": ["game", "pong"], "likes": 3, "viewed": 285, "published": 3, "date": "1626836762", "time_retrieved": "2024-07-30T19:09:57.913126", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    ivec2 iCoord = ivec2(fragCoord);\n    if (iCoord.y == 0) {\n        col = vec4(1); //color over data pixels\n    }\n    fragColor = vec4(col.rgb, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\nto do\n- add enemy ai option\n*/\n\n//vars\nfloat ball_screen_per_frame = 0.1;\nfloat paddle_screen_per_frame = 0.05;\nvec2 score;\nconst int ARROW_UP = 38;\nconst int ARROW_DOWN = 40;\nconst int SHIFT = 16;\nconst int CTRL = 17;\nconst int R = 82;\n\nfloat rand(vec2 uv){ // generate random numbers\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nbool scorepx( vec2 uv, vec2 offset){ // pixels for numbers\n    float x = uv.x - offset.x;\n    float y = uv.y - offset.y;\n    if (x <= 0.011 && x >= -0.011 && y <= 0.011 && y >= -0.011){\n        return true;\n    }\n    return false;\n}\n\nbool letter(vec2 uv, vec2 winpos, vec2 losepos){\nif(scorepx(uv,vec2(0,0)+winpos)||scorepx(uv,vec2(0,0.02)+winpos)||scorepx(uv,vec2(0,0.04)+winpos)||\nscorepx(uv,vec2(00,0.08)+winpos)||scorepx(uv,vec2(0.04,0)+winpos)||scorepx(uv,vec2(0.04,0.02)+winpos)||scorepx(uv,vec2(0.04,0.04)+winpos)||\nscorepx(uv,vec2(0.04,0.06)+winpos)||scorepx(uv,vec2(0.06,0.06)+winpos)||scorepx(uv,vec2(0.08,0)+winpos)||scorepx(uv,vec2(0.08,0.02)+winpos)||\nscorepx(uv,vec2(0.08,0.04)+winpos)||scorepx(uv,vec2(0.08,0.06)+winpos)||scorepx(uv,vec2(-0.04,0)+winpos)||scorepx(uv,vec2(-0.04,0.02)+winpos)||\nscorepx(uv,vec2(-0.04,0.04)+winpos)||scorepx(uv,vec2(-0.04,0.06)+winpos)||scorepx(uv,vec2(-0.06,0)+winpos)||scorepx(uv,vec2(-0.08,0)+winpos)||\nscorepx(uv,vec2(-0.08,0.02)+winpos)||scorepx(uv,vec2(-0.08,0.04)+winpos)||scorepx(uv,vec2(-0.08,0.06)+winpos)||scorepx(uv,vec2(-0.1,0)+winpos)||\nscorepx(uv,vec2(-0.12,0)+winpos)||scorepx(uv,vec2(-0.12,0.02)+winpos)||scorepx(uv,vec2(-0.12,0.04)+winpos)||scorepx(uv,vec2(-0.12,0.06)+winpos)){return true;}\nif(scorepx(uv,vec2(0,0)+losepos)||scorepx(uv,vec2(0,0.02)+losepos)||scorepx(uv,vec2(0,0.04)+losepos)||scorepx(uv,vec2(0,0.06)+losepos)||\nscorepx(uv,vec2(-0.02,0.06)+losepos)||scorepx(uv,vec2(-0.02,0)+losepos)||scorepx(uv,vec2(-0.04,0)+losepos)||scorepx(uv,vec2(-0.04,0.02)+losepos)||\nscorepx(uv,vec2(-0.04,0.04)+losepos)||scorepx(uv,vec2(-0.04,0.06)+losepos)||scorepx(uv,vec2(-0.08,0)+losepos)||scorepx(uv,vec2(-0.08,0.02)+losepos)||\nscorepx(uv,vec2(-0.08,0.04)+losepos)||scorepx(uv,vec2(-0.08,0.06)+losepos)||scorepx(uv,vec2(-0.08,0.08)+losepos)||scorepx(uv,vec2(0.04,0.06)+losepos)||\nscorepx(uv,vec2(0.06,0.06)+losepos)||scorepx(uv,vec2(0.08,0.06)+losepos)||scorepx(uv,vec2(0.04,0)+losepos)||scorepx(uv,vec2(0.06,0)+losepos)||\nscorepx(uv,vec2(0.08,0)+losepos)||scorepx(uv,vec2(0.08,0.02)+losepos)||scorepx(uv,vec2(0.06,0.04)+losepos)||scorepx(uv,vec2(0.04,0.04)+losepos)||\nscorepx(uv,vec2(0.12,0)+losepos)||scorepx(uv,vec2(0.14,0)+losepos)||scorepx(uv,vec2(0.16,0)+losepos)||scorepx(uv,vec2(0.12,0.02)+losepos)||\nscorepx(uv,vec2(0.12,0.04)+losepos)||scorepx(uv,vec2(0.14,0.04)+losepos)||scorepx(uv,vec2(0.16,0.04)+losepos)||scorepx(uv,vec2(0.12,0.06)+losepos)||\nscorepx(uv,vec2(0.14,0.06)+losepos)||scorepx(uv,vec2(0.16,0.06)+losepos)){return true;}\nreturn false;\n}\n\nbool num(float num, vec2 offset, vec2 uv){ // dump for num coords\nif(num==1.0&&(scorepx(uv,vec2(0,0)+offset)||scorepx(uv,vec2(0,0.02)+offset)||scorepx(uv,vec2(0,0.04)+offset)||scorepx(uv,vec2(0,0.06)+offset)\n||scorepx(uv,vec2(0,0.08)+offset)||scorepx(uv,vec2(-0.02,0.06)+offset)||scorepx(uv,vec2(0.02,0)+offset)||scorepx(uv,vec2(-0.02,0)+offset))){return true;}\nif(num==2.0&&(scorepx(uv,vec2(-0.02,0)+offset)||scorepx(uv,vec2(0.02,0)+offset)||scorepx(uv,vec2(0,0)+offset)||scorepx(uv,vec2(-0.02,0.02)+offset)\n||scorepx(uv,vec2(-0.02,0.04)+offset)||scorepx(uv,vec2(0.02,0.06)+offset)||scorepx(uv,vec2(0.02,0.08)+offset)||scorepx(uv,vec2(0,0.04)+offset)\n||scorepx(uv,vec2(0.02,0.04)+offset)||scorepx(uv,vec2(0,0.04)+offset)||scorepx(uv,vec2(0,0.08)+offset)||scorepx(uv,vec2(-0.02,0.08)+offset))){return true;}\nif(num==3.0&&(scorepx(uv,vec2(-0.02,0)+offset)||scorepx(uv,vec2(0.02,0)+offset)||scorepx(uv,vec2(0,0)+offset)||scorepx(uv,vec2(0.02,0.02)+offset)\n||scorepx(uv,vec2(-0.02,0.04)+offset)||scorepx(uv,vec2(0.02,0.06)+offset)||scorepx(uv,vec2(0.02,0.08)+offset)||scorepx(uv,vec2(0,0.04)+offset)\n||scorepx(uv,vec2(0.02,0.04)+offset)||scorepx(uv,vec2(0,0.04)+offset)||scorepx(uv,vec2(0,0.08)+offset)||scorepx(uv,vec2(-0.02,0.08)+offset))){return true;}\nif(num==4.0&&(scorepx(uv,vec2(0.02,0)+offset)||scorepx(uv,vec2(0.02,0.02)+offset)||scorepx(uv,vec2(-0.02,0.04)+offset)||scorepx(uv,vec2(-0.02,0.06)+offset)\n||scorepx(uv,vec2(0.02,0.06)+offset)||scorepx(uv,vec2(0.02,0.08)+offset)||scorepx(uv,vec2(0,0.04)+offset)||scorepx(uv,vec2(0.02,0.04)+offset)\n||scorepx(uv,vec2(0,0.04)+offset)||scorepx(uv,vec2(-0.02,0.08)+offset))){return true;}if(num>=5.0&&(scorepx(uv,vec2(-0.02,0)+offset)\n||scorepx(uv,vec2(0.02,0)+offset)||scorepx(uv,vec2(0,0)+offset)||scorepx(uv,vec2(0.02,0.02)+offset)||scorepx(uv,vec2(-0.02,0.04)+offset)\n||scorepx(uv,vec2(-0.02,0.06)+offset)||scorepx(uv,vec2(0.02,0.08)+offset)||scorepx(uv,vec2(0,0.04)+offset)||scorepx(uv,vec2(0.02,0.04)+offset)\n||scorepx(uv,vec2(0,0.04)+offset)||scorepx(uv,vec2(0,0.08)+offset)||scorepx(uv,vec2(-0.02,0.08)+offset))){return true;}\nreturn false;\n}\n\nbool winlose(vec2 uv){\n    vec2 winpos, losepos;\n    if (score.x >= 5.0){\n        winpos = vec2(-0.4,0);\n        losepos = vec2(0.4,0);\n        return letter(uv, winpos, losepos);\n    }\n    if (score.y >= 5.0){\n        winpos = vec2(0.4,0);\n        losepos = vec2(-0.4,0);\n        return letter(uv, winpos, losepos);\n    }\n    return false;\n}\n\nbool draw_score(vec2 uv) { // displays scores\n    bool score_r;\n    bool score_l;\n    vec2 r_offset = vec2(-0.1, 0.35);\n    vec2 l_offset = vec2(0.1, 0.35);\n    if (num(score.x, r_offset, uv)){ return true; }\n    if (num(score.y, l_offset, uv)){ return true; }\n    return false;\n}\n\nvoid paddleposition(inout vec2 paddlepos, inout vec2 paddlepos2){ // test inputs, move paddles\n    if (texelFetch(iChannel1, ivec2(ARROW_UP, 0), 0).x == 1.0 && paddlepos.y + 0.1 < 0.47){\n        paddlepos.y += paddle_screen_per_frame/6.0;\n    } else if (texelFetch(iChannel1, ivec2(ARROW_DOWN, 0), 0).x == 1.0 && paddlepos.y - 0.1 > -0.47){\n        paddlepos.y -= paddle_screen_per_frame/6.0;\n    }\n    if (texelFetch(iChannel1, ivec2(SHIFT, 0), 0).x == 1.0 && paddlepos2.y + 0.1 < 0.47){\n        paddlepos2.y += paddle_screen_per_frame/6.0;\n    } else if (texelFetch(iChannel1, ivec2(CTRL, 0), 0).x == 1.0 && paddlepos2.y - 0.1 > -0.47){\n        paddlepos2.y -= paddle_screen_per_frame/6.0;\n    }\n}\n\nvoid pos(inout vec2 pos, in vec2 paddlepos, in vec2 paddlepos2, inout vec2 direction){ // check ball collision, move ball\n    float ball_radius = 0.01;\n   \n    //hit barrier\n    if (pos.y <= -(0.48) || pos.y >= 0.48 + ball_radius){\n        direction = vec2(direction.x, -direction.y);\n    }\n   \n    //hit paddle\n    if (\n        pos.x <= paddlepos.x + 0.01 + ball_radius &&\n        pos.x >= paddlepos.x - (0.01 + ball_radius) &&\n        pos.y <= paddlepos.y + 0.1 + ball_radius &&\n        pos.y >= paddlepos.y-(0.1 + ball_radius)\n    ){\n        float hitpos = (pos.y-paddlepos.y)*9.0;\n        direction = normalize(vec2( -( 1.0 - hitpos), hitpos));\n        pos += sign(direction.x) * 0.01;\n    }\n   \n    //hit paddle 2\n    if (\n        pos.x <= paddlepos2.x + 0.01 + ball_radius &&\n        pos.x >= paddlepos2.x - (0.01 + ball_radius) &&\n        pos.y <= paddlepos2.y + 0.1 + ball_radius &&\n        pos.y >= paddlepos2.y-(0.1 + ball_radius)\n    ){\n        direction = vec2(-direction.x, direction.y);\n        pos += sign(direction.x) * 0.01;\n    }\n   \n    //leave map\n    if (pos.x < -1.0) { //leave to left\n        pos = vec2(0);\n        direction = vec2(0);\n        score.y ++;\n    }\n    if (pos.x > 1.0){ //leave to right\n        pos = vec2(0);\n        direction = vec2(0);\n        score.x ++;\n    }\n   \n    if (score.x < 5.0 && score.y < 5.0){\n        pos += direction*ball_screen_per_frame/6.0;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) //main\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 col;\n\n    //get frame data\n    vec2 direction = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    vec2 currentpos = texelFetch(iChannel0, ivec2(1, 0), 0).xy;\n    vec2 paddlepos = texelFetch(iChannel0, ivec2(2, 0), 0).xy;\n    vec2 paddlepos2 = texelFetch(iChannel0, ivec2(3, 0), 0).xy;\n    score = texelFetch(iChannel0, ivec2(4, 0), 0).xy;\n\n    //fix missing data\n    if (direction == vec2(0)){\n        float ran_direction = rand( vec2( iTime)) - 0.5;\n        float ran_side = sign( round( mod( rand( vec2( iTime)), 0.01)*100.0) - 0.5);\n        direction = vec2((1.0 - ran_direction*sign(ran_direction))*ran_side, ran_direction);\n    }\n    if (paddlepos == vec2(0)){\n        paddlepos = vec2(0.8, 0.0);\n    }\n    if (paddlepos2 == vec2(0)){\n        paddlepos2 = vec2(-0.8, 0.0);\n    }\n   \n    //set pos\n    paddleposition(paddlepos, paddlepos2);\n    pos(currentpos, paddlepos, paddlepos2, direction);\n   \n    //color in\n    if (currentpos.x+0.01 >= uv.x && currentpos.x-0.01 <= uv.x && currentpos.y+0.01 >= uv.y && currentpos.y-0.01 <= uv.y){ col = vec3(1); } //ball\n   \n    if (uv.y>0.48 || uv.y<-0.48){ col = vec3(1); } //top + bottom border\n   \n    if (paddlepos.x+0.01 >= uv.x && paddlepos.x-0.01 <= uv.x && paddlepos.y+0.1 >= uv.y && paddlepos.y-0.1 <= uv.y){ col = vec3(1); } //paddle\n   \n    if (paddlepos2.x+0.01 >= uv.x && paddlepos2.x-0.01 <= uv.x && paddlepos2.y+0.1 >= uv.y && paddlepos2.y-0.1 <= uv.y){ col = vec3(1); } //paddle 2\n   \n    if (uv.x<0.005 && uv.x>-0.005 && mod(uv.y,0.04)>0.02){ col = vec3(1); } //middle border\n   \n    if ( draw_score(uv) ){ col = vec3(1); } // score\n   \n    if ( winlose(uv) ){ col = vec3(1); } //win / lose\n   \n    //check for restart\n    if (texelFetch(iChannel1, ivec2(R, 0), 0).x == 1.0){\n        score = vec2(0);\n        paddlepos = vec2(0);\n        paddlepos2 = vec2(0);\n        currentpos = vec2(0);\n        direction = vec2(0);\n    }\n   \n    //store frame data\n    ivec2 iCoord = ivec2(fragCoord);\n   \n    if (iCoord == ivec2(0,0)) {\n        col = vec3(direction, 0.0); //ball direction\n    }\n    if (iCoord == ivec2(1,0)) {\n        col = vec3(currentpos, 0.0); //ball position\n    }\n    if (iCoord == ivec2(2,0)) {\n        col = vec3(paddlepos, 0.0); //paddle position\n    }\n    if (iCoord == ivec2(3,0)) {\n        col = vec3(paddlepos2, 0.0); //paddle 2 position\n    }\n    if (iCoord == ivec2(4,0)) {\n        col = vec3(score, 0.0); //scores\n    }\n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tsSWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 294]], "test": "untested"}
{"id": "7llSWl", "name": "Sin01", "author": "lambmeow", "description": "messing around", "tags": ["sin", "cos", "other"], "likes": 3, "viewed": 219, "published": 3, "date": "1626836337", "time_retrieved": "2024-07-30T19:09:58.680075", "image_code": "void mainImage( out vec4 c, in vec2 f )\n{\n  vec2 u = f/iResolution.xy;\n  \n  vec4 a = texture(iChannel0, u);\n  c = a;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 c, in vec2 f )\n{\n  float t = mod(iTime, 100.);\n  vec2 r = iResolution.xy, u = (((2.*f-r)/r.y) * 20.), atu =  (u);\n  c = vec4(cos(dot(sin(atu * sin(iTime / 10.)), cos(atu + iTime)) * 10.));\n\n}", "buffer_a_inputs": [], "buffer_b_code": "void mainImage( out vec4 c, in vec2 f )\n{\n  vec2 u = f/iResolution.xy;\n  vec4 a = texture(iChannel0, u);\n  c = a - vec4(sin(a.r + iTime),cos(a.g + iTime), 0,0);\n  c += texture(iChannel1, u) * 0.95;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7llSWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 118]], "test": "untested"}
{"id": "flsXDs", "name": "Rainbow Spiral (bouncy!)", "author": "froggynotacon", "description": "Fork of https://www.shadertoy.com/view/fllSWl\n\nInstead of using the mouse coordinates to indicate the origin, it just uses simple sin and cos functions.\n", "tags": ["rainbow", "fork"], "likes": 5, "viewed": 297, "published": 3, "date": "1626834188", "time_retrieved": "2024-07-30T19:09:59.646491", "image_code": "\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/vec2(iResolution.y, iResolution.y);\n    vec2 m = vec2(abs(sin(iTime /4.))* iResolution.x, abs(cos(iTime *.95)) * iResolution.y)/vec2(iResolution.y, iResolution.y);\n    vec2 v = st - m;\n    v = v / 0.01;\n    float tau = 6.283185;\n    float hue = atan(v.x, v.y)/tau;\n    hue = hue + length(v)/80. - iTime/2.;\n    vec3 rgb = hsl2rgb ( vec3(hue, 1., \n                              cos(2.0-length(v)*3.5)));\n    fragColor = vec4(rgb.r,rgb.g,rgb.b,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flsXDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 29, 29, 171], [173, 173, 230, 230, 707]], "test": "untested"}
{"id": "ftlSWs", "name": "DCT basis functions", "author": "KylBlz", "description": "just wanted to render https://en.wikipedia.org/wiki/Discrete_cosine_transform", "tags": ["cosine", "discrete", "transform", "basis"], "likes": 4, "viewed": 302, "published": 3, "date": "1626820278", "time_retrieved": "2024-07-30T19:10:00.571019", "image_code": "const float pi  = 3.1416;\nconst float eps = 0.0001;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // make it look like the wiki page\n    vec2 kl = fragCoord / iResolution.yy;\n    // vertical flip\n    kl.y = 1.0 - kl.y;\n    // 8x8\n    float MN = 8.0;\n    kl *= MN;\n\n    // lower case m,n vars\n    vec2 mn = floor(kl);\n    // JPEG flips every other?\n    float sgn = mod(mn.x + mn.y, 2.0) * -2.0 + 1.0;\n\n    // MD-DCT-IV, slightly vectorized\n    vec2 dct = cos(mn*kl*pi);\n    float col = dct.x * dct.y * sgn * 0.5 + 0.5;\n\n    // red grid\n    float w = 1.0 - eps - MN / iResolution.y;\n    float g = step(w, fract(kl.x)) + step(w, fract(kl.y));\n    // black out past MN (range)\n    float r = step(kl.x, MN);\n    \n    // output to screen\n    fragColor = vec4(mix(vec3(col), vec3(1.0, 0.0, 0.0), g) * r, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftlSWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 110, 149, 821]], "test": "untested"}
{"id": "NtsXWl", "name": "JS Bach - Kyrie Eleison in Bm", "author": "incription", "description": "last one I swear, I am trying different sounds and note types. Maybe someone can increase framerate and make cooler notes, I got inspiration from https://www.youtube.com/c/smalin/videos", "tags": ["raymarching", "sound", "bach"], "likes": 11, "viewed": 270, "published": 3, "date": "1626815828", "time_retrieved": "2024-07-30T19:10:01.891488", "image_code": "// Fork of \"J.S.Bach - Badinerie BMV1067\" by incription. https://shadertoy.com/view/ftfXWl\n// 2021-07-20 20:42:17\n\n// Fork of \"Toccata and Fugue in D Minor\" by incription. https://shadertoy.com/view/NlsXWH\n// 2021-07-20 00:13:14\n\n#define F(x,y) col = mix(x, col, smoothstep(0., fwidth(y), y))\nvec3 HUEtoRGB(in float hue)\n{\n    // Hue [0..1] to RGB [0..1]\n    // See http://www.chilliant.com/rgb2hsv.html\n    vec3 rgb = abs(hue * 6. - vec3(3, 2, 4)) * vec3(1, -1, -1) + vec3(-1, 2, 2);\n    return clamp(rgb, 0., 1.);\n}\n\nvec3 HSVtoRGB(in vec3 hsv)\n{\n    // Hue-Saturation-Value [0..1] to RGB [0..1]\n    vec3 rgb = HUEtoRGB(hsv.x);\n    return ((rgb - 1.) * hsv.y + 1.) * hsv.z;\n}\n\nmat2 rotationMatrix(float angle)\n{\n\tangle *= pi / 180.0;\n    float s=sin(angle), c=cos(angle);\n    return mat2( c, -s, s, c );\n}\n\nfloat sdArc( in vec2 p, in vec2 sc, in float ra, float rb )\n{\n    // sc is the sin/cos of the arc's aperture\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\nfloat sdNote( in vec2 p, in vec2 size )\n{\n    float r = size.y * .8;\n    p -= size.x / 2.;\n    float d = sdSegment(p, vec2(r - .002, .0), vec2(r - .002, .05)) - .002;\n\n    d = min(d, length(p) - r);\n    \n    if(size.x > .05) {\n        d = min(d, sdSegment(p, vec2(0,0), vec2(-size.x*2.,0)) - .006);\n        \n        //float tb = .5;\n        //vec2  sc = vec2(sin(tb),cos(tb));\n        //float R = .5 * size.x * asin(tb / 2.);\n\n        //d = min(d, sdArc(p + vec2(size.x / 2., sqrt(R*R - size.x * size.x * .5 )), sc, size.x, 0.005));\n    }\n    \n    return d;\n}\n\nvec3 background(vec2 uv) {\n    vec3 col = vec3(1);\n    \n    return col;\n}\n\nvec3 cam(vec2 uv) {\n    vec3 col = background(uv);\n    vec3 nc;\n    \n    //int tx = int(uv.y*512.0);\n    //float fft = texelFetch( iChannel0, ivec2(tx, 0), 0).x;\n    \n    float t = (iTime - t_offset);\n    float temp;\n    float scale = .2;\n    int i;\n    float latest_t = 0.;\n    \n    for(i = 0; i < n_notes; i++) {\n        vec4 note = notes(i);\n        vec2 pos = vec2((note.x - t + note.z / 2.) * scale, -.5 + note.y / 128. - 1. / 128.) * vec2(1, 2) - uv;\n        if(abs(pos.x) < .5) {\n        \n        vec2 size = vec2((note.z / 2.) * scale, 1. / 64.);\n\n        float nt = min(1. - max(0., t-note.x) / note.z, 1.);\n        if(t-(note.x+note.z) > 0.) nt = 1.;\n        \n        vec2 glowpos = pos;\n        vec2 glowsize = size;\n        \n        nc = vec3(0,0,0); //HSVtoRGB(vec3(note.w/10.,1.,1.));\n        \n        nt = 1. + log(nt);\n        float boxd = sdNote(pos, size);\n        //vec3 glow = nc * (0.000008 / boxd);\n        F(nc, boxd);\n        \n        //c += 0.5 * vec3(0.584,0.388,0.612) * d * float(note.w == 0.);\n        //c += vec3(0.584,0.388,0.612) * d * float(note.w == 1.);\n        //c += vec3(0.118,0.553,0.663) * d * float(note.w == 2.);\n        //c += vec3(0.859,0.514,0.122) * d * float(note.w == 3.);\n        \n        pos -= .5;\n        if( sdBox(pos + uv, vec2(size.x, 2.)) < 0. )\n            latest_t = t;\n        }\n    }\n    \n    return col;\n}\n\nvec3 addCol(vec3 col, vec3 col2) {\n    return 1. - (col) * (1. - col2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 col = cam(uv);\n    float inPlay = sdBox(uv, vec2(.01, 1.));\n    if(inPlay <= 0.) col = mix(addCol(col, vec3(1, 0, 0)), col, smoothstep(0.0, fwidth(inPlay), inPlay));\n    //vec3 col = 1. - ((1. - col) * mix(0., 1., min(1. ,uv.x * 10.)));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define n_notes 902\n#define t_offset 1.\n#define t_length 96.501\n#define SPEED 1.0\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec4 notes(int n)\n{\n    const vec4 _[n_notes] = vec4[n_notes](vec4(0,83,0.3,0),vec4(0,47,0.0984375,0),vec4(0.3,47,0.09843750000000001,0),vec4(0.3,86,0.15000000000000002,0),vec4(0.45,83,0.14999999999999997,0),vec4(0.6,50,0.20156249999999998,0),vec4(0.6,78,0.29999999999999993,0),vec4(0.8999999999999999,83,0.1499999999999999,0),vec4(0.8999999999999999,47,0.20156249999999987,0),vec4(1.0499999999999998,78,0.1499999999999999,0),vec4(1.1999999999999997,54,0.2015625000000001,0),vec4(1.1999999999999997,74,0.30000000000000004,0),vec4(1.4999999999999998,78,0.1499999999999999,0),vec4(1.4999999999999998,50,0.20156249999999987,0),vec4(1.6499999999999997,74,0.1499999999999999,0),vec4(1.7999999999999996,59,0.20156249999999987,0),vec4(2.0999999999999996,54,0.2015625000000001,0),vec4(1.7999999999999996,71,0.6000000000000003,0),vec4(2.4,66,0.1499999999999999,0),vec4(2.4,50,0.2015625000000001,0),vec4(2.55,71,0.15000000000000036,0),vec4(2.7,74,0.1499999999999999,0),vec4(2.7,47,0.2015625000000001,0),vec4(2.85,71,0.15000000000000036,0),vec4(3.0000000000000004,73,0.1499999999999999,0),vec4(3.0000000000000004,52,0.2015625000000001,0),vec4(3.1500000000000004,71,0.15000000000000036,0),vec4(3.3000000000000007,73,0.1499999999999999,0),vec4(3.3000000000000007,49,0.2015625000000001,0),vec4(3.4500000000000006,71,0.15000000000000036,0),vec4(3.600000000000001,70,0.1499999999999999,0),vec4(3.600000000000001,54,0.2015625000000001,0),vec4(3.750000000000001,73,0.15000000000000036,0),vec4(3.9000000000000012,76,0.15000000000000036,0),vec4(3.9000000000000012,42,0.20156250000000053,0),vec4(4.050000000000002,73,0.15000000000000036,0),vec4(4.200000000000002,47,0.07500000000000018,0),vec4(4.350000000000002,49,0.07500000000000018,0),vec4(4.200000000000002,74,0.3000000000000007,0),vec4(4.500000000000003,50,0.07500000000000018,0),vec4(4.650000000000003,49,0.07500000000000018,0),vec4(4.500000000000003,71,0.3000000000000007,0),vec4(4.800000000000003,47,0.20156249999999964,0),vec4(4.800000000000003,83,0.2999999999999998,0),vec4(5.100000000000003,86,0.15000000000000036,0),vec4(5.100000000000003,47,0.20156250000000053,0),vec4(5.2500000000000036,83,0.15000000000000036,0),vec4(5.400000000000004,50,0.20156249999999964,0),vec4(5.400000000000004,78,0.2999999999999998,0),vec4(5.700000000000004,83,0.15000000000000036,0),vec4(5.700000000000004,47,0.20156250000000053,0),vec4(5.850000000000004,78,0.15000000000000036,0),vec4(6.000000000000004,54,0.20156249999999964,0),vec4(6.000000000000004,74,0.2999999999999998,0),vec4(6.300000000000004,78,0.15000000000000036,0),vec4(6.300000000000004,50,0.20156250000000053,0),vec4(6.450000000000005,74,0.15000000000000036,0),vec4(6.600000000000005,59,0.20156249999999964,0),vec4(6.900000000000005,54,0.20156249999999964,0),vec4(6.600000000000005,71,0.5999999999999996,0),vec4(7.200000000000005,74,0.15000000000000036,0),vec4(7.200000000000005,59,0.20156250000000053,0),vec4(7.350000000000005,73,0.15000000000000036,0),vec4(7.500000000000005,62,0.07500000000000018,0),vec4(7.650000000000006,59,0.07500000000000018,0),vec4(7.500000000000005,74,0.3000000000000007,0),vec4(7.800000000000006,74,0.15000000000000036,0),vec4(7.800000000000006,56,0.20156249999999964,0),vec4(7.950000000000006,73,0.14999999999999858,0),vec4(8.100000000000005,59,0.07499999999999929,0),vec4(8.250000000000004,56,0.07499999999999929,0),vec4(8.100000000000005,74,0.29999999999999716,0),vec4(8.400000000000002,52,0.20156249999999964,0),vec4(8.400000000000002,83,0.29999999999999893,0),vec4(8.700000000000001,56,0.07499999999999929,0),vec4(8.85,52,0.07499999999999929,0),vec4(8.700000000000001,74,0.29999999999999716,0),vec4(8.999999999999998,74,0.056250000000000355,0),vec4(9.065624999999999,76,0.05156249999999929,0),vec4(9.126562499999999,74,0.046875,0),vec4(8.999999999999998,57,0.20156249999999964,0),vec4(9.187499999999998,76,0.046875,0),vec4(9.253124999999999,74,0.044531250000000355,0),vec4(9.299999999999999,61,0.07499999999999929,0),vec4(9.449999999999998,57,0.07499999999999929,0),vec4(9.299999999999999,73,0.29999999999999716,0),vec4(9.599999999999996,78,0.15000000000000036,0),vec4(9.599999999999996,62,0.20156249999999964,0),vec4(9.749999999999996,77,0.14999999999999858,0),vec4(9.899999999999995,66,0.07499999999999929,0),vec4(10.049999999999994,62,0.07499999999999929,0),vec4(9.899999999999995,78,0.29999999999999716,0),vec4(10.199999999999992,78,0.15000000000000036,0),vec4(10.199999999999992,59,0.20156249999999964,0),vec4(10.349999999999993,77,0.14999999999999858,0),vec4(10.499999999999991,62,0.07499999999999929,0),vec4(10.64999999999999,59,0.07499999999999929,0),vec4(10.499999999999991,78,0.29999999999999716,0),vec4(10.799999999999988,56,0.20156249999999964,0),vec4(10.799999999999988,86,0.29999999999999893,0),vec4(11.099999999999987,59,0.07499999999999929,0),vec4(11.249999999999986,56,0.07499999999999929,0),vec4(11.099999999999987,78,0.29999999999999716,0),vec4(11.399999999999984,78,0.056250000000000355,0),vec4(11.399999999999984,61,0.07500000000000107,0),vec4(11.465624999999985,80,0.051562500000001066,0),vec4(11.526562499999986,78,0.046875,0),vec4(11.549999999999986,62,0.07499999999999929,0),vec4(11.587499999999986,80,0.046875,0),vec4(11.653124999999987,78,0.044531250000000355,0),vec4(11.699999999999987,61,0.07499999999999929,0),vec4(11.849999999999985,59,0.07499999999999929,0),vec4(11.699999999999987,77,0.29999999999999716,0),vec4(11.999999999999984,73,0.15000000000000036,0),vec4(11.999999999999984,57,0.20156249999999964,0),vec4(12.149999999999984,78,0.14999999999999858,0),vec4(12.299999999999983,81,0.15000000000000036,0),vec4(12.299999999999983,54,0.20156249999999964,0),vec4(12.449999999999983,78,0.14999999999999858,0),vec4(12.599999999999982,80,0.15000000000000036,0),vec4(12.599999999999982,59,0.20156249999999964,0),vec4(12.749999999999982,78,0.14999999999999858,0),vec4(12.89999999999998,80,0.15000000000000036,0),vec4(12.89999999999998,56,0.20156249999999964,0),vec4(13.049999999999981,78,0.14999999999999858,0),vec4(13.19999999999998,77,0.15000000000000036,0),vec4(13.19999999999998,61,0.20156249999999964,0),vec4(13.34999999999998,80,0.14999999999999858,0),vec4(13.499999999999979,83,0.15000000000000036,0),vec4(13.499999999999979,49,0.20156249999999964,0),vec4(13.649999999999979,80,0.14999999999999858,0),vec4(13.799999999999978,81,0.15000000000000036,0),vec4(13.799999999999978,54,0.20156249999999964,0),vec4(13.949999999999978,80,0.14999999999999858,0),vec4(14.099999999999977,81,0.15000000000000036,0),vec4(14.099999999999977,42,0.20156249999999964,0),vec4(14.249999999999977,80,0.14999999999999858,0),vec4(14.399999999999975,78,0.15000000000000036,0),vec4(14.399999999999975,54,0.20156249999999964,0),vec4(14.549999999999976,81,0.14999999999999858,0),vec4(14.699999999999974,78,0.15000000000000036,0),vec4(14.699999999999974,57,0.20156249999999964,0),vec4(14.849999999999975,77,0.14999999999999858,0),vec4(14.999999999999973,78,0.11953124999999964,0),vec4(14.999999999999973,50,0.20156249999999964,0),vec4(15.149999999999974,83,0.14999999999999858,0),vec4(15.299999999999972,78,0.15000000000000036,0),vec4(15.299999999999972,59,0.20156249999999964,0),vec4(15.449999999999973,77,0.14999999999999858,0),vec4(15.599999999999971,78,0.11953124999999964,0),vec4(15.599999999999971,49,0.20156249999999964,0),vec4(15.749999999999972,85,0.14999999999999858,0),vec4(15.89999999999997,78,0.14999999999999858,0),vec4(15.89999999999997,61,0.20156249999999787,0),vec4(16.04999999999997,77,0.14999999999999858,0),vec4(16.199999999999967,78,0.11953125000000142,0),vec4(16.199999999999967,47,0.20156250000000142,0),vec4(16.34999999999997,86,0.14999999999999858,0),vec4(16.499999999999968,78,0.14999999999999858,0),vec4(16.499999999999968,62,0.20156249999999787,0),vec4(16.649999999999967,77,0.14999999999999858,0),vec4(16.799999999999965,78,0.11953125000000142,0),vec4(16.799999999999965,59,0.20156250000000142,0),vec4(16.949999999999967,86,0.14999999999999858,0),vec4(17.099999999999966,85,0.14999999999999858,0),vec4(17.099999999999966,56,0.20156249999999787,0),vec4(17.249999999999964,83,0.14999999999999858,0),vec4(17.399999999999963,85,0.14999999999999858,0),vec4(17.399999999999963,57,0.20156249999999787,0),vec4(17.54999999999996,81,0.14999999999999858,0),vec4(17.69999999999996,80,0.14999999999999858,0),vec4(17.69999999999996,59,0.20156249999999787,0),vec4(17.84999999999996,78,0.14999999999999858,0),vec4(17.999999999999957,61,0.20156250000000142,0),vec4(17.999999999999957,81,0.3000000000000007,0),vec4(18.299999999999958,80,0.05624999999999858,0),vec4(18.365624999999955,81,0.05156249999999929,0),vec4(18.426562499999953,80,0.046875,0),vec4(18.299999999999958,49,0.20156249999999787,0),vec4(18.487499999999955,81,0.046875,0),vec4(18.553124999999955,80,0.04453124999999858,0),vec4(18.599999999999955,54,0.5015624999999986,0),vec4(18.599999999999955,78,0.5999999999999979,0),vec4(19.199999999999953,47,0.09843749999999929,0),vec4(19.199999999999953,83,0.3000000000000007,0),vec4(19.499999999999954,47,0.09843749999999929,0),vec4(19.499999999999954,86,0.14999999999999858,0),vec4(19.649999999999952,83,0.14999999999999858,0),vec4(19.79999999999995,50,0.20156250000000142,0),vec4(19.79999999999995,78,0.3000000000000007,0),vec4(20.09999999999995,83,0.14999999999999858,0),vec4(20.09999999999995,47,0.20156249999999787,0),vec4(20.24999999999995,78,0.14999999999999858,0),vec4(20.39999999999995,54,0.20156250000000142,0),vec4(20.39999999999995,74,0.3000000000000007,0),vec4(20.69999999999995,78,0.14999999999999858,0),vec4(20.69999999999995,50,0.20156249999999787,0),vec4(20.849999999999948,74,0.14999999999999858,0),vec4(20.999999999999947,59,0.20156250000000142,0),vec4(21.299999999999947,54,0.20156250000000142,0),vec4(20.999999999999947,71,0.6000000000000014,0),vec4(21.599999999999948,66,0.14999999999999858,0),vec4(21.599999999999948,50,0.20156249999999787,0),vec4(21.749999999999947,71,0.14999999999999858,0),vec4(21.899999999999945,74,0.14999999999999858,0),vec4(21.899999999999945,47,0.20156249999999787,0),vec4(22.049999999999944,71,0.14999999999999858,0),vec4(22.199999999999942,73,0.14999999999999858,0),vec4(22.199999999999942,52,0.20156249999999787,0),vec4(22.34999999999994,71,0.14999999999999858,0),vec4(22.49999999999994,73,0.14999999999999858,0),vec4(22.49999999999994,49,0.20156249999999787,0),vec4(22.649999999999938,71,0.14999999999999858,0),vec4(22.799999999999937,70,0.14999999999999858,0),vec4(22.799999999999937,54,0.20156249999999787,0),vec4(22.949999999999935,73,0.14999999999999858,0),vec4(23.099999999999934,76,0.14999999999999858,0),vec4(23.099999999999934,42,0.20156249999999787,0),vec4(23.249999999999932,73,0.14999999999999858,0),vec4(23.39999999999993,47,0.07499999999999929,0),vec4(23.54999999999993,49,0.07499999999999929,0),vec4(23.39999999999993,74,0.29999999999999716,0),vec4(23.69999999999993,50,0.07499999999999929,0),vec4(23.849999999999927,49,0.07499999999999929,0),vec4(23.69999999999993,71,0.29999999999999716,0),vec4(23.999999999999925,47,0.20156250000000142,0),vec4(23.999999999999925,83,0.3000000000000007,0),vec4(24.299999999999926,86,0.14999999999999858,0),vec4(24.299999999999926,47,0.20156249999999787,0),vec4(24.449999999999925,83,0.14999999999999858,0),vec4(24.599999999999923,50,0.20156250000000142,0),vec4(24.599999999999923,78,0.3000000000000007,0),vec4(24.899999999999924,83,0.14999999999999858,0),vec4(24.899999999999924,47,0.20156249999999787,0),vec4(25.049999999999923,78,0.14999999999999858,0),vec4(25.19999999999992,54,0.20156250000000142,0),vec4(25.19999999999992,74,0.3000000000000007,0),vec4(25.499999999999922,78,0.14999999999999858,0),vec4(25.499999999999922,50,0.20156249999999787,0),vec4(25.64999999999992,74,0.14999999999999858,0),vec4(25.79999999999992,59,0.20156250000000142,0),vec4(26.09999999999992,54,0.20156250000000142,0),vec4(25.79999999999992,71,0.6000000000000014,0),vec4(26.39999999999992,74,0.14999999999999858,0),vec4(26.39999999999992,59,0.20156249999999787,0),vec4(26.54999999999992,73,0.14999999999999858,0),vec4(26.699999999999918,62,0.07499999999999929,0),vec4(26.849999999999916,59,0.07499999999999929,0),vec4(26.699999999999918,74,0.29999999999999716,0),vec4(26.999999999999915,74,0.14999999999999858,0),vec4(26.999999999999915,56,0.20156249999999787,0),vec4(27.149999999999913,73,0.14999999999999858,0),vec4(27.299999999999912,59,0.07499999999999929,0),vec4(27.44999999999991,56,0.07499999999999929,0),vec4(27.299999999999912,74,0.29999999999999716,0),vec4(27.59999999999991,52,0.20156250000000142,0),vec4(27.59999999999991,83,0.3000000000000007,0),vec4(27.89999999999991,56,0.07499999999999929,0),vec4(28.04999999999991,52,0.07499999999999929,0),vec4(27.89999999999991,74,0.29999999999999716,0),vec4(28.199999999999907,74,0.05624999999999858,0),vec4(28.265624999999904,76,0.05156249999999929,0),vec4(28.326562499999902,74,0.046875,0),vec4(28.199999999999907,57,0.20156249999999787,0),vec4(28.387499999999903,76,0.046875,0),vec4(28.453124999999904,74,0.04453124999999858,0),vec4(28.499999999999904,61,0.07499999999999929,0),vec4(28.649999999999903,57,0.07499999999999929,0),vec4(28.499999999999904,73,0.29999999999999716,0),vec4(28.7999999999999,78,0.14999999999999858,0),vec4(28.7999999999999,62,0.20156249999999787,0),vec4(28.9499999999999,77,0.14999999999999858,0),vec4(29.0999999999999,66,0.07499999999999929,0),vec4(29.249999999999897,62,0.07499999999999929,0),vec4(29.0999999999999,78,0.29999999999999716,0),vec4(29.399999999999896,78,0.14999999999999858,0),vec4(29.399999999999896,59,0.20156249999999787,0),vec4(29.549999999999894,77,0.14999999999999858,0),vec4(29.699999999999893,62,0.07499999999999929,0),vec4(29.84999999999989,59,0.07499999999999929,0),vec4(29.699999999999893,78,0.29999999999999716,0),vec4(29.99999999999989,56,0.20156250000000142,0),vec4(29.99999999999989,86,0.3000000000000007,0),vec4(30.29999999999989,59,0.07499999999999929,0),vec4(30.44999999999989,56,0.07499999999999929,0),vec4(30.29999999999989,78,0.29999999999999716,0),vec4(30.599999999999888,78,0.05624999999999858,0),vec4(30.599999999999888,61,0.07499999999999574,0),vec4(30.665624999999885,80,0.05156249999999929,0),vec4(30.726562499999883,78,0.046875,0),vec4(30.749999999999883,62,0.07500000000000284,0),vec4(30.787499999999884,80,0.046875,0),vec4(30.853124999999885,78,0.04453124999999858,0),vec4(30.899999999999885,61,0.07499999999999929,0),vec4(31.049999999999883,59,0.07499999999999929,0),vec4(30.899999999999885,77,0.29999999999999716,0),vec4(31.199999999999882,73,0.14999999999999858,0),vec4(31.199999999999882,57,0.20156249999999787,0),vec4(31.34999999999988,78,0.14999999999999858,0),vec4(31.49999999999988,81,0.14999999999999858,0),vec4(31.49999999999988,54,0.20156249999999787,0),vec4(31.649999999999878,78,0.14999999999999858,0),vec4(31.799999999999876,80,0.14999999999999858,0),vec4(31.799999999999876,59,0.20156250000000142,0),vec4(31.949999999999875,78,0.15000000000000568,0),vec4(32.09999999999988,80,0.14999999999999858,0),vec4(32.09999999999988,56,0.20156250000000142,0),vec4(32.24999999999988,78,0.15000000000000568,0),vec4(32.399999999999885,77,0.14999999999999858,0),vec4(32.399999999999885,61,0.20156250000000142,0),vec4(32.54999999999988,80,0.15000000000000568,0),vec4(32.69999999999989,83,0.14999999999999858,0),vec4(32.69999999999989,49,0.20156250000000142,0),vec4(32.84999999999989,80,0.15000000000000568,0),vec4(32.99999999999989,81,0.14999999999999858,0),vec4(32.99999999999989,54,0.20156250000000142,0),vec4(33.14999999999989,80,0.15000000000000568,0),vec4(33.2999999999999,81,0.14999999999999858,0),vec4(33.2999999999999,42,0.20156250000000142,0),vec4(33.449999999999896,80,0.15000000000000568,0),vec4(33.5999999999999,78,0.14999999999999858,0),vec4(33.5999999999999,54,0.20156250000000142,0),vec4(33.7499999999999,81,0.15000000000000568,0),vec4(33.899999999999906,78,0.14999999999999858,0),vec4(33.899999999999906,57,0.20156250000000142,0),vec4(34.049999999999905,77,0.15000000000000568,0),vec4(34.19999999999991,78,0.11953125000000142,0),vec4(34.19999999999991,50,0.20156250000000142,0),vec4(34.34999999999991,83,0.15000000000000568,0),vec4(34.499999999999915,78,0.14999999999999858,0),vec4(34.499999999999915,59,0.20156250000000142,0),vec4(34.64999999999991,77,0.15000000000000568,0),vec4(34.79999999999992,78,0.11953125000000142,0),vec4(34.79999999999992,49,0.20156250000000142,0),vec4(34.94999999999992,85,0.15000000000000568,0),vec4(35.09999999999992,78,0.14999999999999858,0),vec4(35.09999999999992,61,0.20156250000000142,0),vec4(35.24999999999992,77,0.15000000000000568,0),vec4(35.39999999999993,78,0.11953125000000142,0),vec4(35.39999999999993,47,0.20156250000000142,0),vec4(35.549999999999926,86,0.15000000000000568,0),vec4(35.69999999999993,78,0.14999999999999858,0),vec4(35.69999999999993,62,0.20156250000000142,0),vec4(35.84999999999993,77,0.15000000000000568,0),vec4(35.999999999999936,78,0.11953125000000142,0),vec4(35.999999999999936,59,0.20156250000000142,0),vec4(36.149999999999935,86,0.15000000000000568,0),vec4(36.29999999999994,85,0.14999999999999858,0),vec4(36.29999999999994,56,0.20156250000000142,0),vec4(36.44999999999994,83,0.15000000000000568,0),vec4(36.599999999999945,85,0.14999999999999858,0),vec4(36.599999999999945,57,0.20156250000000142,0),vec4(36.74999999999994,81,0.15000000000000568,0),vec4(36.89999999999995,80,0.14999999999999858,0),vec4(36.89999999999995,59,0.20156250000000142,0),vec4(37.04999999999995,78,0.15000000000000568,0),vec4(37.19999999999995,61,0.20156250000000142,0),vec4(37.19999999999995,81,0.30000000000000426,0),vec4(37.49999999999996,80,0.05624999999999858,0),vec4(37.565624999999955,81,0.05156250000000284,0),vec4(37.626562499999956,80,0.046875,0),vec4(37.49999999999996,49,0.20156250000000142,0),vec4(37.68749999999996,81,0.046875,0),vec4(37.753124999999955,80,0.04453124999999858,0),vec4(37.799999999999955,54,0.5015624999999986,0),vec4(37.799999999999955,78,0.6000000000000014,0),vec4(38.399999999999956,42,0.20156250000000142,0),vec4(38.399999999999956,78,0.30000000000000426,0),vec4(38.69999999999996,81,0.14999999999999858,0),vec4(38.69999999999996,42,0.20156250000000142,0),vec4(38.84999999999996,78,0.15000000000000568,0),vec4(38.999999999999964,45,0.20156250000000142,0),vec4(38.999999999999964,73,0.30000000000000426,0),vec4(39.29999999999997,78,0.14999999999999858,0),vec4(39.29999999999997,42,0.20156250000000142,0),vec4(39.44999999999997,73,0.15000000000000568,0),vec4(39.59999999999997,49,0.20156250000000142,0),vec4(39.59999999999997,69,0.30000000000000426,0),vec4(39.89999999999998,73,0.14999999999999858,0),vec4(39.89999999999998,45,0.20156250000000142,0),vec4(40.049999999999976,69,0.15000000000000568,0),vec4(40.19999999999998,54,0.20156250000000142,0),vec4(40.499999999999986,57,0.07500000000000284,0),vec4(40.64999999999999,54,0.07500000000000284,0),vec4(40.19999999999998,66,0.6000000000000156,0),vec4(40.8,51,0.20156250000000142,0),vec4(40.8,72,0.30000000000000426,0),vec4(41.1,54,0.07500000000000284,0),vec4(41.25000000000001,51,0.07500000000000284,0),vec4(41.1,71,0.23906250000000995,0),vec4(41.40000000000001,47,0.20156250000000142,0),vec4(41.40000000000001,76,0.30000000000000426,0),vec4(41.70000000000002,75,0.11953125000000142,0),vec4(41.70000000000002,47,0.20156250000000142,0),vec4(41.850000000000016,78,0.15000000000000568,0),vec4(42.00000000000002,47,0.20156250000000142,0),vec4(42.00000000000002,81,0.30000000000000426,0),vec4(42.300000000000026,79,0.14999999999999858,0),vec4(42.300000000000026,47,0.20156250000000142,0),vec4(42.450000000000024,78,0.15000000000000568,0),vec4(42.60000000000003,52,0.20156250000000142,0),vec4(42.60000000000003,79,0.30000000000000426,0),vec4(42.900000000000034,59,0.07500000000000284,0),vec4(43.05000000000004,55,0.07500000000000284,0),vec4(42.900000000000034,76,0.30000000000001137,0),vec4(43.200000000000045,52,0.20156250000000142,0),vec4(43.200000000000045,79,0.30000000000000426,0),vec4(43.50000000000005,55,0.07500000000000284,0),vec4(43.50000000000005,83,0.15000000000000568,0),vec4(43.650000000000055,52,0.07500000000000284,0),vec4(43.650000000000055,79,0.15000000000000568,0),vec4(43.80000000000006,49,0.20156250000000142,0),vec4(43.80000000000006,76,0.30000000000000426,0),vec4(44.100000000000065,79,0.14999999999999858,0),vec4(44.100000000000065,45,0.20156250000000142,0),vec4(44.250000000000064,76,0.15000000000000568,0),vec4(44.40000000000007,52,0.20156250000000142,0),vec4(44.40000000000007,73,0.30000000000000426,0),vec4(44.700000000000074,76,0.14999999999999858,0),vec4(44.700000000000074,49,0.20156250000000142,0),vec4(44.85000000000007,73,0.15000000000000568,0),vec4(45.00000000000008,55,0.20156250000000142,0),vec4(45.30000000000008,52,0.20156250000000142,0),vec4(45.00000000000008,69,0.7500000000000071,0),vec4(45.60000000000009,54,0.20156250000000142,0),vec4(45.750000000000085,74,0.15000000000000568,0),vec4(45.90000000000009,78,0.14999999999999858,0),vec4(45.90000000000009,59,0.20156250000000142,0),vec4(46.05000000000009,74,0.15000000000000568,0),vec4(46.200000000000095,76,0.14999999999999858,0),vec4(46.200000000000095,55,0.20156250000000142,0),vec4(46.350000000000094,74,0.15000000000000568,0),vec4(46.5000000000001,76,0.14999999999999858,0),vec4(46.5000000000001,52,0.20156250000000142,0),vec4(46.6500000000001,74,0.15000000000000568,0),vec4(46.800000000000104,73,0.14999999999999858,0),vec4(46.800000000000104,57,0.20156250000000142,0),vec4(46.9500000000001,76,0.15000000000000568,0),vec4(47.10000000000011,79,0.14999999999999858,0),vec4(47.10000000000011,45,0.20156250000000142,0),vec4(47.25000000000011,76,0.15000000000000568,0),vec4(47.40000000000011,78,0.14999999999999858,0),vec4(47.40000000000011,50,0.20156250000000142,0),vec4(47.55000000000011,76,0.15000000000000568,0),vec4(47.70000000000012,78,0.14999999999999858,0),vec4(47.70000000000012,38,0.20156250000000142,0),vec4(47.850000000000115,76,0.15000000000000568,0),vec4(48.00000000000012,74,0.14999999999999858,0),vec4(48.00000000000012,48,0.20156250000000142,0),vec4(48.15000000000012,78,0.15000000000000568,0),vec4(48.300000000000125,74,0.14999999999999858,0),vec4(48.300000000000125,54,0.20156250000000142,0),vec4(48.450000000000124,73,0.15000000000000568,0),vec4(48.60000000000013,74,0.11953125000000142,0),vec4(48.60000000000013,47,0.20156250000000142,0),vec4(48.75000000000013,79,0.15000000000000568,0),vec4(48.900000000000134,74,0.14999999999999858,0),vec4(48.900000000000134,55,0.20156250000000142,0),vec4(49.05000000000013,73,0.15000000000000568,0),vec4(49.20000000000014,74,0.11953125000000142,0),vec4(49.20000000000014,45,0.20156250000000142,0),vec4(49.350000000000136,81,0.15000000000000568,0),vec4(49.50000000000014,74,0.14999999999999858,0),vec4(49.50000000000014,57,0.20156250000000142,0),vec4(49.65000000000014,73,0.15000000000000568,0),vec4(49.800000000000146,74,0.11953125000000142,0),vec4(49.800000000000146,43,0.20156250000000142,0),vec4(49.950000000000145,83,0.15000000000000568,0),vec4(50.10000000000015,74,0.14999999999999858,0),vec4(50.10000000000015,59,0.20156250000000142,0),vec4(50.25000000000015,73,0.15000000000000568,0),vec4(50.400000000000155,74,0.11953125000000142,0),vec4(50.400000000000155,55,0.20156250000000142,0),vec4(50.55000000000015,83,0.15000000000000568,0),vec4(50.70000000000016,81,0.14999999999999858,0),vec4(50.70000000000016,52,0.20156250000000142,0),vec4(50.85000000000016,79,0.15000000000000568,0),vec4(51.00000000000016,81,0.14999999999999858,0),vec4(51.00000000000016,54,0.20156250000000142,0),vec4(51.15000000000016,78,0.15000000000000568,0),vec4(51.30000000000017,76,0.14999999999999858,0),vec4(51.30000000000017,55,0.20156250000000142,0),vec4(51.450000000000166,74,0.15000000000000568,0),vec4(51.60000000000017,57,0.20156250000000142,0),vec4(51.60000000000017,78,0.30000000000000426,0),vec4(51.900000000000176,76,0.05624999999999858,0),vec4(51.96562500000017,78,0.05156250000000284,0),vec4(52.026562500000175,76,0.046875,0),vec4(51.900000000000176,45,0.20156250000000142,0),vec4(52.087500000000176,78,0.046875,0),vec4(52.15312500000017,76,0.04453124999999858,0),vec4(52.20000000000017,50,0.20156250000000142,0),vec4(52.50000000000018,45,0.07500000000000284,0),vec4(52.65000000000018,42,0.07500000000000284,0),vec4(52.20000000000017,74,0.6000000000000156,0),vec4(52.80000000000019,78,0.14999999999999858,0),vec4(52.80000000000019,38,0.20156250000000142,0),vec4(52.95000000000019,76,0.15000000000000568,0),vec4(53.10000000000019,62,0.07500000000000284,0),vec4(53.2500000000002,57,0.07500000000000284,0),vec4(53.10000000000019,78,0.30000000000001137,0),vec4(53.400000000000205,78,0.14999999999999858,0),vec4(53.400000000000205,54,0.20156250000000142,0),vec4(53.5500000000002,76,0.15000000000000568,0),vec4(53.70000000000021,57,0.07500000000000284,0),vec4(53.850000000000215,54,0.07500000000000284,0),vec4(53.70000000000021,78,0.30000000000001137,0),vec4(54.00000000000022,50,0.20156250000000142,0),vec4(54.00000000000022,86,0.30000000000000426,0),vec4(54.300000000000225,54,0.07500000000000284,0),vec4(54.45000000000023,50,0.07500000000000284,0),vec4(54.300000000000225,78,0.30000000000001137,0),vec4(54.600000000000236,78,0.05624999999999858,0),vec4(54.66562500000023,79,0.05156250000000284,0),vec4(54.726562500000234,78,0.046875,0),vec4(54.600000000000236,57,0.20156250000000142,0),vec4(54.787500000000236,79,0.046875,0),vec4(54.85312500000023,78,0.04453124999999858,0),vec4(54.90000000000023,52,0.07500000000000284,0),vec4(55.05000000000024,49,0.07500000000000284,0),vec4(54.90000000000023,76,0.30000000000001137,0),vec4(55.200000000000244,76,0.14999999999999858,0),vec4(55.200000000000244,46,0.20156250000000142,0),vec4(55.35000000000024,74,0.15000000000000568,0),vec4(55.50000000000025,64,0.07500000000000284,0),vec4(55.650000000000254,61,0.07500000000000284,0),vec4(55.50000000000025,76,0.30000000000001137,0),vec4(55.80000000000026,76,0.14999999999999858,0),vec4(55.80000000000026,58,0.20156250000000142,0),vec4(55.95000000000026,74,0.15000000000000568,0),vec4(56.100000000000264,61,0.07500000000000284,0),vec4(56.25000000000027,58,0.07500000000000284,0),vec4(56.100000000000264,76,0.30000000000001137,0),vec4(56.400000000000276,54,0.20156250000000142,0),vec4(56.400000000000276,85,0.30000000000000426,0),vec4(56.70000000000028,58,0.07500000000000284,0),vec4(56.850000000000286,54,0.07500000000000284,0),vec4(56.70000000000028,76,0.30000000000001137,0),vec4(57.00000000000029,76,0.05624999999999858,0),vec4(57.06562500000029,78,0.05156250000000284,0),vec4(57.12656250000029,76,0.046875,0),vec4(57.00000000000029,59,0.20156250000000142,0),vec4(57.18750000000029,78,0.046875,0),vec4(57.25312500000029,76,0.04453124999999858,0),vec4(57.30000000000029,54,0.20156250000000142,0),vec4(57.30000000000029,74,0.30000000000000426,0),vec4(57.60000000000029,50,0.20156250000000142,0),vec4(57.60000000000029,83,0.30000000000000426,0),vec4(57.9000000000003,86,0.14999999999999858,0),vec4(57.9000000000003,47,0.20156250000000142,0),vec4(58.050000000000296,83,0.11250000000000426,0),vec4(58.1625000000003,81,0.03750000000000142,0),vec4(58.2000000000003,52,0.20156250000000142,0),vec4(58.500000000000306,59,0.07500000000000284,0),vec4(58.65000000000031,55,0.07500000000000284,0),vec4(58.80000000000032,52,0.20156250000000142,0),vec4(58.2000000000003,79,0.9000000000000199,0),vec4(59.10000000000032,83,0.07500000000000284,0),vec4(59.175000000000324,81,0.07500000000000284,0),vec4(59.10000000000032,40,0.20156250000000853,0),vec4(59.25000000000033,79,0.07500000000000284,0),vec4(59.32500000000033,78,0.05859375,0),vec4(59.40000000000033,52,0.20156250000000142,0),vec4(59.70000000000034,55,0.07500000000000284,0),vec4(59.85000000000034,52,0.07500000000000284,0),vec4(60.00000000000035,47,0.20156250000000142,0),vec4(59.40000000000033,76,0.9000000000000199,0),vec4(60.30000000000035,79,0.07500000000000284,0),vec4(60.375000000000355,78,0.07500000000000284,0),vec4(60.30000000000035,40,0.20156250000000853,0),vec4(60.45000000000036,76,0.07500000000000284,0),vec4(60.52500000000036,74,0.05859375,0),vec4(60.600000000000364,72,0.14999999999999858,0),vec4(60.600000000000364,52,0.20156250000000142,0),vec4(60.75000000000036,76,0.15000000000000568,0),vec4(60.90000000000037,79,0.14999999999999858,0),vec4(60.90000000000037,52,0.20156250000000142,0),vec4(61.05000000000037,76,0.15000000000000568,0),vec4(61.20000000000037,72,0.14999999999999858,0),vec4(61.20000000000037,52,0.20156250000000142,0),vec4(61.35000000000037,71,0.11953125000000142,0),vec4(61.50000000000037,72,0.14999999999999858,0),vec4(61.50000000000037,40,0.20156250000000142,0),vec4(61.65000000000037,71,0.11953125000000142,0),vec4(61.80000000000037,70,0.14765624999999716,0),vec4(61.80000000000037,52,0.20156249999999432,0),vec4(62.100000000000364,64,0.07500000000000284,0),vec4(62.100000000000364,66,0.14765625000000426,0),vec4(62.25000000000037,61,0.07500000000000284,0),vec4(62.400000000000375,58,0.20156250000000142,0),vec4(62.400000000000375,67,0.30000000000000426,0),vec4(62.70000000000038,61,0.07500000000000284,0),vec4(62.850000000000385,58,0.07500000000000284,0),vec4(62.70000000000038,66,0.23906250000000995,0),vec4(63.00000000000039,54,0.20156250000000142,0),vec4(63.00000000000039,71,0.30000000000000426,0),vec4(63.300000000000395,70,0.11953125000000142,0),vec4(63.300000000000395,54,0.20156250000000142,0),vec4(63.450000000000394,73,0.15000000000000568,0),vec4(63.6000000000004,54,0.20156250000000142,0),vec4(63.6000000000004,76,0.30000000000000426,0),vec4(63.900000000000404,74,0.15000000000000568,0),vec4(63.900000000000404,54,0.20156250000000853,0),vec4(64.05000000000041,73,0.15000000000000568,0),vec4(64.20000000000041,59,0.20156249999999432,0),vec4(64.20000000000041,74,0.29999999999999716,0),vec4(64.50000000000041,62,0.07500000000000284,0),vec4(64.50000000000041,71,0.07500000000000284,0),vec4(64.57500000000041,73,0.07500000000000284,0),vec4(64.65000000000042,59,0.07500000000000284,0),vec4(64.65000000000042,74,0.07500000000000284,0),vec4(64.72500000000042,76,0.07500000000000284,0),vec4(64.80000000000042,54,0.20156249999999432,0),vec4(64.80000000000042,78,0.23906249999998863,0),vec4(65.1000000000004,59,0.07500000000000284,0),vec4(65.1000000000004,74,0.15000000000000568,0),vec4(65.25000000000041,54,0.07500000000000284,0),vec4(65.25000000000041,78,0.15000000000000568,0),vec4(65.40000000000042,50,0.20156249999999432,0),vec4(65.40000000000042,83,0.29999999999999716,0),vec4(65.70000000000041,47,0.07500000000000284,0),vec4(65.85000000000042,50,0.07500000000000284,0),vec4(65.70000000000041,78,0.30000000000001137,0),vec4(66.00000000000043,76,0.15000000000000568,0),vec4(66.00000000000043,54,0.20156250000000853,0),vec4(66.15000000000043,74,0.15000000000000568,0),vec4(66.30000000000044,73,0.15000000000000568,0),vec4(66.30000000000044,42,0.20156250000000853,0),vec4(66.45000000000044,74,0.11015625000000284,0),vec4(66.56015625000045,73,0.03984375000000284,0),vec4(66.60000000000045,47,0.5015625000000057,0),vec4(66.60000000000045,71,0.5015625000000057,0),vec4(66.60000000000045,66,0.5015625000000057,0),vec4(66.60000000000045,62,0.5015625000000057,0),vec4(67.80000000000045,42,0.20156249999999432,0),vec4(67.80000000000045,78,0.29999999999999716,0),vec4(68.10000000000045,81,0.15000000000000568,0),vec4(68.10000000000045,42,0.20156250000000853,0),vec4(68.25000000000045,78,0.15000000000000568,0),vec4(68.40000000000046,45,0.20156249999999432,0),vec4(68.40000000000046,73,0.29999999999999716,0),vec4(68.70000000000046,78,0.15000000000000568,0),vec4(68.70000000000046,42,0.20156250000000853,0),vec4(68.85000000000046,73,0.15000000000000568,0),vec4(69.00000000000047,49,0.20156249999999432,0),vec4(69.00000000000047,69,0.29999999999999716,0),vec4(69.30000000000047,73,0.15000000000000568,0),vec4(69.30000000000047,45,0.20156250000000853,0),vec4(69.45000000000047,69,0.15000000000000568,0),vec4(69.60000000000048,54,0.20156249999999432,0),vec4(69.90000000000047,57,0.07500000000000284,0),vec4(70.05000000000048,54,0.07500000000000284,0),vec4(69.60000000000048,66,0.6000000000000085,0),vec4(70.20000000000049,51,0.20156249999999432,0),vec4(70.20000000000049,72,0.29999999999999716,0),vec4(70.50000000000048,54,0.07500000000000284,0),vec4(70.65000000000049,51,0.07500000000000284,0),vec4(70.50000000000048,71,0.23906250000000284,0),vec4(70.80000000000048,47,0.20156249999999432,0),vec4(70.80000000000048,76,0.29999999999999716,0),vec4(71.10000000000048,75,0.11953124999999432,0),vec4(71.10000000000048,47,0.20156249999999432,0),vec4(71.25000000000047,78,0.15000000000000568,0),vec4(71.40000000000047,47,0.20156249999999432,0),vec4(71.40000000000047,81,0.29999999999999716,0),vec4(71.70000000000047,79,0.15000000000000568,0),vec4(71.70000000000047,47,0.20156250000000853,0),vec4(71.85000000000048,78,0.15000000000000568,0),vec4(72.00000000000048,52,0.20156249999999432,0),vec4(72.00000000000048,79,0.29999999999999716,0),vec4(72.30000000000048,59,0.07500000000000284,0),vec4(72.45000000000049,55,0.07500000000000284,0),vec4(72.30000000000048,76,0.30000000000001137,0),vec4(72.60000000000049,52,0.20156249999999432,0),vec4(72.60000000000049,79,0.29999999999999716,0),vec4(72.90000000000049,55,0.07500000000000284,0),vec4(72.90000000000049,83,0.15000000000000568,0),vec4(73.0500000000005,52,0.07500000000000284,0),vec4(73.0500000000005,79,0.15000000000000568,0),vec4(73.2000000000005,49,0.20156249999999432,0),vec4(73.2000000000005,76,0.29999999999999716,0),vec4(73.5000000000005,79,0.15000000000000568,0),vec4(73.5000000000005,45,0.20156250000000853,0),vec4(73.6500000000005,76,0.15000000000000568,0),vec4(73.80000000000051,52,0.20156249999999432,0),vec4(73.80000000000051,73,0.29999999999999716,0),vec4(74.1000000000005,76,0.15000000000000568,0),vec4(74.1000000000005,49,0.20156250000000853,0),vec4(74.25000000000051,73,0.15000000000000568,0),vec4(74.40000000000052,55,0.20156249999999432,0),vec4(74.70000000000051,52,0.20156249999999432,0),vec4(74.40000000000052,69,0.75,0),vec4(75.00000000000051,54,0.20156250000000853,0),vec4(75.15000000000052,74,0.15000000000000568,0),vec4(75.30000000000052,78,0.15000000000000568,0),vec4(75.30000000000052,59,0.20156250000000853,0),vec4(75.45000000000053,74,0.15000000000000568,0),vec4(75.60000000000053,76,0.15000000000000568,0),vec4(75.60000000000053,55,0.20156250000000853,0),vec4(75.75000000000054,74,0.15000000000000568,0),vec4(75.90000000000055,76,0.15000000000000568,0),vec4(75.90000000000055,52,0.20156250000000853,0),vec4(76.05000000000055,74,0.15000000000000568,0),vec4(76.20000000000056,73,0.15000000000000568,0),vec4(76.20000000000056,57,0.20156250000000853,0),vec4(76.35000000000056,76,0.15000000000000568,0),vec4(76.50000000000057,79,0.15000000000000568,0),vec4(76.50000000000057,45,0.20156250000000853,0),vec4(76.65000000000057,76,0.15000000000000568,0),vec4(76.80000000000058,78,0.15000000000000568,0),vec4(76.80000000000058,50,0.20156250000000853,0),vec4(76.95000000000059,76,0.15000000000000568,0),vec4(77.10000000000059,78,0.15000000000000568,0),vec4(77.10000000000059,38,0.20156250000000853,0),vec4(77.2500000000006,76,0.15000000000000568,0),vec4(77.4000000000006,74,0.15000000000000568,0),vec4(77.4000000000006,48,0.20156250000000853,0),vec4(77.55000000000061,78,0.15000000000000568,0),vec4(77.70000000000061,74,0.15000000000000568,0),vec4(77.70000000000061,54,0.20156250000000853,0),vec4(77.85000000000062,73,0.15000000000000568,0),vec4(78.00000000000063,74,0.11953124999999432,0),vec4(78.00000000000063,47,0.20156249999999432,0),vec4(78.15000000000062,79,0.15000000000000568,0),vec4(78.30000000000062,74,0.15000000000000568,0),vec4(78.30000000000062,55,0.20156250000000853,0),vec4(78.45000000000063,73,0.15000000000000568,0),vec4(78.60000000000063,74,0.11953124999999432,0),vec4(78.60000000000063,45,0.20156249999999432,0),vec4(78.75000000000063,81,0.15000000000000568,0),vec4(78.90000000000063,74,0.15000000000000568,0),vec4(78.90000000000063,57,0.20156250000000853,0),vec4(79.05000000000064,73,0.15000000000000568,0),vec4(79.20000000000064,74,0.11953124999999432,0),vec4(79.20000000000064,43,0.20156249999999432,0),vec4(79.35000000000063,83,0.15000000000000568,0),vec4(79.50000000000064,74,0.15000000000000568,0),vec4(79.50000000000064,59,0.20156250000000853,0),vec4(79.65000000000065,73,0.15000000000000568,0),vec4(79.80000000000065,74,0.11953124999999432,0),vec4(79.80000000000065,55,0.20156249999999432,0),vec4(79.95000000000064,83,0.15000000000000568,0),vec4(80.10000000000065,81,0.15000000000000568,0),vec4(80.10000000000065,52,0.20156250000000853,0),vec4(80.25000000000065,79,0.15000000000000568,0),vec4(80.40000000000066,81,0.15000000000000568,0),vec4(80.40000000000066,54,0.20156250000000853,0),vec4(80.55000000000067,78,0.15000000000000568,0),vec4(80.70000000000067,76,0.15000000000000568,0),vec4(80.70000000000067,55,0.20156250000000853,0),vec4(80.85000000000068,74,0.15000000000000568,0),vec4(81.00000000000068,57,0.20156249999999432,0),vec4(81.00000000000068,78,0.29999999999999716,0),vec4(81.30000000000068,76,0.056250000000005684,0),vec4(81.36562500000069,78,0.05156250000000284,0),vec4(81.4265625000007,76,0.046875,0),vec4(81.30000000000068,45,0.20156250000000853,0),vec4(81.4875000000007,78,0.046875,0),vec4(81.55312500000069,76,0.044531250000005684,0),vec4(81.60000000000069,50,0.20156249999999432,0),vec4(81.90000000000069,45,0.07500000000000284,0),vec4(82.0500000000007,42,0.07500000000000284,0),vec4(81.60000000000069,74,0.6000000000000085,0),vec4(82.2000000000007,78,0.15000000000000568,0),vec4(82.2000000000007,38,0.20156250000000853,0),vec4(82.3500000000007,76,0.15000000000000568,0),vec4(82.50000000000071,62,0.07500000000000284,0),vec4(82.65000000000072,57,0.07500000000000284,0),vec4(82.50000000000071,78,0.30000000000001137,0),vec4(82.80000000000072,78,0.15000000000000568,0),vec4(82.80000000000072,54,0.20156250000000853,0),vec4(82.95000000000073,76,0.15000000000000568,0),vec4(83.10000000000073,57,0.07500000000000284,0),vec4(83.25000000000074,54,0.07500000000000284,0),vec4(83.10000000000073,78,0.30000000000001137,0),vec4(83.40000000000074,50,0.20156249999999432,0),vec4(83.40000000000074,86,0.29999999999999716,0),vec4(83.70000000000074,54,0.07500000000000284,0),vec4(83.85000000000075,50,0.07500000000000284,0),vec4(83.70000000000074,78,0.30000000000001137,0),vec4(84.00000000000075,78,0.056250000000005684,0),vec4(84.06562500000076,79,0.05156250000000284,0),vec4(84.12656250000077,78,0.046875,0),vec4(84.00000000000075,57,0.20156250000000853,0),vec4(84.18750000000077,79,0.046875,0),vec4(84.25312500000076,78,0.044531250000005684,0),vec4(84.30000000000076,52,0.07500000000000284,0),vec4(84.45000000000077,49,0.07500000000000284,0),vec4(84.30000000000076,76,0.30000000000001137,0),vec4(84.60000000000078,76,0.15000000000000568,0),vec4(84.60000000000078,46,0.20156250000000853,0),vec4(84.75000000000078,74,0.15000000000000568,0),vec4(84.90000000000079,64,0.07500000000000284,0),vec4(85.0500000000008,61,0.07500000000000284,0),vec4(84.90000000000079,76,0.30000000000001137,0),vec4(85.2000000000008,76,0.15000000000000568,0),vec4(85.2000000000008,58,0.20156250000000853,0),vec4(85.3500000000008,74,0.15000000000000568,0),vec4(85.50000000000081,61,0.07500000000000284,0),vec4(85.65000000000082,58,0.07500000000000284,0),vec4(85.50000000000081,76,0.30000000000001137,0),vec4(85.80000000000082,54,0.20156249999999432,0),vec4(85.80000000000082,85,0.29999999999999716,0),vec4(86.10000000000082,58,0.07500000000000284,0),vec4(86.25000000000082,54,0.07500000000000284,0),vec4(86.10000000000082,76,0.30000000000001137,0),vec4(86.40000000000083,76,0.056250000000005684,0),vec4(86.46562500000084,78,0.05156250000000284,0),vec4(86.52656250000085,76,0.046875,0),vec4(86.40000000000083,59,0.20156250000000853,0),vec4(86.58750000000084,78,0.046875,0),vec4(86.65312500000084,76,0.044531250000005684,0),vec4(86.70000000000084,54,0.20156249999999432,0),vec4(86.70000000000084,74,0.29999999999999716,0),vec4(87.00000000000084,50,0.20156249999999432,0),vec4(87.00000000000084,83,0.29999999999999716,0),vec4(87.30000000000084,86,0.15000000000000568,0),vec4(87.30000000000084,47,0.20156250000000853,0),vec4(87.45000000000084,83,0.11249999999999716,0),vec4(87.56250000000084,81,0.037499999999994316,0),vec4(87.60000000000083,52,0.20156249999999432,0),vec4(87.90000000000083,59,0.07500000000000284,0),vec4(88.05000000000084,55,0.07500000000000284,0),vec4(88.20000000000084,52,0.20156249999999432,0),vec4(87.60000000000083,79,0.9000000000000057,0),vec4(88.50000000000084,83,0.07500000000000284,0),vec4(88.57500000000084,81,0.07500000000000284,0),vec4(88.50000000000084,40,0.20156250000000853,0),vec4(88.65000000000084,79,0.07500000000000284,0),vec4(88.72500000000085,78,0.05859375,0),vec4(88.80000000000085,52,0.20156249999999432,0),vec4(89.10000000000085,55,0.07500000000000284,0),vec4(89.25000000000085,52,0.07500000000000284,0),vec4(89.40000000000086,47,0.20156249999999432,0),vec4(88.80000000000085,76,0.9000000000000057,0),vec4(89.70000000000086,79,0.07500000000000284,0),vec4(89.77500000000086,78,0.07500000000000284,0),vec4(89.70000000000086,40,0.20156250000000853,0),vec4(89.85000000000086,76,0.07500000000000284,0),vec4(89.92500000000086,74,0.05859375,0),vec4(90.00000000000087,72,0.15000000000000568,0),vec4(90.00000000000087,52,0.20156250000000853,0),vec4(90.15000000000087,76,0.15000000000000568,0),vec4(90.30000000000088,79,0.15000000000000568,0),vec4(90.30000000000088,52,0.20156250000000853,0),vec4(90.45000000000088,76,0.15000000000000568,0),vec4(90.60000000000089,72,0.15000000000000568,0),vec4(90.60000000000089,52,0.20156250000000853,0),vec4(90.7500000000009,71,0.11953125000000853,0),vec4(90.9000000000009,72,0.15000000000000568,0),vec4(90.9000000000009,40,0.20156250000000853,0),vec4(91.0500000000009,71,0.11953125000000853,0),vec4(91.20000000000091,70,0.14765624999999716,0),vec4(91.20000000000091,52,0.20156249999999432,0),vec4(91.50000000000091,64,0.07500000000000284,0),vec4(91.50000000000091,66,0.14765624999999716,0),vec4(91.6500000000009,61,0.07500000000000284,0),vec4(91.8000000000009,58,0.20156249999999432,0),vec4(91.8000000000009,67,0.29999999999999716,0),vec4(92.1000000000009,61,0.07500000000000284,0),vec4(92.25000000000091,58,0.07500000000000284,0),vec4(92.1000000000009,66,0.23906250000000284,0),vec4(92.4000000000009,54,0.20156249999999432,0),vec4(92.4000000000009,71,0.29999999999999716,0),vec4(92.7000000000009,70,0.11953124999999432,0),vec4(92.7000000000009,54,0.20156249999999432,0),vec4(92.85000000000089,73,0.15000000000000568,0),vec4(93.0000000000009,54,0.20156249999999432,0),vec4(93.0000000000009,76,0.29999999999999716,0),vec4(93.30000000000089,74,0.15000000000000568,0),vec4(93.30000000000089,54,0.20156250000000853,0),vec4(93.4500000000009,73,0.15000000000000568,0),vec4(93.6000000000009,59,0.20156249999999432,0),vec4(93.6000000000009,74,0.29999999999999716,0),vec4(93.9000000000009,62,0.07500000000000284,0),vec4(93.9000000000009,71,0.07500000000000284,0),vec4(93.9750000000009,73,0.07500000000000284,0),vec4(94.0500000000009,59,0.07500000000000284,0),vec4(94.0500000000009,74,0.07500000000000284,0),vec4(94.12500000000091,76,0.07500000000000284,0),vec4(94.20000000000091,54,0.20156249999999432,0),vec4(94.20000000000091,78,0.23906249999998863,0),vec4(94.5000000000009,59,0.07500000000000284,0),vec4(94.5000000000009,74,0.15000000000000568,0),vec4(94.6500000000009,54,0.07500000000000284,0),vec4(94.6500000000009,78,0.15000000000000568,0),vec4(94.8000000000009,50,0.20156249999999432,0),vec4(94.8000000000009,83,0.29999999999999716,0),vec4(95.1000000000009,47,0.07500000000000284,0),vec4(95.25000000000091,50,0.07500000000000284,0),vec4(95.1000000000009,78,0.30000000000001137,0),vec4(95.40000000000092,76,0.15000000000000568,0),vec4(95.40000000000092,54,0.20156250000000853,0),vec4(95.55000000000092,74,0.15000000000000568,0),vec4(95.70000000000093,73,0.15000000000000568,0),vec4(95.70000000000093,42,0.20156250000000853,0),vec4(95.85000000000093,74,0.11015625000000284,0),vec4(95.96015625000094,73,0.03984375000000284,0),vec4(96.00000000000094,47,0.5015625000000057,0),vec4(96.00000000000094,71,0.5015625000000057,0),vec4(96.00000000000094,66,0.5015625000000057,0),vec4(96.00000000000094,62,0.5015625000000057,0));    \n    vec4 note = _[n];\n    note.xz /= SPEED;\n    return note;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}", "sound_code": "\n// Various temperaments, expressed as the number of cents from which they differ\n// from the equal temperament.\n// https://en.wikipedia.org/wiki/Musical_temperament\n\n// 12-tone equal temperament\n//const float[] adjustment = float[12](0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.);\n\n// Five-limit tuning: unpleasant intervals appear when modulating\nconst float[] adjustment = float[12](0., 12., 4., 16., -14., -2., -10., 2., 14., -16., 18., -12.);\n\n// 1/4 comma meantone\n//const float[] adjustment = float[12](0., 16., -6., 10., -13., 3., -19., -3., 13., -10., 6., -16.);\n\nfloat pitch(float i)\n{\n    // Chromatic scale degree within the B minor scale.\n    // Goes from 0 (note B) to 11 (note A#).\n    int degree = int(mod(i - 6., 12.));\n    // Baroque tuning (middle A = 415hz vs 440hz)\n    // Adjust each degree with the number of cents prescribed.\n    return 415. * pow(2., (i - 69. + 0.01*adjustment[degree]) / 12.);\n}\n\nvec2 wave(vec2 f, vec2 a, float time)\n{\n    vec2 w = 2. * pi * f * time;\n    //float v = pow(abs(sin(w / 2.)), 8.) - .5;\n    //float v = pow(max(0., (sin(w) + 1.) / 2.), 2.) - .5;\n    vec2 sw = sin(w/2.);\n    vec2 sw2 = sw*sw;\n    //vec2 v = sw2*sw2 - .375; // Remove DC offset\n    vec2 v = sw2*sw2*sw2 - .3125; // Remove DC offset\n    a *= sqrt(clamp(800./f, 1., 10.));\n    return a * v;\n}\n\nvec2 organ(vec2 f, float time)\n{\n    vec2 sound = vec2(0);\n    sound += wave(f, vec2(.08), time);\n    sound += wave(f * 2., vec2(0.8,1)*.01, time);\n    sound += wave(f * 4., vec2(.004), time);\n    sound += wave(f * .5, vec2(1,0.5)*.008, time);\n    return sound;\n}\n\n\nvec2 mainSound(int samp, float time)\n{\n    vec2 sound = vec2(0);\n\n    float t = time - t_offset;\n    for (int i=min(0, int(iSampleRate)) ; i<n_notes ; ++i)\n    {\n        vec4 note = notes(i);\n        if (note.w == -1.)\n            continue;\n        if (note.x < t && t < note.x + note.z  + 5.)\n        {\n            float f = pitch(note.y);\n            // Add random pitch variation per note,\n            // so that if several notes with the same pitch are\n            // played at the same time, they are still\n            // decorrelated.\n            // Otherwise the combined tone sounds too loud\n            // (amplitude proportional to n, instead of sqrt(n)).\n            f += 0.3*sin(float(i));\n            \n            float pos = sin(note.w);\n            vec2 pan = sqrt(vec2(1) + 0.5*vec2(1,-1)*pos);\n            \n            \n            float t_in = t - note.x; // Time since attack\n            float t_out = t_in - note.z; // Time since release\n            float env = smoothstep(0., .05, t_in) * smoothstep(.05,0.,t_out);\n            sound += pan*env*organ(vec2(f), time);\n            float rtime = 0.1 + smoothstep(100.,400.,f);\n            float rtau = 99./rtime; // Reverb decay time: lower for bass notes\n            float env_verb = clamp(1.-exp(-t_in*rtau),0.,1.)*clamp(exp(-t_out*rtau),0.,1.);\n            sound += 0.5 * rtime * env_verb * organ(f+vec2(-.2,.32), time);\n            \n        }\n    }\n\n    return sound;\n}\n", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsXWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[293, 293, 322, 403, 517], [519, 519, 547, 596, 676], [678, 678, 712, 712, 806], [808, 808, 869, 916, 1050], [1052, 1052, 1093, 1093, 1611], [1613, 1613, 1639, 1639, 1686], [1688, 1688, 1707, 1707, 3054], [3056, 3056, 3090, 3090, 3129], [3131, 3131, 3188, 3188, 3560]], "test": "untested"}
{"id": "NlsXWn", "name": "Lofi mansion", "author": "mare", "description": "Pseudo random number based whistling improsation, on trivial 2-5-1 \n * obstructed by some passages and scratches. \n * Pseudo random beat features, \n * floating rhytm and tuning,\n * some accidental artifacts that came from bugs, but I like them.", "tags": ["audio"], "likes": 10, "viewed": 397, "published": 3, "date": "1626814447", "time_retrieved": "2024-07-30T19:10:03.010497", "image_code": "\nfloat circle( vec2 uv, vec2 center,float radius )\n{\n    return 1.0 - (smoothstep( radius -.02, radius + .02, length( uv - center ) ) );\n}\nfloat arc( vec2 uv, vec2 a, vec2 b )\n{\n    vec2 diff = b - a;\n    float dist = length(diff);\n    vec2 diff90 = vec2( diff.y, -diff.x );\n    vec2 center = a + .866025 * diff90 + .5 * diff;\n    float distToCenter = length( uv - center );\n    \n    float circleVal = max(.0, 1.0 - 40.0 * abs( distToCenter - dist ) );\n    return circleVal * \n        clamp( 50.0 * dot( diff, uv - a), .0, 1.0 ) * \n        clamp( 50.0 * dot( -diff, uv - b), .0, 1.0 ) * \n        clamp( 50.0 * dot( uv - center, a - center), .0, 1.0 );\n        \n}\n#define INV_MUL(a,b) (1.0-(1.0-(a))*(1.0-(b)))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float time = 2.* iTime + 1.5 * sin( iTime * .5 );\n    vec2 uv = ( fragCoord - vec2( (iResolution.x - iResolution.y) * .5, 0 ) )/iResolution.y - vec2( .5 );\n\n    // Time varying pixel color\n    vec2 a = vec2( .3,.15) + vec2(sin(time*.9+32.)*0.1, sin(time*.2+124.)*.3);\n    vec2 b = vec2( .1,-.2) + vec2(sin(time*.7+98.)*0.1, sin(time*.1+987.)*.35);\n    vec2 c = vec2( -.4,.05) + vec2(sin(time*.8+24.)*0.15, sin(time*.3+156.)*.3);\n    vec2 d = vec2( .0,.25) + vec2(sin(time*.75+95.)*0.07, sin(time*.25+696.)*.1);\n    float col = circle( uv, a, .15 + sin(time*1.94+75.)*0.01);\n    col = INV_MUL( col, circle( uv, b, .075 + sin(time*2.1+26.)*0.01 ) );\n    col = INV_MUL( col, circle( uv, c, .1 + sin(time*1.3+81.)*0.02) );\n    col = INV_MUL( col, circle( uv, d, .1 + sin(time*2.94+81.)*0.003) );\n    col = INV_MUL( col, arc( uv, b,a ) );\n    col = INV_MUL( col, arc( uv, b,c ) );\n    col = INV_MUL( col, arc( uv, a,c ) );\n    col = INV_MUL( col, arc( uv, d,c ) );\n    col = INV_MUL( col, arc( uv, d,a ) );\n    col = INV_MUL( col, arc( uv, d,b ) );\n    float contour = clamp( 30.*(col-.55)*(col - .45),.0,1.0 );\n    col = min(col, 1.0 );\n\n    // Output to screen\n    fragColor = vec4(contour - col * .2 ,contour - col * .07, contour,1.0);\n}", "image_inputs": [], "sound_code": "#define TONE(i,f) sin(c_tg*f*float(i))\n#define TONE_UNTUNED( i, f,d) vec2(TONE(i,(1.-d)*f),TONE(i,(1.+d)*f))\n#define LIMIT(x,l) clamp(x,-l,l)*1./l\n#define TONE_MP(i,f,lp,hp) TONE(i,f)*clamp(min((f-lp)*.01,(hp-f)*.01),.0,1.)\n#define RAND(i) (fract(8023.*sin(float(i)*0.0876))*2.-1.)\n//#define RAND_INT(i,a) (((91331*(i)+15698)/((i)+11))%(a))\n#define RAND_INT(i,a) ((int((RAND(i)+1.0)*1.2e3))%(a))\n\n\n#define SPEED_UP_CYCLE 13\n\nfloat att( int samp, int len, float attack )\n{\n    float dt = float( samp );\n    float x = clamp( min( dt * attack,( float( len ) - dt ) )/ float( len ), .0, 1.0 );\n    x *= x; x *= x; return x;\n}\n\nfloat kick( int samp, float c_tg )\n{\n    float sine = TONE( samp, 30. ) + TONE( samp, 50. ) + TONE( samp, 80. );\n    sine *= att( samp, 15000, 1000.0 );\n    return LIMIT( sine, .8 ) * .2;\n}\nvec2 bass ( int samp, float f, float c_tg )\n{\n    vec2 sine = TONE_UNTUNED( samp, f, .003 ) * .3 + TONE_UNTUNED( samp, f * 2., -.003 ) * .3;\n    sine = vec2( LIMIT( sine.x, .8 ), LIMIT( sine.y, .8 ) );\n    return sine;\n}\n\nfloat hat( int samp )\n{\n    \n    float sine = RAND( samp % 8000 );\n    sine -= .2 * RAND( ( samp - 4 ) % 8000 );\n    sine -= .2 * RAND( ( samp - 3 ) % 8000 );\n    sine -= .2 * RAND( ( samp - 2 ) % 8000 );\n    sine -= .2 * RAND( ( samp - 1 ) % 8000 );\n    sine -= .2 * RAND( ( samp + 1 ) % 8000 );\n    sine -= .2 * RAND( ( samp + 2 ) % 8000 );\n    sine -= .2 * RAND( ( samp + 3 ) % 8000 );\n    sine -= .2 * RAND( ( samp + 4 ) % 8000 );\n    \n    sine *= att( samp, 18000, 30.0 );\n    return sine * 0.02;\n}\n\nfloat snare( int samp )\n{\n    float sine = RAND( samp / 10 );\n    float sine2 = RAND( samp / 3 );\n    float sine3 = RAND( samp );\n    sine *= att( samp, 17000, 1000.0 );\n    sine2 *= att( samp, 15000, 3.0 );\n    sine3 *= ( \n        att( samp, 5000, 10000.0 ) + \n        att( samp - 1500, 5000, 10000.0 ) * .4 + \n        att( samp - 3000, 5000, 10000.0 ) * .16 );\n    \n    return sine * .1 + sine2 * .3 + sine3 * .2;\n}\n\nconst int bpm = 200;\nconst int beatSampCount = 60 * 44100 / bpm;\nconst float progressionRatios[8] = float[8](1.125, 1.5, 1., 1., 2.25, 1.5, 1., 1. );\nconst float relative3rds[8] = float[8](1.2, 1.25, 1.25, 1.2, 1.2, 1.25, 1.2, 1.2 );\nconst float relative7ths[8] = float[8](1.75, 1.75, 1.888889, 1.66667, 1.75, 1.75, 1.888889, 1.888889 );\nconst int phraseQualityOffset[8] = int[8](17,0,0,0,17,0,0,0);\nconst float orderedRations[34] = float[34](\n    .0,\n    1.0,1.125,1.25, 1.33333,\n    1.5,1.666667, 1.75, 1.888888,\n    2.0, 2.25, 2.5, 2.66667,\n    3.0,3.33333, 3.5, 3.777777,\n    // major\n    .0,\n    1.0,1.111111,1.2, 1.33333,\n    1.5,1.666667, 1.75, 1.888888,\n    2.0, 2.222222, 2.4, 2.66667,\n    3.0, 3.142857, 3.5, 3.777777\n    // minor\n    \n    );\n    #define MELODY_LICK_COUNT 10\n    \nconst int melodyIndices[12*MELODY_LICK_COUNT] = int[12*MELODY_LICK_COUNT](\n    0,0,0,0,0,0,9,8,6,5,3,2,\n    1,2,0,2,6,7,9,11,10,0,0,0,\n    0,0,13,14,15,16,9,10,9,10,11,12,\n    13,0,7,0,10,11,5,6,6,5,6,7,\n    0,0,3,0,2,0,1,0,8,0,7,0,\n    5,4,3,2,2,2,1,0,2,0,3,0,\n    5,0,7,0,11,10,9,0,9,8,7,6,\n    0,0,6,8,9,10,8,0,5,6,0,0,\n    0,0,0,0,1,2,3,0,0,5,0,0,\n    17,16,14,13,11,10,9,13,9,5,0,0\n    );\n    \nconst int bassWalk[7] = int[7](\n    1,3,5,7,8,7,3\n    );\n    \n#define RHYTM_SAMPLE(samp) (samp+int(1000.*(TONE(samp,.3)+TONE(samp,.08))))\n    \nfloat chordLayer( int samp, float c_tg )\n{\n    int rhytmSamp = RHYTM_SAMPLE(samp);\n    int phraseLength = beatSampCount * 12;\n   \n    \n    int phraseIndexPrior = rhytmSamp / phraseLength;\n    int speedUpMask = 1 - min( phraseIndexPrior % SPEED_UP_CYCLE, 1);\n    int sustain = ( phraseLength * ( 1 + speedUpMask * 3) )/ 2;\n    rhytmSamp += int( 2. * float( speedUpMask * rhytmSamp ) );\n    \n    \n    \n    int phraseIndex = rhytmSamp / phraseLength;\n    int speedUpCount = ( phraseIndexPrior + SPEED_UP_CYCLE - 1 ) / SPEED_UP_CYCLE;\n    phraseIndex -= speedUpCount;\n    int phraseMod = phraseIndex & 7;\n    int phraseSamp = (rhytmSamp % phraseLength );\n    float f = progressionRatios[phraseMod] * 110.0 * (1.0 + .00004 - .00004 * TONE( samp, 8.02 ));\n    \n    \n    float chord1f = f;\n    float chord3f = relative3rds[phraseMod] * chord1f * 2.0;\n    float chord5f = 1.5 * chord1f * 4.;\n    float chord7f = relative7ths[phraseMod] * chord1f * 4.0;\n    float chord9f =  2.25 * chord1f * 2.0;\n    \n    int sineSamp = samp % ( phraseLength * 5 );\n    return\n    \n        TONE( sineSamp, chord1f) * .03 * att(phraseSamp, sustain, 100.0) + \n        TONE( sineSamp, chord3f) * .03 * att(phraseSamp - 8000, sustain, 100.0) + \n        TONE( sineSamp, chord5f) * .02 * att(phraseSamp - 3000, sustain, 100.0) + \n        TONE( sineSamp, chord7f) * .01 * att(phraseSamp, sustain, 100.0) + \n        TONE( sineSamp, chord9f) * .03 * att(phraseSamp - 3000, sustain, 100.0) + \n        TONE( sineSamp, chord9f) * .04 * att(phraseSamp - 13000, sustain, 100.0) +\n        TONE( sineSamp, chord1f) * .03 * float(RAND_INT(phraseIndex+324,2)) * att(phraseSamp - beatSampCount*(2+RAND_INT(phraseIndex+933,6)), phraseLength/2, 100.0) + \n        TONE( sineSamp, chord3f) * .03 * float(RAND_INT(phraseIndex+957,2)) * att(phraseSamp - beatSampCount*(2+RAND_INT(phraseIndex+462,6)), phraseLength/2, 100.0) + \n        TONE( sineSamp, chord5f) * .02 * float(RAND_INT(phraseIndex+234,2)) * att(phraseSamp - beatSampCount*(2+RAND_INT(phraseIndex+116,6)), phraseLength/2, 100.0) + \n        TONE( sineSamp, chord7f) * .01 * float(RAND_INT(phraseIndex+634,2)) * att(phraseSamp - beatSampCount*(2+RAND_INT(phraseIndex+697,6)), phraseLength/2, 100.0) + \n        TONE( sineSamp, chord9f) * .03 * float(RAND_INT(phraseIndex+199,2)) * att(phraseSamp - beatSampCount*(2+RAND_INT(phraseIndex+555,6)), phraseLength/2, 100.0) + \n        TONE( sineSamp, chord9f) * .04 * float(RAND_INT(phraseIndex+846,2)) * att(phraseSamp - beatSampCount*(2+RAND_INT(phraseIndex+698,6)), phraseLength/2, 100.0);      \n}\n\nfloat beatLayer( int samp, float c_tg )\n{\n    int rythmSamp = RHYTM_SAMPLE(samp);\n    int barLength = beatSampCount * 3;\n    int barSamp = (rythmSamp % barLength );\n    int barIndex = rythmSamp / barLength;\n    int phraseLength = beatSampCount * 12;\n    int phraseIndex = rythmSamp / phraseLength;\n    int phraseMod = phraseIndex & 7;\n    int phraseSamp = (rythmSamp % phraseLength );\n    int kickOffset1 = (RAND_INT(phraseIndex+748,4)- 2);\n    int kickOffset2 = kickOffset1 + (RAND_INT(phraseIndex+748,1 - kickOffset1) ) + 1;\n    \n\n     return \n        kick( phraseSamp, c_tg ) + \n        kick( phraseSamp - phraseLength / 2 + kickOffset1*beatSampCount , c_tg ) + \n        kick( phraseSamp - phraseLength / 2 + kickOffset2*beatSampCount , c_tg ) + \n        \n        hat( phraseSamp ) +\n        hat( barSamp - beatSampCount + 50 ) +\n        hat( barSamp - beatSampCount - beatSampCount ) +\n        hat( phraseSamp - beatSampCount / 2 - beatSampCount * ( RAND_INT( barIndex+493,13 ) ) ) +\n        \n        hat( phraseSamp - 3 * beatSampCount / 2) * .2+\n        hat( barSamp - 3 * beatSampCount / 2 - beatSampCount + 50 ) * .2 +\n        hat( barSamp - 3 * beatSampCount / 2 - beatSampCount - beatSampCount ) * .2 +\n        snare( phraseSamp - phraseLength / 4  ) + \n        snare( phraseSamp - 3 * phraseLength / 4 );\n        \n}\n    \nvec2 mainSound( int samp, float time )\n{\n    float c_tg = 6.2831 / iSampleRate; // sine tangent   \n    int rhytmSamp = RHYTM_SAMPLE(samp);\n    int barLength = 3 * beatSampCount;\n    int phraseLength = beatSampCount * 12;  \n    int phraseIndexPrior = rhytmSamp / phraseLength;\n    int speedUpMask = 1 - min( phraseIndexPrior % SPEED_UP_CYCLE, 1);\n    rhytmSamp += int( 2. * float( speedUpMask * rhytmSamp ) );\n    \n    int beatSamp = (rhytmSamp % beatSampCount );\n    int barSamp = (rhytmSamp % barLength );\n    int barIndex = rhytmSamp / barLength;\n    int beatIndex = rhytmSamp / beatSampCount;\n    \n    int phraseIndex = barIndex / 4;\n    int speedUpCount = ( phraseIndexPrior + SPEED_UP_CYCLE - 1 ) / SPEED_UP_CYCLE;\n    phraseIndex -= speedUpCount;\n    \n    int phraseSamp = (rhytmSamp % phraseLength );\n    int phraseMod = phraseIndex & 7;\n    int sineSamp = samp % ( phraseLength * 5 );\n    \n    \n    float f = progressionRatios[phraseMod] * 110.0 * (1.0 + .000005 * TONE( samp, 8.02 ));\n    float f2  = progressionRatios[phraseMod & 3] * 110.0 * (1.0 + .000005 * TONE( samp, 8.02 ));\n    int cycleRange = int( iSampleRate / (f *4.) );\n    float barBack = 4.0 *  (float (barSamp) / float(barLength) ) * (float (barLength-barSamp) / float(barLength) );\n    \n    int lickIndex = RAND_INT( (barIndex / 2), MELODY_LICK_COUNT);\n    int melodyMod = (beatIndex % 6 ) + 6 * lickIndex;\n    float melodyF1 = f2 * 4.0 * orderedRations[ melodyIndices[ 2 * melodyMod ] + phraseQualityOffset[phraseMod] ];\n    float melodyF2 = f2 * 4.0 * orderedRations[ melodyIndices[ 2 * melodyMod + 1 ] + phraseQualityOffset[phraseMod]];\n    float bassF = f2 * .25 * orderedRations[ bassWalk[ (barIndex*2) % 7 ] + phraseQualityOffset[phraseMod]];\n    float bassF2 = f2 * .25 * orderedRations[ bassWalk[ (barIndex*2 + 1) % 7 ] + phraseQualityOffset[phraseMod]];\n    \n    float scratchMask = ( max( -TONE( rhytmSamp - int(100. * TONE( rhytmSamp, .4 ) ), .125 * iSampleRate / float(phraseLength) ), .96 ) - .96 ) * 25.0;\n    scratchMask = max( scratchMask, clamp( .1 * time - 17.0,  .0, 1.0 ) );\n    int scratchDistortion = int( 6000. * TONE( rhytmSamp, 4.0 ) * scratchMask );\n    float maskFloat = 1.0 - float(speedUpMask);\n    float melodyMask = float(speedUpCount & 1 );\n    float tatTatMask = float((speedUpCount/2) & 1 );\n    \n    vec2 sound =\n        vec2( beatLayer(samp + scratchDistortion, c_tg) ) * maskFloat +\n        vec2( chordLayer(samp + scratchDistortion, c_tg) ) + \n        bass( sineSamp, bassF, c_tg ) * .3 * att(barSamp, barLength, 100.0) * maskFloat + \n        bass( sineSamp, bassF2, c_tg ) * .3 * att(barSamp - 2 * barLength, barLength, 100.0) * maskFloat + \n        TONE_UNTUNED( sineSamp, melodyF1,.01)* .6 * att(beatSamp, beatSampCount/2, 2.0) * maskFloat * melodyMask + \n        TONE_UNTUNED( sineSamp, melodyF2,-.02)* .2 * att(beatSamp - 2*beatSampCount/3, beatSampCount/3, 2.0) * maskFloat * melodyMask + \n        TONE_UNTUNED( sineSamp, 1.5 * f, .001 )*att(barSamp - beatSampCount + 50, beatSampCount, 10.0) * .2 * maskFloat * tatTatMask+ \n        TONE_UNTUNED( sineSamp, 1.5 * 1.2 * f,-.001 )*att(barSamp - beatSampCount - beatSampCount, beatSampCount, 10.0)* .2 * maskFloat * tatTatMask\n        ;\n    return sound * clamp( ( 180.0 - time ) * .2, .0, 1.0 );\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlsXWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 52, 52, 138], [139, 139, 177, 177, 662], [711, 711, 768, 818, 2058]], "test": "untested"}
{"id": "fllSWl", "name": "Rainbowspiral", "author": "phaiax", "description": "First shader :)", "tags": ["rainbow"], "likes": 2, "viewed": 232, "published": 3, "date": "1626810294", "time_retrieved": "2024-07-30T19:10:03.817339", "image_code": "\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/vec2(iResolution.y, iResolution.y);\n    vec2 m = iMouse.xy/vec2(iResolution.y, iResolution.y);\n    vec2 v = st - m;\n    v = v / 0.01;\n    float tau = 6.283185;\n    float hue = atan(v.x, v.y)/tau;\n    hue = hue + length(v)/80. - iTime/2.;\n    vec3 rgb = hsl2rgb ( vec3(hue, 1., \n                              cos(2.0-length(v)*3.5)));\n    fragColor = vec4(rgb.r,rgb.g,rgb.b,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fllSWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 29, 29, 171], [173, 173, 230, 230, 638]], "test": "untested"}
{"id": "7tfXDs", "name": "Rainbow ribbon spirals", "author": "jarble", "description": "This fractal has many colorful ribbons.", "tags": ["fractal", "ribbon", "spiral"], "likes": 3, "viewed": 242, "published": 3, "date": "1626809525", "time_retrieved": "2024-07-30T19:10:04.730897", "image_code": "\n//Try changing these parameters to get more crazy patterns!\n#define s1 2.\n#define scale 2.1\n#define scale1 1.14\n\n#define ITERS 12\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    float t=0.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/20.0;\n    uv.y += (iTime)/25.0;\n    for(int c=0;c<ITERS;c++){\n        col_prev = col;\n        \n        for(int i=0;i<ITERS;i++)\n        {\n            uv = fract(uv.yx);\n            uv= (uv+((vec2(uv.x/scale-uv.y/scale1,uv.y/scale-uv.x/scale1)/(scale))))/scale1;\n            uv.x *= scale1/s1;\n            \n            uv.y /= -scale1/s1;\n            \n        }\n        col[2] = abs((uv.y)-(uv.x));\n        col = ((col+col_prev.yzx))/2.2;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tfXDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[131, 131, 188, 188, 824]], "test": "untested"}
{"id": "NljGR1", "name": "Meta CRT - Single Pass", "author": "P_Malin", "description": "A single pass version of Meta CRT : https://www.shadertoy.com/view/4dlyWX", "tags": ["crt"], "likes": 43, "viewed": 2374, "published": 3, "date": "1626808516", "time_retrieved": "2024-07-30T19:10:05.877830", "image_code": "// Meta CRT - Single Pass - @P_Malin\n// A single pass version of Meta CRT : https://www.shadertoy.com/view/4dlyWX\n\n// This can be used as a webcam fiter in Memix\n// See github here : https://github.com/pmalin/pmalin-memix-shaders\n\n//#define FIXED_CAMERA_INDEX 2\n\n#define FLIP_V 0\n\n#define USE_MOUSE 0\n\n\n#define PI 3.141592654\n\n\n///////////////////////////\n// Hash Functions\n///////////////////////////\n\n// From: Hash without Sine by Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n//#define HASHSCALE1 .1031\n//#define HASHSCALE3 vec3(.1031, .1030, .0973)\n//#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n#define kMaxTraceDist 1000.0\n#define kFarDist 1100.0\n\n#define MAT_FG_BEGIN \t10\n\n///////////////////////////\n// Scene\n///////////////////////////\n\nstruct SceneResult\n{\n\tfloat fDist;\n\tint iObjectId;\n    vec3 vUVW;\n};\n    \nvoid Scene_Union( inout SceneResult a, in SceneResult b )\n{\n    if ( b.fDist < a.fDist )\n    {\n        a = b;\n    }\n}\n\n    \nvoid Scene_Subtract( inout SceneResult a, in SceneResult b )\n{\n    if ( a.fDist < -b.fDist )\n    {\n        a.fDist = -b.fDist;\n        a.iObjectId = b.iObjectId;\n        a.vUVW = b.vUVW;\n    }\n}\n\nSceneResult Scene_GetDistance( vec3 vPos );    \n\nvec3 Scene_GetNormal(const in vec3 vPos)\n{\n    const float fDelta = 0.0001;\n    vec2 e = vec2( -1, 1 );\n    \n    vec3 vNormal = \n        Scene_GetDistance( e.yxx * fDelta + vPos ).fDist * e.yxx + \n        Scene_GetDistance( e.xxy * fDelta + vPos ).fDist * e.xxy + \n        Scene_GetDistance( e.xyx * fDelta + vPos ).fDist * e.xyx + \n        Scene_GetDistance( e.yyy * fDelta + vPos ).fDist * e.yyy;\n    \n    return normalize( vNormal );\n}    \n    \nSceneResult Scene_Trace( const in vec3 vRayOrigin, const in vec3 vRayDir, float minDist, float maxDist )\n{\t\n    SceneResult result;\n    result.fDist = 0.0;\n    result.vUVW = vec3(0.0);\n    result.iObjectId = -1;\n    \n\tfloat t = minDist;\n\tconst int kRaymarchMaxIter = 128;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\t\t\n        float epsilon = 0.0001 * t;\n\t\tresult = Scene_GetDistance( vRayOrigin + vRayDir * t );\n        if ( abs(result.fDist) < epsilon )\n\t\t{\n\t\t\tbreak;\n\t\t}\n                        \n        if ( t > maxDist )\n        {\n            result.iObjectId = -1;\n\t        t = maxDist;\n            break;\n        }       \n        \n        if ( result.fDist > 1.0 )\n        {\n            result.iObjectId = -1;            \n        }    \n        \n        t += result.fDist;        \n\t}\n    \n    result.fDist = t;\n\n\n    return result;\n}    \n\nfloat Scene_TraceShadow( const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fMinDist, const in float fLightDist )\n{\n    //return 1.0;\n    //return ( Scene_Trace( vRayOrigin, vRayDir, 0.1, fLightDist ).fDist < fLightDist ? 0.0 : 1.0;\n    \n\tfloat res = 1.0;\n    float t = fMinDist;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = Scene_GetDistance( vRayOrigin + vRayDir * t ).fDist;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.0001 || t>fLightDist ) break;\n    }\n    return clamp( res, 0.0, 1.0 );    \n}\n\nfloat Scene_GetAmbientOcclusion( const in vec3 vPos, const in vec3 vDir )\n{\n    float fOcclusion = 0.0;\n    float fScale = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float fOffsetDist = 0.001 + 0.1*float(i)/4.0;\n        vec3 vAOPos = vDir * fOffsetDist + vPos;\n        float fDist = Scene_GetDistance( vAOPos ).fDist;\n        fOcclusion += (fOffsetDist - fDist) * fScale;\n        fScale *= 0.4;\n    }\n    \n    return clamp( 1.0 - 30.0*fOcclusion, 0.0, 1.0 );\n}\n\n///////////////////////////\n// Lighting\n///////////////////////////\n    \nstruct SurfaceInfo\n{\n    vec3 vPos;\n    vec3 vNormal;\n    vec3 vBumpNormal;    \n    vec3 vAlbedo;\n    vec3 vR0;\n    float fSmoothness;\n    vec3 vEmissive;\n};\n    \nSurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, SceneResult traceResult );\n\nstruct SurfaceLighting\n{\n    vec3 vDiffuse;\n    vec3 vSpecular;\n};\n    \nSurfaceLighting Scene_GetSurfaceLighting( const in vec3 vRayDir, in SurfaceInfo surfaceInfo );\n\nfloat Light_GIV( float dotNV, float k)\n{\n\treturn 1.0 / ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nvoid Light_Add(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fNDotL = clamp(dot(vLightDir, surface.vBumpNormal), 0.0, 1.0);\n\t\n\tlighting.vDiffuse += vLightColour * fNDotL;\n    \n\tvec3 vH = normalize( -vViewDir + vLightDir );\n\tfloat fNdotV = clamp(dot(-vViewDir, surface.vBumpNormal), 0.0, 1.0);\n\tfloat fNdotH = clamp(dot(surface.vBumpNormal, vH), 0.0, 1.0);\n    \n\tfloat alpha = 1.0 - surface.fSmoothness;\n\t// D\n\n\tfloat alphaSqr = alpha * alpha;\n\tfloat denom = fNdotH * fNdotH * (alphaSqr - 1.0) + 1.0;\n\tfloat d = alphaSqr / (PI * denom * denom);\n\n\tfloat k = alpha / 2.0;\n\tfloat vis = Light_GIV(fNDotL, k) * Light_GIV(fNdotV, k);\n\n\tfloat fSpecularIntensity = d * vis * fNDotL;    \n\tlighting.vSpecular += vLightColour * fSpecularIntensity;    \n}\n\nvoid Light_AddPoint(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightPos, const in vec3 vLightColour)\n{    \n    vec3 vPos = surface.vPos;\n\tvec3 vToLight = vLightPos - vPos;\t\n    \n\tvec3 vLightDir = normalize(vToLight);\n\tfloat fDistance2 = dot(vToLight, vToLight);\n\tfloat fAttenuation = 100.0 / (fDistance2);\n\t\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 0.1, length(vToLight) );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);\n}\n\nvoid Light_AddDirectional(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\t\n\tfloat fAttenuation = 1.0;\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 0.1, 10.0 );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);\n}\n\nvec3 Light_GetFresnel( vec3 vView, vec3 vNormal, vec3 vR0, float fGloss )\n{\n    float NdotV = max( 0.0, dot( vView, vNormal ) );\n\n    return vR0 + (vec3(1.0) - vR0) * pow( 1.0 - NdotV, 5.0 ) * pow( fGloss, 20.0 );\n}\n\nvoid Env_AddPointLightFlare(inout vec3 vEmissiveGlow, const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fIntersectDistance, const in vec3 vLightPos, const in vec3 vLightColour)\n{\n    vec3 vToLight = vLightPos - vRayOrigin;\n    float fPointDot = dot(vToLight, vRayDir);\n    fPointDot = clamp(fPointDot, 0.0, fIntersectDistance);\n\n    vec3 vClosestPoint = vRayOrigin + vRayDir * fPointDot;\n    float fDist = length(vClosestPoint - vLightPos);\n\tvEmissiveGlow += sqrt(vLightColour * 0.05 / (fDist * fDist));\n}\n\nvoid Env_AddDirectionalLightFlareToFog(inout vec3 vFogColour, const in vec3 vRayDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fDirDot = clamp(dot(vLightDir, vRayDir) * 0.5 + 0.5, 0.0, 1.0);\n\tfloat kSpreadPower = 2.0;\n\tvFogColour += vLightColour * pow(fDirDot, kSpreadPower) * 0.25;\n}\n\n\n///////////////////////////\n// Rendering\n///////////////////////////\n\nvec4 Env_GetSkyColor( const vec3 vViewPos, const vec3 vViewDir );\nvec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist );\nvec3 FX_Apply( in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist);\n\nvec4 Scene_GetColorAndDepth( vec3 vRayOrigin, vec3 vRayDir )\n{\n\tvec3 vResultColor = vec3(0.0);\n            \n\tSceneResult firstTraceResult;\n    \n    float fStartDist = 0.0f;\n    float fMaxDist = 10.0f;\n    \n    vec3 vRemaining = vec3(1.0);\n    \n\tfor( int iPassIndex=0; iPassIndex < 3; iPassIndex++ )\n    {\n    \tSceneResult traceResult = Scene_Trace( vRayOrigin, vRayDir, fStartDist, fMaxDist );\n\n        if ( iPassIndex == 0 )\n        {\n            firstTraceResult = traceResult;\n        }\n        \n        vec3 vColor = vec3(0);\n        vec3 vReflectAmount = vec3(0);\n        \n\t\tif( traceResult.iObjectId < 0 )\n\t\t{\n            vColor = Env_GetSkyColor( vRayOrigin, vRayDir ).rgb;\n        }\n        else\n        {\n            \n            SurfaceInfo surfaceInfo = Scene_GetSurfaceInfo( vRayOrigin, vRayDir, traceResult );\n            SurfaceLighting surfaceLighting = Scene_GetSurfaceLighting( vRayDir, surfaceInfo );\n                \n            // calculate reflectance (Fresnel)\n\t\t\tvReflectAmount = Light_GetFresnel( -vRayDir, surfaceInfo.vBumpNormal, surfaceInfo.vR0, surfaceInfo.fSmoothness );\n\t\t\t\n\t\t\tvColor = (surfaceInfo.vAlbedo * surfaceLighting.vDiffuse + surfaceInfo.vEmissive) * (vec3(1.0) - vReflectAmount); \n            \n            vec3 vReflectRayOrigin = surfaceInfo.vPos;\n            vec3 vReflectRayDir = normalize( reflect( vRayDir, surfaceInfo.vBumpNormal ) );\n            fStartDist = 0.001 / max(0.0000001,abs(dot( vReflectRayDir, surfaceInfo.vNormal ))); \n\n            vColor += surfaceLighting.vSpecular * vReflectAmount;            \n\n\t\t\tvColor = Env_ApplyAtmosphere( vColor, vRayOrigin, vRayDir, traceResult.fDist );\n\t\t\tvColor = FX_Apply( vColor, vRayOrigin, vRayDir, traceResult.fDist );\n            \n            vRayOrigin = vReflectRayOrigin;\n            vRayDir = vReflectRayDir;\n        }\n        \n        vResultColor += vColor * vRemaining;\n        vRemaining *= vReflectAmount;        \n    }\n \n    return vec4( vResultColor, firstTraceResult.fDist );\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n/////////////////////////\n// Scene Description\n/////////////////////////\n\n// Materials\n\n#define MAT_SKY\t\t \t-1\n#define MAT_DEFAULT \t 0\n#define MAT_SCREEN\t\t 1\n#define MAT_TV_CASING    2\n#define MAT_TV_TRIM      3\n#define MAT_CHROME       4\n\n\nvec3 PulseIntegral( vec3 x, float s1, float s2 )\n{\n    // Integral of function where result is 1.0 between s1 and s2 and 0 otherwise        \n\n    // V1\n    //if ( x > s2 ) return s2 - s1;\n\t//else if ( x > s1 ) return x - s1;\n\t//return 0.0f; \n    \n    // V2\n    //return clamp( (x - s1), 0.0f, s2 - s1);\n    //return t;\n    \n    return clamp( (x - s1), vec3(0.0f), vec3(s2 - s1));\n}\n\nfloat PulseIntegral( float x, float s1, float s2 )\n{\n    // Integral of function where result is 1.0 between s1 and s2 and 0 otherwise        \n\n    // V1\n    //if ( x > s2 ) return s2 - s1;\n\t//else if ( x > s1 ) return x - s1;\n\t//return 0.0f; \n    \n    // V2\n    //return clamp( (x - s1), 0.0f, s2 - s1);\n    //return t;\n    \n    return clamp( (x - s1), (0.0f), (s2 - s1));\n}\n\nvec3 Bayer( vec2 vUV, vec2 vBlur )\n{\n    vec3 x = vec3(vUV.x);\n    vec3 y = vec3(vUV.y);           \n\n    x += vec3(0.66, 0.33, 0.0);\n    y += 0.5 * step( fract( x * 0.5 ), vec3(0.5) );\n        \n    //x -= 0.5f;\n    //y -= 0.5f;\n    \n    x = fract( x );\n    y = fract( y );\n    \n    // cell centered at 0.5\n    \n    vec2 vSize = vec2(0.16f, 0.75f);\n    \n    vec2 vMin = 0.5 - vSize * 0.5;\n    vec2 vMax = 0.5 + vSize * 0.5;\n    \n    vec3 vResult= vec3(0.0);\n    \n    vec3 vResultX = (PulseIntegral( x + vBlur.x, vMin.x, vMax.x) - PulseIntegral( x - vBlur.x, vMin.x, vMax.x)) / min( vBlur.x, 1.0);\n    vec3 vResultY = (PulseIntegral(y + vBlur.y, vMin.y, vMax.y) - PulseIntegral(y - vBlur.y, vMin.y, vMax.y))  / min( vBlur.y, 1.0);\n    \n    vResult = min(vResultX,vResultY)  * 5.0;\n        \n    //vResult = vec3(1.0);\n    \n    return vResult;\n}\n\nvec3 GetPixelMatrix( vec2 vUV )\n{\n#if 1\n    vec2 dx = dFdx( vUV );\n    vec2 dy = dFdy( vUV );\n    float dU = length( vec2( dx.x, dy.x ) );\n    float dV = length( vec2( dx.y, dy.y ) );\n    if (dU <= 0.0 || dV <= 0.0 ) return vec3(1.0);\n    return Bayer( vUV, vec2(dU, dV) * 1.0);\n#else\n    return vec3(1.0);\n#endif\n}\n\nfloat Scanline( float y, float fBlur )\n{   \n    float fResult = sin( y * 10.0 ) * 0.45 + 0.55;\n    return mix( fResult, 1.0f, min( 1.0, fBlur ) );\n}\n\n\nfloat GetScanline( vec2 vUV )\n{\n#if 1\n    vUV.y *= 0.25;\n    vec2 dx = dFdx( vUV );\n    vec2 dy = dFdy( vUV );\n    float dV = length( vec2( dx.y, dy.y ) );\n    if (dV <= 0.0 ) return 1.0;\n    return Scanline( vUV.y, dV * 1.3 );\n#else\n    return 1.0;\n#endif\n}\n\n\nvec2 kScreenRsolution = vec2(480.0f, 576.0f);\n\nstruct Interference\n{\n    float noise;\n    float scanLineRandom;\n};\n\nfloat InterferenceHash(float p)\n{\n    float hashScale = 0.1031;\n\n    vec3 p3  = fract(vec3(p, p, p) * hashScale);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat InterferenceSmoothNoise1D( float x )\n{\n    float f0 = floor(x);\n    float fr = fract(x);\n\n    float h0 = InterferenceHash( f0 );\n    float h1 = InterferenceHash( f0 + 1.0 );\n\n    return h1 * fr + h0 * (1.0 - fr);\n}\n\n\nfloat InterferenceNoise( vec2 uv )\n{\n\tfloat displayVerticalLines = 483.0;\n    float scanLine = floor(uv.y * displayVerticalLines); \n    float scanPos = scanLine + uv.x;\n\tfloat timeSeed = fract( iTime * 123.78 );\n    \n    return InterferenceSmoothNoise1D( scanPos * 234.5 + timeSeed * 12345.6 );\n}\n    \nInterference GetInterference( vec2 vUV )\n{\n    Interference interference;\n        \n    interference.noise = InterferenceNoise( vUV );\n    interference.scanLineRandom = InterferenceHash(vUV.y * 100.0 + fract(iTime * 1234.0) * 12345.0);\n    \n    return interference;\n}\n    \nvec3 SampleScreen( vec3 vUVW )\n{   \n    vec3 vAmbientEmissive = vec3(0.1);\n    vec3 vBlackEmissive = vec3(0.02);\n    float fBrightness = 1.75;\n    vec2 vResolution = vec2(480.0f, 576.0f);\n    vec2 vPixelCoord = vUVW.xy * vResolution;\n    \n    vec3 vPixelMatrix = GetPixelMatrix( vPixelCoord );\n    float fScanline = GetScanline( vPixelCoord );\n      \n    vec2 vTextureUV = vUVW.xy;\n    //vec2 vTextureUV = vPixelCoord;\n    vTextureUV = floor(vTextureUV * vResolution * 2.0) / (vResolution * 2.0f);\n \n    \n    Interference interference = GetInterference( vTextureUV );\n\n    float noiseIntensity = 0.1;\n    \n    //vTextureUV.x += (interference.scanLineRandom * 2.0f - 1.0f) * 0.025f * noiseIntensity;\n           \n    vec2 vSampleUV = vTextureUV;\n    #if FLIP_V\n    vSampleUV.y = 1.0 - vSampleUV.y;\n    #endif\n    \n    vec3 vPixelEmissive = textureLod( iChannel0, vSampleUV.xy, 0.0 ).rgb;\n        \n    vPixelEmissive = vPixelEmissive * vPixelEmissive;\n        \n    vPixelEmissive = clamp( vPixelEmissive + (interference.noise - 0.5) * 2.0 * noiseIntensity, 0.0, 1.0 );\n    \n\tvec3 vResult = (vPixelEmissive * fBrightness + vBlackEmissive) * vPixelMatrix * fScanline + vAmbientEmissive;\n    \n    // TODO: feather edge?\n    if( any( greaterThanEqual( vUVW.xy, vec2(1.0) ) ) || any ( lessThan( vUVW.xy, vec2(0.0) ) ) || ( vUVW.z > 0.0 ) )\n    {\n        return vec3(0.0);\n    }\n    \n    return vResult;\n    \n}\n\nfloat Checker(vec2 vUV)\n{\n\treturn step(fract((floor(vUV.x) + floor(vUV.y)) * 0.5), 0.25);\n}\n\nSurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, SceneResult traceResult )\n{\n    SurfaceInfo surfaceInfo;\n    \n    surfaceInfo.vPos = vRayOrigin + vRayDir * (traceResult.fDist);\n    \n    surfaceInfo.vNormal = Scene_GetNormal( surfaceInfo.vPos ); \n    surfaceInfo.vBumpNormal = surfaceInfo.vNormal;\n    surfaceInfo.vAlbedo = vec3(1.0);\n    surfaceInfo.vR0 = vec3( 0.02 );\n    surfaceInfo.fSmoothness = 1.0;\n    surfaceInfo.vEmissive = vec3( 0.0 );\n    //return surfaceInfo;\n        \n    if ( traceResult.iObjectId == MAT_DEFAULT )\n    {\n    \tsurfaceInfo.vR0 = vec3( 0.02 );\n        float checker = Checker(traceResult.vUVW.xz * 4.0);\n\t    surfaceInfo.vAlbedo = mix( vec3(.9,.2,.2),vec3(.2,.2,.9), checker );                        \n    \tsurfaceInfo.fSmoothness = clamp( 1.0 - surfaceInfo.vAlbedo.r * surfaceInfo.vAlbedo.r * 2.0, 0.0, 1.0);\n        \n    }\n    \n    if ( traceResult.iObjectId == MAT_SCREEN )\n    {\n        surfaceInfo.vAlbedo = vec3(0.02); \n        surfaceInfo.vEmissive = SampleScreen( traceResult.vUVW );        \n    }\n\n    if ( traceResult.iObjectId == MAT_TV_CASING )\n    {\n        surfaceInfo.vAlbedo = vec3(0.5, 0.4, 0.3); \n\t    surfaceInfo.fSmoothness = 0.4;        \n    }\n    \n    if ( traceResult.iObjectId == MAT_TV_TRIM )\n    {\n        surfaceInfo.vAlbedo = vec3(0.03, 0.03, 0.05); \n\t    surfaceInfo.fSmoothness = 0.5;\n    }    \n\n    if ( traceResult.iObjectId == MAT_CHROME )\n    {\n        surfaceInfo.vAlbedo = vec3(0.01, 0.01, 0.01); \n\t    surfaceInfo.fSmoothness = 0.9;\n    \tsurfaceInfo.vR0 = vec3( 0.8 );\n    }    \n \n    return surfaceInfo;\n}\n\n// Scene Description\n\nfloat SmoothMin( float a, float b, float k )\n{\n\t//return min(a,b);\n\t\n\t\n    //float k = 0.06;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat UdRoundBox( vec3 p, vec3 b, float r )\n{\n    //vec3 vToFace = abs(p) - b;\n    //vec3 vConstrained = max( vToFace, 0.0 );\n    //return length( vConstrained ) - r;\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nSceneResult Scene_GetCRT( vec3 vScreenDomain, vec2 vScreenWH, float fScreenCurveRadius, float fBevel, float fDepth )\n{\n    SceneResult resultScreen;\n#if 1\n    vec3 vScreenClosest;\n    vScreenClosest.xy = max(abs(vScreenDomain.xy)-vScreenWH,0.0);\n    vec2 vCurveScreenDomain = vScreenDomain.xy;\n    vCurveScreenDomain = clamp( vCurveScreenDomain, -vScreenWH, vScreenWH );\n    float fCurveScreenProjection2 = fScreenCurveRadius * fScreenCurveRadius - vCurveScreenDomain.x * vCurveScreenDomain.x - vCurveScreenDomain.y * vCurveScreenDomain.y;\n    float fCurveScreenProjection = sqrt( fCurveScreenProjection2 ) - fScreenCurveRadius;\n    vScreenClosest.z = vScreenDomain.z - clamp( vScreenDomain.z, -fCurveScreenProjection, fDepth );\n    resultScreen.vUVW.z = vScreenDomain.z + fCurveScreenProjection;        \n    resultScreen.fDist = (length( vScreenClosest ) - fBevel) * 0.95;\n    //resultScreen.fDist = (length( vScreenDomain - vec3(0,0,fScreenCurveRadius)) - fScreenCurveRadius - fBevel);    \n#endif    \n    \n#if 0\n    vec3 vScreenClosest;\n    vScreenClosest.xyz = max(abs(vScreenDomain.xyz)-vec3(vScreenWH, fDepth),0.0);\n    float fRoundDist = length( vScreenClosest.xyz ) - fBevel;\n    float fSphereDist = length( vScreenDomain - vec3(0,0,fScreenCurveRadius) ) - (fScreenCurveRadius + fBevel);    \n    resultScreen.fDist = max(fRoundDist, fSphereDist);\n#endif    \n    \n    resultScreen.vUVW.xy = (vScreenDomain.xy / vScreenWH) * 0.5 + 0.5f;\n\tresultScreen.iObjectId = MAT_SCREEN;\n    return resultScreen;\n}\n\nSceneResult Scene_GetComputer( vec3 vPos )\n{\n    SceneResult resultComputer;\n    resultComputer.vUVW = vPos.xzy;\n\t\n    float fXSectionStart = -0.2;\n    float fXSectionLength = 0.15;\n    float fXSectionT = clamp( (vPos.z - fXSectionStart) / fXSectionLength, 0.0, 1.0);\n    float fXSectionR1 = 0.03;\n    float fXSectionR2 = 0.05;\n    float fXSectionR = mix( fXSectionR1, fXSectionR2, fXSectionT );\n    float fXSectionZ = fXSectionStart + fXSectionT * fXSectionLength;\n    \n    vec2 vXSectionCentre = vec2(fXSectionR, fXSectionZ );\n    vec2 vToPos = vPos.yz - vXSectionCentre;\n    float l = length( vToPos );\n    if ( l > fXSectionR ) l = fXSectionR;\n    vec2 vXSectionClosest = vXSectionCentre + normalize(vToPos) * l;\n    //float fXSectionDist = length( vXSectionClosest ) - fXSectionR;\n    \n    float x = max( abs( vPos.x ) - 0.2f, 0.0 );\n\n    resultComputer.fDist = length( vec3(x, vXSectionClosest - vPos.yz) )-0.01;\n    //resultComputer.fDist = x;\n        \n    resultComputer.iObjectId = MAT_TV_CASING;\n/*\n    vec3 vKeyPos = vPos.xyz - vec3(0,0.125,0);\n    vKeyPos.y -= vKeyPos.z * (fXSectionR2 - fXSectionR1) * 2.0 / fXSectionLength;\n    float fDomainRepeatScale = 0.02;\n    if ( fract(vKeyPos.z * 0.5 / fDomainRepeatScale + 0.25) > 0.5) vKeyPos.x += fDomainRepeatScale * 0.5;\n    vec2 vKeyIndex = round(vKeyPos.xz / fDomainRepeatScale);\n    vKeyIndex.x = clamp( vKeyIndex.x, -8.0, 8.0 );\n    vKeyIndex.y = clamp( vKeyIndex.y, -10.0, -5.0 );\n    //vKeyPos.xz = (fract( vKeyPos.xz / fDomainRepeatScale ) - 0.5) * fDomainRepeatScale;\n    vKeyPos.xz = (vKeyPos.xz - (vKeyIndex) * fDomainRepeatScale);\n    vKeyPos.xz /= 0.7 + vKeyPos.y;\n    SceneResult resultKey;    \n    resultKey.vUVW = vPos.xzy;\n    resultKey.fDist = UdRoundBox( vKeyPos, vec3(0.01), 0.001 );\n    resultKey.iObjectId = MAT_TV_TRIM;\n    Scene_Union( resultComputer, resultKey );\n*/    \n    return resultComputer;\n}\n\nSceneResult Scene_GetDistance( vec3 vPos )\n{\n    SceneResult result;\n    \n\t//result.fDist = vPos.y;\n    float fBenchBevel = 0.01;\n    result.fDist = UdRoundBox( vPos - vec3(0,-0.02-fBenchBevel,0.0), vec3(2.0, 0.02, 1.0), fBenchBevel );\n    result.vUVW = vPos;\n\tresult.iObjectId = MAT_DEFAULT;        \n    \n    vec3 vSetPos = vec3(0.0, 0.0, 0.0);\n    vec3 vScreenPos = vSetPos + vec3(0.0, 0.25, 0.00);\n    \n    //vPos.x = fract( vPos.x - 0.5) - 0.5;\n    \n    vec2 vScreenWH = vec2(4.0, 3.0) / 25.0;\n\n    SceneResult resultSet;\n    resultSet.vUVW = vPos.xzy;\n\tresultSet.fDist = UdRoundBox( vPos - vScreenPos - vec3(0.0,-0.01,0.2), vec3(.21, 0.175, 0.18), 0.01 );\n    resultSet.iObjectId = MAT_TV_CASING;\n    Scene_Union( result, resultSet );\n\n    SceneResult resultSetRecess;\n    resultSetRecess.vUVW = vPos.xzy;\n    resultSetRecess.fDist = UdRoundBox( vPos - vScreenPos - vec3(0.0,-0.0, -0.05), vec3(vScreenWH + 0.01, 0.05) + 0.005, 0.015 );\n    resultSetRecess.iObjectId = MAT_TV_TRIM;\n\tScene_Subtract( result, resultSetRecess );\n    \n    SceneResult resultSetBase;\n    resultSetBase.vUVW = vPos.xzy;\n    float fBaseBevel = 0.03;\n\tresultSetBase.fDist = UdRoundBox( vPos - vSetPos - vec3(0.0,0.04,0.22), vec3(0.2, 0.04, 0.17) - fBaseBevel, fBaseBevel );\n    resultSetBase.iObjectId = MAT_TV_CASING;\n    Scene_Union( result, resultSetBase );\n\n\tSceneResult resultScreen = Scene_GetCRT( vPos - vScreenPos, vScreenWH, 0.75f, 0.02f, 0.1f );\n    Scene_Union( result, resultScreen );    \n    \n    //SceneResult resultComputer = Scene_GetComputer( vPos - vec3(0.0, 0.0, -0.1) );\n    //Scene_Union( result, resultComputer );\n\n    SceneResult resultSphere;\n    resultSet.vUVW = vPos.xzy;\n\tresultSet.fDist = length(vPos - vec3(0.35,0.075,-0.1)) - 0.075;\n    resultSet.iObjectId = MAT_CHROME;\n    Scene_Union( result, resultSet );    \n    \n    return result;\n}\n\n\n\n// Scene Lighting\n\nvec3 g_vSunDir = normalize(vec3(0.3, 0.4, -0.5));\nvec3 g_vSunColor = vec3(1, 0.95, 0.8) * 3.0;\nvec3 g_vAmbientColor = vec3(0.8, 0.8, 0.8) * 1.0;\n\nSurfaceLighting Scene_GetSurfaceLighting( const in vec3 vViewDir, in SurfaceInfo surfaceInfo )\n{\n    SurfaceLighting surfaceLighting;\n    \n    surfaceLighting.vDiffuse = vec3(0.0);\n    surfaceLighting.vSpecular = vec3(0.0);    \n    \n    Light_AddDirectional( surfaceLighting, surfaceInfo, vViewDir, g_vSunDir, g_vSunColor );\n    \n    Light_AddPoint( surfaceLighting, surfaceInfo, vViewDir, vec3(1.4, 2.0, 0.8), vec3(1,1,1) * 0.2 );\n    \n    float fAO = Scene_GetAmbientOcclusion( surfaceInfo.vPos, surfaceInfo.vNormal );\n    // AO\n    surfaceLighting.vDiffuse += fAO * (surfaceInfo.vBumpNormal.y * 0.5 + 0.5) * g_vAmbientColor;\n    \n    return surfaceLighting;\n}\n\n// Environment\n\nvec4 Env_GetSkyColor( const vec3 vViewPos, const vec3 vViewDir )\n{\n\tvec4 vResult = vec4( 0.0, 0.0, 0.0, kFarDist );\n\n#if 0\n    vec3 vEnvMap = textureLod( iChannel1, vViewDir.zyx, 0.0 ).rgb;\n    vResult.rgb = vEnvMap;\n#endif    \n    \n#if 0\n    vec3 vEnvMap = textureLod( iChannel1, vViewDir.zyx, 0.0 ).rgb;\n    vEnvMap = vEnvMap * vEnvMap;\n    float kEnvmapExposure = 0.999;\n    vResult.rgb = -log2(1.0 - vEnvMap * kEnvmapExposure);\n\n#endif\n    \n    vResult.rgb = mix( vec3(0.3,0.8,0.9),vec3(0.3,0.4,0.9), vViewDir.y );\n    \n    // Sun\n    float NdotV = dot( g_vSunDir, vViewDir );\n    vResult.rgb += smoothstep( cos(radians(.7)), cos(radians(.5)), NdotV ) * g_vSunColor * 100.0;\n\n    return vResult;\t\n}\n\nfloat Env_GetFogFactor(const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist )\n{    \n\tfloat kFogDensity = 0.00001;\n\treturn exp(fDist * -kFogDensity);\t\n}\n\nvec3 Env_GetFogColor(const in vec3 vDir)\n{    \n\treturn vec3(0.2, 0.5, 0.6) * 2.0;\t\t\n}\n\nvec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist )\n{\n    //return vColor;\n    vec3 vResult = vColor;\n    \n    \n\tfloat fFogFactor = Env_GetFogFactor( vRayOrigin, vRayDir, fDist );\n\tvec3 vFogColor = Env_GetFogColor( vRayDir );\t\n\t//Env_AddDirectionalLightFlareToFog( vFogColor, vRayDir, g_vSunDir, g_vSunColor * 3.0);    \n    vResult = mix( vFogColor, vResult, fFogFactor );\n\n    return vResult;\t    \n}\n\n\nvec3 FX_Apply( in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist)\n{    \n    return vColor;\n}\n\n\nvec4 MainCommon( vec3 vRayOrigin, vec3 vRayDir )\n{\n\tvec4 vColorLinAndDepth = Scene_GetColorAndDepth( vRayOrigin, vRayDir );    \n    vColorLinAndDepth.rgb = max( vColorLinAndDepth.rgb, vec3(0.0) );\n    \n    vec4 vFragColor = vColorLinAndDepth;\n    \n    float fExposure = 2.0f;\n    \n    vFragColor.rgb *= fExposure;\n    \n    vFragColor.a = vColorLinAndDepth.w;\n    \n    return vFragColor;\n}\n\n///////////////////////////\n// Camera\n///////////////////////////\n\nstruct CameraState\n{\n    vec3 vPos;\n    vec3 vTarget;\n    float fFov;\n    vec2 vJitter;\n    float fPlaneInFocus;\n};\n\nmat3 Cam_GetWorldToCameraRotMatrix( const CameraState cameraState )\n{\n    vec3 vForward = normalize( cameraState.vTarget - cameraState.vPos );\n\tvec3 vRight = normalize( cross(vec3(0, 1, 0), vForward) );\n\tvec3 vUp = normalize( cross(vForward, vRight) );\n    \n    return mat3( vRight, vUp, vForward );\n}\n\nvec2 Cam_GetViewCoordFromUV( vec2 vUV, vec2 res )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= res.x / res.y;\n\n\treturn vWindow;\t\n}\n\nvoid Cam_GetCameraRay( vec2 vUV, vec2 res, CameraState cam, out vec3 vRayOrigin, out vec3 vRayDir )\n{\n    vec2 vView = Cam_GetViewCoordFromUV( vUV, res );\n    vRayOrigin = cam.vPos;\n    float fPerspDist = 1.0 / tan( radians( cam.fFov ) );\n    vRayDir = normalize( Cam_GetWorldToCameraRotMatrix( cam ) * vec3( vView, fPerspDist ) );\n}\n\nvec2 Cam_GetUVFromWindowCoord( vec2 vWindow, vec2 res )\n{\n    vec2 vScaledWindow = vWindow;\n    vScaledWindow.x *= res.y / res.x;\n\n    return (vScaledWindow * 0.5 + 0.5);\n}\n\nvec2 Cam_WorldToWindowCoord(const in vec3 vWorldPos, const in CameraState cameraState )\n{\n    vec3 vOffset = vWorldPos - cameraState.vPos;\n    vec3 vCameraLocal;\n\n    vCameraLocal = vOffset * Cam_GetWorldToCameraRotMatrix( cameraState );\n\t\n    vec2 vWindowPos = vCameraLocal.xy / (vCameraLocal.z * tan( radians( cameraState.fFov ) ));\n    \n    return vWindowPos;\n}\n\n\nCameraState GetCameraPosition( int index )\n{\n    CameraState cam;\n\n    vec3 vFocus = vec3(0,0.25,-0.012);   \n    \n    if ( index > 9 )\n    {\n    \tindex = int(hash11(float(index) / 10.234) * 100.0);\n    \tindex = index % 10;\n    }\n\n    #ifdef FIXED_CAMERA_INDEX\n    index=FIXED_CAMERA_INDEX; // Force a camera position\n    #endif\n    \n    if ( index == 0 )\n    {\n        cam.vPos = vec3(-0.1,0.24,-0.08);\n        cam.vTarget = vec3(0.15,0.25,0.1);\n        cam.fFov = 10.0;\n    }\n    if ( index == 1 )\n    {\n        cam.vPos = vec3(0.01,0.25,-0.8);\n        cam.vTarget = vec3(0,0.25,0.1);\n        cam.fFov = 10.0;\n    }\n    if ( index == 2 )\n    {\n        cam.vPos = vec3(-0.4,0.3,-1.0);\n        cam.vTarget = vec3(0.25,0.18,0.5);\n        cam.fFov = 10.0;\n    }\n    if ( index == 3 )\n    {\n        cam.vPos = vec3(-0.8,0.5,-1.5);\n        cam.vTarget = vec3(0.2,0.1,0.5);\n        cam.fFov = 8.0;\n    }\n    if ( index == 4 )\n    {\n        cam.vPos = vec3(0.5,0.3,-0.5);\n        cam.vTarget = vec3(-0.4,0.1,0.5);\n        cam.fFov = 16.0;\n    }\n    if ( index == 5 )\n    {\n        cam.vPos = vec3(-0.244,0.334,-0.0928);\n        cam.vTarget = vec3(0,0.25,0.1);\n        cam.fFov = 20.0;\n    }\n    if ( index == 6 )\n    {\n        cam.vPos = vec3(0.0,0.1,-0.5);\n        cam.vTarget = vec3(0.08,0.2,-0.1);\n        vFocus = cam.vTarget; \n        cam.fFov = 20.0;\n    }\n    if ( index == 7 )\n    {\n        cam.vPos = vec3(-0.01,0.01,-0.25);\n        cam.vTarget = vec3(0.01,0.27,0.1);\n        vFocus = cam.vTarget; \n        cam.fFov = 23.0;\n    }\n    if ( index == 8 )\n    {\n        cam.vPos = vec3(-0.23,0.3,-0.05);\n        cam.vTarget = vec3(0.1,0.2,0.1);\n        cam.fFov = 15.0;\n    }\n    if ( index == 9 )\n    {\n        cam.vPos = vec3(0.4,0.2,-0.2);\n        cam.vTarget = vec3(-0.1,0.25,0.1);\n        cam.fFov = 12.0;\n    }\n    \n    cam.fPlaneInFocus = length( vFocus - cam.vPos);\n    cam.vJitter = vec2(0.0);        \n    \n    return cam;\n}\n\n\nvec3 Tonemap( vec3 x )\n{\n#if 0 \n    \n    vec3 luminanceCoeffsBT709 = vec3( 0.2126f, 0.7152f, 0.0722f );\n    float f = dot( x, luminanceCoeffsBT709 );\n    x /= f;        \n    f = 1.0f - exp(-f);    \n    x *= f;    \n    x = mix( x, vec3(f), f*f );\n    \n    return x;\n#else       \n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n\n    return ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e );    \n#endif    \n}\n\n\nfloat GetVignetting( const in vec2 vUV, float fScale, float fPower, float fStrength )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0) * fScale;\n\t\n\tfloat fDist = max( 0.0, 1.0 - length( vOffset ) );\n    \n\tfloat fShade = 1.0 - pow( fDist, fPower );\n    \n    fShade = 1.0 - fShade * fStrength;\n\n\treturn fShade;\n}\n\n\nvoid mainImage( out vec4 vFragColor, in vec2 vFragCoord )\n{\n    vec2 vUV = vFragCoord.xy / iResolution.xy; \n\n    CameraState cam;\n    \n    {\n    \tCameraState camA;\n    \tCameraState camB;\n    \n        float fSeqTime = iTime;\n        float fSequenceSegLength = 5.0;\n        float fSeqIndex = floor(fSeqTime / fSequenceSegLength);\n        float fSeqPos = fract(fSeqTime / fSequenceSegLength);\n        int iIndex = int(fSeqIndex);\n\t\tint iIndexNext = int(fSeqIndex) + 1;\n        camA = GetCameraPosition(iIndex);\n        camB = GetCameraPosition(iIndexNext);\n        \n        float t = smoothstep(0.3, 1.0, fSeqPos);\n        cam.vPos = mix(camA.vPos, camB.vPos, t );\n        cam.vTarget = mix(camA.vTarget, camB.vTarget, t );\n        cam.fFov = mix(camA.fFov, camB.fFov, t );\n        cam.fPlaneInFocus = mix(camA.fPlaneInFocus, camB.fPlaneInFocus, t );\n    }\n    \n#if USE_MOUSE    \n    if ( iMouse.z > 0.0 )\n    {\n        float fDist = 0.01 + 3.0 * (iMouse.y / iResolution.y);\n\n        float fAngle = (iMouse.x / iResolution.x) * radians(360.0);\n    \t//float fElevation = (iMouse.y / iResolution.y) * radians(90.0);\n    \tfloat fElevation = 0.15f * radians(90.0);    \n\n        cam.vPos = vec3(sin(fAngle) * fDist * cos(fElevation),sin(fElevation) * fDist,cos(fAngle) * fDist * cos(fElevation));\n        cam.vTarget = vec3(0,0.25,0.1);\n        cam.vPos +=cam.vTarget;\n        cam.fFov = 20.0 / (1.0 + fDist * 0.5);\n    \tvec3 vFocus = vec3(0,0.25,-0.012);\t    \n\t    cam.fPlaneInFocus = length( vFocus - cam.vPos );\n    }\n#endif    \n    \n#if 0\n    {\n        float fDist = 0.5;\n\n        float fAngle = 0.6 * PI * 2.0f;\n        float fElevation = 0.2;\n        \n        cam.vPos = vec3(sin(fAngle) * fDist * cos(fElevation),sin(fElevation) * fDist,cos(fAngle) * fDist * cos(fElevation));\n        cam.vTarget = vec3(0.05,0.25,0.1);\n        cam.vPos +=cam.vTarget;\n        cam.fFov = 22.0;\n    \tvec3 vFocus = vec3(0,0.25,-0.012);\t    \n\t    cam.fPlaneInFocus = length( vFocus - cam.vPos );\n    }\n#endif\n    \n#ifdef ENABLE_TAA_JITTER\n    cam.vJitter = hash21( fract( iTime ) ) - 0.5f;\n#endif\n    \n            \n    vec3 vRayOrigin, vRayDir;\n    vec2 vJitterUV = vUV + cam.vJitter / iResolution.xy;\n    Cam_GetCameraRay( vJitterUV, iResolution.xy, cam, vRayOrigin, vRayDir );\n \n    float fHitDist = 0.0f;\n    vFragColor = MainCommon( vRayOrigin, vRayDir );\n    \n    float fShade = GetVignetting( vUV, 0.7, 2.0, 1.0 );\n    \n    vFragColor.rgb *= fShade;\n    \n    vFragColor.rgb = Tonemap( vFragColor.rgb );        \n}\n", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NljGR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[909, 1019, 1042, 1042, 1160], [1162, 1181, 1203, 1203, 1317], [1319, 1339, 1361, 1361, 1465], [1467, 1486, 1509, 1509, 1617], [1840, 1840, 1899, 1899, 1957], [1964, 1964, 2026, 2026, 2158], [5042, 5042, 5082, 5082, 5132], [6891, 6891, 6966, 6966, 7106], [8299, 8299, 8361, 8361, 10285], [10634, 10634, 10684, 10952, 11015], [11017, 11017, 11069, 11337, 11392], [11394, 11394, 11430, 11430, 12235], [12237, 12237, 12270, 12270, 12552], [12554, 12554, 12594, 12594, 12702], [12705, 12705, 12736, 12736, 12963], [13082, 13082, 13115, 13115, 13272], [13275, 13275, 13319, 13319, 13495], [13498, 13498, 13534, 13534, 13794], [13800, 13800, 13842, 13842, 14066], [14072, 14072, 14104, 14104, 15473], [15475, 15475, 15500, 15500, 15566], [17199, 17199, 17245, 17291, 17380], [17382, 17382, 17427, 17548, 17590], [17592, 17592, 17710, 17710, 19098], [19100, 19100, 19144, 19144, 20983], [20985, 20985, 21029, 21029, 22832], [23681, 23681, 23747, 23747, 24383], [25247, 25247, 25297, 25297, 25635], [25821, 25821, 25890, 25890, 26122], [26124, 26124, 26175, 26175, 26258], [26260, 26260, 26361, 26361, 26593], [26595, 26595, 26652, 26652, 26767], [27136, 27136, 27180, 27180, 29067], [29070, 29070, 29094, 29094, 29532], [29841, 29841, 29900, 29900, 32338]], "test": "untested"}
{"id": "stXSDs", "name": "Suborbital Flight", "author": "dr2", "description": "High flyer (guess who's not inside) with alternating inverted flight (mouseable - click in lower-right corner to override inversion)", "tags": ["space", "rocket", "aircraft"], "likes": 10, "viewed": 337, "published": 3, "date": "1626805528", "time_retrieved": "2024-07-30T19:10:06.834273", "image_code": "// \"Suborbital Flight\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  1   // (= 0/1) optional antialiasing\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrConCylDf (vec3 p, vec2 cs, float r, float h);\nfloat PrAnConCylDf (vec3 p, vec2 cs, float r, float w, float h);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat BumpFbm3 (vec3 p);\nfloat Hashfv3 (vec3 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit;\nvec2 rollCs;\nfloat tCur, dstFar, szFac, flRad, flLen;\nint idObj;\nbool invFly;\nconst int idFus = 1, idWng = 2, idEng = 3;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, w, s, dy;\n  dMin = dstFar / szFac;\n  p /= szFac;\n  p.xy = Rot2Cs (p.xy, rollCs);\n  q = p;\n  w = 1.2;\n  dy = 0.;\n  if (q.z < -1.5) {\n    s = (q.z + 1.5) * (q.z + 1.5);\n    w *= 1. - 0.025 * s;\n  } else if (q.z > 2.) {\n    s = (q.z - 2.) * (q.z - 2.);\n    w *= 1. - 0.025 * s;\n    dy = -0.01 * s;\n  }\n  d = max (PrCapsDf (q - vec3 (0., dy, 0.), w, 7.5), - q.z - 6.);\n  DMINQ (idFus);\n  q = p;\n  q.x = abs (q.x);\n  q.yz -= vec2 (1.7, -4.2);\n  d = max (max (- q.z - 1.6, dot (vec2 (q.y, dot (q.xz, sin (0.15 * pi + vec2 (0., 0.5 * pi)))),\n     sin (0.1 * pi + vec2 (0., 0.5 * pi))) - 1.6), q.y - 0.6);\n  d = max (d, - min (abs (PrBox2Df (q.xz - vec2 (2.6, -1.5), vec2 (1., 0.2))),\n     abs (PrBox2Df (q.yz - vec2 (-0.2, -1.5), vec2 (0.5, 0.2)))));\n  d = SmoothMax (d, abs (PrRoundBox2Df (q.xy, vec2 (4., 1.), 0.7)) - 0.04, 0.05);\n  DMINQ (idWng);\n  q = p;\n  q.z += 6.05;\n  d = PrCylDf (q, 0.4, 0.15);\n  q.z += 0.5;\n  d = min (d, PrAnConCylDf (q, sin (0.07 * pi + vec2 (0.5 * pi, 0.)), 0.45, 0.03, 0.35));\n  DMINQ (idEng);\n  return 0.5 * szFac * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 240; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec2 CapsHit (vec3 ro, vec3 rd, float cRad, float cLen)\n{\n  float dIn, dOut, d, a, b, bs, w, s, ws, roz;\n  dIn = dstFar;\n  dOut = dstFar;\n  a = dot (rd.xy, rd.xy);\n  b = dot (rd.xy, ro.xy);\n  w = b * b - a * (dot (ro.xy, ro.xy) - cRad * cRad);\n  if (w > 0. && a > 0.) {\n    ws = sqrt (w);\n    d = - (b + ws) / a;\n    s = ro.z + d * rd.z;\n    if (d > 0. && abs (s) < cLen) dIn = d;\n    else {\n      roz = ro.z;\n      ro.z -= cLen * sign (s);\n      bs = dot (rd, ro);\n      w = bs * bs - (dot (ro, ro) - cRad * cRad);\n      if (w > 0.) {\n        d = - bs - sqrt (w);\n        if (d > 0.) dIn = d;\n      }\n      ro.z = roz;\n    }\n  }\n  if (dIn < dstFar) {\n    d = (- b + ws) / a;\n    s = ro.z + d * rd.z;\n    if (abs (s) < cLen) dOut = d;\n    else {\n      ro.z -= cLen * sign (s);\n      bs = dot (rd, ro);\n      w = bs * bs - (dot (ro, ro) - cRad * cRad);\n      if (w > 0.) dOut = - bs + sqrt (w);\n    }\n  }\n  return vec2 (dIn, dOut);\n}\n\nfloat FlmDens (vec3 p)\n{ // (from \"Flaming Asteroids\")\n  float c;\n  c = max (0., 1.3 * BumpFbm3 (0.2 * vec3 (p.xy / flRad, 0.5 * p.z + 16. * tCur)) - 0.2 +\n     0.4 * smoothstep (-0.5 * flRad, 0.1 * flRad, p.z));\n  return c * (1. - smoothstep (-0.3 * flRad, 0., length (vec3 (p.xy,\n     p.z - clamp (p.z, - 2. * flLen, 0.))) - flRad * (1. + 0.8 * p.z / (2. * flLen)))) *\n     smoothstep (0., flRad, p.z + 2. * flLen);\n}\n\nvec4 FlmCol (vec3 ro, vec3 rd, vec2 dCyl2, float dstObj)\n{\n  vec4 col4;\n  vec3 q, c;\n  float s, ds, f, fn, r;\n  const float sMax = 50.;\n  ds = min (2. * flRad, dCyl2.y - dCyl2.x) / sMax;\n  s = dCyl2.x;\n  ro.z -= flLen;\n  q = ro + s * rd;\n  r = length (q.xy) / flRad;\n  q.xy = Rot2D (q.xy, 0.8 * r * (2. * smoothstep (0.4, 0.8, r) - 1.) * q.z);\n  fn = FlmDens (q);\n  col4 = vec4 (0.);\n  for (float j = float (VAR_ZERO); j < sMax; j ++) {\n    f = fn;\n    s += ds;\n    q = ro + (s + ds * Hashfv3 (16. * rd)) * rd;\n    r = length (q.xy) / flRad;\n    q.xy = Rot2D (q.xy, 0.8 * r * (2. * smoothstep (0.4, 0.8, r) - 1.) * q.z);\n    fn = FlmDens (q);\n    c = mix (mix (vec3 (1., 0.3, 0.1), vec3 (1., 1., 0.2), clamp ((0.3 / ds) * (f - fn), 0., 1.)),\n       vec3 (0.9, 0.8, 0.3), smoothstep (-0.5 * flRad, 0.2 * flRad, q.z)) *\n       (1. - smoothstep (-0.1, 0.1, s - dstObj));\n    col4 = col4 + (1. - col4.a) * vec4 (c, 1.) * f / sMax;\n    if (s > dstObj || col4.a > 1.) break;\n  }\n  return clamp (col4, 0., 1.);\n}\n\nvec4 SphHit (vec3 ro, vec3 rd, float rad)\n{\n  vec3 vn;\n  float b, d, w;\n  b = dot (rd, ro);\n  w = b * b + rad * rad - dot (ro, ro);\n  d = dstFar;\n  if (w > 0.) {\n    d = - b - sqrt (w);\n    vn = (ro + d * rd) / rad;\n  }\n  return vec4 (d, vn);\n}\n\nvec3 StarPat (vec3 rd, float scl) \n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 8. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, dSph4, c;\n  vec3 col, vn, vnh, roo, rdo, q, stCol;\n  vec2 dCyl2;\n  float dstObj, dstGrnd, dstCld, s, spRad, h, clDens;\n  bool doRefl;\n  szFac = 0.5;\n  roo = ro;\n  rdo = rd;\n  doRefl = false;\n  dstGrnd = dstFar;\n  col = vec3 (0.);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = vec4 (0.84, 0.84, 0.85, 0.3);\n    if (idObj == idFus) {\n      q = qHit;\n      q.z -= 1.;\n      s = 0.;\n      if (abs (q.z) < 3.6) {\n        q *= 0.6;\n        q.z = fract (q.z) - 0.5;\n        s = max (step (length (q.yz + vec2 (-0.2, 0.)), 0.22), step (0., q.y) *\n           step (length (q.xz), 0.22));\n      }\n      s = max (s, step (SmoothMax (PrRoundBox2Df (vec2 (abs (qHit.x) - 0.55, qHit.z) - vec2 (0., 5.6),\n         vec2 (0.3, 0.6), 0.1), - qHit.y + 0.2, 0.1), 0.));\n      if (s > 0.) {\n        doRefl = true;\n        col4 = vec4 (0.);\n      }\n      if (qHit.z < -5.9) col4 *= 0.5 + 0.5 * smoothstep (0.4, 0.45,\n         mod (16. * (atan (qHit.y, qHit.x) / (2. * pi) + 0.5), 1.));\n      if (qHit.y < 0.) {\n        col4 *= 0.7 + 0.3 * smoothstep (0., 0.02,\n           min (abs (PrBox2Df (vec2 (abs (qHit.x), qHit.z) - vec2 (0.35, -0.5), vec2 (0.35, 1.5))),\n           abs (PrBox2Df (vec2 (abs (qHit.x), qHit.z) - vec2 (0.15, 4.5), vec2 (0.15, 0.4)))) - 0.01);\n      }\n      col4.rgb = mix (col4.rgb, vec3 (0.3, 0.8, 0.8), smoothstep (0., 0.02, qHit.z - 7.5));\n    } else if (idObj == idWng) {\n      col4.rgb = mix (vec3 (0.3, 0.8, 0.8), col4.rgb, smoothstep (0., 0.02,\n         abs (length (qHit.xz - vec2 (2.5, -0.2)) - 0.5) - 0.1));\n    } else if (idObj == idEng) {\n      col4 = (PrConCylDf (qHit, sin (0.07 * pi + vec2 (0.5 * pi, 0.)), 0.45, 0.35) > 0.) ?\n         vec4 (0.7, 0.3, 0.3, 0.) * (0.8 + 0.2 * sin (16. * pi * qHit.z)) : vec4 (1., 0., 0., -1.);\n    }\n    col = col4.rgb;\n    if (col4.a >= 0.) col = col * (0.2 + 0.8 * max (dot (vn, sunDir), 0.)) +\n       col4.a * vec3 (1., 1., 0.9) * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 64.);\n    else col *= 0.5 + 0.5 * max (- dot (rd, vn), 0.);\n  }\n  if (doRefl) {\n    rd = reflect (rd, vn);\n    col = vec3 (0.);\n    dstObj = dstFar;\n  }\n  if (dstObj >= dstFar) {\n    ro = roo;\n    spRad = 200.;\n    dSph4 = SphHit (ro - vec3 (0., - spRad - 5., 0.), rd, spRad);\n    dstGrnd = dSph4.x;\n    if (dstGrnd < dstFar && dstGrnd > 0.) {\n      ro += dstGrnd * rd;\n      vnh = dSph4.yzw;\n      ro.xz += vec2 (0., 0.5 * tCur);\n      h = Fbm2 (vec2 (0.23, 0.2) * ro.xz);\n      vn = VaryNf ((4. - 2. * step (0.45, h)) * ro, vnh, (0.1 + 2.9 * max (h - 0.45, 0.)) *\n         smoothstep (0.03, 0.1, - dot (vnh, rd)));\n      s = Noisefv2 (32. * ro.xz);\n      col4 = vec4 (0., 0.2, 1., 0.3) * (1. - 0.2 * s);\n      col4 = mix (col4, vec4 (0.8, 0.5, 0.2, 0.1) * (1. - 0.1 * s), step (0.45, h));\n      col4 = mix (col4, vec4 (0.4, 0.8, 0.4, 0.1) * (1. - 0.1 * s), smoothstep (0.46, 0.54, h));\n      col4 = mix (col4, vec4 (0.5, 0.7, 0.5, 0.1) * (1. - 0.2 * s), smoothstep (0.6, 0.7, h));\n      col4 = mix (col4, vec4 (1., 1., 1., 0.3) * (1. - 0.2 * s), smoothstep (0.75, 0.8, h));\n      col4.rgb = mix (col4.rgb, vec3 (1., 1., 0.8), 0.2);\n      col4 = mix (vec4 (0.6, 0.6, 0.9, 0.), col4, smoothstep (0.03, 0.1, - dot (vnh, rd)));\n      col4 = mix (vec4 (0.05, 0.05, 0.05, 0.), col4, smoothstep (0., 0.03, - dot (vnh, rd)));\n      col = col4.rgb * (0.2 + 0.8 * max (dot (vn, sunDir), 0.)) +\n         col4.a * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 8.);\n      ro.xz += 0.1 * atan (sunDir.xz, sunDir.yy);\n      clDens = clamp (1.6 * Fbm2 (vec2 (0.4, 0.7) * ro.xz) - 0.4, 0., 1.);\n      col *= 1. - 0.3 * clDens;\n    }\n    ro = roo;\n    spRad = 250.;\n    dSph4 = SphHit (ro - vec3 (0., - spRad - 5., 0.), rd, spRad);\n    dstCld = dSph4.x;\n    if (dstCld < dstFar && dstCld > 0.) {\n      ro += dstCld * rd;\n      vnh = dSph4.yzw;\n      ro.xz += vec2 (0., 0.5 * tCur);\n      clDens = clamp (1.6 * Fbm2 (vec2 (0.4, 0.7) * ro.xz) - 0.4, 0., 1.);\n      col = mix (col, vec3 (1.) * (0.2 + 0.8 * max (dot (vnh, sunDir), 0.)), clDens *\n         smoothstep (0.11, 0.14, - dot (vnh, rd)));\n    }\n  }\n  ro = roo;\n  rd = rdo;\n  if (! doRefl) {\n    flRad = 0.4;\n    flLen = 20.;\n    ro.z += flLen + 7.4 * szFac;\n    dCyl2 = CapsHit (ro, rd, flRad, flLen);\n    if (dCyl2.x < min (min (dstObj, dstGrnd), dstFar)) {\n      c = FlmCol (ro, rd, dCyl2, dstObj);\n      col = mix (col, 3. * c.rgb, clamp (8. * c.a * c.a, 0., 1.));\n    }\n  }\n  stCol = StarPat (rd, 16.);\n  if (length (col) < 0.03) col = mix (col, stCol, step (Maxv3 (col), 0.4 * Maxv3 (stCol)));\n  if (doRefl && length (col) < 0.03) col += vec3 (0.15, 0.1, 0.);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  invFly = (mod (0.025 * tCur, 1.) > 0.5);\n  if (mPtr.z > 0. && mPtr.x > 0.4 && mPtr.y < -0.4) invFly = ! invFly;\n  rollCs = sin (0.1 * pi * sin (0.1 * pi * tCur) + (invFly ? pi : 0.) + vec2 (0.5 * pi, 0.));\n  if (invFly) uv *= -1.;\n  az = pi;\n  el = -0.1 * pi;\n  if (mPtr.z > 0. && ! (mPtr.x > 0.4 && mPtr.y < -0.4)) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.9 * pi * sin (0.01 * pi * tCur);\n    el -= 0.05 * pi * sin (0.012 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, 0.01 * pi);\n  az = clamp (az, 0.1 * pi, 1.9 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -15.);\n  zmFac = 4.;\n  dstFar = 300.;\n  sunDir = normalize (vec3 (1., 1., -1.));\n  if (invFly) sunDir.xz *= -1.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrConCylDf (vec3 p, vec2 cs, float r, float h)\n{\n  return max (dot (vec2 (length (p.xy) - r, p.z), cs), abs (p.z) - h);\n}\n\nfloat PrAnConCylDf (vec3 p, vec2 cs, float r, float w, float h)\n{\n  return max (abs (dot (vec2 (length (p.xy) - r, p.z), cs)) - w, abs (p.z) - h);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat PerBumpf (float p)\n{\n  return 0.5 * smoothstep (0., 0.5, abs (fract (p) - 0.5));\n}\n\nvec3 PerBumpv3 (vec3 p)\n{\n  return 0.5 * smoothstep (0., 0.5, abs (fract (p) - 0.5));\n}\n\nfloat BumpFbm3 (vec3 p)\n{\n  vec3 q;\n  float a, f;\n  a = 1.;\n  f = 0.;\n  q = p;\n  for (int j = 0; j < 4; j ++) {\n    p += PerBumpv3 (q + PerBumpv3 (q).yzx);\n    p *= 1.5;\n    f += a * (PerBumpf (p.z + PerBumpf (p.x + PerBumpf (p.y))));\n    q = 2. * q + 1.;\n    a *= 0.75;\n  }\n  return f;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stXSDs.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1077, 1077, 1099, 1099, 2175], [2177, 2177, 2210, 2210, 2393], [2395, 2395, 2416, 2416, 2671], [2673, 2673, 2730, 2730, 3605], [3607, 3607, 3631, 3661, 4026], [4028, 4028, 4086, 4086, 5033], [5035, 5035, 5078, 5078, 5279], [5281, 5281, 5317, 5317, 5770], [5772, 5772, 5807, 5807, 10448], [10450, 10450, 10506, 10506, 11943], [11945, 11945, 11978, 11978, 12067], [12069, 12069, 12116, 12116, 12163], [12165, 12165, 12207, 12207, 12258], [12260, 12260, 12303, 12303, 12367], [12369, 12369, 12423, 12423, 12496], [12498, 12498, 12563, 12563, 12646], [12648, 12648, 12670, 12670, 12708], [12710, 12710, 12755, 12755, 12847], [12849, 12849, 12894, 12894, 12932], [12934, 12934, 12964, 12964, 13077], [13079, 13079, 13110, 13110, 13174], [13176, 13176, 13212, 13212, 13418], [13420, 13420, 13446, 13446, 13508], [13510, 13510, 13535, 13535, 13597], [13599, 13599, 13624, 13624, 13887], [13921, 13921, 13945, 13945, 14010], [14012, 14012, 14036, 14036, 14148], [14150, 14150, 14175, 14175, 14361], [14363, 14363, 14384, 14384, 14539], [14541, 14541, 14570, 14570, 14782], [14784, 14784, 14823, 14823, 15075]], "test": "untested"}
{"id": "7lfXWl", "name": "Tribute to FMS_Cat", "author": "xenn", "description": "There is just something I really dig about the way this all moves. Tweaked to get most of the bits I like. I would love to get it to look like this does at this point:\nhttps://youtu.be/BpP9r84VqOk", "tags": ["3d", "livecoding"], "likes": 4, "viewed": 411, "published": 3, "date": "1626785749", "time_retrieved": "2024-07-30T19:10:07.709932", "image_code": "// Fork of \"Tribute to FMS_Cat\" by xenn. https://shadertoy.com/view/NlfSDl\n// 2021-07-20 12:54:20\n\n// Fork of \"FMS_Cat @ Shader Royale #1\" by FMS_Cat. https://shadertoy.com/view/wsccWj\n// 2021-07-20 11:24:45\n\n// FMS_Cat!!\n// Since it's written in the shader royale compo,\n// the code is a total mess that is not intended to be read.\n// I heard the compo machine is not a beast enough\n// so I made this less intensive a bit.\n// There are several artifacts that is difficult to ignore :(\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 bloom = texture(iChannel0,  uv);\n    vec4 base = texture(iChannel1,  uv); \n    \n    fragColor = sqrt(bloom) * base; \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Fork of \"FMS_Cat @ Shader Royale #1\" by FMS_Cat. https://shadertoy.com/view/wsccWj\n// 2021-07-20 03:21:18\n\n// FMS_Cat!!\n// Since it's written in the shader royale compo,\n// the code is a total mess that is not intended to be read.\n// I heard the compo machine is not a beast enough\n// so I made this less intensive a bit.\n// There are several artifacts that is difficult to ignore :(\n\n\n#define BEAT (time*138.0/60.0)\n#define PI 3.14159265\n#define time iTime * 0.75\n#define lofi(x,d) (floor((x)/(d))*(d))\n#define saturate(a) (clamp((a),0.025,1.))\n#define linearstep(a,b,t) (saturate(((t)-(a))/((b)-(a))))\n\nfloat seed;\n\nfloat fractsin(float v)\n{\n  return fract(sin(v*121.445)*34.59);\n}\n\nfloat rand()\n{\n  seed=fractsin(seed);\n  return seed;\n}\n\nvec3 randsphere()\n{\n  float t=PI*2.*rand();\n  float p=acos(rand()*2.-1.);\n  return vec3(sin(p)*sin(t),cos(p),sin(p)*cos(t));\n}\n\nfloat easeceil(float t, float fac)\n{\n  return floor(t)+.5+.5*cos(PI*exp(fac*fract(t)));\n}\n\nmat2 rot2d(float t)\n{\n  return mat2(cos(t),-sin(t),sin(t),cos(t));\n}\n\nvec3 ifs(vec3 p,vec3 rot,vec3 shift)\n{\n  vec3 pt=abs(p);\n  vec3 t=shift;\n  for(int i=0;i<6;i++)\n  {\n    pt=abs(pt)-abs(lofi(t*pow(1.8,-float(i)),1.0/512.0));\n    t.yz=rot2d(rot.x)*t.yz;\n    t.zx=rot2d(rot.y)*t.zx;\n    t.xy=rot2d(rot.z)*t.xy;\n    pt.xy=pt.x<pt.y?pt.yx:pt.xy;\n    pt.yz=pt.y<pt.z?pt.zy:pt.yz;\n  }\n  return pt;\n}\n\nfloat sdbox(vec3 p,vec3 s)\n{\n  vec3 d=abs(p)-s;\n  return length(max(d,0.));\n}\n\n// ======= map!!!!!!!!!! ====================================\nvec4 map(vec3 p)\n{\n  vec3 pt=p;\n  vec3 haha=lofi(pt,5.0);\n  float scrphase=mod(999.9*fractsin(haha.y+haha.z+3.88),PI*2.0);\n  float scr=(mod(haha.y+haha.z,2.0)*2.0-1.0)*20.0*smoothstep(-0.5,0.5,sin(time*0.5+scrphase));\n  pt.x+=scr;\n  haha=lofi(pt,5.0);\n  float phase=BEAT/8.0;\n  phase+=dot(haha,vec3(2.75,3.625,1.0625));\n  phase=easeceil(phase,-10.0);\n  pt=mod(pt,5.0)-2.5;\n  vec3 pm=pt;\n  pt.yz=rot2d(.5*PI*phase+.25*PI)*pt.yz;\n  float clampBox=sdbox(pt,vec3(2.25,1.5,1.8));\n  pt=ifs(pt,vec3(3.6,3.0+0.4*phase,3.1),vec3(3.0,2.3,3.5));\n  pt=mod(pt-.5,1.)-.5;\n  float dist=sdbox(pt,vec3(.17));\n  dist=max(dist,clampBox);\n  return vec4(\n    dist,\n    sin(PI*fract(phase)),\n    step(0.0,0.01-abs(pt.x+pt.y)),\n    abs(pm.x)+abs(pm.y)+abs(pm.z)\n  );\n}\n\nvec3 normalFunc(vec3 p,vec2 d)\n{\n  return normalize(vec3(\n    map(p+d.yxx).x-map(p-d.yxx).x,\n    map(p+d.xyx).x-map(p-d.xyx).x,\n    map(p+d.xxy).x-map(p-d.xxy).x\n  ));\n}\n\nfloat aoFunc(vec3 p,vec3 n)\n{\n  float accum=0.;\n  for(int i=0;i<32;i++){\n    vec3 d=(0.02+0.02*float(i))*randsphere();\n    d=dot(d,n)<.0?-d:d;\n    //accum+=step(map(p+d).x,0.0)/64.0;\n    accum+=linearstep(0.02,0.0,map(p+d).x)/64.0;\n  }\n  return 1.0-sqrt(saturate(6.0*accum));\n}\n\nvec2 glitch(vec2 v)\n{\n  vec2 vt=v;\n  for(int i=0;i<6;i++)\n  {\n    float fac=4.0*pow(2.2,-float(i));\n    float s=fractsin(lofi(vt.x,1.6*fac));\n    s+=fractsin(lofi(vt.y,0.4*fac));\n    s+=fractsin(time);\n    float proc=fractsin(s);\n    vt+=0.2*step(proc,0.4*exp(-30.0*mod(BEAT,8.0))-0.1)*(vec2(\n      fractsin(s+22.56),\n      fractsin(s+17.56)\n    )-0.5);\n  }\n  return vt;\n}\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n  vec2 p=(fragCoord.xy*2.0-iResolution.xy)/iResolution.y;\n  o=vec4(0,0,0,1);\n  seed=texture(iChannel0,p).x;\n  seed+=time;\n  \n  vec2 po=p;\n  p=glitch(p);\n  \n  vec3 ro=vec3(4.0*time,0,lofi(BEAT,8.0));\n  vec3 rd=vec3(p,-1);\n  rd.z+=0.6*length(p);\n  float camphase=lofi(BEAT,8.0)+mod(BEAT,8.0)*0.2;\n  rd.yz=rot2d(0.33*camphase+0.03*sin(3.0*time))*rd.yz;\n  rd.zx=rot2d(0.78*camphase+0.03*cos(3.0*time))*rd.zx;\n  rd.xy=rot2d(0.048*camphase)*rd.xy;\n  rd=normalize(rd);\n  vec3 fp=ro+rd*5.0;\n  ro+=0.002*randsphere();\n  rd=normalize(fp-ro);\n  \n  vec4 dist;\n  float rl=0.01;\n  float glow=0.0;\n  vec3 rp=ro+rl*rd;\n  for(int i=0;i<69;i++){ // nice\n    dist=map(rp);\n    glow=dist.y;\n    rl+=dist.x*0.7;\n    rp=ro+rl*rd;\n  }\n  \n  float fog=exp(-0.1*max(0.,rl-5.0));\n  o.xyz+=(1.0-fog)*vec3(1.);\n  \n  vec3 n2=normalFunc(rp,vec2(0.0,1E-2+4E-2*dist.y));\n  vec3 n=normalFunc(rp,vec2(0.0,2E-3));\n  float edge=saturate(length(n-n2));\n  float gorge=dist.z;\n\n  o.xyz+=fog*0.1*vec3(15.0,1.0,1.5)*glow;\n  \n  if(dist.x<1E-3)\n  {\n    float ao=aoFunc(rp,n);\n    o.xyz+=fog*vec3((0.4-0.1*gorge)*ao);\n    o.xyz+=fog*edge*dist.y*vec3(15.0,1.0,1.5);\n    //o.xyz+=fog*gorge*vec3(2.0,15.0,5.0)*exp(-10.0*mod(time+dist.w,1.0));\n  }\n  \n  o.xyz+=length(p-po)*2.0*sin(3.0+4.0*o.x+vec3(0.0,2.0,4.0));\n  o.xyz=pow(o.xyz,vec3(0.4545));\n  o.xyz-=0.2*length(p);\n  o.xyz=vec3(\n    smoothstep(0.1,0.9,o.x),\n    linearstep(0.0,0.8,o.y),\n    smoothstep(-0.2,1.1,o.z)\n  );\n  o.xyz*=1.0+0.1*sin(vec3(0.,1.,2.)+fragCoord.y*2.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define PI 3.1415926536\n\nvec2 rotate(vec2 src, float angle) {\n    float sn = sin(angle);\n    float cs = cos(angle);\n    return vec2(src.x * cs - src.y * sn, src.x * sn + src.y * cs);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    float radius = 0.0065;\n    float angle = iTime * 4.0 + (uv.x * 80.0 + uv.y * 80.0) * 0.015;\n    float angle2 = iTime * 4.0 + (uv.x * 80.0 + uv.y * 80.0) * 0.015;\n    float angle3 = iTime * 4.0 + (uv.x * 80.0 + uv.y * 80.0) * 0.015;\n    \n    vec2 vector = vec2(0, radius);\n    \n    vec4 red = texture(iChannel0, uv + rotate(vector/* + sin(iTime * 7.0) * 0.0025*/, angle));\n    vec4 green = texture(iChannel0, uv + rotate(vector/* + sin(iTime * 9.0) * 0.0025*/, angle2 + 2.0 * PI / 3.0));\n    vec4 blue = texture(iChannel0, uv + rotate(vector/* + sin(iTime * 11.0) * 0.0025*/, angle3 + 2.0 * PI / 3.0 * 2.0));\n    fragColor = vec4(red.r, green.g, blue.b, 1.0);\n\n    // Output to screen\n    // fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 p = fragCoord.xy;\n    \n    vec2 uv = (p.xy) / iResolution.xy;\n    \n    //line thickness\n    float th = 0.002;\n    \n    //gradient detection for r,g and b separatly\n    //not sure why I did this actually\n    \n    float gxr = texture(iChannel0, uv.xy+vec2(th, 0.)).r\n    - texture(iChannel0, uv.xy-vec2(th, 0.)).r ;\n    \n    float gyr = texture(iChannel0, uv.xy+vec2(0., th)).r\n    - texture(iChannel0, uv.xy-vec2(0., th)).r;\n    \n    float gxg = texture(iChannel0, uv.xy+vec2(th, 0.)).g\n    - texture(iChannel0, uv.xy-vec2(th, 0.)).g ;\n    \n    float gyg = texture(iChannel0, uv.xy+vec2(0., th)).g\n    - texture(iChannel0, uv.xy-vec2(0., th)).g;\n    \n    float gxb = texture(iChannel0, uv.xy+vec2(th, 0.)).b\n    - texture(iChannel0, uv.xy-vec2(th, 0.)).b;\n    \n    float gyb = texture(iChannel0, uv.xy+vec2(0., th)).b\n    - texture(iChannel0, uv.xy-vec2(0., th)).b;\n    \n    //hack to concea noise from: https://www.shadertoy.com/view/Mdf3zr\n    float gr = gxr*gxr + gyr*gyr;\n    float gg = gxg*gxg + gyg*gyg;\n    float gb = gxb*gxb + gyb*gyb;\n    \n    //more noise control\n    float g = pow((gr+gg+gb)/1.,1.9);\n    \n    \n    vec3 col = texture(iChannel1, p / iResolution.xy).xyz;\n    col = mix(col,  0.5 + 0.5*cos(iTime*4.+uv.y*6.+vec3(0,2,4)),g*100.);\n    \n    fragColor = vec4(col,1.);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// This buffer is the feedback loop\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Convert the uv's to polar coordinates to scale up  \n    vec2 polarUv = (uv * 2.0 - 1.0);\n    float angle = atan(polarUv.y, polarUv.x);\n    \n    // Scale up the length of the vector by a noise function feeded by the angle and length of the vector\n    float ll = length(polarUv)*0.4915;\n    \n    vec3 base = texture(iChannel0, uv).rgb;\n    \n    // Convert the scaled coordinates back to cartesian\n    vec2 offs = vec2(cos(angle)*ll + 0.5, sin(angle)*ll + 0.5);\n    \n    // sample the last texture with uv's slightly scaled up\n    vec3 overlay = texture(iChannel1,offs).rgb;\n\n        // Additively blend the colors together\n    vec4 col = vec4(base + (base * overlay*(0.8478975*cos(iTime/5.5))), 1.0);\n    \n    fragColor = col;\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Pi  3.14159265359\n\n#define FocalDistance 1.4\n#define LensRatio .5\n#define Margins .01", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lfXWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[488, 488, 545, 545, 718]], "test": "untested"}
{"id": "4syBDm", "name": "/voronoi/stained glass", "author": "_fov", "description": "Remix of https://www.shadertoy.com/view/ldl3W8 and https://www.shadertoy.com/view/MslGD8", "tags": ["voronoi", "stainedglass"], "likes": 8, "viewed": 516, "published": 3, "date": "1626784884", "time_retrieved": "2024-07-30T19:10:08.585591", "image_code": "// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// I've not seen anybody out there computing correct cell interior distances for Voronoi\n// patterns yet. That's why they cannot shade the cell interior correctly, and why you've\n// never seen cell boundaries rendered correctly. \n\n// However, here's how you do mathematically correct distances (note the equidistant and non\n// degenerated grey isolines inside the cells) and hence edges (in yellow):\n\n// https://iquilezles.org/articles/voronoilines\n\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 hash2( vec2 p )\n{\n    // procedural white noise\t\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec2 animatedO( in vec2 n, in vec2 g)\n{\n    vec2 o = hash2( n + g );\n    o = 0.5 + 0.5*sin( iTime/10. + 6.2831 * o );\n    return o;\n}\n\n\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mr;\n    vec2 mo;\n    float md = 8.;\n\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = animatedO(n, g);\n\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mo = o;\n        }\n\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n\n    md = 10.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n        vec2 o = animatedO(n, g);\n\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        {\n            md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n        }\n    }\n\n    //return vec3( md, mr );\n    return vec3( md, mo );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xx;\n    vec3 c = voronoi( 8.0*p );\n\n    vec3 col = texture( iChannel0, p + c.yz / 8. ).rgb;\n\n    // highlights\n    col += c.x*vec3(0.8);\n    \n    // colorize some cells\n    vec3 cell_color = 0.5 + 0.5 * cos( vec3(c.y, 0,c.z) * 12. );\t\n    float dd = length( c.yz );\n\tcol = mix( cell_color, col, smoothstep( 0.2, 0.4, dd + 0.1) );\n    \n    // borders\t\n    col = mix( vec3(0.), col, smoothstep( 0.04, 0.07, c.x ) );\n        \n    // color adjust\n    col = rgb2hsv(col);\n    col.y *= 1.5;\n    col.z *= 1.25;\n    col = hsv2rgb(col);\n    \n    \n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4syBDm.jpg", "access": "api", "license": "mit", "functions": [[1529, 1529, 1551, 1551, 1882], [1884, 1884, 1906, 1906, 2075], [2077, 2077, 2099, 2130, 2220], [2222, 2222, 2261, 2261, 2355], [2358, 2358, 2385, 2385, 3393], [3395, 3395, 3452, 3452, 4055]], "test": "untested"}
{"id": "ftfSDs", "name": "Fork Fork ghost shaderatla 957", "author": "shaderatlasv", "description": "ghost+zoom", "tags": ["zoom"], "likes": 2, "viewed": 235, "published": 3, "date": "1626774982", "time_retrieved": "2024-07-30T19:10:09.361516", "image_code": "#define ZOOM_ITER 40\n#define ZOOM_CENTER vec2(0.5,0.5)\n#define ZOOM_AMP 0.02\n#define ZOOM_OUTSIDE_AMP 0.15\n#define ZOOM_OUTSIDE_OFFSET 0.2\n#define CHROMA_MIX 0.2\n#define HUGE 9E16\n#define PI 3.14159265\n#define saturate(i) clamp(i,0.,1.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  float len = length( uv - ZOOM_CENTER );\n\n  vec3 tex = vec3( 0.0 );\n\n  for ( int i = 0; i < ZOOM_ITER; i ++ ) {\n    float fi = ( float( i ) + 0.5 ) / float( ZOOM_ITER );\n    vec3 blurA = saturate( vec3(\n      1.0 - 4.0 * abs( 1.0 / 4.0 - fi ),\n      1.0 - 4.0 * abs( 2.0 / 4.0 - fi ),\n      1.0 - 4.0 * abs( 3.0 / 4.0 - fi )\n    ) ) * 4.0;\n    vec3 blurB = vec3(\n        1.0 - 2.0 * abs( 1.0 / 2.0 - fi )\n    ) * 2.0;\n    vec3 blur = mix( blurA, blurB, CHROMA_MIX ) / float( ZOOM_ITER );\n    float scaleAmp = ( ZOOM_OUTSIDE_AMP * len + ZOOM_AMP ) * fi + ZOOM_OUTSIDE_OFFSET * len;\n    vec2 uvt = ( 1.0 - scaleAmp ) * ( uv - ZOOM_CENTER ) + ZOOM_CENTER;\n    tex += blur * texture( iChannel0, uvt ).xyz;\n  }\n\n  // fragColor = vec4( tex, 1.0 );\n  fragColor = texture(iChannel0, uv);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 scaleFromCenter(vec2 coord, float scale) {\n  if (scale > 1.0 || scale < 0.0) { return coord; }\n  vec2 scaleCenter = vec2(0.5);\n  return (coord - scaleCenter) * scale + scaleCenter;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord/iResolution.xy;\n  \n    float scale = 1.0 - mod(iTime * 1.3, 0.8) + 0.4;\n    if (scale < 0.0) {\n    fragColor = texture(iChannel0, st);\n    return;\n    }\n    vec2 newCoord = scaleFromCenter(st, scale);\n    float colorScale = scale * 0.5;\n    vec4 resultColor = texture(iChannel0, st) * (1.0 - colorScale + 0.2);\n    vec4 newCoordColor = texture(iChannel0, newCoord) * (colorScale - 0.2);\n    vec4 result = (resultColor + newCoordColor);\n    fragColor = result;\n}", "buffer_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec4 appendFilter(vec4 textureColor) {\n    mediump float blueColor = textureColor.b * 63.0;\n    mediump vec2 quad1;\n    quad1.y = floor(floor(blueColor) / 8.0);\n    quad1.x = floor(blueColor) - (quad1.y * 8.0);\n    mediump vec2 quad2;\n    quad2.y = floor(ceil(blueColor) / 8.0);\n    quad2.x = ceil(blueColor) - (quad2.y * 8.0);\n    highp vec2 texPos1;\n    texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\n    texPos1.y = (quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g);\n    highp vec2 texPos2;\n    texPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\n    texPos2.y = (quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g);\n    lowp vec4 newColor1 = texture(iChannel1, texPos1);\n    lowp vec4 newColor2 = texture(iChannel1, texPos2);\n    lowp vec4 newColor = mix(newColor1, newColor2, fract(blueColor));\n\n    return mix(textureColor, vec4(newColor.rgb, textureColor.w), 0.7);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = appendFilter(texture(iChannel0, uv));\n} \n", "buffer_b_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftfSDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "NlXSWs", "name": "Analog Fractal", "author": "Tater", "description": "I saw this video by Code Parade and had to try it for myself. Mousable.\n[url]https://www.youtube.com/watch?v=Pv26QAOcb6Q[/url]\n\nThe code is fairly easy to change, if you make something cool please leave a comment :D", "tags": ["2d", "fractal", "mouse", "feedback"], "likes": 7, "viewed": 345, "published": 3, "date": "1626771581", "time_retrieved": "2024-07-30T19:10:10.125473", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0,uv).rgb;\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Processed by 'GLSL Shader Shrinker' (for reformating)\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\n#define rot(a)\tmat2(cos(a), sin(a), -sin(a), cos(a))\n#define sat(a, b)\tclamp(a, -b, b)\n#define undo(uv)\t(((uv * iResolution.y) + 0.5 * iResolution.xy) / iResolution.xy)\n\n//Change this to see the projected screens that create the fractal;\n#define viewScreens\tfalse\n\n//iq palette\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) { return a + b * cos(6.28318 * (c * t + d)); }\n\nvec3 texCam(vec2 uv, vec2 p, float rot, float scale) {\n\tuv -= p;\n\tuv *= rot(rot);\n\tuv /= scale;\n\tuv = undo(uv);\n\tfloat m = 1.0;\n\tif (viewScreens) m = 0.0;\n\treturn mix(texture(iChannel1, uv).rgb, texture(iChannel0, uv).rgb, m) * step(uv.x, 1.0) * step(uv.y, 1.0) * step(0.0, uv.x) * step(0.0, uv.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\tvec3 col = vec3(0.0);\n\tfloat t = iTime;\n\n\t//3 Copies of the current screen with some animation\n\tcol += texCam(uv, vec2(-0.1 + sin(t * 0.2 + 1.0) * 0.4, 0.1 + sin(t * 0.1 + 4.0) * 0.2), 0.4 + t * 0.4, 0.6);\n\tcol += texCam(uv, vec2(0.1 + sin(t * 0.4 + 2.0) * 0.4, -0.1 + sin(t * 0.3 + 5.0) * 0.2), 2.7 + t * 0.6, 0.8);\n\tcol += texCam(uv, vec2(0.0 + sin(t * 0.6 + 3.0) * 0.4, 0.0 + sin(t * 0.8 + 6.0) * 0.2), 0.3 + t, 0.3);\n\n\t//Something on screen to get it going\n\tvec3 ballcol = pal(floor(t * 0.5) * 0.25, vec3(0.5), vec3(0.5), vec3(1), vec3(0, 0.33, 0.66));\n\tvec2 ballpos = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n\tif (iMouse.z > 0.0) col += ballcol * step(length(vec2(uv - ballpos)), 0.1);\n\telse col += ballcol * step(length(vec2(uv.x + sin(t) * 0.2, uv.y + cos(t) * 0.2)), 0.1);\n\n\t//Reduce the color to prevent it from getting too bright\n\tcol *= 0.85;\n\tcol = clamp(col, 0.0, 1.0);\n\tfragColor = vec4(col, 1.0);\n}", "buffer_a_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXSWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 182]], "test": "untested"}
{"id": "ftXSWs", "name": "Revolving Planets", "author": "napsternxg", "description": "Simple example of plants revolving along the sun. \nOne this not implemented right now is to handle what happens when objects go behind each other. That will be handled in another example. ", "tags": ["plantes", "simpleraytracing"], "likes": 0, "viewed": 215, "published": 3, "date": "1626759973", "time_retrieved": "2024-07-30T19:10:10.896412", "image_code": "float PI = radians(180.);\n\nfloat makeCircle(vec3 p, vec3 rd, float r){\n    /**\n    Find inside of circle based on position vector and ray direction\n    Remember each point on screen gets its own ray direction\n    We use the normal vector of the point to control its brightness on screen.\n    **/ \n    float n = length(cross(p, rd));\n    n = smoothstep(r-0.02, r, n);\n    return n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //uv = fract(5.*uv);\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    \n    // Camera Source - Ray Source\n    vec3 ro = vec3(0., 0., -1.);\n    \n    // Ray Direction\n    vec3 rd = vec3(uv.x, uv.y, 0);\n    rd -= ro; // Vector\n    rd /= length(rd); // Normalize\n    \n    int numC = 5;\n    \n    vec3 p = vec3(0.);\n    float n = 0.;\n    vec3 cCol = vec3(1., 0., 0.);\n    \n    vec3 sceneCenter = vec3(0., 0., 5.);\n    sceneCenter -= ro;\n    \n    p = sceneCenter;\n    //p -= ro; // position vector with respect to camera\n    cCol = vec3(1., 1., 0.);\n    float nScene = makeCircle(p, rd, 0.5);\n    n = nScene;\n    col = mix(cCol, col, n);\n    float theta = PI/4.;\n    mat2 rot = mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n    \n    for(int i=0; i < numC; i++){\n        float id = smoothstep(0., float(numC), float(i+1));\n        p = vec3(cos(id*1.*iTime), 0.0*(id), 5.*sin(id*1.*iTime));\n        // Define a new plane of rotation around the sun for the planet\n        theta = (id-.5)*PI/4.;\n        rot = mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n        p.xy *= rot;\n        p += sceneCenter;\n        //p *= 3.;\n        //p -= ro; // position vector with respect to camera\n        cCol = vec3(id, 1.-id, id*id);\n        //cCol = vec3((id+0.5));\n        n = makeCircle(p, rd, 0.2*(0.5+id));\n        //n = min(nScene, n);;\n        //if(n>0. && nScene > 0. && dot(p - sceneCenter, rd) > 0.){\n        //    n = nScene;\n        //}\n        // step(0., -dot(p - sceneCenter, rd)\n        //n *= mix(nScene, n, step(0., -length(p) + nScene*length(sceneCenter)));\n        //n /= 2.;\n        //n = makeCircle(p, rd, 0.5);\n        col = mix(cCol, col, n);\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXSWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 70, 295, 382], [384, 384, 441, 491, 2305]], "test": "untested"}
{"id": "ftXXDl", "name": "beat-detect-julia", "author": "Shellderr", "description": "The soundcloud channel in buffer a doesn't always load..", "tags": ["reactive", "audio"], "likes": 3, "viewed": 269, "published": 3, "date": "1626755261", "time_retrieved": "2024-07-30T19:10:11.678321", "image_code": "#define res iResolution\n\nvoid mainImage(out vec4 fcolor, in vec2 fcoord){\n    fcolor = texture(iChannel0, fcoord/res.xy);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define res iResolution\n\nvoid mainImage(out vec4 fcolor, in vec2 fcoord){\n    float p = texture(iChannel0, vec2(0)).x;    \n    \n    float band = .2;\n    float threshhold = .578;\n    \n    float s = texture(iChannel1, vec2(band-.05,.75)).x;\n    s += texture(iChannel1, vec2(band,.75)).x;\n    s += texture(iChannel1, vec2(band+.05,.75)).x;\n    s*=.3;\n    \n   //p += pow(sin(iTime*3.),4.)*.001;\n   \n    p+= smoothstep(threshhold, 1.99, s)*.15; \n    fcolor = vec4(fract(p));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27841, "src": "https://soundcloud.com/kennylarkinofficial/kenny-larkin-glob-ben-klock-1", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_b_code": "#define res iResolution\n#define thresh 20.\n#define stop 200\n\nvec3 rgb(float a){\n    a *=8.;\n    return(cos(4.+a+vec3(0.,2.,4.)*.7)*.5+.5);\n}\n\nvec2 cmul(vec2 a, vec2 b){\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2){\n    float a = (v1.x*v2.x+v1.y*v2.y)/(v2.x*v2.x+v2.y*v2.y);\n    float b = (v1.y*v2.x-v1.x*v2.y)/(v2.x*v2.x+v2.y*v2.y);\n    return vec2(a,b);\n}\n\nvec2 cexp(vec2 z){\n    return exp(z.x)*vec2(cos(z.y),sin(z.y));\n}\n\nvec2 clog(vec2 z){\n    return vec2(log(length(z)),atan(z.y,z.x));\n}\n\nvec2 cpow(vec2 z, float c){\n    return cexp(c*clog(z));\n}\n\n\nvec2 clerp(vec2 a, vec2 b, float m){\n    m = clamp(m,0.,1.);\n    return cmul(vec2(1.-m),a)+cmul(vec2(m),b);\n}\n\n\nvec2 rot(vec2 v, float t){\n    float a = (1.*atan(v.x,v.y))+t;\n    return vec2(cos(a),sin(a))*length(v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    vec2 z = .8*(2.*fragCoord.xy-res.xy)/res.y;\n    \n    float p = texture(iChannel0, vec2(0)).x;\n    float t = p*100.;\n    vec2 v = vec2(cos(t*1.7),sin(t))*.43+vec2(-.3, .3);\n    \n    // z = rot(z,time);\n    //vec2 zz = vec2(0);\n    z = clerp(.3*clog(vec2(2)+z), (cdiv(vec2(.5),z)), .1);\n    // z = cexp(cmul(z,vec2(.4)));\n    z=rot(z,iTime*.3);\n    vec2 mouse = .5*iMouse.xy/res.xy;\n    vec2 c = mouse.xy==vec2(0)? vec2(-.77,-.22)/*vec2(cos(iTime*.4)-.3,-.66)*/: (2.*mouse.xy-1.);\n    int i = 0;\n    for(i; i < stop; i++){\n        z = cmul(z,z)+v;\n        if(length(z) > thresh)\n            break;\n    }\n    vec3 col = rgb(log(.9+float(i)/380.)*2.);\n    fragColor = vec4(col, 1.0 );\n}\n\n\n\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXXDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 73, 73, 123]], "test": "untested"}
{"id": "NlfSDl", "name": "Flux Modulation Synapse cat.01", "author": "xenn", "description": "I take off my hat to FMS_Cat. There is just something I really dig about the way this all moves. Tweaked to get most of the bits I like. I would love to get it to look like this does at this point:\nhttps://youtu.be/BpP9r84VqOk", "tags": ["3d", "livecoding"], "likes": 7, "viewed": 326, "published": 3, "date": "1626753155", "time_retrieved": "2024-07-30T19:10:12.630776", "image_code": "// Given a vec2 in [-1,+1], generate a texture coord in [0,+1]\nvec2 barrelDistortion( vec2 p, vec2 amt )\n{\n    p = 2.0 * p - 1.0;\n\n    /*\n    const float maxBarrelPower = 5.0;\n\t//note: http://glsl.heroku.com/e#3290.7 , copied from Little Grasshopper\n    float theta  = atan(p.y, p.x);\n    vec2 radius = vec2( length(p) );\n    radius = pow(radius, 1.0 + maxBarrelPower * amt);\n    p.x = radius.x * cos(theta);\n    p.y = radius.y * sin(theta);\n\n\t/*/\n    // much faster version\n    //const float maxBarrelPower = 5.0;\n    //float radius = length(p);\n    float maxBarrelPower = sqrt(5.0);\n    float radius = dot(p,p); //faster but doesn't match above accurately\n    p *= pow(vec2(radius), maxBarrelPower * amt);\n\t/* */\n\n    return p * 0.5 + 0.5;\n}\n\n//note: from https://www.shadertoy.com/view/MlSXR3\nvec2 brownConradyDistortion(vec2 uv, float scalar)\n{\n// AH!!!    uv = uv * 2.0 - 1.0;\n    uv = (uv - 0.5 ) * 2.0;\n    \n    if( true )\n    {\n        // positive values of K1 give barrel distortion, negative give pincushion\n        float barrelDistortion1 = -0.02 * scalar; // K1 in text books\n        float barrelDistortion2 = 0.0 * scalar; // K2 in text books\n\n        float r2 = dot(uv,uv);\n        uv *= 1.0 + barrelDistortion1 * r2 + barrelDistortion2 * r2 * r2;\n        //uv *= 1.0 + barrelDistortion1 * r2;\n    }\n    \n    // tangential distortion (due to off center lens elements)\n    // is not modeled in this function, but if it was, the terms would go here\n//    return uv * 0.5 + 0.5;\n   return (uv / 2.0) + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float maxDistort = 4.0 * (1.0-iMouse.x/iResolution.x);\n\n    float scalar = 1.0 * maxDistort;\n//    vec4 colourScalar = vec4(2.0, 1.5, 1.0, 1.0);\n    vec4 colourScalar = vec4(700.0, 560.0, 490.0, 1.0);\t// Based on the true wavelengths of red, green, blue light.\n    colourScalar /= max(max(colourScalar.x, colourScalar.y), colourScalar.z);\n    colourScalar *= 2.0;\n    \n    colourScalar *= scalar;\n    \n    vec4 sourceCol = texture(iChannel2, uv);\n\n    const float numTaps = 16.0;\n    \n    \n    fragColor = vec4( 0.0 );\n    for( float tap = 0.0; tap < numTaps; tap += 1.0 )\n    {\n        fragColor.r += texture(iChannel0, brownConradyDistortion(uv, colourScalar.r)).r;\n        fragColor.g += texture(iChannel0, brownConradyDistortion(uv, colourScalar.g)).g;\n        fragColor.b += texture(iChannel0, brownConradyDistortion(uv, colourScalar.b)).b;\n        \n        colourScalar *= 0.99;\n    }\n    \n    fragColor /= numTaps;\n  \n    fragColor.a = 1.0;\n    \n    vec4 bloom = texture(iChannel0,  uv);\n    vec4 base = texture(iChannel1,  uv); \n    \n    fragColor = sqrt(bloom).a * (bloom - ( base * bloom)); \n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Fork of \"FMS_Cat @ Shader Royale #1\" by FMS_Cat. https://shadertoy.com/view/wsccWj\n// 2021-07-20 03:21:18\n\n// FMS_Cat!!\n// Since it's written in the shader royale compo,\n// the code is a total mess that is not intended to be read.\n// I heard the compo machine is not a beast enough\n// so I made this less intensive a bit.\n// There are several artifacts that is difficult to ignore :(\n\n\n#define BEAT (time*69.0/60.0)\n#define PI 3.14159265\n#define time iTime * 01.0\n#define lofi(x,d) (floor((x)/(d))*(d))\n#define saturate(a) (clamp((a),0.025,1.))\n#define linearstep(a,b,t) (saturate(((t)-(a))/((b)-(a))))\n\nfloat seed;\n\nfloat fractsin(float v)\n{\n  return fract(sin(v*121.445)*34.59);\n}\n\nfloat rand()\n{\n  seed=fractsin(seed);\n  return seed;\n}\n\nvec3 randsphere()\n{\n  float t=PI*2.*rand();\n  float p=acos(rand()*2.-1.);\n  return vec3(sin(p)*sin(t),cos(p),sin(p)*cos(t));\n}\n\nfloat easeceil(float t, float fac)\n{\n  return floor(t)+.5+.5*cos(PI*exp(fac*fract(t)));\n}\n\nmat2 rot2d(float t)\n{\n  return mat2(cos(t),-sin(t),sin(t),cos(t));\n}\n\nvec3 ifs(vec3 p,vec3 rot,vec3 shift)\n{\n  vec3 pt=abs(p);\n  vec3 t=shift;\n  for(int i=0;i<6;i++)\n  {\n    pt=abs(pt)-abs(lofi(t*pow(1.8,-float(i)),1.0/512.0));\n    t.yz=rot2d(rot.x)*t.yz;\n    t.zx=rot2d(rot.y)*t.zx;\n    t.xy=rot2d(rot.z)*t.xy;\n    pt.xy=pt.x<pt.y?pt.yx:pt.xy;\n    pt.yz=pt.y<pt.z?pt.zy:pt.yz;\n  }\n  return pt;\n}\n\nfloat sdbox(vec3 p,vec3 s)\n{\n  vec3 d=abs(p)-s;\n  return length(max(d,0.));\n}\n\n// ======= map!!!!!!!!!! ====================================\nvec4 map(vec3 p)\n{\n  vec3 pt=p;\n  vec3 haha=lofi(pt,5.0);\n  float scrphase=mod(999.9*fractsin(haha.y+haha.z+3.88),PI*2.0);\n  float scr=(mod(haha.y+haha.z,2.0)*2.0-1.0)*20.0*smoothstep(-0.5,0.5,sin(time*0.5+scrphase));\n  pt.x+=scr;\n  haha=lofi(pt,5.0);\n  float phase=BEAT/8.0;\n  phase+=dot(haha,vec3(2.75,3.625,1.0625));\n  phase=easeceil(phase,-10.0);\n  pt=mod(pt,5.0)-2.5;\n  vec3 pm=pt;\n  pt.yz=rot2d(.5*PI*phase+.25*PI)*pt.yz;\n  float clampBox=sdbox(pt,vec3(2.25,1.5,1.8));\n  pt=ifs(pt,vec3(3.6,3.0+0.4*phase,3.1),vec3(3.0,2.3,3.5));\n  pt=mod(pt-.5,1.)-.5;\n  float dist=sdbox(pt,vec3(.17));\n  dist=max(dist,clampBox);\n  return vec4(\n    dist,\n    sin(PI*fract(phase)),\n    step(0.0,0.01-abs(pt.x+pt.y)),\n    abs(pm.x)+abs(pm.y)+abs(pm.z)\n  );\n}\n\nvec3 normalFunc(vec3 p,vec2 d)\n{\n  return normalize(vec3(\n    map(p+d.yxx).x-map(p-d.yxx).x,\n    map(p+d.xyx).x-map(p-d.xyx).x,\n    map(p+d.xxy).x-map(p-d.xxy).x\n  ));\n}\n\nfloat aoFunc(vec3 p,vec3 n)\n{\n  float accum=0.;\n  for(int i=0;i<32;i++){\n    vec3 d=(0.02+0.02*float(i))*randsphere();\n    d=dot(d,n)<.0?-d:d;\n    //accum+=step(map(p+d).x,0.0)/64.0;\n    accum+=linearstep(0.02,0.0,map(p+d).x)/64.0;\n  }\n  return 1.0-sqrt(saturate(6.0*accum));\n}\n\nvec2 glitch(vec2 v)\n{\n  vec2 vt=v;\n  for(int i=0;i<6;i++)\n  {\n    float fac=4.0*pow(2.2,-float(i));\n    float s=fractsin(lofi(vt.x,1.6*fac));\n    s+=fractsin(lofi(vt.y,0.4*fac));\n    s+=fractsin(time);\n    float proc=fractsin(s);\n    vt+=0.2*step(proc,0.4*exp(-30.0*mod(BEAT,8.0))-0.1)*(vec2(\n      fractsin(s+22.56),\n      fractsin(s+17.56)\n    )-0.5);\n  }\n  return vt;\n}\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n  vec2 p=(fragCoord.xy*2.0-iResolution.xy)/iResolution.y;\n  o=vec4(0,0,0,1);\n  seed=texture(iChannel0,p).x;\n  seed+=time;\n  \n  vec2 po=p;\n  p=glitch(p);\n  \n  vec3 ro=vec3(4.0*time,0,lofi(BEAT,8.0));\n  vec3 rd=vec3(p,-1);\n  rd.z+=0.6*length(p);\n  float camphase=lofi(BEAT,8.0)+mod(BEAT,8.0)*0.2;\n  rd.yz=rot2d(0.33*camphase+0.03*sin(3.0*time))*rd.yz;\n  rd.zx=rot2d(0.78*camphase+0.03*cos(3.0*time))*rd.zx;\n  rd.xy=rot2d(0.048*camphase)*rd.xy;\n  rd=normalize(rd);\n  vec3 fp=ro+rd*5.0;\n  ro+=0.002*randsphere();\n  rd=normalize(fp-ro);\n  \n  vec4 dist;\n  float rl=0.01;\n  float glow=0.0;\n  vec3 rp=ro+rl*rd;\n  for(int i=0;i<69;i++){ // nice\n    dist=map(rp);\n    glow=dist.y;\n    rl+=dist.x*0.7;\n    rp=ro+rl*rd;\n  }\n  \n  float fog=exp(-0.1*max(0.,rl-5.0));\n  o.xyz+=(1.0-fog)*vec3(1.);\n  \n  vec3 n2=normalFunc(rp,vec2(0.0,1E-2+4E-2*dist.y));\n  vec3 n=normalFunc(rp,vec2(0.0,2E-3));\n  float edge=saturate(length(n-n2));\n  float gorge=dist.z;\n\n  o.xyz+=fog*0.1*vec3(15.0,1.0,1.5)*glow;\n  \n  if(dist.x<1E-3)\n  {\n    float ao=aoFunc(rp,n);\n    o.xyz+=fog*vec3((0.4-0.1*gorge)*ao);\n    o.xyz+=fog*edge*dist.y*vec3(15.0,1.0,1.5);\n    //o.xyz+=fog*gorge*vec3(2.0,15.0,5.0)*exp(-10.0*mod(time+dist.w,1.0));\n  }\n  \n  o.xyz+=length(p-po)*2.0*sin(3.0+4.0*o.x+vec3(0.0,2.0,4.0));\n  o.xyz=pow(o.xyz,vec3(0.4545));\n  o.xyz-=0.2*length(p);\n  o.xyz=vec3(\n    smoothstep(0.1,0.9,o.x),\n    linearstep(0.0,0.8,o.y),\n    smoothstep(-0.2,1.1,o.z)\n  );\n  o.xyz*=1.0+0.1*sin(vec3(0.,1.,2.)+fragCoord.y*2.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Given a vec2 in [-1,+1], generate a texture coord in [0,+1]\nvec2 barrelDistortion( vec2 p, vec2 amt )\n{\n    p = 2.0 * p - 1.0;\n\n    /*\n    const float maxBarrelPower = 5.0;\n\t//note: http://glsl.heroku.com/e#3290.7 , copied from Little Grasshopper\n    float theta  = atan(p.y, p.x);\n    vec2 radius = vec2( length(p) );\n    radius = pow(radius, 1.0 + maxBarrelPower * amt);\n    p.x = radius.x * cos(theta);\n    p.y = radius.y * sin(theta);\n\n\t/*/\n    // much faster version\n    //const float maxBarrelPower = 5.0;\n    //float radius = length(p);\n    float maxBarrelPower = sqrt(5.0);\n    float radius = dot(p,p); //faster but doesn't match above accurately\n    p *= pow(vec2(radius), maxBarrelPower * amt);\n\t/* */\n\n    return p * 0.5 + 0.5;\n}\n\n//note: from https://www.shadertoy.com/view/MlSXR3\nvec2 brownConradyDistortion(vec2 uv, float scalar)\n{\n// AH!!!    uv = uv * 2.0 - 1.0;\n    uv = (uv - 0.5 ) * 2.0;\n    \n    if( true )\n    {\n        // positive values of K1 give barrel distortion, negative give pincushion\n        float barrelDistortion1 = -0.02 * scalar; // K1 in text books\n        float barrelDistortion2 = 0.0 * scalar; // K2 in text books\n\n        float r2 = dot(uv,uv);\n        uv *= 1.0 + barrelDistortion1 * r2 + barrelDistortion2 * r2 * r2;\n        //uv *= 1.0 + barrelDistortion1 * r2;\n    }\n    \n    // tangential distortion (due to off center lens elements)\n    // is not modeled in this function, but if it was, the terms would go here\n//    return uv * 0.5 + 0.5;\n   return (uv / 2.0) + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float maxDistort = 4.0 * (1.0-iMouse.x/iResolution.x);\n\n    float scalar = 1.0 * maxDistort;\n//    vec4 colourScalar = vec4(2.0, 1.5, 1.0, 1.0);\n    vec4 colourScalar = vec4(700.0, 560.0, 490.0, 1.0);\t// Based on the true wavelengths of red, green, blue light.\n    colourScalar /= max(max(colourScalar.x, colourScalar.y), colourScalar.z);\n    colourScalar *= 2.0;\n    \n    colourScalar *= scalar;\n    \n    vec4 sourceCol = texture(iChannel0, uv);\n\n    const float numTaps = 8.0;\n    \n    \n    fragColor = vec4( 0.0 );\n    for( float tap = 0.0; tap < numTaps; tap += 1.0 )\n    {\n        fragColor.r += texture(iChannel0, brownConradyDistortion(uv, colourScalar.r)).r;\n        fragColor.g += texture(iChannel0, brownConradyDistortion(uv, colourScalar.g)).g;\n        fragColor.b += texture(iChannel0, brownConradyDistortion(uv, colourScalar.b)).b;\n        \n        colourScalar *= 0.99;\n    }\n    \n    fragColor /= numTaps;\n  \n    fragColor.a = 1.0;\n}\n\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 p = fragCoord.xy;\n    \n    vec2 uv = (p.xy) / iResolution.xy;\n    \n    //line thickness\n    float th = 0.002;\n    \n    //gradient detection for r,g and b separatly\n    //not sure why I did this actually\n    \n    float gxr = texture(iChannel0, uv.xy+vec2(th, 0.)).r\n    - texture(iChannel0, uv.xy-vec2(th, 0.)).r ;\n    \n    float gyr = texture(iChannel0, uv.xy+vec2(0., th)).r\n    - texture(iChannel0, uv.xy-vec2(0., th)).r;\n    \n    float gxg = texture(iChannel0, uv.xy+vec2(th, 0.)).g\n    - texture(iChannel0, uv.xy-vec2(th, 0.)).g ;\n    \n    float gyg = texture(iChannel0, uv.xy+vec2(0., th)).g\n    - texture(iChannel0, uv.xy-vec2(0., th)).g;\n    \n    float gxb = texture(iChannel0, uv.xy+vec2(th, 0.)).b\n    - texture(iChannel0, uv.xy-vec2(th, 0.)).b;\n    \n    float gyb = texture(iChannel0, uv.xy+vec2(0., th)).b\n    - texture(iChannel0, uv.xy-vec2(0., th)).b;\n    \n    //hack to concea noise from: https://www.shadertoy.com/view/Mdf3zr\n    float gr = gxr*gxr + gyr*gyr;\n    float gg = gxg*gxg + gyg*gyg;\n    float gb = gxb*gxb + gyb*gyb;\n    \n    //more noise control\n    float g = pow((gr+gg+gb)/1.,1.9);\n    \n    \n    vec3 col = texture(iChannel1, p / iResolution.xy).xyz;\n    col = mix(col,  0.5 + 0.5*cos(iTime*4.+uv.y*6.+vec3(0,2,4)),g*100.);\n    \n    fragColor = vec4(col,1.);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// This buffer is the feedback loop\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Convert the uv's to polar coordinates to scale up  \n    vec2 polarUv = (uv * 2.0 - 1.0);\n    float angle = atan(polarUv.y, polarUv.x);\n    \n    // Scale up the length of the vector by a noise function feeded by the angle and length of the vector\n    float ll = length(polarUv)*0.4915;\n    \n    vec3 base = texture(iChannel0, uv).rgb;\n    \n    // Convert the scaled coordinates back to cartesian\n    vec2 offs = vec2(cos(angle)*ll + 0.5, sin(angle)*ll + 0.5);\n    \n    // sample the last texture with uv's slightly scaled up\n    vec3 overlay = texture(iChannel1,offs).rgb;\n\n        // Additively blend the colors together\n    vec4 col = vec4(base + (base * overlay*(0.8478975*cos(iTime/5.5))), 1.0);\n    \n    fragColor = col;\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Pi  3.14159265359\n\n#define FocalDistance 1.4\n#define LensRatio .5\n#define Margins .01", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlfSDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 63, 106, 106, 743], [745, 796, 848, 881, 1519], [1521, 1521, 1578, 1578, 2733]], "test": "untested"}
{"id": "ftXSDl", "name": "Epilepsy inducer", "author": "xenn", "description": "slightly modified Inigo Quilez's 3-line shader", "tags": ["simple"], "likes": 2, "viewed": 331, "published": 3, "date": "1626749303", "time_retrieved": "2024-07-30T19:10:13.397724", "image_code": "// Fork of \"edwiz7 - shader 2\" by edwiz7. https://shadertoy.com/view/ftlSWX\n// 2021-07-20 02:47:07\n\n// This buffer is the feedback loop\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Convert the uv's to polar coordinates to scale up  \n    vec2 polarUv = (uv * 2.0 - 1.0);\n    float angle = atan(polarUv.y, polarUv.x);\n    \n    // Scale up the length of the vector by a noise function feeded by the angle and length of the vector\n    float ll = length(polarUv)*0.4915;\n    \n    vec3 base = texture(iChannel0, uv).rgb;\n    \n    // Convert the scaled coordinates back to cartesian\n    vec2 offs = vec2(cos(angle)*ll + 0.5, sin(angle)*ll + 0.5);\n    \n    // sample the last texture with uv's slightly scaled up\n    vec3 overlay = texture(iChannel1,offs).rgb;\n\n        // Additively blend the colors together\n    vec4 col = vec4(base + overlay*(0.8478975*cos(iTime/5.5)), 1.0);\n    \n    fragColor = col;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This buffer is the feedback loop\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Convert the uv's to polar coordinates to scale up  \n    vec2 polarUv = (uv * 2.0 - 1.0);\n    float angle = atan(polarUv.y, polarUv.x);\n    \n    // Scale up the length of the vector by a noise function feeded by the angle and length of the vector\n    float ll = length(polarUv)*0.4915;\n    \n    vec3 base = texture(iChannel0, uv).rgb;\n    \n    // Convert the scaled coordinates back to cartesian\n    vec2 offs = vec2(cos(angle)*ll + 0.5, sin(angle)*ll + 0.5);\n    \n    // sample the last texture with uv's slightly scaled up\n    vec3 overlay = texture(iChannel1,offs).rgb;\n\n        // Additively blend the colors together\n    vec4 col = vec4(base + overlay*(0.8478975*cos(iTime/5.5)), 1.0);\n    \n    fragColor = col;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 c, in vec2 p )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = p/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Time varying pixel color\n\n    // Output to screen\n    c = vec4( sin(-6.0*uv.y/dot(uv,uv) + vec4(0,1,2,1) + iTime * 6.0) );\n}", "buffer_a_inputs": [], "buffer_c_code": "void mainImage( out vec4 c, in vec2 p )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = p/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Time varying pixel color\n\n    // Output to screen\n    c = vec4( sin(12.0*uv.y/dot(uv,uv) + vec4(0,1,2,1) + iTime * 12.0) );\n}", "buffer_c_inputs": [], "buffer_d_code": "// This buffer is the feedback loop\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Convert the uv's to polar coordinates to scale up  \n    vec2 polarUv = (uv * 2.0 - 1.0);\n    float angle = atan(polarUv.y, polarUv.x);\n    \n    // Scale up the length of the vector by a noise function feeded by the angle and length of the vector\n    float ll = length(polarUv)*0.4915;\n    \n    vec3 base = texture(iChannel0, uv).rgb;\n    \n    // Convert the scaled coordinates back to cartesian\n    vec2 offs = vec2(cos(angle)*ll + 0.5, sin(angle)*ll + 0.5);\n    \n    // sample the last texture with uv's slightly scaled up\n    vec3 overlay = texture(iChannel1,offs).rgb;\n\n        // Additively blend the colors together\n    vec4 col = vec4(base + overlay*(0.8478975*cos(iTime/5.5)), 1.0);\n    \n    fragColor = col;\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXSDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[137, 137, 194, 194, 969]], "test": "untested"}
{"id": "NtfXWl", "name": "Fractal 61_gaz", "author": "gaz", "description": "inspired \nhttps://twitter.com/zozuar/status/1417242718204465153\nhttps://twitter.com/kamoshika_vrc/status/1412078324545822721", "tags": ["fractal"], "likes": 8, "viewed": 378, "published": 3, "date": "1626747708", "time_retrieved": "2024-07-30T19:10:14.164674", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(1),H(g*.1),.5)*.02*exp(-20.*i*i*e)\n    )\n    {\n        p=g*d;\n        p.z-=15.;\n        p=R(p,normalize(vec3(3,2,1)),iTime*.5);        \n        e=s=3.;\n        for(int j=0;j++<10;)\n            p.xz=abs(p.zx),\n            e=min(\n                e,\n                (length(p.zx+length(p)-3.)-.3)/s\n            ),\n            q=R(normalize(vec3(1,2,3)),vec3(.577),iTime*.7),\n            p=R(p,q,iTime*.3),\n            p-=vec3(1,1.2,1.+sin(iTime)*.5),\n            p*=1.2,\n            s*=1.2;\n        g+=e;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtfXWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 809]], "test": "untested"}
{"id": "7tlXWf", "name": "Simplest proper voxel tracing", "author": "Balint", "description": "\"Proper\" as in you could make a simpler version that steps a set small amount each iteration, but that would be slow or would be very inaccurate", "tags": ["voxelraytracinginteractive"], "likes": 10, "viewed": 488, "published": 3, "date": "1626732886", "time_retrieved": "2024-07-30T19:10:14.987474", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1);\n    vec2 uv = fragCoord / iResolution.yy * 10.0;\n\n    \n    vec2 rayOrigin = vec2(6.2, 7.6);\n    vec2 mousePos = iMouse.xy / iResolution.yy * 10.0;\n    vec2 rayDirection = normalize(mousePos - rayOrigin);\n    \n    ivec2 blockPos = ivec2(uv);\n    \n    vec2 pos = rayOrigin;\n    for (int i = 0; i < 50; i++) {\n        ivec2 currentBlock = ivec2(floor(pos));\n        // If we are inside the block the pixel is in, draw grey\n        if (blockPos.x == currentBlock.x && blockPos.y == currentBlock.y) {\n            fragColor.rgb = vec3(0.5);\n            break;\n        }\n    \n        vec2 fPos = fract(pos);\n        vec2 distances = ceil(sign(rayDirection) * 0.5 + 0.5) - fPos;\n        vec2 steps = abs(distances / rayDirection);\n        float closestStep = min(steps.x, steps.y);\n        pos += rayDirection * (closestStep + 0.001);\n    }\n    \n    // Drawing grid lines\n    fragColor.rgb = mix(vec3(0, 0, 0), fragColor.rgb, step(0.05, fract(uv.x)) * step(0.05, fract(uv.y)));\n    // Drawing ray\n    vec2 normal = rayDirection.yx * vec2(-1, 1);\n    float closest = max(dot(uv - rayOrigin, rayDirection), 0.0);\n    float d = length(uv - rayOrigin - rayDirection * closest);\n    fragColor.rgb = mix(vec3(0, 1, 0), fragColor.rgb, step(0.05, d));\n    // Drawing ray origin\n    fragColor.rgb = mix(vec3(0, 0, 1), fragColor.rgb, step(0.15, length(rayOrigin - uv)));\n    // Drawing mouse pos\n    fragColor.rgb = mix(vec3(1, 0, 0), fragColor.rgb, step(0.15, length(mousePos - uv)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlXWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1552]], "test": "untested"}
{"id": "ftlSDX", "name": "Fast Supersampling", "author": "goingdigital", "description": "Image Super Resolution using 5 texture fetch Lanczos-2 resampler and AMD FidelityFX CAS sharpener. 10 texture samples per pixel.  Other upscalers: https://www.shadertoy.com/playlist/WcKXWW\n", "tags": ["superresolution", "fsr"], "likes": 19, "viewed": 2781, "published": 3, "date": "1626730730", "time_retrieved": "2024-07-30T19:10:15.845181", "image_code": "/*\n\nPlease view shader in full screen. It works better at up-scaling\nthan down-scaling, so needs a viewing window at least 1024x1024 for\nthe default texture.\n\nAMD FidelityFX Contrast Adaptive Sharpening\nhttps://gpuopen.com/fidelityfx-cas/\nPotentially useful to upscale under-resolution renders.\n\nThis is a slimmed down reimplementation based on the paper.\n\nBest viewed in fullscreen.\nDrag left right to change switchover position. CAS on left.\nDrag up and down to set CAS level.\n\nThanks Txoka for the fixes.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 muv;\n    if (iMouse.z > 0.) {\n        muv = iMouse.xy/iResolution.xy;\n    } else {\n        muv = vec2(.5+.3*sin(iTime*.3),.5);\n    }\n  \n    vec3 col = texture(iChannel0, uv).xyz;\n\n    // CAS algorithm\n    float max_g = col.y;\n    float min_g = col.y;\n    vec4 uvoff = vec4(1,0,1,-1)/iChannelResolution[0].xxyy;\n    vec3 colw;\n    vec3 col1 = texture(iChannel0, uv+uvoff.yw).xyz;\n    max_g = max(max_g, col1.y);\n    min_g = min(min_g, col1.y);\n    colw = col1;\n    col1 = texture(iChannel0, uv+uvoff.xy).xyz;\n    max_g = max(max_g, col1.y);\n    min_g = min(min_g, col1.y);\n    colw += col1;\n    col1 = texture(iChannel0, uv+uvoff.yz).xyz;\n    max_g = max(max_g, col1.y);\n    min_g = min(min_g, col1.y);\n    colw += col1;\n    col1 = texture(iChannel0, uv-uvoff.xy).xyz;\n    max_g = max(max_g, col1.y);\n    min_g = min(min_g, col1.y);\n    colw += col1;\n    float d_min_g = min_g;\n    float d_max_g = 1.-max_g;\n    float A;\n    max_g = max(0., max_g);\n    if (d_max_g < d_min_g) {\n        A = d_max_g / max_g;\n    } else {\n        A = d_min_g / max_g;\n    }\n    A = sqrt(max(0., A));\n    A *= mix(-.125, -.2, muv.y);\n    vec3 col_out = (col + colw * A) / (1.+4.*A);\n    if (uv.x > (muv.x-1./iResolution.x)) {\n        if (uv.x > (muv.x+1./iResolution.x)) {\n            // 'Control' texture\n            col_out = texture(iChannel1, uv).xyz;\n        } else {\n            // Black line\n            col_out = vec3(0);\n        }\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(col_out,1);\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/* Lanczos-2 image upscaler\n*\n* This takes a reduced resolution source, and scales it up while preserving detail.\n* It is very close to an ideal Lanczos-2 filter, but 5 texture fetches instead of 16.\n*\n* Algorithm based on Jorge Jimenez's SIGGRAPH 2016 paper\n* [Jimenez2016] Filmic SMAA: Sharp Morphological and Temporal\nAntialiasing\n* https://research.activision.com/publications/archives/filmic-smaasharp-morphological-and-temporal-antialiasing\n*\n* [Djovnov2012] Bicubic Filtering in Fewer Taps\n* https://vec3.ca/bicubic-filtering-in-fewer-taps\n*\n* I've rolled by own tap coefficients, as seem to be much more accurate to Lanczos-2\n* than the references above.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scale constants\n    vec4 scale = vec4(\n        1. / vec2(textureSize(iChannel0, 0)),\n        vec2(textureSize(iChannel0, 0)) / iResolution.xy\n    );\n    \n    // Source position in fractions of a texel\n    vec2 src_pos = scale.zw * fragCoord;\n    // Source bottom left texel centre\n    vec2 src_centre = floor(src_pos - .5) + .5;\n    // f is position. f.x runs left to right, y bottom to top, z right to left, w top to bottom\n    vec4 f; f.zw = 1. - (f.xy = src_pos - src_centre);\n    // Calculate weights in x and y in parallel.\n    // These polynomials are piecewise approximation of Lanczos kernel\n    // Calculator here: https://gist.github.com/going-digital/752271db735a07da7617079482394543\n    vec4 l2_w0_o3 = ((1.5672 * f - 2.6445) * f + 0.0837) * f + 0.9976;\n    vec4 l2_w1_o3 = ((-0.7389 * f + 1.3652) * f - 0.6295) * f - 0.0004;\n\n    vec4 w1_2 = l2_w0_o3;\n    vec2 w12 = w1_2.xy + w1_2.zw;\n    vec4 wedge = l2_w1_o3.xyzw * w12.yxyx;\n    // Calculate texture read positions. tc12 uses bilinear interpolation to do 4 reads in 1.\n    vec2 tc12 = scale.xy * (src_centre + w1_2.zw / w12);\n    vec2 tc0 = scale.xy * (src_centre - 1.);\n    vec2 tc3 = scale.xy * (src_centre + 2.);\n    // Sharpening adjustment\n    // Thanks mad_gooze for the normalization fix.\n    float sum = wedge.x + wedge.y + wedge.z + wedge.w + w12.x * w12.y;    \n    wedge /= sum;\n    vec3 col = vec3(\n        texture(iChannel0, vec2(tc12.x, tc0.y)).rgb * wedge.y +\n        texture(iChannel0, vec2(tc0.x, tc12.y)).rgb * wedge.x +\n        texture(iChannel0, tc12.xy).rgb * (w12.x * w12.y) +\n        texture(iChannel0, vec2(tc3.x, tc12.y)).rgb * wedge.z +\n        texture(iChannel0, vec2(tc12.x, tc3.y)).rgb * wedge.w\n    );\n\n    fragColor = vec4(col,1);\n}\n", "buffer_a_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftlSDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[512, 512, 569, 619, 2162]], "test": "untested"}
{"id": "stsSWf", "name": "Lasers!", "author": "kosmaks", "description": "Shamelessly stolen idea from blender render. Source: https://twitter.com/chiu_hans/status/1416972152381657093?s=20", "tags": ["raytracing", "raymarching", "lasers"], "likes": 29, "viewed": 661, "published": 3, "date": "1626728973", "time_retrieved": "2024-07-30T19:10:16.872434", "image_code": "float getDistMinimal(vec3 p, out int id) {\n    return bootstrapGetDist(iTime, p, id);\n}\n\n\nfloat getDist(vec3 p, out int id) {\n    float d = getDistMinimal(p, id);\n    \n    float td = MAX_DIST;\n    int tid;\n    float fi = -1.;\n    \n    for (int i = 0; i < MAX_LASER_BOUNCES; ++i) {\n        fi += 1.;\n        vec3 start = sampleCell(iChannel0, vec2(0., fi)).xyz;\n        if (start.x < -9.) break;\n        vec3 end = sampleCell(iChannel0, vec2(1., fi)).xyz;\n        td = sdSegment(p, start, end);\n        if (td < d) { d = td; id = ID_LASER; }\n    }\n    \n    return d;\n}\n\nvec3 getNormal(vec3 p) {\n    int id;\n    float dist = getDistMinimal(p, id);\n    vec2 e = vec2(MIN_DIST, 0.);\n    vec3 n = dist - vec3(\n        getDistMinimal(p - e.xyy, id),\n        getDistMinimal(p - e.yxy, id),\n        getDistMinimal(p - e.yyx, id));\n    return normalize(n);\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float k, float mind, float maxd) {\n    int id;\n    float totalDist = 0.1;\n    float res = 1.;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        vec3 next = ro + totalDist * rd;\n        float d = getDistMinimal(next, id);\n        if (id != ID_LASER && id != ID_REFR) {\n            res = min(res, k * d / totalDist);\n            if (abs(d) < mind) return 0.;\n        } else {\n            return 1.1;\n        }\n        totalDist += d;\n        if (totalDist > maxd) break;\n    }\n    return clamp(res, 0., 1.);\n}\n\nfloat castRay(vec3 ro, vec3 rd, out int id) {\n    float totalDist = 0.;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        vec3 next = ro + totalDist * rd;\n        float d = getDist(next, id);\n        totalDist += (d);\n        if (abs(d) < MIN_DIST || totalDist > MAX_DIST) break;\n        if (i == MAX_STEPS - 1) totalDist = MAX_DIST + 1.;\n    }\n\n    return totalDist;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.y;\n    float vpWindow = 2. / iResolution.y;\n    vec2 vpShift = vec2(iResolution.x / iResolution.y, 1.);\n    vec2 vp = fragCoord * vpWindow - vpShift;\n\n    vec3 camOrigin = vec3(0.2, 2.2, -2.) + sin(iTime * 1.) * vec3(0.1, 0., 0.);\n    vec3 camTarget = vec3(0.1, -0.2, 0.5);\n    vec3 camForward = normalize(camTarget - camOrigin);\n    vec3 camRight = cross(vec3(0., 1., 0.), camForward);\n    vec3 camUp = cross(camForward, camRight);\n\n    vec3 ro = camOrigin;\n    vec3 rd = normalize(camForward * 2.5 + camRight * vp.x + camUp * vp.y);\n\n    int id;\n    float d;\n    vec3 col = vec3(0.);\n    vec3 mul = vec3(1.);\n    float flip = 0.;\n\n    for (int i = 0; i < 20; ++i) {\n        d = castRay(ro, rd, id);\n\n        if (d < MAX_DIST) {\n\n            if (id == ID_LASER) {\n                col += mul * vec3(0., 2., 0.);\n                break;\n            }\n\n            vec3 hit = ro + d * rd;\n            vec3 n = getNormal(hit);\n            \n            vec3 tl = normalize((LIGHT_POS - hit));\n            \n            float diffuse = max(0., dot(tl, n));\n            float ambient = 0.1;\n            float specular = max(0., dot(reflect(normalize(hit - LIGHT_POS), n), -rd));\n            float shadow = softShadow(hit + n * MIN_DIST * 2., tl, 10., 0.001, 2.);\n            \n            if (id == ID_FLOOR) {\n                col += mul * diffuse * vec3(0.5);\n                col += mul * ambient * vec3(0.1);\n                col += mul * pow(specular, 2.) * vec3(0.2);\n                col *= mix(0.7, 1., shadow);\n                break;\n            } else\n            \n            if (id == ID_TARGET) {\n                col += mul * diffuse * vec3(1.);\n                col += mul * vec3(0.3);\n                col += mul * pow(specular, 20.) * vec3(0.2);\n                col *= mix(0.7, 1., shadow);\n                \n                mul *= 0.2;\n                ro = hit + n * MIN_DIST * 2.;\n                rd = reflect(rd, n);\n                continue;\n            } else\n            \n            if (id == ID_REFR) {\n                col += mul * pow(specular, 20.) * vec3(5.);\n                \n                float h = REFR;\n                float idx = mix(1. / h, h / 1., flip);\n                rd = refract(rd, n, idx);\n                ro = hit + rd * WALL * 4.;\n                flip = 1. - flip;\n                \n                continue;\n            }\n\n            if (id == ID_REFL) {\n                col += mul * diffuse * vec3(0.1);\n                col += mul * pow(specular, 3.) * vec3(1.);\n                col *= mix(0.7, 1., shadow);\n                \n                ro = hit + n * MIN_DIST * 2.;\n                rd = reflect(rd, n);\n                rd = normalize(rd + texture(iChannel1, hit.xy * 3.).xyz * rd * 0.4);\n                continue;\n            }\n\n            break;\n\n        } else {\n            break;\n        }\n    }\n\n    \n    float gamma = 2.2;\n    col = pow(col, vec3(1. / gamma));\n    \n    \n    float frame = 1. - length(fragCoord.xy / iResolution.xy - 0.5);\n    col *= frame * frame * 0.9 + 0.1;\n    \n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define MIN_DIST (0.001)\n#define MAX_DIST (10.)\n#define MAX_STEPS (100)\n\n#define WALL (0.002)\n#define MAX_LASER_BOUNCES (20)\n#define LASER_ORIGIN (vec3(-1.93, 0., -2.))\n\nconst vec3 LASER_DIR = normalize(vec3(0.7, 0., 2.));\n\n#define ID_FLOOR (0)\n#define ID_REFL (1)\n#define ID_REFR (2)\n#define ID_LASER (3)\n#define ID_TARGET (4)\n#define ID_ROOF (5)\n\n#define LIGHT_POS (vec3(0., 3., -0.5))\n\n#define REFR (1.5)\n\n// distance funcs\n\nvec3 rotate(vec3 v, vec3 axis, float angle) {\n    float ah = angle / 2.;\n    vec4 q = vec4(axis.xyz * sin(ah), cos(ah));\n    vec3 temp = cross(q.xyz, v) + q.w * v;\n    return v + 2. * cross(q.xyz, temp);\n}\n\nfloat sdSegment(vec3 p, vec3 s, vec3 e) {\n    p -= s;\n    e -= s;\n    float len = length(e);\n    float v = clamp(dot(p, e) / (len * len), 0., 1.);\n    vec3 proj = e * v;\n    return distance(proj, p) - 0.003;\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h, r);\n  return min(max(d.x, d.y),0.0) + length(max(d, 0.0));\n}\n\nfloat sdHollowCylinder(vec3 p, float h, float r) {\n    return max(sdCylinder(p, h, r), -sdCylinder(p, h - WALL, r - WALL));\n}\n\n// bootstraps\n\n#define ANIM_DURATION (3.5)\n\nfloat animate(float iTime, float start, float end, float from, float to) {\n    iTime += ANIM_DURATION;\n    iTime = mod(iTime, ANIM_DURATION + 0.5);\n    float dur = (end - start);\n    float idx = clamp((iTime - start) / dur, 0., 1.);\n    \n    idx = min(idx, 1. - clamp((iTime - ANIM_DURATION) / 0.5, 0., 1.));\n    \n    idx = smoothstep(0., 1., idx);\n    return mix(from, to, idx);\n}\n\nfloat bootstrapGetDist(float iTime, vec3 p, out int id) {\n    id = ID_FLOOR;\n    float d = p.y + 0.5, td, shift;\n    vec3 tp;\n    \n    //d = min(d, 6. - length(p));\n \n    shift = animate(iTime, 0., 0.5, 0.3, 0.5);\n    tp = p;\n    tp -= vec3(-1., 0., 0.7);\n    tp = rotate(tp, vec3(0., 1., 0.), shift);\n    tp = rotate(tp, vec3(1., 0., 0.), 1.57);\n    td = sdCylinder(tp, 0.2, 0.03);\n    if (td < d) { d = td; id = ID_REFL; }\n\n    shift = animate(iTime, 0.5, 1., -0.3, 0.);\n    tp = p;\n    tp -= vec3(0.15, shift, 0.7);\n    td = sdHollowCylinder(tp, 0.5, 0.08);\n    if (td < d) { d = td; id = ID_REFR; }\n \n    shift = animate(iTime, 1., 1.5, -1.9, -1.8);\n    tp = p;\n    tp -= vec3(1., 0., 0.6);\n    tp = rotate(tp, vec3(0., 1., 0.), shift);\n    tp = rotate(tp, vec3(1., 0., 0.), 1.57);\n    td = sdCylinder(tp, 0.2, 0.03);\n    if (td < d) { d = td; id = ID_REFL; }\n\n    shift = animate(iTime, 1.5, 2., 2., 1.8);\n    tp = p;\n    tp -= vec3(-0.7, 0., 1.);\n    tp = rotate(tp, vec3(0., 1., 0.), shift);\n    tp = rotate(tp, vec3(1., 0., 0.), 1.57);\n    td = sdCylinder(tp, 0.2, 0.03);\n    if (td < d) { d = td; id = ID_REFL; }\n\n    shift = animate(iTime, 2., 2.5, -0.45, -0.535);\n    tp = p;\n    tp -= vec3(0.5, 0., 1.47);\n    tp = rotate(tp, vec3(0., 1., 0.), shift);\n    tp = rotate(tp, vec3(1., 0., 0.), 1.57);\n    td = sdCylinder(tp, 0.2, 0.03);\n    if (td < d) { d = td; id = ID_REFL; }\n\n    shift = animate(iTime, 2.5, 3., -1.3, -1.1);\n    tp = p;\n    tp -= vec3(-0.5, 0., -0.5);\n    tp = rotate(tp, vec3(0., 1., 0.), shift);\n    tp = rotate(tp, vec3(1., 0., 0.), 1.57);\n    td = sdCylinder(tp, 0.2, 0.03);\n    if (td < d) { d = td; id = ID_REFL; }\n    \n    shift = animate(iTime, 3., 3.5, 0., 1.);\n    tp = p;\n    tp -= vec3(0.7, 0., -0.25);\n    td = length(tp) - 0.2;\n    if (td < d) { d = td; id = ID_TARGET; }\n \n    return d;\n}\n\n// State\n\n#define GRID_SIZE (100.)\n#define GRID_CELL (1. / GRID_SIZE)\n#define GRID_HALF vec2(GRID_CELL * 0.5)\n#define CLOSE(x, y) (abs(x - y) < 0.001)\n#define IS_CELL(c, a) (CLOSE(c.x, a.x) && CLOSE(c.y, a.y))\n\nvec2 getGridCell(vec2 uv) {\n    vec2 scaled = uv * GRID_SIZE;\n    vec2 vertex = floor(scaled);\n    vec2 center = vertex + 0.5;\n    return distance(scaled, center) < 0.5 ? vertex : vec2(-1.);\n}\n\nvec4 sampleCell(sampler2D tex, vec2 index) {\n    return texture(tex, index / GRID_SIZE + GRID_HALF);\n}", "buffer_a_code": "float getDist(vec3 p, out int id) {\n    return bootstrapGetDist(iTime, p, id);\n}\n\nvec3 getNormal(vec3 p) {\n    int id;\n    float dist = getDist(p, id);\n    vec2 e = vec2(MIN_DIST, 0.);\n    vec3 n = dist - vec3(\n        getDist(p - e.xyy, id),\n        getDist(p - e.yxy, id),\n        getDist(p - e.yyx, id));\n    return normalize(n);\n}\n\nfloat castRay(vec3 ro, vec3 rd, out int id) {\n    float totalDist = 0.;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        vec3 next = ro + totalDist * rd;\n        float d = getDist(next, id);\n        totalDist += (d);\n        if (abs(d) < MIN_DIST || totalDist > MAX_DIST) break;\n        if (i == MAX_STEPS - 1) totalDist = MAX_DIST + 1.;\n    }\n    \n    return totalDist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 cell = getGridCell(uv);\n    \n    if (\n        cell.x >= 2. || \n        cell.y >= float(MAX_LASER_BOUNCES) || \n        cell.x < 0. || \n        cell.y < 0.\n    ) {\n        fragColor = vec4(0.);\n        return;\n    }\n   \n    \n    vec3 lo = LASER_ORIGIN, ld = LASER_DIR;\n    int id;\n    float flip = 0.;\n    \n    float fi = -1.;\n    \n    for (int i = 0; i < MAX_LASER_BOUNCES; ++i) {\n        fi += 1.;\n        \n        float d = castRay(lo, ld, id);\n        \n        if (IS_CELL(cell, vec2(0., fi))) {\n            fragColor = vec4(lo, 0.);\n            return;\n        }\n        \n        vec3 hit = lo + d * ld;\n        \n        if (IS_CELL(cell, vec2(1., fi))) {\n            fragColor = vec4(hit, 0.);\n            return;\n        }\n        \n        if (d > MAX_DIST) {\n            break;\n        }\n        \n        if (id == ID_REFL) {\n            vec3 n = getNormal(hit);\n            lo = hit + n * MIN_DIST;\n            ld = reflect(ld, n);\n            continue;\n        }\n\n        if (id == ID_REFR) {\n            vec3 n = getNormal(hit);\n            lo = hit - n * WALL * 3.;\n            ld = refract(ld, n, mix(1. / REFR, REFR / 1., flip));\n            flip = 1. - flip;\n            continue;\n        }\n\n        break;\n    }\n    \n    \n    fragColor = vec4(vec3(-10.), 1.);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stsSWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 87], [90, 90, 125, 125, 567], [569, 569, 593, 593, 849], [851, 851, 920, 920, 1393], [1395, 1395, 1440, 1440, 1764], [1766, 1766, 1821, 1821, 4925]], "test": "untested"}
{"id": "fllXzl", "name": "Lattice Parametrization II", "author": "spr", "description": "Lattice with Voronoi cells. Uses LLL for lattice reduction. Modular Surface /  Space of Lattices\nControls:\na/z expand x-direction & contract y-direction (geodesic flow)\ns/x & f/v shear (horocycle flow)\nd/c rotate (rotation of unit tangent vector)\n\n\n", "tags": ["modularsurface"], "likes": 10, "viewed": 524, "published": 3, "date": "1626724818", "time_retrieved": "2024-07-30T19:10:17.830872", "image_code": "// MacOS Safari users need to turn on WebGL 2.0 in Experimental Features.\n\n\n// The MIT License\n// Copyright © 2021 René Rühr\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Fun fact: shear + opposite shear to produce a rotation (e.g. https://link.springer.com/content/pdf/10.1007/3-540-62005-2_26.pdf )\n//           Press s & v alternatingly\n\n\n// Acknowledgement: First Person hyperbolic disk suggested by Manfred.\n\n\nconst int sample_range = 5; \nconst float point_size = 0.1;\nconst float line_thickness = 0.01;\nconst float infty = 10000.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/pixel_per_unit;\n\n    vec3 color = vec3(0);\n    vec2 p1,p2;\n    float d1 = infty;\n    float d2 = infty;\n    \n    mat2 lattice;\n    lattice[0] = texelFetch( iChannel0, ivec2(0), 0 ).xy; // Lattice after Reduction from Buffer A\n    lattice[1] = texelFetch( iChannel0, ivec2(0), 0 ).zw; // \n    \n    vec2 z = texelFetch( iChannel1, ivec2(0), 0 ).zw; // Height from Buffer B\n    float cusp_zoom = min(z.y < 4.6 ? 1. : z.y*0.3, 11.);       // Used to zoom out in upper half plane, increase copies in the disk model, \n    int range = sample_range + 2*int(cusp_zoom);      // and increase the copies of the voronoi cell\n    \n    //Voronoi Window\n    if(fragCoord.x >= iResolution.x/2. && fragCoord.y >= iResolution.y/2.){ \n        vec2 uv = (fragCoord-vec2(0.75*iResolution.x,0.75*iResolution.y))/pixel_per_unit;\n        vec3 color_in;\n        for(int x = -range; x<=range; ++x){\n            for(int y = -range; y<=range; ++y){\n                if(x == 0 && y == 0) \n                    color_in = vec3(1,0,0);\n                else if(x == 0 && y == 1)\n                    color_in = vec3(0,1,0);\n                else if(x == 1 && y == 0)\n                    color_in = vec3(0,0,1);\n                else\n                    color_in = vec3(1);               \n                vec2 point = lattice[0]*float(x) + lattice[1]*float(y);\n\n                DrawPoint(color, color_in, uv, point, point_size);\n                ClosestPoints(p1, p2, d1, d2, uv, point);\n        }}\n        if(abs(dot(uv-0.5*(p1+p2), normalize(p2-p1)))<line_thickness) color = vec3(1);   // https://iquilezles.org/articles/voronoilines\n    } \n    //Disk Model Window\n    else if(fragCoord.x >= iResolution.x/2. && fragCoord.y <= iResolution.y/2.)\n    {\n        vec2 resolution = iResolution.xy/2.;\n        vec2 offset = vec2(0.75 * iResolution.x, 0.25*iResolution.y);\n        vec2 w = (fragCoord-offset)/resolution.x*4.; \n        \n        float arrow = sdArrow( w*40., vec2(0,0)*40., vec2(0,0)*50.-.3*vec2(0,-1)*40., 0.2, 1. );\n        arrow = arrow <= 0.1 ? 1. : 0.;\n        color = vec3(arrow); \n        \n        w = vec2(-w.y,w.x);\n\n        if(length(w)<=0.03){\n            color += vec3(1);\n        } else if(length(w)<1.){ \n            int number_of_max_translates = 10+int(cusp_zoom)*30; \n            ToHalfplane(w);\n            Moebius(inverse(lattice), w);\n                \n             \n            bool flip = false; // https://www.shadertoy.com/view/wdjyzh\n            int j=0;\n            for (;j<number_of_max_translates; ++j)\n            {\n                flip = !flip;\n                if(w.x > 0.5) w.x -= 1.;\n                else if(w.x < -0.5) w.x += 1.;\n                else if(length(w)<1.) CircleInversion(w);\n                else { break; }\n            }\n            color += j==0 || j==1 || j==2 ? vec3((j+1)%2,j,j%2) :vec3(flip);\n         } else if(length(w)<1.02){\n             color += vec3(1.);\n         }\n         \n    } \n    //Upper Half Plane Window\n    else{\n        vec2 dir = texelFetch( iChannel1, ivec2(0), 0 ).xy;    \n        vec2 resolution = vec2(iResolution.x*0.5, iResolution.y);\n        vec2 uv = cusp_zoom * 4.*fragCoord/resolution.x; uv.x -= 2.*cusp_zoom;\n\n\n        \n        if(length(z-uv) < 0.3){\n            if(length(z-uv) < 0.05)\n                color = vec3(1);\n            else{\n                //mat2 rot = mat2(0,1,-1,0);\n                float arrow = sdArrow( uv*40., z*40., z*40.-.3*dir*40., 0.1, 1. );\n                arrow = arrow <= 0.1 ? 1. : 0.;\n                color = vec3(arrow);     \n            }\n        }\n\n\n        float line_width = max(0.01, cusp_zoom*0.01);\n        int num_translates = 0;\n        for(int j = -num_translates; j<=num_translates; ++j){\n        vec2 st = uv + vec2(j,0);\n            if( abs(abs(st.x)-0.5) < line_width && length(st) >= 1.) \n                color = vec3(1);\n            else if(abs(length(st)-1.) < line_width) \n                color = vec3(1);\n        }\n       \n    }\n    \n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float pixel_per_unit = 100.;\n\n\n//Transformations\nmat2 e(){\n    return mat2(1,0,0,1);\n}\n\nvoid Rotate(inout mat2 A, in float theta){\n    mat2 k = mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n    A = k*A;\n}\n\nvoid Shear(inout mat2 A, in float s){\n    mat2 u = mat2(1,s,0,1);\n    A= u*A;\n}\nvoid ShearOpposite(inout mat2 A, in float s){\n    mat2 u = mat2(1,0,s,1);\n    A= u*A;\n}\n\nvoid Dilate(inout mat2 A, in float t){\n    mat2 a = mat2(t,0,0,1./t);\n    A= a*A;\n}\n\n\nvoid kan(inout mat2 k, inout mat2 A, inout mat2 n, in mat2 g)\n{\n    float a=g[0][0], b=g[1][0], c=g[0][1], d=g[1][1];\n    float t= sqrt(a*a+c*c);\n   \n    k[0] = vec2(a,c); k[1] = vec2(-c,a); k = k / t;\n    A=mat2(t,0,0,1./t);\n    n=mat2(1,(a*b+c*d)/(t*t),0,1);\n}\n\n\nvoid sl2inverse(inout mat2 g){\n    mat2 h = g;\n    g[0][0] = h[1][1];\n    g[1][1] = h[0][0];\n    g[1][0] = -h[1][0];\n    g[0][1] = -h[0][1];\n}\n\nvoid MoebiusAti(in mat2 g, inout vec2 z){//z=i -> di-b / -ci+a\n    sl2inverse(g);\n    float a=g[0][0], b=g[1][0], c=g[0][1], d=g[1][1];\n    z = vec2(a*c+b*d,1) / (c*c+d*d);\n}\n\nvoid Moebius(in mat2 g, inout vec2 z){// z -> az+b / cz+d  for a,b,c,d real\n    float a=g[0][0], b=g[1][0], c=g[0][1], d=g[1][1];\n    float x = a*c*dot(z,z)+b*d + (a*d+b*c)*z.x;\n    float y = z.y;\n    float denom = (c*c*dot(z,z)+d*d+2.*d*c*z.x);\n    z = vec2(x,y) / denom;\n    }\n    \n\nvoid ToHalfplane(inout vec2 z){// z -> -iz-i / z-1\n    float x=z[0], y=z[1];\n    float denom = x*x + y*y + 1. - 2.*x;\n    z = vec2(-2.*y, -x*x-y*y+1.) / denom;\n}\n\nvoid CircleInversion(inout vec2 z)\n{\n\tz.x = -z.x;\n\tz /= dot(z,z);\n}\n\nvoid HorizontalTranslation(inout vec2 z)\n{\n\tz.x = mod(z.x+0.5, 1.)-0.5;\n}\n\n\n\n\n//Lattice Reduction\n\nfloat ClosestInteger(float f)\n{\n    return floor(f+0.5);\n}\n\nvoid WeakReduce(inout mat2 A, inout mat2 gamma){\n    float mu = round( dot(A[0], A[1]) / dot(A[0],A[0]) );\n    A[1] -= mu * A[0];\n    mat2 u = mat2(1,-mu,0,1);\n    gamma = gamma*u;\n}\n\nvoid GramSchmidt(inout mat2 A){\n    float mu = dot(A[0], A[1]) / dot(A[0],A[0]);\n    A[1] -= mu * A[0];\n}\n\nvoid SwapColumns(inout mat2 A, inout mat2 gamma){\n     mat2 B = A;\n     A[0] = -B[1]; A[1] = B[0];\n     mat2 w = mat2(0,-1,1,0);\n     gamma = gamma*w;\n}\n\nbool IsReduced(in mat2 A){\n    GramSchmidt(A);\n    return dot(A[0],A[0]) <  4./3. * dot(A[1],A[1]);\n}\n\n\nvoid LLL(inout mat2 A, inout mat2 gamma){ //Lattice Reduction Algorithm\n    WeakReduce(A, gamma);\n    while(!IsReduced(A)){\n        SwapColumns(A, gamma);\n        WeakReduce(A, gamma);\n    }   \n}\n\n#define bug_fix 0.00001 \nvoid MakeShorter(inout mat2 A, inout mat2 gamma){ // Tries to find a shorter basis using at most one step.\n    if(dot(A[0],A[0]) > dot(A[1],A[1])+bug_fix) {\n        SwapColumns(A, gamma); \n        return;}    \n    mat2 B = A, C = A;\n    B[1] -=  B[0];\n    if(dot(A[1],A[1]) > dot(B[1],B[1])){ \n        A = B; \n        gamma = gamma*mat2(1,-1,0,1);\n        return;}\n    C[1] +=  C[0];\n    if(dot(A[1],A[1]) > dot(C[1],C[1])){\n        A = C;\n        gamma = gamma*mat2(1,1,0,1);\n        return;}\n}\n\n\n\n\nfloat DrawCircle(in vec2 uv, float radius){\n    return abs(length(uv)-radius) < 0.01 ? 1. : 0.;\n}\n\n\n\n\n\n\n\n\n\nvoid DrawPoint(inout vec3 color_out, in vec3 color_in, in vec2 pixel, in vec2 center, in float radius){\n    vec2 point = pixel-center;\n    if( dot(point, point) <= radius*radius){\n        color_out = color_in;\n    }\n}\n\n//Checks if \"point\" is closer to \"pixel\" compared to the currently closest points p1,p2.\nvoid ClosestPoints(inout vec2 p1, inout vec2 p2, inout float d1, inout float d2, in vec2 pixel, in vec2 point){\n    float d = distance(pixel, point);\n    if(d < d2){\n        if(d<d1){\n            d1 = d;\n            p1 = point;\n        }else{\n            d2 = d;\n            p2 = point;\n        }\n    }\n}\n\n\n\n\n\n\n\n// https://www.shadertoy.com/view/slj3Dd\n// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Distance to an arrow\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2 )\n{\n    const float k = 3.0;   // arrow head ratio\n\tvec2  ba = b - a;\n    float l2 = dot(ba,ba);\n    float l = sqrt(l2);\n\n    // pixel setup\n    p = p-a;\n    p = mat2(ba.x,-ba.y,ba.y,ba.x)*p/l;\n    p.y = abs(p.y);\n    vec2 pz = p-vec2(l-w2*k,w2);\n\n    // === distance (four segments) === \n\n    vec2 q = p;\n    q.x -= clamp( q.x, 0.0, l-w2*k );\n    q.y -= w1;\n    float di = dot(q,q);\n    //----\n    q = pz;\n    q.y -= clamp( q.y, w1-w2, 0.0 );\n    di = min( di, dot(q,q) );\n    //----\n    if( p.x<w1 ) // conditional is optional\n    {\n    q = p;\n    q.y -= clamp( q.y, 0.0, w1 );\n    di = min( di, dot(q,q) );\n    }\n    //----\n    if( pz.x>0.0 ) // conditional is optional\n    {\n    q = pz;\n    q -= vec2(k,-1.0)*clamp( (q.x*k-q.y)/(k*k+1.0), 0.0, w2 );\n    di = min( di, dot(q,q) );\n    }\n    \n    // === sign === \n    \n    float si = 1.0;\n    float z = l - p.x;\n    if( min(p.x,z)>0.0 ) //if( p.x>0.0 && z>0.0 )\n    {\n      float h = (pz.x<0.0) ? w1 : z/k;\n      if( p.y<h ) si = -1.0;\n    }\n    return si*sqrt(di);\n}\n\n", "buffer_a_code": "//Lattice Reduction (right ride)\n\nmat2 lattice = mat2(1,0,0,1);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0,0.0,0.0,1.0);\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/pixel_per_unit;\n    \n    if(fragCoord == vec2(0.5) || fragCoord == vec2(1.5)){\n        \n        if(iFrame > 1){\n            lattice[0] = texelFetch( iChannel0, ivec2(0), 0 ).xy;\n            lattice[1] = texelFetch( iChannel0, ivec2(0), 0 ).zw;\n        }\n    \n        \n        if( texelFetch(iChannel1,ivec2(65,0),0).x > 0.){            \n            Dilate(lattice, 1.01);\n        } \n        else if( texelFetch(iChannel1,ivec2(90,0),0).x > 0.){           \n            Dilate(lattice, 1./1.01);\n        }\n        else if( texelFetch(iChannel1,ivec2(83,0),0).x > 0.){            \n            Shear(lattice, 0.02);\n        } \n        else if( texelFetch(iChannel1,ivec2(88,0),0).x > 0.){            \n            Shear(lattice, -0.02);\n        }\n        else if( texelFetch(iChannel1,ivec2(68,0),0).x > 0.){            \n            Rotate(lattice, 0.05);\n        } \n        else if( texelFetch(iChannel1,ivec2(67,0),0).x > 0.){            \n            Rotate(lattice, -0.05);\n        }\n        else if( texelFetch(iChannel1,ivec2(70,0),0).x > 0.){            \n            ShearOpposite(lattice, 0.02);\n        } \n        else if( texelFetch(iChannel1,ivec2(86,0),0).x > 0.){            \n            ShearOpposite(lattice, -0.02);\n        }\n        \n        mat2 gamma = e();\n        LLL(lattice, gamma);\n        //MakeShorter(lattice, gamma);\n        \n        \n        if(fragCoord == vec2(0.5))\n            fragColor = vec4(lattice[0], lattice[1]);\n        else if(fragCoord == vec2(1.5))\n            fragColor = vec4(gamma[0], gamma[1]);\n    }\n     \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0,0,1,1);\n\n    if(fragCoord == vec2(0.5)){\n        mat2 lattice;\n        lattice[0] = texelFetch( iChannel0, ivec2(0), 0 ).xy;\n        lattice[1] = texelFetch( iChannel0, ivec2(0), 0 ).zw;\n        \n    \n        mat2 K,a,n;\n        kan(K,a,n,lattice);\n        \n        vec2 z;\n        MoebiusAti(lattice,z);\n           \n        fragColor = vec4((K*K)[1], z);\n\n    }\n              \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fllXzl.jpg", "access": "api", "license": "mit", "functions": [[1524, 1524, 1581, 1581, 5599]], "test": "untested"}
{"id": "ftlXWB", "name": "The Phantom Zone", "author": "P_Malin", "description": "A silly webcam filter I made for zoom etc. for use with Memix.", "tags": ["zoom", "memix"], "likes": 14, "viewed": 708, "published": 3, "date": "1626719607", "time_retrieved": "2024-07-30T19:10:18.869095", "image_code": "// The Phantom Zone\n// by @P_Malin\n// https://www.shadertoy.com/view/ftlXWB\n\n// A silly shader designed to work with Memix https://www.memix.app/\n// Save the shader as %LOCALAPPDATA%\\Beautypi\\Memix\\shader.txt\n\n// https://github.com/pmalin/pmalin-memix-shaders\n\n// Thanks for the following:\n// Dave Hoskins - hash function from https://www.shadertoy.com/view/4djSRW\n// iq - soft shadow from https://www.shadertoy.com/view/lsKcDD \n// iq - box intersection from https://iquilezles.org/articles/intersectors\n// iq - smooth min from https://iquilezles.org/articles/smin\n\n// Also see a similar shader from dean_the_coder: https://www.shadertoy.com/view/Wd2fzV\n\n#define RAYMARCH_ITER 32\n#define MAX_RAYMARCH_DIST 70.0\n#define SHADOW_STEPS 16\n\n\nvec3 boxDimensions = vec3(1,1,0.02);\nvec3 glassColour = vec3( 0.6, 0.84, 0.9 );\nfloat glassDensity = 40.0;\n\nvec3 sunDir = normalize(vec3(0.3, 0.5, -0.2));\nvec3 sunColor = vec3(1, 0.95, 0.9) * 1.7;\nvec3 ambientColor = vec3(0.3, 0.7, 1.0) * 1.0;\n\nfloat fogDensity= 0.00005;\nfloat fogHeightFalloff = 1.0;\n\nfloat sliceBegin = -3.5f;\nfloat sliceHeight = 1.0f;\n\n#define PI 3.1415925654\n\nvec3 RotateX( vec3 pos, float angle )\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return vec3( pos.x, c * pos.y + s * pos.z, -s * pos.y + c * pos.z);\n}\n\nvec3 RotateY( vec3 pos, float angle )\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return vec3( c * pos.x + s * pos.z, pos.y, -s * pos.x + c * pos.z);\n}\n\nvec3 RotateZ( vec3 pos, float angle )\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return vec3( c * pos.x + s * pos.y, -s * pos.x + c * pos.y, pos.z);\n}\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct CameraState\n{\n    vec3 pos;\n    vec3 target;\n    vec3 up;\n};\n\nmat3 GetCameraMatrix( CameraState cameraState )\n{\n    vec3 zDir = normalize(cameraState.target - cameraState.pos);    \n    vec3 xDir = normalize( cross( cameraState.up, zDir ) );\n    vec3 yDir = normalize( cross( zDir, xDir ) );\n    \n    mat3 mat = mat3( xDir, yDir, zDir );\n    \n    return mat;\n}\n\nRay GetCameraRay( vec2 coord, CameraState cameraState )\n{\n    vec3 viewDir = normalize(vec3( coord.xy, 1.0f ));\n    \n    mat3 mat = GetCameraMatrix( cameraState );\n    \n    Ray ray = Ray( cameraState.pos, mat * viewDir );\n    \n    return ray;\n}\n\n#define MAT_NONE -1\n#define MAT_DEFAULT 0\n#define MAT_QUAD 1\n\n\n// hash from https://www.shadertoy.com/view/4djSRW\n// Hash without Sine\n// by Dave_Hoskins\n\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n\nfloat SmoothNoise( vec2 o ) \n{\n\t//vec2 p = floor(o);\n\tvec2 f = fract(o);\n    vec2 p = o-f;\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = hash11(n+  0.0);\n\tfloat b = hash11(n+  1.0);\n\tfloat c = hash11(n+ 57.0);\n\tfloat d = hash11(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n    return res;\n}\n\nfloat CircleBomb( vec2 pos, float range )\n{   \n    float dist = MAX_RAYMARCH_DIST;\n    for(float yo=-range; yo<=range; yo+=1.0)\n    {\n        for(float xo=-range; xo<=range; xo+=1.0)\n        {\n            vec2 cellPos = pos + vec2(xo,yo);\n            vec2 cellIndex = floor(cellPos);\n            \n            vec3 hash = hash32( cellIndex );\n            \n            vec2 circleOffset = hash.xy * 0.5;\n            \n            vec2 circlePos = cellIndex + 0.5 + circleOffset;\n            \n            float circleRadius = hash.z * 0.5;\n            float circleDist = length( circlePos - pos ) - circleRadius;\n            \n            if ( circleDist < dist )\n            {\n                dist = circleDist;\n            }\n        }\n    }\n    \n    return dist;\n}\n\nfloat GetSlice( float h )\n{\n    return floor( (h-sliceBegin) / sliceHeight );\n}\n\nstruct RaymarchResult\n{\n\tfloat dist;\n\tint objectId;\n    vec3 uvw;\n};\n\nRaymarchResult Scene_GetDistance( vec3 pos );\n\nRaymarchResult Scene_Raymarch( Ray ray, float minDist, float maxDist )\n{\t\n    RaymarchResult result;\n    result.dist = 0.0;\n    result.uvw = vec3(0.0);\n    result.objectId = MAT_NONE;\n    \n\tfloat t = minDist;\n    \n\tfor(int i=0; i<RAYMARCH_ITER; i++)\n\t{\t\t\n        float epsilon = 0.000001 * t;\n\t\tresult = Scene_GetDistance( ray.pos + ray.dir * t );\n        if ( abs(result.dist) < epsilon )\n\t\t{\n\t\t\tbreak;\n\t\t}\n                        \n        if ( t > maxDist )\n        {\n            result.objectId = MAT_NONE;\n\t        t = maxDist;\n            break;\n        }       \n        \n        if ( result.dist > 1.0 )\n        {\n            result.objectId = MAT_NONE;\n        }    \n        \n        t += result.dist; \n\t}\n    \n    result.dist = max( t, minDist );\n\n\n    return result;\n}\n\n\nRaymarchResult Scene_Union( RaymarchResult a, RaymarchResult b )\n{\n    if ( b.dist < a.dist )\n    {\n        return b;\n    }\n    return a;\n}\n\nvec3 Scene_GetNormal(vec3 pos)\n{\n    const float fDelta = 0.0001;\n    vec2 e = vec2( -1, 1 );\n    \n    vec3 vNormal =\n        Scene_GetDistance( e.yxx * fDelta + pos ).dist * e.yxx + \n        Scene_GetDistance( e.xxy * fDelta + pos ).dist * e.xxy + \n        Scene_GetDistance( e.xyx * fDelta + pos ).dist * e.xyx + \n        Scene_GetDistance( e.yyy * fDelta + pos ).dist * e.yyy;\n    \n    return normalize( vNormal );\n} \n\nstruct TraceResult\n{\n\tfloat dist;\n\tint objectId;\n    vec3 uvw;\n    vec3 pos;    \n    vec3 normal;\n};\n\nvec3 BoxDomainRotate( vec3 pos );\nvec3 BoxDomainInvRotate( vec3 pos );\n\n\n// https://iquilezles.org/articles/intersectors\n// axis aligned box centered at the origin, with size boxSize\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}\n\n\nTraceResult Scene_Raytrace( Ray ray, float minDist, float maxDist )\n{\n    TraceResult result;\n    \n    result.dist = MAX_RAYMARCH_DIST;\n    result.objectId = MAT_NONE;\n\n    vec3 boxRayDir = BoxDomainRotate( ray.dir );\n    vec3 boxRayPos = BoxDomainRotate( ray.pos );    \n\n    vec2 t = boxIntersection( boxRayPos, boxRayDir, boxDimensions, result.normal);\n\n    result.normal = BoxDomainInvRotate( result.normal );\n\n    result.uvw = (boxRayPos + boxRayDir * t.x);\n\n    if ( t.x  >= 0.0 )\n    {\n        result.dist = t.x;\n        result.objectId = MAT_QUAD;\n    }\n    \n    return result;\n}\n\n\nTraceResult Scene_Trace( Ray ray, float minDist, float maxDist )\n{\n    TraceResult result;    \n\n    TraceResult raytraceResult = Scene_Raytrace( ray, minDist, maxDist );\n        \n    if (ray.dir.y >= 0.0 )\n    {\n        result.dist = MAX_RAYMARCH_DIST;\n        result.objectId = MAT_NONE;\n        result.normal = -ray.dir;\n        result.uvw = vec3(0);\n        result.pos = ray.pos + ray.dir * result.dist;\n    }\n    else\n    {\n        float yStart = sliceBegin;\n        \n        float t = (yStart - ray.pos.y) / ray.dir.y;\n        \n        if ( t > minDist )\n        {\n            minDist = t;\n        }\n        \n        RaymarchResult raymarchResult;\n        \n        raymarchResult = Scene_Raymarch( ray, minDist, maxDist );        \n\n        result.dist = raymarchResult.dist;\n        result.objectId = raymarchResult.objectId;\n        result.uvw = raymarchResult.uvw;\n        result.pos = ray.pos + ray.dir * result.dist;\n        result.normal = Scene_GetNormal( result.pos );     \n        \n    }\n        \n    if ( raytraceResult.dist < result.dist )\n    {\n        result.dist = raytraceResult.dist;\n        result.objectId = raytraceResult.objectId;\n        result.uvw = raytraceResult.uvw;\n        result.pos = ray.pos + ray.dir * result.dist;\n        result.normal = raytraceResult.normal;             \n    }\n\n    return result;\n}\n\nfloat Scene_TraceShadow( Ray ray, float minDist, float lightDist )\n{\n    // Soft Shadow Variation\n    // https://www.shadertoy.com/view/lsKcDD    \n    // based on Sebastian Aaltonen's soft shadow improvement\n    \n\tfloat res = 1.0;\n    float t = minDist;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n        \n    for( int i=0; i<SHADOW_STEPS; i++ )\n    {\n\t\tfloat h = Scene_GetDistance( ray.pos + ray.dir * t ).dist;\n\n        // use this if you are getting artifact on the first iteration, or unroll the\n        // first iteration out of the loop\n        //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d/max(0.0,t-y) );\n        ph = h;\n        \n        t += h;\n        \n        if( res < 0.0001 || t > lightDist ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );    \n}\n\nfloat Scene_GetAmbientOcclusion( Ray ray )\n{\n    float occlusion = 0.0;\n    float scale = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float fOffsetDist = 0.001 + 0.05*float(i)/4.0;\n        vec3 AOPos = ray.dir * fOffsetDist + ray.pos;\n        float dist = Scene_GetDistance( AOPos ).dist;\n        occlusion += (fOffsetDist - dist) * scale;\n        scale *= 0.46;\n    }\n    \n    return clamp( 1.0 - 30.0*occlusion, 0.0, 1.0 );\n}\n\nstruct SurfaceInfo\n{\n    vec3 pos;\n    vec3 normal;\n    vec3 albedo;\n    vec3 r0;\n    float gloss;\n    vec3 emissive;\n};\n    \nSurfaceInfo Scene_GetSurfaceInfo( Ray ray, TraceResult traceResult );\n\nstruct SurfaceLighting\n{\n    vec3 diffuse;\n    vec3 specular;\n};\n\nfloat Light_GIV( float dotNV, float k)\n{\n\treturn 1.0 / ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nfloat AlphaSqrFromGloss( float gloss )\n{\n\tfloat MAX_SPEC = 10.0;\n\treturn 2.0f  / ( 2.0f + exp2( gloss * MAX_SPEC) );\n}\n    \nvoid Light_Add( inout SurfaceLighting lighting, SurfaceInfo surface, vec3 viewDir, vec3 lightDir, vec3 lightColour )\n{\n\tfloat NDotL = clamp(dot(lightDir, surface.normal), 0.0, 1.0);\n\t\n\tlighting.diffuse += lightColour * NDotL;\n\n    if ( surface.gloss > 0.0 )\n    {\n        vec3 H = normalize( -viewDir + lightDir );\n        float NdotV = clamp(dot(-viewDir, surface.normal), 0.0, 1.0);\n        float NdotH = clamp(dot(surface.normal, H), 0.0, 1.0);\n\n        // D\n\n        float alphaSqr = AlphaSqrFromGloss( surface.gloss );\n        float alpha = sqrt( alphaSqr );\n        float denom = NdotH * NdotH * (alphaSqr - 1.0) + 1.0;\n        float d = alphaSqr / (PI * denom * denom);\n\n        float k = alpha / 2.0;\n        float vis = Light_GIV( NDotL, k ) * Light_GIV( NdotV, k );\n\n        float specularIntensity = d * vis * NDotL;    \n        lighting.specular += lightColour * specularIntensity;    \n    }\n}\n\nvoid Light_AddDirectional(inout SurfaceLighting lighting, SurfaceInfo surface, vec3 viewDir, vec3 lightDir, vec3 lightColour)\n{\t\n\tfloat attenuation = 1.0;\n    Ray shadowRay;\n    shadowRay.pos = surface.pos + surface.normal * 0.001;\n    shadowRay.dir = lightDir;\n\tfloat shadowFactor = Scene_TraceShadow( shadowRay, 0.01, 10.0 );\n\t\n\tLight_Add( lighting, surface, viewDir, lightDir, lightColour * shadowFactor * attenuation);\n}\n\nSurfaceLighting Scene_GetSurfaceLighting( Ray ray, SurfaceInfo surfaceInfo );\n\nvec3 Env_GetSkyColor( Ray ray );\n\nvec3 Light_GetFresnel( vec3 view, vec3 normal, vec3 r0, float gloss )\n{\n    float NdotV = max( 0.0, dot( view, normal ) );\n\n    return r0 + (vec3(1.0) - r0) * pow( 1.0 - NdotV, 5.0 ) * pow( gloss, 20.0 );\n}\n\nvec3 Env_ApplyAtmosphere( vec3 colour, Ray ray, float dist );\n\n\nvec3 Scene_GetColour( Ray ray )\n{\n\tvec3 resultColor = vec3(0.0);\n            \n\tTraceResult firstTraceResult;\n    \n    float startDist = 0.0f;\n    float maxDist = MAX_RAYMARCH_DIST;\n    \n    vec3 remaining = vec3(1.0);\n    \n\tfor( int passIndex=0; passIndex < 2; passIndex++ )\n    {\n    \tTraceResult traceResult = Scene_Trace( ray, startDist, maxDist );\n\n        if ( passIndex == 0 )\n        {\n            firstTraceResult = traceResult;\n        }\n        \n        vec3 colour = vec3(0);\n        vec3 reflectAmount = vec3(0);\n        \n\t\tif( traceResult.objectId < 0 )\n\t\t{\n            colour = Env_GetSkyColor( ray );\n\t\t\tcolour = Env_ApplyAtmosphere( colour, ray, traceResult.dist );\n        }\n        else\n        {\n            \n            SurfaceInfo surfaceInfo = Scene_GetSurfaceInfo( ray, traceResult );\n            SurfaceLighting surfaceLighting = Scene_GetSurfaceLighting( ray, surfaceInfo );\n                \n            if ( surfaceInfo.gloss <= 0.0 )\n            {\n                reflectAmount = vec3(0.0);\n            }\n            else\n            {\n                // calculate reflectance (Fresnel)\n                reflectAmount = Light_GetFresnel( -ray.dir, surfaceInfo.normal, surfaceInfo.r0, surfaceInfo.gloss );            \n            }\n\t\t\t\n\t\t\tcolour = (surfaceInfo.albedo * surfaceLighting.diffuse + surfaceInfo.emissive) * (vec3(1.0) - reflectAmount); \n            \n            vec3 reflectRayOrigin = surfaceInfo.pos;\n            vec3 reflectRayDir = normalize( reflect( ray.dir, surfaceInfo.normal ) );\n            startDist = 0.001 / max(0.0000001,abs(dot( reflectRayDir, surfaceInfo.normal ))); \n\n            colour += surfaceLighting.specular * reflectAmount;            \n\n\t\t\tcolour = Env_ApplyAtmosphere( colour, ray, traceResult.dist );\n            \n            ray.pos = reflectRayOrigin;\n            ray.dir = reflectRayDir;\n        }\n        \n        resultColor += colour * remaining;\n        remaining *= reflectAmount;                \n        \n        if ( (remaining.x + remaining.y + remaining.z) < 0.01 )\n        {\n            break;\n        }            \n    }\n \n    return vec3( resultColor );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec3 BoxDomainRotate( vec3 pos )\n{\n    pos = RotateX( pos, iTime );\n    pos = RotateZ( pos, 0.5 );\n    \n    return pos;\n}\n\nvec3 BoxDomainInvRotate( vec3 pos )\n{\n    pos = RotateZ( pos, -0.5 );\n    pos = RotateX( pos, -iTime );\n    \n    return pos;\n}\n\n// https://iquilezles.org/articles/smin\n// polynomial smooth min (k = 0.1);\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nRaymarchResult Scene_GetDistance( vec3 pos )\n{\n    RaymarchResult landscapeResult;\n    landscapeResult.dist = 100000.0;\n    landscapeResult.uvw = pos.xzy;\n    landscapeResult.objectId = MAT_DEFAULT;\n    \n    \n    vec3 landscapeDomain = pos + vec3(30.3,0,iTime);\n    \n    float scale = 10.0;\n    \n    float circleDist = CircleBomb(landscapeDomain.xz / scale, 2.0) * scale;\n\n    circleDist -= CircleBomb(landscapeDomain.xz * 3.0, 1.0) * 0.3;\n\n    float bump = SmoothNoise(landscapeDomain.xz * 5.0) * 0.1;\n\n    float sliceCount = 2.0;\n\n    for ( float slice = 0.0; slice >= -(sliceCount-1.0); slice -= 1.0 )\n    {\n        float sliceDist = circleDist + (slice) * .1 * scale - 1.0;    \n            \n        float sliceY = -slice * slice * sliceHeight + sliceBegin - bump; \n    \n        sliceDist = -sminCubic( -sliceDist, (sliceY - landscapeDomain.y), 0.5 );\n            \n        landscapeResult.dist = sminCubic( landscapeResult.dist, sliceDist, 0.5 );\n    }\n    \n    landscapeResult.dist = sminCubic( landscapeResult.dist, pos.y - (-sliceCount * sliceHeight + sliceBegin) - bump, 0.5 );    \n    \n    RaymarchResult result = landscapeResult;\n\n\n    return result;\n}\n\nSurfaceInfo Scene_GetSurfaceInfo( Ray ray, TraceResult traceResult )\n{\n    SurfaceInfo surfaceInfo;\n    \n    surfaceInfo.pos = traceResult.pos;\n    surfaceInfo.normal = traceResult.normal;\n    \n    surfaceInfo.albedo = vec3(1.0);\n    surfaceInfo.r0 = vec3( 0.02 );\n    surfaceInfo.gloss = 0.0;\n    surfaceInfo.emissive = vec3( 0.0 );\n        \n    if ( traceResult.objectId == MAT_DEFAULT )\n    {\n        surfaceInfo.albedo = vec3(0.95, 0.95, 0.95); \n\t    surfaceInfo.gloss = 0.0;\n    \tsurfaceInfo.r0 = vec3( 0.02 );\n    }\n    \n    if ( traceResult.objectId == MAT_QUAD )\n    {\n        surfaceInfo.albedo = vec3(0);\n\t    surfaceInfo.gloss = 0.9;\n    \tsurfaceInfo.r0 = vec3( 0.02 );\n        \n        \n        vec3 dir = refract( ray.dir, surfaceInfo.normal, 1.0 / 1.33 );\n        \n        vec3 boxRayDir = BoxDomainRotate( normalize( dir ) ) / (boxDimensions);\n        vec3 boxRayPos = traceResult.uvw / (boxDimensions);\n\n        vec3 h = -(boxRayPos - sign(boxRayDir)) / boxRayDir;\n        float t = min(min(h.x, h.y), h.z);\n        \n        vec3 p = boxRayPos + boxRayDir * t;\n\n\n        vec2 uv = p.xy;\n        float d = length( boxRayDir * t * boxDimensions );\n        \n        uv = uv * 0.5 + 0.5;\n        \n        ivec2 tSize = textureSize(iChannel0, 0);\n        uv = uv - 0.5;\n        if ( tSize.x > tSize.y )\n        {\n            uv.x *= float(tSize.y) / float(tSize.x);\n        }\n        else\n        {\n            uv.y *= float(tSize.x) / float(tSize.y);\n        }\n        uv = uv + 0.5;\n        \n        vec3 emissiveSample = texture( iChannel0, uv ).rgb;\n        surfaceInfo.emissive = emissiveSample * emissiveSample;\n\n        surfaceInfo.emissive *= exp( -d * (1.0 - glassColour) * glassDensity );                      \n    }   \n    \n    return surfaceInfo;    \n}\n\nvec3 Env_GetSkyColor( Ray ray )\n{\n    return vec3(0.0);\n}\n\nSurfaceLighting Scene_GetSurfaceLighting( Ray ray, SurfaceInfo surfaceInfo )\n{   \n    SurfaceLighting surfaceLighting;\n    \n    surfaceLighting.diffuse = vec3(0.0);\n    surfaceLighting.specular = vec3(0.0);    \n    \n    Light_AddDirectional( surfaceLighting, surfaceInfo, ray.dir, sunDir, sunColor );\n    \n    \n    Ray aoRay;\n    aoRay.pos = surfaceInfo.pos;\n    aoRay.dir = surfaceInfo.normal;\n    float fAO = Scene_GetAmbientOcclusion(aoRay);    \n    surfaceLighting.diffuse += fAO * (surfaceInfo.normal.y * 0.5 + 0.5) * ambientColor;\n    \n    return surfaceLighting;\n}\n\nfloat Env_GetFogFactor( Ray ray, float dist )\n{    \n\n    float fogAmount = fogDensity * exp(-ray.pos.y*fogHeightFalloff) * (1.0-exp(-dist*ray.dir.y*fogHeightFalloff ))/ray.dir.y;\n    \n\treturn exp(dist * -fogAmount);\t    \n}\n\nvec3 Env_GetFogColour(Ray ray)\n{    \n\treturn vec3(0.1, 0.35, 0.9);\n}\n\nvec3 Env_ApplyAtmosphere( vec3 colour, Ray ray, float dist )\n{\n    vec3 result = colour;\n        \n\tfloat fogFactor = Env_GetFogFactor( ray, dist );\n\tvec3 fogColor = Env_GetFogColour( ray );\n    result = mix( fogColor, result, fogFactor );\n\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 coord = uv - 0.5;\n    coord.x *= iResolution.x / iResolution.y;\n    \n    CameraState camera;\n\n    camera.pos = vec3(0,-0.3,-3);\n    camera.target = vec3(0,0.1,0);\n    camera.up = vec3(0,1,0);\n\n    camera.pos = RotateY( camera.pos, sin(iTime * 0.1) * 0.3 );\n    \n    camera.pos *= (sin( iTime * 0.234 ) * 0.5 + 0.5) * 1.0 + 1.0;\n    \n    Ray ray = GetCameraRay( coord, camera );\n    \n    vec3 sceneColour = Scene_GetColour( ray );\n    \n    vec3 colour = sceneColour;\n    \n    colour = 1.0f - exp( -colour * 1.0 );\n    \n    colour = pow( colour, vec3(1.0f / 2.2f) );\n    \n    fragColor = vec4(colour, 1.0f);\n}\n", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftlXWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1118, 1118, 1157, 1157, 1288], [1290, 1290, 1329, 1329, 1460], [1462, 1462, 1501, 1501, 1632], [1748, 1748, 1797, 1797, 2045], [2047, 2047, 2104, 2104, 2291], [2448, 2467, 2490, 2490, 2575], [2577, 2596, 2617, 2617, 2753], [2756, 2756, 2786, 2808, 3170], [3172, 3172, 3215, 3215, 3933], [3935, 3935, 3962, 3962, 4014], [4133, 4133, 4205, 4205, 4910], [4913, 4913, 4979, 4979, 5052], [5054, 5054, 5086, 5086, 5473], [5651, 5761, 5844, 5844, 6322], [6325, 6325, 6394, 6394, 6911], [6914, 6914, 6980, 6980, 8251], [8253, 8253, 8321, 8460, 9140], [9142, 9142, 9186, 9186, 9573], [9838, 9838, 9878, 9878, 9928], [9930, 9930, 9970, 9970, 10048], [10054, 10054, 10172, 10172, 10959], [10961, 10961, 11088, 11088, 11385], [11500, 11500, 11571, 11571, 11706], [11772, 11772, 11805, 11805, 13907], [13909, 13909, 13940, 13940, 14031], [14033, 14033, 14067, 14067, 14154], [14156, 14156, 14193, 14193, 14282], [14284, 14360, 14406, 14406, 14492], [14494, 14494, 14540, 14540, 15655], [15657, 15657, 15727, 15727, 17432], [17434, 17434, 17467, 17467, 17491], [17493, 17493, 17571, 17571, 18064], [18066, 18066, 18113, 18113, 18288], [18290, 18290, 18322, 18322, 18358], [18360, 18360, 18422, 18422, 18620], [18622, 18622, 18679, 18679, 19341]], "test": "untested"}
{"id": "sllSWX", "name": "Domain expansion:Unlimited Void ", "author": "yasuo", "description": "jujutsu kaisen", "tags": ["cubemap", "reproduction"], "likes": 3, "viewed": 313, "published": 3, "date": "1626716365", "time_retrieved": "2024-07-30T19:10:19.636045", "image_code": "#define USE_MOUSE 0\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\n// noise and fbm function from https://www.shadertoy.com/view/Xd3GD4\n//-----------------------------------------------------------------------------\nvec2 hash( vec2 p ){\n    p = vec2( dot(p,vec2(127.1,311.7)),\n             dot(p,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat noise2d( in vec2 p ){\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n    \n    vec2 i = floor( p + (p.x+p.y)*K1 );\n    \n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0*K2;\n    \n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n    \n    vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    \n    return dot( n, vec3(70.0) );\n}\nfloat fbm(vec2 uv){\n    float f;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*noise2d( uv ); uv = m*uv;\n    f += 0.2500*noise2d( uv ); uv = m*uv;\n    f += 0.1250*noise2d( uv ); uv = m*uv;\n    f += 0.0625*noise2d( uv ); uv = m*uv;\n    f = 0.5 + 0.5*f;\n    return f;\n}\n\nvec3 tex(in vec2 p)\n{\n    vec2 prevP = p;\n    p+=iTime*0.15;\n    \n    float n = fbm(p*2.7)*0.6;\n    vec3 col = vec3(0.0,0.0,0.2)+n*0.7;\n    \n    p = prevP;\n    float d = length(p)-0.35;\n    \n    d = length(p)-0.35;\n    col = mix(col,vec3(1.2),S(abs(d*(n*3.0))-0.15,-0.3));\n    \n    d = length(p)-0.35;\n    col = mix(col,vec3(0.7),S(abs(d)-0.07,-0.2));\n    \n    p = prevP;\n    p.y=-abs(p.y);\n    col = mix(col,vec3(1,0.9,0.6),S(abs(d)-0.01+sin(p.y*3.0)*0.02,-0.05));\n    \n    p = prevP;\n    p*=Rot(radians(iTime*30.0));\n    p.y=abs(p.y);\n    col = mix(col,vec3(1),S(abs(d)-0.005+sin(p.y*3.0)*0.005,-0.005));\n    \n    p = prevP;\n    p*=Rot(radians(iTime*25.0));\n    p.x+=iTime*0.1;\n    float n2 = fbm(p*4.0)*0.15;\n    p = prevP;\n    d = length(p)-0.16;\n    col = mix(col,vec3(1.0),S(d*n2*0.3,0.0));\n    \n    p = prevP;\n    d = length(p)-0.15;\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    p = prevP;\n    \n    p+=iTime*0.1;\n    \n    float n1 = noise2d(p*0.6)+fbm(p*5.5);\n    col = mix(col,col*vec3(2.7),S(n1,0.0));\n    col = mix(col,col*vec3(1.5),S(abs(n1)-0.01,0.0));\n    p-=vec2(0.8);\n    n1 = noise2d(p*0.7)+fbm(p*7.5);\n    col = mix(col,col*vec3(2.85),S(n1,0.0));\n    col = mix(col,col*vec3(1.5),S(abs(n1)-0.01,0.0));\n    p+=vec2(2.8);\n    n1 = noise2d(p*0.8)+fbm(p*9.5);\n    col = mix(col,col*vec3(2.675),S(n1,0.0));\n    col = mix(col,col*vec3(1.5),S(abs(n1)-0.01,0.0));\n    \n    p = prevP;\n    p*=20.0;\n    vec2 grid = abs(fract(p - 0.5) - 0.5) / fwidth(p);\n    float line = min(grid.x, grid.y);\n    float gridd = 1.0 - min(line, 1.0);\n    col = mix(col,col*vec3(0.675),S(gridd,0.0));\n\n    return col;\n}\n\n// cube mapping technique from @nimitz https://www.shadertoy.com/view/4sjXW1\nvec3 cubeproj(in vec3 p)\n{\n    vec3 x = tex(p.zy/p.x);\n    vec3 y = tex(p.xz/p.y);\n    vec3 z = tex(p.xy/p.z);\n    \n    //select face\n    p = abs(p);\n    if (p.x > p.y && p.x > p.z) return x;\n    else if (p.y > p.x && p.y > p.z) return y;\n    else return z;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n   \n    vec3 ro = vec3(0, 0, -1.0);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(sin(-iTime*.2)*0.3);\n    ro.xz *= Rot(-iTime*.3+1.0);\n    #endif\n   \n    vec3 rd = R(uv, ro, vec3(0,0,0), 1.0);\n    vec3 col = cubeproj(rd);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sllSWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[179, 328, 348, 348, 482], [483, 483, 510, 510, 1013], [1014, 1014, 1033, 1033, 1295], [1297, 1297, 1318, 1318, 2905], [2907, 2984, 3010, 3010, 3243], [3245, 3245, 3287, 3287, 3482], [3484, 3484, 3541, 3541, 3967]], "test": "untested"}
{"id": "flsSWf", "name": "/polder/flight", "author": "_fov", "description": "somewhat akin a flight over a polder landscape", "tags": ["grid", "abstract", "polder"], "likes": 1, "viewed": 168, "published": 3, "date": "1626707523", "time_retrieved": "2024-07-30T19:10:20.398008", "image_code": "const vec2 cell_size = 1. / vec2(3., 10.);\nconst float diagonal_slope = 0.45;\nconst float diagonal_offset = 0.6;\n\nfloat hash1( uint n ) \n{\n    // integer hash copied from Hugo Elias\n    // implementation copied from https://www.shadertoy.com/view/llGSzw\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec4 image(vec2 uv)\n{\n    uv.y = 2.+uv.y;\n    vec2 cell_uv;\n    vec2 cell_fraction = modf(uv / cell_size, cell_uv);\n    cell_uv = cell_uv * cell_size;\n\n\n    // horizontal lines\n    bool h = (abs(cell_fraction.y -.5)>0.4275);\n\n    // vertical lines\n    float tex = hash1(uint(cell_uv.y * 20. + (cell_uv.x + floor(uv.x))* 20.));\n\n    float v_offset = 0.5 + tex /2.;\n    float cell_d_x = diagonal_offset + (1.0 - cell_uv.y) * diagonal_slope;\n    bool v = abs(cell_fraction.x - v_offset)<0.045;\n\n    if(cell_fraction.x > v_offset)\n    {\n        cell_uv.x += cell_size.x;\n        tex = hash1(uint(cell_uv.y * 20. + (cell_uv.x + floor(uv.x + cell_size.x))* 20.));\n    }\n\n    // diagonal line\n    float patch_slope = diagonal_slope * (hash1(uint(uv.x))-.5);\n    bool d = abs(diagonal_offset - fract(uv.x) + patch_slope * (1.0 - uv.y)) < 0.03;\n\n    vec3 col = h || v || d ? vec3(0.0) : vec3(tex);\n\n    return vec4(col,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // dirty zoom\n    uv += 0.5;\n    uv *= 0.5;\n    \n    // basic perspective from https://www.shadertoy.com/view/ttscW2\n    float coeff =0.25 *sin(iTime/5.)+0.75;\n    \n    uv.x -= 0.5f;\n\tuv.x /= (1.0 - uv.y * coeff);\n    uv.y /= (1.0 - uv.y * coeff);\n   \n    uv.y += iTime/10.;\n    uv.x += sin(iTime/5.)/10.;\n    // Output to screen\n    fragColor = image(uv.yx);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flsSWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 114, 138, 253, 391], [393, 393, 414, 414, 1310], [1312, 1312, 1369, 1419, 1825]], "test": "untested"}
{"id": "ftlSDf", "name": "New retro wave", "author": "Citiral", "description": "Simple shader to emulate the new retro wave 'laser grid' style, with distortion.", "tags": ["simple", "wave", "retro", "laser"], "likes": 0, "viewed": 362, "published": 3, "date": "1626707211", "time_retrieved": "2024-07-30T19:10:21.161965", "image_code": "float line(float p, float l, float w)\n{\n\treturn max(distance(p, l) - w, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\tp.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 r = normalize(vec3(p.x - iResolution.x / iResolution.y * 0.5, -1, p.y - 0.5));\n\t\n\tr.x += tan(iTime+sin(p.y))*0.01;\n\tr.z += sin(iTime*4.01+r.x*2.0)*0.005;\n\t\n\tif (r.z <= 0.0) {\n        vec2 sp = mod(r.xy / r.z, 1.0);\n\t\tfloat d = line(sp.x, 0.0, 0.01) *\n                  line(sp.y, 0.0, 0.01) *\n                  line(sp.x, 1.0, 0.01) *\n                  line(sp.y, 1.0, 0.01);\n\n\t\tfragColor.rgb = (1.0-pow(d, 0.06)) * vec3(0.3, 1, 0.2);\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftlSDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 79], [81, 81, 138, 138, 668]], "test": "untested"}
{"id": "NtsXWX", "name": "Hippy Flip", "author": "xenn", "description": "Check mouse! \n\nhttps://xemantic.github.io/shader-web-background/\n \nGoal: shadertoy-style shaders in regular web development\n", "tags": ["mouse", "background", "shadertoy", "feedback", "integration", "library", "web", "webdevelopment", "webdev", "javascript"], "likes": 24, "viewed": 802, "published": 3, "date": "1626693127", "time_retrieved": "2024-07-30T19:10:22.119405", "image_code": "// Forked up shit of \"Pleasant Yonic\" by xenn. https://shadertoy.com/view/ftsSWX\n// 2021-07-19 11:02:27\n\n\n#define AB_SCALE 0.95\n\nvec2 displace(vec2 uv, vec2 offset)\n{   \n    float d = smoothstep(0.2,2.0,texture(iChannel1, (uv*1.0 - vec2(iTime /8.0,0)) + offset).r) * 0.25;\n    \n    return vec2(d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 dr = displace(uv, vec2(0   , 0.02) * AB_SCALE),\n         dg = displace(uv, vec2(0.01, 0.01) * AB_SCALE),\n         db = displace(uv, vec2(0.01, 0   ) * AB_SCALE);\n    \n    vec3 color = vec3(0);\n    color += vec3(1, 0, 0)*texture(iChannel0, uv - dr).r;\n    color += vec3(0, 1, 0)*texture(iChannel0, uv - dg).g;\n    color += vec3(0, 0, 1)*texture(iChannel0, uv - db).b;\n    \n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 p = fragCoord.xy;\n    \n    vec2 uv = (p.xy) / iResolution.xy;\n    \n    //line thickness\n    float th = 0.002;\n    \n    //gradient detection for r,g and b separatly\n    //not sure why I did this actually\n    \n    float gxr = texture(iChannel0, uv.xy+vec2(th, 0.)).r\n    - texture(iChannel0, uv.xy-vec2(th, 0.)).r ;\n    \n    float gyr = texture(iChannel0, uv.xy+vec2(0., th)).r\n    - texture(iChannel0, uv.xy-vec2(0., th)).r;\n    \n    float gxg = texture(iChannel0, uv.xy+vec2(th, 0.)).g\n    - texture(iChannel0, uv.xy-vec2(th, 0.)).g ;\n    \n    float gyg = texture(iChannel0, uv.xy+vec2(0., th)).g\n    - texture(iChannel0, uv.xy-vec2(0., th)).g;\n    \n    float gxb = texture(iChannel0, uv.xy+vec2(th, 0.)).b\n    - texture(iChannel0, uv.xy-vec2(th, 0.)).b;\n    \n    float gyb = texture(iChannel0, uv.xy+vec2(0., th)).b\n    - texture(iChannel0, uv.xy-vec2(0., th)).b;\n    \n    //hack to concea noise from: https://www.shadertoy.com/view/Mdf3zr\n    float gr = gxr*gxr + gyr*gyr;\n    float gg = gxg*gxg + gyg*gyg;\n    float gb = gxb*gxb + gyb*gyb;\n    \n    //more noise control\n    float g = pow((gr+gg+gb)/1.,1.9);\n    \n    \n    vec3 col = texture(iChannel0, p / iResolution.xy).xyz;\n    col = mix(col,  0.5 + 0.5*cos(iTime*4.+uv.y*6.+vec3(0,2,4)),g*100.);\n    \n    fragColor = vec4(col,1.);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n//#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "buffer_b_code": "                                                                                                                                                                                                                                                                                        // See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .001;\nconst float iFeedbackFadeRate         = .993;\nconst float iFeedbackColorShiftZoom   = 0.1;\nconst float iFeedbackColorShiftImpact = -0.00233;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = .975;\nconst float iBlobEdgeSmoothing        = .09;\nconst float iBlob1Radius              = .33;\nconst float iBlob1PowFactor           = 20.;\nconst float iBlob1ColorPulseSpeed     = .032;\nconst float iBlob2Radius              = .66;\nconst float iBlob2PowFactor           = 30.;\nconst float iBlob2ColorPulseSpeed     = .01234;\nconst float iBlob2ColorPulseShift     = 2.5;\nconst float iColorShiftOfRadius       = 2.;\nconst float iFeedbackMouseShiftFactor = .003;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.bg/colorShift.gr - .5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel2, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n   \n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// hueshifter but better https://www.youtube.com/watch?v=CXXmZiVXCxY\n\n#define SWAY 0.01\n#define BLURSTRENGTH 1.0\n\nconst int samples = 35,\n          LOD = 2,         // gaussian done on MIPmap at scale LOD\n          sLOD = 1 << LOD; // tile size = 2^LOD\nconst float sigma = float(samples) * .2;\n\nfloat gaussian(vec2 i) {\n    return exp( -.5* dot(i/=sigma,i) ) / ( 6.28 * sigma*sigma );\n}\n\nvec4 blur(sampler2D sp, vec2 U, vec2 scale) {\n    vec4 O = vec4(0);  \n    int s = samples/sLOD;\n    \n    for ( int i = 0; i < s*s; i++ ) {\n        vec2 d = vec2(i%s, i/s)*float(sLOD) - float(samples)/2.;\n        O += gaussian(d) * textureLod( sp, U + scale * d , float(LOD) );\n    }\n    \n    return O / O.a;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 swayuv = uv * 1.0 + sin(iTime * 0.5) * SWAY;\n    vec3 col = texture(iChannel0,swayuv).rgb;\n    vec3 blur = blur(iChannel0,uv, 1./iChannelResolution[0].xy ).rgb;\n    blur *= BLURSTRENGTH;\n    // col += blur * 0.5;\n    bool chroma_shift = false;\n    if (chroma_shift) {\n        swayuv.x += 0.01;\n        col.r *= texture(iChannel0,swayuv).r;\n        swayuv.x -= 0.02;\n        col.b *= texture(iChannel0,swayuv).b;\n    }\n    col = max(col,blur);\n    fragColor = vec4(col,1.0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Fork of \"spirit aura\" by xenn. https://shadertoy.com/view/7lSGzR\n// 2021-06-21 18:20:40\n\n/*\n\tFull Scene Radial Blur\n\t----------------------\n\n\tRadial blur - as a postprocessing effect - is one of the first things I considered doing \n\twhen the multipass system came out. I've always loved this effect. Reminds me of the early \n\tdemos from Aardbei et al. \n\n\tAnyway, Shadertoy user, Passion, did a really cool radial blur on a field of spheres that\n\tinspired me to do my own. Radial blurs are pretty straight forward, but it was still\n    helpful to have Passion's version as a guide. \n\n    As for the radial blur process, there's not much to it. Start off at the pixel position, \n    then radiate outwards gathering up pixels with decreased weighting. The result is a\n\tblurring of the image in a radial fashion, strangely enough. :)\n\n\tInspired by:\n\n\tBlue Dream - Passion\n\thttps://www.shadertoy.com/view/MdG3RD\n\n\tRadial Blur - IQ\n\thttps://www.shadertoy.com/view/4sfGRn\n\n\tRays of Blinding Light - mu6k\n\thttps://www.shadertoy.com/view/lsf3Dn\n\n*/\n\n// The radial blur section. Shadertoy user, Passion, did a good enough job, so I've used a\n// slightly trimmed down version of that. By the way, there are accumulative weighting \n// methods that do a slightly better job, but this method is good enough for this example.\n\n\n// Radial blur samples. More is always better, but there's frame rate to consider.\nconst float SAMPLES = 128.; \n\n\n// 2x1 hash. Used to jitter the samples.\nfloat hash( vec2 p ){ return fract(sin(dot(p, vec2(41, 289)))*45758.5453); }\n\n\n// Light offset.\n//\n// I realized, after a while, that determining the correct light position doesn't help, since \n// radial blur doesn't really look right unless its focus point is within the screen boundaries, \n// whereas the light is often out of frame. Therefore, I decided to go for something that at \n// least gives the feel of following the light. In this case, I normalized the light position \n// and rotated it in unison with the camera rotation. Hacky, for sure, but who's checking? :)\nvec3 lOff(){    \n    \n    vec2 u = sin(vec2(1.57, 0) - iTime/2.);\n    mat2 a = mat2(u, -u.y, u.x);\n    \n    vec3 l = normalize(vec3(1.5, 1., -0.5));\n    l.xz = a * l.xz;\n    l.xy = a * l.xy;\n    \n    return l;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // Screen coordinates.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Radial blur factors.\n    //\n    // Falloff, as we radiate outwards.\n    float decay = 0.597; \n    // Controls the sample density, which in turn, controls the sample spread.\n    float density = 0.725; \n    // Sample weight. Decays as we radiate outwards.\n    float weight = 0.1; \n    \n    // Light offset. Kind of fake. See above.\n    vec3 l = lOff();\n    \n    // Offset texture position (uv - .5), offset again by the fake light movement.\n    // It's used to set the blur direction (a direction vector of sorts), and is used \n    // later to center the spotlight.\n    //\n    // The range is centered on zero, which allows the accumulation to spread out in\n    // all directions. Ie; It's radial.\n    vec2 tuv =  uv - .5 - l.xy*.45;\n    \n    // Dividing the direction vector above by the sample number and a density factor\n    // which controls how far the blur spreads out. Higher density means a greater \n    // blur radius.\n    vec2 dTuv = tuv*density/SAMPLES;\n    \n    // Grabbing a portion of the initial texture sample. Higher numbers will make the\n    // scene a little clearer, but I'm going for a bit of abstraction.\n    vec4 col = texture(iChannel0, uv.xy)*0.5;\n    \n    // Jittering, to get rid of banding. Vitally important when accumulating discontinuous \n    // samples, especially when only a few layers are being used.\n    uv += dTuv*(hash(uv.xy + fract(iTime))*2. - 1.);\n    \n    // The radial blur loop. Take a texture sample, move a little in the direction of\n    // the radial direction vector (dTuv) then take another, slightly less weighted,\n    // sample, add it to the total, then repeat the process until done.\n    for(float i=0.; i < SAMPLES; i++){\n    \n        uv -= dTuv;\n        col += texture(iChannel1, uv) * weight * col, uv;\n        weight *= decay;\n        \n    }\n    \n    // Multiplying the final color with a spotlight centered on the focal point of the radial\n    // blur. It's a nice finishing touch... that Passion came up with. If it's a good idea,\n    // it didn't come from me. :)\n    col *= (1. - dot(tuv, tuv)*.75);\n    \n    // Smoothstepping the final color, just to bring it out a bit, then applying some \n    // loose gamma correction.\n    fragColor = sqrt(smoothstep(0., 1., col));\n    \n    // Bypassing the radial blur to show the raymarched scene on its own.\n    //fragColor = sqrt(texture(iChannel0, fragCoord.xy / iResolution.xy));\n}\n\n", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsXWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 129, 166, 166, 299], [301, 301, 356, 356, 815]], "test": "untested"}
{"id": "ftfSWH", "name": "Bamboo Forest", "author": "will7007", "description": "A gray bamboo forest based off of the Arashiyama Bamboo Forest and the bamboo forest near the fox shrine that I visited while in Japan.", "tags": ["raymarching", "forest", "bamboo"], "likes": 4, "viewed": 282, "published": 3, "date": "1626660198", "time_retrieved": "2024-07-30T19:10:22.886355", "image_code": "// Fork of \"Donut factory\" by anclin. https://shadertoy.com/view/MsffDS\n// 2021-07-05 22:22:34\n\n// I was going to make things much more complex with crepuscular rays, textures, curving bamboo\n// trunks, and moving leaves (among other things), but I wanted to have a \"good enough\" version to\n// wrap things up and just get this thing out the door!\n\nconst float EPSILON = 0.001;\n\nconst vec3 leafColorDark = vec3(0x58, 0x66, 0x0f)/255.;\nconst vec3 leafColorLight = vec3(0xc0, 0xc0, 0x6e)/255.;\nconst vec3 trunkColor = vec3(0xb1, 0xb5, 0xb1)/255.;\n\n// credit to iq for making these SDF transforms/shapes\nfloat opExtrussion(in vec3 p, in float sdf, in float h) {\n    vec2 w = vec2( sdf, abs(p.y) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat sdCircle( vec2 p, float r ) {\n    return length(p) - r;\n}\n\nfloat bamboo(vec3 origin, float height, float radius) {\n  float radiusBumpy = max(-.02*abs(sin(10.*origin.y))+radius,radius-.002);\n  origin.y -= clamp(origin.y, 0.0, height);\n  return length(origin) - radiusBumpy;\n}\n\nfloat leaves(vec3 origin, float h, float distortion) {\n    // don't look too closely at these crazy, distorted \"leaves\"!\n    origin.y -= h;\n    float c = opExtrussion( origin, sdCircle( vec2(origin.x,origin.z), .5 ), 0.6 );\n    return c-.7*sin(distortion*origin.x)*sin(distortion*origin.y)*sin(distortion*origin.z);\n}\n\nvec2 N22(vec2 p) {\n    vec3 a = fract(p.xyx*vec3(123.34,234.34,345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y,a.y*a.z));\n}\n\nfloat SceneSDF(vec3 p){\n    //p = rotateY(iTime * 0.2) * p;\n    float smallest = 5.;\n    float d = 100.;\n    vec3 xyz = fract(p);  // point within a grid cell\n    xyz.y = p.y;  // we want the absolute y position in the grid cell for correctly calculating notches\n    vec2 id = floor(p.xz);  // the grid cell we are in\n    \n    for(float y=-1.; y <= 1.; y++) {  // look at the neighboring cells\n        for(float x=-1.; x <= 1.; x++) {  // to see which cell has a point that is the closest to our pixel\n            vec2 off = vec2(x, y);\n            vec2 coord = id+off;\n            vec2 n = N22(id+off);\n            \n            // calculate the point, then add the offset to it\n            // so that the point is moved into its own grid cell\n            // this is the origin for the purposes of this grid cell (i.e. the place where the bamboo trunk is centered)\n            // and xyz is the pixel where we are, so we measure from xyz->point since we want to know dist from point->origin\n            vec2 point = off+n;\n            \n            // dist between Voronoi point and current pixel RELATIVE TO GRID\n            // because the point is created relative to the grid\n            // so there won't be any Voronois if uv goes too far from the origin\n            vec3 gridCenter = vec3(xyz.x-point.x,xyz.y,xyz.z-point.y);\n            \n            d = bamboo(vec3(gridCenter),20.,.05);\n            d = min(d,leaves(gridCenter,21.9,20.));\n            \n            smallest = (d < smallest) ? d : smallest;\n        }\n    }\n    return smallest;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        SceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - SceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        SceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - SceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        SceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - SceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 RayDirection(float fieldOfView, vec2 fragCoord, vec2 size){\n\tvec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec4 ShortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end){\n\tfloat depth = start;\n\tvec3 pos = eye;\n    for(int i = 0; i < 255; i++){\n        vec3 pos = eye + depth * marchingDirection;\n        //if(pos.y >= 30.) break;\n    \tfloat dist = SceneSDF(pos);\n        if( dist <= EPSILON){\n            return vec4(pos,depth);\n        }\n        depth += dist;\n        if(depth >= end){\n            pos = eye + depth * marchingDirection;\n        \treturn vec4(pos,end);\n        }\n    }\n    return vec4(pos,end);\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 rayDir = RayDirection(45.0, fragCoord.xy, iResolution.xy);\n    \n    float t = iTime*0.05;\n    vec3 eye = vec3(30.0+10.0*sin(t),3.,10.*cos(t));\n    \n    vec3 lookAtPos = vec3(1.0,40.,1.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, lookAtPos, vec3(0,1,0) );\n    vec3 worldDir = (viewToWorld*vec4(rayDir,0)).xyz;\n    \n    vec4 shortDist = ShortestDistanceToSurface(eye,worldDir,0.,100.0);\n    vec3 pos = shortDist.xyz;\n    float dist = shortDist.w;\n    \n    vec3 lightPos = vec3(.5,1.5,.5);\n    vec3 lightDirection = normalize(-lightPos);\n    \n    vec3 p = eye + dist * worldDir;\n    vec3 normal = estimateNormal(p);\n    float diffuse = dot(normal, -lightDirection);\n    diffuse = max(diffuse,0.);\n    \n    vec3 finalColor = vec3(0);\n\n    if(shortDist.y >= 21.35) {\n        finalColor = leafColorLight;\n    } else if(shortDist.y >= 20.) {\n        finalColor = leafColorDark;\n    } else {\n        finalColor = trunkColor;\n    }\n\n    vec3 ambientColor = vec3(.4);\n    finalColor = finalColor*(diffuse+ambientColor);\n\n\tfragColor = vec4(finalColor,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftfSWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[545, 600, 657, 657, 753], [755, 755, 790, 790, 818], [820, 820, 875, 875, 1035], [1037, 1037, 1091, 1157, 1354], [1356, 1356, 1374, 1374, 1497], [1499, 1499, 1522, 1558, 3049], [3051, 3051, 3080, 3080, 3390], [3392, 3392, 3456, 3456, 3585], [3587, 3587, 3676, 3676, 4119], [4121, 4448, 4497, 4532, 4758], [4760, 4760, 4817, 4817, 5876]], "test": "untested"}
{"id": "ftXXDf", "name": "How Many Sides || Edit", "author": "AlijahT", "description": "Edit of this shader https://www.shadertoy.com/view/4dlBDn", "tags": ["spiralthingedit"], "likes": 1, "viewed": 271, "published": 3, "date": "1626654914", "time_retrieved": "2024-07-30T19:10:23.649315", "image_code": "\nfloat time = 0.1;\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n mat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nfloat map(vec3 p)\n{\n\n    vec3 q = p;\n\n    vec3 c = vec3(0.2);\n    p.z = mod(p.z,c.z)-0.5*c.z;\n\n    \n    vec3 p_s;\n    \n    p = p * rotationMatrix(vec3(0.0, 0.0, 1.0), sin(floor(q.z * 10.0) * 10.0) * 4.0 + 0.1 * (time));\n    \n    float bars = 1000.0;\n    int sides = 25; // not really sides\n    float angle = 3.1415 * 1.0 / float(sides) + sin(iTime/10.0)+ 1.0;\n    \n    for ( int i = 0; i < sides; i ++)\n    {\n        \n        p_s = p * rotationMatrix(vec3(0.0, 0.0, 1.0), angle * float(i));\n        \n       \tp_s += vec3(\n            sin(30.0 * floor(q.z))* 0.5 + 1.0, \n            cos(iTime + sin(q.z* 9.0)), \n            0.0);\n        \n        vec3 boxdim = vec3(\n        \t0.05 + 0.05 * sin(q.z*5.0 + iTime* 2.0), \n            sin(q.z * 10.0) * 0.5  + 0.5, \n            0.01 + pow(sin(iTime), 0.5)\n        );\n     \t\n        \n        bars = min(bars, sdBox(p_s, boxdim));  \n    }\n\n        \n    \n    float result = bars;   \n    return result;\n}\n\n\nvoid getCamPos(inout vec3 ro, inout vec3 rd)\n{\n    ro.z = time;\n   // ro.x -= sin(iTime) 2.0;\n}\n\n vec3 gradient(vec3 p, float t) {\n\t\t\tvec2 e = vec2(0., t);\n\n\t\t\treturn normalize( \n\t\t\t\tvec3(\n\t\t\t\t\tmap(p+e.yxx) - map(p-e.yxx),\n\t\t\t\t\tmap(p+e.xyx) - map(p-e.xyx),\n\t\t\t\t\tmap(p+e.xxy) - map(p-e.xxy)\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ttime = iTime * 0.5;\n    vec2 _p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    vec3 ray = normalize(vec3(_p, 1.0));\n    vec3 cam = vec3(0.0, 0.0, 0.0);\n    bool hit = false;\n    getCamPos(cam, ray);\n    \n    float depth = 0.0, d = 0.0, iter = 0.0;\n    vec3 p;\n    \n    for( int i = 0; i < 40; i ++)\n    {\n    \tp = depth * ray + cam;\n        d = map(p);\n                  \n        if (d < 0.001) {\n\t\t\thit = true;\n            break;\n        }\n                   \n        float ratio = 0.2;\n\t\tdepth += d * ratio;\n\t\titer++;\n                   \n    }\n    \n    vec3 col = vec3(1.0 - iter / 40.0);\n\t\n    \n    \n    col = pow(col, vec3(\n        0.5,\n         0.1 + sin(iTime - p.z * 3.6)* 0.4 + 0.5,\n        0.1 + sin(iTime - p.z * 10.0)* 0.4 + 0.5));\n\n    \n    \n    fragColor = vec4(col, hit? length(p.xy) : 0.0 );\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXXDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 50, 50, 137], [139, 139, 172, 172, 198], [201, 201, 246, 246, 718], [720, 720, 739, 739, 1663], [1666, 1666, 1712, 1712, 1761], [1764, 1764, 1796, 1796, 1971], [1974, 1974, 2031, 2031, 2859]], "test": "untested"}
{"id": "NtsSzf", "name": "Aliasing zoom", "author": "Alexwing", "description": "Explore the cosine aliasing with the mouse.", "tags": ["mouse"], "likes": 3, "viewed": 265, "published": 3, "date": "1626636504", "time_retrieved": "2024-07-30T19:10:24.411277", "image_code": "#define VELOCITY    500.0\n#define ANTI_ALIASING_FACTOR    0.5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord.xy; //We obtain our coordinates for the current pixel\n    \n\n    xy.x = xy.x / (iResolution.x-iMouse.x); //We divide the coordinates by the screen size \n    xy.y = xy.y / (iResolution.y-iMouse.y);\n    \n    // Now x is 0 for the leftmost pixel, and 1 for the rightmost pixel\n    vec4 solidRed = vec4(0,0.0,0.0,0.0); //This is actually black right now\n    \n\tif(iMouse.z>0.0 ) { // button is down\n     fragCoord -= 0.5*(fragColor.xy=(iMouse.xy*2.0));\n    }else{\n     fragCoord -= 0.5*(fragColor.xy=(iResolution.xy));\n    }\n    \n    // inversion\n    fragCoord = cos(iTime*  fragCoord*VELOCITY* xy /dot(fragCoord,fragCoord)) ;\n        \n    // anti-aliasing and color post\n\tsolidRed += ANTI_ALIASING_FACTOR-  fragCoord.x / fwidth(fragCoord.x  -fragColor );      \n    \n    //solidRed.x += ANTI_ALIASING_FACTOR-  fragCoord.x / fwidth(fragCoord  -xy ).x;       \n   // solidRed.y += ANTI_ALIASING_FACTOR-  fragCoord.x / fwidth(fragCoord  -xy ).y;      \n   // solidRed.z += ANTI_ALIASING_FACTOR-  fragCoord.x / fwidth(fragCoord  -xy ).x;  \n    \n\n    fragColor = solidRed;\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsSzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 120, 120, 1216]], "test": "untested"}
{"id": "ftXXWX", "name": "Cable nest", "author": "mrange", "description": "License CC0: Cable nest\nResult after a few hours programming sunday afternoon\n", "tags": ["raymarching"], "likes": 98, "viewed": 5528, "published": 3, "date": "1626634908", "time_retrieved": "2024-07-30T19:10:25.186205", "image_code": "// License CC0: Cable nest\n//  Result after a few hours programming sunday afternoon\n#define TOLERANCE       0.0001\n#define NORMTOL         0.00125\n#define MAX_RAY_LENGTH  20.0\n#define MAX_RAY_MARCHES 90\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\n// https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n#define PATHA vec2(0.1147, 0.2093)\n#define PATHB vec2(13.0, 3.0)\n\nconst float cam_amp = 1.0;\n\nvec4 g_state = vec4(0.0);\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// https://iquilezles.org/articles/spherefunctions\nfloat sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    float ndbuffer = dbuffer/sph.w;\n    vec3  rc = (ro - sph.xyz)/sph.w;\n  \n    float b = dot(rd,rc);\n    float c = dot(rc,rc) - 1.0;\n    float h = b*b - c;\n    if( h<0.0 ) return 0.0;\n    h = sqrt( h );\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if( t2<0.0 || t1>ndbuffer ) return 0.0;\n    t1 = max( t1, 0.0 );\n    t2 = min( t2, ndbuffer );\n\n    float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n    float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n    return (i2-i1)*(3.0/4.0);\n}\n\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvec3 cam_path(float z) {\n  return vec3(cam_amp*sin(z*PATHA)*PATHB, z);\n}\n\nvec3 dcam_path(float z) {\n  return vec3(cam_amp*PATHA*PATHB*cos(PATHA*z), 1.0);\n}\n\nvec3 ddcam_path(float z) {\n  return cam_amp*vec3(cam_amp*-PATHA*PATHA*PATHB*sin(PATHA*z), 0.0);\n}\n\nfloat df(vec3 p3, out vec4 state) {\n  float cylr = 0.2;\n  vec2 p = p3.xy;\n  float t = p3.z;\n  \n  const float ss = 1.5;\n  mat2 pp = ss*ROT(1.0+0.5*p3.z);\n\n  p *= ROT(-0.2*TIME);\n  float s = 1.0;\n  \n  float d = 1E6;\n  float tt = 0.0;\n  for (int i = 0; i < 3; ++i) {\n    tt += sqrt(2.0)*float(1+i);\n    p *= pp;\n    vec2 sp = sign(p);\n    p = abs(p);\n    tt += dot(sp, vec2(0.25, 0.5))*s;\n    p -= 1.35*s;\n    s *= 1.0/ss;\n    \n    float dd = (length(p-vec2(0.0))-cylr)*s;\n    if (dd < d) {\n      d = dd;\n      state = vec4(p, t, hash(tt+123.4));\n    }\n    \n  }\n  \n  return d;\n}\n\nfloat df(vec3 p) {\n  // Found this world warping technique somewhere but forgot which shader :(\n  vec3 cam = cam_path(p.z);\n  vec3 dcam = normalize(dcam_path(p.z));\n  p.xy -= cam.xy;\n  p -= dcam*dot(vec3(p.xy, 0), dcam)*0.5*vec3(1,1,-1);\n  vec4 state;\n  float d = df(p, state);\n  \n  g_state = state;\n  \n  return d; \n} \n\nfloat rayMarch(in vec3 ro, in vec3 rd, out int iter) {\n  float t = 0.0;\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float distance = df(ro + rd*t);\n    if (distance < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += distance;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal(in vec3 pos) {\n  vec3  eps = vec3(NORMTOL,0.0,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat softShadow(in vec3 pos, in vec3 ld, in float ll, float mint, float k) {\n  const float minShadow = 0.25;\n  float res = 1.0;\n  float t = mint;\n  for (int i=0; i<25; ++i) {\n    float distance = df(pos + ld*t);\n    res = min(res, k*distance/t);\n    if (ll <= t) break;\n    if(res <= minShadow) break;\n    t += max(mint*0.2, distance);\n  }\n  return clamp(res,minShadow,1.0);\n}\n\nvec3 postProcess(in vec3 col, in vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 lightPos0  = cam_path(TIME-0.5);\n  vec3 lightPos1  = cam_path(TIME+6.5);\n\n  vec3 skyCol = vec3(0.0);\n\n  int iter = 0;\n  float t = rayMarch(ro, rd, iter);\n  vec4 state = g_state;\n\n  float tt = float(iter)/float(MAX_RAY_MARCHES);\n  float bs = 1.0-tt*tt*tt*tt;\n \n  vec3 pos = ro + t*rd;    \n  \n  float lsd1  = sphered(ro, rd, vec4(lightPos1, 2.5), t);\n  float beat  = smoothstep(0.25, 1.0, sin(TAU*TIME*120.0/60.0));\n  vec3 bcol   = mix(1.5*vec3(2.25, 0.75, 0.5), 3.5*vec3(2.0, 1.0, 0.75), beat);\n  vec3 gcol   = lsd1*bcol;\n\n  if (t >= MAX_RAY_LENGTH) {\n    return skyCol+gcol;\n  }\n  \n  vec3 nor    = normal(pos);\n\n  float sa    = atan(state.y, state.x)+4.0*state.z*(0.5+0.5*state.w);\n  float v     = 0.9*smoothstep(-0.1, 0.1, sin(4.0*sa));\n  vec3 color  = hsv2rgb(vec3(0.0+123.4*state.w, 0.66, 0.75*v));\n  \n  vec3 lv0    = lightPos0 - pos;\n  float ll20  = dot(lv0, lv0);\n  float ll0   = sqrt(ll20);\n  vec3 ld0    = lv0 / ll0;\n  float dm0   = 8.0/ll20;\n  float sha0  = softShadow(pos, ld0, ll0, 0.125, 32.0);\n  float dif0  = max(dot(nor,ld0),0.0)*dm0;\n\n  vec3 lv1    = lightPos1 - pos;\n  float ll21  = dot(lv1, lv1);\n  float ll1   = sqrt(ll21);\n  vec3 ld1    = lv1 / ll1;\n  float spe1  = pow(max(dot(reflect(ld1, nor), rd), 0.), 100.)*tanh_approx(3.0/ll21);\n\n  vec3 col = vec3(0.0);\n  col += dif0*sha0*color;\n  col += spe1*bcol*bs;\n  col += gcol;\n\n  return col;\n}\n\nvec3 effect3d(vec2 p) {\n  float tm = TIME;\n  vec3 cam  = cam_path(tm);\n  vec3 dcam = dcam_path(tm);\n  vec3 ddcam= ddcam_path(tm);\n\n  vec3 ro = cam;\n  vec3 ww = normalize(dcam);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0)+ddcam*-2.0, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  float rdd = (2.0+0.5*tanh_approx(length(p)));\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n\n  vec3 col = render(ro, rd);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q=fragCoord.xy/RESOLUTION.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect3d(p);\n\n  fragColor = vec4(postProcess(col, q),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXXWX.jpg", "access": "api", "license": "cc0-1.0", "functions": [[510, 510, 532, 532, 678], [943, 943, 971, 991, 1067], [1069, 1120, 1178, 1178, 1659], [1661, 1661, 1683, 1683, 1731], [1733, 1733, 1757, 1757, 1805], [1807, 1807, 1832, 1832, 1888], [1890, 1890, 1916, 1916, 1987], [1989, 1989, 2024, 2024, 2564], [2566, 2566, 2584, 2661, 2883], [2886, 2886, 2940, 2940, 3156], [3158, 3158, 3184, 3184, 3395], [3397, 3397, 3474, 3474, 3774], [3776, 3776, 3819, 3819, 4071], [4073, 4073, 4104, 4104, 5472], [5474, 5474, 5497, 5497, 5895], [5897, 5897, 5952, 5952, 6126]], "test": "ok"}
{"id": "7tsSD2", "name": "Indian Flags + Rotating Chakra", "author": "napsternxg", "description": "Added rotating chakra and the number of flags changes over time. \nBased on this version: https://www.shadertoy.com/view/7lsSDj", "tags": ["flag", "india"], "likes": 1, "viewed": 243, "published": 3, "date": "1626627935", "time_retrieved": "2024-07-30T19:10:25.955150", "image_code": "vec3 WHITE = vec3(1);\nvec3 BLACK = vec3(0);\nvec3 SAFFRON = vec3(255,153,51)/255.;\nvec3 GREEN = vec3(19,136,8)/255.;\nvec3 BLUE = vec3(0,0,128)/255.;\nfloat PI = radians(180.);\n\n\nfloat get_band(float x, float width,  float smoothing_d){\nreturn smoothstep(0., smoothing_d, x)*smoothstep(0., smoothing_d, -x + width);\n    \n}\n\nvec3 Chakra(vec2 cuv, vec3 col){\n    //cuv.y = cuv.y*ratio;\n    float d = length(cuv);\n    //float angle = (PI + atan(cuv.y, cuv.x))/2.*PI;\n    float angle = atan(cuv.y, cuv.x)/PI;\n    angle = 12.*angle;\n    angle = fract(angle);\n    \n    float circle_r = 0.09;\n    float circle_w = 0.01;\n    \n    //float circle_rim = smoothstep(0., 0.01, d-circle_r + circle_w)*smoothstep(0., 0.01, d-circle_r);\n    float circle_rim = get_band(d-(circle_r - circle_w), circle_w, 0.001);\n    col = mix(col, BLUE, circle_rim);\n    \n    /**\n    if(d > circle_r - circle_w && d < circle_r){\n        col = BLUE;\n    }\n    **/\n    \n    col = mix(col, BLUE, smoothstep(0., 0.001, -d+0.01));\n    /**\n    if(d < 0.01){\n        col = BLUE;\n    }\n    **/\n    \n    \n    col = mix(col, BLUE, smoothstep(0., 0.001, -d+circle_r)*get_band(angle-0.8, 0.2, 0.01));\n    return col;\n\n}\n\nvec3 Flag(vec2 uv){\n\n// Normalized pixel coordinates (from 0 to 1)\n    \n    \n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n\n    float band = floor(uv.y*3.);\n    \n    col = BLACK;\n    \n    //float flag_region = smoothstep(0., 0.01, band+1.)*smoothstep(0., 0.01, -band + 3.);\n    float flag_region = get_band(band+1., 4., 0.001);\n    \n    float top = flag_region*smoothstep(0., 0.01, band + 3.);\n    col = mix(col, GREEN, top);\n    \n    top = top*smoothstep(0., 0.01, band);\n    col = mix(col, WHITE, top);\n    \n    top = top*smoothstep(0., 0.01, band-1.);\n    col = mix(col, SAFFRON, top);\n    \n    \n    /**\n    if(band < 3. && band > -1.){\n        if (band > 1.){\n            col = SAFFRON;\n        } else if (band > 0.) {\n            col = WHITE;\n        } else if (band > -1.){\n            col = GREEN; \n        }\n    }\n    **/\n    \n    vec2 center = vec2(0.5);\n    vec2 cuv = uv - center;\n    \n    float rotation = fract(iTime)*2.*PI;\n    mat2 rotation_matrix = mat2(cos(rotation), sin(rotation), -sin(rotation), cos(rotation));\n    \n    cuv *= rotation_matrix;\n    \n    col = Chakra(cuv, col);\n    \n    /**\n    if(d < circle_r && angle > 0.8){\n        col = BLUE;\n    }\n    **/\n    \n    col = mix(BLACK, col, flag_region);\n    \n    return col;\n\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float num_flags = 1.+5.*(1.+cos(.2*iTime))/2.;\n    \n    //float rotation = fract(iTime)*2.*PI;\n    //mat2 rotation_matrix = mat2(cos(rotation), sin(rotation), -sin(rotation), cos(rotation));\n    //uv -= 0.5;\n    \n    //uv *= rotation_matrix;\n    \n    //uv -= 0.5*cos(1.*iTime);\n    \n    uv.x = fract(num_flags*uv.x);\n    uv.y = fract(num_flags*uv.y);\n    \n    float t = uv.x*7. - 2.*iTime + uv.y*3.;\n    \n    uv.y += sin(t)*0.03;\n    \n    \n    float ratio = iResolution.y/iResolution.x;\n    vec3 col = Flag(uv);\n    \n    col *= .9 + cos(t)*0.2;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tsSD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[176, 176, 233, 233, 319], [321, 321, 353, 380, 1171], [1173, 1173, 1192, 1282, 2472], [2474, 2474, 2531, 2531, 3185]], "test": "untested"}
{"id": "sllXDj", "name": "melon blobz", "author": "zevanrosser", "description": "some blobs", "tags": ["cineshader"], "likes": 10, "viewed": 5599, "published": 3, "date": "1626619962", "time_retrieved": "2024-07-30T19:10:26.727086", "image_code": "#define NUM 8 \n        \n  float rand(vec2 co){ \n    return fract(sin(dot(co.xy, vec2(12.9891,78.233))) * 43754.6453);\n  }\n\n  float ting(float i, vec2 uv, vec2 loc){\n    return smoothstep(0.1, 0.7 + i / 20.0, 1. - atan(distance(uv, loc + vec2(0.2, 0.0))) * 3.);\n  }\n\n  void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    uv.y /= iResolution.x / iResolution.y;\n\n    uv.y -= max(0.0,(iResolution.y - iResolution.x) / iResolution.y);\n\n    float cl = 0.0;\n    float dl = 0.0;\n    float v = 2. - smoothstep(0.0, 1.0, 1.0 - (distance(uv, vec2(0.5, 0.5)))) * 2.;\n\n    float t = cos(iTime);\n\n    for (int i = 0; i < NUM; i++){\n      float fi = float(i);\n      float ty = rand(vec2(fi, 0.9));\n      float tx = 0.1 * fi - 0.1 + 0.03 * cos(iTime + fi);\n      float tcos = cos(iTime * float(i - NUM / 2) * 0.3);\n      float tin = ting(fi * 1.2 * tcos, uv, vec2(tx, ty));\n\n      if (tin > cl) {\n        cl += smoothstep(cl, 1.2, tin);\n      }\n\n      tin = ting(fi * 1.1 * tcos, uv, vec2(tx + 0.01, ty + 0.01));\n\n      if (tin > dl) {\n        dl += smoothstep(dl, 1.1, tin);\n      }\n    }\n\n\n    cl = sin(acos(cl - 0.2));\n    dl = sin(acos(dl - 0.2));\n\n    float j = sin(5.0 * smoothstep(0.3, 1.2, dl));\n\n    cl = max(cl , j * 1.2);\n    cl += rand(fragCoord.xy + iTime) * 0.14;\n    cl -= v * 0.6;\n\n    fragColor = vec4(cl * 1.44, (cl + dl) / 2.3, cl * 0.9, 1.0);\n  }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sllXDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 46, 46, 121], [125, 125, 164, 164, 264], [268, 268, 325, 325, 1406]], "test": "untested"}
{"id": "7lsSDj", "name": "Multiple Waving Indian Flags", "author": "napsternxg", "description": "Extended my previous shader code for waving Indian Flags to now have multiple Indian Flags: https://www.shadertoy.com/view/7tXXD2", "tags": ["flags", "india"], "likes": 0, "viewed": 242, "published": 3, "date": "1626619326", "time_retrieved": "2024-07-30T19:10:27.492040", "image_code": "vec3 WHITE = vec3(1);\nvec3 BLACK = vec3(0);\nvec3 SAFFRON = vec3(255,153,51)/255.;\nvec3 GREEN = vec3(19,136,8)/255.;\nvec3 BLUE = vec3(0,0,128)/255.;\nfloat PI = radians(180.);\n\n\nfloat get_band(float x, float width,  float smoothing_d){\nreturn smoothstep(0., smoothing_d, x)*smoothstep(0., smoothing_d, -x + width);\n    \n}\n\nvec3 Flag(vec2 uv, float ratio){\n\n// Normalized pixel coordinates (from 0 to 1)\n    \n    \n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n\n    float band = floor(uv.y*3.);\n    \n    col = BLACK;\n    \n    //float flag_region = smoothstep(0., 0.01, band+1.)*smoothstep(0., 0.01, -band + 3.);\n    float flag_region = get_band(band+1., 4., 0.001);\n    \n    float top = flag_region*smoothstep(0., 0.01, band + 3.);\n    col = mix(col, GREEN, top);\n    \n    top = top*smoothstep(0., 0.01, band);\n    col = mix(col, WHITE, top);\n    \n    top = top*smoothstep(0., 0.01, band-1.);\n    col = mix(col, SAFFRON, top);\n    \n    \n    /**\n    if(band < 3. && band > -1.){\n        if (band > 1.){\n            col = SAFFRON;\n        } else if (band > 0.) {\n            col = WHITE;\n        } else if (band > -1.){\n            col = GREEN; \n        }\n    }\n    **/\n    \n    \n    vec2 center = vec2(0.5);\n    vec2 cuv = uv - center;\n    cuv.y = cuv.y*ratio;\n    float d = length(cuv);\n    //float angle = (PI + atan(cuv.y, cuv.x))/2.*PI;\n    float angle = atan(cuv.y, cuv.x)/PI;\n    angle = 12.*angle;\n    angle = fract(angle);\n    \n    float circle_r = 0.09;\n    float circle_w = 0.01;\n    \n    //float circle_rim = smoothstep(0., 0.01, d-circle_r + circle_w)*smoothstep(0., 0.01, d-circle_r);\n    float circle_rim = get_band(d-(circle_r - circle_w), circle_w, 0.001);\n    col = mix(col, BLUE, circle_rim);\n    \n    /**\n    if(d > circle_r - circle_w && d < circle_r){\n        col = BLUE;\n    }\n    **/\n    \n    col = mix(col, BLUE, smoothstep(0., 0.001, -d+0.01));\n    /**\n    if(d < 0.01){\n        col = BLUE;\n    }\n    **/\n    \n    \n    col = mix(col, BLUE, smoothstep(0., 0.001, -d+circle_r)*get_band(angle-0.8, 0.2, 0.01));\n    \n    /**\n    if(d < circle_r && angle > 0.8){\n        col = BLUE;\n    }\n    **/\n    \n    col = mix(BLACK, col, flag_region);\n    \n    return col;\n\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.x = fract(5.*uv.x);\n    uv.y = fract(5.*uv.y);\n    \n    float t = uv.x*7. - 2.*iTime + uv.y*3.;\n    \n    uv.y += sin(t)*0.03;\n    \n    \n    float ratio = iResolution.y/iResolution.x;\n    vec3 col = Flag(uv, ratio);\n    \n    col *= .9 + cos(t)*0.2;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lsSDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[176, 176, 233, 233, 319], [321, 321, 353, 443, 2229], [2231, 2231, 2288, 2288, 2648]], "test": "untested"}
{"id": "ftsXW2", "name": "5 AM With Friends", "author": "blackle", "description": "just a random coding session among friends at 5 am", "tags": ["circles", "gold", "gridlines", "livecode"], "likes": 35, "viewed": 758, "published": 3, "date": "1626600920", "time_retrieved": "2024-07-30T19:10:28.254003", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat stg;\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nfloat smin(float a, float b, float k) {\n  float h = max(k-abs(a-b), 0.)/k;\n  return min(a,b) - h*h*h*k/6.;\n}\n\nfloat comp(vec3 p) {\n  p = asin(sin(p)*.999);\n  return dot(p,normalize(vec3(1,2,3)));\n}\n\nfloat linedist(vec3 p, vec3 a, vec3 b) {\n  float k = dot(p-a,b-a)/dot(b-a,b-a);\n  return distance(p,mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat w, dts;\nfloat scene(vec3 p) {\n  float h1 = comp(erot(p,normalize(vec3(1,2,3)),2.));\n  float h2 = comp(erot(p,normalize(vec3(3,-1,2)),stg));\n  float h3 = comp(erot(p,normalize(vec3(0,3,2)),stg*2.));\n  float cave = (h1+h2+h3)/2.5;\n  float lvl1 = -smin(-cave,-p.z,.1);\n  float lvl2 = -smin(-cave-.5,1.-p.z,.1);\n  vec3 p2 = p;\n  p2.xy = asin(sin(p2.xy*3.))/3.;\n  p2.xy = abs(p2.xy);\n  if(p2.x < p2.y) p2.xy = p2.yx;\n  p2.z += asin(sin(iTime+stg*2.)*.9)*.5+2.;\n  w = smin(lvl2,lvl1,.1);\n  dts = linedist(p2,vec3(1,0,0), vec3(-1,0,0))-.02;\n  return min(w, dts);\n}\n\nvec3 norm(vec3 p ) {\n  mat3 k = mat3(p,p,p) - mat3(0.001);\n  return normalize(scene(p) - vec3(scene(k[0]), scene(k[1]), scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n  \n  stg = floor(iTime);\n\n\tvec3 cam = normalize(vec3(1.5,uv));\n  vec3 init = vec3(-15,0,0);\n  float roz = iTime*.1;\n  if (mod(stg, 2.) < 1.) roz *= -1.;\n  float roy = .8 + sin(stg)*.2;\n  cam = erot(cam,vec3(0,1,0),roy);\n  init = erot(init,vec3(0,1,0),roy);\n  cam = erot(cam,vec3(0,0,1),roz);\n  init = erot(init,vec3(0,0,1),roz);\n  vec3 p = init;\n  bool hit = false;\n  float dist;\n  float glo = 0.;\n  for (int i = 0; i < 150 && !hit; i++) {\n    dist = scene(p);\n    hit = dist*dist < 1e-6;\n    glo += dist/(.1+dts*500.)*10.;\n    p += cam*dist;\n  }\n  bool isgrd = (dts == dist);\n  vec3 n = norm(p);\n  vec3 r = reflect(cam,n);\n  float fres = 1. - abs(dot(cam,n))*.98;\n  r.xy = abs(r.xy);\n  n.xy = abs(n.xy);\n  float ao = smoothstep(-.5,.5,scene(p+n*.5));\n  float ro = smoothstep(-.2,.2,scene(p+r*.2));\n  float spec = length(sin(r*3.5)*.5+.5)/sqrt(3.);\n  float diff = length(sin(n*3.5)*.5+.5)/sqrt(3.);\n  spec = fres*(spec*.1 + pow(spec,8.)*10.) * ro;\n  vec3 col1 = vec3(1,0.4,0.1) * spec; \n  vec3 col2 = vec3(diff)*vec3(.01,.03,.1)*ao + spec*.05;\n  float aaa = sin(p.x*3.+p.y*2.+p.z*8.);\n  vec3 col = mix(col2, col1, smoothstep(-.94,-.96,aaa));\n  if (isgrd) col = vec3(.1,.2,.5)*6.;\n  col = mix(col, vec3(.01), smoothstep(0.,-7.,p.z));\n  col += glo*vec3(.1,.2,.5)+glo*glo;\n  fragColor.xyz = col;\n  fragColor *= 1. - dot(uv,uv);\n  fragColor = smoothstep(-.05,1.1,sqrt(fragColor) + vec4(0.08,0.02,0.1,0));\n  float dt = length(uv);\n  float f1 = step(0.,sin(stg*.7));\n  float f2 = step(0.,sin(stg*1.7));\n  float f3 = step(0.,sin(stg*2.7));\n  float circles = abs(abs(abs(dt-mix(.7,.5,f3))-.1*f1)-.03*f2)-.002;\n  fragColor = mix(vec4(0.2), fragColor,smoothstep(0.,fwidth(dt)*3.,circles));\n  fragColor = mix(vec4(1), fragColor,smoothstep(0.,fwidth(dt)*1.5,circles));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsXW2.jpg", "access": "api", "license": "cc0-1.0", "functions": [[205, 205, 243, 243, 307], [309, 309, 348, 348, 417], [419, 419, 439, 439, 506], [508, 508, 548, 548, 635], [651, 651, 672, 672, 1200], [1202, 1202, 1222, 1222, 1338], [1340, 1340, 1397, 1397, 3213]], "test": "untested"}
{"id": "stXSWB", "name": "AMD FidelityFX: Super Resolution", "author": "goingdigital", "description": "Shadertoy port of AMD FidelityFX Super Resolution (FSR).  Other upscalers: https://www.shadertoy.com/playlist/WcKXWW\n", "tags": ["fsr"], "likes": 40, "viewed": 5916, "published": 3, "date": "1626598207", "time_retrieved": "2024-07-30T19:10:29.317160", "image_code": "/*\n* FidelityFX Super Resolution scales up a low resolution\n* image, while adding fine detail.\n*\n* MIT Open License\n*\n* https://gpuopen.com/fsr\n*\n* Left: FSR processed\n* Right: Original texture, bilinear interpolation\n*\n* Mouse at top: Sharpness 0 stops (maximum)\n* Mouse at bottom: Sharpness 2 stops (minimum)\n*\n* It works in two passes-\n*   EASU upsamples the image with a clamped Lanczos kernel.\n*   RCAS sharpens the image at the target resolution.\n*\n* I needed to make a few changes to improve readability and\n* WebGL compatibility in an algorithm I don't fully understand.\n* Expect bugs.\n*\n* Shader not currently running for WebGL1 targets (eg. mobile Safari)\n*\n* There is kind of no point to using FSR in Shadertoy, as it renders buffers\n* at full target resolution. But this might be useful for WebGL based demos\n* running smaller-than-target render buffers.\n*\n* For sharpening with a full resolution render buffer,\n* FidelityFX CAS is a better option.\n* https://www.shadertoy.com/view/ftsXzM\n*\n* For readability and compatibility, these optimisations have been removed:\n*   * Fast approximate inverse and inversesqrt\n*   * textureGather fetches (not WebGL compatible)\n*   * Multiplying by reciprocal instead of division\n*\n* Apologies to AMD for the numerous slowdowns and errors I have introduced.\n*\n*/\n\n/***** RCAS *****/\n#define FSR_RCAS_LIMIT (0.25-(1.0/16.0))\n//#define FSR_RCAS_DENOISE\n\n// Input callback prototypes that need to be implemented by calling shader\nvec4 FsrRcasLoadF(vec2 p);\n//------------------------------------------------------------------------------------------------------------------------------\nvoid FsrRcasCon(\n    out float con,\n    // The scale is {0.0 := maximum, to N>0, where N is the number of stops (halving) of the reduction of sharpness}.\n    float sharpness\n){\n    // Transform from stops to linear value.\n    con = exp2(-sharpness);\n}\n\nvec3 FsrRcasF(\n    vec2 ip, // Integer pixel position in output.\n    float con\n)\n{\n    // Constant generated by RcasSetup().\n    // Algorithm uses minimal 3x3 pixel neighborhood.\n    //    b \n    //  d e f\n    //    h\n    vec2 sp = vec2(ip);\n    vec3 b = FsrRcasLoadF(sp + vec2( 0,-1)).rgb;\n    vec3 d = FsrRcasLoadF(sp + vec2(-1, 0)).rgb;\n    vec3 e = FsrRcasLoadF(sp).rgb;\n    vec3 f = FsrRcasLoadF(sp+vec2( 1, 0)).rgb;\n    vec3 h = FsrRcasLoadF(sp+vec2( 0, 1)).rgb;\n    // Luma times 2.\n    float bL = b.g + .5 * (b.b + b.r);\n    float dL = d.g + .5 * (d.b + d.r);\n    float eL = e.g + .5 * (e.b + e.r);\n    float fL = f.g + .5 * (f.b + f.r);\n    float hL = h.g + .5 * (h.b + h.r);\n    // Noise detection.\n    float nz = .25 * (bL + dL + fL + hL) - eL;\n    nz=clamp(\n        abs(nz)\n        /(\n            max(max(bL,dL),max(eL,max(fL,hL)))\n            -min(min(bL,dL),min(eL,min(fL,hL)))\n        ),\n        0., 1.\n    );\n    nz=1.-.5*nz;\n    // Min and max of ring.\n    vec3 mn4 = min(b, min(f, h));\n    vec3 mx4 = max(b, max(f, h));\n    // Immediate constants for peak range.\n    vec2 peakC = vec2(1., -4.);\n    // Limiters, these need to be high precision RCPs.\n    vec3 hitMin = mn4 / (4. * mx4);\n    vec3 hitMax = (peakC.x - mx4) / (4.* mn4 + peakC.y);\n    vec3 lobeRGB = max(-hitMin, hitMax);\n    float lobe = max(\n        -FSR_RCAS_LIMIT,\n        min(max(lobeRGB.r, max(lobeRGB.g, lobeRGB.b)), 0.)\n    )*con;\n    // Apply noise removal.\n    #ifdef FSR_RCAS_DENOISE\n    lobe *= nz;\n    #endif\n    // Resolve, which needs the medium precision rcp approximation to avoid visible tonality changes.\n    return (lobe * (b + d + h + f) + e) / (4. * lobe + 1.);\n} \n\n\nvec4 FsrRcasLoadF(vec2 p) {\n    return texture(iChannel0,p/iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Set up constants\n    float con;\n    float sharpness = 0.2;\n    float division = 0.5+.3*sin(iTime*.3);\n    if (iMouse.z > 0.) {\n        sharpness = 2.-2.*pow( iMouse.y / iResolution.y,.25);\n        division = iMouse.x / iResolution.x;\n    }\n    FsrRcasCon(con,sharpness);\n\n    // Perform RCAS pass\n    vec3 col = FsrRcasF(fragCoord, con);\n    \n    // Source image\n    vec2 uv1;\n    \n    // Bilinear interpolation\n    uv1 = fragCoord/iResolution.xy;\n    \n    // Nearest pixel\n    //uv1 = (floor(vec2(textureSize(iChannel1,0))*fragCoord/iResolution.xy)+.5)/vec2(textureSize(iChannel1,0));\n    \n    vec3 col_orig = texture(iChannel1,uv1).xyz;\n    \n    // Comparison tool\n    if (fragCoord.x/iResolution.x > division) col = col_orig;\n    if (abs(fragCoord.x/iResolution.x - division)<.005) col = vec3(0);\n\n    fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/* EASU stage\n*\n* This takes a reduced resolution source, and scales it up while preserving detail.\n*\n* Updates:\n*   stretch definition fixed. Thanks nehon for the bug report!\n*/\n\nvec3 FsrEasuCF(vec2 p) {\n    return texture(iChannel0,p).rgb;\n}\n\n/**** EASU ****/\nvoid FsrEasuCon(\n    out vec4 con0,\n    out vec4 con1,\n    out vec4 con2,\n    out vec4 con3,\n    // This the rendered image resolution being upscaled\n    vec2 inputViewportInPixels,\n    // This is the resolution of the resource containing the input image (useful for dynamic resolution)\n    vec2 inputSizeInPixels,\n    // This is the display resolution which the input image gets upscaled to\n    vec2 outputSizeInPixels\n)\n{\n    // Output integer position to a pixel position in viewport.\n    con0 = vec4(\n        inputViewportInPixels.x/outputSizeInPixels.x,\n        inputViewportInPixels.y/outputSizeInPixels.y,\n        .5*inputViewportInPixels.x/outputSizeInPixels.x-.5,\n        .5*inputViewportInPixels.y/outputSizeInPixels.y-.5\n    );\n    // Viewport pixel position to normalized image space.\n    // This is used to get upper-left of 'F' tap.\n    con1 = vec4(1,1,1,-1)/inputSizeInPixels.xyxy;\n    // Centers of gather4, first offset from upper-left of 'F'.\n    //      +---+---+\n    //      |   |   |\n    //      +--(0)--+\n    //      | b | c |\n    //  +---F---+---+---+\n    //  | e | f | g | h |\n    //  +--(1)--+--(2)--+\n    //  | i | j | k | l |\n    //  +---+---+---+---+\n    //      | n | o |\n    //      +--(3)--+\n    //      |   |   |\n    //      +---+---+\n    // These are from (0) instead of 'F'.\n    con2 = vec4(-1,2,1,2)/inputSizeInPixels.xyxy;\n    con3 = vec4(0,4,0,0)/inputSizeInPixels.xyxy;\n}\n\n// Filtering for a given tap for the scalar.\nvoid FsrEasuTapF(\n    inout vec3 aC, // Accumulated color, with negative lobe.\n    inout float aW, // Accumulated weight.\n    vec2 off, // Pixel offset from resolve position to tap.\n    vec2 dir, // Gradient direction.\n    vec2 len, // Length.\n    float lob, // Negative lobe strength.\n    float clp, // Clipping point.\n    vec3 c\n)\n{\n    // Tap color.\n    // Rotate offset by direction.\n    vec2 v = vec2(dot(off, dir), dot(off,vec2(-dir.y,dir.x)));\n    // Anisotropy.\n    v *= len;\n    // Compute distance^2.\n    float d2 = min(dot(v,v),clp);\n    // Limit to the window as at corner, 2 taps can easily be outside.\n    // Approximation of lancos2 without sin() or rcp(), or sqrt() to get x.\n    //  (25/16 * (2/5 * x^2 - 1)^2 - (25/16 - 1)) * (1/4 * x^2 - 1)^2\n    //  |_______________________________________|   |_______________|\n    //                   base                             window\n    // The general form of the 'base' is,\n    //  (a*(b*x^2-1)^2-(a-1))\n    // Where 'a=1/(2*b-b^2)' and 'b' moves around the negative lobe.\n    float wB = .4 * d2 - 1.;\n    float wA = lob * d2 -1.;\n    wB *= wB;\n    wA *= wA;\n    wB = 1.5625*wB-.5625;\n    float w=  wB * wA;\n    // Do weighted average.\n    aC += c*w;\n    aW += w;\n}\n\n//------------------------------------------------------------------------------------------------------------------------------\n// Accumulate direction and length.\nvoid FsrEasuSetF(\n    inout vec2 dir,\n    inout float len,\n    float w,\n    float lA,float lB,float lC,float lD,float lE\n)\n{\n    // Direction is the '+' diff.\n    //    a\n    //  b c d\n    //    e\n    // Then takes magnitude from abs average of both sides of 'c'.\n    // Length converts gradient reversal to 0, smoothly to non-reversal at 1, shaped, then adding horz and vert terms.\n    float lenX = max(abs(lD - lC), abs(lC - lB));\n    float dirX = lD - lB;\n    dir.x += dirX * w;\n    lenX = clamp(abs(dirX)/lenX,0.,1.);\n    lenX *= lenX;\n    len += lenX * w;\n    // Repeat for the y axis.\n    float lenY = max(abs(lE - lC), abs(lC - lA));\n    float dirY = lE - lA;\n    dir.y += dirY * w;\n    lenY = clamp(abs(dirY) / lenY,0.,1.);\n    lenY *= lenY;\n    len += lenY * w;\n}\n\n//------------------------------------------------------------------------------------------------------------------------------\nvoid FsrEasuF(\n    out vec3 pix,\n    vec2 ip, // Integer pixel position in output.\n    // Constants generated by FsrEasuCon().\n    vec4 con0, // xy = output to input scale, zw = first pixel offset correction\n    vec4 con1,\n    vec4 con2,\n    vec4 con3\n)\n{\n    //------------------------------------------------------------------------------------------------------------------------------\n    // Get position of 'f'.\n    vec2 pp = ip * con0.xy + con0.zw; // Corresponding input pixel/subpixel\n    vec2 fp = floor(pp);// fp = source nearest pixel\n    pp -= fp; // pp = source subpixel\n\n    //------------------------------------------------------------------------------------------------------------------------------\n    // 12-tap kernel.\n    //    b c\n    //  e f g h\n    //  i j k l\n    //    n o\n    // Gather 4 ordering.\n    //  a b\n    //  r g\n    vec2 p0 = fp * con1.xy + con1.zw;\n    \n    // These are from p0 to avoid pulling two constants on pre-Navi hardware.\n    vec2 p1 = p0 + con2.xy;\n    vec2 p2 = p0 + con2.zw;\n    vec2 p3 = p0 + con3.xy;\n\n    // TextureGather is not available on WebGL2\n    vec4 off = vec4(-.5,.5,-.5,.5)*con1.xxyy;\n    // textureGather to texture offsets\n    // x=west y=east z=north w=south\n    vec3 bC = FsrEasuCF(p0 + off.xw); float bL = bC.g + 0.5 *(bC.r + bC.b);\n    vec3 cC = FsrEasuCF(p0 + off.yw); float cL = cC.g + 0.5 *(cC.r + cC.b);\n    vec3 iC = FsrEasuCF(p1 + off.xw); float iL = iC.g + 0.5 *(iC.r + iC.b);\n    vec3 jC = FsrEasuCF(p1 + off.yw); float jL = jC.g + 0.5 *(jC.r + jC.b);\n    vec3 fC = FsrEasuCF(p1 + off.yz); float fL = fC.g + 0.5 *(fC.r + fC.b);\n    vec3 eC = FsrEasuCF(p1 + off.xz); float eL = eC.g + 0.5 *(eC.r + eC.b);\n    vec3 kC = FsrEasuCF(p2 + off.xw); float kL = kC.g + 0.5 *(kC.r + kC.b);\n    vec3 lC = FsrEasuCF(p2 + off.yw); float lL = lC.g + 0.5 *(lC.r + lC.b);\n    vec3 hC = FsrEasuCF(p2 + off.yz); float hL = hC.g + 0.5 *(hC.r + hC.b);\n    vec3 gC = FsrEasuCF(p2 + off.xz); float gL = gC.g + 0.5 *(gC.r + gC.b);\n    vec3 oC = FsrEasuCF(p3 + off.yz); float oL = oC.g + 0.5 *(oC.r + oC.b);\n    vec3 nC = FsrEasuCF(p3 + off.xz); float nL = nC.g + 0.5 *(nC.r + nC.b);\n   \n    //------------------------------------------------------------------------------------------------------------------------------\n    // Simplest multi-channel approximate luma possible (luma times 2, in 2 FMA/MAD).\n    // Accumulate for bilinear interpolation.\n    vec2 dir = vec2(0);\n    float len = 0.;\n\n    FsrEasuSetF(dir, len, (1.-pp.x)*(1.-pp.y), bL, eL, fL, gL, jL);\n    FsrEasuSetF(dir, len,    pp.x  *(1.-pp.y), cL, fL, gL, hL, kL);\n    FsrEasuSetF(dir, len, (1.-pp.x)*  pp.y  , fL, iL, jL, kL, nL);\n    FsrEasuSetF(dir, len,    pp.x  *  pp.y  , gL, jL, kL, lL, oL);\n\n    //------------------------------------------------------------------------------------------------------------------------------\n    // Normalize with approximation, and cleanup close to zero.\n    vec2 dir2 = dir * dir;\n    float dirR = dir2.x + dir2.y;\n    bool zro = dirR < (1.0/32768.0);\n    dirR = inversesqrt(dirR);\n    dirR = zro ? 1.0 : dirR;\n    dir.x = zro ? 1.0 : dir.x;\n    dir *= vec2(dirR);\n    // Transform from {0 to 2} to {0 to 1} range, and shape with square.\n    len = len * 0.5;\n    len *= len;\n    // Stretch kernel {1.0 vert|horz, to sqrt(2.0) on diagonal}.\n    float stretch = dot(dir,dir) / (max(abs(dir.x), abs(dir.y)));\n    // Anisotropic length after rotation,\n    //  x := 1.0 lerp to 'stretch' on edges\n    //  y := 1.0 lerp to 2x on edges\n    vec2 len2 = vec2(1. +(stretch-1.0)*len, 1. -.5 * len);\n    // Based on the amount of 'edge',\n    // the window shifts from +/-{sqrt(2.0) to slightly beyond 2.0}.\n    float lob = .5 - .29 * len;\n    // Set distance^2 clipping point to the end of the adjustable window.\n    float clp = 1./lob;\n\n    //------------------------------------------------------------------------------------------------------------------------------\n    // Accumulation mixed with min/max of 4 nearest.\n    //    b c\n    //  e f g h\n    //  i j k l\n    //    n o\n    vec3 min4 = min(min(fC,gC),min(jC,kC));\n    vec3 max4 = max(max(fC,gC),max(jC,kC));\n    // Accumulation.\n    vec3 aC = vec3(0);\n    float aW = 0.;\n    FsrEasuTapF(aC, aW, vec2( 0,-1)-pp, dir, len2, lob, clp, bC);\n    FsrEasuTapF(aC, aW, vec2( 1,-1)-pp, dir, len2, lob, clp, cC);\n    FsrEasuTapF(aC, aW, vec2(-1, 1)-pp, dir, len2, lob, clp, iC);\n    FsrEasuTapF(aC, aW, vec2( 0, 1)-pp, dir, len2, lob, clp, jC);\n    FsrEasuTapF(aC, aW, vec2( 0, 0)-pp, dir, len2, lob, clp, fC);\n    FsrEasuTapF(aC, aW, vec2(-1, 0)-pp, dir, len2, lob, clp, eC);\n    FsrEasuTapF(aC, aW, vec2( 1, 1)-pp, dir, len2, lob, clp, kC);\n    FsrEasuTapF(aC, aW, vec2( 2, 1)-pp, dir, len2, lob, clp, lC);\n    FsrEasuTapF(aC, aW, vec2( 2, 0)-pp, dir, len2, lob, clp, hC);\n    FsrEasuTapF(aC, aW, vec2( 1, 0)-pp, dir, len2, lob, clp, gC);\n    FsrEasuTapF(aC, aW, vec2( 1, 2)-pp, dir, len2, lob, clp, oC);\n    FsrEasuTapF(aC, aW, vec2( 0, 2)-pp, dir, len2, lob, clp, nC);\n    //------------------------------------------------------------------------------------------------------------------------------\n    // Normalize and dering.\n    pix=min(max4,max(min4,aC/aW));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 c;\n    vec4 con0,con1,con2,con3;\n    \n    // \"rendersize\" refers to size of source image before upscaling.\n    vec2 rendersize = iChannelResolution[0].xy;\n    FsrEasuCon(\n        con0, con1, con2, con3, rendersize, rendersize, iResolution.xy\n    );\n    FsrEasuF(c, fragCoord, con0, con1, con2, con3);\n    fragColor = vec4(c.xyz, 1);\n}", "buffer_a_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stXSWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1503, 1632, 1808, 1853, 1883], [1885, 1885, 1967, 2102, 3550], [3554, 3554, 3581, 3581, 3631], [3633, 3633, 3690, 3740, 4624]], "test": "untested"}
{"id": "NllSDj", "name": "Shepard Noise", "author": "paniq", "description": "Endlessly zooming out of an infinite cosmos of colorful clouds.", "tags": ["zoomer", "shepardtone"], "likes": 28, "viewed": 836, "published": 3, "date": "1626590171", "time_retrieved": "2024-07-30T19:10:30.168883", "image_code": "// from https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec3 getc(vec2 uv, int frame) {\n    vec2 o = hash22(vec2(frame, 0.0));\n    vec2 r = hash22(vec2(frame, 1.0)) * 6.283185;\n    vec2 cs = vec2(cos(r.x), sin(r.x));\n    uv = vec2(dot(uv, cs), dot(uv, cs.yx * vec2(1.0, -1.0)));\n    vec3 col = texture(iChannel0, uv / vec2(1.0, 1.0) - o).rgb;\n    vec3 hsl = rgb2hsl(col);\n    hsl.x += float(frame) * 2.0 / (sqrt(5.0) - 1.0) + uv.x * 0.01;\n    return hsl2rgb(hsl);\n}\n\nvec3 shepard_noise (vec2 uv, float loglevel) {\n    int it = int(loglevel);\n    float m = fract(loglevel);\n\n    const float O = 2.0;\n    const int N = 32;\n    \n    uv *= exp(mix(log(1.0),log(O),m));\n    uv *= 2.0;\n    \n    vec3 w = vec3(0.0);\n    w += mix(getc(uv, it - N), vec3(0.0), m);\n    uv /= O;\n    for (int i = 1; i < N; ++i) {\n        w += getc(uv, it - N + i);\n        uv /= O;\n    }\n    w += mix(vec3(0.0), getc(uv, it), m);\n    \n    w /= float(N);\n    \n    w = pow(vec3(2.0), (w - 0.3)*log2(float(N))*32.0);\n    return w;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord / iResolution.xy)*2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float t = iTime / 4.0;\n    \n    \n    int it = int(t / 8.0);\n    float m = smoothstep(0.0, 1.0, fract(t / 8.0));\n    //float m = fract(t / 8.0);\n    \n    vec2 p0 = hash22(vec2(it, 0))*2.0 - 1.0;\n    float s0 = hash22(vec2(it, 1)).x * 64.0;\n    vec2 p1 = hash22(vec2(it + 1, 0))*2.0 - 1.0;\n    float s1 = hash22(vec2(it + 1, 1)).x * 64.0;\n    vec2 p = mix(p0, p1, m);\n    float s = mix(s0, s1, m);\n    \n    vec3 w = shepard_noise(uv - p, s);\n    \n    fragColor = vec4(pow(ACESFitted(w),vec3(0.4545)),1.0);\n}\n", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ACES fitted\n// from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted(vec3 color)\n{\n    color = color * ACESInputMat;\n\n    // Apply RRT and ODT\n    color = RRTAndODTFit(color);\n\n    color = color * ACESOutputMat;\n\n    // Clamp to [0, 1]\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n\n// from https://www.shadertoy.com/view/lsS3Wc\n\nconst float eps = 0.0000001;\n\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 rgb2hsl( vec3 col )\n{\n    float minc = min( col.r, min(col.g, col.b) );\n    float maxc = max( col.r, max(col.g, col.b) );\n    vec3  mask = step(col.grr,col.rgb) * step(col.bbg,col.rgb);\n    vec3 h = mask * (vec3(0.0,2.0,4.0) + (col.gbr-col.brg)/(maxc-minc + eps)) / 6.0;\n    return vec3( fract( 1.0 + h.x + h.y + h.z ),              // H\n                 (maxc-minc)/(1.0-abs(minc+maxc-1.0) + eps),  // S\n                 (minc+maxc)*0.5 );                           // L\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NllSDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 46, 67, 67, 201], [203, 203, 234, 234, 612], [614, 614, 660, 660, 1148], [1150, 1150, 1207, 1207, 1819]], "test": "untested"}
{"id": "stXSD2", "name": "Ray Casting - Iso, MIP, Emi.Abs.", "author": "Rapideye", "description": "iso surface ray casting with binary search refinement.\nray marching is used to find the entry and exit point of the volume.\nVolumeIntensity() simulates intensity values inside the box instead of a CT scan or so.", "tags": ["raycasting", "compositing", "isosurface", "maximumintensityprojection", "emissionabsorption"], "likes": 2, "viewed": 352, "published": 3, "date": "1626561795", "time_retrieved": "2024-07-30T19:10:31.037561", "image_code": "// original \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// this shader simulates volume ray casting\n// 1) ray march a box to find entry and exit points of the volume\n// 2) ray cast into the volume and use several different compositing techniques\n//    - iso surface with binary search refinement\n//    - maximum/minimum intensity projection\n//    - front to back emission absorption\n//    - switch between them using defines below\n// misc:\n//    - have a look at VolumeIntensity(...)\n\n#define ISO_SURFACE_RAYCASTING true\n#define MAXIMUM_INTENSITY_PROJECTION false\n#define MINIMUM_INTENSITY_PROJECTION false\n#define FRONT_TO_BACK_EMISSION_ABSORPTION false\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S(a, b, x) smoothstep(a, b, x)\n#define T iTime\n\n#define BOX_SIZE 1.\n\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p) - s;\n\treturn length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat GetDist(vec3 p) {\n    return sdBox(p, vec3(BOX_SIZE));\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO = 0.;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 p = ro + rd * dO;\n        float dS = GetDist(p);\n        dO += abs(dS);\n        if(dO > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0.);\n    \n    vec3 n = d - vec3(\n        GetDist(p - e.xyy),\n        GetDist(p - e.yxy),\n        GetDist(p - e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l - p),\n        r = normalize(cross(vec3(0., 1., 0.), f)),\n        u = cross(f, r),\n        c = f * z,\n        i = c + uv.x * r + uv.y * u,\n        d = normalize(i);\n    return d;\n}\n\n// here you can simulate whatever volume intensies you want\n// usually CT or MRI scans or simulations from the real world are used here\nfloat VolumeIntensity(vec3 p) {\n    // p : [0, 1]\n    // try to have no hard edges in intensity here -> would produce \"ugly\" normals\n    \n    // simulate sphere in center of volume with soft fall off at the edge of sphere to avoid \"ugly\" normals\n    float i = S(.6, .4, distance(p, vec3(.5)));\n    // float i = distance(p, vec3(.5)) < .5 ? 1. : 0.; // sphere without soft edge\n    \n    return i;\n}\n\nvec3 CentralDiffGradient(vec3 p, float dt)\n{\n    vec3 a0 = vec3(p.x+dt,p.y,p.z);\n    vec3 b0 = vec3(p.x,p.y+dt,p.z);\n    vec3 c0 = vec3(p.x,p.y,p.z+dt);\n\n    vec3 a1 = vec3(p.x-dt,p.y,p.z);\n    vec3 b1 = vec3(p.x,p.y-dt,p.z);\n    vec3 c1 = vec3(p.x,p.y,p.z-dt);\n\n    vec3 gradient = vec3(\n        VolumeIntensity(a0) - VolumeIntensity(a1),\n        VolumeIntensity(b0) - VolumeIntensity(b1),\n        VolumeIntensity(c0) - VolumeIntensity(c1));\n\n    return normalize(gradient);\n}\n\nvec3 phong(vec3 N, vec3 L, vec3 V, vec3 color, float shininess)\n{\n    // calc. lighting\n    vec3 R = normalize(reflect(-L, N));\n    float diffuse_intensity = max(dot(N, L) * .5 + .5, 0.); // wrapped lambert\n    float specular_intensity = pow(max(dot(V, R), 0.), shininess);\n\n    // calc. final color\n    return (diffuse_intensity + specular_intensity) * color;\n}\n\nvec3 WorldToVolumeCoord(vec3 p, vec3 min_box, vec3 max_box)\n{\n    return (p - min_box) / (max_box - min_box);\n}\n\nstruct EntryExitPoints {\n    vec3 p_front;\n    vec3 p_back;\n    bool volume_hit;\n};\n\nEntryExitPoints FindEntryExitPoints(vec3 ro, vec3 rd) {\n    EntryExitPoints result;\n    result.p_front = vec3(0.);\n    result.p_front = vec3(0.);\n    result.volume_hit = false;\n    \n    float d = RayMarch(ro, rd);\n\n    // check if front face was hit\n    if(d < MAX_DIST) {\n        // front face\n        vec3 p_front = ro + d * rd;\n        \n        // start again at front face with small offset inside the surface\n        // step inside the volume along normal as an alternative instead of just along the ray\n        // might be better at small angles\n        ro = p_front + 5e-2 * rd;\n        d = RayMarch(ro, rd);\n        \n        // check if back face was hit\n        if (d < MAX_DIST) {\n            // back face\n            vec3 p_back = ro + d * rd;\n            \n            // return valid result if front and back was found\n            result.p_front = p_front;\n            result.p_front = p_front;\n            result.volume_hit = true;\n        }\n    }\n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\tvec2 m = iMouse.xy / iResolution.xy;\n\n    vec3 ro = vec3(0., 3., -3.);\n    ro.yz *= Rot(-m.y * 3.14 + 1.);\n    ro.xz *= Rot(-m.x * 6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0.), 1.);\n    vec3 col = vec3(0.);\n\n    // use ray-box intersection instead of ray marching for better performance here\n    EntryExitPoints entry_exit = FindEntryExitPoints(ro, rd);\n\n    if (entry_exit.volume_hit) {\n        vec3 p_front = entry_exit.p_front;\n        vec3 p_back = entry_exit.p_back;\n    \n        // parameters\n        vec3 surface_color = vec3(1., .4, .1);\n        vec3 light_color = vec3(1.);\n        vec3 L = normalize(vec3(1., -1., -1.));\n        vec3 V = normalize(-ro);\n        float shininess = 32.0;\n        float iso_value = .5;\n        int refinement_steps = 10;\n        float step_size = 1e-3;\n\n        // ray cast from p_front to p_back\n        float t = 0.;\n        float t_end = distance(p_front, p_back);\n                \n        // compositing options:\n        // - iso surface ray cast\n        // - maximum/minimum intensity projection\n        // - front to back emission absorption model\n\n        if (ISO_SURFACE_RAYCASTING) {\n        \n            while (t < t_end) {\n                // position in world space\n                vec3 p = p_front + t * rd;\n\n                // position in volume space with volume at origin\n                vec3 coord = WorldToVolumeCoord(p, -vec3(BOX_SIZE), vec3(BOX_SIZE));\n\n                float s = VolumeIntensity(coord);\n\n                // iso surface ray casting with boundary refinement\n                if (s > iso_value) {\n                    // refine position with binary search of iso surface\n                    float t_a = t - step_size;\n                    float t_b = t;\n                    vec3 coord_r = coord;\n                    for (int i = 0; i < refinement_steps; ++i)\n                    {\n                        // binary search position\n                        float t_r = 0.5f * (t_a + t_b);\n                        vec3 p_r = p_front + rd * t_r;\n                        coord_r = WorldToVolumeCoord(p_r, -vec3(BOX_SIZE), vec3(BOX_SIZE));\n\n                        // sample new intensity\n                        float s_r = VolumeIntensity(coord_r);\n\n                        // move left or right boundary for binary search\n                        if (s_r < iso_value)\n                            t_a = t_r;\n                        else\n                            t_b = t_r;\n                    }\n\n                    // get gradient\n                    vec3 N = CentralDiffGradient(coord_r, .5 * step_size);\n\n                    // phong with wrapped lambert\n                    col = phong(N, L, V, surface_color, shininess) * light_color;\n\n                    // debug\n                    //col = coord_r;\n                    //if (uv.x > .0) col = N;\n\n                    // stop, nothing can be seen behind the iso surface if it is fully opaque\n                    break;\n                }\n\n                // step along ray\n                t += step_size;\n            }\n            \n        } else if (MAXIMUM_INTENSITY_PROJECTION) {\n        \n            float max_s = .0;\n            while (t < t_end && max_s < 0.99) { // early ray termination\n                // position in world space\n                vec3 p = p_front + t * rd;\n\n                // position in volume space with volume at origin\n                vec3 coord = WorldToVolumeCoord(p, -vec3(BOX_SIZE), vec3(BOX_SIZE));\n\n                float s = VolumeIntensity(coord);\n                \n                // store maximum intensity\n                max_s = max(max_s, s);\n                \n                // step along ray\n                t += step_size;\n            }\n            col = vec3(max_s);\n            \n        } else if (MINIMUM_INTENSITY_PROJECTION) {\n            \n            float min_s = 1.;\n            while (t < t_end && min_s > .0) { // early ray termination\n                // position in world space\n                vec3 p = p_front + t * rd;\n\n                // position in volume space with volume at origin\n                vec3 coord = WorldToVolumeCoord(p, -vec3(BOX_SIZE), vec3(BOX_SIZE));\n\n                float s = VolumeIntensity(coord);\n                \n                // store minimum intensity\n                min_s = min(min_s, s);\n                \n                // step along ray\n                t += step_size;\n            }\n            col = vec3(min_s);\n            \n        } else if (FRONT_TO_BACK_EMISSION_ABSORPTION) {\n        \n            vec3 C = vec3(.0);\n            float A = .0;\n            while (t < t_end && A < .99) { // early ray termination\n                // position in world space\n                vec3 p = p_front + t * rd;\n\n                // position in volume space with volume at origin\n                vec3 coord = WorldToVolumeCoord(p, -vec3(BOX_SIZE), vec3(BOX_SIZE));\n\n                float s = VolumeIntensity(coord);\n                \n                // classification using a transfer function\n                //vec4 color = TransferFunction(s);\n                vec4 color = vec4(s);\n                color.rgb = surface_color;\n                color.a *= .05;\n                \n                // get gradient\n                vec3 N = CentralDiffGradient(coord, .5 * step_size);\n                \n                // shade\n                color.rgb = phong(N, L, V, color.rgb, shininess);\n                color.a *= step_size * 100.;\n                \n                // front to back emission absorption\n                C += (1. - A) * color.a * color.rgb;\n                A += (1. - A) * color.a;\n                \n                // step along ray\n                t += step_size;\n            }\n            col = C.rgb;\n            \n        } else {\n            // fallback error color as red\n            col = vec3(1., 0., 0.);\n        }\n    }\n    \n    fragColor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stXSD2.jpg", "access": "api", "license": "mit", "functions": [[2056, 2056, 2075, 2075, 2141], [2143, 2143, 2172, 2172, 2257], [2259, 2259, 2282, 2282, 2321], [2323, 2323, 2357, 2357, 2585], [2587, 2587, 2611, 2611, 2808], [2810, 2810, 2860, 2860, 3065], [3067, 3203, 3234, 3448, 3600], [3602, 3602, 3646, 3646, 4079], [4081, 4081, 4146, 4168, 4443], [4445, 4445, 4506, 4506, 4556], [4643, 4643, 4698, 4698, 5629], [5631, 5631, 5688, 5688, 11646]], "test": "ok"}
{"id": "7tXXD2", "name": "Waving Indian Flag", "author": "napsternxg", "description": "Waving Indian Flag. Color info taken from: https://en.wikipedia.org/wiki/Flag_of_India\nInspired from this shader: https://www.shadertoy.com/view/flsXRM\n", "tags": ["animation", "flag", "india"], "likes": 2, "viewed": 436, "published": 3, "date": "1626559288", "time_retrieved": "2024-07-30T19:10:31.898259", "image_code": "vec3 WHITE = vec3(1);\nvec3 BLACK = vec3(0);\nvec3 SAFFRON = vec3(255,153,51)/255.;\nvec3 GREEN = vec3(19,136,8)/255.;\nvec3 BLUE = vec3(0,0,128)/255.;\nfloat PI = radians(180.);\n\n\nfloat get_band(float x, float width,  float smoothing_d){\nreturn smoothstep(0., smoothing_d, x)*smoothstep(0., smoothing_d, -x + width);\n    \n}\n\nvec3 Flag(vec2 uv, float ratio){\n\n// Normalized pixel coordinates (from 0 to 1)\n    \n    \n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n\n    float band = floor(uv.y*3.);\n    \n    col = BLACK;\n    \n    //float flag_region = smoothstep(0., 0.01, band+1.)*smoothstep(0., 0.01, -band + 3.);\n    float flag_region = get_band(band+1., 4., 0.001);\n    \n    float top = flag_region*smoothstep(0., 0.01, band + 3.);\n    col = mix(col, GREEN, top);\n    \n    top = top*smoothstep(0., 0.01, band);\n    col = mix(col, WHITE, top);\n    \n    top = top*smoothstep(0., 0.01, band-1.);\n    col = mix(col, SAFFRON, top);\n    \n    \n    /**\n    if(band < 3. && band > -1.){\n        if (band > 1.){\n            col = SAFFRON;\n        } else if (band > 0.) {\n            col = WHITE;\n        } else if (band > -1.){\n            col = GREEN; \n        }\n    }\n    **/\n    \n    \n    vec2 center = vec2(0.5);\n    vec2 cuv = uv - center;\n    cuv.y = cuv.y*ratio;\n    float d = length(cuv);\n    //float angle = (PI + atan(cuv.y, cuv.x))/2.*PI;\n    float angle = atan(cuv.y, cuv.x)/PI;\n    angle = 12.*angle;\n    angle = fract(angle);\n    \n    float circle_r = 0.09;\n    float circle_w = 0.01;\n    \n    //float circle_rim = smoothstep(0., 0.01, d-circle_r + circle_w)*smoothstep(0., 0.01, d-circle_r);\n    float circle_rim = get_band(d-(circle_r - circle_w), circle_w, 0.001);\n    col = mix(col, BLUE, circle_rim);\n    \n    /**\n    if(d > circle_r - circle_w && d < circle_r){\n        col = BLUE;\n    }\n    **/\n    \n    col = mix(col, BLUE, smoothstep(0., 0.001, -d+0.01));\n    /**\n    if(d < 0.01){\n        col = BLUE;\n    }\n    **/\n    \n    \n    col = mix(col, BLUE, smoothstep(0., 0.001, -d+circle_r)*get_band(angle-0.8, 0.2, 0.01));\n    \n    /**\n    if(d < circle_r && angle > 0.8){\n        col = BLUE;\n    }\n    **/\n    \n    col = mix(BLACK, col, flag_region);\n    \n    return col;\n\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float t = uv.x*7. - 2.*iTime + uv.y*3.;\n    \n    uv.y += sin(t)*0.03;\n    \n    float ratio = iResolution.y/iResolution.x;\n    vec3 col = Flag(uv, ratio);\n    \n    col *= .9 + cos(t)*0.2;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tXXD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[176, 176, 233, 233, 319], [321, 321, 353, 443, 2229], [2231, 2231, 2288, 2288, 2584]], "test": "untested"}
{"id": "slfXDH", "name": "Floled's Pathtracing", "author": "Floled", "description": "Pathtracing", "tags": ["bruh"], "likes": 1, "viewed": 211, "published": 3, "date": "1626553740", "time_retrieved": "2024-07-30T19:10:32.775913", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 data = texture(iChannel0, uv);\n    vec3 col = data.xyz / data.w; \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define skyboxVisible true\n#define INFINITY 1e9\n#define PI 3.1415926\n#define NUM_SAMPLES 16\n#define NUM_BOUNCES 4\n\nvec2 _Pixel;\nfloat _Seed = 0.0;\nfloat rand() {\n    float result = sin(_Seed / 100.0 * dot(_Pixel * cos(iTime * 53.35342), vec2(12.9898f, 78.233f))) * 43758.5453;\n    _Seed += 1.0;\n    return fract(result);\n}\nfloat rand2(vec2 v) {\n    float result = fract(sin(fract(iTime + v.x + v.y) * 54538.4375 * dot(v, vec2(12.9898, 78.233))) * 43758.5453);\n    return result;\n}\nfloat sdot(vec3 x, vec3 y) {\n    return clamp(dot(x, y), 0.0, 1.0);\n}\nvec3 randPointOnSphere(vec2 seed) {\n    vec2 uv = vec2(fract(rand2(seed)), fract(rand2(seed * 59.24234)));\n    float theta = 2.0 * PI * uv.x;\n    float psi = acos(2.0 * uv.y - 1.0);\n    float x = cos(theta) * sin(psi);\n    float y = sin(theta) * sin(psi);\n    float z = cos(psi);\n    return vec3(x, y, z);\n}\nfloat smoothnessToPhongAlpha(float s)\n{\n    return pow(1000.0, s * s);\n}\nfloat energy(vec3 color)\n{\n    return (color.x + color.y + color.z) / 3.0;\n}\n\nstruct Sphere {\n    vec3 pos;\n    float radius;\n    int materialID;\n};\nstruct Box {\n    vec3 size;\n    vec3 pos;\n    int materialID;\n};\nstruct AABB {\n    vec3 min;\n    vec3 max;\n    vec3 pos;\n};\nstruct Plane {\n    float y;\n    vec3 normal;\n    int materialID;\n};\nstruct Material {\n    vec3 color;\n    bool emission;\n    float intensity;\n    float ior;\n};\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    vec3 energy;\n};\nstruct HitInfo {\n    vec3 pos;\n    vec3 direction;\n    vec3 normal;\n    float distance;\n    int materialID;\n};\nMaterial materials[4] = Material[4](\n    Material(vec3(0.5, 0.6, 0.8), false, 0.0),\n    Material(vec3(0.7, 0.9, 0.5), false, 0.0),\n    Material(vec3(1.0, 0.7, 0.8), false, 0.0),\n    Material(vec3(1.0, 1.0, 1.0), true, 5.0)\n);\nPlane plane = Plane(-1.0, vec3(0.0, 1.0, 0.0), 0);\nconst int numSpheres = 1;\nconst int numBoxes = 17;\nSphere spheres[numSpheres] = Sphere[numSpheres](\n    Sphere(vec3(0., 5.15, 0.), 1., 1)\n);\nBox boxes[numBoxes] = Box[numBoxes](\n    Box(vec3(.15, 2., .15), vec3(2., 2., 2.), 2),\n    Box(vec3(.15, 2., .15), vec3(-2., 2., 2.), 2),\n    Box(vec3(.15, 2., .15), vec3(-2., 2., -2.), 2),\n    Box(vec3(.15, 2., .15), vec3(2., 2., -2.), 2),\n    Box(vec3(2.15, .15, 2.15), vec3(0., 4., 0.), 2),\n    Box(vec3(.15, 1., .15), vec3(3.5, 1., 1.), 2),\n    Box(vec3(.15, 1., .15), vec3(1.5, 1., 1.), 2),\n    Box(vec3(.15, 1., .15), vec3(1.5, 1., -1.), 2),\n    Box(vec3(.15, 1., .15), vec3(3.5, 1., -1.), 2),\n    Box(vec3(1.15, .15, 1.15), vec3(2.5, 2., 0.), 2),\n    Box(vec3(.15, 1.5, .15), vec3(3.5, 3.5, 0.), 2),\n    Box(vec3(.15, 1.5, .15), vec3(3.5, 3.5, -.5), 2),\n    Box(vec3(.15, 1.5, .15), vec3(3.5, 3.5, .5), 2),\n    Box(vec3(.15, 1.5, .15), vec3(3.5, 3.5, 1.), 2),\n    Box(vec3(.15, 1.5, .15), vec3(3.5, 3.5, -1.), 2),\n    Box(vec3(.15, .15, 1.15), vec3(3.5, 5., 0.), 2),\n    Box(vec3(5.0, .001, 5.0), vec3(0., 9.0, 0.), 3)\n);\n\nbool intersectAABB(in Ray ray, in AABB box, inout float t_min, inout float t_max)\n{\n\tvec3 div = 1.0 / ray.direction;\n\tvec3 t_1 = (box.min - ray.origin);\n\tvec3 t_2 = (box.max - ray.origin);\n    t_1 += box.pos;\n    t_2 += box.pos;\n    t_1 *= div;\n    t_2 *= div;\n\tvec3 t_min2 = min(t_1, t_2);\n\tvec3 t_max2 = max(t_1, t_2);\n\n\tt_min = max(max(t_min2.x, t_min2.y), max(t_min2.z, t_min));\n\tt_max = min(min(t_max2.x, t_max2.y), min(t_max2.z, t_max));\n\n\treturn t_min < t_max;\n}\nvoid intersectBox(Ray ray, inout HitInfo rayHit, int boxID)\n{\n    Box box = boxes[boxID];\n    AABB boxAABB = AABB(-box.size, box.size, box.pos);\n\tfloat t_min = 0.0;\n\tfloat t_max = INFINITY;\n\tif(intersectAABB(ray, boxAABB, t_min, t_max)) {\n        if (t_min < rayHit.distance) {\n            vec3 p = ray.origin + ray.direction * t_min;\n            p -= box.pos;\n            p /= box.size;\n            if(abs(p.x) > abs(p.y)) {\n                if(abs(p.x) > abs(p.z)) {\n                    rayHit.normal = vec3(p.x > 0.0 ? 1.0 : -1.0, 0, 0);\n                }\n                else {\n                    rayHit.normal = vec3(0, 0, p.z > 0.0 ? 1.0 : -1.0);\n                }\n            }\n            else if(abs(p.y) > abs(p.z)) {\n                rayHit.normal = vec3(0, p.y > 0.0 ? 1.0 : -1.0, 0);\n            }\n            else {\n                rayHit.normal = vec3(0, 0, p.z > 0.0 ? 1.0 : -1.0);\n            }\n            rayHit.distance = t_min;\n            rayHit.pos = ray.origin + ray.direction * t_min;\n            rayHit.materialID = box.materialID;\n        }\n\t}\n}\nvoid intersectSphere(Ray ray, inout HitInfo rayHit, int sphereID)\n{\n    Sphere sphere = spheres[sphereID];\n    vec3 d = ray.origin - sphere.pos;\n    float p1 = -dot(ray.direction, d);\n    float p2sqr = p1 * p1 - dot(d, d) + sphere.radius * sphere.radius;\n    if (p2sqr < 0.0)\n        return;\n    float p2 = sqrt(p2sqr);\n    float t = p1 - p2 > 0.0 ? p1 - p2 : p1 + p2;\n    if (t > 0.0 && t < rayHit.distance)\n    {\n        if (t < rayHit.distance) {\n            rayHit.distance = t;\n            rayHit.pos = ray.origin + ray.direction * t;\n            rayHit.normal = normalize(rayHit.pos - sphere.pos);\n            rayHit.materialID = sphere.materialID;\n        }\n    }\n}\nvoid intersectGroundPlane(Ray ray, inout HitInfo rayHit) {\n    float t = -ray.origin.y / ray.direction.y;\n    if (t > 0.0 && t < rayHit.distance)\n    {\n        rayHit.distance = t;\n        rayHit.pos = ray.origin + t * ray.direction;\n        rayHit.normal = plane.normal;\n        rayHit.materialID = plane.materialID;\n    }\n}\nHitInfo trace(Ray ray) {\n    HitInfo rayHit = HitInfo(vec3(0.), ray.direction, vec3(0.), INFINITY, 0);\n    intersectGroundPlane(ray, rayHit);\n    for (int i = 0; i < numSpheres; i++) {\n        intersectSphere(ray, rayHit, i);\n    }\n    for (int i = 0; i < numBoxes; i++) {\n        intersectBox(ray, rayHit, i);\n    }\n    return rayHit;\n}\nvec3 shade(inout Ray ray, HitInfo hitInfo) {\n    vec3 pos = hitInfo.pos;\n    vec3 dir = normalize(hitInfo.direction);\n    vec3 normal = normalize(hitInfo.normal);\n    if (hitInfo.distance < INFINITY) {\n        Material material = materials[hitInfo.materialID];\n        vec3 diffuse = material.color;\n        ray.origin = pos + normal * 0.001;\n        vec3 reflectionAngle = reflect(ray.direction, normal);\n        float alpha = smoothnessToPhongAlpha(material.smoothness);\n        vec3 rand = randPointOnSphere(dir.xy / iResolution.xy);\n        ray.direction = rand * sign(dot(normal, rand));\n        vec3 specular = vec3(1.0) * (alpha + 2.0) * pow(sdot(ray.direction, reflectionAngle), alpha);\n        if (material.emission) {\n            ray.energy *= material.intensity;\n            return material.color;\n        }\n        if (material.metallic) {\n            ray.energy *= specular;\n            return vec3(0.0);\n        }\n        ray.energy *= mix(diffuse, specular, fresnel);\n        return vec3(0.0);\n    } else {\n        ray.energy *= 0.0;\n        return skyboxVisible ? texture(iChannel1, dir).xyz : vec3(0.0);\n    }\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    _Pixel = fragCoord;\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 translatedUV = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    translatedUV /= 1.7;\n    \n    vec4 data = texture(iChannel0, uv);\n    if (iMouse.z > 0.0 || iMouse.w > 0.0) data = vec4(0.0);\n    \n    vec3 camUp = vec3(0, 1, 0);\n\tvec3 camLookat = vec3(0, 2, 0);\n\n    float mx = iMouse.x / iResolution.x * PI * 2.0 - 0.7;\n\tfloat my = -iMouse.y / iResolution.y * 1.45 + 1.55;\n\tvec3 camPos = vec3(cos(my) * cos(mx), sin(my), cos(my) * sin(mx)) * (18.2);\n\n    if ((dot(iMouse.xy, vec2(1.0)) <= 8.0)) camPos = vec3(12.0, 5.0, 6.0);\n\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + translatedUV.x * sideNorm * (iResolution.x/iResolution.y) + translatedUV.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n    \n    float aspectRatio = iResolution.y / iResolution.x;\n    for (int i = 0; i < NUM_SAMPLES; i++) {\n        float offset = rand2(vec2(float(i) + iTime, float(i) * iTime)) / iResolution.x;\n        vec3 rayDirection = rayVec + offset;\n        rayDirection = normalize(rayDirection);\n        vec3 color;\n        Ray ray = Ray(camPos, rayDirection, vec3(1.0, 1.0, 1.0));\n        for (int j = 0; j < NUM_BOUNCES; j++) {\n            HitInfo tracedRay = trace(ray);\n            color += ray.energy * shade(ray, tracedRay);\n            if (ray.energy == vec3(0.0))\n                break;\n        }\n        data += vec4(color, 1.0);\n    }\n    fragColor = data;\n}", "buffer_a_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slfXDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 203]], "test": "untested"}
{"id": "stXSW2", "name": "Atomata", "author": "Pixdigit", "description": "A basic implementation of simple automata.\nClick to draw and see Buffer A too change the ruleset.", "tags": ["conway", "gameoflife", "cellularautomata", "gridworld"], "likes": 2, "viewed": 251, "published": 3, "date": "1626546470", "time_retrieved": "2024-07-30T19:10:33.636612", "image_code": "// See Buffer A for implementation and tweaking\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = vec4(texture(iChannel0, uv).rgb, 1.);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const int CONWAY = 1;\nconst int ELEMENTARY = 2;\n\n\n//Adjust here\n//--------------------------\nconst float timeStep = 0.01;\nconst int ruleset = ELEMENTARY;\nconst float rule = 30.;\n//--------------------------\n\n\n\nbool fetch(vec2 coord) {\n    vec4 val = texelFetch(iChannel0, ivec2(coord), 0);\n    return val.r > .5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Place pixel below mouse\n    if (length(floor(iMouse.zw) - floor(fragCoord.xy)) < 1.) {\n        fragColor = vec4(1.);\n    } else {\n        // Run ruleset if timestep has been reached\n        if (mod(iTime - iTimeDelta, timeStep) > mod(iTime, timeStep)) { \n\n            // Get neighbour states\n            bool tl = fetch(fragCoord + vec2(-1.,  1.));\n            bool tm = fetch(fragCoord + vec2( 0.,  1.));\n            bool tr = fetch(fragCoord + vec2( 1.,  1.));\n            bool ml = fetch(fragCoord + vec2(-1.,  0.));\n            bool mm = fetch(fragCoord + vec2( 0.,  0.));\n            bool mr = fetch(fragCoord + vec2( 1.,  0.));\n            bool bl = fetch(fragCoord + vec2(-1., -1.));\n            bool bm = fetch(fragCoord + vec2( 0., -1.));\n            bool br = fetch(fragCoord + vec2( 1., -1.));\n\n            int sum = int(tl) + int(tm) + int(tr)\n                    + int(ml) +           int(mr)\n                    + int(bl) + int(bm) + int(br);\n\n            // Apply rule(s)\n            bool alive;\n\n            if (ruleset == CONWAY) {\n                alive = sum == 3 || (alive && sum == 2);\n            } else if (ruleset == ELEMENTARY) {\n                alive = (( tl &&  tm &&  tr) && (mod(rule, 256.) >= 128.))\n                          || (( tl &&  tm && !tr) && (mod(rule, 128.) >=  64.))\n                          || (( tl && !tm &&  tr) && (mod(rule,  64.) >=  32.))\n                          || (( tl && !tm && !tr) && (mod(rule,  32.) >=  16.))\n                          || ((!tl &&  tm &&  tr) && (mod(rule,  16.) >=   8.))\n                          || ((!tl &&  tm && !tr) && (mod(rule,   8.) >=   4.))\n                          || ((!tl && !tm &&  tr) && (mod(rule,   4.) >=   2.))\n                          || ((!tl && !tm && !tr) && (mod(rule,   2.) >=   1.))\n                          //Keep \"seed\" ie. singe pixel at the top\n                          ||(!(tl || tm || tr) && mm);\n            }\n\n            // Store and display result\n            if (alive) {\n                fragColor = vec4(1.);\n            } else {\n                fragColor = vec4(0.);\n            }\n        } else {\n            // Keep previous state\n            fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        }\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stXSW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 106, 156, 253]], "test": "untested"}
{"id": "stfXDj", "name": "Paint Spill 2.0", "author": "jackdavenport", "description": "Remake of my older shader Paint Spill: https://www.shadertoy.com/view/Mst3Rn\n\nI made a lot of improvements, mainly to the scene modelling and also shading. Move mouse left and right to rotate, up and down to zoom. ", "tags": ["light", "raymarcher", "reflections", "paint", "liquid", "spill"], "likes": 8, "viewed": 425, "published": 3, "date": "1626542208", "time_retrieved": "2024-07-30T19:10:34.509278", "image_code": "// if you're having major framerate issues, uncomment the following\n// line to enable low quality mode\n// #define LOW_QUALITY\n\n//\n#ifdef LOW_QUALITY\n    #define MAX_ITER 128\n    #define MAX_BOUNCE 4\n    #define MIN_DIST .001\n    #define MAX_DIST 20.\n#else\n    #define MAX_ITER 256\n    #define MIN_DIST .000001\n    #define MAX_DIST 20.\n    #define MAX_BOUNCE 8\n#endif\n\n\nconst vec3 lightDir = normalize(vec3(-.8,.6,0.));\n\nvec2 scene(vec3 p) {\n    // table\n    vec2 t = vec2(sdCappedCylinder(p, 3., .1), 0.);\n    \n    // paint can\n    vec3 q = p;\n    q.yz = rot2D(q.yz, PI / 2.);\n    q.xy = rot2D(q.xy, .6);\n    q += vec3(.7, .3, -.58);\n    \n    float can = sdCappedCylinder(q, .5, .5);\n    float hole = sdCappedCylinder(q+vec3(0.,-.01,0.), .45, .5);\n    float disp = noise(p*10.) * .003;\n    t = depthTest(t, max(can,-hole)+disp, 1.);\n    \n    // paint\n    q = p-vec3(.2,.1,-.6);\n    float displace = noise(vec3(normalize(q.xz)*4.,0.));\n    float paint = sdRoundedCylinder(q, .6 + .1 * displace, .03, .002 * p.y / .06);\n    t = depthTest(t, paint, 2.);\n    \n    return t;\n}\n\nvec2 raymarch(vec3 ro, vec3 rd) {\n    float t = 0.;\n    float id = -1.;\n    for(int i = 0; i < MAX_ITER; i++) {\n        vec3 p = ro + rd * t;\n        vec2 d = scene(p);\n        if(d.x < MIN_DIST || t > MAX_DIST) break;\n        t += d.x;\n        id = d.y;\n    }\n    return vec2(t,id);\n}\n\nvec3 normal(vec3 p, float t) {\n    vec2 e = vec2(t * .00001, 0.);\n    vec3 n = vec3(\n        scene(p+e.xyy).x-scene(p-e.xyy).x,\n        scene(p+e.yxy).x-scene(p-e.yxy).x,\n        scene(p+e.yyx).x-scene(p-e.yyx).x\n    );\n    return normalize(n);\n}\n\n// Source: https://iquilezles.org/articles/rmshadows\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = scene(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nvoid material(inout Material mat, float id, vec3 p, vec3 n) {\n    if(id == 0.) {\n        mat.diffuse  = tex3D(p * .5, n, iChannel0).rgb;\n        mat.specular = vec3(1.);\n        mat.shine    = 10.;\n        mat.reflec   = .2;\n    } else if(id == 1.) {\n        mat.diffuse  = n * .5 + .5;\n        mat.specular = vec3(1.);\n        mat.shine    = 70.;\n        mat.reflec   = .8;\n    } else if(id == 2.) {\n        float rnd = noise(p*3.5);\n        vec3 col = mix(vec3(.2,.7,.4),vec3(.8,.2,.5),rnd);\n        mat.diffuse  = col * .9;\n        mat.specular = col * 1.5;\n        mat.shine    = 50.;\n        mat.reflec   = .5;\n    }\n}\n\nvec3 shade(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.);\n    vec3 mask = vec3(1.);\n    \n    for(int i = 0; i < MAX_BOUNCE; i++) {\n        vec2 t = raymarch(ro, rd);\n\n        // did the ray hit anything?\n        if(t.x < MAX_DIST) {\n            // calculate position and normal\n            vec3 p = ro + rd * t.x;\n            vec3 n = normal(p, t.x);\n            vec3 r = normalize(reflect(rd, n));\n\n            // get material data\n            Material mat;\n            material(mat, t.y, p, n);\n\n            // output the color\n            float shad = softshadow(p, lightDir, .02, MAX_DIST, 20.);\n            float diff = max(0.,dot(lightDir,n)) * shad;\n            float spec = pow(max(0.,dot(lightDir,r)),mat.shine) * shad;\n            \n            vec3 light = mat.diffuse * diff + mat.specular * spec;\n            col += light * mask * (1. - mat.reflec);\n            \n            // if this surface is reflective, change\n            // the ray for the next bounce\n            if(mat.reflec > 0.) {\n                mask *= mat.reflec * mat.specular;\n                rd = r;\n                ro = p + rd * .001;\n            } else {\n                break;\n            }\n        } else {\n            // ray hit nothing, output the background and\n            // stop further bounces\n            if(i < 1) col += texture(iChannel2, rd, 1.7).rgb * mask;\n            else col += texture(iChannel1, rd).rgb * mask;\n            break;\n        }\n    }\n    \n    return col;  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    vec3 ro = vec3(0.,1.,-5.);\n    vec3 rd = vec3(uv, 1.);\n    \n    float a = iTime * .2;\n    if(iMouse.xy != vec2(0.)) {\n        a = PI * ((2. * iMouse.x / iResolution.x) - 1.);\n        ro *= .2 + .8 * (iMouse.y / iResolution.y);\n    }\n    ro.xz = rot2D(ro.xz, a);\n    rd.xz = rot2D(rd.xz, a);\n    \n    fragColor.rgb = shade(ro, normalize(rd));\n    fragColor.w   = 1.;\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159265359\n\nstruct Material {\n    vec3 diffuse;\n    vec3 specular;\n    float shine;\n    float reflec;\n};\n\nvec2 rot2D(vec2 p, float a) {\n    float s = sin(a), c = cos(a);\n    mat2 m  = mat2(c,s,-s,c);\n    return m * p;\n}\n\nvec2 depthTest(vec2 a, float bt, float bi) {\n    if(a.x < bt) return a;\n    else return vec2(bt, bi);\n}\n\n// 3d texture sampler by reinder (thanks!)\n// Source: https://www.shadertoy.com/view/4dj3Dw\nvec4 tex3D( in vec3 pos, in vec3 normal, sampler2D sampler )\n{\n\treturn \ttexture( sampler, pos.yz )*abs(normal.x)+ \n\t\t\ttexture( sampler, pos.xz )*abs(normal.y)+ \n            texture( sampler, pos.xy )*abs(normal.z);\n}\n\n// Source: https://iquilezles.org/articles/distfunctions\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n// Source: https://www.shadertoy.com/view/4sfGzS\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stfXDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[420, 420, 440, 453, 1071], [1073, 1073, 1106, 1106, 1358], [1360, 1360, 1390, 1390, 1606], [1608, 1661, 1738, 1738, 1955], [1957, 1957, 2018, 2018, 2580], [2582, 2582, 2612, 2612, 4052], [4054, 4054, 4111, 4111, 4548]], "test": "untested"}
{"id": "ftXSW2", "name": "Unique Yonic", "author": "xenn", "description": "Check mouse! \n\nhttps://xemantic.github.io/shader-web-background/\n \nGoal: shadertoy-style shaders in regular web development\n", "tags": ["mouse", "background", "shadertoy", "feedback", "integration", "library", "web", "webdevelopment", "webdev", "javascript"], "likes": 13, "viewed": 440, "published": 3, "date": "1626516733", "time_retrieved": "2024-07-30T19:10:35.579417", "image_code": "// Fork of \"Smooth Soft Colours\" by xenn. https://shadertoy.com/view/7tXSzs\n// 2021-07-17 10:10:52\n\n// Fork of \"soft Colour\" by None. https://shadertoy.com/view/-1\n// 2021-07-14 22:40:15\n\n// Fork of \"soft Colour\" by xenn. https://shadertoy.com/view/NtfXD7\n// 2021-07-14 22:39:31\n\n// Postprocess copied with some small modifications from Mattias: https://www.shadertoy.com/view/Ms23DR\n\nvec2 curve(vec2 uv)\n{\n\tuv = (uv - 0.5) * 2.0;\n\tuv *= 1.1;\t\n\tuv.x *= 1.0 + pow((abs(uv.y) / 5.0), 3.0);\n\tuv.y *= 1.0 + pow((abs(uv.x) / 4.0), 3.0);\n\tuv  = (uv / 2.0) + 0.5;\n\tuv =  uv *0.92 + 0.04;\n\treturn uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 uv = curve( q );\n    vec3 oricol = texture( iChannel0, vec2(q.x,q.y) ).xyz;\n    vec3 col;\n    vec3 sha = texture( iChannel1, vec2(q.x,q.y) ).xyz;\n   \n\tfloat x =  sin(0.3*iTime+uv.y*21.0)*sin(0.7*iTime+uv.y*29.0)*sin(0.3+0.33*iTime+uv.y*31.0)*0.0005 ;\n\n    col.r = texture(iChannel0,vec2(x+uv.x+0.001,uv.y+0.001)).x+0.05;\n    col.g = texture(iChannel0,vec2(x+uv.x+0.000,uv.y-0.002)).y+0.05;\n    col.b = texture(iChannel0,vec2(x+uv.x-0.002,uv.y+0.000)).z+0.05;\n    col.r += 0.08*texture(iChannel0,0.75*vec2(x+0.025, -0.027)+vec2(uv.x+0.001,uv.y+0.001)).x;\n    col.g += 0.05*texture(iChannel0,0.75*vec2(x+-0.022, -0.02)+vec2(uv.x+0.000,uv.y-0.002)).y;\n    col.b += 0.08*texture(iChannel0,0.75*vec2(x+-0.02, -0.018)+vec2(uv.x-0.002,uv.y+0.000)).z;\n    \n    float vig = (0.0 + 1.0*16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y));\n\tcol *= vec3(pow(vig,0.15));\n\n    col *= vec3(0.9,1.1,0.9);\n    \n\tfloat scans = clamp( 0.35+0.05*sin(3.5*iTime+uv.y*iResolution.y*1.5), 0.0, 1.0);\n\t\n\tfloat s = pow(scans,0.75);\n\tcol = col *vec3(0.4+0.7*s) + (sha * col);\n\n    col *= 1.0+0.035*sin(110.0*(iTime / 4.0));\n\n\tcol*=1.0-0.75*vec3(clamp((mod(fragCoord.x, 2.0)-1.0)*1.0,0.0,1.0));\n\t\n    float comp = smoothstep( 0.1, 0.9, sin(iTime) );\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 p = fragCoord.xy;\n    \n    vec2 uv = (p.xy) / iResolution.xy;\n    \n    //line thickness\n    float th = 0.002;\n    \n    //gradient detection for r,g and b separatly\n    //not sure why I did this actually\n    \n    float gxr = texture(iChannel0, uv.xy+vec2(th, 0.)).r\n    - texture(iChannel0, uv.xy-vec2(th, 0.)).r ;\n    \n    float gyr = texture(iChannel0, uv.xy+vec2(0., th)).r\n    - texture(iChannel0, uv.xy-vec2(0., th)).r;\n    \n    float gxg = texture(iChannel0, uv.xy+vec2(th, 0.)).g\n    - texture(iChannel0, uv.xy-vec2(th, 0.)).g ;\n    \n    float gyg = texture(iChannel0, uv.xy+vec2(0., th)).g\n    - texture(iChannel0, uv.xy-vec2(0., th)).g;\n    \n    float gxb = texture(iChannel0, uv.xy+vec2(th, 0.)).b\n    - texture(iChannel0, uv.xy-vec2(th, 0.)).b;\n    \n    float gyb = texture(iChannel0, uv.xy+vec2(0., th)).b\n    - texture(iChannel0, uv.xy-vec2(0., th)).b;\n    \n    //hack to concea noise from: https://www.shadertoy.com/view/Mdf3zr\n    float gr = gxr*gxr + gyr*gyr;\n    float gg = gxg*gxg + gyg*gyg;\n    float gb = gxb*gxb + gyb*gyb;\n    \n    //more noise control\n    float g = pow((gr+gg+gb)/1.,1.9);\n    \n    \n    vec3 col = texture(iChannel0, p / iResolution.xy).xyz;\n    col = mix(col,  0.5 + 0.5*cos(iTime*4.+uv.y*6.+vec3(0,2,4)),g*100.);\n    \n    fragColor = vec4(col,1.);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n//#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "buffer_b_code": "                                                                                                                                                                                                                                                                                        // See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .001;\nconst float iFeedbackFadeRate         = .993;\nconst float iFeedbackColorShiftZoom   = 0.1;\nconst float iFeedbackColorShiftImpact = .0033;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = .35;\nconst float iBlobEdgeSmoothing        = .0567;\nconst float iBlob1Radius              = .33;\nconst float iBlob1PowFactor           = 20.;\nconst float iBlob1ColorPulseSpeed     = .2;\nconst float iBlob2Radius              = .54;\nconst float iBlob2PowFactor           = 20.;\nconst float iBlob2ColorPulseSpeed     = .0234;\nconst float iBlob2ColorPulseShift     = 1.75;\nconst float iColorShiftOfRadius       = 1.5;\nconst float iFeedbackMouseShiftFactor = .003;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.bg/colorShift.gr - .5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel2, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n   \n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// This buffer is the feedback loop\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Convert the uv's to polar coordinates to scale up  \n    vec2 polarUv = (uv * 2.0 - 1.0);\n    float angle = atan(polarUv.y, polarUv.x);\n    \n    // Scale up the length of the vector by a noise function feeded by the angle and length of the vector\n    float ll = length(polarUv)*0.4915+(0.1*sin(iTime/3.4));\n    \n    vec3 base = texture(iChannel0, uv).rgb;\n    \n    // Convert the scaled coordinates back to cartesian\n    vec2 offs = vec2(cos(angle)*ll + 0.5, sin(angle)*ll + 0.5);\n    \n    // sample the last texture with uv's slightly scaled up\n    vec3 overlay = texture(iChannel1,offs).rgb;\n\n        // Additively blend the colors together\n    vec4 col = vec4(base + overlay*(0.1+(0.1*cos(iTime/2.))), 01.0);\n    \n    fragColor = col;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Fork of \"spirit aura\" by xenn. https://shadertoy.com/view/7lSGzR\n// 2021-06-21 18:20:40\n\n/*\n\tFull Scene Radial Blur\n\t----------------------\n\n\tRadial blur - as a postprocessing effect - is one of the first things I considered doing \n\twhen the multipass system came out. I've always loved this effect. Reminds me of the early \n\tdemos from Aardbei et al. \n\n\tAnyway, Shadertoy user, Passion, did a really cool radial blur on a field of spheres that\n\tinspired me to do my own. Radial blurs are pretty straight forward, but it was still\n    helpful to have Passion's version as a guide. \n\n    As for the radial blur process, there's not much to it. Start off at the pixel position, \n    then radiate outwards gathering up pixels with decreased weighting. The result is a\n\tblurring of the image in a radial fashion, strangely enough. :)\n\n\tInspired by:\n\n\tBlue Dream - Passion\n\thttps://www.shadertoy.com/view/MdG3RD\n\n\tRadial Blur - IQ\n\thttps://www.shadertoy.com/view/4sfGRn\n\n\tRays of Blinding Light - mu6k\n\thttps://www.shadertoy.com/view/lsf3Dn\n\n*/\n\n// The radial blur section. Shadertoy user, Passion, did a good enough job, so I've used a\n// slightly trimmed down version of that. By the way, there are accumulative weighting \n// methods that do a slightly better job, but this method is good enough for this example.\n\n\n// Radial blur samples. More is always better, but there's frame rate to consider.\nconst float SAMPLES = 24.; \n\n\n// 2x1 hash. Used to jitter the samples.\nfloat hash( vec2 p ){ return fract(sin(dot(p, vec2(41, 289)))*45758.5453); }\n\n\n// Light offset.\n//\n// I realized, after a while, that determining the correct light position doesn't help, since \n// radial blur doesn't really look right unless its focus point is within the screen boundaries, \n// whereas the light is often out of frame. Therefore, I decided to go for something that at \n// least gives the feel of following the light. In this case, I normalized the light position \n// and rotated it in unison with the camera rotation. Hacky, for sure, but who's checking? :)\nvec3 lOff(){    \n    \n    vec2 u = sin(vec2(1.57, 0) - iTime/2.);\n    mat2 a = mat2(u, -u.y, u.x);\n    \n    vec3 l = normalize(vec3(1.5, 1., -0.5));\n    l.xz = a * l.xz;\n    l.xy = a * l.xy;\n    \n    return l;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // Screen coordinates.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Radial blur factors.\n    //\n    // Falloff, as we radiate outwards.\n    float decay = 0.97; \n    // Controls the sample density, which in turn, controls the sample spread.\n    float density = 0.5; \n    // Sample weight. Decays as we radiate outwards.\n    float weight = 0.1; \n    \n    // Light offset. Kind of fake. See above.\n    vec3 l = lOff();\n    \n    // Offset texture position (uv - .5), offset again by the fake light movement.\n    // It's used to set the blur direction (a direction vector of sorts), and is used \n    // later to center the spotlight.\n    //\n    // The range is centered on zero, which allows the accumulation to spread out in\n    // all directions. Ie; It's radial.\n    vec2 tuv =  uv - .5 - l.xy*.45;\n    \n    // Dividing the direction vector above by the sample number and a density factor\n    // which controls how far the blur spreads out. Higher density means a greater \n    // blur radius.\n    vec2 dTuv = tuv*density/SAMPLES;\n    \n    // Grabbing a portion of the initial texture sample. Higher numbers will make the\n    // scene a little clearer, but I'm going for a bit of abstraction.\n    vec4 col = texture(iChannel0, uv.xy)*0.25;\n    \n    // Jittering, to get rid of banding. Vitally important when accumulating discontinuous \n    // samples, especially when only a few layers are being used.\n    uv += dTuv*(hash(uv.xy + fract(iTime))*2. - 1.);\n    \n    // The radial blur loop. Take a texture sample, move a little in the direction of\n    // the radial direction vector (dTuv) then take another, slightly less weighted,\n    // sample, add it to the total, then repeat the process until done.\n    for(float i=0.; i < SAMPLES; i++){\n    \n        uv -= dTuv;\n        col += texture(iChannel1, uv) * weight;\n        weight *= decay;\n        \n    }\n    \n    // Multiplying the final color with a spotlight centered on the focal point of the radial\n    // blur. It's a nice finishing touch... that Passion came up with. If it's a good idea,\n    // it didn't come from me. :)\n    col *= (1. - dot(tuv, tuv)*.75);\n    \n    // Smoothstepping the final color, just to bring it out a bit, then applying some \n    // loose gamma correction.\n    fragColor = sqrt(smoothstep(0., 1., col));\n    \n    // Bypassing the radial blur to show the raymarched scene on its own.\n    //fragColor = sqrt(texture(iChannel0, fragCoord.xy / iResolution.xy));\n}\n\n", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXSW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[385, 385, 406, 406, 594], [596, 596, 653, 653, 1948]], "test": "untested"}
{"id": "NlXXDj", "name": "Fractal 60_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 15, "viewed": 542, "published": 3, "date": "1626515636", "time_retrieved": "2024-07-30T19:10:36.409199", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=0.;\n        ++i<90.;\n        O.xyz+=mix(vec3(1),H(length(p)*3.),.6)*.015*exp(-8.*i*i*e)\n    )\n    {\n        p=g*d;\n        p=R(p,vec3(.577),iTime*.1);\n        p.z-=iTime;\n        s=6.;\n        p=abs(fract(p*.5)-.5);\n        p=R(p,p/p,.3);\n        for(int i=0;i++<8;)\n            p=.92-abs(p-.81),\n            s*=e=1.3/dot(p,p)-.03,\n            p*=e;\n        g+=e=(dot(p,p/p)-1.1)/s-.002;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXXDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 650]], "test": "untested"}
{"id": "NlfSDj", "name": "Concrete Jungle", "author": "yasuo", "description": "Concrete Jungle", "tags": ["concrete"], "likes": 14, "viewed": 366, "published": 3, "date": "1626510162", "time_retrieved": "2024-07-30T19:10:37.219033", "image_code": "// All the distance functions from:https://iquilezles.org/articles/distfunctions\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 256\n#define MAX_DIST 200.\n#define SURF_DIST .0001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n#define EDGE_WIDTH 0.01\n\n#define MATERIAL_DIFFUSE0 0\n#define MATERIAL_REFLECT 10\n\nfloat edge;\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// https://iquilezles.org/articles/fbmsdf\n// https://www.shadertoy.com/view/3dGSWR\nfloat sph( vec3 i, vec3 f, vec3 c )\n{\n    // random radius at grid vertex i+c (please replace this hash by\n    // something better if you plan to use this for a real application)\n    vec3  p = 17.0*fract( (i+c)*0.3183099+vec3(0.11,0.17,0.13) );\n    float w = fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n    float r = 0.8*w*w;\n    // distance to sphere at grid vertex i+c\n    return sdBox((f-c),vec3(r));\n}\n\n// https://iquilezles.org/articles/fbmsdf\nfloat sdBase( in vec3 p , bool animate)\n{\n    float t = iTime*2.0;\n    //if(animate)p.y-=t;\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    return min(min(min(sph(i,f,vec3(0,0,0)),\n                       sph(i,f,vec3(0,0,1))),\n                   min(sph(i,f,vec3(0,1,0)),\n                       sph(i,f,vec3(0,1,1)))),\n               min(min(sph(i,f,vec3(1,0,0)),\n                       sph(i,f,vec3(1,0,1))),\n                   min(sph(i,f,vec3(1,1,0)),\n                       sph(i,f,vec3(1,1,1)))));\n}\n\n\nvec2 GetDist(vec3 p) {\n    float t = iTime*6.0;\n    p.z+=t;\n    \n    vec3 prevP = p;\n    float d = sdBase(p,true);\n    float d2 = sdBase(p,false);\n    \n    p.xz = mod(p.xz,20.0)-10.0;\n    float b = sdBox(p,vec3(3.0,10.0,3.0));\n    \n    d = max(b,-d);\n    d2 = min(max(-p.y+10.0,-d2),max(p.y+10.0,-d2));\n   \n    vec2 res = vec2(min(d,d2)*0.5, MATERIAL_DIFFUSE0);\n       \n    vec2 model = res;\n    return model;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side) {\n    vec2 dO = vec2(0.0);\n    float lastDistEval = 1e10;\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if (lastDistEval < EDGE_WIDTH && dS.x > lastDistEval + 0.001) {\n\t\t\tedge = 1.0;\n\t\t}\n        if (dS.x < lastDistEval) lastDistEval = dS.x;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n   \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n   \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n   \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 col) {\n    float dif = dot(n,normalize(vec3(1,2,3)))*0.5+0.5;\n    return vec3(dif)*col;\n}\n\nvec3 reflectMaterial(vec3 p, vec3 rd, vec3 n) {\n    vec3 r = reflect(rd,n);\n    vec3 col = r;\n   \n    float k = r.y*2.5+2.5;\n    col = mix(col*vec3(0.5),vec3(0.5),k);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n   \n    vec3 ro = vec3(0, 2, -3.5);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-30.0));\n    //ro.xz *= Rot(radians(180.0));\n    \n    if(mod(iTime,20.0)<17.0){\n        ro.xz *= Rot(-iTime*.1+1.0);\n    } else {\n        ro.xz *= Rot(radians(180.0));\n    }\n    \n    #endif\n   \n    vec3 rd = R(uv, ro, vec3(0,0,0), 3.0);\n    vec2 d = RayMarch(ro, rd, 1.);\n    vec3 col = vec3((map(uv.y,0.0,1.0,1.0,0.5))-0.6);\n   \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd,n);\n       \n        int mat = int(d.y);\n        if(mat == MATERIAL_DIFFUSE0){\n            col = diffuseMaterial(n,vec3(1.0));\n        } else if(mat == MATERIAL_REFLECT) {\n            col = reflectMaterial(p,rd,n);\n        }\n\n    }\n   \n    // gamma correction\n    col = pow( col, vec3(0.6545) );\n    col = mix(col,vec3(0.3,0.3,0.3),edge);\n   \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlfSDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[608, 608, 680, 680, 746], [748, 748, 779, 779, 870], [872, 955, 992, 1133, 1352], [1354, 1396, 1437, 1437, 1902], [1905, 1905, 1927, 1927, 2316], [2318, 2318, 2363, 2363, 2811], [2813, 2813, 2837, 2837, 3036], [3038, 3038, 3080, 3080, 3275], [3277, 3277, 3317, 3317, 3400], [3402, 3402, 3449, 3449, 3586], [3588, 3588, 3645, 3645, 4719]], "test": "untested"}
{"id": "NtXXWj", "name": "Rotating light house/spotlight", "author": "napsternxg", "description": "If you need to shoot a video like girls like you by Maroon 5, you would need a spotlight rotating around the subject (black dot) like this. Now you can also imagine a bouncing effect for the spotlight\n", "tags": ["introduction"], "likes": 1, "viewed": 265, "published": 3, "date": "1626502074", "time_retrieved": "2024-07-30T19:10:37.980996", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 center = vec2(0.5, 0.5);\n    float tr = 0.2;\n    vec2 time_offset = vec2(tr*cos(iTime), tr*sin(iTime));\n    \n    vec2 tcenter = center + time_offset;\n    \n    vec2 tuv = uv - tcenter;\n    \n    \n    float dist = length(tuv);\n    float tlen = length(time_offset);\n    float tproj = dot(tuv, time_offset)/(dist*tlen);\n    \n    \n    vec3 col = vec3(0.8, 0.5, 0.1);\n    float alpha = 1.0;\n    \n    if(dist > 0.1*abs(cos(iTime))){\n        //col = vec3(abs(time_offset/tr)*0.5, 0.2*abs(cos(iTime)));\n        col = vec3(0.2*abs(cos(iTime)), 0.5*abs(cos(iTime)), 0.5*abs(cos(iTime)));\n    }\n    \n    if(tproj < (-0.99 -0.01*sin(iTime/2.0)) && tproj >= -1.0){\n        col = vec3(0.9, 0.9, 0.5);\n        alpha = 0.2;\n    }\n    \n    \n    if(dist < 0.01){\n        col = vec3(1, 1, 0.2);\n        alpha = 1.0;\n    }\n    \n    if(distance(uv, center) < 0.01){\n        col = vec3(0.2, 0.2, 0.2);\n        alpha = 1.0;\n    }\n    \n\n    \n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,alpha);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtXXWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1228]], "test": "untested"}
{"id": "7lsXDB", "name": "Creation Copy/Edit", "author": "AlijahT", "description": "Credits to Danilo Guanabara & Comment section of their post", "tags": ["shader"], "likes": 2, "viewed": 236, "published": 3, "date": "1626491917", "time_retrieved": "2024-07-30T19:10:38.742959", "image_code": "// LITERALLY A COPY OF https://www.shadertoy.com/view/XsXXDn\n// small edits on lines 23 & 24 and a new line after 21 credits go to comment section on original shader\n\n\n\n// http://www.pouet.net/prod.php?which=57245\n// If you intend to reuse this shader, please add credits to 'Danilo Guanabara'\n\n#define t iTime\n#define r iResolution.xy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec3 c;\n\tfloat l,z=t;\n\tfor(int i=0;i<3;i++) {\n\t\tvec2 uv,p=fragCoord.xy/r;\n\t\tuv=p;\n\t\tp-=.5;\n\t\tp.x*=r.x/r.y;\n\t\tz+=.07;\n\t\tl=length(p);\n        l*=l;\n\t\tuv+=p/l*(sin(z)+1.)*abs(sin(l*9.-z*4.));\n\t\tc[i]=.05/length(abs(mod(uv,1.)-1.5));\n\t}\n\tfragColor=vec4(c/l,t);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lsXDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[337, 337, 393, 393, 652]], "test": "untested"}
{"id": "7lsXWB", "name": "Another Face-21-jul-", "author": "jorge2017a1", "description": "Another Face-21-jul-", "tags": ["anotherface21jul"], "likes": 6, "viewed": 239, "published": 3, "date": "1626482117", "time_retrieved": "2024-07-30T19:10:39.702393", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opI2(d1, d2) ( d1.x > d2.x ? d1 : d2 )\n#define opS2(d1, d2) ( d1.x > -d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\nfloat sdTorus( vec3 p, vec2 t )\n\t{ vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }\nfloat sdCylinder( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n    \nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat sMin( float a, float b, float k )\n{\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.-h);\n}\nfloat sMax(in float x, in float y, in float s)\n{\n    float b = clamp(abs(x-y)/s, 0.0, 1.0);\n    return max(x,y) + 0.25 * s * (b - 1.0) * (b - 1.0);\n}\n\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    float planeDist2 = 50.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    float planeDist5 = -p.z+40.0;  //pared frente\n    float planeDist6 = p.z+40.0;  //pared atras\n    \n    res =opU3(res, vec3(planeDist1,-1.0,7.0)); //inf\n    \n    res =opU3(res, vec3(planeDist2,14.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist3,-1.0,9.0)); \n    res =opU3(res, vec3(planeDist4,-1.0,9.0)); \n    res =opU3(res, vec3(planeDist5,-1.0 ,8.0)); \n    //res =opU3(res, vec3(planeDist5,100.0 ,-1.0));\n    res =opU3(res, vec3(planeDist6,16.0,MATERIAL_NO)); \n    \n    float vmi=mix( -5.0,40.0, sin(iTime));\n    p=rotate_y(p, radians( vmi) );\n    mObj.AngRot=radians( vmi);\n    \n          p.y=p.y-10.0;\n   \n    float sdCabeza= sdEllipsoid( p, vec3(6.5,8.0,5.0) );\n    \n    float sdPelo= sdEllipsoid( p, vec3(7.6,8.0,7.6) );\n    float sdPeloMordida= sdEllipsoid( p-vec3(0.0,-1.0,-5.5), vec3(5.0,4.5,3.0) );\n    \n    float sdCuadradoPelo=sdBox( p-vec3(0.0,-11.0,0.0), vec3(7.7,7.0,7.7) );\n    float sdPeloDif=differenceSDF(sdPelo,sdCuadradoPelo);\n    sdPeloDif=differenceSDF(sdPeloDif,sdPeloMordida);\n    \n    res =opU3(res, vec3(sdPeloDif,-1.0,10.0));\n    \n    //Frente\n    float  sdFrente= sdCylinder(p-vec3(0.0,3.0,0.0), vec2(5.5,2.0) );\n    res =opU3(res, vec3(sdFrente,3.0,MATERIAL_NO)); \n    \n    //Oyos Ojos\n    float sdOyoIzq= sdEllipsoid( p-vec3(-2.5,-0.5,-4.5), vec3(2.0,1.5,1.0) );\n    float sdOyoDer= sdEllipsoid( p-vec3( 2.5,-0.5,-4.5), vec3(2.0,1.5,1.0) );\n    \n    sdCabeza= differenceSDF(sdCabeza, sdOyoIzq);\n    sdCabeza= differenceSDF(sdCabeza, sdOyoDer);\n    \n    ///ojos\n    float sdOjoIzq= sdEllipsoid( p-vec3(-2.5,-0.5,-4.0), vec3(1.8,1.4,0.9) );\n    float sdOjoDer= sdEllipsoid( p-vec3( 2.5,-0.5,-4.0), vec3(1.8,1.4,0.9) );\n    \n    //restar cilindro a ojos y poner en negro uno nuevo\n    float sdPupilaIzq=sdCylinderXY(p-vec3(-2.5,-0.65,-3.5), vec2(0.2,2.0) );\n    float sdPupilaDer=sdCylinderXY(p-vec3( 2.5,-0.65,-3.5), vec2(0.2,2.0) );\n    float sdOjoIzqInter=intersectSDF( sdOjoIzq,sdPupilaIzq);\n    float sdOjoDerInter=intersectSDF( sdOjoDer,sdPupilaDer);\n    \n    float sdOjoIzqDif=differenceSDF( sdOjoIzq,sdPupilaIzq);\n    float sdOjoDerDif=differenceSDF( sdOjoDer,sdPupilaDer);\n     sdOjoIzq=sdOjoIzqDif;\n     sdOjoDer=sdOjoDerDif;\n    \n    \n    res =opU3(res, vec3(sdOjoIzqInter,0.0,MATERIAL_NO));\n    res =opU3(res, vec3(sdOjoIzq,1.0,MATERIAL_NO));\n    \n    res =opU3(res, vec3(sdOjoDerInter,0.0,MATERIAL_NO));\n    res =opU3(res, vec3(sdOjoDer,1.0,MATERIAL_NO));\n    \n\n    \n    //Nariz\n    vec3 prot0=p;\n    prot0.yz= rotatev2(p.yz, radians(350.0));  //inclinado hacia adelante\n    float sNariz1= sdCylinderXZ(prot0-vec3(0.0,-1.5,-5.3), vec2(0.2,1.5) );\n    vec3 pn=p-vec3(0.0,1.0,0.0);\n    vec3 prot1=pn;\n    vec3 prot2=pn;\n     prot1.xy= rotatev2(pn.xy, radians(15.0)); //lado izq\n     prot2.xy= rotatev2(pn.xy, radians(345.)); //lado derecho\n     \n    \n    float sNariz1Izq= sdCylinderXZ(prot1-vec3( 0.1,-1.5,-5.2), vec2(0.18,1.5) );\n    float sNariz1Der= sdCylinderXZ(prot2-vec3(-0.1,-1.5,-5.2), vec2(0.18,1.5) );\n    \n    res =opU3(res, vec3(sNariz1,2.0,MATERIAL_NO));\n    \n    //suavizar frente\n    sdCabeza= smin( sdCabeza, sdFrente, 2.0);\n    sdCabeza= smin( sdCabeza, sNariz1, 1.5);\n    \n    \n    sdCabeza= smin( sdCabeza, sNariz1Izq, 0.8);\n    sdCabeza= smin( sdCabeza, sNariz1Der, 0.8);\n    \n    p=p-vec3(0.0,0.5,0.0);  //subir labios\n    //Labio Izquierdo\n    float r1; float r2; float h;\n    r1=0.05; r2=0.3; h=1.7;\n    pn=p-vec3(0.15,0.0,0.5); //unir mas cerca labios\n    prot1=rotate_z(pn-vec3(-2.0+0.1,-4.5,-4.5), radians(70.0));\n    prot2=rotate_z(pn-vec3(-2.0,    -4.5,-4.5), radians(86.0));\n    \n    //rotar hacia un lado de afuera\n    prot1=rotate_x(prot1, radians(20.0));\n    prot2=rotate_x(prot2, radians(20.0));\n    float sdLabioIzqA= sdRoundCone( prot1-vec3(0.0,0.0,0.0), r1, r2, h );\n    float sdLabioIzqB= sdRoundCone( prot2-vec3(0.0,0.0,0.0), r1, r2, h );\n    \n    \n    \n    //----labio derecho\n    pn=p-vec3(-0.15,0.0,0.5);\n    prot1=rotate_z(pn-vec3(2.0-0.2,-4.5,-4.5), radians(270.0+2.0));\n    prot2=rotate_z(pn-vec3(2.0-0.2,-4.5,-4.5), radians(286.0+2.0));\n    \n    //rotar hacia un lado de afuera\n    prot1=rotate_x(prot1, radians(20.0));\n    prot2=rotate_x(prot2, radians(20.0));\n    float sdLabioDerA= sdRoundCone( prot1-vec3(0.0,0.0,0.0), r1, r2, h );\n    float sdLabioDerB= sdRoundCone( prot2-vec3(0.0,0.0,0.0), r1, r2, h );\n    \n    res =opU3(res, vec3(sdCabeza,16.0,MATERIAL_NO));\n    res =opU3(res, vec3(sdLabioDerA,2.0,MATERIAL_NO));\n    res =opU3(res, vec3(sdLabioDerB,2.0,MATERIAL_NO));\n    res =opU3(res, vec3(sdLabioIzqA,2.0,MATERIAL_NO));\n    res =opU3(res, vec3(sdLabioIzqB,2.0,MATERIAL_NO));\n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n///-----------------------------\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\n\n\nvec3 LightShadingV2(vec3 normal,vec3 p, vec3 ro,vec3 rd, vec3 plight_pos,vec3 color)\n{   \n    vec3 final = vec3( 0.0 );\n    float shininess = 64.;\n\tvec3 l = normalize( p-plight_pos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    \n    vec3 lightDir = normalize(plight_pos);\n    vec3 viewDir = normalize(-rd);  \n    vec3 halfV = normalize(viewDir + lightDir);\n    float diff = dot(normal, l);\n    \n    vec3 vl = normalize( plight_pos - p );\n    vec3 ref_v = reflect( v, normal );\n    float diffuse  = max( 0.0, dot( vl, normal ) );\n    float specular = max( 0.0, dot( vl, ref_v ) );\n\t\tspecular = pow( specular, shininess );\n\t\tfinal += color * ( diffuse + specular);\n    return  final;\n    \n    \n}   \n\n\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    //result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    result= LightShadingV2( nor, p, ro,rd, plight_pos, colobj);\n    return result;\n}\n///-------------------------------------\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\n// Convert polar coordinates -> rectangular.\nvec2 polar2rect(vec2 polar)\n{\n    float x = polar.x * cos(polar.y);\n    float y = polar.x * sin(polar.y);\n    return vec2(x, y);\n}\n\n\n//https://www.shadertoy.com/view/stXXWn\n///http://glslsandbox.com/e#73908.0\nvec3 espiral( vec2 uv ) \n{\n    float size= 10.0;\n    vec2 cuv = vec2(2.0*length(uv), atan(uv.x, uv.y));\n    cuv.x = mix(cuv.x, 2.0/cuv.x, 0.7);\n    float td = (pow(0.3/length(cuv.x),1.0));\n    float strip1 = step(-sin(size*(cuv.x-cuv.y)), -0.5);\n    float strip2 = step(-sin(size*(cuv.x+cuv.y)), -0.1)*step(sin(size*(cuv.x-cuv.y)), -0.0);\n    return vec3(5.0*(strip1*4.+2.*strip2)*td);\n    \n}\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    if (id_material==5.0)\n    {   float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    return vec3( clamp(d,0.0,1.0) );\n    }\n    \n    \n    if (id_material==6.0)\n    {  float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    vec3 col= vec3( clamp(d,0.0,1.0) );\n        l1= amb(col, 0.5) + col*diff( p,light_pos1, mObj.normal) + col*spec( p, light_pos1,mObj.rd, mObj.normal);\n        return l1;\n    }\n    \n    if (id_material==7.0)\n    {return pattern( p.xz );}\n    \n    if (id_material==8.0)\n    {return pattern( p.xy );}\n    \n    if (id_material==9.0)\n    {return pattern( p.zy );}\n    \n    \n    \n    if (id_material==10.0)\n    {\n        vec2 uv=p.xy;\n         uv = vec2(length(uv), atan(uv.y, uv.x));\n        uv= rotatev2(uv, mObj.AngRot);\n        return espiral( polar2rect(uv*1.0 )); \n    }\n    \n   \n    if (id_material==11.0)\n    {\n        vec2 uv=mObj.normal.xy;\n        vec2 rt = vec2(length(uv), atan(uv.y, uv.x));\n        rt= rotatev2(rt, mObj.AngRot);\n        return espiral(( rt) );\n    }\n    \n    \n    if (id_material==11.0)\n    {\n        vec2 uv=mObj.normal.xy;\n        vec2 rt = vec2(length(uv), atan(uv.y, uv.x));\n        rt= rotatev2(rt, mObj.AngRot);\n        return espiral(( rt) );\n    }\n    \n}\n\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n   \n    float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        col= result;\n    }\n   \n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \t//light_pos1= vec3(5.0, 15.0, -10.0+10.*sin(t) ); light_color1=vec3( 1.0 );\n \t//light_pos2= vec3(0.0,10.0, -10.0-10.*sin(t) ); light_color2 =vec3( 1.0 ); \n   \n   light_pos1= vec3(5.0, 10.0, -10.0 ); light_color1=vec3( 1.0 );\n   light_pos2= vec3( -10.0, 30.0, -10.0 ); light_color2 =vec3( 1.0 );\n    \n   \n   vec3 ro=vec3(0.0,8.5,-19.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n    //light_pos1+=ro;\n    //light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    col = exposureToneMapping(2.0, col);\n    //col = linear2srgb(col);\n    \n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n    float AngRot;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\n\n///--------------------------------------------FIN\n///--------------------------------------------\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lsXWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[621, 621, 657, 657, 678], [679, 679, 711, 711, 795], [796, 796, 842, 842, 929], [930, 930, 964, 964, 1026], [1027, 1027, 1064, 1064, 1159], [1160, 1160, 1199, 1199, 1294], [1296, 1296, 1335, 1335, 1430], [1436, 1436, 1475, 1475, 1570], [1573, 1573, 1614, 1614, 1707], [1708, 1708, 1749, 1749, 1836], [1837, 1837, 1885, 1885, 1986], [1989, 2033, 2080, 2080, 2107], [2108, 2108, 2151, 2151, 2178], [2179, 2179, 2227, 2227, 2255], [2256, 2319, 2353, 2353, 2449], [2450, 2450, 2484, 2484, 2575], [2576, 2576, 2610, 2610, 2701], [2702, 2742, 2776, 2776, 2871], [2874, 2874, 2911, 2911, 2994], [2997, 2997, 3055, 3055, 3319], [3320, 3360, 3385, 3385, 8305], [8307, 8358, 8382, 8382, 8544], [8546, 8546, 8595, 8595, 9262], [9264, 9351, 9387, 9387, 9632], [9633, 9688, 9715, 9715, 9732], [9734, 9734, 9770, 9770, 9862], [9863, 9863, 9909, 9909, 10034], [10038, 10038, 10124, 10124, 10752], [10758, 10792, 10872, 10872, 11061], [11104, 11104, 11136, 11136, 11333], [11335, 11383, 11411, 11411, 11599], [11601, 11646, 11675, 11675, 11776], [11779, 11855, 11881, 11881, 12247], [12248, 12299, 12346, 12346, 13677], [13679, 13731, 13824, 13824, 14165], [14168, 14168, 14199, 14199, 14741], [14743, 14792, 14818, 14818, 14928], [14930, 14930, 14988, 14988, 15040], [15042, 15091, 15148, 15148, 15911]], "test": "untested"}
{"id": "7llSDS", "name": "Multicolor Subpixel Game of Life", "author": "CharmingSalmon", "description": "Seizure warning. Game of life in Shader form, now with more colors!", "tags": ["gameoflife"], "likes": 4, "viewed": 441, "published": 3, "date": "1626480767", "time_retrieved": "2024-07-30T19:10:40.467348", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Output to screen\n    fragColor = texelFetch(iChannel1, ivec2(fragCoord.xy),0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "int life(int value, int neighborCount);\n\nvec4 texFetchColor(sampler2D channel, vec2 coord){\n    return  texelFetch(channel,ivec2(coord),0);\n}\n\nivec4 fetchAdj(vec2 coord, int x, int y){\n return ivec4(round(texFetchColor(iChannel0,coord - vec2(x,y))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n //Pause if mouse is down\n  if(iMouse.z > 0.) {\n  fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n  return;}\n  \n  //Count neighbors\n  ivec3 neighborCount = ivec3(0);\n  \n  ivec4 px9 = fetchAdj(fragCoord, -1,-1);\n  ivec4 px8 = fetchAdj(fragCoord, 0,-1);\n  ivec4 px7 = fetchAdj(fragCoord, 1,-1);\n  \n  ivec4 px6 = fetchAdj(fragCoord, -1,0);\n  ivec4 px5 = fetchAdj(fragCoord, 0,0);\n  ivec4 px4 = fetchAdj(fragCoord, 1,0);\n  \n  ivec4 px3 = fetchAdj(fragCoord, -1,1);\n  ivec4 px2 = fetchAdj(fragCoord, 0,1);\n  ivec4 px1 = fetchAdj(fragCoord, 1,1);\n  \n  neighborCount.r = px9.b + px8.r + px8.g + px6.b + px5.g + px3.b + px2.r + px2.g; //All adjacent subpixels\n  neighborCount.g = px8.r + px8.g + px8.b + px5.r + px5.b + px2.r + px2.g + px2.b; \n  neighborCount.b = px8.g + px8.b + px7.r + px5.g + px4.r + px2.g + px1.r + px1.g;\n    \nivec4 prevPixel = px5;\nfragColor = vec4(life(prevPixel.r, neighborCount.r), life(prevPixel.g, neighborCount.g), life(prevPixel.b, neighborCount.b),1.);\n}\n\nint life(int value, int neighborCount){\n //Adjust state as appropriate\n  switch(neighborCount){\n  case 3:\n      return 1;\n  break;\n  case 2:\n      return value;\n  break;\n  default:\n      return 0;\n  }\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "float rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 mod2(vec2 vecA, vec2 vecB){\n  return vec2(mod(vecA.x,vecB.x),mod(vecA.y,vecB.y));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec4 px = texelFetch(iChannel0,ivec2(fragCoord),0);\n//  if( iFrame % 10 == 0 && rand(fragCoord - 2.*vec2(iFrame % 200, mod(iTime,200.))) < 0.1 ){\n\n//  }}\n  \n  if(rand(fragCoord - 2.*vec2(iFrame % 200, mod(iTime,200.))) < (1./1e34) * pow(sin(iTime/20.),2.) ) {\n  \n        vec2 texSize = vec2(textureSize(iChannel1,0));\n  vec4 texel = texelFetch(iChannel1,ivec2(mod2(fragCoord,texSize)),0);\n  if(texel != vec4(0)){\n  if(px == vec4(0) || px == vec4(0,0,0,1)) fragColor = round(texel);\n  return;\n  }\n      switch(int(rand(fragCoord-vec2(iTime))*3.)){\n      case 0:\n      fragColor = vec4(1,px.g,px.b,1);\n      break;\n      case 1:\n      fragColor = vec4(px.r,1,px.b,1);\n      break;\n      case 2:\n      fragColor = vec4(px.r,px.g,1,1);\n      }\n  return;\n  }\n  \n  \n \n  \n  ivec2 dist = ivec2(abs(fragCoord.xy - iMouse.xy));\n  if(dist.x <= 1 && dist.y <= 1){\n      fragColor = vec4(1);\n  } else {\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord.xy),0);\n    }\n}\n\n\n", "buffer_b_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //Gravity warp\n       vec2 gravity = vec2(0.,0.);\n  //Gravity Calculation\n for(int adj_col = -3; adj_col <= 3; adj_col++){\n    for(int adj_row = -3; adj_row <= 3; adj_row++){\n    if(adj_col == 0 && adj_row==0) continue;\n    if(texelFetch(iChannel0,ivec2(fragCoord+vec2(adj_col,adj_row)),0) == vec4(1.))\n       gravity += vec2(adj_col,adj_row) * 1e5;\n    }\n  }\n  if(1./gravity.x < 1e-6 || 1./gravity.y < 1e-6) {\n  fragColor = texelFetch(iChannel0,ivec2(fragCoord),0); return;\n  }\n  //fragColor = vec4(ceil(1./gravity.x),ceil(1./gravity.y),1,1) * texelFetch(iChannel0,ivec2(fragCoord),0);\n  fragColor = texelFetch(iChannel0,ivec2(fragCoord-ceil(1./gravity)),0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7llSDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 82, 146]], "test": "untested"}
{"id": "slXSzB", "name": "Checkerworld", "author": "golinad", "description": "* added cylinder and octahedron sdf\n* shadow casting\n* checkerboard 3d texture\n* uv texturing\n* assign materials\n* phong shading", "tags": ["sdf", "texture", "shadow", "light"], "likes": 3, "viewed": 387, "published": 3, "date": "1626474057", "time_retrieved": "2024-07-30T19:10:41.232303", "image_code": "// Uncomment for debug rendering\n//#define COMPLEXITY\n//#define ISOLINES\n\nconst float pi = 3.1415926535897932384626433832795;\n\nfloat delta = 0.001;\nfloat maxT = 20.0;\nconst int maxIt = 100;\nvec4 ambientColor = vec4(0.20,0.20,0.3,1.0);\nvec4 lightColor = vec4(1.0,1.0,0.7,1.0);\n\n// Material types\nconst int matDefault = 0;\nconst int matChecker = 1;\nconst int matRed = 2;\nconst int matGreen = 3;\nconst int matUVCyan = 4;\nconst int matUVMagenta = 5;\n\nstruct SpotInfo {\n    float d;\n    vec3 pos;\n    vec2 uv;\n    int m;\n};\n\n// SDF primitives\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\nfloat sdBox(in vec3 p,in vec3 ext) {\n    vec3 q = abs(p) - ext/2.0;\n    return length(max(q,0.0)) + min(max(max(q.x, q.y),q.z),0.0);\n}\nfloat sdTorus(in vec3 p, float r1, float r2) {\n    vec3 c = vec3(normalize(p.xy)*r1, 0.0);\n    return distance(p, c) - r2;\n}\nfloat sdCylinder(in vec3 p, in float r, in float h) {\n    p = abs(p);\n    vec3 q = normalize(vec3(p.x, 0.0, p.z))*r + vec3(0,min(p.y, h/2.0),0);\n    q = abs(p) - q;\n    return length(max(q, 0.0)) + min(max(p.y-h/2.0, length(p.xz)-r), 0.0);\n}\n// simple version, not compatible with rounding\nfloat sdOctahedron(in vec3 p, in float r) {\n    p = abs(p);\n    // basically a plane\n//    vec3 n = normalize(vec3(1,1,1));\n//    float ri =  r*(pow(3.0, 0.5)/3.0);\n//    return  dot(n,p) - ri;\n\n    // the same, but fast and cryptic\n    return (p.x + p.y + p.z - r) * 0.57735026;\n}\n\nSpotInfo sdTorusUV(in vec3 p, in float r1, in float r2) {\n    vec3 c = vec3(normalize(p.xy)*r1, 0.0);\n    return SpotInfo(distance(p, c) - r2, p,\n                    vec2(-atan(p.x, p.y)/2.0/pi+0.5, -atan(p.z, distance(p.xy, c.xy))/2.0/pi+0.5), 0);\n}\n\nSpotInfo sdSphereUV(in vec3 p, in float r) {\n    return SpotInfo(length(p) - r, p,\n                vec2(atan(p.x, p.z)/2.0/pi+0.5, -atan(p.y, length(p.xz))/pi+0.5), 0);\n}\n\n// SDF operations\nfloat sdUnion(float a, float b) {return min(a,b);}\nfloat sdIntersect( float a, float b) {return max(a,b);}\nfloat sdSubstract(float a, float b) {return max(a, -b);}\n\n// SDF operations including spot info\nSpotInfo sdUnion(in SpotInfo a, in SpotInfo b) {\n    if(a.d<b.d)\n        return a;\n    else\n        return b;\n}\nSpotInfo sdIntersect(in SpotInfo a, in SpotInfo b) {\n    if(a.d>b.d)\n        return a;\n    else\n        return b;\n}\nSpotInfo sdSubstract(in SpotInfo a, in SpotInfo b) {\n    if (a.d>-b.d)\n        return a;\n    else\n        return SpotInfo(-b.d, b.pos, b.uv, b.m);\n}\n\nfloat checkerBoard(in vec2 uv, in float w) {\n    float cx = mod(uv.x, w)>w*0.5?1.0:0.0;\n    float cy = mod(uv.y, w)>w*0.5?1.0:0.0;\n    \n    // XOR: (a || b) && !( a && b) ->  (a+b)*(1-a*b)\n    return (cx+cy)*(1.0 - cx*cy);\n}\n\n// XOR: (a || b) && !( a && b) ->  (a+b)*(1-a*b)\nfloat xor(float a, float b) {\n    return (a+b)*(1.0 - a*b);\n}\n\nfloat checkerBoard(in vec3 p, float w) {\n    float cx = mod(p.x, w)>w*0.5?1.0:0.0;\n    float cy = mod(p.y, w)>w*0.5?1.0:0.0;\n    float cz = mod(p.z, w)>w*0.5?1.0:0.0;\n    \n    return xor(xor(cx, cy),cz);\n}\n\nfloat isoLines(float d, float seg) {\n    return mod(d, seg) > seg*0.95 ^^ d < 0.0?1.0:0.0;\n}\n\n// sdf only, used for marching\nfloat map(in vec3 p) {\n    float dBox = sdBox(p-vec3(0,-2,0), vec3(40,0.1,40));\n    float dTorus = sdTorus((p - vec3(sin(iTime),1,-3.0+cos(iTime))).xzy, 1.5, 0.2);\n    float dSphere = sdSphere(p - vec3(cos(iTime),0,-3.0+sin(iTime)), 0.5);\n    float d3 = sdUnion(dSphere, dTorus);\n    float d = sdUnion(d3,dBox);\n    d = sdUnion(d, sdCylinder(p - vec3(0,0,-3), 0.2, 4.0)-0.1);\n    d = sdUnion(d, sdOctahedron(p - vec3(-2,-1,-5), 1.0));\n    return d;\n}\n\n// spot info, expensive, only used on surfac hit\nSpotInfo mapSI(in vec3 p) {\n    SpotInfo siBox = SpotInfo(sdBox(p-vec3(0,-2,0), vec3(40,0.1,40)),p,vec2(0,0), matChecker);\n    SpotInfo siTorus = sdTorusUV((p - vec3(sin(iTime),1,-3.0+cos(iTime))).xzy, 1.5, 0.2);\n    siTorus.m = matUVMagenta;\n    SpotInfo siSphere = sdSphereUV(p - vec3(cos(iTime),0,-3.0+sin(iTime)), 0.5);\n    siSphere.m = matUVCyan;\n    SpotInfo si3 = sdUnion(siSphere, siTorus);\n    SpotInfo si = sdUnion(si3,siBox);\n    SpotInfo siCyl = SpotInfo(sdCylinder(p - vec3(0,0,-3), 0.2, 4.0)-0.1, p, vec2(0), matRed);\n    si = sdUnion(si, siCyl);\n    SpotInfo siOct = SpotInfo(sdOctahedron(p - vec3(-2,-1,-5), 1.0), p, vec2(0), matGreen);\n    si = sdUnion(si, siOct);\n    return si;\n}\n\nvec3 tex(in SpotInfo si, in int matID) {\n    // switch case not working on gl es ... so use if else\n    if (matID == matChecker) {\n        return vec3(1.0)*(checkerBoard(si.pos, 1.0)*0.5+0.5);\n    } else if (matID == matRed) {\n        return vec3(1,0,0)*(checkerBoard(si.pos, 1.0)*0.5+0.5);\n    } else if (matID == matGreen) {\n        return vec3(0,1,0)*(checkerBoard(si.pos, 1.0)*0.5+0.5);\n    } else if (matID == matUVCyan) {\n        return vec3(0,1,1)*(checkerBoard(si.uv*vec2(2,1), 0.1)*0.5+0.5);\n    } else if (matID == matUVMagenta) { // uv checkerboard\n        return vec3(1,0,1)*(checkerBoard(si.uv*vec2(2,1), 0.1)*0.5+0.5);\n    } else {\n        return vec3(1.0);\n    }\n}\n\n// calculate normal based on simplified(3 vs. 6 samples) gradient around pos\n// Note: when we are marching solids, d is almost 0 on surface (varying due to marching)\nvec3 calcNormal(in vec3 p, in float d) {\n    float dx = map(p + vec3(delta,0,0));\n    float dy = map(p + vec3(0,delta,0));\n    float dz = map(p + vec3(0,0,delta));\n    \n    return normalize(vec3(dx-d, dy-d, dz-d));\n}\n\n// return distance\nfloat march(in vec3 ro, in vec3 rd, inout int j, out float d) {\n    float t = 0.0;\n    \n    for(int i = 0; i < maxIt; i++) {\n        if (t > maxT) {\n            return t;\n        }\n        \n        d = map(ro+t*rd);\n        if(d < delta || i == 99) {\n            return t;\n        } else {\n            t += d;\n        }\n        j++;\n    }\n}\n\nvec3 lightDirection() {\n    return normalize(vec3(sin(iTime*0.123),0.5,cos(iTime*0.123)));\n}\n\nvec4 bgColor(in vec3 rd) {\n    return ambientColor*cos(rd.y) + pow(max(dot(lightDirection(), rd),0.0),100.0);\n}\n\nvoid shade(out vec4 fragColor, in vec3 p, in vec3 n,in vec3 rd, in float t, inout int j) {\n    // ambient light\n    vec3 light = ambientColor.xyz;\n\n    // direct light\n    vec3 ld = lightDirection();\n    float d;\n    bool shadowed = march(p + n*delta, ld, j, d) < maxT;\n    vec3 lightSpec = vec3(0,0,0);\n    if(!shadowed)  {\n        light += max(dot(n, ld), 0.0)*lightColor.xyz; // diffuse\n        vec3 r = rd-2.0*n*dot(n, rd); // reflection ray\n        float n = 6.0;// exoonent\n        lightSpec = pow(max(dot(r,ld), 0.0),n)*((n+2.0)/2.0/pi)*lightColor.xyz;// specular\n    }\n\n\n    SpotInfo si = mapSI(p);\n    fragColor = vec4(tex(si, si.m)*light + lightSpec, 1.0);\n\n    // fade to bg (fog)\n    fragColor = mix(fragColor, bgColor(rd), t/maxT);\n}\n\nvoid render(out vec4 fragColor, in vec3 ro, in vec3 rd) {\n\n    int j = 0;\n    float d;\n    float t = march(ro, rd, j, d);\n    \n    if (t >= maxT) { // background\n        fragColor = bgColor(rd);\n    } else { // hit something\n        vec3 p = vec3(ro+t*rd);\n        vec3 n = calcNormal(p, d);\n        \n        shade(fragColor, p, n, rd, t, j);\n\n    }\n\n\n#ifdef COMPLEXITY\n    // marching complexity heatmap\n    fragColor = mix(vec4(0,0,1,1), vec4(1,0,0,1), float(j)/float(maxIt*2));\n#endif\n}\n\nvoid debugRender(out vec4 fragColor, in vec2 uv) {\n    float d = map(vec3(uv,0));\n    vec3  n = calcNormal(vec3(uv, 0), d);\n    float l = isoLines(d, 0.1);\n\n    // colored\n    //fragColor = vec4((n*0.5+0.5)*l,1.0);\n    \n    // monochrome\n    fragColor = vec4(l,l,l,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy/2.0)/iResolution.y*2.0;\n    \n#ifdef ISOLINES\n    debugRender(fragColor, uv);\n    //fragColor = vec4(mod(uv, 1.0), 0,1);\n#else\n    vec3 ro = vec3(0,0,2);\n    vec3 rd = normalize(vec3(uv.xy, 0) - ro);\n    render(fragColor, ro , rd);\n#endif\n}\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) {\n\n    render(fragColor, fragRayOri, fragRayDir);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slXSzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[520, 538, 571, 571, 599], [600, 600, 636, 636, 734], [735, 735, 781, 781, 859], [860, 860, 913, 913, 1101], [1102, 1150, 1193, 1193, 1431], [1433, 1433, 1490, 1490, 1683], [1685, 1685, 1729, 1729, 1855], [1857, 1875, 1908, 1908, 1925], [1926, 1926, 1964, 1964, 1981], [1982, 1982, 2019, 2019, 2038], [2040, 2078, 2126, 2126, 2189], [2190, 2190, 2242, 2242, 2305], [2306, 2306, 2358, 2358, 2454], [2456, 2456, 2500, 2500, 2680], [2682, 2731, 2760, 2760, 2792], [2794, 2794, 2834, 2834, 2999], [3095, 3126, 3148, 3148, 3576], [3578, 3627, 3654, 3654, 4325], [4327, 4327, 4367, 4426, 5006], [5008, 5174, 5214, 5214, 5390], [5392, 5411, 5474, 5474, 5751], [5753, 5753, 5776, 5776, 5845], [5847, 5847, 5873, 5873, 5958], [5960, 5960, 6050, 6071, 6706], [6708, 6708, 6765, 6765, 7197], [7199, 7199, 7249, 7249, 7471], [7473, 7473, 7530, 7580, 7860], [7863, 7863, 7957, 7957, 8007]], "test": "untested"}
{"id": "sllSDS", "name": "Ready Player One", "author": "dean_the_coder", "description": "After just finishing the Ready Player One book, and watching the film a couple of times, I was inspired\nto try to make a scene inspired by it.\nHope you like it!\n", "tags": ["3d", "raymarching", "glow", "vr", "movie", "cineshader"], "likes": 38, "viewed": 6544, "published": 3, "date": "1626467598", "time_retrieved": "2024-07-30T19:10:42.045130", "image_code": "// 'Ready Player One' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/sllSDS (YouTube: https://youtu.be/jUx2yGj3pGo)\n//\n// \"It's not about winning, it's about playing.\"\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// After just finishing the Ready Player One book,\n// and watching the film a couple of times, I was inspired\n// to try to make a scene inspired by it.\n//\n// Hope you like it!\n//\n// Tricks to get the performance:\n//\n// A relatively straight-forward ray-marching scene, but to keep\n// the performance up I've tried to avoid adding noise into the SDF\n// as much as possible - The finer detail on the terrain is applied\n// when calculating the material color.\n//\n// The Iron Giant only has one real arm and leg - I've used mirroring\n// on the X axis to duplicate the other side.\n// The arm and leg SDF is generated from the same function, parameterized\n// to slightly adjust appearance.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// Blackle and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define Z0\tmin(iTime, 0.)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S(a, b, c) smoothstep(a, b, c)\n\nfloat t, g;\nstruct Hit {\n\tfloat d;\n\tint id;\n\tvec3 uv;\n};\n\n#define HASH\tp = fract(p * .1031); p *= p + 3.3456; return fract(p * (p + p));\n\nvec4 h44(vec4 p) { HASH }\n\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(h44(h), h44(h + s.x), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat n21(vec2 p) { return n31(vec3(p, 1)); }\n\n#define minH(a)\tif (a.d < h.d) h = a\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat hex(vec3 p, vec2 h) {\n\tconst vec3 k = vec3(-.8660254, .5, .57735);\n\tp = abs(p);\n\tp.xy -= 2. * min(dot(k.xy, p.xy), 0.) * k.xy;\n\tvec2 d = vec2(length(p.xy - vec2(clamp(p.x, -k.z * h.x, k.z * h.x), h.x)) * sign(p.y - h.x), p.z - h.y);\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat cyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.zy), p.x)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat cap(vec3 p, float h, float r) {\n\tp.y -= clamp(p.y, 0., h);\n\treturn length(p) - r;\n}\n\nfloat pod(vec3 p, float s) { return hex(p.xzy, vec2(.5 - (p.y > 0. ? p.y * .3 : 0.), 1) * s); }\n\nfloat limb(inout vec3 p, float a1, float a2, float s) {\n\tfloat f, d,\n\t      oy = p.y;\n\tp.yz *= rot(a1);\n\tf = max(max(length(p.zy) - .45, p.x - p.y), -p.x);\n\td = min(cyl(p, vec2(.5, .1)), f);\n\tf = p.y;\n\tp.y = abs(p.y + .7) - .7;\n\td = min(d, length(p) - .35 + .1 * step(oy, -.3));\n\tp.y = f + 1.2;\n\td = min(d, cap(p, 1., .2));\n\tp.y += .2;\n\tp.yz *= rot(a2);\n\tp.y += .1 + s;\n\treturn min(d, pod(p, s));\n}\n\nvec3 rayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nHit map(vec3 p, bool shield) {\n\tvec3 pp, op,\n\t     rp = p;\n\trp.xz *= rot(S(-1., 1., 1.5 * sin(cos(t * .5))) - .5);\n\tpp = rp;\n\tpp.z += .05;\n\tfloat bd, bdd, eye, mx, lxz, d,\n\t      chin = max(cap(pp, .6, .5), -pp.z - .45);\n\tchin = max(chin, rp.y - .6);\n\tpp.y -= 1.3 + pp.z * .2;\n\tpp.z += 1.1;\n\tbd = max(min(cap(rp, .7, .45), max(chin, -box(pp, vec3(1)))), .15 - rp.y + rp.z * .5);\n\tpp = rp;\n\tpp.x = abs(pp.x) - .2;\n\tpp.yz = rp.yz - vec2(.6, -.4);\n\top = pp;\n\tbd = min(max(bd, .12 - length(pp)), cyl(rp - vec3(0, .7, 0), vec2(.5, .02)));\n\teye = max(length(pp - vec3(0, 0, .1)) - .1, abs(pp.y) - S(1., .8, sin(t * .9)) + .05);\n\tg += 1e-4 / (.001 + eye * eye);\n\tHit orb,\n\t    h = Hit(eye, 3, rp);\n\tmx = abs(p.x);\n\tpp.x = mx - .2;\n\tpp.yz = p.yz - vec2(.6, -.4);\n\tlxz = length(p.xz);\n\td = .25 + .35 * step(p.y, -1.) * mix(.8, 1., sat(2. * abs(sin(p.y * 10.))));\n\tbdd = max(max(lxz - d, p.y - 1.), -p.y - 2.5);\n\td = max(max(max(length(p.xz * vec2(.5, .9)) - (p.y + 6.2) * .12, p.y + 1.), -p.y - 2.), -box(pp + vec3(0, 2.4, 0), vec3(-pp.y * .18, .3, 1)));\n\tbd = min(bd, d);\n\tpp.x -= .4;\n\tpp.y += 1.4;\n\tpp.xz *= rot(.4);\n\tpp.xy *= rot(-.1);\n\tbd = min(bd, .9 * box(pp, vec3(.8, .5 + pp.z * .4, .25)));\n\tpp = p;\n\tpp.x = mx - 1.58;\n\tpp.xy *= rot(.1);\n\tpp.y += .8;\n\tbd = min(bd, limb(pp, -.2, .4, .7));\n\td = box(pp + vec3(-.1, .9, 0), vec3(0, .2, .2));\n\tpp.xy *= rot(-.7 - sin(t) * .025);\n\tbd = min(bd, min(d, box(pp + vec3(-.8, 1, 0), vec3(0, .2, .2))) - .1 + .03 * abs(sin(pp.z * 20.75)));\n\tpp = p;\n\tpp.y += 3.2;\n\tpp.x = floor(mx * 5.) / 5.;\n\tminH(Hit(min(bdd, cap(pp, 1., .3)), 2, p));\n\tbd = min(bd, max(length(pp.zy) - .15, lxz - 1.));\n\tpp.x = mx - 1.;\n\tbd = min(bd, limb(pp, .2, -.2, 1.));\n\tpp.y += 1.4;\n\tbd = min(bd, max(max(hex(pp, vec2(.4, 1.2)), -pp.y), pp.z - .3));\n\tminH(Hit(bd, 1, p));\n\top = p - vec3(10, -7, 30);\n\torb = Hit(length(op) - 25., 0, op);\n\tg += .01 / (orb.d * orb.d * .1 + 1.);\n\tif (shield) minH(orb);\n\tpp = p - vec3(p.y + 74.875 + sin(p.y * 15.) * .05, n21(pp.xy * .5) * .2, -11.22);\n\td = n21(pp.xz * .2);\n\tminH(Hit(pp.y - 2. * pow(d, 10.) + 7.1, 4, vec3(pp.xz, d)));\n\top.xz *= rot(1.);\n\tp = op;\n\top.xz = abs(op.xz) - 8.;\n\tpp = op;\n\top.xz *= rot(op.y / 12.7348);\n\td = 4. - 2.8 * pow(sin(.5 * pow(op.y * .39, .65) + .2), 1.8);\n\td = min(max(box(op, vec3(d, 20, d)) - .1, box(pp, vec3(3.25, 20, 3.25))), box(p, vec3(12, .3, 12)) - .2);\n\tminH(Hit(d, 5, op));\n\td = cyl(p.yxz, vec2(.7 - p.y * 0.12, 4.0)) - .5;\n\tminH(Hit(d, 2, op));\n\tp.y -= 5.;\n\torb = Hit(length(p) - .7 + n31(p * 3. + t) * .4, 0, op);\n\tg += .01 / (orb.d * orb.d * .1 + 1.);\n\tminH(orb);\n\treturn h;\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .4;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h, false).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 ld) {\n\tfloat i, h,\n\t      s = 1.,\n\t      t = .1;\n\tfor (i = Z0; i < 20.; i++) {\n\t\th = map(t * ld + p, false).d;\n\t\ts = min(s, 30. * h / t);\n\t\tt += h;\n\t\tif (s < .001 || t > 20.) break;\n\t}\n\n\treturn sat(s);\n}\n\nvec3 vig(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\nvec3 lights(vec3 p, vec3 rd, float d, Hit h) {\n\tif (h.id == 3) return vec3(1);\n\tvec3 n, c,\n\t     ld = normalize(vec3(2, 20, 15) - p);\n\tif (h.id == 0) {\n\t\tn = normalize(h.uv);\n\t\tfloat ns,\n\t\t      f = sat(.2 + .8 * dot(ld * vec3(-1, 1, 1), n));\n\t\tvec2 k = (n.xy * rot(t * .1) - vec2(.3, .1)) * rot(t * -.3) + vec2(.1, .2);\n\t\tfor (float i = 0.; i < 2.; i++) {\n\t\t\tfloat l = length(k + i * .1);\n\t\t\tf += (.4 + .2 * sin(l * 60. - t * 2.)) * (.003 + S(.5, 0., l) * S(0., .5, l));\n\t\t\tt += 32.;\n\t\t}\n\n\t\tns = n31(n * 19. + vec3(0, 0, t * 2.)) * .7 + n31(n * 39. + vec3(0, t * 2., 0)) * .3;\n\t\tf *= .5 + .5 * S(.2, .8, ns);\n\t\treturn vec3(1, 1.1, 1.7) * f;\n\t}\n\n\tn = N(p, d);\n\tif (h.id == 1) c = vec3(.2);\n\telse if (h.id == 2) c = vec3(.01);\n\telse if (h.id == 4) {\n\t\tc = vec3(.55);\n\t\tn.xz += 4. * (h.uv.z * .5 + n21(p.xz) * .125 - .5 + (n21(p.xz * 2.) + n21(p.zx * 32.1)) * .05);\n\t\tn = normalize(n);\n\t}\n\telse if (h.id == 5) c = mix(vec3(-.05), vec3(2. * pow(sat(sin(t + p.y * .2)), 10.), 0, 0), step(.8, fract(p.y)) * step(-7., p.y));\n\n\tfloat gg = g,\n\t      l1 = sat(.1 + .9 * dot(ld, n)) * (.2 + .8 * shadow(p, ld)),\n\t      l2 = sat(.1 + .9 * dot(ld * vec3(-1, 0, -1), n)) * .3 + pow(sat(dot(rd, reflect(ld, n))), 10.),\n\t      fre = 1. - S(.7, 1., 1. + dot(rd, n)) * .5;\n\tg = gg;\n\treturn (l1 + l2) * fre * c * vec3(.4, .32, .3);\n}\n\nvec3 sky(vec3 rd) {\n\tfloat f = pow(1. - sat(rd.y / .5), 3.);\n\treturn vec3(.16, .18, .24) * f + vec3((1. - f) * S(-.2, -.7, rd.x) * step(.96, n31(rd * 2e2)) * .5 * (.01 + .99 * n31(rd * 40. - t * .5)));\n}\n\nvec3 march(inout vec3 p, vec3 rd) {\n\tfloat i,\n\t      d = .01;\n\tbool addOrb = true;\n\tHit h, orb;\n\tvec3 orbP, c;\n\tg = 0.;\n\tfor (i = Z0; i < 128.; i++) {\n\t\th = map(p, addOrb);\n\t\tif (abs(h.d) < .0015) {\n\t\t\tif (h.id == 0) {\n\t\t\t\torb = h;\n\t\t\t\torbP = p;\n\t\t\t\taddOrb = false;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\n\t\td += h.d;\n\t\tif (d > 64.) break;\n\t\tp += h.d * rd;\n\t}\n\n\tc = (d < 64. ? lights(p, rd, d, h) : sky(rd)) + g;\n\tif (!addOrb) c += lights(orbP, rd, d, orb);\n\treturn c;\n}\n\n#define R\tiResolution\n\nvec3 render(vec3 ro, vec3 rd) {\n\tt = mod(iTime, 30.);\n\treturn pow(max(vec3(0), march(ro, rd)), vec3(.45)) * sat(iTime);\n}\n\nvoid mainVR(out vec4 fragColor, vec2 fc, vec3 ro, vec3 rd) {\n\trd.xz *= rot(-1.57);\n\tfragColor = vec4(render(vec3(-2, -4, -5), rd), 0);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tvec2 uv = (fc - .5 * R.xy) / R.y;\n\tif (abs(uv.y) > .4) {\n\t\tfragColor = vec4(0);\n\t\treturn;\n\t}\n\n\tt = mod(iTime, 30.);\n\tfloat p = S(1., 15., t);\n\tvec3 lookAt = vec3(3, -3, 0) * p,\n\t     ro = mix(vec3(0, 0, -5), vec3(6, -5, -11), p);\n\tfragColor = vec4(vig(render(ro, rayDir(ro, lookAt, uv)), fc), 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sllSDS.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1456, 1456, 1475, 1475, 1720], [1722, 1722, 1741, 1741, 1767], [1807, 1807, 1826, 1826, 1893], [1895, 1895, 1922, 1922, 2188], [2190, 2190, 2217, 2217, 2304], [2306, 2306, 2334, 2334, 2434], [2436, 2436, 2473, 2473, 2525], [2527, 2527, 2555, 2555, 2622], [2624, 2624, 2679, 2679, 3022], [3024, 3024, 3068, 3068, 3204], [3206, 3206, 3236, 3236, 5776], [5778, 5778, 5803, 5803, 6029], [6031, 6031, 6062, 6062, 6260], [6262, 6262, 6289, 6289, 6404], [6406, 6406, 6452, 6452, 7721], [7723, 7723, 7742, 7742, 7926], [7928, 7928, 7963, 7963, 8383], [8408, 8408, 8439, 8439, 8529], [8531, 8531, 8591, 8591, 8667], [8669, 8669, 8714, 8714, 9014]], "test": "untested"}
{"id": "flsSWS", "name": "Waveform MultiChannel", "author": "kaihagseth", "description": "3 channel waveform scope", "tags": ["waveform", "scope"], "likes": 6, "viewed": 432, "published": 3, "date": "1626438441", "time_retrieved": "2024-07-30T19:10:42.813076", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iChannelResolution[0].xy;\n    uv /=  vec2(iChannelResolution[0].x/ iChannelResolution[1].x, iResolution.y/ float(NBUCKETS-1));\n    fragColor = texture(iChannel0, uv);\n}\n", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x > iChannelResolution[0].x ||fragCoord.y > float(NBUCKETS)) \n    {\n        return;\n    }\n        \n    float begin = (fragCoord.y/iChannelResolution[0].y) /  (float(NBUCKETS-1) /  iChannelResolution[0].y);\n    float end = ((fragCoord.y+1.0)/iChannelResolution[0].y) /  (float(NBUCKETS-1) /  iChannelResolution[0].y);\n    fragColor.rgb = vec3(0.0);\n    for (int i = 0; i < int(iChannelResolution[0].y); ++i)\n    {\n        vec4 v = texelFetch(iChannel0, ivec2(fragCoord.x,i), 0);\n        fragColor.r += step(v.r, end) * (1.0 - step(v.r, begin));\n        fragColor.g += step(v.g, end) * (1.0 - step(v.g, begin));\n        fragColor.b += step(v.b, end) * (1.0 - step(v.b, begin));\n    }\n    fragColor *= GAIN;\n\n}", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Number of buckets must be lower than the y-size of view. Lower to improve performance and reduce precision.\n#define NBUCKETS 256\n#define GAIN 0.1", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flsSWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 252]], "test": "untested"}
{"id": "ftsSWS", "name": "Not The Ship Stamp", "author": "dr2", "description": "Not that overpriced British Guiana 1c magenta postage stamp", "tags": ["ship", "sail", "philately"], "likes": 20, "viewed": 341, "published": 3, "date": "1626435716", "time_retrieved": "2024-07-30T19:10:43.748575", "image_code": "// \"Not The Ship Stamp\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Not that overpriced British Guiana 1c magenta postage stamp (mouseable - click in\n// lower-right corner for monochrome image)\n\n/*\n  No. 8 in \"Sailing Ship\" series\n    \"Ship in a Shell\"          (XlBfRR)\n    \"Sailing\"                  (MtBBRR)\n    \"Tempting the Mariner\"     (ll2BzR)\n    \"Lighthouse with Ship\"     (MtSBR1)\n    \"Ship of Mirrors\"          (4ljfzw)\n    \"Refractable Ship\"         (MtjBRm)\n    \"Ship in a Bottle\"         (wlXXzf)\n*/\n\n#define AA  0   // (= 0/1) optional antialiasing\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrEVCapsDf (vec3 p, vec4 u, float r);\nfloat PrEECapsDf (vec3 p, vec3 v1, vec3 v2, float r);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nvec2 Noisev2v4 (vec4 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec4 vum[4], vur[5], shipConf;\nvec3 qHit, ltDirEx, sunDir, vim[4], vir[5], bDeck, sailVel;\nfloat tCur, dstFar;\nint idObj;\nbool monoImg;\nconst int idHull = 1, idRud = 2, idStruc = 3, idMast = 4, idSparT = 5, idSparL = 6, idSailT = 7,\n   idSailA = 8, idSailF = 9, idFlag = 10, idRig = 11;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat WaveHt (vec2 p, float d)\n{\n  mat2 qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  vec4 t4, v4;\n  vec2 q, t, tw;\n  float wFreq, wAmp, h;\n  h = 0.;\n  if (d < 0.3 * dstFar) {\n    q = p;\n    q += sailVel.xz * tCur;\n    wFreq = 0.5;\n    wAmp = 0.1;\n    tw = 0.1 * tCur * vec2 (1., -1.);\n    for (int j = 0; j < 4; j ++) {\n      q *= qRot;\n      t4 = abs (sin (wFreq * (q.xyxy + tw.xxyy) + 2. * Noisev2v4 (t4).xxyy - 1.));\n      v4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n      t = 1. - sqrt (v4.xz * v4.yw);\n      t *= t;\n      t *= t;\n      h += wAmp * (t.x + t.y);\n      wFreq *= 2.;\n      wAmp *= 0.5;\n    }\n    h *= 1. - smoothstep (0.1, 0.3, d / dstFar);\n  }\n  return h;\n}\n\nvec4 WaveNf (vec3 p, float d)\n{\n  vec2 e;\n  float h;\n  e = vec2 (max (0.1, 1e-4 * d * d), 0.);\n  h = WaveHt (p.xz, d);\n  return vec4 (normalize (vec3 (h - vec2 (WaveHt (p.xz + e.xy, d),\n     WaveHt (p.xz + e.yx, d)), e.x)).xzy, h);\n}\n\nfloat ShipHullDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, fy, fz, gz;\n  q = p;\n  d = abs (p.z) - 4.5;\n  q.z = mod (q.z + 1.4, 2.8) - 1.4;\n  q.yz -= vec2 (-3.4, -0.4);\n  d = max (d, PrBoxDf (q, vec3 (0.3, 0.1, 0.5)));\n  DMINQ (idStruc);\n  q = p;\n  q.x = abs (q.x);\n  q.yz -= vec2 (-3.8, 0.5);\n  fz = q.z / 5. + 0.3;\n  fz *= fz;\n  fy = 1. - smoothstep (-1.3, -0.1, q.y);\n  gz = smoothstep (2., 5., q.z);\n  bDeck = vec3 ((1. - 0.45 * fz * fz) * (1.1 - 0.5 * fy * fy) *\n     (1. - 0.5 * smoothstep (-5., -2., q.y) * smoothstep (2., 5., q.z)),\n     0.78 - 0.8 * gz * gz - 0.2 * (1. - smoothstep (-5.2, -4., q.z)), 5. * (1. + 0. * 0.02 * q.y));\n  d = min (PrBoxDf (vec3 (q.x, q.y + bDeck.y - 0.6, q.z), bDeck),\n     max (PrBoxDf (q - vec3 (0., 0.72, -4.6), vec3 (bDeck.x, 0.12, 0.4)),\n     - PrBox2Df (vec2 (abs (q.x) - 0.4, q.y - 0.65), vec2 (0.2, 0.08))));\n  d = max (d, - PrBoxDf (vec3 (q.x, q.y - 0.58 - 0.1 * fz, q.z),\n     vec3 (bDeck.x - 0.07, 0.3, bDeck.z - 0.1)));\n  q = p;\n  d = max (d, - max (PrBox2Df (vec2 (q.y + 3.35, mod (q.z + 0.25, 0.5) - 0.25), vec2 (0.08, 0.1)),\n     abs (q.z + 0.5) - 3.75));\n  DMINQ (idHull);\n  q = p;\n  d = PrBoxDf (q + vec3 (0., 4.4, 4.05), vec3 (0.03, 0.35, 0.5));\n  DMINQ (idRud);\n  return dMin;\n}\n\nfloat ShipMastDf (vec3 p, float dMin)\n{\n  vec3 q, qq;\n  float d, fy, fz, s, rSpar, yLim, zLim;\n  rSpar = 0.05;\n  fy = 1. - 0.07 * p.y;\n  fz = 1. - 0.14 * step (1., abs (p.z));\n  zLim = abs (p.z) - 4.5;\n  q = p;\n  d = zLim;\n  q.z = mod (q.z + 1.4, 2.8) - 1.2;\n  d = max (d, PrCapsDf ((q - vec3 (0., 3.7 * (fz - 1.), 0.)).xzy, 0.1 * fy, 3.7 * fz));\n  DMINQ (idMast);\n  q = p;\n  yLim = abs (q.y - 0.2 * fz) - 3. * fz;\n  qq = q;\n  qq.y = mod (qq.y - 3.3 * (fz - 1.), 2. * fz) - fz;\n  qq.z = mod (qq.z + 1.4, 2.8) - 1.4 + 0.1 * fz;\n  d = max (max (min (d, PrCylDf (vec3 (qq - vec3 (0., 0.05 * fy * fz, 0.1 * fz - 0.23)).xzy,\n     0.15 * fy, 0.11 * fy * fz)), yLim), zLim);\n  DMINQ (idMast);\n  d = max (max (PrCapsDf (qq.yzx, 0.05, 1.23 * fy * fz), yLim), zLim);\n  DMINQ (idSparT);\n  q = p;\n  d = dstFar;\n  for (int k = 0; k < 4; k ++) d = min (d, PrEVCapsDf (q - vim[k], vum[k], rSpar));\n  DMINQ (idSparL);\n  return dMin;\n}\n\nfloat ShipSailDf (vec3 p, float dMin)\n{\n  vec3 q, qq, w;\n  float d, fy, fz;\n  fy = 1. - 0.07 * p.y;\n  fz = 1. - 0.14 * step (1., abs (p.z));\n  q = p;\n  qq = q;\n  qq.y = mod (qq.y - 3.1 * (fz - 1.), 2. * fz) - fz;\n  qq.z = mod (qq.z + 1.4, 2.8) - 1.4 + 0.2 * (fz - abs (qq.y)) * (fz - abs (qq.y)) - 0.1 * fz;\n  d = max (max (max (PrBoxDf (qq, vec3 ((1.2 - 0.07 * q.y) * fz, fz, 0.01)),\n     min (qq.y, 1.5 * fy * fz - length (vec2 (qq.x, qq.y + 0.9 * fy * fz)))),\n     abs (q.y - 3. * (fz - 1.)) - 2.95 * fz), - PrBox2Df (qq.yz, vec2 (0.01 * fz)));\n  d = max (d, abs (p.z) - 4.5);\n  DMINQ (idSailT);\n  q = p;\n  q.z -= -3.8;\n  q.y -= -1.75 - 0.2 * q.z;\n  d = PrBoxDf (q, vec3 (0.01, 0.9 - 0.2 * q.z, 0.6));\n  DMINQ (idSailA);\n  q = p;\n  q.yz -= vec2 (-1., 4.5);\n  w = vec3 (1., q.yz);\n  d = max (max (max (abs (q.x) - 0.01, - dot (w, vec3 (2.3, 1., -0.35))),\n     - dot (w, vec3 (0.68, -0.74, -1.))), - dot (w, vec3 (0.41, 0.4, 1.)));\n  DMINQ (idSailF);\n  q = p;\n  q.yz -= vec2 (3.4, 0.18);\n  d = PrBoxDf (q, vec3 (0.01, 0.2, 0.3));\n  DMINQ (idFlag);\n  return dMin;\n}\n\nfloat ShipRigDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float rRig, d, fz, gz, s;\n  rRig = 0.02;\n  fz = 1. - 0.14 * step (1., abs (p.z));\n  q = p;\n  d = abs (p.z) - 4.5;\n  gz = (q.z - 0.5) / 5. + 0.3;\n  gz *= gz;\n  gz = 1.05 * (1. - 0.45 * gz * gz);\n  q.x = abs (q.x);\n  q.z = mod (q.z + 1.4, 2.8) - 1.4;\n  d = max (d, min (PrEECapsDf (q, vec3 (1.05 * gz, -3.25, -0.5),\n     vec3 (1.4 * fz, -2.95, -0.05), 0.7 * rRig),\n     PrEECapsDf (vec3 (q.xy, abs (q.z + 0.2) - 0.01 * (0.3 - 2. * q.y)), vec3 (gz, -3.2, 0.),\n     vec3 (0.05, -0.9 + 2. * (fz - 1.), 0.), rRig)));\n  q = p;\n  d = min (d, PrEVCapsDf (q - vir[0], vur[0], 0.8 * rRig));\n  d = min (min (d, min (PrEVCapsDf (q - vir[1], vur[1], rRig),\n     PrEVCapsDf (q - vir[2], vur[2], rRig))), PrEVCapsDf (q - vir[3], vur[3], rRig));\n  q.x = abs (q.x);\n  d = min (d, PrEVCapsDf (q - vir[4], vur[4], rRig));\n  s = step (1.8, q.y) - step (q.y, -0.2);\n  d = min (min (d, min (PrEECapsDf (q, vec3 (0.95, 0.4, 2.7) + vec3 (-0.1, 1.7, 0.) * s,\n     vec3 (0.05, 1.1, -0.15) + vec3 (0., 2., 0.) * s, rRig),\n     PrEECapsDf (q, vec3 (1.05, 1., -0.1) + vec3 (-0.1, 2., 0.) * s,\n     vec3 (0.05, 0.5, -2.95) + vec3 (0., 1.7, 0.) * s, rRig))),\n     PrEECapsDf (q, vec3 (0.95, 0.4, -2.9) + vec3 (-0.1, 1.7, 0.) * s,\n     vec3 (0.05, 0.9, -0.25) + vec3 (0., 2., 0.) * s, rRig));\n  DMINQ (idRig);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin;\n  p.xz = Rot2D (p.xz, shipConf.w);\n  p.yz = Rot2D (p.yz, -1. * shipConf.z);\n  p.xy = Rot2D (p.xy, 6. * shipConf.y);\n  p.y -= shipConf.x + 4.1;\n  q = p;\n  dMin = dstFar;\n  dMin = ShipHullDf (q, dMin);\n  dMin = ShipMastDf (q, dMin);\n  dMin = ShipSailDf (q, dMin);\n  dMin = ShipRigDf (q, dMin);\n  return 0.7 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvoid EvalShipConf ()\n{\n  vec4 h;\n  vec3 vd;\n  vec2 e;\n  e = vec2 (4., 0.);\n  h = vec4 (WaveHt (- e, 0.), WaveHt (e, 0.), WaveHt (- e.yx, 0.), WaveHt (e.yx, 0.));\n  shipConf = vec4 (0.25 * dot (h, vec4 (1.)), vec2 (h.xz - h.yw) / (2. * e.x), 0.15 * pi * sin (0.05 * tCur));\n  vim[0] = vec3 (0., -3.5, 4.3);   vd = vec3 (0., -2.6, 6.7) - vim[0];   vum[0] = vec4 (normalize (vd), length (vd));\n  vim[1] = vec3 (0., -4., 4.1);    vd = vec3 (0., -2.9, 6.) - vim[1];    vum[1] = vec4 (normalize (vd), length (vd));\n  vim[2] = vec3 (0., -1.2, -3.);   vd = vec3 (0., -0.5, -4.5) - vim[2];  vum[2] = vec4 (normalize (vd), length (vd));\n  vim[3] = vec3 (0., -2.7, -3.);   vd = vec3 (0., -2.7, -4.5) - vim[3];  vum[3] = vec4 (normalize (vd), length (vd));\n  vir[0] = vec3 (0., -3., -4.45);  vd = vec3 (0., -2.7, -4.5) - vir[0];  vur[0] = vec4 (normalize (vd), length (vd));\n  vir[1] = vec3 (0., 2.45, 2.65);  vd = vec3 (0., -2.7, 6.5) - vir[1];   vur[1] = vec4 (normalize (vd), length (vd));\n  vir[2] = vec3 (0., 2.5, 2.65);   vd = vec3 (0., -3.2, 4.9) - vir[2];   vur[2] = vec4 (normalize (vd), length (vd));\n  vir[3] = vec3 (0., 2.6, -3.);    vd = vec3 (0., -0.5, -4.5) - vir[3];  vur[3] = vec4 (normalize (vd), length (vd));\n  vir[4] = vec3 (0.65, -3.5, 3.5); vd = vec3 (0.05, -2.7, 6.4) - vir[4]; vur[4] = vec4 (normalize (vd), length (vd));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.03 * d, h));\n    d += clamp (h, 0.02, 0.3);\n    if (sh < 0.05) break;\n  }\n  return 0.6  + 0.4 * sh;\n}\n\nvoid ShipCol (out vec4 col4, out vec2 vf)\n{\n  vec2 cg;\n  vf = vec2 (0.);\n  if (idObj == idHull) {\n    if (abs (qHit.x) < bDeck.x - 0.08 && qHit.y > -3.6 && qHit.z > - bDeck.z + 0.62) {\n      col4 = vec4 (0.5, 0.3, 0., 0.1) * (0.5 +\n         0.5 * SmoothBump (0.05, 0.95, 0.02, mod (8. * qHit.x, 1.)));\n    } else if (qHit.y > -4.) {\n      col4 = vec4 (0.7, 0.5, 0.1, 0.1);\n      if (abs (qHit.z - 4.) < 0.25 && abs (qHit.y + 3.55) < 0.05) col4 *= 1.2;\n      else if (qHit.z < -4. && abs (qHit.x) < 0.84 && abs (qHit.y + 3.62) < 0.125) {\n        cg = step (0.1, abs (fract (vec2 (6. * qHit.x, 8. * (qHit.y + 3.62)) + 0.5) - 0.5));\n        if (cg.x * cg.y == 1.) col4 = vec4 (0.8, 0.8, 0.2, 0.3);\n        else col4 *= 0.8;\n      } else {\n        col4 *= 0.7 + 0.3 * SmoothBump (0.06, 0.94, 0.03, mod (8. * qHit.y, 1.));\n        vf = vec2 (64., 0.3);\n      } \n    } else if (qHit.y > -4.05) {\n      col4 = vec4 (0.8, 0.8, 0.8, 0.1);\n    } else if (qHit.y < -4.7) {\n      col4 = vec4 (0.8, 0., 0., 0.1);\n      vf = vec2 (64., 2.);\n    } else {\n      col4 = vec4 (0.3, 0.2, 0.1, 0.);\n      vf = vec2 (64., 2.);\n    }\n  } else if (idObj == idRud) {\n    col4 = vec4 (0.5, 0.3, 0., 0.);\n  } else if (idObj == idStruc) {\n    col4 = vec4 (0.4, 0.3, 0.1, 0.1);\n    if (max (abs (qHit.x), abs (qHit.z + 0.22)) < 0.2) {\n      cg = step (0.1, abs (fract (vec2 (10. * vec2 (qHit.x, qHit.z + 0.22)) + 0.5) - 0.5));\n      if (cg.x * cg.y == 1.) col4 = vec4 (0.8, 0.8, 0.2, 0.3);\n    }\n  } else if (idObj == idSailT) {\n    qHit.x *= (1. + 0.07 * qHit.y) * (1. + 0.14 * step (1., abs (qHit.z)));\n    col4 = vec4 (1., 1., 1., 0.) * (0.7 + 0.3 * SmoothBump (0.06, 0.94, 0.02, mod (4. * qHit.x, 1.)));\n  } else if (idObj == idSailA) {\n    col4 = vec4 (1., 1., 1., 0.) * (0.7 + 0.3 * SmoothBump (0.06, 0.94, 0.02, mod (5. * qHit.z, 1.)));\n  } else if (idObj == idSailF) {\n    col4 = vec4 (1., 1., 1., 0.) * (0.7 + 0.3 * SmoothBump (0.06, 0.94, 0.02,\n       mod (2.95 * qHit.y + 4. * qHit.z - 0.5, 1.)));\n  } else if (idObj == idFlag) {\n    col4 = vec4 (1., 1., 0.5, 0.1);\n    if (abs (abs (length (qHit.yz) - 0.1) - 0.04) < 0.02) col4 = vec4 (0.8, 0.2, 0.2, 0.1);\n  } else if (idObj == idMast) {\n    col4 = vec4 (0.7, 0.4, 0., 0.1);\n    if (length (qHit.xz) < 0.16 * (1. - 0.07 * qHit.y)) col4 *= 0.6 + 0.4 * SmoothBump (0.04, 0.96, 0.01,\n       mod (2. * qHit.y / (1. + 0.14 * step (1., abs (qHit.z))), 1.));\n  } else if (idObj == idSparT) {\n    qHit.x *= (1. + 0.07 * qHit.y) * (1. + 0.14 * step (1., abs (qHit.z)));\n    col4 = vec4 (0.7, 0.4, 0., 0.1) *  (0.6 + 0.4 * SmoothBump (0.08, 0.92, 0.01,\n       mod (4. * qHit.x, 1.)));\n  } else if (idObj == idSparL) {\n    col4 = vec4 (0.7, 0.4, 0., 0.1);\n  } else if (idObj == idRig) {\n    col4 = vec4 (0.25, 0.2, 0.15, 0.);\n    vf = vec2 (32., 0.5);\n  }\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y < 0.001) {\n    rd.y = 0.001;\n    rd = normalize (rd);\n  }\n  q = 0.01 * (ro.xz + 0.5 * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n  ff = Fbm2 (q);\n  f = smoothstep (0.2, 0.8, ff);\n  fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n  clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n     smoothstep (0., 0.05, abs (fd)));\n  skCol = vec3 (0.4, 0.5, 0.8);\n  sd = max (dot (rd, sunDir), 0.);\n  skCol = mix (skCol, vec3 (1., 1., 0.8), step (0.1, sd) *\n     0.2 * pow (sd, 128.) + 0.8 * pow (sd, 2048.));\n  col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  return col;\n}\n\nvec3 InShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, vh4;\n  vec3 vn, col, watCol, row, rdw, rw, vnw;\n  vec2 vf;\n  float dstObj, dstWat, sh, hw;\n  bool waterRefl;\n  sailVel = vec3 (0., 0., 1.);\n  dstWat = (rd.y < 0.) ? - ro.y / rd.y : dstFar;\n  waterRefl = false;\n  for (int k = VAR_ZERO; k < 2; k ++) {\n    if (k == 0 || waterRefl) dstObj = ObjRay (ro, rd);\n    if (k == 0) {\n      waterRefl = (dstWat < min (dstFar, dstObj));\n      if (waterRefl) {\n        ro += dstWat * rd;\n        vh4 = WaveNf (ro, dstWat);\n        vnw = vh4.xyz;\n        hw = vh4.w;\n        row = ro;\n        rdw = rd;\n        rd = reflect (rd, vnw);\n        ro += 0.01 * rd;\n      }\n    }\n  }\n  if (dstObj < min (dstWat, dstFar)) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    ShipCol (col4, vf);\n    sh = waterRefl ? 1. : ObjSShadow (ro + 0.01 * vn, sunDir);\n    if (vf.x > 0.) vn = VaryNf (vf.x * qHit, vn, vf.y);\n    col = col4.rgb * (0.2 + 0.1 * max (dot (vn, normalize (vec3 (- sunDir.xz, 0.)).xzy), 0.) +\n       0.8 * sh * max (dot (vn, sunDir), 0.)) + col4.a * step (0.95, sh) * pow (max (0.,\n       dot (sunDir, reflect (rd, vn))), 32.);\n  } else {\n    col = SkyCol (ro, rd);\n  }\n  if (waterRefl) {\n    rw = row + sailVel * tCur;\n    vnw = VaryNf (rw, vnw, 1. - smoothstep (0.1, 0.4, dstWat / dstFar));\n    watCol = mix (vec3 (0., 0.2, 0.4), vec3 (0., 0.15, 0.3),\n       smoothstep (0.3, 0.7, Fbm2 (0.25 * rw.xz))) *\n       (0.3 + 0.7 * (max (vnw.y, 0.) + 0.1 * pow (max (0., dot (sunDir, reflect (rdw, vnw))), 32.)));\n    col = mix (watCol, 0.7 * col, pow (1. - abs (dot (rdw, vnw)), 5.));\n    col = mix (col, SkyCol (row, rdw), smoothstep (0.7, 0.95, dstWat / dstFar));\n  }\n  if (monoImg) col = vec3 (1., 0.3, 0.7) * pow (Maxv3 (col), 1.2);\n  return clamp (col, 0., 1.);\n}\n\nvec3 InMain (vec2 fCoord)\n{\n  mat3 vuMat;\n  vec3 ro, rd;\n  float el, az;\n  az = 0.9 * pi;\n  el = -0.05 * pi;\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (-1., 3., -25.);\n  rd = vuMat * normalize (vec3 (fCoord, 4.));\n  sunDir = vuMat * normalize (vec3 (0.5, 1., -1.));\n  return clamp (InShowScene (ro, rd), 0., 1.);\n}\n\nfloat ExObjDf (vec3 p)\n{\n  vec4 t;\n  t = vec4 (mod (p.xy + 0.1, 0.2) - 0.1, abs (p.yx) - 1.21);\n  return SmoothMax (PrBoxDf (p, vec3 (1.2, 1.2, 0.02)), 0.08 -\n     min (length (t.xz), length (t.yw)), 0.01);\n }\n\nfloat ExObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 60; j ++) {\n    d = ExObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ExObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ExObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 BlkHit (vec3 ro, vec3 rd, vec3 sz)\n{\n  vec3 v, tm, tp, u, vn;\n  float dMin, dn, df;\n  dMin = dstFar;\n  v = ro / rd;\n  tp = sz / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    vn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  }\n  return vec4 (dMin, vn);\n}\n\nvec3 ExShowScene (vec3 ro, vec3 rd)\n{\n  vec4 db4;\n  vec3 col, vn;\n  vec2 q;\n  float dstExObj, s;\n  col = vec3 (0.1, 0.12, 0.1);\n  db4 = BlkHit (ro, rd, vec3 (1.55, 1.35, 0.15));\n  if (db4.x < dstFar) {\n    dstExObj = ExObjRay (ro, rd);\n    if (dstExObj < dstFar) {\n      ro += dstExObj * rd;\n      vn = ExObjNf (ro);\n      if (max (abs (ro.x), abs (ro.y)) < 1. && ro.z < -0.01) col = InMain (ro.xy);\n      else col = vec3 (0.8, 0.2, 0.6) * (0.8 + 0.2 * Fbm2 (128. * ro.xy)) *\n         (0.2 + 0.8 * max (dot (vn, ltDirEx), 0.));\n      if (ro.z < -0.01) {\n        q = ro.xy - vec2 (0.95, -0.95);\n        s = abs (length (q) - 0.25) - 0.02;\n        col = mix (vec3 (0.1), col, min (smoothstep (0.002, 0.005, abs (s)), 1. - step (s, 0.) *\n           smoothstep (0.85, 0.9, mod (30. * (atan (q.y, q.x) / (2. * pi) + 0.5), 1.))));\n      }\n    }\n  }\n  if (db4.x < min (dstExObj, dstFar)) {\n    vn = db4.yzw;\n    col = mix (col, vec3 (1.) * (0.2 + 0.8 * max (dot (vn, ltDirEx), 0.)) +\n       0.1 * pow (max (0., dot (ltDirEx, reflect (rd, vn))), 32.),\n       0.1 + 0.9 * pow (1. - abs (dot (rd, vn)), 4.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  monoImg = false;\n  if (mPtr.z > 0. && mPtr.x > 0.4 && mPtr.y < -0.4) monoImg = true;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0. && ! monoImg) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -9.);\n  dstFar = 100.;\n  ltDirEx = vuMat * normalize (vec3 (1., 1., -1.));\n  EvalShipConf ();\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), 6.));\n    col += (1. / naa) * ExShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrEVCapsDf (vec3 p, vec4 u, float r)\n{\n  return length (p - clamp (dot (p, u.xyz), 0., u.w) * u.xyz) - r;\n}\n\nfloat PrEECapsDf (vec3 p, vec3 v1, vec3 v2, float r)\n{\n  return PrEVCapsDf (p - v1, vec4 (normalize (v2 - v1), length (v2 - v1)), r);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 ip, fp, t1, t2;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t1 = Hashv4f (dot (ip.xy, vec2 (1., 57.)));\n  t2 = Hashv4f (dot (ip.zw, vec2 (1., 57.)));\n  return vec2 (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n               mix (mix (t2.x, t2.y, fp.z), mix (t2.z, t2.w, fp.z), fp.w));\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsSWS.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1696, 1696, 1728, 1728, 2365], [2367, 2367, 2398, 2398, 2600], [2602, 2602, 2641, 2641, 3838], [3840, 3840, 3879, 3879, 4758], [4760, 4760, 4799, 4799, 5825], [5827, 5827, 5865, 5865, 7171], [7173, 7173, 7195, 7195, 7534], [7536, 7536, 7569, 7569, 7752], [7754, 7754, 7775, 7775, 8030], [8032, 8032, 8054, 8054, 9368], [9370, 9370, 9407, 9407, 9656], [9658, 9658, 9701, 9701, 12439], [12441, 12441, 12473, 12473, 13173], [13175, 13175, 13212, 13212, 14931], [14933, 14933, 14960, 14960, 15254], [15256, 15256, 15280, 15280, 15465], [15467, 15467, 15502, 15502, 15687], [15689, 15689, 15712, 15712, 15969], [15971, 15971, 16012, 16012, 16314], [16316, 16316, 16353, 16353, 17450], [17452, 17452, 17508, 17508, 18558], [18560, 18560, 18592, 18592, 18692], [18694, 18694, 18727, 18727, 18816], [18818, 18818, 18860, 18860, 18911], [18913, 18913, 18956, 18956, 19020], [19022, 19022, 19066, 19066, 19135], [19137, 19137, 19191, 19191, 19272], [19274, 19274, 19296, 19296, 19334], [19336, 19336, 19358, 19358, 19396], [19398, 19398, 19443, 19443, 19546], [19548, 19548, 19593, 19593, 19631], [19633, 19633, 19690, 19690, 19773], [19775, 19775, 19805, 19805, 19918], [19920, 19920, 19956, 19956, 20162], [20196, 20196, 20220, 20220, 20332], [20334, 20334, 20358, 20358, 20421], [20423, 20423, 20448, 20448, 20634], [20636, 20636, 20661, 20661, 20998], [21000, 21000, 21021, 21021, 21176], [21178, 21178, 21207, 21207, 21419], [21421, 21421, 21460, 21460, 21712]], "test": "untested"}
{"id": "slX3DB", "name": "plasma ball v1", "author": "milkfat", "description": "From 2021", "tags": ["raymarch"], "likes": 1, "viewed": 103, "published": 3, "date": "1626409126", "time_retrieved": "2024-07-30T19:10:44.499567", "image_code": "/*\n    Code date: 2021-06-23\n*/\n\n\n#define SCREEN_D -800.0\n#define AMOUNT_OF_PLASMA 15\n\nfloat hash(float n) {\n    float n2 = fract(n*5.18261);\n    return fract(n2*n);\n}\n\nfloat hash(int n) {\n    return hash(float(n));\n}\n\n\nfloat sdist(vec2 p, vec2 l0, vec2 l1) {\n    vec2 v1 = l1 - l0;\n    vec2 v2 = l0 - p;\n    vec2 v3 = vec2(v1.y,-v1.x);\n    return dot(v2,normalize(v3));\n}\n\n\nfloat dist(vec2 p, vec2 l0, vec2 l1) {\n    return abs(sdist(p, l0, l1));\n}\n\n\n\n\nvec2 rotate(vec2 p, float a) {\n    \n    return vec2 (\n        cos(a)*p.x - sin(a)*p.y,\n        sin(a)*p.x + cos(a)*p.y);\n}\n\nvec2 irotate(vec2 p, float a) {\n    return rotate(p, -a);\n}\n\nvec3 closestPoint(vec3 A, vec3 B, vec3 C) {\n    vec3 d = (C - B) / distance(C,B);\n    vec3 v = A - B;\n    float t = dot(v,d);\n    vec3 P = B + t * d;\n    return P;\n}\n\nvec3 iproject(vec3 p)\n{\n\n    \n    p.x -= iResolution.x/2.0;\n    p.y -= iResolution.y/2.0;\n    \n    p.z -= 2000.0;\n    p.x /= iResolution.y/675.0;\n    p.y /= iResolution.y/675.0;\n    \n    p.x *= (SCREEN_D+p.z);\n    p.y *= (SCREEN_D+p.z);\n    \n    p.x /= (SCREEN_D);\n    p.y /= (SCREEN_D);\n    \n    \n    p.z += 2000.0;\n    p.z += 400.0;\n    \n    p.y += sin(iTime*.5)*200.0;\n    p.x += cos(iTime*.35)*200.0;\n    p.z += cos(iTime*.4)*300.0;\n    p.yz = irotate(p.yz, sin(iTime*.3)*.04);\n    p.xz = irotate(p.xz, cos(iTime*.3)*.02);\n    p.yx = irotate(p.yx, cos(iTime*.5)*.02);\n    \n    p.yz =  irotate(p.yz,- 2.3+2.7+6.28*sin((iMouse.y)/iResolution.y));\n    p.xz =  irotate(p.xz, 4.1+6.28*sin((iMouse.x)/iResolution.x));\n    return p;\n    \n}\n\nvec4 calcLight(vec3 p, vec3 ps) {\n    float wx = max((5000.0 - p.x)/ps.x,(-5000.0 - p.x)/ps.x);\n    float wy = max((5000.0 - p.y)/ps.y,(-5000.0 - p.y)/ps.y);\n    float wz = max((5000.0 - p.z)/ps.z,(-5000.0 - p.z)/ps.z);\n    float w = min(min(wx,wy),wz);\n    p += ps*w;\n    vec3 light = vec3(500,3000,2000);\n    vec3 l = light-p;\n    float ll = length(l);\n    l = normalize(l);\n    //box norm X\n    if(abs(p.x) > max(abs(p.y),abs(p.z))) {\n        vec3 norm = vec3(-p.x/abs(p.x),0,0);\n        norm.x += (texture(iChannel0,.4*p.yz/iResolution.xy).b - texture(iChannel0,.4*vec2(p.y+.1,p.z)/iResolution.xy).b)*50.0;\n        norm.y += (texture(iChannel0,.4*p.yz/iResolution.xy).b - texture(iChannel0,.4*vec2(p.y,p.z+.1)/iResolution.xy).b)*50.0;\n        float bri = 2.0*dot(l,norm) / (ll*ll*.0000005);\n        return clamp(texture(iChannel0,.4*p.zy/iResolution.xy)*bri,0.0,1.0);\n    //box norm Y\n    } else if (abs(p.y) > max(abs(p.x),abs(p.z))) {\n        vec3 norm = vec3(0,-p.y/abs(p.y),0);\n        norm.x += (texture(iChannel0,.4*p.xz/iResolution.xy).b - texture(iChannel0,.4*vec2(p.x+.1,p.z)/iResolution.xy).b)*50.0;\n        norm.y += (texture(iChannel0,.4*p.xz/iResolution.xy).b - texture(iChannel0,.4*vec2(p.x,p.z+.1)/iResolution.xy).b)*50.0;\n        float bri = 2.0*dot(l,norm) / (ll*ll*.0000005);\n        return clamp(texture(iChannel0,.4*p.xz/iResolution.xy)*bri,0.0,1.0);\n    //box norm Z\n    } else {\n        vec3 norm = vec3(0,0,-p.z/abs(p.z));\n        norm.x += (texture(iChannel0,.4*p.xy/iResolution.xy).b - texture(iChannel0,.4*vec2(p.x+.1,p.y)/iResolution.xy).b)*50.0;\n        norm.y += (texture(iChannel0,.4*p.xy/iResolution.xy).b - texture(iChannel0,.4*vec2(p.x,p.y+.1)/iResolution.xy).b)*50.0;\n        float bri = 2.0*dot(l,norm) / (ll*ll*.0000005);\n        return clamp(texture(iChannel0,.4*p.xy/iResolution.xy)*bri,0.0,1.0);\n    }\n}\nfloat rmod(vec3 cp) {\n    float asdf = sin(atan(cp.y,cp.z)*36.0);\n    float asdf2 = sin(atan(cp.x,cp.z)*36.0);\n    return (asdf+asdf2)*3.0;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float spec = 0.0;\n    vec2 coord = fragCoord-.5;\n    //coord = rotate(coord, sin(coord.x*.01)*.1);\n    vec3 p = iproject(vec3(coord, 800));\n    vec3 p2 = iproject(vec3(coord, -1000));\n    vec3 ps = normalize(p2-p);\n    float old_d = length(p);\n    vec3 pg = vec3(0,0,0); //glass reflection\n    vec3 psg = vec3(0,0,0);\n    bool glass_reflect = false;\n    \n    vec3 pg2 = vec3(0,0,0); //glass reflection\n    vec3 psg2 = vec3(0,0,0);\n    bool glass_reflect2 = false;\n    \n        //glass sphere\n    vec3 cp = closestPoint(vec3(0,0,0), p, p2);\n    \n    if( length(cp) > 800.0 && old_d > 800.0) {} else\n    {\n        float A = length(cp);\n        float C = 800.0;\n        float B = sqrt(C*C-A*A);\n        p = cp - ps*B;\n        //p+=rmod(normalize(p));\n        spec += dot(reflect(ps, normalize(p)), normalize(vec3(500,8000,2000)));\n        pg = p;\n        glass_reflect = true;\n        psg = reflect(ps,normalize(p));\n        ps = refract(ps, normalize(p), 1.0/1.52);\n        p+=ps*10.0;\n        ps = refract(ps, normalize(p), 1.52/1.0);\n    }\n    \n    \n    bool glass_out = false;\n    \n    \n    float val = 0.0;\n    float r = sin(iTime)*700.0;\n    //cast rays\n    for (int i = 0; i <60; i++) {\n        float d = length(p);\n        \n        //glass sphere\n        if(!glass_out && d > 800.0 && old_d < 800.0) {\n            vec3 cp = closestPoint(vec3(0,0,0), p, p+ps);\n            float A = length(cp);\n            float C = 800.0;\n            float B = -sqrt(C*C-A*A);\n            p = cp - ps*B; \n        //p+=rmod(normalize(p));\n        pg2 = p;\n        glass_reflect2 = true;\n        psg2 = reflect(ps,normalize(-p));\n            d=length(p);\n            ps = refract(ps, normalize(-p), 1.0/1.52);\n            p+=ps*10.0;\n            ps = refract(ps, normalize(-p), 1.52/1.03); \n            glass_out = true;\n            //i=50;\n            break;\n        }\n    \n        \n        float dist = 100.0;\n        //check ray against plasma\n        for (int j = 0; j < AMOUNT_OF_PLASMA; j++) {\n        \n            float more = clamp(100.0 - (800.0 - d), 0.0, 100.0);\n            more /= 100.0;\n            more *= more;\n            more *= more;\n            more *= 50.0;\n            \n            vec3 lps = vec3(0,1,0);\n            float h = hash(j);\n            float time = iTime+float(j)*100.0;\n            //float h2 = fract(h*8.1731);\n            lps.xy = rotate(lps.xy,(h-.5)*6.28*time*.087+cos((d+more)/150.0-h*time*3.5)*.15);\n            lps.yz = rotate(lps.yz,(h-.5)*6.28*time*.14+cos((d+more)/150.0-h*time*2.0)*.15);\n\n            lps = normalize(lps);\n            vec3 a1 = d*lps;\n            if(d <= 801.0) {\n                dist = min(dist,distance(p,a1));\n                float v = clamp((35.0+more)-distance(p,a1), 0.0, 35.0);\n                v += clamp(5.0 - (d - 60.0),0.0,20.0)*.05;\n                //v+= v*clamp(100.0 - (800.0 - d), 0.0, 100.0)*.05;\n                if(d < 100.0) v -= v*(100.0-d)/100.0;\n                val += v;\n            } else {\n                break;\n            }\n        }\n        old_d = d;\n        if(d < 50.0) { //small sphere in the middle\n            ps = vec3(0,0,0);\n            break;\n        }\n        p+=ps*max(min(dist*.5,clamp(808.0-d,0.0,1000.0)),5.0);\n    }\n    \n    //val += clamp(50.0-distance(p,vec3(0,0,0)), 0.0, 50.0)*100.0;\n    val /= 85.0;\n    vec3 col = vec3((val-1.0)*.5,(val-2.0)*.15,val);\n    col = clamp(col, 0.0, 1.0);\n    \n    \n  \n    fragColor = calcLight(p,ps)*vec4(1,.8,.7,1);\n    if(glass_reflect) fragColor += calcLight(pg,psg)*.3*vec4(1,.8,.7,1); //outer reflection\n    if(glass_reflect2) fragColor += calcLight(pg2,psg2)*.1*vec4(1,.8,.7,1); //inner reflection\n \n    p.x+=iTime*100.0;\n    fragColor += vec4(col,1.0);\n    spec=clamp(spec,0.0,1.0);\n    spec*=spec;\n    spec*=spec;\n    spec*=spec;\n    spec*=spec;\n    spec*=spec;\n    spec*=spec;\n    spec*=spec;\n    spec*=spec;\n    fragColor += spec*vec4(1,.8,.7,1);\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2));\n    \n}", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slX3DB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 108, 108, 167], [169, 169, 188, 188, 217], [220, 220, 259, 259, 372], [375, 375, 413, 413, 449], [454, 454, 484, 484, 576], [578, 578, 609, 609, 637], [639, 639, 682, 682, 804], [806, 806, 829, 829, 1542], [1544, 1544, 1577, 1577, 3390], [3391, 3391, 3412, 3412, 3532], [3533, 3533, 3590, 3590, 7542]], "test": "untested"}
{"id": "NtfSDS", "name": "Warped space", "author": "Dinno", "description": "Just tested an idea about optimization of lattice based acceleration structure. The idea was bad, but warped lattice looks ok :)", "tags": ["test", "warped", "lattice"], "likes": 0, "viewed": 227, "published": 3, "date": "1626394851", "time_retrieved": "2024-07-30T19:10:45.360266", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cc = fragCoord - iResolution.xy / vec2(2);\n    float l = length(cc); //max(abs(cc.x), abs(cc.y));\n    float scale = log(l) / l * 10.0 * (1.5 + sin(iTime));\n    vec2 c = cc * scale;\n    fragColor = any(equal(ivec2(c) % ivec2(10), ivec2(0))) ? vec4(1) : vec4(0);\n    if (length(c) < 4.0) fragColor = vec4(0, 1, 0, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtfSDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 384]], "test": "untested"}
{"id": "NlXSDS", "name": "Cracktro at the partyplace", "author": "merry", "description": "Mixing my Skid Row Lemmings Cracktro shader (https://www.shadertoy.com/view/lsKcRh) with some non-physically-based experiments on GI.", "tags": ["2d", "amiga", "projector", "lemmings", "cracktro", "skidrow", "glossiness"], "likes": 19, "viewed": 1142, "published": 3, "date": "1626392395", "time_retrieved": "2024-07-30T19:10:46.578010", "image_code": "//\tFXAA (autor: Mudlord).\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2  p         = fragCoord.xy/iResolution.xy;\n    vec2  pp        = 1.0 / iResolution.xy;\n    vec4  color     = texture(iChannel0, vec2(fragCoord.xy * pp));\n    vec3  luma      = vec3(0.299, 0.587, 0.114);\n    float lumaNW    = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.,-1.)) * pp).xyz, luma);\n    float lumaNE    = dot(texture(iChannel0, (fragCoord.xy + vec2( 1.,-1.)) * pp).xyz, luma);\n    float lumaSW    = dot(texture(iChannel0, (fragCoord.xy + vec2(-1., 1.)) * pp).xyz, luma);\n    float lumaSE    = dot(texture(iChannel0, (fragCoord.xy + vec2( 1., 1.)) * pp).xyz, luma);\n    float lumaM     = dot(color.xyz, luma);\n    float lumaMin   = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax   = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2  dir       = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * (1.0/8.0)), (1.0/128.0));\n    float rcpDirMin = 2.5 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(8.0, 8.0), max(vec2(-8.0, -8.0), dir * rcpDirMin)) * pp;\n\n    vec3 rgbA = 0.5 * \n    (\n        texture(iChannel0, fragCoord.xy * pp + dir * (1. / 3. -.5)).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * (2. / 3. -.5)).xyz\n    );\n    vec3 rgbB = rgbA * 0.5 + 0.25 * \n    (\n        texture(iChannel0, fragCoord.xy * pp + dir *-.5).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * .5).xyz\n    );\n\n    float lumaB = dot(rgbB, luma);\n    fragColor = vec4((lumaB < lumaMin) || (lumaB > lumaMax) ? rgbA : rgbB, color.w);\n\n    fragColor*= (1. / pow(1. + pow(length(p*2.-1.) * .3,  3.), 75.));  // Vignetting.\n    fragColor = pow((((fragColor * (.15 * fragColor + .05) + .004) / (fragColor * (.15 * fragColor + .50) + .06)) - .0667) / .6 * 3.1, vec4(.45)); // Tonemapping & Gamma correction.\n}\n", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27825, "src": "https://soundcloud.com/david-canadas-mazo/lff", "ctype": "musicstream", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "// Skid Row Lemmings Cracktro Remake by merry^Architect.\n// http://www.pouet.net/prod.php?which=4021 (Pöuet).\n// https://www.youtube.com/watch?v=2YJGHcCkYEw (Youtube).\n// Coded by merry ^ Architect in 2018.\n\n// This cracktro is my favourite of all times (the music by 4mat is probably the actual reason!!!).\n// With this little tribute I wanted to make a homage to all Amiga cracktros that introduced me into the demoscene. \n\n// Common: shared definitions.\n\n#define SCR_WIDTH  320 // Amiga viewport width , in pixels.\n#define SCR_HEIGHT 256 // Amiga viewport height, in pixels.\n", "buffer_a_code": "// Skid Row Lemmings Cracktro Remake by merry^Architect.\n// http://www.pouet.net/prod.php?which=4021 (Pöuet).\n// https://www.youtube.com/watch?v=2YJGHcCkYEw (Youtube).\n// Coded by merry ^ Architect in 2018.\n\n// This cracktro is my favourite of all times (the music by 4mat is probably the actual reason!!!).\n// With this little tribute I wanted to make a homage to all Amiga cracktros that introduced me into the demoscene. \n\n// Buffer A: Mimics the Skid Row Lemmings Cracktro at its original resolution.\n// For those interested, I did the worst approach ever to the UV-to-Amiga coordinates system mapping. Too late to \n// change it now. Further cracktro remakes will do better... :)\n\nconst float kPi = 3.14159265359;\n\n// Default font.\nconst int kDefaultFont[] = int[]\n(\n\t124, 198, 198, 230, 230, 254, 124,  0, // Number 0.\n     56,  24,  24,  56,  56, 254, 254,  0, // Number 1.\n    124, 198,   6, 124, 224, 254, 254,  0, // Number 2.\n    252,   6,   6,  60,  14, 254, 252,  0, // Number 3.\n    198, 198, 198, 126,  14,  14,  14,  0, // Number 4.\n    254, 192, 192, 252,  14, 254, 252,  0, // Number 5.\n    124, 198, 192, 252, 206, 254, 124,  0, // Number 6.\n    252, 254,   6,  14,  14,  14,  14,  0, // Number 7.\n    124, 198, 198, 124, 198, 254, 124,  0, // Number 8.\n    124, 198, 198, 126,  14, 254, 124,  0, // Number 9.\n     16,  16, 254, 124,  56, 108,  68,  0, // Star.\n    124, 198, 198, 254, 230, 230, 230,  0, // A.\n    252, 198, 198, 252, 230, 254, 252,  0, // B.\n    124, 198, 192, 224, 230, 254, 124,  0, // C.\n    252, 198, 198, 230, 230, 230, 252,  0, // D.\n    126, 192, 192, 248, 224, 254, 126,  0, // E.\n    126, 192, 192, 248, 224, 224, 224,  0, // F.\n    124, 198, 192, 238, 230, 254, 124,  0, // G.\n    198, 198, 198, 254, 230, 230, 230,  0, // H.\n    254,  24,  24,  56,  56, 254, 254,  0, // I.\n     12,  12,  12,  14, 206, 254, 124,  0, // J.\n    198, 204, 216, 240, 248, 236, 230,  0, // K.\n    192, 192, 192, 224, 224, 254, 126,  0, // L.\n    238, 254, 214, 230, 230, 230, 230,  0, // M.\n\t252, 198, 198, 230, 230, 230, 230,  0, // N.\n\t124, 198, 198, 230, 230, 254, 124,  0, // O.\n    252, 198, 198, 252, 224, 224, 224,  0, // P.\n\t124, 198, 198, 230, 230, 248, 126,  0, // Q.\n    252, 198, 198, 252, 248, 236, 230,  0, // R.\n    124, 198, 192, 124,   6, 254, 252,  0, // S.   \n    254,  24,  24,  56,  56,  56,  56,  0, // T.\n    198, 198, 198, 230, 230, 254, 124,  0, // U.\n    198, 198, 198, 230, 230, 124,  56,  0, // V.\n    198, 198, 198, 214, 254, 238, 198,  0, // W.    \n    198, 198, 108,  56, 124, 230, 230,  0, // X.\n    198, 198, 198, 126,   6, 254, 252,  0, // Y.\n    254,  12,  24, 112, 224, 254, 254,  0, // Z.\n      0,   0,   0,   0,   0,  48,  48,  0, // Period.\n      0,   0,   0,  60,  60,   0,   0,  0, // Hyphen.\n     56,  56,  56,  56,   0,  56,  56,  0, // Exclamation sign.\n      0,   0,   0,   0,   0,  48, 112,112, // Comma.\n    108, 254, 254, 254, 124,  56,  16,  0, // Heart.\n      0,   0,   0,   0,   0,   0,   0,  0, // Space.\n      0\n);//kDefaultFont.\n\nconst float kCreditsSprite[] = float[]\n(\n    .9,.6,.0,.0,.0,.6,.0,.0,.9,.6,.3,.0,.9,.6,.3,.0,.0,.9,.6,.3,.0,.0,.9,.6,.0,.6,.0,.0,.0,.0,.0,.9,.6,.0,.0,.0,.9,.6,.3,.0,.0,.0,.9,.6,.3,.0,.0,.9,.6,.3,.0,.0,.0,.9,.6,.3,.3,.0,.9,.6,.0,.6,.0,.9,.6,.0,.9,.6,.3,.3,.0,.0,.9,.6,.3,.0,.0,.9,.6,.3,.3,.0,.9,.6,.3,.3,\n    .6,.3,.3,.0,.3,.3,.0,.9,.3,.0,.0,.0,.6,.3,.0,.3,.0,.6,.3,.0,.3,.0,.6,.3,.0,.3,.0,.0,.0,.0,.9,.3,.0,.3,.0,.9,.3,.0,.0,.0,.0,.0,.6,.3,.0,.3,.0,.6,.3,.0,.3,.0,.9,.3,.0,.0,.0,.0,.6,.3,.0,.3,.0,.6,.3,.0,.0,.3,.3,.0,.0,.9,.3,.0,.0,.0,.9,.3,.0,.0,.0,.0,.0,.3,.3,.0,\n    .3,.3,.3,.3,.3,.3,.0,.6,.3,.3,.3,.0,.3,.3,.3,.0,.0,.3,.3,.3,.0,.0,.3,.3,.3,.3,.0,.0,.0,.0,.6,.3,.0,.3,.0,.6,.3,.3,.0,.0,.0,.0,.3,.3,.3,.3,.0,.3,.3,.3,.0,.0,.6,.3,.0,.0,.0,.0,.3,.3,.3,.3,.0,.3,.3,.0,.0,.3,.3,.0,.0,.6,.3,.3,.0,.0,.6,.3,.0,.0,.0,.0,.0,.3,.3,.0,\n    .3,.3,.0,.3,.0,.3,.0,.3,.3,.0,.0,.0,.3,.3,.0,.3,.0,.3,.3,.0,.3,.0,.0,.3,.3,.0,.0,.0,.0,.0,.3,.3,.0,.3,.0,.3,.3,.0,.0,.0,.0,.0,.3,.3,.0,.3,.0,.3,.3,.0,.3,.0,.6,.3,.0,.0,.0,.0,.3,.3,.0,.3,.0,.3,.3,.0,.0,.3,.3,.0,.0,.3,.3,.0,.0,.0,.6,.3,.0,.0,.0,.0,.0,.3,.3,.0,\n    .3,.6,.0,.0,.0,.6,.0,.3,.3,.3,.6,.0,.3,.6,.0,.6,.0,.3,.6,.0,.6,.0,.0,.3,.6,.0,.0,.0,.0,.0,.0,.3,.6,.0,.0,.3,.6,.0,.0,.0,.0,.0,.3,.6,.0,.6,.0,.3,.6,.0,.6,.0,.0,.3,.3,.3,.6,.0,.3,.6,.0,.6,.0,.3,.3,.0,.0,.3,.6,.0,.0,.3,.3,.3,.6,.0,.0,.3,.3,.3,.6,.0,.0,.3,.6,.0\n);//kCreditsSprite.\n\n#define N0  0\n#define N1  1\n#define N2  2\n#define N3  3\n#define N4  4\n#define N5  5\n#define N6  6\n#define N7  7\n#define N8  8\n#define N9  9\n#define XX 10 // Star.\n#define A  11\n#define B  12\n#define C  13\n#define D  14\n#define E  15\n#define F  16\n#define G  17\n#define H  18\n#define I  19\n#define J  20\n#define K  21\n#define L  22\n#define M  23\n#define N  24\n#define O  25\n#define P  26\n#define Q  27\n#define R  28\n#define S  29\n#define T  30\n#define U  31\n#define V  32\n#define W  33\n#define X  34\n#define Y  35\n#define Z  36\n#define DT 37 // Period.\n#define HP 38 // Hyphen.\n#define EX 39 // Exclamation sign.\n#define CM 40 // Comma.\n#define HT 41 // Heart.\n#define _  42 // Space.\n\n#define\tCHR_WIDTH   8\n#define CHR_HEIGHT  8\n#define TXT_WIDTH\t(SCR_WIDTH  / CHR_WIDTH )\n#define TXT_HEIGHT  (SCR_HEIGHT / CHR_HEIGHT)\n#define XCR_SPEED\t80\n#define XCR_MIN_Y   11\n#define XCR_MAX_Y   28\n#define VAR_Y_POS   (SCR_HEIGHT + CHR_HEIGHT + CHR_HEIGHT)\n#define NUM_STARS\t256\n\nbool charPixel(ivec2 pixelIndex, int charIndex) { return bool(kDefaultFont[charIndex * CHR_HEIGHT + (pixelIndex.y % CHR_HEIGHT)] & (1 << (8 - (pixelIndex.x % CHR_WIDTH)))); }\n\n// The static text that appears at the top of the screen character by character.\nconst int kStaticText[] = int[]\n(\n\t_ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , XX, _ , A , R , C , H , I , T , E , C , T , DT, _ , XX, _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , // Line 0 | * ARCHITECT. * \n    _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , P , R , E , S , E , N , T , S ,\t_ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , // Line 1 | PRESENTS\n\t_ , _ , _ , _ , _ , _ , _ , A , N , O , T , H , E , R , _ , L , I , G , H , T , S , P , E , E , D , _ , R , E , L , E , A , S , E , _ , _ , _ , _ , _ , _ , _ , // Line 2 | ANOTHER LIGHT_ EED RELEASE\n\t_ , _ , _ , _ , _ , _ , _ , _ , _ , _ ,\t_ , _ , _ , _ , _ , _ , _ , _ , _ , _ ,\t_ , _ , _ , _ , _ , _ , _ , _ , _ , _ ,\t_ , _ , _ , _ , _ , _ , _ , _ , _ , _ , // Line 3 | <empty>\n    _ , _ , _ , S , K , I , D , _ , R , O , W , _ , L , E , M , M , I , N , G , S , _ , C , R , A , C , K , T , R , O , _ , R , E , M , A , K , E , DT, _ , _ , _ , // Line 4 | SKID ROW LEMMINGS CRACKTRO REMAKE\n \t_ , _ , _ , _ , _ , _ , _ , _ , _ , _ ,\t_ , _ , _ , _ , _ , _ , _ , _ , _ , _ ,\t_ , _ , _ , _ , _ , _ , _ , _ , _ , _ ,\t_ , _ , _ , _ , _ , _ , _ , _ , _ , _ , // Line 5 | <empty>\n    _ , _ , _ , D , O , N , E , _ , B , Y , _ , M , E , R , R , Y , _ , O , F , _ , A , R , C , H , I , T , E , C , T , _ , I , N , _ , N2, N0, N1, N8, _ , _ , _ , // Line 6 | DONE BY MERRY FROM ARCHITECT IN 2018\n    C , H , E , C , K , _ , S , H , A , D , E , R , T , O , Y , DT, C , O , M , _ , F , O , R , _ , M , O , R , E , _ , F , A , N , C , Y , _ , S , T , U , F , F , // Line 7 | CHECK SHADERTOY.COM FOR MORE FANCY STUFF\n    _ , _ , _ , A , N , D , _ , O , U , R , _ , F , O , R , T , H , C , O , M , I , N , G , _ , P , R , O , D , U , C , T , I , O , N , S , DT, DT, DT, _ , _ , _ , // Line 8 | AND OUR FORTHCOMING PRODUCTIONS...\n    _ , _ , _ , S , E , E , _ , Y , O , U , _ , L , A , T , E , R , _ , I , N , _ , A , N , O , T , H , E , R , _ , I , N , T , R , O , _ , EX, EX, EX, _ , _ , _   // Line 9 | SEE YOU LATER IN ANOTHER INTRO !!!\n);//kStaticText.\n\n// The dynamic text that scrolls right to left using a sinus scroller.\nconst int kScrollingText[] = int[]\n(\n\t_ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , \n\t_ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , \n\tXX, _ , A , R , C , H , I , T , E , C , T , _ , XX,\n\t_ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , // Text 0: * ARCHITECT *\n    HP, _ , T , H , E , _ , L , E , A , D , I , N , G , _ , F , O , R , C , E , _ , HP, \n\t_ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , // Text 1: - THE LEADING FORCE - \n    I , S , _ , B , A , C , K , _ , O , N , _ , Y , O , U , R , _ , S , C , R , E , E , N , _ , W , I , T , H ,\n\t_ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , // Text 2: IS BACK ON YOUR SCREEN WITH\n    XX, _ , S , K , I , D , _ , R , O , W , _ , L , E , M , M , I , N , G , S , _ , C , R , A , C , K , T , R , O , _ , \n    R , E , M , A , K , E , _ , XX, \n\t_ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , // Text 3: SKID ROW LEMMINGS CRACKTRO REMAKE\n    C , O , D , E , D , _ , B , Y , _ , M , E , R , R , Y , _ , O , F , _ ,\n    A , R , C , H , I , T , E , C , T , _ , I , N , _ , T , H , E , _ , Y , E , A , R , _ , O , F , _ , \n    N2, N0, N1, N8, _ , EX, EX, EX,\n    _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , // Text 4: CODED BY MERRY FROM ARCHITECT IN THE YEAR OF 2018\n\n    O , R , I , G , I , N , A , L , _ , C , O , D , E , _ , B , Y , _ , D , A , N , _ , O , F , _ , \n    A , N , A , R , C , H , Y , _ , XX, _ ,\n    O , R , I , G , I , N , A , L , _ , M , U , S , I , C , _ , M , O , D , U , L , E , _ ,\n    B , Y , _ , N4, M , A , T ,\n    _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , // Text 5: ORIGINAL CODE BY DAN OF ANACHY * ORIGINAL MUSIC MODULE BY 4MAT\n    I , F , _ , Y , O , U , _ , W , A , N , T , _ , T , O , _ , E , N , J , O , Y , _ , \n    T , H , E , _ , U , L , T , I , M , A , T , E , _ , N3, D , _ , \n    E , X , P , E , R , I , E , N , C , E , _ , I , N , _ , Y , O , U , R , _ , B , R , O , W , S , E , R , _ , \n    V , I , S , I , T , _ , S , H , A , D , E , R , T , O , Y , DT, C , O , M , _ , EX, EX, EX,\n    _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , // Text 6: IF YOU WANT TO ENJOY THE ULTIMATE 3D EXPERIENCE IN YOUR BROWSER VISIT SHADERTOY.COM !!!\n    G , R , E , E , T , I , N , G , S , _ , T , O , _ , A , L , L , _ , O , U , R , _ , F , R , I , E , N , D , S , _ ,\n    A , R , O , U , N , D , _ , T , H , E , _ , G , L , O , B , E , _ , EX, EX, EX,\n    _ , _ , _ , _ , _ , _ , _ , \n    HT, _ , A , L , C , A , T , R , A , Z , _ , HT, _ ,\n    A , N , A , R , C , H , Y , _ , HT, _ ,\n    A , N , G , E , L , S , _ , HT, _ ,\n    A , N , T , H , R , O , X , _ , HT, _ ,\n    B , A , M , I , G , A , _ , S , E , C , T , O , R , _ , O , N , E , _ , HT, _ ,\n    C , R , Y , S , T , A , L , _ , HT, _ ,\n    F , A , I , R , L , I , G , H , T , _ , HT, _ ,\n    H , O , R , I , Z , O , N , _ , HT, _ ,\n    L , E , M , O , N , DT, _ , HT, _ ,\n    M , E , L , O , N , _ , D , E , Z , I , G , N , _ , HT, _ ,\n    P , A , R , A , D , O , X , _ , HT, _ ,\n    P , A , R , A , N , O , I , M , I , A , _ , HT, _ ,\n    Q , U , A , R , T , E , X , _ , HT, _ ,\n    R , A , Z , O , R , _ , N1, N9, N1, N1, _ , HT, _ ,\n    R , E , D , _ , S , E , C , T , O , R , CM, _ , I , N , C , DT, _ , HT, _ ,\n    S , A , N , I , T , Y , _ , HT, _ ,\n    S , C , O , O , P , E , X , _ , HT, _ ,\n    S , K , I , D , _ , R , O , W , _ , HT, _ ,\n    S , U , P , P , L , E , X , _ , HT, _ ,\n    T , H , E , _ , S , I , L , E , N , T , S , _ , HT, _ ,\n    T , R , I , S , T , A , R , _ , HT, _ ,\n    V , I , S , I , O , N , _ , F , A , C , T , O , R , Y ,_ , HT , _ ,\n    _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , // Text 7: GREETINGS TO ALL OUR FRIENDS AROUND THE GLOBE !!!\n\tI , F , _ , Y , O , U , _ , U , S , E , _ , T , H , I , S , _ , \n    P , I , E , C , E , _ , O , F , _ ,\n    S , O , F , T , W , A , R , E , _ , C , A , L , L , E , D , _ , \n    S , H , A , D , E , R , T , O , Y , DT, C , O , M , _ ,\n    P , L , E , A , S , E , _ , C , O , N , S , I , D , E , R , _ , \n    C , O , N , T , R , I , B , U , T , I , N , G , _ , \n    T , O , _ , I , T , _ , O , N , _ , P , A , T , R , E , O , N , \n    _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , // Text 8: IF YOU USE THIS PIECE OF SOFTWARE CALLED SHADERTOY.COM PLEASE CONSIDER CONTRIBUTING TO IT ON PATREON\n    DT, DT, DT, _ ,\n    S , C , R , O , L , L , _ , R , E , S , T , A , R , T , S , _ ,\n    DT, DT, DT \t\t\t\t\t\t\t\t\t\t\t\t// Text 9: ... SCROLL RESTARTS ...\n);//kScrollingText.\n\nconst int kStaticTextScanColors[] = int[]\n(\n\t140,  0,  0,173, 32, 33,206, 69, 66,238,101, 99,206, 69, 66,173, 32, 33,140,  0,  0,0,0,0, // Red.\n\t140, 69,  0,173,101, 33,206,138, 66,238,170, 99,206,138, 66,173,101, 33,140, 69,  0,0,0,0, // Orange.\n    140,138,  0,173,170, 33,206,206, 66,238,239, 99,206,206, 66,173,170, 33,140,138,  0,0,0,0, // Yellow.\n      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,0,0,0, // Black.\n      0,138,  0, 33,170, 33, 66,206, 66, 99,239, 99, 66,206, 66, 33,170, 33,  0,138,  0,0,0,0, // Green.\n      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,0,0,0, // Black.\n      0, 69,140, 33,101,173, 66,138,206, 99,170,238, 66,138,206, 33,101,173,  0, 69,140,0,0,0, // Light blue.\n      0,  0,140, 33, 32,173, 66, 69,206, 99,101,238, 66, 69,206, 33, 32,173,  0,  0,140,0,0,0, // Dark  blue.\n     66,  0,140, 99, 32,173,140, 69,206,173,101,238,140, 69,206, 99, 32,173, 66,  0,140,0,0,0, // Magenta.\n    140,  0,140,173, 32,173,206, 69,206,238,101,238,206, 69,206,173, 32,173,140,  0,140,0,0,0  // Pink.        \n);//kStaticTextScanColors.\n\nfloat rand(vec2 uv) { return fract(sin(dot(uv.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n\n// Palette function by iq, see more at https://www.shadertoy.com/view/ll2GD3.\nvec3  pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) { return a + b*cos(6.28318*(c*t + d)); }\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    \n    float tTime = floor(iTime/.02)*.02; // Drops down the perceived frame rate.\n    vec2  uv  = fragCoord / iResolution.xy;\n\tvec4  col = vec4(0); \n    ivec2 wx  = ivec2(fragCoord.x, fragCoord.y); // Local fragment coordinate.\n\tint   chi = int(floor(tTime * 20.));// Static text character index.\n\n    // Writes out the starfield state.\n\tvec4 sfx = vec4(0);\n    if ((wx.y == VAR_Y_POS) && (wx.x < NUM_STARS))\n\t{\n    \tif (0 == iFrame)\n\t    {//\tInitializes starfield data.\n\t\t\tcol = vec4(rand(uv), rand(uv + fragCoord.xx), float(wx.x) / float(NUM_STARS), 0);\n    \t}\n\t    else\n    \t{// Updates the starfield data.\n            vec4 displacement = vec4(sin(tTime * 1.0/0.9) * .01, sin(tTime * 1.0/1.32) * .02, sin(iTime * .25) * .01 ,0.);\n\t\t\tcol = texture(iChannel0, uv);\n\t\t\tcol+= displacement * clamp(col.z, .3, 1.);\n\t\t\tcol = mod(col,1.);            \n\t    }\n\t}\n\t\n    // Oldskool way of \"starfielding\". Really dirty but didn't want an actual 3D approach.\n    if ((wx.y < (SCR_HEIGHT - CHR_HEIGHT)) && (wx.x < SCR_WIDTH))\n    {\n        for (int i = 0; i < NUM_STARS; ++i)\n\t\t{\n            vec2 ruv = vec2(float(i) / iResolution.x, float(VAR_Y_POS + 1) / iResolution.y);\n\t\t\tvec4 rstate = texture(iChannel0, ruv);\n\n            //\tSimulates depth.\n            rstate.xy = rstate.xy * 2.  - 1. ;\n\t\t\trstate.xy*= clamp(rstate.z,.7,2.);\n\t\t\trstate.xy = rstate.xy * .5  + .5 ;\n\t\t\tif ((int(rstate.x * float(SCR_WIDTH)) == wx.x) && (int(rstate.y*float(SCR_HEIGHT)) == wx.y))\n\t\t\t{\n\t\t\t    sfx = mix(vec4(.1), vec4(1), pow(rstate.z, 2.5));\n\t\t\t    break;\n\t\t\t}            \n\t\t}\n    }\n    \n    // Top Copper-like scanline.\n\tif ((wx.x < SCR_WIDTH) && (wx.y == 1))\n\t    col = vec4(pal(uv.x + tTime*.75, vec3(.5), vec3(5), vec3(1), vec3(.0,.33,.67)), 1);\n    \n    // Static text.\n    wx.y +=-8;    \n\tif ((wx.y >= 0) && (wx.y < (CHR_HEIGHT * kStaticText.length() / TXT_WIDTH)))\n    {\n\t\tint x = wx.x / CHR_WIDTH ;\n\t\tint y = wx.y / CHR_HEIGHT;\n        int i = y * TXT_WIDTH + x;\n        \n        if ((x < TXT_WIDTH) && (y < TXT_HEIGHT) && (chi > i))\n        {\n            vec4 mul = mix(vec4(1), vec4(\n\t\t\t    kStaticTextScanColors[wx.y*3    ],\n\t\t\t    kStaticTextScanColors[wx.y*3 + 1],\n\t\t\t    kStaticTextScanColors[wx.y*3 + 2],\n\t\t\t256)/ 256., min(1.,float(chi - i) * (tTime * 10.) - float(chi)));\n\t\t\tcol = vec4(charPixel(wx, kStaticText[i])) * mul;\n        }\n    }\n\n    // Scrolling text buffer.\n    if ((wx.y >= SCR_HEIGHT) && (wx.y < SCR_HEIGHT+CHR_HEIGHT))\n    {\n\t    ivec2 zx = wx;\n        zx.x  = zx.x + int(tTime * float(XCR_SPEED));\n\t\tint x = zx.x / CHR_WIDTH ;\n\t\tint y = (zx.y) / CHR_HEIGHT - CHR_HEIGHT * TXT_HEIGHT;\n        if (((int(fragCoord.x) / CHR_WIDTH) < TXT_WIDTH) && (y < TXT_HEIGHT))\n        \tcol = vec4(charPixel(ivec2(mod(vec2(zx), vec2(CHR_WIDTH, 0))), kScrollingText[x % kScrollingText.length()]));\n    }    \n\n    // Scrolling remap to the viewport area.\n    if ((wx.x < SCR_WIDTH) && (wx.y >= CHR_HEIGHT*XCR_MIN_Y) && (wx.y <= CHR_HEIGHT*XCR_MAX_Y+CHR_HEIGHT))\n    {\n\t\tfloat vv  = ((fragCoord.y) - float(CHR_HEIGHT*XCR_MIN_Y-CHR_HEIGHT)) / float((XCR_MAX_Y - XCR_MIN_Y) * CHR_HEIGHT);\n\t\tvec4  mul = pow(vec4(.4, 0, 0, 1) * (     sin(vv * kPi * 2.)), vec4(1.0))\n\t              + pow(vec4(.6, 0, 0, 1) * (1. - sin(vv * kPi * 2.)), vec4(0.7))\n            \t  + pow(vec4(.6,.4,.2, 1) * (1. - sin(vv * kPi * 2.)), vec4(1.5));\n\n        vec2 fc   = fragCoord;\n\t\tfc.x*=.5;\n\t\tfc.y = float(SCR_HEIGHT + CHR_HEIGHT) \n\t\t     + ((fragCoord.y) - float(CHR_HEIGHT*XCR_MIN_Y+CHR_HEIGHT))*.5 \n             + (sin(tTime + tTime + tTime + tTime - fragCoord.x / float(SCR_WIDTH) * kPi * 1.5) * .25 - .25) * float((XCR_MAX_Y - XCR_MIN_Y - 1) * CHR_HEIGHT);\n\t\tif (fc.y >= float(SCR_HEIGHT+ CHR_HEIGHT) && fc.y <= float(SCR_HEIGHT + CHR_HEIGHT+ CHR_HEIGHT))\n        {        \n\t\t\tfc.y  = fc.y;\n\t\t\tcol   = texture(iChannel0, fc / iResolution.xy) * mul;\n        }\n    }\n\n    // Bottom Copper-like scanline.\n    wx.y += 8;\n\tif ((wx.x < SCR_WIDTH) && (wx.y == (SCR_HEIGHT - 1 - 8)))\n\t    col = vec4(pal(uv.x - tTime*.75, vec3(.5), vec3(5), vec3(1), vec3(.0,.33,.67)), 1);\n    \n    // Credits sprite.\n    wx.y-=SCR_HEIGHT - CHR_HEIGHT + 2;\n    wx.x-=SCR_WIDTH  - kCreditsSprite.length() / 4;\n    int limitMin     = wx.x;\n    \n\tif ((wx.y >= 0) && (wx.y < 5) && (wx.x >= 0) && (wx.x < kCreditsSprite.length()/5))\n    \tcol = vec4(kCreditsSprite[wx.y*kCreditsSprite.length()/5 + wx.x]);\n\n    if (wx.y < 0)\n    {// Mixes with the starfield.\n        col = mix(sfx, col, col.a);\n    }\n    fragColor = col;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Skid Row Lemmings Cracktro Remake by merry^Architect.\n// http://www.pouet.net/prod.php?which=4021 (Pöuet).\n// https://www.youtube.com/watch?v=2YJGHcCkYEw (Youtube).\n// Coded by merry ^ Architect in 2018.\n\n// This cracktro is my favourite of all times (the music by 4mat is probably the actual reason!!!).\n// With this little tribute I wanted to make a homage to all Amiga cracktros that introduced me into the demoscene. \n\n// Buffer B: Remaps the 320x256, 4:3 screen ratio source image to the destination viewport.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv  = fragCoord / iResolution.xy;\n    uv.x =(uv.x - ((float(SCR_HEIGHT) / float(SCR_WIDTH))- (iResolution.y / iResolution.x))*.5) * 4./3.;\n    uv.x = uv.x *   float(SCR_WIDTH ) / iResolution.x;\n    uv.y = 1. - uv.y;\n    uv.y = uv.y *   float(SCR_HEIGHT) / iResolution.y;\n    \n    if (uv.x >= 0.)\n    {\n        fragColor = floor(texture(iChannel0, uv)*16.)/16.;\n\t}\n    else\n    {\n        fragColor = vec4(0);\n    }\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Skid Row Lemmings Cracktro Remake by merry^Architect.\n// http://www.pouet.net/prod.php?which=4021 (Pöuet).\n// https://www.youtube.com/watch?v=2YJGHcCkYEw (Youtube).\n// Coded by merry ^ Architect in 2018.\n\n// This cracktro is my favourite of all times (the music by 4mat is probably the actual reason!!!).\n// With this little tribute I wanted to make a homage to all Amiga cracktros that introduced me into the demoscene. \n\n// Buffer C: Remaps the 320x256, 4:3 screen ratio source image to the destination viewport.\n// Same than Buffer B. Due to a Shadertoy limitation, it is not possible to use the same texture twice in a pass with\n// different sampler filtering. Due to this, Buffers B and C prepares the exact same output to be processed \n// as both mipmapped and nearest-neighbor samplers in Image.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv  = fragCoord / iResolution.xy;\n    uv.x =(uv.x - ((float(SCR_HEIGHT) / float(SCR_WIDTH))- (iResolution.y / iResolution.x))*.5) * 4./3.;\n    uv.x = uv.x *   float(SCR_WIDTH ) / iResolution.x;\n    uv.y = 1. - uv.y;\n    uv.y = uv.y *   float(SCR_HEIGHT) / iResolution.y;\n    \n    if (uv.x >= 0.)\n    {\n        fragColor = floor(texture(iChannel0, uv)*16.)/16.;\n\t}\n    else\n    {\n        fragColor = vec4(0);\n    }\n}\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "const float i_kEpsilon   =.005 ; // Epsilon value.\nconst float i_kFov       = 2.5 ; // FOV.\nconst int   i_kSteps     = 64 ; // Raymarching steps.\nconst int   i_kStepsSec  = 32 ; // Raymarching steps for secondary rays.\nconst int   i_kStepsTri  = 32 ; // Raymarching steps for tertiary rays.\nconst float i_kNear      = 0.01  ; // Distance to the near plane.\nconst float i_kFar       = 100.; // Distance to the far  plane.\nconst float i_kPi        = 3.1415927;\nconst int   i_kNumLights = 1   ; // Number of light sources.\nconst vec3  i_kAmbientColor = vec3(.166, .406, .664);\nconst float i_kAmbientLevel =.25  ;\n \nvec2  gTexelSize   ; // Pixel size   (screen domain).\nfloat gTexelRadius ; // Pixel radius (screen domain).\nfloat gDitherLambda; // Dithering lambda.\n\n// Skid Row Lemmings Cracktro Remake by merry^Architect.\n// http://www.pouet.net/prod.php?which=4021 (Pöuet).\n// https://www.youtube.com/watch?v=2YJGHcCkYEw (Youtube).\n// Coded by merry ^ Architect in 2018.\n\n// This cracktro is my favourite of all times (the music by 4mat is probably the actual reason!!!).\n// With this little tribute I wanted to make a homage to all Amiga cracktros that introduced me into the demoscene. \n\n// Image: composes the image. Uses Buffer B for mipmapping, Buffer C for pixel-perfect sampling. Composes the image\n// by mixing different mipmap levels onto the original image, then applies some post-processing.\n\n// Uncomment SHOW_ORIGINAL_RASTERPORT to watch the rasterport without any postprocessing.\n// #define SHOW_ORIGINAL_RASTERPORT\n\n// The CRT tube distortion is driven by this parameter.\n#define CRT_FACTOR 1.1\n\n// Taken from: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// Taken from: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImageSkidRow(out vec4 fragColor, in vec2 uv)\n{\n    vec4 col = vec4(0);\n    float v  = 1.;\n    \n    // Fakes a CRT surface.\n#\tifndef SHOW_ORIGINAL_RASTERPORT    \n    uv = uv * 2. - 1.;\n    v  = length(uv);\n    uv = normalize(uv) * pow(v, CRT_FACTOR);\n    uv = uv * .5 + .5;\n#   endif//SHOW_ORIGINAL_RASTERPORT    \n\n    // Fake brightness using mipmaps.\n#\tifndef SHOW_ORIGINAL_RASTERPORT    \n    col+= clamp(pow(textureLod(iChannel2, uv, 4.), vec4(.1)), 0., 1.) * .01;\n    col+= clamp(pow(textureLod(iChannel2, uv, 3.), vec4(.1)), 0., 1.) * .01;\n    col+= clamp(pow(textureLod(iChannel2, uv, 2.), vec4(.1)), 0., 1.) * .01;\n\tcol+= clamp(textureLod(iChannel2, uv, 1.), 0., 1.) * .16;\n#   endif//SHOW_ORIGINAL_RASTERPORT    \n\tcol+= texture(iChannel3, uv);\t\n\n    vec2 coord = uv * vec2(SCR_WIDTH, SCR_HEIGHT);\n    vec2 coord2= coord;\n#   ifndef SHOW_ORIGINAL_RASTERPORT\n    coord+= vec2(iTime * 25.);\n#   endif//SHOW_ORIGINAL_RASTERPORT\n\n\t// Subpixel pattern.\n#\tifndef SHOW_ORIGINAL_RASTERPORT    \n    col*= vec4(mix(1.2, 1. - mod(coord.x     + coord.y, 3.), .12),\n\t           mix(1.2, 1. - mod(coord.x + 1.+ coord.y, 3.), .12),\n    \t       mix(1.2, 1. - mod(coord.x + 2.+ coord.y, 3.), .12), 1.);\n#   endif//SHOW_ORIGINAL_RASTERPORT    \n\n    // Some HSV correction.\n#\tifndef SHOW_ORIGINAL_RASTERPORT    \n    col = vec4(hsv2rgb(rgb2hsv(col.xyz) * vec3(.95,.95,.75)), 1);\n#   endif//SHOW_ORIGINAL_RASTERPORT    \n\n    // Scanlines & vignetting.\n#\tifndef SHOW_ORIGINAL_RASTERPORT    \n\tcol*= vec4(mix(1.2, 1. - mod(coord.y, 2.), .12));\n    col*= max (.9, 1. - pow(v,5.));\n#   endif//SHOW_ORIGINAL_RASTERPORT    \n       \n    fragColor = col;\n}\n\n//  Gets an N-dimensional random number using given argument as seed for the calculation.\n//  @in     n       Random seed.\n//  @return Resulting value.\nfloat hashi(ivec2 n) { return float((0x3504f333 * n.x * n.x + n.y) * (0xf1bbcdcb * n.y * n.y + n.x)) * (2. / 8589934592.) +.5; }\nfloat hashf(float n) { return hashi(ivec2(n)); }\nvec3  hash3(vec2  p) { return fract(sin(vec3(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)), dot(p, vec2(419.2, 371.9)))) * 43758.5453); }\n\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\nfloat n4rand_ss( vec2 n )\n{\n\tfloat nrnd0 = nrand( n + 0.07*fract( 123.456 ) );\n\tfloat nrnd1 = nrand( n + 0.11*fract( 123.456 + 0.573953 ) );\t\n\treturn 0.23*sqrt(-log(nrnd0+0.00001))*cos(2.0*3.141592*nrnd1)+0.5;\n}\n\nfloat blugausnoise2(vec2 c1) {\n    float nrand1 = n4rand_ss(c1);\n    float nrand0 = n4rand_ss(vec2(c1.x- 1.,c1.y));\n    float nrand2 = n4rand_ss(vec2(c1.x+ 1.,c1.y));\n    return 2.0* nrand1- 0.5* (nrand0+ nrand2);\n}\n\nvec4 tex_triplanar(sampler2D texID, vec3 pos, vec3 nor, vec2 bias, float k)\n{\n    vec3 m = pow(abs(nor), vec3(k));\n    m   /= m.x + m.y + m.z;\n    // Triplanar first component shall be inferred from pos.yz. Changed to pos.zy to make it work with our textures.\n    return  (texture(texID, pos.zy + bias.yx) * m.x + texture(texID, pos.zx + bias.xx) * m.y + texture(texID, pos.xy + bias.xy) * m.z);\n}\n\n//  Gets material information for the given ID and world-space data.\n//  @in     matID   Material ID.\n//  @in     pos     World-space position.\n//  @in     nor     Normal  vector.\n//  @in     t       Tangent vector. DEPRECATED.\n//  @return The material descriptor for given input data.\n//  Materials are set up using a mat4 instance. Input and output material structure is as follows:\n//      [0] Albedo    (XYZ); emissive (W).\n//      [1] Roughness   (X); fresnel  (Y); metalness (Z); SSS (W).\n//      [2] Reflectance (X).\n//      [3] Normal    (XYZ). Output only.\n//  Albedo value present at input is used as texture albedo multiplier.\nmat4 getMaterialInfo(int matID, vec3 pos, vec3 nor /*, vec3 t */)\n{\n  \tmat4 mat = mat4(0);\n    if (0 == matID)\n    {\n    \tmat[0] = vec4(.15,.15,.15,0);\n        mat[1] = vec4(.05+.75*texture(iChannel1,pos.xz*.03).x,.3,.0,.0);\n        mat[2] = vec4(.0,.0,.0,.0);\n        mat[3] = vec4(nor,     .0);\n    }\n    else\n    if (1 == matID)\n    {\n    \tmat[0] = vec4(1,1,1,.0);\n        mat[1] = vec4(.5,.3,.0,.0);\n        mat[2] = vec4(.0,.0,.0,.0);\n        mat[3] = vec4(nor,     .0);\n    }\n    else\n    if (2 == matID)\n    {\n        vec2 uv = pos.xy*vec2(.1,.2)+vec2(.5,.12);\n\t\tmainImageSkidRow(mat[0], uv.xy);\n        mat[0] = clamp(mat[0]*8., 0.03, 8.);\n        mat[0].w = 1.;\n        mat[1] = vec4(.1,.5,.0,.0);\n        mat[2] = vec4(.0,.0,.0,.0);\n        mat[3] = vec4(nor,     .0);\n    }\n    else\n    if (3 == matID)\n    {\n    \tmat[0] = vec4(8,8,8,.1);\n        mat[1] = vec4(.1,.3,.0,.0);\n        mat[2] = vec4(.0,.0,.0,.0);\n        mat[3] = vec4(nor,     .0);\n    }\n    else\n    if (8 == matID)\n    {\n    \tmat[0] = vec4(.1);\n        mat[1] = vec4(.5+.25*texture(iChannel1,pos.xy*.03).x,.3,.0,.0);\n        mat[2] = vec4(.0,.0,.0,.0);\n        mat[3] = vec4(nor,     .0);\n    }\n    return\tmat;\n}\n\n//  Gets light information for the given ID and world-space data.\n//  @in     litID   Light ID.\n//  @in     pos     World-space position.\n//  @return The light material for the given input data.\n//  Lights are set up using a mat4 instance. Output light structure is as follows:\n//      [0] Light position or direction  (XYZ); light type (W), either spot (0) or directional (1).\n//      [1] Light color (XYZ), attenuation (W).\n//      [2] -\n//      [3] (auto) Light direction (XYZ).\nmat4 getLightInfo(int litID, vec3 pos)\n{\n\tmat4 lit = mat4(0);\n    if (0 == litID)\n    {\n\t\tlit[0] = vec4(3,5, 3,0);\n        lit[1] = vec4(0);\n    }\n    lit[3].xyz = mix(normalize(lit[0].xyz - pos), lit[0].xyz, lit[0].w);\n\n\treturn  lit;\n}\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nfloat sdSphere(vec3 p, float s) { return length(p) - s; }\nfloat sdBox   (vec3 p, vec3  b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\nfloat sdChair(vec3 p)\n{\n    float a = sdBox(p,vec3( .25,.01, .25));\n    a = min(a,sdBox(p+vec3(0, -.37, -.25),vec3(.25,.15,.02)));\n    a = min(a,sdBox(p+vec3( .25,.00,-.25),vec3(.01,.50,.01)));\n    a = min(a,sdBox(p+vec3(-.25,.00,-.25),vec3(.01,.50,.01)));\n    a = min(a,sdBox(p+vec3(-.25,.42, .25),vec3(.01,.42,.01)));\n    a = min(a,sdBox(p+vec3( .25,.42, .25),vec3(.01,.42,.01)));\n    return a;\n}\n\n#define MIN(dst, src)   dst = mix(src, dst, step(dst.x, src.x))\nvec2 mapScene(vec3 pos)\n{\n    vec2 a = vec2(i_kFar), b = vec2(i_kFar);\n\n    float q = floor(mod(iTime*.20, 4.));\n    \n    b = vec2(max(-sdBox(pos-vec3(0,4,0), vec3(5)), sdBox(pos, vec3(100))), 8); MIN(a, b);\n    b = vec2(sdBox(pos+vec3(0,.99,0), vec3(100,.01,100)), 0); MIN(a, b);\n    b = vec2(sdBox(pos+vec3(0,0,4.99), vec3(5,5,.01)), 2); MIN(a, b);\n    \n    pos.y+= .5;\n    vec2 c = pMod2(pos.xz, vec2(1, 3));\n    pR(pos.xz, hashi(ivec2(c))*.25);\n    b = vec2(sdChair(pos), 0); MIN(a, b);\n    \n    return\ta;\n}\n    \n//  Gets a rotation matrix within given direction.\n//  @in     dir     Normalized direction in scene center, ground domain (up = [0,1,0]).\n//  @in     upvec   Bias to apply to the up vector to avoid gimbal lock.\n//  @return The resulting rotation matrix.\nmat3 rotationMatrix(vec3 dir, vec3 upvec)\n{\n    vec3 cu = normalize(cross(dir , upvec));\n    return  mat3(cu, normalize(cross(cu, dir)), dir);\n}\n\n//  Calculates the ray direction to draw pixel at the given viewport UV coordinates from the given world-space position.\n//  @in     ro      World-space position within the ray starts from.\n//  @in     rd      World-space position within the ray ends.\n//  @in     uv      Viewport UV coordinates.\n//  @return The resulting ray direction.\nvec3 getCameraDir(vec3 ro, vec3 rd, vec2 uv)\n{\n    return rotationMatrix(normalize(rd - ro), vec3(i_kEpsilon, 1., i_kEpsilon)) \n        * normalize(vec3 (uv * vec2(iResolution.x / iResolution.y, 1.), i_kFov));\n}\n\n//  Gets square of \"x\".\n//  @in     x       Value to get square of.       \n//  @return Square of \"x\".\nfloat sq(float x) { return x * x; }\n\n//  Gets normal vector within a given hit.\n//  @in     pos     World position where hit was found.\n//  @return Normal vector within the hit.\n#define ZERO min(iFrame,0)\nvec3  computeNormal(const vec3 pos)\n{\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*mapScene(pos+0.0005*e).x;\n    }\n    return normalize(n);\n}\n\nfloat ao(vec3 ro, vec3 rd, float kk)\n{\n    float k = 1.0;\n    float d = 0.0;\n    float occ = 0.0;\n    for(int i = 0; i < 32; i++){\n        d = mapScene(ro + 0.1 * k * rd).x;\n        occ += 1.0 / pow(2.0, k) * (k * 0.1 - d);\n        k += 1.0;\n    }\n    return 1.0 - clamp(kk * occ, 0.0, 1.0);\n}\n\n//  Casts a ray along the given direction until a hit is found. Returns a vec4() with distance (X), material ID (Y). \n//  Uses \"over-relaxation raymarching\" and \"screen-space aware intersection point selection\" algorithms depicted at\n//  the  \"Enhanced Sphere Tracing\" paper by Benjamin Kelinert et al.\n//  @in     ro      Ray origin.\n//  @in     rd      Ray direction.\n//  @in     steps   Maximum ray iterations.\n//  @return Raycast result. A vec4() with total distance (X), last step distance (Y), material ID (Z), steps (W).\nvec4 castRay(vec3 ro, vec3 rd, int steps)\n{\n    float t   = i_kNear, stepLength = 0., prevRad = i_kFar, prevErr = i_kFar, err, k = 1.2;\n    vec2  res = vec2(1);\n    for (; (steps >= 0) && (t < i_kFar); --steps)\n    {\n        res = mapScene(ro + rd * t);\n        bool  sor = (k > 1.) && ((prevRad + res.x) < stepLength);\n        if (sor)\n        {\n            stepLength-= k * stepLength;\n            k = 1.;            \n        }        \n        else\n            stepLength = res.x * k;\n\n        prevRad = res.x;\n        err = res.x / t;\n        if (!sor)\n        {\n            if (err < prevErr     ) { res.x = t; prevErr = err; }\n            if (err < gTexelRadius) break;\n        }\n        t  += stepLength;\n    }\n    return vec4(t, res.xy, steps);\n}\n\n//  Lits given point.\n//  @in     pos     Surface position to lit.\n//  @in     nor     Normal  vector to the surface position to lit.\n//  @in     rd      Ray direction.\n//  @in     mat     The material descriptor to use.\n//  @return Surface color at that point.\nvec4 shadeFragment(vec3 pos, vec3 nor, vec3 rd, mat4 mat)\n{\n    vec3  col    = vec3(1), diffuse;\n    vec4  amb    = vec4(0), res;\n    float weight = 0.;\n\n    mat4 lit = getLightInfo(0, pos);\n    diffuse  = mix(mat[0].xyz * clamp(dot(mat[3].xyz, lit[3].xyz), 0., 1.) * (1. - mat[1].z), mat[0].xyz, mat[0].w);\n\n    //  Calculates the Cook-Torrance BRDF terms for a particular point in the 3D space within the given material setup  \n    //  and  light direction.\n    //  BRDF function terms used are:\n    //          * D term (isotropic  ) - GGX.\n    //          * F term (reflectance) - Schlick.\n    //          * G term (geometric  ) - Schlick approximation of Smith solved with GGX.\n \tvec3  h         = normalize   (-rd + lit[3].xyz);\n   \tfloat rsq       = max  (.001, sq(mat[1].x));\n    vec3  terms     = vec3\n    (\n        /* D Term    */ (rsq * rsq / (i_kPi * sq((sq(rsq) - 1.) * sq(clamp(dot(mat[3].xyz, h), 0., 1.)) + 1. ))),   // Isotropic GGX NDF. \n        /* F Term    */ (mat[1].y + (1. - mat[1].y  ) * (pow(1. -    clamp(dot(mat[3].xyz, lit[3].xyz), 0., 1.),  5.))),\n        /* G Term    */ sq(1. / (dot(h , lit[3].xyz) * (1. - rsq * .5) + rsq * .5))\n    );\n\tcol = diffuse * col * terms.y + mix(lit[1].xyz, vec3(1), mat[0].w) * diffuse;\n                                       \n    //  Integrates result with ambient light.\n    col    += mat[0].xyz * i_kAmbientColor * i_kAmbientLevel;\n    return  vec4(col, terms.y);\n}\n\n//  Gets a rotation matrix within given direction.\n//  @in     dir     Normalized direction in scene center, ground domain (up = [0,1,0]).\n//  @in     upvec   The up-vector.\n//  @return The resulting rotation matrix.\nmat3 rotation_matrix(vec3 dir, vec3 upvec)\n{\n    vec3 cu = normalize(cross(dir , upvec));\n    return  mat3(cu, normalize(cross(cu, dir)), dir);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tgTexelSize    = 1. / iResolution.xy;\n\tgTexelRadius  = length(gTexelSize) ;\n \tgDitherLambda = -.25 + .5 * fract(52.9829189  * fract(dot(fragCoord.xy, vec2(.06711056,.00583715))));\n    \n    vec2 uv = (fragCoord.xy + hash3(vec2(iTime*15.,iTime*.23)).x) / iResolution.xy;\n    vec2 qv = uv * 2. - 1.;\n\tvec3 pos, nor;\n    vec4 res;\n    float depth;\n\n\t// Camera setup.\n    float t = .25 * (iTime * 5. + (sin(iTime*.33)*4.+4.)), t2 = mod(iTime * .1, 4.);\n    int  scn = int(floor(mod(t2, 4.)));\n    float t3 = t2 - float(scn);\n    vec3 ro = vec3(sin(t2 * .2) * .2,1,4.8);\n    vec3 rd = getCameraDir(ro, vec3(sin(t2 * .2) * .1,1,0), qv);\n    \n    // Casts ray.\n    res = castRay(ro, rd, i_kSteps);\n    pos = ro + rd * res.x;\n    \n    // Reduces neighbors discontinuity by reprojecting hitpoint sample to be represented by a pixel on the screen.\n    float coneSize  = tan(i_kPi / 6.) / (iResolution.y);\n    float error     = 0.;\n    for (int  i = 0; i < 3; ++i)\n    {\n        pos    -= rd *    (error - mapScene(pos).x);\n        error   = coneSize * length(ro  - pos);\n    }\n    int srcMat  = int(res.z);\n    nor         = computeNormal(pos);\n    depth       = clamp (((i_kFar + i_kNear) / (i_kFar - i_kNear)) + (2. * i_kFar * i_kNear / (i_kFar - i_kNear)) /-abs(res.x), 0., 1.);\n\tmat4 mat    = getMaterialInfo(srcMat, pos, nor);\n    fragColor   = shadeFragment(pos, nor, rd, mat);\n    \n    float pdf;\n    mat3 mm;\n    vec2 hm;\n    pdf = fragColor.a;\n    vec4 dif =(1.-mat[1].z)*vec4(mat[0].xyz, 1);\n    vec4 dif2=vec4(mat[0].xyz,1);\n\n\tvec3 p2 = pos, n2 = nor, r2 = ro, d2 = rd;    \n\tfloat aa = mat[1].x * mat[1].x, metallic = mat[1].z;\n\tvec4 col = vec4(0);\n\tmat4 m2 = mat;\n\n    float att = 1.,att2=.5;\n    for (int i = 0; srcMat != 2 && i < 1; ++i)\n    {\n\t    ro = pos + nor * .01;\n\t    rd = nor;\n\t    if (mat[2].y > 0.)\n\t    {\t\n        ro = pos - nor * .01;\n\t        rd = refract(-rd, nor, mat[2].y);\n\t    }\n\t\trd+= abs(hash3(vec2(float(iTime*.01) / 512., hash3(uv + iTime*.01))))*1.-.5;\n\t    rd = normalize(rd);\n\t    res = castRay(ro, rd, i_kStepsSec);\n\t    pos = ro + rd * res.x;\n\t    nor         = computeNormal(pos);\n\t    depth       = clamp (((i_kFar + i_kNear) / (i_kFar - i_kNear)) + (2. * i_kFar * i_kNear / (i_kFar - i_kNear)) /-abs(res.x), 0., 1.);\n\t\tmat         = getMaterialInfo(int(res.z), pos, nor);\n\t\tcol+= att*dif*mix(mat[0].xyz * clamp(dot(mat[3].xyz, d2), 0., 1.) * (1. - mat[1].z), mat[0].xyz, mat[0].w).xyzz*((3.-float(i))/3.);\n\t\tatt*=att2;\n    }\n    fragColor = mix(fragColor, col, .5);    \n    \n\tpos=p2;nor=n2;ro=r2;rd=d2;\n\tcol = vec4(0);\n    att=1.;\n    \n    for (int i = 0; srcMat != 2 && i < 2; ++i)\n    {\n\t    ro = pos + nor * .001;\n\t    rd = reflect(rd, nor);\n\t\trd*= mix(vec3(1),abs(hash3(vec2(float(iTime*.01) / 512., hash3(uv + iTime*.01)))),aa)*1.-.5;\n\t    rd = normalize(rd);\n\t    res = castRay(ro, rd, i_kStepsTri);\n\t    pos = ro + rd * res.x;\n\t    nor         = computeNormal(pos);\n\t    depth       = clamp (((i_kFar + i_kNear) / (i_kFar - i_kNear)) + (2. * i_kFar * i_kNear / (i_kFar - i_kNear)) /-abs(res.x), 0., 1.);\n\t\tmat         = getMaterialInfo(int(res.z), pos, nor);\n\t    vec4 sf = shadeFragment(pos, nor, rd, mat);\n\t    col+= att*mix(col, (mix(vec4(1),dif2,metallic))*sf*pdf,.5)*((3.-float(i))/3.);\n\t    pdf = sf.a;\n\t\taa = mat[1].x * mat[1].x;\n\t\tatt*=att2;\n    }\n    float m=((2==srcMat)?.7:.05);\n    fragColor = mix(fragColor, col, .5)*m+texture(iChannel0,fragCoord.xy/iResolution.xy)*(1.-m);    \n}\n", "buffer_d_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXSDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 26, 78, 78, 1977]], "test": "untested"}
{"id": "4tsBD7", "name": "Disk - intersection", "author": "iq", "description": "ray-disk intersection", "tags": ["3d", "raytracing", "raycast", "intersection", "raytrace", "disk"], "likes": 24, "viewed": 1872, "published": 3, "date": "1626387735", "time_retrieved": "2024-07-30T19:10:47.373882", "image_code": "// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Ray-disk intersection. For general planar shapes, please see the\n// \"coord system intersector\" at https://www.shadertoy.com/view/lsfGDB\n//\n//\n// List of other ray-surface intersectors:\n//    https://www.shadertoy.com/playlist/l3dXRf\n// and \n//    https://iquilezles.org/articles/intersectors\n\n\n// disk: center c, normal n, radius r\nfloat diskIntersect( in vec3 ro, in vec3 rd, vec3 c, vec3 n, float r )\n{\n\tvec3  o = ro - c;\n    float t = -dot(n,o)/dot(rd,n);\n    vec3  q = o + rd*t;\n    return (dot(q,q)<r*r) ? t : -1.0;\n}\n\n// disk: center c, normal n, radius r\nfloat diskIntersectWithBackFaceCulling( in vec3 ro, in vec3 rd, vec3 c, vec3 n, float r )\n{\n    float d = dot(rd,n);\n    if( d>0.0 ) return -1.0;\n\tvec3  o = ro - c;\n    float t = -dot(n,o)/d;\n    vec3  q = o + rd*t;\n    return (dot(q,q)<r*r) ? t : -1.0;\n}\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n        // camera\n        vec3 ro = 1.5*vec3(cos(0.15*iTime),0.0,sin(0.15*iTime));\n        vec3 ta = vec3(0.0,0.0,0.0);\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.0*ww );\n\n        // render background\n        vec3 col = vec3(0.08)*(1.0-0.3*length(p)) + 0.02*rd.y;\n\n        // render disks (raycast them)\n        const int num = 64;  // number of disks\n\n        float tmin = 1e20;\n        vec3  onor = vec3(0.0);\n        for( int i=0; i<num; i++ )\n        {\n            // fibonacci points on a sphere\n            const float kInvPhi = (sqrt(5.0)-1.0)/2.0; // one over golden ratio\n            float cb = 1.0-2.0*(float(i)+0.5)/float(num);\n            float sb = sqrt(1.0-cb*cb);\n            float aa = 6.283185*kInvPhi*float(i);\n            vec3  cen = vec3( sb*sin(aa), sb*cos(aa), cb );\n\n            // orient disk tangent to sphere surface\n            vec3  nor = normalize(cen);\n\n            // for full coverage, each disk's area should be 4PI/num,\n            // ie, their radius should be 2/sqrt(num)\n            float rad = (2.0/sqrt(float(num))); \n            // but we only want partial coverage, for aesthetic reasons\n            rad *= 0.5;\n\n            // test for intersection with disk\n            float t = diskIntersect( ro, rd, cen, nor, rad );\n\n            // trak intersections\n            if( t>0.0 && t<tmin ) \n            {\n                tmin = t;\n                onor = nor;\n            }\n        }\n\n        // shade disk, if one found\n        if( tmin<1000.0 )\n        {\n            float dif = clamp( dot(onor,vec3(0.8,0.6,0.4)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*onor.y;\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.75,0.6)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n        \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // dither to remove banding in the background\n    tot += fract(sin(fragCoord.x*vec3(13,1,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tsBD7.jpg", "access": "api", "license": "mit", "functions": [[1375, 1413, 1485, 1485, 1603], [1605, 1643, 1734, 1734, 1898]], "test": "ok"}
{"id": "fllXRl", "name": "Hard and Soft HSL (fork)", "author": "glaucocfg", "description": "Nice and branchless. Fork.", "tags": ["color", "rgb", "hsl", "cmy"], "likes": 2, "viewed": 285, "published": 3, "date": "1626317774", "time_retrieved": "2024-07-30T19:10:48.128863", "image_code": "#define rep(m, x) (mod(x, 2.0*(m)) - (m))\n#define sdf(w, d) smoothstep(1.5*(w), 0.0, d)\n#define plot(w, x, y) sdf(w, abs((x) - (y)))\n#define range(x, a, b) ((a) <= (x) && (x) < (b))\n\nvec3 hard(vec3 hsl) {\n    const vec3 offset = vec3(0.0, 2.0, 1.0)/3.0;\n    float limit = 0.5 - abs(0.5 - hsl.z);\n    vec3 rgb = 15.0*abs(fract(offset + hsl.x) - 0.5) - 6.0;\n    return hsl.z + hsl.y*limit*clamp(rgb, -1.0, 1.0);\n}\n\nvec3 soft(vec3 hsl) {\n    const float tau = radians(360.0);\n    const vec3 offset = vec3(0.0, 1.0, 2.0)/3.0;\n    float limit = (1.0 - hsl.z)*hsl.z;\n\treturn hsl.z + hsl.y*limit*cos(tau*(offset - hsl.x));\n}\n\nvoid mainImage(out vec4 rgba, vec2 xy) {\n    float dashed = sdf(1.0, abs(rep(6.0, xy.x)) - 4.0);\n    float dotted = sdf(1.0, abs(rep(2.0, xy.x)));\n    \n    vec2 px = 1.0/iResolution.xy;\n    vec2 uv = xy*px;\n\n    vec3 a = hard(vec3(0.1*iTime + uv.x, 1.0, 0.5));\n    vec3 b = soft(vec3(0.1*iTime + uv.x, 2.0, 0.5));\n    \n    vec3 plots =\n        plot(px.y, uv.y, 0.7)*0.1 +\n        plot(px.y, uv.y, 0.7 + 0.4*(a - b)) +\n        plot(px.y, uv.y, 0.1 + 0.4*a)*dashed +\n        plot(px.y, uv.y, 0.1 + 0.4*b)*dotted;\n\n    vec3 rgb =\n        range(uv.y, px.y + 0.950, 1.000) ? a :\n    \trange(uv.y, px.y + 0.000, 0.025) ? b :\n    \tplots;\n\n    rgba = vec4(srgb(rgb), 0.0);\n}", "image_inputs": [], "common_code": "vec3 srgb(vec3 c) {\n    vec3 a = 1.0*pow(c, vec3(1.0/2.4)) - 0.0;\n    vec3 b = 12.92*c;\n    return mix(a, b, lessThanEqual(c, vec3(0.0031308)));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fllXRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[183, 183, 204, 204, 411], [413, 413, 434, 434, 617], [619, 619, 659, 659, 1284]], "test": "untested"}
{"id": "stfXRs", "name": "Toccata and Fugue in Brute Force", "author": "pyBlob", "description": "Simplified, de-optimized and no external sources.", "tags": ["sound", "bach"], "likes": 3, "viewed": 292, "published": 3, "date": "1626305239", "time_retrieved": "2024-07-30T19:10:49.783440", "image_code": "/*\nCommon: Change disk (0..2) after 180s\n\nIf audio is not in sync: restart (alt+down) while shader is playing\n*/\n\nvoid mainImage(out vec4 C, in vec2 O)\n{\n    vec2 f = vec2(\n        10., // seconds\n        12. * 10. // half-tones\n    ) / iResolution.xy;\n    float t = min(iTime, t_disk) + t_offset;\n    vec2 d = vec2(\n        t - 1.,\n        0\n    );\n    \n    C = vec4(0);\n    if (abs(O * f - 1.).x < .6 * f.x)\n        C = vec4(1);\n\n    vec2 o = O * f + d;\n    for (int i=min(0,iFrame) ; i<n_notes ; ++i)\n    {\n        vec4 note = notes(i);\n        if (note.w == -1.)\n            continue;\n        if (note.x < o.x && o.x < note.x + note.z && int(o.y) == int(note.y))\n        {\n            if (note.x + note.z < t)\n                C = vec4(0,0,1,1);\n            else if (note.x < t)\n                C = vec4(0,1,0,1);\n            else\n                C = vec4(1,0,0,1);\n        }\n    }\n\n    if (iTime > t_disk)\n    {\n        C = mix(C, vec4(.5,.5,.5,1), .5);\n        f = vec2(1. / iResolution.y);\n        vec2 uv = (O - iResolution.xy / 2.) * f;\n        uv = abs(uv);\n        uv.x = abs(uv.x - .2);\n        C = mix(C, vec4(1), float(uv.x < 0.1 && uv.y < .3));\n    }\n}\n", "image_inputs": [], "common_code": "const int disk = 0;\n\nconst float pi = radians(180.);\n\nconst int n_notes = 3809;\nconst float t_disk = 180.;\nconst float t_offset = t_disk * float(disk) + 0.;\nconst float t_length = 510.;\n\nvec4 notes(int n)\n{\n    const vec4 v_0[1024] = vec4[](vec4(0,4,4,-1), vec4(0.1875,79,0.1875,1), vec4(0.1875,67,0.1875,1), vec4(0.375,69,2.20588125,1), vec4(0.375,81,2.20588125,1), vec4(0.375,69,2.20588125,1), vec4(3.0220575,79,0.1875,1), vec4(3.0220575,67,0.1875,1), vec4(3.2095575,77,0.1875,1), vec4(3.2095575,65,0.1875,1), vec4(3.3970575,76,0.1875,1), vec4(3.3970575,64,0.1875,1), vec4(3.5845575,74,0.1875,1), vec4(3.5845575,62,0.1875,1), vec4(3.7720575,73,0.36328125,1), vec4(3.7720575,61,0.36328125,1), vec4(4.1470575,74,0.71484375,1), vec4(4.1470575,62,0.71484375,1), vec4(7.862966,69,0.17045449999999995,1), vec4(7.862966,57,0.17045449999999995,3), vec4(8.0334205,67,0.17045449999999995,1), vec4(8.0334205,55,0.17045449999999995,3), vec4(8.203875,69,1.985293125,1), vec4(8.203875,57,1.985293125,3), vec4(10.630344375,64,0.36328125,1), vec4(10.630344375,52,0.36328125,3), vec4(11.005344375,65,0.36328125,1), vec4(11.005344375,53,0.36328125,3), vec4(11.380344375,61,0.36328125,1), vec4(11.380344375,49,0.36328125,3), vec4(11.755344375,62,0.71484375,1), vec4(11.755344375,50,0.71484375,3), vec4(14.891707375,36,32,-1), vec4(15.062161875,55,0.2205881250000008,1), vec4(15.062161875,43,0.2205881250000008,3), vec4(15.28275,57,2.205881250000001,1), vec4(15.28275,57,2.205881250000001,1), vec4(15.28275,45,2.205881250000001,3), vec4(15.28275,45,2.205881250000001,3), vec4(17.929807500000003,55,0.1875,3), vec4(17.929807500000003,43,0.1875,3), vec4(18.117307500000003,53,0.1875,3), vec4(18.117307500000003,41,0.1875,3), vec4(18.304807500000003,52,0.1875,3), vec4(18.304807500000003,40,0.1875,3), vec4(18.492307500000003,50,0.1875,3), vec4(18.492307500000003,38,0.1875,3), vec4(18.679807500000003,49,0.36328125,3), vec4(18.679807500000003,37,0.36328125,3), vec4(19.054807500000003,50,0.71484375,3), vec4(19.054807500000003,38,0.71484375,3), vec4(28.105942499999998,4,4,-1), vec4(24.7607729375,49,4.985794124999998,3), vec4(25.080375125,52,4.985794124999998,3), vec4(25.7195795,58,4.985794124999998,3), vec4(26.039181687499998,61,5.215907812499999,1), vec4(25.3999773125,55,6.159799687499998,3), vec4(26.358783874999997,64,5.435368125,1), vec4(32.3332145,52,0.953125,3), vec4(22.992307500000003,26,11.950281999999994,2), vec4(30.833214499999997,62,4.3125,1), vec4(30.833214499999997,50,4.3125,3), vec4(30.833214499999997,57,4.3125,3), vec4(33.3332145,54,1.90625,3), vec4(36.58321325,61,0.17435182031250207,1), vec4(36.58321325,49,0.17435182031250207,3), vec4(36.76613975,62,0.11432906249999775,1), vec4(36.76613975,50,0.11432906249999775,3), vec4(36.886185265624995,64,0.11718728906249964,1), vec4(36.886185265624995,52,0.11718728906249964,3), vec4(37.00908900781249,61,0.11718728906249964,1), vec4(37.00908900781249,49,0.11718728906249964,3), vec4(37.13199274999999,62,0.11432906249999775,1), vec4(37.13199274999999,50,0.11432906249999775,3), vec4(37.25203826562498,64,0.11718728906249964,1), vec4(37.25203826562498,52,0.11718728906249964,3), vec4(37.37494200781248,61,0.11718728906249964,1), vec4(37.37494200781248,49,0.11718728906249964,3), vec4(37.497845749999975,62,0.11432906249999775,1), vec4(37.497845749999975,50,0.11432906249999775,3), vec4(37.61789126562497,64,0.11718728906249964,1), vec4(37.61789126562497,52,0.11718728906249964,3), vec4(37.740795007812466,61,0.11718728906249964,1), vec4(37.740795007812466,49,0.11718728906249964,3), vec4(37.86369874999996,62,0.1702007226562472,1), vec4(37.86369874999996,50,0.1702007226562472,3), vec4(38.04226999999996,64,0.1702007226562472,1), vec4(38.04226999999996,52,0.1702007226562472,3), vec4(38.22084124999996,65,0.11160703125000282,1), vec4(38.22084124999996,53,0.11160703125000282,3), vec4(38.33802863281246,67,0.11439720703125289,1), vec4(38.33802863281246,55,0.11439720703125289,3), vec4(38.45800619140621,64,0.11439720703125289,1), vec4(38.45800619140621,52,0.11439720703125289,3), vec4(38.577983749999966,65,0.11160703125000282,1), vec4(38.577983749999966,53,0.11160703125000282,3), vec4(38.69517113281247,67,0.11439720703125289,1), vec4(38.69517113281247,55,0.11439720703125289,3), vec4(38.81514869140622,64,0.11439720703125289,1), vec4(38.81514869140622,52,0.11439720703125289,3), vec4(38.935126249999975,65,0.11160703125000282,1), vec4(38.935126249999975,53,0.11160703125000282,3), vec4(39.05231363281248,67,0.11439720703125289,1), vec4(39.05231363281248,55,0.11439720703125289,3), vec4(39.17229119140623,64,0.11439720703125289,1), vec4(39.17229119140623,52,0.11439720703125289,3), vec4(39.292268749999984,65,0.1702007226562472,1), vec4(39.292268749999984,53,0.1702007226562472,3), vec4(39.47083999999998,67,0.1702007226562472,1), vec4(39.47083999999998,55,0.1702007226562472,3), vec4(39.64941124999998,33,32,-1), vec4(39.64941124999998,69,0.10901140624999783,1), vec4(39.64941124999998,57,0.10901140624999783,3), vec4(39.763873226562474,70,0.11173669140625009,1), vec4(39.763873226562474,58,0.11173669140625009,3), vec4(39.88106048828122,67,0.11173669140625009,1), vec4(39.88106048828122,55,0.11173669140625009,3), vec4(39.99824774999997,69,0.10901140624999783,1), vec4(39.99824774999997,57,0.10901140624999783,3), vec4(40.112709726562464,70,0.11173669140625009,1), vec4(40.112709726562464,58,0.11173669140625009,3), vec4(40.22989698828121,67,0.11173669140625009,1), vec4(40.22989698828121,55,0.11173669140625009,3), vec4(40.34708424999996,69,0.10901140624999783,1), vec4(40.34708424999996,57,0.10901140624999783,3), vec4(40.461546226562454,70,0.11173669140625009,1), vec4(40.461546226562454,58,0.11173669140625009,3), vec4(40.5787334882812,67,0.11173669140625009,1), vec4(40.5787334882812,55,0.11173669140625009,3), vec4(40.69592074999995,69,0.16624239453125256,1), vec4(40.69592074999995,57,0.16624239453125256,3), vec4(42.35289412499995,73,0.17435182031250207,1), vec4(42.35289412499995,61,0.17435182031250207,3), vec4(42.53582062499995,4,4,-1), vec4(42.53582062499995,74,0.11432906249999775,1), vec4(42.53582062499995,62,0.11432906249999775,3), vec4(42.655866140624944,76,0.11718728906249964,1), vec4(42.655866140624944,64,0.11718728906249964,3), vec4(42.77876988281244,73,0.11718728906249964,1), vec4(42.77876988281244,61,0.11718728906249964,3), vec4(42.90167362499994,74,0.11432906249999775,1), vec4(42.90167362499994,62,0.11432906249999775,3), vec4(43.02171914062493,76,0.11718728906249964,1), vec4(43.02171914062493,64,0.11718728906249964,3), vec4(43.14462288281243,73,0.11718728906249964,1), vec4(43.14462288281243,61,0.11718728906249964,3), vec4(43.267526624999924,74,0.11432906249999775,1), vec4(43.267526624999924,62,0.11432906249999775,3), vec4(43.38757214062492,76,0.11718728906249964,1), vec4(43.38757214062492,64,0.11718728906249964,3), vec4(43.510475882812415,73,0.11718728906249964,1), vec4(43.510475882812415,61,0.11718728906249964,3), vec4(43.63337962499991,74,0.1702007226562472,1), vec4(43.63337962499991,62,0.1702007226562472,3), vec4(43.81195087499991,76,0.1702007226562472,1), vec4(43.81195087499991,64,0.1702007226562472,3), vec4(43.990522124999906,77,0.11160703125000282,1), vec4(43.990522124999906,65,0.11160703125000282,3), vec4(44.10770950781241,79,0.11439720703125289,1), vec4(44.10770950781241,67,0.11439720703125289,3), vec4(44.22768706640616,76,0.11439720703125289,1), vec4(44.22768706640616,64,0.11439720703125289,3), vec4(44.347664624999915,77,0.11160703125000282,1), vec4(44.347664624999915,65,0.11160703125000282,3), vec4(44.46485200781242,79,0.11439720703125289,1), vec4(44.46485200781242,67,0.11439720703125289,3), vec4(44.58482956640617,76,0.11439720703125289,1), vec4(44.58482956640617,64,0.11439720703125289,3), vec4(44.704807124999924,77,0.11160703125000282,1), vec4(44.704807124999924,65,0.11160703125000282,3), vec4(44.82199450781243,79,0.11439720703125289,1), vec4(44.82199450781243,67,0.11439720703125289,3), vec4(44.94197206640618,76,0.11439720703125289,1), vec4(44.94197206640618,64,0.11439720703125289,3), vec4(45.06194962499993,77,0.16624239453125256,1), vec4(45.06194962499993,65,0.16624239453125256,3), vec4(45.236367874999935,79,0.16624239453125256,1), vec4(45.236367874999935,67,0.16624239453125256,3), vec4(45.41078612499994,33,32,-1), vec4(45.41078612499994,81,0.10901140624999783,1), vec4(45.41078612499994,69,0.10901140624999783,3), vec4(45.52524810156243,82,0.11173669140625009,1), vec4(45.52524810156243,70,0.11173669140625009,3), vec4(45.64243536328118,79,0.11173669140625009,1), vec4(45.64243536328118,67,0.11173669140625009,3), vec4(45.75962262499993,81,0.10901140624999783,1), vec4(45.75962262499993,69,0.10901140624999783,3), vec4(45.87408460156242,82,0.11173669140625009,1), vec4(45.87408460156242,70,0.11173669140625009,3), vec4(45.99127186328117,79,0.11173669140625009,1), vec4(45.99127186328117,67,0.11173669140625009,3), vec4(46.10845912499992,81,0.10901140624999783,1), vec4(46.10845912499992,69,0.10901140624999783,3), vec4(46.22292110156241,82,0.11173669140625009,1), vec4(46.22292110156241,70,0.11173669140625009,3), vec4(46.34010836328116,79,0.11173669140625009,1), vec4(46.34010836328116,67,0.11173669140625009,3), vec4(46.45729562499991,81,0.16624239453125256,1), vec4(46.45729562499991,69,0.16624239453125256,3), vec4(48.11426899999991,81,0.1702007226562472,1), vec4(48.11426899999991,69,0.1702007226562472,3), vec4(48.292840249999905,4,4,-1), vec4(48.292840249999905,79,0.11160703125000282,1), vec4(48.292840249999905,67,0.11160703125000282,3), vec4(48.41002763281241,82,0.11439720703125289,1), vec4(48.41002763281241,70,0.11439720703125289,3), vec4(48.53000519140616,76,0.11439720703125289,1), vec4(48.53000519140616,64,0.11439720703125289,3), vec4(48.649982749999914,79,0.11160703125000282,1), vec4(48.649982749999914,67,0.11160703125000282,3), vec4(48.76717013281242,82,0.11439720703125289,1), vec4(48.76717013281242,70,0.11439720703125289,3), vec4(48.88714769140617,76,0.11439720703125289,1), vec4(48.88714769140617,64,0.11439720703125289,3), vec4(49.00712524999992,77,0.11160703125000282,1), vec4(49.00712524999992,65,0.11160703125000282,3), vec4(49.124312632812426,81,0.11439720703125289,1), vec4(49.124312632812426,69,0.11439720703125289,3), vec4(49.24429019140618,74,0.11439720703125289,1), vec4(49.24429019140618,62,0.11439720703125289,3), vec4(49.36426774999993,77,0.11160703125000282,1), vec4(49.36426774999993,65,0.11160703125000282,3), vec4(49.481455132812435,81,0.11439720703125289,1), vec4(49.481455132812435,69,0.11439720703125289,3), vec4(49.60143269140619,74,0.11439720703125289,1), vec4(49.60143269140619,62,0.11439720703125289,3), vec4(49.72141024999994,76,0.11160703125000282,1), vec4(49.72141024999994,64,0.11160703125000282,3), vec4(49.838597632812444,79,0.11439720703125289,1), vec4(49.838597632812444,67,0.11439720703125289,3), vec4(49.9585751914062,72,0.11439720703125289,1), vec4(49.9585751914062,60,0.11439720703125289,3), vec4(50.07855274999995,76,0.11160703125000282,1), vec4(50.07855274999995,64,0.11160703125000282,3), vec4(50.19574013281245,79,0.11439720703125289,1), vec4(50.19574013281245,67,0.11439720703125289,3), vec4(50.315717691406206,72,0.11439720703125289,1), vec4(50.315717691406206,60,0.11439720703125289,3), vec4(50.43569524999996,74,0.11160703125000282,1), vec4(50.43569524999996,62,0.11160703125000282,3), vec4(50.55288263281246,77,0.11439720703125289,1), vec4(50.55288263281246,65,0.11439720703125289,3), vec4(50.672860191406215,70,0.11439720703125289,1), vec4(50.672860191406215,58,0.11439720703125289,3), vec4(50.79283774999997,74,0.11160703125000282,1), vec4(50.79283774999997,62,0.11160703125000282,3), vec4(50.91002513281247,77,0.11439720703125289,1), vec4(50.91002513281247,65,0.11439720703125289,3), vec4(51.030002691406224,70,0.11439720703125289,1), vec4(51.030002691406224,58,0.11439720703125289,3), vec4(51.14998024999998,72,0.11160703125000282,1), vec4(51.14998024999998,60,0.11160703125000282,3), vec4(51.26716763281248,76,0.11439720703125289,1), vec4(51.26716763281248,64,0.11439720703125289,3), vec4(51.38714519140623,69,0.11439720703125289,1), vec4(51.38714519140623,57,0.11439720703125289,3), vec4(51.507122749999986,72,0.11160703125000282,1), vec4(51.507122749999986,60,0.11160703125000282,3), vec4(51.62431013281249,76,0.11439720703125289,1), vec4(51.62431013281249,64,0.11439720703125289,3), vec4(51.74428769140624,69,0.11439720703125289,1), vec4(51.74428769140624,57,0.11439720703125289,3), vec4(51.864265249999995,70,0.11160703125000282,1), vec4(51.864265249999995,58,0.11160703125000282,3), vec4(51.9814526328125,74,0.11439720703125289,1), vec4(51.9814526328125,62,0.11439720703125289,3), vec4(52.10143019140625,67,0.11439720703125289,1), vec4(52.10143019140625,55,0.11439720703125289,3), vec4(52.221407750000004,70,0.11160703125000282,1), vec4(52.221407750000004,58,0.11160703125000282,3), vec4(52.33859513281251,74,0.11439720703125289,1), vec4(52.33859513281251,62,0.11439720703125289,3), vec4(52.45857269140626,67,0.11439720703125289,1), vec4(52.45857269140626,55,0.11439720703125289,3), vec4(52.57855025000001,69,0.11160703125000282,1), vec4(52.57855025000001,57,0.11160703125000282,3), vec4(52.695737632812516,72,0.11439720703125289,1), vec4(52.695737632812516,60,0.11439720703125289,3), vec4(52.81571519140627,65,0.11439720703125289,1), vec4(52.81571519140627,53,0.11439720703125289,3), vec4(52.93569275000002,69,0.11160703125000282,1), vec4(52.93569275000002,57,0.11160703125000282,3), vec4(53.052880132812525,72,0.11439720703125289,1), vec4(53.052880132812525,60,0.11439720703125289,3), vec4(53.17285769140628,65,0.11439720703125289,1), vec4(53.17285769140628,53,0.11439720703125289,3), vec4(53.29283525000003,67,0.11160703125000282,1), vec4(53.29283525000003,55,0.11160703125000282,3), vec4(53.410022632812534,70,0.11439720703125289,1), vec4(53.410022632812534,58,0.11439720703125289,3), vec4(53.53000019140629,64,0.11439720703125289,1), vec4(53.53000019140629,52,0.11439720703125289,3), vec4(53.64997775000004,67,0.11160703125000282,1), vec4(53.64997775000004,55,0.11160703125000282,3), vec4(53.76716513281254,70,0.11439720703125289,1), vec4(53.76716513281254,58,0.11439720703125289,3), vec4(53.8871426914063,64,0.11439720703125289,1), vec4(53.8871426914063,52,0.11439720703125289,3), vec4(54.00712025000005,65,0.1171875,1), vec4(54.00712025000005,53,0.1171875,3), vec4(54.13016712500005,69,0.1201171875,1), vec4(54.13016712500005,57,0.1201171875,3), vec4(54.25614368750005,62,0.1201171875,1), vec4(54.25614368750005,50,0.1201171875,3), vec4(54.38212025000005,65,0.1171875,1), vec4(54.38212025000005,53,0.1171875,3), vec4(54.50516712500005,69,0.1201171875,1), vec4(54.50516712500005,57,0.1201171875,3), vec4(54.63114368750005,62,0.1201171875,1), vec4(54.63114368750005,50,0.1201171875,3), vec4(54.75712025000005,64,0.13392843750000338,1), vec4(54.75712025000005,52,0.13392843750000338,3), vec4(54.89774510937505,67,0.1372766484374992,1), vec4(54.89774510937505,55,0.1372766484374992,3), vec4(55.04171817968755,61,0.1372766484374992,1), vec4(55.04171817968755,49,0.1372766484374992,3), vec4(55.18569125000005,64,0.13392843750000338,1), vec4(55.18569125000005,52,0.13392843750000338,3), vec4(55.32631610937505,67,0.1372766484374992,1), vec4(55.32631610937505,55,0.1372766484374992,3), vec4(55.47028917968755,61,0.1372766484374992,1), vec4(55.47028917968755,49,0.1372766484374992,3), vec4(56.25176225000005,49,2.7890625,3), vec4(56.39238725000005,52,2.82421875,3), vec4(57.16582475000005,67,2.173828125,1), vec4(56.53301225000005,55,2.859375,3), vec4(56.67363725000005,58,2.89453125,3), vec4(56.81426225000005,61,2.9296875,1), vec4(55.614262250000046,26,4.129687500000003,2), vec4(56.99004350000005,64,3.24609375,1), vec4(60.56426225000005,69,0.181640625,1), vec4(60.75176225000005,67,0.181640625,1), vec4(57.34160600000005,70,3.744140625,1), vec4(60.93926225000005,65,0.181640625,1), vec4(61.12676225000005,64,0.181640625,1), vec4(61.31426225000005,62,0.181640625,1), vec4(61.50176225000005,61,0.181640625,1), vec4(61.68926225000005,59,0.181640625,1), vec4(61.87676225000005,61,0.23828125,1), vec4(62.12676225000005,57,0.23828125,1), vec4(62.37676225000005,61,0.23828125,1), vec4(62.62676225000005,64,0.181640625,1), vec4(62.81426225000005,67,0.181640625,1), vec4(63.00176225000005,67,0.064453125,1), vec4(63.08379350000005,65,0.064453125,1), vec4(63.16582475000005,67,0.064453125,1), vec4(63.24785600000005,65,0.064453125,1), vec4(63.32988725000005,67,0.064453125,1), vec4(63.41191850000005,65,0.064453125,1), vec4(63.49394975000005,67,0.064453125,1), vec4(63.57598100000005,65,0.064453125,1), vec4(63.65801225000005,67,0.064453125,1), vec4(63.74004350000005,65,0.064453125,1), vec4(63.82207475000005,67,0.064453125,1), vec4(63.90410600000005,65,0.064453125,1), vec4(63.98613725000005,67,0.0644531249999929,1), vec4(64.12676225000004,64,0.357421875,1), vec4(64.50176225000004,9,8,-1), vec4(64.50176225000004,65,2.25,1), vec4(64.50176225000004,62,2.25,1), vec4(64.50176225000004,53,2.25,3), vec4(64.50176225000004,57,2.25,3), vec4(64.50176225000004,50,2.25,3), vec4(64.50176225000004,26,2.25,2), vec4(67.87676225000004,69,0.21024769921875475,1), vec4(68.09735000000005,74,0.10340050781249488,1), vec4(68.20764387500004,69,0.21024769921874054,3), vec4(68.31793775000004,76,0.10340050781249488,1), vec4(68.42823162500004,69,0.21024769921874054,3), vec4(68.53852550000003,77,0.10340050781249488,1), vec4(68.64881937500003,69,0.21024769921874054,3), vec4(68.75911325000003,74,0.10340050781249488,1), vec4(68.86940712500002,69,0.21024769921874054,3), vec4(68.97970100000002,76,0.10340050781249488,1), vec4(69.08999487500002,69,0.21024769921874054,3), vec4(69.20028875000001,77,0.10340050781249488,1), vec4(69.31058262500001,69,0.21024769921874054,3), vec4(69.4208765,79,0.10340050781249488,1), vec4(69.531170375,69,0.21024769921874054,3), vec4(69.64146425,76,0.10340050781249488,1), vec4(69.86205199999999,4,4,-1), vec4(69.86205199999999,77,0.10340050781249488,1), vec4(69.751758125,69,0.22058774999999287,3), vec4(69.97234587499999,69,0.21024769921874054,3), vec4(70.08263974999998,79,0.10340050781249488,1), vec4(70.19293362499998,69,0.21024769921874054,3), vec4(70.30322749999998,81,0.10340050781249488,1), vec4(70.41352137499997,69,0.21024769921874054,3), vec4(70.52381524999997,77,0.10340050781249488,1), vec4(70.63410912499997,69,0.21024769921874054,3), vec4(70.74440299999996,79,0.10340050781249488,1), vec4(70.85469687499996,69,0.21024769921874054,3), vec4(70.96499074999996,81,0.10340050781249488,1), vec4(71.07528462499995,69,0.21024769921874054,3), vec4(71.18557849999995,82,0.10340050781249488,1), vec4(71.29587237499995,69,0.21024769921874054,3), vec4(71.40616624999994,79,0.10340050781249488,1), vec4(71.51646012499994,69,0.21024769921874054,3), vec4(71.62675399999993,81,0.10340050781249488,1), vec4(71.73704787499993,69,0.21024769921874054,3), vec4(71.84734174999993,77,0.10340050781249488,1), vec4(71.95763562499992,69,0.21024769921874054,3), vec4(72.06792949999992,79,0.10340050781249488,1), vec4(72.17822337499992,69,0.21024769921874054,3), vec4(72.28851724999991,76,0.10340050781249488,1), vec4(72.39881112499991,69,0.21024769921874054,3), vec4(72.5091049999999,77,0.10340050781249488,1), vec4(72.6193988749999,69,0.21024769921874054,3), vec4(72.7296927499999,74,0.10340050781249488,1), vec4(72.8399866249999,69,0.21024769921874054,3), vec4(72.95028049999989,76,0.10340050781249488,1), vec4(73.06057437499989,69,0.21024769921874054,3), vec4(73.17086824999988,73,0.10340050781249488,1), vec4(73.39145599999988,74,0.10340050781249488,1), vec4(73.28116212499988,69,0.22058774999999287,3), vec4(73.50174987499987,69,0.21024769921874054,3), vec4(73.61204374999987,69,0.10340050781249488,1), vec4(73.72233762499987,69,0.21024769921874054,3), vec4(73.83263149999986,70,0.10340050781249488,1), vec4(73.94292537499986,69,0.21024769921874054,3), vec4(74.05321924999986,67,0.10340050781249488,1), vec4(74.16351312499985,69,0.21024769921874054,3), vec4(74.27380699999985,69,0.10340050781249488,1), vec4(74.38410087499985,69,0.21024769921874054,3), vec4(74.49439474999984,65,0.10340050781249488,1), vec4(74.60468862499984,69,0.21024769921874054,3), vec4(74.71498249999983,67,0.10340050781249488,1), vec4(74.82527637499983,69,0.21024769921874054,3), vec4(74.93557024999983,64,0.10340050781249488,1), vec4(75.04586412499982,69,0.21024769921874054,3), vec4(75.15615799999982,65,0.10340050781249488,1), vec4(75.26645187499982,69,0.21024769921874054,3), vec4(75.37674574999981,62,0.10340050781249488,1), vec4(75.48703962499981,69,0.21024769921874054,3), vec4(75.5973334999998,64,0.10340050781249488,1), vec4(75.7076273749998,69,0.21024769921874054,3), vec4(75.8179212499998,61,0.10340050781249488,1), vec4(75.9282151249998,69,0.21024769921874054,3), vec4(76.03850899999979,65,0.10340050781249488,1), vec4(76.14880287499979,69,0.21024769921874054,3), vec4(76.25909674999978,62,0.10340050781249488,1), vec4(76.36939062499978,69,0.21024769921874054,3), vec4(76.47968449999978,64,0.10340050781249488,1), vec4(76.58997837499977,69,0.21024769921874054,3), vec4(76.70027224999977,61,0.10340050781249488,1), vec4(76.92085999999976,62,0.10340050781249488,1), vec4(76.81056612499977,69,0.22058774999999287,3), vec4(77.03115387499976,69,0.21024769921874054,3), vec4(77.14144774999976,57,0.10340050781249488,1), vec4(77.25174162499975,69,0.21024769921874054,3), vec4(77.36203549999975,58,0.10340050781249488,1), vec4(77.47232937499975,69,0.21024769921874054,3), vec4(77.58262324999974,55,0.10340050781249488,1), vec4(77.69291712499974,69,0.21024769921874054,3), vec4(77.80321099999973,57,0.10340050781249488,1), vec4(77.91350487499973,69,0.21024769921874054,3), vec4(78.02379874999973,53,0.10340050781249488,1), vec4(78.13409262499972,69,0.21024769921874054,3), vec4(78.24438649999972,55,0.10340050781249488,1), vec4(78.35468037499972,69,0.21024769921874054,3), vec4(78.46497424999971,52,0.10340050781249488,1), vec4(78.57526812499971,69,0.21024769921874054,3), vec4(78.6855619999997,53,0.10340050781249488,1), vec4(78.7958558749997,69,0.21024769921874054,3), vec4(78.9061497499997,50,0.10340050781249488,1), vec4(79.0164436249997,69,0.21024769921874054,3), vec4(79.12673749999969,55,0.10340050781249488,1), vec4(79.23703137499969,69,0.21024769921874054,3), vec4(79.34732524999968,52,0.10340050781249488,1), vec4(79.45761912499968,69,0.21024769921874054,3), vec4(79.56791299999968,53,0.10340050781249488,1), vec4(79.67820687499967,69,0.21024769921874054,3), vec4(79.78850074999967,50,0.10340050781249488,1), vec4(79.89879462499967,69,0.21024769921874054,3), vec4(80.00908849999966,52,0.10340050781249488,1), vec4(80.11938237499966,69,0.21024769921874054,3), vec4(80.22967624999966,49,0.10340050781249488,1), vec4(80.33997012499965,69,0.29779387499999643,3), vec4(80.45026399999965,50,0.71484375,1), vec4(81.20026399999965,62,0.12526930468750663,1), vec4(81.32957424999965,65,0.12526930468750663,1), vec4(81.45888449999966,70,0.12526930468750663,1), vec4(81.58819474999966,65,0.12526930468750663,1), vec4(81.71750499999966,60,0.12526930468750663,1), vec4(81.84681524999966,64,0.12526930468750663,1), vec4(81.97612549999967,69,0.12526930468750663,1), vec4(82.10543574999967,64,0.12526930468750663,1), vec4(82.23474599999967,58,0.12526930468750663,1), vec4(82.36405624999968,62,0.12526930468750663,1), vec4(82.49336649999968,67,0.12526930468750663,1), vec4(82.62267674999968,62,0.12526930468750663,1), vec4(82.75198699999969,57,0.12526930468750663,1), vec4(82.88129724999969,61,0.12526930468750663,1), vec4(83.0106074999997,64,0.12526930468750663,1), vec4(83.1399177499997,69,0.12526930468750663,1), vec4(83.2692279999997,62,0.28593750000000284,1), vec4(83.2692279999997,38,0.5718749999999915,2), vec4(83.5692279999997,65,0.28593749999998863,1), vec4(83.5692279999997,70,0.28593749999998863,1), vec4(83.86922799999968,57,0.28593750000000284,3), vec4(83.86922799999968,36,0.5718749999999915,2), vec4(84.16922799999968,64,0.28593749999998863,1), vec4(84.16922799999968,69,0.28593749999998863,1), vec4(84.46922799999966,58,0.357421875,3), vec4(84.46922799999966,34,0.71484375,2), vec4(84.84422799999966,62,0.357421875,1), vec4(84.84422799999966,67,0.357421875,1), vec4(85.21922799999966,64,1.4296875,1), vec4(85.21922799999966,69,1.4296875,1), vec4(85.21922799999966,61,1.4296875,1), vec4(85.21922799999966,52,1.4296875,3), vec4(85.21922799999966,33,1.4296875,2), vec4(86.71922799999966,62,0.12746703515624347,1), vec4(86.85080687499965,65,0.12746703515624347,1), vec4(86.98238574999964,70,0.12746703515624347,1), vec4(87.11396462499962,65,0.12746703515624347,1), vec4(87.24554349999961,60,0.12746703515624347,1), vec4(87.3771223749996,64,0.12746703515624347,1), vec4(87.50870124999959,69,0.12746703515624347,1), vec4(87.64028012499958,64,0.12746703515624347,1), vec4(87.77185899999957,58,0.12746703515624347,1), vec4(87.90343787499955,62,0.12746703515624347,1), vec4(88.03501674999954,67,0.12746703515624347,1), vec4(88.16659562499953,62,0.12746703515624347,1), vec4(88.29817449999952,57,0.12746703515624347,1), vec4(88.4297533749995,61,0.12746703515624347,1), vec4(88.5613322499995,64,0.12746703515624347,1), vec4(88.69291112499948,69,0.12746703515624347,1), vec4(88.82448999999947,62,0.28593750000000284,1), vec4(88.82448999999947,38,0.5718749999999915,2), vec4(89.12448999999947,65,0.28593749999998863,1), vec4(89.12448999999947,70,0.28593749999998863,1), vec4(89.42448999999945,57,0.28593750000000284,3), vec4(89.42448999999945,36,0.5718749999999915,2), vec4(89.72448999999945,64,0.28593749999998863,1), vec4(89.72448999999945,69,0.28593749999998863,1), vec4(90.02448999999943,58,0.357421875,3), vec4(90.02448999999943,34,0.71484375,2), vec4(90.39948999999943,62,0.357421875,1), vec4(90.39948999999943,67,0.357421875,1), vec4(90.77448999999943,64,1.633926937499993,1), vec4(90.77448999999943,61,1.633926937499993,1), vec4(90.77448999999943,52,1.633926937499993,3), vec4(90.77448999999943,33,1.633926937499993,2), vec4(90.77448999999943,69,1.8440271132812427,1), vec4(92.62270237499942,67,0.12974311328125054,1), vec4(92.75663074999942,65,0.12974311328125054,1), vec4(92.89055912499941,64,0.12974311328125054,1), vec4(93.02448749999941,62,0.12974311328125054,1), vec4(93.1584158749994,61,0.12974311328125054,1), vec4(93.2923442499994,59,0.12974311328125054,1), vec4(93.4262726249994,61,0.12974311328125054,1), vec4(93.5602009999994,57,0.12974311328125054,3), vec4(93.69412937499939,59,0.12974311328125054,3), vec4(93.82805774999939,61,0.12974311328125054,3), vec4(93.96198612499938,62,0.12974311328125054,3), vec4(94.09591449999938,64,0.12974311328125054,1), vec4(94.22984287499938,65,0.12974311328125054,1), vec4(94.36377124999937,67,0.12974311328125054,1), vec4(94.49769962499937,69,0.12974311328125054,1), vec4(94.63162799999937,67,0.12974311328125054,1), vec4(94.76555637499936,65,0.12974311328125054,1), vec4(94.89948474999936,64,0.12974311328125054,1), vec4(95.03341312499936,65,0.12974311328125054,1), vec4(95.16734149999935,62,0.12974311328125054,1), vec4(95.30126987499935,65,0.12974311328125054,1), vec4(95.43519824999935,69,0.12974311328125054,1), vec4(95.56912662499934,73,0.12974311328125054,1), vec4(95.70305499999934,74,0.2553009648437552,1), vec4(95.97091174999935,69,0.12974311328125054,1), vec4(96.10484012499934,71,0.12974311328125054,1), vec4(96.23876849999934,73,0.12974311328125054,1), vec4(96.37269687499933,74,0.12974311328125054,1), vec4(96.50662524999933,76,0.12974311328125054,1), vec4(96.64055362499933,77,0.12974311328125054,1), vec4(96.77448199999932,79,0.12974311328125054,1), vec4(96.90841037499932,81,0.12974311328125054,1), vec4(97.04233874999932,82,0.4765625,1), vec4(97.54233874999932,74,0.28593750000000284,1), vec4(97.54233874999932,38,0.5718749999999915,2), vec4(97.84233874999931,77,0.28593749999998863,1), vec4(97.84233874999931,82,0.28593749999998863,1), vec4(98.1423387499993,69,0.28593750000000284,1), vec4(98.1423387499993,36,0.5718749999999915,2), vec4(98.4423387499993,76,0.28593749999998863,1), vec4(98.4423387499993,81,0.28593749999998863,1), vec4(98.74233874999928,70,0.357421875,1), vec4(98.74233874999928,34,0.71484375,2), vec4(99.11733874999928,74,0.357421875,1), vec4(99.11733874999928,79,0.357421875,1), vec4(99.49233874999928,73,0.953125,1), vec4(99.49233874999928,76,0.953125,1), vec4(99.49233874999928,81,0.953125,1), vec4(99.49233874999928,64,0.953125,1), vec4(99.49233874999928,33,0.953125,2), vec4(100.49233874999928,74,0.1321022617187566,1), vec4(100.62870237499928,77,0.1321022617187566,1), vec4(100.76506599999928,82,0.1321022617187566,1), vec4(100.90142962499928,77,0.1321022617187566,1), vec4(101.03779324999928,72,0.1321022617187566,1), vec4(101.17415687499928,76,0.1321022617187566,1), vec4(101.31052049999928,81,0.1321022617187566,1), vec4(101.44688412499929,76,0.1321022617187566,1), vec4(101.58324774999929,70,0.1321022617187566,1), vec4(101.71961137499929,74,0.1321022617187566,1), vec4(101.85597499999929,79,0.1321022617187566,1), vec4(101.99233862499929,74,0.1321022617187566,1), vec4(102.1287022499993,69,0.1321022617187566,1), vec4(102.2650658749993,73,0.1321022617187566,1), vec4(102.4014294999993,76,0.1321022617187566,1), vec4(102.5377931249993,81,0.1321022617187566,1), vec4(102.6741567499993,74,0.28593750000000284,1), vec4(102.6741567499993,38,0.5718749999999915,2), vec4(102.9741567499993,77,0.28593749999998863,1), vec4(102.9741567499993,82,0.28593749999998863,1), vec4(103.27415674999928,69,0.28593750000000284,1), vec4(103.27415674999928,36,0.5718749999999915,2), vec4(103.57415674999928,76,0.28593749999998863,1), vec4(103.57415674999928,81,0.28593749999998863,1), vec4(103.87415674999926,70,0.28593750000000284,1), vec4(103.87415674999926,34,0.5718749999999915,2), vec4(104.17415674999926,74,0.28593749999998863,1), vec4(104.17415674999926,79,0.28593749999998863,1), vec4(104.47415674999924,73,0.71484375,1), vec4(104.47415674999924,76,0.71484375,1), vec4(104.47415674999924,81,0.71484375,1), vec4(104.47415674999924,64,0.71484375,1), vec4(104.47415674999924,33,0.71484375,2), vec4(105.22415674999924,71,0.71484375,1), vec4(105.22415674999924,74,0.71484375,1), vec4(105.22415674999924,59,0.71484375,1), vec4(105.22415674999924,62,0.71484375,1), vec4(105.22415674999924,65,0.71484375,1), vec4(105.22415674999924,32,0.71484375,2), vec4(105.97415674999924,33,32,-1), vec4(105.97415674999924,73,1.072265625,1), vec4(105.97415674999924,64,1.4296875,1), vec4(105.97415674999924,69,1.4296875,1), vec4(105.97415674999924,57,1.4296875,3), vec4(105.97415674999924,31,1.4296875,2), vec4(107.09915674999924,71,0.357421875,1), vec4(107.47415674999924,69,0.2599431601562543,1), vec4(107.74688399999924,73,0.2599431601562543,1), vec4(108.01961124999924,76,0.181640625,1), vec4(108.20711124999924,79,0.181640625,1), vec4(108.39461124999924,82,1.125,1), vec4(109.51961124999924,81,0.12109375,1), vec4(109.64461124999924,79,0.12109375,1), vec4(109.76961124999924,77,0.12109375,1), vec4(109.89461124999924,76,0.12109375,1), vec4(110.01961124999924,77,0.12109375,1), vec4(110.14461124999924,76,0.12109375,1), vec4(110.26961124999924,74,0.12109375,1), vec4(110.39461124999924,73,0.12109375,1), vec4(110.51961124999924,74,0.12109375,1), vec4(110.64461124999924,72,0.12109375,1), vec4(110.76961124999924,70,0.12109375,1), vec4(110.89461124999924,69,0.12109375,1), vec4(111.01961124999924,67,0.12109375,1), vec4(111.14461124999924,65,0.12109375,1), vec4(111.26961124999924,64,0.12109375,1), vec4(111.39461124999924,62,0.12109375,1), vec4(111.52156437499924,4,4,-1), vec4(111.52156437499924,76,2.853515625,1), vec4(111.52156437499924,70,2.853515625,1), vec4(111.52156437499924,67,2.853515625,3), vec4(111.52156437499924,61,2.853515625,3), vec4(111.52156437499924,43,2.853515625,2), vec4(111.52156437499924,73,3.110293906250007,1), vec4(111.52156437499924,64,3.110293906250007,3), vec4(114.63737297656175,76,0.11305125390624937,1), vec4(114.63737297656175,67,0.11305125390624937,3), vec4(114.7559389257805,73,0.11305125390624937,1), vec4(114.7559389257805,64,0.11305125390624937,3), vec4(114.87450487499925,70,0.11029390625000701,1), vec4(114.87450487499925,61,0.11029390625000701,3), vec4(114.99031347656175,73,0.11305125390624937,1), vec4(114.99031347656175,64,0.11305125390624937,3), vec4(115.1088794257805,70,0.11305125390624937,1), vec4(115.1088794257805,61,0.11305125390624937,3), vec4(115.22744537499925,73,0.11029390625000701,1), vec4(115.22744537499925,64,0.11029390625000701,3), vec4(115.34325397656175,76,0.11305125390624937,1), vec4(115.34325397656175,67,0.11305125390624937,3), vec4(115.4618199257805,73,0.11305125390624937,1), vec4(115.4618199257805,64,0.11305125390624937,3), vec4(115.58038587499925,70,0.11029390625000701,1), vec4(115.58038587499925,61,0.11029390625000701,3), vec4(115.69619447656176,73,0.11305125390624937,1), vec4(115.69619447656176,64,0.11305125390624937,3), vec4(115.8147604257805,70,0.11305125390624937,1), vec4(115.8147604257805,61,0.11305125390624937,3), vec4(115.93332637499925,73,0.11029390625000701,1), vec4(115.93332637499925,64,0.11029390625000701,3), vec4(116.04913497656176,76,0.11305125390624937,1), vec4(116.04913497656176,67,0.11305125390624937,3), vec4(116.16770092578051,73,0.11305125390624937,1), vec4(116.16770092578051,64,0.11305125390624937,3), vec4(116.28626687499926,70,0.11029390625000701,1), vec4(116.28626687499926,61,0.11029390625000701,3), vec4(116.40207547656176,73,0.11305125390624937,1), vec4(116.40207547656176,64,0.11305125390624937,3), vec4(116.52064142578051,70,0.11305125390624937,1), vec4(116.52064142578051,61,0.11305125390624937,3), vec4(116.63920737499926,73,0.11029390625000701,1), vec4(116.63920737499926,64,0.11029390625000701,3), vec4(116.75501597656177,76,0.11305125390624937,1), vec4(116.75501597656177,67,0.11305125390624937,3), vec4(116.87358192578051,73,0.11305125390624937,1), vec4(116.87358192578051,64,0.11305125390624937,3), vec4(116.99214787499926,70,0.11029390625000701,1), vec4(116.99214787499926,61,0.11029390625000701,3), vec4(117.10795647656177,73,0.11305125390624937,1), vec4(117.10795647656177,64,0.11305125390624937,3), vec4(117.22652242578052,70,0.11305125390624937,1), vec4(117.22652242578052,61,0.11305125390624937,3), vec4(117.34508837499926,67,0.11029390625000701,1), vec4(117.34508837499926,58,0.11029390625000701,3), vec4(117.46089697656177,70,0.11305125390624937,1), vec4(117.46089697656177,61,0.11305125390624937,3), vec4(117.57946292578052,67,0.11305125390624937,1), vec4(117.57946292578052,58,0.11305125390624937,3), vec4(117.69802887499927,64,0.11029390625000701,1), vec4(117.69802887499927,55,0.11029390625000701,3), vec4(117.81383747656177,67,0.11305125390624937,1), vec4(117.81383747656177,58,0.11305125390624937,3), vec4(117.93240342578052,64,0.11305125390624937,1), vec4(117.93240342578052,55,0.11305125390624937,3), vec4(118.05096937499927,67,0.11029390625000701,1), vec4(118.05096937499927,58,0.11029390625000701,3), vec4(118.16677797656178,70,0.11305125390624937,1), vec4(118.16677797656178,61,0.11305125390624937,3), vec4(118.28534392578052,67,0.11305125390624937,1), vec4(118.28534392578052,58,0.11305125390624937,3), vec4(118.40390987499927,64,0.11029390625000701,1), vec4(118.40390987499927,55,0.11029390625000701,3), vec4(118.51971847656178,67,0.11305125390624937,1), vec4(118.51971847656178,58,0.11305125390624937,3), vec4(118.63828442578053,64,0.11305125390624937,1), vec4(118.63828442578053,55,0.11305125390624937,3), vec4(118.75685037499927,67,0.11029390625000701,1), vec4(118.75685037499927,58,0.11029390625000701,3), vec4(118.87265897656178,70,0.11305125390624937,1), vec4(118.87265897656178,61,0.11305125390624937,3), vec4(118.99122492578053,67,0.11305125390624937,1), vec4(118.99122492578053,58,0.11305125390624937,3), vec4(119.10979087499928,64,0.11029390625000701,1), vec4(119.10979087499928,55,0.11029390625000701,3), vec4(119.22559947656178,67,0.11305125390624937,1), vec4(119.22559947656178,58,0.11305125390624937,3), vec4(119.34416542578053,64,0.11305125390624937,1), vec4(119.34416542578053,55,0.11305125390624937,3), vec4(119.46273137499928,67,0.11029390625000701,1), vec4(119.46273137499928,58,0.11029390625000701,3), vec4(119.57853997656179,70,0.11305125390624937,1), vec4(119.57853997656179,61,0.11305125390624937,3), vec4(119.69710592578053,67,0.11305125390624937,1), vec4(119.69710592578053,58,0.11305125390624937,3), vec4(119.81567187499928,64,0.11029390625000701,1), vec4(119.81567187499928,55,0.11029390625000701,3), vec4(119.93148047656179,67,0.11305125390624937,1), vec4(119.93148047656179,58,0.11305125390624937,3), vec4(120.05004642578054,64,0.11305125390624937,1), vec4(120.05004642578054,55,0.11305125390624937,3), vec4(120.16861237499928,61,0.11029390625000701,1), vec4(120.16861237499928,52,0.11029390625000701,3), vec4(120.28442097656179,64,0.11305125390624937,1), vec4(120.28442097656179,55,0.11305125390624937,3), vec4(120.40298692578054,61,0.11305125390624937,1), vec4(120.40298692578054,52,0.11305125390624937,3), vec4(120.52155287499929,58,0.11029390625000701,1), vec4(120.52155287499929,49,0.11029390625000701,3), vec4(120.6373614765618,61,0.11305125390624937,1), vec4(120.6373614765618,52,0.11305125390624937,3), vec4(120.75592742578054,58,0.11305125390624937,1), vec4(120.75592742578054,49,0.11305125390624937,3), vec4(120.87449337499929,61,0.11029390625000701,1), vec4(120.87449337499929,52,0.11029390625000701,3), vec4(120.9903019765618,64,0.11305125390624937,1), vec4(120.9903019765618,55,0.11305125390624937,3), vec4(121.10886792578054,61,0.11305125390624937,1), vec4(121.10886792578054,52,0.11305125390624937,3), vec4(121.22743387499929,58,0.11029390625000701,1), vec4(121.22743387499929,49,0.11029390625000701,3), vec4(121.3432424765618,61,0.11305125390624937,1), vec4(121.3432424765618,52,0.11305125390624937,3), vec4(121.46180842578055,58,0.11305125390624937,1), vec4(121.46180842578055,49,0.11305125390624937,3), vec4(121.5803743749993,61,0.11029390625000701,1), vec4(121.5803743749993,52,0.11029390625000701,3), vec4(121.6961829765618,64,0.11305125390624937,1), vec4(121.6961829765618,55,0.11305125390624937,3), vec4(121.81474892578055,61,0.11305125390624937,1), vec4(121.81474892578055,52,0.11305125390624937,3), vec4(121.9333148749993,58,0.11029390625000701,1), vec4(121.9333148749993,49,0.11029390625000701,3), vec4(122.0491234765618,61,0.11305125390624937,1), vec4(122.0491234765618,52,0.11305125390624937,3), vec4(122.16768942578055,58,0.11305125390624937,1), vec4(122.16768942578055,49,0.11305125390624937,3), vec4(122.2862553749993,61,0.11029390625000701,1), vec4(122.2862553749993,52,0.11029390625000701,3), vec4(122.4020639765618,64,0.11305125390624937,1), vec4(122.4020639765618,55,0.11305125390624937,3), vec4(122.52062992578055,61,0.11305125390624937,1), vec4(122.52062992578055,52,0.11305125390624937,3), vec4(122.6391958749993,58,0.11029390625000701,1), vec4(122.6391958749993,49,0.11029390625000701,3), vec4(122.75500447656181,61,0.11305125390624937,1), vec4(122.75500447656181,52,0.11305125390624937,3), vec4(122.87357042578056,58,0.11305125390624937,1), vec4(122.87357042578056,49,0.11305125390624937,3), vec4(122.9921363749993,61,0.11029390625000701,1), vec4(122.9921363749993,52,0.11029390625000701,3), vec4(123.10794497656181,64,0.11305125390624937,1), vec4(123.10794497656181,55,0.11305125390624937,3), vec4(123.22651092578056,61,0.11305125390624937,1), vec4(123.22651092578056,52,0.11305125390624937,3), vec4(123.34507687499931,64,0.11029390625000701,1), vec4(123.34507687499931,55,0.11029390625000701,3), vec4(123.46088547656181,67,0.11305125390624937,1), vec4(123.46088547656181,58,0.11305125390624937,3), vec4(123.57945142578056,64,0.11305125390624937,1), vec4(123.57945142578056,55,0.11305125390624937,3), vec4(123.69801737499931,61,0.11029390625000701,1), vec4(123.69801737499931,52,0.11029390625000701,3), vec4(123.81382597656182,64,0.11305125390624937,1), vec4(123.81382597656182,55,0.11305125390624937,3), vec4(123.93239192578056,61,0.11305125390624937,1), vec4(123.93239192578056,52,0.11305125390624937,3), vec4(124.05095787499931,64,0.11029390625000701,1), vec4(124.05095787499931,55,0.11029390625000701,3), vec4(124.16676647656182,67,0.11305125390624937,1), vec4(124.16676647656182,58,0.11305125390624937,3), vec4(124.28533242578057,64,0.11305125390624937,1), vec4(124.28533242578057,55,0.11305125390624937,3), vec4(124.40389837499932,61,0.11029390625000701,1), vec4(124.40389837499932,52,0.11029390625000701,3), vec4(124.51970697656182,64,0.11305125390624937,1), vec4(124.51970697656182,55,0.11305125390624937,3), vec4(124.63827292578057,61,0.11305125390624937,1), vec4(124.63827292578057,52,0.11305125390624937,3), vec4(124.75683887499932,64,0.11029390625000701,1), vec4(124.75683887499932,55,0.11029390625000701,3), vec4(124.87264747656182,67,0.11305125390624937,1), vec4(124.87264747656182,58,0.11305125390624937,3), vec4(124.99121342578057,64,0.11305125390624937,1), vec4(124.99121342578057,55,0.11305125390624937,3), vec4(125.10977937499932,61,0.11029390625000701,1), vec4(125.10977937499932,52,0.11029390625000701,3), vec4(125.22558797656183,64,0.11305125390624937,1), vec4(125.22558797656183,55,0.11305125390624937,3), vec4(125.34415392578057,61,0.11305125390624937,1), vec4(125.34415392578057,52,0.11305125390624937,3), vec4(125.46271987499932,64,0.11029390625000701,1), vec4(125.46271987499932,55,0.11029390625000701,3), vec4(125.57852847656183,67,0.11305125390624937,1), vec4(125.57852847656183,58,0.11305125390624937,3), vec4(125.69709442578058,64,0.11305125390624937,1), vec4(125.69709442578058,55,0.11305125390624937,3), vec4(125.81566037499933,67,0.11029390625000701,1), vec4(125.81566037499933,52,0.11029390625000701,3), vec4(125.93146897656183,70,0.11305125390624937,1), vec4(125.93146897656183,55,0.11305125390624937,3), vec4(126.05003492578058,67,0.11305125390624937,1), vec4(126.05003492578058,52,0.11305125390624937,3), vec4(126.16860087499933,70,0.11029390625000701,1), vec4(126.16860087499933,52,0.11029390625000701,3), vec4(126.28440947656183,67,0.11305125390624937,1), vec4(126.28440947656183,55,0.11305125390624937,3), vec4(126.40297542578058,70,0.1201171875,1), vec4(126.40297542578058,52,0.1201171875,3), vec4(126.52895198828058,67,0.1171875,1), vec4(126.52895198828058,58,0.1171875,3), vec4(126.65199886328058,70,0.1201171875,1), vec4(126.65199886328058,61,0.1201171875,3), vec4(126.77797542578058,67,0.1201171875,1), vec4(126.77797542578058,58,0.1201171875,3), vec4(126.90395198828058,70,0.1171875,1), vec4(126.90395198828058,58,0.1171875,3), vec4(127.02699886328058,67,0.1201171875,1), vec4(127.02699886328058,61,0.1201171875,3), vec4(127.15297542578058,70,0.12812499999999716,1), vec4(127.15297542578058,58,0.12812499999999716,3), vec4(127.28735042578057,73,0.125,1), vec4(127.28735042578057,64,0.125,3), vec4(127.41860042578057,70,0.12812499999999716,1), vec4(127.41860042578057,61,0.12812499999999716,3), vec4(127.55297542578056,73,0.12812499999999716,1), vec4(127.55297542578056,64,0.12812499999999716,3), vec4(127.68735042578055,76,0.13392843750000338,1), vec4(127.68735042578055,61,0.13392843750000338,3), vec4(127.82797528515556,73,0.1372766484375063,1), vec4(127.82797528515556,64,0.1372766484375063,3), vec4(127.97194835546807,76,0.1372766484375063,1), vec4(127.97194835546807,61,0.1372766484375063,3), vec4(128.11592142578058,73,0.13392843750000338,1), vec4(128.11592142578058,64,0.13392843750000338,3), vec4(128.2565462851556,76,0.14783623046875505,1), vec4(128.2565462851556,61,0.14783623046875505,3), vec4(128.41159403906184,73,0.14783623046875505,1), vec4(128.41159403906184,64,0.14783623046875505,3), vec4(128.56664179296808,76,0.14423046875000978,1), vec4(128.56664179296808,61,0.14423046875000978,3), vec4(128.71808378515559,73,0.14783623046875505,1), vec4(128.71808378515559,64,0.14783623046875505,3), vec4(128.87313153906183,76,0.14783623046875505,1), vec4(128.87313153906183,61,0.14783623046875505,3), vec4(129.02817929296808,69,1.1437500000000114,1), vec4(129.02817929296808,73,1.1437500000000114,1), vec4(129.02817929296808,76,1.1437500000000114,1), vec4(129.02817929296808,81,1.1437500000000114,1), vec4(129.02817929296808,61,1.1437500000000114,1), vec4(129.02817929296808,64,1.1437500000000114,1), vec4(129.02817929296808,57,1.1437500000000114,3), vec4(129.02817929296808,43,1.1437500000000114,2), vec4(130.2281792929681,69,1.1437500000000114,1), vec4(130.2281792929681,74,1.1437500000000114,1), vec4(130.2281792929681,77,1.1437500000000114,1), vec4(130.2281792929681,81,1.1437500000000114,1), vec4(130.2281792929681,62,1.1437500000000114,1), vec4(130.2281792929681,65,1.1437500000000114,1), vec4(130.2281792929681,57,1.1437500000000114,3), vec4(130.2281792929681,41,1.1437500000000114,2), vec4(131.4281792929681,70,1.4296875,1), vec4(131.4281792929681,74,1.4296875,1), vec4(131.4281792929681,79,1.4296875,1), vec4(131.4281792929681,62,1.4296875,1), vec4(131.4281792929681,67,1.4296875,1), vec4(131.4281792929681,46,2.138671875,2), vec4(133.6781792929681,45,0.357421875,2), vec4(134.0531792929681,43,0.357421875,2), vec4(134.4281792929681,45,1.072265625,2), vec4(134.4281792929681,69,1.4296875,1), vec4(134.4281792929681,73,1.4296875,1), vec4(134.4281792929681,76,1.4296875,1), vec4(134.4281792929681,79,1.4296875,1), vec4(134.4281792929681,61,1.4296875,1), vec4(134.4281792929681,64,1.4296875,1), vec4(135.5531792929681,40,0.357421875,2), vec4(135.9281792929681,41,0.357421875,2), vec4(136.3031792929681,38,0.357421875,2), vec4(136.6781792929681,40,0.357421875,2), vec4(137.0531792929681,37,0.357421875,2), vec4(137.4281792929681,38,0.357421875,2), vec4(137.8031792929681,35,0.357421875,2), vec4(138.1781792929681,37,0.357421875,2), vec4(138.5531792929681,33,0.357421875,2), vec4(138.9281792929681,34,0.4765625,2), vec4(139.4281792929681,32,0.4765625,2), vec4(139.9281792929681,33,0.4765625,2), vec4(140.4281792929681,69,0.5718750000000057,1), vec4(140.4281792929681,73,0.5718750000000057,1), vec4(140.4281792929681,64,0.5718750000000057,1), vec4(140.4281792929681,57,0.5718750000000057,3), vec4(140.4281792929681,43,0.5718750000000057,2), vec4(141.0281792929681,65,1.1437500000000114,1), vec4(141.0281792929681,69,1.1437500000000114,1), vec4(141.0281792929681,74,1.1437500000000114,1), vec4(141.0281792929681,62,1.1437500000000114,1), vec4(141.0281792929681,57,1.1437500000000114,3), vec4(141.0281792929681,41,1.1437500000000114,2), vec4(142.22817929296812,65,1.1437500000000114,1), vec4(142.22817929296812,38,1.1437500000000114,2), vec4(142.22817929296812,62,2.629687500000017,1), vec4(142.22817929296812,57,3.344531250000017,3), vec4(143.42817929296814,64,2.859375,1), vec4(143.42817929296814,33,2.859375,2), vec4(144.92817929296814,61,1.4296875,1), vec4(145.67817929296814,55,2.1796875,3), vec4(147.92817929296814,53,0.71484375,3), vec4(148.67817929296814,52,0.71484375,3), vec4(146.42817929296814,62,6.609375,1), vec4(146.42817929296814,50,6.609375,3), vec4(146.42817929296814,57,6.609375,3), vec4(146.42817929296814,26,6.609375,2), vec4(149.42817929296814,53,3.8125,3), vec4(156.42817929296814,69,0.1588537695312482,3), vec4(156.59484554296813,67,0.1588537695312482,3), vec4(156.76151179296812,69,0.1588537695312482,3), vec4(156.9281780429681,65,0.1588537695312482,3), vec4(157.0948442929681,69,0.1588537695312482,3), vec4(157.2615105429681,64,0.1588537695312482,3), vec4(157.4281767929681,69,0.1588537695312482,3), vec4(157.59484304296808,62,0.1588537695312482,3), vec4(157.76150929296807,69,0.1588537695312482,3), vec4(157.92817554296806,61,0.1588537695312482,3), vec4(158.09484179296805,69,0.1588537695312482,3), vec4(158.26150804296805,62,0.1588537695312482,3), vec4(158.42817429296804,69,0.1588537695312482,3), vec4(158.59484054296803,64,0.1588537695312482,3), vec4(158.76150679296802,69,0.1588537695312482,3), vec4(158.928173042968,65,0.1588537695312482,3), vec4(159.094839292968,69,0.1588537695312482,3), vec4(159.261505542968,57,0.1588537695312482,3), vec4(159.428171792968,69,0.1588537695312482,3), vec4(159.59483804296798,59,0.1588537695312482,3), vec4(159.76150429296797,69,0.1588537695312482,3), vec4(159.92817054296796,61,0.1588537695312482,3), vec4(160.09483679296795,69,0.1588537695312482,3), vec4(160.26150304296795,62,0.1588537695312482,3), vec4(160.42816929296794,69,0.1588537695312482,3), vec4(160.59483554296793,61,0.1588537695312482,3), vec4(160.76150179296792,69,0.1588537695312482,3), vec4(160.9281680429679,62,0.1588537695312482,3), vec4(161.0948342929679,69,0.1588537695312482,3), vec4(161.2615005429679,64,0.1588537695312482,3), vec4(161.4281667929679,69,0.1588537695312482,3), vec4(161.59483304296788,65,0.3177075390624964,3), vec4(161.76149929296787,74,0.1588537695312482,1), vec4(161.92816554296786,72,0.1588537695312482,1), vec4(161.92816554296786,66,0.3177075390624964,3), vec4(162.09483179296785,74,0.1588537695312482,1), vec4(162.26149804296784,70,0.1588537695312482,1), vec4(162.26149804296784,67,0.3177075390624964,3), vec4(162.42816429296784,74,0.1588537695312482,1), vec4(162.59483054296783,69,0.1588537695312482,1), vec4(162.59483054296783,60,0.3177075390624964,3), vec4(162.76149679296782,74,0.1588537695312482,1), vec4(162.9281630429678,67,0.1588537695312482,1), vec4(162.9281630429678,58,0.3177075390624964,3), vec4(163.0948292929678,74,0.1588537695312482,1), vec4(163.2614955429678,66,0.1588537695312482,1), vec4(163.2614955429678,57,0.3177075390624964,3));\n    const vec4 v_1[1024] = vec4[](vec4(163.42816179296779,74,0.1588537695312482,1), vec4(163.59482804296778,67,0.1588537695312482,1), vec4(163.59482804296778,58,0.3177075390624964,3), vec4(163.76149429296777,74,0.1588537695312482,1), vec4(163.92816054296776,69,0.1588537695312482,1), vec4(163.92816054296776,60,0.3177075390624964,3), vec4(164.09482679296775,74,0.1588537695312482,1), vec4(164.26149304296774,70,0.1588537695312482,1), vec4(164.26149304296774,62,0.3177075390624964,3), vec4(164.42815929296773,74,0.1588537695312482,1), vec4(164.59482554296773,62,0.1588537695312482,1), vec4(164.59482554296773,54,0.3177075390624964,3), vec4(164.76149179296772,74,0.1588537695312482,1), vec4(164.9281580429677,64,0.1588537695312482,1), vec4(164.9281580429677,55,0.3177075390624964,3), vec4(165.0948242929677,74,0.1588537695312482,1), vec4(165.2614905429677,66,0.1588537695312482,1), vec4(165.2614905429677,57,0.3177075390624964,3), vec4(165.42815679296768,74,0.1588537695312482,1), vec4(165.59482304296768,67,0.1588537695312482,1), vec4(165.59482304296768,58,0.3177075390624964,3), vec4(165.76148929296767,74,0.1588537695312482,1), vec4(165.92815554296766,66,0.1588537695312482,1), vec4(165.92815554296766,57,0.3177075390624964,3), vec4(166.09482179296765,74,0.1588537695312482,1), vec4(166.26148804296764,67,0.1588537695312482,1), vec4(166.26148804296764,58,0.3177075390624964,3), vec4(166.42815429296763,74,0.1588537695312482,1), vec4(166.59482054296762,69,0.1588537695312482,1), vec4(166.59482054296762,54,0.3177075390624964,3), vec4(166.76148679296762,74,0.1588537695312482,1), vec4(166.9281530429676,55,0.1588537695312482,3), vec4(166.9281530429676,70,0.2343744140625006,1), vec4(167.0948192929676,67,0.1588537695312482,3), vec4(167.2614855429676,55,0.1588537695312482,3), vec4(167.2614855429676,74,0.2343744140625006,1), vec4(167.42815179296758,67,0.1588537695312482,3), vec4(167.59481804296757,62,0.1588537695312482,3), vec4(167.59481804296757,70,0.2343744140625006,1), vec4(167.76148429296757,67,0.1588537695312482,3), vec4(167.92815054296756,62,0.1588537695312482,3), vec4(167.92815054296756,74,0.2343744140625006,1), vec4(168.09481679296755,67,0.1588537695312482,3), vec4(168.26148304296754,60,0.1588537695312482,3), vec4(168.26148304296754,75,0.2343744140625006,1), vec4(168.42814929296753,63,0.1588537695312482,3), vec4(168.59481554296752,60,0.1588537695312482,3), vec4(168.59481554296752,67,0.2343744140625006,1), vec4(168.76148179296752,63,0.1588537695312482,3), vec4(168.9281480429675,60,0.1588537695312482,3), vec4(168.9281480429675,75,0.2343744140625006,1), vec4(169.0948142929675,63,0.1588537695312482,3), vec4(169.2614805429675,60,0.1588537695312482,3), vec4(169.2614805429675,67,0.2343744140625006,1), vec4(169.42814679296748,63,0.1588537695312482,3), vec4(169.59481304296747,60,0.1588537695312482,3), vec4(169.59481304296747,72,0.2343744140625006,1), vec4(169.76147929296746,65,0.1588537695312482,3), vec4(169.92814554296746,60,0.1588537695312482,3), vec4(169.92814554296746,69,0.2343744140625006,1), vec4(170.09481179296745,65,0.1588537695312482,3), vec4(170.26147804296744,60,0.1588537695312482,3), vec4(170.26147804296744,72,0.2343744140625006,1), vec4(170.42814429296743,65,0.1588537695312482,3), vec4(170.59481054296742,60,0.1588537695312482,3), vec4(170.59481054296742,69,0.2343744140625006,1), vec4(170.76147679296741,65,0.1588537695312482,3), vec4(170.9281430429674,58,0.1588537695312482,3), vec4(170.9281430429674,74,0.2343744140625006,1), vec4(171.0948092929674,62,0.1588537695312482,3), vec4(171.2614755429674,58,0.1588537695312482,3), vec4(171.2614755429674,65,0.2343744140625006,1), vec4(171.42814179296738,62,0.1588537695312482,3), vec4(171.59480804296737,58,0.1588537695312482,3), vec4(171.59480804296737,74,0.2343744140625006,1), vec4(171.76147429296736,62,0.1588537695312482,3), vec4(171.92814054296736,58,0.1588537695312482,3), vec4(171.92814054296736,65,0.2343744140625006,1), vec4(172.09480679296735,62,0.1588537695312482,3), vec4(172.26147304296734,58,0.1588537695312482,3), vec4(172.26147304296734,70,0.2343744140625006,1), vec4(172.42813929296733,64,0.1588537695312482,3), vec4(172.59480554296732,58,0.1588537695312482,3), vec4(172.59480554296732,67,0.2343744140625006,1), vec4(172.7614717929673,64,0.1588537695312482,3), vec4(172.9281380429673,58,0.1588537695312482,3), vec4(172.9281380429673,70,0.2343744140625006,1), vec4(173.0948042929673,64,0.1588537695312482,3), vec4(173.2614705429673,58,0.1588537695312482,3), vec4(173.2614705429673,67,0.2343744140625006,1), vec4(173.42813679296728,64,0.1588537695312482,3), vec4(173.59480304296727,57,0.1588537695312482,3), vec4(173.59480304296727,73,0.2343744140625006,1), vec4(173.76146929296726,61,0.1588537695312482,3), vec4(173.92813554296725,57,0.1588537695312482,3), vec4(173.92813554296725,64,0.2343744140625006,1), vec4(174.09480179296725,61,0.1588537695312482,3), vec4(174.26146804296724,57,0.1588537695312482,3), vec4(174.26146804296724,73,0.2343744140625006,1), vec4(174.42813429296723,61,0.1588537695312482,3), vec4(174.59480054296722,57,0.1588537695312482,3), vec4(174.59480054296722,64,0.2343744140625006,1), vec4(174.7614667929672,61,0.1588537695312482,3), vec4(174.9281330429672,53,0.1588537695312482,3), vec4(174.9281330429672,69,0.2343744140625006,1), vec4(175.0947992929672,62,0.1588537695312482,3), vec4(175.2614655429672,53,0.1588537695312482,3), vec4(175.2614655429672,65,0.2343744140625006,1), vec4(175.42813179296718,62,0.1588537695312482,3), vec4(175.59479804296717,53,0.1588537695312482,3), vec4(175.59479804296717,69,0.2343744140625006,1), vec4(175.76146429296716,62,0.1588537695312482,3), vec4(175.92813054296715,53,0.1588537695312482,3), vec4(175.92813054296715,65,0.2343744140625006,1), vec4(176.09479679296714,62,0.1588537695312482,3), vec4(176.26146304296714,52,0.1588537695312482,3), vec4(176.26146304296714,67,0.2343744140625006,1), vec4(176.42812929296713,58,0.1588537695312482,3), vec4(176.59479554296712,52,0.1588537695312482,3), vec4(176.59479554296712,61,0.2343744140625006,1), vec4(176.7614617929671,58,0.1588537695312482,3), vec4(176.9281280429671,52,0.1588537695312482,3), vec4(176.9281280429671,67,0.2343744140625006,1), vec4(177.0947942929671,58,0.1588537695312482,3), vec4(177.2614605429671,52,0.1588537695312482,3), vec4(177.2614605429671,61,0.2343744140625006,1), vec4(177.42812679296708,58,0.1588537695312482,3), vec4(177.59479304296707,50,0.1588537695312482,3), vec4(177.59479304296707,65,0.2343744140625006,1), vec4(177.76145929296706,57,0.1588537695312482,3), vec4(177.92812554296705,50,0.1588537695312482,3), vec4(177.92812554296705,62,0.2343744140625006,1), vec4(178.09479179296704,57,0.1588537695312482,3), vec4(178.26145804296704,50,0.1588537695312482,3), vec4(178.26145804296704,65,0.2343744140625006,1), vec4(178.42812429296703,57,0.1588537695312482,3), vec4(178.59479054296702,50,0.1588537695312482,3), vec4(178.59479054296702,62,0.2343744140625006,1), vec4(178.761456792967,57,0.1588537695312482,3), vec4(178.928123042967,52,0.1588537695312482,3), vec4(178.928123042967,64,0.2343744140625006,1), vec4(179.094789292967,55,0.1588537695312482,3), vec4(179.26145554296698,52,0.1588537695312482,3), vec4(179.26145554296698,58,0.2343744140625006,1), vec4(179.42812179296698,55,0.1588537695312482,3), vec4(179.59478804296697,52,0.1588537695312482,3), vec4(179.59478804296697,64,0.2343744140625006,1), vec4(179.76145429296696,55,0.1588537695312482,3), vec4(179.92812054296695,52,0.1588537695312482,3), vec4(179.92812054296695,58,0.2343744140625006,1), vec4(180.09478679296694,55,0.1588537695312482,3), vec4(180.26145304296693,57,0.3177075390624964,3), vec4(180.26145304296693,53,0.3177075390624964,3), vec4(180.42811929296693,81,0.1588537695312482,1), vec4(180.59478554296692,79,0.1588537695312482,1), vec4(180.59478554296692,57,0.3177075390624964,3), vec4(180.59478554296692,52,0.3177075390624964,3), vec4(180.7614517929669,81,0.1588537695312482,1), vec4(180.9281180429669,77,0.1588537695312482,1), vec4(180.9281180429669,57,0.3177075390624964,3), vec4(180.9281180429669,50,0.3177075390624964,3), vec4(181.0947842929669,81,0.1588537695312482,1), vec4(181.26145054296688,76,0.1588537695312482,1), vec4(181.26145054296688,57,0.3177075390624964,3), vec4(181.26145054296688,55,0.3177075390624964,3), vec4(181.42811679296688,81,0.1588537695312482,1), vec4(181.59478304296687,74,0.1588537695312482,1), vec4(181.59478304296687,57,0.3177075390624964,3), vec4(181.59478304296687,53,0.3177075390624964,3), vec4(181.76144929296686,81,0.1588537695312482,1), vec4(181.92811554296685,73,0.1588537695312482,1), vec4(181.92811554296685,57,0.3177075390624964,3), vec4(181.92811554296685,52,0.3177075390624964,3), vec4(182.09478179296684,81,0.1588537695312482,1), vec4(182.26144804296683,74,0.1588537695312482,1), vec4(182.26144804296683,57,0.3177075390624964,3), vec4(182.26144804296683,53,0.3177075390624964,3), vec4(182.42811429296682,81,0.1588537695312482,1), vec4(182.59478054296682,76,0.1588537695312482,1), vec4(182.59478054296682,57,0.3177075390624964,3), vec4(182.59478054296682,49,0.3177075390624964,3), vec4(182.7614467929668,81,0.1588537695312482,1), vec4(182.9281130429668,77,0.1588537695312482,1), vec4(182.9281130429668,57,0.3177075390624964,3), vec4(182.9281130429668,50,0.3177075390624964,3), vec4(183.0947792929668,81,0.1588537695312482,1), vec4(183.26144554296678,69,0.1588537695312482,1), vec4(183.26144554296678,57,0.3177075390624964,3), vec4(183.26144554296678,49,0.3177075390624964,3), vec4(183.42811179296677,81,0.1588537695312482,1), vec4(183.59477804296677,71,0.1588537695312482,1), vec4(183.59477804296677,57,0.3177075390624964,3), vec4(183.59477804296677,50,0.3177075390624964,3), vec4(183.76144429296676,81,0.1588537695312482,1), vec4(183.92811054296675,73,0.1588537695312482,1), vec4(183.92811054296675,57,0.3177075390624964,3), vec4(183.92811054296675,52,0.3177075390624964,3), vec4(184.09477679296674,81,0.1588537695312482,1), vec4(184.26144304296673,74,0.1588537695312482,1), vec4(184.26144304296673,57,0.3177075390624964,3), vec4(184.26144304296673,53,0.3177075390624964,3), vec4(184.42810929296672,81,0.1588537695312482,1), vec4(184.59477554296672,73,0.1588537695312482,1), vec4(184.59477554296672,57,0.3177075390624964,3), vec4(184.59477554296672,52,0.3177075390624964,3), vec4(184.7614417929667,81,0.1588537695312482,1), vec4(184.9281080429667,74,0.1588537695312482,1), vec4(184.9281080429667,57,0.3177075390624964,3), vec4(184.9281080429667,53,0.3177075390624964,3), vec4(185.0947742929667,81,0.1588537695312482,1), vec4(185.26144054296668,76,0.1588537695312482,1), vec4(185.26144054296668,57,0.3177075390624964,3), vec4(185.26144054296668,49,0.3177075390624964,3), vec4(185.42810679296667,81,0.1588537695312482,1), vec4(185.59477304296666,77,0.1588537695312482,1), vec4(185.76143929296666,81,0.1588537695312482,1), vec4(185.92810554296665,76,0.1588537695312482,1), vec4(185.59477304296666,57,0.6354150781249643,3), vec4(185.59477304296666,50,0.6354150781249643,3), vec4(186.09477179296664,81,0.1588537695312482,1), vec4(186.26143804296663,74,0.1588537695312482,1), vec4(186.42810429296662,81,0.1588537695312482,1), vec4(186.59477054296661,72,0.1588537695312482,1), vec4(186.26143804296663,62,0.6354150781249643,3), vec4(186.26143804296663,53,0.6354150781249643,3), vec4(186.7614367929666,81,0.1588537695312482,1), vec4(186.9281030429666,70,0.1588537695312482,1), vec4(187.0947692929666,81,0.1588537695312482,1), vec4(187.26143554296658,72,0.1588537695312482,1), vec4(186.9281030429666,62,0.6354150781249643,3), vec4(186.9281030429666,55,0.6354150781249643,3), vec4(187.42810179296657,81,0.1588537695312482,1), vec4(187.59476804296656,74,0.1588537695312482,1), vec4(187.76143429296656,79,0.1588537695312482,1), vec4(187.92810054296655,70,0.1588537695312482,1), vec4(188.09476679296654,79,0.1588537695312482,1), vec4(188.26143304296653,76,0.1588537695312482,1), vec4(188.42809929296652,79,0.1588537695312482,1), vec4(188.5947655429665,74,0.1588537695312482,1), vec4(188.26143304296653,60,0.6354150781249643,3), vec4(188.26143304296653,48,0.6354150781249643,3), vec4(188.7614317929665,79,0.1588537695312482,1), vec4(188.9280980429665,72,0.1588537695312482,1), vec4(189.0947642929665,79,0.1588537695312482,1), vec4(189.26143054296648,70,0.1588537695312482,1), vec4(188.9280980429665,60,0.6354150781249643,3), vec4(188.9280980429665,52,0.6354150781249643,3), vec4(189.42809679296647,79,0.1588537695312482,1), vec4(189.59476304296646,69,0.1588537695312482,1), vec4(189.76142929296645,79,0.1588537695312482,1), vec4(189.92809554296645,70,0.1588537695312482,1), vec4(189.59476304296646,60,0.6354150781249643,3), vec4(189.59476304296646,53,0.6354150781249643,3), vec4(190.09476179296644,79,0.1588537695312482,1), vec4(190.26142804296643,72,0.1588537695312482,1), vec4(190.42809429296642,77,0.1588537695312482,1), vec4(190.5947605429664,69,0.1588537695312482,1), vec4(190.7614267929664,77,0.1588537695312482,1), vec4(190.9280930429664,74,0.1588537695312482,1), vec4(191.0947592929664,77,0.1588537695312482,1), vec4(191.26142554296638,72,0.1588537695312482,1), vec4(190.9280930429664,58,0.6354150781249643,3), vec4(190.9280930429664,46,0.6354150781249643,3), vec4(191.42809179296637,77,0.1588537695312482,1), vec4(191.59475804296636,70,0.1588537695312482,1), vec4(191.76142429296635,77,0.1588537695312482,1), vec4(191.92809054296634,69,0.1588537695312482,1), vec4(191.59475804296636,58,0.6354150781249643,3), vec4(191.59475804296636,50,0.6354150781249643,3), vec4(192.09475679296634,77,0.1588537695312482,1), vec4(192.26142304296633,67,0.1588537695312482,1), vec4(192.42808929296632,77,0.1588537695312482,1), vec4(192.5947555429663,69,0.1588537695312482,1), vec4(192.26142304296633,58,0.6354150781249643,3), vec4(192.26142304296633,52,0.6354150781249643,3), vec4(192.7614217929663,77,0.1588537695312482,1), vec4(192.9280880429663,70,0.1588537695312482,1), vec4(193.0947542929663,76,0.1588537695312482,1), vec4(193.26142054296628,67,0.1588537695312482,1), vec4(193.42808679296627,76,0.1588537695312482,1), vec4(193.59475304296626,73,0.1588537695312482,1), vec4(193.76141929296625,76,0.1588537695312482,1), vec4(193.92808554296624,70,0.1588537695312482,1), vec4(193.59475304296626,57,0.6354150781249643,3), vec4(193.59475304296626,45,0.6354150781249643,3), vec4(194.09475179296624,76,0.1588537695312482,1), vec4(194.26141804296623,69,0.1588537695312482,1), vec4(194.42808429296622,76,0.1588537695312482,1), vec4(194.5947505429662,67,0.1588537695312482,1), vec4(194.26141804296623,57,0.6354150781249643,3), vec4(194.26141804296623,49,0.6354150781249643,3), vec4(194.7614167929662,76,0.1588537695312482,1), vec4(194.9280830429662,65,0.1588537695312482,1), vec4(195.09474929296618,76,0.1588537695312482,1), vec4(195.26141554296618,67,0.1588537695312482,1), vec4(194.9280830429662,57,0.6354150781249643,3), vec4(194.9280830429662,50,0.6354150781249643,3), vec4(195.42808179296617,76,0.1588537695312482,1), vec4(195.59474804296616,69,0.1588537695312482,1), vec4(195.76141429296615,74,0.1588537695312482,1), vec4(195.92808054296614,65,0.1588537695312482,1), vec4(195.92808054296614,62,0.3177075390624964,1), vec4(195.92808054296614,53,0.3177075390624964,3), vec4(196.09474679296613,74,0.1588537695312482,1), vec4(196.26141304296613,64,0.1588537695312482,1), vec4(196.26141304296613,61,0.3177075390624964,1), vec4(196.26141304296613,58,0.3177075390624964,3), vec4(196.42807929296612,76,0.1588537695312482,1), vec4(196.5947455429661,64,0.1588537695312482,1), vec4(196.5947455429661,61,0.3177075390624964,1), vec4(196.5947455429661,58,0.3177075390624964,3), vec4(196.7614117929661,76,0.1588537695312482,1), vec4(196.9280780429661,65,0.1588537695312482,1), vec4(196.9280780429661,62,0.3177075390624964,1), vec4(196.9280780429661,57,0.3177075390624964,3), vec4(197.09474429296608,74,0.1588537695312482,1), vec4(197.26141054296608,65,0.1588537695312482,1), vec4(197.26141054296608,62,0.3177075390624964,1), vec4(197.26141054296608,57,0.3177075390624964,3), vec4(197.42807679296607,74,0.1588537695312482,1), vec4(197.59474304296606,70,0.1588537695312482,1), vec4(197.76140929296605,73,0.1588537695312482,1), vec4(197.92807554296604,70,0.1588537695312482,1), vec4(197.59474304296606,64,0.6354150781249643,1), vec4(197.59474304296606,55,0.6354150781249643,3), vec4(198.09474179296603,73,0.1588537695312482,1), vec4(198.26140804296602,69,0.1588537695312482,1), vec4(198.42807429296602,74,0.1588537695312482,1), vec4(198.594740542966,65,0.1588537695312482,1), vec4(198.594740542966,62,0.3177075390624964,1), vec4(198.594740542966,57,0.3177075390624964,3), vec4(198.761406792966,74,0.1588537695312482,1), vec4(198.928073042966,64,0.1588537695312482,1), vec4(198.928073042966,61,0.3177075390624964,1), vec4(198.928073042966,58,0.3177075390624964,3), vec4(199.09473929296598,76,0.1588537695312482,1), vec4(199.26140554296597,64,0.1588537695312482,1), vec4(199.26140554296597,61,0.3177075390624964,1), vec4(199.26140554296597,58,0.3177075390624964,3), vec4(199.42807179296597,76,0.1588537695312482,1), vec4(199.59473804296596,65,0.1588537695312482,1), vec4(199.59473804296596,62,0.3177075390624964,1), vec4(199.59473804296596,57,0.3177075390624964,3), vec4(199.76140429296595,74,0.1588537695312482,1), vec4(199.92807054296594,65,0.1588537695312482,1), vec4(199.92807054296594,62,0.3177075390624964,1), vec4(199.92807054296594,57,0.3177075390624964,3), vec4(200.09473679296593,74,0.1588537695312482,1), vec4(200.42806929296592,74,0.1588537695312482,1), vec4(200.5947355429659,73,0.1588537695312482,1), vec4(200.26140304296592,64,0.6354150781249643,1), vec4(200.26140304296592,56,0.6354150781249643,3), vec4(200.7614017929659,74,0.1588537695312482,1), vec4(200.9280680429659,71,0.1588537695312482,1), vec4(201.09473429296588,74,0.1588537695312482,1), vec4(201.26140054296587,73,0.1588537695312482,1), vec4(201.42806679296586,71,0.1588537695312482,1), vec4(201.76139929296585,69,0.1588537695312482,1), vec4(201.92806554296584,67,0.1588537695312482,1), vec4(201.59473304296586,73,0.6354150781249643,1), vec4(201.59473304296586,57,0.6354150781249643,3), vec4(202.09473179296583,69,0.1588537695312482,1), vec4(202.26139804296582,64,0.1588537695312482,1), vec4(202.42806429296581,67,0.1588537695312482,1), vec4(202.5947305429658,65,0.1588537695312482,1), vec4(202.7613967929658,64,0.1588537695312482,1), vec4(203.09472929296578,74,0.1588537695312482,1), vec4(203.26139554296577,73,0.1588537695312482,1), vec4(202.9280630429658,65,0.6354150781249643,1), vec4(203.42806179296576,74,0.1588537695312482,1), vec4(203.59472804296576,77,0.1588537695312482,1), vec4(203.76139429296575,74,0.1588537695312482,1), vec4(203.92806054296574,73,0.1588537695312482,1), vec4(203.59472804296576,62,0.6354150781249643,1), vec4(204.09472679296573,71,0.1588537695312482,1), vec4(204.26139304296572,57,0.1588537695312482,1), vec4(204.4280592929657,69,0.1588537695312482,1), vec4(204.5947255429657,67,0.1588537695312482,1), vec4(204.26139304296572,73,0.6354150781249643,1), vec4(204.7613917929657,69,0.1588537695312482,1), vec4(204.9280580429657,61,0.1588537695312482,1), vec4(205.09472429296568,67,0.1588537695312482,1), vec4(205.26139054296567,65,0.1588537695312482,1), vec4(205.42805679296566,64,0.1588537695312482,1), vec4(204.9280580429657,76,0.9843725390624627,1), vec4(205.76138929296565,62,0.1588537695312482,3), vec4(205.92805554296564,61,0.1588537695312482,3), vec4(205.59472304296565,65,0.6354150781249643,1), vec4(206.09472179296563,62,0.1588537695312482,3), vec4(205.92805554296564,74,0.6510400390624795,1), vec4(206.4280542929656,57,0.1510412890625048,3), vec4(206.4280542929656,57,0.1588537695312482,3), vec4(206.5947205429656,55,0.1588537695312482,3), vec4(206.26138804296562,64,0.6354150781249643,1), vec4(206.5947205429656,73,0.31770753906246796,1), vec4(206.7613867929656,57,0.15885376953121977,3), vec4(206.92805304296556,54,0.1588537695312482,3), vec4(206.92805304296556,62,0.3177075390624964,1), vec4(207.09471929296555,62,0.1588537695312482,3), vec4(207.26138554296554,61,0.1588537695312482,3), vec4(206.92805304296556,72,0.6354150781249643,1), vec4(207.42805179296553,62,0.1588537695312482,3), vec4(207.59471804296552,55,0.1588537695312482,3), vec4(207.26138554296554,69,0.6510400390624795,1), vec4(207.76138429296552,65,0.1588537695312482,3), vec4(207.9280505429655,63,0.1588537695312482,3), vec4(207.59471804296552,70,0.6354150781249643,1), vec4(208.0947167929655,62,0.1588537695312482,3), vec4(208.2613830429655,61,0.1588537695312482,3), vec4(208.42804929296548,64,0.1588537695312482,3), vec4(208.59471554296547,57,0.1588537695312482,3), vec4(207.9280505429655,67,0.9687475781249475,1), vec4(208.2613830429655,69,0.6354150781249643,1), vec4(208.76138179296547,61,0.1588537695312482,3), vec4(208.92804804296546,50,0.1588537695312482,3), vec4(209.09471429296545,63,0.1588537695312482,3), vec4(209.26138054296544,62,0.1588537695312482,3), vec4(208.92804804296546,69,0.6354150781249643,1), vec4(208.92804804296546,66,0.6354150781249643,1), vec4(209.42804679296543,60,0.1588537695312482,3), vec4(209.59471304296542,59,0.1588537695312482,3), vec4(209.76137929296542,62,0.1588537695312482,3), vec4(209.9280455429654,55,0.1588537695312482,3), vec4(209.59471304296542,67,0.6354150781249643,1), vec4(209.59471304296542,65,0.6354150781249643,1), vec4(210.0947117929654,59,0.1588537695312482,3), vec4(210.2613780429654,48,0.1588537695312482,3), vec4(210.42804429296538,62,0.1588537695312482,3), vec4(210.59471054296537,60,0.1588537695312482,3), vec4(210.2613780429654,67,0.6354150781249643,1), vec4(210.76137679296536,58,0.1588537695312482,3), vec4(210.92804304296536,57,0.1588537695312482,3), vec4(210.2613780429654,63,0.9843725390624627,1), vec4(210.92804304296536,66,0.3177075390624964,1), vec4(211.09470929296535,60,0.1588537695312482,3), vec4(211.26137554296534,54,0.1588537695312482,3), vec4(211.26137554296534,62,0.3177075390624964,1), vec4(211.42804179296533,57,0.1588537695312482,3), vec4(211.59470804296532,50,0.1588537695312482,3), vec4(211.26137554296534,69,0.6354150781249643,1), vec4(211.59470804296532,66,0.31770753906246796,1), vec4(211.76137429296531,60,0.15885376953121977,3), vec4(211.92804054296528,58,0.1588537695312482,3), vec4(211.92804054296528,75,0.3177075390624964,1), vec4(212.09470679296527,57,0.1588537695312482,3), vec4(212.26137304296526,58,0.1588537695312482,3), vec4(211.92804054296528,72,0.6510400390624795,1), vec4(212.42803929296525,69,0.1588537695312482,3), vec4(212.59470554296524,70,0.1588537695312482,1), vec4(212.59470554296524,67,0.1588537695312482,3), vec4(212.26137304296526,74,0.6354150781249643,1), vec4(212.76137179296524,69,0.1588537695312482,1), vec4(212.76137179296524,66,0.1588537695312482,3), vec4(212.92803804296523,67,0.1588537695312482,3), vec4(212.92803804296523,70,0.3177075390624964,1), vec4(213.09470429296522,58,0.1588537695312482,3), vec4(213.2613705429652,57,0.1588537695312482,3), vec4(213.2613705429652,70,0.3177075390624964,1), vec4(213.4280367929652,55,0.1588537695312482,3), vec4(213.2613705429652,79,0.6510400390624795,1), vec4(213.76136929296518,38,0.1588537695312482,2), vec4(213.92803554296518,36,0.1588537695312482,2), vec4(213.5947030429652,69,0.6354150781249643,1), vec4(213.5947030429652,62,0.6354150781249643,3), vec4(213.92803554296518,78,0.31770753906246796,1), vec4(214.09470179296517,38,0.15885376953121977,2), vec4(214.26136804296513,34,0.1588537695312482,2), vec4(214.26136804296513,74,0.3177075390624964,1), vec4(214.42803429296512,38,0.1588537695312482,2), vec4(214.5947005429651,33,0.1588537695312482,2), vec4(214.26136804296513,79,0.6354150781249643,1), vec4(214.5947005429651,72,0.31770753906246796,1), vec4(214.5947005429651,62,0.31770753906246796,3), vec4(214.7613667929651,38,0.15885376953121977,2), vec4(214.92803304296507,31,0.1588537695312482,2), vec4(214.92803304296507,70,0.3177075390624964,1), vec4(214.92803304296507,62,0.3177075390624964,3), vec4(215.09469929296506,38,0.1588537695312482,2), vec4(215.26136554296505,30,0.1588537695312482,2), vec4(215.26136554296505,74,0.3177075390624964,1), vec4(215.26136554296505,69,0.3177075390624964,1), vec4(215.26136554296505,62,0.3177075390624964,3), vec4(215.42803179296504,38,0.1588537695312482,2), vec4(215.59469804296504,31,0.1588537695312482,2), vec4(215.59469804296504,74,0.3177075390624964,1), vec4(215.59469804296504,70,0.3177075390624964,1), vec4(215.59469804296504,62,0.3177075390624964,3), vec4(215.76136429296503,38,0.1588537695312482,2), vec4(215.92803054296502,33,0.1588537695312482,2), vec4(215.92803054296502,74,0.3177075390624964,1), vec4(215.92803054296502,66,0.3177075390624964,1), vec4(215.92803054296502,60,0.3177075390624964,3), vec4(216.094696792965,38,0.1588537695312482,2), vec4(216.261363042965,34,0.1588537695312482,2), vec4(216.261363042965,74,0.3177075390624964,1), vec4(216.261363042965,67,0.3177075390624964,1), vec4(216.261363042965,58,0.3177075390624964,3), vec4(216.428029292965,38,0.1588537695312482,2), vec4(216.59469554296498,26,0.1588537695312482,2), vec4(216.59469554296498,74,0.3177075390624964,1), vec4(216.59469554296498,66,0.3177075390624964,1), vec4(216.59469554296498,62,0.3177075390624964,3), vec4(216.76136179296498,38,0.1588537695312482,2), vec4(216.92802804296497,28,0.1588537695312482,2), vec4(216.92802804296497,74,0.3177075390624964,1), vec4(216.92802804296497,67,0.3177075390624964,1), vec4(216.92802804296497,62,0.3177075390624964,3), vec4(217.09469429296496,38,0.1588537695312482,2), vec4(217.26136054296495,30,0.1588537695312482,2), vec4(217.26136054296495,74,0.3177075390624964,1), vec4(217.26136054296495,69,0.3177075390624964,1), vec4(217.26136054296495,60,0.3177075390624964,3), vec4(217.42802679296494,38,0.1588537695312482,2), vec4(217.59469304296493,31,0.1588537695312482,2), vec4(217.59469304296493,74,0.3177075390624964,1), vec4(217.59469304296493,70,0.3177075390624964,1), vec4(217.59469304296493,58,0.3177075390624964,3), vec4(217.76135929296493,38,0.1588537695312482,2), vec4(217.92802554296492,30,0.1588537695312482,2), vec4(217.92802554296492,74,0.3177075390624964,1), vec4(217.92802554296492,69,0.3177075390624964,1), vec4(217.92802554296492,62,0.3177075390624964,3), vec4(218.0946917929649,38,0.1588537695312482,2), vec4(218.2613580429649,31,0.1588537695312482,2), vec4(218.2613580429649,74,0.3177075390624964,1), vec4(218.2613580429649,70,0.3177075390624964,1), vec4(218.2613580429649,62,0.3177075390624964,3), vec4(218.4280242929649,38,0.1588537695312482,2), vec4(218.59469054296488,33,0.1588537695312482,2), vec4(218.59469054296488,74,0.3177075390624964,1), vec4(218.59469054296488,66,0.3177075390624964,1), vec4(218.59469054296488,60,0.3177075390624964,3), vec4(218.76135679296488,38,0.1588537695312482,2), vec4(218.92802304296487,74,0.1588537695312482,1), vec4(218.92802304296487,67,0.1588537695312482,1), vec4(219.09468929296486,79,0.1588537695312482,1), vec4(219.09468929296486,70,0.1588537695312482,1), vec4(219.26135554296485,77,0.1588537695312482,1), vec4(219.26135554296485,69,0.1588537695312482,1), vec4(218.92802304296487,58,0.6354150781249643,3), vec4(218.92802304296487,34,0.6354150781249643,2), vec4(219.42802179296484,79,0.1588537695312482,1), vec4(219.42802179296484,70,0.1588537695312482,1), vec4(219.59468804296483,76,0.1588537695312482,1), vec4(219.59468804296483,67,0.1588537695312482,1), vec4(219.76135429296482,77,0.1588537695312482,1), vec4(219.76135429296482,69,0.1588537695312482,1), vec4(219.92802054296482,74,0.1588537695312482,1), vec4(219.92802054296482,65,0.1588537695312482,1), vec4(219.92802054296482,35,0.3177075390624964,2), vec4(220.0946867929648,76,0.1588537695312482,1), vec4(220.0946867929648,67,0.1588537695312482,1), vec4(220.2613530429648,72,0.1588537695312482,1), vec4(220.2613530429648,64,0.1588537695312482,1), vec4(220.4280192929648,81,0.1588537695312482,1), vec4(220.4280192929648,72,0.1588537695312482,1), vec4(220.59468554296478,79,0.1588537695312482,1), vec4(220.59468554296478,70,0.1588537695312482,1), vec4(220.2613530429648,36,0.6354150781249643,2), vec4(220.76135179296477,81,0.1588537695312482,1), vec4(220.76135179296477,72,0.1588537695312482,1), vec4(220.92801804296477,77,0.1588537695312482,1), vec4(220.92801804296477,69,0.1588537695312482,1), vec4(221.09468429296476,79,0.1588537695312482,1), vec4(221.09468429296476,70,0.1588537695312482,1), vec4(221.26135054296475,76,0.1588537695312482,1), vec4(221.26135054296475,67,0.1588537695312482,1), vec4(221.26135054296475,37,0.3177075390624964,2), vec4(221.42801679296474,77,0.1588537695312482,1), vec4(221.42801679296474,69,0.1588537695312482,1), vec4(221.59468304296473,74,0.1588537695312482,1), vec4(221.59468304296473,65,0.1588537695312482,1), vec4(221.76134929296472,82,0.1588537695312482,1), vec4(221.76134929296472,74,0.1588537695312482,1), vec4(221.92801554296472,81,0.1588537695312482,1), vec4(221.92801554296472,72,0.1588537695312482,1), vec4(221.59468304296473,38,0.6354150781249643,2), vec4(222.0946817929647,82,0.1588537695312482,1), vec4(222.0946817929647,74,0.1588537695312482,1), vec4(222.2613480429647,79,0.1588537695312482,1), vec4(222.2613480429647,70,0.1588537695312482,1), vec4(222.4280142929647,81,0.1588537695312482,1), vec4(222.4280142929647,72,0.1588537695312482,1), vec4(222.59468054296468,77,0.1588537695312482,1), vec4(222.59468054296468,69,0.1588537695312482,1), vec4(222.59468054296468,38,0.3177075390624964,2), vec4(222.76134679296467,79,0.1588537695312482,1), vec4(222.76134679296467,70,0.1588537695312482,1), vec4(222.92801304296466,76,0.1588537695312482,1), vec4(222.92801304296466,67,0.1588537695312482,1), vec4(223.09467929296466,84,0.1588537695312482,1), vec4(223.09467929296466,76,0.1588537695312482,1), vec4(223.26134554296465,82,0.1588537695312482,1), vec4(223.26134554296465,74,0.1588537695312482,1), vec4(222.92801304296466,40,0.6354150781249643,2), vec4(223.42801179296464,84,0.1588537695312482,1), vec4(223.42801179296464,76,0.1588537695312482,1), vec4(223.59467804296463,81,0.1588537695312482,1), vec4(223.59467804296463,72,0.1588537695312482,1), vec4(223.76134429296462,82,0.1588537695312482,1), vec4(223.76134429296462,74,0.1588537695312482,1), vec4(223.9280105429646,79,0.1588537695312482,1), vec4(223.9280105429646,70,0.1588537695312482,1), vec4(223.9280105429646,40,0.3177075390624964,2), vec4(224.0946767929646,81,0.1588537695312482,1), vec4(224.0946767929646,72,0.1588537695312482,1), vec4(224.2613430429646,77,0.1588537695312482,1), vec4(224.2613430429646,69,0.3177075390624964,1), vec4(224.2613430429646,41,0.3177075390624964,2), vec4(224.4280092929646,75,0.1588537695312482,1), vec4(224.59467554296458,74,0.1588537695312482,1), vec4(224.59467554296458,65,0.3177075390624964,1), vec4(224.59467554296458,33,0.3177075390624964,2), vec4(224.76134179296457,72,0.1588537695312482,1), vec4(224.92800804296456,74,0.1588537695312482,1), vec4(224.92800804296456,70,0.1588537695312482,1), vec4(224.92800804296456,34,0.3177075390624964,2), vec4(225.09467429296456,72,0.1588537695312482,1), vec4(225.09467429296456,69,0.1588537695312482,1), vec4(225.26134054296455,70,0.1588537695312482,1), vec4(225.26134054296455,67,0.1588537695312482,1), vec4(225.26134054296455,38,0.3177075390624964,2), vec4(225.42800679296454,69,0.1588537695312482,1), vec4(225.42800679296454,65,0.1588537695312482,1), vec4(225.59467304296453,70,0.1588537695312482,1), vec4(225.59467304296453,67,0.1588537695312482,1), vec4(225.76133929296452,74,0.1588537695312482,1), vec4(225.76133929296452,70,0.1588537695312482,1), vec4(225.9280055429645,70,0.1588537695312482,1), vec4(225.9280055429645,67,0.1588537695312482,1), vec4(225.59467304296453,31,0.6354150781249643,2), vec4(226.0946717929645,69,0.1588537695312482,1), vec4(226.0946717929645,65,0.1588537695312482,1), vec4(226.2613380429645,67,0.1588537695312482,1), vec4(226.2613380429645,64,0.1588537695312482,1), vec4(226.4280042929645,70,0.1588537695312482,1), vec4(226.4280042929645,67,0.1588537695312482,1), vec4(226.59467054296448,67,0.1588537695312482,1), vec4(226.59467054296448,64,0.1588537695312482,1), vec4(226.76133679296447,65,0.1588537695312482,1), vec4(226.76133679296447,62,0.1588537695312482,1), vec4(226.92800304296446,64,0.1588537695312482,1), vec4(226.92800304296446,60,0.1588537695312482,1), vec4(226.59467054296448,34,0.6510400390624795,2), vec4(227.09466929296445,65,0.1588537695312482,1), vec4(227.09466929296445,62,0.1588537695312482,1), vec4(227.26133554296445,67,0.1588537695312482,1), vec4(227.26133554296445,64,0.1588537695312482,1), vec4(227.26133554296445,33,0.3177075390624964,2), vec4(227.42800179296444,69,0.1588537695312482,1), vec4(227.42800179296444,65,0.1588537695312482,1), vec4(227.59466804296443,70,0.1588537695312482,1), vec4(227.59466804296443,67,0.3177075390624964,1), vec4(227.59466804296443,31,0.3177075390624964,2), vec4(227.76133429296442,74,0.1588537695312482,1), vec4(227.9280005429644,72,0.1588537695312482,1), vec4(227.9280005429644,64,0.3177075390624964,1), vec4(227.9280005429644,36,0.3177075390624964,2), vec4(228.0946667929644,70,0.1588537695312482,1), vec4(228.4279992929644,60,0.1588537695312482,3), vec4(228.59466554296438,58,0.1588537695312482,3), vec4(228.2613330429644,69,0.6354150781249643,1), vec4(228.2613330429644,65,0.6354150781249643,1), vec4(228.2613330429644,29,0.6354150781249643,2), vec4(228.76133179296437,60,0.1588537695312482,3), vec4(228.92799804296436,57,0.1588537695312482,3), vec4(228.92799804296436,72,0.3177075390624964,1), vec4(229.09466429296435,60,0.1588537695312482,3), vec4(229.26133054296434,55,0.1588537695312482,3), vec4(229.26133054296434,70,0.3177075390624964,1), vec4(229.42799679296434,60,0.1588537695312482,3), vec4(229.59466304296433,53,0.1588537695312482,3), vec4(229.59466304296433,69,0.3177075390624964,1), vec4(229.76132929296432,60,0.1588537695312482,3), vec4(229.9279955429643,52,0.1588537695312482,3), vec4(229.9279955429643,67,0.3177075390624964,1), vec4(230.0946617929643,60,0.1588537695312482,3), vec4(230.2613280429643,53,0.1588537695312482,3), vec4(230.2613280429643,69,0.3177075390624964,1), vec4(230.42799429296429,60,0.1588537695312482,3), vec4(230.59466054296428,55,0.1588537695312482,3), vec4(230.59466054296428,70,0.3177075390624964,1), vec4(230.76132679296427,60,0.1588537695312482,3), vec4(230.92799304296426,57,0.1588537695312482,3), vec4(230.92799304296426,72,0.3177075390624964,1), vec4(231.09465929296425,60,0.1588537695312482,3), vec4(231.26132554296424,48,0.1588537695312482,3), vec4(231.26132554296424,64,0.3177075390624964,1), vec4(231.42799179296424,60,0.1588537695312482,3), vec4(231.59465804296423,50,0.1588537695312482,3), vec4(231.59465804296423,65,0.3177075390624964,1), vec4(231.76132429296422,60,0.1588537695312482,3), vec4(231.9279905429642,52,0.1588537695312482,3), vec4(231.9279905429642,67,0.3177075390624964,1), vec4(232.0946567929642,60,0.1588537695312482,3), vec4(232.2613230429642,53,0.1588537695312482,3), vec4(232.2613230429642,69,0.3177075390624964,1), vec4(232.42798929296418,60,0.1588537695312482,3), vec4(232.59465554296418,52,0.1588537695312482,3), vec4(232.59465554296418,67,0.3177075390624964,1), vec4(232.76132179296417,60,0.1588537695312482,3), vec4(232.92798804296416,53,0.1588537695312482,3), vec4(232.92798804296416,69,0.3177075390624964,1), vec4(233.09465429296415,60,0.1588537695312482,3), vec4(233.26132054296414,55,0.1588537695312482,3), vec4(233.26132054296414,70,0.3177075390624964,1), vec4(233.42798679296413,60,0.1588537695312482,3), vec4(233.59465304296413,72,0.1588537695312482,1), vec4(233.76131929296412,70,0.1588537695312482,1), vec4(233.9279855429641,69,0.1588537695312482,1), vec4(233.59465304296413,57,0.6354150781249643,3), vec4(234.0946517929641,67,0.1588537695312482,1), vec4(234.2613180429641,65,0.1588537695312482,1), vec4(234.42798429296408,63,0.1588537695312482,1), vec4(234.59465054296408,62,0.1588537695312482,1), vec4(234.76131679296407,60,0.1588537695312482,1), vec4(234.92798304296406,74,0.1588537695312482,1), vec4(234.92798304296406,58,0.3177075390624964,1), vec4(235.09464929296405,72,0.1588537695312482,1), vec4(235.26131554296404,70,0.1588537695312482,1), vec4(235.42798179296403,69,0.1588537695312482,1), vec4(235.59464804296402,67,0.1588537695312482,1), vec4(235.76131429296402,65,0.1588537695312482,1), vec4(235.927980542964,64,0.1588537695312482,1), vec4(236.094646792964,62,0.1588537695312482,1), vec4(236.261313042964,76,0.1588537695312482,1), vec4(236.261313042964,60,0.3177075390624964,1), vec4(236.42797929296398,74,0.1588537695312482,1), vec4(236.59464554296397,72,0.1588537695312482,1), vec4(236.76131179296397,70,0.1588537695312482,1), vec4(236.92797804296396,69,0.1588537695312482,1), vec4(237.09464429296395,67,0.1588537695312482,1), vec4(237.26131054296394,65,0.1588537695312482,1), vec4(237.42797679296393,64,0.1588537695312482,1), vec4(237.59464304296392,77,0.1588537695312482,1), vec4(237.59464304296392,62,0.3177075390624964,1), vec4(237.76130929296392,76,0.1588537695312482,1), vec4(237.9279755429639,74,0.1588537695312482,1), vec4(238.0946417929639,72,0.1588537695312482,1), vec4(238.2613080429639,70,0.1588537695312482,1), vec4(238.42797429296388,69,0.1588537695312482,1), vec4(238.59464054296387,67,0.1588537695312482,1), vec4(238.76130679296386,65,0.1588537695312482,1), vec4(238.92797304296386,79,0.1588537695312482,1), vec4(238.92797304296386,64,0.3177075390624964,1), vec4(239.09463929296385,77,0.1588537695312482,1), vec4(239.26130554296384,76,0.1588537695312482,1), vec4(239.42797179296383,74,0.1588537695312482,1), vec4(239.59463804296382,72,0.1588537695312482,1), vec4(239.7613042929638,70,0.1588537695312482,1), vec4(239.9279705429638,69,0.1588537695312482,1), vec4(240.0946367929638,67,0.1588537695312482,1), vec4(240.2613030429638,81,0.1588537695312482,1), vec4(240.2613030429638,65,0.3177075390624964,1), vec4(240.42796929296378,77,0.1588537695312482,1), vec4(240.59463554296377,76,0.1588537695312482,1), vec4(240.76130179296376,77,0.1588537695312482,1), vec4(240.92796804296376,72,0.3177075390624964,1), vec4(241.09463429296375,77,0.1588537695312482,1), vec4(241.26130054296374,76,0.1588537695312482,1), vec4(241.42796679296373,77,0.1588537695312482,1), vec4(241.59463304296372,81,0.1588537695312482,1), vec4(241.59463304296372,65,0.3177075390624964,1), vec4(241.7612992929637,77,0.1588537695312482,1), vec4(241.9279655429637,76,0.1588537695312482,1), vec4(242.0946317929637,77,0.1588537695312482,1), vec4(242.2612980429637,72,0.3177075390624964,1), vec4(242.42796429296368,77,0.1588537695312482,1), vec4(242.59463054296367,76,0.1588537695312482,1), vec4(242.76129679296366,77,0.1588537695312482,1), vec4(242.92796304296365,79,0.1588537695312482,1), vec4(242.92796304296365,64,0.3177075390624964,1), vec4(243.09462929296365,76,0.1588537695312482,1), vec4(243.26129554296364,74,0.1588537695312482,1), vec4(243.42796179296363,76,0.1588537695312482,1), vec4(243.59462804296362,72,0.3177075390624964,1), vec4(243.7612942929636,76,0.1588537695312482,1), vec4(243.9279605429636,74,0.1588537695312482,1), vec4(244.0946267929636,76,0.1588537695312482,1), vec4(244.2612930429636,79,0.1588537695312482,1), vec4(244.2612930429636,64,0.3177075390624964,1), vec4(244.42795929296358,76,0.1588537695312482,1), vec4(244.59462554296357,74,0.1588537695312482,1), vec4(244.76129179296356,76,0.1588537695312482,1), vec4(244.92795804296355,72,0.3177075390624964,1), vec4(245.09462429296354,76,0.1588537695312482,1), vec4(245.26129054296354,74,0.1588537695312482,1), vec4(245.42795679296353,76,0.1588537695312482,1), vec4(245.59462304296352,81,0.1588537695312482,0), vec4(245.59462304296352,65,0.3177075390624964,0), vec4(245.7612892929635,77,0.1588537695312482,0), vec4(245.9279555429635,76,0.1588537695312482,0), vec4(246.0946217929635,77,0.1588537695312482,0), vec4(246.26128804296349,72,0.3177075390624964,0), vec4(246.42795429296348,77,0.1588537695312482,0), vec4(246.59462054296347,76,0.1588537695312482,0), vec4(246.76128679296346,77,0.1588537695312482,0), vec4(246.92795304296345,81,0.1588537695312482,0), vec4(246.92795304296345,65,0.3177075390624964,0), vec4(247.09461929296344,77,0.1588537695312482,0), vec4(247.26128554296344,76,0.1588537695312482,0), vec4(247.42795179296343,77,0.1588537695312482,0), vec4(247.59461804296342,72,0.3177075390624964,0), vec4(247.7612842929634,77,0.1588537695312482,0), vec4(247.9279505429634,76,0.1588537695312482,0), vec4(248.0946167929634,77,0.1588537695312482,0), vec4(248.26128304296338,79,0.1588537695312482,0), vec4(248.26128304296338,64,0.3177075390624964,0), vec4(248.42794929296338,76,0.1588537695312482,0), vec4(248.59461554296337,74,0.1588537695312482,0), vec4(248.76128179296336,76,0.1588537695312482,0), vec4(248.92794804296335,72,0.3177075390624964,0), vec4(249.09461429296334,76,0.1588537695312482,0), vec4(249.26128054296333,74,0.1588537695312482,0), vec4(249.42794679296333,76,0.1588537695312482,0), vec4(249.59461304296332,79,0.1588537695312482,0), vec4(249.59461304296332,64,0.3177075390624964,0), vec4(249.7612792929633,76,0.1588537695312482,0), vec4(249.9279455429633,74,0.1588537695312482,0), vec4(250.0946117929633,76,0.1588537695312482,0), vec4(250.26127804296328,72,0.3177075390624964,0), vec4(250.42794429296328,76,0.1588537695312482,0), vec4(250.59461054296327,74,0.1588537695312482,0), vec4(250.76127679296326,76,0.1588537695312482,0), vec4(250.92794304296325,77,0.1588537695312482,1), vec4(250.92794304296325,62,0.3177075390624964,1), vec4(251.09460929296324,79,0.1588537695312482,1), vec4(251.26127554296323,77,0.1588537695312482,1), vec4(251.42794179296322,76,0.1588537695312482,1), vec4(251.59460804296322,74,0.1588537695312482,1), vec4(251.7612742929632,72,0.1588537695312482,1), vec4(251.9279405429632,71,0.1588537695312482,1), vec4(252.0946067929632,69,0.1588537695312482,1), vec4(252.26127304296318,71,0.1588537695312482,1), vec4(252.42793929296317,67,0.1588537695312482,1), vec4(252.59460554296317,71,0.1588537695312482,1), vec4(252.76127179296316,74,0.1588537695312482,1), vec4(252.92793804296315,77,0.1588537695312482,1), vec4(253.09460429296314,81,0.1588537695312482,1), vec4(253.26127054296313,77,0.1588537695312482,1), vec4(253.42793679296312,74,0.1588537695312482,1), vec4(253.59460304296312,71,0.1588537695312482,0), vec4(253.7612692929631,67,0.1588537695312482,0), vec4(253.9279355429631,71,0.1588537695312482,0), vec4(254.0946017929631,74,0.1588537695312482,0), vec4(254.26126804296308,77,0.1588537695312482,0), vec4(254.42793429296307,81,0.1588537695312482,0), vec4(254.59460054296306,77,0.1588537695312482,0), vec4(254.76126679296306,74,0.1588537695312482,0), vec4(254.92793304296305,70,0.1588537695312482,1), vec4(255.09459929296304,67,0.1588537695312482,1), vec4(255.26126554296303,70,0.1588537695312482,1), vec4(255.42793179296302,72,0.1588537695312482,1), vec4(255.594598042963,76,0.1588537695312482,1), vec4(255.761264292963,79,0.1588537695312482,1), vec4(255.927930542963,76,0.1588537695312766,1), vec4(256.09459679296305,72,0.1588537695312766,1), vec4(256.2612630429631,70,0.1588537695312766,0), vec4(256.42792929296314,67,0.1588537695312766,0), vec4(256.5945955429632,70,0.1588537695312766,0), vec4(256.76126179296324,72,0.1588537695312766,0), vec4(256.9279280429633,76,0.1588537695312766,0), vec4(257.09459429296334,79,0.1588537695312766,0), vec4(257.2612605429634,76,0.1588537695312766,0), vec4(257.42792679296343,72,0.1588537695312766,0), vec4(257.5945930429635,69,0.1588537695312766,1), vec4(257.76125929296353,65,0.1588537695312766,1), vec4(257.9279255429636,69,0.1588537695312766,1), vec4(258.0945917929636,72,0.1588537695312766,1), vec4(258.2612580429637,74,0.1588537695312766,1), vec4(258.4279242929637,77,0.1588537695312766,1), vec4(258.5945905429638,74,0.1588537695312766,1), vec4(258.7612567929638,70,0.1588537695312766,1), vec4(258.92792304296387,69,0.1588537695312766,0), vec4(259.0945892929639,65,0.1588537695312766,0), vec4(259.26125554296397,69,0.1588537695312766,0), vec4(259.427921792964,70,0.1588537695312766,0), vec4(259.59458804296406,74,0.1588537695312766,0), vec4(259.7612542929641,77,0.1588537695312766,0), vec4(259.92792054296416,74,0.1588537695312766,0), vec4(260.0945867929642,70,0.1588537695312766,0), vec4(260.26125304296426,67,0.1588537695312766,1), vec4(260.4279192929643,64,0.1588537695312766,1), vec4(260.59458554296435,67,0.1588537695312766,1), vec4(260.7612517929644,70,0.1588537695312766,1), vec4(260.92791804296445,73,0.1588537695312766,1), vec4(261.0945842929645,76,0.1588537695312766,1), vec4(261.26125054296455,73,0.1588537695312766,1), vec4(261.4279167929646,70,0.1588537695312766,1), vec4(261.59458304296464,67,0.1588537695312766,0), vec4(261.7612492929647,64,0.1588537695312766,0), vec4(261.92791554296474,67,0.1588537695312766,0), vec4(262.0945817929648,70,0.1588537695312766,0), vec4(262.26124804296484,73,0.1588537695312766,0), vec4(262.4279142929649,76,0.1588537695312766,0), vec4(262.59458054296493,73,0.1588537695312766,0), vec4(262.761246792965,70,0.1588537695312766,0), vec4(262.92791304296503,69,0.3177075390624964,1), vec4(263.094579292965,81,0.1588537695312766,1), vec4(263.26124554296507,79,0.1588537695312766,1), vec4(263.26124554296507,73,0.3177075390625532,1), vec4(263.4279117929651,81,0.1588537695312766,1), vec4(263.59457804296517,77,0.1588537695312766,1), vec4(263.59457804296517,74,0.3177075390625532,1), vec4(263.7612442929652,81,0.1588537695312766,1), vec4(263.92791054296526,76,0.1588537695312766,1), vec4(263.92791054296526,67,0.3177075390625532,1), vec4(264.0945767929653,81,0.1588537695312766,1), vec4(264.26124304296536,74,0.1588537695312766,1), vec4(264.26124304296536,65,0.3177075390625532,1), vec4(264.4279092929654,81,0.1588537695312766,1), vec4(264.59457554296546,73,0.1588537695312766,1), vec4(264.59457554296546,69,0.3177075390625532,1), vec4(264.7612417929655,81,0.1588537695312766,1), vec4(264.92790804296556,74,0.1588537695312766,1), vec4(264.92790804296556,71,0.3177075390625532,1), vec4(265.0945742929656,81,0.1588537695312766,1), vec4(265.26124054296565,76,0.1588537695312766,1), vec4(265.26124054296565,73,0.3177075390625532,1), vec4(265.4279067929657,81,0.1588537695312766,1), vec4(265.59457304296575,77,0.1588537695312766,1), vec4(265.59457304296575,74,0.3177075390625532,1), vec4(265.7612392929658,81,0.1588537695312766,1), vec4(265.92790554296585,69,0.1588537695312766,1), vec4(265.92790554296585,73,0.3177075390625532,1), vec4(266.0945717929659,81,0.1588537695312766,1), vec4(266.26123804296594,71,0.1588537695312766,1), vec4(266.26123804296594,74,0.3177075390625532,1), vec4(266.427904292966,81,0.1588537695312766,1), vec4(266.59457054296604,73,0.1588537695312766,1), vec4(266.59457054296604,76,0.3177075390625532,1), vec4(266.7612367929661,81,0.1588537695312766,1), vec4(266.92790304296614,77,0.1588537695312766,1), vec4(266.92790304296614,74,0.3177075390625532,1), vec4(267.0945692929662,81,0.1588537695312766,1), vec4(267.26123554296623,76,0.1588537695312766,1), vec4(267.26123554296623,73,0.3177075390625532,1), vec4(267.4279017929663,81,0.1588537695312766,1), vec4(267.59456804296633,77,0.3177075390624964,1), vec4(267.59456804296633,74,0.3177075390624964,1), vec4(267.7612342929663,69,0.1588537695312766,1), vec4(267.92790054296637,67,0.1588537695312766,1), vec4(267.92790054296637,76,0.3177075390625532,1), vec4(267.92790054296637,73,0.3177075390625532,1), vec4(268.0945667929664,69,0.1588537695312766,1), vec4(268.26123304296647,74,0.3177075390624964,1), vec4(268.42789929296646,66,0.1588537695312766,1), vec4(268.5945655429665,64,0.1588537695312766,1), vec4(268.5945655429665,72,0.3177075390625532,1), vec4(268.5945655429665,69,0.3177075390625532,1), vec4(268.76123179296656,66,0.1588537695312766,1), vec4(268.9278980429666,70,0.3177075390624964,1), vec4(268.9278980429666,67,0.3177075390624964,1), vec4(269.0945642929666,62,0.1588537695312766,3), vec4(269.26123054296664,60,0.1588537695312766,3), vec4(269.26123054296664,69,0.3177075390625532,1), vec4(269.26123054296664,66,0.3177075390625532,1), vec4(269.4278967929667,62,0.1588537695312766,3), vec4(269.59456304296674,70,0.1588537695312766,1), vec4(269.59456304296674,58,0.1588537695312766,3), vec4(269.59456304296674,67,0.3177075390625532,1), vec4(269.7612292929668,69,0.1588537695312766,1), vec4(269.7612292929668,60,0.1588537695312766,3), vec4(269.92789554296684,67,0.1588537695312766,1), vec4(269.92789554296684,58,0.1588537695312766,3), vec4(270.0945617929669,65,0.1588537695312766,1), vec4(270.0945617929669,57,0.1588537695312766,3), vec4(270.26122804296693,64,0.1588537695312766,1), vec4(270.26122804296693,55,0.1588537695312766,3), vec4(270.427894292967,62,0.1588537695312766,1), vec4(270.427894292967,53,0.1588537695312766,3), vec4(270.59456054296703,61,0.1588537695312766,1), vec4(270.59456054296703,52,0.1588537695312766,3), vec4(270.7612267929671,59,0.1588537695312766,1), vec4(270.7612267929671,50,0.1588537695312766,3), vec4(270.9278930429671,57,0.1588537695312766,3), vec4(270.9278930429671,49,0.1588537695312766,3), vec4(271.0945592929672,45,0.1588537695312766,3), vec4(271.2612255429672,49,0.1588537695312766,3), vec4(271.4278917929673,52,0.1588537695312766,3), vec4(271.5945580429673,55,0.1588537695312766,3), vec4(271.76122429296737,58,0.1588537695312766,3), vec4(271.9278905429674,55,0.1588537695312766,3), vec4(272.09455679296747,52,0.1588537695312766,3), vec4(272.2612230429675,49,0.1588537695312766,0), vec4(272.42788929296756,45,0.1588537695312766,0), vec4(272.5945555429676,49,0.1588537695312766,0), vec4(272.76122179296766,52,0.1588537695312766,0), vec4(272.9278880429677,55,0.1588537695312766,0), vec4(273.09455429296776,58,0.1588537695312766,0), vec4(273.2612205429678,55,0.1588537695312766,0), vec4(273.42788679296785,52,0.1588537695312766,0), vec4(273.5945530429679,50,0.1588537695312766,3), vec4(273.76121929296795,45,0.1588537695312766,3), vec4(273.927885542968,50,0.1588537695312766,3), vec4(274.09455179296805,53,0.1588537695312766,3), vec4(274.2612180429681,57,0.1588537695312766,3), vec4(274.42788429296814,62,0.1588537695312766,3), vec4(274.5945505429682,57,0.1588537695312766,3), vec4(274.76121679296824,53,0.1588537695312766,3), vec4(274.9278830429683,50,0.1588537695312766,0), vec4(275.09454929296834,45,0.1588537695312766,0), vec4(275.2612155429684,50,0.1588537695312766,0), vec4(275.42788179296844,53,0.1588537695312766,0), vec4(275.5945480429685,57,0.1588537695312766,0), vec4(275.76121429296853,62,0.1588537695312766,0), vec4(275.9278805429686,57,0.1588537695312766,0), vec4(276.09454679296863,53,0.1588537695312766,0), vec4(276.2612130429687,49,0.1588537695312766,3), vec4(276.4278792929687,45,0.1588537695312766,3), vec4(276.5945455429688,49,0.1588537695312766,3), vec4(276.7612117929688,52,0.1588537695312766,3), vec4(276.92787804296887,55,0.1588537695312766,3), vec4(277.0945442929689,58,0.1588537695312766,3), vec4(277.26121054296897,55,0.1588537695312766,3), vec4(277.427876792969,52,0.1588537695312766,3), vec4(277.59454304296906,49,0.1588537695312766,0), vec4(277.7612092929691,45,0.1588537695312766,0), vec4(277.92787554296916,49,0.1588537695312766,0), vec4(278.0945417929692,52,0.1588537695312766,0), vec4(278.26120804296926,55,0.1588537695312766,0), vec4(278.4278742929693,58,0.1588537695312766,0), vec4(278.59454054296936,55,0.1588537695312766,0), vec4(278.7612067929694,52,0.1588537695312766,0));\n    const vec4 v_2[1024] = vec4[](vec4(278.92787304296945,50,0.1588537695312766,3), vec4(279.0945392929695,45,0.1588537695312766,3), vec4(279.26120554296955,50,0.1588537695312766,3), vec4(279.4278717929696,53,0.1588537695312766,3), vec4(279.59453804296965,57,0.1588537695312766,3), vec4(279.7612042929697,62,0.1588537695312766,3), vec4(279.92787054296974,57,0.1588537695312766,3), vec4(280.0945367929698,53,0.1588537695312766,3), vec4(280.26120304296984,50,0.1588537695312766,0), vec4(280.4278692929699,45,0.1588537695312766,0), vec4(280.59453554296994,50,0.1588537695312766,0), vec4(280.76120179297,53,0.1588537695312766,0), vec4(280.92786804297003,57,0.1588537695312766,0), vec4(281.0945342929701,62,0.1588537695312766,0), vec4(281.26120054297013,57,0.1588537695312766,0), vec4(281.4278667929702,53,0.1588537695312766,0), vec4(281.5945330429702,52,0.1588537695312766,3), vec4(281.7611992929703,49,0.1588537695312766,3), vec4(281.9278655429703,52,0.1588537695312766,3), vec4(282.0945317929704,55,0.1588537695312766,3), vec4(282.2611980429704,58,0.1588537695312766,3), vec4(282.42786429297047,61,0.1588537695312766,3), vec4(282.5945305429705,58,0.1588537695312766,3), vec4(282.76119679297057,55,0.1588537695312766,3), vec4(282.9278630429706,52,0.1588537695312766,0), vec4(283.09452929297066,49,0.1588537695312766,0), vec4(283.2611955429707,52,0.1588537695312766,0), vec4(283.42786179297076,55,0.1588537695312766,0), vec4(283.5945280429708,58,0.1588537695312766,0), vec4(283.76119429297086,61,0.1588537695312766,0), vec4(283.9278605429709,58,0.1588537695312766,0), vec4(284.09452679297095,55,0.1588537695312766,0), vec4(284.261193042971,53,0.1588537695312766,3), vec4(284.42785929297105,50,0.1588537695312766,3), vec4(284.5945255429711,53,0.1588537695312766,3), vec4(284.76119179297115,57,0.1588537695312766,3), vec4(284.9278580429712,62,0.1588537695312766,1), vec4(285.09452429297124,65,0.1588537695312766,1), vec4(285.2611905429713,62,0.1588537695312766,1), vec4(285.42785679297134,57,0.1588537695312766,1), vec4(285.5945230429714,53,0.1588537695312766,0), vec4(285.76118929297144,50,0.1588537695312766,0), vec4(285.9278555429715,53,0.1588537695312766,0), vec4(286.09452179297153,57,0.1588537695312766,0), vec4(286.2611880429716,62,0.1588537695312766,0), vec4(286.42785429297163,65,0.1588537695312766,0), vec4(286.5945205429717,62,0.1588537695312766,0), vec4(286.7611867929717,57,0.1588537695312766,0), vec4(286.9278530429718,52,0.1588537695312766,3), vec4(287.0945192929718,49,0.1588537695312766,3), vec4(287.2611855429719,52,0.1588537695312766,3), vec4(287.4278517929719,55,0.1588537695312766,3), vec4(287.59451804297197,58,0.1588537695312766,3), vec4(287.761184292972,61,0.1588537695312766,3), vec4(287.92785054297207,58,0.1588537695312766,3), vec4(288.0945167929721,55,0.1588537695312766,3), vec4(288.26118304297216,52,0.1588537695312766,0), vec4(288.4278492929722,49,0.1588537695312766,0), vec4(288.59451554297226,52,0.1588537695312766,0), vec4(288.7611817929723,55,0.1588537695312766,0), vec4(288.92784804297236,58,0.1588537695312766,0), vec4(289.0945142929724,61,0.1588537695312766,0), vec4(289.26118054297245,58,0.1588537695312766,0), vec4(289.4278467929725,55,0.1588537695312766,0), vec4(289.59451304297255,53,0.1588537695312766,3), vec4(289.7611792929726,50,0.1588537695312766,3), vec4(289.92784554297265,53,0.1588537695312766,3), vec4(290.0945117929727,57,0.1588537695312766,3), vec4(290.26117804297274,62,0.1588537695312766,1), vec4(290.4278442929728,65,0.1588537695312766,1), vec4(290.59451054297284,62,0.1588537695312766,1), vec4(290.7611767929729,57,0.1588537695312766,1), vec4(290.92784304297294,53,0.1588537695312766,0), vec4(291.094509292973,50,0.1588537695312766,0), vec4(291.26117554297304,53,0.1588537695312766,0), vec4(291.4278417929731,57,0.1588537695312766,0), vec4(291.59450804297313,62,0.1588537695312766,0), vec4(291.7611742929732,65,0.1588537695312766,0), vec4(291.92784054297323,62,0.1588537695312766,0), vec4(292.0945067929733,57,0.1588537695312766,0), vec4(292.2611730429733,55,0.1588537695312766,3), vec4(292.4278392929734,52,0.1588537695312766,3), vec4(292.5945055429734,55,0.1588537695312766,3), vec4(292.76117179297347,58,0.1588537695312766,3), vec4(292.9278380429735,61,0.1588537695312766,1), vec4(293.09450429297357,64,0.1588537695312766,1), vec4(293.2611705429736,61,0.1588537695312766,1), vec4(293.42783679297366,58,0.1588537695312766,1), vec4(293.5945030429737,55,0.1588537695312766,0), vec4(293.76116929297376,52,0.1588537695312766,0), vec4(293.9278355429738,55,0.1588537695312766,0), vec4(294.09450179297386,58,0.1588537695312766,0), vec4(294.2611680429739,61,0.1588537695312766,0), vec4(294.42783429297396,64,0.1588537695312766,0), vec4(294.594500542974,61,0.1588537695312766,0), vec4(294.76116679297405,58,0.1588537695312766,0), vec4(294.9278330429741,57,0.1588537695312766,3), vec4(295.09449929297415,53,0.1588537695312766,3), vec4(295.2611655429742,57,0.1588537695312766,3), vec4(295.42783179297425,61,0.1588537695312766,3), vec4(295.5944980429743,62,0.1588537695312766,1), vec4(295.76116429297434,65,0.1588537695312766,1), vec4(295.9278305429744,62,0.1588537695312766,1), vec4(296.09449679297444,57,0.1588537695312766,3), vec4(296.2611630429745,58,0.1588537695312766,3), vec4(296.42782929297454,62,0.1588537695312766,1), vec4(296.5944955429746,58,0.1588537695312766,1), vec4(296.76116179297463,55,0.1588537695312766,3), vec4(296.9278280429747,53,0.1588537695312766,3), vec4(297.09449429297473,57,0.1588537695312766,3), vec4(297.2611605429748,53,0.1588537695312766,3), vec4(297.4278267929748,50,0.1588537695312766,3), vec4(297.5944930429749,45,0.1588537695312766,3), vec4(297.7611592929749,50,0.1588537695312766,3), vec4(297.927825542975,45,0.1588537695312766,3), vec4(298.094491792975,41,0.1588537695312766,3), vec4(298.26115804297507,38,0.1588537695312766,3), vec4(298.4278242929751,50,0.1588537695312766,3), vec4(298.59449054297517,49,0.1588537695312766,3), vec4(298.7611567929752,47,0.1588537695312766,3), vec4(298.92782304297526,49,0.1588537695312766,3), vec4(299.0944892929753,58,0.1588537695312766,3), vec4(299.26115554297536,57,0.1588537695312766,3), vec4(299.4278217929754,55,0.1588537695312766,3), vec4(299.59448804297546,53,0.1588537695312766,3), vec4(299.7611542929755,55,0.1588537695312766,3), vec4(299.92782054297555,53,0.1588537695312766,3), vec4(300.0944867929756,52,0.1588537695312766,3), vec4(300.26115304297565,50,0.1588537695312766,3), vec4(300.4278192929757,58,0.1588537695312766,3), vec4(300.59448554297575,57,0.1588537695312766,3), vec4(300.7611517929758,55,0.1588537695312766,3), vec4(300.92781804297584,53,0.1588537695312766,3), vec4(301.0944842929759,55,0.1588537695312766,3), vec4(301.26115054297594,53,0.1588537695312766,3), vec4(301.427816792976,52,0.1588537695312766,3), vec4(301.59448304297604,50,0.1588537695312766,3), vec4(301.7611492929761,52,0.08072896484372905,3), vec4(301.84448241797605,53,0.08072896484372905,3), vec4(301.927815542976,55,0.08072896484372905,3), vec4(302.011148667976,57,0.08072896484372905,3), vec4(302.09448179297596,59,0.08072896484372905,3), vec4(302.1778149179759,61,0.08072896484372905,3), vec4(302.2611480429759,62,0.1588537695312766,3), vec4(302.42781429297594,65,0.1588537695312766,1), vec4(302.594480542976,64,0.1588537695312766,1), vec4(302.76114679297604,62,0.1588537695312766,1), vec4(302.9278130429761,69,0.1588537695312766,1), vec4(302.9278130429761,57,0.1588537695312766,3), vec4(303.09447929297613,59,0.08072896484372905,3), vec4(303.1778124179761,61,0.08072896484372905,3), vec4(303.26114554297607,62,0.08072896484372905,3), vec4(303.34447866797603,64,0.08072896484372905,3), vec4(303.427811792976,65,0.08072896484372905,3), vec4(303.51114491797597,67,0.08072896484372905,3), vec4(303.59447804297594,69,0.1588537695312766,3), vec4(303.761144292976,76,0.1588537695312766,1), vec4(303.761144292976,67,0.1588537695312766,3), vec4(303.92781054297603,74,0.1588537695312766,1), vec4(303.92781054297603,65,0.1588537695312766,3), vec4(304.0944767929761,73,0.1588537695312766,1), vec4(304.0944767929761,64,0.1588537695312766,3), vec4(304.26114304297613,74,0.1588537695312766,1), vec4(304.4278092929762,75,0.08072896484372905,1), vec4(304.26114304297613,65,0.3177075390624964,3), vec4(304.51114241797615,74,0.08072896484372905,1), vec4(304.5944755429761,72,0.08072896484372905,1), vec4(304.6778086679761,70,0.08072896484372905,1), vec4(304.76114179297605,69,0.08072896484372905,1), vec4(304.844474917976,67,0.08072896484372905,1), vec4(304.927808042976,66,0.3177075390624964,1), vec4(305.094474292976,63,0.1588537695312766,3), vec4(305.261140542976,62,0.1588537695312766,3), vec4(305.42780679297607,60,0.1588537695312766,3), vec4(305.261140542976,69,0.6510400390625932,1), vec4(305.5944730429761,58,0.3177075390624964,3), vec4(305.7611392929761,43,0.1588537695312766,2), vec4(305.92780554297616,41,0.1588537695312766,2), vec4(305.92780554297616,67,0.3177075390625532,1), vec4(305.92780554297616,59,0.3177075390625532,3), vec4(306.0944717929762,43,0.1588537695312766,2), vec4(306.26113804297626,39,0.1588537695312766,2), vec4(306.26113804297626,72,0.3177075390625532,1), vec4(306.26113804297626,60,0.3177075390625532,3), vec4(306.4278042929763,43,0.1588537695312766,2), vec4(306.59447054297635,38,0.1588537695312766,2), vec4(306.59447054297635,71,0.3177075390625532,1), vec4(306.59447054297635,67,0.3177075390625532,3), vec4(306.7611367929764,43,0.1588537695312766,2), vec4(306.92780304297645,69,0.06510400390624227,3), vec4(307.0111361679764,67,0.06510400390624227,3), vec4(306.92780304297645,36,0.15885376953121977,2), vec4(307.09446929297644,69,0.06510400390624227,3), vec4(307.1778024179764,67,0.06510400390624227,3), vec4(306.92780304297645,75,0.31770753906243954,1), vec4(307.09446929297644,43,0.15885376953121977,2), vec4(307.26113554297643,69,0.06510400390624227,3), vec4(307.3444686679764,67,0.06510400390624227,3), vec4(307.26113554297643,35,0.15885376953121977,2), vec4(307.4278017929764,69,0.06510400390624227,3), vec4(307.5111349179764,67,0.06510400390624227,3), vec4(307.26113554297643,74,0.31770753906243954,1), vec4(307.4278017929764,43,0.15885376953121977,2), vec4(307.5944680429764,69,0.06510400390624227,3), vec4(307.6778011679764,67,0.06510400390624227,3), vec4(307.5944680429764,36,0.15885376953121977,2), vec4(307.7611342929764,69,0.06510400390624227,3), vec4(307.8444674179764,67,0.06510400390624227,3), vec4(307.5944680429764,75,0.31770753906243954,1), vec4(307.7611342929764,43,0.15885376953121977,2), vec4(307.9278005429764,69,0.06510400390624227,3), vec4(308.01113366797637,67,0.06510400390624227,3), vec4(307.9278005429764,38,0.15885376953121977,2), vec4(308.0944667929764,69,0.06510400390624227,3), vec4(308.17779991797636,67,0.06510400390624227,3), vec4(307.9278005429764,71,0.31770753906243954,1), vec4(308.0944667929764,43,0.15885376953121977,2), vec4(308.2611330429764,69,0.06510400390624227,3), vec4(308.34446616797635,67,0.06510400390624227,3), vec4(308.2611330429764,39,0.15885376953121977,2), vec4(308.4277992929764,69,0.06510400390624227,3), vec4(308.51113241797634,67,0.06510400390624227,3), vec4(308.2611330429764,72,0.31770753906243954,1), vec4(308.4277992929764,43,0.15885376953121977,2), vec4(308.59446554297637,69,0.06510400390624227,3), vec4(308.67779866797633,67,0.06510400390624227,3), vec4(308.59446554297637,31,0.15885376953121977,2), vec4(308.76113179297636,69,0.06510400390624227,3), vec4(308.8444649179763,67,0.06510400390624227,3), vec4(308.59446554297637,71,0.31770753906243954,1), vec4(308.76113179297636,43,0.15885376953121977,2), vec4(308.92779804297635,69,0.06510400390624227,3), vec4(309.0111311679763,67,0.06510400390624227,3), vec4(308.92779804297635,33,0.15885376953121977,2), vec4(309.09446429297634,69,0.06510400390624227,3), vec4(309.1777974179763,67,0.06510400390624227,3), vec4(308.92779804297635,72,0.31770753906243954,1), vec4(309.09446429297634,43,0.15885376953121977,2), vec4(309.26113054297633,69,0.06510400390624227,3), vec4(309.3444636679763,67,0.06510400390624227,3), vec4(309.26113054297633,35,0.15885376953121977,2), vec4(309.4277967929763,69,0.06510400390624227,3), vec4(309.5111299179763,67,0.06510400390624227,3), vec4(309.26113054297633,74,0.31770753906243954,1), vec4(309.4277967929763,43,0.15885376953121977,2), vec4(309.5944630429763,69,0.06510400390624227,3), vec4(309.6777961679763,67,0.06510400390624227,3), vec4(309.5944630429763,36,0.15885376953121977,2), vec4(309.7611292929763,69,0.06510400390624227,3), vec4(309.8444624179763,67,0.06510400390624227,3), vec4(309.5944630429763,75,0.31770753906243954,1), vec4(309.7611292929763,43,0.15885376953121977,2), vec4(309.9277955429763,69,0.06510400390624227,3), vec4(310.01112866797627,67,0.06510400390624227,3), vec4(309.9277955429763,35,0.15885376953121977,2), vec4(310.0944617929763,69,0.06510400390624227,3), vec4(310.17779491797626,67,0.06510400390624227,3), vec4(309.9277955429763,74,0.31770753906243954,1), vec4(310.0944617929763,43,0.15885376953121977,2), vec4(310.2611280429763,69,0.06510400390624227,3), vec4(310.34446116797625,67,0.06510400390624227,3), vec4(310.2611280429763,36,0.15885376953121977,2), vec4(310.4277942929763,69,0.06510400390624227,3), vec4(310.51112741797624,67,0.06510400390624227,3), vec4(310.2611280429763,75,0.31770753906243954,1), vec4(310.4277942929763,43,0.15885376953121977,2), vec4(310.59446054297626,69,0.06510400390624227,3), vec4(310.67779366797623,67,0.06510400390624227,3), vec4(310.59446054297626,38,0.15885376953121977,2), vec4(310.76112679297626,69,0.06510400390624227,3), vec4(310.8444599179762,67,0.06510400390624227,3), vec4(310.59446054297626,77,0.31770753906243954,1), vec4(310.76112679297626,43,0.15885376953121977,2), vec4(310.92779304297625,81,0.06510400390624227,1), vec4(311.0111261679762,79,0.06510400390624227,1), vec4(310.92779304297625,67,0.15885376953121977,3), vec4(311.09445929297624,81,0.06510400390624227,1), vec4(311.1777924179762,79,0.06510400390624227,1), vec4(310.92779304297625,39,0.31770753906243954,2), vec4(311.09445929297624,67,0.15885376953121977,3), vec4(311.26112554297623,81,0.06510400390624227,1), vec4(311.3444586679762,79,0.06510400390624227,1), vec4(311.26112554297623,65,0.15885376953121977,3), vec4(311.4277917929762,81,0.06510400390624227,1), vec4(311.5111249179762,79,0.06510400390624227,1), vec4(311.26112554297623,38,0.31770753906243954,2), vec4(311.4277917929762,67,0.15885376953121977,3), vec4(311.5944580429762,81,0.06510400390624227,1), vec4(311.6777911679762,79,0.06510400390624227,1), vec4(311.5944580429762,63,0.15885376953121977,3), vec4(311.7611242929762,81,0.06510400390624227,1), vec4(311.8444574179762,79,0.06510400390624227,1), vec4(311.5944580429762,36,0.31770753906243954,2), vec4(311.7611242929762,67,0.15885376953121977,3), vec4(311.9277905429762,81,0.06510400390624227,1), vec4(312.01112366797616,79,0.06510400390624227,1), vec4(311.9277905429762,62,0.15885376953121977,3), vec4(312.0944567929762,81,0.06510400390624227,1), vec4(312.17778991797616,79,0.06510400390624227,1), vec4(311.9277905429762,35,0.31770753906243954,2), vec4(312.0944567929762,67,0.15885376953121977,3), vec4(312.2611230429762,81,0.06510400390624227,1), vec4(312.34445616797615,79,0.06510400390624227,1), vec4(312.2611230429762,60,0.15885376953121977,3), vec4(312.4277892929762,81,0.06510400390624227,1), vec4(312.51112241797614,79,0.06510400390624227,1), vec4(312.2611230429762,36,0.31770753906243954,2), vec4(312.4277892929762,67,0.15885376953121977,3), vec4(312.59445554297616,81,0.06510400390624227,1), vec4(312.67778866797613,79,0.06510400390624227,1), vec4(312.59445554297616,59,0.15885376953121977,3), vec4(312.76112179297616,81,0.06510400390624227,1), vec4(312.8444549179761,79,0.06510400390624227,1), vec4(312.59445554297616,38,0.31770753906243954,2), vec4(312.76112179297616,67,0.15885376953121977,3), vec4(312.92778804297615,81,0.06510400390624227,1), vec4(313.0111211679761,79,0.06510400390624227,1), vec4(312.92778804297615,60,0.15885376953121977,3), vec4(313.09445429297614,81,0.06510400390624227,1), vec4(313.1777874179761,79,0.06510400390624227,1), vec4(312.92778804297615,39,0.31770753906243954,2), vec4(313.09445429297614,67,0.15885376953121977,3), vec4(313.26112054297613,81,0.06510400390624227,1), vec4(313.3444536679761,79,0.06510400390624227,1), vec4(313.26112054297613,62,0.15885376953121977,3), vec4(313.4277867929761,81,0.06510400390624227,1), vec4(313.5111199179761,79,0.06510400390624227,1), vec4(313.26112054297613,41,0.31770753906243954,2), vec4(313.4277867929761,67,0.15885376953121977,3), vec4(313.5944530429761,81,0.06510400390624227,1), vec4(313.6777861679761,79,0.06510400390624227,1), vec4(313.5944530429761,63,0.15885376953121977,3), vec4(313.7611192929761,81,0.06510400390624227,1), vec4(313.8444524179761,79,0.06510400390624227,1), vec4(313.5944530429761,43,0.31770753906243954,2), vec4(313.7611192929761,67,0.15885376953121977,3), vec4(313.9277855429761,81,0.06510400390624227,1), vec4(314.01111866797606,79,0.06510400390624227,1), vec4(313.9277855429761,55,0.15885376953121977,3), vec4(314.0944517929761,81,0.06510400390624227,1), vec4(314.17778491797606,79,0.06510400390624227,1), vec4(313.9277855429761,35,0.31770753906243954,2), vec4(314.0944517929761,67,0.15885376953121977,3), vec4(314.2611180429761,81,0.06510400390624227,1), vec4(314.34445116797605,79,0.06510400390624227,1), vec4(314.2611180429761,57,0.15885376953121977,3), vec4(314.42778429297607,81,0.06510400390624227,1), vec4(314.51111741797604,79,0.06510400390624227,1), vec4(314.2611180429761,36,0.31770753906243954,2), vec4(314.42778429297607,67,0.15885376953121977,3), vec4(314.59445054297606,81,0.06510400390624227,1), vec4(314.67778366797603,79,0.06510400390624227,1), vec4(314.59445054297606,59,0.15885376953121977,3), vec4(314.76111679297605,81,0.06510400390624227,1), vec4(314.844449917976,79,0.06510400390624227,1), vec4(314.59445054297606,38,0.31770753906243954,2), vec4(314.76111679297605,67,0.15885376953121977,3), vec4(314.92778304297605,81,0.06510400390624227,1), vec4(315.011116167976,79,0.06510400390624227,1), vec4(314.92778304297605,60,0.15885376953121977,3), vec4(315.09444929297604,81,0.06510400390624227,1), vec4(315.177782417976,79,0.06510400390624227,1), vec4(314.92778304297605,39,0.31770753906243954,2), vec4(315.09444929297604,67,0.15885376953121977,3), vec4(315.26111554297603,81,0.06510400390624227,1), vec4(315.344448667976,79,0.06510400390624227,1), vec4(315.26111554297603,59,0.15885376953121977,3), vec4(315.427781792976,81,0.06510400390624227,1), vec4(315.511114917976,79,0.06510400390624227,1), vec4(315.26111554297603,38,0.31770753906243954,2), vec4(315.427781792976,67,0.15885376953121977,3), vec4(315.594448042976,81,0.06510400390624227,1), vec4(315.677781167976,79,0.06510400390624227,1), vec4(315.594448042976,60,0.15885376953121977,3), vec4(315.761114292976,81,0.06510400390624227,1), vec4(315.84444741797597,79,0.06510400390624227,1), vec4(315.594448042976,39,0.31770753906243954,2), vec4(315.761114292976,67,0.15885376953121977,3), vec4(315.927780542976,81,0.06510400390624227,1), vec4(316.01111366797596,79,0.06510400390624227,1), vec4(315.927780542976,62,0.15885376953121977,3), vec4(316.094446792976,81,0.06510400390624227,1), vec4(316.17777991797595,79,0.06510400390624227,1), vec4(315.927780542976,41,0.31770753906243954,2), vec4(316.094446792976,67,0.15885376953121977,3), vec4(316.261113042976,81,0.06510400390624227,1), vec4(316.34444616797595,79,0.06510400390624227,1), vec4(316.261113042976,63,0.31770753906243954,3), vec4(316.261113042976,43,0.31770753906243954,2), vec4(316.4277792929759,79,0.1588537695312766,1), vec4(316.59444554297596,77,0.1588537695312766,1), vec4(316.59444554297596,62,0.3177075390625532,3), vec4(316.59444554297596,35,0.3177075390625532,2), vec4(316.761111792976,79,0.1588537695312766,1), vec4(316.92777804297606,75,0.1588537695312766,1), vec4(316.92777804297606,67,0.1588537695312766,3), vec4(316.92777804297606,36,0.3177075390625532,2), vec4(317.0944442929761,77,0.1588537695312766,1), vec4(317.0944442929761,68,0.1588537695312766,3), vec4(317.26111054297616,74,0.1588537695312766,1), vec4(317.26111054297616,65,0.1588537695312766,3), vec4(317.26111054297616,38,0.3177075390625532,2), vec4(317.4277767929762,75,0.1588537695312766,1), vec4(317.4277767929762,67,0.1588537695312766,3), vec4(317.59444304297625,72,0.1588537695312766,1), vec4(317.59444304297625,63,0.3177075390625532,3), vec4(317.59444304297625,39,0.3177075390625532,2), vec4(317.7611092929763,77,0.1588537695312766,1), vec4(317.92777554297635,75,0.1588537695312766,1), vec4(317.92777554297635,60,0.3177075390625532,3), vec4(317.92777554297635,33,0.3177075390625532,2), vec4(318.0944417929764,77,0.1588537695312766,1), vec4(318.26110804297645,74,0.1588537695312766,1), vec4(318.26110804297645,65,0.1588537695312766,3), vec4(318.26110804297645,34,0.3177075390625532,2), vec4(318.4277742929765,75,0.1588537695312766,1), vec4(318.4277742929765,67,0.1588537695312766,3), vec4(318.59444054297654,72,0.1588537695312766,1), vec4(318.59444054297654,63,0.1588537695312766,3), vec4(318.59444054297654,36,0.3177075390625532,2), vec4(318.7611067929766,74,0.1588537695312766,1), vec4(318.7611067929766,65,0.1588537695312766,3), vec4(318.92777304297664,70,0.1588537695312766,1), vec4(318.92777304297664,62,0.3177075390625532,3), vec4(318.92777304297664,38,0.3177075390625532,2), vec4(319.0944392929767,75,0.1588537695312766,1), vec4(319.26110554297674,74,0.1588537695312766,1), vec4(319.26110554297674,58,0.3177075390625532,3), vec4(319.26110554297674,31,0.3177075390625532,2), vec4(319.4277717929768,75,0.1588537695312766,1), vec4(319.59443804297683,72,0.1588537695312766,1), vec4(319.59443804297683,63,0.1588537695312766,3), vec4(319.59443804297683,33,0.3177075390625532,2), vec4(319.7611042929769,74,0.1588537695312766,1), vec4(319.7611042929769,65,0.1588537695312766,3), vec4(319.92777054297693,70,0.1588537695312766,1), vec4(319.92777054297693,62,0.1588537695312766,3), vec4(319.92777054297693,34,0.3177075390625532,2), vec4(320.094436792977,72,0.1588537695312766,1), vec4(320.094436792977,63,0.1588537695312766,3), vec4(320.261103042977,69,0.1588537695312766,1), vec4(320.261103042977,60,0.3177075390625532,3), vec4(320.261103042977,36,0.3177075390625532,2), vec4(320.4277692929771,74,0.1588537695312766,1), vec4(320.5944355429771,72,0.1588537695312766,1), vec4(320.5944355429771,66,0.3177075390625532,3), vec4(320.5944355429771,38,0.3177075390625532,2), vec4(320.7611017929772,74,0.1588537695312766,1), vec4(320.9277680429772,70,0.1588537695312766,1), vec4(320.9277680429772,67,0.1588537695312766,3), vec4(320.9277680429772,43,0.3177075390625532,2), vec4(321.09443429297727,72,0.1588537695312766,1), vec4(321.09443429297727,69,0.1588537695312766,3), vec4(321.2611005429773,69,0.1588537695312766,1), vec4(321.2611005429773,65,0.1588537695312766,3), vec4(321.2611005429773,38,0.3177075390625532,2), vec4(321.42776679297737,70,0.1588537695312766,1), vec4(321.42776679297737,67,0.1588537695312766,3), vec4(321.5944330429774,67,0.1588537695312766,1), vec4(321.5944330429774,63,0.1588537695312766,3), vec4(321.5944330429774,39,0.3177075390625532,2), vec4(321.76109929297746,70,0.1588537695312766,1), vec4(321.76109929297746,67,0.1588537695312766,3), vec4(321.9277655429775,69,0.1588537695312766,1), vec4(321.9277655429775,66,0.1588537695312766,3), vec4(321.9277655429775,34,0.3177075390625532,2), vec4(322.09443179297756,70,0.1588537695312766,1), vec4(322.09443179297756,67,0.1588537695312766,3), vec4(322.2610980429776,72,0.1588537695312766,1), vec4(322.2610980429776,69,0.1588537695312766,3), vec4(322.2610980429776,33,0.3177075390625532,2), vec4(322.42776429297766,70,0.1588537695312766,1), vec4(322.42776429297766,67,0.1588537695312766,3), vec4(322.5944305429777,69,0.1588537695312766,1), vec4(322.5944305429777,66,0.1588537695312766,3), vec4(322.5944305429777,36,0.3177075390625532,2), vec4(322.76109679297775,67,0.1588537695312766,1), vec4(322.76109679297775,64,0.1588537695312766,3), vec4(322.9277630429778,66,0.3177075390624964,1), vec4(323.0944292929778,62,0.1588537695312766,3), vec4(323.26109554297784,60,0.1588537695312766,3), vec4(323.26109554297784,69,0.3177075390625532,1), vec4(323.4277617929779,62,0.1588537695312766,3), vec4(323.59442804297794,74,0.1588537695312766,1), vec4(323.59442804297794,58,0.1588537695312766,3), vec4(323.761094292978,67,0.1588537695312766,1), vec4(323.761094292978,62,0.1588537695312766,3), vec4(323.92776054297804,72,0.1588537695312766,1), vec4(323.92776054297804,57,0.1588537695312766,3), vec4(324.0944267929781,66,0.1588537695312766,1), vec4(324.0944267929781,62,0.1588537695312766,3), vec4(324.26109304297813,70,0.1588537695312766,1), vec4(324.26109304297813,55,0.1588537695312766,3), vec4(324.4277592929782,67,0.1588537695312766,1), vec4(324.4277592929782,62,0.1588537695312766,3), vec4(324.59442554297823,74,0.1588537695312766,1), vec4(324.59442554297823,54,0.1588537695312766,3), vec4(324.7610917929783,69,0.1588537695312766,1), vec4(324.7610917929783,62,0.1588537695312766,3), vec4(324.9277580429783,70,0.1588537695312766,1), vec4(324.9277580429783,55,0.1588537695312766,3), vec4(325.0944242929784,67,0.1588537695312766,1), vec4(325.0944242929784,62,0.1588537695312766,3), vec4(325.2610905429784,69,0.1588537695312766,1), vec4(325.2610905429784,57,0.1588537695312766,3), vec4(325.42775679297847,66,0.1588537695312766,1), vec4(325.42775679297847,62,0.1588537695312766,3), vec4(325.5944230429785,67,0.1588537695312766,1), vec4(325.5944230429785,58,0.1588537695312766,3), vec4(325.76108929297857,74,0.1588537695312766,1), vec4(325.76108929297857,62,0.1588537695312766,3), vec4(325.9277555429786,66,0.1588537695312766,1), vec4(325.9277555429786,50,0.1588537695312766,3), vec4(326.09442179297866,74,0.1588537695312766,1), vec4(326.09442179297866,62,0.1588537695312766,3), vec4(326.2610880429787,67,0.1588537695312766,1), vec4(326.2610880429787,52,0.1588537695312766,3), vec4(326.42775429297876,74,0.1588537695312766,1), vec4(326.42775429297876,62,0.1588537695312766,3), vec4(326.5944205429788,69,0.1588537695312766,1), vec4(326.5944205429788,54,0.1588537695312766,3), vec4(326.76108679297886,74,0.1588537695312766,1), vec4(326.76108679297886,62,0.1588537695312766,3), vec4(326.9277530429789,70,0.1588537695312766,1), vec4(326.9277530429789,55,0.1588537695312766,3), vec4(327.09441929297896,67,0.1588537695312766,1), vec4(327.09441929297896,62,0.1588537695312766,3), vec4(327.261085542979,74,0.1588537695312766,1), vec4(327.261085542979,54,0.1588537695312766,3), vec4(327.42775179297905,69,0.1588537695312766,1), vec4(327.42775179297905,62,0.1588537695312766,3), vec4(327.5944180429791,70,0.1588537695312766,1), vec4(327.5944180429791,55,0.1588537695312766,3), vec4(327.76108429297915,67,0.1588537695312766,1), vec4(327.76108429297915,62,0.1588537695312766,3), vec4(327.9277505429792,72,0.1588537695312766,1), vec4(327.9277505429792,57,0.1588537695312766,3), vec4(328.09441679297925,69,0.1588537695312766,1), vec4(328.09441679297925,62,0.1588537695312766,3), vec4(328.2610830429793,74,0.1588537695312766,1), vec4(328.2610830429793,58,0.3177075390625532,3), vec4(328.42774929297934,72,0.1588537695312766,1), vec4(328.5944155429794,70,0.1588537695312766,1), vec4(322.9277630429778,38,5.968735078126656,2), vec4(328.5944155429794,57,0.3177075390625532,3), vec4(328.76108179297944,69,0.1588537695312766,1), vec4(328.9277480429795,70,0.1588537695312766,1), vec4(329.09441429297954,69,0.1588537695312766,1), vec4(329.2610805429796,70,0.1588537695312766,1), vec4(329.2610805429796,31,0.3177075390625532,2), vec4(329.42774679297963,67,0.1588537695312766,1), vec4(329.5944130429797,69,0.1588537695312766,1), vec4(329.5944130429797,36,0.3177075390625532,2), vec4(329.76107929297973,70,0.1588537695312766,1), vec4(329.9277455429798,72,0.1588537695312766,1), vec4(328.9277480429795,55,1.2682259960940883,3), vec4(329.9277455429798,33,0.3177075390625532,2), vec4(330.0944117929798,74,0.1588537695312766,1), vec4(330.2610780429799,75,0.1588537695312766,1), vec4(330.2610780429799,38,0.3177075390625532,2), vec4(330.4277442929799,74,0.1588537695312766,1), vec4(330.59441054298,72,0.1588537695312766,1), vec4(330.2610780429799,54,0.6354150781251633,3), vec4(330.59441054298,26,0.3177075390625532,2), vec4(330.76107679298,74,0.1588537695312766,1), vec4(330.92774304298007,70,0.1588537695312766,1), vec4(330.92774304298007,55,0.3177075390625532,3), vec4(331.0944092929801,72,0.1588537695312766,1), vec4(331.26107554298017,69,0.1588537695312766,1), vec4(330.92774304298007,31,0.6354150781251633,2), vec4(331.26107554298017,57,0.3177075390625532,3), vec4(331.4277417929802,70,0.1588537695312766,1), vec4(331.59440804298026,58,0.1588537695312766,3), vec4(331.59440804298026,67,0.3177075390625532,1), vec4(331.7610742929803,57,0.1588537695312766,3), vec4(331.92774054298036,55,0.1588537695312766,3), vec4(331.92774054298036,71,0.3177075390625532,1), vec4(331.92774054298036,31,0.3177075390625532,2), vec4(332.0944067929804,53,0.1588537695312766,3), vec4(332.26107304298046,72,0.1588537695312766,1), vec4(332.26107304298046,51,0.3177075390625532,3), vec4(332.4277392929805,75,0.1588537695312766,1), vec4(332.59440554298055,77,0.1588537695312766,1), vec4(332.59440554298055,63,0.3177075390625532,3), vec4(332.7610717929806,79,0.1588537695312766,1), vec4(332.92773804298065,80,0.1588537695312766,1), vec4(332.26107304298046,36,0.9505184570314782,2), vec4(333.0944042929807,79,0.15885376953121977,1), vec4(333.2610705429807,77,0.1588537695312766,1), vec4(332.92773804298065,62,0.6354150781251064,3), vec4(333.2610705429807,35,0.3177075390625532,2), vec4(333.42773679298074,79,0.1588537695312766,1), vec4(333.5944030429808,75,0.1588537695312766,1), vec4(333.5944030429808,60,0.3177075390625532,3), vec4(333.76106929298084,77,0.1588537695312766,1), vec4(333.9277355429809,74,0.1588537695312766,1), vec4(333.5944030429808,36,0.6354150781251633,2), vec4(333.9277355429809,62,0.3177075390625532,3), vec4(334.09440179298093,75,0.1588537695312766,1), vec4(334.261068042981,63,0.1588537695312766,3), vec4(334.261068042981,72,0.3177075390625532,1), vec4(334.42773429298103,65,0.1588537695312766,3), vec4(334.5944005429811,62,0.1588537695312766,3), vec4(334.5944005429811,70,0.3177075390625532,1), vec4(334.7610667929811,63,0.1588537695312766,3), vec4(334.9277330429812,60,0.1588537695312766,3), vec4(334.9277330429812,69,0.3177075390625532,1), vec4(335.0943992929812,63,0.1588537695312766,3), vec4(335.26106554298127,62,0.1588537695312766,3), vec4(335.4277317929813,65,0.1588537695312766,3), vec4(335.59439804298137,67,0.1588537695312766,3), vec4(335.26106554298127,70,0.6510400390626501,1), vec4(335.7610642929814,65,0.1588537695312766,3), vec4(335.92773054298146,63,0.1588537695312766,3), vec4(336.0943967929815,65,0.1588537695312766,3), vec4(336.26106304298156,62,0.1588537695312766,3), vec4(335.92773054298146,69,0.6510400390626501,1), vec4(336.4277292929816,58,0.1588537695312766,3), vec4(336.59439554298166,63,0.1588537695312766,3), vec4(336.7610617929817,62,0.1588537695312766,3), vec4(336.92772804298176,61,0.1588537695312766,3), vec4(336.59439554298166,67,0.6510400390626501,1), vec4(337.0943942929818,57,0.1588537695312766,3), vec4(337.26106054298185,61,0.1588537695312766,3), vec4(337.26106054298185,66,0.3177075390625532,1), vec4(337.4277267929819,60,0.1588537695312766,3), vec4(337.59439304298195,59,0.1588537695312766,3), vec4(337.59439304298195,65,0.3177075390625532,1), vec4(337.761059292982,55,0.1588537695312766,3), vec4(337.92772554298205,60,0.1588537695312766,3), vec4(338.0943917929821,58,0.1588537695312766,3), vec4(338.26105804298214,57,0.1588537695312766,3), vec4(337.92772554298205,63,0.6510400390626501,1), vec4(338.4277242929822,53,0.1588537695312766,3), vec4(338.59439054298224,62,0.1588537695312766,1), vec4(338.59439054298224,58,0.1588537695312766,3), vec4(338.7610567929823,70,0.1588537695312766,1), vec4(338.7610567929823,61,0.1588537695312766,3), vec4(338.92772304298234,69,0.1588537695312766,1), vec4(338.92772304298234,60,0.1588537695312766,3), vec4(339.0943892929824,70,0.1588537695312766,1), vec4(339.0943892929824,62,0.1588537695312766,3), vec4(339.26105554298243,69,0.1588537695312766,1), vec4(339.26105554298243,60,0.1588537695312766,3), vec4(339.4277217929825,67,0.1588537695312766,1), vec4(339.4277217929825,58,0.1588537695312766,3), vec4(339.59438804298253,66,0.1588537695312766,1), vec4(339.59438804298253,57,0.1588537695312766,3), vec4(339.7610542929826,75,0.1588537695312766,1), vec4(339.7610542929826,60,0.1588537695312766,3), vec4(339.9277205429826,74,0.1588537695312766,1), vec4(339.9277205429826,58,0.1588537695312766,3), vec4(340.0943867929827,72,0.1588537695312766,1), vec4(340.0943867929827,57,0.1588537695312766,3), vec4(340.2610530429827,70,0.1588537695312766,1), vec4(340.2610530429827,55,0.1588537695312766,3), vec4(340.4277192929828,81,0.1588537695312766,1), vec4(340.4277192929828,60,0.1588537695312766,3), vec4(340.5943855429828,79,0.1588537695312766,1), vec4(340.5943855429828,58,0.1588537695312766,3), vec4(340.76105179298287,78,0.1588537695312766,1), vec4(340.76105179298287,57,0.1588537695312766,3), vec4(340.9277180429829,58,0.1588537695312766,3), vec4(341.09438429298297,60,0.1588537695312766,3), vec4(340.9277180429829,79,0.47656130859382984,1), vec4(341.261050542983,58,0.15885376953121977,3), vec4(341.427716792983,77,0.1588537695312766,1), vec4(341.427716792983,57,0.1588537695312766,3), vec4(341.59438304298305,75,0.1588537695312766,1), vec4(341.59438304298305,55,0.1588537695312766,3), vec4(341.7610492929831,77,0.1588537695312766,1), vec4(341.7610492929831,57,0.1588537695312766,3), vec4(341.92771554298315,74,0.1588537695312766,1), vec4(341.92771554298315,53,0.1588537695312766,3), vec4(342.0943817929832,75,0.1588537695312766,1), vec4(342.0943817929832,55,0.1588537695312766,3), vec4(342.42771429298324,70,0.1588537695312766,1), vec4(342.5943805429833,69,0.1588537695312766,1), vec4(342.26104804298325,73,0.6354150781251064,1), vec4(342.26104804298325,52,0.6354150781251064,3), vec4(342.76104679298334,67,0.1588537695312766,1), vec4(343.0943792929834,63,0.1588537695312766,3), vec4(343.2610455429834,62,0.1588537695312766,3), vec4(342.9277130429834,74,0.6354150781251064,1), vec4(342.9277130429834,69,0.6354150781251064,1), vec4(342.9277130429834,54,0.6354150781251064,3), vec4(343.4277117929835,60,0.1588537695312766,3), vec4(343.5943780429835,62,0.1588537695312766,3), vec4(343.76104429298357,60,0.1588537695312766,3), vec4(343.9277105429836,58,0.1588537695312766,3), vec4(343.5943780429835,72,0.6354150781251633,1), vec4(343.5943780429835,66,0.6354150781251633,1), vec4(343.5943780429835,50,0.6354150781251633,3), vec4(344.09437679298367,57,0.1588537695312766,3), vec4(344.2610430429837,67,0.1588537695312766,1), vec4(344.42770929298376,65,0.1588537695312766,1), vec4(344.5943755429838,63,0.1588537695312766,1), vec4(344.2610430429837,70,0.6354150781251633,1), vec4(344.2610430429837,55,0.6354150781251633,3), vec4(344.76104179298386,62,0.1588537695312766,1), vec4(344.9277080429839,57,0.1588537695312766,3), vec4(344.9277080429839,69,0.3177075390625532,1), vec4(344.9277080429839,61,0.3177075390625532,1), vec4(345.09437429298396,58,0.1588537695312766,3), vec4(345.261040542984,57,0.1588537695312766,3), vec4(345.261040542984,73,0.3177075390625532,1), vec4(345.261040542984,64,0.3177075390625532,1), vec4(345.42770679298405,55,0.1588537695312766,3), vec4(345.5943730429841,53,0.1588537695312766,3), vec4(345.5943730429841,74,0.3177075390625532,1), vec4(345.5943730429841,65,0.3177075390625532,1), vec4(345.76103929298415,55,0.1588537695312766,3), vec4(345.9277055429842,52,0.1588537695312766,3), vec4(345.9277055429842,76,0.3177075390625532,1), vec4(345.9277055429842,67,0.3177075390625532,1), vec4(346.09437179298425,57,0.1588537695312766,3), vec4(346.2610380429843,69,0.1588537695312766,1), vec4(346.42770429298434,67,0.1588537695312766,1), vec4(346.5943705429844,69,0.1588537695312766,1), vec4(346.2610380429843,77,0.6354150781251633,1), vec4(346.2610380429843,50,0.6354150781251633,3), vec4(346.76103679298444,65,0.1588537695312766,1), vec4(346.9277030429845,67,0.1588537695312766,1), vec4(347.09436929298454,69,0.1588537695312766,1), vec4(347.2610355429846,67,0.1588537695312766,1), vec4(346.5943705429844,74,0.9687475781252601,1), vec4(347.42770179298464,69,0.1588537695312766,1), vec4(347.5943680429847,70,0.1588537695312766,1), vec4(347.76103429298473,69,0.1588537695312766,1), vec4(347.9277005429848,67,0.1588537695312766,1), vec4(346.9277030429845,76,1.2682259960940883,1), vec4(347.5943680429847,73,0.6354150781251633,1), vec4(348.09436679298483,69,0.1588537695312766,1), vec4(348.2610330429849,69,0.1588537695312766,1), vec4(348.2610330429849,65,0.1588537695312766,1), vec4(348.4276992929849,70,0.1588537695312766,1), vec4(348.4276992929849,67,0.1588537695312766,1), vec4(348.594365542985,67,0.1588537695312766,1), vec4(348.594365542985,64,0.1588537695312766,1), vec4(348.761031792985,69,0.1588537695312766,1), vec4(348.761031792985,65,0.1588537695312766,1), vec4(348.92769804298507,62,0.1588537695312766,1), vec4(348.2610330429849,74,0.9505184570314782,1), vec4(348.92769804298507,65,0.3177075390625532,1), vec4(349.0943642929851,60,0.1588537695312766,3), vec4(349.26103054298517,58,0.1588537695312766,3), vec4(349.26103054298517,69,0.3177075390625532,1), vec4(349.26103054298517,77,0.3177075390625532,1), vec4(349.4276967929852,57,0.1588537695312766,3), vec4(349.59436304298526,58,0.1588537695312766,3), vec4(349.59436304298526,79,0.3177075390625532,1), vec4(349.59436304298526,67,0.3177075390625532,1), vec4(349.7610292929853,57,0.1588537695312766,3), vec4(349.92769554298536,55,0.1588537695312766,3), vec4(349.92769554298536,74,0.3177075390625532,1), vec4(349.92769554298536,69,0.3177075390625532,1), vec4(350.0943617929854,53,0.1588537695312766,3), vec4(350.26102804298546,52,0.1588537695312766,3), vec4(350.26102804298546,73,0.3177075390625532,1), vec4(350.26102804298546,67,0.3177075390625532,1), vec4(350.4276942929855,53,0.1588537695312766,3), vec4(350.59436054298556,52,0.1588537695312766,3), vec4(350.59436054298556,74,0.3177075390625532,1), vec4(350.59436054298556,65,0.3177075390625532,1), vec4(350.7610267929856,50,0.1588537695312766,3), vec4(350.92769304298565,49,0.1588537695312766,3), vec4(350.92769304298565,76,0.3177075390625532,1), vec4(350.92769304298565,67,0.3177075390625532,1), vec4(351.0943592929857,45,0.1588537695312766,3), vec4(351.26102554298575,50,0.1588537695312766,3), vec4(351.26102554298575,74,0.3177075390625532,1), vec4(351.26102554298575,65,0.3177075390625532,1), vec4(351.4276917929858,45,0.1588537695312766,3), vec4(351.59435804298585,52,0.1588537695312766,3), vec4(351.59435804298585,73,0.3177075390625532,1), vec4(351.59435804298585,64,0.3177075390625532,1), vec4(351.7610242929859,45,0.1588537695312766,3), vec4(351.92769054298594,53,0.1588537695312766,3), vec4(351.92769054298594,74,0.3177075390625532,1), vec4(351.92769054298594,69,0.3177075390625532,1), vec4(352.094356792986,45,0.1588537695312766,3), vec4(352.26102304298604,55,0.1588537695312766,3), vec4(352.26102304298604,76,0.3177075390625532,1), vec4(352.26102304298604,70,0.3177075390625532,1), vec4(352.4276892929861,45,0.1588537695312766,3), vec4(352.59435554298614,53,0.1588537695312766,3), vec4(352.59435554298614,74,0.3177075390625532,1), vec4(352.59435554298614,69,0.3177075390625532,1), vec4(352.7610217929862,45,0.1588537695312766,3), vec4(352.92768804298623,52,0.1588537695312766,3), vec4(352.92768804298623,73,0.3177075390625532,1), vec4(352.92768804298623,67,0.3177075390625532,1), vec4(353.0943542929863,45,0.1588537695312766,3), vec4(353.26102054298633,50,0.1588537695312766,3), vec4(353.26102054298633,74,0.3177075390625532,1), vec4(353.26102054298633,65,0.3177075390625532,1), vec4(353.4276867929864,45,0.1588537695312766,3), vec4(353.5943530429864,49,0.1588537695312766,3), vec4(353.5943530429864,76,0.3177075390625532,1), vec4(353.5943530429864,67,0.3177075390625532,1), vec4(353.7610192929865,57,0.1588537695312766,3), vec4(353.9276855429865,45,0.1588537695312766,3), vec4(353.9276855429865,79,0.3177075390625532,1), vec4(353.9276855429865,76,0.3177075390625532,1), vec4(354.0943517929866,57,0.1588537695312766,3), vec4(354.2610180429866,50,0.1588537695312766,3), vec4(354.2610180429866,77,0.3177075390625532,1), vec4(354.2610180429866,74,0.3177075390625532,1), vec4(354.42768429298667,57,0.1588537695312766,3), vec4(354.5943505429867,53,0.1588537695312766,3), vec4(354.5943505429867,74,0.3177075390625532,1), vec4(354.5943505429867,69,0.3177075390625532,1), vec4(354.76101679298677,62,0.1588537695312766,3), vec4(354.9276830429868,55,0.1588537695312766,3), vec4(354.9276830429868,70,0.3177075390625532,1), vec4(354.9276830429868,67,0.3177075390625532,1), vec4(355.09434929298686,62,0.1588537695312766,3), vec4(355.2610155429869,52,0.1588537695312766,3), vec4(355.2610155429869,76,0.3177075390625532,1), vec4(355.2610155429869,67,0.3177075390625532,1), vec4(355.42768179298696,61,0.1588537695312766,3), vec4(355.594348042987,53,0.1588537695312766,3), vec4(355.594348042987,74,0.3177075390625532,1), vec4(355.594348042987,69,0.3177075390625532,1), vec4(355.76101429298706,62,0.1588537695312766,3), vec4(355.9276805429871,50,0.1588537695312766,3), vec4(355.9276805429871,74,0.3177075390625532,1), vec4(355.9276805429871,65,0.3177075390625532,1), vec4(356.09434679298715,62,0.1588537695312766,3), vec4(356.2610130429872,64,0.1588537695312766,1), vec4(356.42767929298725,69,0.1588537695312766,1), vec4(356.5943455429873,67,0.1588537695312766,1), vec4(356.2610130429872,73,0.6354150781251633,1), vec4(356.76101179298735,69,0.1588537695312766,1), vec4(356.9276780429874,65,0.1588537695312766,1), vec4(356.9276780429874,74,0.3177075390625532,1), vec4(357.09434429298744,69,0.1588537695312766,1), vec4(357.2610105429875,64,0.1588537695312766,1), vec4(357.2610105429875,76,0.3177075390625532,1), vec4(357.42767679298754,69,0.1588537695312766,1), vec4(357.5943430429876,62,0.1588537695312766,1), vec4(357.5943430429876,77,0.3177075390625532,1), vec4(357.76100929298764,69,0.1588537695312766,1), vec4(357.9276755429877,61,0.1588537695312766,1), vec4(357.9276755429877,76,0.3177075390625532,1), vec4(358.09434179298773,69,0.1588537695312766,1), vec4(358.2610080429878,62,0.1588537695312766,1), vec4(358.2610080429878,77,0.3177075390625532,1), vec4(358.42767429298783,69,0.1588537695312766,1), vec4(358.5943405429879,64,0.1588537695312766,1), vec4(358.5943405429879,73,0.3177075390625532,1), vec4(358.7610067929879,69,0.1588537695312766,1), vec4(358.927673042988,65,0.1588537695312766,1), vec4(358.927673042988,74,0.3177075390625532,1), vec4(359.094339292988,69,0.1588537695312766,1), vec4(359.2610055429881,57,0.1588537695312766,1), vec4(359.2610055429881,73,0.3177075390625532,1), vec4(359.4276717929881,69,0.1588537695312766,1), vec4(359.59433804298817,59,0.1588537695312766,1), vec4(359.59433804298817,74,0.3177075390625532,1), vec4(359.7610042929882,69,0.1588537695312766,1), vec4(359.92767054298827,61,0.1588537695312766,1), vec4(359.92767054298827,76,0.3177075390625532,1), vec4(360.0943367929883,69,0.1588537695312766,1), vec4(360.26100304298836,62,0.1588537695312766,1), vec4(360.26100304298836,77,0.3177075390625532,1), vec4(360.4276692929884,69,0.1588537695312766,1), vec4(360.59433554298846,61,0.1588537695312766,1), vec4(360.59433554298846,76,0.3177075390625532,1), vec4(360.7610017929885,69,0.1588537695312766,1), vec4(360.92766804298856,62,0.1588537695312766,1), vec4(360.92766804298856,77,0.3177075390625532,1), vec4(361.0943342929886,69,0.1588537695312766,1), vec4(361.26100054298865,64,0.1588537695312766,1), vec4(361.26100054298865,79,0.3177075390625532,1), vec4(361.4276667929887,69,0.1588537695312766,1), vec4(361.59433304298875,81,0.1588537695312766,1), vec4(361.59433304298875,65,0.3177075390625532,1), vec4(361.7609992929888,82,0.1588537695312766,1), vec4(361.92766554298885,79,0.1588537695312766,1), vec4(361.92766554298885,64,0.3177075390625532,1), vec4(362.0943317929889,81,0.1588537695312766,1), vec4(362.26099804298894,77,0.1588537695312766,1), vec4(362.26099804298894,62,0.3177075390625532,1), vec4(362.427664292989,79,0.1588537695312766,1), vec4(362.59433054298904,76,0.1588537695312766,1), vec4(362.59433054298904,67,0.3177075390625532,1), vec4(362.7609967929891,77,0.1588537695312766,1), vec4(362.92766304298914,74,0.1588537695312766,1), vec4(362.92766304298914,65,0.3177075390625532,1), vec4(363.0943292929892,69,0.1588537695312766,1), vec4(363.26099554298924,73,0.1588537695312766,1), vec4(363.26099554298924,64,0.3177075390625532,1), vec4(363.4276617929893,69,0.1588537695312766,1), vec4(363.59432804298933,74,0.1588537695312766,1), vec4(363.59432804298933,65,0.3177075390625532,1), vec4(363.7609942929894,69,0.1588537695312766,1), vec4(363.92766054298943,76,0.1588537695312766,1), vec4(363.92766054298943,61,0.3177075390625532,1), vec4(364.0943267929895,69,0.1588537695312766,1), vec4(364.2609930429895,77,0.1588537695312766,1), vec4(364.2609930429895,62,0.3177075390625532,1), vec4(364.4276592929896,69,0.1588537695312766,1), vec4(364.5943255429896,76,0.1588537695312766,1), vec4(364.5943255429896,61,0.3177075390625532,1), vec4(364.76099179298967,69,0.1588537695312766,1), vec4(364.9276580429897,77,0.1588537695312766,1), vec4(364.9276580429897,62,0.3177075390625532,1), vec4(365.09432429298977,69,0.1588537695312766,1), vec4(365.2609905429898,79,0.1588537695312766,1), vec4(365.2609905429898,59,0.3177075390625532,1), vec4(365.42765679298986,69,0.1588537695312766,1), vec4(365.5943230429899,81,0.1588537695312766,1), vec4(365.5943230429899,61,0.3177075390625532,1), vec4(365.76098929298996,69,0.1588537695312766,1), vec4(365.92765554299,76,0.1588537695312766,1), vec4(365.92765554299,67,0.3177075390625532,1), vec4(366.09432179299006,69,0.1588537695312766,1), vec4(366.2609880429901,77,0.1588537695312766,1), vec4(366.2609880429901,65,0.3177075390625532,1), vec4(366.42765429299016,69,0.1588537695312766,1), vec4(366.5943205429902,79,0.1588537695312766,1), vec4(366.5943205429902,62,0.3177075390625532,1), vec4(366.76098679299025,69,0.1588537695312766,1), vec4(367.0943192929903,45,0.1588537695312766,2), vec4(367.26098554299034,43,0.1588537695312766,2), vec4(366.9276530429903,81,0.6354150781251064,1), vec4(366.9276530429903,61,0.6354150781251064,1), vec4(356.2610130429872,57,11.302055078128205,3), vec4(367.4276517929904,45,0.1588537695312766,2), vec4(367.59431804299044,41,0.1588537695312766,2), vec4(367.7609842929905,45,0.1588537695312766,2), vec4(367.92765054299053,40,0.1588537695312766,2), vec4(368.0943167929906,45,0.1588537695312766,2), vec4(368.26098304299063,38,0.1588537695312766,2), vec4(368.4276492929907,45,0.1588537695312766,2), vec4(368.5943155429907,37,0.1588537695312766,2), vec4(368.7609817929908,45,0.1588537695312766,2), vec4(368.9276480429908,38,0.1588537695312766,2), vec4(369.0943142929909,45,0.1588537695312766,2), vec4(369.2609805429909,40,0.1588537695312766,2), vec4(369.42764679299097,45,0.1588537695312766,2), vec4(369.594313042991,41,0.1588537695312766,2), vec4(369.76097929299107,45,0.1588537695312766,2), vec4(369.9276455429911,33,0.1588537695312766,2), vec4(370.09431179299116,45,0.1588537695312766,2), vec4(370.2609780429912,35,0.1588537695312766,2), vec4(370.42764429299126,45,0.1588537695312766,2), vec4(370.5943105429913,37,0.1588537695312766,2), vec4(370.76097679299136,45,0.1588537695312766,2), vec4(370.9276430429914,38,0.1588537695312766,2), vec4(371.09430929299145,45,0.1588537695312766,2), vec4(371.2609755429915,37,0.1588537695312766,2), vec4(371.42764179299155,45,0.1588537695312766,2), vec4(371.5943080429916,38,0.1588537695312766,2), vec4(371.76097429299165,45,0.1588537695312766,2), vec4(371.9276405429917,40,0.1588537695312766,2), vec4(372.09430679299174,45,0.1588537695312766,2), vec4(372.4276392929918,76,0.1588537695312766,1), vec4(372.4276392929918,67,0.1588537695312766,3), vec4(372.59430554299183,74,0.1588537695312766,1), vec4(372.59430554299183,65,0.1588537695312766,3), vec4(372.2609730429918,41,0.6354150781251064,2), vec4(372.7609717929919,73,0.1588537695312766,1), vec4(372.7609717929919,64,0.1588537695312766,3), vec4(372.92763804299193,65,0.1588537695312766,3), vec4(372.92763804299193,74,0.3177075390625532,1), vec4(373.094304292992,61,0.1588537695312766,3), vec4(373.260970542992,41,0.3177075390624964,2), vec4(373.427636792992,77,0.1588537695312766,1), vec4(373.59430304299207,76,0.1588537695312766,1), vec4(373.59430304299207,43,0.3177075390625532,2), vec4(373.7609692929921,77,0.1588537695312766,1), vec4(373.92763554299216,79,0.1588537695312766,1), vec4(373.260970542992,62,0.9687475781252033,3), vec4(373.92763554299216,40,0.3177075390625532,2), vec4(374.0943017929922,81,0.1588537695312766,1), vec4(374.26096804299226,82,0.1588537695312766,1), vec4(374.26096804299226,45,0.3177075390625532,2), vec4(374.4276342929923,81,0.1588537695312766,1), vec4(374.59430054299236,79,0.1588537695312766,1), vec4(374.26096804299226,61,0.6354150781251633,3), vec4(374.59430054299236,33,0.3177075390625532,2), vec4(374.7609667929924,81,0.1588537695312766,1), vec4(374.92763304299245,62,0.1588537695312766,3), vec4(374.92763304299245,77,0.3177075390625532,1), vec4(375.0942992929925,69,0.1588537695312766,3), vec4(375.26096554299255,71,0.1588537695312766,3), vec4(374.92763304299245,38,0.6354150781251633,2), vec4(375.26096554299255,76,0.3177075390625532,1), vec4(375.4276317929926,73,0.1588537695312766,3), vec4(375.59429804299265,74,0.1588537695312766,1), vec4(375.59429804299265,74,0.3177075390625532,3), vec4(375.7609642929927,76,0.1588537695312766,1), vec4(375.92763054299274,77,0.1588537695312766,1), vec4(375.92763054299274,72,0.3177075390625532,3), vec4(375.92763054299274,33,0.3177075390625532,2), vec4(376.0942967929928,75,0.1588537695312766,1), vec4(376.26096304299284,74,0.1588537695312766,1), vec4(376.26096304299284,34,0.3177075390625532,2), vec4(376.4276292929929,72,0.1588537695312766,1), vec4(376.59429554299294,70,0.1588537695312766,1), vec4(376.59429554299294,31,0.3177075390625532,2), vec4(376.760961792993,69,0.1588537695312766,1), vec4(376.92762804299304,67,0.1588537695312766,1), vec4(376.26096304299284,65,0.9505184570314782,3), vec4(376.92762804299304,36,0.3177075390625532,2), vec4(377.0942942929931,69,0.1588537695312766,1), vec4(377.26096054299313,70,0.1588537695312766,1), vec4(377.26096054299313,24,0.3177075390625532,2), vec4(377.4276267929932,72,0.1588537695312766,1), vec4(377.26096054299313,63,0.49218626953137345,3), vec4(377.7609592929933,60,0.1588537695312766,3), vec4(377.9276255429933,57,0.1588537695312766,3), vec4(377.59429304299323,69,0.6354150781251633,1), vec4(377.59429304299323,29,0.6354150781251633,2), vec4(378.0942917929934,53,0.1588537695312766,3), vec4(378.2609580429934,57,0.1588537695312766,3), vec4(378.42762429299347,60,0.1588537695312766,3), vec4(378.5942905429935,63,0.1588537695312766,3), vec4(378.5942905429935,33,0.3177075390625532,2), vec4(378.76095679299357,60,0.1588537695312766,3), vec4(378.9276230429936,62,0.1588537695312766,3), vec4(378.5942905429935,72,0.6510400390626501,1));\n    const vec4 v_3[737] = vec4[](vec4(379.09428929299366,58,0.1588537695312766,3), vec4(379.2609555429937,55,0.1588537695312766,3), vec4(378.9276230429936,34,0.6354150781251633,2), vec4(379.2609555429937,70,0.3177075390625532,1), vec4(379.42762179299376,50,0.1588537695312766,3), vec4(379.5942880429938,55,0.1588537695312766,3), vec4(379.76095429299386,58,0.1588537695312766,3), vec4(379.9276205429939,62,0.1588537695312766,3), vec4(379.9276205429939,79,0.3177075390625532,1), vec4(379.9276205429939,34,0.3177075390625532,2), vec4(380.09428679299396,67,0.1588537695312766,3), vec4(380.260953042994,75,0.1588537695312766,1), vec4(380.260953042994,60,0.1588537695312766,3), vec4(380.42761929299405,77,0.1588537695312766,1), vec4(380.42761929299405,62,0.1588537695312766,3), vec4(380.5942855429941,74,0.1588537695312766,1), vec4(380.5942855429941,58,0.1588537695312766,3), vec4(380.260953042994,36,0.6354150781251633,2), vec4(380.76095179299415,75,0.1588537695312766,1), vec4(380.76095179299415,60,0.1588537695312766,3), vec4(380.9276180429942,72,0.1588537695312766,1), vec4(380.9276180429942,57,0.1588537695312766,3), vec4(381.09428429299425,70,0.1588537695312766,1), vec4(381.09428429299425,55,0.1588537695312766,3), vec4(381.2609505429943,69,0.1588537695312766,1), vec4(381.2609505429943,54,0.1588537695312766,3), vec4(381.2609505429943,33,0.3177075390625532,2), vec4(381.42761679299434,67,0.1588537695312766,1), vec4(381.42761679299434,52,0.1588537695312766,3), vec4(381.5942830429944,54,0.1588537695312766,3), vec4(381.76094929299444,50,0.1588537695312766,3), vec4(381.9276155429945,54,0.1588537695312766,3), vec4(381.5942830429944,69,0.6354150781251633,1), vec4(381.5942830429944,38,0.6354150781251633,2), vec4(382.09428179299454,55,0.1588537695312766,3), vec4(382.2609480429946,57,0.1588537695312766,3), vec4(382.42761429299463,62,0.1588537695312766,3), vec4(382.5942805429947,57,0.1588537695312766,3), vec4(382.76094679299473,55,0.1588537695312766,3), vec4(382.9276130429948,54,0.1588537695312766,3), vec4(383.0942792929948,50,0.1588537695312766,3), vec4(383.2609455429949,54,0.1588537695312766,3), vec4(382.9276130429948,38,0.6354150781251633,2), vec4(383.4276117929949,55,0.1588537695312766,3), vec4(383.594278042995,57,0.1588537695312766,3), vec4(383.760944292995,62,0.1588537695312766,3), vec4(383.92761054299507,57,0.1588537695312766,3), vec4(384.0942767929951,54,0.1588537695312766,3), vec4(384.26094304299517,55,0.1588537695312766,3), vec4(384.4276092929952,50,0.1588537695312766,3), vec4(384.59427554299526,55,0.1588537695312766,3), vec4(384.26094304299517,38,0.6354150781251633,2), vec4(384.7609417929953,57,0.1588537695312766,3), vec4(384.92760804299536,58,0.1588537695312766,3), vec4(385.0942742929954,62,0.1588537695312766,3), vec4(385.26094054299546,58,0.1588537695312766,3), vec4(385.4276067929955,57,0.1588537695312766,3), vec4(385.59427304299555,55,0.1588537695312766,3), vec4(385.7609392929956,50,0.1588537695312766,3), vec4(385.92760554299565,55,0.1588537695312766,3), vec4(385.59427304299555,38,0.6354150781251633,2), vec4(386.0942717929957,57,0.1588537695312766,3), vec4(386.26093804299575,58,0.1588537695312766,3), vec4(386.4276042929958,62,0.1588537695312766,3), vec4(386.59427054299584,60,0.1588537695312766,3), vec4(386.7609367929959,58,0.1588537695312766,3), vec4(386.92760304299594,57,0.1588537695312766,3), vec4(387.094269292996,54,0.1588537695312766,3), vec4(387.26093554299604,57,0.1588537695312766,3), vec4(386.92760304299594,38,0.6354150781251633,2), vec4(387.4276017929961,58,0.1588537695312766,3), vec4(387.59426804299613,60,0.1588537695312766,1), vec4(387.7609342929962,63,0.1588537695312766,1), vec4(387.92760054299623,60,0.1588537695312766,1), vec4(388.0942667929963,58,0.1588537695312766,1), vec4(388.2609330429963,57,0.1588537695312766,3), vec4(388.4275992929964,54,0.1588537695312766,3), vec4(388.5942655429964,57,0.1588537695312766,3), vec4(388.2609330429963,38,0.6354150781251633,2), vec4(388.7609317929965,58,0.1588537695312766,3), vec4(388.9275980429965,60,0.1588537695312766,1), vec4(389.09426429299657,63,0.1588537695312766,1), vec4(389.2609305429966,60,0.1588537695312766,1), vec4(389.42759679299667,58,0.1588537695312766,1), vec4(389.5942630429967,57,0.1588537695312766,3), vec4(389.76092929299676,58,0.1588537695312766,3), vec4(389.9275955429968,62,0.1588537695312766,3), vec4(389.5942630429967,38,0.6354150781251633,2), vec4(390.09426179299686,66,0.1588537695312766,3), vec4(390.2609280429969,67,0.1588537695312766,1), vec4(390.42759429299696,70,0.1588537695312766,1), vec4(390.594260542997,67,0.1588537695312766,1), vec4(390.76092679299705,62,0.1588537695312766,1), vec4(390.9275930429971,58,0.1588537695312766,3), vec4(391.09425929299715,55,0.1588537695312766,3), vec4(391.2609255429972,58,0.1588537695312766,3), vec4(390.9275930429971,38,0.6354150781251633,2), vec4(391.42759179299725,62,0.1588537695312766,3), vec4(391.5942580429973,67,0.1588537695312766,1), vec4(391.76092429299734,70,0.1588537695312766,1), vec4(391.9275905429974,67,0.1588537695312766,1), vec4(392.09425679299744,62,0.1588537695312766,1), vec4(392.2609230429975,60,0.1588537695312766,3), vec4(392.42758929299754,57,0.1588537695312766,3), vec4(392.5942555429976,60,0.1588537695312766,3), vec4(392.2609230429975,38,0.6354150781251633,2), vec4(392.76092179299764,63,0.1588537695312766,3), vec4(392.9275880429977,66,0.1588537695312766,1), vec4(393.09425429299773,69,0.1588537695312766,1), vec4(393.2609205429978,66,0.1588537695312766,1), vec4(393.42758679299783,63,0.1588537695312766,1), vec4(393.5942530429979,60,0.1588537695312766,3), vec4(393.7609192929979,57,0.1588537695312766,3), vec4(393.927585542998,60,0.1588537695312766,3), vec4(393.5942530429979,38,0.6354150781251633,2), vec4(394.094251792998,63,0.1588537695312766,3), vec4(394.26091804299807,66,0.1588537695312766,1), vec4(394.4275842929981,69,0.1588537695312766,1), vec4(394.59425054299817,66,0.1588537695312766,1), vec4(394.7609167929982,63,0.1588537695312766,1), vec4(394.92758304299826,62,0.3177075390624964,1), vec4(394.92758304299826,54,0.3177075390624964,3), vec4(395.09424929299826,38,0.1588537695312766,2), vec4(395.2609155429983,36,0.1588537695312766,2), vec4(395.42758179299835,38,0.1588537695312766,2), vec4(395.5942480429984,34,0.1588537695312766,2), vec4(395.5942480429984,74,0.3177075390625532,1), vec4(395.5942480429984,67,0.3177075390625532,1), vec4(395.5942480429984,55,0.3177075390625532,3), vec4(395.76091429299845,38,0.1588537695312766,2), vec4(395.9275805429985,33,0.1588537695312766,2), vec4(395.9275805429985,72,0.3177075390625532,1), vec4(395.9275805429985,66,0.3177075390625532,1), vec4(395.9275805429985,57,0.3177075390625532,3), vec4(396.09424679299855,38,0.1588537695312766,2), vec4(396.2609130429986,31,0.1588537695312766,2), vec4(396.42757929299864,43,0.1588537695312766,2), vec4(396.5942455429987,41,0.1588537695312766,2), vec4(396.2609130429986,70,0.6354150781251633,1), vec4(396.2609130429986,67,0.6354150781251633,1), vec4(396.2609130429986,58,0.6354150781251633,3), vec4(396.76091179299874,43,0.1588537695312766,2), vec4(396.9275780429988,39,0.1588537695312766,2), vec4(396.9275780429988,72,0.3177075390625532,1), vec4(396.9275780429988,67,0.3177075390625532,1), vec4(396.9275780429988,63,0.3177075390625532,3), vec4(397.09424429299884,43,0.1588537695312766,2), vec4(397.2609105429989,38,0.1588537695312766,2), vec4(397.2609105429989,74,0.3177075390625532,1), vec4(397.2609105429989,71,0.3177075390625532,1), vec4(397.2609105429989,59,0.3177075390625532,3), vec4(397.42757679299893,43,0.1588537695312766,2), vec4(397.594243042999,36,0.1588537695312766,2), vec4(397.76090929299903,36,0.1588537695312766,2), vec4(397.9275755429991,34,0.1588537695312766,2), vec4(397.594243042999,75,0.6354150781251633,1), vec4(397.594243042999,72,0.6354150781251633,1), vec4(397.594243042999,55,0.6354150781251633,3), vec4(398.0942417929991,36,0.1588537695312766,2), vec4(398.2609080429992,33,0.1588537695312766,2), vec4(398.2609080429992,77,0.3177075390625532,1), vec4(398.2609080429992,72,0.3177075390625532,1), vec4(398.2609080429992,60,0.3177075390625532,3), vec4(398.4275742929992,36,0.1588537695312766,2), vec4(398.5942405429993,31,0.1588537695312766,2), vec4(398.5942405429993,79,0.3177075390625532,1), vec4(398.5942405429993,76,0.3177075390625532,1), vec4(398.5942405429993,58,0.3177075390625532,3), vec4(398.7609067929993,36,0.1588537695312766,2), vec4(398.92757304299937,29,0.1588537695312766,2), vec4(399.0942392929994,41,0.1588537695312766,2), vec4(399.26090554299947,39,0.1588537695312766,2), vec4(398.92757304299937,81,0.6354150781251633,1), vec4(398.92757304299937,77,0.6354150781251633,1), vec4(398.92757304299937,57,0.6354150781251633,3), vec4(399.4275717929995,41,0.1588537695312766,2), vec4(399.59423804299956,38,0.1588537695312766,2), vec4(399.59423804299956,77,0.3177075390625532,1), vec4(399.59423804299956,70,0.3177075390625532,1), vec4(399.59423804299956,58,0.3177075390625532,3), vec4(399.7609042929996,41,0.1588537695312766,2), vec4(399.92757054299966,36,0.1588537695312766,2), vec4(399.92757054299966,75,0.3177075390625532,1), vec4(399.92757054299966,69,0.3177075390625532,1), vec4(399.92757054299966,60,0.3177075390625532,3), vec4(400.0942367929997,41,0.1588537695312766,2), vec4(400.26090304299976,74,0.1588537695312766,1), vec4(400.26090304299976,62,0.1588537695312766,3), vec4(400.26090304299976,70,0.3177075390625532,1), vec4(400.26090304299976,34,0.3177075390625532,2), vec4(400.4275692929998,75,0.1588537695312766,1), vec4(400.4275692929998,67,0.1588537695312766,3), vec4(400.59423554299985,74,0.1588537695312766,1), vec4(400.59423554299985,65,0.1588537695312766,3), vec4(400.59423554299985,39,0.3177075390625532,2), vec4(400.7609017929999,72,0.1588537695312766,1), vec4(400.7609017929999,63,0.1588537695312766,3), vec4(400.92756804299995,70,0.1588537695312766,1), vec4(400.92756804299995,62,0.1588537695312766,3), vec4(400.92756804299995,41,0.3177075390625532,2), vec4(401.094234293,72,0.1588537695312766,1), vec4(401.094234293,63,0.1588537695312766,3), vec4(401.26090054300005,70,0.1588537695312766,1), vec4(401.26090054300005,62,0.1588537695312766,3), vec4(401.26090054300005,29,0.3177075390625532,2), vec4(401.4275667930001,69,0.1588537695312766,1), vec4(401.4275667930001,60,0.1588537695312766,3), vec4(401.59423304300014,67,0.1588537695312766,1), vec4(401.59423304300014,58,0.1588537695312766,3), vec4(401.59423304300014,31,0.3177075390625532,2), vec4(401.7608992930002,72,0.1588537695312766,1), vec4(401.7608992930002,63,0.1588537695312766,3), vec4(401.92756554300024,70,0.1588537695312766,1), vec4(401.92756554300024,62,0.1588537695312766,3), vec4(401.92756554300024,36,0.3177075390625532,2), vec4(402.0942317930003,69,0.1588537695312766,1), vec4(402.0942317930003,60,0.1588537695312766,3), vec4(402.26089804300034,67,0.1588537695312766,1), vec4(402.26089804300034,58,0.1588537695312766,3), vec4(402.26089804300034,38,0.3177075390625532,2), vec4(402.4275642930004,69,0.1588537695312766,1), vec4(402.4275642930004,60,0.1588537695312766,3), vec4(402.59423054300044,67,0.1588537695312766,1), vec4(402.59423054300044,58,0.1588537695312766,3), vec4(402.59423054300044,26,0.3177075390625532,2), vec4(402.7608967930005,66,0.1588537695312766,1), vec4(402.7608967930005,57,0.1588537695312766,3), vec4(402.92756304300053,67,0.1588537695312766,1), vec4(402.92756304300053,58,0.1588537695312766,3), vec4(403.0942292930006,65,0.1588537695312766,1), vec4(403.0942292930006,57,0.1588537695312766,3), vec4(403.26089554300063,64,0.1588537695312766,1), vec4(403.26089554300063,55,0.1588537695312766,3), vec4(402.92756304300053,31,0.6354150781251633,2), vec4(403.4275617930007,62,0.1588537695312766,1), vec4(403.4275617930007,53,0.1588537695312766,3), vec4(403.5942280430007,61,0.3177075390624964,1), vec4(403.5942280430007,52,0.3177075390624964,3), vec4(403.7608942930007,33,0.1588537695312766,2), vec4(403.92756054300077,31,0.1588537695312766,2), vec4(403.92756054300077,64,0.3177075390625532,1), vec4(403.92756054300077,55,0.3177075390625532,3), vec4(404.0942267930008,33,0.1588537695312766,2), vec4(404.26089304300086,65,0.1588537695312766,1), vec4(404.26089304300086,57,0.1588537695312766,3), vec4(404.26089304300086,29,0.3177075390625532,2), vec4(404.4275592930009,67,0.1588537695312766,1), vec4(404.4275592930009,59,0.1588537695312766,3), vec4(404.59422554300096,69,0.1588537695312766,1), vec4(404.59422554300096,61,0.1588537695312766,3), vec4(404.59422554300096,26,0.3177075390625532,2), vec4(404.760891793001,71,0.1588537695312766,1), vec4(404.760891793001,62,0.1588537695312766,3), vec4(404.92755804300106,73,0.1588537695312766,1), vec4(404.92755804300106,64,0.1588537695312766,3), vec4(405.0942242930011,74,0.1588537695312766,1), vec4(405.0942242930011,65,0.1588537695312766,3), vec4(405.26089054300115,76,0.1588537695312766,1), vec4(405.26089054300115,67,0.1588537695312766,3), vec4(404.92755804300106,33,0.6354150781251633,2), vec4(405.4275567930012,77,0.1588537695312766,1), vec4(405.4275567930012,69,0.1588537695312766,3), vec4(405.59422304300125,79,0.3177075390624964,1), vec4(405.59422304300125,70,0.3177075390624964,3), vec4(405.92755554300123,77,0.1588537695312766,1), vec4(405.92755554300123,69,0.1588537695312766,3), vec4(406.0942217930013,76,0.1588537695312766,1), vec4(406.0942217930013,67,0.1588537695312766,3), vec4(406.26088804300133,65,0.1588537695312766,3), vec4(406.26088804300133,74,0.3177075390625532,1), vec4(406.4275542930014,69,0.1588537695312766,3), vec4(406.5942205430014,64,0.1588537695312766,3), vec4(406.5942205430014,73,0.3177075390625532,1), vec4(406.7608867930015,69,0.1588537695312766,3), vec4(406.9275530430015,62,0.1588537695312766,3), vec4(406.9275530430015,74,0.3177075390625532,1), vec4(407.0942192930016,69,0.1588537695312766,3), vec4(407.2608855430016,61,0.1588537695312766,3), vec4(407.2608855430016,76,0.3177075390625532,1), vec4(407.42755179300167,69,0.1588537695312766,3), vec4(407.5942180430017,62,0.1588537695312766,3), vec4(407.5942180430017,77,0.3177075390625532,1), vec4(407.76088429300177,69,0.1588537695312766,3), vec4(407.9275505430018,64,0.1588537695312766,3), vec4(407.9275505430018,79,0.3177075390625532,1), vec4(408.09421679300186,69,0.1588537695312766,3), vec4(408.2608830430019,65,0.1588537695312766,3), vec4(408.2608830430019,81,0.3177075390625532,1), vec4(408.42754929300196,69,0.1588537695312766,3), vec4(408.594215543002,57,0.1588537695312766,3), vec4(408.594215543002,73,0.3177075390625532,1), vec4(408.76088179300206,69,0.1588537695312766,3), vec4(408.9275480430021,59,0.1588537695312766,3), vec4(408.9275480430021,74,0.3177075390625532,1), vec4(409.09421429300215,69,0.1588537695312766,3), vec4(409.2608805430022,61,0.1588537695312766,3), vec4(405.59422304300125,26,3.9348859960947493,2), vec4(409.2608805430022,76,0.3177075390625532,1), vec4(409.42754679300225,69,0.1588537695312766,3), vec4(409.5942130430023,62,0.1588537695312766,3), vec4(409.5942130430023,77,0.3177075390625532,1), vec4(409.76087929300235,69,0.1588537695312766,3), vec4(409.9275455430024,61,0.1588537695312766,3), vec4(409.9275455430024,76,0.3177075390625532,1), vec4(410.09421179300244,69,0.1588537695312766,3), vec4(410.2608780430025,62,0.1588537695312766,3), vec4(410.2608780430025,77,0.3177075390625532,1), vec4(410.42754429300254,69,0.1588537695312766,3), vec4(410.5942105430026,59,0.1588537695312766,3), vec4(410.5942105430026,74,0.3177075390625532,1), vec4(410.5942105430026,38,0.3177075390625532,2), vec4(410.76087679300264,69,0.1588537695312766,3), vec4(410.9275430430027,76,0.357421875,1), vec4(410.9275430430027,61,0.357421875,3), vec4(410.9275430430027,33,0.357421875,2), vec4(411.3025430430027,74,0.357421875,1), vec4(411.3025430430027,69,0.357421875,1), vec4(411.3025430430027,62,0.357421875,3), vec4(411.3025430430027,29,0.357421875,2), vec4(411.6775430430027,74,0.408481734375016,1), vec4(411.6775430430027,70,0.408481734375016,1), vec4(411.6775430430027,67,0.408481734375016,3), vec4(411.6775430430027,31,0.408481734375016,2), vec4(412.1061140430027,73,0.408481734375016,1), vec4(412.1061140430027,69,0.408481734375016,1), vec4(412.1061140430027,64,0.408481734375016,3), vec4(412.1061140430027,33,0.408481734375016,2), vec4(412.53468504300275,74,0.4765625,1), vec4(412.53468504300275,69,0.4765625,1), vec4(412.53468504300275,65,0.4765625,3), vec4(412.53468504300275,29,0.4765625,2), vec4(413.03468504300275,77,0.4765625,1), vec4(413.03468504300275,74,0.4765625,1), vec4(413.03468504300275,69,0.4765625,3), vec4(413.03468504300275,26,0.4765625,2), vec4(413.53468504300275,74,0.5718749999999773,1), vec4(413.53468504300275,70,0.5718749999999773,3), vec4(413.53468504300275,31,0.5718749999999773,2), vec4(413.53468504300275,76,1.1437499999999545,1), vec4(414.1346850430027,72,0.5718749999999773,1), vec4(414.1346850430027,69,0.5718749999999773,3), vec4(414.1346850430027,33,0.5718749999999773,2), vec4(414.7358569180027,5,4,-1), vec4(414.7358569180027,74,4.5,1), vec4(414.7358569180027,65,4.5,1), vec4(414.7358569180027,70,4.5,1), vec4(414.7358569180027,62,4.5,3), vec4(414.7358569180027,53,4.5,3), vec4(414.7358569180027,58,4.5,3), vec4(414.7358569180027,34,4.5,2), vec4(419.3608569180027,77,0.12109375,1), vec4(419.4858569180027,79,0.12109375,1), vec4(419.6108569180027,81,0.12109375,1), vec4(419.7358569180027,82,0.12109375,1), vec4(419.8608569180027,69,0.12109375,1), vec4(419.9858569180027,70,0.12109375,1), vec4(420.1108569180027,72,0.12109375,1), vec4(420.2358569180027,74,0.12109375,1), vec4(420.3608569180027,72,0.12109375,1), vec4(420.4858569180027,74,0.12109375,1), vec4(420.6108569180027,75,0.12109375,1), vec4(420.7358569180027,77,0.12109375,1), vec4(420.8608569180027,65,0.12109375,1), vec4(420.9858569180027,67,0.12109375,1), vec4(421.1108569180027,69,0.12109375,1), vec4(421.2358569180027,4,4,-1), vec4(421.2358569180027,70,0.12109375,1), vec4(421.3608569180027,69,0.12109375,1), vec4(421.4858569180027,70,0.12109375,1), vec4(421.6108569180027,72,0.12109375,1), vec4(421.7358569180027,74,0.12109375,1), vec4(421.8608569180027,69,0.12109375,1), vec4(421.9858569180027,67,0.12109375,1), vec4(422.1108569180027,65,0.12109375,1), vec4(422.2358569180027,63,0.12109375,1), vec4(422.3608569180027,67,0.12109375,1), vec4(422.4858569180027,69,0.12109375,1), vec4(422.6108569180027,70,0.12109375,1), vec4(422.7358569180027,72,0.12109375,1), vec4(422.8608569180027,67,0.12109375,1), vec4(422.9858569180027,65,0.12109375,1), vec4(423.1108569180027,63,0.12109375,1), vec4(423.2358569180027,62,0.12109375,1), vec4(423.3608569180027,65,0.12109375,1), vec4(423.4858569180027,67,0.12109375,1), vec4(423.6108569180027,69,0.12109375,1), vec4(423.7358569180027,70,0.12109375,1), vec4(423.8608569180027,57,0.12109375,3), vec4(423.9858569180027,58,0.12109375,3), vec4(424.1108569180027,60,0.12109375,3), vec4(424.2358569180027,62,0.12109375,3), vec4(424.3608569180027,60,0.12109375,1), vec4(424.4858569180027,62,0.12109375,1), vec4(424.6108569180027,63,0.12109375,1), vec4(424.7358569180027,65,0.12109375,1), vec4(424.8608569180027,53,0.12109375,3), vec4(424.9858569180027,55,0.12109375,3), vec4(425.1108569180027,57,0.12109375,3), vec4(425.2358569180027,58,0.12109375,3), vec4(425.3608569180027,57,0.12109375,3), vec4(425.4858569180027,58,0.12109375,3), vec4(425.6108569180027,60,0.12109375,3), vec4(425.7358569180027,62,0.12109375,3), vec4(425.8608569180027,60,0.12109375,3), vec4(425.9858569180027,58,0.12109375,3), vec4(426.1108569180027,57,0.12109375,3), vec4(426.2358569180027,55,0.12109375,3), vec4(426.3608569180027,58,0.1321022617187282,1), vec4(426.4972205430027,60,0.1321022617187282,1), vec4(426.6335841680027,62,0.1321022617187282,1), vec4(426.7699477930027,63,0.1321022617187282,1), vec4(426.9063114180027,62,0.1321022617187282,3), vec4(427.0426750430027,60,0.1321022617187282,3), vec4(427.1790386680027,58,0.1321022617187282,3), vec4(427.3154022930027,57,0.1321022617187282,3), vec4(427.4517659180027,60,0.14531249999998863,1), vec4(427.6017659180027,62,0.14531249999998863,1), vec4(427.75176591800266,64,0.14531249999998863,1), vec4(427.90176591800264,66,0.14531249999998863,1), vec4(428.0517659180026,63,0.14531249999998863,1), vec4(428.2017659180026,62,0.14531249999998863,1), vec4(428.35176591800257,60,0.14531249999998863,1), vec4(428.50176591800255,58,0.14531249999998863,1), vec4(428.6517659180025,66,0.14531249999998863,1), vec4(428.8017659180025,67,0.14531249999998863,1), vec4(428.9517659180025,69,0.14531249999998863,1), vec4(429.28926591800246,72,0.181640625,1), vec4(429.10176591800246,70,0.71484375,1), vec4(429.47676591800246,74,0.357421875,1), vec4(429.47676591800246,55,0.357421875,3), vec4(429.66426591800246,67,0.181640625,1), vec4(429.85176591800246,37,3.8046875,2), vec4(429.85176591800246,70,5.90625,1), vec4(429.85176591800246,76,5.90625,1), vec4(429.85176591800246,64,5.90625,1), vec4(429.85176591800246,67,5.90625,1), vec4(429.85176591800246,61,5.90625,3), vec4(433.85176591800246,41,2.8515625,2), vec4(435.85176591800246,69,1.90625,1), vec4(435.85176591800246,65,1.90625,1), vec4(435.85176591800246,62,1.90625,3), vec4(436.85176591800246,38,0.953125,2), vec4(435.85176591800246,74,5.8046875,1), vec4(437.85176591800246,71,3.8046875,1), vec4(437.85176591800246,62,3.8046875,1), vec4(437.85176591800246,65,3.8046875,1), vec4(437.85176591800246,59,3.8046875,3), vec4(437.85176591800246,32,3.8046875,2), vec4(442.22676591800246,44,0.357421875,2), vec4(442.60176591800246,47,0.357421875,2), vec4(442.97676591800246,41,0.357421875,2), vec4(443.35176591800246,44,0.357421875,2), vec4(443.72676591800246,38,0.357421875,2), vec4(444.10176591800246,41,0.357421875,2), vec4(444.47676591800246,35,0.357421875,2), vec4(444.85176591800246,38,0.357421875,2), vec4(445.22676591800246,32,0.357421875,2), vec4(445.60176591800246,33,0.71484375,2), vec4(447.35176591800246,71,0.953125,1), vec4(447.35176591800246,74,0.953125,1), vec4(447.35176591800246,64,0.953125,1), vec4(447.35176591800246,68,0.953125,1), vec4(447.35176591800246,59,0.953125,3), vec4(447.35176591800246,52,0.953125,3), vec4(447.35176591800246,56,0.953125,3), vec4(448.35176591800246,69,2.8515625,1), vec4(451.35176591800246,67,0.4765625,1), vec4(448.35176591800246,64,3.8046875,1), vec4(448.35176591800246,57,3.8046875,3), vec4(451.85176591800246,65,0.4765625,1), vec4(452.35176591800246,5,4,-1), vec4(448.35176591800246,72,10.0,1), vec4(452.35176591800246,64,6.0,1), vec4(448.35176591800246,60,10.0,3), vec4(448.35176591800246,52,10.0,3), vec4(452.35176591800246,55,6.0,3), vec4(446.35176591800246,28,12.0,2), vec4(458.4654020430025,67,0.11008499609374667,1), vec4(458.57903816800246,65,0.11008499609374667,1), vec4(458.6926742930024,67,0.11008499609374667,1), vec4(458.8063104180024,64,0.11008499609374667,1), vec4(458.91994654300237,64,0.11008499609374667,1), vec4(459.03358266800234,62,0.11008499609374667,1), vec4(459.1472187930023,64,0.11008499609374667,1), vec4(459.2608549180023,60,0.11008499609374667,1), vec4(459.37449104300225,69,0.11008499609374667,1), vec4(459.4881271680022,67,0.11008499609374667,1), vec4(459.6017632930022,69,0.11008499609374667,1), vec4(459.71539941800216,65,0.11008499609374667,1), vec4(459.82903554300214,65,0.11008499609374667,1), vec4(459.9426716680021,64,0.11008499609374667,1), vec4(460.0563077930021,65,0.11008499609374667,1), vec4(460.16994391800205,4,4,-1), vec4(460.16994391800205,62,0.11008499609374667,1), vec4(460.283580043002,71,0.11008499609374667,1), vec4(460.397216168002,69,0.11008499609374667,1), vec4(460.51085229300196,71,0.11008499609374667,1), vec4(460.62448841800193,67,0.11008499609374667,1), vec4(460.7381245430019,67,0.11008499609374667,1), vec4(460.8517606680019,65,0.11008499609374667,1), vec4(460.96539679300184,67,0.11008499609374667,1), vec4(461.0790329180018,64,0.11008499609374667,1), vec4(461.1926690430018,72,0.11008499609374667,1), vec4(461.30630516800176,71,0.11008499609374667,1), vec4(461.4199412930017,72,0.11008499609374667,1), vec4(461.5335774180017,69,0.11008499609374667,1), vec4(461.64721354300167,74,0.11008499609374667,1), vec4(461.76084966800164,72,0.11008499609374667,1), vec4(461.8744857930016,74,0.11008499609374667,1), vec4(461.9881219180016,71,0.11008499609374667,1), vec4(462.10175804300155,76,0.11008499609374667,1), vec4(462.2153941680015,74,0.11008499609374667,1), vec4(462.3290302930015,76,0.11008499609374667,1), vec4(462.44266641800147,72,0.11008499609374667,1), vec4(462.55630254300144,77,0.11008499609374667,1), vec4(462.6699386680014,76,0.11008499609374667,1), vec4(462.7835747930014,77,0.11008499609374667,1), vec4(462.89721091800135,74,0.11008499609374667,1), vec4(463.0108470430013,79,0.11008499609374667,1), vec4(463.1244831680013,77,0.11008499609374667,1), vec4(463.23811929300126,79,0.11008499609374667,1), vec4(463.35175541800123,76,0.11008499609374667,1), vec4(463.4653915430012,72,0.11008499609374667,1), vec4(463.5790276680012,71,0.11008499609374667,1), vec4(463.69266379300115,72,0.11008499609374667,1), vec4(463.8062999180011,69,0.11008499609374667,1), vec4(463.9199360430011,74,0.11008499609374667,1), vec4(464.03357216800106,72,0.11008499609374667,1), vec4(464.14720829300103,74,0.11008499609374667,1), vec4(464.260844418001,71,0.11008499609374667,1), vec4(464.37448054300097,68,0.11008499609374667,1), vec4(464.48811666800094,66,0.11008499609374667,1), vec4(464.6017527930009,68,0.11008499609374667,1), vec4(464.7153889180009,64,0.11008499609374667,1), vec4(464.82902504300085,72,0.11008499609374667,1), vec4(464.9426611680008,71,0.11008499609374667,1), vec4(465.0562972930008,72,0.11008499609374667,1), vec4(465.16993341800077,69,0.11008499609374667,1), vec4(465.28356954300074,65,0.11008499609374667,1), vec4(465.3972056680007,64,0.11008499609374667,1), vec4(465.5108417930007,65,0.11008499609374667,1), vec4(465.62447791800065,62,0.11008499609374667,1), vec4(465.7381140430006,71,0.11008499609374667,1), vec4(465.8517501680006,69,0.11008499609374667,1), vec4(465.96538629300056,71,0.11008499609374667,1), vec4(466.07902241800053,60,0.11008499609374667,1), vec4(466.1926585430005,69,0.11008499609374667,1), vec4(466.3062946680005,67,0.11008499609374667,1), vec4(466.41993079300045,69,0.11008499609374667,1), vec4(466.5335669180004,59,0.11008499609374667,1), vec4(466.6472030430004,68,0.11008499609374667,1), vec4(466.76083916800036,66,0.11008499609374667,1), vec4(466.87447529300033,68,0.11008499609374667,1), vec4(466.9881114180003,64,0.11008499609374667,1), vec4(467.1017475430003,60,0.11008499609374667,3), vec4(467.21538366800024,59,0.11008499609374667,3), vec4(467.3290197930002,57,0.11008499609374667,3), vec4(467.4426559180002,56,0.11008499609374667,3), vec4(467.55629204300016,62,0.11008499609374667,1), vec4(467.6699281680001,60,0.11008499609374667,1), vec4(467.7835642930001,59,0.11008499609374667,1), vec4(467.89720041800007,57,0.11008499609374667,3), vec4(468.01083654300004,64,0.1171872656249775,1), vec4(468.131804043,62,0.1171872656249775,1), vec4(468.25277154299994,60,0.1171872656249775,1), vec4(468.3737390429999,59,0.1171872656249775,3), vec4(468.49470654299984,65,0.1171872656249775,1), vec4(468.6156740429998,64,0.1171872656249775,1), vec4(468.73664154299973,62,0.1171872656249775,1), vec4(468.8576090429997,60,0.1171872656249775,3), vec4(468.97857654299963,67,0.1171872656249775,1), vec4(469.0995440429996,65,0.1321022617187282,1), vec4(469.2359076679996,64,0.1321022617187282,1), vec4(469.3722712929996,62,0.1321022617187282,1), vec4(469.5086349179996,69,0.1321022617187282,1), vec4(469.6449985429996,67,0.1321022617187282,1), vec4(469.7813621679996,65,0.14531249999998863,1), vec4(469.93136216799957,64,0.14531249999998863,1), vec4(470.08136216799954,67,0.14531249999998863,1), vec4(470.2313621679995,69,0.14531249999998863,1), vec4(470.3813621679995,71,0.14531249999998863,1), vec4(470.5313621679995,72,1.787109375,1), vec4(471.4688621679995,60,0.8935546875,1), vec4(471.4688621679995,64,0.8935546875,1), vec4(471.4688621679995,67,0.8935546875,1), vec4(471.4688621679995,55,0.8935546875,3), vec4(471.4688621679995,40,0.8935546875,2), vec4(472.4063621679995,73,0.8935546875,1), vec4(472.4063621679995,64,0.8935546875,1), vec4(472.4063621679995,69,0.8935546875,1), vec4(472.4063621679995,57,0.8935546875,3), vec4(472.4063621679995,43,0.8935546875,2), vec4(473.3438621679995,57,0.12526930468749242,1), vec4(473.4731724179995,61,0.12526930468749242,1), vec4(473.6024826679995,64,0.12526930468749242,1), vec4(473.7317929179995,69,0.12526930468749242,1), vec4(473.8611031679995,73,0.492995328125005,1), vec4(474.3783441679995,73,0.492995328125005,1), vec4(474.3783441679995,64,0.492995328125005,1), vec4(474.3783441679995,69,0.492995328125005,1), vec4(474.3783441679995,57,0.492995328125005,3), vec4(474.3783441679995,43,0.492995328125005,2), vec4(474.8955851679995,74,0.492995328125005,1), vec4(474.8955851679995,62,0.492995328125005,1), vec4(474.8955851679995,65,0.492995328125005,1), vec4(474.8955851679995,69,0.492995328125005,1), vec4(474.8955851679995,57,0.492995328125005,3), vec4(474.8955851679995,41,0.492995328125005,2), vec4(475.4128261679995,57,0.12526930468749242,1), vec4(475.54213641799953,62,0.12526930468749242,1), vec4(475.67144666799953,65,0.12526930468749242,1), vec4(475.80075691799954,69,0.12526930468749242,1), vec4(475.93006716799954,74,0.492995328125005,1), vec4(476.44730816799955,74,0.492995328125005,1), vec4(476.44730816799955,65,0.492995328125005,1), vec4(476.44730816799955,69,0.492995328125005,1), vec4(476.44730816799955,57,0.492995328125005,3), vec4(476.44730816799955,41,0.492995328125005,2), vec4(476.96454916799956,71,0.492995328125005,1), vec4(476.96454916799956,62,0.492995328125005,1), vec4(476.96454916799956,67,0.492995328125005,1), vec4(476.96454916799956,55,0.492995328125005,3), vec4(476.96454916799956,41,0.492995328125005,2), vec4(477.4817901679996,55,0.12526930468749242,3), vec4(477.6111004179996,59,0.12526930468749242,3), vec4(477.7404106679996,62,0.12526930468749242,3), vec4(477.8697209179996,67,0.12526930468749242,1), vec4(477.9990311679996,71,0.492995328125005,1), vec4(478.5162721679996,71,0.492995328125005,1), vec4(478.5162721679996,62,0.492995328125005,1), vec4(478.5162721679996,67,0.492995328125005,1), vec4(478.5162721679996,55,0.492995328125005,3), vec4(478.5162721679996,41,0.492995328125005,2), vec4(479.0335131679996,72,0.492995328125005,1), vec4(479.0335131679996,64,0.492995328125005,1), vec4(479.0335131679996,67,0.492995328125005,1), vec4(479.0335131679996,55,0.492995328125005,3), vec4(479.0335131679996,40,0.492995328125005,2), vec4(479.5507541679996,55,0.12526930468749242,1), vec4(479.68006441799963,60,0.12526930468749242,1), vec4(479.80937466799963,64,0.12526930468749242,1), vec4(479.93868491799964,67,0.12526930468749242,1), vec4(480.06799516799964,72,0.492995328125005,1), vec4(480.58523616799965,72,0.492995328125005,1), vec4(480.58523616799965,64,0.492995328125005,1), vec4(480.58523616799965,67,0.492995328125005,1), vec4(480.58523616799965,55,0.492995328125005,3), vec4(480.58523616799965,40,0.492995328125005,2), vec4(481.10247716799967,69,0.492995328125005,1), vec4(481.10247716799967,60,0.492995328125005,1), vec4(481.10247716799967,65,0.492995328125005,1), vec4(481.10247716799967,57,0.492995328125005,3), vec4(481.10247716799967,40,0.492995328125005,2), vec4(481.6197181679997,53,0.12526930468749242,3), vec4(481.7490284179997,57,0.12526930468749242,3), vec4(481.8783386679997,60,0.12526930468749242,3), vec4(482.0076489179997,65,0.12526930468749242,1), vec4(482.1369591679997,69,0.492995328125005,1), vec4(482.6542001679997,69,0.492995328125005,1), vec4(482.6542001679997,60,0.492995328125005,1), vec4(482.6542001679997,65,0.492995328125005,1), vec4(482.6542001679997,53,0.492995328125005,3), vec4(482.6542001679997,40,0.492995328125005,2), vec4(483.1714411679997,70,0.492995328125005,1), vec4(483.1714411679997,62,0.492995328125005,1), vec4(483.1714411679997,65,0.492995328125005,1), vec4(483.1714411679997,53,0.492995328125005,3), vec4(483.1714411679997,38,0.492995328125005,2), vec4(483.68868216799973,53,0.12526930468749242,3), vec4(483.81799241799973,58,0.12526930468749242,3), vec4(483.94730266799974,62,0.12526930468749242,3), vec4(484.07661291799974,65,0.12526930468749242,1), vec4(484.20592316799974,70,0.492995328125005,1), vec4(484.72316416799976,70,0.492995328125005,1), vec4(484.72316416799976,62,0.492995328125005,1), vec4(484.72316416799976,65,0.492995328125005,1), vec4(484.72316416799976,53,0.492995328125005,3), vec4(484.72316416799976,38,0.492995328125005,2), vec4(485.24040516799977,70,0.492995328125005,1), vec4(485.24040516799977,67,0.492995328125005,1), vec4(485.24040516799977,52,0.492995328125005,3), vec4(485.24040516799977,37,0.492995328125005,2), vec4(485.7576461679998,52,0.1345485976562486,3), vec4(485.8965350429998,55,0.1345485976562486,3), vec4(486.0354239179998,58,0.1345485976562486,3), vec4(486.17431279299984,61,0.1345485976562486,1), vec4(486.31320166799986,70,0.5295138359375073,1), vec4(486.8687571679999,70,0.5295138359375073,1), vec4(486.8687571679999,61,0.5295138359375073,1), vec4(486.8687571679999,64,0.5295138359375073,1), vec4(486.8687571679999,67,0.5295138359375073,1), vec4(486.8687571679999,52,0.5295138359375073,3), vec4(486.8687571679999,37,0.5295138359375073,2), vec4(487.4243126679999,69,0.5295138359375073,1), vec4(487.4243126679999,62,0.5295138359375073,1), vec4(487.4243126679999,66,0.5295138359375073,1), vec4(487.4243126679999,54,0.5295138359375073,3), vec4(487.4243126679999,36,0.5295138359375073,2), vec4(487.97986816799994,50,0.14531249999998863,3), vec4(488.1298681679999,57,0.14531249999998863,3), vec4(488.2798681679999,62,0.14531249999998863,3), vec4(488.42986816799987,66,0.14531249999998863,1), vec4(488.57986816799985,69,0.5718749999999773,1), vec4(489.1798681679998,62,0.5718749999999773,1), vec4(489.1798681679998,66,0.5718749999999773,1), vec4(489.1798681679998,54,0.5718749999999773,3), vec4(489.1798681679998,36,0.5718749999999773,2), vec4(489.1798681679998,69,1.8093743437499938,1), vec4(489.7798681679998,31,1.209374343750028,2), vec4(489.7798681679998,58,2.4749980781249974,1), vec4(489.7798681679998,62,2.4749980781249974,1), vec4(489.7798681679998,55,2.4749980781249974,3), vec4(491.0517424492498,34,1.2708320625000056,2), vec4(491.0517424492498,67,2.536455796874975,1), vec4(492.38507444924977,61,1.2708320625000056,1), vec4(492.38507444924977,64,1.2708320625000056,1), vec4(492.38507444924977,58,1.2708320625000056,3), vec4(492.38507444924977,28,1.2708320625000056,2), vec4(493.71840644924976,65,1.4296875,1), vec4(493.71840644924976,57,1.4296875,3), vec4(493.71840644924976,29,1.4296875,2), vec4(493.71840644924976,62,2.9296875,1), vec4(495.21840644924976,64,3.046873453124988,1), vec4(495.21840644924976,57,3.046873453124988,3), vec4(495.21840644924976,33,3.046873453124988,2), vec4(496.71840644924976,60,3.348210937499971,1), vec4(498.4326904492497,53,1.6339269375000072,3), vec4(498.4326904492497,34,1.6339269375000072,2), vec4(500.14697444924974,58,1.90625,3), vec4(500.14697444924974,55,1.90625,3), vec4(500.14697444924974,31,1.90625,2), vec4(502.14697444924974,6,4,-1), vec4(498.4326904492497,62,11.71427600000004,1), vec4(502.14697444924974,57,7.99999200000002,3), vec4(502.14697444924974,53,7.99999200000002,3), vec4(502.14697444924974,26,7.99999200000002,2), vec4(502.14697444924974,38,7.99999200000002,2));\n    if (n < v_0.length())\n        return v_0[n];\n    else if ((n -= v_0.length()) < v_1.length())\n        return v_1[n];\n    else if ((n -= v_1.length()) < v_2.length())\n        return v_2[n];\n    else if ((n -= v_2.length()) < v_3.length())\n        return v_3[n];\n    return vec4(-2);\n}\n", "sound_code": "float pitch(float i)\n{\n    return 440. * pow(2., (i - 60.) / 12.);\n}\n\nvec2 wave(float f, float a, float time)\n{\n    float w = 2. * pi * f * time;\n    //float v = pow(abs(sin(w / 2.)), 8.) - .5;\n    float v = pow(max(0., (sin(w) + 1.) / 2.), 8.) - .5;\n    return vec2(a * v);\n}\n\nvec2 mainSound(int samp, float time)\n{\n    vec2 sound = vec2(0);\n\n    float t = time + t_offset;\n    for (int i=min(0, int(iSampleRate)) ; i<n_notes ; ++i)\n    {\n        vec4 note = notes(i);\n        if (note.w == -1.)\n            continue;\n        if (note.x < t && t < note.x + note.z)\n        {\n            float f = pitch(note.y);\n            float a = smoothstep(0., .05, t - note.x) * smoothstep(.0, -.05, t - (note.x + note.z));\n            sound += wave(f, .05 * a * clamp(800. / f, 1., 10.), time);\n        }\n    }\n\n    return sound;\n}\n", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stfXRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 114, 153, 153, 1166]], "test": "untested"}
{"id": "slXXzl", "name": "My Game Of Life Shader Attempt", "author": "CharmingSalmon", "description": "Game of life in Shader form.", "tags": ["gameoflife"], "likes": 0, "viewed": 238, "published": 3, "date": "1626302447", "time_retrieved": "2024-07-30T19:10:50.536427", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Output to screen\n    fragColor = texelFetch(iChannel1, ivec2(fragCoord.xy),0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n //Pause if mouse is down\n  if(iMouse.z > 0.) {\n  fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n  return;}\n  \n  //Count neighbors\n  int neighborCount = 0;\n  for(int adj_col = -1; adj_col <= 1; adj_col++){\n    for(int adj_row = -1; adj_row <= 1; adj_row++){\n    if(adj_col == 0 && adj_row==0) continue;\n     if(texelFetch(iChannel0, ivec2(fragCoord.xy - vec2(adj_col,adj_row)),0) == vec4(1)){\n     neighborCount++;\n     }\n    }\n  }\n\n  //Adjust state as appropriate\n  switch(neighborCount){\n  case 8:\n  fragColor = vec4(1);\n  break;\n  case 3:\n  fragColor = vec4(1);\n  break;\n  case 2:\n  if(texelFetch(iChannel0,ivec2(fragCoord.xy),0) == vec4(1)){\n      fragColor = vec4(1);\n  } else {fragColor = vec4(0);}\n  break;\n  default:\n  fragColor = vec4(0);\n  }\n  \n\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "float rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  if (iFrame == 0 && fragCoord == vec2(0)) {\n      fragColor = vec4(iTime);\n      return;\n  }\n  if(iTime - texelFetch(iChannel0, ivec2(0),0).r < 1.5) {\n  vec2 size = vec2(textureSize(iChannel1,0));\n  if(rand(fragCoord + iMouse.xy) > 0.5) {\n  fragColor = vec4(1);\n  }\n  //fragColor = vec4(texelFetch(iChannel1, ivec2(mod(fragCoord.xy/2.,size.xy)), 0).r);\n  return;\n  }\n  \n \n  \n  ivec2 dist = ivec2(abs(fragCoord.xy - iMouse.xy));\n  if(dist.x <= 1 && dist.y <= 1){\n      fragColor = vec4(1);\n  } else {\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord.xy),0);\n    }\n}\n\n\n", "buffer_b_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //Gravity warp\n       vec2 gravity = vec2(0.,0.);\n  //Gravity Calculation\n for(int adj_col = -3; adj_col <= 3; adj_col++){\n    for(int adj_row = -3; adj_row <= 3; adj_row++){\n    if(adj_col == 0 && adj_row==0) continue;\n    if(texelFetch(iChannel0,ivec2(fragCoord+vec2(adj_col,adj_row)),0) == vec4(1.))\n       gravity += vec2(adj_col,adj_row) * 1e5;\n    }\n  }\n  if(1./gravity.x < 1e-6 || 1./gravity.y < 1e-6) {\n  fragColor = texelFetch(iChannel0,ivec2(fragCoord),0); return;\n  }\n  //fragColor = vec4(ceil(1./gravity.x),ceil(1./gravity.y),1,1) * texelFetch(iChannel0,ivec2(fragCoord),0);\n  fragColor = texelFetch(iChannel0,ivec2(fragCoord-ceil(1./gravity)),0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slXXzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 82, 146]], "test": "untested"}
{"id": "stXXRs", "name": "Sommarhack warped fbm", "author": "mrange", "description": "License CC0: Sommarhack warped fbm\nMore warped FBM stuff + sommarhack phoenix", "tags": ["fbm", "warp"], "likes": 5, "viewed": 418, "published": 3, "date": "1626296430", "time_retrieved": "2024-07-30T19:10:51.295397", "image_code": "// License CC0: Sommarhack warped fbm\n//  More warped FBM stuff + sommarhack phoenix\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define TTIME           (TIME*TAU)\n#define DOT2(x)         dot(x, x)\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x)         (0.5+0.5*cos(x))\n\nvec2 g_qx = vec2(0.0);\nvec2 g_qy = vec2(0.0);\n\nvec2 g_rx = vec2(0.0);\nvec2 g_ry = vec2(0.0);\n\n// https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat noise(vec2 p) {\n  p /= pow(1.1 + 0.25*(0.5 + 0.5*sin(0.1*(p.x + p.y) + TTIME/10.0)), 1.15);\n  float a = sin(p.x);\n  float b = cos(p.y);\n  float c = sin(p.x + p.y);\n  float d = mix(a, b, c);\n  return tanh_approx(d);\n\n}\n\n// https://iquilezles.org/articles/fbm\nfloat fbm(vec2 p) {    \n  const float A = 0.57;\n  const float F = 2.1;\n  const int numOctaves = 4;\n  const mat2 rots[numOctaves] = mat2[](F*ROT(0.0/float(numOctaves)), F*ROT(1.0/float(numOctaves)), F*ROT(2.0/float(numOctaves)), F*ROT(3.0/float(numOctaves)));\n\n  float t = 0.0;\n  float f = 1.0;\n  float a = 1.0;\n  for(int i = 0; i<numOctaves; ++i) {\n    t += a*noise(f*p);\n    p *= rots[i];\n    a *= A;\n  }\n\n  return tanh_approx(0.3+t);\n}\n\nconst float scale1 = 1.4;\nconst float scale2 = 0.2; \n\nvoid compute_globals(vec2 p) {\n  const vec2 qx = vec2(1.0,3.0)*scale2;\n  const vec2 qy = vec2(5.0,2.0)*scale2;\n\n  const vec2 rx = vec2(2.0,9.0)*scale2;\n  const vec2 ry = vec2(8.0,3.0)*scale2;\n  \n  g_qx = qx*ROT(TTIME/100.0);\n  g_qy = qy*ROT(TTIME/90.0);\n\n  g_rx = rx*ROT(TTIME/80.0);\n  g_ry = ry*ROT(TTIME/70.0);\n}\n\n// https://iquilezles.org/articles/warp\nvec3 warp(in vec2 p, float d) {\n  float lp = length(p);\n  p *= ROT(-TTIME/100.0 + 0.125*length(p));\n  \n  vec2 qx = g_qx;\n  vec2 qy = g_qy;\n\n  vec2 rx = g_rx;\n  vec2 ry = g_ry;\n\n  vec2 q = vec2(fbm(p + qx),\n                fbm(p + qy));\n\n  vec2 r = vec2(fbm(0.25*p + scale1*q + rx),\n                fbm(0.5*p + scale1*q + ry));\n\n  float f = fbm(0.75*p + scale1*r);\n \n  const vec3 col1 = vec3(0.1, 0.3, 0.8);\n  const vec3 col2 = vec3(0.7, 0.3, 0.5);\n\n  float scaleIt = 1.5*(pow(abs((p.x + p.y)), 0.7));\n\n  float pp= mix(0.7, 0.35, 1.5*tanh_approx(length(p)));\n\n  float fi = tanh_approx(pow(scaleIt, pp)*d / (f - d*scaleIt));\n  vec3 col =  abs(fi + 0.1)*(+0.3 + length(q)*col1 + length(r)*col2);\n  return pow(col, vec3(2.0, 1.5, 1.5)*tanh_approx(0.25*lp));\n}\n\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// Distance fields from: https://iquilezles.org/articles/distfunctions2d\nfloat vesica(vec2 p, vec2 sz) {\n  if (sz.x < sz.y) {\n    sz = sz.yx;\n  } else {\n    p  = p.yx; \n  }\n  vec2 sz2 = sz*sz;\n  float d  = (sz2.x-sz2.y)/(2.0*sz.y);\n  float r  = sqrt(sz2.x+d*d);\n  float b  = sz.x;\n  p = abs(p);\n  return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))                         : length(p-vec2(-d,0.0))-r;\n}\n\nfloat moon(vec2 p, float d, float ra, float rb ) {\n    p.y = abs(p.y);\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n          return length(p-vec2(a,b));\n    return max( (length(p          )-ra),\n               -(length(p-vec2(d,0))-rb));\n}\n\n// Imprecise faster version\nfloat fastMoon(vec2 p, float d, float ra, float rb) {\n  float d0 = length(p) - ra;\n  float d1 = length(p-vec2(d, 0.0)) - rb;\n  return max(d0, -d1);\n}\n\nfloat roundedCross( in vec2 p, in float h )\n{\n    float k = 0.5*(h+1.0/h); // k should be const at modeling time\n    p = abs(p);\n    return ( p.x<1.0 && p.y<p.x*(k-h)+h ) ? \n             k-sqrt(DOT2(p-vec2(1,k)))  :\n           sqrt(min(DOT2(p-vec2(0,h)),\n                    DOT2(p-vec2(1,0))));\n}\n\nfloat box(vec2 p, vec2 b) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n \nfloat plane(vec2 p, vec3 pp) {\n  return dot(p, pp.xy) + pp.z;\n}\n \nfloat summerhack(vec2 p) {\n  // As the moon shapes are mostly used for cut-outs I think there is less need for exact\n  //  moon distance and therefore rely on fastMoon instead\n  vec2 op = p;\n  p.x = abs(p.x);\n  vec2 p0 = p;\n  p0 -= vec2(0.0, 0.385);\n  float d0 = circle(p0, 0.605);\n  vec2 p1 = p;\n  p1 -= vec2(0.0, -0.375);  \n  float d1 = vesica(p1, vec2(0.04, 0.569))-(mix(0.005, 0.035, smoothstep(0.1, 0.2, p1.y)));\n  \n  vec2 p2 = p;\n  p2 -= vec2(0.0, 0.4);\n  p2 = -p2.yx;\n  float d2 = fastMoon(p2, 0.075, 0.33, 0.275);\n  \n  vec2 p3 = p;\n  p3 -= vec2(0.0, 0.65);\n  float d3 = circle(p3, 0.367);\n  \n  vec2 p4 = p;\n  p4 -= vec2(0.0, 0.43);\n  float d4 = circle(p4, 0.29);\n  \n  vec2 p5 = p;\n  p5 -= vec2(-0.185, 0.12);\n  float d5 = circle(p5, 0.30);\n  \n  vec2 p6 = p;\n  p6 -= vec2(0.12, -0.19);\n  p6 *= ROT(0.65);\n  float d6 = vesica(p6, vec2(0.15, 0.024))-0.0175;\n  \n  vec2 p7 = p;\n  p7 -= vec2(0.0, 0.735);\n  p7 = -p7.yx;\n  float d7 = fastMoon(p7, 0.13, 0.68, 0.595);\n  \n  vec2 p8 = p;\n  p8 -= vec2(0.0, 0.7);\n  p8 = -p8.yx;\n  float d8 = fastMoon(p8, 0.1, 0.477, 0.4676);\n\n  vec2 p9 = p;\n  p9 -= vec2(0.25, 0.72);\n  p9.x = -p9.x;\n  float d9 = fastMoon(p9, 0.188, 0.73, 0.775);\n\n  vec2 p10 = op;\n  p10 -= vec2(0.0, 0.28);\n  p10 = p10.yx;\n  p10.x *= sign(op.x);\n  p10.x += (-sign(op.x)+1.0)*-0.0775;\n  float d10 = moon(p10, 0.045, 0.105, 0.095);\n\n  vec2 p11 = p;\n  p11 -= vec2(0.0, -0.78);\n  p11 = p11.yx;\n  float d11 = roundedCross(p11, 0.55);\n  \n  vec2 p12 = p;\n  float d12 = plane(p12, vec3(normalize(vec2(-4.0, 1.0)), 0.315));\n  \n  vec2 p13 = p;\n  p13 -= vec2(-0.05, -0.805);\n  float d13 = circle(p13, 0.175);\n\n  vec2 p14 = p;\n  p14 -= vec2(0.0, -0.88);\n  float d14 = p14.y;\n  \n  vec2 p15 = p;\n  p15 -= vec2(0.45, -0.4);\n  p15 = p15.yx;\n  float d15 = fastMoon(p15, 0.14, 0.4, 0.4);\n\n  vec2 p16 = op;\n  p16 -= vec2(-0.095, 0.323);\n  // Cheat to remove discontinuity in distance field due to hacking on d10\n  float d16 = length(p16); \n    \n  d11 = max(d11, -d13);\n  d11 = max(d11, -d14);\n  d11 = max(d11, -d15);\n  d11 = pmax(d11, -d12, 0.0125);\n\n  float dn = d3;\n  dn = min(dn, d4);\n  dn = min(dn, d2);\n  dn = min(dn, d5);\n  dn = min(dn, d6);\n  dn = min(dn, d7);\n  dn = min(dn, d8);\n  dn = min(dn, d9);\n\n  float d = d0;\n  d = max(d, -dn);\n  d = min(d, d1);\n  d = min(d, d10);\n  d = min(d, d11);\n  d = min(d, d16);\n  \n  \n  return d;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, vec3(1.0/2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  compute_globals(p);\n  float aa = 2.0 / RESOLUTION.y;\n \n  vec3 col = vec3(0.0);  \n  float d = summerhack(p);\n  vec2 c = vec2(0.0, 0.385);\n  \n  const vec3 lcol2 = vec3(1.2, 1.3, 2.0)*1.5;\n  col = warp(p*6.0, d-0.05);\n  col = mix(2.0, 0.5, smoothstep(0.605, 1.5, length(p-c)))*col;\n  col = col;\n\n  col += lcol2*exp(-40.0*max(abs(d-mix(-0.05, -0.01, q.y)), 0.0));\n  col = mix(col, vec3(1.0), smoothstep(-aa, aa, -d));\n  col = mix(col, vec3(0.25*(lcol2*lcol2)*smoothstep(0.56, 0.8, q.y)), smoothstep(-aa, aa, -(d+aa*2.5)));\n  return col.zyx;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = effect(p, q);\n  \n  col = postProcess(col, q);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stXXRs.jpg", "access": "api", "license": "cc0-1.0", "functions": [[487, 527, 566, 566, 655], [657, 657, 696, 696, 725], [727, 727, 755, 775, 851], [853, 853, 874, 874, 1076], [1610, 1610, 1640, 1640, 1924], [1926, 1966, 1997, 1997, 2721], [2724, 2724, 2755, 2755, 2781], [2783, 2856, 2887, 2887, 3182], [3184, 3184, 3234, 3234, 3511], [3513, 3541, 3594, 3594, 3690], [3692, 3692, 3737, 3737, 3989], [3991, 3991, 4018, 4018, 4098], [4101, 4101, 4131, 4131, 4164], [4167, 4167, 4193, 4342, 6500], [6502, 6502, 6538, 6538, 6771], [6773, 6773, 6802, 6802, 7343], [7345, 7345, 7402, 7402, 7593]], "test": "error"}
{"id": "slfXzl", "name": "Torus - closest 3D", "author": "iq", "description": "Closest point on a torus. See more primitives here: [url]https://www.shadertoy.com/playlist/wXsSzB[/url]", "tags": ["3d", "sdf", "torus", "closest"], "likes": 11, "viewed": 715, "published": 3, "date": "1626292886", "time_retrieved": "2024-07-30T19:10:52.040406", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Closest point on a capsule. For closest points on other primitives, check\n//\n//    https://www.shadertoy.com/playlist/wXsSzB\n\n\n\nvec3 closestPointToTorus( vec3 p, float ra, float rb )\n{\n    float l = length(p.xz);\n    vec3  q = vec3(ra*p.x/l,0.0,ra*p.z/l);\n    return q + rb*normalize(p-q);\n}\n\n//------------------------------------------------------------\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdTorus( vec3 p, float ra, float rb )\n{\n    return length( vec2(length(p.xz)-ra,p.y) )-rb;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, vec3 cen, float rad )\n{\n    return length(p-cen)-rad;\n}\n\n//------------------------------------------------------------\nconst float ra = 0.9;\nconst float rb = 0.25;\nvec2 map( in vec3 pos, in bool showSurface, in vec3 samplePoint )\n{\n\n\n    // compute closest point to gPoint on the surace of the capsule\n    vec3 closestPoint = closestPointToTorus(samplePoint, ra, rb );\n    \n    // point\n    vec2 res = vec2( sdSphere( pos, samplePoint, 0.06 ), 1.0 );\n    \n    // closest point\n    {\n    float d = sdSphere( pos, closestPoint, 0.06 );\n    if( d<res.x ) res = vec2( d, 4.0 );\n    }\n    \n    // shape\n    if( showSurface )\n    {\n    float d = sdTorus( pos, ra, rb );\n    if( d<res.x ) res =  vec2( d, 5.0 );\n    }\n\n    // segment\n    {\n    float d = sdCapsule( pos, samplePoint, closestPoint, 0.015 );\n    if( d<res.x ) res =  vec2( d, 4.0 );\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in bool showSurface, in vec3 samplePoint )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps, showSurface, samplePoint ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps, showSurface, samplePoint ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps, showSurface, samplePoint ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps, showSurface, samplePoint ).x );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftShadow( vec3 ro, vec3 rd, in bool showSurface, in vec3 samplePoint )\n{\n    float res = 1.0;\n    const float tmax = 2.0;\n    float t = 0.001;\n    for( int i=0; i<64; i++ )\n    {\n     \tfloat h = map(ro + t*rd, showSurface, samplePoint).x;\n        res = min( res, 64.0*h/t );\n    \tt += clamp(h, 0.01,0.5);\n        if( res<-1.0 || t>tmax ) break;\n        \n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep, in [-1,1]\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord)*AA + ivec2(m,n);\n        // time sample\n        float td = 0.5+0.5*sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1);\n        float time = iTime - (1.0/60.0)*(td+float(m*AA+n))/float(AA*AA-1);\n        #else    \n        // pixel coordinates\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord);\n        // time sample\n        float time = iTime;\n        #endif\n\n        // make shape transparent\n      //bool showSurface = ((samp.x+samp.y)&1)==0;     // 50% opaque\n        bool showSurface = ((samp.x&1)+(samp.y&1))!=0; // 75% opaque\n\n        // animate camera\n        float an = 0.25*time + 6.283185*iMouse.x/iResolution.x;\n        vec3 ro = vec3( 2.4*cos(an), 0.7, 2.4*sin(an) );\n        vec3 ta = vec3( 0.0, 0.0, 0.0 );\n\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.2,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n\n        // animate point\n        vec3 samplePoint = sin(-time*0.8*vec3(1.0,1.1,1.1)+vec3(2.0,1.0,0.0));\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raycast\n        const float tmax = 5.0;\n        float t = 0.0;\n        float m = -1.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            vec2 hm = map(pos,showSurface,samplePoint);\n            m = hm.y;\n            if( hm.x<0.0001 || t>tmax ) break;\n            t += hm.x;\n        }\n    \n        // shade background\n        vec3 col = vec3(0.05)*(1.0-0.2*length(p));\n        \n        // shade objects\n        if( t<tmax )\n        {\n            // geometry\n            vec3  pos = ro + t*rd;\n            vec3  nor = calcNormal(pos,showSurface,samplePoint);\n\n            // color\n            vec3  mate = 0.5 + 0.45*cos( m + vec3(0.0,1.0,1.5) );\n             // show distance isolines\n            if( abs(m-5.0)<0.5 )\n            {\n                float dref = sdTorus( samplePoint, ra, rb );\n                float dsam = length(pos-samplePoint);\n                mate += 0.25*smoothstep(0.8,0.9,sin((dsam-dref)*100.0))*exp2(-12.0*(dsam-dref)*(dsam-dref));\n            }\n           \n            // lighting\t\n            col = vec3(0.0);\n            {\n              // key light\n              vec3  lig = normalize(vec3(0.3,0.7,0.2));\n              float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n              if( dif>0.001 ) dif *= calcSoftShadow(pos+nor*0.001,lig,showSurface,samplePoint);\n              col += 1.5*mate*vec3(1.0,0.9,0.8)*dif;\n            }\n            {\n              // dome light\n              float dif = 0.5 + 0.5*nor.y;\n              col += 0.5*mate*vec3(0.2,0.3,0.4)*dif;\n            }\n        }\n\n        // gamma        \n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slfXzl.jpg", "access": "api", "license": "mit", "functions": [[1210, 1210, 1266, 1266, 1373], [1439, 1488, 1533, 1533, 1586], [1588, 1637, 1689, 1689, 1803], [1805, 1854, 1901, 1901, 1933], [2043, 2043, 2110, 2180, 2747], [2749, 2795, 2869, 2869, 3220], [3222, 3267, 3351, 3351, 3737]], "test": "ok"}
{"id": "stXXzl", "name": "Capsule - closest 3D", "author": "iq", "description": "Closest point on a capsule. See more primitives here: [url]https://www.shadertoy.com/playlist/wXsSzB[/url]", "tags": ["3d", "sdf", "capsule", "closest"], "likes": 13, "viewed": 769, "published": 3, "date": "1626292315", "time_retrieved": "2024-07-30T19:10:52.796384", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Closest point on a capsule. For closest points on other primitives, check\n//\n//    https://www.shadertoy.com/playlist/wXsSzB\n\n\n\nvec3 closestPointToCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec3 q = a + ba*h;\n    return q + r*normalize(p-q);\n}\n\n//------------------------------------------------------------\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, vec3 cen, float rad )\n{\n    return length(p-cen)-rad;\n}\n\n//------------------------------------------------------------\nconst float rad = 0.5;\nconst vec3 pa = vec3(-0.7,-0.2,0.4);\nconst vec3 pb = vec3( 0.7,0.2,-0.1);\n\nvec2 map( in vec3 pos, in vec3 samplePoint )\n{\n\n    // compute closest point to gPoint on the surace of the capsule\n    vec3 closestPoint = closestPointToCapsule(samplePoint, pa, pb, rad );\n    \n    // point\n    vec2 res = vec2( sdSphere( pos, samplePoint, 0.06 ), 1.0 );\n    \n    // closest point\n    {\n    float d = sdSphere( pos, closestPoint, 0.06 );\n    if( d<res.x ) res = vec2( d, 4.0 );\n    }\n    \n    // surface \n    {\n    float d = sdCapsule( pos, pa, pb, rad );\n    if( d<res.x ) res =  vec2( d, 5.0 );\n    }\n\n    // segment\n    {\n    float d = sdCapsule( pos, samplePoint, closestPoint, 0.015 );\n    if( d<res.x ) res =  vec2( d, 4.0 );\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in vec3 samplePoint )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps, samplePoint ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps, samplePoint ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps, samplePoint ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps, samplePoint ).x );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftShadow( vec3 ro, vec3 rd, in vec3 samplePoint )\n{\n    float res = 1.0;\n    const float tmax = 2.0;\n    float t = 0.001;\n    for( int i=0; i<64; i++ )\n    {\n     \tfloat h = map(ro + t*rd, samplePoint).x;\n        res = min( res, 64.0*h/t );\n    \tt += clamp(h, 0.01,0.5);\n        if( res<-1.0 || t>tmax ) break;\n        \n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep, in [-1,1]\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        // time sample\n        float td = 0.5+0.5*sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1);\n        float time = iTime - 0.5*(1.0/60.0)*(td+float(m*AA+n))/float(AA*AA-1);\n        #else    \n        // pixel coordinates\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        // time sample\n        float time = iTime;\n        #endif\n\n        // animate camera\n        float an = 0.25*time + 6.283185*iMouse.x/iResolution.x;\n        vec3 ro = vec3( 2.4*cos(an), 0.7, 2.4*sin(an) );\n        vec3 ta = vec3( 0.0, 0.0, 0.0 );\n\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.2,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n\n        // animate point\n        vec3 samplePoint = sin(time*0.9*vec3(1.0,1.1,1.2)+vec3(0.0,4.0,5.0));\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raycast\n        const float tmax = 5.0;\n        float t = 0.0;\n        float m = -1.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            vec2 hm = map(pos, samplePoint);\n            m = hm.y;\n            if( hm.x<0.0001 || t>tmax ) break;\n            t += hm.x;\n        }\n    \n        // shade background\n        vec3 col = vec3(0.05)*(1.0-0.2*length(p));\n        \n        // shade objects\n        if( t<tmax )\n        {\n            // geometry\n            vec3  pos = ro + t*rd;\n            vec3  nor = calcNormal(pos, samplePoint);\n\n            // color\n            vec3  mate = 0.55 + 0.45*cos( m + vec3(0.0,1.0,1.5) );\n            // show distance isolines\n            if( abs(m-5.0)<0.5 )\n            {\n                float dref = sdCapsule( samplePoint, pa, pb, rad );\n                float dsam = length(pos-samplePoint);\n                mate += 0.25*smoothstep(0.8,0.9,sin((dsam-dref)*100.0))*exp2(-12.0*(dsam-dref)*(dsam-dref));\n            }\n                       \n            // lighting\t\n            col = vec3(0.0);\n            {\n              // key light\n              vec3  lig = normalize(vec3(0.3,0.7,0.2));\n              float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n              if( dif>0.001 ) dif *= calcSoftShadow(pos+nor*0.001,lig, samplePoint);\n              col += 0.75*mate*vec3(1.0,0.9,0.8)*dif;\n            }\n            {\n              // dome light\n              float dif = 0.5 + 0.5*nor.y;\n              col += 0.75*mate*vec3(0.2,0.3,0.4)*dif;\n            }\n        }\n\n        // gamma        \n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stXXzl.jpg", "access": "api", "license": "mit", "functions": [[1210, 1210, 1273, 1273, 1413], [1479, 1528, 1580, 1580, 1694], [1696, 1745, 1792, 1792, 1824], [1987, 1987, 2033, 2102, 2664], [2666, 2712, 2765, 2765, 3064], [3066, 3111, 3174, 3174, 3547]], "test": "ok"}
{"id": "slfXRl", "name": "Sphere - closest 3D", "author": "iq", "description": "Closest point on a sphere. See more primitives here: [url]https://www.shadertoy.com/playlist/wXsSzB[/url]", "tags": ["3d", "sdf", "sphere", "closest"], "likes": 11, "viewed": 857, "published": 3, "date": "1626288125", "time_retrieved": "2024-07-30T19:10:53.545381", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Closest point on a sphere. For closest points on other primitives, check\n//\n//    https://www.shadertoy.com/playlist/wXsSzB\n\n\n\nvec3 closestPointToSphere( vec3 p, vec3 cen, float rad )\n{\n    return cen + rad*normalize(p-cen);\n}\n\n//------------------------------------------------------------\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, vec3 cen, float rad )\n{\n    return length(p-cen)-rad;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n//------------------------------------------------------------\n\nconst float rad = 0.9;\n\nvec2 map( in vec3 pos, bool showSphere, in vec3 samplePoint )\n{\n\n    // compute closest point to gPoint on the surace of the sphere\n    vec3 closestPoint = closestPointToSphere(samplePoint, vec3(0.0), rad );\n    \n    // point\n    vec2 res = vec2( sdSphere( pos, samplePoint, 0.06 ), 1.0 );\n    \n    // closest point\n    {\n    float d = sdSphere( pos, closestPoint, 0.06 );\n    if( d<res.x ) res = vec2( d, 4.0 );\n    }\n    \n    if( showSphere )\n    {\n    float d = sdSphere( pos, vec3(0.0), rad );\n    if( d<res.x ) res =  vec2( d, 5.0 );\n    }\n\n    // segment\n    {\n    float d = sdCapsule( pos, samplePoint, closestPoint, 0.015 );\n    if( d<res.x ) res =  vec2( d, 4.0 );\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in bool showSphere, in vec3 samplePoint )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps, showSphere, samplePoint ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps, showSphere, samplePoint ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps, showSphere, samplePoint ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps, showSphere, samplePoint ).x );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftShadow(vec3 ro, vec3 rd, bool showSphere, in vec3 samplePoint )\n{\n    float res = 1.0;\n    const float tmax = 2.0;\n    float t = 0.001;\n    for( int i=0; i<64; i++ )\n    {\n     \tfloat h = map(ro + t*rd, showSphere, samplePoint).x;\n        res = min( res, 64.0*h/t );\n    \tt += clamp(h, 0.01,0.5);\n        if( res<-1.0 || t>tmax ) break;\n        \n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep, in [-1,1]\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord)*AA + ivec2(m,n);\n        // time sample\n        float td = 0.5+0.5*sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1);\n        float time = iTime - (1.0/60.0)*(td+float(m*AA+n))/float(AA*AA-1);\n        #else    \n        // pixel coordinates\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord);\n        // time sample\n        float time = iTime;\n        #endif\n\n        // make sphere transparent\n        bool showSphere = (texelFetch(iChannel0,samp&7,0).x>0.25);\n\n        // animate camera\n        float an = 0.25*time + 6.283185*iMouse.x/iResolution.x;\n        vec3 ro = vec3( 2.4*cos(an), 0.7, 2.4*sin(an) );\n        vec3 ta = vec3( 0.0, 0.0, 0.0 );\n\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.2,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n\n        // animate point\n        vec3 samplePoint = sin(time*0.8*vec3(1.0,1.1,1.2)+vec3(0.0,1.0,2.0));\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raycast\n        const float tmax = 5.0;\n        float t = 0.0;\n        float m = -1.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            vec2 hm = map(pos,showSphere,samplePoint);\n            m = hm.y;\n            if( hm.x<0.0001 || t>tmax ) break;\n            t += hm.x;\n        }\n    \n        // shade background\n        vec3 col = vec3(0.05)*(1.0-0.2*length(p));\n            \n        // shade objects\n        if( t<tmax )\n        {\n            // geometry\n            vec3  pos = ro + t*rd;\n            vec3  nor = calcNormal(pos,showSphere,samplePoint);\n\n            // color\n            vec3  mate = 0.55 + 0.45*cos( m + vec3(0.0,1.0,1.5) );\n            // show distance isolines\n            if( abs(m-5.0)<0.5 )\n            {\n                float dref = sdSphere( samplePoint, vec3(0.0), rad );\n                float dsam = length(pos-samplePoint);\n                mate += 0.25*smoothstep(0.8,0.9,sin((dsam-dref)*100.0))*exp2(-12.0*(dsam-dref)*(dsam-dref));\n            }\n            \n            // lighting\t\n            col = vec3(0.0);\n            {\n              // key light\n              vec3  lig = normalize(vec3(0.3,0.7,0.2));\n              float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n              if( dif>0.001 ) dif *= calcSoftShadow(pos+nor*0.001,lig,showSphere,samplePoint);\n              col += mate*vec3(1.0,0.9,0.8)*dif;\n            }\n            {\n              // dome light\n              float dif = 0.5 + 0.5*nor.y;\n              col += mate*vec3(0.2,0.3,0.4)*dif;\n            }\n        }\n\n        // gamma        \n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slfXRl.jpg", "access": "api", "license": "mit", "functions": [[1209, 1209, 1267, 1267, 1308], [1374, 1423, 1470, 1470, 1502], [1504, 1553, 1605, 1605, 1719], [1809, 1809, 1872, 1940, 2511], [2513, 2559, 2632, 2632, 2979], [2981, 3026, 3105, 3105, 3490]], "test": "untested"}
{"id": "NlXXzs", "name": "Box - closest 3D", "author": "iq", "description": "Closest point to a 3D box. Both interior and exterior queries work.  See more primitives here: [url]https://www.shadertoy.com/playlist/wXsSzB[/url]", "tags": ["3d", "sdf", "box", "closest"], "likes": 27, "viewed": 1318, "published": 3, "date": "1626283334", "time_retrieved": "2024-07-30T19:10:54.301360", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Closest point on a 3D box. For closest points on other primitives, check\n//\n//    https://www.shadertoy.com/playlist/wXsSzB\n\n\n\n// Returns the closest point o, a 3D box\n//   p is the point we are at\n//   b is the box radius (3 half side lengths)\n//   The box is axis aligned and centered at the origin. For a box rotated \n//   by M,you need to transform p and the returned point by inverse(M).\nvec3 closestPointToBox( vec3 p, vec3 b )\n{\n    vec3   d = abs(p) - b;\n    float  m = min(0.0,max(d.x,max(d.y,d.z)));\n    return p - vec3(d.x>=m?d.x:0.0,\n                    d.y>=m?d.y:0.0,\n                    d.z>=m?d.z:0.0)*sign(p);\n}\n\n// Alternative implementation\nvec3 closestPointToBox2( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    vec3 s = sign(p);\n\n    // interior\n    vec3 q; float ma;\n                 { q=p; q.x=s.x*b.x; ma=d.x; }\n    if( d.y>ma ) { q=p; q.y=s.y*b.y; ma=d.y; }\n    if( d.z>ma ) { q=p; q.z=s.z*b.z; ma=d.z; }\n    if( ma<0.0 ) return q;\n\n    // exterior\n    return p - s*max(d,0.0);\n}\n\n// If the point is guaranteed to be always outside of the box, you can\n// use closestPointToBoxExterior() instead.\nvec3 closestPointToBoxExterior( vec3 p, vec3 b )\n{\n    return p-sign(p)*max(abs(p)-b,0.0);\n}\n\n//------------------------------------------------------------\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, vec3 cen, float rad )\n{\n    return length(p-cen)-rad;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n//------------------------------------------------------------\nconst vec3 box_rad = vec3(1.1,0.5,0.6);\n\nvec2 map( in vec3 pos, bool showSurface, in vec3 samplePoint )\n{\n\n    // compute closest point to gPoint on the surace of the box\n    vec3 closestPoint = closestPointToBox(samplePoint, box_rad );\n    \n    // point\n    vec2 res = vec2( sdSphere( pos, samplePoint, 0.06 ), 1.0 );\n    \n    // closest point\n    {\n    float d = sdSphere( pos, closestPoint, 0.06 );\n    if( d<res.x ) res = vec2( d, 4.0 );\n    }\n    \n    // box (semi-transparent)    \n    if( showSurface )\n    {\n    float d = sdBox( pos, box_rad );\n    if( d<res.x ) res =  vec2( d, 5.0 );\n    }\n\n    // segment\n    {\n    float d = sdCapsule( pos, samplePoint, closestPoint, 0.015 );\n    if( d<res.x ) res =  vec2( d, 4.0 );\n    }\n\n    // box edges\n    {\n    float d = sdBoxFrame( pos, box_rad, 0.01 );\n    if( d<res.x ) res =  vec2( d, 5.0 );\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in bool showSurface, in vec3 samplePoint )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps, showSurface, samplePoint ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps, showSurface, samplePoint ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps, showSurface, samplePoint ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps, showSurface, samplePoint ).x );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftShadow( vec3 ro, vec3 rd, bool showSurface, in vec3 samplePoint )\n{\n    float res = 1.0;\n    const float tmax = 2.0;\n    float t = 0.001;\n    for( int i=0; i<64; i++ )\n    {\n     \tfloat h = map(ro + t*rd, showSurface, samplePoint).x;\n        res = min( res, 64.0*h/t );\n    \tt += clamp(h, 0.01,0.5);\n        if( res<-1.0 || t>tmax ) break;\n        \n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep, in [-1,1]\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord)*AA + ivec2(m,n);\n        // time sample\n        float td = 0.5+0.5*sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1);\n        float time = iTime - 0.5*(1.0/60.0)*(td+float(m*AA+n))/float(AA*AA-1);\n        #else    \n        // pixel coordinates\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord);\n        // time sample\n        float time = iTime;\n        #endif\n\n        // animate camera\n        float an = 0.25*time + 6.283185*iMouse.x/iResolution.x;\n        vec3 ro = vec3( 2.4*cos(an), 0.7, 2.4*sin(an) );\n        vec3 ta = vec3( 0.0, -0.15, 0.0 );\n\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.2,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n\n        // animate point\n        vec3 samplePoint = -sin(time*0.8*vec3(1.0,1.1,1.2)+vec3(4.0,2.0,1.0));\n\n\n        // make box transparent\n      //bool showSurface = ((samp.x+samp.y)&1)==0;     // 50% opaque\n        bool showSurface = ((samp.x&1)+(samp.y&1))!=0; // 75% opaque\n\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raycast\n        const float tmax = 5.0;\n        float t = 0.0;\n        float m = -1.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            vec2 hm = map(pos,showSurface, samplePoint);\n            m = hm.y;\n            if( hm.x<0.0001 || t>tmax ) break;\n            t += hm.x;\n        }\n    \n        // shade background\n        vec3 col = vec3(0.05)*(1.0-0.2*length(p));\n        \n        // shade objects\n        if( t<tmax )\n        {\n            // geometry\n            vec3  pos = ro + t*rd;\n            vec3  nor = calcNormal(pos,showSurface, samplePoint);\n\n            // color\n            vec3  mate = 0.55 + 0.45*cos( m + vec3(0.0,1.0,1.5) );\n            // show distance isolines\n            if( abs(m-5.0)<0.5 )\n            {\n                float dref = sdBox( samplePoint, box_rad );\n                float dsam = length(pos-samplePoint);\n                mate += smoothstep(0.8,0.9,sin((dsam-dref)*80.0))*exp2(-12.0*(dsam-dref)*(dsam-dref));\n            }\n                        \n            // lighting\t\n            col = vec3(0.0);\n            {\n              // key light\n              vec3  lig = normalize(vec3(0.3,0.7,0.2));\n              float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n              if( dif>0.001 ) dif *= calcSoftShadow(pos+nor*0.001,lig,showSurface, samplePoint);\n              col += mate*vec3(1.0,0.9,0.8)*dif;\n            }\n            {\n              // dome light\n              float dif = 0.5 + 0.5*nor.y;\n              col += mate*vec3(0.2,0.3,0.4)*dif;\n            }\n        }\n\n        // gamma        \n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXXzs.jpg", "access": "api", "license": "mit", "functions": [[1209, 1475, 1517, 1517, 1710], [1712, 1742, 1785, 1785, 2087], [2089, 2204, 2254, 2254, 2296], [2362, 2411, 2442, 2442, 2533], [2535, 2584, 2631, 2631, 2663], [2665, 2714, 2766, 2766, 2880], [2882, 2931, 2976, 2976, 3264], [3370, 3370, 3434, 3499, 4204], [4206, 4252, 4326, 4326, 4677], [4679, 4724, 4805, 4805, 5191]], "test": "ok"}
{"id": "flS3D3", "name": "invaderz ufos", "author": "z0rg", "description": "zey r cOmInG fOr uS", "tags": ["invaders", "ufo", "invaderz", "zerfef"], "likes": 14, "viewed": 390, "published": 3, "date": "1626281460", "time_retrieved": "2024-07-30T19:10:55.142112", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a,0.,1.)\nmat2 r2d(float a){float ca = cos(a),sa=sin(a);return mat2(ca,-sa,sa,ca);}\n#define PI 3.14159265\n\nfloat _sqr(vec2 p, vec2 s)\n{\n    vec2 l = abs(p)-s;\n    return max(l.x, l.y);\n}\nfloat _cir(vec2 p, float r)\n{\nreturn length(p)-r;\n}\n\nfloat _bbox(vec3 p, vec3 s)\n{\n  vec3 l = abs(p)-s;\n//  l = abs(l)-s*.9;\n  return max(l.x,max(l.y,l.z));\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n  if(a.x<b.x)\n  return a;\n  return b;\n}\n\nfloat _sph(vec3 p, float r)\n{\n  return length(p)-r;\n}\n\nvec4 ovnip[3];\n\nfloat ovni(vec3 p)\n{\n  float acc = 1000.;\n  acc = min(acc, max(length(p)-2.,p.y+1.5));\n\n  acc= min(acc,max(length(p.xz)-1.3,abs(p.y+1.1)-.4));\n\n  vec3 pc = p-vec3(0.,2.9,0.);\n  acc = min(acc, max(length(pc)-4.,pc.y+3.5));\n\n // float a = atan(p.x,p.z);\n\n  float repa = 2.*PI/3.;\n\n  for(int i = 0;i<3;++i)\n  {\n    float a = float(i)*repa+iTime;\n    float r = 1.2;\n    vec3 pos = p+vec3(sin(a)*r,0.55,cos(a)*r);\n    acc = min(acc, _sph(pos,.25));\n  }\n  acc = min(acc, _sph(p-vec3(0.,-.6,0.),.5));\n  return acc;\n}\n\nvec2 map(vec3 p)\n{\n  vec2 acc = vec2(1000.,-1.);\n\n  for (int i = 0;i<3;++i)\n  {\n    float a = ovnip[i].w;\n    vec3 pos = p-ovnip[i].xyz;\n    vec3 opos = pos;\n    pos.xy*=r2d(a);\n    acc = _min(acc, vec2(ovni(pos),float(i)));\n\n    vec3 dest = vec3(0.,-2.,0.);\n    vec3 plaser = mix(opos, dest, mod(iTime*2.+float(i)*.33, 1.)/1.);\n    plaser.yz *= r2d(-.5);\n   plaser.xz *= r2d(-a*.5);\n    acc= _min(acc, vec2(_sph(plaser*vec3(1.,1.,.1),.1), 12.));\n  }\n\n  acc = _min(acc, vec2(_sph(p-vec3(0.,19.,8.), 15.5), 5.));\n  return acc;\n}\nvec3 gradient(float f)\n{\n    vec3 cols[3];\n    \n    cols[0] = vec3(0.169,0.086,0.816);\n    cols[1] = vec3(0.835,0.216,0.843);\n    cols[2] = vec3(1.,1.,1.);\n    \n    float cnt = 2.;\n    float cur = f*cnt;\n    float curIdx = floor(cur);\n    return mix(cols[int(curIdx)], cols[int(min(curIdx+1., cnt))], sat(fract(cur)));\n}\nvec3 accCol;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n  vec3 p = ro;\n  for (int i = 0; i<steps;++i)\n  {\n    vec2 res = map(p);\n    if (res.x<0.01)\n      return vec3(res.x,distance(p,ro),res.y);\n      if (res.y > 10.)\n          accCol += vec3(0.2,1.,0.2)*pow(1.-sat(res.x/0.2),5.);\n      else if (res.y != 5.)\n          accCol += (1.-sat(p.z*.045))*.1*gradient(sat(p.z*.05))*pow(1.-sat(res.x/2.7),5.);\n    p+= rd*res.x;\n  }\n  return vec3(-1.);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n  float fov = .75;\n  vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n  vec3 u = normalize(cross(rd,r));\n  return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n  vec2 e = vec2(0.01,0.);\n  return normalize(vec3(d)-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x));\n}\n\nvoid setup()\n{\n  ovnip[0]= vec4(-2.+cos(iTime*2.)*.2,sin(iTime*2.)*.25-.5,2.,.3);\n  ovnip[1]= vec4(3.,sin(iTime*2.+1.)*.25,10.,-.3);\n  ovnip[2]= vec4(0.,sin(iTime*2.+2.)*.25,20.,0.);\n}\n\nfloat _person(vec2 uv, float off)\n{\n    float shape = _sqr(uv, vec2(.03,.07));\n    shape = min(shape, _cir(uv-vec2(0.,.1), .03));\n    shape = min(shape, _sqr(uv-vec2(0.02,-.05), vec2(.01,0.05+0.05*(sin(iTime*16.+off)*.5+.5))));\n    shape = min(shape, _sqr(uv-vec2(-0.02,-.05), vec2(.01,0.05+0.05*(sin((iTime)*16.+3.14+off)*.5+.5))));\n    float th = 0.01;\n    uv -= vec2(0.,-.03);\n    uv *= r2d(-sign(uv.x)*.5);\n    shape = min(shape, max(abs(uv.y-.05-sat(abs(uv.x*2.))*sin(abs(uv.x*50.)-iTime*5.+off)*.02)-th, abs(uv.x)-.2));\n    return shape;\n}\n\nvec3 drawPeople(vec3 col, vec2 uv)\n{\n    float shapea = _person((uv*r2d(.25)*.5-vec2(0.2,-.1))*r2d(sin(iTime*2.+1.)*.1),0.);\n    float shapeb = _person((uv*r2d(-.25)*1.5-vec2(-0.3,-.6))*r2d(sin(iTime)*.2),1.);\n\n    float shape = min(shapea, shapeb);\n    col = mix(col, vec3(0.), 1.-sat(shapea*400.));\n    col = mix(col, col*.25, 1.-sat(shapeb*400.));\n    return col;\n}\n\nfloat letter(vec2 uv, int idx, int idy)\n{\n    uv *= .25;\n    float width = 1./16.;\n    float height = 1./16.;\n    float x = float(idx);\n    float y = float(idy);\n    vec2 topl = vec2(x*width, y*height);\n    vec2 coords = uv+vec2(width, height)*.5;//+topl;\n    coords = clamp(coords, vec2(0.), vec2(width, height));\n    coords -= topl;\n    return texture(iChannel1, coords).x;\n}\n\nvec3 drawText(vec2 uv)\n{\n    vec3 col = vec3(0.);\n    uv -= vec2(-.5,.3);\n    uv *= r2d(-.5);\n    uv.y *= 1.-sat(abs(uv.x))+sin(uv.x*7.+iTime*2.)*.1;\n    uv.x += .4;\n    vec2 off = vec2(0.12, 0.);\n    col = mix(col, vec3(1.), letter(uv*r2d(.1),-9,5));\n    uv -= off;\n    col = mix(col, vec3(1.), letter(uv*r2d(-.2),-14,5));\n    uv -= off;\n    col = mix(col, vec3(1.), letter(uv*r2d(.1),10,6));\n    uv -= off;\n    col = mix(col, vec3(1.), letter(uv*r2d(-.1),-1,5));\n    uv -= off;\n    col = mix(col, vec3(1.), letter(uv*r2d(-.3),-4,5));\n    uv -= off;\n    col = mix(col, vec3(1.), letter(uv,-5,5));\n    uv -= off;\n    col = mix(col, vec3(1.), letter(uv*r2d(-.1),14,6));\n    uv -= off;\n    col = mix(col, vec3(1.), letter(uv*.75*r2d(.25),6,6));\n\n    return col;\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 col = vec3(0.);\n  \n  vec2 skyp = uv-vec2(0.,-1.75);\n  float a = atan(skyp.y,skyp.x)+iTime*.25;\n  vec3 sk = mix(vec3(0.863,0.486,0.196), vec3(0.875,0.125,0.424), sat(length(.5*uv-vec2(0.,-.5))));\n  col = mix(vec3(0.286,0.467,0.553), sk, pow(sat(texture(iChannel0, vec2(length(skyp)*.5,a*.1)*.5).x),.5));\n  col *= 1.-sat(length(uv)-.5);\n  col = pow(col, vec3(.75));\ncol += vec3(0.863,0.486,0.196)*(1.-sat(length(uv-vec2(0.,-.5))));\n\nfloat offh = 1.2;\n  vec3 ro = vec3(0.,1.5+offh,-7.);\n  vec3 ta = vec3(0.,-.15+offh,0.);\n  vec3 rd = normalize(ta-ro);\n\n  rd = getCam(rd,uv);\n  setup();\n  accCol = vec3(0.);\n  vec3 res = trace(ro,rd,128);\n  if (res.y>0.)\n  {\n    vec3 p = ro+rd*res.y;\n    vec3 n = getNorm(p,res.x);\n    col = n*.5+.5;\n    vec3 lpos = vec3(0.,5.,25.);\n    vec3 ldir = lpos-p;\n    vec3 h = normalize(rd+ldir);\n    if (res.z < 3.5)\n    {\n        vec3 pr = p-ovnip[int(res.z)].xyz;\n        col = vec3(0.349,0.235,0.447)*.25+vec3(0.722,0.667,0.875)*pow(texture(iChannel0, 3.*vec2(atan(pr.x, pr.z)*.1, 2.*length(pr))).x,2.);\n        float ndoth = sat(dot(n,h));\n       col *= sat(.5+ndoth);\n       col += vec3(0.863,0.486,0.196)*ndoth;\n\n    }   \n    if (res.z == 5.)\n    {\n        float rep = .1;\n            col = mix(col, vec3(1.),1.-sat(max(abs(uv.x)-0.08*pow(sat(-uv.y),2.),sin(uv.y*20.-iTime*10.))*400.));\n    }\n  }\n  col = drawPeople(col, uv-vec2(0.,.1));\n  col += accCol;\n  vec3 bucol = col;\n  col *= 1.-sat(drawText(uv*.95));\n  col += bucol.zxy*drawText(uv);\n  return col;\n}\n\nvec3 mixcol(vec3 col, vec2 uv)\n{\n    vec3 rgb = col;\n    \n    rgb.xy *= r2d(sin(iTime));\n    //rgb.yz *= r2d(-iTime*.5);\n    rgb = sat(rgb);\n    \n    return mix(col, rgb, sat(.5+.5*sin(uv.y*5.-iTime*3.)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord.xy-vec2(.5)*iResolution.xy) / iResolution.xx;\n  uv *= length(uv+vec2(sin(iTime), cos(iTime))*.2)+.8;\n  uv *= mix(1.,1.5,sat(sin(iTime*.5)*.5+.5));\n  vec3 col = rdr(uv*2.);\n  col = mixcol(col, uv);\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27702, "src": "https://soundcloud.com/lfttrax/helena-hauff-b2b-lft-october-6-7pm-9pm", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flS3D3.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[427, 427, 445, 445, 500], [524, 524, 552, 552, 603], [604, 604, 633, 633, 655], [657, 657, 686, 686, 762], [764, 764, 791, 791, 831], [833, 833, 862, 862, 886], [904, 904, 924, 924, 1413], [1415, 1415, 1433, 1433, 1942], [1943, 1943, 1967, 1967, 2263], [2277, 2277, 2318, 2318, 2709], [2711, 2711, 2742, 2742, 2891], [2893, 2893, 2924, 2924, 3032], [3034, 3034, 3048, 3048, 3218], [3220, 3220, 3255, 3255, 3765], [3767, 3767, 3803, 3803, 4135], [4137, 4137, 4178, 4178, 4514], [4516, 4516, 4540, 4540, 5277], [5279, 5279, 5298, 5298, 6795], [6797, 6797, 6829, 6829, 7004], [7006, 7006, 7063, 7063, 7315]], "test": "untested"}
{"id": "flXSzs", "name": "SDF antialiasing", "author": "Apos", "description": "Simple SDF antialiasing. You can click to see with aa off.", "tags": ["sdf", "antialiasing", "rectangle"], "likes": 1, "viewed": 332, "published": 3, "date": "1626280418", "time_retrieved": "2024-07-30T19:10:55.961920", "image_code": "// https://iquilezles.org/articles/distfunctions2d\n// https://drewcassidy.me/2020/06/26/sdf-antialiasing/\n\nfloat SDFCircle(vec2 p, float r) {\n    return length(p) - r;\n}\nfloat SDFRect(vec2 p, vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\nfloat Antialias(float d, float size) {\n    float texel = 1.0 / iResolution.y;\n    return mix(0.0, 1.0, smoothstep(0.0, texel * size, d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float d  = 0.0;\n    \n    if (uv.x < 0.5) {\n        d = SDFRect(p + vec2(1., 0.), vec2(0.3, 0.5));\n    } else {\n        d = SDFCircle(p - vec2(1.0, 0.), 0.2);\n    }\n\n    // Output to screen\n    if (iMouse.z > 0.0) {\n        fragColor = mix(vec4(1.0), vec4(0), Antialias(d, 0.0));\n    } else {\n        fragColor = mix(vec4(1.0), vec4(0), Antialias(d, 4.0));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flXSzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 141, 141, 169], [170, 170, 201, 201, 286], [287, 287, 325, 325, 426], [428, 428, 485, 535, 1002]], "test": "untested"}
{"id": "NsSSW3", "name": "Juno's position", "author": "z0rg", "description": "Description", "tags": ["triangles", "electro", "dnb"], "likes": 13, "viewed": 680, "published": 3, "date": "1626273665", "time_retrieved": "2024-07-30T19:10:56.808656", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat sdf_zicon(vec2 uv)\n{\n  float th = 0.02*2.;\n  float sz = 0.1;\n  float acc = 1000.;\n\n  acc = abs(cir(uv-vec2(.3), sz))-th;\n  acc = min(acc,abs(cir(uv-vec2(-.3), sz))-th);\n  acc = min(acc,abs(cir(uv-vec2(-.3,.3), sz*.7))-th);\n  acc = min(acc,abs(cir(uv-vec2(.3,-.35), sz*1.3))-th);\n\n  acc = min(acc, sqr(uv-vec2(-0.015,.3), vec2(.21,th)));\n  acc = min(acc, sqr((uv-vec2(-0.0,.0))*r2d(-PI/4.), vec2(.32,th)));\n  acc = min(acc, sqr((uv-vec2(-0.015,-.3))*r2d(0.1), vec2(.19,th)));\n\n    return acc;\n}\n\nvec3 doBloom(vec2 uv, float blur, float threshold)\n{\n    vec3 col;\n    int cnt = 50;\n    float fcnt = float(cnt);\n    for (int i = 0;i <cnt;++i)\n    {\n        float fi = float(i);\n        float coef = (fi/fcnt);\n        float sz = 1.+pow(coef,2.)*blur;\n        float samplePerTurn = 5.;\n        float an = (fi/(fcnt/samplePerTurn))*PI;\n        vec2 p = uv - vec2(sin(an), cos(an))*(fi/fcnt)*blur;\n        vec3 smple = texture(iChannel0, p).xyz;\n        if (length(smple) > threshold)\n            col += smple;\n    }\n    \n    return col/float(cnt);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    float bloomIntensity = 624./640.;  \n    vec3 bloomSample = doBloom(uv, 30./360., 217./ 640.);\n    bloomSample = pow(bloomSample, vec3(0.5));\n    \n    col = col + (bloomSample*bloomIntensity);\n    \n    col = mix(col, col.zyx, pow(sat(length(cuv*2.)),4.));\n    \n    col = mix(col, 1.-col.yzx, 1.-sat(sdf_zicon((cuv-vec2(.45, -.225))*15.)*40.));\n    \n    col = pow(col, vec3(1.75));\n\n    col *= sat(iTime-1.);\n    fragColor = vec4(col.yxz, 1.);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define FFT(a) texture(iChannel1, vec2(a, 0.)).x\n\nfloat _tri(vec2 p, float r)\n{\n    float a = atan(p.y, p.x);\n    /*\n    //p = vec2(length(\n    float s = 3.;\n    float stp = float(int((a)/s))*s;\n    vec2 uv = p*r2d(stp);*/\n    float s = 3.;\n    float as = PI*2.0/s;\n    \n    float ra = mod(a+.5*as, as)-.5*as;\n    \n    vec2 uv = length(p)*vec2(sin(ra),cos(ra)); \n    \n    return uv.y-r;\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = mix(vec3(.1), vec3(0.690,0.188,0.439), 1.-sat(length(uv*2.)));\n    \n    for (int i = 0; i < int(FFT(iTime*.1)*10.)+20; ++i)\n    {\n        float fi = 10.-float(i);\n\n        float sz = .3*pow(FFT(fi*.1),.5)+(sin(fi+iTime)*.2+1.)/(fi+1.);\n        float th = 0.1*fi/(fi+1.);\n        float t = abs(_tri(uv*r2d(fi*.1+iTime*(fi+1.)*.05), sz))-th;\n        vec3 rgb = vec3(0.);\n        if (mod(float(i), 2.) < 0.1)\n            rgb = vec3(0.969,0.212,0.478)*4.;\n        if (mod(fi, 3.) < 0.1)\n            rgb = rgb.zyx;\n        col = mix(col, rgb, (1.-sat(t*400.)));\n    }\n\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    uv *= 2.;\n    vec3 col = rdr(uv*2.*(sin(iTime*.5)+1.5))*.5;\n    \n    float stp = 0.01;\n    uv = floor(uv/stp)*stp;\n    col += rdr(uv*2.*(sin(iTime*.2)+1.5)).zxy*.5;\n    \n    fragColor = vec4(col/2.,1.0);\n}", "buffer_a_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.141592653\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\nfloat cir(vec2 uv, float r)\n{\n    return length(uv)-r;\n}\n\nfloat sqr(vec2 uv, vec2 s)\n{\n    vec2 l = abs(uv)-s;\n    return max(l.x, l.y);\n}", "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec3 rdrWaterDroplets(vec2 ouv, vec2 cuv)\n{\n    vec3 col = texture(iChannel0, ouv).xyz;\n    float mapA = -.5+(texture(iChannel1, cuv*.3+vec2(0., iTime*.005)).x*texture(iChannel1, cuv*.2).x);\n    mapA = pow(mapA, .5);\n    col = mapA*vec3(1.);\n    \n    vec2 off = vec2(dFdx(mapA), dFdy(mapA))*5.;\n    \n    col = mix(texture(iChannel0, ouv).xyz, texture(iChannel0, ouv-off).yzx, sat((length(cuv)-.25)*10.)*(1.-sat(length(off*2.))));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    vec3 col = rdrWaterDroplets(uv, cuv);\n    \n    { // Not so cheap antialiasing SSAA x4\n        //col = vec3(1.,0.,0.); // debug\n        vec2 off = vec2(1., -1.)/(iResolution.x*1.);\n        vec3 acc = col;\n        // To avoid too regular pattern yielding aliasing artifacts\n        mat2 rot = r2d(uv.y*5.); // a bit of value tweaking, appears to be working well\n        acc += rdrWaterDroplets(uv, cuv-off.xx);\n        acc += rdrWaterDroplets(uv, cuv-off.xy);\n        acc += rdrWaterDroplets(uv, cuv-off.yy);\n        acc += rdrWaterDroplets(uv, cuv-off.yx);\n        col = acc/5.;\n    }\n    //col += texture(iChannel0, uv).xyz;\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsSSW3.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 423, 423, 896], [898, 898, 950, 950, 1447], [1449, 1449, 1506, 1506, 2114]], "test": "untested"}
{"id": "flfSzl", "name": "Discrete String Simulation", "author": "Jordan", "description": "Use the mouse to give it a kick or put some waves in it, and check the \"Common\" tab for constants like n_particles stiffness and damping.\n\nI did this to teach myself how to use the buffer. This is my first attempt at a non cellular-automata buffer shader.", "tags": ["wave", "simulation", "string", "buffer", "discrete", "multipass", "acoustic", "pluck"], "likes": 4, "viewed": 370, "published": 3, "date": "1626273296", "time_retrieved": "2024-07-30T19:10:57.606523", "image_code": "// Fork of \"Buffer computed points.\" by patu. https://shadertoy.com/view/XllBRj\nvoid mainImage( out vec4 F, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.y -= .5;\n    uv *= 0.7;\n    // Start black\n    F = vec4(0.0,0.0,0.0,1.0);\n    // Draw the string dots\n    for (int p = 0; p < n_particles; p++) {\n        vec4 c = texelFetch(iChannel0, ivec2(0, p), 0);\n        F.r += smoothstep(0., 1., 1. / length(uv - c.xy) * .5*(0.001+abs(c[3])));//mix(F, abs(c.xyzw), smoothstep(0., 1., 1. / length(uv - c.xy) * .015));\n    }\n    // Draw the mouse\n    if (iMouse.z>0.){\n    F.b = 0.01/length(uv/0.7+vec2(0.5*iResolution.x / iResolution.y,0.5)-iMouse.xy/iResolution.y);\n    }\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "int n_particles = 80;\nfloat stiffness = 1.3;\nfloat damping = 0.006; \nfloat kick_strength = 0.005;\n\nfloat hash12(vec2 p) {\n\tfloat h = dot(p , vec2(127.1,311.7));\t\n    return fract(abs(sin(h)*43758.5453123));\n}", "buffer_a_code": "// C.x --> x-position\n// C.y --> y-position\n// C[2] --> (unused)\n// C[3] --> y-velocity\n\nvoid mainImage( out vec4 C, in vec2 fragCoord )\n{\n    C = vec4(0.0,0.0,0.0,0.0);\n    \n    if (int(fragCoord.x) == 0 && int(fragCoord.y) < n_particles) {   \n\n        if (iFrame == 0) {           \n            // initial position\n            C.x = (fragCoord.y / float(n_particles)) - 0.5;\n            if (int(fragCoord.y)>0 && int(fragCoord.y) < n_particles-1){\n                C.y = 0.4*sin(8.*3.14*C.x)*(C.x*C.x);\n            }\n            \n        // after first frame - move\n        } else {\n            // exclude endpoints\n            C = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n            if (int(fragCoord.y)>0 && int(fragCoord.y) < n_particles-1){\n                if ( length(C.x+0.5*iResolution.x / iResolution.y-iMouse.z/iResolution.y)<(2.0/float(n_particles))){//(hash12(vec2(hash12(fragCoord+iTime),0.1231*iTime))>0.999){\n                    // Random kicks\n                    C[3] -=kick_strength*(hash12(fragCoord+iTime+0.312349*fragCoord*iTime)+(C[2]-iMouse.y/iResolution.y)); \n                }\n                // Get neighbours\n                vec4 C_left = texelFetch(iChannel0, ivec2(fragCoord.x,fragCoord.y-1.0), 0); \n                vec4 C_right = texelFetch(iChannel0, ivec2(fragCoord.x,fragCoord.y+1.0), 0); \n                // Attraction to neighbours\n                C[3] -= stiffness*( C.y - (C_left.y+C_right.y)*0.5); \n                // Damping\n                C[3] *= 1.0-damping;\n                C.y += C[3];\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flfSzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 80, 129, 129, 759]], "test": "untested"}
{"id": "ftfSzl", "name": "Webcam fractals", "author": "kaihagseth", "description": "Wave to the camera!", "tags": ["fractal", "webcam"], "likes": 1, "viewed": 567, "published": 3, "date": "1626272560", "time_retrieved": "2024-07-30T19:10:58.365494", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 prevFrame = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    vec2 st = ( fragCoord * iChannelResolution[0].xy) / iResolution.xy;\n    vec4 currFrame = texelFetch(iChannel0, ivec2(st), 0);\n    fragColor = abs(currFrame - prevFrame);\n    //fragColor = currFrame;\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = ( fragCoord * iChannelResolution[0].xy) / iResolution.xy;\n    fragColor = texelFetch(iChannel0, ivec2(st), 0);\n}", "buffer_b_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "vec4 projection(vec2 pos, float scale, float angle, vec2 st)\n{\n    st = ( st /  iResolution. x) - .5;\n    st = st - pos;\n    st =  mat2 (cos(angle), -sin(angle), sin(angle), cos(angle)) * st;\n    st = st / scale;\n    st = ( (st + .5) *  iResolution.x);\n    return texelFetch(iChannel1, ivec2(st), 0) * .6;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 new = texelFetch(iChannel0, ivec2(fragCoord), 0);  \n    if (length(new) < 0.05) {\n        new = vec4(0.0);\n    }\n    vec4 p1 = projection( vec2(0.0, -0.2), .7 - (.26124*sin(iTime)), cos(iTime/5.4) * -1.115351, fragCoord) ;\n    vec4 p2 = projection(vec2(sin(iTime)*.2,-0.1), .7 - (.1516*sin(iTime/12.)), sin(iTime/4.0) * 1.12, fragCoord) ;\n    vec4 p3 = projection(vec2(sin(iTime)*.1,+0.1), .7 - (.123425*sin(iTime/12.)), sin(iTime/3.09509) * 1.12, fragCoord) ;\n    fragColor = new + p1 + p2 + p3 ;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftfSzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 120]], "test": "untested"}
{"id": "NtXSzl", "name": "Moving without travelling", "author": "mrange", "description": "License CC0: Moving without travelling", "tags": ["warpedfbm"], "likes": 28, "viewed": 1750, "published": 3, "date": "1626261436", "time_retrieved": "2024-07-30T19:10:59.121472", "image_code": "// License CC0: Moving without travelling\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define TTIME           (TAU*TIME)\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define BPERIOD         5.6\n#define PCOS(x)         (0.5+ 0.5*cos(x))\n#define BPM             150.0\n\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst vec3 std_gamma        = vec3(2.2);\n\nfloat g_th = 0.0;\nfloat g_hf = 0.0;\n\nvec2 g_vx = vec2(0.0);\nvec2 g_vy = vec2(0.0);\n\nvec2 g_wx = vec2(0.0);\nvec2 g_wy = vec2(0.0);\n\n// https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return -pmin(-a, a, k);\n}\n\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.0-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n}\n\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - pabs(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// Based on: https://iquilezles.org/articles/distfunctions2d\nfloat vesica(vec2 p, vec2 sz) {\n  if (sz.x < sz.y) {\n    sz = sz.yx;\n  } else {\n    p  = p.yx; \n  }\n  vec2 sz2 = sz*sz;\n  float d  = (sz2.x-sz2.y)/(2.0*sz.y);\n  float r  = sqrt(sz2.x+d*d);\n  float b  = sz.x;\n  p = abs(p);\n  return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                           : length(p-vec2(-d,0.0))-r;\n}\n\nfloat outerEye(vec2 p, float th) {\n  float a  = mix(0.0, 1.0, smoothstep(0.995, 1.0, cos(th+TTIME/BPERIOD)));\n  const float w = 1.14;\n  float h = mix(0.48, 0.05, a);\n  float d0 =  vesica(p, vec2(w, h));\n  return d0;\n}\n\nconst vec2 iris_center = vec2(0.0, 0.28);\nvec4 completeEye(vec2 p, float th) {\n  const float iris_outer = 0.622;\n  const float iris_inner = 0.285;\n  \n  float t0 = abs(0.9*p.x);\n  t0 *= t0;\n  t0 *= t0;\n  t0 *= t0;\n  t0 = clamp(t0, 0.0, 1.0);\n  float dt0 = mix(0.0125, -0.0025, t0);\n\n  vec2 p0 = p;\n  float d0 = outerEye(p, th);\n  float d5 = d0;\n\n  vec2 p1 = p;\n  p1 -= iris_center;\n  float d1 = circle(p1, iris_outer);\n  d1 = max(d1,d0+dt0);\n  float d6 = d1;\n\n  vec2 p2 = p;\n  p2 -= vec2(0.155, 0.35);\n  float d2 = circle(p2, 0.065);\n\n  vec2 p3 = p;\n  p3 -= iris_center;\n  p3 = toPolar(p3);\n  float n3 = mod1(p3.x, 0.05);\n  float d3 = abs(p3.x)-0.0125*(1.0-1.0*length(p1));\n\n  vec2 p4 = p;\n  p4 -= iris_center;\n  float d4 = circle(p4, iris_inner);\n\n  d3 = max(d3,-d4);\n\n  d1 = pmax(d1,-d2, 0.0125);\n  d1 = max(d1,-d3);\n\n  d0 = abs(d0)-dt0;\n\n  float d = d0;\n  d = pmin(d, d1, 0.0125);\n  return vec4(d, d6, d5, max(d4, d6));\n}\n\n\n// The path function\nvec3 offset(float z) {\n  float a = z;\n  vec2 p = -0.1*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));\n  return vec3(p, z);\n}\n\n// The derivate of the path function\n//  Used to generate where we are looking\nvec3 doffset(float z) {\n  float eps = 0.1;\n  return 0.5*(offset(z + eps) - offset(z - eps))/eps;\n}\n\n// The second derivate of the path function\n//  Used to generate tilt\nvec3 ddoffset(float z) {\n  float eps = 0.1;\n  return 0.125*(doffset(z + eps) - doffset(z - eps))/eps;\n}\n\nfloat noise(vec2 p) {\n  float a = sin(p.x);\n  float b = sin(p.y);\n  float c = 0.5 + 0.5*cos(p.x + p.y);\n  float d = mix(a, b, c);\n  return d;\n}\n\n// https://iquilezles.org/articles/fbm\nfloat fbm(vec2 p, float aa) {\n  const mat2 frot = mat2(0.80, 0.60, -0.60, 0.80);\n\n  float f = 0.0;\n  float a = 1.0;\n  float s = 0.0;\n  float m = 2.0;\n  for (int x = 0; x < 4; ++x) {\n    f += a*noise(p); \n    p = frot*p*m;\n    m += 0.01;\n    s += a;\n    a *= aa;\n  }\n  return f/s;\n}\n\n// https://iquilezles.org/articles/warp\nfloat warp(vec2 p, out vec2 v, out vec2 w) {\n  const float r  = 0.5;\n  const float rr = 0.25;\n  float l2 = length(p);\n  float f  = 1.0;\n\n  f = smoothstep(-0.1, 0.15, completeEye(p, g_th).x);\n  const float rep = 50.0;\n  const float sm = 0.125*0.5*60.0/rep;\n  float  n = smoothKaleidoscope(p, sm, rep);\n  p.y += TIME*0.125+1.5*g_th;\n\n  g_hf = f;\n  vec2 pp = p;\n\n  vec2 vx = g_vx;\n  vec2 vy = g_vy;\n\n  vec2 wx = g_wx;\n  vec2 wy = g_wy;\n\n\n  //float aa = mix(0.95, 0.25, tanh_approx(pp.x));\n  float aa = 0.5;\n\n  v = vec2(fbm(p + vx, aa), fbm(p + vy, aa))*f;\n  w = vec2(fbm(p + 3.0*v + wx, aa), fbm(p + 3.0*v + wy, aa))*f;\n  \n  return -tanh_approx(fbm(p + 2.25*w, aa)*f);\n}\n\nvec3 normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = warp(p + e.xy, v, w) - warp(p - e.xy, v, w);\n  n.y = 2.0*e.x;\n  n.z = warp(p + e.yx, v, w) - warp(p - e.yx, v, w);\n  \n  return normalize(n);\n}\n\nvoid compute_globals() {\n\n  vec2 vx = vec2(0.0, 0.0);\n  vec2 vy = vec2(3.2, 1.3);\n\n  vec2 wx = vec2(1.7, 9.2);\n  vec2 wy = vec2(8.3, 2.8);\n\n  vx *= ROT(TTIME/1000.0);\n  vy *= ROT(TTIME/900.0);\n\n  wx *= ROT(TTIME/800.0);\n  wy *= ROT(TTIME/700.0);\n  \n  g_vx = vx;\n  g_vy = vy;\n  \n  g_wx = wx;\n  g_wy = wy;\n}\n\nvec3 weird(vec2 p) {\n  const vec3 up  = vec3(0.0, 1.0, 0.0);\n  const vec3 lp1 = 1.0*vec3(1.0, 1.25, 1.0);\n  const vec3 lp2 = 1.0*vec3(-1.0, 2.5, 1.0);\n\n  vec3 ro = vec3(0.0, 10.0, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec2 v;\n  vec2 w;\n \n  float h  = warp(p, v, w);\n  float hf = g_hf;\n  vec3  n  = normal(p);\n\n  vec3 lcol1 = hsv2rgb(vec3(0.7, 0.5, 1.0)); \n  vec3 lcol2 = hsv2rgb(vec3(0.4, 0.5, 1.0));\n  vec3 po  = vec3(p.x, 0.0, p.y);\n  vec3 rd  = normalize(po - ro);\n  \n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3  ref   = reflect(rd, n);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  const vec3 col1 = vec3(0.1, 0.7, 0.8).xzy;\n  const vec3 col2 = vec3(0.7, 0.3, 0.5).zyx;\n  \n  float a = length(p);\n  vec3 col = vec3(0.0);\n//  col -= 0.5*hsv2rgb(vec3(fract(0.3*TIME+0.25*a+0.5*v.x), 0.85, abs(tanh_approx(v.y))));\n//  col -= 0.5*hsv2rgb(vec3(fract(-0.5*TIME+0.25*a+0.125*w.x), 0.85, abs(tanh_approx(w.y))));\n  col += hsv2rgb(vec3(fract(-0.1*TIME+0.125*a+0.5*v.x+0.125*w.x), abs(0.5+tanh_approx(v.y*w.y)), tanh_approx(0.1+abs(v.y-w.y))));\n  col -= 0.5*(length(v)*col1 + length(w)*col2*1.0);\n  /*\n  col += 0.25*diff1;\n  col += 0.25*diff2;\n  */\n  col += 0.5*lcol1*pow(ref1, 20.0);\n  col += 0.5*lcol2*pow(ref2, 10.0);\n  col *= hf;\n\n  return col;\n}\n\nvec4 plane3(vec3 ro, vec3 rd, vec3 pp, vec3 off, float aa, float n) {\n  float h = hash(n+1234.4);\n  float th = TAU*h;\n  g_th = th;\n  float s = 1.*mix(0.2, 0.3, h);\n\n  vec3 hn;\n  vec2 p = (pp-off*vec3(1.0, 1.0, 0.0)).xy;\n  p *= ROT(0.2*mix(-1.0, 1.0, h));\n  p /= s;\n  float lp = length(p); \n  p -= -iris_center;\n  const float lw = 0.005;\n  vec4 de = completeEye(p, th)*s;\n  float ax = smoothstep(-aa, aa, de.x);\n  float ay = smoothstep(-aa, aa, de.y);\n  float az = smoothstep(-aa, aa, -de.z);\n  float aw = smoothstep(-aa, aa, 0.0125*(de.w+0.025));\n\n  float df = 1.0-tanh_approx(0.5*lp);\n  vec3 acol = vec3(df);\n  vec3 icol = weird(p);\n  vec3 ecol = mix(vec3(0.0), vec3(1.0), ax);\n  vec3 bcol = mix(icol, ecol, az*0.5*df);\n  vec4 col = vec4(bcol, aw);\n\n  return col;\n}\n\nvec4 plane(vec3 ro, vec3 rd, vec3 pp, vec3 off, float aa, float n) {\n  return plane3(ro, rd, pp, off, aa, n);\n}\n\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  float ld = max(dot(rd, vec3(0.0, 0.0, 1.0)), 0.0);\n  vec3 baseCol = 1.0*vec3(2.0, 1.0, 3.0)*(pow(ld, 100.0));\n  return vec3(baseCol);\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  float lp = length(p);\n  vec2 np = p + 1.0/RESOLUTION.xy;\n  const float per = 10.0;\n  float rdd = (1.0+0.5*lp*tanh_approx(lp+0.9*PCOS(per*p.x)*PCOS(per*p.y)));\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);\n\n  const float planeDist = 1.0-0.0;\n  const int furthest = 4;\n  const int fadeFrom = max(furthest-3, 0);\n  const float fadeDist = planeDist*float(furthest - fadeFrom);\n  float nz = floor(ro.z / planeDist);\n\n  vec3 skyCol = skyColor(ro, rd);\n\n  // Steps from nearest to furthest plane and accumulates the color\n\n  vec4 acol = vec4(0.0);\n  const float cutOff = 0.95;\n  bool cutOut = false;\n  \n  for (int i = 1; i <= furthest; ++i) {\n    float pz = planeDist*nz + planeDist*float(i);\n\n    float pd = (pz - ro.z)/rd.z;\n\n    if (pd > 0.0 && acol.w < cutOff) {\n      vec3 pp = ro + rd*pd;\n      vec3 npp = ro + nrd*pd;\n\n      float aa = 3.0*length(pp - npp);\n\n      vec3 off = offset(pp.z);\n\n      vec4 pcol = plane(ro, rd, pp, off, aa, nz+float(i));\n\n      float nz = pp.z-ro.z;\n      float fadeIn = exp(-2.5*max((nz - planeDist*float(fadeFrom))/fadeDist, 0.0));\n      float fadeOut = smoothstep(0.0, planeDist*0.1, nz);\n      pcol.xyz = mix(skyCol, pcol.xyz, (fadeIn));\n      pcol.w *= fadeOut;\n\n      pcol = clamp(pcol, 0.0, 1.0);\n\n      acol = alphaBlend(pcol, acol);\n    } else {\n      cutOut = true;\n      break;\n    }\n\n  }\n\n  vec3 col = alphaBlend(skyCol, acol);\n// To debug cutouts due to transparency  \n//  col += cutOut ? vec3(1.0, -1.0, 0.0) : vec3(0.0);\n  return col;\n}\n\n// Classic post processing\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/std_gamma);\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  compute_globals();\n  \n  float tm  = TIME*0.5*BPM/60.0;\n  vec3 ro   = offset(tm);\n  vec3 dro  = doffset(tm);\n  vec3 ddro = ddoffset(tm);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));\n  vec3 vv = normalize(cross(ww, uu));\n\n  vec3 col = color(ww, uu, vv, ro, p);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, q);\n  col += smoothstep(3.0, 0.0, TIME);\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": 27809, "src": "https://soundcloud.com/jezbuddha/astral-traveller", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtXSzl.jpg", "access": "api", "license": "cc0-1.0", "functions": [[436, 436, 458, 458, 604], [980, 1020, 1059, 1059, 1148], [1150, 1150, 1189, 1189, 1218], [1220, 1220, 1250, 1250, 1278], [1280, 1280, 1302, 1302, 1350], [1352, 1352, 1392, 1392, 1551], [1553, 1553, 1593, 1593, 1635], [1637, 1637, 1665, 1685, 1761], [1763, 1795, 1834, 1834, 1959], [1961, 1961, 1983, 1983, 2027], [2029, 2029, 2050, 2050, 2095], [2097, 2097, 2142, 2142, 2296], [2298, 2298, 2359, 2359, 2572], [2574, 2574, 2605, 2605, 2631], [2633, 2694, 2725, 2725, 3023], [3025, 3025, 3059, 3059, 3242], [3286, 3286, 3322, 3322, 4167], [4170, 4191, 4213, 4213, 4345], [4347, 4426, 4449, 4449, 4524], [4526, 4596, 4620, 4620, 4699], [4701, 4701, 4722, 4722, 4844], [4846, 4885, 4914, 4914, 5166], [5168, 5208, 5252, 5252, 5875], [5877, 5877, 5898, 5898, 6120], [6122, 6122, 6146, 6146, 6427], [6429, 6429, 6449, 6449, 7828], [7830, 7830, 7899, 7899, 8596], [8598, 8598, 8666, 8666, 8709], [8712, 8712, 8745, 8745, 8883], [8885, 8885, 8941, 8941, 10479], [10481, 10508, 10544, 10544, 10777], [10779, 10779, 10808, 10808, 11138], [11140, 11140, 11195, 11195, 11419]], "test": "untested"}
{"id": "ftfSzX", "name": "California Daydream", "author": "chenglou", "description": "Using the Apple logo SDF.", "tags": ["raytracing", "sdf", "logo", "apple"], "likes": 3, "viewed": 361, "published": 3, "date": "1626256317", "time_retrieved": "2024-07-30T19:10:59.974193", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord),0);\n    fragColor = vec4(sqrt(data.rgb/data.w),1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float PI = 3.14159;\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat sdSphere( vec3 p, float r ) {\n    return length(p) - r;\n}\nfloat sdCircle( vec2 p, float r ) {\n    return length(p) - r;\n}\n\nmat3 rotate(float t) {\n    mat3 R = mat3(\n        vec3(cos(t), 0, sin(t)),\n        vec3(0, 1, 0),\n        vec3(-sin(t), 0, cos(t))\n    );\n    return R;\n}\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec3 hash32(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 random_in_unit_sphere(vec2 p)\n{\n    vec3 rand = hash32(p);\n    float phi = 2.0 * PI * rand.x;\n    float cosTheta = 2.0 * rand.y - 1.0;\n    float u = rand.z;\n\n    float theta = acos(cosTheta);\n    float r = pow(u, 1.0 / 3.0);\n\n    float x = r * sin(theta) * cos(phi);\n    float y = r * sin(theta) * sin(phi);\n    float z = r * cos(theta);\n\n    return vec3(x, y, z);\n}\nvec3 random_unit_vector(vec2 p) {\n    return normalize(random_in_unit_sphere(p));\n}\nbool near_zero(vec3 p) {\n    float s = 1e-8;\n    return p.x < s && p.y < s && p.z < s;\n}\n\nfloat sdApple(vec2 coord, float ra) {\n    float leaf1 = sdCircle(coord - vec2(-0.0161, 0.9658) * ra, 0.4447 * ra);\n    float leaf2 = sdCircle(coord - vec2(0.4628, 0.5473) * ra, 0.4567 * ra);\n\n    float shoulderLeft = sdCircle(coord - vec2(-0.3340, 0.0644) * ra, 0.4608 * ra);\n    float shoulderRight = sdCircle(coord - vec2(0.3964, 0.0382) * ra, 0.4909 * ra);\n\n    float bodyLeft = sdCircle(coord - vec2(-0.1227, -0.1831) * ra, 1.006 * ra);\n    float bodyCenter = sdCircle(coord - vec2(0.0141, -0.4889) * ra, 0.9256 * ra);\n    float bodyRight = sdCircle(coord - vec2(0.3662, -0.0483) * ra, 1.2052 * ra);\n    float bodyShoulderLeft = sdCircle(coord - vec2(-0.1791, -0.0624) * ra, 0.6640 * ra);\n\n    float buttLeft = sdCircle(coord - vec2(-0.2998, -0.7505) * ra, 0.2495 * ra);\n    float buttRight = sdCircle(coord - vec2(0.3803, -0.7505) * ra, 0.2495 * ra);\n\n    float bite = sdCircle(coord - vec2(1.0080, -0.0543) * ra, 0.4427 * ra);\n    float bottom = sdCircle(coord - vec2(0.0382, -1.4145) * ra, 0.4950 * ra);\n\n    float delimiterLeft = sdCircle(coord - vec2(-0.6398390342052314, 0.0201) * ra, 0.3320 * ra);\n\n    // assemble!\n    float leaf = opIntersection(leaf1, leaf2);\n    float tinyPieceLeft = opIntersection(delimiterLeft, bodyShoulderLeft) + 0.002 * ra; // random constant\n    float lowerPart = opIntersection(bodyLeft, opIntersection(bodyCenter, bodyRight));\n    float body;\n    body = opUnion(shoulderLeft, shoulderRight);\n    body = opSmoothUnion(body, lowerPart, 0.121 * ra); // random constant\n    body = opUnion(body, tinyPieceLeft);\n    body = opUnion(body, leaf);\n    body = opSubtraction(bite, body);\n    body = opSmoothSubtraction(bottom, body, 0.189 * ra); // random constant\n\n    return body;\n}\n\nfloat map(vec3 p, vec2 iMouse, float iTime) {\n    vec3 shift = (p - vec3(0., 0.06, 0.01)) * rotate(iTime);\n    \n    float s1 = sdApple(shift.xy, 1./3.);\n    s1 = opExtrussion(shift, s1, 0.066);\n    // if inside of apple, flip it\n    s1 = abs(s1);\n\n    float s2 = sdSphere(p - vec3(0., -1.7, 0.), 1.43);    \n\n    return opUnion(s1, s2);\n}\n\nvec3 calcNormal( in vec3 p, vec2 iMouse, float iTime) // for function f(p)\n{\n    const float eps = 1e-7; // or some other value\n    const vec2 h = vec2(eps, 0);\n    return normalize( vec3(map(p+h.xyy, iMouse, iTime) - map(p-h.xyy, iMouse, iTime),\n                           map(p+h.yxy, iMouse, iTime) - map(p-h.yxy, iMouse, iTime),\n                           map(p+h.yyx, iMouse, iTime) - map(p-h.yyx, iMouse, iTime) ) );\n}\n\nfloat maxT = 12.;\nbool rayMarch(vec3 ro, vec3 rd, vec2 iMouse, float iTime, out float t) {\n    t = 1e-4;\n    for(int i = 0; i < 18; i++) {\n        vec3 p = ro + t*rd;\n        float h = map(p, iMouse, iTime);\n        if( abs(h) < 1e-5) {\n            return true;\n        }\n\n        if (t > maxT) {\n            return false;\n        }\n        t += h;\n    }\n    return true;\n}\n\nvec3 skyCol = vec3(0.6, 0.7, .7);\nvec3 appleCol = vec3(0.5, 0.5, .8);\n\nvec3 rayColor(vec3 ro, vec3 rd, vec2 iMouse, float iTime, vec2 seed) {\n    vec3 color = vec3(1);\n    \n    vec3 ro_ = ro;\n    vec3 rd_ = rd;\n    for (int i = 0; i < 5; i++) {\n        float t;\n        if (rayMarch(ro_, rd_, iMouse, iTime, t)) {\n            vec3 pos = ro_ + rd_ * t;\n            vec3 normal = calcNormal(pos, iMouse, iTime);            \n            \n            vec3 scatter_direction = normal + random_unit_vector(seed + float(i));\n            // catch degenerate scatter direction\n            if (near_zero(scatter_direction)) {\n                scatter_direction = normal;\n            }\n            ro_ = pos;\n            rd_ = scatter_direction;\n            \n            color *= appleCol;\n        } else {\n            vec3 unit_direction = normalize(rd);\n            float t = 0.5 * (unit_direction.y + 1.0);\n            color *= mix(appleCol, skyCol, t);\n            return color;\n        }\n    }\n    \n    return vec3(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (ivec2(fragCoord) == ivec2(0)) {\n        fragColor = iResolution.xyxy;\n    } else {\n        vec3 ro = vec3(0., 0., 0.28);\n\n        vec2 rand = hash22(fragCoord + iTime * 999.);\n        vec2 coord = fragCoord + rand;\n        coord = (2. * fragCoord - iResolution.xy) / iResolution.y;\n        \n        vec3 rd = normalize(vec3(coord, 0) - ro);\n        vec3 col = rayColor(ro, rd, iMouse.xy, iTime, fragCoord + rand);\n\n        if (texelFetch(iChannel0, ivec2(0), 0).xy == iResolution.xy) {        \n            fragColor = vec4(col,1) * .1 + texelFetch(iChannel0, ivec2(fragCoord), 0) * .9;\n        } else {        \n            fragColor = vec4(col,1);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftfSzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 167]], "test": "untested"}
{"id": "ftXSzX", "name": "Apple Logo SDF", "author": "chenglou", "description": "Apple logo uses cubic bezier. This approximates it to a high fidelity with only circles + smoothing. Maybe it's better to just use the cubic beziers?\n\nSee comment for details. Original sizes at https://www.shadertoy.com/view/NtsXRM", "tags": ["raytracing", "sdf", "logo", "apple"], "likes": 6, "viewed": 491, "published": 3, "date": "1626256308", "time_retrieved": "2024-07-30T19:11:01.025382", "image_code": "/*\nThe circles over the Apple logo are manually approximated in a Figma file:\nhttps://www.figma.com/file/ywGtT2aMhG04cuvz2MKF0d/Apple-soft-3D-Community?node-id=0%3A1\nThen converted from Figma's coordinate system, where:\n- y increases downward\n- sizes aren't normalized\n- origin of the circles are on the upper left\n- circles are specified using width instead of radius\n*/\n\nfloat sdCircle( vec2 p, float r ) { return length(p) - r; }\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h ) {\n    vec2 w = vec2( sdf, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat sdApple(vec2 coord, float ra) {\n    float leaf1 = sdCircle(coord - vec2(-0.0161, 0.9658) * ra, 0.4447 * ra);\n    float leaf2 = sdCircle(coord - vec2(0.4628, 0.5473) * ra, 0.4567 * ra);\n\n    float shoulderLeft = sdCircle(coord - vec2(-0.3340, 0.0644) * ra, 0.4608 * ra);\n    float shoulderRight = sdCircle(coord - vec2(0.3964, 0.0382) * ra, 0.4909 * ra);\n\n    float bodyLeft = sdCircle(coord - vec2(-0.1227, -0.1831) * ra, 1.006 * ra);\n    float bodyCenter = sdCircle(coord - vec2(0.0141, -0.4889) * ra, 0.9256 * ra);\n    float bodyRight = sdCircle(coord - vec2(0.3662, -0.0483) * ra, 1.2052 * ra);\n    float bodyShoulderLeft = sdCircle(coord - vec2(-0.1791, -0.0624) * ra, 0.6640 * ra);\n\n    float bite = sdCircle(coord - vec2(1.0080, -0.0543) * ra, 0.4427 * ra);\n    float bottom = sdCircle(coord - vec2(0.0382, -1.4145) * ra, 0.4950 * ra);\n\n    float delimiterLeft = sdCircle(coord - vec2(-0.6398390342052314, 0.0201) * ra, 0.3320 * ra);\n\n    // assemble!\n    float leaf = opIntersection(leaf1, leaf2);\n    float tinyPieceLeft = opIntersection(delimiterLeft, bodyShoulderLeft) + 0.002 * ra; // random constant\n    float lowerPart = opIntersection(bodyLeft, opIntersection(bodyCenter, bodyRight));\n    float body;\n    body = opUnion(shoulderLeft, shoulderRight);\n    body = opSmoothUnion(body, lowerPart, 0.121 * ra); // random constant\n    body = opUnion(body, tinyPieceLeft);\n    body = opUnion(body, leaf);\n    body = opSubtraction(bite, body);\n    body = opSmoothSubtraction(bottom, body, 0.189 * ra); // random constant\n\n    return body;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 mouse = (2. * iMouse.xy - iResolution.xy) / iResolution.y;\n\n    float body = sdApple(coord, .5);\n    \n    vec3 col = vec3(1.0) - sign(body) * vec3(0.1,0.4,0.7);\n    col *= 1.0 - exp(-3.0 * abs(body));\n    col *= 0.8 + 0.2 * cos(150.0 * body);\n    col = mix(col, vec3(1.0), 1.0 - smoothstep(0.0,0.01, abs(body)));\n    \n    if(iMouse.z > 0.001) {\n        vec2 m = mouse; vec2 p = coord;\n        float d = sdApple(m, .5);\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXSzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[373, 373, 408, 408, 432], [434, 434, 471, 471, 492], [494, 494, 537, 537, 559], [561, 561, 605, 605, 626], [628, 628, 680, 680, 780], [782, 782, 840, 840, 941], [943, 943, 1002, 1002, 1099], [1101, 1101, 1138, 1138, 2652], [2654, 2654, 2711, 2711, 3441]], "test": "untested"}
{"id": "NtsXRM", "name": "Apple Logo SDF Draft", "author": "chenglou", "description": "Apple logo uses cubic bezier. This closely approximates it with only circles + smoothing. Maybe it's better to just use the cubic beziers?\n\nSee comment for details. Click to reveal the composing circles. Cleaned up: https://www.shadertoy.com/view/ftXSzX", "tags": ["raytracing", "sdf", "logo", "apple"], "likes": 2, "viewed": 289, "published": 3, "date": "1626256303", "time_retrieved": "2024-07-30T19:11:01.866134", "image_code": "/*\nThe circles of the logo are manually approximated in a Figma file:\nhttps://www.figma.com/file/ywGtT2aMhG04cuvz2MKF0d/Apple-soft-3D-Community?node-id=0%3A1\nThen converted from Figma's coordinate system, where:\n- y increases downward\n- sizes aren't normalized to 0 - 1\n- origin of the circles are on the upper left\n- circles are specified using width instead of radius\n\nSee convertCoords below\n*/\n\nfloat sdCircle( vec2 p, float r ) { return length(p) - r; }\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h ) {\n    vec2 w = vec2( sdf, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat ratio = 3./3.;\nfloat width = 419.;\nfloat height = 497.;\n\nfloat convertCoords(vec2 coord, vec3 xyr) {\n    float r = xyr.z / 2.;\n    vec2 absolute = vec2(xyr.x - width / 2., height / 2. - xyr.y) + vec2(r, -r);\n    return sdCircle(coord - absolute * ratio / height * 2., r * ratio / height * 2.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\n    float leaf1 = convertCoords(coord, vec3(95, -102, 221));\n    float leaf2 = convertCoords(coord, vec3(211, -1, 227));\n\n    float shoulderLeft = convertCoords(coord, vec3(12, 118, 229));\n    float shoulderRight = convertCoords(coord, vec3(186, 117, 244));\n\n    float bodyLeft = convertCoords(coord, vec3(-71, 44, 500));\n    float bodyCenter = convertCoords(coord, vec3(-17, 140, 460));\n    float bodyRight = convertCoords(coord, vec3(1, -39, 599));\n    float bodyShoulderLeft = convertCoords(coord, vec3(0, 99, 330));\n\n    float bite = convertCoords(coord, vec3(350, 152, 220));\n    float bottom = convertCoords(coord, vec3(96, 477, 246));\n\n    float delimiterLeft = convertCoords(coord, vec3(-32, 161, 165));\n    \n\n    float leaf = opIntersection(leaf1, leaf2);\n    float tinyPieceLeft = opIntersection(delimiterLeft, bodyShoulderLeft) + 0.994 * ratio / height; // random constant\n    float lowerPart = opIntersection(bodyLeft, opIntersection(bodyCenter, bodyRight));\n    \n    float body;\n    body = opUnion(shoulderLeft, shoulderRight);\n    body = opSmoothUnion(body, lowerPart, 60. * ratio / height); // random constant\n    body = opUnion(body, tinyPieceLeft);\n    body = opUnion(body, leaf);\n    body = opSubtraction(bite, body);\n    body = opSmoothSubtraction(bottom, body, 94. * ratio / height); // random constant\n    \n    \n    vec3 color = vec3(1.0) - sign(body) * vec3(0.1,0.4,0.7);\n    color *= 1.0 - exp(-3.0 * abs(body));\n    color *= 0.8 + 0.2 * cos(150.0 * body);\n    color = mix(color, vec3(1.0), 1.0 - smoothstep(0.0,0.01, abs(body)));\n\n    float line = 0.002;\n    if (iMouse.z > 0.001 &&\n        (abs(leaf1) < line\n        || abs(leaf2) < line\n        || abs(bite) < line\n        || abs(shoulderLeft) < line\n        || abs(shoulderRight) < line\n        || abs(bottom) < line\n        || abs(bodyRight) < line\n        || abs(bodyLeft) < line\n        || abs(bodyShoulderLeft) < line\n        || abs(bodyCenter) < line\n        || abs(delimiterLeft) < line)\n    ) {\n        color = vec3(1, 1, 0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsXRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[399, 399, 434, 434, 458], [460, 460, 497, 497, 518], [520, 520, 563, 563, 585], [587, 587, 631, 631, 652], [654, 654, 706, 706, 806], [808, 808, 866, 866, 967], [969, 969, 1028, 1028, 1125], [1190, 1190, 1233, 1233, 1428], [1430, 1430, 1487, 1487, 3613]], "test": "untested"}
{"id": "NtlXzf", "name": "Zi7ar21's KIFS", "author": "Zi7ar21", "description": "This shader looks really good and runs pretty fast!", "tags": ["raymarching", "fractal", "ray", "raymarch", "raymarched", "raymarcher", "kifs", "march"], "likes": 11, "viewed": 405, "published": 3, "date": "1626233430", "time_retrieved": "2024-07-30T19:11:02.718855", "image_code": "// ####### Zi7ar21's KIFS #######\n// Made by Jacob Bingham (Zi7ar21) on July 13th, 2021\n\n// Last Updated on July 13th, 2021 at 21:20 Mountain Standard Time\n\n// If you found this anywhere except Shadertoy, the original and possibly updated version can be found at:\n// https://www.shadertoy.com/view/NtlXzf\n\n// \"License\":\n// You can use this code in any way you want, as long as you keep credits to things that aren't mine\n// e.g. Triple32: https://nullprogram.com/blog/2018/07/31/\n// We are programmers, not lawyers! :)\n\n/*\nIt's crazy just how simple a KIFS fractal is!\n\nFeatures:\n- KIFS Fractal\n- Ray-Marching\n- Soft Shadows\n- Glow\n- Orbit Trap Colors\n- Animation\n*/\n\n// Check out my friends!\n// michael0884\n// https://www.shadertoy.com/user/michael0884\n// loicvdb\n// https://www.shadertoy.com/user/loicvdb\n// Dumb_Psycho\n// https://www.shadertoy.com/user/Dumb_Psycho\n// peabrainiac\n// https://www.shadertoy.com/user/peabrainiac\n\n// ##### Parameters #####\n\n// Camera Field of View\n#define camfov 1.0\n\n// Tonemap Exposure\n#define exposure 1.0\n\n// Maximum Ray-Marching Steps\n#define maxStep 128\n\n// Distance Considered a Collision\n#define hitDist 1E-3\n\n// Maximum Ray-Marching Distance\n#define maxDist 4.0\n\n// Maximum Shadow Ray Distance\n#define shadowDist 2.0\n\n// ##### Preprocessor #####\n\n// I don't know if I am using these properly so I will leave them disabled by default\n//#pragma optimize(on)\n//#pragma debug(off)\n\n// ##### Constants #####\n\n// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\n#define pi 3.141592653589793\n\n// Traditional Uniform Identifiers\n#define resolution iResolution\n#define frame iFrame\n#define time iTime\n//#define time (float(frame)/60.0)\n//#define time 0.0\n\n// ##### Rendering #####\n\n// Rotate a 3-Component Vector\nvec3 rotate(vec3 vec, vec3 rot)\n{\n    vec3 s = sin(rot), c = cos(rot);\n\n    mat3 rotx = mat3(\n    1.0, 0.0, 0.0,\n    0.0, c.x,-s.x,\n    0.0, s.x, c.x);\n    mat3 roty = mat3(\n    c.y, 0.0,-s.y,\n    0.0, 1.0, 0.0,\n    s.y, 0.0, c.y);\n    mat3 rotz = mat3(\n    c.z,-s.z, 0.0,\n    s.z, c.z, 0.0,\n    0.0, 0.0, 1.0);\n\n    mat3 rotmat = rotx*roty*rotz;\n\n    /*\n    rotmat[0] = normalize(rotmat[0]);\n    rotmat[1] = normalize(rotmat[1]);\n    rotmat[2] = normalize(rotmat[2]);\n    */\n\n    return (vec.x*rotmat[0])+(vec.y*rotmat[1])+(vec.z*rotmat[2]);\n}\n\n// Root Object SDF\nfloat SDF(vec3 pos)\n{\n    // Sphere\n    //return length(pos)-1.0;\n\n    // Cube\n    //pos = abs(pos);\n    return max(max(pos.x, pos.y), pos.z)-1.0;\n}\n\n// Zi7ar21's KIFS SDF: https://www.shadertoy.com/view/NtlXzf\nfloat DE(in vec3 pos, out vec3 orbitTrap)\n{\n    // Fractal Parameters\n    vec3 rot = mod(vec3(time*pi*0.05, -0.5+(time*pi*0.023), 0.3+(time*pi*0.03)), 2.0);\n    //const vec3 rot = vec3(-0.6, -0.5, 0.3);\n    const vec3 translate = vec3(-0.1, -0.23, -0.17);\n    const float scale = 1.3;\n\n    // Set-Up Variables\n    orbitTrap = vec3(10.0);\n    float t = 1.0;\n\n    // Iterate the Fractal\n    for(int i = 0; i < 16; i++)\n    {\n        // Scale\n        pos *= scale;\n        t *= scale;\n\n        // Rotate\n        pos = rotate(pos, rot*pi);\n\n        // Mirror\n        pos = abs(pos);\n\n        // Orbit Trap\n        orbitTrap = min(pos, orbitTrap);\n\n        // Translate\n        pos += translate;\n    }\n\n    // Return the Distance Estimate\n    return SDF(pos)/t;\n}\n\n// SDF Tetrahedron Numerical Normals\nvec3 sampleNormal(vec3 pos)\n{\n    const vec2 k = vec2(-1.0, 1.0);\n    vec3 n;\n    return normalize(\n    k.xxx*DE(pos+k.xxx*hitDist, n)+\n    k.xyy*DE(pos+k.xyy*hitDist, n)+\n    k.yxy*DE(pos+k.yxy*hitDist, n)+\n    k.yyx*DE(pos+k.yyx*hitDist, n));\n}\n\n// Distance Estimator Soft Shadows\nfloat sampleLight(vec3 ro, vec3 rd)\n{\n    float res = 1.0;\n    float t = 0.0;\n    float ph = 1E4;\n    vec3 n;\n    for(int i = 0; i < maxStep; i++)\n    {\n        float h = DE(ro+rd*t, n);\n        float y = i == 0 ? 0.0 : h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n\n        res = min(res, 10.0*d/max(0.0, t-y));\n\n        t += h;\n\n        if(res < hitDist || t > shadowDist){break;}\n    }\n\n    res = clamp(res, 0.0, 1.0);\n\n    return res*res*(3.0-2.0*res);\n}\n\n// Intersection Structure\nstruct intersection {\n    float tMin;\n    float tMax;\n    bool hit;\n    bool expire;\n    vec3 normal;\n    vec3 albedo;\n    vec3 emission;\n};\n\n// Ray-Marching\nintersection trace(vec3 ro, vec3 rd)\n{\n    // Set-Up Variables\n    float t = 0.0;\n    vec3 emission = vec3(0.0);\n    vec3 color = vec3(0.0);\n\n    // Ray-Marching\n    for(int i = 0; i < maxStep; i++)\n    {\n        // Check if the Ray \"Hit\" the Background\n        if(t > maxDist)\n        {\n            // Return the Intersection Data\n            return intersection(-1.0, -1.0, false, false, vec3(0.0), vec3(1.0, 0.0, 1.0), emission);\n        }\n\n        float td = DE(ro+rd*t, color);\n\n        // Check if the Ray Hit the Scene\n        if(td < hitDist)\n        {\n            // Return the Intersection Data\n            return intersection(t, -1.0, true, false, sampleNormal(ro+rd*t), clamp(color*10.0, 0.0, 1.0), emission);\n        }\n\n        // Add to Glow\n        emission += max(exp(-td*10.0), 0.0)*0.03;\n\n        // \"March\" the Ray\n        t += td;\n    }\n\n    // Ray Expired (Increase maxStep!)\n    return intersection(-1.0, -1.0, false, true, vec3(0.0), vec3(1.0, 0.0, 1.0), vec3(0.0));\n}\n\n// Rendering\nvec3 radiance(vec3 ro, vec3 rd)\n{\n    // Compute the Intersection\n    intersection t = trace(ro, rd);\n\n    // If the Ray expired, output Debug Magenta color\n    if(t.expire)\n    {\n        // Magenta/Cyan Pattern\n        //return int(gl_FragCoord.x+gl_FragCoord.y)/4 % 2 == 0 ? vec3(10.000, 00.000, 10.000) : vec3(00.000, 10.000, 10.000);\n\n        // Magenta\n        return vec3(100.0, 0.0, 100.0);\n    }\n\n    // If the Ray never hit anything, output the background color\n    if(!t.hit)\n    {\n        return vec3(0.000, 0.000, 0.000)+t.emission;\n    }\n\n    // Light Direction\n    const vec3 lightDirection = vec3(0.577350269189626, 0.577350269189626, 0.577350269189626);\n\n    // Compute Lighting\n    float lighting0 = sampleLight(ro+rd*t.tMin, lightDirection);\n    float lighting1 = max(dot(t.normal, lightDirection), 0.0)*0.95;\n    float lighting2 = max(dot(t.normal,-lightDirection), 0.0)*0.15;\n\n    // Output the Final Color\n    return t.albedo*lighting0*(lighting1+lighting2+0.05)+t.emission;\n}\n\n// Render and Output the Frame\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Screen UV Coordinates\n    vec2 uv = 2.0*(gl_FragCoord.xy-0.5*resolution.xy)/max(resolution.x, resolution.y);\n\n    // Set-Up Camera\n    const vec3 ro = vec3(0.0, 0.0, 2.0);\n    const mat3 rotmat = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n    vec3 rd = normalize(vec3(camfov*uv, -1.0)*rotmat);\n\n    // Render the Frame\n    vec3 color = radiance(ro, rd);\n\n    // HDR Tonemapping\n    color = clamp(1.0-exp(-max(color, 0.0)*exposure), 0.0, 1.0);\n\n    // Output the Rendered Frame\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtlXzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1761, 1792, 1825, 1825, 2336], [2338, 2357, 2378, 2457, 2505], [2507, 2568, 2611, 2637, 3326], [3328, 3365, 3394, 3394, 3611], [3613, 3648, 3685, 3685, 4107], [4277, 4293, 4331, 4355, 5284], [5286, 5299, 5332, 5364, 6296], [6298, 6329, 6384, 6413, 6912]], "test": "untested"}
{"id": "7lfXRf", "name": "redec-red-ray", "author": "firebreathz", "description": "Applying some God rays, post process, to a simple raymarched scene. Inspired by Passion's \"Blue Dream\" ... and a lot of old demos. :)", "tags": ["raymarching", "blur", "radial", "godrays"], "likes": 5, "viewed": 384, "published": 3, "date": "1626228367", "time_retrieved": "2024-07-30T19:11:03.791985", "image_code": "\n/*\n\tInspired by:\n    \n    Full Scene Radial Blur\n    https://www.shadertoy.com/view/XsKGRW\n    \n    Sound sinus wave\n    https://www.shadertoy.com/view/XsX3zS\n\n\tBlue Dream - Passion\n\thttps://www.shadertoy.com/view/MdG3RD\n\n\tRadial Blur - IQ\n\thttps://www.shadertoy.com/view/4sfGRn\n\n\tRays of Blinding Light - mu6k\n\thttps://www.shadertoy.com/view/lsf3Dn\n\n*/\n\n// The radial blur section. Shadertoy user, Passion, did a good enough job, so I've used a\n// slightly trimmed down version of that. By the way, there are accumulative weighting \n// methods that do a slightly better job, but this method is good enough for this example.\n\n\n// Radial blur samples. More is always better, but there's frame rate to consider.\nconst float SAMPLES = 40.; \n\n\n// 2x1 hash. Used to jitter the samples.\nfloat hash( vec2 p ){ return fract(sin(dot(p, vec2(1, 289)))*45758.5453); }\n\n\n// Light offset.\n//\n// I realized, after a while, that determining the correct light position doesn't help, since \n// radial blur doesn't really look right unless its focus point is within the screen boundaries, \n// whereas the light is often out of frame. Therefore, I decided to go for something that at \n// least gives the feel of following the light. In this case, I normalized the light position \n// and rotated it in unison with the camera rotation. Hacky, for sure, but who's checking? :)\nvec3 lOff(){    \n    \n    vec2 u = sin(vec2(.57, 0) - iTime/01.);\n    mat2 a = mat2(u, -u.y, u.x);\n    \n    vec3 l = normalize(vec3(.5, 1., -0.95));\n    l.xz = a * l.xz;\n    l.xy = a * l.xy;\n    \n    return l;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // Screen coordinates.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Radial blur factors.\n    //\n    // Falloff, as we radiate outwards.\n    float decay = 0.99; \n    // Controls the sample density, which in turn, controls the sample spread.\n    float density = 0.32; \n    // Sample weight. Decays as we radiate outwards.\n    float weight = 0.51; \n    \n    // Light offset. Kind of fake. See above.\n    vec3 l = lOff();\n    \n    // Offset texture position (uv - .5), offset again by the fake light movement.\n    // It's used to set the blur direction (a direction vector of sorts), and is used \n    // later to center the spotlight.\n    //\n    // The range is centered on zero, which allows the accumulation to spread out in\n    // all directions. Ie; It's radial.\n    vec2 tuv =  uv - .5 - l.xy*.45;\n    \n    // Dividing the direction vector above by the sample number and a density factor\n    // which controls how far the blur spreads out. Higher density means a greater \n    // blur radius.\n    vec2 dTuv = tuv*density/SAMPLES;\n    \n    // Grabbing a portion of the initial texture sample. Higher numbers will make the\n    // scene a little clearer, but I'm going for a bit of abstraction.\n    vec4 col = texture(iChannel0, uv.xy)*0.25;\n    \n    // Jittering, to get rid of banding. Vitally important when accumulating discontinuous \n    // samples, especially when only a few layers are being used.\n    uv += dTuv*(hash(uv.xy + fract(iTime))*0.2 - 1.);\n    \n    // The radial blur loop. Take a texture sample, move a little in the direction of\n    // the radial direction vector (dTuv) then take another, slightly less weighted,\n    // sample, add it to the total, then repeat the process until done.\n    for(float i=0.; i < SAMPLES; i++){\n    \n        uv -= dTuv;\n        col += texture(iChannel0, uv) * weight;\n        weight *= decay;\n        \n    }\n    \n    // Multiplying the final color with a spotlight centered on the focal point of the radial\n    // blur. It's a nice finishing touch... that Passion came up with. If it's a good idea,\n    // it didn't come from me. :)\n    col *= (1. - dot(tuv, tuv)*.075);\n    \n    // Smoothstepping the final color, just to bring it out a bit, then applying some \n    // loose gamma correction.\n    fragColor = sqrt(smoothstep(0., 1., col));\n    \n    // Bypassing the radial blur to show the raymarched scene on its own.\n    //fragColor = sqrt(texture(iChannel0, fragCoord.xy / iResolution.xy));\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// The scene itself. Not much commenting, since this is mainly about the radial blur,\n// plus a lot of it is rudimentary.\n\n#define FAR 2000.\n\n// Hash.\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tpl( sampler2D t, in vec3 p, in vec3 n ){\n   \n    n = max(abs(n), 0.001);\n    n /= (n.x + n.y + n.z );  \n\tp = (texture(t, p.yz)*n.x + texture(t, p.zx)*n.y + texture(t, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// A simple, cheap but visually effective sinusoid based lattice. The downside to building\n// a scene with transcendentals is the honing difficulty, but the logarithmic based\n// \"Logarithmmic Bisection\" tracing method counters that.\nfloat map(in vec3 p){\n   \n    // A few small bumps to put on the surface.\n    float bump = (dot(sin(p*24. - cos(p.yzx*36.)), vec3(.015)));\n    \n    // Perturbing the surface slightly, prior to construction.\n    p += sin(p*8. + 3.14159)*.1;\n    \n    // The main surface. A weird, molecular looking lattice.\n    float n = dot(sin(p*2.), cos(p.yzx*2.));\n    \n \t// Clamping the surface value, and adding the bumps.\n    //return (clamp(0., -1.1, n) + 1.1)/1.1 + bump;\n    return (min(n, 0.) + 1.1)/1.1 + bump;\n    \n}\n\n \n// Ambient occlusion, for that self shadowed look.\n// XT95 came up with this particular version. Very nice.\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat cao( in vec3 p, in vec3 n, float maxDist )\n{\n\tfloat ao = 0.0, l;\n\tconst float nbIte = 6.0;\n\tconst float falloff = 1.5;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i + hash(i))*.5/nbIte*maxDist;\n        ao += (l - map( p + n*l ))/ pow(1. + l, falloff);\n    }\n\t\n    return clamp( 1.-ao/nbIte, 0., 1.);\n}\n\n// Tetrahedral normal, courtesy of IQ.\nvec3 nr(in vec3 p)\n{  \n    vec2 e = vec2(-1, 1)*.001;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n// A trimmed down version of Nimitz's \"Log Bisecion\" method. Very effective on\n// difficult to hone in on things like weird, transcendental surfaces.\n// Worth studying, if you're not familiar with it.\n//\n// Log-Bisection Tracing - Nimitz\n// https://www.shadertoy.com/view/4sSXzD\nfloat logBisectTrace( in vec3 ro, in vec3 rd){\n\n\n    float t = 0., told = 0., mid, dn;\n    float d = map(rd*t + ro);\n    float sgn = sign(d);\n\n    for (int i=0; i<64; i++){\n\n        // If the threshold is crossed with no detection, use the bisection method.\n        // Also, break for the usual reasons. Note that there's only one \"break\"\n        // statement in the loop. I heard GPUs like that... but who knows?\n        if (sign(d) != sgn || d < 0.001 || t > FAR) break;\n \n        told = t;\n        \n        // Branchless version of the following:  \n        // if(d>1.) t += d*.5; else t += log(abs(d) + 1.1)*.5;\n        t += step(d, 1.)*(log(abs(d) + 1.1)*.5 - d*.5) + d*.5;\n       \n        d = map(rd*t + ro);\n    }\n    \n    // If a threshold was crossed without a solution, use the bisection method.\n    if (sign(d) != sgn){\n    \n        // Based on suggestions from CeeJayDK, with some minor changes.\n\n        dn = sign(map(rd*told + ro));\n        \n        vec2 iv = vec2(told, t); // Near, Far\n\n        // 6 iterations seems to be more than enough, for most cases...\n        // but there's an early exit, so I've added a couple more.\n        for (int ii=0; ii<8; ii++){ \n            //Evaluate midpoint\n            mid = dot(iv, vec2(.5));\n            float d = map(rd*mid + ro);\n            if (abs(d) < 0.001)break;\n            // Suggestion from movAX13h - Shadertoy is one of those rare\n            // sites with helpful commenters. :)\n            // Set mid to near or far, depending on which side we're on.\n            iv = mix(vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn));\n        }\n\n        t = mid; \n        \n    }\n\n    return min(t, FAR);\n}\n\n// Shadows.\nfloat sha(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int maxIterationsShad = 16; \n\n    float dist = start;\n    float stepDist = end/float(maxIterationsShad);\n\n    for (int i=0; i<maxIterationsShad; i++){\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist));\n\n        dist += clamp(h, 0.02, 0.16);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if ((h)<0.001 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.) + 0.1, 1.0); \n}\n\n// Grey scale.\nfloat gr(vec3 p){ return dot(p, vec3(0.299, 0.587, 0.114)); }\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 db( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    // Gradient vector, constructed with offset greyscale texture values.\n    vec3 g = vec3( gr(tpl(tx, p - e.xyy, n)), gr(tpl(tx, p - e.yxy, n)), gr(tpl(tx, p - e.yyx, n)));\n    \n    g = (g - gr(tpl(tx,  p , n)))/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n// Camera path. Arranged to coincide with the frequency of the lattice.\nvec3 camPath(float t){\n  \n    return vec3(-sin(t), sin(t) + .75, t*2. + .5);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n\t// Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\t\n    vec3 o = camPath(iTime); // Camera position, doubling as the ray origin.\n    vec3 lk = camPath(iTime + .1);  // \"Look At\" position.\n    vec3 l = o + vec3(1.5, 1., -0.5); // Light position, somewhere near the moving camera.\n\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; // FOV - Field of view.\n    vec3 fwd = normalize(lk-o);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    // Unit direction ray.\n    vec3 r = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    // Lens distortion.\n    //vec3 r = fwd + FOV*(u.x*rgt + u.y*up);\n    //r = normalize(vec3(r.xy, (r.z - length(r.xy)*.5)));\n    \n    \n    // Rotate the camera using Fabrice's simplified rotation matrix.\n    u = sin(vec2(10.57, 0) - iTime/10.); // Reusing \"u.\"\n    mat2 a = mat2(u, -u.y, u.x);\n    r.xz = a * r.xz;\n    r.xy = a * r.xy;\n\n    // Nimitz's fancy surface intersection formula.\n    float t = logBisectTrace(o, r);\n\n    // Initialize the scene color to zero.\n    vec3 col = vec3(0);\n    \n    // If the surface is hit, light it up.\n    if(t<FAR){\n    \n        // Position and normal.\n        vec3 p = o + r*t, n = nr(p);\n        \n        // Texture bump the normal.\n        float sz = 1./1.;\n        n = db(iChannel0, p*sz, n, .03/(1. + t/FAR));\n\n\n        l -= p; // Light to surface vector. Ie: Light direction vector.\n        float d = max(length(l), 0.001); // Light to surface distance.\n        l /= d; // Normalizing the light direction vector.\n        \n        // Ambient occlusion and shadowing.\n        float ao =  cao(p, n, 4.);\n        float sh = sha(p, l, 0.04, d, 4.);\n        \n        // Diffuse, specular, fresnel. Only the latter is being used here.\n        //float di = max(dot(l, n), 0.);\n        //float sp = pow(max( dot( reflect(r, n), l ), 0.0 ), 8.); // Specular term.\n        float fr = clamp(1.0 + dot(r, n), 0.0, 1.0); // Fresnel reflection term.\n        \n        // Texturing the surface with some tri-planar mapping..\n        vec3 tx = tpl( iChannel0, p*sz, n);\n\n\t\t// Very simple coloring. Fresnel and texture combination. Radial blurs like simplicity. :)\n        col = tx*fr*40.;\n        col *= 10./(1. + d*.125 + d*d*.05)*ao*sh;\n\n        \n    }\n\n    vec3 bg = vec3(1, .56, .3);\n    col = mix(clamp(col, 0., 1.), bg, smoothstep(0., FAR-2., t));\n    fragColor = vec4(col, 1.);\n    \n    \n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define WAVES 16.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\n\tfloat time = iTime * 1.0;\n\t\n\tvec3 color = vec3(0.0);\n\n\tfor (float i=0.0; i<WAVES + 1.0; i++) {\n\t\tfloat freq = texture(iChannel0, vec2(i / WAVES, 0.0)).x * 7.0;\n\n\t\tvec2 p = vec2(uv);\n\n\t\tp.x += i * 0.04 + freq * 0.03;\n\t\tp.y += sin(p.x * 0.0 + time) * cos(p.x * 2.0) * freq * 0.2 * ((i + 1.0) / WAVES);\n\t\tfloat intensity = abs(0.01 / p.y) * clamp(freq, 0.35, 2.0);\n\t\tcolor += vec3(1.0 * intensity * (i / 5.0), 0.5 * intensity, .75 * intensity) * (3.0 / WAVES);\n\t}\n\n\tfragColor = vec4(color, 1.0);\n}", "buffer_b_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lfXRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[741, 782, 803, 803, 857], [860, 1356, 1368, 1368, 1572], [1576, 1576, 1632, 1664, 4094]], "test": "untested"}
{"id": "NlsXzf", "name": "Fractal webcam", "author": "matigekunstintelligentie", "description": "Webcam as orbit trap", "tags": ["fractal", "webcam", "feedback"], "likes": 2, "viewed": 634, "published": 3, "date": "1626211581", "time_retrieved": "2024-07-30T19:11:04.613789", "image_code": "\nprecision highp float;\n\n\nfloat ShadeMode = 0.; // value=1, min=0, max=1, step=1 (No, Yes)\nfloat ImageMode = 1.; // value=1, min=0, max=1, step=1 (No, Yes)\nfloat ImageXScale = 1.; // value=1, min=0, max=2, step=0.1\nfloat ImageYScale = 1.; // value=1, min=0, max=2, step=0.1\nfloat Front = 1.; // value=1, min=0, max=1, step=1 (No, Yes)\nfloat Animate = 1.; // value=1, min=0, max=1, step=1 (No, Yes)\nfloat Radius = 0.5; // value=0.5, min=0, max=1, step=0.01\nfloat Normalised = 1.; // value=1, min=0, max=1, step=1 (No, Yes)\nfloat Julia = 1.; // value=1, min=0, max=1, step=1 (No, Yes)\nfloat Julia_c1 = 0.; // value=0, min=-1.0, max=1.0, step=0.01\nfloat Julia_c2 = 0.; // value=0, min=-1.0, max=1.0, step=0.01\nint MaxIter = 50; // value=50, min=1, max=1000, step=1\nint AA = 4; // value=4, min=1, max=9, step=1\nfloat Zoom = 1.; // value=1, min=0.01, max=20, step=0.01\nfloat Xoffset = 0.; // value=0, min=-1, max=1, step=0.01\nfloat Xpan = 0.; // value=0, min=-1, max=1, step=0.01\nfloat Yoffset = 0.; // value=0, min=-1, max=1, step=0.01\nfloat Ypan = 0.; // value=0, min=-1, max=1, step=0.01\nfloat light = 1.5; // value=1.5, min=0, max=4, step=0.01\nfloat angle = 0.5; // value=0.5, min=0, max=1, step=0.01\nfloat EscapeRadius = 100.; // value=4, min=0, max=100, step=0.01\n\nfloat jc1;\nfloat jc2;\n\n\n\nvec2 cMul(vec2 a, vec2 b) {\n    return vec2( a.x*b.x -  a.y*b.y,a.x*b.y + a.y * b.x);\n}\n\nvec2 cInverse(vec2 a) {\n    return  vec2(a.x,-a.y)/dot(a,a);\n}\nvec2 cDiv(vec2 a, vec2 b) {\n    return cMul( a,cInverse(b));\n}\nvec2 cExp(in vec2 z){\n    return vec2(exp(z.x)*cos(z.y),exp(z.x)*sin(z.y));\n}\n\n// https://thebookofshaders.com/10/\n// Random function\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Colour scheme\n// Stolen from llemarie\n// vec3 HSVtoRGB(float iter){\n//     iter = mod(iter+iTime, float(MaxIter));\n//     float value = 1. - float(iter)/float(MaxIter);\n//     value *= value;\n        \n//     float h = value;\n//     float s = 1.;\n//     float v = (iter < float(MaxIter)) ? 1. - value*value : 0.;\n    \n//     float r, g, b, f, p, q, t;\n//     int i;\n//     i = int(h * 6.);\n//     f = h * 6. - float(i);\n//     p = v * (1. - s);\n//     q = v * (1. - f * s);\n//     t = v * (1. - (1. - f) * s);\n//     switch (i % 6){\n//         case 0: r = v, g = t, b = p; break;\n//         case 1: r = q, g = v, b = p; break;\n//         case 2: r = p, g = v, b = t; break;\n//         case 3: r = p, g = q, b = v; break;\n//         case 4: r = t, g = p, b = v; break;\n//         case 5: r = v, g = p, b = q; break;\n//     }\n//     return vec3(r, g, b);\n// }\n\nvec3 palette(float t)\n{\n    //return vec3(0.5,0.5,0.5) + vec3(0.5,0.5,0.5)*cos(6.28318*(vec3(2.0,1.0,0.0)*t + vec3(0.5,0.2,0.25)));\n    return vec3(0.5) + vec3(0.5)*cos(6.28318*(vec3(1.0)*t + vec3(0.,0.33,0.67) + iTime));\n    //return vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5)*cos(6.28318*(vec3(1.0, 1.0, 1.0)*t+2.*iTime*vec3(0.01, 0.10, 0.20)) );\n}\n\n\n// Put anything you like here. This is the image that is rendered in the image orbit traps\nvec4 subrender(float xin, float yin){\n    xin = xin/ImageXScale;\n    yin = yin/ImageYScale;\n    float sqr = sqrt((xin-0.5)*(xin-0.5)+(yin-0.5)*(yin-0.5));\n    if(sqr<Radius){\n        return texture( iChannel0,vec2(xin,yin));\n    }\n    else{\n        return vec4(0.0);\n    }\n}\n\nvec4 render(float xin, float yin){\n    // vec4 final_col = vec4(0.0);\n    // for(int i = 0; i<AA;i++){\n        float trap1 = 0.0;\n        float x = 0.0;\n        float y = 0.0;\n        float xx = 0.0;\n        float yy = 0.0;\n        float xy = 0.0;\n        \n        // sample points around the main pixel for anti-aliasing\n        float c1 = (1./Zoom)*(xin + Xoffset + Xpan);\n        float c2 = (1./Zoom)*(yin + Yoffset - Ypan);\n        \n        // Julia mode\n        if(Julia>0.0){\n            x = c1;\n            y = c2;\n            c1 = jc1;\n            c2 = jc2;\n        }\n        \n        vec2 dc = vec2(1, 0);\n        vec2 der = dc;\n        \n        float h2 = light;\n        float angle = angle;\n        vec2 v = cExp(vec2(0.0, angle*2.*3.1415/360.));\n        v = vec2(sin(iTime),angle*cos(iTime));\n        \n        int j = 0;\n        // Flag keeps track of opqque pixels\n        int flag = 0;\n        \n        vec4 col = vec4(palette(1.0), 1.0);\n        \n        while(j<MaxIter){\n            xx = x*x;\n            yy = y*y;\n            col = vec4(palette(trap1), 1.0);\n            if((xx + yy) > EscapeRadius){\n                if(flag<1){\n                    // Normalised/Smooth iteration count\n                    if(Normalised>0.0){\n                        float iter =float(j) - log2(log2(dot(vec2(x,y),vec2(x,y)))) + 4.0;\n                        \n                        // float logzn = log(xx+yy);\n                        // float log4 = log(4.0);\n                        // float log2 = 1.44269504089;\n                        // float logzndiv4 = logzn/log4;\n                        // float loglogzndiv4 = log(logzndiv4);\n                        // float nu = loglogzndiv4 * 1.0/log2;\n                        // nu = log(logzn/log(4.0))/log(2.0);\n                        // float iter = float(j) + 1.0 - nu;\n                        \n                        col = vec4(palette(trap1), 1.0);\n                    }\n                    else{\n    \n                        \n                        col = vec4(palette(float(j)), 1.0);\n                    }\n                }\n                \n                break;\n            }\n            der = cMul(vec2(x,y), der) * 2.0 + dc;\n            \n            // TODO: Karatsuba style - not sure how much time it saves. https://mathr.co.uk/blog/2016-04-10_complex_squaring.html\n            xy = x*y;\n            x = xx - yy + c1;\n            y = xy+xy + c2;\n            \n            float d1 = abs(dot(vec2(x,y)-vec2(0.0,1.0),vec2(0.5)));\n\t\t    float ff = 1.0-smoothstep(0.7,1.3,d1);\n\t\t    trap1 += ff*d1;\n            \n            // Image orbit trap\n            if(ImageMode>0.0 && x>-1.0*ImageXScale && x<=1.0*ImageXScale && y > -1.0*ImageYScale && y<=1.0*ImageYScale){\n                vec4 sr = subrender(x+0.5, y+0.5);\n                if(sr.a>0.0){\n                    col = sr;\n                    if(Front>0.0){\n                        break;\n                    }\n                    flag = 1;\n                }\n            }\n            j++;\n        }\n        \n        if(ShadeMode>0.0){\n        \n            vec2 u = cDiv(vec2(x,y), der);\n            u = cDiv(u, abs(vec2(u.x, u.y)));\n            float t = dot(u,v) + h2;\n            t = t/(1. + h2);\n            \n            if(t<0.){\n                t =0.;\n            }\n            \n            col.xyz *= t;\n        }\n        \n        return col;\n        \n        \n\n    // }\n    \n    // return final_col/float(AA);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    for( int m=0; m<AA; m++ ){\n    for( int n=0; n<AA; n++ ){\n    // Screen coordinate (from [-aspect, -1] to [aspect, 1])\n\n    vec2 q   = (2.0*(fragCoord.xy+vec2(float(m),float(n))/float(AA))-iResolution.xy) / iResolution.y;\n    \n    jc1 = Julia_c1;\n    jc2 = Julia_c2;\n    if(Animate>0.0){\n        jc1 = sin(Julia_c1 + iTime + 5.);\n        jc2 = cos(Julia_c2 + iTime + 7.);\n    }\n    \n    vec4 col = render(q.x, q.y);\n    col.xyz = pow(col.xyz, vec3(0.9));\n    \n    // Output\n    fragColor += col;\n    }\n    }\n    fragColor/=float(AA*AA);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlsXzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1291, 1291, 1318, 1318, 1378], [1380, 1380, 1403, 1403, 1442], [1443, 1443, 1470, 1470, 1505], [1506, 1506, 1527, 1527, 1583], [1585, 1640, 1664, 1664, 1771], [2634, 2634, 2657, 2765, 2983], [2986, 3077, 3114, 3114, 3351], [3353, 3353, 3387, 3455, 6787], [6789, 6789, 6846, 6846, 7389]], "test": "untested"}
{"id": "NllXzf", "name": "Video feedback julia", "author": "TheJimJames40", "description": "Create a julia fractal by reading from the same buffer we are writing to", "tags": ["fractal", "julia", "feedback"], "likes": 6, "viewed": 289, "published": 3, "date": "1626206284", "time_retrieved": "2024-07-30T19:11:05.375751", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n    \n    vec2 s = 1.5 * ratio;\n    vec2 c2 = (texture(iChannel0, uv).xy*2.0 - 1.0)*s;\n    vec2 c3 = (iMouse.xy / iResolution.xy *2.0 - 1.0)*s;\n    vec2 c = (uv*2.0 - 1.0)*s;\n    \n    vec2 z = c;\n    vec2 z2;\n    \n    \n    // enable for bonus algorithm\n    #if 0\n    z = abs(z);\n    z2.x = z.x*z.x - z.y*z.y;\n    z2.y = z.x*z.y*2.0;\n    z2 += c3;\n    z = z2;\n    #endif\n    \n\n    z2.x = z.x*z.x - z.y*z.y;\n    z2.y = z.x*z.y*2.0;\n    z2 += c3;\n\n\n    \n    vec2 uv2 = (z2/s + 1.0)/2.0;\n    vec4 t = texture(iChannel0, uv2);\n    \n    fragColor = max(t*0.99, smoothstep(0.1, 0.0, dot(c, c))); // vec4(0.0,0.0,1.0,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NllXzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 214]], "test": "untested"}
{"id": "NtsXRf", "name": "Analog Julia Fractal", "author": "TheJimJames40", "description": "Idea stolen from https://www.youtube.com/watch?v=Pv26QAOcb6Q\nI was wondering if this would also work with the julia set.\nGo full screen, and point a webcam at the screen. Drag with the mouse to change the value of 'c'", "tags": ["fractal", "webcam", "feedback", "julila"], "likes": 3, "viewed": 412, "published": 3, "date": "1626198720", "time_retrieved": "2024-07-30T19:11:06.129735", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 m  = iMouse.xy/iResolution.xy;\n    \n    vec2 ratio = vec2(iResolution.y / iResolution.x, 1.0);\n    \n    float s = 2.0;\n    \n    vec2 i = (uv*2.0 - 1.0)*s;\n    m = (m*2.0 - 1.0)*s;\n    float d = length(i)*8.0;\n    \n    vec2 c = i;\n\n    vec2 z = vec2(0.0);\n    \n    z = i;\n\n    {\n        vec2 z2;\n        z2.x = z.x*z.x - z.y*z.y;\n        z2.y = z.x*z.y*2.0;\n        z2 += m;\n        z = z2;\n    }\n    \n    vec2 o = (z / s + 1.0) / 2.0;\n    // o = (o / ratio / 3.0 + 1.0)*0.5;\n    \n\n    // Time varying pixel color\n    vec4 col = max(texture(iChannel0, o)*0.5, 1.0 / (d*d + 1.0));\n\n    // Output to screen\n    fragColor = col;\n}\n", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsXRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 733]], "test": "untested"}
{"id": "fllSRf", "name": "Circle11111", "author": "ASkkk", "description": "for church", "tags": ["cfm"], "likes": 6, "viewed": 394, "published": 3, "date": "1626193582", "time_retrieved": "2024-07-30T19:11:06.879729", "image_code": "// credit: https://www.shadertoy.com/view/4tGXzt\n\n#define BEATMOVE 1\n\nconst float FREQ_RANGE = 100.0;\nconst float PI = 3.1415;\nconst float RADIUS = 0.6;\nconst float BRIGHTNESS = 0.2;\nconst float SPEED = 0.5;\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat getfrequency(float x) {\n\treturn texture(iChannel0, vec2(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE, 0.25)).x + 0.06;\n}\n\nfloat getfrequency_smooth(float x) {\n\tfloat index = floor(x * FREQ_RANGE) / FREQ_RANGE;\n    float next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\n\treturn mix(getfrequency(index), getfrequency(next), smoothstep(0.0, 1.0, fract(x * FREQ_RANGE)));\n}\n\nfloat getfrequency_blend(float x) {\n    return mix(getfrequency(x), getfrequency_smooth(x), 0.5);\n}\n\nvec3 doHalo(vec2 fragment, float radius) {\n\tfloat dist = length(fragment);\n\tfloat ring = 1.0 / abs(dist - radius);\n\t\n\tfloat b = dist < radius ? BRIGHTNESS * 0.3 : BRIGHTNESS;\n\t\n\tvec3 col = vec3(0.0);\n\t\n\tfloat angle = atan(fragment.x, fragment.y);\n\tcol += hsv2rgb( vec3( ( angle + iTime * 0.25 ) / (PI * 2.0), 1.0, 1.0 ) ) * ring * b;\n\t\n\tfloat frequency = max(getfrequency_blend(abs(angle / PI)) - 0.02, 0.0);\n\tcol *= frequency;\n\t\n\t// Black halo\n\tcol *= smoothstep(radius * 0.5, radius, dist);\n\t\n\treturn col;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 fragPos = fragCoord / iResolution.xy;\n\tfragPos = (fragPos - 0.5) * 2.0;\n    fragPos.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 color = vec3(0.0134, 0.052, 0.1);\n\tcolor += doHalo(fragPos, RADIUS);\n\n    float c = cos(iTime * SPEED);\n    float s = sin(iTime * SPEED);\n    vec2 rot = mat2(c,s,-s,c) * fragPos;\n\t\n\tcolor += max(luma(color) - 1.0, 0.0);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 21, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fllSRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[209, 230, 251, 251, 420], [422, 422, 446, 446, 496], [498, 498, 527, 527, 620], [622, 622, 658, 658, 869], [871, 871, 906, 906, 970], [972, 972, 1014, 1014, 1481], [1486, 1486, 1543, 1543, 1938]], "test": "untested"}
{"id": "NllXRX", "name": "neonightwisterays", "author": "firebreathz", "description": "bright reactive random rays", "tags": ["ray", "neon"], "likes": 4, "viewed": 442, "published": 3, "date": "1626184468", "time_retrieved": "2024-07-30T19:11:07.823207", "image_code": "// Fork of \"redec-ray\" by None. https://shadertoy.com/view/-1\n// 2021-07-13 11:38:11\n\n// Fork of \"redec-ray\" by None. https://shadertoy.com/view/-1\n// 2021-07-13 07:45:30\n\n// Fork of \"redec-ray\" by None. https://shadertoy.com/view/-1\n// 2021-07-13 07:45:22\n\n// Fork of \"redec-ray\" by None. https://shadertoy.com/view/-1\n// 2021-07-13 07:44:47\n\n// Fork of \"Fork Fork Full  firebreath 322\" by None. https://shadertoy.com/view/-1\n// 2021-07-13 07:42:55\n\n// Fork of \"Fork Fork Full  firebreath 322\" by None. https://shadertoy.com/view/-1\n// 2021-07-13 07:42:25\n\n// Fork of \"Fork Fork Full  firebreath 322\" by firebreathz. https://shadertoy.com/view/ftfXR7\n// 2021-07-13 07:42:02\n\n/*\n\tFull Scene Radial Blur\n\t----------------------\n\n\tRadial blur - as a postprocessing effect - is one of the first things I considered doing \n\twhen the multipass system came out. I've always loved this effect. Reminds me of the early \n\tdemos from Aardbei et al. \n\n\tAnyway, Shadertoy user, Passion, did a really cool radial blur on a field of spheres that\n\tinspired me to do my own. Radial blurs are pretty straight forward, but it was still\n    helpful to have Passion's version as a guide. \n\n    As for the radial blur process, there's not much to it. Start off at the pixel position, \n    then radiate outwards gathering up pixels with decreased weighting. The result is a\n\tblurring of the image in a radial fashion, strangely enough. :)\n\n\tInspired by:\n\n\tBlue Dream - Passion\n\thttps://www.shadertoy.com/view/MdG3RD\n\n\tRadial Blur - IQ\n\thttps://www.shadertoy.com/view/4sfGRn\n\n\tRays of Blinding Light - mu6k\n\thttps://www.shadertoy.com/view/lsf3Dn\n\n*/\n\n// The radial blur section. Shadertoy user, Passion, did a good enough job, so I've used a\n// slightly trimmed down version of that. By the way, there are accumulative weighting \n// methods that do a slightly better job, but this method is good enough for this example.\n\n\n// Radial blur samples. More is always better, but there's frame rate to consider.\nconst float SAMPLES = 40.; \n\n\n// 2x1 hash. Used to jitter the samples.\nfloat hash( vec2 p ){ return fract(sin(dot(p, vec2(1, 289)))*45758.5453); }\n\n\n// Light offset.\n//\n// I realized, after a while, that determining the correct light position doesn't help, since \n// radial blur doesn't really look right unless its focus point is within the screen boundaries, \n// whereas the light is often out of frame. Therefore, I decided to go for something that at \n// least gives the feel of following the light. In this case, I normalized the light position \n// and rotated it in unison with the camera rotation. Hacky, for sure, but who's checking? :)\nvec3 lOff(){    \n    \n    vec2 u = sin(vec2(.57, 0) - iTime/01.);\n    mat2 a = mat2(u, -u.y, u.x);\n    \n    vec3 l = normalize(vec3(.5, 1., -0.95));\n    l.xz = a * l.xz;\n    l.xy = a * l.xy;\n    \n    return l;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // Screen coordinates.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Radial blur factors.\n    //\n    // Falloff, as we radiate outwards.\n    float decay = 0.99; \n    // Controls the sample density, which in turn, controls the sample spread.\n    float density = 0.32; \n    // Sample weight. Decays as we radiate outwards.\n    float weight = 0.51; \n    \n    // Light offset. Kind of fake. See above.\n    vec3 l = lOff();\n    \n    // Offset texture position (uv - .5), offset again by the fake light movement.\n    // It's used to set the blur direction (a direction vector of sorts), and is used \n    // later to center the spotlight.\n    //\n    // The range is centered on zero, which allows the accumulation to spread out in\n    // all directions. Ie; It's radial.\n    vec2 tuv =  uv - .5 - l.xy*.45;\n    \n    // Dividing the direction vector above by the sample number and a density factor\n    // which controls how far the blur spreads out. Higher density means a greater \n    // blur radius.\n    vec2 dTuv = tuv*density/SAMPLES;\n    \n    // Grabbing a portion of the initial texture sample. Higher numbers will make the\n    // scene a little clearer, but I'm going for a bit of abstraction.\n    vec4 col = texture(iChannel0, uv.xy)*0.25;\n    \n    // Jittering, to get rid of banding. Vitally important when accumulating discontinuous \n    // samples, especially when only a few layers are being used.\n    uv += dTuv*(hash(uv.xy + fract(iTime))*0.2 - 1.);\n    \n    // The radial blur loop. Take a texture sample, move a little in the direction of\n    // the radial direction vector (dTuv) then take another, slightly less weighted,\n    // sample, add it to the total, then repeat the process until done.\n    for(float i=0.; i < SAMPLES; i++){\n    \n        uv -= dTuv;\n        col += texture(iChannel0, uv) * weight;\n        weight *= decay;\n        \n    }\n    \n    // Multiplying the final color with a spotlight centered on the focal point of the radial\n    // blur. It's a nice finishing touch... that Passion came up with. If it's a good idea,\n    // it didn't come from me. :)\n    col *= (1. - dot(tuv, tuv)*.075);\n    \n    // Smoothstepping the final color, just to bring it out a bit, then applying some \n    // loose gamma correction.\n    fragColor = sqrt(smoothstep(0., 1., col));\n    \n    // Bypassing the radial blur to show the raymarched scene on its own.\n    //fragColor = sqrt(texture(iChannel0, fragCoord.xy / iResolution.xy));\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define WAVES 8.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\n\tfloat time = iTime * 1.0;\n\t\n\tvec3 color = vec3(0.0);\n\n\tfor (float i=0.0; i<WAVES + 1.0; i++) {\n\t\tfloat freq = texture(iChannel0, vec2(i / WAVES, 0.0)).x * 17.0;\n\n\t\tvec2 p = vec2(uv);\n\n\t\tp.x += i * 0.04 + freq * 0.03;\n\t\tp.y += sin(p.x * 0.0 + time) * cos(p.x * 2.0) * freq * 0.2 * ((i + 1.0) / WAVES);\n\t\tfloat intensity = abs(0.01 / p.y) * clamp(freq, 0.35, 2.0);\n\t\tcolor += vec3(1.0 * intensity * (i / 5.0), 0.5 * intensity, .95 * intensity) * (3.0 / WAVES);\n\t}\n\n\tfragColor = vec4(color, 1.0);\n}", "buffer_b_inputs": [{"id": 20, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// The scene itself. Not much commenting, since this is mainly about the radial blur,\n// plus a lot of it is rudimentary.\n\n#define FAR 2000.\n\n// Hash.\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tpl( sampler2D t, in vec3 p, in vec3 n ){\n   \n    n = max(abs(n), 0.001);\n    n /= (n.x + n.y + n.z );  \n\tp = (texture(t, p.yz)*n.x + texture(t, p.zx)*n.y + texture(t, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// A simple, cheap but visually effective sinusoid based lattice. The downside to building\n// a scene with transcendentals is the honing difficulty, but the logarithmic based\n// \"Logarithmmic Bisection\" tracing method counters that.\nfloat map(in vec3 p){\n   \n    // A few small bumps to put on the surface.\n    float bump = (dot(sin(p*24. - cos(p.yzx*36.)), vec3(.015)));\n    \n    // Perturbing the surface slightly, prior to construction.\n    p += sin(p*8. + 3.14159)*.1;\n    \n    // The main surface. A weird, molecular looking lattice.\n    float n = dot(sin(p*2.), cos(p.yzx*2.));\n    \n \t// Clamping the surface value, and adding the bumps.\n    //return (clamp(0., -1.1, n) + 1.1)/1.1 + bump;\n    return (min(n, 0.) + 1.1)/1.1 + bump;\n    \n}\n\n \n// Ambient occlusion, for that self shadowed look.\n// XT95 came up with this particular version. Very nice.\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat cao( in vec3 p, in vec3 n, float maxDist )\n{\n\tfloat ao = 0.0, l;\n\tconst float nbIte = 6.0;\n\tconst float falloff = 1.5;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i + hash(i))*.5/nbIte*maxDist;\n        ao += (l - map( p + n*l ))/ pow(1. + l, falloff);\n    }\n\t\n    return clamp( 1.-ao/nbIte, 0., 1.);\n}\n\n// Tetrahedral normal, courtesy of IQ.\nvec3 nr(in vec3 p)\n{  \n    vec2 e = vec2(-1, 1)*.001;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n// A trimmed down version of Nimitz's \"Log Bisecion\" method. Very effective on\n// difficult to hone in on things like weird, transcendental surfaces.\n// Worth studying, if you're not familiar with it.\n//\n// Log-Bisection Tracing - Nimitz\n// https://www.shadertoy.com/view/4sSXzD\nfloat logBisectTrace( in vec3 ro, in vec3 rd){\n\n\n    float t = 0., told = 0., mid, dn;\n    float d = map(rd*t + ro);\n    float sgn = sign(d);\n\n    for (int i=0; i<64; i++){\n\n        // If the threshold is crossed with no detection, use the bisection method.\n        // Also, break for the usual reasons. Note that there's only one \"break\"\n        // statement in the loop. I heard GPUs like that... but who knows?\n        if (sign(d) != sgn || d < 0.001 || t > FAR) break;\n \n        told = t;\n        \n        // Branchless version of the following:  \n        // if(d>1.) t += d*.5; else t += log(abs(d) + 1.1)*.5;\n        t += step(d, 1.)*(log(abs(d) + 1.1)*.5 - d*.5) + d*.5;\n       \n        d = map(rd*t + ro);\n    }\n    \n    // If a threshold was crossed without a solution, use the bisection method.\n    if (sign(d) != sgn){\n    \n        // Based on suggestions from CeeJayDK, with some minor changes.\n\n        dn = sign(map(rd*told + ro));\n        \n        vec2 iv = vec2(told, t); // Near, Far\n\n        // 6 iterations seems to be more than enough, for most cases...\n        // but there's an early exit, so I've added a couple more.\n        for (int ii=0; ii<18; ii++){ \n            //Evaluate midpoint\n            mid = dot(iv, vec2(.5));\n            float d = map(rd*mid + ro);\n            if (abs(d) < 0.01)break;\n            // Suggestion from movAX13h - Shadertoy is one of those rare\n            // sites with helpful commenters. :)\n            // Set mid to near or far, depending on which side we're on.\n            iv = mix(vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn));\n        }\n\n        t = mid; \n        \n    }\n\n    return min(t, FAR);\n}\n\n// Shadows.\nfloat sha(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int maxIterationsShad = 36; \n\n    float dist = start;\n    float stepDist = end/float(maxIterationsShad);\n\n    for (int i=0; i<maxIterationsShad; i++){\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist));\n\n        dist += clamp(h, 0.02, 0.16);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if ((h)<0.0001 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.) + 0.1, 1.0); \n}\n\n// Grey scale.\nfloat gr(vec3 p){ return dot(p, vec3(0.99, 0.587, 0.114)); }\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 db( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    // Gradient vector, constructed with offset greyscale texture values.\n    vec3 g = vec3( gr(tpl(tx, p - e.xyy, n)), gr(tpl(tx, p - e.yxy, n)), gr(tpl(tx, p - e.yyx, n)));\n    \n    g = (g - gr(tpl(tx,  p , n)))/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n// Camera path. Arranged to coincide with the frequency of the lattice.\nvec3 camPath(float t){\n  \n    return vec3(-sin(t), sin(t) + .5, t*2. + .5);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n\t// Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\t\n    vec3 o = camPath(iTime); // Camera position, doubling as the ray origin.\n    vec3 lk = camPath(iTime + 90.009);  // \"Look At\" position.\n    vec3 l = o + vec3(.1, 1., -0.5); // Light position, somewhere near the moving camera.\n\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 4.14159/3.; // FOV - Field of view.\n    vec3 fwd = normalize(lk-o);\n    vec3 rgt = normalize(vec3(fwd.z, 100., -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    // Unit direction ray.\n    vec3 r = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    // Lens distortion.\n    //vec3 r = fwd + FOV*(u.x*rgt + u.y*up);\n    //r = normalize(vec3(r.xy, (r.z - length(r.xy)*.5)));\n    \n    \n    // Rotate the camera using Fabrice's simplified rotation matrix.\n    u = sin(vec2(.001, 0) - iTime/1.01); // Reusing \"u.\"\n    mat2 a = mat2(u, -u.y, u.x);\n    r.xz = a * r.xz;\n    r.xy = a * r.xy;\n\n    // Nimitz's fancy surface intersection formula.\n    float t = logBisectTrace(o, r);\n\n    // Initialize the scene color to zero.\n    vec3 col = vec3(0);\n    \n    // If the surface is hit, light it up.\n    if(t<FAR){\n    \n        // Position and normal.\n        vec3 p = o + r*t, n = nr(p);\n        \n        // Texture bump the normal.\n        float sz = 1./1.;\n        n = db(iChannel0, p*sz, n, .3/(1. + t/FAR));\n\n\n        l -= p; // Light to surface vector. Ie: Light direction vector.\n        float d = max(length(l), 0.901); // Light to surface distance.\n        l /= d; // Normalizing the light direction vector.\n        \n        // Ambient occlusion and shadowing.\n        float ao =  cao(p, n, 9.);\n        float sh = sha(p, l, 0.4, d, 4.);\n        \n        // Diffuse, specular, fresnel. Only the latter is being used here.\n        //float di = max(dot(l, n), 0.);\n        //float sp = pow(max( dot( reflect(r, n), l ), 0.0 ), 8.); // Specular term.\n        float fr = clamp(1.0 + dot(r, n), 0.0, 1.0); // Fresnel reflection term.\n        \n        // Texturing the surface with some tri-planar mapping..\n        vec3 tx = tpl( iChannel0, p*sz, n);\n\n\t\t// Very simple coloring. Fresnel and texture combination. Radial blurs like simplicity. :)\n        col = tx*fr*80.;\n        col *= 2.5/(1. + d*.25 + d*d*.05)*ao*sh;\n\n        \n    }\n\n    vec3 bg = vec3(0.000,0.000,0.627);\n    col = mix(clamp(col, 0., 1.), bg, smoothstep(0., FAR-8., t));\n    fragColor = vec4(col, 1.);\n    \n    \n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NllXRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2013, 2054, 2075, 2075, 2129], [2132, 2628, 2640, 2640, 2844], [2848, 2848, 2904, 2936, 5366]], "test": "untested"}
{"id": "NlXSzf", "name": "Grid of Cylinders reactive", "author": "firebreathz", "description": "Using a 2D regular grid as acceleration structure for raytracing (an infinite amount of) cylinders. I trace across the 2D grid and then intersect the cylinder inside each cell. When the first intersection is found, the tracing can stop.", "tags": ["procedural", "3d", "raytracing", "grid", "cylinder", "regulargrid", "vr"], "likes": 3, "viewed": 496, "published": 3, "date": "1626156020", "time_retrieved": "2024-07-30T19:11:08.594145", "image_code": "// Fork of \"Grid of Cylinders\" by iq. https://shadertoy.com/view/4dSGW1\n// 2021-07-13 05:56:57\n\n// Created by inigo quilez - iq/2013\n// I share this piece (art and code) here in Shadertoy and through its Public API, only for educational purposes. \n// You cannot use, sell, share or host this piece or modifications of it as part of your own commercial or non-commercial product, website or project.\n// You can share a link to it or an unmodified screenshot of it provided you attribute \"by Inigo Quilez, @iquilezles and iquilezles.org\". \n// If you are a techer, lecturer, educator or similar and these conditions are too restrictive for your needs, please contact me and we'll work it out.\n\n\n// Try 4, 15, 30 samples if yo have a powerful machine\n\n#if HW_PERFORMANCE==30\n#define VIS_SAMPLES 0\n#else\n#define VIS_SAMPLES 1\n#endif\n\n\nfloat hash1( float n ) { return fract(43758.5453123*sin(n)); }\nfloat hash1( vec2  n ) { return fract(43758.5453123*sin(dot(n,vec2(1.0,113.0)))); }\nvec2  hash2( float n ) { return fract(43758.5453123*sin(vec2(n,n+1.0))); }\n\nfloat gAnimTime;\nfloat map( vec2 p ) \n{\n\tfloat f = textureLod( iChannel0, p/iChannelResolution[0].xy, 0.0 ).x;\n\t\n\tf *= sqrt( textureLod( iChannel2, (0.9*p + 20.0*gAnimTime)/2056.0, 0.0 ).x );\n\treturn 200.0*f;\n}\n\nvec3 calcNormal( in vec3 pos, in float ic )\n{\n\treturn mix( normalize(vec3(pos.x,0.0,pos.z)), vec3(0.0,1.0,0.0), ic );\n}\n\nvec4 castRay( in vec3 ro, in vec3 rd )\n{\n\tvec2 pos = floor(ro.xz);\n\tvec2 ri = 10.0/rd.xz;\n\tvec2 rs = sign(rd.xz);\n\tvec2 ris = ri*rs;\n\tvec2 dis = (pos-ro.xz+ 0.5 + rs*0.5) * ri;\n\t\n\tvec4 res = vec4( -1.0, 0.0, 0.0, 0.0 );\n\n    // traverse regular grid (in 2D)\n\tvec2 mm = vec2(0.0);\n\tfor( int i=0; i<200; i++ ) \n\t{\n\n\t\tfloat ma = map(pos);\n\t\t\n        // intersect capped cylinder\t\t\n\t\tvec3  ce = vec3( pos.x+1.25, 0.0, pos.y+0.5 );\n\t\tvec3  rc = ro - ce;\n\t\tfloat a = dot( rd.xz, rd.xz );\n\t\tfloat b = dot( rc.xz, rd.xz );\n\t\tfloat c = dot( rc.xz, rc.xz ) - 0.9;\n\t\tfloat h = b*b - a*c;\n\t\tif( h>=0.0 )\n\t\t{\n            // cylinder\t\t\t\n\t\t\tfloat s = (-b - sqrt( h ))/a;\n\t\t\tif( s>0.0 && (ro.y+s*rd.y)<ma )\n\t\t\t{\n\t\t\t\tres = vec4( s, 0.0, pos );\n    \t\t\tbreak; \n\t\t\t}\n            // cap\t\t\t\n\t\t\ts = (ma - ro.y)/rd.y;\n\t\t\tif( s>0.0 && (s*s*a+1.7*s*b+c)<0.0 )\n\t\t\t{\n\t\t\t\tres = vec4( s, 10.0, pos );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n        // step to next cell\t\t\n\t\tmm = step( dis.xy, dis.yx ); \n\t\tdis += mm*ris;\n        pos += mm*rs;\n\t}\n\n\n\treturn res;\n}\n\nfloat castShadowRay( in vec3 ro, in vec3 rd )\n{\n\tvec2 pos = floor(ro.xz);\n\tvec2 ri = 1.0/rd.xz;\n\tvec2 rs = sign(rd.xz);\n\tvec2 ris = ri*rs;\n\tvec2 dis = (pos-ro.xz+ 9.5 + rs*0.5) * ri;\n\tfloat t = -1.0;\n\tfloat res = 10.0;\n\t\n    // first step we check noching\t\n\tvec2 mm = step( dis.xy, dis.yx ); \n\tdis += mm * ris;\n    pos += mm * rs;\n\t\n    // traverse regular grid (2D)\t\n\tfor( int i=0; i<6; i++ ) \n\t{\n\t\tfloat ma = map(pos);\n\t\t\n        // test capped cylinder\t\t\n\t\tvec3  ce = vec3( pos.x+0.5, 0.0, pos.y+0.5 );\n\t\tvec3  rc = ro - ce;\n\t\tfloat a = dot( rd.xz, rd.xz );\n\t\tfloat b = dot( rc.xz, rd.xz );\n\t\tfloat c = dot( rc.xz, rc.xz ) - 0.009;\n\t\tfloat h = b*b - a*c;\n\t\tif( h>=0.0 )\n\t\t{\n\t\t\tfloat t = (-b - sqrt( h ))/a;\n\t\t\tif( (ro.y+t*rd.y)<ma )\n\t\t\t{\n\t\t\t\tres = 0.0;\n    \t\t\tbreak; \n\t\t\t}\n\t\t}\n\t\tmm = step( dis.xy, dis.yx ); \n\t\tdis += mm * ris;\n        pos += mm * rs;\n\t}\n\n\treturn res;\n}\n\nvec3 cameraPath( float t )\n{\n    // procedural path\t\n    vec2 p  = 20.0*sin( 0.01*t*vec2(1.2,1.0) + vec2(0.1,0.9) );\n\t     p += 100.0*sin( 0.02*t*vec2(1.1,1.3) + vec2(1.0,4.5) );\n\tfloat y = 15.0 + 4.0*sin(0.05*t);\n\t\n\t// collision\n\tfloat h;\n\th  = map( p+vec2(-1.0, 0.0) );\n\th += map( p+vec2( 1.0, 0.0) );\n\th += map( p+vec2( 0.0, 1.0) );\n\th += map( p+vec2( 0.0,-1.0) );\n\th /= 4.0;\n\th += 5.0;\n\ty = max( y, h );\n\n\treturn vec3( p.x, y, p.y );\n}\n\nvec4 texcyl( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture( sam, vec2(p.y,0.5+0.5*atan(n.x,n.z)/3.14) );\n\tvec4 y = texture( sam, p.xz );\n\treturn mix( x, y, abs(n.y) );\n}\n\nvec3 desat( in vec3 col, float a )\n{\n    return mix( col, vec3(dot(col,vec3(0.333))), a );\n}\n\nvec3 lig = normalize(vec3(-0.7,0.25,0.6));\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n        // background color\t\n\t\tfloat sun = clamp( dot( rd, lig ), 0.0, 1.0 );\n\n\t\tvec3 bgcol = vec3(0.9,0.9,0.8) + 0.3*pow(sun,4.0)*vec3(1.0,1.0,0.0);\n\n        // raytrace\n        vec3 col = bgcol;\n\t\tvec4 res = castRay( ro, rd );\n        vec2 vos = res.zw;\n        float t = res.x;\n        if( t>0.0 )\n        {\n            vec3  pos = ro + rd*t;\n\t\t\tfloat id  = hash1( vos );\n\t\t\tvec3  nor = calcNormal( fract(pos)-0.5, res.y );\n\t\t\tfloat h = map(vos);\n\n            // material color\t\t\t\n\t\t\tvec3 mate1 = 0.5 + 0.45*sin( 3.14*id + 0.8 + vec3(0.0,0.5,1.0) );\n\t\t\tvec3 mate2 = 0.5 + 0.45*sin( 6.28*id + vec3(0.0,0.5,1.0) );\n\t\t\tvec3 mate = mix( mate1, mate2, smoothstep( 9.0, 11.0, h) );\n\t\t\t\n\t\t\tvec3 uvw = pos - vec3(0.0,h,0.0);\n\t\t\tvec3 tex = texcyl( iChannel3, 0.2*uvw + 13.1*hash1(id), nor ).xyz;\n\t\t\tmate *= 0.2+4.0*pow( desat(tex,0.3), vec3(2.0) );\n            mate *= 1.5*sqrt(texture( iChannel0, pos.xz/iChannelResolution[0].xy ).xyz);\n            mate *= 0.02 + 0.98*smoothstep( 0.1,0.11, hash1(id) );\t\n\t\t\t\n            // material cheap/wrong bump\t\t\t \n            vec3 bn = -1.0 + 2.0*texcyl( iChannel1, 0.2*uvw*vec3(1.0,0.2,1.0) + 13.1*hash1(id), nor ).xyz;\n            //nor = normalize(nor + 0.45*bn*(1.0-0.5*nor.y) );\n\t\t\t\n\t\t\t// procedural occlusion\n\t\t\tfloat occ = nor.y*0.75;\n\t\t\tocc += 0.5*clamp( nor.x,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2( 1.0, 0.0)) );\n\t\t\tocc += 0.5*clamp(-nor.x,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2(-1.0, 0.0)) );\n\t\t\tocc += 0.5*clamp( nor.z,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2( 0.0, 1.0)) );\n\t\t\tocc += 0.5*clamp(-nor.z,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2( 0.0,-1.0)) );\n\t\t\tocc = 0.2 + 0.8*occ;\n\t\t\tocc *= pow( clamp((0.1+pos.y)/(0.1+map(floor(pos.xz))),0.0,1.0),2.0);\n\t\t\tocc = occ*0.5+0.5*occ*occ;\n\t\t\tfloat rim = pow( clamp( 1.0+dot(rd,nor), 0.0, 1.0 ),5.0 );\n \n            //-------------\n            // lighitng\n            //-------------\n\t\t\tfloat amb = 1.0;\n            //-------------\n\t\t\tfloat bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z)) ), 0.0, 1.0 ) * clamp(1.0-pos.y/20.0,0.0,1.0);;\n            //-------------\n\t\t\tfloat sha = 0.0;\n\t\t\tfloat dif = dot( nor, lig );\n\t\t\tif( dif<0.0 ) dif=0.0; else sha = castShadowRay( pos, lig );\n            float spe = pow( clamp( dot(lig,reflect(rd,nor)), 0.0, 1.0 ),3.0 );\n            //-------------\n\t\t\tvec3 lin  = 3.00*vec3(1.0,1.0,1.0)*0.7*sqrt(dif)*sha;\n\t\t\t     lin += 0.40*vec3(0.4,1.0,1.7)*amb*occ;\n\t\t\t     lin += 0.60*vec3(0.8,0.5,0.3)*bac*occ;\n\t\t\t\n\t\t\tcol = mate * lin + tex.x*1.5*vec3(1.0,1.0,1.0)*(0.3+0.7*rim)*spe*dif*sha;\n\n            // tone mapping\t\t\t\n\t\t\tcol *= 1.1 + 0.5*dot( rd, lig );\n\n            // fog\n            float ff = 1.0 - smoothstep( 0.0, 1.0, pow(t/160.0,1.8) );\n\t\t\tcol = mix( col, bgcol, 1.0-ff );\n\t\t}\n\t\tcol += 0.2*pow(sun,8.0)*vec3(1.0,0.7,0.2);\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // inputs\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\t\n    vec2 mo = iMouse.xy / iResolution.xy;\n    if( iMouse.w<=0.00001 ) mo=vec2(0.0);\n\t\n    gAnimTime = iTime;\n    \n\t// montecarlo\t\n\tvec3 tot = vec3(0.0);\n    #if VIS_SAMPLES<2\n\tint a = 0;\n\t{\n        vec2 p = -1.0 + 2.0*(fragCoord.xy) / iResolution.xy;\n        p.x *= iResolution.x/ iResolution.y;\n        float time = 4.0*iTime + 50.0*mo.x;\n    #else\n\tfor( int a=0; a<VIS_SAMPLES; a++ )\n\t{\n\t\tvec4 rr = texture( iChannel1, (fragCoord.xy+floor(256.0*hash2(float(a))))/iChannelResolution[1].xy );\n        vec2 p = -1.0 + 2.0*(fragCoord.xy+rr.xz) / iResolution.xy;\n        p.x *= iResolution.x/ iResolution.y;\n\t\t#if VIS_SAMPLES>3\n        float time = 4.0*(iTime + 1.0*(0.4/24.0)*rr.w) + 50.0*mo.x;\n\t\t#else\n        float time = 4.0*(iTime) + 50.0*mo.x;\n\t\t#endif\n    #endif\t\n\n\t\t// camera\n        vec3  ro = cameraPath( time );\n        vec3  ta = cameraPath( time+5.0 ); ta.y = ro.y - 5.5;\n        float cr = 0.2*cos(0.1*time*0.5);\n\t\n        // build ray\n        vec3 ww = normalize( ta - ro);\n        vec3 uu = normalize(cross( vec3(sin(cr),cos(cr),0.0), ww ));\n        vec3 vv = normalize(cross(ww,uu));\n        float r2 = p.x*p.x*0.32 + p.y*p.y;\n        p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n        // dof\n        #if VIS_SAMPLES>2\n        vec3 fp = ro + rd * 17.0;\n        ro += (uu*(-1.0+2.0*rr.y) + vv*(-1.0+2.0*rr.w))*0.035;\n        rd = normalize( fp - ro );\n        #endif\n\n\n        vec3 col = render( ro, rd );\n        \n\t\ttot += col;\n\t}\n\ttot /= float(VIS_SAMPLES);\n\t\n\n\t// gamma\t\n\ttot = pow( clamp(tot,0.0,1.0), vec3(0.45) );\n\n\t// vignetting\t\n\ttot *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n\tfragColor = vec4( tot, 1.0 );\n}\n    \n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 cam = cameraPath( iTime );\n\n    gAnimTime = iTime*0.2;\n\n    vec3 ro = fragRayOri + cam + vec3(0.0,-2.0,0.0);\n    vec3 rd = fragRayDir*vec3(-1.0,1.0,-1.0);\n    vec3 col = render( ro, rd );\n\n    // gamma\t\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.44) );\n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 p = fragCoord.xy;\n    \n    vec2 uv = (p.xy) / iResolution.xy - vec2(0.15);\n    vec4 col = vec4(0.);//texture(iChannel0, p / iResolution.xy);\n    \n    float thickness = 0.003;\n    for(float i = 1.; i < 2.; i += 0.1){\n    \n    //float i = 1.3;\n    float j = -i/6.;\n        float gx = texture(iChannel0, uv.xy/i+vec2( thickness, 0.) - vec2(j)).x\n    - texture(iChannel0, uv.xy/i-vec2( thickness, 0.)- vec2(j)).x ;\n    \n    float gy = texture(iChannel0, uv.xy/i+vec2(0.,  thickness)- vec2(j)).x \n    - texture(iChannel0, uv.xy/i-vec2(0.,  thickness)- vec2(j)).x;\n\n    \n\t// hack: use g^2 to conceal noise in the video\n    float g = gx*gx + gy*gy;\n    \n    \n    col += vec4(vec3(g/8.,g/3.,g/2.)*10., 1.0);\n    col = clamp(col,0.,1.);\n    }\n    fragColor = col;\n}", "buffer_d_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXSzf.jpg", "access": "api", "license": "proprietary-license", "functions": [[830, 830, 854, 854, 892], [893, 893, 917, 917, 976], [977, 977, 1001, 1001, 1051], [1070, 1070, 1092, 1092, 1263], [1265, 1265, 1310, 1310, 1384], [1386, 1386, 1426, 1426, 2399], [2401, 2401, 2448, 2448, 3274], [3276, 3276, 3304, 3328, 3715], [3717, 3717, 3769, 3769, 3898], [3900, 3900, 3936, 3936, 3992], [4038, 4038, 4077, 4106, 6907]], "test": "untested"}
{"id": "NlXSRX", "name": "64 Cubes", "author": "Tater", "description": "Another shader for Sableraph's weekly creative coding challenge, the prompt this time being \"64\". \n\nI sorta ran out of ideas after finishing the pipes and cubes but maybe I will come back to this and add some background details idk. ", "tags": ["3d", "raymarch"], "likes": 14, "viewed": 469, "published": 3, "date": "1626155173", "time_retrieved": "2024-07-30T19:11:09.424924", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pi 3.1415926535\n#define STEPS 96.0\n#define MDIST 50.0\n#define aspect (iResolution.y/iResolution.x)\n\n\nfloat rand1(float a){\n    return fract(sin(dot(vec2(a),vec2(43.234,21.4343)))*94544.3434343)-0.5;\n}\n//cylinder from iq\nfloat cyl( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 bezier4p(vec2 p1, vec2 p2, vec2 p3, vec2 p4, float t){\n    vec2 p = pow(1.0-t,3.0)*p1+\n           3.0*pow(1.0-t,2.0)*t*p2+ \n           3.0*(1.0-t)*t*t*p3+\n           pow(t,3.0)*p4;  \n    return p;\n}\nfloat box(vec3 p, vec3 b){\n    vec3 d = abs(p)-b;\n    return max(d.x,max(d.y,d.z));\n}\nfloat pipe(vec3 p){\n    float a = 0.0;\n    a = cyl(p+vec3(0,9,0),1.0,10.0);\n    a = min(a,cyl(p-vec3(0,1,0),1.2,0.2));\n    a = max(-(length(p.xz)-0.9),a);\n    a-=0.02;\n    return a;\n}\nvec2 aspectize(vec2 a){\n    a.x*=aspect;\n    a.y/=aspect;\n    return a;\n}\nvec2 map(vec3 p){//oops this became a huge mess, oh well\n\n    vec3 po = p;\n    float t = iTime;\n    \n    vec2 a = vec2(0);\n    vec2 b = vec2(1);\n    \n    float ps = 0.5; //Pipe Smooth Time\n    float prt = 3.0;//Pipe Repeat Time\n    \n    vec2 pipe1Pos = vec2(0);\n    vec2 pipe2Pos = vec2(0);\n    float cycleInt = floor(t/prt+1.0);\n    \n    //Pipe Up/Down Movement\n    pipe1Pos.y = 10.0-5.0*smoothstep(0.0,ps,mod(t,prt))*smoothstep(prt,prt-ps,mod(t,prt));\n    //Side to Side randomize\n    float sideScale = 11.75;\n    \n    pipe1Pos.x+=rand1(cycleInt)*sideScale;\n    pipe2Pos.x+=rand1(cycleInt*1.01)*sideScale;\n    \n    pipe2Pos.y = pipe1Pos.y;\n    \n    \n    float pipe1Rot = floor((rand1(cycleInt*1.02)+0.5)*4.0);\n    float pipe2Rot = floor((rand1(cycleInt*1.03)+0.5)*4.0);\n    \n    if(pipe1Rot==pipe2Rot){\n        pipe1Pos.x = abs(pipe1Pos.x)-sideScale*0.5-1.5;\n        pipe2Pos.x = -abs(pipe2Pos.x)+sideScale*0.5+1.5;\n    }\n    \n    if(pipe1Rot==1.0||pipe1Rot==3.0){\n        pipe1Pos.x*=aspect;\n        pipe1Pos.y/=aspect;\n    }\n    \n    p.xy*=rot((pi/2.0)*pipe1Rot);\n    p.xy+=pipe1Pos;\n    a.x = pipe(p);\n    \n    p = po;\n    \n    if(pipe2Rot==1.0||pipe2Rot==3.0){\n        pipe2Pos.x*=aspect;\n        pipe2Pos.y/=aspect;\n    }\n    \n    p.xy*=rot((pi/2.0)*pipe2Rot);\n    p.xy+=pipe2Pos;\n    \n    b = vec2(pipe(p),0.0);\n    \n    a=(a.x<b.x)?a:b;    \n    \n    float pathDisp = 8.5; //Try increasing this :)\n    vec2 p1 = pipe1Pos*rot(3.0*(pi/2.0)*pipe1Rot);\n    vec2 p2 = (pipe1Pos+vec2(0,-pathDisp))*rot(3.0*(pi/2.0)*pipe1Rot);\n    vec2 p3 = pipe2Pos*rot(3.0*(pi/2.0)*pipe2Rot);\n    vec2 p4 = (pipe2Pos+vec2(0,-pathDisp))*rot(3.0*(pi/2.0)*pipe2Rot);\n    \n    float loops =16.0;\n    for(float i = 0.0; i <loops; i ++){\n        float tp = min(-prt*0.5+fract(t/prt)*prt+i/loops,1.1);\n        vec2 boxp = bezier4p(p1,p2,p4,p3,tp);\n        p = po;\n        p+=vec3(boxp,0);\n        p.xy*=rot(t+(i/16.0)*13.0);\n        p.xz*=rot(t+(i/16.0)*13.0);\n        p = abs(p)-vec3(0.45,0.45,0.0);\n        b = vec2(box(p,vec3(0.15)),1.0);\n        if(fract(t/prt)*3.0>ps) a=(a.x<b.x)?a:b;\n    }\n    \n    return a;\n}\n\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.01,0);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col =vec3(0);\n    \n    vec3 ro = vec3(0,0,-30);\n    vec3 rd = normalize(vec3(uv,3.0));\n    \n    vec3 p;\n    vec2 d;\n    float dO, shad;\n    bool hit = false;\n    \n    for(float i = 0.0; i < STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x;\n        \n        if(abs(d.x)<0.01){\n            shad = i/STEPS;\n            hit = true;\n            break;\n        }\n        if(dO>MDIST){\n            p = ro+rd*MDIST;\n            break;\n        }\n    }\n    if(hit){\n    vec3 n = norm(p);\n    vec3 ld = vec3(-0.5,0.5,-1);\n    vec3 h = normalize(ld-rd);\n    float spec = pow(max(dot(n,h),0.0),30.0);\n    float fres = pow(1. - max(dot(n, -rd),0.), 5.);\n    float diff = max(dot(n, ld),0.);\n    \n    \n    vec3 al;\n    if(d.y == 0.0) al = vec3(0.035,0.757,0.216);\n    if(d.y == 1.0) al = vec3(0.792,0.247,0.255);\n    col = vec3(diff*0.5);\n    col += spec*0.5;\n    col+=fres*0.2;\n    col+=(1.0-shad)*0.5;\n    col*=al;\n    \n    }\n    \n    //vec3 sky = mix(vec3(0.180,0.616,1.000),vec3(0.278,0.235,0.843),clamp(-p.y*0.1+0.4,0.0,1.0));\n    \n    if(!hit)col = vec3(0.302,0.545,1.000)*(1.0-0.5*length(uv*uv));\n    col*=clamp(sin(18.0* uv.y*iResolution.y+iTime*2.0)*0.5+0.5,0.8,1.0);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXSRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 159, 180, 180, 258], [259, 278, 317, 317, 424], [426, 426, 485, 485, 629], [630, 630, 656, 656, 715], [716, 716, 735, 735, 899], [900, 900, 923, 923, 973], [974, 974, 991, 1030, 3070], [3072, 3072, 3090, 3090, 3217], [3219, 3219, 3276, 3276, 4562]], "test": "untested"}
{"id": "stjGDd", "name": "Fork Cubic Bezi brickmaker 655", "author": "brickmaker", "description": "Computing the exact bounding box to a cubic Bezier curve. Yellow: naive bbox of the 4 control points. Blue: exact/analytic bbox. Since the bezier is cubic, the bbox can be compute with a quadratic equation.", "tags": ["2d", "bezier", "cubic", "boundingbox", "bbox"], "likes": 6, "viewed": 348, "published": 3, "date": "1626145746", "time_retrieved": "2024-07-30T19:11:10.179906", "image_code": "// The MIT License\n// Copyright © 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Computes the exact bounding box to a cubic Bezier curve. Since the bezier is cubic,\n// the bbox can be compute with a quadratic equation:\n//\n//   Yellow: naive bbox of the 4 control points\n//   Blue: exact bbox\n//\n// More info here: https://iquilezles.org/articles/bezierbbox\n//    \n// Related Shaders:\n//     Quadratic Bezier - 3D      : https://www.shadertoy.com/view/ldj3Wh\n//     Cubic     Bezier - 2D BBox : https://www.shadertoy.com/view/XdVBWd \n//     Cubic     Bezier - 3D BBox : https://www.shadertoy.com/view/MdKBWt\n//     Quadratic Bezier - 2D BBox : https://www.shadertoy.com/view/lsyfWc\n//     Quadratic Bezier - 3D BBox : https://www.shadertoy.com/view/tsBfRD\n\n\n\n//---------------------------------------------------------------------------------------\n\n\nfloat length2( in vec2 v ) { return dot(v,v); }\n\nfloat sdSegmentSq( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length2( pa - ba*h );\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\treturn sqrt(sdSegmentSq(p,a,b));\n}\n\n// slow, do not use in production. Can probably do better than\n// tesselation in linear segments.\nvec2 udBezier(vec2 p0, vec2 p1, vec2 p2, in vec2 p3, vec2 pos)\n{   \n    const int kNum = 50;\n    vec2 res = vec2(1e10,0.0);\n    vec2 a = p0;\n    for( int i=1; i<kNum; i++ )\n    {\n        float t = float(i)/float(kNum-1);\n        float s = 1.0-t;\n        vec2 b = p0*s*s*s + p1*3.0*s*s*t + p2*3.0*s*t*t + p3*t*t*t;\n        float d = sdSegmentSq( pos, a, b );\n        if( d<res.x ) res = vec2(d,t);\n        a = b;\n    }\n    \n    return vec2(sqrt(res.x),res.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //--------\n    // animate\n    //--------\n    float time = iTime*0.5 - 0.7;\n    vec2 p0 = 0.8*sin( time*0.7 + vec2(3.0,1.0) );\n    vec2 p1 = 0.8*sin( time*1.1 + vec2(0.0,6.0) );\n    vec2 p2 = 0.8*sin( time*1.3 + vec2(4.0,2.0) );\n    vec2 p3 = 0.8*sin( time*1.5 + vec2(1.0,5.0) );\n\n\t//-------------\n    // compute bbox\n\t//-------------\n    // vec4 b1 = bboxBezierSimple(p0,p1,p2,p3);\n    // vec4 b2 = bboxBezier(p0,p1,p2,p3);\n    \n    //--------\n    // render\n    //--------\n    \n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n    p *= 2.0;\n    px *= 2.0;\n    // background\n    vec3 col = vec3(0.15);\n    float be = udBezier( p0, p1, p2, p3, p ).x;\n\t// col += 0.03*sin(be*150.0);\n    // col *= 1.0 - 0.3*length(p);\n    \n    float d;\n    \n    \n    // control cage\n    d = sdSegment( p, p0, p1 );\n    col = mix( col, vec3(0.3), 1.0-smoothstep(0.003,0.003+px,d) );\n    d = sdSegment( p, p1, p2 );\n    col = mix( col, vec3(0.3), 1.0-smoothstep(0.003,0.003+px,d) );\n    d = sdSegment( p, p2, p3 );\n    col = mix( col, vec3(0.3), 1.0-smoothstep(0.003,0.003+px,d) );\n\n    // bezier\n    d = be;\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.003,0.003+px*1.5,d) );\n         \n    // control points\n    d = length(p0-p); col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.04+px,d) );\n    d = length(p1-p); col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.04+px,d) );\n    d = length(p2-p); col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.04+px,d) );\n    d = length(p3-p); col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.04+px,d) );\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stjGDd.jpg", "access": "api", "license": "mit", "functions": [[1851, 1851, 1879, 1879, 1898], [1900, 1900, 1954, 1954, 2065], [2067, 2067, 2119, 2119, 2155], [2157, 2255, 2319, 2319, 2715], [2717, 2717, 2774, 2819, 4382]], "test": "untested"}
{"id": "7tlXz2", "name": "cellular automata 1", "author": "guillefix", "description": "cellular automata and other stuff", "tags": ["howto", "storage"], "likes": 3, "viewed": 258, "published": 3, "date": "1626138199", "time_retrieved": "2024-07-30T19:11:10.939874", "image_code": "// Fork of \"Storing Values in a Buffer\" by MarvelousBilly. https://shadertoy.com/view/WsByDt\n// 2021-07-12 21:45:04\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = fragCoord/iResolution.xy;\n    //vec2 uv = fragCoord;\n    vec3 col = vec3(texelFetch(iChannel0, ivec2(fragCoord), 0).xyz);   \n    //collect the stored value in (1,0) of buffer A\n\n    //if(distance(iMouse.xy,fragCoord)<3.){\n    //\tcol = vec3(0.,0.,1.); //mouse position\n    //}\n    //if(distance(col.xy*iResolution.xy,fragCoord)<3.){\n    //\tcol = vec3(1.,1.,1.); //color \"position\"\n    //}\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float hash(float seed)\n{\n\t// Return a \"random\" number based on the \"seed\"\n    //return fract(sin(seed/100.0)* 1235.1);\n    return fract(1235.1*sin(mod(seed,6.28)*10.0));\n}\n\nvec4 game_of_life(vec4 val, vec4 val1, vec4 val2, vec4 val3, vec4 val4, vec4 val5, vec4 val6, vec4 val7, vec4 val8){\n    //return (val+val1+val2+val3+val4)/5.0;\n    vec4 num_living_neis = val1 + val2 + val3 + val4 + val5 + val6 + val7 + val8;\n    if (num_living_neis.x < 1.9) return vec4(0.0);\n    if (num_living_neis.x > 3.9) return vec4(0.0);\n    if (num_living_neis.x > 2.9 && num_living_neis.x < 3.1) return vec4(1.0);\n    else return val;\n}\n\nvec4 game_of_life_weird(vec4 val, vec4 val1, vec4 val2, vec4 val3, vec4 val4, vec4 val5, vec4 val6, vec4 val7, vec4 val8){\n    //return (val+val1+val2+val3+val4)/5.0;\n    vec4 num_living_neis = val1 + val2 + val3 + val4 + val5 + val6 + val7 + val8;\n    if (num_living_neis.x < 1.9) return val-num_living_neis/8.0;\n    if (num_living_neis.x > 3.9) return val-num_living_neis/8.0;\n    if (num_living_neis.x > 2.9 && num_living_neis.x < 3.1) return val+num_living_neis/8.0;\n    else return val;\n}\n\nvec4 game_of_life_weird2(vec4 val, vec4 val1, vec4 val2, vec4 val3, vec4 val4, vec4 val5, vec4 val6, vec4 val7, vec4 val8){\n    //return (val+val1+val2+val3+val4)/5.0;\n    vec4 num_living_neis = val1 + val2 + val3 + val4 + val5 + val6 + val7 + val8;\n    if (num_living_neis.x < 1.9) return val-(val-num_living_neis/8.0);\n    if (num_living_neis.x > 3.9) return val-(val-num_living_neis/8.0);\n    if (num_living_neis.x > 2.9 && num_living_neis.x < 3.1) return val+(val-num_living_neis/8.0);\n    else return val;\n}\n\nvec4 game_of_life_weird3(vec4 val, vec4 val1, vec4 val2, vec4 val3, vec4 val4, vec4 val5, vec4 val6, vec4 val7, vec4 val8){\n    //return (val+val1+val2+val3+val4)/5.0;\n    vec4 num_living_neis = val1 + val2 + val3 + val4 + val5 + val6 + val7 + val8;\n    float prod = num_living_neis.x * num_living_neis.y * num_living_neis.z * num_living_neis.w;\n    float sum = num_living_neis.x + num_living_neis.y + num_living_neis.z + num_living_neis.w;\n    float ave = sum / 4.0;\n    float a1 = 1.5, a2 = 5.0, a3 = a1, a4 = a2;\n    if (ave < a1) return val-(val-num_living_neis/8.0)+0.1;\n    if (ave > a2) return val-(val-num_living_neis/8.0)-0.1;\n    if (ave > a3 && ave < a4) return val+(val-num_living_neis/8.0);\n    else return val;\n}\n\nvec4 game_of_life_weird4(vec4 val, vec4 val1, vec4 val2, vec4 val3, vec4 val4, vec4 val5, vec4 val6, vec4 val7, vec4 val8){\n    //return (val+val1+val2+val3+val4)/5.0;\n    vec4 num_living_neis = val1 + val2 + val3 + val4 + val5 + val6 + val7 + val8;\n    float prod = num_living_neis.x * num_living_neis.y * num_living_neis.z * num_living_neis.w;\n    float sum = num_living_neis.x + num_living_neis.y + num_living_neis.z + num_living_neis.w;\n    float ave = sum / 4.0;\n    float a1 = 1.5, a2 = 5.0, a3 = a1, a4 = a2;\n    if (ave < a1) return val-(val-num_living_neis/8.0)+0.1;\n    if (ave > a2) return val-(val-num_living_neis/8.0)-0.1-ave*iTime;\n    if (ave > a3 && ave < a4) return val+(val-num_living_neis/8.0)+ave*iTime;\n    else return val;\n}\n\nvec4 game_of_life_weird5(vec4 val, vec4 val1, vec4 val2, vec4 val3, vec4 val4, vec4 val5, vec4 val6, vec4 val7, vec4 val8){\n    //return (val+val1+val2+val3+val4)/5.0;\n    vec4 num_living_neis = val1 + val2 + val3 + val4 + val5 + val6 + val7 + val8;\n    float prod = num_living_neis.x * num_living_neis.y * num_living_neis.z * num_living_neis.w;\n    float sum = num_living_neis.x + num_living_neis.y + num_living_neis.z + num_living_neis.w;\n    float ave = sum / 4.0;\n    float a1 = 1.5, a2 = 5.5, a3 = a1, a4 = a2;\n    if (ave < a1) return val-(val-num_living_neis/8.0)+0.1;\n    if (ave > a2) return val-(val-num_living_neis/8.0)-0.1-ave*pow(sin(0.78*iTime),2.0);\n    if (ave > a3 && ave < a4) return val+(val-num_living_neis/8.0)+ave*pow(sin(0.5*iTime),2.0);\n    else return val;\n}\n\nvec4 game_of_life_weird6(vec4 val, vec4 val1, vec4 val2, vec4 val3, vec4 val4, vec4 val5, vec4 val6, vec4 val7, vec4 val8){\n    //return (val+val1+val2+val3+val4)/5.0;\n    vec4 num_living_neis = val1 + val2 + val3 + val4 + val5 + val6 + val7 + val8;\n    float prod = num_living_neis.x * num_living_neis.y * num_living_neis.z * num_living_neis.w;\n    float sum = num_living_neis.x + num_living_neis.y + num_living_neis.z + num_living_neis.w;\n    float ave = sum / 4.0;\n    float a1 = 1.5, a2 = 5.5*pow(cos(0.12*iTime),2.0), a3 = a1, a4 = a2;\n    if (ave < a1) return val-(val-num_living_neis/8.0)+0.1;\n    if (ave > a2) return val-(val-num_living_neis/8.0)-0.1-ave*pow(sin(0.31*iTime),2.0);\n    if (ave > a3 && ave < a4) return val+(val-num_living_neis/8.0)+ave*pow(sin(0.17*iTime),2.0);\n    else return val;\n}\n\nvec4 game_of_life_weird7(vec4 val, vec4 val1, vec4 val2, vec4 val3, vec4 val4, vec4 val5, vec4 val6, vec4 val7, vec4 val8, vec2 fragCoord){\n    //return (val+val1+val2+val3+val4)/5.0;\n    vec4 num_living_neis = val1 + val2 + val3 + val4 + val5 + val6 + val7 + val8;\n    float prod = num_living_neis.x * num_living_neis.y * num_living_neis.z * num_living_neis.w;\n    float sum = num_living_neis.x + num_living_neis.y + num_living_neis.z + num_living_neis.w;\n    float ave = sum / 4.0;\n    float a1 = 1.5*pow(cos(0.11*iTime),2.0), a2 = 5.5*pow(cos(0.11*iTime*(1.0-cos(0.9*iTime)*(fragCoord.y/10.0))),2.0), a3 = a1, a4 = a2;\n    if (ave < a1) return val-(val-num_living_neis/8.0)+0.1;\n    if (ave > a2) return val-(val-num_living_neis/8.0)-0.1-ave*pow(sin(0.31*iTime),2.0);\n    if (ave > a3 && ave < a4) return val+(val-num_living_neis/8.0)+ave*pow(sin(0.19*iTime),2.0);\n    else return val;\n}\n\nvec4 game_of_life_weird8(vec4 val, vec4 val1, vec4 val2, vec4 val3, vec4 val4, vec4 val5, vec4 val6, vec4 val7, vec4 val8, vec2 fragCoord){\n    //return (val+val1+val2+val3+val4)/5.0;\n    vec4 num_living_neis = val1 + val2 + val3 + val4 + val5 + val6 + val7 + val8;\n    float prod = num_living_neis.x * num_living_neis.y * num_living_neis.z * num_living_neis.w;\n    float sum = num_living_neis.x + num_living_neis.y + num_living_neis.z + num_living_neis.w;\n    float ave = sum / 4.0;\n    float a1 = 1.5*pow(cos(0.11*iTime),2.0), a2 = 5.5*pow(cos(0.11*iTime*(1.0-cos(0.9*iTime)*(fragCoord.y/10.0))),2.0), a3 = a1, a4 = a2;\n    if (ave < a1) return val-(val-num_living_neis/8.0)+0.1;\n    if (ave*prod > a2) return val-(val-num_living_neis/8.0)-0.1-ave*pow(sin(0.31*iTime),2.0);\n    if (ave > a3 && ave < a4) return val+(val-num_living_neis/8.0)+ave*pow(sin(0.19*iTime),2.0);\n    else return val;\n}\n\nvec4 game_of_life_weird9(vec4 val, vec4 val1, vec4 val2, vec4 val3, vec4 val4, vec4 val5, vec4 val6, vec4 val7, vec4 val8, vec2 fragCoord){\n    //return (val+val1+val2+val3+val4)/5.0;\n    vec4 num_living_neis = val1 + val2 + val3 + val4 + val5 + val6 + val7 + val8;\n    float prod = num_living_neis.x * num_living_neis.y * num_living_neis.z * num_living_neis.w;\n    float sum = num_living_neis.x + num_living_neis.y + num_living_neis.z + num_living_neis.w;\n    float ave = sum / 4.0;\n    float a1 = 1.5, a2 = 5.5*pow(cos(0.11*(1.0-cos(0.9*iTime)*(fragCoord.y/10.0))),2.0), a3 = a1, a4 = a2;\n    float u = fragCoord.x/31.0, v = fragCoord.y/50.0;\n    if (ave < a1*v) return val-(val-num_living_neis/8.0)+0.1;\n    if (ave > a2*u) return val-(val-num_living_neis/8.0)-0.1-ave*pow(sin(0.31*iTime),2.0);\n    if (ave > a3*v && ave < a4*u) return val+(val-num_living_neis/8.0)+ave*pow(sin(0.19*iTime),2.0);\n    else return val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 val = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    ivec2 nei1 = ivec2(mod(fragCoord.x+1.0,iResolution.x),mod(fragCoord.y+1.0,iResolution.y));\n    ivec2 nei2 = ivec2(mod(fragCoord.x-1.0,iResolution.x),mod(fragCoord.y-1.0,iResolution.y));\n    ivec2 nei3 = ivec2(mod(fragCoord.x+1.0,iResolution.x),mod(fragCoord.y-1.0,iResolution.y));\n    ivec2 nei4 = ivec2(mod(fragCoord.x-1.0,iResolution.x),mod(fragCoord.y+1.0,iResolution.y));\n    ivec2 nei5 = ivec2(mod(fragCoord.x-1.0,iResolution.x),mod(fragCoord.y,iResolution.y));\n    ivec2 nei6 = ivec2(mod(fragCoord.x+1.0,iResolution.x),mod(fragCoord.y,iResolution.y));\n    ivec2 nei7 = ivec2(mod(fragCoord.x,iResolution.x),mod(fragCoord.y+1.0,iResolution.y));\n    ivec2 nei8 = ivec2(mod(fragCoord.x,iResolution.x),mod(fragCoord.y-1.0,iResolution.y));\n    vec4 val1 = texelFetch(iChannel0, nei1, 0);\n    vec4 val2 = texelFetch(iChannel0, nei2, 0);\n    vec4 val3 = texelFetch(iChannel0, nei3, 0);\n    vec4 val4 = texelFetch(iChannel0, nei4, 0);\n    vec4 val5 = texelFetch(iChannel0, nei5, 0);\n    vec4 val6 = texelFetch(iChannel0, nei6, 0);\n    vec4 val7 = texelFetch(iChannel0, nei7, 0);\n    vec4 val8 = texelFetch(iChannel0, nei8, 0);\n\n\n    if (iFrame == 0) {\n        if (hash(fragCoord.x+fragCoord.y*iResolution.x) > 0.3) {\n        val = vec4(0.3,0.5,0.5,1.0);\n            if (hash(fragCoord.x+fragCoord.y*iResolution.x) > 0.7) {\n            val = vec4(0.3,0.3,0.3,1.0);\n            }\n        }\n        else {\n        val = vec4(1.0);\n        }\n    } else {\n        //val = game_of_life(val,val1,val2,val3,val4,val5,val6,val7,val8);\n        //val = game_of_life_weird6(val,val1,val2,val3,val4,val5,val6,val7,val8);\n        val = game_of_life_weird9(val,val1,val2,val3,val4,val5,val6,val7,val8,fragCoord);\n\n    }\n    fragColor = val;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlXz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 174, 243, 612]], "test": "untested"}
{"id": "ftfXRX", "name": "Curvature blindness illusion_", "author": "rubix", "description": "based on https://twitter.com/emollick/status/1414436947733499905 (Takahashi Curvature Blindness Illusion, iPerception 2017)", "tags": ["opticalillusion"], "likes": 4, "viewed": 233, "published": 3, "date": "1626136720", "time_retrieved": "2024-07-30T19:11:11.687874", "image_code": "// rubix 2021-07-13\n// based on https://twitter.com/emollick/status/1414436947733499905 (Takahashi's iPerception, 2017)\n\n#define TAU 6.28318530718\n\nfloat background(vec2 p) {\n    float b = p.x-p.y;\n    \n    //if (b < -0.1) return 1.;\n    //if (b < 0.6) return 0.5;\n    //return 0.;\n    \n    float t = fwidth(b);\n    return 0.5 * smoothstep(0.6+t, 0.6-t, b)\n         + 0.5 * smoothstep(-0.1+t, -0.1-t, b);\n}\n\nfloat color(vec2 p) {\n    float d = 250.*p.y + 1.*sin(100.*p.x);\n    int z = int(d+1.) % 24;\n    \n    //if (z == 0 || z == 3)\n    //    return sin(100.*p.x) < 0. ? 0.3 : 0.7;\n    //if (z == 12 || z == 15)\n    //    return sin(100.*p.x - TAU/4.) < 0. ? 0.3 : 0.7;\n    //return background(p);\n    \n    float t = fwidth(p.x);\n    float x = fwidth(2.*d);\n    float wave = smoothstep((5.-x)/6., (5.+x)/6., abs(fract(d/3.)*3.-2.));\n    float c = background(p);\n    if (z < 6)\n        c = mix(c, mix(0.3, 0.7, smoothstep(-t, t, sin(100.*p.x))), wave);\n    if (z > 11 && z < 18)\n        c = mix(c, mix(0.3, 0.7, smoothstep(-t, t, sin(100.*p.x - TAU/4.))), wave);;\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.x;\n    fragColor = vec4(vec3(color(uv)), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftfXRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 148, 174, 174, 406], [408, 408, 429, 429, 1079], [1081, 1081, 1136, 1136, 1220]], "test": "untested"}
{"id": "7lsXR2", "name": "XOR Towers in Fog & Rain", "author": "GregRostami", "description": "Another variation of KilledByAPixel's Voxel Fractal:\n[url]https://www.shadertoy.com/view/NlB3Rz[/url]\nRain code from P_Malin's SmallStars\n[url]https://www.shadertoy.com/view/Ml2XDt[/url]", "tags": ["3d", "voxel", "fog", "city", "lights", "short"], "likes": 19, "viewed": 779, "published": 3, "date": "1626119791", "time_retrieved": "2024-07-30T19:11:12.445847", "image_code": "// Added rain code from P_Malin\n// You can toggle features by placing a comment \"//\" in front of each line that has a \"*\" in comments.\nvoid mainImage(out vec4 o, vec2 u)\n{ \n    ivec4 b = ivec4(o -= o);                   // Initialize b=0\n     vec2 R = iResolution.xy;\n    float t = .1*iTime, B, h, z;\n            \n    u =\n        (2. + cos(t)) *                        // * Camera push in/out \n        (u+u-R)/R.y                            //   Center coordinates\n        * mat2( cos( vec4(0,33,55,0) - .1*t))  // * Rotate camera\n        ;\n            \n    for ( z = (h = cos(B = ceil(atan(u.x, u.y) * 2e2))) / dot(u,u); //Variables for Rain\n          (b.x^b.y^b.z)%99 > b.z-8 ; )         // The XOR function for towers!!\n          b = ivec4(u * o.a + 2e2\n                + vec2(7,30)*t                 // * Move camera (x,y)\n                , o+=.1 );                     // Increment layer\n                \n    o =\n        o.a < 8.1 ? .1+sin(t/.1)*vec4(b%32 & b.x%9 & b.z%9) :  // * Blinking lights\n        o/70. - .02 *                                          // * Distance fog\n        vec4(b%3)                                              // * building colors\n        + .06 * texture( iChannel1, .02*u - .03*t ).r          // * Moving fog\n        + .01 * max(exp(fract(h * B - z + t+t) * -1e2) / z,0.) // * Rain\n        ;\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27797, "src": "https://soundcloud.com/appy-the-gm/blade-runner-blues-vangelis-hd", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lsXR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 135, 171, 171, 1330]], "test": "untested"}
{"id": "7lsXzj", "name": "iChannel texture - 005", "author": "catafest", "description": "The kaleidoscope distorsion build with math functions sine and cosine changed by mouse position", "tags": ["math", "kaleidoscope", "sine", "cosine", "distorsion"], "likes": 1, "viewed": 556, "published": 3, "date": "1626112307", "time_retrieved": "2024-07-30T19:11:13.207810", "image_code": "#define PI 3.14159265358979\n\n#define distance 0.6 \n\n//#define amplitude 7.0\n\n#define angular_frequency 7.0\n\n//affects the distorsion speed\n#define TIME_FACTOR 1.0\n\n//vec2 for mouse position \nvec2 mp;\n\n// simple sine and cosine functions used with uv for wave effect\nfloat sine_wave(float t, float amplitude)\n{\n    return amplitude*(sin(angular_frequency * PI*t));\n}\n\nfloat cosine_wave(float t, float amplitude)\n{\n    return amplitude*(cos(angular_frequency * PI*t));\n}\n\n//main function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// get the uv \n    vec2 uv = fragCoord.xy/ iResolution.xy;\n    // center of the uv\n    vec2 CENTER = uv/2.0; \n    // get the mouse position \n    mp = iMouse.xy / iResolution.xy;\n    // vec2 for build uv \n    vec2 mp_uv=vec2(0,0);\n    // the mouse position let you to see the distorsion versus \n    if (mp.x > CENTER.x)\n    {\n    //this basic kaleidoscope distorsion is build with parts from uv.x and uv.y and mouse position\n       \n        // if you use angular_frequency 0.5 you will see the full image \n        // 1.0-uv.x is inverse image only to uv.x\n        // the number of square = screen size / angular_frequency\n        // default is 7 squares\n        float xx = sine_wave  (1.0-uv.x, mp.x);\n        float yy = cosine_wave(1.0-uv.y, mp.y);\n        \n        mp_uv = vec2(xx,yy);  \n    }\n    else \n    {\n    // this move the uv by mouse position\n    mp_uv = vec2(uv.x + mp.x ,uv.y + mp.y);\n    }\n\n    // the output on screen is fragColor and is a iChannel0 input with the build mp_uv\n    fragColor = texture(iChannel0, mp_uv);\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lsXzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[201, 266, 309, 309, 365], [367, 367, 412, 412, 468], [470, 486, 543, 559, 1580]], "test": "untested"}
{"id": "7lsSRj", "name": "Noise01_WhitePetal", "author": "WhitePetal", "description": "Noise Learning", "tags": ["noise"], "likes": 1, "viewed": 216, "published": 3, "date": "1626102497", "time_retrieved": "2024-07-30T19:11:14.088456", "image_code": "vec2 truchetPattern(in vec2 _st, in float _index){\n    _index = fract(((_index-0.5)*2.0));\n    if (_index > 0.75) {\n        _st = vec2(1.0) - _st;\n    } else if (_index > 0.5) {\n        _st = vec2(1.0-_st.x,_st.y);\n    } else if (_index > 0.25) {\n        _st = 1.0-vec2(1.0-_st.x,_st.y);\n    }\n    return _st;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv1 = floor(uv * vec2(10));\n    vec2 uv2 = fract(uv * vec2(10));\n    // random = fract(sin(x * c))   c: The degree of randomness -> 1 / Tilling\n    // rando_2d = fract(sin(dot(vec2_x, vec2_d)) * c)    vec2_d: random dir\n    float random = fract(sin(dot(uv1, vec2(31.415926, 2.34765))) * 400003.32456);\n    vec2 tile = truchetPattern(uv2, random);\n    float color = smoothstep(tile.x-0.5,tile.x,tile.y)-\n            smoothstep(tile.x,tile.x+0.5,tile.y);\n    \n\n    // Output to screen\n    fragColor = vec4(vec3(color), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lsSRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 50, 50, 311], [313, 313, 370, 420, 994]], "test": "untested"}
{"id": "stsSRj", "name": "Noise00_WhitePetal", "author": "WhitePetal", "description": "Noise Learning", "tags": ["noise"], "likes": 1, "viewed": 213, "published": 3, "date": "1626101143", "time_retrieved": "2024-07-30T19:11:14.835458", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // vec2 uv1 = floor(uv * vec2(10));\n    vec2 uv1 = uv;\n    // random = fract(sin(x * c))   c: The degree of randomness -> 1 / Tilling\n    // rando_2d = fract(sin(dot(vec2_x, vec2_d)) * c)    vec2_d: random dir\n    float random = fract(sin(dot(uv1, vec2(31.415926, 2.34765))) * 400003.32456);\n\n    float color = random;\n    \n\n    // Output to screen\n    fragColor = vec4(vec3(color), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stsSRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 547]], "test": "untested"}
{"id": "sllSRj", "name": "Sommarhack 2021 - Rising phoenix", "author": "mrange", "description": "Sommarhack 2021 - Rising phoenix\nWanted to use the distance field created earlier\nMusic: https://soundcloud.com/no-om-uo-n/sommarhack-2020\n", "tags": ["stars", "sommarhack"], "likes": 10, "viewed": 439, "published": 3, "date": "1626101005", "time_retrieved": "2024-07-30T19:11:15.591437", "image_code": "// Sommarhack 2021 - Rising phoenix\n// Wanted to use the distance field created earlier\n// Music: https://soundcloud.com/no-om-uo-n/sommarhack-2020\n\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            (mod(iTime, 3.0*60.0+12.0))\n#define TTIME           (TAU*TIME)\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define SCA(a)          vec2(sin(a), cos(a))\n#define PCOS(x)         (0.5+0.5*cos(x))\n#define DOT2(x)         dot(x, x)\n#define BREAK           16.1\n\nconst vec3 std_gamma        = vec3(2.2);\n\nfloat hash(float co) {\n  co += 123.4;\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// https://iquilezles.org/articles/intersectors\nvec2 rayCylinder(vec3 ro, vec3 rd, vec3 cb, vec3 ca, float cr) {\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0); //no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat vesica(vec2 p, vec2 sz) {\n  if (sz.x < sz.y) {\n    sz = sz.yx;\n  } else {\n    p  = p.yx; \n  }\n  vec2 sz2 = sz*sz;\n  float d  = (sz2.x-sz2.y)/(2.0*sz.y);\n  float r  = sqrt(sz2.x+d*d);\n  float b  = sz.x;\n  p = abs(p);\n  return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                           : length(p-vec2(-d,0.0))-r;\n}\n\nfloat moon(vec2 p, float d, float ra, float rb ) {\n    p.y = abs(p.y);\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n          return length(p-vec2(a,b));\n    return max( (length(p          )-ra),\n               -(length(p-vec2(d,0))-rb));\n}\n\n// Imprecise faster version\nfloat fastMoon(vec2 p, float d, float ra, float rb) {\n  float d0 = length(p) - ra;\n  float d1 = length(p-vec2(d, 0.0)) - rb;\n  return max(d0, -d1);\n}\n\nfloat roundedCross( in vec2 p, in float h )\n{\n    float k = 0.5*(h+1.0/h); // k should be const at modeling time\n    p = abs(p);\n    return ( p.x<1.0 && p.y<p.x*(k-h)+h ) ? \n             k-sqrt(DOT2(p-vec2(1,k)))  :\n           sqrt(min(DOT2(p-vec2(0,h)),\n                    DOT2(p-vec2(1,0))));\n}\n\nfloat plane(vec2 p, vec3 pp) {\n  return dot(p, pp.xy) + pp.z;\n}\n\n\nfloat summerhack(vec2 p) {\n  // As the moon shapes are mostly used for cut-outs I think there is less need for exact\n  //  moon distance and therefore rely on fastMoon instead\n  vec2 op = p;\n  p.x = abs(p.x);\n  vec2 p0 = p;\n  p0 -= vec2(0.0, 0.385);\n  float d0 = circle(p0, 0.605);\n  vec2 p1 = p;\n  p1 -= vec2(0.0, -0.375);  \n  float d1 = vesica(p1, vec2(0.04, 0.569))-(mix(0.005, 0.035, smoothstep(0.1, 0.2, p1.y)));\n  \n  vec2 p2 = p;\n  p2 -= vec2(0.0, 0.4);\n  p2 = -p2.yx;\n  float d2 = fastMoon(p2, 0.075, 0.33, 0.275);\n  \n  vec2 p3 = p;\n  p3 -= vec2(0.0, 0.65);\n  float d3 = circle(p3, 0.367);\n  \n  vec2 p4 = p;\n  p4 -= vec2(0.0, 0.43);\n  float d4 = circle(p4, 0.29);\n  \n  vec2 p5 = p;\n  p5 -= vec2(-0.185, 0.12);\n  float d5 = circle(p5, 0.30);\n  \n  vec2 p6 = p;\n  p6 -= vec2(0.12, -0.19);\n  p6 *= ROT(0.65);\n  float d6 = vesica(p6, vec2(0.15, 0.024))-0.0175;\n  \n  vec2 p7 = p;\n  p7 -= vec2(0.0, 0.735);\n  p7 = -p7.yx;\n  float d7 = fastMoon(p7, 0.13, 0.68, 0.595);\n  \n  vec2 p8 = p;\n  p8 -= vec2(0.0, 0.7);\n  p8 = -p8.yx;\n  float d8 = fastMoon(p8, 0.1, 0.477, 0.4676);\n\n  vec2 p9 = p;\n  p9 -= vec2(0.25, 0.72);\n  p9.x = -p9.x;\n  float d9 = fastMoon(p9, 0.188, 0.73, 0.775);\n\n  vec2 p10 = op;\n  p10 -= vec2(0.0, 0.28);\n  p10 = p10.yx;\n  p10.x *= sign(op.x);\n  p10.x += (-sign(op.x)+1.0)*-0.0775;\n  float d10 = moon(p10, 0.045, 0.105, 0.095);\n\n  vec2 p11 = p;\n  p11 -= vec2(0.0, -0.78);\n  p11 = p11.yx;\n  float d11 = roundedCross(p11, 0.55);\n  \n  vec2 p12 = p;\n  float d12 = plane(p12, vec3(normalize(vec2(-4.0, 1.0)), 0.315));\n  \n  vec2 p13 = p;\n  p13 -= vec2(-0.05, -0.805);\n  float d13 = circle(p13, 0.175);\n\n  vec2 p14 = p;\n  p14 -= vec2(0.0, -0.88);\n  float d14 = p14.y;\n  \n  vec2 p15 = p;\n  p15 -= vec2(0.45, -0.4);\n  p15 = p15.yx;\n  float d15 = fastMoon(p15, 0.14, 0.4, 0.4);\n\n  vec2 p16 = op;\n  p16 -= vec2(-0.095, 0.323);\n  // Cheat to remove discontinuity in distance field due to hacking on d10\n  float d16 = length(p16); \n    \n  d11 = max(d11, -d12);\n  d11 = max(d11, -d13);\n  d11 = max(d11, -d14);\n  d11 = max(d11, -d15);\n\n  float dn = d3;\n  dn = min(dn, d4);\n  dn = min(dn, d2);\n  dn = min(dn, d5);\n  dn = min(dn, d6);\n  dn = min(dn, d7);\n  dn = min(dn, d8);\n  dn = min(dn, d9);\n\n  float d = d0;\n  d = max(d, -dn);\n  d = min(d, d1);\n  d = min(d, d10);\n  d = min(d, d11);\n  d = min(d, d16);\n  \n\n  return d;\n}\n\nfloat beat() {\n  float fft = 0.0;\n  fft += texture(iChannel0, vec2(0.1, 0.25)).x; \n  fft += texture(iChannel0, vec2(0.2, 0.25)).x; \n  fft += texture(iChannel0, vec2(0.3, 0.25)).x; \n  fft += texture(iChannel0, vec2(0.4, 0.25)).x; \n  fft *= 0.25;\n  return fft;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd, float b) {\n  b *= step(BREAK, TIME);\n\n  const vec3 l = normalize(vec3(0.0, 0.0, 1));\n  vec3 baseCol = vec3(0.5, 0.66, 1.0)+b*b*vec3(1.0);\n  return 1.25*baseCol*pow(max(dot(l, normalize(rd*vec3(1.0, 0.33, 1.0))), 0.0), mix(250.0, 200.0, b));\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p, float b) {\n  float lp = length(p);\n  vec2 np = p + 1.0/RESOLUTION.xy;\n  float rdd = (2.0+0.5*tanh_approx(lp));  // Playing around with rdd can give interesting distortions\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  \n  vec3 skyCol = skyColor(ro, rd, b);\n\n  float aa = TIME*0.125;\n  rd.yx *= ROT(aa);\n  float a = atan(rd.y, rd.x);\n\n  vec3 col = skyCol;\n  const float mm = 5.0;\n  for(float i = 0.0; i < mm; ++i) {\n    float ma = a;\n    float ii = i/(mm-1.0);\n    float sz = 31.0+i*64.0;\n    float slices = TAU/sz; \n    float na = mod1(ma, slices);\n\n    float hh = hash(na+113.0*i);\n    float h1 = hh;\n    float h2 = fract(hh*113.0);\n    float h3 = fract(hh*127.0);\n\n    float tr = mix(0.25, 2.0, h1);\n    vec2 tc = rayCylinder(ro, rd, ro, vec3(0.0, 0.0, 1.0), tr);\n    vec3 tcp = ro + tc.y*rd;\n    vec2 tcp2 = vec2(tcp.z+h2*2.0, atan(tcp.y, tcp.x));\n  \n    float sx = mix(0.75, 1.5, h3);\n    vec2 tnp2 = mod2(tcp2, vec2(sx, slices));\n    tcp2.y *= tr*PI;\n    float h4 = hash(tnp2.x+hh);\n    float h5 = fract(113.0*h4);\n    tcp2.x += 0.4*sx*h4;\n    float d = length(tcp2)-0.001;\n\n    float si = exp(-(100.0+1.4*sz)*max(d, 0.0));\n\n    vec3 hsv = vec3(-0.0-0.4*h4, mix(0.4, 0.00, ii), 1.0);\n    vec3 bcol = hsv2rgb(hsv)*3.0;\n    vec4 scol = vec4(bcol*sqrt(si), sqrt(si)*exp(-0.05*tc.y*tc.y));\n\n    col = alphaBlend(col, scol);\n  }\n\n  return col;\n}\n\nvec3 overlay(vec3 col, vec2 p, vec2 q, float b) {\n  vec2 op = p;\n  float aa = 2.0/RESOLUTION.y;\n\n  float dist = PCOS(80.0*(op.y-TTIME/30.0))*PCOS(23.0*length(op+op.x-TTIME/43.0));\n  float fade = mix(0.7, 1.0, smoothstep(15.0, 20.1, TIME))*mix(0.945, 0.95, smoothstep(0.5, 1.0, q.y)*dist)*0.97;\n\n  vec2 pi = p;\n  float off = sqrt(p.x*p.x+p.y*p.y);\n  const float coff = PI;\n  float angle = off+mix(coff*0.42, -coff*0.42 , fade);\n  float split = angle+coff;\n  int nsplit = int(mod1(split, coff));\n  split = (nsplit & 1) == 0 ? split : -split;\n\n  const float zi = 1.0;\n  pi /= zi;\n  float di  = summerhack(pi);\n  float dii = abs(di-0.0125) - 0.0025;\n  di = min(di, dii);\n  di *= zi;\n  \n  float dg = di;\n\n  const vec3 lcol2 = vec3(2.0, 1.55, 1.25).zyx*0.85;\n\n  float gmix = pow(abs(cos(angle)), 14.0);\n  float gmix2 = abs(1.0/tanh_approx(split))*0.5;\n\n  dg = abs(dg-0.025);\n  float glow = exp(-10.0*max(dg+0., 0.0));\n  vec3 glowCol = mix(lcol2.zyx*lcol2.zyx/6.0, lcol2.zyx, glow*glow)*gmix2;\n  col = mix(col, vec3(mix(vec3(0.9), sqrt(glowCol*0.5), gmix)), smoothstep(-aa, aa, -di));\n  col += glowCol*glow*gmix;\n\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float tm  = TIME;\n  vec3 ro   = vec3(0.0, 0, tm);\n  vec3 dro  = normalize(vec3(0.20, 0.2, 1.0));\n  dro.xz *= ROT(0.2*sin(0.05*tm));\n  dro.yz *= ROT(0.2*sin(0.05*tm*sqrt(0.5)));\n  vec3 up = vec3(0.0,1.0,0.0);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = normalize(cross(ww, uu));\n\n  float b = beat();\n  \n  vec3 col = color(ww, uu, vv, ro, p, b);\n  \n  if (TIME > BREAK) {\n    col = overlay(col, p, q, b);\n  }\n  \n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, vec3(1.0/2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, q);\n  \n  col += smoothstep(2.0+0.25*length(p), 0.0, TIME);\n  col += smoothstep(BREAK-0.4+length(p)*0.15, BREAK, TIME)*smoothstep(BREAK+3.0+length(p), BREAK, TIME);\n  \n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": 27794, "src": "https://soundcloud.com/no-om-uo-n/sommarhack-2020", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sllSRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[596, 596, 618, 618, 681], [683, 762, 784, 784, 953], [955, 955, 994, 994, 1083], [1085, 1085, 1124, 1124, 1153], [1155, 1155, 1195, 1195, 1237], [1239, 1239, 1267, 1287, 1363], [1365, 1396, 1435, 1435, 1560], [1562, 1562, 1598, 1598, 1692], [1694, 1742, 1806, 1806, 2134], [2136, 2136, 2163, 2163, 2239], [2241, 2241, 2272, 2272, 2298], [2300, 2300, 2331, 2331, 2629], [2631, 2631, 2681, 2681, 2958], [2960, 2988, 3041, 3041, 3137], [3139, 3139, 3184, 3184, 3436], [3438, 3438, 3468, 3468, 3501], [3504, 3504, 3530, 3679, 5826], [5828, 5828, 5842, 5842, 6088], [6090, 6090, 6132, 6132, 6364], [6366, 6366, 6431, 6431, 7770], [7772, 7772, 7821, 7821, 8894], [8896, 8896, 8925, 8925, 9387], [9389, 9389, 9425, 9425, 9658], [9660, 9660, 9715, 9715, 10065]], "test": "untested"}
{"id": "NtlXzB", "name": "Almost tempo-synced", "author": "Shellderr", "description": "Syncing a parameter to musically animate a fractal. White dot is the Julia coordinate. Soundcloud wont load..", "tags": ["fractal", "julia"], "likes": 1, "viewed": 149, "published": 3, "date": "1626090641", "time_retrieved": "2024-07-30T19:11:16.342429", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n}", "image_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define res iResolution\n#define dst(v,a) (a/dot(uv-v,uv-v))\n#define tri(t) abs(fract(t)-.5)*2.\n\nfloat hash(vec2 v){\n    return fract(sin(dot(v, vec2(53.7781, 31.0314)))*77412.41);\n}\n\nfloat hash1(float f){\n    return fract(sin(f*55.35)*77412.41);\n}\n\nvoid mainImage(out vec4 fcolor, in vec2 fcoord){\n\n    vec2 uv = (2.*fcoord-res.xy)/res.y;\n    \n    float time = iTime*1.9029;\n    \n    vec2 v = vec2(hash1(floor(time)), hash1(floor(1.+time)))-.5;\n//    vec3 c = dst(v,.001)*vec3(.2, .5, 1.);\n    \n    vec2 v2 = vec2(hash1(3.3+floor(time)), hash1(3.3+floor(1.+time)))-.5;\n//    vec3 c2 = dst(v2,.001)*vec3(.8, .2, 1.);\n    \n    vec2 v3 = mix(v, v2, clamp(fract(time)*8.,0., 1.));\n    v3 += vec2(-.5,.2);\n   // vec3 c3 = dst(v3,.001)*vec3(.0, .9, 1.);\n\n   fcolor = vec4(v3, 0., 0.);\n}", "buffer_a_inputs": [], "buffer_b_code": "#define res iResolution\n#define thresh 20.\n#define stop 200\n\nvec3 rgb(float a){\n    a *=10.;\n    return(cos(4.+a+vec3(0.,2.,4.)*.7)*.5+.5);\n}\n\nvec2 cmul(vec2 a, vec2 b){\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2){\n    float a = (v1.x*v2.x+v1.y*v2.y)/(v2.x*v2.x+v2.y*v2.y);\n    float b = (v1.y*v2.x-v1.x*v2.y)/(v2.x*v2.x+v2.y*v2.y);\n    return vec2(a,b);\n}\n\nvec2 cexp(vec2 z){\n    return exp(z.x)*vec2(cos(z.y),sin(z.y));\n}\n\nvec2 clog(vec2 z){\n    return vec2(log(length(z)),atan(z.y,z.x));\n}\n\nvec2 cpow(vec2 z, float c){\n    return cexp(c*clog(z));\n}\n\n\nvec2 clerp(vec2 a, vec2 b, float m){\n    m = clamp(m,0.,1.);\n    return cmul(vec2(1.-m),a)+cmul(vec2(m),b);\n}\n\n\nvec2 rot(vec2 v, float t){\n    float a = (1.*atan(v.x,v.y))+t;\n    return vec2(cos(a),sin(a))*length(v);\n}\n\n//https://www.shadertoy.com/view/XdcXzn\nmat4 brightnessMatrix( float brightness )\n{\n    return mat4( 1, 0, 0, 0,\n                 0, 1, 0, 0,\n                 0, 0, 1, 0,\n                 brightness, brightness, brightness, 1 );\n}\nmat4 contrastMatrix( float contrast )\n{\n\tfloat t = ( 1.0 - contrast ) / 2.0;\n    \n    return mat4( contrast, 0, 0, 0,\n                 0, contrast, 0., 0,\n                 0.4, 0., contrast, 0.,\n                 0, 0, 0, 0 );\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (2.*fragCoord.xy-res.xy)/res.y;\n    vec2 z = .8*uv;\n    // z = rot(z,time);\n    //vec2 zz = vec2(0);\n    z = clerp(.3*clog(vec2(2)+z), (cdiv(vec2(.5),z)), .1);\n    // z = cexp(cmul(z,vec2(.4)));\n    z=rot(z,iTime*.3);\n    vec2 mouse = .5*iMouse.xy/res.xy;\n    vec2 c = mouse.xy==vec2(0)? vec2(-.77,-.22)/*vec2(cos(iTime*.4)-.3,-.66)*/: (2.*mouse.xy-1.);\n    vec2 coord =  texture(iChannel1, fragCoord.xy/iResolution.xy).xy;\n\n    int i = 0;\n    for(i; i < stop; i++){\n        z = cmul(z,z)+coord;\n        if(length(z) > thresh)\n            break;\n    }\n    vec3 col = rgb(log(.9+float(i)/380.)*2.);\n    vec3 fb = texture(iChannel0, fragCoord.xy/iResolution.xy*.995).xyz;\n//    fragColor = vec4(col-fb*.2, 1.0 );\n    // vec3 oc =  ((.7+.3*col)/(col-fb));\n     vec3 oc =  iFrame > 4 ? 1./fb-(col/fb) : col;;\n //    vec3 oc =  fb-(col/fb);\n //    vec3 oc =  1./fb*(col/fb);\n \n    fragColor = vec4(col*(.4+.7*oc), 1.0 );\n   // fragColor.xyz = mix(fragColor.xyz,pow(fragColor.xyz,vec3(1.3)),.7);\n    fragColor.xyz += (.001/dot(uv-coord,uv-coord))*vec3(.3,.6,.9)*clamp(sin(iTime*.5)*.77,0.,1.);\n    fragColor.xyzw *= contrastMatrix(.7);\n\n}\n\n\n\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtlXzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 124]], "test": "untested"}
{"id": "NtsXR2", "name": "Digits7", "author": "spalmer", "description": "idk why, just saw Kamoshika's toy and had a brief spurt of inspiration which, oddly, actually resulted in working code that's somewhat post-worthy, so enjoy!", "tags": ["7segment", "digits", "print", "numeric"], "likes": 12, "viewed": 371, "published": 3, "date": "1626088610", "time_retrieved": "2024-07-30T19:11:17.099405", "image_code": "// had some brief spurt of inspiration when looking at this toy\n// Simple 7-segment Numbers by Kamoshika https://shadertoy.com/view/ftsSzB\n// but code is completely original by spalmer.  hope it's useful!\n\n// returns local (non-Euclidean metric) distance to segment edge\nfloat digit7(vec2 q, int n)\n{ // could add a few more 'digit' glyphs for minus sign and decimal point\n\tconst int digitsegs[10] = int[] ( \n\t\t95,10,118,122,43,121,125,26,127,123\n\t\t);\n\tif (n < 0 || n >= digitsegs.length()) return -1.; // just in case, array bound check\n\tint segs = digitsegs[n];\n\tconst ivec2 segpos[7] = ivec2[] ( \n\t\t  ivec2(-1,1), ivec2(1,1), ivec2(-1,-1), ivec2(1,-1) // 4 vertical segments\n\t\t, ivec2(0,2), ivec2(0,0), ivec2(0,-2) // 3 horizontal segments\n\t\t// maybe a period TODO\n\t\t);\n\tfloat d = 3.4e38;\n\tfor (int i = segpos.length(); i-- > 0; ) {\n\t\tif ((segs & (1 << i)) == 0) continue;\n\t\tvec2 p = vec2(segpos[i]); //vec2(.0, .0); \n\t\tp *= vec2(.45, .45);\n\t\tp = q - p; //p -= q; // doesn't matter\n\t\tbool vertical = i < 4;\n\t\t//bool period = false;\n\t\t//bool minus = false;\n\t\tif (vertical) p = p.yx; // rotate some 90degrees\n\t\tp = abs(p);\n\t\tvec2 w = vec2(.35, .0); //vec2(period ? 0. : .35, 0.); //\n\t\tp -= w;\n\t\tp = max(p, vec2(0));\n\t\tfloat dx = (p.x + p.y);\n\t\td = min(d, dx);\n\t}\n\td *= sqrt(.5); // correct for metric\n\treturn d - .05; // seg thickness\n}\n\nvoid digits7(inout vec4 o, vec4 c, vec2 q, vec2 R, uint value)\n{\n\tfloat d = 3.4e38;\n    //value %= 10000u;\n\tfor (int i = 4; i-- > 0; ) {\n\t\td = min(d, digit7(q, int(value%10u)));\n\t\tvalue = value / 10u;\n\t\tq.x += 1.25;\n\t}\n\tfloat a = clamp(.5 - .25 * R.y * d, 0., 1.); // antialias edge\n    a = mix(a, 1., exp2(-2. * max(0., d)) * .3 * (1. - abs(sin(3.14*iTime)))); // glow effect added 2023-3-11\n\to = mix(o, c, a);\n}\n\nvoid mainImage(out vec4 o, vec2 u)\n{\n\tvec2 R = iResolution.xy\n\t, q = (u * 2. - R) * .5 / R.y;\n\to = vec4(0);\n    uint n = uint(10. * iTime); //iFrame / 4); //\n\tdigits7(o, vec4(1.,.0,0,1), q * 4. - vec2(2. + .5*q.y, 0), R, n);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsXR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1339, 1339, 1403, 1403, 1752], [1754, 1754, 1790, 1790, 1980]], "test": "untested"}
{"id": "fllXR2", "name": "Hue Rainbow", "author": "spalmer", "description": "a simple rainbow hue function, 124 ch\n", "tags": ["rainbow", "hue", "golf"], "likes": 1, "viewed": 325, "published": 3, "date": "1626087655", "time_retrieved": "2024-07-30T19:11:17.854386", "image_code": "/** /\n// my pathetic 124 chars\nvoid mainImage(out vec4 o, vec2 p)\n{\n\to = sqrt(max(2. - 6.*abs(fract(p.x * 2. / iResolution.x) - vec4(0,1,2,3) / 3.), 0.));\n\to.x = max(o.x, o.w);\n}\n/**/\n// someone probably did this before; I know I've seen similar stuff\n// just worked this out from prior code I had based on Mundhenk and Jos Stam,\n// but it's so different I think it's basically original code now.\n// I could swear I've seen this style of clipped bump before though...\n// and there's no way I'll win the golfing game  ;)\n\n/** /\n// FabriceNeyret2 from http://shadertoy.com/view/ltyXRm, 110 ch here\nvoid mainImage(out vec4 o, vec2 p)\n{\n    o = sqrt(max(abs(fract(p.x * 2. / iResolution.x + vec4(3,2,1,0) / 3.) * 6. - 3.) - 1., 0.));\n}\n/**/\n\n/**/\n// Xor from comment at http://shadertoy.com/view/7tGBWz only 98 ch\nvoid mainImage(out vec4 O,vec2 C) \n{\n    O = sqrt(abs(mod(C.x/iResolution.x*12. + vec4(0,4,2,0), 6.)-3.)-1.); // 98 ch w properish gamma\n}\n//    O=abs(mod(C.x/iResolution.x*12.+vec4(0,4,2,0),6.)-3.)-1.; // 92 chars\n/**/\n\n/** /\n//  iq (96 chars, wrong gamma though): \n// from comment at http://shadertoy.com/view/7tGBWz\nvoid mainImage(out vec4 O,vec2 C) \n{\n    O=abs(6.*fract(C.x*2./iResolution.x+vec4(0,2,1,0)/3.)-3.)-1.;\n}\n/**/\n\n/** /\n// Fabrice from that same page comment: (87 ch)\nvoid mainImage(out vec4 O,vec2 U) \n{\n    O = .6 + .6 * cos(12.6 * U.x/iResolution.x + vec4(0,23,21,0));\n}\n/**/\n\n// duh, found an older unlisted toy of mine that\n// has las-inspired code that seems shorter!  haha\n// at Hue Test https://shadertoy.com/view/3t3GDs\n/** /\n// earliest use of this method I can find is by las in 2011:\n// http://www.pouet.net/topic.php?which=7920&page=29&x=14&y=9\n\nvec3 hue(float h)\n{\n\tvec3 h3 = fract(h - vec3(0, 1, 2) / 3.);\n\treturn clamp(abs(h3 * 6. - 3.) - 1., 0., 1.);\n}\n// of course would need inlined into main and further golfed\nvoid mainImage(out vec4 o, vec2 p) { o = vec4(hue(p.x*2./iResolution.x), 1); }\n/**/\n\n/** /\n// Xor from comments, 119 ch\nvoid mainImage(out vec4 o, vec2 p)\n{\n    o = sqrt(max(2.-abs(12.*mod(p.x / iResolution.x,.5) - vec4(0,2,4,6)),0.));\n\to = max(o, o.wyzx);\n}\n/**/\n\n/** /\n// Xor sqrt-less version from comments, 106 ch, looks pretty good but is not linear in gamma,\n// seems scaled slightly differently.\n// also I don't trust the undefined behavior using ++o inside expression involving o\nvoid mainImage(out vec4 o, vec2 p)\n{\n\to = -abs(3.*fract(p.x / iResolution.y) - vec4(0,1,2,3));\n\to = max(++o, o.wyzx)*2.; // U.B.\n}\n/**/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fllXR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[738, 810, 846, 846, 948]], "test": "untested"}
{"id": "NtfSz2", "name": "Sommarhack 2021", "author": "mrange", "description": "License CC0: Sommarhack 2021 as a distance field\nInspired by the Sommarhack 2021 I wanted to recreate the logo as a distance field\nto enable some cool effects later", "tags": ["2d", "summerhack"], "likes": 5, "viewed": 325, "published": 3, "date": "1626030098", "time_retrieved": "2024-07-30T19:11:18.601389", "image_code": "// License CC0: Sommarhack 2021 as a distance field\n//  Inspired by the Sommarhack 2021 I wanted to recreate the logo as a distance field\n//  to enable some cool effects later\n//  I took some liberties with the logo so it's not an exact replica\n//  The distance field isn't perfect but doesn't look too awful\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define DOT2(x)         dot(x, x)\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, vec3(1.0/2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\n// Lots of distance fields from: https://iquilezles.org/articles/distfunctions2d\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat vesica(vec2 p, vec2 sz) {\n  if (sz.x < sz.y) {\n    sz = sz.yx;\n  } else {\n    p  = p.yx; \n  }\n  vec2 sz2 = sz*sz;\n  float d  = (sz2.x-sz2.y)/(2.0*sz.y);\n  float r  = sqrt(sz2.x+d*d);\n  float b  = sz.x;\n  p = abs(p);\n  return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                           : length(p-vec2(-d,0.0))-r;\n}\n\nfloat moon(vec2 p, float d, float ra, float rb ) {\n    p.y = abs(p.y);\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n          return length(p-vec2(a,b));\n    return max( (length(p          )-ra),\n               -(length(p-vec2(d,0))-rb));\n}\n\n// Imprecise faster version\nfloat fastMoon(vec2 p, float d, float ra, float rb) {\n  float d0 = length(p) - ra;\n  float d1 = length(p-vec2(d, 0.0)) - rb;\n  return max(d0, -d1);\n}\n\nfloat roundedCross( in vec2 p, in float h )\n{\n    float k = 0.5*(h+1.0/h); // k should be const at modeling time\n    p = abs(p);\n    return ( p.x<1.0 && p.y<p.x*(k-h)+h ) ? \n             k-sqrt(DOT2(p-vec2(1,k)))  :\n           sqrt(min(DOT2(p-vec2(0,h)),\n                    DOT2(p-vec2(1,0))));\n}\n\nfloat box(vec2 p, vec2 b) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n \nfloat plane(vec2 p, vec3 pp) {\n  return dot(p, pp.xy) + pp.z;\n}\n \nfloat summerhack(vec2 p) {\n  // As the moon shapes are mostly used for cut-outs I think there is less need for exact\n  //  moon distance and therefore rely on fastMoon instead\n  vec2 op = p;\n  p.x = abs(p.x);\n  vec2 p0 = p;\n  p0 -= vec2(0.0, 0.385);\n  float d0 = circle(p0, 0.605);\n  vec2 p1 = p;\n  p1 -= vec2(0.0, -0.375);  \n  float d1 = vesica(p1, vec2(0.04, 0.569))-(mix(0.005, 0.035, smoothstep(0.1, 0.2, p1.y)));\n  \n  vec2 p2 = p;\n  p2 -= vec2(0.0, 0.4);\n  p2 = -p2.yx;\n  float d2 = fastMoon(p2, 0.075, 0.33, 0.275);\n  \n  vec2 p3 = p;\n  p3 -= vec2(0.0, 0.65);\n  float d3 = circle(p3, 0.367);\n  \n  vec2 p4 = p;\n  p4 -= vec2(0.0, 0.43);\n  float d4 = circle(p4, 0.29);\n  \n  vec2 p5 = p;\n  p5 -= vec2(-0.185, 0.12);\n  float d5 = circle(p5, 0.30);\n  \n  vec2 p6 = p;\n  p6 -= vec2(0.12, -0.19);\n  p6 *= ROT(0.65);\n  float d6 = vesica(p6, vec2(0.15, 0.024))-0.0175;\n  \n  vec2 p7 = p;\n  p7 -= vec2(0.0, 0.735);\n  p7 = -p7.yx;\n  float d7 = fastMoon(p7, 0.13, 0.68, 0.595);\n  \n  vec2 p8 = p;\n  p8 -= vec2(0.0, 0.7);\n  p8 = -p8.yx;\n  float d8 = fastMoon(p8, 0.1, 0.477, 0.4676);\n\n  vec2 p9 = p;\n  p9 -= vec2(0.25, 0.72);\n  p9.x = -p9.x;\n  float d9 = fastMoon(p9, 0.188, 0.73, 0.775);\n\n  vec2 p10 = op;\n  p10 -= vec2(0.0, 0.28);\n  p10 = p10.yx;\n  p10.x *= sign(op.x);\n  p10.x += (-sign(op.x)+1.0)*-0.0775;\n  float d10 = moon(p10, 0.045, 0.105, 0.095);\n\n  vec2 p11 = p;\n  p11 -= vec2(0.0, -0.78);\n  p11 = p11.yx;\n  float d11 = roundedCross(p11, 0.55);\n  \n  vec2 p12 = p;\n  float d12 = plane(p12, vec3(normalize(vec2(-4.0, 1.0)), 0.315));\n  \n  vec2 p13 = p;\n  p13 -= vec2(-0.05, -0.805);\n  float d13 = circle(p13, 0.175);\n\n  vec2 p14 = p;\n  p14 -= vec2(0.0, -0.88);\n  float d14 = p14.y;\n  \n  vec2 p15 = p;\n  p15 -= vec2(0.45, -0.4);\n  p15 = p15.yx;\n  float d15 = fastMoon(p15, 0.14, 0.4, 0.4);\n\n  vec2 p16 = op;\n  p16 -= vec2(-0.095, 0.323);\n  // Cheat to remove discontinuity in distance field due to hacking on d10\n  float d16 = length(p16); \n    \n  d11 = max(d11, -d12);\n  d11 = max(d11, -d13);\n  d11 = max(d11, -d14);\n  d11 = max(d11, -d15);\n\n  float dn = d3;\n  dn = min(dn, d4);\n  dn = min(dn, d2);\n  dn = min(dn, d5);\n  dn = min(dn, d6);\n  dn = min(dn, d7);\n  dn = min(dn, d8);\n  dn = min(dn, d9);\n\n  float d = d0;\n  d = max(d, -dn);\n  d = min(d, d1);\n  d = min(d, d10);\n  d = min(d, d11);\n  d = min(d, d16);\n  \n  \n  return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q    = fragCoord/RESOLUTION.xy;\n  vec2 p    = -1. + 2. * q;\n  p.x       *= RESOLUTION.x/RESOLUTION.y;\n  float aa  = 2.0/RESOLUTION.y;\n\n  float d = summerhack(p);  \n  float ds = summerhack(p-0.033*vec2(1.0, -1.0));\n\n  float od = abs(d-0.015)-0.0033;\n  d = min(d, od);\n\n  vec3 col  = vec3(0.1, 0.1, 0.2);\n  vec4 scol = vec4(col*0.5, smoothstep(-aa, aa, -ds)); \n  vec4 dcol = vec4(mix(vec3(1.0, 0.5, 0.5), vec3(1.0), q.y*q.y), smoothstep(-aa, aa, -d)); \n\n  col = alphaBlend(col, scol);\n  col = alphaBlend(col, dcol);\n  /* View distance field\n  if (p.x > 0.0)\n    col += 0.5*sin(300.0*d);\n  */\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtfSz2.jpg", "access": "api", "license": "cc0-1.0", "functions": [[542, 542, 578, 578, 811], [813, 813, 853, 853, 895], [979, 979, 1010, 1010, 1036], [1038, 1038, 1069, 1069, 1367], [1369, 1369, 1419, 1419, 1696], [1698, 1726, 1779, 1779, 1875], [1877, 1877, 1922, 1922, 2174], [2176, 2176, 2203, 2203, 2283], [2286, 2286, 2316, 2316, 2349], [2352, 2352, 2378, 2527, 4676], [4678, 4678, 4733, 4733, 5392]], "test": "ok"}
{"id": "ftlXW8", "name": "Fluidy fluid", "author": "michael0884", "description": "Messing around with fluids again a bit. Seems that distributing the velocity with a quadratic spline kernel and distributing mass with a dynamic mass distribution makes for a relatively smooth liquid with really sharp detail", "tags": ["fluid", "particles", "reintegration", "mpm", "apic"], "likes": 40, "viewed": 1353, "published": 3, "date": "1626021776", "time_retrieved": "2024-07-30T19:11:19.360360", "image_code": "//MIT License\n//Copyright 2021 Mykhailo Moroz\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb); \t\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    P = floor(P);\n    \n    if(iMouse.z < 0.)\n    {\n        //P = iMouse.xy + 100.*(P/R.x - 0.5); \n    }\n    \n    float m = 0.0;\n    float rho = 0.0;\n    vec2 v = vec2(0.0);\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        //load data\n        vec2 di = vec2(i,j);\n        vec4 data0 = A(P + di);\n        vec4 data1 = B(P + di);\n        \n        //unpack data\n        float m0 = data0.y;\n        vec2 x0 = 2.0*decode(data0.x) - fract(P);\n        vec2 v0 = decode(data1.x);\n        mat2 B0 = mat2(decode(data1.y),decode(data1.z)); //velocity gradient\n        //update particle position\n    \n        //find cell contribution\n        vec3 o = overlap(2.0*x0 + di + v0*dt , vec2(0.1));\n            x0 = x0 + di; \n        \n        m += m0*o.z;\n        \n        float w = k1(1.0*x0);\n        \n        v += (v0 + 4.0*B0*x0)*w;\n        rho += m0*w;\n    }\n   // rho = step(0.1, rho)*rho; //isosurface\n    float arg = 0.5*(atan(v.y, v.x)/PI + 1.0);\n    float d = 2.5*length(v);\n    vec3 fluid = hsv2rgb(vec3(arg, 0.5, 0.3*d +0.*rho));\n    \n    C = vec4(mix( vec3(1.000,1.000,1.000),fluid, smoothstep(0.,0.5,sqrt(rho))), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R;\nvec4 Mouse;\nfloat time;\nint frame;\n\n#define A(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define B(p) texelFetch(iChannel1, ivec2(mod(p,R)), 0)\n\n#define CH(c, p) texelFetch(c, ivec2(mod(p,R)), 0)\n\n//loop in range\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.0\n#define max_vel 1.0\n#define rad 1\n\n#define diffusion 0.25\n#define gravity 0.005\n\n#define PI 3.14159265\n\n#define rest_rho 1.0\n#define eos_pressure 0.5\n\n//reduce rotation/shearing of low density particles\n//without this the vacuum and border state very chaotic, but it still works fine\n//in usual MPM that isn't necessary since the particles don't change mass\nfloat affine_str(float m)\n{\n    return 1.0; //full APIC\n    //return smoothstep(0.5*rest_rho,0.55*rest_rho,m);\n}\n\n//pressure equation of state\nfloat pressure(float rho)\n{\n    return 1.2*(rho - 0.5); //gas\n   // return eos_pressure*(pow(rho/rest_rho,4.) - 1.0); //Tait EOS (water)\n}\n\nvoid InitialConditions(inout float m, inout vec2 v, vec2 P)\n{\n    vec2 dx = P - R*vec2(0.3, 0.5);\n\n    float d = smoothstep(R.y*0.3, R.y*0.19, length(dx));  \n    m = 2.0*d;\n\n    v = d*0.3*normalize(vec2(dx.y,-dx.x));\n}\n\n//KERNEL FUNCTIONS\n\nfloat k0(vec2 dx) //linear kernel\n{\n    vec2 k = max(1.0 - abs(dx), 0.);\n    return k.x*k.y;\n}\n\nvec3 K0(vec2 dx) //linear kernel with the center of mass\n{\n    vec2 k = max(1.0 - abs(dx), 0.);\n    return vec3(dx*0.5, k.x*k.y);\n}\n\nfloat k1(vec2 dx) //quadratic kernel\n{\n    vec2 f = max(1.5 - abs(dx), 0.0);\n    vec2 k = min(max(0.75 - dx*dx, 0.5), 0.5*f*f);\n    return k.x*k.y;\n}\n\n//box size enstimator\nvec2 destimator(vec2 dx)\n{\n    return clamp(1.0 - 2.0*abs(dx), 0.0001, 1.0);\n}\n\n//box overlap with center of mass\nvec3 overlap(vec2 dx, vec2 box)\n{\n    vec2 min0 = max(dx - box*0.5, -0.5); \n    vec2 max0 = min(dx + box*0.5, 0.5); \n    vec2 size = max(max0 - min0, 0.); \n    return vec3(0.5*(max0 + min0), size.x*size.y/(box.x*box.y));\n}\n\n//boundary\n#define border_h 3.\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -border_h-sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n\n    return bound;\n}\n\n#define h 2.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\n//DATA PACKING\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X)*1.0; \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x/1.);\n    return uintBitsToFloat(X); \n}\n\n//particle to grid\nvec4 P2G(sampler2D a, sampler2D b, vec2 P)\n{\n    vec2 x = vec2(0.0);\n    vec2 v = vec2(0.0);\n    float m = 0.0;\n    float rho = 0.0;\n    \n    range(i, -rad, rad) range(j, -rad, rad)\n    {\n        //load data\n        vec2 di = vec2(i,j);\n        vec4 data0 = CH(a, P + di);\n        vec4 data1 = CH(b, P + di);\n        \n        //unpack data\n        float m0 = data0.y;\n        float r0 = data0.w;\n        vec2 x0 = decode(data0.x);\n        vec2 v0 = decode(data1.x);\n       // mat2 B0 = mat2(decode(data1.y),decode(data1.z)); //velocity gradient\n        \n        //estimate the shape of the distribution\n        vec2 box = destimator(x0);\n        \n        //update particle position\n        x0 = x0 + di + v0*dt;\n    \n        //find cell contribution\n        vec3 o = overlap(x0, box);\n         \n        //update distribution\n        x += m0*o.xy*o.z;\n        m += m0*o.z;\n        \n        //find grid node contribution\n        float w = k1(x0);\n        \n        //distribute momentum onto grid\n        v += v0*w*m0;\n        rho += m0*w;\n    }\n    \n    //normalize\n    if(rho > 0.0) v /= rho;\n    if(m > 0.0) x /= m;\n    \n    //initial conditions\n    if(frame < 20)\n    {\n        InitialConditions(m, v, P);\n    }\n    \n    v = (length(v)>max_vel)?normalize(v)*max_vel:v;\n    \n    return vec4(encode(x), m, encode(v), rho);\n}\n\n//grid to particle\nvec4 G2P(sampler2D a, sampler2D b, vec2 P)\n{\n    vec2 V = vec2(0.0);\n    mat2 B = mat2(0.0);\n    \n    vec4 data = CH(a, P);\n    float m = data.y;\n    vec2 x = decode(data.x);\n    \n    range(i, -rad, rad) range(j, -rad, rad)\n    {\n        //load data\n        vec2 di = vec2(i,j);\n        vec4 data0 = CH(a, P + di);\n        \n        //unpack data\n        float m0 = data0.y;\n        float rho = data0.w;\n        vec2 dx = x - di;\n        vec2 v0 = decode(data0.z);\n        \n        //find grid node contribution\n        float w = k1(dx);\n        \n        float P = clamp(pressure(rho), -0.5, 0.5);\n        vec2 F = rho*dx*P;\n        \n        //distribute velocities/forces to particles\n        V += (F*dt)*w;\n        B += affine_str(m)*mat2(v0*dx.x,v0*dx.y)*w;\n    }\n    \n    V += 1.0005*decode(data.z);\n    \n    //gravity\n    V += vec2(0.0, -gravity)*dt;\n    \n    //push fluid\n   // V += vec2(0.0, 0.5)*exp(-0.02*pow(distance(P, R*vec2(0.7,0.3)), 2.));\n    \n    if(Mouse.z > 0.)\n    {\n        vec2 dx = (Mouse.xy - P); \n        V += -0.05*exp(-0.05*length(dx))*dx*dt; \n    }\n    \n    //border \n    vec3 N = bN(P + x);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, V);\n    //V *= 1. - 0.1*exp(-N.z);\n    V += (0. + 1.5*max(vdotN, 0.0))*N.xy*step(abs(N.z), border_h)*exp(-N.z);\n    V = (length(V)>max_vel)?normalize(V)*max_vel:V;\n\n    return vec4(encode(V), encode(B[0]), encode(B[1]), 1.0);\n}\n\n", "buffer_a_code": "//Advect mass distributions and distrubute the momentum and density to grid\n\n//Advect + P2G\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse; frame = iFrame;\n    P = floor(P);\n   \n    C = P2G(iChannel0,iChannel1,P);\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//Distribute grid velocities to the mass distributions\n\n//G2P\n\n//technically its more correct to do the force in the P2G step 2\n//but I didn't want to waste a buffer here\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse; frame = iFrame;\n    P = floor(P);\n    C = G2P(iChannel0, iChannel1, P);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//Advect + P2G\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse; frame = iFrame;\n    P = floor(P);\n   \n    C = P2G(iChannel0,iChannel1,P);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//G2P\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse; frame = iFrame;\n    P = floor(P);\n    C = G2P(iChannel0, iChannel1, P);\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftlXW8.jpg", "access": "api", "license": "mit", "functions": [[47, 47, 74, 74, 232]], "test": "untested"}
{"id": "sllSzB", "name": "Fork Fork psych toby80 785", "author": "toby80", "description": "Another play on IQ's tunnel", "tags": ["tunnel"], "likes": 1, "viewed": 239, "published": 3, "date": "1625998815", "time_retrieved": "2024-07-30T19:11:20.116338", "image_code": "// Fork of \"psychedelic tunnel\" by None. https://shadertoy.com/view/-1\n// 2021-07-11 09:06:41\n\n// Fork of \"psychedelic tunnel\" by None. https://shadertoy.com/view/-1\n// 2021-07-11 08:51:50\n\n// Fork of \"psychedelic tunnel\" by StanRee. https://shadertoy.com/view/4lX3W7\n// 2021-07-11 07:56:38\n\n\n// Deform - square tunnel : REDUX\n// Modifications by Stanley Hayes\n// Original Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//Hsv conversion from http://ploobs.com.br/?p=1499\n\nvec3 Hue(float a){\nvec3 K = vec3(3,2,1)/3.;\nreturn clamp(abs(fract(vec3(a)+K)*6. - vec3(3.)) - K.xxx, 0., 1.);\n}\n\n\n#define Time (iTime * .06) \n\nvec3 HSVtoRGB(vec3 HSV)\n{\n    return vec3(((Hue(HSV.x) - 1.0) * HSV.y + 1.0) * HSV.z);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized coordinates (-1 to 1 vertically)\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\n    // angle of each pixel to the center of the screen\n    \n    \n    // modified distance metric. Usually distance = (xÂ² + yÂ²)^(1/2). By replacing all the \"2\" numbers\n    // by 32 in that formula we can create distance metrics other than the euclidean. The higher the\n    // exponent, then more square the metric becomes. More information here:\n    \n    // http://en.wikipedia.org/wiki/Minkowski_distance\n    \n    float exp = 1.0;\n    float crayStationsCoef = 1.01; \n    p.x +=  sin(pow(Time,.5))*crayStationsCoef*2.0;\n   //p.y +=  cos(Time)*crayStationsCoef*10.0;\n    float a = atan(p.y,p.x) + Time * sin(Time)*.002 + iMouse.x * .0001;\n    float r = pow( pow(p.x*p.x,exp) + pow(p.y*p.y,exp), 1.0/(exp * 2.0) ) + sin(Time)*crayStationsCoef;\n    a += pow(r,.50); \n    \n       \n    // index texture by angle and radious, and animate along radius    \n    vec2 uv = vec2( 0.5/r + 0.5*Time + iMouse.y,                    a/3.1416 );\n\n    r -= sin(Time)*.05;\n    // fecth color and darken in the center\n    vec3 col =  texture( iChannel0, uv ).xyz * r;\n    col = HSVtoRGB(vec3(col.r, 1.0, 1.0)); \n\t\n    col.r *= (sin(uv.x*5.0)*.7 + 1.0) * .9;\n    \n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sllSzB.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[547, 547, 565, 565, 659], [691, 691, 716, 716, 779], [782, 782, 839, 890, 2140]], "test": "untested"}
{"id": "7tsSRB", "name": "大龙猫 - ᠰᠢᠨ᠎ᠡ ᠤᠯᠠᠭᠠᠨᠪᠠᠭᠠᠲᠤᠷ", "author": "totetmatt", "description": " [SOUND IN BUFFER A TO PLAY IF NOT STARTED AUTOMATICALLY]\n\nClose enough from Bonzo", "tags": ["2d"], "likes": 15, "viewed": 497, "published": 3, "date": "1625997599", "time_retrieved": "2024-07-30T19:11:20.865336", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n /*\n \n  [SOUND IN BUFFER A TO PLAY IF NOT STARTED AUTOMATICALLY]\n\n */\n    vec2 uv = fragCoord/iResolution.xy;   \n    fragColor = texture(iChannel0 ,uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "mat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat box(vec2 uv, vec2 b){\n    vec2 q = abs(uv)-b;\n    return length(max(vec2(0.),q))+min(0.,max(q.x,q.y));\n}\nfloat hash21(vec2 p) {\n    p = fract(p * vec2(233.34, 851.74));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\n  #define spuv(pp) (pp * vec2(iResolution.y / iResolution.x, 1))+.5\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n\n  vec2 ouv = uv;\n  vec2 puv = uv;\n\n  uv*=4.;\n\n  uv*=rot(-.785*.5);\n   uv.x+=iTime*.2;\n    \n \n  vec2 id = floor(uv);\n     uv.y +=sign(sin(id.x*120.))*iTime*.1;\n  id = floor(uv);\n    float h = hash21(id);\n    uv*=rot(.785*20.*h);\n  uv= fract(uv)-.5;   \n  for(float i=floor(h*100.)/3.;i>0.;i--){\n      uv= fract(uv)-.25;\n      uv*=rot(id.x*.1+id.y*.2+-.785*.5*i+iTime*.133);\n       uv = uv.x <uv.y ? uv.yx:uv.xy;\n    \n    }\n  float ffx = texture(iChannel2,fract(vec2(.05+h+abs(uv.x*.5)))).r*.5;\n  float ffy = texture(iChannel2,fract(vec2(.05+h+abs(uv.y*.5)))).r*.5;\n    ffx = sqrt(ffx)*.3;\n    ffy=sqrt(ffy)*.3;\n  float d = box(uv,vec2(.5-ffy,.5-ffx));\n  d = smoothstep(fwidth(d),.00,abs(d)-.01-sqrt(h)*(.02+texture(iChannel2,vec2(fract(id.x*.1+id.y*.1))).r*.05));\n  vec3 col = vec3(d);\n    \n    float tt= texture(iChannel1,fract(uv)).r*.045;\n    \n    if(h<.5) puv = uv+puv;\n      \n    vec2 rpuv = spuv(puv*(.995+tt));    \n    vec4 rpcol = texture(iChannel0,rpuv);\n    \n    vec2 gpuv = spuv(puv*(1.003-tt));    \n    vec4 gpcol = texture(iChannel0,gpuv);\n    \n    vec2 bpuv = spuv(puv*(1.004-tt));    \n    vec4 bpcol = texture(iChannel0,bpuv);\n    \n    col =mix(col,vec3(rpcol.r,bpcol.b,gpcol.g),max(.3,log(h+1.7)-texture(iChannel2,vec2(fract(.7+h))).r));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27777, "src": "https://soundcloud.com/mixmagadria/premiere-ken-ishii-reality-tunnel-dj-jock-remix-6", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tsSRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 127, 212]], "test": "untested"}
{"id": "7lsXRS", "name": "Fork Solidtux R toby80 739", "author": "toby80", "description": "Rainbow Tunnel", "tags": ["tunnel"], "likes": 0, "viewed": 287, "published": 3, "date": "1625994762", "time_retrieved": "2024-07-30T19:11:21.613336", "image_code": "\n\n#define TIME mod(iTime, float(20.425))\n\nprecision highp float;\n\nconst float MIN_DEPTH = float(1);\nconst float MAX_DEPTH = float(40);\nconst int MAX_ITER = 600;\nconst float EPS = float(0.01);\nconst float SHADOW = float(0);\nconst float SHADOW_EPS = float(0.01);\nconst float SHADOW_DEPTH = float(2);\nconst float SHADOW_SMOOTH = float(15);\nconst float PI = 3.14159265359;\nconst float KEYFRAME_0 = float(0);\nconst float KEYFRAME_1 = float(5);\nconst float KEYFRAME_2 = float(6);\nconst float KEYFRAME_3 = float(15);\nconst float KEYFRAME_4 = float(20);\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\nstruct RayResult {\n    float depth;\n    int object;\n    vec3 norm;\n};\nstruct SdfResult {\n    float distance;\n    vec3 pos;\n    vec2 uv;\n    int object;\n};\nstruct Camera {\n    vec3 position;\n    vec3 target;\n    vec3 up;\n    float zoom;\n};\nfloat rand(float n){\n    return fract(sin(n) * 43758.5453123);\n}\nvec2 norm_coord(in vec2 coord, in vec2 res) {\n    vec2 uv = coord.xy/res.xy;\n    uv = 2.*uv - 1.;\n    if (res.x > res.y) {\n        uv.x *= res.x/res.y;\n    } else {\n        uv.y *= res.y/res.x;\n    }\n    return uv;\n}\nvec3 ray_direction(in Camera cam, in vec2 coord, in vec2 res) {\n    vec2 uv = norm_coord(coord, res);\n    vec3 dir = normalize(cam.target - cam.position);\n    vec3 right = normalize(cross(dir, cam.up));\n    vec3 u = normalize(cross(right, dir));\n    vec3 target = cam.position + normalize(dir)/cam.zoom + uv.x*right + uv.y*u;\n    return normalize(target - cam.position);\n}\nRay get_ray(in Camera cam, in vec2 coord, in vec2 res) {\n    return Ray(cam.position, ray_direction(cam, coord, res));\n}\nvec2 sphere_map(in vec3 pos) {\n    // TODO\n    return vec2(0.);\n}\nfloat box(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\nSdfResult sdf_union(in SdfResult a, in SdfResult b) {\n    if (a.distance < b.distance) {\n        return a;\n    } else {\n        return b;\n    }\n}\nmat3 rotx(in float a) {\n    return mat3(\n            1., 0., 0.,\n            0., cos(a), -sin(a),\n            0., sin(a), cos(a)\n            );\n}\nmat3 roty(in float a) {\n    return mat3(\n            cos(a), 0., -sin(a),\n            0., 1., 0.,\n            sin(a), 0., cos(a)\n            );\n}\nmat3 rotz(in float a) {\n    return mat3(\n            cos(a), -sin(a), 0.,\n            sin(a), cos(a), 0.,\n            0., 0., 1.\n            );\n}\nSdfResult sdf(in vec3 pos) {\n    SdfResult res = SdfResult(MAX_DEPTH, vec3(0.), vec2(0.), -1);\n    vec3 p = pos;\n    \n    p.xz = vec2(atan(p.x, p.z), length(p.xz) - 2.7 + 0.5*(exp(-TIME*0.1) + exp((TIME - 20.425)*0.1))*sin(0.5*p.y));\n    p.y -= 5.*(TIME - 11.);\n    p.xy = mod(p.xy, vec2(0.3, 3.));\n    p.y += p.x;\n    res = SdfResult(box(p, vec3(float(0.35), float(0.2), float(2))), p, vec2(0., 0.), 0);\n    return res;\n}\nvec3 norm(in vec3 p) {\n    return normalize(vec3(\n        sdf(vec3(p.x + EPS, p.y, p.z)).distance - sdf(vec3(p.x - EPS, p.y, p.z)).distance,\n        sdf(vec3(p.x, p.y + EPS, p.z)).distance - sdf(vec3(p.x, p.y - EPS, p.z)).distance,\n        sdf(vec3(p.x, p.y, p.z + EPS)).distance - sdf(vec3(p.x, p.y, p.z - EPS)).distance\n    ));\n}\nRayResult raymarcher(in Ray ray) {\n    float depth = MIN_DEPTH;\n    for (int i=0; i<MAX_ITER; i++) {\n        vec3 pos = ray.origin + depth*ray.direction;\n        SdfResult res = sdf(pos);\n        if (res.distance < EPS) {\n            return RayResult(depth, res.object, norm(pos));\n        }\n        depth += res.distance;\n        if (depth > MAX_DEPTH) {\n            return RayResult(MAX_DEPTH, -1, vec3(0.));\n        }\n    }\n    return RayResult(MAX_DEPTH, -1, vec3(0.));\n}\nfloat lightmarch(in Ray ray, in float maxd, in float k) {\n    float depth = 0.;\n    float r = 1.;\n    for (int i=0; i<MAX_ITER; i++) {\n        vec3 pos = ray.origin + depth*ray.direction;\n        SdfResult res = sdf(pos);\n        if (res.distance < SHADOW_EPS) {\n            return 0.;\n        }\n        r = min(r, k*res.distance/depth);\n        depth += res.distance;\n        if (depth >= (maxd - SHADOW_DEPTH)) {\n            return r;\n        }\n    }\n    return r;\n}\nvec4 color(in vec2 coord, in vec2 resolution) {\n    Camera cam = Camera(mix(mix(mix(mix(vec3(float(0), float(0), float(40)), vec3(float(0), float(5), float(0)), smoothstep(KEYFRAME_0, KEYFRAME_1, TIME)), vec3(float(0), float(5), float(0)), smoothstep(KEYFRAME_1, KEYFRAME_2, TIME)), vec3(float(0), float(5), float(0)), smoothstep(KEYFRAME_2, KEYFRAME_3, TIME)), vec3(float(0), float(0), float(40)), smoothstep(KEYFRAME_3, KEYFRAME_4, TIME)), vec3(float(0.1), float(0), float(0)), mix(mix(mix(mix(vec3(float(0), float(1), float(0)), vec3(float(1), float(5), float(0)), smoothstep(KEYFRAME_0, KEYFRAME_1, TIME)), vec3(cos(0.75*sin(TIME - 11.)), 0., sin(0.75*sin(TIME - 11.))), smoothstep(KEYFRAME_1, KEYFRAME_2, TIME)), vec3(cos(0.75*sin(TIME - 11.)), 0., sin(0.75*sin(TIME - 11.))), smoothstep(KEYFRAME_2, KEYFRAME_3, TIME)), vec3(float(0), float(1), float(0)), smoothstep(KEYFRAME_3, KEYFRAME_4, TIME)), float(0.4));\n    Ray ray = get_ray(cam, coord, resolution);\n    RayResult res = raymarcher(ray);\n    vec3 pos = ray.origin + res.depth*ray.direction;\n    vec3 col;\n    if (res.object == 0) {\n        vec3 amb = vec3((sin(pos) + 1.)/2.);\n        vec3 spec = vec3(0.);\n        vec3 diff = vec3(0.);\n        vec3 h;\n        vec3 l;\n        vec3 lpos;\n        vec3 ldir;\n        float bright = 1.;\n        lpos = vec3(float(0), float(5), float(0));\n        l = normalize(lpos - pos);\n        h = normalize(-ray.direction + l);\n        spec += vec3(float(1), float(1), float(1))*pow(dot(res.norm, h), float(1));\n        diff += amb*dot(l, res.norm);\n        if (SHADOW > 0.) {\n            Ray light_ray = Ray(lpos, -l);\n            float s = SHADOW*lightmarch(light_ray, length(lpos - pos), SHADOW_SMOOTH) + 1. - SHADOW;\n            spec *= s;\n            diff *= s;\n        }\n        col = float(0)*amb + float(1)*diff + float(0)*spec;\n    }\n    if (res.object == -1) {\n        col = vec3(float(0.1), float(0.1), float(0.2));\n    }vec2 nc = abs(2.*coord/resolution - 1.); col = mix(vec3(0.), col, smoothstep(1.1, 1.05, max(nc.x, nc.y) + 0.1*length(nc)));\n    col = clamp(col, 0., 1.);\n    return vec4(col, 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = color(fragCoord, iResolution.xy);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lsXRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[838, 838, 858, 858, 902], [903, 903, 948, 948, 1119], [1120, 1120, 1183, 1183, 1492], [1493, 1493, 1549, 1549, 1613], [1614, 1614, 1644, 1656, 1679], [1680, 1680, 1707, 1707, 1794], [1795, 1795, 1848, 1848, 1940], [1941, 1941, 1964, 1964, 2086], [2087, 2087, 2110, 2110, 2232], [2233, 2233, 2256, 2256, 2378], [2379, 2379, 2407, 2407, 2801], [2802, 2802, 2824, 2824, 3133], [3134, 3134, 3168, 3168, 3609], [3610, 3610, 3667, 3667, 4078], [4079, 4079, 4126, 4126, 6190], [6192, 6192, 6247, 6247, 6299]], "test": "untested"}
{"id": "7tlXRS", "name": "psychox", "author": "toby80", "description": "Messing with nimitz' spiral from:  https://www.shadertoy.com/view/MdlXRS .  Just a doodle.", "tags": ["spiral", "psychedelic"], "likes": 0, "viewed": 261, "published": 3, "date": "1625994392", "time_retrieved": "2024-07-30T19:11:22.375299", "image_code": "// Fork of \"Fork xxHypno-Wh toby80 281\" by None. https://shadertoy.com/view/-1\n// 2021-07-11 09:04:31\n\n// Fork of \"Fork xxHypno-Wh toby80 281\" by None. https://shadertoy.com/view/-1\n// 2021-07-11 09:04:19\n\n// Fork of \"Hypno-Wheel\" by CaliCoastReplay. https://shadertoy.com/view/llK3WK\n// 2021-07-11 09:03:15\n\n//Just trying to pull apart nimitz' spiral from https://www.shadertoy.com/view/MdlXRS\n//to see how it works!\n\n#define TAU 6.28318530716\n\nfloat spiral(vec2 p,float scl, float phase) \n{\n\tfloat r = length(p);\n\tr = log(r);\n\tfloat a = atan(p.y, p.x);\n\treturn abs(mod(scl*(r-1.0/scl*a) - phase*2.0,TAU)-1.)/2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    float modifier1 = 1.0 / spiral(uv, 1.0, iTime + 2.3);\n    float modifier2 = 1.0 / spiral(uv, 2.0, iTime);\n    float modifier3 = 1.0 / spiral(uv, 3.0, iTime*2.0 - 1.0);\n    float modifier4 = 1.0 / spiral(uv, 25.0 , iTime*5.0 - 2.0);\n    vec3 color = vec3 (0.19, 0.43, 0.82);\n\tfragColor = vec4(color,1.0)\n        * (modifier1 +\n           modifier2 +\n           modifier3 + \n           modifier4)/4.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlXRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[446, 446, 492, 492, 616], [618, 618, 675, 675, 1138]], "test": "untested"}
{"id": "7tsSRS", "name": "xxHypno-Wheel", "author": "toby80", "description": "Messing with nimitz' spiral from:  https://www.shadertoy.com/view/MdlXRS .  Just a doodle.", "tags": ["spiral", "psychedelic"], "likes": 2, "viewed": 266, "published": 3, "date": "1625994269", "time_retrieved": "2024-07-30T19:11:23.132778", "image_code": "// Fork of \"Hypno-Wheel\" by CaliCoastReplay. https://shadertoy.com/view/llK3WK\n// 2021-07-11 09:03:15\n\n//Just trying to pull apart nimitz' spiral from https://www.shadertoy.com/view/MdlXRS\n//to see how it works!\n\n#define TAU 6.28318530716\n\nfloat spiral(vec2 p,float scl, float phase) \n{\n\tfloat r = length(p);\n\tr = log(r);\n\tfloat a = atan(p.y, p.x);\n\treturn abs(mod(scl*(r-1.0/scl*a) - phase*2.0,TAU)-1.)/2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    float modifier1 = 1.0 / spiral(uv, 1.0, iTime + 2.3);\n    float modifier2 = 1.0 / spiral(uv, 2.0, iTime);\n    float modifier3 = 1.0 / spiral(uv, 3.0, iTime*2.0 - 1.0);\n    float modifier4 = 1.0 / spiral(uv, 25.0 , iTime*5.0 - 2.0);\n    vec3 color = vec3 (0.19, 0.43, 0.82);\n\tfragColor = vec4(color,1.0)\n        * (modifier1 +\n           modifier2 +\n           modifier3 + \n           modifier4)/4.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tsSRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[240, 240, 286, 286, 410], [412, 412, 469, 469, 932]], "test": "untested"}
{"id": "7lXXzB", "name": "Scanning Electron Microscope", "author": "Zi7ar21", "description": "I tried making something visually similar to a Scanning Electron Microscope. I won't pretend like it's physically based or anything, but it looks pretty good!", "tags": ["fractal", "ray", "mandelbulb", "tracing", "traced", "tracer", "rt", "mandel", "trace", "path", "microscope", "pt", "electron", "bulb", "sem", "em", "microscopy"], "likes": 21, "viewed": 660, "published": 3, "date": "1625966934", "time_retrieved": "2024-07-30T19:11:24.014421", "image_code": "// ####### Scanning Electron Microscope #######\n// Made by Jacob Bingham (Zi7ar21) on July 10th, 2021\n\n// Last Updated on July 10th, 2021 at 15:00 Mountain Standard Time\n\n// If you found this anywhere except Shadertoy, you can find the original and possibly updated version at:\n// https://www.shadertoy.com/view/7lXXzB\n\n// \"License\":\n// You can use this code in any way you want, as long as you keep credits to things that aren't mine\n// e.g. Triple32: https://nullprogram.com/blog/2018/07/31/\n// We are programmers, not lawyers! :)\n\n/*\nI'm not sure how Scanning Electron Microscopes really produce images, but here is my best attempt\nat visually approximating an image from one.\n*/\n\n// Check out my friends!\n// michael0884\n// https://www.shadertoy.com/user/michael0884\n// loicvdb\n// https://www.shadertoy.com/user/loicvdb\n// Dumb_Psycho\n// https://www.shadertoy.com/user/Dumb_Psycho\n// peabrainiac\n// https://www.shadertoy.com/user/peabrainiac\n\n// Image Preview\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Get the Final Image\n    vec3 color = texel0.rgb;\n\n    // HDR Tonemapping\n    color = tonemap(color);\n\n    // Output the Image Preview\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ##### Parameters #####\n\n// Tonemap Exposure (Image Preview Only!)\n#define exposure 1.0\n\n// Camera Field of View\n#define camfov 1.0\n\n// Ray-Marching Hit Distance\n#define hitDist 1E-4\n\n// Maximum Distance\n#define maxDist 0.6\n\n// Maximum Shadow Ray Distance\n#define shadowDist 0.2\n\n// Maximum Ray-Marching Steps\n#define maxSteps 1024U\n\n// ##### Preprocessor #####\n\n// Compiler Optimization (I think I am using these properly? I will comment them by default just in case...)\n//#pragma optimize(on)\n//#pragma debug(off)\n\n// ##### Constants, Macros, and Maths #####\n\n// Minimum Digits Double Pi\n// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\n#define pi 3.141592653589793\n\n// Trig Function for Pi\n// (crappy compilers might make the GPU solve this every time, not ideal)\n//#define pi acos(-1.0)\n\n// Ideal 32-Bit Floating-Point Pi\n// (idk how compatible uintBitsToFloat() is, Unsigned Integers alone break on some systems I've tried)\n//#define pi uintBitsToFloat(0x40490FDBU)\n\n// Traditional Uniform Identifiers\n#define resolution iResolution\n#define frame iFrame\n\n// Sample Buffer Texel\n#define texel0 texelFetch(iChannel0, ivec2(gl_FragCoord.xy), 0)\n#define texel1 texelFetch(iChannel1, ivec2(gl_FragCoord.xy), 0)\n#define texel2 texelFetch(iChannel2, ivec2(gl_FragCoord.xy), 0)\n#define texel3 texelFetch(iChannel3, ivec2(gl_FragCoord.xy), 0)\n\n// Dot Product\nfloat dotp(vec2 vector){return dot(vector, vector);}\nfloat dotp(vec3 vector){return dot(vector, vector);}\nfloat dotp(vec4 vector){return dot(vector, vector);}\n\n// ##### Color Management #####\n\n// HDR Tonemapping Function\nvec3 tonemap(vec3 color)\n{\n    // Clamp Negatives\n    color = max(color, 0.0);\n\n    // Exposure Tonemap\n    color = 1.0-exp(-color*exposure);\n\n    // Return the Tonemapped Color\n    return clamp(color, 0.0, 1.0);\n}\n\n// ##### Random Number Generator #####\n\n// Random Number Generator Seed\nuint ns;\n#define INIT_RNG ns = uint(frame)*uint(resolution.x*resolution.y)+uint(gl_FragCoord.x+gl_FragCoord.y*resolution.x)\n\n/*\n// PCG Random: https://www.pcg-random.org/\nuvec4 pcg4(uvec4 x)\n{\n    x *= 0x0019660DU+0x3C6EF35FU;\n    x += uvec4(x.y*x.w, x.z*x.x, x.x*x.y, x.y*x.z);\n    x ^= x >> 16U;\n    x += uvec4(x.y*x.w, x.z*x.x, x.x*x.y, x.y*x.z);\n    return x;\n}\n*/\n\n/*\n// PCG Random: https://www.pcg-random.org/\nuint pcgRandom(uint x)\n{\n    uint state = x*0x2C9277B5U+0xAC564B05U;\n    uint word = ((state >> ((state >> 28U) + 4U)) ^ state) * 0x108EF2D9U;\n    return (word >> 22U) ^ word;\n}\n*/\n\n// Triple32: https://nullprogram.com/blog/2018/07/31/\nuint triple32(uint x)\n{\n    x ^= x >> 17U;\n    x *= 0xED5AD4BBU;\n    x ^= x >> 11U;\n    x *= 0xAC4C1B51U;\n    x ^= x >> 15U;\n    x *= 0x31848BABU;\n    x ^= x >> 14U;\n    return x;\n}\n\n//\nfloat rand()\n{\n    //ns = pcgRandom(ns);\n    ns = triple32(ns);\n    return float(ns)/float(0xFFFFFFFFU);\n}\n\n// Random Vectors\nvec2 rand2(){return vec2(rand (), rand());}\nvec3 rand3(){return vec3(rand2(), rand());}\nvec4 rand4(){return vec4(rand3(), rand());}\n//vec5 rand5(){return vec5(rand4(), rand());} // GLSL Sus Imposter Confirmed!? The truth is out there...\n\n// See michael0884's usage of PCG Random\n// https://www.shadertoy.com/view/wltcRS\n// https://www.shadertoy.com/view/WttyWX\n\n// Normalized Random Vectors\n// A point is equally probable to land at every point inside the volume of a sphere at the mean with a radius of sigma\nvec2 nrand2(float sigma, vec2 mean)\n{\n    vec2 z = rand2();\n    return mean+sigma*sqrt(-2.0*log(z.x   ))*vec2(cos(2.0*pi*z.y), sin(2.0*pi*z.y));\n}\n\nvec3 nrand3(float sigma, vec3 mean)\n{\n    vec4 z = rand4();\n    return mean+sigma*sqrt(-2.0*log(z.xxy ))*vec3(cos(2.0*pi*z.z), sin(2.0*pi*z.z), cos(2.0*pi*z.w));\n}\n\nvec4 nrand4(float sigma, vec4 mean)\n{\n    vec4 z = rand4();\n    return mean+sigma*sqrt(-2.0*log(z.xxyy))*vec4(cos(2.0*pi*z.z), sin(2.0*pi*z.z), cos(2.0*pi*z.w), sin(2.0*pi*z.w));\n}\n\n// Uniform Random Vectors\n// A point is equally probable to land at every point on the surface of a sphere with a radius of 1.0\nvec3 urand3()\n{\n    vec2 z = rand2();\n    vec2 r = vec2(2.0*pi*z.x, acos(2.0*z.y-1.0));\n    vec2 s = sin(r), c = cos(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}", "buffer_a_code": "// ##### Rendering #####\n\n// Distance Estimator\nfloat DE(vec3 pos)\n{\n    // Transform the SDF (and dither the position to remove weird artifacts)\n    pos = (vec3(-0.2, 0.2, 1.2)+nrand3(hitDist, pos)).xzy;\n\n    // Soft Edges\n    pos = nrand3(0.0003, pos);\n\n    // Set-Up Variables\n    vec3 z = pos;\n    float dr = 1.0;\n    float r = 0.0;\n\n    // Iterate Mandelbulb\n    for(uint i = 0U; i < 32U; i++)\n    {\n        r = length(z);\n\n        // Bailout\n        if(r > 4.0)\n        {\n            break;\n        }\n\n        // Iterate the Mandelbulb\n        float theta = acos(z.z/r)*8.0;\n        float phi = atan(z.y, z.x)*8.0;\n        dr = r*r*r*r*r*r*r*8.0*dr+1.0;\n        z = r*r*r*r*r*r*r*r*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n        z += pos;\n    }\n\n    // Return the Distance Estimate\n    return 0.5*log(r)*r/dr;\n}\n\n// Tetrahedron Numerical SDF Normals\nvec3 sampleNormal(vec3 pos)\n{\n    const vec2 k = vec2(-1.0, 1.0);\n    return normalize(\n    k.xxx*DE(pos+k.xxx*hitDist)+\n    k.xyy*DE(pos+k.xyy*hitDist)+\n    k.yxy*DE(pos+k.yxy*hitDist)+\n    k.yyx*DE(pos+k.yyx*hitDist));\n}\n\n// \"Light\" Transport (or would it be Electron Transport?)\nvec3 radiance(vec3 ro, vec3 rd)\n{\n    // Set-Up Variables\n    float t = 0.0;\n\n    // Ray-Marching\n    for(uint i = 0U; i < maxSteps; i++)\n    {\n        // Check if the Ray reached the background\n        if(t > maxDist)\n        {\n            return vec3(0.0);\n        }\n\n        // Compute the Distance Estimate\n        float td = DE(ro+rd*t);\n\n        // Check if the Ray hit the scene\n        if(td < hitDist)\n        {\n            // Set-Up Variables\n            //vec3 normal = sampleNormal(ro+rd*t);\n            ro = ro+rd*t;\n            //rd = urand3();\n            //rd = reflect(rd, normalize(nrand3(0.2, normal)));\n            // normalize(vec3(1.0)) == vec3(1.0/sqrt(3.0)) == vec3(0.57735026919)\n            const vec3 lightDirection = vec3(0.57735026919, 0.57735026919, 0.57735026919);\n            rd = normalize(nrand3(0.2, lightDirection)+urand3());\n            float t0 = t;\n            t = 0.0;\n\n            // Shadow Ray\n            for(uint i = 0U; i < maxSteps; i++)\n            {\n                // Check if the Shadow Ray reached the background\n                if(t > shadowDist)\n                {\n                    return vec3(4.0)*max(1.0-(t0/maxDist), 0.0);\n                }\n\n                // Compute the Distance Estimate\n                float td = DE(ro+rd*t);\n\n                // Check if the Shadow Ray hit the scene\n                if(td < hitDist)\n                {\n                    //return vec3(0.5)*max(1.0-(t/maxDist), 0.0);\n                    return vec3(0.0);\n                }\n\n                // March the Ray\n                t += td;\n            }\n\n            // Sample Expired\n            return vec3(-1.0);\n        }\n\n        // March the Ray\n        t += td;\n    }\n\n    // Sample Expired\n    return vec3(-1.0);\n}\n\n// Render and Output the Sample\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Progressive Rendering\n    fragColor = frame != 0 ? texel0 : vec4(0.0);\n\n    // Initialize Random Number Generator\n    INIT_RNG;\n\n    // Pixel Filtering\n    //fragCoord.xy += rand2();\n    fragCoord.xy = nrand2(0.5, fragCoord.xy);\n\n    // Screen UV Coordinates\n    vec2 uv = 2.0*(fragCoord.xy-0.5*resolution.xy)/max(resolution.x, resolution.y);\n\n    // Path-Tracing Bloom\n    float t = rand();\n    if(t < 0.25)\n    {\n        // Large Bloom\n        float r2 = rand();\n        uv += nrand2(0.1*r2*r2*r2, vec2(0.0));\n    }\n    else if(t < 0.5)\n    {\n        // Microbloom\n        uv += nrand2(0.005, vec2(0.0));\n    }\n\n    // Set-Up Camera Variables\n    const vec3 ro = vec3(0.0, 0.0, 0.0);\n    const mat3 rotmat = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n    vec3 rd = normalize(vec3(camfov*uv, -1.0)*rotmat);\n\n    // Render the Sample\n    vec3 color = radiance(ro, rd);\n\n    // Output the Rendered Sample\n    fragColor += any(lessThan(color, vec3(0.0))) || any(isinf(color)) || any(isnan(color)) ? vec4(0.0) : vec4(color, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ##### Image Export #####\n// On Shadertoy, click the image icon in the bottom right of the editor to save a Floating-Point OpenEXR Image\n// Be aware it won't be tonemapped, because good image editors such as GIMP apply gamma correction during editing\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Get the Progressive Rendering Buffer\n    vec4 texel = texel0;\n\n    // Output the Final Image\n    fragColor = vec4(texel.a != 0.0 ? texel.rgb/texel.a : texel.rgb, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lXXzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[946, 963, 1018, 1045, 1195]], "test": "untested"}
{"id": "NtsXRS", "name": "MandelbrotBlue", "author": "ZenithGD", "description": "Trying to make a mandelbrot set in GLSL. X movement with mouse will pan over the fractal in the X axis, and Y movement with mouse will zoom in/out.", "tags": ["fractal"], "likes": 2, "viewed": 237, "published": 3, "date": "1625960961", "time_retrieved": "2024-07-30T19:11:24.772394", "image_code": "vec2 sqrcomp(vec2 v)\n{\n    return vec2(v.x * v.x - v.y * v.y, 2.* v.x * v.y); \n}\n\nvec3 mandelbrot(vec2 v, int max_iter)\n{\n    vec2 z = vec2(0.);\n    vec2 c = v / (0.1 + iMouse.y / iResolution.y * 15.) ;\n    c += vec2(-1.5+(iMouse.x / iResolution.x),.25);\n    int i;\n    float min_dist = 10000.;\n    for ( i = 0; i < max_iter; i++ )\n    {\n        if ( length(z) > 2. ) break;\n        z = sqrcomp(z) + c;\n        \n        float nm = length(z);\n        if ( nm < min_dist ) min_dist = nm;\n    }\n    \n    \n    return mix(vec3(2./255., 0., 36./255.), vec3(0., 212./255., 1.), 1. - min_dist * 2.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1) from center\n    vec2 uv = (fragCoord.xy - .5*iResolution.xy) / iResolution.y;\n    int max_iter = 50;\n    \n    // Output to screen\n    fragColor = vec4(mandelbrot(uv, max_iter),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsXRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 80], [82, 82, 121, 121, 593], [595, 595, 652, 714, 886]], "test": "untested"}
{"id": "7tfSzB", "name": "Mandelbox variant no 1E6", "author": "mrange", "description": "License CC0: Mandelbox variant no 1E6\nAnother variant of Mandelbox by Evilryu: https://www.shadertoy.com/view/XdlSD4\n", "tags": ["3d"], "likes": 46, "viewed": 1037, "published": 3, "date": "1625947532", "time_retrieved": "2024-07-30T19:11:25.586218", "image_code": "// License CC0: Mandelbox variant no 1E6\n//  Another variant of Mandelbox by Evilryu: https://www.shadertoy.com/view/XdlSD4\n\n#define TOLERANCE       0.0001\n#define MAX_RAY_LENGTH  8.0\n#define MAX_RAY_MARCHES 100\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\nconst float fixed_radius2 = 1.9;\nconst float min_radius2   = 0.5;\nconst vec3  folding_limit = vec3(1.0);\nconst float scale         = -2.8;\nconst int   max_iter      = 120;\nconst vec3  bone          = vec3(0.89, 0.855, 0.788);\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  \n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nvec3 pmin(vec3 a, vec3 b, vec3 k) {\n  vec3 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nvoid sphere_fold(inout vec3 z, inout float dz) {\n    float r2 = dot(z, z);\n    if(r2 < min_radius2) {\n        float temp = (fixed_radius2 / min_radius2);\n        z *= temp;\n        dz *= temp;\n    } else if(r2 < fixed_radius2) {\n        float temp = (fixed_radius2 / r2);\n        z *= temp;\n        dz *= temp;\n    }\n}\n\nvoid box_fold(float k, inout vec3 z, inout float dz) {\n  vec3 zz = sign(z)*pmin(abs(z), folding_limit, vec3(k));\n  z = zz * 2.0 - z;\n}\n\nfloat sphere(vec3 p, float t) {\n  return length(p)-t;\n}\n\nfloat boxf( vec3 p, vec3 b, float e)\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat mb(vec3 z) {\n    vec3 offset = z;\n    float dr = 1.0;\n    float fd = 0.0;\n    const float k = 0.05;\n    for(int n = 0; n < 5; ++n) {\n        box_fold(k/dr, z, dr);\n        sphere_fold(z, dr);\n        z = scale * z + offset;\n        dr = dr * abs(scale) + 1.0;        \n        float r1 = sphere(z, 5.0);\n        float r2 = boxf(z, vec3(5.0), 0.5);\n        float r = n < 4 ? r2 : r1;\n        float dd = r / abs(dr);\n        if (n < 3 || dd < fd) {\n          fd = dd;\n        }\n    }\n    return fd;\n}\n\nfloat df(vec3 p) { \n    const float z = 0.3;\n    p.y -= 1.0;\n    float d1 = mb(p/z)*z;\n    return d1; \n} \n\nfloat rayMarch(in vec3 ro, in vec3 rd, out int iter) {\n  float t = 0.0;\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float distance = df(ro + rd*t);\n    if (distance < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += distance;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal(in vec3 pos) {\n  vec3  eps = vec3(.0005,0.0,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat softShadow(in vec3 pos, in vec3 ld, in float ll, float mint, float k) {\n  const float minShadow = 0.25;\n  float res = 1.0;\n  float t = mint;\n  for (int i=0; i<24; i++) {\n    float distance = df(pos + ld*t);\n    res = min(res, k*distance/t);\n    if (ll <= t) break;\n    if(res <= minShadow) break;\n    t += max(mint*0.2, distance);\n  }\n  return clamp(res,minShadow,1.0);\n}\n\nvec3 postProcess(in vec3 col, in vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n  vec3 lightPos = 2.0*vec3(1.5, 3.0, 1.0);\n\n  vec3 skyCol = vec3(0.0);\n\n  int iter = 0;\n  float t = rayMarch(ro, rd, iter);\n\n  float ifade = 1.0-tanh_approx(3.0*float(iter)/float(MAX_RAY_MARCHES));\n\n  vec3 pos = ro + t*rd;    \n  vec3 nor = vec3(0.0, 1.0, 0.0);\n  \n  vec3 color = vec3(0.0);\n  \n  float h = fract(TIME/30.0);\n  \n  if (t < MAX_RAY_LENGTH && pos.y > 0.0) {\n    // Ray intersected object\n    nor       = normal(pos);\n    vec3 hsv  = (vec3(fract(h - 0.6 + 0.4+1.75*t), 1.0-ifade, 1.0));\n    color     = hsv2rgb(hsv);\n  } else if (pos.y > 0.0) {\n    // Ray intersected sky\n    return skyCol*ifade;\n  } else {\n    // Ray intersected plane\n    t   = -ro.y/rd.y;\n    pos = ro + t*rd;\n    nor = vec3(0.0, 1.0, 0.0);\n    vec2 pp = pos.xz*1.5;\n    float m = 0.5+0.25*(sin(3.0*pp.x+TIME*2.1)+sin(3.3*pp.y+TIME*2.0));\n    m *= m;\n    m *= m;\n    pp = fract(pp+0.5)-0.5;\n    float dp = pmin(abs(pp.x), abs(pp.y), 0.025);\n    vec3 hsv = vec3(0.4+mix(0.15,0.0, m), tanh_approx(mix(100.0, 10.0, m)*dp), 1.0);\n    color = 5.5*hsv2rgb(hsv)*exp(-mix(30.0, 10.0, m)*dp);\n  }\n\n  vec3 lv   = lightPos - pos;\n  float ll2 = dot(lv, lv);\n  float ll  = sqrt(ll2);\n  vec3 ld   = lv / ll;\n  float sha = softShadow(pos, ld, ll, 0.01, 64.0);\n\n  float dm  = min(1.0, 40.0/ll2);\n  float dif = max(dot(nor,ld),0.0)*dm;\n  float spe = pow(max(dot(reflect(-ld, nor), -rd), 0.), 10.);\n  float l   = dif*sha;\n\n  float lin = mix(0.2, 1.0, l);\n\n  vec3 col = lin*color + spe*sha;\n\n  float f = exp(-20.0*(max(t-3.0, 0.0) / MAX_RAY_LENGTH));\n    \n  return mix(skyCol, col , f)*ifade;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q=fragCoord.xy/RESOLUTION.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 ro = 0.4*vec3(2.0, 0, 0.2)+vec3(0.0, 1.25, 0.0);\n  float tm = mix(10.33, 11.7, 0.5+0.5*sin(TIME*TAU/60.0));\n  ro.xz *= ROT(sin(tm));\n  ro.yz *= ROT(sin(tm*sqrt(0.5))*0.25);\n\n  vec3 ww = normalize(vec3(0.0, 1.0, 0.0) - ro);\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize( p.x*uu + p.y*vv + (2.0+0.5*tanh_approx(length(p)))*ww);\n\n  vec3 col = render(ro, rd);\n  col = clamp(col, 0.0, 1.0);\n  fragColor = vec4(postProcess(col, q),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tfSzB.jpg", "access": "api", "license": "cc0-1.0", "functions": [[637, 637, 665, 685, 761], [763, 763, 802, 802, 890], [892, 892, 927, 927, 1012], [1014, 1014, 1062, 1062, 1332], [1334, 1334, 1388, 1388, 1468], [1470, 1470, 1501, 1501, 1525], [1527, 1527, 1565, 1565, 1847], [1849, 1849, 1867, 1867, 2352], [2354, 2354, 2372, 2372, 2458], [2461, 2461, 2515, 2515, 2731], [2733, 2733, 2759, 2759, 2968], [2970, 2970, 3047, 3047, 3347], [3349, 3349, 3392, 3392, 3644], [3646, 3646, 3668, 3668, 3837], [3839, 3839, 3876, 3876, 5432], [5434, 5434, 5489, 5489, 6096]], "test": "untested"}
{"id": "stXSzB", "name": "Pixel Art Clouds V2", "author": "bogz", "description": "2D cloud shader from 2019, with tweaks", "tags": ["procedural", "2d", "clouds", "pixel", "sky", "art", "mist"], "likes": 3, "viewed": 533, "published": 3, "date": "1625944502", "time_retrieved": "2024-07-30T19:11:26.356160", "image_code": "precision highp float;\n\nfloat rand(vec2 coords)\n{\n\treturn fract(sin(dot(coords, vec2(56.3456f,78.3456f)) * 5.0f) * 10000.0f);\n}\n\nfloat noise(vec2 coords)\n{\n\tvec2 i = floor(coords);\n\tvec2 f = fract(coords);\n\n\tfloat a = rand(i);\n\tfloat b = rand(i + vec2(1.0f, 0.0f));\n\tfloat c = rand(i + vec2(0.0f, 1.0f));\n\tfloat d = rand(i + vec2(1.0f, 1.0f));\n\n\tvec2 cubic = f * f * (3.0f - 2.0f * f);\n\n\treturn mix(a, b, cubic.x) + (c - a) * cubic.y * (1.0f - cubic.x) + (d - b) * cubic.x * cubic.y;\n}\n\nfloat fbm(vec2 coords)\n{\n\tfloat value = 0.0f;\n\tfloat scale = 0.5f;\n\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tvalue += noise(coords) * scale;\n\t\tcoords *= 4.0f;\n\t\tscale *= 0.5f;\n\t}\n\n\treturn value;\n}\n\nfloat value(vec2 uv)\n{\n    float Pixels = 1024.0;\n    float dx = 10.0 * (1.0 / Pixels);\n    float dy = 10.0 * (1.0 / Pixels);\n  \n\n    float final = 0.0f;\n    \n    vec2 uvc = uv;\n    \n    vec2 Coord = vec2(dx * floor(uvc.x / dx),\n                          dy * floor(uvc.y / dy));\n\n    \n    for (int i =0;i < 3; i++)\n    {\n        vec2 motion = vec2(fbm(Coord + iTime * 0.05f + vec2(i)));\n        final += fbm(Coord + motion + vec2(i));\n    }\n\n\treturn final / 3.0f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.y * 2.0f;\n    \n\tfragColor = vec4(mix(vec3(-0.3f), vec3(0.45, 0.4f, 0.6f) + vec3(0.6f), value(uv)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stXSzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 49, 49, 127], [129, 129, 155, 155, 485], [487, 487, 511, 511, 676], [678, 678, 700, 700, 1144], [1146, 1146, 1203, 1203, 1349]], "test": "untested"}
{"id": "7lfXRB", "name": "2D Misty Shader", "author": "bogz", "description": "2D mist, using FBM", "tags": ["2d", "noise", "cloud", "misty"], "likes": 5, "viewed": 357, "published": 3, "date": "1625944249", "time_retrieved": "2024-07-30T19:11:27.217856", "image_code": "precision highp float;\n\nfloat rand(vec2 coords)\n{\n\treturn fract(sin(dot(coords, vec2(56.3456f,78.3456f)) * 5.0f) * 10000.0f);\n}\n\nfloat noise(vec2 coords)\n{\n\tvec2 i = floor(coords);\n\tvec2 f = fract(coords);\n\n\tfloat a = rand(i);\n\tfloat b = rand(i + vec2(1.0f, 0.0f));\n\tfloat c = rand(i + vec2(0.0f, 1.0f));\n\tfloat d = rand(i + vec2(1.0f, 1.0f));\n\n\tvec2 cubic = f * f * (3.0f - 2.0f * f);\n\n\treturn mix(a, b, cubic.x) + (c - a) * cubic.y * (1.0f - cubic.x) + (d - b) * cubic.x * cubic.y;\n}\n\nfloat fbm(vec2 coords)\n{\n\tfloat value = 0.0f;\n\tfloat scale = 0.5f;\n\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tvalue += noise(coords) * scale;\n\t\tcoords *= 4.0f;\n\t\tscale *= 0.5f;\n\t}\n\n\treturn value;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.y * 2.0f;\n \n\tfloat final = 0.0f;\n    \n    for (int i =1; i < 6; i++)\n    {\n        vec2 motion = vec2(fbm(uv + iTime * 0.05f + vec2(i)));\n\n        final += fbm(uv + motion);\n\n    }\n    \n    final /= 5.0f;\n\tfragColor = vec4(mix(vec3(-0.3f), vec3(0.45, 0.4f, 0.6f) + vec3(0.6f), final), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lfXRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 49, 49, 127], [129, 129, 155, 155, 485], [487, 487, 511, 511, 677], [680, 680, 737, 737, 1069]], "test": "untested"}
{"id": "NsSSRW", "name": "Class I Goldberg Polyhedron ", "author": "Lichtso", "description": "UV-mapped hexagonal tiling on an icosahedron, See: https://en.wikipedia.org/wiki/Goldberg_polyhedron\n\nInstead of mesh tessellation this shader uses voronoi cells.\nThis way the performance is independent of the number of tiles.", "tags": ["uv", "sphere", "hexagon", "tile", "polyhedron"], "likes": 6, "viewed": 354, "published": 3, "date": "1625939958", "time_retrieved": "2024-07-30T19:11:28.061600", "image_code": "const float M_PI = radians(180.0);\nconst float icosahedron_radius_by_edge_length = sin(M_PI*2.0/5.0);\nconst float inversesqrt5 = inversesqrt(5.0);\nconst vec3 ICOSAHEDRON_VERTICES[12] = vec3[](\n    vec3(0.0, -1.0, 0.0),\n    vec3(-0.27639320492744446, -inversesqrt5, -0.8506507873535156),\n    vec3(-0.8944271802902222, -inversesqrt5, -1.6430361299034693e-16),\n    vec3(-0.27639320492744446, -inversesqrt5, 0.8506507873535156),\n    vec3(0.7236068248748779, -inversesqrt5, 0.525731086730957),\n    vec3(0.7236068248748779, -inversesqrt5, -0.525731086730957),\n    vec3(0.27639320492744446, inversesqrt5, -0.8506507873535156),\n    vec3(-0.7236068248748779, inversesqrt5, -0.525731086730957),\n    vec3(-0.7236068248748779, inversesqrt5, 0.525731086730957),\n    vec3(0.27639320492744446, inversesqrt5, 0.8506507873535156),\n    vec3(0.8944271802902222, inversesqrt5, 1.6430361299034693e-16),\n    vec3(0.0, 1.0, 0.0)\n);\n\nconst float blending_region = 0.65;\nconst float planet_radius = 9.0;\n\nbool side_of_half_plane(vec3 direction, int pole_index_a, int pole_index_b) {\n    vec3 aux_a = cross(ICOSAHEDRON_VERTICES[pole_index_a], ICOSAHEDRON_VERTICES[pole_index_b]);\n    return dot(direction, aux_a) > 0.0;\n}\n\nfloat line_sphere_intersection(vec3 origin, vec3 direction, float radius, out vec3 intersections[2]) {\n    float a = dot(direction, direction);\n    float b = -dot(direction, origin);\n    float c = dot(origin, origin) - radius*radius;\n    float d = (b*b)-a*c;\n    if(d < 0.0)\n        return -1.0;\n    d = sqrt(d);\n    direction /= a;\n    intersections[0] = origin+direction*(b-d);\n    intersections[1] = origin+direction*(b+d);\n    return b-d;\n}\n\n/*vec3 bary_to_cart(vec3 barycentric, ivec3 pole_indices) {\n    barycentric = sin(sin(barycentric));\n    mat3 mat = mat3(\n        ICOSAHEDRON_VERTICES[pole_indices[0]],\n        ICOSAHEDRON_VERTICES[pole_indices[1]],\n        ICOSAHEDRON_VERTICES[pole_indices[2]]\n    );\n    return normalize(mat*barycentric);\n}\n\nvec3 cart_to_bary(vec3 direction, ivec3 pole_indices) {\n    vec3 barycentric = vec3(0.0);\n    for(int i = 0; i < 3; ++i)\n        barycentric[i] = dot(cross(ICOSAHEDRON_VERTICES[pole_indices[(i+1)%3]], ICOSAHEDRON_VERTICES[pole_indices[(i+2)%3]]), direction);\n    barycentric = asin(asin(barycentric));\n    return barycentric/dot(barycentric, vec3(1.0));\n}*/\n\nvec3 cart_to_bary(vec3 direction, ivec3 pole_indices) {\n    vec3 bary;\n    for(int i = 0; i < 3; ++i) {\n        vec3 b = ICOSAHEDRON_VERTICES[pole_indices[(i+1)%3]];\n        vec3 c = ICOSAHEDRON_VERTICES[pole_indices[(i+2)%3]];\n        float numerator = dot(direction, cross(b, c));\n        float denominator = 1.0+inversesqrt5+dot(direction, b)+dot(direction, c);\n        bary[i] = 10.0/M_PI*atan(numerator, denominator);\n    }\n    bary /= dot(vec3(1.0), bary);\n    return bary;\n}\n\nvec3 bary_to_cart(vec3 barycentric, ivec3 pole_indices) {\n    vec4 planes[3];\n    for(int i = 0; i < 3; ++i) {\n        vec3 b = ICOSAHEDRON_VERTICES[pole_indices[(i+1)%3]];\n        vec3 c = ICOSAHEDRON_VERTICES[pole_indices[(i+2)%3]];\n        float tangent = tan(M_PI/10.0*barycentric[i]);\n        planes[i].x = tangent*(1.0+inversesqrt5);\n        planes[i].yzw = cross(b, c)-tangent*(b+c);\n    }\n    vec3 l_g0 = planes[0].x * planes[1].yzw - planes[0].yzw * planes[1].x;\n    vec3 l_g1 = planes[0].z * vec3(planes[1].w, 0.0, -planes[1].y) + planes[0].w * vec3(-planes[1].z, planes[1].y, 0.0) + planes[0].y * vec3(0.0, -planes[1].w, planes[1].z);\n    vec4 p = l_g0.y * vec4(0.0, -planes[2].w, 0.0, planes[2].y) + l_g0.z * vec4(0.0, planes[2].z, -planes[2].y, 0.0) + l_g1.y * vec4(planes[2].z, 0.0, -planes[2].x, 0.0) + l_g1.z * vec4(planes[2].w, 0.0, 0.0, -planes[2].x) + vec4(l_g1.x, -l_g1.x, l_g0.x, -l_g0.x) * planes[2].yxwz;\n    return -p.yzw/p.x;\n}\n\nvec2 bary_to_texcoord(vec3 barycentric) {\n    return vec2(0.5)+0.75*vec2(barycentric.z, (barycentric.x-barycentric.y)/sqrt(3.0));\n}\n\nfloat checker_texture(vec2 texcoord) {\n    vec2 repeated = mod(texcoord, vec2(1.0));\n    vec2 chequer = smoothstep(0.4, 0.5, repeated) * smoothstep(1.0, 0.95, repeated);\n    return abs(1.0-chequer.x-chequer.y);\n}\n\nfloat stripe_texture(float texcoord) {\n    return abs(mod(texcoord, 1.0)-0.5)*2.0;\n}\n\nconst vec3 color_palette[3] = vec3[3](\n    vec3(0.7, 0.7, 0.3),\n    vec3(0.0, 0.6, 0.0),\n    vec3(0.2, 0.6, 0.8)\n);\nvec3 color_of_cell(ivec3 cell) {\n    int residue_class = (cell.x + cell.y * 2) % 3;\n    return color_palette[residue_class];\n}\n\n/*bool is_cell_patched(int gp_index, int triangle_longitude, int triangle_latitude, ivec3 cell) {\n    if(triangle_longitude == 1 || triangle_longitude == 2) {\n        return cell.z == 0\n            || (triangle_longitude == 2 && cell.y == 0)\n            || (triangle_longitude == 1 && cell.x == 0);\n    } else {\n        return (cell.y == 0 && cell.z < gp_index)\n            || (triangle_latitude > 0 && cell.z == gp_index);\n    }\n}*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int gp_index = int(planet_radius/icosahedron_radius_by_edge_length);\n    \n    // Ray tracing of the sphere\n    vec3 view_ray_origin = vec3(0.0, 0.0, planet_radius*10.0);\n    vec3 view_ray_hit = vec3(fragCoord/iResolution.xy*2.0-vec2(1.0), 0.0);\n    view_ray_hit.x *= iResolution.x/iResolution.y;\n    view_ray_hit.xy *= planet_radius*1.2;\n    vec3 view_ray_direction = normalize(view_ray_hit-view_ray_origin);\n\n    vec3 intersections[2];\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    if(line_sphere_intersection(view_ray_origin, view_ray_direction, planet_radius, intersections) < 0.0)\n        return;\n    vec3 surface_normal = normalize(intersections[0]);\n    \n    float rotate_y = (iMouse.x/iResolution.x-0.5+iTime*0.02)*M_PI*2.0;\n    float rotate_x = (iMouse.y/iResolution.y-0.5)*M_PI;\n    surface_normal = (mat4(\n        cos(rotate_y), 0.0, sin(rotate_y), 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        -sin(rotate_y), 0.0, cos(rotate_y), 0.0,\n        0.0, 0.0, 0.0, 1.0\n    )*mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, cos(rotate_x), sin(rotate_x), 0.0,\n        0.0, -sin(rotate_x), cos(rotate_x), 0.0,\n        0.0, 0.0, 0.0, 1.0\n    )*vec4(surface_normal, 1.0)).xyz;\n\n    vec3 spherical = surface_normal;\n    ivec3 pole_indices;\n    int triangle_longitude;\n    int triangle_latitude;\n    {\n        // Icosahedron triangles\n        float longitude = 1.0-acos(spherical[1])/M_PI;\n        float latitude = atan(spherical[0], spherical[2])/M_PI;\n        int triangle_latitude_south = int(mod((2.9+latitude)*2.5, 5.0));\n        int triangle_latitude_north = int(mod((3.1+latitude)*2.5, 5.0));\n        if(side_of_half_plane(spherical, 1+(triangle_latitude_south+1)%5, 1+triangle_latitude_south)) {\n            pole_indices = ivec3(1+(triangle_latitude_south+1)%5, 1+triangle_latitude_south, 0);\n            triangle_longitude = 0;\n            triangle_latitude = triangle_latitude_south;\n        } else if(side_of_half_plane(spherical, 6+triangle_latitude_north, 6+(triangle_latitude_north+1)%5)) {\n            pole_indices = ivec3(6+triangle_latitude_north, 6+(triangle_latitude_north+1)%5, 11);\n            triangle_longitude = 3;\n            triangle_latitude = triangle_latitude_north;\n        } else if(side_of_half_plane(spherical, 6+triangle_latitude_north, 1+triangle_latitude_north) &&\n                  side_of_half_plane(spherical, 1+triangle_latitude_north, 6+(triangle_latitude_north+1)%5)) {\n            pole_indices = ivec3(6+(triangle_latitude_north+1)%5, 6+triangle_latitude_north, 1+triangle_latitude_north);\n            triangle_longitude = 2;\n            triangle_latitude = triangle_latitude_north;\n        } else {\n            pole_indices = ivec3(1+triangle_latitude_south, 1+(triangle_latitude_south+1)%5, 6+(triangle_latitude_south+1)%5);\n            triangle_longitude = 1;\n            triangle_latitude = triangle_latitude_south;\n        }\n    }\n    \n    vec3 barycentric = cart_to_bary(spherical, pole_indices);\n    vec2 orig_texcoord = bary_to_texcoord((triangle_longitude%2 == 1) ? -barycentric : barycentric);\n    ivec3 cell;\n    ivec3 neighbors[3];\n    vec3 blending_weights = vec3(0.0);\n    {\n        // Barycentric rounding\n        ivec3 rounded = ivec3(barycentric*float(gp_index));\n        int step_dir = (rounded.x+rounded.y+rounded.z)%2 == gp_index%2 ? 1 : -1;\n        ivec3 center = rounded*3+ivec3(3+step_dir)/2;\n        float distance_to_edge = 10000.0;\n\n        // Voronoi cells\n        for(int i = 0; i < 3; ++i) {\n            ivec3 neighbor = ivec3(step_dir);\n            neighbor[i] *= -2;\n            neighbor += center;\n            neighbor /= 3;\n            neighbors[i] = neighbor;\n            vec3 diff = (bary_to_cart(vec3(neighbor)/float(gp_index), pole_indices)-spherical)*float(gp_index);\n            blending_weights[i] = dot(diff, diff);\n            if(distance_to_edge > blending_weights[i]) {\n                distance_to_edge = blending_weights[i];\n                cell = neighbor;\n            }\n        }\n        blending_weights = smoothstep(vec3(blending_region), vec3(0.0), blending_weights);\n        blending_weights /= dot(vec3(1.0), blending_weights);\n    }\n\n    // Patch triangle edges\n    if(triangle_longitude == 2 && cell.y == 0 && cell.z > 0) {\n        cell.xz = cell.zx;\n        barycentric = vec3(1.0-barycentric.x, -barycentric.y, 1.0-barycentric.z);\n        triangle_longitude = 1; // 3-triangle_longitude;\n    } else if(triangle_longitude == 1 && cell.x == 0 && cell.z > 0) {\n        cell.yz = cell.zy;\n        barycentric = vec3(-barycentric.x, 1.0-barycentric.y, 1.0-barycentric.z);\n        triangle_latitude = (triangle_latitude+1)%5;\n        triangle_longitude = 2; // 3-triangle_longitude;\n    }\n    if(cell.z == 0) {\n        cell.yx = cell.xy;\n        barycentric = vec3(1.0-barycentric.x, 1.0-barycentric.y, -barycentric.z);\n        triangle_longitude = triangle_longitude*3-3;\n    }\n    if(triangle_longitude == 0) {\n        if(cell.y == 0 && cell.z < gp_index) {\n            cell.yx = cell.xy;\n            barycentric = vec3(-barycentric.y, 1.0-barycentric.z, 1.0-barycentric.x);\n            triangle_latitude = (triangle_latitude+1)%5; // (triangle_latitude+1+triangle_longitude)%5;\n        } else if(triangle_latitude > 0 && cell.z == gp_index) {\n            for(int i = 5; i > triangle_latitude; --i)\n                barycentric = vec3(-barycentric.y, 1.0-barycentric.z, 1.0-barycentric.x);\n            triangle_latitude = 0;\n        }\n    } else if(triangle_longitude == 3) {\n        if(cell.x == 0 && cell.z < gp_index) {\n            cell.yx = cell.xy;\n            barycentric = vec3(1.0-barycentric.z, -barycentric.x, 1.0-barycentric.y);\n            triangle_latitude = (triangle_latitude+1)%5; // (triangle_latitude+4-triangle_longitude)%5;\n        } else if(triangle_latitude > 0 && cell.z == gp_index) {\n            for(int i = 5; i > triangle_latitude; --i)\n                barycentric = vec3(1.0-barycentric.z, -barycentric.x, 1.0-barycentric.y);\n            triangle_latitude = 0;\n        }\n    }\n    \n    // Texture Coordinates\n    vec2 patched_texcoord = bary_to_texcoord((triangle_longitude%2 == 1) ? -barycentric : barycentric);\n    \n    // Texture\n    // fragColor.rgb = barycentric;\n    // ivec2 rectified_coords = triangle_longitude%2 == 1 ? ivec2(gp_index)-cell.xy : cell.xy;\n    // rectified_coords += gp_index*ivec2(triangle_latitude, triangle_longitude/2);\n    // fragColor.r = float(triangle_latitude)/5.0;\n    // fragColor.g = float(triangle_longitude)/4.0;\n    // fragColor.rgb = vec3(rectified_coords, 0.0)/float(5*gp_index);\n    // fragColor.rgb = vec3(cell)/float(gp_index)*0.8+vec3(0.2);\n    for(int i = 0; i < 3; ++i) {\n        vec3 color = color_of_cell(neighbors[i]);\n        color *= 0.9+0.1*checker_texture(patched_texcoord*40.0);\n        fragColor.rgb += color*color*blending_weights[i];\n    }\n    fragColor.rgb = sqrt(fragColor.rgb);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsSSRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[980, 980, 1057, 1057, 1195], [1197, 1197, 1299, 1299, 1641], [2313, 2313, 2368, 2368, 2794], [2796, 2796, 2853, 2853, 3748], [3750, 3750, 3791, 3791, 3881], [3883, 3883, 3921, 3921, 4095], [4097, 4097, 4135, 4135, 4181], [4299, 4299, 4331, 4331, 4425], [4862, 4862, 4917, 4917, 11775]], "test": "untested"}
{"id": "stfXRS", "name": "SDF-Develop 2", "author": "golinad", "description": "For learning and testing sdf rendering", "tags": ["sdf"], "likes": 2, "viewed": 341, "published": 3, "date": "1625933003", "time_retrieved": "2024-07-30T19:11:28.819573", "image_code": "// Uncomment for debug rendering\n//#define COMPLEXITY\n//#define ISOLINES\n//#define CURVATURE\n\nfloat delta = 0.001;\nfloat delta2 = 0.05;\nfloat maxT = 20.0;\nconst int maxIt = 100;\nconst float pi = 3.14159265359;\n//vec4 bgColor = vec4(0.25,0.5,0.8,1.0);\nvec4 bgColor = vec4(0.1,0.2,0.4,1.0);\n\n// SDF primitives\n// giving primitives a position makes them easy to use\n// but more complex in calculation and difficult to use with manipulations like extrude\nfloat sdSphere(vec3 pos, float r, in vec3 p) {\n    return distance(p, pos) - r;\n}\nfloat sdBox(vec3 pos, vec3 ext, in vec3 p) {\n    vec3 q = abs(p-pos) - ext/2.0;\n    return length(max(q,0.0)) + min(max(max(q.x, q.y),q.z),0.0);\n}\nfloat sdTorus(in vec3 p, float r1, float r2) {\n    vec3 c = vec3(normalize(p.xy)*r1, 0.0);\n    return distance(p, c) - r2;\n}\n\n// SDF operations\nfloat sdUnion(float a, float b) {return min(a,b);}\nfloat sdIntersect( float a, float b) {return max(a,b);}\nfloat sdSubstract(float a, float b) {return max(a, -b);}\n\nfloat sdShell(float d, float t) {return abs(d)-t;}\n\nvec3 sdExtrude(vec3 pos, vec3 dir) {\n    return pos - clamp(pos, -0.5*dir, 0.5*dir);\n}\nvec3 sdArray(vec3 pos, vec3 step) {\n    // we dont want the break in the center\n    // the repeaded block should be centered at origin\n    return mod(pos +0.5*step, step) - 0.5*step;\n}\n// placd content at positive y\nvec3 sdRadialArray(vec3 pos, float count) {\n    // we dont want the break in the center\n    // the repeaded block should be centered at origin\n    float angle = atan(pos.x, pos.y);\n    angle = mod(angle + pi/count, 2.0*pi/count) - pi/count;\n    float l = length(pos.xy);\n    return vec3(sin(angle)*l, cos(angle)*l, pos.z);\n}\nvec3 sdMirror(vec3 pos) {\n    return abs(pos);\n}\n\nfloat isoLines(float d, float seg) {\n    return mod(d, seg) > seg*0.95 ^^ d < 0.0?1.0:0.0;\n}\n\nfloat map(in vec3 p) {\n    p = sdArray(p-vec3(sin(iTime), cos(iTime), 0.0), vec3(4,4,4));\n    float d = sdSphere(vec3(0), 1.0, p);\n    if(d < 0.1) {\n        vec3 p1 = sdRadialArray(p.xyz, 6.0);\n        p1 = sdRadialArray(p1.yzx, 6.0);\n        float d1 = sdSphere(vec3(0,0.75,0), 0.4, p1);\n        d = sdIntersect(sdShell(d1,0.05), d);\n    }\n    \n    return d;\n}\n\n// calculate normal based on simplified(3 vs. 6 samples) gradient around pos\n// Note: when we are marching solids, d is 0 on surface\nvec3 calcNormal(in vec3 p, in float d) {\n    float dx = map(p + vec3(delta,0,0));\n    float dy = map(p + vec3(0,delta,0));\n    float dz = map(p + vec3(0,0,delta));\n    \n    return normalize(vec3(dx-d, dy-d, dz-d));\n}\n\nfloat calcCurvature(in vec3 p, in float d) {\n    float dx = map(p + vec3(delta2,0,0));\n    float dy = map(p + vec3(0,delta2,0));\n    float dz = map(p + vec3(0,0,delta2));\n    \n    float ndx = map(p + vec3(-delta2,0,0));\n    float ndy = map(p + vec3(0,-delta2,0));\n    float ndz = map(p + vec3(0,0,-delta2));\n    \n    \n    return clamp((dx+dy+dz+ndx+ndy+ndz-6.0*d)/delta2/4.0,-1.0,1.0);\n}\n\nvoid render(out vec4 fragColor, in vec3 ro, in vec3 rd) {\n    float t = 0.0;\n    \n    int j = 0;\n    for(int i = 0; i < maxIt; i++) {\n        if (t > maxT) {\n            fragColor = bgColor;\n            break;\n        }\n        \n        float d = map(ro+t*rd);\n        if(d < delta || i == 99) {\n            vec3 n = calcNormal(ro+t*rd, d);\n            fragColor = vec4((n*0.5+0.5)+1.0-min(calcCurvature(ro+t*rd, d)+1.0, 1.0),1.0);\n            //fragColor = vec4((n*0.5+0.5)*min(calcCurvature(ro+t*rd, d)+1.0, 1.0)*(max(dot(n, normalize(vec3(-1,1,0.5))), 0.0) + 0.5),1.0);\n#ifdef CURVATURE\n    fragColor = mix(vec4(0,0,1,1), vec4(1,0,0,1), calcCurvature(ro+t*rd, d) *0.5 + 0.5);\n#endif\n            break;\n        } else {\n            t += d;\n        }\n        j++;\n    }\n    // fade to bg (fog)\n    fragColor = mix(fragColor, bgColor, t/maxT);\n    \n#ifdef COMPLEXITY //marching complexity\n    fragColor = mix(vec4(0,0,1,1), vec4(1,0,0,1), float(j)/100.0);\n#endif\n}\n\nvoid debugRender(out vec4 fragColor, in vec2 uv) {\n    float d = map(vec3(uv,0));\n    vec3  n = calcNormal(vec3(uv, 0), d);\n    float l = isoLines(d, 0.1);\n\n    // colored\n    //fragColor = vec4((n*0.5+0.5)*l,1.0);\n    \n    // monochrome\n    fragColor = vec4(l,l,l,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy/2.0)/iResolution.y*2.0;\n    \n#ifdef ISOLINES\n    debugRender(fragColor, uv);\n    //fragColor = vec4(mod(uv, 1.0), 0,1);\n#else\n    vec3 ro = vec3(0,0,2);\n    vec3 rd = normalize(vec3(uv.xy, 0) - ro);\n    render(fragColor, ro , rd);\n#endif\n\n\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) {\n\n    render(fragColor, fragRayOri, fragRayDir);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stfXRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[290, 451, 497, 497, 532], [533, 533, 577, 577, 679], [680, 680, 726, 726, 804], [806, 824, 857, 857, 874], [875, 875, 913, 913, 930], [931, 931, 968, 968, 987], [989, 989, 1022, 1022, 1039], [1041, 1041, 1077, 1077, 1127], [1128, 1128, 1163, 1262, 1312], [1313, 1344, 1387, 1486, 1668], [1669, 1669, 1694, 1694, 1717], [1813, 1813, 1835, 1835, 2174], [2176, 2309, 2349, 2349, 2525], [2527, 2527, 2571, 2571, 2914], [2916, 2916, 2973, 2973, 3880], [3882, 3882, 3932, 3932, 4154], [4156, 4156, 4213, 4263, 4545], [4547, 4547, 4641, 4641, 4691]], "test": "untested"}
{"id": "slfSzS", "name": "Sitting By The Window", "author": "Kris_Katur", "description": "And dreaming of everything", "tags": ["refraction", "blur", "normals", "rain", "webcam", "window", "raindrop"], "likes": 44, "viewed": 2976, "published": 3, "date": "1625931672", "time_retrieved": "2024-07-30T19:11:29.567573", "image_code": "// shader derived from Heartfelt - by Martijn Steinrucken aka BigWings - 2017\n// https://www.shadertoy.com/view/ltffzl\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define S(a, b, t) smoothstep(a, b, t)\n//#define DEBUG\n#define size 0.2\n\n\nvec3 N13(float p) {\n   //  from DAVE HOSKINS\n   vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nvec4 N14(float t) {\n\treturn fract(sin(t*vec4(123., 1024., 1456., 264.))*vec4(6547., 345., 8799., 1564.));\n}\nfloat N(float t) {\n    return fract(sin(t*12345.564)*7658.76);\n}\n\nfloat Saw(float b, float t) {\n\treturn S(0., b, t)*S(1., b, t);\n}\n\n\n\nvec2 Drops(vec2 uv, float t) {\n    \n    vec2 UV = uv;\n    \n    // DEFINE GRID\n    uv.y += t*0.8;\n    vec2 a = vec2(6., 1.);\n    vec2 grid = a*2.;\n    vec2 id = floor(uv*grid);\n    \n    // RANDOM SHIFT Y\n    float colShift = N(id.x); \n    uv.y += colShift;\n    \n    // DEFINE SPACES\n    id = floor(uv*grid);\n    vec3 n = N13(id.x*35.2+id.y*2376.1);\n    vec2 st = fract(uv*grid)-vec2(.5, 0);\n    \n    // POSITION DROPS\n    //clamp(2*x,0,2)+clamp(1-x*.5, -1.5, .5)+1.5-2\n    float x = n.x-.5;\n    \n    float y = UV.y*20.;\n    \n    float distort = sin(y+sin(y));\n    x += distort*(.5-abs(x))*(n.z-.5);\n    x *= .7;\n    float ti = fract(t+n.z);\n    y = (Saw(.85, ti)-.5)*.9+.5;\n    vec2 p = vec2(x, y);\n    \n    // DROPS\n    float d = length((st-p)*a.yx);\n    \n    float dSize = size; \n    \n    float Drop = S(dSize, .0, d);\n    \n    \n    float r = sqrt(S(1., y, st.y));\n    float cd = abs(st.x-x);\n    \n    // TRAILS\n    float trail = S((dSize*.5+.03)*r, (dSize*.5-.05)*r, cd);\n    float trailFront = S(-.02, .02, st.y-y);\n    trail *= trailFront;\n    \n    \n    // DROPLETS\n    y = UV.y;\n    y += N(id.x);\n    float trail2 = S(dSize*r, .0, cd);\n    float droplets = max(0., (sin(y*(1.-y)*120.)-st.y))*trail2*trailFront*n.z;\n    y = fract(y*10.)+(st.y-.5);\n    float dd = length(st-vec2(x, y));\n    droplets = S(dSize*N(id.x), 0., dd);\n    float m = Drop+droplets*r*trailFront;\n    #ifdef DEBUG\n    m += st.x>a.y*.45 || st.y>a.x*.165 ? 1.2 : 0.; //DEBUG SPACES\n    #endif\n    \n    \n    return vec2(m, trail);\n}\n\nfloat StaticDrops(vec2 uv, float t) {\n\tuv *= 30.;\n    \n    vec2 id = floor(uv);\n    uv = fract(uv)-.5;\n    vec3 n = N13(id.x*107.45+id.y*3543.654);\n    vec2 p = (n.xy-.5)*0.5;\n    float d = length(uv-p);\n    \n    float fade = Saw(.025, fract(t+n.z));\n    float c = S(size, 0., d)*fract(n.z*10.)*fade;\n\n    return c;\n}\n\nvec2 Rain(vec2 uv, float t) {\n    float s = StaticDrops(uv, t); \n    vec2 r1 = Drops(uv, t);\n    vec2 r2 = Drops(uv*1.8, t);\n    \n    #ifdef DEBUG\n    float c = r1.x;\n    #else\n    float c = s+r1.x+r2.x;\n    #endif\n    \n    c = S(.3, 1., c);\n    \n    #ifdef DEBUG\n    return vec2(c, r1.y);\n    #else\n    return vec2(c, max(r1.y, r2.y));\n    #endif\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    vec2 UV = fragCoord.xy/iResolution.xy;\n    float T = iTime;\n    \n    \n    float t = T*.2;\n    \n    float rainAmount = 0.8;\n    \n\n    \n    UV = (UV-.5)*(.9)+.5;\n    \n    vec2 c = Rain(uv, t);\n\n   \tvec2 e = vec2(.001, 0.); //pixel offset\n   \tfloat cx = Rain(uv+e, t).x;\n   \tfloat cy = Rain(uv+e.yx, t).x;\n   \tvec2 n = vec2(cx-c.x, cy-c.x); //normals\n    \n\n\n    // BLUR derived from existical https://www.shadertoy.com/view/Xltfzj\n        float Pi = 6.28318530718; // Pi*2\n    \n        // GAUSSIAN BLUR SETTINGS {{{\n        float Directions = 32.0; // BLUR DIRECTIONS (Default 16.0 - More is better but slower)\n        float Quality = 8.0; // BLUR QUALITY (Default 4.0 - More is better but slower)\n        float Size = 32.0; // BLUR SIZE (Radius)\n        // GAUSSIAN BLUR SETTINGS }}}\n\n        vec2 Radius = Size/iResolution.xy;\n\n        vec3 col = texture(iChannel0, UV).rgb;\n        // Blur calculations\n        for( float d=0.0; d<Pi; d+=Pi/Directions)\n        {\n            for(float i=1.0/Quality; i<=1.0; i+=1.0/Quality)\n            {\n                #ifdef DEBUG\n                vec3 tex = texture( iChannel0, UV+c+vec2(cos(d),sin(d))*Radius*i).rgb;\n                #else\n                vec3 tex = texture( iChannel0, UV+n+vec2(cos(d),sin(d))*Radius*i).rgb;\n                #endif\n\n                col += tex;            \n            }\n        }\n\n        col /= Quality * Directions - 0.0;\n\n        vec3 tex = texture( iChannel0, UV+n).rgb;\n        c.y = clamp(c.y, 0.0, 1.);\n\n        col -= c.y;\n        col += c.y*(tex+.6);\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30381, "src": "https://soundcloud.com/rainsoundsofficial/sounds-to-make-you-97433627?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slfSzS.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[281, 281, 300, 325, 497], [499, 499, 518, 518, 606], [607, 607, 625, 625, 671], [673, 673, 702, 702, 737], [741, 741, 771, 771, 2246], [2248, 2248, 2285, 2285, 2565], [2567, 2567, 2596, 2596, 2916], [2919, 2919, 2976, 2976, 4610]], "test": "untested"}
{"id": "7lfSRS", "name": "walking slow", "author": "jorge2017a1", "description": "walking slow\n\n", "tags": ["robot", "android", "walkingslow"], "likes": 9, "viewed": 278, "published": 3, "date": "1625924169", "time_retrieved": "2024-07-30T19:11:30.495094", "image_code": "//por jorge2017a1-  //10-jul-2021\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvec2 RotarPuntoPivote(vec2 p,vec2 pXrYr, float theta)\n{    vec2 pp=p;\n     vec2 pos=pXrYr;\n     pp=pp-pos;\n     pp.xy = rotatev2(pp.xy, theta);\n     pp=pp+pos;   \n     return pp;\n}   \n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    float planeDist2 = 50.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    float planeDist5 = -p.z+40.0;  //pared frente\n    float planeDist6 = p.z+40.0;  //pared atras\n    \n    res =opU3(res, vec3(planeDist1,-1.0,7.0)); //inf\n    //res =opU3(res, vec3(planeDist1,-1.0,8.0)); //inf\n    p.y=p.y-10.0;\n    \n    p.x-=itime;\n    float posy=16.0;\n    float sbcabeza= sdBox(p-vec3(0.0,posy+0.0,0.0), vec3(10.,3.0,5.0) );\n    res =opU3(res, vec3(sbcabeza,1.0,-1)); \n    \n    //rotar pierna\n    vec3 pr1=p;\n    vec3 pr2=p;\n    pr1.xy= RotarPuntoPivote(p.xy,vec2(-1.0,13.0), (sin((iTime+8.0)/4.0)) );\n    pr2.xy= RotarPuntoPivote(p.xy,vec2(-1.0,13.0), (sin((iTime-8.0)/4.0)) );\n    \n    float sbPierna1= sdBox(pr1-vec3(-1.0,6.0,2.5), vec3(2.,7.0,2.0) );\n    float sbPierna2= sdBox(pr2-vec3(-1.0,6.0,-2.5), vec3(2.,7.0,2.0) );\n    \n    //rotat rodilla\n    vec3 pr1a=pr1;\n    vec3 pr2a=pr2;\n    pr1a.xy= RotarPuntoPivote(pr1a.xy,vec2(-1.0,0.0), abs(sin((2.0*iTime-8.0)/16.0)) );\n    pr2a.xy= RotarPuntoPivote(pr2a.xy,vec2(-1.0,0.0), abs(sin((2.0*iTime-8.0)/16.0)) );\n    \n    float sbRodilla1= sdBox(pr1a-vec3(-1.5,-4.0,2.0), vec3(2.,5.0,2.0) );\n    float sbRodilla2= sdBox(pr2a-vec3(-1.5,-4.0,-2.5), vec3(2.,5.0,2.0) );\n    \n    ///rotar pie\n    vec3 pr1b=pr1;\n    vec3 pr2b=pr2;\n    pr1b.xy= RotarPuntoPivote(pr1b.xy,vec2(-1.0,0.0), abs(sin((2.0*iTime-8.0)/16.0)) );\n    pr2b.xy= RotarPuntoPivote(pr2b.xy,vec2(-1.0,0.0), abs(sin((2.0*iTime-8.0)/16.0)) );\n    float sPie1= sdBox(pr1b-vec3(1.0,-9.0,2.0), vec3(3.,1.0,2.0) );\n    float sPie2= sdBox(pr2b-vec3(0.5,-9.0,-2.5), vec3(3.,1.0,2.0) );\n        res =opU3(res, vec3(sbPierna1,2.0,-1));\n        res =opU3(res, vec3(sbPierna2,3.0,-1));\n        res =opU3(res, vec3(sbRodilla1,4.0,-1));\n        res =opU3(res, vec3(sbRodilla2,4.0,-1));\n        res =opU3(res, vec3(sPie1,5.0,-1));\n        res =opU3(res, vec3(sPie2,5.0,-1));\n    \n    //return (dist, id_color, id_material)\n    return res;\n}\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p=ro;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {   p=ro + rd*t;\n        dS = GetDist(p);\n        \n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {   mObj.hitbln = true; minDist = abs(t); break; }\n        if(t>MAX_DIST)\n            { mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n///-----------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{   vec3 l = normalize(lp - p);\n    vec3 r = reflect(-l, n);\n    float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n    return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{ vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n        vec3  hal = normalize(-rd+l);\n         float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n         float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n         float occ = 0.5 + 0.5*n.y;\n        float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true)\n    { fshadow=GetShadow(p,lp);}\n    else\n    {   fshadow=0.5; }\n\n    vec3 lin=vec3(1.0);\n        lin*= amb*amb2*occ;\n        lin += 1.0*(dif+diff+dif3)*sh;\n        lin += 2.5*spe*vec3(1.0);\n        lin += 2.5*fre*vec3(1.);\n        lin += 0.5*dom*vec3(1.);\n        lin += 0.35*bac*vec3(1.);\n        lin += 0.35*rim*vec3(1.);\n        lin += 0.35*rim*dn*vec3(1.);\n        lin += 0.4*pow(clamp(dot(hal,n),0.0,1.0),12.0)*dif3;\n        lin *= atten*0.5*col*fshadow;\n        lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n        lin = pow(lin,vec3(0.4545));\n \n    return lin;\n    //return lin*atten*(1.0/2.0);\n    \n}\n///-------------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     \n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n///-------------------------------------\nvec3 render_sky_color(vec3 rd)\n{\n    \n    float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    \n\tvec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{\n    vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    \n    return col;\n}\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    if (id_material==5.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    return vec3( clamp(d,0.0,1.0) );\n    }\n    \n    if (id_material==6.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    vec3 col= vec3( clamp(d,0.0,1.0) );\n        l1= amb(col, 0.5) + col*diff( p,light_pos1, mObj.normal) + col*spec( p, light_pos1,mObj.rd, mObj.normal);\n        return l1;\n    }\n    \n    if (id_material==7.0)\n        {return pattern( p.xz );}\n    if (id_material==8.0)\n        {return pattern( p.xy );}\n    if (id_material==9.0)\n        {return pattern( p.zy );}\n    \n}\n\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    if (id_material>-1.0 && id_color==-1)\n    {  colobj=vec3(0.5);\n       colobj*=getMaterial(p, id_material); \n       return colobj;\n    }\n    return colobj;\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{\n  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;mObj.ro=ro;\n   vec3 p ;\n\n\n   float d=RayMarch(ro,rd, MAX_STEPS); Obj=mObj;\n    \n    if(mObj.hitbln) \n    {\n        p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        //result/=1.25;\n        //col= result*dif1;\n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n    \n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c) );\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t; t=mod(iTime*5.0,200.0);  itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        light_pos1= vec3(10.0, 20.0, -10.0 ); light_color1=vec3( 1.0 );\n        light_pos2= vec3(-10.0, 30.0,10.0 ); light_color2 =vec3( 1.0 ); \n    vec3 ro=vec3(0.0+t,7.0,-40.0);  vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n        light_pos1+=ro;\n        light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    col = linear2srgb(col);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n///--------------------------------------------FIN\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lfSRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[492, 492, 524, 524, 608], [609, 653, 700, 700, 727], [728, 728, 771, 771, 798], [799, 799, 847, 847, 875], [876, 947, 981, 981, 1077], [1078, 1078, 1112, 1112, 1203], [1204, 1204, 1238, 1238, 1329], [1330, 1370, 1404, 1404, 1499], [1501, 1501, 1556, 1556, 1681], [1685, 1725, 1750, 1750, 3837], [3838, 3889, 3913, 3913, 4101], [4103, 4103, 4152, 4152, 4834], [4835, 4868, 4904, 4904, 5151], [5152, 5207, 5234, 5234, 5251], [5253, 5253, 5289, 5289, 5381], [5382, 5382, 5428, 5428, 5561], [5563, 5563, 5637, 5637, 7284], [7285, 7326, 7406, 7406, 7538], [7539, 7580, 7612, 7612, 7818], [7820, 7868, 7896, 7896, 8091], [8092, 8143, 8190, 8190, 8910], [8965, 8965, 9058, 9058, 9356], [9358, 9358, 9389, 9389, 10038], [10040, 10089, 10115, 10115, 10217], [10219, 10219, 10277, 10277, 10329], [10331, 10380, 10437, 10437, 10970]], "test": "untested"}
{"id": "sllXRN", "name": "Dancing Julia Spheres", "author": "golinad", "description": "Animated Juliaset rendered using min distance to origin.", "tags": ["fractal"], "likes": 2, "viewed": 242, "published": 3, "date": "1625922787", "time_retrieved": "2024-07-30T19:11:31.241099", "image_code": "/*\n    Click in image to change pattern.\n*/\n#define SPHERES\n\nconst int maxIt = 16;\n \nvec2 cSqr(vec2 c){\n    return vec2(c.x*c.x - c.y*c.y, 2.0*c.x*c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y*4.0;\n    int it = 0;\n    vec2 z = uv;\n    vec2 c = (iMouse.xy-iResolution.xy*0.5)/iResolution.y*4.0;\n    float minD = length(z);\n    c = vec2(sin(iTime), cos(iTime))*(length(c)+abs(sin(iTime*3.14)*0.25));\n    for(int i=0; i< maxIt;i++){\n        z = cSqr(z) + c;\n        if(length(z) > 50.0) break;\n        it++;\n        minD = min(length(z), minD);\n    }\n    // Time varying pixel color\n#ifdef SPHERES\n    vec3 col = 1.0-vec3(1,iMouse.x/iResolution.x,iMouse.y/iResolution.y)*minD;\n#else\n    vec3 col = vec3(1.0)*float(it)/float(maxIt);\n#endif\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sllXRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 103, 103, 154], [156, 156, 213, 263, 922]], "test": "untested"}
{"id": "stfSWN", "name": "🔴 Circular 🔴", "author": "icylavah", "description": "A bunch of rotating arcs\nRendered: https://twitter.com/icylava_/status/1413845208052031493", "tags": ["raymarching"], "likes": 5, "viewed": 346, "published": 3, "date": "1625922030", "time_retrieved": "2024-07-30T19:11:32.003062", "image_code": "#define EPSILON (0.001)\n#define MAX_DEPTH (1000.0)\n#define MIN_DEPTH (EPSILON * 2.0)\n#define RINGS (20)\n#define PI (3.14159265359)\n#define TAU (PI * 2.0)\n#define LINE_THICKNESS (0.012)\n\nvec3 rgb2lab(vec3 c);\nvec3 lab2rgb(vec3 c);\n\n// https://gist.github.com/onedayitwillmake/3288507\nmat4 rotationX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 rotationY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n}\n\nvec3 pointMultiply(vec3 point, mat4 matrix) {\n    return (matrix * vec4(point, 0.0)).xyz;\n}\n\nfloat sphereSDF(vec3 point) {\n    return length(point) - 0.2;\n}\n\nfloat arcSDF(vec3 point, float radius, float angle1, float angle2) {\n    point = pointMultiply(point, rotationX(radians(30.0)));\n    float sizeD = LINE_THICKNESS;\n    float angle = mod(atan(point.z, point.x), TAU);\n    if(angle1 > angle2) angle2 += TAU;\n    if(angle1 > angle) angle += TAU;\n    if(angle >= angle1 && angle <= angle2) {\n        return min(\n            length(vec3(cos(angle1), 0.0, sin(angle1)) * radius - point) - sizeD,\n            length(vec3(cos(angle2), 0.0, sin(angle2)) * radius - point) - sizeD\n        );\n    }\n    float r = radius;\n    return length(normalize(vec3(point.x, 0.0, point.z)) * r - point) - sizeD;\n}\n\nfloat sceneSDF(vec3 point) {\n    float dist = MAX_DEPTH;\n    \n    for(int i = 0; i < RINGS; i++) {\n        float angle1 = fract(iTime * 1.0 - float(i) / float(RINGS) * 2.0) * TAU;\n        float angle2 = mod(angle1 + PI * 0.75, TAU);\n        dist = min(dist, arcSDF(point, 1.0 + float(i) / 10.0, angle1, angle2));\n    }\n    \n    point = pointMultiply(point, rotationX(radians(30.0)));\n    point = pointMultiply(point, rotationY(-TAU * iTime / 32.0));\n    point = (fract(point * 0.05) / 0.05) - 10.0;\n    dist = min(dist, sphereSDF(point));\n    \n    return dist;\n}\n\n#define C1 (rgb2lab(vec3(0.3, 0.7, 0.8)))\n#define C2 (rgb2lab(vec3(0.9, 0.2, 0.4)))\n#define C3 (rgb2lab(vec3(0.3, 0.5, 0.6)))\nvec3 colorField(vec3 point) {\n    float lerp = length(pointMultiply(point, rotationX(radians(30.0))).xz);\n    lerp = (lerp - 1.0) / (float(RINGS - 1) / 10.0);\n    lerp = max(0.0, lerp);\n    if(lerp > 1.1) return lab2rgb(C3);\n    lerp = pow(lerp, 1.0);\n    return lab2rgb(C1 * (1.0 - lerp) + C2 * lerp);\n}\n\nfloat march(vec3 from, vec3 dir) {\n    float depth = MIN_DEPTH;\n    for(int i = 0; i < 256; i++) {\n        float nearest = sceneSDF(from + dir * depth);\n        if(nearest < EPSILON) return depth;\n        depth += nearest;\n        if(depth > MAX_DEPTH) return MAX_DEPTH;\n    }\n    return depth;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = vec3(0.0, -0.35, 10.0);\n    vec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    float depth = march(pos, dir);\n    float upness = smoothstep(-0.3, 0.3, dot(dir, vec3(0.0, 1.0, 0.0)));\n    vec3 background = vec3(0.1, 0.0, 0.2);\n    if(depth > MAX_DEPTH - EPSILON) {\n        fragColor = vec4(pow(background, vec3(2.2)), 1.0);\n        return;\n    }\n    vec3 hitPos = pos + dir * depth;\n    //vec3 lightPos = vec3(cos(iTime * 6.28 / 2.0) * 4.5, sin(iTime * 6.28 / 2.0) * 4.5, 1.0);\n    //vec3 color = background * 0.5;\n    //color += vec3(0.98, 0.1, 0.4);\n    vec3 color = colorField(hitPos);\n    fragColor = vec4(pow(color, vec3(2.2)), 1.0);\n}\n\n\n//CIE L*a*b* (CIELAB, L* for lightness, a* from green to red, b* from blue to yellow)\n//Source: https://gist.github.com/mattatz/44f081cac87e2f7c8980 (HLSL)\nvec3 rgb2xyz(vec3 c){\n\tvec3 tmp=vec3(\n\t\t(c.r>.04045)?pow((c.r+.055)/1.055,2.4):c.r/12.92,\n\t\t(c.g>.04045)?pow((c.g+.055)/1.055,2.4):c.g/12.92,\n\t\t(c.b>.04045)?pow((c.b+.055)/1.055,2.4):c.b/12.92\n\t);\n\tmat3 mat=mat3(\n\t\t.4124,.3576,.1805,\n\t\t.2126,.7152,.0722,\n\t\t.0193,.1192,.9505\n\t);\n\treturn 100.*(tmp*mat);\n}\nvec3 xyz2lab(vec3 c){\n\tvec3 n=c/vec3(95.047,100.,108.883),\n\t     v=vec3(\n\t\t(n.x>.008856)?pow(n.x,1./3.):(7.787*n.x)+(16./116.),\n\t\t(n.y>.008856)?pow(n.y,1./3.):(7.787*n.y)+(16./116.),\n\t\t(n.z>.008856)?pow(n.z,1./3.):(7.787*n.z)+(16./116.)\n\t);\n\treturn vec3((116.*v.y)-16.,500.*(v.x-v.y),200.*(v.y-v.z));\n}\nvec3 rgb2lab(vec3 c){\n\tvec3 lab=xyz2lab(rgb2xyz(c));\n\treturn vec3(lab.x/100.,.5+.5*(lab.y/127.),.5+.5*(lab.z/127.));\n}\nvec3 lab2xyz(vec3 c){\n\tfloat fy=(c.x+16.)/116.,\n\t      fx=c.y/500.+fy,\n\t      fz=fy-c.z/200.;\n\treturn vec3(\n\t\t 95.047*((fx>.206897)?fx*fx*fx:(fx-16./116.)/7.787),\n\t\t100.   *((fy>.206897)?fy*fy*fy:(fy-16./116.)/7.787),\n\t\t108.883*((fz>.206897)?fz*fz*fz:(fz-16./116.)/7.787)\n\t);\n}\nvec3 xyz2rgb(vec3 c){\n\tmat3 mat=mat3(\n\t\t3.2406,-1.5372,-.4986,\n\t\t-.9689, 1.8758, .0415,\n\t\t .0557, -.2040,1.0570\n\t);\n\tvec3 v=(c/100.0)*mat,\n\t     r=vec3(\n\t\t(v.r>.0031308)?((1.055*pow(v.r,(1./2.4)))-.055):12.92*v.r,\n\t\t(v.g>.0031308)?((1.055*pow(v.g,(1./2.4)))-.055):12.92*v.g,\n\t\t(v.b>.0031308)?((1.055*pow(v.b,(1./2.4)))-.055):12.92*v.b\n\t);\n\treturn r;\n}\nvec3 lab2rgb(vec3 c){return xyz2rgb(lab2xyz(vec3(100.*c.x,2.*127.*(c.y-.5),2.*127.*(c.z-.5))));}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stfSWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[231, 283, 317, 317, 456], [458, 458, 492, 492, 628], [630, 630, 664, 664, 797], [799, 799, 844, 844, 890], [892, 892, 921, 921, 955], [957, 957, 1025, 1025, 1595], [1597, 1597, 1625, 1625, 2159], [2593, 2593, 2627, 2627, 2889], [2891, 2891, 2920, 2920, 3230], [3232, 3232, 3297, 3297, 3429], [3431, 3431, 3488, 3488, 4154], [4157, 4313, 4334, 4334, 4617], [4618, 4618, 4639, 4639, 4920], [4921, 4921, 4942, 4942, 5039], [5040, 5040, 5061, 5061, 5317], [5318, 5318, 5339, 5339, 5669], [5670, 5670, 5691, 5691, 5766]], "test": "untested"}
{"id": "ftXSRS", "name": "Analogous Oceans", "author": "byt3_m3chanic", "description": "Double tap system with some simple noise and sine waves to create some waves/motion.", "tags": ["waves"], "likes": 18, "viewed": 481, "published": 3, "date": "1625921803", "time_retrieved": "2024-07-30T19:11:32.753056", "image_code": "/**\n    Analogous Oceans | some abstract marching\n    @byt3_m3chanic | 07/10/21\n*/\n\nfloat offset[3] = float[]( 0.0, .7215, 1.73 );\nfloat weight[3] = float[]( 0.2, 0.35, 0.0735 );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\n    vec3 C = texture(iChannel0, uv).rgb;\n    vec3 R = texture(iChannel0, uv).rgb * weight[0];\n    for (int i=1; i<3; i++) {\n      R += texture(iChannel0, uv + vec2(offset[i])/iResolution.xy, 0.0).rgb * weight[i];\n      R += texture(iChannel0, uv - vec2(offset[i])/iResolution.xy, 0.0).rgb * weight[i];\n    }\n    \n    // mask for effect and mixdown \n    float dt = distance(uv.xy,vec2(.5))*.35;\n    dt = smoothstep(.80,.92,1.-dt);\n\n    vec3 Color = mix(R,C,dt);\n    \n    // output\n    Color=pow(Color, vec3(.4545));\n    fragColor = vec4(Color,1.);\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/**\n    Analogous Oceans | some abstract marching\n    @byt3_m3chanic | 07/10/21\n*/\n\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MAX_DIST    100.\n#define MIN_DIST    .0001\n\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4324.23); }\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = hash21(i);\n    float b = hash21(i + vec2(1.0, 0.0));\n    float c = hash21(i + vec2(0.0, 1.0));\n    float d = hash21(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3. - 2.0 * f);\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n//@iq\nfloat box(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.)-.025;\n}\n\nvec3 hit=vec3(0),hitPoint,gid,sid;\nvec3 speed = vec3(0);\nfloat glow =0.0,wtime;\nconst float size = .75;\nconst float hlf = size/2.;\nconst float dbl = size*2.;\n          \nvec2 map(in vec3 p, float sg) {\n    vec2 res = vec2(1e5,0.);\n    p += speed;\n\n    float id,nz=0.;\n    vec3 q;\n    for(int i = 0; i<2; i++)\n    {\n        float cnt = i<1 ? size : dbl;\n        q = vec3(p.x-cnt,p.yz);\n        id = floor(q.x/dbl) + .5;\n        q.x -= (id)*dbl;\n        float qf = (id)*dbl + cnt;\n\n        nz = noise(vec2(qf*.22+wtime,q.z*.22)) * 2.;\n        q.y += nz+nz*sin(q.z*.55);\n        q.y += nz+nz*cos(q.x*.35);\n        float d = box(q+vec3(0.,3.25,0.),vec3(.125,.25,50.));\n        d=max(d,-(p.y+6.4));\n        \n        if(d<res.x){\n            res = vec2(d,1.);\n            hitPoint = q+vec3(qf,qf,float(i));\n            gid = vec3(qf,nz,float(i));\n            if(sg==1. && mod(qf,6.)==0.) glow += .001/(.0005+d*d);\n        }\n        \n    }\n\n    float fl = p.y+6.5;\n    if(fl<res.x){\n        res=vec2(fl,2.);\n        hitPoint=p;\n    }\n    return res;\n}\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e,0.).x+\n             h.yyx * map(p+h.yyx*e,0.).x+\n             h.yxy * map(p+h.yxy*e,0.).x+\n             h.xxx * map(p+h.xxx*e,0.).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int maxsteps, float sg){\n\tfloat d = 0.;\n    float m = 0.;\n    for(int i=0;i<maxsteps;i++){\n    \tvec2 ray = map(ro + rd * d, sg);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += i<42?ray.x*.4:ray.x;\n        m  = ray.y;\n    }\n\treturn vec2(d,m);\n}\n\n// Tri-Planar blending function. GPU Gems 3 - Ryan Geiss:\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    n = max(abs(n), MIN_DIST);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\nvec4 FC = vec4(0.019,0.019,0.019,0.);\n\nvec3 hue(float t){ \n    const vec3 c = vec3(0.757,0.110,0.992);\n    return .65 + .45*cos(13.+PI2*t*(c*vec3(0.959,0.970,0.989))); \n}\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec2 ray = marcher(ro,rd,150, 1.);\n    hitPoint = hit;\n    sid=gid;\n    d = ray.x;\n    float m = ray.y;\n    float alpha = 0.;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(1.,11,-3.);\n        vec3 l = normalize(lpos-p);\n        \n        vec3 h = vec3(.5);\n        vec3 hp = hitPoint;\n\n        float diff = clamp(dot(n,l),0.,1.);\n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 9.);\n        fresnel = mix(.01, .7, fresnel);\n\n        float shdw = 1.0;\n        for( float t=.01; t < 10.; )\n        {\n            float h = map(p + l*t,0.).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 18.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n\n        diff = mix(diff,diff*shdw,.75);\n\n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec = 0.3 * pow(max(dot(view, ret), 0.), 20.);\n        \n        vec3 clr = hue(sid.x*.1+sid.y)*.35;\n        // materials\n        if(m==1.){\n            h= mod(sid.x,6.)==0. ? clr : tex3D(iChannel0,hp*.1,n).rgb*clr;\n            \n            ref = h-fresnel;\n            C = (diff*h)+spec;\n        }\n        if(m==2.){\n            h=texture(iChannel0,hp.xz*.1).rgb;\n            ref = vec3(1.)-fresnel;\n            C = (diff*h)+spec;\n        }\n\n        C = mix(FC.rgb,C,exp(-.00015*d*d*d));\n        ro = p+n*.01;\n        rd = reflect(rd,n);\n        C+=clamp(glow,0.,.95)*clr;\n    } \n    return vec4(C,alpha);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    float T2 = T*2.;\n    float rrt = T2*PI/180.;\n    wtime=T*.1;\n    speed = vec3(T2,0,5.*sin(T*.25));\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,.25,1.5);\n    vec3 rd = normalize(vec3(uv,-1));\n    \n    //camera\n    mat2 rx = rot(.75), ry = rot(rrt);\n    \n    ro.yz *= rx, ro.xz *= ry;\n    rd.yz *= rx, rd.xz *= ry;\n\n    // reflection loop (@BigWings)\n    vec3 C = vec3(0);\n    vec3 ref=vec3(0), fil=vec3(1);\n    float d =0.;\n    float numBounces = 2.;\n    for(float i=0.; i<numBounces; i++) {\n        vec4 pass = render(ro, rd, ref, i==numBounces-1., d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n        if(i==0.) FC = vec4(FC.rgb,exp(-.000015*d*d*d));\n    }\n    C = mix(C,FC.rgb,1.-FC.w);\n    C = clamp(C,vec3(.01),vec3(1));\n    //C=pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n\n\n", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXSRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[180, 180, 237, 237, 830]], "test": "untested"}
{"id": "flXXzB", "name": "\"Best\" hash Int - wang, lowbias", "author": "tigrazone", "description": "from Chris Wellons [url]https://nullprogram.com/blog/2018/07/31/[/url] \n( thanks for this ref that was raised... I don't remember in which discussion ! :-) )\n\nNote that it might not be costlier than the infamous fract(big*sin(big*x)) ;-) ", "tags": ["hash"], "likes": 4, "viewed": 263, "published": 3, "date": "1625919095", "time_retrieved": "2024-07-30T19:11:33.501056", "image_code": "// --- from Chris Wellons https://nullprogram.com/blog/2018/07/31/\n// Note that it might not be costlier than the infamous fract(big*sin(big*x)) ;-) \n\n        // --- choose one:\n#define hashi(x)   lowbias32(x)\n  //#define hashi(x)   triple32(x) \n//  #define hashi(x)   wang(x)\n\n  #define hash(x)  ( float( hashi(x) ) / float( 0xffffffffU ) )\n\n//bias: 0.17353355999581582 ( very probably the best of its kind )\nuint lowbias32(uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\n// bias: 0.020888578919738908 = minimal theoretic limit\nuint triple32(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\nuint wang(uint v)\n{\n    v = (v ^ 61u) ^ (v >> 16u);\n    v *= 9u;\n    v ^= v >> 4u;\n    v *= 0x27d4eb2du;\n    v ^= v >> 15u;\n    return v;\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    uvec2 V = uvec2(U);\n    float h = hash( V.x + hashi(V.y) ); // clean 2D hash\n  //float h = hash( V.x + (V.y<<16) );  // 2D hash (should be ok too )\n    O = vec4( h );\n  //O = vec4( pow( h, 1./2.2) );        // sRGB conversion\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flXXzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[343, 410, 434, 434, 548], [550, 606, 629, 629, 783], [785, 785, 804, 804, 924], [926, 926, 964, 964, 1196]], "test": "untested"}
{"id": "ftXXzS", "name": "pnpolyTest", "author": "MrOkiDoki", "description": "Test", "tags": ["polygon"], "likes": 5, "viewed": 268, "published": 3, "date": "1625892659", "time_retrieved": "2024-07-30T19:11:34.258032", "image_code": "\n//Taken by http://www.eecs.umich.edu/courses/eecs380/HANDOUTS/PROJ2/InsidePoly.html by Randolph Franklin\n\n\nconst vec2[] Points = vec2[] (\nvec2(0.91,4.52),\nvec2(2.6,5),\nvec2(2.56,-0.61),\nvec2(-2.16,-0.07),\nvec2(-3.43,4.46),\nvec2(-0.78,0.29),\nvec2(-0.84,5.65),\nvec2(0.1,.87),\nvec2(1.71,.87)\n);\n\nconst int count = 9;\n\nfloat pnpoly(vec2 p)\n{\n    int i, j;\n    float c = 0.0;\n    for (i = 0, j = count - 1; i < count; j = i++)\n    {\n        if ((((Points[i].y <= p.y) && (p.y < Points[j].y)) || ((Points[j].y <= p.y) && (p.y < Points[i].y))) && (p.x < (Points[j].x - Points[i].x) * (p.y - Points[i].y) / (Points[j].y - Points[i].y) + Points[i].x))\n        c = 1.0f - c;\n         \n    }\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv *= 7.;\n    uv += vec2(-3.5,-1.);\n\n    // Time varying pixel color\n    float col = pnpoly(uv);\n\n    // Output to screen\n    fragColor = vec4(vec3(col),1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXXzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[316, 316, 338, 338, 697], [699, 699, 756, 806, 1012]], "test": "untested"}
{"id": "stsXD7", "name": "大龙猫 - Heat Dome", "author": "totetmatt", "description": "Heat Dome \n[Updated to spare some cycle]", "tags": ["lava", "heat", "dome"], "likes": 18, "viewed": 456, "published": 3, "date": "1625868988", "time_retrieved": "2024-07-30T19:11:35.009025", "image_code": "mat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nvec2 sdf(vec3 p){\n    p.y+=3.;\n    float gr = 1.;\n   float zz;\n   vec4 pp = vec4(p,1.1);\n   for(float i=0.;i<=5.;i++){\n         pp.xyz = abs(pp.xyz)-.77;\n      pp.y+=1.;\n      pp.z+=.41;\n         pp*=1.2;\n       zz=abs(gr*atan(pp.x,pp.z)*.05);\n      float t = .5;\n         pp.xz *=rot(.785*.5+i+t);\n         \n         gr = min(gr, (atan(sin(pp.z+pp.y))-sin(pp.x*.2)+cos(pp.z*.5))/pp.a);\n      \n     \n      \n    }\n    \n    vec2 h;\n    gr += texture(iChannel0,vec2(gr*.5)).r*.1;\n    h.x = dot(p,vec3(0.,1.,0.))-gr;\n    \n    h.y = 1.-zz;\n    \n    vec2 t;\n    vec3 ppp=p;\n    ppp.y+=1.;\n \n    t.x  = abs(length(ppp)-3.)-(.1-gr*.2-abs(sin(p.y*2.)*cos(gr*atan(p.x,p.z)*5.))*.1);\n    t.x  = max(.7*t.x,-dot(p,vec3(0.,1.,0.)));\n    \n    t.y = 2.;\n    h = t.x < h.x ? t:h;\n    return h;\n}\n\n#define q(s) s*sdf(p+s).x\nvec2 nv=vec2(-.003,.003);\nvec3 norm(vec3 p){return normalize(q(nv.xyy)+q(nv.yxy)+q(nv.yyx)+q(nv.xxx));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n vec2 uuv =uv;\n  uuv *=.25;\n\n\tvec3 col = vec3(.1);\n  \n  vec3 ro = vec3(5.*cos(iTime*.05),-1.,5.*sin(iTime*.05));\n  vec3 rt = vec3(0.,-3.,0.);\n  vec3 z = normalize(rt-ro);\n  vec3 x = normalize(cross(z,vec3(0.,-1.,.0)));\n  vec3 y = normalize(cross(z,x));\n  \n  vec3 rd = mat3(x,y,z)*normalize(vec3(uv,1.));\n  vec3 rp = ro;\n  vec3 light = vec3(1.,0.,-3.);\n  \n  vec3 acc = vec3(0.);\n  bool inside = false;\n  float rpt = 0.;\n  for(float i=0.;i<=128.;i++){\n   \n      vec2 d = sdf(rp);\n       if(inside) d.x = -d.x;\n    rpt +=d.x;\n      if(rpt >=50.)break;\n      if(d.y <=.96){\n        acc += vec3(1.,.2,.1)*max(0.,exp(.5*-abs(d.x))/(20.-sin(iTime*4.+rp.x*5.+rp.z)*10.));\n      }\n      rp+=d.x*rd;\n      if(d.x <=0.001){\n          vec3 n = norm(rp);\n          if(d.y<=1.){\n            \n            vec3 di = vec3(.2)*max(0.,dot(normalize(light-rp),n));\n            vec3 sp = vec3(1.)*(acc/i)* pow(max(dot(reflect(normalize(-light),n),-rd),0.),20.);\n            col = di+sp*20.;\n            break;\n          } else if(d.y ==2.){\n              float ior = 1.05;\n              if(!inside){\n                \n                 acc +=vec3(.2,.001,.001);\n                rd = refract(rd,n,1./ior);\n                rp -= .05*n;\n                inside = true;\n              } else {\n                    n = -n;\n                    vec3 _rd=refract(rd,n,ior);\n                    if(dot(_rd,_rd)==0.){\n                      \n                        rd = reflect(rd,n);\n                        rp +=n*.05;\n                      \n                    } else {\n                        rd = _rd;\n                        rp -=n*.05;\n                        inside = false;\n                       acc +=vec3(.1,.11,.1);\n                      }\n              }\n          }\n      }\n  }\n  col +=acc;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stsXD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 65], [66, 66, 83, 83, 845], [899, 899, 917, 917, 976], [978, 978, 1035, 1085, 2948]], "test": "untested"}
{"id": "7tsXW7", "name": "iChannel texture - 004", "author": "catafest", "description": "This is a simple sine distortion with parameters : distance, amplitude and angular_frequency.\nThis example can explain some parts from spatial frequency theory.\nhttps://en.wikipedia.org/wiki/Spatial_frequency\n", "tags": ["texture", "sine", "ichannel", "angularfrequency"], "likes": 6, "viewed": 580, "published": 3, "date": "1625859282", "time_retrieved": "2024-07-30T19:11:35.757025", "image_code": "//https://en.wikipedia.org/wiki/Spatial_frequency\n//PI constant\n#define PI 3.14159265358979\n\n#define distance 0.6 \n\n#define amplitude 7.0\n\n#define angular_frequency 7.0\n\nfloat sine_wave(float t)\n{\n    return amplitude*(sin(angular_frequency * PI*t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy/ iResolution.xy;\n    \n    vec2 CENTER = uv/2.0;\n    \n    uv += CENTER;      \n    \n    float len = length(uv);\n   \n    float corr = sine_wave( len-iTime );\n    \n    uv =  CENTER* ( len*distance + corr * clamp(CENTER.x, 0.0, CENTER.y ));\n     \n    fragColor = texture(iChannel0, uv);\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tsXW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[170, 170, 196, 196, 252], [254, 254, 311, 311, 619]], "test": "untested"}
{"id": "NtSGDm", "name": "texture schlorping", "author": "elenzil", "description": "started on a particle system thing, got texture schlorping.", "tags": ["automata"], "likes": 3, "viewed": 275, "published": 3, "date": "1625842286", "time_retrieved": "2024-07-30T19:11:36.519985", "image_code": "void mainImage( out vec4 RGBA, in vec2 XY )\n{\n    \n    RGBA = texelFetch(iChannel0, ivec2(XY), 0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 RGBA, in vec2 XY )\n{\n    if (iFrame < 2) {\n        RGBA = texelFetch(iChannel1, ivec2(XY), 0);\n        return;\n    }\n    \n    ivec2 IJ = ivec2(XY);\n    \n    vec2 UV = XY/iResolution.xy;\n    \n    vec4 tnoise = texelFetch(iChannel0, IJ % ivec2(iChannelResolution[0].xy), 0);\n    vec3 noiseHSV = rgb2hsv(tnoise.rgb);\n    \n    float theta = noiseHSV.x * PI * 2.0;\n    theta += iTime * 0.5;\n    vec2 offsetDir = rot2(theta) * vec2(1.0, 0.0);\n    vec2 offset = offsetDir * (1.0 - noiseHSV.x);\n   // offset *= 2.0;\n\n    vec4 prev   = textureLod(iChannel1, UV + offset / iResolution.xy, 0.0);\n    \n    float mixAmt = (iFrame - 2) % 800 == 0 ? 1.0 : 0.0;\n    \n    RGBA  = mix(prev, tnoise, mixAmt);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//------------------------------------------------------\n\nconst float PI = 3.14159265359;\n\n//------------------------------------------------------\n\n// https://gist.github.com/983/e170a24ae8eba2cd174f\nvec3 rgb2hsv(in vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(in vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//------------------------------------------------------\n\n\nmat2 rot2(in float radians) {\n    float c = cos(radians);\n    float s = sin(radians);\n    return mat2(c, s, -s, c);\n}", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 c;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    const int cases = 3;\n    switch((iFrame / (cases * 100)) % cases) {\n        case 0: {\n            float minRes = min(iResolution.x, iResolution.y);\n\n            vec2 p = (fragCoord - iResolution.xy / 2.0) / minRes * 2.0;\n\n            float h = atan(p.y, p.x) / PI / 2.0 + 0.5;\n            float v = length(p);\n            float s = sin(v * 20.0) * 0.2 + 0.8;\n\n            c = hsv2rgb(vec3(h, s, v));\n            break;\n        }\n        case 1: {\n            c = textureLod(iChannel0, uv, 0.0).rgb;\n            break;\n        }\n        case 2: {\n            c = textureLod(iChannel1, uv, 0.0).rgb;\n            break;\n        }\n    }\n    \n    fragColor = vec4(c, 1.0);\n\n}", "buffer_b_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 RGBA, in vec2 XY )\n{\n    if (iFrame < 5 || length(iMouse.xy) < length(iResolution.xy * 0.1)) {\n        RGBA = vec4(0.0);\n        return;\n    }\n\n    ivec2 IJ = ivec2(XY);\n    \n    vec3 dry = texelFetch(iChannel0, IJ, 0).rgb;\n   \n    vec2  vMouse = iMouse.xy - XY;\n    float dMouse = length(vMouse);\n    float aMouse = atan(vMouse.y, vMouse.x) / PI / 2.0 + 0.5;\n    \n    float h = aMouse - iTime * 0.1;\n    \n    vec3 wet = hsv2rgb(vec3(h, 1.0, 1.0));\n    \n    const float rad = 50.0;\n    const float eps =  4.0;\n    wet = mix(dry, wet, smoothstep(rad + eps, rad - eps, dMouse));\n    \n    \n    RGBA = vec4(wet, 1.0);    \n    \n}", "buffer_c_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtSGDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 100]], "test": "untested"}
{"id": "ftlSDM", "name": "Roblox sdf character", "author": "IDGAMER89", "description": "This is a sdf roblox character.", "tags": ["raymarch", "sdf", "sdf", "roblox", "roblox"], "likes": 3, "viewed": 430, "published": 3, "date": "1625807822", "time_retrieved": "2024-07-30T19:11:37.280950", "image_code": "#define deg2rad (3.141/360.)\n#define MAX_STEPS 100\n#define MAX_DIST 1e2\n#define SURF_DIST 1e-4\n\nfloat sphereSDF(vec3 p, float r){\n\treturn length(p)-r;\n}\n\nfloat cubeSDF(vec3 p, vec3 s) {\n    vec3 q = abs(p) - s;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat roundedCubeSDF(vec3 p, vec3 s, float r) {\n    vec3 q = abs(p) - s;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0)-r;\n}\n\nfloat roundedCylinderSDF( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat characterSDF(vec3 p){\n\tfloat d = roundedCylinderSDF(p, 0.3, 0.3, .3);//Head\n\td = min(d, roundedCubeSDF(p-vec3(0,-1.6,0), vec3(1,1,.5), .05));//Torso\n    //p.x = abs(p.x);\n\td = min(d, roundedCubeSDF(p-vec3(1.6,-1.6,0), vec3(0.5,1,.5), .05));//left arm\n\td = min(d, roundedCubeSDF(p-vec3(0.51,-3.7,0), vec3(0.46,1,.5), .05));//left leg\n\td = min(d, roundedCubeSDF(p-vec3(-1.6,-1.6,0), vec3(0.5,1,.5), .05));//right arm\n\td = min(d, roundedCubeSDF(p-vec3(-0.51,-3.7,0), vec3(0.46,1,.5), .05));//right leg\n    \n\treturn d;\n}\n\nfloat scene(vec3 p){\n\tfloat d = p.y+5.0;\n    d = min(d, characterSDF(p));\n\t\n\treturn d;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(SURF_DIST, 0.0);\n\n    return normalize(\n        scene(p) - vec3(\n            scene(p - e.xyy),\n            scene(p - e.yxy),\n            scene(p - e.yyx)\n        )\n    );\n}\n\nfloat AO(vec3 p) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    vec3 nor = GetNormal(p);\n    for(int i = 0; i < 5; i++) {\n        float h = 0.001 + 0.15*float(i)/4.0;\n        float d = scene(p + h*nor);\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        float dS = scene(ro + rd * dO);\n        dO += dS;\n        if(dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    return dO;\n}\n\nmat3 rot(vec3 ang) {\n    vec3 s = sin(ang);\n    vec3 c = cos(ang);\n    mat3 x = mat3(\n        vec3(1, 0, 0),\n        vec3(0, c.x,-s.x),\n        vec3(0, s.x, c.x)\n    );\n    mat3 y = mat3(\n        vec3(c.y, 0, s.y),\n        vec3(0, 1, 0),\n        vec3(-s.y, 0, c.y)\n    );\n    mat3 z = mat3(\n        vec3(c.z, s.z, 0),\n        vec3(-s.z, c.z, 0),\n        vec3(0, 0, 1)\n    );\n    return x*y*z;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord.xy-0.5*iResolution.xy)/max(iResolution.x, iResolution.y)*2.;\n\tvec3 ro = vec3(0, 0, -5);\n    vec3 rd = normalize(vec3(uv, 75.*deg2rad));\n\n    vec2 t = (iMouse.xy-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n    t *= 4.0;\n    vec2 mouse_rotation = t*2.;\n    //if(length(touch.xy) < 1e-3) mouse_rotation = vec2(0);\n\n    vec2 yawpitch = vec2(mouse_rotation.x, -mouse_rotation.y);\n    mat3 viewmat = rot(vec3(yawpitch.y, yawpitch.x, 0));\n\n    ro *= viewmat;\n    rd *= viewmat;\n\n    float d = RayMarch(ro, rd);\n    vec3 p = ro + rd * d;\n    vec3 col = vec3(0);\n\n    if(d < MAX_DIST){\n    \tvec3 lp = normalize(vec3(0,5,-3));\n    \tvec3 n = GetNormal(p);\n\t\tcol = vec3(smoothstep(-0.2,1.,dot(n, lp)));\n        float s = RayMarch(p+n*SURF_DIST*2.0, lp);\n        col *= AO(p); \n\t\tif(s < length(lp-p)) col *= vec3(.5);\n    }else{\n        col = texture(iChannel0, rd.zyx).rgb;\n    }\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftlSDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 129, 129, 152], [154, 154, 185, 185, 280], [282, 282, 329, 329, 426], [428, 428, 493, 493, 610], [612, 612, 639, 639, 1134], [1136, 1136, 1156, 1156, 1224], [1226, 1226, 1250, 1250, 1441], [1443, 1443, 1461, 1461, 1743], [1745, 1745, 1779, 1779, 1972], [1974, 1974, 1994, 1994, 2368], [2371, 2371, 2426, 2426, 3362]], "test": "untested"}
{"id": "NtsSWM", "name": "Demo Noise Dissolve", "author": "MacLin", "description": "Demo Noise Dissolve", "tags": ["test"], "likes": 2, "viewed": 296, "published": 3, "date": "1625800935", "time_retrieved": "2024-07-30T19:11:38.027953", "image_code": "float dist()\n{\n    return iMouse.z > 0.0 ? iMouse.x / iResolution.x : max(sin(iTime / 4.0 * 2.0 * 3.14), 0.0);\n}\n\nfloat threshold(in vec2 uv )\n{\n    return step(texture(iChannel0, uv).r, dist());\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel1, uv).rgb * threshold(uv);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsSWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 14, 14, 112], [114, 114, 144, 144, 197], [199, 199, 256, 306, 497]], "test": "untested"}
{"id": "7tlSW4", "name": "Light With Object", "author": "oneshade", "description": "Testing in a simple scene with a rotating box. I'm really missing a volumetric shadow! I think that will go on my todo list. Control the light with the mouse.", "tags": ["3d", "illumination", "light", "volumetric", "integration"], "likes": 11, "viewed": 210, "published": 3, "date": "1625792094", "time_retrieved": "2024-07-30T19:11:38.782934", "image_code": "float getIllumination(in vec3 p, in float k, in float d) {\n    return k / (1.0 + dot(p, p) / (d * d));\n}\n\n// Short range (up to oclluder at t)\nfloat volumeLightPartial(in vec3 ro, in vec3 rd, in float k, in float d, in float t) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) + d * d;\n    float h = sqrt(c - b * b), r = b / h;\n    return d * d * k * (atan(t / h + r) - atan(r)) / h;\n}\n\n// Infinite range\nfloat volumeLightFull(in vec3 ro, in vec3 rd, in float k, in float d) {\n    const float rho = 1.57079632679;\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) + d * d;\n    float h = sqrt(c - b * b);\n    return d * d * k * (rho - atan(b / h)) / h;\n}\n\nfloat iSphere(in vec3 ro, in vec3 rd, in float r) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - r * r;\n    float h = sqrt(b * b - c);\n    if (h < 0.0) return -1.0;\n    return -b - sqrt(h);\n}\n\n// Modified from https://iquilezles.org/articles/intersectors\nfloat iBox(in vec3 ro, in vec3 rd, in vec3 boxSize, out vec3 outNormal)  {\n    vec3 n = ro / rd;\n    vec3 k = boxSize / abs(rd);\n    vec3 q = abs(ro) - boxSize;\n    vec3 t1 = -k - n, t2 = +k - n;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if (tN > tF || tF < 0.0) return -1.0;\n    outNormal = -sign(rd) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n    return mix(tN, tF, step(0.0, -max(q.x, max(q.y, q.z))));\n}\n\n// Camera matrix\nmat3 getCamera(in vec2 viewDir) {\n    vec2 c = cos(viewDir); vec2 s = sin(viewDir);\n    return mat3(       c.x, 0.0,         s.x,  // Right\n                s.x * -s.y, c.y, -c.x * -s.y,  // Up\n                s.x *  c.y, s.y, -c.x *  c.y); // Forward\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y;\n    fragColor = vec4(0.0);\n\n    // Camera ray\n    mat3 cam = getCamera(vec2(0.65, 0.0));\n    vec3 ro = vec3(-2.0, 0.0, 4.5);\n    vec3 rd = normalize(cam * vec3(uv, 1.0));\n\n    // Light control\n    float k = 0.8 + 0.1 * cos(iTime), d = 0.5;\n    vec3 lightColor = vec3(1.0, 0.75, 0.15);\n\n    vec3 lightPos = vec3(0.0);\n    if (iMouse.z > 0.0) {\n        vec3 md = normalize(cam * vec3(mouse, 1.0));\n        lightPos = ro - vec3(md.xy * ro.z / md.z, ro.z);\n    }\n\n    // Box control\n    vec3 boxSize = vec3(1.0), boxNor;//, dummy;\n    vec3 boxPos = vec3(3.0, 0.0, 0.0);\n\n    mat3 boxRot = mat3(1.0); // Identity\n    float c = cos(iTime), s = sin(iTime);\n    boxRot *= mat3(c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c); // XZ rotation\n    boxRot *= mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c); // YZ rotation\n\n    // Intersect box\n    vec3 roBox = (ro - boxPos) * boxRot;\n    vec3 rdBox = rd * boxRot;\n    float tBox = iBox(roBox, rdBox, boxSize, boxNor);\n\n    if (tBox > 0.0) {\n        vec3 hitPos = ro + rd * tBox;\n        boxNor = boxRot * boxNor;\n\n        // Lighting\n        vec3 lightDir = normalize(lightPos - hitPos);\n        float diff = max(0.0, dot(lightDir, boxNor));\n        float illum = clamp(getIllumination(hitPos - lightPos, k, d), 0.0, 1.0) * diff * 10.0;\n        float scatterLight = volumeLightPartial(ro - lightPos, rd, k, d, tBox);\n        //if (iBox((hitPos + lightDir * 0.001 - boxPos) * boxRot, lightDir * boxRot, boxSize, dummy) > 0.0) illum = 0.0, scatterLight = 0.0;\n\n        float checkers = 0.5 + 0.5 * mod(dot(floor((roBox + rdBox * tBox) * 2.0 + 0.001), vec3(1.0)), 2.0);\n        fragColor.rgb += vec3(1.0, 0.0, 0.0) * checkers * lightColor * illum;\n        fragColor.rgb = mix(fragColor.rgb, lightColor, clamp(scatterLight, 0.0, 1.0));\n    }\n\n    else {\n        fragColor.rgb += volumeLightFull(ro - lightPos, rd, k, d) * lightColor;\n    }\n\n    float tSphere = iSphere(ro - lightPos, rd, 0.1);\n    if (tSphere > 0.0 && (tBox > 0.0 ? (tSphere < tBox) : true)) {\n        fragColor.rgb = 2.0 * lightColor;\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlSW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 104], [106, 143, 229, 229, 391], [393, 411, 482, 482, 662], [664, 664, 715, 715, 865], [867, 929, 1003, 1003, 1388], [1390, 1407, 1440, 1440, 1659], [1661, 1661, 1716, 1716, 3895]], "test": "untested"}
{"id": "stXXWM", "name": "Glitching Robot Character", "author": "intrakits", "description": "I was playing around with making a robot character and wanted too see what kind of emotes I could give him.", "tags": ["robot"], "likes": 1, "viewed": 270, "published": 3, "date": "1625769864", "time_retrieved": "2024-07-30T19:11:39.637649", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST 0.01\n#define AA 1\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nvec2 rand2(vec2 p)\n{\n\tvec2 q = vec2(dot(p,vec2(127.1,311.7)), \n\t\tdot(p,vec2(269.5,183.3)));\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat rand(vec2 p)\n{\n\treturn fract(sin(dot(p,vec2(419.2,371.9))) * 833458.57832);\n}\n\nfloat iqnoise(in vec2 pos, float irregular, float smoothness)\n{\n\tvec2 cell = floor(pos);\n\tvec2 cellOffset = fract(pos);\n\n\tfloat sharpness = 1.0 + 63.0 * pow(1.0-smoothness, 4.0);\n\t\n\tfloat value = 0.0;\n\tfloat accum = 0.0;\n\t// Sample the surrounding cells, from -2 to +2\n\t// This is necessary for the smoothing as well as the irregular grid.\n\tfor(int x=-2; x<=2; x++ )\n\tfor(int y=-2; y<=2; y++ )\n\t{\n\t\tvec2 samplePos = vec2(float(y), float(x));\n\n  \t\t// Center of the cell is not at the center of the block for irregular noise.\n  \t\t// Note that all the coordinates are in \"block\"-space, 0 is the current block, 1 is one block further, etc\n\t\tvec2 center = rand2(cell + samplePos) * irregular;\n\t\tfloat centerDistance = length(samplePos - cellOffset + center);\n\n\t\t// High sharpness = Only extreme values = Hard borders = 64\n\t\t// Low sharpness = No extreme values = Soft borders = 1\n\t\tfloat sam = pow(1.0 - smoothstep(0.0, 1.414, centerDistance), sharpness);\n\n\t\t// A different \"color\" (shade of gray) for each cell\n\t\tfloat color = rand(cell + samplePos);\n\t\tvalue += color * sam;\n\t\taccum += sam;\n\t}\n\n\treturn value/accum;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    //line from a to b\n    vec3 ab = b-a;\n    \n    // line from p to a\n    vec3 ap = p-a;\n    \n    // as p approaches a, it will be 1\n    // as p approaches b it will b 0\n    float t = dot(ab,ap) / dot(ab,ab);\n    \n    // clamp values between 0 and 1\n    t= clamp(t,0.,1.);\n    \n    // center point of the capsule\n    // start at a (top of capsule)\n    // go towards b, t steps\n    vec3 c = a + t*ab;\n    \n    float d = length(p-c)-r;\n    \n    return d;\n}\n\nfloat sdTorus(vec3 p, vec2 r){\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.));\n}\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n  p = abs(p);\n  vec2 b = vec2(la,lb);\n  float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n  vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\nvec2 colMin(vec2 res, vec2 obj){\n    res.x = min(obj.x,res.x);\n    if(obj.x == res.x){\n        res.y = obj.y;\n    }\n    return res;\n}\n// https://iquilezles.org/articles/smin\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\nfloat getDisp(vec2 uv){\n\n    vec2 p = 0.5 - 0.5*sin(vec2(1.01,1.71) );\n    p = vec2(1.0, 1.0);\n\t\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\t\n\tfloat f = iqnoise(24.0*uv, p.x, p.y);\n\t\n\treturn f;\n}\nvec2 GetDist(vec3 p){\n    vec3 hPos = p;\n    hPos.y += pow(sin(iTime),2.)*.1;\n    hPos.xz *= Rot(.1*sin(.001*iTime/cos(iTime)));\n    //head\n    vec2 res = vec2(length(hPos-vec3(0,cos(abs(p.x+3.14159))+.5,0))-0.5,1);\n    vec2 ears = vec2(sdCylinder(hPos-vec3(0,-.5,0), vec3(-.6,0,0), vec3(.6,0,0), .1),1);\n    res = colMin(res,ears);\n    vec2 antennaBase = vec2(sdCylinder(hPos-vec3(0,-.5,0), vec3(-.55,0,0), vec3(.55,0,0), .2),1);\n    res = colMin(res,antennaBase);\n    vec2 antR = vec2(dBox(hPos-vec3(-.54,0,0), vec3(.005,.5,.2-(sin(p.y*p.y*.6)))),1);\n    res = colMin(res,antR);\n    vec2 antL = vec2(dBox(hPos-vec3(.54,0,0), vec3(.005,.5,.2-(sin(p.y*p.y*.6)))),1);\n    res = colMin(res,antL);\n    \n    //eyes\n    float blink = sin(iTime)*.04;\n    vec3 rotP = hPos-vec3(0,-.4,-0.3);\n    rotP.yz *= Rot(3.1415/2.);\n    vec2 sock = vec2(sdRhombus(rotP, .3, .1-blink, .2, .001),2);\n    \n    rotP = hPos-vec3(0,-.4,-0.4);\n    rotP.yz *= Rot(3.1415/2.);\n    vec2 sockM = vec2(sdRhombus(rotP, .2, .08-blink, .2, .001),2);\n    sock.x = opSmoothSubtraction(sockM.x,sock.x, .01);\n    res = colMin(res,sock);\n    \n    vec2 eye = vec2(sdRhombus(rotP, .1, .05-blink, .1, .001),3);\n    \n    res = colMin(res,eye);\n    \n    //body\n    vec3 bPos = p;\n    bPos.y += cos(0.001*iTime/sin(iTime))*.01;\n    vec2 body = vec2(length(bPos-vec3(0,5.*cos(abs(p.x+3.14159))+3.2,0))-0.5,1);\n    res = colMin(res,body);\n    return res;\n}\nvec2 RayMarch(vec3 ro, vec3 rd){\n    // distance from origin\n    vec2 dO=vec2(0.,0.);\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO.x*rd;\n        \n        // get distance to seam\n        vec2 ds = GetDist(p);\n        //move origin to new point\n        dO+=ds.x*.5;\n        if(ds.x < SURFACE_DIST){\n            dO.y = ds.y;\n            break;\n        }\n        else if( dO.x > MAX_DIST){\n            dO.y= -1.;\n            break;\n        }\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    //distance to point being analyzed\n    float d = GetDist(p).x;\n    \n    //distance to another point along the objects surface that is closeby\n    vec2 e = vec2(0.01,0);\n    \n    //slope between the two points\n    //note: swizzel is the .xxy or .yyx etc\n    vec3 n = d - vec3(\n         GetDist(p-e.xyy).x,\n         GetDist(p-e.yxy).x,\n         GetDist(p-e.yyx).x);\n         \n    return normalize(n);\n    \n}\nfloat GetLight(vec3 p){\n    //position of the light source\n    vec3 lightPos = vec3(0,5,-5);\n    \n    lightPos.xz += vec2(sin(iTime),cos(iTime));\n    //light vector\n    vec3 l = normalize(lightPos-p);\n    \n    //normal of object\n    vec3 n = GetNormal(p);\n    \n    // dot product of the light vector and normal of the point\n    // will give us the amount of lighting to apply to the point\n    // dot() evaluates to values between -1 and 1, so we will clamp it\n    float diff = clamp(dot(n, l),0.,1.);\n    \n    // calculate if point should be a shadow:\n    // raymarch from point being calculated towards light source\n    // if hits surface of something else before the light,\n    // then it must be obstructed and thus is a shadow\n    // the slight offset \"p+n*SURFACE_DIST*1.1\" is needed to ensure the\n    // break condistions in the function are not met too early\n    float d = RayMarch(p+n*SURFACE_DIST*1.1,l).x;\n    if(d < length(lightPos-p)){\n        diff *= 0.1;\n    }\n    return diff;\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nvec3 headCol(vec3 p, vec3 n, vec3 rd){\n        vec3 colXZ = texture(iChannel0, p.xz*.5+.5).rgb;\n        vec3 colXY = texture(iChannel0, p.xy*.5+.5).rgb;\n        vec3 colYZ = texture(iChannel0, p.yz*.5+.5).rgb;\n        \n        vec3 refl = texture(iChannel1, rd).rgb;\n        refl= refl*abs(n.y) + refl*abs(n.z) + refl*abs(n.x);\n        vec3 metal = colXZ*abs(n.y) + colXY*abs(n.z) + colYZ*abs(n.x);\n        metal= mix(smoothstep(0.6,.8,metal.r)*refl*5.,metal,.8);\n        return metal;\n\n\n}\n/*\nvec3 decCol(vec3 p, vec3 n, vec3 rd){\n        vec3 colXZ = texture(iChannel0, p.xz*.5+.5).rgb;\n        vec3 colXY = texture(iChannel0, p.xy*.5+.5).rgb;\n        vec3 colYZ = texture(iChannel0, p.yz*.5+.5).rgb;\n        \n        vec3 refl = texture(iChannel2, rd).rgb;\n        refl= refl*abs(n.y) + refl*abs(n.z) + refl*abs(n.x);\n        vec3 metal = colXZ*abs(n.y) + colXY*abs(n.z) + colYZ*abs(n.x);\n        metal= mix(smoothstep(0.7,.8,metal.r)*refl*5.,metal,.7);\n        return metal;\n\n}\nvec3 poleCol(vec3 p, vec3 n, vec3 rd){\n        vec3 colXZ = texture(iChannel3, p.xz*.5+.5).rgb;\n        vec3 colXY = texture(iChannel3, p.xy*.5+.5).rgb;\n        vec3 colYZ = texture(iChannel3, p.yz*.5+.5).rgb;\n        \n        vec3 refl = texture(iChannel2, rd).rgb;\n        refl= refl*abs(n.y) + refl*abs(n.z) + refl*abs(n.x);\n        vec3 metal = colXZ*abs(n.y) + colXY*abs(n.z) + colYZ*abs(n.x);\n        //metal= mix(smoothstep(0.7,.8,metal.r)*refl*5.,metal,.7);\n        return metal;\n\n}*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n   \n    \n    //camera\n    //-----------------\n    // ray origin\n    //controls position\n    vec3 ta = vec3( 0, -1, .5);\n    vec3 ro = ta + vec3( 4.5*cos(7.0*mo.x), 1.3 + 2.0*mo.y, 4.5*sin(7.0*mo.x) );\n    mat3 ca = setCamera( ro, ta, 0.0 );\n//    vec3 ro = vec3(0,3,-5);\n\n    \n    //ray dir\n    //controls rotation\n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 pt = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 pt = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n    vec3 rd = ca * normalize( vec3(pt,2.5) );\n    //------------------\n    vec2 d = RayMarch(ro,rd);\n    \n    // position of point\n    // start at ray origin\n    // move d units in the ray direction\n    vec3 p = ro + rd *d.x;\n    \n    //get diffuse lighting\n    float diff = GetLight(p);\n    vec3 col = vec3(0);\n    col = vec3(diff);\n    \n    vec3 n = GetNormal(p);\n    \n    if(d.y == 1.){\n        col *= headCol(p, n, rd);\n    }\n    else if(d.y==2.){\n       col *= vec3(0,0,0);\n    }\n    else if(d.y==3.){\n        col=vec3(1,0,0);\n    }\n    else if(d.y==4.){\n      //  col*=decCol(p, n, rd)*vec3(1,1,0);\n    }\n    else if(d.y==-1.){\n        col=texture(iChannel1, rd).rgb;\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stXXWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 112, 112, 140], [142, 142, 162, 162, 269], [271, 271, 291, 291, 354], [356, 356, 419, 419, 1469], [1471, 1471, 1490, 1490, 1552], [1553, 1553, 1604, 1604, 1888], [1890, 1890, 1939, 1962, 2395], [2397, 2397, 2427, 2427, 2498], [2500, 2500, 2527, 2527, 2566], [2567, 2567, 2631, 2631, 2882], [2883, 2883, 2915, 2915, 3016], [3017, 3057, 3095, 3095, 3192], [3194, 3234, 3275, 3275, 3347], [3348, 3348, 3406, 3406, 3507], [3508, 3508, 3531, 3531, 3726], [3727, 3727, 3748, 3748, 5137], [5138, 5138, 5170, 5198, 5711], [5712, 5712, 5735, 5774, 6145], [6146, 6146, 6169, 6204, 7139], [7140, 7140, 7192, 7192, 7369], [7370, 7370, 7408, 7408, 7859]], "test": "untested"}
{"id": "ftXSD7", "name": "EU flag ( 227 chars )", "author": "FabriceNeyret2", "description": "golfing  https://shadertoy.com/view/NtXSDM", "tags": ["flag", "2tweets", "europe", "golfing", "eu"], "likes": 3, "viewed": 256, "published": 3, "date": "1625758733", "time_retrieved": "2024-07-30T19:11:40.510315", "image_code": "// golfing  https://shadertoy.com/view/NtXSDM\n\n/**/ // -7 chars by Xor\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2   R = iResolution.xy;\n           U -= .5*R;   \n    U -= cos(round( atan(U.x,U.y) * 1.91 ) / 1.91 + vec2(11,0)) * R.y/3.;\n        \n    O = vec4(.5,.3,-.3,0);\n    O = O.xxyx - O * clamp(\n                         length(U) * sin( 2.2+abs( mod(atan(U.yx,U),1.26 )-.628) ) - R/62.\n                        ,-1., 1. ).y;\n}  /**/\n\n\n\n\n\n\n\n/* -- 234 chars\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2   R = iResolution.xy;\n           U -= .5*R;   \n    U -= cos(round( atan(U.x,U.y) * 1.91 ) / 1.91 + vec2(11,0)) * R.y/3.;\n        \n    O = vec4(.5,.3,-.3,0);\n    O = O.xxyx - O * clamp(\n                         length(U) * sin( 2.2+abs( mod(atan(U.yx,U)*5.,6.28 )/5.-.628) ) -.016 * R\n                        ,-1., 1. ).y;\n}  /**/\n\n\n\n\n\n\n\n/** // --- 247 chars \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2   R = iResolution.xy,\n           U = ( u - .5*R) / R.y;   \n    U -= .33* cos(round( atan(U.x,U.y) * 1.91 ) / 1.91 + vec2(11,0));\n        \n    O = vec4(.5,.5,.3,1) - vec4(.5,.3,-.3,0) * \n             clamp(\n                        ( length(U) * sin( 2.2+abs( mod(atan(U.x,U.y)*5.,6.28 )/5.-.628) ) -.016 ) *R.y\n                        ,-1., 1.);\n}  /**/\n\n\n\n\n\n\n\n/** // --- 250\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2   R = iResolution.xy,\n           U = ( u - .5*R) / R.y;   \n    U -= .33* cos(round( atan(U.x,U.y) * 1.91 ) / 1.91 + vec2(11,0));\n        \n    O = vec4(0,.2,.6,1) + vec4(1,.6,-.6,0)* \n             smoothstep( 1., -1., \n                        ( length(U) * sin( 2.2+abs( mod(atan(U.x,U.y)*5.,6.28 )/5.-.628) ) -.016 ) *R.y\n                       );\n}  /**/\n\n\n\n\n\n\n\n/** // --- 255 chars\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2   R = iResolution.xy,\n           U = ( u+u - R) / R.y;   \n    U -= .66* cos(round( atan(U.x,U.y) * 1.91 ) / 1.91 + vec2(11,0));\n        \n    O = mix( vec4(0,.2,.6,1), vec4(1,.8,0,1), \n             smoothstep( 1., -1., \n                        ( length(U) * sin( 2.2+abs( mod(atan(U.x,U.y)*5.,6.28 )/5.-.628) ) -.033 ) *R.y/2.\n           )           );\n}  /**/\n\n\n\n\n\n\n\n/** // --- 279 chars\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2   R = iResolution.xy,\n           U = ( u+u - R) / R.y;   \n    float  d = fwidth(U.y), n = 1.91, // 12 / 2Pi,\n           a = round( atan(U.x,U.y) * n ) / n;\n    U -= .66* vec2(sin(a), cos(a));\n        \n    a = mod( atan(U.x,U.y)*5., 6.28 ) / 5. - .628; // 3.14/5.\n    a = length(U)*  sin(2.2+abs(a));  // 3.14*.7 \n\n    O = mix( vec4(0,.2,.6,1), vec4(1,.8,0,1), smoothstep(d, -d, a-.033 ) );\n} /**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXSD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 110, 110, 435]], "test": "untested"}
{"id": "stlSW4", "name": "Packed Object Pattern", "author": "Shane", "description": "A very basic packed object pattern using a less than sophisticated dart throwing algorithm.", "tags": ["circle", "circle", "bubble", "vector", "polygon", "pack", "pack", "packing", "dart", "throwing"], "likes": 54, "viewed": 887, "published": 3, "date": "1625757234", "time_retrieved": "2024-07-30T19:11:41.372012", "image_code": "/*\n\n    Packed Object Pattern\n    ---------------------    \n    \n    This is yet another packed object pattern using a simple but highly\n    inefficient dart throwing algorithm -- To be fair, it will get the\n    job done, but will take at least 20 seconds to form, which in GPU \n    time is an eternity.\n    \n    There was no particular reason for putting this together other than \n    boredom and fun. I started with Oneshade's \"Coral Growth\" demonstration \n    as a base, then added bits here and there until not much of the \n    original code was left, but it's basically the same thing.\n    \n    My main motivation was prettying up some random vector objects, so I\n    didn't bother much with the algorithm itself. Having said that, I at\n    least attempted to hurry things along by modifying things to \n    effectively shoot more darts. However, there are way more efficient \n    partitioning based strategies for producing these patterns.\n    \n    I much prefer to use the cube map faces for pre-rendered textures,\n    but I didn't here, plus I'm using all four channels, so changing \n    resolutions requires either hitting the back button or clicking the \n    mouse. By the way, there's a \"SHAPE\" define in the other tab that'll\n    allow for the rendering of different objects for anyone interested.\n    \n    \n    \n    Other Examples:\n    \n    // I loosely based this example on the following:\n    Expanding Coral Growth - Oneshade\n    https://www.shadertoy.com/view/sl2GDd\n    \n    // One of Fabrice's early attempts.\n    dart throwing / space filling 2b - Created by FabriceNeyret2 \n    https://www.shadertoy.com/view/ltVBRt\n    \n    // This is a much more sophisticated approach. Fizzer uses his brain,\n    // whereas I tend to hit things with a hammer and hope for the best. :D\n    Dart-Throwing with Gap-Search - Fizzer\n    https://www.shadertoy.com/view/3sSXW1 \n\n*/\n\n\n// I prefer the cleaner look, but some mild texturing is possible.\n//#define TEXTURE\n\n// Fake highlight shading. Things look cleaner without it.\n#define HIGHLIGHTS\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){\n    return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); \n}\n\n/*\n// IQ's line distace formula. \nfloat sdLine( in vec2 p, in vec2 a, in vec2 b ){\n\n\tp -= a, b -= a;\n\treturn length(p - b*clamp(dot(p, b)/dot(b, b), 0., 1.));\n}\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n   \n    // UV coordinates.\n    vec2 svUV = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    vec2 uv = rot2(-3.14159/3.5)*svUV - iTime/32.;\n    float sf = 1./iResolution.y;\n\n    // Some texture or buffer samples.\n    vec4 buf = texture(iChannel0, fract(uv));\n    vec4 bufSh = texture(iChannel0, fract(uv - vec2(-.005, -.015)));\n    vec4 bufLt = texture(iChannel0, fract(uv + 2.25*vec2(-.005, -.015)));\n    \n    \n    // Scene color -- Initiated to white.\n    vec3 col = vec3(1);\n    \n    \n    #ifdef TEXTURE\n    vec3 tx2 = texture(iChannel1, uv).xyz; tx2 *= tx2;\n    col = col*.6 + (col*1. + .1)*tx2;    \n    #endif\n    \n    \n    // Mild distance field based concentric background pattern.\n    float pat = (abs(fract(-buf.x*65.) - .5)*2. - .2)/130.;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, pat))*.25);\n    // Line pattern.\n    //float pat2 = (abs(fract((uv.x - uv.y)*65.) - .5)*2. - .35)/65.;\n    //col = mix(col, vec3(0), (1. - smoothstep(0., sf, pat2))*.35);\n    \n    \n    // Object coloring.\n    vec3 cCol = vec3(1,  hash21(buf.yz)*.1, hash21(buf.yz + .09)*.1);\n     \n     \n    // Texturing the objects.\n    #ifdef TEXTURE\n    vec2 qq = (fract(uv - buf.yz) - .5);\n    vec3 tx = texture(iChannel1, (qq/2./buf.w)*(1. + dot(qq, qq)/buf.w) - .5).xyz; tx *= tx;\n    tx = smoothstep(.1, .5, tx).xyz;\n    cCol = cCol*.6 + (cCol*1.2 + .1)*tx;\n    #endif\n    \n    // Outer and inner edge widths.\n    float ew = .005;\n    float ew2 = .008;\n    \n    // Bump. Not used.\n    //float b = max(-bufLt.x/(buf.w - ew2), 0.);\n \n \n    #ifdef HIGHLIGHTS\n    // Fake mild diffuse and fake specular highlights.\n    vec2 ep = buf.yz + normalize(vec2(.005, .015))*(buf.w*.35);\n    float pl = length(fract(uv - ep) - .5) - (buf.w*.7*.85);\n    //float pl = sHexS(fract(uv - ep) - .5, (buf.w*.4*.85), (buf.w*.4*.85)*.4);\n    cCol = mix(cCol, mix(cCol, vec3(1), .75), (1. - smoothstep(0., sf*12., pl))*.1);\n    ep = buf.yz + normalize(vec2(.005, .015))*(buf.w*.3);\n    pl = length(fract(uv - ep) - .5) - (buf.w*.15*.85);\n    //vec2 gg = abs(fract(uv - ep) - .5) - (buf.w*.15*.85);\n    //pl = -pl + max(gg.x, gg.y)*16.;\n    cCol = mix(cCol, mix(cCol, vec3(1), .75), (1. - smoothstep(0., sf*5., pl))*.35);\n    #endif\n \n    // Light edge color.\n    vec3 cCol2 = mix(cCol, vec3(1), .9);\n\n\n    /*\n    ////\n    // Polar lines on the outer rims. Interesting, but not this time. :)\n    vec2 pp = fract(uv - buf.yz) - .5;\n    float aa = atan(pp.x, pp.y)/6.2831;\n    float lnNum = floor(48.*6.2831*buf.w);\n    aa = (floor(aa*lnNum) + .5)/lnNum;\n    vec2 aPnt3 = rot2(aa*6.2831)*vec2(0, 1);\n    float pat3 = sdLine(pp, vec2(0), aPnt3) - .0025;\n    if(lnNum>3.)cCol2 = mix(cCol2, vec3(0), (1. - smoothstep(0., sf, pat3))*.3);\n    ////\n    */\n    \n\n    // Rendering the various shadow, edge, color layers, etc.\n    //\n    // Shadow.\n    col = mix(col, vec3(0),  (1. - smoothstep(0., sf*2., bufSh.x))*.4);\n    // Edges.\n    col = mix(col, vec3(0),  1. - smoothstep(sf, 0., -buf.x));\n    col = mix(col, cCol2,  1. - smoothstep(sf, 0., -buf.x - ew));\n    col = mix(col, vec3(0),  1. - smoothstep(sf, 0., -buf.x - ew2 - ew));\n    #ifdef HIGHLIGHTS\n    cCol += max(0.-(bufLt.x)/.25, 0.);\n    //cCol += b*b;\n    //cCol = mix(cCol, vec3(0), (1. - smoothstep(0., sf, pat2))*.35);\n    #endif\n    // The inner color layer.\n    col = mix(col, cCol,  1. - smoothstep(sf, 0., -buf.x - ew2 - ew*2.));\n    \n    \n    // Extra gradient based coloring.\n    uv = fragCoord/iResolution.xy;\n    col = mix(col, col.zyx, uv.y*.7 - .35);\n    \n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// The dart throwing algorithm.\n\n\n// Pattern shape: Circle: 0, Triangle: 1,  Square: 2, Polygon: 3\n// Changing this will require a reset with the mouse or back button.\n#define SHAPE 3\n\n// Put holes in the shapes.\n//#define ANULUS\n\n \n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  \n    //p = mod(p, 8.);\n    return fract(sin(mod(dot(p, vec2(127.619, 157.583)), 6.2831589))*43758.5453); \n}\n\n \n// I searched Shadertoy for a robust regular polygon routine and came across\n// the following example:\n//\n// Regular Polygon SDF - BasmanovDaniil\n// https://www.shadertoy.com/view/MtScRG\n//\n// To use the functions in more intensive scenes, some optimization would be\n// necessary, but I've left them in their original form to show the working.\n\nfloat Polygon(vec2 p, float vertices, float radius){\n\n    float segmentAngle = 6.2831853/vertices;\n    \n    float angleRadians = atan(p.x, p.y);\n    float repeat = mod(angleRadians, segmentAngle) - segmentAngle/2.;\n    float inradius = radius*cos(segmentAngle/2.);\n    float circle = length(p);\n    float x = sin(repeat)*circle;\n    float y = cos(repeat)*circle - inradius;\n\n    float inside = min(y, 0.);\n    float corner = radius*sin(segmentAngle/2.);\n    float outside = length(vec2(max(abs(x) - corner, 0.0), y))*step(0.0, y);\n    return inside + outside;\n}\n\n \n// Object distance field and central position based ID.\nvec4 object(in vec2 p, in float r, in vec2 id){\n\n    #if SHAPE == 0\n    float d = length(p) - r;\n    #ifdef ANULUS\n    // Effectively boring out holes in the shape.\n    d = abs(d + sqrt(r)*.1) - sqrt(r)*.1;\n    #endif\n    return vec4(d, id, r);\n    // Donuts... Doesn't look great, but it works.\n    //return vec4(abs(length(p) - r*.66) - r*.34, id, r);\n    #else\n    \n    #if SHAPE == 1\n    float vNum = 3.;\n    #elif SHAPE == 2\n    float vNum = 4.;\n    #else\n    float vNum = 3. + floor(hash21(id)*6.);\n    #endif\n    \n    p = rot2(hash21(id)*6.2831*4.)*p; \n    float d = Polygon(p, vNum, r - r*.2) - r*.2;\n    #ifdef ANULUS\n    // Effectively boring out holes in the shape.\n    d = abs(d + sqrt(r)*.1) - sqrt(r)*.1;\n    #endif\n    return vec4(d, id, r);\n    \n    #endif\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n \n \n    // Screen coordinates. Range: [0, 1].\n    vec2 uv = (fragCoord)/iResolution.xy;\n    \n    vec2 seed = vec2(1.618, 1)*mod(float(iFrame)*0.0127 + iDate.w, 256.);//iDate.w;\n    \n    // Set all data slots to one.\n    vec4 col = vec4(1);\n     \n    // After loading or hitting the mouse button, reset.\n    if(textureSize(iChannel0, 0).x<2 || iMouse.z>1.){\n          \n          fragColor = col;\n          return;\n    }\n    \n    // After the first frame, start filling the buffer.\n    if (iFrame>0) { \n    \n        // Closest object distance, ID and width at this pixel postion.\n        col = texture(iChannel0, uv);\n    \n        for(int i = min(0, iFrame); i<60; i++){\n\n            // Random object size.\n            float rad = hash21(seed + .021)*.12 + .05;\n\n            // Random canvas position.\n            vec2 rndPos = vec2(hash21(seed + .141), hash21(seed + .083));\n            // Object distance at the random start position.\n            vec4 dataRndPos = texture(iChannel0, fract(rndPos + .5));\n\n            for(int j=0; j<10; j++){            \n            \n                // If there's enough room to place the new object, do so. \n                if(dataRndPos.x>rad){ \n\n                        // Create the object at the new position.\n                        vec4 tmp = object(fract(uv - rndPos) - .5, rad, rndPos);\n                        // Compare it to the old closest object, then update if necessary.\n                        col = tmp.x<col.x? tmp : col;\n                        i = 1000;\n                        break;\n                }\n                // If there's not enough room, reduce the object size and try again.\n                rad *= .84;\n                \n                // Alternative: If there's not enough room, reduce size roughly half the time then\n                // try again. In theory, more large objects should result.\n                //if(hash21(seed + .071)<.5) rad *= .82;\n            }\n            \n            // If we've made it this far, we didn't get a hit, so update the\n            // seed and try at the next position.\n            seed = mod(seed + vec2(i*57, i)*.0123, 256.);\n\n        }\n    }\n    \n    fragColor = col;\n \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stlSW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2049, 2082, 2104, 2104, 2162], [2165, 2193, 2214, 2214, 2281], [2448, 2448, 2503, 2535, 6089]], "test": "untested"}
{"id": "NtfXDM", "name": "Flag From Down Under", "author": "dr2", "description": "Flag of Australia (derived from \"Union Jack Flag\")", "tags": ["flag", "dynamics", "physics", "wind", "unionjack", "australia"], "likes": 8, "viewed": 348, "published": 3, "date": "1625753052", "time_retrieved": "2024-07-30T19:11:42.609702", "image_code": "// \"Flag From Down Under\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Flag of Australia (derived from \"Union Jack Flag\")\n\n#define AA  1   // optional antialiasing\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec4 Loadv4 (vec2 vId);\n\nconst ivec2 nBallE = ivec2 (65, 33);\n\nconst int nsMax = 5000;\n\nvec3 sunDir;\nvec2 qgHit;\nfloat dstFar, tCur, todCur, spLen, szFac;\nconst float pi = 3.14159;\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nfloat SheetRay (vec3 ro, vec3 rd)\n{\n  vec3 r, q;\n  vec2 g;\n  float d, dMin, sz, szMax, szMin, grLen;\n  bvec2 ilt;\n  bool bkTrak;\n  grLen = 0.92 * spLen;\n  dMin = dstFar / (grLen * szFac);\n  ro /= szFac;\n  rd /= grLen;\n  szMax = float (nBallE.x - 1);\n  szMin = 1./32.;\n  sz = szMax;\n  g = vec2 (0.);\n  bkTrak = false;\n  for (int ns = VAR_ZERO; ns < nsMax; ns ++) {\n    if (sz == szMin) {\n      r = GetR (g) - ro;\n      q = cross (r, rd);\n      if (dot (q, q) < sz * sz) {\n        d = dot (r, rd);\n        if (d < dMin) {\n          dMin = d;\n          qgHit = g;\n        }\n      }\n      bkTrak = true;\n    }\n    q = cross (GetR (g + 0.5 * sz) - ro, rd);\n    bkTrak = bkTrak || (dot (q, q) > sz * sz);\n    if (bkTrak) {\n      bkTrak = false;\n      ilt = lessThan (fract (g / (2. * sz)), vec2 (0.5));\n      g.x += ilt.x ? sz : - sz;\n      if (! ilt.x) {\n        if (sz == 0.5 * szMax) break;\n        g.y += ilt.y ? sz : - sz;\n        if (! ilt.y) {\n          sz *= 2.;\n          if (sz == szMax) break;\n          bkTrak = true;\n        }\n      }\n    } else if (sz > szMin) sz *= 0.5;\n  }\n  return dMin * grLen * szFac;\n}\n\nvec3 GetRC (vec2 v)\n{\n  return GetR (clamp (v, vec2 (0.), vec2 (nBallE - 1)));\n}\n\nvec3 SheetNf () \n{\n  vec3 c;\n  vec2 e = vec2 (1., 0.);\n  c = GetRC (qgHit);\n  return normalize (cross (GetRC (qgHit + e.yx) - c, GetRC (qgHit + e) - c));\n}\n\nfloat SheetSilHit (vec3 ro, vec3 rd)\n{\n  vec3 blkSize, pMin, pMax, v, tm, tp;\n  float dn, df;\n  pMin = Loadv4 (vec2 (1, nBallE.y)).xyz;\n  pMax = Loadv4 (vec2 (2, nBallE.y)).xyz;\n  ro /= szFac;\n  ro -= 0.5 * (pMin + pMax);\n  blkSize = 0.5 * (pMax - pMin) + 0.5;\n  v = ro  / rd;\n  tp = blkSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  return (df > 0. && dn < df) ? szFac * dn : dstFar;\n}\n\nvec4 CylHit (vec3 ro, vec3 rd, float cylRad, float cylLen)\n{\n  vec3 s, vn;\n  float dMin, d, a, b, w, srdy;\n  dMin = dstFar;\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - cylRad * cylRad);\n  if (w > 0.) {\n    srdy = sign (rd.y);\n    if (a > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0.) {\n        d /= a;\n        s = ro + d * rd;\n      } else s.y = cylLen;\n    } else s.y = cylLen;\n    if (abs (s.y) < cylLen) {\n      dMin = d;\n      vn = vec3 (s.xz / cylRad, 0.).xzy;\n    } else if (srdy * ro.y < - cylLen) {\n      d = - (srdy * ro.y + cylLen) / abs (rd.y);\n      if (d > 0.) {\n        s = ro + d * rd;\n        if (length (s.xz) < cylRad) {\n          dMin = d;\n          vn = vec3 (0., 0., - srdy).xzy;\n        }\n      }\n    }\n  }\n  return vec4 (dMin, vn);\n}\n\nvec3 BgCol (vec3 rd)\n{\n  vec3 col;\n  vec2 u;\n  float el, f;\n  rd.xz = Rot2D (rd.xz, 0.01 * tCur);\n  el = asin (rd.y);\n  u = vec2 (atan (rd.z, - rd.x) + pi, tan (2. * atan (0.5 * el))) / (2. * pi);\n  f = 64.;\n  col = mix (vec3 (0., 0.1, 0.3), vec3 (0.8), mix (Fbm2 (f * u),\n     Fbm2 (f * (u - vec2 (1., 0.))), u.x));\n  col = mix (col, vec3 (0.2, 0.3, 0.4), smoothstep (0.95, 0.98, abs (el) / (0.5 * pi)));\n  return col;\n}\n\nvec3 SheetCol (float s)\n{  // specs from Wikipedia\n  vec4 pStar[6];\n  vec3 col, colB, colR, colW;\n  vec2 p, q;\n  float w;\n  colB = vec3 (0., 0., 139. / 255.);\n  colR = vec3 (1., 0., 0.);\n  colW = vec3 (1.);\n  col = colB;\n  p = (qgHit / (0.5 * float (nBallE.y - 1)) - 1.);\n  if (abs (p.x) < 1. && abs (p.y - 0.5) < 0.5) {\n    p *= 2.;\n    p.y -= 1.;\n    w = 1./15.;\n    q = Rot2D (p, atan (0.5));\n    col = mix (colW, col, smoothstep (0., 0.02, abs (q.y) - 3. * w));\n    col = mix (colR, col, smoothstep (0., 0.02, abs (q.y - sign (p.x) * w) - w));\n    q = Rot2D (p, atan (-0.5));\n    col = mix (colW, col, smoothstep (0., 0.02, abs (q.y) - 3.* w));\n    col = mix (colR, col, smoothstep (0., 0.02, abs (q.y - sign (p.x) * w) - w));\n    q = p;\n    col = mix (colW, col, smoothstep (0., 0.02, Minv2 (abs (q)) - 5.* w));\n    col = mix (colR, col, smoothstep (0., 0.02, Minv2 (abs (q)) - 3.* w));\n    col = mix (col, colB, smoothstep (-0.01, 0., Maxv2 (abs (q) - vec2 (2., 1.))));\n  } else {\n    p += 1.;\n    pStar[0] = vec4 (1./4., 1./4., 3./20., 7.);\n    pStar[1] = vec4 (3./4., 1./6., 1./14., 7.);\n    pStar[2] = vec4 (5./8., 9./16., 1./14., 7.);\n    pStar[3] = vec4 (3./4., 5./6., 1./14., 7.);\n    pStar[4] = vec4 (31./36., 151./240., 1./14., 7.);\n    pStar[5] = vec4 (4./5., 11./24., 1./24., 5.);\n    for (int k = 0; k < 6; k ++) {\n      q = p - vec2 (4., 2.) * pStar[k].xy;\n      if (length (q) < 2. * pStar[k].z + 0.02) {\n        q = Rot2D (q, ((pStar[k].w == 7.) ? pi : 0.) + 0.5 * pi / pStar[k].w);\n        q = Rot2D (q, 2. * pi * (floor (pStar[k].w * ((length (q) > 0.) ? atan (q.y, - q.x) : 0.) /\n           (2. * pi) + 0.5) / pStar[k].w));\n        col = mix (colW, col, smoothstep (0., 0.01, dot (vec2 (abs (q.y), - q.x - 2. * pStar[k].z),\n           sin (0.11 * pi + vec2 (0.5 * pi, 0.)))));\n      }\n    }\n  }\n  col = mix (col, vec3 (1.), 0.1);\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, dc4;\n  vec3 col, vn, q;\n  float dstObj, dstSheet, s, flSize;\n  szFac = 4. / float (nBallE.y - 1);\n  flSize = szFac * 0.5 * float (nBallE.y + 1);\n  q = ro;\n  q.y -= - 2. * flSize;\n  dc4 = CylHit (q, rd, 0.06, 3. * flSize + 0.2);\n  dstObj = dc4.x;\n  q = ro;\n  q.x -= 2. * flSize + 0.06;\n  dstSheet = (SheetSilHit (q, rd) < dstFar) ? SheetRay (q, rd) : dstFar;\n  if (min (dstSheet, dstObj) < dstFar) {\n    if (dstSheet < dstObj) {\n      vn = SheetNf ();\n      s = sign (dot (rd, vn));\n      if (s > 0.) vn = - vn;\n      col4 = vec4 (SheetCol (s), 0.03);\n    } else {\n      ro += dstObj * rd;\n      vn = dc4.yzw;\n      col4 = vec4 (0.8, 0.8, 0.85, 0.3);\n      if (abs (ro.y) < flSize + 0.1) col4 *= (0.5 + 0.5 * smoothstep (0.05, 0.1,\n         abs (mod (4. * (ro.y + 0.02) / flSize + 0.5, 1.) - 0.5)));\n    }\n    col = col4.rgb * (0.3 + 0.7 * max (dot (vn, sunDir), 0.)) +\n       col4.a * pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);\n  } else col = BgCol (rd);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, stDat;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2.2 * pi * mPtr.x;\n    el += 0.4 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.2 * pi, 0.2 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., -0.7, -20.);\n  ro.x += 4.;\n  stDat = Loadv4 (vec2 (0, nBallE.y));\n  spLen = stDat.x;\n  dstFar = 60.;\n  sunDir = vuMat * normalize (vec3 (-0.5, 1., -1.));\n  col = vec3 (0.);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), 5.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Flag From Down Under\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Fbm1 (float p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst ivec2 nBallE = ivec2 (65, 33);\n\nvec3 pMin, pMax;\nivec2 idNeb[4], idNebD[4];\nfloat tCur, spLen, nStep;\nconst float pi = 3.14159;\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nvec3 GetV (vec2 v)\n{\n  return Loadv4 (vec2 (v.x + float (nBallE.x), v.y)).xyz;\n}\n\nvec3 SpringForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 dr, f;\n  ivec2 ivn;\n  float spLenD, fSpring, fSpringD, fDamp;\n  fSpring = 400.;\n  fDamp = 1.;\n  f = vec3 (0.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNeb[n];\n    if (ivn.y >= 0 && ivn.y < nBallE.y && ivn.x >= 0 && ivn.x < nBallE.x) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpring * (spLen - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  fSpringD = 3. * fSpring;\n  spLenD = spLen * sqrt(2.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNebD[n];\n    if (ivn.y >= 0 && ivn.y < nBallE.y && ivn.x >= 0 && ivn.x < nBallE.x) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpringD * (spLenD - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  return f;\n}\n\nvec3 BendForce (ivec2 iv, vec3 r)\n{\n  vec3 dr1, dr2, rt, f;\n  ivec2 ivd, ivp, ivm;\n  float s, c11, c22, c12, cd;\n  bool doInt;\n  f = vec3 (0.);\n  for (int nd = 0; nd < 2; nd ++) {\n    ivd = (nd == 0) ? ivec2 (1, 0) : ivec2 (0, 1);\n    for (int k = 0; k < 3; k ++) {\n      doInt = false;\n      if (nd == 0) {\n        if (k == 0 && iv.x > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.x < nBallE.x - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.x > 0 && iv.x < nBallE.x - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      } else {\n        if (k == 0 && iv.y > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.y < nBallE.y - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.y > 0 && iv.y < nBallE.y - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      }\n      if (doInt) {\n        if (k == 0) {\n          rt = GetR (vec2 (ivp));\n          dr1 = rt - GetR (vec2 (ivm));\n          dr2 = r - rt;\n          s = -1.;\n        } else if (k == 2) {\n          rt = GetR (vec2 (ivm));\n          dr1 = rt - r;\n          dr2 = GetR (vec2 (ivp)) - rt;\n          s = -1.;\n        } else {\n          dr1 = r - GetR (vec2 (ivm));\n          dr2 = GetR (vec2 (ivp)) - r;\n          s = 1.;\n        }\n        c11 = 1. / dot (dr1, dr1);\n        c12 = dot (dr1, dr2);\n        c22 = 1. / dot (dr2, dr2);\n        cd = sqrt (c11 * c22);\n        s *= cd * (c12 * cd - 1.);\n        if (k <= 1) f += s * (dr1 - c12 * c22 * dr2);\n        if (k >= 1) f += s * (c12 * c11 * dr1 - dr2);\n      }\n    }\n  }\n  return f;\n}\n\nvec3 PairForce (vec3 r)\n{\n  vec3 dr, f;\n  float rSep;\n  int nx, ny;\n  f = vec3 (0.);\n  nx = 0;\n  ny = 0;\n  for (int n = 0; n < nBallE.x * nBallE.y; n ++) {\n    dr = r - GetR (vec2 (nx, ny));\n    rSep = length (dr);\n    if (rSep > 0.01 && rSep < 1.) f += (1. / rSep - 1.) * dr;\n    if (++ nx == nBallE.x) {\n      nx = 0;\n      ++ ny;\n    }  \n  }\n  return f;\n}\n\nvec3 NormForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 f, n;\n  ivec2 e = ivec2 (1, 0);\n  f = vec3 (0.);\n  if (iv.y > 0 && iv.y < nBallE.y - 1 && iv.x > 0 && iv.x < nBallE.x - 1) {\n    n = normalize (cross (GetR (vec2 (iv + e.yx)) - GetR (vec2 (iv - e.yx)),\n       GetR (vec2 (iv + e)) - GetR (vec2 (iv - e))));\n    f = - dot (v, n) * n;\n  }\n  return f;\n}\n\nvoid IdNebs ()\n{\n  idNeb[0] = ivec2 (1, 0);\n  idNeb[1] = - idNeb[0];\n  idNeb[2] = ivec2 (0, 1);\n  idNeb[3] = - idNeb[2];\n  idNebD[0] = ivec2 (1, 1);\n  idNebD[1] = - idNebD[0];\n  idNebD[2] = ivec2 (1, -1);\n  idNebD[3] = - idNebD[2];\n}\n\nvoid Step (ivec2 iv, out vec3 r, out vec3 v)\n{\n  vec3 dr, f, wDir;\n  vec2 s;\n  float fOvlap, fBend, fGrav, fDamp, dt;\n  IdNebs ();\n  fOvlap = 1000.;\n  fBend = 50.;\n  fGrav = 0.25;\n  fDamp = 0.5;\n  wDir = vec3 (Rot2D (vec2 (-1., 0.), 0.7 * pi * (2. * Fbm1 (1.5 * tCur) - 1.)), 0.).xzy;\n  r = GetR (vec2 (iv));\n  v = GetV (vec2 (iv));\n  f = fOvlap * PairForce (r) + SpringForce (iv, r, v) + fBend * BendForce (iv, r) +\n     (1. + 8. * Fbm1 (tCur)) * NormForce (iv, r, wDir);\n  f -= fDamp * v;\n  f.y -= fGrav;\n  dt = 0.02;\n  if (iv.x != 0 || mod (float (iv.y), float ((nBallE.y - 1) / 8)) != 0. && iv.y != nBallE.y - 2) {\n    v += dt * f;\n    r += dt * v;\n  }\n}\n\nvoid Init (ivec2 iv, out vec3 r, out vec3 v)\n{\n  float fn;\n  for (int iy = 0; iy < nBallE.y; iy ++) {\n    for (int ix = 0; ix < nBallE.x; ix ++) {\n      if (iv.x == ix && iv.y == iy) {\n        r = vec3 (ix, iy, 0.);\n        r.xy -= 0.5 * (vec2 (nBallE.x, nBallE.y) - 1.);\n        r *= 0.97 * spLen;\n      }\n    }\n  }\n  fn = float (iv.y * nBallE.x + iv.x);\n  v = 1. * normalize (vec3 (Hashff (fn), Hashff (fn + 0.3), Hashff (fn + 0.6)) - 0.5);\n}\n\nvoid SheetLims ()\n{\n  vec3 p;\n  pMin = vec3 (1e6);\n  pMax = - pMin;\n  for (int iy = 0; iy < nBallE.y; iy ++) {\n    for (int ix = 0; ix < nBallE.x; ix ++) {\n      p = GetR (vec2 (ix, iy));\n      pMin = min (pMin, p);\n      pMax = max (pMax, p);\n    }\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 r, v;\n  ivec2 pxIv, iv;\n  int mId, pxId, nb;\n  tCur = iTime;\n  pxIv = ivec2 (fragCoord);\n  pxId = pxIv.x + 2 * nBallE.x * pxIv.y;\n  nb = nBallE.x * nBallE.y;\n  if (pxIv.x >= 2 * nBallE.x || pxId >= 2 * nb + 3) discard;\n  stDat = Loadv4 (vec2 (2, nBallE));\n  iv = pxIv;\n  if (iv.x >= nBallE.x) iv.x -= nBallE.x;\n  mId = iv.y * nBallE.x + iv.x;\n  if (iFrame <= 5) {\n    spLen = 1.1;\n    nStep = 0.;\n    if (mId < nb) Init (iv, r, v);\n  } else {\n    stDat = Loadv4 (vec2 (0, nBallE.y));\n    spLen = stDat.x;\n    nStep = stDat.y;\n    stDat = Loadv4 (vec2 (3, nBallE.y));\n    ++ nStep;\n    if (mId < nb) Step (iv, r, v);\n  }\n  if (pxId == 2 * nb + 1 || pxId == 2 * nb + 2) SheetLims ();\n  if (pxId < 2 * nb) stDat = vec4 (((pxIv.x >= nBallE.x) ? v : r), 0.);\n  else {\n    if (pxId == 2 * nb + 0) stDat = stDat = vec4 (spLen, nStep, 0., 0.);\n    else if (pxId == 2 * nb + 1) stDat = vec4 (pMin, 0.);\n    else if (pxId == 2 * nb + 2) stDat = vec4 (pMax, 0.);\n  }\n  Savev4 (vec2 (pxIv), stDat, fragColor, fragCoord);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \"Flag From Down Under\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Fbm1 (float p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst ivec2 nBallE = ivec2 (65, 33);\n\nvec3 pMin, pMax;\nivec2 idNeb[4], idNebD[4];\nfloat tCur, spLen, nStep;\nconst float pi = 3.14159;\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nvec3 GetV (vec2 v)\n{\n  return Loadv4 (vec2 (v.x + float (nBallE.x), v.y)).xyz;\n}\n\nvec3 SpringForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 dr, f;\n  ivec2 ivn;\n  float spLenD, fSpring, fSpringD, fDamp;\n  fSpring = 400.;\n  fDamp = 1.;\n  f = vec3 (0.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNeb[n];\n    if (ivn.y >= 0 && ivn.y < nBallE.y && ivn.x >= 0 && ivn.x < nBallE.x) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpring * (spLen - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  fSpringD = 3. * fSpring;\n  spLenD = spLen * sqrt(2.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNebD[n];\n    if (ivn.y >= 0 && ivn.y < nBallE.y && ivn.x >= 0 && ivn.x < nBallE.x) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpringD * (spLenD - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  return f;\n}\n\nvec3 BendForce (ivec2 iv, vec3 r)\n{\n  vec3 dr1, dr2, rt, f;\n  ivec2 ivd, ivp, ivm;\n  float s, c11, c22, c12, cd;\n  bool doInt;\n  f = vec3 (0.);\n  for (int nd = 0; nd < 2; nd ++) {\n    ivd = (nd == 0) ? ivec2 (1, 0) : ivec2 (0, 1);\n    for (int k = 0; k < 3; k ++) {\n      doInt = false;\n      if (nd == 0) {\n        if (k == 0 && iv.x > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.x < nBallE.x - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.x > 0 && iv.x < nBallE.x - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      } else {\n        if (k == 0 && iv.y > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.y < nBallE.y - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.y > 0 && iv.y < nBallE.y - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      }\n      if (doInt) {\n        if (k == 0) {\n          rt = GetR (vec2 (ivp));\n          dr1 = rt - GetR (vec2 (ivm));\n          dr2 = r - rt;\n          s = -1.;\n        } else if (k == 2) {\n          rt = GetR (vec2 (ivm));\n          dr1 = rt - r;\n          dr2 = GetR (vec2 (ivp)) - rt;\n          s = -1.;\n        } else {\n          dr1 = r - GetR (vec2 (ivm));\n          dr2 = GetR (vec2 (ivp)) - r;\n          s = 1.;\n        }\n        c11 = 1. / dot (dr1, dr1);\n        c12 = dot (dr1, dr2);\n        c22 = 1. / dot (dr2, dr2);\n        cd = sqrt (c11 * c22);\n        s *= cd * (c12 * cd - 1.);\n        if (k <= 1) f += s * (dr1 - c12 * c22 * dr2);\n        if (k >= 1) f += s * (c12 * c11 * dr1 - dr2);\n      }\n    }\n  }\n  return f;\n}\n\nvec3 PairForce (vec3 r)\n{\n  vec3 dr, f;\n  float rSep;\n  int nx, ny;\n  f = vec3 (0.);\n  nx = 0;\n  ny = 0;\n  for (int n = 0; n < nBallE.x * nBallE.y; n ++) {\n    dr = r - GetR (vec2 (nx, ny));\n    rSep = length (dr);\n    if (rSep > 0.01 && rSep < 1.) f += (1. / rSep - 1.) * dr;\n    if (++ nx == nBallE.x) {\n      nx = 0;\n      ++ ny;\n    }  \n  }\n  return f;\n}\n\nvec3 NormForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 f, n;\n  ivec2 e = ivec2 (1, 0);\n  f = vec3 (0.);\n  if (iv.y > 0 && iv.y < nBallE.y - 1 && iv.x > 0 && iv.x < nBallE.x - 1) {\n    n = normalize (cross (GetR (vec2 (iv + e.yx)) - GetR (vec2 (iv - e.yx)),\n       GetR (vec2 (iv + e)) - GetR (vec2 (iv - e))));\n    f = - dot (v, n) * n;\n  }\n  return f;\n}\n\nvoid IdNebs ()\n{\n  idNeb[0] = ivec2 (1, 0);\n  idNeb[1] = - idNeb[0];\n  idNeb[2] = ivec2 (0, 1);\n  idNeb[3] = - idNeb[2];\n  idNebD[0] = ivec2 (1, 1);\n  idNebD[1] = - idNebD[0];\n  idNebD[2] = ivec2 (1, -1);\n  idNebD[3] = - idNebD[2];\n}\n\nvoid Step (ivec2 iv, out vec3 r, out vec3 v)\n{\n  vec3 dr, f, wDir;\n  vec2 s;\n  float fOvlap, fBend, fGrav, fDamp, dt;\n  IdNebs ();\n  fOvlap = 1000.;\n  fBend = 50.;\n  fGrav = 0.25;\n  fDamp = 0.5;\n  wDir = vec3 (Rot2D (vec2 (-1., 0.), 0.7 * pi * (2. * Fbm1 (1.5 * tCur) - 1.)), 0.).xzy;\n  r = GetR (vec2 (iv));\n  v = GetV (vec2 (iv));\n  f = fOvlap * PairForce (r) + SpringForce (iv, r, v) + fBend * BendForce (iv, r) +\n     (1. + 8. * Fbm1 (tCur)) * NormForce (iv, r, wDir);\n  f -= fDamp * v;\n  f.y -= fGrav;\n  dt = 0.02;\n  if (iv.x != 0 || mod (float (iv.y), float ((nBallE.y - 1) / 8)) != 0. && iv.y != nBallE.y - 2) {\n    v += dt * f;\n    r += dt * v;\n  }\n}\n\nvoid Init (ivec2 iv, out vec3 r, out vec3 v)\n{\n  float fn;\n  for (int iy = 0; iy < nBallE.y; iy ++) {\n    for (int ix = 0; ix < nBallE.x; ix ++) {\n      if (iv.x == ix && iv.y == iy) {\n        r = vec3 (ix, iy, 0.);\n        r.xy -= 0.5 * (vec2 (nBallE.x, nBallE.y) - 1.);\n        r *= 0.97 * spLen;\n      }\n    }\n  }\n  fn = float (iv.y * nBallE.x + iv.x);\n  v = 1. * normalize (vec3 (Hashff (fn), Hashff (fn + 0.3), Hashff (fn + 0.6)) - 0.5);\n}\n\nvoid SheetLims ()\n{\n  vec3 p;\n  pMin = vec3 (1e6);\n  pMax = - pMin;\n  for (int iy = 0; iy < nBallE.y; iy ++) {\n    for (int ix = 0; ix < nBallE.x; ix ++) {\n      p = GetR (vec2 (ix, iy));\n      pMin = min (pMin, p);\n      pMax = max (pMax, p);\n    }\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 r, v;\n  ivec2 pxIv, iv;\n  int mId, pxId, nb;\n  tCur = iTime;\n  pxIv = ivec2 (fragCoord);\n  pxId = pxIv.x + 2 * nBallE.x * pxIv.y;\n  nb = nBallE.x * nBallE.y;\n  if (pxIv.x >= 2 * nBallE.x || pxId >= 2 * nb + 3) discard;\n  stDat = Loadv4 (vec2 (2, nBallE));\n  iv = pxIv;\n  if (iv.x >= nBallE.x) iv.x -= nBallE.x;\n  mId = iv.y * nBallE.x + iv.x;\n  if (iFrame <= 5) {\n    spLen = 1.1;\n    nStep = 0.;\n    if (mId < nb) Init (iv, r, v);\n  } else {\n    stDat = Loadv4 (vec2 (0, nBallE.y));\n    spLen = stDat.x;\n    nStep = stDat.y;\n    stDat = Loadv4 (vec2 (3, nBallE.y));\n    ++ nStep;\n    if (mId < nb) Step (iv, r, v);\n  }\n  if (pxId == 2 * nb + 1 || pxId == 2 * nb + 2) SheetLims ();\n  if (pxId < 2 * nb) stDat = vec4 (((pxIv.x >= nBallE.x) ? v : r), 0.);\n  else {\n    if (pxId == 2 * nb + 0) stDat = stDat = vec4 (spLen, nStep, 0., 0.);\n    else if (pxId == 2 * nb + 1) stDat = vec4 (pMin, 0.);\n    else if (pxId == 2 * nb + 2) stDat = vec4 (pMax, 0.);\n  }\n  Savev4 (vec2 (pxIv), stDat, fragColor, fragCoord);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// \"Flag From Down Under\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Fbm1 (float p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst ivec2 nBallE = ivec2 (65, 33);\n\nvec3 pMin, pMax;\nivec2 idNeb[4], idNebD[4];\nfloat tCur, spLen, nStep;\nconst float pi = 3.14159;\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nvec3 GetV (vec2 v)\n{\n  return Loadv4 (vec2 (v.x + float (nBallE.x), v.y)).xyz;\n}\n\nvec3 SpringForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 dr, f;\n  ivec2 ivn;\n  float spLenD, fSpring, fSpringD, fDamp;\n  fSpring = 400.;\n  fDamp = 1.;\n  f = vec3 (0.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNeb[n];\n    if (ivn.y >= 0 && ivn.y < nBallE.y && ivn.x >= 0 && ivn.x < nBallE.x) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpring * (spLen - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  fSpringD = 3. * fSpring;\n  spLenD = spLen * sqrt(2.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNebD[n];\n    if (ivn.y >= 0 && ivn.y < nBallE.y && ivn.x >= 0 && ivn.x < nBallE.x) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpringD * (spLenD - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  return f;\n}\n\nvec3 BendForce (ivec2 iv, vec3 r)\n{\n  vec3 dr1, dr2, rt, f;\n  ivec2 ivd, ivp, ivm;\n  float s, c11, c22, c12, cd;\n  bool doInt;\n  f = vec3 (0.);\n  for (int nd = 0; nd < 2; nd ++) {\n    ivd = (nd == 0) ? ivec2 (1, 0) : ivec2 (0, 1);\n    for (int k = 0; k < 3; k ++) {\n      doInt = false;\n      if (nd == 0) {\n        if (k == 0 && iv.x > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.x < nBallE.x - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.x > 0 && iv.x < nBallE.x - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      } else {\n        if (k == 0 && iv.y > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.y < nBallE.y - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.y > 0 && iv.y < nBallE.y - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      }\n      if (doInt) {\n        if (k == 0) {\n          rt = GetR (vec2 (ivp));\n          dr1 = rt - GetR (vec2 (ivm));\n          dr2 = r - rt;\n          s = -1.;\n        } else if (k == 2) {\n          rt = GetR (vec2 (ivm));\n          dr1 = rt - r;\n          dr2 = GetR (vec2 (ivp)) - rt;\n          s = -1.;\n        } else {\n          dr1 = r - GetR (vec2 (ivm));\n          dr2 = GetR (vec2 (ivp)) - r;\n          s = 1.;\n        }\n        c11 = 1. / dot (dr1, dr1);\n        c12 = dot (dr1, dr2);\n        c22 = 1. / dot (dr2, dr2);\n        cd = sqrt (c11 * c22);\n        s *= cd * (c12 * cd - 1.);\n        if (k <= 1) f += s * (dr1 - c12 * c22 * dr2);\n        if (k >= 1) f += s * (c12 * c11 * dr1 - dr2);\n      }\n    }\n  }\n  return f;\n}\n\nvec3 PairForce (vec3 r)\n{\n  vec3 dr, f;\n  float rSep;\n  int nx, ny;\n  f = vec3 (0.);\n  nx = 0;\n  ny = 0;\n  for (int n = 0; n < nBallE.x * nBallE.y; n ++) {\n    dr = r - GetR (vec2 (nx, ny));\n    rSep = length (dr);\n    if (rSep > 0.01 && rSep < 1.) f += (1. / rSep - 1.) * dr;\n    if (++ nx == nBallE.x) {\n      nx = 0;\n      ++ ny;\n    }  \n  }\n  return f;\n}\n\nvec3 NormForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 f, n;\n  ivec2 e = ivec2 (1, 0);\n  f = vec3 (0.);\n  if (iv.y > 0 && iv.y < nBallE.y - 1 && iv.x > 0 && iv.x < nBallE.x - 1) {\n    n = normalize (cross (GetR (vec2 (iv + e.yx)) - GetR (vec2 (iv - e.yx)),\n       GetR (vec2 (iv + e)) - GetR (vec2 (iv - e))));\n    f = - dot (v, n) * n;\n  }\n  return f;\n}\n\nvoid IdNebs ()\n{\n  idNeb[0] = ivec2 (1, 0);\n  idNeb[1] = - idNeb[0];\n  idNeb[2] = ivec2 (0, 1);\n  idNeb[3] = - idNeb[2];\n  idNebD[0] = ivec2 (1, 1);\n  idNebD[1] = - idNebD[0];\n  idNebD[2] = ivec2 (1, -1);\n  idNebD[3] = - idNebD[2];\n}\n\nvoid Step (ivec2 iv, out vec3 r, out vec3 v)\n{\n  vec3 dr, f, wDir;\n  vec2 s;\n  float fOvlap, fBend, fGrav, fDamp, dt;\n  IdNebs ();\n  fOvlap = 1000.;\n  fBend = 50.;\n  fGrav = 0.25;\n  fDamp = 0.5;\n  wDir = vec3 (Rot2D (vec2 (-1., 0.), 0.7 * pi * (2. * Fbm1 (1.5 * tCur) - 1.)), 0.).xzy;\n  r = GetR (vec2 (iv));\n  v = GetV (vec2 (iv));\n  f = fOvlap * PairForce (r) + SpringForce (iv, r, v) + fBend * BendForce (iv, r) +\n     (1. + 8. * Fbm1 (tCur)) * NormForce (iv, r, wDir);\n  f -= fDamp * v;\n  f.y -= fGrav;\n  dt = 0.02;\n  if (iv.x != 0 || mod (float (iv.y), float ((nBallE.y - 1) / 8)) != 0. && iv.y != nBallE.y - 2) {\n    v += dt * f;\n    r += dt * v;\n  }\n}\n\nvoid Init (ivec2 iv, out vec3 r, out vec3 v)\n{\n  float fn;\n  for (int iy = 0; iy < nBallE.y; iy ++) {\n    for (int ix = 0; ix < nBallE.x; ix ++) {\n      if (iv.x == ix && iv.y == iy) {\n        r = vec3 (ix, iy, 0.);\n        r.xy -= 0.5 * (vec2 (nBallE.x, nBallE.y) - 1.);\n        r *= 0.97 * spLen;\n      }\n    }\n  }\n  fn = float (iv.y * nBallE.x + iv.x);\n  v = 1. * normalize (vec3 (Hashff (fn), Hashff (fn + 0.3), Hashff (fn + 0.6)) - 0.5);\n}\n\nvoid SheetLims ()\n{\n  vec3 p;\n  pMin = vec3 (1e6);\n  pMax = - pMin;\n  for (int iy = 0; iy < nBallE.y; iy ++) {\n    for (int ix = 0; ix < nBallE.x; ix ++) {\n      p = GetR (vec2 (ix, iy));\n      pMin = min (pMin, p);\n      pMax = max (pMax, p);\n    }\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 r, v;\n  ivec2 pxIv, iv;\n  int mId, pxId, nb;\n  tCur = iTime;\n  pxIv = ivec2 (fragCoord);\n  pxId = pxIv.x + 2 * nBallE.x * pxIv.y;\n  nb = nBallE.x * nBallE.y;\n  if (pxIv.x >= 2 * nBallE.x || pxId >= 2 * nb + 3) discard;\n  stDat = Loadv4 (vec2 (2, nBallE));\n  iv = pxIv;\n  if (iv.x >= nBallE.x) iv.x -= nBallE.x;\n  mId = iv.y * nBallE.x + iv.x;\n  if (iFrame <= 5) {\n    spLen = 1.1;\n    nStep = 0.;\n    if (mId < nb) Init (iv, r, v);\n  } else {\n    stDat = Loadv4 (vec2 (0, nBallE.y));\n    spLen = stDat.x;\n    nStep = stDat.y;\n    stDat = Loadv4 (vec2 (3, nBallE.y));\n    ++ nStep;\n    if (mId < nb) Step (iv, r, v);\n  }\n  if (pxId == 2 * nb + 1 || pxId == 2 * nb + 2) SheetLims ();\n  if (pxId < 2 * nb) stDat = vec4 (((pxIv.x >= nBallE.x) ? v : r), 0.);\n  else {\n    if (pxId == 2 * nb + 0) stDat = stDat = vec4 (spLen, nStep, 0., 0.);\n    else if (pxId == 2 * nb + 1) stDat = vec4 (pMin, 0.);\n    else if (pxId == 2 * nb + 2) stDat = vec4 (pMax, 0.);\n  }\n  Savev4 (vec2 (pxIv), stDat, fragColor, fragCoord);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// \"Flag From Down Under\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Fbm1 (float p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst ivec2 nBallE = ivec2 (65, 33);\n\nvec3 pMin, pMax;\nivec2 idNeb[4], idNebD[4];\nfloat tCur, spLen, nStep;\nconst float pi = 3.14159;\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nvec3 GetV (vec2 v)\n{\n  return Loadv4 (vec2 (v.x + float (nBallE.x), v.y)).xyz;\n}\n\nvec3 SpringForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 dr, f;\n  ivec2 ivn;\n  float spLenD, fSpring, fSpringD, fDamp;\n  fSpring = 400.;\n  fDamp = 1.;\n  f = vec3 (0.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNeb[n];\n    if (ivn.y >= 0 && ivn.y < nBallE.y && ivn.x >= 0 && ivn.x < nBallE.x) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpring * (spLen - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  fSpringD = 3. * fSpring;\n  spLenD = spLen * sqrt(2.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNebD[n];\n    if (ivn.y >= 0 && ivn.y < nBallE.y && ivn.x >= 0 && ivn.x < nBallE.x) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpringD * (spLenD - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  return f;\n}\n\nvec3 BendForce (ivec2 iv, vec3 r)\n{\n  vec3 dr1, dr2, rt, f;\n  ivec2 ivd, ivp, ivm;\n  float s, c11, c22, c12, cd;\n  bool doInt;\n  f = vec3 (0.);\n  for (int nd = 0; nd < 2; nd ++) {\n    ivd = (nd == 0) ? ivec2 (1, 0) : ivec2 (0, 1);\n    for (int k = 0; k < 3; k ++) {\n      doInt = false;\n      if (nd == 0) {\n        if (k == 0 && iv.x > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.x < nBallE.x - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.x > 0 && iv.x < nBallE.x - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      } else {\n        if (k == 0 && iv.y > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.y < nBallE.y - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.y > 0 && iv.y < nBallE.y - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      }\n      if (doInt) {\n        if (k == 0) {\n          rt = GetR (vec2 (ivp));\n          dr1 = rt - GetR (vec2 (ivm));\n          dr2 = r - rt;\n          s = -1.;\n        } else if (k == 2) {\n          rt = GetR (vec2 (ivm));\n          dr1 = rt - r;\n          dr2 = GetR (vec2 (ivp)) - rt;\n          s = -1.;\n        } else {\n          dr1 = r - GetR (vec2 (ivm));\n          dr2 = GetR (vec2 (ivp)) - r;\n          s = 1.;\n        }\n        c11 = 1. / dot (dr1, dr1);\n        c12 = dot (dr1, dr2);\n        c22 = 1. / dot (dr2, dr2);\n        cd = sqrt (c11 * c22);\n        s *= cd * (c12 * cd - 1.);\n        if (k <= 1) f += s * (dr1 - c12 * c22 * dr2);\n        if (k >= 1) f += s * (c12 * c11 * dr1 - dr2);\n      }\n    }\n  }\n  return f;\n}\n\nvec3 PairForce (vec3 r)\n{\n  vec3 dr, f;\n  float rSep;\n  int nx, ny;\n  f = vec3 (0.);\n  nx = 0;\n  ny = 0;\n  for (int n = 0; n < nBallE.x * nBallE.y; n ++) {\n    dr = r - GetR (vec2 (nx, ny));\n    rSep = length (dr);\n    if (rSep > 0.01 && rSep < 1.) f += (1. / rSep - 1.) * dr;\n    if (++ nx == nBallE.x) {\n      nx = 0;\n      ++ ny;\n    }  \n  }\n  return f;\n}\n\nvec3 NormForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 f, n;\n  ivec2 e = ivec2 (1, 0);\n  f = vec3 (0.);\n  if (iv.y > 0 && iv.y < nBallE.y - 1 && iv.x > 0 && iv.x < nBallE.x - 1) {\n    n = normalize (cross (GetR (vec2 (iv + e.yx)) - GetR (vec2 (iv - e.yx)),\n       GetR (vec2 (iv + e)) - GetR (vec2 (iv - e))));\n    f = - dot (v, n) * n;\n  }\n  return f;\n}\n\nvoid IdNebs ()\n{\n  idNeb[0] = ivec2 (1, 0);\n  idNeb[1] = - idNeb[0];\n  idNeb[2] = ivec2 (0, 1);\n  idNeb[3] = - idNeb[2];\n  idNebD[0] = ivec2 (1, 1);\n  idNebD[1] = - idNebD[0];\n  idNebD[2] = ivec2 (1, -1);\n  idNebD[3] = - idNebD[2];\n}\n\nvoid Step (ivec2 iv, out vec3 r, out vec3 v)\n{\n  vec3 dr, f, wDir;\n  vec2 s;\n  float fOvlap, fBend, fGrav, fDamp, dt;\n  IdNebs ();\n  fOvlap = 1000.;\n  fBend = 50.;\n  fGrav = 0.25;\n  fDamp = 0.5;\n  wDir = vec3 (Rot2D (vec2 (-1., 0.), 0.7 * pi * (2. * Fbm1 (1.5 * tCur) - 1.)), 0.).xzy;\n  r = GetR (vec2 (iv));\n  v = GetV (vec2 (iv));\n  f = fOvlap * PairForce (r) + SpringForce (iv, r, v) + fBend * BendForce (iv, r) +\n     (1. + 8. * Fbm1 (tCur)) * NormForce (iv, r, wDir);\n  f -= fDamp * v;\n  f.y -= fGrav;\n  dt = 0.02;\n  if (iv.x != 0 || mod (float (iv.y), float ((nBallE.y - 1) / 8)) != 0. && iv.y != nBallE.y - 2) {\n    v += dt * f;\n    r += dt * v;\n  }\n}\n\nvoid Init (ivec2 iv, out vec3 r, out vec3 v)\n{\n  float fn;\n  for (int iy = 0; iy < nBallE.y; iy ++) {\n    for (int ix = 0; ix < nBallE.x; ix ++) {\n      if (iv.x == ix && iv.y == iy) {\n        r = vec3 (ix, iy, 0.);\n        r.xy -= 0.5 * (vec2 (nBallE.x, nBallE.y) - 1.);\n        r *= 0.97 * spLen;\n      }\n    }\n  }\n  fn = float (iv.y * nBallE.x + iv.x);\n  v = 1. * normalize (vec3 (Hashff (fn), Hashff (fn + 0.3), Hashff (fn + 0.6)) - 0.5);\n}\n\nvoid SheetLims ()\n{\n  vec3 p;\n  pMin = vec3 (1e6);\n  pMax = - pMin;\n  for (int iy = 0; iy < nBallE.y; iy ++) {\n    for (int ix = 0; ix < nBallE.x; ix ++) {\n      p = GetR (vec2 (ix, iy));\n      pMin = min (pMin, p);\n      pMax = max (pMax, p);\n    }\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 r, v;\n  ivec2 pxIv, iv;\n  int mId, pxId, nb;\n  tCur = iTime;\n  pxIv = ivec2 (fragCoord);\n  pxId = pxIv.x + 2 * nBallE.x * pxIv.y;\n  nb = nBallE.x * nBallE.y;\n  if (pxIv.x >= 2 * nBallE.x || pxId >= 2 * nb + 3) discard;\n  stDat = Loadv4 (vec2 (2, nBallE));\n  iv = pxIv;\n  if (iv.x >= nBallE.x) iv.x -= nBallE.x;\n  mId = iv.y * nBallE.x + iv.x;\n  if (iFrame <= 5) {\n    spLen = 1.1;\n    nStep = 0.;\n    if (mId < nb) Init (iv, r, v);\n  } else {\n    stDat = Loadv4 (vec2 (0, nBallE.y));\n    spLen = stDat.x;\n    nStep = stDat.y;\n    stDat = Loadv4 (vec2 (3, nBallE.y));\n    ++ nStep;\n    if (mId < nb) Step (iv, r, v);\n  }\n  if (pxId == 2 * nb + 1 || pxId == 2 * nb + 2) SheetLims ();\n  if (pxId < 2 * nb) stDat = vec4 (((pxIv.x >= nBallE.x) ? v : r), 0.);\n  else {\n    if (pxId == 2 * nb + 0) stDat = stDat = vec4 (spLen, nStep, 0., 0.);\n    else if (pxId == 2 * nb + 1) stDat = vec4 (pMin, 0.);\n    else if (pxId == 2 * nb + 2) stDat = vec4 (pMax, 0.);\n  }\n  Savev4 (vec2 (pxIv), stDat, fragColor, fragCoord);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtfXDM.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[698, 698, 718, 718, 745], [747, 747, 782, 782, 1863], [1865, 1865, 1886, 1886, 1945], [1947, 1947, 1965, 1965, 2102], [2104, 2104, 2142, 2142, 2526], [2528, 2528, 2588, 2588, 3336], [3338, 3338, 3360, 3360, 3759], [3761, 3761, 3786, 3811, 5629], [5631, 5631, 5666, 5666, 6676], [6678, 6678, 6734, 6734, 7792], [7794, 7794, 7816, 7816, 7843], [7845, 7845, 7867, 7867, 7894], [7896, 7896, 7918, 7918, 7956], [7958, 7958, 7980, 7980, 8018], [8020, 8020, 8077, 8077, 8160], [8162, 8162, 8198, 8198, 8404], [8406, 8406, 8436, 8436, 8549], [8583, 8583, 8607, 8607, 8737], [8739, 8739, 8764, 8764, 8950], [8952, 8952, 8973, 8973, 9128], [9195, 9195, 9219, 9219, 9269]], "test": "untested"}
{"id": "7lXXWH", "name": "VolumeRayCastTest", "author": "alfy", "description": "Testing volume raycasting", "tags": ["volume", "raycast"], "likes": 1, "viewed": 229, "published": 3, "date": "1625741193", "time_retrieved": "2024-07-30T19:11:43.458433", "image_code": "\n\nvec3 camera_rd(vec3 camera_p, vec3 camera_t, float camera_fov_h, vec2 uv, vec2 resolution_uv) {\n    vec3 t_p = camera_t - camera_p;\n    float length_t_p = length(t_p);\n    \n    t_p = normalize(t_p);\n    vec3 x_axis = normalize(cross(t_p, vec3(0.,-1.,0.)));\n    vec3 y_axis = normalize(cross(t_p, x_axis));\n    \n    \n    float length_x_axis = tan(camera_fov_h/2.0) * length_t_p;\n    float length_y_axis = resolution_uv.y/resolution_uv.x * length_x_axis;\n    \n    vec3 rayTarget = camera_t + x_axis * (uv.x / resolution_uv.x * length_x_axis) + y_axis * (uv.y / resolution_uv.y * length_y_axis);\n    \n    \n    return normalize(rayTarget - camera_p);\n}\n\n\n\nbool iAABB(in vec3 ro, in vec3 rd, in vec3 minBound, in vec3 maxBound)\n{\n    float tmin = (minBound.x - ro.x) / rd.x; \n    float tmax = (maxBound.x - ro.x) / rd.x; \n \n    if (tmin > tmax) {\n        //swap\n        float t = tmin;\n        tmin = tmax;\n        tmax = t;\n    } \n \n    float tymin = (minBound.y - ro.y) / rd.y; \n    float tymax = (maxBound.y - ro.y) / rd.y; \n \n    if (tymin > tymax) {\n        //swap\n        float ty = tymin;\n        tymin = tymax;\n        tymax = ty;\n    }\n \n    if ((tmin > tymax) || (tymin > tmax)) \n        return false; \n \n    if (tymin > tmin) \n        tmin = tymin; \n \n    if (tymax < tmax) \n        tmax = tymax; \n \n    float tzmin = (minBound.z - ro.z) / rd.z; \n    float tzmax = (maxBound.z - ro.z) / rd.z; \n \n    if (tzmin > tzmax) {\n        //swap\n        float tz = tzmin;\n        tzmin = tzmax;\n        tzmax = tz;\n    }\n \n    if ((tmin > tzmax) || (tzmin > tmax)) \n        return false; \n \n    if (tzmin > tmin) \n        tmin = tzmin; \n \n    if (tzmax < tmax) \n        tmax = tzmax; \n \n    return true; \n}\n\nbool iBox( in vec3 ro, in vec3 rd, in vec3 rad, out float tNear, out float tFar ) \n{\n    // convert from ray to box space\n\t//vec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\t//vec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return false;\n\n\t//vec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    // convert to ray space\n\t\n\t//nor = (txi * vec4(nor,0.0)).xyz;\n    \n    tNear = tN;\n    tFar = tF;\n\n\treturn true;\n}\n\n\nfloat noiseNew( in vec3 x )\n{\n    return texture( iChannel0, x/32.0 ).x;    // <---------- Sample a 3D texture!\n}\n\n\nvec3 average(vec3 nearPoint, vec3 farPoint, float steps) {\n    vec3 col = vec3(0.);\n    \n    vec3 d = farPoint - nearPoint;\n    float t = 0.;\n    for (float i=0.0; i < steps; i++) {\n        vec3 p = nearPoint + (i/steps) * d;\n        float density = noiseNew(p*10.);\n        //if (density > 0.5) {\n        //    t+=1.;\n        //}\n        t += density * (1.-length(p)*1.);\n    }\n    \n    return vec3(t/steps*2.);\n}\n\n\n\nvec3 volRayCast(vec3 ro, vec3 rd)\n{\n    float tN,tF;\n    bool inter = iBox(ro, rd, vec3(1.), tN, tF);\n    \n    if (inter){\n        vec3 nearPoint = ro + tN*rd;\n        vec3 farPoint = ro + tF*rd;\n        //float d = distance(nearPoint, farPoint);\n        //return vec3(d/6.);\n        return average(nearPoint, farPoint, 100.);\n    }\n    \n    return vec3(0.);\n\n}\n\n\nbool iCloud(in vec3 ro, in vec3 rd, out float nearInt)\n{\n    float epsilon = 0.01;\n    nearInt = 100000.; //Big Number\n    float tN,tF;\n    bool inter = iBox(ro, rd, vec3(1.), tN, tF);\n    \n    for (float t = tN; t < tF; t += epsilon) {\n        vec3 p = ro + t * rd;\n        float density = noiseNew(p*2.);\n        if (density > 0.8) {\n            nearInt = t;\n            return true;\n        }\n    }\n    return false;\n}\n\n\nvec3 pointNormal(vec3 p, vec3 rd)\n{\n    float epsilone = 0.001;\n    \n    float tX;\n    vec3 roX = p + vec3(epsilone, 0., 0.);\n    iCloud(roX, rd, tX);\n    vec3 pX = roX + rd * tX;\n    \n    float tY;\n    vec3 roY = p + vec3(0., epsilone, 0.);\n    iCloud(roY, rd, tY);\n    vec3 pY = roY + rd * tY;\n    \n    float tZ;\n    vec3 roZ = p + vec3(0., 0., epsilone);\n    iCloud(roZ, rd, tZ);\n    vec3 pZ = roZ + rd * tZ;\n    \n    vec3 x = normalize(pX - p);\n    vec3 y = normalize(pY - p);\n    vec3 z = normalize(pZ - p);\n    \n    return cross(x, y);\n\n}\n\nvec3 getShading(vec3 p, vec3 n) {\n    vec3 light1_p = vec3(10.,10.,10.);\n    \n    vec3 col;\n    \n    col += clamp(0.,1.,dot(n, normalize(light1_p-p)));\n    \n    return col;\n}\n\n\nvec3 rayTrace(vec3 ro, vec3 rd)\n{\n    vec3 light1_p = vec3(10.,10.,10.);\n    \n    float t = 0.;\n    bool i = iCloud(ro, rd, t);\n    if (i) {\n        vec3 p = ro + rd * t;\n        vec3 n = pointNormal(p, rd);\n        return getShading(p, n);\n    }\n    return vec3(0.);\n}\n\n\nvec3 rotateY(float a, float r, float h)\n{\n    return vec3(\n        sin(a) * r,\n        h,\n        cos(a) * r\n    );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //move origin to center, iResolution.y range -1.0 to 1.0\n    vec2 uv = (fragCoord-(iResolution.xy*0.5))/iResolution.y;\n    vec2 resolution_uv = iResolution.xy/iResolution.y*0.5;\n    vec2 mouse_uv = (iMouse.xy-(iResolution.xy*0.5))/iResolution.y;\n    \n    vec3 camera_p = rotateY(iTime*0.5, 5., 2.5);//vec3(10.,10.,10.);\n    vec3 camera_t = vec3(0.,0.,0.);\n    float camera_fov_h = 0.785; //45degrees\n    \n    vec3 rd = camera_rd(camera_p, camera_t, camera_fov_h, uv, resolution_uv);\n    \n    //vec3 col = volRayCast(camera_p, rd);\n    vec3 col = rayTrace(camera_p, rd);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lXXWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 97, 97, 650], [654, 654, 726, 726, 1704], [1706, 1706, 1790, 1942, 2371], [2374, 2374, 2403, 2403, 2487], [2490, 2490, 2548, 2548, 2904], [2908, 2908, 2943, 2943, 3269], [3272, 3272, 3328, 3328, 3693], [3696, 3696, 3731, 3731, 4240], [4242, 4242, 4275, 4275, 4416], [4419, 4419, 4452, 4452, 4688], [4691, 4691, 4732, 4732, 4808], [4811, 4811, 4868, 4929, 5476]], "test": "untested"}
{"id": "ftlSD4", "name": "attempting ocean 60fps", "author": "jhylands", "description": "Turns out creating the memory is less efficient", "tags": ["sea", "sun", "clouds", "fbm", "water", "cirrus"], "likes": 7, "viewed": 513, "published": 3, "date": "1625711236", "time_retrieved": "2024-07-30T19:11:44.517601", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n    \n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*\nReal time PBR Volumetric Clouds by robobo1221.\nSingle scattering\nAlso includes volumetric light.\nhttp://shadertoy.com/user/robobo1221\n\nFirst ever somewhat PBR effect I decided to work on.\nIt uses the same algorithm to calculate the worldPosition as in: https://www.shadertoy.com/view/lstfR7\n\nFeel free to fork and edit it. (Credit me please.)\nHope you enjoy!\n*/\n\n#define CLOUDS 0\n#define WAVE_DETAIL 1\n#define cloudSpeed 0.02\n#define cloudHeight 3000.0\n#define cloudThickness 1000.0\n#define cloudDensity 0.01\n\n#define fogDensity 0.0001\n\n#define volumetricCloudSteps 32\t\t\t//Higher is a better result with rendering of clouds.\n#define volumetricLightSteps 1\t\t\t//Higher is a better result with rendering of volumetric light.\n\n#define cloudShadowingSteps 1\t\t\t//Higher is a better result with shading on clouds.\n\n\n#define rayleighCoeff (vec3(0.27, 0.5, 1.0) * 1e-5)\t//Not really correct\n#define mieCoeff vec3(0.5e-6)\t\t\t\t\t\t//Not really correct\n\nconst float sunBrightness = 10.0;\n\n#define earthRadius 6371000.0\nfloat waterlevel = 70.0;        // height of the water\nfloat wavegain   = 1.0;       // change to adjust the general water wave level\nfloat large_waveheight = 1.0; // change to adjust the \"heavy\" waves (set to 0.0 to have a very still ocean :)\nconst float small_waveheight = 1.0; // change to adjust the small waves\n\n\n\n///////////////////////////////////////////////////////////////////////////////////\n\n#define d0(x) (abs(x)+ 1e-8 )\n#define d02(x) (abs(x) + 1e-3)\n\nconst vec3 totalCoeff = rayleighCoeff + mieCoeff;\n\nvec3 scatter(vec3 coeff, float depth){\n\treturn coeff * depth;\n}\n\nvec3 absorb(vec3 coeff, float depth){\n\treturn exp2(scatter(coeff, -depth));\n}\n\nfloat calcParticleThickness(float depth){\n   \t\n    depth = depth * 2.0;\n    depth = max(depth + 0.01, 0.01);\n    depth = 1.0 / depth;\n    \n\treturn 100000.0 * depth;   \n}\n\nfloat calcParticleThicknessH(float depth){\n   \t\n    depth = depth * 2.0 + 0.1;\n    depth = max(depth + 0.01, 0.01);\n    depth = 1.0 / depth;\n    \n\treturn 100000.0 * depth;   \n}\n\nfloat calcParticleThicknessConst(const float depth){\n    \n\treturn 100000.0 / max(depth * 2.0 - 0.01, 0.1);   \n}\n\nfloat rayleighPhase(float x){\n\treturn 0.375 * (1.0 + x*x);\n}\n\nfloat hgPhase(float x, float g)\n{\n    float g2 = g*g;\n\treturn 0.25 * ((1.0 - g2) * pow(1.0 + g2 - 2.0*g*x, -1.5));\n}\n\nfloat miePhaseSky(float x, float depth)\n{\n \treturn hgPhase(x, exp2(-0.000003 * depth));\n}\n\nfloat powder(float od)\n{\n\treturn 1.0 - exp2(-od * 2.0);\n}\n\nfloat calculateScatterIntergral(float opticalDepth, float coeff){\n    float a = -coeff * rLOG2;\n    float b = -1.0 / coeff;\n    float c =  1.0 / coeff;\n\n    return exp2(a * opticalDepth) * b + c;\n}\n\nvec3 calculateScatterIntergral(float opticalDepth, vec3 coeff){\n    vec3 a = -coeff * rLOG2;\n    vec3 b = -1.0 / coeff;\n    vec3 c =  1.0 / coeff;\n\n    return exp2(a * opticalDepth) * b + c;\n}\n\n\nvec3 calcAtmosphericScatter(positionStruct pos, out vec3 absorbLight){\n    const float ln2 = log(2.0);\n    \n    float lDotW = dot(pos.sunVector, pos.worldVector);\n    float lDotU = dot(pos.sunVector, vec3(0.0, 1.0, 0.0));\n    float uDotW = dot(vec3(0.0, 1.0, 0.0), pos.worldVector);\n    float m = 1.;\n    if(uDotW<0.){\n     m = 0.5*(1.+abs(uDotW));\n     uDotW*=-1.;\n     \n    }\n    \n\tfloat opticalDepth = calcParticleThickness(uDotW);\n    float opticalDepthLight = calcParticleThickness(lDotU);\n    \n    vec3 scatterView = scatter(totalCoeff, opticalDepth);\n    vec3 absorbView = absorb(totalCoeff, opticalDepth);\n    \n    vec3 scatterLight = scatter(totalCoeff, opticalDepthLight);\n         absorbLight = absorb(totalCoeff, opticalDepthLight);\n    \t \n    vec3 absorbSun =  abs(absorbLight - absorbView) / d0((scatterLight - scatterView) * ln2);\n    \n    vec3 mieScatter = scatter(mieCoeff, opticalDepth) * miePhaseSky(lDotW, opticalDepth);\n    vec3 rayleighScatter = scatter(rayleighCoeff, opticalDepth) * rayleighPhase(lDotW);\n    \n    vec3 scatterSun = mieScatter + rayleighScatter;\n    \n    vec3 sunSpot = smoothstep(0.9996, 0.99993, lDotW) * absorbView * sunBrightness;\n    \n    return (scatterSun * absorbSun + sunSpot) * sunBrightness * m;\n}\n\nvec3 calcAtmosphericScatterTop(positionStruct pos){\n    const float ln2 = log(2.0);\n    \n    float lDotU = dot(pos.sunVector, vec3(0.0, 1.0, 0.0));\n    \n\tfloat opticalDepth = calcParticleThicknessConst(2.5);\n    float opticalDepthLight = calcParticleThickness(lDotU);\n    \n    vec3 scatterView = scatter(totalCoeff, opticalDepth);\n    vec3 absorbView = absorb(totalCoeff, opticalDepth);\n    \n    vec3 scatterLight = scatter(totalCoeff, opticalDepthLight);\n    vec3 absorbLight = absorb(totalCoeff, opticalDepthLight);\n    \n    vec3 absorbSun = d02(absorbLight - absorbView) / d02((scatterLight - scatterView) * ln2);\n    \n    vec3 mieScatter = scatter(mieCoeff, opticalDepth) * 0.25;\n    vec3 rayleighScatter = scatter(rayleighCoeff, opticalDepth) * 0.375;\n    \n    vec3 scatterSun = mieScatter + rayleighScatter;\n    \n    return (scatterSun * absorbSun) * sunBrightness;\n}\n\nfloat Get3DNoise(vec3 pos) \n{\n    //return 1.;\n    float p = floor(pos.z);\n    float f = pos.z - p;\n    \n    const float invNoiseRes = 1.0 / 64.0;\n    \n    float zStretch = 17.0 * invNoiseRes;\n    \n    vec2 coord = pos.xy * invNoiseRes + (p * zStretch);\n    \n    vec2 noise = vec2(texture(iChannel3, coord).x,\n\t\t\t\t\t  texture(iChannel3, coord + zStretch).x);\n    \n    return mix(noise.x, noise.y, f);\n}\n\nfloat getClouds(vec3 p)\n{\n    p = vec3(p.x, length(p + vec3(0.0, earthRadius, 0.0)) - earthRadius, p.z);\n\n    \n    \n    float time = iTime * cloudSpeed;\n    vec3 movement = vec3(time, 0.0, time);\n    \n    vec3 cloudCoord = (p * 0.001) + movement;\n    vec4 noise_weight = vec4(0.5, 0.25, 0.125, 0.0625);\n\tvec4 noise = vec4(\n            Get3DNoise(cloudCoord),\n    \t  Get3DNoise(cloudCoord * 2.0 + movement),\n    \t  Get3DNoise(cloudCoord * 7.0 - movement),\n    \t  Get3DNoise((cloudCoord + movement) * 16.0));\n        \n    //noise *= 1./0.8;\n    const float top = 0.004;\n    const float bottom = 0.01;\n    \n    float horizonHeight = p.y - cloudMinHeight;\n    float treshHold = (1.0 - exp2(-bottom * horizonHeight)) * exp2(-top * horizonHeight);\n    \n    float clouds = smoothstep(0.55, 0.6, dot(noise, noise_weight));\n          clouds *= treshHold;\n    \n    return clouds * cloudDensity;\n}\n\n\nfloat getSunVisibility(vec3 p, positionStruct pos)\n{\n\tconst int steps = cloudShadowingSteps;\n    const float rSteps = cloudThickness / float(steps);\n    \n    vec3 increment = pos.sunVector * rSteps;\n    vec3 position = increment * 0.5 + p;\n    \n    float transmittance = 0.0;\n    \n    for (int i = 0; i < steps; i++, position += increment)\n    {\n\t\ttransmittance += getClouds(position);\n    }\n    \n    return exp2(-transmittance * rSteps);\n}\n\nfloat phase2Lobes(float x)\n{\n    const float m = 0.6;\n    const float gm = 0.8;\n    \n\tfloat lobe1 = hgPhase(x, 0.8 * gm);\n    float lobe2 = hgPhase(x, -0.5 * gm);\n    \n    return mix(lobe2, lobe1, m);\n}\n\nvec3 getVolumetricCloudsScattering(\n    float opticalDepth, float phase, vec3 p, vec3 sunColor, vec3 skyLight, positionStruct pos)\n{\n    float intergal = calculateScatterIntergral(opticalDepth, 1.11);\n    \n    float beersPowder = powder(opticalDepth * log(2.0));\n    \n\tvec3 sunlighting = (sunColor * getSunVisibility(p, pos) * beersPowder) * phase * hPi * sunBrightness;\n    vec3 skylighting = skyLight * 0.25 * rPi;\n    \n    return (sunlighting + skylighting) * intergal * pi;\n}\n\nfloat getHeightFogOD(float height)\n{\n\tconst float falloff = 0.001;\n    \n    return exp2(height * falloff) * fogDensity;\n}\n\n\nvec3 calculateVolumetricClouds(positionStruct pos, vec3 color, float dither, vec3 sunColor)\n{\n\tconst int steps = volumetricCloudSteps;\n    const float iSteps = 1.0 / float(steps);\n    \n    if (pos.worldVector.y < 0.0)\n       return color;\n    \n    float bottomSphere = rsi(vec3(0.0, 1.0, 0.0) * earthRadius, pos.worldVector, earthRadius + cloudMinHeight).y;\n    float topSphere = rsi(vec3(0.0, 1.0, 0.0) * earthRadius, pos.worldVector, earthRadius + cloudMaxHeight).y;\n    \n    vec3 startPosition = pos.worldVector * bottomSphere;\n    vec3 endPosition = pos.worldVector * topSphere;\n    \n    vec3 increment = (endPosition - startPosition) * iSteps;\n    vec3 cloudPosition = increment * dither + startPosition;\n    \n    float stepLength = length(increment);\n    \n    vec3 scattering = vec3(0.0);\n    float transmittance = 1.0;\n    \n    float lDotW = dot(pos.sunVector, pos.worldVector);\n    float phase = phase2Lobes(lDotW);\n    \n    vec3 skyLight = calcAtmosphericScatterTop(pos);\n    \n    for (int i = 0; i < steps; i++, cloudPosition += increment)\n    {\n        float opticalDepth = getClouds(cloudPosition) * stepLength;\n        \n        if (opticalDepth <= 0.0)\n            continue;\n        \n\t\tscattering += getVolumetricCloudsScattering(opticalDepth, phase, cloudPosition, sunColor, skyLight, pos) * transmittance;\n        transmittance *= exp2(-opticalDepth);\n    }\n    \n    return mix(color * transmittance + scattering, color, clamp(length(startPosition) * 0.00001, 0.0, 1.0));\n}\n\nvec3 robobo1221Tonemap(vec3 color)\n{\n    #define rTOperator(x) (x / sqrt(x*x+1.0))\n\n    float l = length(color);\n\n    color = mix(color, color * 0.5, l / (l+1.0));\n    color = rTOperator(color);\n\n    return color;\n}\nfloat voronoise( in vec2 p, in float t_metric)\n{\n    const vec2 temp = 0.5 - 0.5 * -1.8*vec2(1.0,0.5) ;\n    const float u = temp.x;\n    const float v = temp.y;\n\tfloat k = 1.0+63.0*pow(1.0-v,6.0);\n    \n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 t = 10.*vec2(cos(0.001*t_metric), cos(0.002*t_metric+0.34));\n\tvec2 a = vec2(0.0,0.0);\n    const int stepr = 2;\n    for( int y=-stepr; y<=stepr; y++ )\n    for( int x=-stepr; x<=stepr; x++ )\n    {\n        vec2  g = vec2( x, y );\n\t\tvec3  o = texture(iChannel1, (i + g)* 0.5/64.+ 0.5*t).rgb;\n\t\tvec2  d = g - f + o.xy;\n\t\tfloat w = pow( 1.0-smoothstep(0.0,1.414,length(d)), k );\n\t\ta += vec2(o.z*w,w);\n    }\n    return a.x/a.y;\n}\nvec3 calcFlatClouds(positionStruct pos,in vec3 color, in vec3 sunColor)\n{\n    float distance_metric = tan(0.4*3.1415926*length(pos.worldVector.xz))+1.;\n    vec2 p = distance_metric*pos.worldVector.xz*24.;\n    float time_metric = 0.1*(iTime+0.);\n\n    vec2 un = vec2(0.01,0.00432)*p;\n    float mixer = .8-length(sin(un+vec2(0.+0.005*time_metric))+sin(un+vec2(2.+0.005*time_metric)));\n\t\n    return mix(color,10.*sunColor,smoothstep(0.9-smoothstep(0.,1.3,abs(mixer)),1.1,mix(voronoise(p*10., 0.),voronoise(p, time_metric),0.7)));\n}\nvec3 getSky(in positionStruct pos )\n{\n    \n    float dither = bayer16(pos.texcoord*iResolution.xy);\n    \n    vec3 lightAbsorb = vec3(0.0);\n\n    vec3 color = vec3(0.0);\n         color = calcAtmosphericScatter(pos, lightAbsorb);\n#if CLOUDS\n         color = calcFlatClouds(pos, color, lightAbsorb);\n         color = calculateVolumetricClouds(pos, color, dither, lightAbsorb);\n#endif\n\n    return color;\n}\n\nfloat hash( vec2 p ) {\n    return fract(sin(dot(p,vec2(1177.1,2711.7)))*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f * f * (3.0-2.0 * f);\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nfloat wv(in vec2 uv, vec2 d, float t, float A)\n{\n    return sin ( dot(d, uv) / 4.0 + t) * A;\n}\n\n// water\nfloat fbm(in vec2 uv, float lod)\n{\t\n    float f =  textureLod(iChannel2, uv, lod).r * 0.5;\n    \t  f += textureLod(iChannel2, uv*2.0, lod).r * 0.5*0.5;\n    \t  f += textureLod(iChannel2, uv*4.0, lod).r * 0.5*0.5*0.5;\n    \t  f += textureLod(iChannel2, uv*8.0, lod).r * 0.5*0.5*0.5*0.5;\n\n    f = f*f*f*f;\n    return f;\n}\nconst mat2 m2 = mat2(1.6,-1.2,1.2,1.6);\nfloat noiseo(vec2 p)\n{\n  return textureLod(iChannel0,p*vec2(1./256.),0.0).x;\n}\n// Fractional Brownian motion\nfloat fbm( vec2 p )\n{\n  float f = 0.5000*noiseo( p ); p = m2*p;\n  f += 0.2500*noiseo( p ); p = m2*p;\n  f += 0.1666*noiseo( p ); p = m2*p;\n  f += 0.0834*noiseo( p );\n  return f;\n}\nfloat wavesLo(const in vec3 rp, float t, float A)\n{\n    vec2 p = rp.xz*100.1;\n    \n  vec2 shift2 = 0.001*vec2( iTime*190.0*2.0, -iTime*130.0*2.0 );\n    \n  // coarse crossing 'ocean' waves...\n  float wave = 0.0;\n  wave += sin(p.x*0.021  + shift2.x)*4.5;\n  wave += sin(p.x*0.0172+p.y*0.010 + shift2.x*1.121)*4.0;\n  wave -= sin(p.x*0.00104+p.y*0.005 + shift2.x*0.121)*4.0;\n  // ...added by some smaller faster waves...\n  wave += sin(p.x*0.02221+p.y*0.01233+shift2.x*3.437)*5.0;\n  wave += sin(p.x*0.03112+p.y*0.01122+shift2.x*4.269)*2.5 ;\n  wave *= 0.01;//large_waveheight;\n  //wave -= fbm(p*0.004-shift2*.5)*small_waveheight*24.;\n  return wave;\n}\n\n// high detail waves\nconst mat2 m_0 = mat2(1.6,-1.2,1.2,1.6)*0.9331;\nfloat waves(const in vec3 rp, float t, float A)\n{\n#if WAVE_DETAIL\n    const float small_waveheight = 0.015;\n     vec2 shift1 = 0.3*0.001*vec2( iTime*160.0*2.0, iTime*120.0*2.0 );\n     mat4x2 shift2 = mat4x2(shift1, shift1, shift1, shift1);\n     const mat4x2 shiftmul = mat4x2(\n         vec2(1.),\n         vec2(1.841),\n         vec2(1.841)*vec2(1.841),\n         vec2(1.841)*vec2(1.841)*vec2(1.841));\n    shift2 = matrixCompMult(shift2, shiftmul);\n    vec2 p = rp.xz;\n  mat4x2 pesa = mat4x2(p, p*m2, p*(m2*m2), p*(m2*m2*m2));\n  const float amp = 6.*small_waveheight;\n  vec4 noisevals = vec4(0.);\n  const vec4 amps = vec4(amp, amp*.51, amp*(.51*.51),amp*(.51*.51*.51));\n  mat4x2 key = 1.1*pesa + shift2;\n  for (int i=0; i<4; i++)\n  {\n    noisevals[i] = noise(key[i]);\n  }\n  float wave = dot(abs(sin((noisevals-.5)*3.14))*amps, vec4(1.));\n    return wavesLo(rp, t, A) - wave;// +w3+w4+w7+w8+w5+w6;\n#else\n    return wavesLo(rp, t, A);\n#endif\n}\n\nfloat mapLo(in vec3 rp)\n{\n    return rp.y - wavesLo(rp, 2.0+iTime*.5, .04);\n}\n\n\nfloat map(in vec3 rp)\n{\n    return rp.y - waves(rp, 2.0+iTime*.5, .04);\n}\n\n\nvec3 grad(vec3 rp, float preci)\n{\n    vec2 off = vec2(preci, 0.0);\n    vec3 g = vec3(map(rp + off.xyy) - map(rp - off.xyy),\n\t\t\t\t  map(rp + off.yxy) - map(rp - off.yxy),                  \n\t\t\t\t  map(rp + off.yyx) - map(rp - off.yyx));\n    return normalize(g);\n}\n\n// scanning the surroundings for differences in heights on the heightmap\nvec2 sub(vec3 rp, float preci)\n{\n    vec2 off = vec2(preci, 0.0);\n    vec2 g = vec2(map(rp + off.xyy) + map(rp - off.xyy),\n\t\t\t\t  map(rp + off.yyx) + map(rp - off.yyx));\n    return g;\n}\n\n\n\n\nconst vec3 up = vec3(0.0, 1.0, 0.0);\n\n\nvoid trace(in positionStruct pos, in vec3 rp, in vec3 rd, inout vec4 color)\n{\n    \n    if (dot(rd, up)>0.0){\n        color.rgb = getSky(pos);\n        return;\n    }\n    \n    // trace to plane on top of waves\n    vec3 ro = rp;\n    float t = -(0.155+dot(rp, -up)) / dot(-up, rd);\n    if (t < 0.0) \n    {\n        return;\n    }\n    \n\trp += rd*t;    \n    bool hit = false;\n    float dist = 0.0;\n    \n    // actual tracing\n    \n    // low freq\n    for (int i = 0; i < 10; ++i)\n    {\n        float travelledSq=dot(ro-rp, ro-rp);\n        dist = mapLo(rp);\n        \n        if(dist < 0.01)\n        {\n            hit = true;\n            break;\n        }\n        rp += rd * max(dist * (log2(2.+travelledSq)), 0.01);\n        if(travelledSq > 9000.0) break;\n    }\n    \n    //detail tracing\n    for (int i = 0; i < 10; ++i)\n    {\n        rp += dist * rd;\n        if (abs(dist) < 0.0001) break;\n        dist = map(rp);\n    }\n    \n    // shadings    \n        vec3 sun = pos.sunVector;\n        vec3 g = grad(rp, 0.002 * (1.0+log2(length(ro-rp) * 100.)));\n        // base color\n        float rddg = dot(rd, g);\n        pos.worldVector = rd-2.*rddg*g;\n        pos.worldVector = normalize(pos.worldVector);\n        float F = clamp(max(0.0, 1.+rddg), 0.0, 1.);\n        vec3 water_color = 0.5*vec3(.05, 0.22, .4);\n\n        color.rgb = F* getSky(pos) + (1.-F)*water_color;\n\n\n\n    \n    color.a = 1.;//length(ro-rp);\n    \n}\n\n\nmat3 lookat(vec3 from, vec3 to)\n{\n    vec3 f = normalize(to - from);\n    vec3 _tmpr = normalize(cross(f, vec3(0.0, .999, 0.0)));\n    vec3 u = normalize(cross(_tmpr, f));\n    vec3 r = normalize(cross(u, f));\n    return mat3(r, u, f);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    gatherPositions(pos, fragCoord, iMouse.xy, iResolution.xy);\n;\n    vec2 uv = (fragCoord.xy-iResolution.xy*.5) / iResolution.x;\n    \n    //ray direction \n    vec3 rd = pos.worldPosition;\n    \n    //ray position\n    vec3 rp = vec3(0.0, 2.3, 0.0);\n    vec3 _rp = rp;\n\t    \n    trace(pos, rp, rd, fragColor);\n    vec3 color = fragColor.rgb;\n    color = pow(color, vec3(1.0 / 2.2)); //Fitting to regular colorspace\n    color = robobo1221Tonemap(color);\n    fragColor.rgb = clamp(color, 0.0, 1.0);\n}", "buffer_b_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define VOLUMETRIC_LIGHT\n//#define SPHERICAL_PROJECTION\n\n#define cameraMode 1 \t\t\t\t\t//1 is free rotation, 2 is still camera but free sun rotation\n\n\n//////////////////////////////////////////////////////////////////\n\nfloat bayer2(vec2 a){\n    a = floor(a);\n    return fract( dot(a, vec2(.5, a.y * .75)) );\n}\n\nvec2 rsi(vec3 position, vec3 direction, float radius) {\n    float PoD = dot(position, direction);\n    float radiusSquared = radius * radius;\n\n    float delta = PoD * PoD + radiusSquared - dot(position, position);\n    if (delta < 0.0) return vec2(-1.0);\n          delta = sqrt(delta);\n\n    return -PoD + vec2(-delta, delta);\n}\n\n#define bayer4(a)   (bayer2( .5*(a))*.25+bayer2(a))\n#define bayer8(a)   (bayer4( .5*(a))*.25+bayer2(a))\n#define bayer16(a)  (bayer8( .5*(a))*.25+bayer2(a))\n#define bayer32(a)  (bayer16(.5*(a))*.25+bayer2(a))\n#define bayer64(a)  (bayer32(.5*(a))*.25+bayer2(a))\n#define bayer128(a) (bayer64(.5*(a))*.25+bayer2(a))\n\n//////////////////////////////////////////////////////////////////\n\n#define cloudMinHeight cloudHeight\n#define cloudMaxHeight (cloudThickness + cloudMinHeight)\n\n#define sunPosition vec3(1.0, 0.9, 0.0)\n\nconst float pi = acos(-1.0);\nconst float rPi = 1.0 / pi;\nconst float hPi = pi * 0.5;\nconst float tau = pi * 2.0;\nconst float rLOG2 = 1.0 / log(2.0);\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    float xx = axis.x * axis.x;\n    float yy = axis.y * axis.y;\n    float zz = axis.z * axis.z;\n    \n    float xy = axis.x * axis.y;\n    float xz = axis.x * axis.z;\n    float zy = axis.z * axis.y;\n    \n    return mat3(oc * xx + c, oc * xy - axis.z * s, oc * xz + axis.y * s,\n                oc * xy + axis.z * s, oc * yy + c, oc * zy - axis.x * s, \n                oc * xz - axis.y * s, oc * zy + axis.x * s, oc * zz + c);\n}\n#define PI 3.14159265358\n\nmat3 rotx(float a) { return rotationMatrix(vec3(1.,0.,0.), a); }\nmat3 roty(float a) { return rotationMatrix(vec3(0.,1.,0.), a); }\nmat3 rotz(float a) { return rotationMatrix(vec3(0.,0.,1.), a); }\n\nstruct positionStruct\n{\n\tvec2 texcoord;\n    vec2 mousecoord;\n    vec3 worldPosition;\n    vec3 worldVector;\n    vec3 sunVector;\n} pos;\n\nvec3 sphereToCart(vec3 sphere) {\n    vec2 c = cos(sphere.xy);\n    vec2 s = sin(sphere.xy);\n    \n    return sphere.z * vec3(c.x * c.y, s.y, s.x * c.y);\n}\n\nvec3 calculateWorldSpacePosition(vec2 p)\n{\n\tp = p * 2.0 - 1.0;\n    \n    vec3 worldSpacePosition =  vec3(p.x, p.y, 1.0);\n    \n    #ifdef SPHERICAL_PROJECTION\n\t\tworldSpacePosition = sphereToCart(worldSpacePosition * vec3(pi, hPi, 1.0));\n\t#endif\n    \n    return worldSpacePosition;\n}\n\nvoid gatherPositions(inout positionStruct pos, vec2 fragCoord, vec2 mouseCoord, vec2 screenResolution)\n{\n\tpos.texcoord = fragCoord / screenResolution;\n    pos.mousecoord = mouseCoord / screenResolution;\n    \n    pos.mousecoord = pos.mousecoord.x < 0.001 ? vec2(0.4, 0.64) : pos.mousecoord;\n    \n    vec2 rotationAngle = radians(vec2(360.0, 180.0) * pos.mousecoord - vec2(0.0, 90.0));\n\n    \n    mat3 rotateH = rotationMatrix(vec3(0.0, 1.0, 0.0), rotationAngle.x);\n    mat3 rotateV = rotationMatrix(vec3(1.0, 0.0, 0.0), -rotationAngle.y);\n    \n    pos.worldPosition = calculateWorldSpacePosition(pos.texcoord);\n    \n    if (cameraMode == 1) {\n    \tpos.worldPosition = rotateH * (rotateV * pos.worldPosition);\n        \n        // Sun position\n    \tpos.sunVector = normalize(sunPosition);\n    }\n    if (cameraMode == 2) {\n    \tpos.sunVector = normalize(calculateWorldSpacePosition(pos.mousecoord));\n    }\n    \n    pos.worldVector = normalize(pos.worldPosition);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftlSD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 143]], "test": "untested"}
{"id": "stfSDN", "name": "Reactive Light Garden", "author": "oneshade", "description": "Testing with lots of lights. Doing a 10x10 loop does not seem smart!\nWell anyway it has a nice warm look to it like I intended :)\nMove around with the arrow keys and mouse.", "tags": ["3d", "light", "volumetric", "audioreactive", "integration", "lightfied"], "likes": 12, "viewed": 281, "published": 3, "date": "1625710164", "time_retrieved": "2024-07-30T19:11:45.266599", "image_code": "// https://www.shadertoy.com/view/4djSRW\nvec2 Hash22(in vec2 p) {\n\tvec3 p3 = fract(p.xyx * vec3(0.1031, 0.103, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec3 Hash33(in vec3 p) {\n\tp = fract(p * vec3(0.1031, 0.103, 0.0973));\n    p += dot(p, p.yxz + 33.33);\n    return fract((p.xxy + p.yxx) * p.zyx);\n}\n\n// https://www.shadertoy.com/view/slXXD4\n// Simplified to assume the ray is normalized\nfloat integrateLightFullView(in vec3 ro, in vec3 rd, in float k, in float d) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) + d * d;\n    float h = sqrt(c - b * b);\n    return d * d * k * (RHO - atan(b / h)) / h;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    float time = iTime * 2.0;\n    fragColor = vec4(0.0);\n\n    // Camera ray\n    vec2 viewDir = ivec2(iMouse.xy) == ivec2(0) ? vec2(0.0, -0.6) : (iMouse.xy - center) / iResolution.y * PI;\n    mat3 cam = getCamera(viewDir);\n\n    vec3 ro = getPosition();\n    vec3 rd = normalize(cam * vec3(uv, 1.0));\n\n    // Lights\n    for (float x=-50.0; x < 51.0; x += 10.0) {\n        for (float y=-50.0; y < 51.0; y += 10.0) {\n            vec2 horiPos = vec2(x, y);\n            horiPos += 8.0 * Hash22(horiPos) - 4.0;\n            float height = texture(iChannel1, vec2(length(horiPos) / 70.0, 0.0)).x * 30.0;\n            vec3 colorLast = normalize(Hash33(vec3(horiPos, floor(time))));\n            vec3 colorNext = normalize(Hash33(vec3(horiPos, ceil(time))));\n            fragColor.rgb += integrateLightFullView(ro - vec3(horiPos, height).xzy, rd, 2.0, 0.25) * mix(colorLast, colorNext, fract(time));\n        }\n    }\n\n    fragColor.rgb *= vec3(1.0, 0.8, 0.5);\n}", "image_inputs": [{"id": 13, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Constants\n#define PI 3.14159265359\n#define RHO 1.57079632679\n\n// State loading\n#define getPosition() texelFetch(iChannel0, ivec2(0), 0).xyz\n#define keyUpPressed() bool(texelFetch(iChannel1, ivec2(38, 0), 0).x)\n#define keyDownPressed() bool(texelFetch(iChannel1, ivec2(40, 0), 0).x)\n#define keyRightPressed() bool(texelFetch(iChannel1, ivec2(39, 0), 0).x)\n#define keyLeftPressed() bool(texelFetch(iChannel1, ivec2(37, 0), 0).x)\n\n// Camera matrix\nmat3 getCamera(in vec2 viewDir) {\n    vec2 c = cos(viewDir); vec2 s = sin(viewDir);\n    return mat3(       c.x, 0.0,         s.x,  // Right\n                s.x * -s.y, c.y, -c.x * -s.y,  // Up\n                s.x *  c.y, s.y, -c.x *  c.y); // Forward\n}", "buffer_a_code": "// Camera position buffer\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 50.0, 50.0, 0.0);\n    if (iFrame > 0) {\n        ivec2 addr = ivec2(fragCoord);\n        if (addr == ivec2(0)) {\n            fragColor = vec4(getPosition(), 0.0);\n\n            vec2 viewDir = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y * PI;\n            mat3 cam = getCamera(viewDir);\n\n            if (keyUpPressed()) fragColor.xyz += cam[2] * 0.5;\n            if (keyDownPressed()) fragColor.xyz -= cam[2] * 0.5;\n            if (keyRightPressed()) fragColor.xyz += cam[0] * 0.5;\n            if (keyLeftPressed()) fragColor.xyz -= cam[0] * 0.5;\n        }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stfSDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 41, 65, 65, 200], [202, 202, 226, 226, 348], [350, 437, 515, 515, 658], [660, 660, 715, 715, 1753]], "test": "untested"}
{"id": "7l2GWy", "name": "Particle System Base", "author": "SpinningCube", "description": "basic particle code to be expanded on, storing position and velocity. Fullscreen is broken for some reason, I haven't found an explanation for the behavior there.\n\nreset it to add more particles", "tags": ["ball", "physics", "particle"], "likes": 6, "viewed": 691, "published": 3, "date": "1625705137", "time_retrieved": "2024-07-30T19:11:46.032551", "image_code": "vec4 displayRawParticles (vec2 uv) {\n    return texture(iChannel0, uv/10.)/iResolution.x;\n}\n\nfloat circleDist (vec2 point, vec2 pos, float radius) {\n    return distance(point, pos) - radius;\n}\n\nvec3 drawBalls (int count, float radius, vec2 fragCoord) {\n    for (int i = 0; i < count; i++) {\n        if (circleDist(mod(fragCoord + vec2(radius) - getParticlePos(i), iResolution.xy), vec2(radius), radius) <= 0.) {\n            return vec3(1.);\n        }\n    }\n    return vec3(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(uv,0);\n\n    // Output to screen\n    fragColor = vec4(drawBalls(100, 20., fragCoord), 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 outputVec;\n    \n    int id = int(fragCoord.x) + int(iResolution.x) * int(fragCoord.y);\n\n    int particleNum = id/2;\n\n    int task = int(mod(float(id), 2.)); // 0 = position, 1 = velocity\n    \n    if (iFrame > 0) {\n\n        vec2 pos = getParticlePos(particleNum);\n        vec2 vel = getParticleVel(particleNum);\n\n        if (task == 0) { // position\n            outputVec = pos + vel;\n        }\n        else { // velocity\n            outputVec = vel;\n        }\n        outputVec = mod(outputVec, iResolution.xy);\n    }\n    else {\n    \n        outputVec = texelFetch(iChannel1, ivec2(fragCoord), 0).xy;\n        if (task == 0) {\n            outputVec *= iResolution.x;\n        }\n        else {\n            outputVec -= 0.5;\n            outputVec *= 4.;\n        }\n    }\n    \n    \n    fragColor = vec4(outputVec, 0., 1.);\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define getParticlePos(num) texelFetch(iChannel0, ivec2(mod(float(num*2), iResolution.x), num*2 / int(iResolution.x)), 0).xy\n#define getParticleVel(num) texelFetch(iChannel0, ivec2(mod(float(num*2), iResolution.x) + 1., num*2 / int(iResolution.x)), 0).xy\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l2GWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 91], [93, 93, 148, 148, 192], [194, 194, 252, 252, 479], [481, 481, 538, 588, 773]], "test": "untested"}
{"id": "slsSWH", "name": "Hex Pattern y28", "author": "Yusef28", "description": ".Lot's of comments for this one.", "tags": ["2d", "simple", "hexagon", "tiles"], "likes": 3, "viewed": 290, "published": 3, "date": "1625703215", "time_retrieved": "2024-07-30T19:11:46.793516", "image_code": "/*\n\n*/\n\n\nfloat rnd(vec2 id){\n    return fract(sin(id.x*12.49 + id.y*78.99)*41235.32);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 u = 10.*fragCoord/iResolution.x;\n    \n    //the 30 60 90 triangle with sides 1, 2 and sqrt(3)\n    //sqrt(3) is 1.731: https://www.redblobgames.com/grids/hexagons/\n    vec2 s = vec2(1.,1.732);\n    \n    //we create two grids. Both have the dimentions of s.\n    //mod with s gives us the coordinates like fract does\n    vec2 a = mod(u,s)*2.-s;//stuff after mod just changes value not cell dimention\n    //floor of u/s gives us an id system that is strechted to the s dimentions\n    vec2 idA = floor(u/s);\n    //get a random value for each id for coloring if I wanted\n   // float A = rnd(idA);\n    \n    //we do the same again but with +s*0.5 so we move this system up\n    //diagonally by half the dimentions of s\n    vec2 b = mod(u+s*.5,s)*2.-s;//stuff after mod just changes value not cell dimention\n    vec2 idB = floor((u+s*.5)/s);\n    //I add +4 to give B some randomness\n   // float B = rnd(idB+4.);\n    \n    \n    //we take the lengths because a comparison for a given pixel\n    //between length (within a given grid rectangle) will tell us\n    //the coordinate system where the pixel is closest to 0.,0.\n    //this tells us then which system (and which hexagon) to use.\n    float la = length(a);\n    float lb = length(b);\n  //  float C = la < lb ? A*la : B*lb;\n    \n    //choose which hex system to use\n    u = la < lb ? a : b;\n    //we go a step further, get abs u so whatever we do\n    //in the top right quadrant will be mirrored in top left, bottom left,\n    //and bottom right\n    vec2 st = abs(u);\n    //what we do with this is get the dopt product.\n    //if you remove the max(st.x portion you get a diamond.\n    //This is percentage every pixel's vector (st) is aligned with\n    //the normalized dimention vector (s). and that vector being 1.,1.732\n    //is on a 60 degree angle already from the x axis. All these ratios\n    //act as distances since s is normalized, and that give us that diamond shape.\n    //on top of that max(st.x...) cut's things off whenever x > than the dot\n    //dot product. That gives us an even hex shape.\n    //(in the chosen system)\n    float q = max(st.x, dot(st,normalize(s)));\n    \n\n    //Then I jut add a color pallette\n\tfragColor = vec4(0.5+0.5*cos(vec3(1.,2.,4.)/10. + floor(q*8.) ), 1.);//vec4(1.0-floor(C*8.)/8.*.75);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slsSWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[9, 9, 28, 28, 87], [89, 89, 146, 146, 2419]], "test": "untested"}
{"id": "stfXDN", "name": "Conway at Night[Full Screen]", "author": "Yusef28", "description": "Full Screen shows way more!\nComments on the process are in the image tab\nReminds me of shooting stars and nursery rhymes.", "tags": ["coloring", "conway", "gameoflife", "gol"], "likes": 9, "viewed": 335, "published": 3, "date": "1625702757", "time_retrieved": "2024-07-30T19:11:47.559468", "image_code": "/*\n\nI added a hack to get more action.\nIn Buffer A when a cell dies there is now\na 0.002 percent chance that it will be reborn as a glowing orb.\nAll the other things (fire flies, clowns, and brass knuckels)\nlike to crowd around and sometimes hang out or something.\n\nI mean that is, at least to me, an apt description of what's\nbeen happening so far.\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates 0 (from to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 tex = texture(iChannel0,uv);\n\n    fragColor = vec4(tex.rgb,1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\n\nfloat count(vec2 p, vec2 off){\n\n    float cnt = 0.;\n    \n    cnt += texture(iChannel0, p + vec2(off.x,off.y)).y;\n    cnt += texture(iChannel0, p + vec2(off.x,0.0)).y;\n    cnt += texture(iChannel0, p + vec2(off.x,-off.y)).y;\n    cnt += texture(iChannel0, p + vec2(0.,off.y)).y;\n    cnt += texture(iChannel0, p + vec2(0.,-off.y)).y;\n    cnt += texture(iChannel0, p + vec2(-off.x,off.y)).y;\n    cnt += texture(iChannel0, p + vec2(-off.x,0.0)).y;\n    cnt += texture(iChannel0, p + vec2(-off.x,-off.y)).y;\n    \n    return cnt;\n    \n}\n\nvoid mainImage( out vec4 data, in vec2 fragCoord )\n{\n\n   //fragCoord -= mod(fragCoord, float(S));\n    vec2 off = S/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;//  + (off * .5);\n    vec2 st = fract(uv*skale);\n    vec2 id = floor(uv*skale);\n    vec3 mouse = iMouse.xyz;\n    \n    float c;\n    \n    float state,val,speed,resx;\n    \n    \n    //set up / spacebar reset\n    if(iFrame == 0 || texture(iChannel1,  vec2(0.126953125, .25)).x > 0.){\n    \n        uv = fragCoord/iResolution.xy;\n        \n        //st = fract(uv*skale);        \n        id = floor(uv*skale);\n\n        \n        //val = rnd(id);\n        state = step(0.65,rnd(uv));\n        val = 0.;\n        //speed = rnd(id+vec2(1.))*0.002+0.99;\n        //resx = iResolution.x;\n        \n    }\n    else{\n        //get own texture\n        vec4 tex = texture(iChannel0, uv);\n        \n        float c = count(uv,off);\n        \n        state = tex.y;\n        \n            if((c == 2. && state == 1.) || c == 3.){\n            \n            //this variation is like a tiling\n            //if((c == 2. && state == 1.) || c == 1.){\n            \n                state = 1.;\n            }\n            \n            //if cell dies, increment val, the death counter\n            //\"Death Counting\"\n            else{\n            \n            \n                state = step(0.998,rnd(uv));//0.;\n                val += 1.;\n            }    \n    \n    }\n\n\n    data = vec4(val, state, speed, rnd(vec2(uv.x*uv.y)));\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n//scaling and aspect ration have to happen for st and not the orig uv\n#define S 1.\n#define skale vec2(S,S)\n//*(iResolution.y/iResolution.x))\n//#define off vec2(iResolution.x/skale.x,iResolution.y/skale.y)\n\nfloat rnd(vec2 id){\n    return fract(sin(id.x*12.99+id.y*800.+40.)*51343.);\n}\n", "buffer_b_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates 0 (from to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //for color\n    \n    //the 256 effects the highlights. lower for more highlights.\n    vec2 st = uv;// fract(uv*iResolution.xy/256.);\n\n    vec4 tex = texture(iChannel0,uv/8.);\n    \n    vec3 col;// = vec3(step(0.5,tex.y));// * (1.0-length(st-vec2(0.5))-0.3);\n\n       //glow \n    col = 0.5+0.5*cos(vec3(tex.y*tex.x*tex.y*1.)+vec3(0,2,4)/4.+tex.y*tex.x*3. +3.);\n       \n\n    \n    col = pow(col,vec3(2.))*5.;\n    col = mix(col, texture(iChannel1,uv).rgb, .9);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stfXDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[355, 355, 412, 462, 579]], "test": "untested"}
{"id": "stXXWn", "name": "Entering the Cross Spirals", "author": "R3N", "description": "Playing around with a cross pattern in polar coordinates.", "tags": ["spiral"], "likes": 15, "viewed": 388, "published": 3, "date": "1625696107", "time_retrieved": "2024-07-30T19:11:48.338386", "image_code": "#define saturate(t) clamp(t, 0.0, 1.0)\n#define size 10.0\n// Anti-Aliased smoothstep proposed by FabriceNeyret2\n#define sstep(v) smoothstep(-1.,1.,(v)/fwidth(v))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.y;\n    uv -= iResolution.xy/iResolution.y*0.5;\n    vec2 cuv = vec2(2.0*length(uv), atan(uv.x, uv.y));\n    float tr = smoothstep(-1.0, 1.0, 2.0*sin(0.5*iTime));\n    cuv.x = mix(cuv.x, 2.0/cuv.x, tr);\n    cuv.x -= cos(0.5*iTime);\n    float td = saturate(pow(2.0/length(cuv.x),2.0));\n    float strip1 = sstep(-sin(size*(cuv.x-cuv.y))-0.5);\n    float strip2 = sstep(-sin(size*(cuv.x+cuv.y))-0.5)*sstep(sin(size*(cuv.x-cuv.y)));\n    fragColor = vec4((strip1+0.6*strip2)*td);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stXXWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[162, 162, 219, 219, 727]], "test": "untested"}
{"id": "slfSWN", "name": "Nice ocean", "author": "jhylands", "description": "Using Cirrus clouds to try and get a quicker shader than with volumetric ", "tags": ["sea", "sun", "clouds", "fbm", "water", "cirrus"], "likes": 8, "viewed": 932, "published": 3, "date": "1625695603", "time_retrieved": "2024-07-30T19:11:49.271890", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n    \n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*\nReal time PBR Volumetric Clouds by robobo1221.\nSingle scattering\nAlso includes volumetric light.\nhttp://shadertoy.com/user/robobo1221\n\nFirst ever somewhat PBR effect I decided to work on.\nIt uses the same algorithm to calculate the worldPosition as in: https://www.shadertoy.com/view/lstfR7\n\nFeel free to fork and edit it. (Credit me please.)\nHope you enjoy!\n*/\n\n#define CLOUDS 1\n#define cloudSpeed 0.02\n#define cloudHeight 3000.0\n#define cloudThickness 1000.0\n#define cloudDensity 0.01\n\n#define fogDensity 0.0001\n\n#define volumetricCloudSteps 32\t\t\t//Higher is a better result with rendering of clouds.\n#define volumetricLightSteps 1\t\t\t//Higher is a better result with rendering of volumetric light.\n\n#define cloudShadowingSteps 1\t\t\t//Higher is a better result with shading on clouds.\n\n\n#define rayleighCoeff (vec3(0.27, 0.5, 1.0) * 1e-5)\t//Not really correct\n#define mieCoeff vec3(0.5e-6)\t\t\t\t\t\t//Not really correct\n\nconst float sunBrightness = 10.0;\n\n#define earthRadius 6371000.0\nfloat waterlevel = 70.0;        // height of the water\nfloat wavegain   = 1.0;       // change to adjust the general water wave level\nfloat large_waveheight = 1.0; // change to adjust the \"heavy\" waves (set to 0.0 to have a very still ocean :)\nfloat small_waveheight = 1.0; // change to adjust the small waves\n\n\n\n///////////////////////////////////////////////////////////////////////////////////\n\n#define d0(x) (abs(x)+ 1e-8 )\n#define d02(x) (abs(x) + 1e-3)\n\nconst vec3 totalCoeff = rayleighCoeff + mieCoeff;\n\nvec3 scatter(vec3 coeff, float depth){\n\treturn coeff * depth;\n}\n\nvec3 absorb(vec3 coeff, float depth){\n\treturn exp2(scatter(coeff, -depth));\n}\n\nfloat calcParticleThickness(float depth){\n   \t\n    depth = depth * 2.0;\n    depth = max(depth + 0.01, 0.01);\n    depth = 1.0 / depth;\n    \n\treturn 100000.0 * depth;   \n}\n\nfloat calcParticleThicknessH(float depth){\n   \t\n    depth = depth * 2.0 + 0.1;\n    depth = max(depth + 0.01, 0.01);\n    depth = 1.0 / depth;\n    \n\treturn 100000.0 * depth;   \n}\n\nfloat calcParticleThicknessConst(const float depth){\n    \n\treturn 100000.0 / max(depth * 2.0 - 0.01, 0.1);   \n}\n\nfloat rayleighPhase(float x){\n\treturn 0.375 * (1.0 + x*x);\n}\n\nfloat hgPhase(float x, float g)\n{\n    float g2 = g*g;\n\treturn 0.25 * ((1.0 - g2) * pow(1.0 + g2 - 2.0*g*x, -1.5));\n}\n\nfloat miePhaseSky(float x, float depth)\n{\n \treturn hgPhase(x, exp2(-0.000003 * depth));\n}\n\nfloat powder(float od)\n{\n\treturn 1.0 - exp2(-od * 2.0);\n}\n\nfloat calculateScatterIntergral(float opticalDepth, float coeff){\n    float a = -coeff * rLOG2;\n    float b = -1.0 / coeff;\n    float c =  1.0 / coeff;\n\n    return exp2(a * opticalDepth) * b + c;\n}\n\nvec3 calculateScatterIntergral(float opticalDepth, vec3 coeff){\n    vec3 a = -coeff * rLOG2;\n    vec3 b = -1.0 / coeff;\n    vec3 c =  1.0 / coeff;\n\n    return exp2(a * opticalDepth) * b + c;\n}\n\n\nvec3 calcAtmosphericScatter(positionStruct pos, out vec3 absorbLight){\n    const float ln2 = log(2.0);\n    \n    float lDotW = dot(pos.sunVector, pos.worldVector);\n    float lDotU = dot(pos.sunVector, vec3(0.0, 1.0, 0.0));\n    float uDotW = dot(vec3(0.0, 1.0, 0.0), pos.worldVector);\n    float m = 1.;\n    if(uDotW<0.){\n     m = 0.5*(1.+abs(uDotW));\n     uDotW*=-1.;\n     \n    }\n    \n\tfloat opticalDepth = calcParticleThickness(uDotW);\n    float opticalDepthLight = calcParticleThickness(lDotU);\n    \n    vec3 scatterView = scatter(totalCoeff, opticalDepth);\n    vec3 absorbView = absorb(totalCoeff, opticalDepth);\n    \n    vec3 scatterLight = scatter(totalCoeff, opticalDepthLight);\n         absorbLight = absorb(totalCoeff, opticalDepthLight);\n    \t \n    vec3 absorbSun =  abs(absorbLight - absorbView) / d0((scatterLight - scatterView) * ln2);\n    \n    vec3 mieScatter = scatter(mieCoeff, opticalDepth) * miePhaseSky(lDotW, opticalDepth);\n    vec3 rayleighScatter = scatter(rayleighCoeff, opticalDepth) * rayleighPhase(lDotW);\n    \n    vec3 scatterSun = mieScatter + rayleighScatter;\n    \n    vec3 sunSpot = smoothstep(0.9996, 0.99993, lDotW) * absorbView * sunBrightness;\n    \n    return (scatterSun * absorbSun + sunSpot) * sunBrightness * m;\n}\n\nvec3 calcAtmosphericScatterTop(positionStruct pos){\n    const float ln2 = log(2.0);\n    \n    float lDotU = dot(pos.sunVector, vec3(0.0, 1.0, 0.0));\n    \n\tfloat opticalDepth = calcParticleThicknessConst(2.5);\n    float opticalDepthLight = calcParticleThickness(lDotU);\n    \n    vec3 scatterView = scatter(totalCoeff, opticalDepth);\n    vec3 absorbView = absorb(totalCoeff, opticalDepth);\n    \n    vec3 scatterLight = scatter(totalCoeff, opticalDepthLight);\n    vec3 absorbLight = absorb(totalCoeff, opticalDepthLight);\n    \n    vec3 absorbSun = d02(absorbLight - absorbView) / d02((scatterLight - scatterView) * ln2);\n    \n    vec3 mieScatter = scatter(mieCoeff, opticalDepth) * 0.25;\n    vec3 rayleighScatter = scatter(rayleighCoeff, opticalDepth) * 0.375;\n    \n    vec3 scatterSun = mieScatter + rayleighScatter;\n    \n    return (scatterSun * absorbSun) * sunBrightness;\n}\n\nfloat Get3DNoise(vec3 pos) \n{\n    //return 1.;\n    float p = floor(pos.z);\n    float f = pos.z - p;\n    \n    const float invNoiseRes = 1.0 / 64.0;\n    \n    float zStretch = 17.0 * invNoiseRes;\n    \n    vec2 coord = pos.xy * invNoiseRes + (p * zStretch);\n    \n    vec2 noise = vec2(texture(iChannel3, coord).x,\n\t\t\t\t\t  texture(iChannel3, coord + zStretch).x);\n    \n    return mix(noise.x, noise.y, f);\n}\n\nfloat getClouds(vec3 p)\n{\n    p = vec3(p.x, length(p + vec3(0.0, earthRadius, 0.0)) - earthRadius, p.z);\n\n    \n    \n    float time = iTime * cloudSpeed;\n    vec3 movement = vec3(time, 0.0, time);\n    \n    vec3 cloudCoord = (p * 0.001) + movement;\n    vec4 noise_weight = vec4(0.5, 0.25, 0.125, 0.0625);\n\tvec4 noise = vec4(\n            Get3DNoise(cloudCoord),\n    \t  Get3DNoise(cloudCoord * 2.0 + movement),\n    \t  Get3DNoise(cloudCoord * 7.0 - movement),\n    \t  Get3DNoise((cloudCoord + movement) * 16.0));\n        \n    //noise *= 1./0.8;\n    const float top = 0.004;\n    const float bottom = 0.01;\n    \n    float horizonHeight = p.y - cloudMinHeight;\n    float treshHold = (1.0 - exp2(-bottom * horizonHeight)) * exp2(-top * horizonHeight);\n    \n    float clouds = smoothstep(0.55, 0.6, dot(noise, noise_weight));\n          clouds *= treshHold;\n    \n    return clouds * cloudDensity;\n}\n\n\nfloat getSunVisibility(vec3 p, positionStruct pos)\n{\n\tconst int steps = cloudShadowingSteps;\n    const float rSteps = cloudThickness / float(steps);\n    \n    vec3 increment = pos.sunVector * rSteps;\n    vec3 position = increment * 0.5 + p;\n    \n    float transmittance = 0.0;\n    \n    for (int i = 0; i < steps; i++, position += increment)\n    {\n\t\ttransmittance += getClouds(position);\n    }\n    \n    return exp2(-transmittance * rSteps);\n}\n\nfloat phase2Lobes(float x)\n{\n    const float m = 0.6;\n    const float gm = 0.8;\n    \n\tfloat lobe1 = hgPhase(x, 0.8 * gm);\n    float lobe2 = hgPhase(x, -0.5 * gm);\n    \n    return mix(lobe2, lobe1, m);\n}\n\nvec3 getVolumetricCloudsScattering(\n    float opticalDepth, float phase, vec3 p, vec3 sunColor, vec3 skyLight, positionStruct pos)\n{\n    float intergal = calculateScatterIntergral(opticalDepth, 1.11);\n    \n    float beersPowder = powder(opticalDepth * log(2.0));\n    \n\tvec3 sunlighting = (sunColor * getSunVisibility(p, pos) * beersPowder) * phase * hPi * sunBrightness;\n    vec3 skylighting = skyLight * 0.25 * rPi;\n    \n    return (sunlighting + skylighting) * intergal * pi;\n}\n\nfloat getHeightFogOD(float height)\n{\n\tconst float falloff = 0.001;\n    \n    return exp2(height * falloff) * fogDensity;\n}\n\n\nvec3 calculateVolumetricClouds(positionStruct pos, vec3 color, float dither, vec3 sunColor)\n{\n\tconst int steps = volumetricCloudSteps;\n    const float iSteps = 1.0 / float(steps);\n    \n    if (pos.worldVector.y < 0.0)\n       return color;\n    \n    float bottomSphere = rsi(vec3(0.0, 1.0, 0.0) * earthRadius, pos.worldVector, earthRadius + cloudMinHeight).y;\n    float topSphere = rsi(vec3(0.0, 1.0, 0.0) * earthRadius, pos.worldVector, earthRadius + cloudMaxHeight).y;\n    \n    vec3 startPosition = pos.worldVector * bottomSphere;\n    vec3 endPosition = pos.worldVector * topSphere;\n    \n    vec3 increment = (endPosition - startPosition) * iSteps;\n    vec3 cloudPosition = increment * dither + startPosition;\n    \n    float stepLength = length(increment);\n    \n    vec3 scattering = vec3(0.0);\n    float transmittance = 1.0;\n    \n    float lDotW = dot(pos.sunVector, pos.worldVector);\n    float phase = phase2Lobes(lDotW);\n    \n    vec3 skyLight = calcAtmosphericScatterTop(pos);\n    \n    for (int i = 0; i < steps; i++, cloudPosition += increment)\n    {\n        float opticalDepth = getClouds(cloudPosition) * stepLength;\n        \n        if (opticalDepth <= 0.0)\n            continue;\n        \n\t\tscattering += getVolumetricCloudsScattering(opticalDepth, phase, cloudPosition, sunColor, skyLight, pos) * transmittance;\n        transmittance *= exp2(-opticalDepth);\n    }\n    \n    return mix(color * transmittance + scattering, color, clamp(length(startPosition) * 0.00001, 0.0, 1.0));\n}\n\nvec3 robobo1221Tonemap(vec3 color)\n{\n    #define rTOperator(x) (x / sqrt(x*x+1.0))\n\n    float l = length(color);\n\n    color = mix(color, color * 0.5, l / (l+1.0));\n    color = rTOperator(color);\n\n    return color;\n}\nfloat voronoise( in vec2 p, in float t_metric)\n{\n    const vec2 temp = 0.5 - 0.5 * -1.8*vec2(1.0,0.5) ;\n    const float u = temp.x;\n    const float v = temp.y;\n\tfloat k = 1.0+63.0*pow(1.0-v,6.0);\n    \n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 t = 10.*vec2(cos(0.001*t_metric), cos(0.002*t_metric+0.34));\n\tvec2 a = vec2(0.0,0.0);\n    const int stepr = 2;\n    for( int y=-stepr; y<=stepr; y++ )\n    for( int x=-stepr; x<=stepr; x++ )\n    {\n        vec2  g = vec2( x, y );\n\t\tvec3  o = texture(iChannel1, (i + g)* 0.5/64.+ 0.5*t).rgb;\n\t\tvec2  d = g - f + o.xy;\n\t\tfloat w = pow( 1.0-smoothstep(0.0,1.414,length(d)), k );\n\t\ta += vec2(o.z*w,w);\n    }\n    return a.x/a.y;\n}\nvec3 calcFlatClouds(positionStruct pos,in vec3 color, in vec3 sunColor)\n{\n    float distance_metric = tan(0.4*3.1415926*length(pos.worldVector.xz))+1.;\n    vec2 p = distance_metric*pos.worldVector.xz*24.;\n    float time_metric = 0.1*(iTime+0.);\n\n    vec2 un = vec2(0.01,0.00432)*p;\n    float mixer = .8-length(sin(un+vec2(0.+0.005*time_metric))+sin(un+vec2(2.+0.005*time_metric)));\n\t\n    return mix(color,10.*sunColor,smoothstep(0.9-smoothstep(0.,1.3,abs(mixer)),1.1,mix(voronoise(p*10., 0.),voronoise(p, time_metric),0.7)));\n}\nvec3 getSky(in positionStruct pos )\n{\n    \n    float dither = bayer16(pos.texcoord*iResolution.xy);\n    \n    vec3 lightAbsorb = vec3(0.0);\n\n    vec3 color = vec3(0.0);\n         color = calcAtmosphericScatter(pos, lightAbsorb);\n#if CLOUDS\n         color = calcFlatClouds(pos, color, lightAbsorb);\n         color = calculateVolumetricClouds(pos, color, dither, lightAbsorb);\n#endif\n\n    return color;\n}\n\nfloat hash( vec2 p ) {\n    return fract(sin(dot(p,vec2(1177.1,2711.7)))*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f * f * (3.0-2.0 * f);\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nfloat wv(in vec2 uv, vec2 d, float t, float A)\n{\n    return sin ( dot(d, uv) / 4.0 + t) * A;\n}\n\n// water\nfloat fbm(in vec2 uv, float lod)\n{\t\n    float f =  textureLod(iChannel2, uv, lod).r * 0.5;\n    \t  f += textureLod(iChannel2, uv*2.0, lod).r * 0.5*0.5;\n    \t  f += textureLod(iChannel2, uv*4.0, lod).r * 0.5*0.5*0.5;\n    \t  f += textureLod(iChannel2, uv*8.0, lod).r * 0.5*0.5*0.5*0.5;\n\n    f = f*f*f*f;\n    return f;\n}\nmat2 m2 = mat2(1.6,-1.2,1.2,1.6);\nfloat noiseo(vec2 p)\n{\n  return textureLod(iChannel0,p*vec2(1./256.),0.0).x;\n}\n// Fractional Brownian motion\nfloat fbm( vec2 p )\n{\n  float f = 0.5000*noiseo( p ); p = m2*p;\n  f += 0.2500*noiseo( p ); p = m2*p;\n  f += 0.1666*noiseo( p ); p = m2*p;\n  f += 0.0834*noiseo( p );\n  return f;\n}\nfloat wavesLo(const in vec3 rp, float t, float A)\n{\n    vec2 p = rp.xz*100.1;\n    \n  vec2 shift2 = 0.001*vec2( iTime*190.0*2.0, -iTime*130.0*2.0 );\n    \n  // coarse crossing 'ocean' waves...\n  float wave = 0.0;\n  wave += sin(p.x*0.021  + shift2.x)*4.5;\n  wave += sin(p.x*0.0172+p.y*0.010 + shift2.x*1.121)*4.0;\n  wave -= sin(p.x*0.00104+p.y*0.005 + shift2.x*0.121)*4.0;\n  // ...added by some smaller faster waves...\n  wave += sin(p.x*0.02221+p.y*0.01233+shift2.x*3.437)*5.0;\n  wave += sin(p.x*0.03112+p.y*0.01122+shift2.x*4.269)*2.5 ;\n  wave *= 0.01;//large_waveheight;\n  //wave -= fbm(p*0.004-shift2*.5)*small_waveheight*24.;\n  return wave;\n}\n\n// high detail waves\n\nfloat waves(const in vec3 rp, float t, float A)\n{\n\n    float small_waveheight = 0.015;\n      vec2 shift1 = 0.001*vec2( iTime*160.0*2.0, iTime*120.0*2.0 );\n    vec2 p = rp.xz;\n  float amp = 6.*small_waveheight;\n  shift1 *= .3;\n    float wave = 0.0;\n  for (int i=0; i<6; i++)\n  {\n    wave -= abs(sin((noise(p*1.1+shift1)-.5)*3.14))*amp;\n    amp *= .51;\n    shift1 *= 1.841;\n    p *= m2*0.9331;\n  }\n    return wavesLo(rp, t, A) + wave;// +w3+w4+w7+w8+w5+w6;\n}\n\nfloat mapLo(in vec3 rp)\n{\n    return rp.y - wavesLo(rp, 2.0+iTime*.5, .04);\n}\n\n\nfloat map(in vec3 rp)\n{\n    return rp.y - waves(rp, 2.0+iTime*.5, .04);\n}\n\n\nvec3 grad(vec3 rp, float preci)\n{\n    vec2 off = vec2(preci, 0.0);\n    vec3 g = vec3(map(rp + off.xyy) - map(rp - off.xyy),\n\t\t\t\t  map(rp + off.yxy) - map(rp - off.yxy),                  \n\t\t\t\t  map(rp + off.yyx) - map(rp - off.yyx));\n    return normalize(g);\n}\n\n// scanning the surroundings for differences in heights on the heightmap\nvec2 sub(vec3 rp, float preci)\n{\n    vec2 off = vec2(preci, 0.0);\n    vec2 g = vec2(map(rp + off.xyy) + map(rp - off.xyy),\n\t\t\t\t  map(rp + off.yyx) + map(rp - off.yyx));\n    return g;\n}\n\n\n\n\nconst vec3 up = vec3(0.0, 1.0, 0.0);\n\n\nvoid trace(in positionStruct pos, in vec3 rp, in vec3 rd, inout vec4 color)\n{\n    \n    if (dot(rd, up)>0.0){\n        color.rgb = getSky(pos);\n        return;\n    }\n    \n    // trace to plane on top of waves\n    vec3 ro = rp;\n    float t = -(0.155+dot(rp, -up)) / dot(-up, rd);\n    if (t < 0.0) \n    {\n        return;\n    }\n    \n\trp += rd*t;    \n    bool hit = false;\n    float dist = 0.0;\n    \n    // actual tracing\n    \n    // low freq\n    for (int i = 0; i < 10; ++i)\n    {\n        float travelledSq=dot(ro-rp, ro-rp);\n        dist = mapLo(rp);\n        \n        if(dist < 0.01)\n        {\n            hit = true;\n            break;\n        }\n        rp += rd * max(dist * (log2(2.+travelledSq)), 0.01);\n        if(travelledSq > 9000.0) break;\n    }\n    \n    //detail tracing\n    for (int i = 0; i < 10; ++i)\n    {\n        rp += dist * rd;\n        if (abs(dist) < 0.0001) break;\n        dist = map(rp);\n    }\n    \n    // shadings    \n        vec3 sun = pos.sunVector;\n        vec3 g = grad(rp, 0.002 * (1.0+log2(length(ro-rp) * 100.)));\n        /*vec3 tg =  texGrad (rp.xz*5.1 + vec2(-iTime*.015, iTime*.06));\n        vec3 tg2 = texGrad (rp.xz*6.2 + vec2( iTime*.01,  -iTime*.06));\n        tg = normalize(tg+tg2);\n        tg = normalize(tg+texGrad(rp.xz*4.2 + vec2( iTime*.01, iTime*.05))*0.3);*/\n        \n        //vec3 sg = grad(rp, 0.001);\n        //sg = normalize(sg+tg*.3);\n        // base color\n        pos.worldVector = rd-2.*dot(rd, g)*g;\n        pos.worldVector = normalize(pos.worldVector);\n        float F = clamp(max(0.0, 1.+dot(rd, g)), 0.0, 1.);\n        vec3 water_color = 0.5*vec3(.05, 0.22, .4);\n\n        color.rgb = F* getSky(pos) + (1.-F)*water_color;\n        /*\n        // diffuse\n        float d = max(0.0, dot(g, sun));\n        //color *= mix(1.0, d, .4);\n        \n        // top\n        vec2 heights = sub(rp, 0.3);\n        float sst = length(max(vec2(0.00001), heights));\n        float sunD = -1.*(dot(sun, g));\n        //color.rgb = mix(color.rgb, vec3(.2, 0.5, 0.72)*.5, smoothstep(0., .4, sunD));\n        \n        // bottom\n        float ssb = length(min(vec2(0.0), heights));\n        //color.rgb = mix(color.rgb, vec3(.05, 0.22, .4)*.5, smoothstep(0.0, 0.4, ssb));\n        */\n        // foam\n        /*vec3 pw = vec3(1.+2.3/(sst*1.+.001))*2.2;\n        vec3 texcol1 = texture(iChannel2, rp.xz*.5+vec2(.0, .07*iTime)).rgb;\n        \n        vec3 pw2 = vec3(1.+.7/(sst*1.2+.01));\n        vec3 texcol2 = texture(iChannel2, rp.xz*.5+vec2(.0, .07*iTime)).rgb*1.;\n        \n        vec3 foam = max(pow(texcol1, pw).rrr, pow(texcol2, pw2).rrr);\n        if(foam.r>.3){\n        color.rgb = foam*3.;\n        }*/\n        \n        // fresnel\n        vec3 H = normalize(-rd + normalize(sun));\n\n\n    \n    color.a = 1.;//length(ro-rp);\n    \n}\n\n\nmat3 lookat(vec3 from, vec3 to)\n{\n    vec3 f = normalize(to - from);\n    vec3 _tmpr = normalize(cross(f, vec3(0.0, .999, 0.0)));\n    vec3 u = normalize(cross(_tmpr, f));\n    vec3 r = normalize(cross(u, f));\n    return mat3(r, u, f);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    gatherPositions(pos, fragCoord, iMouse.xy, iResolution.xy);\n;\n    vec2 uv = (fragCoord.xy-iResolution.xy*.5) / iResolution.x;\n    \n    //ray direction \n    vec3 rd = pos.worldPosition;\n    \n    //ray position\n    vec3 rp = vec3(0.0, 2.3, 0.0);\n    vec3 _rp = rp;\n\t    \n    trace(pos, rp, rd, fragColor);\n    vec3 color = fragColor.rgb;\n    color = pow(color, vec3(1.0 / 2.2)); //Fitting to regular colorspace\n    color = robobo1221Tonemap(color);\n    fragColor.rgb = clamp(color, 0.0, 1.0);\n}", "buffer_b_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define VOLUMETRIC_LIGHT\n//#define SPHERICAL_PROJECTION\n\n#define cameraMode 1 \t\t\t\t\t//1 is free rotation, 2 is still camera but free sun rotation\n\n\n//////////////////////////////////////////////////////////////////\n\nfloat bayer2(vec2 a){\n    a = floor(a);\n    return fract( dot(a, vec2(.5, a.y * .75)) );\n}\n\nvec2 rsi(vec3 position, vec3 direction, float radius) {\n    float PoD = dot(position, direction);\n    float radiusSquared = radius * radius;\n\n    float delta = PoD * PoD + radiusSquared - dot(position, position);\n    if (delta < 0.0) return vec2(-1.0);\n          delta = sqrt(delta);\n\n    return -PoD + vec2(-delta, delta);\n}\n\n#define bayer4(a)   (bayer2( .5*(a))*.25+bayer2(a))\n#define bayer8(a)   (bayer4( .5*(a))*.25+bayer2(a))\n#define bayer16(a)  (bayer8( .5*(a))*.25+bayer2(a))\n#define bayer32(a)  (bayer16(.5*(a))*.25+bayer2(a))\n#define bayer64(a)  (bayer32(.5*(a))*.25+bayer2(a))\n#define bayer128(a) (bayer64(.5*(a))*.25+bayer2(a))\n\n//////////////////////////////////////////////////////////////////\n\n#define cloudMinHeight cloudHeight\n#define cloudMaxHeight (cloudThickness + cloudMinHeight)\n\n#define sunPosition vec3(1.0, 0.9, 0.0)\n\nconst float pi = acos(-1.0);\nconst float rPi = 1.0 / pi;\nconst float hPi = pi * 0.5;\nconst float tau = pi * 2.0;\nconst float rLOG2 = 1.0 / log(2.0);\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    float xx = axis.x * axis.x;\n    float yy = axis.y * axis.y;\n    float zz = axis.z * axis.z;\n    \n    float xy = axis.x * axis.y;\n    float xz = axis.x * axis.z;\n    float zy = axis.z * axis.y;\n    \n    return mat3(oc * xx + c, oc * xy - axis.z * s, oc * xz + axis.y * s,\n                oc * xy + axis.z * s, oc * yy + c, oc * zy - axis.x * s, \n                oc * xz - axis.y * s, oc * zy + axis.x * s, oc * zz + c);\n}\n#define PI 3.14159265358\n\nmat3 rotx(float a) { return rotationMatrix(vec3(1.,0.,0.), a); }\nmat3 roty(float a) { return rotationMatrix(vec3(0.,1.,0.), a); }\nmat3 rotz(float a) { return rotationMatrix(vec3(0.,0.,1.), a); }\n\nstruct positionStruct\n{\n\tvec2 texcoord;\n    vec2 mousecoord;\n    vec3 worldPosition;\n    vec3 worldVector;\n    vec3 sunVector;\n} pos;\n\nvec3 sphereToCart(vec3 sphere) {\n    vec2 c = cos(sphere.xy);\n    vec2 s = sin(sphere.xy);\n    \n    return sphere.z * vec3(c.x * c.y, s.y, s.x * c.y);\n}\n\nvec3 calculateWorldSpacePosition(vec2 p)\n{\n\tp = p * 2.0 - 1.0;\n    \n    vec3 worldSpacePosition =  vec3(p.x, p.y, 1.0);\n    \n    #ifdef SPHERICAL_PROJECTION\n\t\tworldSpacePosition = sphereToCart(worldSpacePosition * vec3(pi, hPi, 1.0));\n\t#endif\n    \n    return worldSpacePosition;\n}\n\nvoid gatherPositions(inout positionStruct pos, vec2 fragCoord, vec2 mouseCoord, vec2 screenResolution)\n{\n\tpos.texcoord = fragCoord / screenResolution;\n    pos.mousecoord = mouseCoord / screenResolution;\n    \n    pos.mousecoord = pos.mousecoord.x < 0.001 ? vec2(0.4, 0.64) : pos.mousecoord;\n    \n    vec2 rotationAngle = radians(vec2(360.0, 180.0) * pos.mousecoord - vec2(0.0, 90.0));\n\n    \n    mat3 rotateH = rotationMatrix(vec3(0.0, 1.0, 0.0), rotationAngle.x);\n    mat3 rotateV = rotationMatrix(vec3(1.0, 0.0, 0.0), -rotationAngle.y);\n    \n    pos.worldPosition = calculateWorldSpacePosition(pos.texcoord);\n    \n    if (cameraMode == 1) {\n    \tpos.worldPosition = rotateH * (rotateV * pos.worldPosition);\n        \n        // Sun position\n    \tpos.sunVector = normalize(sunPosition);\n    }\n    if (cameraMode == 2) {\n    \tpos.sunVector = normalize(calculateWorldSpacePosition(pos.mousecoord));\n    }\n    \n    pos.worldVector = normalize(pos.worldPosition);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slfSWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 143]], "test": "untested"}
{"id": "slXXD4", "name": "Analytical Integrated Light", "author": "oneshade", "description": "I think I finally am getting the hang of integration by substitution. At least well enough to integrate a volumetric light with some inversesquareish falloff :) Move around with the arrow keys and mouse.", "tags": ["3d", "light", "volumetric", "integration", "inversesquare"], "likes": 18, "viewed": 475, "published": 3, "date": "1625688786", "time_retrieved": "2024-07-30T19:11:50.024877", "image_code": "// Desmos graph (not very functional, just the workthrough):\n// https://www.desmos.com/calculator/lrcijiosth\n//\n// Left: analytically integrated\n// Right: numerically integrated\n//\n// The only difference I notice is that the numerically\n// integrated one flickers as you move the camera due to\n// it missing some areas between steps which creates some\n// inconsistency as the ray moves.\n//\n// Some parts of the calculations look suspiciously\n// like the quadratic formula simplified for a sphere\n// intersection.\n//\n// The functions below are just specializations for different cases.\n// Feel free to use any of them (as long as you give credit of course :)).\n\n// Indefinite integral of the light volume over the ray at t\n// Lighting at distance x is k/(1+(x/d)^2)\n// k: brightness\n// d: spread/diffusion\nfloat integrateLightIndefinite(in vec3 ro, in vec3 rd, in float k, in float d, in float t) {\n    float a = dot(rd, rd);\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) + d * d;\n    float h = sqrt(a * c - b * b);\n    return d * d * k * atan((a * t + b) / h) / h;\n}\n\n// Definite integral of the light volume over any finite segment of the ray (ta to tb)\nfloat integrateLightDefinite(in vec3 ro, in vec3 rd, in float k, in float d, in float ta, in float tb) {\n    float a = dot(rd, rd);\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) + d * d;\n    float h = sqrt(a * c - b * b);\n    float ah = a / h, bh = b / h;\n    return d * d * k * (atan(ah * tb + bh) - atan(ah * ta + bh)) / h;\n}\n\n// Definite integral of the light volume over a partial view of the ray (0 to t)\nfloat integrateLightPartialView(in vec3 ro, in vec3 rd, in float k, in float d, in float t) {\n    float a = dot(rd, rd);\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) + d * d;\n    float h = sqrt(a * c - b * b), r = b / h;\n    return d * d * k * (atan(a * t / h + r) - atan(r)) / h;\n}\n\n// Definite integral of the light volume over the entire view of the ray (0 to ∞)\n// I computed the limit based on the fact that atan() approaches π/2 (90 degrees)\n// as x (the ratio of y over x) goes to infinity\nfloat integrateLightFullView(in vec3 ro, in vec3 rd, in float k, in float d) {\n    float a = dot(rd, rd);\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) + d * d;\n    float h = sqrt(a * c - b * b);\n    return d * d * k * (RHO - atan(b / h)) / h;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    fragColor = vec4(0.0);\n\n    // Camera ray\n    vec2 viewDir = ivec2(iMouse.xy) == ivec2(0) ? vec2(0.0) : (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y * TAU * ROTATION_SPEED;\n    mat3 cam = getCamera(viewDir);\n\n    vec3 ro = getPosition();\n    vec3 rd = normalize(cam[0] * uv.x + cam[1] * uv.y + cam[2]);\n\n    // Analytically integrated light on left\n    float k = 0.8, d = 0.6;\n    vec3 lightColor = vec3(1.0, 0.75, 0.15);\n\n    fragColor.rgb += integrateLightFullView(ro, rd, k, d) * lightColor;\n    //fragColor.rgb += integrateLightPartialView(ro, rd, k, d, 1000000.0) * lightColor;\n\n    // Numerically integrated light on right\n    if (uv.x > 0.0) {\n        fragColor = vec4(0.0);\n        float tMax = 100.0;\n        float dt = tMax / 100.0;\n        for (float t=0.0; t < tMax; t += dt) {\n            vec3 p = ro + rd * t;\n            fragColor.rgb += k / (1.0 + dot(p, p) / (d * d)) * dt; // Naive euler integration\n        }\n\n        fragColor.rgb *= lightColor;\n    }\n\n    // Divider\n    float unit = 2.0 / iResolution.y;\n    fragColor.rgb = mix(fragColor.rgb, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(uv.x) - 0.001));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Constants\n#define TAU 6.28318530718\n#define RHO 1.57079632679\n\n// Camera control\n#define STEP_SIZE 0.1\n#define ROTATION_SPEED 0.5\n\n// Key codes from iq's keyboard input demo (https://www.shadertoy.com/view/lsXGzf):\n#define KEY_UP 38\n#define KEY_DOWN 40\n#define KEY_RIGHT 39\n#define KEY_LEFT 37\n\n#define getPosition() texelFetch(iChannel0, ivec2(0), 0).xyz\n\n#define keyUpPressed() bool(texelFetch(iChannel1, ivec2(38, 0), 0).x)\n#define keyDownPressed() bool(texelFetch(iChannel1, ivec2(40, 0), 0).x)\n#define keyRightPressed() bool(texelFetch(iChannel1, ivec2(39, 0), 0).x)\n#define keyLeftPressed() bool(texelFetch(iChannel1, ivec2(37, 0), 0).x)\n\n// Camera matrix\nmat3 getCamera(in vec2 viewDir) {\n    vec2 c = cos(viewDir); vec2 s = sin(viewDir);\n    return mat3(       c.x, 0.0,         s.x,  // Right\n                s.x * -s.y, c.y, -c.x * -s.y,  // Up\n                s.x *  c.y, s.y, -c.x *  c.y); // Forward\n}", "buffer_a_code": "// Camera position buffer\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 5.0, 0.0);\n    if (iFrame > 0) {\n        ivec2 addr = ivec2(fragCoord);\n        if (addr == ivec2(0)) {\n            fragColor = vec4(getPosition(), 1.0);\n\n            vec2 viewDir = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y * TAU * ROTATION_SPEED;\n            mat3 cam = getCamera(viewDir);\n\n            if (keyUpPressed()) fragColor.xyz += cam[2] * STEP_SIZE;\n            if (keyDownPressed()) fragColor.xyz -= cam[2] * STEP_SIZE;\n            if (keyRightPressed()) fragColor.xyz += cam[0] * STEP_SIZE;\n            if (keyLeftPressed()) fragColor.xyz -= cam[0] * STEP_SIZE;\n        }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slXXD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[661, 805, 897, 897, 1073], [1075, 1162, 1266, 1266, 1496], [1498, 1579, 1672, 1672, 1869], [1871, 2087, 2165, 2165, 2339], [2341, 2341, 2396, 2396, 3629]], "test": "untested"}
{"id": "stXSDH", "name": "Cirrus clouds over the ocean", "author": "jhylands", "description": "Using Cirrus clouds to try and get a quicker shader than with volumetric ", "tags": ["sea", "sun", "clouds", "fbm", "water", "cirrus"], "likes": 7, "viewed": 692, "published": 3, "date": "1625672592", "time_retrieved": "2024-07-30T19:11:50.981319", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n    \n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*\nReal time PBR Volumetric Clouds by robobo1221.\nSingle scattering\nAlso includes volumetric light.\nhttp://shadertoy.com/user/robobo1221\n\nFirst ever somewhat PBR effect I decided to work on.\nIt uses the same algorithm to calculate the worldPosition as in: https://www.shadertoy.com/view/lstfR7\n\nFeel free to fork and edit it. (Credit me please.)\nHope you enjoy!\n*/\n\n\n#define cloudSpeed 0.02\n#define cloudHeight 1000.0\n#define cloudThickness 1000.0\n#define cloudDensity 0.01\n\n#define fogDensity 0.0001\n\n#define volumetricCloudSteps 32\t\t\t//Higher is a better result with rendering of clouds.\n#define volumetricLightSteps 1\t\t\t//Higher is a better result with rendering of volumetric light.\n\n#define cloudShadowingSteps 1\t\t\t//Higher is a better result with shading on clouds.\n\n\n#define rayleighCoeff (vec3(0.27, 0.5, 1.0) * 1e-5)\t//Not really correct\n#define mieCoeff vec3(0.5e-6)\t\t\t\t\t\t//Not really correct\n\nconst float sunBrightness = 10.0;\n\n#define earthRadius 6371000.0\n\n\n\n///////////////////////////////////////////////////////////////////////////////////\n\n#define d0(x) (abs(x)+ 1e-8 )\n#define d02(x) (abs(x) + 1e-3)\n\nconst vec3 totalCoeff = rayleighCoeff + mieCoeff;\n\nvec3 scatter(vec3 coeff, float depth){\n\treturn coeff * depth;\n}\n\nvec3 absorb(vec3 coeff, float depth){\n\treturn exp2(scatter(coeff, -depth));\n}\n\nfloat calcParticleThickness(float depth){\n   \t\n    depth = depth * 2.0;\n    depth = max(depth + 0.01, 0.01);\n    depth = 1.0 / depth;\n    \n\treturn 100000.0 * depth;   \n}\n\nfloat calcParticleThicknessH(float depth){\n   \t\n    depth = depth * 2.0 + 0.1;\n    depth = max(depth + 0.01, 0.01);\n    depth = 1.0 / depth;\n    \n\treturn 100000.0 * depth;   \n}\n\nfloat calcParticleThicknessConst(const float depth){\n    \n\treturn 100000.0 / max(depth * 2.0 - 0.01, 0.1);   \n}\n\nfloat rayleighPhase(float x){\n\treturn 0.375 * (1.0 + x*x);\n}\n\nfloat hgPhase(float x, float g)\n{\n    float g2 = g*g;\n\treturn 0.25 * ((1.0 - g2) * pow(1.0 + g2 - 2.0*g*x, -1.5));\n}\n\nfloat miePhaseSky(float x, float depth)\n{\n \treturn hgPhase(x, exp2(-0.000003 * depth));\n}\n\nfloat powder(float od)\n{\n\treturn 1.0 - exp2(-od * 2.0);\n}\n\nfloat calculateScatterIntergral(float opticalDepth, float coeff){\n    float a = -coeff * rLOG2;\n    float b = -1.0 / coeff;\n    float c =  1.0 / coeff;\n\n    return exp2(a * opticalDepth) * b + c;\n}\n\nvec3 calculateScatterIntergral(float opticalDepth, vec3 coeff){\n    vec3 a = -coeff * rLOG2;\n    vec3 b = -1.0 / coeff;\n    vec3 c =  1.0 / coeff;\n\n    return exp2(a * opticalDepth) * b + c;\n}\n\n\nvec3 calcAtmosphericScatter(positionStruct pos, out vec3 absorbLight){\n    const float ln2 = log(2.0);\n    \n    float lDotW = dot(pos.sunVector, pos.worldVector);\n    float lDotU = dot(pos.sunVector, vec3(0.0, 1.0, 0.0));\n    float uDotW = dot(vec3(0.0, 1.0, 0.0), pos.worldVector);\n    if(uDotW<0.){\n     uDotW=0.5;\n    }\n    \n\tfloat opticalDepth = calcParticleThickness(uDotW);\n    float opticalDepthLight = calcParticleThickness(lDotU);\n    \n    vec3 scatterView = scatter(totalCoeff, opticalDepth);\n    vec3 absorbView = absorb(totalCoeff, opticalDepth);\n    \n    vec3 scatterLight = scatter(totalCoeff, opticalDepthLight);\n         absorbLight = absorb(totalCoeff, opticalDepthLight);\n    \t \n    vec3 absorbSun =  abs(absorbLight - absorbView) / d0((scatterLight - scatterView) * ln2);\n    \n    vec3 mieScatter = scatter(mieCoeff, opticalDepth) * miePhaseSky(lDotW, opticalDepth);\n    vec3 rayleighScatter = scatter(rayleighCoeff, opticalDepth) * rayleighPhase(lDotW);\n    \n    vec3 scatterSun = mieScatter + rayleighScatter;\n    \n    vec3 sunSpot = smoothstep(0.9999, 0.99993, lDotW) * absorbView * sunBrightness;\n    \n    return (scatterSun * absorbSun + sunSpot) * sunBrightness;\n}\n\nvec3 calcAtmosphericScatterTop(positionStruct pos){\n    const float ln2 = log(2.0);\n    \n    float lDotU = dot(pos.sunVector, vec3(0.0, 1.0, 0.0));\n    \n\tfloat opticalDepth = calcParticleThicknessConst(2.5);\n    float opticalDepthLight = calcParticleThickness(lDotU);\n    \n    vec3 scatterView = scatter(totalCoeff, opticalDepth);\n    vec3 absorbView = absorb(totalCoeff, opticalDepth);\n    \n    vec3 scatterLight = scatter(totalCoeff, opticalDepthLight);\n    vec3 absorbLight = absorb(totalCoeff, opticalDepthLight);\n    \n    vec3 absorbSun = d02(absorbLight - absorbView) / d02((scatterLight - scatterView) * ln2);\n    \n    vec3 mieScatter = scatter(mieCoeff, opticalDepth) * 0.25;\n    vec3 rayleighScatter = scatter(rayleighCoeff, opticalDepth) * 0.375;\n    \n    vec3 scatterSun = mieScatter + rayleighScatter;\n    \n    return (scatterSun * absorbSun) * sunBrightness;\n}\n\nfloat Get3DNoise(vec3 pos) \n{\n    //return 1.;\n    float p = floor(pos.z);\n    float f = pos.z - p;\n    \n    const float invNoiseRes = 1.0 / 64.0;\n    \n    float zStretch = 17.0 * invNoiseRes;\n    \n    vec2 coord = pos.xy * invNoiseRes + (p * zStretch);\n    \n    vec2 noise = vec2(texture(iChannel3, coord).x,\n\t\t\t\t\t  texture(iChannel3, coord + zStretch).x);\n    \n    return mix(noise.x, noise.y, f);\n}\n\nfloat getClouds(vec3 p)\n{\n    p = vec3(p.x, length(p + vec3(0.0, earthRadius, 0.0)) - earthRadius, p.z);\n\n    \n    \n    float time = iTime * cloudSpeed;\n    vec3 movement = vec3(time, 0.0, time);\n    \n    vec3 cloudCoord = (p * 0.001) + movement;\n    vec4 noise_weight = vec4(0.5, 0.25, 0.125, 0.0625);\n\tvec4 noise = vec4(\n            Get3DNoise(cloudCoord),\n    \t  Get3DNoise(cloudCoord * 2.0 + movement),\n    \t  Get3DNoise(cloudCoord * 7.0 - movement),\n    \t  Get3DNoise((cloudCoord + movement) * 16.0));\n        \n    //noise *= 1./0.8;\n    const float top = 0.004;\n    const float bottom = 0.01;\n    \n    float horizonHeight = p.y - cloudMinHeight;\n    float treshHold = (1.0 - exp2(-bottom * horizonHeight)) * exp2(-top * horizonHeight);\n    \n    float clouds = smoothstep(0.55, 0.6, dot(noise, noise_weight));\n          clouds *= treshHold;\n    \n    return clouds * cloudDensity;\n}\n\n\nfloat getSunVisibility(vec3 p, positionStruct pos)\n{\n\tconst int steps = cloudShadowingSteps;\n    const float rSteps = cloudThickness / float(steps);\n    \n    vec3 increment = pos.sunVector * rSteps;\n    vec3 position = increment * 0.5 + p;\n    \n    float transmittance = 0.0;\n    \n    for (int i = 0; i < steps; i++, position += increment)\n    {\n\t\ttransmittance += getClouds(position);\n    }\n    \n    return exp2(-transmittance * rSteps);\n}\n\nfloat phase2Lobes(float x)\n{\n    const float m = 0.6;\n    const float gm = 0.8;\n    \n\tfloat lobe1 = hgPhase(x, 0.8 * gm);\n    float lobe2 = hgPhase(x, -0.5 * gm);\n    \n    return mix(lobe2, lobe1, m);\n}\n\nvec3 getVolumetricCloudsScattering(\n    float opticalDepth, float phase, vec3 p, vec3 sunColor, vec3 skyLight, positionStruct pos)\n{\n    float intergal = calculateScatterIntergral(opticalDepth, 1.11);\n    \n    float beersPowder = powder(opticalDepth * log(2.0));\n    \n\tvec3 sunlighting = (sunColor * getSunVisibility(p, pos) * beersPowder) * phase * hPi * sunBrightness;\n    vec3 skylighting = skyLight * 0.25 * rPi;\n    \n    return (sunlighting + skylighting) * intergal * pi;\n}\n\nfloat getHeightFogOD(float height)\n{\n\tconst float falloff = 0.001;\n    \n    return exp2(height * falloff) * fogDensity;\n}\n\n\nvec3 calculateVolumetricClouds(positionStruct pos, vec3 color, float dither, vec3 sunColor)\n{\n\tconst int steps = volumetricCloudSteps;\n    const float iSteps = 1.0 / float(steps);\n    \n    if (pos.worldVector.y < 0.0)\n       return color;\n    \n    float bottomSphere = rsi(vec3(0.0, 1.0, 0.0) * earthRadius, pos.worldVector, earthRadius + cloudMinHeight).y;\n    float topSphere = rsi(vec3(0.0, 1.0, 0.0) * earthRadius, pos.worldVector, earthRadius + cloudMaxHeight).y;\n    \n    vec3 startPosition = pos.worldVector * bottomSphere;\n    vec3 endPosition = pos.worldVector * topSphere;\n    \n    vec3 increment = (endPosition - startPosition) * iSteps;\n    vec3 cloudPosition = increment * dither + startPosition;\n    \n    float stepLength = length(increment);\n    \n    vec3 scattering = vec3(0.0);\n    float transmittance = 1.0;\n    \n    float lDotW = dot(pos.sunVector, pos.worldVector);\n    float phase = phase2Lobes(lDotW);\n    \n    vec3 skyLight = calcAtmosphericScatterTop(pos);\n    \n    for (int i = 0; i < steps; i++, cloudPosition += increment)\n    {\n        float opticalDepth = getClouds(cloudPosition) * stepLength;\n        \n        if (opticalDepth <= 0.0)\n            continue;\n        \n\t\tscattering += getVolumetricCloudsScattering(opticalDepth, phase, cloudPosition, sunColor, skyLight, pos) * transmittance;\n        transmittance *= exp2(-opticalDepth);\n    }\n    \n    return mix(color * transmittance + scattering, color, clamp(length(startPosition) * 0.00001, 0.0, 1.0));\n}\n\nvec3 robobo1221Tonemap(vec3 color)\n{\n    #define rTOperator(x) (x / sqrt(x*x+1.0))\n\n    float l = length(color);\n\n    color = mix(color, color * 0.5, l / (l+1.0));\n    color = rTOperator(color);\n\n    return color;\n}\nfloat voronoise( in vec2 p, in float t_metric)\n{\n    const vec2 temp = 0.5 - 0.5 * -1.8*vec2(1.0,0.5) ;\n    const float u = temp.x;\n    const float v = temp.y;\n\tfloat k = 1.0+63.0*pow(1.0-v,6.0);\n    \n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 t = 10.*vec2(cos(0.001*t_metric), cos(0.002*t_metric+0.34));\n\tvec2 a = vec2(0.0,0.0);\n    const int stepr = 2;\n    for( int y=-stepr; y<=stepr; y++ )\n    for( int x=-stepr; x<=stepr; x++ )\n    {\n        vec2  g = vec2( x, y );\n\t\tvec3  o = texture(iChannel1, (i + g)* 0.5/64.+ 0.5*t).rgb;\n\t\tvec2  d = g - f + o.xy;\n\t\tfloat w = pow( 1.0-smoothstep(0.0,1.414,length(d)), k );\n\t\ta += vec2(o.z*w,w);\n    }\n    return a.x/a.y;\n}\nvec3 calcFlatClouds(positionStruct pos,in vec3 color, in vec3 sunColor)\n{\n    float distance_metric = tan(0.4*3.1415926*length(pos.worldVector.xz))+1.;\n    vec2 p = distance_metric*pos.worldVector.xz*24.;\n    float time_metric = 0.1*(iTime+0.);\n\n    vec2 un = vec2(0.01,0.00432)*p;\n    float mixer = .8-length(sin(un+vec2(0.+0.005*time_metric))+sin(un+vec2(2.+0.005*time_metric)));\n\t\n    return mix(color,10.*sunColor,smoothstep(0.9-smoothstep(0.,1.3,abs(mixer)),1.1,mix(voronoise(p*10., 0.),voronoise(p, time_metric),0.7)));\n}\nvec3 getSky(in positionStruct pos )\n{\n    \n    float dither = bayer16(pos.texcoord*iResolution.xy);\n    \n    vec3 lightAbsorb = vec3(0.0);\n\n    vec3 color = vec3(0.0);\n         color = calcAtmosphericScatter(pos, lightAbsorb);\n         color = calcFlatClouds(pos, color, lightAbsorb);\n         //color = calculateVolumetricClouds(pos, color, dither, lightAbsorb);\n\n    return color;\n}\n\nfloat hash( vec2 p ) {\n    return fract(sin(dot(p,vec2(1177.1,2711.7)))*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f * f * (3.0-2.0 * f);\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nfloat wv(in vec2 uv, vec2 d, float t, float A)\n{\n    return sin ( dot(d, uv) / 4.0 + t) * A;\n}\n\n// water\nfloat fbm(in vec2 uv, float lod)\n{\t\n    float f =  textureLod(iChannel2, uv, lod).r * 0.5;\n    \t  f += textureLod(iChannel2, uv*2.0, lod).r * 0.5*0.5;\n    \t  f += textureLod(iChannel2, uv*4.0, lod).r * 0.5*0.5*0.5;\n    \t  f += textureLod(iChannel2, uv*8.0, lod).r * 0.5*0.5*0.5*0.5;\n\n    f = f*f*f*f;\n    return f;\n}\n\nfloat wavesLo(const in vec3 rp, float t, float A, float lod)\n{\n    vec2 uv = rp.xz;\n    \n    //uv.y += pow(max(rp.y + 0.4, 0.0), 10.) * 1.5;\n    float w00 = noise(uv * 1.2 * vec2(.2,  2.2) + vec2(0.20 * t, t * 1.));\n    float w03 = noise(uv * 1.2 * vec2(1.2,  .6) + vec2(1.* t, t * .3));\n    float w01 = fbm(uv*.05+vec2(iTime*.01, 0.), lod);\n    float w02 = fbm(uv*.1 +vec2(iTime*.006, iTime*.0024), lod);\n    return w00*.12+w01*.1+w02*0.1+w03*.1;\n}\n\n// high detail waves\nfloat waves(const in vec3 rp, float t, float A)\n{\n    vec2 uv = rp.xz;\n    vec2 nuv2 = uv+0.05*vec2(noise(uv*5.-t*.03), noise(uv*2.+t*.04));\n    \n    float w3 = wv(nuv2 * 170.0, vec2( -0.1, 0.6), t * 4.5, A) * 0.03;\n\tfloat w4 = wv(nuv2 * 170.0, vec2( 0.1, 0.6) , t * 6.,  A) * 0.03;\n    float w7 = wv(nuv2 * 570.0, vec2( 0.05, 0.4), t * 15., A) * 0.02;\n    float w8 = wv(nuv2 * 570.0, vec2( -0.05, 0.3) , t * 15.,  A) * 0.02;\n    float w5 = -wv(nuv2 * 1670.0, vec2(-0.1, 0.4), t * 63., A) * 0.007;\n    float w6 = -wv(nuv2 * 1670.0, vec2( 0.1, 0.5) ,  t * 63.,  A) * 0.007;\n    \n    return wavesLo(rp, t, A, 0.0) +w3+w4+w7+w8+w5+w6;\n}\n\nfloat mapLo(in vec3 rp)\n{\n    return rp.y - wavesLo(rp, 2.0+iTime*.5, .04, 4.0);\n}\n\n\nfloat map(in vec3 rp)\n{\n    return rp.y - waves(rp, 2.0+iTime*.5, .04);\n}\n\n\nvec3 grad(vec3 rp, float preci)\n{\n    vec2 off = vec2(preci, 0.0);\n    vec3 g = vec3(map(rp + off.xyy) - map(rp - off.xyy),\n\t\t\t\t  map(rp + off.yxy) - map(rp - off.yxy),                  \n\t\t\t\t  map(rp + off.yyx) - map(rp - off.yyx));\n    return normalize(g);\n}\n\n// scanning the surroundings for differences in heights on the heightmap\nvec2 sub(vec3 rp, float preci)\n{\n    vec2 off = vec2(preci, 0.0);\n    vec2 g = vec2(map(rp + off.xyy) + map(rp - off.xyy),\n\t\t\t\t  map(rp + off.yyx) + map(rp - off.yyx));\n    return g;\n}\n\n// for the spec bump \nvec3 texGrad(in vec2 uv)\n{\n    vec2 offset = vec2(0.01, 0.0);\n    uv *= .5;\n    float h0 = texture(iChannel2, uv).r;\n    float h1 = h0-texture(iChannel3, uv+offset.xy).r;\n    float h2 = h0-texture(iChannel0, uv+offset.yx).r;\n    \n    float bump = .4;\n    vec3 g = cross(normalize(vec3(bump, h1, 0.0)), normalize(vec3(0.0, h2, bump)));\n    return g;\n}\n\n\nconst vec3 up = vec3(0.0, 1.0, 0.0);\n\n\nvoid trace(in positionStruct pos, in vec3 rp, in vec3 rd, inout vec4 color)\n{\n    \n    if (dot(rd, up)>0.0){\n        color.rgb = getSky(pos);\n        return;\n    }\n    \n    // trace to plane on top of waves\n    vec3 ro = rp;\n    float t = -(0.155+dot(rp, -up)) / dot(-up, rd);\n    if (t < 0.0) \n    {\n        return;\n    }\n    \n\trp += rd*t;    \n    bool hit = false;\n    float dist = 0.0;\n    \n    // actual tracing\n    \n    // low freq\n    for (int i = 0; i < 5; ++i)\n    {\n        float travelledSq=dot(ro-rp, ro-rp);\n        dist = mapLo(rp);\n        \n        if(dist < 0.01)\n        {\n            hit = true;\n            break;\n        }\n        rp += rd * max(dist * (log2(2.+travelledSq)), 0.01);\n        if(travelledSq > 9000.0) break;\n    }\n    \n    //detail tracing\n    /*for (int i = 0; i < 10; ++i)\n    {\n        rp += dist * rd;\n        if (abs(dist) < 0.0001) break;\n        dist = map(rp);\n    }*/\n    \n    // shadings    \n        vec3 sun = pos.sunVector;\n        vec3 g = grad(rp, 0.002 * (1.0+log2(length(ro-rp) * 100.)));\n        /*vec3 tg =  texGrad (rp.xz*5.1 + vec2(-iTime*.015, iTime*.06));\n        vec3 tg2 = texGrad (rp.xz*6.2 + vec2( iTime*.01,  -iTime*.06));\n        tg = normalize(tg+tg2);\n        tg = normalize(tg+texGrad(rp.xz*4.2 + vec2( iTime*.01, iTime*.05))*0.3);*/\n        \n        //vec3 sg = grad(rp, 0.001);\n        //sg = normalize(sg+tg*.3);\n        // base color\n        pos.worldVector = rd-2.*dot(rd, g)*g;\n        pos.worldVector = normalize(pos.worldVector);\n        color.rgb = getSky(pos);\n        //color = vec4(.05, 0.22, .4, 0.0);\n        /*\n        // diffuse\n        float d = max(0.0, dot(g, sun));\n        //color *= mix(1.0, d, .4);\n        \n        // top\n        vec2 heights = sub(rp, 0.3);\n        float sst = length(max(vec2(0.00001), heights));\n        float sunD = -1.*(dot(sun, g));\n        //color.rgb = mix(color.rgb, vec3(.2, 0.5, 0.72)*.5, smoothstep(0., .4, sunD));\n        \n        // bottom\n        float ssb = length(min(vec2(0.0), heights));\n        //color.rgb = mix(color.rgb, vec3(.05, 0.22, .4)*.5, smoothstep(0.0, 0.4, ssb));\n        */\n        // foam\n        /*vec3 pw = vec3(1.+2.3/(sst*1.+.001))*2.2;\n        vec3 texcol1 = texture(iChannel2, rp.xz*.5+vec2(.0, .07*iTime)).rgb;\n        \n        vec3 pw2 = vec3(1.+.7/(sst*1.2+.01));\n        vec3 texcol2 = texture(iChannel2, rp.xz*.5+vec2(.0, .07*iTime)).rgb*1.;\n        \n        vec3 foam = max(pow(texcol1, pw).rrr, pow(texcol2, pw2).rrr);\n        if(foam.r>.3){\n        color.rgb = foam*3.;\n        }*/\n        \n        // fresnel\n        vec3 H = normalize(-rd + normalize(sun));\n        float F = clamp(max(0.0, 1.2+dot(rd, g)), 0.0, 1.);\n\n        color.rgb = F* color.rgb + (1.-F)*vec3(.0, .15, .3);\n\n    \n    color.a = 1.;//length(ro-rp);\n    \n}\n\n\nmat3 lookat(vec3 from, vec3 to)\n{\n    vec3 f = normalize(to - from);\n    vec3 _tmpr = normalize(cross(f, vec3(0.0, .999, 0.0)));\n    vec3 u = normalize(cross(_tmpr, f));\n    vec3 r = normalize(cross(u, f));\n    return mat3(r, u, f);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    gatherPositions(pos, fragCoord, iMouse.xy, iResolution.xy);\n;\n    vec2 uv = (fragCoord.xy-iResolution.xy*.5) / iResolution.x;\n    \n    //ray direction \n    vec3 rd = pos.worldPosition;\n    \n    //ray position\n    vec3 rp = vec3(0.0, 0.3, 0.0);\n    vec3 _rp = rp;\n\t    \n    trace(pos, rp, rd, fragColor);\n    vec3 color = fragColor.rgb;\n    color = pow(color, vec3(1.0 / 2.2)); //Fitting to regular colorspace\n    color = robobo1221Tonemap(color);\n    fragColor.rgb = clamp(color, 0.0, 1.0);\n}", "buffer_b_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define VOLUMETRIC_LIGHT\n//#define SPHERICAL_PROJECTION\n\n#define cameraMode 1 \t\t\t\t\t//1 is free rotation, 2 is still camera but free sun rotation\n\n\n//////////////////////////////////////////////////////////////////\n\nfloat bayer2(vec2 a){\n    a = floor(a);\n    return fract( dot(a, vec2(.5, a.y * .75)) );\n}\n\nvec2 rsi(vec3 position, vec3 direction, float radius) {\n    float PoD = dot(position, direction);\n    float radiusSquared = radius * radius;\n\n    float delta = PoD * PoD + radiusSquared - dot(position, position);\n    if (delta < 0.0) return vec2(-1.0);\n          delta = sqrt(delta);\n\n    return -PoD + vec2(-delta, delta);\n}\n\n#define bayer4(a)   (bayer2( .5*(a))*.25+bayer2(a))\n#define bayer8(a)   (bayer4( .5*(a))*.25+bayer2(a))\n#define bayer16(a)  (bayer8( .5*(a))*.25+bayer2(a))\n#define bayer32(a)  (bayer16(.5*(a))*.25+bayer2(a))\n#define bayer64(a)  (bayer32(.5*(a))*.25+bayer2(a))\n#define bayer128(a) (bayer64(.5*(a))*.25+bayer2(a))\n\n//////////////////////////////////////////////////////////////////\n\n#define cloudMinHeight cloudHeight\n#define cloudMaxHeight (cloudThickness + cloudMinHeight)\n\n#define sunPosition vec3(1.0, 0.2, 0.0)\n\nconst float pi = acos(-1.0);\nconst float rPi = 1.0 / pi;\nconst float hPi = pi * 0.5;\nconst float tau = pi * 2.0;\nconst float rLOG2 = 1.0 / log(2.0);\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    float xx = axis.x * axis.x;\n    float yy = axis.y * axis.y;\n    float zz = axis.z * axis.z;\n    \n    float xy = axis.x * axis.y;\n    float xz = axis.x * axis.z;\n    float zy = axis.z * axis.y;\n    \n    return mat3(oc * xx + c, oc * xy - axis.z * s, oc * xz + axis.y * s,\n                oc * xy + axis.z * s, oc * yy + c, oc * zy - axis.x * s, \n                oc * xz - axis.y * s, oc * zy + axis.x * s, oc * zz + c);\n}\n#define PI 3.14159265358\n\nmat3 rotx(float a) { return rotationMatrix(vec3(1.,0.,0.), a); }\nmat3 roty(float a) { return rotationMatrix(vec3(0.,1.,0.), a); }\nmat3 rotz(float a) { return rotationMatrix(vec3(0.,0.,1.), a); }\n\nstruct positionStruct\n{\n\tvec2 texcoord;\n    vec2 mousecoord;\n    vec3 worldPosition;\n    vec3 worldVector;\n    vec3 sunVector;\n} pos;\n\nvec3 sphereToCart(vec3 sphere) {\n    vec2 c = cos(sphere.xy);\n    vec2 s = sin(sphere.xy);\n    \n    return sphere.z * vec3(c.x * c.y, s.y, s.x * c.y);\n}\n\nvec3 calculateWorldSpacePosition(vec2 p)\n{\n\tp = p * 2.0 - 1.0;\n    \n    vec3 worldSpacePosition =  vec3(p.x, p.y, 1.0);\n    \n    #ifdef SPHERICAL_PROJECTION\n\t\tworldSpacePosition = sphereToCart(worldSpacePosition * vec3(pi, hPi, 1.0));\n\t#endif\n    \n    return worldSpacePosition;\n}\n\nvoid gatherPositions(inout positionStruct pos, vec2 fragCoord, vec2 mouseCoord, vec2 screenResolution)\n{\n\tpos.texcoord = fragCoord / screenResolution;\n    pos.mousecoord = mouseCoord / screenResolution;\n    \n    pos.mousecoord = pos.mousecoord.x < 0.001 ? vec2(0.4, 0.64) : pos.mousecoord;\n    \n    vec2 rotationAngle = radians(vec2(360.0, 180.0) * pos.mousecoord - vec2(0.0, 90.0));\n\n    \n    mat3 rotateH = rotationMatrix(vec3(0.0, 1.0, 0.0), rotationAngle.x);\n    mat3 rotateV = rotationMatrix(vec3(1.0, 0.0, 0.0), -rotationAngle.y);\n    \n    pos.worldPosition = calculateWorldSpacePosition(pos.texcoord);\n    \n    if (cameraMode == 1) {\n    \tpos.worldPosition = rotateH * (rotateV * pos.worldPosition);\n        \n        // Sun position\n    \tpos.sunVector = normalize(sunPosition);\n    }\n    if (cameraMode == 2) {\n    \tpos.sunVector = normalize(calculateWorldSpacePosition(pos.mousecoord));\n    }\n    \n    pos.worldVector = normalize(pos.worldPosition);\n}", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stXSDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 143]], "test": "untested"}
{"id": "stsSD8", "name": "Fantasy Axe", "author": "intrakits", "description": "Wanted to try and make a cool weapon. I think i made it too shiny, lol.", "tags": ["axe"], "likes": 6, "viewed": 313, "published": 3, "date": "1625671429", "time_retrieved": "2024-07-30T19:11:51.740290", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST 0.01\n#define AA 1\n\nvec2 rand2(vec2 p)\n{\n\tvec2 q = vec2(dot(p,vec2(127.1,311.7)), \n\t\tdot(p,vec2(269.5,183.3)));\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat rand(vec2 p)\n{\n\treturn fract(sin(dot(p,vec2(419.2,371.9))) * 833458.57832);\n}\n\nfloat iqnoise(in vec2 pos, float irregular, float smoothness)\n{\n\tvec2 cell = floor(pos);\n\tvec2 cellOffset = fract(pos);\n\n\tfloat sharpness = 1.0 + 63.0 * pow(1.0-smoothness, 4.0);\n\t\n\tfloat value = 0.0;\n\tfloat accum = 0.0;\n\t// Sample the surrounding cells, from -2 to +2\n\t// This is necessary for the smoothing as well as the irregular grid.\n\tfor(int x=-2; x<=2; x++ )\n\tfor(int y=-2; y<=2; y++ )\n\t{\n\t\tvec2 samplePos = vec2(float(y), float(x));\n\n  \t\t// Center of the cell is not at the center of the block for irregular noise.\n  \t\t// Note that all the coordinates are in \"block\"-space, 0 is the current block, 1 is one block further, etc\n\t\tvec2 center = rand2(cell + samplePos) * irregular;\n\t\tfloat centerDistance = length(samplePos - cellOffset + center);\n\n\t\t// High sharpness = Only extreme values = Hard borders = 64\n\t\t// Low sharpness = No extreme values = Soft borders = 1\n\t\tfloat sam = pow(1.0 - smoothstep(0.0, 1.414, centerDistance), sharpness);\n\n\t\t// A different \"color\" (shade of gray) for each cell\n\t\tfloat color = rand(cell + samplePos);\n\t\tvalue += color * sam;\n\t\taccum += sam;\n\t}\n\n\treturn value/accum;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    //line from a to b\n    vec3 ab = b-a;\n    \n    // line from p to a\n    vec3 ap = p-a;\n    \n    // as p approaches a, it will be 1\n    // as p approaches b it will b 0\n    float t = dot(ab,ap) / dot(ab,ab);\n    \n    // clamp values between 0 and 1\n    t= clamp(t,0.,1.);\n    \n    // center point of the capsule\n    // start at a (top of capsule)\n    // go towards b, t steps\n    vec3 c = a + t*ab;\n    \n    float d = length(p-c)-r;\n    \n    return d;\n}\n\nfloat sdTorus(vec3 p, vec2 r){\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.));\n}\nvec2 colMin(vec2 res, vec2 obj){\n    res.x = min(obj.x,res.x);\n    if(obj.x == res.x){\n        res.y = obj.y;\n    }\n    return res;\n}\n// https://iquilezles.org/articles/smin\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\nfloat getDisp(vec2 uv){\n\n    vec2 p = 0.5 - 0.5*sin(vec2(1.01,1.71) );\n    p = vec2(1.0, 1.0);\n\t\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\t\n\tfloat f = iqnoise(24.0*uv, p.x, p.y);\n\t\n\treturn f;\n}\nvec2 GetDist(vec3 p){\n    //ground\n    vec2 res = vec2(p.y+10.,0);\n    float e = 2.71828182846;\n    float offs = (pow(e,cos(p.y))/pow(e,sin(p.y*p.y*10.))*.03);\n    vec2 blade = vec2(sdCapsule(p-vec3(0,0,clamp(abs(p.x-.5)*.5,0.,.7)), vec3(0,0,0), vec3(1,0,0), 1.),1);\n    float mask = dBox(p-vec3(0,0,0), vec3(4,1,.1));\n    \n    blade = max(blade,mask);\n    blade= max(blade,1.-length(p-vec3(.5,1,0))-.1);\n    blade= max(blade,1.-length(p-vec3(.5,-1.4,0))-.1);\n    res= colMin(res,blade);\n    \n    vec2 pole = vec2(sdCylinder(p-vec3(.5,0,0), vec3(0,-5,0), vec3(0,1,0), .2),2);\n    vec2 uv = vec2(atan(p.x,p.z)/(3.14159*2.),p.y/5.)+.5;\n    \n    float disp = 0.1*iqnoise( 30.0*uv, 1., .1 );\n    pole.x-=disp*.1;\n    mask = dBox(p-vec3(.5,0,-.1), vec3(.1,1,.5));\n    pole.x = opSmoothSubtraction(mask,pole.x,.2);\n    res= colMin(res,pole);\n    \n    vec2 socket = vec2(sdCylinder(p-vec3(.5,-.15,0), vec3(0,0,.2), vec3(0,0,-.2), .3),3);\n    res= colMin(res,socket);\n    mask = sdCylinder(p-vec3(.5,-.15,0), vec3(0,0,.2), vec3(0,0,-.2), .1);\n    res.x = opSmoothSubtraction(mask,res.x,.1);\n    \n    vec2 dec1 = vec2(sdCylinder(p-vec3(.5,-.7,0), vec3(0,0,.2), vec3(0,0,-.2), .2),4);\n    vec2 dec2 = vec2(sdCylinder(p-vec3(.5,-.7,0), vec3(.3,0,0), vec3(-.3,0,0), .2),4);\n    dec1 = min(dec1,dec2);\n    vec2 dec3 = vec2(sdCylinder(p-vec3(.5,-.9,0), vec3(0,0,0), vec3(0,-.1,0), .25),4);\n    dec1 = min(dec1,dec3);\n    \n    vec2 dec4 = vec2(sdCylinder(p-vec3(.5,-1.2,0), vec3(0,0,.2), vec3(0,0,-.24), .2),4);\n    vec2 dec5 = vec2(sdCylinder(p-vec3(.5,-1.2,0), vec3(.3,0,0), vec3(-.3,0,0), .2),4);\n    dec1 = min(dec1,dec4);\n    dec1 = min(dec1,dec5);\n    vec2 dec6 = vec2(sdCylinder(p-vec3(.5,-1.4,0), vec3(0,0,0), vec3(0,-.1,0), .25),4);\n    dec1 = min(dec1,dec6);\n    res= colMin(res,dec1);\n    return res;\n}\nvec2 RayMarch(vec3 ro, vec3 rd){\n    // distance from origin\n    vec2 dO=vec2(0.,0.);\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO.x*rd;\n        \n        // get distance to seam\n        vec2 ds = GetDist(p);\n        //move origin to new point\n        dO+=ds.x;\n        if(ds.x < SURFACE_DIST){\n            dO.y = ds.y;\n            break;\n        }\n        else if( dO.x > MAX_DIST){\n            break;\n        }\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    //distance to point being analyzed\n    float d = GetDist(p).x;\n    \n    //distance to another point along the objects surface that is closeby\n    vec2 e = vec2(0.01,0);\n    \n    //slope between the two points\n    //note: swizzel is the .xxy or .yyx etc\n    vec3 n = d - vec3(\n         GetDist(p-e.xyy).x,\n         GetDist(p-e.yxy).x,\n         GetDist(p-e.yyx).x);\n         \n    return normalize(n);\n    \n}\nfloat GetLight(vec3 p){\n    //position of the light source\n    vec3 lightPos = vec3(0,5,-5);\n    \n    lightPos.xz += vec2(sin(iTime),cos(iTime));\n    //light vector\n    vec3 l = normalize(lightPos-p);\n    \n    //normal of object\n    vec3 n = GetNormal(p);\n    \n    // dot product of the light vector and normal of the point\n    // will give us the amount of lighting to apply to the point\n    // dot() evaluates to values between -1 and 1, so we will clamp it\n    float diff = clamp(dot(n, l),0.,1.);\n    \n    // calculate if point should be a shadow:\n    // raymarch from point being calculated towards light source\n    // if hits surface of something else before the light,\n    // then it must be obstructed and thus is a shadow\n    // the slight offset \"p+n*SURFACE_DIST*1.1\" is needed to ensure the\n    // break condistions in the function are not met too early\n    float d = RayMarch(p+n*SURFACE_DIST*1.1,l).x;\n    if(d < length(lightPos-p)){\n        diff *= 0.1;\n    }\n    return diff;\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nvec3 axeCol(vec3 p, vec3 n, vec3 rd){\n        vec3 colXZ = texture(iChannel1, p.xz*.5+.5).rgb;\n        vec3 colXY = texture(iChannel1, p.xy*.5+.5).rgb;\n        vec3 colYZ = texture(iChannel1, p.yz*.5+.5).rgb;\n        \n        vec3 refl = texture(iChannel2, rd).rgb;\n        refl= refl*abs(n.y) + refl*abs(n.z) + refl*abs(n.x);\n        vec3 metal = colXZ*abs(n.y) + colXY*abs(n.z) + colYZ*abs(n.x);\n        metal*=smoothstep(0.1,.4,metal.b)*refl*5.;\n        return metal;\n\n}\nvec3 decCol(vec3 p, vec3 n, vec3 rd){\n        vec3 colXZ = texture(iChannel0, p.xz*.5+.5).rgb;\n        vec3 colXY = texture(iChannel0, p.xy*.5+.5).rgb;\n        vec3 colYZ = texture(iChannel0, p.yz*.5+.5).rgb;\n        \n        vec3 refl = texture(iChannel2, rd).rgb;\n        refl= refl*abs(n.y) + refl*abs(n.z) + refl*abs(n.x);\n        vec3 metal = colXZ*abs(n.y) + colXY*abs(n.z) + colYZ*abs(n.x);\n        metal= mix(smoothstep(0.7,.8,metal.r)*refl*5.,metal,.7);\n        return metal;\n\n}\nvec3 poleCol(vec3 p, vec3 n, vec3 rd){\n        vec3 colXZ = texture(iChannel3, p.xz*.5+.5).rgb;\n        vec3 colXY = texture(iChannel3, p.xy*.5+.5).rgb;\n        vec3 colYZ = texture(iChannel3, p.yz*.5+.5).rgb;\n        \n        vec3 refl = texture(iChannel2, rd).rgb;\n        refl= refl*abs(n.y) + refl*abs(n.z) + refl*abs(n.x);\n        vec3 metal = colXZ*abs(n.y) + colXY*abs(n.z) + colYZ*abs(n.x);\n        //metal= mix(smoothstep(0.7,.8,metal.r)*refl*5.,metal,.7);\n        return metal;\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n   \n    \n    //camera\n    //-----------------\n    // ray origin\n    //controls position\n    vec3 ta = vec3( 0.5, -1, .5);\n    vec3 ro = ta + vec3( 4.5*cos(7.0*mo.x), 1.3 + 2.0*mo.y, 4.5*sin(7.0*mo.x) );\n    mat3 ca = setCamera( ro, ta, 0.0 );\n//    vec3 ro = vec3(0,3,-5);\n\n    \n    //ray dir\n    //controls rotation\n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 pt = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 pt = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n    vec3 rd = ca * normalize( vec3(pt,2.5) );\n    //------------------\n    vec2 d = RayMarch(ro,rd);\n    \n    // position of point\n    // start at ray origin\n    // move d units in the ray direction\n    vec3 p = ro + rd *d.x;\n    \n    //get diffuse lighting\n    float diff = GetLight(p);\n    vec3 col = vec3(0);\n    col = vec3(diff)*2.;\n    \n    vec3 n = GetNormal(p);\n    \n    if(d.y == 1.){\n        col *= axeCol(p, n, rd);\n    }\n    else if(d.y==2.){\n        col *= poleCol(p,n,rd);\n    }\n    else if(d.y==3.){\n        col*=decCol(p, n, rd)*vec3(0,0.6,.9);\n    }\n    else if(d.y==4.){\n        col*=decCol(p, n, rd)*vec3(1,1,0);\n    }\n    else{\n    col *=texture(iChannel2, rd).rgb * 5.;\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stsSD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 84, 104, 104, 211], [213, 213, 233, 233, 296], [298, 298, 361, 361, 1411], [1413, 1413, 1432, 1432, 1494], [1495, 1495, 1546, 1546, 1830], [1832, 1832, 1881, 1904, 2337], [2339, 2339, 2369, 2369, 2440], [2442, 2442, 2469, 2469, 2508], [2509, 2509, 2541, 2541, 2642], [2643, 2683, 2721, 2721, 2818], [2820, 2860, 2901, 2901, 2973], [2974, 2974, 3032, 3032, 3133], [3134, 3134, 3157, 3157, 3352], [3353, 3353, 3374, 3387, 5151], [5152, 5152, 5184, 5212, 5699], [5700, 5700, 5723, 5762, 6133], [6134, 6134, 6157, 6192, 7127], [7128, 7128, 7180, 7180, 7357], [7358, 7358, 7395, 7395, 7831], [7832, 7832, 7869, 7869, 8319], [8320, 8320, 8358, 8358, 8810]], "test": "untested"}
{"id": "NtXXWN", "name": "Mandelbrot 9002", "author": "johannesCmayer", "description": "Mandelbrot and Julia sets\n\nClick and drag in the window to see the Julia set.", "tags": ["fractal"], "likes": 4, "viewed": 298, "published": 3, "date": "1625670952", "time_retrieved": "2024-07-30T19:11:52.491282", "image_code": "//#define animateIterations\n//#define zoom\n//#define animateColor\n//#define SHOW_ID\n#define PI 3.14159265359\n\nfloat maxIterationsC = 100.;\nfloat minIterationsC = 10.;\n\nvec2 offset = vec2(-30., 0.);\n\nstruct Coordinates\n{\n    float real;\n    float imagenary;\n};\n    \nstruct Frac_Return_Val\n{\n\tfloat iterations;\n    float real;\n    float imaginary;\n};\n    \nFrac_Return_Val MandelbrotFunc(float maxIterations, Coordinates coordinates)\n{\n    float real;\n    float imaginary;\n    float c_real;\n    float c_imaginary;\n    \n    //Mandelbrot\n    real = 0.;\n    imaginary = 0.;\n    c_real = coordinates.real;\n    c_imaginary = coordinates.imagenary;\n    \n    //Julia\n    if (iMouse.z > 0.)\n    {\n        real = coordinates.real;\n        imaginary = coordinates.imagenary;\n        c_real = (iMouse.x - iResolution.x / 2.) / iResolution.x * 4.;\n        c_imaginary = (iMouse.y - iResolution.y / 2.) / iResolution.y * 4.;\n    }\n    \n    //Julia Mandel\n    /*\n    real = coordinates.real;\n    imaginary = coordinates.imagenary;\n    c_real = coordinates.real;\n    c_imaginary = coordinates.imagenary;\n    */\n    \n    float iterations = 0.;    \n    \n   \tfor (float i = 0.; i < maxIterations; i++)\n    {\n        iterations++;\n                        \n        if (pow(real, 2.) + pow(imaginary, 2.) > 4.) \n        {\n            Frac_Return_Val r_Val;\n    \t\tr_Val.iterations = iterations;\n    \t\tr_Val.real = real;\n    \t\tr_Val.imaginary = imaginary;\n                \n            return r_Val;\n        }              \n               \n        float temp = real;\n        real = pow(real, 2.) - pow(imaginary, 2.) + c_real;\n        imaginary = 2. * temp * imaginary + c_imaginary;\n    } \n    \n    Frac_Return_Val r_Val;\n    r_Val.iterations = iterations;\n    r_Val.real = real;\n    r_Val.imaginary = imaginary;\n    \n    return r_Val;\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat atan2(in float y, in float x)\n{\n    bool s = (abs(x) > abs(y));\n    return mix(PI/2.0 - atan(x,y), atan(y,x), s);\n}\n\n/*\nvec4 id_color()\n{\n    float modulus = sqrt(pow(coordinates.real, 2.) + pow(coordinates.imagenary, 2.));\n    float a = (atan(coordinates.imagenary, coordinates.real)+2.*PI) / (2.*PI);\n    color = vec4(a,0.,0.,0);\n    float mod_2 = 2./PI*atan(modulus* 10.);\n    \n    color = vec4(hsv2rgb(vec3(a, 1., mod_2)), 1.);\n    //color = vec4(a, 0., 0., 1.);\n    float b = atan(1.,0.);\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef animateIterations\n    float maxIterations = maxIterationsC * abs(sin(iTime)) + minIterationsC;    \n    #else\n    float maxIterations = maxIterationsC;\n    #endif\n        \n    Coordinates coordinates;\n  \n    #ifdef constantCoordinate\n    coordinates.real = 1. / 100.;\n    coordinates.imagenary = 1. / 100.;\n    #else\n    coordinates.real = (fragCoord.x - iResolution.x / 2. + offset.x) / iResolution.y * 3.;\n    coordinates.imagenary = (fragCoord.y - iResolution.y / 2. + offset.y) / iResolution.y * 3.;\n    #endif\n    \n    #ifdef zoom\n    coordinates.real /= (sin(iTime * 0.1) * 1000.);\n    coordinates.imagenary /= (sin(iTime * 0.1) * 1000.);\n    #endif\n    \n    Frac_Return_Val r_Val = MandelbrotFunc(maxIterations, coordinates);\n         \n    vec4 color;\n    \n    if (r_Val.iterations >= maxIterations) {\n        float modulus = sqrt(pow(r_Val.real, 2.) + pow(r_Val.imaginary, 2.));\n        float a = (atan(r_Val.imaginary, r_Val.real) + 2.*PI) / (2.*PI);\n        float mod_2 = 2./PI*atan(modulus* 10.);\n        color = vec4(hsv2rgb(vec3(a, 1., mod_2)), 1.);\n    }\n    else {\n    \tcolor = vec4(r_Val.iterations / 64., r_Val.iterations / 128., r_Val.iterations / 32., 1.);\n        //color = vec4(0,0,0,0);\n    }\n    \n    #ifdef SHOW_ID\n    float modulus = sqrt(pow(coordinates.real, 2.) + pow(coordinates.imagenary, 2.));\n    float a = (atan(coordinates.imagenary, coordinates.real)+2.*PI) / (2.*PI);\n    float mod_2 = 2./PI*atan(modulus* 10.);\n    color = vec4(hsv2rgb(vec3(a, 1., mod_2)), 1.);\n    #endif\n    \n    #ifdef animateColor\n    float st = abs(sin(iTime)) * 2. + 1.;\n    color *= vec4(1. * st, 1. * st , 1. * st , 1.);\n    #endif\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtXXWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[354, 354, 432, 432, 1811], [1813, 1813, 1835, 1835, 2166], [2168, 2168, 2190, 2190, 2359], [2361, 2361, 2398, 2398, 2482], [2867, 2867, 2924, 2924, 4603]], "test": "untested"}
{"id": "NlfSDN", "name": "vectorscope clock", "author": "schobbejack", "description": "displays analog clock on vectorscope", "tags": ["clock", "ycbcr", "vectorscope"], "likes": 4, "viewed": 293, "published": 3, "date": "1625670073", "time_retrieved": "2024-07-30T19:11:53.249256", "image_code": "vec3 to_rgb(vec3 ycbcr)\n{\n    // full range bt709 matrix\n    const mat3 c709=mat3(1.0000000000, 1.0000000000, 1.0000000000,\n                      0.0000000000, -0.1873242729, 1.8556000000,\n                      1.5748000000, -0.4681242729, 0.0000000000);\n    return c709 * ycbcr;\n}\n\nvec2 rot(vec2 uv, float r)\n{\n    float s=sin(r);\n    float c=cos(r);\n    \n    return vec2(uv.x*c-uv.y*s,uv.x*s+uv.y*c);\n}\n\nconst float pi = acos(-1.);\nconst float pi2 = pi*2.;\n\nvec2 vsphere(float x)\n{\n    return vec2(sin(x*pi),cos(x*pi))*.25;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.xy;\n    \n    float t = iDate.w;\n    \n    uv.y = uv.y*2.5+sin(t*3.+uv.x*6.)*sin(uv.x*4.)*.3;\n    \n    const float fm[]=float[](1.,60.,3600.,43200.);\n    float m = floor(clamp(uv.y+2.5,1.,4.)-1.);\n    float r = mod(t,fm[int(m)])*(1./fm[int(m)])*pi2;\n        \n    vec2 cbcr=mix(rot(vsphere(uv.x),sin(t)*pi2),rot(vec2(0.0,uv.x*.5+.5),-r)*(0.25-pow(m/3.,.8)*.1),float(uv.y>-1.5));\n    \n    fragColor = vec4(to_rgb(vec3(.5,cbcr)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlfSDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 56, 281], [283, 283, 311, 311, 404], [460, 460, 483, 483, 527]], "test": "untested"}
{"id": "NlXXWN", "name": "Atmospherical Scattering", "author": "Txoka", "description": "Just an atmosphere scattering light (1 step scattering only)\nUse mouse to move the scene\ntry #define SEE_FROM_INSIDE", "tags": ["raytracing", "sun", "normals", "light", "scattering", "atmosphere", "ssao"], "likes": 18, "viewed": 684, "published": 3, "date": "1625669009", "time_retrieved": "2024-07-30T19:11:54.065075", "image_code": "//TUNING PARAMETERS HAS MADE ME INSANE. PLS APRECIATE THE WORK XD\n\n\n#define R iResolution\n#define time (iTime*0.5)\n\n#define SEE_ATMOSPHERE\n//#define SEE_FROM_INSIDE\n//#define EXPERIMENTAL_PLANET_SHADOW\n//#define CRAPPY_AA\n\n\nstruct ray{\n\tvec3 ro;\n    vec3 rd;\n};\nstruct sph{\n    vec3 c;\n\tfloat r;\n};\n\nconst vec3 center=vec3(0);\n\n#ifdef EXPERIMENTAL_PLANET_SHADOW\nconst int VIEW_SAMPLES=64;\n#else\nconst int VIEW_SAMPLES=25;\n#endif\n\nconst int DEPTH_SAMPLES=8;\n\nconst sph atm=sph(center,1.);\nconst vec3 sunInt=vec3(1.);\nconst sph earth=sph(center,0.5);\nconst vec3 waves=700./vec3(700,510,440);\nconst vec3 RGBScatter=waves*waves*waves*waves;\nconst float scatterStrength=50.;\nconst float densFall=7.;\n\nfloat dot2(vec3 k){return dot(k,k);}\nconst float pi=4.*atan(1.);\n\nfloat phase(float cosTheta) {\n\treturn (1. + cosTheta * cosTheta) / (16.0 * pi);\n}\n\nfloat sphere(ray r, sph s, float n){//sphere ray intersection\n\tvec3 rc = r.ro-s.c;\n\tfloat c = dot(rc, rc) - (s.r*s.r);\n\tfloat b = dot(r.rd, rc);\n\tfloat d = b*b - c;\n\tfloat t = -b - n*sqrt(abs(d));\n\tfloat st = step(0.0, min(t,d));\n\treturn max(0.,mix(-1., t, st));\n}\n\nfloat suc(ray r,vec3 center,float radius){// sun glare\n    vec3 o=r.ro-center;\n    float a=dot(o,o);\n    float b=dot(r.rd,o);\n    float c=dot(r.rd,r.rd);\n    float k=sqrt(a*c-b*b);\n    float integ=radius*(pi/2.-atan(b,k))/k/3.;\n    integ*=integ;\n    integ*=integ;//not integral anymore but looks great\n    return integ;\n}\n\nfloat density(vec3 p){\n    float l=distance(p,center)-earth.r;\n    l/=atm.r-earth.r;\n    return exp(-l*densFall)*(1.-l);\n}\n\nfloat depth(vec3 s,vec3 e){\n    float d=0.;\n    for(int i=0;i<DEPTH_SAMPLES;i++){\n        vec3 p=s+(e-s)*float(i)/float(DEPTH_SAMPLES);\n        d+=density(p);\n    }\n    return d/float(DEPTH_SAMPLES)*distance(s,e);\n}\n\nvec3 light(ray r,vec3 sunPos,vec3 orig){\n    if(distance(r.ro,center)<atm.r){\n    }else{\n        float d1=sphere(r,atm,1.);\n        if(d1==0.)return orig;\n        r.ro+=r.rd*d1;\n    }\n    float d2=sphere(r,earth,1.);\n    if(d2==0.)d2=sphere(r,atm,-1.);\n    float viewDepth=0.;\n    vec3 l=vec3(0.);\n    for(int i=0;i<VIEW_SAMPLES;i++){\n        vec3 p=r.ro+r.rd*(float(i)+0.5)/float(VIEW_SAMPLES+1)*d2;\n        ray k=ray(p,normalize(sunPos-p));\n        #ifdef EXPERIMENTAL_PLANET_SHADOW\n        if(sphere(k,earth,1.)==0.){\n        #endif\n            float sunDepth=depth(k.ro,k.ro+k.rd*sphere(k,atm,-1.));\n            viewDepth=depth(r.ro,p);\n            vec3 transmitance=exp(-(sunDepth+viewDepth)*RGBScatter);\n        \n        \n            l+=transmitance*density(p)*phase(dot(r.rd,normalize(sunPos-p)));\n        #ifdef EXPERIMENTAL_PLANET_SHADOW\n        }\n        #endif\n    }\n    vec3 origTransmitance=exp(-viewDepth*RGBScatter);\n    return orig*origTransmitance+l/float(VIEW_SAMPLES)*d2*sunInt*RGBScatter*scatterStrength;\n}\n\n\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat starField(vec3 rd){\n    rd*=200.;\n    float col=0.;\n    for(int i=0;i<4;i++){\n        vec3 CellUVs=floor(rd+float(i*1199));\n        vec3 hash=(hash33(CellUVs)*2.-1.)*.8;\n        float hash_magnitude =(1.0-length(hash));\n        vec3 UVgrid=fract(rd)-.5;\n        float radius=clamp(hash_magnitude-.5,0.,1.);\n        float radialGradient=length(UVgrid-hash)/radius;\n        radialGradient=clamp(1.-radialGradient,0.,1.);\n        radialGradient*=radialGradient;\n        col += radialGradient;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 O, in vec2 U ){\n    #ifdef SEE_FROM_INSIDE\n    float uvz=2.;\n    float roz=0.;\n    vec3 pos=vec3(0,0.6,0);\n    #else\n    float uvz=-1.;\n    float roz=-3.;\n    vec3 pos=vec3(0,0,0);\n    #endif\n\n    vec3 uv = vec3((U*2.-R.xy)/R.y,uvz);\n    vec2 m=(iMouse.xy*2.-R.xy)/R.xy;\n    m*=vec2(1,0.5)*pi;\n    //if(iMouse.z<=0.)m=vec2(-iTime/3.,0.05);\n    if(length(iMouse.xy)==0.)m=vec2(0);\n    \n\n    vec3 ro=vec3(0,0,roz);\n    \n    ro.yz*=mat2(cos(m.y),-sin(m.y),sin(m.y),cos(m.y));\n    ro.xz*=mat2(cos(m.x),-sin(m.x),sin(m.x),cos(m.x));\n    uv.yz*=mat2(cos(m.y),-sin(m.y),sin(m.y),cos(m.y));\n    uv.xz*=mat2(cos(m.x),-sin(m.x),sin(m.x),cos(m.x));\n    \n    \n    O=vec4(0);\n    ray r=ray(ro+pos,normalize(uv-ro));\n    sph sun=sph(vec3(0,10.*vec2(sin(time),cos(time))),1.);\n    O.rgb+=starField(r.rd);\n    //if(sphere(r,sun,1.)>0.)O=vec4(clamp(vec3(0.),vec3(1.),sunInt),1.);\n    O.rgb+=clamp(0.,1000.,suc(r,sun.c,sun.r))*sunInt;\n \n    float d=sphere(r,earth,1.);\n    \n    if(d>0.){\n        vec3 planet;\n        vec3 surf=r.ro+r.rd*d;\n        planet =texture(iChannel0,(surf-center).xz+vec2(0.4,0.1)).rgb*(surf-center).y*(surf-center).y;\n        planet+=texture(iChannel0,(surf-center).xy+vec2(0.1,0.6)).rgb*(surf-center).z*(surf-center).z;\n        planet+=texture(iChannel0,(surf-center).yz+vec2(0.0,0.2)).rgb*(surf-center).x*(surf-center).x;\n        float normal=0.;\n        normal =texture(iChannel1,1.*(surf-center).xz+vec2(0.4,0.1)).r*(surf-center).y*(surf-center).y;\n        normal+=texture(iChannel1,1.*(surf-center).xy+vec2(0.1,0.6)).r*(surf-center).z*(surf-center).z;\n        normal+=texture(iChannel1,1.*(surf-center).yz+vec2(0.0,0.2)).r*(surf-center).x*(surf-center).x;\n        normal*=4.;\n        \n        planet*=4.;\n        planet*=0.03+0.97*smoothstep(-0.1,0.7,(normal*2.-1.)*0.7+dot(normalize(surf-center),normalize(sun.c-surf)));\n        \n        #ifdef CRAPPY_AA\n        //cheap antialiasing\n        float z=length(r.ro-earth.c);\n        float w=z-earth.r;\n        z=sqrt(z*z-earth.r*earth.r);//distance from cam to edge of planet(the point where it aliases)\n        z=(d-z)/(w-z);//1 on the closest point of the sphere to the carmera 0 on the furthest\n        z=smoothstep(10./R.y,90./R.y,z);\n        O.rgb=mix(O.rgb,planet,z);\n        #else\n        O.rgb=planet;\n        #endif\n    }\n    #ifdef SEE_ATMOSPHERE\n    O=vec4(light(r,sun.c,O.rgb),1.);\n    #endif\n}", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXXWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[696, 696, 715, 715, 732], [762, 762, 791, 791, 843], [845, 845, 881, 906, 1109], [1111, 1111, 1153, 1165, 1432], [1434, 1434, 1456, 1456, 1556], [1558, 1558, 1585, 1585, 1773], [2804, 2804, 2825, 2825, 2949], [2951, 2951, 2976, 2976, 3470], [3472, 3472, 3512, 3512, 5863]], "test": "untested"}
{"id": "4dSBRW", "name": "Optical Effect 9001", "author": "johannesCmayer", "description": "some effect", "tags": ["oe"], "likes": 3, "viewed": 195, "published": 3, "date": "1625660152", "time_retrieved": "2024-07-30T19:11:54.820056", "image_code": "// all noise agorithms came from here -> https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\n#define t iTime\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float q = t;\n        \n    vec3 np; \n    np.x = length(sin(fragCoord.yx / (iResolution.y / 30.)));\n    np.y = length(sin(fragCoord.yx / (iResolution.y / 30.)));\n    np.z = length(cos(fragCoord.yx / (iResolution.y / 30.)));\n    \n    float no = noise(np - q + noise(np - q + noise(np - sin(q) + noise(np + q))));\n    \n\tvec4 color = vec4(no, 0, no, 1.);\n    \n    \n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dSBRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 125, 145, 145, 183], [185, 185, 207, 207, 252], [253, 253, 273, 273, 318], [319, 319, 337, 337, 376], [378, 378, 398, 398, 889], [891, 891, 948, 948, 1337]], "test": "untested"}
{"id": "XsBfWd", "name": "SinWave", "author": "johannesCmayer", "description": "Wave", "tags": ["sin"], "likes": 0, "viewed": 212, "published": 3, "date": "1625659993", "time_retrieved": "2024-07-30T19:11:55.570050", "image_code": "#define t iTime * 5.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 color;\n    \n    if(uv.y*(3. + sin(t)) >= sin(uv.x*(20. + sin(t)) + -t) + 1.5 && uv.y*(3. + sin(t)) <= sin(uv.x*(20. + sin(t)) + -t) + 1.6)\n    \tcolor = vec4(1.,0.,0.,1.);\n    else\n    \tcolor = vec4(0.,0.,0.,1.);\n    \n\tfragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsBfWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 79, 79, 374]], "test": "untested"}
{"id": "ldBBRW", "name": "Raymacher  9001.5", "author": "johannesCmayer", "description": "Raymarcher\nMove the mouse in the viewport to look around.", "tags": ["raymacher"], "likes": 2, "viewed": 248, "published": 3, "date": "1625659947", "time_retrieved": "2024-07-30T19:11:56.330018", "image_code": "#define MAXRAYSTEPS 1000\n#define RAYEPSILON 0.0001\n#define NORMALEPSILON 0.0001\n\n#define SATURATION 0.4\n\n#define t iTime\n    \n//>>>>>>>>>>>>>>>>>>>>>>>>>>> Print Util\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( const vec2 vStringCoords, const float fValue, const float fMaxDigits, const float fDecimalPlaces )\n{\n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n\t\t\t\tfloat fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n\t\t\t}\n        }\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n\nfloat print(vec2 fragCoord, float value, vec2 coord)\n{\n    // Multiples of 4x5 work best\n\tvec2 vFontSize = vec2(16.0, 13.0);\n    float fDigits = 1.0;\n\tfloat fDecimalPlaces = 2.0;    \n    vec3 vColour;        \n\tvec2 vPixelCoord1 = coord;\n    fDigits = 15.0;   \n\t\n\treturn PrintValue( (fragCoord - vPixelCoord1) / vFontSize, value, fDigits, fDecimalPlaces);     \n}\n//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n\nstruct HitData\n{\n    float depth;\n    vec3 hitP;\n};\n \n//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>DistanceFunctions    \nmat2 rot(float a) \n{\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nvec4 formula(vec4 p) \n{\n    p.xz = abs(p.xz+1.)-abs(p.xz-1.)-p.xz;\n\n    //p.xz = abs(sin(p.xz+1.))-abs((p.xz-1.))-mod(p.xz, p.y);\n    p.y-=.25;\n    //p.xz*=rot(radians(35.*sin(iTime)+50.)); //Hier Sinus rein!\n    p.xy*=rot(radians(20.));\n    p=p*2./clamp(dot(p.xyz,p.xyz),.2,1.);\n\treturn p;\n}\n\nfloat de(vec3 pos) {\n#ifdef WAVES\n\t//pos.y+=sin(pos.z-t*6.)*.15; //waves!\n    pos.y+= tan(pos.z * 0.1); //waves!\n#endif\n    pos.z = mix(pos.z, pos.z*(4. - min(3.1,iTime)), max(iTime - 1., 1. )); //Zeit Raum Kontinuum brechen\n\t//float hid=0.;\n\tvec3 tpos=sin(pos);\n\ttpos.z=abs(3.-mod(tpos.z,6.));\n\tvec4 p=vec4(tpos,1.);\n\tfor (int i=0; i<4; i++) {p=formula(p);}\n\tfloat fr=(length(max(vec2(0.),p.yz-1.5))-1.)/p.w;\n\treturn fr;\n}\n\nfloat udBox( vec3 p, vec3 pos, vec3 b )\n{\n  return length(max(abs(p + pos)-b,0.0));\n}\n\nfloat sphereF(vec3 p, vec3 pos, float r)\n{\n    return length(p - pos) - r;\n}\n//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Operators\nfloat opRepSphere( vec3 p, vec3 c)\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return sphereF( q , vec3(0.,0.,0.), 1.);\n}\n\nfloat opRepCube( vec3 p, vec3 c)\n{\n    vec3 q = mod(p,c)-0.5 * c;\n    return udBox( q , vec3(0.,0.,0.), vec3(1., 1., 1.));\n}\n\nfloat opDisplace( vec3 p )\n{\n    float d1 = opRepCube(p, vec3(20., 20., 20.));\n    float d2 = (sin(2.*p.x)*sin(2.*p.y)*sin(2.*p.z)) * 2.;\n    return d1+d2;\n}\n//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\nfloat scene(vec3 p)\n{\n    //return de(p);\n    //return opDisplace(p);\n    //return opRepCube (p, vec3(20.,20.,20.));\n    return opRepSphere(p, vec3(20.,20.,20.));\n    //float s = opRepSphere(p, vec3(20.,20.,20.));\n    \n    //return min(c, s);\n    \n    return sphereF(p, vec3(0.,0.,5.), 1.);\n}\n\n//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Rotation\nvec3 RotateX(vec3 toRotate, vec3 camRot)\n{\n    mat3 rX = mat3 (\n        1.0, 0.0, 0.0,\n        0.0, cos(camRot.x), -sin(camRot.x),\n        0.0, sin(camRot.x), cos(camRot.x)\n        );  \n\n        return toRotate * rX;\n}\n\nvec3 RotateY(vec3 toRotate, vec3 camRot)\n{\n    mat3 rY = mat3 (\n        cos(camRot.y), 0.0,sin(camRot.y),\n        0.0, 1.0, 0.0,\n        -sin(camRot.y), 0.0, cos(camRot.y)\n        );  \n\n        return toRotate * rY;\n}\n\nvec3 RotateZ(vec3 toRotate, vec3 camRot)\n{\n    mat3 rZ = mat3 (\n        cos(camRot.z), -sin(camRot.z), 0.0,\n        sin(camRot.z), cos(camRot.z), 0.0,\n        0.0, 0.0, 1.0\n        );  \n\n        return toRotate * rZ;\n}\n\nvec3 Rotate(vec3 toRotate, vec3 camPos, vec3 camRot)\n{\n    return RotateZ(RotateY(RotateX(toRotate, camRot), camRot), camRot);    \n}\n//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\nvec3 calcNormal(vec3 p)\n{\n    vec3 n= vec3(scene(vec3(p.x + NORMALEPSILON, p.y, p.z)) - scene(vec3(p.x - NORMALEPSILON, p.y, p.z)),\n                 scene(vec3(p.x, p.y + NORMALEPSILON, p.z)) - scene(vec3(p.x, p.y - NORMALEPSILON, p.z)),\n                 scene(vec3(p.x, p.y, p.z + NORMALEPSILON)) - scene(vec3(p.x, p.y, p.z - NORMALEPSILON))\n               );\n    \n    return normalize(n);\n}\n\nHitData raymarch(vec3 rayOrigin, vec3 rayDirection)\n{\n    float t = 0.;\n    HitData hd;\n    \n    rayDirection = normalize(rayDirection);\n    \n    for (int i = 0; i < MAXRAYSTEPS; i++)\n    {\n        float d = scene(rayOrigin + rayDirection * t);\n        if (d < RAYEPSILON)\n        {\n            hd.depth = d;\n            hd.hitP = rayOrigin + rayDirection * t;            \n            return hd;\n        }\n        t += d;\n    }\n    hd.depth = t;\n    hd.hitP = rayOrigin + rayDirection * t;\n    return hd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 camPos = vec3(t, t*1.5, t);\n    vec3 camRot = vec3((iMouse.y - iMouse.y / 2.) / 100., (-iMouse.x - iMouse.x / 2.) / 100., 0.);\n    \n    float screenSpaceX = fragCoord.x;\n    float screenSpaceY = fragCoord.y;\n    \n    screenSpaceX = (screenSpaceX - iResolution.x / 2.) / iResolution.y;\n    screenSpaceY = (screenSpaceY - iResolution.y / 2.) / iResolution.y;\n       \n    HitData hit = raymarch(camPos, Rotate(vec3(screenSpaceX, screenSpaceY, 1.)\n                                          , camPos, \n                                          \tcamRot));\n    \n    vec3 db = Rotate(vec3(screenSpaceX, screenSpaceY, 1.), camPos, camRot);\n    vec3 db2 = vec3(screenSpaceX, screenSpaceY, 1.);\n    \n    float printColor =  print(fragCoord, hit.depth, vec2(0., 0.)) +\n        \t\t\t\tprint(fragCoord, calcNormal(hit.hitP).x, vec2(0., 20.)) +\n        \t\t\t\tprint(fragCoord, calcNormal(vec3(1.,1.,1.)).y, vec2(0., 40.)) +\n        \t\t\t\tprint(fragCoord, calcNormal(vec3(1.,1.,1.)).z, vec2(0., 60.)) +\n        \t\t\t\tprint(fragCoord, 0., vec2(0., 80.)) +\n        \t\t\t\tprint(fragCoord, 0., vec2(0., 100.)) +\n        \t\t\t\tprint(fragCoord, 0., vec2(0., 120.)) +\n        \t\t\t\tprint(fragCoord, 0., vec2(0., 140.));\n    \n    float printLerp = 0.;\n    \n    vec4 color;\n    \n    if (hit.depth > 200.)\n        color = vec4(0.,0.,0.2,1.);\n    else\n    \tcolor = vec4(mix((calcNormal(hit.hitP).x + 1.5 / 3.), printColor, printLerp),\n                     mix((calcNormal(hit.hitP).y + 1.5 / 3.), printColor, printLerp),\n                     mix((calcNormal(hit.hitP).z + 1.5 / 3.), printColor, printLerp), 1.);\n    \n    fragColor = color * vec4(SATURATION, SATURATION, SATURATION, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldBBRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 167, 198, 198, 356], [358, 358, 476, 476, 1446], [1448, 1448, 1502, 1536, 1809], [1907, 1974, 1994, 1994, 2041], [2043, 2043, 2066, 2066, 2335], [2337, 2337, 2357, 2357, 2760], [2762, 2762, 2803, 2803, 2847], [2849, 2849, 2891, 2891, 2925], [2972, 3027, 3063, 3063, 3139], [3141, 3141, 3175, 3175, 3265], [3267, 3267, 3295, 3295, 3424], [3472, 3472, 3493, 3588, 3764], [3766, 3836, 3878, 3878, 4054], [4056, 4056, 4098, 4098, 4273], [4275, 4275, 4317, 4317, 4493], [4495, 4495, 4549, 4549, 4627], [4712, 4712, 4737, 4737, 5104], [5106, 5106, 5159, 5159, 5612], [5614, 5614, 5671, 5671, 7326]], "test": "untested"}
{"id": "7llSD8", "name": "Rotation Migration", "author": "Tater", "description": "For the weekly creative coding challenge by @Sableraph, the prompt being \"Rotation\"", "tags": ["2d", "motionblur", "rotation"], "likes": 21, "viewed": 527, "published": 3, "date": "1625629171", "time_retrieved": "2024-07-30T19:11:57.079016", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvNorm = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    //matching time function but not increasing\n    float smoothTime = smoothstep(0.0,1.0,fract(iTime));\n    \n    //Chrome ab increases further out and is synced to movement\n    float ca = sqrt(length(uvNorm))*0.005*sin(fract(iTime*speed)*pi);\n    \n    //Sample texture with offset for chrome ab\n    col.r = texture(iChannel0,uv+ca).r;\n    col.g = texture(iChannel0,uv).g;\n    col.b = texture(iChannel0,uv-ca).b;\n    \n    col+=vec3(0.1);\n    \n    fragColor = vec4(col,0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define T(uv) texture(iChannel0,(uv)/iResolution.xy).xyz\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pmod(p,x) (mod(p,x) - (x)*0.5)\nvoid mainImage( out vec4 fragColor, in vec2 U )\n{\n    vec2 R = iResolution.xy;\n    float t=iTime*speed;\n    //t = (floor(iTime*60.0)/60.0)*speed; //Testing how it looks at 60fps\n    vec2 uv = (U-0.5*R.xy)/R.y; \n    vec3 col = vec3(0);\n    \n    float aa = 1.0/R.y; //aa constant based on resolution\n    \n    float wdth = 0.011;//cross size (nice value to play with)\n    float lngth = wdth*9.0;//cross length\n    \n    //Warp edges of screen \n    float screenWarp = 1.0+pow(length(uv),10.0)*0.3;\n    uv*=screenWarp;\n    aa*=screenWarp;\n    \n    //domain repitition IDs and size\n    float rep = lngth*2.5;\n    vec2 id = floor(uv/rep);\n    \n    //4 cycle uv shifting based on ID\n    float cycle = floor(mod(t,4.0));\n    float smoothTime = smoothstep(0.0,1.0,fract(t))+floor(t);\n    if(cycle == 0.0)uv.x+=(id.y+2.0)*rep*smoothTime;\n    if(cycle == 1.0)uv.y+=(id.x+4.0)*rep*smoothTime;\n    if(cycle == 2.0)uv.x+=(id.y-1.0)*rep*smoothTime;\n    if(cycle == 3.0)uv.y+=(id.x-3.0)*rep*smoothTime;\n    \n    //Infinite crosses\n    uv = pmod(uv,rep);\n\n    //Rotate crosses but alternate direction every other time\n    uv*=rot(smoothTime*pi*sign(sin(t*pi)));\n\n    //Making 2 lines to form a cross\n    float crs = smoothstep(wdth+aa,wdth-aa,abs(uv.x));\n    crs = max(crs,smoothstep(wdth+aa,wdth-aa,abs(uv.y)));\n    \n    //cutting it after a certain distance from center\n    float dist = max(abs(uv.x),abs(uv.y));\n    crs*=smoothstep(lngth+aa,lngth-aa,dist);\n    \n    //Stack this frame with the previous for motion blur \n    //It's perhaps unrealistcally high but I like the effect\n    col=T(U)*0.75 + vec3(crs);\n   \n    col = clamp(col,0.0,1.0);\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.1415926535\n#define speed 0.85", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7llSD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 664]], "test": "untested"}
{"id": "ftsXD8", "name": "Dim in Another World", "author": "squid", "description": ".", "tags": ["3d"], "likes": 3, "viewed": 254, "published": 3, "date": "1625614873", "time_retrieved": "2024-07-30T19:11:57.928744", "image_code": "#define PI 3.1415926535898\n\n#define MOD2 vec2(443.8975,397.2973)\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\n#define MOD4 vec4(443.8975,397.2973, 491.1871, 470.7827)\nfloat hash13(vec3 p)\n{\n\tp  = fract(p * MOD3);\n    p += dot(p.xyz, p.yzx + 19.19);\n    return fract(p.x * p.y * p.z);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3.zxy, p3.yxz+19.19);\n    return fract(vec3(p3.x * p3.y, p3.x*p3.z, p3.y*p3.z));\n}\nvec3 hash33(vec3 p)\n{\n\tp = fract(p * MOD3);\n    p += dot(p.zxy, p+19.19);\n    return fract(vec3(p.x * p.y, p.x*p.z, p.y*p.z));\n}\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx) * MOD4);\n    p4 += dot(p4.wzxy, p4+19.19);\n    return fract(vec4(p4.x * p4.y, p4.x*p4.z, p4.y*p4.w, p4.x*p4.w));\n}\n\nmat2 rot2(float a){\n    float c = cos(a); float s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat SM(float a, float b, float k)\n{\n    float xp = clamp(-(b-a) * k + 0.5, 0.0, 1.0), xp2 = xp*xp;\n   \treturn a+min((b-a), xp2 * (xp2 * 0.5 - xp) / k);\n}\n\nvec2 U(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 path(float ct) {\n    return vec3(cos(ct*0.05)*6.,sin(ct*0.4)*1.6+10.0, ct*3.);\n}\n\nfloat height(vec2 p) {\n    return (sin(p.y*0.5+63.)+sin(p.x*0.5-23.))*1. + (cos(p.y*0.06-35.)+cos(p.x*0.02+95.))*2. + 3.;\n}\n\nvec2 map_(vec3 p){\n    float lt = p.y - height(p.xz);\n    vec3 q = mod(p, 8.)-4.;\n    vec4 h = hash43(floor(p/8.));\n    lt = max(lt, (3.+h.x*h.y)-length(q));\n    return vec2(lt, 1.);\n}\nfloat map(vec3 p) { return map_(p).x; }\n\nvec3 N(in vec3 p)\n{  \n    vec2 e = vec2(-1.,1.)*0.01;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n\nfloat G(vec3 uv, float width) {\n\tvec3 c = max(step(abs(uv), vec3(width*.5))*.8,step(fract(uv), vec3(width*1.2))*.2);\n\treturn max(c.x,max(c.y,c.z));\n}\n\n\nvec2 trace(in vec3 ro, in vec3 rd) {\n    float t = 0., dt;\n\tfor(int i=0; i<512; i++){\n\t\tdt = map(ro + rd*t);\n\t\tif(dt<5e-3 || t > 150.) break;\n\t\tt += dt*0.5;\n\t}\n    return vec2(t,dt);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    vec3 ro = path(iTime) + vec3(0., 0.0, -2.);\n\tvec3 c,sp,\n        f = normalize(path(iTime+1.)-ro),\n        r = normalize(vec3(f.z, 0., -f.x)),\n        u = cross(f, r),\n        rd = normalize(f + uv.x*r + uv.y*u);\n    \n    const vec3 sun = normalize(vec3(0.15,0.125,0.6));\n    const vec3 sun_col = vec3(1.0,0.8,0.5);\n    const vec3 lamp_col = vec3(0.9,0.99,0.75);\n    const vec3 surf = vec3(0.6,0.6,0.64);\n        \n\tvec2 trs = trace(ro, rd);\n\tfloat t = trs.x, dt = trs.y, x;\n\tif(dt<5e-3){\n    \tsp = t * rd+ro;\n        x = map_(sp).y;\n        vec3 n = N(sp);\n        vec3 L = (sp-(path(iTime+8.0)));\n        float Ld = length(L);\n        L /= -Ld;\n        c = min(1./(0.05*Ld*Ld),1.0)*lamp_col * max(dot(L,n),0.) * surf * (trace(sp+L*0.1,L).y<5e-3?0.:1.) +\n            sun_col * max(dot(sun,n),0.) * surf * (trace(sp+sun*0.1,sun).y<5e-3?0.:1.) +\n            0.5*(1.-surf)*pow(max(1.-abs(dot(n, rd)), 0.),10.);\n        c = mix(c, vec3(0.0), t/150.0);\n\t} else {\n        c = pow(dot(rd,sun),2000.)*sun_col;\n    }\n    c = mix(c, vec3(0.0), pow(length(uv*vec2(0.9,1.2)),5.));\n    c = pow(c, vec3(0.735));\n\t\n\tfragColor = c.xyzz;\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsXD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 169, 191, 191, 287], [289, 289, 310, 310, 446], [447, 447, 468, 468, 575], [576, 576, 597, 597, 742], [744, 744, 763, 763, 832], [834, 834, 871, 871, 989], [991, 991, 1015, 1015, 1047], [1049, 1049, 1082, 1082, 1135], [1137, 1137, 1189, 1189, 1296], [1298, 1298, 1319, 1319, 1383], [1385, 1385, 1407, 1407, 1508], [1510, 1510, 1528, 1528, 1694], [1695, 1695, 1714, 1714, 1734], [1736, 1736, 1755, 1755, 1915], [1918, 1918, 1949, 1949, 2067], [2070, 2070, 2106, 2106, 2254], [2256, 2256, 2312, 2312, 3503]], "test": "untested"}
{"id": "NtlXDH", "name": "fft color sphere", "author": "schobbejack", "description": "modulate sphere radius by fft", "tags": ["fft", "polar", "ycbcr"], "likes": 2, "viewed": 229, "published": 3, "date": "1625608657", "time_retrieved": "2024-07-30T19:11:58.677741", "image_code": "const float pi = acos(-1.);\n\nfloat fft(float x)\n{\n\n    float f = texture(iChannel0,vec2(pow(x,1.5)*(1.-pow(cos(x*pi*2.)*.5+.5,30.)),0)).x;\n    float cutoff = 0.25;\n    f = (clamp(f,cutoff,1.0)-cutoff)/(1.-cutoff);\n    return f;\n}\n\nfloat r(vec2 uv)\n{\n    float a = clamp(atan(uv.x,uv.y)/(pi*2.)+.5,0.,1.);\n    float f = clamp(pow(fft(mod(a+.5,1.)),2.)+.15,.1,1.);\n    return 1.-smoothstep(f*.3,f+.05,length(uv)*.75);\n}\n\nvec3 to_rgb(vec3 ycbcr)\n{\n    // full range bt709 matrix\n    const mat3 c709=mat3(1.0000000000, 1.0000000000, 1.0000000000,\n                      0.0000000000, -0.1873242729, 1.8556000000,\n                      1.5748000000, -0.4681242729, 0.0000000000);\n    return c709 * ycbcr;\n}\n\nvec2 rot(vec2 uv, float r)\n{\n    float s=sin(r);\n    float c=cos(r);\n    \n    return vec2(uv.x*c-uv.y*s,uv.x*s+uv.y*c);\n}\n\nvec2 vsphere(float x)\n{\n    return vec2(sin(x*pi),cos(x*pi));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 f )\n{\n    vec2 uv = (2.*f-iResolution.xy)/iResolution.xy;\n    uv+=vec2(cos(iTime),sin(iTime)+.5)*.2;\n\n\n    float m = r(uv);\n    \n    uv=rot(uv,iTime*pi*.5);\n    float inv = 1./length(uv);\n    uv*=inv;    \n    \n    vec2 cbcr=vsphere(uv.x+iTime)*.3;\n\n    vec3 col=vec3(to_rgb(vec3(inv*.1,cbcr)))*m;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 27775, "src": "https://soundcloud.com/scene_music/unreal-ii", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtlXDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 49, 49, 229], [231, 231, 249, 249, 417], [419, 419, 444, 475, 700], [702, 702, 730, 730, 823], [825, 825, 848, 848, 888], [890, 890, 939, 939, 1263]], "test": "untested"}
{"id": "wdGfWD", "name": "sin(x * y + t) = sin(x) + sin(y)", "author": "sheepmaster", "description": "Countour plot of sin(x * y + t) = sin(x) + sin(y)", "tags": ["2d", "contour"], "likes": 9, "viewed": 263, "published": 3, "date": "1625604270", "time_retrieved": "2024-07-30T19:11:59.525475", "image_code": "const float BASE_SCALE = 8.;\nconst float STROKE_WIDTH = 1.;\nconst float PERIOD = 3.;\n\nconst float TAU = 8. * atan(1.);\n\nvec3 f(float x, float y, float t) {\n    return vec3(sin(x * y + t) - (sin(x) + sin(y)),\n                y * cos(x * y + t) - cos(x), \n                x * cos(x * y + t) - cos(y));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float scale = BASE_SCALE / min(iResolution.x, iResolution.y);\n    vec2 uv = (2.0*fragCoord-iResolution.xy) * scale;;\n\n\tvec3 f = f(uv.x, uv.y, iTime / PERIOD * TAU);\n    float d = abs(f.x) / length(f.yz);\n\n    float col = smoothstep(STROKE_WIDTH+1., STROKE_WIDTH-1., d/2./scale);\n    fragColor = vec4(vec3(col), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGfWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 120, 155, 155, 301], [303, 303, 358, 358, 680]], "test": "untested"}
{"id": "flXSDH", "name": "Independence Day Fireworks", "author": "oneshade", "description": "Inspired by Martijn's tutorial [url=https://www.youtube.com/watch?v=t4XnK50ocMk]https://www.youtube.com/watch?v=t4XnK50ocMk[/url]\nA bit late but I had to finish it still :)", "tags": ["flag", "fireworks", "shaderart", "american", "independence", "fourthofjuly"], "likes": 19, "viewed": 339, "published": 3, "date": "1625600742", "time_retrieved": "2024-07-30T19:12:00.353262", "image_code": "// Constants\n#define TAU 6.28318530718\n#define PI 3.14159265359\n#define RHO 1.57079632679\n\n// Utilities\n#define fillDraw(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n#define glowDraw(dist, col, glow) color += col / exp((glow) * (dist))\n#define remap01(x, a, b) ((x) - (a)) / ((b) - (a))\n\n// SDFs\nfloat sdDisk(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    p = abs(p) - b;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdStar5(in vec2 p, in float r, in float rf) {\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0 * max(dot(k1, p), 0.0) * k1;\n    p -= 2.0 * max(dot(k2, p), 0.0) * k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf * vec2(-k1.y, k1.x) - vec2(0.0, 1.0);\n    float h = clamp(dot(p, ba) / dot(ba, ba), 0.0, r);\n    return length(p - ba * h) * sign(p.y * ba.x - p.x * ba.y);\n}\n\n// Simple trajectory with an initial position, linear velocity and gravity\nvec2 posInTrajectory(in vec2 p0, in vec2 v0, in float g, in float t) {\n    vec2 p = p0 + v0 * t;\n    p.y -= 0.5 * g * t * t;\n    return p;\n}\n\nvec2 velInTrajectory(in vec2 p0, in vec2 v0, in float g, in float t) {\n    v0.y -= g * t;\n    return v0;\n}\n\n// I would try optimizing with a bbox check but unfortunately\n// the glow just doesn't work well with that :(\nvec2 sdTrajectory(in vec2 p, in vec2 p0, in vec2 v0, in float g, in float tStart, in float tEnd) {\n    vec2 q = p0 - p;\n    float t3 = 0.5 * g * g;\n    float t2 = -1.5 * g * v0.y;\n    float t1 = dot(v0, v0) - q.y * g;\n    float t0 = dot(q, v0);\n\n    t2 /= t3, t1 /= t3, t0 /= t3;\n    float t22 = t2 * t2;\n    vec2 pq = vec2(t1 - t22 / 3.0, t22 * t2 / 13.5 - t2 * t1 / 3.0 + t0);\n    float ppp = pq.x * pq.x * pq.x, qq = pq.y * pq.y;\n\n    float p2 = abs(pq.x);\n    float r1 = 1.5 / pq.x * pq.y;\n\n    if (qq * 0.25 + ppp / 27.0 > 0.0) {\n        float r2 = r1 * sqrt(3.0 / p2), root;\n        if (pq.x < 0.0) root = sign(pq.y) * cosh(acosh(r2 * -sign(pq.y)) / 3.0);\n        else root = sinh(asinh(r2) / 3.0);\n        root = -2.0 * sqrt(p2 / 3.0) * root - t2 / 3.0;\n        return vec2(length(p - posInTrajectory(p0, v0, g, clamp(root, tStart, tEnd))), root);\n    }\n\n    else {\n        float ac = acos(r1 * sqrt(-3.0 / pq.x)) / 3.0;\n        vec2 roots = 2.0 * sqrt(-pq.x / 3.0) * cos(vec2(ac, ac - 4.18879020479)) - t2 / 3.0;\n        vec2 p1 = p - posInTrajectory(p0, v0, g, clamp(roots.x, tStart, tEnd));\n        vec2 p2 = p - posInTrajectory(p0, v0, g, clamp(roots.y, tStart, tEnd));\n        float d1 = dot(p1, p1), d2 = dot(p2, p2);\n        return  d1 < d2 ? vec2(sqrt(d1), roots.x) : vec2(sqrt(d2), roots.y);\n    }\n}\n\n// Modified hash from https://www.shadertoy.com/view/4djSRW\nfloat gSeed = 167.23;\nfloat random() {\n    float x = fract(gSeed++ * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nvoid doFirework(inout vec3 color, in vec2 uv, in float time, in float seed) {\n    float timeFrame = floor(time / 3.0) * 3.0;\n    float fireTime = time - timeFrame;\n\n    // Generate random traits\n    gSeed = timeFrame + seed;\n    float angle = mix(0.4, 0.6, random()) * PI;\n    float speed = mix(2.0, 2.5, random());\n    vec3 sparkColor = normalize(vec3(random(), random(), random())) * 1.25;\n\n    // Compute start position, velocity, and gravity\n    vec2 p0 = vec2(0.0, 0.6);\n    vec2 v0 = vec2(cos(angle), sin(angle)) * speed;\n    float g = 1.0;\n\n    // Tracking\n    float tApogee = v0.y / g;\n    float t = tApogee * fireTime;\n    vec2 pos = posInTrajectory(p0, v0, g, t);\n\n    // Projectile and trail\n    vec3 fadeColor = sparkColor * (1.0 - fireTime / 3.0);\n    vec2 arc = sdTrajectory(uv, p0, v0, g, max(0.0, t - 2.0), t);\n    glowDraw(arc.x - 0.01, fadeColor * clamp(remap01(arc.y, t - 2.0, t), 0.0, 1.0), 15.0);\n    glowDraw(sdDisk(uv - pos, 0.02), fadeColor, 25.0);\n\n    // Cast a circle of sparks from the apogee (highest point in the trajectory)\n    if (t > tApogee) {\n        fireTime -= 1.0;\n        vec2 vApogee = velInTrajectory(p0, v0, g, tApogee);\n        p0 = posInTrajectory(p0, v0, g, tApogee);\n        for (float an=0.0; an < TAU; an += TAU / 25.0) {\n            // Tracking\n            v0 = vec2(cos(an), sin(an)) * (0.5 + random()) + vApogee;\n            t = tApogee * fireTime;\n            pos = posInTrajectory(p0, v0, g, t);\n\n            // Projectile with trail\n            vec3 fadeColor = sparkColor * (1.0 - 0.5 * fireTime);\n            vec2 arc = sdTrajectory(uv, p0, v0, g, 0.0, t);\n            glowDraw(arc.x - 0.01, fadeColor * clamp(remap01(arc.y, t - 1.0, t), 0.0, 1.0), 15.0);\n            glowDraw(sdDisk(uv - pos, 0.02), fadeColor, 25.0);\n        }\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - vec2(0.5 * iResolution.x, 0.0)) / iResolution.y * 4.0;\n    vec3 color = mix(vec3(1.0, 0.8, 0.0), vec3(0.5, 0.0, 0.0), 0.25 * (length(uv) - 0.25));\n    float unit = 8.0 / iResolution.y;\n\n    // Flagpole\n    fillDraw(sdBox(vec2(uv.x, uv.y - 1.75), vec2(0.035, 1.75)), vec3(0.0));\n\n    // Flag\n    vec2 flagUv = uv - vec2(0.845, 2.85);\n\n    // Wave and shear to make it look like its more in perspective\n    float x = uv.x - 0.035;\n    flagUv.x = 1.1 * flagUv.x + 0.08;\n    flagUv.y += 0.1 * x * sin(3.0 * (flagUv.x - iTime)) + 0.3 * x;\n\n    // Shadows to highlight the ripples\n    float shadow = 0.4 * sin(3.0 * (flagUv.x - iTime));\n    shadow *= shadow;\n\n    fillDraw(sdBox(flagUv, vec2(0.8, 0.64)), vec3(1.0) - shadow);\n\n    // Red and white stripes (one for each of the original 13 colonies)\n    vec2 stripesUv = flagUv;\n    stripesUv.y -= clamp(round(stripesUv.y * 5.0) * 0.2, -0.6, 0.6);\n    fillDraw(sdBox(stripesUv, vec2(0.8, 0.6 / 13.0)), vec3(0.78, 0.06, 0.18) - shadow);\n\n    // Blue background and stars (one star for each of the 50 current states)\n    // The stars are in staggered rows, 6 stars, 5 stars, repeat for 9 rows total\n    vec2 starsUv = flagUv - vec2(-0.38, 0.3);\n    fillDraw(sdBox(starsUv, vec2(0.425, 0.35)), vec3(0.0, 0.13, 0.41) - shadow);\n\n    vec2 repSize = vec2(0.85, 0.7) / vec2(6.0, 9.0);\n    float cy = floor(starsUv.y / repSize.y + 0.5) * repSize.y; // Cell y coordinate\n\n    float stagger = mod(floor(cy / repSize.y), 2.0) * 0.5;\n    float bx = 0.375 - stagger * repSize.x; // Repetition x bound (varied to create staggered rows)\n    float cx = (floor(starsUv.x / repSize.x + stagger) + abs(stagger - 0.5)) * repSize.x; // Cell x coordinate\n\n    starsUv -= clamp(vec2(cx, cy), -vec2(bx, 0.3), vec2(bx, 0.3));\n    fillDraw(sdStar5(starsUv, 0.02, 0.4), vec3(1.0) - shadow);\n\n    // Fireworks\n    vec2 fireUv = uv;\n    fireUv.x = abs(fireUv.x) - 2.0;\n\n    // Spouts\n    fillDraw(sdBox(vec2(fireUv.x, fireUv.y - 0.04), vec2(0.15, 0.04)), vec3(0.0));\n    fillDraw(sdBox(vec2(fireUv.x, fireUv.y - 0.3), vec2(0.06, 0.3)), vec3(0.0));\n\n    // Sparks\n    doFirework(color, vec2(uv.x - 2.0, uv.y), iTime, 394.438);\n    doFirework(color, vec2(uv.x + 2.0, uv.y), iTime + 1.0, 593.458);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flXSDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[307, 315, 352, 352, 380], [382, 382, 429, 429, 537], [539, 539, 574, 574, 654], [656, 707, 758, 758, 1168], [1170, 1245, 1315, 1315, 1385], [1387, 1387, 1457, 1457, 1493], [1495, 1605, 1703, 1703, 2920], [3004, 3004, 3020, 3020, 3118], [3120, 3120, 3197, 3197, 4912], [4914, 4914, 4969, 4969, 7242]], "test": "untested"}
{"id": "fllSD8", "name": "Psychedelic Eye", "author": "mrange", "description": "License CC0: Psychedelic eye\nContinuation of weekend experiment\n", "tags": ["2d", "fbm", "warp"], "likes": 22, "viewed": 591, "published": 3, "date": "1625589701", "time_retrieved": "2024-07-30T19:12:01.301725", "image_code": "// License CC0: Psychedelic eye\n//  Continuation of weekend experiment\n\n#define PI            3.141592654\n#define TAU           (2.0*PI)\n#define TIME          iTime\n#define TTIME         (TAU*TIME)\n#define RESOLUTION    iResolution\n#define ROT(a)        mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x)       (0.5 + 0.5*cos(x))\n#define DOT2(x)       dot(x, x)\n#define BPERIOD       5.6\n#define MPERIOD       7.2\n#define FLIP          10.0\n\nconst vec2 iris_center = vec2(0.0, 0.28);\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst vec3  grid_color    = HSV2RGB(vec3(0.6, 0.3, 1.0)); \nconst vec3  light0_color  = 16.0*HSV2RGB(vec3(0.6, 0.5, 1.0)); \nconst vec3  light1_color  = 8.0*HSV2RGB(vec3(0.9, 0.25, 1.0)); \nconst vec3  sky0_color    = HSV2RGB(vec3(0.05, 0.65, -0.25)); \nconst vec3  sky1_color    = HSV2RGB(vec3(0.6, 0.5, 0.25)); \nconst vec3  light0_pos    = vec3(1.0, 5.0, 4.0);\nconst vec3  light1_pos    = vec3(3.0, -1.0, -8.0);\nconst vec3  light0_dir    = normalize(light0_pos);\nconst vec3  light1_dir    = normalize(light1_pos);\nconst vec4  planet_sph    = vec4(50.0*normalize(light1_dir+vec3(0.025, -0.025, 0.0)), 10.0);\n\nint   g_eff = 0;\n\nfloat g_hf;\n\nvec2 g_vx = vec2(0.0);\nvec2 g_vy = vec2(0.0);\n\nvec2 g_wx = vec2(0.0);\nvec2 g_wy = vec2(0.0);\n\n\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.0-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n}\n\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, vec3(1.0/2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// Based on: https://iquilezles.org/articles/distfunctions2d\nfloat vesica(vec2 p, vec2 sz) {\n  if (sz.x < sz.y) {\n    sz = sz.yx;\n  } else {\n    p  = p.yx; \n  }\n  vec2 sz2 = sz*sz;\n  float d  = (sz2.x-sz2.y)/(2.0*sz.y);\n  float r  = sqrt(sz2.x+d*d);\n  float b  = sz.x;\n  p = abs(p);\n  return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                           : length(p-vec2(-d,0.0))-r;\n}\n\n// IQ's box\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat eye_shape(vec2 p) {\n  float a  = mix(0.0, 1.0, smoothstep(0.995, 1.0, cos(TTIME/BPERIOD)));\n  const float w = 1.14;\n  float h = mix(0.48, 0.05, a);\n  float d0 =  vesica(p, vec2(w, h));\n  return d0;\n}\n\n// IQ's ray sphere intersect: https://iquilezles.org/articles/intersectors\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sph) {\n  vec3 oc = ro - sph.xyz;\n  float b = dot( oc, rd );\n  float c = dot( oc, oc ) - sph.w*sph.w;\n  float h = b*b - c;\n  if (h < 0.0) return vec2(-1.0);\n  h = sqrt(h);\n  return vec2(-b - h, -b + h);\n}\n\n// IQ's ray plane intersect: https://iquilezles.org/articles/intersectors\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return p.x*vec2(cos(p.y), sin(p.y));\n}\n\nvec3 toSpherical(vec3 p) {\n  float r   = length(p);\n  float t   = acos(p.z/r);\n  float ph  = atan(p.y, p.x);\n  return vec3(r, t, ph);\n}\n\nvec3 toRect(vec3 p) {\n  return p.x*vec3(cos(p.z)*sin(p.y), sin(p.z)*sin(p.y), cos(p.y));\n}\n\n// https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return -pmin(-a, a, k);\n}\n\nfloat noise(vec2 p) {\n  float a = sin(p.x);\n  float b = sin(p.y);\n  float c = 0.5 + 0.5*cos(p.x + p.y);\n  float d = mix(a, b, c);\n  return d;\n}\n\n// https://iquilezles.org/articles/fbm\nfloat fbm(vec2 p, float aa) {\n  const mat2 frot = mat2(0.80, 0.60, -0.60, 0.80);\n\n  float f = 0.0;\n  float a = 1.0;\n  float s = 0.0;\n  float m = 2.0;\n  for (int x = 0; x < 4; ++x) {\n    f += a*noise(p); \n    p = frot*p*m;\n    m += 0.01;\n    s += a;\n    a *= aa;\n  }\n  return f/s;\n}\n\n// https://iquilezles.org/articles/warp\nfloat warp(vec2 p, out vec2 v, out vec2 w) {\n  const float r  = 0.5;\n  const float rr = 0.25;\n  float l2 = length(p);\n  float f  = 1.0;\n\n  switch (g_eff) {\n  case 0:\n//    f = smoothstep(r, r+rr, l2);\n    f = smoothstep(-0.1, 0.15, eye_shape(p));\n    p.y += TIME*0.125;\n    p.x = pabs(p.x, 0.1);\n    break;\n  case 1:\n    const float z = 0.75; \n    f = smoothstep(-0.05, 0.1, eye_shape(p.yx/z)*z);\n    f = smoothstep(r, r+rr, l2);\n    p = -p.yx;\n    p = toPolar(p);\n//    f = smoothstep(r, r+rr, l2);\n    p.y -= -0.125*TIME+p.x*1.25;\n    break;\n  default:\n    break;\n  }\n\n  g_hf = f;\n  vec2 pp = p;\n\n  vec2 vx = g_vx;\n  vec2 vy = g_vy;\n\n  vec2 wx = g_wx;\n  vec2 wy = g_wy;\n\n\n  //float aa = mix(0.95, 0.25, tanh_approx(pp.x));\n  float aa = 0.5;\n\n  v = vec2(fbm(p + vx, aa), fbm(p + vy, aa))*f;\n  w = vec2(fbm(p + 3.0*v + wx, aa), fbm(p + 3.0*v + wy, aa))*f;\n  \n  return -tanh_approx(fbm(p + 2.25*w, aa)*f);\n}\n\nvec3 normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = warp(p + e.xy, v, w) - warp(p - e.xy, v, w);\n  n.y = 2.0*e.x;\n  n.z = warp(p + e.yx, v, w) - warp(p - e.yx, v, w);\n  \n  return normalize(n);\n}\n\nvoid compute_globals() {\n  vec2 vx = vec2(0.0, 0.0);\n  vec2 vy = vec2(3.2, 1.3);\n\n  vec2 wx = vec2(1.7, 9.2);\n  vec2 wy = vec2(8.3, 2.8);\n\n  vx *= ROT(TTIME/1000.0);\n  vy *= ROT(TTIME/900.0);\n\n  wx *= ROT(TTIME/800.0);\n  wy *= ROT(TTIME/700.0);\n  \n  g_vx = vx;\n  g_vy = vy;\n  \n  g_wx = wx;\n  g_wy = wy;\n}\n\nvec3 iris(vec2 p) {\n  const vec3 up  = vec3(0.0, 1.0, 0.0);\n  const vec3 lp1 = 1.0*vec3(1.0, 1.25, 1.0);\n  const vec3 lp2 = 1.0*vec3(-1.0, 2.5, 1.0);\n\n  vec3 ro = vec3(0.0, 10.0, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec2 v;\n  vec2 w;\n \n  float h  = warp(p, v, w);\n  float hf = g_hf;\n  vec3  n  = normal(p);\n\n  vec3 lcol1 = hsv2rgb(vec3(0.7, 0.5, 1.0)); \n  vec3 lcol2 = hsv2rgb(vec3(0.4, 0.5, 1.0));\n  vec3 po  = vec3(p.x, 0.0, p.y);\n  vec3 rd  = normalize(po - ro);\n  \n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3  ref   = reflect(rd, n);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  const vec3 col1 = vec3(0.1, 0.7, 0.8).xzy;\n  const vec3 col2 = vec3(0.7, 0.3, 0.5).zyx;\n  \n  float a = length(p);\n  vec3 col = vec3(0.0);\n//  col += hsv2rgb(vec3(fract(0.3*TIME+0.25*a+0.5*v.x), 0.85, abs(tanh_approx(v.y))));\n//  col += hsv2rgb(vec3(fract(-0.5*TIME+0.25*a+0.125*w.x), 0.85, abs(tanh_approx(w.y))));\n  col += hsv2rgb(vec3(fract(-0.1*TIME+0.125*a+0.5*v.x+0.125*w.x), abs(0.5+tanh_approx(v.y*w.y)), tanh_approx(0.1+abs(v.y-w.y))));\n//  col += (length(v)*col1 + length(w)*col2*1.0);\n//  col += diff1;\n//  col += diff2;\n//  col *= 0.0;\n  col += 0.5*lcol1*pow(ref1, 20.0);\n  col += 0.5*lcol2*pow(ref2, 10.0);\n  col *= hf;\n\n//  col = n;\n  return col;\n}\n\nvec3 eye_complete(vec2 p) {\n  const float iris_outer = 0.622;\n  const float iris_inner = 0.285;\n\n  \n  float t0 = abs(0.9*p.x);\n  t0 *= t0;\n  t0 *= t0;\n  t0 *= t0;\n  t0 = clamp(t0, 0.0, 1.0);\n  float dt0 = mix(0.0125, -0.0025, t0);\n\n  vec2 p0 = p;\n  float d0 = eye_shape(p);\n  float d5 = d0;\n\n  vec2 p1 = p;\n  p1 -= iris_center;\n  float d1 = circle(p1, iris_outer);\n  d1 = max(d1,d0+dt0);\n  float d6 = d1;\n\n  vec2 p2 = p;\n  p2 -= vec2(0.155, 0.35);\n  float d2 = circle(p2, 0.065);\n\n  vec2 p3 = p;\n  p3 -= iris_center;\n  p3 = toPolar(p3);\n  float n3 = mod1(p3.x, 0.05);\n  float d3 = abs(p3.x)-0.0125*(1.0-1.0*length(p1));\n\n  vec2 p4 = p;\n  p4 -= iris_center;\n  float d4 = circle(p4, iris_inner);\n\n  d3 = max(d3,-d4);\n\n  d1 = pmax(d1,-d2, 0.0125);\n  d1 = max(d1,-d3);\n\n  d0 = abs(d0)-dt0;\n\n\n  float d = d0;\n  d = pmin(d, d1, 0.0125);\n  return vec3(d, d6, d5);\n}\n\nvec3 df(vec2 p) {\n  return eye_complete(p); \n}\n\nvec3 render_background(vec3 ro, vec3 rd, vec3 nrd) {\n  rd.xy *= ROT(-PI/2.0+0.6);\n  vec3 srd = toSpherical(rd.xzy);\n  srd.z += 0.025*TIME;\n  vec2 pg  = srd.yz;\n  float f  = sin(pg.x); \n  float lf2= ceil(log(f)/log(2.0)-0.505);\n  float mf = pow(2.0, lf2);\n\n  float aa = 0.005;\n  const float count = 20.0;\n  const vec2 sz = vec2(2.0*PI/count);\n  vec2 ng = mod2(pg, vec2(mf, 1.0)*sz);\n\n  float dg = min(abs(pg.y)*f, abs(pg.x))-aa*0.0;\n  vec3 lines = grid_color*smoothstep(-aa, aa, -dg)*f*f;\n\n  vec3 sky  = smoothstep(1.0, 0.0, rd.y)*sky1_color+smoothstep(0.5, 0.0, rd.y)*sky0_color;\n\n  vec2 pi = raySphere(ro, rd, planet_sph);\n\n  float lf1 = 1.0;\n  if (pi.x > 0.0) {\n    vec3 ppos = ro+rd*pi.x;\n    float t = 1.0-tanh_approx(1.5*(pi.y - pi.x)/planet_sph.w);\n    sky *= mix(0.5, 1.0, t);\n    lf1 = t;\n  } else {\n    sky += lines;\n  }\n\n  sky += pow(max(dot(rd, light0_dir), 0.0), 800.0)*light0_color; \n  sky += pow(max(dot(rd, light0_dir), 0.0), 80.0)*light1_color*0.1; \n  sky += lf1*pow(max(dot(rd, light1_dir), 0.0), 150.0)*light1_color; \n  sky += lf1*pow(max(dot(rd, light1_dir), 0.0), 50.0)*light0_color*0.1; \n\n\n  return sky;\n}\n\nvec4 render_iris(vec3 ro, vec3 rd, vec3 nrd) {\n  vec4 plane = vec4(normalize(vec3(1.0, 0.165-0.00, 0.0)), -0.944);\n  float aa = TTIME/MPERIOD;\n  float bb = smoothstep(-0.125, 0.125, sin(aa));\n  plane.xy *= ROT(0.075*bb);\n  plane.xz *= ROT(0.25*bb*sign(-sin(PI/4.0+0.5*aa)));\n  vec3 tnor  = plane.xyz;\n  const vec3 tup   = normalize(vec3(0.0, -1.0, 0.0));\n  float t = rayPlane(ro, rd, plane);\n  if (t <= 0.0) {\n    return vec4(0.0);\n  }\n  \n  vec3 tpos = ro + t*rd;\n  tpos *= 4.0;\n  vec3 txx = normalize(cross(tnor, tup));\n  vec3 tyy = normalize(cross(tnor, txx));\n  \n  vec2 tpos2 = vec2(dot(txx, tpos), dot(tyy, tpos));\n  \n  vec3 col = iris(tpos2)*smoothstep(0.0, 1.0/75.0, t);\n  \n  return vec4(col, smoothstep(0.0, 1.0/500.0, t));\n}\n\n\nvec4 render_body(vec2 p, vec3 dd, float z) {\n//  p -= iris_center;\n  float aa = 2.0/RESOLUTION.y;\n  \n  vec3 ro = vec3(2.0, 0.0, 0.0);\n  vec3 la = vec3(0.0, 0.0, 0.0); \n\n  vec2 np   = p + vec2(4.0/RESOLUTION.y); \n\n  vec3 ww   = normalize(la - ro);\n  vec3 uu   = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv   = normalize(cross(ww,uu));\n  float rdd = 2.0;\n  vec3 rd   = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd  = normalize(np.x*uu + np.y*vv + rdd*ww);\n  \n  vec4 sph  = vec4(vec3(0.0), 1.0);\n  \n  vec2 si   = raySphere(ro, rd, sph);\n  if (si.x <= 0.0) {\n    return vec4(0.0);\n  }\n  \n  float a = smoothstep(-aa, aa, -dd.z);\n  float b = smoothstep(0.0, mix(0.25, 1.0, float(p.y > 0.0))*mix(0.075, 0.0025, smoothstep(0.5, 1.0, abs(p.x))), -dd.z/z);\n  float c = smoothstep(-aa, aa, -dd.x);\n\n  vec3 pos  = ro + rd*si.x;\n  \n  vec3 nor  = normalize(pos - sph.xyz);\n  \n  float dif0= max(dot(nor, light0_dir), 0.0);\n  float dif1= max(dot(nor, light1_dir), 0.0);\n  \n  vec3 ref  = reflect(rd, nor); \n  vec3 nref = reflect(nrd, nor); \n\n  vec3 refr = refract(rd, nor, 0.9); \n  vec3 nrefr= refract(nrd, nor, 0.9); \n\n  vec3 rbkg = render_background(pos, ref, nref);\n  vec4 riris= render_iris(pos, refr, nrefr);\n\n  vec3 col = vec3(0.0);\n  col += vec3(0.5);\n  col += dif1*0.5;\n  col += dif0*0.5;\n  if (fract((TIME/BPERIOD)/(2.0*FLIP)) > 0.5) {\n    rbkg = max(rbkg, 0.0);\n    rbkg = tanh(vec3(0.5, 1.0, 1.6)*rbkg).zxy;\n    col = mix(rbkg, rbkg*0.6, c);\n  } else {\n    col = alphaBlend(col, riris);\n    col += rbkg*mix(0.33, 1.0, riris.w);\n  }\n  col *= b;\n  \n  return vec4(col, a);\n}\n\nfloat synth(vec2 p) {\n  const float z = 4.0;\n  const float st = 0.02;\n  float dob = box(p, vec2(1.4, 0.5));\n  p.x = abs(p.x);\n  p.x += st*20.0;\n  p /= z;\n  float n = mod1(p.x, st);\n  float dib = 1E6;\n  const int around = 1;\n  for (int i = -around; i <=around ;++i) {\n    float fft = texture(iChannel0, vec2((n+float(i))*st, 0.25)).x; \n    fft *= fft;\n    float dibb = box(p-vec2(st*float(i), 0.0), vec2(st*0.25, 0.05*fft+0.001));\n    dib = min(dib, dibb);\n  }\n  \n  float dl = p.y;\n  dl = abs(dl) - 0.005;\n  dl = abs(dl) - 0.0025;\n  dl = abs(dl) - 0.00125;\n  float d = dib;\n  d = max(d, -dl);\n  //d = pmax(d, dob, 0.025);\n  return d*z;\n}\n\nvec3 effect(vec2 p) {\n  compute_globals();\n\n  float aa = 2.0/RESOLUTION.y;\n  const float m = 3.0; \n  const float z = 1.0;\n  p /= z;\n  vec2 pp  = p;\n  \n  vec3 d   = df(pp)*z;\n\n  vec4 dcol = vec4(mix(vec3(0.9), vec3(0.0), smoothstep(-aa, aa, -d.x)) , smoothstep(-aa, aa, -d.z));\n  g_eff = 1;\n  vec4 scol = render_body(p, d, z); \n  \n  vec3 col  = vec3(1.0);\n  g_eff = 0;\n  col = iris(p);\n\n  vec2 dp = p;\n  dp.y = -pabs(dp.y, 1.0);\n  dp -= vec2(0.0, -0.85);\n  dp = toPolar(dp);\n  dp.y += -0.2*(p.x);\n  dp = toRect(dp);\n  float dd = synth(dp);\n  \n  vec4 ddcol = vec4(vec3(0.9), smoothstep(-aa, aa, -dd));\n\n  col = alphaBlend(col, dcol);\n  if (fract((TIME/BPERIOD)/FLIP) > 0.5) {\n    col = alphaBlend(col, scol);\n  }\n  col -= 0.5*exp(-75.0*max(dd, 0.0));\n  col = alphaBlend(col, ddcol);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n\n  vec3 col = effect(p);\n  col = mix(vec3(0.0), col, smoothstep(0.5, 5.0, TIME));\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": 27750, "src": "https://soundcloud.com/lifeformsmusic/one-of-a-kind-1", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fllSD8.jpg", "access": "api", "license": "cc0-1.0", "functions": [[628, 628, 650, 650, 796], [1731, 1731, 1771, 1771, 1930], [1932, 1932, 1972, 1972, 2014], [2016, 2016, 2052, 2052, 2285], [2287, 2287, 2318, 2318, 2344], [2346, 2407, 2438, 2438, 2736], [2738, 2750, 2777, 2777, 2853], [2855, 2855, 2880, 2880, 3060], [3062, 3137, 3181, 3181, 3378], [3380, 3454, 3496, 3496, 3543], [3545, 3545, 3573, 3593, 3669], [3671, 3671, 3693, 3693, 3737], [3739, 3739, 3760, 3760, 3801], [3803, 3803, 3829, 3829, 3938], [3940, 3940, 3961, 3961, 4030], [4032, 4064, 4103, 4103, 4228], [4230, 4262, 4298, 4298, 4392], [4394, 4434, 4473, 4473, 4562], [4564, 4564, 4603, 4603, 4632], [4634, 4634, 4664, 4664, 4692], [4694, 4694, 4715, 4715, 4837], [4839, 4878, 4907, 4907, 5159], [5161, 5201, 5245, 5245, 6107], [6109, 6109, 6130, 6130, 6352], [6354, 6354, 6378, 6378, 6658], [6660, 6660, 6679, 6679, 8061], [8063, 8063, 8090, 8090, 8921], [8923, 8923, 8940, 8940, 8969], [8971, 8971, 9023, 9023, 10097], [10099, 10099, 10145, 10145, 10831], [10834, 10834, 10878, 10900, 12409], [12411, 12411, 12432, 12432, 13047], [13049, 13049, 13070, 13070, 13845], [13847, 13847, 13902, 13902, 14175]], "test": "untested"}
{"id": "7lXSDH", "name": "Fork notebook polar sin work on", "author": "firebreathz", "description": "hand drawing effect\n...i used to draw a lot, now i let computers pursue my hobbies ;)\n\ntook aspect ratio into account, so webcams dont get quenched too much\n...so try your webcam instead of jean claude ;)", "tags": ["effect", "pencil", "drawing", "hand"], "likes": 2, "viewed": 330, "published": 3, "date": "1625581345", "time_retrieved": "2024-07-30T19:12:02.212291", "image_code": "// Fork of \"Fork notebook polar sin\" by firebreathz. https://shadertoy.com/view/7tXSDH\n// 2021-07-06 14:20:40\n\n// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// trying to resemle some hand drawing style\n\n\n#define SHADERTOY\n#ifdef SHADERTOY\n#define Res0 iChannelResolution[0].xy\n#define Res1 iChannelResolution[1].xy\n#else\n#define Res0 textureSize(iChannel0,0)\n#define Res1 textureSize(iChannel1,0)\n#define iResolution Res0\n#endif\n\n#define Res  iResolution.xy\n\n#define randSamp iChannel1\n#define colorSamp iChannel0\n\n\nvec4 getRand(vec2 pos)\n{\n    return textureLod(iChannel1,pos/Res1/iResolution.y*1080., 0.0);\n}\n\nvec4 getCol(vec2 pos)\n{\n    // take aspect ratio into account\n    vec2 uv=((pos-Res.xy*.5)/Res.y*Res0.y)/Res0.xy+.5;\n    vec4 c1=texture(iChannel0,uv);\n    vec4 e=smoothstep(vec4(-0.05),vec4(-0.0),vec4(uv,vec2(1)-uv));\n    c1=mix(vec4(1,1,1,0),c1,e.x*e.y*e.z*e.w);\n    float d=clamp(dot(c1.xyz,vec3(-.5,1.,-.5)),0.0,1.0);\n    vec4 c2=vec4(.7);\n    return min(mix(c1,c2,1.8*d),.7);\n}\n\nvec4 getColHT(vec2 pos)\n{\n \treturn smoothstep(.5,.5,getCol(pos)*.8+.2+getRand(pos*.25));\n}\n\nfloat getVal(vec2 pos)\n{\n    vec4 c=getCol(pos);\n \treturn pow(dot(c.xyz,vec3(.333)),1.)*1.;\n}\n\nvec2 getGrad(vec2 pos, float eps)\n{\n   \tvec2 d=vec2(eps,0);\n    return vec2(\n        getVal(pos+d.xy)-getVal(pos-d.xy),\n        getVal(pos+d.yx)-getVal(pos-d.yx)\n    )/eps/9000.;\n}\n\n#define AngleNum 1\n\n#define SampNum 6\n#define PI2 60.28318530717959\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord+40.0*sin(iTime*1.*vec2(1,1.7))*iResolution.y/40000.;\n    vec3 col = vec3(0);\n    vec3 col2 = vec3(0);\n    float sum=0.;\n    for(int i=0;i<AngleNum;i++)\n    {\n        float ang=PI2/float(AngleNum)*(float(i)+.890);\n        vec2 v=vec2(cos(ang),sin(ang));\n        for(int j=0;j<SampNum;j++)\n        {\n            vec2 dpos  = v.yx*vec2(1,-1)*float(j)*iResolution.y/400.;\n            vec2 dpos2 = v.xy*float(j*j)/float(SampNum)*.5*iResolution.y/400.;\n\t        vec2 g;\n            float fact;\n            float fact2;\n\n            for(float s=-1.;s<=1.;s+=2.)\n            {\n                vec2 pos2=pos+s*dpos+dpos2;\n                vec2 pos3=pos+(s*dpos+dpos2).yx*vec2(1,-1)*2.;\n            \tg=getGrad(pos2,.4);\n            \tfact=dot(g,v)-.5*abs(dot(g,v.yx*vec2(1,-1)))/**(1.-getVal(pos2))*/;\n            \tfact2=dot(normalize(g+vec2(.0001)),v.yx*vec2(1,-1));\n                \n                fact=clamp(fact,0.,.05);\n                fact2=abs(fact2);\n                \n                fact*=1.-float(j)/float(SampNum);\n            \tcol += fact;\n            \tcol2 += fact2*getColHT(pos3).xyz;\n            \tsum+=fact2;\n            }\n        }\n    }\n    col/=float(SampNum*AngleNum)*.75/sqrt(iResolution.y);\n    col2/=sum;\n    col.x*=(.6+.8*getRand(pos*.7).x);\n    col.x=1.-col.x;\n    col.x*=col.x*col.x;\n\n    vec2 s=sin(pos.xy*.1/sqrt(iResolution.y/400.));\n    vec3 karo=vec3(1);\n    karo-=.95*vec3(.25,.1,.1)*dot(exp(-s*s*800.),vec2(1));\n    float r=length(pos-iResolution.xy*.5)/iResolution.x;\n    float vign=0.91-r*r*r;\n\tfragColor = vec4(vec3(col.x*col2*karo*vign),1);\n    //fragColor=getCol(fragCoord);\n}\n", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "#define WAVES 8.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\n\tfloat time = iTime * 1.0;\n\t\n\tvec3 color = vec3(0.0);\n\n\tfor (float i=0.0; i<WAVES + 1.0; i++) {\n\t\tfloat freq = texture(iChannel0, vec2(i / WAVES, 0.0)).x * 7.0;\n\n\t\tvec2 p = vec2(uv);\n\n\t\tp.x += i * 0.04 + freq * 0.03;\n\t\tp.y += sin(p.x * 10.0 + time) * cos(p.x * 2.0) * freq * 0.2 * ((i + 1.0) / WAVES);\n\t\tfloat intensity = abs(0.01 / p.y) * clamp(freq, 0.35, 2.0);\n\t\tcolor += vec3(1.0 * intensity * (i / 5.0), 0.5 * intensity, 1.75 * intensity) * (3.0 / WAVES);\n\t}\n\n\tfragColor = vec4(color, 1.0);\n}", "buffer_d_inputs": [{"id": 18, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Fork of \"Fork Fork Polar \" by firebreathz. https://shadertoy.com/view/stj3Rw\n// 2021-06-25 22:06:44\n\n// Fork of \"Fork Fork Polar firebreath 967\" by firebreathz. https://shadertoy.com/view/NdBXRG\n// 2021-06-13 18:25:29\n\n#define time iTime\n#define PI 3.14159265359\n\n#define NUM_BANDS 1000\n\n//#define REVERSED\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(1.000,1.000,1.000))) * 10.)*20.0-10.0;\n}\n\nvec3 mixc(vec3 col1, vec3 col2, float v)\n{\n    v = clamp(v,0.0,1.0);\n    return col1+v*(col2-col1);\n}\n\nvec3 drawBands(vec2 uv)\n{\n  \tuv = 2.0*uv-1.0;\n    uv.x*=iResolution.x/iResolution.y;\n    uv = vec2(length(uv), atan(uv.y,uv.x));\n    \n    uv.x-=0.01;\n    uv.x = max(0.0,uv.x);\n    \n    uv.y -= PI*0.5;\n    vec2 uv2 = vec2(uv.x, uv.y*-1.0);\n    uv.y = mod(uv.y,PI*2.0);\n    uv2.y = mod(uv2.y,PI*2.0);\n    \n    vec3 col = vec3(0.0);\n    vec3 col2 = vec3(0.0);\n    \n    float nBands = float(NUM_BANDS);\n    float i = floor(uv.x*nBands);\n    float f = fract(uv.x*nBands);\n    float band = i/nBands;\n   \tfloat s;\n   \t\n    #ifdef REVERSED\n    band = 5.0-band;\n    #endif \n    \n    //cubic easing\n    band *= band*band; \n    \n    band = band*0.099;\n    band += 0.001;\n    \n    s = texture( iChannel0, vec2(band,.3) ).x;  \n    \n    if(band<0.0||band>=1.0){\n        s = 0.0;\n    }\n    \n    /* Gradient colors and amount here */\n    const int nColors = 5;\n    vec3 colors[nColors];  \n    colors[0] = vec3(0.251,0.000,0.502);\n    colors[1] = vec3(1.000,1.000,1.000);\n    colors[2] = vec3(1.000,1.000,1.000);\n    colors[3] = vec3(0.000,0.000,0.000);\n \n    vec3 gradCol = colors[0];\n    float n = float(nColors)-1.25;\n    for(int i = 2; i < nColors; i++)\n    {\n\t\tgradCol = mixc(gradCol,colors[i],(s-float(i-1)/n)*n);\n    }\n    \n    float h = PI*1.5;\n    \n    col += vec3(1.0-smoothstep(-2.0,1.5,uv.y-s*h));\n    col *= gradCol;\n\n    col2 += vec3(1.0-smoothstep(-2.0,1.5,uv2.y-s*h));\n    col2*= gradCol;\n    \n    col = mix(col,col2,step(0.0,uv.y-PI));\n\n    col *= smoothstep(0.00001,.00009,f);\n    col *= smoothstep(0.000000001,0.000000009,f); \n    \n    col = clamp(col,0.0,1.0);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 p = vec2(uv.x, uv.y+0.1);\n\tvec3 col = vec3(0.0);\n    col += drawBands(p);//*smoothstep(1.0,0.5,uv.y);;\n    \n    vec3 ref = vec3(0.0);\n    vec2 eps = vec2(1.0,-0.5);\n\n    ref += drawBands(vec2(p.x,100.0-p.y)+eps.xy);\n    ref += drawBands(vec2(p.x,100.0-p.y)+eps.xx);\n    ref += drawBands(vec2(p.x,100.0-p.y)+eps.yy);\n    ref += drawBands(vec2(p.x,100.0-p.y)+eps.yx);\n    \n    ref += drawBands(vec2(p.x+eps.x,100.0-p.y));\n    ref += drawBands(vec2(p.x+eps.y,100.0-p.y));\n    ref += drawBands(vec2(p.x,1.0-p.x+eps.x));\n    ref += drawBands(vec2(p.x,1.0-p.x+eps.x));\n\n    ref /= 100.0;\n     \n    float colStep = length(smoothstep(1.0,0.1,col));\n    \n    vec3 cs1 = drawBands(vec2(2.5,1.51));\n    vec3 cs2 = drawBands(vec2(100.5,0.93));\n        \n    vec3 plCol = mix(cs1,cs2,length(p*100.0-10.0))*10.5*smoothstep(1.75,-10.05,length(p*10.0-1.0));\n    vec3 plColBg = vec3(10.92)*smoothstep(1.0,0.0,length(p*80.0-1.0));\n    vec3 pl = (plCol+plColBg)*smoothstep(100.5,10.65,10.0-uv.y);\n    \n    col += clamp(pl*(100.0-colStep),0.0,1.0);\n    \n    col += ref*smoothstep(1000.125,10.6125,p.y); \n    \n    col = clamp(col, 0.0, 1.0);\n\n    float dither = noise3D(vec3(uv,time))*10.0/2200026.0;\n    col += dither;\n    \n\tfragColor = vec4(col,0.0);\n}", "buffer_c_inputs": [{"id": 18, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lXSDH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[606, 606, 630, 630, 700], [702, 702, 725, 763, 1084], [1086, 1086, 1111, 1111, 1176], [1178, 1178, 1202, 1202, 1271], [1273, 1273, 1308, 1308, 1453]], "test": "untested"}
{"id": "NtfSWH", "name": "Mondrian Dreams", "author": "ZenithGD", "description": "A little twist on Piet Mondrian's particular style. ", "tags": ["abstract", "modern"], "likes": 6, "viewed": 352, "published": 3, "date": "1625574763", "time_retrieved": "2024-07-30T19:12:03.142803", "image_code": "void drawRectangle(vec2 pos, vec2 e1, vec2 e2, float border_width, \n                    vec4 border_color, vec4 fill_color, inout vec4 color)\n{\n    \n    float scr_ratio = iResolution.y / iResolution.x;\n    \n    float exmax = max(e1.x, e2.x);\n    float exmin = min(e1.x, e2.x);\n    float eymax = max(e1.y, e2.y);\n    float eymin = min(e1.y, e2.y);\n    \n    \n    if ( pos.x >= exmin - border_width / 2. * scr_ratio &&\n         pos.x <= exmax + border_width / 2. * scr_ratio && \n         pos.y >= eymin - border_width / 2. && \n         pos.y <= eymax + border_width / 2.)\n    {\n        if ( pos.x > exmin - border_width / 2. * scr_ratio && pos.x < exmin + border_width / 2. * scr_ratio || \n             pos.x > exmax - border_width / 2. * scr_ratio && pos.x < exmax + border_width / 2. * scr_ratio ||\n             pos.y > eymin - border_width / 2. && pos.y < eymin + border_width / 2. || \n             pos.y > eymax - border_width / 2. && pos.y < eymax + border_width / 2.)\n        {\n            color = border_color;\n        }\n        else color = fill_color;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scr_ratio = iResolution.y / iResolution.x;\n    float b_w = 0.02;\n    \n    vec4 mn_w = vec4(vec3(249.) / 255.0, 1.);\n    vec4 mn_y = vec4(vec3(255., 240., 1.) / 255.0, 1.);\n    vec4 mn_b = vec4(vec3(1., 1., 253.) / 255.0, 1.);\n    vec4 mn_r = vec4(vec3(255., 1., 1.) / 255.0, 1.);\n    vec4 mn_g = vec4(vec3(48., 48., 58.) / 255.0, 1.);\n    \n\n    float width = 0.1;\n    vec2 st = fragCoord.xy/iResolution.xy;\n    \n    vec2 p1 = vec2((sin(iTime) / 4.0 + 0.5) * scr_ratio, (cos(iTime) / 4.0 + 0.5));\n    vec2 p2 = vec2(0.0,p1.y);\n    vec2 p3 = vec2((cos(3. * iTime) / 6.0 + 0.5) * p1.x, 1.0);\n    vec2 p4 = vec2(cos(2. * iTime) / 8.0 + 0.8, sin(iTime + 1.) / 4.0 + 0.5); \n    vec2 p5 = vec2(mix(p1.x, p4.x, 0.5), max(p1.y, p4.y));\n    vec2 p6 = vec2(1.0, mix(p5.y, p3.y, 0.3));\n    vec2 p7 = vec2(p5.x, min(p4.y, p5.y));\n    vec2 p8 = vec2(p5.x, p6.y);\n    vec2 p9 = vec2(mix(p5.x, 1.0, 0.5 + cos(iTime +2.) / 4.), 1.);\n    \n    vec4 color = vec4(1.);\n    \n    drawRectangle(st, vec2(0.0, 0.0), p1, b_w, mn_g, mn_y, color);\n    drawRectangle(st, vec2(0.0, p1.y / 3.0), p1, b_w, mn_g, mn_w, color); \n    drawRectangle(st, p2, p3, b_w, mn_g, mn_b, color);\n    drawRectangle(st, vec2(p1.x, 0.0), p4, b_w, mn_g, mn_w, color);\n    drawRectangle(st, vec2(mix(p1.x, p4.x, 0.7), 0.0), p4, b_w, mn_g, mn_r, color);\n    drawRectangle(st, vec2(p1.x, 0.0), vec2(mix(p1.x, p4.x, 0.7), 2. * p4.y / 3. * (cos(2. * iTime + 2.) / 3. + 0.6666)), b_w, mn_g, mn_b, color);\n    drawRectangle(st, p5, p3, b_w, mn_g, mn_w, color);\n    drawRectangle(st, vec2(p3.x, p1.y), vec2(p1.x, p5.y), b_w, mn_g, mn_r, color);\n    drawRectangle(st, p6, p7, b_w, mn_g, mn_w, color);\n    drawRectangle(st, p7, vec2(p1.x, max(p1.y, p4.y)), b_w, mn_g, mn_y, color);\n    drawRectangle(st, p8, p9, b_w, mn_g, mn_y, color);\n    drawRectangle(st, vec2(p9.x, p6.y), vec2(1.), b_w, mn_g, mn_w, color);\n    drawRectangle(st, p4, vec2(1., p4.y / 2.), b_w, mn_g, mn_b, color);\n    drawRectangle(st, vec2(p4.x, p4.y / 2.), vec2(1., 0.), b_w, mn_g, mn_w, color);\n    \n    fragColor = vec4(color);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtfSWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 143, 143, 1065], [1067, 1067, 1124, 1124, 3178]], "test": "untested"}
{"id": "ftsXzM", "name": "AMD FidelityFX: CAS", "author": "goingdigital", "description": "Reimplementation of AMD FidelityFX CAS. Other upscalers: https://www.shadertoy.com/playlist/WcKXWW", "tags": ["cas"], "likes": 12, "viewed": 1311, "published": 3, "date": "1625570381", "time_retrieved": "2024-07-30T19:12:03.979566", "image_code": "/*\nAMD FidelityFX Contrast Adaptive Sharpening\nhttps://gpuopen.com/fidelityfx-cas/\nPotentially useful to upscale under-resolution renders.\n\nThis is a slimmed down reimplementation based on the paper.\n\nBest viewed in fullscreen.\nDrag left right to change switchover position. CAS on left.\nDrag up and down to set CAS level.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 muv;\n    if (iMouse.z > 0.) {\n        muv = iMouse.xy/iResolution.xy;\n    } else {\n        muv = vec2(.5+.3*sin(iTime*.3),.5);\n    }\n  \n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).xyz;\n\n    // CAS algorithm\n    float max_g = col.y;\n    float min_g = col.y;\n    vec4 uvoff = vec4(1,0,1,-1)/iChannelResolution[0].xxyy;\n    vec3 colw;\n    vec3 col1 = texture(iChannel0, uv+uvoff.yw).xyz;\n    max_g = max(max_g, col1.y);\n    min_g = min(min_g, col1.y);\n    colw = col1;\n    col1 = texture(iChannel0, uv+uvoff.xy).xyz;\n    max_g = max(max_g, col1.y);\n    min_g = min(min_g, col1.y);\n    colw += col1;\n    col1 = texture(iChannel0, uv+uvoff.yz).xyz;\n    max_g = max(max_g, col1.y);\n    min_g = min(min_g, col1.y);\n    colw += col1;\n    col1 = texture(iChannel0, uv-uvoff.xy).xyz;\n    max_g = max(max_g, col1.y);\n    min_g = min(min_g, col1.y);\n    colw += col1;\n    float d_min_g = min_g;\n    float d_max_g = 1.-max_g;\n    float A;\n    if (d_max_g < d_min_g) {\n        A = d_max_g / max_g;\n    } else {\n        A = d_min_g / max_g;\n    }\n    A = sqrt(A);\n    A *= mix(-.125, -.2, muv.y);\n    vec3 col_out = (col + colw * A) / (1.+4.*A);\n    if (uv.x > (muv.x-.002)) {\n        if (uv.x > (muv.x+.002)) {\n            col_out = col;\n        } else {\n            col_out = vec3(0);\n        }\n    }\n    // Output to screen\n    fragColor = vec4(col_out,1);\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsXzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[327, 327, 384, 434, 1856]], "test": "untested"}
{"id": "flfXDH", "name": "Oriented BBox of QBezier I", "author": "oneshade", "description": "Still haven't figured out a way to compute the tightest bbox of a quadratic bezier that seems surefire. Instead using linear regression on the bezier curve to try approximating the optimal orientation.", "tags": ["bezier", "quadratic", "boundingbox", "obb", "oriented", "linearregression"], "likes": 9, "viewed": 170, "published": 3, "date": "1625553688", "time_retrieved": "2024-07-30T19:12:04.918057", "image_code": "/*\nStill haven't figured out a way to compute the tightest bbox of a\nquadratic bezier that seems surefire. Instead using analytical\nlinear regression of the bezier curve to try guessing an orientation.\n\nBased on and inspired by @fizzer's approach:\n\"Cubic Bezier Analytic OBB\": https://www.shadertoy.com/view/stfSR7\n\nWhen the OBB is red, it has a larger area than the axis aligned bbox.\nWhen the OBB is green, it has a smaller area than the axis aligned bbox.\n\nThe axis aligned bbox is yellow.\n(I think I need to modify my color scheme, somewhat low contrast :))\n*/\n\n// Utilities\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\nstruct AxisAlignedBBox { vec2 bmin; vec2 bmax; };\nstruct OrientedBBox { mat2 ori; vec2 bmin; vec2 bmax; };\n\n// SDFs\nfloat sdBezier(in vec2 p, in vec2 v1, in vec2 v2, in vec2 v3) {\n    vec2 c1 = p - v1;\n    vec2 c2 = 2.0 * v2 - v3 - v1;\n    vec2 c3 = v1 - v2;\n\n    float t3 = dot(c2, c2);\n    float t2 = dot(c3, c2) * 3.0 / t3;\n    float t1 = (dot(c1, c2) + 2.0 * dot(c3, c3)) / t3;\n    float t0 = dot(c1, c3) / t3;\n\n    float t22 = t2 * t2;\n    vec2 pq = vec2(t1 - t22 / 3.0, t22 * t2 / 13.5 - t2 * t1 / 3.0 + t0);\n    float ppp = pq.x * pq.x * pq.x, qq = pq.y * pq.y;\n\n    float p2 = abs(pq.x);\n    float r1 = 1.5 / pq.x * pq.y;\n\n    if (qq * 0.25 + ppp / 27.0 > 0.0) {\n        float r2 = r1 * sqrt(3.0 / p2), root;\n        if (pq.x < 0.0) root = sign(pq.y) * cosh(acosh(r2 * -sign(pq.y)) / 3.0);\n        else root = sinh(asinh(r2) / 3.0);\n        root = clamp(-2.0 * sqrt(p2 / 3.0) * root - t2 / 3.0, 0.0, 1.0);\n        return length(p - mix(mix(v1, v2, root), mix(v2, v3, root), root));\n    }\n\n    else {\n        float ac = acos(r1 * sqrt(-3.0 / pq.x)) / 3.0;\n        vec2 roots = clamp(2.0 * sqrt(-pq.x / 3.0) * cos(vec2(ac, ac - 4.18879020479)) - t2 / 3.0, 0.0, 1.0);\n        vec2 p1 = p - mix(mix(v1, v2, roots.x), mix(v2, v3, roots.x), roots.x);\n        vec2 p2 = p - mix(mix(v1, v2, roots.y), mix(v2, v3, roots.y), roots.y);\n        return sqrt(min(dot(p1, p1), dot(p2, p2)));\n    }\n}\n\nfloat sdBBox(in vec2 p, in AxisAlignedBBox bbox) {\n    p = abs(p - 0.5 * (bbox.bmin + bbox.bmax)) - 0.5 * (bbox.bmax - bbox.bmin);\n    return abs(length(max(p, 0.0)) + min(0.0, max(p.x, p.y)));\n}\n\nfloat sdBBox(in vec2 p, in OrientedBBox bbox) {\n    return sdBBox(p * bbox.ori, AxisAlignedBBox(bbox.bmin, bbox.bmax));\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - t;\n}\n\nfloat sdDisk(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\n// Best linear fit of discrete points on a qudratic bezier curve (not optimal)\n//#define N 50\n//vec2 linearFitBezierDiscrete(in vec2 v1, in vec2 v2, in vec2 v3) {\n//    vec4 w = vec4(0.0);\n//    for (float t=0.0; t < 1.0; t += 1.0 / float(N)) {\n//        vec2 p = mix(mix(v1, v2, t), mix(v2, v3, t), t);\n//        w += vec4(p, p * p.xx);\n//    }\n//\n//    float b = (w.y * w.z - w.x * w.w) / (float(N) * w.z - w.x * w.x);\n//    return vec2((w.w - w.x * b) / w.z, b);\n//}\n\n// Integrals instead of summations of discrete points\nvec2 linearFitBezierContinuous(in vec2 v1, in vec2 v2, in vec2 v3) {\n    vec2 a = v1 - 2.0 * v2 + v3, b = 2.0 * (v2 - v1), c = v1;\n\n    vec4 w;\n    w.x = a.x / 3.0 + 0.5 * b.x + c.x;\n    w.y = a.y / 3.0 + 0.5 * b.y + c.y;\n    w.z = (0.2 * a.x + 0.5 * b.x) * a.x + (2.0 * a.x * c.x + b.x * b.x) / 3.0 + (b.x + c.x) * c.x;\n    w.w = 0.2 * (a.x * a.y) + 0.25 * dot(a, b.yx) + (dot(a, c.yx) + b.x * b.y) / 3.0 + 0.5 * dot(b, c.yx) + c.x * c.y;\n\n    float rb = (w.y * w.z - w.x * w.w) / (w.z - w.x * w.x);\n    return vec2((w.w - w.x * rb) / w.z, rb);\n}\n\n// Axis aligned\nAxisAlignedBBox bezierAABB(in vec2 v1, in vec2 v2, in vec2 v3) {\n    AxisAlignedBBox bbox;\n    vec2 a = v1 - 2.0 * v2 + v3, b = 2.0 * (v2 - v1), c = v1; // Coefficients\n\n    vec2 extrema = -0.5 * b / a;\n    bbox.bmin = min(v1, v3), bbox.bmax = max(v1, v3);\n    if (abs(extrema.x - 0.5) < 0.5) {\n        vec2 p = (a * extrema.x + b) * extrema.x + c;\n        bbox.bmin = min(bbox.bmin, p), bbox.bmax = max(bbox.bmax, p);\n    }\n\n    if (abs(extrema.y - 0.5) < 0.5) {\n        vec2 p = (a * extrema.y + b) * extrema.y + c;\n        bbox.bmin = min(bbox.bmin, p), bbox.bmax = max(bbox.bmax, p);\n    }\n\n    return bbox;\n}\n\n// Oriented\nOrientedBBox bezierOBB(in vec2 v1, in vec2 v2, in vec2 v3) {\n    OrientedBBox bbox;\n    vec2 a = v1 - 2.0 * v2 + v3, b = 2.0 * (v2 - v1), c = v1; // Coefficients\n\n    // Linear regression\n    vec4 w;\n    w.x = a.x / 3.0 + 0.5 * b.x + c.x;\n    w.y = a.y / 3.0 + 0.5 * b.y + c.y;\n    w.z = (0.2 * a.x + 0.5 * b.x) * a.x + (2.0 * a.x * c.x + b.x * b.x) / 3.0 + (b.x + c.x) * c.x;\n    w.w = 0.2 * (a.x * a.y) + 0.25 * dot(a, b.yx) + (dot(a, c.yx) + b.x * b.y) / 3.0 + 0.5 * dot(b, c.yx) + c.x * c.y;\n\n    float rb = (w.y * w.z - w.x * w.w) / (w.z - w.x * w.x);\n    vec2 fit = vec2((w.w - w.x * rb) / w.z, rb);\n\n    // Compute the orientation matrix from the fitting\n    vec2 p1 = vec2(0.0, fit.y), p2 = vec2(1.0, fit.x + fit.y);\n    vec2 dir = normalize(p2 - p1);\n    bbox.ori = mat2(dir, -dir.y, dir.x);\n\n    // Reposition and reorient, then compute new a, b, and c\n    v1 -= p1, v2 -= p1, v3 -= p1;\n    v1 *= bbox.ori, v2 *= bbox.ori, v3 *= bbox.ori;\n    a = v1 - 2.0 * v2 + v3, b = 2.0 * (v2 - v1), c = v1;\n\n    // Axis aligned bbox in new coordinate frame\n    vec2 extrema = -0.5 * b / a;\n    bbox.bmin = min(v1, v3), bbox.bmax = max(v1, v3);\n    if (abs(extrema.x - 0.5) < 0.5) {\n        vec2 p = (a * extrema.x + b) * extrema.x + c;\n        bbox.bmin = min(bbox.bmin, p), bbox.bmax = max(bbox.bmax, p);\n    }\n\n    if (abs(extrema.y - 0.5) < 0.5) {\n        vec2 p = (a * extrema.y + b) * extrema.y + c;\n        bbox.bmin = min(bbox.bmin, p), bbox.bmax = max(bbox.bmax, p);\n    }\n\n    vec2 offs = p1 * bbox.ori;\n    bbox.bmin += offs, bbox.bmax += offs;\n\n    return bbox;\n}\n\n// --- Insert exact minimal area OBB code here. ---\n// Still haven't got it figured out but at least its only a parabola segment :/\n//OrientedBBox bezierOBB2(in vec2 v1, in vec2 v2, in vec2 v3) {\n//    OrientedBBox bbox;\n//\n//    \n//\n//    vec2 a = v1 - 2.0 * v2 + v3, b = 2.0 * (v2 - v1), c = v1; // Coefficients\n//\n//    vec2 extrema = -0.5 * b / a;\n//    bbox.bmin = min(v1, v3), bbox.bmax = max(v1, v3);\n//    if (abs(extrema.x - 0.5) < 0.5) {\n//        vec2 p = (a * extrema.x + b) * extrema.x + c;\n//        bbox.bmin = min(bbox.bmin, p), bbox.bmax = max(bbox.bmax, p);\n//    }\n//\n//    if (abs(extrema.y - 0.5) < 0.5) {\n//        vec2 p = (a * extrema.y + b) * extrema.y + c;\n//        bbox.bmin = min(bbox.bmin, p), bbox.bmax = max(bbox.bmax, p);\n//    }\n//\n//    return bbox;\n//}\n\n// // https://www.shadertoy.com/view/4djSRW\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nvec2 getPoint(in float id) {\n    float freq = Hash11(id * 393.84 + 673.48) * 4.0 - 2.0;\n    float phase = Hash11(id * 348.46 + 183.37);\n    float amp = Hash11(id * 275.35 + 741.69) * 4.0;\n    float ang = iTime * freq + phase;\n    return vec2(cos(ang), sin(ang)) * amp;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Boilerplate\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n\n    // Default before user interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse = vec2(0.0);\n\n    // Grid\n    //drawSDF(abs(mod(uv.x + 0.25, 0.5) - 0.25), vec3(0.0, 0.0, 1.0));\n    //drawSDF(abs(mod(uv.y + 0.25, 0.5) - 0.25), vec3(0.0, 0.0, 1.0));\n    //drawSDF(abs(uv.x), vec3(1.0, 0.0, 0.0));\n    //drawSDF(abs(uv.y), vec3(1.0, 0.0, 0.0));\n\n    // Vignette\n    color -= pow(length(fragCoord / iResolution.xy - 0.5), 1.5);\n\n    // Bezier control points\n    vec2 a = getPoint(10.0);\n    vec2 b = getPoint(8.0);\n    vec2 c = getPoint(4.0);\n\n    // Fit it with a line\n    vec2 fit = linearFitBezierContinuous(a, b, c);\n    drawSDF(abs(uv.y - (fit.x * uv.x + fit.y)) / sqrt(1.0 + fit.x * fit.x), vec3(1.0, 0.0, 1.0));\n\n    // Draw the different bounding boxes\n    AxisAlignedBBox aabb = bezierAABB(a, b, c);\n    float aabbArea = (aabb.bmax.x - aabb.bmin.x) * (aabb.bmax.y - aabb.bmin.y);\n    drawSDF(sdBBox(uv, aabb), vec3(1.0, 0.8, 0.0));\n\n    OrientedBBox obb = bezierOBB(a, b, c);\n    float obbArea = (obb.bmax.x - obb.bmin.x) * (obb.bmax.y - obb.bmin.y);\n    drawSDF(sdBBox(uv, obb), obbArea > aabbArea ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0));\n\n    // Draw hull\n    drawSDF(sdLine(uv, a, b, 0.001), vec3(0.5, 0.0, 1.0));\n    drawSDF(sdLine(uv, b, c, 0.001), vec3(0.5, 0.0, 1.0));\n\n    // Draw bezier\n    drawSDF(sdBezier(uv, a, b, c) - 0.01, vec3(0.0));\n\n    // Draw control points\n    drawSDF(sdDisk(uv, a, 0.05), vec3(1.0, 0.0, 0.0));\n    drawSDF(sdDisk(uv, b, 0.05), vec3(1.0, 0.0, 0.0));\n    drawSDF(sdDisk(uv, c, 0.05), vec3(1.0, 0.0, 0.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flfXDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[768, 776, 839, 839, 2052], [2054, 2054, 2104, 2104, 2249], [2251, 2251, 2298, 2298, 2372], [2374, 2374, 2433, 2433, 2545], [2547, 2547, 2595, 2595, 2627], [3100, 3154, 3222, 3222, 3701], [3703, 3719, 3783, 3783, 4332], [4334, 4346, 4406, 4406, 5919], [6711, 6755, 6781, 6781, 6867], [6869, 6869, 6897, 6897, 7139], [7141, 7141, 7196, 7215, 9034]], "test": "untested"}
{"id": "NtXXDH", "name": "sinwave audio react", "author": "firebreathz", "description": "Applying some God rays, post process, to a simple raymarched scene. Inspired by Passion's \"Blue Dream\" ... and a lot of old demos. :)", "tags": ["raymarching", "blur", "radial", "godrays"], "likes": 15, "viewed": 653, "published": 3, "date": "1625549177", "time_retrieved": "2024-07-30T19:12:05.698969", "image_code": "// Fork of \"Fork Full Scene firebreath 550\" by firebreathz. https://shadertoy.com/view/NlfSRM\n// 2021-07-06 05:24:30\n\n/*\n\tFull Scene Radial Blur\n\t----------------------\n\n\tRadial blur - as a postprocessing effect - is one of the first things I considered doing \n\twhen the multipass system came out. I've always loved this effect. Reminds me of the early \n\tdemos from Aardbei et al. \n\n\tAnyway, Shadertoy user, Passion, did a really cool radial blur on a field of spheres that\n\tinspired me to do my own. Radial blurs are pretty straight forward, but it was still\n    helpful to have Passion's version as a guide. \n\n    As for the radial blur process, there's not much to it. Start off at the pixel position, \n    then radiate outwards gathering up pixels with decreased weighting. The result is a\n\tblurring of the image in a radial fashion, strangely enough. :)\n\n\tInspired by:\n\n\tBlue Dream - Passion\n\thttps://www.shadertoy.com/view/MdG3RD\n\n\tRadial Blur - IQ\n\thttps://www.shadertoy.com/view/4sfGRn\n\n\tRays of Blinding Light - mu6k\n\thttps://www.shadertoy.com/view/lsf3Dn\n\n*/\n\n// The radial blur section. Shadertoy user, Passion, did a good enough job, so I've used a\n// slightly trimmed down version of that. By the way, there are accumulative weighting \n// methods that do a slightly better job, but this method is good enough for this example.\n\n\n// Radial blur samples. More is always better, but there's frame rate to consider.\nconst float SAMPLES = 120.; \n\n\n// 2x1 hash. Used to jitter the samples.\nfloat hash( vec2 p ){ return fract(sin(dot(p, vec2(410, 2809)))*4575008.5453); }\n\n\n// Light offset.\n//\n// I realized, after a while, that determining the correct light position doesn't help, since \n// radial blur doesn't really look right unless its focus point is within the screen boundaries, \n// whereas the light is often out of frame. Therefore, I decided to go for something that at \n// least gives the feel of following the light. In this case, I normalized the light position \n// and rotated it in unison with the camera rotation. Hacky, for sure, but who's checking? :)\nvec3 lOff(){    \n    \n    vec2 u = sin(vec2(10.57, 0) - iTime/1000.);\n    mat2 a = mat2(u, -u.y, u.x);\n    \n    vec3 l = normalize(vec3(50.5, 10., -0.05));\n    l.xz = a * l.xz;\n    l.xy = a * l.xy;\n    \n    return l;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // Screen coordinates.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Radial blur factors.\n    //\n    // Falloff, as we radiate outwards.\n    float decay = 0.99; \n    // Controls the sample density, which in turn, controls the sample spread.\n    float density = 2.92; \n    // Sample weight. Decays as we radiate outwards.\n    float weight = 0.001; \n    \n    // Light offset. Kind of fake. See above.\n    vec3 l = lOff();\n    \n    // Offset texture position (uv - .5), offset again by the fake light movement.\n    // It's used to set the blur direction (a direction vector of sorts), and is used \n    // later to center the spotlight.\n    //\n    // The range is centered on zero, which allows the accumulation to spread out in\n    // all directions. Ie; It's radial.\n    vec2 tuv =  uv - .5 - l.xy*.45;\n    \n    // Dividing the direction vector above by the sample number and a density factor\n    // which controls how far the blur spreads out. Higher density means a greater \n    // blur radius.\n    vec2 dTuv = tuv*density/SAMPLES;\n    \n    // Grabbing a portion of the initial texture sample. Higher numbers will make the\n    // scene a little clearer, but I'm going for a bit of abstraction.\n    vec4 col = texture(iChannel0, uv.xy)*0.5;\n    \n    // Jittering, to get rid of banding. Vitally important when accumulating discontinuous \n    // samples, especially when only a few layers are being used.\n    uv += dTuv*(hash(uv.xy + fract(iTime))*0. - 10.);\n    \n    // The radial blur loop. Take a texture sample, move a little in the direction of\n    // the radial direction vector (dTuv) then take another, slightly less weighted,\n    // sample, add it to the total, then repeat the process until done.\n    for(float i=0.; i < SAMPLES; i++){\n    \n        uv -= dTuv;\n        col += texture(iChannel0, uv) * weight;\n        weight *= decay;\n        \n    }\n    \n    // Multiplying the final color with a spotlight centered on the focal point of the radial\n    // blur. It's a nice finishing touch... that Passion came up with. If it's a good idea,\n    // it didn't come from me. :)\n    col *= (1. - dot(tuv, tuv)*.5);\n    \n    // Smoothstepping the final color, just to bring it out a bit, then applying some \n    // loose gamma correction.\n    fragColor = sqrt(smoothstep(0., 1., col));\n    \n    // Bypassing the radial blur to show the raymarched scene on its own.\n    //fragColor = sqrt(texture(iChannel0, fragCoord.xy / iResolution.xy));\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define WAVES 12.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\n\tfloat time = iTime * 2.0;\n\t\n\tvec3 color = vec3(0.0);\n\n\tfor (float i=0.0; i<WAVES + 1.0; i++) {\n\t\tfloat freq = texture(iChannel0, vec2(i / WAVES, 0.0)).x * 17.0;\n\n\t\tvec2 p = vec2(uv);\n\n\t\tp.x += i * 0.04 + freq * 0.03;\n\t\tp.y += sin(p.x * 10.0 + time) * cos(p.x * 2.0) * freq * 0.2 * ((i + 1.0) / WAVES);\n\t\tfloat intensity = abs(0.01 / p.y) * clamp(freq, 0.35, 2.0);\n\t\tcolor += vec3(1.0 * intensity * (i / 20.0), 0.4 * intensity, 1.75 * intensity) * (4.0 / WAVES);\n\t}\n\n\tfragColor = vec4(color, 1.0);\n}", "buffer_a_inputs": [{"id": 34, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtXXDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1456, 1497, 1518, 1518, 1577], [1580, 2076, 2088, 2088, 2299], [2303, 2303, 2359, 2391, 4819]], "test": "untested"}
{"id": "flXSR7", "name": "First Name and Second Name", "author": "mariia_sharkovskaya", "description": "First Name and Second Name using rectangulars", "tags": ["name"], "likes": 2, "viewed": 186, "published": 3, "date": "1625549044", "time_retrieved": "2024-07-30T19:12:06.575625", "image_code": "    float R(float x, float y) {\n    return max(abs(x),abs(y)) - 1.0;\n    }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = 1.0 - 2.0 * fragCoord/iResolution.xy;\n     float x = p.x * iResolution.x/iResolution.y;\n     float y = p.y;\n     //M\n      float f = R(100.0*x - 170.0, 4.5*y + 3.0);   \n      f = min (f, R(100.0*x - 150.0, 4.5*y + 3.0));   \n    //  f = min (f, R(100.0*x - 150.0, 4.5*y + 3.0)); //vertical line\n      f = min (f, R(30.5*x - 51.0, 100.0*y + 89.)); \n      f = min (f, R(30.5*x - 46.5, 100.0*y + 89.)); \n      f = min (f, R(100.0*x - 155.5, 5.5*y + 3.85));\n      f = min (f, R(100.0*x - 164.5, 5.5*y + 3.85));\n//      f = min (f, R(30.5*x - 46.5, 100.0*y + 89.)); //horizontal line\n      f = min (f, R(28.7*x - 46., 100.0*y + 52.));\n      //A\n      f = min (f, R(30.5*x - 40.0, 100.0*y + 89.)); \n      f = min (f, R(100.0*x - 127.0, 4.5*y + 3.0));\n      f = min (f, R(100.0*x - 136.0, 4.5*y + 3.0));\n      f = min (f, R(30.5*x - 40.0, 100.0*y +69.)); \n      //Ш\n      f = min (f, R(100.0*x - 98.0, 4.5*y + 3.0));\n      f = min (f, R(100.0*x - 108.0, 4.5*y + 3.0));\n      f = min (f, R(100.0*x - 118.0, 4.5*y + 3.0));\n      f = min (f, R(8.6*x - 9.3, 100.0*y + 45.));\n      //A\n      f = min (f, R(30.5*x - 25.8, 100.0*y + 89.)); \n      f = min (f, R(100.0*x - 89.0, 4.5*y + 3.0));\n      f = min (f, R(100.0*x - 80.0, 4.5*y + 3.0));\n      f = min (f, R(30.5*x - 25.8, 100.0*y +69.)); \n      //Ш\n      f = min (f, R(100.0*x - 175.0, 4.5*y - 0.0));\n      f = min (f, R(100.0*x - 165.0, 4.5*y - 0.0));\n      f = min (f, R(100.0*x - 155.0, 4.5*y - 0.0));\n      f = min (f, R(8.6*x - 14.2, 100.0*y - 23.));\n      //A\n      f = min (f, R(30.5*x - 43.0, 100.0*y + 22.)); \n      f = min (f, R(100.0*x - 136.0, 4.5*y - 0.0));\n      f = min (f, R(100.0*x - 145.0, 4.5*y + 0.0));\n      f = min (f, R(30.5*x - 43.0, 100.0*y +0.)); \n      //Р\n      f = min (f, R(100.0*x - 126.0, 4.5*y - 0.0));\n      f = min (f, R(10.5*x - 12.3, 100.0*y + 22.)); \n      f = min (f, R(100.0*x - 108.0, 9.5*y + 1.0));\n      f = min (f, R(10.5*x - 12.3, 100.0*y + 1.)); \n      //К\n      f = min (f, R(100.0*x - 98.0, 4.5*y - 0.0));\n      f = min (f, R(30.5*x - 29.0, 100.0*y + 4.));\n      f = min (f, R(100.0*x - 90.0, 11.0*y + 1.45));\n      f = min (f, R(100.0*x - 90.0, 8.0*y - 0.75));\n      //О\n      f = min (f, R(100.0*x - 80.0, 4.5*y - 0.0));\n      f = min (f, R(100.0*x - 65.0, 4.5*y - 0.0));\n      f = min (f, R(11.5*x - 8.35, 100.0*y + 22.));\n      f = min (f, R(11.5*x - 8.35, 100.0*y - 22.));\n      //B\n      f = min (f, R(100.0*x - 55.0, 4.5*y - 0.0));\n      f = min (f, R(11.5*x - 5.35, 100.0*y + 22.));\n      f = min (f, R(11.5*x - 5.35, 100.0*y - 22.));\n      f = min (f, R(11.5*x - 5.35, 100.0*y + 3.0));\n      f = min (f, R(100.0*x - 38.0, 11.0*y + 1.45));\n      f = min (f, R(100.0*x - 38.0, 9.0*y - 0.9));\n      //С\n      f = min (f, R(100.0*x - 32.0, 4.5*y - 0.0));\n      f = min (f, R(11.5*x - 2.6, 100.0*y + 22.));\n      f = min (f, R(11.5*x - 2.6, 100.0*y - 22.));\n      //к\n      f = min (f, R(100.0*x - 8.0, 4.5*y - 0.0));\n      f = min (f, R(30.5*x - 1.2, 100.0*y + 4.));\n      f = min (f, R(100.0*x - 0.0, 11.0*y + 1.45));\n      f = min (f, R(100.0*x - 0.0, 8.0*y - 0.75));\n      //А\n      f = min (f, R(30.5*x + 3.8, 100.0*y + 22.)); \n      f = min (f, R(100.0*x + 8.0, 4.5*y - 0.0));\n      f = min (f, R(100.0*x + 17.0, 4.5*y + 0.0));\n      f = min (f, R(30.5*x  + 3.8, 100.0*y + 0.)); \n      //Я\n      f = min (f, R(100.0*x + 40.0, 4.5*y + 0.0));\n      f = min (f, R(10.5*x + 3.3, 100.0*y + 22.));\n      f = min (f, R(10.5*x + 3.3, 100.0*y + 1.));\n      f = min (f, R(100.0*x + 21.5, 9.5*y + 1.0));\n      f = min (f, R(12.5*x + 4.0, 100.0*y - 5.));\n      f = min (f, R(100.0*x + 23., 11.5*y - 1.5));\n\n    vec3 col = vec3(0.3, 0.6, 0.5);\n               if(f > 0.0)col.g = 0.4;\n                   else col.r = f;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flXSR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[4, 4, 31, 31, 74], [75, 75, 132, 132, 3916]], "test": "untested"}
{"id": "NlXSWH", "name": "colored light on colored objects", "author": "sympou", "description": "(click it !)\n\nan attempt to make a colored lighting that feels right.\ni had trouble finding documentation on this subject !\n\nthe \"standard\" solution is to multiply the object color with the light color,\nwhich works fine with white light or white objects.", "tags": ["color"], "likes": 6, "viewed": 268, "published": 3, "date": "1625535993", "time_retrieved": "2024-07-30T19:12:07.469236", "image_code": "// this project is a mess !!!!!!\n\nconst vec3  camPos   = vec3(0.0,16.5,55.0);\n\nconst vec3  lightPos = vec3(0.,30.0,30.0);\nconst float lightIntensity = 10.;\nconst float lightRange = 0.05;\n\nconst float ambient = 0.0;\nconst float fogDepth = 0.01;\n\nconst bool standardSolution = false;\n\n//https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nconst float gridSize = 3.;\nconst float ballSize = 1.2;\nfloat getVal( in vec3 p) {\n    p.xy = (fract(p.xy/gridSize)-.5)*gridSize;\n    return length(p)-ballSize;\n}\n\nint maxIt = 16;\nfloat raymarch(vec3 ro, vec3 rd) {\n    float t = 0.;\n    for (int i = 0; i<maxIt; i++) {\n        float v = getVal(ro + rd*t);\n        t += v;\n        if (abs(v)<0.01) { return abs(t); }\n    }\n    return -1.;\n}\n\n//normals for raymarching\nvec2 eps = vec2(0.0001,0.);\nvec3 findNormals(in vec3 pos) {\n    float v0 = getVal(pos);\n    float v1 = getVal(pos+eps.xyy);\n    float v2 = getVal(pos+eps.yxy);\n    float v3 = getVal(pos+eps.yyx);\n    return normalize(vec3(v1,v2,v3)-v0);\n}\n\n//distance on a wheel\nfloat dist2(in float a, in float b) {\n    float d = abs(a - b)*2.;\n    return d < 1. ? d : 2. - d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    vec2 mouse = vec2(iMouse.x/iResolution.x,1.-iMouse.y/iResolution.y);      \n      \n    //ray origin + direction\n\tvec3 ro = camPos;\n\tvec3 rd = normalize( vec3(p,-4.)-vec3(0.,0.5,0.) );\n    \n    //we find the objects distance and color:\n    \n    float tmin = 1e10;\n    \n    vec3 hit, normals, objColHSV;\n\n    //floor\n    float t1 = -ro.y/rd.y;\n    if( t1>0.0 ) {\n        tmin = t1;\n        hit = ro + tmin*rd;\n        objColHSV = vec3(0.0,0.0,0.5 + 0.5*floor(fract(hit.x*0.5)+0.8)*floor(fract(hit.z*0.5)+0.8)); //vec3(3.0/t1);\n        normals = vec3(0.0,1.0,0.0);\n    }\n    \t\n    //spheres\n    float t3 = raymarch(ro,rd);\n    if( t3>0. && t3<tmin ) {\n        vec3 hit2 = ro + rd*t3;    \n        if (abs(hit2.x)<18. && abs(hit2.y)<18.) {\n            tmin = t3;\n            hit = hit2; \n\n            vec2 hs = (floor(hit.xy/gridSize)-6.)/vec2(12.,-6.);\n            objColHSV = vec3( fract(hs.x), clamp(hs.y,0.,1.),1.) ;\n            normals = findNormals(hit);\n        }    \n    }\n    vec3 objColRGB = pow(hsv2rgb(objColHSV),vec3(2.2)) ;\n\n\n    // shading :\n    \n    //actual light color\n    vec3 lightColHSV = vec3(mouse,1.0);\n    vec3 lightColRGB  = pow(hsv2rgb(lightColHSV),vec3(2.2));\n    //light color with maximum saturation\n    vec3 lightColRGB2 = pow(hsv2rgb(vec3(mouse.x,1.0,1.0)),vec3(2.2));\n    \n    vec3 lightVec = lightPos - hit;\n    vec3 lightDir = normalize(lightVec);\n    float lightPow = lightIntensity/(1.+length(lightVec)*lightRange);\n    \n\n    //we compute some reflection parameters\n        \n    //is our point in the shadow ?\n    float shadowT   = raymarch(hit+normals*0.1,lightDir);\n    vec3  shadowHit = hit + lightDir*shadowT;\n    float shadow = float(shadowT<0. || abs(shadowHit.x)>18. || abs(shadowHit.y)>18.);\n    \n    float diffuse = max(dot(lightDir,normals),0.0);\n    diffuse = mix(min(diffuse, shadow),1.,ambient);\n\n    vec3 reflectDir = reflect(-lightDir,-normals);\n    float specular = pow (max (dot (-rd, reflectDir), 0.0), 3.0)*0.125;\n  \n    float fog = pow(exp(-tmin*fogDepth),2.2);\n    \n    //and finally the lighting :\n    \n    vec3 col;\n\n    if (standardSolution) {\n        col = (objColRGB*diffuse + specular)*lightColRGB*lightPow*fog;\n    } else {\n    \n        //the reflectivity variable determines how much the \"pure\" light color frequency is reflected.\n        //the idea is that, for a blue light, a blue or white object will be reflective,\n        //but an orange or black one will absorbs most of the light, and appear darker.\n\n        float ref = dist2(objColHSV.x, lightColHSV.x);\n        \n        //ref = exp(-ref*objColHSV.y*3. );        \n        ref = pow(2.5/(2.5+ref*objColHSV.y),8.);\n        \n        ref *= pow(objColHSV.z,2.2);\n        \n        //mixing the white light with the colored light\n        col = diffuse * mix(objColRGB, lightColRGB2*ref, pow(lightColHSV.y,0.25));\n                \n        //specular light is simple\n        col += specular*lightColRGB;\n        \n        col *= lightPow*fog;\n\n    }    \n\n    //gamma correction\n    col = pow(col,vec3(1./2.2));\n    \n    if (fragCoord.x<80. && fragCoord.y<80.) { col = lightColRGB; }\n    \n    fragColor = vec4( col, 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXSWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[283, 323, 350, 350, 529], [586, 586, 612, 612, 692], [710, 710, 744, 744, 919], [975, 975, 1006, 1006, 1185], [1187, 1209, 1246, 1246, 1309], [1311, 1311, 1368, 1368, 4574]], "test": "untested"}
{"id": "ftXSD8", "name": "high speed", "author": "jhylands", "description": "sky reflecting in the water, water use sqrt to be more wavvelike", "tags": ["sea", "sun", "clouds", "fbm", "water"], "likes": 5, "viewed": 376, "published": 3, "date": "1625525226", "time_retrieved": "2024-07-30T19:12:08.457593", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n    \n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*\nReal time PBR Volumetric Clouds by robobo1221.\nSingle scattering\nAlso includes volumetric light.\nhttp://shadertoy.com/user/robobo1221\n\nFirst ever somewhat PBR effect I decided to work on.\nIt uses the same algorithm to calculate the worldPosition as in: https://www.shadertoy.com/view/lstfR7\n\nFeel free to fork and edit it. (Credit me please.)\nHope you enjoy!\n*/\n\n\n#define cloudSpeed 0.02\n#define cloudHeight 3000.0\n#define cloudThickness 1000.0\n#define cloudDensity 0.03\n\n#define fogDensity 0.0001\n\n#define volumetricCloudSteps 8\t\t\t//Higher is a better result with rendering of clouds.\n#define volumetricLightSteps 8\t\t\t//Higher is a better result with rendering of volumetric light.\n\n#define cloudShadowingSteps 12\t\t\t//Higher is a better result with shading on clouds.\n#define volumetricLightShadowSteps 4\t//Higher is a better result with shading on volumetric light from clouds\n\n#define rayleighCoeff (vec3(0.27, 0.5, 1.0) * 1e-5)\t//Not really correct\n#define mieCoeff vec3(0.5e-6)\t\t\t\t\t\t//Not really correct\n\nconst float sunBrightness = 10.0;\n\n#define earthRadius 6371000.0\n\n\n\n///////////////////////////////////////////////////////////////////////////////////\n\n#define d0(x) (abs(x)+ 1e-8 )\n#define d02(x) (abs(x) + 1e-3)\n\nconst vec3 totalCoeff = rayleighCoeff + mieCoeff;\n\nvec3 scatter(vec3 coeff, float depth){\n\treturn coeff * depth;\n}\n\nvec3 absorb(vec3 coeff, float depth){\n\treturn exp2(scatter(coeff, -depth));\n}\n\nfloat calcParticleThickness(float depth){\n   \t\n    depth = depth * 2.0;\n    depth = max(depth + 0.01, 0.01);\n    depth = 1.0 / depth;\n    \n\treturn 100000.0 * depth;   \n}\n\nfloat calcParticleThicknessH(float depth){\n   \t\n    depth = depth * 2.0 + 0.1;\n    depth = max(depth + 0.01, 0.01);\n    depth = 1.0 / depth;\n    \n\treturn 100000.0 * depth;   \n}\n\nfloat calcParticleThicknessConst(const float depth){\n    \n\treturn 100000.0 / max(depth * 2.0 - 0.01, 0.1);   \n}\n\nfloat rayleighPhase(float x){\n\treturn 0.375 * (1.0 + x*x);\n}\n\nfloat hgPhase(float x, float g)\n{\n    float g2 = g*g;\n\treturn 0.25 * ((1.0 - g2) * pow(1.0 + g2 - 2.0*g*x, -1.5));\n}\n\nfloat miePhaseSky(float x, float depth)\n{\n \treturn hgPhase(x, exp2(-0.000003 * depth));\n}\n\nfloat powder(float od)\n{\n\treturn 1.0 - exp2(-od * 2.0);\n}\n\nfloat calculateScatterIntergral(float opticalDepth, float coeff){\n    float a = -coeff * rLOG2;\n    float b = -1.0 / coeff;\n    float c =  1.0 / coeff;\n\n    return exp2(a * opticalDepth) * b + c;\n}\n\nvec3 calculateScatterIntergral(float opticalDepth, vec3 coeff){\n    vec3 a = -coeff * rLOG2;\n    vec3 b = -1.0 / coeff;\n    vec3 c =  1.0 / coeff;\n\n    return exp2(a * opticalDepth) * b + c;\n}\n\n\nvec3 calcAtmosphericScatter(positionStruct pos, out vec3 absorbLight){\n    const float ln2 = log(2.0);\n    \n    float lDotW = dot(pos.sunVector, pos.worldVector);\n    float lDotU = dot(pos.sunVector, vec3(0.0, 1.0, 0.0));\n    float uDotW = dot(vec3(0.0, 1.0, 0.0), pos.worldVector);\n    if(uDotW<0.){\n     uDotW=0.5;\n    }\n    \n\tfloat opticalDepth = calcParticleThickness(uDotW);\n    float opticalDepthLight = calcParticleThickness(lDotU);\n    \n    vec3 scatterView = scatter(totalCoeff, opticalDepth);\n    vec3 absorbView = absorb(totalCoeff, opticalDepth);\n    \n    vec3 scatterLight = scatter(totalCoeff, opticalDepthLight);\n         absorbLight = absorb(totalCoeff, opticalDepthLight);\n    \t \n    vec3 absorbSun =  abs(absorbLight - absorbView) / d0((scatterLight - scatterView) * ln2);\n    \n    vec3 mieScatter = scatter(mieCoeff, opticalDepth) * miePhaseSky(lDotW, opticalDepth);\n    vec3 rayleighScatter = scatter(rayleighCoeff, opticalDepth) * rayleighPhase(lDotW);\n    \n    vec3 scatterSun = mieScatter + rayleighScatter;\n    \n    vec3 sunSpot = smoothstep(0.9999, 0.99993, lDotW) * absorbView * sunBrightness;\n    \n    return (scatterSun * absorbSun + sunSpot) * sunBrightness;\n}\n\nvec3 calcAtmosphericScatterTop(positionStruct pos){\n    const float ln2 = log(2.0);\n    \n    float lDotU = dot(pos.sunVector, vec3(0.0, 1.0, 0.0));\n    \n\tfloat opticalDepth = calcParticleThicknessConst(2.5);\n    float opticalDepthLight = calcParticleThickness(lDotU);\n    \n    vec3 scatterView = scatter(totalCoeff, opticalDepth);\n    vec3 absorbView = absorb(totalCoeff, opticalDepth);\n    \n    vec3 scatterLight = scatter(totalCoeff, opticalDepthLight);\n    vec3 absorbLight = absorb(totalCoeff, opticalDepthLight);\n    \n    vec3 absorbSun = d02(absorbLight - absorbView) / d02((scatterLight - scatterView) * ln2);\n    \n    vec3 mieScatter = scatter(mieCoeff, opticalDepth) * 0.25;\n    vec3 rayleighScatter = scatter(rayleighCoeff, opticalDepth) * 0.375;\n    \n    vec3 scatterSun = mieScatter + rayleighScatter;\n    \n    return (scatterSun * absorbSun) * sunBrightness;\n}\n\nfloat Get3DNoise(vec3 pos) \n{\n    float p = floor(pos.z);\n    float f = pos.z - p;\n    \n    const float invNoiseRes = 1.0 / 64.0;\n    \n    float zStretch = 17.0 * invNoiseRes;\n    \n    vec2 coord = pos.xy * invNoiseRes + (p * zStretch);\n    \n    vec2 noise = vec2(texture(iChannel3, coord).x,\n\t\t\t\t\t  texture(iChannel3, coord + zStretch).x);\n    \n    return mix(noise.x, noise.y, f);\n}\n\nfloat getClouds(vec3 p)\n{\n    p = vec3(p.x, length(p + vec3(0.0, earthRadius, 0.0)) - earthRadius, p.z);\n    \n    if (p.y < cloudMinHeight || p.y > cloudMaxHeight)\n        return 0.0;\n    \n    float time = iTime * cloudSpeed;\n    vec3 movement = vec3(time, 0.0, time);\n    \n    vec3 cloudCoord = (p * 0.001) + movement;\n    \n\tfloat noise = Get3DNoise(cloudCoord) * 0.5;\n    \t  noise += Get3DNoise(cloudCoord * 2.0 + movement) * 0.25;\n    \t  noise += Get3DNoise(cloudCoord * 7.0 - movement) * 0.125;\n    \t  noise += Get3DNoise((cloudCoord + movement) * 16.0) * 0.0625;\n    \n    const float top = 0.004;\n    const float bottom = 0.01;\n    \n    float horizonHeight = p.y - cloudMinHeight;\n    float treshHold = (1.0 - exp2(-bottom * horizonHeight)) * exp2(-top * horizonHeight);\n    \n    float clouds = smoothstep(0.55, 0.6, noise);\n          clouds *= treshHold;\n    \n    return clouds * cloudDensity;\n}\n    \nfloat getCloudShadow(vec3 p, positionStruct pos)\n{\n\tconst int steps = volumetricLightShadowSteps;\n    float rSteps = cloudThickness / float(steps) / abs(pos.sunVector.y);\n    \n    vec3 increment = pos.sunVector * rSteps;\n    vec3 position = pos.sunVector * (cloudMinHeight - p.y) / pos.sunVector.y + p;\n    \n    float transmittance = 0.0;\n    \n    for (int i = 0; i < steps; i++, position += increment)\n    {\n\t\ttransmittance += getClouds(position);\n    }\n    \n    return exp2(-transmittance * rSteps);\n}\n\nfloat getSunVisibility(vec3 p, positionStruct pos)\n{\n\tconst int steps = cloudShadowingSteps;\n    const float rSteps = cloudThickness / float(steps);\n    \n    vec3 increment = pos.sunVector * rSteps;\n    vec3 position = increment * 0.5 + p;\n    \n    float transmittance = 0.0;\n    \n    for (int i = 0; i < steps; i++, position += increment)\n    {\n\t\ttransmittance += getClouds(position);\n    }\n    \n    return exp2(-transmittance * rSteps);\n}\n\nfloat phase2Lobes(float x)\n{\n    const float m = 0.6;\n    const float gm = 0.8;\n    \n\tfloat lobe1 = hgPhase(x, 0.8 * gm);\n    float lobe2 = hgPhase(x, -0.5 * gm);\n    \n    return mix(lobe2, lobe1, m);\n}\n\nvec3 getVolumetricCloudsScattering(float opticalDepth, float phase, vec3 p, vec3 sunColor, vec3 skyLight, positionStruct pos)\n{\n    float intergal = calculateScatterIntergral(opticalDepth, 1.11);\n    \n    float beersPowder = powder(opticalDepth * log(2.0));\n    \n\tvec3 sunlighting = (sunColor * getSunVisibility(p, pos) * beersPowder) * phase * hPi * sunBrightness;\n    vec3 skylighting = skyLight * 0.25 * rPi;\n    \n    return (sunlighting + skylighting) * intergal * pi;\n}\n\nfloat getHeightFogOD(float height)\n{\n\tconst float falloff = 0.001;\n    \n    return exp2(height * falloff) * fogDensity;\n}\n\n\nvec3 calculateVolumetricClouds(positionStruct pos, vec3 color, float dither, vec3 sunColor)\n{\n\tconst int steps = volumetricCloudSteps;\n    const float iSteps = 1.0 / float(steps);\n    \n    //if (pos.worldVector.y < 0.0)\n     //   return color;\n    \n    float bottomSphere = rsi(vec3(0.0, 1.0, 0.0) * earthRadius, pos.worldVector, earthRadius + cloudMinHeight).y;\n    float topSphere = rsi(vec3(0.0, 1.0, 0.0) * earthRadius, pos.worldVector, earthRadius + cloudMaxHeight).y;\n    \n    vec3 startPosition = pos.worldVector * bottomSphere;\n    vec3 endPosition = pos.worldVector * topSphere;\n    \n    vec3 increment = (endPosition - startPosition) * iSteps;\n    vec3 cloudPosition = increment * dither + startPosition;\n    \n    float stepLength = length(increment);\n    \n    vec3 scattering = vec3(0.0);\n    float transmittance = 1.0;\n    \n    float lDotW = dot(pos.sunVector, pos.worldVector);\n    float phase = phase2Lobes(lDotW);\n    \n    vec3 skyLight = calcAtmosphericScatterTop(pos);\n    \n    for (int i = 0; i < steps; i++, cloudPosition += increment)\n    {\n        float opticalDepth = getClouds(cloudPosition) * stepLength;\n        \n        if (opticalDepth <= 0.0)\n            continue;\n        \n\t\tscattering += getVolumetricCloudsScattering(opticalDepth, phase, cloudPosition, sunColor, skyLight, pos) * transmittance;\n        transmittance *= exp2(-opticalDepth);\n    }\n    \n    return mix(color * transmittance + scattering, color, clamp(length(startPosition) * 0.00001, 0.0, 1.0));\n}\n\nvec3 robobo1221Tonemap(vec3 color)\n{\n    #define rTOperator(x) (x / sqrt(x*x+1.0))\n\n    float l = length(color);\n\n    color = mix(color, color * 0.5, l / (l+1.0));\n    color = rTOperator(color);\n\n    return color;\n}\nvec3 getSky(in positionStruct pos )\n{\n    \n    float dither = bayer16(pos.texcoord*iResolution.xy);\n    \n    vec3 lightAbsorb = vec3(0.0);\n\n    vec3 color = vec3(0.0);\n         color = calcAtmosphericScatter(pos, lightAbsorb);\n         //color = calculateVolumetricClouds(pos, color, dither, lightAbsorb);\n         color = pow(color, vec3(1.0 / 2.2)); //Fitting to regular colorspace\n         color = robobo1221Tonemap(color);\n    return color;\n}\n\nfloat hash( vec2 p ) {\n    return fract(sin(dot(p,vec2(1177.1,2711.7)))*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f * f * (3.0-2.0 * f);\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nfloat wv(in vec2 uv, vec2 d, float t, float A)\n{\n    return sin ( dot(d, uv) / 4.0 + t) * A;\n}\n\n// water\nfloat fbm(in vec2 uv, float lod)\n{\t\n    float f =  textureLod(iChannel2, uv, lod).r * 0.5;\n    \t  f += textureLod(iChannel2, uv*2.0, lod).r * 0.5*0.5;\n    \t  f += textureLod(iChannel2, uv*4.0, lod).r * 0.5*0.5*0.5;\n    \t  f += textureLod(iChannel2, uv*8.0, lod).r * 0.5*0.5*0.5*0.5;\n\n    f = f*f*f*f;\n    return f;\n}\n\nfloat wavesLo(const in vec3 rp, float t, float A, float lod)\n{\n    vec2 uv = rp.xz;\n    \n    //uv.y += pow(max(rp.y + 0.4, 0.0), 10.) * 1.5;\n    float w00 = noise(uv * 1.2 * vec2(.2,  2.2) + vec2(0.20 * t, t * 1.));\n    float w03 = noise(uv * 1.2 * vec2(1.2,  .6) + vec2(1.* t, t * .3));\n    float w01 = fbm(uv*.05+vec2(iTime*.01, 0.), lod);\n    float w02 = fbm(uv*.1 +vec2(iTime*.006, iTime*.0024), lod);\n    return w00*.12+w01*.1+w02*0.1+w03*.1;\n}\n\n// high detail waves\nfloat waves(const in vec3 rp, float t, float A)\n{\n    vec2 uv = rp.xz;\n    vec2 nuv2 = uv+0.05*vec2(noise(uv*5.-t*.03), noise(uv*2.+t*.04));\n    \n    float w3 = wv(nuv2 * 170.0, vec2( -0.1, 0.6), t * 4.5, A) * 0.03;\n\tfloat w4 = wv(nuv2 * 170.0, vec2( 0.1, 0.6) , t * 6.,  A) * 0.03;\n    float w7 = wv(nuv2 * 570.0, vec2( 0.05, 0.4), t * 15., A) * 0.02;\n    float w8 = wv(nuv2 * 570.0, vec2( -0.05, 0.3) , t * 15.,  A) * 0.02;\n    float w5 = -wv(nuv2 * 1670.0, vec2(-0.1, 0.4), t * 63., A) * 0.007;\n    float w6 = -wv(nuv2 * 1670.0, vec2( 0.1, 0.5) ,  t * 63.,  A) * 0.007;\n    \n    return wavesLo(rp, t, A, 0.0) +w3+w4+w7+w8+w5+w6;\n}\n\nfloat mapLo(in vec3 rp)\n{\n    return rp.y - wavesLo(rp, 2.0+iTime*.5, .04, 4.0);\n}\n\n\nfloat map(in vec3 rp)\n{\n    return rp.y - waves(rp, 2.0+iTime*.5, .04);\n}\n\n\nvec3 grad(vec3 rp, float preci)\n{\n    vec2 off = vec2(preci, 0.0);\n    vec3 g = vec3(map(rp + off.xyy) - map(rp - off.xyy),\n\t\t\t\t  map(rp + off.yxy) - map(rp - off.yxy),                  \n\t\t\t\t  map(rp + off.yyx) - map(rp - off.yyx));\n    return normalize(g);\n}\n\n// scanning the surroundings for differences in heights on the heightmap\nvec2 sub(vec3 rp, float preci)\n{\n    vec2 off = vec2(preci, 0.0);\n    vec2 g = vec2(map(rp + off.xyy) + map(rp - off.xyy),\n\t\t\t\t  map(rp + off.yyx) + map(rp - off.yyx));\n    return g;\n}\n\n// for the spec bump \nvec3 texGrad(in vec2 uv)\n{\n    vec2 offset = vec2(0.01, 0.0);\n    uv *= .5;\n    float h0 = texture(iChannel2, uv).r;\n    float h1 = h0-texture(iChannel3, uv+offset.xy).r;\n    float h2 = h0-texture(iChannel0, uv+offset.yx).r;\n    \n    float bump = .4;\n    vec3 g = cross(normalize(vec3(bump, h1, 0.0)), normalize(vec3(0.0, h2, bump)));\n    return g;\n}\n\n\nconst vec3 up = vec3(0.0, 1.0, 0.0);\n\n\nvoid trace(in positionStruct pos, in vec3 rp, in vec3 rd, inout vec4 color)\n{\n    \n    if (dot(rd, up)>0.0){\n        color.rgb = getSky(pos);\n        return;\n    }\n    \n    // trace to plane on top of waves\n    vec3 ro = rp;\n    float t = -(0.155+dot(rp, -up)) / dot(-up, rd);\n    if (t < 0.0) \n    {\n        return;\n    }\n    \n\trp += rd*t;    \n    bool hit = false;\n    float dist = 0.0;\n    \n    // actual tracing\n    \n    // low freq\n    for (int i = 0; i < 5; ++i)\n    {\n        float travelledSq=dot(ro-rp, ro-rp);\n        dist = mapLo(rp);\n        \n        if(dist < 0.01)\n        {\n            hit = true;\n            break;\n        }\n        rp += rd * max(dist * (log2(2.+travelledSq)), 0.01);\n        if(travelledSq > 9000.0) break;\n    }\n    \n    //detail tracing\n    /*for (int i = 0; i < 10; ++i)\n    {\n        rp += dist * rd;\n        if (abs(dist) < 0.0001) break;\n        dist = map(rp);\n    }*/\n    \n    // shadings    \n        vec3 sun = pos.sunVector;\n        vec3 g = grad(rp, 0.002 * (1.0+log2(length(ro-rp) * 100.)));\n        /*vec3 tg =  texGrad (rp.xz*5.1 + vec2(-iTime*.015, iTime*.06));\n        vec3 tg2 = texGrad (rp.xz*6.2 + vec2( iTime*.01,  -iTime*.06));\n        tg = normalize(tg+tg2);\n        tg = normalize(tg+texGrad(rp.xz*4.2 + vec2( iTime*.01, iTime*.05))*0.3);*/\n        \n        //vec3 sg = grad(rp, 0.001);\n        //sg = normalize(sg+tg*.3);\n        // base color\n        pos.worldVector = rd-2.*dot(rd, g)*g;\n        pos.worldVector = normalize(pos.worldVector);\n        color.rgb = getSky(pos);\n        //color = vec4(.05, 0.22, .4, 0.0);\n        /*\n        // diffuse\n        float d = max(0.0, dot(g, sun));\n        //color *= mix(1.0, d, .4);\n        \n        // top\n        vec2 heights = sub(rp, 0.3);\n        float sst = length(max(vec2(0.00001), heights));\n        float sunD = -1.*(dot(sun, g));\n        //color.rgb = mix(color.rgb, vec3(.2, 0.5, 0.72)*.5, smoothstep(0., .4, sunD));\n        \n        // bottom\n        float ssb = length(min(vec2(0.0), heights));\n        //color.rgb = mix(color.rgb, vec3(.05, 0.22, .4)*.5, smoothstep(0.0, 0.4, ssb));\n        */\n        // foam\n        /*vec3 pw = vec3(1.+2.3/(sst*1.+.001))*2.2;\n        vec3 texcol1 = texture(iChannel2, rp.xz*.5+vec2(.0, .07*iTime)).rgb;\n        \n        vec3 pw2 = vec3(1.+.7/(sst*1.2+.01));\n        vec3 texcol2 = texture(iChannel2, rp.xz*.5+vec2(.0, .07*iTime)).rgb*1.;\n        \n        vec3 foam = max(pow(texcol1, pw).rrr, pow(texcol2, pw2).rrr);\n        if(foam.r>.3){\n        color.rgb = foam*3.;\n        }*/\n        \n        // fresnel\n        vec3 H = normalize(-rd + normalize(sun));\n        float F = clamp(max(0.0, 1.2+dot(rd, g)), 0.0, 1.);\n\n        color.rgb = F* color.rgb + (1.-F)*vec3(.0, .15, .3);\n\n    \n    color.a = 1.;//length(ro-rp);\n    \n}\n\n\nmat3 lookat(vec3 from, vec3 to)\n{\n    vec3 f = normalize(to - from);\n    vec3 _tmpr = normalize(cross(f, vec3(0.0, .999, 0.0)));\n    vec3 u = normalize(cross(_tmpr, f));\n    vec3 r = normalize(cross(u, f));\n    return mat3(r, u, f);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    gatherPositions(pos, fragCoord, iMouse.xy, iResolution.xy);\n;\n    vec2 uv = (fragCoord.xy-iResolution.xy*.5) / iResolution.x;\n    \n    //ray direction \n    vec3 rd = pos.worldPosition;\n    \n    //ray position\n    vec3 rp = vec3(0.0, 0.3, 0.0);\n    vec3 _rp = rp;\n\t    \n    trace(pos, rp, rd, fragColor);\n    fragColor.rgb = clamp(fragColor.rgb, 0.0, 1.0);\n}", "buffer_b_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define VOLUMETRIC_LIGHT\n//#define SPHERICAL_PROJECTION\n\n#define cameraMode 1 \t\t\t\t\t//1 is free rotation, 2 is still camera but free sun rotation\n\n\n//////////////////////////////////////////////////////////////////\n\nfloat bayer2(vec2 a){\n    a = floor(a);\n    return fract( dot(a, vec2(.5, a.y * .75)) );\n}\n\nvec2 rsi(vec3 position, vec3 direction, float radius) {\n    float PoD = dot(position, direction);\n    float radiusSquared = radius * radius;\n\n    float delta = PoD * PoD + radiusSquared - dot(position, position);\n    if (delta < 0.0) return vec2(-1.0);\n          delta = sqrt(delta);\n\n    return -PoD + vec2(-delta, delta);\n}\n\n#define bayer4(a)   (bayer2( .5*(a))*.25+bayer2(a))\n#define bayer8(a)   (bayer4( .5*(a))*.25+bayer2(a))\n#define bayer16(a)  (bayer8( .5*(a))*.25+bayer2(a))\n#define bayer32(a)  (bayer16(.5*(a))*.25+bayer2(a))\n#define bayer64(a)  (bayer32(.5*(a))*.25+bayer2(a))\n#define bayer128(a) (bayer64(.5*(a))*.25+bayer2(a))\n\n//////////////////////////////////////////////////////////////////\n\n#define cloudMinHeight cloudHeight\n#define cloudMaxHeight (cloudThickness + cloudMinHeight)\n\n#define sunPosition vec3(1.0, 1.0, 0.0)\n\nconst float pi = acos(-1.0);\nconst float rPi = 1.0 / pi;\nconst float hPi = pi * 0.5;\nconst float tau = pi * 2.0;\nconst float rLOG2 = 1.0 / log(2.0);\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    float xx = axis.x * axis.x;\n    float yy = axis.y * axis.y;\n    float zz = axis.z * axis.z;\n    \n    float xy = axis.x * axis.y;\n    float xz = axis.x * axis.z;\n    float zy = axis.z * axis.y;\n    \n    return mat3(oc * xx + c, oc * xy - axis.z * s, oc * xz + axis.y * s,\n                oc * xy + axis.z * s, oc * yy + c, oc * zy - axis.x * s, \n                oc * xz - axis.y * s, oc * zy + axis.x * s, oc * zz + c);\n}\n#define PI 3.14159265358\n\nmat3 rotx(float a) { return rotationMatrix(vec3(1.,0.,0.), a); }\nmat3 roty(float a) { return rotationMatrix(vec3(0.,1.,0.), a); }\nmat3 rotz(float a) { return rotationMatrix(vec3(0.,0.,1.), a); }\n\nstruct positionStruct\n{\n\tvec2 texcoord;\n    vec2 mousecoord;\n    vec3 worldPosition;\n    vec3 worldVector;\n    vec3 sunVector;\n} pos;\n\nvec3 sphereToCart(vec3 sphere) {\n    vec2 c = cos(sphere.xy);\n    vec2 s = sin(sphere.xy);\n    \n    return sphere.z * vec3(c.x * c.y, s.y, s.x * c.y);\n}\n\nvec3 calculateWorldSpacePosition(vec2 p)\n{\n\tp = p * 2.0 - 1.0;\n    \n    vec3 worldSpacePosition =  vec3(p.x, p.y, 1.0);\n    \n    #ifdef SPHERICAL_PROJECTION\n\t\tworldSpacePosition = sphereToCart(worldSpacePosition * vec3(pi, hPi, 1.0));\n\t#endif\n    \n    return worldSpacePosition;\n}\n\nvoid gatherPositions(inout positionStruct pos, vec2 fragCoord, vec2 mouseCoord, vec2 screenResolution)\n{\n\tpos.texcoord = fragCoord / screenResolution;\n    pos.mousecoord = mouseCoord / screenResolution;\n    \n    pos.mousecoord = pos.mousecoord.x < 0.001 ? vec2(0.4, 0.64) : pos.mousecoord;\n    \n    vec2 rotationAngle = radians(vec2(360.0, 180.0) * pos.mousecoord - vec2(0.0, 90.0));\n\n    \n    mat3 rotateH = rotationMatrix(vec3(0.0, 1.0, 0.0), rotationAngle.x);\n    mat3 rotateV = rotationMatrix(vec3(1.0, 0.0, 0.0), -rotationAngle.y);\n    \n    pos.worldPosition = calculateWorldSpacePosition(pos.texcoord);\n    \n    if (cameraMode == 1) {\n    \tpos.worldPosition = rotateH * (rotateV * pos.worldPosition);\n        \n        // Sun position\n    \tpos.sunVector = normalize(sunPosition);\n    }\n    if (cameraMode == 2) {\n    \tpos.sunVector = normalize(calculateWorldSpacePosition(pos.mousecoord));\n    }\n    \n    pos.worldVector = normalize(pos.worldPosition);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXSD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 143]], "test": "untested"}
{"id": "fllSWn", "name": "Fork Synaptic by pirk0", "author": "pirk0", "description": "- based on https://www.shadertoy.com/view/MdG3Dd\n- replaced noisemap https://www.shadertoy.com/view/ftlXWn", "tags": ["3d", "particles", "palette", "feedback", "trails", "multipass"], "likes": 10, "viewed": 510, "published": 3, "date": "1625474609", "time_retrieved": "2024-07-30T19:12:09.233520", "image_code": "// Synaptic by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/MdG3Dd\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n//Code is in the other tabs:\n//Buf A = Particle velocity and position handling\n//Buf B = Rendering\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(texture(iChannel0, fragCoord.xy/iResolution.xy).rgb, 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Synaptic by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/MdG3Dd\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n//Velocity handling\n\nvec3 hash3(vec3 p)\n{\n    p = fract(p * vec3(443.8975,397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz+19.1);\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z))-0.5;\n}\n\nvec3 update(in vec3 vel, vec3 pos, in float id)\n{   \n    vel.xyz = vel.xyz*.999 + (hash3(vel.xyz + iTime)*2.)*7.;\n    \n    float d = pow(length(pos)*1.2, 0.75);\n    vel.xyz = mix(vel.xyz, -pos*d, sin(-iTime*.55)*0.5+0.5);\n    \n    return vel;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    \n    vec4 col= vec4(1);\n    vec2 w = 1./iResolution.xy;\n    \n    vec3 pos = texture(iChannel0, vec2(q.x,100.*w)).xyz;\n    vec3 velo = texture(iChannel0, vec2(q.x,0.0)).xyz;\n    velo = update(velo, pos, q.x);\n    \n    if (fragCoord.y < 30.)\n    {\n    \tcol.rgb = velo;\n    }\n    else\n    {\n        pos.rgb += velo*0.002;\n        col.rgb = pos.rgb;\n    }\n\t\n    //Init\n    if (iFrame < 10) \n    {\n        if (fragCoord.y < 30.)\n        \tcol = ((texture(iChannel1, q*1.9))-.5)*10.;\n        else\n        {\n            col = ((texture(iChannel1, q*1.9))-.5)*.5;\n        }\n    }\n    \n\tfragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Synaptic by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/MdG3Dd\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n//Rendering\n\n/*\n\tThis buffer renders each particles\n\tmultiple times per frame to allow particles\n\tto move more than one pixel per frame while still\n\tleaving a solid trail.\n*/\n\n//Anywhere under 900 \"should\" work fine (might slow down though)\nconst int numParticles = 140;\nconst int stepsPerFrame = 7;\n\nfloat mag(vec3 p){return dot(p,p);}\n\nvec4 drawParticles(in vec3 ro, in vec3 rd)\n{\n    vec4 rez = vec4(0);\n    vec2 w = 1./iResolution.xy;\n    \n    for (int i = 0; i < numParticles; i++)\n    {\n        vec3 pos = texture(iChannel0, vec2(i,100.0)*w).rgb;\n        vec3 vel = texture(iChannel0, vec2(i,0.0)*w).rgb;\n        for(int j = 0; j < stepsPerFrame; j++)\n        {\n            float d = mag((ro + rd*dot(pos.xyz - ro, rd)) - pos.xyz);\n            d *= 1000.;\n            d = .14/(pow(d,1.1)+.03);\n            \n            rez.rgb += d*abs(sin(vec3(2.,3.4,1.2)*(iTime*.06 + float(i)*.003 + 2.) + vec3(0.8,0.,1.2))*0.7+0.3)*0.04;\n            pos.xyz += vel*0.002*0.2;\n        }\n    }\n    rez /= float(stepsPerFrame);\n    \n    return rez;\n}\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\nvec3 roty(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n\nvec3 rotz(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\t\n    vec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(-0.15,0.):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n    mo*=6.14;\n\t\n\tvec3 ro = vec3(0.,0.,2.5);\n    vec3 rd = normalize(vec3(p,-.5));\n    \n    vec4 cola = drawParticles(ro, rd);\n    vec4 colb = texture(iChannel1, q);\n    \n    //Feedback\n    vec4 col = cola + colb;\n    col *= 0.9975;\n    \n    if (iFrame < 5) col = vec4(0);\n    \n\tfragColor = col;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Generate Gold Noise image\n\nconst float PHI = 1.61803398874989484820459; // Φ = Golden Ratio \n\nfloat gold_noise(in vec2 xy, in float seed)\n{\n    return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(gold_noise(fragCoord, fract(iTime)+1.0), // r\n                gold_noise(fragCoord, fract(iTime)+2.0), // g\n                gold_noise(fragCoord, fract(iTime)+3.0), // b\n                1.0);                             // a\n}", "buffer_c_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fllSWn.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[321, 321, 378, 378, 457]], "test": "untested"}
{"id": "ftlXDn", "name": "chronophotography 2", "author": "FabriceNeyret2", "description": "uh, I discover I already did this along ago when I found the title was already taken... by me. https://www.shadertoy.com/view/Md33Dj   →  so, enriching the new one.\nNote sure why I have this aliasing on contour, though ( I even use MIPmap to smooth sourc ", "tags": ["chronophotography"], "likes": 10, "viewed": 411, "published": 3, "date": "1625474170", "time_retrieved": "2024-07-30T19:12:10.129124", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    O = texelFetch( iChannel0, ivec2(U), 0 );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{\n    U /= iResolution.xy;\n\n    O = textureLod(iChannel1, U,1.);\n    float d = length ( O.rgb*255. - vec3(13,163,37) );\n   \n    d = (d -100.) / max(.01, fwidth(d));\n  \n    // .995 : fade with age     .03 : blur with age\n    O =   mix( .995*texture(iChannel0, U,.03), texture(iChannel1, U), smoothstep ( -3., 3., d ) ) // blend on background\n        * smoothstep ( 0., 2., abs(d) ); // add black silhouette contouring\n \n}", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftlXDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 86]], "test": "untested"}
{"id": "ftsSDn", "name": "time warp with sine offset", "author": "teadrinker", "description": "Just testing timewarp with a different shape.\nnormal timewarp:  https://www.shadertoy.com/view/NtlXWn", "tags": ["timewarp"], "likes": 3, "viewed": 431, "published": 3, "date": "1625470878", "time_retrieved": "2024-07-30T19:12:10.984836", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    float sinePeaks = 3.;\n    float waitPixelRows = 300.;\n    int speed = 1; // higher values will reduce quality\n    int scanPos = int(mod(float(iFrame * speed), iResolution.y + waitPixelRows));\n    int yoffs = int((-1.+cos(fragCoord.x * sinePeaks * 6.28/ iResolution.x)) * iResolution.y / 22.);\n    if(int(fragCoord.y) + yoffs > int(iResolution.y) - scanPos)\n        discard;\n    else if(int(fragCoord.y) + yoffs ==  int(iResolution.y) - scanPos - speed)\n        fragColor = vec4(0.,1.,0.,1.);\n    else\n        fragColor = texture(iChannel0, vec2(iResolution.x - fragCoord.x, fragCoord.y) / iResolution.xy);\n}\n\n\n", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsSDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 58, 58, 670]], "test": "untested"}
{"id": "NtlXWn", "name": "time warp single pass", "author": "teadrinker", "description": "https://www.reddit.com/r/shaders/comments/o7n3x5/is_there_any_possibility_to_make_this_shader_work/\n\nSame shader, but with sine offset: https://www.shadertoy.com/view/ftsSDn\nwithout discard: https://www.shadertoy.com/view/fdjfRt", "tags": ["timewarp", "singlepass"], "likes": 2, "viewed": 537, "published": 3, "date": "1625468344", "time_retrieved": "2024-07-30T19:12:11.730841", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    float waitPixelRows = 200.;\n    int speed = 1; // higher values will reduce quality\n    int width = 3; \n    vec4 scanColor = vec4(0.4, 1., 0.85,1.);\n    \n    int scanPos = int(mod(float(iFrame * speed), iResolution.y + waitPixelRows));\n    if(int(fragCoord.y) > int(iResolution.y) - scanPos)\n        discard;\n    else if(abs(int(fragCoord.y) + speed*width - (int(iResolution.y) - scanPos)) < width)\n        fragColor = scanColor;\n    else\n        fragColor = texture(iChannel0, vec2(iResolution.x - fragCoord.x, fragCoord.y) / iResolution.xy);\n}\n\n\n", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtlXWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ftlXWn", "name": "Fork Gold Noise TD Compatible", "author": "pirk0", "description": "- based on https://www.shadertoy.com/view/ltB3zD", "tags": ["noise", "random", "static", "generator"], "likes": 1, "viewed": 291, "published": 3, "date": "1625467527", "time_retrieved": "2024-07-30T19:12:12.647391", "image_code": "// Generate Gold Noise image\n\nconst float PHI = 1.61803398874989484820459; // Φ = Golden Ratio \n\nfloat gold_noise(in vec2 xy, in float seed)\n{\n    return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(gold_noise(fragCoord, fract(iTime)+1.0), // r\n                gold_noise(fragCoord, fract(iTime)+2.0), // g\n                gold_noise(fragCoord, fract(iTime)+3.0), // b\n                1.0);                             // a\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftlXWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 143, 143, 200], [203, 203, 258, 258, 506]], "test": "untested"}
{"id": "7tsSR4", "name": "Conway Colouring [Full Screen]", "author": "Yusef28", "description": "Full Screen shows way more!\nComments on the process are in the image tab", "tags": ["coloring", "conway", "gameoflife", "gol"], "likes": 5, "viewed": 405, "published": 3, "date": "1625451378", "time_retrieved": "2024-07-30T19:12:13.522052", "image_code": "/* CONWAY's GAME OF LIFE- COLORED BY \"Death Counting\"\n(and one or two other things)\n\nI have about 7 different coloring schemes below based on this\nsimple idea:\n\nTrack the number of times a cell has died \nin buffer A and then pass that to main along with the current\nstate. Only show pixels with state = 1 (alive) + color somehow\nbased on the number of times a pixel has died.\n\nAt first I was just trying to get tiled with a soft\nvignette shading around each one so that's why there is a \nlength(p - vec2( etcetc) in there but it works well because\nit adds a gradient. I wanted a tiled conway's game\nbut couldn't get it.\n\nThis is a great example of what I wanted initally:\nhttps://www.shadertoy.com/view/3tSyWm\n\nAlso there is a level of detail hack I used to intially get\nbigger cells. So I call buffer A with uv/16.\n\nI started experimenting and discovered coloring the pixels \nbased on number of deaths. \nNot a new concept apparently but there it is. \n(Honestly I'm not exaclty sure how it works since number of deaths\nseems often to just be 0 or 1. but it's doing something.)\n\nI discovered a ton of very interesting patterns \nbased on this. I'm sure there are more.\n\nOn Full Screen more of the world is displayed than just small.\n\nincreasing 10. to 16 in this line in th code (around line 40 - 50)\nwill let you see more detail of the indivsual things. It's pretty\ninteresting.\n\nvec4 tex = texture(iChannel0,uv/10.);\n*/\n\n\n\n//FIRST A MUCH EASIER TO UNDERSTAND VERSION: FabriceNeyret2\n/*\nvoid mainImage( out vec4 O, vec2 U )\n{ \n    O = texture(iChannel0,U/iResolution.xy /16.);\n    // .y = current state , .x = death counter\n    \n    U = fract(U/256.);\n \n    float v =     O.y                            // state\n              * ( 1.-length(U-.5) )              // large tile decoration\n              * ( .6+ 5.*cos(.05 + O.x*15.)  );  // strips around cells\n   \n    O = .5 + .6*cos( v + vec4(0,2,4,0)/5. + 2.); // hue\n    O = pow(O,vec4(2.8))*4.;                     // sort of sRGB\n}\n\n\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates 0 (from to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //for color\n    \n    //the 256 effects the highlights. lower for more highlights.\n    vec2 st = fract(uv*iResolution.xy/256.);\n    // Time varying pixel color\n    //vec2 id = floor(uv*32.);\n    \n    //the colors are some how dependent on the uv/# \n    //16. is what all my coloring schemes are based on.\n    vec4 tex = texture(iChannel0,uv/16.);\n    \n    vec3 col = vec3(step(0.5,tex.y));// * (1.0-length(st-vec2(0.5))-0.3);\n       //col = vec3(tex.y*(1.0-length(st-vec2(0.5))));\n       //col = col.x*(0.9+1.5*cos(vec3(3.,3.,4.)/5. - tex.x*205. + 10.)  );\n       \n       //inside out\n       /*\n       col = vec3(tex.y*(1.0-length(st-vec2(0.5))));\n       col = col.x*(0.9+1.5*cos(vec3(3.,3.,4.)/5. - tex.x*205. + 10.)  );\n       */\n       \n       //clowns\n       /*\n        col = vec3(tex.y*(1.0-length(st-vec2(0.5))));\n       col = col.x*(0.3+2.5*cos(vec3(1.,3.,4.)/5. - tex.x*25. + 10.)  );\n       */\n       \n       //double outline \n       /*\n       col = vec3(tex.y*(1.0-length(st-vec2(0.5))));\n       col = col.x*(0.3+2.5*cos(vec3(1.,3.,4.)/20. + tex.x*15.)  );\n       */\n       \n       //minimal outline\n       /*\n       col = vec3(tex.y*(1.0-length(st-vec2(0.5))));\n       col = col.x*(0.3+2.5*cos(vec3(1.,3.,4.)/20. + tex.x*9.)  );\n       */\n       \n       //cool pattern 1 red\n       /*\n       col = vec3(tex.y*tex.y*tex.y* (1.0-length(st-vec2(0.5))));\n       col = col.x*(0.3+2.5*cos(vec3(1.,3.,4.)/2. + tex.x*90.)  );\n       */\n       \n       //cool pattern 2\n       /*\n       col = vec3(tex.y*(1.0-length(st-vec2(0.5))));\n       col = col.x*(0.3+2.5*cos(vec3(1.,3.,4.)/2. + tex.x*90.)  );\n       */\n       \n       //I think I'll choose double outline one for now\n       //and add a cool palette\n       col = vec3(tex.y*(1.0-length(st-vec2(0.5))));\n       col = col.x*(0.3+2.5*cos(vec3(1.,3.,4.)/20. + tex.x*15.)  );\n       //added one more line for that\n       col = 0.5+0.6*cos(vec3(col.x)+vec3(0,2,4)/5.+col.x*1. + 2.);\n       \n    \n    \n    col = pow(col,vec3(2.8))*4.;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\n\nfloat count(vec2 p, vec2 off){\n\n    float cnt = 0.;\n    \n    cnt += texture(iChannel0, p + vec2(off.x,off.y)).y;\n    cnt += texture(iChannel0, p + vec2(off.x,0.0)).y;\n    cnt += texture(iChannel0, p + vec2(off.x,-off.y)).y;\n    cnt += texture(iChannel0, p + vec2(0.,off.y)).y;\n    cnt += texture(iChannel0, p + vec2(0.,-off.y)).y;\n    cnt += texture(iChannel0, p + vec2(-off.x,off.y)).y;\n    cnt += texture(iChannel0, p + vec2(-off.x,0.0)).y;\n    cnt += texture(iChannel0, p + vec2(-off.x,-off.y)).y;\n    \n    return cnt;\n    \n}\n\nvoid mainImage( out vec4 data, in vec2 fragCoord )\n{\n\n   //fragCoord -= mod(fragCoord, float(S));\n    vec2 off = S/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;//  + (off * .5);\n    vec2 st = fract(uv*skale);\n    vec2 id = floor(uv*skale);\n    vec3 mouse = iMouse.xyz;\n    \n    float c;\n    \n    float state,val,speed,resx;\n    \n    \n    //set up / spacebar reset\n    if(iFrame == 0 || texture(iChannel1,  vec2(0.126953125, .25)).x > 0.){\n    \n        uv = fragCoord/iResolution.xy;\n        \n        //st = fract(uv*skale);        \n        id = floor(uv*skale);\n\n        \n        //val = rnd(id);\n        state = step(0.65,rnd(uv));\n        val = 0.;\n        //speed = rnd(id+vec2(1.))*0.002+0.99;\n        //resx = iResolution.x;\n        \n    }\n    else{\n        //get own texture\n        vec4 tex = texture(iChannel0, uv);\n        \n        float c = count(uv,off);\n        \n        state = tex.y;\n        \n            if((c == 2. && state == 1.) || c == 3.){\n            \n            //this variation is like a tiling\n            //if((c == 2. && state == 1.) || c == 1.){\n            \n                state = 1.;\n            }\n            \n            //if cell dies, increment val, the death counter\n            //\"Death Counting\"\n            else{\n            \n            \n                state = 0.;\n                val += 1.;\n            }    \n    \n    }\n\n\n    data = vec4(val, state, speed, rnd(vec2(uv.x*uv.y)));\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n//scaling and aspect ration have to happen for st and not the orig uv\n#define S 1.\n#define skale vec2(S,S)\n//*(iResolution.y/iResolution.x))\n//#define off vec2(iResolution.x/skale.x,iResolution.y/skale.y)\n\nfloat rnd(vec2 id){\n    return fract(sin(id.x*12.99+id.y*800.+40.)*51343.);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tsSR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1423, 1989, 2046, 2096, 4186]], "test": "untested"}
{"id": "7tfSWr", "name": "RippleWave", "author": "ZenithGD", "description": "My first GLSL shader!", "tags": ["trippy", "psychodelic"], "likes": 4, "viewed": 265, "published": 3, "date": "1625450956", "time_retrieved": "2024-07-30T19:12:14.386741", "image_code": "#define PI 3.14159265\n#define sides 9.0\n\nfloat ripple(float d)\n{\n    return d / 3.0 + sin(30.0 * d * d - 5.0 * (iTime + sin(6.0 * iTime) / 10.0) ) / 2.0 * sqrt(d * d + 1.0) + 0.5;\n}\n\nfloat angle(vec2 v)\n{\n    return acos(dot(normalize(v),vec2(0.0, 1.0)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float angleNorm = fract(angle(fragCoord / iResolution.xy - vec2(0.5, 0.5)) / ( 2.0 * PI ));\n    \n    float d = sin(2.0 * sides * PI * angleNorm + PI/2.0)/(50.0 * (sin(2.0 * iTime) + 2.0)) + 1.0 - distance(vec2(0.5, 0.5), vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y)); \n                  ;\n    \n    float r = ripple(d);\n    \n    // Output to screen\n    vec4 nv   = vec4(abs(sin(iTime + PI / 4.0)) * r * d * d + abs(sin(iTime)) / 2.0, \n                     abs(cos(iTime + PI / 2.0)) * r * (1.0 - d * d / 2.0),\n                     abs(cos(iTime + PI / 4.0)) * r * (1.0 - d),\n                     1.0);\n    fragColor = nv;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tfSWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 64, 64, 181], [183, 183, 204, 204, 257], [259, 259, 316, 316, 961]], "test": "untested"}
{"id": "NlXXDr", "name": "Look into my eye", "author": "mrange", "description": "License CC0: Look into my eye\nEye designs was the theme of the weekend. Last one.\n", "tags": ["2d"], "likes": 15, "viewed": 382, "published": 3, "date": "1625431383", "time_retrieved": "2024-07-30T19:12:15.208543", "image_code": "// License CC0: Look into my eye\n//  Eye designs was the theme of the weekend. Last one.\n\n// Variant flips between B/W design and colorful design\n// #define VARIANT\n\n#define PI            3.141592654\n#define TAU           (2.0*PI)\n#define TIME          iTime\n#define TTIME         (TAU*iTime)\n#define RESOLUTION    iResolution\n#define ROT(a)        mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x)       (0.5 + 0.5*cos(x))\n#define DOT2(x)       dot(x, x)\n#define PERIOD        5.0\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst vec3  grid_color    = HSV2RGB(vec3(0.6, 0.3, 1.0)); \nconst vec3  light0_color  = 16.0*HSV2RGB(vec3(0.6, 0.5, 1.0)); \nconst vec3  light1_color  = 8.0*HSV2RGB(vec3(0.9, 0.25, 1.0)); \nconst vec3  sky0_color    = HSV2RGB(vec3(0.05, 0.65, -0.25)); \nconst vec3  sky1_color    = HSV2RGB(vec3(0.6, 0.5, 0.25)); \nconst vec3  light0_pos    = vec3(1.0, 5.0, 4.0);\nconst vec3  light1_pos    = vec3(3.0, -1.0, -8.0);\nconst vec3  light0_dir    = normalize(light0_pos);\nconst vec3  light1_dir    = normalize(light1_pos);\nconst vec4  planet_sph    = vec4(50.0*normalize(light1_dir+vec3(0.025, -0.025, 0.0)), 10.0);\n\nfloat g_hf;\n\nvec2 g_vx = vec2(0.0);\nvec2 g_vy = vec2(0.0);\n\nvec2 g_wx = vec2(0.0);\nvec2 g_wy = vec2(0.0);\n\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.0-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n}\n\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, vec3(1.0/2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat vesica(vec2 p, vec2 sz) {\n  if (sz.x < sz.y) {\n    sz = sz.yx;\n  } else {\n    p  = p.yx; \n  }\n  vec2 sz2 = sz*sz;\n  float d  = (sz2.x-sz2.y)/(2.0*sz.y);\n  float r  = sqrt(sz2.x+d*d);\n  float b  = sz.x;\n  p = abs(p);\n  return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                           : length(p-vec2(-d,0.0))-r;\n}\n\n// IQ's ray sphere intersect: https://iquilezles.org/articles/intersectors\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sph) {\n  vec3 oc = ro - sph.xyz;\n  float b = dot( oc, rd );\n  float c = dot( oc, oc ) - sph.w*sph.w;\n  float h = b*b - c;\n  if (h < 0.0) return vec2(-1.0);\n  h = sqrt(h);\n  return vec2(-b - h, -b + h);\n}\n\n// IQ's ray plane  intersect: https://iquilezles.org/articles/intersectors\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return p.x*vec2(cos(p.y), sin(p.y));\n}\n\nvec3 toSpherical(vec3 p) {\n  float r   = length(p);\n  float t   = acos(p.z/r);\n  float ph  = atan(p.y, p.x);\n  return vec3(r, t, ph);\n}\n\nvec3 toRect(vec3 p) {\n  return p.x*vec3(cos(p.z)*sin(p.y), sin(p.z)*sin(p.y), cos(p.y));\n}\n\n// https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return -pmin(-a, a, k);\n}\n\nconst vec2 iris_center = vec2(0.0, 0.28);\n\nfloat noise(vec2 p) {\n  float a = sin(p.x);\n  float b = sin(p.y);\n  float c = 0.5 + 0.5*cos(p.x + p.y);\n  float d = mix(a, b, c);\n  return d;\n}\n\n// https://iquilezles.org/articles/fbm\nfloat fbm(vec2 p, float aa) {\n  const mat2 frot = mat2(0.80, 0.60, -0.60, 0.80);\n\n  float f = 0.0;\n  float a = 1.0;\n  float s = 0.0;\n  float m = 2.0;\n  for (int x = 0; x < 4; ++x) {\n    f += a*noise(p); \n    p = frot*p*m;\n    m += 0.01;\n    s += a;\n    a *= aa;\n  }\n  return f/s;\n}\n\n// https://iquilezles.org/articles/warp\nfloat warp(vec2 p, out vec2 v, out vec2 w) {\n  float d2 = DOT2(p);\n//  p.x = pabs(p.x, 0.1);\n  p = -p.yx;\n  p = toPolar(p);\n  p.y -= -0.125*TIME+p.x*1.25;\n  vec2 pp = p;\n\n  vec2 vx = g_vx;\n  vec2 vy = g_vy;\n\n  vec2 wx = g_wx;\n  vec2 wy = g_wy;\n\n  const float r = 0.5;\n  const float rr = 0.25;\n  float f = smoothstep(r, r+rr, pp.x);\n  g_hf = f;\n\n  //float aa = mix(0.95, 0.25, tanh_approx(pp.x));\n  float aa = 0.5;\n\n  v = vec2(fbm(p + vx, aa), fbm(p + vy, aa))*f;\n  w = vec2(fbm(p + 3.0*v + wx, aa), fbm(p + 3.0*v + wy, aa))*f;\n  \n  return -tanh_approx(fbm(p + 2.25*w, aa)*f);\n}\n\nvec3 normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = warp(p + e.xy, v, w) - warp(p - e.xy, v, w);\n  n.y = 2.0*e.x;\n  n.z = warp(p + e.yx, v, w) - warp(p - e.yx, v, w);\n  \n  return normalize(n);\n}\n\nvoid compute_globals() {\n  vec2 vx = vec2(0.0, 0.0);\n  vec2 vy = vec2(3.2, 1.3);\n\n  vec2 wx = vec2(1.7, 9.2);\n  vec2 wy = vec2(8.3, 2.8);\n\n  vx *= ROT(TTIME/1000.0);\n  vy *= ROT(TTIME/900.0);\n\n  wx *= ROT(TTIME/800.0);\n  wy *= ROT(TTIME/700.0);\n  \n  g_vx = vx;\n  g_vy = vy;\n  \n  g_wx = wx;\n  g_wy = wy;\n}\n\nvec3 iris(vec2 p) {\n  const vec3 up  = vec3(0.0, 1.0, 0.0);\n  const vec3 lp1 = 1.0*vec3(1.0, 1.25, 1.0);\n  const vec3 lp2 = 1.0*vec3(-1.0, 2.5, 1.0);\n\n  compute_globals();\n\n  vec3 ro = vec3(0.0, 10.0, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec2 v;\n  vec2 w;\n \n  float h  = warp(p, v, w);\n  float hf = g_hf;\n  vec3  n  = normal(p);\n\n  const vec3 lcol1 = HSV2RGB(vec3(0.7, 0.5, 1.0)); \n  const vec3 lcol2 = HSV2RGB(vec3(0.4, 0.5, 1.0));\n  vec3 po  = vec3(p.x, 0.0, p.y);\n  vec3 rd  = normalize(po - ro);\n  \n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3  ref   = reflect(rd, n);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n \n  float a = length(p);\n  vec3 col = vec3(0.0);\n  col += hsv2rgb(vec3(fract(-0.1*TIME+0.125*a+0.5*v.x+0.125*w.x), abs(0.5+tanh_approx(v.y*w.y)), tanh_approx(0.1+abs(v.y-w.y))));\n  col += 0.5*lcol1*pow(ref1, 20.0);\n  col += 0.5*lcol2*pow(ref2, 10.0);\n  col *= hf;\n\n  return col;\n}\n\nvec3 render_iris(vec3 ro, vec3 rd, vec3 nrd) {\n  const vec4 plane = vec4(normalize(vec3(1.0, 0.3, 0.0)), -2.0);\n  const vec3 tnor  = plane.xyz;\n  const vec3 tup   = normalize(vec3(0.0, -1.0, 0.0));\n  const float aa   = 0.001;\n  float t = rayPlane(ro, rd, plane);\n  \n  vec3 tpos = ro + t*rd;\n  vec3 txx = normalize(cross(tnor, tup));\n  vec3 tyy = normalize(cross(tnor, txx));\n  \n  vec2 tpos2 = vec2(dot(txx, tpos), dot(tyy, tpos));\n  \n  vec3 col = iris(tpos2);\n  \n  return col;\n}\n\nvec3 df(vec2 p) {\n  const float iris_outer = 0.622;\n  const float iris_inner = 0.285;\n  \n  float a  = mix(0.0, 1.0, smoothstep(0.995, 1.0, cos(TTIME/PERIOD)));\n  const float w = 1.14;\n  float h = mix(0.48, 0.05, a);\n  \n  float t0 = abs(0.9*p.x);\n  t0 *= t0;\n  t0 *= t0;\n  t0 *= t0;\n  t0 = clamp(t0, 0.0, 1.0);\n  float dt0 = mix(0.0125, -0.0025, t0);\n\n  vec2 p0 = p;\n  float d0 =  vesica(p0, vec2(w, h));\n  float d5 = d0;\n\n  vec2 p1 = p;\n  p1 -= iris_center;\n  float d1 = circle(p1, iris_outer);\n  d1 = max(d1,d0+dt0);\n  float d6 = d1;\n\n  vec2 p2 = p;\n  p2 -= vec2(-0.155, 0.35);\n  float d2 = circle(p2, 0.065);\n\n  vec2 p3 = p;\n  p3 -= iris_center;\n  p3 = toPolar(p3);\n  float n3 = mod1(p3.x, 0.05);\n  float d3 = abs(p3.x)-0.0125*(1.0-1.0*length(p1));\n\n  vec2 p4 = p;\n  p4 -= iris_center;\n  float d4 = circle(p4, iris_inner);\n\n  d3 = max(d3,-d4);\n\n  d1 = pmax(d1,-d2, 0.0125);\n  d1 = max(d1,-d3);\n\n  d0 = abs(d0)-dt0;\n\n\n  float d = d0;\n  d = pmin(d, d1, 0.0125);\n  return vec3(d, d6, d5);\n}\n\nvec3 render_background(vec3 ro, vec3 rd, vec3 nrd) {\n  rd.xy *= ROT(-PI/2.0+0.6);\n  vec3 srd = toSpherical(rd.xzy);\n  srd.z += 0.025*TIME;\n  vec2 pg  = srd.yz;\n  float f  = sin(pg.x); \n  float lf2= ceil(log(f)/log(2.0)-0.505);\n  float mf = pow(2.0, lf2);\n\n  const float aa = 0.005;\n  const float count = 20.0;\n  const vec2 sz = vec2(2.0*PI/count);\n  vec2 ng = mod2(pg, vec2(mf, 1.0)*sz);\n\n  float dg = min(abs(pg.y)*f, abs(pg.x))-aa*0.0;\n  vec3 lines = grid_color*smoothstep(-aa, aa, -dg)*f*f;\n\n  vec3 sky  = smoothstep(1.0, 0.0, rd.y)*sky1_color+smoothstep(0.5, 0.0, rd.y)*sky0_color;\n\n  vec2 pi = raySphere(ro, rd, planet_sph);\n\n  float lf1 = 1.0;\n  if (pi.x > 0.0) {\n    vec3 ppos = ro+rd*pi.x;\n    float t = 1.0-tanh_approx(1.5*(pi.y - pi.x)/planet_sph.w);\n    sky *= mix(0.5, 1.0, t);\n    lf1 = t;\n  } else {\n    sky += lines;\n  }\n\n  sky += pow(max(dot(rd, light0_dir), 0.0), 800.0)*light0_color; \n  sky += pow(max(dot(rd, light0_dir), 0.0), 80.0)*light1_color*0.1; \n  sky += lf1*pow(max(dot(rd, light1_dir), 0.0), 150.0)*light1_color; \n  sky += lf1*pow(max(dot(rd, light1_dir), 0.0), 50.0)*light0_color*0.1; \n\n\n  return sky;\n}\n\nvec4 render_body(vec2 p, vec2 q, vec3 dd) {\n//  p -= iris_center;\n  float aa = 2.0/RESOLUTION.y;\n  \n  float a = smoothstep(-aa, aa, -dd.z);\n  float b = smoothstep(0.0, mix(0.075, 0.0025, smoothstep(0.5, 1., abs(p.x))), -dd.z);\n  float c = smoothstep(-aa, aa, -dd.y);\n  float d = smoothstep(0.00, 0.1, -dd.y);\n  \n  //vec3 ro = vec3(1.5, 1.9, -1.85);\n  vec3 ro = vec3(2.0, 0.0, 0.0);\n//  ro.xz *= ROT(TIME);\n  vec3 la = vec3(0.0, 0.0, 0.0); \n\n  vec2 np   = p + vec2(4.0/RESOLUTION.y); \n\n  vec3 ww   = normalize(la - ro);\n  vec3 uu   = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv   = normalize(cross(ww,uu));\n  float rdd = 2.0;\n  vec3 rd   = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd  = normalize(np.x*uu + np.y*vv + rdd*ww);\n  \n  vec4 sph  = vec4(vec3(0.0), 1.0);\n  \n  vec2 si   = raySphere(ro, rd, sph);\n  \n  vec3 pos  = ro + rd*si.x;\n  \n  vec3 nor  = normalize(pos - sph.xyz);\n  \n  vec3 ref  = reflect(rd, nor); \n  vec3 nref = reflect(nrd, nor); \n\n  vec3 refr = refract(rd, nor, 0.9); \n  vec3 nrefr= refract(nrd, nor, 0.9); \n\n  vec3 rbkg = render_background(pos, ref, nref);\n\n  vec3 col = vec3(0.0);\n  col += rbkg;\n  if (d > 0.0) {\n    vec3 riris= render_iris(pos, ref, nref);\n    col += riris*d;\n  }\n  \n  col += mix(vec3(0.0), vec3(0.75), 1.0-c); \n  col.xyz*=b;\n  \n  return vec4(col, a);\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float aa = 2.0/RESOLUTION.y;\n  vec3 d   = df(p);\n\n  vec4 dcol = vec4(0.0, 0.0, 0.0, 0.5);\n  dcol.w    = mix(0.0, 0.95, smoothstep(-aa, aa, -d.x));\n  vec4 scol = render_body(p, q, d); \n  \n  vec3 col  = vec3(1.0);\n  col = alphaBlend(col, dcol);\n#ifdef VARIANT  \n  if (fract(TIME/(2.0*PERIOD)) >= 0.5) {\n    col = alphaBlend(col, scol);\n  }\n#else\n  col = alphaBlend(col, scol);\n#endif\n  return col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n\n  vec3 col = effect(p, q);\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXXDr.jpg", "access": "api", "license": "cc0-1.0", "functions": [[627, 627, 649, 649, 795], [1711, 1711, 1751, 1751, 1910], [1912, 1912, 1952, 1952, 1994], [1996, 1996, 2032, 2032, 2265], [2267, 2267, 2298, 2298, 2324], [2326, 2377, 2408, 2408, 2706], [2708, 2783, 2827, 2827, 3024], [3026, 3101, 3143, 3143, 3190], [3192, 3192, 3220, 3240, 3316], [3318, 3318, 3340, 3340, 3384], [3386, 3386, 3407, 3407, 3448], [3450, 3450, 3476, 3476, 3585], [3587, 3587, 3608, 3608, 3677], [3679, 3711, 3750, 3750, 3875], [3877, 3909, 3945, 3945, 4039], [4041, 4081, 4120, 4120, 4209], [4211, 4211, 4250, 4250, 4279], [4281, 4281, 4311, 4311, 4339], [4384, 4384, 4405, 4405, 4527], [4529, 4568, 4597, 4597, 4849], [4851, 4891, 4935, 4935, 5468], [5470, 5470, 5491, 5491, 5713], [5715, 5715, 5739, 5739, 6019], [6021, 6021, 6040, 6040, 7072], [7074, 7074, 7120, 7120, 7552], [7554, 7554, 7571, 7571, 8543], [8545, 8545, 8597, 8597, 9677], [9679, 9679, 9722, 9744, 10982], [10984, 10984, 11013, 11013, 11413], [11416, 11416, 11471, 11471, 11689]], "test": "error"}
{"id": "flfXDn", "name": "Retro cube effect with twist", "author": "mrange", "description": "License CC0: Retro cube effect with twist\nWe made a retro demo some time ago and wanted a version of the classic Amiga effect:\nMusic: Hyperbased by Firefox: https://soundcloud.com/firefox-amigamus", "tags": ["3d", "raymarch", "retro"], "likes": 31, "viewed": 699, "published": 3, "date": "1625421836", "time_retrieved": "2024-07-30T19:12:16.077220", "image_code": "// License CC0: Retro cube effect with twist\n//  We made a retro demo some time ago and in one of the effects\n//  We wanted to recreate the classic \"Amiga Cube that intersects a translucent plane\"\n//  But having accesss to a few more Teraflops than the Amiga we wanted to add a bit of a twist to it\n//  Music: Hyperbased by Firefox: https://soundcloud.com/firefox-amigamusician/hyperbased\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            (iTime+155.0)\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(a)         (0.5+0.5*cos(a))\n#define PSIN(a)         (0.5+0.5*sin(a))\n#define L2(x)           dot(x, x)\n#define SCA(a)          vec2(sin(a), cos(a))\n#define MISS            1E6\n#define BTIME(n)        (n*beat+start)\n\n#define CUBE_TOLERANCE       0.0001\n#define CUBE_MAX_RAY_LENGTH  8.0\n#define CUBE_MAX_RAY_MARCHES 80\n#define CUBE_NORM_OFF        0.0005\n\nconst float beat            = 0.48;\nconst float start           = 41.1;\nconst float bounce_freq     = 0.5/beat;\n\nconst mat2 rot0             = ROT(0.00);\nconst vec3 std_gamma        = vec3(2.2);\n\nconst float cube_begin      = BTIME(240.0); // ~156\nconst float cube_flash0     = BTIME(334.0);\nconst float cube_flash1     = BTIME(335.0);\nconst float cube_end        = BTIME(336.0);\n\n// GLOBAL MUTABLES\n\nvec4  cube_g_plane       = vec4(normalize(vec3(1.0, 0.0, 0.0)), 0.0);\nfloat cube_g_pw          = 0.0;\nmat2 cube_g_rotxy        = rot0;\nmat2 cube_g_rotxz        = rot0;\nmat2 cube_g_rotxw        = rot0;\nmat2 cube_g_rotyw        = rot0;\nmat2 cube_g_rotzw        = rot0;\n\n\n// -----------------------------------------------------------------------------\n// COMMON\n// -----------------------------------------------------------------------------\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat plane(vec3 p, vec4 plane) {\n  return dot(plane.xyz, p)+plane.w;\n}\n\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat box(vec4 p, vec4 b) {\n  vec4 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(max(q.x, q.w),max(q.y,q.z)),0.0);\n}\n\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Classic post processing\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/std_gamma);\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\n// -----------------------------------------------------------------------------\n// CUBE\n// -----------------------------------------------------------------------------\n\nvec2 cube_mengerSponge(vec4 p) {\n  float db = box(p, vec4(1.0));\n  if(db > .125) vec2(db, db);\n\n  float d_ = db;\n  float res = d_;\n\n  float s = 1.0;\n  for(int m = 0; m < 4; ++m) {\n    float ss = 0.75;\n    vec4 a = mod(p*s, 2.0)-1.0;\n    s *= 3.0;\n    vec4 r = abs(1.0 - 3.0*abs(a));\n\n    float da = max(max(r.x,r.y),r.w);\n    float db = max(max(r.y,r.z),r.w);\n    float dc = max(max(r.z,r.x),r.w);\n    float dd = max(max(r.z,r.x),r.y);\n    float df = length(r)-2.16;\n\n    float du = da;\n    du = min(du, db);\n    du = min(du, dc);\n    du = pmin(du, dd, ss); // Soften the edges a bit\n    du = max(du, -df);\n    du -= 1.0;\n    du /= s;\n\n    res = max(res, du);\n  }\n\n  return vec2(db, res);\n}\n\nfloat cube_intersectTransformPlane(vec3 ro, vec3 rd) {\n  return rayPlane(ro, rd, cube_g_plane);\n}\n\nfloat cube_dtransformPlane(vec3 p) {\n  return plane(p, cube_g_plane);\n}\n\nfloat cube_df(vec3 p) {\n  float dp = cube_dtransformPlane(p);\n  const float s = 1.0/3.0;\n  p /= s;\n  p.xy *= cube_g_rotxy;\n  p.xz *= cube_g_rotxz;\n  vec4 pp = vec4(p, cube_g_pw);\n  pp.xw *= cube_g_rotxw;\n  pp.yw *= cube_g_rotyw;\n  pp.zw *= cube_g_rotzw;\n\n  // TODO: Optimize\n  vec2 dms = cube_mengerSponge(pp);\n\n  float d0 = dms.x*s;\n  float d2 = d0;\n  d0 = max(dp, d0);\n\n  float d1 = dms.y*s;\n  d1 = max(-dp, d1);\n  return max(d2, pmin(d0, d1, 0.05));\n}\n\nfloat cube_rayMarch(vec3 ro, vec3 rd, out int iter) {\n  float t = 0.0;\n  int i = 0;\n  for (i = 0; i < CUBE_MAX_RAY_MARCHES; i++) {\n    float d = cube_df(ro + rd*t);\n    if (d < CUBE_TOLERANCE || t > CUBE_MAX_RAY_LENGTH) break;\n    t += d;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 cube_normal(vec3 pos) {\n  vec2  eps = vec2(CUBE_NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = cube_df(pos+eps.xyy) - cube_df(pos-eps.xyy);\n  nor.y = cube_df(pos+eps.yxy) - cube_df(pos-eps.yxy);\n  nor.z = cube_df(pos+eps.yyx) - cube_df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat cube_softShadow(vec3 pos, vec3 ld, float ll, float mint, float k) {\n  const float minShadow = 0.25;\n  float res = 1.0;\n  float t = mint;\n  for (int i=0; i<24; i++) {\n    float d = cube_df(pos + ld*t);\n    res = min(res, k*d/t);\n    if (ll <= t) break;\n    if(res <= minShadow) break;\n    t += max(mint*0.2, d);\n  }\n  return clamp(res,minShadow,1.0);\n}\n\nvec3 cube_transformPlane(vec3 ro, vec3 rd, vec4 plane, out float ttp) {\n  vec3 tnor = plane.xyz;\n  float t = rayPlane(ro, rd, plane);\n  ttp = t;\n  if (t < 0.0) return vec3(0.0);\n  vec3 tp = ro + t*rd;\n  float td = cube_df(tp);\n  td -= 0.025;\n  float otd = td;\n  td = abs(td)- 0.005;\n  const vec3 tup = vec3(0.0, 1.0, 0.0);\n  vec3 txx = normalize(cross(tnor, tup));\n  vec3 tyy = (cross(tnor, txx));\n  vec2 tp2 = vec2(dot(txx, tp), dot(tyy, tp));\n  float a  = mix(0.0, PI/4.0 + 0.5*(TIME-BTIME(288.0)), smoothstep(BTIME(288.0), BTIME(292.0), TIME));\n  tp2 *= ROT(a);\n  float tpd = box(tp2, 0.6*vec2(4.0/3.0, 1.0));\n  float taa = 0.001;\n  mod2(tp2, vec2(0.125));\n  float tpgd = min(abs(tp2.x), abs(tp2.y));\n  tpgd = max(tpgd, -otd);\n  tpgd = max(tpgd, tpd);\n  float tgd = tpd;\n  tgd -= 0.0125;\n  tgd = abs(tgd)- 0.005;\n  tgd = min(tgd, td);\n\n  const vec3 greenGlow = vec3(1.25, 2.0, 1.25);\n  const vec3 redGlow = vec3(2.0, 1.25, 1.5);\n  vec3 tcol = vec3(0.0125);\n  tcol += greenGlow*exp(-max(tpgd, 0.0)*900.0);\n  tcol += greenGlow*(1.0-abs(dot(rd, tnor)))*0.2*PSIN(500.*tp2.y);\n  tcol = mix(vec3(0.0), tcol, smoothstep(-taa, taa, -(tpd-0.025)));\n  tcol += redGlow*exp(-max(tgd, 0.0)*100.0);\n  return tcol;\n}\n\nvec3 cube_render(in vec3 ro, in vec3 rd) {\n  vec3 lightPos = 2.0*vec3(1.5, 3.0, 1.0);\n\n  float alpha   = 0.05*TIME;\n  vec3 tnor     = normalize(vec3(1.0, 0.0, 0.0));\n  tnor.xy       *= ROT(PI*(1.0-cos(sqrt(0.3)*max(TIME-BTIME(296.0), 0.0))));\n  tnor.xz       *= ROT(PI*(1.0-cos(sqrt(0.15)*max(TIME-BTIME(304.0), 0.0))));\n\n  float tm      = -0.5*(cos((2.0*TAU/(4.0/beat))*max(TIME-BTIME(292.0), 0.0)));\n  tm  = mix(0.75 , tm, smoothstep(BTIME(272.0), BTIME(288.0), TIME));\n  tm  = mix(-0.75, tm, smoothstep(BTIME(248.0), BTIME(272.0), TIME));\n  tm  = mix(-3.0 , tm, smoothstep(BTIME(244.0), BTIME(248.0), TIME));\n\n  vec4 plane    = vec4(tnor, tm);\n\n  cube_g_plane       = plane;\n  cube_g_rotxy       = ROT(TIME);\n  cube_g_rotxz       = ROT(TIME*sqrt(0.5));\n  cube_g_pw          = 0.5*cos(alpha*sqrt(2.0));\n  cube_g_rotxw       = ROT(alpha);\n  cube_g_rotyw       = ROT(alpha*sqrt(0.5));\n  cube_g_rotzw       = ROT(alpha*sqrt(2.0));\n\n//  tnor.xy *= g_rotxy;\n  // background color\n  vec3 skyCol = vec3(0.0);\n\n  int iter = 0;\n  float t = cube_rayMarch(ro, rd, iter);\n  float tp;\n  vec3 tcol = cube_transformPlane(ro, rd, plane, tp);\n  tcol = mix(vec3(0.0), tcol, float(tp < t));\n\n  float ifade = 1.0-tanh_approx(2.0*float(iter)/float(CUBE_MAX_RAY_MARCHES));\n\n  vec3 pos = ro + t*rd;\n  vec3 nor = vec3(0.0, 1.0, 0.0);\n\n  vec3 color = vec3(0.0);\n\n  float dp   = -(ro.y+1.)/rd.y;\n\n  if (dp > 0.0 && dp < t) {\n    // Ray intersected plane\n    t   = dp;\n    pos = ro + t*rd;\n    nor = vec3(0.0, 1.0, 0.0);\n    vec2 pp = pos.xz*1.5;\n    float m = 0.5+0.25*(sin(3.0*pp.x+TIME*2.1)+sin(3.3*pp.y+TIME*2.0));\n    m *= m;\n    m *= m;\n    pp = fract(pp+0.5)-0.5;\n    float dp = pmin(abs(pp.x), abs(pp.y), 0.025);\n    vec3 hsv = vec3(0.4+mix(0.15,0.0, m), tanh_approx(mix(100.0, 10.0, m)*dp), 1.0);\n    color = 2.5*hsv2rgb(hsv)*exp(-mix(30.0, 10.0, m)*dp);\n  } else if (t < CUBE_MAX_RAY_LENGTH) {\n    // Ray intersected object\n    nor        = cube_normal(pos);\n    vec3 hsv   = (vec3(-0.2+0.25*t, 1.0-ifade, 1.0));\n    color = hsv2rgb(hsv);\n  } else {\n    // Ray intersected sky\n    return (skyCol)*ifade+tcol;\n  }\n\n  vec3 lv   = lightPos - pos;\n  float ll2 = dot(lv, lv);\n  float ll  = sqrt(ll2);\n  vec3 ld   = lv / ll;\n  float sha = cube_softShadow(pos, ld, ll, 0.01, 64.0);\n\n  float dm  = min(1.0, 40.0/ll2);\n  float dif = max(dot(nor,ld),0.0)*dm;\n  float spe = pow(max(dot(reflect(-ld, nor), -rd), 0.), 10.);\n  float l   = dif*sha;\n\n  float lin = mix(0.2, 1.0, l);\n\n  vec3 col = lin*color + spe*sha;\n\n  float f = exp(-20.0*(max(t-3.0, 0.0) / CUBE_MAX_RAY_LENGTH));\n\n  return (mix(skyCol, col , f))*ifade+tcol;\n}\n\nvec3 cube_effect(vec2 p, vec2 q) {\n  float m = smoothstep(BTIME(264.0), BTIME(272.0), TIME);\n  float tm = TIME-BTIME(264.0);\n  // camera\n  vec3 ro = mix(1.0, 0.6, m)*vec3(2.0, 0, 0.2)+vec3(0.0, 0.25, 0.0);\n  ro.xz *= ROT(mix(0.0, tm*0.25, m));\n  ro.yz *= ROT(-(1.0-PCOS(tm*0.25*sqrt(0.5)))*0.25);\n  vec3 ww = normalize(vec3(0.0, 0.0, 0.0) - ro);\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n  return cube_render(ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = cube_effect(p, q);\n\n  col = postProcess(col, q);\n  col = mix(vec3(1.0), col, smoothstep(cube_begin+0.25, cube_begin+1.5, TIME));\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 27716, "src": "https://soundcloud.com/firefox-amigamusician/hyperbased", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flfXDn.jpg", "access": "api", "license": "cc0-1.0", "functions": [[1805, 1805, 1844, 1844, 1933], [1935, 1935, 1977, 1977, 2024], [2026, 2026, 2054, 2074, 2150], [2152, 2152, 2185, 2185, 2223], [2225, 2225, 2252, 2252, 2328], [2330, 2330, 2357, 2357, 2454], [2456, 2456, 2492, 2492, 2586], [2588, 2588, 2610, 2610, 2779], [2781, 2808, 2844, 2844, 3077], [3250, 3250, 3282, 3282, 3940], [3942, 3942, 3996, 3996, 4039], [4041, 4041, 4077, 4077, 4112], [4114, 4114, 4137, 4137, 4568], [4570, 4570, 4623, 4623, 4838], [4840, 4840, 4868, 4868, 5111], [5113, 5113, 5186, 5186, 5470], [5472, 5472, 5543, 5543, 6676], [6678, 6678, 6720, 6720, 9276], [9278, 9278, 9312, 9312, 9799], [9801, 9801, 9856, 9856, 10129]], "test": "untested"}
{"id": "NtfSDn", "name": "Variant of IQ's Vesica", "author": "mrange", "description": "Variant of IQ's vesica: https://www.shadertoy.com/view/XtVfRW\nI wanted to be able to specify the dimensions of the vesica object\nso modified the function slightly", "tags": ["2d"], "likes": 7, "viewed": 346, "published": 3, "date": "1625417159", "time_retrieved": "2024-07-30T19:12:16.930938", "image_code": "#define TIME       iTime\n#define RESOLUTION iResolution\n\n// IQ's box used as reference\nfloat box(vec2 p, vec2 b) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// Variant of IQ's vesica: https://www.shadertoy.com/view/XtVfRW\n// I wanted to be able to specify the dimensions of the vesica object\n//  so modified the function slightly\nfloat vesica(vec2 p, vec2 sz) {\n  if (sz.x < sz.y) {\n    sz = sz.yx;\n  } else {\n    p  = p.yx; \n  }\n  vec2 sz2 = sz*sz;\n  float d  = (sz2.x-sz2.y)/(2.0*sz.y);\n  float r  = sqrt(sz2.x+d*d);\n  float b  = sz.x;\n  p = abs(p);\n  return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                           : length(p-vec2(-d,0.0))-r;\n}\n\nfloat df(vec2 p) {\n  vec2 sz = vec2(mix(1.0, 2.0, 0.5+0.5*cos(TIME*sqrt(0.5))), mix(1.0, 2.0, 0.5+0.5*sin(TIME)));\n  float d0 = vesica(p, sz*0.5);\n  float d1 = box(p, sz*0.5);\n  d1 = abs(d1) - 0.01;\n  float d = d0;\n  if (mod(floor(TIME), 2.0) == 0.0) {\n    d = min(d0, d1);\n  }\n  return d;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n\n  float d = df(p);\n  \n  vec3 col = vec3(0.1);\n  \n  col = mix(col, vec3(0.9), smoothstep(-aa, aa, -d));\n  col += vec3(1.0, 0.0, 0.0)*sin(100.0*d);\n\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtfSDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 87, 114, 114, 194], [196, 369, 400, 400, 698], [700, 700, 718, 718, 991], [994, 994, 1049, 1049, 1357]], "test": "untested"}
{"id": "NtfXWn", "name": "Basic Ray Marching Mandelbulb", "author": "MerlinSleeps", "description": "Basic Ray Marching Mandelbulb.\n\nStill learning^^", "tags": ["raymarching", "mandelbulb"], "likes": 1, "viewed": 337, "published": 3, "date": "1625413588", "time_retrieved": "2024-07-30T19:12:17.781663", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat sdMandelbulb(vec3 pos) {\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 255; i++) {\n\t\tr = length(z);\n\t\tif (r>4.) break;\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, 8.)*8.*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,8.);\n\t\ttheta = theta*8.;\n\t\tphi = phi*8.;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr *vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\nfloat GetDist(vec3 p) {\n\n    float mb = sdMandelbulb(p);\n    float box = sdBox(p, vec3(1));\n    \n    \n    float d = max(box, mb);\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Transform(vec3 p) {\n    p.xy *= Rot(p.z*.15);\n\tp.z -= iTime*.1;\n    p.y -= .3;\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        p = Transform(p);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif) * vec3(0.1, 0.4, 0.7);\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtfXWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 125, 125, 187], [189, 189, 218, 218, 299], [302, 302, 332, 332, 826], [828, 828, 851, 851, 978], [980, 980, 1014, 1014, 1225], [1227, 1227, 1251, 1251, 1441], [1443, 1443, 1493, 1493, 1684], [1686, 1686, 1710, 1710, 1785], [1787, 1787, 1844, 1844, 2500]], "test": "untested"}
{"id": "stlXzM", "name": "Spherical iris", "author": "mrange", "description": "License CC0: Spherical iris\nResult of more tinkering around eye designs", "tags": ["2d"], "likes": 7, "viewed": 316, "published": 3, "date": "1625395615", "time_retrieved": "2024-07-30T19:12:18.823877", "image_code": "#define PI            3.141592654\n#define TAU           (2.0*PI)\n#define TIME          iTime\n#define RESOLUTION    iResolution\n\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\n// Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst vec3  grid_color    = HSV2RGB(vec3(0.6, 0.3, 1.0)); \nconst vec3  light0_color  = 16.0*HSV2RGB(vec3(0.6, 0.5, 1.0)); \nconst vec3  light1_color  = 8.0*HSV2RGB(vec3(0.9, 0.25, 1.0)); \nconst vec3  sky0_color    = HSV2RGB(vec3(0.05, 0.65, -0.25)); \nconst vec3  sky1_color    = HSV2RGB(vec3(0.6, 0.5, 0.25)); \nconst vec3  light0_pos    = vec3(5.0, 4.0, 4.0);\nconst vec3  light1_pos    = vec3(3.0, -1.0, -8.0);\nconst vec3  light0_dir    = normalize(light0_pos);\nconst vec3  light1_dir    = normalize(light1_pos);\nconst vec4  planet_sph    = vec4(50.0*normalize(light1_dir+vec3(0.025, -0.025, 0.0)), 10.0);\nconst vec2   iris_center  = vec2(0.0, 0.28);\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, vec3(1.0/2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat vesica(vec2 p, float r, float d) {\n  p = abs(p);\n  float b = sqrt(r*r-d*d);\n  return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                           : length(p-vec2(-d,0.0))-r;\n}\n\n// IQ's ray sphere intersect: https://iquilezles.org/articles/intersectors\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sph) {\n  vec3 oc = ro - sph.xyz;\n  float b = dot( oc, rd );\n  float c = dot( oc, oc ) - sph.w*sph.w;\n  float h = b*b - c;\n  if (h < 0.0) return vec2(-1.0);\n  h = sqrt(h);\n  return vec2(-b - h, -b + h);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec3 toSpherical(vec3 p) {\n  float r   = length(p);\n  float t   = acos(p.z/r);\n  float ph  = atan(p.y, p.x);\n  return vec3(r, t, ph);\n}\n\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nvec2 df(vec2 p) {\n  const float iris_outer = 0.622;\n  const float iris_inner = 0.285;\n  \n  float a  = mix(0.0, 0.85, smoothstep(0.995, 1.0, cos(TAU*TIME/5.0)));\n  const float b = 4.0;\n  float rr = mix(1.6, b, a);\n  float dd = mix(1.12, b, a);\n  \n  float t0 = abs(0.9*p.x);\n  t0 *= t0;\n  t0 *= t0;\n  t0 *= t0;\n  t0 = clamp(t0, 0.0, 1.0);\n  float dt0 = mix(0.0125, -0.0025, t0);\n\n  vec2 p0 = p;\n  p0 = p0.yx;\n  float d0 =  vesica(p0, rr, dd);\n  float d5 = d0;\n\n  vec2 p1 = p;\n  p1 -= iris_center;\n  float d1 = circle(p1, iris_outer);\n  d1 = max(d1,d0+dt0);\n  float d6 = d1;\n\n  vec2 p2 = p;\n  p2 -= vec2(-0.155, 0.35);\n  float d2 = circle(p2, 0.065);\n\n  vec2 p3 = p;\n  p3 -= iris_center;\n  p3 = toPolar(p3);\n  float n3 = mod1(p3.x, 0.05);\n  float d3 = abs(p3.x)-0.0125*(1.0-1.0*length(p1));\n\n  vec2 p4 = p;\n  p4 -= iris_center;\n  float d4 = circle(p4, iris_inner);\n\n  d3 = max(d3,-d4);\n\n  d1 = pmax(d1,-d2, 0.0125);\n  d1 = max(d1,-d3);\n\n  d0 = abs(d0)-dt0;\n\n  float d = d0;\n  d = pmin(d, d1, 0.0125);\n  return vec2(d, d6);\n}\n\nvec3 render_background(vec3 ro, vec3 rd, vec3 nrd) {\n  vec3 srd = toSpherical(rd.xzy);\n  srd.z += 0.02*TIME;\n  vec2 pg  = srd.yz;\n  float f  = sin(pg.x); \n  float lf2= ceil(log(f)/log(2.0)-0.505);\n  float mf = pow(2.0, lf2);\n\n  const float aa = 0.005;\n  const float count = 20.0;\n  const vec2 sz = vec2(2.0*PI/count);\n  vec2 ng = mod2(pg, vec2(mf, 1.0)*sz);\n\n  float dg = min(abs(pg.y)*f, abs(pg.x))-aa*0.0;\n  vec3 lines = grid_color*smoothstep(-aa, aa, -dg)*f*f;\n\n  vec3 sky  = smoothstep(1.0, 0.0, rd.y)*sky1_color+smoothstep(0.5, 0.0, rd.y)*sky0_color;\n\n  vec2 pi = raySphere(ro, rd, planet_sph);\n\n  float lf1 = 1.0;\n  if (pi.x > 0.0) {\n    vec3 ppos = ro+rd*pi.x;\n    float t = 1.0-tanh_approx(1.5*(pi.y - pi.x)/planet_sph.w);\n    sky *= mix(0.5, 1.0, t);\n    lf1 = t;\n  } else {\n    sky += lines;\n  }\n\n  sky += pow(max(dot(rd, light0_dir), 0.0), 800.0)*light0_color; \n  sky += pow(max(dot(rd, light0_dir), 0.0), 80.0)*light1_color*0.1; \n  sky += lf1*pow(max(dot(rd, light1_dir), 0.0), 150.0)*light1_color; \n  sky += lf1*pow(max(dot(rd, light1_dir), 0.0), 50.0)*light0_color*0.1; \n\n\n  return sky;\n}\n\nvec4 render_iris(vec2 p, vec2 q, float d) {\n  p -= iris_center;\n  float aa = 2.0/RESOLUTION.y;\n  \n  float a = smoothstep(-aa, aa, -d);\n  float b = smoothstep(0.0, 0.125, -d);\n  \n  vec3 ro = 1.0*vec3(2.0, 4.0, -1.0);\n  vec3 la = vec3(0.0, 0.0, 0.0); \n\n  vec2 np   = p + vec2(4.0/RESOLUTION.y); \n\n  vec3 ww   = normalize(la - ro);\n  vec3 uu   = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv   = normalize(cross(ww,uu));\n  float rdd = 2.0;\n  vec3 rd   = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd  = normalize(np.x*uu + np.y*vv + rdd*ww);\n  \n  vec4 sph  = vec4(vec3(0.0), 1.78);\n  \n  vec2 si   = raySphere(ro, rd, sph);\n  \n  vec3 pos  = ro + rd*si.x;\n  \n  vec3 nor  = normalize(pos - sph.xyz);\n  \n  vec3 ref  = reflect(rd, nor); \n  vec3 nref = reflect(nrd, nor); \n\n  vec3 rbkg = render_background(pos, ref, nref); \n\n  vec4 col = vec4(rbkg, 1.0);\n  \n  col.xyz*=b;\n  col.w = a;\n  \n  \n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float aa = 2.0/RESOLUTION.y;\n  vec2 d   = df(p);\n\n  vec4 dcol = vec4(0.0, 0.0, 0.0, 0.5);\n  dcol.w    = mix(0.0, 0.95, smoothstep(-aa, aa, -d.x));\n  vec4 scol = render_iris(p, q, d.y); \n  \n  vec3 col  = vec3(1.0);\n  col = alphaBlend(col, dcol);\n  col = alphaBlend(col, scol);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n\n  vec3 col = effect(p, q);\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stlXzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1121, 1121, 1149, 1169, 1245], [1247, 1247, 1287, 1287, 1329], [1331, 1331, 1367, 1367, 1600], [1602, 1602, 1633, 1633, 1659], [1661, 1661, 1701, 1701, 1850], [1852, 1927, 1971, 1971, 2168], [2170, 2170, 2192, 2192, 2236], [2238, 2238, 2264, 2264, 2373], [2375, 2375, 2414, 2414, 2539], [2541, 2541, 2577, 2577, 2671], [2673, 2673, 2712, 2712, 2801], [2803, 2803, 2842, 2842, 2871], [2873, 2873, 2890, 2890, 3894], [3896, 3896, 3948, 3948, 4998], [5000, 5000, 5043, 5043, 5904], [5906, 5906, 5935, 5935, 6229], [6231, 6231, 6286, 6286, 6504]], "test": "untested"}
{"id": "stlSzM", "name": "framecounter", "author": "schobbejack", "description": "display hh:mm:ss:ff based on system clock", "tags": ["counter", "framecounter"], "likes": 2, "viewed": 370, "published": 3, "date": "1625389945", "time_retrieved": "2024-07-30T19:12:19.693551", "image_code": "int bcd(int i) // 0 - 99\n{\n    return (i/10*6+i);\n}\n\nfloat digit(vec2 uv, int i)\n{\n    const float doff=12./16.;\n    \n    return texture(iChannel0,uv/16.+vec2(float(i)/16.,doff)).x;\n}\n\nvoid draw_digit(inout float c, vec2 uv, int i)\n{\n    if(abs(uv.x)<.5 && abs(uv.y) < .5)\n    {\n        c = max(c,digit(uv+.5,i));\n    }\n}\n\nvoid draw_bcd(inout float c, vec2 uv, int i)\n{\n    draw_digit(c, uv,(i&0xf0)>>4);\n    draw_digit(c, uv-vec2(.5,0),(i&0xf));\n}\n\n#define FRAME_RATE 50.\n\n\nfloat draw_time(vec2 uv, vec2 o, float size)\n{\n    float c = 0.;\n    uv=(uv-o)/size - vec2(.25,-.5);\n    \n    int hour = bcd(int(iDate.w/3600.));\n    int minute = bcd(int(mod(iDate.w,3600.)/60.));\n    int second = bcd(int(mod(iDate.w,60.)));\n    \n    int pal_frame = bcd(int(fract(iDate.w)*FRAME_RATE));\n\n    draw_bcd(c,uv,hour);\n    uv.x-=.85;\n    draw_digit(c,uv,10);\n    uv.x-=.35;\n    draw_bcd(c,uv,minute);\n    uv.x-=.85;\n    draw_digit(c,uv,10);\n    uv.x-=.35;\n    draw_bcd(c,uv,second);\n    uv.x-=.85;\n    draw_digit(c,uv,10);\n    uv.x-=.35;\n    draw_bcd(c,uv,pal_frame);\n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 col=mix(vec3(0),vec3(1),draw_time(uv,vec2(-.65,0.125),.3+sin(iTime)*.01));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stlSzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 51], [53, 53, 82, 82, 183], [185, 185, 233, 233, 321], [323, 323, 369, 369, 448], [475, 475, 521, 521, 1069], [1072, 1072, 1129, 1129, 1307]], "test": "untested"}
{"id": "slsXRM", "name": "Linear Best Fit", "author": "oneshade", "description": "Analytical solution to the best linear fit of a set of points. I'm planning to extend this to continuous curves (bezier curves in particular).", "tags": ["2d", "linear", "regression", "fitting"], "likes": 9, "viewed": 216, "published": 3, "date": "1625388988", "time_retrieved": "2024-07-30T19:12:20.513359", "image_code": "// Desmos graph: https://www.desmos.com/calculator/rpdsgju4tl\n\n// Utilities\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\n// Number of points\n#define N 50\n\n// Minimizing Σ(p[n].y - (a*p[n].x + b))² wrt a and b\nvec2 bestFitLinear(in vec2[N] p) {\n    vec4 w = vec4(0.0);\n    for (int n=0; n < N; n++) w += vec4(p[n], p[n] * p[n].xx);\n    float b = (w.y * w.z - w.x * w.w) / (float(N) * w.z - w.x * w.x);\n    return vec2((w.w - w.x * b) / w.z, b);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nvec2 getOffset(in float id) {\n    float freq = Hash11(id * 393.84 + 673.48) * 10.0 - 5.0;\n    float phase = Hash11(id * 348.46 + 183.37);\n    float amp = Hash11(id * 275.35 + 741.69);\n    float ang = iTime * freq + phase;\n    return vec2(cos(ang), sin(ang)) * amp;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Boilerplate\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    vec4 mouse = (abs(iMouse) - center.xyxy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n\n    // Default before user interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse = vec4(-2.0, cos(iTime), 2.0, sin(iTime));\n\n    // Grid\n    drawSDF(abs(mod(uv.x + 0.25, 0.5) - 0.25), vec3(0.0, 0.0, 1.0));\n    drawSDF(abs(mod(uv.y + 0.25, 0.5) - 0.25), vec3(0.0, 0.0, 1.0));\n    drawSDF(abs(uv.x), vec3(1.0, 0.0, 0.0));\n    drawSDF(abs(uv.y), vec3(1.0, 0.0, 0.0));\n\n    // Line drawn by the mouse\n    vec2 p1 = mouse.zw, p2 = mouse.xy;\n    float a = (p2.y - p1.y) / (p2.x - p1.x);\n    float b = p1.y - a * p1.x;\n\n    // Generate random points distributed on a line\n    vec2[N] points;\n    for (int n=0; n < N; n++) {\n        float x = float(n) / float(N) * 4.0 - 2.0;\n        points[n] = vec2(x, a * x + b) + getOffset(float(n));\n        drawSDF(length(uv - points[n]) - 0.05, vec3(0.0));\n    }\n\n    // Draw the mouse line\n    //drawSDF(abs(uv.y - (a * uv.x + b)) / sqrt(1.0 + a * a), vec3(0.0, 1.0, 0.0));\n\n    // Draw best linear fit\n    vec2 fit = bestFitLinear(points);\n    drawSDF(abs(uv.y - (fit.x * uv.x + fit.y)) / sqrt(1.0 + fit.x * fit.x), vec3(1.0, 0.0, 0.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slsXRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[485, 526, 552, 552, 638], [640, 640, 669, 669, 906]], "test": "untested"}
{"id": "fllSRM", "name": "neon ray", "author": "firebreathz", "description": "Applying some God rays, post process, to a simple raymarched scene. Inspired by Passion's \"Blue Dream\" ... and a lot of old demos. :)", "tags": ["raymarching", "blur", "radial", "godrays"], "likes": 3, "viewed": 476, "published": 3, "date": "1625344320", "time_retrieved": "2024-07-30T19:12:21.547594", "image_code": "/*\n\tFull Scene Radial Blur\n\t----------------------\n\n\tRadial blur - as a postprocessing effect - is one of the first things I considered doing \n\twhen the multipass system came out. I've always loved this effect. Reminds me of the early \n\tdemos from Aardbei et al. \n\n\tAnyway, Shadertoy user, Passion, did a really cool radial blur on a field of spheres that\n\tinspired me to do my own. Radial blurs are pretty straight forward, but it was still\n    helpful to have Passion's version as a guide. \n\n    As for the radial blur process, there's not much to it. Start off at the pixel position, \n    then radiate outwards gathering up pixels with decreased weighting. The result is a\n\tblurring of the image in a radial fashion, strangely enough. :)\n\n\tInspired by:\n\n\tBlue Dream - Passion\n\thttps://www.shadertoy.com/view/MdG3RD\n\n\tRadial Blur - IQ\n\thttps://www.shadertoy.com/view/4sfGRn\n\n\tRays of Blinding Light - mu6k\n\thttps://www.shadertoy.com/view/lsf3Dn\n\n*/\n\n// The radial blur section. Shadertoy user, Passion, did a good enough job, so I've used a\n// slightly trimmed down version of that. By the way, there are accumulative weighting \n// methods that do a slightly better job, but this method is good enough for this example.\n\n\n// Radial blur samples. More is always better, but there's frame rate to consider.\nconst float SAMPLES = 24.; \n\n\n// 2x1 hash. Used to jitter the samples.\nfloat hash( vec2 p ){ return fract(sin(dot(p, vec2(41, 289)))*45758.5453); }\n\n\n// Light offset.\n//\n// I realized, after a while, that determining the correct light position doesn't help, since \n// radial blur doesn't really look right unless its focus point is within the screen boundaries, \n// whereas the light is often out of frame. Therefore, I decided to go for something that at \n// least gives the feel of following the light. In this case, I normalized the light position \n// and rotated it in unison with the camera rotation. Hacky, for sure, but who's checking? :)\nvec3 lOff(){    \n    \n    vec2 u = sin(vec2(1.57, 0) - iTime/1.);\n    mat2 a = mat2(u, -u.y, u.x);\n    \n    vec3 l = normalize(vec3(1.5, 1., -0.5));\n    l.xz = a * l.xz;\n    l.xy = a * l.xy;\n    \n    return l;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // Screen coordinates.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Radial blur factors.\n    //\n    // Falloff, as we radiate outwards.\n    float decay = 0.99; \n    // Controls the sample density, which in turn, controls the sample spread.\n    float density = 0.2; \n    // Sample weight. Decays as we radiate outwards.\n    float weight = 0.1; \n    \n    // Light offset. Kind of fake. See above.\n    vec3 l = lOff();\n    \n    // Offset texture position (uv - .5), offset again by the fake light movement.\n    // It's used to set the blur direction (a direction vector of sorts), and is used \n    // later to center the spotlight.\n    //\n    // The range is centered on zero, which allows the accumulation to spread out in\n    // all directions. Ie; It's radial.\n    vec2 tuv =  uv - .5 - l.xy*.45;\n    \n    // Dividing the direction vector above by the sample number and a density factor\n    // which controls how far the blur spreads out. Higher density means a greater \n    // blur radius.\n    vec2 dTuv = tuv*density/SAMPLES;\n    \n    // Grabbing a portion of the initial texture sample. Higher numbers will make the\n    // scene a little clearer, but I'm going for a bit of abstraction.\n    vec4 col = texture(iChannel0, uv.xy)*0.25;\n    \n    // Jittering, to get rid of banding. Vitally important when accumulating discontinuous \n    // samples, especially when only a few layers are being used.\n    uv += dTuv*(hash(uv.xy + fract(iTime))*2. - 1.);\n    \n    // The radial blur loop. Take a texture sample, move a little in the direction of\n    // the radial direction vector (dTuv) then take another, slightly less weighted,\n    // sample, add it to the total, then repeat the process until done.\n    for(float i=0.; i < SAMPLES; i++){\n    \n        uv -= dTuv;\n        col += texture(iChannel0, uv) * weight;\n        weight *= decay;\n        \n    }\n    \n    // Multiplying the final color with a spotlight centered on the focal point of the radial\n    // blur. It's a nice finishing touch... that Passion came up with. If it's a good idea,\n    // it didn't come from me. :)\n    col *= (1. - dot(tuv, tuv)*.75);\n    \n    // Smoothstepping the final color, just to bring it out a bit, then applying some \n    // loose gamma correction.\n    fragColor = sqrt(smoothstep(0., 1., col));\n    \n    // Bypassing the radial blur to show the raymarched scene on its own.\n    //fragColor = sqrt(texture(iChannel0, fragCoord.xy / iResolution.xy));\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// The scene itself. Not much commenting, since this is mainly about the radial blur,\n// plus a lot of it is rudimentary.\n\n#define FAR 200.\n\n// Hash.\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tpl( sampler2D t, in vec3 p, in vec3 n ){\n   \n    n = max(abs(n), 0.001);\n    n /= (n.x + n.y + n.z );  \n\tp = (texture(t, p.yz)*n.x + texture(t, p.zx)*n.y + texture(t, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// A simple, cheap but visually effective sinusoid based lattice. The downside to building\n// a scene with transcendentals is the honing difficulty, but the logarithmic based\n// \"Logarithmmic Bisection\" tracing method counters that.\nfloat map(in vec3 p){\n   \n    // A few small bumps to put on the surface.\n    float bump = (dot(sin(p*24. - cos(p.yzx*36.)), vec3(.015)));\n    \n    // Perturbing the surface slightly, prior to construction.\n    p += sin(p*8. + 3.14159)*.1;\n    \n    // The main surface. A weird, molecular looking lattice.\n    float n = dot(sin(p*2.), cos(p.yzx*2.));\n    \n \t// Clamping the surface value, and adding the bumps.\n    //return (clamp(0., -1.1, n) + 1.1)/1.1 + bump;\n    return (min(n, 0.) + 1.1)/1.1 + bump;\n    \n}\n\n \n// Ambient occlusion, for that self shadowed look.\n// XT95 came up with this particular version. Very nice.\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat cao( in vec3 p, in vec3 n, float maxDist )\n{\n\tfloat ao = 0.0, l;\n\tconst float nbIte = 6.0;\n\tconst float falloff = 1.5;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i + hash(i))*.5/nbIte*maxDist;\n        ao += (l - map( p + n*l ))/ pow(1. + l, falloff);\n    }\n\t\n    return clamp( 1.-ao/nbIte, 0., 1.);\n}\n\n// Tetrahedral normal, courtesy of IQ.\nvec3 nr(in vec3 p)\n{  \n    vec2 e = vec2(-1, 1)*.001;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n// A trimmed down version of Nimitz's \"Log Bisecion\" method. Very effective on\n// difficult to hone in on things like weird, transcendental surfaces.\n// Worth studying, if you're not familiar with it.\n//\n// Log-Bisection Tracing - Nimitz\n// https://www.shadertoy.com/view/4sSXzD\nfloat logBisectTrace( in vec3 ro, in vec3 rd){\n\n\n    float t = 0., told = 0., mid, dn;\n    float d = map(rd*t + ro);\n    float sgn = sign(d);\n\n    for (int i=0; i<64; i++){\n\n        // If the threshold is crossed with no detection, use the bisection method.\n        // Also, break for the usual reasons. Note that there's only one \"break\"\n        // statement in the loop. I heard GPUs like that... but who knows?\n        if (sign(d) != sgn || d < 0.001 || t > FAR) break;\n \n        told = t;\n        \n        // Branchless version of the following:  \n        // if(d>1.) t += d*.5; else t += log(abs(d) + 1.1)*.5;\n        t += step(d, 1.)*(log(abs(d) + 1.1)*.5 - d*.5) + d*.5;\n       \n        d = map(rd*t + ro);\n    }\n    \n    // If a threshold was crossed without a solution, use the bisection method.\n    if (sign(d) != sgn){\n    \n        // Based on suggestions from CeeJayDK, with some minor changes.\n\n        dn = sign(map(rd*told + ro));\n        \n        vec2 iv = vec2(told, t); // Near, Far\n\n        // 6 iterations seems to be more than enough, for most cases...\n        // but there's an early exit, so I've added a couple more.\n        for (int ii=0; ii<8; ii++){ \n            //Evaluate midpoint\n            mid = dot(iv, vec2(.5));\n            float d = map(rd*mid + ro);\n            if (abs(d) < 0.001)break;\n            // Suggestion from movAX13h - Shadertoy is one of those rare\n            // sites with helpful commenters. :)\n            // Set mid to near or far, depending on which side we're on.\n            iv = mix(vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn));\n        }\n\n        t = mid; \n        \n    }\n\n    return min(t, FAR);\n}\n\n// Shadows.\nfloat sha(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int maxIterationsShad = 16; \n\n    float dist = start;\n    float stepDist = end/float(maxIterationsShad);\n\n    for (int i=0; i<maxIterationsShad; i++){\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist));\n\n        dist += clamp(h, 0.02, 0.16);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if ((h)<0.001 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.) + 0.1, 1.0); \n}\n\n// Grey scale.\nfloat gr(vec3 p){ return dot(p, vec3(0.299, 0.587, 0.114)); }\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 db( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.1, 0);\n    // Gradient vector, constructed with offset greyscale texture values.\n    vec3 g = vec3( gr(tpl(tx, p - e.xyy, n)), gr(tpl(tx, p - e.yxy, n)), gr(tpl(tx, p - e.yyx, n)));\n    \n    g = (g - gr(tpl(tx,  p , n)))/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n// Camera path. Arranged to coincide with the frequency of the lattice.\nvec3 camPath(float t){\n  \n    return vec3(-sin(t), sin(t) + .75, t*2. + .5);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n\t// Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\t\n    vec3 o = camPath(iTime); // Camera position, doubling as the ray origin.\n    vec3 lk = camPath(iTime + .1);  // \"Look At\" position.\n    vec3 l = o + vec3(0.1, 1., -1.5); // Light position, somewhere near the moving camera.\n\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; // FOV - Field of view.\n    vec3 fwd = normalize(lk-o);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    // Unit direction ray.\n    vec3 r = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    // Lens distortion.\n    //vec3 r = fwd + FOV*(u.x*rgt + u.y*up);\n    //r = normalize(vec3(r.xy, (r.z - length(r.xy)*.5)));\n    \n    \n    // Rotate the camera using Fabrice's simplified rotation matrix.\n    u = sin(vec2(1000.57, 1) - iTime/20.); // Reusing \"u.\"\n    mat2 a = mat2(u, -u.y, u.x);\n    r.xz = a * r.xz;\n    r.xy = a * r.xy;\n\n    // Nimitz's fancy surface intersection formula.\n    float t = logBisectTrace(o, r);\n\n    // Initialize the scene color to zero.\n    vec3 col = vec3(0);\n    \n    // If the surface is hit, light it up.\n    if(t<FAR){\n    \n        // Position and normal.\n        vec3 p = o + r*t, n = nr(p);\n        \n        // Texture bump the normal.\n        float sz = 1./1.;\n        n = db(iChannel0, p*sz, n, .03/(1. + t/FAR));\n\n\n        l -= p; // Light to surface vector. Ie: Light direction vector.\n        float d = max(length(l), 0.001); // Light to surface distance.\n        l /= d; // Normalizing the light direction vector.\n        \n        // Ambient occlusion and shadowing.\n        float ao =  cao(p, n, 40.);\n        float sh = sha(p, l, 0.004, d, 4.);\n        \n        // Diffuse, specular, fresnel. Only the latter is being used here.\n        //float di = max(dot(l, n), 0.);\n        float sp = pow(max( dot( reflect(r, n), l ), 0.0 ), 8.); // Specular term.\n        float fr = clamp(1.0 + dot(r, n), 0.0, 1.0); // Fresnel reflection term.\n        \n        // Texturing the surface with some tri-planar mapping..\n        vec3 tx = tpl( iChannel0, p*sz, n);\n\n\t\t// Very simple coloring. Fresnel and texture combination. Radial blurs like simplicity. :)\n        col = tx*fr*4.;\n        col *= 1./(1. + d*.125 + d*d*.05)*ao*sh;\n\n        \n    }\n\n    vec3 bg = vec3(1, .56, .3);\n    col = mix(clamp(col, 0., 1.), bg, smoothstep(0., FAR-20000., t));\n    fragColor = vec4(col, 1.);\n    \n    \n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define WAVES 16.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\n\tfloat time = iTime * 1.0;\n\t\n\tvec3 color = vec3(0.0);\n\n\tfor (float i=0.0; i<WAVES + 1.0; i++) {\n\t\tfloat freq = texture(iChannel0, vec2(i / WAVES, 0.0)).x * 17.0;\n\n\t\tvec2 p = vec2(uv);\n\n\t\tp.x += i * 0.04 + freq * 0.03;\n\t\tp.y += sin(p.x * 10.0 + time) * cos(p.x * 2.0) * freq * 0.2 * ((i + 1.0) / WAVES);\n\t\tfloat intensity = abs(0.01 / p.y) * clamp(freq, 0.35, 2.0);\n\t\tcolor += vec3(1.0 * intensity * (i / 5.0), 0.5 * intensity, 3.75 * intensity) * (3.0 / WAVES);\n\t}\n\n\tfragColor = vec4(color, 1.0);\n}", "buffer_b_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fllSRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1337, 1378, 1399, 1399, 1454], [1457, 1953, 1965, 1965, 2169], [2173, 2173, 2229, 2261, 4687]], "test": "untested"}
{"id": "slfSR7", "name": "CineShader Demo", "author": "jhancock532", "description": "This has been adapted from the book of shaders (https://thebookofshaders.com/edit.php#10/ikeda-03.frag) to be displayed on cineshader.com", "tags": ["cineshader"], "likes": 13, "viewed": 5833, "published": 3, "date": "1625335154", "time_retrieved": "2024-07-30T19:12:22.389344", "image_code": "float random (in float x) {\n    return fract(sin(x)*1e4);\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nfloat pattern(vec2 st, vec2 v, float t) {\n    vec2 p = floor(st+v);\n    return step(t, random(8.+p*.000001)+random(p.x)*0.5 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 st = fragCoord/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n\n    vec2 grid = vec2(100.0,50.);\n    st *= grid;\n\n    vec2 ipos = floor(st);  // integer\n    vec2 fpos = fract(st);  // fraction\n\n    vec2 vel = vec2(iTime*1.*max(grid.x,grid.y)); // time\n    vel *= vec2(-1.,0.0) * random(1.0+ipos.y); // direction\n\n    // Assign a random value base on the integer coord\n    vec2 offset = vec2(0.1,0.);\n\n    vec3 color = vec3(0.);\n    color.r = pattern(st+offset,vel,0.5);\n    color.g = pattern(st,vel,0.5);\n    color.b = pattern(st-offset,vel,0.5);\n\n    // Margins\n    color *= step(0.2,fpos.y);\n\n    fragColor = vec4(color,1.0);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"CineShader Demo\",\n\t\"description\": \"Adapted from Book of Shaders\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slfSR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 59], [61, 61, 88, 88, 162], [164, 164, 205, 205, 292], [294, 294, 351, 351, 1004]], "test": "untested"}
{"id": "7tfSzM", "name": "Warped XOR Towers - 306 chars", "author": "GregRostami", "description": "Another variation of KilledByAPixel's Voxel Fractal:\n[url]https://www.shadertoy.com/view/NlB3Rz[/url]", "tags": ["3d", "fractal", "xor", "warped", "short", "2tc"], "likes": 5, "viewed": 306, "published": 3, "date": "1625329981", "time_retrieved": "2024-07-30T19:12:23.411610", "image_code": "// 306 chars -  Fabrice removed another 3 chars from the shader.\nvoid mainImage(out vec4 o, vec2 u)\n{ \n    ivec4 b = ivec4(o -= o);\n    float t = .1*iTime;\n            \n    for (vec2 R = iResolution.xy; (b.x^b.y^b.z)%99 > b.z-8 ; )\n        b = ivec4((2. + cos(t))*(2.*(u-=2.*sin(t))-R)/R.y\n                * mat2( cos( vec4(0,33,55,0) - .03*o.a-.3*t))\n                * o.a\n                + 2e2 + vec2(25,9)*t\n                , o+=.1 );\n                \n    o = o.a < 8.1 ? .1+sin(t/.1)*vec4(b%32 & b.x%9 & b.z%9) : o/65. - .02*vec4(b%3);\n}\n\n// 309 chars - dean_the_coder eliminated 2 chars.\n/**\nvoid mainImage(out vec4 o, vec2 u)\n{ \n    ivec4 b = ivec4(o -= o);\n    vec2 R = iResolution.xy;\n    float t = .1*iTime,\n          z = 2. + cos(t);\n            \n    for (; (b.x^b.y^b.z)%99 > b.z-8 ; )\n        b = ivec4(z*(2.*(u-=2.*sin(t))-R)/R.y\n                * mat2( cos( vec4(0,33,55,0) - .03*o.a-.3*t))\n                * o.a\n                + 2e2 + vec2(25,9)*t\n                , o+=.1 );\n                \n    o = o.a < 8.1 ? .1+sin(t/.1)*vec4(b%32 & b.x%9 & b.z%9) : o/65. - .02*vec4(b%3);\n}\n/**/", "image_inputs": [{"id": 27773, "src": "https://soundcloud.com/eminakaya/inception-soundtrack-old-souls-hans-zimmer", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tfSzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 65, 101, 101, 541]], "test": "untested"}
{"id": "flXSz7", "name": "Flood fill", "author": "Daizuukee", "description": "This is a shader to test filling something in a flood like pattern", "tags": ["flood", "algorithm", "fill"], "likes": 1, "viewed": 409, "published": 3, "date": "1625325712", "time_retrieved": "2024-07-30T19:12:24.301233", "image_code": "//#define rand\n//#define point\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 col = texture(iChannel0,uv).rg;\n    #ifdef rand\n    fragColor = vec4(texture(iChannel2,col).r);\n    #else\n    #ifdef point\n    fragColor = vec4(texture(iChannel0,col).rg,1.,1.);\n    #else\n    fragColor = vec4(texture(iChannel1,col).rgb,1.);\n    #endif\n    #endif\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define stepSize s\n#define diff 0.1\n\n#define close\n\n#ifdef close\n#define check(a) texture(iChannel0,data.rg + a).rg\n#else\n#define check(a) data.rg + a\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float s = 1./512.;\n    if(iFrame == 0) {\n        fragColor = vec4(fragCoord / iResolution.xy,1.0,1.0);\n    } else {\n        vec4 data = texture(iChannel0,fragCoord / iResolution.xy);\n        fragColor = vec4(data.rgb,1.0);\n        float self = dot(vec3(1),texture(iChannel1,data.rg).rgb);\n        if(data.b == 1.0) {\n            if(data.r < 1.-stepSize && abs(self - dot(vec3(1),texture(iChannel1,check(vec2(stepSize,0))).rgb)) < diff)\n                fragColor = vec4(texture(iChannel0,data.rg + vec2(stepSize,0)).rg,1.0,1.0);\n            else\n                fragColor = vec4(data.rg,0.75,1.0);\n        }\n        if(data.b == 0.75) {\n            if(data.g < 1.-stepSize&& abs(self - dot(vec3(1),texture(iChannel1,check(vec2(0,stepSize))).rgb)) < diff)\n                fragColor = vec4(texture(iChannel0,data.rg + vec2(0,stepSize)).rg,0.75,1.0);\n            else\n                fragColor = vec4(data.rg,0.5,1.0);\n        }\n        if(data.b == 0.5) {\n            if(data.r > stepSize && abs(self - dot(vec3(1),texture(iChannel1,check(vec2(-stepSize,0))).rgb)) < diff)\n                fragColor = vec4(texture(iChannel0,data.rg + vec2(-stepSize,0)).rg,0.5,1.0);\n            else\n                fragColor = vec4(data.rg,0.25,1.0);\n        }\n        if(data.b == 0.25) {\n            if(data.g > stepSize && abs(self - dot(vec3(1),texture(iChannel1,check(vec2(0,-stepSize))).rgb)) < diff)\n                fragColor = vec4(texture(iChannel0,data.rg + vec2(0,-stepSize)).rg,0.25,1.0);\n            else\n                fragColor = vec4(data.rg,1.0,1.0);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flXSz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 89, 139, 454]], "test": "untested"}
{"id": "7tlXR4", "name": "shading with 1 random color (2)", "author": "sympou", "description": "random ball shading again,\nthis time using the hsl color representation format.\nit is less simple, but more balanced and more tweakable.", "tags": ["shadingpalette"], "likes": 4, "viewed": 438, "published": 3, "date": "1625323007", "time_retrieved": "2024-07-30T19:12:25.264656", "image_code": "const float gridSize = 75.;\nconst float sphereSize = 0.92;\nconst float speed = 10.;\n\n//https://www.shadertoy.com/view/4djSRW\nvec3 hash32(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//https://www.shadertoy.com/view/lsS3Wc\nvec3 hsl2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 lightDir = normalize(vec3(cos(iTime)*0.25,0.5,sin(iTime)*0.25));\n    \n    //slowly panning coordinates\n    vec2 uv = (fragCoord+iTime*vec2(2.,1.)*speed)/gridSize;\n\n    //a square that contains the sphere\n    vec2 uv2 = (fract(uv)*2.-1.)/sphereSize;\n    \n    // a method to get sphere normals in orthographic projection\n    // (if d >= 1. then we are not touching the sphere)  \n    float d = dot(uv2,uv2);\n    float z = (d>=1.) ? 0. : sqrt(1.-d);\n    vec3 normals = vec3(uv2,z);\n    \n    //phong reflection model\n    float specular = pow(max(2.*z*dot(lightDir,normals) -lightDir.z, 0.0),20.)*0.25;\n    float diffuse = 0.5 + dot(normals,lightDir)*0.5;\n    \n    vec2 seed = floor(uv);\n    vec3 rnd = hash32(seed);\n    \n    //we create 2 slightly different colors\n    \n    float hue  = rnd.x;\n    float hue2 = rnd.x + 0.25 + fract(rnd.x*99.99)*0.1;\n    \n    float saturation = 0.1 + rnd.z*0.9;\n    \n    float luminosity  = 0.05 + rnd.y*0.5;\n    float luminosity2 = 0.2  + rnd.y*0.5;\n    \n    vec3 colA = hsl2rgb(vec3(hue , saturation, luminosity));\n    vec3 colB = hsl2rgb(vec3(hue2, saturation, luminosity2));\n    \n    vec3 col = mix(colA, colB, diffuse);\n    \n    //light space blending\n    //vec3 col = pow(mix(pow(colA,vec3(2.2)), pow(colB,vec3(2.2)), diffuse),vec3(1./2.2));\n\n    //antialiasing\n    col *= min(15.*z*z,1.);\n    \n    // Output to screen\n    fragColor = vec4(col+specular,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlXR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 125, 146, 146, 282], [284, 324, 351, 351, 493], [495, 495, 552, 552, 1961]], "test": "untested"}
{"id": "ftfXR7", "name": "Fork Fork Full  firebreath 322", "author": "firebreathz", "description": "Applying some God rays, post process, to a simple raymarched scene. Inspired by Passion's \"Blue Dream\" ... and a lot of old demos. :)", "tags": ["raymarching", "blur", "radial", "godrays"], "likes": 2, "viewed": 341, "published": 3, "date": "1625320394", "time_retrieved": "2024-07-30T19:12:26.314848", "image_code": "/*\n\tFull Scene Radial Blur\n\t----------------------\n\n\tRadial blur - as a postprocessing effect - is one of the first things I considered doing \n\twhen the multipass system came out. I've always loved this effect. Reminds me of the early \n\tdemos from Aardbei et al. \n\n\tAnyway, Shadertoy user, Passion, did a really cool radial blur on a field of spheres that\n\tinspired me to do my own. Radial blurs are pretty straight forward, but it was still\n    helpful to have Passion's version as a guide. \n\n    As for the radial blur process, there's not much to it. Start off at the pixel position, \n    then radiate outwards gathering up pixels with decreased weighting. The result is a\n\tblurring of the image in a radial fashion, strangely enough. :)\n\n\tInspired by:\n\n\tBlue Dream - Passion\n\thttps://www.shadertoy.com/view/MdG3RD\n\n\tRadial Blur - IQ\n\thttps://www.shadertoy.com/view/4sfGRn\n\n\tRays of Blinding Light - mu6k\n\thttps://www.shadertoy.com/view/lsf3Dn\n\n*/\n\n// The radial blur section. Shadertoy user, Passion, did a good enough job, so I've used a\n// slightly trimmed down version of that. By the way, there are accumulative weighting \n// methods that do a slightly better job, but this method is good enough for this example.\n\n\n// Radial blur samples. More is always better, but there's frame rate to consider.\nconst float SAMPLES = 24.; \n\n\n// 2x1 hash. Used to jitter the samples.\nfloat hash( vec2 p ){ return fract(sin(dot(p, vec2(41, 289)))*45758.5453); }\n\n\n// Light offset.\n//\n// I realized, after a while, that determining the correct light position doesn't help, since \n// radial blur doesn't really look right unless its focus point is within the screen boundaries, \n// whereas the light is often out of frame. Therefore, I decided to go for something that at \n// least gives the feel of following the light. In this case, I normalized the light position \n// and rotated it in unison with the camera rotation. Hacky, for sure, but who's checking? :)\nvec3 lOff(){    \n    \n    vec2 u = sin(vec2(1.57, 0) - iTime/1.);\n    mat2 a = mat2(u, -u.y, u.x);\n    \n    vec3 l = normalize(vec3(1.5, 1., -0.5));\n    l.xz = a * l.xz;\n    l.xy = a * l.xy;\n    \n    return l;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // Screen coordinates.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Radial blur factors.\n    //\n    // Falloff, as we radiate outwards.\n    float decay = 0.99; \n    // Controls the sample density, which in turn, controls the sample spread.\n    float density = 0.2; \n    // Sample weight. Decays as we radiate outwards.\n    float weight = 0.1; \n    \n    // Light offset. Kind of fake. See above.\n    vec3 l = lOff();\n    \n    // Offset texture position (uv - .5), offset again by the fake light movement.\n    // It's used to set the blur direction (a direction vector of sorts), and is used \n    // later to center the spotlight.\n    //\n    // The range is centered on zero, which allows the accumulation to spread out in\n    // all directions. Ie; It's radial.\n    vec2 tuv =  uv - .5 - l.xy*.45;\n    \n    // Dividing the direction vector above by the sample number and a density factor\n    // which controls how far the blur spreads out. Higher density means a greater \n    // blur radius.\n    vec2 dTuv = tuv*density/SAMPLES;\n    \n    // Grabbing a portion of the initial texture sample. Higher numbers will make the\n    // scene a little clearer, but I'm going for a bit of abstraction.\n    vec4 col = texture(iChannel0, uv.xy)*0.25;\n    \n    // Jittering, to get rid of banding. Vitally important when accumulating discontinuous \n    // samples, especially when only a few layers are being used.\n    uv += dTuv*(hash(uv.xy + fract(iTime))*2. - 1.);\n    \n    // The radial blur loop. Take a texture sample, move a little in the direction of\n    // the radial direction vector (dTuv) then take another, slightly less weighted,\n    // sample, add it to the total, then repeat the process until done.\n    for(float i=0.; i < SAMPLES; i++){\n    \n        uv -= dTuv;\n        col += texture(iChannel0, uv) * weight;\n        weight *= decay;\n        \n    }\n    \n    // Multiplying the final color with a spotlight centered on the focal point of the radial\n    // blur. It's a nice finishing touch... that Passion came up with. If it's a good idea,\n    // it didn't come from me. :)\n    col *= (1. - dot(tuv, tuv)*.75);\n    \n    // Smoothstepping the final color, just to bring it out a bit, then applying some \n    // loose gamma correction.\n    fragColor = sqrt(smoothstep(0., 1., col));\n    \n    // Bypassing the radial blur to show the raymarched scene on its own.\n    //fragColor = sqrt(texture(iChannel0, fragCoord.xy / iResolution.xy));\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// The scene itself. Not much commenting, since this is mainly about the radial blur,\n// plus a lot of it is rudimentary.\n\n#define FAR 200.\n\n// Hash.\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tpl( sampler2D t, in vec3 p, in vec3 n ){\n   \n    n = max(abs(n), 0.001);\n    n /= (n.x + n.y + n.z );  \n\tp = (texture(t, p.yz)*n.x + texture(t, p.zx)*n.y + texture(t, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// A simple, cheap but visually effective sinusoid based lattice. The downside to building\n// a scene with transcendentals is the honing difficulty, but the logarithmic based\n// \"Logarithmmic Bisection\" tracing method counters that.\nfloat map(in vec3 p){\n   \n    // A few small bumps to put on the surface.\n    float bump = (dot(sin(p*24. - cos(p.yzx*36.)), vec3(.015)));\n    \n    // Perturbing the surface slightly, prior to construction.\n    p += sin(p*8. + 3.14159)*.1;\n    \n    // The main surface. A weird, molecular looking lattice.\n    float n = dot(sin(p*2.), cos(p.yzx*2.));\n    \n \t// Clamping the surface value, and adding the bumps.\n    //return (clamp(0., -1.1, n) + 1.1)/1.1 + bump;\n    return (min(n, 0.) + 1.1)/1.1 + bump;\n    \n}\n\n \n// Ambient occlusion, for that self shadowed look.\n// XT95 came up with this particular version. Very nice.\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat cao( in vec3 p, in vec3 n, float maxDist )\n{\n\tfloat ao = 0.0, l;\n\tconst float nbIte = 6.0;\n\tconst float falloff = 1.5;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i + hash(i))*.5/nbIte*maxDist;\n        ao += (l - map( p + n*l ))/ pow(1. + l, falloff);\n    }\n\t\n    return clamp( 1.-ao/nbIte, 0., 1.);\n}\n\n// Tetrahedral normal, courtesy of IQ.\nvec3 nr(in vec3 p)\n{  \n    vec2 e = vec2(-1, 1)*.001;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n// A trimmed down version of Nimitz's \"Log Bisecion\" method. Very effective on\n// difficult to hone in on things like weird, transcendental surfaces.\n// Worth studying, if you're not familiar with it.\n//\n// Log-Bisection Tracing - Nimitz\n// https://www.shadertoy.com/view/4sSXzD\nfloat logBisectTrace( in vec3 ro, in vec3 rd){\n\n\n    float t = 0., told = 0., mid, dn;\n    float d = map(rd*t + ro);\n    float sgn = sign(d);\n\n    for (int i=0; i<64; i++){\n\n        // If the threshold is crossed with no detection, use the bisection method.\n        // Also, break for the usual reasons. Note that there's only one \"break\"\n        // statement in the loop. I heard GPUs like that... but who knows?\n        if (sign(d) != sgn || d < 0.001 || t > FAR) break;\n \n        told = t;\n        \n        // Branchless version of the following:  \n        // if(d>1.) t += d*.5; else t += log(abs(d) + 1.1)*.5;\n        t += step(d, 1.)*(log(abs(d) + 1.1)*.5 - d*.5) + d*.5;\n       \n        d = map(rd*t + ro);\n    }\n    \n    // If a threshold was crossed without a solution, use the bisection method.\n    if (sign(d) != sgn){\n    \n        // Based on suggestions from CeeJayDK, with some minor changes.\n\n        dn = sign(map(rd*told + ro));\n        \n        vec2 iv = vec2(told, t); // Near, Far\n\n        // 6 iterations seems to be more than enough, for most cases...\n        // but there's an early exit, so I've added a couple more.\n        for (int ii=0; ii<8; ii++){ \n            //Evaluate midpoint\n            mid = dot(iv, vec2(.5));\n            float d = map(rd*mid + ro);\n            if (abs(d) < 0.001)break;\n            // Suggestion from movAX13h - Shadertoy is one of those rare\n            // sites with helpful commenters. :)\n            // Set mid to near or far, depending on which side we're on.\n            iv = mix(vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn));\n        }\n\n        t = mid; \n        \n    }\n\n    return min(t, FAR);\n}\n\n// Shadows.\nfloat sha(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int maxIterationsShad = 16; \n\n    float dist = start;\n    float stepDist = end/float(maxIterationsShad);\n\n    for (int i=0; i<maxIterationsShad; i++){\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist));\n\n        dist += clamp(h, 0.02, 0.16);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if ((h)<0.001 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.) + 0.1, 1.0); \n}\n\n// Grey scale.\nfloat gr(vec3 p){ return dot(p, vec3(0.299, 0.587, 0.114)); }\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 db( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    // Gradient vector, constructed with offset greyscale texture values.\n    vec3 g = vec3( gr(tpl(tx, p - e.xyy, n)), gr(tpl(tx, p - e.yxy, n)), gr(tpl(tx, p - e.yyx, n)));\n    \n    g = (g - gr(tpl(tx,  p , n)))/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n// Camera path. Arranged to coincide with the frequency of the lattice.\nvec3 camPath(float t){\n  \n    return vec3(-sin(t), sin(t) + .75, t*2. + .5);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n\t// Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\t\n    vec3 o = camPath(iTime); // Camera position, doubling as the ray origin.\n    vec3 lk = camPath(iTime + .1);  // \"Look At\" position.\n    vec3 l = o + vec3(1.5, 1., -0.5); // Light position, somewhere near the moving camera.\n\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; // FOV - Field of view.\n    vec3 fwd = normalize(lk-o);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    // Unit direction ray.\n    vec3 r = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    // Lens distortion.\n    //vec3 r = fwd + FOV*(u.x*rgt + u.y*up);\n    //r = normalize(vec3(r.xy, (r.z - length(r.xy)*.5)));\n    \n    \n    // Rotate the camera using Fabrice's simplified rotation matrix.\n    u = sin(vec2(10.57, 0) - iTime/10.); // Reusing \"u.\"\n    mat2 a = mat2(u, -u.y, u.x);\n    r.xz = a * r.xz;\n    r.xy = a * r.xy;\n\n    // Nimitz's fancy surface intersection formula.\n    float t = logBisectTrace(o, r);\n\n    // Initialize the scene color to zero.\n    vec3 col = vec3(0);\n    \n    // If the surface is hit, light it up.\n    if(t<FAR){\n    \n        // Position and normal.\n        vec3 p = o + r*t, n = nr(p);\n        \n        // Texture bump the normal.\n        float sz = 1./1.;\n        n = db(iChannel0, p*sz, n, .03/(1. + t/FAR));\n\n\n        l -= p; // Light to surface vector. Ie: Light direction vector.\n        float d = max(length(l), 0.001); // Light to surface distance.\n        l /= d; // Normalizing the light direction vector.\n        \n        // Ambient occlusion and shadowing.\n        float ao =  cao(p, n, 4.);\n        float sh = sha(p, l, 0.04, d, 4.);\n        \n        // Diffuse, specular, fresnel. Only the latter is being used here.\n        //float di = max(dot(l, n), 0.);\n        //float sp = pow(max( dot( reflect(r, n), l ), 0.0 ), 8.); // Specular term.\n        float fr = clamp(1.0 + dot(r, n), 0.0, 1.0); // Fresnel reflection term.\n        \n        // Texturing the surface with some tri-planar mapping..\n        vec3 tx = tpl( iChannel0, p*sz, n);\n\n\t\t// Very simple coloring. Fresnel and texture combination. Radial blurs like simplicity. :)\n        col = tx*fr*4.;\n        col *= 1./(1. + d*.125 + d*d*.05)*ao*sh;\n\n        \n    }\n\n    vec3 bg = vec3(1, .56, .3);\n    col = mix(clamp(col, 0., 1.), bg, smoothstep(0., FAR-2., t));\n    fragColor = vec4(col, 1.);\n    \n    \n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define WAVES 16.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\n\tfloat time = iTime * 1.0;\n\t\n\tvec3 color = vec3(0.0);\n\n\tfor (float i=0.0; i<WAVES + 1.0; i++) {\n\t\tfloat freq = texture(iChannel0, vec2(i / WAVES, 0.0)).x * 17.0;\n\n\t\tvec2 p = vec2(uv);\n\n\t\tp.x += i * 0.04 + freq * 0.03;\n\t\tp.y += sin(p.x * 10.0 + time) * cos(p.x * 2.0) * freq * 0.2 * ((i + 1.0) / WAVES);\n\t\tfloat intensity = abs(0.01 / p.y) * clamp(freq, 0.35, 2.0);\n\t\tcolor += vec3(1.0 * intensity * (i / 5.0), 0.5 * intensity, 3.75 * intensity) * (3.0 / WAVES);\n\t}\n\n\tfragColor = vec4(color, 1.0);\n}", "buffer_b_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftfXR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1337, 1378, 1399, 1399, 1454], [1457, 1953, 1965, 1965, 2169], [2173, 2173, 2229, 2261, 4687]], "test": "untested"}
{"id": "flfSR7", "name": "Fork Fork Fork  firebreath 154", "author": "firebreathz", "description": "A warped lattice structure, very loosely based on the 256b Puls demo by Rrrola.", "tags": ["raymarch", "warp", "edges", "lattice"], "likes": 3, "viewed": 343, "published": 3, "date": "1625318186", "time_retrieved": "2024-07-30T19:12:27.378005", "image_code": "/*\n\n\tLattice Framework\n\t-----------------\n\n\tI coded up a simple lattice the other day, complete with some joins to jazz it up a \n\tbit. At that point, I realized that it had a bit of a \"Puls 256b\" feel, so added in \n\tsome bolts to complete the process. I've never looked at the original Puls code, but \n\tit'd be interesting to see if it's more efficient. At 256 bytes, it's definitely \n\tmore compact. :)\n\n\tThe structure in this particular example is wrapped around a path then rotated about \n\tthe XY plane according to Z distance. Other than that, it's a very rudimentary scene.\n\n\tFor anyone interested, the relevant code is contained in the distance function.\n\n\t// Very cool 256b demo, and definitely worth a look, if you haven't seen it before.\n\tPuls (256b) by Rrrola\n\thttp://www.pouet.net/prod.php?which=53816\n\n\t// Cool and informative lattice example.\n\tCC / FCC / BCC Lattices - Paniq\n\thttps://www.shadertoy.com/view/llfGRj\n\n*/\n\n#define FAR 100. // Far plane, or maximum distance.\n\nfloat objID = 0.; // Object ID - Lattice: 0.; Joins: 1.; Bolts: 2..\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tpl( sampler2D t, in vec3 p, in vec3 n ){\n   \n    n = max(abs(n), 0.001);\n    n /= (n.x + n.y + n.z );  \n\tp = (texture(t, p.yz)*n.x + texture(t, p.zx)*n.y + texture(t, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n\n// Camera path. Arranged to coincide with the frequency of the lattice.\nvec3 camPath(float t){\n  \n    //return vec3(0, 0, t); // Straight path.\n    return vec3(-sin(t/2.), sin(t/2.)*.5 + 1.57, t); // Windy path.\n    \n}\n\n\n// The lattice structure.\nfloat map(in vec3 p){\n    \n    // Using the Z value to offset the structure by the camera path. Pretty standard.\n    p.xy -= camPath(p.z).xy;\n    \n    // Rotating the structure about the XY plane by an angle dependent on the Z value.\n    // Also a pretty standard move that you'll see from time to time.\n\tvec2 a = sin(vec2(1.57, 0) + p.z*1.57/10.);\n    p.xy = mat2(a, -a.y, a.x)*p.xy;\n    \n    // Rounded cubes, just for fun, and to help visualize things.\n    //p = abs(fract(p) - .5);\n    //return max(p.x, max(p.y, p.z))*.7 + length(p)*.3 - .2;\n    \n    // Using repeat properties to produce the octahedral joins. There's probably a \n    // clever way to do both simultaneously, but the following works well enough.\n    vec3 q = abs(fract(p + vec3(.5, 0, .5)) - .5);\n    float joins = (q.x + q.y + q.z) - .16; // Half of the joins.\n    \n    p = abs(fract(p + vec3(0, .5, 0)) - .5);\n    joins =  min(joins, (p.x + p.y + p.z) - .16); // The other half.\n    \n    \n    // Reusing \"p\" above to produce the lattice structure. This particular one is called\n    // a body-centered lattice, which I think relates back to some form of nomenclature\n    // regarding crystalline structure. I was already familiar with the structure, but \n    // learned that it had a fancy name via Paniq's really informative shader here:\n    //\n    // CC / FCC / BCC Lattices - https://www.shadertoy.com/view/llfGRj\n    //\n    // Body-centered lattice. My take on it, anyway. I like it because it's cheap and it\n    // looks interesting. Basically, you get your money's worth. :)\n    //p = abs(p - dot(p, vec3(.333)));\n    //float lat = dot(p, vec3(.5)) - 0.034;\n    p = abs(p - (p.x + p.y + p.z)*.3333);\n    float lat = (p.x + p.y + p.z)*.8 - 0.034;\n    \n    // Bolts. Constructed by enlarging the lattice tubes and the octahedral joins, then\n    // taking the difference.\n    float bolts = max(lat - .015, -(joins - .48));\n    \n    // Object ID. Octahedral joins are blue, and the lattice itself will be white.\n    objID = step(joins, lat) + step(bolts, lat)*2.;\n    \n    // Combined objects and joins.\n    return min(min(joins, lat), bolts);\n    \n    \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cao(in vec3 p, in vec3 n)\n{\n\tfloat sca = 1., occ = 0.;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.35/4.;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0., 1.);    \n}\n\n\n// The normal function with some edge detection rolled into it.\nvec3 nr(vec3 p, inout float edge) { \n\t\n    vec2 e = vec2(.003, 0);\n\n    // Take some distance function measurements from either side of the hit point on all three axes.\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\t// The hit point itself - Doubled to cut down on calculations. See below.\n     \n    // Edges - Take a geometry measurement from either side of the hit point. Average them, then see how\n    // much the value differs from the hit point itself. Do this for X, Y and Z directions. Here, the sum\n    // is used for the overall difference, but there are other ways. Note that it's mainly sharp surface \n    // curves that register a discernible difference.\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = max(max(abs(d1 + d2 - d), abs(d3 + d4 - d)), abs(d5 + d6 - d)); // Etc.\n    \n    // Once you have an edge value, it needs to normalized, and smoothed if possible. How you \n    // do that is up to you. This is what I came up with for now, but I might tweak it later.\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n\t\n    // Return the normal.\n    // Standard, normalized gradient mearsurement.\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0.0, h;\n    for(int i = 0; i < 128; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.001*max(t*.25, 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h*.85;\n        \n    }\n\n    return min(t, FAR);\n}\n\n\n\n// Shadows.\nfloat sha(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int maxIterationsShad = 13; \n\n    float dist = start;\n    float stepDist = end/float(maxIterationsShad);\n\n    for (int i=0; i<maxIterationsShad; i++){\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist));\n\n        dist += clamp(h, 0.005, 0.16);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if (abs(h)<0.01 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.) + 0.1, 1.0); \n}\n\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 db( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.01, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tpl(tx, p - e.xyy, n), tpl(tx, p - e.yxy, n), tpl(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tpl(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. The normal is redundant here, but it can be used\n// to pass into a 3D texture mapping function to produce some interesting\n// environmental reflections.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 eMap(vec3 rd, vec3 sn){\n    \n    vec3 sRd = rd; // Save rd, just for some mixing at the end.\n    \n    // Add a time component, scale, then pass into the noise function.\n    rd.xy -= iTime*.5;\n    rd *= 2.;\n    \n    //vec3 tx = tpl(iChannel1, rd/3., sn).zyx;\n    //tx = smoothstep(0.2, 1., tx*2.); \n    //float c = dot(tx, vec3(.299, .587, .114));\n    \n    float c = n3D(rd)*.57 + n3D(rd*2.)*.28 + n3D(rd*4.)*.15; // Noise value.\n    c = smoothstep(0.1, 0.5, c); // Darken and add contast for more of a spotlight look.\n    \n    //vec3 col = vec3(c, c*c, c*c*c*c).zyx; // Simple, warm coloring.\n    vec3 col = vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.)); // More color.\n    \n    // Mix in some more red to tone it down and return.\n    return mix(col, col.yzx, sRd*.5+.5); \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n\t// Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n    float speed = 0.8;\n    vec3 o = camPath(iTime*speed); // Camera position, doubling as the ray origin.\n    vec3 lk = camPath(iTime*speed + .1);  // \"Look At\" position.\n    vec3 l = camPath(iTime*speed + 1.); // Light position, somewhere near the moving camera.\n\t\n    // Light postion offset. Since the lattice structure is rotated about the XY plane, the light\n    // has to be rotated to match. See the \"map\" equation.\n    vec3 loffs =  vec3(0, 1, 0);\n    vec2 a = sin(vec2(1.57, 0) - l.z*1.57/10.);\n    loffs.xy = mat2(a, -a.y, a.x)*loffs.xy; \n    l += loffs;\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 4.14159/3.; ///3. FOV - Field of view.\n    vec3 fwd = normalize(lk-o);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    // Unit direction ray.\n    vec3 r = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    // Lens distortion.\n    //vec3 r = fwd + FOV*(u.x*rgt + u.y*up);\n    //r = normalize(vec3(r.xy, (r.z - length(r.xy)*.25)));\n\n\n    // Raymarch.\n    float t = trace(o, r);\n    \n    // Save the object ID directly after the raymarching equation, since other equations that\n    // use the \"map\" function will distort the results. I leaned that the hard way. :)\n    float sObjID = objID;\n\n    // Initialize the scene color to the background.\n    vec3 col = vec3(0);\n    \n    // If the surface is hit, light it up.\n    if(t<FAR){\n    \n        // Position and normal.\n        vec3 p = o + r*t;\n        \n        float ed; // Edge variable.\n        vec3 n = nr(p, ed);\n        \n        // Texture bump the normal.\n        float sz = 2./1.;\n        n = db(iChannel0, p*sz, n, .01/(1. + t/FAR));\n\n\n        l -= p; // Light to surface vector. Ie: Light direction vector.\n        float d = max(length(l), 0.001); // Light to surface distance.\n        l /= d; // Normalizing the light direction vector.\n        \n        float at = 1./(1. + d*.25 + d*d*.1); // Light attenuation.\n        \n        // Ambient occlusion and shadowing.\n        float ao =  cao(p, n);\n        float sh = sha(p, l, 0.04, d, 8.);\n        \n        // Diffuse, specular, fresnel. Only the latter is being used here.\n        float di = max(dot(l, n), 0.);\n        float sp = pow(max( dot( reflect(r, n), l ), 0.0 ), 16.); // Specular term.\n        //float fr = clamp(1.0 + dot(r, n), 0.0, 1.0); // Fresnel reflection term.\n        \n        // Texturing the surface with some tri-planar mapping..\n        vec3 tx = tpl(iChannel0, p*sz, n); // Lattice coloring.\n        if(sObjID>1.5) tx *= vec3(1.5); // Lighten the bolts a bit.\n        else if(sObjID>.5) tx *= vec3(.5, .7, 1);// Color the joins blue.\n\n\t\t// Very simple coloring.\n        col = tx*(di + vec3(.75, .75, 1) + vec3(.5, .7, 1)*sp*3.);\n        \n        // Edges.\n        col *= 1. - ed*.7; // Darker edges.\n        //col += ed*.5; // Lighter edges.\n\n        // Fake environment mapping.\n        vec3 em = eMap(reflect(r, n), n); \n        col += col*em*2.;\n        \n        // Apply some shading.\n        col *= ao*sh*at;\n\n        \n    }\n    \n    // If we've hit the far plane, calulate \"l\" only.\n    if(t>=FAR) l = normalize(l - o - r*FAR);\n \t\n    // Produce some colored fog.\n    vec3 bg = mix(vec3(.5, .7, 1), vec3(1, .5, .6), l.y*.5 + .5);\n    col = mix(clamp(col, 0., 1.), bg, smoothstep(0., FAR-2., t));\n    \n     \n    \n    // Rough gamma correction, and we're done.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.);\n    \n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Fork of \"Fork Fork Polar \" by firebreathz. https://shadertoy.com/view/stj3Rw\n// 2021-06-25 22:06:44\n\n// Fork of \"Fork Fork Polar firebreath 967\" by firebreathz. https://shadertoy.com/view/NdBXRG\n// 2021-06-13 18:25:29\n\n#define time iTime\n#define PI 3.14159265359\n\n#define NUM_BANDS 1000\n\n//#define REVERSED\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(1.000,1.000,1.000))) * 10.)*20.0-10.0;\n}\n\nvec3 mixc(vec3 col1, vec3 col2, float v)\n{\n    v = clamp(v,0.0,1.0);\n    return col1+v*(col2-col1);\n}\n\nvec3 drawBands(vec2 uv)\n{\n  \tuv = 2.0*uv-1.0;\n    uv.x*=iResolution.x/iResolution.y;\n    uv = vec2(length(uv), atan(uv.y,uv.x));\n    \n    uv.x-=0.01;\n    uv.x = max(0.0,uv.x);\n    \n    uv.y -= PI*0.5;\n    vec2 uv2 = vec2(uv.x, uv.y*-1.0);\n    uv.y = mod(uv.y,PI*2.0);\n    uv2.y = mod(uv2.y,PI*2.0);\n    \n    vec3 col = vec3(0.0);\n    vec3 col2 = vec3(0.0);\n    \n    float nBands = float(NUM_BANDS);\n    float i = floor(uv.x*nBands);\n    float f = fract(uv.x*nBands);\n    float band = i/nBands;\n   \tfloat s;\n   \t\n    #ifdef REVERSED\n    band = 5.0-band;\n    #endif \n    \n    //cubic easing\n    band *= band*band; \n    \n    band = band*0.099;\n    band += 0.001;\n    \n    s = texture( iChannel0, vec2(band,.3) ).x;  \n    \n    if(band<0.0||band>=1.0){\n        s = 0.0;\n    }\n    \n    /* Gradient colors and amount here */\n    const int nColors = 5;\n    vec3 colors[nColors];  \n    colors[0] = vec3(0.208,0.000,0.416);\n    colors[1] = vec3(0.251,0.000,0.502);\n    colors[2] = vec3(1.000,1.000,1.000);\n    colors[3] = vec3(0.059,0.059,0.482);\n \n    vec3 gradCol = colors[0];\n    float n = float(nColors)-1.25;\n    for(int i = 2; i < nColors; i++)\n    {\n\t\tgradCol = mixc(gradCol,colors[i],(s-float(i-1)/n)*n);\n    }\n    \n    float h = PI*1.5;\n    \n    col += vec3(1.0-smoothstep(-2.0,1.5,uv.y-s*h));\n    col *= gradCol;\n\n    col2 += vec3(1.0-smoothstep(-2.0,1.5,uv2.y-s*h));\n    col2*= gradCol;\n    \n    col = mix(col,col2,step(0.0,uv.y-PI));\n\n    col *= smoothstep(0.00001,.00009,f);\n    col *= smoothstep(0.000000001,0.000000009,f); \n    \n    col = clamp(col,0.0,1.0);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 p = vec2(uv.x, uv.y+0.1);\n\tvec3 col = vec3(0.0);\n    col += drawBands(p);//*smoothstep(1.0,0.5,uv.y);;\n    \n    vec3 ref = vec3(0.0);\n    vec2 eps = vec2(1.0,-0.5);\n\n    ref += drawBands(vec2(p.x,100.0-p.y)+eps.xy);\n    ref += drawBands(vec2(p.x,100.0-p.y)+eps.xx);\n    ref += drawBands(vec2(p.x,100.0-p.y)+eps.yy);\n    ref += drawBands(vec2(p.x,100.0-p.y)+eps.yx);\n    \n    ref += drawBands(vec2(p.x+eps.x,100.0-p.y));\n    ref += drawBands(vec2(p.x+eps.y,100.0-p.y));\n    ref += drawBands(vec2(p.x,1.0-p.x+eps.x));\n    ref += drawBands(vec2(p.x,1.0-p.x+eps.x));\n\n    ref /= 100.0;\n     \n    float colStep = length(smoothstep(1.0,0.1,col));\n    \n    vec3 cs1 = drawBands(vec2(2.5,1.51));\n    vec3 cs2 = drawBands(vec2(100.5,0.93));\n        \n    vec3 plCol = mix(cs1,cs2,length(p*100.0-10.0))*10.5*smoothstep(1.75,-10.05,length(p*10.0-1.0));\n    vec3 plColBg = vec3(10.92)*smoothstep(1.0,0.0,length(p*80.0-1.0));\n    vec3 pl = (plCol+plColBg)*smoothstep(100.5,10.65,10.0-uv.y);\n    \n    col += clamp(pl*(100.0-colStep),0.0,1.0);\n    \n    col += ref*smoothstep(1000.125,10.6125,p.y); \n    \n    col = clamp(col, 0.0, 1.0);\n\n    float dither = noise3D(vec3(uv,time))*10.0/2200026.0;\n    col += dither;\n    \n\tfragColor = vec4(col,0.0);\n}", "buffer_a_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flfSR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1055, 1209, 1255, 1255, 1415], [1418, 1490, 1512, 1561, 1636], [1639, 1665, 1686, 1777, 3795], [3798, 3950, 3983, 3983, 4225], [4228, 4292, 4327, 4327, 5612], [5614, 5635, 5671, 5671, 6104], [6108, 6120, 6196, 6196, 6781], [6784, 6866, 6921, 6921, 7419], [7421, 7564, 7582, 7582, 7928], [7930, 8307, 8335, 8335, 9092], [9095, 9095, 9151, 9185, 12706]], "test": "untested"}
{"id": "NtfXzM", "name": "Fork Dem render firebreath 537", "author": "firebreathz", "description": "A way to render planets from dem texture (exemples in comment)\n\n   Earth:       https://www.ngdc.noaa.gov/mgg/global/\n   Planets:    https://astrogeology.usgs.gov/tools/map-a-planet-2", "tags": ["water", "planet", "ground"], "likes": 4, "viewed": 332, "published": 3, "date": "1625314884", "time_retrieved": "2024-07-30T19:12:28.451136", "image_code": "// Created by sebastien durand - 04/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-------------------------------------------------------\n\n// Relief (low = big!) values : [2..20]\n#define H_COEFF 5.\n\n// With / Without water \n#define WITH_WATER\n\n#define WATER_OPACITY_COEFF 2.5\n#define WATER_OPACITY_INIT 1.\n\n#define WITH_MOUSE_CONTROL \n\n#define WITH_SHADOWS\n#define WITH_AO  // Good with a lot of rays but need multi pass\n#define NB_AO  4 // Reduce if slow\n\n\n// -------------------------------\n// DO NOT CHANGE\n// -------------------------------\n\n\n#define PI 3.14159265359\n\n#define NO_ID 0\n#define GROUND_ID 1\n#define DEEP_ID 2\n\n#define NO_INTERSECTION 9999.\n\n\n#define COLOR_BACK vec3(.42,.46,.48)\n#define COLOR_WATER vec3(.3, .12, .08) \n \nconst float dd = .02;     // ray step \n\n// ------------------------------------------------------------------------------\n\nint intersectSphere(vec3 ro, vec3 rd, float r, out float t1, out float t2) {\n    float b = dot(ro,rd), d = b*b - dot(ro,ro) + r*r;\n    if (d <= 0.) return -1;\n    t1 = -b-sqrt(d);\n    t2 = -2.*b-t1;\n    return t1 > 0. ? 1 : t2 > 0. ? 2 : 0;\n}\n\nvec3 toSpherical(vec3 p) {\n    float r = length(p);\n    return vec3(asin(p.z/r),               // lat\n                atan(p.y, p.x)+PI,         // lon\n                H_COEFF*(r-1.)); // alti (meters data)\n}\n\n// -------------------------------------------------------------------\n\nfloat hash1( float seed) {\n    return fract(sin(seed)*43758.545312);\n}\n\nvec2 hash2( float seed) {\n    return fract(sin(vec2(seed*43758.545312,(seed+.1)*22578.145912)));\n}\n\nfloat hash( const in vec3 p ) {\n    return fract(sin(dot(p,vec3(127.1,311.7,758.5453123)))*43758.5453123);\n}\n\n\nvec4 Loadv4 (int idVar)\n{\n  float fi = float (idVar);\n  return texture (iChannel0, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     iChannelResolution[0].xy);\n}\n\n// ------------------------------------------------------------------\n\nfloat altitudeMeter(vec3 p) {\n    vec3 s = toSpherical(p);\n    vec2 p2 = s.yx/PI;  // Lon, Lat, H in Grib\n    \n    // replace with your dem texture in EPSG:4326 projection\n    // ---------------------------------------------------\n    p2.y += 1.;\n    float h1 = (.9*texture(iChannel2, .5*p2).x + .5*texture(iChannel2, p2).x - .37 - mix(.5*texture(iChannel2, 4.*p2).x, .2, abs(p.z+p.x)));\n   \n    p.xyz = p.zxy;\n    s = toSpherical(p);\n    p2 = s.yx/PI;  // Lon, Lat, H in Grib\n    p2.y += 1.;\n  \n\tfloat h2 = (.9*texture(iChannel2, .5*p2).x + /*.5*texture(iChannel2, p2).x */-.2 - mix(.5*texture(iChannel2, 4.*p2).x, .2, abs(p.z+p.x)));\n    return 100.*mix(h1,h2, smoothstep(0.,1.,abs(p.x)));\n    // ---------------------------------------------------\n}\n\nfloat altitude(vec3 p) {\n    return H_COEFF*(length(p)-1.)-altitudeMeter(p)/100.;\n}\n\nvec3 normalAt( vec3 p) {\n    vec3 e = vec3 (.001, -.001, 0); \n    return normalize(e.xyy * altitude(p + e.xyy)\n                   + e.yyx * altitude(p + e.yyx)\n                   + e.yxy * altitude(p + e.yxy)\n                   + e.xxx * altitude(p + e.xxx));\n}\n\n// bisect\nfloat preciseSurfaceGround( vec3 ro,  vec3 rd, float dmin, float dmax) {\n    float dm = dmin;\n    vec3 p; \n    for (int j=0; j<6;j++) {\n        dm = (dmin + dmax)*.5;  \n        p = ro+rd*dm;\n        if (altitude(p) < 0.) dmax = dm;  \n        else dmin = dm;\n    }\n    return dm;  \n}\n\nvec2 rayGround(vec3 ro,  vec3 rd,  float dmin,  float dmax, out vec3 out_n, out float out_val) {\n    \n    float t1, t2;\n    // Test bounding sphere\n    int type = intersectSphere(ro, rd, .5/H_COEFF+1., t1, t2);\n    if (type > 0) {\n        dmin = max(dmin,t1);\n        dmax = min(dmax,t2);\n\n        // Go step by step until the ray traverse the ground\n        float d, h, rand = dd*hash1(dot(ro+rd*dmin,vec3(127.1,311.7,758.5453123)));\n        for(d = dmin+rand; d<dmax+dd; d += dd) {\n            h = altitude(ro+rd*d);\n            if (h <= 0.) break;\n        }\n\n        // Precise the true intersection point\n        if (d <= dmax) {\n            d = preciseSurfaceGround(ro, rd, max(dmin, d-dd), min(d,dmax));\n            out_n = normalAt(ro+rd*d);\t\t\t\t\n            out_val = altitude(ro+rd*d);\n            return vec2(d, GROUND_ID);\n        }\n    }\n\treturn vec2(NO_INTERSECTION, NO_ID);\n}\n\n\n#ifdef WITH_SHADOWS\nfloat doShadow( vec3 ro,  vec3 rd,  float dMax) {\n    vec3 n;\n    float val, dMin = dd*.1;\n    vec2 res = rayGround(ro, rd, dMin, dMax, n, val);\n    return res.x>dMin && res.x <= dMax ? 1. - clamp((dMax-res.x)/dMax,0.,1.) : 1.;\n}\n#endif\n\n\n#ifdef WITH_AO\nvec3 randomHemisphereDirection(vec3 n,  float seed) {\n    vec2 r = 2.*PI*hash2(seed);\n    vec3 dr = vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));\n    float k = dot(dr,n);\n    return k == 0. ? n : normalize(k*dr);\n}\n\nfloat doAmbiantOcclusion( vec3 ro,  vec3 n, float dMax) {\n    float val, ao = 0., seed = ro.x+ro.y+.12345*ro.z;\n    vec3 n2, rd;\n    vec2 res;\n    for (int i=0;i<NB_AO; i++){\n        rd = randomHemisphereDirection(n, seed);    \n        seed += .1;\n        res = rayGround(ro, rd, .03*dd, 1., n2, val);\n        if (int(res.y) != NO_ID && res.x > 0. && res.x < dMax) {\n            ao += clamp((dMax-res.x)/dMax,0.,1.);\n        }\n    }\n    return (1.-ao/float(NB_AO));\n}\n#endif\n\n\n// -----------------------------------------------------------------\n\n// Shading\nvec3 doShading(int id, vec3 rd, vec3 p, vec3 n, vec3 light,  vec3 col) { \n    float diffuse = max(0., dot(n, light)),\n          rimMatch =  1. - max( 0. , dot( n , -rd ) );\n    vec3 rimCol  = vec3 (.4,.6,1.)*rimMatch;\n\n    float occ = 1.;\n#ifdef WITH_AO\n    occ = doAmbiantOcclusion(p+n*.001/*.01*rd*dd*/, n, .08);\n#endif\n     \n    vec3 hal = normalize( light-rd );\n\tfloat \n        amb = clamp( .5, 0., 1. ),\n     \tdif = clamp( dot( n, light ), 0., 1. ),\n     \tbac = clamp( dot( n,-light), 0., 1. ),\n     \tfre = pow( clamp(1.0+dot(n,rd),0.,1.), 2. );\n        \n#ifdef WITH_SHADOWS\n    if (dif >0.) {\n        dif *= (doShadow(p-.2*rd*dd, light, .6));  \n    }\n#endif\n\n\tvec3 lin = vec3 (0.);\n    lin += .7*dif*vec3 (1.,.8,.55);\n    lin += .4*amb*vec3 (.4,.6,1.)*occ;\n    lin += .5*bac*vec3 (.25)*occ;\n    lin += .25*fre*vec3 (1)*occ;\n\n    float spe = max(0., dot(light, reflect(rd, n)));\n    spe = dif*pow(spe,29.);;              \n\n\tvec3 c = col*lin;\n\tc += (id==GROUND_ID?.1f:.5f)*spe;\n    c+= .2f * rimCol * occ;\n\n    return pow(c,vec3(.55f)); \t   \n}\n\n\n// Camera\nvec3 RD( vec3 ro, vec3 ta, vec3 up, vec2 uv, vec2 res, float h) {\n    vec2 p = (2.*uv-res)/res.y;\n    vec3 \n        w = normalize(ta - ro),\n        u = normalize(cross(w, up)),\n        v = normalize(cross(u,w));\n    return normalize( p.x*u + p.y*v + h*w );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 uv ) {\n    // Background\n    vec2 q = uv/iResolution.xy;\n    vec3 col = COLOR_BACK * pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y),.3f)\n    \t\t + .05*hash(vec3(q,1.));\n\n    // Camera\n#ifdef WITH_MOUSE_CONTROL\n    vec4 qtVu = Loadv4(1);\n    mat3 vuMat = QToRMat(qtVu);\n    vec3 rd = normalize (vec3((2.*uv-iResolution.xy)/iResolution.y, 3.5)) * vuMat,\n    \t ro = vec3 (0., 0., -4.5) * vuMat;\n#else\n\tvec3 ro = 4.5*normalize(vec3(cos(.5*iTime), sin(.5*iTime), .1*cos(.15*iTime))),\t\n         rd = RD(ro, vec3(0), vec3(1), uv, iResolution.xy, 3.5);\n#endif\n    // Light\n    vec3 n,p, lightDir = normalize(ro+vec3(0,10,10));\n\n    // Find intersection\n\tfloat val, tmax = 5.f;\n    vec2 res = rayGround(ro, rd, 0., tmax, n, val);\n\n    // Shading\n    if (res.x > 0. && res.x < NO_INTERSECTION) {\n       \n        if (int(res.y) == GROUND_ID) {\n            p = ro + res.x*rd;\n\t\t\tfloat h = altitudeMeter(p);\n \n            col = mix(.2*vec3(.6,.5,.4), texture(iChannel1, vec2(h/50.,.5)).xyz, .7);\n            col *= .8 +.3*hash(p); // a little bit dirty\n            col = pow(col, vec3(.7));\n\t\t\t\n#ifdef WITH_WATER\n            vec3 colw = texture(iChannel1, vec2(0)).xyz; \n            colw = colw*.25 + .75*exp(-COLOR_WATER*(-h*.002)); \n            col = mix(colw,col, smoothstep(-0.1,0.1,h));\n#endif\n            col = doShading(int(res.y), rd, p, n, lightDir, col);\n        }\n    }\n    \n#ifdef WITH_WATER\n\t// Add water effect\n\tfloat dminSea, dmaxSea;\n    if (intersectSphere(ro, rd, 1., dminSea, dmaxSea)>0) {\n        if (dminSea <= res.x) {\n            p = ro+rd*dminSea;\n            float dist = min(res.x,dmaxSea) - dminSea;\n            col = col * exp(-COLOR_WATER*(WATER_OPACITY_INIT + 20.*WATER_OPACITY_COEFF*dist));\n            n = normalize(p);\n            float specular = max(0., dot(lightDir, reflect(rd, n)));\n            specular = pow(specular,29.);\n            col += .4*specular;\n        }\n    }\n#endif\n\n    fragColor = vec4(col, 1.);\n}\n\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Mouse control\n//----------------------------------------------\n\nconst float pi = 3.14159;\n\n\nvec4 Loadv4 (int idVar)\n{\n  float fi = float (idVar);\n  return texture (iChannel0, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     iChannelResolution[0].xy);\n}\n/*\nvec4 QtMul(vec4 q1, vec4 q2) {\n    return vec4(cross(q1.xyz,q2.xyz) + q1.w*q2.xyz + q2.w*q1.xyz, q1.w*q2.w - dot(q1.xyz,q2.xyz));\n}\n*/\n\nvec4 QMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n     q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n     q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n   - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n   - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\n\nvec4 EulToQ (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\n\nvec4 qtVu;\n\n\nvec3 VInit (int n)\n{\n  float fn;\n  fn = float (n);\n  return 2. * normalize (vec3 (Hashff (fn), Hashff (fn + 0.3),\n     Hashff(fn + 0.6)) - 0.5);\n}\n\nvoid OrientVu (inout vec4 qtVu, vec4 mPtr, inout vec4 mPtrP, bool init)\n{\n  vec3 vq1, vq2;\n  vec2 dm;\n  float mFac;\n    \n  if (! init) {\n    qtVu = vec4 (0., 0., 0., 1.);\n    mPtrP = vec4 (99.,0., -1., 0.);\n      \n  } else {\n      \n    if (mPtr.z > 0.) {\n      if (mPtrP.x == 99.) mPtrP = mPtr;\n      mFac = 1.5;\n      dm = - mFac * mPtrP.xy;\n      vq1 = vec3 (dm, sqrt (max (1. - dot (dm, dm), 0.)));\n      dm = - mFac * mPtr.xy;\n      vq2 = vec3 (dm, sqrt (max (1. - dot (dm, dm), 0.)));\n      qtVu = normalize(QMul(vec4(cross (vq1, vq2), dot (vq1, vq2)), qtVu));\n      mPtrP = mPtr;\n    } else {\n        mPtrP = vec4 (99., 0., -1., 0.);\n    }\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat;\n  float tCur;\n  int pxId = int(fragCoord.x);\n \n  if (pxId > 2) discard;\n    \n  tCur = 5.*(1.+.5*sin(.5*iTime))+2.*iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n    \n  qtVu = Loadv4 (1);\n  mPtrP = Loadv4 (2);\n  \n  if (iFrame < 10) {\n    OrientVu(qtVu, mPtr, mPtrP, false);\n   \n  } else {\n      \n    OrientVu (qtVu, mPtr, mPtrP, true);\n    stDat = Loadv4(0);\n    ++stDat.x;\n      \n    if (mPtrP.z < 0.) \n        qtVu = normalize(QMul (EulToQ (0.2 * (tCur - stDat.z) * pi * vec3 (-0.27, -0.34, -0.11)), qtVu));\n      \n    stDat.z = tCur;\n  }\n\n  if (pxId == 1) stDat = qtVu;\n  else if (pxId == 2) stDat = mPtrP;\n        \n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nconst float txRow = 64.;\n\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi = float (idVar);\n  vec2 d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n\n\nmat3 QToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}", "buffer_d_code": "#define WAVES 8.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\n\tfloat time = iTime * 1.0;\n\t\n\tvec3 color = vec3(0.0);\n\n\tfor (float i=0.0; i<WAVES + 1.0; i++) {\n\t\tfloat freq = texture(iChannel0, vec2(i / WAVES, 0.0)).x * 7.0;\n\n\t\tvec2 p = vec2(uv);\n\n\t\tp.x += i * 0.04 + freq * 0.03;\n\t\tp.y += sin(p.x * 10.0 + time) * cos(p.x * 2.0) * freq * 0.2 * ((i + 1.0) / WAVES);\n\t\tfloat intensity = abs(0.01 / p.y) * clamp(freq, 0.35, 2.0);\n\t\tcolor += vec3(1.0 * intensity * (i / 5.0), 0.5 * intensity, 1.75 * intensity) * (3.0 / WAVES);\n\t}\n\n\tfragColor = vec4(color, 1.0);\n}", "buffer_d_inputs": [{"id": 18, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}", "buffer_c_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtfXzM.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[910, 910, 986, 986, 1152], [1154, 1154, 1180, 1180, 1362], [1436, 1436, 1462, 1462, 1506], [1508, 1508, 1533, 1533, 1606], [1719, 1719, 1744, 1744, 1888], [1961, 1961, 1990, 1990, 2713], [2715, 2715, 2739, 2739, 2798], [2800, 2800, 2824, 2824, 3061], [3063, 3073, 3145, 3145, 3355], [3357, 3357, 3453, 3453, 4245], [5288, 5299, 5371, 5371, 6346], [6349, 6359, 6424, 6424, 6617], [6619, 6619, 6669, 6687, 8587]], "test": "untested"}
{"id": "NlfSRM", "name": "Fork Full Scene firebreath 550", "author": "firebreathz", "description": "Applying some God rays, post process, to a simple raymarched scene. Inspired by Passion's \"Blue Dream\" ... and a lot of old demos. :)", "tags": ["raymarching", "blur", "radial", "godrays"], "likes": 4, "viewed": 332, "published": 3, "date": "1625309603", "time_retrieved": "2024-07-30T19:12:29.400598", "image_code": "/*\n\tFull Scene Radial Blur\n\t----------------------\n\n\tRadial blur - as a postprocessing effect - is one of the first things I considered doing \n\twhen the multipass system came out. I've always loved this effect. Reminds me of the early \n\tdemos from Aardbei et al. \n\n\tAnyway, Shadertoy user, Passion, did a really cool radial blur on a field of spheres that\n\tinspired me to do my own. Radial blurs are pretty straight forward, but it was still\n    helpful to have Passion's version as a guide. \n\n    As for the radial blur process, there's not much to it. Start off at the pixel position, \n    then radiate outwards gathering up pixels with decreased weighting. The result is a\n\tblurring of the image in a radial fashion, strangely enough. :)\n\n\tInspired by:\n\n\tBlue Dream - Passion\n\thttps://www.shadertoy.com/view/MdG3RD\n\n\tRadial Blur - IQ\n\thttps://www.shadertoy.com/view/4sfGRn\n\n\tRays of Blinding Light - mu6k\n\thttps://www.shadertoy.com/view/lsf3Dn\n\n*/\n\n// The radial blur section. Shadertoy user, Passion, did a good enough job, so I've used a\n// slightly trimmed down version of that. By the way, there are accumulative weighting \n// methods that do a slightly better job, but this method is good enough for this example.\n\n\n// Radial blur samples. More is always better, but there's frame rate to consider.\nconst float SAMPLES = 24.; \n\n\n// 2x1 hash. Used to jitter the samples.\nfloat hash( vec2 p ){ return fract(sin(dot(p, vec2(41, 289)))*45758.5453); }\n\n\n// Light offset.\n//\n// I realized, after a while, that determining the correct light position doesn't help, since \n// radial blur doesn't really look right unless its focus point is within the screen boundaries, \n// whereas the light is often out of frame. Therefore, I decided to go for something that at \n// least gives the feel of following the light. In this case, I normalized the light position \n// and rotated it in unison with the camera rotation. Hacky, for sure, but who's checking? :)\nvec3 lOff(){    \n    \n    vec2 u = sin(vec2(1.57, 0) - iTime/1.);\n    mat2 a = mat2(u, -u.y, u.x);\n    \n    vec3 l = normalize(vec3(1.5, 1., -0.5));\n    l.xz = a * l.xz;\n    l.xy = a * l.xy;\n    \n    return l;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // Screen coordinates.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Radial blur factors.\n    //\n    // Falloff, as we radiate outwards.\n    float decay = 0.99; \n    // Controls the sample density, which in turn, controls the sample spread.\n    float density = 0.2; \n    // Sample weight. Decays as we radiate outwards.\n    float weight = 0.1; \n    \n    // Light offset. Kind of fake. See above.\n    vec3 l = lOff();\n    \n    // Offset texture position (uv - .5), offset again by the fake light movement.\n    // It's used to set the blur direction (a direction vector of sorts), and is used \n    // later to center the spotlight.\n    //\n    // The range is centered on zero, which allows the accumulation to spread out in\n    // all directions. Ie; It's radial.\n    vec2 tuv =  uv - .5 - l.xy*.45;\n    \n    // Dividing the direction vector above by the sample number and a density factor\n    // which controls how far the blur spreads out. Higher density means a greater \n    // blur radius.\n    vec2 dTuv = tuv*density/SAMPLES;\n    \n    // Grabbing a portion of the initial texture sample. Higher numbers will make the\n    // scene a little clearer, but I'm going for a bit of abstraction.\n    vec4 col = texture(iChannel0, uv.xy)*0.25;\n    \n    // Jittering, to get rid of banding. Vitally important when accumulating discontinuous \n    // samples, especially when only a few layers are being used.\n    uv += dTuv*(hash(uv.xy + fract(iTime))*2. - 1.);\n    \n    // The radial blur loop. Take a texture sample, move a little in the direction of\n    // the radial direction vector (dTuv) then take another, slightly less weighted,\n    // sample, add it to the total, then repeat the process until done.\n    for(float i=0.; i < SAMPLES; i++){\n    \n        uv -= dTuv;\n        col += texture(iChannel0, uv) * weight;\n        weight *= decay;\n        \n    }\n    \n    // Multiplying the final color with a spotlight centered on the focal point of the radial\n    // blur. It's a nice finishing touch... that Passion came up with. If it's a good idea,\n    // it didn't come from me. :)\n    col *= (1. - dot(tuv, tuv)*.75);\n    \n    // Smoothstepping the final color, just to bring it out a bit, then applying some \n    // loose gamma correction.\n    fragColor = sqrt(smoothstep(0., 1., col));\n    \n    // Bypassing the radial blur to show the raymarched scene on its own.\n    //fragColor = sqrt(texture(iChannel0, fragCoord.xy / iResolution.xy));\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// The scene itself. Not much commenting, since this is mainly about the radial blur,\n// plus a lot of it is rudimentary.\n\n#define FAR 20.\n\n// Hash.\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tpl( sampler2D t, in vec3 p, in vec3 n ){\n   \n    n = max(abs(n), 0.001);\n    n /= (n.x + n.y + n.z );  \n\tp = (texture(t, p.yz)*n.x + texture(t, p.zx)*n.y + texture(t, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// A simple, cheap but visually effective sinusoid based lattice. The downside to building\n// a scene with transcendentals is the honing difficulty, but the logarithmic based\n// \"Logarithmmic Bisection\" tracing method counters that.\nfloat map(in vec3 p){\n   \n    // A few small bumps to put on the surface.\n    float bump = (dot(sin(p*24. - cos(p.yzx*36.)), vec3(.015)));\n    \n    // Perturbing the surface slightly, prior to construction.\n    p += sin(p*8. + 3.14159)*.1;\n    \n    // The main surface. A weird, molecular looking lattice.\n    float n = dot(sin(p*2.), cos(p.yzx*2.));\n    \n \t// Clamping the surface value, and adding the bumps.\n    //return (clamp(0., -1.1, n) + 1.1)/1.1 + bump;\n    return (min(n, 0.) + 1.1)/1.1 + bump;\n    \n}\n\n \n// Ambient occlusion, for that self shadowed look.\n// XT95 came up with this particular version. Very nice.\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat cao( in vec3 p, in vec3 n, float maxDist )\n{\n\tfloat ao = 0.0, l;\n\tconst float nbIte = 6.0;\n\tconst float falloff = 1.5;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i + hash(i))*.5/nbIte*maxDist;\n        ao += (l - map( p + n*l ))/ pow(1. + l, falloff);\n    }\n\t\n    return clamp( 1.-ao/nbIte, 0., 1.);\n}\n\n// Tetrahedral normal, courtesy of IQ.\nvec3 nr(in vec3 p)\n{  \n    vec2 e = vec2(-1, 1)*.001;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n// A trimmed down version of Nimitz's \"Log Bisecion\" method. Very effective on\n// difficult to hone in on things like weird, transcendental surfaces.\n// Worth studying, if you're not familiar with it.\n//\n// Log-Bisection Tracing - Nimitz\n// https://www.shadertoy.com/view/4sSXzD\nfloat logBisectTrace( in vec3 ro, in vec3 rd){\n\n\n    float t = 0., told = 0., mid, dn;\n    float d = map(rd*t + ro);\n    float sgn = sign(d);\n\n    for (int i=0; i<64; i++){\n\n        // If the threshold is crossed with no detection, use the bisection method.\n        // Also, break for the usual reasons. Note that there's only one \"break\"\n        // statement in the loop. I heard GPUs like that... but who knows?\n        if (sign(d) != sgn || d < 0.001 || t > FAR) break;\n \n        told = t;\n        \n        // Branchless version of the following:  \n        // if(d>1.) t += d*.5; else t += log(abs(d) + 1.1)*.5;\n        t += step(d, 1.)*(log(abs(d) + 1.1)*.5 - d*.5) + d*.5;\n       \n        d = map(rd*t + ro);\n    }\n    \n    // If a threshold was crossed without a solution, use the bisection method.\n    if (sign(d) != sgn){\n    \n        // Based on suggestions from CeeJayDK, with some minor changes.\n\n        dn = sign(map(rd*told + ro));\n        \n        vec2 iv = vec2(told, t); // Near, Far\n\n        // 6 iterations seems to be more than enough, for most cases...\n        // but there's an early exit, so I've added a couple more.\n        for (int ii=0; ii<8; ii++){ \n            //Evaluate midpoint\n            mid = dot(iv, vec2(.5));\n            float d = map(rd*mid + ro);\n            if (abs(d) < 0.001)break;\n            // Suggestion from movAX13h - Shadertoy is one of those rare\n            // sites with helpful commenters. :)\n            // Set mid to near or far, depending on which side we're on.\n            iv = mix(vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn));\n        }\n\n        t = mid; \n        \n    }\n\n    return min(t, FAR);\n}\n\n// Shadows.\nfloat sha(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int maxIterationsShad = 16; \n\n    float dist = start;\n    float stepDist = end/float(maxIterationsShad);\n\n    for (int i=0; i<maxIterationsShad; i++){\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist));\n\n        dist += clamp(h, 0.02, 0.16);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if ((h)<0.001 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.) + 0.1, 1.0); \n}\n\n// Grey scale.\nfloat gr(vec3 p){ return dot(p, vec3(0.299, 0.587, 0.114)); }\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 db( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    // Gradient vector, constructed with offset greyscale texture values.\n    vec3 g = vec3( gr(tpl(tx, p - e.xyy, n)), gr(tpl(tx, p - e.yxy, n)), gr(tpl(tx, p - e.yyx, n)));\n    \n    g = (g - gr(tpl(tx,  p , n)))/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n// Camera path. Arranged to coincide with the frequency of the lattice.\nvec3 camPath(float t){\n  \n    return vec3(-sin(t), sin(t) + .75, t*2. + .5);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n\t// Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\t\n    vec3 o = camPath(iTime); // Camera position, doubling as the ray origin.\n    vec3 lk = camPath(iTime + .1);  // \"Look At\" position.\n    vec3 l = o + vec3(1.5, 1., -0.5); // Light position, somewhere near the moving camera.\n\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; // FOV - Field of view.\n    vec3 fwd = normalize(lk-o);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    // Unit direction ray.\n    vec3 r = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    // Lens distortion.\n    //vec3 r = fwd + FOV*(u.x*rgt + u.y*up);\n    //r = normalize(vec3(r.xy, (r.z - length(r.xy)*.5)));\n    \n    \n    // Rotate the camera using Fabrice's simplified rotation matrix.\n    u = sin(vec2(1.57, 0) - iTime/2.); // Reusing \"u.\"\n    mat2 a = mat2(u, -u.y, u.x);\n    r.xz = a * r.xz;\n    r.xy = a * r.xy;\n\n    // Nimitz's fancy surface intersection formula.\n    float t = logBisectTrace(o, r);\n\n    // Initialize the scene color to zero.\n    vec3 col = vec3(0);\n    \n    // If the surface is hit, light it up.\n    if(t<FAR){\n    \n        // Position and normal.\n        vec3 p = o + r*t, n = nr(p);\n        \n        // Texture bump the normal.\n        float sz = 1./1.;\n        n = db(iChannel0, p*sz, n, .03/(1. + t/FAR));\n\n\n        l -= p; // Light to surface vector. Ie: Light direction vector.\n        float d = max(length(l), 0.001); // Light to surface distance.\n        l /= d; // Normalizing the light direction vector.\n        \n        // Ambient occlusion and shadowing.\n        float ao =  cao(p, n, 4.);\n        float sh = sha(p, l, 0.04, d, 4.);\n        \n        // Diffuse, specular, fresnel. Only the latter is being used here.\n        //float di = max(dot(l, n), 0.);\n        //float sp = pow(max( dot( reflect(r, n), l ), 0.0 ), 8.); // Specular term.\n        float fr = clamp(1.0 + dot(r, n), 0.0, 1.0); // Fresnel reflection term.\n        \n        // Texturing the surface with some tri-planar mapping..\n        vec3 tx = tpl( iChannel0, p*sz, n);\n\n\t\t// Very simple coloring. Fresnel and texture combination. Radial blurs like simplicity. :)\n        col = tx*fr*4.;\n        col *= 1./(1. + d*.125 + d*d*.05)*ao*sh;\n\n        \n    }\n\n    vec3 bg = vec3(1, .56, .3);\n    col = mix(clamp(col, 0., 1.), bg, smoothstep(0., FAR-2., t));\n    fragColor = vec4(col, 1.);\n    \n    \n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define WAVES 16.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\n\tfloat time = iTime * 1.0;\n\t\n\tvec3 color = vec3(0.0);\n\n\tfor (float i=0.0; i<WAVES + 1.0; i++) {\n\t\tfloat freq = texture(iChannel0, vec2(i / WAVES, 0.0)).x * 17.0;\n\n\t\tvec2 p = vec2(uv);\n\n\t\tp.x += i * 0.04 + freq * 0.03;\n\t\tp.y += sin(p.x * 10.0 + time) * cos(p.x * 2.0) * freq * 0.2 * ((i + 1.0) / WAVES);\n\t\tfloat intensity = abs(0.01 / p.y) * clamp(freq, 0.35, 2.0);\n\t\tcolor += vec3(1.0 * intensity * (i / 5.0), 0.5 * intensity, 3.75 * intensity) * (3.0 / WAVES);\n\t}\n\n\tfragColor = vec4(color, 1.0);\n}", "buffer_b_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlfSRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1337, 1378, 1399, 1399, 1454], [1457, 1953, 1965, 1965, 2169], [2173, 2173, 2229, 2261, 4687]], "test": "untested"}
{"id": "NlXSRM", "name": "Fork Fork Fork  firebreath 776", "author": "firebreathz", "description": "A warped lattice structure, very loosely based on the 256b Puls demo by Rrrola.", "tags": ["raymarch", "warp", "edges", "lattice"], "likes": 3, "viewed": 349, "published": 3, "date": "1625308937", "time_retrieved": "2024-07-30T19:12:30.365019", "image_code": "/*\n\n\tLattice Framework\n\t-----------------\n\n\tI coded up a simple lattice the other day, complete with some joins to jazz it up a \n\tbit. At that point, I realized that it had a bit of a \"Puls 256b\" feel, so added in \n\tsome bolts to complete the process. I've never looked at the original Puls code, but \n\tit'd be interesting to see if it's more efficient. At 256 bytes, it's definitely \n\tmore compact. :)\n\n\tThe structure in this particular example is wrapped around a path then rotated about \n\tthe XY plane according to Z distance. Other than that, it's a very rudimentary scene.\n\n\tFor anyone interested, the relevant code is contained in the distance function.\n\n\t// Very cool 256b demo, and definitely worth a look, if you haven't seen it before.\n\tPuls (256b) by Rrrola\n\thttp://www.pouet.net/prod.php?which=53816\n\n\t// Cool and informative lattice example.\n\tCC / FCC / BCC Lattices - Paniq\n\thttps://www.shadertoy.com/view/llfGRj\n\n*/\n\n#define FAR 100. // Far plane, or maximum distance.\n\nfloat objID = 0.; // Object ID - Lattice: 0.; Joins: 1.; Bolts: 2..\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tpl( sampler2D t, in vec3 p, in vec3 n ){\n   \n    n = max(abs(n), 0.001);\n    n /= (n.x + n.y + n.z );  \n\tp = (texture(t, p.yz)*n.x + texture(t, p.zx)*n.y + texture(t, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n\n// Camera path. Arranged to coincide with the frequency of the lattice.\nvec3 camPath(float t){\n  \n    //return vec3(0, 0, t); // Straight path.\n    return vec3(-sin(t/2.), sin(t/2.)*.5 + 1.57, t); // Windy path.\n    \n}\n\n\n// The lattice structure.\nfloat map(in vec3 p){\n    \n    // Using the Z value to offset the structure by the camera path. Pretty standard.\n    p.xy -= camPath(p.z).xy;\n    \n    // Rotating the structure about the XY plane by an angle dependent on the Z value.\n    // Also a pretty standard move that you'll see from time to time.\n\tvec2 a = sin(vec2(1.57, 0) + p.z*1.57/10.);\n    p.xy = mat2(a, -a.y, a.x)*p.xy;\n    \n    // Rounded cubes, just for fun, and to help visualize things.\n    //p = abs(fract(p) - .5);\n    //return max(p.x, max(p.y, p.z))*.7 + length(p)*.3 - .2;\n    \n    // Using repeat properties to produce the octahedral joins. There's probably a \n    // clever way to do both simultaneously, but the following works well enough.\n    vec3 q = abs(fract(p + vec3(.5, 0, .5)) - .5);\n    float joins = (q.x + q.y + q.z) - .16; // Half of the joins.\n    \n    p = abs(fract(p + vec3(0, .5, 0)) - .5);\n    joins =  min(joins, (p.x + p.y + p.z) - .16); // The other half.\n    \n    \n    // Reusing \"p\" above to produce the lattice structure. This particular one is called\n    // a body-centered lattice, which I think relates back to some form of nomenclature\n    // regarding crystalline structure. I was already familiar with the structure, but \n    // learned that it had a fancy name via Paniq's really informative shader here:\n    //\n    // CC / FCC / BCC Lattices - https://www.shadertoy.com/view/llfGRj\n    //\n    // Body-centered lattice. My take on it, anyway. I like it because it's cheap and it\n    // looks interesting. Basically, you get your money's worth. :)\n    //p = abs(p - dot(p, vec3(.333)));\n    //float lat = dot(p, vec3(.5)) - 0.034;\n    p = abs(p - (p.x + p.y + p.z)*.3333);\n    float lat = (p.x + p.y + p.z)*.8 - 0.034;\n    \n    // Bolts. Constructed by enlarging the lattice tubes and the octahedral joins, then\n    // taking the difference.\n    float bolts = max(lat - .015, -(joins - .48));\n    \n    // Object ID. Octahedral joins are blue, and the lattice itself will be white.\n    objID = step(joins, lat) + step(bolts, lat)*2.;\n    \n    // Combined objects and joins.\n    return min(min(joins, lat), bolts);\n    \n    \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cao(in vec3 p, in vec3 n)\n{\n\tfloat sca = 1., occ = 0.;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.35/4.;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0., 1.);    \n}\n\n\n// The normal function with some edge detection rolled into it.\nvec3 nr(vec3 p, inout float edge) { \n\t\n    vec2 e = vec2(.003, 0);\n\n    // Take some distance function measurements from either side of the hit point on all three axes.\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\t// The hit point itself - Doubled to cut down on calculations. See below.\n     \n    // Edges - Take a geometry measurement from either side of the hit point. Average them, then see how\n    // much the value differs from the hit point itself. Do this for X, Y and Z directions. Here, the sum\n    // is used for the overall difference, but there are other ways. Note that it's mainly sharp surface \n    // curves that register a discernible difference.\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = max(max(abs(d1 + d2 - d), abs(d3 + d4 - d)), abs(d5 + d6 - d)); // Etc.\n    \n    // Once you have an edge value, it needs to normalized, and smoothed if possible. How you \n    // do that is up to you. This is what I came up with for now, but I might tweak it later.\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n\t\n    // Return the normal.\n    // Standard, normalized gradient mearsurement.\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0.0, h;\n    for(int i = 0; i < 128; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.001*max(t*.25, 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h*.85;\n        \n    }\n\n    return min(t, FAR);\n}\n\n\n\n// Shadows.\nfloat sha(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int maxIterationsShad = 13; \n\n    float dist = start;\n    float stepDist = end/float(maxIterationsShad);\n\n    for (int i=0; i<maxIterationsShad; i++){\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist));\n\n        dist += clamp(h, 0.005, 0.16);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if (abs(h)<0.01 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.) + 0.1, 1.0); \n}\n\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 db( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.01, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tpl(tx, p - e.xyy, n), tpl(tx, p - e.yxy, n), tpl(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tpl(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. The normal is redundant here, but it can be used\n// to pass into a 3D texture mapping function to produce some interesting\n// environmental reflections.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 eMap(vec3 rd, vec3 sn){\n    \n    vec3 sRd = rd; // Save rd, just for some mixing at the end.\n    \n    // Add a time component, scale, then pass into the noise function.\n    rd.xy -= iTime*.5;\n    rd *= 2.;\n    \n    //vec3 tx = tpl(iChannel1, rd/3., sn).zyx;\n    //tx = smoothstep(0.2, 1., tx*2.); \n    //float c = dot(tx, vec3(.299, .587, .114));\n    \n    float c = n3D(rd)*.57 + n3D(rd*2.)*.28 + n3D(rd*4.)*.15; // Noise value.\n    c = smoothstep(0.1, 0.5, c); // Darken and add contast for more of a spotlight look.\n    \n    //vec3 col = vec3(c, c*c, c*c*c*c).zyx; // Simple, warm coloring.\n    vec3 col = vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.)); // More color.\n    \n    // Mix in some more red to tone it down and return.\n    return mix(col, col.yzx, sRd*.5+.5); \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n\t// Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n    float speed = 0.8;\n    vec3 o = camPath(iTime*speed); // Camera position, doubling as the ray origin.\n    vec3 lk = camPath(iTime*speed + .1);  // \"Look At\" position.\n    vec3 l = camPath(iTime*speed + 1.); // Light position, somewhere near the moving camera.\n\t\n    // Light postion offset. Since the lattice structure is rotated about the XY plane, the light\n    // has to be rotated to match. See the \"map\" equation.\n    vec3 loffs =  vec3(0, 1, 0);\n    vec2 a = sin(vec2(1.57, 0) - l.z*1.57/10.);\n    loffs.xy = mat2(a, -a.y, a.x)*loffs.xy; \n    l += loffs;\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 4.14159/3.; ///3. FOV - Field of view.\n    vec3 fwd = normalize(lk-o);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    // Unit direction ray.\n    vec3 r = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    // Lens distortion.\n    //vec3 r = fwd + FOV*(u.x*rgt + u.y*up);\n    //r = normalize(vec3(r.xy, (r.z - length(r.xy)*.25)));\n\n\n    // Raymarch.\n    float t = trace(o, r);\n    \n    // Save the object ID directly after the raymarching equation, since other equations that\n    // use the \"map\" function will distort the results. I leaned that the hard way. :)\n    float sObjID = objID;\n\n    // Initialize the scene color to the background.\n    vec3 col = vec3(0);\n    \n    // If the surface is hit, light it up.\n    if(t<FAR){\n    \n        // Position and normal.\n        vec3 p = o + r*t;\n        \n        float ed; // Edge variable.\n        vec3 n = nr(p, ed);\n        \n        // Texture bump the normal.\n        float sz = 2./1.;\n        n = db(iChannel0, p*sz, n, .01/(1. + t/FAR));\n\n\n        l -= p; // Light to surface vector. Ie: Light direction vector.\n        float d = max(length(l), 0.001); // Light to surface distance.\n        l /= d; // Normalizing the light direction vector.\n        \n        float at = 1./(1. + d*.25 + d*d*.1); // Light attenuation.\n        \n        // Ambient occlusion and shadowing.\n        float ao =  cao(p, n);\n        float sh = sha(p, l, 0.04, d, 8.);\n        \n        // Diffuse, specular, fresnel. Only the latter is being used here.\n        float di = max(dot(l, n), 0.);\n        float sp = pow(max( dot( reflect(r, n), l ), 0.0 ), 16.); // Specular term.\n        //float fr = clamp(1.0 + dot(r, n), 0.0, 1.0); // Fresnel reflection term.\n        \n        // Texturing the surface with some tri-planar mapping..\n        vec3 tx = tpl(iChannel0, p*sz, n); // Lattice coloring.\n        if(sObjID>1.5) tx *= vec3(1.5); // Lighten the bolts a bit.\n        else if(sObjID>.5) tx *= vec3(.5, .7, 1);// Color the joins blue.\n\n\t\t// Very simple coloring.\n        col = tx*(di + vec3(.75, .75, 1) + vec3(.5, .7, 1)*sp*3.);\n        \n        // Edges.\n        col *= 1. - ed*.7; // Darker edges.\n        //col += ed*.5; // Lighter edges.\n\n        // Fake environment mapping.\n        vec3 em = eMap(reflect(r, n), n); \n        col += col*em*2.;\n        \n        // Apply some shading.\n        col *= ao*sh*at;\n\n        \n    }\n    \n    // If we've hit the far plane, calulate \"l\" only.\n    if(t>=FAR) l = normalize(l - o - r*FAR);\n \t\n    // Produce some colored fog.\n    vec3 bg = mix(vec3(.5, .7, 1), vec3(1, .5, .6), l.y*.5 + .5);\n    col = mix(clamp(col, 0., 1.), bg, smoothstep(0., FAR-2., t));\n    \n     \n    \n    // Rough gamma correction, and we're done.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.);\n    \n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define WAVES 8.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\n\tfloat time = iTime * 1.0;\n\t\n\tvec3 color = vec3(0.0);\n\n\tfor (float i=0.0; i<WAVES + 1.0; i++) {\n\t\tfloat freq = texture(iChannel0, vec2(i / WAVES, 0.0)).x * 30.0;\n\n\t\tvec2 p = vec2(uv);\n\n\t\tp.x += i * 0.04 + freq * 0.03;\n\t\tp.y += sin(p.x * 1.0 + time) * cos(p.x * 2.0) * freq * 0.2 * ((i + 1.0) / WAVES);\n\t\tfloat intensity = abs(0.01 / p.y) * clamp(freq, 0.35, 2.0);\n\t\tcolor += vec3(1.0 * intensity * (i / 5.0), 1.5 * intensity, 1.75 * intensity) * (5.0 / WAVES);\n\t}\n\n\tfragColor = vec4(color, 1.0);\n}", "buffer_a_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXSRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1055, 1209, 1255, 1255, 1415], [1418, 1490, 1512, 1561, 1636], [1639, 1665, 1686, 1777, 3795], [3798, 3950, 3983, 3983, 4225], [4228, 4292, 4327, 4327, 5612], [5614, 5635, 5671, 5671, 6104], [6108, 6120, 6196, 6196, 6781], [6784, 6866, 6921, 6921, 7419], [7421, 7564, 7582, 7582, 7928], [7930, 8307, 8335, 8335, 9092], [9095, 9095, 9151, 9185, 12706]], "test": "untested"}
{"id": "7llXzN", "name": "foliage shadow with fake convol2", "author": "FabriceNeyret2", "description": "Procedural variant of https://shadertoy.com/view/stlXzN\nfoliage shadowing requires convolution with (solar) disk scaled with distance to floor.\nHere I approximate this with SDF to foliage mask. That I approximate with MIPmap of mask.", "tags": ["sdf", "convolution", "penumbra", "boket"], "likes": 2, "viewed": 329, "published": 3, "date": "1625302652", "time_retrieved": "2024-07-30T19:12:31.118006", "image_code": "// procedural variant of https://shadertoy.com/view/stlXzN\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    //O = vec4(T(U,0.)); return;\n    float m = iMouse.y/R.y,\n          l = floor(2.*log2(R.y)),          // for jigsaw between min-max LOD\n          t = floor(l*fract(iTime/8.-.1));\n          t = min(t,l-t);\n          \n    m = .8;                                 // foliage threshold\n    t = 3.+log2(R.y/360.);                  // log2( distance to floor )\n    \n    float v = T(U, t )- (1.-m); \n    O = vec4( smoothstep(-6., 6., v*R.y/10. ) );  // -4..4 to reproduce soft disk\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define hash(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{  \n   O-=O;                                        // foliage mask \n   vec2 U = 30.*u/R.y/vec2(4,1);\n   float d = 1e9;\n   for( int i=0; i < 9; i++) {\n       vec2 D = vec2(i%3-1,i/3-1),\n            I = floor(U)+D,\n            H = hash(I+.5),\n            P = hash(I) + .5*cos( .5*iTime*(1.+(H.y-.5)) + 6.3*H.x + vec2(0,11) );\n            d = min(d, length(fract(U)-D-P) );  \n   }\n   O.x = smoothstep(.1,-.1,  d - .3 );\n    \n\n   { vec2 D = R/5.*cos(iTime+vec2(0,11));    \n     O.x *= step( R.y/5., length(u-R/2.+D));    // occluder mask \n   }\n}", "buffer_a_inputs": [], "common_code": "#define R         iResolution.xy\n#define T( U, l ) textureLod( iChannel0, (U)/R , l ).x", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7llXzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 98, 131, 577]], "test": "untested"}
{"id": "stlXzN", "name": "foliage shadow with fake convolu", "author": "FabriceNeyret2", "description": "foliage shadowing is equivalent to DoF Boket : requires convolution with (solar) disk scaled with distance to floor.\nHere I approximate this with SDF to foliage mask. That I approximate with MIPmap of mask.\n( try uncommenting some foliage motion. WIP ).", "tags": ["sdf", "convolution", "penumbra", "boket"], "likes": 2, "viewed": 277, "published": 3, "date": "1625301460", "time_retrieved": "2024-07-30T19:12:31.970726", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    float m = iMouse.y/R.y,\n          l = floor(2.*log2(R.y)),          // for jigsaw between min-max LOD\n          t = floor(l*fract(iTime/8.-.1));\n          t = min(t,l-t);\n          \n    m = .8;                                 // foliage threshold\n    t = 3.+log2(R.y/360.);                  // log2( distance to floor )\n    \n    float v = T(U, t )- (1.-m); \n    O = vec4( smoothstep(-4., 4., v*R.y/10. ) );  // -4..4 to reproduce soft disk\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{\n   \n    O.x = step( T(U,0.), .4 );                 // foliage mask \n    \n\n/**\n  { vec2 D = R/100.*cos(iTime*2.+vec2(0,11));\n    O.x = 1.-step( (1.-T(U,0.))*(1.-T(-U+D,0.)), .25 );  // motion: 2nd foliage layer\n  }\n/**/   \n\n/**\n  { vec2 D = R/40.*cos(iTime+vec2(0,11));\n    O.x = step( T(U,0.), .6 ) * step( T(-U+D,0.), .6 );  // motion: 2nd foliage layer\n  }\n/**/\n\n\n/**/\n   { vec2 D = R/5.*cos(iTime+vec2(0,11));    \n     O.x *= step( R.y/5., length(U-R/2.+D));   // occluder mask \n   }\n/**/    \n\n}", "buffer_a_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R         iResolution.xy\n#define T( U, l ) textureLod( iChannel0, (U)/R , l ).x", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stlXzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 484]], "test": "untested"}
{"id": "sllSzN", "name": "isolines in MIPmapped mask", "author": "FabriceNeyret2", "description": "funny patterns I got why looking for something totally else. :-)", "tags": ["patterns", "mipmap", "isolines"], "likes": 8, "viewed": 293, "published": 3, "date": "1625298377", "time_retrieved": "2024-07-30T19:12:32.768592", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    float l = floor(2.*log2(R.y)),          // for jigsaw between min-max LOD\n          t = floor(l*fract(iTime/8.-.05));\n          t = min(t,l-t);\n\n    O = T(U, t );\n    O = sin( O/fwidth(O) );                 // normalized isolines\n // O = sin( 10.* O );                      // without normalization\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{\n    O = step( T(U,0.), vec4(.3) );            // mask \n}", "buffer_a_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R         iResolution.xy\n#define T( U, l ) textureLod( iChannel0, (U)/R , l )", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sllSzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 344]], "test": "untested"}
{"id": "stsXR4", "name": "Aizawa attractor ", "author": "michael0884", "description": "Tried to use Voronoi particle tracking in 3D for the first time. The obvious choice was to try something simple like the Lorentz attractor.", "tags": ["3d", "voronoi", "particles", "chaos", "lorentz"], "likes": 17, "viewed": 446, "published": 3, "date": "1625268244", "time_retrieved": "2024-07-30T19:12:33.710075", "image_code": "// Fork of \"Volumetric shader template\" by michael0884. https://shadertoy.com/view/tlc3Wf\n// 2019-12-30 20:57:24\n\n//#define VOLUMETRIC\n#define FULL_UNION\n#define sphere_rad 0.5\n\nfloat SDF_particle(vec3 p0, vec3 p)\n{\n    vec4 point = voxel(ch0, p0);\n    return length(point.xyz - p) - sphere_rad;\n}\n\n//distance estimator to the voronoi particle field\nfloat DE(vec3 p)\n{\n\tfloat de = 1e5;\n   \n   \tvec3 p0 =  round(clamp(p, vec3(0), size3d));\n    if(length(p - size3d*0.5) > 0.6*length(size3d)) \n        de = length(p - size3d*0.5);\n    else\n    {\t\n        de = min(de, SDF_particle(p0, p));\n        de = min(de, SDF_particle(p0+vec3(1,0,0), p));\n        de = min(de, SDF_particle(p0+vec3(-1,0,0), p));\n        de = min(de, SDF_particle(p0+vec3(0,1,0), p));\n        de = min(de, SDF_particle(p0+vec3(0,-1,0), p));\n        de = min(de, SDF_particle(p0+vec3(0,0,1), p));\n        de = min(de, SDF_particle(p0+vec3(0,0,-1), p));\n    }\n    \n    if(de < sphere_rad*2.)\n    {\n\t\tde = min(de, SDF_particle(p0+vec3(1,1,0), p));\n        de = min(de, SDF_particle(p0+vec3(-1,-1,0), p));\n        de = min(de, SDF_particle(p0+vec3(0,1,1), p));\n        de = min(de, SDF_particle(p0+vec3(0,-1,-1), p));\n        de = min(de, SDF_particle(p0+vec3(1,0,1), p));\n        de = min(de, SDF_particle(p0+vec3(-1,0,-1), p));\n        //reduces the number of artifacts even further, since it is using all neighboring voxels in a 3*3*3 cube\n        #ifdef FULL_UNION\n            de = min(de, SDF_particle(p0+vec3(1,-1,0), p));\n            de = min(de, SDF_particle(p0+vec3(-1,1,0), p));\n            de = min(de, SDF_particle(p0+vec3(0,-1,1), p));\n            de = min(de, SDF_particle(p0+vec3(0,1,-1), p));\n            de = min(de, SDF_particle(p0+vec3(-1,0,1), p));\n            de = min(de, SDF_particle(p0+vec3(1,0,-1), p));\n            de = min(de, SDF_particle(p0+vec3(1,-1,0), p));\n            de = min(de, SDF_particle(p0+vec3(-1,1,0), p));\n            de = min(de, SDF_particle(p0+vec3(0,1,-1), p));\n            de = min(de, SDF_particle(p0+vec3(0,-1,1), p));\n            de = min(de, SDF_particle(p0+vec3(1,0,-1), p));\n            de = min(de, SDF_particle(p0+vec3(-1,0,1), p));\n            de = min(de, SDF_particle(p0+vec3(1,1,1), p));\n            de = min(de, SDF_particle(p0+vec3(1,1,-1), p));\n            de = min(de, SDF_particle(p0+vec3(1,-1,1), p));\n            de = min(de, SDF_particle(p0+vec3(1,-1,-1), p));\n            de = min(de, SDF_particle(p0+vec3(-1,1,1), p));\n            de = min(de, SDF_particle(p0+vec3(-1,1,-1), p));\n            de = min(de, SDF_particle(p0+vec3(-1,-1,-1), p));\n        #endif\n    }\n    \n    return de;\n}\n\nvec3 COL(vec3 p)\n{\n    if(inside(p))\n    {\n        vec4 point = trilinear(ch0, p);\n            \n        return jet_range(point.w, -0.1, 1.2)*exp(-0.25*pow(max(DE(p),0.),2.));\n    }\n    else return vec3(0.);\n}\n\n#define MAX_MARCHES 130\n#define DX 1.5\n#define OPACITY 0.2\nvec4 ray_march_vol(vec3 p, vec3 r)\n{\n    vec4 color = vec4(0., 0., 0., 0.);\n    vec4 background = vec4(0.1);\n    for(int i = 0; i < MAX_MARCHES; i++)\n    {\n        vec3 tcolor = COL(p);\n        float density = length(tcolor);\n        float noise  =(1.+0.25*sin(1754.*length(p)+p.x));\n        float d = DX*exp(-2.*min(density,2.))*noise;\n        float opacity = 1.-exp(-OPACITY*density*d);\n        float newa = max(color.w + (1. - color.w)*opacity,0.0001);\n        color.xyz = (color.xyz*color.w + (1.-color.w)*opacity*tcolor)/newa;\n        color.w = newa;\n        if(1. - newa < 0.01) break;\n        p += r*d;\n    }\n    return background + color;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdLineBox(vec3 p, vec3 b, float r)\n{\n    p = abs(p);\n    float cx = sdBox(p - vec3(b.x*0.5,b.y,b.z), vec3(b.x*0.5+r,r,r));\n    float cy = sdBox(p - vec3(b.x,b.y*0.5,b.z), vec3(r,b.y*0.5+r,r));\n    float cz = sdBox(p - vec3(b.x,b.y,b.z*0.5), vec3(r,r,b.z*0.5+r));\n    return min(min(cx, cy),cz);\n}\n\nvec3 sdcolor(vec3 p)\n{\n    vec3 c = vec3(0.);\n    if(inside(p))\n    {\n        vec4 point = trilinear(ch0, p);\n            \n        c = jet_range(point.w, -0.1, 1.2);\n    }\n    else c = vec3(0.1);\n    if(sdLineBox(p - size3d*0.5, size3d*0.5, 0.5) < 5. || p.z < 3.) c = vec3(1.);\n    return c;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat map(vec3 p)\n{\n    float de_partic = DE(p); \n    de_partic = min(de_partic, sdPlane(p, vec4(0,0,1,0)));\n    return min(de_partic, sdLineBox(p - size3d*0.5, size3d*0.5, 0.5));\n}\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 k = vec3(1,-1,0);\n\treturn   (k.xyyx*map(p + k.xyy*dx) +\n\t\t\t k.yyxx*map(p + k.yyx*dx) +\n\t\t\t k.yxyx*map(p + k.yxy*dx) +\n\t\t\t k.xxxx*map(p + k.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n//usual ray marching stuff\nfloat rayfov;\nvec3 light;\n\n#define shadow_steps 256\n#define MIN_DIST 0.001\n#define MAX_DIST 1000.\nfloat shadow_march(vec4 pos, vec4 dir, float distance2light, float light_angle)\n{\n\tfloat light_visibility = 1.;\n\tfloat ph = 1e5;\n\tfloat dDEdt = 0.;\n\tpos.w = map(pos.xyz);\n\tint i = 0;\n\tfor (; i < shadow_steps; i++) {\n\t\n\t\tdir.w += pos.w;\n\t\tpos.xyz += pos.w*dir.xyz;\n        float noise  =(1.+0.1*sin(1754.*length(pos)+pos.x));\n\t\tpos.w = noise*map(pos.xyz);\n\t\t\n\t\tfloat y = pos.w*pos.w/(2.0*ph);\n        float d = (pos.w+ph)*0.5*(1.-dDEdt);\n\t\tfloat angle = d/(max(MIN_DIST,dir.w-y)*light_angle);\n\t\t\n        light_visibility = min(light_visibility, angle);\n\t\t\n\t\t//minimizing banding even further\n\t\tdDEdt = dDEdt*0.75 + 0.25*(pos.w-ph)/ph;\n\t\t\n\t\tph = pos.w;\n\t\t\n        if(dir.w >= distance2light)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif(dir.w > MAX_DIST || pos.w < max(0.5*rayfov*dir.w, MIN_DIST))\n\t\t{\n\t\t\treturn 0.;\n\t\t}\n\t}\n\t\n\tif(i >= shadow_steps)\n\t{\n\t\tlight_visibility=0.;\n\t}\n\t//return light_visibility; //bad\n\tlight_visibility = clamp(2.*light_visibility - 1.,-1.,1.);\n\treturn  0.5 + (light_visibility*sqrt(1.-light_visibility*light_visibility) + asin(light_visibility))/3.14159265; //looks better and is more physically accurate(for a circular light source)\n}\n\nfloat ambient_occlusion(in vec4 pos, in vec4 norm)\n{\t\n\tvec3 pos0 = pos.xyz;\n\t\n\tfloat occlusion_angle = 0.;\n\tvec3 direction = normalize(norm.xyz);\n\t//step out\n\tpos.xyz += 0.1*norm.w*direction;\n\t//march in the direction of the normal\n\tfor(int i = 0; i < 2; i++)\n\t{\n\t\tpos.xyz += pos.w*direction;\n\t\tpos.w = map(pos.xyz);\n\t\t\n\t\tnorm.w = length(pos0 - pos.xyz);\n\t\tocclusion_angle += clamp(pos.w/norm.w,0.,1.);\n\t}\n\t\n\tocclusion_angle /= 2.; // average weighted by importance\n\treturn (0.5-cos(3.14159265*occlusion_angle)*0.5);\n}\n\nvec4 ray_march(vec3 p, vec3 r)\n{\n    float td = 0.;\n    int i;\n    for(i = 0; i < 100; i++)\n    {\n    \tfloat de = map(p);\n        if(de < rayfov*td || td > MAX_DIST)\n        {\n            break;\n        }\n        p += de*r;\n        td += de;\n    }\n    vec3 col =sdcolor(p);\n    vec4 norm = calcNormal(p,MIN_DIST);\n    p += r*(norm.w-rayfov*td);\n    float ao = ambient_occlusion(vec4(p,0.), vec4(norm.xyz, td));\n    float shad = shadow_march(vec4(p+norm.xyz*0.05,0.), vec4(light,0.), 400.,0.03);\n    float ill = max(dot(norm.xyz, light)*(shad  + 0.35*ao*(1. - shad)), 0.0);\n    return vec4(col*ill,1.);\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    rayfov = FOV/iResolution.x;\n     SCALE = floor(ar*pow(iResolution.x*iResolution.y,0.1666666));\n    size3d = vec3(floor(iResolution.xy/SCALE), SCALE.x*SCALE.y);\n   \n    vec2 uv = (fragCoord - 0.5*size)/max(size.x, size.y);\n\n    vec2 angles = vec2(2.*PI, PI)*(iMouse.xy/iResolution.xy - 0.5);\n\n    if(iMouse.z <= 0.)\n    {\n        angles = vec2(0.2*iTime, 0.3*sin(0.2*iTime)+0.2);\n    }\n    vec3 ray = getRay(angles, uv);\n    vec3 cray = getRay(angles, vec2(0.));\n    light = vec3(0.3,0.8,0.9);\n    light.z = max(light.z, 0.9);\n    light = normalize(light);\n    float d = sqrt(dot(vec3(size3d), vec3(size3d)))*0.55;\n    vec3 pos = vec3(size3d)*0.5 - cray*d;\n\n    // Output to screen\n    vec4 t = texel(ch0, fragCoord);\n    vec3 p = dim3from2(fragCoord);\n    #ifdef VOLUMETRIC\n   \t fragColor = 2.*ray_march_vol(pos, ray);\n    #else\n     fragColor = 1.5*ray_march(pos, ray);\n\t#endif\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//definitions\n#define size iResolution.xy\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define pixel(a, p, s) texture(a, p/vec2(s))\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define dt 0.2\n\n#define ar vec2(1.35,0.8)\nvec2 SCALE;\nvec3 size3d;\n\nvec2 dim2from3(vec3 p3d)\n{\n    float ny = floor(p3d.z/SCALE.x);\n    float nx = floor(p3d.z) - ny*SCALE.x;\n    return vec2(nx, ny)*vec2(size3d.xy) + p3d.xy;\n}\n\nvec3 dim3from2(vec2 p2d)\n{\n    return vec3(p2d - size3d.xy*floor(p2d/size3d.xy),(floor(p2d.x/size3d.x) + SCALE.x*floor(p2d.y/size3d.y)));\n}\n\nvec4 voxel(sampler2D ch, vec3 p3d)\n{\n    return pixel(ch, dim2from3(p3d), textureSize(ch, 0));\n}\n\n//trilinear interpolation = linear interp between layers\nvec4 trilinear(sampler2D ch, vec3 p3d)\n{\n    return mix(voxel(ch, vec3(p3d.xy, floor(p3d.z))),voxel(ch, vec3(p3d.xy, ceil(p3d.z))), fract(p3d.z));\n}\n\nbool inside(vec3 p)\n{\n    if(p.x > 1. && p.y > 1. && p.z > 1. && p.x < float(size3d.x)-1. && p.y < float(size3d.y)-1. && p.z < float(size3d.z)-1.)\n    {\n        return true;\n    }\n    else return false;\n}\n\n#define FOV 2.5\nmat3 getCamera(vec2 angles)\n{\n   mat3 theta_rot = mat3(1,   0,              0,\n                          0,   cos(angles.y),  sin(angles.y),\n                          0,  -sin(angles.y),  cos(angles.y)); \n        \n   mat3 phi_rot = mat3(cos(angles.x),   sin(angles.x), 0.,\n        \t\t       -sin(angles.x),   cos(angles.x), 0.,\n        \t\t        0.,              0.,            1.); \n        \n   return theta_rot*phi_rot;\n}\n\nvec3 getRay(vec2 angles, vec2 pos)\n{\n    mat3 camera = getCamera(angles);\n    return normalize(transpose(camera)*vec3(FOV*pos.x, 1., FOV*pos.y));\n}\n\nfloat minv(vec3 a)\n{\n    return min(min(a.x, a.y),a.z);\n}\n\nfloat distance2border(vec3 p)\n{\n    vec3 a = vec3(size3d) - p;\n    return min(minv(p),minv(a));\n}\n    \n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\n", "buffer_a_code": "//3d voronoi particle tracking\n\nvoid Check(inout vec4 U, vec3 pos, vec3 dx)\n{\n    vec4 Unb = voxel(ch0, pos+dx);\n    //check if the stored neighbouring particle is closer to this position \n    if(length(Unb.xyz - pos) < length(U.xyz - pos))\n    {\n        U = Unb; //copy the particle info\n    }\n}\n\nvoid CheckRadius(inout vec4 U, vec3 p, int r)\n{\n    Check(U, p, vec3(-r, 0, 0));\n    Check(U, p, vec3(r, 0, 0));\n    Check(U, p, vec3(0, -r, 0));\n    Check(U, p, vec3(0, r, 0));\n    Check(U, p, vec3(0, 0, -r));\n    Check(U, p, vec3(0, 0, r));\n}\n\n#define sigma 10.\n#define beta 8./3.\n#define rho 28.\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    SCALE = floor(ar*pow(iResolution.x*iResolution.y,0.1666666));\n    size3d = vec3(floor(iResolution.xy/SCALE), SCALE.x*SCALE.y);\n    //voxel\n    vec3 p = dim3from2(pos);\n    \n    //this voxel value\n    U = voxel(ch0, p);\n    \n    //check neighbours \n    CheckRadius(U, p, 1);\n    CheckRadius(U, p, 2);\n    CheckRadius(U, p, 3);\n    CheckRadius(U, p, 4);\n \n    //U.xyz += 0.2*dt*vec3(p);\n    float scaling =8.0/length(size3d);\n    vec3 ppos = scaling*(U.xyz - size3d*vec3(0.5,0.5,0.5)); \n    \n    float a = 0.95, b = 0.7, c = 0.6, d = 3.5, e = 0.25, f = 0.1;\n    \n    vec3 val = ppos;\n    \n    float x1 = (val.z-b)*val.x - d*val.y;\n\n    float y1 = d * val.x + (val.z - b) * val.y;;\n\n    float z1 = c + a*val.z - (pow(val.z, 3.)/3.) - \n\n        (pow(val.x, 2.f) + pow(val.y, 2.f)) *\n\n        (1.0 + e * val.z) + f * val.z * ( pow(val.x, 3.f)); \n    \n   // vec3 dx = vec3(sigma*(ppos.y - ppos.x), ppos.x*(rho - ppos.z) - ppos.y, ppos.x*ppos.y - beta*ppos.z);\n    vec3 dx = vec3(x1, y1, z1);\n    U.xyz += dt*dx;\n    U.w = length(dx)*0.25;\n    \n    float bdist = distance2border(U.xyz);\n    \n    if(iFrame < 1)\n    {\n        ppos = vec3(4.*round(p/4.));\n        U = vec4(ppos, 0.);\n    }\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//3d voronoi particle tracking\n\nvoid Check(inout vec4 U, vec3 pos, vec3 dx)\n{\n    vec4 Unb = voxel(ch0, pos+dx);\n    //check if the stored neighbouring particle is closer to this position \n    if(length(Unb.xyz - pos) < length(U.xyz - pos))\n    {\n        U = Unb; //copy the particle info\n    }\n}\n\nvoid CheckRadius(inout vec4 U, vec3 p, int r)\n{\n    Check(U, p, vec3(-r, 0, 0));\n    Check(U, p, vec3(r, 0, 0));\n    Check(U, p, vec3(0, -r, 0));\n    Check(U, p, vec3(0, r, 0));\n    Check(U, p, vec3(0, 0, -r));\n    Check(U, p, vec3(0, 0, r));\n}\n\n#define sigma 10.\n#define beta 8./3.\n#define rho 28.\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    SCALE = floor(ar*pow(iResolution.x*iResolution.y,0.1666666));\n    size3d = vec3(floor(iResolution.xy/SCALE), SCALE.x*SCALE.y);\n    //voxel\n    vec3 p = dim3from2(pos);\n    \n    //this voxel value\n    U = voxel(ch0, p);\n    \n    //check neighbours \n    CheckRadius(U, p, 1);\n    CheckRadius(U, p, 2);\n    CheckRadius(U, p, 3);\n    CheckRadius(U, p, 4);\n \n    U.xyz += 0.002*dt*vec3(p);\n    float scaling =8.0/length(size3d);\n    vec3 ppos = scaling*(U.xyz - size3d*vec3(0.5,0.5,0.5)); \n    \n    float a = 0.95, b = 0.7, c = 0.6, d = 3.5, e = 0.25, f = 0.1;\n    \n    vec3 val = ppos;\n    \n    float x1 = (val.z-b)*val.x - d*val.y;\n\n    float y1 = d * val.x + (val.z - b) * val.y;;\n\n    float z1 = c + a*val.z - (pow(val.z, 3.)/3.) - \n\n        (pow(val.x, 2.f) + pow(val.y, 2.f)) *\n\n        (1.0 + e * val.z) + f * val.z * ( pow(val.x, 3.f)); \n    \n   // vec3 dx = vec3(sigma*(ppos.y - ppos.x), ppos.x*(rho - ppos.z) - ppos.y, ppos.x*ppos.y - beta*ppos.z);\n    vec3 dx = vec3(x1, y1, z1);\n    U.xyz += dt*dx;\n    \n    float bdist = distance2border(U.xyz);\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stsXR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 178, 215, 215, 297], [299, 350, 368, 368, 2619], [2621, 2621, 2639, 2639, 2829], [2890, 2890, 2926, 2926, 3538], [3540, 3540, 3571, 3571, 3662], [3664, 3664, 3717, 3717, 3776], [3778, 3778, 3830, 3830, 3951], [3953, 3953, 3995, 3995, 4255], [4257, 4257, 4279, 4279, 4550], [4552, 4552, 4585, 4611, 4642], [4644, 4644, 4663, 4663, 4825], [4827, 4827, 4862, 4862, 5052], [5179, 5179, 5260, 5260, 6320], [6322, 6322, 6374, 6374, 6840], [6842, 6842, 6874, 6874, 7445], [7451, 7451, 7508, 7508, 8393]], "test": "untested"}
{"id": "NlsXR4", "name": "Room 237 (The Shining)", "author": "dean_the_coder", "description": "Another scene based on 'The Shining'.", "tags": ["3d", "raymarching", "horror", "shining", "movie", "cineshader"], "likes": 30, "viewed": 6023, "published": 3, "date": "1625257891", "time_retrieved": "2024-07-30T19:12:34.560800", "image_code": "// 'Room 237 (The Shining)' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/NlsXR4 (YouTube: https://youtu.be/w_RCsMP70-I)\n//\n// Processed by 'GLSL Shader Shrinker' (Shrunk by 1,704 characters)\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// Another scene based on 'The Shining'.\n// Weird, as I don't actually like the movie too much!\n// It's in Ready Player One though, and that's great...\n//\n// Tricks to get the performance:\n// - The curtain is actually a flat plane, textured\n//   when the material color is added.\n// - The 'person' doesn't have an SDF - Just a subtle\n//   color added to the curtain material.\n// - The SDF for some objects (E.g. the toilet) is not\n//   calculated if the march point is 'too far away'.\n// - Use of abs() to mirror SDF content.\n//   (E.g. shelves, wall lights, sinks, ...)\n// - Keep the material (lights(...)) code outside of the\n//   marching 'for' loop to reduce compilation times.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// Blackle and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define Z0\tmin(iTime, 0.)\n#define sat(x)\tclamp(x, 0., 1.)\n\nfloat g = 0.,\n      furn = 1.;\n\n#define AA // Comment out this line to speed things up!\n\nstruct Hit {\n\tfloat d;\n\tint id;\n\tvec3 uv;\n};\n\n\n// Thnx Dave_Hoskins - https://www.shadertoy.com/view/4djSRW\nfloat hash31(vec3 p3) {\n\tp3 = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 3.3456);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash21(vec2 p) { return hash31(p.xyx); }\n\nvec4 hash44(vec4 p) { p = fract(p * .1031); p *= p + 3.3456; return fract(p * (p + p)); }\n\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(hash44(h), hash44(h + s.x), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat n21(vec2 p) { return n31(vec3(p, 1)); }\n\nfloat smin(float a, float b, float k) {\n\tfloat h = sat(.5 + .5 * (b - a) / k);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\n#define minH(a)\tif (a.d < h.d) h = a\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdBox2D(vec2 p, vec2 b) {\n\treturn length(max(abs(p) - b, 0.));\n}\n\nfloat sdCyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nvec3 rayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nHit map(vec3 p) {\n\tfloat bath, bulb, lid, bowl, curt,\n\t      d = abs(p.z) - .4;\n\td = min(max(min(min(min(max(d, -(sdBox2D(p.xy, vec2(1.6, 6)) - 1.8)), min(2. - p.z, max(sdBox2D(p.yz - vec2(0, 2.4), vec2(1.78)), 3.5 - abs(p.x)))), sdBox2D(p.yz, vec2(.2, 1.6))), 4.1 - abs(p.x)), -(sdBox2D(p.zy + vec2(5.5, 0), vec2(.7, 5.2)) - 1.8)), 6.5 - abs(p.x));\n\tfloat bathRimCut = smoothstep(1., .5, abs(p.x) - 1.) * .25 + p.y - 1.7;\n\tbath = max(abs(sdBox(p - vec3(0, 2, 1.2), vec3(3.5, 2, .7))), p.y - 1.8);\n\tfurn = min(max(bath, bathRimCut), length(vec2(bath, bathRimCut)) - .08);\n\td = min(d, furn);\n\tvec3 c,\n\t     q = p;\n\tq.x = abs(q.x);\n\tq += vec3(-5.2, -4.6, 2.71);\n\td = max(d, -sdBox(q, vec3(.8, 1.8, .3)));\n\tq.y = abs(q.y + .45) - .5;\n\tfloat chrome = sdBox(q, vec3(.8, .04, .3));\n\tchrome = min(chrome, max(abs(q.z), 4.5 - abs(p.x)));\n\tbulb = length(q.xz - vec2(1.15, -2.2)) - .12;\n\tq.y = p.y - 5.;\n\tchrome = min(chrome, max(bulb, abs(abs(q.y) - .76) - .15));\n\tbulb = max(bulb, abs(q.y) - .6);\n\tq = p - vec3(-5.4, 1.3, -4);\n\tq.x *= .7;\n\tlid = sdCyl(q, vec2(.7, .02)) - .03;\n\tif (lid < 2.) {\n\t\tfurn = min(min(furn, max(sdCyl(q + vec3(0, .12, 0), vec2(.53, .1)) - .18, .03 - lid)), lid);\n\t\tfurn = min(furn, max(length(q.xz) - .4 + sin(q.y * 4. - .4) * .1, q.y));\n\t\tfurn = smin(furn, max(length(q.yz + vec2(.8, 0)) - .2, q.x), .2);\n\t}\n\n\tq = p - vec3(5.5, 2.2, -5.2);\n\tq.z = abs(q.z) - 1.2;\n\tbowl = sdBox(q, vec3(.4, .2, .4));\n\tif (bowl < 1.) {\n\t\tfurn = min(furn, min(sdBox(q, vec3(.8, .15, .8)) - .1, max(bowl - .2, q.y)));\n\t\tfurn = max(furn, .18 - bowl);\n\t}\n\n\td = min(d, furn);\n\tchrome = min(min(chrome, sdBox(q - vec3(1.95, 2, 0), vec3(1, 1.4, .6))), smin(sdCyl(q.xzy + vec3(.8, 0, .7), vec2(.04, .6)), max(length(abs(q.xz + vec2(.2, 0)) - .6) - .04, q.y), .08));\n\td = min(min(d, abs(p.y)), abs(p.y - 8.7));\n\tc = p;\n\tc.x += sin(iTime) * .1 * -(cos((c.y + 3.) * .6) - 1.) * smoothstep(-3.5, 2., c.x);\n\tcurt = max(max(abs(c.z), c.x), 1. - c.y - sin(c.x * 8.) * .06);\n\tq = p - vec3(0, 8.2, -2);\n\tbulb = min(bulb, length(q) - .5);\n\tg += .01 / (.2 + bulb * bulb);\n\tfloat bulbHolder = length(q.xz) - 1.;\n\td = min(d, min(max(bulbHolder, .4 - q.y), max(bulbHolder + .3, .3 - q.y)));\n\tHit h = Hit(d, 1, p);\n\tminH(Hit(chrome, 0, p));\n\tminH(Hit(bulb, 2, p));\n\tminH(Hit(curt, 3, c));\n\treturn h;\n}\n\nvec3 N(vec3 p) {\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * .01).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 ld) {\n\tfloat i, h,\n\t      s = 1.,\n\t      t = .1;\n\tfor (i = Z0; i < 30.; i++) {\n\t\th = map(t * ld + p).d;\n\t\ts = min(s, 15. * h / t);\n\t\tt += h;\n\t\tif (s < .001 || t > 50.) break;\n\t}\n\n\treturn sat(s);\n}\n\nfloat ao(vec3 p, vec3 n, float h) { return map(h * n + p).d / h; }\n\nvec3 vig(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\nvec3 lights(vec3 p, vec3 rd, Hit h) {\n\tif (h.id == 2) return vec3(1.6);\n\tif (h.id == 0) return vec3(.01);\n\tvec3 c,\n\t     ld = normalize(vec3(0, 6.5, -5) - p),\n\t     n = N(p);\n\tfloat w, lig,\n\t      ss = 0.,\n\t      gg = g,\n\t      spe = 2.;\n\tvec2 pp;\n\tif (h.id == 1) {\n\t\tif (abs(n.y - 1.) < .01 && p.y < .3) {\n\t\t\tc = vec3(.5, .5, .4) - n21(p.xz * 20.) * .1;\n\t\t\tc -= .2 * smoothstep(.6, 0., furn);\n\t\t\tpp = p.xz;\n\t\t\tpp.y += 5.;\n\t\t\tc = mix(c, vec3(.5, .25, .25), step(abs(min(sdBox2D(pp, vec2(1)), sdBox2D(pp, vec2(2, .2))) - 1.), .15));\n\t\t}\n\t\telse if (p.y < .35 && furn > .01) c = vec3(.05);\n\t\telse if (p.y > 8.6 || p.y > 3. && (abs(p.z + .4) < .1 || abs(abs(p.x) - 4.1) < .01)) c = mix(vec3(.35, .38, .36), vec3(.4, .3, .1), step(p.y, 3.5));\n\t\telse c = vec3(.16, .35, .17) + step(furn, .0015) * .15;\n\t}\n\telse if (h.id == 3) {\n\t\tpp = h.uv.xy;\n\t\tw = sin(pp.x * 8.) * .8 + sin(pp.x * 20.) * sin(pp.y * .4);\n\t\tc = vec3(.5, .76 + w * .07, .5) + step(length(mod(pp - vec2(0, w * .02), .2) - .1), .03) * .15;\n\t\tn.x += w / 4.;\n\t\tn = normalize(n);\n\t\tspe = .04;\n\t\tpp = p.xy;\n\t\tpp.x += sin(iTime * .3 + pp.y) * .08;\n\t\tc = mix(c, -smoothstep(1., 0., min(length(pp * vec2(2, 1) - vec2(-2.8, 3)), length(pp - vec2(-1.3, 2.2)))) * vec3(.6, 1.8, 1.8), .1);\n\t}\n\telse {\n\t\tss = 1.8;\n\t\tc = vec3(.13, .09, .09);\n\t\tc *= .5 + .5 * smoothstep(-.1 - sin(h.uv.y * 3.5) * .1, 0., h.uv.x);\n\t}\n\n\tfloat ao = mix(ao(p, n, .1), ao(p, n, .8), .5),\n\t      l1 = sat(.3 + .7 * dot(ld, n)) * (.7 + .3 * shadow(p, ld)) * (.6 + .4 * ao),\n\t      l2 = sat(n.y * -.3) + pow(sat(dot(rd, reflect(ld, n))), 2.) * spe,\n\t      fre = smoothstep(.7, 1., 1. + dot(rd, n)) * .5;\n\tlig = l1 + l2 * ao + ss;\n\tg = gg;\n\treturn mix(lig * c * vec3(1.8, 1.6, 1.5), vec3(.01), fre);\n}\n\nvec4 march(inout vec3 p, vec3 rd, float s) {\n\tg = 0.;\n\tHit h;\n\tfor (float i = Z0; i < s; i++) {\n\t\th = map(p);\n\t\tif (abs(h.d) < .0015) break;\n\t\tp += h.d * rd;\n\t}\n\n\treturn vec4(g + lights(p, rd, h), h.id);\n}\n\nvec3 scene(vec3 p, vec3 rd) {\n\tvec4 l,\n\t     col = vec4(0);\n\tfloat a = 1.;\n\tfor (int i = 0; i < 3; i++) {\n\t\tl = march(p, rd, 64.);\n\t\tcol += l * a;\n\t\tif (l.w > 0.) break;\n\t\ta *= .9;\n        vec3 n = N(p);\n\t\trd = reflect(rd, n);\n\t\tp += n * .01;\n\t}\n\n\treturn col.rgb;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tfloat t = mod(iTime, 25.),\n\t      f = smoothstep(0., 14.5, t);\n\tvec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n\tvec3 lookAt = mix(vec3(-1. + f, 4, 0), vec3(8, 5, -3), sat(1.2 * pow(sin(sat(f * 1.2 - .2) * 3.141), 4.))),\n\t     ro = vec3(.1, 4, -14. + f * 7.),\n         col = scene(ro, rayDir(ro, lookAt, uv));\n#ifdef AA\n\tif (fwidth(col.r) > .1) {\n\t\tfor (float dx = Z0; dx <= 1.; dx++) {\n\t\t\tfor (float dy = Z0; dy <= 1.; dy++)\n\t\t\t\tcol += scene(ro, rayDir(ro, lookAt, uv + (vec2(dx, dy) - .5) / iResolution.xy));\n\t\t}\n\n\t\tcol /= 5.;\n\t}\n\n#endif\n\tcol.g -= hash21(fc) * .04;\n\tfragColor = vec4(vig(pow(max(vec3(0), col), vec3(.45)) * sat(t), fc), 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlsXR4.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1369, 1430, 1453, 1453, 1550], [1552, 1552, 1574, 1574, 1598], [1600, 1600, 1621, 1621, 1689], [1691, 1691, 1710, 1710, 1961], [1963, 1963, 1982, 1982, 2008], [2010, 2010, 2049, 2049, 2131], [2171, 2171, 2200, 2200, 2287], [2289, 2289, 2320, 2320, 2359], [2361, 2361, 2391, 2391, 2491], [2493, 2493, 2537, 2537, 2673], [2675, 2675, 2692, 2692, 4953], [4955, 4955, 4971, 4971, 5173], [5175, 5175, 5206, 5206, 5397], [5399, 5399, 5434, 5434, 5465], [5467, 5467, 5494, 5494, 5609], [5611, 5611, 5648, 5648, 7331], [7333, 7333, 7377, 7377, 7538], [7540, 7540, 7569, 7569, 7805], [7807, 7807, 7852, 7852, 8504]], "test": "untested"}
{"id": "7tfSzN", "name": "cheburashka (2.07.2021)", "author": "mariia_sharkovskaya", "description": "cheburashka of ovals, rectangular and circles", "tags": ["cheburashka"], "likes": 0, "viewed": 210, "published": 3, "date": "1625255649", "time_retrieved": "2024-07-30T19:12:35.398561", "image_code": "    float C(float x, float y, float r) { // circle's function\n            return x*x + y*y - r;\n    }\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = 1.0 - 2.0 * fragCoord/iResolution.xy;\n     float x = p.x * iResolution.x/iResolution.y;\n     float y = p.y;\n      float f = 10.0*C(4.0*x, 3.5*y, 1.5);                   //body\n        f *= 10.0*C(4.7*x, 4.3*y + 0.4, 0.3);                  //stomach\n         f = min (f, 40.0*C(2.5*x-0.4, 5.0*y-2.1, 0.15));       //left ankle\n          f = min (f, 40.0*C(x-0.05, y-0.35, 0.003));            //left leg\n           f = min (f, 40.0*C(2.5*x+0.4, 5.0*y-2.1, 0.15));       //right ankle\n            f = min (f, 40.0*C(x+0.05, y-0.35, 0.003));            //right leg\n             f = min (f, 10.0*C(4.0*x - 1.8, 3.5*y + 1.7, 0.8));    // left ear\n              f *= 10.0*C(4.0*x - 1.8, 3.5*y + 1.7, 0.4);            //inner left ear\n               f = min (f, 10.0*C(4.0*x + 1.8, 3.5*y + 1.7, 0.8));    //right ear\n                f *= 10.0*C(4.0*x + 1.8, 3.5*y + 1.7, 0.4);            //inner right ear\n                 f = min (f, 10.0*C(2.7*x, 4.0*y + 1.8, 1.0));          // head         \n                  f *= 10.0*C(2.7*x, 4.0*y + 1.8, 0.6);                  //face\n                   f = min (f, 150.0*C(2.5*x + 0.3, 2.5*y+1.2, 0.02));    //right eye\n                    f = min (f, 150.0*C(2.5*x - 0.3, 2.5*y+1.2, 0.02));    //left eye\n                     f *= 40.0*C(2.5*x - 0.29, 2.5*y+1.18, 0.01);           //left pupil\n                      f *= 40.0*C(2.5*x + 0.29, 2.5*y+1.18, 0.01);           //right pupil\n                       f = min (f, 1000.0*C(1.1*x - 0.14, 2.5*y+1.4, 0.002)); //left eyebrow\n                        f = min (f, 1000.0*C(1.1*x + 0.14, 2.5*y+1.4, 0.002)); //right eyebrow\n                         f = min (f, 150.0*C(2.5*x - 0.01, 2.5*y+1.0, 0.01));   //nose\n                          f = min (f, 40.0*C(5.0*x+1.6, 2.5*y+0.03, 0.15));      //right hand\n                           f = min (f, 40.0*C(5.0*x-1.6, 2.5*y+0.03, 0.15));      //left hand\n                            f = min (f, 200.0*C(1.5*x - 0.0, 8.0*y + 2.5, 0.015));    //mouth\n              vec3 col = vec3(1.0, 0.3, 1.0);\n               if(f > 0.0)col.g = 1.0;\n                   else col.b = f;\n// Output to screen\n                 fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tfSzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[4, 4, 40, 61, 101], [102, 102, 158, 158, 2333]], "test": "untested"}
{"id": "ftsSR4", "name": "Tight BBox of Arc", "author": "oneshade", "description": "Tightest bounding box of an arc (given translation, rotation, and scale as degrees of freedom).", "tags": ["2d", "arc", "bbox", "tight"], "likes": 8, "viewed": 142, "published": 3, "date": "1625255073", "time_retrieved": "2024-07-30T19:12:36.294166", "image_code": "// Constants\n#define PI 3.14159265359\n\n// Utilities\n#define drawSDF(dist, col, opaq) color = mix(color, col, smoothstep(unit, 0.0, dist) * opaq)\nstruct TightBBox { mat2 ori; vec2 bmin; vec2 bmax; };\n\n// SDFs\nfloat sdBox(in vec2 p, in vec2 b) {\n    p = abs(p) - b;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\n}\n\n// ax: vec2(cos(axis), sin(axis))\n// ap: vec2(cos(aperture), sin(aperture))\nfloat sdArc(in vec2 p, in vec2 ax, in vec2 ap, in float r, in float t) {\n    p = vec2(dot(p, ax), abs(p.y * ax.x - p.x * ax.y));\n    return (p.y * ap.x < p.x * ap.y ? abs(length(p) - r) : length(p - ap * r)) - t;\n}\n\nTightBBox arcBoundingBox(in vec2 ax, in vec2 ap, in float r, in float t) {\n    float y = (ap.x < 0.0 ? r : ap.y * r) + t;\n    return TightBBox(mat2(ax, -ax.y, ax.x), vec2(ap.x * r - t, -y), vec2(r + t, y));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 2.0;\n    vec3 color = vec3(pow(max(0.0, 1.0 - length(fragCoord / iResolution.xy - 0.5)), 0.8));\n    float unit = 4.0 / iResolution.y;\n\n    // Animated arc parameters\n    float axis = PI * sin(iTime);\n    float aper = PI * (0.5 + 0.5 * cos(iTime));\n    float thick = 0.025 + 0.025 * sin(iTime);\n    float rad = 0.55;\n\n    // Set to be equivalent to axis aligned bbox\n    // of a circle\n    if (iTime < 3.0) {\n        axis = 0.5 * PI;\n        aper = PI;\n    }\n\n    // Start rotating the bbox\n    else if (iTime < 8.0) {\n        axis = PI * sin(0.5 * iTime);\n        aper = PI;\n    }\n\n    // Transition to full animation with tight bbox\n    else {\n        float transition = smoothstep(8.0, 13.0, iTime);\n        axis = mix(PI * sin(0.5 * iTime), axis, transition);\n        aper = mix(PI, aper, transition);\n    }\n\n    // Draw arc\n    vec2 csAxis = vec2(cos(axis), sin(axis));\n    vec2 csAper = vec2(cos(aper), sin(aper));\n    drawSDF(abs(sdArc(uv, csAxis, csAper, rad, thick)), vec3(0.0), 1.0);\n\n    // Compute tight bbox\n    TightBBox bbArc = arcBoundingBox(csAxis, csAper, rad, thick);\n\n    // Transform into bbox local coordinate frame\n    vec2 bp = uv * bbArc.ori;\n\n    // Point in bounding box test\n    //if (bp.x > bbArc.bmin.x && bp.x < bbArc.bmax.x &&\n    //    bp.y > bbArc.bmin.y && bp.y < bbArc.bmax.y) {\n    //    color -= 0.25;\n    //}\n\n    // Draw as SDF instead for free antialiasing\n    drawSDF(sdBox(bp - 0.5 * (bbArc.bmin + bbArc.bmax), 0.5 * (bbArc.bmax - bbArc.bmin)), vec3(0.0), 0.25);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsSR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[200, 208, 243, 243, 323], [325, 401, 473, 473, 615], [617, 617, 691, 691, 825], [827, 827, 882, 882, 2491]], "test": "untested"}
{"id": "NtXSR4", "name": "Volumetric laser tracer", "author": "michael0884", "description": "Storing a laser path to then resample it for illumation when path tracing.\nCamera controls are WASD and QR for roll. Might be broken on some GPUs for some reason. R reset accumulation.", "tags": ["camera"], "likes": 77, "viewed": 3363, "published": 3, "date": "1625249148", "time_retrieved": "2024-07-30T19:12:37.368294", "image_code": "vec3 tone(vec3 c)\n{\n    return tanh(pow(c,vec3(0.5)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 acc = texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor = vec4(tone(8.5*acc.xyz/acc.w), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//controller\n\n//Keyboard constants\nconst int keyLe = 37, keyUp = 38, keyRi = 39, keyDn = 40, keyA = 65, keyB = 66, keyC = 67, keyD = 68, keyE = 69, keyF = 70, keyG = 71, keyH = 72, keyI = 73, keyJ = 74, keyK = 75, keyL = 76, keyM = 77, keyN = 78, keyO = 79, keyP = 80, keyQ = 81, keyR = 82, keyS = 83, keyT = 84, keyU = 85, keyV = 86, keyW = 87, keyX = 88, keyY = 89, keyZ = 90;\n\nbool pressed(int k) \n{\n    return texelFetch(iChannel3, ivec2(k, 0), 0).x > 0.5;\n}\n\nconst float force =25.0;\nconst float mouse_sens = 100.0;\nconst float roll_speed = 0.5;\n\nvoid mainImage( out vec4 o, in vec2 p )\n{\n    p = floor(p);\n    if(p.x > NAddr && p.y > 0.) discard;\n    \n    //get camera data\n    vec3 cp = get(CamP).xyz;\n    vec4 ca = get(CamA);\n    \n    float mode = 0.0;\n    if(pressed(keyR)) mode = 1.0;\n    \n    //initialization\n    if(iFrame == 0)\n    {\n        cp = vec3(-1.,1.5,-1);\n        ca = aa2q( normalize(vec3(0,1,0)), -PI*0.6/4.0);\n        mat3 cam = getCam(ca);\n        ca = qq2q(ca, aa2q(cam*vec3(1,0,0), -PI*0.4/4.0)); \n    }\n    vec4 oldca = ca;\n    if(p.x == PrevCamP) o = vec4(cp, 0);\n    if(p.x == PrevCamA) o = ca;\n    \n    mat3 cam = getCam(ca);\n    \n    //get velocities\n    vec3 cv = get(CamV).xyz;\n    vec4 cav = get(CamAV);\n    \n    float dt = 1./60.0;\n    //update position\n    if(pressed(keyW)) cv += force*dt*cam*vec3(0,0,1);\n    if(pressed(keyS)) cv += force*dt*cam*vec3(0,0,-1);\n    if(pressed(keyA)) cv += force*dt*cam*vec3(-1,0,0);\n    if(pressed(keyD)) cv += force*dt*cam*vec3(1,0,0);\n    \n    cp += dt*cv;\n    cv += -cv*tanh(10.0*dt);\n    \n    //update camera orientation\n    vec2 dmouse = dt*mouse_sens*(iMouse.xy - get(PrevMouse).xy)/iResolution.x;\n    \n    if(length(dmouse) < 0.1)\n    {\n        //rotate around y ax\n        ca = qq2q(ca, aa2q(cam*vec3(0,1,0), -dmouse.x)); \n        //rotate around x ax\n        ca = qq2q(ca, aa2q(cam*vec3(1,0,0), dmouse.y));\n    }\n    \n    //roll camera\n    if(pressed(keyQ)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), -roll_speed*dt)); \n    if(pressed(keyE)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), roll_speed*dt)); \n    \n    if(distance(oldca, ca) > 0.001 || length(cv) > 0.01) mode = 1.0;\n    \n    if(p.x == CamP) o = vec4(cp, mode);\n    if(p.x == CamA) o = ca;\n    if(p.x == CamV) o = vec4(cv, 0.0);\n    if(p.x == CamAV) o = vec4(0.0);\n    if(p.x == PrevMouse) o = vec4(iMouse.xy, 0, 0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n#define FOV 1.1\n#define CAM_ANGLE 0.001\n#define MAX_STEPS 90\n#define MIN_DIST 1e-5\n#define MAX_DIST 500.0\n\n//(reused some of @ollj's code, made it more readible)\n\nvec3 light = normalize(vec3(0,1,0));\nconst float light_bright =1.0;\nconst float light_ang = 0.1;\n\n//specific controller buffer Addresses\nconst float CamP = 0.,     //camera position \n            CamA = 1.,     //camera rotation quaternion    \n            CamV = 2.,     //camera velocity\n            CamAV = 3.,    //camera rotation velocity\n            PrevCamP = 4., //previous frame camera position\n            PrevCamA = 5., //previous frame camera rotation quaternion\n            PrevMouse = 6.,//previous mouse pos\n            NAddr = 7.;    //max address count\n            \n#define get(i) texelFetch(iChannel2,ivec2(i,0),0)\n\nfloat sqr(float x)\n{\n    return x*x;\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n              in vec3 planeNormal, in float planeDist) {\n    float a = dot(rd, planeNormal);\n    float d = -(dot(ro, planeNormal)+planeDist)/a;\n    if (a > 0. || d < distBound.x || d > distBound.y) {\n        return MAX_DIST;\n    } else {\n        normal = planeNormal;\n    \treturn d;\n    }\n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n               float sphereRadius ) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - sphereRadius*sphereRadius;\n    float h = b*b - c;\n    if (h < 0.) {\n        return MAX_DIST;\n    } else {\n\t    h = sqrt(h);\n        float d1 = -b-h;\n        float d2 = -b+h;\n        if (d1 >= distBound.x && d1 <= distBound.y) {\n            normal = normalize(ro + rd*d1);\n            return d1;\n        } else if (d2 >= distBound.x && d2 <= distBound.y) { \n            normal = normalize(ro + rd*d2);            \n            return d2;\n        } else {\n            return MAX_DIST;\n        }\n    }\n}\n\nfloat iBox( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal, \n            in vec3 boxSize ) {\n    vec3 m = sign(rd)/max(abs(rd), 1e-8);\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if (tN > tF || tF <= 0.) {\n        return MAX_DIST;\n    } else {\n        if (tN >= distBound.x && tN <= distBound.y) {\n        \tnormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n            return tN;\n        } else if (tF >= distBound.x && tF <= distBound.y) { \n        \tnormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n            return tF;\n        } else {\n            return MAX_DIST;\n        }\n    }\n}\n\nfloat iCylinder( in vec3 ro, in vec3 rd, \n                in vec3 pa, in vec3 pb, float ra ) // extreme a, extreme b, radius\n{\n    vec3 ba = pb-pa;\n\n    vec3  oc = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoc = dot(ba,oc);\n    \n    float k2 = baba            - bard*bard;\n    float k1 = baba*dot(oc,rd) - baoc*bard;\n    float k0 = baba*dot(oc,oc) - baoc*baoc - ra*ra*baba;\n    \n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return 1e10;\n    h = sqrt(h);\n    float t = (-k1-h)/k2;\n\n    // body\n    float y = baoc + t*bard;\n    if( y>0.0 && y<baba ) return t;\n    \n    // caps\n    t = ( ((y<0.0) ? 0.0 : baba) - baoc)/bard;\n    if( abs(k1+k2*t)<h )\n    {\n        return t;\n    }\n\n    return 1e10;\n}\n\n//ollj quaternionRotation math\n//\n//ANY rotations in 3d are non-commutative!\n//\n//matrix rotations are just bulky, memory wasting\n//EulerRotations almost certainly fail to rotate over the SHORTEST path.\n//EulerRotations almost certainly will gimbalLock and get stuck along one axis\n//QuaternionRotations are superior here.\n//-> we only use EulerRorations for simple input devices (keyboard input)\n//-> we convert to quaternions, buffered as vec4.\n\n//quaternion Identity\nvec4 qid() \n{\n    return vec4(0, 0, 0, 1);\n}\n\n//return quaternion from axis and angle\nvec4 aa2q(vec3 axis, float ang) \n{\n    vec2 g = vec2(sin(ang), cos(ang)) * 0.5;\n    return normalize(vec4(axis * g.x, g.y));\n}\n\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q) \n{\n    return vec4(q.xyz / sqrt(1.0 - q.w * q.w), acos(q.w) * 2.);\n}\n\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2) \n{\n    return vec4(q1.xyz * q2.w + q2.xyz * q1.w + cross(q1.xyz, q2.xyz), (q1.w * q2.w) - dot(q1.xyz, q2.xyz));\n}\n\n//extension to qq2q(), scaled by sensitivity [f] (==quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f) \n{\n    float d = dot(a, b), t = acos(abs(d)), o = (1. / sin(t));\n    return normalize(a * sin(t * (1.0 - f)) * o * sign(d) + b * sin(t * f) * o);\n}\n\n//doing qq2q() multiple times, you need to normalize() the quaternion, to fix rounding errors.\n//how often you do this is up to you.\n\n//normalize q (assuming length(q) is already close to 1, we can skip whe sqrt()\nvec4 qn(vec4 q) \n{\n    return q / dot(q,q);\n}\n\n//return quaternion, that is the shortest rotation, between looking to [a before], and looking to [b after] the rotation.\n//http://wiki.secondlife.com/wiki/LlRotBetween\nvec4 qBetween(vec3 a, vec3 b) \n{\n    float v = sqrt(dot(a,a) * dot(a,a));\n\n    if(v == 0.) return qid();\n    \n    v = dot(a, b) / v;\n    vec3 c = a.yzx * b.zxy - a.zxy * b.yzx / v;\n    float d = dot(c,c);\n    \n    if(d != 0.) \n    {\n        float s = (v > - 0.707107) ? 1. + v : d / (1. + sqrt(1. - d));\n        return vec4(c, s) / sqrt(d + s * s);\n    }\n    \n    if(v > 0.) return qid();\n    \n    float m = length(a.xy);\n    \n    return (m != 0.) ? vec4(a.y, - a.x, 0, 0) / m : vec4(1, 0, 0, 0);\n}\n\n//return inverse of quaternion\nvec4 qinv(vec4 q) \n{\n    return vec4(- q.xyz, q.w) / dot(q,q);\n}\n\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q, vec3 p) \n{\n    return qq2q(q, qq2q(vec4(p, .0), qinv(q))).xyz;\n}\n\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it is rotated by VECTOR p (as if it is a quaternion)\nvec3 vq2v(vec3 p, vec4 q) \n{\n    return qq2q(qinv(q), qq2q(vec4(p, 0.0), q)).xyz;\n}\n\nvec3 vq2v(vec4 a, vec3 b) \n{\n    return qv2v(a, b);\n}\n\n//in case of namespace confuction\nvec3 qv2v(vec3 a, vec4 b) \n{\n    return vq2v(a, b);\n}\n\n//return mat3 of quaternion (rotation matrix without translation)\n//https://www.shadertoy.com/view/WsGfWm\nmat3 q2m(vec4 q) \n{\n    vec3 a = vec3(-1, 1, 1);\n    vec3 u = q.zyz * a, v = q.xyx * a.xxy;\n    mat3 m = mat3(0.5) + mat3(0, u.x,u.y,u.z, 0, v.x,v.y,v.z, 0) * q.w + matrixCompMult(outerProduct(q.xyz, q.xyz), 1. - mat3(1));\n    q *= q; \n    m -= mat3(q.y + q.z, 0, 0, 0, q.x + q.z, 0, 0, 0, q.x + q.y);\n    return m * 2.0;\n}\n\n//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\nvec4 m2q(mat3 m) \n{\n#define m2f(a,b) m[a][b]-m[b][a]\n    //http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n    float q = 2. * sqrt(abs(1. + m[0][0] + m[1][1] + m[2][2]));\n    return vec4(vec3(m2f(2, 1), m2f(0, 1), m2f(1, 0)) / q / 4., q);\n#undef m2f\n}\n\nfloat at2e(vec2 a) \n{\n    a *= 2.;\n    return atan(a.x, 1. - a.y);\n}\n\n//return quaternion of Euler[yaw,pitch,roll]     \nvec4 eYPR2q(vec3 o) \n{\n    o *= .5;\n    vec3 s = sin(o);\n    //https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n    o = cos(o);\n    vec4 a = vec4(s.xz, o.xz);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(-1, 1, -1, 1);\n}\n\nvec4 eYPR2q(vec2 o) \n{\n    o *= .5;\n    vec2 s = sin(o);\n    o = cos(o);\n    vec4 a = vec4(s.x, 0., o.x, 0.);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(- 1, 1, - 1, 1);\n}\n\nmat3 getCam(vec4 q) \n{\n    return q2m(q);\n}\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nuvec4 pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    return v;\n}\n\nfloat rand(){ return float(pcg4d(s0).x)/float(0xffffffffu); }\nvec2 rand2(){ return vec2(pcg4d(s0).xy)/float(0xffffffffu); }\nvec3 rand3(){ return vec3(pcg4d(s0).xyz)/float(0xffffffffu); }\nvec4 rand4(){ return vec4(pcg4d(s0))/float(0xffffffffu); }\n\nvec2 nrand2(float sigma, vec2 mean)\n{\n\tvec2 Z = rand2();\n    return mean + sigma * sqrt(-2.0 * log(Z.x)) * \n           vec2(cos(TWO_PI * Z.y),sin(TWO_PI * Z.y));\n}\n\nvec3 nrand3(float sigma, vec3 mean)\n{\n\tvec4 Z = rand4();\n    return mean + sigma * sqrt(-2.0 * log(Z.xxy)) * \n           vec3(cos(TWO_PI * Z.z),sin(TWO_PI * Z.z),cos(TWO_PI * Z.w));\n}\n\n//uniformly spherically distributed\nvec3 udir(vec2 rng)\n{\n    vec2 r = vec2(2.*PI*rng.x, acos(2.*rng.y-1.));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}\n\n\nconst float PI2 = 6.2831853071;\n\n// Valid from 1000 to 40000 K (and additionally 0 for pure full white)\nvec3 colorTemperatureToRGB(const in float temperature){\n  // Values from: http://blenderartists.org/forum/showthread.php?270332-OSL-Goodness&p=2268693&viewfull=1#post2268693   \n  mat3 m = (temperature <= 6500.0) ? mat3(vec3(0.0, -2902.1955373783176, -8257.7997278925690),\n\t                                      vec3(0.0, 1669.5803561666639, 2575.2827530017594),\n\t                                      vec3(1.0, 1.3302673723350029, 1.8993753891711275)) : \n\t \t\t\t\t\t\t\t\t mat3(vec3(1745.0425298314172, 1216.6168361476490, -8257.7997278925690),\n   \t                                      vec3(-2666.3474220535695, -2173.1012343082230, 2575.2827530017594),\n\t                                      vec3(0.55995389139931482, 0.70381203140554553, 1.8993753891711275)); \n  return mix(clamp(vec3(m[0] / (vec3(clamp(temperature, 1000.0, 40000.0)) + m[1]) + m[2]), vec3(0.0), vec3(1.0)), vec3(1.0), smoothstep(1000.0, 0.0, temperature));\n}\n\n\nconst float aperture_size = 0.0;\nvec2 aperture()\n{\n    vec2 r = rand2();\n    return vec2(sin(TWO_PI*r.x), cos(TWO_PI*r.x))*sqrt(r.y);\n}\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\nvec3 spectral_zucconi(float w)\n{\n    // w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\n\tconst vec3 cs = vec3(3.54541723, 2.86670055, 2.29421995);\n\tconst vec3 xs = vec3(0.69548916, 0.49416934, 0.28269708);\n\tconst vec3 ys = vec3(0.02320775, 0.15936245, 0.53520021);\n\n\treturn bump3y (\tcs * (x - xs), ys);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n        float y = baoa + t*bard;\n        // body\n        if( y>0.0 && y<baba ) return t;\n        // caps\n        vec3 oc = (y<=0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - r*r;\n        h = b*b - c;\n        if( h>0.0 ) return -b - sqrt(h);\n    }\n    return -1.0;\n}", "buffer_b_code": "#define SPP 3\n\n\nvec3 opU( vec3 d, float iResult, float mat ) {\n\treturn (iResult < d.y) ? vec3(d.x, iResult, mat) : d;\n}\n    \nvec3 worldhit( in vec3 ro, in vec3 rd, in vec2 dist, out vec3 normal ) {\n    vec3 tmp0, tmp1, d = vec3(dist, 0.);\n    \n    d = opU(d, iPlane      (ro,                  rd, d.xy, normal, vec3(0,1,0), 0.), 1.);\n    \n    d = opU(d, iBox        (ro-vec3( 0,.252, 1), rd, d.xy, normal, vec3(.25)), 2.);\n    d = opU(d, iSphere     (ro-vec3( 0,.252, 0), rd, d.xy, normal, .25), 3.);\n    d = opU(d, iSphere     (ro-vec3( 0.6,.252, 0.2), rd, d.xy, normal, .25), 3.);\n    d = opU(d, iSphere     (ro-vec3( -0.5,.252, 0.1), rd, d.xy, normal, .25), 3.);\n\n    return d;\n}\n\n\n#define LASER_PATH 14\nint cpath;\nvec4 path[LASER_PATH];\n\nconst float crad = 0.02;\nfloat pathhit(in vec3 ro, in vec3 rd, float td) {\n    float acc = 0.0;\n    \n    for(int i = 0; i <= cpath; i++)\n    {\n        if(path[i].w > 0.0 && path[i+1].w > 0.0)\n        {\n            float ct = iCylinder(ro,rd,path[i].xyz,path[i+1].xyz,crad);\n            if(ct < td && ct > 0.0)\n            {\n                vec3 a = (path[i].xyz - path[i+1].xyz);\n                vec3 b = rd;\n                vec3 c = (path[i+1].xyz - ro);\n                vec3 cro = cross(a,b);\n                float d = abs(dot(c,cro)/length(cross(a,b)));\n                acc += 15.0*smoothstep(1.0, 0., pow(d/crad,0.2));\n            }\n        }\n    }\n    return acc;\n}\n\nbool getRay(vec2 uv, out vec3 ro, out vec3 rd)\n{\n    mat3 cam = getCam(get(CamA));\n    vec2 apert_cent = -0.*uv; \n    vec2 ap = aperture();  \n    if(!(distance(ap, apert_cent) < 1.0)) return false;  \n    float apd = length(ap);  \n    vec3 daperture = ap.x*cam[0] + ap.y*cam[1]; \n    ro = get(CamP).xyz + aperture_size*daperture;\n    float focus =2.5 + 0.8*pow(apd,5.0);\n    rd = normalize(focus*(cam*vec3(FOV*uv, 1.0)) - aperture_size*daperture);\n    return true;\n}\n\nvoid processhit(in vec3 res, inout vec3 ro, inout vec3 rd, inout float inside,\n                in float ior, in vec3 normal, inout vec3 col, inout vec3 att)\n{\n    ro += rd*res.y;\n           \n    if(res.z <= 2.0)\n    {\n\n        rd = reflect(rd, normalize(nrand3(0.25, normal))); \n    }\n    else\n    {\n        inside = -inside;\n        vec3 matn = normalize(nrand3(0.005, -normal*inside));\n        vec3 newrd = refract(rd, matn, pow(1.0 + 0.5*ior, inside));\n        if(length(newrd) > 0.5) //not total internal reflection\n        {\n            rd = newrd;\n        }\n        else\n        {\n            rd =reflect(rd, matn); \n        } \n    }\n}\n\nvec4 render(vec2 fragCoord)\n{\n    fragCoord += nrand2(0.5, vec2(0.));\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n   \n    vec3 ro, rd, normal;\n  \n \n    //trace laser\n    \n    // get a random refractive index different per pixel\n    float ior = (rand()-0.5) + 0.03;\n    //ior = (fract(gl_FragCoord.y/3.)-.5);\n    float id=1./(1.0 + ior);\n    // compute index of refraction associated color \n    vec3 scol = spectral_zucconi(300.0*(ior + 0.5) + 400.0);\n   \n    \n    ro =  nrand3(0.0, vec3( -2,.252, 0));\n    rd =  normalize(vec3(0.3,0.,-0.028));\n    float inside = 1.0;\n    \n    vec3 col = vec3(0.0);\n    vec3 att = vec3(1.0);\n    \n    for(cpath = 0; cpath < LASER_PATH - 1; cpath++)\n    {\n        path[cpath] = vec4(ro, att.x);\n        vec3 res = worldhit( ro, rd, vec2(.001, MAX_DIST), normal );\n        if (res.z > 0.) \n        {\n            processhit(res,ro,rd,inside,id,normal,col,att);\n        }\n        else \n        {\n            ro += rd*res.y;\n            break;\n        }\n    }\n    path[cpath+1] = vec4(ro, att.x);\n    \n    if(!getRay(uv, ro, rd)) return vec4(0,0,0,1);\n    \n    col = vec3(0.0);\n    att = vec3(1.0);\n    inside = 1.0;\n    \n    for(int i = 0; i < 5; i++)\n    {\n        vec3 res = worldhit( ro, rd, vec2(.00001, MAX_DIST), normal );\n        \n        vec3 acc = scol*pathhit(ro,rd,res.y);\n        col += att*acc;\n        \n        if (res.z > 0.) \n        {\n            processhit(res,ro,rd,inside,ior,normal,col,att);\n        }\n        else \n        {\n            col += 0.*att*texture(iChannel1, rd).xyz;\n            break;\n        }\n    }\n   \n\n    return vec4(col, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    rng_initialize(fragCoord, iFrame);\n    //prev \n    if(get(CamP).w == 0.0)\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    else\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy)*0.1;\n   \n   for(int i = 0; i < SPP; i++)\n       fragColor += render(fragCoord);\n}", "buffer_b_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtXSR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 56], [58, 58, 115, 115, 230]], "test": "untested"}
{"id": "7llXz8", "name": "Quadratic Axis Aligned BB", "author": "Yusef28", "description": "That rotation tracking took longer than I want to admit. I didn't really understand arcos until this moment lol.\nA good resource: https://pomax.github.io/bezierinfo/\n\n", "tags": ["bezier", "quadratic", "casteljau"], "likes": 4, "viewed": 313, "published": 3, "date": "1625185626", "time_retrieved": "2024-07-30T19:12:38.157185", "image_code": "//black and light blue\n/*\n#define bgCol   vec3(244, 244, 248)/255.\n#define lineCol vec3(254, 215, 102)/255.*0.\n#define segCol vec3(42, 183, 202)/255.\n#define circleCol vec3(42, 183, 202)/255.\n#define segCircleCol vec3(210., 81., 224.)/255.\n#define magikCol vec3(142,142,246)/255.\n*/\n\n#define numSegments 20.\n#define showSeg\n//Cappacino pallet\n#define bgCol   vec3(60, 47, 47)/255.*0.5\n#define lineCol vec3(133, 68, 66)/255.\n#define segCol vec3(225, 244, 230)/255.\n#define circleCol vec3(255, 244, 230)/255.\n#define segCircleCol vec3(255, 244, 230)/255.\n#define magikCol vec3(60, 47, 47)/255.\n\n#define lineThickness 0.004\n#define gradLineThickness 0.004*3.\n#define segRingRadius 0.006\n#define gradRingRadius 0.03\n#define pointRingRadius 0.01\n\nfloat distToLine(vec2 A, vec2 B, vec2 p){\n    \n    vec2 PA = p - A;\n    vec2 BA = B - A;\n    float d = dot(PA,BA);\n    float t = clamp(d/(length(BA)*length(BA)),0., 1.);//Vektorprodukt\n    vec2 normal = PA - BA*t;\n    return length(normal);\n\n}\n\n\nvec3 drawRing(float radius, float thickness, vec2 p, vec2 off, vec3 col, vec3 ringCol){\n    \n    p -= off;\n    \n    float eps = 1./min(iResolution.x,iResolution.y);\n    \n    float circle = 1.-smoothstep(-eps, eps, \n    abs(radius - length(p))-thickness);\n    \n    col = mix(col, ringCol, circle);\n    \n    return col;\n}\n\nvec3 drawLine(vec2 A, vec2 B, vec2 p, vec3 col, vec3 lineColor, float th){\n\n    //float dist = 1.0-smoothstep(0.004, 0.005, distToLine(A, B, p));\n    float dist = distToLine(A, B, p);\n    dist = 1.0-smoothstep(0., fwidth(dist), dist - th);\n    return mix(col, lineColor, dist);\n}\n\n\n//shorten version thx iapafoto, original version with notes is below\n//but then I went and added a matrix version to it\nvec3 drawSegments(vec2 p, vec2 p1, vec2 p2, vec2 p3, vec3 col){\n    vec2 g, prev = p1;\n    float dt = 1./numSegments;  \n    \n    for(float t = 0.; t <= 1.+dt; t+=dt){   \n    \n\n        g = p3*(t*t) + p2*2.*(1.-t)*t + p1*(1.-t)*(1.-t);\n        \n        col = drawLine(prev,g,p,col,segCol*vec3(t, .7, .9),lineThickness);\n        col = drawRing(segRingRadius, .003, p, g, col, segCircleCol);\n        prev = g;\n    }\n    return col;\n}\n\n//calculate and draw bounding box, mix with color and return\nvec3 drawExtrema(vec2 p, vec2 p1, vec2 p2, vec2 p3, vec3 boxCol, vec3 col){\n\n    vec2 g = vec2(0.0);\n    \n    float tx = clamp((p1.x - p2.x)/(p1.x - 2.*p2.x + p3.x),0.,1.);\n    float x = p3.x*(tx*tx) + p2.x*2.*(1.-tx)*tx + p1.x*(1.-tx)*(1.-tx);\n    \n    float ty = clamp((p1.y - p2.y)/(p1.y - 2.*p2.y + p3.y),0.,1.);\n    float y = p3.y*(ty*ty) + p2.y*2.*(1.-ty)*ty + p1.y*(1.-ty)*(1.-ty);\n    \n    //col = drawRing(segRingRadius, .003, p, vec2(x,y), col,vec3(1.,0.,0.));\n    \n    \n    float top = min(y, min(p1.y,p3.y));\n    float bottom = max(y, max(p1.y,p3.y));\n    float right = min(x, min(p1.x,p3.x));\n    float left = max(x, max(p1.x,p3.x));\n    \n    vec2 uv = p;\n    col = drawLine(vec2(right,top),vec2(left,top),uv,col,boxCol,lineThickness);\n    col = drawLine(vec2(right,top),vec2(right,bottom),uv,col,boxCol,lineThickness);\n    col = drawLine(vec2(right,bottom+0.01),vec2(left,bottom+0.01),uv,col,boxCol,lineThickness);\n    col = drawLine(vec2(left,top),vec2(left,bottom),uv,col,boxCol,lineThickness);\n    \n    \n    return col;\n}\n\n\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)*2./iResolution.y;\n    \n    float eps = 1./min(iResolution.x, iResolution.y);\n    \n    //calculating p1 as an offset that I'll apply to the other points\n    \n    //original points\n    vec2 p1 = vec2(-0.5, -0.3)+ vec2(sin(iTime+5.),cos(iTime+5.))/2.;\n    vec2 p2 = vec2(0.0, 0.3) + vec2(sin(iTime+5.),cos(iTime+6.))/5.;\n    vec2 p3 = vec2(0.5, -0.3) + vec2(sin(iTime+0.2),cos(iTime+0.2))/5.;\n     \n    //new points with offset so p1Prime is always 0,0\n    vec2 off = p1; \n    vec2 p1Prime = p1 - off;\n    vec2 p2Prime = p2 - off;\n    vec2 p3Prime = p3 - off;\n        \n    //x axis for alignment\n    vec2 xAxis = vec2(1.,0.);\n    //dot a*b = |a|*|b|*cos(a)\n    \n    //get the angle between p3 and x axis to put it right on the x line\n    float a = acos(dot(xAxis,p3Prime) /(length(xAxis)*length(p3Prime)));\n    \n    //save p3.y for reversing the process at the end\n    float p3y = p3Prime.y;\n    \n    \n    //This is is the arccos thing here:\n    //rotate the other points by the angle between p3 and x BUT if \n    //p3.y is already negative we have to rotate in the opposite direction\n    //because acos only gives an angle between 0 and pi as we move towards 180\n    //then from 180 to 360 the angle decreases again to 0.\n    //p2Prime=p2Prime*rot(a*sign(p3y));\n    //p3Prime=p3Prime*rot(a*sign(p3y));\n    \n    //an optimization of above two lines by Oneshade (no trig!)\n    float r = length(p3Prime);\n    vec2 cosi = p3Prime / r; // Force the point onto the unit circle to get sin/cos\n    p2Prime = p2Prime * mat2(cosi, -cosi.y, cosi.x); // Rotate\n    p3Prime = vec2(r, 0.0); // Because we are undoing the rotation of p3Prime\n\n    \n    vec2 line1 = p2-p1;\n    vec2 line2 = p3-p2;\n    float t = sin(iTime)*0.5+0.5;\n    \n    vec2 dLinePoint1 = p1*t + (1.0-t)*p2;\n    vec2 dLinePoint2 = p2*t + (1.0-t)*p3;\n    \n    vec2 magik = dLinePoint1*t + (1.0-t)*dLinePoint2;\n    \n    \n    vec3 col = bgCol;\n    // Time varying pixel color\n    vec3 magik_farber = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float line1Dist = 1.0-smoothstep(0.004, 0.005, distToLine(p1, p2, uv));\n    float line2Dist = 1.0-smoothstep(0.004, 0.005, distToLine(p2, p3, uv));\n    float line3Dist = 1.0-smoothstep(0.004, 0.005,\n    distToLine(dLinePoint1, dLinePoint2, uv));\n    \n    //float line4Dist = 1.0-smoothstep(0.004, 0.005,\n    //distToLine(magik, p2, uv));\n    \n    \n    col = drawRing(0.01, 0.003, uv, p1, col, lineCol*1.2);\n    col = drawRing(0.01, 0.003, uv, p2, col, lineCol*1.2);\n    col = drawRing(0.01, 0.003, uv, p3, col, lineCol*1.2);\n    \n    col = mix(col, lineCol, line1Dist);\n    col = mix(col, lineCol, line2Dist);\n    col = mix(col, lineCol, line3Dist);\n    //col = mix(col, circleCol, line4Dist);\n    \n    col = drawRing(0.01, 0.003, uv, dLinePoint1, col, circleCol);\n    col = drawRing(0.01, 0.003, uv, dLinePoint2, col, circleCol);\n    col = drawRing(0.01, 0.003, uv, magik, col, magikCol);\n    \n    col = drawSegments(uv, p1, p2, p3, col);\n    //AA segment\n    //col = drawSegments(uv, p1Prime, p2Prime, p3Prime, col);\n    \n    //Good bounding Box\n    col = drawExtrema(uv, p1, p2, p3, vec3(1.,0.,0.),col);\n    \n    //I reverse everything right here for the uv that goes into the second\n    //bounding box function\n    vec2 ruv = (uv-off)*rot(a*sign(p3y));\n    \n    //better Bounding box\n    col = drawExtrema(ruv, p1Prime, p2Prime, p3Prime, vec3(0.,0.,1.), col);\n    \n    //vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.15); // change pow for modifying the extend of the  vignette\n\n    fragColor = vec4(col*vig,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7llXz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[742, 742, 783, 783, 985], [988, 988, 1075, 1075, 1307], [1309, 1309, 1383, 1454, 1588], [1591, 1711, 1774, 1774, 2140], [2142, 2203, 2278, 2278, 3241], [3245, 3245, 3263, 3263, 3306], [3308, 3308, 3365, 3415, 7096]], "test": "untested"}
{"id": "sllXzH", "name": "Maxnorm Distance to Parabola", "author": "oneshade", "description": "Maxnorm distance to a parabola.", "tags": ["2d", "sdf", "distance", "parabola", "maxnorm", "linf"], "likes": 7, "viewed": 188, "published": 3, "date": "1625178388", "time_retrieved": "2024-07-30T19:12:38.914161", "image_code": "float sdParabola(in vec2 p, in float h) {\n    float x = sqrt(0.25 + max(0.0, abs(p.x * h) + p.y * h)) - 0.5;\n    return (x * x / h - p.y) * sign(h);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Boilerplate\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    float time = iTime * 0.5;\n\n    // Default before user interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse = vec2(0.5, 0.5 * sin(time)) * cos(time);\n\n    float a = sin(0.25 * iTime) * 16.0;\n    float b = cos(0.25 * iTime);\n    float c = 0.25 * sin(0.5 * iTime);\n    vec2 vertex =  vec2(-0.5 * b / a, c - 0.25 * b * b / a);\n\n    float d = sdParabola(uv - vertex, a);\n    d *= 2.0; // Shrink isolines\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n    float mDist = abs(sdParabola(mouse - vertex, a));\n    color = mix(color, vec3(0.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - mouse) - 0.008));\n    color = mix(color, vec3(0.0, 1.0, 0.0), smoothstep(unit, 0.0, abs(max(abs(uv.x - mouse.x), abs(uv.y - mouse.y)) - mDist) - 0.001));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sllXzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 150], [152, 152, 207, 226, 1367]], "test": "untested"}
{"id": "stB3Rd", "name": "SDF-Develop", "author": "golinad", "description": "For learning and testing sdf rendering", "tags": ["sdf"], "likes": 3, "viewed": 355, "published": 3, "date": "1625174799", "time_retrieved": "2024-07-30T19:12:39.664156", "image_code": "// Uncomment for debug rendering\n//#define COMPLEXITY\n//#define ISOLINES\n//#define CURVATURE\n\nfloat delta = 0.0001;\nfloat delta2 = 0.1;\nfloat maxT = 20.0;\n//vec4 bgColor = vec4(0.25,0.5,0.8,1.0);\nvec4 bgColor = vec4(1.0,1.0,1.0,1.0);\n\n// SDF primitives\n// giving primitives a position makes them easy to use\n// but more complex in calculation and difficult to use with manipulations like extrude\nfloat sdSphere(vec3 pos, float r, in vec3 p) {\n    return distance(p, pos) - r;\n}\nfloat sdBox(vec3 pos, vec3 ext, in vec3 p) {\n// ok for inner part, but sharp outside and too long distance at corners\n// works, but incompatible with rounding\n/*    return max(max(abs(p.x - pos.x) - ext.x/2.0, \n                   abs(p.y - pos.y) - ext.y/2.0),\n                   abs(p.z - pos.z) - ext.z/2.0);*/\n    vec3 q = abs(p-pos) - ext/2.0;\n    return length(max(q,0.0)) + min(max(max(q.x, q.y),q.z),0.0);\n}\nfloat sdTorus(in vec3 p, float r1, float r2) {\n    vec3 c = vec3(normalize(p.xy)*r1, 0.0);\n    return distance(p, c) - r2;\n}\n\n// SDF operations\nfloat sdUnion(float a, float b) {return min(a,b);}\nfloat sdIntersect( float a, float b) {return max(a,b);}\nfloat sdSubstract(float a, float b) {return max(a, -b);}\n\nfloat sdShell(float d, float t) {return abs(d)-t;}\n\nvec3 sdExtrude(vec3 pos, vec3 dir) {\n    return pos - clamp(pos, -0.5*dir, 0.5*dir);\n}\nvec3 sdArray(vec3 pos, vec3 step) {\n    // we dont want the break in the center\n    // the repeaded block should be centered at origin\n    return mod(pos +0.5*step, step) - 0.5*step;\n}\nvec3 sdMirror(vec3 pos) {\n    return abs(pos);\n}\n\nfloat isoLines(float d, float seg) {\n    return mod(d, seg) > seg*0.95 ^^ d < 0.0?1.0:0.0;\n}\n\nfloat map(in vec3 p) {\n    float d1 = sdShell(sdSphere(vec3(0,0,0), 0.5, sdExtrude(sdArray(p-vec3(sin(iTime), cos(iTime), 0.0), vec3(2,2,2)), vec3(0,1,0))), 0.1);\n    float d2 = sdBox(vec3(cos(iTime), sin(iTime), sin(iTime)), vec3(8.0,2.0,12), p) - 1.0;\n    float d = sdSubstract(d1,d2);\n    //d = sdUnion(d, sdTorus(sdMirror(p - vec3(cos(iTime), sin(iTime), sin(iTime)-5.0)) - vec3(3,0,1), 2.0, 1.0));\n    \n    return d;\n}\n\n// calculate normal based on simplified(3 vs. 6 samples) gradient around pos\n// Note: when we are marching solids, d is 0 on surface\nvec3 calcNormal(in vec3 p, in float d) {\n    float dx = map(p + vec3(delta,0,0));\n    float dy = map(p + vec3(0,delta,0));\n    float dz = map(p + vec3(0,0,delta));\n    \n    return normalize(vec3(dx-d, dy-d, dz-d));\n}\n\nfloat calcCurvature(in vec3 p, in float d) {\n    float dx = map(p + vec3(delta2,0,0));\n    float dy = map(p + vec3(0,delta2,0));\n    float dz = map(p + vec3(0,0,delta2));\n    \n    float ndx = map(p + vec3(-delta2,0,0));\n    float ndy = map(p + vec3(0,-delta2,0));\n    float ndz = map(p + vec3(0,0,-delta2));\n    \n    \n    return clamp((dx+dy+dz+ndx+ndy+ndz-6.0*d)/delta2/4.0,-1.0,1.0);\n}\n\nvoid render(out vec4 fragColor, in vec3 ro, in vec3 rd) {\n    float t = 0.0;\n    \n    int j = 0;\n    for(int i = 0; i < 100; i++) {\n        if (t > maxT) {\n            fragColor = bgColor;\n            break;\n        }\n        \n        float d = map(ro+t*rd);\n        if(d < delta || i == 99) {\n            vec3 n = calcNormal(ro+t*rd, d);\n            fragColor = vec4((n*0.5+0.5)*min(calcCurvature(ro+t*rd, d)+1.0, 1.0),1.0);\n#ifdef CURVATURE\n    fragColor = mix(vec4(0,0,1,1), vec4(1,0,0,1), calcCurvature(ro+t*rd, d) *0.5 + 0.5);\n#endif\n            break;\n        } else {\n            t += d;\n        }\n        j++;\n    }\n    // fade to bg (fog)\n    fragColor = mix(fragColor, bgColor, t/maxT);\n    \n#ifdef COMPLEXITY //marching complexity\n    fragColor = mix(vec4(0,0,1,1), vec4(1,0,0,1), float(j)/100.0);\n#endif\n}\n\nvoid debugRender(out vec4 fragColor, in vec2 uv) {\n    float d = map(vec3(uv,0));\n    vec3  n = calcNormal(vec3(uv, 0), d);\n    float l = isoLines(d, 0.1);\n\n    // colored\n    //fragColor = vec4((n*0.5+0.5)*l,1.0);\n    \n    // monochrome\n    fragColor = vec4(l,l,l,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy/2.0)/iResolution.y*2.0;\n    \n#ifdef ISOLINES\n    debugRender(fragColor, uv);\n    //fragColor = vec4(mod(uv, 1.0), 0,1);\n#else\n    vec3 ro = vec3(0,0,1);\n    vec3 rd = normalize(vec3(uv.xy, 0) - ro);\n    render(fragColor, ro , rd);\n#endif\n\n\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) {\n\n    render(fragColor, fragRayOri, fragRayDir);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stB3Rd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[235, 396, 442, 442, 477], [478, 478, 522, 790, 892], [893, 893, 939, 939, 1017], [1019, 1037, 1070, 1070, 1087], [1088, 1088, 1126, 1126, 1143], [1144, 1144, 1181, 1181, 1200], [1202, 1202, 1235, 1235, 1252], [1254, 1254, 1290, 1290, 1340], [1341, 1341, 1376, 1475, 1525], [1526, 1526, 1551, 1551, 1574], [1670, 1670, 1692, 1692, 2093], [2095, 2228, 2268, 2268, 2444], [2446, 2446, 2490, 2490, 2833], [2835, 2835, 2892, 2892, 3652], [3654, 3654, 3704, 3704, 3926], [3928, 3928, 3985, 4035, 4317], [4319, 4319, 4413, 4413, 4463]], "test": "untested"}
{"id": "sllSzH", "name": "smesharik Kopatych", "author": "mariia_sharkovskaya", "description": "smesharik Kopatych from ovals and circles", "tags": ["smesharik"], "likes": 0, "viewed": 218, "published": 3, "date": "1625172158", "time_retrieved": "2024-07-30T19:12:40.611622", "image_code": "    float C(float x, float y, float r) { // circle's function\n            return x*x + y*y - r;\n    }\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = 1.0 - 2.0 * fragCoord/iResolution.xy;\n     float x = p.x * iResolution.x/iResolution.y;\n     float y = p.y;\n      float f = 10.0*C(3.0*x, 3.0*y, 1.5);              //body\n      f = min (f, 20.0*C(3.0*x-0.5, 4.0*y-1.75, 0.15)); //lef leg\n      f = min (f, 20.0*C(3.0*x+0.5, 4.0*y-1.75, 0.15)); //right leg \n      f = min (f, 50.0*C(3.0*x-0.8, 4.0*y+1.35, 0.04)); //left ear\n      f = min (f, 50.0*C(3.0*x+0.8, 4.0*y+1.35, 0.04)); // right ear\n      f = min (f, 20.0*C(5.0*x-2.1, 4.0*y-0.2, 0.24));  //left hand\n      f = min (f, 20.0*C(5.0*x+2.1, 4.0*y-0.2, 0.24));  //right hand\n      f /= 0.05/C(6.0*x+0.5, 6.0*y+0.8, 0.24); //right eye\n      f /= 0.05/C(7.0*x+0.5, 7.0*y+0.8, 0.09); \n      f /= 0.05/C(6.0*x-0.5, 6.0*y+0.8, 0.24); //left eye\n      f /= 0.05/C(7.0*x-0.5, 7.0*y+0.8, 0.09); \n      f /= 0.05/C(6.0*x+0.0, 10.0*y+0.4, 0.26); //nose\n      f /= 0.05/C(6.0*x+0.0, 20.0*y-1.3, 0.26); //mouse\n              vec3 col;\n              if (f <= 1.0)col.r = -f;\n              fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sllSzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[4, 4, 40, 61, 101], [102, 102, 158, 158, 1181]], "test": "untested"}
{"id": "slsXRH", "name": "Juicy Colour", "author": "xenn", "description": "Check mouse! \n\nhttps://xemantic.github.io/shader-web-background/\n \nGoal: shadertoy-style shaders in regular web development\n", "tags": ["mouse", "background", "shadertoy", "feedback", "integration", "library", "web", "webdevelopment", "webdev", "javascript"], "likes": 9, "viewed": 441, "published": 3, "date": "1625170533", "time_retrieved": "2024-07-30T19:12:41.617932", "image_code": "\n  // Fork of a fork of a fork mixed with a fork or two of forks \n        // Funnily enough a few forks too forked\n        // No fork is too forky\n        // It's a fork eat fork world\n        // Fork that bridge when we get to it\n        // And let me get the Bill S. reference over with;\n        // Macfork, ahem, I mean, that scottish fork\n        // I don't care if that makes no sense, enjoy...\n// 2021-06-21 18:40:35\n\n/*\n\tFull Scene Radial Blur\n\t----------------------\n\n\tRadial blur - as a postprocessing effect - is one of the first things I considered doing \n\twhen the multipass system came out. I've always loved this effect. Reminds me of the early \n\tdemos from Aardbei et al. \n\n\tAnyway, Shadertoy user, Passion, did a really cool radial blur on a field of spheres that\n\tinspired me to do my own. Radial blurs are pretty straight forward, but it was still\n    helpful to have Passion's version as a guide. \n\n    As for the radial blur process, there's not much to it. Start off at the pixel position, \n    then radiate outwards gathering up pixels with decreased weighting. The result is a\n\tblurring of the image in a radial fashion, strangely enough. :)\n\n\tInspired by:\n\n\tBlue Dream - Passion\n\thttps://www.shadertoy.com/view/MdG3RD\n\n\tRadial Blur - IQ\n\thttps://www.shadertoy.com/view/4sfGRn\n\n\tRays of Blinding Light - mu6k\n\thttps://www.shadertoy.com/view/lsf3Dn\n\n*/\n\n// The radial blur section. Shadertoy user, Passion, did a good enough job, so I've used a\n// slightly trimmed down version of that. By the way, there are accumulative weighting \n// methods that do a slightly better job, but this method is good enough for this example.\n\n\n// Radial blur samples. More is always better, but there's frame rate to consider.\nconst float SAMPLES = 24.; \n\n\n// 2x1 hash. Used to jitter the samples.\nfloat hash( vec2 p ){ return fract(sin(dot(p, vec2(41, 289)))*45758.5453); }\n\n\n// Light offset.\n//\n// I realized, after a while, that determining the correct light position doesn't help, since \n// radial blur doesn't really look right unless its focus point is within the screen boundaries, \n// whereas the light is often out of frame. Therefore, I decided to go for something that at \n// least gives the feel of following the light. In this case, I normalized the light position \n// and rotated it in unison with the camera rotation. Hacky, for sure, but who's checking? :)\nvec3 lOff(){    \n    \n    vec2 u = sin(vec2(1.57, 0) - iTime/2.);\n    mat2 a = mat2(u, -u.y, u.x);\n    \n    vec3 l = normalize(vec3(1.5, 1., -0.5));\n    l.xz = a * l.xz;\n    l.xy = a * l.xy;\n    \n    return l;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // Screen coordinates.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Radial blur factors.\n    //\n    // Falloff, as we radiate outwards.\n    float decay = 0.97; \n    // Controls the sample density, which in turn, controls the sample spread.\n    float density = 0.5; \n    // Sample weight. Decays as we radiate outwards.\n    float weight = 0.1; \n    \n    // Light offset. Kind of fake. See above.\n    vec3 l = lOff();\n    \n    // Offset texture position (uv - .5), offset again by the fake light movement.\n    // It's used to set the blur direction (a direction vector of sorts), and is used \n    // later to center the spotlight.\n    //\n    // The range is centered on zero, which allows the accumulation to spread out in\n    // all directions. Ie; It's radial.\n    vec2 tuv =  uv - .5 - l.xy*.45;\n    \n    // Dividing the direction vector above by the sample number and a density factor\n    // which controls how far the blur spreads out. Higher density means a greater \n    // blur radius.\n    vec2 dTuv = tuv*density/SAMPLES;\n    \n    // Grabbing a portion of the initial texture sample. Higher numbers will make the\n    // scene a little clearer, but I'm going for a bit of abstraction.\n    vec4 col = texture(iChannel0, uv.xy)*0.25;\n    vec4 sha = texture(iChannel1, uv.xy)*0.25;\n    \n    // Jittering, to get rid of banding. Vitally important when accumulating discontinuous \n    // samples, especially when only a few layers are being used.\n    uv += dTuv*(hash(uv.xy + fract(iTime))*2. - 1.);\n    \n    // The radial blur loop. Take a texture sample, move a little in the direction of\n    // the radial direction vector (dTuv) then take another, slightly less weighted,\n    // sample, add it to the total, then repeat the process until done.\n    for(float i=0.; i < SAMPLES; i++){\n    \n        uv -= dTuv;\n        col += texture(iChannel0, uv) * weight ;\n        weight *= decay;\n         \n        \n    }\n    \n    // Multiplying the final color with a spotlight centered on the focal point of the radial\n    // blur. It's a nice finishing touch... that Passion came up with. If it's a good idea,\n    // it didn't come from me. :)\n    col *= (1. - dot(tuv, tuv)*.5);\n    \n    // Smoothstepping the final color, just to bring it out a bit, then applying some \n    // loose gamma correction.\n    fragColor = sqrt(smoothstep(0., 1., col));\n    \n    // Bypassing the radial blur to show the raymarched scene on its own.\n    //fragColor = sqrt(texture(iChannel0, fragCoord.xy / iResolution.xy));\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 p = fragCoord.xy;\n    \n    vec2 uv = (p.xy) / iResolution.xy;\n    \n    //line thickness\n    float th = 0.002;\n    \n    //gradient detection for r,g and b separatly\n    //not sure why I did this actually\n    \n    float gxr = texture(iChannel0, uv.xy+vec2(th, 0.)).r\n    - texture(iChannel0, uv.xy-vec2(th, 0.)).r ;\n    \n    float gyr = texture(iChannel0, uv.xy+vec2(0., th)).r\n    - texture(iChannel0, uv.xy-vec2(0., th)).r;\n    \n    float gxg = texture(iChannel0, uv.xy+vec2(th, 0.)).g\n    - texture(iChannel0, uv.xy-vec2(th, 0.)).g ;\n    \n    float gyg = texture(iChannel0, uv.xy+vec2(0., th)).g\n    - texture(iChannel0, uv.xy-vec2(0., th)).g;\n    \n    float gxb = texture(iChannel0, uv.xy+vec2(th, 0.)).b\n    - texture(iChannel0, uv.xy-vec2(th, 0.)).b;\n    \n    float gyb = texture(iChannel0, uv.xy+vec2(0., th)).b\n    - texture(iChannel0, uv.xy-vec2(0., th)).b;\n    \n    //hack to concea noise from: https://www.shadertoy.com/view/Mdf3zr\n    float gr = gxr*gxr + gyr*gyr;\n    float gg = gxg*gxg + gyg*gyg;\n    float gb = gxb*gxb + gyb*gyb;\n    \n    //more noise control\n    float g = pow((gr+gg+gb)/1.,1.9);\n    \n    \n    vec3 col = texture(iChannel0, p / iResolution.xy).xyz;\n    col = mix(col,  0.5 + 0.5*cos(iTime*4.+uv.y*6.+vec3(0,2,4)),g*100.);\n    \n    fragColor = vec4(col,1.);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "buffer_b_code": "                                                                                                                                                                                                                                                                                        // See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .001;\nconst float iFeedbackFadeRate         = .99;\nconst float iFeedbackColorShiftZoom   = .2;\nconst float iFeedbackColorShiftImpact = .0033;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = .25;\nconst float iBlobEdgeSmoothing        = .0567;\nconst float iBlob1Radius              = .33;\nconst float iBlob1PowFactor           = 20.;\nconst float iBlob1ColorPulseSpeed     = .2;\nconst float iBlob2Radius              = .54;\nconst float iBlob2PowFactor           = 20.;\nconst float iBlob2ColorPulseSpeed     = .0234;\nconst float iBlob2ColorPulseShift     = .125;\nconst float iColorShiftOfRadius       = 1.5;\nconst float iFeedbackMouseShiftFactor = .003;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.bg/colorShift.gr - .5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel2, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n   \n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Postprocess copied with some small modifications from Mattias: https://www.shadertoy.com/view/Ms23DR\n\nvec2 curve(vec2 uv)\n{\n\tuv = (uv - 0.5) * 2.0;\n\tuv *= 1.1;\t\n\tuv.x *= 1.0 + pow((abs(uv.y) / 5.0), 3.0);\n\tuv.y *= 1.0 + pow((abs(uv.x) / 4.0), 3.0);\n\tuv  = (uv / 2.0) + 0.5;\n\tuv =  uv *0.92 + 0.04;\n\treturn uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 uv = curve( q );\n    vec3 oricol = texture( iChannel0, vec2(q.x,q.y) ).xyz;\n    vec3 col;\n\tfloat x =  sin(0.3*iTime+uv.y*21.0)*sin(0.7*iTime+uv.y*29.0)*sin(0.3+0.33*iTime+uv.y*31.0)*0.0005 ;\n\n    col.r = texture(iChannel0,vec2(x+uv.x+0.001,uv.y+0.001)).x+0.05;\n    col.g = texture(iChannel0,vec2(x+uv.x+0.000,uv.y-0.002)).y+0.05;\n    col.b = texture(iChannel0,vec2(x+uv.x-0.002,uv.y+0.000)).z+0.05;\n    col.r += 0.08*texture(iChannel0,0.75*vec2(x+0.025, -0.027)+vec2(uv.x+0.001,uv.y+0.001)).x;\n    col.g += 0.05*texture(iChannel0,0.75*vec2(x+-0.022, -0.02)+vec2(uv.x+0.000,uv.y-0.002)).y;\n    col.b += 0.08*texture(iChannel0,0.75*vec2(x+-0.02, -0.018)+vec2(uv.x-0.002,uv.y+0.000)).z;\n    \n    float vig = (0.0 + 1.0*16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y));\n\tcol *= vec3(pow(vig,0.15));\n\n    col *= vec3(0.9,1.1,0.9);\n    \n\tfloat scans = clamp( 0.35+0.05*sin(3.5*iTime+uv.y*iResolution.y*1.5), 0.0, 1.0);\n\t\n\tfloat s = pow(scans,0.75);\n\tcol = col *vec3(0.4+0.7*s);\n\n    col *= 1.0+0.035*sin(110.0*iTime);\n\n\tcol*=1.0-0.75*vec3(clamp((mod(fragCoord.x, 2.0)-1.0)*1.0,0.0,1.0));\n\t\n    float comp = smoothstep( 0.1, 0.9, sin(iTime) );\n\n    fragColor = vec4(col,1.0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "\n\n// Fork of \"spirit aura\" by xenn. https://shadertoy.com/view/7lSGzR\n// 2021-06-21 18:20:40\n\n/*\n\tFull Scene Radial Blur\n\t----------------------\n\n\tRadial blur - as a postprocessing effect - is one of the first things I considered doing \n\twhen the multipass system came out. I've always loved this effect. Reminds me of the early \n\tdemos from Aardbei et al. \n\n\tAnyway, Shadertoy user, Passion, did a really cool radial blur on a field of spheres that\n\tinspired me to do my own. Radial blurs are pretty straight forward, but it was still\n    helpful to have Passion's version as a guide. \n\n    As for the radial blur process, there's not much to it. Start off at the pixel position, \n    then radiate outwards gathering up pixels with decreased weighting. The result is a\n\tblurring of the image in a radial fashion, strangely enough. :)\n\n\tInspired by:\n\n\tBlue Dream - Passion\n\thttps://www.shadertoy.com/view/MdG3RD\n\n\tRadial Blur - IQ\n\thttps://www.shadertoy.com/view/4sfGRn\n\n\tRays of Blinding Light - mu6k\n\thttps://www.shadertoy.com/view/lsf3Dn\n\n*/\n\n// The radial blur section. Shadertoy user, Passion, did a good enough job, so I've used a\n// slightly trimmed down version of that. By the way, there are accumulative weighting \n// methods that do a slightly better job, but this method is good enough for this example.\n\n\n// Radial blur samples. More is always better, but there's frame rate to consider.\nconst float SAMPLES = 128.; \n\n\n// 2x1 hash. Used to jitter the samples.\nfloat hash( vec2 p ){ return fract(sin(dot(p, vec2(41, 289)))*45758.5453); }\n\n\n// Light offset.\n//\n// I realized, after a while, that determining the correct light position doesn't help, since \n// radial blur doesn't really look right unless its focus point is within the screen boundaries, \n// whereas the light is often out of frame. Therefore, I decided to go for something that at \n// least gives the feel of following the light. In this case, I normalized the light position \n// and rotated it in unison with the camera rotation. Hacky, for sure, but who's checking? :)\nvec3 lOff(){    \n    \n    vec2 u = sin(vec2(1.57, 0) - iTime/2.);\n    mat2 a = mat2(u, -u.y, u.x);\n    \n    vec3 l = normalize(vec3(1.5, 1., -0.5));\n    l.xz = a * l.xz;\n    l.xy = a * l.xy;\n    \n    return l;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // Screen coordinates.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Radial blur factors.\n    //\n    // Falloff, as we radiate outwards.\n    float decay = 0.97; \n    // Controls the sample density, which in turn, controls the sample spread.\n    float density = 0.75; \n    // Sample weight. Decays as we radiate outwards.\n    float weight = 0.1; \n    \n    // Light offset. Kind of fake. See above.\n    vec3 l = lOff();\n    \n    // Offset texture position (uv - .5), offset again by the fake light movement.\n    // It's used to set the blur direction (a direction vector of sorts), and is used \n    // later to center the spotlight.\n    //\n    // The range is centered on zero, which allows the accumulation to spread out in\n    // all directions. Ie; It's radial.\n    vec2 tuv =  uv - .5 - l.xy*.45;\n    \n    // Dividing the direction vector above by the sample number and a density factor\n    // which controls how far the blur spreads out. Higher density means a greater \n    // blur radius.\n    vec2 dTuv = tuv*density/SAMPLES;\n    \n    // Grabbing a portion of the initial texture sample. Higher numbers will make the\n    // scene a little clearer, but I'm going for a bit of abstraction.\n    vec4 col = texture(iChannel0, uv.xy)*0.25;\n    vec4 sha = texture(iChannel1, uv.xy)*0.25;\n    \n    // Jittering, to get rid of banding. Vitally important when accumulating discontinuous \n    // samples, especially when only a few layers are being used.\n    uv += dTuv*(hash(uv.xy + fract(iTime))*2. - 1.);\n    \n    // The radial blur loop. Take a texture sample, move a little in the direction of\n    // the radial direction vector (dTuv) then take another, slightly less weighted,\n    // sample, add it to the total, then repeat the process until done.\n    for(float i=0.; i < SAMPLES; i++){\n    \n        uv -= dTuv;\n        col += texture(iChannel0, uv) * weight ;\n        weight *= decay;\n         \n        \n    }\n    \n    // Multiplying the final color with a spotlight centered on the focal point of the radial\n    // blur. It's a nice finishing touch... that Passion came up with. If it's a good idea,\n    // it didn't come from me. :)\n    col *= (1. - dot(tuv, tuv)*.75);\n    \n    // Smoothstepping the final color, just to bring it out a bit, then applying some \n    // loose gamma correction.\n    fragColor = sqrt(smoothstep(0., 1., col));\n    \n    // Bypassing the radial blur to show the raymarched scene on its own.\n    //fragColor = sqrt(texture(iChannel0, fragCoord.xy / iResolution.xy));\n}\n\n", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slsXRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1761, 1802, 1823, 1823, 1878], [1881, 2377, 2389, 2389, 2593], [2597, 2597, 2653, 2685, 5168]], "test": "untested"}
{"id": "slsSR8", "name": "XOR Towers Explorer V2", "author": "GregRostami", "description": "Another variation of KilledByAPixel's Voxel Fractal:\n[url]https://www.shadertoy.com/view/NlB3Rz[/url]\nUse the mouse to fly around this endless fractal cityscape ... use w,s keys to move in/out.", "tags": ["3d", "fractal", "xor", "short", "2tc"], "likes": 4, "viewed": 328, "published": 3, "date": "1625169733", "time_retrieved": "2024-07-30T19:12:42.370919", "image_code": "// Use the mouse to move around the XOR Towers.\n// Use the 'w' & 's' keys to move in/out.\n// A big thanks to Fabrice Neyret for helping me figure out the Z motion algorithm.\nvoid mainImage(out vec4 o, vec2 u)\n{ \n    ivec4 b = ivec4(o -= o);\n    u = 2.*(u+u-R)/R.y;\n  \n    for (; (b.x^b.y^ b.z+int(T.z) ) % 99-int(T.z) > b.z-8 ; )\n        b = ivec4(u * o.a + T.xy, o+=.1 ); \n    \n    o = o/70. - .02*vec4(b%3);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define k(c) texelFetch(iChannel1,ivec2(c,0),0).x > 0.\nvoid mainImage( out vec4 o,vec2 u )\n{\n    o = T;\n    k(87) ? o++ : k(83) ? o-- : o;\n\n    o.xy =  abs(T.xy + iMouse.xy / R - .5);   \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T texture(iChannel0,u)//\n#define R iResolution.xy//", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slsSR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 174, 210, 210, 411]], "test": "untested"}
{"id": "7tlSRH", "name": "iam", "author": "MaksymYakushev", "description": "iam", "tags": ["iam"], "likes": 0, "viewed": 218, "published": 3, "date": "1625167157", "time_retrieved": "2024-07-30T19:12:43.166791", "image_code": "float _(float a, float b, float c){\n                  return max(a,max(b,c));\n        }\n             \n        float L(vec2 p, vec2 P0, vec2 P1){\n                float a = -(P1.y-P0.y);\n                float b =  (P1.x-P0.x);\n                float d =  P0.x*P1.y- P0.y*P1.x; \n                float x = p.x;\n                float y = p.y;\n                \n                 return a*x + b*y + d;\n        }\n    \n    float T(vec2 p, vec2 P0, vec2 P1, vec2 P2){\n          return  _(\n                     L(p, P0, P1),\n                     L(p, P1, P2), \n                     L(p, P2, P0)\n                   );   \n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//  digitalized Pi profile                      \n          vec2 P[76];\n           P[ 0] = vec2(0.94063,-1.4750);\n           P[ 1] = vec2(0.89063,-1.4563);\n           P[ 2] = vec2(0.86563,-1.4031);\n           P[ 3] = vec2(0.84063,-1.3875);\n           P[ 4] = vec2(0.80313,-1.40310);\n           P[ 5] = vec2(0.76875,-1.4438);\n           P[ 6] = vec2(0.72188,-1.4813);\n           P[ 7] = vec2(0.6625,-1.5094);\n           P[ 8] = vec2(0.59375,-1.5406);\n           P[ 9] = vec2(0.50938,-1.5500);\n           P[10] = vec2(0.47188,-1.5250);\n           P[11] = vec2(0.44063,-1.5063);\n           P[12] = vec2(0.42188,-1.4781);\n           P[13] = vec2(0.38125,-1.4656);\n           P[14] = vec2(0.35938,-1.4375);\n           P[15] = vec2(0.3375,-1.4125);\n           P[16] = vec2(0.32188,-1.3906);\n           P[17] = vec2(0.30313,-1.3781);\n           P[18] = vec2(0.29063,-1.3656);\n           P[19] = vec2(0.275,-1.3469);\n           P[20] = vec2(0.26875,-1.3188);\n           P[21] = vec2(0.24063,-1.3188);\n           P[22] = vec2(0.22188,-1.3406);\n           P[23] = vec2(0.18437,-1.3375);\n           P[24] = vec2(0.14688,-1.3250);\n           P[25] = vec2(0.14688,-1.3000);\n           P[26] = vec2(0.15625,-1.2719);\n           P[27] = vec2(0.15625,-1.0906);\n           P[28] = vec2(0.14375,-1.0344);\n           P[29] = vec2(0.10938,-1.0156);\n           P[30] = vec2(0.075,-0.98438);\n           P[31] = vec2(0.0375,-0.95000);\n           P[32] = vec2(0.021875,-0.91250);\n           P[33] = vec2(0.00625,-0.86875);\n           P[34] = vec2(-0.00625,-0.81250);\n           P[35] = vec2(-0.059375,-0.65000);\n           P[36] = vec2(-0.08125,-0.58438);\n           P[37] = vec2(-0.1375,-0.52500);\n           P[38] = vec2(-0.16875,-0.45313);\n           P[39] = vec2(-0.17812,-0.35938);\n           P[40] = vec2(-0.1625,-0.28750);\n           P[41] = vec2(-0.12187,-0.21563);\n           P[42] = vec2(0.10313,0.053125);\n           P[43] = vec2(0.19688,0.12500);\n           P[44] = vec2(0.28438,0.15312);\n           P[45] = vec2(0.40938,0.20000);\n           P[46] = vec2(0.49375,0.21250);\n           P[47] = vec2(0.57188,0.21250);\n           P[48] = vec2(0.65625,0.20000);\n           P[49] = vec2(0.73438,0.19062);\n           P[50] = vec2(0.7625,0.16562);\n           P[51] = vec2(0.83438,0.13437);\n           P[52] = vec2(0.8625,0.10938);\n           P[53] = vec2(0.8875,0.081250);\n           P[54] = vec2(0.92813,0.040625);\n           P[55] = vec2(0.95313,0.021875);\n           P[56] = vec2(0.97188,0.0031250);\n           P[57] = vec2(0.975,-0.021875);\n           P[58] = vec2(0.99688,-0.037500);\n           P[59] = vec2(1.0125,-0.090625);\n           P[60] = vec2(1.0219,-0.11563);\n           P[61] = vec2(1.0406,-0.16563);\n           P[62] = vec2(1.0688,-0.22500);\n           P[63] = vec2(1.0969,-0.30938);\n           P[64] = vec2(1.0969,-0.33438);\n           P[65] = vec2(1.1156,-0.38125);\n           P[66] = vec2(1.1281,-0.40938);\n           P[67] = vec2(1.1344,-0.49688);\n           P[68] = vec2(1.1438,-0.57813);\n           P[69] = vec2(1.1719,-0.65625);\n           P[70] = vec2(1.1719,-0.74063);\n           P[71] = vec2(1.1969,-0.80938);\n           P[72] = vec2(1.2406,-0.89375);\n           P[73] = vec2(1.2625,-0.91563);\n           P[74] = vec2(1.3219,-0.97188);\n           P[75] = vec2(1.3656,-1.0281);\n   \n    // Normalized pixel coordinates (from -1 to 1)\n            vec2 p = 1.0 - 2.0* fragCoord/iResolution.xy;\n            vec2 m = 1.0 - 2.0* iMouse.xy/iResolution.xy;\n\n             float x = p.x * iResolution.x/iResolution.y;\n             float y = p.y ;\n     \n              float mx = m.x * iResolution.x/iResolution.y;\n              float my = m.y ;\n           \n               x/=mx;\n               y/=my;\n            \n                p.x=x;\n                p.y=y;\n   \n\n                 float  z = 1.0e23; \n                 for(int i=0;i<76-3;i++)\n                  z = min(z, T(p,  P[i],P[i+1], P[i+3]) );   \n                   float f = 10.0/z; \n\n    // Time varying pixel color\n                    vec3 col = vec3(1.0, 1.0, 1.0);\n                    if(f >= 0.0)col.g = f;\n                    else col.r = f; col.g = f; col.b = f;\n                \n\n    // Output to screen\n                     fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlSRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 87], [110, 110, 144, 144, 402], [412, 412, 455, 455, 612], [614, 614, 671, 720, 4885]], "test": "untested"}
{"id": "sllSRH", "name": "Имя и фамилия Филипенко", "author": "filipenkonikita", "description": "имя и фамилия", "tags": [], "likes": 1, "viewed": 207, "published": 3, "date": "1625166744", "time_retrieved": "2024-07-30T19:12:43.924764", "image_code": "    const int font[] = int[](\n     0x69f99, 0x79797, 0xe111e, 0x79997, 0xf171f, 0xf1711, 0xe1d96, 0x99f99, \n     0xf444f, 0x88996, 0x95159, 0x1111f, 0x9f999, 0x9bd99, 0x69996, 0x79971,\n     0x69b5a, 0x79759, 0xe1687, 0xf4444, 0x99996, 0x999a4, 0x999f9, 0x99699,\n     0x99e8e, 0xf843f, 0x6bd96, 0x46444, 0x6942f, 0x69496, 0x99f88, 0xf1687,\n     0x61796, 0xf8421, 0x69696, 0x69e84, 0x66400, 0x0faa9, 0x0000f, 0x00600,\n     0x0a500, 0x02720, 0x0f0f0, 0x08421, 0x33303, 0x69404, 0x00032, 0x00002,\n     0x55000, 0x00000, 0x00202, 0x42224, 0x24442);\n\n    const ivec2 MAP_SIZE = ivec2(4,5);\n\n\n    int drawChar( in int char, in vec2 pos, in vec2 size, in vec2 uv )\n    {\n    uv = vec2(MAP_SIZE)*(uv-pos)/size;\n     ivec2 iuv = ivec2(round(uv));\n     if( iuv.x<0 || iuv.x>MAP_SIZE.x-1 ||\n         iuv.y<0 || iuv.y>MAP_SIZE.y-1 ) return 0;\n      int index = MAP_SIZE.x*iuv.y + iuv.x;\n    return (font[char]>>index)&1;\n\n}\n    vec2  charSize;\n    float spaceSize;\n    vec2  charPos;\n    int   chr;\n\n#define DRAW(a) chr += drawChar( a, charPos, charSize, uv); charPos.x += spaceSize;\n#define A DRAW(0)\n#define E DRAW(4)\n#define F DRAW(5)\n#define I DRAW(8)\n#define K DRAW(10)\n#define L DRAW(11)\n#define N DRAW(13)\n#define O DRAW(14)\n#define P DRAW(15)\n#define T DRAW(19)\n#define SPACE DRAW(49)\n    float End( void )\n    {\n        return float(chr);\n    }\n\n    void SetSize( float size )\n    {\n        charSize = size*vec2(MAP_SIZE) / float(MAP_SIZE.x);\n        spaceSize = charSize.x*1.6;\n    }\n\n    void SetPos( in vec2 pos )\n    {\n        charPos = pos;\n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord / iResolution.y;\n    SetSize( 0.04 );\n\tSetPos( vec2(0.38, 0.5) );\n    F I L I P E N K O SPACE N I K I T A      \n\tfragColor = vec4(0,0,End(),0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sllSRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[590, 590, 662, 662, 910], [1284, 1284, 1307, 1307, 1340], [1346, 1346, 1378, 1378, 1480], [1486, 1486, 1518, 1518, 1547]], "test": "untested"}
{"id": "flBGDy", "name": "3D Bezier: De Casteljau's", "author": "maras", "description": "I made this shader to make it easier to visualize Bezier curves in 3D and de Casteljau's algorithm.\nYou can find more shaders to learn about Bezier curves\non my playlist: https://www.shadertoy.com/pl\nMore info in comment below (sorry, characters limit).", "tags": ["3d", "bezier", "camera", "curve", "learning"], "likes": 3, "viewed": 324, "published": 3, "date": "1625165682", "time_retrieved": "2024-07-30T19:12:45.060727", "image_code": "/* \n Hi. I made this shader to make it easier to visualize Bezier curves in 3D and de Casteljau's algorithm.\n You can find more shaders to learn about Bezier curves\n on my playlist: https://www.shadertoy.com/playlist/X3XfWf (still WiP)\n Enjoy <3\n*/\n\n#define BEZIER_CURVE_POINTS 3 // int, minimum = 2, maximum = 13\n// After changing BEZIER_CURVE_POINTS peremeter you need to reset shader's time (button on the bottom of shader window)\n// PS: higher values can be imposible to compile if your GPU is weak. Sorry\n\n#define BACKWARDS_ANIMATION true // bool\n\n#define SLOW_DOWN 2.0 // float, need to be typed with decimal point (.)\n\n// sorry for naming the parameter \"SLOW_DOWN\" instead of \"SPEED\", but default speed is really fast\n// and it's easier for you to slow down things by an integer instead of speeding up by for example 0.25.\n// If you want to speed up the animation you can use a float lower than 1.0\n\n// Information on the parameters below is provided in the comment\n\n#define SHOW_RED_DOTS true // bool\n#define SHOW_BLUE_DOT true // bool\n#define SHOW_FINAL_DOT true // bool\n\n#define SHOW_BLACK_LINE true // bool\n#define SHOW_GREY_LINES true // bool\n\n#define ALWAYS_SHOW_BEZIER_CURVE false // bool\n\n#define CASTELJAUS_STEPS 50 // int, more than 1000 can really slow down your computer, be careful\n\n#define SHOW_1_SUPPORT_POINT true // bool\n#define SHOW_2_SUPPORT_POINT true // bool\n#define SHOW_3_SUPPORT_POINT true // bool\n#define SHOW_4_SUPPORT_POINT true // bool\n#define SHOW_5_SUPPORT_POINT true // bool\n#define SHOW_6_SUPPORT_POINT true // bool\n#define SHOW_7_SUPPORT_POINT true // bool\n#define SHOW_8_SUPPORT_POINT true // bool\n#define SHOW_9_SUPPORT_POINT true // bool\n#define SHOW_10_SUPPORT_POINT true // bool\n#define SHOW_11_SUPPORT_POINT true // bool\n\n#define SHOW_1_SUPPORT_LINE true // bool\n#define SHOW_2_SUPPORT_LINE true // bool\n#define SHOW_3_SUPPORT_LINE true // bool\n#define SHOW_4_SUPPORT_LINE true // bool\n#define SHOW_5_SUPPORT_LINE true // bool\n#define SHOW_6_SUPPORT_LINE true // bool\n#define SHOW_7_SUPPORT_LINE true // bool\n#define SHOW_8_SUPPORT_LINE true // bool\n#define SHOW_9_SUPPORT_LINE true // bool\n#define SHOW_10_SUPPORT_LINE true // bool\n#define SHOW_11_SUPPORT_LINE true // bool\n\n// non-changeable parameters (don't get me wrong, feel free to experiment with the entire code,\n// but you can screw something up :D )\n\n#define EDGE   0.05   // anti-aliasing\n#define EDGE_LINE 0.0003\n#define SMOOTH_LINE 0.01\n#define SMOOTH 0.001  // anti-aliasing \n\nconst int max_count = BEZIER_CURVE_POINTS;\n\nconst int factorials[13] = int[](\n                           1,\n                           1,\n                           2,\n                           6,\n                           24,\n                           120,\n                           720,\n                           5040,\n                           40320,\n                           362880,\n                           3628800,\n                           39916800,\n                           479001600);\n\nconst vec3 support_lines_colors[11] = vec3[](\n                                      vec3(1.0, 0.839, 0.458),\n                                      vec3(1.0, 0.674, 0.478),\n                                      vec3(1.0, 0.658, 0.560),\n                                      vec3(1.0, 0.541, 0.788),\n                                      vec3(0.992, 0.380, 1.0),\n                                      vec3(0.788, 0.458, 1.0),\n                                      vec3(0.635, 0.541, 1.0),\n                                      vec3(0.380, 0.788, 1.0),\n                                      vec3(0.321, 1.0, 0.803),\n                                      vec3(0.807, 0.705, 0.592),\n                                      vec3(0.509, 0.482, 0.678));\n     \nconst vec3 support_points_colors[11]= vec3[](\n                                      vec3(0.992, 0.792, 0.325),\n                                      vec3(1.0, 0.639, 0.341),\n                                      vec3(1.0, 0.454, 0.301),\n                                      vec3(1.0, 0.039, 0.560),\n                                      vec3(0.807, 0.0, 0.819),\n                                      vec3(0.560, 0.0, 0.921),\n                                      vec3(0.333, 0.160, 1.0),\n                                      vec3(0.019, 0.662, 1.0),\n                                      vec3(0.0, 0.980, 0.694),\n                                      vec3(0.549, 0.443, 0.329),\n                                      vec3(0.270, 0.250, 0.392));                                       \n                                      \nconst vec3 final_dot_color = vec3(0.0,1.0,0.0);\n\nconst bool show_support_points[11] = bool[](\n                                     SHOW_1_SUPPORT_POINT,\n                                     SHOW_2_SUPPORT_POINT,\n                                     SHOW_3_SUPPORT_POINT,\n                                     SHOW_4_SUPPORT_POINT,\n                                     SHOW_5_SUPPORT_POINT,\n                                     SHOW_6_SUPPORT_POINT,\n                                     SHOW_7_SUPPORT_POINT,\n                                     SHOW_8_SUPPORT_POINT,\n                                     SHOW_9_SUPPORT_POINT,\n                                     SHOW_10_SUPPORT_POINT,\n                                     SHOW_11_SUPPORT_POINT);\n                                     \nconst bool show_support_lines[11] = bool[](\n                                    SHOW_1_SUPPORT_LINE,\n                                    SHOW_2_SUPPORT_LINE,\n                                    SHOW_3_SUPPORT_LINE,\n                                    SHOW_4_SUPPORT_LINE,\n                                    SHOW_5_SUPPORT_LINE,\n                                    SHOW_6_SUPPORT_LINE,\n                                    SHOW_7_SUPPORT_LINE,\n                                    SHOW_8_SUPPORT_LINE,\n                                    SHOW_9_SUPPORT_LINE,\n                                    SHOW_10_SUPPORT_LINE,\n                                    SHOW_11_SUPPORT_LINE);\n\nconst float coPlanerThreshold = 0.7; // Some threshold value that is application dependent\nconst float lengthErrorThreshold = 0.1;\n\nvec3 control_points[13] = vec3[](\n                        vec3(-0.5, -0.5, 0.0),\n                        vec3(0.0, 2.0, 0.5),\n                        vec3(0.0, -1.0, 1.5),\n                        vec3(0.4, 1.6, 1.3),\n                        vec3(-1.4, 0.6, 0.3),\n                        vec3(0.4, -1.0, 2.8),\n                        vec3(-0.8, 1.0, 0.8),\n                        vec3(1.2, -0.2, 0.4),\n                        vec3(0.0, 0.0, -1.0),\n                        vec3(3.0, -1.0, 0.7),\n                        vec3(5.4, -4.0, 1.8),\n                        vec3(0.4, 4.0, 3.2),\n                        vec3(0.0, 0.0, 2.0)\n                        );\n\n// link to video explaining below function:\n// https://www.youtube.com/watch?v=ELQG5OvmAE8&ab_channel=EgoMoose\nfloat RaySegmentDistance(vec3 start, vec3 end, vec3 ray_origin, vec3 ray_screen_intersection) { \n\tvec3 q = start - ray_origin;\n    vec3 r = end - start;\n    vec3 s = ray_screen_intersection - ray_origin;\n    \n    float t = (dot(q, s) * dot(r, s)) - (dot(q, r) * dot(s, s));\n    t = t / ((dot(r, r) * dot(s, s)) - (dot(r, s) * dot(s, r)));\n    \n    float u = dot(q, s) + (t * dot(r, s)); \n    u = u / dot(s, s);\n    \n    if (t > 1.0 || t < 0.0 || u < 0.0) { return 100.0; }\n    \n    vec3 P0 = start + t * r;\n    vec3 P1 = ray_origin + u * s;\n    \n    return distance(P0, P1);\n}\n\nint BinomialCoefficient(int n, int k) {\n    return factorials[n] / (factorials[k] * factorials[n-k]);\n}\n\nfloat DistLine(vec3 ray_origin, vec3 ray_direction, vec3 point) {\n    return length(cross(point - ray_origin, ray_direction)) / length(ray_direction);\n}\n\nfloat DrawPoint(vec3 ray_origin, vec3 ray_direction, vec3 point) {\n    float dist = DistLine(ray_origin, ray_direction, point);\n    //dist = 1.0 - smoothstep(0.01, 0.09, dist);\n    \n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec2 mo = vec2(0.0);\n    if (iMouse.z > 0.0) {\n        mo += (2.0 * iMouse.xy - iResolution.xy) / iResolution.yy;\n    }\n    \n    vec4 camPos = textureLod( iChannel0, vec2(.5,.5)/iResolution.xy, 0.0 );\n    vec4 camRot = textureLod( iChannel0, vec2(1.5,.5)/iResolution.xy, 0.0 )*6.28318530718;\n\n    float zoom = 1.0;\n    zoom = textureLod( iChannel2, vec2(1.5,.5)/iResolution.xy, 0.0 ).x;\n    vec3 ray_origin = vec3(0.0,  0.0, -3.0);     // camera point\n    \n    //ray_origin = normalize( vec3( (fragCoord.xy-iResolution.xy*.5)/iResolution.x, 1.0 ) );\n    \n    ray_origin.zy = ray_origin.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*ray_origin.yz;\n    ray_origin.xz = ray_origin.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*ray_origin.zx;\n    \n    vec3 lookat = vec3(0.5); // center of scene\n    vec3 forward_vector = normalize(lookat - ray_origin);\n    vec3 right_vector = cross(vec3(0.0, 1.0, 0.0), forward_vector);\n    vec3 up_vector = cross(forward_vector, right_vector);\n\n    vec3 screen_center = ray_origin + forward_vector * zoom;\n\n    vec3 ray_screen_intersection = screen_center + uv.x * right_vector + uv.y * up_vector;\n    vec3 ray_direction = ray_screen_intersection - ray_origin; // point at screen\n    \n    float t = fract(iTime / SLOW_DOWN);\n\n    if (int(iTime / SLOW_DOWN) % 2 == 1 && BACKWARDS_ANIMATION) {\n        t = 1.0 - t;\n    }\n    \n    control_points[max_count - 1] = control_points[control_points.length() - 1];\n    \n    vec3 final_point = vec3(0.0);\n        \n    float t2 = (1.0 - t);\n            \n    for (int point_index = 0; point_index < max_count; ++point_index) {\n        final_point += float(BinomialCoefficient(max_count - 1, point_index)) \n                 * pow(t2, float(max_count - 1 - point_index)) \n                 * pow(t, float(point_index))\n                 * control_points[point_index];\n     }\n    \n\n    float draw_start_point = DrawPoint(ray_origin, ray_direction, control_points[0]);\n    float draw_end_point = DrawPoint(ray_origin, ray_direction, control_points[max_count - 1]);\n    float draw_final_point = DrawPoint(ray_origin, ray_direction, final_point);\n    \n    vec3 col = vec3(1.0);\n    \n    // draw start point\n    if (draw_start_point < EDGE + SMOOTH && SHOW_RED_DOTS)\n    {\n        draw_start_point = (EDGE - draw_start_point + EDGE / 2.0) / EDGE;\n        col *= vec3(1.0,0.0,0.0) * draw_start_point;\n    }\n    \n    // draw end point\n    if (draw_end_point < EDGE + SMOOTH && SHOW_RED_DOTS)\n    {\n        draw_end_point = (EDGE - draw_end_point + EDGE / 2.0) / EDGE;\n        col *= vec3(1.0,0.0,0.0) * draw_end_point;\n    }\n\n    // draw bezier curve using de Casteljau's algorithm\n    if (SHOW_BLACK_LINE) {\n        vec3 prev_point = control_points[0];\n\n        float end_algorithm = t;\n\n        if(ALWAYS_SHOW_BEZIER_CURVE) { end_algorithm = 1.0; }\n\n        float increaser = end_algorithm / float(CASTELJAUS_STEPS);\n\n        end_algorithm += 0.001; // without it some small values of CASTELJAUS_STEPS couses ending curve before endpoint\n                                // (i don't know why)\n        \n        for (float i = 0.0; i <= end_algorithm; i += increaser) {\n            float i2 = 1.0 - i;\n            \n            vec3 point = vec3(0.0);\n            \n            for (int point_index = 0; point_index < max_count; ++point_index) {\n                point += float(BinomialCoefficient(max_count - 1, point_index)) \n                         * pow(i2, float(max_count - 1 - point_index)) \n                         * pow(i, float(point_index))\n                         * control_points[point_index];\n            }\n\n            float dist = RaySegmentDistance(prev_point, point, ray_origin, ray_screen_intersection);\n\n            if (dist < EDGE_LINE + SMOOTH_LINE)\n            {\n                dist = max(dist, 0.0);\n                dist = smoothstep(EDGE_LINE,EDGE_LINE + SMOOTH_LINE, dist);\n                col *= dist;\n            }\n            \n            prev_point = point;\n        }\n    }\n        \n    // draw control points\n    for (int i = 1; i < max_count - 1; ++i) {\n        float dist = DrawPoint(ray_origin, ray_direction, control_points[i]);\n        \n        if (dist < EDGE + SMOOTH && show_support_points[i])\n        {\n            dist = (EDGE - dist + EDGE / 2.0) / EDGE;\n            col *= vec3(0.0,0.0, float(max_count - i) / float(max_count) + 0.1) * dist;\n        }\n    }\n\n    // draw lines between control points\n    if (SHOW_GREY_LINES) {\n        for (int i = 0; i < max_count - 1; ++i) {\n            float dist = RaySegmentDistance(control_points[i], control_points[i + 1], ray_origin, ray_screen_intersection);\n\n            if (dist < EDGE_LINE + SMOOTH_LINE)\n            {\n                dist = max(dist, 0.0);\n                dist = smoothstep(EDGE_LINE,EDGE_LINE + SMOOTH_LINE, dist);\n                col *= mix(vec3(0.8),vec3(1.0,1.0,1.0),dist);\n            }\n        }\n    }\n\n    // draw support lines and points\n    vec3 support_points[control_points.length()] = control_points;\n    \n    for (int i = 0; i < max_count - 1; ++i) {\n        support_points[0] = support_points[0] + t * (support_points[1] - support_points[0]);\n        \n        for (int j = 1; j < max_count - i - 1; ++j) {\n            support_points[j] = support_points[j] + t * (support_points[j+1] - support_points[j]);\n            \n            float dist = RaySegmentDistance(support_points[j-1], support_points[j], ray_origin, ray_screen_intersection);\n            if (dist < EDGE_LINE + SMOOTH_LINE && show_support_lines[i])\n            {\n                dist = max(dist, 0.0);\n                dist = smoothstep(EDGE_LINE,EDGE_LINE + SMOOTH_LINE, dist);\n                col *= mix(support_lines_colors[i], vec3(1.0,1.0,1.0),dist);\n            }\n            \n            dist = DrawPoint(ray_origin, ray_direction, support_points[j-1]);\n            if (dist < EDGE + SMOOTH && show_support_points[i])\n            {\n                dist = (EDGE - dist + EDGE / 2.0) / EDGE;\n                col *= support_points_colors[i] * dist;\n            }\n        }\n        \n        float dist = DrawPoint(ray_origin, ray_direction, support_points[max_count - i - 1]);\n        if (dist < EDGE + SMOOTH && show_support_points[i])\n        {\n            dist = (EDGE - dist + EDGE / 2.0) / EDGE;\n            col *= support_points_colors[i - 1] * dist;\n        }\n    }\n    \n    // draw final point\n    if (draw_final_point < EDGE + SMOOTH && SHOW_RED_DOTS)\n    {\n        draw_final_point = (EDGE - draw_final_point + EDGE / 2.0) / EDGE;\n        col *= final_dot_color * draw_final_point;\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// camera \"drag and rotate\" system\n// taken almost directly from https://www.shadertoy.com/view/ldyGzW\n\nconst float accel = .01;\nconst float decay = .95; // how much velocity is preserved per frame (proportionally)\n\nconst float yMul = -1.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n\n    if ( int(fragCoord.y) == 0 )\n    {\n        if ( int(fragCoord.x) == 0 )\n        {\n            vec4 camPos = textureLod( iChannel0, vec2(.5,.5)/iResolution.xy, 0.0 );\n            vec4 camVel = textureLod( iChannel0, vec2(3.5,.5)/iResolution.xy, 0.0 );\n            \n            fragColor = camPos + camVel;\n\n            if ( camPos.y < .0 ) { fragColor.y = .0; }\n\n            \n        }\n        else if ( int(fragCoord.x) <= 2 )\n        {\n            vec4 baseCamRot = textureLod( iChannel0, vec2(2.5,.5)/iResolution.xy, 0.0 );\n            vec4 camRot = textureLod( iChannel0, vec2(1.5,.5)/iResolution.xy, 0.0 );\n\n            vec2 mouseRot = (iMouse.yx/iResolution.yx-.5)*vec2(.5*yMul,1.);\n            \n            camRot.w = iMouse.z;\n            \n            bool press = (camRot.w > .0);\n            bool lastPress = (baseCamRot.w > .0);\n            bool click = press && !lastPress;\n            if ( click )\n            {\n                baseCamRot.xy -= mouseRot;\n            }\n            \n            if ( press )\n            {\n                camRot.xy = baseCamRot.xy + mouseRot;\n            }\n            else\n            {\n                //update the base pos\n                baseCamRot = camRot;\n            }\n\n            baseCamRot.w = camRot.w;\n            \n            // store\n            if ( int(fragCoord.x) == 1 )\n            {\n            \tfragColor = camRot;\n            }\n            else\n            {\n            \tfragColor = baseCamRot;\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// zooming system\n// taken almost directly from https://www.shadertoy.com/view/4sVSDm\n\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 1.0;\n    \n    if(iFrame>0) {\n        //read previous state\n        vec4 zoom_vec = textureLod( iChannel2, vec2(1.5,.5)/iResolution.xy, 0.0 );\n        zoom = zoom_vec.x;\n    }\n    \n    //read arrow button press and update state via changing the texture \n    if( texelFetch( iChannel1, ivec2(KEY_UP,1),0 ).x>0.1 ) { zoom *= 1.2; }\n    if( texelFetch( iChannel1, ivec2(KEY_DOWN,1),0 ).x>0.1 ) { zoom /= 1.2; }\n\n    fragColor = vec4(zoom);\n    \n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flBGDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[6817, 6928, 7023, 7023, 7504], [7506, 7506, 7545, 7545, 7609], [7611, 7611, 7676, 7676, 7763], [7765, 7765, 7831, 7831, 7965], [7967, 7967, 8024, 8024, 14704]], "test": "untested"}
{"id": "NlXXR8", "name": "BiComplexFractal 1", "author": "bgold", "description": "messing around with bicomplex numbers which I hadn't even heard of until https://www.shadertoy.com/view/NlBGDd\n", "tags": ["fractal", "bicomplex"], "likes": 2, "viewed": 239, "published": 3, "date": "1625165012", "time_retrieved": "2024-07-30T19:12:46.056065", "image_code": "#define ITER_MAX 255\n#define GAMMA 0.6\n\nvec4 bcSquare( vec4 a ) {\n    return vec4(a.x*a.x - a.y*a.y - a.z*a.z + a.w*a.w,\n                2.0 * (a.x*a.y - a.z*a.t),\n                2.0 * (a.x*a.z - a.y*a.t),\n                2.0 * (a.x*a.t + a.y*a.z));\n}\n\nvec4 bcNorm( vec4 a ) {\n    return vec4(a.x*a.x - a.y*a.y + a.z*a.z - a.w*a.w,\n                2.0 * (a.x*a.y + a.z*a.t),\n                0.0,\n                0.0);\n}\n\nvec3 iterate(vec4 inVec) {\n    vec4 v = inVec;\n    float iterfrac = 0.0;\n    for (int i=0; i<ITER_MAX; i++) {\n        v = bcSquare(v) + inVec;\n        iterfrac = float(i+1)/float(ITER_MAX);\n        if (length(v) > 1000.0) break;\n    }\n    return vec3(bcNorm(v).xy, iterfrac);\n}\n\nvec3 colrot(vec3 c, float th) {\n    vec3 v = c - vec3(0.5);\n    v = mat3(cos(th), 0, -sin(th), 0, 1, 0, sin(th), 0, cos(th)) * v;\n    return v+vec3(0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy/2.0) /iResolution.y;\n    uv *= 2.0;\n\n    vec3 escape = iterate(vec4(uv.x, uv.y, 0.8*sin(iTime/15.7), 0.8*sin(iTime/4.007)));\n    \n    float val = pow(escape.z, GAMMA);\n    float shade = smoothstep(0.1, 10.0, length(escape.xy));\n    float hue = abs(escape.y*10.0);\n    vec3 col = val*colrot(vec3(shade*shade, shade, 1.0), hue);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXXR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 65, 65, 252], [254, 254, 277, 277, 420], [422, 422, 448, 448, 699], [701, 701, 732, 732, 856], [858, 858, 915, 915, 1317]], "test": "untested"}
{"id": "sllXz8", "name": "Simple 2D eye", "author": "mrange", "description": "License CC0: Simple 2D eye\nNothing fancy, just a simple distance field for an eye\n\n", "tags": ["2d", "eye"], "likes": 28, "viewed": 417, "published": 3, "date": "1625164331", "time_retrieved": "2024-07-30T19:12:46.967628", "image_code": "// License CC0: Simple 2D eye\n// Nothing fancy, just a simple distance field for an eye\n\n#define RESOLUTION iResolution\n#define TIME       iTime\n\n#define PI  3.141592654\n#define TAU (2.0*PI)\n\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.0-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n}\n\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, vec3(1.0/2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat vesica(vec2 p, float r, float d) {\n  p = abs(p);\n  float b = sqrt(r*r-d*d);\n  return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                           : length(p-vec2(-d,0.0))-r;\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return p.x*vec2(cos(p.y), sin(p.y));\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return -pmin(-a, a, k);\n}\n\nfloat df(vec2 p) {\n  float a  = mix(0.0, 0.85, smoothstep(0.995, 1.0, cos(TAU*TIME/5.0)));\n  const float b = 4.0;\n  float rr = mix(1.6, b, a);\n  float dd = mix(1.12, b, a);\n  \n  vec2 p0 = p;\n  p0 = p0.yx;\n  float d0 =  vesica(p0, rr, dd);\n  float d5 = d0;\n\n  vec2 p1 = p;\n  p1.y -= 0.28;\n  float d1 = circle(p1, 0.622);\n  d1 = max(d1,d0);\n\n  vec2 p2 = p;\n  p2 -= vec2(-0.155, 0.35);\n  float d2 = circle(p2, 0.065);\n\n  vec2 p3 = p;\n  p3.y -= 0.28;\n  p3 = toPolar(p3);\n  float n3 = mod1(p3.x, 0.05);\n  float d3 = abs(p3.x)-0.0125*(1.0-length(p1));\n\n  vec2 p4 = p;\n  p4.y -= 0.28;\n  float d4 = circle(p4, 0.285);\n\n  d3 = max(d3,-d4);\n\n  d1 = pmax(d1,-d2, 0.0125);\n  d1 = max(d1,-d3);\n\n  float t0 = abs(0.9*p.x);\n  t0 *= t0;\n  t0 *= t0;\n  t0 *= t0;\n  t0 = clamp(t0, 0.0, 1.0);\n  d0 = abs(d0)-mix(0.0125, -0.0025, t0);\n\n\n  float d = d0;\n  d = pmin(d, d1, 0.0125);\n  return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n  float d   = df(p);\n  vec4 dcol = vec4(0.0, 0.0, 0.0, 0.5);\n  dcol.w = mix(0.0, 0.95, smoothstep(-aa, aa, -d));\n  \n  vec3 col  = vec3(1.0);\n//  col = alphaBlend(col, ecol);\n  col = alphaBlend(col, dcol);\n//  col += 0.5*sin(400.0*d);\n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sllXz8.jpg", "access": "api", "license": "cc0-1.0", "functions": [[192, 192, 232, 232, 391], [393, 393, 433, 433, 475], [477, 477, 513, 513, 746], [748, 748, 779, 779, 805], [807, 858, 898, 898, 1047], [1049, 1049, 1071, 1071, 1115], [1117, 1117, 1138, 1138, 1179], [1181, 1212, 1251, 1251, 1376], [1378, 1418, 1457, 1457, 1546], [1548, 1548, 1587, 1587, 1616], [1618, 1618, 1648, 1648, 1676], [1678, 1678, 1696, 1696, 2550], [2552, 2552, 2607, 2607, 3033]], "test": "error"}
{"id": "ftsXz8", "name": "Naive AA vs Exact blend", "author": "pyBlob", "description": "Representing subpixel coverage as transparency for antialiasing assumes that background subpixels are covered independently. In the extreme case (left circle), the covered foreground subpixels exactly match the covered background subpixels.", "tags": ["antialiasing"], "likes": 2, "viewed": 277, "published": 3, "date": "1625143773", "time_retrieved": "2024-07-30T19:12:47.892157", "image_code": "const float pi = radians(180.);\n\nvec4 rainbow(vec2 U)\n{\n    float a = atan(U.y, U.x);\n    vec3 c = cos(vec3(a) - vec3(0, 2, 4)) * .5 + .5;\n    return vec4(c, 1);\n}\n\nbool aa, withcolor;\nvoid blend(inout vec4 O, vec2 R, vec2 U)\n{\n    float d = step(length(U), .12*R.y);\n    if (aa)\n    {\n        float f = 1.2;\n        d = smoothstep(f, 0., length(U) - .12*R.y + f / 2.);\n    }\n\n    vec4 C = vec4(1) * d;\n    if (withcolor)\n        C = rainbow(U) * d;\n\n    O = O * (1. - d) + C;\n}\n\nvec4 image(vec2 R, vec2 U)\n{\n    vec4 O = vec4(0);\n    int N = 20;\n    for (int i=0 ; i<N ; ++i)\n    {\n        float a = (float(i) + .5) / float(N);\n        vec2 M = R/2. + R/4. * cos((a - vec2(0, .25)) * 2. * pi);\n        blend(O, R, U - M);\n    }\n    int M = 20;\n    for (int i=0 ; i<M ; ++i)\n    {\n        blend(O, R, U - vec2(.1, .2) * R);\n        blend(O, R, U - vec2(.1, 1.-.2) * R);\n\n        float y = (float(i) + .5) / float(N);\n        y = mix(.15, .25, y);\n        blend(O, R, U - vec2(.9, y) * R);\n        blend(O, R, U - vec2(.9, 1.-y) * R);\n    }\n    return O;\n}\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    withcolor = u.y > iResolution.y/2.;\n    //aa = u.x < iResolution.x/2.;\n    aa = u.x / iResolution.x < .5 + .5 * sin(iTime * 1.);\n\n    int zoom = 4;\n    vec2 R = iResolution.xy / float(zoom);\n    vec2 U = vec2(ivec2(u) / zoom) + .5;\n\n    O = vec4(0);\n    if (aa)\n        O = image(R, U);\n    else\n    {\n        const int N = 10;\n        for (ivec2 x=ivec2(0) ; x.y<N ; ++x.y)\n        for (x.x=0 ; x.x<N ; ++x.x)\n            O += image(R, U - .5 + (vec2(x) + .5) / float(N));\n        O /= float(N * N);\n    }\n\n    O.xyz = pow(O.xyz, vec3(.45));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsXz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 55, 55, 163], [185, 185, 227, 227, 478], [1057, 1057, 1093, 1093, 1642]], "test": "untested"}
{"id": "slfXzH", "name": "- Thor -", "author": "Mihaha", "description": "...", "tags": ["2d", "3d", "rotation", "thor"], "likes": 5, "viewed": 296, "published": 3, "date": "1625140699", "time_retrieved": "2024-07-30T19:12:48.792749", "image_code": "/*\n\n> by MihasGames, 01.07.2021 <\n(https://mihas-games.itch.io/)\n\n*/\n\nfloat sum(vec2 v) { return v.x + v.y; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.95);\n    float t = iTime*2.;\n    \n    // Pixel Normalizations //\n    vec2 uv01 = fragCoord.xy/iResolution.xy,\n         uv = (uv01 - 0.5) * vec2(iResolution.x / iResolution.y, 1) * 3.6;\n    \n    vec2 cpos = uv*24.5 + vec2(0, -t*2.);\n    if (sum(cos(cpos)) > 1.6) col = vec3(0.9); // Circles //\n   \n    // Thor //\n    float r = sin(t/4.)*0.2-0.7, R = 1.;\n    \n    for (float z=2.; z >=-2.; z-=0.03) {\n        vec3 v = vec3(uv.x, uv.y, z);\n        v.zy *= mat2( cos(t), -sin(t), sin(t), cos(t) );\n        v.yx *= mat2( cos(t/1.2), -sin(t/1.2), sin(t/1.2), cos(t/1.2) );\n\n        if (sqrt( pow( sqrt(v.x*v.x + v.z*v.z)-R, 2.) + pow(v.y, 2.) ) - r < 1.) {\n            col = vec3(uv01.xy, 1.) * vec3((z*.5+.5)/1.5+0.65);\n            break;\n        }\n    } \n    \n    col *= (1. - length((uv01-0.5)/2.))*1.1; // Vignette //\n    \n    fragColor = vec4(col,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slfXzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 89, 89, 109], [111, 111, 168, 168, 1043]], "test": "untested"}
{"id": "fllSz8", "name": "How to merge Circle gradual?", "author": "bbsuuo", "description": "i want merge circle gradual effect and get some effect, but i can't get correct effect \n, could you help me ?", "tags": ["circle", "problem", "seekhelp"], "likes": 0, "viewed": 285, "published": 3, "date": "1625139654", "time_retrieved": "2024-07-30T19:12:49.761160", "image_code": "float distCircle(vec2 p, vec2 c, float r) {\n \t float dst = length(p - c);\n     return  1.0 - clamp( dst/r,0.0,1.0);\n}\n\nfloat blockingCircle(float buffer,float circle){\n  return max(buffer,circle);\n}\n\nfloat mergeCircle(float buffer,float circle)\n{\n return buffer + circle;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x/ iResolution.y;\n    vec2 imouse = iMouse.xy;\n    imouse /= iResolution.xy;\n    imouse = imouse * 2.0 - 1.0;\n    imouse.x *= aspect;\n    \n    vec2 c1 = vec2(0 , 0) ; \n    vec2 uv =   fragCoord.xy  /iResolution.xy ;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= aspect; \n         \n    float circle = distCircle(imouse,uv,0.8);\n    circle = blockingCircle( circle ,distCircle(vec2(-0.3,0.5),uv,0.5));\n    circle = mergeCircle( circle ,distCircle(vec2(-0.3,-0.5),uv,0.5));\n    // Output to screen\n    fragColor = vec4(circle ,  circle , circle,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fllSz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 117], [119, 119, 167, 167, 198], [200, 200, 246, 246, 273], [276, 276, 333, 333, 905]], "test": "untested"}
{"id": "NtlSz8", "name": "Julia set zoom", "author": "Swiiz", "description": "A smooth zoom into (configurable) julia set.", "tags": ["fractal", "julia", "zoom", "juliaset"], "likes": 0, "viewed": 221, "published": 3, "date": "1625139527", "time_retrieved": "2024-07-30T19:12:50.763479", "image_code": "const vec2 c = vec2(-.79, .15); // Complex seed \n\nconst vec4 colorPalette = -vec4(0,23,21,0);\nconst vec4 finalColor = vec4(.0);\nconst int hueModulus = 30;\n                       \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float zoom = exp(-iTime/10.0)*5.0;\n    int recursion = int(exp(iTime)) + 200, i = 0;\n    vec2 z = (fragCoord / iResolution.x - 0.5) * -zoom + -iMouse.xy/iResolution.xy;\n    for(; i <= recursion && length(z) <= 2. ; i++ ) z = vec2(z.x*z.x-z.y*z.y, 2.0*z.x*z.y) + c;\n    fragColor =  i - 1 == recursion ? finalColor : .6 + .6 * cos( 6.3 *  (float((i - 1) % hueModulus) / float(hueModulus)) + colorPalette);\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtlSz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "Nl2GWt", "name": "The whisp", "author": "xenn", "description": "same same, more dreamy, (not that) NEW!\nwith IMPROVED GIMMICK!\n\nCheck mouse! \n\nhttps://xemantic.github.io/shader-web-background/\n \nGoal: shadertoy-style shaders in regular web development\n", "tags": ["mouse", "background", "shadertoy", "feedback", "integration", "library", "web", "webdevelopment", "webdev", "javascript"], "likes": 7, "viewed": 504, "published": 3, "date": "1625135134", "time_retrieved": "2024-07-30T19:12:51.922381", "image_code": "// For some nice variations, down the bottom of Buffer C try\n// mixing different image buffers in iChannel0 and iChannel1\n\n// Fork of \"photon powder flame\" by xenn. https://shadertoy.com/view/7lSGDK\n// 2021-06-29 13:39:14\n\n        // Fork of a fork of a fork mixed with a fork or two of forks \n        // Funnily enough a few forks too forked\n        // No fork is too forky\n        // It's a fork eat fork world\n        // Fork that bridge when we get to it\n        // And let me get the Bill S. reference over with;\n        // Macfork, ahem, I mean, that scottish fork\n        // I don't care if that makes no sense, enjoy...\n// 2021-06-21 18:40:35\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float seperation = 0.001;\n    float sinWave = sin(iTime) * seperation;\n    float cosWave = cos(iTime) * seperation;\n    \n    vec2 clockwise = vec2(sinWave, cosWave);\n    vec2 anticlockwise = vec2(-sinWave, cosWave);\n    float speed = 0.50;\n    \n    vec2 offsetRed = clockwise;\n\tvec2 offsetGreen = anticlockwise;\n\tvec2 offsetBlue = vec2(1,1) * cosWave;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 red = texture(iChannel0, uv-(offsetRed*cosWave));\n    vec4 green = texture(iChannel0, uv-offsetGreen);\n    vec4 blue = texture(iChannel0, uv-offsetBlue);\n    \n    vec4 other = texture(iChannel1, uv);\n     vec4 other2 = texture(iChannel2, uv);\n\tfragColor = vec4(red.r, green.g, blue.b, 0.250) *0.5  * (other / 0.50) + other2\n    ;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// by @paulofalcao\n//\n// Fun with some feedbacks :)\n\nvec3 subImg(in vec2 fragCoord, float xs,float ys, float zs){\n    vec2 xy=fragCoord.xy/iResolution.xy;\n    xy-=0.5;\n    xy+=vec2(sin(iTime*xs)*0.1,cos(iTime*ys)*0.1);//move\n    xy*=(1.1+sin(iTime*zs)*01.1);//scale\n    xy+=0.5;\n    return texture(iChannel0,xy).xyz;\n}\n\nvec3 drawCircle(in vec2 xy){\n    float l=length(xy);\n    return ( l>.233 || l<.184 ) ? vec3(0) : vec3(sin(l*128.0)*.5+0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n   \n  fragColor = (texture(iChannel0,uv)-texture(iChannel1,uv)/1.0);\n\n}\n", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n//#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "buffer_b_code": "                                                                                                                                                                                                                                                                                        // See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .001;\nconst float iFeedbackFadeRate         = .99;\nconst float iFeedbackColorShiftZoom   = .2;\nconst float iFeedbackColorShiftImpact = .0033;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = .25;\nconst float iBlobEdgeSmoothing        = .0567;\nconst float iBlob1Radius              = .33;\nconst float iBlob1PowFactor           = 20.;\nconst float iBlob1ColorPulseSpeed     = .2;\nconst float iBlob2Radius              = .54;\nconst float iBlob2PowFactor           = 20.;\nconst float iBlob2ColorPulseSpeed     = .0234;\nconst float iBlob2ColorPulseShift     = .125;\nconst float iColorShiftOfRadius       = 1.5;\nconst float iFeedbackMouseShiftFactor = .003;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.bg/colorShift.gr - .5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel2, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// This buffer is the feedback loop\n\n// iq noise\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*157.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\n// hue by netgrind(?)\n\nvec3 hue(vec3 color, float shift) {\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI     = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ     = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR   = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG   = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB   = vec3 (1.0, -1.107, 1.704);\n\n    // Convert to YIQ\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I      = dot (color, kRGBToI);\n    float   Q      = dot (color, kRGBToQ);\n\n    // Calculate the hue and chroma\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    // Make the user's adjustments\n    hue += shift;\n\n    // Convert back to YIQ\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    // Convert back to RGB\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n    color.r = dot (yIQ, kYIQToR);\n    color.g = dot (yIQ, kYIQToG);\n    color.b = dot (yIQ, kYIQToB);\n\n    return color;\n}\n\nfloat fractalNoise(vec2 pos) {\n\tfloat n = 0.;\n\tfloat scale = 1. / 1.5;\n\tfor (int i = 0; i < 5; i += 1) {\n\t\tn += noise(pos) * scale;\n\t\tscale *= 0.5;\n\t\tpos *= 2.;\n\t}\n\treturn n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Convert the uv's to polar coordinates to scale up  \n    vec2 polarUv = (uv * 2.0 - 1.0);\n    float angle = atan(polarUv.y, polarUv.x);\n    \n    // Scale up the length of the vector by a noise function feeded by the angle and length of the vector\n    float ll = length(polarUv)*0.5 - fractalNoise(vec2(sin(angle*4. + iTime*2.) + length(uv)*10., length(uv)*20. + sin(angle*4.)))*0.005 ;\n    \n    vec3 base = texture(iChannel0, uv).rgb;\n    \n    // Convert the scaled coordinates back to cartesian\n    vec2 offs = vec2(cos(angle)*ll + 0.5, sin(angle)*ll + 0.5);\n    \n    // sample the last texture with uv's slightly scaled up\n    vec3 overlay = texture(iChannel1, offs.xy).rgb;\n    \n    // Since the colors of the iChannel0 are monochrome, set a color channel to zero to do a hue shift\n    base.b = 0.;\n    \n    // Apply a hue shift to the overlaid image so it cascades in the feedback loop\n    overlay = hue(overlay, .3);\n    \n    // Additively blend the colors together\n    vec4 col = vec4(clamp(vec3(0.),vec3(1.),base + overlay*0.86), 1.0);\n    \n    fragColor = col;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "/*\n\tFull Scene Radial Blur\n\t----------------------\n\n\tRadial blur - as a postprocessing effect - is one of the first things I considered doing \n\twhen the multipass system came out. I've always loved this effect. Reminds me of the early \n\tdemos from Aardbei et al. \n\n\tAnyway, Shadertoy user, Passion, did a really cool radial blur on a field of spheres that\n\tinspired me to do my own. Radial blurs are pretty straight forward, but it was still\n    helpful to have Passion's version as a guide. \n\n    As for the radial blur process, there's not much to it. Start off at the pixel position, \n    then radiate outwards gathering up pixels with decreased weighting. The result is a\n\tblurring of the image in a radial fashion, strangely enough. :)\n\n\tInspired by:\n\n\tBlue Dream - Passion\n\thttps://www.shadertoy.com/view/MdG3RD\n\n\tRadial Blur - IQ\n\thttps://www.shadertoy.com/view/4sfGRn\n\n\tRays of Blinding Light - mu6k\n\thttps://www.shadertoy.com/view/lsf3Dn\n\n*/\n\n// The radial blur section. Shadertoy user, Passion, did a good enough job, so I've used a\n// slightly trimmed down version of that. By the way, there are accumulative weighting \n// methods that do a slightly better job, but this method is good enough for this example.\n\n\n// Radial blur samples. More is always better, but there's frame rate to consider.\nconst float SAMPLES = 64.; \n\n\n// 2x1 hash. Used to jitter the samples.\nfloat hash( vec2 p ){ return fract(sin(dot(p, vec2(41, 289)))*45758.5453); }\n\n\n// Light offset.\n//\n// I realized, after a while, that determining the correct light position doesn't help, since \n// radial blur doesn't really look right unless its focus point is within the screen boundaries, \n// whereas the light is often out of frame. Therefore, I decided to go for something that at \n// least gives the feel of following the light. In this case, I normalized the light position \n// and rotated it in unison with the camera rotation. Hacky, for sure, but who's checking? :)\nvec3 lOff(){    \n    \n    vec2 u = sin(vec2(1.57, 0) - iTime/2.);\n    mat2 a = mat2(u, -u.y, u.x);\n    \n    vec3 l = normalize(vec3(1.5, 1., -0.5));\n    l.xz = a * l.xz;\n    l.xy = a * l.xy;\n    \n    return l;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // Screen coordinates.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Radial blur factors.\n    //\n    // Falloff, as we radiate outwards.\n    float decay = 0.97; \n    // Controls the sample density, which in turn, controls the sample spread.\n    float density = 0.25; \n    // Sample weight. Decays as we radiate outwards.\n    float weight = 0.1; \n    \n    // Light offset. Kind of fake. See above.\n    vec3 l = lOff();\n    \n    // Offset texture position (uv - .5), offset again by the fake light movement.\n    // It's used to set the blur direction (a direction vector of sorts), and is used \n    // later to center the spotlight.\n    //\n    // The range is centered on zero, which allows the accumulation to spread out in\n    // all directions. Ie; It's radial.\n    vec2 tuv =  uv - .5 - l.xy*.45;\n    \n    // Dividing the direction vector above by the sample number and a density factor\n    // which controls how far the blur spreads out. Higher density means a greater \n    // blur radius.\n    vec2 dTuv = tuv*density/SAMPLES;\n    \n    // Grabbing a portion of the initial texture sample. Higher numbers will make the\n    // scene a little clearer, but I'm going for a bit of abstraction.\n    vec4 col = texture(iChannel0, uv.xy)*0.5 * texture(iChannel2, uv.xy)*0.5;\n    \n    // Jittering, to get rid of banding. Vitally important when accumulating discontinuous \n    // samples, especially when only a few layers are being used.\n    uv += dTuv*(hash(uv.xy + fract(iTime))*2. - 1.);\n    \n    // The radial blur loop. Take a texture sample, move a little in the direction of\n    // the radial direction vector (dTuv) then take another, slightly less weighted,\n    // sample, add it to the total, then repeat the process until done.\n    for(float i=0.; i < SAMPLES; i++){\n    \n        uv -= dTuv;\n        col += texture(iChannel1, uv) * weight;\n        weight *= decay;\n        \n    }\n    \n    // Multiplying the final color with a spotlight centered on the focal point of the radial\n    // blur. It's a nice finishing touch... that Passion came up with. If it's a good idea,\n    // it didn't come from me. :)\n    col *= (1. - dot(tuv, tuv)*.75);\n    \n    // Smoothstepping the final color, just to bring it out a bit, then applying some \n    // loose gamma correction.\n    fragColor = sqrt(smoothstep(0., 1., col));\n    \n    // Bypassing the radial blur to show the raymarched scene on its own.\n    //fragColor = sqrt(texture(iChannel0, fragCoord.xy / iResolution.xy));\n}\n\n", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2GWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[652, 652, 709, 709, 1458]], "test": "untested"}
{"id": "7tlXzn", "name": "voxel cannon", "author": "mdb", "description": "test of an octree in the shaders for a voxel object", "tags": ["voxel", "octree", "cannon"], "likes": 15, "viewed": 465, "published": 3, "date": "1625135090", "time_retrieved": "2024-07-30T19:12:53.595907", "image_code": "/*\nThis is a text for voxel octree ray traversal\ninpired from:\nhttps://lsi2.ugr.es/curena/inves/wscg00/revelles-wscg00.pdf\n\nbe aware that this is NOT good code, some things should not be used like that\n\n\nthe main limitation that is slowing down the render is the data stored in buffers.\n\nby using custom textures with the data i could use a way more detail voxel model \nbut without custom textures, shaders limit the number of variables to 4096\nso i could not store more data.\nby the way if some one know how to pass custom textures in shadertoy like this\nshader 'https://www.shadertoy.com/view/lsGGDd' but with RGBA float32 textures ?\nI have my idea on how i could bypass this problem, so i will probably try it later,\nwith more complex voxels!\n\nthe tree is stored as:\nNode:\n    8 uint for each child\n    \n    and for each uint (32 bit)\n        24 bit -> child index\n        6 bit -> material index\n        1 bit -> is the leaf empty\n        1 bit -> is the node a leaf\n\nif you want to see the octree, you can uncomment line 34\n\n*/\n\n\n//#define showTree\n\n#define maxDepth 10\n\nint actualDepth = 0;\nuint nodeIdx[maxDepth];\nuint childIdx[maxDepth];\nvec3 t0s[maxDepth];\nvec3 t1s[maxDepth];\nvec3 treeUp = vec3(2.0);\nvec3 treeDown = vec3(-2.0);\n\nstruct Mat{float Ns; vec3 Kd, Ks, Ke; int id;};\nconst Mat materials[4] = Mat[](\n    Mat(80.740713, 1.6*vec3(0.056215, 0.045614, 0.076713), vec3(0.585106, 0.585106, 0.585106), vec3(0.000000, 0.000000, 0.000000), 0),\n    Mat( 20.918504, vec3(0.305978, 0.096844, 0.049981), 0.2*vec3(0.574468, 0.574468, 0.574468), vec3(0.000000, 0.000000, 0.000000), 1),\n    Mat( 20.918504, vec3(0.452223, 0.171584, 0.080988), 0.2*vec3(0.574468, 0.574468, 0.574468), vec3(0.000000, 0.000000, 0.000000), 2),\n    Mat( 20.995129, vec3(0.557894, 0.199709, 0.071449), 0.2*vec3(0.627660, 0.627660, 0.627660), vec3(0.000000, 0.000000, 0.000000), 3)\n);\n\nvec3 normal;\nMat material;\nvec3 col = vec3(0.0);\n\n#define vec4ToUint (uint(data.x) + (uint(data.y)<<8) + (uint(data.z)<<16) + (uint(data.w)<<24))\nuint treeTex(uint idx){\n    vec4 data;\n    ivec2 co;\n    if(idx < 3818u){\n        data = texelFetch(iChannel0, ivec2(idx % 64u, idx / 64u), 0);\n        return vec4ToUint;\n    }\n    idx -= 3818u;\n    if(idx < 3818u){\n        data = texelFetch(iChannel1, ivec2(idx % 64u, idx / 64u), 0);\n        return vec4ToUint;\n    }\n    idx -= 3818u;\n    if(idx < 3818u){\n        data = texelFetch(iChannel2, ivec2(idx % 64u, idx / 64u), 0);\n        return vec4ToUint;\n    }\n    idx -= 3818u;\n    if(idx < 3818u){\n        data = texelFetch(iChannel3, ivec2(idx % 64u, idx / 64u), 0);\n        return vec4ToUint;\n    }\n    return 0u;\n}\n\nfloat rand(vec3 p){\n    uint idx = uint(p.x) + uint(p.y)*64u + uint(p.z)*64u*64u;\n    idx ^= 3646844786u;\n    idx *= 474746u;\n    idx >>= 16;\n    idx *= 563563u;\n    idx >> 13;\n    idx *= 454749u;\n    return float(idx)/4294967295.0;\n}\n\n//tree traversal stuff\n\nuint a;\nuint find_firstNode(vec3 t0, vec3 tM){\n    uint first = 0u;\n    if(t0.x > t0.y && t0.x > t0.z){ // entry YZ\n        if(tM.y < t0.x) first |= 2u;\n        if(tM.z < t0.x) first |= 1u;\n    }else if(t0.y > t0.z){ // entry XZ\n        if(tM.x < t0.y) first |= 4u;\n        if(tM.z < t0.y) first |= 1u;\n    }else{  // entry XY\n        if(tM.x < t0.z) first |= 4u;\n        if(tM.y < t0.z) first |= 2u; \n    }\n    return first;\n}\n\nuint next_Node(vec3 t1, uint yz, uint xz,uint xy){\n    if(t1.x < t1.y && t1.x < t1.z){\n        return yz;\n    }else if(t1.y < t1.z){\n        return xz;\n    }else{\n        return xy;\n    }\n}\n\nfloat procTree( vec3 t0, vec3 t1, bool shadow)\n{   \n    actualDepth = 0;\n    t0s[actualDepth] = t0;\n    t1s[actualDepth] = t1;\n    const int END = 8;\n    \n    vec3 tM = 0.5 * (t0 + t1);\n    childIdx[actualDepth] = find_firstNode(t0, tM);\n    nodeIdx[actualDepth] = 0u;\n    nodeIdx[actualDepth + 1] = treeTex(nodeIdx[actualDepth] + a ^ childIdx[actualDepth]);\n    //nodeIdx[actualDepth + 1] = tree[nodeIdx[actualDepth] + a ^ childIdx[actualDepth]];\n   \n    if (0x10u == 10u){\n    return 0.0;\n    }\n    \n    for(int i = 0; i < 130; i ++){\n        if (actualDepth < 0)return -1.0;//visited all nodes\n        \n        uint currNode =  childIdx[actualDepth];\n        \n        if(currNode == 8u){\n            actualDepth -= 1;\n            t0 = t0s[actualDepth];\n            t1 = t1s[actualDepth];\n            tM = 0.5 * (t0 + t1);\n            currNode = childIdx[actualDepth];\n            vec3 dt = t1 - t0;\n            vec3 idx = vec3(float(currNode&4u)/4.0, float(currNode&2u)/2.0, float(currNode&1u));\n            vec3 t0_ = t0 + 0.5*dt*idx;\n            vec3 t1_ = t0 + 0.5*dt*(1.0 + idx);\n            vec3 tM_ = 0.5*(t0_ + t1_);\n            \n            uvec3 next = uvec3[](uvec3( 4 , 2 , 1 ),\n                             uvec3( 5 , 3 ,END),\n                             uvec3( 6 ,END, 3 ),\n                             uvec3( 7 ,END,END),\n                             uvec3(END, 6 , 5 ),\n                             uvec3(END, 7 ,END),\n                             uvec3(END,END, 7 ),\n                             uvec3(END,END,END))[currNode];\n                             \n            childIdx[actualDepth] = next_Node(t1_, next.x, next.y, next.z);\n            //nodeIdx[actualDepth + 1] = tree[(nodeIdx[actualDepth]>>1u) + a ^ childIdx[actualDepth]];\n            nodeIdx[actualDepth + 1] = treeTex((nodeIdx[actualDepth]>>8u) + a ^ childIdx[actualDepth]);\n            continue;\n        }\n        \n        if (actualDepth == 7){col = vec3(1.0, 0.0, 0.0); return -1.0;}\n        \n       \n        //bool leaf = actualDepth == 6 || ((childIdx[actualDepth]^a) != 0u && (childIdx[actualDepth]^a) != 7u);\n        bool leaf = ((nodeIdx[actualDepth + 1] & 1u) == 1u) || actualDepth==8;\n        \n        if (leaf){\n            t0 = t0s[actualDepth];\n            t1 = t1s[actualDepth];\n            tM = 0.5 * (t0 + t1);\n            currNode = childIdx[actualDepth];\n            vec3 dt = t1 - t0;\n            vec3 idx = vec3(float(currNode&4u)/4.0, float(currNode&2u)/2.0, float(currNode&1u));\n            vec3 t0_ = t0 + 0.5*dt*idx;\n            vec3 t1_ = t0 + 0.5*dt*(1.0 + idx);\n            vec3 tM_ = 0.5*(t0_ + t1_);\n            \n            \n            uint data = nodeIdx[actualDepth + 1] >> 1u;\n            if ((data & 1u) == 1u){ //the node is full\n                t0 = t0_;\n                if (shadow) return max(max(t0.x, t0.y), t0.z);\n                data >>= 1u;\n                material = materials[data & 7u];\n                \n                if(t0.x > t0.y && t0.x > t0.z){ // entry YZ\n                    normal = vec3(1.0, 0.0, 0.0);\n                    return t0.x;\n                }else if(t0.y > t0.z){ // entry XZ\n                    normal = vec3(0.0, 1.0, 0.0);\n                    return t0.y;\n                }else{  // entry XY\n                    normal = vec3(0.0, 0.0, 1.0);\n                    return t0.z;\n                }\n            }//the node is empty\n            #ifdef showTree   \n            col -= 0.012*float(actualDepth); \n            #endif\n            \n            uvec3 next = uvec3[](uvec3( 4 , 2 , 1 ),\n                             uvec3( 5 , 3 ,END),\n                             uvec3( 6 ,END, 3 ),\n                             uvec3( 7 ,END,END),\n                             uvec3(END, 6 , 5 ),\n                             uvec3(END, 7 ,END),\n                             uvec3(END,END, 7 ),\n                             uvec3(END,END,END))[currNode];\n                             \n            childIdx[actualDepth] = next_Node(t1_, next.x, next.y, next.z);\n            //nodeIdx[actualDepth + 1] = tree[(nodeIdx[actualDepth]>>1u) + a ^ childIdx[actualDepth]];\n            nodeIdx[actualDepth + 1] = treeTex((nodeIdx[actualDepth]>>8u) + a ^ childIdx[actualDepth]);\n        \n        } else {\n            t0 = t0s[actualDepth];\n            t1 = t1s[actualDepth];\n            actualDepth += 1;\n           \n            tM = 0.5 * (t0 + t1);\n\n            vec3 dt = t1 - t0;\n            vec3 idx = vec3(float(currNode&4u)/4.0, float(currNode&2u)/2.0, float(currNode&1u));\n            vec3 t0_ = t0 + 0.5*dt*idx;\n            vec3 t1_ = t0 + 0.5*dt*(1.0 + idx);\n            vec3 tM_ = 0.5*(t0_ + t1_);\n            childIdx[actualDepth] = find_firstNode(t0_, tM_);\n            //nodeIdx[actualDepth + 1] = tree[(nodeIdx[actualDepth]>>1u) + a ^ childIdx[actualDepth]];\n            nodeIdx[actualDepth + 1] = treeTex((nodeIdx[actualDepth]>>8u) + a ^ childIdx[actualDepth]);\n            t0s[actualDepth] = t0_;\n            t1s[actualDepth] = t1_;\n        }\n        \n    }\n    return -1.0;\n}\n\n\n\nfloat ray_step(vec3 ro, vec3 rd, bool shadow){\n    a = 0u;\n    vec3 size = (treeUp + treeDown)*0.5;\n    ro.z = size.z - ro.z;\n    rd.z = -(rd.z);\n    \n    if (rd.x < 0.0){\n        ro.x = size.x - ro.x;\n        rd.x = -rd.x;\n        a |= 4u;\n    }\n    if (rd.y < 0.0){\n        ro.y = size.y - ro.y;\n        rd.y = -rd.y;\n        a |= 2u;\n    }\n    if (rd.z < 0.0){\n        ro.z = size.z - ro.z;\n        rd.z = -(rd.z);\n        a |= 1u;\n    }\n    \n    vec3 invDir = 1.0/rd;\n    vec3 t0 = (treeDown - ro) * invDir;\n    vec3 t1 = (treeUp - ro) * invDir;\n\n    float tmin = max(max(t0.x, t0.y), t0.z);\n    float tmax = min(min(t1.x, t1.y), t1.z);\n    if ((tmin < tmax) && (tmax > 0.0f)){\n        return procTree(t0, t1, shadow);\n    }else{ //doesn't intersect\n        return -1.0;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy*2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 camPos = vec3(-3.0*cos(iTime), 0.5 + 0.4*sin(iTime*0.7), -3.0*sin(iTime))*0.8;\n    vec3 target = vec3(0.0);\n    const vec3 lightPos = vec3(4.0, 2.0, -2.5)*10.0;\n    \n    vec3 dir0 = normalize(target - camPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(up, dir0));\n         up = cross(dir0, right);\n    \n    vec3 rd = normalize(right * uv.x + up * uv.y + dir0);\n    \n    float t = ray_step(camPos, rd, false);\n    //back ground\n    vec3 col2 = 0.5*vec3(135.0/255.0, 206.0/255.0, 235.0/255.0);\n    col2 += 0.1*(1.0 - pow(abs(rd.y)+0.01, 0.2)); \n    vec3 camLight = normalize(lightPos - camPos);\n    col2 += 0.05*(0.5 + 0.5*dot(rd, camLight));\n    col2 += 0.05*pow(0.5 + 0.5*dot(rd, camLight), 10.0);\n    \n    if (t > 0.0){\n        vec3 p = camPos + t*rd;\n        vec3 voxCoord = floor((p+2.0)*16.0 - vec3(0.00001, 0.00001, 0.00001));\n        // material texture variation\n        material.Kd *= 0.95 + 0.1*rand(voxCoord);\n        material.Kd.r *= 0.95 + 0.6*rand(abs(voxCoord - 56.0));\n        if(material.id == 0)material.Kd.b *= 0.95 + 0.3*rand(abs(voxCoord - 36.0));\n        if(material.id == 1)material.Kd *= 0.8 + 0.5*fract(sin(floor((voxCoord - 3.0)/6.0)*39.0)*45.0);\n        //lighting\n        col2 = material.Kd;\n        normal *= -sign(rd);\n        \n        const vec3 lightPos = vec3(4.0, 2.0, -2.5)*10.0;\n        vec3 lightDir = normalize(lightPos - p);\n        //ambiant\n        float AO = 0.9;\n        AO *= 0.3 + 0.7*smoothstep(0.0, 0.7, max(max(abs(p.x*0.8), max(0.0, p.y)), abs(p.z)));\n        col2 = material.Kd * AO * vec3(0.2, 0.8, 0.9);\n        \n        //shadow\n        float shadow = ray_step(lightPos, - lightDir, true);\n        if (shadow > 0.0){\n            vec3 p2 = lightPos - lightDir * shadow;\n            shadow = 1.0 - 0.95*step(0.00001, dot(p-p2, p-p2));\n        }else{shadow = 1.0;};\n        \n        normal = mix(normal, 2.0*vec3(rand(abs(p)*60.0), rand(abs(p)*60.0 + 10.0), rand(abs(p)*60.0 + 20.0)) - 1.0, 0.02);\n        //diffuse\n        col2 += shadow * material.Kd * max(0.0, dot(normal, lightDir));\n        //specular\n        vec3 r = reflect(rd, normal);\n        col2 += shadow * material.Ks * pow(max(0.0,dot(r, lightDir)), material.Ns);\n        \n    }\n    uv = fragCoord/iResolution.xy;\n    \n    // color stuff\n    //col2 = pow( col2, vec3(0.4545) );\n    col2 = 1.0 - exp(-col2*3.2);\n    col2 = clamp(col2, 0.0, 1.0);\n    col2 = col2*col2*(3.0-2.0*col2);\n    \n    col2 *= vec3(1.2, 1.2, 1.0);\n    \n    col2 *= 0.6 + 0.4*pow(16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.4 );\n    fragColor = vec4(col + col2,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n        if (fragCoord.x >= 64.0)return;\n        if(iFrame > 2){\n            fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n            return;\n        }\n        uint idx = uint(fragCoord.x) + 64u*uint(fragCoord.y); \n        \n        \n        if(0u <= idx && idx < 3818u){\n\n\nconst uint tree[3818] = uint[](\n          2048u,    667648u,   1323008u,   1613824u,   1902592u,   2510848u,   3069952u,   3487744u,     65537u,     65537u,      4096u,     18432u,\n         65537u,     65537u,    165888u,    196608u,     65537u,     65537u,     65537u,     65537u,     65537u,      6144u,     65537u,     65537u,\n         65537u,     65537u,     65537u,      8192u,     65537u,     65537u,     65537u,     12288u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65537u,     65537u,     10240u,     65537u,     65543u,     65537u,     65543u,     65537u,     65543u,     65537u,     65543u,\n         65537u,     65537u,     65537u,     14336u,     65537u,     65537u,     65537u,     16384u,     65537u,     65543u,     65537u,     65543u,\n         65537u,     65543u,     65537u,     65543u,     65537u,     65543u,     65537u,     65543u,     65537u,     65543u,     65537u,     65543u,\n         65537u,     65537u,     65537u,     65537u,     20480u,     55296u,     90112u,    104448u,     65537u,     65537u,     22528u,     28672u,\n         65537u,     65537u,     34816u,     45056u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     24576u,     26624u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     30720u,     32768u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65537u,     65537u,     36864u,     38912u,     65537u,     65537u,     40960u,     43008u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,     47104u,     49152u,\n         65537u,     65537u,     51200u,     53248u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65537u,     65537u,     57344u,     63488u,     65537u,     65537u,     69632u,     79872u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65537u,     59392u,     61440u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65537u,     65536u,     67584u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,     71680u,     73728u,\n         65537u,     65537u,     75776u,     77824u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65537u,     65537u,     81920u,     83968u,     65537u,     65537u,     86016u,     88064u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65537u,     65537u,     65537u,     65537u,     65537u,     92160u,     65537u,     98304u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     94208u,     65537u,     96256u,     65537u,     65537u,     65537u,     65537u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65537u,     65537u,     65537u,     65537u,     65537u,    100352u,     65537u,    102400u,     65539u,     65539u,     65537u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65537u,     65537u,     65537u,     65537u,     65539u,     65539u,     65537u,     65537u,\n         65537u,     65537u,     65537u,     65537u,    106496u,    118784u,    129024u,    147456u,     65537u,     65537u,    108544u,    110592u,\n        112640u,     65537u,    114688u,    116736u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65551u,     65539u,     65537u,     65539u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,    120832u,    122880u,\n         65537u,     65537u,    124928u,    126976u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65551u,     65537u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65539u,     65537u,     65537u,     65551u,     65551u,\n        131072u,    133120u,    135168u,    137216u,    139264u,    141312u,    143360u,    145408u,     65537u,     65537u,     65537u,     65537u,\n         65551u,     65551u,     65551u,     65551u,     65537u,     65537u,     65537u,     65537u,     65551u,     65551u,     65551u,     65551u,\n         65537u,     65537u,     65537u,     65537u,     65551u,     65551u,     65551u,     65551u,     65537u,     65537u,     65537u,     65537u,\n         65551u,     65551u,     65551u,     65551u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,\n         65551u,     65551u,     65551u,     65551u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65551u,\n         65539u,     65537u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,\n        149504u,    151552u,    153600u,    155648u,    157696u,    159744u,    161792u,    163840u,     65537u,     65537u,     65537u,     65537u,\n         65551u,     65537u,     65551u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65539u,     65537u,     65539u,\n         65537u,     65537u,     65537u,     65537u,     65551u,     65537u,     65551u,     65537u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65539u,     65537u,     65537u,     65551u,     65551u,     65551u,     65551u,     65551u,     65537u,     65551u,     65537u,\n         65551u,     65539u,     65551u,     65539u,     65537u,     65537u,     65537u,     65537u,     65551u,     65551u,     65551u,     65551u,\n         65551u,     65537u,     65551u,     65551u,     65551u,     65539u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65537u,    167936u,     65537u,     65537u,     65537u,    182272u,     65537u,     65537u,     65537u,     65537u,     65537u,    169984u,\n         65537u,     65537u,     65537u,    176128u,     65537u,     65537u,     65537u,    172032u,     65537u,     65537u,     65537u,    174080u,\n         65537u,     65543u,     65537u,     65543u,     65537u,     65543u,     65537u,     65543u,     65537u,     65543u,     65537u,     65543u,\n         65537u,     65543u,     65537u,     65543u,     65537u,     65537u,     65537u,    178176u,     65537u,     65537u,     65537u,    180224u,\n         65537u,     65543u,     65537u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65537u,     65537u,     65537u,    184320u,     65537u,     65537u,     65537u,    190464u,\n         65537u,     65537u,     65537u,    186368u,     65537u,     65537u,     65537u,    188416u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65543u,     65537u,     65543u,\n         65537u,     65537u,     65537u,    192512u,     65537u,     65537u,     65537u,    194560u,     65537u,     65543u,     65537u,     65543u,\n         65537u,     65543u,     65537u,     65543u,     65537u,     65543u,     65537u,     65543u,     65537u,     65543u,     65537u,     65537u,\n        198656u,    241664u,    284672u,    350208u,    473088u,    516096u,     65537u,    559104u,     65537u,     65537u,    200704u,    210944u,\n         65537u,     65537u,    221184u,    231424u,     65537u,     65537u,    202752u,    204800u,     65537u,     65537u,    206848u,    208896u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,    212992u,    215040u,\n         65537u,     65537u,    217088u,    219136u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65539u,     65539u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65539u,     65539u,     65543u,     65543u,     65539u,     65539u,\n         65537u,     65537u,    223232u,    225280u,     65537u,     65537u,    227328u,    229376u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65537u,     65537u,    233472u,    235520u,     65537u,     65537u,    237568u,    239616u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65539u,     65539u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,    243712u,    253952u,\n         65537u,     65537u,    264192u,    274432u,     65537u,     65537u,    245760u,    247808u,     65537u,     65537u,    249856u,    251904u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65539u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65539u,     65543u,     65543u,     65543u,     65539u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,    256000u,    258048u,\n         65537u,     65537u,    260096u,    262144u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65537u,     65537u,    266240u,    268288u,     65537u,     65537u,    270336u,    272384u,     65543u,     65543u,     65539u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65537u,     65537u,    276480u,    278528u,     65537u,     65537u,    280576u,    282624u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,    286720u,     65537u,    303104u,\n         65537u,    321536u,     65537u,    335872u,    288768u,    290816u,    292864u,    294912u,     65537u,    296960u,    299008u,    301056u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65551u,     65537u,     65551u,\n         65539u,     65539u,     65539u,     65537u,     65539u,     65551u,     65539u,     65551u,     65539u,     65539u,     65539u,     65537u,\n         65539u,     65539u,     65539u,     65537u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,\n         65539u,     65551u,     65539u,     65537u,     65539u,     65551u,     65539u,     65551u,    305152u,    307200u,    309248u,    311296u,\n        313344u,    315392u,    317440u,    319488u,     65537u,     65537u,     65537u,     65537u,     65537u,     65551u,     65537u,     65537u,\n         65539u,     65537u,     65539u,     65539u,     65539u,     65551u,     65539u,     65537u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65539u,     65537u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65537u,     65539u,     65551u,     65539u,     65551u,\n         65539u,     65551u,     65539u,     65551u,     65537u,     65539u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,\n         65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,    323584u,    325632u,    327680u,    329728u,\n         65537u,    331776u,     65537u,    333824u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65537u,\n         65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65539u,     65537u,     65537u,     65537u,     65551u,\n         65537u,     65537u,     65537u,     65539u,     65539u,     65537u,     65539u,     65551u,     65539u,     65539u,     65539u,     65537u,\n         65537u,     65537u,     65539u,     65539u,     65537u,     65537u,     65537u,     65537u,     65539u,     65539u,     65539u,     65539u,\n         65539u,     65537u,     65539u,     65539u,    337920u,    339968u,    342016u,    344064u,     65537u,    346112u,     65537u,    348160u,\n         65537u,     65551u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65539u,     65551u,     65539u,     65537u,\n         65539u,     65537u,     65539u,     65539u,     65537u,     65539u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65537u,     65537u,     65537u,     65537u,     65539u,     65539u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,\n        352256u,    366592u,    376832u,    395264u,    413696u,    428032u,    438272u,    456704u,    354304u,     65537u,    356352u,    358400u,\n        360448u,     65537u,    362496u,    364544u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65551u,     65537u,\n         65539u,     65537u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65551u,     65551u,     65551u,     65551u,     65539u,     65537u,     65551u,     65537u,     65539u,     65537u,     65551u,     65537u,\n         65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,\n         65551u,     65551u,     65551u,     65551u,     65537u,     65537u,    368640u,    370688u,     65537u,     65537u,    372736u,    374784u,\n         65537u,     65537u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,\n         65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,    378880u,    380928u,    382976u,    385024u,\n        387072u,    389120u,    391168u,    393216u,     65551u,     65537u,     65539u,     65537u,     65551u,     65551u,     65551u,     65537u,\n         65551u,     65537u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65539u,     65537u,     65539u,     65539u,\n         65539u,     65537u,     65539u,     65539u,     65551u,     65537u,     65539u,     65539u,     65551u,     65537u,     65539u,     65539u,\n         65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,\n         65551u,     65551u,     65551u,     65551u,     65539u,     65537u,     65539u,     65539u,     65551u,     65537u,     65539u,     65551u,\n         65551u,     65537u,     65539u,     65539u,     65551u,     65537u,     65551u,     65551u,    397312u,    399360u,    401408u,    403456u,\n        405504u,    407552u,    409600u,    411648u,     65551u,     65537u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,\n         65537u,     65537u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65537u,     65551u,     65551u,\n         65551u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,\n         65551u,     65551u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,    415744u,     65537u,    417792u,    419840u,\n        421888u,     65537u,    423936u,    425984u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,\n         65551u,     65537u,     65551u,     65551u,     65539u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65537u,     65537u,\n         65539u,     65537u,     65539u,     65551u,     65537u,     65537u,     65539u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,    430080u,    432128u,     65537u,     65537u,    434176u,    436224u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,    440320u,    442368u,    444416u,    446464u,\n        448512u,    450560u,    452608u,    454656u,     65551u,     65551u,     65551u,     65537u,     65551u,     65537u,     65539u,     65537u,\n         65551u,     65551u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65539u,     65537u,     65539u,     65551u,\n         65539u,     65537u,     65539u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,\n         65539u,     65537u,     65539u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,\n         65551u,     65537u,     65551u,     65537u,     65539u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,\n         65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,    458752u,    460800u,    462848u,    464896u,\n        466944u,     65537u,    468992u,    471040u,     65551u,     65551u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,\n         65551u,     65551u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65551u,     65537u,     65551u,     65551u,\n         65551u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65551u,\n         65551u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,    475136u,    485376u,     65537u,     65537u,    495616u,    505856u,     65537u,     65537u,    477184u,    479232u,\n         65537u,     65537u,    481280u,    483328u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65537u,     65537u,    487424u,    489472u,     65537u,     65537u,    491520u,    493568u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65537u,     65537u,    497664u,    499712u,     65537u,     65537u,    501760u,    503808u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,    507904u,    509952u,\n         65537u,     65537u,    512000u,    514048u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65537u,     65537u,    518144u,    528384u,     65537u,     65537u,    538624u,    548864u,     65537u,     65537u,    520192u,    522240u,\n         65537u,     65537u,    524288u,    526336u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65537u,     65537u,    530432u,    532480u,     65537u,     65537u,    534528u,    536576u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65537u,     65537u,    540672u,    542720u,     65537u,     65537u,    544768u,    546816u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,    550912u,    552960u,\n         65537u,     65537u,    555008u,    557056u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n        561152u,    571392u,    581632u,    600064u,    614400u,    624640u,    634880u,    653312u,     65537u,     65537u,    563200u,    565248u,\n         65537u,     65537u,    567296u,    569344u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65539u,     65539u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65539u,     65539u,\n         65537u,     65537u,    573440u,    575488u,     65537u,     65537u,    577536u,    579584u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65539u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65551u,     65551u,    583680u,    585728u,    587776u,    589824u,    591872u,    593920u,    595968u,    598016u,\n         65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,\n         65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,\n         65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,     65539u,     65537u,     65551u,     65537u,\n         65539u,     65539u,     65539u,     65539u,     65551u,     65537u,     65551u,     65537u,     65539u,     65539u,     65539u,     65539u,\n         65551u,     65537u,     65539u,     65551u,     65539u,     65539u,     65539u,     65539u,     65551u,     65537u,     65551u,     65551u,\n         65539u,     65539u,     65539u,     65539u,    602112u,     65537u,    604160u,    606208u,    608256u,     65537u,    610304u,    612352u,\n         65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65551u,\n         65551u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65551u,     65537u,     65551u,     65537u,     65539u,     65537u,     65539u,     65537u,     65551u,     65537u,     65551u,     65551u,\n         65539u,     65537u,     65539u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,    616448u,    618496u,     65537u,     65537u,    620544u,    622592u,     65537u,     65537u,     65537u,     65551u,\n         65537u,     65537u,     65537u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65537u,     65551u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,    626688u,    628736u,     65537u,     65537u,    630784u,    632832u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,    636928u,    638976u,    641024u,    643072u,\n        645120u,    647168u,    649216u,    651264u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,\n         65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65551u,\n         65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,\n         65539u,     65551u,     65539u,     65537u,     65539u,     65551u,     65539u,     65537u,     65551u,     65537u,     65551u,     65537u,\n         65551u,     65537u,     65551u,     65537u,     65539u,     65537u,     65539u,     65551u,     65539u,     65537u,     65551u,     65551u,\n         65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,    655360u,     65537u,    657408u,    659456u,\n        661504u,     65537u,    663552u,    665600u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,\n         65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,\n         65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,    669696u,    817152u,     65537u,     65537u,    825344u,   1296384u,\n         65537u,     65537u,     65537u,     65537u,    671744u,    706560u,    741376u,    802816u,     65537u,     65537u,    673792u,    679936u,\n         65537u,     65537u,    686080u,    696320u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,    675840u,    677888u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,    681984u,    684032u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65537u,     65537u,    688128u,    690176u,     65537u,     65537u,    692224u,    694272u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,    698368u,    700416u,\n         65537u,     65537u,    702464u,    704512u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65537u,     65537u,    708608u,    714752u,     65537u,     65537u,    720896u,    731136u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65537u,    710656u,    712704u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65537u,    716800u,    718848u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,    722944u,    724992u,\n         65537u,     65537u,    727040u,    729088u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65537u,     65537u,    733184u,    735232u,     65537u,     65537u,    737280u,    739328u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65537u,     65537u,     65537u,     65537u,    743424u,    753664u,    765952u,    784384u,\n         65537u,     65537u,    745472u,    747520u,     65537u,     65537u,    749568u,    751616u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65551u,\n         65537u,     65537u,     65539u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,    755712u,    757760u,     65537u,    759808u,    761856u,    763904u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65537u,     65537u,     65537u,     65539u,     65537u,     65539u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65539u,     65551u,     65539u,\n         65537u,     65539u,     65551u,     65539u,    768000u,    770048u,    772096u,    774144u,    776192u,    778240u,    780288u,    782336u,\n         65537u,     65537u,     65537u,     65537u,     65539u,     65539u,     65539u,     65539u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65551u,     65537u,     65551u,     65537u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     65551u,     65537u,     65551u,     65539u,     65551u,     65539u,     65551u,\n         65537u,     65537u,     65537u,     65537u,     65551u,     65551u,     65551u,     65551u,     65537u,     65551u,     65537u,     65551u,\n         65539u,     65551u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,\n         65537u,     65551u,     65551u,     65551u,    786432u,    788480u,    790528u,    792576u,    794624u,    796672u,    798720u,    800768u,\n         65537u,     65537u,     65537u,     65537u,     65551u,     65551u,     65551u,     65551u,     65537u,     65537u,     65537u,     65537u,\n         65551u,     65551u,     65551u,     65551u,     65537u,     65537u,     65537u,     65537u,     65551u,     65551u,     65551u,     65551u,\n         65537u,     65537u,     65537u,     65537u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,\n         65537u,     65551u,     65537u,     65551u,     65537u,     65539u,     65537u,     65551u,     65537u,     65539u,     65537u,     65539u,\n         65551u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,\n         65537u,     65539u,     65551u,     65551u,     65537u,     65537u,     65537u,     65537u,    804864u,     65537u,    811008u,     65537u,\n         65537u,     65537u,     65537u,     65537u,    806912u,     65537u,    808960u,     65537u,     65537u,     65537u,     65537u,     65537u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65537u,     65537u,     65537u,     65537u,    813056u,     65537u,    815104u,     65537u,     65539u,     65539u,     65537u,     65537u,\n         65539u,     65539u,     65539u,     65539u,     65537u,     65537u,     65537u,     65537u,     65539u,     65539u,     65537u,     65537u,\n         65537u,     65537u,     65537u,     65537u,    819200u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65537u,    821248u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,    823296u,     65537u,\n         65537u,     65537u,     65537u,     65537u,     65543u,     65543u,     65537u,     65537u,    827392u,    870400u,    913408u,   1036288u,\n       1095680u,   1138688u,   1181696u,   1290240u,     65537u,     65537u,    829440u,    839680u,     65537u,     65537u,    849920u,    860160u,\n         65537u,     65537u,    831488u,    833536u,     65537u,     65537u,    835584u,    837632u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65537u,     65537u,    841728u,    843776u,     65537u,     65537u,    845824u,    847872u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65539u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65539u,     65543u,     65543u,     65543u,     65539u,     65537u,     65537u,    851968u,    854016u,\n         65537u,     65537u,    856064u,    858112u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65537u,     65537u,    862208u,    864256u,     65537u,     65537u,    866304u,    868352u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65539u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65537u,     65537u,    872448u,    882688u,     65537u,     65537u,    892928u,    903168u,\n         65537u,     65537u,    874496u,    876544u,     65537u,     65537u,    878592u,    880640u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65539u,     65539u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65539u,     65539u,     65543u,     65543u,     65539u,     65539u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65537u,     65537u,    884736u,    886784u,     65537u,     65537u,    888832u,    890880u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,    894976u,    897024u,\n         65537u,     65537u,    899072u,    901120u,     65543u,     65543u,     65539u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65537u,     65537u,    905216u,    907264u,     65537u,     65537u,    909312u,    911360u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,    915456u,    925696u,    940032u,    958464u,    976896u,    987136u,   1001472u,   1017856u,\n         65537u,     65537u,    917504u,    919552u,     65537u,     65537u,    921600u,    923648u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,\n         65551u,     65551u,     65551u,     65551u,     65537u,    927744u,    929792u,    931840u,     65537u,    933888u,    935936u,    937984u,\n         65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,\n         65537u,     65539u,     65537u,     65551u,     65537u,     65539u,     65537u,     65551u,     65551u,     65551u,     65551u,     65551u,\n         65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,\n        942080u,    944128u,    946176u,    948224u,    950272u,    952320u,    954368u,    956416u,     65537u,     65537u,     65537u,     65537u,\n         65551u,     65551u,     65537u,     65537u,     65537u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,\n         65537u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,\n         65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,\n        960512u,    962560u,    964608u,    966656u,    968704u,    970752u,    972800u,    974848u,     65537u,     65551u,     65537u,     65551u,\n         65551u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65539u,     65551u,     65551u,     65537u,     65551u,\n         65537u,     65551u,     65539u,     65539u,     65537u,     65551u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,\n         65537u,     65539u,     65539u,     65539u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,\n         65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65537u,     65551u,     65539u,     65539u,\n         65537u,     65551u,     65551u,     65551u,     65537u,     65539u,     65539u,     65539u,     65537u,     65551u,     65551u,     65539u,\n         65537u,     65537u\n);\n\n\n\n        uint data = tree[idx];\n            fragColor = vec4(float(data&255u), \n                             float((data>>8u)&255u),\n                             float((data>>16u)&255u),\n                             float((data>>24u)&255u));\n            return;\n        }\n        \n    \n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        if (fragCoord.x >= 64.0)return;\n        if(iFrame > 2){\n            fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n            return;\n        }\n        uint idx = uint(fragCoord.x) + 64u*uint(fragCoord.y); \n        \n        if(0u <= idx && idx < 3818u){\n\nconst uint tree[3818] = uint[](\n        978944u,    980992u,     65537u,     65537u,    983040u,    985088u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,\n         65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,\n         65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,\n         65551u,     65551u,     65537u,    989184u,    991232u,    993280u,     65537u,    995328u,    997376u,    999424u,     65537u,     65539u,\n         65537u,     65551u,     65537u,     65539u,     65537u,     65539u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,\n         65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65539u,     65551u,     65551u,     65537u,     65537u,\n         65537u,     65539u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,\n         65551u,     65551u,     65537u,     65539u,     65551u,     65539u,     65537u,     65537u,     65551u,     65539u,   1003520u,   1005568u,\n       1007616u,   1009664u,     65537u,   1011712u,   1013760u,   1015808u,     65551u,     65551u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65537u,\n         65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,\n         65551u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65537u,\n         65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,\n         65551u,     65551u,   1019904u,   1021952u,   1024000u,   1026048u,   1028096u,   1030144u,   1032192u,   1034240u,     65551u,     65551u,\n         65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65537u,     65539u,\n         65537u,     65539u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65539u,\n         65551u,     65539u,     65537u,     65539u,     65551u,     65539u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,\n         65537u,     65551u,     65537u,     65539u,     65537u,     65539u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,\n         65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65539u,     65551u,     65551u,     65537u,     65551u,\n         65551u,     65551u,   1038336u,     65537u,   1052672u,     65537u,   1067008u,     65537u,   1081344u,     65537u,   1040384u,     65537u,\n       1042432u,   1044480u,   1046528u,     65537u,   1048576u,   1050624u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65539u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65551u,     65539u,     65537u,     65537u,\n         65537u,     65537u,     65537u,     65537u,     65551u,     65537u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,\n         65537u,     65539u,     65551u,     65539u,     65551u,     65539u,     65551u,     65539u,     65551u,     65539u,     65551u,     65537u,\n         65551u,     65537u,     65551u,     65537u,     65551u,     65537u,   1054720u,   1056768u,   1058816u,     65537u,   1060864u,   1062912u,\n       1064960u,     65537u,     65537u,     65539u,     65539u,     65539u,     65551u,     65539u,     65537u,     65539u,     65537u,     65537u,\n         65537u,     65537u,     65551u,     65537u,     65537u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65539u,     65539u,     65551u,     65539u,     65537u,     65539u,     65551u,     65539u,     65551u,     65539u,     65551u,     65537u,\n         65537u,     65537u,     65551u,     65537u,     65551u,     65537u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,\n         65539u,     65539u,   1069056u,   1071104u,   1073152u,   1075200u,   1077248u,     65537u,   1079296u,     65537u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,\n         65537u,     65537u,     65537u,     65539u,     65551u,     65539u,     65539u,     65539u,     65537u,     65539u,     65537u,     65537u,\n         65551u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65539u,     65539u,     65537u,     65537u,\n         65537u,     65537u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,   1083392u,   1085440u,\n       1087488u,   1089536u,   1091584u,     65537u,   1093632u,     65537u,     65551u,     65539u,     65537u,     65539u,     65539u,     65539u,\n         65539u,     65539u,     65551u,     65537u,     65537u,     65537u,     65537u,     65537u,     65539u,     65537u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65537u,     65539u,     65539u,     65539u,     65539u,     65537u,     65537u,     65537u,     65537u,     65539u,     65539u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,   1097728u,   1107968u,     65537u,     65537u,\n       1118208u,   1128448u,     65537u,     65537u,   1099776u,   1101824u,     65537u,     65537u,   1103872u,   1105920u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,   1110016u,   1112064u,     65537u,     65537u,\n       1114112u,   1116160u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,\n       1120256u,   1122304u,     65537u,     65537u,   1124352u,   1126400u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65537u,     65537u,   1130496u,   1132544u,     65537u,     65537u,   1134592u,   1136640u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,   1140736u,   1150976u,     65537u,     65537u,\n       1161216u,   1171456u,     65537u,     65537u,   1142784u,   1144832u,     65537u,     65537u,   1146880u,   1148928u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,   1153024u,   1155072u,     65537u,     65537u,\n       1157120u,   1159168u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,\n       1163264u,   1165312u,     65537u,     65537u,   1167360u,   1169408u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65537u,     65537u,   1173504u,   1175552u,     65537u,     65537u,   1177600u,   1179648u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,   1183744u,   1193984u,   1204224u,   1218560u,   1236992u,   1247232u,\n       1257472u,   1271808u,     65537u,     65537u,   1185792u,   1187840u,     65537u,     65537u,   1189888u,   1191936u,     65537u,     65537u,\n         65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,\n         65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,\n         65551u,     65551u,     65537u,     65537u,     65551u,     65539u,     65537u,     65537u,   1196032u,   1198080u,     65537u,     65537u,\n       1200128u,   1202176u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,\n         65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,\n         65539u,     65539u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65539u,     65539u,     65537u,   1206272u,\n       1208320u,   1210368u,     65537u,   1212416u,   1214464u,   1216512u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,\n         65537u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65551u,\n         65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65539u,\n         65537u,     65539u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65551u,\n         65551u,     65551u,     65537u,     65539u,     65551u,     65539u,   1220608u,   1222656u,   1224704u,   1226752u,   1228800u,   1230848u,\n       1232896u,   1234944u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,\n         65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,\n         65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,\n         65537u,     65551u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65537u,     65551u,     65539u,     65539u,\n         65539u,     65539u,     65537u,     65551u,     65551u,     65551u,     65539u,     65539u,     65539u,     65539u,     65537u,     65551u,\n         65551u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65537u,   1239040u,   1241088u,     65537u,     65537u,\n       1243136u,   1245184u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,\n         65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,\n         65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,\n       1249280u,   1251328u,     65537u,     65537u,   1253376u,   1255424u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,\n         65551u,     65551u,     65537u,     65537u,     65551u,     65537u,     65537u,     65537u,     65551u,     65537u,     65537u,     65537u,\n         65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65537u,     65537u,     65537u,\n         65537u,     65537u,     65537u,   1259520u,   1261568u,   1263616u,     65537u,   1265664u,   1267712u,   1269760u,     65537u,     65551u,\n         65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,\n         65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,\n         65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,\n         65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,   1273856u,   1275904u,\n       1277952u,   1280000u,   1282048u,   1284096u,   1286144u,   1288192u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,\n         65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65537u,     65551u,\n         65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,\n         65551u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65551u,     65539u,\n         65537u,     65539u,     65551u,     65539u,     65537u,     65539u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,\n         65551u,     65551u,     65537u,     65539u,     65551u,     65539u,     65537u,     65539u,     65551u,     65551u,     65537u,     65537u,\n         65537u,     65537u,     65537u,     65537u,   1292288u,     65537u,     65537u,     65537u,     65537u,     65537u,   1294336u,     65537u,\n         65537u,     65537u,     65537u,     65537u,     65539u,     65539u,     65537u,     65537u,     65539u,     65539u,   1298432u,     65537u,\n         65537u,     65537u,   1310720u,     65537u,     65537u,     65537u,     65537u,     65537u,   1300480u,     65537u,     65537u,     65537u,\n       1306624u,     65537u,     65537u,     65537u,   1302528u,     65537u,     65537u,     65537u,   1304576u,     65537u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65537u,     65537u,   1308672u,     65537u,     65537u,     65537u,     65537u,     65537u,     65543u,     65543u,\n         65543u,     65543u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,   1312768u,     65537u,     65537u,     65537u,\n       1316864u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,   1314816u,     65537u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,   1318912u,     65537u,     65537u,     65537u,\n       1320960u,     65537u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,   1325056u,     65537u,     65537u,     65537u,   1339392u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,   1327104u,     65537u,     65537u,     65537u,   1329152u,\n         65537u,     65537u,     65537u,   1333248u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,   1331200u,\n         65537u,     65537u,     65537u,     65543u,     65537u,     65543u,     65537u,     65543u,     65537u,     65543u,     65537u,   1335296u,\n         65537u,     65537u,     65537u,   1337344u,     65537u,     65537u,     65537u,     65543u,     65537u,     65543u,     65537u,     65543u,\n         65537u,     65543u,     65537u,     65543u,     65537u,     65543u,     65537u,     65543u,     65537u,     65543u,   1341440u,   1347584u,\n         65537u,   1419264u,     65537u,   1449984u,     65537u,   1576960u,     65537u,   1343488u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,   1345536u,     65537u,     65537u,     65539u,     65537u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     65537u,   1349632u,   1359872u,     65537u,   1370112u,   1384448u,   1390592u,\n         65537u,   1402880u,   1351680u,   1353728u,     65537u,     65537u,   1355776u,   1357824u,     65537u,     65537u,     65537u,     65539u,\n         65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,\n         65539u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65539u,     65539u,\n         65539u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,   1361920u,     65537u,   1363968u,     65537u,   1366016u,\n         65537u,   1368064u,     65551u,     65543u,     65551u,     65543u,     65551u,     65537u,     65551u,     65537u,     65551u,     65551u,\n         65551u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,\n         65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65537u,   1372160u,\n         65537u,   1374208u,   1376256u,   1378304u,   1380352u,   1382400u,     65537u,     65537u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     65539u,     65551u,     65551u,     65537u,     65537u,     65539u,     65539u,\n         65539u,     65539u,     65537u,     65537u,     65537u,     65537u,     65537u,     65539u,     65537u,     65539u,     65537u,     65537u,\n         65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65537u,     65537u,     65537u,   1386496u,   1388544u,\n         65537u,     65537u,     65547u,     65547u,     65537u,     65537u,     65547u,     65547u,     65547u,     65547u,     65547u,     65547u,\n         65537u,     65537u,     65547u,     65547u,     65547u,     65547u,     65537u,   1392640u,     65537u,   1394688u,   1396736u,   1398784u,\n         65537u,   1400832u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,\n         65551u,     65551u,     65551u,     65537u,     65539u,     65539u,     65547u,     65537u,     65537u,     65537u,     65547u,     65537u,\n         65547u,     65537u,     65551u,     65551u,     65551u,     65551u,     65537u,     65537u,     65537u,     65537u,     65551u,     65551u,\n         65539u,     65539u,     65537u,     65537u,     65539u,     65539u,   1404928u,   1406976u,   1409024u,     65537u,   1411072u,   1413120u,\n       1415168u,   1417216u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65539u,     65537u,     65539u,     65539u,     65537u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,\n         65539u,     65537u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,   1421312u,\n         65537u,     65537u,     65537u,   1431552u,     65537u,     65537u,     65537u,   1423360u,     65537u,     65537u,   1425408u,   1427456u,\n         65537u,   1429504u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65537u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65537u,     65539u,     65539u,\n         65539u,     65539u,     65537u,     65537u,     65537u,     65537u,     65539u,     65539u,     65537u,     65537u,   1433600u,   1435648u,\n       1437696u,   1439744u,   1441792u,   1443840u,   1445888u,   1447936u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,\n         65539u,     65539u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65539u,\n         65537u,     65537u,     65539u,     65539u,     65537u,     65537u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65537u,     65537u,     65539u,\n         65537u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,   1452032u,   1470464u,\n       1484800u,   1495040u,   1513472u,   1529856u,   1540096u,   1558528u,   1454080u,   1456128u,   1458176u,   1460224u,   1462272u,   1464320u,\n       1466368u,   1468416u,     65547u,     65547u,     65547u,     65547u,     65547u,     65547u,     65547u,     65537u,     65547u,     65547u,\n         65547u,     65547u,     65547u,     65547u,     65537u,     65537u,     65547u,     65547u,     65537u,     65537u,     65547u,     65547u,\n         65547u,     65547u,     65547u,     65547u,     65537u,     65537u,     65547u,     65547u,     65547u,     65547u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65547u,     65547u,     65539u,     65537u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,\n         65539u,     65537u,     65539u,     65539u,     65539u,     65539u,   1472512u,     65537u,   1474560u,   1476608u,   1478656u,     65537u,\n       1480704u,   1482752u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,\n         65537u,     65537u,     65547u,     65537u,     65547u,     65537u,     65537u,     65537u,     65539u,     65539u,     65537u,     65537u,\n         65539u,     65539u,     65547u,     65537u,     65547u,     65537u,     65539u,     65537u,     65539u,     65537u,     65547u,     65537u,\n         65547u,     65537u,     65539u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65539u,     65537u,     65537u,\n         65537u,     65537u,   1486848u,   1488896u,     65537u,     65537u,   1490944u,   1492992u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65537u,     65547u,     65547u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65547u,     65547u,\n         65537u,     65537u,     65539u,     65539u,     65537u,     65537u,     65539u,     65539u,     65537u,     65537u,     65539u,     65547u,\n         65537u,     65537u,     65539u,     65539u,     65537u,     65537u,   1497088u,   1499136u,   1501184u,   1503232u,   1505280u,   1507328u,\n       1509376u,   1511424u,     65537u,     65539u,     65539u,     65539u,     65547u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65537u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65539u,     65537u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65547u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65537u,     65539u,     65539u,\n         65537u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65537u,     65537u,\n         65537u,     65539u,     65537u,     65537u,     65537u,     65539u,   1515520u,   1517568u,   1519616u,     65537u,   1521664u,   1523712u,\n       1525760u,   1527808u,     65547u,     65547u,     65547u,     65537u,     65547u,     65547u,     65547u,     65537u,     65547u,     65547u,\n         65537u,     65537u,     65547u,     65547u,     65537u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,\n         65547u,     65547u,     65547u,     65547u,     65547u,     65537u,     65547u,     65547u,     65547u,     65537u,     65547u,     65547u,\n         65537u,     65537u,     65547u,     65547u,     65537u,     65537u,     65547u,     65537u,     65547u,     65547u,     65547u,     65537u,\n         65547u,     65547u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65547u,     65537u,   1531904u,     65537u,\n       1533952u,     65537u,   1536000u,     65537u,   1538048u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,\n         65547u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,\n         65547u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,\n         65547u,     65537u,   1542144u,   1544192u,   1546240u,   1548288u,   1550336u,   1552384u,   1554432u,   1556480u,     65547u,     65547u,\n         65547u,     65547u,     65547u,     65547u,     65547u,     65537u,     65547u,     65547u,     65547u,     65547u,     65547u,     65547u,\n         65537u,     65537u,     65547u,     65547u,     65547u,     65547u,     65547u,     65537u,     65547u,     65547u,     65547u,     65547u,\n         65547u,     65547u,     65537u,     65537u,     65547u,     65547u,     65547u,     65547u,     65547u,     65537u,     65547u,     65547u,\n         65547u,     65537u,     65547u,     65547u,     65537u,     65537u,     65547u,     65547u,     65537u,     65537u,     65547u,     65537u,\n         65547u,     65547u,     65547u,     65537u,     65547u,     65547u,     65537u,     65537u,     65547u,     65547u,     65537u,     65537u,\n         65539u,     65539u,   1560576u,   1562624u,   1564672u,   1566720u,   1568768u,   1570816u,   1572864u,   1574912u,     65547u,     65539u,\n         65547u,     65539u,     65547u,     65537u,     65547u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,\n         65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65537u,     65537u,\n         65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65547u,     65537u,     65547u,     65539u,     65547u,     65537u,\n         65547u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,\n         65539u,     65537u,     65539u,     65539u,     65539u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,\n         65537u,     65539u,     65537u,   1579008u,     65537u,     65537u,   1593344u,   1599488u,     65537u,     65537u,   1581056u,     65537u,\n       1583104u,   1585152u,   1587200u,     65537u,   1589248u,   1591296u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65539u,     65539u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65539u,     65539u,\n         65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,\n         65537u,     65539u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65539u,     65539u,\n         65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65537u,     65537u,     65537u,     65537u,   1595392u,   1597440u,\n         65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65539u,     65539u,\n         65537u,     65537u,     65539u,     65539u,     65537u,     65537u,   1601536u,     65537u,   1603584u,   1605632u,   1607680u,     65537u,\n       1609728u,   1611776u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65537u,     65539u,\n         65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,\n         65537u,     65537u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65537u,     65539u,\n         65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65539u,     65539u,     65537u,     65537u,     65539u,     65539u,\n         65537u,     65537u,   1615872u,     65537u,     65537u,     65537u,   1630208u,     65537u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65537u,   1617920u,     65537u,     65537u,     65537u,   1619968u,     65537u,     65537u,     65537u,   1624064u,     65537u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     65537u,   1622016u,     65537u,     65537u,     65537u,     65537u,     65537u,\n         65543u,     65537u,     65543u,     65537u,     65543u,     65537u,   1626112u,     65537u,     65537u,     65537u,   1628160u,     65537u,\n         65537u,     65537u,     65543u,     65537u,     65543u,     65537u,     65543u,     65537u,     65543u,     65537u,     65543u,     65537u,\n         65543u,     65537u,     65543u,     65537u,     65543u,     65537u,   1632256u,     65537u,   1703936u,     65537u,   1734656u,     65537u,\n       1861632u,     65537u,   1634304u,   1644544u,   1654784u,     65537u,   1669120u,   1681408u,   1687552u,     65537u,   1636352u,     65537u,\n       1638400u,     65537u,   1640448u,     65537u,   1642496u,     65537u,     65543u,     65551u,     65543u,     65551u,     65537u,     65551u,\n         65537u,     65551u,     65551u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,\n         65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,\n         65537u,     65551u,   1646592u,   1648640u,     65537u,     65537u,   1650688u,   1652736u,     65537u,     65537u,     65539u,     65539u,\n         65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,\n         65537u,     65537u,     65539u,     65539u,     65537u,     65539u,     65537u,     65537u,     65537u,     65537u,     65539u,     65537u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     65537u,   1656832u,     65537u,   1658880u,     65537u,   1660928u,   1662976u,\n       1665024u,   1667072u,     65537u,     65537u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65537u,     65537u,\n         65539u,     65537u,     65537u,     65537u,     65539u,     65537u,     65551u,     65551u,     65537u,     65537u,     65539u,     65551u,\n         65539u,     65539u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,\n         65539u,     65537u,     65539u,     65539u,     65539u,     65539u,     65537u,     65537u,     65537u,     65537u,     65539u,     65537u,\n         65539u,     65537u,   1671168u,     65537u,   1673216u,     65537u,   1675264u,   1677312u,   1679360u,     65537u,     65537u,     65551u,\n         65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,\n         65539u,     65551u,     65551u,     65551u,     65551u,     65551u,     65537u,     65537u,     65537u,     65537u,     65537u,     65547u,\n         65537u,     65537u,     65537u,     65547u,     65537u,     65547u,     65551u,     65551u,     65539u,     65551u,     65537u,     65537u,\n         65539u,     65537u,     65537u,     65537u,     65537u,     65537u,   1683456u,   1685504u,     65537u,     65537u,     65547u,     65547u,\n         65537u,     65537u,     65547u,     65547u,     65547u,     65547u,     65547u,     65547u,     65537u,     65537u,     65547u,     65547u,\n         65547u,     65547u,   1689600u,   1691648u,     65537u,   1693696u,   1695744u,   1697792u,   1699840u,   1701888u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65537u,     65537u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65537u,     65539u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,   1705984u,     65537u,     65537u,     65537u,   1716224u,     65537u,\n         65537u,     65537u,   1708032u,     65537u,     65537u,     65537u,   1710080u,   1712128u,   1714176u,     65537u,     65539u,     65537u,\n         65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65539u,\n         65539u,     65539u,     65537u,     65537u,     65537u,     65537u,     65539u,     65537u,     65539u,     65537u,     65537u,     65537u,\n         65537u,     65537u,     65539u,     65539u,     65537u,     65537u,   1718272u,   1720320u,   1722368u,   1724416u,   1726464u,   1728512u,\n       1730560u,   1732608u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65537u,     65539u,     65539u,\n         65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65537u,     65537u,     65537u,     65539u,     65539u,     65537u,     65537u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65537u,     65537u,     65539u,     65537u,     65537u,     65537u,   1736704u,   1751040u,   1769472u,   1787904u,   1798144u,   1808384u,\n       1824768u,   1843200u,     65537u,   1738752u,   1740800u,   1742848u,     65537u,   1744896u,   1746944u,   1748992u,     65537u,     65547u,\n         65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,\n         65539u,     65537u,     65537u,     65547u,     65537u,     65537u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,\n         65537u,     65547u,     65537u,     65539u,     65537u,     65539u,     65537u,     65537u,     65539u,     65539u,     65537u,     65537u,\n         65537u,     65537u,     65537u,     65547u,     65537u,     65547u,     65537u,     65539u,     65537u,     65539u,   1753088u,   1755136u,\n       1757184u,   1759232u,   1761280u,   1763328u,   1765376u,   1767424u,     65547u,     65547u,     65547u,     65547u,     65547u,     65547u,\n         65537u,     65537u,     65547u,     65547u,     65547u,     65547u,     65547u,     65547u,     65537u,     65547u,     65547u,     65547u,\n         65537u,     65537u,     65547u,     65547u,     65547u,     65547u,     65547u,     65547u,     65537u,     65537u,     65547u,     65547u,\n         65547u,     65547u,     65547u,     65547u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65537u,     65539u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,   1771520u,   1773568u,\n       1775616u,   1777664u,   1779712u,   1781760u,   1783808u,   1785856u,     65539u,     65539u,     65537u,     65537u,     65539u,     65539u,\n         65537u,     65537u,     65539u,     65537u,     65539u,     65539u,     65539u,     65547u,     65539u,     65539u,     65537u,     65537u,\n         65539u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65539u,     65537u,     65539u,     65539u,     65539u,\n         65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65547u,\n         65539u,     65539u,     65537u,     65539u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,\n         65539u,     65537u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,   1789952u,   1792000u,\n         65537u,     65537u,   1794048u,   1796096u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65547u,     65547u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65547u,     65547u,     65537u,     65537u,     65547u,     65539u,\n         65537u,     65537u,     65539u,     65539u,     65537u,     65537u,     65539u,     65539u,     65537u,     65537u,     65539u,     65539u,\n         65537u,     65537u,     65537u,   1800192u,     65537u,   1802240u,     65537u,   1804288u,     65537u,   1806336u,     65537u,     65547u,\n         65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,\n         65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,\n         65537u,     65547u,     65537u,     65547u,     65537u,     65547u,   1810432u,   1812480u,     65537u,   1814528u,   1816576u,   1818624u,\n       1820672u,   1822720u,     65547u,     65547u,     65537u,     65537u,     65547u,     65547u,     65537u,     65537u,     65547u,     65547u,\n         65537u,     65547u,     65547u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,\n         65547u,     65547u,     65547u,     65547u,     65537u,     65537u,     65547u,     65547u,     65537u,     65537u,     65547u,     65547u,\n         65537u,     65547u,     65547u,     65547u,     65537u,     65547u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65547u,     65537u,     65547u,     65547u,     65547u,     65537u,     65547u,     65547u,     65547u,   1826816u,   1828864u,\n       1830912u,   1832960u,   1835008u,   1837056u,   1839104u,   1841152u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,\n         65537u,     65539u,     65537u,     65547u,     65539u,     65547u,     65537u,     65547u,     65539u,     65547u,     65537u,     65537u,\n         65539u,     65537u,     65537u,     65537u,     65539u,     65537u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,\n         65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65537u,     65547u,\n         65539u,     65547u,     65537u,     65547u,     65539u,     65547u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,\n         65539u,     65537u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,   1845248u,   1847296u,\n       1849344u,   1851392u,   1853440u,   1855488u,   1857536u,   1859584u,     65547u,     65547u,     65547u,     65547u,     65547u,     65547u,\n         65537u,     65537u,     65547u,     65547u,     65547u,     65547u,     65547u,     65547u,     65537u,     65547u,     65547u,     65547u,\n         65547u,     65547u,     65537u,     65537u,     65547u,     65547u,     65547u,     65547u,     65547u,     65547u,     65537u,     65547u,\n         65547u,     65547u,     65547u,     65547u,     65537u,     65537u,     65547u,     65547u,     65537u,     65537u,     65547u,     65547u,\n         65537u,     65547u,     65547u,     65547u,     65537u,     65547u,     65537u,     65537u,     65547u,     65547u,     65537u,     65537u,\n         65539u,     65539u,     65537u,     65547u,     65547u,     65547u,     65537u,     65547u,     65547u,     65547u,   1863680u,     65537u,\n         65537u,     65537u,   1882112u,   1896448u,     65537u,     65537u,   1865728u,   1867776u,   1869824u,   1871872u,   1873920u,   1875968u,\n       1878016u,   1880064u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65539u,     65537u,     65539u,     65539u,     65537u,     65537u,     65539u,     65539u,     65537u,     65537u,     65539u,     65537u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     65537u,   1884160u,   1886208u,   1888256u,     65537u,   1890304u,   1892352u,\n       1894400u,     65537u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65539u,     65539u,\n         65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65537u,     65537u,     65539u,     65539u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65539u,     65539u,\n         65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65537u,     65537u,     65539u,     65539u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     65537u,   1898496u,   1900544u,     65537u,     65537u,     65539u,     65539u,\n         65537u,     65537u,     65539u,     65539u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,\n         65537u,     65537u,     65537u,     65537u,   1904640u,   1935360u,     65537u,     65537u,   2404352u,   2418688u,     65537u,   1906688u,\n         65537u,     65537u,     65537u,   1914880u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,\n         65537u,   1908736u,     65537u,     65537u,     65537u,   1910784u,     65537u,     65537u,     65537u,   1912832u,     65537u,     65537u,\n         65537u,     65537u,     65537u,     65543u,     65537u,     65543u,     65537u,     65543u,     65537u,     65543u,     65537u,     65543u,\n         65537u,     65543u,     65537u,     65537u,     65537u,   1916928u,     65537u,     65537u,     65537u,   1925120u,     65537u,     65537u,\n         65537u,   1918976u,     65537u,     65537u,   1921024u,   1923072u,     65537u,     65543u,     65537u,     65543u,     65537u,     65543u,\n         65537u,     65543u,     65537u,     65543u,     65537u,     65543u,     65537u,     65543u,     65537u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,   1927168u,   1929216u,     65537u,     65537u,\n       1931264u,   1933312u,     65537u,     65543u,     65537u,     65543u,     65537u,     65543u,     65537u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65543u,     65537u,     65543u,     65537u,     65543u,\n         65537u,     65537u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65543u,   1937408u,   1980416u,\n       2023424u,   2058240u,   2168832u,   2211840u,   2254848u,   2304000u,     65537u,     65537u,   1939456u,   1949696u,     65537u,     65537u,\n       1959936u,   1970176u,     65537u,     65537u,   1941504u,   1943552u,     65537u,     65537u,   1945600u,   1947648u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,   1951744u,   1953792u,     65537u,     65537u,\n       1955840u,   1957888u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u\n);\n\n        uint data = tree[idx];\n            fragColor = vec4(float(data&255u), \n                             float((data>>8u)&255u),\n                             float((data>>16u)&255u),\n                             float((data>>24u)&255u));\n            return;\n        }\n        \n    \n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    \n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        if (fragCoord.x >= 64.0)return;\n        if(iFrame > 2){\n            fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n            return;\n        }\n        uint idx = uint(fragCoord.x) + 64u*uint(fragCoord.y); \n        \n        if(0u <= idx && idx < 3818u){\n\nconst uint tree[3818] = uint[](\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,   1961984u,   1964032u,\n         65537u,     65537u,   1966080u,   1968128u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65537u,     65537u,   1972224u,   1974272u,     65537u,     65537u,   1976320u,   1978368u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65539u,     65539u,     65537u,     65537u,   1982464u,   1992704u,     65537u,     65537u,   2002944u,   2013184u,\n         65537u,     65537u,   1984512u,   1986560u,     65537u,     65537u,   1988608u,   1990656u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65537u,     65537u,   1994752u,   1996800u,     65537u,     65537u,   1998848u,   2000896u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,   2004992u,   2007040u,\n         65537u,     65537u,   2009088u,   2011136u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65539u,     65543u,\n         65543u,     65543u,     65539u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65537u,     65537u,   2015232u,   2017280u,     65537u,     65537u,   2019328u,   2021376u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65537u,     65537u,     65537u,     65537u,     65537u,   2025472u,     65537u,   2041856u,\n         65537u,   2027520u,   2029568u,   2031616u,   2033664u,   2035712u,   2037760u,   2039808u,     65537u,     65537u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65537u,     65537u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65537u,     65537u,     65539u,\n         65537u,     65537u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     65551u,     65537u,     65551u,     65539u,     65537u,     65539u,     65537u,\n         65539u,     65551u,     65539u,     65551u,   2043904u,   2045952u,     65537u,   2048000u,   2050048u,   2052096u,   2054144u,   2056192u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65539u,     65539u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65537u,     65539u,     65539u,     65539u,     65539u,\n         65537u,     65537u,     65537u,     65539u,     65537u,     65551u,     65537u,     65537u,     65539u,     65537u,     65539u,     65537u,\n         65539u,     65551u,     65539u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,   2060288u,   2066432u,   2076672u,   2095104u,\n       2109440u,   2123776u,   2134016u,   2152448u,     65537u,     65537u,     65537u,   2062336u,     65537u,     65537u,     65537u,   2064384u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,   2068480u,   2070528u,     65537u,     65537u,   2072576u,   2074624u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,   2078720u,   2080768u,   2082816u,   2084864u,\n       2086912u,   2088960u,   2091008u,   2093056u,     65539u,     65551u,     65539u,     65537u,     65539u,     65551u,     65551u,     65537u,\n         65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65539u,     65537u,     65539u,     65551u,\n         65539u,     65537u,     65539u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,\n         65551u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,\n         65551u,     65551u,     65551u,     65537u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,\n         65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,   2097152u,     65537u,   2099200u,   2101248u,\n       2103296u,     65537u,   2105344u,   2107392u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,\n         65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,\n         65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65551u,     65551u,   2111488u,     65537u,   2113536u,   2115584u,   2117632u,     65537u,   2119680u,   2121728u,\n         65537u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,\n         65539u,     65537u,     65539u,     65539u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65539u,     65539u,\n         65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65551u,     65537u,     65551u,     65537u,     65539u,     65539u,\n         65551u,     65551u,     65551u,     65551u,     65537u,     65537u,     65539u,     65539u,     65551u,     65551u,     65551u,     65551u,\n         65537u,     65537u,   2125824u,   2127872u,     65537u,     65537u,   2129920u,   2131968u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65539u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65539u,     65551u,     65551u,     65551u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65551u,     65551u,     65551u,     65551u,   2136064u,   2138112u,   2140160u,   2142208u,   2144256u,   2146304u,   2148352u,   2150400u,\n         65539u,     65551u,     65539u,     65537u,     65539u,     65539u,     65539u,     65539u,     65551u,     65551u,     65551u,     65537u,\n         65539u,     65539u,     65539u,     65539u,     65551u,     65537u,     65551u,     65551u,     65539u,     65539u,     65539u,     65539u,\n         65551u,     65537u,     65551u,     65551u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65551u,     65551u,     65551u,     65537u,     65539u,     65539u,     65539u,     65539u,     65551u,     65551u,     65551u,     65537u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65551u,     65539u,     65539u,     65539u,     65539u,\n         65551u,     65537u,     65551u,     65551u,   2154496u,     65537u,   2156544u,   2158592u,   2160640u,   2162688u,   2164736u,   2166784u,\n         65551u,     65537u,     65551u,     65537u,     65539u,     65537u,     65539u,     65537u,     65551u,     65537u,     65551u,     65551u,\n         65539u,     65537u,     65539u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65539u,     65537u,     65539u,     65537u,     65551u,     65551u,     65551u,     65537u,     65537u,     65537u,     65537u,     65537u,\n         65551u,     65551u,     65537u,     65537u,     65539u,     65537u,     65539u,     65551u,     65551u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,   2170880u,   2181120u,\n         65537u,     65537u,   2191360u,   2201600u,     65537u,     65537u,   2172928u,   2174976u,     65537u,     65537u,   2177024u,   2179072u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,   2183168u,   2185216u,\n         65537u,     65537u,   2187264u,   2189312u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65539u,     65539u,     65543u,     65543u,     65539u,     65539u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65539u,     65539u,     65543u,     65543u,     65543u,     65543u,\n         65537u,     65537u,   2193408u,   2195456u,     65537u,     65537u,   2197504u,   2199552u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65537u,     65537u,   2203648u,   2205696u,     65537u,     65537u,   2207744u,   2209792u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,   2213888u,   2224128u,\n         65537u,     65537u,   2234368u,   2244608u,     65537u,     65537u,   2215936u,   2217984u,     65537u,     65537u,   2220032u,   2222080u,\n         65543u,     65543u,     65539u,     65543u,     65543u,     65543u,     65539u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,   2226176u,   2228224u,\n         65537u,     65537u,   2230272u,   2232320u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65537u,     65537u,   2236416u,   2238464u,     65537u,     65537u,   2240512u,   2242560u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65537u,     65537u,   2246656u,   2248704u,     65537u,     65537u,   2250752u,   2252800u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,   2256896u,     65537u,   2275328u,\n         65537u,   2293760u,     65537u,   2299904u,   2258944u,   2260992u,   2263040u,   2265088u,   2267136u,   2269184u,   2271232u,   2273280u,\n         65537u,     65539u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65539u,     65539u,     65539u,     65537u,\n         65539u,     65539u,     65539u,     65537u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,\n         65539u,     65551u,     65539u,     65537u,     65539u,     65551u,     65539u,     65551u,     65537u,     65537u,     65537u,     65539u,\n         65537u,     65537u,     65537u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65539u,     65537u,     65539u,     65537u,\n         65539u,     65539u,     65539u,     65539u,   2277376u,   2279424u,   2281472u,   2283520u,   2285568u,   2287616u,   2289664u,   2291712u,\n         65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65539u,     65539u,     65551u,     65539u,     65551u,\n         65539u,     65551u,     65539u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,\n         65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65537u,     65539u,     65537u,     65539u,\n         65537u,     65539u,     65537u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65537u,     65539u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65539u,     65539u,     65539u,     65539u,\n         65539u,     65539u,     65537u,     65537u,     65537u,   2295808u,     65537u,   2297856u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65537u,     65539u,     65539u,     65539u,     65539u,\n         65537u,     65537u,     65537u,     65537u,     65537u,   2301952u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,\n         65539u,     65539u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,   2306048u,   2320384u,   2330624u,   2349056u,\n       2367488u,   2379776u,   2383872u,   2398208u,   2308096u,     65537u,   2310144u,   2312192u,   2314240u,     65537u,   2316288u,   2318336u,\n         65539u,     65537u,     65551u,     65537u,     65539u,     65537u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,\n         65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,\n         65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65551u,     65537u,\n         65539u,     65537u,     65539u,     65539u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65539u,     65539u,\n         65537u,     65537u,   2322432u,   2324480u,     65537u,     65537u,   2326528u,   2328576u,     65551u,     65551u,     65551u,     65551u,\n         65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65537u,     65537u,   2332672u,   2334720u,   2336768u,   2338816u,   2340864u,   2342912u,   2344960u,   2347008u,\n         65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65551u,\n         65551u,     65551u,     65551u,     65537u,     65551u,     65537u,     65539u,     65551u,     65551u,     65537u,     65539u,     65551u,\n         65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65551u,     65539u,     65537u,\n         65539u,     65539u,     65539u,     65539u,     65551u,     65551u,     65551u,     65551u,     65539u,     65539u,     65539u,     65539u,\n         65539u,     65537u,     65539u,     65551u,     65539u,     65537u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,\n         65537u,     65537u,     65551u,     65551u,   2351104u,   2353152u,   2355200u,   2357248u,   2359296u,   2361344u,   2363392u,   2365440u,\n         65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65551u,\n         65551u,     65551u,     65537u,     65537u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,\n         65539u,     65537u,     65539u,     65537u,     65551u,     65551u,     65551u,     65551u,     65537u,     65537u,     65537u,     65537u,\n         65551u,     65551u,     65551u,     65551u,     65551u,     65537u,     65551u,     65537u,     65551u,     65551u,     65551u,     65551u,\n         65537u,     65537u,     65537u,     65537u,   2369536u,     65537u,   2371584u,   2373632u,     65537u,     65537u,   2375680u,   2377728u,\n         65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65537u,     65537u,     65539u,     65537u,     65539u,     65539u,\n         65537u,     65537u,     65539u,     65539u,     65537u,     65537u,     65539u,     65539u,     65537u,     65537u,     65539u,     65539u,\n         65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65539u,     65537u,\n         65537u,     65537u,     65539u,     65537u,     65537u,     65537u,   2381824u,     65537u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,   2385920u,   2387968u,   2390016u,   2392064u,\n       2394112u,   2396160u,     65537u,     65537u,     65539u,     65551u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65551u,     65551u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65551u,     65537u,     65551u,     65551u,\n         65551u,     65551u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,\n         65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65539u,     65537u,     65539u,     65537u,\n         65539u,     65537u,     65539u,     65537u,   2400256u,     65537u,   2402304u,     65537u,     65537u,     65537u,     65537u,     65537u,\n         65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65551u,     65537u,     65551u,     65537u,\n         65551u,     65537u,     65551u,     65537u,     65537u,   2406400u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65537u,     65537u,   2408448u,     65537u,     65537u,     65537u,   2414592u,     65537u,     65537u,     65537u,   2410496u,\n         65537u,     65537u,     65537u,   2412544u,     65537u,     65543u,     65537u,     65543u,     65537u,     65543u,     65537u,     65543u,\n         65537u,     65543u,     65537u,     65543u,     65537u,     65543u,     65537u,     65543u,     65537u,     65537u,     65537u,   2416640u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     65543u,     65537u,     65543u,     65537u,     65543u,     65537u,     65537u,\n       2420736u,   2455552u,     65537u,   2490368u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,   2422784u,   2433024u,\n         65537u,     65537u,   2443264u,   2449408u,     65537u,     65537u,   2424832u,   2426880u,     65537u,     65537u,   2428928u,   2430976u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,   2435072u,   2437120u,\n         65537u,     65537u,   2439168u,   2441216u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65537u,     65537u,   2445312u,   2447360u,     65537u,     65537u,     65537u,     65537u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65537u,     65537u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,\n         65537u,     65537u,   2451456u,   2453504u,     65537u,     65537u,     65537u,     65537u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65537u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65537u,     65537u,   2457600u,   2467840u,     65537u,     65537u,   2478080u,   2484224u,     65537u,     65537u,   2459648u,   2461696u,\n         65537u,     65537u,   2463744u,   2465792u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65537u,     65537u,   2469888u,   2471936u,     65537u,     65537u,   2473984u,   2476032u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65537u,     65537u,   2480128u,   2482176u,     65537u,     65537u,     65537u,     65537u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65537u,     65537u,   2486272u,   2488320u,     65537u,     65537u,     65537u,     65537u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65537u,     65537u,   2492416u,     65537u,     65537u,     65537u,     65537u,     65537u,\n       2494464u,   2496512u,   2498560u,   2500608u,   2502656u,   2504704u,   2506752u,   2508800u,     65537u,     65539u,     65537u,     65539u,\n         65537u,     65539u,     65537u,     65539u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,\n         65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65539u,     65537u,     65539u,     65537u,\n         65539u,     65537u,     65539u,     65537u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65539u,     65537u,     65539u,\n         65537u,     65539u,     65537u,     65539u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,\n         65537u,     65537u,   2512896u,   2963456u,     65537u,     65537u,   2977792u,     65537u,   2514944u,   2557952u,   2598912u,   2709504u,\n       2742272u,   2785280u,   2826240u,   2926592u,     65537u,     65537u,   2516992u,   2527232u,     65537u,     65537u,   2537472u,   2547712u,\n         65537u,     65537u,   2519040u,   2521088u,     65537u,     65537u,   2523136u,   2525184u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65537u,     65537u,   2529280u,   2531328u,     65537u,     65537u,   2533376u,   2535424u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,   2539520u,   2541568u,\n         65537u,     65537u,   2543616u,   2545664u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65537u,     65537u,   2549760u,   2551808u,     65537u,     65537u,   2553856u,   2555904u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65539u,     65537u,     65537u,   2560000u,   2570240u,     65537u,     65537u,   2580480u,   2590720u,\n         65537u,     65537u,   2562048u,   2564096u,     65537u,     65537u,   2566144u,   2568192u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65537u,     65537u,   2572288u,   2574336u,     65537u,     65537u,   2576384u,   2578432u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,   2582528u,   2584576u,\n         65537u,     65537u,   2586624u,   2588672u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65539u,     65539u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65537u,     65537u,   2592768u,   2594816u,     65537u,     65537u,   2596864u,     65537u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,     65537u,     65537u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,   2600960u,   2611200u,   2617344u,   2631680u,\n       2650112u,   2660352u,   2674688u,   2691072u,     65537u,     65537u,   2603008u,   2605056u,     65537u,     65537u,   2607104u,   2609152u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,   2613248u,     65537u,\n         65537u,     65537u,   2615296u,     65537u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,   2619392u,   2621440u,   2623488u,\n         65537u,   2625536u,   2627584u,   2629632u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,\n         65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,\n         65537u,     65551u,     65551u,     65551u,   2633728u,   2635776u,   2637824u,   2639872u,   2641920u,   2643968u,   2646016u,   2648064u,\n         65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65551u,     65539u,     65537u,     65539u,\n         65551u,     65539u,     65537u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,\n         65537u,     65539u,     65551u,     65539u,     65537u,     65539u,     65551u,     65539u,     65551u,     65551u,     65537u,     65551u,\n         65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,\n         65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,\n         65537u,     65551u,     65551u,     65551u,     65537u,     65537u,   2652160u,   2654208u,     65537u,     65537u,   2656256u,   2658304u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65551u,     65539u,     65537u,     65537u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65537u,   2662400u,   2664448u,   2666496u,\n         65537u,   2668544u,   2670592u,   2672640u,     65537u,     65537u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65539u,     65539u,     65537u,     65539u,     65537u,     65539u,\n         65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65537u,     65551u,     65537u,     65551u,\n         65551u,     65551u,     65551u,     65551u,     65537u,   2676736u,   2678784u,   2680832u,   2682880u,   2684928u,   2686976u,   2689024u,\n         65537u,     65551u,     65537u,     65551u,     65537u,     65539u,     65537u,     65539u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65539u,     65551u,     65539u,\n         65537u,     65537u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65537u,     65551u,     65537u,     65551u,\n         65551u,     65551u,     65537u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,   2693120u,   2695168u,   2697216u,   2699264u,\n       2701312u,   2703360u,   2705408u,   2707456u,     65551u,     65551u,     65537u,     65551u,     65539u,     65539u,     65539u,     65539u,\n         65551u,     65539u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65551u,     65551u,     65551u,\n         65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65551u,     65551u,     65539u,     65539u,     65539u,     65539u,\n         65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65539u,     65539u,     65539u,     65539u,\n         65551u,     65551u,     65537u,     65551u,     65537u,     65539u,     65539u,     65539u,     65537u,     65551u,     65551u,     65551u,\n         65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65551u,     65539u,     65537u,     65537u,   2711552u,     65537u,\n       2715648u,     65537u,   2727936u,     65537u,   2713600u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65537u,     65539u,     65539u,     65537u,     65537u,     65537u,     65537u,   2717696u,     65537u,   2719744u,     65537u,\n       2721792u,     65537u,   2723840u,   2725888u,     65537u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65539u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65551u,     65539u,     65551u,     65539u,\n         65537u,     65537u,     65537u,     65537u,     65551u,     65537u,     65551u,     65537u,   2729984u,     65537u,   2732032u,     65537u,\n       2734080u,   2736128u,   2738176u,   2740224u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65539u,     65537u,     65537u,     65537u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65537u,     65539u,\n         65551u,     65539u,     65537u,     65539u,     65537u,     65537u,     65539u,     65537u,     65551u,     65537u,     65537u,     65537u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65537u,     65537u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     65537u,   2744320u,   2754560u,     65537u,     65537u,   2764800u,   2775040u,\n         65537u,     65537u,   2746368u,   2748416u,     65537u,     65537u,   2750464u,   2752512u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65537u,     65537u,   2756608u,   2758656u,     65537u,     65537u,   2760704u,   2762752u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65539u,\n         65543u,     65543u,     65543u,     65539u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,   2766848u,   2768896u,\n         65537u,     65537u,   2770944u,   2772992u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65537u,     65537u,   2777088u,   2779136u,     65537u,     65537u,   2781184u,   2783232u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65537u,     65537u,   2787328u,   2797568u,     65537u,     65537u,   2805760u,   2816000u,\n         65537u,     65537u,   2789376u,   2791424u,     65537u,     65537u,   2793472u,   2795520u,     65543u,     65543u,     65539u,     65539u,\n         65543u,     65543u,     65539u,     65539u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65537u,     65537u,   2799616u,     65537u,     65537u,     65537u,   2801664u,   2803712u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65537u,     65537u,   2807808u,   2809856u,     65537u,     65537u,   2811904u,   2813952u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65537u,     65537u,   2818048u,   2820096u,     65537u,     65537u,   2822144u,   2824192u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,   2828288u,   2838528u,   2852864u,   2871296u,\n       2889728u,   2893824u,   2906112u,   2912256u,     65537u,     65537u,   2830336u,   2832384u,     65537u,     65537u,   2834432u,   2836480u,\n         65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,\n         65551u,     65551u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65537u,     65539u,     65537u,   2840576u,   2842624u,   2844672u,\n         65537u,   2846720u,   2848768u,   2850816u,     65537u,     65539u,     65537u,     65551u,     65537u,     65539u,     65537u,     65551u,\n         65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65537u,     65551u,\n         65551u,     65551u,     65551u,     65551u,     65537u,     65539u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,\n         65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65539u,     65539u,     65537u,     65551u,     65537u,     65551u,\n         65537u,     65539u,     65539u,     65539u,   2854912u,   2856960u,   2859008u,   2861056u,   2863104u,   2865152u,   2867200u,   2869248u,\n         65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65551u,     65551u,\n         65551u,     65551u,     65537u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,\n         65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,\n         65537u,     65537u,     65537u,     65537u,     65551u,     65551u,     65551u,     65551u,     65537u,     65539u,     65537u,     65539u,\n         65551u,     65551u,     65551u,     65551u,     65537u,     65537u,     65537u,     65537u,     65551u,     65551u,     65551u,     65551u,\n         65537u,     65551u,     65537u,     65551u,   2873344u,   2875392u,   2877440u,   2879488u,   2881536u,   2883584u,   2885632u,   2887680u,\n         65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,\n         65551u,     65551u,     65537u,     65551u,     65537u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,\n         65537u,     65539u,     65551u,     65539u,     65537u,     65551u,     65551u,     65539u,     65551u,     65551u,     65551u,     65551u,\n         65539u,     65539u,     65539u,     65539u,     65551u,     65551u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65551u,     65551u,     65551u,     65551u,     65537u,     65537u,     65551u,     65551u,     65537u,     65539u,     65551u,     65539u,\n         65537u,     65539u,     65551u,     65551u,     65537u,     65537u,     65537u,   2891776u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,   2895872u,   2897920u,   2899968u,\n         65537u,     65537u,   2902016u,   2904064u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65537u,     65539u,     65539u,     65537u,     65537u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,\n         65537u,     65537u,     65539u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,\n         65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,   2908160u,     65537u,   2910208u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,\n         65537u,     65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65551u,   2914304u,   2916352u,   2918400u,   2920448u,\n       2922496u,   2924544u,     65537u,     65537u,     65551u,     65551u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65551u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65537u,     65551u,     65551u,\n         65551u,     65551u,     65551u,     65551u,     65537u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,     65551u,\n         65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65539u,     65537u,     65539u,     65537u,\n         65539u,     65537u,     65539u,     65537u,   2928640u,     65537u,   2940928u,     65537u,   2953216u,     65537u,   2959360u,     65537u,\n       2930688u,     65537u,   2932736u,   2934784u,   2936832u,     65537u,   2938880u,     65537u,     65539u,     65539u,     65537u,     65539u,\n         65539u,     65539u\n);\n\n        uint data = tree[idx];\n           fragColor = vec4(float(data&255u), \n                             float((data>>8u)&255u),\n                             float((data>>16u)&255u),\n                             float((data>>24u)&255u));\n            return;\n        }\n        \n    \n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    \n}", "buffer_c_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        if (fragCoord.x >= 64.0)return;\n        if(iFrame > 2){\n            fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n            return;\n        }\n        uint idx = uint(fragCoord.x) + 64u*uint(fragCoord.y); \n        \n        if(0u <= idx && idx < 3818u){\n  \nconst uint tree[3818] = uint[](\n         65537u,     65539u,     65551u,     65539u,     65537u,     65539u,     65551u,     65539u,     65551u,     65539u,     65551u,     65537u,\n         65551u,     65537u,     65551u,     65537u,     65551u,     65537u,     65539u,     65539u,     65539u,     65539u,     65537u,     65537u,\n         65539u,     65539u,     65537u,     65539u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,   2942976u,   2945024u,\n       2947072u,     65537u,   2949120u,     65537u,   2951168u,     65537u,     65551u,     65539u,     65537u,     65539u,     65551u,     65539u,\n         65537u,     65539u,     65551u,     65537u,     65537u,     65537u,     65551u,     65537u,     65537u,     65537u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65537u,   2955264u,     65537u,\n       2957312u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65539u,     65539u,     65537u,     65537u,\n         65537u,     65537u,     65539u,     65539u,     65539u,     65539u,     65537u,     65537u,     65537u,     65537u,   2961408u,     65537u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65539u,     65539u,     65539u,     65539u,     65537u,     65537u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     65537u,   2965504u,     65537u,     65537u,     65537u,     65537u,     65537u,\n       2967552u,     65537u,     65537u,     65537u,   2971648u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,\n       2969600u,     65537u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,\n       2973696u,     65537u,     65537u,     65537u,   2975744u,     65537u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,   2979840u,   3014656u,\n       3049472u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,   2981888u,   2992128u,     65537u,     65537u,\n       3002368u,   3008512u,     65537u,     65537u,   2983936u,   2985984u,     65537u,     65537u,   2988032u,   2990080u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,   2994176u,   2996224u,     65537u,     65537u,\n       2998272u,   3000320u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,\n       3004416u,   3006464u,     65537u,     65537u,     65537u,     65537u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,\n       3010560u,   3012608u,     65537u,     65537u,     65537u,     65537u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,\n         65537u,     65537u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,\n       3016704u,   3026944u,     65537u,     65537u,   3037184u,   3043328u,     65537u,     65537u,   3018752u,   3020800u,     65537u,     65537u,\n       3022848u,   3024896u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,\n       3028992u,   3031040u,     65537u,     65537u,   3033088u,   3035136u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,     65543u,\n         65543u,     65543u,     65537u,     65537u,   3039232u,   3041280u,     65537u,     65537u,     65537u,     65537u,     65543u,     65543u,\n         65543u,     65543u,     65537u,     65537u,     65537u,     65537u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,\n         65537u,     65537u,     65537u,     65537u,   3045376u,   3047424u,     65537u,     65537u,     65537u,     65537u,     65543u,     65543u,\n         65543u,     65543u,     65537u,     65537u,     65537u,     65537u,     65543u,     65543u,     65543u,     65543u,     65537u,     65537u,\n         65537u,     65537u,     65537u,     65537u,     65537u,   3051520u,     65537u,     65537u,     65537u,     65537u,   3053568u,   3055616u,\n       3057664u,   3059712u,   3061760u,   3063808u,   3065856u,   3067904u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,\n         65537u,     65539u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65537u,     65539u,\n         65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,\n         65539u,     65537u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,\n         65539u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,\n         65537u,     65539u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65537u,   3072000u,\n         65537u,     65537u,     65537u,   3356672u,     65537u,     65537u,     65537u,   3074048u,     65537u,   3203072u,   3254272u,   3260416u,\n         65537u,   3325952u,   3076096u,   3094528u,   3104768u,   3123200u,   3141632u,   3160064u,   3170304u,   3184640u,   3078144u,   3080192u,\n       3082240u,   3084288u,   3086336u,   3088384u,   3090432u,   3092480u,     65547u,     65547u,     65547u,     65537u,     65547u,     65547u,\n         65547u,     65537u,     65547u,     65547u,     65537u,     65537u,     65547u,     65547u,     65537u,     65537u,     65547u,     65537u,\n         65547u,     65547u,     65547u,     65537u,     65547u,     65547u,     65537u,     65537u,     65547u,     65537u,     65537u,     65537u,\n         65547u,     65537u,     65547u,     65547u,     65547u,     65537u,     65547u,     65547u,     65547u,     65537u,     65547u,     65547u,\n         65537u,     65537u,     65547u,     65547u,     65537u,     65537u,     65547u,     65537u,     65547u,     65547u,     65547u,     65537u,\n         65547u,     65547u,     65537u,     65537u,     65547u,     65537u,     65537u,     65537u,     65547u,     65547u,   3096576u,     65537u,\n       3098624u,     65537u,   3100672u,     65537u,   3102720u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,\n         65547u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,\n         65547u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,\n         65547u,     65537u,   3106816u,   3108864u,   3110912u,   3112960u,   3115008u,   3117056u,   3119104u,   3121152u,     65547u,     65547u,\n         65547u,     65537u,     65547u,     65547u,     65547u,     65537u,     65547u,     65547u,     65537u,     65537u,     65547u,     65547u,\n         65537u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65547u,     65547u,     65547u,     65537u,     65547u,     65547u,\n         65547u,     65537u,     65547u,     65547u,     65537u,     65537u,     65547u,     65547u,     65537u,     65537u,     65547u,     65547u,\n         65539u,     65539u,     65547u,     65537u,     65547u,     65539u,     65547u,     65547u,     65539u,     65539u,     65537u,     65537u,\n         65547u,     65547u,   3125248u,   3127296u,   3129344u,   3131392u,   3133440u,   3135488u,   3137536u,   3139584u,     65547u,     65537u,\n         65547u,     65539u,     65547u,     65537u,     65547u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,\n         65539u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65537u,\n         65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65547u,     65537u,     65547u,     65539u,     65547u,     65537u,\n         65547u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,\n         65539u,     65539u,     65547u,     65539u,     65539u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,\n         65537u,     65539u,   3143680u,   3145728u,   3147776u,   3149824u,   3151872u,   3153920u,   3155968u,   3158016u,     65547u,     65547u,\n         65547u,     65537u,     65539u,     65539u,     65539u,     65539u,     65547u,     65547u,     65537u,     65537u,     65539u,     65539u,\n         65539u,     65539u,     65547u,     65537u,     65547u,     65547u,     65539u,     65539u,     65539u,     65539u,     65537u,     65537u,\n         65547u,     65547u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65547u,     65547u,\n         65547u,     65537u,     65539u,     65539u,     65539u,     65539u,     65547u,     65547u,     65537u,     65537u,     65547u,     65537u,\n         65539u,     65547u,     65547u,     65537u,     65547u,     65547u,     65539u,     65539u,     65547u,     65539u,     65537u,     65537u,\n         65547u,     65547u,   3162112u,     65537u,   3164160u,     65537u,   3166208u,     65537u,   3168256u,     65537u,     65547u,     65537u,\n         65547u,     65537u,     65539u,     65537u,     65539u,     65537u,     65547u,     65537u,     65547u,     65537u,     65539u,     65537u,\n         65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65547u,     65537u,     65547u,     65537u,     65539u,     65537u,\n         65539u,     65537u,     65547u,     65537u,     65547u,     65537u,   3172352u,   3174400u,   3176448u,   3178496u,   3180544u,   3182592u,\n         65537u,     65537u,     65547u,     65547u,     65547u,     65537u,     65539u,     65539u,     65547u,     65547u,     65547u,     65547u,\n         65537u,     65537u,     65539u,     65539u,     65547u,     65547u,     65547u,     65537u,     65547u,     65547u,     65547u,     65547u,\n         65547u,     65547u,     65537u,     65537u,     65547u,     65547u,     65547u,     65547u,     65547u,     65547u,     65539u,     65539u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65547u,     65537u,     65537u,     65537u,     65547u,\n         65537u,     65537u,   3186688u,   3188736u,   3190784u,   3192832u,   3194880u,   3196928u,   3198976u,   3201024u,     65547u,     65537u,\n         65547u,     65539u,     65539u,     65537u,     65547u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,\n         65539u,     65537u,     65547u,     65539u,     65539u,     65539u,     65547u,     65539u,     65539u,     65539u,     65537u,     65539u,\n         65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65547u,     65539u,     65539u,     65539u,     65547u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,\n         65537u,     65539u,   3205120u,   3215360u,     65537u,     65537u,   3231744u,   3237888u,     65537u,     65537u,   3207168u,   3209216u,\n         65537u,     65537u,   3211264u,   3213312u,     65537u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65537u,     65539u,     65537u,     65539u,     65537u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65537u,     65537u,   3217408u,   3219456u,   3221504u,   3223552u,   3225600u,   3227648u,     65537u,   3229696u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,\n         65539u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65539u,     65539u,\n         65537u,     65537u,     65539u,     65539u,     65537u,     65537u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,\n         65537u,     65539u,     65537u,     65537u,     65539u,     65537u,     65537u,     65539u,     65539u,     65537u,     65539u,     65539u,\n         65537u,     65537u,     65539u,     65539u,     65537u,     65537u,   3233792u,   3235840u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65539u,     65539u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     65537u,   3239936u,   3241984u,     65537u,   3244032u,   3246080u,   3248128u,\n       3250176u,   3252224u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65537u,     65539u,\n         65539u,     65537u,     65537u,     65539u,     65539u,     65537u,     65539u,     65539u,     65537u,     65537u,     65539u,     65539u,\n         65537u,     65537u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65537u,     65539u,\n         65539u,     65537u,     65537u,     65539u,     65539u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,\n         65537u,     65537u,     65539u,     65539u,     65537u,     65537u,     65539u,     65539u,     65537u,     65537u,     65537u,   3256320u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,   3258368u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,   3262464u,   3276800u,\n       3284992u,   3289088u,     65537u,     65537u,     65537u,   3307520u,   3264512u,   3266560u,   3268608u,   3270656u,   3272704u,   3274752u,\n         65537u,     65537u,     65547u,     65547u,     65547u,     65537u,     65547u,     65547u,     65547u,     65547u,     65547u,     65547u,\n         65537u,     65537u,     65547u,     65547u,     65547u,     65547u,     65547u,     65547u,     65547u,     65547u,     65547u,     65547u,\n         65547u,     65547u,     65547u,     65547u,     65547u,     65547u,     65547u,     65547u,     65537u,     65537u,     65547u,     65547u,\n         65547u,     65547u,     65537u,     65537u,     65537u,     65537u,     65547u,     65547u,     65547u,     65547u,     65537u,     65537u,\n         65537u,     65537u,   3278848u,     65537u,   3280896u,     65537u,   3282944u,     65537u,     65537u,     65537u,     65547u,     65537u,\n         65547u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,\n         65537u,     65537u,     65547u,     65537u,     65547u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,   3287040u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65547u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65537u,   3291136u,   3293184u,   3295232u,   3297280u,   3299328u,   3301376u,   3303424u,   3305472u,     65547u,     65537u,\n         65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,\n         65539u,     65537u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,\n         65537u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,\n         65537u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65537u,     65539u,\n         65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,\n         65539u,     65539u,   3309568u,   3311616u,   3313664u,   3315712u,   3317760u,   3319808u,   3321856u,   3323904u,     65537u,     65537u,\n         65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,\n         65539u,     65537u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,\n         65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65537u,     65539u,     65539u,     65537u,     65537u,\n         65537u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,\n         65539u,     65539u,     65537u,   3328000u,     65537u,     65537u,     65537u,   3342336u,     65537u,     65537u,   3330048u,   3332096u,\n         65537u,   3334144u,   3336192u,   3338240u,     65537u,   3340288u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,\n         65537u,     65539u,     65537u,     65539u,     65539u,     65537u,     65537u,     65539u,     65539u,     65537u,     65539u,     65539u,\n         65537u,     65537u,     65539u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,\n         65537u,     65539u,     65537u,     65539u,     65539u,     65537u,     65537u,     65539u,     65539u,     65537u,     65539u,     65539u,\n         65537u,     65537u,     65539u,     65539u,     65537u,     65537u,   3344384u,   3346432u,     65537u,   3348480u,   3350528u,   3352576u,\n         65537u,   3354624u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,\n         65539u,     65537u,     65537u,     65539u,     65539u,     65537u,     65539u,     65539u,     65537u,     65537u,     65539u,     65539u,\n         65537u,     65537u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,\n         65539u,     65537u,     65537u,     65539u,     65539u,     65537u,     65539u,     65539u,     65537u,     65537u,     65539u,     65539u,\n         65537u,     65537u,     65537u,   3358720u,     65537u,   3403776u,     65537u,   3434496u,     65537u,   3463168u,   3360768u,     65537u,\n         65537u,   3366912u,     65537u,     65537u,     65537u,   3385344u,   3362816u,   3364864u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65539u,     65537u,\n         65537u,     65537u,     65539u,     65537u,     65537u,     65537u,   3368960u,   3371008u,   3373056u,   3375104u,   3377152u,   3379200u,\n       3381248u,   3383296u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,     65539u,\n         65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,\n         65537u,     65539u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65537u,\n         65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,\n         65539u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65539u,     65539u,\n         65539u,     65537u,     65539u,     65539u,     65539u,     65537u,   3387392u,   3389440u,   3391488u,   3393536u,   3395584u,   3397632u,\n       3399680u,   3401728u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,     65539u,\n         65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,\n         65537u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65537u,     65537u,\n         65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,\n         65539u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65539u,     65539u,\n         65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65537u,   3405824u,     65537u,     65537u,     65537u,   3420160u,\n         65537u,     65537u,   3407872u,   3409920u,     65537u,   3411968u,   3414016u,   3416064u,     65537u,   3418112u,     65537u,     65539u,\n         65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,\n         65539u,     65537u,     65539u,     65539u,     65537u,     65537u,     65539u,     65539u,     65537u,     65537u,     65537u,     65539u,\n         65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,\n         65539u,     65537u,     65539u,     65539u,     65537u,     65537u,     65539u,     65539u,     65537u,     65537u,   3422208u,   3424256u,\n         65537u,   3426304u,   3428352u,   3430400u,     65537u,   3432448u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,\n         65537u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65537u,     65537u,     65539u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,\n         65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,   3436544u,     65537u,     65537u,\n         65537u,   3454976u,   3438592u,   3440640u,   3442688u,   3444736u,   3446784u,   3448832u,   3450880u,   3452928u,     65537u,     65537u,\n         65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,\n         65539u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65539u,     65539u,\n         65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,\n         65537u,     65539u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,\n         65537u,     65539u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,\n         65539u,     65537u,     65537u,   3457024u,   3459072u,   3461120u,     65537u,     65537u,     65537u,     65537u,     65537u,     65539u,\n         65539u,     65539u,     65537u,     65537u,     65537u,     65537u,     65537u,     65539u,     65537u,     65539u,     65537u,     65537u,\n         65537u,     65537u,     65539u,     65539u,     65539u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,   3465216u,\n         65537u,     65537u,     65537u,   3479552u,     65537u,     65537u,   3467264u,   3469312u,     65537u,   3471360u,   3473408u,   3475456u,\n         65537u,   3477504u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65537u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,\n         65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,     65539u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65537u,     65537u,     65539u,     65539u,\n         65537u,     65537u,   3481600u,   3483648u,     65537u,   3485696u,     65537u,     65537u,     65537u,     65537u,     65537u,     65539u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65539u,     65539u,     65539u,     65539u,     65537u,     65537u,\n         65537u,     65537u,     65539u,     65539u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,   3489792u,     65537u,\n         65537u,     65537u,   3780608u,     65537u,     65537u,     65537u,   3491840u,   3620864u,   3627008u,     65537u,   3676160u,   3741696u,\n       3747840u,     65537u,   3493888u,   3504128u,   3522560u,   3540992u,   3559424u,   3569664u,   3588096u,   3606528u,     65537u,   3495936u,\n         65537u,   3497984u,     65537u,   3500032u,     65537u,   3502080u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,\n         65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,\n         65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,\n         65537u,     65547u,   3506176u,   3508224u,   3510272u,   3512320u,   3514368u,   3516416u,   3518464u,   3520512u,     65547u,     65547u,\n         65537u,     65537u,     65547u,     65547u,     65537u,     65537u,     65547u,     65547u,     65537u,     65547u,     65547u,     65547u,\n         65537u,     65547u,     65537u,     65537u,     65537u,     65547u,     65537u,     65537u,     65537u,     65547u,     65537u,     65547u,\n         65547u,     65547u,     65537u,     65547u,     65547u,     65547u,     65547u,     65547u,     65537u,     65537u,     65547u,     65547u,\n         65537u,     65537u,     65547u,     65547u,     65537u,     65547u,     65547u,     65547u,     65537u,     65547u,     65537u,     65537u,\n         65537u,     65547u,     65537u,     65537u,     65547u,     65547u,     65537u,     65547u,     65547u,     65547u,     65537u,     65547u,\n         65547u,     65547u,   3524608u,   3526656u,   3528704u,   3530752u,   3532800u,   3534848u,   3536896u,   3538944u,     65539u,     65539u,\n         65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65537u,     65547u,     65539u,     65547u,     65537u,     65547u,\n         65539u,     65547u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,\n         65537u,     65539u,     65537u,     65547u,     65539u,     65547u,     65537u,     65547u,     65539u,     65547u,     65539u,     65537u,\n         65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65547u,     65539u,     65539u,     65539u,     65547u,\n         65539u,     65539u,   3543040u,   3545088u,   3547136u,   3549184u,   3551232u,   3553280u,   3555328u,   3557376u,     65547u,     65547u,\n         65537u,     65537u,     65547u,     65547u,     65537u,     65537u,     65547u,     65547u,     65537u,     65547u,     65547u,     65547u,\n         65537u,     65547u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65547u,     65547u,     65537u,     65537u,     65547u,     65547u,\n         65537u,     65537u,     65547u,     65547u,     65537u,     65547u,     65547u,     65547u,     65537u,     65547u,     65547u,     65547u,\n         65539u,     65539u,     65537u,     65537u,     65547u,     65547u,     65547u,     65547u,     65539u,     65539u,     65537u,     65547u,\n         65539u,     65547u,     65537u,   3561472u,     65537u,   3563520u,     65537u,   3565568u,     65537u,   3567616u,     65537u,     65547u,\n         65537u,     65547u,     65537u,     65539u,     65537u,     65539u,     65537u,     65547u,     65537u,     65547u,     65537u,     65539u,\n         65537u,     65539u,     65537u,     65547u,     65537u,     65539u,     65537u,     65547u,     65537u,     65547u,     65537u,     65539u,\n         65537u,     65539u,     65537u,     65547u,     65537u,     65547u,   3571712u,   3573760u,   3575808u,   3577856u,   3579904u,   3581952u,\n       3584000u,   3586048u,     65547u,     65547u,     65537u,     65537u,     65539u,     65539u,     65539u,     65539u,     65547u,     65547u,\n         65537u,     65547u,     65539u,     65539u,     65539u,     65539u,     65537u,     65537u,     65547u,     65547u,     65539u,     65539u,\n         65539u,     65539u,     65537u,     65547u,     65547u,     65547u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65539u,     65539u,     65547u,     65547u,     65537u,     65537u,     65539u,     65539u,     65539u,     65539u,     65547u,     65547u,\n         65537u,     65547u,     65539u,     65539u,     65539u,     65539u,     65537u,     65537u,     65547u,     65547u,     65539u,     65539u,\n         65539u,     65539u,     65537u,     65547u,     65547u,     65547u,   3590144u,   3592192u,   3594240u,   3596288u,   3598336u,   3600384u,\n       3602432u,   3604480u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65537u,     65547u,\n         65539u,     65547u,     65537u,     65539u,     65539u,     65547u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,\n         65539u,     65537u,     65539u,     65547u,     65539u,     65539u,     65539u,     65547u,     65539u,     65539u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65547u,\n         65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,   3608576u,   3610624u,   3612672u,   3614720u,   3616768u,   3618816u,\n         65537u,     65537u,     65547u,     65547u,     65537u,     65537u,     65539u,     65539u,     65547u,     65547u,     65547u,     65547u,\n         65537u,     65547u,     65539u,     65539u,     65547u,     65547u,     65537u,     65537u,     65547u,     65547u,     65547u,     65547u,\n         65547u,     65547u,     65537u,     65547u,     65547u,     65547u,     65547u,     65547u,     65547u,     65547u,     65539u,     65539u,\n         65537u,     65537u,     65547u,     65537u,     65537u,     65537u,     65539u,     65539u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     65537u,   3622912u,     65537u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65537u,   3624960u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65539u,     65537u,\n         65537u,     65537u,   3629056u,   3643392u,     65537u,     65537u,   3653632u,   3670016u,     65537u,     65537u,   3631104u,   3633152u,\n       3635200u,     65537u,   3637248u,   3639296u,   3641344u,     65537u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,\n         65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65537u,     65537u,     65539u,     65539u,     65537u,     65537u,     65537u,     65537u,     65537u,     65539u,     65539u,     65537u,\n         65537u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,\n         65537u,     65537u,     65539u,     65539u,     65537u,     65537u,   3645440u,   3647488u,     65537u,     65537u,   3649536u,   3651584u,\n         65537u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65537u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65537u,     65537u,     65537u,   3655680u,   3657728u,\n       3659776u,     65537u,   3661824u,   3663872u,   3665920u,   3667968u,     65539u,     65537u,     65537u,     65539u,     65539u,     65537u,\n         65537u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65539u,\n         65537u,     65537u,     65539u,     65539u,     65537u,     65537u,     65539u,     65537u,     65537u,     65539u,     65539u,     65537u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,\n         65537u,     65537u,     65539u,     65539u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,\n         65537u,     65537u,   3672064u,   3674112u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65539u,     65539u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65537u,   3678208u,   3686400u,   3700736u,   3719168u,     65537u,     65537u,   3723264u,     65537u,     65537u,   3680256u,\n         65537u,   3682304u,     65537u,   3684352u,     65537u,     65537u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,\n         65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,     65547u,     65537u,     65537u,     65537u,     65547u,\n         65537u,     65547u,     65537u,     65537u,     65537u,     65537u,   3688448u,   3690496u,   3692544u,   3694592u,   3696640u,   3698688u,\n         65537u,     65537u,     65547u,     65547u,     65537u,     65537u,     65547u,     65547u,     65547u,     65547u,     65547u,     65539u,\n         65537u,     65547u,     65547u,     65539u,     65547u,     65547u,     65547u,     65547u,     65547u,     65547u,     65547u,     65547u,\n         65537u,     65537u,     65547u,     65547u,     65547u,     65547u,     65547u,     65547u,     65547u,     65547u,     65547u,     65547u,\n         65547u,     65547u,     65537u,     65537u,     65537u,     65537u,     65547u,     65547u,     65547u,     65547u,     65537u,     65537u,\n         65537u,     65537u,   3702784u,   3704832u,   3706880u,   3708928u,   3710976u,   3713024u,   3715072u,   3717120u,     65539u,     65539u,\n         65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65537u,     65547u,     65539u,     65537u,     65537u,     65537u,\n         65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,\n         65537u,     65539u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,     65539u,     65537u,\n         65539u,     65537u,     65539u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65539u,     65539u,   3721216u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65547u,     65537u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     65537u,   3725312u,   3727360u,   3729408u,   3731456u,   3733504u,   3735552u,\n       3737600u,   3739648u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65537u,     65537u,\n         65539u,     65537u,     65537u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,\n         65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65537u,     65537u,     65537u,\n         65539u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,   3743744u,     65537u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65537u,   3745792u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65539u,     65537u,\n         65537u,     65537u,     65539u,     65537u,     65537u,     65537u,   3749888u,     65537u,     65537u,     65537u,   3764224u,     65537u,\n         65537u,     65537u,   3751936u,   3753984u,   3756032u,     65537u,   3758080u,   3760128u,   3762176u,     65537u,     65539u,     65537u,\n         65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,\n         65539u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,\n         65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,\n         65539u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,   3766272u,   3768320u,\n       3770368u,     65537u,   3772416u,   3774464u,   3776512u,   3778560u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,\n         65539u,     65539u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,\n         65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,\n         65539u,     65539u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65539u,\n         65537u,     65537u,     65539u,     65539u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65537u,   3782656u,     65537u,   3825664u,     65537u,   3856384u,     65537u,   3887104u,     65537u,     65537u,   3784704u,\n       3790848u,     65537u,     65537u,     65537u,   3809280u,     65537u,   3786752u,   3788800u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65539u,     65537u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     65537u,   3792896u,   3794944u,   3796992u,   3799040u,   3801088u,   3803136u,\n       3805184u,   3807232u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65537u,     65537u,\n         65539u,     65537u,     65537u,     65537u,     65539u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65539u,\n         65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,\n         65539u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,\n         65539u,     65537u,     65539u,     65537u,     65539u,     65537u,   3811328u,     65537u,   3813376u,   3815424u,   3817472u,   3819520u,\n       3821568u,   3823616u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,\n         65539u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65537u,     65537u,\n         65539u,     65537u,     65537u,     65537u,     65537u,     65537u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,\n         65537u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65537u,   3827712u,     65537u,\n         65537u,     65537u,   3842048u,     65537u,     65537u,     65537u,   3829760u,   3831808u,   3833856u,     65537u,   3835904u,   3837952u,\n       3840000u,     65537u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,\n         65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,\n         65537u,     65537u,     65539u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,\n         65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,\n         65537u,     65537u,   3844096u,   3846144u,   3848192u,     65537u,   3850240u,   3852288u,   3854336u,     65537u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,\n         65539u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65539u,     65537u,\n         65539u,     65537u,     65539u,     65539u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,\n       3858432u,     65537u,     65537u,     65537u,   3876864u,     65537u,   3860480u,   3862528u,   3864576u,   3866624u,   3868672u,   3870720u,\n       3872768u,   3874816u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65537u,     65537u,\n         65539u,     65537u,     65537u,     65537u,     65539u,     65537u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,\n         65537u,     65539u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65537u,     65537u,\n         65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,\n         65539u,     65537u,     65539u,     65539u,     65537u,     65539u,     65539u,     65539u,     65537u,     65539u,     65539u,     65537u,\n         65539u,     65537u,     65539u,     65537u,     65539u,     65537u,   3878912u,   3880960u,   3883008u,   3885056u,     65537u,     65537u,\n         65537u,     65537u,     65537u,     65537u,     65539u,     65539u,     65537u,     65537u,     65537u,     65537u,     65537u,     65537u,\n         65539u,     65537u,     65537u,     65537u,     65537u,     65537u,     65539u,     65539u,     65537u,     65539u,     65537u,     65537u,\n         65537u,     65537u,     65539u,     65537u,     65539u,     65537u,     65537u,     65537u,     65537u,     65537u,   3889152u,     65537u,\n         65537u,     65537u,   3901440u,     65537u,     65537u,     65537u,   3891200u,   3893248u,     65537u,     65537u,   3895296u,   3897344u,\n       3899392u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,     65537u,\n         65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65539u,     65539u,     65539u,     65539u,     65539u,\n         65539u,     65539u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65539u,     65537u,     65537u,     65537u,\n         65537u,     65537u,     65539u,     65539u,     65537u,     65537u,   3903488u,   3905536u,   3907584u,     65537u,     65537u,     65537u,\n         65537u,     65537u,     65539u,     65539u,     65539u,     65539u,     65537u,     65537u,     65537u,     65537u,     65539u,     65537u,\n         65537u,     65537u,     65537u,     65537u,     65537u,     65537u,     65539u,     65537u,     65537u,     65537u,     65537u,     65537u,\n         65537u,     65537u\n);\n\n\n\n\n        uint data = tree[idx];\n            fragColor = vec4(float(data&255u), \n                             float((data>>8u)&255u),\n                             float((data>>16u)&255u),\n                             float((data>>24u)&255u));\n            return;\n        }\n        \n    \n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    \n}", "buffer_d_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlXzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2012, 2012, 2035, 2035, 2631], [2633, 2633, 2652, 2652, 2867], [2901, 2901, 2939, 2939, 3320], [3322, 3322, 3372, 3372, 3511], [8541, 8541, 8587, 8587, 9323], [9325, 9325, 9381, 9381, 12062]], "test": "untested"}
{"id": "slfSRH", "name": "Five Metallic Tetrahedra", "author": "dr2", "description": "Five interlocking tetrahedral frames ('Compound of Five Tetrahedra')", "tags": ["reflect", "symmetry", "polyhedron", "sculpture"], "likes": 11, "viewed": 354, "published": 3, "date": "1625128360", "time_retrieved": "2024-07-30T19:12:54.420701", "image_code": "// \"Five Metallic Tetrahedra\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// (Based on \"Ten Intersecting Tetrahedra\")\n\n#define AA  1\n\nfloat PrSphDf (vec3 p, float r);\nfloat Maxv2 (vec2 p);\nmat3 VToRMat (vec3 v, float a);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir;\nfloat tCur, dstFar;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat TetFrameDf (vec3 p, float w)\n{\n  vec3 q;\n  q = p;\n  p = abs (p);\n  q = mix (q, q.yzx, step (Maxv2 (p.yz), p.x));\n  q = mix (q, q.zxy, step (Maxv2 (p.zx), p.y));\n  q = mix (q, vec3 (q.x, - q.yz).yxz, step (q.z, 0.)) - vec3 (-1., 1., 1.) / sqrt (3.);\n  return length (vec2 (0.5 * (q.x + q.y), q.z)) - w;\n}\n\nfloat ObjDf (vec3 p)\n{\n  mat3 m;\n  vec3 q;\n  float dMin, d, a;\n  dMin = dstFar;\n  p.y -= 0.86;\n  q = p;\n  d = PrSphDf (q, 1.1);\n  if (d < 0.1) {\n    a = atan (2. / (sqrt (5.) + 1.));\n    m = VToRMat (vec3 (0., sin (a + vec2 (0.5 * pi, 0.))), 2. * pi / 5.);\n    q.yz = Rot2D (q.yz, a);\n    for (int k = 0; k < 5; k ++) {\n      d = TetFrameDf (q, 0.05);\n      dMin = min (dMin, d);\n      q = m * q;\n    }\n    dMin = max (dMin, PrSphDf (p, 1.05));\n  } else dMin = min (dMin, d);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.001 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.005, -0.005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.4, 0.5);\n  } else {\n    q = 0.01 * (ro.xz + 2. * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.3, 0.4, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstObj, dstGrnd, sh;\n  bool isBg;\n  const int nRefl = 1;\n  isBg = false;\n  dstGrnd = dstFar;\n  for (int k = VAR_ZERO; k <= nRefl; k ++) {\n    dstObj = ObjRay (ro, rd);\n    if (k < nRefl && dstObj < dstFar) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n    }\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n  } else if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n  } else {\n    isBg = true;\n    col = SkyBgCol (ro, rd);\n  }\n  if (! isBg) {\n    sh = (min (dstObj, dstGrnd) < dstFar) ? ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;\n    if (dstObj < dstFar) {\n      col = vec3 (0.4, 0.5, 0.9) * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.)) +\n         0.2 * step (0.95, sh) * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n    } else {\n      col = 0.5 * mix (vec3 (0.8, 1., 0.5), vec3 (0.7, 0.9, 0.5), 0.2 +\n         0.8 * smoothstep (0.3, 0.7, Fbm2 (4. * ro.xz)));\n      vn = VaryNf (16. * ro, vec3 (0., 1., 0.), 1. - smoothstep (0.5, 0.8, dstGrnd / dstFar));\n      col *= (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.));\n      col = mix (col, vec3 (0.3, 0.4, 0.5), pow (1. + rd.y, 16.));\n    }\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az -= 2. * pi * mPtr.x;\n    el -= pi * mPtr.y;\n  }\n  el = clamp (el, -0.45 * pi, -0.05 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -6.);\n  ro.y += 0.8;\n  zmFac = 5.;\n  dstFar = 30.;\n  sunDir = normalize (vec3 (0., 2., -1.));\n  sunDir.xz = Rot2D (sunDir.xz, 0.02 * pi * tCur);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nmat3 VToRMat (vec3 v, float a)\n{\n  mat3 m;\n  vec3 w, b1, b2, bp, bm;\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  w = (1. - cs.x) * v * v + cs.x;\n  b1 = (1. - cs.x) * v.xzy * v.yxz;\n  b2 = - cs.y * v.zyx;\n  bp = b1 + b2;\n  bm = b1 - b2;\n  m[0][0] = w.x;  m[1][1] = w.y;  m[2][2] = w.z;\n  m[0][1] = bp.x;  m[1][0] = bm.x;\n  m[2][0] = bp.y;  m[0][2] = bm.y;\n  m[1][2] = bp.z;  m[2][1] = bm.z;\n  return m;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slfSRH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[524, 524, 560, 560, 833], [835, 835, 857, 857, 1327], [1329, 1329, 1362, 1362, 1609], [1611, 1611, 1632, 1632, 1887], [1889, 1889, 1926, 1926, 2169], [2171, 2171, 2205, 2205, 2962], [2964, 2964, 2999, 2999, 4255], [4257, 4257, 4313, 4313, 5358], [5360, 5360, 5382, 5382, 5409], [5411, 5411, 5444, 5444, 5471], [5473, 5473, 5505, 5505, 5883], [5885, 5885, 5921, 5921, 6127], [6129, 6129, 6159, 6159, 6272], [6306, 6306, 6330, 6330, 6383], [6385, 6385, 6409, 6409, 6521], [6523, 6523, 6548, 6548, 6694], [6696, 6696, 6721, 6721, 6907], [6909, 6909, 6931, 6931, 7085], [7087, 7087, 7108, 7108, 7263], [7265, 7265, 7294, 7294, 7506], [7508, 7508, 7547, 7547, 7799]], "test": "untested"}
{"id": "NlBGz3", "name": "Ray Tracing One Weekend", "author": "chenglou", "description": "From [url]https://raytracing.github.io/books/RayTracingInOneWeekend[/url]. A path tracer. Ported it over almost verbatim.\nAnimated it for stress testing speed. No temporal AA hack\nMuch improved version at [url]https://www.shadertoy.com/view/7tBXDh[/url]", "tags": ["raytracing"], "likes": 7, "viewed": 506, "published": 3, "date": "1625120774", "time_retrieved": "2024-07-30T19:12:55.485853", "image_code": "//https://raytracing.github.io/books/RayTracingInOneWeekend.html\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec3 hash32(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 random_in_unit_sphere(vec2 p) {\n    float test = 0.;\n    while (test < 9999.) {\n        vec3 pt = hash32(p * 10000. + test) * 2. - 1.;\n        float len = length(pt);\n        if (len * len >= 1.) {\n            test += 1.;\n            continue;\n        }\n        return pt;\n    }\n}\n\nvec3 random_unit_vector(vec2 p) {\n    return normalize(random_in_unit_sphere(p));\n}\n\nvec3 random_in_unit_disk(vec2 p) {\n    float test = 0.;\n    while (test < 9999.) {\n        vec3 pt = vec3(hash22(p * 10000. + test) * 2. - 1., 0);\n        float len = length(pt);\n        if (len * len >= 1.) {\n            test += 1.;\n            continue;\n        }\n        return pt;\n    }\n}\n\n\nconst int material_lambertian = 0;\nconst int material_metal = 1;\nconst int material_dielectric = 2;\n\nstruct ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct material {\n    int type;\n    vec3 albedo;\n    float metal_fuzz;\n    float dielectric_index_of_refraction;\n};\n\nstruct hit_record {\n    vec3 p;\n    vec3 normal;\n    float t;\n    material material;\n};\n\nstruct sphere {\n    vec3 center;\n    float radius;\n    material material;\n};\n\nsphere[] spheres = sphere[](\n    // ground\n    sphere(vec3( 0.0, -1000., -1.0), 1000., material(material_lambertian, vec3(0.5), 0., 0.)),\n\n    sphere(vec3(-4.0,    1.0, 2.),   1.0, material(material_dielectric, vec3(0), 0., 1.5)),\n    sphere(vec3( 0.0,    1.0, 0.),   1.0, material(material_metal, vec3(0.7, 0.6, 0.5), 0., 0.)),\n    sphere(vec3( 4.0,    1.0, 2.),   1.0, material(material_lambertian, vec3(0.7, 0.3, 0.3), 0., 0.)),\n\n    // smaller balls\n    sphere(vec3(-6, 0.2, 2.8), 0.2, material(material_dielectric, vec3(0, 0, 0.2), 0., 1.5)),\n    sphere(vec3(1.6, 0.2, -0.9), 0.2, material(material_dielectric, vec3(0), 0., 1.5)),\n    sphere(vec3(-5.7, 0.2, -2.7), 0.2, material(material_lambertian, vec3(0.8, 0.3, 0.3), 0., 0.)),\n    sphere(vec3(-3.6, 0.2, -4.4), 0.2, material(material_lambertian, vec3(0.9, 0.3, 0.2), 0., 0.)),\n    sphere(vec3(0.8, 0.2, 2.3), 0.2, material(material_lambertian, vec3(0.2, 0, 0.5), 0., 0.)),\n    sphere(vec3(3.8, 0.2, 4.2), 0.2, material(material_lambertian, vec3(0.4, 0.3, 0.7), 0., 0.)),\n    sphere(vec3(-0.1, 0.2, -1.9), 0.2, material(material_lambertian, vec3(0.4, 0, 0.4), 0., 0.)),\n    sphere(vec3(-2.5, 0.2, 5.4), 0.2, material(material_metal, vec3(0.3, 0.7, 0.9), 0.3, 0.)),\n    sphere(vec3(-3.9, 0.2, -0.3), 0.2, material(material_lambertian, vec3(0.9, 0.8, 0.5), 0., 0.)),\n    sphere(vec3(-6, 0.2, 4), 0.2, material(material_lambertian, vec3(0.9, 0.9, 0.5), 0., 0.)),\n    sphere(vec3(4.4, 0.2, -0.5), 0.2, material(material_lambertian, vec3(0.5, 0.4, 0.8), 0., 0.)),\n    sphere(vec3(3.4, 0.2, 5.3), 0.2, material(material_lambertian, vec3(0.1, 0.6, 0.2), 0., 0.)),\n    sphere(vec3(4.6, 0.2, -3.8), 0.2, material(material_lambertian, vec3(0.2, 0.2, 0.2), 0., 0.)),\n    sphere(vec3(0.7, 0.2, -2.5), 0.2, material(material_metal, vec3(0, 0.2, 0.1), 0., 0.)),\n    sphere(vec3(2.4, 0.2, -4.3), 0.2, material(material_lambertian, vec3(0.8, 0.9, 0), 0., 0.)),\n    sphere(vec3(4.4, 0.2, 4.9), 0.2, material(material_lambertian, vec3(0.8, 0.8, 0), 0., 0.)),\n    sphere(vec3(-4.7, 0.2, 4.6), 0.2, material(material_lambertian, vec3(0.8, 0.8, 0.7), 0., 0.)),\n    sphere(vec3(4.2, 0.2, -3.5), 0.2, material(material_lambertian, vec3(0.8, 0.8, 0.6), 0., 0.)),\n    sphere(vec3(-5.2, 0.2, 0.5), 0.2, material(material_lambertian, vec3(0.2, 0.7, 0.9), 0., 0.)),\n    sphere(vec3(5.7, 0.2, -0.8), 0.2, material(material_lambertian, vec3(0.3, 0, 0.7), 0., 0.))\n);\n\nbool hit_sphere(sphere sph, ray r, float t_min, float t_max, out hit_record rec) {    \n    vec3 oc = r.origin - sph.center;\n    float a = dot(r.dir, r.dir);\n    float half_b = dot(oc, r.dir);\n    float c = dot(oc, oc) - sph.radius * sph.radius;\n    float discriminant = half_b * half_b - a * c;\n    if (discriminant < 0.) {\n        return false;\n    }\n    \n    float sqrtd = sqrt(discriminant);\n    \n    // Find the nearest root that lies in the acceptable range\n    float root = (-half_b - sqrtd) / a; // the t. from -b - sqrt(dis) / 2a\n    if (root < t_min || t_max < root) {\n        root = (-half_b + sqrtd) / a;\n        if (root < t_min || t_max < root) {\n            return false;\n        }\n    }\n    \n    vec3 p = r.origin + r.dir * root;\n    rec = hit_record(p, (p - sph.center) / sph.radius, root, sph.material);\n    \n    return true;\n}\n\nbool hit(ray r, float t_min, float t_max, out hit_record rec) {\n    bool hit_anything = false;\n    float closest_so_far = t_max;\n    \n    hit_record rec_;\n    for (int i = 0; i < spheres.length(); i++) {\n        if (hit_sphere(spheres[i], r, t_min, closest_so_far, rec_)) {\n            hit_anything = true;\n            closest_so_far = rec_.t;\n            rec = rec_;\n        }\n    }\n    \n    return hit_anything;\n}\n\nbool near_zero(vec3 p) {\n    float s = 1e-8;\n    return p.x < s && p.y < s && p.z < s;\n}\n\nfloat reflectance(float cosine, float ref_idx) {\n    // Use Schlick's approximation for reflectance\n    float r0 = (1. - ref_idx) / (1. + ref_idx);\n    r0 = r0 * r0;\n    return r0 + (1. - r0) * pow((1. - cosine), 5.);\n}\n\nbool scatter(hit_record rec, ray r, vec2 seed, out vec3 attenuation, out ray scattered) {\n    material m = rec.material;\n    \n    if (m.type == material_lambertian) {\n        vec3 scatter_direction = rec.normal + random_unit_vector(seed);\n    \n        // catch degenerate scatter direction\n        if (near_zero(scatter_direction)) {\n            scatter_direction = rec.normal;\n        }\n\n        scattered = ray(rec.p, scatter_direction);\n        attenuation = m.albedo;\n        return true;\n    } else if (m.type == material_metal) {\n        vec3 reflected = reflect(normalize(r.dir), rec.normal);\n        scattered = ray(rec.p, reflected + m.metal_fuzz * random_in_unit_sphere(seed));\n        attenuation = m.albedo;\n        return dot(scattered.dir, rec.normal) > 0.;\n    } else if (m.type == material_dielectric) {\n        attenuation = vec3(1);\n        \n        bool front_face = dot(r.dir, rec.normal) < 0.;\n        vec3 adjusted_normal = front_face ? rec.normal : -rec.normal;\n        float ref = m.dielectric_index_of_refraction;\n        float refraction_ratio = front_face ? 1.0/ref : ref;\n        \n        vec3 unit_direction = normalize(r.dir);\n        float cos_theta = min(dot(-unit_direction, adjusted_normal), 1.0);\n        float sin_theta = sqrt(1.0 - cos_theta * cos_theta);\n        \n        bool cannot_refract = refraction_ratio * sin_theta > 1.0;\n        vec3 direction;\n\n        if (cannot_refract || reflectance(cos_theta, refraction_ratio) > hash12(seed)) {\n            direction = reflect(unit_direction, adjusted_normal);\n        } else {\n            direction = refract(unit_direction, adjusted_normal, refraction_ratio);\n        }\n        \n        scattered = ray(rec.p, direction);\n        return true;\n    }\n}\n\nvec3 ray_color(in ray r, vec2 seed, int max_depth) {\n    vec3 color = vec3(1);\n    \n    int depth = max_depth;\n    hit_record rec;\n    while (depth > 0) {\n        if (hit(r, 0.001, 99999., rec)) {\n            ray scattered;\n            vec3 attenuation;\n            if (scatter(rec, r, seed + float(depth), attenuation, scattered)) {\n                r = scattered;\n                color = attenuation * color;\n            }\n        } else {\n            // hit bg, aka nothing\n            vec3 unit_direction = normalize(r.dir);\n            float t = 0.5 * (unit_direction.y + 1.0);\n            color *= mix(vec3(1.), vec3(0.5, 0.7, 1.0), t);\n\n            break;\n        }\n        \n        depth--;\n    }\n    \n    if (depth == 0) {\n        return vec3(0);\n    }\n    return color;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // image\n    float samples_per_pixel = 10.;\n    int max_depth = 6; // number of ray bounces\n    \n    // camera\n    vec3 lookfrom = vec3(cos(iTime) * 13., 2.0, sin(iTime) * 10.);\n    vec3 lookat = vec3(0, 0, 0);\n    vec3 vup = vec3(0, 1, 0);\n    float vfov = 30.0;\n    float aspect_ratio = iResolution.x / iResolution.y;\n    float aperture = 0.1;\n    float focus_dist = 10.0;\n    \n    float theta = radians(vfov);\n    float h = tan(theta / 2.);\n    float viewport_height = 2.0 * h;\n    float viewport_width = aspect_ratio * viewport_height;\n    \n    vec3 w = normalize(lookfrom - lookat);\n    vec3 u = normalize(cross(vup, w));\n    vec3 v = cross(w, u);\n    \n    vec3 origin = lookfrom;\n    vec3 horizontal = focus_dist * viewport_width * u;\n    vec3 vertical = focus_dist * viewport_height * v;\n    vec3 lower_left_corner = origin - horizontal / 2. - vertical / 2. - focus_dist * w;\n    \n    float lens_radius = aperture / 2.;\n    \n    // render\n    vec3 color = vec3(0);\n    for (float s = 0.; s < samples_per_pixel; s++) {\n        vec2 rand = hash22(fragCoord * 10000. + s);\n               \n        vec2 normalizedCoord = (fragCoord + rand) / (iResolution.xy - 1.);\n        vec3 rd = lens_radius * random_in_unit_disk(normalizedCoord);\n        vec3 offset = u * rd.x + v * rd.y;\n        ray r = ray(\n            origin + offset, \n            lower_left_corner + normalizedCoord.x * horizontal + normalizedCoord.y * vertical - origin - offset\n        );\n        color += ray_color(r, normalizedCoord, max_depth);\n    }\n    \n    fragColor = vec4(sqrt(color / samples_per_pixel), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlBGz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 88, 88, 205], [206, 206, 227, 227, 364], [365, 365, 386, 386, 525], [527, 527, 563, 563, 812], [814, 814, 847, 847, 897], [899, 899, 933, 933, 1191], [4023, 4023, 4105, 4105, 4867], [4869, 4869, 4932, 4932, 5284], [5286, 5286, 5310, 5310, 5374], [5376, 5376, 5424, 5475, 5595], [5597, 5597, 5686, 5686, 7336], [7338, 7338, 7390, 7390, 8122], [8124, 8124, 8181, 8194, 9772]], "test": "untested"}
{"id": "7tXSz8", "name": "darker scene test", "author": "fraser", "description": "A darker scene to characterize how this thing converges", "tags": ["3d", "raytracing", "raymarching", "sdf", "gi", "global", "pathtracing", "montecarlo"], "likes": 0, "viewed": 282, "published": 3, "date": "1625115810", "time_retrieved": "2024-07-30T19:12:56.584916", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec4 data = texture(iChannel0, fragCoord/iResolution.xy);\n\tvec3 col = data.xyz/data.w;\n\n    col = pow(col,vec3(0.4545)); // gamma correction\n\n\n    vec2 rC = vec2(max(iResolution.x,iResolution.y),\n                   min(iResolution.x,iResolution.y));\n    col*=0.24*(clamp(1.3-1.5*length(fragCoord-0.5*vec2(rC.x,rC.y))/rC.y,0.0,1.0)-1.0)+1.0;\n\n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//--<RANDOM>--------------------------------------------------------------------\n\t#define UV_NOISE 1\n\t// Rand functions postfixed with _tuv are generally for scattering, take UVs \n\t// as a seed (which may or may not be used depending on a define), and use  \n\t// an internal time-based seed.\n\n    // method from Lee C\n    // http://amindforeverprogramming.blogspot.com/2013/07/random-floats-in-glsl-330.html\n\tuint hash( uint x ) {\n        x += ( x << 10u );\n        x ^= ( x >>  6u );\n        x += ( x <<  3u );\n        x ^= ( x >> 11u );\n        x += ( x << 15u );\n        return x;\n    }\n    uint hash( uvec2 v ) {\n        return hash( v.x ^ hash(v.y) );\n    }\n\n    uint hash( uvec3 v ) {\n        return hash( v.x ^ hash(v.y) ^ hash(v.z) );\n    }\n\n    uint hash( uvec4 v ) {\n        return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) );\n    }\n    #define bitMantissaMask 0x007FFFFFu\n    #define bitOne 0x3F800000u\n    float random(float f) {\n        uint h = hash( floatBitsToUint( f ) );\n        h &= bitMantissaMask;\n        h |= bitOne;\n    \n        float  r2 = uintBitsToFloat( h );\n        return r2 - 1.0;\n    }\n    \n    float random(vec2 f) {\n        uint h = hash(floatBitsToUint( f ));\n        h &= bitMantissaMask;\n        h |= bitOne;\n    \n        float  r2 = uintBitsToFloat( h );\n        return r2 - 1.0;\n    }\n    float random(vec3 f) {\n        uint h = hash(floatBitsToUint( f ));\n        h &= bitMantissaMask;\n        h |= bitOne;\n    \n        float  r2 = uintBitsToFloat( h );\n        return r2 - 1.0;\n    }\n    float random(vec4 f) {\n        uint h = hash(floatBitsToUint( f ));\n        h &= bitMantissaMask;\n        h |= bitOne;\n    \n        float  r2 = uintBitsToFloat( h );\n        return r2 - 1.0;\n    }\n    //-------\n\tfloat rand_base_uv(float x, vec2 uv){\n\t\t#if UV_NOISE == 1\n\t\t\treturn random(vec3(uv, x));\n\t\t#else\n\t\t\treturn random(x);\n\t\t#endif\n\t}\n    \n\n\t// A few quick wrapper functions, probably could be faster if I put more time into it.\n\t// These should be made so tweaking any component in gives an unpredictably \n\t// different out on all components.\n\tfloat rand_f_tuv(vec2 seed){\n\t\treturn rand_base_uv(float(iFrame), seed);\n\t}\n\tvec2 rand_2f_tuv(vec2 seed){\n\t\treturn vec2(rand_base_uv(float(iFrame), seed), \n\t\t\t\t\trand_base_uv(float(iFrame)+3341.23138, seed));\n\t}\n\tvec2 rand_unitCircle_tuv(vec2 seed){ // uniform (in theory)\n\t\tvec2 r = rand_2f_tuv(seed);\n\t\tr.x *= 6.2831853;\n\t\treturn sqrt(r.y) * vec2(cos(r.x), sin(r.x));\n\t}\n\tvec3 rand_disk_tuv(vec3 nor, vec2 seed){\n\t\tvec3 u = vec3(0, -nor.z, nor.y);\n\t\tvec3 v = vec3(nor.y*nor.y+nor.z*nor.z, -nor.x*nor.y, -nor.x*nor.z);\n\t\tvec2 p = rand_unitCircle_tuv(seed);\n\t\treturn u*p.x+v*p.y;\n\t}\n\n\t// fizzer's tan-less method (http://www.amietia.com/lambertnotangent.html)\n\tvec3 cosDir_tuv(vec3 nor, vec2 seed){\n\t\tvec2 r = rand_2f_tuv(seed);\n\t\tr.x *= 6.2831853;\n\t\tr.y = 2.0*r.y-1.0;\n\t\treturn normalize(nor + vec3(sqrt(1.0-r.y*r.y) * \n\t\t\tvec2(cos(r.x), sin(r.x)), r.y));\n\t}\n\t// from wolfram-alpha, maybe could be faster.\n\tvec3 hemiSphereDir_tuv(vec3 nor, vec2 seed){\n\t\tvec2 r = rand_2f_tuv(seed);\n\t\tr.x *= 6.2831853;\n\t\tr.y = acos(2.0*r.y-1.0);\n\t\treturn normalize(nor + vec3(sqrt(1.0-r.y*r.y) * \n\t\t\tvec2(cos(r.x), sin(r.x)), r.y));\n\t}\n//--</RANDOM>-------------------------------------------------------------------\n\n//--<DATA TYPES>----------------------------------------------------------------\n\t// A way of packaging together distance information with an object identifier \n\t// (uint standing in for an enum). Possibly expand to include more information \n\t// (blending, etc) later, though it'll be tough without even so much as a \n\t// c-union, never-mind something like rust-enums.\n\t#define SKY_MAT\t0u\n\t#define MATTE_MAT  1u\n\t#define ORANGE_MAT 2u\n\t#define GREEN_MAT  3u\n\t#define END_MAT  4u\n\tstruct DistIden{\n\t\tfloat dist;\n\t\tuint  iden;\n\t};\n//--</DATA TYPES>---------------------------------------------------------------\n\n//--<DISTANCE FUNCTIONS>--------------------------------------------------------\n\t// speed isn't particularly important rn, so I'm going with an exponential \n\t// implementation for commutability. We can change this later for RTRT.  \n\tfloat smin(float a, float b, float k){\n\t\treturn -log2(exp2(-k*a) + exp2(-k*b))/k;\n\t}\n\tfloat smax(float a, float b, float k){\n\t\treturn log2(exp2(k*a) + exp2(k*b))/k;\n\t}\n\tfloat SDF_SPHERE(vec3 pos, float r){\n\t\treturn length(pos)-r;\n\t}\n\n\t#define windowPeriod 4.0\n\t#define boxwidth 3.0\n\t#define boxheight 1.5\n\t#define boxthickness 0.1\n\n\t#define ENABLE_boxroundness 1\n\t#define boxroundness 0.1\n\n\t#define holewidth 0.05 // 0.5\n\tfloat SDF_BOXTUBE(vec3 pos){\n\t\tvec2 q2 = abs(pos.yz) - vec2(boxheight/2.0, boxwidth/2.0);\n\t\tfloat d_tube = abs(length(max(q2,0.0)) + min(max(q2.x,q2.y),0.0)-boxroundness*3.0) - boxthickness;\n\t\tvec3 q3 = abs(vec3(mod(pos.x, windowPeriod)-windowPeriod*0.5, pos.y-boxheight/2.0, pos.z)) - vec3(holewidth,0.5,holewidth);\n\t\tfloat d_hole = length(max(q3,0.0)) + min(max(q3.x,max(q3.y,q3.z)),0.0)-boxroundness;\n\t#if ENABLE_boxroundness == 0\n\t\treturn max(d_tube, -d_hole);\n\t#else\n\t\treturn smax(d_tube, -d_hole, 50.0);\n\t#endif\n\t}\n\n\tDistIden DI_WORLD(vec3 pos){\n\t\tfloat d_sphere1   = SDF_SPHERE(vec3(mod(pos.x,2.62)-1.31, pos.y+0.6, pos.z+1.25), 0.85);\n\t\tfloat d_sphere2   = SDF_SPHERE(vec3(mod(pos.x-4.0,11.0)-5.5, pos.y-0.35, pos.z-1.1), 0.5);\n\t\tfloat d_left_wall = max(1.35-pos.z, abs(pos.y)-boxheight/2.0-boxthickness-0.1);\n\t\tfloat d_boxtube   = SDF_BOXTUBE(pos);\n\t\t\n\t\tDistIden di;\n\t\t\n\t\tdi.iden = d_boxtube < d_sphere1 ?  MATTE_MAT : ORANGE_MAT;\n\t\tdi.dist = smin(d_boxtube, d_sphere1, 12.0);\n\t\t\n\t\tdi.iden = d_sphere2 < di.dist ? GREEN_MAT : di.iden;\n\t\tdi.dist = min(d_sphere2, di.dist);\n\t\t\n\t\tdi.iden = d_left_wall < di.dist ? END_MAT : di.iden;\n\t\tdi.dist = min(d_left_wall, di.dist); \n\t\t\n\t\treturn di;\n\t}\n//--</DISTANCE FUNCTIONS>-------------------------------------------------------\n\n//--<WORLD-RENDERER INTERFACE>--------------------------------------------------\n\t#define SPHEREMARCH_ITERATIONS 512 // set via macro\n\tDistIden raycast(vec3 rayOrg, vec3 rayDir, float maxDist){\n\t\tfloat rayLength = 0.0;\n\t\tDistIden query;\n\t\tfor(int i=0;i<SPHEREMARCH_ITERATIONS;i++){\n\t\t\tquery = DI_WORLD(rayOrg + rayLength * rayDir);\n\t\t\tif(query.dist<0.001) break;\n\t\t\tif(rayLength>maxDist){\n\t\t\t\tquery.iden = SKY_MAT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trayLength += query.dist;\n\t\t}\n\t\tquery.dist = rayLength;\n\t\treturn query;\n\t}\n\n\t// using IQ's \"tetrahedron technique\"\n\tvec3 calcNormal(vec3 pos){\n\t\tvec2 EPSILON2 = 0.0001*vec2(1,-1);\n\t\treturn normalize(EPSILON2.xyy*DI_WORLD(pos+EPSILON2.xyy).dist+ \n\t\t\t\t\t\t EPSILON2.yyx*DI_WORLD(pos+EPSILON2.yyx).dist+ \n\t\t\t\t\t\t EPSILON2.yxy*DI_WORLD(pos+EPSILON2.yxy).dist+ \n\t\t\t\t\t\t EPSILON2.xxx*DI_WORLD(pos+EPSILON2.xxx).dist);\t\n\t}\n\n\t// occlusion-only version of raycast (0.0 for hit, 1.0 for miss)\n\t// once I'm generating shaders through code, write this as a separate \n\t// implementation to save from unnecessarily calculating identifiers.\n\tfloat raycastOcc(vec3 rayOrg, vec3 rayDir, float maxDist){\n\t\treturn (raycast(rayOrg, rayDir, maxDist).iden==SKY_MAT)?1.0:0.0;\n\t}\n\n\tvec3 skyColour(vec3 dir){\n\t\treturn vec3(0.639, 0.941, 1) - dir.y * 0.63;\n\t}\n\n\t// In the future this can be expanded to possibly take more parameters \n\t// (position, normal, incident ray angle, etc)\n\tvec3 renderMaterial(uint mat_iden){ \n\t\tvec3 matte = vec3(0.2);\n\t\t\tswitch(mat_iden){\n\t\t\t\tcase ORANGE_MAT:\n\t\t\t\t\tmatte *= vec3(0.3,1.0,1.0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GREEN_MAT:\n\t\t\t\t\tmatte *= vec3(0.0,0.16,1.0);\n\t\t\t\t\tbreak;\n                case END_MAT:\n\t\t\t\t\tmatte *= vec3(1.0,0.75,0.5);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\treturn matte;\n\t}\n//--</WORLD-RENDERER INTERFACE>-------------------------------------------------\n\n//--<RENDERER>------------------------------------------------------------------\n\t#define FAR_PLANE 5000.0 // set via macro, optionally non-existent via macro\n\n\tconst vec3 sun_dir = normalize(vec3(-0.03,0.5,0.5));\n\t// general direct-lighting function\n\tvec3 worldLighting(vec3 pos, vec3 nor, vec2 seed){\n\t\t// Procedure: for every (easy) light in the scene (including the sun and \n\t\t// sky), pick a random point on the surface of the light (weighted even in \n\t\t// regards to area from the perspective of pos). Calculate the Lambert (dot \n\t\t// product) lighting, and perform a direct occlusion test (with the light's \n\t\t// distance as the max dist). Add this to a running total.\n\t\tvec3 col = vec3(0.0);\n\t\t{\t// sky -----------\n\t\t\t// importance sampling: cosign weighted random means the dot product is baked into the distribution (and it's way faster).\n\t\t\tvec3 dir = cosDir_tuv(nor, seed);\n\t\t\tcol += skyColour(dir) * raycastOcc(pos, dir, FAR_PLANE);\n\t\t}{\t// sun -----------\n\t\t\tvec3  src\t  = 1000.0 * sun_dir + 50.0 * rand_disk_tuv(nor, seed);\n\t\t\tvec3  dir\t  = normalize(src - pos);\n\t\t\tfloat lambert = max(0.0, dot(dir, nor));\n\t\t\tcol += (vec3(1, 0.976, 0.929)*20.0) * lambert * raycastOcc(pos, dir, FAR_PLANE);\n\t\t}\t//    ------------\n\t\treturn col;\n\t}\n\n\t#define EPSILON1 0.001;\n\t#define DEPTH 6\n\tvec3 render(vec3 pos, vec3 dir, vec2 seed){\n\t\tvec3 summed = vec3(0.0);\n\t\tvec3 factional = vec3(1.0);\n\t\t\n\t\tfor(int i=0;i<DEPTH;i++){\n\t\t\tDistIden ray = raycast(pos, dir, FAR_PLANE);\n\t\t\t// fall out criteria\n\t\t\tif(ray.iden == SKY_MAT) {\n\t\t\t   if(i==0) return skyColour(dir);\n\t\t\t   break;\n\t\t\t}\n\t\t\t//update normal and pos\n\t\t\tpos += ray.dist * dir;\n\t\t\tvec3 nor = calcNormal(pos);\n\t\t\t// nudge so next raycast doesn't just immediately return a hit\n\t\t\t// (if very large scale things don't work make this dependent on dist from cam (|pos| if org = 0))\n\t\t\tpos += nor * EPSILON1; \n\n\t\t\t// loop unpacks to surface_1(direct_1 + surface_2(direct_2 + surface_3(direct_3 + ... ) ) )\n\t\t\t// (same as recursive approach)\n\t\t\tfactional *= renderMaterial(ray.iden);\n\t\t\tsummed += factional * worldLighting(pos, nor, seed);\n\t\t\t// currently random weight, possibly change later to allow for shiny mats\n\t\t\tdir = cosDir_tuv(nor, seed);\n\t\t}\n\t\treturn summed;\n\t}\n//--</RENDERER>-----------------------------------------------------------------\n\n//--<IMAGE>---------------------------------------------------------------------\n\tmat4x3 cameraMatrix(float time){\n\t\t// this following 4 var system is temporary, will be turned into a proper set of uniforms with full control later.\n\n\t\tvec3  subjectPos\t= vec3(1.8, -0.3, 0.0); \n\t\tfloat yawAngle\t  = -0.2;// + sin(time*0.347)*0.05;\n\t\tfloat subjectXZDist = 2.0; \n\t\tfloat subjectYDist  = 0.6; // + sin(time*0.6)*0.1;\n\n\t\t//cameraPointingVec\n\t\tvec3 cpv = vec3(subjectXZDist*cos(yawAngle), subjectYDist, subjectXZDist*sin(yawAngle));\n\t\tvec3 cpv_n = normalize(cpv);\n\n\t\tvec3 x = normalize(vec3(cpv_n.z, 0.0, -cpv_n.x));\n\t\treturn mat4x3(subjectPos + cpv, x, cross(cpv_n,x), -cpv_n);\n\t}\n\n\t#define FOV_OFFSET 1.64 //=1/tan(0.5*FOV)\n\t#define FOCUS_DIST 1.7\n\t#define BLUR_AMOUNT 0.01\n\n\tvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\t\t\n\t\tvec3 col = vec3(0);\n\t\t{\n\t\t\t// AA within pixel\n\t\t\tvec2 uv = (2.0*(fragCoord+rand_2f_tuv(fragCoord)-0.5)\n\t\t\t\t-iResolution.xy)/min(iResolution.x, iResolution.y);\n\t\t\t// motion blur\n\t\t\tfloat time = iTime + rand_f_tuv(uv)*float(iFrame);\n\n\t\t\t//<Camera with DOF (random offset of rayOrg on uv plane)>\n\t\t\t\tmat4x3 camM = cameraMatrix(time);\n\t\t\t\t\n\t\t\t\tvec3 uv3 = normalize(vec3(uv, FOV_OFFSET));\n\n\t\t\t\tvec3 randOffset = BLUR_AMOUNT*vec3(2.0*rand_2f_tuv(uv)-1.0, 0);\n\t\t\t\tvec3 randDir\t= normalize(uv3*FOCUS_DIST - randOffset);\n\n\t\t\t\tvec3 rayOrg = camM[0] + randOffset.x*camM[1] + randOffset.y*camM[2];\n\t\t\t\tvec3 rayDir = normalize((uv3.x+randDir.x)*camM[1] + (uv3.y+randDir.y)*camM[2] + uv3.z*camM[3]);\n\t\t\t//</Camera>\n\n\t\t\tcol = render(rayOrg, normalize(rayDir), uv);\n\t\t}\n\t\t\n\t\tvec4 data = texture(iChannel0, fragCoord/iResolution.xy);\n\t\tfragColor = data + vec4(col,1.0);\n        if(iMouse.z > 0.9) fragColor = vec4(0.0);\n\t}\n//--</IMAGE>---------------------------------------------------------------------", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tXSz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 431]], "test": "untested"}
{"id": "7lfXR8", "name": "Lighting test - fixed random", "author": "fraser", "description": "Swapped to a much improved random function (on the advise of iq). It's still a hash (no updating internal seed yet), but already gives much better results :)", "tags": ["3d", "raytracing", "raymarching", "sdf", "gi", "global", "pathtracing", "montecarlo"], "likes": 5, "viewed": 343, "published": 3, "date": "1625115298", "time_retrieved": "2024-07-30T19:12:57.518419", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec4 data = texture(iChannel0, fragCoord/iResolution.xy);\n\tvec3 col = data.xyz/data.w;\n\n    col = pow(col,vec3(0.4545)); // gamma correction\n\n\n    vec2 rC = vec2(max(iResolution.x,iResolution.y),\n                   min(iResolution.x,iResolution.y));\n    col*=0.24*(clamp(1.3-1.5*length(fragCoord-0.5*vec2(rC.x,rC.y))/rC.y,0.0,1.0)-1.0)+1.0;\n\n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//--<RANDOM>--------------------------------------------------------------------\n\t#define UV_NOISE 1\n\t// Rand functions postfixed with _tuv are generally for scattering, take UVs \n\t// as a seed (which may or may not be used depending on a define), and use  \n\t// an internal time-based seed.\n\n    // a method from Lee C\n    // http://amindforeverprogramming.blogspot.com/2013/07/random-floats-in-glsl-330.html\n\tuint hash( uint x ) {\n        x += ( x << 10u );\n        x ^= ( x >>  6u );\n        x += ( x <<  3u );\n        x ^= ( x >> 11u );\n        x += ( x << 15u );\n        return x;\n    }\n    uint hash( uvec2 v ) {\n        return hash( v.x ^ hash(v.y) );\n    }\n\n    uint hash( uvec3 v ) {\n        return hash( v.x ^ hash(v.y) ^ hash(v.z) );\n    }\n\n    uint hash( uvec4 v ) {\n        return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) );\n    }\n    #define bitMantissaMask 0x007FFFFFu\n    #define bitOne 0x3F800000u\n    float random(float f) {\n        uint h = hash( floatBitsToUint( f ) );\n        h &= bitMantissaMask;\n        h |= bitOne;\n    \n        float  r2 = uintBitsToFloat( h );\n        return r2 - 1.0;\n    }\n    \n    float random(vec2 f) {\n        uint h = hash(floatBitsToUint( f ));\n        h &= bitMantissaMask;\n        h |= bitOne;\n    \n        float  r2 = uintBitsToFloat( h );\n        return r2 - 1.0;\n    }\n    float random(vec3 f) {\n        uint h = hash(floatBitsToUint( f ));\n        h &= bitMantissaMask;\n        h |= bitOne;\n    \n        float  r2 = uintBitsToFloat( h );\n        return r2 - 1.0;\n    }\n    float random(vec4 f) {\n        uint h = hash(floatBitsToUint( f ));\n        h &= bitMantissaMask;\n        h |= bitOne;\n    \n        float  r2 = uintBitsToFloat( h );\n        return r2 - 1.0;\n    }\n    //-------\n\tfloat rand_base_uv(float x, vec2 uv){\n\t\t#if UV_NOISE == 1\n\t\t\treturn random(vec3(uv, x));\n\t\t#else\n\t\t\treturn random(x);\n\t\t#endif\n\t}\n    \n\n\t// A few quick wrapper functions, probably could be faster if I put more time into it.\n\t// These should be made so tweaking any component in gives an unpredictably \n\t// different out on all components.\n\tfloat rand_f_tuv(vec2 seed){\n\t\treturn rand_base_uv(float(iFrame), seed);\n\t}\n\tvec2 rand_2f_tuv(vec2 seed){\n\t\treturn vec2(rand_base_uv(float(iFrame), seed), \n\t\t\t\t\trand_base_uv(float(iFrame)+3341.23138, seed));\n\t}\n\tvec2 rand_unitCircle_tuv(vec2 seed){ // uniform (in theory)\n\t\tvec2 r = rand_2f_tuv(seed);\n\t\tr.x *= 6.2831853;\n\t\treturn sqrt(r.y) * vec2(cos(r.x), sin(r.x));\n\t}\n\tvec3 rand_disk_tuv(vec3 nor, vec2 seed){\n\t\tvec3 u = vec3(0, -nor.z, nor.y);\n\t\tvec3 v = vec3(nor.y*nor.y+nor.z*nor.z, -nor.x*nor.y, -nor.x*nor.z);\n\t\tvec2 p = rand_unitCircle_tuv(seed);\n\t\treturn u*p.x+v*p.y;\n\t}\n\n\t// fizzer's tan-less method (http://www.amietia.com/lambertnotangent.html)\n\tvec3 cosDir_tuv(vec3 nor, vec2 seed){\n\t\tvec2 r = rand_2f_tuv(seed);\n\t\tr.x *= 6.2831853;\n\t\tr.y = 2.0*r.y-1.0;\n\t\treturn normalize(nor + vec3(sqrt(1.0-r.y*r.y) * \n\t\t\tvec2(cos(r.x), sin(r.x)), r.y));\n\t}\n\t// from wolfram-alpha, maybe could be faster.\n\tvec3 hemiSphereDir_tuv(vec3 nor, vec2 seed){\n\t\tvec2 r = rand_2f_tuv(seed);\n\t\tr.x *= 6.2831853;\n\t\tr.y = acos(2.0*r.y-1.0);\n\t\treturn normalize(nor + vec3(sqrt(1.0-r.y*r.y) * \n\t\t\tvec2(cos(r.x), sin(r.x)), r.y));\n\t}\n//--</RANDOM>-------------------------------------------------------------------\n\n//--<DATA TYPES>----------------------------------------------------------------\n\t// A way of packaging together distance information with an object identifier \n\t// (uint standing in for an enum). Possibly expand to include more information \n\t// (blending, etc) later, though it'll be tough without even so much as a \n\t// c-union, never-mind something like rust-enums.\n\t#define SKY_MAT\t0u\n\t#define MATTE_MAT  1u\n\t#define ORANGE_MAT 2u\n\t#define GREEN_MAT  3u\n\t#define LIGHT_MAT  4u\n\tstruct DistIden{\n\t\tfloat dist;\n\t\tuint  iden;\n\t};\n//--</DATA TYPES>---------------------------------------------------------------\n\n//--<DISTANCE FUNCTIONS>--------------------------------------------------------\n\t// speed isn't particularly important rn, so I'm going with an exponential \n\t// implementation for commutability. We can change this later for RTRT.  \n\tfloat smin(float a, float b, float k){\n\t\treturn -log2(exp2(-k*a) + exp2(-k*b))/k;\n\t}\n\tfloat smax(float a, float b, float k){\n\t\treturn log2(exp2(k*a) + exp2(k*b))/k;\n\t}\n\tfloat SDF_SPHERE(vec3 pos, float r){\n\t\treturn length(pos)-r;\n\t}\n\n\t#define windowPeriod 3.0\n\t#define boxwidth 3.0\n\t#define boxheight 1.5\n\t#define boxthickness 0.1\n\n\t#define ENABLE_boxroundness 0\n\t#define boxroundness 0.0\n\n\t#define holewidth 0.5 // 0.5\n\tfloat SDF_BOXTUBE(vec3 pos){\n\t\tvec2 q2 = abs(pos.yz) - vec2(boxheight/2.0, boxwidth/2.0);\n\t\tfloat d_tube = abs(length(max(q2,0.0)) + min(max(q2.x,q2.y),0.0)-boxroundness*3.0) - boxthickness;\n\t\tvec3 q3 = abs(vec3(mod(pos.x, windowPeriod)-windowPeriod*0.5, pos.y-boxheight/2.0, pos.z)) - vec3(holewidth,0.5,holewidth);\n\t\tfloat d_hole = length(max(q3,0.0)) + min(max(q3.x,max(q3.y,q3.z)),0.0)-boxroundness;\n\t#if ENABLE_boxroundness == 0\n\t\treturn max(d_tube, -d_hole);\n\t#else\n\t\treturn smax(d_tube, -d_hole, 50.0);\n\t#endif\n\t}\n\n\tDistIden DI_WORLD(vec3 pos){\n\t\tfloat d_sphere1   = SDF_SPHERE(vec3(mod(pos.x,2.62)-1.31, pos.y+0.6, pos.z+1.25), 0.85);\n\t\tfloat d_sphere2   = SDF_SPHERE(vec3(mod(pos.x-4.0,11.0)-5.5, pos.y-0.35, pos.z-1.1), 0.25);\n\t\tfloat d_left_wall = max(1.35-pos.z, abs(pos.y)-boxheight/2.0-boxthickness-0.1);\n\t\tfloat d_boxtube   = SDF_BOXTUBE(pos);\n\t\t\n\t\tDistIden di;\n\t\t\n\t\tdi.iden = d_boxtube < d_sphere1 ?  MATTE_MAT : ORANGE_MAT;\n\t\tdi.dist = smin(d_boxtube, d_sphere1, 12.0);\n\t\t\n\t\tdi.iden = d_sphere2 < di.dist ? GREEN_MAT : di.iden;\n\t\tdi.dist = min(d_sphere2, di.dist);\n\t\t\n\t\tdi.iden = d_left_wall < di.dist ? MATTE_MAT : di.iden;\n\t\tdi.dist = min(d_left_wall, di.dist); \n\t\t\n\t\treturn di;\n\t}\n//--</DISTANCE FUNCTIONS>-------------------------------------------------------\n\n//--<WORLD-RENDERER INTERFACE>--------------------------------------------------\n\t#define SPHEREMARCH_ITERATIONS 512 // set via macro\n\tDistIden raycast(vec3 rayOrg, vec3 rayDir, float maxDist){\n\t\tfloat rayLength = 0.0;\n\t\tDistIden query;\n\t\tfor(int i=0;i<SPHEREMARCH_ITERATIONS;i++){\n\t\t\tquery = DI_WORLD(rayOrg + rayLength * rayDir);\n\t\t\tif(query.dist<0.001) break;\n\t\t\tif(rayLength>maxDist){\n\t\t\t\tquery.iden = SKY_MAT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trayLength += query.dist;\n\t\t}\n\t\tquery.dist = rayLength;\n\t\treturn query;\n\t}\n\n\t// using IQ's \"tetrahedron technique\"\n\tvec3 calcNormal(vec3 pos){\n\t\tvec2 EPSILON2 = 0.0001*vec2(1,-1);\n\t\treturn normalize(EPSILON2.xyy*DI_WORLD(pos+EPSILON2.xyy).dist+ \n\t\t\t\t\t\t EPSILON2.yyx*DI_WORLD(pos+EPSILON2.yyx).dist+ \n\t\t\t\t\t\t EPSILON2.yxy*DI_WORLD(pos+EPSILON2.yxy).dist+ \n\t\t\t\t\t\t EPSILON2.xxx*DI_WORLD(pos+EPSILON2.xxx).dist);\t\n\t}\n\n\t// occlusion-only version of raycast (0.0 for hit, 1.0 for miss)\n\t// once I'm generating shaders through code, write this as a separate \n\t// implementation to save from unnecessarily calculating identifiers.\n\tfloat raycastOcc(vec3 rayOrg, vec3 rayDir, float maxDist){\n\t\treturn (raycast(rayOrg, rayDir, maxDist).iden==SKY_MAT)?1.0:0.0;\n\t}\n\n\tvec3 skyColour(vec3 dir){\n\t\treturn vec3(0.639, 0.941, 1) - dir.y * 0.63;\n\t}\n\n\t// In the future this can be expanded to possibly take more parameters \n\t// (position, normal, incident ray angle, etc)\n\tvec3 renderMaterial(uint mat_iden){ \n\t\tvec3 matte = vec3(0.2);\n\t\t\tswitch(mat_iden){\n\t\t\t\tcase ORANGE_MAT:\n\t\t\t\t\tmatte *= vec3(1.0,0.5,0.0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GREEN_MAT:\n\t\t\t\t\tmatte *= vec3(0.0,1.0,0.16);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\treturn matte;\n\t}\n//--</WORLD-RENDERER INTERFACE>-------------------------------------------------\n\n//--<RENDERER>------------------------------------------------------------------\n\t#define FAR_PLANE 5000.0 // set via macro, optionally non-existent via macro\n\n\tconst vec3 sun_dir = normalize(vec3(-0.03,0.5,0.5));\n\t// general direct-lighting function\n\tvec3 worldLighting(vec3 pos, vec3 nor, vec2 seed){\n\t\t// Procedure: for every (easy) light in the scene (including the sun and \n\t\t// sky), pick a random point on the surface of the light (weighted even in \n\t\t// regards to area from the perspective of pos). Calculate the Lambert (dot \n\t\t// product) lighting, and perform a direct occlusion test (with the light's \n\t\t// distance as the max dist). Add this to a running total.\n\t\tvec3 col = vec3(0.0);\n\t\t{\t// sky -----------\n\t\t\t// importance sampling: cosign weighted random means the dot product is baked into the distribution (and it's way faster).\n\t\t\tvec3 dir = cosDir_tuv(nor, seed);\n\t\t\tcol += skyColour(dir) * raycastOcc(pos, dir, FAR_PLANE);\n\t\t}{\t// sun -----------\n\t\t\tvec3  src\t  = 1000.0 * sun_dir + 50.0 * rand_disk_tuv(nor, seed);\n\t\t\tvec3  dir\t  = normalize(src - pos);\n\t\t\tfloat lambert = max(0.0, dot(dir, nor));\n\t\t\tcol += (vec3(1, 0.976, 0.929)*20.0) * lambert * raycastOcc(pos, dir, FAR_PLANE);\n\t\t}\t//    ------------\n\t\treturn col;\n\t}\n\n\t#define EPSILON1 0.001;\n\t#define DEPTH 6\n\tvec3 render(vec3 pos, vec3 dir, vec2 seed){\n\t\tvec3 summed = vec3(0.0);\n\t\tvec3 factional = vec3(1.0);\n\t\t\n\t\tfor(int i=0;i<DEPTH;i++){\n\t\t\tDistIden ray = raycast(pos, dir, FAR_PLANE);\n\t\t\t// fall out criteria\n\t\t\tif(ray.iden == SKY_MAT) {\n\t\t\t   if(i==0) return skyColour(dir);\n\t\t\t   break;\n\t\t\t}\n\t\t\t//update normal and pos\n\t\t\tpos += ray.dist * dir;\n\t\t\tvec3 nor = calcNormal(pos);\n\t\t\t// nudge so next raycast doesn't just immediately return a hit\n\t\t\t// (if very large scale things don't work make this dependent on dist from cam (|pos| if org = 0))\n\t\t\tpos += nor * EPSILON1; \n\n\t\t\t// loop unpacks to surface_1(direct_1 + surface_2(direct_2 + surface_3(direct_3 + ... ) ) )\n\t\t\t// (same as recursive approach)\n\t\t\tfactional *= renderMaterial(ray.iden);\n\t\t\tsummed += factional * worldLighting(pos, nor, seed);\n\t\t\t// currently random weight, possibly change later to allow for shiny mats\n\t\t\tdir = cosDir_tuv(nor, seed);\n\t\t}\n\t\treturn summed;\n\t}\n//--</RENDERER>-----------------------------------------------------------------\n\n//--<IMAGE>---------------------------------------------------------------------\n\tmat4x3 cameraMatrix(float time){\n\t\t// this following 4 var system is temporary, will be turned into a proper set of uniforms with full control later.\n\n\t\tvec3  subjectPos\t= vec3(0.0, -0.3, 0.0); \n\t\tfloat yawAngle\t  = -0.2;// + sin(time*0.347)*0.05;\n\t\tfloat subjectXZDist = 2.0; \n\t\tfloat subjectYDist  = 0.6; // + sin(time*0.6)*0.1;\n\n\t\t//cameraPointingVec\n\t\tvec3 cpv = vec3(subjectXZDist*cos(yawAngle), subjectYDist, subjectXZDist*sin(yawAngle));\n\t\tvec3 cpv_n = normalize(cpv);\n\n\t\tvec3 x = normalize(vec3(cpv_n.z, 0.0, -cpv_n.x));\n\t\treturn mat4x3(subjectPos + cpv, x, cross(cpv_n,x), -cpv_n);\n\t}\n\n\t#define FOV_OFFSET 1.64 //=1/tan(0.5*FOV)\n\t#define FOCUS_DIST 1.7\n\t#define BLUR_AMOUNT 0.01\n\n\tvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\t\t\n\t\tvec3 col = vec3(0);\n\t\t{\n\t\t\t// AA within pixel\n\t\t\tvec2 uv = (2.0*(fragCoord+rand_2f_tuv(fragCoord)-0.5)\n\t\t\t\t-iResolution.xy)/min(iResolution.x, iResolution.y);\n\t\t\t// motion blur\n\t\t\tfloat time = iTime + rand_f_tuv(uv)*float(iFrame);\n\n\t\t\t//<Camera with DOF (random offset of rayOrg on uv plane)>\n\t\t\t\tmat4x3 camM = cameraMatrix(time);\n\t\t\t\t\n\t\t\t\tvec3 uv3 = normalize(vec3(uv, FOV_OFFSET));\n\n\t\t\t\tvec3 randOffset = BLUR_AMOUNT*vec3(2.0*rand_2f_tuv(uv)-1.0, 0);\n\t\t\t\tvec3 randDir\t= normalize(uv3*FOCUS_DIST - randOffset);\n\n\t\t\t\tvec3 rayOrg = camM[0] + randOffset.x*camM[1] + randOffset.y*camM[2];\n\t\t\t\tvec3 rayDir = normalize((uv3.x+randDir.x)*camM[1] + (uv3.y+randDir.y)*camM[2] + uv3.z*camM[3]);\n\t\t\t//</Camera>\n\n\t\t\tcol = render(rayOrg, normalize(rayDir), uv);\n\t\t}\n\t\t\n\t\tvec4 data = texture(iChannel0, fragCoord/iResolution.xy);\n\t\tfragColor = data + vec4(col,1.0);\n        if(iMouse.z > 0.9) fragColor = vec4(0.0);\n\t}\n//--</IMAGE>---------------------------------------------------------------------", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lfXR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 431]], "test": "untested"}
{"id": "stXSz8", "name": "folding Julia set", "author": "Shellderr", "description": "Julia set with distorted input coordinates. Use the mouse to change C.", "tags": ["fractal", "julia"], "likes": 2, "viewed": 258, "published": 3, "date": "1625114164", "time_retrieved": "2024-07-30T19:12:58.295342", "image_code": "#define res iResolution\n#define thresh 20.\n#define stop 200\n\nvec3 rgb(float a){\n    a *=8.;\n    return(cos(4.+a+vec3(0.,2.,4.)*.7)*.5+.5);\n}\n\nvec2 cmul(vec2 a, vec2 b){\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2){\n    float a = (v1.x*v2.x+v1.y*v2.y)/(v2.x*v2.x+v2.y*v2.y);\n    float b = (v1.y*v2.x-v1.x*v2.y)/(v2.x*v2.x+v2.y*v2.y);\n    return vec2(a,b);\n}\n\nvec2 cexp(vec2 z){\n    return exp(z.x)*vec2(cos(z.y),sin(z.y));\n}\n\nvec2 clog(vec2 z){\n    return vec2(log(length(z)),atan(z.y,z.x));\n}\n\nvec2 cpow(vec2 z, float c){\n    return cexp(c*clog(z));\n}\n\n\nvec2 clerp(vec2 a, vec2 b, float m){\n    m = clamp(m,0.,1.);\n    return cmul(vec2(1.-m),a)+cmul(vec2(m),b);\n}\n\n\nvec2 rot(vec2 v, float t){\n    float a = (1.*atan(v.x,v.y))+t;\n    return vec2(cos(a),sin(a))*length(v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    vec2 z = .8*(2.*fragCoord.xy-res.xy)/res.y;\n    // z = rot(z,time);\n    //vec2 zz = vec2(0);\n    z = clerp(.3*clog(vec2(2)+z), (cdiv(vec2(.5),z)), .1);\n    // z = cexp(cmul(z,vec2(.4)));\n    z=rot(z,iTime*.3);\n    vec2 mouse = .5*iMouse.xy/res.xy;\n    vec2 c = mouse.xy==vec2(0)? vec2(-.77,-.22)/*vec2(cos(iTime*.4)-.3,-.66)*/: (2.*mouse.xy-1.);\n    int i = 0;\n    for(i; i < stop; i++){\n        z = cmul(z,z)+c;\n        if(length(z) > thresh)\n            break;\n    }\n    vec3 col = rgb(log(.9+float(i)/380.)*2.);\n    fragColor = vec4(col, 1.0 );\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stXSz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 79, 79, 140], [142, 142, 168, 168, 225], [227, 227, 255, 255, 397], [399, 399, 417, 417, 464], [466, 466, 484, 484, 533], [535, 535, 562, 562, 592], [595, 595, 631, 631, 704], [707, 707, 733, 733, 813], [815, 815, 870, 870, 1424]], "test": "untested"}
{"id": "stXSR8", "name": "Mandelbrot Set Pixel Counting", "author": "oneshade", "description": "Using mipmaps to count the pixels in the mandelbrot set. Reference: [url=https://www.shadertoy.com/view/Ml2cDm]https://www.shadertoy.com/view/Ml2cDm[/url]\nTo get a better measurement in actual units, you'll need to manually set PIXEL_AREA.", "tags": ["mandelbrot", "mipmap", "area", "gpmipmap", "pixelcounting"], "likes": 5, "viewed": 249, "published": 3, "date": "1625106553", "time_retrieved": "2024-07-30T19:12:59.247795", "image_code": "// To get a better measurement in actual units, you'll need to\n// manually set PIXEL_AREA to the area of your screens' pixels\n// in millimeters² or better yet, directly measure the shader window.\n// You can change the mandelbrot set by dragging with the mouse.\n\n// Likely not accurate\n#define PIXEL_AREA 0.07000433851\n\n// Maximum string length\n#define MAX_LEN 7\n\n// Hue to RGB function from Fabrice's shadertoyunofficial blog\n#define hue2rgb(hue) (0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0)))\n\n// Modified version of font loader from https://www.shadertoy.com/view/ltcXzs\nvoid drawChar(inout vec3 pixel, in vec3 color, in vec2 uv, in vec2 pos, in vec2 size, in int char) {\n    uv = (uv - pos) / size + 0.5;\n    vec2 charUv = uv / 16.0;\n    vec2 dfdx = dFdx(charUv);\n    vec2 dfdy = dFdy(charUv);\n    if (all(lessThan(abs(uv - 0.5), vec2(0.5)))) {\n        float val = textureGrad(iChannel1, charUv + fract(vec2(char, 15 - char / 16) / 16.0), dfdx, dfdy).r;\n        pixel = mix(pixel, color, val);\n    }\n}\n\nvoid drawFloat(inout vec3 pixel, in vec3 color, in vec2 uv, in vec2 anchor, in vec2 size, in float spacing, in float num) {\n    num = round(num * 100.0) * 0.01;\n    for (float place=-2.0; place < 3.0; place++) {\n        int digit = int(num * pow(10.0, place)) - 10 * int(num * pow(10.0, place - 1.0));\n        drawChar(pixel, color, uv, anchor, size, ZERO + digit);\n        anchor.x += spacing;\n    }\n}\n\nvoid drawString(inout vec3 pixel, in vec3 color, in vec2 uv, in vec2 anchor, in vec2 size, in float spacing, in int[MAX_LEN] string, in int strLen) {\n    for (int char=0; char < strLen; char++) {\n        drawChar(pixel, color, uv, anchor, size, string[char]);\n        anchor.x += spacing;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y; // Centered, aspect correct\n    vec2 st = fragCoord / iResolution.xy; // Normalize to [0...1] range\n\n    vec2 buf = texture(iChannel0, st).xy;\n    fragColor = vec4(pow(max(0.0, 1.0 - length(st - 0.5)), 0.8));\n\n    vec3 color = 0.5 * (hue2rgb(0.01 * buf.y) + cos(0.25 * buf.y + iTime));\n    fragColor.rgb = mix(fragColor.rgb, color, buf.x); // Display mandelbrot color\n\n    buf = texture(iChannel0, st, 100.0).xz;\n    float relativeArea = buf.x / buf.y; // Decimal percentage of screen area\n\n    vec2 anchor = vec2(-0.8, 0.35);\n\n    // Text message \"Pixels:\"\n    drawString(fragColor.rgb, vec3(0.0), uv, anchor, vec2(0.1), 0.08, int[MAX_LEN](P, i, x, e, l, s, COLON), 7);\n    anchor.y = 0.25;\n\n    // Relative area\n    drawFloat(fragColor.rgb, vec3(0.0), uv, anchor, vec2(0.1), 0.08, relativeArea * 100.0);\n    drawChar(fragColor.rgb, vec3(0.0), uv, anchor + vec2(0.20, 0.0), vec2(0.1), PERIOD);\n    drawChar(fragColor.rgb, vec3(0.0), uv, anchor + vec2(0.40, 0.0), vec2(0.1), PERCENT);\n\n    // Area (approximate)\n    float screenArea = iResolution.x * iResolution.y * PIXEL_AREA;\n    float mandelbrotArea = screenArea * relativeArea;\n    mandelbrotArea *= 0.01; // Convert to centimeters to shorten the number (100 millimeter² = 1 centimeter²)\n\n    anchor = vec2(-0.8, -0.25);\n\n    // Text message \"Area~\"\n    drawString(fragColor.rgb, vec3(0.0), uv, anchor, vec2(0.1), 0.08, int[MAX_LEN](A, r, e, a, TILDE, 0, 0), 5);\n    anchor.y = -0.35;\n\n    // Area (not relative)\n    drawFloat(fragColor.rgb, vec3(0.0), uv, anchor, vec2(0.1), 0.08, mandelbrotArea);\n    drawChar(fragColor.rgb, vec3(0.0), uv, anchor + vec2(0.20, 0.0), vec2(0.1), PERIOD);\n    drawChar(fragColor.rgb, vec3(0.0), uv, anchor + vec2(0.40, 0.0), vec2(0.1), c);\n    drawChar(fragColor.rgb, vec3(0.0), uv, anchor + vec2(0.48, 0.0), vec2(0.1), m);\n    drawChar(fragColor.rgb, vec3(0.0), uv, anchor + vec2(0.54, 0.0), vec2(0.1), SQUARE);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Complex power\nvec2 cpow(in vec2 z, in float n) {\n    float a = atan(z.y, z.x) * n;\n    return vec2(cos(a), sin(a)) * pow(dot(z, z), 0.5 * n);\n}\n\n// Mandelbrot set iterator\nvec2 mandelbrot(in vec2 pixel) {\n    vec2 c = (pixel - 0.5 * iResolution.xy) / iResolution.y * 3.0;\n    float n = iMouse.z > 0.0 ? iMouse.x / iResolution.x * 10.0 : mix(2.0, 8.0, 0.5 + 0.5 * sin(0.5 * iTime));\n    vec2 z = vec2(0.0, 0.0);\n    float a = 0.0;\n    for (float i=0.0; i < 50.0; i++) {\n        z = cpow(z, n) + c;\n        if (i > 15.0) {\n            return vec2(1.0, a);\n        }\n\n        if (length(z) > 2.0) break;\n        a += (c.y - z.y) / (length(z - c) + 0.001); // cross(normalize(z - c), vec2(1, 0))\n    }\n\n    return vec2(0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    float spp = 4.0; // Really sqrt(SPP)\n\n    // Accumulate and average pixel samples to approximate local area\n    for (float x=0.0; x < spp; x++) {\n        for (float y=0.0; y < spp; y++) {\n            fragColor.xy += mandelbrot(fragCoord + vec2(x, y) / spp);\n        }\n    }\n\n    fragColor.xy /= spp * spp;\n    fragColor.z = 1.0; // To count total pixels\n}", "buffer_a_inputs": [], "common_code": "// Character codes for convenience (with unused ones removed)\n// Generated with a python script I wrote to save me the trouble ;)\n// I'm not using macros because otherwise every piece of my code starts burning\nconst int PERCENT = 37;\nconst int PERIOD = 46;\nconst int ZERO = 48;\nconst int COLON = 58;\nconst int A = 65;\nconst int E = 69;\nconst int P = 80;\nconst int a = 97;\nconst int c = 99;\nconst int e = 101;\nconst int i = 105;\nconst int l = 108;\nconst int m = 109;\nconst int r = 114;\nconst int s = 115;\nconst int x = 120;\nconst int TILDE = 126;\nconst int SQUARE = 178;", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stXSR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[502, 580, 680, 680, 1011], [1013, 1013, 1136, 1136, 1415], [1715, 1715, 1770, 1770, 3740]], "test": "untested"}
{"id": "flfSRH", "name": "Bounce lighting test", "author": "fraser", "description": "I'm currently having some issues where convergence still has banding (even with uv noise enabled), but that could easily just be that my random-functions are a bit lacking", "tags": ["3d", "raytracing", "raymarching", "sdf", "gi", "global", "pathtracing", "montecarlo"], "likes": 4, "viewed": 337, "published": 3, "date": "1625102985", "time_retrieved": "2024-07-30T19:13:00.100515", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec4 data = texture(iChannel0, fragCoord/iResolution.xy);\n\tvec3 col = data.xyz/data.w;\n\n    col = pow(col,vec3(0.4545)); // gamma correction\n\n\n    vec2 rC = vec2(max(iResolution.x,iResolution.y),\n                   min(iResolution.x,iResolution.y));\n    col*=0.24*(clamp(1.3-1.5*length(fragCoord-0.5*vec2(rC.x,rC.y))/rC.y,0.0,1.0)-1.0)+1.0;\n\n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//--<RANDOM>--------------------------------------------------------------------\n\t#define UV_NOISE 0\n\t// Rand functions postfixed with _tuv are generally for scattering, take UVs \n\t// as a seed (which may or may not be used depending on a define), and use  \n\t// an internal time-based seed.\n\n\t// I'm about 60% sure random's originally from the book of shaders, though I've\n\t// seen it used literally everywhere \n\tfloat rand_base_uv(float x, vec2 uv){\n\t\t#if UV_NOISE == 1\n\t\t\treturn fract(sin(dot(vec3(uv, x), vec3(12.9898, 78.233, 47.2964))) * 43758.5453);\n\t\t#else\n\t\t\treturn fract(sin(x) * 43758.5453);\n\t\t#endif\n\t}\n\n\t// A few quick wrapper functions, probably could be faster if I put more time into it.\n\t// These should be made so tweaking any component in gives an unpredictably \n\t// different out on all components.\n\tfloat rand_f_tuv(vec2 seed){\n\t\treturn rand_base_uv(float(iFrame), seed);\n\t}\n\tvec2 rand_2f_tuv(vec2 seed){\n\t\treturn vec2(rand_base_uv(float(iFrame), seed), \n\t\t\t\t\trand_base_uv(float(iFrame)+3341.23138, seed));\n\t}\n\tvec2 rand_unitCircle_tuv(vec2 seed){ // uniform (in theory)\n\t\tvec2 r = rand_2f_tuv(seed);\n\t\tr.x *= 6.2831853;\n\t\treturn sqrt(r.y) * vec2(cos(r.x), sin(r.x));\n\t}\n\tvec3 rand_disk_tuv(vec3 nor, vec2 seed){\n\t\tvec3 u = vec3(0, -nor.z, nor.y);\n\t\tvec3 v = vec3(nor.y*nor.y+nor.z*nor.z, -nor.x*nor.y, -nor.x*nor.z);\n\t\tvec2 p = rand_unitCircle_tuv(seed);\n\t\treturn u*p.x+v*p.y;\n\t}\n\n\t// fizzer's tan-less method (http://www.amietia.com/lambertnotangent.html)\n\tvec3 cosDir_tuv(vec3 nor, vec2 seed){\n\t\tvec2 r = rand_2f_tuv(seed);\n\t\tr.x *= 6.2831853;\n\t\tr.y = 2.0*r.y-1.0;\n\t\treturn normalize(nor + vec3(sqrt(1.0-r.y*r.y) * \n\t\t\tvec2(cos(r.x), sin(r.x)), r.y));\n\t}\n\t// from wolfram-alpha, maybe could be faster.\n\tvec3 hemiSphereDir_tuv(vec3 nor, vec2 seed){\n\t\tvec2 r = rand_2f_tuv(seed);\n\t\tr.x *= 6.2831853;\n\t\tr.y = acos(2.0*r.y-1.0);\n\t\treturn normalize(nor + vec3(sqrt(1.0-r.y*r.y) * \n\t\t\tvec2(cos(r.x), sin(r.x)), r.y));\n\t}\n//--</RANDOM>-------------------------------------------------------------------\n\n//--<DATA TYPES>----------------------------------------------------------------\n\t// A way of packaging together distance information with an object identifier \n\t// (uint standing in for an enum). Possibly expand to include more information \n\t// (blending, etc) later, though it'll be tough without even so much as a \n\t// c-union, never-mind something like rust-enums.\n\t#define SKY_MAT\t0u\n\t#define MATTE_MAT  1u\n\t#define ORANGE_MAT 2u\n\t#define GREEN_MAT  3u\n\t#define LIGHT_MAT  4u\n\tstruct DistIden{\n\t\tfloat dist;\n\t\tuint  iden;\n\t};\n//--</DATA TYPES>---------------------------------------------------------------\n\n//--<DISTANCE FUNCTIONS>--------------------------------------------------------\n\t// speed isn't particularly important rn, so I'm going with an exponential \n\t// implementation for commutability. We can change this later for RTRT.  \n\tfloat smin(float a, float b, float k){\n\t\treturn -log2(exp2(-k*a) + exp2(-k*b))/k;\n\t}\n\tfloat smax(float a, float b, float k){\n\t\treturn log2(exp2(k*a) + exp2(k*b))/k;\n\t}\n\tfloat SDF_SPHERE(vec3 pos, float r){\n\t\treturn length(pos)-r;\n\t}\n\n\t#define windowPeriod 3.0\n\t#define boxwidth 3.0\n\t#define boxheight 1.5\n\t#define boxthickness 0.1\n\n\t#define ENABLE_boxroundness 0\n\t#define boxroundness 0.0\n\n\t#define holewidth 0.5 // 0.5\n\tfloat SDF_BOXTUBE(vec3 pos){\n\t\tvec2 q2 = abs(pos.yz) - vec2(boxheight/2.0, boxwidth/2.0);\n\t\tfloat d_tube = abs(length(max(q2,0.0)) + min(max(q2.x,q2.y),0.0)-boxroundness*3.0) - boxthickness;\n\t\tvec3 q3 = abs(vec3(mod(pos.x, windowPeriod)-windowPeriod*0.5, pos.y-boxheight/2.0, pos.z)) - vec3(holewidth,0.5,holewidth);\n\t\tfloat d_hole = length(max(q3,0.0)) + min(max(q3.x,max(q3.y,q3.z)),0.0)-boxroundness;\n\t#if ENABLE_boxroundness == 0\n\t\treturn max(d_tube, -d_hole);\n\t#else\n\t\treturn smax(d_tube, -d_hole, 50.0);\n\t#endif\n\t}\n\n\tDistIden DI_WORLD(vec3 pos){\n\t\tfloat d_sphere1   = SDF_SPHERE(vec3(mod(pos.x,2.62)-1.31, pos.y+0.6, pos.z+1.25), 0.85);\n\t\tfloat d_sphere2   = SDF_SPHERE(vec3(mod(pos.x-4.0,11.0)-5.5, pos.y-0.35, pos.z-1.1), 0.25);\n\t\tfloat d_left_wall = max(1.35-pos.z, abs(pos.y)-boxheight/2.0-boxthickness-0.1);\n\t\tfloat d_boxtube   = SDF_BOXTUBE(pos);\n\t\t\n\t\tDistIden di;\n\t\t\n\t\tdi.iden = d_boxtube < d_sphere1 ?  MATTE_MAT : ORANGE_MAT;\n\t\tdi.dist = smin(d_boxtube, d_sphere1, 12.0);\n\t\t\n\t\tdi.iden = d_sphere2 < di.dist ? GREEN_MAT : di.iden;\n\t\tdi.dist = min(d_sphere2, di.dist);\n\t\t\n\t\tdi.iden = d_left_wall < di.dist ? MATTE_MAT : di.iden;\n\t\tdi.dist = min(d_left_wall, di.dist); \n\t\t\n\t\treturn di;\n\t}\n//--</DISTANCE FUNCTIONS>-------------------------------------------------------\n\n//--<WORLD-RENDERER INTERFACE>--------------------------------------------------\n\t#define SPHEREMARCH_ITERATIONS 512 // set via macro\n\tDistIden raycast(vec3 rayOrg, vec3 rayDir, float maxDist){\n\t\tfloat rayLength = 0.0;\n\t\tDistIden query;\n\t\tfor(int i=0;i<SPHEREMARCH_ITERATIONS;i++){\n\t\t\tquery = DI_WORLD(rayOrg + rayLength * rayDir);\n\t\t\tif(query.dist<0.001) break;\n\t\t\tif(rayLength>maxDist){\n\t\t\t\tquery.iden = SKY_MAT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trayLength += query.dist;\n\t\t}\n\t\tquery.dist = rayLength;\n\t\treturn query;\n\t}\n\n\t// using IQ's \"tetrahedron technique\"\n\tvec3 calcNormal(vec3 pos){\n\t\tvec2 EPSILON2 = 0.0001*vec2(1,-1);\n\t\treturn normalize(EPSILON2.xyy*DI_WORLD(pos+EPSILON2.xyy).dist+ \n\t\t\t\t\t\t EPSILON2.yyx*DI_WORLD(pos+EPSILON2.yyx).dist+ \n\t\t\t\t\t\t EPSILON2.yxy*DI_WORLD(pos+EPSILON2.yxy).dist+ \n\t\t\t\t\t\t EPSILON2.xxx*DI_WORLD(pos+EPSILON2.xxx).dist);\t\n\t}\n\n\t// occlusion-only version of raycast (0.0 for hit, 1.0 for miss)\n\t// once I'm generating shaders through code, write this as a separate \n\t// implementation to save from unnecessarily calculating identifiers.\n\tfloat raycastOcc(vec3 rayOrg, vec3 rayDir, float maxDist){\n\t\treturn (raycast(rayOrg, rayDir, maxDist).iden==SKY_MAT)?1.0:0.0;\n\t}\n\n\tvec3 skyColour(vec3 dir){\n\t\treturn vec3(0.639, 0.941, 1) - dir.y * 0.63;\n\t}\n\n\t// In the future this can be expanded to possibly take more parameters \n\t// (position, normal, incident ray angle, etc)\n\tvec3 renderMaterial(uint mat_iden){ \n\t\tvec3 matte = vec3(0.2);\n\t\t\tswitch(mat_iden){\n\t\t\t\tcase ORANGE_MAT:\n\t\t\t\t\tmatte *= vec3(1.0,0.5,0.0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GREEN_MAT:\n\t\t\t\t\tmatte *= vec3(0.0,1.0,0.16);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\treturn matte;\n\t}\n//--</WORLD-RENDERER INTERFACE>-------------------------------------------------\n\n//--<RENDERER>------------------------------------------------------------------\n\t#define FAR_PLANE 5000.0 // set via macro, optionally non-existent via macro\n\n\tconst vec3 sun_dir = normalize(vec3(-0.03,0.5,0.5));\n\t// general direct-lighting function\n\tvec3 worldLighting(vec3 pos, vec3 nor, vec2 seed){\n\t\t// Procedure: for every (easy) light in the scene (including the sun and \n\t\t// sky), pick a random point on the surface of the light (weighted even in \n\t\t// regards to area from the perspective of pos). Calculate the Lambert (dot \n\t\t// product) lighting, and perform a direct occlusion test (with the light's \n\t\t// distance as the max dist). Add this to a running total.\n\t\tvec3 col = vec3(0.0);\n\t\t{\t// sky -----------\n\t\t\t// importance sampling: cosign weighted random means the dot product is baked into the distribution (and it's way faster).\n\t\t\tvec3 dir = cosDir_tuv(nor, seed);\n\t\t\tcol += skyColour(dir) * raycastOcc(pos, dir, FAR_PLANE);\n\t\t}{\t// sun -----------\n\t\t\tvec3  src\t  = 1000.0 * sun_dir + 50.0 * rand_disk_tuv(nor, seed);\n\t\t\tvec3  dir\t  = normalize(src - pos);\n\t\t\tfloat lambert = max(0.0, dot(dir, nor));\n\t\t\tcol += (vec3(1, 0.976, 0.929)*20.0) * lambert * raycastOcc(pos, dir, FAR_PLANE);\n\t\t}\t//    ------------\n\t\treturn col;\n\t}\n\n\t#define EPSILON1 0.001;\n\t#define DEPTH 6\n\tvec3 render(vec3 pos, vec3 dir, vec2 seed){\n\t\tvec3 summed = vec3(0.0);\n\t\tvec3 factional = vec3(1.0);\n\t\t\n\t\tfor(int i=0;i<DEPTH;i++){\n\t\t\tDistIden ray = raycast(pos, dir, FAR_PLANE);\n\t\t\t// fall out criteria\n\t\t\tif(ray.iden == SKY_MAT) {\n\t\t\t   if(i==0) return skyColour(dir);\n\t\t\t   break;\n\t\t\t}\n\t\t\t//update normal and pos\n\t\t\tpos += ray.dist * dir;\n\t\t\tvec3 nor = calcNormal(pos);\n\t\t\t// nudge so next raycast doesn't just immediately return a hit\n\t\t\t// (if very large scale things don't work make this dependent on dist from cam (|pos| if org = 0))\n\t\t\tpos += nor * EPSILON1; \n\n\t\t\t// loop unpacks to surface_1(direct_1 + surface_2(direct_2 + surface_3(direct_3 + ... ) ) )\n\t\t\t// (same as recursive approach)\n\t\t\tfactional *= renderMaterial(ray.iden);\n\t\t\tsummed += factional * worldLighting(pos, nor, seed);\n\t\t\t// currently random weight, possibly change later to allow for shiny mats\n\t\t\tdir = cosDir_tuv(nor, seed);\n\t\t}\n\t\treturn summed;\n\t}\n//--</RENDERER>-----------------------------------------------------------------\n\n//--<IMAGE>---------------------------------------------------------------------\n\tmat4x3 cameraMatrix(float time){\n\t\t// this following 4 var system is temporary, will be turned into a proper set of uniforms with full control later.\n\n\t\tvec3  subjectPos\t= vec3(0.0, -0.3, 0.0); \n\t\tfloat yawAngle\t  = -0.2;// + sin(time*0.347)*0.05;\n\t\tfloat subjectXZDist = 2.0; \n\t\tfloat subjectYDist  = 0.6; // + sin(time*0.6)*0.1;\n\n\t\t//cameraPointingVec\n\t\tvec3 cpv = vec3(subjectXZDist*cos(yawAngle), subjectYDist, subjectXZDist*sin(yawAngle));\n\t\tvec3 cpv_n = normalize(cpv);\n\n\t\tvec3 x = normalize(vec3(cpv_n.z, 0.0, -cpv_n.x));\n\t\treturn mat4x3(subjectPos + cpv, x, cross(cpv_n,x), -cpv_n);\n\t}\n\n\t#define FOV_OFFSET 1.64 //=1/tan(0.5*FOV)\n\t#define FOCUS_DIST 1.7\n\t#define BLUR_AMOUNT 0.01\n\n\tvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\t\t\n\t\tvec3 col = vec3(0);\n\t\t{\n\t\t\t// AA within pixel\n\t\t\tvec2 uv = (2.0*(fragCoord+rand_2f_tuv(fragCoord)-0.5)\n\t\t\t\t-iResolution.xy)/min(iResolution.x, iResolution.y);\n\t\t\t// motion blur\n\t\t\tfloat time = iTime + rand_f_tuv(uv)*float(iFrame);\n\n\t\t\t//<Camera with DOF (random offset of rayOrg on uv plane)>\n\t\t\t\tmat4x3 camM = cameraMatrix(time);\n\t\t\t\t\n\t\t\t\tvec3 uv3 = normalize(vec3(uv, FOV_OFFSET));\n\n\t\t\t\tvec3 randOffset = BLUR_AMOUNT*vec3(2.0*rand_2f_tuv(uv)-1.0, 0);\n\t\t\t\tvec3 randDir\t= normalize(uv3*FOCUS_DIST - randOffset);\n\n\t\t\t\tvec3 rayOrg = camM[0] + randOffset.x*camM[1] + randOffset.y*camM[2];\n\t\t\t\tvec3 rayDir = normalize((uv3.x+randDir.x)*camM[1] + (uv3.y+randDir.y)*camM[2] + uv3.z*camM[3]);\n\t\t\t//</Camera>\n\n\t\t\tcol = render(rayOrg, normalize(rayDir), uv);\n\t\t}\n\t\t\n\t\tvec4 data = texture(iChannel0, fragCoord/iResolution.xy);\n\t\tfragColor = data + vec4(col,1.0);\n        if(iMouse.z > 0.9) fragColor = vec4(0.0);\n\t}\n//--</IMAGE>---------------------------------------------------------------------", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flfSRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 431]], "test": "untested"}
