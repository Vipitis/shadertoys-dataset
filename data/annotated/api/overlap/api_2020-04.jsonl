{"id": "tdsBD4", "name": "Polar of a Cardioid", "author": "mla", "description": "The polar curve of the mouse position for a cardioid.\n\n[url]https://en.wikipedia.org/wiki/Polar_curve[/url]", "tags": ["polar", "cardioid"], "likes": 9, "viewed": 418, "published": 3, "date": "1588282514", "time_retrieved": "2024-07-30T21:09:34.954991", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Polar of a Cardioid\n// Matthew Arcus, mla, 2020\n//\n// Given an implicit curve f(z) = 0, the polar curve for a point w is\n// polar(z) = p.x + p.y where p = grad(f,z)*(w-z)\n//\n// The intersection of the polar with the curve itself gives the points\n// on the curve whose tangents pass through p.\n//\n// Here we have a cardioid, drawn as a tangent envelope, and the polar of\n// the pointer position, drawn as an implicit curve - the tangents through the\n// pointer position meet the curve at its intersections with the polar.\n//\n// NEW FEATURE: (press 'g' to hide): a graph showing the distance of the\n// pointer position from tangent(t), where tangent(t) is the line between\n// (cos(t),sin(t)) and (cos(2t),sin(2t)) - zeros of this function are where\n// a line passes through the point. The vertical lines are at -PI and +PI\n// and there is a bogus zero at t = 0 in the middle (the two points\n// coincide).\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.1415927;\n\nfloat line(vec2 p, vec2 a, vec2 b) {\n  vec2 pa = p - a;\n  vec2 ba = b - a;\n  float h = dot(pa, ba) / dot(ba, ba);\n  float d = length(pa - ba * h);\n  return d;\n}\n\nconst int N = 108;\nfloat card0(vec2 z) {\n  // Draw the envelope\n  float d = 1e8;\n  float k = 2.0*PI/float(N);\n  float t = 2.0;\n  for (int i = 0; i < N; i++) {\n    float theta = float(i)*k;\n    vec2 p = vec2(cos(theta),sin(theta));\n    vec2 q = vec2(cos(t*theta),sin(t*theta));\n    d = min(d,line(z,p,q));\n  }\n  return d;\n}\n\n// Maybe use dual numbers here?\n// I did the diff for card by hand, but it got tedious for the polar,\n// so it's numeric all the way (it's more generic anyway).\n// Some macrology instead of higher order functions.\n#define GRAD(F,Z,EPS)                      \\\n  (vec2(F(Z+vec2(EPS,0))-F(Z-vec2(EPS,0)), \\\n        F(Z+vec2(0,EPS))-F(Z-vec2(0,EPS)))/(2.0*EPS))\n\nfloat card(vec2 p) {\n  // Implicit function for cardioid\n  float a = 1.0/3.0; // Line up with the unit circle\n  p.x += a;\n  float x = p.x, y = p.y;\n  float t = x*x+y*y;\n  return t*t - 4.0*a*x*t - 4.0*a*a*y*y;\n}\n\nvec2 cardgrad(vec2 z) {\n#define F(Z) (card(Z))\n  return GRAD(F,z,0.01);\n#undef F\n}\n\nfloat carddist(vec2 z) {\n  float d = card(z);\n  vec2 ds = cardgrad(z);\n  d /= length(ds);\n  return d;\n}\n\nfloat polar(vec2 z, vec2 w) {\n  float eps = 0.01;\n  vec2 e = vec2(eps,0);\n  return dot(vec2(1),cardgrad(z)*(w-z));\n}\n\nvec2 polargrad(vec2 z, vec2 w) {\n#define F(Z) (polar(Z,w))\n  return GRAD(F,z,0.01);\n#undef F\n}\n\nfloat polardist(vec2 z, vec2 w) {\n  float d = polar(z,w);\n  vec2 ds = polargrad(z,w);\n  return d/length(ds);\n}\n\nfloat line(vec3 p, vec3 l) {\n  return abs(dot(p,l)/(p.z*length(l.xy)));\n}\n\nfloat graph(vec2 z, vec2 w) {\n  // Draw curve, y = f(x), ie. f(x)-y = 0\n  float t = PI*z.x;\n  float y = 6.0*z.y;\n  vec3 p0 = vec3(cos(t),sin(t),1);\n  vec3 p1 = vec3(cos(2.0*t),sin(2.0*t),1);\n  vec3 l = vec3(sin(t)-sin(2.0*t),\n                cos(2.0*t)-cos(t),\n                cos(t)*sin(2.0*t)-sin(t)*cos(2.0*t));\n  return dot(vec3(w,1),l) - y;\n}\n\nvec2 graphgrad(vec2 z, vec2 w) {\n#define F(Z) (graph(Z,w))\n  return GRAD(F,z,0.01);\n#undef F\n}\n\nfloat graphdist(vec2 z, vec2 w) {\n  return graph(z,w)/length(graphgrad(z,w));\n}\n\nbool key(int code) {\n  return texelFetch(iChannel3, ivec2(code,2),0).x != 0.0;\n}\n\nconst int CHAR_G = 71;\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  int AA = 2;\n  vec3 col = vec3(0);\n  vec2 w;\n  if (iMouse.x > 0.0) w = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n  else w = cos(0.5*iTime-vec2(0,0.4*PI));\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 z = (2.0*(fragCoord+vec2(i,j)/float(AA))-iResolution.xy)/iResolution.y;\n      float ldist = graphdist(z,w);\n      float lmin = 0.002, lmax = max(0.003,fwidth(z.x));\n      float pmin = 0.015, pmax = max(0.02,2.0*fwidth(z.x));\n      vec3 c = vec3(0.75);\n      c.rg += 0.25*cos(2.0*PI*8.0*polardist(z,w));\n      c.b += 0.25*cos(2.0*PI*8.0*carddist(z));\n      c = mix(c,vec3(0.1),1.0-smoothstep(lmin,lmax,abs(card0(z))));\n      c = mix(c,vec3(0,0,1),1.0-smoothstep(lmin,lmax,abs(carddist(z))));\n      c = mix(c,vec3(1,0,0),1.0-smoothstep(lmin,lmax,abs(polardist(z,w))));\n      if (!key(CHAR_G)) {\n          c *= 0.8;\n          c = mix(c,vec3(1),1.0-smoothstep(lmin,lmax,abs(ldist)));\n          c = mix(c,vec3(1),1.0-smoothstep(lmin,lmax,line(z,vec2(-1,0),vec2(1,0))));\n          c = mix(c,vec3(1),1.0-smoothstep(lmin,lmax,line(z,vec2(-1,0),vec2(-1,1))));\n          c = mix(c,vec3(1),1.0-smoothstep(lmin,lmax,line(z,vec2(1,0),vec2(1,1))));\n      }\n      c = mix(c,vec3(0),1.0-smoothstep(pmin,pmax,distance(z,w)));\n      col += c;\n    }\n  }\n  col /= float(AA*AA);\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsBD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1104, 1104, 1140, 1140, 1264], [1285, 1285, 1306, 1329, 1588], [1949, 1949, 1969, 2005, 2159], [2245, 2245, 2269, 2269, 2348], [2350, 2350, 2379, 2379, 2466], [2564, 2564, 2597, 2597, 2674], [2676, 2676, 2704, 2704, 2749], [2751, 2751, 2780, 2822, 3098], [3196, 3196, 3229, 3229, 3275], [3277, 3277, 3297, 3297, 3357], [3383, 3383, 3435, 3435, 4792]], "test": "untested"}
{"id": "3dsBWN", "name": "Broken oil projector", "author": "sh1boot", "description": "Trying to use mipmaps to calculate median value by quantising to a threshold and taking whole-frame average as a count of values above/below that threshold.\n\nHaving some difficulty avoiding oscillation of the threshold value, though.", "tags": ["lava", "broken"], "likes": 4, "viewed": 441, "published": 3, "date": "1588273421", "time_retrieved": "2024-07-30T21:09:35.820677", "image_code": "vec4 pal(in vec4 i) {\n    // Convert saturated (ie., approximately binary) xyzw values\n    // into a 16-colour palette.  In this case, an approximation\n    // of the C64 colour palette.  Why the C64?  I do not know.\n    // I just wanted to do away with that RGB-filter look that\n    // comes out otherwise.\n    vec4 j = vec4(1.) - i;\n    return (j.x * j.y * j.z * j.w) * vec4(0., 0., 0., 0.)\n         + (j.x * j.y * j.z * i.w) * vec4(1., 1., 1., 0.)\n         + (j.x * j.y * i.z * j.w) * vec4(0., 1., 0., 0.)\n         + (j.x * j.y * i.z * i.w) * vec4(.5, 0., 0., 0.)\n         + (j.x * i.y * j.z * j.w) * vec4(.6, 1., .9, 0.)\n         + (j.x * i.y * j.z * i.w) * vec4(.7, .3, .7, 0.)\n         + (j.x * i.y * i.z * j.w) * vec4(0., .7, .4, 0.)\n         + (j.x * i.y * i.z * i.w) * vec4(0., 0., .6, 0.)\n         + (i.x * j.y * j.z * j.w) * vec4(.9, .9, .5, 0.)\n         + (i.x * j.y * j.z * i.w) * vec4(.8, .5, .3, 0.)\n         + (i.x * j.y * i.z * j.w) * vec4(1., .5, .5, 0.)\n         + (i.x * j.y * i.z * i.w) * vec4(.2, .2, .2, 0.)\n         + (i.x * i.y * j.z * j.w) * vec4(.5, .5, .5, 0.)\n         + (i.x * i.y * j.z * i.w) * vec4(.6, 1., .7, 0.)\n         + (i.x * i.y * i.z * j.w) * vec4(0., .5, 1., 0.)\n         + (i.x * i.y * i.z * i.w) * vec4(.8, .8, .8, 0.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n    vec4 c = texture(iChannel1, uv);\n    vec4 debug = texture(iChannel0, uv);\n    if (uv.x > 0.95) debug = textureLod(iChannel1, vec2(0.5), 100.5);\n    c = m.y > uv.y ? debug : c;\n    fragColor = pal(c);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Mostly a generic framebuffer feedback thing, with some\n// scribbling over the top.\n// To help edge towards rounded shapes, the smoothed and\n// sharpened buffer is fed back into this as well, so that\n// it gradually sharpens itself as it mixes and the shapes\n// should become progressively rounder from frame to frame\n// (if not for the stirring).\n\n\nvec4 funborder(sampler2D s, vec2 uv) {\n    if (any(notEqual(uv, fract(uv)))) {\n        uv -= 0.5;\n        float th = atan(uv.y, uv.x) + iTime;\n        return max(vec4(0), sin(vec4(0.4, -0.7, -0.9, 0.1) * th) - 0.6);\n    }\n    return texture(s, uv);\n}\n\n// Just some random perturbation of the coordinates to make things swirl.\nvec2 f(in vec2 uv) {\n    const vec2 centre = vec2(0.35, 0.35);\n    const float th = 0.003;\n    const float r = 0.9995;\n    float c = cos(th), s = sin(th);\n    uv = (uv - centre) * mat2(c, s, -s, c) * r + centre;\n    vec2 wiggle = vec2(sin(iTime + uv.y * 15.1), cos(uv.x * 14.1));\n    uv += wiggle * 0.002;\n\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iChannelResolution[0].xy;\n    vec2 vu = uv.yx;\n    uv = f(uv);\n    vu = f(vu).yx;\n    vec4 q = 0.5 * vec4(funborder(iChannel1, uv).xz,\n                        funborder(iChannel1, vu).yw).xzyw;\n    vec4 col = vec4(funborder(iChannel0, uv).xz,\n                    funborder(iChannel0, vu).yw).xzyw;\n\n    col = mix(col, q, 0.008);\n    \n    // Try to enlarge colour fringes a bit.\n    col *= vec4(1.005, 0.995, 0.995, 1.005);\n\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "buffer_d_code": "// Read a blurred Buffer A (blurring aims to represent surface tension),\n// and quantise it according to the average of the previous frame.\n// The idea is that the average of the result should seek the median\n// weight of Buffer A so that half the buffer is lit.\n// This is fed back into buffer A to encourage it to gradually gain\n// more defined edges and the expected weight, while still being able\n// to move and blur.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Sample the main framebuffer with a whole lot of smoothing.\n    // Simply using the LOD bias on its own produces horrible artefacts,\n    // so try to do the smoothing manually here.\n    // TODO: make a better approximation of Gaussian blur\n    vec4 colour = 0.50 * texture(iChannel0, uv, 6.5)\n                + 0.25 * texture(iChannel0, uv, 4.5)\n                + 0.16 * texture(iChannel0, uv, 2.5);\n                + 0.09 * texture(iChannel0, uv, 0.5);\n\n#if 0\n    // Take the average of the whole of the previous output;\n    // if this is low then too few pixels were 'set', and\n    // if it is high then too many pixels were 'set'.\n    vec4 threshold = textureLod(iChannel1, vec2(0.5), 100.5);\n#else\n    // Take the average of the whole of the current input;\n    // This divides the output into above and below average,\n    // which is not the same as the median, but I think it will\n    // seek the median more stably than above.\n    vec4 threshold = textureLod(iChannel0, vec2(0.5), 100.5);\n#endif\n    \n    // I didn't really think this through.  We need to make an informed\n    // guess at where the correct threshold should be, but it's fiddly\n    // trying to be stateful about previous guesses, so I just mashed\n    // the keyboard until the flashing and blinking didn't happened so\n    // much.\n    threshold = mix(threshold, vec4(0.7), 0.1);\n    colour = smoothstep(-0.005, 0.005, colour - threshold);\n\n    fragColor = colour;\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsBWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 306, 1264], [1267, 1267, 1324, 1324, 1613]], "test": "untested"}
{"id": "WslfW4", "name": "[TWITCH] Orb harvest", "author": "evvvvil", "description": "Orb harvest - Result of improvised live code session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["terrain", "demoscene", "abstract", "tree", "beam", "glow", "alien", "robot", "kifs", "spaceship", "structure", "industrial", "twitch", "improv"], "likes": 16, "viewed": 1074, "published": 3, "date": "1588270625", "time_retrieved": "2024-07-30T21:09:36.578157", "image_code": "// Orb harvest - Result of an improvised live code session on Twitch\n// Thankx to md10t, Balkhan and haptix for suggestions & help\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\n// https://www.twitch.tv/evvvvil_\n\n// \"Everyday the postman votes for me\" - Raymond Prunier\n\nvec2 z,v,e=vec2(.0035,-.0035); float f,t,tt,g,g2,b,bb,cc;vec3 np,bp,pp,cp,po,no,al,ld;//global vars. About as exciting as vegans talking about sausages.\nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);} //box primitive function. Box is the only primitve I hang out with, I find the others have too many angles and seem to have a multi-faced agenda.\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));} //rotate function. Short and sweet, just like a midget wrestler covered in Mapple syrup.\nvec2 fb( vec3 p, float s ) // fb \"fucking bit\" function make a base geometry which we use to make spaceship and central structures using more complex positions defined in mp\n{\n  vec2 h,t=vec2(bo(p,vec3(.5,.5,17)),5);  \n  h=vec2(bo(p,vec3(.7,.3,17)),6);  \n  t=t.x<h.x?t:h;\n  h=vec2(bo(p,vec3(.3,.7,17)),3);  \n  t=t.x<h.x?t:h;  \n  h=vec2(bo(abs(p)-vec3(1,0,0),vec3(0,0,17)),6);  \n  h.x=max(h.x,abs(cp.z)-8.);\n  g+=0.1/(0.1*h.x*h.x*(1000.-980.*sin(cp.z*.2+tt*2.)));\n  t=t.x<h.x?t:h;\n  if(s>0.) t.x=max(t.x,abs(cp.z)-8.),t.x=max(t.x,-cp.y);\n  return t;\n}\nvec2 mp( vec3 p )\n{ \n  p.xy*=r2(sin(p.z*.2+tt*.5)*.4);  \n  p.z=mod(p.z+tt*5.,40.)-20.;  \n  np=bp=pp=cp=p;\n  vec2 h,t=vec2(length(abs(p)-vec3(2.+cc,0,0))-3.,7.);\n  t.x=max(abs(t.x)-.2,-(abs(p.x)-2.-cc));  \n  h=vec2(length(abs(p)-vec3(2.+cc,0,0))-3.,6.);\n  h.x=max(abs(h.x)-.1,-(abs(p.x)-1.8-cc));\n  t=t.x<h.x?t:h;\n  t.x=max(t.x,-(length(p.yz)-1.8));  \n  h=vec2(bo(p,vec3(1.5)),3);  //MIDDLE BOX + CYLINDER\n  h.x=max(abs(h.x)-.1,-(length(p)-1.8));\n  t=t.x<h.x?t:h;\n  h=vec2(length(p.xy)-.2,6);  \n  t=t.x<h.x?t:h;     \n  bp.yz*=r2(0.785*2.);pp.yz*=r2(0.785*2.);//TENTACLES + STRUCTURE KIFS \n  np.x=abs(np.x)-8.;\n  bb=.5+.5*sin(np.x*.5-1.7)+np.x*.1;\n  np.z-=2.*sin(p.x*.3+tt*1.)*bb;\n  np.zy*=r2(tt);\n  for(int i=0;i<3;i++){\n    np=abs(np)-vec3(0,1.*bb,1.*bb);\n    bp=abs(bp)-vec3(0,5,.75);\n    bp.yz*=r2(.785);\n    bp.xz*=r2(sin(pp.z*.2)*.3);\n  } bp.y-=1.4;\n  b=abs(np.x*.8)*.1;\n  h=vec2(bo(np,vec3(5,.4-b,.4-b)),3);\n  h.x*=.5; t=t.x<h.x?t:h;\n  h=vec2(bo(np,vec3(5,.5-b,.25-b)),6);\n  h.x*=.5; t=t.x<h.x?t:h; \n  h=fb(bp,1.);h.x*=0.7;t=t.x<h.x?t:h;    //STRUCTURE\n  h=fb(abs(p*.5-vec3(0,1,0))-vec3(4,5,4),0.);h.x*=0.7;   //ROADS\n  t=t.x<h.x?t:h;    \n  h=vec2(length(abs(p)-vec3(3,0,0))-1.3,6.); //GLOWY SPHEREs \n  g2+=0.1/(0.1*h.x*h.x*(40.-39.*sin(cp.x*.2+tt*2.)));\n  t=t.x<h.x?t:h;  \n  h=vec2(p.y+10.+sin(cp.z*25.-tt*60.)*.03,8);//TERRAIN\n  h.x*=0.4;  t=t.x<h.x?t:h;  \n  float at=min(length(cp)-7.,7.)/7.;//TREES\n  b=ceil(cp.x*.1);\n  p.z=mod(p.z-tt*2.5,40.)-20.;\n  p.xz=abs(abs(p.xz)-10.)-8.+b*2.;  \n  p+=vec3(0,10.-b,0);\n  bb=.5+.5*sin(cp.y*.5+2.7-b);\n  h=vec2(bo(abs(p)-vec3(1.*bb,0,1.*bb),vec3(.2,5.-at*3.,.1)),6);\n  h.x*=.5; t=t.x<h.x?t:h;\n  h=vec2(.5*length(abs(p-vec3(0,5.-at*6.,0))-vec3(.5,0,.5))+.05,6);\n  g2+=.3/(0.1*h.x*h.x*150.);\n  t=t.x<h.x?t:h; t.x*=0.9;\n  return t;\n}\nvec2 tr( vec3 ro, vec3 rd ) // main trace / raycast / raymarching loop function \n{\n  vec2 h,t= vec2(.1); //Near plane because when it all started the hipsters still lived in Norwich and they only wore tweed.\n  for(int i=0;i<128;i++){ //Main loop de loop \n    h=mp(ro+rd*t.x); //Marching forward like any good fascist army: without any care for culture theft. (get distance to geom)\n    if(h.x<.0001||t.x>60.) break; //Conditional break we hit something or gone too far. Don't let the bastards break you down!\n    t.x+=h.x;t.y=h.y; //Huge step forward and remember material id. Let me hold the bottle of gin while you count the colours.\n  }\n  if(t.x>60.) t.y=0.;//If we've gone too far then we stop, you know, like Alexander The Great did when he realised his wife was sexting some Turkish bloke. (10 points whoever gets the reference)\n  return t;\n}\n// Rough shadertoy approximation of the bonzomatic noise texture by yx - https://www.shadertoy.com/view/tdlXW4\nvec4 texNoise(vec2 uv){ float f = 0.; f+=texture(iChannel0, uv*.125).r*.5;\n    f+=texture(iChannel0,uv*.25).r*.25;f+=texture(iChannel0,uv*.5).r*.125;\n    f+=texture(iChannel0,uv*1.).r*.125;f=pow(f,1.2);return vec4(f*.45+.05);\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )//2 lines above are a = ambient occlusion and s = sub surface scattering\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //get UVs, nothing fancy, \n  tt=mod(iTime+3.,62.82);  //Time variable, modulo'ed to avoid ugly artifact. Imagine moduloing your timeline, you would become a cry baby straight after dying a bitter old man. Christ, that's some fucking life you've lived, Steve.\n  cc=3.*(clamp(sin(tt*.75-1.8),-.5,.5)+.5);\n    vec3 ro=mix(vec3(1),vec3(-1,-1,1),ceil(sin(tt*.4+2.)))*vec3(sin(tt*.4-2.)*15.,2.,-20.),//Ro=ray origin=camera position We build camera right here broski. Gotta be able to see, to peep through the keyhole.\n  cw=normalize(vec3(0)-ro),cu=normalize(cross(cw,vec3(0,1,0))),cv=normalize(cross(cu,cw)),\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;//rd=ray direction (where the camera is pointing), co=final color, fo=fog color\n  ld=normalize(vec3(-.1,.5,-.2)); //ld=light direction\n  v=vec2(abs(atan(rd.x,rd.z)),rd.y);//make some polar uvs to make a fake spherical environment map\n  co=fo=vec3(.1,.3,.6)-length(uv)*.1+.5*texNoise(v*.5).r;//background is dark blueish with vignette and subtle vertical gradient based on ray direction y axis. \n  z=tr(ro,rd);t=z.x; //Trace the trace in the loop de loop. Sow those fucking ray seeds and reap them fucking pixels.\n  if(z.y>0.){ //Yeah we hit something, unlike you at your best man speech.\n    po=ro+rd*t; //Get ray pos, know where you at, be where you is.\n    no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x); //Make some fucking normals. You do the maths while I count how many instances of Holly Willoughby there really is.\n    al=vec3(1,.5,0);b=1.;  \n    if(z.y<5.) al=vec3(0); //material ID < 5 makes it black\n    if(z.y>5.) al=vec3(1); //material ID > 5 makes it white\n    if(z.y>6.) al=vec3(0,.2,.7);  \n    if(z.y>7.) al=vec3(1),b=0.;  \n    float dif=max(0.,dot(no,ld)), //Dumb as fuck diffuse lighting\n    fr=pow(1.+dot(no,rd),4.), //Fr=fresnel which adds background reflections on edges to composite geometry better\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),50.);//Sp=specular, stolen from Shane \n    co=mix(sp*b+mix(vec3(.8),vec3(1),abs(rd))*al*(a(.1)*a(.3)+.2)*(dif+s(7.)*.5),fo,min(fr,.3));//Building the final lighting result, compressing the fuck outta everything above into an RGB shit sandwich\n    co=mix(fo,co,exp(-.00002*t*t*t)); //Fog soften things, but it won't stop your mother from being unimpressed by your current girlfriend\n  } ro=.5+.5*sin(cp);\n  fragColor = vec4(pow(co+g*.2*mix(vec3(.7,.3,0),vec3(1,.1,0),ro)+g2*.2*mix(vec3(0,.1,.5),vec3(.1,.2,1),ro),vec3(.55)),1);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WslfW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[386, 453, 477, 477, 518], [519, 665, 682, 682, 725], [726, 815, 990, 990, 1365], [1366, 1366, 1385, 1385, 3142], [3143, 3143, 3225, 3225, 3991], [3992, 4103, 4126, 4126, 4330], [4420, 4420, 4549, 4549, 7127]], "test": "untested"}
{"id": "WdsfW4", "name": "The Ugly Duckling", "author": "darknoon", "description": "wip: duck from The Ugly Duckling", "tags": ["raymarching", "sdf", "duck"], "likes": 5, "viewed": 361, "published": 3, "date": "1588267272", "time_retrieved": "2024-07-30T21:09:37.670236", "image_code": "    \n\n// A list of useful distance function to simple primitives. All\n// these functions (except for ellipsoid) return an exact\n// euclidean distance, meaning they produce a better SDF than\n// what you'd get if you were constructing them from boolean\n// operations.\n//\n// More info here:\n//\n// https://iquilezles.org/articles/distfunctions\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n\n\n#define STEPS 70\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nfloat opCheapBendBox(in vec3 p, in vec3 b )\n{\n    const float k = 0.6; // or some other amount\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return sdBox(q, b);\n}\n\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n    \n    float a = 0.2*PI + 0.3*PI * sin(3.*iTime) - 0.12*sin(9. * iTime);\n    // Local coordinate for wooden duck\n    vec3 posP = vec3(rot2d(a) * pos.xy, pos.z);\n\n    // Head height\n    float hh = 1.2;\n\n    float head = sdSphere(posP - vec3(0.0, hh, 0.0), 0.3);\n\tres = opU( res, vec2(head, 2.2));\n\n    float bodyA = sdSphere(posP - vec3(0.0, 0.0, 0.0), 0.56);\n    float bodyB = sdSphere(posP - vec3(-0.55, 0.0, 0.0), 0.25);\n    float bodyC = sdBox(posP - vec3(-1.0, 0.244, 0.0), vec3(0.35, 0.04, 0.2)) - 0.04;\n    float body = bodyA;\n    body = sminCubic(body, bodyB, 1.8);\n    body = sminCubic(body, bodyC, 0.6);\n\tres = opU( res, vec2(body, 2.0));\n    \n    float neck = sdCylinder(posP - vec3(0.0, 0.5, 0.0), vec2(0.15, 0.5 *hh));\n\tres = opU( res, vec2(neck, 3.0));\n    \n    float bill = opCheapBendBox(posP - vec3(0.3, -0.04 + hh, 0.0), vec3(0.4, 0.04, 0.125)) - 0.03;\n    float pSc = 0.1;\n\n    // Local coordinate for bill\n    vec3 posB = posP - vec3(0.3,0.1 + hh, 0.0);\n    \n    vec3 posBPyr = vec3(rot2d(0.55 * PI) * posB.xy, posB.z);\n    float pyrBill = sdPyramid( 1./pSc*posBPyr, 2.0 )*pSc - 0.1;\n    bill = sminCubic(bill, pyrBill, 0.2);\n\tres = opU( res, vec2(bill, 4.0));\n    \n    //res = opU( res, vec2(sminCubic(pyr, s, 0.7), 2.0) );\n    \n    float bez = sdBezier(\n        vec3(0.4),\n        vec3(1.0, 0.0, 0.0),\n        vec3(1.0, -0.2, 0.0),\n        pos\n    ).x - 0.25;\n    //res = opU(res, vec2(bez, 1.0));\n    \n    \n    return res;\n}\n\n// https://iquilezles.org/articles/boxfunctions\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.5,0.5,-0.5), rd, vec3(2.0, 1.0,3.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<STEPS && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\n// Map material id to material\nvoid material(in float m, out vec3 col) {\n    \n}\n\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.2 + 0.18*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        //col = vec3(0.2);\n        col = 0.2 + 0.18*sin( m*2.0 + vec3(0.0,0.5,1.0) );\n        if( m<1.5 )\n        {\n            // project pixel footprint into the plane\n            vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n            float f = checkersGradBox( 5.0*pos.xz, 5.0*dpdx.xz, 5.0*dpdy.xz );\n            col = 0.15 + f*vec3(0.05);\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.2, 0.2, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 3.80*dif*vec3(1.30,1.00,0.70);\n        lin += 0.55*amb*vec3(0.40,0.60,1.15)*occ;\n        lin += 0.85*dom*vec3(0.40,0.60,1.30)*occ;\n        lin += 0.55*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 7.00*spe*vec3(1.10,0.90,0.70);\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime*1.5;\n\n    // camera\t\n    vec3 ta = vec3( 0.5, -0.4, -0.5 );\n    vec3 ro = ta + vec3( 4.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 4.5*sin(0.1*time + 6.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,2.5) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,2.5) );\n        vec3 rdy = ca * normalize( vec3(py,2.5) );\n        \n        // render\t\n        vec3 col = render( ro, rd, rdx, rdy );\n\n\t\t// gamma\n        //col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    vec3 col = tot;\n    \n    #if 0\n    col = log2(col) + 1.9;\n    col = 1. / (1. + exp2(-col) * 1.5);\n    #elif 0\n    // attempt at filmic blender\n    col = log2(col) + 5.;\n    col *= 0.25;\n    col = 1.031 / (1. + exp(5.3-col*8.7));\n    #else\n    col = sqrt(col);\n    #endif\n\n    \n    fragColor.rgb = col;\n}", "image_inputs": [], "common_code": "#define PI 3.141596\n\n// Portions copyright Inigo Quilez\n\n// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\n\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 pos, vec2 c, float ra)\n{\n    vec2 p = vec2( length(pos.xz), pos.y );\n    float l = length(p) - ra;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,ra) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n\n    // exact distance\n    #if 0\n    vec3 o = min(3.0*p - m, 0.0);\n    o = max(6.0*p - m*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n    #endif\n    \n    // exact distance\n    #if 1\n \tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n    #endif\n    \n    // bound, not exact\n    #if 0\n\treturn m*0.57735027;\n    #endif\n}\n\nfloat sdPyramid( in vec3 p, in float h )\n{\n    float m2 = h*h + 0.25;\n    \n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\t\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n}\n\n// http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) \n{\n    float a =     det(b0,b2);\n    float b = 2.0*det(b1,b0);\n    float d = 2.0*det(b2,b1);\n    float f = b*d - a*a;\n    vec2  d21 = b2-b1;\n    vec2  d10 = b1-b0;\n    vec2  d20 = b2-b0;\n    vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n    vec2  pp = -f*gf/dot(gf,gf);\n    vec2  d0p = b0-pp;\n    float ap = det(d0p,d20);\n    float bp = 2.0*det(d10,d0p);\n    float t = clamp( (ap+bp)/(2.0*a+b+d), 0.0 ,1.0 );\n    return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\nvec4 sdBezier( vec3 a, vec3 b, vec3 c, vec3 p )\n{\n\tvec3 w = normalize( cross( c-b, a-b ) );\n\tvec3 u = normalize( c-b );\n\tvec3 v =          ( cross( w, u ) );\n\n\tvec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n\tvec2 b2 = vec2( 0.0 );\n\tvec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n\tvec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n\tvec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n\n\treturn vec4( sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z), cp.z, length(cp.xy), p3.z );\n}\n\n////\n\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n\n// ---\n\n\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nmat2 rot2d(float a) {\n\treturn mat2( cos(a), sin(a),\n                -sin(a), cos(a));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsfW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[631, 631, 676, 676, 865], [868, 868, 893, 893, 2376], [2378, 2426, 2477, 2477, 2682], [2711, 2711, 2751, 2751, 3532], [3535, 3580, 3658, 3681, 4072], [4074, 4120, 4152, 4152, 4683], [4686, 4686, 4728, 4728, 5044], [5046, 5098, 5162, 5183, 5416], [5418, 5449, 5490, 5490, 5497], [5500, 5500, 5565, 5565, 7561], [7563, 7563, 7615, 7615, 7792]], "test": "untested"}
{"id": "tdffDN", "name": "Video Gas", "author": "michael0884", "description": "This is cooler than the chain tbh", "tags": ["particles", "aabb", "sort"], "likes": 65, "viewed": 1605, "published": 3, "date": "1588262780", "time_retrieved": "2024-07-30T21:09:38.842103", "image_code": "// Fork of \"Connected particle chain image\" by michael0884. https://shadertoy.com/view/3dXfDN\n// 2020-04-30 15:21:35\n\n// Fork of \"Large scale flocking\" by michael0884. https://shadertoy.com/view/tsScRG\n// 2020-04-30 07:24:31\n\nivec4 get(ivec2 p)\n{\n    return floatBitsToInt(texel(ch0, p));\n}\n\nivec4 getb(int id)\n{\n    return floatBitsToInt(texel(ch2, i2xy(id)));\n}\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nvec3 imageC(vec2 p)\n{\n    return texture(ch3, vec2(1., 1.)*p/size).xyz;\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(p, getParticle(id).xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n     N = ivec2(prop*iResolution.xy);\n    tot_n = N.x*N.y;\n    ivec4 nb = get(ivec2(pos));\n \tvec4 p0 = getParticle(nb.x);\n   \n    fragColor = vec4(0.,0,0,1);\n    for(int i = 0; i < 4; i++)\n    {\n       vec4 p0 = getParticle(nb[i]);\n    \tfragColor.xyz += 0.3*(0.85+0.25*imageC(p0.xy))\n            \t\t\t//*sin(vec3(1,2,3)*length(p0.zw))\n            \t\t\t*exp(-0.15*distance(p0.xy, pos));\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define dt 0.4\n#define prop 0.5\n\nivec2 N;\nint tot_n;\n\nfloat hash11(float p)\n{\n    p = fract(p * 15.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p) - 0.5;\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nconst int k = 1664525;  \n\nivec4 hash( ivec4 x )\n{\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    return ivec4(x);\n}\n\nivec2 i2xy(int id)\n{\n    return ivec2(id%N.x, id/N.x);\n}\n\nint xy2i(ivec2 p)\n{\n    return p.x + p.y*N.x;\n}\n\nivec2 cross_distribution(int i)\n{\n    return (1<<(i/4)) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 );\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}", "buffer_a_code": "//particle buffer\n\nint cid;\n\nivec4 get(int id)\n{\n    return floatBitsToInt(texel(ch0, i2xy(id)));\n}\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat F(float d)\n{\n    return (0.15*exp(-0.1*d) - 2.*exp(-0.2*d));\n}\n\nfloat imageV(vec2 p)\n{\n    return 1.-2.*texture(ch2, vec2(1., 1.)*p/size).x;\n}\n\nvec2 imageF(vec2 p)\n{\n    vec3 d = vec3(-1,0,1);\n    return vec2(imageV(p+d.zy) - imageV(p+d.xy), imageV(p+d.yz) - imageV(p+d.yx));\n}\n\nvec2 Fv(vec4 p0, int pid)\n{\n    if(pid < 0 || pid >= tot_n || pid == cid) return vec2(0); \n   \tvec4 p1 = getParticle(pid);\n    float d= distance(p0.xy, p1.xy);\n    vec2 dv = (p1.zw - p0.zw);\n    float dotv = dot(normalize(p1.xy-p0.xy), normalize(dv)); //divergence correction\n    vec2 antidivergence = 0.*dv*abs(dotv)*exp(-0.5*d);\n    vec2 viscosity = 0.25*dv*exp(-0.1*d);\n    vec2 pressure = normalize(p1.xy-p0.xy)*F(d);\n    return viscosity + pressure + antidivergence;\n}\n\nfloat irad;\n\nvec2 Fspring(vec4 p0, int pid)\n{\n    if(pid < 0 || pid >= tot_n || pid == cid) return vec2(0); \n   \tvec4 p1 = getParticle(pid);\n    vec2 interaction = normalize(p1.xy-p0.xy)*(distance(p1.xy,p0.xy)- 2.*PI*irad/float(tot_n) - 4.*tanh(0.1*iTime));\n    return interaction;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    N = ivec2(prop*iResolution.xy);\n    tot_n = N.x*N.y;\n    if(p.x < N.x && p.y < N.y)\n    {\n        irad = 0.3*size.y;\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch1, pos);\n        int id = xy2i(p);\n        cid = id;\n        \n        //this pixel value\n        if(iFrame<10)\n        {\n            float t = 2.*PI*float(id)/float(tot_n);\n            U.xy = size*hash22(3.14159*pos);\n\t\t\tU.zw = 1.*(hash22(3.14159*pos) - 0.5);\n      \t\treturn;\n        }\n        \n        //neighbors\n   \t\tivec4 cp = get(id);\n   \t  \n        vec2 F = Fv(U, cp.x) +\n            \t Fv(U, cp.y) +\n            \t Fv(U, cp.z) +\n                 Fv(U, cp.w) +\n            \t -20.*imageF(U.xy);\n        \n        if(iMouse.z > 0.) \n        {\n            float d = distance(iMouse.xy, U.xy);\n            F += 2.*normalize(iMouse.xy - U.xy)/(sqrt(d)+2.);\n        }\n        \n        U.zw = 15.*tanh((F*dt + U.zw)/15.) ;\n        U.xy += U.zw*dt;\n        \n        //border conditions\n        if(size.x - U.x < 2.) U.z = -abs(U.z);\n        if(U.x < 2.) U.z = abs(U.z);\n        if(size.y - U.y < 2.) U.w = -abs(U.w);\n        if(U.y < 2.) U.w = abs(U.w);\n \n        \n    }\n    else discard;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//sorting closest 4 particles in axis directions that make a bounding box\n//only in particle space, texture buffer not needed\n\nivec4 get(int id)\n{\n    return floatBitsToInt(texel(ch0, i2xy(id)));\n}\n\nvec4 save(ivec4 v)\n{\n    return intBitsToFloat(v);\n}\n\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //this particle position\nint tid;\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\n//insertion sort\nvoid sort(int utemp)\n{\n    if(utemp == tid || utemp < 0) return;\n     \n   \tvec4 part = getParticle(utemp);\n    vec2 dx = part.xy - pos;\n    float dtemp = length(dx);\n    //sorting\n    if(dx.x > abs(dx.y))\n    {\n        if(d.x > dtemp) \n        {\n            d.x = dtemp;\n        \tu.x = utemp;\n        }\n    }\n    else if(dx.x < -abs(dx.y))\n    {\n        if(d.y > dtemp) \n        {\n            d.y = dtemp;\n        \tu.y = utemp;\n        }\n    }\n    else if(dx.y > abs(dx.x))\n    {\n        if(d.z > dtemp) \n        {\n            d.z = dtemp;\n        \tu.z = utemp;\n        }\n    }\n    else if(d.w > dtemp) \n    {\n        d.w = dtemp;\n        u.w = utemp;\n    }\n}\n\nvoid sortneighbor(int id)\n{\n    ivec4 nb = get(id);\n    for(int j = 0; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{  \n    ivec2 p = ivec2(fragCoord);\n    N = ivec2(prop*iResolution.xy);\n    tot_n = N.x*N.y;\n    if(p.x > N.x || p.y > N.y) discard;\n    \n    int id = xy2i(p);\n     \n    u = ivec4(-1); d = vec4(1e10); \n   \n    tid = id;\n    pos = getParticle(id).xy;\n    \n    sortneighbor(id); \n    \n    for(int i = 0; i < 8; i++)\n    {\n        sort(hash(ivec4(p, iFrame, i)).x%tot_n); //random sort    \n    }\n    \n    ivec4 nb = get(id);\n    for(int i = 0; i < 4; i++)\n    {\n        sortneighbor(nb[i]); \n    }\n    \n    if( any(lessThan(u, ivec4(-1))) || any(greaterThan(u, ivec4(tot_n))))\n    {\n        u = ivec4(0);\n    }\n    \n    \n    U = save(u);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//4th order voronoi particle tracking \n\nivec4 get(ivec2 p)\n{\n    return floatBitsToInt(texel(ch0, p));\n}\n\nvec4 save(ivec4 v)\n{\n    return intBitsToFloat(v);\n}\n\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //pixel position\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(p, getParticle(id).xy);\n}\n\n//insertion sort\nvoid sort(int utemp)\n{\n    if(utemp <0) return; \n   \tfloat dtemp = particleDistance(utemp, pos);\n    //sorting\n    if(d.x > dtemp)\n    {\n        d = vec4(dtemp, d.xyz);\n        u = ivec4(utemp, u.xyz);\n    }\n    else if(d.y > dtemp && dtemp > d.x)\n    {\n        d.yzw = vec3(dtemp, d.yz);\n        u.yzw = ivec3(utemp, u.yz);\n    }\n    else if(d.z > dtemp && dtemp > d.y)\n    {\n        d.zw = vec2(dtemp, d.z);\n        u.zw = ivec2(utemp, u.z);\n    }\n    else if(d.w > dtemp && dtemp > d.z)\n    {\n        d.w = dtemp;\n        u.w = utemp;\n    }\n}\n\nvoid sortpos(ivec2 p)\n{\n    ivec4 nb = get(p);\n    for(int j = 0; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{\n    pos = fragCoord;\n     N = ivec2(prop*iResolution.xy);\n    tot_n = N.x*N.y;\n    ivec2 p = ivec2(pos);\n     \n    u = ivec4(-1); d = vec4(1e10); \n   \n    //jump flood sorting \n    sortpos(p); //resort this position\n    for(int i = 0; i < 8; i++)\n    {\n        sortpos(p+cross_distribution(i)); \n    }\n    \n    for(int i = 0; i < 4; i++)\n    {\n        sort(hash(ivec4(p, iFrame, i)).x%tot_n); //random sort    \n    }\n    \n    if( any(lessThan(u, ivec4(-1))) || any(greaterThan(u, ivec4(tot_n))) )\n    {\n        u = ivec4(0);\n    }\n    \n    U = save(u);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdffDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[226, 226, 246, 246, 290], [292, 292, 312, 312, 363], [365, 365, 391, 391, 426], [428, 428, 449, 449, 501], [503, 503, 543, 543, 589], [591, 591, 642, 642, 1031]], "test": "untested"}
{"id": "tsXBDN", "name": "Connected particle chain Video", "author": "michael0884", "description": "Fabrice here you go.", "tags": ["particles", "aabb", "sort"], "likes": 18, "viewed": 555, "published": 3, "date": "1588260215", "time_retrieved": "2024-07-30T21:09:39.606060", "image_code": "// Fork of \"Connected particle chain image\" by michael0884. https://shadertoy.com/view/3dXfDN\n// 2020-04-30 15:21:35\n\n// Fork of \"Large scale flocking\" by michael0884. https://shadertoy.com/view/tsScRG\n// 2020-04-30 07:24:31\n\nivec4 get(ivec2 p)\n{\n    return floatBitsToInt(texel(ch0, p));\n}\n\nivec4 getb(int id)\n{\n    return floatBitsToInt(texel(ch2, i2xy(id)));\n}\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nvec3 imageC(vec2 p)\n{\n    return texture(ch3, vec2(1., 1.)*p/size).xyz;\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return sdSegment(p, getParticle(id).xy, getParticle((id+1)%tot_n).xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    ivec4 nb = get(ivec2(pos));\n \tvec4 p0 = getParticle(nb.x);\n   \n    \n    float d0 = 0.;\n    \n    d0 += 0.24/(1.+0.3*particleDistance(nb[0], pos));\n    d0 += 0.24/(1.+0.3*particleDistance(nb[1], pos));\n    \n    vec3 v = imageC(pos);\n    \n    fragColor.xyz = 2.5*v*sin(vec3(1,1,3)*d0);\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define N ivec2(50,50)\n#define dt 1.\n\n\nconst int tot_n = N.x*N.y;\n\nfloat hash11(float p)\n{\n    p = fract(p * 15.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p) - 0.5;\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nconst int k = 1664525;  \n\nivec4 hash( ivec4 x )\n{\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    return ivec4(x);\n}\n\nivec2 i2xy(int id)\n{\n    return ivec2(id%N.x, id/N.x);\n}\n\nint xy2i(ivec2 p)\n{\n    return p.x + p.y*N.x;\n}\n\nivec2 cross_distribution(int i)\n{\n    return (1<<(i/4)) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 );\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}", "buffer_a_code": "//particle buffer\n\nint cid;\n\nivec4 get(int id)\n{\n    return floatBitsToInt(texel(ch0, i2xy(id)));\n}\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat F(float d)\n{\n    return tanh(0.1*iTime)*(1.*exp(-0.1*d) - 5.*exp(-0.2*d));\n}\n\nfloat imageV(vec2 p)\n{\n    return 1.-2.*texture(ch2, vec2(1., 1.)*p/size).x;\n}\n\nvec2 imageF(vec2 p)\n{\n    vec3 d = vec3(-1,0,1);\n    return vec2(imageV(p+d.zy) - imageV(p+d.xy), imageV(p+d.yz) - imageV(p+d.yx));\n}\n\nvec2 Fv(vec4 p0, int pid)\n{\n    if(pid < 0 || pid >= tot_n || pid == cid) return vec2(0); \n   \tvec4 p1 = getParticle(pid);\n    vec2 flocking_force = 0.3*(p1.zw - p0.zw)/(1.+1.*distance(p1.xy,p0.xy));\n    vec2 interaction = normalize(p1.xy-p0.xy)*F(distance(p1.xy,p0.xy));\n    return flocking_force + interaction;\n}\n\nfloat irad;\n\nvec2 Fspring(vec4 p0, int pid)\n{\n    if(pid < 0 || pid >= tot_n || pid == cid) return vec2(0); \n   \tvec4 p1 = getParticle(pid);\n    vec2 interaction = normalize(p1.xy-p0.xy)*(distance(p1.xy,p0.xy)- 2.*PI*irad/float(tot_n) - 4.*tanh(0.1*iTime));\n    return interaction;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    if(p.x < N.x && p.y < N.y)\n    {\n        irad = 0.3*size.y;\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch1, pos);\n        int id = xy2i(p);\n        cid = id;\n        \n        //this pixel value\n        if(iFrame<10)\n        {\n            float t = 2.*PI*float(id)/float(tot_n);\n            U.xy = size*vec2(0.3,0.5) + irad*(1.+0.4*sin(20.*t))*vec2(cos(t),sin(t));\n\t\t\tU.zw = 1.*(hash22(3.14159*pos) - 0.5);\n      \t\treturn;\n        }\n        \n        //neighbors\n   \t\tivec4 cp = get(id);\n   \t  \n        vec2 F = Fv(U, cp.x) +\n            \t Fv(U, cp.y) +\n            \t Fv(U, cp.z) +\n                 Fv(U, cp.w) +\n                 Fspring(U, (id + 1)%tot_n) +\n                 Fspring(U, (id - 1)%tot_n) +\n            \t -4.*imageF(U.xy);\n        \n        if(iMouse.z > 0.) \n        {\n            float d = distance(iMouse.xy, U.xy);\n            F += 2.*normalize(iMouse.xy - U.xy)/(sqrt(d)+2.);\n        }\n        \n        U.zw += (-0.002*U.zw + 0.5*F)*dt;\n        U.xy += U.zw*dt;\n        \n        //border conditions\n        if(size.x - U.x < 2.) U.z = -abs(U.z);\n        if(U.x < 2.) U.z = abs(U.z);\n        if(size.y - U.y < 2.) U.w = -abs(U.w);\n        if(U.y < 2.) U.w = abs(U.w);\n \n        \n    }\n    else discard;\n}", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//sorting closest 4 particles in axis directions that make a bounding box\n//only in particle space, texture buffer not needed\n\nivec4 get(int id)\n{\n    return floatBitsToInt(texel(ch0, i2xy(id)));\n}\n\nvec4 save(ivec4 v)\n{\n    return intBitsToFloat(v);\n}\n\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //this particle position\nint tid;\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\n//insertion sort\nvoid sort(int utemp)\n{\n    if(utemp == tid || utemp < 0) return;\n       \n   \tvec4 part = getParticle(utemp);\n    vec2 dx = part.xy - pos;\n    float dtemp = length(dx);\n    //sorting\n    if(dx.x > abs(dx.y))\n    {\n        if(d.x > dtemp) \n        {\n            d.x = dtemp;\n        \tu.x = utemp;\n        }\n    }\n    else if(dx.x < -abs(dx.y))\n    {\n        if(d.y > dtemp) \n        {\n            d.y = dtemp;\n        \tu.y = utemp;\n        }\n    }\n    else if(dx.y > abs(dx.x))\n    {\n        if(d.z > dtemp) \n        {\n            d.z = dtemp;\n        \tu.z = utemp;\n        }\n    }\n    else if(d.w > dtemp) \n    {\n        d.w = dtemp;\n        u.w = utemp;\n    }\n}\n\nvoid sortneighbor(int id)\n{\n    ivec4 nb = get(id);\n    for(int j = 0; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{  \n    ivec2 p = ivec2(fragCoord);\n    \n    if(p.x > N.x || p.y > N.y) discard;\n    \n    int id = xy2i(p);\n     \n    u = ivec4(-1); d = vec4(1e10); \n   \n    tid = id;\n    pos = getParticle(id).xy;\n    \n    sortneighbor(id); \n    \n    for(int i = 0; i < 8; i++)\n    {\n        sort(hash(ivec4(p, iFrame, i)).x%tot_n); //random sort    \n    }\n    \n    ivec4 nb = get(id);\n    for(int i = 0; i < 4; i++)\n    {\n        sortneighbor(nb[i]); \n    }\n    \n    if( any(lessThan(u, ivec4(-1))) || any(greaterThan(u, ivec4(tot_n))))\n    {\n        u = ivec4(0);\n    }\n    \n    \n    U = save(u);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//4th order voronoi particle tracking \n\nivec4 get(ivec2 p)\n{\n    return floatBitsToInt(texel(ch0, p));\n}\n\nvec4 save(ivec4 v)\n{\n    return intBitsToFloat(v);\n}\n\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //pixel position\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return sdSegment(p, getParticle(id).xy, getParticle((id+1)%tot_n).xy);\n}\n\n//insertion sort\nvoid sort(int utemp)\n{\n    if(utemp <0) return; \n   \tfloat dtemp = particleDistance(utemp, pos);\n    //sorting\n    if(d.x > dtemp)\n    {\n        d = vec4(dtemp, d.xyz);\n        u = ivec4(utemp, u.xyz);\n    }\n    else if(d.y > dtemp && dtemp > d.x)\n    {\n        d.yzw = vec3(dtemp, d.yz);\n        u.yzw = ivec3(utemp, u.yz);\n    }\n    else if(d.z > dtemp && dtemp > d.y)\n    {\n        d.zw = vec2(dtemp, d.z);\n        u.zw = ivec2(utemp, u.z);\n    }\n    else if(d.w > dtemp && dtemp > d.z)\n    {\n        d.w = dtemp;\n        u.w = utemp;\n    }\n}\n\nvoid sortpos(ivec2 p)\n{\n    ivec4 nb = get(p);\n    for(int j = 0; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{\n    pos = fragCoord;\n    ivec2 p = ivec2(pos);\n     \n    u = ivec4(-1); d = vec4(1e10); \n   \n    //jump flood sorting \n    sortpos(p); //resort this position\n    for(int i = 0; i < 8; i++)\n    {\n        sortpos(p+cross_distribution(i)); \n    }\n    \n    for(int i = 0; i < 4; i++)\n    {\n        sort(hash(ivec4(p, iFrame, i)).x%tot_n); //random sort    \n    }\n    \n    if( any(lessThan(u, ivec4(-1))) || any(greaterThan(u, ivec4(tot_n))) )\n    {\n        u = ivec4(0);\n    }\n    \n    U = save(u);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXBDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[226, 226, 246, 246, 290], [292, 292, 312, 312, 363], [365, 365, 391, 391, 426], [428, 428, 449, 449, 501], [503, 503, 543, 543, 620], [622, 622, 673, 673, 962]], "test": "untested"}
{"id": "wdByRw", "name": "tribute to FF7 - cloud's sword", "author": "Cewein", "description": "the new remake made me look at another angle to the sword, so here it is.\n\nMusic credits: Final Fantasy OST, Nobuo Uematsu & Masashi Hamauzu ", "tags": ["reflection", "cloud", "music", "texture", "start", "raymaching", "sword", "metal", "finalfantasy", "ff7"], "likes": 5, "viewed": 713, "published": 3, "date": "1588251251", "time_retrieved": "2024-07-30T21:09:40.478727", "image_code": "// a small tribute to FF7 : Cloud's buster sword\n// fell free to look around, there is mouse controle\n//\n// shader made by cewein\n//\n\n\n// signed distance functions\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nmat2 rot(in float a)\n{\n    a *= 0.0174533;\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 sdSword(vec3 pos)\n{\n    //sword\n    float sword;\n    vec3 sp = pos;\n    sp.y += 1.1; sp.xy *= rot(26.0);\n    \n    //blade\n    float blade = sdBox(sp, vec3(0.5,2.5,0.03));\n    float unBlade = sdBox(sp, vec3(0.5,2.5,0.025));\n    float sharpen = dot(sp + vec3(0.,1.3,0.), normalize(vec3(0.75,-0.7,8.0)));\n    unBlade = max(unBlade,sharpen);\n    sharpen = dot(sp + vec3(-.45,0.,0.), normalize(vec3(1,0.0,11.)));\n    unBlade = max(unBlade,sharpen);\n    \n    sharpen = dot(sp + vec3(0.,1.1,0.), normalize(vec3(0.75,-0.7,0.0)));\n    blade = max(blade,sharpen);\n    sharpen = dot(sp + vec3(-.25,0.,0.), normalize(vec3(1,0.0,0.)));\n    blade = max(blade,sharpen);\n    \n    \n    //blade hole\n    float hole1 = length(sp - vec3(0.,2.2,0.)) - 0.1;\n    float hole2 = length(sp - vec3(0.,1.9,0.)) - 0.1;\n    unBlade = max(unBlade,-hole1);\n    unBlade = max(unBlade,-hole2);\n    blade = max(blade,-hole1);\n    blade = max(blade,-hole2);\n    \n    sword = blade;\n    vec3 res = vec3(sword, 1.0,1.);\n    if(unBlade < blade)\n    {\n        sword = min(sword, unBlade);\n    \tres = vec3(sword, 4.0,1.);\n    }\n        \n    //guard\n    float guard = sdBox(sp - vec3(0.,2.5,0.), vec3(0.6,0.08,0.08));\n    float rm = sdBox(sp - vec3(0.,2.5,0.15), vec3(0.62,0.06,0.08));\n    guard = max(-rm,guard);\n    rm = sdBox(sp - vec3(0.,2.5,-.15), vec3(0.62,0.06,0.08));\n    guard = max(-rm,guard);\n    rm = sdBox(sp - vec3(.78,2.5,0.), vec3(0.2,0.06,0.08));\n    guard = max(-rm,guard);\n    rm = sdBox(sp - vec3(-.78,2.5,0.), vec3(0.2,0.06,0.08));\n    guard = max(-rm,guard);\n\tif( guard<sword)\n    {\n     \tsword = min(sword,guard);\n        res = vec3(sword, 2.0,-1.);\n    }\n    \n    //guard bolt\n    vec3 bp = sp;\n    bp.yz *= rot(90.0);\n    float bolts = sdVerticalCapsule(bp - vec3(-0.5,-.07,2.5), .14, 0.03);\n    float b = sdVerticalCapsule(bp - vec3(-0.3,-.07,2.5), .14, 0.03);\n    bolts = min(bolts, b);\n    b = sdVerticalCapsule(bp - vec3(-0.1,-.07,2.5), .14, 0.03);\n    bolts = min(bolts, b);\n    b = sdVerticalCapsule(bp - vec3(0.1,-.07,2.5), .14, 0.03);\n    bolts = min(bolts, b);\n    b = sdVerticalCapsule(bp - vec3(0.3,-.07,2.5), .14, 0.03);\n    bolts = min(bolts, b);\n    b = sdVerticalCapsule(bp - vec3(0.5,-.07,2.5), .14, 0.03);\n    bolts = min(bolts, b);\n    \n    if(bolts < sword)\n    {\n    \tsword = min(sword,bolts);\n    \tres = vec3(sword, 4.0,0.3);\n    }\n    \n    //handle\n   \tfloat handle = sdCappedCylinder(sp - vec3(0.,3.0,0.), 0.08, 0.4);\n    float handleDown = sdCappedCylinder(sp - vec3(0.,2.635,0.), 0.1, 0.05);\n    float handleUp = sdCappedCylinder(sp - vec3(0.,3.44,0.), 0.1, 0.05);\n    handleDown = min(handleDown,handleUp);   \n\tif(handle<sword)\n    {\n     \tsword = min(sword,handle);\n        res = vec3(sword, 3.0,-1.);\n    }\n    \n    if(handleDown<sword)\n    {\n        sword= min(sword,handleDown);\n        res = vec3(sword, 4.0,.3);\n    }\n    \n    //health ball\n    float sph = length(sp - vec3(0.,2.2,0.)) - .09;\n    if(sph  == sword)\n    {\n    \tsword = min(sword, sph);\n    \tres = vec3(sword, 5.0, -1.);\n    }\n    \n    return res;\n}\n\n\n//Mapping function\nvec3 map(in vec3 pos) \n{\n    //tm is the vec3(distance, id mat, boolean for reflection)\n    vec3 tm = sdSword(pos);\n    float flr = pos.y + 2.1;\n \tif(flr<tm.x)\n    {\n        tm.x = flr;\n        tm.y = 6.;\n        tm.z = -1.;\n    }\n    \n    return tm;\n\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(0.0001,0.);\n    return normalize(vec3(map(pos + e.xyy).x-map(pos-e.xyy).x,\n                          map(pos + e.yxy).x-map(pos-e.yxy).x,\n                          map(pos + e.yyx).x-map(pos-e.yyx).x)\n                    );\n}\n\n//ray marching algorithms\nvec3 castRay(in vec3 ro, in vec3 rd)\n{\n    vec3 tm = vec3(0., -1., -1.);\n    vec3 vc = vec3(0.);\n    for(int i = 0; i<120; i++)\n    {\n        vec3 pos = ro + tm.x*rd;\n        vec3 h = map(pos);\n        if(h.x < 0.0001) break;\n        tm.y = h.y;\n        tm.x += h.x;\n        tm.z = h.z;\n        if(tm.x > 200.)\n        {\n            tm.y = -1.; \n            break;\n        }\n        \n    }\n        \n    return tm;\n}\n\nvec3 hash33(vec3 p){\n    p  = fract(p * vec3(5.3983, 5.4427, 6.9371));\n    p += dot(p.yzx, p.xyz  + vec3(21.5351, 14.3137, 15.3219));\n    return fract(vec3(p.x * p.z * 95.4337, p.x * p.y * 97.597, p.y * p.z * 93.8365));\n}\n\nfloat tri(in float x)\n{\n    return abs(fract(x)-.5);\n}\n\n//thanks for the stars, check this shader out, it contain midgar\n//https://www.shadertoy.com/view/XllXWN\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    \n    //Triangular deformation (used to break sphere intersection pattterns)\n    p.x += (tri(p.z*50.)+tri(p.y*50.))*0.006;\n    p.y += (tri(p.z*50.)+tri(p.x*50.))*0.006;\n    p.z += (tri(p.x*50.)+tri(p.y*50.))*0.006;\n    \n\tfor (float i=0.;i<2.;i++)\n    {\n        vec3 q = fract(p*250.)-0.5;\n        vec3 id = floor(p*250.);\n        float rn = hash33(id).z;\n        float c2 = 1.-smoothstep(-0.2,.4,length(q));\n        c2 *= step(rn,0.005+i*0.014);\n        c += c2*(mix(vec3(1.0,0.75,0.5),vec3(0.85,0.9,1.),rn*30.)*0.5 + 0.5);\n        p *= 1.15;\n    }\n    return c*c*smoothstep(-0.1, 0., p.y);\n}\n\nvec3 render(in vec3 ro, in vec3 rd, vec2 uv)\n{\n    float mult = 1.0;\n    vec3 col = stars(rd) * smoothstep(0.,.5, dot(rd,vec3(0.,1.,0.)));\n    vec3 density;\n    \n   \tvec3 tm = castRay(ro,rd);\n\n    vec3 pos = ro + tm.x*rd;\n    vec3 mat = vec3(0.01)* texture(iChannel2, (10. + pos.xz)/100.).x * smoothstep(10.,0.,length(pos));\n    vec3 sunDir = normalize(vec3( 1.0,0.5,.6));\n    \n    if(tm.y < 1.5)\n    {\n        vec3 pos = ro + tm.x*rd;\n        mat = vec3(0.025) * texture(iChannel0,pos.xy).x;\n    }\n    else if(tm.y < 2.5)\n    {\n        mat = vec3(.01);\n    }\n    else if(tm.y < 3.5)\n    {\n        mat = vec3(0.35, 0.20, 0.05)* texture(iChannel1,pos.xy).xyy;\n    }\n    else if(tm.y < 4.5)\n    {\n        mat = vec3(0.1);\n    }\n    else if(tm.y < 5.5)\n    {\n        mat = vec3(0.0,0.04,0.);   \n    }\n    \n    if(tm.y > 0.)\n    {\n        vec3 density;\n        vec3 norm = calcNormal(pos);\n        \n        vec3 volPos = vec3(0.95,.9,0.);\n        \n        vec3 tmp;\n        \n       \tfloat sunDif = clamp( dot(norm, sunDir),0.,1.);\n        float skyDif = clamp( 0.5 + 0.5*dot(norm, vec3(0.,1.,0.)),0.,1.);\n        float sunSha = step(castRay(pos + norm * 0.001, sunDir).y,0.);\n        float bouceDif = clamp( 0.5 + 0.5*dot(norm, vec3(0.,-1.,0.)),0.,1.);\n        \n        col =  mat * vec3(2.0)* sunDif * sunSha;\n        col += mat * vec3(0.5) * skyDif;        \n        col += mat * vec3(0.1) * bouceDif;\n        \n        if(tm.z > 0.)\n        {\n            vec3 ref = reflect(rd, norm);\n            vec3 spe = vec3(smoothstep(0.0,0.35,clamp( dot(ref, sunDir),0.,1.)));\n            float fre = clamp(1.0+dot(rd,norm), 0.,1.0);\n            spe *= mat + (1.0-mat)*pow(fre,5.0);\n            spe *= 100. * tm.z;\n            \n            col += mat*spe*sunSha;\n        }\n        \n    }\n\n    col += density;\n    \n    \n    col = pow(col, vec3(0.4545));\n    \n    return col;\n}\n \nvec3 getDir(in vec3 ro, in vec2 uv)\n{\n    vec3 ta = vec3(0.,0.5,0.);\n    \n    vec3 ww = normalize(ta-ro); //front\n    vec3 uu = normalize(cross(ww,vec3(0.,1.0,0.))); //right\n    vec3 vv = normalize(cross(uu,ww)); //up\n    \n    return normalize(uv.x*uu + uv.y*vv + 1.5*ww);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float angle = 10.0*iMouse.x/iResolution.x;\n    vec3 ro = vec3(5.0 * sin(angle),1.,5.0 * cos(angle));  \n    vec3 rd = getDir(ro, uv);\n    vec3 col = render(ro,rd, uv);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdByRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[165, 165, 196, 196, 283], [285, 285, 338, 338, 397], [399, 399, 421, 421, 517], [519, 519, 571, 571, 678], [680, 680, 704, 716, 3713], [3716, 3735, 3759, 3822, 3988], [3990, 3990, 4020, 4020, 4264], [4266, 4292, 4330, 4330, 4707], [4709, 4709, 4729, 4729, 4930], [4932, 4932, 4955, 4955, 4986], [4988, 5093, 5116, 5116, 5735], [5737, 5737, 5783, 5783, 7599], [7602, 7602, 7639, 7639, 7876], [7878, 7878, 7935, 7935, 8198]], "test": "untested"}
{"id": "tdffW4", "name": "Translate by mouse & matrix", "author": "forestgril", "description": "A simple example, how to translate scene by mouse coordinates, by using matrix mutliplication. It mainly highlights, that matrix constructor takes vectors column major. Click/drag to change camera/scene position.", "tags": ["mouse", "order", "translate", "major", "mat4", "rowmajor", "columnmajor"], "likes": 1, "viewed": 373, "published": 3, "date": "1588242133", "time_retrieved": "2024-07-30T21:09:41.420210", "image_code": "mat4 MakeTranslationMatrix3D(const in vec3 Offset)\n{ \n    return mat4(vec4(1.0, 0.0, 0.0, 0.0), vec4(0.0, 1.0, 0.0, 0.0), vec4(0.0, 0.0, 1.0,0.0), vec4(Offset.x, Offset.y, 0.0, 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord)/iResolution.xy ;\n\n    vec3 translationVector = vec3(-iMouse.x/iResolution.x, -iMouse.y/iResolution.y, 0.0);\n    mat4 translateByMousePos = MakeTranslationMatrix3D(translationVector);\n   \n    vec4 uv4 = vec4(uv.x ,uv.y, 0,1);\n    \n    vec3 col = 0.5 + 0.5*cos(32.0*(translateByMousePos*uv4).xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdffW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[187, 187, 244, 294, 686]], "test": "untested"}
{"id": "3dXfDN", "name": "Connected particle chain image", "author": "michael0884", "description": "Fabrice here you go.", "tags": ["particles", "aabb", "sort"], "likes": 32, "viewed": 1082, "published": 3, "date": "1588233002", "time_retrieved": "2024-07-30T21:09:42.180178", "image_code": "// Fork of \"Large scale flocking\" by michael0884. https://shadertoy.com/view/tsScRG\n// 2020-04-30 07:24:31\n\nivec4 get(ivec2 p)\n{\n    return floatBitsToInt(texel(ch0, p));\n}\n\nivec4 getb(int id)\n{\n    return floatBitsToInt(texel(ch2, i2xy(id)));\n}\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nvec3 imageC(vec2 p)\n{\n    return texture(ch3, vec2(1./6., 1.)*p/size).xyz;\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return sdSegment(p, getParticle(id).xy, getParticle((id+1)%tot_n).xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    ivec4 nb = get(ivec2(pos));\n \tvec4 p0 = getParticle(nb.x);\n   \n    \n    float d0 = 0.;\n    \n    d0 += 0.24/(1.+0.7*particleDistance(nb[0], pos));\n    d0 += 0.24/(1.+0.7*particleDistance(nb[1], pos));\n    \n    vec3 nyan = imageC(pos);\n    \n    fragColor.xyz = 2.5*sin(vec3(1,1,3)*d0) + (0.5*d0+0.3)*nyan;\n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define N ivec2(100,50)\n#define dt 0.5\n\n\nconst int tot_n = N.x*N.y;\n\nfloat hash11(float p)\n{\n    p = fract(p * 15.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p) - 0.5;\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nconst int k = 1664525;  \n\nivec4 hash( ivec4 x )\n{\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    return ivec4(x);\n}\n\nivec2 i2xy(int id)\n{\n    return ivec2(id%N.x, id/N.x);\n}\n\nint xy2i(ivec2 p)\n{\n    return p.x + p.y*N.x;\n}\n\nivec2 cross_distribution(int i)\n{\n    return (1<<(i/4)) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 );\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}", "buffer_a_code": "//particle buffer\n\nint cid;\n\nivec4 get(int id)\n{\n    return floatBitsToInt(texel(ch0, i2xy(id)));\n}\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat F(float d)\n{\n    return tanh(0.1*iTime)*(1.*exp(-0.35*d) - 4.*exp(-0.5*d));\n}\n\nfloat imageV(vec2 p)\n{\n    return 1.-2.*texture(ch2, vec2(1./6., 1.)*p/size).a;\n}\n\nvec2 imageF(vec2 p)\n{\n    vec3 d = vec3(-1,0,1);\n    return vec2(imageV(p+d.zy) - imageV(p+d.xy), imageV(p+d.yz) - imageV(p+d.yx));\n}\n\nvec2 Fv(vec4 p0, int pid)\n{\n    if(pid < 0 || pid >= tot_n || pid == cid) return vec2(0); \n   \tvec4 p1 = getParticle(pid);\n    vec2 flocking_force = 0.3*(p1.zw - p0.zw)/(1.+1.*distance(p1.xy,p0.xy));\n    vec2 interaction = normalize(p1.xy-p0.xy)*F(distance(p1.xy,p0.xy));\n    return flocking_force + interaction;\n}\n\nfloat irad;\n\nvec2 Fspring(vec4 p0, int pid)\n{\n    if(pid < 0 || pid >= tot_n || pid == cid) return vec2(0); \n   \tvec4 p1 = getParticle(pid);\n    vec2 interaction = normalize(p1.xy-p0.xy)*(distance(p1.xy,p0.xy)- 2.*PI*irad/float(tot_n) - 2.*tanh(0.1*iTime));\n    return interaction;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    if(p.x < N.x && p.y < N.y)\n    {\n        irad = 0.1*size.y;\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch1, pos);\n        int id = xy2i(p);\n        cid = id;\n        \n        //this pixel value\n        if(iFrame<10)\n        {\n            float t = 2.*PI*float(id)/float(tot_n);\n            U.xy = size*0.5 + irad*vec2(cos(t),sin(t));\n\t\t\tU.zw = 1.*(hash22(3.14159*pos) - 0.5);\n      \t\treturn;\n        }\n        \n        //neighbors\n   \t\tivec4 cp = get(id);\n   \t  \n        vec2 F = Fv(U, cp.x) +\n            \t Fv(U, cp.y) +\n            \t Fv(U, cp.z) +\n                 Fv(U, cp.w) +\n                 Fspring(U, (id + 1)%tot_n) +\n                 Fspring(U, (id - 1)%tot_n) +\n            \t -imageF(U.xy);\n        \n        if(iMouse.z > 0.) \n        {\n            float d = distance(iMouse.xy, U.xy);\n            F += 2.*normalize(iMouse.xy - U.xy)/(sqrt(d)+2.);\n        }\n        \n        U.zw += (-0.002*U.zw + 0.5*F)*dt;\n        U.xy += U.zw*dt;\n        \n        //border conditions\n        if(size.x - U.x < 2.) U.z = -abs(U.z);\n        if(U.x < 2.) U.z = abs(U.z);\n        if(size.y - U.y < 2.) U.w = -abs(U.w);\n        if(U.y < 2.) U.w = abs(U.w);\n \n        \n    }\n    else discard;\n}", "buffer_a_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//sorting closest 4 particles in axis directions that make a bounding box\n//only in particle space, texture buffer not needed\n\nivec4 get(int id)\n{\n    return floatBitsToInt(texel(ch0, i2xy(id)));\n}\n\nvec4 save(ivec4 v)\n{\n    return intBitsToFloat(v);\n}\n\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //this particle position\nint tid;\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\n//insertion sort\nvoid sort(int utemp)\n{\n    if(utemp == tid || utemp < 0) return;\n       \n   \tvec4 part = getParticle(utemp);\n    vec2 dx = part.xy - pos;\n    float dtemp = length(dx);\n    //sorting\n    if(dx.x > abs(dx.y))\n    {\n        if(d.x > dtemp) \n        {\n            d.x = dtemp;\n        \tu.x = utemp;\n        }\n    }\n    else if(dx.x < -abs(dx.y))\n    {\n        if(d.y > dtemp) \n        {\n            d.y = dtemp;\n        \tu.y = utemp;\n        }\n    }\n    else if(dx.y > abs(dx.x))\n    {\n        if(d.z > dtemp) \n        {\n            d.z = dtemp;\n        \tu.z = utemp;\n        }\n    }\n    else if(d.w > dtemp) \n    {\n        d.w = dtemp;\n        u.w = utemp;\n    }\n}\n\nvoid sortneighbor(int id)\n{\n    ivec4 nb = get(id);\n    for(int j = 0; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{  \n    ivec2 p = ivec2(fragCoord);\n    \n    if(p.x > N.x || p.y > N.y) discard;\n    \n    int id = xy2i(p);\n     \n    u = ivec4(-1); d = vec4(1e10); \n   \n    tid = id;\n    pos = getParticle(id).xy;\n    \n    sortneighbor(id); \n    \n    for(int i = 0; i < 8; i++)\n    {\n        sort(hash(ivec4(p, iFrame, i)).x%tot_n); //random sort    \n    }\n    \n    ivec4 nb = get(id);\n    for(int i = 0; i < 4; i++)\n    {\n        sortneighbor(nb[i]); \n    }\n    \n    if( any(lessThan(u, ivec4(-1))) || any(greaterThan(u, ivec4(tot_n))))\n    {\n        u = ivec4(0);\n    }\n    \n    \n    U = save(u);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//4th order voronoi particle tracking \n\nivec4 get(ivec2 p)\n{\n    return floatBitsToInt(texel(ch0, p));\n}\n\nvec4 save(ivec4 v)\n{\n    return intBitsToFloat(v);\n}\n\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //pixel position\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return sdSegment(p, getParticle(id).xy, getParticle((id+1)%tot_n).xy);\n}\n\n//insertion sort\nvoid sort(int utemp)\n{\n    if(utemp <0) return; \n   \tfloat dtemp = particleDistance(utemp, pos);\n    //sorting\n    if(d.x > dtemp)\n    {\n        d = vec4(dtemp, d.xyz);\n        u = ivec4(utemp, u.xyz);\n    }\n    else if(d.y > dtemp && dtemp > d.x)\n    {\n        d.yzw = vec3(dtemp, d.yz);\n        u.yzw = ivec3(utemp, u.yz);\n    }\n    else if(d.z > dtemp && dtemp > d.y)\n    {\n        d.zw = vec2(dtemp, d.z);\n        u.zw = ivec2(utemp, u.z);\n    }\n    else if(d.w > dtemp && dtemp > d.z)\n    {\n        d.w = dtemp;\n        u.w = utemp;\n    }\n}\n\nvoid sortpos(ivec2 p)\n{\n    ivec4 nb = get(p);\n    for(int j = 0; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{\n    pos = fragCoord;\n    ivec2 p = ivec2(pos);\n     \n    u = ivec4(-1); d = vec4(1e10); \n   \n    //jump flood sorting \n    sortpos(p); //resort this position\n    for(int i = 0; i < 12; i++)\n    {\n        sortpos(p+cross_distribution(i)); \n    }\n    \n    for(int i = 0; i < 4; i++)\n    {\n        sort(hash(ivec4(p, iFrame, i)).x%tot_n); //random sort    \n    }\n    \n    if( any(lessThan(u, ivec4(-1))) || any(greaterThan(u, ivec4(tot_n))) )\n    {\n        u = ivec4(0);\n    }\n    \n    U = save(u);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXfDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 108, 128, 128, 172], [174, 174, 194, 194, 245], [247, 247, 273, 273, 308], [310, 310, 331, 331, 386], [388, 388, 428, 428, 505], [507, 507, 558, 558, 868]], "test": "untested"}
{"id": "WsXBD4", "name": "A first raymarcher", "author": "CraftedCart", "description": "I started off with https://www.youtube.com/watch?v=PGtv-dBi2wE and tried adding some more shapes, a spinning camera, multiple lights, and soft shadows :)", "tags": ["3d", "raymarching"], "likes": 0, "viewed": 387, "published": 3, "date": "1588214279", "time_retrieved": "2024-07-30T21:09:43.002978", "image_code": "// Tutorial videos\n// ===============\n// https://www.youtube.com/watch?v=PGtv-dBi2wE\n\n#define M_PI 3.1415926535897932384626433832795\n\nconst int MAX_MARCHING_STEPS = 100; // How many marching iterations should we do before giving up\nconst float MAX_MARCHING_DIST = 100.0; // How far should we march for before giving up and calling it \"sky\"\nconst float MARCHING_SURFACE_DIST = 0.01; // How close should we march towards some geometry before we consider it a hit\nconst float MAX_LIGHT_BOUNCES = 6.0; // How many times we should attempt to bounce light in shadowed areas before giving up\n\nconst vec3 WORLD_UP = vec3(0.0, 1.0, 0.0);\nconst vec3 VIEW_TARGET = vec3(0.0, 2.5, 0.0);\nconst float ZOOM_FAC = 1.0;\n\nconst vec3 COL_PINK = vec3(0.969, 0.659, 0.722);\nconst vec3 COL_BLUE = vec3(0.333, 0.804, 0.988);\n\n/** Given a point in 3D space, figure out how far away we are from the nearest piece of geometry */\nfloat getDistToGeom(vec3 point) {\n    float minDist = MAX_MARCHING_DIST;\n\n    // Sphere object\n    vec3 sphere1Pos = vec3(-2.0, 1.0, 0.0);\n    float sphere1Radius = 1.0;\n    float sphere1Dist = length(point - sphere1Pos) - sphere1Radius;\n    minDist = min(minDist, sphere1Dist);\n\n    // Sphere object\n    vec3 sphere2Pos = vec3(2.0, 0.5, 0.0);\n    float sphere2Radius = 0.5;\n    float sphere2Dist = length(point - sphere2Pos) - sphere2Radius;\n    minDist = min(minDist, sphere2Dist);\n\n    // Many sphere objects\n    float rot = sin(iTime * 2.0) * 0.5 + 0.5;\n    for (float i = 0.0; i < 2.0 * M_PI; i += M_PI / 6.0) {\n        // vec3 spherePos = vec3(cos(i * 4) + sin(iTime * 2 + i), 4 + sin(i * 4) + cos(iTime * 2 + i), sin(i));\n        vec3 spherePos = vec3(sin(iTime * 4.0 + i) * (1.0 - rot) + cos(iTime * 4.0 + i) * rot, 3.0 + cos(iTime + i), sin(iTime * 4.0 + i) * rot + cos(iTime * 4.0 + i) * (1.0 - rot));\n        float sphereRadius = 0.15;\n        float sphereDist = length(point - spherePos) - sphereRadius;\n        minDist = min(minDist, sphereDist);\n    }\n\n    // Ground plane distance can be calculated as just the point offset from the ground\n    float planeDist = point.y;\n    minDist = min(minDist, planeDist);\n\n    // Return whatever distance is closest to the point\n    return minDist;\n}\n\n/** Given a ray origin and ray direction, figure out how far the ray goes before hitting some geometry */\nfloat rayMarch(vec3 rayOrigin, vec3 rayDir) {\n    float distFromOrigin = 0.0;\n\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 currentPos = rayOrigin + rayDir * distFromOrigin;\n\n        float distToGeom = getDistToGeom(currentPos);\n        distFromOrigin += distToGeom; // March forward\n\n        // Check if we should exit the loop\n        if (distFromOrigin > MAX_MARCHING_DIST || distToGeom < MARCHING_SURFACE_DIST) break;\n    }\n\n    return distFromOrigin;\n}\n\n/** Given a point on a surface in 3D space, figure out its normal direction */\nvec3 getNormal(vec3 point) {\n    float dist = getDistToGeom(point);\n\n    return normalize(dist - vec3(\n                getDistToGeom(point - vec3(0.01, 0.0, 0.0)),\n                getDistToGeom(point - vec3(0.0, 0.01, 0.0)),\n                getDistToGeom(point - vec3(0.0, 0.0, 0.01))\n                ));\n}\n\n/** Gets the pixel color of a point in 3D space */\nfloat getLight(vec3 point, vec3 lightPos) {\n    vec3 lightDir = normalize(lightPos - point);\n    vec3 surfaceNorm = getNormal(point);\n\n    float diffuse = max(0.0, dot(lightDir, surfaceNorm));\n\n    // Now, let's raymarch towards our light source\n    // if it turns out we can't raymarch all the way to the light, that means we hit an object along the way\n    // meaning we should be in shadow\n\n    // Adjust the point so we don't start inside some geometry\n    bool rayEscaped = false;\n    for (float i = 0.0; i < MAX_LIGHT_BOUNCES; i++) {\n        vec3 pointAdj = point + surfaceNorm * MARCHING_SURFACE_DIST * 3.0;\n\n        float distTowardsLight = rayMarch(pointAdj, lightDir);\n        if (distTowardsLight < length(lightPos - point)) {\n            // We hit something - let's do a light bounce\n            vec3 hitPoint = pointAdj + lightDir * distTowardsLight;\n            vec3 hitNormal = getNormal(hitPoint);\n\n            float bounceMarchDist = rayMarch(hitPoint, hitNormal);\n            vec3 bouncePoint = hitPoint + hitNormal * bounceMarchDist;\n            vec3 bounceNorm = getNormal(bouncePoint);\n\n            diffuse *= pow(1.0 - (1.0 / MAX_LIGHT_BOUNCES), i);\n\n            point = bouncePoint;\n            surfaceNorm = bounceNorm;\n        } else {\n            rayEscaped = true;\n        }\n    }\n\n    // If a ray never made it to the light source, make it pitch black\n    if (!rayEscaped) {\n        diffuse = 0.0;\n    }\n\n    return diffuse;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float ratio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n\n    uv -= 0.5; // Move the origin to the middle of the screen\n    uv.x *= ratio; // Account for the aspect ratio\n\n    vec3 col = vec3(0.0, 0.0, 0.0);\n\n    vec3 rayOrigin = vec3(cos(iTime * 0.2) * 12.0, 1.5 + sin(iTime * 0.5), sin(iTime * 0.2) * 12.0); // Camera position\n\n    vec3 camForward = normalize(VIEW_TARGET - rayOrigin);\n    vec3 camRight = normalize(cross(WORLD_UP, camForward));\n    vec3 camUp = cross(camForward, camRight);\n\n    vec3 screenCenter = rayOrigin + camForward * ZOOM_FAC; // Figure out where the center of the screen is in 3D space\n    vec3 intersectPoint = screenCenter + (uv.x * camRight) + (uv.y * camUp);\n\n    vec3 rayDir = intersectPoint - rayOrigin;\n\n    float rayDist = rayMarch(rayOrigin, rayDir);\n    vec3 point = rayOrigin + rayDir * rayDist; // Get the point in 3D space\n\n    vec3 lightPos;\n    lightPos = vec3(0.0 + sin(iTime * 1.5) * 8.0, 5.0, 6.0 + cos(iTime * 1.5) * 8.0);\n    col += getLight(point, lightPos) * COL_BLUE * (sin(iTime * 0.3) + 1.0) * 0.5;\n\n    lightPos = vec3(0.0 + sin(iTime) * 2.0, 2.0, 6.0 + cos(iTime) * 2.0);\n    col += getLight(point, lightPos) * COL_PINK * (cos(iTime * 0.3) + 1.0) * 0.5;\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXBD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[803, 903, 936, 936, 2206], [2208, 2314, 2359, 2359, 2790], [2792, 2871, 2899, 2899, 3177], [3179, 3230, 3273, 3273, 4684], [4686, 4686, 4741, 4741, 6043]], "test": "untested"}
{"id": "WsfBW4", "name": "Tutorial point cube", "author": "CraftedCart", "description": "https://www.youtube.com/watch?v=dKA5ZVALOhs\nhttps://www.youtube.com/watch?v=PBxuVlp7nuM", "tags": ["3d", "tutorial"], "likes": 2, "viewed": 351, "published": 3, "date": "1588206204", "time_retrieved": "2024-07-30T21:09:43.941469", "image_code": "const vec3 WORLD_UP = vec3(0.0, 1.0, 0.0);\nconst vec3 VIEW_TARGET = vec3(0.0, 0.0, 0.0);\nconst float ZOOM_FAC = 2.0;\n\n/** Returns how far away `point` is from the ray line */\nfloat distLine(vec3 rayOrigin, vec3 rayDir, vec3 point) {\n    return length(cross(point - rayOrigin, rayDir)) / length(rayDir);\n}\n\nfloat drawPoint(vec3 rayOrigin, vec3 rayDir, vec3 point) {\n    return smoothstep(0.06, 0.05, distLine(rayOrigin, rayDir, point));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float ratio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n\n    uv -= 0.5; // Move the origin to the middle of the screen\n    uv.x *= ratio; // Account for the aspect ratio\n\n    vec3 rayOrigin = vec3(cos(iTime) * 4.0, sin(iTime) * 4.0, sin(iTime) * 4.0); // Camera position\n\n    vec3 camForward = normalize(VIEW_TARGET - rayOrigin);\n    vec3 camRight = normalize(cross(WORLD_UP, camForward));\n    vec3 camUp = cross(camForward, camRight);\n\n    vec3 screenCenter = rayOrigin + camForward * ZOOM_FAC; // Figure out where the center of the screen is in 3D space\n    vec3 intersectPoint = screenCenter + (uv.x * camRight) + (uv.y * camUp);\n\n    vec3 rayDir = intersectPoint - rayOrigin;\n\n    // Make a color shifting gradient\n    vec3 col = 0.5 + 0.5 * cos((iTime * 0.8) + uv.xyx + vec3(0.0, 2.0, 4.0));\n\n    float mask = 0.0;\n\n    // Add points of a cube\n    // mask += drawPoint(rayOrigin, rayDir, vec3(-0.5, -0.5, -0.5));\n    // mask += drawPoint(rayOrigin, rayDir, vec3(-0.5, -0.5,  0.5));\n    // mask += drawPoint(rayOrigin, rayDir, vec3(-0.5,  0.5, -0.5));\n    // mask += drawPoint(rayOrigin, rayDir, vec3(-0.5,  0.5,  0.5));\n    // mask += drawPoint(rayOrigin, rayDir, vec3( 0.5, -0.5, -0.5));\n    // mask += drawPoint(rayOrigin, rayDir, vec3( 0.5, -0.5,  0.5));\n    // mask += drawPoint(rayOrigin, rayDir, vec3( 0.5,  0.5, -0.5));\n    // mask += drawPoint(rayOrigin, rayDir, vec3( 0.5,  0.5,  0.5));\n\n    // Add \"lines\" (composed of many points) of a cube\n    for (float x = -0.5; x < 0.5; x += 0.05) {\n        mask += drawPoint(rayOrigin, rayDir, vec3(x, -0.5, -0.5));\n        mask += drawPoint(rayOrigin, rayDir, vec3(x,  0.5, -0.5));\n        mask += drawPoint(rayOrigin, rayDir, vec3(x, -0.5,  0.5));\n        mask += drawPoint(rayOrigin, rayDir, vec3(x,  0.5,  0.5));\n    }\n\n    for (float y = -0.5; y < 0.5; y += 0.05) {\n        mask += drawPoint(rayOrigin, rayDir, vec3(-0.5, y, -0.5));\n        mask += drawPoint(rayOrigin, rayDir, vec3( 0.5, y, -0.5));\n        mask += drawPoint(rayOrigin, rayDir, vec3(-0.5, y,  0.5));\n        mask += drawPoint(rayOrigin, rayDir, vec3( 0.5, y,  0.5));\n    }\n\n    for (float z = -0.5; z < 0.5; z += 0.05) {\n        mask += drawPoint(rayOrigin, rayDir, vec3(-0.5, -0.5, z));\n        mask += drawPoint(rayOrigin, rayDir, vec3( 0.5, -0.5, z));\n        mask += drawPoint(rayOrigin, rayDir, vec3(-0.5,  0.5, z));\n        mask += drawPoint(rayOrigin, rayDir, vec3( 0.5,  0.5, z));\n    }\n\n    col *= (min(mask, 1.0) * 0.8) + 0.2;\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsfBW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 175, 232, 232, 304], [306, 306, 364, 364, 437], [439, 439, 494, 494, 3052]], "test": "untested"}
{"id": "3sfBW4", "name": "fun spiral", "author": "kit_spin", "description": "my first little shader project :3", "tags": ["test", "beginner", "spiral"], "likes": 4, "viewed": 415, "published": 3, "date": "1588205288", "time_retrieved": "2024-07-30T21:09:44.693458", "image_code": "float drawspiral(in float wingsize, float fuzz, float d, float offset, \n                 float wings, float zoom, float speed, float nudge){\n    //Draw displacement map\n\treturn smoothstep(wingsize, wingsize+fuzz,\n                      abs(sin(d*zoom+\n                              offset*wings+\n                              iTime*speed+\n                              nudge)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 st = fragCoord.xy/iResolution.xy;\n    vec3 color = vec3(0.0);\n    float d = 0.0;\n\t\n    //Place origin at center of screen\n    st = st *2.00-1.000;\n    st.x *= iResolution.x/iResolution.y;\n\t\n    //Concentric circles distance map from center\n    d = length( abs(st) );\n\t\n    //Nudge pixels towards the center relative to the angle from the X axis\n    float offset = (atan(st.y/st.x));  \n    \n    //Unfocus edgest more when closer to center\n    float focus = pow(d,-.5)/2.00;\n    \n    // Edit these things for fun and profit\n    // \t\t\t\t\t(size , fuzz \t  , d, offset, wings, zoom , speed, nudge)\n    float r = drawspiral(0.700, 0.20*focus, d, offset, \n                         6.000, 10.0, 1.000, iTime);\n    float g = drawspiral(0.700, 0.20*focus, d, offset, \n                         6.000, 10.*sin(iTime/3.0 ), 1.000, 2.000);\n    float b = drawspiral(0.700, 0.20*focus, d, offset, \n                         6.000, 10.*sin(iTime/3.0 +1.57078), 1.000, 2.200);\n    \n    color = vec3(r,g,b);\n    \n    fragColor = vec4(color, 1);\n    \n    //uncomment this line to force black and white and read only from 'b' only\n    //fragColor = vec4(vec3(b), 1);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfBW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 140, 168, 379], [381, 381, 437, 437, 1592]], "test": "untested"}
{"id": "WdXBW4", "name": "Clouds-2D", "author": "murieron", "description": "murieron shader", "tags": ["cineshader"], "likes": 117, "viewed": 50837, "published": 3, "date": "1588200933", "time_retrieved": "2024-07-30T21:09:45.551165", "image_code": "// https://www.shadertoy.com/view/WdXBW4\n \nconst float cloudscale = 1.1;\nconst float speed = 0.03;\nconst float clouddark = 0.5;\nconst float cloudlight = 0.3;\nconst float cloudcover = 0.2;\nconst float cloudalpha = 8.0;\nconst float skytint = 0.5;\nconst vec3 skycolour1 = vec3(0.2, 0.4, 0.6);\nconst vec3 skycolour2 = vec3(0.4, 0.7, 1.0);\n\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));\t\n}\n\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 0.1;\n\tfor (int i = 0; i < 7; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn = m * n;\n\t\tamplitude *= 0.4;\n\t}\n\treturn total;\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = fragCoord.xy / iResolution.xy;\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0);    \n    float time = iTime * speed;\n    float q = fbm(uv * cloudscale * 0.5);\n    \n    //ridged noise shape\n\tfloat r = 0.0;\n\tuv *= cloudscale;\n    uv -= q - time;\n    float weight = 0.8;\n    for (int i=0; i<8; i++){\n\t\tr += abs(weight*noise( uv ));\n        uv = m*uv + time;\n\t\tweight *= 0.7;\n    }\n    \n    //noise shape\n\tfloat f = 0.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale;\n    uv -= q - time;\n    weight = 0.7;\n    for (int i=0; i<8; i++){\n\t\tf += weight*noise( uv );\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n    \n    f *= r + f;\n    \n    //noise colour\n    float c = 0.0;\n    time = iTime * speed * 2.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale*2.0;\n    uv -= q - time;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n\t\tc += weight*noise( uv );\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n    \n    //noise ridge colour\n    float c1 = 0.0;\n    time = iTime * speed * 3.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale*3.0;\n    uv -= q - time;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n\t\tc1 += abs(weight*noise( uv ));\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n\t\n    c += c1;\n    \n    vec3 skycolour = mix(skycolour2, skycolour1, p.y);\n    vec3 cloudcolour = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight*c), 0.0, 1.0);\n   \n    f = cloudcover + cloudalpha*f*r;\n    \n    vec3 result = mix(skycolour, clamp(skytint * skycolour + cloudcolour, 0.0, 1.0), clamp(f + c, 0.0, 1.0));\n    \n\tfragColor = vec4( result, 1.0 );\n}\n\n/** SHADERDATA\n{\n    \"title\": \"Murieron\",\n    \"description\": \"Homenaje a las víctimas del COVID-19\",\n    \"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXBW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[383, 383, 404, 404, 517], [519, 519, 545, 545, 1069], [1071, 1071, 1090, 1090, 1244], [1298, 1298, 1355, 1355, 2977]], "test": "untested"}
{"id": "wdsfDH", "name": "Clouds 3D", "author": "murieron", "description": "Shader for In memoriam", "tags": ["cineshader"], "likes": 44, "viewed": 47426, "published": 3, "date": "1588199587", "time_retrieved": "2024-07-30T21:09:46.405880", "image_code": "// based in https://www.shadertoy.com/view/4sXGRM\n\nvec3 skytop = vec3(0.05, 0.2, 0.5);\n\nvec3 light = normalize(vec3(0.1, 0.25, 0.9));\n\nvec2 cloudrange = vec2(0.0, 10000.0);\n\nmat3 m = mat3(0.00, 1.60, 1.20, -1.60, 0.72, -0.96, -1.20, -0.96, 1.28);\n\n// hash function              \nfloat hash(float n)\n{\n    return fract(cos(n) * 114514.1919);\n}\n\n// 3d noise function\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = smoothstep(0.0, 1.0, fract(x));\n        \n    float n = p.x + p.y * 10.0 + p.z * 100.0;\n    \n    return mix(\n        mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n            mix(hash(n + 10.0), hash(n + 11.0), f.x), f.y),\n        mix(mix(hash(n + 100.0), hash(n + 101.0), f.x),\n            mix(hash(n + 110.0), hash(n + 111.0), f.x), f.y), f.z);\n}\n\n// Fractional Brownian motion\nfloat fbm(vec3 p)\n{\n    float f = 0.5000 * noise(p);\n    p = m * p;\n    f += 0.2500 * noise(p);\n    p = m * p;\n    f += 0.1666 * noise(p);\n    p = m * p;\n    f += 0.0834 * noise(p);\n    return f;\n}\n\nvec3 camera(float time)\n{\n    return vec3(5000.0 * sin(1.0 * time), 5000. + 1500. * sin(0.5 * time), 6000.0 * time);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float time = (iTime + 13.5 + 44.) * 1.0;\n    vec3 campos = camera(time);\n    vec3 camtar = camera(time + 0.4);\n\n    vec3 front = normalize(camtar - campos);\n    vec3 right = normalize(cross(front, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, front));\n    vec3 fragAt = normalize(uv.x * right + uv.y * up + front);\n    \n    // clouds\n    vec4 sum = vec4(0, 0, 0, 0);\n    for (float depth = 0.0; depth < 100000.0; depth += 200.0)\n    {\n        vec3 ray = campos + fragAt * depth;\n        if (cloudrange.x < ray.y && ray.y < cloudrange.y)\n        {\n            float alpha = smoothstep(0.5, 1.0, fbm(ray * 0.00025));\n            vec3 localcolor = mix(vec3(1.1, 1.05, 1.0), vec3(0.3, 0.3, 0.2), alpha);\n            alpha = (1.0 - sum.a) * alpha;\n            sum += vec4(localcolor * alpha, alpha);\n        }\n    }\n    \n    float alpha = smoothstep(0.7, 1.0, sum.a);\n    sum.rgb /= sum.a + 0.0001;\n\n    float sundot = clamp(dot(fragAt, light), 0.0, 1.0);\n    vec3 col = 0.8 * (skytop);\n    col += 0.47 * vec3(1.6, 1.4, 1.0) * pow(sundot, 350.0);\n    col += 0.4 * vec3(0.8, 0.9, 1.0) * pow(sundot, 2.0);\n    \n    sum.rgb -= 0.6 * vec3(0.8, 0.75, 0.7) * pow(sundot, 13.0) * alpha;\n    \n    sum.rgb += 0.2 * vec3(1.3, 1.2, 1.0) * pow(sundot, 5.0) * (1.0 - alpha);\n\n    col = mix(col, sum.rgb, sum.a);\n\n    fragColor = vec4(col, 1.0);\n    // fragColor = vec4(col, sum.a);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Murieron\",\n\t\"description\": \"Homenaje a las víctimas del COVID-19\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsfDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[248, 279, 300, 300, 342], [344, 365, 389, 389, 771], [773, 803, 822, 822, 1000], [1002, 1002, 1027, 1027, 1120], [1122, 1122, 1177, 1177, 2661]], "test": "untested"}
{"id": "tdXBW8", "name": "Neon Desert", "author": "demofox", "description": "Non PBR Path Tracer combining Ray Tracing, Ray Marching and 2D SDFs. +Bloom and depth of field, circular bokeh.\nDrag mouse to move camera.\nCommon = settings\nBufferA = scene\nBufferB = bloom horizontal pass\nImage = bloom vertical pass and display adaptation", "tags": ["pathtracing"], "likes": 55, "viewed": 3413, "published": 3, "date": "1588197791", "time_retrieved": "2024-07-30T21:09:47.532867", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Does second pass of Bloom (vertical)\n    // Then does exposure, tone mapping & linear to sRGB conversion.\n    //fragColor = ImageFunction(iChannel0, iChannel1, fragCoord.xy, iResolution.xy);\n\n\t// get the linear color of the pixel\n    vec3 pixelColor = texture( iChannel0, fragCoord.xy/iResolution.xy).rgb;\n    \n    // add in bloom\n    pixelColor += BloomPass2(fragCoord.xy, iResolution.xy, iChannel1);\n    \n    // apply exposure\n    pixelColor *= c_exposure;\n    \n    // tone map the color to bring it from unbound HDR levels to SDR levels\n    pixelColor = ACESFilm(pixelColor);\n    \n    // convert to sRGB, then output\n    pixelColor = LinearToSRGB(pixelColor);\n    fragColor = vec4(pixelColor, 1.0f);    \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// =======================================================================\n// Scene Descriptions - both ray tracing and ray marched objects\n// =======================================================================\n\nvoid RayTraceMountainCylinders(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo hitInfo, in float seed, in float radius, in float maxMountainHeight)\n{\n    SMaterial material;\n    material.diffuse = vec3(1.0f, 1.0f, 1.0f);\n    material.specular = vec3(0.0f, 0.0f, 0.0f);\n    material.roughness = 0.025f;\n    material.emissive = vec3(0.0f, 0.0f, 0.0f);\n\n    SRayHitInfo oldHitInfo = hitInfo;\n\n    if(TestCylinderTrace(rayPos, rayDir, hitInfo, vec3(0.0f, -15.0f, 0.0f), radius, maxMountainHeight, material))\n    {\n        vec3 hitPos = rayPos + rayDir * hitInfo.dist;\n        float azimuthPercent = clamp((atan(hitPos.z, hitPos.x) + c_pi) / c_twopi, 0.0f, 1.0f);\n        float heightPercent = (hitPos.y + 15.0f) / maxMountainHeight;\n\n        float thisHeightIndex = floor(azimuthPercent * 20.0f);\n        float nextHeightIndex = mod(thisHeightIndex + 1.0f, 20.0f);\n        float thisHeightIndexFraction = fract(azimuthPercent * 20.0f);\n\n        float thisHeight = hash12(vec2(thisHeightIndex, seed)) * 0.75f + 0.25f;\n        float nextHeight = hash12(vec2(nextHeightIndex, seed)) * 0.75f + 0.25f;\n\n        float mountainHeight = mix(thisHeight, nextHeight, thisHeightIndexFraction);\n\n        if (heightPercent > mountainHeight)\n        {\n            hitInfo = oldHitInfo;\n        }\n        else\n        {\n            vec3 brightPink = pow(vec3(0.99f, 0.04f, 0.98f), vec3(2.2f, 2.2f, 2.2f)) * 5.0f;\n            \n            float borderSize = 0.25f / maxMountainHeight;\n            \n            hitInfo.material.emissive = brightPink * smoothstep(mountainHeight - borderSize, mountainHeight, heightPercent);\n        }\n    }    \n}\n\nvoid RayTraceScene(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo hitInfo)\n{\n    // floor\n    {\n    \tSMaterial material;\n        material.diffuse = vec3(0.1f, 0.1f, 0.1f);\n        material.specular = vec3(0.0f, 0.0f, 0.0f);\n        material.roughness = 0.02f;\n        material.emissive = vec3(0.0f, 0.0f, 0.0f);\n    \tif (TestPlaneTrace(rayPos, rayDir, hitInfo, vec4( normalize(vec3(0.0f, 1.0f, 0.0f)), -5.0f), material))\n        {\n            vec3 intersectPos = rayPos + rayDir * hitInfo.dist;\n            vec2 uv = intersectPos.xz;\n                        \n            uv = fract(uv / 75.0f);\n            \n            float dist = min(abs(uv.x - 0.5), abs(uv.y - 0.5));\n            dist = step(dist, 0.005f);\n                       \n            float len2d = (cos(intersectPos.x * 0.01530f + intersectPos.y * 0.06320f) + 1.0f) / 2.5f;\n            \n            vec3 brightPurple = pow(vec3(0.73f, 0.06f, 0.99f), vec3(2.2f, 2.2f, 2.2f));\n            brightPurple = mix(brightPurple, vec3(0.0625f, 0.0f, 1.0f), len2d);\n            \n            vec3 darkPurple = pow(vec3(0.12f, 0.02f, 0.09f), vec3(2.2f, 2.2f, 2.2f));\n            \n            hitInfo.material.emissive = mix(darkPurple, brightPurple, dist);\n            hitInfo.material.specular = mix(vec3(0.33f, 0.33f, 0.33f), vec3(0.0f, 0.0f, 0.0f), dist);\n        }\n    }\n    \n    // reflective balls\n    {\n    \tSMaterial material;\n        material.diffuse = vec3(0.5f, 0.5f, 0.5f);\n        material.specular = vec3(1.0f, 1.0f, 1.0f);\n        material.roughness = 0.035f;\n        material.emissive = vec3(0.0f, 0.0f, 0.0f);\n    \tTestSphereTrace(rayPos, rayDir, hitInfo, vec4(20.0f, 5.0f, -20.0f, 10.0f), material);\n        \n        TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-60.0f, 0.0f, 20.0f, 10.0f), material);\n        \n        \n        TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, 5.0f,  -65.0f, 10.0f), material);\n        \n        \n        TestSphereTrace(rayPos, rayDir, hitInfo, vec4(15.0f, -3.0f, 65.0f, 2.0f), material);\n    }\n    \n    // Cylinders with mountain cutouts - draw front to back\n    {\n        RayTraceMountainCylinders(rayPos, rayDir, hitInfo,  284.0f, 700.0f, 50.0f);\n        RayTraceMountainCylinders(rayPos, rayDir, hitInfo, 1337.0f, 800.0f, 150.0f);\n        RayTraceMountainCylinders(rayPos, rayDir, hitInfo, 1932.0f, 900.0f, 250.0f);\n\t}\n    \n    // dark sun with gradient\n    {\n    \tSMaterial material;\n        material.diffuse = vec3(0.0f, 0.0f, 0.0f);\n        material.specular = vec3(0.0f, 0.0f, 0.0f);\n        material.roughness = 0.0f;\n        material.emissive = vec3(0.0f, 0.0f, 0.0f);\n        \n        SRayHitInfo oldHitInfo = hitInfo;\n        \n    \tif (TestPlaneTrace(rayPos, rayDir, hitInfo, vec4( normalize(vec3(0.0f, 0.0f, -1.0f)), -1000.0f), material))\n        {\n            vec3 intersectPos = rayPos + rayDir * hitInfo.dist;\n            vec2 uv = intersectPos.xy;\n            \n            int stripe = int((-uv.y + 500.0f) / 50.0f);\n            if (stripe > 1)\n                stripe = (stripe-1) % 2;\n            else\n                stripe = 0;\n            \n            if (length(uv) > 500.0f)\n            {\n                hitInfo = oldHitInfo;\n            }\n            else if (stripe == 1)\n            {\n                hitInfo.material.emissive = pow(vec3(0.29f, 0.03f, 0.42f) * 0.55f, vec3(2.2f, 2.2f, 2.2f));\n            }\n            else\n            {\n                vec3 topColor = pow(vec3(0.99f, 0.04f, 0.98f), vec3(2.2f, 2.2f, 2.2f));\n                vec3 bottomColor = pow(vec3(0.12f, 0.02f, 0.09f), vec3(2.2f, 2.2f, 2.2f));\n\n                float lerp = clamp((uv.y - 100.0f) / 400.0f, 0.0f, 1.0f);\n                lerp = Bias(lerp, 0.05);\n                hitInfo.material.emissive = mix(bottomColor, topColor, lerp);\n            }\n        }\n    }\n    \n    // ringed planet\n    {\n        // planet\n        {\n            SMaterial material;\n            material.diffuse = vec3(0.0f, 0.0f, 0.0f);\n            material.specular = vec3(0.0f, 0.0f, 0.0f);\n            material.roughness = 0.0f;\n            material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            if(TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, 500.0f, -1200.0f, 200.0f), material))\n            {\n                // TODO: gradient: yellow to red, then red to purple?\n                vec3 intersectPos = rayPos + rayDir * hitInfo.dist;\n\n                float lerpTop = clamp((intersectPos.y - 500.0f) / 200.0f, 0.0f, 1.0f);\n                float lerpMiddle = 1.0f - clamp((intersectPos.y - 500.0f) / 200.0f, 0.0f, 1.0f);\n                float lerpBottom = clamp((intersectPos.y - 500.0f) / -200.0f, 0.0f, 1.0f);\n                \n                lerpTop = Bias(lerpTop, 0.1f);\n                lerpMiddle = Bias(lerpMiddle, 0.9f);\n                lerpBottom = Bias(lerpBottom, 0.1f);\n\n                vec3 color = vec3(1.0f, 1.0f, 0.0f) * lerpTop;\n                color += vec3(1.0f, 0.0f, 0.0f) * lerpMiddle;\n                color += vec3(1.0f, 0.0f, 1.0f) * lerpBottom;\n\n                hitInfo.material.emissive = color;\n            }\n        }\n        \n        // ring\n        {\n            SMaterial material;\n            material.diffuse = vec3(0.0f, 0.0f, 0.0f);\n            material.specular = vec3(0.0f, 0.0f, 0.0f);\n            material.roughness = 0.0f;\n            material.emissive = vec3(0.8f, 0.0f, 1.0f);// * 2.0f;// * 0.1f;\n\n            TestCylinderTrace(rayPos, rayDir, hitInfo, vec3(0.0f, 460.0f, -1200.0f), 300.0f, 10.0f, material);\n            TestCylinderTrace(rayPos, rayDir, hitInfo, vec3(0.0f, 460.0f, -1200.0f), 350.0f, 10.0f, material);\n            TestCylinderTrace(rayPos, rayDir, hitInfo, vec3(0.0f, 460.0f, -1200.0f), 375.0f, 10.0f, material);\n        }\n    }\n    \n    // sky dome\n    {\n    \tSMaterial material;\n        material.diffuse = vec3(0.0f, 0.0f, 0.0f);\n        material.specular = vec3(0.0f, 0.0f, 0.0f);\n        material.roughness = 0.0f;\n        material.emissive = pow(vec3(0.29f, 0.03f, 0.42f) * 0.55f, vec3(2.2f, 2.2f, 2.2f));\n    \tif(TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, 0.0f, 0.0f, 2000.0f), material))\n        {\n            const float c_skyStarCells = 45.0f;\n            \n            // convert the hit position to polar, but percentages from 0 to 1.\n            // make the pole at the horizon to hide the distortion that would be in the sky otherwise.\n            vec3 hitPos = (rayPos + rayDir * hitInfo.dist).yzx;\n            float theta = (atan(hitPos.y, hitPos.x) + c_pi) / c_twopi;\n            float phi = (atan(sqrt(hitPos.x*hitPos.x + hitPos.y*hitPos.y), hitPos.z) + c_pi) / c_twopi;\n\n            // figure out what cell we are in and the offset in that cell\n            vec2 cellIndex = vec2(floor(theta * c_skyStarCells), floor(phi * c_skyStarCells));\n            vec2 cellUV = vec2(fract(theta * c_skyStarCells), fract(phi * c_skyStarCells));\n\n            // make a star at a random place in the cell\n            float starRadius = hash12(cellIndex) * 0.1f + 0.07f;\n\t\t\tvec2 starPos = hash22(cellIndex) * (1.0f - starRadius * 2.0f) + starRadius;\n            float dist = sdStar(starPos - cellUV, starRadius, 4, 3.75f);\n            \n            dist *= pow(length(starPos - cellUV) / starRadius, 10.0f);\n                       \n            float value = step(dist, 0.0f);\n\t\t\tvalue *= pow(1.0f - clamp(length(starPos - cellUV) / starRadius, 0.0f, 1.0f), 3.0f);\n                        \n            hitInfo.material.emissive = mix(material.emissive, vec3(1.0f, 1.0f, 1.0f), value);            \n        }\n    }\n}\n\nSRayHitInfo TestSceneMarch(in vec3 rayPos)\n{\n    SRayHitInfo hitInfo;\n    hitInfo.hitAnObject = false;\n    hitInfo.dist = c_superFar;\n    \n    // glowing triangles\n    {\n\n        vec3 A = vec3(0.0f, 0.0f, 0.0f);\n        vec3 B = vec3(1.5f, 3.0f, 0.0f);\n        vec3 C = vec3(3.0f, 0.0f, 0.0f);\n        float lineWidth = 0.1f;\n        \n        vec3 center = (A + B + C) / 3.0f;\n        A -= center;\n        B -= center;\n        C -= center;\n        \n        A *= 3.0f;\n        B *= 3.0f;\n        C *= 3.0f;\n        \n        // foreground purple one\n        SMaterial material;\n        material.diffuse = vec3(0.0f, 0.0f, 0.0f);\n        material.specular = vec3(0.0f, 0.0f, 0.0f);\n        material.roughness = 0.0f;\n        material.emissive = pow(vec3(0.73f, 0.06f, 0.99f), vec3(2.2f, 2.2f, 2.2f)) * 10.0f;            \n\n        TestLineMarch(rayPos, hitInfo, A, B, lineWidth, material);\n        TestLineMarch(rayPos, hitInfo, B, C, lineWidth, material);\n        TestLineMarch(rayPos, hitInfo, C, A, lineWidth, material);\n        \n        // blue one slightly behind\n        material.emissive = pow(vec3(0.3f, 0.15f, 1.0f), vec3(2.2f, 2.2f, 2.2f)) * 10.0f;\n        A += vec3(0.0f, 0.0f, 5.0f);\n        B += vec3(0.0f, 0.0f, 5.0f);\n        C += vec3(0.0f, 0.0f, 5.0f);\n        TestLineMarch(rayPos, hitInfo, A, B, lineWidth, material);\n        TestLineMarch(rayPos, hitInfo, B, C, lineWidth, material);\n        TestLineMarch(rayPos, hitInfo, C, A, lineWidth, material);        \n        \n        // red one behind more\n        material.emissive = pow(vec3(1.0f, 0.15f, 0.3f), vec3(2.2f, 2.2f, 2.2f)) * 10.0f;\n        A += vec3(0.0f, 0.0f, 5.0f);\n        B += vec3(0.0f, 0.0f, 5.0f);\n        C += vec3(0.0f, 0.0f, 5.0f);\n        TestLineMarch(rayPos, hitInfo, A, B, lineWidth, material);\n        TestLineMarch(rayPos, hitInfo, B, C, lineWidth, material);\n        TestLineMarch(rayPos, hitInfo, C, A, lineWidth, material);              \n\t}    \n\n    // a neon cactus\n    {\n    \tSMaterial material;\n        material.diffuse = vec3(0.0f, 0.0f, 0.0f);\n        material.specular = vec3(0.0f, 0.0f, 0.0f);\n        material.roughness = 0.0f;\n        material.emissive = pow(vec3(0.73f, 0.06f, 0.99f), vec3(2.2f, 2.2f, 2.2f)) * 10.0f;\n        \n        vec3 cactusOffset = vec3(0.0f, 0.0f, 50.0f);\n        \n        // main body section\n        {\n            vec3 A = vec3(-40.0f, -10.0f, 0.0f) + cactusOffset;\n            vec3 B = vec3(-40.0f, 5.0f, 1.0f) + cactusOffset;\n            vec3 C = vec3(-40.0f, 20.0f, 0.0f) + cactusOffset;\n            TestBezierMarch(rayPos, hitInfo, A, B, C, 2.0f, material);\n        }\n        \n        // Arm going to left\n        {\n            vec3 A = vec3(-40.0f, 5.0f, 1.0f) + cactusOffset;\n            vec3 B = vec3(-32.5f, 10.0f, 0.0f) + cactusOffset;\n            vec3 C = vec3(-32.5f, 15.0f, -1.0f) + cactusOffset;\n            TestBezierMarch(rayPos, hitInfo, A, B, C, 1.0f, material);\n        }\n        \n        // Arm going to right\n        {\n            vec3 A = vec3(-40.0f, 2.0f, 1.0f) + cactusOffset;\n            vec3 B = vec3(-47.5f, 7.0f, 2.0f) + cactusOffset;\n            vec3 C = vec3(-47.5f, 13.0f, 4.0f) + cactusOffset;\n            TestBezierMarch(rayPos, hitInfo, A, B, C, 1.0f, material);\n        }        \n        \n    }\n\n    return hitInfo;\n}\n\n// =======================================================================\n// Ray Marching\n// =======================================================================\n\nvoid RayMarchScene(in vec3 startingRayPos, in vec3 rayDir, inout SRayHitInfo oldHitInfo)\n{\n    SMaterial dummyMaterial = SMaterial(vec3(0.0f, 0.0f, 0.0f), vec3(0.0f, 0.0f, 0.0f), 0.0f, vec3(0.0f, 0.0f, 0.0f));\n    \n    float rayDistance = c_minimumRayHitTime;\n    float lastRayDistance = c_minimumRayHitTime;\n    \n    float lastHitInfoDist = 0.0f;\n    \n    SRayHitInfo newHitInfo = oldHitInfo;\n    newHitInfo.hitAnObject = false;\n    \n    for (int stepIndex = 0; stepIndex < c_numSteps; ++stepIndex)\n    {\n        vec3 rayPos = startingRayPos + rayDistance * rayDir;\n        \n        newHitInfo = TestSceneMarch(rayPos);\n        \n        // these two lines are so that the material code goes away when the test functions are inlines\n        newHitInfo.normal = vec3(0.0f, 0.0f, 0.0f);\n        newHitInfo.material = dummyMaterial;\n        \n        newHitInfo.hitAnObject = newHitInfo.dist < 0.0f;\n        if (newHitInfo.hitAnObject)\n            break;\n        \n        lastRayDistance = rayDistance;\n        rayDistance += max(newHitInfo.dist, c_minStepDistance);\n\n        lastHitInfoDist = newHitInfo.dist;\n        \n        if (rayDistance > oldHitInfo.dist)\n            break;\n    }\n    \n    if (newHitInfo.hitAnObject)\n    {\n\t\tfloat refinedHitPercent = lastHitInfoDist / (lastHitInfoDist - newHitInfo.dist);\n        newHitInfo.dist = mix(lastRayDistance, rayDistance, refinedHitPercent);\n        \n        if (newHitInfo.dist < oldHitInfo.dist)\n            oldHitInfo = newHitInfo;\n    }\n}\n\n// =======================================================================\n// Iterative bounce ray tracing\n// =======================================================================\n    \nvec3 GetColorForRay(in vec3 startRayPos, in vec3 startRayDir, inout uint rngState)\n{\n    vec3 ret = vec3(0.0f, 0.0f, 0.0f);\n    vec3 colorMultiplier = vec3(1.0f, 1.0f, 1.0f);\n    \n    vec3 rayPos = startRayPos;\n    vec3 rayDir = startRayDir;\n       \n    for (int i = 0; i <= c_numBounces; ++i)\n    {\n        SRayHitInfo hitInfo;\n\t\thitInfo.hitAnObject = false;\n        hitInfo.dist = c_superFar;\n        \n        // ray trace first, which also gives a maximum distance for ray marching\n        RayTraceScene(rayPos, rayDir, hitInfo);\n        RayMarchScene(rayPos, rayDir, hitInfo);\n        \n        if (!hitInfo.hitAnObject)\n        {\n            // handle ray misses\n            ret += texture(iChannel1, rayDir).rgb * c_skyboxMultiplier * colorMultiplier;\n            break;\n        }\n                      \n        // update the ray position\n        rayPos += rayDir * hitInfo.dist;\n               \n        // get the material info if it was a ray marched object\n        if (hitInfo.rayMarchedObject)\n\t\t\thitInfo = TestSceneMarch(rayPos);       \n                \n\t\t// add in emissive lighting\n        ret += hitInfo.material.emissive * colorMultiplier;\n        \n        // figure out whether we are going to shoot out a specular or diffuse ray.\n        // If neither, exit\n        float diffuseLength = length(hitInfo.material.diffuse);        \n        float specularLength = length(hitInfo.material.specular);\n        if (diffuseLength + specularLength == 0.0f)\n            break;\n        float specularWeight = specularLength / (diffuseLength + specularLength);       \n        float doSpecular = float(RandomFloat01(rngState) < specularWeight);\n       \n        // set up the next ray direction\n        float roughness = mix(1.0f, hitInfo.material.roughness, doSpecular);\n        vec3 reflectDir = reflect(rayDir, hitInfo.normal);\n        vec3 randomDir = RandomUnitVector(rngState);\n        rayDir = normalize(mix(reflectDir, randomDir, roughness));\n        \n        if (dot(rayDir, hitInfo.normal) < 0.0f)\n            rayDir *= -1.0f;        \n        \n        // move the ray away from the surface it hit a little bit\n        rayPos += hitInfo.normal * c_rayPosNormalNudge;\n        \n        // Make all future light affected be modulated by either the diffuse or specular reflection color\n        // depending on which we are doing.\n        // Attenuate diffuse by the dot product of the outgoing ray and the normal (aka multiply diffuse by cosine theta or N dot L)\n        float NdotL = dot(hitInfo.normal, rayDir);\n        colorMultiplier *= mix(hitInfo.material.diffuse * NdotL, hitInfo.material.specular, doSpecular);        \n    }\n    \n    return ret;\n}\n\n// =======================================================================\n// Orbit Camera\n// =======================================================================\n\n\nvoid GetCameraVectors(out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraUp, out vec3 cameraRight)\n{   \n    vec2 mouse = iMouse.xy;\n    if (dot(mouse, vec2(1.0f, 1.0f)) == 0.0f)\n        mouse = c_defaultMousePos * iResolution.xy;\n    \n    float angleX = -mouse.x * 16.0f / float(iResolution.x);\n    float angleY = mix(c_minCameraAngle, c_maxCameraAngle, mouse.y / float(iResolution.y));\n    \n    cameraPos.x = sin(angleX) * sin(angleY) * c_cameraDistance;\n    cameraPos.y = -cos(angleY) * c_cameraDistance;\n    cameraPos.z = cos(angleX) * sin(angleY) * c_cameraDistance;\n    \n    cameraPos += c_cameraAt;\n    \n    cameraFwd = normalize(c_cameraAt - cameraPos);\n    cameraRight = normalize(cross(cameraFwd, vec3(0.0f, 1.0f, 0.0f)));\n    cameraUp = normalize(cross(cameraRight, cameraFwd));   \n}\n\n// =======================================================================\n// Main function\n// =======================================================================\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // initialize a random number state based on frag coord and frame\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    \n    // add sub pixel jitter for anti aliasing\n    vec2 fragCoordJittered = fragCoord + (vec2(RandomFloat01(rngState), RandomFloat01(rngState)) - 0.5f);\n    \n    // get the camera vectors\n    vec3 cameraPos, cameraFwd, cameraUp, cameraRight;\n    GetCameraVectors(cameraPos, cameraFwd, cameraUp, cameraRight);\n    \n    // calculate the ray direction for this pixel\n    vec2 uvJittered = fragCoordJittered/iResolution.xy;\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n    vec3 rayDir;\n    {   \n\t\tvec2 screen = uvJittered * 2.0f - 1.0f;\n        screen.y /= aspectRatio;\n                \n        float cameraDistance = tan(c_FOV * 0.5f * c_pi / 180.0f);       \n        rayDir = vec3(screen, cameraDistance);\n        rayDir = normalize(mat3(cameraRight, cameraUp, cameraFwd) * rayDir);\n    }\n    \n    // simulate a thin lens (depth of field and circular bokeh)\n    if (c_apertureRadius > 0.0f)\n    {\n        // calculate point on the focal plane\n        vec3 focalPlanePoint = cameraPos + rayDir * c_focalPlaneDistance;\n        \n        // calculate a random point on the aperture\n        float angle = RandomFloat01(rngState) * 2.0f * c_pi;\n\t\tfloat radius = sqrt(RandomFloat01(rngState)) * c_apertureRadius;\n\t\tvec2 offset = vec2(cos(angle), sin(angle)) * radius;\n        \n        // update the camera pos\n        cameraPos += offset.x * cameraRight + offset.y * cameraUp;\n        \n        // update the ray direction\n        rayDir = normalize(focalPlanePoint - cameraPos);  \n    }\n    \n    // get the linear color of the ray\n    vec3 color = GetColorForRay(cameraPos, rayDir, rngState);\n    \n    // integrate color with previous frame.\n    // incremental averaging: https://blog.demofox.org/2016/08/23/incremental-averaging/\n    bool spacePressed = (texture(iChannel2, vec2(KEY_SPACE,0.25)).x > 0.1);\n    vec4 oldColor = texture(iChannel0, fragCoord / iResolution.xy);\n    float blend = (oldColor.a == 0.0f || iMouse.z > 0.0 || spacePressed) ? 1.0f : 1.0f / (1.0f + (1.0f / oldColor.a));\n    color = mix(oldColor.rgb, color, blend);    \n    fragColor = vec4(color, blend);\n}", "buffer_a_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// =======================================================================\n// Constants\n// =======================================================================\n\nconst float c_pi = 3.14159265359f;\nconst float c_twopi = 2.0f * c_pi;\nconst float KEY_SPACE = 32.5/256.0;\n\n// =======================================================================\n// Parameters\n// =======================================================================\n\n// camera parameters\nconst vec3 c_cameraAt = vec3(0.0f, 0.0f, 0.0f);\nconst float c_cameraDistance = 80.0f;\nconst float c_apertureRadius = 0.4f;  // in world units. 0 for pinhole camera.\nconst float c_focalPlaneDistance = 80.0f; // in world units. How far from the camera things are in focus at.\nconst float c_minCameraAngle = c_pi / 2.0f - 0.125f;\nconst float c_maxCameraAngle = (c_pi - 0.01f);\nconst float c_exposure = 2.0f;  // +1 fstops of exposure\nconst float c_FOV = 90.0f; // in degrees\n\n// the place to put the mouse if it hasn't moved yet (aka the default view)\nconst vec2 c_defaultMousePos = vec2(140.0f / 800.0f, 40.0f / 450.0f);  // viewing the dark sun\n//const vec2 c_defaultMousePos = vec2(300.0f / 800.0f, 30.0f / 450.0f);  // viewing saturn\n\n// bloom parameters\nconst vec3 c_bloomMin = vec3(1.0f, 1.0f, 1.0f);\n// The array below is a 1d gaussian which starts at index 0.\n// A nice gaussian calculator is at http://dev.theomader.com/gaussian-kernel-calculator/\n// Just calculate a kernel that is (c_radius * 2 + 1) large and use the second half of the result (including the center).\n// That should give you an array that is (c_radius+1) items large.\n//const int c_bloomRadius = 3;\n//const float c_bloomKernel[c_bloomRadius+1] = float[c_bloomRadius+1](0.383103, 0.241843, 0.060626, 0.00598); // sigma 1.0\nconst int c_bloomRadius = 5;\n//const float c_bloomKernel[c_bloomRadius+1] = float[c_bloomRadius+1](0.382925, 0.24173, 0.060598, 0.005977, 0.000229, 0.000003); // sigma 1.0\nconst float c_bloomKernel[c_bloomRadius+1] = float[c_bloomRadius+1](0.163053, 0.150677, 0.118904, 0.080127, 0.046108, 0.022657); // sigma 2.5\n//const float c_bloomKernel[c_bloomRadius+1] = float[c_bloomRadius+1](0.109317, 0.107159, 0.100939, 0.091364, 0.079465, 0.066414); // sigma 5.0    \n\n// scene parameters\nconst float c_skyboxMultiplier = 0.0f; // for the cube map, if visible.\n\n// ray tracing parameters\nconst int c_numBounces = 4;\nconst float c_minimumRayHitTime = 0.1f;\nconst float c_superFar = 10000.0f;\n\n// ray marching parameters\nconst int c_numSteps = 256;\nconst float c_minStepDistance = 0.1f;\n\n// other parameters\nconst float c_rayPosNormalNudge = 0.01f; // after a hit, it moves the ray this far along the normal away from a surface\n\n// =======================================================================\n// Display Adaptation Functions\n// =======================================================================\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n\nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n    \n    return mix(\n        pow(rgb * 1.055f, vec3(1.f / 2.4f)) - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\n// =======================================================================\n// Bloom Functions\n// =======================================================================\n\nvec3 BloomPass1(in vec2 pixelPos, in vec2 resolution, in sampler2D linearImage)\n{\n    // horizontal & conditional\n    vec3 sum = vec3(0.0f, 0.0f, 0.0f);\n    for (int ix = -c_bloomRadius; ix <= c_bloomRadius; ++ix)\n    {\n        vec3 pixelColor = texture( linearImage, (pixelPos + vec2(ix, 0))/resolution.xy).rgb;\n        vec3 bloomColor = clamp(pixelColor - c_bloomMin, 0.0f, 1.0f);\n        \n        bloomColor = (dot(bloomColor, c_bloomMin) > 0.0f ? bloomColor : vec3(0.0f, 0.0f, 0.0f));\n\n        float weight = c_bloomKernel[abs(ix)];\n        sum += bloomColor * weight;\n    }\n    \n    return sum;\n}\n\nvec3 BloomPass2(in vec2 pixelPos, in vec2 resolution, in sampler2D bloomImage)\n{\n    // vertical\n    vec3 sum = vec3(0.0f, 0.0f, 0.0f);\n    for (int iy = -c_bloomRadius; iy <= c_bloomRadius; ++iy)\n    {\n        vec3 bloomColor = texture( bloomImage, (pixelPos + vec2(0, iy))/resolution.xy).rgb;\n        float weight = c_bloomKernel[abs(iy)];\n        sum += bloomColor * weight;\n    }\n    \n    return sum;\n}\n\n// =======================================================================\n// RNG Functions\n// =======================================================================\n\n// from \"Hash without Sine\" https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec3 RandomUnitVector(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * c_twopi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\n// =======================================================================\n// Misc Functions\n// =======================================================================\n\nfloat MaxComp(vec3 v)\n{\n    return max(v.x, max(v.y, v.z));\n}\n\nint MaxCompIndex(vec3 v)\n{\n    if (v.x > v.y)\n    {\n        if (v.x > v.z)\n            return 0;\n        else\n            return 2;\n    }\n    else\n    {\n        if (v.y > v.z)\n            return 1;\n        else\n            return 2;\n    }\n}\n\nfloat Bias(float x, float bias)\n{\n  return (x / ((((1.0f/bias) - 2.0f)*(1.0f - x))+1.0f));\n}\n\nfloat dot2(in vec3 v ) { return dot(v,v); }\n\n// =======================================================================\n// Distance Functions 2D\n// https://iquilezles.org/articles/distfunctions2d\n// =======================================================================\n\nfloat sdEquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdRoundedX( in vec2 p, in float w, in float r )\n{\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\nfloat sdStar(in vec2 p, in float r, in int n, in float m)\n{\n    // next 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;  // m is between 2 and n\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon,\n\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n  return length(p) - r;\n}\n\n// =======================================================================\n// Distance Functions 3D\n// https://iquilezles.org/articles/distfunctions\n// =======================================================================\n\nfloat SphereDistance(in vec4 sphere, in vec3 point)\n{\n    return length(point - sphere.xyz) - sphere.w;\n}\n\nfloat PlaneDistance(in vec4 plane, in vec3 point)\n{\n    return (dot(plane.xyz, point) - plane.w) / dot(plane.xyz, plane.xyz);\n}\n\nfloat BoxDistance(in vec3 boxPos, in vec3 boxRadius, in float width, in vec3 point)\n{\n    point -= boxPos;\n    width = max(width, 0.01f);  // fix for a problem i didn't investigate :P\n    \n    // from https://www.youtube.com/watch?reload=9&v=62-pRVZuS5c\n    // rounding the box from https://www.youtube.com/watch?v=s5NGeUV2EyU\n    vec3 q = abs(point) - boxRadius;\n    return length(max(q,vec3(0.0f,0.0f,0.0f))) + min(MaxComp(q), 0.0f) - width;\n}\n\nfloat LineDistance(in vec3 A, in vec3 B, float width, in vec3 point, out vec3 normal)\n{\n\tvec3 AP = point - A;\n    vec3 AB = B - A;\n    \n    // from https://www.youtube.com/watch?v=PMltMdi1Wzg\n    // added normal calculation though\n    float h = min(1.0f, max(0.0f, dot(AP, AB) / dot(AB, AB)));\n    vec3 closestPoint = A + h * AB;\n    normal = normalize(point - closestPoint);\n    return length(point - closestPoint) - width;\n}\n\nfloat BezierDistance( in vec3 pos, in vec3 A, in vec3 B, in vec3 C, in float width)\n{    \n    vec3 a = B - A;\n    vec3 b = A - 2.0*B + C;\n    vec3 c = a * 2.0;\n    vec3 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res ) - width;\n}\n\n// =======================================================================\n// Object Intersection Helpers for Ray Marching\n// =======================================================================\n\nstruct SMaterial\n{\n    vec3 diffuse;\n    vec3 specular;\n\tfloat roughness;\n    vec3 emissive;    \n};\n\nstruct SRayHitInfo\n{\n    bool hitAnObject;\n    bool rayMarchedObject;\n    float dist;\n    vec3 normal;\n    SMaterial material;\n};\n    \nvoid TestSphereMarch(in vec3 rayPos, inout SRayHitInfo info, in vec4 sphere, in SMaterial material)\n{\n    float dist = SphereDistance(sphere, rayPos);\n    if (dist < info.dist)\n    {\n        info.rayMarchedObject = true;\n        info.dist = dist;        \n        info.normal = normalize(rayPos - sphere.xyz);\n        info.material = material;\n    }    \n}\n\nvoid TestPlaneMarch(in vec3 rayPos, inout SRayHitInfo info, in vec4 plane, in SMaterial material)\n{\n    float dist = PlaneDistance(plane, rayPos);\n    if (dist < info.dist)\n    {\n        info.rayMarchedObject = true;\n        info.dist = dist;        \n        info.normal = plane.xyz;\n        info.material = material;\n    }    \n}\n\nvoid TestBoxMarch(in vec3 rayPos, inout SRayHitInfo info, in vec3 boxPos, in vec3 boxRadius, in float width, in SMaterial material)\n{\n    float dist = BoxDistance(boxPos, boxRadius, width, rayPos);\n    if (dist < info.dist)\n    {\n        info.rayMarchedObject = true;\n        info.dist = dist;\n        \n        vec3 relPos = max(abs(rayPos - boxPos) - boxRadius, 0.0f);\n        int maxIndex = MaxCompIndex(relPos);\n        if (maxIndex == 0)\n        {\n            info.normal = (rayPos.x < boxPos.x) ? vec3(-1.0f, 0.0f, 0.0f) : vec3(1.0f, 0.0f, 0.0f);\n        }\n        else if(maxIndex == 1)\n        {\n            info.normal = (rayPos.y < boxPos.y) ? vec3(0.0f, -1.0f, 0.0f) : vec3(0.0f, 1.0f, 0.0f);\n        }\n        else\n        {\n            info.normal = (rayPos.z < boxPos.z) ? vec3(0.0f, 0.0f, -1.0f) : vec3(0.0f, 0.0f, 1.0f);\n        }\n        \n        info.material = material;\n    }    \n}\n\nvoid TestLineMarch(in vec3 rayPos, inout SRayHitInfo info, in vec3 A, in vec3 B, in float width, in SMaterial material)\n{   \n    vec3 normal;\n    float dist = LineDistance(A, B, width, rayPos, normal);\n    if (dist < info.dist)\n    {\n        info.rayMarchedObject = true;\n        info.dist = dist;        \n        info.normal = normal;\n        info.material = material;\n    }    \n}\n\nvoid TestBezierMarch(in vec3 rayPos, inout SRayHitInfo info, in vec3 A, in vec3 B, in vec3 C, in float width, in SMaterial material)\n{\n    float dist = BezierDistance(rayPos, A, B, C, width);\n    if (dist < info.dist)\n    {\n        info.rayMarchedObject = true;\n        info.dist = dist;    \n        info.normal = vec3(1.0f, 0.0f, 0.0f); // TODO: normal, if you ever need it!\n        info.material = material;\n    }    \n}\n\n// =======================================================================\n// Object Intersection Helpers for Ray Tracing\n// =======================================================================\n\nbool TestPlaneTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 plane, in SMaterial material)\n{\n    float dist = -1.0f;\n    float denom = dot(plane.xyz, rayDir);\n    if (abs(denom) > 0.001f)\n    {\n        dist = (plane.w - dot(plane.xyz, rayPos)) / denom;\n    \n        if (dist > c_minimumRayHitTime && dist < info.dist)\n        {\n            info.hitAnObject = true;\n            info.rayMarchedObject = false;\n            info.dist = dist;        \n            info.normal = plane.xyz;\n            info.material = material;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool TestSphereTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 sphere, in SMaterial material)\n{\n\t//get the vector from the center of this sphere to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n    \n\t//ray now found to intersect sphere, compute smallest t value of intersection\n    bool fromInside = false;\n\tfloat dist = -b - sqrt(discr);\n    if (dist < 0.0f)\n    {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n    \n\tif (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.hitAnObject = true;\n        info.rayMarchedObject = false;\n        info.dist = dist;        \n        info.normal = normalize((rayPos+rayDir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);\n\t\tinfo.material = material;        \n        return true;\n    }\n    \n    return false;\n}\n\n// Tests against a vertical cylinder without caps\n// Derived from the sphere function and not super optimal but whatever.\nbool TestCylinderTrace(in vec3 rayPos_, in vec3 rayDir_, inout SRayHitInfo info, in vec3 pos, in float radius, in float height, in SMaterial material)\n{\n    vec3 relativeRayPos = rayPos_ - pos;\n    vec3 projectedRayPos = vec3(relativeRayPos.x, 0.0f, relativeRayPos.z);\n    vec3 projectedRayDir = vec3(rayDir_.x, 0.0f, rayDir_.z);\n    \n    float lengthCorrection = length(projectedRayDir);\n    projectedRayDir /= lengthCorrection;\n    \n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = projectedRayPos;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, projectedRayDir);\n\n\tfloat c = dot(m, m) - radius * radius;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n    \n\t//ray now found to intersect sphere, compute smallest t value of intersection\n    bool fromInside = false;\n\tfloat dist = -b - sqrt(discr);\n    if (dist < 0.0f)\n    {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n\n    // adjust distance\n    dist /= lengthCorrection;\n\n    // enforce height - note we may be invalid height for the first distance but not the second.\n    vec3 relativeHitPos = relativeRayPos + rayDir_ * dist;\n    if (relativeHitPos.y < 0.0f || relativeHitPos.y > height)\n    {\n        dist = -b + sqrt(discr);\n        dist /= lengthCorrection;\n        relativeHitPos = relativeRayPos + rayDir_ * dist;\n        if (relativeHitPos.y < 0.0f || relativeHitPos.y > height)\n      \t\treturn false;\n    }\n        \n\tif (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.hitAnObject = true;\n        info.rayMarchedObject = false;\n        info.dist = dist;        \n        info.normal = normalize(vec3(relativeHitPos.x, 0.0f, relativeHitPos.z)) * (fromInside ? -1.0f : 1.0f);\n\t\tinfo.material = material;        \n        return true;\n    }\n    \n    return false;\n}\n\n/*\n\n============================================\n\nNon PBR Path tracer version 1.\n\n* ray traced objects & ray marched objects\n* thin lens simulation (depth of field and bokeh) with a circular aperture.\n* bloom\n\nBranched to: https://www.shadertoy.com/view/wslfzX\n\n============================================\n\nmake a more traditional path traced scene next, just to have it?\n\n============================================\n\nImprovements for future versions (other shadertoys)...\n\n* blue noise for low sample counts. maybe low discrepancy sequences too for more than low sample counts.\n\n* spectral path tracing - different material properties for different wavelengths of light.\n\n* transparency & refraction?\n * would need ot be able to be inside of objects. maybe only allow for raytracing?\n * maybe combine this with subsurface scattering?\n\n* participating media:\n * https://www.alanzucconi.com/2017/10/10/atmospheric-scattering-1/\n * https://shaderbits.com/blog/creating-volumetric-ray-marcher\n * https://www.shadertoy.com/view/tsScDG\n * also: do low step count ray marching, but use blue noise to offset each ray ftw!\n\n* subsurface scattering\n * https://my.eng.utah.edu/~darais/classes/cs6620/project/index.html\n * https://www.fxguide.com/fxfeatured/pixar-deep-dive-on-sss-siggraph-preview/\n\n* lens flare\n* motion blur\n* fresnel\n\n*/", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Does first pass of Bloom (horizontal & conditional)\n    fragColor = vec4(BloomPass1(fragCoord.xy, iResolution.xy, iChannel0), 1.0f);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXBW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 292, 771]], "test": "untested"}
{"id": "wslBDH", "name": "Merci Bokeh", "author": "wyatt", "description": "Bifurcation of points in parallel - makes for some extreme rendering potential. Use the speed up if you have the plugin. ", "tags": ["fractaljfa"], "likes": 11, "viewed": 499, "published": 3, "date": "1588196449", "time_retrieved": "2024-07-30T21:09:48.423485", "image_code": "// Fork of \"Tree Study\" by wyatt. https://shadertoy.com/view/3dlfWn\n// 2020-04-29 20:14:04\n\nMain { Q = B(U); }", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texelFetch(iChannel2,ivec2(U),0)\n#define D(U) texelFetch(iChannel3,ivec2(U),0)\n#define pi 3.14159265359\n#define phi 1.61803398875\n#define Main void mainImage(out vec4 Q, vec2 U) \n#define e(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define N 12.\n#define I 12.\nvec2 hash22(vec2 p) // Dave H\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nfloat sg (vec2 p, vec2 a, vec2 b) {\n    return  length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n    \n}", "buffer_a_code": "void Y (inout vec4 Q, vec2 U, vec4 n) {\n\tif ((length(U-Q.xy)>=length(U-n.xy)||length(Q.xy)<3.)&&\n        length(n.xy)>3.) Q = n;\n}\nMain {\n    U = round(U);\n\tQ = A(U);\n    Q = round(Q);\n    float iN = mod(float(iFrame),N);\n    if (iN<.5) {\n        if (mod(float(iFrame),N*I)<.5) {\n           Q = vec4(R.x*(0.5),\n                    0.4*R.y,\n                    R.x*(0.5),\n                    -R.x*.1);\n        } else {\n            vec4 t = Q;\n            float n = floor(U.x+U.y*R.x);\n            float a = mod(mod(float(iFrame),41.),6.)+1.;\n            float s = 1.;//(1.+mod(n,a))-ceil(0.5*a);\n            float b = 1.;\n            float l = (mod(n,2.));\n            float an = iTime*.2*sign(l*2.-1.)*phi*pi;\n            t.xy = Q.xy-.7*(Q.zw-Q.xy)*e(an);\n        \tt.zw = Q.xy;\n            if (iN<1.) Q = t;\n            else Y(Q,U,t);\n        }\n    }\n    else {\n        float k = exp2(N-1.-mod(float(iFrame),N));\n    \tY(Q,U,A(U+vec2(0,k)));\n    \tY(Q,U,A(U+vec2(k,0)));\n    \tY(Q,U,A(U-vec2(0,k)));\n    \tY(Q,U,A(U-vec2(k,0)));\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n    vec4 b = B(U);\n    float iN = mod(float(iFrame),N);\n    float IN = mod(float(iFrame)/N,I);\n    if (iN>N-2.&&IN>1.) {\n        vec4 a = A(U);\n        float l = length(a.xy-a.zw);\n        if (length(a.xy)<3.||length(a.zw)<3.){Q = B(U); return;}\n        float r = length(U-a.xy);\n        Q = (0.7+0.5*sin(\n            2.*sin(.1*float(iFrame))+\n            .01*float(iFrame)+\n            (4.+mod(float(iFrame),N*I))/N/I*(vec4(1,2,3,4))));\n        float p = (.1*l);\n        float x = (smoothstep(.3*p,.2*p,abs(r-2.5*p))*0.5+smoothstep(3.*p,2.*p,r))/(1.+.05*l);\n        Q  = mix(b,Q,0.5*x);\n    } else {\n         vec4 m = 0.25*(B(U+vec2(0,1))+B(U+vec2(1,0))+B(U-vec2(0,1))+B(U-vec2(1,0)));\n        Q = b = mix(b,m*0.99,.05);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslBDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "wdsfD8", "name": "Interference fractal", "author": "michael0884", "description": "Messing with PBR BRDF's", "tags": ["brdf"], "likes": 18, "viewed": 539, "published": 3, "date": "1588189916", "time_retrieved": "2024-07-30T21:09:49.482654", "image_code": "#define fracaxis normalize(vec3(2.+sin(iTime),2,3.+cos(iTime)))\n#define fracangle 1.\n#define fracscale 1.2\n#define fracshift vec4(0.05*sin(0.2*iTime), 0.1,0.+0.05*cos(0.2*iTime),0.)\n\n//fractal matrix\nmat4 fmat;\n\nfloat sdFract(vec3 p)\n{\n    vec4 cp = vec4(p,1.);\n    for(int i = 0; i < 16; i++)\n    {\n        cp = fmat*cp + fracshift;\n        mengerFold(cp);\n    }\n    return sdBox(cp.xyz + fracshift.xyz, vec3(0.5))/cp.w;\n}\n\nvec3 sdFractCol(vec3 p)\n{\n    p.xy = mod(p.xy + vec2(2.), vec2(4.)) - vec2(2);\n    vec4 cp = vec4(p,1.);\n    vec3 c = vec3(1,2,1);\n    for(int i = 0; i < 6; i++)\n    {\n        cp = fmat*cp + fracshift;\n        mengerFold(cp);\n        c = min(c,cp.xyz); \n    }\n    return tanh(abs(c));\n}\n\nvec2 map(vec3 p)\n{\n    p.xy = mod(p.xy + vec2(2.), vec2(4.)) - vec2(2);\n    vec2 d = vec2(sdFract(p), 0);\n    d = minid( vec2(p.z + 1., 1), d);\n    return d;\n}\n\nvec4 normal(vec3 p, float dx) {\n\tconst vec3 k = vec3(1,-1,0);\n\tvec4 r = k.xyyx*map(p + k.xyy*dx).x +\n\t\t\t k.yyxx*map(p + k.yyx*dx).x +\n\t\t\t k.yxyx*map(p + k.yxy*dx).x +\n\t\t\t k.xxxx*map(p + k.xxx*dx).x;\n    //the normal and the averaged distance\n    return vec4(normalize(r.xyz), r.w*0.25);\n}\n\nvec4 march(vec3 p, vec3 r)\n{\n    float td = 0.;\n    vec2 d;\n    for(int i = 0; i < MAXI; i++)\n    {\n        d = map(p + td*r);\n        if(d.x <= LOD*td) break;\n        if(td > MAXD) \n        {\n            d.y = -1.;\n            break;\n        }\n        td += d.x;\n    }\n    td += d.x - LOD*td; //better surface\n    return vec4(p + td*r, d.y); //position and ID\n}\n\n#define AOscale 30.\nfloat AO(vec3 p, vec3 n, float td)\n{\n    vec2 de = map(p+AOscale*n*td*LOD);\n    return max(0.,tanh(de.x/(AOscale*td*LOD)));\n}\n\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 HDRmapping(vec3 color, float exposure)\n{\n\t// Exposure tone mapping\n    vec3 mapped = ACESFilm(color * exposure);\n    // Gamma correction \n    return pow(mapped, vec3(1.0 / 2.2));\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n    LOD = 1.4/max(iResolution.x,iResolution.y);\n    fmat = fracscale*rotationMatrix(fracaxis, fracangle);\n    \n    vec2 uv = (pos - 0.5*iResolution.xy)/iResolution.x;\n    vec2 angle = (iMouse.z>0.)?(vec2(2.*PI, PI)*iMouse.xy/iResolution.xy - vec2(0,PI*0.5)):vec2(PI+0.2*iTime, 0.);\n\tvec3 r = getRay(angle, uv), cr = getRay(angle, vec2(0));\n    vec3 p = -0.6*cr;\n    \n    vec4 res = march(p, r);\n    float td = distance(res.xyz,p);\n    p = res.xyz;\n    \n    vec3 L = vec3(0,1,0);\n   \n    col.xyz = vec3(0.);\n    if(res.w < 0.)\n    {\n        col.xyz = sky(r);\n    }\n    else\n    {\n        vec4 n = normal(p, td*LOD);\n    \tmat a = materials[int(res.w)];\n        if(res.w == 0.)\n        \ta.albedo = sdFractCol(p - n.xyz*n.w);\n        float ao = AO(p, n.xyz, td);\n        //a few light sources\n       \tcol.xyz += BRDF(-r, vec3(cos(0.5),0,sin(0.5)), n.xyz, a);\n        col.xyz += BRDF(-r, vec3(0,cos(1.),sin(1.)), n.xyz, a);\n        col.xyz += BRDF(-r, vec3(0,sin(1.),cos(1.)), n.xyz, a)*3.;\n        col.xyz += BRDF(-r, vec3(0,-sin(1.),-cos(1.)), n.xyz, a);\n        col.xyz*=ao*sky(vec3(1.,0.,0.));\n    }\n    col = vec4(HDRmapping(col.xyz, 6.),1.);\n}", "image_inputs": [], "common_code": "#define PI 3.14159265\n\nfloat sqr(float x)\n{\n    return x*x;\n}\n\nfloat sdSph( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvoid mengerFold(inout vec4 z) \n{\n\tfloat a = min(z.x - z.y, 0.0);\n\tz.x -= a; z.y += a;\n\ta = min(z.x - z.z, 0.0);\n\tz.x -= a; z.z += a;\n\ta = min(z.y - z.z, 0.0);\n\tz.y -= a; z.z += a;\n}\n\nvec2 minid(vec2 a, vec2 b)\n{\n    return (a.x<b.x)?a:b;\n}\n\nstruct mat\n{\n    vec3 albedo;\n    vec3 emiss;\n    float rough;\n    float metal;\n};\n    \nmat materials[3] = mat[3](mat(vec3(1.,0.02,0), vec3(0), 0.4, 0.2),\n    \t\t\t          mat(vec3(0.9,0.9,1.), vec3(0), 0.6, 0.2),\n                          mat(vec3(0.5,0.9,0.2), vec3(0), 0.1, 0.4));\n\n                  \n#define MAXD 64.\n#define MAXI 128\n#define FOV 1.5\nfloat LOD;\n\n\nmat3 getCamera(vec2 angles)\n{\n   mat3 theta_rot = mat3(1,   0,              0,\n                          0,   cos(angles.y),  sin(angles.y),\n                          0,  -sin(angles.y),  cos(angles.y)); \n        \n   mat3 phi_rot = mat3(cos(angles.x),   sin(angles.x), 0.,\n        \t\t       -sin(angles.x),   cos(angles.x), 0.,\n        \t\t        0.,              0.,            1.); \n        \n   return theta_rot*phi_rot;\n}\n\nvec3 getRay(vec2 angles, vec2 pos)\n{\n    mat3 camera = getCamera(angles);\n    return normalize(transpose(camera)*vec3(FOV*pos.x, 1., FOV*pos.y));\n}\n\nfloat NGGX(vec3 n, vec3 h, float a)\n{\n    float a2 = sqr(a);\n    return a2/(PI*sqr( sqr( max(dot(n,h),0.) )*(a2-1.) + 1.));\n}\n\nfloat GGX(vec3 n, vec3 o, float a)\n{\n    float ndoto = max(dot(n,o),0.);\n    return ndoto/mix(1., ndoto, sqr(a+1.)*0.125);\n}\n\nfloat GS(vec3 n, vec3 i, vec3 o, float a)\n{\n    return GGX(n,i,a)*GGX(n,o,a);\n}\n\nvec3 IR(float D, float k0, vec3 k1)\n{\n    //interference effect here ->\n    return (0.25+ k0*( 1. - cos(2.*PI*pow(vec3(D), -k1)) ))/D ;\n}\n\nvec3 BRDF(vec3 i, vec3 o, vec3 n, mat m)\n{\n    vec3 h = normalize(i + o);\n    vec3 F0 = mix(vec3(0.04), m.albedo, m.metal);\n    vec3 FS = F0 + (1.0 - F0) * pow(1.0 - max(dot(h, i), 0.0), 5.0);\n    vec3 DFG = NGGX(n,h,m.rough)*GS(n,i,o,m.rough)*FS;\n    float denom = max(dot(n, i), 0.001) * max(dot(n, o), 0.001);\n    return (m.albedo*(1.-FS)/PI +\n            DFG*IR(denom, 1., vec3(1.,1.1,1.2)))*max(0., dot(n,o));\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n\nvec3 sky(vec3 r)\n{\n    vec3 c = vec3(.009, .288, .828);\n\tc = mix(vec3(1.), c, .9);\n\tc *= .5;\n    float atmo = tanh(10.*(r.z-0.05))*0.4 + 0.5 + 0.1*r.z;\n    \n    vec3 g = vec3(atmo);  \n    vec3 A0 = pow(c, g);\n    vec3 B0 = 1.-pow(vec3(1.)-c, 1.-g);\n    \n    vec3 A = A0*(1.-A0);\n    vec3 B = B0*(1.-B0);\n    \n    return mix(A, B, g);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsfD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[212, 212, 235, 235, 423], [425, 425, 450, 450, 711], [713, 713, 731, 731, 872], [874, 874, 905, 905, 1162], [1164, 1164, 1192, 1192, 1526], [1548, 1548, 1584, 1584, 1673], [1676, 1676, 1699, 1699, 1839], [1841, 1841, 1886, 1912, 2026], [2028, 2028, 2073, 2073, 3218]], "test": "untested"}
{"id": "3ssfD8", "name": "distantringsoflight", "author": "nabr", "description": "experimenting with feedback and delay.", "tags": ["sound", "rings", "space", "practice", "delay", "reverberation"], "likes": 7, "viewed": 385, "published": 3, "date": "1588177292", "time_retrieved": "2024-07-30T21:09:50.237635", "image_code": "void mainImage(out vec4 O, in vec2 U)\n{\n    #define t iTime\n    vec2 R = iResolution.xy;\n    vec3 d = vec3((U - .5 * R) / min(R.x, R.y), .5+(sin(t)*.1+.1));\n    vec3 dn = vec3(.314, 1.57, 6.28), dc = vec3(0, 0, 3), c = vec3(sin(t) * .3, .2, .89);\n    if (all(lessThan(abs(d.xy), vec2(.6))))\n    {\n        for (int i = 0; i < 6; ++i)\n        {\n            dn = (cos(.5 * t) * dn - sin(.5 * t) * vec3(dn.y, -dn.x, cos(.5 * t)));\n            vec3 D = dot(dn, dc - d) / dot(dn, d) * d - dc;\n            float r = 1. - length(3. - dot(D, D));\n            if (r > .5)\n            {\n                vec3 p = r * D + d;\n                vec3 l = normalize(20. * vec3(cos(t), sin(t), 1));\n                c = .58 - length(r) + vec3(1, .415, .1) * max(0., 1. - dot(l + p, -p));\n            }\n            d += dot(-.0215 * dc, 2. * d) * dc;\n        }\n        c = 1. - dot(vec3(.2, .5, 1), c) * vec3(.9);\n    }\n    else\n        c = vec3(.051) * float(int(t + U * 2.) & 2);\n    O = vec4(c, 1);\n}", "image_inputs": [], "sound_code": "// -----------------------------------------------------\n// distantringsoflight by nabr\n// https://www.shadertoy.com/view/3ssfD8\n// License Creative Commons Attribution-NonCommercial 4.0 International (CC BY-NC 4.0)\n// https://creativecommons.org/licenses/by-nc/4.0/\n// -----------------------------------------------------\n// bandcamp:\n// https://tolka-nabroski.bandcamp.com/track/distant-rings-of-light\n\n#define SR iSampleRate\n#define e 1e-3\nfloat intfract(int, float);\n// synth\nfloat synth(int samp, float rt)\n{\n    uint uta=uint(.125*rt);\n    float rs2=(2.*rt),ft=mod(rs2,1.),\n          a=sqrt(2.*ft*exp(log2((1.+1e-5)-ft)/(.5+ft)));//attack/decay\n    float p0ar[4u]=float[4u](491.,291.,251.,e);\n    float p1ar[12u]=float[12u](1000.,e,e,e,e,e,e,1120.,880.,e,600.,e);\n    //freq\n    float[4u]p0a=float[4u](0.,0.,0.,0.);\n    p0a[0u]=440.;p0a[1u]=720.;\n    p0a[2u]=samp>=1411200?p0ar[((1315313u%(uta+1u))%3u)]:491.;//44100*32\n    p0a[3u]=991.;\n    return(sin(6.283185*intfract(samp,SR/p0a[uint(rs2)%4u]))\n           +sin(6.283185*intfract(samp,SR/p1ar[uta%12u])))*a;\n}\n// reverberation\nconst float[6u]ha=float[6u](.184089,.118295,.074423,.046412,.029080,.018004);\nconst uint sz = 6u; //uint(ha.length());\nvec2[6u]z; //=vec2[6u](vec2(1e-3),vec2(1e-3),vec2(1e-3),vec2(1e-3),vec2(1e-3),vec2(1e-3));\nvec2[sz]stdly(in vec2 v,out float t,in int sn)\n{\n    float rsn=(float(sn)/SR),cds=rsn+(.25*t);//copy dry timesignal\n    t+=ha[uint(rsn/SR)%sz];\n    rsn+=t;\n    // wet + dry * rot\n    v.x=synth(sn/2,rsn)+.251*synth(sn,cds)*(cos(t)+sin(t));\n    v.y=synth(sn/2,rsn)+.251*synth(sn,cds)*(-sin(t)+cos(t));\n    // unroll for mobile and similar z =vec2[](v, v, v, v, v, v);\n    z[0]=v;z[1]=v;z[2]=v;z[3]=v;z[4]=v;z[5]=v;\n    return z;\n}\nvec2 mainSound( in int s,float time)\n{\n   // int block=int((iBlockOffset+0.5)*iSampleRate/(512.*512.));\n   // int s=512*512*block+512*int(gl_FragCoord.y)+int(gl_FragCoord.x);\n    vec2 snd=vec2(1e-3),v=vec2(1e-3);\n    float t=float(s)/SR;\n    for(uint j=0u;j<3u;++j)\n        for(uint i=0u;i<sz;++i)\n            snd+=stdly(v,t,s)[i];\n    // --------out\n    return snd*0.027778;//(6.*float(sz))\n}\nfloat intfract(int s,float n)\n{\n    // Explanation and copyright: shadertoy.com/view/4ltfRN\n    int sn=int(n),a=s%sn,b=(s/sn);\n    const float MAXF=float(uint(-1))+1.;\n    return fract((float(a)/n)+float((uint(b)*uint(MAXF*float(sn)/n)))/MAXF);\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ssfD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 981]], "test": "untested"}
{"id": "3dlfDH", "name": "Fractal Tomography", "author": "dr2", "description": "Looking inside the Mandelbox and Mandalay fractals", "tags": ["mandelbox", "mandalay"], "likes": 4, "viewed": 421, "published": 3, "date": "1588175885", "time_retrieved": "2024-07-30T21:09:51.003587", "image_code": "// \"Fractal Tomography\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n Looking inside the Mandelbox and Mandalay fractals.\n Step-through showing slices overlaid on full view.\n Mouse-x rotates, -y zooms\n*/\n\n#define M_TYPE   0  // = 0/1 for Mandelbox / Mandalay fractals\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nvec3 HsvToRgb (vec3 c);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\n\nvec3 ltDir, pFold;\nfloat tCur, dstFar, mScale, bxLim, slPos, slWid;\nint mType;\nconst int itMax = 12;\nbool isTrans;\nconst float pi = 3.14159;\n\nfloat PPFoldD (vec3 p)\n{\n  vec3 s;\n  p.y = max (p.y, p.z);\n  s = vec3 (p.x, max (abs (p.x - pFold.x) - pFold.x, p.y - 4. * pFold.x),\n     max (p.x - 2. * pFold.x - pFold.y, p.y - pFold.z));\n  return Minv3 (s);\n}\n\nvec3 PPFold (vec3 p)\n{\n  return vec3 (PPFoldD (p), PPFoldD (p.yzx), PPFoldD (p.zxy));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec4 p4;\n  float d;\n  p4 = vec4 (p, 1.);\n  for (int j = 0; j < itMax; j ++) {\n    p4.xyz = 2. * clamp (p4.xyz, -1., 1.) - p4.xyz;\n    if (mType == 1) p4.xyz = - sign (p4.xyz) * PPFold (abs (p4.xyz));\n    p4 = mScale * p4 / clamp (dot (p4.xyz, p4.xyz), 0.25, 1.) + vec4 (p, 1.);\n  }\n  d = max (length (p4.xyz) / p4.w, PrBoxDf (p, vec3 (bxLim)));\n  if (! isTrans) d = max (d, abs (p.z - slPos) - slWid);\n  return d;\n}\n\nvec3 ObjTDist (vec3 p)\n{\n  vec4 p4;\n  vec3 pMin;\n  pMin = vec3 (1.);\n  p4 = vec4 (p, 1.);\n  for (int j = 0; j < itMax; j ++) {\n    p4.xyz = 2. * clamp (p4.xyz, -1., 1.) - p4.xyz;\n    if (mType == 1) p4.xyz = - sign (p4.xyz) * PPFold (abs (p4.xyz));\n    pMin = min (pMin, abs (p4.xyz));\n    p4 = mScale * p4 / clamp (dot (p4.xyz, p4.xyz), 0.25, 1.) + vec4 (p, 1.);\n  }\n  return pMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, h, s, sLo, sHi, eps;\n  eps = 0.0005;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    h = ObjDf (ro + s * rd);\n    if (h < eps || s > dstFar) {\n      sHi = s;\n      break;\n    }\n    sLo = s;\n    s += h;\n  }\n  if (h < eps) {\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      if (ObjDf (ro + s * rd) > eps) sLo = s;\n      else sHi = s;\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, colT, vn, roo;\n  float dstObj, dstObjT;\n  bool isBg;\n  mScale = (mType == 1) ? 3. : 2.5;\n  roo = ro;\n  isTrans = false;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    isBg = false;\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col = HsvToRgb (vec3 (mod (0.2 + 0.15 * Maxv3 (abs (ObjTDist (ro))), 1.), 0.5, 1.)) *\n       (0.3 + 0.7 * max (dot (vn, ltDir), 0.)) +\n       0.1 * pow (max (0., dot (ltDir, reflect (rd, vn))), 16.);\n   } else {\n    isBg = true;\n    col = vec3 (0.3, 0.3, 0.3);\n  }\n  isTrans = true;\n  ro = roo;\n  dstObjT = ObjRay (ro, rd);\n  if (dstObjT < min (dstObj, dstFar)) {\n    ro += dstObjT * rd;\n    vn = ObjNf (ro);\n    colT = HsvToRgb (vec3 (mod (0.2 + 0.15 * Maxv3 (abs (ObjTDist (ro))), 1.), 0.5, 1.)) *\n       (0.3 + 0.7 * max (dot (vn, ltDir), 0.));\n    colT = mix (colT, vec3 (0.6, 0.65, 0.6) * smoothstep (0., 1., Maxv3 (colT)), 0.7);\n    col = mix (col, colT, (isBg ? 0.35 : 0.15));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col[2];\n  vec2 canvas, uv;\n  float el, az, zmFac, tCyc;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  mType = M_TYPE;\n  bxLim = (mType == 1) ? 5. : 2.8;\n  if (mType == 1) pFold = HsvToRgb (vec3 (0.5, 0.2, 1.));\n  dstFar = 80.;\n  az = -0.25 * pi;\n  el = 0.;\n  zmFac = (mType == 1) ? 5.6 : 5.2;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    zmFac += (mType == 1) ? 15. * (mPtr.y + 0.5) : 30. * (mPtr.y + 0.5);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -6.6 * bxLim);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  ltDir = vuMat * normalize (vec3 (1., 2., -1.));\n  slWid = 0.05;\n  tCyc = 100.;\n  tCur *= 1.5;\n  for (int k = VAR_ZERO; k <= 1; k ++) {\n    slPos = (bxLim - slWid) * (4. * (0.5 - abs (mod ((float (k) +\n       floor (tCur)), tCyc) / tCyc - 0.5)) - 1.);\n    col[k] = ShowScene (ro, rd);\n  }\n  fragColor = vec4 (mix (col[0], col[1], smoothstep (0.1, 0.9, fract (tCur))), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlfDH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[672, 672, 696, 696, 883], [885, 885, 907, 907, 972], [974, 974, 996, 996, 1414], [1416, 1416, 1440, 1440, 1800], [1802, 1802, 1835, 1835, 2289], [2291, 2291, 2312, 2312, 2569], [2571, 2571, 2606, 2606, 3577], [4715, 4715, 4747, 4747, 4847], [4849, 4849, 4873, 4873, 4990], [4992, 4992, 5014, 5014, 5052], [5054, 5054, 5076, 5076, 5114], [5116, 5116, 5152, 5152, 5358], [5360, 5360, 5390, 5390, 5503]], "test": "untested"}
{"id": "WdlBDH", "name": "FRC Blue Noise", "author": "Dain", "description": " Hold left mouse button to enable the flipping\n\nI found this useful to improve the visual quality of blue noise dithered particles\nOn odd frames it flips the blue noise around 0, making the dithering looking smoother over time\n", "tags": ["dithering", "bluenoise", "temporal"], "likes": 1, "viewed": 570, "published": 3, "date": "1588175449", "time_retrieved": "2024-07-30T21:09:51.753582", "image_code": "// Hold left mouse button to enable the flipping\n\n//I found this useful to improve the visual quality of blue noise dithered particles in the game I'm working on.\n//On odd frames it flips the blue noise around 0, making the dithering looking smoother over time\n//It doesn't work in screenshots or if you pause.. just in motion\n//It reminds me  FRC used in monitors https://en.wikipedia.org/wiki/Frame_rate_control (not sure how related it really is)\n\n\n//from: https://www.shadertoy.com/view/WtfSDS\nfloat VNoiseCell( in vec2 p ){\n\tvec2 uv = p;\n\n    //Fetch 4 value noises--\n    vec4 r = texture(iChannel0, uv/float(iChannelResolution[0])).rgba*2.0-1.0;\n    \n    //make some cells using geometric average\n    float t = abs(r.a*r.b*r.g*r.r);\n\n    float geo_avg = intBitsToFloat(798731503 + (floatBitsToInt(t)>>2)); \n    return geo_avg*2.0 -1.0;\n}\n//note: from https://github.com/Unity-Technologies/ScriptableRenderPipeline/blob/master/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/FinalPass.shader#L124\nfloat remap_pdf_tri_unity( float v )\n{\n    v = v*2.0-1.0;\n    return sign(v) * (1.0 - sqrt(1.0 - abs(v)));\n}\n\nvec2 GetFinalUV(vec2 uv){\n   return uv*.078 + 1.1;//(.13 + cos(iTime*.3)*.03)  + 1.1 + sin(iTime*.25)*.03; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0);\n    \n    vec2 bn = texture(iChannel1, fragCoord/vec2(iChannelResolution[1].xy) ).rg;\n    \n    //2 seperate trianglar mapped blue noise samples for high quality dither\n\tvec2 blueNoiseDither = vec2(remap_pdf_tri_unity(bn.x), remap_pdf_tri_unity(bn.y));\n    \n\tfloat f = 0.0;\n    float split = .5;\n    float midPt = split*(iResolution.x/iResolution.y);\n  \n\n    bool mouseBtnPressed = (iMouse.z >= 1.0);\n\n    //8 bit fixed point so adjust sub pixel precision by 1/256\n    float ditherSize = (1.0/256.0);\n    if(mouseBtnPressed)\n    {\n        //On odd frames flip the dither value around 0\n        if(bool(iFrame&1)){\n           blueNoiseDither = -blueNoiseDither;\n        }\n    }\n\tf = VNoiseCell(GetFinalUV(uv) + blueNoiseDither*ditherSize);\n\t\n\n\tf = 2.0 + 2.0*f;\n\t\t\n\tfragColor = vec4( f, f, f, 1.0 );\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlBDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[452, 498, 528, 528, 843], [844, 1028, 1066, 1066, 1136], [1138, 1138, 1163, 1163, 1247], [1249, 1249, 1306, 1306, 2201]], "test": "untested"}
{"id": "3dlBWH", "name": "one line britney", "author": "flockaroo", "description": "Hilb-Toning: halftoning using a hilbert curve in different scales.\nmove mouse to adjust detail\n\n...btw this effect is also available for AfterEffects and OpenFX (e.g. Nuke, DaVinci, Natron) here: [url]https://10xfx.com?package=pack2[/url]\n", "tags": ["effect", "halftone", "hilbert"], "likes": 55, "viewed": 1586, "published": 3, "date": "1588169326", "time_retrieved": "2024-07-30T21:09:52.514547", "image_code": "// created by florian berger (flockaroo) - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// one line britney - \"Hilb-toning\"\n\n// this and more effect for AfterEffects/OpenFX available at https://10xfx.com\n\n\n#define Res vec2(iResolution.xy)\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n#define PI  3.14159265359\n#define PI2 6.28318530718\n#define PIH 1.57079632679\n\n#define ROT(ang) mat2(cos(ang+vec2(0.,PI*.5)),sin(ang+vec2(0.,PI*.5)))\n\n//#define PatternRot 0.\n#define PatternRot (iTime*.1)\n#define randness .0\n\nvec4 getRand(int idx)\n{\n    return texelFetch(iChannel1,ivec2(idx%256,(idx/256)%256),0);\n}\n\nmat2 getHilbTrans(int idx)\n{\n//  mirr, ang  (4 points)\n//    -1,-90\n//     1,  0\n//     1,  0\n//    -1, 90\n    float a=float( (((idx/2)&1)*2-1)*(((idx+3)/2)&1) ); // (-1,-1,1,1)*(1,0,0,1)=(-1,0,0,1)\n    float mir=-abs(a)*2.+1.;\n    float ang=a*PIH;\n    vec2 cs=cos(ang-vec2(0,PIH));\n    return mat2(cs,cs.yx*vec2(-1,1))*mat2(mir,0,0,1);\n    //return vec2(mir,ang);\n}\n    \nvec2 getHilbPoint(int idx)\n{\n    return vec2((ivec2(idx,idx+1)/2)&1)-.5;\n}\n\nint getHilbIdx03(vec2 sc)\n{\n    // get quadrant index\n    // 1 2\n    // 0 3\n    //return int(step(0.,-sc.y*sc.x)+2.*step(0.,sc.x));\n    return int(atan(sc.x,sc.y)/PIH+2.);\n}\n\nfloat dDirLine(vec3 p, vec3 c, vec3 dir, float l)\n{\n    p-=c;\n    dir=normalize(dir);\n    float dp=dot(p,dir);\n    //return length(p-dp*dir);\n    return max(max(length(p-dp*dir),-dp),dp-l);\n}\n\nfloat dLine(vec3 p, vec3 p1, vec3 p2) { return dDirLine(p,p1,normalize(p2-p1),length(p2-p1)); }\n\nfloat dLine(vec2 p, vec2 p1, vec2 p2) { return dLine(vec3(p,0),vec3(p1,0),vec3(p2,0)); }\n\n// get hilbert point of index idx with lev subdivision levels\nvec2 getHilbPoint(int idx,int lev)\n{\n    vec2 p=vec2(0);\n    float scale=1.;\n    mat2 m=mat2(1,0,0,1);\n    for(int l=0;l<lev;l++)\n    {\n        int il=(idx>>((lev-1-l)*2))&3;\n        p+=m*(getHilbPoint(il)*scale);\n        m=m*getHilbTrans(il);\n        scale*=.5;\n    }\n    return p;\n}\n\nvec2 getHilbPointF(int idx,float lev)\n{\n    vec2 p=vec2(0);\n    float scale=1.;\n    mat2 m=mat2(1,0,0,1);\n    int maxLev=int(floor(lev)+1.)-1;\n    maxLev=min(maxLev,10);\n    for(int l=0;l<=maxLev;l++)\n    {\n        int il=(idx>>((maxLev-l)*2))&3;\n        float levFade=1.;\n        if(l==maxLev) levFade=fract(lev);\n        vec2 offs=vec2(0.);\n        if(l==maxLev-1) offs=(getRand(idx).xy-.5)*.2*randness;\n        if(l==maxLev) offs=(getRand(idx).xy-.5)*.2*(1.-fract(lev))*randness;\n        p+=m*((getHilbPoint(il)+offs)*scale)*levFade;\n        m=m*getHilbTrans(il);\n        scale*=.5;\n    }\n    return p;\n}\n\nint getClosestHilbIdx(vec2 p,int lev)\n{\n    float scale=1.;\n    int idxAll=0;\n    for(int l=0;l<lev;l++)\n    {\n        int idx=getHilbIdx03(p);\n        idxAll=idxAll*4+idx;\n        mat2 m=getHilbTrans(idx);\n        p=m*(p-getHilbPoint(idx)*scale);\n        scale*=.5;\n    }\n    return idxAll;\n}\n\nfloat hilbert2d(vec2 pos, int level)\n{\n    float d=10000.;\n    for(int i=0; i<int(iMouse.x/10.); i++)\n    {\n        vec2 p1=getHilbPoint(i,level);\n        vec2 p2=getHilbPoint(i+1,level);\n        d=min(d,dLine(pos,p1,p2));\n    }\n    return d;\n}\n\n\nvec2 getInterPoint(vec2 p[11], int num, float fact)\n{\n    fact=clamp(fact,0.,1.);\n    float idxf=fact*(float(num)-.001);\n    int fi=int(idxf);\n    return mix(p[fi],p[min(fi+1,num-1)],fract(idxf));\n}\n\nvec2 getSmoothInterPoint(vec2 p[11], int num, float fact, float w)\n{\n    vec2 p1=getInterPoint(p, num, fact-w);\n    vec2 p2=getInterPoint(p, num, fact+w);\n    return mix(p1,p2,.5);\n}\n\nfloat hilbDistF(vec2 p, float lev)\n{\n    vec2 h[11];\n    int idx0=getClosestHilbIdx(p,int(lev+1.));\n    for(int i=0;i<=8;i++)\n    {\n        h[i]=getHilbPointF(idx0+i-4,lev);\n    }\n    float d=10000.;\n    //d=dSpline(h,8);\n    for(int i=0;i<8;i++)\n    {\n        d=min(d,dLine(p,h[i],h[i+1]));\n    }\n    return d;\n}\n\nfloat hilbPat(vec2 p, float lev)\n{\n    float sc=1.*exp2(lev);\n    return hilbDistF(p, lev);\n}\n\n#define LineWidth (1.*pow(Res.x/700.,.3)*(.75+iMouse.y/Res.y))\n#define Inverse 0.\n\n#define VidTex iChannel0\n\nfloat WhiteVign=1.;\n\nvec4 getCol(vec2 c)\n{\n    vec2 uv=(c-.5*Res)*min(Res0.x/Res.x,Res0.y/Res.y)/Res0+.5;\n    //return textureLod(VidTex,c/Res,0.);\n    vec4 col=vec4(0);\n    float sum=0.;\n    for(int i=0;i<4;i++) \n    {\n        float f=exp2(-float(i)*1.);\n        col+=f*textureLod(VidTex,uv,.5+float(i)*1.2);\n        sum+=f;\n    }\n    col/=sum;\n    float l=length(c/Res-.5);\n\t//col*=1.1;\n    //col-=.1;\n    col=mix(col,vec4(1),clamp(WhiteVign*l*l,0.,1.));\n    return clamp(col,0.,.9);\n}\n\nfloat getVal(vec2 c)\n{\n    //return dot(getCol(c).xyz,vec3(.3,.5,.2));\n    return dot(getCol(c).xyz,vec3(.3333));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fitRes=min(Res.x,Res.y);\n    vec2 sc=(fragCoord-Res*.5)/fitRes*2.;\n    sc=ROT(PatternRot)*sc;\n    \n    /*vec4 c=\n     1.  *textureLod(iChannel0,fragCoord/Res,0.5)\n    +.5  *textureLod(iChannel0,fragCoord/Res,1.5)\n    +.25 *textureLod(iChannel0,fragCoord/Res,2.5)\n    +.125*textureLod(iChannel0,fragCoord/Res,3.5);\n    c*=1./(1.+.5+.25+.125)*.9;\n    float br=dot(c.xyz,vec3(.333));*/\n    float br=getVal(fragCoord);\n    br=clamp(br,0.,1.);\n    //br*=.9;\n    br=mix(br,1.-br,Inverse);\n    //sc+=(texture(iChannel1,sc*.2).xy-.5)*.006;\n    //br=.1+.9*br;\n    float scale=1.;\n    //scale*=exp(-iMouseData.z/3000.)/sqrt(Res.x/600.);\n    scale*=exp(-iMouse.x/Res.x)/sqrt(Res.x/600.);\n    scale*=max(.8,.01)*(fitRes/Res.x);\n    float d=hilbPat(sc, log2(br*.5*Res.x*scale));\n    \n    float s=2./(fitRes*length(vec2(fwidth(sc.y),fwidth(sc.x))));\n    \n    d=hilbDistF(sc, log2((1.-br)*1.*Res.x*scale))*fitRes/2.;\n    //d=hilbPat(sc, iMouse.x/Res.x*10.);\n    \n    float w=1.4*fwidth(d);\n    fragColor.xyz = vec3(0)+exp(-(d-1.+br)*(d-1.+br)/w/w);\n    float th=LineWidth-.35;\n    //float p=smoothstep(th-.7,th+.7,d);\n    float p=clamp(d*s*1.4+1.-LineWidth,0.,1.);\n    p=mix(p,1.-p,Inverse);\n    fragColor.xyz = vec3(0)+p;\n}\n\n", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlBWH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[601, 601, 624, 624, 691], [693, 693, 721, 799, 1059], [1065, 1065, 1093, 1093, 1139], [1141, 1141, 1168, 1272, 1314], [1316, 1316, 1367, 1367, 1507], [1509, 1509, 1548, 1548, 1604], [1606, 1606, 1645, 1645, 1694], [1696, 1758, 1794, 1794, 2042], [2044, 2044, 2083, 2083, 2651], [2653, 2653, 2692, 2692, 2946], [2948, 2948, 2986, 2986, 3192], [3395, 3395, 3463, 3463, 3577], [3579, 3579, 3615, 3615, 3892], [3894, 3894, 3928, 3928, 3987], [4119, 4119, 4140, 4140, 4585], [4587, 4587, 4609, 4657, 4702], [4704, 4704, 4761, 4761, 5981]], "test": "untested"}
{"id": "WdlBW8", "name": "2d Pixel Lighting Test", "author": "natethegreat2525", "description": "2d pixel lighting test for future reference. Just throwing around some ideas. Mostly this solves the problem of how to light surrounding 2d terrain while also allowing some nice soft shadows.", "tags": ["2d", "lighting", "pixel"], "likes": 8, "viewed": 566, "published": 3, "date": "1588145528", "time_retrieved": "2024-07-30T21:09:53.274516", "image_code": "\nbool inWall(vec2 pos) {\n    return texture(iChannel0, pos/iResolution.xy).x > .5;\n}\n\nfloat getLight(vec2 pos, vec2 lpos) {\n    vec2 dir = pos-lpos;\n    float dist = length(dir);\n    float light = 3./pow(dist,.5);\n    float dotf = dist*.2;\n    int dot = int(dotf);\n    float walls = 0.;\n    for (int i = 0; i <= dot; i++) {\n        vec2 p = lpos + (float(i)/dotf)*dir;\n        if (inWall(p)) {\n            walls++;\n            if (walls > 4.) {\n                break;\n            }\n        }\n    }\n    \n    return light * (5.-walls)/5.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 coord )\n{\n    vec3 light = texture(iChannel2, coord/iResolution.xy).rgb;\n    if (inWall(coord)) {\n        fragColor = texture(iChannel1, coord*4./iResolution.xy);\n        fragColor.xyz *= light*2.;\n        return;\n    }\n    \n    \n    fragColor = vec4(vec3(light), 1);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "bool inWall(vec2 pos) {\n    return texture(iChannel0, pos/iResolution.xy).x > .5;\n}\n\nvec3 getLight(vec2 pos, vec2 lpos, vec3 col) {\n    vec2 dir = pos-lpos;\n    float dist = length(dir);\n    float light = 3./sqrt(dist);\n    float dotf = dist*.2;\n    int dot = int(dotf);\n    for (int i = 1; i <= dot; i++) {\n        vec2 p = lpos + (float(i)/dotf)*dir;\n        if (inWall(p)) {\n            return vec3(0.);\n        }\n    }\n    \n    return light * col;\n}\n\n#define RAD 5.\nvoid mainImage( out vec4 fragColor, in vec2 coord )\n{\n    float time = iTime * .5;\n    vec2 light1Pos = iResolution.xy * (vec2(.5) + vec2(cos(time), sin(time))*.3);\n    vec2 light2Pos = iResolution.xy * (vec2(.5) + vec2(cos(time*.4), sin(time*.8))*.4);\n    // need to add light together in squared space then squareroot again to properly add light values\n    vec3 light = sqrt(pow(getLight(coord, iMouse.xy, vec3(1)), vec3(2.)) +\n                      pow(getLight(coord, light1Pos, vec3(1, 1, 0)), vec3(2.)) +\n                     pow(getLight(coord, light2Pos, vec3(0, 1, 1)), vec3(2.)));\n    \n    vec3 oldLightU = texelFetch(iChannel2, ivec2(coord.x, coord.y+RAD), 0).rgb;\n    vec3 oldLightD = texelFetch(iChannel2, ivec2(coord.x, coord.y-RAD), 0).rgb;\n    vec3 oldLightL = texelFetch(iChannel2, ivec2(coord.x+RAD, coord.y), 0).rgb;\n    vec3 oldLightR = texelFetch(iChannel2, ivec2(coord.x-RAD, coord.y), 0).rgb;\n    \n    vec3 maxAround = max(max(oldLightU, oldLightD), max(oldLightL, oldLightR));\n    \n    vec3 oldLightUR = texelFetch(iChannel2, ivec2(coord.x-RAD, coord.y+RAD), 0).rgb;\n    vec3 oldLightDR = texelFetch(iChannel2, ivec2(coord.x-RAD, coord.y-RAD), 0).rgb;\n    vec3 oldLightUL = texelFetch(iChannel2, ivec2(coord.x+RAD, coord.y+RAD), 0).rgb;\n    vec3 oldLightDL = texelFetch(iChannel2, ivec2(coord.x+RAD, coord.y-RAD), 0).rgb;\n    \n    vec3 maxAroundDiag = max(max(oldLightUR, oldLightDR), max(oldLightUL, oldLightDL));\n    \n    maxAround = max(maxAround, maxAroundDiag*.94);  // multiplier should be .9 ^ (1/sqrt(2)), not sure why but had to tweak to .94 to remove artifacts\n    light = max(light, clamp(maxAround, 0., 1.)*.9);\n    fragColor = vec4(light, 1);\n}", "buffer_a_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlBW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 24, 24, 84], [540, 540, 593, 593, 853]], "test": "untested"}
{"id": "wdffW8", "name": "Tutorial Tree", "author": "CraftedCart", "description": "https://www.youtube.com/watch?v=0ifChJ0nJfM\n\nI also added a simple sun with day/night cycle, and made the leaves wobble a bit.", "tags": ["tutorial", "tree"], "likes": 2, "viewed": 391, "published": 3, "date": "1588125793", "time_retrieved": "2024-07-30T21:09:54.336675", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float ratio = iResolution.x / iResolution.y;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x *= ratio;\n    vec2 treeOffset = uv - vec2(0.33, 0.7);\n\n    // Make a sky gradient, blue at the top, pink at the bottom\n    vec3 col = mix(vec3(0.969, 0.659, 0.722), vec3(0.333, 0.804, 0.988), pow(uv.y, 1.0 / 1.4));\n\n    // Make a sun and day/night cycle\n    float sunDist = length(uv - vec2(sin(iTime * 0.2) + (ratio * 0.5), cos(iTime * 0.2) - 0.2)) * 0.7;\n    col += vec3(1.0, 1.0, 1.0) * (0.5 - sunDist);\n\n    // Make leaves\n    const float LEAF_COUNT = 10.0;\n    float leafSize = 0.1 + sin(iTime) * 0.01;\n    float radius = 0.2 + (leafSize * cos(atan(treeOffset.y, treeOffset.x) * LEAF_COUNT + (20.0 * treeOffset.x + 1.0 + cos(iTime * 0.8))));\n    col *= smoothstep(radius, radius + 0.01, length(treeOffset));\n\n    // Make a tree trunk\n    float treeTrunkWidth = 0.015;\n    treeTrunkWidth += 0.002 * cos(120.0 * treeOffset.y); // Make the trunk wobbly\n    treeTrunkWidth += exp(-40.0 * uv.y); // Make the trunk smoothly grow to make the ground\n    col *= 1.0 -\n        (\n         1.0 -\n         smoothstep(\n             // Define the width of the trunk\n             treeTrunkWidth,\n             treeTrunkWidth + 0.002,\n\n             // Vary the X position of the trunk depending on the Y position, to curve the trunk\n             abs(treeOffset.x - (0.2 * sin(2.0 * treeOffset.y)))\n             )\n        ) *\n        // Make the trunk end where the leaves start\n        (\n         1.0 -\n         smoothstep(0.0, 0.01, treeOffset.y)\n        );\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdffW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 1711]], "test": "untested"}
{"id": "WdByRd", "name": "fracDemo", "author": "okh0056", "description": "psuedo fractal", "tags": ["fractal", "demo"], "likes": 5, "viewed": 387, "published": 3, "date": "1588116313", "time_retrieved": "2024-07-30T21:09:55.100633", "image_code": "\n#define ANGLE 2.1\n#define DELTA 0.00635\n#define XOFF .034531\n\n#define time iTime\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\n\nfloat f(vec2 p, float featureSize)\n{\n\tp.x = cos(p.x*0.6+time*0.2)*log(time+p.x*0.1)*ANGLE;\t\n    p += sin(p.x*0.5)*ANGLE;\n    return smoothstep(-0.01,featureSize,abs(p.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x/iResolution.y;\n    float featureSize = 135./((iResolution.x*aspect+iResolution.y));\n\n    vec2 p = (fragCoord.xy/(ANGLE*XOFF)) / (iResolution.xy*ANGLE);\n\tp.x *= aspect;\n\tp.y = abs(p.y);\n\t\n\tvec3 col = vec3(.04);\n    vec3 col2 = (cos(vec3(3.3,2.5,2.2)-2.*0.15)*0.74)*(1.-f(p,featureSize));\n\tfor(float i=0.;i<26.;i+=(XOFF*12.))\n\t{\n\t\tcol2 = (cos(vec3(3.3,2.5,2.2)-i*ANGLE)*0.74)*(1.-f(p,featureSize));\n\t\tcol = max(col,col2);\n\t\t\n        p.x -= XOFF;\n        p.y -= tanh(time*0.31+1.5)*3.;//((ANGLE/XOFF)*XOFF); //1.5+1.5;\n\t\tp*= mm2(i*DELTA+ANGLE);\n\t\t\n        vec2 pa = vec2(abs(p.x-0.9),abs(p.y));\n        vec2 pb = vec2(p.x,abs(p.y));\n        \n        p = mix(pa,pb,smoothstep(-.47,.67,cosh(time*0.14)-ANGLE));\n\t}\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdByRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 103, 103, 155], [158, 158, 194, 194, 331], [333, 333, 390, 390, 1162]], "test": "untested"}
{"id": "wsXBW8", "name": "3D forest generator", "author": "michael0884", "description": "Bifurcation of points in parallel - makes for some extreme rendering potential. Use the speed up if you have the plugin. ", "tags": ["fractal", "tree", "jfa"], "likes": 23, "viewed": 597, "published": 3, "date": "1588111994", "time_retrieved": "2024-07-30T21:09:56.107939", "image_code": "// Fork of \"Tree Study\" by wyatt. https://shadertoy.com/view/3dlfWn\n// 2020-04-28 22:09:24\n\nMain { Q = B(U); }", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texelFetch(iChannel2,ivec2(U),0)\n#define D(U) texelFetch(iChannel3,ivec2(U),0)\n#define pi 3.14159265359\n#define Main void mainImage(out vec4 Q, vec2 U) \n#define e(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define N 5.\n#define I 15.\nvec2 hash22(vec2 p) // Dave H\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nfloat sg (vec2 p, vec2 a, vec2 b) {\n    return  length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n    \n}", "buffer_a_code": "void Y (inout vec4 Q, vec2 U, vec4 n) {\n\tif ((length(U-Q.xy)>length(U-n.xy)||length(Q.xy)<3.)&&\n        length(n.xy)>3.) Q = n;\n}\nMain {\n\tQ = A(U);\n    Q = round(Q);\n    if (mod(float(iFrame),N)<.5) {\n        if (mod(float(iFrame),N*I)<.5) {\n           Q = vec4(R.x*(0.5+0.3*sin(2.61*iTime)),\n                    0.15*R.y,\n                    R.x*(0.5+0.3*sin(2.61*iTime)),\n                    0.);\n        } else {\n            float\n                  n = 1.+mod(floor(float(iFrame)/N/3.),3.),\n                  s = mod(floor(U.x+R.x*U.y),n),\n                  l = length(Q.zw-Q.xy),\n                  a = .1*sin(.1*iTime)+\n                \t  .3*sin(l+float(iFrame))*\n                \t  (s-ceil(0.5*n))*pi;\n            vec2 h = .1*l*(hash22(floor(Q.xy))*2.-1.);\n            vec2 t = Q.xy;\n            Q.xy = Q.xy - 0.8*(Q.zw-Q.xy)+h;\n            Q.xy = t+(Q.xy-t)*e(a);\n        \tQ.zw = t;\n        }\n    }\n    else {\n        float k = exp2(N-1.-mod(float(iFrame),N));\n    \tY(Q,U,A(U+vec2(0,k)));\n    \tY(Q,U,A(U+vec2(k,0)));\n    \tY(Q,U,A(U-vec2(0,k)));\n    \tY(Q,U,A(U-vec2(k,0)));\n    }\n    Q = clamp(Q,vec4(0),R.xyxy);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n    vec2 Un = (U-R*0.5)*1.0015+R*0.5 - vec2(0.98);\n\tvec4 a = A(U);\n    float l = length(a.xy-a.zw);\n    if (length(a.xy)<3.||length(a.zw)<3.){Q = B(U); return;}\n    float r = sg(U,a.zw,a.xy);\n    Q = (0.8+0.5*sin(.01*float(iFrame)+mod(float(iFrame),N*I)/N/I*(vec4(1,2,3,4))));\n    float x = exp(-.5/(1.+.05*l)*r*r);\n    vec4 b = B(Un);\n    //vec4 m = 0.25*(B(Un+vec2(0,1))+B(Un+vec2(1,0))+B(Un-vec2(0,1))+B(Un-vec2(1,0)));\n    //b = mix(b,m,0.01);\n    Q = mix(b,Q*x,x);\n    Q = min(Q,vec4(1));\n    float bd = min(min(R.x - U.x - 1., R.y - U.y - 1.), min(U.x, U.y));\n    Q *= 1.-exp(-bd);\n    if (iFrame < 1) Q = vec4(0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXBW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "tsfBWn", "name": "Land of Commodore", "author": "friol", "description": "Balls are not touching.", "tags": ["c64", "commodore", "64", "cbm"], "likes": 15, "viewed": 526, "published": 3, "date": "1588109412", "time_retrieved": "2024-07-30T21:09:57.373556", "image_code": "\n//\n// friol 2o2o\n// crt effect from https://www.shadertoy.com/view/Ms23DR\n// sdf functions and fake AO by iq\n// music Clutter by Induktiv\n// 02.05.2020: used proper normal for reflections\n// 06.05.2020: optimized compilation times a bit\n//\n\nconst int iterationAmount=256;\nconst int numBalls=16;\nvec4 ballsPositions[numBalls];\n\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nvec3 rotx(in vec3 p, float a) \n{\n\treturn vec3(p.x,\n                cos(a) * p.y + sin(a) * p.z,\n                cos(a) * p.z - sin(a) * p.y);\n}\n\nvec3 roty(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.z,\n                p.y,\n                cos(a) * p.z - sin(a) * p.x);\n}\n\nvec3 rotz(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.y,\n                cos(a) * p.y - sin(a) * p.x,\n                p.z);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nvec2 SDF(vec3 r)\n{\n    vec3 rOrig=r;\n    vec3 rDist=rOrig;\n    float mat=0.0;\n    float t=0.0;\n    \n    float logoDepth=.5;\n    float bendAmt=.2;\n\n    //r=roty(r,r.y*sin(iTime)*bendAmt);\n    r=rotx(r,3.141592/2.0);\n    //float cylouter=sdCappedCylinder(r,vec3(0.0,0.0,0.0),vec3(0.0,.6,0.0),1.0);\n    //float cylinner=sdCappedCylinder(r,vec3(0.0,-2.0,0.0),vec3(0.0,1.7,0.0),0.58);\n\n    float cylouter=sdRoundedCylinder(r,0.50,0.05,0.3);\n    float cylinner=sdCappedCylinder(r,vec3(0.0,-2.0,0.0),vec3(0.0,logoDepth,0.0),0.58);\n    \n    t=opSubtraction(cylinner,cylouter);\n    \n    //vec3 rcb=roty(rOrig,rOrig.y*sin(iTime)*bendAmt);\n    vec3 rcb=rOrig;\n    float cuttingBox=sdBox(rcb-vec3(0.75,0.0,0.0),vec3(0.5,1.0,logoDepth));\n\tt=opSubtraction(cuttingBox,t);                           \n\n    //vec3 r2=roty(rOrig,rOrig.y*sin(iTime)*bendAmt);\n    vec3 r2=rotx(rOrig,3.141592);\n    float upperVent=sdRoundBox(r2-vec3(.58,0.25,0.0),vec3(0.3,0.16,.3),0.03);\n    t=min(t,upperVent);\n    float lowerVent=sdRoundBox(r2-vec3(.58,-0.25,0.0),vec3(0.3,0.16,.3),0.03);\n    t=min(t,lowerVent);\n\n    //vec3 r3=roty(rOrig,rOrig.y*sin(iTime)*bendAmt);\n    vec3 r3=rotz(rOrig,3.141592/4.01);\n    float minusCube=sdBox(r3-vec3(0.8,-0.8,0.0),vec3(.45,.45,.5));\n    \n    t=opSubtraction(minusCube,t);\n    float cbmLogo=t;\n\n    float floorPlane=sdPlane(rDist-vec3(0.0,-0.1*sin(rDist.x)*2.0*cos(rDist.z),0.0),\n                             vec4(0.0,1.0,0.0,1.0));\n    t=min(floorPlane,t);\n\n    float teeMin=100.0;\n    for (int i=0;i<numBalls;i++)\n    {\n        float amigaBall=sdSphere(rOrig-vec3(2.0+ballsPositions[i].x,\n                                            -0.7+abs(sin(iTime+ballsPositions[i].w)),\n                                            ballsPositions[i].z),\n                                 \t\t\t0.4+0.2*ballsPositions[i].w);\n        t=min(amigaBall,t);\n        teeMin=min(t,teeMin);\n    }\n    \n    \n    //\n    \n    if (t==cbmLogo) mat=0.0;\n    else if (t==floorPlane) mat=1.0;\n    else if (t==teeMin) mat=2.0;\n    if (t==upperVent) mat=3.0;\n    if (t==lowerVent) mat=4.0;\n    \n    return vec2(t,mat);   \n}\n\nvec3 calcNormal(vec3 pos)\n{\n\tvec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        // iOS fix\n        //vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        vec3 e = 0.5773*(2.0*vec3(( mod(float((i+3)/2),2.0) ),(mod(float(i/2),2.0)),(mod(float(i),2.0)))-1.0);\n        n += e*SDF(pos+0.0005*e)[0];\n    }\n    return normalize(n);\n}\n\nvec2 castRay(vec3 rayOrigin, vec3 rayDir)\n{\n    float t = 0.0;\n     \n    for (int i = 0; i < iterationAmount; i++)\n    {\n        vec2 res = SDF(rayOrigin + rayDir * t);\n        if (res[0] < (0.0001*t))\n        {\n            return vec2(t,res[1]);\n        }\n        t += res[0];\n    }\n     \n    return vec2(-1.0,-1.0);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = SDF( aopos )[0];\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvec3 Sky( vec3 ray )\n{\n\treturn mix( vec3(.8), vec3(0), exp2(-(1.0/max(ray.y,.01))*vec3(.4,.6,1.0)) );\n}\n\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nvec3 fog(vec3 c, float dist, vec3 fxcol)\n{\n    const float FOG_DENSITY = 0.06;\n    vec3 FOG_COLOR = fxcol.xyz;\n    \n    float fogAmount = 1.0 - exp(-dist * FOG_DENSITY);\n        \n    return mix(c, FOG_COLOR, fogAmount);\n}\n\nvec4 bounceRender(vec3 rayOrigin, vec3 rayDir, vec2 uv)\n{\n    vec3 col=vec3(.52);\n    vec3 L=normalize(vec3(1.0,0.2,-2.0));\n\n    vec2 rayHit = castRay(rayOrigin, rayDir);\n    float t=rayHit[0];\n\n    if (t>0.0)\n    {\n    \tvec3 pHit=rayOrigin + rayDir * t;\n        float mat=rayHit[1];\n        vec3 N=calcNormal(rayOrigin + rayDir * t);\n        float NoL = max(dot(N, L), 0.0);\n      \n\t\tif (mat==0.0)\n        {\n            col=vec3(NoL)*0.75;\n            col+=vec3(.15,.15,.15);\n        }        \n        else if (mat==1.0)\n        {\n            float occ = calcAO( pHit, vec3(0.0,1.0,0.0) );\n            float cdist=pow(distance(pHit,rayOrigin),1.202);\n            col=vec3(0.5)*occ;\n            \n            float tee = -rayOrigin.y / rayDir.y;\n\n            vec2 P = rayOrigin.xz + t * rayDir.xz;\n            vec2 Q = floor(P);\n            P = mod(P, 1.0);\n\n            const float gridLineWidth = 0.1;\n\n            float res = clamp(2048.0 / iResolution.y, 1.0, 3.0);\n            P = 1.0 - abs(P - 0.5) * 2.0;\n            float d = clamp(min(P.x, P.y) / (gridLineWidth * clamp(tee + res * 2.0, 1.0, 2.0)) + 0.5, 0.0, 1.0);\n\n            float shade = mix(hash(120.0 + Q * 0.1) * 0.4, 0.3, min(tee * tee * 0.001, 1.0)) + 0.6;\n            vec3 colFloor= vec3(pow(d, \n                           clamp(150.0 / (pow(max(tee - 2.0, 0.1), res) + 1.0), 0.1, 31.0)\n                      )) * shade + 0.1;            \n            colFloor*=vec3(0.51,0.12,0.23);\n            col=mix(colFloor,col,0.5);\n            col=fog(col,pow(cdist,.7642),Sky(rayDir));\n        }\n        else if (mat==2.0)\n        {\n            vec3 q=N;\n            vec2 matuv = vec2( atan(N.x,N.z), acos(N.y ) );\n            vec2 qp = floor(matuv*2.51);\n            float intensity=mod( qp.x+qp.y, 2.0 );\n            if (intensity==1.0) col=vec3(1.0,0.0,0.0);\n            else col=vec3(1.0);\n            //float NoL = max(dot(N, L), 0.2);\n            col*=NoL;\n\n            float cdist=pow(distance(pHit,rayOrigin),1.202);\n            col=fog(col,pow(cdist,.7642),Sky(rayDir));\n        }\n        else if ((mat==3.0)||(mat==4.0))\n        {\n            col=vec3(NoL)*0.75;\n            if (mat==4.0) col+=vec3(231.0/256.0,12.0/256.0,52.0/256.0);\n            else col+=vec3(0.0,112.0/256.0,232.0/256.0);\n            float cdist=pow(distance(pHit,rayOrigin),1.202);\n            col=fog(col,pow(cdist,.7642),Sky(rayDir));\n            col/=4.0;\n        }\n    }\n    else\n    {\n        vec3 sk=Sky(rayDir);\n        col=vec3(clamp(sk.x,0.0,1.0),clamp(sk.y,0.0,1.0),clamp(sk.z,0.0,1.0));\n        //col=vec3(1.0,0.0,0.0);\n    }\n\n    //col=pow(col,vec3(0.58));\n    return vec4(col,1.0);\n}\n\n\nvec4 render(vec3 rayOrigin, vec3 rayDir, vec2 uv)\n{\n    vec3 col=vec3(0.);\n    vec3 L=normalize(vec3(4.0,0.2,-2.0));\n\n    vec2 rayHit = castRay(rayOrigin, rayDir);\n    float t=rayHit[0];\n    vec3 N=calcNormal(rayOrigin + rayDir * t);\n    float NoL = max(dot(N, L), 0.0);\n\n    if (t>0.0)\n    {\n    \tvec3 pHit=rayOrigin + rayDir * t;\n        float mat=rayHit[1];\n      \n        if (mat==0.0) // c= logo\n        {\n            col=vec3(NoL)*0.75;\n            col+=vec3(.25,.25,.25);\n            vec3 refDir = reflect(rayDir,N);\n            vec4 colReflect=bounceRender(pHit,refDir,uv);\n            col=mix(col,colReflect.xyz,0.6);\n\n            float cdist=pow(distance(pHit,rayOrigin),1.202);\n            col=fog(col,pow(cdist,.7642),Sky(rayDir));\n        }\n        else if (mat==1.0) // floor\n        {\n            float occ = calcAO( pHit, vec3(0.0,1.0,0.0) );\n            float cdist=pow(distance(pHit,rayOrigin),1.202);\n            col=vec3(0.5)*occ;\n            \n            float tee = -rayOrigin.y / rayDir.y;\n\n            vec2 P = rayOrigin.xz + t * rayDir.xz;\n            vec2 Q = floor(P);\n            P = mod(P, 1.0);\n\n            const float gridLineWidth = 0.05;\n\n            float res = clamp(2048.0 / iResolution.y, 1.0, 3.0);\n            P = 1.0 - abs(P - 0.5) * 2.0;\n            float d = clamp(min(P.x, P.y) / (gridLineWidth * clamp(tee + res * 2.0, 1.0, 2.0)) + 0.5, 0.0, 1.0);\n\n            float shade = mix(hash(120.0 + Q * 0.1) * 0.4, 0.3, min(tee * tee * 0.001, 1.0)) + 0.6;\n            vec3 colFloor= vec3(pow(d, \n                           clamp(150.0 / (pow(max(tee - 2.0, 0.1), res) + 1.0), 0.1, 31.0)\n                      )) * shade + 0.1;            \n            \n            colFloor*=vec3(0.51,0.12,0.23);\n            col=mix(colFloor,col,0.5);\n            col=fog(col,pow(cdist,.7642),Sky(rayDir));\n        }\n        else if (mat==2.0) // amiga balls\n        {\n            vec3 q=N;\n            vec2 matuv = vec2( atan(N.x,N.z), acos(N.y ) );\n            vec2 qp = floor(matuv*2.51);\n            float intensity=mod( qp.x+qp.y, 2.0 );\n            if (intensity==1.0) col=vec3(1.0,0.0,0.0);\n            else col=vec3(1.0);\n            float NoL = max(dot(N, L), 0.1);\n            col*=NoL;\n            col+=pow(NoL,32.0);\n            \n            vec3 refDir = reflect(rayDir,N);\n\n            vec4 colReflect=bounceRender(pHit,refDir,uv);\n            col=mix(col,colReflect.xyz,0.7);\n\n            float cdist=pow(distance(pHit,rayOrigin),1.202);\n            col=fog(col,pow(cdist,.7642),Sky(rayDir));\n        }\n        else if ((mat==3.0)||(mat==4.0))\n        {\n            col=vec3(NoL)*0.75;\n            if (mat==4.0) col+=vec3(231.0/256.0,12.0/256.0,52.0/256.0);\n            else col+=vec3(0.0,112.0/256.0,232.0/256.0);\n            vec3 refDir = reflect(rayDir,N);\n            vec4 colReflect=bounceRender(pHit,refDir,uv);\n            col=mix(col,colReflect.xyz,0.6);\n\n            float cdist=pow(distance(pHit,rayOrigin),1.202);\n            col=fog(col,pow(cdist,.7642),Sky(rayDir));\n        }\n        else\n        {\n            col=vec3(1.0,1.0,0.0);\n        }\n        \n    }\n    else\n    {\n        col=Sky(rayDir);\n    }\n\n    col=pow(col,vec3(0.58));\n    return vec4(col,1.0);\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 upz=vec3(0.,1.,0.);\n    vec3 camRight = normalize(cross(upz, camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n     \n    float fPersp = 2.0;\n    vec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n \n    return vDir;\n}\n\nvec2 normalizeScreenCoords(vec2 screenCoord)\n{\n    vec2 result = 2.0 * (screenCoord/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    return result;\n}\n\nfloat onelinerRandom(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid initBalls()\n{\n    float ballSpread=16.0;\n    int seed=234;\n    for (int b=0;b<numBalls;b++)\n    {\n        float x=-ballSpread/2.0+onelinerRandom(vec2(seed))*ballSpread; seed+=0x42;\n        float y=onelinerRandom(vec2(seed))*3.141592*2.0; seed+=0x42;\n        float z=-ballSpread/2.0+onelinerRandom(vec2(seed))*ballSpread; seed+=0x42;\n        float delta=onelinerRandom(vec2(seed));\n\t\tballsPositions[b]=vec4(x,y,z,delta);        \n    }\n}\n\nvec2 curve(vec2 uv)\n{\n\tuv = (uv - 0.5) * 2.0;\n\tuv *= 1.1;\t\n\tuv.x *= 1.0 + pow((abs(uv.y) / 5.0), 2.0);\n\tuv.y *= 1.0 + pow((abs(uv.x) / 4.0), 2.0);\n\tuv  = (uv / 2.0) + 0.5;\n\tuv =  uv *0.92 + 0.04;\n\treturn uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initBalls();\n    \n    float myTime=(iTime+1.34)/2.0;\n\tvec2 uv = normalizeScreenCoords(fragCoord);\n\n    vec3 camPos,camTarget;\n\n    float radius=4.0;\n    camPos = vec3(radius*sin(myTime),1.0+cos(myTime/4.0)*0.9,-radius*cos(myTime));\n    camTarget = vec3(0.0,0.,0.0);\n    \n    vec3 rayDir = getCameraRayDir(uv, camPos, camTarget);   \n\n    vec4 finalCol = vec4(render(camPos, rayDir,uv).xyz,1.0);\n\t//vec4 col=finalCol;\n    \n\tvec2 coord = (uv - 0.5) * (iResolution.x/iResolution.y) * 2.0;\n    vec2 uv2 = fragCoord.xy / iResolution.xy;\n\tvec3 col = finalCol.rgb;\n    col=clamp(col*0.6+0.4*col*col*1.0,0.0,1.0);\n    float vig = (0.0 + 1.0*16.0*uv2.x*uv2.y*(1.0-uv2.x)*(1.0-uv2.y));\n\tcol *= vec3(pow(vig,0.3));\n    col *= vec3(0.95,0.90,0.95)*2.7;\n\tfloat scans = clamp( 0.35+0.35*sin(3.5*iTime+uv2.y*iResolution.y*1.5), 0.0, 1.0);\n\tfloat s = pow(scans,1.7);\n\tcol = col*vec3( 0.4+0.7*s) ;\n    col *= 1.0+0.01*sin(110.0*iTime);\n\tcol*=1.0-0.65*vec3(clamp((mod(fragCoord.x, 2.0)-1.0)*2.0,0.0,1.0));\n    float comp = smoothstep( 0.1, 0.9, sin(iTime) );\n    \n    //vec3 col2=mix(col,finalCol.rgb,0.5);\n    //col=mix(col,finalCol.rgb,(1.0-pow(distance(uv,vec2(0.0,0.0)),0.039))/1.0);\n\tcol=mix(col,finalCol.rgb,0.4);\n    //vec3 col=finalCol.xyz;\n    \n    fragColor=vec4(col.rgb, 1.0);\n}\n", "image_inputs": [{"id": 22483, "src": "https://soundcloud.com/studiodrumandbass/induktiv-clutter-free-download?in=different-drumz/sets/free-drum-bass-downloads-from", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfBWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[329, 329, 372, 372, 394], [396, 396, 428, 428, 539], [541, 541, 572, 572, 683], [685, 685, 716, 716, 827], [829, 829, 881, 881, 980], [982, 982, 1015, 1015, 1043], [1045, 1045, 1090, 1090, 1181], [1183, 1183, 1216, 1216, 1247], [1249, 1249, 1280, 1280, 1367], [1369, 1369, 1426, 1426, 1762], [1764, 1764, 1828, 1828, 1945], [1947, 1947, 1965, 1965, 4041], [4043, 4043, 4070, 4070, 4401], [4403, 4403, 4446, 4446, 4722], [4724, 4724, 4766, 4766, 5080], [5082, 5082, 5104, 5104, 5185], [5187, 5187, 5207, 5207, 5295], [5297, 5297, 5339, 5339, 5518], [5520, 5520, 5577, 5577, 8157], [8160, 8160, 8211, 8211, 11372], [11374, 11374, 11434, 11434, 11760], [11762, 11762, 11808, 11808, 11934], [11936, 11936, 11966, 11966, 12038], [12040, 12040, 12058, 12058, 12480], [12482, 12482, 12503, 12503, 12691], [12693, 12693, 12750, 12750, 14025]], "test": "untested"}
{"id": "WsffWH", "name": "array of threads - loopless", "author": "FabriceNeyret2", "description": "Loopless variant of \"array of threads\"  [url]https://shadertoy.com/view/llXSD8[/url]\nUncomment line 21 to display the curve density instead.", "tags": ["2d", "short", "loopless"], "likes": 11, "viewed": 556, "published": 3, "date": "1588104347", "time_retrieved": "2024-07-30T21:09:58.265172", "image_code": "// loopless variant of \"array of threads\"  https://shadertoy.com/view/llXSD8\n\n#define draw  O += .003 / abs( i*(u.y-u.x-i)+i-u.y )  // function to draw ( is where f ~ inf ;-) )\n\nvoid mainImage(out vec4 O, vec2 u) {\n\n    O = vec4(0);\n    u = 3.*u/iResolution.y -vec2(2,1); \n    \n#if 0  // --- loop version\n\n    for ( float i=-1.; i<=2.; i+=.1 )\n        draw;    \n    \n#else  // --- loopless version\n    \n    // solving for f(i)=big -> i² -b.i +c ~ 0  with b= y-x+1 and c= y\n    float b = u.y-u.x+1., d = b*b -4.*u.y, i;\n    if (d<0.) return;    // pixel out of the threaded area\n\n // O += .5/d; return;   // draw the inverve Jacobian to show curve density\n // variant: .5/abs(d) , before line 19\n    \n#define ifInRange   i = round( i *10.)/10.; if (i>=-1. && i<=2.) \n    i = (b-sqrt(d))/2.; ifInRange draw; \n    i = (b+sqrt(d))/2.; ifInRange draw; \n    O *= 2.; // this case is tough since all lines extend/decay lateraly up to infinity \n    \n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsffWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 178, 214, 214, 951]], "test": "untested"}
{"id": "3dfBWH", "name": "The Rorsach Mask", "author": "mrange", "description": "License CC0\nCoded while listening to some 1970s Tangerine Dream. Big thanks to ollj for introducing me to SABS.\nCode not very elegant and contains repeated concepts but I liked the result\n", "tags": ["2d", "sabs"], "likes": 6, "viewed": 446, "published": 3, "date": "1588101022", "time_retrieved": "2024-07-30T21:09:59.300404", "image_code": "// License CC0\n//  Coded while listening to some 1970s Tangerine Dream. Big thanks to ollj for introducing me to SABS\n//  Code not very elegant and contains repeated concepts but I liked the result\n//  Colors are better in non-chromium browsers\n\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define SCA(a)      vec2(sin(a), cos(a))\n#define TTIME       ((iTime-232.0)*TAU)\n#define LESS(a,b,c) mix(a,b,step(0.,c))\n#define SABS(x,k)   LESS((.5/k)*x*x+k*.5,abs(x),abs(x)-k)\n\n\nvec2 hash(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise(vec2 p) {\n  const float K1 = .366025404;\n  const float K2 = .211324865;\n\n  vec2 i = floor (p + (p.x + p.y)*K1);\n    \n  vec2 a = p - i + (i.x + i.y)*K2;\n  vec2 o = step (a.yx, a.xy);    \n  vec2 b = a - o + K2;\n  vec2 c = a - 1. + 2.*K2;\n\n  vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n  vec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),dot (b, hash (i + o)), dot (c, hash (i + 1.)));\n\n  return dot (n, vec3 (70.));\n}\n\nfloat fbm(vec2 pos, float tm) {\n  vec2 offset = vec2(cos(tm), sin(tm*sqrt(0.5)));\n  float aggr = 0.0;\n    \n  aggr += noise(pos);\n  aggr += noise(pos + offset) * 0.5;\n  aggr += noise(pos + offset.yx) * 0.25;\n  aggr += noise(pos - offset) * 0.125;\n  aggr += noise(pos - offset.yx) * 0.0625;\n    \n  aggr /= 1.0 + 0.5 + 0.25 + 0.125 + 0.0625;\n    \n  return (aggr * 0.5) + 0.5;    \n}\n\nvec3 lightning(vec2 pos, float offset, float dl) {\n  vec3 col = vec3(0.0);\n  vec2 f = 10.0*SCA(PI/2.0 + TTIME/1000.0);\n    \n  float width = 0.003*dl;\n    \n  for (int i = 0; i < 2; i++) {\n    float btime = TTIME/35.0 + float(i);\n    float rtime = TTIME/40.0 + float(i) + 10.0;\n    float d1 = abs(offset * width / (0.0 + offset - fbm((pos + f) * 3.0, rtime)));\n    float d2 = abs(offset * width / (0.0 + offset - fbm((pos + f) * 2.0, btime)));\n    col += vec3(d1 * vec3(0.1, 0.3, 0.8));\n    col += vec3(d2 * vec3(0.7, 0.3, 0.5));\n  }\n    \n  return clamp(col, 0.0, 1.0);;\n}\n\n\nvec2 toSmith(vec2 p)  {\n  // z = (p + 1)/(-p + 1)\n  // (x,y) = ((1+x)*(1-x)-y*y,2y)/((1-x)*(1-x) + y*y)\n  float d = (1.0 - p.x)*(1.0 - p.x) + p.y*p.y;\n  float x = (1.0 + p.x)*(1.0 - p.x) - p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\nvec2 fromSmith(vec2 p)  {\n  // z = (p - 1)/(p + 1)\n  // (x,y) = ((x+1)*(x-1)+y*y,2y)/((x+1)*(x+1) + y*y)\n  float d = (p.x + 1.0)*(p.x + 1.0) + p.y*p.y;\n  float x = (p.x + 1.0)*(p.x - 1.0) + p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat tile0(vec2 p, float hwidth, float lwidth) {\n  float c0 = circle(p - vec2(hwidth), hwidth);  \n  float c1 = circle(p + vec2(hwidth), hwidth);  \n  c0 = abs(c0) - lwidth;\n  c1 = abs(c1) - lwidth;\n\n  float d = c0;\n  d = min(d, c1);\n\n  return d;\n}\n\nfloat tile1(vec2 p, float hwidth, float lwidth) {\n  p = abs(p);\n  float c0 = circle(p - vec2(hwidth), hwidth);  \n  c0 = abs(c0) - lwidth;\n\n  float d = c0;\n\n  return d;\n}\n\nfloat tile2(vec2 p, float hwidth, float lwidth) {\n  // Empty cell\n  return hwidth*4.0;\n}\n\nfloat tile3(vec2 p, float hwidth, float lwidth) {\n  p = abs(p);\n  float c0 = abs(p.x) - lwidth;\n\n  float d = c0;\n\n  return d;\n}\n\nfloat tile4(vec2 p, float hwidth, float lwidth) {\n  p.x = abs(p.x);\n  float c0 = circle(p - vec2(hwidth, hwidth), hwidth);  \n  c0 = abs(c0) - lwidth;\n\n  float d = c0;\n\n  return d;\n}\n\nfloat rand(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\n\nfloat tile(vec2 p, vec2 n, float hwidth, float lwidth) {\n  float rnd = rand(n);\n\n  vec2 ap = abs(p);\n\n  vec2 pp = toPolar(p);\n  pp.y -= float(int(mod(1000.0*rnd, 4.0)))*PI/2.0;  \n  p = toRect(pp);\n\n  float d = 0.0;  \n  \n  if (rnd > 0.95) {\n    d =  tile0(p, hwidth, lwidth);\n  } else if (rnd > 0.85) {\n    d = tile0(p, hwidth, lwidth);\n  } else if (rnd > 0.75) {\n    d =  tile3(p, hwidth, lwidth);\n  } else if (rnd > 0.65) {\n    d =  tile1(p, hwidth, lwidth);\n  } else {\n    d =  tile0(p, hwidth, lwidth);\n  }\n\n  float da1 = circle(ap - vec2(hwidth, 0.0), lwidth);  \n  float da2 = circle(ap - vec2(0.0, hwidth), lwidth);  \n\n  float da = min(da1, da2);\n\n  return min(d, da);\n}\n\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nfloat df(vec2 p) {\n  float hwidth = 1.0;\n  float lwidth = 0.25;\n  vec2 n = mod2(p, vec2(hwidth*2.0));  \n  float d = tile(p, n, hwidth, lwidth);\n  \n  return d;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nvec2 coordinateTransform(vec2 p) {\n  p.x = SABS(p.x, 0.1);\n  p *= 5.0;\n  rot(p, TTIME/100.0);\n  vec2 sp = toSmith(p);\n  float x = 3.;\n  sp.x += x;\n  sp.y += x;\n  p = fromSmith(sp);\n  return p;\n}\n\nvec4 dCoordinateTransform(vec2 p) {\n  vec4 nor;\n  vec2 eps = vec2(0.0001, 0.0);\n  \n  nor.xy = (coordinateTransform(p + eps.xy) - coordinateTransform(p - eps.xy));\n  nor.zw = (coordinateTransform(p + eps.yx) - coordinateTransform(p - eps.yx));\n  \n  return nor/eps.x;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) { \n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n \n \n  float z = 0.5;\n    \n  vec3 col = vec3(0.0);\n \n  vec4 dp = dCoordinateTransform(p);\n  float dl = length(dp);\n  p = coordinateTransform(p);\n  p.y += TTIME/200.0;\n \n  float d = df(p/z)*z;\n\n  float pp = 0.3;\n  vec3 li = lightning(p, tanh(pow(max(d, 0.0), pp)), 20.0*pow(1.5*dl, pp));\n  col = 1.0 - li;\n  \n  float f = tanh(0.01*dl);\n  col = pow(col, vec3(1.0 - f))*vec3(1.2, 0.7, 0.5);\n  col = clamp(col, 0.0, 1.0);\n  col = mix(col, vec3(0.), f);\n\n  col = postProcess(col, q);\n  \n  fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfBWH.jpg", "access": "api", "license": "cc0-1.0", "functions": [[489, 489, 508, 508, 631], [633, 633, 654, 654, 1081], [1083, 1083, 1114, 1114, 1461], [1463, 1463, 1513, 1513, 2033], [2036, 2036, 2059, 2139, 2278], [2280, 2280, 2305, 2384, 2523], [2525, 2525, 2556, 2556, 2582], [2584, 2584, 2633, 2633, 2831], [2833, 2833, 2882, 2882, 3002], [3004, 3004, 3053, 3069, 3092], [3094, 3094, 3143, 3143, 3221], [3223, 3223, 3272, 3272, 3404], [3406, 3406, 3427, 3427, 3497], [3499, 3499, 3521, 3521, 3565], [3567, 3567, 3588, 3588, 3633], [3636, 3636, 3692, 3692, 4311], [4313, 4313, 4349, 4349, 4443], [4445, 4445, 4463, 4463, 4605], [4607, 4607, 4640, 4640, 4725], [4727, 4727, 4761, 4761, 4921], [4923, 4923, 4958, 4958, 5190], [5192, 5192, 5228, 5228, 5477], [5479, 5479, 5534, 5534, 6147]], "test": "untested"}
{"id": "WdffD8", "name": "Cow-Headed Fractal", "author": "jarble", "description": "This fractal is based on [url=https://www.shadertoy.com/view/3dfBW8]this shader[/url].", "tags": ["fractal", "cow"], "likes": 1, "viewed": 354, "published": 3, "date": "1588099022", "time_retrieved": "2024-07-30T21:10:00.335636", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (12.0+sin(iTime)*4.0) * (fragCoord - iResolution.xy / (2.0)) / min(iResolution.y, iResolution.x);\n    \n    float lar;\n\n    for (float i=0.0; i < 6.0; i++)\n    {\n        lar = length(vec2(uv.x, uv.y));\n\t\tfloat uvx1= uv.x;\n        uv.x = - uv.y + sin(uv.x)*(uv.x);\n        uv.y = - uvx1 + sin(uv.y)*(uv.y);\n    }\n    // Output to screen\n    fragColor = vec4(cos(lar * 2.0), cos(lar * 3.0), cos(lar * 1.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdffD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 533]], "test": "untested"}
{"id": "3dXBW8", "name": "2D clouds i wanted to do", "author": "Leria", "description": "What a Sunny day !\n\ninspired from this shader : https://www.shadertoy.com/view/tlB3zK (zxxuan1001)", "tags": ["2d", "noise", "cloud", "sky"], "likes": 1, "viewed": 441, "published": 3, "date": "1588090907", "time_retrieved": "2024-07-30T21:10:01.515481", "image_code": "\n//noise function from iq: https://www.shadertoy.com/view/Msf3WH\nvec2 hash( vec2 p ) \n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n//quintique\nvec2 fade5(vec2 f) {return f * f * f * (f * (f * 6.0 - 15.0) + 10.0);}\n\n//cubique\nvec2 fade3(vec2 f) {return f*f*(3.0-2.0*f);}\n\nfloat noise(vec2 p)\n{\n \tvec2 i = floor( p );\n    vec2 f = fract( p );\n    \n    vec2 u = fade5(f);\n    \n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n        \n}\n\n\nfloat fractal_noise(vec2 p)\n{\n    float f = 0.0;\n\tfloat amp = 1.;\n    p = p*2.;\n    for(int i = 0; i < 5 ; i++)\n    {\n     \tf += amp/2.*noise(p);\n        p = p*2.;\n    }\n    \n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 sky = vec3(0.5, 0.7, 0.8);\n    vec3 col = vec3(0.0);\n    \n    vec3 cloud_color = vec3(1.0);\n   \n    float n = fractal_noise(fragCoord/(200.+iTime/1000.));\n    col = mix( sky, cloud_color, smoothstep(-1., 40., n));\n    col = mix( col, cloud_color, smoothstep(.75, -1.25, n));\n    col = min(col, cloud_color);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXBW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 65, 87, 87, 202], [204, 216, 236, 236, 286], [288, 298, 318, 318, 342], [344, 344, 365, 365, 773], [776, 776, 805, 805, 966], [968, 968, 1025, 1025, 1381]], "test": "untested"}
{"id": "tdsfDr", "name": "Градієнт", "author": "Drak_Lowell", "description": "Цікавий шейдер, в якому синій шар поглинає чорний, потім все перевертається", "tags": [], "likes": 0, "viewed": 257, "published": 3, "date": "1588088699", "time_retrieved": "2024-07-30T21:10:02.717268", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float colCoef = mod(iTime, 10.0)/10.0; // Коефіцієнт кольору, який міняється з часом ( Коефіцієнт від 0.0 до 1.0 )\n    if(colCoef>0.5){\n        colCoef = 1.0 - colCoef; // Якщо коефіцієнт більше 0.5, перевертаємо його, роблячи зациклення ( Стає 0.0 до 0.5\n    }\n    colCoef += 0.5; // Збільшуємо коефіцієнт на 0.5 ( Тепер він від 0.5 до 1.0)\n    vec2 uv = (fragCoord/iResolution.xy)*vec2(4,4)-vec2(2,2); // Перетворюємо координати на діапазон від -2 до 2\n    float formulaCol = (uv.x*exp(-(pow(uv.x, 2.0)+pow(uv.y, 2.0)))+2.0)/4.0; // Виконуємо f(x, y) = xe−(x2 + y2) \n    float col = -formulaCol+colCoef; // Виконуємо накладання коефеціенту на колір\n    fragColor = vec4(0, 0, col, 1.0); // Виводимо колір на екран з прозорістю 1 ( НЕ прозорий )\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsfDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1085]], "test": "untested"}
{"id": "wssfWr", "name": "RENTAGHOST", "author": "jj99", "description": "RENT-A-GHOST", "tags": ["silly", "ghost", "purple"], "likes": 3, "viewed": 292, "published": 3, "date": "1588084390", "time_retrieved": "2024-07-30T21:10:03.720586", "image_code": "// RENT-A-GHOST (C) ME\n\nvec2 rot(vec2 p, float a)\n{\nfloat sa = sin(a), ca = cos(a);\nreturn p * mat2(ca, -sa, sa, ca);\n}   \nfloat seg( in vec2 p, in vec2 a, in vec2 b )\n{\nvec2 ba = b-a;\nvec2 pa = p-a;\nfloat h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\nreturn length(pa-h*ba);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\nvec2 p = (fragCoord.xy - iResolution.xy/2.) / iResolution.y;\np*=1.7+sin(p.x+time*0.9)*0.3;\np = rot(p,0.5+sin(time+p.y*1.2+p.x*0.2)*0.5);\np += sin(time*.87)*.7;\nvec2 pp = rot(p,degrees(-45.0*0.5));\nfloat d = length(pp-vec2(0.25,0.2))-0.04;\nd = min(d,length(pp-vec2(0.0,0.3))-0.04);\npp = rot(pp,degrees(((pp.x-0.1)*-0.05))*0.75);\nfloat d2 = seg(pp, vec2(-0.1,0.0), vec2(0.2,-0.1));\nd2 += 0.02;\nfloat d3 = length(pp-vec2(0.05,0.0))-0.02;\nfloat v = 0.5+sin(time*1.1)*0.5;\nd2 = mix(d3,d2,v);\nfloat angle = atan(p.y, p.x);\nfloat radius = length(p*p) * (1. + sin(p.x*6.0+angle+p.y*9.0 + time)*.1);\nfloat ed = 0.055 + 0.02*sin(p.y*10.0+time*1. + angle);    \ned = -(ed /  (radius - 0.3+sin(20.0*p.x*p.y)*0.1));\ned -= abs(sin(p.y*0.1+time*1.3)*0.3);\nvec3 col = vec3(0.5,0.7,0.1) * ed;\nd = abs(d)+0.01;\nd = 1.0-smoothstep(0.02,0.025,d);\ncol += d*vec3(1.5,1.5,1.5);\nd2 = 1.0-smoothstep(0.03,0.04,d2);\ncol.rgb+=d2*vec3(0.9,0.9,0.9);\nfragColor = vec4(1.-col,1.0);\n}\n \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wssfWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 51, 51, 119], [123, 123, 169, 169, 276], [277, 277, 334, 334, 1310]], "test": "untested"}
{"id": "WdsBWn", "name": "Lazy Cave Thingie", "author": "khoba", "description": "-", "tags": ["raytracing"], "likes": 0, "viewed": 304, "published": 3, "date": "1588063515", "time_retrieved": "2024-07-30T21:10:04.630154", "image_code": "#define OUTLINE_THRESHOLD 0.003\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 offsetX = vec2(1. / iResolution.x, 0.);\n    vec2 offsetY = vec2(0., 1. / iResolution.y);\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    vec3 colU = texture(iChannel0, uv + offsetY).xyz;\n    vec3 colD = texture(iChannel0, uv - offsetY).xyz;\n    vec3 colR = texture(iChannel0, uv + offsetX).xyz;\n    vec3 colL = texture(iChannel0, uv - offsetX).xyz;\n    \n    float diff = max(abs(BW(colU) - BW(colD)), abs(BW(colR)  - BW(colL)));\n    \n    vec3 outputCol = diff > OUTLINE_THRESHOLD ? col * col * col * col: vec3(1, 1., 95.);\n\t\n    fragColor = vec4(outputCol, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define STEP \t\t0.0001\n#define MAX_DIST\t0.1\n#define MIN_DIST    0.0\n#define THRESHOLD   0.03\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 cuv = (uv - .5) * 2.;\n    \n    vec3 pos = vec3(0., 0., iTime * 0.01);\n    vec3 ray = normalize(vec3(cuv, 1.))\n        * rotationZ(cos(iTime * 0.52) * 0.25)\n        * rotationX(sin(iTime * 0.3) * 0.74);\n    \n    float dist = 1.;\n    for(float d = MIN_DIST; d < MAX_DIST; d += STEP) {\n        vec3 samplePos = pos + ray * d;\n        vec3 xy = texture(iChannel0, samplePos.xy).xyz;\n        vec3 yz = texture(iChannel0, samplePos.zy).xyz;\n        if(BW(xy) * BW(yz) > THRESHOLD) {\n            dist = d / (MAX_DIST - MIN_DIST);\n            break;\n        }\n    }\n\t\n    fragColor = vec4(dist, dist, dist, 1.);\n}", "buffer_a_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define BW(v) (v.x * .28 + v.y * .6 + v.z * .12)\n\nmat3 rotationY(in float a) {\n    return mat3(cos(a), 0., sin(a),\n               \t0., 1., 0.,\n               -sin(a), 0., cos(a));\n}\n\nmat3 rotationX(in float a) {\n\treturn mat3(1., 0., 0.,\n               \t0.,\tcos(a), sin(a),\n               \t0., -sin(a), cos(a));\n}\n\nmat3 rotationZ(in float a) {\n\treturn mat3(cos(a), sin(a), 0.,\n               \t-sin(a), cos(a), 0.,\n               \t0., 0., 1.);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsBWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 90, 90, 714]], "test": "untested"}
{"id": "3slfWn", "name": "FlyingToastBoy", "author": "jj99", "description": "Flying Toast Boy", "tags": ["boy", "flying", "toast"], "likes": 5, "viewed": 347, "published": 3, "date": "1588033685", "time_retrieved": "2024-07-30T21:10:05.607540", "image_code": "// FLYING TOASTBOY (C) ME\nvec2 rot(vec2 p, float a)\n{\nfloat sa = sin(a), ca = cos(a);\nreturn p * mat2(ca, -sa, sa, ca);\n}   \nfloat seg( in vec2 p, in vec2 a, in vec2 b )\n{\nvec2 ba = b-a;\nvec2 pa = p-a;\nfloat h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\nreturn length(pa-h*ba);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nfloat time = iTime;\nvec2 p = (gl_FragCoord.xy - iResolution.xy/2.) / iResolution.y;\np*=1.7+sin(p.x+time*0.9)*0.3;\np = rot(p,0.5+sin(time+p.y*1.2+p.x*0.2)*0.5);\np += sin(time*.87)*1.4;\nvec2 pp = rot(p,degrees(-45.0*0.5));\nfloat d = length(pp-vec2(0.25,0.2))-0.04;\nd = min(d,length(pp-vec2(0.0,0.3))-0.04);\npp = rot(pp,degrees(((pp.x-0.1)*-0.05))*abs(sin(time)*0.85));\nfloat d2 = seg(pp, vec2(-0.1,0.0), vec2(0.2,-0.1));\nfloat angle = atan(p.y, p.x);\nfloat radius = length(p*p) * (1. + sin(p.x*6.0+angle+p.y*9.0 + time)*.1);\nfloat thin = 0.035 + 0.02*sin(p.y*10.0+time*1. + angle);\nvec3 col = vec3(0.5+0.4*cos(angle*vec3(3.7,1.8,2.9))) * thin / abs (radius - 0.3+sin(20.0*p.x*p.y)*0.1);\nd = abs(d)+0.015;\nd = 1.0-smoothstep(0.02,0.025,d);\ncol+=d*(vec3(0.3,1.,0.3)*1.0+sin(time*4.0)*0.3);\nd2 = abs(d2)+0.02;\nd2 = 1.0-smoothstep(0.03,0.04,d2);\ncol.rgb+=d2*vec3(0.9,0.9,0.9);\nfragColor = vec4(col,1.0);\n}\n \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slfWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 26, 53, 53, 121], [125, 125, 171, 171, 278], [279, 279, 336, 336, 1236]], "test": "untested"}
{"id": "3dlfWn", "name": "Tree Study", "author": "wyatt", "description": "Bifurcation of points in parallel - makes for some extreme rendering potential. Use the speed up if you have the plugin. ", "tags": ["fractaljfa"], "likes": 13, "viewed": 540, "published": 3, "date": "1588032718", "time_retrieved": "2024-07-30T21:10:06.699620", "image_code": "Main { Q = B(U); }", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texelFetch(iChannel2,ivec2(U),0)\n#define D(U) texelFetch(iChannel3,ivec2(U),0)\n#define pi 3.14159265359\n#define Main void mainImage(out vec4 Q, vec2 U) \n#define e(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define N 8.\n#define I 10.\nvec2 hash22(vec2 p) // Dave H\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nfloat sg (vec2 p, vec2 a, vec2 b) {\n    return  length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n    \n}", "buffer_a_code": "void Y (inout vec4 Q, vec2 U, vec4 n) {\n\tif ((sg(U,Q.xy,Q.zw)>sg(U,n.xy,n.zw)||length(Q.xy)<3.)&&\n        length(n.xy)>3.) Q = n;\n}\nMain {\n    U = round(U);\n\tQ = A(U);\n    Q = round(Q);\n    float iN = mod(float(iFrame),N);\n    if (iN<.5) {\n        if (mod(float(iFrame),N*I)<.5) {\n           Q = vec4(R.x*(0.5+0.5*sin(2.61*iTime)),\n                    0.25*R.y,\n                    R.x*(0.5+0.5*sin(2.61*iTime)),\n                    0.);\n        } else {\n            float\n                  n = 1.+mod(floor(float(iFrame)/N/3.),4.),\n                  n2 = 1.+mod(floor(float(iFrame+124231)/N/3.),3.),\n                  s = mod(floor(U.x+R.x*U.y),n),\n                  l = length(Q.zw-Q.xy),\n                  a = .3*sin(l+float(iFrame))*\n                \t  (s-n2+ceil(0.5*n))*pi;\n            vec2 h = .1*l*(hash22(floor(Q.xy))*2.-1.);\n            vec2 t = Q.xy,\n                 g = sin(.5*iTime)*vec2(0,0.0001*R.y*(-0.6*N+iN)*abs((-0.6*N+iN)));\n            Q.xy = Q.xy - 0.7*(Q.zw-Q.xy)+.2*(h+g);\n            Q.xy = t+(Q.xy-t)*e(a);\n        \tQ.zw = t;\n        }\n    }\n    else {\n        float k = exp2(N-1.-mod(float(iFrame),N));\n    \tY(Q,U,A(U+vec2(0,k)));\n    \tY(Q,U,A(U+vec2(k,0)));\n    \tY(Q,U,A(U-vec2(0,k)));\n    \tY(Q,U,A(U-vec2(k,0)));\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n\tvec4 a = A(U);\n    float l = length(a.xy-a.zw);\n    if (length(a.xy)<3.||length(a.zw)<3.){Q = B(U); return;}\n    float r = sg(U,a.zw,a.xy),r1=sg(U+1.,a.zw,a.xy);\n    Q = (0.8+0.6*sin(.01*float(iFrame)+mod(float(iFrame),N*I)/N/I*(vec4(1,2,3,4))));\n    float x = exp(-.1/(1.+.01*l*l)*r*r*r*r),\n    \t  y = exp(-.05/(1.+.01*l*l)*r1*r1*r1*r1);\n    vec4 b = B(U);\n    vec4 m = 0.25*(B(U+vec2(0,1))+B(U+vec2(1,0))+B(U-vec2(0,1))+B(U-vec2(1,0)));\n    b = mix(b,m,0.05);\n    Q = mix(b*(1.-0.5*y),Q*x,0.5*x);\n    Q = min(Q,vec4(1));\n    if (iFrame < 1) Q = vec4(0);\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlfWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "tdffWr", "name": "Permutation Grid", "author": "mla", "description": "All 720 permutations of 6 elements. Press 'x' to multiply permutation index by int(iTime) - if coprime to 2,3,5, then still get full set, otherwise, a reduced selection. Now uses lexicographically ordered unranking - press 'l' to see other ordering.", "tags": ["permutations"], "likes": 9, "viewed": 458, "published": 3, "date": "1588021407", "time_retrieved": "2024-07-30T21:10:07.468564", "image_code": "const int N = 6;\n// Shuffle the array according to the rank.\n// 0 <= k < N!\nint unrankperm(int k, int t) {\n  int a[N];\n  for (int i = 0; i < N; i++) {\n    a[i] = i;\n  }\n  for (int i = 0; i < N-1; i++) {\n    int k1 = k%(N-i);\n    k = k/(N-i);\n    int tmp = a[i+k1];\n    if (i == t) return tmp;\n    a[i+k1] = a[i];\n    a[i] = tmp;\n\n  }\n  return a[t];\n}\n\n// unrank in lexicographic order - shuffle, but instead of\n// swapping the selected item with the front item, just\n// close the gap, but keep the same order.\nint unrankperm2(int k, int t) {\n  int a[N];\n  int p = 1;\n  for (int i = 0; i < N; i++) {\n    a[i] = i;\n    p *= i+1;\n  }\n  // p is N!\n  for (int i = N; i > 1; i--) {\n    p /= i;\n    // p is (i-1)!\n    int k1 = k/p;\n    k = k%p;\n    int tmp = a[k1];\n    for (int j = k1; j < i-1; j++) {\n      a[j] = a[j+1];\n    }\n    a[i-1] = tmp;\n  }\n  return a[N-t-1];\n}\n\nvec3 colors[] =\n  vec3[](vec3(1,0,0),vec3(1,1,0),vec3(0,1,0),\n         vec3(0,1,1),vec3(0,0,1),vec3(1,0,1));\n\nbool key(int code) {\n  return texelFetch(iChannel3, ivec2(code,2),0).x != 0.0;\n}\n\nconst int CHAR_L = 76;\nconst int CHAR_X = 88;\n\nvec3 bgcolor(vec2 fragCoord) {\n  ivec2 pdim = ivec2(iResolution.xy);\n  ivec2 pcoord = ivec2(fragCoord);\n  pcoord.y = pdim.y-1-pcoord.y;\n  vec3 col = vec3(0.2);\n  int W = 12, W1 = N;\n  int H = 10, H1 = 6;\n  int M = 1;\n  ivec2 bdim = ivec2(W*(W1+M)+M, H*(H1+M)+M);\n  ivec2 bcoord = pcoord*bdim/pdim;\n  int nwidth = bdim.x;\n  int nheight = bdim.y;\n  int i = bcoord.x, j = bcoord.y;\n  int i1 = (i+W1)%(W1+M); // Index within a horizontal block\n  int j1 = (j+H1)%(H1+M);   // Index within a vertical block\n  if (i1 < W1 && j1 < H1) {\n    int index = (i-M)/(W1+M)*(H*H1)+(j-M)/(H1+M)*H1+j1;\n    if (key(CHAR_X)) index = index*int(iTime)%(W*H*H1);\n    int p = key(CHAR_L) ? unrankperm(index,i1) : unrankperm2(index,i1);\n    col = colors[p];\n  }\n  ivec2 boffset = (bcoord*pdim+bdim-1)/bdim; // Index of 1st pixel in block\n  if (bcoord.x > 0 && j1 < H1 && pcoord.x == boffset.x) col = vec3(0);\n  if (bcoord.y > 0 && i1 < W1 && pcoord.y == boffset.y) col = vec3(0);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  fragColor = vec4(bgcolor(fragCoord),1);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdffWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 76, 106, 106, 350], [352, 510, 541, 541, 865], [977, 977, 997, 997, 1057], [1106, 1106, 1136, 1136, 2077], [2079, 2079, 2131, 2131, 2175]], "test": "untested"}
{"id": "wsfBWr", "name": "Julia 7 v1", "author": "jonGomez", "description": "Julia set, inspired by https://en.wikipedia.org/wiki/Julia_set#/media/File:JSr07885.gif", "tags": ["julia", "mandelbrot", "fractals"], "likes": 3, "viewed": 343, "published": 3, "date": "1588020315", "time_retrieved": "2024-07-30T21:10:08.291365", "image_code": "// inspired by https://en.wikipedia.org/wiki/Julia_set#/media/File:JSr07885.gif\n// https://www.shadertoy.com/view/XljGzV\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (y: -1 to 1 ;; x: -something to something)\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    \n    vec2 z = uv;\n    \n    float my_const = 0.7885;\n    float theta = iTime*0.4;\n    vec2 c = vec2(my_const*cos(theta), my_const*sin(theta));\n    \n    const float max_steps = 65.;\n    float boundary = 20.;\n    float num_steps;\n    \n    for(num_steps = 0.; num_steps<max_steps; num_steps++) {\n    \tz = vec2(z.x*z.x - z.y*z.y, 2.*z.x*z.y) + c;\n        if(length(z) > boundary) break;\n    }\n    \n    float pixel_intensity = num_steps/max_steps;\n    \n    vec3 col = hsl2rgb(vec3(pixel_intensity + .6,1., smoothstep(1.,.8,pixel_intensity)*.5));\n \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfBWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 121, 148, 148, 291], [293, 293, 350, 429, 1094]], "test": "untested"}
{"id": "wdXBWr", "name": "cospalette04", "author": "paulobarcelos", "description": "cospalette04", "tags": ["cs"], "likes": 2, "viewed": 338, "published": 3, "date": "1588017912", "time_retrieved": "2024-07-30T21:10:09.196943", "image_code": "const int FPS = 60;\nconst float DURATION = 15.0;\nconst int TOTAL_FRAMES = int(float(FPS) * DURATION);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float progress = float(iFrame % TOTAL_FRAMES) / float(TOTAL_FRAMES);\n    float osc1 = sin(progress * PI2);\n    float osc2 = cos(progress * PI2);\n    vec2 uv = (fragCoord.xy / iResolution.xy) + 1.0;\n    \n    vec3 c = cosPalette((voronoi(uv) + pow(uv.x, 1.0)) * (voronoi(uv) + pow(uv.y, 2.5))  * (osc1 + 4.0) * 0.5,\n        vec3(voronoi(uv), 0.4, 0.3),\n        vec3(0.4, voronoi(uv), 0.),\n        vec3(voronoi(uv), 0.4, 0.9),\n        vec3(0.2, 0.4, 0.3)\n    );\n    fragColor = vec4(pow(c, vec3(1.1, 1.9, 1.0)), 1.0);\n}", "image_inputs": [], "common_code": "float PI = 3.14159;\nfloat PI2 = 6.28318;\n\nvec3 black = vec3(0.0);\nvec3 white = vec3(1.0);\nvec3 red = vec3(0.86,0.22,0.27);   \nvec3 orange = vec3(0.92,0.49,0.07);\nvec3 yellow = vec3(0.91,0.89,0.26);\nvec3 green = vec3(0.0,0.71,0.31);\nvec3 blue = vec3(0.05,0.35,0.65);\nvec3 purple = vec3(0.38,0.09,0.64);\nvec3 pink = vec3(.9,0.758,0.798);\nvec3 lime = vec3(0.361,0.969,0.282);\nvec3 teal = vec3(0.396,0.878,0.878);\nvec3 magenta = vec3(1.0, 0.189, 0.745);\nvec3 brown = vec3(0.96, 0.474, 0.227);\n\n\n\nfloat kale(vec2 p, float n) {\n  return abs(mod(atan(p.x, p.y), n) - n * .5);\n}\n\nfloat box(vec2 p,vec2 b,float r,float f) {\n    return smoothstep(f, 0.0, length(max(abs(p)-b,0.0))-r);\n}\n\n\n\nvec2 rotate(vec2 space, vec2 center, float amount){\n    return vec2(cos(amount) * (space.x - center.x) + sin(amount) * (space.y - center.y),\n        cos(amount) * (space.y - center.y) - sin(amount) * (space.x - center.x));\n}\n\nvec2 mod289(vec2 x) { return x - floor(x * (1.0/289.0)) * 289.0; }\nvec3 mod289(vec3 x) { return x - floor(x * (1.0/289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nconst mat2 myt = mat2(.12121212,.13131313,-.13131313,.12121212);\nconst vec2 mys = vec2(1e4, 1e6);\nvec2 rhash(vec2 uv) {\n    uv *= myt;\n    uv *= mys;\n    return  fract(fract(uv/mys)*uv);\n}\nvec3 hash( vec3 p ){\n    return fract(sin(vec3( dot(p,vec3(1.0,57.0,113.0)), \n                           dot(p,vec3(57.0,113.0,1.0)),\n                           dot(p,vec3(113.0,1.0,57.0))))*43758.5453);\n\n}\n\nfloat rand(const in float n){return fract(sin(n) * 1e4);}\nfloat rand(const in vec2 n) { return fract(1e4 * sin(17.0 * n.x + n.y * 0.1) * (0.1 + abs(sin(n.y * 13.0 + n.x))));\n}\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(rand(i), rand(i + 1.0), u);\n}\n\nfloat noise(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( rand(n + dot(step, vec3(0, 0, 0))), rand(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( rand(n + dot(step, vec3(0, 1, 0))), rand(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( rand(n + dot(step, vec3(0, 0, 1))), rand(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( rand(n + dot(step, vec3(0, 1, 1))), rand(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nconst vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);\nfloat snoise(vec2 v){\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m;\n    m = m*m;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nconst vec2  CC = vec2(1.0/6.0, 1.0/3.0) ;\nconst vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\nfloat snoise(vec3 v){ \n\n  vec3 i  = floor(v + dot(v, CC.yyy) );\n  vec3 x0 =   v - i + dot(i, CC.xxx) ;\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n  vec3 x1 = x0 - i1 + 1.0 * CC.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * CC.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * CC.xxx;\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat voronoi(const in vec2 point )\n{\n    vec2 p = floor( point );\n    vec2 f = fract( point );\n    float res = 0.0;\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec2 b = vec2( i, j );\n            vec2 r = vec2( b ) - f + rhash( p + b);\n            res += 1./pow(dot(r,r),8.);\n        }\n    }\n    return pow(1./res, 0.0625);\n}\n\nvec3 voronoi( const in vec3 x ) {\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n    float id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ ) {\n        for( int j=-1; j<=1; j++ ) {\n            for( int i=-1; i<=1; i++ ) {\n                vec3 b = vec3( float(i), float(j), float(k) );\n                vec3 r = vec3( b ) - f + hash( p + b );\n                float d = dot( r, r );\n\n                float cond = max(sign(res.x - d), 0.0);\n                float nCond = 1.0 - cond;\n\n                float cond2 = nCond * max(sign(res.y - d), 0.0);\n                float nCond2 = 1.0 - cond2;\n\n                id = (dot(p + b, vec3(1.0, 57.0, 113.0)) * cond) + (id * nCond);\n                res = vec2(d, res.x) * cond + res * nCond;\n\n                res.y = cond2 * d + nCond2 * res.y;\n            }\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\n//brownian\nfloat fbm(float x, const in int it) {\n    float v = 0.0;\n    float a = 0.5;\n    float shift = float(100);\n    for (int i = 0; i < 32; ++i) {\n        if(i<it) {\n            v += a * noise(x);\n            x = x * 2.0 + shift;\n            a *= 0.5;\n        }\n    }\n    return v;\n}\n\nfloat fbm(vec2 x, const in int it) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < 32; ++i) {\n        if(i<it) {\n            v += a * noise(x);\n            x = rot * x * 2.0 + shift;\n            a *= 0.5;\n        }\n    }\n    return v;\n}\n\nfloat fbm(vec3 x, const in int it) {\n    float v = 0.0;\n    float a = 0.5;\n    vec3 shift = vec3(100);\n    for (int i = 0; i < 32; ++i) {\n        if(i<it) {\n            v += a * noise(x);\n            x = x * 2.0 + shift;\n            a *= 0.5;\n        }\n    }\n    return v;\n}\n\n//ridged multifractal\nfloat rmf(vec2 uv, const in int it) {\n    float l = 2.;\n    float r = 0.;\n    float a = 0.5;\n    float f = 1.0;\n    for(int i = 0; i < 32; i++) {\n        if(i<it) {\n            uv = uv.yx * l;\n            float n = noise(uv);     \n            n = abs(fract(n-.5)-.5);\n            n *= n * a;\n            a = clamp(0.,1., n*2.);\n            r += n*pow(f, -1.);\n            f *= l;\n        }\n    }\n    return r*2.;\n}\n\n//voronoi fbm\nfloat vfbm(const in vec2 uv, const in int it) {\n    float n = 0.;\n    float a = 0.5;\n    float f = 1.0;\n    for(int i = 0; i < 32; i++) {\n        if(i<it) {\n            n += voronoi(uv*f)*a;\n            f *= 2.;\n            a *= .5;\n        }\n    }\n    return n;\n}\n\n//ridged multifractal\nfloat vrmf(vec2 uv, const in int it) {\n    float l = 2.;\n    float r = 0.;\n    float a = 0.5;\n    float f = 1.0;\n    for(int i = 0; i < 32; i++) {\n        if(i<it) {\n            uv = uv.yx * l;\n            float n = voronoi(uv);     \n            n = abs(fract(n-.5)-.5);\n            n *= n * a;\n            a = clamp(0.,1., n*2.);\n            r += n*pow(f, -1.);\n            f *= l;\n        }\n    }\n    return r*2.;\n}\n\nconst vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// https://iquilezles.org/articles/palettes\n// As t runs from 0 to 1 (our normalized palette index or domain), \n//the cosine oscilates c times with a phase of d. \n//The result is scaled and biased by a and b to meet the desired constrast and brightness.\nvec3 cosPalette( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXBWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 160, 160, 681]], "test": "untested"}
{"id": "wsffDn", "name": "cospalette03", "author": "paulobarcelos", "description": "cospalette03", "tags": ["cos"], "likes": 1, "viewed": 291, "published": 3, "date": "1588017438", "time_retrieved": "2024-07-30T21:10:09.951925", "image_code": "const int FPS = 60;\nconst float DURATION = 7.5;\nconst int TOTAL_FRAMES = int(float(FPS) * DURATION);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float progress = float(iFrame % TOTAL_FRAMES) / float(TOTAL_FRAMES);\n    float osc1 = cos(progress * PI2);\n    vec2 uv = (fragCoord.xy / iResolution.xy) * (1.0 - osc1 * 0.1) + sin(progress * PI2 )* 0.05;\n    \n    vec3 c = cosPalette((snoise(uv) +  pow(uv.x, 4.0))  * (osc1 + 10.0),\n        vec3(0.6, 0.4, 0.3),\n        vec3(2.0, 0.4, 0.3),\n        vec3(0.2, 0.4, 0.5),\n        vec3(0.2, 0.2, osc1)\n    );\n    fragColor = vec4(pow(c, vec3(10.0,0.9,1.0)), 1.0);\n}", "image_inputs": [], "common_code": "float PI = 3.14159;\nfloat PI2 = 6.28318;\n\nvec3 black = vec3(0.0);\nvec3 white = vec3(1.0);\nvec3 red = vec3(0.86,0.22,0.27);   \nvec3 orange = vec3(0.92,0.49,0.07);\nvec3 yellow = vec3(0.91,0.89,0.26);\nvec3 green = vec3(0.0,0.71,0.31);\nvec3 blue = vec3(0.05,0.35,0.65);\nvec3 purple = vec3(0.38,0.09,0.64);\nvec3 pink = vec3(.9,0.758,0.798);\nvec3 lime = vec3(0.361,0.969,0.282);\nvec3 teal = vec3(0.396,0.878,0.878);\nvec3 magenta = vec3(1.0, 0.189, 0.745);\nvec3 brown = vec3(0.96, 0.474, 0.227);\n\n\n\nfloat kale(vec2 p, float n) {\n  return abs(mod(atan(p.x, p.y), n) - n * .5);\n}\n\nfloat box(vec2 p,vec2 b,float r,float f) {\n    return smoothstep(f, 0.0, length(max(abs(p)-b,0.0))-r);\n}\n\n\n\nvec2 rotate(vec2 space, vec2 center, float amount){\n    return vec2(cos(amount) * (space.x - center.x) + sin(amount) * (space.y - center.y),\n        cos(amount) * (space.y - center.y) - sin(amount) * (space.x - center.x));\n}\n\nvec2 mod289(vec2 x) { return x - floor(x * (1.0/289.0)) * 289.0; }\nvec3 mod289(vec3 x) { return x - floor(x * (1.0/289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nconst mat2 myt = mat2(.12121212,.13131313,-.13131313,.12121212);\nconst vec2 mys = vec2(1e4, 1e6);\nvec2 rhash(vec2 uv) {\n    uv *= myt;\n    uv *= mys;\n    return  fract(fract(uv/mys)*uv);\n}\nvec3 hash( vec3 p ){\n    return fract(sin(vec3( dot(p,vec3(1.0,57.0,113.0)), \n                           dot(p,vec3(57.0,113.0,1.0)),\n                           dot(p,vec3(113.0,1.0,57.0))))*43758.5453);\n\n}\n\nfloat rand(const in float n){return fract(sin(n) * 1e4);}\nfloat rand(const in vec2 n) { return fract(1e4 * sin(17.0 * n.x + n.y * 0.1) * (0.1 + abs(sin(n.y * 13.0 + n.x))));\n}\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(rand(i), rand(i + 1.0), u);\n}\n\nfloat noise(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( rand(n + dot(step, vec3(0, 0, 0))), rand(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( rand(n + dot(step, vec3(0, 1, 0))), rand(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( rand(n + dot(step, vec3(0, 0, 1))), rand(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( rand(n + dot(step, vec3(0, 1, 1))), rand(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nconst vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);\nfloat snoise(vec2 v){\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m;\n    m = m*m;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nconst vec2  CC = vec2(1.0/6.0, 1.0/3.0) ;\nconst vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\nfloat snoise(vec3 v){ \n\n  vec3 i  = floor(v + dot(v, CC.yyy) );\n  vec3 x0 =   v - i + dot(i, CC.xxx) ;\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n  vec3 x1 = x0 - i1 + 1.0 * CC.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * CC.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * CC.xxx;\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat voronoi(const in vec2 point )\n{\n    vec2 p = floor( point );\n    vec2 f = fract( point );\n    float res = 0.0;\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec2 b = vec2( i, j );\n            vec2 r = vec2( b ) - f + rhash( p + b);\n            res += 1./pow(dot(r,r),8.);\n        }\n    }\n    return pow(1./res, 0.0625);\n}\n\nvec3 voronoi( const in vec3 x ) {\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n    float id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ ) {\n        for( int j=-1; j<=1; j++ ) {\n            for( int i=-1; i<=1; i++ ) {\n                vec3 b = vec3( float(i), float(j), float(k) );\n                vec3 r = vec3( b ) - f + hash( p + b );\n                float d = dot( r, r );\n\n                float cond = max(sign(res.x - d), 0.0);\n                float nCond = 1.0 - cond;\n\n                float cond2 = nCond * max(sign(res.y - d), 0.0);\n                float nCond2 = 1.0 - cond2;\n\n                id = (dot(p + b, vec3(1.0, 57.0, 113.0)) * cond) + (id * nCond);\n                res = vec2(d, res.x) * cond + res * nCond;\n\n                res.y = cond2 * d + nCond2 * res.y;\n            }\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\n//brownian\nfloat fbm(float x, const in int it) {\n    float v = 0.0;\n    float a = 0.5;\n    float shift = float(100);\n    for (int i = 0; i < 32; ++i) {\n        if(i<it) {\n            v += a * noise(x);\n            x = x * 2.0 + shift;\n            a *= 0.5;\n        }\n    }\n    return v;\n}\n\nfloat fbm(vec2 x, const in int it) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < 32; ++i) {\n        if(i<it) {\n            v += a * noise(x);\n            x = rot * x * 2.0 + shift;\n            a *= 0.5;\n        }\n    }\n    return v;\n}\n\nfloat fbm(vec3 x, const in int it) {\n    float v = 0.0;\n    float a = 0.5;\n    vec3 shift = vec3(100);\n    for (int i = 0; i < 32; ++i) {\n        if(i<it) {\n            v += a * noise(x);\n            x = x * 2.0 + shift;\n            a *= 0.5;\n        }\n    }\n    return v;\n}\n\n//ridged multifractal\nfloat rmf(vec2 uv, const in int it) {\n    float l = 2.;\n    float r = 0.;\n    float a = 0.5;\n    float f = 1.0;\n    for(int i = 0; i < 32; i++) {\n        if(i<it) {\n            uv = uv.yx * l;\n            float n = noise(uv);     \n            n = abs(fract(n-.5)-.5);\n            n *= n * a;\n            a = clamp(0.,1., n*2.);\n            r += n*pow(f, -1.);\n            f *= l;\n        }\n    }\n    return r*2.;\n}\n\n//voronoi fbm\nfloat vfbm(const in vec2 uv, const in int it) {\n    float n = 0.;\n    float a = 0.5;\n    float f = 1.0;\n    for(int i = 0; i < 32; i++) {\n        if(i<it) {\n            n += voronoi(uv*f)*a;\n            f *= 2.;\n            a *= .5;\n        }\n    }\n    return n;\n}\n\n//ridged multifractal\nfloat vrmf(vec2 uv, const in int it) {\n    float l = 2.;\n    float r = 0.;\n    float a = 0.5;\n    float f = 1.0;\n    for(int i = 0; i < 32; i++) {\n        if(i<it) {\n            uv = uv.yx * l;\n            float n = voronoi(uv);     \n            n = abs(fract(n-.5)-.5);\n            n *= n * a;\n            a = clamp(0.,1., n*2.);\n            r += n*pow(f, -1.);\n            f *= l;\n        }\n    }\n    return r*2.;\n}\n\nconst vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// https://iquilezles.org/articles/palettes\n// As t runs from 0 to 1 (our normalized palette index or domain), \n//the cosine oscilates c times with a phase of d. \n//The result is scaled and biased by a and b to meet the desired constrast and brightness.\nvec3 cosPalette( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsffDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 159, 159, 625]], "test": "untested"}
{"id": "wsXfDn", "name": "cospalette02", "author": "paulobarcelos", "description": "cospalette02", "tags": ["cos"], "likes": 3, "viewed": 284, "published": 3, "date": "1588016699", "time_retrieved": "2024-07-30T21:10:10.716879", "image_code": "const int FPS = 60;\nconst float DURATION = 15.0;\nconst int TOTAL_FRAMES = int(float(FPS) * DURATION);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float progress = float(iFrame % TOTAL_FRAMES) / float(TOTAL_FRAMES);\n    float osc1 = sin(progress * PI2);\n    vec2 uv = (fragCoord.xy / iResolution.xy) + 1.0;\n    \n    vec3 c = cosPalette((snoise(uv) + pow(uv.x, 1.0))  * (osc1 + 2.0),\n        vec3(0.7, 0.4, 0.3),\n        vec3(0.7, 0.5, 0.3),\n        vec3(0.7, 0.4, 0.5),\n        vec3(0.7, 0.4, 0.3)\n    );\n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "float PI = 3.14159;\nfloat PI2 = 6.28318;\n\nvec3 black = vec3(0.0);\nvec3 white = vec3(1.0);\nvec3 red = vec3(0.86,0.22,0.27);   \nvec3 orange = vec3(0.92,0.49,0.07);\nvec3 yellow = vec3(0.91,0.89,0.26);\nvec3 green = vec3(0.0,0.71,0.31);\nvec3 blue = vec3(0.05,0.35,0.65);\nvec3 purple = vec3(0.38,0.09,0.64);\nvec3 pink = vec3(.9,0.758,0.798);\nvec3 lime = vec3(0.361,0.969,0.282);\nvec3 teal = vec3(0.396,0.878,0.878);\nvec3 magenta = vec3(1.0, 0.189, 0.745);\nvec3 brown = vec3(0.96, 0.474, 0.227);\n\n\n\nfloat kale(vec2 p, float n) {\n  return abs(mod(atan(p.x, p.y), n) - n * .5);\n}\n\nfloat box(vec2 p,vec2 b,float r,float f) {\n    return smoothstep(f, 0.0, length(max(abs(p)-b,0.0))-r);\n}\n\n\n\nvec2 rotate(vec2 space, vec2 center, float amount){\n    return vec2(cos(amount) * (space.x - center.x) + sin(amount) * (space.y - center.y),\n        cos(amount) * (space.y - center.y) - sin(amount) * (space.x - center.x));\n}\n\nvec2 mod289(vec2 x) { return x - floor(x * (1.0/289.0)) * 289.0; }\nvec3 mod289(vec3 x) { return x - floor(x * (1.0/289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nconst mat2 myt = mat2(.12121212,.13131313,-.13131313,.12121212);\nconst vec2 mys = vec2(1e4, 1e6);\nvec2 rhash(vec2 uv) {\n    uv *= myt;\n    uv *= mys;\n    return  fract(fract(uv/mys)*uv);\n}\nvec3 hash( vec3 p ){\n    return fract(sin(vec3( dot(p,vec3(1.0,57.0,113.0)), \n                           dot(p,vec3(57.0,113.0,1.0)),\n                           dot(p,vec3(113.0,1.0,57.0))))*43758.5453);\n\n}\n\nfloat rand(const in float n){return fract(sin(n) * 1e4);}\nfloat rand(const in vec2 n) { return fract(1e4 * sin(17.0 * n.x + n.y * 0.1) * (0.1 + abs(sin(n.y * 13.0 + n.x))));\n}\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(rand(i), rand(i + 1.0), u);\n}\n\nfloat noise(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( rand(n + dot(step, vec3(0, 0, 0))), rand(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( rand(n + dot(step, vec3(0, 1, 0))), rand(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( rand(n + dot(step, vec3(0, 0, 1))), rand(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( rand(n + dot(step, vec3(0, 1, 1))), rand(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nconst vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);\nfloat snoise(vec2 v){\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m;\n    m = m*m;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nconst vec2  CC = vec2(1.0/6.0, 1.0/3.0) ;\nconst vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\nfloat snoise(vec3 v){ \n\n  vec3 i  = floor(v + dot(v, CC.yyy) );\n  vec3 x0 =   v - i + dot(i, CC.xxx) ;\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n  vec3 x1 = x0 - i1 + 1.0 * CC.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * CC.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * CC.xxx;\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat voronoi(const in vec2 point )\n{\n    vec2 p = floor( point );\n    vec2 f = fract( point );\n    float res = 0.0;\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec2 b = vec2( i, j );\n            vec2 r = vec2( b ) - f + rhash( p + b);\n            res += 1./pow(dot(r,r),8.);\n        }\n    }\n    return pow(1./res, 0.0625);\n}\n\nvec3 voronoi( const in vec3 x ) {\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n    float id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ ) {\n        for( int j=-1; j<=1; j++ ) {\n            for( int i=-1; i<=1; i++ ) {\n                vec3 b = vec3( float(i), float(j), float(k) );\n                vec3 r = vec3( b ) - f + hash( p + b );\n                float d = dot( r, r );\n\n                float cond = max(sign(res.x - d), 0.0);\n                float nCond = 1.0 - cond;\n\n                float cond2 = nCond * max(sign(res.y - d), 0.0);\n                float nCond2 = 1.0 - cond2;\n\n                id = (dot(p + b, vec3(1.0, 57.0, 113.0)) * cond) + (id * nCond);\n                res = vec2(d, res.x) * cond + res * nCond;\n\n                res.y = cond2 * d + nCond2 * res.y;\n            }\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\n//brownian\nfloat fbm(float x, const in int it) {\n    float v = 0.0;\n    float a = 0.5;\n    float shift = float(100);\n    for (int i = 0; i < 32; ++i) {\n        if(i<it) {\n            v += a * noise(x);\n            x = x * 2.0 + shift;\n            a *= 0.5;\n        }\n    }\n    return v;\n}\n\nfloat fbm(vec2 x, const in int it) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < 32; ++i) {\n        if(i<it) {\n            v += a * noise(x);\n            x = rot * x * 2.0 + shift;\n            a *= 0.5;\n        }\n    }\n    return v;\n}\n\nfloat fbm(vec3 x, const in int it) {\n    float v = 0.0;\n    float a = 0.5;\n    vec3 shift = vec3(100);\n    for (int i = 0; i < 32; ++i) {\n        if(i<it) {\n            v += a * noise(x);\n            x = x * 2.0 + shift;\n            a *= 0.5;\n        }\n    }\n    return v;\n}\n\n//ridged multifractal\nfloat rmf(vec2 uv, const in int it) {\n    float l = 2.;\n    float r = 0.;\n    float a = 0.5;\n    float f = 1.0;\n    for(int i = 0; i < 32; i++) {\n        if(i<it) {\n            uv = uv.yx * l;\n            float n = noise(uv);     \n            n = abs(fract(n-.5)-.5);\n            n *= n * a;\n            a = clamp(0.,1., n*2.);\n            r += n*pow(f, -1.);\n            f *= l;\n        }\n    }\n    return r*2.;\n}\n\n//voronoi fbm\nfloat vfbm(const in vec2 uv, const in int it) {\n    float n = 0.;\n    float a = 0.5;\n    float f = 1.0;\n    for(int i = 0; i < 32; i++) {\n        if(i<it) {\n            n += voronoi(uv*f)*a;\n            f *= 2.;\n            a *= .5;\n        }\n    }\n    return n;\n}\n\n//ridged multifractal\nfloat vrmf(vec2 uv, const in int it) {\n    float l = 2.;\n    float r = 0.;\n    float a = 0.5;\n    float f = 1.0;\n    for(int i = 0; i < 32; i++) {\n        if(i<it) {\n            uv = uv.yx * l;\n            float n = voronoi(uv);     \n            n = abs(fract(n-.5)-.5);\n            n *= n * a;\n            a = clamp(0.,1., n*2.);\n            r += n*pow(f, -1.);\n            f *= l;\n        }\n    }\n    return r*2.;\n}\n\nconst vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// https://iquilezles.org/articles/palettes\n// As t runs from 0 to 1 (our normalized palette index or domain), \n//the cosine oscilates c times with a phase of d. \n//The result is scaled and biased by a and b to meet the desired constrast and brightness.\nvec3 cosPalette( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXfDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 160, 160, 554]], "test": "untested"}
{"id": "wdfBDn", "name": "cospalette01", "author": "paulobarcelos", "description": "cospalette01", "tags": ["cos"], "likes": 2, "viewed": 290, "published": 3, "date": "1588015134", "time_retrieved": "2024-07-30T21:10:11.540677", "image_code": "const int FPS = 60;\nconst float DURATION = 15.0;\nconst int TOTAL_FRAMES = int(float(FPS) * DURATION);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float progress = float(iFrame % TOTAL_FRAMES) / float(TOTAL_FRAMES);\n    float osc1 = sin(progress * PI2);\n    vec2 uv = (fragCoord.xy / iResolution.xy) - 1.75;\n    \n    vec3 c = cosPalette((snoise(uv) + pow(uv.x, 1.0)) * (snoise(uv) + pow(uv.y, 3.0))  * (osc1 + 2.0),\n        vec3(0.7, 0.4, 0.3),\n        vec3(0.7, 0.5, 0.3),\n        vec3(0.7, 0.4, 0.5),\n        vec3(0.7, 0.4, 0.3)\n    );\n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "float PI = 3.14159;\nfloat PI2 = 6.28318;\n\nvec3 black = vec3(0.0);\nvec3 white = vec3(1.0);\nvec3 red = vec3(0.86,0.22,0.27);   \nvec3 orange = vec3(0.92,0.49,0.07);\nvec3 yellow = vec3(0.91,0.89,0.26);\nvec3 green = vec3(0.0,0.71,0.31);\nvec3 blue = vec3(0.05,0.35,0.65);\nvec3 purple = vec3(0.38,0.09,0.64);\nvec3 pink = vec3(.9,0.758,0.798);\nvec3 lime = vec3(0.361,0.969,0.282);\nvec3 teal = vec3(0.396,0.878,0.878);\nvec3 magenta = vec3(1.0, 0.189, 0.745);\nvec3 brown = vec3(0.96, 0.474, 0.227);\n\n\n\nfloat kale(vec2 p, float n) {\n  return abs(mod(atan(p.x, p.y), n) - n * .5);\n}\n\nfloat box(vec2 p,vec2 b,float r,float f) {\n    return smoothstep(f, 0.0, length(max(abs(p)-b,0.0))-r);\n}\n\n\n\nvec2 rotate(vec2 space, vec2 center, float amount){\n    return vec2(cos(amount) * (space.x - center.x) + sin(amount) * (space.y - center.y),\n        cos(amount) * (space.y - center.y) - sin(amount) * (space.x - center.x));\n}\n\nvec2 mod289(vec2 x) { return x - floor(x * (1.0/289.0)) * 289.0; }\nvec3 mod289(vec3 x) { return x - floor(x * (1.0/289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nconst mat2 myt = mat2(.12121212,.13131313,-.13131313,.12121212);\nconst vec2 mys = vec2(1e4, 1e6);\nvec2 rhash(vec2 uv) {\n    uv *= myt;\n    uv *= mys;\n    return  fract(fract(uv/mys)*uv);\n}\nvec3 hash( vec3 p ){\n    return fract(sin(vec3( dot(p,vec3(1.0,57.0,113.0)), \n                           dot(p,vec3(57.0,113.0,1.0)),\n                           dot(p,vec3(113.0,1.0,57.0))))*43758.5453);\n\n}\n\nfloat rand(const in float n){return fract(sin(n) * 1e4);}\nfloat rand(const in vec2 n) { return fract(1e4 * sin(17.0 * n.x + n.y * 0.1) * (0.1 + abs(sin(n.y * 13.0 + n.x))));\n}\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(rand(i), rand(i + 1.0), u);\n}\n\nfloat noise(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( rand(n + dot(step, vec3(0, 0, 0))), rand(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( rand(n + dot(step, vec3(0, 1, 0))), rand(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( rand(n + dot(step, vec3(0, 0, 1))), rand(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( rand(n + dot(step, vec3(0, 1, 1))), rand(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nconst vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);\nfloat snoise(vec2 v){\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m;\n    m = m*m;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nconst vec2  CC = vec2(1.0/6.0, 1.0/3.0) ;\nconst vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\nfloat snoise(vec3 v){ \n\n  vec3 i  = floor(v + dot(v, CC.yyy) );\n  vec3 x0 =   v - i + dot(i, CC.xxx) ;\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n  vec3 x1 = x0 - i1 + 1.0 * CC.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * CC.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * CC.xxx;\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat voronoi(const in vec2 point )\n{\n    vec2 p = floor( point );\n    vec2 f = fract( point );\n    float res = 0.0;\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec2 b = vec2( i, j );\n            vec2 r = vec2( b ) - f + rhash( p + b);\n            res += 1./pow(dot(r,r),8.);\n        }\n    }\n    return pow(1./res, 0.0625);\n}\n\nvec3 voronoi( const in vec3 x ) {\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n    float id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ ) {\n        for( int j=-1; j<=1; j++ ) {\n            for( int i=-1; i<=1; i++ ) {\n                vec3 b = vec3( float(i), float(j), float(k) );\n                vec3 r = vec3( b ) - f + hash( p + b );\n                float d = dot( r, r );\n\n                float cond = max(sign(res.x - d), 0.0);\n                float nCond = 1.0 - cond;\n\n                float cond2 = nCond * max(sign(res.y - d), 0.0);\n                float nCond2 = 1.0 - cond2;\n\n                id = (dot(p + b, vec3(1.0, 57.0, 113.0)) * cond) + (id * nCond);\n                res = vec2(d, res.x) * cond + res * nCond;\n\n                res.y = cond2 * d + nCond2 * res.y;\n            }\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\n//brownian\nfloat fbm(float x, const in int it) {\n    float v = 0.0;\n    float a = 0.5;\n    float shift = float(100);\n    for (int i = 0; i < 32; ++i) {\n        if(i<it) {\n            v += a * noise(x);\n            x = x * 2.0 + shift;\n            a *= 0.5;\n        }\n    }\n    return v;\n}\n\nfloat fbm(vec2 x, const in int it) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < 32; ++i) {\n        if(i<it) {\n            v += a * noise(x);\n            x = rot * x * 2.0 + shift;\n            a *= 0.5;\n        }\n    }\n    return v;\n}\n\nfloat fbm(vec3 x, const in int it) {\n    float v = 0.0;\n    float a = 0.5;\n    vec3 shift = vec3(100);\n    for (int i = 0; i < 32; ++i) {\n        if(i<it) {\n            v += a * noise(x);\n            x = x * 2.0 + shift;\n            a *= 0.5;\n        }\n    }\n    return v;\n}\n\n//ridged multifractal\nfloat rmf(vec2 uv, const in int it) {\n    float l = 2.;\n    float r = 0.;\n    float a = 0.5;\n    float f = 1.0;\n    for(int i = 0; i < 32; i++) {\n        if(i<it) {\n            uv = uv.yx * l;\n            float n = noise(uv);     \n            n = abs(fract(n-.5)-.5);\n            n *= n * a;\n            a = clamp(0.,1., n*2.);\n            r += n*pow(f, -1.);\n            f *= l;\n        }\n    }\n    return r*2.;\n}\n\n//voronoi fbm\nfloat vfbm(const in vec2 uv, const in int it) {\n    float n = 0.;\n    float a = 0.5;\n    float f = 1.0;\n    for(int i = 0; i < 32; i++) {\n        if(i<it) {\n            n += voronoi(uv*f)*a;\n            f *= 2.;\n            a *= .5;\n        }\n    }\n    return n;\n}\n\n//ridged multifractal\nfloat vrmf(vec2 uv, const in int it) {\n    float l = 2.;\n    float r = 0.;\n    float a = 0.5;\n    float f = 1.0;\n    for(int i = 0; i < 32; i++) {\n        if(i<it) {\n            uv = uv.yx * l;\n            float n = voronoi(uv);     \n            n = abs(fract(n-.5)-.5);\n            n *= n * a;\n            a = clamp(0.,1., n*2.);\n            r += n*pow(f, -1.);\n            f *= l;\n        }\n    }\n    return r*2.;\n}\n\nconst vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// https://iquilezles.org/articles/palettes\n// As t runs from 0 to 1 (our normalized palette index or domain), \n//the cosine oscilates c times with a phase of d. \n//The result is scaled and biased by a and b to meet the desired constrast and brightness.\nvec3 cosPalette( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfBDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 160, 160, 587]], "test": "untested"}
{"id": "tdXBWn", "name": "Stranded island", "author": "42yeah", "description": "This actually started as a water rendering experiment - https://iquilezles.org/articles/simplewater/simplewater.htm , but then I suddenly wanted to create an island and so I made one. I still have absolutely no idea about rendering water though.", "tags": ["raymarching", "water", "island"], "likes": 8, "viewed": 511, "published": 3, "date": "1588004851", "time_retrieved": "2024-07-30T21:10:12.358490", "image_code": "vec2 rand2d(vec2 p) {\n    return fract(sin(vec2(\n        dot(p, vec2(12.345, 67.890)),\n        dot(p, vec2(190.61, 312.21))\n    )) * 41235.45) * 2.0 - 1.0;\n}\n\nfloat perlin(vec3 p) {\n    vec2 u = floor(p.xz);\n    vec2 f = fract(p.xz);\n    vec2 s = smoothstep(0.0, 1.0, f);\n\n    vec2 a = rand2d(u);\n    vec2 b = rand2d(u + vec2(1.0, 0.0));\n    vec2 c = rand2d(u + vec2(0.0, 1.0));\n    vec2 d = rand2d(u + vec2(1.0, 1.0));\n\n    return mix(\n        mix(dot(a, f), dot(b, f - vec2(1.0, 0.0)), s.x),\n        mix(dot(c, f - vec2(0.0, 1.0)), dot(d, f - vec2(1.0, 1.0)), s.x),\n        s.y\n    );\n}\n\nfloat fbm(vec3 p) {\n    p.xz *= 2.0;\n    int octaves = 2;\n    float amplitude = 0.5;\n    float value = 0.0;\n    for (int i = 0; i < octaves; i++) {\n        p += iTime * vec3(0.1, 0.0, 0.3);\n        value += amplitude * perlin(p);\n        p *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\nfloat water(vec3 p) {\n    p.xz *= 0.2;\n    float f = fbm(p);\n    float g = fbm(p + vec3(0.5, 1.0, 0.2));\n    return p.y + fbm(vec3(f, 0.0, g)) - 0.5;\n}\n\nfloat distToCenter(vec3 p) {\n    return clamp(1.5 - length(p.xz) / 5.0, 0.0, 1.5);\n}\n\nfloat sol(vec3 p) {\n    float dtm = distToCenter(p);\n    float per = perlin(p * 0.7) * 1.0 + 3.5;\n    return p.y - per * dtm;\n//    return p.y + distToMiddle;\n}\n\nvec2 map(vec3 p) {\n    float closest = 1000.0;\n    float id = -1.0;\n    \n    float dist = water(p);\n    if (dist < closest) { closest = dist; id = 0.5; }\n    \n    dist = sol(p);\n    if (dist < closest) { closest = dist; id = 1.5; }\n    \n    return vec2(closest, id);\n}\n\nvec2 intersect(vec3 ro, vec3 rd) {\n    float depth = 0.0;\n    float id = -1.0;\n    for (int i = 0; i < 160; i++) {\n        vec2 info = map(ro + rd * depth);\n        if (info.x <= 0.001) {\n            id = info.y;\n            break;\n        }\n        depth += info.x;\n    }\n    return vec2(depth, id);\n}\n\nvec3 getIslandColor(vec3 p) {\n    vec3 baseColor = vec3(0.5, 0.21, 0.1);\n    float total = 1.0;\n    float sandiness = 1.0 - clamp((p.y - 0.2) * (perlin(p) * 0.5 + 0.5) * 1.3, 0.0, 1.0);\n    baseColor = mix(baseColor, vec3(0.76, 0.69, 0.5), sandiness);\n    \n    float grassiness = (total - sandiness) * clamp(1.0 - (p.y - 3.87), 0.0, 1.0);\n    baseColor = mix(baseColor, vec3(0.28, 0.6, 0.21), grassiness);\n    \n    baseColor = mix(baseColor, vec3(1.0, 1.0, 1.0), total - sandiness - grassiness);\n//    float dtm = distToMiddle(p);\n    return vec3(baseColor);\n}\n\nvec3 getSkyColor(vec3 p, vec3 rd) {\n    vec3 skyColor = vec3(0.3, 0.65, 0.99);\n    skyColor = mix(skyColor, vec3(1.0), pow(clamp(rd.y, 0.0, 1.0), 0.7));\n    return skyColor;\n}\n\nvec3 getColor(float id, vec3 p, vec3 rd) {\n    if (id < -0.5) { return getSkyColor(p, rd); }\n    if (id < 1.0) { return vec3(0.21, 0.67, 0.89) * 0.7; }\n    if (id < 2.0) { return getIslandColor(p); }\n    return vec3(1.0, 0.0, 0.0);\n}\n\nvec3 getNormal(vec3 p) {\n    const float epsilon = 0.001;\n    return normalize(vec3(\n        map(vec3(p.x + epsilon, p.yz)).x - map(vec3(p.x - epsilon, p.yz)).x,\n        map(vec3(p.x, p.y + epsilon, p.z)).x - map(vec3(p.x, p.y - epsilon, p.z)).x,\n        map(vec3(p.x, p.y, p.z + epsilon)).x - map(vec3(p.x, p.y, p.z - epsilon)).x\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    vec3 ro = vec3(13.0 - (sin(iTime) * 0.5 + 0.5), 3.0 + sin(iTime * 0.5), 1.0 + cos(iTime));\n    vec3 center = vec3(0.0, 1.5, 0.0);\n    \n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n    \n    vec3 front = normalize(center - ro);\n    vec3 right = normalize(cross(front, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, front));\n    mat4 lookAt = mat4(\n        vec4(right, 0.0),\n        vec4(up, 0.0),\n        vec4(front, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n    vec3 rd = normalize(vec3(lookAt * vec4(uv, 2.0, 1.0)));\n    \n    vec2 info = intersect(ro, rd);\n    \n    vec3 pos = ro + rd * info.x;\n    \n    float foginess = 1.0 - clamp(distToCenter(pos) * 6.0, 0.0, 1.0);\n    if (foginess >= 1.0) {\n        vec3 objColor = getSkyColor(pos, rd);\n        objColor = pow(objColor, vec3(0.4545));\n        fragColor = vec4(objColor, 1.0);\n        return;\n    }\n    vec3 n = getNormal(pos);\n    \n    float ambient = 1.0;\n    float diffuse = max(dot(n, lightDir), 0.0);\n    float dome = 0.2 + 0.8 * clamp(n.y, 0.0, 1.0);\n    float back = max(dot(n, vec3(-lightDir.x, 0.0, -lightDir.z)), 0.0);\n    \n    vec3 light = vec3(0.0);\n    light += ambient * vec3(0.1, 0.1, 0.1);\n    light += diffuse * vec3(1.0, 1.0, 1.12);\n    light += dome * vec3(0.1, 0.1, 0.4);\n    light += back * vec3(5.0, 2.9, 2.0);\n\n    if (info.y < -0.5) {\n        light = vec3(1.0);\n    }\n\n    vec3 objColor = getColor(info.y, pos, rd) * light;\n    objColor = mix(objColor, getSkyColor(pos, rd), foginess);\n    objColor = pow(objColor, vec3(0.4545));\n\n    fragColor = vec4(objColor, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXBWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 157], [159, 159, 181, 181, 588], [590, 590, 609, 609, 889], [891, 891, 912, 912, 1042], [1044, 1044, 1072, 1072, 1128], [1130, 1130, 1149, 1149, 1290], [1292, 1292, 1310, 1310, 1560], [1562, 1562, 1596, 1596, 1864], [1866, 1866, 1895, 1895, 2426], [2428, 2428, 2463, 2463, 2603], [2605, 2605, 2647, 2647, 2838], [2840, 2840, 2864, 2864, 3180], [3182, 3182, 3237, 3237, 4940]], "test": "untested"}
{"id": "wdsBR4", "name": "The magic mirror", "author": "friol", "description": "What's inside the magic mirror?", "tags": ["raymarching", "metaballs", "mirror", "mondrian"], "likes": 9, "viewed": 385, "published": 3, "date": "1588000501", "time_retrieved": "2024-07-30T21:10:13.317925", "image_code": "\n//\n// friol 2o2o\n// music KV by Bloc https://soundcloud.com/kvmusicprod/bloc\n// (watch this with music, please. be sure music is in sync)\n// sdf functions by iq\n// blob taken from mercury and modified\n// da rest is by P.Mondrian\n// 06.05.2020: reduced compilation time as for suggestions by iq\n//\n\nconst int iterationAmount=256;\nconst float patternLength=14.5;\nconst float numPatterns=4.0;\n\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nvec3 rotx(in vec3 p, float a) \n{\n\treturn vec3(p.x,\n                cos(a) * p.y + sin(a) * p.z,\n                cos(a) * p.z - sin(a) * p.y);\n}\n\nvec3 roty(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.z,\n                p.y,\n                cos(a) * p.z - sin(a) * p.x);\n}\n\nvec3 rotz(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.y,\n                cos(a) * p.y - sin(a) * p.x,\n                p.z);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat fBlob(vec3 p) \n{\n    float fft = texture( iChannel0, vec2(0.0,0.0) ).x;\n    p*=(1.5+(fft*0.4));\n    p=roty(p,iTime);\n    p=rotx(p,iTime);\n\n    float PHI=(sqrt(5.0)*0.5 + 0.5);\n\tp = abs(p);\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tif (p.x < min(p.y, p.z)) p = p.yzx;\n\tfloat b = max(max(min(\n\t\tdot(p, normalize(vec3(.3, 1., 1.))),\n\t\tdot(p.xz, normalize(vec2(PHI+1., 1.)))),\n\t\tdot(p.yx, normalize(vec2(1, PHI)))),\n\t\tdot(p.xz, normalize(vec2(1, PHI))));\n\tfloat l = length(p)/(1.0+.01*abs(sin(iTime)));\n\treturn l - 1.5 - 0.2 * (1.5 / 2.0)* .4*sin(min(sqrt(1.01 - b / l)*(3.141592 / 0.25), 3.141592));\n}\n\nvec2 SDF(vec3 r)\n{\n    vec3 rOrig=r;\n    float mat=0.0;\n\n    float plane0=sdPlane(r\t\t\t\t\t,vec4(0.0,1.0,0.0,1.0));\n    float plane1=sdPlane(r-vec3(0.0,0.1,0.0),vec4(0.0,-1.0,0.0,1.0));\n    \n    float domainRep=10.0;\n    vec3 c=vec3(domainRep);\n    r = mod(r+0.5*c,c)-0.5*c;\n    \n    float b0=sdBox(r,vec3(1.0,1.1,1.0));\n    float b1=sdBox(r,vec3(2.0,.9,.8));\n    float b2=sdBox(r-vec3(0.0,0.,0.0),vec3(0.8,0.9,2.0));\n    \n    float b3=sdBox(r-vec3(0.0,-0.9,-0.9),vec3(10.0,0.1,0.1));\n    float b4=sdBox(r-vec3(0.9,-0.9,0.0),vec3(0.1,0.1,10.0));\n    float b5=sdBox(r-vec3(-0.9,-0.9,0.0),vec3(0.1,0.1,10.0));\n    float b6=sdBox(r-vec3(0.0,-0.9,0.9),vec3(10.0,0.1,0.1));\n    float t1=opSubtraction(b1,b0);\n    float t0=opSubtraction(b2,t1);\n    t0=min(t0,b3);\n    t0=min(t0,b4);\n    t0=min(t0,b5);\n    t0=min(t0,b6);\n    \n    float s0=sdSphere(r-vec3(.6*sin(iTime),0.2*cos(iTime),.5*sin(iTime)),0.3);\n    float s1=sdSphere(r-vec3(.5*cos(iTime),-0.2*sin(iTime),0.0),0.2);\n    float s2=sdSphere(r-vec3(.7*cos(iTime),-0.5*cos(iTime),-.2*sin(iTime)),0.2);\n    \n    //vec2 uv = ((normal.xy + 1.0) * 0.5)*4.0;\n\t//float h = texture(iChannel0, uv).x/32.0;  \n\n    float h0=0.,h1=0.,h2=0.;\n    float unionCoeff=0.2;\n    float spheres=opSmoothUnion(opSmoothUnion(s0-h0,s1-h1,unionCoeff),s2-h2,unionCoeff);\n    \n    float pyr0=sdOctahedron((((r)-vec3(2.0,-2.0,0.0))),1.5);\n    float pyr1=sdOctahedron((((r)-vec3(-2.0,-2.0,0.0))),1.5);\n\n    float roamingSphere;\n    float sphTime=iTime*(patternLength/10.615);\n    \n    float modTime=mod(iTime,patternLength*numPatterns);    \n    if (modTime<patternLength)\n    {\n    \troamingSphere=sdSphere(r-vec3(0.0,-10.6,1.5+abs(5.0*sin(sphTime))),0.4);\n    }\n    else\n    {\n    \troamingSphere=sdSphere(r-vec3(0.0,-.6,1.5+abs(5.0*sin(sphTime))),0.4);\n    }\n    \n    vec3 rr=rotz(r,3.141592/2.0);\n    float roamingSphere2=sdTorus(rr-vec3(-.5,0.0,-1.5-abs(5.0*cos(sphTime))),vec2(0.35,0.2));\n\n    float mirror=sdBox(r-vec3(0.0,0.0,5.0),vec3(.8,1.1,.1));\n\n    \n    float t=min(min(min(min(min(min(min(min(t0,plane0),plane1),spheres),pyr0),pyr1),roamingSphere),mirror),roamingSphere2);\n    if (t==plane0) mat=1.0;\n    if (t==plane1) mat=1.0;\n    if (t==spheres) mat=2.0;\n    if (t==pyr0) mat=3.0;\n    if (t==pyr1) mat=4.0;\n\tif (t==roamingSphere) mat=6.0;                                 \n\tif (t==roamingSphere2) mat=7.0;                                 \n    if (t==mirror) mat=5.0;\n\n    if (modTime>=patternLength*3.0)        \n    {\n        float centeredBlob=fBlob(rOrig-vec3(5.0,0.0,1.0+iTime));\n        if (centeredBlob<t)\n        {\n            return vec2(centeredBlob,8.0);\n        }\n    }\n    \n    return vec2(t,mat);   \n}\n\nvec3 calcNormal(vec3 pos)\n{\n    float c = SDF(pos)[0];\n    vec2 eps_zero = vec2(0.01, 0.0);\n    return normalize(vec3( SDF(pos + eps_zero.xyy)[0], SDF(pos + eps_zero.yxy)[0], SDF(pos + eps_zero.yyx)[0] ) - c);\n}\n\nvec2 castRay(vec3 rayOrigin, vec3 rayDir)\n{\n    float t = 0.0;\n     \n    for (int i = 0; i < iterationAmount; i++)\n    {\n        vec2 res = SDF(rayOrigin + rayDir * t);\n        if (res[0] < (0.0001*t))\n        {\n            return vec2(t,res[1]);\n        }\n        t += res[0];\n    }\n     \n    return vec2(-1.0,-1.0);\n}\n\nvec3 bounceRender(vec3 rayOrigin, vec3 rayDir, vec2 uv)\n{\n    vec3 col;\n    vec3 L=normalize(vec3(1.0,0.2,-2.0));\n\n    vec2 rayHit = castRay(rayOrigin, rayDir);\n    float t=rayHit[0];\n    \n    if (t!=-1.0)\n    {\n    \tvec3 pHit=rayOrigin + rayDir * t;\n        vec3 N=calcNormal(pHit);\n        float NoL = max(dot(N, L), 0.0);\n        float mat=rayHit[1];\n        if (mat==0.0)\n        {\n            col=vec3(NoL);\n        }\n        else if (mat==1.0) // plane\n        {\n            float lDist=distance(pHit,L+rayOrigin);\n        \tvec2 a = vec2(1.)*smoothstep(-0.05, 0.05, mod(pHit.x, 1.))*smoothstep(-0.05, 0.05, mod(pHit.z, 1.));\n        \tcol = vec3(1.0-a.x,1.0-a.y,1.0-a.x);\n            \n            //col+=vec3(pow(clamp(1.0-lDist/6.0,0.0,1.0),1.0));\n        }\n        \n        else if (mat==2.0) // spheres\n        {\n            NoL+=pow(NoL,32.0);\n            col+=vec3(.2,.3,.5)*vec3(NoL);\n        }\n        else if (mat==3.0)\n        {\n            NoL+=pow(NoL,32.0);\n            col+=vec3(1.0,0.0,0.0)*vec3(NoL);\n        }\n        else if (mat==4.0)\n        {\n            NoL+=pow(NoL,32.0);\n            col+=vec3(1.0,1.0,0.0)*vec3(NoL);\n        }\n\n        col/=distance(pHit-rayOrigin,vec3(0.))*.3;\n    }\n\n    col=pow(col,vec3(0.58));\n    return col;\n}\n\nvec4 render(vec3 rayOrigin, vec3 rayDir, vec2 uv)\n{\n    vec3 col=vec3(0.);\n    vec3 L=normalize(vec3(1.0,0.2,-2.0));\n\n    vec2 rayHit = castRay(rayOrigin, rayDir);\n    float t=rayHit[0];\n\n    if (t!=-1.0)\n    {\n    \tvec3 pHit=rayOrigin + rayDir * t;\n        float mat=rayHit[1];\n        vec3 N=calcNormal(rayOrigin + rayDir * t);\n        float NoL = max(dot(N, L), 0.0);\n      \n        if (mat==0.0)\n        {\n            col=vec3(NoL);\n        }\n        else if (mat==1.0) // plane\n        {\n            float lDist=distance(pHit,L+rayOrigin);\n        \tvec2 a = vec2(1.)*smoothstep(-0.05, 0.05, mod(pHit.x, 1.))*smoothstep(-0.05, 0.05, mod(pHit.z, 1.));\n        \tcol = vec3(1.0-a.x,1.0-a.y,1.0-a.x);\n            \n            col+=vec3(pow(clamp(1.0-lDist/6.0,0.0,1.0),2.2));\n        }\n        else if ((mat==2.0)||(mat==6.0)||(mat==7.0)) // meatballs/roaming spheres\n        {\n            float modTime=mod(iTime,30.0);    \n    \t\tif ((modTime<10.0)&&(mat==6.0))\n            {\n                return vec4(0.,0.,0.,0.);\n            }\n            \n            NoL=pow(NoL,32.0);\n            NoL=clamp(NoL,0.0,1.0);\n            vec3 colReflect=bounceRender(pHit,N,uv);\n            if (mat==2.0) col=vec3(1.0,1.0,1.0)*vec3(NoL);\n            else if (mat==7.0) col=vec3(1.,1.,1.)*vec3(NoL);\n            else col=vec3(.2,.2,.85)*vec3(NoL);\n            //col=vec3(0.5,0.5,0.5)*vec3(NoL);\n            col=mix(col,colReflect,0.2);\n        }\n        else if (mat==3.0) // pyr1\n        {\n            NoL+=pow(NoL,32.0);\n            col+=vec3(1.0,0.0,0.0)*vec3(NoL);\n        }\n        else if (mat==4.0) // pyr2\n        {\n            NoL+=pow(NoL,32.0);\n            col+=vec3(1.0,1.0,0.0)*vec3(NoL);\n        }\n        else if (mat==5.0) // magic mirror\n        {\n            vec3 N=vec3(0.0,0.0,-1.0);\n            vec3 colReflect=bounceRender(pHit,N,uv);\n            col=colReflect*0.5;\n        }\n        else if (mat==8.0) // mysterious blob\n        {\n            vec3 centerVec=vec3(5.0,0.0,1.0+iTime);\n            vec3 edgeVec=pHit-centerVec;\n            \n            edgeVec=normalize(edgeVec);\n            float edge=1.0-dot(edgeVec,vec3(0.,0.,-1.0));\n            edge=pow(edge,3.0);\n            \n            vec3 color1 = vec3(0.0,0.0,0.0);\n            vec3 color2 = vec3(0.726,0.726,0.726);\n            col = mix(color1,color2,edge);\n           \tcol+=edge*pow(distance(pHit,centerVec)*.4,2.0)*vec3(0.38,0.38,0.64);\n            //col=mix(col,color3,min(0.,edge-0.6)*2.0);\n        }\n\n    \tfloat modTime=mod(iTime,patternLength*numPatterns);    \n        if (modTime>=patternLength*3.0)        \n        {\n            if (mat!=8.0)\n            {\n                vec3 nrd=normalize(rayDir);\n                float fft = texture( iChannel0, vec2(0.0,0.0) ).x;\n                float myTime=iTime/8.0;\n                vec2 b=abs(fract(vec2(1.)*nrd.z+myTime)-.5)*abs(fract(vec2(1.)*nrd.z+myTime)-.5);\n                col+=vec3(\n                    (.01*pow(b.x+.8,20.)+b.y/dot(nrd.xy,nrd.xy)*exp(.24-1./4.))*fft,\n                    (.01*pow(b.x+.2,20.)+b.y/dot(nrd.xy,nrd.xy)*exp(.1-1./4.))*fft,\n                    (.01*pow(b.x+.1,20.)+b.y/dot(nrd.xy,nrd.xy)*exp(.32-1./2.))*fft)/3.0;\n            }\n        }\n        \n        col/=distance(pHit-rayOrigin,vec3(0.))*.6;\n    }\n\n    col=pow(col,vec3(0.58));\n    return vec4(col,1.0);\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 upz=vec3(0.,1.,0.);\n    vec3 camRight = normalize(cross(upz, camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n     \n    float fPersp = 2.0;\n    vec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n \n    return vDir;\n}\n\nvec2 normalizeScreenCoords(vec2 screenCoord)\n{\n    vec2 result = 2.0 * (screenCoord/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    return result;\n}\n\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float myTime=iTime/8.0;\n\tvec2 uv = normalizeScreenCoords(fragCoord);\n\n    vec3 camPos,camTarget;\n\n    float modTime=mod(iTime,patternLength*numPatterns);\n    \n    if (modTime<patternLength) // magic mirror\n    {\n        modTime/=8.0;\n        camPos = vec3(0.0,0.,-3.0+7.5-modTime);\n        camTarget = vec3(.0, 0.,0.0+7.5-modTime);\n    }\n    else if ((modTime>=patternLength)&&(modTime<(patternLength*2.0))) // roaming camera\n    {\n        if (iTime>(patternLength*4.0))\n        {\n            camPos = vec3(cos(myTime)*4.0,0.,-3.0+iTime);\n            camTarget = vec3(.0, 0.,0.0+iTime);\n        }\n        else\n        {\n            camPos = vec3(sin(myTime)*4.0,0.,-3.0+iTime);\n            camTarget = vec3(.0, 0.,0.0+iTime);\n        }\n    }\n    else if ((modTime>=patternLength*2.0)&&(modTime<(patternLength*3.0))) // fisheye\n    {\n    \tuv*=(asin(length(uv)*0.75));\n        camPos = vec3(sin(myTime)*5.0,0.6*cos(myTime),-3.0+iTime);\n        camTarget = vec3(.0, 0.,0.0+iTime);\n    }\n    else // glowsphere\n    {\n        camPos = vec3(5.0,0.0,-3.0+iTime);\n        camTarget = vec3(5.0, 0.,0.0+iTime);\n    }\n\n    \n    \n    \n    vec3 rayDir = getCameraRayDir(uv, camPos, camTarget);   \n\n    float fft = texture( iChannel0, vec2(0.0,0.0) ).x;\n    \n    vec4 finalCol = vec4(render(camPos, rayDir,uv).xyz*(1.2+fft*2.0),1.0);\n\n    vec4 distCol=finalCol;\n    float pixx=mod(abs(uv.x*64.0),1.0);\n    if (pixx<0.33) distCol.x/=2.0;\n    if ((pixx>=0.33)&&(pixx<0.66)) distCol.y/=2.0;\n    if (pixx>0.66) distCol.z/=2.0;\n\n    if ((modTime>=patternLength*2.0)&&(modTime<(patternLength*3.0)))\n    {\n        float mult=4.0;\n        distCol+=sin(uv.x*mult)*cos(uv.y*mult);\n    }\n    \n   \tfinalCol=mix(distCol,finalCol,0.5);\n    \n    if (iTime>(patternLength*4.0))\n    {\n        vec3 value = finalCol.rgb;\n        vec3 oldcolor = value + (value * texture(iChannel1, (mod(fragCoord, 8.0) / 8.0)).rrr);\n        finalCol = vec4(floor(oldcolor),1.0);    \n    }\n  \n    fragColor=finalCol;\n}\n", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22341, "src": "https://soundcloud.com/kvmusicprod/bloc", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsBR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[393, 393, 436, 436, 458], [460, 460, 492, 492, 603], [605, 605, 636, 636, 747], [749, 749, 780, 780, 891], [893, 893, 945, 945, 1044], [1046, 1046, 1079, 1079, 1107], [1109, 1109, 1154, 1154, 1245], [1247, 1247, 1280, 1280, 1311], [1313, 1313, 1344, 1344, 1431], [1433, 1433, 1468, 1468, 1953], [1955, 1955, 1993, 1993, 2273], [2275, 2275, 2308, 2308, 2373], [2375, 2375, 2397, 2397, 2975], [2977, 2977, 2995, 2995, 5619], [5621, 5621, 5648, 5648, 5832], [5834, 5834, 5877, 5877, 6153], [6155, 6155, 6212, 6212, 7416], [7418, 7418, 7469, 7469, 10736], [10738, 10738, 10798, 10798, 11124], [11126, 11126, 11172, 11172, 11298], [11304, 11304, 11361, 11361, 13334]], "test": "untested"}
{"id": "3dfBDr", "name": "Hilbert-curve particle sort", "author": "michael0884", "description": "Using the multi XOR sort to sort particles on a h-order curve. Works a bit better than on a zcurve", "tags": ["xor", "sort", "sorting", "parallel"], "likes": 6, "viewed": 521, "published": 3, "date": "1587997775", "time_retrieved": "2024-07-30T21:10:14.274368", "image_code": "// Fork of \"Z-curve particle sort\" by michael0884. https://shadertoy.com/view/wtyXDc\n// 2020-04-27 14:27:22\n\n// Fork of \"Bitonic sorting network\" by michael0884. https://shadertoy.com/view/ttVXDV\n// 2020-03-08 15:43:17\n\n//get particle id from id array\nvec2 getID(float id, float LI)\n{\n    id = clamp(id, 0., N*N-1.);\n    float y = floor(id/N);\n    float x = id - N*y;\n    return texel(ch1, vec2(x+LI*N,y)).xy;\n}\n\n\n//random binary array id search\nvec2 search(int zid, float LI)\n{\n    float L = 0., R = N*N-1.;\n    vec4 p;\n    float i = 0.;\n    while(L!=R && i < log2(N))\n    {\n        i++;\n    \tfloat lid = floor((L+R)/2.);\n        float zid0 = getID(lid, LI).y; \n        float k = 0.5;\n        if(float(zid) < zid0)\n        {\n            R = (1.-k)*lid+R*k;\n        }\n        else\n        {\n            L = (1.-k)*lid+L*k;\n        }\n    }\n    return vec2(L,R);\n}\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\n#define R 8.\n\nvoid mainImage( out vec4 fragColor, in vec2 p )\n{\n    vec2 pn = floor(1.*p);\n    p = floor(vec2(1.,1.)*p);\n    if(pn.x < LN*N && pn.y < N)\n    {\n    \tvec2 a = texel(ch1, pn).xy;\n        fragColor.xyz = jet_range(a.y, 0., 5e3);\n    }\n    else\n    {\n        int zid = xy2z(p);\n        //render points using last LN particle sorts\n        for(float li = 0.; li < LN; li++)\n        {\n            vec2 lid = search(zid, li);\n            fragColor.xyz = vec3(0);\n            for(float i = lid.x;i <= lid.y; i++)\n            {\n                vec4 a0 = getParticle(getID(i, li).x);\n                fragColor.xyz += vec3(gauss(length(p - a0.xy), 2.));\n            }\n        }\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//particle buffer\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    if(pos.x < N && pos.y < N)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch0, pos);\n        \n        vec2 F = vec2(0.);\n        if(iMouse.z > 0.) \n        {\n            float d = distance(iMouse.xy, U.xy);\n            F = normalize(iMouse.xy - U.xy)/(d+2.);\n        }\n        \n        U.zw += dt*F;\n        U.xy += U.zw*dt;\n        \n \n        //this pixel value\n        if(iFrame<1)\n        {\n            U.xy = size*hash22(pos);\n\t\t\tU.zw = hash22(3.14159*pos) - 0.5;\n        }\n    }\n    else discard;\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//definitions\n#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n//N^2 is the point number\n#define N 65.\n#define dt 0.5\n\n//save N last iterations\n#define LN 1.\n\n//hash functions\n//https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p) - 0.5;\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\n\nuniform sampler2D fake;\n\nvec4 getParticle(float id)\n{\n    float y = floor(id/N);\n    float x = id - N*y;\n    return texel(fake, vec2(x,y));\n}\n   \n//from https://www.shadertoy.com/view/tdlBz7\n\nint HOrder( vec2 p )\n{   \n    uvec2 Position = uvec2(p *1024.);\n    uvec2 Regions;\n    uint Index = 0U;\n    for( uint CurLevel = 1024U/2U; CurLevel > 0U; CurLevel /= 2U )\n    {\n        uvec2 Region = uvec2(greaterThan((Position & uvec2(CurLevel)), uvec2(0U)));\n        Index += CurLevel * CurLevel * ( (3U * Region.x) ^ Region.y);\n        if( Region.y == 0U )\n        {\n            if( Region.x == 1U )\n            {\n                Position = uvec2(1024U - 1U) - Position;\n            }\n            Position.xy = Position.yx;\n        }\n    }\n    \n    return int(Index);\n}\n\n//2d h-curve index\nint xy2z(vec2 U) {       // --- grid location to curve index\n    return HOrder(U/10000.);\n}\n", "buffer_b_code": "//sorting network\n\n//get particle id from id array\nfloat getID(float id)\n{\n    id = clamp(id, 0., N*N-1.);\n    float y = floor(id/N);\n    float x = id - N*y;\n    return texel(ch1, vec2(x,y)).x;\n}\n\nvec2 sort(float id, float pid)\n{\n    \n    float p0_id = getID(id);\n    float p1_id = getID(pid);\n\n    vec4 val0 = getParticle(p0_id);\n    vec4 val1 = getParticle(p1_id);\n    \n    //z-curve indecies\n    int zcurve0 = xy2z(val0.xy);\n    int zcurve1 = xy2z(val1.xy);\n\n    vec2 cmin = (zcurve0<zcurve1) ? vec2(p0_id, zcurve0): vec2(p1_id, zcurve1);\n    vec2 cmax = (zcurve0<zcurve1) ? vec2(p1_id, zcurve1): vec2(p0_id, zcurve0);\n\t\n    return (zcurve0==zcurve1)?vec2(p0_id, zcurve0):((pid > id) ? cmin : cmax); //swap sorted\n}\n\n//flip n bits\nfloat XORN(float x, float n)\n{\n    int X = int(x);\n    int pow2m1 = (1<<int(n+1.)) - 1;\n    return float(X^(pow2m1));\n}\n\nint imod(int x, int y)\n{\n    return x - y * int(floor(float(x)/float(y)));\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{  \n    if(pos.x < N && pos.y < N)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch1, pos);\n        \n        float id = pos.x + pos.y*N;  \n        \n        int maxorder = int(ceil(log2(N*N)));\n\n        int frame = iFrame;\n        float order = float(imod(frame, maxorder));\n        float oe = float(imod(frame, 2));\n\n        //pair id\n        float pid = XORN(id+oe, order)-oe; \n\n        if(pid < N*N) //if inside the array\n        {\n            U.xy = sort(id, pid); //swap sorted\n        }\n\t\t\n        if(iFrame < 1)\n        {\n            U.x = id;\n        }\n    }\n    else discard;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//sorting network\n\n//get particle id from id array\nfloat getID(float id)\n{\n    id = clamp(id, 0., N*N-1.);\n    float y = floor(id/N);\n    float x = id - N*y;\n    return texel(ch1, vec2(x,y)).x;\n}\n\nvec2 sort(float id, float pid)\n{\n    \n    float p0_id = getID(id);\n    float p1_id = getID(pid);\n\n    vec4 val0 = getParticle(p0_id);\n    vec4 val1 = getParticle(p1_id);\n    \n    //z-curve indecies\n    int zcurve0 = xy2z(val0.xy);\n    int zcurve1 = xy2z(val1.xy);\n\n    vec2 cmin = (zcurve0<zcurve1) ? vec2(p0_id, zcurve0): vec2(p1_id, zcurve1);\n    vec2 cmax = (zcurve0<zcurve1) ? vec2(p1_id, zcurve1): vec2(p0_id, zcurve0);\n\t\n    return (zcurve0==zcurve1)?vec2(p0_id, zcurve0):((pid > id) ? cmin : cmax); //swap sorted\n}\n\n//flip n bits\nfloat XORN(float x, float n)\n{\n    int X = int(x);\n    int pow2m1 = (1<<int(n+1.)) - 1;\n    return float(X^(pow2m1));\n}\n\nint imod(int x, int y)\n{\n    return x - y * int(floor(float(x)/float(y)));\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{  \n    if(pos.x < N && pos.y < N)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch1, pos);\n        \n        float id = pos.x + pos.y*N;  \n        \n        int maxorder = int(ceil(log2(N*N)));\n\n        int frame = -2*iFrame;\n        float order = float(imod(frame, maxorder));\n        float oe = float(imod(frame, 2));\n\n        //pair id\n        float pid = XORN(id+oe, order)-oe;\n\n        if(pid < N*N) //if inside the array\n        {\n            U.xy = sort(id, pid); //swap sorted\n        }\n\t\t\n        if(iFrame < 1)\n        {\n            U.x = id;\n        }\n    }\n    else discard;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//sorting network\n\n//get particle id from id array\nfloat getID(float id)\n{\n    id = clamp(id, 0., N*N-1.);\n    float y = floor(id/N);\n    float x = id - N*y;\n    return texel(ch1, vec2(x,y)).x;\n}\n\nvec2 sort(float id, float pid)\n{\n    \n    float p0_id = getID(id);\n    float p1_id = getID(pid);\n\n    vec4 val0 = getParticle(p0_id);\n    vec4 val1 = getParticle(p1_id);\n    \n    //z-curve indecies\n    int zcurve0 = xy2z(val0.xy);\n    int zcurve1 = xy2z(val1.xy);\n\n    vec2 cmin = (zcurve0<zcurve1) ? vec2(p0_id, zcurve0): vec2(p1_id, zcurve1);\n    vec2 cmax = (zcurve0<zcurve1) ? vec2(p1_id, zcurve1): vec2(p0_id, zcurve0);\n\t\n    return (zcurve0==zcurve1)?vec2(p0_id, zcurve0):((pid > id) ? cmin : cmax); //swap sorted\n}\n\n//flip n bits\nfloat XORN(float x, float n)\n{\n    int X = int(x);\n    int pow2m1 = (1<<int(n+1.)) - 1;\n    return float(X^(pow2m1));\n}\n\nint imod(int x, int y)\n{\n    return x - y * int(floor(float(x)/float(y)));\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{  \n    if(pos.x < LN*N && pos.y < N)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch2, pos);\n        if(pos.x < N)\n        {\n            float id = pos.x + pos.y*N;  \n\n            int maxorder = int(ceil(log2(N*N)));\n\n            int frame = -2*iFrame-1;\n            float order = float(imod(frame, maxorder));\n            float oe = float(imod(frame, 2));\n\n            //pair id\n            float pid = XORN(id+oe, order)-oe;\n\n            if(pid < N*N) //if inside the array\n            {\n                U.xy = sort(id, pid); //swap sorted\n            }\n\n            if(iFrame < 1)\n            {\n                U.x = id;\n            }\n        }\n        else\n        {\n            if(imod(iFrame, 2) == 0)\n            {\n            \tfloat LI = pos.x/N;\n            \tU = texel(ch2, pos - vec2(N,0.)); //store last in next\n            }\n        }\n       \n    }\n    else discard;\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfBDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[220, 252, 284, 284, 411], [414, 446, 478, 478, 862], [864, 864, 895, 895, 929], [945, 945, 994, 994, 1620]], "test": "untested"}
{"id": "3sXBDr", "name": "Floppy Clock With Dice", "author": "dr2", "description": "  More physics-based dynamics (use mouse to halt/change box rotation; \n  click upper-right to restart).\n", "tags": ["collision", "dynamics", "physics"], "likes": 11, "viewed": 409, "published": 3, "date": "1587997721", "time_retrieved": "2024-07-30T21:10:15.419307", "image_code": "// \"Floppy Clock With Dice\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  More physics-based dynamics (use mouse to halt/change box rotation; \n  click upper-right to restart).\n  (With bits from \"Stonewashed Flag\", \"Dice Leaping\", \"Tempus Fugit\", etc.)\n*/\n\n#define AA  1  // optional antialiasing\n\nfloat PrBoxDf (vec3 p, vec3 b);\nmat3 QtToRMat (vec4 q);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec3 GetR (vec2 v);\nvec3 GetRC (vec2 v);\nvec3 GetRB (int n);\nvec4 GetQB (int n);\nvec4 Loadv4 (vec2 vId);\n\nconst int nBallE = 33, nBlk = 8;\n\nvec3 ltDir, vnBall, rdSign, vnBox, vnBlk, fcBlk;\nvec2 qgHit, qBlk;\nfloat dstFar, boxSize, boxSizeS, blkSize, bGrid, todCur;\nint idObj, idBlk;\nconst float pi = 3.14159;\n\nfloat BlkHit (vec3 ro, vec3 rd)\n{\n  mat3 m;\n  vec3 rm, rdm, v, tm, tp, u;\n  float dMin, dn, df;\n  dMin = dstFar;\n  for (int n = 0; n < nBlk; n ++) {\n    rm = GetRB (n);\n    m = QtToRMat (GetQB (n));\n    rdm = rd * m;\n    v = ((ro - rm) * m) / rdm;\n    tp = blkSize / abs (rdm) - v;\n    tm = - tp - 2. * v;\n    dn = Maxv3 (tm);\n    df = Minv3 (tp);\n    if (df > 0. && dn < min (df, dMin)) {\n      dMin = dn;\n      fcBlk = - sign (rdm) * step (tm.zxy, tm) * step (tm.yzx, tm);\n      idBlk = n;\n      u = (v + dn) * rdm;\n    }\n  }\n  if (dMin < dstFar) {\n    qBlk = vec2 (dot (u.zxy, fcBlk), dot (u.yzx, fcBlk));\n    vnBlk = QtToRMat (GetQB (idBlk)) * fcBlk;\n  }\n  return dMin;\n}\n\nfloat BlkHitSh (vec3 ro, vec3 rd, float rng)\n{\n  mat3 m;\n  vec3 rm, rdm, v, tm, tp;\n  float dMin, dn, df;\n  dMin = dstFar;\n  for (int n = 0; n < nBlk; n ++) {\n    rm = GetRB (n);\n    m = QtToRMat (GetQB (n));\n    rdm = rd * m;\n    v = ((ro - rm) * m) / rdm;\n    tp = blkSize / abs (rdm) - v;\n    tm = - tp - 2. * v;\n    dn = Maxv3 (tm);\n    df = Minv3 (tp);\n    if (df > 0. && dn < min (df, dMin)) dMin = dn;\n  }\n  return smoothstep (0.3 * rng, rng, dMin);\n}\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec4 sLen, rsLen;\n  vec3 eWid;\n  float dMin, d;\n  dMin = dstFar;\n  sLen = vec4 (vec3 (boxSizeS), 0.);\n  rsLen = vec4 (sLen.xyz * rdSign, 0.);\n  eWid = vec3 (0.1);\n  d = min (min (\n     PrBoxDf (p - rsLen.xww, eWid + sLen.wyz),\n     PrBoxDf (p - rsLen.wyw, eWid + sLen.xwz)),\n     PrBoxDf (p - rsLen.wwz, eWid + sLen.xyw));\n  DMIN (1);\n  p = abs (p);\n  d = min (min (\n     PrBoxDf (p - sLen.wyz, eWid + sLen.xww),\n     PrBoxDf (p - sLen.xwz, eWid + sLen.wyw)),\n     PrBoxDf (p - sLen.xyw, eWid + sLen.wwz));\n  DMIN (2);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 50; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat SheetHit (vec3 ro, vec3 rd)\n{\n  vec3 r, q;\n  vec2 g;\n  float d, dMin, sz, szMax, szMin;\n  bvec2 ilt;\n  bool bkTrak;\n  const int nsMax = 3000;\n  dMin = dstFar;\n  szMax = bGrid;\n  szMin = 1./16.;\n  g = vec2 (0.);\n  bkTrak = false;\n  sz = szMax;\n  for (int ns = 0; ns < nsMax; ns ++) {\n    if (sz == szMin) {\n      r = GetR (g) - ro;\n      q = cross (r, rd);\n      if (dot (q, q) < sz * sz) {\n        d = dot (r, rd);\n        if (d < dMin) {\n          dMin = d;\n          qgHit = g;\n        }\n      }\n      bkTrak = true;\n    }\n    q = cross (GetR (g + 0.5 * sz) - ro, rd);\n    bkTrak = bkTrak || (dot (q, q) > sz * sz);\n    if (bkTrak) {\n      bkTrak = false;\n      ilt = lessThan (fract (g / (2. * sz)), vec2 (0.5));\n      g.x += ilt.x ? sz : - sz;\n      if (! ilt.x) {\n        g.y += ilt.y ? sz : - sz;\n        if (! ilt.y) {\n          sz *= 2.;\n          if (sz == szMax) break;\n          bkTrak = true;\n        }\n      }\n    } else if (sz > szMin) sz *= 0.5;\n  }\n  return dMin;\n}\n\nvec3 SheetNf () \n{\n  vec2 e;\n  e = vec2 (1., 0.);\n  return normalize (cross (GetRC (qgHit + e.yx) - GetRC (qgHit - e.yx),\n     GetRC (qgHit + e.xy) - GetRC (qgHit - e.xy)));\n}\n\nvec3 SheetCol (float s)\n{\n  vec3 col;\n  vec2 b, g, c;\n  float rad, a, f, gRot;\n  col = vec3 (0.9, 0.9, 1.);\n  c = vec2 (1., 0.4);\n  rad = 0.5 * float (nBallE - 1);\n  b = (qgHit / rad - 1.);\n  b = Rot2D (b, pi);\n  if (s > 0.) b.y *= -1.;\n  a = atan (b.y, - b.x) / pi;\n  if (abs (mod (6. * (a + 1.) + 0.5, 1.) - 0.5) < 0.03 &&\n     abs (length (b) - 0.95) < 0.05 || abs (6. * a) < 0.03 &&\n     abs (length (b) - 0.9) < 0.1) col = c.yyx;\n  col = mix (c.yyx, col, \n     0.8 + 0.2 * SmoothBump (0.15, 0.85, 0.02, mod (rad * length (b), 1.)));\n  col = mix (col, c.yyx, smoothstep (0.96, 0.97, length (b)));\n  gRot = todCur * 2. * pi / (12. * 3600.);\n  g = Rot2D (b, gRot - pi);\n  g.x -= 0.25;\n  f = length (max (abs (g) - vec2 (0.3, 0.027 * (0.6 - 0.4 * g.x / 0.3)), 0.));\n  col = mix (col, c.xxy * (1. - 0.4 * step (0.01, f)), step (f, 0.02));\n  gRot *= 12.;\n  g = Rot2D (b, gRot - pi);\n  g.x -= 0.35;\n  f = length (max (abs (g) - vec2 (0.4, 0.013 * (0.6 - 0.4 * g.x / 0.4)), 0.));\n  col = mix (col, c.yxy * (1. - 0.4 * step (0.01, f)), step (f, 0.02));\n  gRot *= 60.;\n  g = Rot2D (b, gRot - pi);\n  g.x -= 0.4;\n  f = length (max (abs (g) - vec2 (0.46, 0.007 * (0.6 - 0.4 * g.x / 0.46)), 0.));\n  col = mix (col, c.xyy * (1. - 0.4 * step (0.01, f)), step (f, 0.02));\n  col = mix (vec3 (0.1, 0.1, 0.2), col, smoothstep (0.007, 0.013, length (b)));\n  return col;\n}\n\nfloat BoxHit (vec3 ro, vec3 rd, vec3 sz)\n{\n  vec3 v, tm, tp;\n  float dMin, dn, df;\n  dMin = dstFar;\n  v = ro / rd;\n  tp = sz / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    vnBox = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  }\n  return dMin;\n}\n\nfloat BoxHitSh (vec3 ro, vec3 rd, vec3 sz, float rng)\n{\n  vec3 v, tm, tp;\n  float dn, df;\n  v = ro / rd;\n  tp = sz / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  return smoothstep (0.3 * rng, rng, (df > 0. && dn < df) ? dn : dstFar);\n}\n\nfloat BoxHitSil (vec3 ro, vec3 rd, vec3 sz)\n{\n  vec3 v, tm, tp;\n  float dn, df;\n  v = ro / rd;\n  tp = sz / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  return (df > 0. && dn < df) ? dn : dstFar;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, w;\n  float dstBlk, dstBox, dstSheet, s, sh, nDotL;\n  bool isWall, isBlk;\n  isWall = false;\n  isBlk = false;\n  dstBlk = BlkHit (ro, rd);\n  dstSheet = SheetHit (ro, rd);\n  rdSign = sign (rd);\n  dstBox = ObjRay (ro, rd);\n  if (min (min (dstBlk, dstBox), dstSheet) < dstFar) {\n    if (dstSheet < min (dstBlk, dstBox)) {\n      ro += dstSheet * rd;\n      vn = SheetNf ();\n      s = sign (dot (rd, vn));\n      if (s > 0.) vn = - vn;\n      col4 = vec4 (SheetCol (s), 0.1);\n    } else if (dstBlk < dstBox) {\n      ro += dstBlk * rd;\n      vn = vnBlk;\n      col4 = (idBlk < nBlk / 2) ? vec4 (1., 0.7, 0.3, 0.2) : vec4 (0.7, 1., 0.3, 0.2);\n      s = -1.;\n      if (fcBlk.x == -1. || fcBlk.y == 1.) qBlk = Rot2D (qBlk, 0.25 * pi);\n      if (abs (fcBlk.x) == 1.) s = (fcBlk.x > 0.) ? length (qBlk) :\n         length (abs (qBlk) - vec2 (0.35 * blkSize, 0.));\n      else if (abs (fcBlk.y) == 1.) s = (fcBlk.y > 0.) ?\n         length (vec2 (mod (qBlk.x + 0.4 * blkSize, 0.8 * blkSize) - 0.4 * blkSize, qBlk.y)) :\n         length (abs (qBlk) - 0.4 * blkSize);\n      else if (abs (fcBlk.z) == 1.) s = (fcBlk.z > 0.) ?\n         min (length (abs (qBlk) - 0.4 * blkSize), length (qBlk)) :\n         length (vec2 (mod (qBlk.x + 0.3 * blkSize, 0.6 * blkSize) - 0.3 * blkSize,\n         abs (qBlk.y) - 0.4 * blkSize));\n      s -= 0.2 * blkSize;\n      if (s < 0.) col4 = vec4 (vec3 (1.2) * (1. - 0.7 * smoothstep (-0.1, 0., s)), 0.5);\n      isBlk = true;\n    } else if (dstBox < dstFar) {\n      ro += dstBox * rd;\n      vn = ObjNf (ro);\n      if (idObj == 1) {\n        w = smoothstep (0., 0.1, abs (fract (5. * ro / boxSize + 0.5) - 0.5));\n        col4 = vec4 (vec3 (mix (vec3 (0.6, 0.55, 0.55), vec3 (0.5, 0.5, 0.55), \n           dot (abs (vn) * w.yzx * w.zxy, vec3 (1.)))), 0.1);\n      } else if (idObj == 2) col4 = vec4 (vec3 (0.6), 0.1);\n      isWall = true;\n    }\n    sh = (isWall || isBlk && (idBlk < nBlk / 2 && ltDir.z > 0. || \n       idBlk >= nBlk / 2 && ltDir.z < 0.)) ?\n       BoxHitSh (ro + 0.01 * ltDir, ltDir, vec3 (boxSizeS, boxSizeS, 0.1), 3. * boxSize) : 1.;\n    sh = 0.6 + 0.4 * min (sh, BlkHitSh (ro + 0.01 * ltDir, ltDir, boxSize));\n    nDotL = max (dot (vn, ltDir), 0.);\n    if (! isWall) nDotL *= nDotL;\n    col = col4.rgb * (0.2 + 0.2 * max (- dot (vn, ltDir), 0.) + 0.8 * sh * nDotL) +\n       col4.a * step (0.95, sh) * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n    if (BoxHit (ro, rd, vec3 (boxSizeS)) < dstFar) col = mix (col,\n       vec3 (0.7, 0.7, 0.75) * (0.2 + 0.8 * max (dot (vnBox, ltDir), 0.)) +\n       0.1 * pow (max (0., dot (ltDir, reflect (rd, vnBox))), 64.),\n       pow (1. - abs (dot (rd, vnBox)), 4.));\n  } else col = vec3 (0.05);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 qtVu, stDat, mPtr;\n  vec3 col, rd, ro;\n  vec2 canvas, uv;\n  float vuEl, zmFac, asp, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  todCur = iDate.w;\n  bGrid = float (nBallE - 1);\n  stDat = Loadv4 (vec2 (4 * nBlk + 0, nBallE));\n  boxSize = stDat.y;\n  boxSizeS = boxSize - 1.;\n  dstFar = 11. * boxSize;\n  blkSize = 1.3;\n  qtVu = Loadv4 (vec2 (4 * nBlk + 1, nBallE));\n  vuMat = QtToRMat (qtVu);\n  vuEl = 0.1 * pi;\n  ro = vec3 (0., 0., -6. * boxSize);\n  ro.yz = Rot2D (ro.yz, vuEl);\n  ro = ro * vuMat;\n  ltDir = normalize (vec3 (-1., 1., -1.)) * vuMat;\n  zmFac = 4.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  col = vec3 (0.);\n  for (float a = 0.; a < naa; a ++) {\n    rd = normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    rd.yz = Rot2D (rd.yz, vuEl);\n    rd = rd * vuMat;\n    if (BoxHitSil (ro, rd, vec3 (boxSizeS)) < dstFar) col += (1. / naa) * ShowScene (ro, rd);\n  }\n  if (length (col) == 0.) col = vec3 (0.1, 0.1, 0.) * (1. - 0.8 * smoothstep (1.1, 1.3, length (uv)));\n  mPtr = Loadv4 (vec2 (4 * nBlk + 2, nBallE));\n  asp = canvas.x / canvas.y;\n  if (mPtr.z > 0. && min (uv.x - asp, uv.y - 1.) > -0.1) col = mix (col, vec3 (1., 1., 0.), 0.3);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nvec3 GetRC (vec2 v)\n{\n  return GetR (clamp (v, 0., bGrid - 1.));\n}\n\nvec3 GetRB (int n)\n{\n  return Loadv4 (vec2 (4 * n + 0, nBallE)).xyz;\n}\n\nvec4 GetQB (int n)\n{\n  return Loadv4 (vec2 (4 * n + 2, nBallE));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Floppy Clock With Dice\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 RMatToQt (mat3 m);\nmat3 QtToRMat (vec4 q);\nvec4 EulToQt (vec3 e);\nvec3 QtToEul (vec4 q);\nmat3 LpStepMat (vec3 a);\nfloat Hashff (float p);\nvec3 GetR (vec2 v);\nvec3 GetV (vec2 v);\nvec3 GetRB (int n);\nvec3 GetVB (int n);\nvec4 GetQB (int n);\nvec3 GetWB (int n);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nBallE = 33, nBlk = 8;\nconst vec3 blkSph = vec3 (3.), blkGap = vec3 (0.9);\nconst int nSiteBlk = 27;\n\nvec3 gravVec;\nivec2 idNeb[4], idNebD[4];\nfloat boxSize, spLen, bMass, farSep, fOvlap, fricN, fricT, fricS, fvDamp;\nconst float pi = 3.14159;\n\nvoid IdNebs ()\n{\n  idNeb[0] = ivec2 (1, 0);\n  idNeb[1] = - idNeb[0];\n  idNeb[2] = ivec2 (0, 1);\n  idNeb[3] = - idNeb[2];\n  idNebD[0] = ivec2 (1, 1);\n  idNebD[1] = - idNebD[0];\n  idNebD[2] = ivec2 (1, -1);\n  idNebD[3] = - idNebD[2];\n}\n\n#define InLatt(t) (t >= 0 && t < nBallE)\n\nvoid ShSpringForce (ivec2 iv, vec3 r, vec3 v, inout vec3 a)\n{\n  vec3 dr;\n  ivec2 ivn;\n  float spLenD, fSpring, fDamp;\n  fSpring = 200.;\n  fDamp = 0.05;\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNeb[n];\n    if (InLatt (ivn.x) && InLatt (ivn.y)) {\n      dr = r - GetR (vec2 (ivn));\n      a += fSpring * (spLen / length (dr) - 1.) * dr - fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  spLenD = spLen * sqrt (2.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNebD[n];\n    if (InLatt (ivn.x) && InLatt (ivn.y)) {\n      dr = r - GetR (vec2 (ivn));\n      a += 5. * fSpring * (spLenD / length (dr) - 1.) * dr - fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n}\n\n#define InLatt2(t, k) (k == 0 && t > 1 || k == 2 && t < nBallE - 2 || k == 1 && (t > 0 && t < nBallE - 1))\n\nvoid ShBendForce (ivec2 iv, vec3 r, inout vec3 a)\n{\n  vec3 dr1, dr2, rt;\n  ivec2 ivd;\n  float s, c11, c22, c12, cd, fBend;\n  fBend = 500.;\n  for (int nd = 0; nd < 2; nd ++) {\n    ivd = (nd == 0) ? ivec2 (1, 0) : ivec2 (0, 1);\n    for (int k = 0; k < 3; k ++) {\n      if (nd == 0 && InLatt2 (iv.x, k) || nd == 1 && InLatt2 (iv.y, k)) {\n        if (k == 0) {\n          rt = GetR (vec2 (iv - ivd));\n          dr1 = rt - GetR (vec2 (iv - 2 * ivd));\n          dr2 = r - rt;\n          s = -1.;\n        } else if (k == 2) {\n          rt = GetR (vec2 (iv + ivd));\n          dr1 = rt - r;\n          dr2 = GetR (vec2 (iv + 2 * ivd)) - rt;\n          s = -1.;\n        } else {\n          dr1 = r - GetR (vec2 (iv - ivd));\n          dr2 = GetR (vec2 (iv + ivd)) - r;\n          s = 1.;\n        }\n        c11 = 1. / dot (dr1, dr1);\n        c12 = dot (dr1, dr2);\n        c22 = 1. / dot (dr2, dr2);\n        cd = sqrt (c11 * c22);\n        s *= fBend * cd * (c12 * cd - 1.);\n        if (k <= 1) a += s * (dr1 - c12 * c22 * dr2);\n        if (k >= 1) a += s * (c12 * c11 * dr1 - dr2);\n      }\n    }\n  }\n}\n\nvec4 RSite (int sId)\n{\n  vec3 s;\n  s = floor (mod (vec3 (sId), blkSph.x * vec3 (1., blkSph.y, blkSph.y * blkSph.z)) /\n     vec3 (1., blkSph.x, blkSph.x * blkSph.y)) - 0.5 * (blkSph - 1.);\n  return vec4 (blkGap * s, dot (step (0.45 * (blkSph - 1.), abs (s)), vec3 (1.)));\n}\n\nvoid ShBForce (vec3 r, inout vec3 a)\n{\n  mat3 mRot;\n  vec4 rts;\n  vec3 rm, dr;\n  float rSep;\n  for (int n = 0; n < nBlk; n ++) {\n    rm = GetRB (n);\n    mRot = QtToRMat (GetQB (n));\n    for (int j = 0; j < nSiteBlk; j ++) {\n      rts = RSite (j);\n      if (rts.w >= 2.) {\n        dr = r - (rm + mRot * rts.xyz);\n        rSep = length (dr);\n        if (rSep < 1.) a += fOvlap * (1. / rSep - 1.) * dr;\n      }\n    }\n  }\n}\n\nvec3 FcFun (vec3 dr, vec3 dv)\n{\n  vec3 f;\n  float rSep, vRel, fo, drv;\n  f = vec3 (0.);\n  rSep = length (dr);\n  if (rSep < 1.) {\n    fo = fOvlap * (1. / rSep - 1.);\n    drv = dot (dr, dv) / (rSep * rSep);\n    dv -= drv * dr;\n    vRel = length (dv);\n    fo = max (fo - fricN * drv, 0.);\n    f = fo * dr;\n    if (vRel > 0.001) f -= min (fricT, fricS * abs (fo) * rSep / vRel) * dv;\n  }\n  return f;\n}\n\nvoid BBPairForce (vec3 rm, vec3 vm, mat3 mRot, vec3 wm, inout vec3 am, inout vec3 wam)\n{\n  mat3 mRotN;\n  vec4 rts, rtsN;\n  vec3 rmN, vmN, wmN, dr, dv, f;\n  float bSep;\n  for (int n = 0; n < nBlk; n ++) {\n    rmN = GetRB (n);\n    bSep = length (rm - rmN);\n    if (bSep > 0.01 && bSep < farSep) {\n      vmN = GetVB (n);\n      mRotN = QtToRMat (GetQB (n));\n      wmN = GetWB (n);\n      for (int j = 0; j < nSiteBlk; j ++) {\n        rts = RSite (j);\n        if (rts.w >= 1.) {\n          rts.xyz = mRot * rts.xyz;\n          dv = vm + cross (wm, rts.xyz) - vmN;\n          f = vec3 (0.);\n          for (int jN = 0; jN < nSiteBlk; jN ++) {\n            rtsN = RSite (jN);\n            if (max (rts.w, rtsN.w) >= 2.) {\n              rtsN.xyz = mRotN * rtsN.xyz;\n              dr = rm + rts.xyz - (rmN + rtsN.xyz);\n              f += FcFun (dr, dv - cross (wmN, rtsN.xyz));\n            }\n          }\n        }\n        am += f;\n        wam += cross (rts.xyz, f);\n      }\n    }\n  }\n}\n\nvoid BWallForce (vec3 rm, vec3 vm, mat3 mRot, vec3 wm, inout vec3 am, inout vec3 wam)\n{\n  vec4 rts, drw;\n  vec3 r, dr, dv, f;\n  for (int j = 0; j < nSiteBlk; j ++) {\n    rts = RSite (j);\n    if (rts.w >= 2.) {\n      rts.xyz = mRot * rts.xyz;\n      r = rm + rts.xyz;\n      dv = vm + cross (wm, rts.xyz);\n      f = vec3 (0.);\n      drw = vec4 ((boxSize - 1. - abs (r)) * (1. - 2. * step (0., r)), 0.);\n      for (int nf = 0; nf < 3; nf ++) {\n        dr = (nf == 0) ? drw.xww : ((nf == 1) ? drw.wyw : drw.wwz);\n        f += FcFun (dr, dv);\n      }\n      am += f;\n      wam += cross (rts.xyz, f);\n    }\n  }\n}\n\nvoid BShForce (vec3 rm, vec3 vm, mat3 mRot, vec3 wm, inout vec3 am, inout vec3 wam)\n{\n  vec4 rts;\n  vec3 dr, dv, f;\n  vec2 g;\n  for (int j = 0; j < nSiteBlk; j ++) {\n    rts = RSite (j);\n    if (rts.w >= 2.) {\n      rts.xyz = mRot * rts.xyz;\n      f = vec3 (0.);\n      g = vec2 (0.);\n      for (int n = 0; n < nBallE * nBallE; n ++) {\n        dr = rm + rts.xyz - GetR (g);\n        dv = vm + cross (wm, rts.xyz) - GetV (g);\n        f += FcFun (dr, dv);\n        if (++ g.x == float (nBallE)) {\n          g.x = 0.;\n          ++ g.y;\n        }  \n      }\n      am += f;\n      wam += cross (rts.xyz, f);\n    }\n  }\n}\n\nvoid Step (ivec2 iv, out vec3 rm, out vec3 vm)\n{\n  vec3 am;\n  float dt;\n  IdNebs ();\n  rm = GetR (vec2 (iv));\n  vm = GetV (vec2 (iv));\n  am = vec3 (0.);\n  if (iv.x > 0 && iv.x < nBallE - 1 && iv.y > 0 && iv.y < nBallE - 1) {\n    ShSpringForce (iv, rm, vm, am);\n    ShBendForce (iv, rm, am);\n    ShBForce (rm, am);\n    am -= fvDamp * vm;\n    dt = 0.02;\n    vm += dt * am;\n    rm += dt * vm;\n  }\n}\n\nvoid StepB (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  mat3 mRot;\n  vec3 am, wam, dSp;\n  float dt;\n  rm = GetRB (mId);\n  vm = GetVB (mId);\n  qm = GetQB (mId);\n  wm = GetWB (mId);\n  mRot = QtToRMat (qm);\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  BBPairForce (rm, vm, mRot, wm, am, wam);\n  BWallForce (rm, vm, mRot, wm, am, wam);\n  BShForce (rm, vm, mRot, wm, am, wam);\n  am -= fvDamp * vm;\n  am /= bMass;\n  am -= 2. * gravVec;\n  dt = 0.02;\n  vm += dt * am;\n  rm += dt * vm;\n  dSp = blkGap * blkSph;\n  wam = mRot * (wam * mRot / (0.25 * (vec3 (dot (dSp, dSp)) - dSp * dSp) + 1.));\n  wm += dt * wam / bMass;\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid OrientVu (inout vec4 qtVu, vec4 mPtr, inout vec4 mPtrP, bool init)\n{\n  vec3 vq1, vq2;\n  vec2 dm;\n  float mFac;\n  if (! init) {\n    qtVu = EulToQt (vec3 (0.1, 0.4, 0.3) * pi);\n    mPtrP = vec4 (99., 0., -1., 0.);\n  } else {\n    if (mPtr.z > 0.) {\n      if (mPtrP.x == 99.) mPtrP = mPtr;\n      mFac = 1.5;\n      dm = - mFac * mPtrP.xy;\n      vq1 = vec3 (dm, sqrt (max (1. - dot (dm, dm), 0.)));\n      dm = - mFac * mPtr.xy;\n      vq2 = vec3 (dm, sqrt (max (1. - dot (dm, dm), 0.)));\n      qtVu = normalize (QtMul (vec4 (cross (vq1, vq2), dot (vq1, vq2)), qtVu));\n      mPtrP = mPtr;\n    } else mPtrP = vec4 (99., 0., -1., 0.);\n  }\n}\n\nvoid Init (ivec2 iv, out vec3 r, out vec3 v)\n{\n  for (int iy = 0; iy < nBallE; iy ++) {\n    for (int ix = 0; ix < nBallE; ix ++) {\n      if (iv.x == ix && iv.y == iy) {\n        r = 0.97 * spLen * (vec3 (ix, iy, 0.) - vec3 (vec2 (0.5 * float (nBallE - 1)), 0.));\n      }\n    }\n  }\n  v = vec3 (0.);\n}\n\nvoid InitB (int mId, out vec3 r, out vec3 v, out vec4 qm, out vec3 wm)\n{\n  float mIdf;\n  mIdf = float (mId);\n  r = 0.4 * boxSize * (2. * vec3 (mod (mIdf, 2.), floor (mod (mIdf, 4.) / 2.),\n     floor (mIdf / 4.)) - 1.);\n  v = vec3 (0.);\n  qm = EulToQt (normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6))));\n  wm = vec3 (0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, qtVu, qm;\n  vec3 r, v, wm;\n  vec2 canvas;\n  ivec2 pxIv, iv;\n  float tCur, nStep, asp;\n  int mId, pxId, kp;\n  bool doInit;\n  pxIv = ivec2 (fragCoord);\n  pxId = pxIv.x + 2 * nBallE * pxIv.y;\n  if (pxIv.x >= 2 * nBallE || pxId > 2 * nBallE * nBallE + 4 * nBlk + 2) discard;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  qtVu = Loadv4 (vec2 (4 * nBlk + 1, nBallE));\n  mPtrP = Loadv4 (vec2 (4 * nBlk + 2, nBallE));\n  iv = pxIv;\n  if (iv.x >= nBallE) iv.x -= nBallE;\n  mId = iv.y * nBallE + iv.x;\n  if (iFrame <= 5) {\n    doInit = true;\n    spLen = 1.1;\n    boxSize = 0.52 * spLen * float (nBallE - 1);\n    nStep = 0.;\n    OrientVu (qtVu, mPtr, mPtrP, false);\n  } else {\n    doInit = false;\n    stDat = Loadv4 (vec2 (4 * nBlk + 0, nBallE));\n    spLen = stDat.x;\n    boxSize = stDat.y;\n    nStep = stDat.w;\n    ++ nStep;\n    if (mPtrP.z < 0.) qtVu = EulToQt (QtToEul (qtVu) + 0.003 * pi * vec3 (0.41, 0., 0.27));\n    OrientVu (qtVu, mPtr, mPtrP, true);\n    gravVec = vec3 (0., 1., 0.) * QtToRMat (qtVu);\n    if (nStep > 100. && mPtr.z > 0. && mPtr.x > 0.5 - 0.05 / asp &&\n       mPtr.y > 0.5 - 0.05) doInit = true;\n  }\n  if (doInit) nStep = 0.;\n  bMass = 8.;\n  farSep = length (blkGap * (blkSph - 1.)) + 1.;\n  fOvlap = 1000.;\n  fricN = 1.;\n  fricT = 1.;\n  fricS = 2.;\n  fvDamp = 0.03;\n  if (mId < nBallE * nBallE) {\n    if (doInit) Init (iv, r, v);\n    else Step (iv, r, v);\n    stDat = vec4 (((pxIv.x < nBallE) ? r : v), 0.);\n  } else if (pxId >= 2 * nBallE * nBallE && pxId < 2 * nBallE * nBallE + 4 * nBlk) {\n    mId = (pxId - 2 * nBallE * nBallE) / 4;\n    if (doInit) InitB (mId, r, v, qm, wm);\n    else StepB (mId, r, v, qm, wm);\n    kp = pxId - 2 * nBallE * nBallE - 4 * mId;\n    if      (kp == 0) stDat = vec4 (r, 0.);\n    else if (kp == 1) stDat = vec4 (v, 0.);\n    else if (kp == 2) stDat = qm;\n    else if (kp == 3) stDat = vec4 (wm, 0.);\n  } else {\n    kp = pxId - 2 * nBallE * nBallE - 4 * nBlk;\n    if      (kp == 0) stDat = stDat = vec4 (spLen, boxSize, tCur, nStep);\n    else if (kp == 1) stDat = qtVu;\n    else if (kp == 2) stDat = mPtrP;\n  }\n  Savev4 (vec2 (pxIv), stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (dot (vec4 (q1.w, - q1.z, q1.yx), q2), dot (vec4 (q1.zw, - q1.x, q1.y), q2),\n     dot (vec4 (- q1.y, q1.xwz), q2), dot (vec4 (- q1.xyz, q1.w), q2));\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nvec3 QtToEul (vec4 q)\n{\n  vec3 e;\n  float s, t;\n  t = dot (q.xy, q.xy);\n  s = 2. * sqrt (max (t * (1. - t), 0.));\n  e.y = atan (s, 1. - 2. * t);\n  if (s != 0.) e.xz = \n     vec2 (atan (q.x * q.z + q.y * q.w, q.x * q.w - q.y * q.z),\n           atan (q.x * q.z - q.y * q.w, q.x * q.w + q.y * q.z));\n  else e.xz = vec2 (2. * atan (q.z, q.w), 0.);\n  return e;\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nvec3 GetV (vec2 v)\n{\n  v.x += float (nBallE);\n  return Loadv4 (v).xyz;\n}\n\nvec3 GetRB (int n)\n{\n  return Loadv4 (vec2 (4 * n + 0, nBallE)).xyz;\n}\n\nvec3 GetVB (int n)\n{\n  return Loadv4 (vec2 (4 * n + 1, nBallE)).xyz;\n}\n\nvec4 GetQB (int n)\n{\n  return Loadv4 (vec2 (4 * n + 2, nBallE));\n}\n\nvec3 GetWB (int n)\n{\n  return Loadv4 (vec2 (4 * n + 3, nBallE)).xyz;\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \"Floppy Clock With Dice\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 RMatToQt (mat3 m);\nmat3 QtToRMat (vec4 q);\nvec4 EulToQt (vec3 e);\nvec3 QtToEul (vec4 q);\nmat3 LpStepMat (vec3 a);\nfloat Hashff (float p);\nvec3 GetR (vec2 v);\nvec3 GetV (vec2 v);\nvec3 GetRB (int n);\nvec3 GetVB (int n);\nvec4 GetQB (int n);\nvec3 GetWB (int n);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nBallE = 33, nBlk = 8;\nconst vec3 blkSph = vec3 (3.), blkGap = vec3 (0.9);\nconst int nSiteBlk = 27;\n\nvec3 gravVec;\nivec2 idNeb[4], idNebD[4];\nfloat boxSize, spLen, bMass, farSep, fOvlap, fricN, fricT, fricS, fvDamp;\nconst float pi = 3.14159;\n\nvoid IdNebs ()\n{\n  idNeb[0] = ivec2 (1, 0);\n  idNeb[1] = - idNeb[0];\n  idNeb[2] = ivec2 (0, 1);\n  idNeb[3] = - idNeb[2];\n  idNebD[0] = ivec2 (1, 1);\n  idNebD[1] = - idNebD[0];\n  idNebD[2] = ivec2 (1, -1);\n  idNebD[3] = - idNebD[2];\n}\n\n#define InLatt(t) (t >= 0 && t < nBallE)\n\nvoid ShSpringForce (ivec2 iv, vec3 r, vec3 v, inout vec3 a)\n{\n  vec3 dr;\n  ivec2 ivn;\n  float spLenD, fSpring, fDamp;\n  fSpring = 200.;\n  fDamp = 0.05;\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNeb[n];\n    if (InLatt (ivn.x) && InLatt (ivn.y)) {\n      dr = r - GetR (vec2 (ivn));\n      a += fSpring * (spLen / length (dr) - 1.) * dr - fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  spLenD = spLen * sqrt (2.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNebD[n];\n    if (InLatt (ivn.x) && InLatt (ivn.y)) {\n      dr = r - GetR (vec2 (ivn));\n      a += 5. * fSpring * (spLenD / length (dr) - 1.) * dr - fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n}\n\n#define InLatt2(t, k) (k == 0 && t > 1 || k == 2 && t < nBallE - 2 || k == 1 && (t > 0 && t < nBallE - 1))\n\nvoid ShBendForce (ivec2 iv, vec3 r, inout vec3 a)\n{\n  vec3 dr1, dr2, rt;\n  ivec2 ivd;\n  float s, c11, c22, c12, cd, fBend;\n  fBend = 500.;\n  for (int nd = 0; nd < 2; nd ++) {\n    ivd = (nd == 0) ? ivec2 (1, 0) : ivec2 (0, 1);\n    for (int k = 0; k < 3; k ++) {\n      if (nd == 0 && InLatt2 (iv.x, k) || nd == 1 && InLatt2 (iv.y, k)) {\n        if (k == 0) {\n          rt = GetR (vec2 (iv - ivd));\n          dr1 = rt - GetR (vec2 (iv - 2 * ivd));\n          dr2 = r - rt;\n          s = -1.;\n        } else if (k == 2) {\n          rt = GetR (vec2 (iv + ivd));\n          dr1 = rt - r;\n          dr2 = GetR (vec2 (iv + 2 * ivd)) - rt;\n          s = -1.;\n        } else {\n          dr1 = r - GetR (vec2 (iv - ivd));\n          dr2 = GetR (vec2 (iv + ivd)) - r;\n          s = 1.;\n        }\n        c11 = 1. / dot (dr1, dr1);\n        c12 = dot (dr1, dr2);\n        c22 = 1. / dot (dr2, dr2);\n        cd = sqrt (c11 * c22);\n        s *= fBend * cd * (c12 * cd - 1.);\n        if (k <= 1) a += s * (dr1 - c12 * c22 * dr2);\n        if (k >= 1) a += s * (c12 * c11 * dr1 - dr2);\n      }\n    }\n  }\n}\n\nvec4 RSite (int sId)\n{\n  vec3 s;\n  s = floor (mod (vec3 (sId), blkSph.x * vec3 (1., blkSph.y, blkSph.y * blkSph.z)) /\n     vec3 (1., blkSph.x, blkSph.x * blkSph.y)) - 0.5 * (blkSph - 1.);\n  return vec4 (blkGap * s, dot (step (0.45 * (blkSph - 1.), abs (s)), vec3 (1.)));\n}\n\nvoid ShBForce (vec3 r, inout vec3 a)\n{\n  mat3 mRot;\n  vec4 rts;\n  vec3 rm, dr;\n  float rSep;\n  for (int n = 0; n < nBlk; n ++) {\n    rm = GetRB (n);\n    mRot = QtToRMat (GetQB (n));\n    for (int j = 0; j < nSiteBlk; j ++) {\n      rts = RSite (j);\n      if (rts.w >= 2.) {\n        dr = r - (rm + mRot * rts.xyz);\n        rSep = length (dr);\n        if (rSep < 1.) a += fOvlap * (1. / rSep - 1.) * dr;\n      }\n    }\n  }\n}\n\nvec3 FcFun (vec3 dr, vec3 dv)\n{\n  vec3 f;\n  float rSep, vRel, fo, drv;\n  f = vec3 (0.);\n  rSep = length (dr);\n  if (rSep < 1.) {\n    fo = fOvlap * (1. / rSep - 1.);\n    drv = dot (dr, dv) / (rSep * rSep);\n    dv -= drv * dr;\n    vRel = length (dv);\n    fo = max (fo - fricN * drv, 0.);\n    f = fo * dr;\n    if (vRel > 0.001) f -= min (fricT, fricS * abs (fo) * rSep / vRel) * dv;\n  }\n  return f;\n}\n\nvoid BBPairForce (vec3 rm, vec3 vm, mat3 mRot, vec3 wm, inout vec3 am, inout vec3 wam)\n{\n  mat3 mRotN;\n  vec4 rts, rtsN;\n  vec3 rmN, vmN, wmN, dr, dv, f;\n  float bSep;\n  for (int n = 0; n < nBlk; n ++) {\n    rmN = GetRB (n);\n    bSep = length (rm - rmN);\n    if (bSep > 0.01 && bSep < farSep) {\n      vmN = GetVB (n);\n      mRotN = QtToRMat (GetQB (n));\n      wmN = GetWB (n);\n      for (int j = 0; j < nSiteBlk; j ++) {\n        rts = RSite (j);\n        if (rts.w >= 1.) {\n          rts.xyz = mRot * rts.xyz;\n          dv = vm + cross (wm, rts.xyz) - vmN;\n          f = vec3 (0.);\n          for (int jN = 0; jN < nSiteBlk; jN ++) {\n            rtsN = RSite (jN);\n            if (max (rts.w, rtsN.w) >= 2.) {\n              rtsN.xyz = mRotN * rtsN.xyz;\n              dr = rm + rts.xyz - (rmN + rtsN.xyz);\n              f += FcFun (dr, dv - cross (wmN, rtsN.xyz));\n            }\n          }\n        }\n        am += f;\n        wam += cross (rts.xyz, f);\n      }\n    }\n  }\n}\n\nvoid BWallForce (vec3 rm, vec3 vm, mat3 mRot, vec3 wm, inout vec3 am, inout vec3 wam)\n{\n  vec4 rts, drw;\n  vec3 r, dr, dv, f;\n  for (int j = 0; j < nSiteBlk; j ++) {\n    rts = RSite (j);\n    if (rts.w >= 2.) {\n      rts.xyz = mRot * rts.xyz;\n      r = rm + rts.xyz;\n      dv = vm + cross (wm, rts.xyz);\n      f = vec3 (0.);\n      drw = vec4 ((boxSize - 1. - abs (r)) * (1. - 2. * step (0., r)), 0.);\n      for (int nf = 0; nf < 3; nf ++) {\n        dr = (nf == 0) ? drw.xww : ((nf == 1) ? drw.wyw : drw.wwz);\n        f += FcFun (dr, dv);\n      }\n      am += f;\n      wam += cross (rts.xyz, f);\n    }\n  }\n}\n\nvoid BShForce (vec3 rm, vec3 vm, mat3 mRot, vec3 wm, inout vec3 am, inout vec3 wam)\n{\n  vec4 rts;\n  vec3 dr, dv, f;\n  vec2 g;\n  for (int j = 0; j < nSiteBlk; j ++) {\n    rts = RSite (j);\n    if (rts.w >= 2.) {\n      rts.xyz = mRot * rts.xyz;\n      f = vec3 (0.);\n      g = vec2 (0.);\n      for (int n = 0; n < nBallE * nBallE; n ++) {\n        dr = rm + rts.xyz - GetR (g);\n        dv = vm + cross (wm, rts.xyz) - GetV (g);\n        f += FcFun (dr, dv);\n        if (++ g.x == float (nBallE)) {\n          g.x = 0.;\n          ++ g.y;\n        }  \n      }\n      am += f;\n      wam += cross (rts.xyz, f);\n    }\n  }\n}\n\nvoid Step (ivec2 iv, out vec3 rm, out vec3 vm)\n{\n  vec3 am;\n  float dt;\n  IdNebs ();\n  rm = GetR (vec2 (iv));\n  vm = GetV (vec2 (iv));\n  am = vec3 (0.);\n  if (iv.x > 0 && iv.x < nBallE - 1 && iv.y > 0 && iv.y < nBallE - 1) {\n    ShSpringForce (iv, rm, vm, am);\n    ShBendForce (iv, rm, am);\n    ShBForce (rm, am);\n    am -= fvDamp * vm;\n    dt = 0.02;\n    vm += dt * am;\n    rm += dt * vm;\n  }\n}\n\nvoid StepB (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  mat3 mRot;\n  vec3 am, wam, dSp;\n  float dt;\n  rm = GetRB (mId);\n  vm = GetVB (mId);\n  qm = GetQB (mId);\n  wm = GetWB (mId);\n  mRot = QtToRMat (qm);\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  BBPairForce (rm, vm, mRot, wm, am, wam);\n  BWallForce (rm, vm, mRot, wm, am, wam);\n  BShForce (rm, vm, mRot, wm, am, wam);\n  am -= fvDamp * vm;\n  am /= bMass;\n  am -= 2. * gravVec;\n  dt = 0.02;\n  vm += dt * am;\n  rm += dt * vm;\n  dSp = blkGap * blkSph;\n  wam = mRot * (wam * mRot / (0.25 * (vec3 (dot (dSp, dSp)) - dSp * dSp) + 1.));\n  wm += dt * wam / bMass;\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid OrientVu (inout vec4 qtVu, vec4 mPtr, inout vec4 mPtrP, bool init)\n{\n  vec3 vq1, vq2;\n  vec2 dm;\n  float mFac;\n  if (! init) {\n    qtVu = EulToQt (vec3 (0.1, 0.4, 0.3) * pi);\n    mPtrP = vec4 (99., 0., -1., 0.);\n  } else {\n    if (mPtr.z > 0.) {\n      if (mPtrP.x == 99.) mPtrP = mPtr;\n      mFac = 1.5;\n      dm = - mFac * mPtrP.xy;\n      vq1 = vec3 (dm, sqrt (max (1. - dot (dm, dm), 0.)));\n      dm = - mFac * mPtr.xy;\n      vq2 = vec3 (dm, sqrt (max (1. - dot (dm, dm), 0.)));\n      qtVu = normalize (QtMul (vec4 (cross (vq1, vq2), dot (vq1, vq2)), qtVu));\n      mPtrP = mPtr;\n    } else mPtrP = vec4 (99., 0., -1., 0.);\n  }\n}\n\nvoid Init (ivec2 iv, out vec3 r, out vec3 v)\n{\n  for (int iy = 0; iy < nBallE; iy ++) {\n    for (int ix = 0; ix < nBallE; ix ++) {\n      if (iv.x == ix && iv.y == iy) {\n        r = 0.97 * spLen * (vec3 (ix, iy, 0.) - vec3 (vec2 (0.5 * float (nBallE - 1)), 0.));\n      }\n    }\n  }\n  v = vec3 (0.);\n}\n\nvoid InitB (int mId, out vec3 r, out vec3 v, out vec4 qm, out vec3 wm)\n{\n  float mIdf;\n  mIdf = float (mId);\n  r = 0.4 * boxSize * (2. * vec3 (mod (mIdf, 2.), floor (mod (mIdf, 4.) / 2.),\n     floor (mIdf / 4.)) - 1.);\n  v = vec3 (0.);\n  qm = EulToQt (normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6))));\n  wm = vec3 (0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, qtVu, qm;\n  vec3 r, v, wm;\n  vec2 canvas;\n  ivec2 pxIv, iv;\n  float tCur, nStep, asp;\n  int mId, pxId, kp;\n  bool doInit;\n  pxIv = ivec2 (fragCoord);\n  pxId = pxIv.x + 2 * nBallE * pxIv.y;\n  if (pxIv.x >= 2 * nBallE || pxId > 2 * nBallE * nBallE + 4 * nBlk + 2) discard;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  qtVu = Loadv4 (vec2 (4 * nBlk + 1, nBallE));\n  mPtrP = Loadv4 (vec2 (4 * nBlk + 2, nBallE));\n  iv = pxIv;\n  if (iv.x >= nBallE) iv.x -= nBallE;\n  mId = iv.y * nBallE + iv.x;\n  if (iFrame <= 5) {\n    doInit = true;\n    spLen = 1.1;\n    boxSize = 0.52 * spLen * float (nBallE - 1);\n    nStep = 0.;\n    OrientVu (qtVu, mPtr, mPtrP, false);\n  } else {\n    doInit = false;\n    stDat = Loadv4 (vec2 (4 * nBlk + 0, nBallE));\n    spLen = stDat.x;\n    boxSize = stDat.y;\n    nStep = stDat.w;\n    ++ nStep;\n    if (mPtrP.z < 0.) qtVu = EulToQt (QtToEul (qtVu) + 0.003 * pi * vec3 (0.41, 0., 0.27));\n    OrientVu (qtVu, mPtr, mPtrP, true);\n    gravVec = vec3 (0., 1., 0.) * QtToRMat (qtVu);\n    if (nStep > 100. && mPtr.z > 0. && mPtr.x > 0.5 - 0.05 / asp &&\n       mPtr.y > 0.5 - 0.05) doInit = true;\n  }\n  if (doInit) nStep = 0.;\n  bMass = 8.;\n  farSep = length (blkGap * (blkSph - 1.)) + 1.;\n  fOvlap = 1000.;\n  fricN = 1.;\n  fricT = 1.;\n  fricS = 2.;\n  fvDamp = 0.03;\n  if (mId < nBallE * nBallE) {\n    if (doInit) Init (iv, r, v);\n    else Step (iv, r, v);\n    stDat = vec4 (((pxIv.x < nBallE) ? r : v), 0.);\n  } else if (pxId >= 2 * nBallE * nBallE && pxId < 2 * nBallE * nBallE + 4 * nBlk) {\n    mId = (pxId - 2 * nBallE * nBallE) / 4;\n    if (doInit) InitB (mId, r, v, qm, wm);\n    else StepB (mId, r, v, qm, wm);\n    kp = pxId - 2 * nBallE * nBallE - 4 * mId;\n    if      (kp == 0) stDat = vec4 (r, 0.);\n    else if (kp == 1) stDat = vec4 (v, 0.);\n    else if (kp == 2) stDat = qm;\n    else if (kp == 3) stDat = vec4 (wm, 0.);\n  } else {\n    kp = pxId - 2 * nBallE * nBallE - 4 * nBlk;\n    if      (kp == 0) stDat = stDat = vec4 (spLen, boxSize, tCur, nStep);\n    else if (kp == 1) stDat = qtVu;\n    else if (kp == 2) stDat = mPtrP;\n  }\n  Savev4 (vec2 (pxIv), stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (dot (vec4 (q1.w, - q1.z, q1.yx), q2), dot (vec4 (q1.zw, - q1.x, q1.y), q2),\n     dot (vec4 (- q1.y, q1.xwz), q2), dot (vec4 (- q1.xyz, q1.w), q2));\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nvec3 QtToEul (vec4 q)\n{\n  vec3 e;\n  float s, t;\n  t = dot (q.xy, q.xy);\n  s = 2. * sqrt (max (t * (1. - t), 0.));\n  e.y = atan (s, 1. - 2. * t);\n  if (s != 0.) e.xz = \n     vec2 (atan (q.x * q.z + q.y * q.w, q.x * q.w - q.y * q.z),\n           atan (q.x * q.z - q.y * q.w, q.x * q.w + q.y * q.z));\n  else e.xz = vec2 (2. * atan (q.z, q.w), 0.);\n  return e;\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nvec3 GetV (vec2 v)\n{\n  v.x += float (nBallE);\n  return Loadv4 (v).xyz;\n}\n\nvec3 GetRB (int n)\n{\n  return Loadv4 (vec2 (4 * n + 0, nBallE)).xyz;\n}\n\nvec3 GetVB (int n)\n{\n  return Loadv4 (vec2 (4 * n + 1, nBallE)).xyz;\n}\n\nvec4 GetQB (int n)\n{\n  return Loadv4 (vec2 (4 * n + 2, nBallE));\n}\n\nvec3 GetWB (int n)\n{\n  return Loadv4 (vec2 (4 * n + 3, nBallE)).xyz;\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXBDr.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[854, 854, 887, 887, 1529], [1531, 1531, 1577, 1577, 1989], [2050, 2050, 2072, 2072, 2610], [2612, 2612, 2645, 2645, 2820], [2822, 2822, 2843, 2843, 3091], [3093, 3093, 3128, 3128, 4080], [4082, 4082, 4100, 4100, 4257], [4259, 4259, 4284, 4284, 5614], [5616, 5616, 5658, 5658, 5945], [5947, 5947, 6002, 6002, 6213], [6215, 6215, 6260, 6260, 6442], [6444, 6444, 6479, 6479, 9194], [9196, 9196, 9252, 9252, 10700], [10702, 10702, 10734, 10734, 10834], [10836, 10836, 10861, 10861, 11236], [11238, 11238, 11260, 11260, 11298], [11300, 11300, 11322, 11322, 11360], [11362, 11362, 11419, 11419, 11502], [11504, 11504, 11534, 11534, 11647], [11649, 11649, 11669, 11669, 11696], [11698, 11698, 11719, 11719, 11764], [11766, 11766, 11786, 11786, 11836], [11838, 11838, 11858, 11858, 11904], [11971, 11971, 11995, 11995, 12045]], "test": "untested"}
{"id": "WsXfDn", "name": "Coloured Collatz fractal", "author": "hamalan", "description": "Collatz fractal", "tags": ["fractal", "collatz"], "likes": 1, "viewed": 334, "published": 3, "date": "1587989157", "time_retrieved": "2024-07-30T21:10:16.254075", "image_code": "// Original code created by Trashe725\n\n#define AA 4\n#define pi 3.14159265358979323846\n#define maxIter 100\n#define maxThres 100.\n\n// from julesb\n// github: https://github.com/julesb/glsl-util/blob/master/complexvisual.glsl\n\nfloat sinnh(float a) { return float(0.5*( exp(a) - exp(-a))); }\nfloat cossh(float a) { return float(0.5*( exp(a) + exp(-a))); }\nfloat tannh(float a) { return float(sinnh(a)/cossh(a)); }\nvec2 cx_add(vec2 a, float b) { return vec2(a.x+b, a.y); }\nvec2 cx_mul(vec2 a, vec2 b) { return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x); }\nvec2 cx_div(vec2 a, vec2 b) { return vec2((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y), (a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)); }\nvec2 cx_cos(vec2 a) { return vec2(cos(a.x) * cossh(a.y), -sin(a.x) * sinnh(a.y)); }\nvec2 cx_sin(vec2 a) { return vec2(sin(a.x) * cossh(a.y), cos(a.x) * sinnh(a.y)); }\nvec2 cx_tanh(vec2 a) { return vec2(cx_div(cx_sin(a),cx_cos(a))); }\n\nvec3 render(vec2 fragCoord, float time)\n{\n    //zoom\n    float sc = 0.12;\n    // Center of the image\n    vec2 ce = vec2(1.99, 0.0);\n    float zoom = time;\n    sc = sc * pow(0.9, zoom);\n    \n    vec2 fc = (-iResolution.xy + 2.0 *fragCoord) / iResolution.x;\n    vec2 z = ce + sc * fc;\n    vec2 dz = vec2(1.0, 0.0);\n    \n    vec2 lz = z;\n    vec2 ldz = dz;\n    \n    //iter\n    int iter = 0;\n    while(iter < maxIter && length(z) < maxThres){\n        lz = z;\n        ldz = dz;\n        vec2 piz = pi*z;\n        dz = cx_add( pi*cx_mul(cx_sin(piz), cx_add(z*4., 2.))-5.*cx_cos(piz), 7.)/4.;\n        z = ( cx_add(z*7., 2.) - cx_mul(cx_add(z*5., 2.), cx_cos(piz)) )/4.;\n        ++iter;\n    }\n    \n    //color\n    float de = length(lz)*log(length(lz))/length(ldz);\n    if (iter < maxIter && length(ldz) < maxThres){\n        \n        return vec3(1.0, 1.0, 1.0);\n    } else {\n    \treturn vec3(0.0, sin(clamp( length(dz), 0.0, 1.0)), tannh(clamp(length(ldz), 0.0, 1.0)));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    float time = -sin(iTime/10.)*9.1 + pi/2.;\n#ifdef AA\n    for(int m=0;m<AA;++m){\n        for(int n=0;n<AA;++n){\n        \tvec2 px = fragCoord + vec2(float(m), float(n))/float(AA);\n            col += render(px, time);\n        }\n    }\n    \n    col /= float(AA*AA);\n#else\n    col = render(fragCoord, time);\n#endif\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXfDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[223, 223, 245, 245, 286], [287, 287, 309, 309, 350], [351, 351, 373, 373, 408], [409, 409, 439, 439, 466], [467, 467, 496, 496, 545], [546, 546, 575, 575, 664], [665, 665, 686, 686, 748], [749, 749, 770, 770, 831], [832, 832, 854, 854, 898], [900, 900, 941, 952, 1866], [1868, 1868, 1925, 1925, 2297]], "test": "untested"}
{"id": "wdsfz7", "name": "coronapacman", "author": "FabriceNeyret2", "description": "reference: [img]https://static.boredpanda.com/blog/wp-content/uploads/2020/04/9-5ea2fa3a27cf1__700.jpg[/img]\nUncomment line16 to make them out of phase.", "tags": ["pacman", "short", "reproduction", "coronavirus", "covid19"], "likes": 17, "viewed": 625, "published": 3, "date": "1587976394", "time_retrieved": "2024-07-30T21:10:17.006064", "image_code": "#define S(v)   smoothstep(1.5,0.,(v)/fwidth(v))  // antialiased draw // 15./R.y\n#define L(x,y) length(vec2(x,y))\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 5.* ( 2.*u - R ) / R.y, V=U;\n    U.x = mod(U.x-3.*iTime, 4.)-2.;      // horizontal tranlation\n\n    float t = 2.*iTime, f,F,c,\n#define setT(t) f = fract(t), F = min(f,1.-f), c = F - A\n          a = atan(U.y,U.x), A = abs(a)/1.6, n = 6.,\n       // B = (2.-A) / (2.-F),           // normalized angle along deformed perimeter\n          l = length(U);\n    O-=O;\n // t += .06*V.x;                        // make them out of phase \n    \n    // --- body\n    setT(t);\n    O.g =   S ( l-1.) * S ( c*l );       // disk * pie\n    \n    // --- eye\n    a = a/1.6 - 1.5/(2.-F);              // local eye coordinates\n    O += S( L(a,l-.5) -.25 );            //   white part\n    O -= S( L(a,l-.5) -.12 ) * 2.;       //   black part\n // O += S( abs(a/1.6 - 1.5/(2.-F) )-.2 ) * S( abs(l-.5) - .25 ); // square\n    \n    // --- hairs\n    setT( t - .3*(l-1.) );               // deform: small time delay\n    A = fract( n* (2.-A) / (2.-F) ) -.5; // local hair ordinate\n    O.g += (   S( L(A,2.*(l-1.2)) -.2 )  //   disk + bar\n             + S( abs(A)-.1 ) * S ( abs(l-1.1)-.1 ) ) * S ( c*l );\n // O.g +=     S( A ) * S ( abs(l-1.2)-.2 )  * S ( c*l ) ;  // squares\n}", "image_inputs": [{"id": 22328, "src": "https://soundcloud.com/fabo-orlando/minimal-pacman", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsfz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "wslfz7", "name": "dotty line segments", "author": "FabriceNeyret2", "description": "auto-demo or mouse control.", "tags": ["lines", "dot", "mm", "segments", "dashes"], "likes": 4, "viewed": 490, "published": 3, "date": "1587971178", "time_retrieved": "2024-07-30T21:10:17.844821", "image_code": "#define R iResolution.xy\n\n#define S(d,r) smoothstep( .7, -.7, (d-r)*R.y/2.)  // antialiased draw\n\nfloat dots(vec2 p, vec2 a,vec2 b, float w) {      // SDF to dots\n    p -= a, b -= a;\n    float h = dot(p, b) / dot(b, b),    \n          c = clamp(h, 0., 1.-w/2.),\n          n = length(b)/w,          // number of dots separate by w\n       // n = 10.,                  //  for always 10. dots\n          H = round(c*n)/n;\n    return length(p - b * H);\n // return h==clamp(h, 0., 1.) ? length(p - b * h) : 1e5; // line without round ends\n\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float scale = 2./R.y,        t = iTime, d = 1e3,\n          WIDTH = 10.* scale;\n    vec2 U = scale* ( u - .5*R ),\n         M = scale* ( iMouse.xy - .5*R );\n    if (length(iMouse.xy) < 10. ) M = vec2(.6*cos(t)+.3*sin(2.3*t),.6*sin(.9*t)-.3*cos(1.8*t)); // demo mode \n\n    // SDF of multiple dotty lines\n    d = min(d, dots (U, vec2(0), M , WIDTH ) );\n    d = min(d, dots (U, M, vec2(M.y,M.x) , WIDTH ) );\n    d = min(d, dots (U, vec2(M.y,M.x), vec2(0) , WIDTH ) );\n    O = vec4( S( d, .8*WIDTH/2.) ); // draw dots\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslfz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 142, 162, 534], [536, 536, 574, 574, 1092]], "test": "untested"}
{"id": "tdlBR7", "name": "Random Trig", "author": "eiffie", "description": "Random user defined trig functions.", "tags": ["nottrig"], "likes": 5, "viewed": 326, "published": 3, "date": "1587949640", "time_retrieved": "2024-07-30T21:10:18.710507", "image_code": "//Random Trig by eiffie - playing with waveforms\n// The sine wave when matched with its \"co\"-sine 1/4 of a cycle ahead\n// create the unit circle. All waveforms create a shape this way and\n// form the basis for their own user defined trigonometry.\n// What waveform creates a box, a triangle, a cat?\n// Usage:\n// Draw the \"sine\" wave on the black surface starting from the left side\n// on the green line and ending on the right back to zero (the green line).\n// The resulting shape is drawn on the white surface.\n\n// While mostly a time waster there are some simple waveforms that are\n// useful in cg. This exercize gives you an intuition where to start looking.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv=fragCoord/iResolution.xy;\n  fragColor=texture(iChannel0,uv);            //base line for drawing\n  if(uv.x<0.5){fragColor.g+=0.5*smoothstep(1.0/iResolution.y,0.,min(abs(uv.y-0.5),mod(uv.x,.125)));return;}\n  vec4 lastms=texture(iChannel0,vec2(0.5,1.5)/iResolution.xy);\n  if(lastms.x>iResolution.x/2.-5.){//good enough\n    float a=fract(iTime*0.1);//rotation angle\n    float sa=texture(iChannel0,vec2(a*0.5,0.0)).r;//get trig from lookup table\n    float ca=texture(iChannel0,vec2(fract(a+0.25)*0.5,0.0)).r;\n    ca=(ca*2.)-1.0;sa=(sa*2.)-1.0;//fix for 0-1 to -1,1\n    uv.x=(uv.x-0.5)*2.0;//fix for left side\n    uv=(uv-vec2(0.5))*2.0;//and scale\n    float d=length(uv-vec2(ca,sa));//distance to this pixel\n    fragColor.rgb=mix(vec3(1.0,0.0,0.0),fragColor.rgb,smoothstep(d,8.0/iResolution.y,0.0));\n  }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlBR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[512, 661, 718, 718, 1528]], "test": "untested"}
{"id": "wslfzM", "name": "I'm Developing a ...", "author": "eiffie", "description": "I'm Developing a Pyramid Complex", "tags": ["fractal", "music", "pyramid"], "likes": 21, "viewed": 529, "published": 3, "date": "1587948542", "time_retrieved": "2024-07-30T21:10:19.461499", "image_code": "//I'm Developing a Pyramid Complex - by eiffie\nfloat nois(vec2 v){// based on 2d noise by Trisomie21\n  vec4 h=fract(sin(vec4(floor(v.x)+floor(v.y)*100.)+vec4(0.,1.,100.,101.))*100.);\n  v=smoothstep(0.,1.,fract(v));return mix(mix(h.x,h.y,v.x),mix(h.z,h.w,v.x),v.y);\n}\nfloat bxLength(vec2 p){p=abs(p);return max(p.x,p.y);}\nfloat wav(float a){return abs(fract(a)-0.5);}\nfloat brick(vec2 p){\n  p.y+=0.5;//if(mod(p.y+0.5,2.0)<1.)p.x+=1.0;//i've turned all the pyrs to 45 deg\n  return min(wav(p.x*0.45)*wav(p.y),0.07);   //so no need to offset brick pattern\n}\nvec3 mcol=vec3(0.0);float detail=0.0;\nfloat DE(vec3 p0){\n  if(detail>0.0){\n    p0.y+=0.00025*nois(p0.xz*1000.0)*detail;\n    p0.y-=abs(sin(p0.y*1000.0))*0.001*detail; \n  }\n  vec2 p=p0.xz;\n  float d=bxLength(p)-0.25+p0.y,ts=1.0,s=1.936,id=1.,sid=1.;\n  for(int i=0;i<6;i++){\n    p=(abs(vec2(p.x-p.y,p.y+p.x)*0.707)-0.6)*s;ts*=s;\n    float d2=max(((bxLength(p)-0.25)/ts+p0.y)*.5,p0.y-0.235/ts);\n    if(d2<d){sid=id;d=d2;}id=-id;\n  }\n  float y=p0.y;\n  if(detail>0.0){\n    y+=0.0025*sin(p0.x*100.0+sin(p0.z*50.0))*detail;\n    y+=0.00025*sin(y*100.0+sin(p0.x*400.0+sin(p0.z*200.0)))*detail;\n    if(sid<0.)p0.x+=p0.z;//turn axis aligned pyrs 45 deg\n    d-=brick(p0.xy*318.3)*0.005*detail;\n  }\n  mcol=vec3(0.6,(d<y?0.5:0.2),0.);\n  return min(d,y)*0.5;\n}\nvec3 sky(vec3 rd, vec3 L){//modified bananaft's & public_int_i's code\n  float d=0.4*dot(rd,L)+0.6;\n  if(rd.y<0.0)return vec3(0.28,0.17,0.07)*dot(vec3(rd.x,-rd.y,rd.z),L);\n  float y=max(0.,L.y),sun=max(1.-(1.+10.*y+rd.y)*length(rd-L),0.)\n    +.3*pow(1.-rd.y,12.)*(1.6-y);\n  return d*mix(vec3(0.3984,0.5117,0.7305),vec3(0.7031,0.4687,0.1055),sun)\n    *((.5+pow(y,.4))*(1.5-abs(L.y))+pow(sun,5.2)*y*(5.+15.0*y));\n}\nfloat rnd;\nvoid randomize(in vec2 p){rnd=fract(float(iFrame)+sin(dot(p,vec2(13.3145,117.7391)))*42317.7654321);}\n\nvec3 scene(vec3 ro, vec3 rd){\n  vec3 L=normalize(vec3(0.4,0.025,0.5));\n  vec3 bcol=sky(rd,L);\n  vec4 col=vec4(0.0);//color accumulator\n  float t=DE(ro)*rnd,d,od=1.0,px=1.0/iResolution.x;ro+=t*rd;\n  for(int i=0;i<256;i++){\n    detail=max(1.0-t*2.0,0.0);\n    d=DE(ro);\n    float soc=px*t*max(20.-750.*t,1.0);\n    if(d<soc){\n      vec3 scol=mcol;\n      float d3=DE(ro+d*16.0*L),d2=DE(ro+d*2.0*L);\n      float vis=clamp(1.0-d/od,0.0,1.0);\n      float dif=clamp(0.3*d2/d,0.0,1.0);\n      float ld=dot(rd,L);\n      float spec=ld<0.0?-ld*vis:ld*(1.0-vis);\n      float shad=clamp(0.03125*d3/d,0.0,1.0);\n      if(detail>0.0)\n        scol+=(vec3(nois(ro.xz*2500.0))+vec3(1.0,0.5,0.0)*nois((ro.zx+(mcol.g==0.5?2.0:.2)*ro.yy)*7000.0))*detail;\n      scol=(scol*dif+vec3(vis)+vec3(1.0,0.9,0.6)*spec)*shad*5.0;\n      float alpha=(1.0-col.w)*clamp(1.0-d/soc,0.0,1.0);if(alpha>0.89)alpha=1.0;\n      col+=vec4(clamp(scol,0.0,1.0),1.0)*alpha;\n      if(col.w>0.9)break;\n    }\n    t+=d;od=d;ro+=rd*d;\n    if(t>3.0)break;\n  }\n  col.rgb+=bcol*(1.0-clamp(col.w,0.0,1.0));\n  return col.rgb;\n}\nmat3 lookat(vec3 fw){vec3 up=vec3(0.0,1.0,0.0),rt=-normalize(cross(fw,up));return mat3(rt,normalize(cross(rt,fw)),fw);}\nvec3 path(float a){\n  a=mod(a,1.25);\n  vec3 v=vec3(cos(a),0.01,sin(a*1.2))*(1.3-a);\n  float d=DE(v);\n  v.y-=d*1.5;v.y+=0.01+abs(sin(a*100.0))*0.001+pow(a,10.0)*0.4;\n  return v;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n randomize(fragCoord);\n float a=iTime*0.01+sin(iTime*0.1)*0.1;\n vec3 cam = path(a);a+=3.0+sin(iTime*0.3);\n if(DE(cam)<0.0){fragColor=vec4(0.0);return;}\n vec3 fw=normalize(vec3(cos(a),cos(a*0.7)*0.025,sin(a))*1.25-cam);\n vec3 rd = lookat(fw)*normalize(vec3((iResolution.xy-2.0*fragCoord)/iResolution.y,2.0));\n fragColor = vec4(scene(cam,rd),1.0);\n}", "image_inputs": [], "sound_code": "#define bps 7.0 \nfloat rnd(float t){return fract(sin(mod(t,32.123)*32.123)*41.123);} \nvec2 nofs(float n){//the song's \"random\" ring \n  float r=0.5+0.5*rnd(floor(n));//random volume as well \n  n=mod(n,8.0); \n  if(n<1.0)n= 0.0; \n  else if(n<2.0)n= 2.0; \n  else if(n<3.0)n= 4.0; \n  else if(n<4.0)n= 5.0; \n  else if(n<5.0)n= 2.0; \n  else if(n<6.0)n= 0.0; \n  else if(n<7.0)n= -2.0; \n  else n=1.0; \n  return vec2(n,r); \n} \nfloat scale(float note){//throws out dissonant tones \n float n2=mod(note,12.); \n //if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//major \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//minor \n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100;//pentatonic minor \n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100.;//blues  \n //if((n2==1.)||(n2==2.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//country \n //if((n2==1.)||(n2==4.)||(n2==7.)||(n2==10.))note=-100.;//diminished whole/half \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//pentatonic major \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//harmonic minor \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//melodic minor ascending \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//whole tone \n //if((n2==2.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//diminished half/whole \n //if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//mixolydian   \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//dorian \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==10.))note=-100.;//lydian   \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian \n if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian Major \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//locrian \n //if((n2==2.)||(n2==4.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//lydian dominant \n //if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//double harmonic \n //if((n2==2.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.))note=-100.;//enigmatic \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//neapolitan  \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//neapolitan minor \n //if((n2==1.)||(n2==4.)||(n2==5.)||(n2==9.)||(n2==10.))note=-100.;//hungarian minor \n return note; \n} \n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2 \nfloat ntof(float n){return (n>0.0)?440.0 * pow(2.0, (n - 67.0) / 12.0):0.0;} \nconst float PI=3.14159; \nfloat Cos(float a){return cos(mod(a,PI*2.));} \nfloat Sin(float a){return Cos(a+PI/2.);} \nstruct instr{float att,fo,vibe,vphas,phas,dtun;}; \nvec2 I(float n,float t,float bt,instr i){//note,time,bt 0-8,instrument \n float f=ntof(scale(n));if(f<12.)return vec2(0.0);f-=bt*i.dtun;f*=t*PI*2.; \n f=exp(-bt*i.fo)*(1.0-exp(-bt*i.att))*Sin(f+Cos(bt*i.vibe*PI/8.+i.vphas*PI/2.)*Sin(f*i.phas))*(1.0-bt*0.125); \n n+=t;return vec2(f*Sin(n),f*Cos(n)); \n} \nvec2 mainSound( in int samp,float time){//att,fo,vibe,vphs,phs,dtun\n instr epiano=instr(20.0,0.05,1.5,0.1,0.505,0.001);//silly fm synth instruments \n instr sitar=instr(100.0,0.25,4.0,0.0,0.2525,0.0025); \n instr bassdrum=instr(500.0,1.0,4.0,0.75,1.0,0.0125); \n instr stick=instr(100.0,30.0,10.5,0.0,2.3131,1000.0); \n instr pluckbass=instr(500.0,2.0,1.5,0.0,0.25,0.005); \n instr bass=instr(20.0,0.2,1.5,0.0,0.2525,0.005); \n float tim=time*bps,b0,b1,b2,t0,t1,t2; \n vec2 a=vec2(0);//accumulator \n for(float i=0.;i<8.;i+=1.){//go back 8 beats and add note tails \n   b0=floor(tim);b1=floor(tim*0.5);b2=floor(tim*0.25); \n   vec2 n2=nofs(b2*0.125)+nofs(b2*0.5)+nofs(b2);//build notes on top of notes like fbm \n   vec2 n1=n2+nofs(b1),n0=n1+nofs(b0); \n   t0=fract(tim)+i; \n   a+=I(n0.x+72.0,time,t0,sitar)*n0.y*0.25;\n   if(mod(i,3.)<1.)a+=I(n0.x+93.0,time+Sin(t0*272.0),t0,stick)*n0.y*0.3;  \n   if(mod(i,2.)<1.){//notes that play every 2 beats \n     t1=fract(tim*0.5)*2.0+i; \n     a+=I(n1.x+56.0,time,t1,epiano)*n1.y; \n     a+=I(n1.x+60.0,time,t1,epiano)*n1.y; \n     a+=I(n1.x+63.0,time,t1,pluckbass)*n1.y;\n     if(mod(i,4.)<1.){//every 4 \n       t2=fract(tim*0.25)*4.0+i;\n       \n       a+=I(n2.x+44.0,time,t2,bass)*n2.y*4.0; \n       a+=I(n2.x+24.0,time+0.008*sin(t2*15.0),t2,bassdrum)*n2.y*4.0; \n     } \n   } \n   tim-=1.;//go back in time to find old notes still decaying \n } \n return clamp(a/24.0,-1.,1.); \n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslfzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 47, 66, 100, 266], [267, 267, 290, 290, 320], [321, 321, 340, 340, 366], [367, 367, 387, 387, 553], [592, 592, 610, 610, 1298], [1299, 1299, 1325, 1368, 1710], [1722, 1722, 1748, 1748, 1823], [1825, 1825, 1854, 1854, 2891], [2892, 2892, 2913, 2913, 3011], [3012, 3012, 3031, 3031, 3190], [3191, 3191, 3248, 3248, 3596]], "test": "untested"}
{"id": "tslfzM", "name": "Even the Party...", "author": "eiffie", "description": "Even the Party Box can't harsh my mellow.", "tags": ["annoying"], "likes": 13, "viewed": 567, "published": 3, "date": "1587948103", "time_retrieved": "2024-07-30T21:10:20.215483", "image_code": "//Even the Party Box can't harsh my mellow - by eiffie\nfloat randi(float n){return mod(floor(iTime*10.0),n);}\nfloat spow(float a, float p){return sign(a)*pow(abs(a),p);}\nvec3 mcol=vec3(0.0),glw=vec3(0.0);\nfloat MD=11.,LGT=2.;\nfloat DE(vec3 p0){\n  vec4 p=vec4(p0,1.0);\n  float d=10.0,id=0.;\n  p=abs(p);\n  if(p.x>p.y)p.xy=p.yx;\n  for(int n=0;n<5;n++){\n    id+=(sign(p.x)+sign(p.z))*p.w;\n    p.xz=abs(p.xz)-0.72-0.25*spow(sin(iTime),40.0);\n    float ds=length(p.xyz)-1.0;\n    if(ds<-0.){     \n      if(mod(id,MD)==LGT){glw+=vec3(cos(id),sin(id),sin(id+1.))*0.05;d=min(d,ds+1.0)/p.w;}\n    }\n    d=min(d,max(ds,-min(length(p.xy)-.68,length(p.zy)-.68))/p.w);\n    p.y-=1.0;\n    p*=2.0;\n    if(n==2 && mcol.x>0.0)mcol+=vec3(0.5)+p.xyz/p.w;\n  }\n  return d;\n}\nvec3 normal(vec3 p, float d){//from dr2\n  vec2 e=vec2(d,-d);vec4 v=vec4(DE(p+e.xxx),DE(p+e.xyy),DE(p+e.yxy),DE(p+e.yyx));\n  return normalize(2.*v.yzw+vec3(v.x-v.y-v.z-v.w));\n}\nvec3 sky(vec3 rd, vec3 L){\n  float d=0.1*dot(rd,L)+0.1;\n  return vec3(d);\n}\nfloat rnd;\nvoid randomize(in vec2 p){rnd=fract(float(iTime)+sin(dot(p,vec2(13.3145,117.7391)))*42317.7654321);}\n\nfloat ShadAO(in vec3 ro, in vec3 rd){\n float t=0.01*rnd,s=1.0,d,mn=0.01;\n for(int i=0;i<12;i++){\n  d=max(DE(ro+rd*t)*1.5,mn);\n  s=min(s,d/t+t*0.5);\n  t+=d;\n }\n return s;\n}\nvec3 scene(vec3 ro, vec3 rd){\n  float t=DE(ro)*rnd,d,px=1.0/iResolution.x;\n  for(int i=0;i<99;i++){\n    t+=d=DE(ro+rd*t);\n    if(t>10.0 || d<px*t)break;\n  }\n  vec3 L=normalize(vec3(0.4,0.025,0.5));\n  vec3 col=sky(rd,L),sgl=glw;\n  if(d<px*t*5.0){\n    mcol=vec3(0.001);\n    vec3 so=ro+rd*t;\n    vec3 N=normal(so,d);\n    vec3 scol=mcol*0.25;\n    float dif=0.5+0.5*dot(N,L);\n    float vis=clamp(dot(N,-rd),0.05,1.0);\n    float fr=pow(1.-vis,5.0);\n    float shad=ShadAO(so,L);\n    col=(scol*dif+fr*sky(reflect(rd,N),L))*shad;\n  }\n  col+=sgl;\n  return col;\n}\nmat3 lookat(vec3 fw){vec3 up=vec3(0.0,1.0,0.0),rt=-normalize(cross(fw,up));return mat3(rt,normalize(cross(rt,fw)),fw);}\nvec3 path(float t){t=t*.5;\n  return vec3(sin(t*1.1)*1.5,sin(t*.3)*1.5,cos(t)*3.0); \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n randomize(fragCoord);\n vec3 ro=path(iTime),fw=normalize(path(iTime+0.1)*.75-ro);\n vec3 rd=lookat(fw)*normalize(vec3((iResolution.xy-2.0*fragCoord)/iResolution.y,1.0));\n MD=randi(20.)+2.0;LGT=randi(MD);\n fragColor=vec4(scene(ro,rd),1.0);\n}", "image_inputs": [], "sound_code": "#define bps 8.0 \nfloat rnd(float t){return fract(sin(mod(t,32.123)*32.123)*41.123);} \nvec2 nofs(float n){//the song's \"random\" ring \n  float r=0.5+0.5*rnd(floor(n));//random volume as well \n  n=mod(n,8.0); \n  if(n<1.0)n= 0.0; \n  else if(n<2.0)n= 0.0; \n  else if(n<3.0)n= 0.0; \n  else if(n<4.0)n= 2.0; \n  else if(n<5.0)n= 2.0; \n  else if(n<6.0)n= 5.0; \n  else if(n<7.0)n= 4.0; \n  else n=2.0;\n  return vec2(n,r); \n} \nfloat scale(float note){//throws out dissonant tones \n float n2=mod(note,12.); \n //if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//major \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//minor \n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100;//pentatonic minor \n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100.;//blues  \n //if((n2==1.)||(n2==2.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//country \n //if((n2==1.)||(n2==4.)||(n2==7.)||(n2==10.))note=-100.;//diminished whole/half \n if((n2==1.)||(n2==3.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//pentatonic major \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//harmonic minor \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//melodic minor ascending \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//whole tone \n //if((n2==2.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//diminished half/whole \n //if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//mixolydian   \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//dorian \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==10.))note=-100.;//lydian   \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian \n //if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian Major \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//locrian \n //if((n2==2.)||(n2==4.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//lydian dominant \n //if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//double harmonic \n //if((n2==2.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.))note=-100.;//enigmatic \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//neapolitan  \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//neapolitan minor \n //if((n2==1.)||(n2==4.)||(n2==5.)||(n2==9.)||(n2==10.))note=-100.;//hungarian minor \n return note; \n} \n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2 \nfloat ntof(float n){return (n>0.0)?440.0 * pow(2.0, (n - 67.0) / 12.0):0.0;} \nconst float PI=3.14159; \nfloat Cos(float a){return cos(mod(a,PI*2.));} \nfloat Sin(float a){return Cos(a+PI/2.);} \nstruct instr{float att,fo,vibe,vphas,phas,dtun;}; \nvec2 I(float n,float t,float bt,instr i){//note,time,bt 0-8,instrument \n float f=ntof(scale(n));if(f<12.)return vec2(0.0);f-=bt*i.dtun;f*=t*PI*2.; \n f=exp(-bt*i.fo)*(1.0-exp(-bt*i.att))*Sin(f+Cos(bt*i.vibe*PI/8.+i.vphas*PI/2.)*Sin(f*i.phas))*(1.0-bt*0.125); \n n+=t;return vec2(f*Sin(n),f*Cos(n));\n} \nvec2 mainSound( in int samp,float time){//att,fo,vibe,vphs,phs,dtun\n instr epiano=instr(20.0,0.05,1.5,0.1,0.505,0.001);//silly fm synth instruments \n instr sitar=instr(30.0,0.1,4.0,0.0,0.2525,0.0025); \n instr bassdrum=instr(500.0,1.0,4.0,0.76,1.0,0.5); \n instr stick=instr(100.0,30.0,10.5,0.0,2.3131,1000.0); \n instr pluckbass=instr(500.0,2.0,1.5,0.0,0.125,0.005); \n instr bass=instr(20.0,0.2,2.0,0.0,0.5,0.005); \n float tim=time*bps,b0,b1,b2,t0,t1,t2; \n vec2 a=vec2(0.0);//accumulator \n for(float i=0.;i<8.;i+=1.){//go back 8 beats and add note tails \n   b0=floor(tim);b1=floor(tim*0.5);b2=floor(tim*0.25); \n   vec2 n2=nofs(b2*0.125)+nofs(b2*0.5)+nofs(b2);//build notes on top of notes like fbm \n   vec2 n1=n2+nofs(b1),n0=n1+nofs(b0); \n   t0=fract(tim)+i; \n   a+=I(n0.x+60.0,time,t0,sitar)*n0.y;\n   if(mod(i,1.)<1.)a+=I(n0.x+93.0,time+Sin(t0*272.0),t0,stick)*n0.y*0.3;  \n   if(mod(i,2.)<1.){//notes that play every 2 beats \n     t1=fract(tim*0.5)*2.0+i;\n     a+=I(n1.x+67.0,time,t1,epiano)*n1.y;\n     a+=I(n1.x+65.0,time,t1,epiano)*n1.y; \n     a+=I(n1.x+60.0,time,t1,epiano)*n1.y; \n     a+=I(n1.x+36.0,time,t1,bass)*n1.y*4.0;\n     if(mod(i,4.)<1.){//every 4 \n       t2=fract(tim*0.25)*4.0+i;\n       a+=I(n2.x+36.0,time,t2,bass)*8.0; \n       a+=I(n2.x+32.0,time+0.008*sin(t2*5.0),t2,bassdrum)*12.0;\n       a+=I(n2.x+31.0,time+0.008*sin(t2*6.0),t2,bassdrum)*12.0;\n     } \n   } \n   tim-=1.;//go back in time to find old notes still decaying \n } \n return clamp(a/32.0,-1.,1.); \n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslfzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 55, 76, 76, 109], [110, 110, 139, 139, 169], [226, 226, 244, 244, 749], [750, 750, 779, 789, 925], [926, 926, 952, 952, 1001], [1013, 1013, 1039, 1039, 1113], [1115, 1115, 1152, 1152, 1286], [1287, 1287, 1316, 1316, 1839], [1840, 1840, 1861, 1861, 1959], [1960, 1960, 1979, 1979, 2045], [2046, 2046, 2103, 2103, 2343]], "test": "untested"}
{"id": "WdlfR7", "name": "Fractal JFA", "author": "wyatt", "description": "Inspired by the rendering algorithm of the video game \"Dreams\"", "tags": ["test"], "likes": 13, "viewed": 479, "published": 3, "date": "1587933985", "time_retrieved": "2024-07-30T21:10:21.017339", "image_code": "Main {\n\tQ = C(U);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texelFetch(iChannel1,ivec2(U),0)\n#define C(U) texelFetch(iChannel2,ivec2(U),0)\n#define D(U) texelFetch(iChannel3,ivec2(U),0)\n\n#define O vec2(R*0.5)\n#define P 0.05\n#define splat(p) (((p).w>0.)?(10.*(p).xy/(1e-4+abs(10.-13.*(p).z))*R.y+0.5*R):vec2(1e9))\n\n#define unpack(i) vec2(mod(i,R.x),i/R.x)\n#define pack(U) (floor((U).x)+floor((U).y)*R.x)\n\n#define Main void mainImage(out vec4 Q, vec2 U) \n\n#define Neighborhood vec4 n = A(U+vec2(0,1)), e = A(U+vec2(1,0)), s = A(U-vec2(0,1)), w = A(U-vec2(1,0));\n\n#define Border if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.) Q.xy*=0.;", "buffer_a_code": "Main {\n    if (U.x>O.x||U.y>O.y) {Q=vec4(0);return;}\n    Q = A(U);\n    Q.xyz += 0.0005*vec3(sin(-8.*Q.z-.1*iTime)+sin(-10.*Q.y+.1*iTime),\n                        cos(8.*Q.x+.134*iTime)+cos(10.*Q.x-.134*iTime),0);\n    Q.xz += 0.0002*vec2(-Q.z,Q.x)/sqrt(length(Q.xz));\n    if (iMouse.z>0.) {\n        Q.xy -= iMouse.xy/R*2.-1.;\n    \t Q.xy += vec2(-Q.y,Q.x)/(1.+10.*sqrt(length(iMouse.xy-splat(Q))));\n        Q.xy += iMouse.xy/R*2.-1.;\n    } else {\n    \t Q.xy += 0.1*vec2(-Q.y,Q.x)/(1.+10.*sqrt(length(0.5*R-splat(Q))));\n    }\n    Q.xyz += 2e-4*(-Q.xyz);\n    if (iFrame<1) Q = vec4(1.7*(U/O-0.5),0,pack(U));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define N 12\nfloat len (vec2 U, vec4 a) {\n\tvec2 v = splat(a);\n    float l = length(v-U);\n    return l*10./(1e-4+abs(10.+11.*(a).z));\n}\nvoid Y (inout vec4 Q, vec2 U, vec4 n) {\n\tfloat l = len(U,(A(n.xy))),\n          ll = len(U,(A(Q.xy)));\n    if (l<ll) Q.xy = n.xy;\n}\nvoid X (inout vec4 Q, vec2 U, vec4 n) {\n\tfloat l = len(U,(A(n.zw))),\n          ll = len(U,(A(Q.zw)));\n    if (l<ll) Q.zw = n.zw;\n}\nMain {\n\tQ = B(U).xyxy;\n    if (iFrame%N==0) Q.xy = floor(mod(U,O));\n    else {\n        float k = exp2(float(N-1-(iFrame%N)));\n    \tY(Q,U,B(U+vec2(0,k)));\n    \tY(Q,U,B(U+vec2(k,0)));\n    \tY(Q,U,B(U-vec2(0,k)));\n    \tY(Q,U,B(U-vec2(k,0)));\n    }\n\n\tX(Q,U,B(U+vec2(0,1)));\n    X(Q,U,B(U+vec2(1,0)));\n    X(Q,U,B(U-vec2(0,1)));\n    X(Q,U,B(U-vec2(1,0)));\n    \n    X(Q,U,B(U+vec2(0,4)));\n    X(Q,U,B(U+vec2(4,0)));\n    X(Q,U,B(U-vec2(0,4)));\n    X(Q,U,B(U-vec2(4,0)));\n    X(Q,U,B(U));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\nvec4 color (vec2 U, vec2 r) {\n    vec2 n = D(U+r).zw,\n         p1 = unpack(n.x),\n         p2 = unpack(n.y);\n    vec4 a1 = A(p1),\n         a2 = A(p2),\n         a = vec4((a1 + P*(a2-a1)).xyz,a1.w);\n    vec2 v = splat(a);\n    float fov = 10./(1e-4+abs(10.+13.*(a).z));\n    float l = length(U-v);\n    \n    return (1.-0.25-0.1*(v.x-U.x)*fov)*\n        abs(sin(6.2*a.w/R.x/R.y+vec4(1,2,3,4)))*\n        smoothstep(4.,3.,l*fov)/fov;\n\n}\nMain {\n    Q = vec4(0);\n    for (int x = -1; x <=1; x++)\n    for (int y = -1; y <=1; y++)\n        Q += 0.1*color(U,vec2(x,y));\n    Q = mix(Q,C(U),0.8);\n}\n            ", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "#define N 2\nfloat len (vec2 U, vec2 n) {\n    vec2 p1 = unpack(n.x),\n         p2 = unpack(n.y);\n    vec4 a1 = A(p1),\n         a2 = A(p2),\n         a = vec4((a1 + P*(a2-a1)).xyz,a2.w);\n    vec2 v = splat(a);\n    float l = length(U-v)*10./(1e-4+abs(10.+11.*(a).z));\n    if (l<2.) return -1e3-a.z;\n    return l;\n    \n}\nvoid Y (inout vec4 Q, vec2 U, vec2 r) {\n    vec4 n = D(U+r);\n\tfloat l = len(U,n.xy),\n          ll = len(U,Q.xy);\n    if (l<ll) Q.xy = n.xy;\n}\nvoid X (inout vec4 Q, vec2 U, vec2 r) {\n    vec4 n = D(U+r);\n    float l = len(U,n.zw),\n          ll = len(U,Q.zw);\n    if (l<ll) Q.zw = n.zw;\n}\nMain {\n\tQ = D(U).xyxy;\n    if (iFrame%N==0||true){\n        vec4 b = B(U);\n        Q.xy = vec2(\n        \tpack(floor(b.zw)),\n        \tpack(floor(mod(b.zw-10.*(U-splat(A(b.zw))),O)))\n    \t);\n    } else {\n        float k = exp2(float(N-1-(iFrame%N)));\n    \tY(Q,U,vec2(0,k));\n    \tY(Q,U,vec2(k,0));\n    \tY(Q,U,vec2(0,k));\n    \tY(Q,U,vec2(k,0));\n    }\n\tX(Q,U,vec2(0,1));\n    X(Q,U,vec2(1,0));\n    X(Q,U,vec2(0,1));\n    X(Q,U,vec2(1,0));\n    \n\tX(Q,U,vec2(1,1));\n    X(Q,U,vec2(1,-1));\n    X(Q,U,vec2(-1,1));\n    X(Q,U,vec2(-1,-1));\n    \n    X(Q,U,vec2(0));\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlfR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WssfR7", "name": "Cubething", "author": "donnerbrenn", "description": "Just a morphing cube with some modifiers applied and simple reflections. Created while learning Raymarching.", "tags": ["raymarching", "cube"], "likes": 2, "viewed": 360, "published": 3, "date": "1587930876", "time_retrieved": "2024-07-30T21:10:21.760353", "image_code": "float detail=10000.;\nvec2 uv;\nvec3 color;\n\nstruct RR\n{\n      vec3 col;\n      vec3 pos;\n      bool hit;\n};\n\nvec3 rotate(vec3 p,vec3 t)\n{\n      float c=cos(t.x),s=sin(t.x);\n      mat3 m=mat3(vec3(1,0,0),vec3(0,c,-s),vec3(0,s,c));\n\n      c=cos(t.y);s=sin(t.y);\n      m*=mat3(vec3(c,0,s),vec3(0,1,0),vec3(-s,0,c));\n\n      c=cos(t.z);s=sin(t.z);\n      m*=mat3(vec3(c,-s,0),vec3(s,c,0),vec3(0,0,1));\n\n      return m*p;\n}\n\n\nvec4 _min(vec4 a, vec4 b)\n{\n      return a.w<b.w?a:b;\n}\n\nvec4 _max(vec4 a, vec4 b, bool cut)\n{\n      b.w*=cut?-1.:1.;   \n      return a.w<b.w?b:a;\n}\n\nvec4 softmin(vec4 f1, vec4 f2, float val)\n{\n      if(val==.0)\n            return _min (f1,f2);\n      vec4 res;\n      float e = max(val - abs(f1.w - f2.w), 0.0);\n      res=_min(f1, f2);\n      \n      res.w-=e*e*0.25 / val;\n      res.xyz=mix(f1.xyz,f2.xyz,clamp(abs(f1.w-res.w)/abs(f1.w - f2.w),0.,1.));\n      return res;\n}\n\nvec4 sdSphere(vec3 p, float r, vec3 color)\n{\n      return vec4(color,length(p)-r);\n}\n\nvec4 sdRoundBox( vec3 p, vec3 b, float r, vec3 color)\n{\n  vec3 q = abs(p) - b;\n  return vec4(color,length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r);\n}\n\nvec4 sdCross(vec3 p, vec2 s, float r, vec3 color)\n{\n      return _min(_min(sdRoundBox(p,s.xyy,r,color),sdRoundBox(p,s.yxy,r,color)),sdRoundBox(p,s.yyx,r,color));\n}\n\nvec4 map(vec3 p)\n{\n      vec4 ground=sdRoundBox(rotate(p+vec3(0,2.5,0),vec3(1.,0.,0.)),vec3(40,40,.1),.0,vec3(.2,.2,.2));\n      p=rotate(p,vec3(iTime*.5,iTime*.5,.5));\n      vec4 final=sdCross(p,vec2(4.5,.89),.21,vec3(.1,.1,.75));\n      vec4 box=sdRoundBox(p,vec3(1.),.25,vec3(.1,.75,.1));\n      final=_max(box,final, true);\n      final=_min(final,sdRoundBox(p,vec3(.0),.4,vec3(.7,.0,.0)));\n      final=mix(box,final,sin(iTime)*.5+.5);\n      return _min(final,ground);\n}\n\nvec3 normal(vec3 p)\n{\n      vec2 eps=vec2(.005,0.);\n      return normalize(vec3(map(p+eps.xyy).w-map(p-eps.xyy).w,\n                            map(p+eps.yxy).w-map(p-eps.yxy).w,\n                            map(p+eps.yyx).w-map(p-eps.yyx).w));\n}\n\nfloat lightRender(vec3 n,vec3 l, vec3 v, float strength)\n{\n      return ((dot(n,normalize(l))*.5+.5)+pow(max(dot(v,reflect(normalize(l),n)),0.),128.))*strength;\n}\n\nRR march(vec3 ro, vec3 rd, float maxl, float aprox)\n{\n      rd=normalize(rd);\n      RR res;\n      res.pos=ro;\n      res.hit=false;\n      vec4 d;\n      for(float l=.0; l<maxl;)\n      {\n            d=map(res.pos);\n            if(d.w<aprox)\n            {\n                  res.hit=true;\n                  res.col=d.xyz;\n                  break;\n            }\n            res.pos+=rd*d.w;\n            l+=d.w;\n      }\n      return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n      uv=gl_FragCoord.xy/vec2(iResolution.x)-vec2(.5,.3);\n      vec3 ro=vec3(.0,.0,-10.5); \n      vec3 n;\n      vec3 rd=normalize(vec3(uv,1.));\n      float light=.0;\n\n      vec3 l1=vec3(-2.8,5.,-3.0);\n      vec3 l2=vec3(-.3,2.15,-2.25);\n      vec3 l3=vec3(-4.2,1.5,-2.25);\n\n      RR res=march(ro,rd,40.,1./detail);\n\n      if (res.hit==true)\n      {\n            n=normal(res.pos);\n            light=lightRender(n,l1,rd,.4);\n            light+=lightRender(n,l2,rd,.350);\n            light+=lightRender(n,l3,rd,.125);\n\n            color=res.col*light;\n            if(res.hit)\n            {\n                  res.pos-=rd*.001;\n                  vec3 nrd=reflect(rd,n);\n                  RR reflection=march(res.pos,nrd,20.,3./detail);\n                  n=normal(reflection.pos);\n                  light=lightRender(n,l1,nrd,.4);\n                  light+=lightRender(n,l2,nrd,.350);\n                  light+=lightRender(n,l3,nrd,.125);\n                  reflection.col*=light;\n\n                  color=mix(color, reflection.col,.125);\n\n                  RR shadow=march(res.pos,l1-res.pos,20.,1./detail);\n                  if(shadow.hit)\n                        color*=.5;\n            }\n      }\n    color*=color;\n    color = pow (color,vec3(1.0 / 2.2)); // gamma correction\n   \n    fragColor=vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WssfR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 135, 135, 414], [417, 417, 444, 444, 472], [474, 474, 511, 511, 565], [567, 567, 610, 610, 887], [889, 889, 933, 933, 973], [975, 975, 1030, 1030, 1133], [1135, 1135, 1186, 1186, 1298], [1300, 1300, 1318, 1318, 1770], [1772, 1772, 1793, 1793, 2016], [2018, 2018, 2076, 2076, 2180], [2182, 2182, 2235, 2235, 2614], [2616, 2616, 2673, 2673, 3977]], "test": "untested"}
{"id": "wdffR7", "name": "Two Orbiting Neon Pulsars v2", "author": "izutionix", "description": "v1: [url]https://www.shadertoy.com/view/Wty3zz[/url]", "tags": ["orbit", "pulsars"], "likes": 6, "viewed": 390, "published": 3, "date": "1587911891", "time_retrieved": "2024-07-30T21:10:22.513339", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 col = 3.*texture(iChannel0, uv); // /float(iFrame+1);\n    col = vec4(1.)-exp(-col);\n    fragColor = col*col;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define pi acos(-1.)\n\nfloat DistLine(vec3 ro, vec3 rd, vec3 p) {\n\treturn length(cross(p-ro, rd))/length(rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 ro = vec3(0., .5, -2.); //vec3(0., (2.*iMouse.y-iResolution.y)/iResolution.y, -2.);\n    vec3 rd = vec3(uv.x, uv.y, 0.)-ro;\n    \n    float t = iTime*2.;\n    vec3 p =.5*vec3(sin(t), 0., .5+cos(t));\n    vec3 q =.5*vec3(sin(t+pi), 0., .5+cos(t+pi));\n    float d = DistLine(ro, rd, p);\n    float e = DistLine(ro, rd, q);\n    \n    d = pow(.05/(d+0.), 1.);\n    e = pow(.05/(e+0.), 1.);\n    \n    vec4 new = vec4(d*vec3(.8,.3,1.)+e*vec3(.3,.8,1.),1.);\n    vec4 old = texture(iChannel0, fragCoord.xy / iResolution.xy);\n\n    fragColor = mix(old,new,.1); //old+new;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdffR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 219]], "test": "untested"}
{"id": "wdSyzd", "name": "Wave circles", "author": "sheepmaster", "description": "https://markd87.github.io/posts/2016/05/06/wave-circles.html", "tags": ["2d", "wave", "circle", "transversewave"], "likes": 7, "viewed": 430, "published": 3, "date": "1587905202", "time_retrieved": "2024-07-30T21:10:23.249371", "image_code": "const float PERIOD_S = 1.7;\n\nconst float TILE_WIDTH = 36.;\n\nconst float DOT_RADIUS = 8.;\nconst float CIRCLE_RADIUS = 0.8 * TILE_WIDTH;\nconst float CIRCLE_LINE_WIDTH = 3.;\n\nconst float TAU = 8. * atan(1.);\n\nconst vec2 k = vec2(TAU / 7., - TAU / 7.);\n\nfloat disk(vec2 uv, vec2 center, float radiusPx, float scale) {\n    return smoothstep((radiusPx - .5) * scale, (radiusPx + .5) * scale, length(uv - center));\n}\n\nfloat circle(vec2 uv, vec2 center, float radius, float lineWidthPx, float scale) {\n    return smoothstep(0.0, lineWidthPx * scale, abs(length(uv - center) - radius));\n}\n\nfloat circleAndDot(vec2 ij, vec2 uv, float scale) {\n\tfloat circle = circle(uv, vec2(0.), CIRCLE_RADIUS * scale, CIRCLE_LINE_WIDTH, scale);\n\n    float theta = iTime / PERIOD_S * TAU + dot(ij, k);\n    vec2 pointPos = CIRCLE_RADIUS * scale * vec2(sin(theta), cos(theta));\n    float point = disk(uv, pointPos, DOT_RADIUS, scale);\n\n    return min(circle, point);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float scale = 1. / TILE_WIDTH;\n    vec2 fragCoordScaled = fragCoord * scale;\n\n    vec2 ij = vec2(floor(fragCoordScaled));\n\tvec2 uv = 2. * fragCoordScaled - 2. * ij - 1.;\n    \n    vec2 ijShifted = vec2(floor(fragCoordScaled + 0.5) - 0.5);\n\tvec2 uvShifted = 2. * fragCoordScaled - 2. * ijShifted - 1.;\n\n\tfragColor = vec4(vec3(1. - min(circleAndDot(ij, uv, scale), circleAndDot(ijShifted, uvShifted, scale))), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSyzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[250, 250, 313, 313, 409], [411, 411, 493, 493, 579], [581, 581, 632, 632, 940], [942, 942, 997, 997, 1415]], "test": "untested"}
{"id": "tdXfzM", "name": "Intense M1", "author": "yasuo", "description": "https://www.pinkbike.com/news/the-history-of-intense-m-bikes.html", "tags": ["raymarching", "mountainbike"], "likes": 4, "viewed": 341, "published": 3, "date": "1587904293", "time_retrieved": "2024-07-30T21:10:24.189857", "image_code": "// All the distance functions from:https://iquilezles.org/articles/distfunctions\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define PI 3.141592653589793\n#define USE_MOUSE 0\n#define MAX_STEPS 126\n#define MAX_DIST 30.\n#define SURF_DIST .002\n#define framethickness 0.1\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    return (val1.w < val2.w)?val1:val2;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// https://www.shadertoy.com/view/wdGXzK\n// http://mercury.sexy/hg_sdf/\nvec2 pModPolar(inout vec2 p, float repetitions, float fix) {\n    float angle = 2.0*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.*fix;\n    p = vec2(cos(a), sin(a))*r;\n\n    return p;\n}\n\nfloat frameDist1(vec3 p) {\n    float size = 1.5;\n    float thickness = framethickness;\n    vec4 a1 = vec4(-0.6,size,0.0,0.0); // btm\n    float p1 = dot(p,a1.xyz) + a1.w;\n    \n    vec4 a2 = vec4(0.0,-size,0.0,1.0); // top\n    float p2 = dot(p,a2.xyz) + a2.w;\n        \n    vec4 a3 = vec4(size,2.0,0.0,0.8); // right\n    float p3 = dot(p,a3.xyz) + a3.w;\n            \n    vec4 a4 = vec4(-size,0.0,0.0,0.8); // left\n    float p4 = dot(p,a4.xyz) + a4.w;\n                \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    float p5 = dot(p,a5.xyz) + a5.w;\n                    \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    float p6 = dot(p,a6.xyz) + a6.w;\n\n    float d = max(-p1,max(-p2,max(-p3,max(-p4,max(-p5,-p6)))));\n    return d;\n}\n\nfloat frameDist1_2(vec3 p) {\n    float size = 3.0;\n    float thickness = framethickness;\n    vec4 a1 = vec4(-1.2,size,0.0,0.0); // btm\n    float p1 = dot(p,a1.xyz) + a1.w;\n    \n    vec4 a2 = vec4(0.0,-size,0.0,1.0); // top\n    float p2 = dot(p,a2.xyz) + a2.w;\n        \n    vec4 a3 = vec4(size,2.0,0.0,0.8); // right\n    float p3 = dot(p,a3.xyz) + a3.w;\n            \n    vec4 a4 = vec4(-size,0.0,0.0,0.8); // left\n    float p4 = dot(p,a4.xyz) + a4.w;\n                \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    float p5 = dot(p,a5.xyz) + a5.w;\n                    \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    float p6 = dot(p,a6.xyz) + a6.w;\n\n    float d = max(-p1,max(-p2,max(-p3,max(-p4,max(-p5,-p6)))));\n    return d;\n}\n\nfloat frameDist2(vec3 p) {\n    float size = 1.5;\n    float thickness = framethickness;\n    vec4 a1 = vec4(-1.0,size+1.0,0.0,0.0); // btm\n    float p1 = dot(p,a1.xyz) + a1.w;\n    \n    vec4 a2 = vec4(1.0,-size-1.0,0.0,0.8); // top\n    float p2 = dot(p,a2.xyz) + a2.w;\n        \n    vec4 a3 = vec4(size,0.0,0.0,1.0); // right\n    float p3 = dot(p,a3.xyz) + a3.w;\n            \n    vec4 a4 = vec4(-size,0.0,0.0,1.0); // left\n    float p4 = dot(p,a4.xyz) + a4.w;\n                \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    float p5 = dot(p,a5.xyz) + a5.w;\n                    \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    float p6 = dot(p,a6.xyz) + a6.w;\n\n    float d = max(-p1,max(-p2,max(-p3,max(-p4,max(-p5,-p6)))));\n    return d;\n}\n\nfloat frameDist3(vec3 p) {\n    float size = 1.5;\n    float thickness = framethickness;\n    vec4 a1 = vec4(1.5,size+1.0,0.0,0.0); // btm\n    float p1 = dot(p,a1.xyz) + a1.w;\n    \n    vec4 a2 = vec4(-1.5,-size-1.0,0.0,1.0); // top\n    float p2 = dot(p,a2.xyz) + a2.w;\n        \n    vec4 a3 = vec4(size,0.0,0.0,0.7); // right\n    float p3 = dot(p,a3.xyz) + a3.w;\n            \n    vec4 a4 = vec4(-size,0.0,0.0,0.7); // left\n    float p4 = dot(p,a4.xyz) + a4.w;\n                \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    float p5 = dot(p,a5.xyz) + a5.w;\n                    \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    float p6 = dot(p,a6.xyz) + a6.w;\n\n    float d = max(-p1,max(-p2,max(-p3,max(-p4,max(-p5,-p6)))));\n    return d;\n}\n\nfloat frameDist4(vec3 p) {\n    float size = 1.5;\n    float thickness = framethickness;\n    vec4 a1 = vec4(0.0,size+1.0,0.0,0.0); // btm\n    float p1 = dot(p,a1.xyz) + a1.w;\n    \n    vec4 a2 = vec4(0.0,-size-1.0,0.0,1.0); // top\n    float p2 = dot(p,a2.xyz) + a2.w;\n        \n    vec4 a3 = vec4(size,0.0,0.0,0.2); // right\n    float p3 = dot(p,a3.xyz) + a3.w;\n            \n    vec4 a4 = vec4(-size,0.0,0.0,0.2); // left\n    float p4 = dot(p,a4.xyz) + a4.w;\n                \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    float p5 = dot(p,a5.xyz) + a5.w;\n                    \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    float p6 = dot(p,a6.xyz) + a6.w;\n\n    float d = max(-p1,max(-p2,max(-p3,max(-p4,max(-p5,-p6)))));\n    return d;\n}\n\nfloat frameDist5(vec3 p) {\n    float size = 1.5;\n    float thickness = framethickness;\n    vec4 a1 = vec4(-3.2,size+1.0,0.0,0.0); // btm\n    float p1 = dot(p,a1.xyz) + a1.w;\n    \n    vec4 a2 = vec4(3.2,-size-1.0,0.0,1.2); // top\n    float p2 = dot(p,a2.xyz) + a2.w;\n        \n    vec4 a3 = vec4(size,0.0,0.0,0.44); // right\n    float p3 = dot(p,a3.xyz) + a3.w;\n            \n    vec4 a4 = vec4(-size,0.0,0.0,0.44); // left\n    float p4 = dot(p,a4.xyz) + a4.w;\n                \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    float p5 = dot(p,a5.xyz) + a5.w;\n                    \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    float p6 = dot(p,a6.xyz) + a6.w;\n\n    float d = max(-p1,max(-p2,max(-p3,max(-p4,max(-p5,-p6)))));\n    return d;\n}\n\nfloat frameDist6(vec3 p) {\n    float size = 1.5;\n    float thickness = framethickness*0.5;\n    vec4 a1 = vec4(-0.5,size+1.0,0.0,0.0); // btm\n    float p1 = dot(p,a1.xyz) + a1.w;\n    \n    vec4 a2 = vec4(0.5,-size-1.0,0.0,0.5); // top\n    float p2 = dot(p,a2.xyz) + a2.w;\n        \n    vec4 a3 = vec4(size,0.0,0.0,1.2); // right\n    float p3 = dot(p,a3.xyz) + a3.w;\n            \n    vec4 a4 = vec4(-size,0.0,0.0,1.2); // left\n    float p4 = dot(p,a4.xyz) + a4.w;\n                \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    float p5 = dot(p,a5.xyz) + a5.w;\n                    \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    float p6 = dot(p,a6.xyz) + a6.w;\n\n    float d = max(-p1,max(-p2,max(-p3,max(-p4,max(-p5,-p6)))));\n    return d;\n}\n\nfloat frameDist7(vec3 p) {\n    float size = 1.5;\n    float thickness = framethickness*0.5;\n    vec4 a1 = vec4(1.8,size+1.0,0.0,0.0); // btm\n    float p1 = dot(p,a1.xyz) + a1.w;\n    \n    vec4 a2 = vec4(-1.8,-size-1.0,0.0,0.5); // top\n    float p2 = dot(p,a2.xyz) + a2.w;\n        \n    vec4 a3 = vec4(size,0.0,0.0,0.4); // right\n    float p3 = dot(p,a3.xyz) + a3.w;\n            \n    vec4 a4 = vec4(-size,0.0,0.0,0.4); // left\n    float p4 = dot(p,a4.xyz) + a4.w;\n                \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    float p5 = dot(p,a5.xyz) + a5.w;\n                    \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    float p6 = dot(p,a6.xyz) + a6.w;\n\n    float d = max(-p1,max(-p2,max(-p3,max(-p4,max(-p5,-p6)))));\n    return d;\n}\n\nfloat frameDist8(vec3 p) {\n    float size = 1.5;\n    float thickness = framethickness*0.5;\n    vec4 a1 = vec4(-1.8,size+1.0,0.0,0.0); // btm\n    float p1 = dot(p,a1.xyz) + a1.w;\n    \n    vec4 a2 = vec4(1.8,-size-1.0,0.0,0.5); // top\n    float p2 = dot(p,a2.xyz) + a2.w;\n        \n    vec4 a3 = vec4(size,0.0,0.0,0.82); // right\n    float p3 = dot(p,a3.xyz) + a3.w;\n            \n    vec4 a4 = vec4(-size,0.0,0.0,0.82); // left\n    float p4 = dot(p,a4.xyz) + a4.w;\n                \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    float p5 = dot(p,a5.xyz) + a5.w;\n                    \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    float p6 = dot(p,a6.xyz) + a6.w;\n\n    float d = max(-p1,max(-p2,max(-p3,max(-p4,max(-p5,-p6)))));\n    return d;\n}\n\nfloat frameDist9(vec3 p) {\n    float size = 1.5;\n    float thickness = framethickness*2.0;\n    vec4 a1 = vec4(1.8,size+1.0,0.0,0.0); // btm\n    float p1 = dot(p,a1.xyz) + a1.w;\n    \n    vec4 a2 = vec4(-1.8,-size-1.0,0.0,0.5); // top\n    float p2 = dot(p,a2.xyz) + a2.w;\n        \n    vec4 a3 = vec4(size,0.0,0.0,0.2); // right\n    float p3 = dot(p,a3.xyz) + a3.w;\n            \n    vec4 a4 = vec4(-size,0.0,0.0,0.2); // left\n    float p4 = dot(p,a4.xyz) + a4.w;\n                \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    float p5 = dot(p,a5.xyz) + a5.w;\n                    \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    float p6 = dot(p,a6.xyz) + a6.w;\n\n    float d = max(-p1,max(-p2,max(-p3,max(-p4,max(-p5,-p6)))));\n    return d;\n}\n\nfloat spokeDist(vec3 p) {\n    float size = 1.5;\n    float thickness = framethickness*0.2;\n    vec4 a1 = vec4(0.0,size+1.0,0.0,0.8); // btm\n    float p1 = dot(p,a1.xyz) + a1.w;\n    \n    vec4 a2 = vec4(0.0,-size-1.0,0.0,0.8); // top\n    float p2 = dot(p,a2.xyz) + a2.w;\n        \n    vec4 a3 = vec4(size,0.0,0.0,0.01); // right\n    float p3 = dot(p,a3.xyz) + a3.w;\n            \n    vec4 a4 = vec4(-size,0.0,0.0,0.01); // left\n    float p4 = dot(p,a4.xyz) + a4.w;\n                \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    float p5 = dot(p,a5.xyz) + a5.w;\n                    \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    float p6 = dot(p,a6.xyz) + a6.w;\n\n    float d = max(-p1,max(-p2,max(-p3,max(-p4,max(-p5,-p6)))));\n    return d;\n}\n\nfloat frameFrontDist(vec3 p) {\n    float f1 = frameDist1(p-vec3(0.0,0.1,0.0));\n    float f2 = frameDist2(p-vec3(-1.,-0.3,0.0));\n    float f3 = frameDist3(p-vec3(-1.1,0.43,0.0));\n    float f4 = frameDist4(p-vec3(-1.25,0.3,0.0));\n    float f5 = frameDist5(p-vec3(-1.37,-0.2,0.0));\n    \n    float f6 = sdCappedCylinder(p-vec3(0.6,0.54,0.0),0.08,0.3);\n    float f7 = sdCappedCylinder(p-vec3(-1.65,1.0,0.0),0.08,0.4);\n    \n    p.z = abs(p.z);\n    p.z-=0.05;\n    float f8 = frameDist1_2(p-vec3(0.1,0.28,0.0));\n    \n    float d = min(f1,min(f2,min(f3,min(f4,min(f5,min(f6,f7))))));\n    d = max(-f8,d);\n    return d*0.6;\n}\n\nfloat frameBackDist(vec3 p) {\n    vec3 prevP = p;\n    p.z = abs(p.z);\n    p *= matRotateY(radians(5.0));\n    p.z-=0.2;\n    float f1 = frameDist6(p-vec3(0.25,-0.9,0.0));\n    float f2 = frameDist7(p-vec3(0.8,-0.4,0.0));\n    float f3 = frameDist8(p-vec3(-0.02,-0.6,0.0));\n    p = prevP;\n    float f4 = frameDist9(p-vec3(0.8,-0.4,0.0));\n    \n    vec3 p2 = p-vec3(-0.4,-0.8,0.0);\n    p2*=matRotateX(radians(90.0));\n    float f5 = sdCappedCylinder(p2,0.07,0.2);\n    \n    float d = min(f1,min(f2,min(f3,min(f4,f5))));\n    return d*0.6;\n}\n\nfloat rearSuspensionDist(vec3 p) {\n    vec3 prevP = p;\n    p.y = mod(p.y,0.1)-0.05;\n    vec3 fp1 = p;\n    float f1 = sdTorus(fp1,vec2(0.07,0.03));\n    p = prevP;\n    fp1 = p;\n    float mask = sdBox(fp1,vec3(0.1,0.22,0.1));\n    float d3 = max(mask,f1);\n    return d3*0.6;\n}\n\nvec4 frontSuspension(vec3 p) {\n    vec3 prevP = p;\n    p.x -= 1.1;\n    p.y -= 1.2;\n    p.z = abs(p.z);\n    p.z -=0.19;\n    vec3 sp1 = p-vec3(0.0,0.0,0.0);\n    float s1 = sdCappedCylinder(sp1,0.08,0.5);\n    float d = s1;\n    vec4 res = vec4(vec3(0.7,0.0,0.0),d*0.6);\n    \n    vec3 sp2 = p-vec3(0.0,0.9,0.0);\n    float s2 = sdCappedCylinder(sp2,0.05,0.53);\n    d = s2;\n    vec4 res2 = vec4(vec3(0.9,0.9,0.6),d*0.6);\n    \n    p = prevP;\n    vec3 sp3 = p-vec3(1.1,0.8,0.0);\n    sp3*=matRotateX(radians(90.0));\n    float s3 = sdCappedCylinder(sp3,0.07,0.12);\n    d = s3;\n    vec4 res3 = vec4(vec3(0.8),d*0.3);\n    \n    return combine(res,combine(res2,res3));\n}\n\nvec4 stemandhandle(vec3 p) {\n    vec3 prevP = p;\n    vec3 sp1 = p-vec3(0.31,2.8,0.0);\n    float s1 = sdBox(sp1,vec3(0.16,0.08,0.12));\n    float d = s1;\n    vec4 res = vec4(vec3(0.8),d*0.6);\n    \n    vec3 sp2 = p-vec3(0.37,2.8,0.0);\n    \n    p.z = abs(p.z);\n    p.z -=0.4;\n    vec3 sp3 = p-vec3(0.28,2.9,0.0);\n    sp2*=matRotateX(radians(90.0));\n    sp3*=matRotateX(radians(-50.0))*matRotateZ(radians(-30.0));\n    float s2 = sdCappedCylinder(sp2,0.04,0.3);\n    float s3 = sdCappedCylinder(sp3,0.04,0.2);\n    d = min(s2,s3);\n    vec4 res2 = vec4(vec3(0.3),d*0.6);\n    \n    return combine(res,res2);\n}\n\nvec4 tyre(vec3 p) {\n    p.x = abs(p.x);\n    p.x -=0.95;\n    vec3 prevP = p;\n    p-=vec3(0.95,1.1,0.0);\n    p.yx = pModPolar(p.yx,20.0,1.0);\n    p.y -= 0.4;\n    \n    vec3 tp1 = p-vec3(0.0,0.0,0.0);\n    float t1 = spokeDist(tp1); \n    p = prevP;\n    \n    vec3 tp2 = p-vec3(0.95,1.1,0.0);\n    tp2*=matRotateX(radians(90.0));\n    float t2 = sdTorus(tp2,vec2(0.75,0.03));\n    float d = min(t1,t2);\n    vec4 res = vec4(vec3(0.6),d*0.6);\n    \n    vec3 tp3 = p-vec3(0.95,1.1,0.0);\n    tp3*=matRotateX(radians(90.0));\n    float t3 = sdTorus(tp3,vec2(0.8,0.05));\n    vec4 res2 = vec4(vec3(0.2),t3*0.3);\n    \n    return combine(res,res2);\n}\n\nvec4 saddles(vec3 p) {\n    vec3 prevP = p;\n    vec3 sp1 = p-vec3(-1.85,2.9,0.0);\n    \n    float sc = mix(0.1,3.0,smoothstep(-1.0,1.0,sp1.x));\n    sp1.yz *= sc;\n    sp1.y*= 3.0;\n    sp1.z*= 1.2;\n    float s1 = length(sp1)-0.3;\n    float d = s1;\n    vec4 res = vec4(vec3(0.3),d*0.3);\n    \n    vec3 sp2 = p-vec3(-1.8,2.7,0.0);\n    sp2*=matRotateZ(radians(-15.0));\n    float s2 = sdCappedCylinder(sp2,0.04,0.2);\n    \n    d = s2;\n    vec4 res2 = vec4(vec3(0.8),d*0.3);\n    \n    return combine(res,res2);\n}\n\nvec4 intenseM1(vec3 p){\n    vec3 front = p-vec3(1.5,1.0,0.0);\n    mat3 frot = matRotateZ(radians(-15.0));\n    front *= frot;\n    float d = frameFrontDist(front);\n    vec4 res = vec4(vec3(0.8,0.0,0.0),d*0.5);\n    \n    vec3 back = p-vec3(-1.0,1.0,0.0);\n    d = frameBackDist(back);\n    vec4 res2 = vec4(vec3(0.8),d*0.5);\n    \n    vec3 sus = p-vec3(-0.12,0.9,0.0);\n    sus *= matRotateZ(radians(50.0));\n    d = rearSuspensionDist(sus);\n    vec4 res3 = vec4(vec3(0.8,0.8,0.0),d*0.5);\n    \n    vec3 fsus = p-vec3(1.55,-0.87,0.0);\n    fsus *= frot;\n    vec4 res4 = frontSuspension(fsus);\n    \n    vec3 stem = p-vec3(2.35,-0.75,0.0);\n    stem *= frot;\n    vec4 res5 = stemandhandle(stem);\n    \n    vec3 tyreP = p-vec3(0.5,-0.9,0.0);\n    vec4 res6 = tyre(tyreP);\n    \n    vec3 saddleP = p-vec3(1.3,-0.6,0.0);\n    vec4 res7 = saddles(saddleP);\n    \n    return combine(res,combine(res2,combine(res3,combine(res4,combine(res5,combine(res6,res7))))));\n}\n\nvec4 GetDist(vec3 p) {\n    vec4 res = intenseM1(p-vec3(-0.4,0.0,0.0));\n    return res;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 dO= vec4(0.0,0.0,0.0,1.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.w;\n        vec4 dS = GetDist(p);\n        dO.w += dS.w;\n        dO.xyz = dS.xyz;\n        if(dO.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(2,9,3);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n    \n    float lambert = max(.0, dot( n, l))*0.1;\n    \n    return vec2((lambert+dif),1.0);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    float t = mod(iTime,8000.0);\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 4, -4.5);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-30.0));\n    ro.xz *= Rot(t*.3+1.0);\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,1,0), 1.);\n\n    vec4 d = RayMarch(ro, rd);\n    \n    if(d.w<MAX_DIST) {\n        vec3 p = ro + rd * d.w;\n    \n        vec2 dif = GetLight(p);\n        col = vec3(dif.x)*d.xyz;\n        col *= dif.y;\n        \n    } else {\n        // background\n        col =.84*max(mix(vec3(1.2,1.2,1.1)+(.1-length(uv.xy)/3.),vec3(1),.1),0.);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXfzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[569, 569, 605, 605, 647], [649, 649, 678, 678, 762], [764, 764, 816, 816, 923], [925, 925, 958, 958, 1023], [1025, 1097, 1157, 1157, 1377], [1379, 1379, 1405, 1405, 2126], [2128, 2128, 2156, 2156, 2877], [2879, 2879, 2905, 2905, 3634], [3636, 3636, 3662, 3662, 4391], [4393, 4393, 4419, 4419, 5147], [5149, 5149, 5175, 5175, 5906], [5908, 5908, 5934, 5934, 6667], [6669, 6669, 6695, 6695, 7428], [7430, 7430, 7456, 7456, 8191], [8193, 8193, 8219, 8219, 8952], [8954, 8954, 8979, 8979, 9713], [9715, 9715, 9745, 9745, 10329], [10331, 10331, 10360, 10360, 10861], [10863, 10863, 10897, 10897, 11135], [11137, 11137, 11167, 11167, 11792], [11794, 11794, 11822, 11822, 12392], [12394, 12394, 12413, 12413, 13023], [13025, 13025, 13047, 13047, 13525], [13527, 13527, 13550, 13550, 14468], [14470, 14470, 14492, 14492, 14558], [14560, 14560, 14593, 14593, 14858], [14860, 14860, 14884, 14884, 15085], [15087, 15087, 15110, 15110, 15399], [15401, 15401, 15443, 15443, 15638], [15640, 15640, 15697, 15697, 16460]], "test": "untested"}
{"id": "tsXBzM", "name": "Simple terrain (SS13)", "author": "angelo12", "description": "Thought this looked pretty cool even though it's really simple. :) ", "tags": ["procedural", "3d", "raymarching", "terrain", "shadersundays"], "likes": 12, "viewed": 1337, "published": 3, "date": "1587903759", "time_retrieved": "2024-07-30T21:10:24.939852", "image_code": "#define saturate(val) clamp(val, 0.0, 1.0)\n\n/*\n\tShader Sundays! (13/52) \n\t\"Simple Terrain\"\n\t\n\tI've dabled in terrain raymarching before but never did a deep dive on it.\n\tBeen working on that on and off this week and I'm pretty happy with this one even\n\tthough it's so simple. There's something really cool about looking into depth buffers,\n\tso although I did some experiments with more elaborate shading I thought\n\tthis simple colored depth buffer looked pretty interesting already. \n\n\tHere are some sources that I used for this and other cool shaders worth checking out\n\tanyway :\n\n\thttps://www.shadertoy.com/view/ttcSD8 (Swiss alps)\n\thttps://www.shadertoy.com/view/MdX3Rr (Elevated)\n\thttps://www.shadertoy.com/view/MdlGW7 (Cloudy terrain)\n\thttps://www.shadertoy.com/view/ttc3zr (High quality murmur hashes)\n*/\n\n\n//https://www.shadertoy.com/view/ttc3zr\nuint murmurHash12(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 1 output, 2 inputs\nfloat hash12(vec2 src) {\n    uint h = murmurHash12(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nfloat\nSmoothNoise(vec2 uv)\n{\n    vec2 id = floor(uv);\n    vec2 fr = fract(uv);\n\n    fr = fr*fr*(3.0 - 2.0*fr);\n\n    float bl = hash12(id);\n    float br = hash12(id + vec2(1.0, 0.0));\n    float b  = mix(bl, br, fr.x);\n\n    float tl = hash12(id + vec2(0.0, 1.0));\n    float tr = hash12(id + vec2(1.0, 1.0));\n    float t  = mix(tl, tr, fr.x);\n\n    return mix(b, t, fr.y);\n}\n\nfloat\nValueNoise(vec2 uv, int octaves)\n{\n    float noise;\n    float totalAmplitude;\n    float amplitude = 1.0;\n    float frequency = 1.0;\n\n    for(int i = 0; i < octaves; ++i)\n    {\n        totalAmplitude += amplitude;\n        noise += SmoothNoise(uv * frequency) * amplitude;\n        frequency *= 2.0;\n        amplitude /= 2.0;\n    }\n\n    return noise / totalAmplitude;\n}\n\nmat3\nSetCamera(vec3 eye, vec3 target, float roll)\n{\n    vec3 i, j, k, temp;\n\n    k = normalize(target - eye);\n    temp = normalize(vec3(sin(roll), cos(roll), 0.0));\n    i = normalize(cross(temp, k));\n    j = cross(k, i);\n\n    return mat3(i, j, k);\n}\n\n#define HI_LOD 8\n#define LO_LOD 2\nfloat\nterrain(vec3 p)\n{\n    return p.y - ValueNoise(p.xz, HI_LOD);\n}\n\n// I know I could change MAX_STEPS and remove the weird haze when you get close to the ground\n// but I like it :)\n#define MAX_STEPS 23\n#define MAX_DIST 20.0\n#define MIN_DIST 0.01\nfloat\nintersectTerrain(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n\n    for(int i = 0; i < MAX_STEPS && t < MAX_DIST; ++ i)\n    {\n        float hit = terrain(ro + t*rd);\n\t\t\n        //Some fancy inigo thing I don't fully understand yet\n        //\tif ray is partially in it's still cool?\n        //\twe make the min distance larger when further away?\n        //  Optimization or stylistic thing?\n        if(abs(hit) < MIN_DIST *t)break;\n\n        t += hit;\n    }\n    return t;\n}\n\nvec3\nRender(vec3 ro, vec3 rd)\n{\n    vec3 col;\n\t\n    //Raymarching the terrain\n    float t = intersectTerrain(ro, rd);\n    \n    //Simple shading\n    col += t / 9.80665; // :) \n    col *= vec3(0.78, 0.9, 1.0);\n\n    return saturate(col);\n}\n\n#define INV_GAMMA 0.45454545\n#define ONE(val) (val * 0.5 - 0.5)\nvoid\nmainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //Camera Setup\n    float nearp = 1.0;\n    float roll = 0.0;\n    vec3 ta = vec3(0.0 + iTime, 0.0, 0.0);\n    vec3 ro = ta + vec3(0.0, 2.0 + 1.25*ONE(sin(iTime / 5.0)) , -abs(10.0*sin(iTime / 30.0)));\n    vec2 uv = ((fragCoord) - 0.5*iResolution.xy)/iResolution.y;\n    mat3 cam = SetCamera(ro, ta, roll);\n    vec3 rd = cam * normalize(vec3(uv, nearp));\n\n    vec3 col = Render(ro, rd);\n    \n    //Noise debug\n    //col = vec3(hash12(uv));\n    //col = vec3(SmoothNoise(uv * 20.0));\n    //col = vec3(ValueNoise(uv* 2.0 + iTime, 8));\n\t\n    col = pow(col, vec3(1.0 / (0.65)));\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXBzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[813, 853, 883, 883, 1080], [1082, 1104, 1128, 1128, 1244], [1246, 1246, 1274, 1274, 1616], [1618, 1618, 1658, 1658, 1990], [1992, 1992, 2043, 2043, 2241], [2277, 2277, 2300, 2300, 2345], [2526, 2526, 2568, 2568, 2995], [2997, 2997, 3028, 3028, 3233], [3299, 3299, 3354, 3373, 3961]], "test": "untested"}
{"id": "wdsBz4", "name": "Starry blur ( 544 chars )", "author": "FabriceNeyret2", "description": "Golfing 1227 chars \"Starry blur\" by nimitz. [url]https://shadertoy.com/view/tsXBRH[/url]\ncould it be shorter ? ;-)", "tags": ["blur", "short", "quick", "artistic", "lic", "golf"], "likes": 11, "viewed": 601, "published": 3, "date": "1587896629", "time_retrieved": "2024-07-30T21:10:25.698822", "image_code": "// Golfing 1227 \"Starry blur\" by nimitz. https://shadertoy.com/view/tsXBRH\n\n// --- ( getting obfuscated )\n\n#define R    iResolution.xy//\n#define H(x) fract( 4e5* sin( ceil(x+p) *mat2(R-1.,R*R) ) ) * 2. - 1.//\n#define D    dot( f - n//\nvec2 N( vec2 p ) {     // 2d gradient noise & analytic derivatives\n    vec2  f = fract(p), F = f*f,\n          u = F*f* (6.*F-15.*f+10.),\n          n = vec2(0,1),\n          a = H(), b = H(n.yx), c = H(n), d = H(1.);\n    return a + mat2(b-a,c-a) * u + u.x*u.y * (a-b-c+d) \n             + 30.*  F* (F-f-f+1.)\n                  * (  u.yx * ( D.x,a) - D.yx,b) - D,c) + D.y,d) ) \n                     + vec2( D.yx,b) , D,c) ) \n                     - D.x,a) );\n}\n#define F normalize( N(P+P) + .3* N(P*8.) ).yx// *v(1,-1) makes it divergence-free\nvoid mainImage(out vec4 O, vec2 U) { O-=O;\n    vec2 p = U/R.y, P = p, d = F;\n    for(float i = 0. ; ++i < 16. ; d = ( d + F )/2. )\n        P = p + d*vec2(i,-i)/2e2 * ( sin(iTime)/4.+.6 ),\n        O += texture(iChannel0, P).bgra;\n    O *=  smoothstep(-.25,.9,p.y) /11.;\n} /*\n\n\n\n\n// --- 568 chars\n        \n        #define R iResolution.xy//\n#define H(x) fract( 4e5* sin( (x+i) *mat2(R-1.,R*R) ) ) * 2. - 1.//\nvec2 N( vec2 p ) {\n    vec2  i = ceil(p), f = fract(p), F=f*f,\n          u = F*f* (6.*F-15.*f+10.),\n          n = vec2(0,1),\n          a = H(), b = H(n.yx), c = H(n), d = H(1.);\n    float A = dot(  a, f  ),\n          B = dot(  b, f - n.yx ),\n          C = dot(  c, f - n );\n    return a + mat2(b-a,c-a) *u + u.x*u.y*(a-b-c+d) \n           + 30.*  F* (F-f-f+1.)\n                * ( u.yx*(A-B-C+dot(d,f-1.)) + vec2(B,C) - A );\n}\n#define F(p) normalize( ( N(p+p) + N(p*8.)*.3 ).yx *vec2(1,-1) )//\n#define mainImage(O,U)                            \\\n    vec2 p = U/R.y, d = F(p), P;                  \\\n    for(float i = 0.; i < 15.; i++)               \\\n        P = p + d*i/2e2 * ( sin(iTime)/4.+.6 ),   \\\n        O += texture(iChannel0, P).bgra,          \\\n        d = (d + F(P) )/2.;                       \\\n    O *=  smoothstep(-.25,.9,p.y) /11.           /*\n\n\n\n\n// --- 701 chars\n\nfloat n = 15.;\n#define R iResolution.xy\n\n#define H(x) ( fract( 4e5* sin( (x)*mat2(R-1.,R*R) ) ) * 2. - 1.)\n\nvec2 N( vec2 p )\n{\n    vec2 i = ceil(p), f = fract(p),\n         u = f*f*f*(f*(f*6.-15.)+10.),\n        du = 30.*f*f*(f*(f-2.)+1.),\n         n = vec2(0,1),\n        ga = H( i ),\n        gb = H( i + n.yx ),\n        gc = H( i + n ),\n        gd = H( i + 1. );\n    \n    float va = dot( ga, f  ),\n          vb = dot( gb, f - n.yx ),\n          vc = dot( gc, f - n ),\n          vd = dot( gd, f - 1. );\n    return ga + mat2(gb-ga,gc-ga) *u + u.x*u.y*(ga-gb-gc+gd) + \n           du * ( u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va );\n}\n\n#define F(p) normalize( ( N(p*2.) + N(p*8.)*.3 ).yx *vec2(1,-1) )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 q = U/R,  v = 4.*q*(1.-q),\n         p = U/R.y,\n         d = F(p), P;    \n    O-=O;\n    \n    for(float i = 0.; i < n; i++)\n        P = p + d*i/2e2 * ( sin(iTime)/4.+.6 ),\n        O += textureLod(iChannel0, P,0.).bgra,\n        d = (d + F(P) )/2.;\n    \n    O *=  smoothstep(-.25,.9,q.y) *1.35/n\n\t  * ( pow(v.x*v.y, .15)*.4 + .6 );\n}\n\n/**/   \n", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsBz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[774, 774, 810, 810, 1044]], "test": "untested"}
{"id": "tdXBRM", "name": "On the way to drive home", "author": "esnho", "description": "camera ray, point on a ray, calculate distance between point and ray", "tags": ["learning"], "likes": 4, "viewed": 369, "published": 3, "date": "1587894754", "time_retrieved": "2024-07-30T21:10:26.447819", "image_code": "#define S(a, b, t) smoothstep(a,b,t)\n\n// inspired from https://www.youtube.com/watch?v=eKtsY7hYTPg\n\nstruct ray {\n    vec3 \to, // origin\n    \t\td; // direction\n};\n\n    ray GetRay(vec2 uv, vec3 camPos, vec3 lookAt, float zoom) {\n        ray a;\n        a.o = camPos;\n\n        vec3 forward = normalize(lookAt-camPos);\n        vec3 right = cross(vec3(0,1,0), forward);\n        vec3 up = cross(forward, right);\n        vec3 centerScreen = a.o + forward * zoom;\n        vec3 intersection = centerScreen + uv.x * right + uv.y * up;\n\n        a.d = normalize(intersection-a.o);\n\n        return a;\n    }\n\n// project a ray and calculate which is the closest point\n// on that ray to an input point\nvec3 ClosestPoint(ray r, vec3 p) {\n    return r.o + max(0.0, dot(p-r.o, r.d))*r.d;\n}\n\n// calculate the distance from a point to a ray\n// first finds the closest point of the ray to the point\n// then calculate the distance\nfloat DistRay(ray r, vec3 p) {\n    return length(p - ClosestPoint(r, p));\n}\n\nfloat Bokeh(ray r, vec3 p, float size, float blur) {\n    float d = DistRay(r, p);\n\n    // smoothstep from the center\n    float c = S(size, size*(1.-blur), d);\n    // ring outside the circle, 70% the width of the circle\n    float ring = S(size*.7, size, d);\n    // mix(inColor, outColor, ring)\n    c *= mix(.7, 1., ring);\n    \n    return c;\n}\n\nfloat  hue2rgb(float p, float q, float t){\n\tif(t < 0.) t += 1.;\n\tif(t > 1.) t -= 1.;\n\tif(t < 1./6.) return p + (q - p) * 6. * t;\n\tif(t < 1./2.) return q;\n\tif(t < 2./3.) return p + (q - p) * (2./3. - t) * 6.;\n\treturn p;\n}\n\nvec3 HslToRgb(float h, float s, float l){\n    vec3 rgb = vec3(1.);\n\n    if(s == 0.){\n        return rgb; // achromatic\n    }else{\n        float q = l < 0.5 ? l * (1. + s) : l + s - l * s;\n        float p = 2. * l - q;\n        rgb.r = hue2rgb(p, q, h + 1./3.);\n        rgb.g = hue2rgb(p, q, h);\n        rgb.b = hue2rgb(p, q, h - 1./3.);\n    }\n\n    return rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 0.5;\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv -= .5;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    vec3 camPos = vec3(.0, .0, .0);\n    vec3 lookat = vec3(.0, .0, 1.0);\n    // this is the camera ray :)\n    ray r = GetRay(uv, camPos, lookat, 2.);\n    \n    // draw!\n    vec3 frag = vec3(.0);\n    for (float i = 0.; i < 80.; i++) {\n        // the position is a weird lissajous curve\n        vec3 p = vec3(\n            (sin(time+i)+cos(time+i+0.5))*2.,\n            cos(time + i * cos(time*0.1)),\n            (\n                (sin(time+i)*\n                 sin(time+i+0.5)*15.\n                )+7.)\n        );\n        // choosing the side of color wheel, the number\n        // is used to offset color position\n        float side = fract(i/2.) >= 0.5 ? 0. : 0.5;\n        vec3 color = HslToRgb(\n            \t(i/80.) + sin(time*.4) + side,\n            \t1.2,\n            \t0.6);\n        \n        // the circle size vary\n        float circleSize = (abs(cos(i))+.2)*.15;\n        \n        // blending max\n        frag = max(frag, Bokeh(r, p, circleSize, .1) * color);\n    }\n    \n    // Output to screen\n    fragColor = vec4(1.-frag,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXBRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[166, 166, 225, 225, 591], [593, 684, 718, 718, 768], [770, 906, 936, 936, 981], [983, 983, 1035, 1035, 1324], [1326, 1326, 1368, 1368, 1546], [1548, 1548, 1589, 1589, 1908], [1910, 1910, 1967, 1967, 3128]], "test": "untested"}
{"id": "wdlfz4", "name": "Srinivasa Ramanujan, 1887-1920", "author": "mla", "description": "Ramanujan died exactly 100 years ago today:\n\n[url]https://en.wikipedia.org/wiki/Srinivasa_Ramanujan[/url]\n[url]https://trinitycollegelibrarycambridge.wordpress.com/2020/04/24/remembering-ramanujan/[/url]\n", "tags": ["partition", "1729", "ramanujan"], "likes": 10, "viewed": 410, "published": 3, "date": "1587891653", "time_retrieved": "2024-07-30T21:10:27.183852", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Srinivasa Ramanujan, 22 December 1887 – 26 April 1920.\n//\n// https://en.wikipedia.org/wiki/Srinivasa_Ramanujan\n//\n// Here we have a 12x12x12 cube, total volume 1728, that can be dissected and,\n// with an extra piece, reassembled into a 9x9x9 cube and a 10x10x10 cube,\n// Key 'x' shows the 10x10x10 cube.\n//\n// Some of Ramanujan's more profound work was in the area of partition theory,\n// for example, Ramanujan's Congruences concerning p(n), the number of\n// partitions of integer n (ie. the number of ways of expressing positive n as a\n// sum of positive integers):\n//\n// https://en.wikipedia.org/wiki/Ramanujan%27s_congruences:\n//\n// p(5k+4) = 0 mod 5\n// p(7k+5) = 0 mod 7\n// p(11k+6) = 0 mod 11\n//\n// The first two are nicely illustrated with p(19) = 490 and all 490\n// partitions appear in the background, grouped appropriately. (Key 'b'\n// shows just the background).\n//\n// Matthew Arcus, mla, 26th April 2020\n//\n////////////////////////////////////////////////////////////////////////////////\n\nint AA = 2; // Set to 1 if too slow.\n\nfloat eyedist = 40.0;     // Eye is at (0,0,eyedist);\nvec3 light = normalize(vec3(0,1,3)); // Direction of light\nbool dorotate = true;\n\nfloat PI = 3.1415927; \n\n// Raymarching configuration.\nint maxsteps = 100;\nfloat precis = 1e-3; \n\nint cubesize = 6; // Half width of cube\nfloat dicesize = 0.4; // \nfloat de(vec3 p) {\n  vec3 p0 = abs(p);\n  p = fract(p);\n  p -= 0.5;\n  p = abs(p);\n  float d = -1e8;\n  d = max(d,p.x-dicesize);\n  d = max(d,p.y-dicesize);\n  d = max(d,p.z-dicesize);\n  // Clip to cubesize\n  d = max(d,p0.x-float(cubesize));\n  d = max(d,p0.y-float(cubesize));\n  d = max(d,p0.z-float(cubesize));\n  return d;\n}\n\nvec3 getnormal(vec3 p, vec3 rd) {\n  // Repeat DE calculation, but return normal to closest plane.\n  p = fract(p);\n  p -= 0.5;\n  p = abs(p);\n  float d1, d = -1e8;\n  vec3 n = vec3(0);\n  d1 = p.x-dicesize;\n  if (d1 > d) { d = d1; n = vec3(1,0,0); }\n  d1 = p.y-dicesize;\n  if (d1 > d) { d = d1; n = vec3(0,1,0); }\n  d1 = p.z-dicesize;\n  if (d1 > d) { d = d1; n = vec3(0,0,1); }\n  // Make sure normal points the right way.\n  return dot(n,rd) < 0.0 ? n : -n;\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\n// Rotate according to mouse position\nvec3 transformframe(vec3 p) {\n  if (iMouse.x > 0.0) {\n    // Full range of rotation across the screen.\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  // autorotation\n  if (dorotate) {\n    p.yz = rotate(p.yz,-iTime*0.125);\n    p.zx = rotate(p.zx,iTime*0.1);\n  }\n  return p;\n}\n\nvec3 colours[] =\n  vec3[](vec3(0,0,1),\n         vec3(1,0,0),\n         vec3(1,1,0),\n         vec3(0,1,0),\n         vec3(1));\n\n// p is integer coordinates of 'dice'.\nvec3 getdicecolor(ivec3 p) {\n  p += cubesize;\n  int t = int(p.x >= 9) + int(p.y >= 9) + int(p.z >= 9);\n  return colours[t+int(cubesize == 5)];\n}\n\nfloat march(vec3 q, vec3 r) {\n  float maxdist = 2.0*eyedist;\n  float t = 0.0;\n  for (int i = 0; i < maxsteps; i++) {\n    vec3 p = q+t*r;\n    float d = de(p);\n    if (abs(d) < precis) return t; // Close enough to the surface.\n    t += d;\n    if (t > maxdist) break;\n  }\n  return -1.0;\n}\n\nbool raycolor(vec3 q, vec3 r, out vec3 color) {\n  float t = march(q,r);\n  if (t < 0.0) return false;\n  // Get the surface point that has been hit,\n  vec3 p = q+t*r;\n  // and the normal at that point.\n  vec3 normal = getnormal(p,r);\n  \n  // Apply lighting. This is a basic \"Lambertian\" model.\n  color = 0.2+0.8*getdicecolor(ivec3(floor(p)));\n  float ambient = 0.3;\n  float diffuse = 0.7*clamp(dot(normal,light),0.0,1.0);\n  color *= ambient+ diffuse;\n  return true;\n}\n\n// Partitions. p(n,m) = number of partitions of n with parts no larger than m\n// p(0,_) = 1\n// p(n,0) = 0\n// p(n,m) = p(n,m-1) + p(n-m,m)\n\nconst int ptable[20*20] =\n  int[] (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2,\n         2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 3, 3, 3,\n         3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 4, 5, 5, 5, 5, 5,\n         5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1, 3, 5, 6, 7, 7, 7, 7, 7, 7, 7,\n         7, 7, 7, 7, 7, 7, 7, 7, 7, 1, 4, 7, 9, 10, 11, 11, 11, 11, 11, 11,\n         11, 11, 11, 11, 11, 11, 11, 11, 11, 1, 4, 8, 11, 13, 14, 15, 15, 15,\n         15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 1, 5, 10, 15, 18, 20,\n         21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 1, 5, 12,\n         18, 23, 26, 28, 29, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n         1, 6, 14, 23, 30, 35, 38, 40, 41, 42, 42, 42, 42, 42, 42, 42, 42,\n         42, 42, 42, 1, 6, 16, 27, 37, 44, 49, 52, 54, 55, 56, 56, 56, 56,\n         56, 56, 56, 56, 56, 56, 1, 7, 19, 34, 47, 58, 65, 70, 73, 75, 76,\n         77, 77, 77, 77, 77, 77, 77, 77, 77, 1, 7, 21, 39, 57, 71, 82, 89,\n         94, 97, 99, 100, 101, 101, 101, 101, 101, 101, 101, 101, 1, 8, 24,\n         47, 70, 90, 105, 116, 123, 128, 131, 133, 134, 135, 135, 135, 135,\n         135, 135, 135, 1, 8, 27, 54, 84, 110, 131, 146, 157, 164, 169, 172,\n         174, 175, 176, 176, 176, 176, 176, 176, 1, 9, 30, 64, 101, 136, 164,\n         186, 201, 212, 219, 224, 227, 229, 230, 231, 231, 231, 231, 231, 1,\n         9, 33, 72, 119, 163, 201, 230, 252, 267, 278, 285, 290, 293, 295,\n         296, 297, 297, 297, 297, 1, 10, 37, 84, 141, 199, 248, 288, 318,\n         340, 355, 366, 373, 378, 381, 383, 384, 385, 385, 385, 1, 10, 40,\n         94, 164, 235, 300, 352, 393, 423, 445, 460, 471, 478, 483, 486, 488,\n         489, 490, 490, 1, 11, 44, 108, 192, 282, 364, 434, 488, 530, 560,\n         582, 597, 608, 615, 620, 623, 625, 626, 627\n);\n\nint pcount(int n, int m) {\n  if (n == 0) return 1;\n  if (m == 0) return 0;\n  return ptable[20*(n-1)+m-1];\n}\n\n// Recurrence:\n// parts(0,_) = [[]]\n// parts(_,0) = []\n// parts(n,m) = parts(n,m-1) + parts(n-m,m)\n// Use p(n,m) to decide which branch of the recursion to follow.\nint unrank(int n, int k, int t) {\n  int m = n, i = 0;\n  while (true) {\n    int k1 = pcount(n,m-1);\n    if (k < k1) m = m-1;\n    else {\n      t -= m;\n      if (t < 0) return i;\n      i++; n -= m; k -= k1;\n    }\n  }\n}\n\nvec3 bgcolor(vec2 fragCoord) {\n  // 490 = 2*5*7*7 items, each 19 squares, arranged in 14 rows of 7\n  // blocks of 5 subrows of 19 square. With a border.\n  ivec2 pdim = ivec2(iResolution.xy);\n  ivec2 pcoord = ivec2(fragCoord);\n  pcoord.y = pdim.y-1-pcoord.y;\n  vec3 col = vec3(0.2);\n  // Width is 7 blocks of 19, plus 8 separators\n  // Height is 14 blocks of 5, plus 15 separators\n  int W = 7, W1 = 19;\n  int H = 14, H1 = 5;\n  int M = 1;\n  ivec2 bdim = ivec2(W*(W1+M)+M, H*(H1+M)+M); //7*19+8;\n  ivec2 bcoord = pcoord*bdim/pdim;\n  int nwidth = bdim.x; //14*5+15;\n  int nheight = bdim.y; //14*5+15;\n  int i = bcoord.x, j = bcoord.y;\n  int i1 = (i+W1)%(W1+M); // Index within a horizontal block\n  int j1 = (j+H1)%(H1+M);   // Index within a vertical block\n  if (i1 < W1 && j1 < H1) {\n    int p = unrank(19,(i-M)/(W1+M)*(H*H1)+(j-M)/(H1+M)*H1+j1,i1);\n    if (p%2 != 0) col = vec3(0.8);\n    else col = vec3(0.5);\n  }\n  ivec2 boffset = (bcoord*pdim+bdim-1)/bdim; // Index of 1st pixel in block\n  if (bcoord.x > 0 && j1 < H1 && pcoord.x == boffset.x) col = vec3(0);\n  if (bcoord.y > 0 && i1 < W1 && pcoord.y == boffset.y) col = vec3(0);\n  return col;\n}\n\nconst int CHAR_B = 66;\nconst int CHAR_R = 82;\nconst int CHAR_X = 88;\n\nbool key(int code) {\n  return texelFetch(iChannel3, ivec2(code,2),0).x != 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n  if (key(CHAR_X)) cubesize = 5;\n  dorotate = !key(CHAR_R);\n  vec3 eye = vec3(0,0,eyedist);\n  eye = transformframe(eye);\n  light = transformframe(light);\n  vec3 bgcol = bgcolor(fragCoord);\n  vec3 col = vec3(0);\n  if (key(CHAR_B)) {\n    col = bgcol;\n  } else {\n    for (int i = 0; i < AA; i++) {\n      for (int j = 0; j < AA; j++) {\n        vec2 z = (2.0*(fragCoord+vec2(i,j)/float(AA))-iResolution.xy)/iResolution.y;\n        vec3 ray = vec3(z,-4);\n        ray = transformframe(ray);\n        ray = normalize(ray);\n        vec3 raycol;\n        if (!raycolor(eye,ray,raycol)) raycol = bgcol;\n        col += raycol;\n      }\n    }\n    col /= float(AA*AA);\n  }\n  col = pow(col,vec3(0.4545)); // Gamma\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlfz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1379, 1427, 1445, 1445, 1747], [1749, 1749, 1782, 1846, 2203], [2205, 2236, 2266, 2266, 2311], [2313, 2351, 2380, 2380, 2773], [2900, 2939, 2967, 2967, 3083], [3085, 3085, 3114, 3114, 3370], [3372, 3372, 3419, 3419, 3837], [5812, 5812, 5838, 5838, 5919], [5921, 6085, 6118, 6118, 6300], [6302, 6302, 6332, 6454, 7447], [7519, 7519, 7539, 7539, 7599], [7601, 7601, 7652, 7652, 8376]], "test": "untested"}
{"id": "WsXfz7", "name": "Psychedelic burning Wheel (2D)", "author": "mrange", "description": "Psychedelic burning wheel. A simple variation of an earlier shader: https://www.shadertoy.com/view/tdScD1", "tags": ["2d"], "likes": 15, "viewed": 604, "published": 3, "date": "1587887897", "time_retrieved": "2024-07-30T21:10:27.994684", "image_code": "// License: CC0\n//  Psychedelic burning wheel. A simple variation of an earlier shader: https://www.shadertoy.com/view/tdScD1\n\n\n// Experiment with these parameters for variants\nconst float size  = 0.75 ;\nconst float offc  = 1.05;\nconst float width = 0.0125;\nconst int   rep   = 15 ;\n\n#define PHI   (.5*(1.+sqrt(5.)))\n#define PI    3.141592654\n#define TAU   (2.0*PI)\n#define TIME  iTime\n#define TTIME (TAU*TIME)\n\nconst vec3 plnormal = normalize(vec3(1, 1, -1));\nconst vec3 n1 = normalize(vec3(-PHI,PHI-1.0,1.0));\nconst vec3 n2 = normalize(vec3(1.0,-PHI,PHI+1.0));\nconst vec3 n3 = normalize(vec3(0.0,0.0,-1.0));\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat box(vec2 p, vec2 b, float r) {\n  vec2 d = abs(p) - (b - r);\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nfloat dodec(in vec3 z) {\n  vec3 p = z;\n  float t;\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=2.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=2.0*t*n2; }\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=2.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=2.0*t*n2; }\n  z = abs(z);\n\n  float dmin=dot(z-vec3(size,0.,0.),plnormal);\n        \n  dmin = abs(dmin) - width*7.5*(0.55 + 0.45*sin(10.0*length(p) - 0.5*p.y + TTIME/9.0));\n        \n  return dmin;\n}\n\nfloat weird(vec2 p) {\n  float d = 100000.0;\n  float off = 0.30  + 0.25*(0.5 + 0.5*sin(TTIME/11.0));\n  float a = atan(p.y, p.x);\n  float r = length(p);\n  for (int i = 0; i < rep; ++i) {\n    vec2 ip = p;\n    //rot(ip, i*TAU/rep + 0.5*(r+0.5*p.x) - a*1.0);\n    rot(ip, float(i)*TAU/float(rep));\n    ip -= vec2(offc*size, 0.0);\n    vec2 cp = ip;\n    rot(ip, TTIME/73.0);\n    float dd = dodec(vec3(ip, off*size));\n    float cd = length(cp - vec2(0.25*sin(TTIME/13.0), 0.0)) - 0.125*size;\n    cd = abs(cd) - width*0.5;\n    d = pmin(d, dd, 0.05);\n    d = pmin(d, cd, 0.025);\n  }\n  return d;\n}\n\nfloat wheel(vec2 p, float s) {\n  vec2 pp = toPolar(p);\n  pp.y += TTIME/60.0;\n  mod1(pp.y, TAU/10.0);\n  pp.y += PI/2.0;\n  p = toRect(pp);\n  float ds = box(p, s*vec2(0.075, 0.5), s*0.04);\n  \n  float dc = circle(p, s*0.375);\n  \n  return pmin(ds, dc, s*0.0125);\n}\n\nfloat df(vec2 p) {\n  float dc = wheel(p, 3.0);\n  dc = abs(dc) - 0.2;\n  dc = abs(dc) - 0.1;\n  dc = abs(dc) - 0.05;\n  float dw = weird(p);\n  return pmin(dw, dc, mix(0.05, 0.5, (0.5 - 0.5*cos(TTIME/120.0))));\n}\n\nvec3 postProcess(vec3 col, vec2 q, vec2 p) {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  const float r = 1.5;\n  float d = max(r - length(p), 0.0)/r;\n  col *= vec3(1.0 - 0.25*exp(-200.0*d*d));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord.xy / iResolution.xy;\n  vec2 p = 2.0*(q - 0.5);\n  p.x *= iResolution.x/iResolution.y;\n  float d = df(p);\n\n  float fuzzy = 5.0/iResolution.x;\n    \n  vec3 col = vec3(0.0);\n\n  const vec3 baseCol = vec3(240.0, 175.0, 20.0)/255.0;\n  \n  col += 0.9*baseCol*vec3(smoothstep(fuzzy, -fuzzy, d));\n\n  vec3 rgb = 0.5 + 0.5*vec3(sin(TAU*vec3(50.0, 49.0, 48.0)*(d - 0.050) + TTIME/3.0));\n\n  col += baseCol.xyz*pow(rgb, vec3(8.0, 9.0, 7.0)); \n  col *= 1.0 - tanh(0.05+length(8.0*d));\n\n  float phase = TAU/4.0*(-length(p) - 0.5*p.y) + TTIME/11.0;\n \n  float wave = sin(phase);\n  float fwave = sign(wave)*pow(abs(wave), 0.75);\n \n  col = abs(0.79*(0.5 + 0.5*fwave) - col);\n  col = pow(col, vec3(0.25, 0.5, 0.75));\n  col = postProcess(col, q, p);\n\n  col = clamp(col, 0.0, 1.0);\n\n  col += 1.0 - smoothstep(0.0, 3.0, TIME);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXfz7.jpg", "access": "api", "license": "cc0-1.0", "functions": [[611, 611, 642, 642, 668], [670, 670, 706, 706, 794], [796, 796, 829, 829, 914], [916, 916, 955, 955, 1044], [1046, 1046, 1085, 1085, 1210], [1212, 1212, 1234, 1234, 1278], [1280, 1280, 1301, 1301, 1346], [1348, 1348, 1372, 1372, 1782], [1784, 1784, 1805, 1805, 2369], [2371, 2371, 2401, 2401, 2630], [2632, 2632, 2650, 2650, 2839], [2841, 2841, 2885, 2885, 3167], [3169, 3169, 3224, 3224, 4078]], "test": "untested"}
{"id": "3sXBR7", "name": "FEED ME", "author": "Plento", "description": "An experiment  (Might need to restart shader)", "tags": ["mouse", "derivative", "feedback", "buffer"], "likes": 11, "viewed": 441, "published": 3, "date": "1587864662", "time_retrieved": "2024-07-30T21:10:28.732710", "image_code": "void mainImage( out vec4 f, in vec2 u ){\n\tvec3 b = texture(iChannel0, u/iResolution.xy).xyz;\n    f = vec4(1.-exp(-b*b*b*b*b*b*17.), 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Paint with the mouse!\n\nvec2 R;\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n#define ch(chan, p) texelFetch(chan, ivec2(p), 0)\nvec2 hash21(float p){\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n// Uncomment for trippy zoomin!!\n#define ZOOM\n\n#define zoomFactor 0.991 \n\n// Bigger numbers means everything blends faster.\n#define diffusionRate 0.0089\n\n#define brushSize .07\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n    vec2 uv2 = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec2 uv = u / R;\n    \n    vec4 bA = ch(iChannel0, u);\n    vec4 bB = texture(iChannel1, u/R);\n    \n    float h = 1.0;\n    vec4 n = texelFetch(iChannel0, ivec2(u + vec2(0., h)), 0);\n    vec4 s = texelFetch(iChannel0, ivec2(u + vec2(0., -h)), 0);\n    vec4 e = texelFetch(iChannel0, ivec2(u + vec2(h, 0.)), 0);\n    vec4 w = texelFetch(iChannel0, ivec2(u + vec2(-h, 0.)), 0);\n    \n    vec4 avg = (n+s+w+e) / 4.;\n    vec4 dif = avg - bA;\n    \n    dif.xy += hash21(avg.z*432.4)*0.25;\n    dif.xy -= 0.125;\n    vec2 dir = normalize(vec2(dif.x, dif.y));\n    vec2 nc = vec2((u + vec2(dir.x*h, dir.y*h)));\n    \n    #ifdef ZOOM\n    nc -= R.xy*.5;\n    nc *= zoomFactor;\n    nc += R.xy*.5;\n    #endif\n    \n    vec4 new = texelFetch(iChannel0, ivec2(nc), 0);\n    \n    f = mix(new, texture(iChannel0, uv), 0.0002);\n    f = mix(f, avg, diffusionRate);\n    \n    if(iMouse.z > 0. && length(m-uv2) < brushSize)f = texture(iChannel1, uv);\n    if(iFrame < 8){f = bB;}\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXBR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 138]], "test": "untested"}
{"id": "3sfBzM", "name": "Symmetry Elements", "author": "izutionix", "description": "control the number of elements by changing the N define\n[url=https://www.shadertoy.com/view/tdsBz4]aesthetically better version[/url]", "tags": ["interactive", "symmetrical"], "likes": 13, "viewed": 408, "published": 3, "date": "1587851881", "time_retrieved": "2024-07-30T21:10:29.500657", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define TAU 6.28318530718\n\n#define N 3\n#define FRAMERATE 60.\n\nvec2 orbit(float t) {\n    return vec2(sin(t),cos(t));\n}\n\n//rotation function snatched from BigWIngs\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 ScatterColors(float g, vec3 c)\n{\n    vec3 g3 = vec3(g);\n    vec3 G1 = pow(c, g3);\n    vec3 G2 = vec3(1.)-pow(vec3(1.)-c, vec3(1.)-g3);\n    \n    vec3 A = G1*(vec3(1.)-G1);\n    vec3 B = G2*(vec3(1.)-G2);\n    \n    return 4.5*mix(A, B, g3);\n}\n\nfloat n = float(N);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    float t = float(iFrame)/FRAMERATE; //produces less gaps than iTime\n    \n    vec3 element = vec3(0.);\n    \n    for(int I = 0; I<N; I++) {\n        \n        float i = float(I);\n        vec2 p = 1.25*uv + orbit(t+i*TAU/float(n));\n\n        if(iMouse == texture(iChannel1, vec2(0.))){}\n        else {\n            p = uv - mouse*Rot(i*TAU/n);\n        }\n        \n        vec3 col = ScatterColors((i+.5)/n, vec3(0.007, 0.828, 0.321)); //vec3(.009, .288, .828)\n\t\tcol = normalize(col);\n        element += col/vec3(length(p));\n    }\n    \n    //accumulate image\n    vec4 new = vec4(vec3(element*.2/n), 1.0);\n    vec4 old = texture(iChannel0, fragCoord.xy / iResolution.xy);\n\n    fragColor = mix(old,new,.1);//vec4(max(old,new));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 old = texture(iChannel1, vec2(0.));\n    vec4 new = iMouse;\n    fragColor = mix(old,new,.6);\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfBzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 138]], "test": "untested"}
{"id": "3dfBzM", "name": "Stylized Shoreline", "author": "haralis", "description": "Small stylized shoreline shader.", "tags": ["water", "stylized", "shore"], "likes": 26, "viewed": 1117, "published": 3, "date": "1587850811", "time_retrieved": "2024-07-30T21:10:30.238684", "image_code": "#define PI 3.14159265369\n\nfloat rand(vec2 c){\n\treturn fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n\nfloat cnoise(vec2 P){\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 * \n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nvec4 rgb(float r, float g, float b) {\n\n\treturn vec4(r / 255.0, g / 255.0, b / 255.0, 1.0);\n\n}\n\nfloat vignette (vec2 st, float r, float rs) {\n\tst -= 0.5;\n\n\treturn smoothstep (r, r - rs, length(st));\n}\n\nvec3 acesFilm(const vec3 x) { const float a = 2.51;\n const float b = 0.03;\n const float c = 2.43;\n const float d = 0.59;\n const float e = 0.14;\n return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\nvec4 frag(vec2 uv) {\n\t//uv = rotate(uv, 5. *PI / 6.);\n\tvec4 snd = rgb(255., 150., 80.);\n\tvec4 wtr = rgb(90., 180., 110.);\n\tvec4 wtr2 = rgb(20., 70., 130.);\n\n\tfloat sltm = iTime * 0.2;\n\n\tfloat uvy = uv.y - (sin(iTime) * 0.5 + 0.5) * 0.1 - 0.6;\n\tfloat wuvy = uv.y - (sin(.75) * 0.5 + 0.5) * 0.1 - 0.59;\n\n\tfloat shore = sin(uv.x * PI * 4. + sltm);\n\tshore += sin(uv.x * PI * 3.);\n\tshore = shore * 0.5 + 0.5;\n\tshore *= 0.05;\n\tfloat smshore = smoothstep( uvy * 5., uvy * 5. + 2.5, shore);\n\n\n\tfloat wshore = smoothstep( wuvy * 5., wuvy * 5., shore);\n\n\tshore = smoothstep( uvy * 5., uvy * 5. + 2., shore);\n\n\tfloat shmsk = step(0.01, shore);\n\tfloat shmsko = step(0.012, shore);\n    \n    float suvx = uv.x + (uv.y * 5.);\n\tfloat sand = step(fract(uv.y * 10.) * 2. - 0.5, (sin(suvx * PI * 1.5)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ sin(suvx * PI * 2.)) * 0.5 + 0.5);\n\tsand -= step(fract(uv.y * 10.) * 2., sin(suvx * PI * 2.) * 0.5 + 0.5);\n\n\n\twtr = mix(wtr2, wtr, smoothstep (0.0, 0.5, uv.y));\n\tsnd *= clamp(sand, 0.95, 1.);\n\tvec4 res = mix(snd, wtr, smshore);\n    \n    //cnoise(vec2(uv.x, uvy * 4. + sltm * 0.5) * 10.0) * 0.5 + 0.5\n    float foam = cnoise(vec2(uv.x * 3.0, uvy * 4. + sltm * 0.5) * 10.0) * 0.5 + 0.5;\n\tfloat ofoam = step(shore + 0.05, foam) * shmsk;\n\tfoam = step(shore, foam) * shmsk;\n\n    //vec2(uv.x, uvy * 4. + soff + sltm * 0.5)\n\tfloat soff = mix(0.01, 0.2, smoothstep (0.7, 0., uv.y));\n\tfloat foams = cnoise(vec2(uv.x * 3.0, uvy * 4. + soff + sltm * 0.5) * 10.0) * 0.5 + 0.5;\n\tfoams = 1. - step(shore, foams) * shmsk * 0.2;\n\n\tres *= foams;\n\tres *= (1. - wshore * (1. - shmsk) * (sin(iTime - PI / 2.) * 0.5 + 0.5) * 0.2);\n\n\tres = mix(res, vec4(1.), foam);\n    \n    res = mix(res, res * vignette(uv, 0.99, 0.8), 0.5);\n\t\n    res.a = mix(0.3, 0.35, shmsk);\n    return res;\n}\n\n\nvec4 chab(vec2 uv, float amt) {\n\n\treturn vec4(\n\t\tfrag(uv + vec2(1.0, 1.0) * amt).r,\n\t\tfrag(uv).g,\n\t\tfrag(uv - vec2(1.0, 1.0) * amt).b,\n\t\tfrag(uv).a\n\t);\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float chmt = 1.3 - vignette(uv, 0.9, 0.8);\n\tvec4 res = chab(uv, 0.004 * chmt);\n    fragColor = vec4(acesFilm(res.rgb), res.a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfBzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 45, 45, 113], [115, 115, 134, 134, 170], [172, 172, 193, 193, 230], [232, 232, 253, 253, 1330], [1332, 1332, 1369, 1369, 1425], [1427, 1427, 1472, 1472, 1531], [1533, 1533, 1562, 1562, 1747], [1749, 1749, 1769, 1802, 3507], [3510, 3510, 3541, 3541, 3664], [3668, 3668, 3725, 3725, 3898]], "test": "untested"}
{"id": "wsXfRN", "name": "Substrate", "author": "darknoon", "description": "GPU implementation of Jason Tarbell's Substrate algorithm.\n\nI couldn't figure out how to get the sand working (#define WIP_SAND), tried raymarching distance to nearest line in a voronoi diagram (jump-flooding) without success.", "tags": ["generative", "cracks", "substrate"], "likes": 7, "viewed": 466, "published": 3, "date": "1587849136", "time_retrieved": "2024-07-30T21:10:31.242001", "image_code": "\nvec3 a = vec3(0.5, 0.5, 0.5);\nvec3 b = vec3(0.5, 0.23, 0.9);\nvec3 c = vec3(1.0, 1.0, 1.0);\nvec3 d = vec3(0.00, 0.33, 0.67);\n\n#define RAYMARCH_DISTANCE 1\n#define RAYMARCH_SAMPLES 5\n\n\n#define WOS_SAMP 1\n#define WOS_E 1.\n#define WOS_MAX_ITER 16\n\n// isquilez color mapper\nvec3 colorMap(float t) {\n\treturn (a + b * cos(2. * PI * (c * t + d)));\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\n#if WIP_WOS\n\n\n\n// WoS\nvec4 march( in vec2 p ) {\n    vec2 invRes = 1. / iResolution.xy;\n\tfor(int i=0; i<WOS_MAX_ITER; i++) {\n        p = clamp(p, vec2(2.), iResolution.xy - 2.);\n        vec4 distData = texture(iChannel1, p * invRes);\n        float d = length(distData.xy - p);\n        \n        if (d < WOS_E) {\n\t    \tvec4 lineData = texture(iChannel0, p * invRes);\n\t\t    vec2 lineBasis = vec2(cos(lineData.z), sin(lineData.z));\n            vec3 lineColor = vec3(0.5 + 0.5 * cos(lineData.z));\n            return vec4(colorMap(lineData.z), 1.0);\n        }\n        p = p + d * randomInCircle();\n    }\n    return vec4(0.0);\n}\n\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 invRes = 1. / iResolution.xy;\n    // For now, just dump out Buffer A\n    vec2 uv = fragCoord * invRes;\n    \n    vec4 distData = texture(iChannel1, uv);\n    vec2 lpt = distData.xy;\n    // vector from nearest line to current point\n    vec2 dto = fragCoord - lpt;\n\n    #if SHOW_DISTANCE_IMAGE\n    // Direction image\n    fragColor = vec4(0.5 + dto * invRes * 1.5, 0.5, 1.0);\n    // Distance\n    //fragColor.rgb = vec3(1.-4.0 * length(dto) * invRes.x);\n    \n    #elif DEBUG\n    vec4 data = texture(iChannel0, uv);\n    fragColor = vec4(data.xy, data.zw);\n\n    #else\n    // Accumulate contribution from neighbors (5x5 neighborhood allows for fatter lines, subpx)\n    float dist = 1000.0;\n    vec4 distLine = vec4(0.0);\n    for (int i=-2; i<=2; i++) {\n        for (int j=-2; j<=2; j++) {\n            vec2 offset = vec2(i, j);\n            vec4 data = texture(iChannel0, uv + offset * invRes);\n            \n            // Each point that a line transited projects a line via udSegment fn\n            vec2 frac = data.xy;\n            vec2 pos = frac + offset;\n            float angle = data.z;\n            vec2 dir = vec2(cos(angle), sin(angle));\n\n            bool filled = data.w != 0.0;\n            // Take the min distance to the surface\n            if (filled) {\n                float segDist = udSegment( vec2(0.0), pos - 0.5 * dir, pos + 0.5 * dir );\n                if (segDist < dist) {\n\t            \tdist = segDist;\n                    distLine = data;\n                }\n            }\n        }\n    }\n    // Read the nearest line (from buffer A) to our current point\n    vec4 lineData = texture(iChannel0, distData.xy * invRes);\n\n    float rmDist = 1.0;\n    #if WIP_SAND && RAYMARCH_DISTANCE\n    // Ray-march from current position away from nearest line\n    vec2 rmDir = normalize(dto);\n    vec2 rmPt = fragCoord;\n    //vec2 rmPt = lpt + vec2(sin(lineData.z), cos(lineData.z));\n    float distBound = length(dto);\n    rmDist = distBound;\n    for (int i = 0; i < RAYMARCH_SAMPLES; i++) {\n        // Ray march distance update to new point\n        vec2 ptNext = rmPt + rmDir * distBound;\n        ptNext = clamp(ptNext, vec2(0.0), iResolution.xy);\n        // opt: length() not really necessary\n        rmDist += length(ptNext - rmPt);\n\t\trmPt = ptNext;\n\n        // Sample distance field\n        vec4 distDataRm = texture(iChannel1, rmPt * invRes);\n        vec2 lptRm = distDataRm.xy;\n        \n        // We can safely step within a radius of the nearest line point\n        distBound = length(lptRm - rmPt);\n    }\n    #elif WIP_WOS\n    \n        // Walk on Circles\n        ivec2 q = ivec2(fragCoord);\n        srand( hash(q.x+hash(q.y + hash(iFrame))));\n        vec4 wc = vec4(0.);\n        for (int i=0; i<WOS_SAMP; i++) {\n            vec4 m = march(fragCoord);\n            wc += m;\n        }\n        vec3 color = wc.rgb / wc.a;\n    #endif\n    \n\n    #if WIP_SAND\n    // Randomize based on point in space\n    // Parameterize space along line angle\n    vec2 lineBasis = vec2(cos(lineData.z), sin(lineData.z));\n    //float str = hash12(lineData.xy);\n    // Distance along line (not from start)\n    float basis = dot(lineBasis, distData.xy);\n    // Distance from line\n    float dline = length(dto);\n\n    //float str = 0.5 + 0.2 * hash11(floor(0.25*basis));\n    float str = 0.5 + 0.2 * sin(0.5 * basis);\n    \n    float rmBright = 1. - clamp(rmDist * invRes.y, 0.0, 1.0);\n    //float str = ;\n    str = rmBright;\n    \n        \n    //vec3 color = str * colorMap(16. * lineData.z);\n    vec3 color = colorMap(rmDist * invRes.y);\n    \n    #elif WIP_WOS\n    \n    #else //WIP_SAND\n    vec3 color = vec3(0.95);\n    #endif //WIP_SAND\n    \n    float thick = 2.0;\n\t\n    // Falloff color\n    vec3 lineColor = vec3(0.0);\n    float lineBlend = clamp(thick - dist, 0.0, 1.0);\n    \n    fragColor.xyz = mix(color, lineColor, lineBlend);\n    \n    //fragColor.xyz = min(vec3(dist), 1.0) - 0.005*length(dto);\n    #endif\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define WIP_SAND 0\n\n// Turn on Walk on Sphere algorithm (PDE)\n#define WIP_WOS 1\n\n#define SLOW_ANIMATION 0\n#define DEBUG 0\n#define SHOW_DISTANCE_IMAGE 0\n#define PI 3.14159\n#define RESET (iFrame == 0 || iMouse.z > 0.0)\n// Number betweet 0 and 1-something, subpixel speed\n#define SPEED 0.85\n\n\n// The interesting code is in Buffer A.\n\n\n#define R(a) texture(iChannel0, (fragCoord + a) * invRes)\n\n// via https://www.shadertoy.com/view/4djSRW\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\n\n\n/// WoS\n\n// --------------------------------------\n// oldschool rand() from Visual Studio\n// --------------------------------------\nint  seed = 1;\nvoid srand(int s ) { seed = s; }\nint  rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\n// --------------------------------------\n\n\n// --------------------------------------\n// hash to initialize the random sequence (copied from Hugo Elias)\n// --------------------------------------\nint hash( int n )\n{\n\tn = (n << 13) ^ n;\n    return n * (n * n * 15731 + 789221) + 1376312589;\n}\n\n// --------------------------------------\n\nvec2 randomInCircle( void )\n{\n    float an = 6.283185*float(rand())/32767.0;\n    return vec2(cos(an),sin(an));\n}\n    \n", "buffer_a_code": "// Crack occupancy buffer\n// xy = fract(xy)       : allows sub-pixel movement of each crack\n// z = angle            : angle of crack travel\n// w = tag              : 0 empty, 1 occupied, 2 active\n\n// RNG for crack init, branch creation\nvec4 hash4( vec3 p )\n{\n    vec4 q = vec4( dot(p,vec3(127.1,311.7,256.8)), \n\t\t\t\t   dot(p,vec3(269.5,183.3,012.5)), \n\t\t\t\t   dot(p,vec3(419.2,371.9,167.1)),\n                   dot(p,vec3(269.5,183.3,918.1))\n                 );\n\treturn fract(sin(q)*43758.5453);\n}\n\n// Update cracks\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 invRes = 1. / iChannelResolution[0].xy;\n    vec4 data = R(0.0);\n    \n    vec4 rng = hash43(vec3(fragCoord * 0.01, iTime + 132.4));\n    \n    // Seed initial cracks\n    if (RESET) {\n        bool init = rng.z < 0.005 && rng.y < 0.005 && rng.w < 0.5;\n        float angle = 2. * 3.14159 * rng.x;\n        if (init) {\n            //float angle = 1.5 + 1.4 * rng.x;\n            // Init frac to middle of the pixel\n            fragColor = vec4(0.0, 0.0, angle, 2.);\n            return;\n        } else {\n            fragColor = vec4(0.0, 0.0, angle, 0.);\n            return;\n        }\n    }\n    \n    // Slow animation\n    #if SLOW_ANIMATION\n    if (fract(iTime) > 1./30.) {\n        fragColor = data;\n        return;\n    }\n    #endif\n    \n    // If we're occupied and inactive, stay inactive with current angle\n    if (data.w == 1.) {\n        // Small chance of turning into an orthogonal line\n        // TODO: only do this if we have enough space\n        if (rng.y < 0.005 && rng.x < 0.005) {\n        \tfragColor = vec4(data.xy, data.z - 0.5 * PI, 2.0);\n        } else if (rng.y < 0.005 && rng.z < 0.005) {\n        \tfragColor = vec4(data.xy, data.z + 0.5 * PI, 2.0);\n        } else {\n            fragColor = data;\n        }\n        return;\n    }\n    \n    // Search neighbors for a particle coming into this cell\n    bool entered = false;\n    for (int i=-1; i<=1; i++) {\n        for (int j=-1; j<=1; j++) {\n            // There are some cases where the current cell could be the target\n            //if (i==0 && j==0) continue;\n            if (entered) break;\n            \n            vec2 offset = vec2(i, j);\n            vec4 other = R(offset);\n            \n            bool otherIsCrack = other.w == 2.0;\n            \n            vec2 frac = other.xy;\n\n            float angle = other.b;\n            \n            vec2 dir = SPEED * vec2(cos(angle), sin(angle));\n            \n            // If this falls within our square (-0.5 ... 0.5) x/y then we become this crack\n            vec2 minc = vec2(-0.5);\n            vec2 maxc = vec2(0.5);\n            vec2 otherNext = offset + frac + dir;\n            // Are we the cell this crack will enter?\n            if (otherIsCrack\n                && all(greaterThan(otherNext, minc))\n                && all(lessThan(otherNext, maxc))) {\n                // Become this crack\n                fragColor = vec4(otherNext.xy, other.z, other.w);\n                entered = true;\n                break;\n            }\n        }\n    }\n    \n    // done searching neighbors\n    if (!entered) {\n        float flag = data.w;\n        flag = min(flag, 1.0);\n        fragColor = vec4(data.xy, data.z, flag);   \n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Jump-flood algorithm for voronoi / min-distance to lines\n// Problem is that this wasn't as useful for estimating distance to nearest line as I thought\n\n// xy = coordinate of nearest line\n// zw = \n\n// Take log(N) steps to resolve a distance image\n// https://computergraphics.stackexchange.com/questions/4830/understanding-jump-flooding-algorithm-jfa-for-voronoi-diagrams\n\n#define JFA_STEPS 9\n#define JFA_MAX_DIST (1<<JFA_STEPS)\n#define JFA_HUGE (100000.0)\n\n// Different algorithm\n\n#if WIP_SAND || WIP_WOS\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 invRes = 1. / iChannelResolution[0].xy;\n    int fi = iFrame % JFA_STEPS;\n    float progress = float(fi) / float(JFA_STEPS);\n    \n    // Can go up or down here\n    int jump = 1 << (JFA_STEPS - fi - 1);\n    \n    // Read data from occupancy texture\n    vec4 data = texture(iChannel0, fragCoord * invRes);\n    \n    // If we are an active cell, seed with our data\n    float minDist = data.w > 0. ? length(data.xy) : JFA_HUGE;\n    vec4  minData = data.w > 0. ? vec4(fragCoord.xy + data.xy, 1.0, 1.0) : vec4(0.0);\n    // Check -jump, cur, jump neighborhood\n    for (int i=-jump; i<=jump; i+=jump) {\n        if (RESET) {\n            break;\n        }\n        for (int j=-jump; j<=jump; j+=jump) {\n            vec2 off = vec2(i,j);\n            // This is our data, xy is coord of nearest point\n            vec4 neigh = texture(iChannel1, (fragCoord + off) * invRes);\n            \n\t\t\t// If neighbor dist is less, use it\n            float dist = length(neigh.xy - fragCoord);\n            if (dist < minDist) {\n                minDist = dist;\n                minData = neigh;\n            }\n        }\n    }\n    if (minDist < JFA_HUGE) {\n\t    fragColor.rgba = minData;\n    } else {\n    \tfragColor.rgba = vec4(0.0);\n    }\n}\n\n#else\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor.rgba = vec4(0.0);\n}\n\n\n#endif", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXfRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[244, 269, 293, 293, 341], [343, 343, 395, 395, 518], [1150, 1150, 1207, 1207, 5101]], "test": "untested"}
{"id": "wdsfzN", "name": "Mold van Damme", "author": "michael0884", "description": "Using Voronoi particle tracking to simulate the dynamics of a slime mold. Use mouse to change parameters.", "tags": ["fast", "particles", "physarum", "polycephalum"], "likes": 26, "viewed": 1026, "published": 3, "date": "1587845329", "time_retrieved": "2024-07-30T21:10:32.105692", "image_code": "// Fork of \"Physarum Polycephalum Simulation\" by michael0884. https://shadertoy.com/view/tlKGDh\n// 2020-04-25 20:06:12\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n\tvec4 particle = texel(ch0, pos);\n    float distr = gauss(pos - particle.xy, prad);\n    vec4 pheromone = 2.5*texel(ch1, pos);\n    fragColor = vec4(sin(pheromone.xyz*vec3(1,1.2,1.5)), 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//voronoi particle tracking \n//simulating the cells\n\n//loop the vector\nvec2 loop_d(vec2 pos)\n{\n\treturn mod(pos + size*0.5, size) - size*0.5;\n}\n\n//loop the space\nvec2 loop(vec2 pos)\n{\n\treturn mod(pos, size);\n}\n\n\nvoid Check(inout vec4 U, vec2 pos, vec2 dx)\n{\n    vec4 Unb = texel(ch0, loop(pos+dx));\n    //check if the stored neighbouring particle is closer to this position \n    if(length(loop_d(Unb.xy - pos)) < length(loop_d(U.xy - pos)))\n    {\n        U = Unb; //copy the particle info\n    }\n}\n\nvoid CheckRadius(inout vec4 U, vec2 pos, float r)\n{\n    Check(U, pos, vec2(-r,0));\n    Check(U, pos, vec2(r,0));\n    Check(U, pos, vec2(0,-r));\n    Check(U, pos, vec2(0,r));\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 muv = iMouse.xy/size;\n    \n    if(length(muv.xy) >0.)\n    {\n    \tsdist *= muv.x;\n  \t\tsst *= muv.y; \n    }\n    else\n    {\n        sdist *= 0.8;\n  \t\tsst *= 0.05; \n    }\n   \n    //this pixel value\n    U = texel(ch0, pos);\n    \n    //check neighbours \n    CheckRadius(U, pos, 1.);\n    //CheckRadius(U, pos, 2.);\n    CheckRadius(U, pos, 3.);\n   // CheckRadius(U, pos, 4.);\n   // CheckRadius(U, pos, 5.);\n   \n    U.xy = loop(U.xy);\n    \n    //cell cloning \n    if(length(U.xy - pos) > 10.)\n    \tU.xy += 1.*(hash22(pos)-0.5);\n\n    //sensors\n    vec2 sleft = U.xy + sdist*vec2(cos(U.z+sangl), sin(U.z+sangl));\n    vec2 sright = U.xy + sdist*vec2(cos(U.z-sangl), sin(U.z-sangl));\n    \n    float dangl = (pixel(ch1, sleft).x - pixel(ch1, sright).x);\n    U.z += dt*sst*tanh(3.*dangl);\n   \n    vec2 pvel = pspeed*vec2(cos(U.z), sin(U.z)) + 0.1*(hash22(U.xy+iTime)-0.5);;\n    \n    //update the particle\n    U.xy += dt*pvel;\n    \n    U.xy = loop(U.xy);\n    \n    \n    if(iFrame < 1)\n    {\n        U.xy = vec2(pdens*round(pos.x/pdens),pdens*round(pos.y/pdens));\n        U.zw = hash22(U.xy) - 0.5;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//simulation variables\n#define dt 0.25\n#define prad 1.4\n#define decay 0.3\n\n//cell speed\nfloat pspeed = 6.;\n\n//sensor distance \nfloat sdist = 10.;\n\n//sensor strenght\nfloat sst = 10.;\n\n//sensor angle\nfloat sangl = 0.3; //radians\n\n#define pdens 2.\n//definitions\n#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p-0.5), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n//hash functions\n//https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\n//functions\nfloat gauss(vec2 x, float r)\n{\n    return exp(-pow(length(x)/r,2.));\n}\n   \n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\n//Laplacian operator\nvec4 Laplace(sampler2D ch, vec2 p)\n{\n    vec3 dx = vec3(-1,0.,1);\n    return texel(ch, p+dx.xy)+texel(ch, p+dx.yx)+texel(ch, p+dx.zy)+texel(ch, p+dx.yz)-4.*texel(ch, p);\n}\n\nvec4 LaplaceP(sampler2D ch, vec2 p)\n{\n    vec3 dx = vec3(-5,0.,5);\n    return pixel(ch, p+dx.xy)+pixel(ch, p+dx.yx)+pixel(ch, p+dx.zy)+pixel(ch, p+dx.yz)-4.*pixel(ch, p);\n}\n\n//Gradient\nvec2 Grad(sampler2D ch, vec2 p)\n{\n    vec3 dx = vec3(-1,0.,1);\n    return vec2(length(texel(ch, p+dx.zy)),length(texel(ch, p+dx.yz))) - length(texel(ch, p));\n}\n", "buffer_b_code": "//depositing and diffusing the pheromone trails \n\nvoid mainImage( out vec4 Q, in vec2 p )\n{\n    Q = texel(ch1, p);\n   \n    //diffusion equation\n    Q += dt*Laplace(ch1, p);\n    \n    vec4 particle = texel(ch0, p);\n    float distr = gauss(p - particle.xy, prad);\n    \n    vec2 ss = vec2(textureSize(ch2,0))/size;\n    float video = length(Laplace(ch2, p*ss));\n    \n    //pheromone depositing\n    Q += dt*(distr+2.*video);\n        \n    //pheromone decay\n    Q += -dt*decay*Q;\n    \n    if(iFrame < 1) Q = vec4(0);\n}", "buffer_b_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 Q, in vec2 p )\n{\n    Q = texel(ch1, p);\n    \n    Q = 0.9*Q + 0.1*texel(ch0, p); \n    if(iFrame < 1) Q =vec4(0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsfzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 120, 171, 171, 361]], "test": "untested"}
{"id": "wdsfRN", "name": "Rational 4D Lattice Slice", "author": "mla", "description": "A variation on [url]https://www.shadertoy.com/view/WdXBzH[/url] using rotations through rational angles to get nice symmetric patterns.", "tags": ["4d", "slices", "rational"], "likes": 7, "viewed": 367, "published": 3, "date": "1587839504", "time_retrieved": "2024-07-30T21:10:32.883612", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Rational Slices.\n//\n// Matthew Arcus, mla, 2020\n//\n// Slices through a 4 dimensional cubic lattice at rational angles.\n// <mouse-y>: scale\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.1415927;\n\n// Quaternion left and right multiplication as matrices\n// The two forms commute (this is just associativity).\nmat4 qmat_left(vec4 q) {\n  float x = q.x, y = q.y, z = q.z, t = q.w;\n  return mat4( t, z,-y,-x, \n              -z, t, x,-y,\n               y,-x, t,-z,\n               x, y, z, t );\n}\n\nmat4 qmat_right(vec4 q) {\n  float x = q.x, y = q.y, z = q.z, t = q.w;\n  return mat4( t,-z, y,-x, \n               z, t,-x,-y,\n              -y, x, t,-z,\n               x, y, z, t );\n}\n\n// Farey(10) sequence\nconst int nfarey = 33;\nconst int farray[2*nfarey] =\n  int[](0,1,1,10,1,9,1,8,1,7,1,6,1,5,2,9,1,4,2,7,3,10,\n        1,3,3,8,2,5,3,7,4,9,1,2,5,9,4,7,3,5,5,8,2,3,7,\n        10,5,7,3,4,7,9,4,5,5,6,6,7,7,8,8,9,9,10,1,1);\n\nfloat farey(int i) {\n  i %= nfarey;\n  return float(farray[2*i])/float(farray[2*i+1]);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  float size = 4.0*exp(3.0*iMouse.y / iResolution.y);\n  uv *= size;\n\n  float tr,tq;\n  tq = atan(1.0);\n  float t = 1.0*iTime;\n  float i0 = 2.0*floor(0.5*t);\n  float i1 = 2.0*floor(0.5*t+0.5);\n  int mfactor = 256;\n  tr = atan(mix(farey(int(i0)*mfactor),farey(int(i1)*mfactor),fract(t)));\n\n  vec4 q = vec4(sin(tq)*vec3(1,0,0),cos(tq));\n  vec4 r = vec4(sin(tr)*vec3(0,1,0),cos(tr));\n\n  vec4 p = vec4(uv,0,0);\n  mat4 qm = qmat_left(q)*qmat_right(r);\n  float ds = fwidth(p.x);\n  p = qm*p;\n  p = mod(p,2.0);\n  vec4 dp = fract(p);\n  dp = min(dp,1.0-dp);\n  p = floor(p);\n  int parity = int(dot(p,vec4(1)))%2;\n\n  mat4x2 dm = transpose(mat2x4(qm));\n  dp /= vec4(length(dm[0]),length(dm[1]),length(dm[2]),length(dm[3]));\n  float d = min(min(dp.x,dp.y),min(dp.z,dp.w));\n  vec3 color = vec3(smoothstep(-ds,+ds,parity==0?d:-d));\n  color = mix(vec3(1,0,0),color,smoothstep(0.01,0.02+ds,d));\n  color = pow(color,vec3(0.4545));\n  fragColor = vec4(color,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsfRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[340, 451, 475, 475, 632], [634, 634, 659, 659, 816], [1057, 1057, 1077, 1077, 1144], [1146, 1146, 1203, 1203, 2202]], "test": "untested"}
{"id": "tdsBz4", "name": "Complementary Elements", "author": "izutionix", "description": "figured out how to use buffers :)\n[url=https://www.shadertoy.com/view/3sfBzM]technically better version[/url]", "tags": ["interactive", "fire", "water"], "likes": 13, "viewed": 712, "published": 3, "date": "1587832126", "time_retrieved": "2024-07-30T21:10:33.633608", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    float t = float(iFrame)/60.; //produces less gaps than iTime\n    \n    vec2 orbit = vec2(sin(t),cos(t));\n    \t\n\n    vec2 fuv = 1.25*uv + orbit;\n    vec2 wuv = 1.25*uv - orbit;\n    \n\tif(iMouse == texture(iChannel1, vec2(0.))){}\n    else\n    {\n\t\tfuv = uv - mouse;\n    \twuv = uv + mouse;\n    }\n    \n    vec3 fire = vec3(.7,.2,.1)/vec3(length(fuv));\n    vec3 water = vec3(.1,.2,.7)/vec3(length(wuv));\n    vec3 col = fire + water;\n    \n    //accumulate image\n    vec4 new = vec4(vec3(col*.1), 1.0);\n    vec4 old = texture(iChannel0, fragCoord.xy / iResolution.xy);\n\n    fragColor = mix(old,new,.1);//vec4(max(old,new));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 old = texture(iChannel1, vec2(0.));\n    vec4 new = iMouse;\n    fragColor = mix(old,new,.6);\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsBz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 138]], "test": "untested"}
{"id": "tdlfR4", "name": "BritneyScope", "author": "xjorma", "description": "Tried to reproduce this effect, less convincing than I hoped :(\n\nhttps://www.facebook.com/groups/touchdesignerhelp/permalink/1567523910080270/", "tags": ["kaleidoscope"], "likes": 8, "viewed": 616, "published": 3, "date": "1587827726", "time_retrieved": "2024-07-30T21:10:34.373628", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#define NB_PIECE\t6\n#define OFFSET\t\t0.6\n#define SCALE\t\t1.2\n#define ROT_SPEED\t0.1\n#define TAU \t\tradians(360.)\n#define MAX_ITER\t4.\n#define CYCLE\t\t15.\n\nvec2 kaleidoscope(vec2 uv, float iter, float v)\n{\n    float c = clamp(v - iter, 0., 1.);\n    float t = fract(iTime * ROT_SPEED * (iter + 1.)) * TAU / float(NB_PIECE);\n    float a = atan(uv.y, uv.x) + t;\n    \n    float p = round(a * float(NB_PIECE) / TAU) * TAU / float(NB_PIECE);\n    \n    vec2 offset = vec2(cos(p - t), sin(p - t)) * c * OFFSET;\n    \n    return  uv * mix(1., pow(SCALE, iter + 1.), c) - offset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2  uv = (2. * fragCoord - iResolution.xy) / iResolution.x;\n    \n    float v = abs(fract((0.5 * iTime - CYCLE / 2.) / CYCLE) * 2. * MAX_ITER - MAX_ITER);\n    \n    for(int i = 0; i < int(MAX_ITER); ++i)    \n    \tuv = kaleidoscope(uv, float(i), v);\n    \n    uv = (uv * vec2(1, 16./9.) / 2. + 0.5);\n \n    vec3 col = texture(iChannel0, uv).rgb;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlfR4.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[261, 261, 310, 310, 674], [676, 676, 733, 733, 1114]], "test": "untested"}
{"id": "WssfzN", "name": "Ciel et sol", "author": "42yeah", "description": "This is just a sky rendering test. Sky code partially stolen from Clouds by iq: https://www.shadertoy.com/view/XslGRr", "tags": ["raymarching"], "likes": 1, "viewed": 483, "published": 3, "date": "1587820458", "time_retrieved": "2024-07-30T21:10:35.118636", "image_code": "vec3 sunDir = normalize(vec3(-0.0, 0.2, -1.0));\n\nfloat sol(vec3 pos) {\n    return pos.y;\n}\n\nvec3 rand3d(vec3 i) {\n    return fract(sin(vec3(\n        dot(i, vec3(12.345, 67.890, 1.56)),\n        dot(i, vec3(512.21, 90.511, 80.42)),\n        dot(i, vec3(6.28, 30.19, 37.48))\n    )) * 421234.567) * 2.0 - 1.0;\n}\n\nvec3 solColor(vec3 pos) {\n    vec3 baseColor = vec3(2.0, 2.0, 2.2);\n    pos = pos * 5.0;\n    vec3 u = mod(floor(pos), 2.0) * 0.5;\n    vec3 f = fract(pos);\n    float m = 0.6 + clamp(abs(u.x - u.z), 0.0, 1.0) * 0.4;\n    return vec3(m) * baseColor;\n}\n\nvec2 map(vec3 pos) {\n    float closest = 1000.0;\n    float id = -1.0;\n    \n    float dist = sol(pos);\n    if (dist < closest) { closest = dist; id = 0.5; }\n    \n    return vec2(closest, id);\n}\n\nvec2 intersect(vec3 ro, vec3 rd) {\n    float depth = 0.0;\n    float id = -1.0;\n    for (int i = 0; i < 200; i++) {\n        vec2 info = map(ro + rd * depth);\n        if (info.x <= 0.001) {\n            id = info.y;\n            break;\n        }\n        depth += info.x;\n    }\n    return vec2(depth, id);\n}\n\nvec3 getSkyColor(vec3 p, vec3 rd) {\n    vec3 c = vec3(0.6, 0.8, 0.9);\n    c += rd.y * vec3(0.3, 0.3, 1.1);\n    float s = clamp(dot(rd, sunDir), 0.0, 1.0);\n    c += vec3(0.3, 0.3, 0.0) * pow(s, 32.0);\n    c += 0.1 * vec3(1.0, 0.4, 0.2) * pow(s, 8.0);\n    return c;\n}\n\nvec3 getColor(float id, vec3 p, vec3 rd) {\n    if (id < -0.5) { // ciel\n        return getSkyColor(p, rd);\n    }\n    if (id < 1.0) { return solColor(p); }\n    return vec3(1.0, 0.0, 0.0);\n}\n\nvec3 getNormal(vec3 pos) {\n    const float epsilon = 0.001;\n    return normalize(vec3(\n        map(pos).x - map(vec3(pos.x - epsilon, pos.yz)).x,\n        map(pos).x - map(vec3(pos.x, pos.y - epsilon, pos.z)).x,\n        map(pos).x - map(vec3(pos.x, pos.y, pos.z - epsilon)).x\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    \n    vec3 ro = vec3(iTime * 0.05, 0.4, iTime * 0.01);\n    \n    vec3 center = vec3(0.0, 0.5, -500.0);\n    vec3 front = normalize(center - ro);\n    vec3 right = normalize(cross(front, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, front));\n    \n    mat4 lookAt = mat4(\n        vec4(right, 0.0),\n        vec4(up, 0.0),\n        vec4(front, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n    vec3 rd = normalize(vec3(lookAt * vec4(uv, 2.0, 1.0)));\n    \n    vec2 info = intersect(ro, rd);\n    vec3 pos = ro + rd * info.x;\n    vec3 n = getNormal(pos);\n    \n    float ambient = 1.0;\n    float diffuse = max(dot(n, sunDir), 0.0);\n    float back = max(dot(n, vec3(-sunDir.x, 0.0, -sunDir.z)), 0.0);\n    float dome = 0.2 + 0.8 * clamp(rd.y, 0.0, 1.0);\n    float sol = 0.2 + 0.8 * clamp(-rd.y, 0.0, 1.0);\n    \n    vec3 light = vec3(0.0);\n    light += ambient * vec3(0.0304, 0.03, 0.02);\n    light += diffuse * vec3(0.30, 0.30, 0.3);\n    light += back * vec3(0.3, 0.37, 0.3);\n    light += dome * vec3(0.515, 0.51, 0.51);\n    light += sol * vec3(0.21, 0.2, 0.2);\n    \n    if (info.y < -0.5) {\n        light = vec3(1.0);\n    }\n    vec3 color = getColor(info.y, pos, rd) * light;\n    color = mix(color, getSkyColor(pos, rd), clamp(pow(info.x / 20.0, 2.0), 0.0, 1.0));\n    color = pow(color, vec3(0.4545));\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WssfzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 70, 70, 90], [92, 92, 113, 113, 306], [308, 308, 333, 333, 555], [557, 557, 577, 577, 749], [751, 751, 785, 785, 1053], [1055, 1055, 1090, 1090, 1320], [1322, 1322, 1364, 1364, 1510], [1512, 1512, 1538, 1538, 1796], [1798, 1798, 1853, 1853, 3253]], "test": "untested"}
{"id": "3ssfz4", "name": "Alpha-premultiplied", "author": "FabriceNeyret2", "description": "Many games either have color bleeding at leaves border or switch off MIPmap&interp.\nLeft:   interpolate or MIPmap RGBA texture , then apply transparency & blend.\nRight: alpha-premultiply colors then interpolate or MIPmap aRaGaBA texture  then blend.", "tags": ["interpolation", "tuto"], "likes": 15, "viewed": 978, "published": 3, "date": "1587813215", "time_retrieved": "2024-07-30T21:10:35.906530", "image_code": "vec4 Bg = vec4(0,.8,1,1);                // Background color\nvoid mainImage( out vec4 O, vec2 u) {\n    vec2 U = 4.*u/R;\n    O = textureLod(iChannel0,U,2.*floor(U.y));\n    float a = O.a;\n    O = U.x<2. ? a * O + (1.-a) * Bg     //  L: blend( back, front, a )\n               :     O + (1.-a) * Bg  ;  //  R: front was alpha-premultiplied *before* MIPmap\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// --- leaf texture\n// adapted from \"shortest heart\" https://shadertoy.com/view/wtcXR7\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  U = (u+u-R-.5)/R.y, C = u/u - abs(U).x,\n          A = 19. -8.*C,\n          B = 6. -C-C  -8.*C*C + U*16.;\n    O.ag =    C * A*A - B*B ;\n    O.ag = clamp(O/fwidth(O), 0.,1.).gg + .01/abs(U.x); }", "buffer_a_inputs": [], "common_code": "#define R iResolution.xy", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ssfz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 61, 98, 98, 353]], "test": "untested"}
{"id": "tssBzr", "name": "The Mandelbrot Simple", "author": "cevherkarakoc", "description": "A simple mandelbrot imp", "tags": ["fractal", "mandelbrot"], "likes": 1, "viewed": 326, "published": 3, "date": "1587809747", "time_retrieved": "2024-07-30T21:10:36.649543", "image_code": "#define MAX_ITER 150.\n\n// z and c are complex numbers\n// f(z) = z*z + c\nvec2 f(vec2 z, vec2 c) {\n    return vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y) + c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    \n\tvec2 c = uv * 2.5;\n    vec2 z = vec2(0.);\n\n    float iter;\n    for(iter = 0.; iter < MAX_ITER; iter++) {\n    \tz = f(z, c);\n        if(length(z) > 2.) break;\n    }\n\n    float f = iter/MAX_ITER;\n    vec3 col = vec3(f);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tssBzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 72, 96, 96, 158], [160, 160, 217, 217, 543]], "test": "untested"}
{"id": "wdXfzN", "name": "Glitter Depth of Field", "author": "qwert33", "description": "Third step towards building a renderer for https://youtu.be/BtYKDamqo2I?t=334\nMouse click/drag to adjust focal distance.\n\nStep one: https://www.shadertoy.com/view/td2cDy\nStep two: https://www.shadertoy.com/view/tsjyWV", "tags": ["dof", "glitter"], "likes": 5, "viewed": 640, "published": 3, "date": "1587807672", "time_retrieved": "2024-07-30T21:10:37.385575", "image_code": "\n\nfloat focalPlane; // along the z-axis\n\n#define TAU 6.28318530718\n#define PI TAU/2.\n\nfloat hash13(in vec3 p) {\n    /*\n\tp  = fract(p * .103177);\n    p += dot(p, p.yzx + 1.91979);\n    return fract((p.x + p.y) * p.z);\n\t*/\n    // This hash is slightly cheaper.\n    return fract(sin(dot(p, vec3(12.9898,78.233,7.279237))) * 43758.5453);\n}\n\n// How many cells around the central_cell we check for ellipses.\n#define SAMPLE_RADIUS 2\nconst float num_layers = 50.;\nconst float depth_of_field = 30.; // the distance between in-focus and having a blurRadius of 1.\n\n/*\n// Debugging things.\nconst vec3 default_debug = vec3(-100, -20, -10);\nconst vec3 orange = vec3(1., .5, 0.);\nconst vec3 cornflowerblue = vec3(100./255., 149./255., 237./255.);\nvec3 debug = default_debug;\n*/\n\nfloat monochrome(vec2 uv) {\n    \n    const float cell_wd = 6.0;\n    vec2 central_cell_center = floor((uv+.5*cell_wd) / cell_wd) * cell_wd;\n    \n\tfloat hashTime = iTime + 100.;  // Don't want thing to be synchonous when the shader starts    \n    \n    float acc = 0.;\n    // Painters algorithm.\n    for (float z = 1.0; z>=-0.001; z -= 1./num_layers) {\n        vec2 shifted_central_cell_center = central_cell_center + cell_wd * vec2(\n            hash13(vec3(10.2, 1.13, z)),\n            hash13(vec3(20.3, 2.34, z))\n        );\n        \n        int j;\n        for (int i = -SAMPLE_RADIUS; i<=SAMPLE_RADIUS; ++i) {\n            for (j = -SAMPLE_RADIUS; j<=SAMPLE_RADIUS; ++j) {\n                vec2 cell_center = shifted_central_cell_center + cell_wd*vec2(ivec2(i,j));\n              \t//cell_center = round(cell_center);\n                //cell_center = round(cell_center);\n\n                float hash_z = 10. * z;\n                vec2 cell_hash_pos = cell_center + vec2(1030., 0);\n                float blurRadius = depth_of_field*abs((z+.5*hash13(vec3(cell_hash_pos, ++hash_z))) - focalPlane);\n\n                float yaw = .1*hashTime + TAU * hash13(vec3(cell_hash_pos, ++hash_z));\n                float angular_speed = 3. + hash13(vec3(cell_hash_pos, ++hash_z));\n                vec2 angular_vel = angular_speed * vec2(cos(yaw), sin(yaw));\n                float pitch = length(angular_vel) * hashTime * 0.6;\n                vec2 a = normalize(angular_vel);  // axis of rotation - major axis of projected ellipse.\n                //vec2 b = vec2(-a.y, a.x) * cos(pitch);  // minor axis\n                vec2 ab = vec2(1., abs(cos(pitch)));\n                vec2 extended_ab = ab + vec2(blurRadius);\n\n                mat2 rot = mat2(a.x, -a.y,\n                                a.y, a.x);\n\n                vec3 normal = vec3(0.0, sin(pitch), cos(pitch));\n                mat3 rot3 = mat3(a.x, -a.y, 0.,\n                                 a.y, a.x, 0.,\n                                 0., 0., 1.);\n                normal = rot3 * normal;\n                const vec3 LIGHT_DIR = normalize(vec3(1.5, -1.0, 2.0));\n                float light_per_area = \n                    .2 + // ambient\n                    100.0 * smoothstep(.98, .99, abs(dot(normal, LIGHT_DIR)));  // cheap (wrong-ish) specular\n                float total_light = light_per_area * ab.x * ab.y;  // total amount of light emitted by this object towards all pixels.\n                // Have a random offset from the cell_center.\n                vec2 ellipse_center = cell_center + (.5*cell_wd - ab.x) * vec2(\n                    sin(hashTime * (.01 + .06*hash13(vec3(cell_hash_pos, ++hash_z)))),\n                    cos(hashTime * (.01 + .06*hash13(vec3(cell_hash_pos, ++hash_z))))\n                );\n                vec2 ellipse_uv = uv - ellipse_center;   \n\n                //float sd = sdEllipse(transpose(rot)*inner_uv, extended_ab);\n                //float sd = sdEllipsoidApproximated(transpose(rot)*inner_uv, extended_ab);\n                float sd = length(rot*ellipse_uv / extended_ab) - 1.;  // Signed distance approximation only accurate for values near zero.\n                float proportional_area = extended_ab.x * extended_ab.y;\n                float edge_blurryness = 0.1/length(extended_ab);\n                float is_in_ellipse = smoothstep(edge_blurryness, -edge_blurryness, sd);\n                \n                \n                float opacity = is_in_ellipse * ab.x / extended_ab.x;\n                //acc = mix(acc, total_light / proportional_area, opacity);\n                //if (opacity > .9) debug=orange;\n                acc *= 1.-(opacity*opacity*opacity*opacity*opacity);  // haax to allow dark in-focus objects in front of blurry backgrounds.\n                acc += opacity * total_light / proportional_area;\n            }\n        }\n    }\n\treturn acc;\n}\n\nvec2 project(vec2 pixel) {\n    vec2 uv = pixel/iResolution.xy - vec2(0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv *50.;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    focalPlane = (iMouse.xy == vec2(0.))? .7 : iMouse.x/iResolution.x;\n    vec3 light = vec3(.1,.2,.9) * monochrome(project(fragCoord));\n    light = 1. - exp(-2. * light); // Simulate exposure\n    fragColor = vec4(light, 1.0);\n    //if (debug != default_debug) fragColor.rgb = debug;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXfzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 86, 111, 257, 334], [763, 763, 790, 790, 4591], [4593, 4593, 4619, 4619, 4732], [4735, 4735, 4789, 4789, 5075]], "test": "untested"}
{"id": "WdlfR4", "name": "Flowing Marbled Fractal", "author": "jarble", "description": "Here's another edit of my \"[url=https://www.shadertoy.com/view/wsSyWV]Ink-Marbling Fractal[/url].\"", "tags": ["fractal", "psychedelic", "marbling"], "likes": 2, "viewed": 352, "published": 3, "date": "1587787978", "time_retrieved": "2024-07-30T21:10:38.126594", "image_code": "\n//This parameter changes the number of iterations.\nconst float mag = 9.0;\nconst float GREEN = 0.;\nconst float BLUE = 1.;\nconst float GRAY = 2.;\nconst float YELLOW = 3.;\nconst float WHITE = 4.;\nconst float RED = 5.;\n\n\n//this function is from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n    float num_colors = 5.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return floor(fract((p3.x + p3.y) * p3.z)*num_colors);\n}\n    \n\n\nfloat magnify(vec2 fragCoord,float mag){\n    return hash12(floor(fragCoord/pow(3.0,mag)));\n}\n\nvec4 get_neighbors(vec2 fragCoord,float mag){\n    return vec4(magnify(fragCoord+vec2(0,1),mag),\n        magnify(fragCoord+vec2(1,0),mag),\n        magnify(fragCoord-vec2(0,1),mag),\n        magnify(fragCoord-vec2(1,0),mag));\n}\n\n\nbool is_next_to(float color,vec4 neighbors){\n\treturn (neighbors.x == color)\n        || (neighbors.y == color)\n        || (neighbors.z == color)\n        || (neighbors.w == color);\n}\n\n\n\nvec3 get_color(float color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == RED){\n    \treturn vec3(1.0,0.0,0.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n}\n\nvec3 iterations(float color1,in vec2 fragCoord,float mag){\n    float colors[] = float[](GREEN,BLUE,GRAY,YELLOW,WHITE,RED);\n    float mag1 = mag;\n    vec4 neighbors;\n    vec3 color;\n    float steps = 0.0;\n    while(mag > 1.0){\n        float avg =((100.0+sin((fragCoord.x+iTime*300.0)/(20.0*mag)))*(mag/color1));\n        fragCoord += vec2(sin(fragCoord.y/avg)*10.0,sin(fragCoord.x/(avg))*10.0)*mag*mag;\n\n        neighbors = get_neighbors(fragCoord,mag);\n    color1 = color1 == GREEN && is_next_to(BLUE,neighbors)\n    \t? YELLOW\n    :color1 == BLUE && is_next_to(GREEN,neighbors)\n        ? GREEN\n    :color1 == YELLOW && is_next_to(GRAY,neighbors)\n        ? BLUE\n    :color1 == GRAY && is_next_to(YELLOW,neighbors)\n        ? YELLOW\n    :color1 == WHITE && is_next_to(YELLOW,neighbors)\n        ? GRAY\n    :color1 == GRAY && is_next_to(BLUE,neighbors)\n        ? BLUE\n    :color1;\n\n    color += get_color(color1);\n    //mag -= 1.0+(sin(fragCoord.x+iTime)+cos(fragCoord.y+iTime))*0.0002;\n    mag -= 1.0;\n    steps += 1.0;\n\n    }\n    return color/steps;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord *= mag*(((iMouse.x-iMouse.y)+iResolution.x)/iResolution.x);\n    fragCoord = fragCoord + floor((iTime)*100.0)*vec2(mag,0.0);\n    fragCoord += vec2(sin(fragCoord.y/(100.0*(mag+1000.0)))*10.0,sin(fragCoord.x/(100.0*(mag)))*10.0)*mag*mag;\n\n    float color1 = magnify(fragCoord,mag);\n    //color1 = replace_pattern(mat2(1.0,1.0,1.0,1.0),mat2(0.0,2.0,2.0,0.0),fragCoord,mag);\n\n    vec3 color2 = iterations(color1,fragCoord,mag-1.0);\n\n    fragColor = vec4(color2,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlfR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[218, 280, 302, 302, 529], [537, 537, 577, 577, 629], [631, 631, 676, 676, 855], [858, 858, 902, 902, 1038], [1042, 1042, 1070, 1070, 1484], [2535, 2535, 2591, 2591, 3069]], "test": "untested"}
{"id": "wsXBz4", "name": "Orderly fashion #2", "author": "Plento", "description": "Now they form letters! (kind of) As suggested by Fabrice.", "tags": ["2d", "mouse", "text", "buffer", "particle"], "likes": 16, "viewed": 446, "published": 3, "date": "1587764396", "time_retrieved": "2024-07-30T21:10:38.871602", "image_code": "// Fork of \"Orderly fashion\" by Plento. https://shadertoy.com/view/3slBR8\n// 2020-04-24 19:35:48\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    f = vec4(0);\n    for(int i = 0; i < int(mem); i++){\n        float d = length(u - ch(iChannel0, vec2(i,0.)).xy);\n        f += rad/(d*d);\n    }\n   // f = 1. - exp(-f);\n    //f = mix(f, ch(iChannel1, u), 0.5);\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 R;\n\nvec2 grad(vec2 p){\n    float bB = ch(iChannel1, p).w;\n    float sgdx = bB - ch(iChannel1,p - vec2(1.,0.0)).w;\n    float sgdy = bB - ch(iChannel1,p - vec2(0.0,1.)).w;\n    float theta = atan(sgdy, sgdx);\n    return vec2(cos(theta), sin(theta));\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n    ivec2 iu = ivec2(u);\n    vec2 uv = u / R;\n    \n    if(iu.x <= int(mem) && iu.y == 0){\n        vec4 bA = ch(iChannel0, u); \n        \n        vec2 gDir = grad(bA.xy);\n        \n        bA.x -= gDir.x * 4.;\n        bA.y -= gDir.y * 4.;\n        \n        for(int i = 0; i < int(mem); i++){\n            if( i != iu.x){\n                vec2 subj = ch(iChannel0, vec2(i,0.)).xy;\n     \t\t\tfloat r = max(length(bA.xy - subj), 10.0);\t   \n        \t\t\n                vec2 dir = normalize(bA.xy - subj);\n        \t\tfloat grav = -(g*2.) / (r*r);\n                \n                bA.x -= grav*dir.x*dt;\n                bA.y -= grav*dir.y*dt;\n            }\n    \t}\n        \n        bA.x = clamp(bA.x, R.x*0.15, R.x-R.x*0.15);\n        bA.y = clamp(bA.y, 10., R.y-R.y*.15);\n        \n    \tif(iFrame == 0){\n            if(u.x <= mem && iu.y == 0 ){\n                bA.xy = hash22(u)*R.xy*0.5 + R.xy*0.25;\n                bA.zw = vec2(0.);\n                f = vec4(0);\n            }\n    \t}\n        \n        f = bA;\n    }\n    else return;\n   \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ch(chan, p) texelFetch(chan, ivec2(p), 0)\n#define mem iResolution.x/4.\n\nfloat dt = 0.12;\nfloat g = 640.;\n\nfloat rad = 30.; // particle screen size\n\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n", "buffer_b_code": "vec2 R;\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n    vec2 uv = (u / R) * 1.;\n    uv+=.15;\n    int l = int(mod(iTime*.5, 26.));\n    int i = int[](l + 65)[int(uv)];      \n    f += texture( iChannel0, fract(uv)*.05 + vec2(i,15-i/16)/16. ).w;\n    \n}", "buffer_b_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXBz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 139, 139, 352]], "test": "untested"}
{"id": "tdlfzH", "name": "Colourful Apollonian II", "author": "mla", "description": "Another Apollonian gasket. Mouse, up, down keys to move. p for progressive display, m for mouse, a for animation.", "tags": ["apollonian", "gasket"], "likes": 12, "viewed": 418, "published": 3, "date": "1587755488", "time_retrieved": "2024-07-30T21:10:39.702381", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// More Apollonian circles.\n// Matthew Arcus, mla, 2020\n//\n// <mouse>: move things around\n// <up>/<down>: zoom in/out\n// a: animation\n// p: progressive display\n// m: enable mouse\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst int max_iterations = 20;\nconst float PI = 3.14159265;\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 getCol(vec4 n){\n  if (n.z == float(max_iterations)) return vec3(0);\n  return vec3(1);\n  vec3 col = hsv2rgb(vec3(mod(n.z/20.0,1.0),0.8,0.8));\n  //col *= 0.6+0.4*smoothstep(0.05,0.1,sqrt(n.w));\n  return col;\n}\n\nbool keypress(int code) {\n  return texelFetch(iChannel3, ivec2(code,2),0).x != 0.0;\n}\nvec4 store(int i,int j) {\n  return texelFetch(iChannel2, ivec2(i,j),0);\n}\n\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\nconst int CHAR_A = 65;\nconst int CHAR_D = 68;\nconst int CHAR_H = 72;\nconst int CHAR_J = 74;\nconst int CHAR_M = 77;\nconst int CHAR_P = 80;\nconst int CHAR_V = 86;\nconst int CHAR_Z = 90;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nvec2 cmul(vec2 z, vec2 w) {\n  return vec2(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\nvec2 cinv(vec2 z) {\n  return z/dot(z,z)*vec2(1,-1);\n}\n\nvec2 csqrt(vec2 z) {\n  float r = length(z);\n  return vec2(sqrt(0.5*(r+z.x)),sign(z.y)*sqrt(0.5*(r-z.x)));\n}\n\n#define AA 2.0\n\nconst float r = 1.0/(sqrt(2.0)+1.0);\nconst float R = r*tan(3.0*PI/8.0); // R = 1 in fact\nconst float r0 = r*(sqrt(2.0)-1.0);\nconst vec4 circles1[] =\n  vec4[](vec4(0,0,r0*r0,1.0),\n         vec4(r,r,r*r,1.0),\n         vec4(r,-r,r*r,1.0),\n         vec4(-r,r,r*r,1.0),\n         vec4(-r,-r,r*r,1.0),\n         vec4(0,0,1,-1.0)\n     );\nconst float R0 = r+2.0*R;\nvec4 circles2[] =\n  vec4[](vec4(0,0,r*r,1.0),\n         vec4(0,r+R,R*R,1.0),\n         vec4(0,-r-R,R*R,1.0),\n         vec4(r+R,0,R*R,1.0),\n         vec4(-r-R,0,R*R,1.0),\n         vec4(0,0,R0*R0,-1.0)\n         );\n\nfloat length2(vec2 p) {\n  return dot(p,p);\n}\n\nbool inside(vec2 p, vec4 c) {\n  float r2 = length2(p-c.xy);\n  if (c.w < 0.0) return r2 > c.z;\n  else return r2 <= c.z;\n}\n\nvec2 invert(vec2 p, vec4 c, inout float scale) {\n  p -= c.xy;\n  float s = c.z/dot(p,p);\n  scale *= abs(s);\n  p *= s;\n  p += c.xy;\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  int N = circles1.length();\n  int maxsteps = 20;\n    if (keypress(CHAR_P)) {\n        maxsteps = int(iTime)%40;\n        maxsteps = min(maxsteps,40-maxsteps);\n    }// Progressive stepping\n  vec2 z0 = (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n  float zoom = 3.0;\n  zoom *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  // Transform to put centre at m\n  float aadelta = 1.0/(AA*iResolution.y);\n  vec3 aacol = vec3(0);\n  for (float p = 0.0; p < AA; p++) {\n    for (float q = 0.0; q < AA; q++) {\n      vec2 z = z0 + aadelta*vec2(p,q);\n      z *= zoom;\n      float scale = zoom;\n      if (!keypress(CHAR_M) && iMouse.x > 0.0) {\n        vec2 m = (2.0*iMouse.xy - iResolution.xy)/iResolution.y;\n    \tm *= zoom;\n    \tfloat k = 1.0;\n    \tfloat r = length(m);\n    \tfloat s = 0.5*(-r + sqrt(r*r + 4.0*k));\n    \tvec4 tcircle = vec4(-s/r*m,1,0);\n        z = invert(z,tcircle,scale);\n        z.x = -z.x;\n\t  }\n      if (!keypress(CHAR_A)) {\n        vec4 tcircle = vec4(sin(0.5*iTime),0,1,0);\n        z = invert(z,tcircle,scale);\n        z.x = -z.x;\n      }\n      vec2 z0 = z;\n      int step;\n      for (step = 0; step < maxsteps; step++) {\n        bool found = false;\n        for (int i = 0; i < N; i++) {\n          if (inside(z,circles2[i])) {\n            z = invert(z,circles2[i],scale);\n            found = true;\n            break;\n          }\n        }\n        if (!found) break;\n      }\n      vec3 col = vec3(0);\n      float dmin = 1e10;\n      if (true) {\n        int imin = -1;\n        for (int i = 0; i < N; i++) {\n          vec4 c = circles2[i];\n          float d = abs(length(z-c.xy) - sqrt(c.z));\n          d /= scale;\n          if (d < dmin) {\n            dmin = d;\n            imin = i;\n          }\n        }\n        if (imin >= 0) col = hsv2rgb(vec3(float(imin)/float(6),1,1));\n      }\n      \n      float lwidth = 0.005;\n\n      vec4 tt = texture(iChannel0,0.5*z0);\n      float ds = fwidth(dmin);\n      float t = 1.0-smoothstep(0.0,max(ds,lwidth*(1.0+tt.y)),dmin);\n      col *= tt.x;\n      float t1 = 1.0-t;\n      t1 *= 0.9+0.1*tt.z;\n      vec3 bg = t1*vec3(1,1,0.5);\n      col = mix(bg,0.1+0.9*col,t);\n      aacol += col;\n    }\n  }\n  aacol.xyz /= AA*AA;\n  fragColor = vec4(pow(aacol,vec3(0.4545)),1);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x);\n  int j = int(uv.y);\n  if ( iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (i == 0) {\n    float w1 = keystate(j,2).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      t.x++;\n    }\n  }     \n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlfzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[409, 504, 531, 531, 707], [709, 709, 729, 729, 921], [923, 923, 948, 948, 1008], [1009, 1009, 1034, 1034, 1082], [1084, 1084, 1107, 1107, 1139], [1425, 1425, 1452, 1452, 1507], [1509, 1509, 1528, 1528, 1562], [1564, 1564, 1584, 1584, 1671], [2255, 2255, 2278, 2278, 2299], [2301, 2301, 2330, 2330, 2421], [2423, 2423, 2471, 2471, 2566], [2568, 2568, 2624, 2624, 4842]], "test": "untested"}
{"id": "wdXBz4", "name": "Spiral Offset 3", "author": "Del", "description": "Deeply Trippy Spiral Action :)", "tags": ["spiraltrippysinwibble"], "likes": 9, "viewed": 473, "published": 3, "date": "1587755188", "time_retrieved": "2024-07-30T21:10:40.528173", "image_code": "// non-black screen version - go full screen, keep watching... !!\n\n#define TAU 6.283185\n\nvec2 rot(vec2 v, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c)*v;\n}\n\n// IQ UnevenCapsule distance func\nfloat cro(in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\nfloat sdUnevenCapsule( in vec2 p, in vec2 pa, in vec2 pb, in float ra, in float rb )\n{\n    p  -= pa;\n    pb -= pa;\n    float h = dot(pb,pb);\n    vec2  q = vec2( dot(p,vec2(pb.y,-pb.x)), dot(p,pb) )/h;\n    \n    //-----------\n    \n    q.x = abs(q.x);\n    \n    float b = ra-rb;\n    vec2  c = vec2(sqrt(h-b*b),b);\n    \n    float k = cro(c,q);\n    float m = dot(c,q);\n    float n = dot(q,q);\n    \n         if( k < 0.0 ) return sqrt(h*(n            )) - ra;\n    else if( k > c.x ) return sqrt(h*(n+1.0-2.0*q.y)) - rb;\n                       return m                       - ra;\n}\n\nfloat TimerInOut(vec4 v)\n{\n    return smoothstep(v.y,v.y+v.w,v.x) - smoothstep(v.z-v.w,v.z,v.x);\n}\nfloat Stime(float _t, float scale)\n{\n    return fract(_t*scale)*TAU;\n}\nfloat Mtime(float _t, float mval)\n{\n    return mod(_t,mval);\n}\n\n// Trippy spiral calc - Del 06/01/2018\nvec2 spiral(vec2 uv,float zoom, float len, float offset,vec2 capoff, float trip, float scount,float rmod)\n{\n    float d = length(uv) * zoom;\n    d=log(d*trip);\n    uv = rot(uv,sin(d*offset)+d*scount*rmod);\n\tfloat v = 1.0-sdUnevenCapsule(uv,vec2(0.0,0.0)+capoff,vec2(0.4*len,0.0)+capoff,0.0,0.4*len)*14.0;\n    return vec2(v,d);\t// dx , dy\n}\n\nvec2 directionalWaveNormal(vec2 p, float amp, vec2 dir, float freq, float speed, float time, float k)\n{\t\n\tfloat a = dot(p, dir) * freq + time * speed;\n\tfloat b = 0.5 * k * freq * amp * pow((sin(a) + 1.0) * 0.5, k) * cos(a);\n\treturn vec2(dir.x * b, dir.y * b);\n}\n\nvec3 summedWaveNormal(vec2 p)\n{\n    float time = iTime;\n\tvec2 sum = vec2(0.0);\n\tsum += directionalWaveNormal(p, 0.5, normalize(vec2(1, 1)), 5.0, 1.5, time, 1.0);\n\tsum += directionalWaveNormal(p, 0.25,normalize(vec2(1.4, 1.0)), 11.0, 2.4, time, 1.5);\n\tsum += directionalWaveNormal(p, 0.125, normalize(vec2(-0.8, -1.0)), 10.0, 2.0, time, 2.0);\n\tsum += directionalWaveNormal(p, 0.0625, normalize(vec2(1.3, 1.0)), 15.0, 4.0, time, 2.2);\n\tsum += directionalWaveNormal(p, 0.03125, normalize(vec2(-1.7, -1.0)), 5.0, 1.8, time, 3.0);\n\treturn normalize(vec3(-sum.x, -sum.y, 1.0));\n}\nvec3 background(vec2 p)\n{\n\tvec3 normal = summedWaveNormal(p);\n\tvec3 c = mix(vec3(0.1, 0.15, 0.1), vec3(0.2, 0.25, 0.4),  dot(normal, normalize(vec3(0.2, 0.2, 0.5))) * 0.5 + 0.5);\n\tc = mix(c, vec3(0.7, 0.9, 1.0), pow(dot(normal, normalize(vec3(-0.4, 0.1, 1.0))) * 0.5 + 0.5, 2.0));\n\tc = mix(c, vec3(0.95, 0.98, 1.0), pow(dot(normal, normalize(vec3(-0.1, -0.3, 0.5))) * 0.5 + 0.5, 10.0));\n    return clamp(c,0.0,1.0);\n}\n\nfloat Bub(vec2 uv,float scale)\n{\n    float time = iTime*0.75;\n    uv.y-=time*2./scale;\n    //uv.x += time*0.2;\n    uv.x+=sin(uv.y+time*.95)*0.025;\t///scale;\n\tuv*=scale;\n    vec2 s=floor(uv);\n    vec2 f=fract(uv);\n    float k=3.0;\n\tvec2 p =.5+.35*sin(11.*fract(sin((s+scale)*mat2(7.0,3.0,6.0,5.0))*5.))-f;\n    float d=length(p);\n    k=min(d,k);\n\tk=smoothstep(0.0,k,sin(f.x+f.y)*0.01);\n   \treturn k;\n}\n\nvec3 Bubbles(vec2 uv,float head,float d)\n{\n\tfloat c = Bub(uv,30.)*.3;\n\tc+=Bub(uv,20.)*.5;\n\tc+=Bub(uv,15.)*.8;\n\tc+=Bub(uv,10.);\n\tc+=Bub(uv,8.);\n\tc+=Bub(uv,6.);\n\tc+=Bub(uv,5.);\n    vec3 scol = vec3(clamp(c*0.3,0.0,0.3));\n    return scol;\n}\n\nvec3 checks(vec2 p)\n{\n    float d = length(p);\n    float head = 1.0-length(p);\n    d+=(0.5+sin(iTime*2.0)*0.5)*0.25;\n    p *= 0.25;\n    return Bubbles(p*(d+0.5), head,d);\n}\n\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat pMod1(inout float p, float size)\n{\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float _t = iTime+2.8;\n    \n\n    // Create some blends over time...\n    float t1 = TimerInOut(vec4(Mtime(_t,9.6),1.0, 7.2, 1.8));\n    float t2 = TimerInOut(vec4(Mtime(_t,12.0),1.0, 9.0, 1.5));\n    float t3 = TimerInOut(vec4(Mtime(_t,21.0),6.0, 14.2, 2.8));\n    float t4 = TimerInOut(vec4(Mtime(_t,60.0),15.0,45.0,1.0));\n    float t5 = TimerInOut(vec4(Mtime(_t,85.0),57.0, 67.0, 3.1));\n    float t6 = TimerInOut(vec4(Mtime(_t,123.0),77.0,101.0,10.0));\n    float t7 = TimerInOut(vec4(Mtime(_t,50.0),28.0,45.0,3.5));\n    float t8 = TimerInOut(vec4(Mtime(_t,20.0),1.0,13.0,3.1));\n    float t9 = TimerInOut(vec4(Mtime(_t,200.0),100.0,159.0,0.5));\n    float t10 = TimerInOut(vec4(Mtime(_t,45.0),21.0,31.0,0.75));\n    float t11 = TimerInOut(vec4(Mtime(_t,30.0),7.0,11.0,0.75));\n    \n    // various spiral modifiers applied over time\n    float t = Stime(_t,0.4);\n    float offset = 25.0 * t1;\n\tfloat zoom = 1.0 + (sin(Stime(_t,0.17))*0.5) * t2;\n    vec2 capoff = vec2(sin(uv.y*4.0+Stime(_t,0.125))*0.25, sin(uv.x*2.0+Stime(_t,0.25))*0.75) * t3;\n    float m = 0.48+sin(Stime(_t,0.15)+uv.y+uv.x)*0.5;\n    float trip = 1.0-(m*t4);\n    float scmod = sin(Stime(_t,0.176));\n    float scount = 5.0+((3.0+(scmod*5.0))*t5);\n\n    float rmod = mix (1.0,sin(Stime(_t,0.1))*2.5,t11);\n\n    // debug... (disable effects)\n    //scount = 5.0;\n    //offset=0.0;\n    //zoom = 1.0;\n    //trip = 1.0;\n    //capoff = vec2(0.0);\n    \n\tvec2 dist = spiral(uv, zoom, t, offset, capoff, trip, scount,rmod);\n    \n    float distmod = 0.49+sin(dist.x*0.34+dist.y*1.6+sin(Stime(_t,.1)))*0.5;\n    dist.x = mix(dist.x, dist.x*distmod, t10);\n    \n//\tfloat v2 = smoothstep(0.5-0.1,0.5+0.1,dist.x);\n//\tfloat v2 = smoothstep(0.0,0.5,dist.x);\n\tfloat v2 = smoothstep(0.0, 1.5*fwidth(dist.x-0.5), dist.x-0.5);\n    \n\tfloat v = mix(v2,clamp(dist.x,0.0,3.0), t6);\n    //vec3 col = vec3(v*1.0-l/t);\n    vec3 col1 = checks(uv);\t////vec3(0.0,0.0,0.2);\n    vec3 col2 = vec3(1.0,0.6,0.5);\n    \n    // rainbow flavour...\n\tcol2 = mix(col2,hsv2rgb_smooth(vec3(fract(iTime*0.2)+dist.x*0.09+dist.y*0.2,0.8,clamp(v,0.35,1.0)))*0.7,t9);\n    \n    vec3 col3 = background(uv);\t//vec3(0.5,0.7,0.5);\n    col1 = mix(col1,col3*0.3, t7);\n    col2 = mix(col2,col3*0.9, t8);\n    //vec3 col = mix(col1,col2,v*1.0-dist.y/t);\n\n    float finalblend = clamp(v*1.0-dist.y/t,0.0,5.0);\n    vec3 col = mix(col1,col2,finalblend);\n\n    // vignette\n \tvec2 q = fragCoord/iResolution.xy;\n    col *= 0.3 + 0.7*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);\n    \n    // utter hack, overlay some coloured circles to show active mods... :)\n    if (iMouse.z>0.5)\n    {\n        uv.xy += 0.05;\n        float c = pMod1(uv.y,0.1);\n        if (c<-3.0)\n        {\n            uv.x -= 0.3;\n            c = pMod1(uv.x,0.1);\n            if (c>=-8.0)\n            {\n                float dd = length(uv)*2.0;\n                dd = 1.0-smoothstep(0.0,0.1,dd);\n                vec3 cf = vec3(0.0);\n                vec3 cc = hsv2rgb_smooth( vec3((c+8.0)/12.0,1.0,dd));\n                if (c<-7.0) cf = cc*t1;\n                else if (c<-6.0) cf = cc*t2;\n                else if (c<-5.0) cf = cc*t3;\n                else if (c<-4.0) cf = cc*t4;\n                else if (c<-3.0) cf = cc*t5;\n                else if (c<-2.0) cf = cc*t6;\n                else if (c<-1.0) cf = cc*t7;\n                else if (c<-0.0) cf = cc*t8;\n                else if (c<1.0) cf = cc*t9;\n                else if (c<2.0) cf = cc*t10;\n                else if (c<3.0) cf = cc*t11;\n                float _mm = smoothstep(0.0,0.1,length(cf)-0.2);\n                col = mix(col,cf,_mm);\n           \t}\n        }\n    }\n    \n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXBz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 120, 120, 206], [208, 242, 276, 276, 304], [305, 305, 391, 391, 878], [880, 880, 906, 906, 978], [979, 979, 1015, 1015, 1049], [1050, 1050, 1085, 1085, 1112], [1114, 1153, 1260, 1260, 1492], [1494, 1494, 1597, 1597, 1755], [1757, 1757, 1788, 1788, 2330], [2331, 2331, 2356, 2356, 2748], [2750, 2750, 2782, 2782, 3149], [3151, 3151, 3193, 3193, 3388], [3390, 3390, 3411, 3411, 3562], [3564, 3564, 3598, 3598, 3776], [3778, 3778, 3818, 3818, 3939], [3941, 3941, 3998, 3998, 7694]], "test": "untested"}
{"id": "WdXfRN", "name": "Newtons fucked up cradle", "author": "run", "description": "Newtons fucked up cradle.\n\nNope it's not broken :) This is what I wanted you to see :)", "tags": ["newtons"], "likes": 6, "viewed": 335, "published": 3, "date": "1587752384", "time_retrieved": "2024-07-30T21:10:41.359949", "image_code": "// based on www.shadertoy.com/view/Xds3zN Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI_16TH 0.39269908169 \n#define HALF_PI 1.57079632679\n#define PI 3.14159265359\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s , float a, float b)\n{\n    mat3 rot1 = mat3(vec3(sin(b),cos(b),0.0), \n                     vec3(cos(b),-sin(b),0.0),\n                     vec3(0.0,0.0,1.0));\n    mat3 rot2 = mat3(vec3(sin(a),0.0,cos(a)), \n                     vec3(0.0, 1.0, 0.0),\n                     vec3(cos(a), 0.0, -sin(a)));\n    p -= rot2*rot1*vec3(0.0,0.9,0.0);\n    return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t , float a)\n{\n  mat3 rot = mat3(vec3(sin(a),0.0,cos(a)), \n                  vec3(0.0, 1.0, 0.0),\n                  vec3(cos(a), 0.0, -sin(a)));\n  \n  p = rot*p;\n  p -= -vec3( 0.0,0.0, 0.0);\n  return length( vec2(length(p.yz)-t.x,p.x) )-t.y;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec2 map( in vec3 pos )\n{\n    pos.z += .7;\n    float time = 2.0 * iTime;\n \tfloat sphere_size = 0.35;\n    vec2 res = vec2(11111111.0,0.0);\n    \n    float balls = 11111111.;\n\n    for( int i=0; i<4; i++ )\n    {\n    \t//res = opU( res, vec2( sdTorus(pos, vec2(0.90,0.01), float(i) * PI_16TH ), 25.0 ) );  \n        //res = opU(res, vec2( sdSphere(    pos, 0.13 , float(i) * PI_16TH, time + PI_16TH * float(i)), time + float(i)));\n        balls = min(balls, sdSphere( pos + vec3(float(i - 2) * sphere_size, 0., 0.), sphere_size / 2. , 0., 0.));\n    }\n    float pendulum = sin(time * 0.6) * .7;\n    //balls = opU(balls, vec2( sdSphere( pos + vec3(2. * sphere_size + sin(pendulum), 0., 1. - cos(pendulum)), sphere_size / 2. , 0., 0.), time));\n    balls = min(balls, sdSphere( pos + vec3(2. * sphere_size + sin(pendulum) * .9, (-1. + cos(pendulum)) * .5, 0.), sphere_size / 2. , 0., 0.));\n    vec3 cp = pos - vec3(0., 0., 0.875);\n    \n    float mount = sdBox( cp, vec3(1., 1., .51) );\n    mount = max(mount, -sdBox( cp - vec3(0., .1, 0.), vec3(2., 1., .42) ));\n    mount = max(mount, -sdBox( cp - vec3(0., -.1, 0.), vec3(.9, 1., 2.) ));\n    \n    vec3 pt = cp;\n    \n    pt.yz -= vec2(.65, .3);\n    pR(pt.yz, .53);\n    mount = min(mount, sdBox( pt - vec3(0., -.1, 0.), vec3(.02, .45, .02) ));\n    pt = cp;\n    \n    pt.yz -= vec2(.65, -.3);\n    pR(pt.yz, -.53);\n    mount = min(mount, sdBox( pt - vec3(0., -.1, 0.), vec3(.02, .45, .02) ));\n    pt = cp;\n    \n    pt.x += sphere_size;\n    pt.yz -= vec2(.65, .3);\n    pR(pt.yz, .53);\n    mount = min(mount, sdBox( pt - vec3(0., -.1, 0.), vec3(.02, .45, .02) ));\n    pt = cp;\n    \n    pt.x += sphere_size;\n    pt.yz -= vec2(.65, -.3);\n    pR(pt.yz, -.53);\n    mount = min(mount, sdBox( pt - vec3(0., -.1, 0.), vec3(.02, .45, .02) ));\n    pt = cp;\n    \n    pt.x -= sphere_size;\n    pt.yz -= vec2(.65, .3);\n    pR(pt.yz, .53);\n    mount = min(mount, sdBox( pt - vec3(0., -.1, 0.), vec3(.02, .45, .02) ));\n    pt = cp;\n    \n    pt.x -= sphere_size;\n    pt.yz -= vec2(.65, -.3);\n    pR(pt.yz, -.53);\n    mount = min(mount, sdBox( pt - vec3(0., -.1, 0.), vec3(.02, .45, .02) ));\n    pt = cp;\n    \n    pt.x -= sphere_size * 2.;\n    pt.yz -= vec2(.65, .3);\n    pR(pt.yz, .53);\n    mount = min(mount, sdBox( pt - vec3(0., -.1, 0.), vec3(.02, .45, .02) ));\n    pt = cp;\n    \n    pt.x -= sphere_size * 2.;\n    pt.yz -= vec2(.65, -.3);\n    pR(pt.yz, -.53);\n    mount = min(mount, sdBox( pt - vec3(0., -.1, 0.), vec3(.02, .45, .02) ));\n    pt = cp;\n    \n    pt.x += sphere_size * 2.;\n    pt.x += sin(pendulum) * 0.3;\n    pt.yz -= vec2(.65, .3);\n    pR(pt.xy, -sin(pendulum));\n    pR(pt.yz, .53);\n    mount = min(mount, sdBox( pt - vec3(0., -.1, 0.), vec3(.02, .45, .02) ));\n    pt = cp;\n    \n    pt.x += sphere_size * 2.;\n    pt.x += sin(pendulum) * 0.3;\n    pt.yz -= vec2(.65, -.3);\n    pR(pt.xy, -sin(pendulum));\n    pR(pt.yz, -.53);\n    mount = min(mount, sdBox( pt - vec3(0., -.1, 0.), vec3(.02, .49, .02) ));\n    pt = cp;\n    \n    \n    return vec2(min(mount, balls), time);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\t\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 0.0 + iTime/3.0;\n    float cra = HALF_PI - clamp(HALF_PI * (cos(time)), 0.0, HALF_PI); // camera rotation angle\n    \n    float y = (0.5 + 0.5 * cos(time))*3.0;\n    \n\t// camera\t\n\tvec3 ro = vec3( 0.0, sqrt(9.0-y*y), y);\n\tvec3 ta = vec3( 0.0, 0.0, 0.0 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXfRN.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[251, 251, 282, 282, 369], [371, 371, 424, 424, 762], [764, 764, 806, 806, 1034], [1036, 1036, 1066, 1066, 1099], [1101, 1101, 1133, 1133, 1175], [1177, 1177, 1202, 1202, 4178], [4180, 4180, 4220, 4220, 4540], [4543, 4543, 4617, 4617, 4878], [4880, 4880, 4912, 4912, 5133], [5135, 5135, 5177, 5177, 5476], [5478, 5478, 5517, 5517, 7088], [7090, 7090, 7142, 7142, 7319], [7321, 7321, 7378, 7378, 8055]], "test": "untested"}
{"id": "tdlBzH", "name": "Library Lost and Found", "author": "dr2", "description": "Transient knowledge ... ", "tags": ["pattern", "architecture", "stairs", "book"], "likes": 15, "viewed": 411, "published": 3, "date": "1587722528", "time_retrieved": "2024-07-30T21:10:42.293453", "image_code": "// \"Library Lost and Found\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Alternating regular and pano images; mouseable - click in upper-right corner to\n  switch image type, lower-right corner for monochrome image.\n*/\n\nfloat PrCylDf (vec3 p, float r, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nfloat Hashfv3 (vec3 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\n\nvec3 bGrid, qHit, ltPos, ltAx, cId;\nfloat dstFar, tCur, tDir, stAng;\nint idObj, stLib;\nbool isPano, colImg;\nconst int idFlr = 1, idCol = 2, idRail = 3, idStr = 4, idShlf = 5, idBk = 6, idLt = 7;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qr;\n  float dMin, d, r, a, s;\n  dMin = dstFar;\n  p -= bGrid * (cId + 0.5);\n  r = length (p.xz);\n  q = p;\n  q.y = 0.5 * bGrid.y - 0.3 - abs (p.y);\n  d = max (q.y, 9.8 - r);\n  DMINQ (idFlr);\n  if (stLib >= 3) {\n    q.xz = abs (q.xz) - 15.;\n    q.y -= 0.1;\n    d = min (length (q.xz) - 0.6, PrCylDf (q.xzy, 1., 0.1));\n    DMINQ (idCol);\n  }\n  if (stLib >= 4) {\n    qr = p;\n    qr.xz = Rot2D (qr.xz, stAng);\n    q = qr;\n    q.xy = Rot2D (q.xy - vec2 (10., -10.), 0.25 * pi);\n    s = mod (q.x, sqrt (2.));\n    d = 0.5 * max (max (q.y - min (s, sqrt (2.) - s), abs (q.z) - 2.), -0.2 - q.y);\n    DMINQ (idStr);\n  }\n  if (stLib >= 5) {\n    q = qr;\n    d = max (length (vec2 (r - 10.2, abs (q.y + 6.) - 1.3)) - 0.13, 2. - abs (qr.z));\n    d = min (d, PrCylDf (vec3 (abs (q.x) - 10., q.y + 7.1, abs (q.z) - 2.).xzy, 0.25, 2.8));\n    q.xz = Rot2D (q.xz, 2. * pi / 32.);\n    a = (r > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.;\n    q.xz = Rot2D (q.xz, 2. * pi * (floor (16. * a + 0.5) / 16.));\n    d = min (d, PrCylDf ((q + vec3 (10.2, + 7.2, 0.)).xzy, 0.13, 2.5));\n    q = qr;\n    q.xy = Rot2D (q.xy, 0.25 * pi);\n    d = min (d, max (length (vec2 (abs (q.y - 2.9) - 0.9, abs (q.z) - 2.)) - 0.13, abs (qr.x) - 10. ));\n    q = qr;\n    q.x += 20.;\n    q.xy = Rot2D (q.xy, 0.25 * pi);\n    d = min (d, max (length (vec2 (abs (q.y - 2.9) - 0.9, abs (q.z) - 2.)) - 0.13, abs (qr.x) - 10.));\n    DMINQ (idRail);\n  }\n  if (stLib >= 6) {\n    q = p;\n    q.y -= -6.7;\n    s = min (abs (q.x), abs (q.z));\n    d = max (max (max (abs (r - 17.) - 1., abs (q.y) - 3.), 5. - s),\n       - max (max (abs (r - 16.) - 1.5, abs (abs (q.y) - 1.4) - 1.2), 5.5 - s));\n    DMINQ (idShlf);\n  }\n  if (stLib == 7 && q.y > 0. || stLib >= 8) {\n    d = max (max (abs (r - 17.) - 0.5, abs (q.y) - 2.8), 5.2 - s);\n    DMINQ (idBk);\n  }\n  if (stLib >= 2) {\n    q = p;\n    q.y -= 9.4;\n    d = length (vec2 (r - 11., q.y)) - 0.3;\n    q.xz = abs (q.xz) - 0.5 * bGrid.xz;\n    d = min (d, PrCylDf (q.xzy, 2., 0.3));\n    DMINQ (idLt);\n  }\n  return dMin;\n}\n\nvoid SetGConf ()\n{\n  stAng = 0.5 * pi * floor (4. * Hashfv2 (cId.xz + vec2 (27.1, 37.1)));\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, rdi, s, cIdP;\n  float dHit, d, eps;\n  eps = 0.0005;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  rdi = 1. / rd;\n  cIdP = vec3 (-99.);\n  dHit = eps;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    p = ro  + dHit * rd;\n    cId = floor (p / bGrid);\n    if (cId != cIdP) {\n      SetGConf ();\n      cIdP = cId;\n    }\n    d = ObjDf (p);\n    s = (bGrid * (cId + step (0., rd)) - p) * rdi;\n    d = min (d, abs (Minv3 (s)) + eps);\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float ao, d;\n  ao = 0.;\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    d = 0.1 + float (j) / 8.;\n    p = ro + d * rd;\n    cId = floor (p / bGrid);\n    SetGConf ();\n    ao += max (0., d - 3. * ObjDf (p));\n  }\n  return 0.5 + 0.5 * clamp (1. - 0.2 * ao, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, bgCol, ltVec, roo, vn;\n  vec2 vf;\n  float dstObj, ltDist, ao, atten, r, s, a, y;\n  int idObjT;\n  bgCol = vec3 (0.05);\n  roo = ro;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    vf = vec2 (0.);\n    if (idObj == idFlr || idObj == idShlf || idObj == idBk) {\n      r = length (qHit.xz);\n      a = (r > 0.) ? atan (qHit.z, - qHit.x) / pi + 0.5 : 0.;\n    }\n    if (idObj == idFlr) {\n      s = length (abs (qHit.xz) - 20.);\n      if (vn.y > 0.99) {\n        col4 = vec4 (0.4, 0.2, 0.1, 0.1) * (1. - 0.3 * Fbm2 (2. * ro.xz));\n        if (stLib >= 4) col4.rgb *= 0.5 + 0.5 * SmoothBump (0.03, 0.97, 0.01, mod (r, 1.));\n        if (stLib >= 2) col4.rgb *= ((1. - 0.3 * smoothstep (1., 5., s)) +\n           (1. - 0.3 * smoothstep (1., 5., r - 11.)));\n        vf = vec2 (32., 1.);\n      } else if (vn.y < -0.99) {\n        col4 = vec4 (vec3 (0.8), -1.);\n        if (stLib >= 3) col4.rgb *= (1. - 0.4 * smoothstep (3., 7., s)) *\n           (1. - 0.4 * smoothstep (0., 4., r - 11.));\n        else col4 = vec4 (vec3 (0.4), 0.1);\n      } else {\n        col4 = vec4 (0.3, 0.3, 0.7, 0.1);\n        vf = vec2 (32., 1.);\n      }\n    } else if (idObj == idCol) {\n      col4 = vec4 (0.7, 0.7, 0.6, 0.05);\n      if (abs (vn.y) < 0.1) {\n        vn.y += 0.1 * sin (2. * pi * 4. * qHit.y);\n        vn = normalize (vn);\n      }\n      vf = vec2 (32., 1.);\n    } else if (idObj == idRail) {\n      col4 = vec4 (0.8, 0.8, 0.85, 0.2);\n      vf = vec2 (32., 0.2);\n    } else if (idObj == idStr) {\n      if (abs (qHit.z) > 1.9) {\n        col4 = vec4 (0.5, 0.55, 0.5, 0.1);\n        vf = vec2 (32., 0.2);\n      } else if (vn.y > -0.01) {\n        col4 = vec4 (0.5, 0.3, 0.1, 0.1) * (1. - 0.2 * Fbm2 (2. * ro.xz));\n        vf = vec2 (32., 0.2);\n      } else {\n        col4 = vec4 (0.6, 0.6, 0.6, -1.);\n      }\n    } else if (idObj == idShlf) {\n      col4 = vec4 (vec3 (0.7, 0.4, 0.2) * (0.5 + 0.5 * Fbm2 ((r > 17.99) ?\n         vec2 (128. * a, 0.5 * qHit.y) :\n         ((abs (vn.y) < 0.01) ? vec2 (4. * r, 0.5 * qHit.y) : vec2 (32. * a, 4. * r)))), 0.1);\n      vf = vec2 (32., 0.1);\n      a = mod (4. * a + 0.5, 1.) - 0.5;\n      if (stLib >= 7 && r > 17.99 && abs (a) < 0.07 && abs (qHit.y - 2.2) < 0.4) {\n        if (ShowInt (vec2 (- 10. * a - 0.5, 0.8 * (qHit.y - 2.)), vec2 (1., 0.25), 4.,\n           dot (mod (vec2 (66., 60.) + cId.xz, 100.), vec2 (100., 1.))) != 0.) \n           col4 = vec4 (0.2, 0.4, 1., -1.);\n      }\n    } else if (idObj == idBk) {\n      a *= 128.;\n      s = Hashfv2 (vec2 (floor (a), 1. + floor (qHit.y / 2.8)));\n      y = mod (qHit.y / 2.8, 1.) / (0.9 - 0.3 * s);\n      if (y < 1.) {\n        a = mod (a, 1.);\n        col4 = vec4 (HsvToRgb (vec3 (mod (Hashfv3 (cId) + 0.2 * s, 1.), 0.7,\n           0.7 * (0.5 + 0.5 * SmoothBump (0.05, 0.95, 0.02, a)))), 0.1);\n        col4.rgb = mix (mix (col4.rgb, vec3 (0.7, 0.7, 0.3), SmoothBump (0.2, 0.25, 0.01, y)),\n           vec3 (0.8, 0.8, 0.2), step (abs (y - 0.5), 0.15) *\n           step (abs (a - 0.5), 0.25) * step (0.5, Noisefv2 (cId.xz * vec2 (19., 31.) +\n           floor (vec2 (16. * a, 16. * qHit.y)))));\n        vn.xz = Rot2D (vn.xz, 0.5 * pi * (a - 0.5));\n      } else {\n        col4 = vec4 (0.1, 0.04, 0., -1.);\n      }\n    } else if (idObj == idLt) {\n      col4 = (stLib >= 3) ? vec4 (vec3 (1., 1., 0.8) * (0.8 - 0.3 * vn.y), -1.) : vec4 (vec3 (0.8), 0.1);\n    }\n    ltVec = roo + ltPos - ro;\n    ltDist = length (ltVec);\n    ltVec /= ltDist;\n    atten = 1.2 / (1. + 0.002 * pow (ltDist, 1.5));\n    if (stLib <= 3 && ! isPano) atten *= 0.05 + 0.95 * smoothstep (0.7, 0.9, dot (ltAx, - ltVec));\n    ao = 1.;\n    if (stLib >= 2 && idObj != idBk) {\n      idObjT = idObj;\n      ao = ObjAO (ro, vn);\n      idObj = idObjT;\n    }\n    if (stLib == 1) vf = vec2 (256., 2.);\n    if (col4.a >= 0.) {\n      if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n      col = col4.rgb * (0.2 + 0.8 * max (dot (vn, ltVec), 0.)) +\n         col4.a * pow (max (dot (normalize (ltVec - rd), vn), 0.), 32.);\n      if (idObj == idBk) col += 0.3 * col4.rgb * (0.6 - 0.4 * dot (normalize (vn.xz),\n         normalize (qHit.xz)));\n      col *= atten;\n    } else col = col4.rgb * (0.2 + 0.8 * atten);\n    col *= ao;\n    col = clamp (mix (bgCol, col, exp (32. * min (0., 0.7 - dstObj / dstFar))), 0., 1.);\n    col = mix (col, vec3 (1.) * Maxv3 (col), 0.2);\n  } else col = bgCol;\n  if (stLib <= 2) col = vec3 (0.95, 0.95, 1.) * Maxv3 (col);\n  if (stLib == 1) col *= (tDir < 0.) ? vec3 (1., 0.2, 0.2) : vec3 (0.2, 1., 0.2);\n  col = clamp (col, 0., 1.);\n  if (! colImg) col = vec3 (0.95, 0.95, 1.) * pow (Maxv3 (col), 0.9);\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col, colF[2];\n  vec2 canvas, uv, ut;\n  float az, el, asp, zmFac, phCyc, tc, t, mb;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  bGrid = vec3 (40., 20., 40.);\n  tc = 0.3 * tCur;\n  colImg = true;\n  isPano = (floor (mod ((tc + 9.5) / 9., 4.)) > 1.); //false;\n  ut = vec2 (mPtr.x, abs (mPtr.y)) + 0.05 * vec2 (1. / asp, 1.) - 0.5;\n  mb = min (ut.x, ut.y);\n  if (mPtr.z > 0. && mb > 0.) {\n    if (mPtr.y > 0.) isPano = ! isPano;\n    else colImg = ! colImg;\n  }\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0. && colImg && ! isPano && mb < 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.7 * pi * mPtr.y;\n  } else {\n    t = 0.04 * tCur;\n    az = 0.6 * pi * (mod (floor (t), 2.) - 0.5) * SmoothBump (0.25, 0.75, 0.15, mod (t, 1.));\n  }\n  el = clamp (el, -0.45 * pi, 0.45 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -1.) + vec3 (0., 9., 4. * tCur);\n  zmFac = isPano ? 0.5 : 1.6;\n  ut = uv;\n  uv /= zmFac;\n  rd = vuMat * normalize (isPano ? vec3 (sin (uv.x + vec2 (0., 0.5 * pi)), uv.y).xzy : \n     vec3 (2. * tan (0.5 * atan (uv.x / asp)) * asp, uv.y, 1.));\n  ltPos = vuMat * vec3 (0., 1., -1.);\n  ltAx = vuMat * vec3 (0., 0., 1.);\n  dstFar = 8. * bGrid.x;\n  for (int k = VAR_ZERO; k < 2; k ++) {\n    t = mod ((tc + float (k)) / 9., 2.);\n    tDir = (2. * floor (t) - 1.) * (1. - abs (t - 1.));\n    stLib = 9 - int (9. * abs (tDir));\n    colF[k] = ShowScene (ro, rd);\n  }\n  col = mix (colF[0], colF[1], smoothstep (0.2, 0.8, fract (tc)));\n  col *= 1. - step (5. * abs (mod ((tc + 0.5) / 9., 2.) - 1.),\n     min (1.5, length (ut * vec2 (1. / asp, 1.))));\n  if (mPtr.z > 0. && min (ut.x - asp, abs (ut.y) - 1.) > -0.1)\n     col = mix (col, vec3 (1., 1., 0.), 0.3);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat DigSeg (vec2 q)\n{\n  return step (abs (q.x), 0.12) * step (abs (q.y), 0.6);\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.5, 2.2);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log (val) / log (10.), 0.) + 0.001) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (idChar == mxChar - nDig - 1. && sgn < 0.) s = ShowDig (q, -1);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlBzH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1035, 1035, 1057, 1057, 3068], [3070, 3070, 3088, 3088, 3162], [3164, 3164, 3197, 3197, 3788], [3790, 3790, 3811, 3811, 4066], [4068, 4068, 4100, 4100, 4371], [4373, 4373, 4408, 4408, 9033], [9035, 9035, 9088, 9088, 10980], [10982, 10982, 11024, 11024, 11075], [11077, 11077, 11134, 11134, 11217], [11219, 11219, 11241, 11241, 11279], [11281, 11281, 11303, 11303, 11341], [11343, 11343, 11379, 11379, 11585], [11587, 11587, 11617, 11617, 11730], [11732, 11732, 11756, 11756, 11873], [11907, 11907, 11931, 11931, 11991], [11993, 11993, 12017, 12017, 12082], [12084, 12084, 12108, 12108, 12220], [12222, 12222, 12247, 12247, 12433], [12435, 12435, 12456, 12456, 12611], [12613, 12613, 12642, 12642, 12854], [12856, 12856, 12895, 12895, 13080], [13082, 13082, 13105, 13105, 13164], [13237, 13237, 13269, 13269, 13811], [13813, 13813, 13873, 13873, 14423]], "test": "untested"}
{"id": "wdlfRH", "name": "Loading Ellipse Flat", "author": "Paltoquet", "description": "A basic loading ellipse for flat design ", "tags": ["loading"], "likes": 1, "viewed": 330, "published": 3, "date": "1587718489", "time_retrieved": "2024-07-30T21:10:43.134205", "image_code": "\n/***\nAuthor: Thibault Ober\nThere is no license attach feel free to enjoy  \n***/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float PI = 3.14159;\n    \n    vec3 color = vec3(0.448,0.800,0.785);\n    vec3 background = vec3(0.418,0.421,0.440);\n    \n    float width = iResolution.x;\n    float height = iResolution.y;\n    float ellipseScale = 2.0;\n    \n    float scale = 1.3;\n    float borderWidthRatio = 0.06;\n    float glowWidthRatio = 1.58;\n    float animationSpeed = 0.42;\n\t\n    float x = (fragCoord.x / iResolution.x);\n    float y = (fragCoord.y / iResolution.y);\n    \n    x = (x * 2.0) - 1.0;\n    y = (y * 2.0) - 1.0;\n    \n\tfloat theta = atan(y, x);\n    float tanTheta = y/x;\n\n    float a = width / scale;\n    float b = height / scale;\n\n    //intersections with the ellipse and the function y = x * tan(theta) https://math.stackexchange.com/questions/22064/calculating-a-point-that-lies-on-an-ellipse-given-an-angle\n    float x1 = a*b / sqrt(b*b + a*a * tanTheta * tanTheta);\n    float y1 = a*b*tanTheta / sqrt(b*b + a*a * tanTheta * tanTheta);\n\n    vec2 point = vec2(x, y) * max(width, height); // work in a square space\n    vec2 pointOnEllipse = vec2(x1, y1);\n\n    float distanceToEllipse = abs(length(pointOnEllipse) - length(point)) / max(width, height);\n    float r = (distanceToEllipse / borderWidthRatio);\n\n    float progress = mod(iTime * animationSpeed, 1.0);\n    float current = (theta + PI); //[0 - 360]\n    current = mod(current + PI / 2.0, 2.0 * PI);  //offset to put the beguining at the top\n    current = current / (2.0 * PI); //ratio for animation\n\t\n    \n    vec3 currentColor = current <= progress  ? color.xyz : background.xyz;\n    float glowRatio = current <= progress ? 1.0 / glowWidthRatio : 3.0;\n\n    if(r < 1.0){\n        fragColor = vec4(currentColor, 1.0);\n    } else {\n        float alpha = 1.0 - (r - 1.0) * glowRatio;\n        fragColor = vec4(vec3(currentColor * alpha), alpha);\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlfRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 140, 140, 1942]], "test": "untested"}
{"id": "wssBz8", "name": "Foam Noise", "author": "TEttinger", "description": "Foam Noise! Really this is just value noise, rotated to match a corner of the appropriate simplex, and domain-warping the next rotation, averaging all results at the end. It's pretty simple but gives nice results with just one octave.", "tags": ["noise", "hash", "foam", "continuous"], "likes": 8, "viewed": 545, "published": 3, "date": "1587709458", "time_retrieved": "2024-07-30T21:10:43.943042", "image_code": "// This Shadertoy ( https://www.shadertoy.com/view/wssBz8 ) shows \"Foam Noise\" by Tommy Ettinger.\n// It's just value noise that's rotated and domain warps the next result.\n\n// Based on a Shadertoy: https://www.shadertoy.com/view/4dS3Wd\n// By Morgan McGuire @morgan3d, http://graphicscodex.com\n// Reuse permitted under the BSD license.\n// The improved value noise is also from a Shadertoy: https://www.shadertoy.com/view/MllBRr\n// By afl_ext, public domain.\n\n// For a single octave\n#define NOISE foam\n\n// For multiple octaves\n//#define NOISE fbm\n#define NUM_NOISE_OCTAVES 1\n\nconst highp float pi          = 3.1415926535;\nconst highp float pi2         = 2.0 * pi;\nconst highp float inf         = 1.0 / 0.0;\nfloat square(float x) { return x * x; }\nfloat infIfNegative(float x) { return (x >= 0.0) ? x : inf; }\n\nconst highp float PHI = 1.61803398874989484820459; // (phi = Golden Ratio)\nconst highp vec2 H2 = vec2(1.324717957244746, 1.754877666246693); // harmonious number for 2D, then its square\nconst highp vec3 H3 = vec3(1.8191725134, 1.6710436067, 1.5497004779); // harmonious 3D\n\nfloat bounce(float x) {\n    float y = fract(x);\n    return mix(y, 1.0 - y, step(fract(x * 0.5), 0.5));\n}\n\nvec2 bounce(vec2 x) {\n    vec2 y = fract(x);\n    return mix(y, 1.0 - y, step(fract(x * 0.5), vec2(0.5)));\n}\n\nfloat hash(float seed, float p) {\n    return bounce(fract((p - seed) * PHI + seed) * (PHI - p));\n//    return fract(fract((p - seed) * PHI + seed) * (PHI - p));\n//    return fract((cos(p * seed + PHI) - sin(p * PHI - seed)) * (31.0 + seed));\n//    float f = floor(p);\n//    float start = sin((cos(f * seed) + sin(f * 1024.)) * 345. + seed);\n//    float end   = sin((cos((f+1.) * seed) + sin((f+1.) * 1024.)) * 345. + seed);\n//    return mix(start, end, smoothstep(0., 1., p - f)) * 0.5 + 0.5;\n}\n\n    //////////WIP comments, feel free to ignore\n    //// old, slow\n//    return fract(dot(sin(seed + hm + p), cos(seed + hm * p)));\n//    const float scale = -1.0 / log(2.125);\n    //// thanks mgsx! https://www.mgsx.net/2015/07/21/006-011-fm-3D-WIP.html\n//    return fract(sin(p * 12.9898 + seed) * 43758.5453 - p - seed);\n\n    //    return acos(fract(sin(p * 12.9898 + seed) * 43758.5453 - p - seed) * 2.0 - 1.0) * (1.0 / pi);\n//    return scale * log(fract(sin(p * 12.9898 + seed) * 43758.5453 - seed) + 1.0) + 1.0;\n    //return pow(0.61803, 3.14159 * fract(sin((p+seed) * 12.9898) * 43758.5453 + (p+seed) * 2.6180339887498949));\n//    return pow(0.61803, 3.14159 * fract(sin(p * 12.9898 + seed) * 43758.5453 - p - seed));\n\n\nfloat hash(float seed, vec2 p) {\n/*\n    p = (fract((p - seed) * PHI + seed) * (PHI - p.yx));\n    p = (fract((p.yx - seed) * PHI + seed) * (PHI - p));\n    return bounce(p.x - p.y);\n*/\n    return fract(4768.1232345456 * sin((p.x+p.y*43.0+seed*137.0)));\n\t//return fract(4768.1232345456 * sin((p.x+p.y*43.0+p.z*137.0+p.w*2666.0)));\n}\n//    return fract((dot((p + seed), HAR) + seed) * (0.5 + fract(length(HAR.yx * p - seed))));\n\n    //////////WIP comments, feel free to ignore\n    //return fract(dot((seed * hm + p.xyx), (seed + hm * p.yxy)) * (0.5 - fract(length(p - seed))));\n    //// faster way, seems better-distributed than the 1D noise, thanks again mgsx\n//    return fract(sin(seed + dot(p, vec2(12.9898,78.233))) * 43758.5453 - length(p + seed));\n//    return acos(fract(sin(seed + dot(p, vec2(12.9898,78.233))) * 43758.5453 - length(p + seed)) * 2.0 - 1.0) * (1.0 / pi);\n    //return pow(0.61803, 3.14159 * fract(sin(seed + dot(p, vec2(12.9898,78.233))) * 43758.5453 - seed));\n    //return pow(0.61803, 3.14159 * fract(sin(seed + dot(p, vec2(12.9898,78.233))) * 43758.5453 + length(p - seed)));\n\nhighp float noise(float seed, float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(seed, i), hash(seed, i + 1.0), u);\n}\n\nhighp float noise(float x) {\n    return noise(42.0, x);\n}\n/*\nfloat noise(float seed, vec2 p)\n{    \n    vec2 i = floor(p);\n\tvec2 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(sin(pi*dot(p,g(seed,i+vec2(0.000000,0.000000)))),\n               \t   sin(pi*dot(p,g(seed,i+vec2(1.000000,0.000000)))),f.x),\n               mix(sin(pi*dot(p,g(seed,i+vec2(0.000000,1.000000)))),\n               \t   sin(pi*dot(p,g(seed,i+vec2(1.000000,1.000000)))),f.x),f.y) * 0.5 + 0.5;\n}\n*/\nhighp float noise(float seed, vec2 x) {\n/*    x.x -= seed;\n    x.y += seed;\n    x *= 0.125;\n    vec2 y = bounce(x.yx + H2);\n    y += (bounce(x * H2 + seed) * (PHI - y));\n    //y -= (bounce(x * H2 - seed) * (PHI - y));\n    return bounce(y.x - y.y + 0.5);\n//    return sin(pi * (y.x - y.y)) * 0.5 + 0.5;\n*/\n/*\n    vec2 y = sin(x * H2) * pi2;\n    y += cos(y * H2 - x.yx);\n    return sin(pi2 * ((y.x - y.y + 0.5) + (PHI + sin((x.y - x.x - 0.5) * pi2)))) * 0.5 + 0.5;\n*/    \n//    const highp vec2 step = vec2(43.0, 59.0);\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(seed, i);\n    float b = hash(seed, i + vec2(1.0, 0.0));\n    float c = hash(seed, i + vec2(0.0, 1.0));\n    float d = hash(seed, i + vec2(1.0, 1.0));\n/*\n    float n = dot(i, step);\n\n    float a = hash(seed, n);\n    float b = hash(seed, n + dot(step, vec2(1.0, 0.0)));\n    float c = hash(seed, n + dot(step, vec2(0.0, 1.0)));\n    float d = hash(seed, n + dot(step, vec2(1.0, 1.0)));\n*/\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nhighp float noise(vec2 x) {\n    return noise(42.0, x);\n}\n\n\nhighp float noise(float seed, vec3 x) {\n    const highp vec3 step = vec3(59.0, 43.0, 37.0);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(seed, n                              ), hash(seed, n + dot(step, vec3(1., 0., 0.))), u.x),\n                   mix( hash(seed, n + dot(step, vec3(0., 1., 0.))), hash(seed, n + dot(step, vec3(1., 1., 0.))), u.x), u.y),\n               mix(mix( hash(seed, n + dot(step, vec3(0., 0., 1.))), hash(seed, n + dot(step, vec3(1., 0., 1.))), u.x),\n                   mix( hash(seed, n + dot(step, vec3(0., 1., 1.))), hash(seed, n + dot(step, vec3(1., 1., 1.))), u.x), u.y), u.z);\n}\n\nhighp float noise(vec3 x) {\n    return noise(42.0, x);\n}\n\nhighp float foam(float seed, float x) {\n    return noise(seed, x);\n}\n\nhighp float foam(float x) { return foam(61.0, x); }\n\nhighp float foam(float seed, vec2 x) {\n    highp vec3 p = vec3(x.x, dot(x, vec2(-0.5, 0.8660254037844386)), dot(x, vec2(-0.5, -0.8660254037844386)));\n    float a = noise(seed, p.yz);\n    float b = noise(seed + 1.0, p.xz + a * 0.5);\n    float c = noise(seed + 2.0, p.xy + b * 0.5);\n    return smoothstep(0.0, 1.0, (a + b + c) * (1.0 / 3.0));\n}\n\nhighp float foam(vec2 x) { return foam(61.0, x); }\n\nhighp float foam(float seed, vec3 x) {\n    highp vec4 p = vec4(x.x, \n                  dot(x.xy, vec2(-0.3333333333333333, 0.9428090415820634)),\n                  dot(x, vec3(-0.3333333333333333, -0.4714045207910317, 0.816496580927726)),\n                  dot(x, vec3(-0.3333333333333333, -0.4714045207910317, -0.816496580927726)));\n    float a = noise(seed, p.yzw);\n    float b = noise(seed + 42.0, p.xzw + a * 0.5);\n    float c = noise(seed + 84.0, p.xyw + b * 0.5);\n    float d = noise(seed + 126.0, p.xyz + c * 0.5);\n    return smoothstep(0.0, 1.0, \n           smoothstep(0.0, 1.0, (a + b + c + d) * 0.25)\n           );\n}\n\nhighp float foam(vec3 x) { return foam(61.0, x); }\n\nfloat fbm(float x) {\n\tfloat v = 0.0;\n\tfloat a = 0.6666;\n\tfloat seed = 61.0;\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * foam(seed, x);\n        seed += 42.0;\n\t\tx = x * 2.0 + seed;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.6666;\n\tfloat seed = 61.0;\n\t// Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * foam(seed, x);\n        seed += 42.0;\n\t\tx = rot * x * 2.0 + seed;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.6666;\n\tfloat seed = 61.0;\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * foam(seed, x);\n        seed += 42.0;\n\t\tx = x * 2.0 + seed;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// Visualization:\n\n// C = sphere center, r = sphere radius, P = ray origin, w = ray direction\nfloat  intersectSphere(vec3 C, float r, vec3 P, vec3 w) {\t\n\tvec3 v = P - C;\n\tfloat b = -dot(w, v);\n\tfloat c = dot(v, v) - square(r);\n\tfloat d = (square(b) - c);\n\tif (d < 0.0) { return inf; }\t\n\tfloat dsqrt = sqrt(d);\n\t\n\t// Choose the first positive intersection\n\treturn min(infIfNegative((b - dsqrt)), infIfNegative((b + dsqrt)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\thighp float v = 0.0;\n\t\n\t// Visualize 1D, 2D, and 3D\n\tif (fragCoord.y > iResolution.y / 2.0) {\n\t\tif (fragCoord.x < iResolution.x / 2.0) {\n\t\t\t// 1D\n\t\t    float coord = fragCoord.x * 0.05 + iTime * 5.0 - 10.0;\n\t\t\tfloat height = NOISE(coord) * iResolution.y / 2.0;\n\t\t\tv = clamp((height - fragCoord.y + iResolution.y / 2.0) / (iResolution.y * 0.02), 0.0, 1.0);\n\t\t} else if (fragCoord.x < iResolution.x / 2.0 + 1.0) {\n\t\t\tfragColor.rgb = vec3(1.0);\n\t\t\treturn;\n\t\t} else {\n\t\t\t// 2D\n\t\t\tvec2 coord = fragCoord.xy * 0.125 - vec2(iTime * 5.0, iResolution.y * 0.5);\n\t\t\tv = NOISE(coord);\n\t\t}\n\t} else if (fragCoord.y > iResolution.y / 2.0 - 1.0) {\n\t\tfragColor.rgb = vec3(1.0);\n\t\treturn;\n\t} else {\n\t\t// Ray-sphere\n\t\tconst float verticalFieldOfView = 25.0 * pi / 180.0;\n\t\t\t\n\t    vec3 P = vec3(sin(iTime) * 2.0, 0, 5.0);\n\t\tvec3 w = normalize(vec3(fragCoord.xy - iResolution.xy / vec2(2.0, 4.0), \n\t\t\t\t\t\t\t\t(iResolution.y / 2.0) / (-2.0 * tan(verticalFieldOfView / 2.0))));\n\n\t\tfloat t = min(intersectSphere(vec3(0, 0, 0), 1.0, P, w),\n\t\t\t\t\t  intersectSphere(vec3(0, -2000, 0), 2000.0 - 1.0, P, w));\n\t\tif (t < inf) {\n\t\t\tvec3 X = P + w * t;\n\t\t\t// Fake lighting to make surfaces appear nicely\n\t\t\tv = NOISE(X * 10.0) * clamp(X.y * 0.75 + 1.0 - min(X.z * 0.05, 0.0), 0.0, 1.0) + \n\t\t\t\tclamp((length(X.xz) - 0.75) * 0.15, 0.0, 0.1);\n\t\t} else {\n\t\t\t// Background\n\t\t\tv = 0.5;\n\t\t}\n\t}\n\n    fragColor.rgb = vec3(v);\n//    fragColor.rgb = vec3(pow(v, 0.375));\n//    fragColor.rg += foam(1999.0, fragCoord.xy * 0.25) * 0.0625;\n//    fragColor.g += foam(97.0, fragCoord.xy * 0.375) * 0.0625;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wssBz8.jpg", "access": "api", "license": "bsd-new", "functions": [[705, 705, 728, 728, 744], [745, 745, 775, 775, 806], [1082, 1082, 1105, 1105, 1186], [1188, 1188, 1209, 1209, 1295], [1297, 1297, 1330, 1330, 1791], [2520, 2520, 2552, 2702, 2849], [7594, 7594, 7614, 7614, 7814], [7817, 7817, 7836, 7836, 8137], [8140, 8140, 8159, 8159, 8359], [8468, 8543, 8600, 8600, 8874], [8876, 8876, 8933, 8933, 10489]], "test": "untested"}
{"id": "tdlBz8", "name": "RGB like you mean it", "author": "ShaderPrankster", "description": "An experiment on WebGL RT, which is more about weird ray stuff. I was learning about doing raytracing on shaders and then that somehow resulted in this.", "tags": ["raytracing", "sphere", "rgb"], "likes": 1, "viewed": 276, "published": 3, "date": "1587706149", "time_retrieved": "2024-07-30T21:10:44.698024", "image_code": "//RT code based on https://www.shadertoy.com/view/ldS3DW by kig\n//Credit should go to this creator, all I did was playing around XD\n\nfloat sphere(vec3 ray, vec3 dir, vec3 center, float radius)\n{\n\tvec3 rc = ray-center;\n    \n\tfloat c = dot(rc, rc) - (radius*radius);\n\tfloat b = dot(dir, rc);\n\tfloat d = b*b - c;\n    \n\tfloat t = -b - sqrt(abs(d));\n\tfloat st = step(0.0, min(t,d));\n    \n\treturn mix(-1.0, t, st);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-1.0 + 2.0*fragCoord.xy / iResolution.xy) * \n\t\tvec2(iResolution.x/iResolution.y, 1.0);\n    \n\tvec3 ro = vec3(0.0, sin(iTime) * 0.5, -2.0);\n\tvec3 rd = normalize(vec3(uv, 1.0));\n\tvec3 p = vec3(cos(iTime) * 0.6, sin(iTime) * 0.4, 0.0);\n    \n\tfloat t = sphere(ro, rd, p, abs(cos(iTime) * 0.8));\n\tvec3 nml = normalize(p - (ro+rd*t));\n    \n\trd = reflect(rd, nml);\n    \n\tvec3 col = vec3(cos(iTime), sin(iTime), sin(iTime) * cos(iTime)) * rd;\n\tfragColor = vec4( mix(vec3(uv, rd.x * rd.z), col, step(0.0, t)), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlBz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[133, 133, 194, 194, 410], [412, 412, 469, 469, 990]], "test": "untested"}
{"id": "tdsfR8", "name": "Julia Walk", "author": "eiffie", "description": "Just killing time during lockdown. The \"music\" took longer than the rest.", "tags": ["julia", "fractalmuz"], "likes": 11, "viewed": 457, "published": 3, "date": "1587701215", "time_retrieved": "2024-07-30T21:10:45.442035", "image_code": "//Years go I did a painter's walk around the brot but following the perpendicular\n//to the normal works ok if you also nudge toward the surface. \n//If I remember correctly this has already been done on Shadertoy... somewhere??\n//Anyway this was just an excuse to use some new fractal \"music\" code.\nconst float iters=64.0;\nfloat DE(vec2 z,vec2 c){\n  float m=0.0;\n  for(float n = 0.0; n < iters; n+=1.0) {\n   z=vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y)+c;\n   m=n;if(dot(z,z)>4.0)break;\n  }return (iters-m+1.33*log(log(dot(z,z))))/iters;\n}\nvoid mainImage(out vec4 O, in vec2 U){\n  U.y=iResolution.y-U.y;\n  vec2 uv=(2.0*U.xy-iResolution.xy)/iResolution.x;\n  vec2 c=texture(iChannel0,vec2(0.5,0.5)/iResolution.xy).xy;\n  float dp=1.0;vec2 rz=iResolution.xy*0.2;\n  if(U.x<rz.x && U.y<rz.y){\n    uv=(2.0*U.xy-rz)/rz.x;uv+=vec2(-0.5,sign(c.y)*0.5);\n    dp=smoothstep(0.0,15.0/rz.x,length(c-uv));c=uv;\n  }\n  float d=DE(uv,c);if(d!=d)d=0.0;//isnan\n  O=vec4(d,min(dp,d),d,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "//am I the only one making shaders where the sound buffer is longer than the others combined?\n#define bps 4.0\nfloat rnd(float t){return fract(sin(mod(t,32.123)*32.123)*41.123);}\nvec2 nofs(float n){//the song's \"random\" ring\n  float r=0.5+0.5*rnd(floor(n));//random volume as well\n  n=mod(n,8.0);\n  if(n<1.0)n= 5.0;\n  else if(n<2.0)n= 3.0;\n  else if(n<3.0)n= -6.0;\n  else if(n<4.0)n= 6.0;\n  else if(n<5.0)n= 0.0;\n  else if(n<6.0)n= -4.0;\n  else if(n<7.0)n= -3.0;\n  else n=3.0;\n  return vec2(n,r);\n}\nfloat scale(float note){//throws out dissonant tones\n float n2=mod(note,12.);\n //if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//major\n if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//minor\n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100;//pentatonic minor\n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100.;//blues \n //if((n2==1.)||(n2==2.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//country\n //if((n2==1.)||(n2==4.)||(n2==7.)||(n2==10.))note=-100.;//diminished whole/half\n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//pentatonic major\n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//harmonic minor\n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//melodic minor ascending\n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//whole tone\n //if((n2==2.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//diminished half/whole\n //if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//mixolydian  \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//dorian\n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==10.))note=-100.;//lydian  \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian\n //if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian Major\n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//locrian\n //if((n2==2.)||(n2==4.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//lydian dominant\n //if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//double harmonic\n //if((n2==2.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.))note=-100.;//enigmatic\n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//neapolitan \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//neapolitan minor\n //if((n2==1.)||(n2==4.)||(n2==5.)||(n2==9.)||(n2==10.))note=-100.;//hungarian minor\n return note;\n}\n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2\nfloat ntof(float n){return (n>0.0)?440.0 * pow(2.0, (n - 67.0) / 12.0):0.0;}\nconst float PI=3.14159;\nfloat Cos(float a){return cos(mod(a,PI*2.));}\nfloat Sin(float a){return Cos(a+PI/2.);}\nstruct instr{float att,fo,vibe,vphas,phas,dtun;};\nvec2 I(float n,float t,float bt,instr i){//note,time,bt 0-8,instrument\n float f=ntof(scale(n));if(f<12.)return vec2(0.0);f-=bt*i.dtun;f*=t*PI*2.;\n f=exp(-bt*i.fo)*(1.0-exp(-bt*i.att))*Sin(f+Cos(bt*i.vibe*PI/8.+i.vphas*PI/2.)*Sin(f*i.phas))*(1.0-bt*0.125);\n n+=t;return vec2(f*Sin(n),f*Cos(n));\n}\nvec2 mainSound( in int samp,float time){\n instr epiano=instr(20.0,0.05,1.5,0.1,0.505,0.001);//silly fm synth instruments\n instr sitar=instr(100.0,0.25,0.1,0.0,0.12525,0.0125);\n instr kettledrum=instr(50.0,0.5,4.0,0.75,1.0,0.0125);\n instr hihat=instr(100.0,1.0,100.5,0.0,1.3131,100.0);\n instr ebongo=instr(500.0,2.0,100.5,0.0,1.333,2.0);\n instr bass=instr(20.0,0.2,1.5,0.0,0.2525,0.005);\n float tim=time*bps,b0,b1,b2,t0,t1,t2;\n vec2 a=vec2(0);//accumulator\n for(float i=0.;i<8.;i+=1.){//go back 8 beats and add note tails\n   b0=floor(tim);b1=floor(tim*0.5);b2=floor(tim*0.25);\n   vec2 n2=nofs(b2*0.125)+nofs(b2*0.5)+nofs(b2);//build notes on top of notes like fbm\n   vec2 n1=n2+nofs(b1),n0=n1+nofs(b0);\n   t0=fract(tim)+i;\n   a+=I(n0.x+72.0,time,t0,sitar)*n0.y*0.25;\n   if(mod(i,2.)<1.){//notes that play every 2 beats\n     t1=fract(tim*0.5)*2.0+i;\n     a+=I(n1.x+56.0,time,t1,epiano)*n1.y;\n     a+=I(n1.x+60.0,time,t1,epiano)*n1.y;\n     a+=I(n1.x+63.0,time,t1,ebongo)*n1.y;//needs more ebongo!\n     a+=I(n1.x+73.0,time+Sin(t1*272.0),t1,hihat)*n1.y*0.1;\n     if(mod(i,4.)<1.){//every 4\n       t2=fract(tim*0.25)*4.0+i;\n       a+=I(n2.x+56.0,time,t2,bass)*n2.y*4.0;\n       a+=I(n2.x+48.0,time,t2,kettledrum)*n2.y*4.0;\n     }\n   }\n   tim-=1.;//go back in time to find old notes still decaying\n }\n return clamp(a/24.0,-1.,1.);\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsfR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[322, 322, 346, 346, 528], [529, 529, 567, 567, 959]], "test": "untested"}
{"id": "tslBR8", "name": "xy circular basis", "author": "darknoon", "description": "Just messing with some functions, but I turned it into a nice picture. Trying to make a function that has a lobe jutting out but doesn't have discontinuities.", "tags": ["trippy"], "likes": 2, "viewed": 331, "published": 3, "date": "1587700728", "time_retrieved": "2024-07-30T21:10:46.181059", "image_code": "\nvec3 a = vec3(0.5, 0.5, 0.5);\nvec3 b = vec3(0.5, 0.5, 0.5);\nvec3 c = vec3(1.0, 1.0, 1.0);\nvec3 d = vec3(0.00, 0.33, 0.67);\n\n// isquilez color mapper\nvec3 colorMap(float t) {\n\treturn (a + b * cos(2. * 3.141 * (c * t + d)));\n}\n\n// Working on this as an oriented basis function for CPPNs\nfloat dv(vec2 uv, int am, float angle) {\n    float r = length(uv);\n    \n    float th = atan(uv.y, uv.x);\n    \n    //float rin = 32.;\n    //float rscale = (1.+rin)/rin - 1. / (rin*r + 1.);\n    float rscale = tanh(3.*r*r);\n    \n    float value = 1.8 + rscale * 0.7*cos(float(am)*th + angle) - r;\n    return tanh(value*value);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    float scale = 2.5;\n    \n    float value = 0.0;\n    vec3 color = vec3(0.0);\n    for (int i=0; i<3; i++) {\n    \tfloat v = dv(uv * scale, 1+i, iTime * (0.8 + 0.4*float(i)) * float(i%2-1));\n        value += v;\n        color[i] = v;\n    }\n    //fragColor = vec4(value);\n    //fragColor = vec4(tanh(value));\n    color = mix(color, colorMap(1.5*value + 0.3*iTime), 0.15);\n    fragColor.xyz = color;\n    //fragColor.xyz = colorMap(value);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslBR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 150, 174, 174, 225], [227, 286, 326, 326, 611], [613, 613, 670, 720, 1254]], "test": "untested"}
{"id": "WslfzH", "name": "Crypts of Sand", "author": "Roninkoi", "description": "Voxelized caverns", "tags": ["raymarching", "voxel", "pillars"], "likes": 5, "viewed": 400, "published": 3, "date": "1587693501", "time_retrieved": "2024-07-30T21:10:46.931053", "image_code": "#define PI 3.14159265\n#define MAXIT 80\n#define EPSILON 0.08\n \n#define minx4(a, b) ((a.w) < (b.w) ? (a) : (b))\n#define minx2(a, b) ((a.x) < (b.x) ? (a) : (b))\n \n#define MAT0 0.0\n#define MAT1 1.0\n\nmat3 rotX(float a)\n{\n    return mat3(\n        1., 0., 0.,\n        0., cos(a), -sin(a),\n        0., sin(a), cos(a)\n    );\n}\n \nmat3 rotY(float a)\n{\n    return mat3(\n        cos(a), 0.0, -sin(a),\n        0., 1., 0.,\n        sin(a), 0.0, cos(a)\n    );\n}\n \nmat3 rotZ(float a)\n{\n    return mat3(\n        cos(a), -sin(a), 0.,\n        sin(a), cos(a), 0.,\n        0., 0., 1.\n    );\n}\n \nfloat t;\n \nfloat sphere(vec3 r, float a)\n{\n    return length(r) - a;\n}\n \nfloat torus(vec3 r, vec2 a)\n{\n    vec2 p = vec2(length(r.xz) - a.x, r.y);\n    return length(p) - a.y;\n}\n \nfloat plane(vec3 r, vec3 o, vec3 n) {\n    return dot(r - o, n);\n}\n\nfloat cylinder(vec3 r, vec2 a)\n{\n\tvec2 p = abs(vec2(length(r.xz), r.y)) - a;\n\t\n\treturn min(max(p.x, p.y), 0.0) + length(max(p, 0.));\n}\n\nfloat hash(vec2 r) {\n    return fract(sin(dot(r, vec2(15.5921, 96.654654))) * 23626.3663);\n}\n\nfloat box(vec3 r, vec3 a, vec2 s)\n{\n\tr.y *= 0.45;\n\tr.y *= 1. + cos(max(-r.y, 0.)) * 0.05;\n\tr.y -= max(r.y, 0.5) * 0.33;\n\tr.y *= 1. + cos(r.x * 0.3) * cos(r.z * 0.2) * 0.01 * max(r.y, 0.);\n\tr.y *= 1. + round(mod(r.x * 0.105, 1.)) * round(mod(r.z * 0.105, 1.)) * 0.009 * max(r.y, 0.) * hash(r.xz) * hash(r.xz) * 1.5;\n\t\n    vec3 p = (abs(r) - a) - max(abs(r.y) + r.y * r.y * 0.1, 2.) + fract(abs(sin(r.x + 0.05)) + hash(r.xx)) * 4. + fract(abs(sin(r.z))) * 4. - 10.;\n\t\n    return length(max(p, 0.));\n}\n\nfloat shade(vec3 n, vec3 rd)\n{\n    return clamp(max(dot(n, -rd), 0.) + 1., 0., 1.);\n}\n \nvec3 fog(float z, vec3 col, vec3 fogCol)\n{\n    return mix(fogCol, col, exp(-z));\n}\n \nvec2 map(vec3 r)\n{    \n\tr *= rotY(t);\n\tr.z += t * 50.;\n\tr.x += 10. * sin(r.z * 0.015) + 50.;\n\t\n    float b = 0.7;\n    vec3 rr = vec3(0.);\n    rr.x = round(r.x / b) * b;\n    rr.y = round(r.y / b) * b;\n    rr.z = round(r.z / b) * b;\n\t\n    vec2 b1 = vec2(\n        box(mod(rr + 50., 100.) - 50., vec3(2.1, 2.1, 2.1), r.xy),\n        (int(sin(rr.x * 0.1) * 2. + sin(rr.y * 0.1) * 2. + sin(rr.z * 0.1) * 2.) % 2)\n    );\n    \n    return b1;\n}\n \nvec3 matCol(vec2 o)\n{\n    if (o.y == MAT0)\n        return normalize(vec3(0.8, 0.5, .2));\n   \n    if (o.y == MAT1)\n        return normalize(vec3(0.7, 0.55, .2));\n   \n    return vec3(0.);\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    t = -iTime * 0.4;\n   \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n   \n    mat3 cam = rotY(-PI) * rotX(0.3);\n       \n    vec3 ro = vec3(0., 10.0, -20.0);\n    vec3 rd = cam * normalize(vec3(uv * 2., -1.));\n    vec3 r = ro;\n   \n    vec3 bcol = vec3(0.5, 0.5, 0.) * 0.2;\n    vec4 col = vec4(0.);\n    col.rgb = bcol;\n   \n    float sh = 1.;\n   \n    for (int i = 0; i < MAXIT; ++i) {\n        vec2 d = map(r);\n        float z = length(r - ro);\n       \n        if (d.x < EPSILON) {\n            col.rgb = mix(col.rgb, \n\t\t\t\tmatCol(d), \n\t\t\t\tshade(normalize(r), rd));\n            col.rgb = fog(z * 0.02, col.rgb, bcol);\n            break;\n        }\n       \n        d.x *= 0.7 - 0.1 * hash(uv);\n\t\tr += rd * d.x * 0.5;\n       \n        sh = (float(i) / float(MAXIT));\n    }\n   \n    if (sh < 0.5)\n\t\tcol.rgb *= exp(-sh * 2. + 1.);\n   \n    fragColor = vec4(col.rgb, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WslfzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[195, 195, 215, 215, 317], [320, 320, 340, 340, 444], [447, 447, 467, 467, 569], [583, 583, 614, 614, 642], [645, 645, 674, 674, 748], [751, 751, 788, 788, 816], [818, 818, 850, 850, 952], [954, 954, 974, 974, 1046], [1048, 1048, 1083, 1083, 1546], [1548, 1548, 1578, 1578, 1633], [1636, 1636, 1678, 1678, 1718], [2158, 2158, 2179, 2179, 2345]], "test": "untested"}
{"id": "3dByDc", "name": "HW_09_2 XuechengSun_Noise", "author": "hehehaha12138", "description": "HW09 for CIS461 Shadow Noise Scene", "tags": ["3d"], "likes": 1, "viewed": 271, "published": 3, "date": "1587681636", "time_retrieved": "2024-07-30T21:10:47.858573", "image_code": "#define SQUARE_PLANE 0\n#define CUBE 1\n#define SPHERE 2\n#define POINT_LIGHT 0\n#define FOCAL_LENGTH 8.0\n#define FOCAL_RANGE 20.0\nconst float AO_DIST = 0.2;\nconst float FIVETAP_K = 2.0;\n\nconst float FOVY = 3.141569 * 0.25;\nconst int RAY_STEPS = 256;\n\nstruct Intersection {\n    float t;\n    vec3 color;\n    vec3 p;\n    int object; // Assign every object in our scene a unique ID int\n};\n    \nstruct Transform\n{\n\tvec3 trans;\n    vec3 scale;\n    vec3 rotate;\n};\n\nstruct Primitive\n{\n\tint id;\n    Transform transform;\n    vec3 matColor;\n    int primitiveId;\n};\n    \nstruct Light\n{\n\tint id;\n    int typeId;\n    float intensity;\n    Transform transform;\n    vec3 lightColor;\n};\n   \n    \nPrimitive floorSquare;\nPrimitive redWall;\nPrimitive greenWall;\nPrimitive backWall;\nPrimitive ceilingWall;\nPrimitive shortCube;\nPrimitive sphere1;\nLight pointLight;\nPrimitive primitives[7];\nLight lights[1];\n\nvoid initializeCornelBox()\n{\n    \n    \n    // Primitive initialization\n\tfloorSquare.transform.trans = vec3(0, -2.5, 0);\n\tfloorSquare.transform.rotate = vec3(-90, 0, 0);\n\tfloorSquare.transform.scale = vec3(10, 10, 1);\n    floorSquare.primitiveId = SQUARE_PLANE;\n    floorSquare.matColor = vec3(0.85, 0.81, 0.78);\n    primitives[0] = floorSquare;\n    \n    redWall.transform.trans = vec3(5, 2.5, 0);\n\tredWall.transform.rotate = vec3(0, -90, 0);\n\tredWall.transform.scale = vec3(10, 10, 1);\n    redWall.primitiveId = SQUARE_PLANE;\n    redWall.matColor = vec3(0.63, 0.065, 0.05);\n    primitives[1] = redWall;\n    \n    greenWall.transform.trans = vec3(-5, 2.5, 0);\n    greenWall.transform.rotate = vec3(0, 90, 0);\n\tgreenWall.transform.scale = vec3(10, 10, 1);\n    greenWall.primitiveId = SQUARE_PLANE;\n    greenWall.matColor = vec3(0.14, 0.45, 0.091);\n    primitives[2] = greenWall;\n    \n    backWall.transform.trans = vec3(0, 2.5, 5);\n    backWall.transform.rotate = vec3(0, 180,  0);\n\tbackWall.transform.scale = vec3(10, 10, 1);\n    backWall.primitiveId = SQUARE_PLANE;\n    backWall.matColor = vec3(0.85, 0.81, 0.78);\n    primitives[3] = backWall;\n    \n    ceilingWall.transform.trans = vec3(0, 7.5, 0);\n    ceilingWall.transform.rotate = vec3(90, 0, 0);\n\tceilingWall.transform.scale = vec3(10, 10, 1);\n    ceilingWall.primitiveId = SQUARE_PLANE;\n    ceilingWall.matColor = vec3(0.85, 0.81, 0.78);\n    primitives[4] = ceilingWall;\n    \n    shortCube.transform.trans = vec3(-2, -1, 0.75);\n    shortCube.transform.rotate = vec3(0, -17.5, 0);\n\tshortCube.transform.scale = vec3(3, 3, 3);\n    shortCube.primitiveId = CUBE;\n    shortCube.matColor = vec3(0.85, 0.81, 0.78);\n    primitives[5] = shortCube;\n    \n    sphere1.transform.trans = vec3(2, 0, 3);\n    sphere1.transform.rotate = vec3(0, 27.5, 0);\n\tsphere1.transform.scale = vec3(3, 3, 3);\n    sphere1.primitiveId = SPHERE;\n    sphere1.matColor = vec3(0.85, 0.81, 0.78);\n    primitives[6] = sphere1;\n    \n \n    \n    // Light initlaization\n    pointLight.id = 0;\n    pointLight.typeId = POINT_LIGHT;\n    pointLight.intensity = 2.0;\n    pointLight.lightColor = vec3(17, 12, 4);\n    pointLight.transform.trans = vec3(0, 7.0, -2.0);\n    pointLight.transform.rotate = vec3(90, 0, 0);\n    pointLight.transform.scale = vec3(3, 3, 1);\n    \n    return;\n}\n\n\n\nfloat random1( vec3 p ) {\n    return fract(sin((dot(p, vec3(127.1,\n                                  311.7,\n                                  191.999)))) *         \n                 43758.5453);\n}\n\nfloat random1(vec2 n)\n{\n\treturn fract(\n                 sin(\n                     dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvec2 random2(vec2 p)\n{\n\treturn fract(sin(vec2(dot(p, vec2(127.1, 311.7)),\n                          dot(p, vec2(269.5, 183.3))))\n                          * 42121.32);\n}\n\nvec3 random3( vec3 p ) {\n    return fract(sin(vec3(dot(p,vec3(127.1, 311.7, 191.999)),\n                          dot(p,vec3(269.5, 183.3, 765.54)),\n                          dot(p, vec3(420.69, 631.2,109.21))))\n                 *43758.5453);\n}\n\nfloat fbm2D(vec2 n)\n{\n    float result = 0.0f;\n    float persistence = 0.5f;\n    int octaves = 8;\n\n\n\n\n    for(int i = 1; i <= octaves; i++)\n    {\n        float freq = pow(3.0, float(i));\n        float amp = pow(persistence, float(i));\n\n        float x = n.x * freq;\n        float y = n.y * freq;\n\n        float v1 = random1(vec2(floor(x), floor(y)));\n        float v2 = random1(vec2(floor(x) + 1.0, floor(y)));\n        float v3 = random1(vec2(floor(x), floor(y) + 1.0));\n        float v4 = random1(vec2(floor(x) + 1.0, floor(y) + 1.0));\n\n        float i1 = mix(v1, v2, fract(x));\n        float i2 = mix(v3, v4, fract(x));\n\n        result += mix(i1, i2, fract(y)) * amp;\n    }\n    result = pow(result, 2.0);\n    return result;\n}\n\nvec3 pow3D(vec3 p, float power)\n{\n\treturn vec3(pow(p.x, power), pow(p.y, power), pow(p.z, power));\n}\n\nfloat surflet(vec3 p, vec3 gridPoint) {\n    // Compute the distance between p and the grid point along each axis, and warp it with a\n    // quintic function so we can smooth our cells\n    vec3 t2 = abs(p - gridPoint);\n    vec3 t = vec3(1.0) - 6.0 * pow3D(t2, 5.0) - 15.0 * pow3D(t2, 4.0) + 10.0 * pow3D(t2, 3.0);\n    // Get the random vector for the grid point (assume we wrote a function random2\n    // that returns a vec2 in the range [0, 1])\n    vec3 gradient = random3(gridPoint) * 2.0 - vec3(1, 1, 1);\n    // Get the vector from the grid point to P\n    vec3 diff = p - gridPoint;\n    // Get the value of our height field by dotting grid->P with our gradient\n    float height = dot(diff, gradient);\n    // Scale our height field (i.e. reduce it) by our polynomial falloff function\n    return height * t.x * t.y;\n}\n\nfloat PerlinNoise3D(vec3 pos) {\n\tfloat surfletSum = 0.0;\n    \n    int cell = 1;\n    \n\tfor(int dx = 0; dx <= cell; ++dx) {\n\t\tfor(int dy = 0; dy <= cell; ++dy) {\n            for(int dz=0; dz <= cell; ++dz)\n            {\n            \tsurfletSum += surflet(pos, floor(pos) + vec3(dx, dy, dz));\n            }\n\t\t\t\n\t\t}\n\t}\n\treturn surfletSum;\n}\n\n\nfloat WorleyNoise3D(vec3 p) {\n    // Tile the space\n    vec3 pointInt = floor(p);\n    vec3 pointFract = fract(p);\n\n    float minDist = 1.0; // Minimum distance initialized to max.\n\n    // Search all neighboring cells and this cell for their point\n    for(int z = -1; z <= 1; z++)\n    {\n        for(int y = -1; y <= 1; y++)\n        {\n            for(int x = -1; x <= 1; x++)\n            {\n                vec3 neighbor = vec3(float(x), float(y), float(z));\n\n                // Random point inside current neighboring cell\n                vec3 point = random3(pointInt + neighbor);\n\n                // Animate the point\n                point = 0.5 + 0.5 * sin(iTime * 0.01 + 6.2831 * point); // 0 to 1 range\n\n                // Compute the distance b/t the point and the fragment\n                // Store the min dist thus far\n                vec3 diff = neighbor + point - pointFract;\n                float dist = length(diff);\n                minDist = min(minDist, dist);\n            }\n        }\n    }\n    return minDist;\n}\n\nfloat WorleyNoise2D(vec2 p) {\n    // Tile the space\n    p = p * 5.0;\n    vec2 pointInt = floor(p);\n    vec2 pointFract = fract(p);\n\n    float minDist = 1.0; // Minimum distance initialized to max.\n\n    // Search all neighboring cells and this cell for their point\n    int cell = 1;\n   \n    for(int y = -cell; y <= cell; y++)\n    {\n        for(int x = -cell; x <= cell; x++)\n        {\n            vec2 neighbor = vec2(float(x), float(y));\n\n            // Random point inside current neighboring cell\n            vec2 point = random2(pointInt + neighbor);\n\t\t\tpoint = 0.5 + 0.5 * sin(4.2132 * point + iTime);\n            \n            // Animate the point\n            point = 0.5 + 0.5 * sin(iTime * 0.01 + 6.2831 * point); // 0 to 1 range\n\n            // Compute the distance b/t the point and the fragment\n            // Store the min dist thus far\n            vec2 diff = neighbor + point - pointFract;\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    \n    return minDist;\n}\n\nvoid CoordinateSystem(in vec3 v1, out vec3 v2, out vec3 v3) {\n    if (abs(v1.x) > abs(v1.y))\n            v2 = vec3(-v1.z, 0.0, v1.x) / sqrt(v1.x * v1.x + v1.z * v1.z);\n        else\n            v2 = vec3(0.0, v1.z, -v1.y) / sqrt(v1.y * v1.y + v1.z * v1.z);\n        v3 = cross(v1, v2);\n}\n\nvec3 WorleyTangentSpaceNormal(vec3 pos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( WorleyNoise3D(pos + epsilon.yxx) - WorleyNoise3D(pos - epsilon.yxx),\n                            WorleyNoise3D(pos + epsilon.xyx) - WorleyNoise3D(pos - epsilon.xyx),\n                            WorleyNoise3D(pos + epsilon.xxy) - WorleyNoise3D(pos - epsilon.xxy)));\n\n}\n\nvec3 PerlinTangentSpaceNormal(vec3 pos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( PerlinNoise3D(pos + epsilon.yxx) - PerlinNoise3D(pos - epsilon.yxx),\n                            PerlinNoise3D(pos + epsilon.xyx) - PerlinNoise3D(pos - epsilon.xyx),\n                            PerlinNoise3D(pos + epsilon.xxy) - PerlinNoise3D(pos - epsilon.xxy)));\n\n}\n\n    \n    \nmat4 transformMatrix(Transform t)\n{\n\tmat4 translate = mat4(      1.0,       0.0,       0.0, 0.0,\n                                0.0,       1.0,       0.0, 0.0,\n                                0.0,       0.0,       1.0, 0.0,\n                                t.trans.x,       t.trans.y,       t.trans.z, 1.0);\n    \n    float xRot = radians(t.rotate.x);\n    float yRot = radians(t.rotate.y);\n    float zRot = radians(t.rotate.z);\n    \n    mat4 rotateX = mat4(1.0,        0.0,       0.0, 0.0,\n                        0.0,  cos(xRot), sin(xRot), 0.0,\n                        0.0, -sin(xRot), cos(xRot), 0.0,\n                        0.0,        0.0,       0.0, 1.0);\n    \n    mat4 rotateY = mat4(cos(yRot), 0.0, -sin(yRot), 0.0,\n                              0.0, 1.0,        0.0, 0.0,\n                        sin(yRot), 0.0,  cos(yRot), 0.0,\n                              0.0, 0.0,        0.0, 1.0);\n    \n    mat4 rotateZ = mat4( cos(zRot), sin(zRot), 0.0, 0.0,\n                        -sin(zRot), cos(zRot), 0.0, 0.0,\n                               0.0,       0.0, 1.0, 0.0,\n                               0.0,       0.0, 0.0, 1.0);\n    \n    mat4 scale = mat4(      t.scale.x,       0.0,       0.0, 0.0,\n                            0.0,       t.scale.y,       0.0, 0.0,\n                            0.0,       0.0,       t.scale.z, 0.0,\n                            0.0,       0.0,       0.0, 1.0);\n    \n    return translate * rotateX * rotateY * rotateZ * scale;\n}\n\nmat4 rotMat(Transform t)\n{\n\tfloat xRot = radians(t.rotate.x);\n    float yRot = radians(t.rotate.y);\n    float zRot = radians(t.rotate.z);\n    \n    mat4 rotateX = mat4(1.0,        0.0,       0.0, 0.0,\n                        0.0,  cos(xRot), sin(xRot), 0.0,\n                        0.0, -sin(xRot), cos(xRot), 0.0,\n                        0.0,        0.0,       0.0, 1.0);\n    \n    mat4 rotateY = mat4(cos(yRot), 0.0, -sin(yRot), 0.0,\n                              0.0, 1.0,        0.0, 0.0,\n                        sin(yRot), 0.0,  cos(yRot), 0.0,\n                              0.0, 0.0,        0.0, 1.0);\n    \n    mat4 rotateZ = mat4( cos(zRot), sin(zRot), 0.0, 0.0,\n                        -sin(zRot), cos(zRot), 0.0, 0.0,\n                               0.0,       0.0, 1.0, 0.0,\n                               0.0,       0.0, 0.0, 1.0);\n    \n    return rotateX * rotateY * rotateZ;\n}\n\nmat3 TangentToWorld(vec3 nor) {\n\tvec3 tangent, bitangent;\n    CoordinateSystem(nor, tangent, bitangent);\n    return mat3(tangent, bitangent, nor);\n}\n\n// SDF of a sphere\nfloat sphere(vec3 p, Transform trans) {\n    p = vec3(inverse(transformMatrix(trans)) * vec4(p, 1.0));\n    return distance(p, vec3(0.0)) - 0.5f;\n}\n\n// Cube SDF\nfloat cube(vec3 p, Transform cubeTrans)\n{\n\tvec3 q = vec3(abs(inverse(transformMatrix(cubeTrans)) * vec4(p, 1.0))) - vec3(0.5);\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// SquarePlane SDF\nfloat squarePlane(vec3 p, Transform squareTrans)\n{\n    mat4 squareMat = transformMatrix(squareTrans);\n    vec3 planeNormal = vec3(0, 0, 1);\n    vec3 actualPoint = vec3(inverse(squareMat) * vec4(p, 1.0f));    \n\treturn abs(dot(actualPoint, planeNormal));\n}\n\nfloat squarePlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p, n.xyz) + n.w;\n}\n\n\nbool isOnPlane(vec3 p, Transform squareTrans)\n{\n    mat4 squareMat = transformMatrix(squareTrans);\n\tvec3 ap = vec3(inverse(squareMat) * vec4(p, 1.0));\n    if(ap.x < 0.5f && ap.x > -0.5f && ap.y < 0.5f && ap.y > -0.5f)\n    {\n    \treturn true;\n    }\n    else\n    {\n    \treturn false;\n    }\n}\n\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj)\n{\n    float minT = 10000.0;\n    obj = -1;\n    for(int i = 0; i < primitives.length(); i = i + 1)\n    {\n        if(primitives[i].primitiveId == SQUARE_PLANE)\n        {\n            vec4 curNor = normalize(rotMat(primitives[i].transform) * vec4(0.0, 0.0, 1.0, 0.0));\n            float maxOffset = max(max(abs(primitives[i].transform.trans.x), \n                                      abs(primitives[i].transform.trans.y)), \n                                      abs(primitives[i].transform.trans.z));\n            curNor.w = maxOffset;\n        \tt = squarePlane(pos, curNor);\n        }\n        else if(primitives[i].primitiveId == CUBE)\n        {\n        \tt = cube(pos, primitives[i].transform);\n        }\n        else if(primitives[i].primitiveId == SPHERE)\n        {\n        \tt = sphere(pos, primitives[i].transform);\n        }\n        \n       \n        \n        if(t < minT)\n        {\n        \tminT = t;\n            obj = i;\n        }\n    }\n   \n    t = minT;\n}\n\nfloat sceneMap3D(vec3 pos)\n{\n    float minT = 10000.0;\n    float t = minT;\n    for(int i = 0; i < primitives.length(); i++)\n    {\n        if(primitives[i].primitiveId == SQUARE_PLANE)\n        {\n        \tvec4 curNor = normalize(rotMat(primitives[i].transform) * vec4(0.0, 0.0, 1.0, 0.0));\n            float maxOffset = max(max(abs(primitives[i].transform.trans.x), \n                                      abs(primitives[i].transform.trans.y)), \n                                      abs(primitives[i].transform.trans.z));\n            curNor.w = maxOffset;\n        \tt = squarePlane(pos, curNor);\n        }\n        else if(primitives[i].primitiveId == CUBE)\n        {\n        \tt = cube(pos, primitives[i].transform);\n        }\n        \n       \n        if(t < minT)\n        {\n        \tminT = t;\n        }\n    }\n    t = minT;\n    return t;\n}\n\n\nfloat fiveTapAO(vec3 p, vec3 n, float k) {\n    float aoSum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * AO_DIST - sceneMap3D(p + n * i * AO_DIST));\n    }\n    return 1.0 - k * aoSum;\n}\n\nvec3 computeNormal(vec3 pos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj) {\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj);\n        if(abs(m) < 0.01) \n        {\n            return;\n        }\n        \n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nconst vec3 a = vec3(0.5, 0.5, 0.5);\nconst vec3 b = vec3(0.5, 0.5, 0.5);\nconst vec3 c = vec3(2.0, 1.0, 1.0);\nconst vec3 d = vec3(0.5, 0.2, 0.25);\n\nvec3 colorPalette(float t) {\n    return a + b * cos(6.28 * (t * c + d));\n}\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 lightVec, vec3 view) {\n    float lambert = max(0.0, dot(lightVec, n));\n    if(hitObj == -1)\n        return vec3(0.0, 0.0, 0.0);\n    if(hitObj == 3)\n    {\n    \t// Back Wall\n        vec2 worleyPoint = vec2(inverse(transformMatrix(primitives[hitObj].transform)) * vec4(p, 1.0));\n        float worley = WorleyNoise2D(worleyPoint);\n        vec3 worleyColor = colorPalette(worley);\n        vec3 color = primitives[hitObj].matColor * lambert * worleyColor;\n        return color;\n    }\n    \n    if(hitObj == 5)\n    {\n        p = vec3(inverse(transformMatrix(primitives[hitObj].transform)) * vec4(p, 1.0));\n    \tfloat cubePerlin = PerlinNoise3D(p);\n        vec3 perlinColor = colorPalette(cubePerlin + iTime);\n       \tvec3 color = primitives[hitObj].matColor * lambert * perlinColor;\n    \treturn color;\n    }\n    \n    if(hitObj == 6)\n    {\n    \tlambert = max(0.0, dot(lightVec, -n));\n        float sphereFBM = fbm2D(vec2(p + iTime));\n        vec3 fbmColor = colorPalette(sphereFBM + iTime);\n        vec3 color = primitives[hitObj].matColor * lambert * fbmColor;\n    \treturn color;\n    }\n    vec3 color = primitives[hitObj].matColor * lambert * vec3(1.0, 1.0, 1.0);\n    return color;\n    \n}\n\n\nIntersection sdf3D(vec3 dir, vec3 eye) {\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect);\n    \n    isect = isect + 0.01 * nor;\n    //vec3 lightDir = normalize(lightPos - isect);\n    \n    vec3 lightDir = normalize(pointLight.transform.trans - isect);\n    \n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect));\n    \n    vec3 normalAsColor = 0.5 * (nor + vec3(1.0, 1.0, 1.0));\n    \n    return Intersection(t, surfaceColor, isect, hitObj);\n}\n\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\n// Returns direction of ray\nvec3 rayCast(vec3 eye, vec3 ref, vec2 ndc) {\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, vec3(0,1,0)));\n    vec3 U = normalize(cross(R, F)); \n    \n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / iResolution.y;\n    \n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    \n    return normalize(p - eye);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initializeCornelBox();\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    // Convert to range [-1, 1]\n    uv = uv * 2.0 - vec2(1.0, 1.0);\n    \n    vec3 eye = vec3(0, 4, -15);\n    vec3 ref = vec3(0, 2, 0);\n    \n    vec3 rayDir = rayCast(eye, ref, uv);\n    \n    Intersection isect = sdf3D(rayDir, eye);\n    \n    float focalLength = (sin(iTime) *  FOCAL_RANGE +  FOCAL_RANGE) / 2.0;\n\t\n    vec3 focalLine = isect.p - eye;\n    float distance = length(focalLine);\n    float disAlongCamZ = dot(focalLine, normalize(ref - eye));\n    float t = abs(disAlongCamZ - focalLength) / FOCAL_RANGE;\n    \n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(0.5 * (rayDir + vec3(1., 1., 1.)), 1.0);\n    fragColor = vec4(isect.color, t);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dByDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[883, 883, 911, 953, 3172], [3176, 3176, 3201, 3201, 3372], [3374, 3374, 3397, 3397, 3503], [3505, 3505, 3527, 3527, 3674], [3676, 3676, 3700, 3700, 3919], [3921, 3921, 3942, 3942, 4648], [4650, 4650, 4683, 4683, 4750], [4752, 4752, 4791, 4935, 5569], [5571, 5571, 5602, 5602, 5907], [5910, 5910, 5939, 5961, 6934], [6936, 6936, 6965, 6987, 7961], [7963, 7963, 8024, 8024, 8248], [8250, 8250, 8291, 8291, 8629], [8631, 8631, 8672, 8672, 9010], [9022, 9022, 9057, 9057, 10481], [10483, 10483, 10509, 10509, 11369], [11371, 11371, 11402, 11402, 11519], [11521, 11540, 11579, 11579, 11685], [11687, 11699, 11740, 11740, 11895], [11897, 11916, 11966, 11966, 12170], [12172, 12172, 12209, 12235, 12267], [12270, 12270, 12317, 12317, 12559], [12562, 12562, 12615, 12615, 13569], [13571, 13571, 13599, 13599, 14406], [14409, 14409, 14451, 14451, 14664], [14666, 14666, 14696, 14696, 15015], [15017, 15017, 15081, 15081, 15355], [15503, 15503, 15531, 15531, 15577], [15579, 15579, 15655, 15655, 16813], [16816, 16816, 16856, 16856, 17376], [17379, 17379, 17410, 17410, 17493], [17495, 17523, 17567, 17567, 17897], [17899, 17899, 17956, 17956, 18811]], "test": "untested"}
{"id": "3slBR8", "name": "Orderly fashion", "author": "Plento", "description": "They don't want to  get too close, but they don't want to stray away either", "tags": ["2d", "mouse", "buffer", "particle"], "likes": 7, "viewed": 410, "published": 3, "date": "1587677639", "time_retrieved": "2024-07-30T21:10:48.605576", "image_code": "void mainImage( out vec4 f, in vec2 u ){\n    f = vec4(0);\n    for(int i = 0; i < int(mem); i++){\n        float d = length(u - ch(iChannel0, vec2(i,0.)).xy);\n        f += 1./(d*d);\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 R;\n\nfloat mass = 1.;\nfloat g = 18.;\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n    ivec2 iu = ivec2(u);\n    \n    if(iu.x <= int(mem) && iu.y == 0){\n        vec4 bA = ch(iChannel0, u); \n        \n        for(int i = 0; i < int(mem); i++){\n            if( i != iu.x){\n                vec2 subj = ch(iChannel0, vec2(i,0.)).xy;\n     \t\t\tfloat r = max(length(bA.xy - subj), 10.0);\t   \n        \t\t\n                vec2 dir = normalize(bA.xy - subj);\n        \t\tfloat grav = -(g*2.*mass) / (r*r);\n                \n                bA.z += grav*dir.x*dt;\n                bA.w += grav*dir.y*dt;  \n                \n                bA.x -= step(seperation, r) * stick*dir.x*dt;\n                bA.y -= step(seperation, r) * stick*dir.y*dt;\n            }\n    \t}\n        \n        if(iMouse.z > 0.){\n         \tfloat r = max(length(iMouse.xy - bA.xy), 10.0);\n            vec2 dir = normalize(bA.xy - iMouse.xy);\n            float ef = -(200.*mass) / r;\n            \n            bA.z -= ef*dir.x*dt;\n            bA.w -= ef*dir.y*dt;  \n            \n            f = vec4(0);\n        }\n        \n        bA.z -= 0.0015*bA.z;\n        bA.w -= 0.0015*bA.w;\n        \n        bA.x -= bA.z*dt;\n        bA.y -= bA.w*dt;\n        \n        bA.x = clamp(bA.x, 10., R.x);\n        bA.y = clamp(bA.y, 10., R.y);\n        \n        \n    \tif(iFrame == 0){\n            if(u.x <= mem && iu.y == 0 ){\n                bA.xy = hash22(u)*R.xy;\n                bA.zw = vec2(0.);\n            }\n    \t}\n        \n        f = bA;\n    }\n    else return;\n   \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n#define ss(a, b, t) smoothstep(a, b, t)\n\n#define ch(chan, p) texelFetch(chan, ivec2(p), 0)\n#define mem iResolution.x/4.\n\nfloat dt = 0.2;\n\n// fun parameters\n#define stick 0.6\n#define seperation 200.\n\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slBR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 187]], "test": "untested"}
{"id": "wdfBzn", "name": "Mystery Mountains Bipolar Mashup", "author": "Flexi", "description": "Plane deformation mix with David Hoskins' original [2TC 15] Mystery Mountains\nhttps://www.shadertoy.com/view/llsGW7", "tags": ["2d", "fractal", "simulation", "milkdrop", "beatdetection", "volumebinning", "verletintegration", "springphysics"], "likes": 7, "viewed": 589, "published": 3, "date": "1587677456", "time_retrieved": "2024-07-30T21:10:49.711620", "image_code": "/* This shadertoy features a basic Milkdrop 2.0 shader pipeline clone\n * Get the original Winamp plugin here: http://www.geisswerks.com/about_milkdrop.html\n *\n * Here's a sketch of the basic blurring pipeline:\n * https://twitter.com/Flexi23/status/686583437814317057\n *\n * Buf D not only contains the Buf A and B blur level stack but also a smoothened spectrum pyramid\n * Bind your sound input in Buf D. Currently playing: Kettel - Candace Bouvard (Generate Remix)\n * There's a certain frame history for the spectrum curves for difference analysis. One smoothing operation costs one frame latency.\n * Access the multiple Gaussian levels by calling BlurA and BlurB with a level index int 0..6\n *\n * Uncomment the #bypass or the prepared blur level stack view statement near the end of this document.\n *\n * You can also find a wastefully implemented store for 4096 vec4 values. Just don't overuse them I suppose.\n *\n * The dancing and swimming L-system fractal is only a remake of an earlier script. See https://youtu.be/8ZnXSq_5m_Y\n * This video is over ten years old today: https://youtu.be/4NbY8n66Q9o\n *\n * Includes Quadratic Bezier Stroke (fork) code and Gaussian kernel parameters from mattdesl: https://www.shadertoy.com/view/lts3Df\n *\n * 2019, https://twitter.com/Flexi23\n */\n\nvec4 Cell(int index){\n    return Cell(index, iChannel3);\n}\n\nvec4 vol(int t){\n    float lo = bass(t, iChannel3);\n    float mi = mid(t, iChannel3);\n    float hi = treb(t, iChannel3);\n    return vec4(lo, mi, hi, (lo + mi + hi)*0.333);\n}\n\nfloat spectrum2D(vec2 uv, float thickness, int level)\n{\n    return spectrum2D(uv, thickness, level, iChannel3);\n}\n\nvec4 BlurA(vec2 uv, int level)\n{\n    return BlurA(uv, level, iChannel0, iChannel3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize = 1. / iResolution.xy;\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n    vec2 uv = fragCoord.xy * pixelSize;\n    vec2 uv_aspect = 0.5 + (uv - 0.5)*aspect.yx;\n    vec2 uv_orig = uv;\n    \n\tvec4 C18 = Cell(18); // last one from the Verlet integrated spring simulation support points\n    vec2 uv_warped = vortex_pair_warp(uv, 0.5 - (C18.xy-0.5), -C18.zw/90., iResolution);\n    \n    vec4 rnd0 = Cell(10);\n    vec4 rnd1 = Cell(11);\n    vec4 normalizedVolume = Cell(21)*0.2 + 0.75;\n\tvec4 volume = vol(0, iChannel3);\n    \n    vec4 last_beat_min = Cell(7);\n    vec4 last_beat_max = Cell(8);\n\tvec4 beat_residual = Cell(4);\n    \n    float beat_relative = (beat_residual.w - last_beat_min.w)/(last_beat_max.w - last_beat_min.w);\n\n    float c1 = smoothcircle(uv - aspect.yx*0.5 + rnd1.xy*aspect.yx, aspect, 0.03, 600.);\n    float c2 = smoothcircle(uv - aspect.yx*0.5 + rnd0.xy*aspect.yx, aspect, 0.015, 800.);\n    float c3 = smoothcircle(uv - aspect.yx*0.5 + mix(rnd0.xy, rnd1.xy, beat_relative)*aspect.yx, aspect, 0.005, 1400.);\n    \n    float bassBox = unit_square(0.5 + (uv-vec2(0.125, volume.x)) * 32. * aspect);\n    float midBox = unit_square(0.5 + (uv-vec2(0.5, volume.y)) * 32. * aspect);\n    float trebBox = unit_square(0.5 + (uv-vec2(0.875, volume.z)) * 32. * aspect);\n    \n    fragColor =  mix(fragColor, vec4(1.,0.,0,0), bassBox);\n    fragColor =  mix(fragColor, vec4(0.,1.,0,0), midBox);\n    fragColor =  mix(fragColor, vec4(0.,0.,1,0), trebBox);\n \n    bassBox = unit_square(0.5 + (uv-vec2(0.25, normalizedVolume.x)) * 128. * aspect);\n    midBox = unit_square(0.5 + (uv-vec2(0.5, normalizedVolume.y)) * 128. * aspect);\n    trebBox = unit_square(0.5 + (uv-vec2(0.75, normalizedVolume.z)) * 128. * aspect);\n\n    fragColor =  mix(fragColor, vec4(1.,0.,0,0), bassBox);\n    fragColor =  mix(fragColor, vec4(0.,1.,0,0), midBox);\n    fragColor =  mix(fragColor, vec4(0.,0.,1,0), trebBox);\n     \n    vec4 integratedVolume = Cell(19);\n\n    bassBox = unit_square(0.5 + (uv-vec2(0.125, integratedVolume.x)) * 64. * aspect);\n    midBox = unit_square(0.5 + (uv-vec2(0.5, integratedVolume.y)) * 64. * aspect);\n    trebBox = unit_square(0.5 + (uv-vec2(0.875, integratedVolume.z)) * 64. * aspect);\n  \n    vec4 fader = Cell(22)*8.;\n    \n    float bassFader = knob(0.5 + (uv-vec2(0.25,0.75))*5., aspect, 0.42, 0.5, fader.x);\n    float midFader = knob(0.5 + (uv-vec2(0.5,0.75))*5., aspect, 0.42, 0.5, fader.y);\n    float trebFader = knob(0.5 + (uv-vec2(0.75,0.75))*5., aspect, 0.42, 0.5, fader.z);\n\n    fragColor =  mix(fragColor, vec4(1.,0.,0,0), bassBox);\n    fragColor =  mix(fragColor, vec4(0.,1.,0,0), midBox);\n    fragColor =  mix(fragColor, vec4(0.,0.,1,0), trebBox);\n    \n    bassBox = unit_square(0.5 + (uv-vec2(0.125, 1.-abs(integratedVolume.x-volume.x))) * 64. * aspect);\n    midBox = unit_square(0.5 + (uv-vec2(0.5, 1.-abs(integratedVolume.y-volume.y))) * 64. * aspect);\n    trebBox = unit_square(0.5 + (uv-vec2(0.875, 1.-abs(integratedVolume.z-volume.z))) * 64. * aspect);\n\n    fragColor =  mix(fragColor, vec4(1.,0.,0,0), bassBox);\n    fragColor =  mix(fragColor, vec4(0.,1.,0,0), midBox);\n    fragColor =  mix(fragColor, vec4(0.,0.,1,0), trebBox);\n  \n    fragColor =  mix(fragColor, vec4(1.,0.,0,0), bassFader);\n    fragColor =  mix(fragColor, vec4(0.,1.,0,0), midFader);\n    fragColor =  mix(fragColor, vec4(0.,0.,1,0), trebFader);\n    \n\n    float speed = 0.0225;\n    vec2 rotate_uv = rotozoom(uv_warped, -2.*fader.y*speed, 1., aspect);\n\tvec2 bipolar_uv = wrap_flip(uv_bipolar(0.5 + (rotate_uv-0.5)*2.33*aspect , vec2(0.5,0.), vec2(0.0,0.5), 2., 0.3, fader.xz*speed));\n\n\n    //fragColor = mix(fragColor, vec4(1), BlurB(uv, 0));\n    \n    fragColor =  mix(fragColor, vec4(2.), BlurA(bipolar_uv, 0));\n    fragColor =  mix(fragColor, vec4(1.), BlurA(uv, 0));\n    \n    //// [2TC 15] Mystery Mountains.\n\t// David Hoskins.\n\n\t// Add texture layers of differing frequencies and magnitudes...\n\n    vec4 p=vec4(bipolar_uv ,1,1)-.5,d=p,t;\n    p.z += iTime*20.;d.y-=.4;\n    vec4 c = vec4(0);\n    for(float i=1.5;i>0.;i-=.002)\n    {\n        float s=.5;\n#define F +texture(iChannel1,.3+p.xz*s/3e3)/(s+=s) \n        t = F F F F F;\n        c =1.+d.x-t*i; c.z-=.1;\n        if(t.x>p.y*.007+1.3)break;\n        p += d;\n    }\n    \n    vec4 C12 = Cell(12);\n    vec4 C13 = Cell(13);\n    vec2 s0 = C12.xy;\n    vec2 s1 = C12.zw;\n\tvec2 s2 = C13.xy;\n    vec2 s = C13.zw; // avg of 3\n    \n    bassBox = unit_square(0.5 + (uv+s1) * 64. * aspect);\n    midBox = unit_square(0.5 + (uv+s0) * 64. * aspect);\n    trebBox = unit_square(0.5 + (uv+s2) * 64. * aspect);\n    fragColor =  mix(fragColor, vec4(1.,0.,0,0), bassBox);\n    fragColor =  mix(fragColor, vec4(0.,1.,0,0), midBox);\n    fragColor =  mix(fragColor, vec4(0.,0.,1,0), trebBox);\n\n    vec4 C25 = Cell(25);\n    float box = unit_square((uv-vec2(0.95, 0.5 + C25.x)) * 64. * aspect);\n    fragColor =  mix(fragColor, vec4(0.,1.,1,0), box);\n    box = unit_square((uv-vec2(0.93, 0.5 + C25.y)) * 64. * aspect);\n    fragColor =  mix(fragColor, vec4(0.,1.,1,0), box);\n    box = unit_square((uv-vec2(0.91, 0.5 + C25.z)) * 64. * aspect);\n    fragColor =  mix(fragColor, vec4(0.,1.,1,0), box);\n    box = unit_square((uv-vec2(0.89, 0.5 + C25.w)) * 64. * aspect);\n    fragColor =  mix(fragColor, vec4(0.,1.,1,0), box);\n    float puller = (integratedVolume.x - integratedVolume.z)/2.;\n    box = unit_square((uv-vec2(0.97, 0.5 + puller)) * 64. * aspect);\n    fragColor =  mix(fragColor, vec4(0.,1.,1,0), box);\n    //fragColor = vec4(0);\n    \n    /*\n    fragColor =  mix(fragColor, vec4(0.1), spectrum2D(uv, 0.05, 0));\n    fragColor =  mix(fragColor, vec4(0.2), spectrum2D(uv, 0.04, 1));\n    fragColor =  mix(fragColor, vec4(0.3), spectrum2D(uv, 0.03, 2));\n    fragColor =  mix(fragColor, vec4(0.5), spectrum2D(uv, 0.02, 3));\n    fragColor =  mix(fragColor, vec4(0.8), spectrum2D(uv, 0.01, 4));\n    */\n    \n    fragColor = mix(fragColor, vec4(1), rainbowSpectra(uv, iChannel3)*((1.-beat_relative)*0.75+0.25));\n    \n//    fragColor = vec4(spectrum(uv.x, 0, 3));\n//    fragColor =  mix(fragColor, vec4(1), texture(iChannel3, uv)); // blur level stack\n\n//    fragColor = Cell(2);\n//    fragColor = texture(iChannel2, uv); // see, the upper right quarter is not used yet\n//    fragColor = vec4(1.) * BlurA(uv, 0).z; // single channel\n\n    vec4 vol = Cell(9);\n    float beat = vol.x;\n\tvec4 C22 = Cell(22);\n\tvec4 C23 = Cell(23);\n    vec2 p_bass = C12.xy;\n    vec2 p_mid = C12.zw;\n    vec2 p_treb = C13.xy;\n    vec2 p_vol = C13.zw;\n    \n\tfloat c4 = smoothcircle(uv_aspect - aspect.yx*0.5 + p_bass*aspect.yx, aspect, 0.0025, 800.);\n    float c5 = smoothcircle(uv_aspect - aspect.yx*0.5 + p_mid*aspect.yx, aspect, 0.0025, 800.);\n    float c6 = smoothcircle(uv_aspect - aspect.yx*0.5 + p_treb*aspect.yx, aspect, 0.0025, 800.);\n    \n    float c8 = smoothcircle(uv, aspect, 0.25, 800.)*0.;\n    \n    //fragColor *= (1.-beat_relative)*0.75+0.25;\n    \n    //fragColor =  mix(fragColor, vec4(0.5), mix(BlurB(uv, 1).x*0.5, BlurB(uv, 0).x, c8*0.75));\n    fragColor =  mix(fragColor, vec4(1), c8*0.166);\n    \n    //vec4 rainbow = vec4(hsl2rgb(fract(iTime), 1., 0.5), 0.);\n    //fragColor *= 0.;\n    \n    //fragColor *= 0.;\n    fragColor =  mix(fragColor, vec4(1.-c8), c1*0.5);\n    fragColor =  mix(fragColor, vec4(1.-c8), c2*0.66);\n    fragColor =  mix(fragColor, vec4(1.-c8), c3*0.75);\n    \n    //fragColor *= 0.;\n    fragColor =  mix(fragColor, vec4(1,1,0,0), c4);\n    fragColor =  mix(fragColor, vec4(1,0,1,0), c5);\n    fragColor =  mix(fragColor, vec4(0,1,1,0), c6);\n    \n    vec4 p1 = Cell(14);\n    vec4 p2 = Cell(15);\n    vec4 p3 = Cell(16);\n    vec4 p4 = Cell(18);\n        \n\tfloat c_p1 = smoothcircle(uv_aspect - aspect.yx*0.5 + p1.xy*aspect.yx, aspect, 0.0025, 800.);\n    float c_p2 = smoothcircle(uv_aspect - aspect.yx*0.5 + p2.xy*aspect.yx, aspect, 0.0025, 800.);\n    float c_p3 = smoothcircle(uv_aspect - aspect.yx*0.5 + p3.xy*aspect.yx, aspect, 0.0025, 800.);\n    float c_p4 = smoothcircle(uv_aspect - aspect.yx*0.5 + p4.xy*aspect.yx, aspect, 0.0025, 800.);\n    \n    //fragColor *= 0.;\n    fragColor =  mix(fragColor, vec4(1,0,0,0), c_p1);\n    fragColor =  mix(fragColor, vec4(0,0,1,0), c_p2);\n    fragColor =  mix(fragColor, vec4(0,1,0,0), c_p3); \n\tfragColor =  mix(fragColor, vec4(1), c_p4);\n\n    //fragColor =  mix(fragColor, fragColor*vec4(2.,1.,0,0), beat*1.);\n    \n    // overlaySpline(fragColor, uv, vec4(1,1,1,0.618), p_vol.xy, p1.xy, p2.xy, iResolution);\n    uv = bipolar_uv;\n    overlaySpline(fragColor, uv, vec4(1,1,0,0.618), p_bass.xy, p1.xy, p2.xy, iResolution);\n    overlaySpline(fragColor, uv, vec4(1,0,1,0.618), p_mid.xy, p1.xy, p2.xy, iResolution);\n    overlaySpline(fragColor, uv, vec4(0,1,1,0.618), p_treb.xy, p1.xy, p2.xy, iResolution);\n    overlaySpline(fragColor, uv, vec4(1,1,1,0.618), p2.xy, p3.xy, p4.xy, iResolution);\n    \n    \n    fragColor = mix(fragColor, vec4(1) - fragColor, min(vec4(1), max(vec4(0), pow(c,vec4(1.15)))));\n    \n    \n    \n    // blur level stack\n\t//fragColor =  mix(fragColor*0., vec4(1), texture(iChannel3, uv));\n    \n    \n    // #bypass\n    //fragColor = c;\n    //fragColor = BlurA(uv, 0);\n    //fragColor = BlurB(uv, 0);\n    //fragColor = mix(fragColor, vec4(1), BlurB(uv, 0).a);\n    //fragColor = mix(fragColor*0., vec4(1), BlurB(bipolar_uv, 0));\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// HSL to RGB converter code from http://www.gamedev.net/topic/465948-hsl-shader-glsl-code/\nfloat Hue_2_RGB(float v1, float v2, float vH )\n{\n    float ret;\n    if ( vH < 0.0 )\n        vH += 1.0;\n    if ( vH > 1.0 )\n        vH -= 1.0;\n    if ( ( 6.0 * vH ) < 1.0 )\n        ret = ( v1 + ( v2 - v1 ) * 6.0 * vH );\n    else if ( ( 2.0 * vH ) < 1.0 )\n        ret = ( v2 );\n    else if ( ( 3.0 * vH ) < 2.0 )\n        ret = ( v1 + ( v2 - v1 ) * ( ( 2.0 / 3.0 ) - vH ) * 6.0 );\n    else\n        ret = v1;\n    return ret;\n}\n\nvec3 hsl2rgb(float H, float S, float L){\n    float var_2, var_1, R, G, B;\n    if (S == 0.0)\n    {\n        R = L;\n        G = L;\n        B = L;\n    }\n    else\n    {\n        if ( L < 0.5 )\n        {\n            var_2 = L * ( 1.0 + S );\n        }\n        else\n        {\n            var_2 = ( L + S ) - ( S * L );\n        }\n\n        var_1 = 2.0 * L - var_2;\n\n        R = Hue_2_RGB( var_1, var_2, H + ( 1.0 / 3.0 ) );\n        G = Hue_2_RGB( var_1, var_2, H );\n        B = Hue_2_RGB( var_1, var_2, H - ( 1.0 / 3.0 ) );\n    }\n    return vec3(R,G,B);\n}\n\nbool is_onscreen(vec2 uv){\n    return (uv.x < 1.) && (uv.x > 0.) && (uv.y < 1.) && (uv.y > 0.);\n}\n\n#define pi2_inv 0.159154943091895335768883763372\n#define pi 3.14159265359\n\nvec2 lower_left(vec2 uv)\n{\n    return fract(uv * 0.5);\n}\n\nvec2 lower_right(vec2 uv)\n{\n    return fract((uv - vec2(1, 0.)) * 0.5);\n}\n\nvec2 upper_left(vec2 uv)\n{\n    return fract((uv - vec2(0., 1)) * 0.5);\n}\n\nvec2 upper_right(vec2 uv)\n{\n    return fract((uv - 1.) * 0.5);\n}\n\nvec4 BlurA(vec2 uv, int level, sampler2D bufA, sampler2D bufD)\n{\n    if(level <= 0)\n    {\n        return texture(bufA, fract(uv));\n    }\n\n    uv = upper_left(uv);\n    for(int depth = 1; depth < 8; depth++)\n    {\n        if(depth >= level)\n        {\n            break;\n        }\n        uv = lower_right(uv);\n    }\n\n    return texture(bufD, uv);\n}\n\nvec4 BlurB(vec2 uv, int level, sampler2D bufB, sampler2D bufD)\n{\n    if(level <= 0)\n    {\n        return texture(bufB, fract(uv));\n    }\n\n    uv = lower_left(uv);\n    for(int depth = 1; depth < 8; depth++)\n    {\n        if(depth >= level)\n        {\n            break;\n        }\n        uv = lower_right(uv);\n    }\n\n    return texture(bufD, uv);\n}\n\nvec2 GradientA(vec2 uv, vec2 d, vec4 selector, int level, sampler2D bufA, sampler2D bufD){\n    vec4 dX = BlurA(uv + vec2(1.,0.)*d, level, bufA, bufD) - BlurA(uv - vec2(1.,0.)*d, level, bufA, bufD);\n    vec4 dY = BlurA(uv + vec2(0.,1.)*d, level, bufA, bufD) - BlurA(uv - vec2(0.,1.)*d, level, bufA, bufD);\n    return vec2( dot(dX, selector), dot(dY, selector) );\n}\n\nvec2 GradientB(vec2 uv, vec2 d, vec4 selector, int level, sampler2D bufB, sampler2D bufD){\n    vec4 dX = BlurB(uv + vec2(1.,0.)*d, level, bufB, bufD) - BlurB(uv - vec2(1.,0.)*d, level, bufB, bufD);\n    vec4 dY = BlurB(uv + vec2(0.,1.)*d, level, bufB, bufD) - BlurB(uv - vec2(0.,1.)*d, level, bufB, bufD);\n    return vec2( dot(dX, selector), dot(dY, selector) );\n}\n\nfloat unit_square(vec2 uv, vec2 aspect){\n    uv = 0.5 + (uv - 0.5)/aspect.yx;\n    return (uv.x > 0. && uv.x < 1. && uv.y > 0. && uv.y < 1. ) ? 1. : 0.;\n}\n\nvec2 rot90(vec2 vector){\n    return vector.yx*vec2(1,-1);\n}\n\nvec2 wrap_flip(vec2 uv){\n\treturn vec2(1.)-abs(fract(uv*.5)*2.-1.);\n}\n\nvec2 complex_mul(vec2 factorA, vec2 factorB){\n    return vec2( factorA.x*factorB.x - factorA.y*factorB.y, factorA.x*factorB.y + factorA.y*factorB.x);\n}\n\nvec2 rotozoom(vec2 uv, float ang, float zoom, vec2 aspect){\n    vec2 rot = vec2(cos(ang), sin(ang))*zoom;    \n    return 0.5 + complex_mul((uv - 0.5)*aspect, rot)/aspect;\n}\n\nvec2 spiralzoom(vec2 domain, vec2 center, float n, float spiral_factor, float zoom_factor, vec2 pos){\n    vec2 uv = domain - center;\n    float d = length(uv);\n    return vec2( atan(uv.y, uv.x)*n*pi2_inv + d*spiral_factor, -log(d)*zoom_factor) + pos;\n}\n\nvec2 complex_div(vec2 numerator, vec2 denominator){\n    return vec2( numerator.x*denominator.x + numerator.y*denominator.y,\n                numerator.y*denominator.x - numerator.x*denominator.y)/\n        vec2(denominator.x*denominator.x + denominator.y*denominator.y);\n}\n\nvec2 mobius(vec2 domain, vec2 zero_pos, vec2 asymptote_pos){\n\treturn complex_div( domain - zero_pos, domain - asymptote_pos);\n}\n\n// see https://stackoverflow.com/a/26070411\nfloat atan2(in float y, in float x)\n{\n    bool s = (abs(x) > abs(y));\n    return mix(pi/2.0 - atan(x,y), atan(y,x), s);\n}\n\nvec2 uv_polar(vec2 domain, vec2 center){\n   vec2 c = domain - center;\n   float rad = length(c);\n   float ang = atan2(c.y, c.x);\n   return vec2(ang, rad);\n}\n\nvec2 uv_polar_logarithmic(vec2 domain, vec2 center, float fins, float log_factor, vec2 coord){\n   vec2 polar = uv_polar(domain, center) * vec2(pi2_inv, 1);\n   return vec2(polar.x * fins + coord.x, log_factor*log(polar.y) + coord.y);\n}\n\nvec2 uv_bipolar(vec2 domain, vec2 northPole, vec2 southPole, float fins, float log_factor, vec2 coord){\n   vec2 help_uv = mobius(domain, northPole, southPole);\n   return uv_polar_logarithmic(help_uv, vec2(0.5), fins, log_factor, coord);\n}\n\nfloat unit_square(vec2 uv){\n\treturn float((uv.x < 1.) && (uv.x > 0.) && (uv.y < 1.) && (uv.y > 0.));\n}\n\nfloat circle(vec2 uv, vec2 aspect, float scale){\n    return clamp( 1. - length((uv-0.5)*aspect*scale), 0., 1.);\n}\n\nfloat sigmoid(float x) {\n    return 2./(1. + exp2(-x)) - 1.;\n}\n\nfloat smoothcircle(vec2 uv, vec2 aspect, float radius, float ramp){\n    return 0.5 - sigmoid( ( length( (uv - 0.5) * aspect) - radius) * ramp) * 0.5;\n}\n\nfloat knob(vec2 domain, vec2 aspect, float innerRadius, float outerRadius, float angle){\n    float knob =  sigmoid((circle(domain, aspect, 2./outerRadius) - circle(domain, aspect, 2./innerRadius))/(outerRadius-innerRadius));\n    knob = mix(knob, 1., circle(domain + vec2(sin(angle), cos(angle))*0.4*aspect.yx, aspect, 8./outerRadius));\n    return knob;\n}\n\nfloat conetip(vec2 uv, vec2 pos, float size, float min, vec3 iResolution)\n{\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n    return max( min, 1. - length((uv - pos) * aspect / size) );\n}\n\nfloat warpFilter(vec2 uv, vec2 pos, float size, float ramp, vec3 iResolution)\n{\n    return 0.5 + sigmoid( conetip(uv, pos, size, -16., iResolution) * ramp) * 0.5;\n}\n\nvec2 vortex_warp(vec2 uv, vec2 pos, float size, float ramp, vec2 rot, vec3 iResolution)\n{\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n\n    vec2 pos_correct = 0.5 + (pos - 0.5);\n    vec2 rot_uv = pos_correct + complex_mul((uv - pos_correct)*aspect, rot)/aspect;\n    float _filter = warpFilter(uv, pos_correct, size, ramp, iResolution);\n    return mix(uv, rot_uv, _filter);\n}\n\nvec2 vortex_pair_warp(vec2 uv, vec2 pos, vec2 vel, vec3 iResolution)\n{\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n    float ramp = 20.;\n\n    float d = 0.075;\n\n    vel *= aspect;\n    float l = length(vel);\n    vec2 p1 = pos;\n    vec2 p2 = pos;\n\n    if(l > 0.){\n        vec2 normal = normalize(rot90(vel))/aspect;\n        p1 = pos + normal * d / 2.;\n        p2 = pos - normal * d / 2.;\n    }\n\n    float w = l*32.;\n\n    // two overlapping rotations that would annihilate if they were not displaced.\n    vec2 circle1 = vortex_warp(uv, p1, d, ramp, vec2(cos(w),sin(w)), iResolution);\n    vec2 circle2 = vortex_warp(uv, p2, d, ramp, vec2(cos(-w),sin(-w)), iResolution);\n    return (circle1 + circle2) / 2.;\n}\n \nfloat border(vec2 domain, float thickness){\n   vec2 uv = fract(domain-vec2(0.5));\n   uv = min(uv,1.-uv)*2.;\n   return clamp(max(uv.x,uv.y)-1.+thickness,0.,1.)/(thickness);\n}\n\n// Buf D contains an N x N array\nfloat N = 32.;\n\n// in the rectangle region between 2 points\nvec2 p1 = vec2(0.75);\nvec2 p2 = vec2(1.);\n\nvec4 Cell(int index, sampler2D bufD)\n{    \n    // map the index to the cell in the array\n    float x = mod(float(index), N) / N;\n    float y = floor(float(index) / N) / N;\n    \n    // compartmentalization\n    vec2 cell_size = (p2 - p1) / N;\n    vec2 center = p1 + cell_size*0.5 + (p2-p1)*vec2(x,y);\n    \n    return texture(bufD, center);\n}\n\nvec2 mouseDelta(vec3 iResolution, vec4 iMouse, sampler2D bufD){\n    vec2 pixelSize = 1. / iResolution.xy;\n    float eighth = 1./8.;\n    vec4 oldMouse = Cell(2, bufD);\n    vec4 nowMouse = vec4(iMouse.xy * pixelSize.xy, iMouse.zw * pixelSize.xy);\n    if(oldMouse.z > pixelSize.x && oldMouse.w > pixelSize.y && \n       nowMouse.z > pixelSize.x && nowMouse.w > pixelSize.y)\n    {\n        return nowMouse.xy - oldMouse.xy;\n    }\n    return vec2(0.);\n}\n\n// sampling from spectrogram\n\nfloat spectrum(float domain, int t, int level, sampler2D bufD)\n{\n    float sixty_fourth = 1./32.;\n    vec2 uv = vec2(float(t)*3.*sixty_fourth + sixty_fourth, domain);\n    uv = upper_right(uv); level++;\n    for(int depth = 1; depth < 8; depth++)\n    {\n        if(depth >= level)\n        {\n            break;\n        }\n        uv = lower_right(uv);\n    }\n\n    return texture(bufD, uv).x;\n}\n\nfloat spectrum2D(vec2 uv, float thickness, int level, sampler2D bufD)\n{\n    float val = spectrum(uv.x, 0, level, bufD);\n    return (abs(uv.y - val) < thickness/2.) ? (1.-abs(uv.y - val)*2./thickness) : 0.;\n}\n\nvec4 rainbowSpectra(vec2 uv, sampler2D bufD)\n{\n    float thickness = 0.015;\n    // make this a loop?\n    vec4 spectra =         vec4(0.25,0,0.5,0)* spectrum2D(uv, thickness, 7, bufD);\n    spectra = mix(spectra, vec4(0.5,0,1.,0), spectrum2D(uv, thickness, 6, bufD));\n    spectra = mix(spectra, vec4(0,0.5,1,0), spectrum2D(uv, thickness, 5, bufD));\n    spectra = mix(spectra, vec4(0,1.,0.5,0), spectrum2D(uv, thickness, 4, bufD));\n    spectra = mix(spectra, vec4(1,1,0,0), spectrum2D(uv, thickness, 3, bufD));\n    spectra = mix(spectra, vec4(0.6,0.25,0,0), spectrum2D(uv, thickness, 2, bufD));\n    spectra = mix(spectra, vec4(0.85,0,0,0), spectrum2D(uv, thickness, 1, bufD));\n    spectra = mix(spectra, vec4(1), spectrum2D(uv, thickness, 0, bufD));\n    \n    return spectra*unit_square(uv);\n}\n\nfloat bass(int t, sampler2D bufD){\n    return spectrum(0.125, t, 3, bufD);\n}\n\nfloat mid(int t, sampler2D bufD){\n    return spectrum(0.5, t, 3, bufD);\n}\n\nfloat treb(int t, sampler2D bufD){\n    return spectrum(0.875, t, 3, bufD);\n}\n\nvec4 vol(int t, sampler2D bufD){\n    float lo = bass(t, bufD);\n    float mi = mid(t, bufD);\n    float hi = treb(t, bufD);\n    return vec4(lo, mi, hi, (lo + mi + hi)*0.333);\n}\n\nvec4 BlurSpectrogram(vec2 uv, int level, sampler2D bufD)\n{\n    uv = upper_right(uv);\n    for(int depth = 1; depth < 8; depth++)\n    {\n        if(depth >= level)\n        {\n            break;\n        }\n        uv = lower_right(uv);\n    }\n\n    return texture(bufD, uv); // Buf D in Texture C\n}\n\n// the following lines are copied from mattdesl's Quadratic Bezier Stroke (fork)\n// https://www.shadertoy.com/view/lts3Df\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\nvec2 closestPointInSegment( vec2 a, vec2 b )\n{\n  vec2 ba = b - a;\n  return a + ba*clamp( -dot(a,ba)/dot(ba,ba), 0.0, 1.0 );\n}\n\n// From: http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nvec2 get_distance_vector(vec2 b0, vec2 b1, vec2 b2) {\n\t\n  float a=det(b0,b2), b=2.0*det(b1,b0), d=2.0*det(b2,b1); // ð›¼,ð›½,ð›¿(ð‘)\n  \n  if( abs(2.0*a+b+d) < 1000.0 ) return closestPointInSegment(b0,b2);\n\t\n  float f=b*d-a*a; // ð‘“(ð‘)\n  vec2 d21=b2-b1, d10=b1-b0, d20=b2-b0;\n  vec2 gf=2.0*(b*d21+d*d10+a*d20);\n  gf=vec2(gf.y,-gf.x); // âˆ‡ð‘“(ð‘)\n  vec2 pp=-f*gf/dot(gf,gf); // ð‘â€²\n  vec2 d0p=b0-pp; // ð‘â€² to origin\n  float ap=det(d0p,d20), bp=2.0*det(d10,d0p); // ð›¼,ð›½(ð‘â€²)\n  // (note that 2*ap+bp+dp=2*a+b+d=4*area(b0,b1,b2))\n  float t=clamp((ap+bp)/(2.0*a+b+d), 0.0 ,1.0); // ð‘¡Ì…\n  return mix(mix(b0,b1,t),mix(b1,b2,t),t); // ð‘£ð‘–= ð‘(ð‘¡Ì…)\n\n}\n\nfloat approx_distance(vec2 p, vec2 b0, vec2 b1, vec2 b2) {\n  return length(get_distance_vector(b0-p, b1-p, b2-p));\n}\n\n// extracted from mainImage\nvec4 overlaySpline(inout vec4 rgba, vec2 uv, vec4 strokeCol, vec2 p1, vec2 p2, vec2 p3, vec3 iResolution){\n\tfloat d = approx_distance((1. - uv)*iResolution.xy, p1*iResolution.xy, p2*iResolution.xy, p3*iResolution.xy);\n\tfloat thickness = 1.0;\n\tfloat a;\n\tif(d < thickness) {\n\t  a = 1.;\n\t} else {\n\t  a = 1. - smoothstep(d, thickness, thickness+0.5);\n\t}\n    rgba = mix(rgba, strokeCol, a * strokeCol.a); \n    return rgba;\n}\n\n// end of fork from https://www.shadertoy.com/view/lts3Df", "buffer_a_code": "// beat detection debug view\n// vortex (pair) warp from the end of the spring chain simulation is applied here\n\nvec4 BlurA(vec2 uv, int level)\n{\n    return BlurA(uv, level, iChannel0, iChannel3);\n}\n\nvec4 BlurB(vec2 uv, int level)\n{\n    return BlurB(uv, level, iChannel1, iChannel3);\n}\n\nvec4 Cell(int index){\n    return Cell(index, iChannel3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize = 1. / iResolution.xy;\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n    vec2 uv = fragCoord.xy * pixelSize;\n    vec2 uv_aspect = 0.5 + (uv - 0.5)*aspect.yx;\n    \n    vec4 noise = (texture(iChannel2, fragCoord.xy / iChannelResolution[2].xy + fract(vec2(42,56)*iTime))-0.5)*2.;\n    \n    vec2 mouseV = mouseDelta(iResolution, iMouse, iChannel3);\n    vec4 volume = vol(0, iChannel3);\n    \n    vec4 C18 = Cell(18); // last one from the Verlet integrated spring simulation support points\n\n    //uv = vortex_pair_warp(uv, iMouse.xy*pixelSize, mouseV, iResolution);\n    uv = vortex_pair_warp(uv, 0.5 - (C18.xy-0.5), -C18.zw/128., iResolution);\n    vec4 poiToy = -C18+0.5;\n    float mask = smoothcircle(uv - poiToy.xy/aspect.xy, aspect, 0.1,64.); //\n    vec2 _c = 0.5 + poiToy.xy/aspect.xy;\n    float _w = 0.5*asin(1.);\n    float z = 1.1;\n    //uv = _c + complex_mul((uv-_c)*aspect, mix(vec2(1.,0.), vec2(cos(_w),-sin(_w))*z, mask)) / aspect;\n    \n    fragColor = BlurA( 0.5 + (uv - 0.5)*vec2(1.006,1.) + vec2(2,0)*pixelSize + vec2(0,iTime*0.0), 0, iChannel0, iChannel3)*1.0- 0./256.;\n    \n    vec4 v0 = Cell(0, iChannel3);\n    vec4 v1 = Cell(1, iChannel3);\n    vec4 v3 = Cell(3, iChannel3);\n    vec2 uv_v0 =vec2(0.95, v0.w);\n    vec2 uv_v3 =vec2(0.95, v3.w*4. + 0.25);\n    vec4 beat_residual = Cell(4);\n    float energy = (v0.w - v1.w);\n    vec2 uv_v1 = vec2(0.95, energy +0.05);\n    if(uv.x >= 0.95 - 1./256.){\n        fragColor.z = Cell(9).x;\n    }\n    fragColor = mix(fragColor, vec4(0,1,0,0), circle(uv - uv_v0+0.5, aspect, 256.));\n    fragColor = mix(fragColor, vec4(1,0,0,0), circle(uv - uv_v1+0.5, aspect, 256.));\n    fragColor = mix(fragColor, vec4(1,1,1,0), circle(uv - uv_v3+0.5, aspect, 256.));\n\n    //fragColor = mix(fragColor, vec4(1,1,1,0), mask);\n\n    vec2 uv_v4 =vec2(0.95, beat_residual.w*0.5);\n    fragColor = mix(fragColor, vec4(0,1,1,0), circle(uv - uv_v4+0.5, aspect, 256.));\n\n    vec4 last_beat_min = Cell(7, iChannel3);\n    vec4 last_beat_max = Cell(8, iChannel3);\n\n    vec2 uv_lo =vec2(0.95, last_beat_min.w*0.5);\n    vec2 uv_hi =vec2(0.95, last_beat_max.w*0.5);\n\n    fragColor = mix(fragColor, vec4(1,0,1,0), circle(uv - uv_lo+0.5, aspect, 256.));\n    fragColor = mix(fragColor, vec4(1,1,0,0), circle(uv - uv_hi+0.5, aspect, 256.));\n\n    vec4 C12 = Cell(12);\n\tvec4 C13 = Cell(13);\n    vec2 p_bass = C12.xy;\n    vec2 p_mid = C12.zw;\n    vec2 p_treb = C13.xy;\n    vec2 p_vol = C13.zw;\n    \n\t//float c4 = smoothcircle(uv - aspect.yx*0.5 + p_bass*aspect.yx, aspect, 0.0025, 800.);\n    //float c5 = smoothcircle(uv - aspect.yx*0.5 + p_mid*aspect.yx, aspect, 0.0025, 800.);\n    //float c6 = smoothcircle(uv - aspect.yx*0.5 + p_treb*aspect.yx, aspect, 0.0025, 800.);\n    float c7 = smoothcircle(uv - aspect.yx*0.5 + Cell(17, iChannel3).xy*aspect.yx, aspect, 0.0025, 800.);    \n    \n    float beat_relative = (beat_residual.w - last_beat_min.w)/(last_beat_max.w - last_beat_min.w);\n    \n    //fragColor *= beat_relative;\n    //fragColor =  mix(fragColor, vec4(.45), mix(BlurA(uv, 1).x*0.175, BlurA(uv, 0).x*0.1, c8*0.75));\n    //fragColor =  mix(fragColor, vec4(1), BlurA(uv, 0)*0.);\n    //fragColor =  mix(fragColor, vec4(1,1,0,0), c6);\n//        fragColor =  mix(fragColor, vec4(1,0,1,0), c4);\n    //fragColor =  mix(fragColor, vec4(0,1,1,0), c5);\n//    fragColor =  mix(fragColor, vec4(1.), c7);\n//    fragColor =  mix(fragColor, vec4(1), c8);\n    \n    vec4 p1 = Cell(14);\n    vec4 p2 = Cell(15);\n    vec4 p3 = Cell(16);\n    vec4 p4 = C18;\n        \n\tfloat c_p1 = smoothcircle(uv_aspect - aspect.yx*0.5 + p1.xy*aspect.yx, aspect, 0.0025, 800.);\n    float c_p2 = smoothcircle(uv_aspect - aspect.yx*0.5 + p2.xy*aspect.yx, aspect, 0.0025, 800.);\n    float c_p3 = smoothcircle(uv_aspect - aspect.yx*0.5 + p3.xy*aspect.yx, aspect, 0.0025, 800.);\n    float c_p4 = smoothcircle(uv_aspect - aspect.yx*0.5 + p4.xy*aspect.yx, aspect, 0.0025, 800.);\n        \n    float c_bass = circle(uv - vec2(0.8,-0.4 + volume.x*0.5)*aspect.yx, aspect, 256.);\n    float c_mid = circle(uv - vec2(0.8,-0.4 + volume.y*0.5)*aspect.yx, aspect, 256.);\n    float c_treb = circle(uv - vec2(0.8,-0.4 + volume.z*0.5)*aspect.yx, aspect, 256.);\n    float c_vol = circle(uv - vec2(0.8,-0.4 + volume.w*0.5)*aspect.yx, aspect, 256.);\n    \n    fragColor =  mix(fragColor, vec4(1,0,0,0), c_p1);\n    fragColor =  mix(fragColor, vec4(0,0,1,0), c_p2);\n    fragColor =  mix(fragColor, vec4(.0,1,0,0), c_p3);\n\tfragColor =  mix(fragColor, vec4(1), c_p4);\n\n    fragColor =  mix(fragColor, vec4(1,0,0,0), c_bass);\n    fragColor =  mix(fragColor, vec4(0,1,0,0), c_mid);\n    fragColor =  mix(fragColor, vec4(0,0,1,0), c_treb);\n    fragColor =  mix(fragColor, vec4(1,1,1,0), c_vol);\n    \n    fragColor =  mix(fragColor, vec4(0,0,0,0), border(uv, 0.04));\n    \n    fragColor = clamp(fragColor, 0., 1.);\n  \n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// reaction-diffusion in RGB\n// L-system fern fractal in Alpha (https://en.wikipedia.org/wiki/Affine_transformation)\n\nvec4 vol(int t){\n    /*\n    float lo = bass(t, bufD);\n    float mi = mid(t, bufD);\n    float hi = treb(t, bufD);\n    return vec4(lo, mi, hi, (lo + mi + hi)*0.333);\n\t*/\n    return vol(t, iChannel3);\n}\n\nvec4 BlurA(vec2 uv, int level)\n{\n    return BlurA(uv, level, iChannel0, iChannel3);\n}\n\nvec4 BlurB(vec2 uv, int level)\n{\n    return BlurB(uv, level, iChannel1, iChannel3);\n}\n\nvec4 Cell(int index){\n    return Cell(index, iChannel3);\n}\n\nvec2 GradientB(vec2 uv, vec2 d, vec4 selector, int level){\n    return GradientB(uv, d, selector, level, iChannel1, iChannel3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rainbow = hsl2rgb(fract(iTime), 1., 0.5);\n    vec4 noise = texture(iChannel2, fragCoord.xy / iChannelResolution[2].xy + fract(vec2(42,56)*iTime));\n\tvec4 normalizedVolume = Cell(13)*0.2 + 0.75;\n    vec4 integratedVolume = Cell(19);\n    vec4 fader = Cell(22)*8.;\n    \n    if(iFrame<16)\n    {\n        //fragColor = noise;\n        //return;\n    }\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mouseV = mouseDelta(iResolution, iMouse, iChannel3);\n    vec4 volume = vol(0, iChannel3);\n    \n    vec4 C18 = Cell(18); // last one from the Verlet integrated spring simulation support points\n    vec4 p2 = Cell(15);\n    vec4 p3 = Cell(16);\n    \n\tvec2 pixelSize = 1./iResolution.xy;\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n    vec2 uv_orig = uv;\n    \n    uv = vortex_pair_warp(uv, 0.5 - (C18.xy-0.5), -C18.zw/128., iResolution);\n    \n    vec4 prevFrame = BlurB(uv, 0);\n    \n    \n    float speed = 0.0225;\n    vec2 rotate_uv = rotozoom(uv, -2.*fader.y*speed, 1., aspect);\n\tvec2 bipolar_uv = uv_bipolar(0.5 + (rotate_uv-0.5)*2.33*aspect , vec2(0.5,0.), vec2(0.0,0.5), 2., 0.3, fader.xz*speed);\n\tbipolar_uv = wrap_flip(bipolar_uv);\n\n    float beat = Cell(9).x;\n    if(beat == 1.)\n    {\n    \tfragColor =  mix(fragColor, vec4(1), BlurB(bipolar_uv, 0) * 0.88);\n\t    fragColor = max(fragColor, rainbowSpectra(bipolar_uv, iChannel3));\n    }\n    else\n    {\n        fragColor = prevFrame;\n    }\n    \n    \n    fragColor.a = 0.;\n    \n    uv = uv_orig;\n    \n    //uv = 0.5 + (uv - 0.5)*0.99;\n    //uv = vortex_pair_warp(uv, iMouse.xy*pixelSize, mouseV*aspect*1., iResolution);\n\t//uv = vortex_pair_warp(uv, 0.5 - (C18.xy-0.5), -C18.zw*4., iResolution);\n\n    float c8 = smoothcircle(uv, aspect, 0.25, 256.);\n\n    float time = iTime;\n   \tuv = uv + (1.-c8)*vec2(sin(time*0.1 + uv.x*2. +1.) - sin(time*0.214 + uv.y*2. +1.), sin(time*0.168 + uv.x*2. +1.) - sin(time*0.115 +uv.y*2. +1.))*pixelSize*0.5;\n\n    vec4 C25 = Cell(25);\n    vec4 C26 = Cell(26);\n    vec4 C27 = Cell(27);\n    float puller = (integratedVolume.x - integratedVolume.z)/2.;\n    //float spineBending = -(C25.x * 0.5 + C25.w* 0.5 - puller) * 2.;\n    float spineBending = C26.z;\n    \n    float w = C26.w - spineBending - time*4.*asin(1.)/60.*0. - fader.a*2.*0. + asin(1.)*2.*0.5 - (volume.x-volume.y-volume.z*0.25)*0.;\n    vec2 rot = vec2(sin(w),-cos(w));\n    vec2 rot_uv = 0.5 + complex_mul((uv-0.5)*aspect*1.618, vec2(cos(w),-sin(w)))/aspect;\n    vec4 last_beat_min = Cell(7);\n    vec4 last_beat_max = Cell(8);\n\tvec4 beat_residual = Cell(4);\n    \n    float beat_relative = (beat_residual.w - last_beat_min.w)/(last_beat_max.w - last_beat_min.w);\n\n    fragColor.a = smoothcircle(uv - 6./32.*rot/aspect, aspect, 2./32. - beat_relative/64.*0. + abs(spineBending)/40., 256.);\n    \n    float l = 3.;\n    vec2 o = vec2(0.33, 0.26);\n    \n    w = -asin(1.)/1.5;\n    float angle = w + spineBending*0.;\n    vec2 uv_left = 0.5 + complex_mul((uv - 0.5)*aspect*l + rot90(rot)*o.x - rot*o.y, vec2(cos(angle),-sin(angle)))/aspect;\n    \n    angle = -w - spineBending*0.;\n    vec2 uv_right = 0.5 + complex_mul((uv - 0.5)*aspect*l - rot90(rot)*o.x - rot*o.y, vec2(cos(angle),-sin(angle)))/aspect;\n    \n    angle = spineBending;\n    vec2 uv_main = 0.5 + complex_mul((uv - 0.5)*aspect*1.33 + rot*0.09, vec2(cos(angle),-sin(angle)))/aspect;\n    \n    float square_main = unit_square(uv_main, aspect);\n    float square_left = unit_square(uv_left, aspect);\n    float square_right = unit_square(uv_right, aspect);\n    fragColor.a = mix(fragColor.a, 1., square_main*BlurB(uv_main, 0).a);\n    fragColor.a = mix(fragColor.a, 1., square_left*BlurB(uv_left, 0).a);\n    fragColor.a = mix(fragColor.a, 1., square_right*BlurB(uv_right, 0).a);\n\n//    fragColor.x = 0.;\n\n    fragColor = clamp(fragColor, 0., 1.);\n\n   // fragColor = noise; // reset\n}", "buffer_b_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// resolution reduction and horizontal blur\n\n// shout-outs to https://twitter.com/mattdesl\n// https://github.com/mattdesl/lwjgl-basics/wiki/shaderlesson5\n\nvec4 blur_horizontal(sampler2D channel, vec2 uv, float scale)\n{\n    float h = scale / iResolution.x;\n    vec4 sum = vec4(0.0);\n\n    sum += texture(channel, fract(vec2(uv.x - 4.0*h, uv.y)) ) * 0.0162162162;\n    sum += texture(channel, fract(vec2(uv.x - 3.0*h, uv.y)) ) * 0.0540540541;\n    sum += texture(channel, fract(vec2(uv.x - 2.0*h, uv.y)) ) * 0.1216216216;\n    sum += texture(channel, fract(vec2(uv.x - 1.0*h, uv.y)) ) * 0.1945945946;\n    sum += texture(channel, fract(vec2(uv.x + 0.0*h, uv.y)) ) * 0.2270270270;\n    sum += texture(channel, fract(vec2(uv.x + 1.0*h, uv.y)) ) * 0.1945945946;\n    sum += texture(channel, fract(vec2(uv.x + 2.0*h, uv.y)) ) * 0.1216216216;\n    sum += texture(channel, fract(vec2(uv.x + 3.0*h, uv.y)) ) * 0.0540540541;\n    sum += texture(channel, fract(vec2(uv.x + 4.0*h, uv.y)) ) * 0.0162162162;\n\n    return sum;\n}\n\n// see a sketch of the downsampling pipeline here: https://twitter.com/Flexi23/status/686583437814317057\n\nvec4 blur_horizontal_left_column(vec2 uv, int depth)\n{\n    float h = pow(2., float(depth)) / iResolution.x;    \n    vec2 uv1, uv2, uv3, uv4, uv5, uv6, uv7, uv8, uv9;\n\n    uv1 = fract(vec2(uv.x - 4.0 * h, uv.y) * 2.);\n    uv2 = fract(vec2(uv.x - 3.0 * h, uv.y) * 2.);\n    uv3 = fract(vec2(uv.x - 2.0 * h, uv.y) * 2.);\n    uv4 = fract(vec2(uv.x - 1.0 * h, uv.y) * 2.);\n    uv5 = fract(vec2(uv.x + 0.0 * h, uv.y) * 2.);\n    uv6 = fract(vec2(uv.x + 1.0 * h, uv.y) * 2.);\n    uv7 = fract(vec2(uv.x + 2.0 * h, uv.y) * 2.);\n    uv8 = fract(vec2(uv.x + 3.0 * h, uv.y) * 2.);\n    uv9 = fract(vec2(uv.x + 4.0 * h, uv.y) * 2.);\n\n    if(uv.y > 0.5)\n    {\n        uv1 = upper_left(uv1);\n        uv2 = upper_left(uv2);\n        uv3 = upper_left(uv3);\n        uv4 = upper_left(uv4);\n        uv5 = upper_left(uv5);\n        uv6 = upper_left(uv6);\n        uv7 = upper_left(uv7);\n        uv8 = upper_left(uv8);\n        uv9 = upper_left(uv9);\n    }\n    else{\n        uv1 = lower_left(uv1);\n        uv2 = lower_left(uv2);\n        uv3 = lower_left(uv3);\n        uv4 = lower_left(uv4);\n        uv5 = lower_left(uv5);\n        uv6 = lower_left(uv6);\n        uv7 = lower_left(uv7);\n        uv8 = lower_left(uv8);\n        uv9 = lower_left(uv9);\n    }\n\n    for(int level = 0; level < 8; level++)\n    {\n        if(level >= depth)\n        {\n            break;\n        }\n\n        uv1 = lower_right(uv1);\n        uv2 = lower_right(uv2);\n        uv3 = lower_right(uv3);\n        uv4 = lower_right(uv4);\n        uv5 = lower_right(uv5);\n        uv6 = lower_right(uv6);\n        uv7 = lower_right(uv7);\n        uv8 = lower_right(uv8);\n        uv9 = lower_right(uv9);\n    }\n\n    vec4 sum = vec4(0.0);\n\n    sum += texture(iChannel3, uv1) * 0.0162162162;\n    sum += texture(iChannel3, uv2) * 0.0540540541;\n    sum += texture(iChannel3, uv3) * 0.1216216216;\n    sum += texture(iChannel3, uv4) * 0.1945945946;\n    sum += texture(iChannel3, uv5) * 0.2270270270;\n    sum += texture(iChannel3, uv6) * 0.1945945946;\n    sum += texture(iChannel3, uv7) * 0.1216216216;\n    sum += texture(iChannel3, uv8) * 0.0540540541;\n    sum += texture(iChannel3, uv9) * 0.0162162162;\n    \n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    if(uv.x < 0.5)\n    {\n        vec2 uv_half = fract(uv*2.);\n        if(uv.y > 0.5)\n        {\n            fragColor = blur_horizontal(iChannel0, uv_half, 1.);\n        }\n        else\n        {\n            fragColor = blur_horizontal(iChannel1, uv_half, 1.);\n        }\n    }\n    else\n    {\n        for(int level = 0; level < 8; level++)\n        {\n            if((uv.x > 0.5 && uv.y > 0.5) || (uv.x <= 0.5))\n            {\n                break;\n            }\n            vec2 uv_half = fract(uv*2.);\n            fragColor = blur_horizontal_left_column(uv_half, level);\n            uv = uv_half;\n        }\n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// bind in iChannel1 misc\n// https://soundcloud.com/generate/kettel-candace-bouvard\n\n// vertical blur (second pass)\n\n// see https://github.com/mattdesl/lwjgl-basics/wiki/shaderlesson5\n// by https://twitter.com/mattdesl\n\nvec4 blur_vertical_upper_left(sampler2D channel, vec2 uv)\n{\n    float v = 1. / iResolution.y;\n    vec4 sum = vec4(0.0);\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 4.0*v)) ) * 0.0162162162;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 3.0*v)) ) * 0.0540540541;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 2.0*v)) ) * 0.1216216216;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 1.0*v)) ) * 0.1945945946;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 0.0*v)) ) * 0.2270270270;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 1.0*v)) ) * 0.1945945946;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 2.0*v)) ) * 0.1216216216;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 3.0*v)) ) * 0.0540540541;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 4.0*v)) ) * 0.0162162162;\n    return sum;\n}\n\nvec4 blur_vertical_lower_left(sampler2D channel, vec2 uv)\n{\n    float v = 1. / iResolution.y;\n    vec4 sum = vec4(0.0);\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 4.0*v)) ) * 0.0162162162;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 3.0*v)) ) * 0.0540540541;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 2.0*v)) ) * 0.1216216216;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 1.0*v)) ) * 0.1945945946;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 0.0*v)) ) * 0.2270270270;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 1.0*v)) ) * 0.1945945946;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 2.0*v)) ) * 0.1216216216;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 3.0*v)) ) * 0.0540540541;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 4.0*v)) ) * 0.0162162162;\n    return sum;\n}\n\n// see a sketch of the downsampling pipeline here: https://twitter.com/Flexi23/status/686583437814317057\n\nvec4 blur_vertical_left_column(vec2 uv, int depth)\n{\n    float v = pow(2., float(depth)) / iResolution.y;\n\n    vec2 uv1, uv2, uv3, uv4, uv5, uv6, uv7, uv8, uv9;\n\n    uv1 = fract(vec2(uv.x, uv.y - 4.0*v) * 2.);\n    uv2 = fract(vec2(uv.x, uv.y - 3.0*v) * 2.);\n    uv3 = fract(vec2(uv.x, uv.y - 2.0*v) * 2.);\n    uv4 = fract(vec2(uv.x, uv.y - 1.0*v) * 2.);\n    uv5 = fract(vec2(uv.x, uv.y + 0.0*v) * 2.);\n    uv6 = fract(vec2(uv.x, uv.y + 1.0*v) * 2.);\n    uv7 = fract(vec2(uv.x, uv.y + 2.0*v) * 2.);\n    uv8 = fract(vec2(uv.x, uv.y + 3.0*v) * 2.);\n    uv9 = fract(vec2(uv.x, uv.y + 4.0*v) * 2.);\n\n    if(uv.x < 0.5)\n    {\n        if(uv.y > 0.5)\n        {\n            uv1 = upper_left(uv1);\n            uv2 = upper_left(uv2);\n            uv3 = upper_left(uv3);\n            uv4 = upper_left(uv4);\n            uv5 = upper_left(uv5);\n            uv6 = upper_left(uv6);\n            uv7 = upper_left(uv7);\n            uv8 = upper_left(uv8);\n            uv9 = upper_left(uv9);\n        }\n        else\n        {\n            uv1 = lower_left(uv1);\n            uv2 = lower_left(uv2);\n            uv3 = lower_left(uv3);\n            uv4 = lower_left(uv4);\n            uv5 = lower_left(uv5);\n            uv6 = lower_left(uv6);\n            uv7 = lower_left(uv7);\n            uv8 = lower_left(uv8);\n            uv9 = lower_left(uv9);\n        }\n    }\n    else\n    {\n        vec2 uv_s = upper_right(uv*2.)*2.;\n        uv1 = clamp(vec2(uv_s.x, uv_s.y - 4.0*v), 0., 1.);\n        uv2 = clamp(vec2(uv_s.x, uv_s.y - 3.0*v), 0., 1.);\n        uv3 = clamp(vec2(uv_s.x, uv_s.y - 2.0*v), 0., 1.);\n        uv4 = clamp(vec2(uv_s.x, uv_s.y - 1.0*v), 0., 1.);\n        uv5 = clamp(vec2(uv_s.x, uv_s.y + 0.0*v), 0., 1.);\n        uv6 = clamp(vec2(uv_s.x, uv_s.y + 1.0*v), 0., 1.);\n        uv7 = clamp(vec2(uv_s.x, uv_s.y + 2.0*v), 0., 1.);\n        uv8 = clamp(vec2(uv_s.x, uv_s.y + 3.0*v), 0., 1.);\n        uv9 = clamp(vec2(uv_s.x, uv_s.y + 4.0*v), 0., 1.);\n        depth--;\n        uv1 = upper_right(uv1);\n        uv2 = upper_right(uv2);\n        uv3 = upper_right(uv3);\n        uv4 = upper_right(uv4);\n        uv5 = upper_right(uv5);\n        uv6 = upper_right(uv6);\n        uv7 = upper_right(uv7);\n        uv8 = upper_right(uv8);\n        uv9 = upper_right(uv9);\n    }\n    for(int level = 0; level < 8; level++)\n    {\n        if(level > depth)\n        {\n            break;\n        }\n\n        uv1 = lower_right(uv1);\n        uv2 = lower_right(uv2);\n        uv3 = lower_right(uv3);\n        uv4 = lower_right(uv4);\n        uv5 = lower_right(uv5);\n        uv6 = lower_right(uv6);\n        uv7 = lower_right(uv7);\n        uv8 = lower_right(uv8);\n        uv9 = lower_right(uv9);\n    }\n\n    vec4 sum = vec4(0.0);\n    if(uv.x > 0.5 && uv.y > 0.5)\n    {\n        //return vec4(0);\n        sum += texture(iChannel3, uv1) * 0.0162162162;\n        sum += texture(iChannel3, uv2) * 0.0540540541;\n        sum += texture(iChannel3, uv3) * 0.1216216216;\n        sum += texture(iChannel3, uv4) * 0.1945945946;\n        sum += texture(iChannel3, uv5) * 0.2270270270;\n        sum += texture(iChannel3, uv6) * 0.1945945946;\n        sum += texture(iChannel3, uv7) * 0.1216216216;\n        sum += texture(iChannel3, uv8) * 0.0540540541;\n        sum += texture(iChannel3, uv9) * 0.0162162162;\n    }\n    else\n    {\n        sum += texture(iChannel2, uv1) * 0.0162162162;\n        sum += texture(iChannel2, uv2) * 0.0540540541;\n        sum += texture(iChannel2, uv3) * 0.1216216216;\n        sum += texture(iChannel2, uv4) * 0.1945945946;\n        sum += texture(iChannel2, uv5) * 0.2270270270;\n        sum += texture(iChannel2, uv6) * 0.1945945946;\n        sum += texture(iChannel2, uv7) * 0.1216216216;\n        sum += texture(iChannel2, uv8) * 0.0540540541;\n        sum += texture(iChannel2, uv9) * 0.0162162162;\n    }\n    return sum; // normalize\n}\n\nvoid set_cell(inout vec4 bufD, vec2 uv, int index, vec4 value)\n{    \n    // map the index to the cell in the array\n    float x = mod(float(index), N) / N;\n    float y = floor(float(index) / N) / N;\n\n\n    // compartmentalization\n    vec2 cell_size = (p2 - p1) / N;\n    vec2 center = p1 + cell_size*0.5 + (p2-p1)*vec2(x,y);\n\n    // store\n    if(abs(uv - center).x <= cell_size.x*0.5 && abs(uv - center).y <= cell_size.y*0.5)\n    {\n        bufD = value;\n    }\n}\n\nvoid spring(float force, inout vec4 p1, inout vec4 p2) {\n    vec2 f = (p2.xy-p1.xy) * force;\n    p1.zw += f;\n    p2.zw -= f;\n}\n\nvoid resist(float friction, inout vec4 p){\n    float dampeningFactor = 0.9;\n    // hit right border\n    if(p.x > 1. && p.z > 0.){\n        p.z = - p.z * dampeningFactor;\n    }\n    // hit left border\n    if(p.x < 0. && p.z < 0.){\n        p.z = - p.z * dampeningFactor;\n    }\n    // hit lower border\n    if(p.y < 0. && p.w < 0.){\n        p.w = - p.w * dampeningFactor;\n    }\n    // hit upper border\n    if(p.y > 1. && p.w > 0.){\n        p.w = - p.w * dampeningFactor;\n    }\n\n    friction = max(0., 1. - length(p.zw)*friction);\n    p.zw *= friction;\n}\n\nvec4 Cell(int index){\n    return Cell(index, iChannel3);\n}\n\nvec4 vol(int t){\n    float lo = bass(t, iChannel3);\n    float mi = mid(t, iChannel3);\n    float hi = treb(t, iChannel3);\n    return vec4(lo, mi, hi, (lo + mi + hi)*0.333);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize = 1./iResolution.xy;\n    vec2 uv = fragCoord.xy * pixelSize;\n    vec2 uv_orig = uv;\n    vec2 uv_half = fract(uv*2.);\n    if(uv.x < 0.5)\n    {\n        if(uv.y > 0.5)\n        {\n            fragColor = blur_vertical_upper_left(iChannel2, uv_half);\n        }\n        else\n        {\n            fragColor = blur_vertical_lower_left(iChannel2, uv_half);\n        }\n    }\n    else\n    {\n        for(int level = 0; level < 8; level++)\n        {\n            if((uv.x > 0.5 && uv.y >= 0.5) || (uv.x < 0.5))\n            {\n                break;\n            }\n            vec2 uv_half = fract(uv*2.);\n            fragColor = blur_vertical_left_column(uv_half, level);\n            uv = uv_half;\n        }\n        uv_half = fract(uv_orig*2.);\n\n        if(uv_orig.y > 0.5)\n        {\n            if(uv_half.x < pixelSize.x *128.)\n            {\n                fragColor = texture(iChannel1, uv_half.yx);\n            }else{\n                fragColor = texture(iChannel3, uv_orig - vec2(64.,0.) * pixelSize);\n                //fragColor = vec4(0);\n            }\n        }\n    }\n\n    // volume from current frame and one frame ago\n    vec4 v0 = vol(0, iChannel3);\n    vec4 v0_prev = Cell(20);\n    vec4 v1 = vol(1);\n\n    set_cell(fragColor, uv, 0, v0);\n    set_cell(fragColor, uv, 1, v1);\n    set_cell(fragColor, uv, 2, vec4(iMouse.xy * pixelSize, iMouse.zw * pixelSize));\n\n    vec4 v2 = vol(2);\n    vec4 attack = v2 + v0 - 2.*v1;\n    set_cell(fragColor, uv, 3, attack);\n\n    vec4 old_beat_residual = Cell(4);\n    vec4 beat_residual = old_beat_residual*0.96 + max(attack*4., 0.);\n    set_cell(fragColor, uv, 4, beat_residual);\n    set_cell(fragColor, uv, 5, old_beat_residual);\n\n    attack = beat_residual - old_beat_residual;\n    set_cell(fragColor, uv, 6, attack );\n\n    vec4 last_beat_min = Cell(7);\n    vec4 last_beat_max = Cell(8);\n    \n    float frames_since_last_beat = Cell(9).y;\n    bool beat = (v0.w-v0_prev.w)*2. > 4./frames_since_last_beat;// || ((last_beat_min.w < 0.01) && attack.w > 0.05) || ((frames_since_last_beat > 120.) && attack.w > 0.15);\n    beat = beat && (frames_since_last_beat > 15.);\n    \n    vec4 noise = texture(iChannel0, fragCoord.xy / iChannelResolution[0].xy + fract(vec2(42,56)*iTime));\n\n    if(beat)\n    {\n        set_cell(fragColor, uv, 7, old_beat_residual);\n        set_cell(fragColor, uv, 8, beat_residual);\n        set_cell(fragColor, uv, 11, Cell(10));\n        set_cell(fragColor, uv, 10, noise);\n        frames_since_last_beat = 1.;\n    }\n    else\n    {\n        set_cell(fragColor, uv, 7, min(last_beat_min, beat_residual));\n        set_cell(fragColor, uv, 8, max(last_beat_max, beat_residual));\n        set_cell(fragColor, uv, 10, Cell(10));\n        set_cell(fragColor, uv, 11, Cell(11));\n        frames_since_last_beat += 1.;\n    }\n\n    set_cell(fragColor, uv, 9, vec4(beat, frames_since_last_beat, 0, 0));\n    \n    // #puller\n    vec4 integratedVolume = Cell(19);\n    vec4 v = integratedVolume * 0.5;\n    vec2 c = vec2( 0.5, 0.5 );\n    vec2 s0 = c + vec2(v.x + v0.x*0.25, +v.x - v.z- v.y);\n\tvec2 s1 = c + vec2(v.x - v.z, - v.y*0.5 - v0.y*0.5);\n    vec2 s2 = c + vec2(-v.z - v0.z*0.25, -v.z + v.x- v.y);\n    \n    vec4 p_bass = vec4(s0, 0, 0);\n    vec4 p_mid = vec4(s1, 0, 0);\n    vec4 p_treb = vec4(s2, 0, 0);\n    vec4 p_vol = vec4((s0 + s1 + s2)/3., 0, 0);\n\n    float drinkMe = 1.;\n    if(drinkMe == 1.){\n        vec2 centerOffset = (p_vol.xy - vec2(0.5,0.5))*vec2(-0.5,-0.5);\n        p_bass.xy -= centerOffset;\n        p_mid.xy  -= centerOffset;\n        p_treb.xy -= centerOffset;\n    }\n    \n    vec2 centerOffset = vec2(0.,0.3);\n    p_bass.xy -= centerOffset;\n    p_mid.xy  -= centerOffset;\n    p_treb.xy -= centerOffset;\n    \n\n    set_cell(fragColor, uv, 12, vec4(p_bass.xy, p_mid.xy));\n    set_cell(fragColor, uv, 13, vec4(p_treb.xy, p_vol.xy));\n    // p_.xy = pos, p_.zw = velocity\n    \n    vec4 p0 = Cell(17);\n    vec4 p1 = Cell(14);\n    vec4 p2 = Cell(15);\n    vec4 p3 = Cell(16);\n    vec4 p4 = Cell(18);\n    \n    float force = 1.666;\n    float friction = 0.0005;\n    float speed = 0.0066;\n    float grav = 0.1;\n    \n    float impactfactor = 128.;\n    spring(force * impactfactor, p0, p_bass);\n    spring(force * impactfactor, p0, p_mid);\n    spring(force * impactfactor, p0, p_treb);\n    spring(force, p0, p1);\n    spring(force, p1, p2);\n    spring(force, p2, p3);\n    spring(force, p3, p4);\n    \n    resist(friction, p0);\n    resist(friction, p1);\n    resist(friction, p2);\n    resist(friction, p3);\n    resist(friction, p4);\n    \n    p1.w += grav;\n    p2.w += grav;\n    p3.w += grav;\n    p4.w += grav;\n    \n    // Verlet integration\n    p0.xy += p0.zw * speed;\n    p1.xy += p1.zw * speed;\n    p2.xy += p2.zw * speed;\n    p3.xy += p3.zw * speed;\n    p4.xy += p4.zw * speed;\n    \n    if(iFrame < 2){\n\t    p0.xy = p_vol.xy;\n\t    p1.xy = p_vol.xy;\n    \tp2.xy = p_vol.xy;\n    \tp3.xy = p_vol.xy;\n    \tp4.xy = p_vol.xy;\n    }\n\n    set_cell(fragColor, uv, 17, p0);\n    set_cell(fragColor, uv, 14, p1);\n    set_cell(fragColor, uv, 15, p2);\n    set_cell(fragColor, uv, 16, p3);\n    set_cell(fragColor, uv, 18, p4);\n    \n    set_cell(fragColor, uv, 19, integratedVolume*0.92 + v0*0.1);\n    set_cell(fragColor, uv, 20, v0);\n    \n    float volMin = min(integratedVolume.x, min(integratedVolume.y, integratedVolume.z));\n    float volMax = max(integratedVolume.x, max(integratedVolume.y, integratedVolume.z));\n    \n    vec4 normalizedVolume = (integratedVolume - volMin*vec4(1))/(volMax - volMin);\n    if(volMax - volMin != 0.){\n    \tset_cell(fragColor, uv, 21, normalizedVolume);\n        set_cell(fragColor, uv, 22, Cell(22) - (normalizedVolume-0.5)*1.33*iTimeDelta);\n    }\n    \n    set_cell(fragColor, uv, 23, vec4(s1,s0));\n    set_cell(fragColor, uv, 24, vec4(s0,s2));\n    \n    vec4 C25 = Cell(25); // 1D spring <s0, v0, v1, s1>\n    float ff = iTimeDelta*0.75; // force factor\n    float vf = 0.25; // velocity factor\n    float puller = (integratedVolume.x - integratedVolume.z)/2.;\n    C25.yz *= 0.99; // dampen\n    // accelerate\n    C25.y += (C25.w - C25.x * 2. + puller) * ff;\n    C25.z += (C25.x - C25.w) * ff;\n    // Verlet integration\n    C25.x += C25.y * vf;\n    C25.w += C25.z * vf;\n    \n    set_cell(fragColor, uv, 25, C25);\n    \n    vec4 C26 = Cell(26); // fractal swimmer <x, y, bending, orientation>\n    vec4 C27 = Cell(27); // previous frame fractal swimmer\n    set_cell(fragColor, uv, 27, C26);\n    \n    // now we can update C26\n    \n    float rollMoment = C26.w - C27.w;\n    vec2 velocity = C26.xy - C27.xy;\n    float bendForce = C26.z- C27.z;\n    float forwardFriction = 0.99;\n    float turnFriction = 0.99;\n    \n    float inputForce = -abs(C25.w - puller)*iTimeDelta*24.;\n\t\n    vec2 velocityPolar = uv_polar(velocity, vec2(0)); // <ang, rad>\n    \n    velocityPolar.y = velocityPolar.y * forwardFriction;\n    velocity = vec2(cos(velocityPolar.x), sin(velocityPolar.x)) * velocityPolar.y;\n    \n    float w = C26.w;\n    velocity += vec2(cos(w), sin(w))*inputForce/256.;\n    \n    //velocity = vec2(- pixelSize.x*4., 0.);\n    //velocity = vec2(0., - pixelSize.x*4.);\n    //velocity = vec2(0);\n    \n    float spineBending = -(C25.x * 0.5 + C25.w* 0.5 - puller) * 2.;\n   \tC26.z = spineBending;\n    C26.xy += velocity;\n    C26.w += rollMoment * turnFriction - velocityPolar.y * C26.z * 2.;\n    \n    //C26.w += 0.*(C25.w - puller)*iTimeDelta*24.; // todo: multiply with forward velocity\n    set_cell(fragColor, uv, 26, C26);\n        \n}", "buffer_d_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22225, "src": "https://soundcloud.com/kateviy-tsfp/faye-cruel-world-cover", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfBzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1283, 1283, 1304, 1304, 1341], [1343, 1343, 1359, 1359, 1516], [1518, 1518, 1573, 1573, 1631], [1633, 1633, 1665, 1665, 1718]], "test": "untested"}
{"id": "Mlcczs", "name": "textmode try2", "author": "halcy", "description": "second attempt, this time the palette is precomputed", "tags": ["textmode", "ansi"], "likes": 2, "viewed": 316, "published": 3, "date": "1587674137", "time_retrieved": "2024-07-30T21:10:50.988206", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    /*\n    // Copy \"full\" tones\n    for(int i = 0; i < 16; i++) {\n        full_palette[i].fore = palette[i];\n        full_palette[i].col = palette[i];\n        full_palette[i].char = 0;\n    }\n    \n   \t// Generate 50% halftones\n    for(int i = 0; i < 16; i++) {\n        for(int j = 0; j < 16; j++) {\n            full_palette[i + 16].fore = palette[i];\n            full_palette[i + 16].back = palette[j];\n            full_palette[i + 16].col = palette[i] * 0.5 + palette[j] * 0.5;\n            full_palette[i + 16].char = 1;\n        }\n    }\n    \n    // Generate 25% halftones\n    for(int i = 0; i < 16; i++) {\n        for(int j = 0; j < 16; j++) {\n            full_palette[i + 16 + 16*16].fore = palette[i];\n            full_palette[i + 16 + 16*16].back = palette[j];\n            full_palette[i + 16 + 16*16].col = palette[i] * 0.75 + palette[j] * 0.25;\n            full_palette[i + 16 + 16*16].char = 2;\n        }\n    }\n    */\n    \n    // Figure out which character to use\n    vec2 char_size = vec2(8.0, 16.0);\n    vec2 uv = (floor(fragCoord / char_size) * char_size);\n\tvec2 in_char_uv = fragCoord - uv;\n    uv /= iResolution.xy;\n    \n    vec3 col = vec3(0.0);\n    float weights = 0.0;\n    for(float x = 0.0; x < char_size.x; x += 1.0) {\n        for(float y = 0.0; y < char_size.y; y += 1.0) {\n        \tfloat weight = length(vec2(x, y) - char_size / 2.0);\n            col += texture(iChannel0, uv + vec2(x, y) / iResolution.xy).rgb * weight;\n            weights += weight;\n        }\n    }\n    col = col / weights;\n    \n    termchar best_char;\n    float best_dist = 1000000000.0;\n    \n    for(int i = 0; i < 528; i++) {\n   \t\tfloat dist = labDist(col, full_palette[i].col);\n        if(dist < best_dist) {\n        \tbest_char = full_palette[i];\n            best_dist = dist;\n        }\n    }\n    \n    // Draw character\n   \tfloat fore_back = 1.0;\n    if(best_char.char == 1) {\n    \tfore_back = mod(1.0 + in_char_uv.x + mod(in_char_uv.y, 2.0), 2.0);\n    }\n    if(best_char.char == 2) {\n    \tfore_back = mod(1.0 + in_char_uv.x + mod(in_char_uv.y, 2.0) * 2.0, 4.0);\n    }\n    fore_back = floor(fore_back);\n    \n    vec3 pixel_col = fore_back * best_char.fore + (1.0 - fore_back) * best_char.back;\n    fragColor = vec4(pixel_col, 1.0);\n    \n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// https://gist.github.com/mattatz/44f081cac87e2f7c8980\nvec3 rgb2xyz( vec3 c ) {\n    vec3 tmp;\n    tmp.x = ( c.r > 0.04045 ) ? pow( ( c.r + 0.055 ) / 1.055, 2.4 ) : c.r / 12.92;\n    tmp.y = ( c.g > 0.04045 ) ? pow( ( c.g + 0.055 ) / 1.055, 2.4 ) : c.g / 12.92,\n    tmp.z = ( c.b > 0.04045 ) ? pow( ( c.b + 0.055 ) / 1.055, 2.4 ) : c.b / 12.92;\n    const mat3x3 mat = mat3x3(\n\t\t0.4124, 0.3576, 0.1805,\n        0.2126, 0.7152, 0.0722,\n        0.0193, 0.1192, 0.9505 \n\t);\n    return 100.0 * tmp * mat;\n}\n\nvec3 xyz2lab( vec3 c ) {\n    vec3 n = c / vec3(95.047, 100, 108.883);\n    vec3 v;\n    v.x = ( n.x > 0.008856 ) ? pow( n.x, 1.0 / 3.0 ) : ( 7.787 * n.x ) + ( 16.0 / 116.0 );\n    v.y = ( n.y > 0.008856 ) ? pow( n.y, 1.0 / 3.0 ) : ( 7.787 * n.y ) + ( 16.0 / 116.0 );\n    v.z = ( n.z > 0.008856 ) ? pow( n.z, 1.0 / 3.0 ) : ( 7.787 * n.z ) + ( 16.0 / 116.0 );\n    return vec3(( 116.0 * v.y ) - 16.0, 500.0 * ( v.x - v.y ), 200.0 * ( v.y - v.z ));\n}\n\nvec3 rgb2lab( vec3 c ) {\n    vec3 lab = xyz2lab( rgb2xyz( c ) );\n    return vec3( lab.x / 100.0, 0.5 + 0.5 * ( lab.y / 127.0 ), 0.5 + 0.5 * ( lab.z / 127.0 ));\n}\n\nfloat labDist(vec3 a, vec3 b) {\n\treturn length(rgb2lab(a) - rgb2lab(b));    \n}\n\nvec3 palette[16] = vec3[16](\n    vec3(0, 0, 0) / 255.0,\n    vec3(170, 0, 0) / 255.0,\n    vec3(0, 170, 0) / 255.0,\n    vec3(170, 85, 0) / 255.0,\n    vec3(0, 0, 170) / 255.0,\n    vec3(170, 0, 170) / 255.0,\n    vec3(0, 170, 170) / 255.0,\n    vec3(170, 170, 170) / 255.0,\n    vec3(85, 85, 85) / 255.0,\n    vec3(255, 85, 85) / 255.0,\n    vec3(85, 255, 85) / 255.0,\n    vec3(255, 255, 85) / 255.0,\n    vec3(85, 85, 255) / 255.0,\n    vec3(255, 85, 255) / 255.0,\n    vec3(85, 255, 255) / 255.0,\n    vec3(255, 255, 255) / 255.0\n);\n\nstruct termchar {\n    vec3 fore;\n    vec3 back;\n    vec3 col;\n    int char; // 0 = full fg, 1 = 50% halftone, 2 = 25% bg 75% fg\n};\n    \nconst termchar full_palette[528] = termchar[528](\n\ttermchar(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 0), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.0), vec3(0.6666666666666666, 0.0, 0.0), vec3(0.6666666666666666, 0.0, 0.0), 0), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.0), vec3(0.0, 0.6666666666666666, 0.0), vec3(0.0, 0.6666666666666666, 0.0), 0), \n\ttermchar(vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.6666666666666666, 0.3333333333333333, 0.0), 0), \n\ttermchar(vec3(0.0, 0.0, 0.6666666666666666), vec3(0.0, 0.0, 0.6666666666666666), vec3(0.0, 0.0, 0.6666666666666666), 0), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.6666666666666666, 0.0, 0.6666666666666666), 0), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.0, 0.6666666666666666, 0.6666666666666666), 0), \n\ttermchar(vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), 0), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), 0), \n\ttermchar(vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(1.0, 0.3333333333333333, 0.3333333333333333), 0), \n\ttermchar(vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.3333333333333333, 1.0, 0.3333333333333333), 0), \n\ttermchar(vec3(1.0, 1.0, 0.3333333333333333), vec3(1.0, 1.0, 0.3333333333333333), vec3(1.0, 1.0, 0.3333333333333333), 0), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.3333333333333333, 0.3333333333333333, 1.0), 0), \n\ttermchar(vec3(1.0, 0.3333333333333333, 1.0), vec3(1.0, 0.3333333333333333, 1.0), vec3(1.0, 0.3333333333333333, 1.0), 0), \n\ttermchar(vec3(0.3333333333333333, 1.0, 1.0), vec3(0.3333333333333333, 1.0, 1.0), vec3(0.3333333333333333, 1.0, 1.0), 0), \n\ttermchar(vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, 1.0), 0), \n\ttermchar(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 1), \n\ttermchar(vec3(0.0, 0.0, 0.0), vec3(0.6666666666666666, 0.0, 0.0), vec3(0.3333333333333333, 0.0, 0.0), 1), \n\ttermchar(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.6666666666666666, 0.0), vec3(0.0, 0.3333333333333333, 0.0), 1), \n\ttermchar(vec3(0.0, 0.0, 0.0), vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.3333333333333333, 0.16666666666666666, 0.0), 1), \n\ttermchar(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.6666666666666666), vec3(0.0, 0.0, 0.3333333333333333), 1), \n\ttermchar(vec3(0.0, 0.0, 0.0), vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.3333333333333333, 0.0, 0.3333333333333333), 1), \n\ttermchar(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.0, 0.3333333333333333, 0.3333333333333333), 1), \n\ttermchar(vec3(0.0, 0.0, 0.0), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), 1), \n\ttermchar(vec3(0.0, 0.0, 0.0), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.16666666666666666, 0.16666666666666666, 0.16666666666666666), 1), \n\ttermchar(vec3(0.0, 0.0, 0.0), vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.5, 0.16666666666666666, 0.16666666666666666), 1), \n\ttermchar(vec3(0.0, 0.0, 0.0), vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.16666666666666666, 0.5, 0.16666666666666666), 1), \n\ttermchar(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 0.3333333333333333), vec3(0.5, 0.5, 0.16666666666666666), 1), \n\ttermchar(vec3(0.0, 0.0, 0.0), vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.16666666666666666, 0.16666666666666666, 0.5), 1), \n\ttermchar(vec3(0.0, 0.0, 0.0), vec3(1.0, 0.3333333333333333, 1.0), vec3(0.5, 0.16666666666666666, 0.5), 1), \n\ttermchar(vec3(0.0, 0.0, 0.0), vec3(0.3333333333333333, 1.0, 1.0), vec3(0.16666666666666666, 0.5, 0.5), 1), \n\ttermchar(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0), vec3(0.5, 0.5, 0.5), 1), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.3333333333333333, 0.0, 0.0), 1), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.0), vec3(0.6666666666666666, 0.0, 0.0), vec3(0.6666666666666666, 0.0, 0.0), 1), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.0), vec3(0.0, 0.6666666666666666, 0.0), vec3(0.3333333333333333, 0.3333333333333333, 0.0), 1), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.0), vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.6666666666666666, 0.16666666666666666, 0.0), 1), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.0), vec3(0.0, 0.0, 0.6666666666666666), vec3(0.3333333333333333, 0.0, 0.3333333333333333), 1), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.0), vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.6666666666666666, 0.0, 0.3333333333333333), 1), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.0), vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), 1), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.0), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.6666666666666666, 0.3333333333333333, 0.3333333333333333), 1), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.0), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.5, 0.16666666666666666, 0.16666666666666666), 1), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.0), vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.8333333333333333, 0.16666666666666666, 0.16666666666666666), 1), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.0), vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.5, 0.5, 0.16666666666666666), 1), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.0), vec3(1.0, 1.0, 0.3333333333333333), vec3(0.8333333333333333, 0.5, 0.16666666666666666), 1), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.0), vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.5, 0.16666666666666666, 0.5), 1), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.0), vec3(1.0, 0.3333333333333333, 1.0), vec3(0.8333333333333333, 0.16666666666666666, 0.5), 1), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.0), vec3(0.3333333333333333, 1.0, 1.0), vec3(0.5, 0.5, 0.5), 1), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.0), vec3(1.0, 1.0, 1.0), vec3(0.8333333333333333, 0.5, 0.5), 1), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.3333333333333333, 0.0), 1), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.0), vec3(0.6666666666666666, 0.0, 0.0), vec3(0.3333333333333333, 0.3333333333333333, 0.0), 1), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.0), vec3(0.0, 0.6666666666666666, 0.0), vec3(0.0, 0.6666666666666666, 0.0), 1), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.0), vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.3333333333333333, 0.5, 0.0), 1), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.0), vec3(0.0, 0.0, 0.6666666666666666), vec3(0.0, 0.3333333333333333, 0.3333333333333333), 1), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.0), vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), 1), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.0), vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.0, 0.6666666666666666, 0.3333333333333333), 1), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.0), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.3333333333333333, 0.6666666666666666, 0.3333333333333333), 1), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.0), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.16666666666666666, 0.5, 0.16666666666666666), 1), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.0), vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.5, 0.5, 0.16666666666666666), 1), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.0), vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.16666666666666666, 0.8333333333333333, 0.16666666666666666), 1), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.0), vec3(1.0, 1.0, 0.3333333333333333), vec3(0.5, 0.8333333333333333, 0.16666666666666666), 1), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.0), vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.16666666666666666, 0.5, 0.5), 1), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.0), vec3(1.0, 0.3333333333333333, 1.0), vec3(0.5, 0.5, 0.5), 1), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.0), vec3(0.3333333333333333, 1.0, 1.0), vec3(0.16666666666666666, 0.8333333333333333, 0.5), 1), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.0), vec3(1.0, 1.0, 1.0), vec3(0.5, 0.8333333333333333, 0.5), 1), \n\ttermchar(vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.3333333333333333, 0.16666666666666666, 0.0), 1), \n\ttermchar(vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.6666666666666666, 0.0, 0.0), vec3(0.6666666666666666, 0.16666666666666666, 0.0), 1), \n\ttermchar(vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.0, 0.6666666666666666, 0.0), vec3(0.3333333333333333, 0.5, 0.0), 1), \n\ttermchar(vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.6666666666666666, 0.3333333333333333, 0.0), 1), \n\ttermchar(vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.0, 0.0, 0.6666666666666666), vec3(0.3333333333333333, 0.16666666666666666, 0.3333333333333333), 1), \n\ttermchar(vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.6666666666666666, 0.16666666666666666, 0.3333333333333333), 1), \n\ttermchar(vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.3333333333333333, 0.5, 0.3333333333333333), 1), \n\ttermchar(vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.6666666666666666, 0.5, 0.3333333333333333), 1), \n\ttermchar(vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.5, 0.3333333333333333, 0.16666666666666666), 1), \n\ttermchar(vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.8333333333333333, 0.3333333333333333, 0.16666666666666666), 1), \n\ttermchar(vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.5, 0.6666666666666666, 0.16666666666666666), 1), \n\ttermchar(vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(1.0, 1.0, 0.3333333333333333), vec3(0.8333333333333333, 0.6666666666666666, 0.16666666666666666), 1), \n\ttermchar(vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.5, 0.3333333333333333, 0.5), 1), \n\ttermchar(vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(1.0, 0.3333333333333333, 1.0), vec3(0.8333333333333333, 0.3333333333333333, 0.5), 1), \n\ttermchar(vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.3333333333333333, 1.0, 1.0), vec3(0.5, 0.6666666666666666, 0.5), 1), \n\ttermchar(vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(1.0, 1.0, 1.0), vec3(0.8333333333333333, 0.6666666666666666, 0.5), 1), \n\ttermchar(vec3(0.0, 0.0, 0.6666666666666666), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.3333333333333333), 1), \n\ttermchar(vec3(0.0, 0.0, 0.6666666666666666), vec3(0.6666666666666666, 0.0, 0.0), vec3(0.3333333333333333, 0.0, 0.3333333333333333), 1), \n\ttermchar(vec3(0.0, 0.0, 0.6666666666666666), vec3(0.0, 0.6666666666666666, 0.0), vec3(0.0, 0.3333333333333333, 0.3333333333333333), 1), \n\ttermchar(vec3(0.0, 0.0, 0.6666666666666666), vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.3333333333333333, 0.16666666666666666, 0.3333333333333333), 1), \n\ttermchar(vec3(0.0, 0.0, 0.6666666666666666), vec3(0.0, 0.0, 0.6666666666666666), vec3(0.0, 0.0, 0.6666666666666666), 1), \n\ttermchar(vec3(0.0, 0.0, 0.6666666666666666), vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.3333333333333333, 0.0, 0.6666666666666666), 1), \n\ttermchar(vec3(0.0, 0.0, 0.6666666666666666), vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.0, 0.3333333333333333, 0.6666666666666666), 1), \n\ttermchar(vec3(0.0, 0.0, 0.6666666666666666), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.3333333333333333, 0.3333333333333333, 0.6666666666666666), 1), \n\ttermchar(vec3(0.0, 0.0, 0.6666666666666666), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.16666666666666666, 0.16666666666666666, 0.5), 1), \n\ttermchar(vec3(0.0, 0.0, 0.6666666666666666), vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.5, 0.16666666666666666, 0.5), 1), \n\ttermchar(vec3(0.0, 0.0, 0.6666666666666666), vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.16666666666666666, 0.5, 0.5), 1), \n\ttermchar(vec3(0.0, 0.0, 0.6666666666666666), vec3(1.0, 1.0, 0.3333333333333333), vec3(0.5, 0.5, 0.5), 1), \n\ttermchar(vec3(0.0, 0.0, 0.6666666666666666), vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.16666666666666666, 0.16666666666666666, 0.8333333333333333), 1), \n\ttermchar(vec3(0.0, 0.0, 0.6666666666666666), vec3(1.0, 0.3333333333333333, 1.0), vec3(0.5, 0.16666666666666666, 0.8333333333333333), 1), \n\ttermchar(vec3(0.0, 0.0, 0.6666666666666666), vec3(0.3333333333333333, 1.0, 1.0), vec3(0.16666666666666666, 0.5, 0.8333333333333333), 1), \n\ttermchar(vec3(0.0, 0.0, 0.6666666666666666), vec3(1.0, 1.0, 1.0), vec3(0.5, 0.5, 0.8333333333333333), 1), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.0, 0.0, 0.0), vec3(0.3333333333333333, 0.0, 0.3333333333333333), 1), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.6666666666666666, 0.0, 0.0), vec3(0.6666666666666666, 0.0, 0.3333333333333333), 1), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.0, 0.6666666666666666, 0.0), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), 1), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.6666666666666666, 0.16666666666666666, 0.3333333333333333), 1), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.0, 0.0, 0.6666666666666666), vec3(0.3333333333333333, 0.0, 0.6666666666666666), 1), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.6666666666666666, 0.0, 0.6666666666666666), 1), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.3333333333333333, 0.3333333333333333, 0.6666666666666666), 1), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.6666666666666666, 0.3333333333333333, 0.6666666666666666), 1), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.5, 0.16666666666666666, 0.5), 1), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.8333333333333333, 0.16666666666666666, 0.5), 1), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.5, 0.5, 0.5), 1), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(1.0, 1.0, 0.3333333333333333), vec3(0.8333333333333333, 0.5, 0.5), 1), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.5, 0.16666666666666666, 0.8333333333333333), 1), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(1.0, 0.3333333333333333, 1.0), vec3(0.8333333333333333, 0.16666666666666666, 0.8333333333333333), 1), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.3333333333333333, 1.0, 1.0), vec3(0.5, 0.5, 0.8333333333333333), 1), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(1.0, 1.0, 1.0), vec3(0.8333333333333333, 0.5, 0.8333333333333333), 1), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.3333333333333333, 0.3333333333333333), 1), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.6666666666666666, 0.0, 0.0), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), 1), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.0, 0.6666666666666666, 0.0), vec3(0.0, 0.6666666666666666, 0.3333333333333333), 1), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.3333333333333333, 0.5, 0.3333333333333333), 1), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.0, 0.0, 0.6666666666666666), vec3(0.0, 0.3333333333333333, 0.6666666666666666), 1), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.3333333333333333, 0.3333333333333333, 0.6666666666666666), 1), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.0, 0.6666666666666666, 0.6666666666666666), 1), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.3333333333333333, 0.6666666666666666, 0.6666666666666666), 1), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.16666666666666666, 0.5, 0.5), 1), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.5, 0.5, 0.5), 1), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.16666666666666666, 0.8333333333333333, 0.5), 1), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(1.0, 1.0, 0.3333333333333333), vec3(0.5, 0.8333333333333333, 0.5), 1), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.16666666666666666, 0.5, 0.8333333333333333), 1), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(1.0, 0.3333333333333333, 1.0), vec3(0.5, 0.5, 0.8333333333333333), 1), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.3333333333333333, 1.0, 1.0), vec3(0.16666666666666666, 0.8333333333333333, 0.8333333333333333), 1), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(1.0, 1.0, 1.0), vec3(0.5, 0.8333333333333333, 0.8333333333333333), 1), \n\ttermchar(vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.0, 0.0, 0.0), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), 1), \n\ttermchar(vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.6666666666666666, 0.0, 0.0), vec3(0.6666666666666666, 0.3333333333333333, 0.3333333333333333), 1), \n\ttermchar(vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.0, 0.6666666666666666, 0.0), vec3(0.3333333333333333, 0.6666666666666666, 0.3333333333333333), 1), \n\ttermchar(vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.6666666666666666, 0.5, 0.3333333333333333), 1), \n\ttermchar(vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.0, 0.0, 0.6666666666666666), vec3(0.3333333333333333, 0.3333333333333333, 0.6666666666666666), 1), \n\ttermchar(vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.6666666666666666, 0.3333333333333333, 0.6666666666666666), 1), \n\ttermchar(vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.3333333333333333, 0.6666666666666666, 0.6666666666666666), 1), \n\ttermchar(vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), 1), \n\ttermchar(vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.5, 0.5, 0.5), 1), \n\ttermchar(vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.8333333333333333, 0.5, 0.5), 1), \n\ttermchar(vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.5, 0.8333333333333333, 0.5), 1), \n\ttermchar(vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(1.0, 1.0, 0.3333333333333333), vec3(0.8333333333333333, 0.8333333333333333, 0.5), 1), \n\ttermchar(vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.5, 0.5, 0.8333333333333333), 1), \n\ttermchar(vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(1.0, 0.3333333333333333, 1.0), vec3(0.8333333333333333, 0.5, 0.8333333333333333), 1), \n\ttermchar(vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.3333333333333333, 1.0, 1.0), vec3(0.5, 0.8333333333333333, 0.8333333333333333), 1), \n\ttermchar(vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(1.0, 1.0, 1.0), vec3(0.8333333333333333, 0.8333333333333333, 0.8333333333333333), 1), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.0, 0.0, 0.0), vec3(0.16666666666666666, 0.16666666666666666, 0.16666666666666666), 1), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.6666666666666666, 0.0, 0.0), vec3(0.5, 0.16666666666666666, 0.16666666666666666), 1), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.0, 0.6666666666666666, 0.0), vec3(0.16666666666666666, 0.5, 0.16666666666666666), 1), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.5, 0.3333333333333333, 0.16666666666666666), 1), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.0, 0.0, 0.6666666666666666), vec3(0.16666666666666666, 0.16666666666666666, 0.5), 1), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.5, 0.16666666666666666, 0.5), 1), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.16666666666666666, 0.5, 0.5), 1), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.5, 0.5, 0.5), 1), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), 1), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.6666666666666666, 0.3333333333333333, 0.3333333333333333), 1), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.3333333333333333, 0.6666666666666666, 0.3333333333333333), 1), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(1.0, 1.0, 0.3333333333333333), vec3(0.6666666666666666, 0.6666666666666666, 0.3333333333333333), 1), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.3333333333333333, 0.3333333333333333, 0.6666666666666666), 1), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(1.0, 0.3333333333333333, 1.0), vec3(0.6666666666666666, 0.3333333333333333, 0.6666666666666666), 1), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.3333333333333333, 1.0, 1.0), vec3(0.3333333333333333, 0.6666666666666666, 0.6666666666666666), 1), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(1.0, 1.0, 1.0), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), 1), \n\ttermchar(vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.0, 0.0, 0.0), vec3(0.5, 0.16666666666666666, 0.16666666666666666), 1), \n\ttermchar(vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.6666666666666666, 0.0, 0.0), vec3(0.8333333333333333, 0.16666666666666666, 0.16666666666666666), 1), \n\ttermchar(vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.0, 0.6666666666666666, 0.0), vec3(0.5, 0.5, 0.16666666666666666), 1), \n\ttermchar(vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.8333333333333333, 0.3333333333333333, 0.16666666666666666), 1), \n\ttermchar(vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.0, 0.0, 0.6666666666666666), vec3(0.5, 0.16666666666666666, 0.5), 1), \n\ttermchar(vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.8333333333333333, 0.16666666666666666, 0.5), 1), \n\ttermchar(vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.5, 0.5, 0.5), 1), \n\ttermchar(vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.8333333333333333, 0.5, 0.5), 1), \n\ttermchar(vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.6666666666666666, 0.3333333333333333, 0.3333333333333333), 1), \n\ttermchar(vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(1.0, 0.3333333333333333, 0.3333333333333333), 1), \n\ttermchar(vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.6666666666666666, 0.6666666666666666, 0.3333333333333333), 1), \n\ttermchar(vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(1.0, 1.0, 0.3333333333333333), vec3(1.0, 0.6666666666666666, 0.3333333333333333), 1), \n\ttermchar(vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.6666666666666666, 0.3333333333333333, 0.6666666666666666), 1), \n\ttermchar(vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(1.0, 0.3333333333333333, 1.0), vec3(1.0, 0.3333333333333333, 0.6666666666666666), 1), \n\ttermchar(vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.3333333333333333, 1.0, 1.0), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), 1), \n\ttermchar(vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(1.0, 1.0, 1.0), vec3(1.0, 0.6666666666666666, 0.6666666666666666), 1), \n\ttermchar(vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.0, 0.0, 0.0), vec3(0.16666666666666666, 0.5, 0.16666666666666666), 1), \n\ttermchar(vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.6666666666666666, 0.0, 0.0), vec3(0.5, 0.5, 0.16666666666666666), 1), \n\ttermchar(vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.0, 0.6666666666666666, 0.0), vec3(0.16666666666666666, 0.8333333333333333, 0.16666666666666666), 1), \n\ttermchar(vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.5, 0.6666666666666666, 0.16666666666666666), 1), \n\ttermchar(vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.0, 0.0, 0.6666666666666666), vec3(0.16666666666666666, 0.5, 0.5), 1), \n\ttermchar(vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.5, 0.5, 0.5), 1), \n\ttermchar(vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.16666666666666666, 0.8333333333333333, 0.5), 1), \n\ttermchar(vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.5, 0.8333333333333333, 0.5), 1), \n\ttermchar(vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.3333333333333333, 0.6666666666666666, 0.3333333333333333), 1), \n\ttermchar(vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.6666666666666666, 0.6666666666666666, 0.3333333333333333), 1), \n\ttermchar(vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.3333333333333333, 1.0, 0.3333333333333333), 1), \n\ttermchar(vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(1.0, 1.0, 0.3333333333333333), vec3(0.6666666666666666, 1.0, 0.3333333333333333), 1), \n\ttermchar(vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.3333333333333333, 0.6666666666666666, 0.6666666666666666), 1), \n\ttermchar(vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(1.0, 0.3333333333333333, 1.0), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), 1), \n\ttermchar(vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.3333333333333333, 1.0, 1.0), vec3(0.3333333333333333, 1.0, 0.6666666666666666), 1), \n\ttermchar(vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(1.0, 1.0, 1.0), vec3(0.6666666666666666, 1.0, 0.6666666666666666), 1), \n\ttermchar(vec3(1.0, 1.0, 0.3333333333333333), vec3(0.0, 0.0, 0.0), vec3(0.5, 0.5, 0.16666666666666666), 1), \n\ttermchar(vec3(1.0, 1.0, 0.3333333333333333), vec3(0.6666666666666666, 0.0, 0.0), vec3(0.8333333333333333, 0.5, 0.16666666666666666), 1), \n\ttermchar(vec3(1.0, 1.0, 0.3333333333333333), vec3(0.0, 0.6666666666666666, 0.0), vec3(0.5, 0.8333333333333333, 0.16666666666666666), 1), \n\ttermchar(vec3(1.0, 1.0, 0.3333333333333333), vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.8333333333333333, 0.6666666666666666, 0.16666666666666666), 1), \n\ttermchar(vec3(1.0, 1.0, 0.3333333333333333), vec3(0.0, 0.0, 0.6666666666666666), vec3(0.5, 0.5, 0.5), 1), \n\ttermchar(vec3(1.0, 1.0, 0.3333333333333333), vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.8333333333333333, 0.5, 0.5), 1), \n\ttermchar(vec3(1.0, 1.0, 0.3333333333333333), vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.5, 0.8333333333333333, 0.5), 1), \n\ttermchar(vec3(1.0, 1.0, 0.3333333333333333), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.8333333333333333, 0.8333333333333333, 0.5), 1), \n\ttermchar(vec3(1.0, 1.0, 0.3333333333333333), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.6666666666666666, 0.6666666666666666, 0.3333333333333333), 1), \n\ttermchar(vec3(1.0, 1.0, 0.3333333333333333), vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(1.0, 0.6666666666666666, 0.3333333333333333), 1), \n\ttermchar(vec3(1.0, 1.0, 0.3333333333333333), vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.6666666666666666, 1.0, 0.3333333333333333), 1), \n\ttermchar(vec3(1.0, 1.0, 0.3333333333333333), vec3(1.0, 1.0, 0.3333333333333333), vec3(1.0, 1.0, 0.3333333333333333), 1), \n\ttermchar(vec3(1.0, 1.0, 0.3333333333333333), vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), 1), \n\ttermchar(vec3(1.0, 1.0, 0.3333333333333333), vec3(1.0, 0.3333333333333333, 1.0), vec3(1.0, 0.6666666666666666, 0.6666666666666666), 1), \n\ttermchar(vec3(1.0, 1.0, 0.3333333333333333), vec3(0.3333333333333333, 1.0, 1.0), vec3(0.6666666666666666, 1.0, 0.6666666666666666), 1), \n\ttermchar(vec3(1.0, 1.0, 0.3333333333333333), vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, 0.6666666666666666), 1), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.0, 0.0, 0.0), vec3(0.16666666666666666, 0.16666666666666666, 0.5), 1), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.6666666666666666, 0.0, 0.0), vec3(0.5, 0.16666666666666666, 0.5), 1), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.0, 0.6666666666666666, 0.0), vec3(0.16666666666666666, 0.5, 0.5), 1), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.5, 0.3333333333333333, 0.5), 1), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.0, 0.0, 0.6666666666666666), vec3(0.16666666666666666, 0.16666666666666666, 0.8333333333333333), 1), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.5, 0.16666666666666666, 0.8333333333333333), 1), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.16666666666666666, 0.5, 0.8333333333333333), 1), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.5, 0.5, 0.8333333333333333), 1), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.3333333333333333, 0.3333333333333333, 0.6666666666666666), 1), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.6666666666666666, 0.3333333333333333, 0.6666666666666666), 1), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.3333333333333333, 0.6666666666666666, 0.6666666666666666), 1), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(1.0, 1.0, 0.3333333333333333), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), 1), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.3333333333333333, 0.3333333333333333, 1.0), 1), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(1.0, 0.3333333333333333, 1.0), vec3(0.6666666666666666, 0.3333333333333333, 1.0), 1), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.3333333333333333, 1.0, 1.0), vec3(0.3333333333333333, 0.6666666666666666, 1.0), 1), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(1.0, 1.0, 1.0), vec3(0.6666666666666666, 0.6666666666666666, 1.0), 1), \n\ttermchar(vec3(1.0, 0.3333333333333333, 1.0), vec3(0.0, 0.0, 0.0), vec3(0.5, 0.16666666666666666, 0.5), 1), \n\ttermchar(vec3(1.0, 0.3333333333333333, 1.0), vec3(0.6666666666666666, 0.0, 0.0), vec3(0.8333333333333333, 0.16666666666666666, 0.5), 1), \n\ttermchar(vec3(1.0, 0.3333333333333333, 1.0), vec3(0.0, 0.6666666666666666, 0.0), vec3(0.5, 0.5, 0.5), 1), \n\ttermchar(vec3(1.0, 0.3333333333333333, 1.0), vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.8333333333333333, 0.3333333333333333, 0.5), 1), \n\ttermchar(vec3(1.0, 0.3333333333333333, 1.0), vec3(0.0, 0.0, 0.6666666666666666), vec3(0.5, 0.16666666666666666, 0.8333333333333333), 1), \n\ttermchar(vec3(1.0, 0.3333333333333333, 1.0), vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.8333333333333333, 0.16666666666666666, 0.8333333333333333), 1), \n\ttermchar(vec3(1.0, 0.3333333333333333, 1.0), vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.5, 0.5, 0.8333333333333333), 1), \n\ttermchar(vec3(1.0, 0.3333333333333333, 1.0), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.8333333333333333, 0.5, 0.8333333333333333), 1), \n\ttermchar(vec3(1.0, 0.3333333333333333, 1.0), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.6666666666666666, 0.3333333333333333, 0.6666666666666666), 1), \n\ttermchar(vec3(1.0, 0.3333333333333333, 1.0), vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(1.0, 0.3333333333333333, 0.6666666666666666), 1), \n\ttermchar(vec3(1.0, 0.3333333333333333, 1.0), vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), 1), \n\ttermchar(vec3(1.0, 0.3333333333333333, 1.0), vec3(1.0, 1.0, 0.3333333333333333), vec3(1.0, 0.6666666666666666, 0.6666666666666666), 1), \n\ttermchar(vec3(1.0, 0.3333333333333333, 1.0), vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.6666666666666666, 0.3333333333333333, 1.0), 1), \n\ttermchar(vec3(1.0, 0.3333333333333333, 1.0), vec3(1.0, 0.3333333333333333, 1.0), vec3(1.0, 0.3333333333333333, 1.0), 1), \n\ttermchar(vec3(1.0, 0.3333333333333333, 1.0), vec3(0.3333333333333333, 1.0, 1.0), vec3(0.6666666666666666, 0.6666666666666666, 1.0), 1), \n\ttermchar(vec3(1.0, 0.3333333333333333, 1.0), vec3(1.0, 1.0, 1.0), vec3(1.0, 0.6666666666666666, 1.0), 1), \n\ttermchar(vec3(0.3333333333333333, 1.0, 1.0), vec3(0.0, 0.0, 0.0), vec3(0.16666666666666666, 0.5, 0.5), 1), \n\ttermchar(vec3(0.3333333333333333, 1.0, 1.0), vec3(0.6666666666666666, 0.0, 0.0), vec3(0.5, 0.5, 0.5), 1), \n\ttermchar(vec3(0.3333333333333333, 1.0, 1.0), vec3(0.0, 0.6666666666666666, 0.0), vec3(0.16666666666666666, 0.8333333333333333, 0.5), 1), \n\ttermchar(vec3(0.3333333333333333, 1.0, 1.0), vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.5, 0.6666666666666666, 0.5), 1), \n\ttermchar(vec3(0.3333333333333333, 1.0, 1.0), vec3(0.0, 0.0, 0.6666666666666666), vec3(0.16666666666666666, 0.5, 0.8333333333333333), 1), \n\ttermchar(vec3(0.3333333333333333, 1.0, 1.0), vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.5, 0.5, 0.8333333333333333), 1), \n\ttermchar(vec3(0.3333333333333333, 1.0, 1.0), vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.16666666666666666, 0.8333333333333333, 0.8333333333333333), 1), \n\ttermchar(vec3(0.3333333333333333, 1.0, 1.0), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.5, 0.8333333333333333, 0.8333333333333333), 1), \n\ttermchar(vec3(0.3333333333333333, 1.0, 1.0), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.3333333333333333, 0.6666666666666666, 0.6666666666666666), 1), \n\ttermchar(vec3(0.3333333333333333, 1.0, 1.0), vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), 1), \n\ttermchar(vec3(0.3333333333333333, 1.0, 1.0), vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.3333333333333333, 1.0, 0.6666666666666666), 1), \n\ttermchar(vec3(0.3333333333333333, 1.0, 1.0), vec3(1.0, 1.0, 0.3333333333333333), vec3(0.6666666666666666, 1.0, 0.6666666666666666), 1), \n\ttermchar(vec3(0.3333333333333333, 1.0, 1.0), vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.3333333333333333, 0.6666666666666666, 1.0), 1), \n\ttermchar(vec3(0.3333333333333333, 1.0, 1.0), vec3(1.0, 0.3333333333333333, 1.0), vec3(0.6666666666666666, 0.6666666666666666, 1.0), 1), \n\ttermchar(vec3(0.3333333333333333, 1.0, 1.0), vec3(0.3333333333333333, 1.0, 1.0), vec3(0.3333333333333333, 1.0, 1.0), 1), \n\ttermchar(vec3(0.3333333333333333, 1.0, 1.0), vec3(1.0, 1.0, 1.0), vec3(0.6666666666666666, 1.0, 1.0), 1), \n\ttermchar(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0), vec3(0.5, 0.5, 0.5), 1), \n\ttermchar(vec3(1.0, 1.0, 1.0), vec3(0.6666666666666666, 0.0, 0.0), vec3(0.8333333333333333, 0.5, 0.5), 1), \n\ttermchar(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.6666666666666666, 0.0), vec3(0.5, 0.8333333333333333, 0.5), 1), \n\ttermchar(vec3(1.0, 1.0, 1.0), vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.8333333333333333, 0.6666666666666666, 0.5), 1), \n\ttermchar(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.6666666666666666), vec3(0.5, 0.5, 0.8333333333333333), 1), \n\ttermchar(vec3(1.0, 1.0, 1.0), vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.8333333333333333, 0.5, 0.8333333333333333), 1), \n\ttermchar(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.5, 0.8333333333333333, 0.8333333333333333), 1), \n\ttermchar(vec3(1.0, 1.0, 1.0), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.8333333333333333, 0.8333333333333333, 0.8333333333333333), 1), \n\ttermchar(vec3(1.0, 1.0, 1.0), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), 1), \n\ttermchar(vec3(1.0, 1.0, 1.0), vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(1.0, 0.6666666666666666, 0.6666666666666666), 1), \n\ttermchar(vec3(1.0, 1.0, 1.0), vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.6666666666666666, 1.0, 0.6666666666666666), 1), \n\ttermchar(vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, 0.3333333333333333), vec3(1.0, 1.0, 0.6666666666666666), 1), \n\ttermchar(vec3(1.0, 1.0, 1.0), vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.6666666666666666, 0.6666666666666666, 1.0), 1), \n\ttermchar(vec3(1.0, 1.0, 1.0), vec3(1.0, 0.3333333333333333, 1.0), vec3(1.0, 0.6666666666666666, 1.0), 1), \n\ttermchar(vec3(1.0, 1.0, 1.0), vec3(0.3333333333333333, 1.0, 1.0), vec3(0.6666666666666666, 1.0, 1.0), 1), \n\ttermchar(vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, 1.0), 1), \n\ttermchar(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 2), \n\ttermchar(vec3(0.0, 0.0, 0.0), vec3(0.6666666666666666, 0.0, 0.0), vec3(0.16666666666666666, 0.0, 0.0), 2), \n\ttermchar(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.6666666666666666, 0.0), vec3(0.0, 0.16666666666666666, 0.0), 2), \n\ttermchar(vec3(0.0, 0.0, 0.0), vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.16666666666666666, 0.08333333333333333, 0.0), 2), \n\ttermchar(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.6666666666666666), vec3(0.0, 0.0, 0.16666666666666666), 2), \n\ttermchar(vec3(0.0, 0.0, 0.0), vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.16666666666666666, 0.0, 0.16666666666666666), 2), \n\ttermchar(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.0, 0.16666666666666666, 0.16666666666666666), 2), \n\ttermchar(vec3(0.0, 0.0, 0.0), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.16666666666666666, 0.16666666666666666, 0.16666666666666666), 2), \n\ttermchar(vec3(0.0, 0.0, 0.0), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.08333333333333333, 0.08333333333333333, 0.08333333333333333), 2), \n\ttermchar(vec3(0.0, 0.0, 0.0), vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.25, 0.08333333333333333, 0.08333333333333333), 2), \n\ttermchar(vec3(0.0, 0.0, 0.0), vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.08333333333333333, 0.25, 0.08333333333333333), 2), \n\ttermchar(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 0.3333333333333333), vec3(0.25, 0.25, 0.08333333333333333), 2), \n\ttermchar(vec3(0.0, 0.0, 0.0), vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.08333333333333333, 0.08333333333333333, 0.25), 2), \n\ttermchar(vec3(0.0, 0.0, 0.0), vec3(1.0, 0.3333333333333333, 1.0), vec3(0.25, 0.08333333333333333, 0.25), 2), \n\ttermchar(vec3(0.0, 0.0, 0.0), vec3(0.3333333333333333, 1.0, 1.0), vec3(0.08333333333333333, 0.25, 0.25), 2), \n\ttermchar(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0), vec3(0.25, 0.25, 0.25), 2), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.5, 0.0, 0.0), 2), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.0), vec3(0.6666666666666666, 0.0, 0.0), vec3(0.6666666666666666, 0.0, 0.0), 2), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.0), vec3(0.0, 0.6666666666666666, 0.0), vec3(0.5, 0.16666666666666666, 0.0), 2), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.0), vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.6666666666666666, 0.08333333333333333, 0.0), 2), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.0), vec3(0.0, 0.0, 0.6666666666666666), vec3(0.5, 0.0, 0.16666666666666666), 2), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.0), vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.6666666666666666, 0.0, 0.16666666666666666), 2), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.0), vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.5, 0.16666666666666666, 0.16666666666666666), 2), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.0), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.6666666666666666, 0.16666666666666666, 0.16666666666666666), 2), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.0), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.5833333333333334, 0.08333333333333333, 0.08333333333333333), 2), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.0), vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.75, 0.08333333333333333, 0.08333333333333333), 2), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.0), vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.5833333333333334, 0.25, 0.08333333333333333), 2), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.0), vec3(1.0, 1.0, 0.3333333333333333), vec3(0.75, 0.25, 0.08333333333333333), 2), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.0), vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.5833333333333334, 0.08333333333333333, 0.25), 2), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.0), vec3(1.0, 0.3333333333333333, 1.0), vec3(0.75, 0.08333333333333333, 0.25), 2), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.0), vec3(0.3333333333333333, 1.0, 1.0), vec3(0.5833333333333334, 0.25, 0.25), 2), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.0), vec3(1.0, 1.0, 1.0), vec3(0.75, 0.25, 0.25), 2), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.5, 0.0), 2), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.0), vec3(0.6666666666666666, 0.0, 0.0), vec3(0.16666666666666666, 0.5, 0.0), 2), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.0), vec3(0.0, 0.6666666666666666, 0.0), vec3(0.0, 0.6666666666666666, 0.0), 2), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.0), vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.16666666666666666, 0.5833333333333334, 0.0), 2), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.0), vec3(0.0, 0.0, 0.6666666666666666), vec3(0.0, 0.5, 0.16666666666666666), 2), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.0), vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.16666666666666666, 0.5, 0.16666666666666666), 2), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.0), vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.0, 0.6666666666666666, 0.16666666666666666), 2), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.0), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.16666666666666666, 0.6666666666666666, 0.16666666666666666), 2), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.0), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.08333333333333333, 0.5833333333333334, 0.08333333333333333), 2), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.0), vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.25, 0.5833333333333334, 0.08333333333333333), 2), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.0), vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.08333333333333333, 0.75, 0.08333333333333333), 2), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.0), vec3(1.0, 1.0, 0.3333333333333333), vec3(0.25, 0.75, 0.08333333333333333), 2), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.0), vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.08333333333333333, 0.5833333333333334, 0.25), 2), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.0), vec3(1.0, 0.3333333333333333, 1.0), vec3(0.25, 0.5833333333333334, 0.25), 2), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.0), vec3(0.3333333333333333, 1.0, 1.0), vec3(0.08333333333333333, 0.75, 0.25), 2), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.0), vec3(1.0, 1.0, 1.0), vec3(0.25, 0.75, 0.25), 2), \n\ttermchar(vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.5, 0.25, 0.0), 2), \n\ttermchar(vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.6666666666666666, 0.0, 0.0), vec3(0.6666666666666666, 0.25, 0.0), 2), \n\ttermchar(vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.0, 0.6666666666666666, 0.0), vec3(0.5, 0.41666666666666663, 0.0), 2), \n\ttermchar(vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.6666666666666666, 0.3333333333333333, 0.0), 2), \n\ttermchar(vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.0, 0.0, 0.6666666666666666), vec3(0.5, 0.25, 0.16666666666666666), 2), \n\ttermchar(vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.6666666666666666, 0.25, 0.16666666666666666), 2), \n\ttermchar(vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.5, 0.41666666666666663, 0.16666666666666666), 2), \n\ttermchar(vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.6666666666666666, 0.41666666666666663, 0.16666666666666666), 2), \n\ttermchar(vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.5833333333333334, 0.3333333333333333, 0.08333333333333333), 2), \n\ttermchar(vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.75, 0.3333333333333333, 0.08333333333333333), 2), \n\ttermchar(vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.5833333333333334, 0.5, 0.08333333333333333), 2), \n\ttermchar(vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(1.0, 1.0, 0.3333333333333333), vec3(0.75, 0.5, 0.08333333333333333), 2), \n\ttermchar(vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.5833333333333334, 0.3333333333333333, 0.25), 2), \n\ttermchar(vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(1.0, 0.3333333333333333, 1.0), vec3(0.75, 0.3333333333333333, 0.25), 2), \n\ttermchar(vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.3333333333333333, 1.0, 1.0), vec3(0.5833333333333334, 0.5, 0.25), 2), \n\ttermchar(vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(1.0, 1.0, 1.0), vec3(0.75, 0.5, 0.25), 2), \n\ttermchar(vec3(0.0, 0.0, 0.6666666666666666), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.5), 2), \n\ttermchar(vec3(0.0, 0.0, 0.6666666666666666), vec3(0.6666666666666666, 0.0, 0.0), vec3(0.16666666666666666, 0.0, 0.5), 2), \n\ttermchar(vec3(0.0, 0.0, 0.6666666666666666), vec3(0.0, 0.6666666666666666, 0.0), vec3(0.0, 0.16666666666666666, 0.5), 2), \n\ttermchar(vec3(0.0, 0.0, 0.6666666666666666), vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.16666666666666666, 0.08333333333333333, 0.5), 2), \n\ttermchar(vec3(0.0, 0.0, 0.6666666666666666), vec3(0.0, 0.0, 0.6666666666666666), vec3(0.0, 0.0, 0.6666666666666666), 2), \n\ttermchar(vec3(0.0, 0.0, 0.6666666666666666), vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.16666666666666666, 0.0, 0.6666666666666666), 2), \n\ttermchar(vec3(0.0, 0.0, 0.6666666666666666), vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.0, 0.16666666666666666, 0.6666666666666666), 2), \n\ttermchar(vec3(0.0, 0.0, 0.6666666666666666), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.16666666666666666, 0.16666666666666666, 0.6666666666666666), 2), \n\ttermchar(vec3(0.0, 0.0, 0.6666666666666666), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.08333333333333333, 0.08333333333333333, 0.5833333333333334), 2), \n\ttermchar(vec3(0.0, 0.0, 0.6666666666666666), vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.25, 0.08333333333333333, 0.5833333333333334), 2), \n\ttermchar(vec3(0.0, 0.0, 0.6666666666666666), vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.08333333333333333, 0.25, 0.5833333333333334), 2), \n\ttermchar(vec3(0.0, 0.0, 0.6666666666666666), vec3(1.0, 1.0, 0.3333333333333333), vec3(0.25, 0.25, 0.5833333333333334), 2), \n\ttermchar(vec3(0.0, 0.0, 0.6666666666666666), vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.08333333333333333, 0.08333333333333333, 0.75), 2), \n\ttermchar(vec3(0.0, 0.0, 0.6666666666666666), vec3(1.0, 0.3333333333333333, 1.0), vec3(0.25, 0.08333333333333333, 0.75), 2), \n\ttermchar(vec3(0.0, 0.0, 0.6666666666666666), vec3(0.3333333333333333, 1.0, 1.0), vec3(0.08333333333333333, 0.25, 0.75), 2), \n\ttermchar(vec3(0.0, 0.0, 0.6666666666666666), vec3(1.0, 1.0, 1.0), vec3(0.25, 0.25, 0.75), 2), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.0, 0.0, 0.0), vec3(0.5, 0.0, 0.5), 2), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.6666666666666666, 0.0, 0.0), vec3(0.6666666666666666, 0.0, 0.5), 2), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.0, 0.6666666666666666, 0.0), vec3(0.5, 0.16666666666666666, 0.5), 2), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.6666666666666666, 0.08333333333333333, 0.5), 2), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.0, 0.0, 0.6666666666666666), vec3(0.5, 0.0, 0.6666666666666666), 2), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.6666666666666666, 0.0, 0.6666666666666666), 2), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.5, 0.16666666666666666, 0.6666666666666666), 2), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.6666666666666666, 0.16666666666666666, 0.6666666666666666), 2), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.5833333333333334, 0.08333333333333333, 0.5833333333333334), 2), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.75, 0.08333333333333333, 0.5833333333333334), 2), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.5833333333333334, 0.25, 0.5833333333333334), 2), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(1.0, 1.0, 0.3333333333333333), vec3(0.75, 0.25, 0.5833333333333334), 2), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.5833333333333334, 0.08333333333333333, 0.75), 2), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(1.0, 0.3333333333333333, 1.0), vec3(0.75, 0.08333333333333333, 0.75), 2), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.3333333333333333, 1.0, 1.0), vec3(0.5833333333333334, 0.25, 0.75), 2), \n\ttermchar(vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(1.0, 1.0, 1.0), vec3(0.75, 0.25, 0.75), 2), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.5, 0.5), 2), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.6666666666666666, 0.0, 0.0), vec3(0.16666666666666666, 0.5, 0.5), 2), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.0, 0.6666666666666666, 0.0), vec3(0.0, 0.6666666666666666, 0.5), 2), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.16666666666666666, 0.5833333333333334, 0.5), 2), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.0, 0.0, 0.6666666666666666), vec3(0.0, 0.5, 0.6666666666666666), 2), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.16666666666666666, 0.5, 0.6666666666666666), 2), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.0, 0.6666666666666666, 0.6666666666666666), 2), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.16666666666666666, 0.6666666666666666, 0.6666666666666666), 2), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.08333333333333333, 0.5833333333333334, 0.5833333333333334), 2), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.25, 0.5833333333333334, 0.5833333333333334), 2), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.08333333333333333, 0.75, 0.5833333333333334), 2), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(1.0, 1.0, 0.3333333333333333), vec3(0.25, 0.75, 0.5833333333333334), 2), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.08333333333333333, 0.5833333333333334, 0.75), 2), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(1.0, 0.3333333333333333, 1.0), vec3(0.25, 0.5833333333333334, 0.75), 2), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.3333333333333333, 1.0, 1.0), vec3(0.08333333333333333, 0.75, 0.75), 2), \n\ttermchar(vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(1.0, 1.0, 1.0), vec3(0.25, 0.75, 0.75), 2), \n\ttermchar(vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.0, 0.0, 0.0), vec3(0.5, 0.5, 0.5), 2), \n\ttermchar(vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.6666666666666666, 0.0, 0.0), vec3(0.6666666666666666, 0.5, 0.5), 2), \n\ttermchar(vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.0, 0.6666666666666666, 0.0), vec3(0.5, 0.6666666666666666, 0.5), 2), \n\ttermchar(vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.6666666666666666, 0.5833333333333334, 0.5), 2), \n\ttermchar(vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.0, 0.0, 0.6666666666666666), vec3(0.5, 0.5, 0.6666666666666666), 2), \n\ttermchar(vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.6666666666666666, 0.5, 0.6666666666666666), 2), \n\ttermchar(vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.5, 0.6666666666666666, 0.6666666666666666), 2), \n\ttermchar(vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), 2), \n\ttermchar(vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.5833333333333334, 0.5833333333333334, 0.5833333333333334), 2), \n\ttermchar(vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.75, 0.5833333333333334, 0.5833333333333334), 2), \n\ttermchar(vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.5833333333333334, 0.75, 0.5833333333333334), 2), \n\ttermchar(vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(1.0, 1.0, 0.3333333333333333), vec3(0.75, 0.75, 0.5833333333333334), 2), \n\ttermchar(vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.5833333333333334, 0.5833333333333334, 0.75), 2), \n\ttermchar(vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(1.0, 0.3333333333333333, 1.0), vec3(0.75, 0.5833333333333334, 0.75), 2), \n\ttermchar(vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.3333333333333333, 1.0, 1.0), vec3(0.5833333333333334, 0.75, 0.75), 2), \n\ttermchar(vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(1.0, 1.0, 1.0), vec3(0.75, 0.75, 0.75), 2), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.0, 0.0, 0.0), vec3(0.25, 0.25, 0.25), 2), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.6666666666666666, 0.0, 0.0), vec3(0.41666666666666663, 0.25, 0.25), 2), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.0, 0.6666666666666666, 0.0), vec3(0.25, 0.41666666666666663, 0.25), 2), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.41666666666666663, 0.3333333333333333, 0.25), 2), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.0, 0.0, 0.6666666666666666), vec3(0.25, 0.25, 0.41666666666666663), 2), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.41666666666666663, 0.25, 0.41666666666666663), 2), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.25, 0.41666666666666663, 0.41666666666666663), 2), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.41666666666666663, 0.41666666666666663, 0.41666666666666663), 2), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), 2), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.5, 0.3333333333333333, 0.3333333333333333), 2), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.3333333333333333, 0.5, 0.3333333333333333), 2), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(1.0, 1.0, 0.3333333333333333), vec3(0.5, 0.5, 0.3333333333333333), 2), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.3333333333333333, 0.3333333333333333, 0.5), 2), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(1.0, 0.3333333333333333, 1.0), vec3(0.5, 0.3333333333333333, 0.5), 2), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.3333333333333333, 1.0, 1.0), vec3(0.3333333333333333, 0.5, 0.5), 2), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(1.0, 1.0, 1.0), vec3(0.5, 0.5, 0.5), 2), \n\ttermchar(vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.0, 0.0, 0.0), vec3(0.75, 0.25, 0.25), 2), \n\ttermchar(vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.6666666666666666, 0.0, 0.0), vec3(0.9166666666666666, 0.25, 0.25), 2), \n\ttermchar(vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.0, 0.6666666666666666, 0.0), vec3(0.75, 0.41666666666666663, 0.25), 2), \n\ttermchar(vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.9166666666666666, 0.3333333333333333, 0.25), 2), \n\ttermchar(vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.0, 0.0, 0.6666666666666666), vec3(0.75, 0.25, 0.41666666666666663), 2), \n\ttermchar(vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.9166666666666666, 0.25, 0.41666666666666663), 2), \n\ttermchar(vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.75, 0.41666666666666663, 0.41666666666666663), 2), \n\ttermchar(vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.9166666666666666, 0.41666666666666663, 0.41666666666666663), 2), \n\ttermchar(vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.8333333333333334, 0.3333333333333333, 0.3333333333333333), 2), \n\ttermchar(vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(1.0, 0.3333333333333333, 0.3333333333333333), 2), \n\ttermchar(vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.8333333333333334, 0.5, 0.3333333333333333), 2), \n\ttermchar(vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(1.0, 1.0, 0.3333333333333333), vec3(1.0, 0.5, 0.3333333333333333), 2), \n\ttermchar(vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.8333333333333334, 0.3333333333333333, 0.5), 2), \n\ttermchar(vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(1.0, 0.3333333333333333, 1.0), vec3(1.0, 0.3333333333333333, 0.5), 2), \n\ttermchar(vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.3333333333333333, 1.0, 1.0), vec3(0.8333333333333334, 0.5, 0.5), 2), \n\ttermchar(vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(1.0, 1.0, 1.0), vec3(1.0, 0.5, 0.5), 2), \n\ttermchar(vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.0, 0.0, 0.0), vec3(0.25, 0.75, 0.25), 2), \n\ttermchar(vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.6666666666666666, 0.0, 0.0), vec3(0.41666666666666663, 0.75, 0.25), 2), \n\ttermchar(vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.0, 0.6666666666666666, 0.0), vec3(0.25, 0.9166666666666666, 0.25), 2), \n\ttermchar(vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.41666666666666663, 0.8333333333333334, 0.25), 2), \n\ttermchar(vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.0, 0.0, 0.6666666666666666), vec3(0.25, 0.75, 0.41666666666666663), 2), \n\ttermchar(vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.41666666666666663, 0.75, 0.41666666666666663), 2), \n\ttermchar(vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.25, 0.9166666666666666, 0.41666666666666663), 2), \n\ttermchar(vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.41666666666666663, 0.9166666666666666, 0.41666666666666663), 2), \n\ttermchar(vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.3333333333333333, 0.8333333333333334, 0.3333333333333333), 2), \n\ttermchar(vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.5, 0.8333333333333334, 0.3333333333333333), 2), \n\ttermchar(vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.3333333333333333, 1.0, 0.3333333333333333), 2), \n\ttermchar(vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(1.0, 1.0, 0.3333333333333333), vec3(0.5, 1.0, 0.3333333333333333), 2), \n\ttermchar(vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.3333333333333333, 0.8333333333333334, 0.5), 2), \n\ttermchar(vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(1.0, 0.3333333333333333, 1.0), vec3(0.5, 0.8333333333333334, 0.5), 2), \n\ttermchar(vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.3333333333333333, 1.0, 1.0), vec3(0.3333333333333333, 1.0, 0.5), 2), \n\ttermchar(vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(1.0, 1.0, 1.0), vec3(0.5, 1.0, 0.5), 2), \n\ttermchar(vec3(1.0, 1.0, 0.3333333333333333), vec3(0.0, 0.0, 0.0), vec3(0.75, 0.75, 0.25), 2), \n\ttermchar(vec3(1.0, 1.0, 0.3333333333333333), vec3(0.6666666666666666, 0.0, 0.0), vec3(0.9166666666666666, 0.75, 0.25), 2), \n\ttermchar(vec3(1.0, 1.0, 0.3333333333333333), vec3(0.0, 0.6666666666666666, 0.0), vec3(0.75, 0.9166666666666666, 0.25), 2), \n\ttermchar(vec3(1.0, 1.0, 0.3333333333333333), vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.9166666666666666, 0.8333333333333334, 0.25), 2), \n\ttermchar(vec3(1.0, 1.0, 0.3333333333333333), vec3(0.0, 0.0, 0.6666666666666666), vec3(0.75, 0.75, 0.41666666666666663), 2), \n\ttermchar(vec3(1.0, 1.0, 0.3333333333333333), vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.9166666666666666, 0.75, 0.41666666666666663), 2), \n\ttermchar(vec3(1.0, 1.0, 0.3333333333333333), vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.75, 0.9166666666666666, 0.41666666666666663), 2), \n\ttermchar(vec3(1.0, 1.0, 0.3333333333333333), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.9166666666666666, 0.9166666666666666, 0.41666666666666663), 2), \n\ttermchar(vec3(1.0, 1.0, 0.3333333333333333), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.8333333333333334, 0.8333333333333334, 0.3333333333333333), 2), \n\ttermchar(vec3(1.0, 1.0, 0.3333333333333333), vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(1.0, 0.8333333333333334, 0.3333333333333333), 2), \n\ttermchar(vec3(1.0, 1.0, 0.3333333333333333), vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.8333333333333334, 1.0, 0.3333333333333333), 2), \n\ttermchar(vec3(1.0, 1.0, 0.3333333333333333), vec3(1.0, 1.0, 0.3333333333333333), vec3(1.0, 1.0, 0.3333333333333333), 2), \n\ttermchar(vec3(1.0, 1.0, 0.3333333333333333), vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.8333333333333334, 0.8333333333333334, 0.5), 2), \n\ttermchar(vec3(1.0, 1.0, 0.3333333333333333), vec3(1.0, 0.3333333333333333, 1.0), vec3(1.0, 0.8333333333333334, 0.5), 2), \n\ttermchar(vec3(1.0, 1.0, 0.3333333333333333), vec3(0.3333333333333333, 1.0, 1.0), vec3(0.8333333333333334, 1.0, 0.5), 2), \n\ttermchar(vec3(1.0, 1.0, 0.3333333333333333), vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, 0.5), 2), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.0, 0.0, 0.0), vec3(0.25, 0.25, 0.75), 2), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.6666666666666666, 0.0, 0.0), vec3(0.41666666666666663, 0.25, 0.75), 2), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.0, 0.6666666666666666, 0.0), vec3(0.25, 0.41666666666666663, 0.75), 2), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.41666666666666663, 0.3333333333333333, 0.75), 2), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.0, 0.0, 0.6666666666666666), vec3(0.25, 0.25, 0.9166666666666666), 2), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.41666666666666663, 0.25, 0.9166666666666666), 2), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.25, 0.41666666666666663, 0.9166666666666666), 2), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.41666666666666663, 0.41666666666666663, 0.9166666666666666), 2), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.3333333333333333, 0.3333333333333333, 0.8333333333333334), 2), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.5, 0.3333333333333333, 0.8333333333333334), 2), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.3333333333333333, 0.5, 0.8333333333333334), 2), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(1.0, 1.0, 0.3333333333333333), vec3(0.5, 0.5, 0.8333333333333334), 2), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.3333333333333333, 0.3333333333333333, 1.0), 2), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(1.0, 0.3333333333333333, 1.0), vec3(0.5, 0.3333333333333333, 1.0), 2), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.3333333333333333, 1.0, 1.0), vec3(0.3333333333333333, 0.5, 1.0), 2), \n\ttermchar(vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(1.0, 1.0, 1.0), vec3(0.5, 0.5, 1.0), 2), \n\ttermchar(vec3(1.0, 0.3333333333333333, 1.0), vec3(0.0, 0.0, 0.0), vec3(0.75, 0.25, 0.75), 2), \n\ttermchar(vec3(1.0, 0.3333333333333333, 1.0), vec3(0.6666666666666666, 0.0, 0.0), vec3(0.9166666666666666, 0.25, 0.75), 2), \n\ttermchar(vec3(1.0, 0.3333333333333333, 1.0), vec3(0.0, 0.6666666666666666, 0.0), vec3(0.75, 0.41666666666666663, 0.75), 2), \n\ttermchar(vec3(1.0, 0.3333333333333333, 1.0), vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.9166666666666666, 0.3333333333333333, 0.75), 2), \n\ttermchar(vec3(1.0, 0.3333333333333333, 1.0), vec3(0.0, 0.0, 0.6666666666666666), vec3(0.75, 0.25, 0.9166666666666666), 2), \n\ttermchar(vec3(1.0, 0.3333333333333333, 1.0), vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.9166666666666666, 0.25, 0.9166666666666666), 2), \n\ttermchar(vec3(1.0, 0.3333333333333333, 1.0), vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.75, 0.41666666666666663, 0.9166666666666666), 2), \n\ttermchar(vec3(1.0, 0.3333333333333333, 1.0), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.9166666666666666, 0.41666666666666663, 0.9166666666666666), 2), \n\ttermchar(vec3(1.0, 0.3333333333333333, 1.0), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.8333333333333334, 0.3333333333333333, 0.8333333333333334), 2), \n\ttermchar(vec3(1.0, 0.3333333333333333, 1.0), vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(1.0, 0.3333333333333333, 0.8333333333333334), 2), \n\ttermchar(vec3(1.0, 0.3333333333333333, 1.0), vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.8333333333333334, 0.5, 0.8333333333333334), 2), \n\ttermchar(vec3(1.0, 0.3333333333333333, 1.0), vec3(1.0, 1.0, 0.3333333333333333), vec3(1.0, 0.5, 0.8333333333333334), 2), \n\ttermchar(vec3(1.0, 0.3333333333333333, 1.0), vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.8333333333333334, 0.3333333333333333, 1.0), 2), \n\ttermchar(vec3(1.0, 0.3333333333333333, 1.0), vec3(1.0, 0.3333333333333333, 1.0), vec3(1.0, 0.3333333333333333, 1.0), 2), \n\ttermchar(vec3(1.0, 0.3333333333333333, 1.0), vec3(0.3333333333333333, 1.0, 1.0), vec3(0.8333333333333334, 0.5, 1.0), 2), \n\ttermchar(vec3(1.0, 0.3333333333333333, 1.0), vec3(1.0, 1.0, 1.0), vec3(1.0, 0.5, 1.0), 2), \n\ttermchar(vec3(0.3333333333333333, 1.0, 1.0), vec3(0.0, 0.0, 0.0), vec3(0.25, 0.75, 0.75), 2), \n\ttermchar(vec3(0.3333333333333333, 1.0, 1.0), vec3(0.6666666666666666, 0.0, 0.0), vec3(0.41666666666666663, 0.75, 0.75), 2), \n\ttermchar(vec3(0.3333333333333333, 1.0, 1.0), vec3(0.0, 0.6666666666666666, 0.0), vec3(0.25, 0.9166666666666666, 0.75), 2), \n\ttermchar(vec3(0.3333333333333333, 1.0, 1.0), vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.41666666666666663, 0.8333333333333334, 0.75), 2), \n\ttermchar(vec3(0.3333333333333333, 1.0, 1.0), vec3(0.0, 0.0, 0.6666666666666666), vec3(0.25, 0.75, 0.9166666666666666), 2), \n\ttermchar(vec3(0.3333333333333333, 1.0, 1.0), vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.41666666666666663, 0.75, 0.9166666666666666), 2), \n\ttermchar(vec3(0.3333333333333333, 1.0, 1.0), vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.25, 0.9166666666666666, 0.9166666666666666), 2), \n\ttermchar(vec3(0.3333333333333333, 1.0, 1.0), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.41666666666666663, 0.9166666666666666, 0.9166666666666666), 2), \n\ttermchar(vec3(0.3333333333333333, 1.0, 1.0), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.3333333333333333, 0.8333333333333334, 0.8333333333333334), 2), \n\ttermchar(vec3(0.3333333333333333, 1.0, 1.0), vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(0.5, 0.8333333333333334, 0.8333333333333334), 2), \n\ttermchar(vec3(0.3333333333333333, 1.0, 1.0), vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.3333333333333333, 1.0, 0.8333333333333334), 2), \n\ttermchar(vec3(0.3333333333333333, 1.0, 1.0), vec3(1.0, 1.0, 0.3333333333333333), vec3(0.5, 1.0, 0.8333333333333334), 2), \n\ttermchar(vec3(0.3333333333333333, 1.0, 1.0), vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.3333333333333333, 0.8333333333333334, 1.0), 2), \n\ttermchar(vec3(0.3333333333333333, 1.0, 1.0), vec3(1.0, 0.3333333333333333, 1.0), vec3(0.5, 0.8333333333333334, 1.0), 2), \n\ttermchar(vec3(0.3333333333333333, 1.0, 1.0), vec3(0.3333333333333333, 1.0, 1.0), vec3(0.3333333333333333, 1.0, 1.0), 2), \n\ttermchar(vec3(0.3333333333333333, 1.0, 1.0), vec3(1.0, 1.0, 1.0), vec3(0.5, 1.0, 1.0), 2), \n\ttermchar(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0), vec3(0.75, 0.75, 0.75), 2), \n\ttermchar(vec3(1.0, 1.0, 1.0), vec3(0.6666666666666666, 0.0, 0.0), vec3(0.9166666666666666, 0.75, 0.75), 2), \n\ttermchar(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.6666666666666666, 0.0), vec3(0.75, 0.9166666666666666, 0.75), 2), \n\ttermchar(vec3(1.0, 1.0, 1.0), vec3(0.6666666666666666, 0.3333333333333333, 0.0), vec3(0.9166666666666666, 0.8333333333333334, 0.75), 2), \n\ttermchar(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.6666666666666666), vec3(0.75, 0.75, 0.9166666666666666), 2), \n\ttermchar(vec3(1.0, 1.0, 1.0), vec3(0.6666666666666666, 0.0, 0.6666666666666666), vec3(0.9166666666666666, 0.75, 0.9166666666666666), 2), \n\ttermchar(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.6666666666666666, 0.6666666666666666), vec3(0.75, 0.9166666666666666, 0.9166666666666666), 2), \n\ttermchar(vec3(1.0, 1.0, 1.0), vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666), vec3(0.9166666666666666, 0.9166666666666666, 0.9166666666666666), 2), \n\ttermchar(vec3(1.0, 1.0, 1.0), vec3(0.3333333333333333, 0.3333333333333333, 0.3333333333333333), vec3(0.8333333333333334, 0.8333333333333334, 0.8333333333333334), 2), \n\ttermchar(vec3(1.0, 1.0, 1.0), vec3(1.0, 0.3333333333333333, 0.3333333333333333), vec3(1.0, 0.8333333333333334, 0.8333333333333334), 2), \n\ttermchar(vec3(1.0, 1.0, 1.0), vec3(0.3333333333333333, 1.0, 0.3333333333333333), vec3(0.8333333333333334, 1.0, 0.8333333333333334), 2), \n\ttermchar(vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, 0.3333333333333333), vec3(1.0, 1.0, 0.8333333333333334), 2), \n\ttermchar(vec3(1.0, 1.0, 1.0), vec3(0.3333333333333333, 0.3333333333333333, 1.0), vec3(0.8333333333333334, 0.8333333333333334, 1.0), 2), \n\ttermchar(vec3(1.0, 1.0, 1.0), vec3(1.0, 0.3333333333333333, 1.0), vec3(1.0, 0.8333333333333334, 1.0), 2), \n\ttermchar(vec3(1.0, 1.0, 1.0), vec3(0.3333333333333333, 1.0, 1.0), vec3(0.8333333333333334, 1.0, 1.0), 2), \n\ttermchar(vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, 1.0), 2)\n);", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mlcczs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 1029, 2289]], "test": "untested"}
{"id": "WdXBzH", "name": "4D Lattice Slice", "author": "mla", "description": "Slicing through a 4-dimensional cubic lattice.", "tags": ["4d", "slice", "lattice"], "likes": 5, "viewed": 382, "published": 3, "date": "1587670647", "time_retrieved": "2024-07-30T21:10:51.740195", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// 4D Lattice Slice\n//\n// Matthew Arcus, mla, 2020\n//\n// Slices through a 4 dimensional cubic lattice.\n// <mouse x>: slice angle\n// <mouse-y>: scale\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.1415927;\n\nmat4 qmat_left(vec4 q) {\n  float x = q.x, y = q.y, z = q.z, t = q.w;\n  return mat4( t, z,-y,-x, \n              -z, t, x,-y,\n               y,-x, t,-z,\n               x, y, z, t );\n}\n\nmat4 qmat_right(vec4 q) {\n  float x = q.x, y = q.y, z = q.z, t = q.w;\n  return mat4( t,-z, y,-x, \n               z, t,-x,-y,\n              -y, x, t,-z,\n               x, y, z, t );\n}\n\nvec4 qmul(vec4 p, vec4 q) {\n  vec3 P = p.xyz, Q = q.xyz;\n  return vec4(p.w*Q+q.w*P+cross(P,Q),p.w*q.w-dot(P,Q));\n}\n\nvec4 qrot(vec4 p, vec4 q, vec4 r) {\n  p = qmul(q,p);\n  p = qmul(p,r);\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  float size = 5.0;\n  float time = 0.1*iTime+0.1;\n  float theta = 0.618*time;\n  if (iMouse.x > 0.0) {\n    size *= exp((2.0*iMouse.y -iResolution.y)/iResolution.y);\n    theta = PI*(2.0*iMouse.x-iResolution.x)/iResolution.x;\n  }\n  uv *= size;\n  float tq = time;\n  float tr = theta;\n  vec4 q = vec4(sin(tq)*vec3(1,0,0),cos(tq));\n  vec4 r = vec4(sin(tr)*vec3(0,1,0),cos(tr));\n  vec4 p = vec4(uv,0,0);\n  mat4 qm = qmat_left(q)*qmat_right(r);\n  float ds = fwidth(p.x);\n  p = qm*p; // qrot(p,q,r);\n  p = mod(p,2.0);\n  vec4 dp = fract(p);\n  dp = min(dp,1.0-dp);\n  p = floor(p);\n  int parity = int(dot(p,vec4(1)))%2;\n\n  mat4x2 dm = transpose(mat2x4(qm));\n  dp /= vec4(length(dm[0]),length(dm[1]),length(dm[2]),length(dm[3]));\n  float d = min(min(dp.x,dp.y),min(dp.z,dp.w));\n  vec3 color = vec3(smoothstep(-ds,+ds,parity==0?d:-d));\n  color = mix(vec3(1,0,0),color,smoothstep(0.01,0.02+ds,d));\n  color = pow(color,vec3(0.4545));\n  fragColor = vec4(color,1);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXBzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[347, 347, 371, 371, 528], [530, 530, 555, 555, 712], [714, 714, 741, 741, 828], [830, 830, 865, 865, 913], [915, 915, 972, 972, 1979]], "test": "untested"}
{"id": "wdXfz8", "name": "QuasiCrystals - Dragon Eye", "author": "mrange", "description": "Found bunch of examples of quasicrystals on shadertoy and combined them with FBM. I liked the result so decided to share it.", "tags": ["2d", "quasicrystals"], "likes": 6, "viewed": 500, "published": 3, "date": "1587667643", "time_retrieved": "2024-07-30T21:10:52.516121", "image_code": "#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define LAYERS      6\n#define FBM         3\n#define LIGHTNING   3\n#define DISTORT     1.4\n#define TIME        iTime\n#define TTIME       (TAU*TIME)\n\nfloat wave(float theta, vec2 p) {\n  return (cos(dot(p,vec2(cos(theta),sin(theta)))));\n}\n\nfloat noise(vec2 p, float time) {\n  float sum = 0.;\n  float a = 1.0;\n  for(int i = 0; i < LAYERS; ++i)  {\n    float theta = float(i)*PI/float(LAYERS);\n    sum += wave(theta, p)*a;\n    a*=DISTORT;\n  }\n\n  return abs(tanh(sum+1.0+0.75*cos(time)));\n}\n\nfloat fbm(vec2 p, float time) {\n  float sum = 0.;\n  float a = 1.0;\n  float f = 1.0;\n  for(int i = 0; i < FBM; ++i)  {\n    sum += a*noise(p*f, time);\n    a *= 2.0/3.0;\n    f *= 2.31;\n  }\n\n  return 0.45*(sum);\n}\n\nvec3 lightning(vec2 pos, float offset) {\n  vec3 col = vec3(0.0);\n  vec2 f = vec2(0);\n         \n  const float w=0.15;\n          \n  for (int i = 0; i < LIGHTNING; i++) {\n    float time = TIME + 0.5*float(i);   \n    float d1 = abs(offset * w / (0.0 + offset - fbm((pos + f) * 3.0, time)));\n    float d2 = abs(offset * w / (0.0 + offset - fbm((pos + f) * 2.0, 0.9 * time + 10.0)));\n    col += vec3(clamp(d1, 0.0, 1.0) * vec3(0.1, 0.5, 0.8));\n    col += vec3(clamp(d2, 0.0, 1.0) * vec3(0.7, 0.5, 0.3));\n  }\n          \n  return (col);\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(p.x*c + p.y*s, -p.x*s + p.y*c);\n}\n\nvec3 normal(vec2 p, float time) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(0.00001, 0);\n  \n  vec3 n;\n  n.x = fbm(p + e.xy, time) - fbm(p - e.xy, time);\n  n.y = 2.0*e.x;\n  n.z = fbm(p + e.yx, time) - fbm(p - e.yx, time);\n  \n  return normalize(n);\n}\n\nvec3 dragonEye(vec2 p) {\n  vec2 pp = 10.0*p;\n\n  rot(p, -0.75); \n  p *= vec2(1.1/tanh(1.0 + length(p)), 1.0);\n  float l = length(p);\n  \n  float dd = 0.2 + 0.65*(-0.5 + 1.75*(0.5 + 0.5*cos(3.0*l-TTIME/12.0)))*tanh(1.0/((pow(l, 4.0) + 2.0)));\n  dd *= smoothstep(9.0, 12.0, TIME-l*2.0);\n  vec3 col = vec3(0.0);\n  float f = fbm(pp, TIME*0.1);\n  vec3 ld = normalize(vec3(p.x, 0.5, p.y));\n  vec3 n = normal(pp, TIME*0.1);\n  float diff = max(dot(ld, n), 0.0);\n  col += vec3(0.5, 1.0, 0.8)*pow(diff, 20.0)/(0.5+dot(p, p));\n  col += lightning(pp, dd);\n  col *= pow(vec3(f), vec3(1.5, 5.0, 5.0));\n//  col += -0.1+0.3*vec3(0.7, 0.2, 0.4)*vec3(tanh((pow(0.6/f, 10))));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord.xy/iResolution.xy;    \n  vec2 p = -1.0 + 2.0*q;\n\n  p.x *= iResolution.x/iResolution.y;    \n  \n  vec3 col = dragonEye(p);\n  \n  col = postProcess(col, q);\n\n  col *= smoothstep(0.0, 4.0, TIME);\n  \n  fragColor = vec4(col, 1.0);  \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXfz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[209, 209, 242, 242, 296], [298, 298, 331, 331, 544], [546, 546, 577, 577, 755], [757, 757, 797, 797, 1287], [1289, 1289, 1325, 1325, 1574], [1576, 1576, 1609, 1609, 1694], [1696, 1696, 1729, 1729, 1938], [1940, 1940, 1964, 1964, 2611], [2613, 2613, 2668, 2668, 2917]], "test": "untested"}
{"id": "wsfBz8", "name": "curvature scalable magnifier", "author": "Lordinator", "description": "based on  Edward Magnifier\n(https://www.shadertoy.com/view/4t2XDK)", "tags": ["magnifier"], "likes": 3, "viewed": 420, "published": 3, "date": "1587666902", "time_retrieved": "2024-07-30T21:10:53.253150", "image_code": "float radio = 1000.0;\nfloat rimSize = 4.0;\nvec2 handView = vec2(10.0,100.0);\t\nfloat scale = 0.4;\t\t\n\nvec2 curvatureGenerator(vec2 toPow,  float dis){\n    float x = dis/radio;\n    return toPow*(1.0-x)*exp(-2.0*x*x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    fragColor = texture(iChannel0, uv).rgba;\n    \n    vec2 center = iMouse.xy;\n    \n    float dis = distance(fragCoord.xy, center);\n    \n    vec2 disV = fragCoord.xy - center;\n    \n    if(dis > radio && dis < radio + rimSize){\n    \tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    } \n    \n    if(abs(disV.x) < (handView.x / 2.0) && abs(disV.y + radio) < ((handView.y))&& dis >= radio + rimSize)\n    {\n    \tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n\n    if(dis < radio){\n        //dis = distance(fragCoord.xy, center + radio*0.5*vec2(cos(iTime),sin(iTime)));\n\n        vec2 trueUV = (fragCoord.xy - (curvatureGenerator(disV,dis) *scale) ) / iResolution.xy;\n    \tfragColor = texture(iChannel0, trueUV).rgba;\n    }\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfBz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 148, 148, 215], [217, 217, 274, 274, 1032]], "test": "untested"}
{"id": "tsXfR8", "name": "Do You Want To Build A Snowman", "author": "42yeah", "description": "First time trying to render an actual raymarching scene. I am still bad at this :(\nDon't look behind the wall. Lots of (lighting) code taken from fruxis: https://www.shadertoy.com/view/ldl3zl , which is awesome, but I am still learning them.", "tags": ["raymarching"], "likes": 5, "viewed": 485, "published": 3, "date": "1587664634", "time_retrieved": "2024-07-30T21:10:53.993171", "image_code": "float smin(float a, float b, float k) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat snowhead(vec3 p, vec3 off) {\n    float body = length(p - off) - 1.0;\n    float head = length(p - vec3(0.0, 1.4, 0.0) - off) - 0.6;\n    return smin(body, head, 0.2);\n}\n\nfloat carrot(vec3 p, vec3 off) {\n    p = p - off;\n    if (length(p) > 1.0) {\n        return 1.0;\n    }\n    float rad = radians(75.0);\n    float q = length(p.xy);\n    return dot(vec2(sin(rad), cos(rad)), vec2(q, p.z));\n}\n\nfloat snoweye(vec3 p, vec3 off) {\n    float left = length(p - vec3(-0.25, 0.0, 0.0) - off) - 0.1;\n    float right = length(p - vec3(0.25, 0.0, 0.0) - off) - 0.1;\n    return min(left, right);\n}\n\nfloat sol(vec3 p) {\n    return p.y;\n}\n\nfloat rect(vec3 p, vec3 b, vec3 off) {\n    vec3 q = abs(p - off) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - 0.1;\n}\n\nfloat window(vec3 p, vec3 off) {\n    return max(rect(p, vec3(2.0, 2.0, 0.1), off),\n        -rect(p, vec3(1.8, 1.7, 1.0), off + vec3(0.0, 0.0, 0.1)));\n}\n\nfloat wall(vec3 p, vec3 windowOff) {\n    if (p.z < -3.0) {\n        return 1.0;\n    }\n    float x = abs(p.x + 3.0) - 0.001;\n    float z = abs(p.z + 3.0) - 0.001;\n    return max(min(x, z),\n        -rect(p, vec3(2.0, 2.0, 1.0), windowOff));\n}\n\nfloat cubic(vec3 p, vec3 off) {\n    float sol = rect(p, vec3(3.0, 0.01, 3.0), off);\n    float plafond = smin(sol, rect(p, vec3(3.0, 0.01, 3.0), off + vec3(0.0, 6.0, 0.0)), 0.1);\n    float wall = smin(plafond, rect(p, vec3(3.0, 6.0, 0.01), off + vec3(0.0, 0.0, -3.0)), 0.1);\n    wall = smin(wall, rect(p, vec3(0.01, 6.0, 3.0), off + vec3(-3.0, 0.0, 0.0)), 0.1);\n    wall = smin(wall, rect(p, vec3(0.01, 6.0, 3.0), off + vec3(3.0, 0.0, 0.0)), 0.1);\n    return wall;\n}\n\nfloat lamp(vec3 p, vec3 off) {\n    return rect(p, vec3(0.5, 0.1, 0.4), off);\n}\n\nvec2 map(vec3 p) {\n    float closest = 1000.0;\n    float id = -1.0;\n    \n    float dist = sol(p);\n    if (dist < closest) { closest = dist; id = 0.5; }\n    \n    dist = snowhead(p, vec3(0.0, 0.5, 0.0));\n    if (dist < closest) { closest = dist; id = 1.5; }\n    \n    dist = snoweye(p, vec3(0.0, 2.2, 0.5));\n    if (dist < closest) { closest = dist; id = 2.5; }\n    \n    dist = carrot(p, vec3(0.0, 1.9, 1.0));\n    if (dist < closest) { closest = dist; id = 3.5; }\n    \n    dist = wall(p, vec3(0.0, 3.8, -4.0));\n    if (dist < closest) { closest = dist; id = 4.5; }\n    \n    dist = window(p, vec3(0.0, 3.8, -3.1));\n    if (dist < closest) { closest = dist; id = 5.5; }\n    \n    dist = cubic(p, vec3(1.0, 0.0, -6.15));\n    if (dist < closest) { closest = dist; id = 6.5; }\n    \n    dist = lamp(p, vec3(1.0, 6.0, -6.15));\n    if (dist < closest) { closest = dist; id = 7.5; }\n    \n    return vec2(closest, id);\n}\n\nvec3 calcNormal(vec3 p) {\n    const float epsilon = 0.001;\n    return normalize(vec3(\n        map(p).x - map(vec3(p.x - epsilon, p.yz)).x,\n        map(p).x - map(vec3(p.x, p.y - epsilon, p.z)).x,\n        map(p).x - map(vec3(p.xy, p.z - epsilon)).x\n    ));\n}\n\nvec2 intersect(vec3 ro, vec3 rd) {\n    vec2 dv = vec2(0.0, -1.0);\n    \n    for (int i = 0; i < 300; i++) {\n        vec2 distId = map(ro + rd * dv.x);\n        if (distId.x <= 0.001) {\n            dv.y = distId.y;\n            break;\n        }\n        dv.x += distId.x;\n    }\n    return dv;\n}\n\nvec3 wallColor(vec3 p) {\n    const vec3 base = vec3(0.8, 0.6, 0.7);\n    vec3 f = fract(p);\n    float clamped = length(clamp(p, 0.0, 1.0));\n    return base * (f.y + 0.4);\n}\n\nvec3 carrotColor(vec3 p) {\n    const vec3 base = vec3(1.5, 0.3, 0.0);\n    vec3 f = fract(p * 10.0);\n    vec3 color = base * (1.0 - pow(f.z, 12.0) * 0.3);\n    return color;\n}\n\nvec3 getColor(vec3 p, float id) {\n    if (id <= -0.5) { return vec3(0.0, 0.0, 0.0); }\n    if (id <= 1.0) { return vec3(1.0, 1.0, 1.0); }\n    if (id <= 2.0) { return vec3(1.0, 1.0, 1.0); }\n    if (id <= 3.0) { return vec3(0.1, 0.1, 0.1); }\n    if (id <= 4.0) { return carrotColor(p); } // carrot\n    if (id <= 5.0) { return wallColor(p); } // wall\n    if (id <= 6.0) { return vec3(0.5, 0.2, 0.1); }\n    if (id <= 7.0) { return vec3(2.2, 2.2, 2.2); }\n    if (id <= 8.0) { return vec3(100.0, 100.0, 100.0); }\n    return vec3(1.0, 0.0, 0.0);\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float k) {\n    float res = 1.0;\n    float depth = 0.0001;\n    vec2 dv = vec2(1.0, -1.0);\n\n    for (int i = 0; i < 50; i++) {\n        dv = map(ro + rd * depth);\n        res = min(res, smoothstep(0.0, 1.0, k * dv.x / depth));\n        if (res < 0.0001) { break; }\n        depth += clamp(dv.x, 0.01, 0.06);\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat directLighting(vec3 p, vec3 n, vec3 lightPos, vec3 lightDir) {\n    vec3 u = normalize(cross(lightDir, vec3(0.0, 1.0, 0.0)));\n    vec3 v = cross(u, lightDir);\n    float shadowIntensity = softShadow(p + 0.001 * n, lightDir, 10.0);\n    \n    vec3 toLight = lightPos - p;\n    float attenuation = smoothstep(0.9, 1.0, dot(normalize(toLight), lightDir));\n    \n    return attenuation * shadowIntensity;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n\n    const float r = 2.0;\n    vec3 ro = vec3(r * (sin(iTime * 0.3) * 0.5 + 0.5) * 0.9 + r, 3.0 * (sin(iTime * 0.5) * 0.1 + 0.9), r * (cos(iTime * 0.3) * 0.5 + 0.5) + r);\n    vec3 center = vec3(0.0, 2.0 + sin(iTime * 0.2) * 0.8 + 0.2, 0.0);\n    vec3 front = normalize(vec3(center - ro));\n    vec3 right = normalize(cross(front, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, front));\n    mat4 lookAt = mat4(\n        vec4(right, 0.0),\n        vec4(up, 0.0),\n        vec4(front, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n    vec3 rd = normalize(vec3(lookAt * vec4(uv, 2.0, 1.0)));\n    \n    vec2 result = intersect(ro, rd);\n    vec3 pos = ro + rd * result.x;\n    vec3 n = calcNormal(pos);\n    \n    vec3 lightPos = vec3(-1.5, 5.5, -4.65);\n    vec3 lightDir = normalize(lightPos);\n    vec3 hal = normalize(lightDir - rd); // WHAT?\n\n    float ambient = 1.0;\n    float diffuse = max(dot(lightDir, n), 0.0);\n    float attenuation = 0.1 + 0.9 * smoothstep(0.9, 1.0, dot(normalize(lightPos - pos), lightDir));\n    float back = max(dot(n, normalize(vec3(-lightDir.x, 0.0, -lightDir.z))), 0.0);\n    float fr = pow(clamp(1.0 + dot(n , rd), 0.0, 1.0), 3.0);\n    float dome = clamp(n.y * 0.8 + 0.2, 0.0, 1.0);\n    float sol = clamp(-n.y * 0.8 + 0.2, 0.0, 0.0) * pow(clamp(1.0 - pos.y, 0.0, 1.0), 2.0);\n    float specular = pow(clamp(dot(n, hal), 0.0, 1.0), 8.0);\n    float shadow = directLighting(pos, n, lightPos, lightDir);\n    \n    vec3 light = vec3(0.0, 0.0, 0.0);\n    light += ambient * vec3(0.03, 0.02, 0.01) * attenuation;\n    light += diffuse * vec3(1.01, 1.0, 1.0) * pow(vec3(shadow), vec3(1.0, 1.0, 1.0)) * attenuation;\n    light += back * vec3(0.42, 0.20, 0.1) * attenuation;\n    light += fr * vec3(3.0, 3.0, 3.0) * attenuation * (0.25 + 0.25 * diffuse);\n    light += dome * vec3(0.15, 0.1, 0.1) * attenuation;\n    light += sol * vec3(0.2, 0.2, 0.2) * attenuation;\n    light += specular * vec3(0.5, 0.5, 0.5) * attenuation;\n    \n    vec3 color = getColor(pos, result.y) * light;\n    color = pow(color, vec3(0.4545));\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXfR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 132], [134, 134, 168, 168, 306], [308, 308, 340, 340, 527], [529, 529, 562, 562, 721], [723, 723, 742, 742, 760], [762, 762, 800, 800, 907], [909, 909, 941, 941, 1060], [1062, 1062, 1098, 1098, 1301], [1303, 1303, 1334, 1334, 1768], [1770, 1770, 1800, 1800, 1848], [1850, 1850, 1868, 1868, 2756], [2758, 2758, 2783, 2783, 3015], [3017, 3017, 3051, 3051, 3306], [3308, 3308, 3332, 3332, 3479], [3481, 3481, 3507, 3507, 3654], [3656, 3656, 3689, 3689, 4195], [4197, 4197, 4242, 4242, 4575], [4577, 4577, 4645, 4645, 4979], [4981, 4981, 5036, 5036, 7229]], "test": "untested"}
{"id": "3dXBzn", "name": "CPPN Random Buffer Texture", "author": "darknoon", "description": "Run a CPPN in real time. In this case, x, y, a radial function, and low-frequency noise are the inputs.\n\nRandom weights and biases are generated in a Buffer A and then read in the Image function.", "tags": ["cppn"], "likes": 4, "viewed": 272, "published": 3, "date": "1587661872", "time_retrieved": "2024-07-30T21:10:54.744164", "image_code": "\n\n// j= sub component, for 8x8 matrix there are 4 sub 4x4 matrices\nmat4 getWeightSubMatrix(int layer, int j) {\n    mat4 m;\n    for (int i=0; i<N_HIDDEN; i++) {\n\t    m[i] = 2.0 * texelFetch(iChannel0, ivec2(layer, j * (N_HIDDEN / 4) + i), 0) - 1.0;\n    }\n\treturn m;\n}\n\n// j= sub component, for 8x1 bias there are 2 sub 4x1 vectors\nvec4 getSubBias(int layer, int j) {\n    vec4 b;\n    b = 2.0 * texelFetch(iChannel0, ivec2(layer, WEIGHTS_END_Y + j), 0) - 1.0;\n\treturn b;\n}\n\nvec4 hash4( vec3 p )\n{\n    vec4 q = vec4( dot(p,vec3(127.1,311.7,256.8)), \n\t\t\t\t   dot(p,vec3(269.5,183.3,012.5)), \n\t\t\t\t   dot(p,vec3(419.2,371.9,167.1)),\n                   dot(p,vec3(269.5,183.3,918.1))\n                 );\n\treturn fract(sin(q)*43758.5453);\n}\n\nvec4 noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\t\n\tvec4 color = vec4(0.0);\n\tfloat wt = 0.0;\n    // Sum contributions from neighboring pixels\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = vec2(float(i), float(j));\n\t\tvec4 value = hash4( vec3(p + g, 0.0) );\n\t\tvec2 r = g - f;\n\t\tfloat d = dot(r,r);\n\t\tfloat ww = 1.0-smoothstep(0.0,1.414,sqrt(d));\n\t\tcolor += value*ww;\n\t\twt += ww;\n    }\n    //return color;\n\t// Normalize weight\n    return 2.0*color/wt -1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2. * uv - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 fr = fract(uv * 8.);\n\n    // Input features\n    vec4 v0 = 0.3*vec4(\n        uv.x,\n        uv.y,\n        2.0 - 4.*length(uv + vec2(0.0, 0.0)),\n        sin(3.14159*uv.x)\n    );\n    float scale = 3.;\n    vec4 v1 = 1.0*noise(scale * uv + vec2(1.0*iTime, 0.0));\n    \n    // Weight and bias factors\n    float k_w = 1.8;\n    float k_b = 0.45;\n    for (int layer=0; layer<N_LAYERS; layer++) {\n        \n        vec4 v00 = getWeightSubMatrix(layer, 0) * v0;\n        vec4 v11 = getWeightSubMatrix(layer, 1) * v1;\n        vec4 v10 = getWeightSubMatrix(layer, 2) * v0;\n        vec4 v01 = getWeightSubMatrix(layer, 3) * v1;\n        \n        v0 = k_w * (v00 + v01) + k_b * getSubBias(layer, 0);\n        v1 = k_w * (v10 + v11) + k_b * getSubBias(layer, 1);\n        \n        if (layer == N_LAYERS - 1) {\n            v0 *= 0.5;\n            v1 *= 0.5;\n        }\n\n        // Apply activation\n        v0 = tanh(v0);\n        v1 = tanh(v1);\n    }\n    \n    fragColor.rgb = 0.5 + 0.5 * (v0 + v1).rgb;\n    \n    // Debug visualization\n    if (fragCoord.x <= float(DATA_WIDTH) * DEBUG_SCALE && fragCoord.y <= float(DATA_HEIGHT) * DEBUG_SCALE) {\n\t    fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy / DEBUG_SCALE);\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\nBuffer A is responsible for generating a number of random weight matrices and bias vectors.\n\nThey are stored packed in the 4 channels of this output texture.\nSince only some pixels are used, discard on other pixels (may not be any more efficient tho)\n*/\n\n// Standard shader RNG\nvec4 hash4( vec3 p )\n{\n    vec4 q = vec4( dot(p,vec3(127.1,311.7,256.8)), \n\t\t\t\t   dot(p,vec3(269.5,183.3,012.5)), \n\t\t\t\t   dot(p,vec3(419.2,371.9,167.1)),\n                   dot(p,vec3(269.5,183.3,918.1))\n                 );\n\treturn fract(sin(q)*43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool weight = int(fragCoord.x) < DATA_WIDTH && int(fragCoord.y) < WEIGHTS_END_Y;\n    bool bias = int(fragCoord.x) < DATA_WIDTH \n        && int(fragCoord.y) >= BIAS_START_Y\n        && int(fragCoord.y) < BIAS_END_Y;\n\n    // This pixel is unused\n    if (!weight && !bias) {\n        fragColor = vec4(0.0);\n        discard;\n    }\n    \n    // Interpolate between each weight breakpoint here\n    float t = iTime * 0.25;\n    vec4 a = hash4(vec3(fragCoord, floor(t)));\n    vec4 b = hash4(vec3(fragCoord, ceil(t)));\n    float k = fract(t);\n    fragColor = mix(a, b, smoothstep(0.0, 1.0, k));\n}", "buffer_a_inputs": [], "common_code": "#define N_HIDDEN 8\n#define N_LAYERS 10\n\n#define DATA_WIDTH N_LAYERS\n#define BIAS_HEIGHT (N_HIDDEN / 4)\n#define WEIGHTS_START_Y 0\n#define WEIGHTS_END_Y (N_HIDDEN * N_HIDDEN / 4)\n#define BIAS_START_Y (WEIGHTS_END_Y + 1)\n#define BIAS_END_Y (BIAS_START_Y + N_HIDDEN / 4)\n\n#define DATA_HEIGHT BIAS_END_Y\n\n#define DEBUG_SCALE 4.\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXBzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 67, 110, 110, 266], [268, 330, 365, 365, 469], [471, 471, 493, 493, 730], [732, 732, 757, 757, 1249], [1251, 1251, 1308, 1358, 2685]], "test": "untested"}
{"id": "tsScDG", "name": "Volumetric Raymarching Sample", "author": "suyoku", "description": "Simple-ish volume raymeracher. Use the mouse to move the camera around.\n\nSet PERFORMANCE_MODE 1 if you want to run this on slower hardware (laptop or phone)", "tags": ["volume"], "likes": 156, "viewed": 9714, "published": 3, "date": "1587658223", "time_retrieved": "2024-07-30T21:10:55.659715", "image_code": "// Created by Christopher Wallis\n#define PI 3.14\n\n#define NUM_LIGHTS 3\n#define NUM_LIGHT_COLORS 3\n\n#define CHECKER_FLOOR_MATERIAL_ID 0\n#define LIGHT_BASE_MATERIAL_ID 1\n#define NUM_MATERIALS (LIGHT_BASE_MATERIAL_ID + NUM_LIGHTS)\n\n#define PERFORMANCE_MODE 0\n\n#define INVALID_MATERIAL_ID int(-1)\n#define LARGE_NUMBER 1e20\n#define EPSILON 0.0001\n#define MAX_SDF_SPHERE_STEPS 15\n#define ABSORPTION_COEFFICIENT 0.5\n#define CAST_VOLUME_SHADOW_ON_OPAQUES 1\n\n#if PERFORMANCE_MODE\n#define MAX_VOLUME_MARCH_STEPS 20\n#define MAX_VOLUME_LIGHT_MARCH_STEPS 4\n#define ABSORPTION_CUTOFF 0.25\n#define MARCH_MULTIPLIER 1.8\n#define LIGHT_ATTENUATION_FACTOR 2.0\n#define MAX_OPAQUE_SHADOW_MARCH_STEPS 10\n#else\n#define MAX_VOLUME_MARCH_STEPS 50\n#define MAX_VOLUME_LIGHT_MARCH_STEPS 25\n#define ABSORPTION_CUTOFF 0.01\n#define MARCH_MULTIPLIER 1.0\n#define LIGHT_ATTENUATION_FACTOR 1.65\n#define MAX_OPAQUE_SHADOW_MARCH_STEPS 25\n#endif\n\n#define UNIFORM_FOG_DENSITY 0\n#define UNIFORM_LIGHT_SPEED 1\n\nstruct CameraDescription\n{\n    vec3 Position;\n    vec3 LookAt;    \n\n    float LensHeight;\n    float FocalDistance;\n};\n    \nstruct OrbLightDescription\n{\n    vec3 Position;\n    float Radius;\n    vec3 LightColor;\n};\n    \nCameraDescription Camera = CameraDescription(\n    vec3(0, 70, -165),\n    vec3(0, 5, 0),\n    2.0,\n    7.0\n);\n\nvec3 GetLightColor(int lightIndex)\n{\n    switch(lightIndex % NUM_LIGHT_COLORS)\n    {\n        case 0: return vec3(1, 0.0, 1.0);\n        case 1: return vec3(0, 1.0, 0.0);\n    }\n    return vec3(0, 0.0, 1.0);\n}\n\nOrbLightDescription GetLight(int lightIndex)\n{\n    const float lightMultiplier = 17.0f;\n#if UNIFORM_LIGHT_SPEED\n    float theta = iTime * 0.7 + float(lightIndex) * PI * 2.0 / float(NUM_LIGHT_COLORS);\n    float radius = 18.5f;\n#else\n    float theta = iTime * 0.4 * (float(lightIndex) + 1.0f);\n    float radius = 19.0f + float(lightIndex) * 2.0;\n#endif\n    \n    OrbLightDescription orbLight;\n    orbLight.Position = vec3(radius * cos(theta), 6.0 + sin(theta * 2.0) * 2.5, radius * sin(theta));\n    orbLight.LightColor = GetLightColor(lightIndex) * lightMultiplier;\n    orbLight.Radius = 0.8f;\n\n    return orbLight;\n}\n\nfloat GetLightAttenuation(float distanceToLight)\n{\n    return 1.0 / pow(distanceToLight, LIGHT_ATTENUATION_FACTOR);\n}\n    \n// --------------------------------------------//\n//               Noise Functions\n// --------------------------------------------//\n// Taken from Inigo Quilez's Rainforest ShaderToy:\n// https://www.shadertoy.com/view/4ttSWf\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\n// Taken from Inigo Quilez's Rainforest ShaderToy:\n// https://www.shadertoy.com/view/4ttSWf\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n}\n\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\n\n// Taken from Inigo Quilez's Rainforest ShaderToy:\n// https://www.shadertoy.com/view/4ttSWf\nfloat fbm_4( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=min(0, iFrame); i<4; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m3*x;\n    }\n\treturn a;\n}\n\n// Taken from https://iquilezles.org/articles/distfunctions\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n// Taken from https://iquilezles.org/articles/distfunctions\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n// Taken from https://iquilezles.org/articles/distfunctions\nfloat sdSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvec3 Translate(vec3 pos, vec3 translate)\n{\n    return pos -= translate;\n}\n\n// Taken from https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, vec3 origin, float s )\n{\n  p = Translate(p, origin);\n  return length(p)-s;\n}\n\n#define MATERIAL_IS_LIGHT_SOURCE 0x1\nstruct Material\n{\n    vec3 albedo;\n    int flags;\n};\n    \nMaterial NormalMaterial(vec3 albedo, int flags)\n{\n    return Material(albedo, flags);\n}\n\nbool IsLightSource(in Material m)\n{\n    return (m.flags & MATERIAL_IS_LIGHT_SOURCE) != 0;\n}\n\nMaterial GetMaterial(int materialID, vec3 position)\n{\n    Material materials[NUM_MATERIALS];\n\tmaterials[CHECKER_FLOOR_MATERIAL_ID] = NormalMaterial(vec3(0.6, 0.6, 0.7), 0);\n    for(int lightIndex = 0; lightIndex < NUM_LIGHTS; lightIndex++)\n    {\n        materials[LIGHT_BASE_MATERIAL_ID + lightIndex] = NormalMaterial(GetLight(lightIndex).LightColor, MATERIAL_IS_LIGHT_SOURCE);\n    }\n    \n    Material mat;\n    if(materialID < int(NUM_MATERIALS))\n    {\n        mat = materials[materialID];\n    }\n    else\n    {\n        // Should never get hit\n   \t\treturn materials[0];\n    }\n    \n    if(materialID == CHECKER_FLOOR_MATERIAL_ID)\n    {\n        vec2 uv = position.xz / 13.0;\n        uv = vec2(uv.x < 0.0 ? abs(uv.x) + 1.0 : uv.x, uv.y < 0.0 ? abs(uv.y) + 1.0 : uv.y);\n        if((int(uv.x) % 2 == 0 && int(uv.y) % 2 == 0) || (int(uv.x) % 2 == 1 && int(uv.y) % 2 == 1))\n        {\n            mat.albedo = vec3(1, 1, 1) * 0.7;\n        }\n    }\n\n    return mat;    \n}\n\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-plane-and-ray-disk-intersection\nfloat PlaneIntersection(vec3 rayOrigin, vec3 rayDirection, vec3 planeOrigin, vec3 planeNormal, out vec3 normal) \n{ \n    float t = -1.0f;\n    normal = planeNormal;\n    float denom = dot(-planeNormal, rayDirection); \n    if (denom > EPSILON) { \n        vec3 rayToPlane = planeOrigin - rayOrigin; \n        return dot(rayToPlane, -planeNormal) / denom; \n    } \n \n    return t; \n} \n    \nfloat SphereIntersection(\n    in vec3 rayOrigin, \n    in vec3 rayDirection, \n    in vec3 sphereCenter, \n    in float sphereRadius, \n    out vec3 normal)\n{\n      vec3 eMinusC = rayOrigin - sphereCenter;\n      float dDotD = dot(rayDirection, rayDirection);\n\n      float discriminant = dot(rayDirection, (eMinusC)) * dot(rayDirection, (eMinusC))\n         - dDotD * (dot(eMinusC, eMinusC) - sphereRadius * sphereRadius);\n\n      if (discriminant < 0.0) \n         return -1.0;\n\n      float firstIntersect = (dot(-rayDirection, eMinusC) - sqrt(discriminant))\n             / dDotD;\n      \n      float t = firstIntersect;\n    \n      normal = normalize(rayOrigin + rayDirection * t - sphereCenter);\n      return t;\n}\n\n\nvoid UpdateIfIntersected(\n    inout float t,\n    in float intersectionT, \n    in vec3 intersectionNormal,\n    in int intersectionMaterialID,\n    out vec3 normal,\n    out int materialID\n\t)\n{    \n    if(intersectionT > EPSILON && intersectionT < t)\n    {\n\t\tnormal = intersectionNormal;\n        materialID = intersectionMaterialID;\n        t = intersectionT;\n    }\n}\n\nfloat IntersectOpaqueScene(in vec3 rayOrigin, in vec3 rayDirection, out int materialID, out vec3 normal)\n{\n    float intersectionT = LARGE_NUMBER;\n    vec3 intersectionNormal = vec3(0, 0, 0);\n\n    float t = LARGE_NUMBER;\n    normal = vec3(0, 0, 0);\n    materialID = INVALID_MATERIAL_ID;\n\n    for(int lightIndex = 0; lightIndex < NUM_LIGHTS; lightIndex++)\n    {\n        UpdateIfIntersected(\n            t,\n            SphereIntersection(rayOrigin, rayDirection, GetLight(lightIndex).Position, GetLight(lightIndex).Radius, intersectionNormal),\n            intersectionNormal,\n            LIGHT_BASE_MATERIAL_ID + lightIndex,\n            normal,\n            materialID);\n    }\n\n    \n    UpdateIfIntersected(\n        t,\n        PlaneIntersection(rayOrigin, rayDirection, vec3(0, 0, 0), vec3(0, 1, 0), intersectionNormal),\n        intersectionNormal,\n        CHECKER_FLOOR_MATERIAL_ID,\n        normal,\n        materialID);\n\n    \n    return t;\n}\n\nfloat QueryVolumetricDistanceField( in vec3 pos)\n{    \n    // Fuse a bunch of spheres, slap on some fbm noise, \n    // merge it with ground plane to get some ground fog \n    // and viola! Big cloudy thingy!\n    vec3 fbmCoord = (pos + 2.0 * vec3(iTime, 0.0, iTime)) / 1.5f;\n    float sdfValue = sdSphere(pos, vec3(-8.0, 2.0 + 20.0 * sin(iTime), -1), 5.6);\n    sdfValue = sdSmoothUnion(sdfValue,sdSphere(pos, vec3(8.0, 8.0 + 12.0 * cos(iTime), 3), 5.6), 3.0f);\n    sdfValue = sdSmoothUnion(sdfValue, sdSphere(pos, vec3(5.0 * sin(iTime), 3.0, 0), 8.0), 3.0) + 7.0 * fbm_4(fbmCoord / 3.2);\n    sdfValue = sdSmoothUnion(sdfValue, sdPlane(pos + vec3(0, 0.4, 0)), 22.0);\n    return sdfValue;\n}\n\nfloat IntersectVolumetric(in vec3 rayOrigin, in vec3 rayDirection, float maxT)\n{\n    // Precision isn't super important, just want a decent starting point before \n    // ray marching with fixed steps\n\tfloat precis = 0.5; \n    float t = 0.0f;\n    for(int i=0; i<MAX_SDF_SPHERE_STEPS; i++ )\n    {\n\t    float result = QueryVolumetricDistanceField( rayOrigin+rayDirection*t);\n        if( result < (precis) || t>maxT ) break;\n        t += result;\n    }\n    return ( t>=maxT ) ? -1.0 : t;\n}\n\nvec3 Diffuse(in vec3 normal, in vec3 lightVec, in vec3 diffuse)\n{\n    float nDotL = dot(normal, lightVec);\n    return clamp(nDotL * diffuse, 0.0, 1.0);\n}\n\nvec3 GetAmbientLight()\n{\n\treturn 1.2 * vec3(0.03, 0.018, 0.018);\n}\n\nfloat GetFogDensity(vec3 position, float sdfDistance)\n{\n    const float maxSDFMultiplier = 1.0;\n    bool insideSDF = sdfDistance < 0.0;\n    float sdfMultiplier = insideSDF ? min(abs(sdfDistance), maxSDFMultiplier) : 0.0;\n \n#if UNIFORM_FOG_DENSITY\n    return sdfMultiplier;\n#else\n   return sdfMultiplier * abs(fbm_4(position / 6.0) + 0.5);\n#endif\n}\n\nfloat BeerLambert(float absorption, float dist)\n{\n    return exp(-absorption * dist);\n}\n\nfloat GetLightVisiblity(in vec3 rayOrigin, in vec3 rayDirection, in float maxT, in int maxSteps, in float marchSize)\n{\n    float t = 0.0f;\n    float lightVisibility = 1.0f;\n    float signedDistance = 0.0;\n    for(int i = 0; i < maxSteps; i++)\n    {                       \n        t += max(marchSize, signedDistance);\n        if(t > maxT || lightVisibility < ABSORPTION_CUTOFF) break;\n\n        vec3 position = rayOrigin + t*rayDirection;\n\n        signedDistance = QueryVolumetricDistanceField(position);\n        if(signedDistance < 0.0)\n        {\n            lightVisibility *= BeerLambert(ABSORPTION_COEFFICIENT * GetFogDensity(position, signedDistance), marchSize);\n        }\n    }\n    return lightVisibility;\n}\n\n\nfloat Luminance(vec3 color)\n{\n    return (color.r * 0.3) + (color.g * 0.59) + (color.b * 0.11);\n}\n\nbool IsColorInsignificant(vec3 color)\n{\n    const float minValue = 0.009;\n    return Luminance(color) < minValue;\n}\n\nvoid CalculateLighting(vec3 position, vec3 normal, vec3 reflectionDirection, Material material, inout vec3 color)\n{\n    for(int lightIndex = 0; lightIndex < NUM_LIGHTS; lightIndex++)\n    {\n        vec3 lightDirection = (GetLight(lightIndex).Position - position);\n        float lightDistance = length(lightDirection);\n        lightDirection /= lightDistance;\n\n        vec3 lightColor = GetLight(lightIndex).LightColor * GetLightAttenuation(lightDistance); \n\n        float lightVisiblity = 1.0;\n        #if CAST_VOLUME_SHADOW_ON_OPAQUES\n        if(!IsColorInsignificant(lightColor))\n        {\n            const float shadowMarchSize = 0.65f * MARCH_MULTIPLIER;\n            lightVisiblity = GetLightVisiblity(position, lightDirection, lightDistance, MAX_OPAQUE_SHADOW_MARCH_STEPS, shadowMarchSize); \n        }\n        #endif\n        \n        color += lightVisiblity * lightColor * pow(max(dot(reflectionDirection, lightDirection), 0.0), 4.0);\n        color += lightVisiblity * lightColor * Diffuse(normal, lightDirection, material.albedo);\n    \n    }\n    color += GetAmbientLight() * material.albedo;\n}\n\nvec3 Render( in vec3 rayOrigin, in vec3 rayDirection)\n{\n    float depth = LARGE_NUMBER;\n    vec3 opaqueColor = vec3(0.0f);\n    \n    vec3 normal;\n    float t;\n    int materialID = INVALID_MATERIAL_ID;\n    t = IntersectOpaqueScene(rayOrigin, rayDirection, materialID, normal);\n    if( materialID != INVALID_MATERIAL_ID )\n    {\n        // Defer lighting calculations after volume lighting so we can \n        // avoid doing shadow tracing on opaque objects that aren't visible anyways\n        depth = t;\n    }\n    \n    float volumeDepth = IntersectVolumetric(rayOrigin, rayDirection, depth);\n    float opaqueVisiblity = 1.0f;\n    vec3 volumetricColor = vec3(0.0f);\n    if(volumeDepth > 0.0)\n    {\n        const vec3 volumeAlbedo = vec3(0.8);\n        const float marchSize = 0.6f * MARCH_MULTIPLIER;\n        float distanceInVolume = 0.0f;\n        float signedDistance = 0.0;\n        for(int i = 0; i < MAX_VOLUME_MARCH_STEPS; i++)\n        {\n            volumeDepth += max(marchSize, signedDistance);\n            if(volumeDepth > depth || opaqueVisiblity < ABSORPTION_CUTOFF) break;\n            \n            vec3 position = rayOrigin + volumeDepth*rayDirection;\n\n            signedDistance = QueryVolumetricDistanceField(position);\n\t\t\tif(signedDistance < 0.0f)\n            {\n                distanceInVolume += marchSize;\n                float previousOpaqueVisiblity = opaqueVisiblity;\n                opaqueVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT * GetFogDensity(position, signedDistance), marchSize);\n                float absorptionFromMarch = previousOpaqueVisiblity - opaqueVisiblity;\n                \n                for(int lightIndex = 0; lightIndex < NUM_LIGHTS; lightIndex++)\n    \t\t\t{\n                    float lightVolumeDepth = 0.0f;\n                    vec3 lightDirection = (GetLight(lightIndex).Position - position);\n                    float lightDistance = length(lightDirection);\n                    lightDirection /= lightDistance;\n                    \n                    vec3 lightColor = GetLight(lightIndex).LightColor * GetLightAttenuation(lightDistance); \n                    if(IsColorInsignificant(lightColor)) continue;\n                    \n                    const float lightMarchSize = 0.65f * MARCH_MULTIPLIER;\n                    float lightVisiblity = GetLightVisiblity(position, lightDirection, lightDistance, MAX_VOLUME_LIGHT_MARCH_STEPS, lightMarchSize); \n                    volumetricColor += absorptionFromMarch * lightVisiblity * volumeAlbedo * lightColor;\n                }\n                volumetricColor += absorptionFromMarch * volumeAlbedo * GetAmbientLight();\n            }\n        }\n    }\n    \n    if( materialID != INVALID_MATERIAL_ID && opaqueVisiblity > ABSORPTION_CUTOFF)\n    {\n        vec3 position = rayOrigin + t*rayDirection;\n        Material material = GetMaterial(materialID, position);\n\t\tif(IsLightSource(material))\n        {\n            opaqueColor = min(material.albedo, vec3(1.0));\n        }       \n        else\n        {\n    \t    vec3 reflectionDirection = reflect( rayDirection, normal);\n\t        CalculateLighting(position, normal, reflectionDirection, material, opaqueColor);\n        }\n    }\n    \n    return min(volumetricColor, 1.0f) + opaqueVisiblity * opaqueColor;\n}\n\nmat3 GetViewMatrix(float xRotationFactor)\n{ \n   float xRotation = ((1.0 - xRotationFactor) - 0.5) * PI * 0.4 + PI * 0.25;\n   return mat3( cos(xRotation), 0.0, sin(xRotation),\n                0.0,           1.0, 0.0,    \n                -sin(xRotation),0.0, cos(xRotation));\n}\n\nfloat GetCameraPositionYOffset()\n{\n    return 100.0 * (iMouse.y / iResolution.y);\n}\n\nfloat GetRotationFactor()\n{\n    return iMouse.x / iResolution.x;\n}\n\nvec3 GammaCorrect(vec3 color) \n{\n    return pow(color, vec3(1.0/2.2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float aspectRatio = iResolution.x /  iResolution.y; \n    float lensWidth = Camera.LensHeight * aspectRatio;\n    \n    vec3 CameraPosition = Camera.Position + GetCameraPositionYOffset();\n    \n    vec3 NonNormalizedCameraView = Camera.LookAt - CameraPosition;\n    float ViewLength = length(NonNormalizedCameraView);\n    vec3 CameraView = NonNormalizedCameraView / ViewLength;\n\n    vec3 lensPoint = CameraPosition;\n    \n    // Pivot the camera around the look at point\n    {\n        float rotationFactor = GetRotationFactor();\n        mat3 viewMatrix = GetViewMatrix(rotationFactor);\n        CameraView = CameraView * viewMatrix;\n        lensPoint = Camera.LookAt - CameraView * ViewLength;\n    }\n    \n    // Technically this could be calculated offline but I like \n    // being able to iterate quickly\n    vec3 CameraRight = cross(CameraView, vec3(0, 1, 0));    \n    vec3 CameraUp = cross(CameraRight, CameraView);\n\n    vec3 focalPoint = lensPoint - Camera.FocalDistance * CameraView;\n    lensPoint += CameraRight * (uv.x * 2.0 - 1.0) * lensWidth / 2.0;\n    lensPoint += CameraUp * (uv.y * 2.0 - 1.0) * Camera.LensHeight / 2.0;\n    \n    vec3 rayOrigin = focalPoint;\n    vec3 rayDirection = normalize(lensPoint - focalPoint);\n    \n    vec3 color = Render(rayOrigin, rayDirection);\n    fragColor=vec4( GammaCorrect(clamp(color, 0.0, 1.0)), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsScDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1297, 1297, 1333, 1333, 1503], [2121, 2121, 2171, 2171, 2238], [2244, 2469, 2493, 2493, 2544], [2546, 2638, 2664, 2664, 3392], [3526, 3618, 3644, 3644, 3869], [3871, 3931, 3956, 3956, 3971], [3973, 4033, 4063, 4063, 4096], [4098, 4158, 4211, 4211, 4311], [4313, 4313, 4355, 4355, 4386], [4388, 4448, 4496, 4496, 4548], [4645, 4645, 4694, 4694, 4732], [4734, 4734, 4769, 4769, 4825], [5789, 5928, 6042, 6042, 6303], [6310, 6310, 6464, 6464, 7016], [7019, 7019, 7208, 7208, 7382], [7384, 7384, 7490, 7490, 8323], [8325, 8325, 8375, 8531, 9011], [9013, 9013, 9093, 9212, 9497], [9499, 9499, 9564, 9564, 9652], [9654, 9654, 9678, 9678, 9720], [9722, 9722, 9777, 9777, 10069], [10071, 10071, 10120, 10120, 10158], [10160, 10160, 10278, 10278, 10872], [10875, 10875, 10904, 10904, 10972], [10974, 10974, 11013, 11013, 11089], [11091, 11091, 11206, 11206, 12190], [12192, 12192, 12247, 12247, 15431], [15433, 15433, 15476, 15476, 15708], [15710, 15710, 15744, 15744, 15793], [15795, 15795, 15822, 15822, 15861], [15863, 15863, 15895, 15895, 15935], [15937, 15937, 15994, 15994, 17392]], "test": "untested"}
{"id": "WdfBzH", "name": "bubler with backdrop", "author": "run", "description": "bubler with backdrop", "tags": ["bubler", "backdrop"], "likes": 2, "viewed": 303, "published": 3, "date": "1587657686", "time_retrieved": "2024-07-30T21:10:56.681982", "image_code": "//-----------------------------------------------------------------------------\n// Simple test/port of Mercury's SDF GLSL library: http://mercury.sexy/hg_sdf/\n// by Tom '2015\n// Disclaimer:\n//   The library is done by Mercury team for OpenGL 4+ (look below),\n//   not me, and this is just an unofficial port.\n//-----------------------------------------------------------------------------\n\n////////////////////////////////////////////////////////////////\n//\n//                           HG_SDF\n//\n//     GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n//\n//     version 2015-12-15 (initial release)\n//\n//     Check http://mercury.sexy/hg_sdf for updates\n//     and usage examples. Send feedback to spheretracing@mercury.sexy.\n//\n//     Brought to you by MERCURY http://mercury.sexy\n//\n//\n//\n// Released as Creative Commons Attribution-NonCommercial (CC BY-NC)\n//\n////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////\n//\n//             HELPER FUNCTIONS/MACROS\n//\n////////////////////////////////////////////////////////////////\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n     // PHI (sqrt(5)*0.5 + 0.5)\n\n// Clamp to [0,1] - this operation is free under certain circumstances.\n// For further information see\n// http://www.humus.name/Articles/Persson_LowLevelThinking.pdf and\n// http://www.humus.name/Articles/Persson_LowlevelShaderOptimization.pdf\n#define saturate(x) clamp(x, 0., 1.)\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nfloat square (float x) {\n\treturn x*x;\n}\n\nvec2 square (vec2 x) {\n\treturn x*x;\n}\n\nvec3 square (vec3 x) {\n\treturn x*x;\n}\n\nfloat lengthSqr(vec3 x) {\n\treturn dot(x, x);\n}\n\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec4 v) {\n\treturn min(min(v.x, v.y), min(v.z, v.w));\n}\n\n\n\n\n////////////////////////////////////////////////////////////////\n//\n//             PRIMITIVE DISTANCE FUNCTIONS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that is a distance function is called fSomething.\n// The first argument is always a point in 2 or 3-space called <p>.\n// Unless otherwise noted, (if the object has an intrinsic \"up\"\n// side or direction) the y axis is \"up\" and the object is\n// centered at the origin.\n//\n////////////////////////////////////////////////////////////////\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n// Cheap Box: distance to corners is overestimated\nfloat fBoxCheap(vec3 p, vec3 b) { //cheap box\n\treturn vmax(abs(p) - b);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Same as above, but in two dimensions (an endless box)\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\n\n// Endless \"corner\"\nfloat fCorner (vec2 p) {\n\treturn length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\n// Blobby ball object. You've probably seen it somewhere. This is not a correct distance bound, beware.\nfloat fBlob(vec3 p) {\n\tp = abs(p);\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tfloat b = max(max(max(\n\t\tdot(p, normalize(vec3(1, 1, 1))),\n\t\tdot(p.xz, normalize(vec2(PHI+1., 1)))),\n\t\tdot(p.yx, normalize(vec2(1, PHI)))),\n\t\tdot(p.xz, normalize(vec2(1, PHI))));\n\tfloat l = length(p);\n\treturn l - 1.5 - 0.2 * (1.5 / 2.)* cos(min(sqrt(1.01 - b / l)*(PI / 0.25), PI));\n}\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n// Capsule: A Cylinder with round caps on both sides\nfloat fCapsule(vec3 p, float r, float c) {\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b - a;\n\tfloat t = saturate(dot(p - a, ab) / dot(ab, ab));\n\treturn length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n// A circle line. Can also be used to make a torus by subtracting the smaller radius of the torus.\nfloat fCircle(vec3 p, float r) {\n\tfloat l = length(p.xz) - r;\n\treturn length(vec2(p.y, l));\n}\n\n// A circular disc with no thickness (i.e. a cylinder with no height).\n// Subtract some value to make a flat disc with rounded edge.\nfloat fDisc(vec3 p, float r) {\n float l = length(p.xz) - r;\n\treturn l < 0. ? abs(p.y) : length(vec2(p.y, l));\n}\n\n// Hexagonal prism, circumcircle variant\nfloat fHexagonCircumcircle(vec3 p, vec2 h) {\n\tvec3 q = abs(p);\n\treturn max(q.y - h.y, max(q.x*sqrt(3.)*0.5 + q.z*0.5, q.z) - h.x);\n\t//this is mathematically equivalent to this line, but less efficient:\n\t//return max(q.y - h.y, max(dot(vec2(cos(PI/3), sin(PI/3)), q.zx), q.z) - h.x);\n}\n\n// Hexagonal prism, incircle variant\nfloat fHexagonIncircle(vec3 p, vec2 h) {\n\treturn fHexagonCircumcircle(p, vec2(h.x*sqrt(3.)*0.5, h.y));\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n//\n// \"Generalized Distance Functions\" by Akleman and Chen.\n// see the Paper at https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n//\n// This set of constants is used to construct a large variety of geometric primitives.\n// Indices are shifted by 1 compared to the paper because we start counting at Zero.\n// Some of those are slow whenever a driver decides to not unroll the loop,\n// which seems to happen for fIcosahedron und fTruncatedIcosahedron on nvidia 350.12 at least.\n// Specialized implementations can well be faster in all cases.\n//\n\n// Macro based version for GLSL 1.2 / ES 2.0 by Tom\n\n#define GDFVector0 vec3(1, 0, 0)\n#define GDFVector1 vec3(0, 1, 0)\n#define GDFVector2 vec3(0, 0, 1)\n\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 1))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector15 normalize(vec3(1, 0, PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\n\n#define fGDFBegin float d = 0.;\n\n// Version with variable exponent.\n// This is slow and does not produce correct distances, but allows for bulging of objects.\n#define fGDFExp(v) d += pow(abs(dot(p, v)), e);\n\n// Version with without exponent, creates objects with sharp edges and flat faces\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n\n#define fGDFExpEnd return pow(d, 1./e) - r;\n#define fGDFEnd return d - r;\n\n// Primitives follow:\n\nfloat fOctahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExpEnd\n}\n\nfloat fDodecahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector13) fGDFExp(GDFVector14) fGDFExp(GDFVector15) fGDFExp(GDFVector16)\n    fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n    fGDFExpEnd\n}\n\nfloat fIcosahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n    fGDFExp(GDFVector11) fGDFExp(GDFVector12)\n    fGDFExpEnd\n}\n\nfloat fTruncatedOctahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector0) fGDFExp(GDFVector1) fGDFExp(GDFVector2) fGDFExp(GDFVector3)\n    fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExpEnd\n}\n\nfloat fTruncatedIcosahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n    fGDFExp(GDFVector11) fGDFExp(GDFVector12) fGDFExp(GDFVector13) fGDFExp(GDFVector14)\n    fGDFExp(GDFVector15) fGDFExp(GDFVector16) fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n    fGDFExpEnd\n}\n\nfloat fOctahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDFEnd\n}\n\nfloat fDodecahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n    fGDF(GDFVector17) fGDF(GDFVector18)\n    fGDFEnd\n}\n\nfloat fIcosahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12)\n    fGDFEnd\n}\n\nfloat fTruncatedOctahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector0) fGDF(GDFVector1) fGDF(GDFVector2) fGDF(GDFVector3)\n    fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDFEnd\n}\n\nfloat fTruncatedIcosahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12) fGDF(GDFVector13) fGDF(GDFVector14)\n    fGDF(GDFVector15) fGDF(GDFVector16) fGDF(GDFVector17) fGDF(GDFVector18)\n    fGDFEnd\n}\n\n\n////////////////////////////////////////////////////////////////\n//\n//                DOMAIN MANIPULATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that modifies the domain is named pSomething.\n//\n// Many operate only on a subset of the three dimensions. For those,\n// you must choose the dimensions that you want manipulated\n// by supplying e.g. <p.x> or <p.zx>\n//\n// <inout p> is always the first argument and modified in place.\n//\n// Many of the operators partition space into cells. An identifier\n// or cell index is returned, if possible. This return value is\n// intended to be optionally used e.g. as a random seed to change\n// parameters of the distance functions inside the cells.\n//\n// Unless stated otherwise, for cell index 0, <p> is unchanged and cells\n// are centered on the origin so objects don't have to be moved to fit.\n//\n//\n////////////////////////////////////////////////////////////////\n\n\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Same, but mirror every second cell so they match at the boundaries\nfloat pModMirror1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize,size) - halfsize;\n\tp *= mod(c, 2.0)*2. - 1.;\n\treturn c;\n}\n\n// Repeat the domain only in positive direction. Everything in the negative half-space is unchanged.\nfloat pModSingle1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tif (p >= 0.)\n\t\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n// Same, but mirror every second cell so all boundaries match\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n\tvec2 halfsize = size*0.5;\n\tvec2 c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tp *= mod(c,vec2(2))*2. - vec2(1);\n\treturn c;\n}\n\n// Same, but mirror every second cell at the diagonal as well\nvec2 pModGrid2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\tp *= mod(c,vec2(2))*2. - vec2(1);\n\tp -= size/2.;\n\tif (p.x > p.y) p.xy = p.yx;\n\treturn floor(c/2.);\n}\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sign(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\n// Mirror in both dimensions and at the diagonal, yielding one eighth of the space.\n// translate by dist before mirroring.\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n\tvec2 s = sign(p);\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n\tfloat t = dot(p, planeNormal)+offset;\n\tif (t < 0.) {\n\t\tp = p - (2.*t)*planeNormal;\n\t}\n\treturn sign(t);\n}\n\n\n////////////////////////////////////////////////////////////////\n//\n//             OBJECT COMBINATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// We usually need the following boolean operators to combine two objects:\n// Union: OR(a,b)\n// Intersection: AND(a,b)\n// Difference: AND(a,!b)\n// (a and b being the distances to the objects).\n//\n// The trivial implementations are min(a,b) for union, max(a,b) for intersection\n// and max(a,-b) for difference. To combine objects in more interesting ways to\n// produce rounded edges, chamfers, stairs, etc. instead of plain sharp edges we\n// can use combination operators. It is common to use some kind of \"smooth minimum\"\n// instead of min(), but we don't like that because it does not preserve Lipschitz\n// continuity in many cases.\n//\n// Naming convention: since they return a distance, they are called fOpSomething.\n// The different flavours usually implement all the boolean operators above\n// and are called fOpUnionRound, fOpIntersectionRound, etc.\n//\n// The basic idea: Assume the object surfaces intersect at a right angle. The two\n// distances <a> and <b> constitute a new local two-dimensional coordinate system\n// with the actual intersection as the origin. In this coordinate system, we can\n// evaluate any 2D distance function we want in order to shape the edge.\n//\n// The operators below are just those that we found useful or interesting and should\n// be seen as examples. There are infinitely more possible operators.\n//\n// They are designed to actually produce correct distances or distance bounds, unlike\n// popular \"smooth minimum\" operators, on the condition that the gradients of the two\n// SDFs are at right angles. When they are off by more than 30 degrees or so, the\n// Lipschitz condition will no longer hold (i.e. you might get artifacts). The worst\n// case is parallel surfaces that are close to each other.\n//\n// Most have a float argument <r> to specify the radius of the feature they represent.\n// This should be much smaller than the object size.\n//\n// Some of them have checks like \"if ((-a < r) && (-b < r))\" that restrict\n// their influence (and computation cost) to a certain area. You might\n// want to lift that restriction or enforce it. We have left it as comments\n// in some cases.\n//\n// usage example:\n//\n// float fTwoBoxes(vec3 p) {\n//   float box0 = fBox(p, vec3(1));\n//   float box1 = fBox(p-vec3(1), vec3(1));\n//   return fOpUnionChamfer(box0, box1, 0.2);\n// }\n//\n////////////////////////////////////////////////////////////////\n\n\n// The \"Chamfer\" flavour makes a 45-degree chamfered edge (the diagonal of a square of size <r>):\nfloat fOpUnionChamfer(float a, float b, float r) {\n\tfloat m = min(a, b);\n\t//if ((a < r) && (b < r)) {\n\t\treturn min(m, (a - r + b)*sqrt(0.5));\n\t//} else {\n\t\treturn m;\n\t//}\n}\n\n// Intersection has to deal with what is normally the inside of the resulting object\n// when using union, which we normally don't care about too much. Thus, intersection\n// implementations sometimes differ from union implementations.\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n\tfloat m = max(a, b);\n\tif (r <= 0.) return m;\n\tif (((-a < r) && (-b < r)) || (m < 0.)) {\n\t\treturn max(m, (a + r + b)*sqrt(0.5));\n\t} else {\n\t\treturn m;\n\t}\n}\n\n// Difference can be built from Intersection or Union:\nfloat fOpDifferenceChamfer (float a, float b, float r) {\n\treturn fOpIntersectionChamfer(a, -b, r);\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n\tfloat m = min(a, b);\n\tif ((a < r) && (b < r) ) {\n\t\treturn min(m, r - sqrt((r-a)*(r-a) + (r-b)*(r-b)));\n\t} else {\n\t return m;\n\t}\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tfloat m = max(a, b);\n\tif ((-a < r) && (-b < r)) {\n\t\treturn max(m, -(r - sqrt((r+a)*(r+a) + (r+b)*(r+b))));\n\t} else {\n\t\treturn m;\n\t}\n}\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n\treturn fOpIntersectionRound(a, -b, r);\n}\n\n\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle:\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\nfloat fOpDifferenceColumns(float a, float b, float r, float n) {\n\ta = -a;\n\tfloat m = min(a, b);\n\t//avoid the expensive computation where not needed (produces discontinuity though)\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/n/2.0;\n\t\tcolumnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\n\t\tpR45(p);\n\t\tp.y += columnradius;\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += -columnradius*sqrt(2.)/2.;\n\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\tpMod1(p.y,columnradius*2.);\n\n\t\tfloat result = -length(p) + columnradius;\n\t\tresult = max(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn -min(result, b);\n\t} else {\n\t\treturn -m;\n\t}\n}\n\nfloat fOpIntersectionColumns(float a, float b, float r, float n) {\n\treturn fOpDifferenceColumns(a,-b,r, n);\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat d = min(a, b);\n\tvec2 p = vec2(a, b);\n\tpR45(p);\n\tp = p.yx - vec2((r-r/n)*0.5*sqrt(2.));\n\tp.x += 0.5*sqrt(2.)*r/n;\n\tfloat x = r*sqrt(2.)/n;\n\tpMod1(p.x, x);\n\td = min(d, p.y);\n\tpR45(p);\n\treturn min(d, vmax(p -vec2(0.5*r/n)));\n}\n\n// We can just call Union since stairs are symmetric.\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, -b, r, n);\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\n\n// This produces a cylindical pipe that runs along the intersection.\n// No objects remain, only the pipe. This is not a boolean operator.\nfloat fOpPipe(float a, float b, float r) {\n\treturn length(vec2(a, b)) - r;\n}\n\n////////////////////////////////////////////////////////////////\n// The end of HG_SDF library\n////////////////////////////////////////////////////////////////\n\n\n\n\n//------------------------------------------------------------------------\n// Here rather hacky and very basic sphere tracer, feel free to replace.\n//------------------------------------------------------------------------\n\n// fField(p) is the final SDF definition, declared at the very bottom\n\nconst int iterations = 2000;\nconst float dist_eps = .0001;\nconst float ray_max = 2000.0;\nconst float fog_density = .001;\n\nconst float cam_dist = 35.;\n\nfloat fField(vec3 p);\n\nvec3 dNormal(vec3 p)\n{\n   const vec2 e = vec2(.005,0);\n   return normalize(vec3(\n      fField(p + e.xyy) - fField(p - e.xyy),\n      fField(p + e.yxy) - fField(p - e.yxy),\n      fField(p + e.yyx) - fField(p - e.yyx) ));\n}\n\nvec4 trace(vec3 ray_start, vec3 ray_dir)\n{\n   float ray_len = 0.0;\n   vec3 p = ray_start;\n   for(int i=0; i<iterations; ++i) {\n   \t  float dist = fField(p);\n      if (dist < dist_eps) break;\n      if (ray_len > ray_max) return vec4(0.0);\n      p += dist*ray_dir / 2.;\n      ray_len += dist;\n   }\n   return vec4(p, 1.0);\n}\n\n// abs(0+0-1)=1\n// abs(1+0-1)=0\n// abs(0+1-1)=0\n// abs(1+1-1)=1\nfloat xnor(float x, in float y) { return abs(x+y-1.0); }\n\nvec4 checker_texture(vec3 pos, float sample_size)\n{\n   pos = pos*8.0 + .5;\n   vec3 cell = step(1.0,mod(pos,2.0));\n   float checker = xnor(xnor(cell.x,cell.y),cell.z);\n   vec4 col = mix(vec4(.4),vec4(.5),checker);\n   float fade = 1.-min(1.,sample_size*24.); // very fake \"AA\"\n   col = mix(vec4(.95, .8, .2, .5),col,fade);\n   pos = abs(fract(pos)-.5);\n   float d = max(max(pos.x,pos.y),pos.z);\n   d = smoothstep(.45,.5,d)*fade;\n   return mix(col,vec4(0.0),d);\n}\n\nvec3 sky_color(vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float b_o = max(cos (uv.x * PI * 2.), cos (uv.y * PI * 2.));\n    vec3 col_o = vec3(b_o);\n    \n    vec2 uv_i = mod(uv * vec2(16., 9.), vec2(16., 9.));\n    uv_i = vec2(uv_i.x + uv_i.y, -uv_i.x + uv_i.y);\n    \n    \n    float b_i = max(cos (uv_i.x * PI * 2.), cos (uv_i.y * PI * 2.));\n    vec3 col_i = (b_i>.9?.2:0.) * vec3(1., 0.5, 1.);\n    col_i *= b_i = min(b_i, -b_o * 2.5);\n\n\n    // Output to screen\n    return vec3(b_o< 0.? col_i: col_o);\n}\n\n/*vec3 sky_color(vec3 ray_dir, vec3 light_dir)\n{\n   float d = max(0.,dot(ray_dir,light_dir));\n   float d2 = light_dir.y*.7+.3;\n   vec3 base_col;\n   base_col = mix(vec3(.3),vec3((ray_dir.y<0.)?0.:1.),abs(ray_dir.y));\n   return base_col*d2;\n}*/\n\nvec4 debug_plane(vec3 ray_start, vec3 ray_dir, float cut_plane, inout float ray_len)\n{\n    // Fancy lighty debug plane\n    if (ray_start.y > cut_plane && ray_dir.y < 0.) {\n       float d = (ray_start.y - cut_plane) / -ray_dir.y;\n       if (d < ray_len) {\n           vec3 hit = ray_start + ray_dir*d;\n           float hit_dist = fField(hit);\n           float iso = fract(hit_dist*5.0);\n           vec3 dist_color = mix(vec3(.2,.4,.6),vec3(.2,.2,.4),iso);\n           dist_color *= 1.0/(max(0.0,hit_dist)+.001);\n           ray_len = d;\n           return vec4(dist_color,.1);\n      }\n   }\n   return vec4(0);\n}\n\nvec3 shade(vec3 ray_start, vec3 ray_dir, vec3 light_dir, vec4 hit, vec2 fragCoord)\n{\n   vec3 fog_color = sky_color(fragCoord);\n   \n   float ray_len;\n   vec3 color;\n   if (hit.w == 0.0) {\n      ray_len = 1e16;\n      color = fog_color;\n   } else {\n      vec3 dir = hit.xyz - ray_start;\n      vec3 norm = dNormal(hit.xyz);\n      float diffuse = max(0.0, dot(norm, light_dir));\n      float spec = max(0.0,dot(reflect(light_dir,norm),normalize(dir)));\n      spec = pow(spec, 16.0)*.5;\n       \n      ray_len = length(dir);\n   \n      vec3 base_color = checker_texture(hit.xyz,ray_len/iResolution.y).xyz;\n      color = mix(vec3(0.,.1,.3),vec3(1.,1.,.9),diffuse)*base_color +\n         spec*vec3(1.,1.,.9);\n\n      float fog_dist = ray_len;\n      float fog = 1.0 - 1.0/exp(fog_dist*fog_density);\n      color = mix(color, fog_color, fog);\n   }\n   \n   \n    \n   float cut_plane0 = sin(iTime)*.15 - .8;\n   for(int k=0; k<4; ++k) {\n      vec4 dpcol = debug_plane(ray_start, ray_dir, cut_plane0+float(k)*.75, ray_len);\n      //if (dpcol.w == 0.) continue;\n      float fog_dist = ray_len;\n      dpcol.w *= 1.0/exp(fog_dist*.05);\n      //color = mix(color,dpcol.xyz,dpcol.w);\n   }\n\n   return color;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n   vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n    \n   vec3 light_dir = normalize(vec3(.5, 1.0, -.25));\n   \n   // Simple model-view matrix:\n   float ang, si, co;\n   ang = (iMouse.z > 0.0) ? (iMouse.x - iResolution.x*.5) * -.018 :\n      .5; //iTime*.25;\n   si = sin(ang); co = cos(ang);\n   mat4 cam_mat = mat4(\n      co, 0., si, 0.,\n      0., 1., 0., 0.,\n     -si, 0., co, 0.,\n      0., 0., 0., 1.);\n   ang = (iMouse.z > 0.0) ? (iMouse.y - iResolution.y*.5) * -.018 :\n      .6; //iTime*.2;\n   si = sin(ang); co = cos(ang);\n   cam_mat = cam_mat * mat4(\n      1., 0., 0., 0.,\n      0., co, si, 0.,\n      0.,-si, co, 0.,\n      0., 0., 0., 1.);\n\n   vec3 pos = vec3(cam_mat*vec4(0., -0., -cam_dist, 1.0));\n   vec3 dir = normalize(vec3(cam_mat*vec4(uv, 1., 0.)));\n   \n   vec3 color = shade(pos, dir, light_dir, trace(pos, dir), fragCoord);\n   color = pow(color,vec3(.44));\n   fragColor = vec4(color, 1.);\n}\n\n//------------------------------------------------------------------------\n// Your custom SDF\n//------------------------------------------------------------------------\n\n\n/*float fField(vec3 p)\n{\n   float towerspacing = 3.5;\n   vec2 c = pMod2(p.xz, vec2(towerspacing));\n   float towerfaces = 5. + floor(2. * sin(9. * c.x + 2.12345 * c.y));\n   pModPolar(p.xz, towerfaces);\n   \n   //pMirrorOctant(p.xz, vec2(.4, .4));\n   p.y += 1.;\n   float basewidth = 0.5 + .2 * sin(1. * c.x + 5.12345 * c.y);\n   float wallthinkness = .05 + .02 * sin(2. *c.x + 6.12345 * c.y);\n   float mainfaceheight = 1. + 1. * sin(3. *c.x + 6.12345 * c.y);\n   float balconywidth = 0.2 + .15 * sin(4. *c.x + 7.12345 * c.y);\n   float balconyheight = 0.2 + .1 * sin(5. *c.x + 8.12345 * c.y);\n   float breastguardheight = 0.15 + .1 * sin(c.x + 0.12345 * c.y);\n   p.x -= basewidth;\n   float mainface = fBox2(p.xy,vec2(wallthinkness, mainfaceheight));\n   p.y -= mainfaceheight;\n   p.x -= balconywidth;\n   float balconyfloor = fBox2(p.xy,vec2(balconywidth, wallthinkness));\n   p.y -= balconyheight;\n   p.x -= balconywidth;\n   float balconywall = fBox2(p.xy,vec2(wallthinkness, balconyheight));\n   p.y -= balconyheight;\n   pMod1(p.z, wallthinkness * 4.);\n   float breastguard = fBox(p,vec3(.1, breastguardheight, wallthinkness));\n   float wall = fOpUnionStairs(mainface, balconyfloor, .2, 3.);\n   wall = fOpUnionStairs(wall, balconywall, .2, 3.);\n   wall = min(wall, breastguard);\n   return wall;\n}\n*/\n\n/*float fField(vec3 p)\n{\n    float pilar_width = 0.1;\n    float pilar_spacing = 3.0;\n    float floor_height = .8;\n    float floor_thickness = 0.1;\n    float railing_thickness = 0.05;\n    float railing_height = 0.5;\n    float wall_height = 0.2;\n    float wall_width = 0.05;\n    \n    \n    vec3 po = p; // Save original position for reseting for frame.\n    \n    \n    pModPolar(p.xz, 4.);\n    p.x -= (1.5 + sin( iTime) * 1.5) * pilar_spacing;\n    \n    // Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\n    pMirror(p.x, 3.);\n    \n    pMod1(p.z, pilar_spacing); // Repeat horizontally\n    \n    float ground =  fPlane(p, vec3(0., 1., 0.), 0.);\n    \n    p.y -= floor_height * 2.4;\n    float pilar = fBox(p,vec3(pilar_width, floor_height * 2.4, pilar_width));\n    \n    p.y = po.y;\n    p.y -= railing_height;\n    pModInterval1(p.y, floor_height * 2., 0., 2.);\n    //p.z -= pilar_spacing;\n    pR(p.yz, PI/2.);\n    float railing = fCylinder(p, railing_thickness, pilar_spacing);\n    \n    p.y = po.y;\n    p.y -= wall_height / 2.0;\n    pModInterval1(p.y, floor_height * 2., 0., 2.);\n    float wall = fBox2(p.xy, vec2(wall_width, wall_height)); \n    \n    \n    p.y = po.y;\n    p.y -= floor_height * 2.;\n    pModInterval1(p.y, floor_height * 2., -1., 1.);\n    p.x += 100. - pilar_width;\n    float parking_floor = fBox2(p.xy, vec2(100., floor_thickness));\n    \n    return min(min(min(min(pilar, railing), wall), parking_floor), 10000.);\n}*/\n\nfloat fField(vec3 p) {\n    float height = 1.;\n    \n    float ball = fSphere(p, 8.);\n    p.y -= height;\n    float cut = fSphere(vec3(p.x+28.*sin(iTime * .4), p.y-19., p.z), 19.);\n    \n    p.y += 3.2;\n    ball = fOpUnionRound(ball, fSphere(p, 5.), 0.8);\n    \n    float bumper = fOpUnionRound(fSphere(vec3(p.x, p.y-7., p.z + 5.+ sin(iTime * .4)), 5.), fSphere(vec3(p.x-3.+ sin(iTime * .2), p.y-7., p.z - 4.), 5.), 0.8);\n    bumper = fOpUnionRound(bumper, fSphere(vec3(p.x+3.+ sin(iTime * .3), p.y-6., p.z - 4.), 4.), .8);\n    bumper = fOpUnionRound(bumper, fSphere(vec3(p.x, p.y-23. + sin(iTime * .2), p.z), 19.), 0.8);\n    bumper = fOpUnionRound(bumper, fSphere(vec3(p.x+3., p.y-5. + sin(iTime * .6), p.z - 4.), 4.), 0.8);\n    bumper = fOpUnionRound(bumper, fSphere(vec3(p.x+3. * sin(iTime * .6), p.y-5., p.z + 4.), 4.), 0.8);\n    bumper = fOpUnionRound(bumper, fSphere(vec3(p.x-4., p.y-6., p.z + 2. + 2. * sin(iTime * .6)), 4.), 0.8);\n    \n    ball = max(ball, -bumper);\n    \n    ball = fOpUnionRound(ball, fSphere(vec3(p.x + 2. + 2. * sin(iTime * 3.), p.y - 3. + 7. * sin(iTime * 6.), p.z), 1.7), .5);\n    ball = fOpUnionRound(ball, fSphere(vec3(p.x - 2. + 2. * sin(iTime * 3. + 3.), p.y - 3. + 7. * sin(iTime * 6. + 4.), p.z), 1.), .5);\n    ball = fOpUnionRound(ball, fSphere(vec3(p.x, p.y - 3. + 7. * sin(iTime * 6. + 2.), p.z - 2. + 2. * sin(iTime * 3. + 3.)), 1.), .5);\n    \n    \n    return ball;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfBzH.jpg", "access": "api", "license": "cc-by-4.0 OR cc-by-3.0", "functions": [[1494, 1533, 1553, 1553, 1578], [1580, 1580, 1604, 1604, 1619], [1621, 1621, 1643, 1643, 1658], [1660, 1660, 1682, 1682, 1697], [1699, 1699, 1724, 1724, 1745], [1748, 1788, 1808, 1808, 1833], [1835, 1835, 1855, 1855, 1890], [1892, 1892, 1912, 1912, 1957], [1959, 1959, 1979, 1979, 2004], [2006, 2006, 2026, 2026, 2061], [2063, 2063, 2083, 2083, 2128], [2686, 2686, 2718, 2718, 2743], [2745, 2819, 2875, 2875, 2917], [2919, 2970, 3003, 3015, 3043], [3045, 3081, 3109, 3109, 3190], [3192, 3249, 3283, 3283, 3309], [3311, 3311, 3340, 3340, 3421], [3424, 3444, 3468, 3468, 3527], [3529, 3633, 3654, 3654, 4027], [4029, 4074, 4122, 4122, 4196], [4198, 4251, 4293, 4293, 4387], [4389, 4473, 4517, 4517, 4620], [4622, 4694, 4743, 4743, 4780], [4782, 4807, 4867, 4867, 4938], [4940, 5039, 5071, 5071, 5132], [5134, 5267, 5297, 5297, 5378], [5380, 5421, 5465, 5465, 5705], [5707, 5744, 5784, 5784, 5848], [5850, 5946, 5995, 5995, 6494]], "test": "untested"}
{"id": "WsXfRH", "name": "my edited furball", "author": "tristanx", "description": "Kajiya & Kay style ray-marched fur.\n\nhttp://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.127.5564", "tags": ["raymarch", "hair", "fur", "fluffy"], "likes": 14, "viewed": 873, "published": 3, "date": "1587655086", "time_retrieved": "2024-07-30T21:10:57.422004", "image_code": "// Fork of \"furball\" by simesgreen. https://shadertoy.com/view/XsfGWN\n// 2020-04-23 15:13:28\n\n// my edited fur ball\n// \n\nconst float uvScale = 2.0;\nconst float colorUvScale = 0.2;\nconst float furDepth = 0.4;\nconst int furLayers = 64;\nconst float rayStep = furDepth*2.0 / float(furLayers);\nconst float furThreshold = 0.4;\nconst float shininess = 50.0;\n\nbool intersectSphere(vec3 ro, vec3 rd, float r, out float t)\n{\n\tfloat b = dot(-ro, rd);\n\tfloat det = b*b - dot(ro, ro) + r*r;\n\tif (det < 0.0) return false;\n\tdet = sqrt(det);\n\tt = b - det;\n\treturn t > 0.0;\n}\n\nvec3 rotateX(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec2 cartesianToSpherical(vec3 p)\n{\t\t\n\tfloat r = length(p);\n\n\tfloat t = (r - (1.0 - furDepth)) / furDepth;\t\n\tp = rotateX(p.zyx, -cos(iTime*1.5)*t*t*0.4).zyx;\t// curl\n\n\tp /= r;\t\n\tvec2 uv = vec2(atan(p.y, p.x), acos(p.z));\n\n\t//uv.x += cos(iTime*1.5)*t*t*0.4;\t// curl\n\t//uv.y += sin(iTime*1.7)*t*t*0.2;\n\tuv.y -= t*t*0.1;\t// curl down\n\treturn uv;\n}\n\n// returns fur density at given position\nfloat furDensity(vec3 pos, out vec2 uv)\n{\n\tuv = cartesianToSpherical(pos.xzy);\t\n\tvec4 tex = textureLod(iChannel0, uv*uvScale, 0.0);\n\n\t// thin out hair\n\tfloat density = smoothstep(furThreshold, 1.0, tex.x);\n\t\n\tfloat r = length(pos);\n\tfloat t = (r - (1.0 - furDepth)) / furDepth;\n\t\n\t// fade out along length\n\tfloat len = tex.y;\n\tdensity *= smoothstep(len, len-0.2, t);\n\n\treturn density;\t\n}\n\n// calculate normal from density\nvec3 furNormal(vec3 pos, float density)\n{\n    float eps = 0.01;\n    vec3 n;\n\tvec2 uv;\n    n.x = furDensity( vec3(pos.x+eps, pos.y, pos.z), uv ) - density;\n    n.y = furDensity( vec3(pos.x, pos.y+eps, pos.z), uv ) - density;\n    n.z = furDensity( vec3(pos.x, pos.y, pos.z+eps), uv ) - density;\n    return normalize(n);\n}\n\nvec3 furShade(vec3 pos, vec2 uv, vec3 ro, float density)\n{\n\t// lighting\n\tconst vec3 L = vec3(0, 1, 0);\n\tvec3 V = normalize(ro - pos);\n\tvec3 H = normalize(V + L);\n\n\tvec3 N = -furNormal(pos, density);\n\t//float diff = max(0.0, dot(N, L));\n\tfloat diff = max(0.0, dot(N, L)*0.5+0.5);\n\tfloat spec = pow(max(0.0, dot(N, H)), shininess);\n\t\n\t// base color\n\tvec3 color = textureLod(iChannel1, uv*colorUvScale, 0.0).xyz;\n\n\t// darken with depth\n\tfloat r = length(pos);\n\tfloat t = (r - (1.0 - furDepth)) / furDepth;\n\tt = clamp(t, 0.0, 1.0);\n\tfloat i = t*0.5+0.5;\n\t\t\n\treturn color*diff*i + vec3(spec*i);\n}\t\t\n\nvec4 scene(vec3 ro,vec3 rd)\n{\n\tvec3 p = vec3(0.0);\n\tconst float r = 1.0;\n\tfloat t;\t\t\t\t  \n\tbool hit = intersectSphere(ro - p, rd, r, t);\n\t\n\tvec4 c = vec4(0.0);\n\tif (hit) {\n\t\tvec3 pos = ro + rd*t;\n\n\t\t// ray-march into volume\n\t\tfor(int i=0; i<furLayers; i++) {\n\t\t\tvec4 sampleCol;\n\t\t\tvec2 uv;\n\t\t\tsampleCol.a = furDensity(pos, uv);\n\t\t\tif (sampleCol.a > 0.0) {\n\t\t\t\tsampleCol.rgb = furShade(pos, uv, ro, sampleCol.a);\n\n\t\t\t\t// pre-multiply alpha\n\t\t\t\tsampleCol.rgb *= sampleCol.a;\n\t\t\t\tc = c + sampleCol*(1.0 - c.a);\n\t\t\t\tif (c.a > 0.95) break;\n\t\t\t}\n\t\t\t\n\t\t\tpos += rd*rayStep;\n\t\t}\n\t}\n\t\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv*2.0-1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 ro = vec3(0.0, 0.0, 2.5);\n\tvec3 rd = normalize(vec3(uv, -2.0));\n\t\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\tfloat roty = 0.0;\n\tfloat rotx = 0.0;\n\tif (iMouse.z > 0.0) {\n\t\trotx = (mouse.y-0.5)*3.0;\n\t\troty = -(mouse.x-0.5)*6.0;\n\t} else {\n\t\troty = sin(iTime*1.5);\n\t}\n\t\n    ro = rotateX(ro, rotx);\t\n    ro = rotateY(ro, roty);\t\n    rd = rotateX(rd, rotx);\n    rd = rotateY(rd, roty);\n\t\n\tfragColor = scene(ro, rd);\n}", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXfRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[352, 352, 414, 414, 558], [560, 560, 591, 591, 695], [697, 697, 728, 728, 833], [835, 835, 870, 870, 1179], [1181, 1222, 1263, 1263, 1609], [1611, 1644, 1685, 1685, 1963], [1965, 1965, 2023, 2036, 2556], [2560, 2560, 2589, 2589, 3146], [3148, 3148, 3205, 3205, 3725]], "test": "untested"}
{"id": "3sXfRH", "name": "Landscape in a tweet", "author": "clepirelli", "description": "Small experiment with displaying as much as I could with as little code as I could\n\nLater much improved by Fabrice Neyret", "tags": ["landscape", "short", "tweet"], "likes": 2, "viewed": 284, "published": 3, "date": "1587654405", "time_retrieved": "2024-07-30T21:10:58.161028", "image_code": "\n//second version, by Fabrice Neyret, 220 chars (with AA)\n\n\n#define z(c) fract(4e5*sin(c*1e5))\nvoid mainImage(out vec4 o, vec2 u) {                                  \\\n    for(vec2 j = 6.* u/iResolution.xy - 2.4, c,x,f, i = j-j ;\n        i++.x < 6.;\n\t\to += smoothstep( c = fwidth(f),-c, f ).x / (2.+i).x\n       )\n       x = floor( c= j+i*iTime ), f = c-x,\n       f = j.y + 3.-i + mix( z(x),z(++x), f*f*(2.-f) );}\n\n\n\n\n\n\n\n\n\n\n\n//first version, by me, 258 chars: \n\n\n//#define z(c)fract(dot(vec3(sin(c*12.015)),vec3(84.942, 92.229, 74.298)))\n//void mainImage(out vec4 a,vec2 b){\n//\tvec2 j=(b/iResolution.xy-.4)*6.;\n//\tfor(float i; i<5.;i++){\n//\t\tfloat c=j.x+i*iTime,x=floor(c),f=c-x;\n//\t\ta+=float(j.y+3.-i+mix(z(x),z(++x),f*f*(2.-1.*f))<.5)/(3.+i);\n//\t}\n//}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXfRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 95, 131, 131, 411]], "test": "untested"}
{"id": "WsfBz8", "name": "1 tweet effect challenge", "author": "yasuo", "description": "I won't do this any more.... This shit takes my time forever.....", "tags": ["raymarching", "tweet"], "likes": 4, "viewed": 351, "published": 3, "date": "1587651535", "time_retrieved": "2024-07-30T21:10:58.906036", "image_code": "void mainImage(out vec4 O, vec2 T) {\n    vec2 R=iResolution.xy,U=(T-.5*R.xy)/R.y;\n    float D,t=iTime;\n    vec3 P,B = normalize( vec3( U.x, U.y,1) );\n    for(int i = 0; i<64;i++) {\n        P = vec3(0, sin(U.x*5.+t), -5)+ B*D;\n        P.z-=t*6.; \n        P=mod(P,3.)-1.5;\n        P.z -= clamp( P.z, 0., 5. );\n        D+=length(P) - .05;\n    }\n    O.r=O.g=((D< 16.) ? 1.:0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsfBz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 375]], "test": "untested"}
{"id": "tsjyWV", "name": "Single Layer Blurred Glitter", "author": "qwert33", "description": "Second step towards building a renderer for https://youtu.be/BtYKDamqo2I?t=334\nMouse click/drag to adjust depth-of-field blur.\n\nStep one: https://www.shadertoy.com/view/td2cDy\nStep three: https://www.shadertoy.com/view/wdXfzN#", "tags": ["dof", "glitter"], "likes": 1, "viewed": 332, "published": 3, "date": "1587635252", "time_retrieved": "2024-07-30T21:10:59.650047", "image_code": "\nconst vec3 default_debug = vec3(-100, -20, -10);\nconst vec3 orange = vec3(1., .5, 0.);\nconst vec3 cornflowerblue = vec3(100./255., 149./255., 237./255.);\nvec3 debug = default_debug;\n\nfloat blurRadius;\n\n\n#define TAU 6.28318530718\n#define PI TAU/2.\n// Dave Hoskins hash\nfloat hash13(in vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse(vec2 p, in vec2 ab) {\n    if (abs(ab.x-ab.y) < .00001) return length(p) - ab.x;  // haaax due to numerical stability issues.\n\n\tp = abs(p); \n    if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if (d<0.0) {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    } else {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx) + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = ab * vec2(co,si);\n\t\n    return length(r-p) * sign(p.y-r.y);\n}\nfloat sdEllipsoidApproximated( in vec2 p, in vec2 r ) {\n    float k0 = length(p/r);\n \treturn length(p/r) - 1.;\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n\n// How many cells around the central_cell we check for ellipses.\n#define SAMPLE_RADIUS 2\n\nfloat monochrome(vec2 uv) {\n    \n    const float cell_wd = 5.5;\n    vec2 central_cell_center = floor((uv+.5*cell_wd) / cell_wd) * cell_wd;\n    \n\tfloat hashTime = iTime + 100.;  // Don't want thing to be synchonous when the shader starts    \n    \n    int j;\n    float acc = 0.;\n    for (int i = -SAMPLE_RADIUS; i<=SAMPLE_RADIUS; ++i) {\n        for (j = -SAMPLE_RADIUS; j<=SAMPLE_RADIUS; ++j) {\n            vec2 cell_center = central_cell_center + cell_wd*vec2(ivec2(i,j));\n            \n            vec2 cell_hash_pos = cell_center + vec2(1030., 0);\n            float yaw = TAU * hash13(vec3(cell_hash_pos, 2.));\n            float angular_speed = 3. + hash13(vec3(cell_hash_pos, 3.));\n            vec2 angular_vel = angular_speed * vec2(cos(yaw), sin(yaw));\n            float pitch = length(angular_vel) * hashTime * 0.1;\n            vec2 a = normalize(angular_vel);  // axis of rotation - major axis of projected ellipse.\n            vec2 b = vec2(-a.y, a.x) * cos(pitch);  // minor axis\n            vec2 ab = vec2(length(a), length(b));\n            mat2 rot = mat2(a.x, a.y,\n                            -a.y, a.x);\n\n            vec3 normal = vec3(0.0, sin(pitch), cos(pitch));\n            mat3 rot3 = mat3(a.x, a.y, 0.,\n                             -a.y, a.x, 0.,\n                             0., 0., 1.);\n            normal = transpose(rot3) * normal;\n            const vec3 LIGHT_DIR = normalize(vec3(1.5, -1.0, 2.0));\n            float light_per_area = \n                .2 + // ambient\n                50.0 * smoothstep(.98, .99, abs(dot(normal, LIGHT_DIR)));  // cheap (wrong-ish) specular\n            float total_light = light_per_area * ab.x * ab.y;  // total amount of light emitted by this object towards all pixels.\n\n            // Have a random offset from the cell_center.\n            vec2 ellipse_center = cell_center + (.5*cell_wd - ab.x) * vec2(\n            \tsin(hashTime * (.01 + .06*hash13(vec3(cell_hash_pos, 4.)))),\n                cos(hashTime * (.01 + .06*hash13(vec3(cell_hash_pos, 4.))))\n            );\n\t\t\tvec2 ellipse_uv = uv - ellipse_center;   \n            \n            vec2 extended_ab = ab + vec2(blurRadius);\n            //float sd = sdEllipse(transpose(rot)*inner_uv, extended_ab);\n            //float sd = sdEllipsoidApproximated(transpose(rot)*inner_uv, extended_ab);\n            float sd = length(transpose(rot)*ellipse_uv / extended_ab) - 1.;  // Signed distance approximation only accurate for values near zero.\n            float proportional_area = extended_ab.x * extended_ab.y;\n            float edge_blurryness = 0.1/length(extended_ab);\n            float is_in_ellipse = smoothstep(edge_blurryness, -edge_blurryness, sd);\n            acc += is_in_ellipse * (total_light / proportional_area);\n\n            // Debug major/minor axes.\n            //if (abs(dot(uv-ellipse_center, normalize(b))) <.01 && length(uv-ellipse_center) < 1.) acc += .9;\n            //if (abs(dot(uv-ellipse_center, normalize(a))) <.01 && length(uv-ellipse_center) < length(b))  acc += .9;\n\n            acc += 1.-smoothstep(0., .1, abs(length(uv) - blurRadius));\n        }\n    }\n\treturn acc;\n}\n\nvec2 project(vec2 pixel) {\n    vec2 uv = pixel/iResolution.xy - vec2(0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv *50.;\n}\n\n\n// antialiasing\nfloat sampleSubpixel(vec2 pixels) {\n\tconst int size = 0; \n    const float numContrb = float(size+1)*float(size+1);\n\tfloat disp = 1.0 / (float(size) + 2.0);\n\tfloat contrb = 0.0;\n\tfor (int j = -size; j <= size; j++) {\n\t\tfor (int i = -size; i <= size; i++) {\n\t\t\tcontrb += monochrome(project(\n                pixels + vec2(float(i) * (disp / 3.0), float(j) * disp)\n            ));\n\t\t}\n\t}\n\treturn contrb / numContrb;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    blurRadius = (iMouse.xy == vec2(0.))? .6 : max(0., length(project(iMouse.xy))-.5);\n    vec3 light = vec3(.1,.2,.9) * sampleSubpixel(fragCoord);\n    light = 1. - exp(-2. * light); // Simulate exposure\n    fragColor = vec4(light, 1.0);\n    if (debug != default_debug) fragColor.rgb = debug;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjyWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[248, 269, 295, 295, 398], [400, 441, 478, 478, 1637], [1638, 1638, 1693, 1693, 1809], [1902, 1902, 1929, 1929, 5006], [5008, 5008, 5034, 5034, 5147], [5582, 5582, 5636, 5636, 5931]], "test": "untested"}
{"id": "tssBRr", "name": "Many balls in 1 tweet", "author": "iY0Yi", "description": "https://twitter.com/iY0Yi/status/1253162301705777155?s=20\n\ntwigl.app:\nbit.ly/2VumdtZ", "tags": ["ball", "golf", "1tc"], "likes": 14, "viewed": 418, "published": 3, "date": "1587629992", "time_retrieved": "2024-07-30T21:11:00.386079", "image_code": "//* My current...(274 => 259ch): -------------------------------------------------------------\n#define M(p)min((p).y,length(p-vec3(\\\nsin(Q.z),\\\nabs(cos(iTime*7.+Q.z))+.5,\\\ncos(Q.x)\\\n))-.5)\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    vec3 P,Q,R=iResolution,T;\n    for(;O.w++<99.;T+=M(P)*.5)\n        P=1.-vec3((.5*R.xy-C)/R.y,1)*T,\n        Q=ceil(P/4.)+iTime,\n        P.xz=mod(P.xz,4.)-2.,\n        O+=M(P)<.1?M(P+.2)*.03:0.;\n}\n\n\n/* By iapafoto(244ch): ----------------------------------------------------------------------\n#define M min(P.y,length(P-vec3(sin(Q.z),abs(cos(iTime*6.+Q.z))+.5, cos(Q.x)))-.5)\n#define mainImage(O,C)\\\n\tvec3 Q,R=iResolution,P=R-R+.9,T=P;\\\n    for(;++O.w<3e2;P=T-=vec3(R.xy-C-C,R)/R.y*M*.3,Q=ceil(P/4.)+iTime,P.xz=mod(P.xz,4.)-2.);\\\n    O+=M<.1?P+=.2,M:0.\n//*/\n\n\n\n/* My original w/ spalmer's tips(280 => 274ch): ---------------------------------------------\n#define M(p)min((p).y,length(p+vec3(\\\nsin(iTime+Q.z),\\\n-abs(cos(iTime*7.+Q.z))-.5,\\\ncos(iTime+Q.x)\\\n))-.5)\n\n#define mainImage(O,C){\\\n    vec3 P,Q,R=iResolution;\\\n    for(float T,i=0.;i++<99.;T+=M(P)*.5)\\\n        P=.9-vec3((.5*R.xy-C)/R.y,1)*T,\\\n        Q=ceil(P/4.),\\\n        P.xz=mod(P.xz,4.)-2.,\\\n        O+=M(P)<.1?M(P+.2)*.03:0.;\\\n}\n//*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tssBRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[190, 190, 226, 226, 422]], "test": "untested"}
{"id": "3dsBRr", "name": "Penumbra Shadows by giaosame", "author": "giaosame", "description": "Implement the penumbra shadows approximation of soft shadows, refer to the code from https://www.shadertoy.com/view/wsjGDG.", "tags": ["3d"], "likes": 1, "viewed": 304, "published": 3, "date": "1587608445", "time_retrieved": "2024-07-30T21:11:01.146047", "image_code": "const vec4 FLOOR_VEC       = vec4(0.0, 1.0, 0.0, 3.0);\nconst vec3 LONG_BOX_POS    = vec3(2.1, -0.5, -2);\nconst vec3 LONG_BOX_SCALE  = vec3(1.5, 3.0, 1.5);\nconst vec3 SPHERE_POS      = vec3(2.2, -1.0, 1.7);\nconst vec3 TORUS_POS       = vec3(0.5, 2.0, 1);\nconst vec2 TORUS_RADIUS    = vec2(1.0, 0.45);\n\nconst vec3 EYE_POS         = vec3(0.0, 2.5, -14.5);\nconst vec3 REF_POS         = vec3(0.0, 2.5, 0.0);\n\nconst int RAY_STEPS     = 256;\nconst int FLOOR_ID      = 0;\nconst int LONG_BOX_ID   = 1;\nconst int SPHERE_ID     = 2;\nconst int TORUS_ID      = 3;\nconst float PI_OVER_180 = 3.1415926 / 180.0;\n\n// The higher the value, the smaller the penumbra\nconst float SHADOW_HARDNESS = 7.0;\n\n// 0 for penumbra shadows, 1 for hard shadows\n#define HARD_SHADOW 0\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n\nfloat plane(vec3 p, vec4 n)\n{\n  // n must be normalized\n  return dot(p, n.xyz) + n.w;\n}\n\n// Box with side lengths b\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\n\nfloat sphere(vec3 p, float r, vec3 c)\n{\n    return distance(p, c) - r;\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nvec3 rotateY(vec3 p, float a) \n{\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvec3 rotateX(vec3 p, float amt) \n{\n    return vec3(p.x, cos(amt) * p.y - sin(amt) * p.z, sin(p.y) + cos(p.z));\n}\n\n\nvoid sceneMap3D(vec3 pos, out float t, out int objId)\n{\n    // floor\n    t = plane(pos, FLOOR_VEC);  \n    objId = FLOOR_ID;  \n\n    float t2;\n    if((t2 = box(rotateY(pos + LONG_BOX_POS, 27.5 * PI_OVER_180), LONG_BOX_SCALE)) < t)  // long bix\n    {\n        t= t2;\n        objId = LONG_BOX_ID;\n    }\n    if((t2 = sphere(pos, 2.0, SPHERE_POS)) < t)\n    {\n        t= t2;\n        objId = SPHERE_ID;\n    }\n    if((t2 = torus(pos + TORUS_POS, TORUS_RADIUS)) < t)\n    {\n        t= t2;\n        objId = TORUS_ID;\n    }\n}\n\nfloat sceneMap3D(vec3 pos)\n{\n    float t = plane(pos, FLOOR_VEC);\n    t = min(t, box(rotateY(pos + LONG_BOX_POS, 27.5 * PI_OVER_180), LONG_BOX_SCALE));\n    t = min(t, sphere(pos, 2.0, SPHERE_POS));\n    t = min(t, torus(pos + TORUS_POS, TORUS_RADIUS));\n    return t;\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int objId)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n        float m;\n        sceneMap3D(pos, m, objId);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n\n    t = -1.0;\n    objId = -1;\n}\n\nvec3 computeMaterial(int objId, vec3 p, vec3 n)\n{\n    switch(objId) \n    {\n    case FLOOR_ID:  // floor\n    {\n        return vec3(1.0, 1.0, 1.0);\n        break;\n    }\n    case LONG_BOX_ID:  // Cuboid, the long box\n    {\n        return vec3(1.0, 0.4, 0.0);\n        break;\n    }\n    case SPHERE_ID:  // Sphere\n    {\n        return vec3(0.0, 1.0, 1.0);\n        break;\n    }   \n    case TORUS_ID:  // Torus\n    {\n        return vec3(0.9, 0.2, 0.9);\n        break;\n    }\n    default:\n        return vec3(0.0);\n        break;\n    }\n\n    return vec3(1.0);\n}\n\nvec3 computeNormal(vec3 pos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize(vec3(sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                          sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                          sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nfloat hardShadow(vec3 dir, vec3 origin, float min_t)\n{\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        float m = sceneMap3D(origin + t * dir);\n        if(m < 0.0001) \n        {\n            return 0.0;\n        }\n        t += m;\n    }\n    \n    return 1.0;\n}\n\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float k) \n{\n    float res = 1.0;\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i) \n    {\n        float m = sceneMap3D(origin + t * dir);\n        if(m < 0.0001) \n        {\n            return 0.0;\n        }\n        \n        res = min(res, k * m / t);\n        t += m;\n    }\n    \n    return res;\n}\n\nfloat shadow(vec3 dir, vec3 origin, float min_t) \n{\n    #if HARD_SHADOW\n    return hardShadow(dir, origin, min_t);\n    #else\n    return softShadow(dir, origin, min_t, SHADOW_HARDNESS);\n    #endif\n}\n\n\nIntersection sdf3D(vec3 dir, vec3 eye)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect);\n    \n    vec3 material = computeMaterial(hitObj, isect, nor);\n    \n    vec3 warmDir = rotateY(normalize(vec3(1.0, 1.0, 1.0)), sin(iTime * 0.5));\n    vec3 coolDir = rotateY(normalize(vec3(-1.0, 0.0, -1.0)), sin(iTime * 0.5));\n\n    float warmDot = max(0.0, dot(nor, warmDir));\n    float coolDot = max(0.0, dot(nor, coolDir));\n\n    vec3 overallColor = warmDot * vec3(1.0, 0.88, 0.7) * shadow(warmDir, isect, 0.1);\n    overallColor += coolDot * vec3(0.05, 0.2, 0.5);\n    overallColor *= material;\n    overallColor = clamp(overallColor + vec3(0.05, 0.1, 0.15), 0.0, 1.0);\n    \n    vec3 sdfColor = overallColor;\n    \n    return Intersection(t, sdfColor, isect, hitObj);\n}\n\nvoid raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref)\n{\n    eye = EYE_POS;\n    ref = REF_POS;\n    \n    float len = tan(3.14159 * 0.125) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * float(iResolution.x) / float(iResolution.y);\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n\n    vec3 dir, eye, ref;\n    raycast(uv2, dir, eye, ref);\n    Intersection intersection = sdf3D(dir, eye);\n\n    // Output to screen    \n    fragColor = vec4(intersection.color * step(0.0, intersection.t), 1.0);\n    float fogT = smoothstep(30.0, 50.0, distance(intersection.p, eye));\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.0), fogT);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsBRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[835, 835, 864, 890, 922], [924, 951, 978, 978, 1019], [1022, 1022, 1061, 1061, 1094], [1096, 1096, 1125, 1125, 1199], [1201, 1201, 1233, 1233, 1316], [1318, 1318, 1352, 1352, 1430], [1433, 1433, 1488, 1501, 1943], [1945, 1945, 1973, 1973, 2212], [2214, 2214, 2277, 2277, 2542], [2544, 2544, 2593, 2593, 3094], [3096, 3096, 3126, 3126, 3439], [3441, 3441, 3495, 3495, 3722], [3724, 3724, 3788, 3788, 4081], [4083, 4083, 4134, 4134, 4280], [4283, 4283, 4323, 4323, 5120], [5122, 5122, 5187, 5187, 5543], [5546, 5546, 5603, 5653, 6087]], "test": "untested"}
{"id": "3dsBzn", "name": "Subsurface Scattering Approximat", "author": "giaosame", "description": "Implement the approximation of subsurface scattering, refer to the code from https://www.shadertoy.com/view/wdSGWK.", "tags": ["3d"], "likes": 0, "viewed": 339, "published": 3, "date": "1587603902", "time_retrieved": "2024-07-30T21:11:01.893050", "image_code": "const vec4 FLOOR_VEC       = vec4(0.0, 1.0, 0.0, 3.0);\nconst vec3 LONG_BOX_POS    = vec3(2.1, -0.5, -2);\nconst vec3 LONG_BOX_SCALE  = vec3(1.5, 3.0, 1.5);\nconst vec3 SPHERE_POS      = vec3(2.2, -1.0, 1.7);\nconst vec3 TORUS_POS       = vec3(0.5, 2.0, 1);\nconst vec2 TORUS_RADIUS    = vec2(1.0, 0.45);\n\nconst vec3 EYE_POS         = vec3(0.0, 2.5, -14.5);\nconst vec3 REF_POS         = vec3(0.0, 2.5, 0.0);\nconst vec3 LIGHT_COL       = vec3(1.0, 0.9, 0.72);\n\nconst int RAY_STEPS     = 256;\nconst int FLOOR_ID      = 0;\nconst int LONG_BOX_ID   = 1;\nconst int SPHERE_ID     = 2;\nconst int LIGHT_ID      = 3;\nconst int TORUS_ID      = 4;\nconst float PI_OVER_180 = 3.1415926 / 180.0;\n\n// Adjust these to alter where the subsurface glow shines through and how brightly\nconst float FIVETAP_K = 2.0;\nconst float AO_DIST = 0.085;\n\n// The larger the DISTORTION, the smaller the glow\nconst float DISTORTION = 0.2;\n// The higher GLOW is, the smaller the glow of the subsurface scattering\nconst float GLOW = 6.0;\n// The higher the BSSRDF_SCALE, the brighter the scattered light\nconst float BSSRDF_SCALE = 3.0;\n// Boost the shadowed areas in the subsurface glow with this\nconst float AMBIENT = 0.0;\n// Toggle this to affect how easily the subsurface glow propagates through an object\n#define ATTENUATION 0\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n\nfloat plane(vec3 p, vec4 n)\n{\n  // n must be normalized\n  return dot(p, n.xyz) + n.w;\n}\n\n// Box with side lengths b\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\n\nfloat sphere(vec3 p, float r, vec3 c)\n{\n    return distance(p, c) - r;\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nvec3 rotateY(vec3 p, float a) \n{\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvec3 rotateX(vec3 p, float amt) \n{\n    return vec3(p.x, cos(amt) * p.y - sin(amt) * p.z, sin(p.y) + cos(p.z));\n}\n\n// from https://www.shadertoy.com/view/wdSGWK\nfloat shadowMap3D(vec3 pos)\n{\n    float t = plane(pos, FLOOR_VEC);\n    t = min(t, box(rotateY(pos + LONG_BOX_POS, 27.5 * PI_OVER_180), LONG_BOX_SCALE));\n    t = min(t, sphere(pos, 2.0, SPHERE_POS));\n    t = min(t, torus(pos + TORUS_POS, TORUS_RADIUS));\n    return t;\n}\n\n// from https://www.shadertoy.com/view/wdSGWK\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float k) \n{\n    float res = 1.0;\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i) \n    {\n        float m = shadowMap3D(origin + t * dir);\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\n// from https://www.shadertoy.com/view/wdSGWK\nfloat shadow(vec3 dir, vec3 origin, float min_t)\n{\n    return softShadow(dir, origin, min_t, 24.0);\n}\n\nfloat fiveTapAO(vec3 p, vec3 n, float k) \n{\n    float aoSum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i)\n    {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * AO_DIST - shadowMap3D(p + n * i * AO_DIST));\n    }\n    \n    return 1.0 - k * aoSum;\n}\n\n// from https://www.shadertoy.com/view/wdSGWK\nfloat subsurface(vec3 lightDir, vec3 normal, vec3 viewVec, float thickness)\n{\n    vec3 scatteredLightDir = lightDir + normal * DISTORTION;\n    float lightReachingEye = pow(clamp(dot(viewVec, -scatteredLightDir), 0.0, 1.0), GLOW) * BSSRDF_SCALE;\n    float attenuation = 1.0;\n    #if ATTENUATION\n    attenuation = max(0.0, dot(normal, lightDir) + dot(viewVec, -lightDir));\n    #endif\n\tfloat totalLight = attenuation * (lightReachingEye + AMBIENT) * thickness;\n    return totalLight;\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int objId, vec3 lightPos)\n{\n    // floor\n    t = plane(pos, FLOOR_VEC);  \n    objId = FLOOR_ID;  \n\n    float t2;\n    if((t2 = box(rotateY(pos + LONG_BOX_POS, 27.5 * PI_OVER_180), LONG_BOX_SCALE)) < t)  // long bix\n    {\n        t= t2;\n        objId = LONG_BOX_ID;\n    }\n    if((t2 = sphere(pos, 2.0, SPHERE_POS)) < t)\n    {\n        t= t2;\n        objId = SPHERE_ID;\n    }\n    if((t2 = sphere(pos, 1.0, lightPos)) < t)\n    {\n        t= t2;\n        objId = LIGHT_ID;\n    }\n    if((t2 = torus(pos + TORUS_POS, TORUS_RADIUS)) < t)\n    {\n        t= t2;\n        objId = TORUS_ID;\n    }\n}\n\nfloat sceneMap3D(vec3 pos, vec3 lightPos)\n{\n    float t = plane(pos, FLOOR_VEC);\n    t = min(t, box(rotateY(pos + LONG_BOX_POS, 27.5 * PI_OVER_180), LONG_BOX_SCALE));\n    t = min(t, sphere(pos, 2.0, SPHERE_POS));\n    t = min(t, sphere(pos, 1.0, lightPos));\n    t = min(t, torus(pos + TORUS_POS, TORUS_RADIUS));\n    return t;\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int objId, vec3 lightPos)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n        float m;\n        sceneMap3D(pos, m, objId, lightPos);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n\n    t = -1.0;\n    objId = -1;\n}\n\nvec3 computeMaterial(int objId, vec3 p, vec3 n, vec3 light, vec3 view, float thick)\n{\n    switch(objId) \n    {\n    case FLOOR_ID:  // floor\n    {\n        return vec3(1.0, 0.95, 0.85) * shadow(light, p, 0.1);\n        break;\n    }\n    case LONG_BOX_ID:  // Cuboid, the long box\n    {\n        vec3 longBoxCol = vec3(1.0, 0.4, 0.0);\n        vec3 color = LIGHT_COL * longBoxCol * max(0.0, dot(n, light)) * shadow(light, p, 0.1);\n        return color + longBoxCol * subsurface(light, n, view, thick) * LIGHT_COL;\n        break;\n    }\n    case SPHERE_ID:  // Cube, the short box\n    {\n        vec3 sphereCol = vec3(0.0, 1.0, 1.0);\n        vec3 color = LIGHT_COL * sphereCol * max(0.0, dot(n, light)) * shadow(light, p, 0.1);\n        return color + sphereCol * subsurface(light, n, view, thick) * LIGHT_COL;\n        break;\n    }\n    case LIGHT_ID:  // Light\n    {\n        return LIGHT_COL;\n        break;\n    }   \n    case TORUS_ID:  // Torus\n    {\n        vec3 torusCol = vec3(0.9, 0.2, 0.9);\n        vec3 color = LIGHT_COL * torusCol * max(0.0, dot(n, light)) * shadow(light, p, 0.1);\n        return color + torusCol * subsurface(light, n, view, thick) * LIGHT_COL;\n        break;\n    }\n    default:\n        return vec3(0.0);\n        break;\n    }\n\n    return vec3(1.0);\n}\n\nvec3 computeNormal(vec3 pos, vec3 lightPos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize(vec3(sceneMap3D(pos + epsilon.yxx, lightPos) - sceneMap3D(pos - epsilon.yxx, lightPos),\n                          sceneMap3D(pos + epsilon.xyx, lightPos) - sceneMap3D(pos - epsilon.xyx, lightPos),\n                          sceneMap3D(pos + epsilon.xxy, lightPos) - sceneMap3D(pos - epsilon.xxy, lightPos)));\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye, vec3 lightPos)\n{\t\n    float t;\n    int hitObj;\n    \n    march(eye, dir, t, hitObj, lightPos);\n    \n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect, lightPos);\n    vec3 lightDir = normalize(lightPos - isect);\n    float thickness = fiveTapAO(isect, -nor, FIVETAP_K);\n    \n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect), thickness);\n    return Intersection(t, surfaceColor, isect, hitObj);\n}\n\nvoid raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref)\n{\n    eye = EYE_POS;\n    ref = REF_POS;\n    \n    float len = tan(3.14159 * 0.125) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * float(iResolution.x) / float(iResolution.y);\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 lightPos = rotateY(vec3(0, 5.0, -5.0), sin(iTime / 150.0) * 180.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n\n    vec3 dir, eye, ref;\n    raycast(uv2, dir, eye, ref);\n    Intersection intersection = sdf3D(dir, eye, lightPos);\n\n    // Output to screen\n    fragColor = vec4(intersection.color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsBzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1373, 1373, 1402, 1428, 1460], [1462, 1489, 1516, 1516, 1557], [1560, 1560, 1599, 1599, 1632], [1634, 1634, 1663, 1663, 1737], [1739, 1739, 1771, 1771, 1854], [1856, 1856, 1890, 1890, 1968], [1970, 2016, 2045, 2045, 2284], [2286, 2332, 2396, 2396, 2667], [2669, 2715, 2765, 2765, 2816], [2818, 2818, 2861, 2861, 3084], [3086, 3132, 3209, 3209, 3614], [3616, 3616, 3686, 3699, 4240], [4242, 4242, 4285, 4285, 4568], [4570, 4570, 4648, 4648, 4923], [4925, 4925, 5010, 5010, 6190], [6192, 6192, 6237, 6237, 6610], [6612, 6612, 6667, 6667, 7104], [7106, 7106, 7171, 7171, 7527], [7530, 7530, 7587, 7587, 7998]], "test": "untested"}
{"id": "wsXfRr", "name": "Further Up the River", "author": "mla", "description": "Trying to understand sl2c's very interesting Up the River shader: [url]https://www.shadertoy.com/view/Wd2yzd[/url]\n\nBackground, by John Conway: [url]https://www.maths.ed.ac.uk/~v1ranick/papers/conwaysens.pdf[/url]", "tags": ["tiling", "quadratic", "conway", "hyperbolic"], "likes": 6, "viewed": 365, "published": 3, "date": "1587595616", "time_retrieved": "2024-07-30T21:11:02.727818", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Further Up the River, Matthew Arcus, mla, 2020.\n// Derived from https://www.shadertoy.com/view/Wd2yzd by sl2c\n//\n// Shows the (2,3,infinity) hyperbolic tiling, with a hyperbolic\n// translation preserving the fixed points of a Mobius transform\n// (+-1/sqrt(2) in fact). Apeirogon borders are shown forming a\n// \"river\" with tributaries (as described below).\n//\n// Controls:\n// b: unshifted map as background\n// f: highlight fixed points\n// h: halfplane\n// r: highlight river\n// t: tiling\n// \n// Shader shows the (2,3,infinity) tiling of the hyperbolic plane, either\n// the disc or halfplane model. This tiling divides the plane up into\n// an infinite number of apeirogons - infinite sided polyhedra - which\n// touch the real line at rational points, in the halfplane\n// model. Define an integral (real) Mobius transformation, T(x) =\n// (ax+b)/(cx+d), lift this to work on the whole complex plane,\n// preserving the real axis (or unit circle). Generally T \n// has two fixed points (solve the quadratic) which divide the real\n// line in two parts, with T(x)-x < 0 in one part, T(x)-x > 0 in the\n// other part. If x is rational, we can expand T(x)-x = T(p/q)-p/q to\n// get a binary quadratic form (substitute p/q for x and expand): Ap^2\n// + Bpq + Cq^2, which takes values < 0 in one of those parts, and > 0\n// in the other part, so we can divide the apeirogons of the tiling\n// into two sets, depending on the quadratic form's value at the point\n// the apeirogon touches the real line, so the River of the title is\n// the line that divides these sets, and in fact has a periodic\n// structure.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// Original copyright header:\n////////////////////////////////////////////////////////////////////////////////\n// Copyright 2020 Google LLC\n// SPDX-License-Identifier: Apache-2.0\n// NOT an official Google project; see Google Open Source guidelines for more info on copyright transfer\n// written by William Cadegan-Schlieper \n////////////////////////////////////////////////////////////////////////////////\n\nfloat PI = 3.1415927;\n\n// Keep track of scaling factor\nvoid invert(inout vec2 z, inout float ds) {\n  float k = 1.0/dot(z,z);\n  z *= k;\n  ds *= k;\n}\n\nvoid invert(inout vec2 z, float r2, inout float ds) {\n  float k = r2/dot(z,z);\n  z *= k;\n  ds *= k;\n}\n\n// (a,b,c,d) => (a,a+b,c,c+d);\nmat2 L = mat2(1,1,0,1); // {b+=a; d+=c;}\nmat2 R = mat2(1,0,1,1); // {a+=b; c+=d;}\n\nbool alert = false;\n\nvec2 color(vec2 z, float ds) {\n  bool parity = false;\n  for(int i = 0; i < 60; i++) {\n    z.x = fract(z.x); // Unit grid\n    if (z.x > 0.5) {\n      z.x = 1.0-z.x; // Reflected\n      parity = !parity;\n    }\n    if (dot(z,z) >= 1.0) break;\n    // Unit circle inversion\n    invert(z,ds);\n    parity = !parity;\n  }\n  // ds = scale factor = pixel width (more or less)\n  float c = 0.0;\n  float d = min(z.x,0.5-z.x);\n  // d = |z|-1 = sqrt(z.z) - 1 = 0.5*z.z - 1 (approx)\n  float d1 = 0.5*(dot(z,z) - 1.0);\n  d = min(d,d1);\n  if (d < ds) {\n    c = 0.5 - 0.5*d/ds;\n  }\n  //c = min(max(c,2.0*ds),0.5); // Grey out highly magnified areas\n  if (parity) c = 1.0 - c;\n  return vec2(c,d1);\n}\n\nbool key(int code) {\n  return texelFetch(iChannel3, ivec2(code,2),0).x != 0.0;\n}\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_F = 70;\nconst int CHAR_H = 72;\nconst int CHAR_J = 74;\nconst int CHAR_L = 76;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_Z = 90;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 z = 2.0 * (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n  float ds = 1.0/iResolution.y;\n    \n  vec3 col;\n  float r2 = dot(z,z);\n  bool halfplane = key(CHAR_H);\n  if (halfplane || r2 < 1.0) {\n    // Map to halfplane,\n    if (halfplane) {\n      z.y += 1.0;\n    } else {\n      z.y = -z.y;\n      z.y -= 1.0;\n      invert(z,2.0,ds);\n      z.y += 1.0;\n    }\n    // Construct our Mobius transform starting from the identity.\n    mat2 T = mat2(1,0,0,1);\n    // L and R preserve det(T) = 1. Stern-Brocot connection here.\n    T = L*R*R*L*T; // (3,2,4,3)\n#if 0\n    if (a+d<=2) {\n      // treat null rotations specially\n      if (c>0) {\n        z.x += 0.5;\n      } else {\n        z.x = 0.5 - z.x;\n      }\n      invert(z,ds);\n      z.x -= 0.1 * iTime;\n      vec2 cdata = color(z,ds);\n      fragColor = vec4(cdata.x,1.0);  // gamma correction suggested by FabriceNeyret2\n      fragColor = pow(fragColor, vec4(1./2.2));\n      return;\n    }\n#endif\n    // Fixed points are (a-d +- sqrt(disc))/(2c)\n    // Note that ad-bc = 1, so we get a simple form for the discriminant.\n    float a = T[0].x, b = T[1].x, c = T[0].y, d = T[1].y;\n    float disc = sqrt((a+d)*(a+d)-4.0);\n    float fixed0 = (a-d+disc) / (2.0*c); // Map to 0\n    float fixed1 = (a-d-disc) / (2.0*c); // Map to infinity\n    float inverse_diff = float(c) / disc; \n    float period = 2.0*log(0.5*(a+d+disc)); // Period - where does this come from?\n\n    vec2 z0 = z;\n    float k = 1.0;\n    if (!key(CHAR_B)) k *= 0.8+0.2*color(z,ds).x; // Show unshifted map\n\n    // Conjugate dilation with map of fixed points to (0,inf).\n    z.x -= fixed0;\n    invert(z,ds);\n    z.x += inverse_diff;\n\n    float t = 0.5*iTime;\n    t = mod(t,period);\n    z *= exp(t); ds *= exp(t);\n\n    z.x -= inverse_diff;\n    invert(z,ds);\n    z.x += fixed0;\n\n    vec2 cdata = color(z,ds);\n    k *= 0.3+0.7*cdata.x;\n    col = vec3(1);\n    if (!key(CHAR_T)) col *= k;\n    if (!key(CHAR_R)) col = mix(vec3(1,0,0),col,smoothstep(-0.05,+0.05,cdata.y));\n    if (!key(CHAR_F)) {\n      float d = distance(z0,vec2(fixed0,0));\n      d = min(d,distance(z0,vec2(fixed1,0)));\n      col = mix(vec3(1,0,0),col,smoothstep(0.0,0.05,d));\n    }\n  } else {\n    col = vec3(1,1,0.75);\n  }\n  if (alert) col.r = 1.0;\n  fragColor = vec4(pow(col, vec3(0.4545)),1);  // gamma correction suggested by FabriceNeyret2\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXfRr.jpg", "access": "api", "license": "apache-2.0", "functions": [[2192, 2224, 2267, 2267, 2316], [2318, 2318, 2371, 2371, 2419], [2556, 2556, 2586, 2586, 3232], [3234, 3234, 3254, 3254, 3314], [3738, 3738, 3790, 3790, 6103]], "test": "untested"}
{"id": "wdfBzr", "name": "Noise and UV Mapping Practice", "author": "giaosame", "description": "Use noise functions to generate height fields and textures, based on the built Cornell Box scene: https://www.shadertoy.com/view/tdXfzn", "tags": ["3d"], "likes": 1, "viewed": 292, "published": 3, "date": "1587595334", "time_retrieved": "2024-07-30T21:11:03.648356", "image_code": "const vec4 FLOOR_VEC       = vec4(0.0, 1.0, 0.0, 2.5);\nconst vec4 LEFT_WALL_VEC   = vec4(1.0, 0.0, 0.0, 5.0);\nconst vec4 RIGHT_WALL_VEC  = vec4(-1.0, 0.0, 0.0, 5.0);\nconst vec4 BACK_WALL_VEC   = vec4(0.0, 0.0, -1.0, 5.0);\nconst vec4 CEILING_VEC     = vec4(0.0, -1.0, 0.0, 7.5);\nconst vec3 LONG_BOX_POS    = vec3(2.1, -0.5, -2);\nconst vec3 LONG_BOX_SCALE  = vec3(1.5, 3.0, 1.5);\nconst vec3 SPHERE_POS   = vec3(2.0, -1.0, -0.25);\n\nconst vec3 EYE_POS         = vec3(0.0, 5, -18.0);\nconst vec3 REF_POS         = vec3(0.0, 2.5, 0.0);\n\nconst int RAY_STEPS     = 256;\nconst int FLOOR_ID      = 0;\nconst int LEFT_WALL_ID  = 1;\nconst int RIGHT_WALL_ID = 2;\nconst int BACK_WALL_ID  = 3;\nconst int CEILING_ID    = 4;\nconst int LONG_BOX_ID   = 5;\nconst int SPHERE_ID  = 6;\nconst float PI_OVER_180 = 3.1415926 / 180.0;\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n\nfloat plane(vec3 p, vec4 n)\n{\n  // n must be normalized\n  return dot(p, n.xyz) + n.w;\n}\n\n// Box with side lengths b\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\n\nfloat sphere(vec3 p, float r, vec3 c)\n{\n    return distance(p, c) - r;\n}\n\nvec3 rotateY(vec3 p, float a) \n{\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvec3 rotateX(vec3 p, float amt) \n{\n    return vec3(p.x, cos(amt) * p.y - sin(amt) * p.z, sin(p.y) + cos(p.z));\n}\n\nvec2 sphereUV(vec3 center, float r, vec3 p)\n{\n    vec3 pDir = normalize(p - center);\n    vec3 worldUp = vec3(0.0, 1.0, 0.0);\n    float theta = acos(dot(pDir, worldUp));\n    \n    // If p is located at the positive part of z axis, then phi is 0-180.\n    // If p is located at the negative part of z axis, then phi is 180-360.\n    vec3 xzDir = normalize(vec3(pDir.x, 0.0, pDir.z));\n    float phi = acos(dot(xzDir, vec3(1.0, 0.0, 0.0)));\n    \n    if(pDir.z < 0.0)\n    {\n        phi = phi + 3.14159;\n    }\n    \n    return vec2(theta / 3.14159, phi / (2.0 * 3.14159));\n}\n\nvoid planeUVAxis(in vec3 p, in vec3 n, out vec3 u, out vec3 v)\n{\n    vec3 worldUp = vec3(0.0, 1.0, 0.0);\n    u = normalize(cross(worldUp, n));\n    v = normalize(cross(n, u));\n}\n\nvec2 planeUV(vec3 origin, vec3 n, vec3 p)\n{\n    vec3 uAxis;\n    vec3 vAxis;\n    planeUVAxis(origin, n, uAxis, vAxis);\n    \n    vec3 diff = p - origin;\n    float uVal = dot(diff, uAxis);\n    float vVal = dot(diff, vAxis);\n    \n    return vec2(uVal, vVal);\n}\n\nfloat hash(float x)\n{\n    return fract(sin(x * 97.79) * 653.767);\n}\n\nvec2 hash2(vec2 p)\n{\n    return vec2(hash(p.x * 27.79 - 300.0 + p.y * 34.35), hash(p.x * 56.3 + 256.0 + p.y * 89.37));\n}\n\n// Modify color to the burning fire color\nvec3 cosinePalette2(float t)\n{\n    const vec3 a = vec3(0.5, 0.5, 0.5);\n\tconst vec3 b = vec3(0.5, 0.5, 0.5);\n\tconst vec3 c = vec3(1.0, 1.0, 1.0);\n\tconst vec3 d = vec3(0.0, 0.33, 0.67);\n    return clamp(a + b * cos(2.0 * 3.14159 * (c * t + d)), 0.0, 1.0);\n}\n\nvec3 cosinePalette(float t)\n{\n    const vec3 a = vec3(0.5, 0.5, 0.4);\n\tconst vec3 b = vec3(0.5, 0.5, 0.43);\n\tconst vec3 c = vec3(0.46, 0.57, 0.4);\n\tconst vec3 d = vec3(0.63, 0.4233, -1.573);\n    return clamp(a + b * cos(2.0 * 3.14159 * (c * t + d)), 0.0, 1.0);\n}\n\nfloat random1(vec3 p) \n{\n    return fract(sin(dot(p, vec3(127.1, 311.7, 191.999))) * 43758.5453);\n}\n\nfloat random1(vec2 p)\n{\n  \treturn fract(sin(dot(p, vec2(456.789, 20487145.123))) * 842478.5453);\n}\n\nvec2 random2(vec2 p)\n{\n    return fract(sin(vec2(dot(p, vec2(271.11, 717.7)),\n                          dot(p, vec2(692.5, 83.31))))\n                 * 35789.537);\n}\n\nvec3 random3( vec3 p )\n{\n    return fract(sin(vec3(dot(p,vec3(127.1, 311.7, 191.999)),\n                          dot(p,vec3(269.5, 183.3, 765.54)),\n                          dot(p, vec3(420.69, 631.2,109.21))))\n                 *43758.5453);\n}\n\n// Worley-noise function to make the Mario twisted and warped\nfloat worley(float x, float y, float multiple)\n{\n    vec2 uv = vec2(x, y);\n    uv *= multiple;\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n\n    float minDist = 1.0;\n    for(int y = -1; y <= 1; ++y)\n    {\n        for(int x = -1; x <= 1; ++x)\n        {\n            vec2 neighbor = vec2(float(x), float(y));\n            vec2 point = (vec2(1.0) + cos(random2(uvInt + neighbor) * 7.987 + iTime / 180.0)) / 2.0;\n            vec2 diff = neighbor + point - uvFract;\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist / multiple;\n}\n\n// Worley-noise function to generate the burning fire effect\nfloat worleyFire1(vec2 c, float time)\n{\n    float dis = 1.0;\n    for(int x = -1; x <= 1; x++)\n    {\n        for(int y = -1; y <= 1; y++)\n        {\n            vec2 p = floor(c) + vec2(x, y);\n            vec2 a = hash2(p) * time;\n            vec2 rnd = 0.5 + sin(a) * 0.5;\n            float d = length(rnd + vec2(x, y) - fract(c));\n            dis = min(dis, d);\n        }\n    }\n\n    return dis;\n}\n\n// Worley-noise function to generate the burning fire effect\nfloat worleyFire2(vec2 c, float time)\n{\n    float w = 0.0;\n    float a = 0.5;\n    for (int i = 0; i<5; i++)\n    {\n        w += worleyFire1(c, time) * a;\n        c *= 2.0;\n        time *= 2.0;\n        a *= 0.5;\n    }\n    return w;\n}\n\n// from https://www.shadertoy.com/view/3sjGz3\nfloat mySmootherStep(float a, float b, float t)\n{\n  \tt = t * t * t * (t * (t * 6.18 - 18.0) + 12.0);\n  \treturn mix(a, b, t);\n}\n\n// from https://www.shadertoy.com/view/3sjGz3\nfloat interpNoise2D(vec2 uv) \n{\n    vec2 uvFract = fract(uv);\n    float ll = random1(floor(uv));\n    float lr = random1(floor(uv) + vec2(1,0));\n    float ul = random1(floor(uv) + vec2(0,1));\n    float ur = random1(floor(uv) + vec2(1,1));\n\n    float lerpXL = mySmootherStep(ll, lr, uvFract.x);\n    float lerpXU = mySmootherStep(ul, ur, uvFract.x);\n\n    return mySmootherStep(lerpXL, lerpXU, uvFract.y);\n}\n\nfloat fbm(vec2 uv) \n{\n    float amp = 0.5;\n    float freq = 8.0;\n    float sum = 0.0;\n    for(int i = 0; i < 4; i++) \n    {\n        sum += interpNoise2D(uv * freq) * amp;\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    \n    return sum;\n}\n\nfloat surflet3D(vec3 p, vec3 gridPoint)\n{\n    vec3 t3 = abs(p - gridPoint);\n    \n    float tX = 1.f - 6.f * pow(t3.x, 5.f) - 15.f * pow(t3.x, 4.f) + 10.f * pow(t3.x, 3.f);\n    float tY = 1.f - 6.f * pow(t3.y, 5.f) - 15.f * pow(t3.y, 4.f) + 10.f * pow(t3.y, 3.f);\n    float tZ = 1.f - 6.f * pow(t3.z, 5.f) - 15.f * pow(t3.z, 4.f) + 10.f * pow(t3.z, 3.f);\n    \n    vec3 t = vec3(tX, tY, tZ);\n    \n    vec3 gradient = random3(gridPoint);\n    vec3 diff = p - gridPoint;\n    float height = dot(diff, gradient);\n    return height * t.x * t.y * t.z;\n}\n\nfloat PerlinNoise3D(vec3 p)\n{\n    float surfletSum = 0.0;\n    vec3 pXLYLZL = floor(p);\n    \n    for(int dx = 0; dx <= 1; ++dx)\n    {\n        for(int dy = 0; dy <= 1; ++dy)\n        {\n            for(int dz = 0; dz <= 1; ++dz)\n            {\n                surfletSum += surflet3D(p, pXLYLZL + vec3(dx, dy, dz));\n            }\n        }\n    }\n    \n    return surfletSum;\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int objId, vec3 lightPos)\n{\n    // floor\n    t = plane(pos, FLOOR_VEC);  \n    objId = FLOOR_ID;  \n\n    float t2;\n    if((t2 = plane(pos, LEFT_WALL_VEC)) < t)  \n    {\n        t= t2;\n        objId = LEFT_WALL_ID;\n    } \n    if((t2 = plane(pos, RIGHT_WALL_VEC)) < t)  \n    {\n        t= t2;\n        objId = RIGHT_WALL_ID;\n    }\n    if((t2 = plane(pos, BACK_WALL_VEC)) < t)\n    {\n        t= t2;\n        objId = BACK_WALL_ID;\n    }\n    if((t2 = plane(pos, CEILING_VEC)) < t)\n    {\n        t= t2;\n        objId = CEILING_ID;\n    }\n    if((t2 = box(rotateY(pos + LONG_BOX_POS, 27.5 * PI_OVER_180), LONG_BOX_SCALE)) < t)  // long bix\n    {\n        t= t2;\n        objId = LONG_BOX_ID;\n    }\n    if((t2 = sphere(pos, 1.5, SPHERE_POS)) < t)\n    {\n        t= t2;\n        objId = SPHERE_ID;\n    }\n}\n\nfloat sceneMap3D(vec3 pos, vec3 lightPos)\n{\n    float t = plane(pos, FLOOR_VEC);\n    t = min(t, plane(pos, LEFT_WALL_VEC));\n    t = min(t, plane(pos, RIGHT_WALL_VEC));\n    t = min(t, plane(pos, BACK_WALL_VEC));\n    t = min(t, plane(pos, CEILING_VEC));\n    t = min(t, box(rotateY(pos + LONG_BOX_POS, 27.5 * PI_OVER_180), LONG_BOX_SCALE));\n    t = min(t, sphere(pos, 1.5, SPHERE_POS));\n    return t;\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int objId, vec3 lightPos)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n        float m;\n        sceneMap3D(pos, m, objId, lightPos);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n\n    t = -1.0;\n    objId = -1;\n}\n\nvec3 computeMaterial(int objId, vec3 p, vec3 n, vec3 light, vec3 view)\n{\n    float lambert = dot(light, n);\n\n    switch(objId) \n    {\n    case FLOOR_ID:  // floor\n        return vec3(1.0, 1.0, 1.0) * lambert;\n        break;\n    case LEFT_WALL_ID:  // Left wall, which is a large red plane\n        return vec3(0.63, 0.065, 0.05) * lambert;\n        break;\n    case RIGHT_WALL_ID:  // Right wall, which is a large green plane\n        return vec3(0.14, 0.45, 0.091) * lambert;\n        break;\n    case BACK_WALL_ID:  // Back wall, which is a large white plane\n    {\n        vec3 normal = vec3(0.0, 0.0, 1.0);\n        vec2 backUV = planeUV(normal * 5.0, normal, p);\n        \n        float m = 5.0;\n    \tfloat x = backUV.x;\n    \tfloat y = backUV.y;\n        vec2 gradient = vec2(0.0);\n        float delta = 1.0;\n    \tgradient.x = worley(x + delta, y, m) - worley(x - delta, y, m);\n    \tgradient.y = worley(x, y + delta, m) - worley(x, y - delta, m);\n        \n        backUV += gradient;\n        float r = 0.48;\n        float dis = worleyFire2(backUV * iResolution.xy / 160.0, iTime * 5.0);\n        vec3 fire = mix(vec3(1.0, 0.95, 0.5), vec3(0.8, 0.0, 0.0), dis);\n           \n        vec3 color = cosinePalette(r) * 0.618 + fire * 0.75;\n        return color * lambert;\n        break;\n    }\n    case CEILING_ID:  // Ceiling, which is a large white plane\n        return vec3(1.0, 1.0, 1.0) * lambert;\n        break;\n    case LONG_BOX_ID:  // Cuboid, the long box\n    {\n        vec3 noisePos = vec3(p.x + sin(iTime), p.y + cos(iTime), p.z + cos(iTime));\n        float perlin = PerlinNoise3D(noisePos);\n        return 1.8 * cosinePalette(perlin) * lambert;\n        break;\n    }\n    case SPHERE_ID:  // Sphere\n    {\n        vec2 sphereUV = sphereUV(vec3(2.0, 0.0, 1.0), 1.0, p);        \n        sphereUV.x = (sphereUV.x + cos(iTime * 0.5) + 4.25) / 2.97;\n        sphereUV.y = (sphereUV.y + sin(iTime * 0.14) + 1.25) / 1.48;      \n        \n        float fbmCol = fbm(sphereUV);\n        vec3 color = cosinePalette2(fbmCol) * 1.2 + vec3(0.12);\n        return color * lambert;\n        break;\n    }        \n    default:\n        return vec3(0.0);\n        break;\n    }\n\n    return vec3(1.0);\n}\n\nvec3 computeNormal(vec3 pos, vec3 lightPos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize(vec3(sceneMap3D(pos + epsilon.yxx, lightPos) - sceneMap3D(pos - epsilon.yxx, lightPos),\n                          sceneMap3D(pos + epsilon.xyx, lightPos) - sceneMap3D(pos - epsilon.xyx, lightPos),\n                          sceneMap3D(pos + epsilon.xxy, lightPos) - sceneMap3D(pos - epsilon.xxy, lightPos)));\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye, vec3 lightPos)\n{\n    float t;\n    int objId;\n    march(eye, dir, t, objId, lightPos);\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect, lightPos);\n    vec3 lightDir = normalize(lightPos - isect);\n    \n    vec3 surfaceColor = computeMaterial(objId, isect, nor, lightDir, normalize(eye - isect));\n    \n    return Intersection(t, surfaceColor, isect, objId);\n}\n\nvoid raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref)\n{\n    eye = EYE_POS;\n    ref = REF_POS;\n    \n    float len = tan(3.14159 * 0.125) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * float(iResolution.x) / float(iResolution.y);\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 lightPos = vec3(0.0, 7.3, -1.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n\n    vec3 dir, eye, ref;\n    raycast(uv2, dir, eye, ref);\n    Intersection intersection = sdf3D(dir, eye, lightPos);\n\n    // Output to screen\n    fragColor = vec4(intersection.color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfBzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[890, 890, 919, 945, 977], [979, 1006, 1033, 1033, 1074], [1077, 1077, 1116, 1116, 1149], [1151, 1151, 1183, 1183, 1266], [1268, 1268, 1302, 1302, 1380], [1382, 1382, 1427, 1427, 1946], [1948, 1948, 2012, 2012, 2124], [2126, 2126, 2169, 2169, 2382], [2384, 2384, 2405, 2405, 2451], [2453, 2453, 2473, 2473, 2573], [2575, 2617, 2647, 2647, 2872], [2874, 2874, 2903, 2903, 3136], [3138, 3138, 3162, 3162, 3237], [3239, 3239, 3262, 3262, 3337], [3339, 3339, 3361, 3361, 3504], [3506, 3506, 3530, 3530, 3749], [3751, 3813, 3861, 3861, 4414], [4416, 4477, 4516, 4516, 4873], [4875, 4936, 4975, 4975, 5167], [5169, 5215, 5264, 5264, 5341], [5343, 5389, 5420, 5420, 5792], [5794, 5794, 5815, 5815, 6034], [6036, 6036, 6077, 6077, 6580], [6582, 6582, 6611, 6611, 6952], [6954, 6954, 7024, 7037, 7781], [7783, 7783, 7826, 7826, 8182], [8184, 8184, 8262, 8262, 8537], [8539, 8539, 8611, 8611, 10711], [10713, 10713, 10758, 10758, 11131], [11133, 11133, 11188, 11188, 11548], [11550, 11550, 11615, 11615, 11971], [11974, 11974, 12031, 12031, 12407]], "test": "untested"}
{"id": "tsXfRr", "name": "Cornell Box Ambient Occlusion", "author": "giaosame", "description": "Use the \"five-tap\" ambient occlusion approximation formula to fake the blocking of light that objects that are close together apply to one another, based on the scene: https://www.shadertoy.com/view/tdXfzn", "tags": ["3d"], "likes": 0, "viewed": 283, "published": 3, "date": "1587593526", "time_retrieved": "2024-07-30T21:11:04.398351", "image_code": "const int AO_SAMPLES = 256;\nconst float AO_DIST = 0.15;\nconst float FIVETAP_K = 2.0;\n\nconst vec4 FLOOR_VEC       = vec4(0.0, 1.0, 0.0, 2.5);\nconst vec4 LEFT_WALL_VEC   = vec4(1.0, 0.0, 0.0, 5.0);\nconst vec4 RIGHT_WALL_VEC  = vec4(-1.0, 0.0, 0.0, 5.0);\nconst vec4 BACK_WALL_VEC   = vec4(0.0, 0.0, -1.0, 5.0);\nconst vec4 CEILING_VEC     = vec4(0.0, -1.0, 0.0, 7.5);\nconst vec3 LONG_BOX_POS    = vec3(2.1, -0.5, -2);\nconst vec3 LONG_BOX_SCALE  = vec3(1.5, 3.0, 1.5);\nconst vec3 SHORT_BOX_POS   = vec3(-2.1, 1, -1);\nconst vec3 SHORT_BOX_SCALE = vec3(1.5, 1.5, 1.5);\n\nconst vec3 EYE_POS         = vec3(0.0, 5, -18.0);\nconst vec3 REF_POS         = vec3(0.0, 2.5, 0.0);\n\nconst int RAY_STEPS     = 256;\nconst int FLOOR_ID      = 0;\nconst int LEFT_WALL_ID  = 1;\nconst int RIGHT_WALL_ID = 2;\nconst int BACK_WALL_ID  = 3;\nconst int CEILING_ID    = 4;\nconst int LONG_BOX_ID   = 5;\nconst int SHORT_BOX_ID  = 6;\nconst float PI_OVER_180 = 3.1415926 / 180.0;\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n\nvoid coordinateSystem(const vec3 v1, out vec3 v2, out vec3 v3) \n{\n    \n    if (abs(v1.x) > abs(v1.y)) \n    {\n        v2 = vec3(-v1.z, 0, v1.x) / length(v1.xz);\n    }\n    else\n    {\n        v2 = vec3(0, v1.z, -v1.y) / length(v1.yz);\n    }\n    v3 = cross(v1, v2);\n}\n\nfloat plane(vec3 p, vec4 n)\n{\n  // n must be normalized\n  return dot(p, n.xyz) + n.w;\n}\n\n// Box with side lengths b\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\nvec3 rotateY(vec3 p, float a) \n{\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvec3 rotateX(vec3 p, float amt) \n{\n    return vec3(p.x, cos(amt) * p.y - sin(amt) * p.z, sin(p.y) + cos(p.z));\n}\n\n\nvoid sceneMap3D(vec3 pos, out float t, out int objId, vec3 lightPos)\n{\n    // floor\n    t = plane(pos, FLOOR_VEC);  \n    objId = FLOOR_ID;  \n\n    float t2;\n    if((t2 = plane(pos, LEFT_WALL_VEC)) < t)  \n    {\n        t= t2;\n        objId = LEFT_WALL_ID;\n    } \n    if((t2 = plane(pos, RIGHT_WALL_VEC)) < t)  \n    {\n        t= t2;\n        objId = RIGHT_WALL_ID;\n    }\n    if((t2 = plane(pos, BACK_WALL_VEC)) < t)\n    {\n        t= t2;\n        objId = BACK_WALL_ID;\n    }\n    if((t2 = plane(pos, CEILING_VEC)) < t)\n    {\n        t= t2;\n        objId = CEILING_ID;\n    }\n    if((t2 = box(rotateY(pos + LONG_BOX_POS, 27.5 * PI_OVER_180), LONG_BOX_SCALE)) < t)  // long bix\n    {\n        t= t2;\n        objId = LONG_BOX_ID;\n    }\n    if((t2 = box(rotateY(pos + SHORT_BOX_POS, -27.5 * PI_OVER_180), SHORT_BOX_SCALE)) < t)\n    {\n        t= t2;\n        objId = SHORT_BOX_ID;\n    }\n}\n\nfloat sceneMap3D(vec3 pos)\n{\n    float t = plane(pos, FLOOR_VEC);\n    t = min(t, plane(pos, LEFT_WALL_VEC));\n    t = min(t, plane(pos, RIGHT_WALL_VEC));\n    t = min(t, plane(pos, BACK_WALL_VEC));\n    t = min(t, plane(pos, CEILING_VEC));\n    t = min(t, box(rotateY(pos + LONG_BOX_POS, 27.5 * PI_OVER_180), LONG_BOX_SCALE));\n    t = min(t, box(rotateY(pos + SHORT_BOX_POS, -27.5 * PI_OVER_180), SHORT_BOX_SCALE));\n    return t;\n}\n\nvec2 random2(vec3 p)\n{\n    return fract(sin(vec2(p.x, p.x + 1.0)) * vec2(43758.5453123, 22578.1459123));\n}\n\n// from https://www.shadertoy.com/view/3sB3zV\nfloat computeAO(vec3 p, vec3 n, float dist)\n{\n    float aoSum = 0.0;\n    \n    // Sample a few points in the hemisphere around n at p\n    vec3 t, b;\n    \n    // Make a tangent and bitangent vector\n    coordinateSystem(n, t, b);\n    \n    for(int i = 0; i < AO_SAMPLES; ++i) \n    {\n        // Generate a pair of random [0, 1] floats\n        vec2 xi = random2(p + float(i) * 203.1);\n        \n        // Convert the xi pair to a vector in the hemisphere\n        float len = sqrt(xi.y);\n        float rx = len * cos(6.2831 * xi.x);\n        float ry = len * sin(6.2831 * xi.x);\n        float rz = sqrt(1.0 - xi.y); // z = sqrt(1 - x*x - y*y)\n        vec3 dir = vec3(rx * t + ry * b + rz * n);\n        \n        aoSum += step(0.0, sceneMap3D(p + dir * dist));\n    }\n    \n    return aoSum / float(AO_SAMPLES);\n}\n\n// from https://www.shadertoy.com/view/3sB3zV\nfloat fiveTapAO(vec3 p, vec3 n, float k) \n{\n    float aoSum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i)\n    {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * AO_DIST - sceneMap3D(p + n * i * AO_DIST));\n    }\n    \n    return 1.0 - k * aoSum;\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int objId, vec3 lightPos)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n        float m;\n        sceneMap3D(pos, m, objId, lightPos);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n\n    t = -1.0;\n    objId = -1;\n}\n\nvec3 computeMaterial(int objId, vec3 p, vec3 n, vec3 light, vec3 view)\n{\n    float lambert = dot(light, n);\n\n    switch(objId) \n    {\n    case FLOOR_ID:  // floor\n        return vec3(1.0, 1.0, 1.0) * lambert;\n        break;\n    case LEFT_WALL_ID:  // Left wall, which is a large red plane\n        return vec3(0.63, 0.065, 0.05) * lambert;\n        break;\n    case RIGHT_WALL_ID:  // Right wall, which is a large green plane\n        return vec3(0.14, 0.45, 0.091) * lambert;\n        break;\n    case BACK_WALL_ID:  // Back wall, which is a large white plane\n        return vec3(1.0, 1.0, 1.0) * lambert;\n        break;\n    case CEILING_ID:  // Ceiling, which is a large white plane\n        return vec3(1.0, 1.0, 1.0) * lambert;\n        break;\n    case LONG_BOX_ID:  // Cuboid, the long box\n        return vec3(1.0, 1.0, 1.0) * lambert;\n        break;\n    case SHORT_BOX_ID:  // Cube, the short box\n        return vec3(1.0, 1.0, 1.0) * lambert;\n        break;\n    default:\n        return vec3(0.0);\n        break;\n    }\n\n    return vec3(1.0);\n}\n\nvec3 computeNormal(vec3 pos, vec3 lightPos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize(vec3(sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                          sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                          sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye, vec3 lightPos)\n{\n    float t;\n    int objId;\n    march(eye, dir, t, objId, lightPos);\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect, lightPos);\n    vec3 lightDir = normalize(lightPos - isect);\n    vec3 surfaceColor = computeMaterial(objId, isect, nor, lightDir, normalize(eye - isect));\n    \n    float ao = fiveTapAO(isect, nor, FIVETAP_K);\n    vec3 sdfColor = ao * surfaceColor;\n    \n    return Intersection(t, sdfColor, isect, objId);\n}\n\nvoid raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref)\n{\n    eye = EYE_POS;\n    ref = REF_POS;\n    \n    float len = tan(3.14159 * 0.125) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * float(iResolution.x) / float(iResolution.y);\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 lightPos = vec3(0.0, 7.3, -1.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n\n    vec3 dir, eye, ref;\n    raycast(uv2, dir, eye, ref);\n    Intersection intersection = sdf3D(dir, eye, lightPos);\n\n    // Output to screen\n    fragColor = vec4(intersection.color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXfRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1027, 1027, 1092, 1092, 1290], [1292, 1292, 1321, 1347, 1379], [1381, 1408, 1435, 1435, 1476], [1478, 1478, 1510, 1510, 1593], [1595, 1595, 1629, 1629, 1707], [1710, 1710, 1780, 1793, 2583], [2585, 2585, 2613, 2613, 3012], [3014, 3014, 3036, 3036, 3120], [3122, 3168, 3213, 3213, 3969], [3971, 4017, 4060, 4060, 4282], [4284, 4284, 4362, 4362, 4637], [4639, 4639, 4711, 4711, 5679], [5681, 5681, 5726, 5726, 6039], [6041, 6041, 6096, 6096, 6540], [6542, 6542, 6607, 6607, 6963], [6966, 6966, 7023, 7023, 7399]], "test": "untested"}
{"id": "tsXBRr", "name": "Cornell Box Post-Processed DoF ", "author": "giaosame", "description": "Use ShaderToy's frame buffer feature to apply post-process based depth of field blurring on the built Cornell Box scene: https://www.shadertoy.com/view/tdXfzn", "tags": ["3d", "cornellbox"], "likes": 1, "viewed": 307, "published": 3, "date": "1587591481", "time_retrieved": "2024-07-30T21:11:05.243093", "image_code": "// Refer to the code from https://www.shadertoy.com/view/wsB3RK\n\n// from https://www.shadertoy.com/view/XdfGDH\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // from https://www.shadertoy.com/view/XdfGDH\n    const int mSize = 11;\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 final_color = vec3(0.0);\n\n    //create the 1-D kernel\n    float sigma = 20.0;\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j) {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j) {\n        Z += kernel[j];\n    }\n    \n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i) {\n        for (int j=-kSize; j <= kSize; ++j) {\n            final_color += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel0, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n\n        }\n    }\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 unblurredColor = texture(iChannel0, uv);\n    fragColor = vec4(mix(unblurredColor.rgb, final_color/(Z*Z), unblurredColor.a), 1.0);\n    \n    float vignette = smoothstep(1.75, 0.0, length((2.0 * uv) - vec2(1.0)));\n    fragColor = mix(vec4(0.0, 0.0, 0.1, 1.0), fragColor, vignette);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const vec4 FLOOR_VEC       = vec4(0.0, 1.0, 0.0, 2.5);\nconst vec4 LEFT_WALL_VEC   = vec4(1.0, 0.0, 0.0, 5.0);\nconst vec4 RIGHT_WALL_VEC  = vec4(-1.0, 0.0, 0.0, 5.0);\nconst vec4 BACK_WALL_VEC   = vec4(0.0, 0.0, -1.0, 5.0);\nconst vec4 CEILING_VEC     = vec4(0.0, -1.0, 0.0, 7.5);\nconst vec3 LONG_BOX_POS    = vec3(2.1, -0.5, -2);\nconst vec3 LONG_BOX_SCALE  = vec3(1.5, 3.0, 1.5);\nconst vec3 SHORT_BOX_POS   = vec3(-2.1, 1, -1);\nconst vec3 SHORT_BOX_SCALE = vec3(1.5, 1.5, 1.5);\n\nconst vec3 EYE_POS         = vec3(0.0, 5, -18.0);\nconst vec3 REF_POS         = vec3(0.0, 2.5, 0.0);\n\nconst int RAY_STEPS     = 256;\nconst int FLOOR_ID      = 0;\nconst int LEFT_WALL_ID  = 1;\nconst int RIGHT_WALL_ID = 2;\nconst int BACK_WALL_ID  = 3;\nconst int CEILING_ID    = 4;\nconst int LONG_BOX_ID   = 5;\nconst int SHORT_BOX_ID  = 6;\nconst float PI_OVER_180 = 3.1415926 / 180.0;\n\nconst float FOCAL_LENGTH = 16.0;\nconst float FOCAL_RANGE = 16.0;\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n\nfloat plane(vec3 p, vec4 n)\n{\n  // n must be normalized\n  return dot(p, n.xyz) + n.w;\n}\n\n// Box with side lengths b\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\nvec3 rotateY(vec3 p, float a) \n{\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvec3 rotateX(vec3 p, float amt) \n{\n    return vec3(p.x, cos(amt) * p.y - sin(amt) * p.z, sin(p.y) + cos(p.z));\n}\n\n\nvoid sceneMap3D(vec3 pos, out float t, out int objId, vec3 lightPos)\n{\n    // floor\n    t = plane(pos, FLOOR_VEC);  \n    objId = FLOOR_ID;  \n\n    float t2;\n    if((t2 = plane(pos, LEFT_WALL_VEC)) < t)  \n    {\n        t= t2;\n        objId = LEFT_WALL_ID;\n    } \n    if((t2 = plane(pos, RIGHT_WALL_VEC)) < t)  \n    {\n        t= t2;\n        objId = RIGHT_WALL_ID;\n    }\n    if((t2 = plane(pos, BACK_WALL_VEC)) < t)\n    {\n        t= t2;\n        objId = BACK_WALL_ID;\n    }\n    if((t2 = plane(pos, CEILING_VEC)) < t)\n    {\n        t= t2;\n        objId = CEILING_ID;\n    }\n    if((t2 = box(rotateY(pos + LONG_BOX_POS, 27.5 * PI_OVER_180), LONG_BOX_SCALE)) < t)  // long bix\n    {\n        t= t2;\n        objId = LONG_BOX_ID;\n    }\n    if((t2 = box(rotateY(pos + SHORT_BOX_POS, -27.5 * PI_OVER_180), SHORT_BOX_SCALE)) < t)\n    {\n        t= t2;\n        objId = SHORT_BOX_ID;\n    }\n}\n\nfloat sceneMap3D(vec3 pos, vec3 lightPos)\n{\n    float t = plane(pos, FLOOR_VEC);\n    t = min(t, plane(pos, LEFT_WALL_VEC));\n    t = min(t, plane(pos, RIGHT_WALL_VEC));\n    t = min(t, plane(pos, BACK_WALL_VEC));\n    t = min(t, plane(pos, CEILING_VEC));\n    t = min(t, box(rotateY(pos + LONG_BOX_POS, 27.5 * PI_OVER_180), LONG_BOX_SCALE));\n    t = min(t, box(rotateY(pos + SHORT_BOX_POS, -27.5 * PI_OVER_180), SHORT_BOX_SCALE));\n    return t;\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int objId, vec3 lightPos)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n        float m;\n        sceneMap3D(pos, m, objId, lightPos);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n\n    t = -1.0;\n    objId = -1;\n}\n\nvec3 computeMaterial(int objId, vec3 p, vec3 n, vec3 light, vec3 view)\n{\n    float lambert = dot(light, n);\n\n    switch(objId) \n    {\n    case FLOOR_ID:  // floor\n        return vec3(1.0, 1.0, 1.0) * lambert;\n        break;\n    case LEFT_WALL_ID:  // Left wall, which is a large red plane\n        return vec3(0.63, 0.065, 0.05) * lambert;\n        break;\n    case RIGHT_WALL_ID:  // Right wall, which is a large green plane\n        return vec3(0.14, 0.45, 0.091) * lambert;\n        break;\n    case BACK_WALL_ID:  // Back wall, which is a large white plane\n        return vec3(1.0, 1.0, 1.0) * lambert;\n        break;\n    case CEILING_ID:  // Ceiling, which is a large white plane\n        return vec3(1.0, 1.0, 1.0) * lambert;\n        break;\n    case LONG_BOX_ID:  // Cuboid, the long box\n        return vec3(1.0, 1.0, 1.0) * lambert;\n        break;\n    case SHORT_BOX_ID:  // Cube, the short box\n        return vec3(1.0, 1.0, 1.0) * lambert;\n        break;\n    default:\n        return vec3(0.0);\n        break;\n    }\n\n    return vec3(1.0);\n}\n\nvec3 computeNormal(vec3 pos, vec3 lightPos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize(vec3(sceneMap3D(pos + epsilon.yxx, lightPos) - sceneMap3D(pos - epsilon.yxx, lightPos),\n                          sceneMap3D(pos + epsilon.xyx, lightPos) - sceneMap3D(pos - epsilon.xyx, lightPos),\n                          sceneMap3D(pos + epsilon.xxy, lightPos) - sceneMap3D(pos - epsilon.xxy, lightPos)));\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye, vec3 lightPos)\n{\n    float t;\n    int objId;\n    march(eye, dir, t, objId, lightPos);\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect, lightPos);\n    vec3 lightDir = normalize(lightPos - isect);\n    vec3 surfaceColor = computeMaterial(objId, isect, nor, lightDir, normalize(eye - isect));\n    \n    vec3 sdfColor = clamp(surfaceColor + vec3(0.05, 0.1, 0.15), 0.0, 1.0);\n    return Intersection(t, sdfColor, isect, objId);\n}\n\nvoid raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref)\n{\n    eye = EYE_POS;\n    ref = REF_POS;\n    \n    float len = tan(3.14159 * 0.125) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * float(iResolution.x) / float(iResolution.y);\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n} \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 lightPos = vec3(0.0, 7.3, -1.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n\n    vec3 dir, eye, ref;\n    raycast(uv2, dir, eye, ref);\n    Intersection intersection = sdf3D(dir, eye, lightPos);\n    \n    float distAlongCamZ = abs(dot(normalize(ref - eye), (intersection.p - eye)));\n    float dofZ = min(1.0, abs(distAlongCamZ - FOCAL_LENGTH) / FOCAL_RANGE);\n    dofZ = pow(dofZ, 0.5);\n    \n    fragColor = vec4(intersection.color * step(0.0, intersection.t), dofZ);\n    float fogT = smoothstep(50.0, 100.0, distance(intersection.p, eye));\n    \n    fragColor.rgb = mix(fragColor.rgb, vec3(0.0), fogT);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXBRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 111, 154, 154, 207], [209, 209, 264, 314, 1371]], "test": "untested"}
{"id": "tdffzn", "name": "Swirly fire thing", "author": "suyoku", "description": "Interesting pattern that stems from just adding a bunch of point lights that are each orbit a little faster", "tags": ["raytracedfire"], "likes": 21, "viewed": 752, "published": 3, "date": "1587590218", "time_retrieved": "2024-07-30T21:11:05.985108", "image_code": "// Created by Christopher Wallis\n#define PI 3.14\n#define SCENE_MAX_T 900.0\n\n#define CHECKER_FLOOR_MATERIAL_ID 0\n#define LAMP_MATERIAL_ID 1\n#define NUM_MATERIALS 2\n\n#define NUM_LIGHTS 20\n\n#define INVALID_MATERIAL_ID int(-1)\n#define LARGE_NUMBER 1e20\n#define EPSILON 0.0001\n\nstruct CameraDescription\n{\n    vec3 Position;\n    vec3 LookAt;    \n\n    float LensHeight;\n    float FocalDistance;\n};\n    \nstruct OrbLightDescription\n{\n    vec3 Position;\n    float Radius;\n    vec3 LightColor;\n};\n    \nCameraDescription Camera = CameraDescription(\n    vec3(0, 20, -250),\n    vec3(0, 5, 0),\n    2.0,\n    7.0\n);\n\nOrbLightDescription GetLight(int lightIndex)\n{\n    float theta = iTime * 0.2 * (float(lightIndex) + 1.0f);\n    float radius = 10.0f + float(lightIndex) * 2.5;\n    \n    OrbLightDescription orbLight;\n    orbLight.Position = vec3(radius * cos(theta), 3.0 + sin(theta * 2.0) * 2.5, radius * sin(theta));\n    orbLight.LightColor = vec3(20.0, 10.0, 0.4);\n    orbLight.Radius = 1.0f;\n\n    return orbLight;\n}\n\n#define MATERIAL_IS_LIGHT_SOURCE 0x1\n\nstruct Material\n{\n    vec3 albedo;\n    vec3 emissive;\n    int flags;\n};\n    \nMaterial NormalMaterial(vec3 albedo, int flags)\n{\n    return Material(albedo, vec3(0), flags);\n}\n\nbool IsLightSource(in Material m)\n{\n    return (m.flags & MATERIAL_IS_LIGHT_SOURCE) != 0;\n}\n\nMaterial GetMaterial(int materialID, vec3 position)\n{\n    Material materials[NUM_MATERIALS];\n\tmaterials[CHECKER_FLOOR_MATERIAL_ID] = NormalMaterial(vec3(0.6, 0.6, 0.7), 0);\n\tmaterials[LAMP_MATERIAL_ID] = NormalMaterial(GetLight(0).LightColor, MATERIAL_IS_LIGHT_SOURCE);\n    \n    Material mat;\n    if(materialID < int(NUM_MATERIALS))\n    {\n        mat = materials[materialID];\n    }\n    else\n    {\n        // Should never get hit\n   \t\treturn materials[0];\n    }\n    \n    if(materialID == CHECKER_FLOOR_MATERIAL_ID)\n    {\n        vec2 uv = position.xz / 13.0;\n        uv = vec2(uv.x < 0.0 ? abs(uv.x) + 1.0 : uv.x, uv.y < 0.0 ? abs(uv.y) + 1.0 : uv.y);\n        if((int(uv.x) % 2 == 0 && int(uv.y) % 2 == 0) || (int(uv.x) % 2 == 1 && int(uv.y) % 2 == 1))\n        {\n            mat.albedo = vec3(1, 1, 1) * 0.7;\n        }\n    }\n\n    return mat;    \n}\n\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-plane-and-ray-disk-intersection\nfloat PlaneIntersection(vec3 rayOrigin, vec3 rayDirection, vec3 planeOrigin, vec3 planeNormal, out vec3 normal) \n{ \n    float t = -1.0f;\n    normal = planeNormal;\n    float denom = dot(-planeNormal, rayDirection); \n    if (denom > EPSILON) { \n        vec3 rayToPlane = planeOrigin - rayOrigin; \n        return dot(rayToPlane, -planeNormal) / denom; \n    } \n \n    return t; \n} \n    \nfloat SphereIntersection(\n    in vec3 rayOrigin, \n    in vec3 rayDirection, \n    in vec3 sphereCenter, \n    in float sphereRadius, \n    out vec3 normal)\n{\n      vec3 eMinusC = rayOrigin - sphereCenter;\n      float dDotD = dot(rayDirection, rayDirection);\n\n      float discriminant = dot(rayDirection, (eMinusC)) * dot(rayDirection, (eMinusC))\n         - dDotD * (dot(eMinusC, eMinusC) - sphereRadius * sphereRadius);\n\n      // If the ray doesn't intersect\n      if (discriminant < 0.0) \n         return -1.0;\n\n      float firstIntersect = (dot(-rayDirection, eMinusC) - sqrt(discriminant))\n             / dDotD;\n      \n      float t = firstIntersect;\n    \n      // If the ray is inside the sphere\n      if (firstIntersect < EPSILON) {\n         t = (dot(-rayDirection, eMinusC) + sqrt(discriminant))\n             / dDotD;\n      }\n    \n      normal = normalize(rayOrigin + rayDirection * t - sphereCenter);\n      return t;\n}\n\n\nvoid UpdateIfIntersected(\n    inout float t,\n    in float intersectionT, \n    in vec3 intersectionNormal,\n    in int intersectionMaterialID,\n    out vec3 normal,\n    out int materialID\n\t)\n{    \n    if(intersectionT > EPSILON && intersectionT < t)\n    {\n\t\tnormal = intersectionNormal;\n        materialID = intersectionMaterialID;\n        t = intersectionT;\n    }\n}\n\nfloat IntersectOpaqueScene(in vec3 rayOrigin, in vec3 rayDirection, out int materialID, out vec3 normal)\n{\n    float intersectionT = LARGE_NUMBER;\n    vec3 intersectionNormal = vec3(0, 0, 0);\n\n    float t = LARGE_NUMBER;\n    normal = vec3(0, 0, 0);\n    materialID = INVALID_MATERIAL_ID;\n\n    for(int lightIndex = 0; lightIndex < NUM_LIGHTS; lightIndex++)\n    {\n        UpdateIfIntersected(\n            t,\n            SphereIntersection(rayOrigin, rayDirection, GetLight(lightIndex).Position, GetLight(lightIndex).Radius, intersectionNormal),\n            intersectionNormal,\n            LAMP_MATERIAL_ID,\n            normal,\n            materialID);\n    }\n\n    \n    UpdateIfIntersected(\n        t,\n        PlaneIntersection(rayOrigin, rayDirection, vec3(0, 0, 0), vec3(0, 1, 0), intersectionNormal),\n        intersectionNormal,\n        CHECKER_FLOOR_MATERIAL_ID,\n        normal,\n        materialID);\n\n    \n    return t;\n}\n\nvec3 Diffuse(in vec3 normal, in vec3 lightVec, in vec3 diffuse)\n{\n    float nDotL = dot(normal, lightVec);\n    return clamp(nDotL * diffuse, 0.0, 1.0);\n}\n\nvoid CalculateLighting(vec3 position, vec3 normal, vec3 reflectionDirection, Material material, bool shootShadowRays, inout vec3 color)\n{\n    for(int lightIndex = 0; lightIndex < NUM_LIGHTS; lightIndex++)\n    {\n        vec3 lightDirection = (GetLight(lightIndex).Position - position);\n        float lightDistance = length(lightDirection);\n        lightDirection /= lightDistance;\n\n        // Manually tuned light falloff for what looked best\n        vec3 lightColor = GetLight(lightIndex).LightColor / pow(lightDistance, 1.5); \n\n        color += 0.25 * lightColor * pow(max(dot(reflectionDirection, lightDirection), 0.0), 4.0);\n        color += lightColor * Diffuse(normal, lightDirection, material.albedo);\n    \n    }\n    color += material.emissive;\n}\n\nvoid Render( in vec3 rayOrigin, in vec3 rayDirection, out vec3 color)\n{\n    float depth = SCENE_MAX_T;\n    color = vec3(0.0f);\n    \n    vec3 normal;\n    float t;\n    int materialID = INVALID_MATERIAL_ID;\n    \n    t = IntersectOpaqueScene(rayOrigin, rayDirection, materialID, normal);\n    \n    if( materialID != INVALID_MATERIAL_ID )\n    {\n        depth = t;\n        vec3 position = rayOrigin + t*rayDirection;\n        Material material = GetMaterial(materialID, position);\n\t\tif(IsLightSource(material))\n        {\n            color = min(material.albedo, vec3(1.0));\n            return;\n        }       \n        \n        vec3 reflectionDirection = reflect( rayDirection, normal);\n        CalculateLighting(position, normal, reflectionDirection, material, true, color);\n    }\n}\n\nmat3 GetViewMatrix(float xRotationFactor)\n{ \n   float xRotation = ((1.0 - xRotationFactor) - 0.5) * PI * 0.4 + PI * 0.25;\n   return mat3( cos(xRotation), 0.0, sin(xRotation),\n                0.0,           1.0, 0.0,    \n                -sin(xRotation),0.0, cos(xRotation));\n}\n\nfloat GetCameraPositionYOffset()\n{\n    return 250.0 * (iMouse.y / iResolution.y);\n}\n\nfloat GetRotationFactor()\n{\n    if(iMouse.x <= 0.0)\n    {\n        // Default value when shader is initially loaded up\n        return 0.65f;\n    }\n    \n    return iMouse.x / iResolution.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float aspectRatio = iResolution.x /  iResolution.y; \n    float lensWidth = Camera.LensHeight * aspectRatio;\n    \n    vec3 CameraPosition = Camera.Position + GetCameraPositionYOffset();\n    \n    vec3 NonNormalizedCameraView = Camera.LookAt - CameraPosition;\n    float ViewLength = length(NonNormalizedCameraView);\n    vec3 CameraView = NonNormalizedCameraView / ViewLength;\n\n    vec3 lensPoint = CameraPosition;\n    \n    // Pivot the camera around the look at point\n    {\n        float rotationFactor = GetRotationFactor();\n        mat3 viewMatrix = GetViewMatrix(rotationFactor);\n        CameraView = CameraView * viewMatrix;\n        lensPoint = Camera.LookAt - CameraView * ViewLength;\n    }\n    \n    // Technically this could be calculated offline but I like \n    // being able to iterate quickly\n    vec3 CameraRight = cross(CameraView, vec3(0, 1, 0));    \n    vec3 CameraUp = cross(CameraRight, CameraView);\n\n    vec3 focalPoint = lensPoint - Camera.FocalDistance * CameraView;\n    lensPoint += CameraRight * (uv.x * 2.0 - 1.0) * lensWidth / 2.0;\n    lensPoint += CameraUp * (uv.y * 2.0 - 1.0) * Camera.LensHeight / 2.0;\n    \n    vec3 rayOrigin = focalPoint;\n    vec3 rayDirection = normalize(lensPoint - focalPoint);\n    \n    vec3 color;\n    Render(rayOrigin, rayDirection, color);\n    fragColor=vec4( clamp(color, 0.0, 1.0), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdffzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1117, 1117, 1166, 1166, 1213], [1215, 1215, 1250, 1250, 1306], [2156, 2295, 2409, 2409, 2670], [2677, 2677, 2831, 2831, 3599], [3602, 3602, 3791, 3791, 3965], [3967, 3967, 4073, 4073, 4887], [4889, 4889, 4954, 4954, 5042], [5044, 5044, 5181, 5181, 5796], [5798, 5798, 5869, 5869, 6573], [6575, 6575, 6618, 6618, 6850], [6852, 6852, 6886, 6886, 6935], [6937, 6937, 6964, 6964, 7126], [7128, 7128, 7185, 7185, 8579]], "test": "untested"}
{"id": "tdXfzn", "name": "Re-made Cornell Box", "author": "giaosame", "description": "A haderToy shader that renders the default Cornell Box scene using ray marching with Box and Plane SDFs.", "tags": ["3d"], "likes": 0, "viewed": 339, "published": 3, "date": "1587589711", "time_retrieved": "2024-07-30T21:11:06.723135", "image_code": "const vec4 FLOOR_VEC       = vec4(0.0, 1.0, 0.0, 2.5);\nconst vec4 LEFT_WALL_VEC   = vec4(1.0, 0.0, 0.0, 5.0);\nconst vec4 RIGHT_WALL_VEC  = vec4(-1.0, 0.0, 0.0, 5.0);\nconst vec4 BACK_WALL_VEC   = vec4(0.0, 0.0, -1.0, 5.0);\nconst vec4 CEILING_VEC     = vec4(0.0, -1.0, 0.0, 7.5);\nconst vec3 LONG_BOX_POS    = vec3(2.1, -0.5, -2);\nconst vec3 LONG_BOX_SCALE  = vec3(1.5, 3.0, 1.5);\nconst vec3 SHORT_BOX_POS   = vec3(-2.1, 1, -1);\nconst vec3 SHORT_BOX_SCALE = vec3(1.5, 1.5, 1.5);\n\nconst vec3 EYE_POS         = vec3(0.0, 5, -18.0);\nconst vec3 REF_POS         = vec3(0.0, 2.5, 0.0);\n\nconst int RAY_STEPS     = 256;\nconst int FLOOR_ID      = 0;\nconst int LEFT_WALL_ID  = 1;\nconst int RIGHT_WALL_ID = 2;\nconst int BACK_WALL_ID  = 3;\nconst int CEILING_ID    = 4;\nconst int LONG_BOX_ID   = 5;\nconst int SHORT_BOX_ID  = 6;\nconst float PI_OVER_180 = 3.1415926 / 180.0;\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n\nfloat plane(vec3 p, vec4 n)\n{\n  // n must be normalized\n  return dot(p, n.xyz) + n.w;\n}\n\n// Box with side lengths b\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\nvec3 rotateY(vec3 p, float a) \n{\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvec3 rotateX(vec3 p, float amt) \n{\n    return vec3(p.x, cos(amt) * p.y - sin(amt) * p.z, sin(p.y) + cos(p.z));\n}\n\n\nvoid sceneMap3D(vec3 pos, out float t, out int objId, vec3 lightPos)\n{\n    // floor\n    t = plane(pos, FLOOR_VEC);  \n    objId = FLOOR_ID;  \n\n    float t2;\n    if((t2 = plane(pos, LEFT_WALL_VEC)) < t)  \n    {\n        t= t2;\n        objId = LEFT_WALL_ID;\n    } \n    if((t2 = plane(pos, RIGHT_WALL_VEC)) < t)  \n    {\n        t= t2;\n        objId = RIGHT_WALL_ID;\n    }\n    if((t2 = plane(pos, BACK_WALL_VEC)) < t)\n    {\n        t= t2;\n        objId = BACK_WALL_ID;\n    }\n    if((t2 = plane(pos, CEILING_VEC)) < t)\n    {\n        t= t2;\n        objId = CEILING_ID;\n    }\n    if((t2 = box(rotateY(pos + LONG_BOX_POS, 27.5 * PI_OVER_180), LONG_BOX_SCALE)) < t)  // long bix\n    {\n        t= t2;\n        objId = LONG_BOX_ID;\n    }\n    if((t2 = box(rotateY(pos + SHORT_BOX_POS, -27.5 * PI_OVER_180), SHORT_BOX_SCALE)) < t)\n    {\n        t= t2;\n        objId = SHORT_BOX_ID;\n    }\n}\n\nfloat sceneMap3D(vec3 pos, vec3 lightPos)\n{\n    float t = plane(pos, FLOOR_VEC);\n    t = min(t, plane(pos, LEFT_WALL_VEC));\n    t = min(t, plane(pos, RIGHT_WALL_VEC));\n    t = min(t, plane(pos, BACK_WALL_VEC));\n    t = min(t, plane(pos, CEILING_VEC));\n    t = min(t, box(rotateY(pos + LONG_BOX_POS, 27.5 * PI_OVER_180), LONG_BOX_SCALE));\n    t = min(t, box(rotateY(pos + SHORT_BOX_POS, -27.5 * PI_OVER_180), SHORT_BOX_SCALE));\n    return t;\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int objId, vec3 lightPos)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n        float m;\n        sceneMap3D(pos, m, objId, lightPos);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n\n    t = -1.0;\n    objId = -1;\n}\n\nvec3 computeMaterial(int objId, vec3 p, vec3 n, vec3 light, vec3 view)\n{\n    float lambert = dot(light, n);\n\n    switch(objId) \n    {\n    case FLOOR_ID:  // floor\n        return vec3(1.0, 1.0, 1.0) * lambert;\n        break;\n    case LEFT_WALL_ID:  // Left wall, which is a large red plane\n        return vec3(0.63, 0.065, 0.05) * lambert;\n        break;\n    case RIGHT_WALL_ID:  // Right wall, which is a large green plane\n        return vec3(0.14, 0.45, 0.091) * lambert;\n        break;\n    case BACK_WALL_ID:  // Back wall, which is a large white plane\n        return vec3(1.0, 1.0, 1.0) * lambert;\n        break;\n    case CEILING_ID:  // Ceiling, which is a large white plane\n        return vec3(1.0, 1.0, 1.0) * lambert;\n        break;\n    case LONG_BOX_ID:  // Cuboid, the long box\n        return vec3(1.0, 1.0, 1.0) * lambert;\n        break;\n    case SHORT_BOX_ID:  // Cube, the short box\n        return vec3(1.0, 1.0, 1.0) * lambert;\n        break;\n    default:\n        return vec3(0.0);\n        break;\n    }\n\n    return vec3(1.0);\n}\n\nvec3 computeNormal(vec3 pos, vec3 lightPos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize(vec3(sceneMap3D(pos + epsilon.yxx, lightPos) - sceneMap3D(pos - epsilon.yxx, lightPos),\n                          sceneMap3D(pos + epsilon.xyx, lightPos) - sceneMap3D(pos - epsilon.xyx, lightPos),\n                          sceneMap3D(pos + epsilon.xxy, lightPos) - sceneMap3D(pos - epsilon.xxy, lightPos)));\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye, vec3 lightPos)\n{\n    float t;\n    int objId;\n    march(eye, dir, t, objId, lightPos);\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect, lightPos);\n    vec3 lightDir = normalize(lightPos - isect);\n    \n    vec3 surfaceColor = computeMaterial(objId, isect, nor, lightDir, normalize(eye - isect));\n    \n    return Intersection(t, surfaceColor, isect, objId);\n}\n\nvoid raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref)\n{\n    eye = EYE_POS;\n    ref = REF_POS;\n    \n    float len = tan(3.14159 * 0.125) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * float(iResolution.x) / float(iResolution.y);\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 lightPos = vec3(0.0, 7.3, -1.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n\n    vec3 dir, eye, ref;\n    raycast(uv2, dir, eye, ref);\n    Intersection intersection = sdf3D(dir, eye, lightPos);\n\n    // Output to screen\n    fragColor = vec4(intersection.color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXfzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[941, 941, 970, 996, 1028], [1030, 1057, 1084, 1084, 1125], [1127, 1127, 1159, 1159, 1242], [1244, 1244, 1278, 1278, 1356], [1359, 1359, 1429, 1442, 2232], [2234, 2234, 2277, 2277, 2676], [2678, 2678, 2756, 2756, 3031], [3033, 3033, 3105, 3105, 4073], [4075, 4075, 4120, 4120, 4493], [4495, 4495, 4550, 4550, 4910], [4912, 4912, 4977, 4977, 5333], [5336, 5336, 5393, 5393, 5769]], "test": "untested"}
{"id": "tsffRn", "name": "Twitter Bokeh Thing", "author": "05gash", "description": "bokeh, tweet version here: https://twitter.com/05gash/status/1253062159204048896", "tags": ["bokeh", "tonemapping", "srgb"], "likes": 3, "viewed": 465, "published": 3, "date": "1587589121", "time_retrieved": "2024-07-30T21:11:07.461162", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv;\n    vec2 r = iResolution.xy;\n    \n    float t = mod(iTime,5.);\n    // Time varying pixel color\n    vec4 col;\n\t\n\t//should fit in a tweet\n    #define o(x) snoise(vec2(x, x*2.))\n    vec2 g = p*2.-1.;g.x*=r.x/r.y;float i;for(i=0.;i<500.;i++){\n    col += smoothstep(.13,.1, length(g - 2.*vec2(o(i), o(i*4.+t/100.))))*vec4(2., 0.4-0.2*snoise(p), 0.22,1.0)*mod(i,10.)/10.;}col = col/(col+1.);\n        \n    fragColor.xyz = lin2srgb(col.xyz);\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "// Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n    // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n        permute( i.y + vec3(0.0, i1.y, 1.0))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n        dot(x0,x0),\n        dot(x1,x1),\n        dot(x2,x2)\n    ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\nvec3 lin2srgb( vec3 cl )\n{\n    //cl = clamp( cl, 0.0, 1.0 );\n    vec3 c_lo = 12.92 * cl;\n    vec3 c_hi = 1.055 * pow(cl,vec3(0.41666)) - 0.055;\n    vec3 s = step( vec3(0.0031308), cl);\n    return mix( c_lo, c_hi, s );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsffRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 623]], "test": "untested"}
{"id": "3sXBRr", "name": "Shiny sphere lights with subsurf", "author": "Iris_", "description": "original work from https://www.shadertoy.com/view/ltjGDd\nTest subsurface shader", "tags": ["subsurface"], "likes": 6, "viewed": 554, "published": 3, "date": "1587581763", "time_retrieved": "2024-07-30T21:11:08.206170", "image_code": "// Adjust these to alter where the subsurface glow shines through and how brightly\nconst float FIVETAP_K = 2.0;\nconst float AO_DIST = 0.085;\n\n// The larger the DISTORTION, the smaller the glow\nconst float DISTORTION = 0.2;\n// The higher GLOW is, the smaller the glow of the subsurface scattering\nconst float GLOW = 6.0;\n// The higher the BSSRDF_SCALE, the brighter the scattered light\nconst float BSSRDF_SCALE = 3.0;\nconst float AMBIENT = 0.0;\n// Fun with spherical lights, area shadows, occlusion and reflections.\n// Sphere and trace functions by inigo quilez, https://iquilezles.org\n#define ATTENUATION 0\n\n#define BIAS 0.0001\n#define PI 3.1415927\n#define SEED 4.\n\n\nfloat subsurface(vec3 lightDir, vec3 normal, vec3 viewVec, float thickness) \n{\n    vec3 scatteredLightDir = lightDir + normal * DISTORTION;\n    float lightReachingEye = pow(clamp(dot(viewVec, -scatteredLightDir), 0.0, 1.0), GLOW) * BSSRDF_SCALE;\n    float attenuation = 1.0;\n    #if ATTENUATION\n    // attenuation = max(0.0, dot(normal, lightDir) + dot(viewVec, -lightDir));\n    #endif\n\tfloat totalLight = attenuation * (lightReachingEye + AMBIENT) * thickness;\n    return totalLight;\n}\n\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n  vec3 oc = ro - sph.xyz;\n  float b = dot( oc, rd );\n  float c = dot( oc, oc ) - sph.w*sph.w;\n  float h = b*b - c;\n  if( h<0.0 ) return -1.0;\n  return -b - sqrt( h );\n}\n\nfloat sphOcclusion( in vec3 pos, in vec3 nor, in vec4 sph )\n{\n    vec3  r = sph.xyz - pos;\n    float l = length(r);\n    float d = dot(nor,r);\n    float res = d;\n\n    if( d<sph.w ) res = pow(clamp((d+sph.w)/(2.0*sph.w),0.0,1.0),1.5)*sph.w;\n    \n    return clamp( res*(sph.w*sph.w)/(l*l*l), 0.0, 1.0 );\n\n}\n\nfloat sphAreaShadow( vec3 P, in vec4 L, vec4 sph )\n{\n  vec3 ld = L.xyz - P;\n  vec3 oc = sph.xyz - P;\n  float r = sph.w - BIAS;\n  \n  float d1 = sqrt(dot(ld, ld));\n  float d2 = sqrt(dot(oc, oc));\n  \n  if (d1 - L.w / 2. < d2 - r) return 1.;\n  \n  float ls1 = L.w / d1;\n  float ls2 = r / d2;\n\n  float in1 = sqrt(1.0 - ls1 * ls1);\n  float in2 = sqrt(1.0 - ls2 * ls2);\n  \n  if (in1 * d1 < in2 * d2) return 1.;\n  \n  vec3 v1 = ld / d1;\n  vec3 v2 = oc / d2;\n  float ilm = dot(v1, v2);\n  \n  if (ilm < in1 * in2 - ls1 * ls2) return 1.0;\n  \n  float g = length( cross(v1, v2) );\n  \n  float th = clamp((in2 - in1 * ilm) * (d1 / L.w) / g, -1.0, 1.0);\n  float ph = clamp((in1 - in2 * ilm) * (d2 / r) / g, -1.0, 1.0);\n  \n  float sh = acos(th) - th * sqrt(1.0 - th * th) \n           + (acos(ph) - ph * sqrt(1.0 - ph * ph))\n           * ilm * ls2 * ls2 / (ls1 * ls1);\n  \n  return 1.0 - sh / PI;\n}\n\n\n//-------------------------------------------------------------------------------------------\nconst int SPH = 27; //3x3x3\n\nvec4 sphere[SPH];\nvec4 L;\n\nvec3 rand3( float x, float seed )\n{ \n  float f = x+seed;\n  return fract( PI*sin( vec3(f,f+5.33,f+7.7)) );\n}\n\nfloat areaShadow( in vec3 P )\n{\n  float s = 1.0;\n  for( int i=0; i<SPH; i++ )\n    s = min( s, sphAreaShadow(P, L, sphere[i] ) );\n  return s;           \n}\n\nvec3 reflections( vec3 P, vec3 R, vec3 tint, int iid )\n{\n  float t = 1e20;\n\n  vec3 s = vec3(R.y < 0. ? 1.-sqrt(-R.y/(P.y+1.)) : 1.); // P.y+1 floor pos\n  for( int i=0; i<SPH; i++ )\n  {    \n    float h = sphIntersect( P, R, sphere[i] );\n    if( h>0.0 && h<t )\n    {\n      s = i == iid ? tint * 2. : vec3(0.);\n      t = h;\n    }\n  }     \n  return max( vec3(0.), s);           \n}\n\nfloat occlusion( vec3 P, vec3 N )\n{\n  float s = 1.0;\n  for( int i=0; i<SPH; i++ )\n    s *= 1.0 - sphOcclusion( P, N, sphere[i] ); \n  return s;           \n}\n\nfloat sphLight( vec3 P, vec3 N, vec4 L)\n{\n  vec3 oc = L.xyz  - P;\n  float dst = sqrt( dot( oc, oc ));\n  vec3 dir = oc / dst;\n  \n  float c = dot( N, dir );\n  float s = L.w  / dst;\n  return max(0., c * s);\n}\n  \n//-------------------------------------------------------------------------------------------\n\nvec3 shade( vec3 I, vec3 P, vec3 N, float id, float iid )\n{\n  vec3 base = rand3( id, SEED );\n  vec3 wash = mix( vec3(0.9), base, 0.4);\n  vec3 hero = rand3( iid, SEED );\n  \n  vec3 ref = reflections( P, I - 2.*(dot(I,N))*N, hero, int(iid) );\n  float occ = occlusion( P, N );\n  float ocf = 1.-sqrt((0.5 + 0.5*-N.y)/(P.y+1.25))*.5; //floor occusion. 1.25 floor P.\n  float fre = clamp(1. + dot(I, N), 0., 1.); fre = (0.01+0.2*pow(fre,3.5));\n  vec3 dir = -(L.xyz  - P);\n    float len = dot(dir, dir);\n    dir = normalize(dir);\n  float thickness = abs(dot(I, N));\n  float sub = subsurface(dir, N, I, 0.5 - thickness * 0.3);\n  float lgh = sphLight( P, N, L)  *  areaShadow( P );\n  float inc = ( id == iid ? 1.0 : 0.0 );\n\n   \n  // Env light\n  vec3 C = vec3(1., 1., 1.) * occ * ocf * 0.5;\n  // C = vec3(0., 0., 0.);\n  // subsurface\n  if( id>-0.5 )\n  {\n      inc += sub / len * 3.;\n  }\n  // Sphere light\n  C += ( inc + lgh * 1.3 ) * hero;\n                  \n\n  // Reflections\n  C = mix( C, ref, fre );\n  \n  return C;\n}    \n\nvec3 trace( vec3 E, vec3 I, vec3 C, float px, float iid )\n{\n  float t = 1e20;\n  float id  = -1.0;\n  vec4  obj = vec4(0.);\n  for( int i=0; i<SPH; i++ )\n  {\n    vec4 sph = sphere[i];\n    float h = sphIntersect( E, I, sph ); \n    if( h>0.0 && h<t ) \n    {\n      t = h;\n      obj = sph;\n      id = float(i);\n    }\n  }\n              \n  if( id>-0.5 )\n  {\n    vec3 P = E + t*I;\n    vec3 N = normalize(P-obj.xyz);\n    C = shade( I, P, N, id, iid  );\n  }\n\n  return C;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec2 m = step(0.0001,iMouse.z) * iMouse.xy/iResolution.xy;\n    \n    //-----------------------------------------------------\n    \n    float time = iTime;\n    float an = 0.3*time - 7.0*m.x;\n    float sec = mod(time,1.);\n    \n    float spI = floor(mod(time,float(SPH)));\n    // float spI = \n    //-----------------------------------------------------\n    for( int i=0; i<SPH; i++ )\n    {\n      float ra = 0.4;\n      float id = float(i);\n      sphere[i] = vec4( mod( id, 3.0) - 1.0,\n                        mod( floor( id/3.0 ), 3.0 ) - .55,\n                        floor( id/9.0 )-1.0, ra );\n\n      if( i == int(spI) )\n      {\n        sphere[i].w += 0.025 * sin(sec*50.) / sqrt(sec) * ( 1.-sqrt(sec));\n        L = sphere[i];\n      }\n    }\n\n    //-----------------------------------------------------\n    \n    float fov = 1.8;\n    vec3 E = vec3( 3.5*sin(an), 2.0, 3.5*cos(an));\n    vec3 V = normalize( -E );\n    vec3 uu = normalize( cross( V, vec3(0., 1., 0.)));\n    vec3 vv = normalize( cross( uu, V));\n    vec3 I = normalize( p.x*uu + p.y*vv + fov*V );\n\n    float px = 1.0*(2.0/iResolution.y)*(1.0/fov);\n\n\n    //-----------------------------------------------------\n    \n    vec3 C = vec3(1.);\n\n    float tmin = 1e20;\n    float t = -(1.0+E.y)/I.y;\n    if( t>0.0 )\n    {\n        tmin = t;\n        vec3 pos = E + t*I;\n        vec3 nor = vec3(0.0,1.0,0.0);\n        C = shade( I, pos, nor, -1.0, spI );\n    }    \n    \n    C = trace( E, I, C, px, spI );\n    \n    // post\n    C = pow( C, vec3(0.41545) );   \n    C *= 0.5 + 0.5*pow(18.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.12);\n\n    fragColor = vec4( C, 1. );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXBRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[667, 667, 745, 745, 1153], [1155, 1155, 1214, 1214, 1383], [1385, 1385, 1446, 1446, 1688], [1690, 1690, 1742, 1742, 2566], [2719, 2719, 2754, 2754, 2826], [2828, 2828, 2859, 2859, 2981], [2983, 2983, 3039, 3039, 3359], [3361, 3361, 3396, 3396, 3516], [3518, 3518, 3559, 3559, 3723], [3822, 3822, 3881, 3881, 4829], [4835, 4835, 4894, 4894, 5295], [5297, 5297, 5354, 5354, 7061]], "test": "untested"}
{"id": "WdXBRr", "name": "Focus on the red bus.", "author": "sarbes", "description": "This shader uses mipmaps of a texture to get some kind of blur effect going. It has its drawbacks, but it can be scaled over the entire texture and it is quite fast.\n\nThere seems to be some resolution dependent issues I'll have to investigate. ", "tags": ["blur", "mipmap"], "likes": 3, "viewed": 551, "published": 3, "date": "1587576456", "time_retrieved": "2024-07-30T21:11:08.947189", "image_code": "#define iLodLimit 8\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float mixfactor = min(3.,length(vec2(uv.x-.25,uv.y-.4))*8.*(sin(iTime)+1.));\n    \n    vec3 color = texture( iChannel0, uv, 0. ).xyz;\n    \n    float j = 1.;\n    for (int i = 1; i < iLodLimit; i++) {\n        j *= .75;\n    \tvec3 lod = texture( iChannel0, uv, float(i) ).xyz;\n    \tcolor = mix(color,lod,mixfactor*j);\n        \n    }\n\tfragColor = vec4(color, 1.0 );\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXBRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 78, 78, 486]], "test": "untested"}
{"id": "3dffzn", "name": "Suminagashi", "author": "jarble", "description": "Another modification of my [url=https://www.shadertoy.com/view/3s2cW3]\"Marbled landscape\"[/url] fractal.\n\nClick and drag the mouse to zoom in!", "tags": ["fractal", "marbling", "suminagashi"], "likes": 1, "viewed": 361, "published": 3, "date": "1587575862", "time_retrieved": "2024-07-30T21:11:09.703168", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 9.0;\nconst float distortion_scale = mag*mag;\n\nconst int GREEN = 0;\nconst int BLUE = 1;\nconst int GRAY = 2;\nconst int YELLOW = 3;\nconst int WHITE = 4;\nconst int FOREST_GREEN = 5;\nconst int LIGHTBLUE = 6;\nconst int SKYBLUE = 7;\nconst int SNOW = 8;\nconst int WHITESMOKE = 9;\nconst int LIGHTGRAY = 10;\nconst int LIME = 11;\nconst int LIGHTYELLOW = 12;\nconst int BEIGE = 13;\nconst int SAND = 14;\nconst int TAN = 15;\nconst int ORANGE = 16;\nconst int RED = 17;\nconst int BLACK = 18;\nconst int DARKGRAY = 19;\nconst int ORANGERED = 20;\n\nconst int FOREST_BIOME = 5;\n\n//this function is from https://www.shadertoy.com/view/4djSRW\nint hash12(vec2 p,float num_colors)\n{\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return int(floor(fract((p3.x + p3.y) * p3.z)*num_colors));\n}\n    \nint magnify(vec2 fragCoord,float mag,float num_colors){\n    return hash12(floor(fragCoord/pow(3.0,mag)),num_colors);\n}\n\nivec4 get_neighbors(vec2 fragCoord,float mag,float colors){\n\treturn ivec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\n\nbool is_next_to(int color,ivec4 neighbors){\n\treturn (neighbors.x == color)\n        || (neighbors.y == color)\n        || (neighbors.z == color)\n        || (neighbors.w == color);\n}\n\nvec3 rgb(float r,float g,float b){\n\treturn vec3(r,g,b)/255.0;\n}\n\nvec3 get_color(int color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == FOREST_GREEN){\n    \treturn rgb(34.0,139.0,34.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n    else if(color == LIGHTBLUE){\n    \treturn rgb(173.0,216.0,230.0);\n   \t}\n    else if(color == SKYBLUE){\n    \treturn rgb(135.0,206.0,235.0);\n    }\n    else if(color == SNOW){\n    \treturn rgb(255.0,250.0,250.0);\n    }\n    else if(color == WHITESMOKE){\n    \treturn rgb(245.0,245.0,245.0);\n    }\n    else if(color == LIGHTGRAY){\n    \treturn rgb(211.0,211.0,211.0);\n    }\n    else if(color == LIME){\n    \treturn rgb(0.0,255.0,0.0);\n    }\n    else if(color == LIGHTYELLOW){\n    \treturn rgb(255.0,255.0,153.0);\n    }\n    else if(color == BEIGE){\n    \treturn rgb(245.0,245.0,220.0);\n    }\n    else if(color == TAN){\n    \treturn rgb(210.,180.,140.);\n    }\n    else if(color == ORANGE){\n    \treturn vec3(255,127,80)/255.0;\n    }\n    else if(color == RED){\n    \treturn vec3(1.0,0.0,0.0);\n   \t}\n    else if(color == DARKGRAY){\n    \treturn rgb(128.0,128.0,128.0);\n    }\n    else if(color == ORANGERED){\n    \treturn rgb(255.0,69.0,0.0);\n    }\n}\n\n\nint forest_biome(inout int color1, ivec4 neighbors){\n\tint BLUE = 0;\n    int GREEN = 1;\n    int YELLOW = 2;\n    int GRAY = 3;\n    int FOREST_GREEN = 4;\n    int WHITE = 5;\n    return (color1 == BLUE && is_next_to(GREEN,neighbors))\n        ? GREEN\n    :(color1 == YELLOW)\n        ? GREEN\n    :(color1 == WHITE && is_next_to(FOREST_GREEN,neighbors))\n        ? FOREST_GREEN\n    :(color1 == GRAY && is_next_to(GREEN,neighbors))\n        ? WHITE\n    :(color1 == GREEN && is_next_to(YELLOW,neighbors))\n        ? WHITE\n    :(color1 == GREEN && is_next_to(WHITE,neighbors))\n        ? FOREST_GREEN\n    :(color1 == FOREST_GREEN && is_next_to(GREEN,neighbors))\n        ? GREEN\n    :color1;\n\n}\n\n\nvoid biome(inout int color1, ivec4 neighbors,int biome){\n    color1 = forest_biome(color1,neighbors);\n}\n\nint biome(in vec2 fragCoord,float mag,float zoom,int colors[6],int biome1){\n    fragCoord *= zoom;\n\n    \n    float num_colors = float(colors.length());\n    float warp = 50.0;\n    float avg = (warp*(mag));\n    fragCoord += vec2(sin(fragCoord.y/avg),sin(fragCoord.x/avg))*mag*mag;\n\n    int color1 = magnify(fragCoord,mag,num_colors);\n    \n    ivec4 neighbors;\n    \n    while(mag > 1.0){\n        avg =(warp*(mag));\n        fragCoord += vec2(sin((fragCoord.y)/avg+iTime)*(3.0+sin(fragCoord.y/warp)*2.0),sin(fragCoord.x/avg+iTime)*(3.0+sin(fragCoord.x/warp)*2.0))*mag*mag;\n\n        neighbors = get_neighbors(fragCoord,mag,num_colors);\n    biome(color1, neighbors,biome1);\n    mag -= 1.0;\n    }\n    return colors[int(color1)];;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = mag*(((iMouse.x-iMouse.y)*2.0+iResolution.x)/iResolution.x);\n    fragCoord *= zoom;\n    fragCoord = fragCoord + floor(iTime*50.0)*vec2(mag,0.0);\n\n    //choose the biome here\n\tint biome = biome(fragCoord,mag,1.0,int[](BLUE,GREEN,YELLOW,GRAY,FOREST_GREEN,WHITE),FOREST_BIOME);\n    \n    fragColor = vec4(get_color(biome),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dffzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[619, 681, 718, 774, 922], [928, 928, 983, 983, 1046], [1048, 1048, 1107, 1107, 1312], [1315, 1315, 1358, 1358, 1494], [1496, 1496, 1530, 1530, 1559], [1561, 1561, 1587, 1587, 2944], [2947, 2947, 2999, 2999, 3625], [3628, 3628, 3684, 3684, 3731], [3733, 3733, 3808, 3808, 4456]], "test": "untested"}
{"id": "wsBcDt", "name": "Julia Set Explorer Angle Avg", "author": "andretugan", "description": "Explorer for the Julia set with keyboard and mouse support.\n\nColoring algorithm uses angle average (similar to an algorithm I found on Kerry Mitchell's website) and palettes from Inigo Quilez.", "tags": ["2d", "fractal", "julia", "interactive"], "likes": 7, "viewed": 346, "published": 3, "date": "1587570881", "time_retrieved": "2024-07-30T21:11:10.630688", "image_code": "//\tAuthor: https://www.shadertoy.com/user/andretugan\n//\tCreative Commons Attribution-NonCommercial 3.0 Unported License\n//\thttps://creativecommons.org/licenses/by-nc/3.0\n//\t\n//  Main image can be dragged with a mouse, the minimap can be clicked\n//\tM - toggle minimap\n// \tA, W, S, D or cursor keys - move\n// \tZ, X, PAGE_UP, PAGE_DOWN - zoom \n// \tQ, E - rotate\n//  SHIFT - hold with move, zoom and rotate for finer movement\n//  SPACE - reset camera\n//\n//\tRequires WebGL 2.0 support. If you are using Safari, it might be disabled by default.  \n//\n//\tThe coloring method is computing atan(y, x) during the iterations and\n//\tuses their average to seed the color palette.\n//\tIt is similar to the weighted average algorithm described here:\n//\thttp://www.kerrymitchellart.com/tutorials/formulas2/uf2-2.htm\n//\tI'm not using weighted average to improve FPS, and it also looks nice.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n    // See Buffer A for the actual code\n    vec3 col = texelFetch(iChannel1, ivec2(fragCoord - 0.5), 0).rgb;\n    \n    // Darken the edges of the image\n    vec2 uv01 = fragCoord / iResolution.xy;\n    float vignette = .5 + .5 * pow(16.0 * uv01.x * uv01.y * (1. - uv01.x) * (1. - uv01.y), .2);\n    col = mix(vec3(0.), col, vignette);\n    \n    // Gamma correction\n    col = pow(col, vec3(0.45));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//\tAuthor: https://www.shadertoy.com/user/andretugan\n//\tCreative Commons Attribution-NonCommercial 3.0 Unported License\n//\thttps://creativecommons.org/licenses/by-nc/3.0\n//\t\n//  Main image can be dragged with a mouse, the minimap can be clicked\n//\tM - toggle Mandelbrot minimap\n//\tJ - toggle Julia minimap\n// \tA, W, S, D or cursor keys - move\n// \tZ, X, PAGE_UP, PAGE_DOWN - zoom \n// \tQ, E - rotate\n//  SHIFT - hold with move, zoom and rotate for finer movement\n//  SPACE - reset camera\n//\n//\tRequires WebGL 2.0 support. If you are using Safari, it might be disabled by default.  \n//\n//\tThe coloring method is computing atan(y, x) during the iterations and\n//\tuses their average to seed the color palette.\n//\tIt is similar to the weighted average algorithm described here:\n//\thttp://www.kerrymitchellart.com/tutorials/formulas2/uf2-2.htm\n//\tI'm not using weighted average to improve FPS, and it also looks nice.\n\n#define ANTI_ALIASING 2\n\n#define M_MINIMAP_SCALE 0.25\n#define M_MINIMAP_OFFSET_X 0.9\n#define M_MINIMAP_OFFSET_Y 0.7\n\n#define M_MINIMAP_LEFT_BOUND -2.2\n#define M_MINIMAP_RIGHT_BOUND 1.\n#define M_MINIMAP_TOP_BOUND 1.3\n#define M_MINIMAP_BOTTOM_BOUND -1.3\n\n#define J_MINIMAP_SCALE 0.25\n#define J_MINIMAP_OFFSET_X 0.75\n#define J_MINIMAP_OFFSET_Y -0.7\n\n#define J_MINIMAP_LEFT_BOUND -2.2\n#define J_MINIMAP_RIGHT_BOUND 2.2\n#define J_MINIMAP_TOP_BOUND 1.3\n#define J_MINIMAP_BOTTOM_BOUND -1.3\n\n#define MINIMAP_FADE 0.5\n\n#define M_PI 3.14159265358\n#define M_2_PI (2. * M_PI)\n#define M_PI_2 (0.5 * M_PI)\n\n#define ESCAPE_RADIUS 500.\n\n//\tFor a more detailed deep zoom increase this\n#define MAX_STEPS 200\n\n#define KEY_SHIFT 16\n#define KEY_CTRL 17\n#define KEY_SPACE 32\n#define KEY_PAGE_UP 33\n#define KEY_PAGE_DOWN 34\n#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n#define KEY_A 65\n#define KEY_D 68\n#define KEY_E 69\n#define KEY_J 74\n#define KEY_M 77\n#define KEY_Q 81\n#define KEY_S 83\n#define KEY_W 87\n#define KEY_X 88\n#define KEY_Y 89\n#define KEY_Z 90\n\n//  Color palettes based on article by Inigo Quilez\n// \thttps://iquilezles.org/articles/palettes\nvec3 GetColor1(float t)\n{\n    return vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5) *\n        cos(M_2_PI * (t * vec3(1., 1., 1.) + vec3(0.00, 0.33, 0.67)));\n}\n\nvec3 GetColor2(float t)\n{\n    return vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5) *\n        cos(M_2_PI * (t * vec3(1., 1., 1.) + vec3(0.0, 0.1, 0.2)));\n}\n\nvec3 GetColor3(float t)\n{\n    return vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5) *\n        cos(M_2_PI * (t * vec3(1., 1., 1.) + vec3(0.3, 0.2, 0.2)));\n}\n\nvec3 GetColor4(float t)\n{\n    return vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5) *\n        cos(M_2_PI * (t * vec3(1.0, 1.0, 0.5) + vec3(0.8, 0.9, 0.3)));\n}\n\nvec3 GetColor5(float t)\n{\n    return vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5) *\n        cos(M_2_PI * (t * vec3(1.0, 0.7, 0.4) + vec3(0.0, 0.15, 0.2)));\n}\n\nvec3 GetColor6(float t)\n{\n    return vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5) *\n        cos(M_2_PI * (t * vec3(2.0, 1.0, 0.0) + vec3(0.5, 0.2, 0.25)));\n}\n\nvec3 GetColor7(float t)\n{\n    return vec3(0.8, 0.5, 0.4) + vec3(0.2, 0.4, 0.2) *\n        cos(M_2_PI * (t * vec3(2.0, 1.0, 1.0) + vec3(0.0, 0.25, 0.25)));\n}\n\nbool NoComputationNeeded(vec2 c) {\t\n    // Do not compute inside the large bulbs\n    // Based on https://www.shadertoy.com/view/4sdXWX\n    float c2 = dot(c, c);\n    if ((256.0 * c2 - 96.0) * c2 + 32.0 * c.x < 3.0) return true;    \n    if (16.0 * (c2 + 2. * c.x + 1.) < 1.0) return true;        \n    return false;\n}\n\nvec2 FromGlobalToMMinimap(vec2 global) {\n    vec2 offset = vec2(M_MINIMAP_OFFSET_X * iResolution.x / iResolution.y, M_MINIMAP_OFFSET_Y);\n\treturn (global - offset) / M_MINIMAP_SCALE;\n}\n\nvec2 FromMMinimapToGlobal(vec2 minimap) {\n    vec2 offset = vec2(M_MINIMAP_OFFSET_X * iResolution.x / iResolution.y, M_MINIMAP_OFFSET_Y);\n\treturn M_MINIMAP_SCALE * minimap + offset;\n}\n\nvec2 FromGlobalToJMinimap(vec2 global) {\n    vec2 offset = vec2(J_MINIMAP_OFFSET_X * iResolution.x / iResolution.y, J_MINIMAP_OFFSET_Y);\n\treturn (global - offset) / J_MINIMAP_SCALE;\n}\n\nvec2 FromJMinimapToGlobal(vec2 minimap) {\n    vec2 offset = vec2(J_MINIMAP_OFFSET_X * iResolution.x / iResolution.y, J_MINIMAP_OFFSET_Y);\n\treturn J_MINIMAP_SCALE * minimap + offset;\n}\n\nvec3 Draw(vec2 z, vec2 c) {    \n    if (NoComputationNeeded(c)) return vec3(0.);\n         \n    float z2 = 0.;       \n    float sum = 0.0;\n    float prev_sum = 0.0;    \n    int iter = 0;\n    while (z2 / ESCAPE_RADIUS < ESCAPE_RADIUS) {\n        if (iter == MAX_STEPS) return vec3(0.);    \t\n        ++iter;\n   \n        // z = z^2 + c\n\t\tz = vec2(z.x*z.x - z.y*z.y, 2.*z.x*z.y) + c;\n        z2 = dot(z, z);\n        \n        // For coloring\n        prev_sum = sum;\n        sum += atan(z.y, z.x);\n    } \n        \n    // The fractional iteration by which we overshot the escape radius    \n    float overshot = log2(0.5*log2(z2)/log2(ESCAPE_RADIUS));\n    \n    // Compute real values for sum and iter at the point of crossing\n    // the escape radius through linear interpolation\n\tfloat real_sum = mix(sum, prev_sum, overshot);\n    float real_iter = float(iter) - overshot;      \n    float avg = real_sum / real_iter;     \n        \n    //float val = 2. / (1. + exp(-real_iter * 0.07)) - 1.;\n\treturn GetColor2(avg);\n    //return GetColor5(avg * 0.45);// * val;\t\t\t\t\t\n}\n\nbool InMMinimap(vec2 uv_m) {\n    return uv_m.x > M_MINIMAP_LEFT_BOUND && uv_m.x < M_MINIMAP_RIGHT_BOUND &&\n        uv_m.y > M_MINIMAP_BOTTOM_BOUND && uv_m.y < M_MINIMAP_TOP_BOUND;\n}\n\nbool InJMinimap(vec2 uv_m) {\n    return uv_m.x > J_MINIMAP_LEFT_BOUND && uv_m.x < J_MINIMAP_RIGHT_BOUND &&\n        uv_m.y > J_MINIMAP_BOTTOM_BOUND && uv_m.y < J_MINIMAP_TOP_BOUND;\n}\n\nvec3 DrawMainImage(vec2 fragCoord, vec2 center, float zoom, mat2 rotation_matrix, vec2 c) {\n    // Split each pixel into an ANTI_ALIASING x ANTI_ALIASING grid\n    vec3 col = vec3(0.);\n    int num_samples = 0;\n    for (int i = 0; i < ANTI_ALIASING; ++i) {\n    \tfor (int j = 0; j <= ANTI_ALIASING; ++j) {\n    \t\t++num_samples;\n\n            // Apply camera transforms\n            vec2 coord = fragCoord + vec2(float(i)/float(ANTI_ALIASING), float(j)/float(ANTI_ALIASING)); \n            vec2 uv = (2.*coord - iResolution.xy)/iResolution.y;            \n            uv *= rotation_matrix;\n            uv /= zoom;\n            uv += center;\n            \n            col += Draw(uv, c);\n        }\n    }\n\n\tcol /= float(num_samples); \n\n \treturn col;   \n}\n\nvec3 DrawMMinimap(vec2 fragCoord, vec2 center, float zoom,\n                  mat2 rotation_matrix, vec2 c, out float minimap_opacity) {\n\tvec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;    \n    vec2 uv_m = FromGlobalToMMinimap(uv);                    \n     \n    \n    vec3 col = vec3(0.);\n    minimap_opacity = 0.;\n    \n    if (InMMinimap(uv_m)) {\n        // Draw the Mandelbrot set for the minimap\n    \tcol = Draw(vec2(0.), uv_m);\n                                                       \n        vec2 offset = uv_m - c;        \n        float marker_opacity = smoothstep(0.005, 0.0, dot(offset, offset));\n        col = mix(col, vec3(1., .1, .1), marker_opacity);        \n        \n        // Minimap border fade out\n        minimap_opacity = 1.;\n        minimap_opacity *= smoothstep(0., MINIMAP_FADE, uv_m.x - M_MINIMAP_LEFT_BOUND);\n        minimap_opacity *= smoothstep(0., MINIMAP_FADE, M_MINIMAP_RIGHT_BOUND - uv_m.x);\n        minimap_opacity *= smoothstep(0., MINIMAP_FADE, M_MINIMAP_TOP_BOUND - uv_m.y);\n        minimap_opacity *= smoothstep(0., MINIMAP_FADE, uv_m.y - M_MINIMAP_BOTTOM_BOUND);        \n    } \n\treturn col;\n}\n\nvec3 DrawJMinimap(vec2 fragCoord, vec2 center, float zoom,\n                  mat2 rotation_matrix, vec2 c, out float minimap_opacity) {\n\tvec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;    \n    vec2 uv_j = FromGlobalToJMinimap(uv);                    \n     \n    \n    vec3 col = vec3(0.);\n    minimap_opacity = 0.;\n    \n    if (InJMinimap(uv_j)) {\n        // Draw the Julia set for the minimap\n    \tcol = Draw(uv_j, c);\n                                               \n        // Draw the rectangular framing on the minimap        \n        vec2 offset = uv_j - center;\n        vec2 framing_uv_j = rotation_matrix * offset * zoom; \n        float aspect = iResolution.x / iResolution.y;\n        float dx = aspect - abs(framing_uv_j.x);\n        float dy = 1. - abs(framing_uv_j.y);\n        float thickness = zoom * 0.03;       \n        float outside_rectangle = max(smoothstep(thickness, 0., dx), smoothstep(thickness, 0., dy));        \n        float inside_rectangle = min(smoothstep(-thickness, 0., dx), smoothstep(-thickness, 0., dy));\n        float framing_opacity = inside_rectangle * outside_rectangle;\n        // When the zoom is high, draw a point, so that the framing does not degenerate into nothing.\n        framing_opacity += smoothstep(40., 70., zoom) * smoothstep(0.005, 0.0, dot(offset, offset));\n        col = mix(col, vec3(1., .1, .1), framing_opacity);        \n        \n        // Minimap border fade out\n        minimap_opacity = 1.;\n        minimap_opacity *= smoothstep(0., MINIMAP_FADE, uv_j.x - J_MINIMAP_LEFT_BOUND);\n        minimap_opacity *= smoothstep(0., MINIMAP_FADE, J_MINIMAP_RIGHT_BOUND - uv_j.x);\n        minimap_opacity *= smoothstep(0., MINIMAP_FADE, J_MINIMAP_TOP_BOUND - uv_j.y);\n        minimap_opacity *= smoothstep(0., MINIMAP_FADE, uv_j.y - J_MINIMAP_BOTTOM_BOUND);        \n    } \n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {        \n    // Read information pixels in the left top corner\n    ivec2 camera_pixel = ivec2(0, iResolution.y - 0.5);\n    ivec2 state_pixel = ivec2(1, iResolution.y - 0.5);\n    ivec2 julia_pixel = ivec2(0, iResolution.y - 1.5);\n    \n    // camera.xy - camera position\n    // camera.z - zoom exponent = log(zoom) + a\n    // camera.w - camera rotation in radians\n    vec4 camera = texelFetch(iChannel1, camera_pixel, 0);\n    \n    // state.xy - position from where mouse dragging started\n    // state.z - currently dragging if 1., not dragging if 0.\n    // state.w - camera controlled manually if 1., automated if 0.\n    vec4 state = texelFetch(iChannel1, state_pixel, 0);\n    \n    // julia.xy - Julia set seed\n    // julia.z - using default Julia seed if 0., user selected if 1.\n    vec4 julia = texelFetch(iChannel1, julia_pixel, 0);\n            \n    if (state.w <= 0.) {\n        // Automated camera movement\n        camera.xy = vec2(-0.457, 0.26);\n    \tcamera.z = 4. + 2. * sin(iTime * 0.1);\n       \tcamera.w = M_2_PI * sin(iTime * 0.01);\n    }       \n    \n    if (julia.z <= 0.) {\n        // Default Julia set seed\n    \tjulia.z = 1.0;\n        julia.x = -0.6;\n        julia.y = 0.5;\n    }\n    \n    // Camera zoom and rotation\n    float zoom = exp(camera.z - 1.);    \n    float sin_rotation = sin(camera.w);\n    float cos_rotation = cos(camera.w);\n    mat2 rotation_matrix = mat2(cos_rotation, sin_rotation, -sin_rotation, cos_rotation);\n    \n    // Mandelbrot and Julia minimaps toggle flags\n    bool m_minimap_enabled = texelFetch(iChannel0, ivec2(KEY_M, 2), 0).x > 0.;    \n    bool j_minimap_enabled = texelFetch(iChannel0, ivec2(KEY_J, 2), 0).x > 0.;    \n     \n    // Update information pixels\n    if (ivec2(fragCoord - 0.5) == camera_pixel || ivec2(fragCoord - 0.5) == state_pixel) {\n        vec4 old_camera = camera;\n        \n        // Update camera position\n        float factor = 1.0 - 0.9 * texelFetch(iChannel0, ivec2(KEY_SHIFT, 0), 0).x;\n        \n        vec2 xy_change = vec2(0.);\n       \txy_change.x -= 0.1 / zoom * factor * texelFetch(iChannel0, ivec2(KEY_LEFT, 0), 0).x;\n        xy_change.x -= 0.1 / zoom * factor * texelFetch(iChannel0, ivec2(KEY_A, 0), 0).x;\n        xy_change.x += 0.1 / zoom * factor * texelFetch(iChannel0, ivec2(KEY_RIGHT, 0), 0).x;\n        xy_change.x += 0.1 / zoom * factor * texelFetch(iChannel0, ivec2(KEY_D, 0), 0).x;\n        xy_change.y -= 0.1 / zoom * factor * texelFetch(iChannel0, ivec2(KEY_DOWN, 0), 0).x;        \n        xy_change.y -= 0.1 / zoom * factor * texelFetch(iChannel0, ivec2(KEY_S, 0), 0).x;        \n        xy_change.y += 0.1 / zoom * factor * texelFetch(iChannel0, ivec2(KEY_UP, 0), 0).x;\n        xy_change.y += 0.1 / zoom * factor * texelFetch(iChannel0, ivec2(KEY_W, 0), 0).x;\n        \n        camera.xy += transpose(rotation_matrix) * xy_change;\n        \n        camera.z -= 0.1 * factor * texelFetch(iChannel0, ivec2(KEY_PAGE_UP, 0), 0).x;        \n        camera.z -= 0.1 * factor * texelFetch(iChannel0, ivec2(KEY_X, 0), 0).x;        \n        camera.z += 0.1 * factor * texelFetch(iChannel0, ivec2(KEY_PAGE_DOWN, 0), 0).x;\n        camera.z += 0.1 * factor * texelFetch(iChannel0, ivec2(KEY_Z, 0), 0).x;        \n        camera.w -= M_PI * 0.01 * factor * texelFetch(iChannel0, ivec2(KEY_E, 0), 0).x;\n        camera.w += M_PI * 0.01 * factor * texelFetch(iChannel0, ivec2(KEY_Q, 0), 0).x;\n                \n        if (iMouse.z > 0.) {\n            vec2 mouse_uv = (2.*iMouse.xy - iResolution.xy)/iResolution.y;    \n            vec2 mouse_uv_j = FromGlobalToJMinimap(mouse_uv);            \n\n            if (state.z > 0.) {\n                // The image is being dragged with a mouse\n            \tcamera.xy = state.xy - transpose(rotation_matrix) * mouse_uv / zoom;                \t\n            } else if (j_minimap_enabled && InJMinimap(mouse_uv_j)) {\n                // Julia minimap was clicked\n            \tcamera.xy = mouse_uv_j;\n            }                    \n        }                \n\t\n        if (camera != old_camera) {\n        \tstate.w = 1.0;\n        } else if (texelFetch(iChannel0, ivec2(KEY_SPACE, 0), 0).x > 0.0) {\n        \tstate.w = 0.0;\n        }\n        \n        // Update dragging state\n        if (ivec2(fragCoord - 0.5) == state_pixel) {                                \n            if (iMouse.z > 0.) {\n                vec2 mouse_uv = (2.*iMouse.xy - iResolution.xy)/iResolution.y;\n                if ((!m_minimap_enabled || !InMMinimap(FromGlobalToMMinimap(mouse_uv))) &&\n                    (!j_minimap_enabled || !InJMinimap(FromGlobalToJMinimap(mouse_uv)))) {\n                    if (state.z <= 0.) { // Not dragging\n                        // Set flag that we are now dragging\n                        state.z = 1.0;\n                        // Set coordinates where we started dragging\n                        state.xy = camera.xy + transpose(rotation_matrix) * mouse_uv / zoom;\n                    }\n                }            \n            } else {\n                // Set flag that we are not dragging\n                state.z = 0.0;        \n            }\n\n            fragColor = state;            \n        } else {        \n        \tfragColor = camera;\n        }\n        \n        return;\n    }\n    \n    // Update Julia set seed\n    if (ivec2(fragCoord - 0.5) == julia_pixel) {\n        if (m_minimap_enabled && iMouse.z > 0.) {\n            vec2 mouse_uv = (2.*iMouse.xy - iResolution.xy)/iResolution.y;                \n            vec2 mouse_uv_m = FromGlobalToMMinimap(mouse_uv);\n            if (InMMinimap(mouse_uv_m)) {\n\t\t\t\tjulia.z = 1.0;\n            \tjulia.xy = mouse_uv_m;\n            }\n        }                \n    \tfragColor = julia;\n        return;\n    }\n         \n    vec3 col = DrawMainImage(fragCoord, camera.xy, zoom, rotation_matrix, julia.xy);\n        \n    if (m_minimap_enabled) {\n    \tfloat minimap_opacity = 0.;\n    \tvec3 minimap_col = DrawMMinimap(fragCoord, camera.xy, zoom,\n                                       rotation_matrix, julia.xy, minimap_opacity);             \t    \n  \t\tcol = mix(col, minimap_col, minimap_opacity);           \n    }\n    \n    if (j_minimap_enabled) {\n    \tfloat minimap_opacity = 0.;\n    \tvec3 minimap_col = DrawJMinimap(fragCoord, camera.xy, zoom,\n                                       rotation_matrix, julia.xy, minimap_opacity);             \t    \n  \t\tcol = mix(col, minimap_col, minimap_opacity);           \n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsBcDt.jpg", "access": "api", "license": "cc-by-3.0", "functions": [[873, 873, 930, 974, 1388]], "test": "untested"}
{"id": "tsSyWc", "name": "Mandelbrot Explorer Angle Avg", "author": "andretugan", "description": "Explorer for the Mandelbrot set with keyboard and mouse support.\n\nColoring algorithm uses angle average (similar to an algorithm I found on Kerry Mitchell's website) and palettes from Inigo Quilez.", "tags": ["2d", "fractal", "mandelbrot", "interactive"], "likes": 15, "viewed": 652, "published": 3, "date": "1587570786", "time_retrieved": "2024-07-30T21:11:11.547237", "image_code": "//\tAuthor: https://www.shadertoy.com/user/andretugan\n//\tCreative Commons Attribution-NonCommercial 3.0 Unported License\n//\thttps://creativecommons.org/licenses/by-nc/3.0\n//\t\n//  Main image can be dragged with a mouse, the minimap can be clicked\n//\tM - toggle minimap\n// \tA, W, S, D or cursor keys - move\n// \tZ, X, PAGE_UP, PAGE_DOWN - zoom \n// \tQ, E - rotate\n//  SPACE - reset camera\n//\n//\tRequires WebGL 2.0 support. If you are using Safari, it might be disabled by default.  \n//\n//\tThe coloring method is computing atan(y, x) during the iterations and\n//\tuses their average to seed the color palette.\n//\tIt is similar to the weighted average algorithm described here:\n//\thttp://www.kerrymitchellart.com/tutorials/formulas2/uf2-2.htm\n//\tI'm not using weighted average to improve FPS, and it also looks nice.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n    // See Buffer A for the actual code\n    vec3 col = texelFetch(iChannel1, ivec2(fragCoord - 0.5), 0).rgb;\n    \n    // Darken the edges of the image\n    vec2 uv01 = fragCoord / iResolution.xy;\n    float vignette = .5 + .5 * pow(16.0 * uv01.x * uv01.y * (1. - uv01.x) * (1. - uv01.y), .2);\n    col = mix(vec3(0.), col, vignette);\n    \n    // Gamma correction\n    col = pow(col, vec3(0.45));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//\tAuthor: https://www.shadertoy.com/user/andretugan\n//\tCreative Commons Attribution-NonCommercial 3.0 Unported License\n//\thttps://creativecommons.org/licenses/by-nc/3.0\n//\t\n//  Main image can be dragged with a mouse, the minimap can be clicked\n//\tM - toggle minimap\n// \tA, W, S, D or cursor keys - move\n// \tZ, X, PAGE_UP, PAGE_DOWN - zoom \n// \tQ, E - rotate\n//  SPACE - reset camera\n//\n//\tRequires WebGL 2.0 support. If you are using Safari, it might be disabled by default.  \n//\n//\tThe coloring method is computing atan(y, x) during the iterations and\n//\tuses their average to seed the color palette.\n//\tIt is similar to the weighted average algorithm described here:\n//\thttp://www.kerrymitchellart.com/tutorials/formulas2/uf2-2.htm\n//\tI'm not using weighted average to improve FPS, and it also looks nice.\n\n#define ANTI_ALIASING 2\n\n#define MINIMAP_SCALE 0.25\n#define MINIMAP_OFFSET_X 0.9\n#define MINIMAP_OFFSET_Y -0.7\n#define MINIMAP_LEFT_BOUND -2.2\n#define MINIMAP_RIGHT_BOUND 1.\n#define MINIMAP_TOP_BOUND 1.3\n#define MINIMAP_BOTTOM_BOUND -1.3\n#define MINIMAP_FADE 0.5\n\n#define M_PI 3.14159265358\n#define M_PI_2 (0.5 * M_PI)\n\n#define ESCAPE_RADIUS 500.\n\n//\tFor a more detailed deep zoom increase this\n#define MAX_STEPS 200\n\n#define KEY_SHIFT 16\n#define KEY_CTRL 17\n#define KEY_SPACE 32\n#define KEY_PAGE_UP 33\n#define KEY_PAGE_DOWN 34\n#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n#define KEY_A 65\n#define KEY_D 68\n#define KEY_E 69\n#define KEY_M 77\n#define KEY_Q 81\n#define KEY_S 83\n#define KEY_W 87\n#define KEY_X 88\n#define KEY_Y 89\n#define KEY_Z 90\n\n//  Color palettes based on article by Inigo Quilez\n// \thttps://iquilezles.org/articles/palettes\nvec3 GetColor1(float t)\n{\n    return vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5) *\n        cos(2. * M_PI * (t * vec3(1., 1., 1.) + vec3(0.00, 0.33, 0.67)));\n}\n\nvec3 GetColor2(float t)\n{\n    return vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5) *\n        cos(2. * M_PI * (t * vec3(1., 1., 1.) + vec3(0.0, 0.1, 0.2)));\n}\n\nvec3 GetColor3(float t)\n{\n    return vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5) *\n        cos(2. * M_PI * (t * vec3(1., 1., 1.) + vec3(0.3, 0.2, 0.2)));\n}\n\nvec3 GetColor4(float t)\n{\n    return vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5) *\n        cos(2. * M_PI * (t * vec3(1.0, 1.0, 0.5) + vec3(0.8, 0.9, 0.3)));\n}\n\nvec3 GetColor5(float t)\n{\n    return vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5) *\n        cos(2. * M_PI * (t * vec3(1.0, 0.7, 0.4) + vec3(0.0, 0.15, 0.2)));\n}\n\nvec3 GetColor6(float t)\n{\n    return vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5) *\n        cos(2. * M_PI * (t * vec3(2.0, 1.0, 0.0) + vec3(0.5, 0.2, 0.25)));\n}\n\nvec3 GetColor7(float t)\n{\n    return vec3(0.8, 0.5, 0.4) + vec3(0.2, 0.4, 0.2) *\n        cos(2. * M_PI * (t * vec3(2.0, 1.0, 1.0) + vec3(0.0, 0.25, 0.25)));\n}\n\nbool NoComputationNeeded(vec2 c) {\t\n    // Do not compute inside the large bulbs\n    // Based on https://www.shadertoy.com/view/4sdXWX\n    float c2 = dot(c, c);\n    if ((256.0 * c2 - 96.0) * c2 + 32.0 * c.x < 3.0) return true;    \n    if (16.0 * (c2 + 2. * c.x + 1.) < 1.0) return true;        \n    return false;\n}\n\nvec2 FromGlobalToMinimap(vec2 global) {\n    vec2 offset = vec2(MINIMAP_OFFSET_X * iResolution.x / iResolution.y, MINIMAP_OFFSET_Y);\n\treturn (global - offset) / MINIMAP_SCALE;\n}\n\nvec2 FromMinimapToGlobal(vec2 minimap) {\n    vec2 offset = vec2(MINIMAP_OFFSET_X * iResolution.x / iResolution.y, MINIMAP_OFFSET_Y);\n\treturn MINIMAP_SCALE * minimap + offset;\n}\n\nvec3 Draw(vec2 z, vec2 c) {    \n    if (NoComputationNeeded(c)) return vec3(0.);\n         \n    float z2 = 0.;       \n    float sum = 0.0;\n    float prev_sum = 0.0;    \n    int iter = 0;\n    while (z2 / ESCAPE_RADIUS < ESCAPE_RADIUS) {\n        if (iter == MAX_STEPS) return vec3(0.);    \t\n        ++iter;\n   \n\t\tz = vec2(z.x*z.x - z.y*z.y, 2.*z.x*z.y) + c;\n        z2 = dot(z, z);                       \n        prev_sum = sum;\n        sum += atan(z.y, z.x);\n    } \n        \n    // The fractional iteration by which we overshot the escape radius    \n    float overshot = log2(0.5*log2(z2)/log2(ESCAPE_RADIUS));\n    \n    // Compute real values for sum and iter at the point of crossing\n    // the escape radius through linear interpolation\n\tfloat real_sum = mix(sum, prev_sum, overshot);\n    float real_iter = float(iter) - overshot;      \n    float avg = real_sum / real_iter;     \n        \n    // float val = 2. / (1. + exp(-real_iter * 0.07)) - 1.;\n    // return GetColor5(0.3 + 0.3 * avg); \n\treturn GetColor2(avg);// * val;\t\t\t\t\t\n}\n\nbool InMinimap(vec2 uv_m) {\n    return uv_m.x > MINIMAP_LEFT_BOUND && uv_m.x < MINIMAP_RIGHT_BOUND &&\n        uv_m.y > MINIMAP_BOTTOM_BOUND && uv_m.y < MINIMAP_TOP_BOUND;\n}\n\nvec3 DrawMainImage(vec2 fragCoord, vec2 center, float zoom, mat2 rotation_matrix) {\n    // Split each pixel into an ANTI_ALIASING x ANTI_ALIASING grid\n    vec3 col = vec3(0.);\n    int num_samples = 0;\n    for (int i = 0; i < ANTI_ALIASING; ++i) {\n    \tfor (int j = 0; j <= ANTI_ALIASING; ++j) {\n    \t\t++num_samples;\n\n            vec2 coord = fragCoord + vec2(float(i)/float(ANTI_ALIASING), float(j)/float(ANTI_ALIASING)); \n            vec2 uv = (2.*coord - iResolution.xy)/iResolution.y;            \n            uv *= rotation_matrix;\n            uv /= zoom;\n            uv += center;\n            \n            col += Draw(vec2(0.), uv);\n        }\n    }\n\n\tcol /= float(num_samples); \n\n \treturn col;   \n}\n\nvec3 DrawMinimap(vec2 fragCoord, vec2 center, float zoom,\n                 mat2 rotation_matrix, out float minimap_opacity) {\n\tvec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;    \n    vec2 uv_m = FromGlobalToMinimap(uv);                    \n     \n    \n    vec3 col = vec3(0.);\n    minimap_opacity = 0.;\n    \n    if (InMinimap(uv_m)) {\n        // Draw the Mandelbrot set for the minimap\n    \tcol = Draw(vec2(0.), uv_m);\n                                               \n        // Draw the rectangular framing on the minimap        \n        vec2 offset = uv_m - center;\n        vec2 framing_uv_m = rotation_matrix * offset * zoom; \n        float aspect = iResolution.x / iResolution.y;\n        float dx = aspect - abs(framing_uv_m.x);\n        float dy = 1. - abs(framing_uv_m.y);\n        float thickness = zoom * 0.03;       \n        float outside_rectangle = max(smoothstep(thickness, 0., dx), smoothstep(thickness, 0., dy));        \n        float inside_rectangle = min(smoothstep(-thickness, 0., dx), smoothstep(-thickness, 0., dy));\n        float framing_opacity = inside_rectangle * outside_rectangle;\n        // When the zoom is high, draw a point, so that the framing does not degenerate into nothing.\n        framing_opacity += smoothstep(40., 70., zoom) * smoothstep(0.005, 0.0, dot(offset, offset));\n        col = mix(col, vec3(1., .1, .1), framing_opacity);        \n        \n        // Minimap border fade out\n        minimap_opacity = 1.;\n        minimap_opacity *= smoothstep(0., MINIMAP_FADE, uv_m.x - MINIMAP_LEFT_BOUND);\n        minimap_opacity *= smoothstep(0., MINIMAP_FADE, MINIMAP_RIGHT_BOUND - uv_m.x);\n        minimap_opacity *= smoothstep(0., MINIMAP_FADE, MINIMAP_TOP_BOUND - uv_m.y);\n        minimap_opacity *= smoothstep(0., MINIMAP_FADE, uv_m.y - MINIMAP_BOTTOM_BOUND);        \n    } \n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {        \n    // Process inputs\n    ivec2 camera_pixel = ivec2(0, iResolution.y - 0.5);\n    ivec2 state_pixel = ivec2(1, iResolution.y - 0.5);\n    \n    // camera.xy - camera position\n    // camera.z - zoom exponent = log(zoom) + a\n    // camera.w - camera rotation in radians\n    vec4 camera = texelFetch(iChannel1, camera_pixel, 0);\n    \n    // state.xy - position from where mouse dragging started\n    // state.z - currently dragging if 1., not dragging if 0.\n    // state.w - camera controlled manually if 1., automated if 0.\n    vec4 state = texelFetch(iChannel1, state_pixel, 0);\n            \n    if (state.w <= 0.) {\n        camera.xy = vec2(-0.2412, 0.8408);\n    \tcamera.z = 6. + 3. * sin(iTime * 0.1);\n       \tcamera.w = 2. * M_PI * sin(iTime * 0.01);\n    }        \n    \n    float zoom = exp(camera.z - 1.);\n    \n    float sin_rotation = sin(camera.w);\n    float cos_rotation = cos(camera.w);\n    mat2 rotation_matrix = mat2(cos_rotation, sin_rotation, -sin_rotation, cos_rotation);\n    bool minimap_enabled = texelFetch(iChannel0, ivec2(KEY_M, 2), 0).x > 0.;    \n    \n    if (ivec2(fragCoord - 0.5) == camera_pixel || ivec2(fragCoord - 0.5) == state_pixel) {\n        vec4 old_camera = camera;\n        \n        float factor = 1.0 - 0.9 * texelFetch(iChannel0, ivec2(KEY_SHIFT, 0), 0).x;\n        \n        vec2 xy_change = vec2(0.);\n       \txy_change.x -= 0.1 / zoom * factor * texelFetch(iChannel0, ivec2(KEY_LEFT, 0), 0).x;\n        xy_change.x -= 0.1 / zoom * factor * texelFetch(iChannel0, ivec2(KEY_A, 0), 0).x;\n        xy_change.x += 0.1 / zoom * factor * texelFetch(iChannel0, ivec2(KEY_RIGHT, 0), 0).x;\n        xy_change.x += 0.1 / zoom * factor * texelFetch(iChannel0, ivec2(KEY_D, 0), 0).x;\n        xy_change.y -= 0.1 / zoom * factor * texelFetch(iChannel0, ivec2(KEY_DOWN, 0), 0).x;        \n        xy_change.y -= 0.1 / zoom * factor * texelFetch(iChannel0, ivec2(KEY_S, 0), 0).x;        \n        xy_change.y += 0.1 / zoom * factor * texelFetch(iChannel0, ivec2(KEY_UP, 0), 0).x;\n        xy_change.y += 0.1 / zoom * factor * texelFetch(iChannel0, ivec2(KEY_W, 0), 0).x;\n        \n        camera.xy += transpose(rotation_matrix) * xy_change;\n        \n        camera.z -= 0.1 * factor * texelFetch(iChannel0, ivec2(KEY_PAGE_UP, 0), 0).x;        \n        camera.z -= 0.1 * factor * texelFetch(iChannel0, ivec2(KEY_X, 0), 0).x;        \n        camera.z += 0.1 * factor * texelFetch(iChannel0, ivec2(KEY_PAGE_DOWN, 0), 0).x;\n        camera.z += 0.1 * factor * texelFetch(iChannel0, ivec2(KEY_Z, 0), 0).x;        \n        camera.w -= M_PI * 0.01 * factor * texelFetch(iChannel0, ivec2(KEY_E, 0), 0).x;\n        camera.w += M_PI * 0.01 * factor * texelFetch(iChannel0, ivec2(KEY_Q, 0), 0).x;\n        \n        if (iMouse.z > 0.) {\n            vec2 mouse_uv = (2.*iMouse.xy - iResolution.xy)/iResolution.y;    \n            vec2 mouse_uv_m = FromGlobalToMinimap(mouse_uv);\n\n            if (state.z > 0.) {\n            \tcamera.xy = state.xy - transpose(rotation_matrix) * mouse_uv / zoom;                \t\n            } else if (minimap_enabled && InMinimap(mouse_uv_m)) {\n            \tcamera.xy = mouse_uv_m;\n            }\n        }                \n\t\n        if (camera != old_camera) {\n        \tstate.w = 1.0;\n        } else if (texelFetch(iChannel0, ivec2(KEY_SPACE, 0), 0).x > 0.0) {\n        \tstate.w = 0.0;\n        }\n        \n        if (ivec2(fragCoord - 0.5) == state_pixel) {                                \n            if (iMouse.z > 0.) {\n                vec2 mouse_uv = (2.*iMouse.xy - iResolution.xy)/iResolution.y;\n                if (!minimap_enabled || !InMinimap(FromGlobalToMinimap(mouse_uv))) {\n                    if (state.z <= 0.) { // Not dragging\n                        // Set flag that we are now dragging\n                        state.z = 1.0;\n                        // Set coordinates where we started dragging\n                        state.xy = camera.xy + transpose(rotation_matrix) * mouse_uv / zoom;\n                    }\n                }            \n            } else {\n                // Set flag that we are not dragging\n                state.z = 0.0;        \n            }\n\n            fragColor = state;            \n        } else {        \n        \tfragColor = camera;\n        }\n        \n        return;\n    }        \n    \n    vec3 col = DrawMainImage(fragCoord, camera.xy, zoom, rotation_matrix);\n    \n    if (minimap_enabled) {\n    \tfloat minimap_opacity = 0.;\n    \tvec3 minimap_col = DrawMinimap(fragCoord, camera.xy, zoom,\n                                       rotation_matrix, minimap_opacity);             \t    \n  \t\tcol = mix(col, minimap_col, minimap_opacity);           \n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsSyWc.jpg", "access": "api", "license": "cc-by-3.0", "functions": [[810, 810, 867, 911, 1325]], "test": "untested"}
{"id": "WdXfRn", "name": "LEAN/LEADR mapping", "author": "H4w0", "description": "Usage :\n- Uncomment #define ANIMATED_TEXTURE in Common to see a phase-shifted LRPN animation \n- Mouse X   : changing isotropic roughness\n- Mouse Y   : changing LOD Bias", "tags": ["ndf", "beckmann", "lean", "leadr", "prefiltering"], "likes": 9, "viewed": 844, "published": 3, "date": "1587569863", "time_retrieved": "2024-07-30T21:11:12.473760", "image_code": "//=======================================================\n//= LEAN / LEADR Mapping\n//=======================================================\n//== Ressources :\n//== *- 2013 - Filtering Distributions of Normals for Shading Antialiasing\n//== \tby J. Dupuy, E. Heitz, J-C Iehl, P. Poulin, F. Neyret & V. Ostromoukhov \n//== *- 2010 - LEAN mapping\n//==  \tby M. Olano & D. Baker\n//==\n//== demo : https://www.shadertoy.com/view/wlXXRn by FabriceNeyret2\n//==\n//=======================================================\n//== Code :\n//== *- Common   : Tangent math + Plane intersection + a dirty-tiled-LRPN-version \n//== *- Buffer A : Return the slope of a height field (texture(iChannel3) or procedure)\t  \t\t\t\t\n//== *- Buffer B : Compute the 2nd moments -> ( slope.x^2 ; slope.y^2 , slope.x * slope.y )\n//==\n//== *- Image \t : LEAN/LEADR using Shifted Anisotropic Beckmann NDF \t\t\t\t\n//==\n//== Usage :\n//== *- Uncomment #define ANIMATED_TEXTURE in Common to see a phase-shifted LRPN animation \n//== *- Mouse X   : changing isotropic roughness\n//== *- Mouse Y   : changing LOD Bias\n//== \n//=======================================================\n\n//-----------------------------------------------------------------------------\n//-- Constants ----------------------------------------------------------------\nconst vec4  UNIT_PLANE     \t= vec4(0.,1.,0.,0.);\n\nconst float LIGHT_INTENSITY = 5.;\nconst vec3  LIGHT_DIRECTION = normalize(vec3(0.,0.1,1.));\nconst vec3  BACKGROUND_GREY = vec3(0.2);\n\n//-------------------------------------------------------------------------------\n//-- Beckmann Shifted Anisotropic distribution ----------------------------------\n//-------------------------------------------------------------------------------\nfloat p22_beckmann_shifted(\tfloat x, float y, vec2 mean,\n                        \tfloat sigma_x, float sigma_y, float rho)\n{\n    x -= mean.x;\n    y -= mean.y;\n    float x_sqr = x*x;\n    float y_sqr = y*y;\n    float sigma_x_sqr = sigma_x*sigma_x;\n    float sigma_y_sqr = sigma_y*sigma_y;\n    float rho_sqr = rho*rho;\n\n    return( \n            exp( -( 1.f /( 2.f*(1.f-rho_sqr))) * ((x_sqr/sigma_x_sqr) + (y_sqr/sigma_y_sqr) - ((2.f*rho*x*y)/(sigma_x*sigma_y))) )\n    / //----------------------------------------------------------------------------------------------------\n                        ( 2.f * m_pi * sigma_x * sigma_y * sqrt(1.f - rho_sqr) )\n    );\n}\n\nfloat ndf_beckmann_shifted(\tvec3 omega_h, vec2 mean,\n                            float sigma_x, float sigma_y, float rho)\n{\n    float slope_x = - (omega_h.x/omega_h.z);\n    float slope_y = - (omega_h.y/omega_h.z);\n    float cos_theta = cos_theta(omega_h);\n    float cos_2_theta = cos_theta * cos_theta;\n    float cos_4_theta = cos_2_theta * cos_2_theta;\n    float beckmann_p22 = p22_beckmann_shifted(slope_x,slope_y,mean, sigma_x,sigma_y,rho);\n    return(\n                beckmann_p22\n    / //---------------------------\n                cos_4_theta\n    );\n}\n\nfloat lambda_beckmann_shifted(\tvec3 omega, vec2 mean, \n                                float sigma_x, float sigma_y, float rho)\n{\n    float lambda \t= 0.f;\n    float cos_phi \t= cos_phi(omega);\n    float sin_phi \t= sin_phi(omega);\n    float tan_theta = tan_theta(omega);\n    float sigma_sqr = cos_phi*cos_phi * sigma_x*sigma_x \n                    + sin_phi*sin_phi * sigma_y*sigma_y\n                    + 2.f*cos_phi*sin_phi * rho*sigma_x*sigma_y;\n\n    float sigma     = sqrt(sigma_sqr); \n    \n    float cot_theta  = 1.f / tan_theta;\n    float mu_phi     = cos_phi*mean.x + sin_phi*mean.y;\n    float nu         = (cot_theta - mu_phi) / (sigma * m_sqrt_2);\n    \n    if(nu < 1.6f)\n        lambda = (1.f - 1.259f*nu + 0.396f*nu*nu) / (3.535f*nu + 2.181f*nu*nu); \n    return(lambda);\n}\n\n\n//-----------------------------------------------------------------------------\n//-- Fresnel ------------------------------------------------------------------\nvec3 fresnel_schlick(in float wo_dot_wh, in vec3 F0)\n{\n    return F0 + (1. - F0) * pow(1. - wo_dot_wh, 5.);\n}\n\n//-----------------------------------------------------------------------------\n//-- World Functions ----------------------------------------------------------\nfloat \tget_light_intensity()            { return LIGHT_INTENSITY; }\nvec3 \tget_light_direction()            { return LIGHT_DIRECTION; }\nvec3 \tget_background_color(in vec3 rd) { return BACKGROUND_GREY; }\n\n//-----------------------------------------------------------------------------\n//-- Main ---------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{      \n    vec2 screen_coords = ( 2.*gl_FragCoord.xy - iResolution.xy ) / iResolution.y;\n    vec3 ro = vec3( 0., 1. , -3. );\n    vec3 rd = compute_camera_ray_direction(screen_coords,ro,vec3(0.),0.);\n\t\n    vec2  mouse \t= clamp(iMouse.xy / iResolution.xy ,0.,1.);\n    float m_alpha \t= clamp( 0.2  + mouse.x , 0., 0.6 ); \n\tfloat m_lod \t= clamp( 0.01 + mouse.y , 0., 1.0 ) * 5.;\n    \n    \n    vec3  color \t= get_background_color(rd);\n    float plane_hit = plane_get_hit(ro,rd,UNIT_PLANE);\n    \n    if(plane_hit > 0.0) \n    {\n        vec3\tP = ro + plane_hit * rd;\n        vec3    N = plane_get_normal(P,UNIT_PLANE);\n    #ifdef ANIMATED_TEXTURE\n        vec2 \tT = plane_get_texcoords(P,0.2);\n    #else\n        vec2 \tT = plane_get_texcoords(P,1.);\n    #endif\n        \n        vec3    L = get_light_direction();\n        vec3    V = -rd;\n\n        mat3 TBN    = orthonormal_basis(N);\n        mat3 TBN_t  = transpose(TBN);\n        vec3 wo \t= normalize(TBN_t * V);\n        vec3 wi \t= normalize(TBN_t * L);\n        vec3 wg \t= normalize(TBN_t * N); // ( should be (0,0,1)^t )\n        vec3 wh \t= normalize(wo+wi);\t\t// ( could check it not zero)\n        \n        vec2 slope \t\t= texture(iChannel0,T,m_lod).rg;\n    \tvec3 moments \t= texture(iChannel1,T,m_lod).rgb;\n    \n       \t/* Square roughness mapping */\n        float base_alpha = m_alpha*m_alpha;\n        /* converting base alpha in rms roughness convention */\n        float base_sigma = base_alpha * m_i_sqrt_2; \n              \n  \t\t/* Retrieve covariance matrix elements (eq. 9) */\n        /** Bivariate Normal Distribution covariance matrix : \n\t\t * \n\t\t * |     sigma_x^2       rho*sigma_x*sigma_y |\n\t\t * | rho*sigma_x*sigma_y      sigma_y^2      |\n\t\t * \n\t\t */\n        \n        float sigma_x_sqr = base_sigma*base_sigma + (moments.x - slope.x*slope.x);\n        float sigma_y_sqr = base_sigma*base_sigma + (moments.y - slope.y*slope.y);\n        float cor_x_y = moments.z - slope.x*slope.y;\n                \n        float sigma_x = sqrt(sigma_x_sqr);\n        float sigma_y = sqrt(sigma_y_sqr);\n        float rho = cor_x_y / (sigma_x * sigma_y);\n        rho = clamp(rho,-0.999,0.999);\n        \n        if(screen_coords.x > 0.) //naive version\n        {\n        \tsigma_x = base_sigma;\n        \tsigma_y = base_sigma;\n         \trho \t= 0.;   \n        }\n        \n        float h_dot_v = clamp(dot(wo,wh),0.,1.);\n        float n_dot_l = clamp(dot(wg,wi),0.,1.);\n        \n        float projected_area = 1. / dot( vec3(-slope.x,-slope.y,1) , wo);\n        float lambda_wo = lambda_beckmann_shifted(wo,slope,sigma_x,sigma_y,rho);\n        float lambda_wi = lambda_beckmann_shifted(wi,slope,sigma_x,sigma_y,rho);\n        float D = ndf_beckmann_shifted(wh,slope,sigma_x,sigma_y,rho);\n        float G = 1. / (1. + lambda_wo + lambda_wi);\n         \n\t\tvec3 F  = fresnel_schlick(h_dot_v,vec3(1.022, 0.782, 0.344));\n        vec3 BRDF = 0.25 * projected_area * (D * F * G) ;\n        \n        color = n_dot_l * get_light_intensity() * vec3(BRDF);\n    }\n    \n    fragColor = vec4(pow(color.rgb,vec3(0.4545)),1.);\n    \n\tif(screen_coords.x <= 0.01 && screen_coords.x >= -0.01) \n        fragColor = vec4(1.,0.,0.,1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//#define ANIMATED_TEXTURE\n\n//-----------------------------------------------------------------------------\n//-- Constants ----------------------------------------------------------------\nconst uint  LRPN_GLOBAL_SEED = 0u;\n//-----------------------------------------------------------------------------\n//-- Constants ----------------------------------------------------------------\nconst float m_pi        = 3.14159265359;           /* MathConstant: PI          */\nconst float m_2_pi      = 6.28318530718;           /* MathConstant: PI*2       \t*/\nconst float m_i_pi      = 0.31830988618;           /* MathConstant: 1 / PI   \t*/\nconst float m_sqrt_2    = 1.41421356237;           /* MathConstant: sqrt(2)    \t*/\nconst float m_i_sqrt_2  = 0.70710678119;           /* MathConstant: 1/sqrt(2)   */\n\nconst float m_eps_3f    = 0.001;            \nconst float m_eps_4f    = 0.0001;            \n\n//-----------------------------------------------------------------------------\n//-- Tangent Space Maths (PBRT) -----------------------------------------------\nfloat cos_theta(const vec3 w)       {return w.z;}\nfloat cos_2_theta(const vec3 w)     {return w.z*w.z;}\nfloat sin_2_theta(const vec3 w)     {return max(0.f, 1.f - cos_2_theta(w));}\nfloat sin_theta(const vec3 w)       {return sqrt(sin_2_theta(w));}\nfloat tan_theta(const vec3 w)       {return sin_theta(w) / cos_theta(w);}\nfloat cos_phi(const vec3 w)         {return (sin_theta(w) == 0.f) ? 1.f : clamp(w.x / sin_theta(w), -1.f, 1.f);}\nfloat sin_phi(const vec3 w)         {return (sin_theta(w) == 0.f) ? 0.f : clamp(w.y / sin_theta(w), -1.f, 1.f);}\nfloat cos_2_phi(const vec3 w)       {return cos_phi(w) * cos_phi(w);}\nfloat sin_2_phi(const vec3 w)       {return sin_phi(w) * sin_phi(w);} \n\n//-----------------------------------------------------------------------------\n//-- Ray ----------------------------------------------------------------------\nvec3 compute_camera_ray_direction(in vec2 screen_coordinates, in vec3 origin, in vec3 target, float cr )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw )*normalize(vec3(screen_coordinates,2.0));\n}\n\n\n//-----------------------------------------------------------------------------\n//-- Plane Intersection Functions ---------------------------------------------\nfloat plane_get_hit(in vec3 ro, in vec3 rd, in vec4 plane)\n{\n    return -(dot(ro,plane.xyz)+plane.w)/dot(rd,plane.xyz);\n}\n\nvec3 plane_get_normal(in vec3 pos, in vec4 plane)\n{\n    return(normalize(plane.xyz));\n}\n\nvec2 plane_get_texcoords(in vec3 pos, in float factor)\n{\n    return(pos.xz*factor);\n}\n\n//-----------------------------------------------------------------------------\n//-- Orthonormal Basis Function -----------------------------------------------\nmat3 orthonormal_basis(in vec3 n)\n{\n    vec3 f,r;\n    if(n.z < -0.999999)\n    {\n        f = vec3(0 , -1, 0);\n        r = vec3(-1, 0, 0);\n    }\n    else\n    {\n        float a = 1./(1. + n.z);\n        float b = -n.x*n.y*a;\n        f = normalize(vec3(1. - n.x*n.x*a, b, -n.x));\n        r = normalize(vec3(b, 1. - n.y*n.y*a , -n.y));\n    }\n    return( mat3(f,r,n) );\n}\n\n\n//--------------------------------------------------------------------------------------------------------\n//-- Pseudo Random Number Generation ---------------------------------------------------------------------  \n// From Texton Noise Source Code provided by Arthur Leclaire et al. \n// https://www.idpoisson.fr/galerne/texton_noise/index.html\n// Sourced ::\n/* \n * From http://www.reedbeta.com/blog/2013/01/12/quick-and-easy-gpu-random-numbers-in-d3d11/\n * Same strategy as in Gabor noise by example\n * Apply hashtable to create cellseed\n * Use a linear congruential generator as fast PRNG\n */\n\nuint  wang_hash(uint seed)                                          {seed=(seed^61u)^(seed>>16u);seed*=9u;seed=seed^(seed>>4u);seed*=668265261u;seed=seed^(seed>>15u);return(seed);}\nuint  cell_seed(const in ivec2 c, const in uint offset)             {const uint period=1024u;uint s=((uint(c.y)%period)*period+(uint(c.x)%period))*period+offset; if(s==0u){s = 1u;}return(s);}\nuint  myrand(inout uint p)                                          {p^=(p<<13u);p^=(p>>17u);p^=(p<<5u);return p;}\nfloat myrand_uniform_0_1(inout uint p)                              {return float(myrand(p))/float(4294967295u);}\nfloat myrand_uniform_m_M(inout uint p, in float mi, in float ma)    {return mi + (myrand_uniform_0_1(p) * (ma - mi));}\n\n//--------------------------------------------------------------------------------------------------------\n//-- Normal Mapping Function -----------------------------------------------------------------------------  \nvec3 normal_map_from_slope(float dx, float dy) // using partial derivatives\n{\n    float norm = length(vec3(dx,dy,1.0));\n    float nx = -dx / norm; \n    float ny = -dy / norm; \n    float nz = 1.0 / norm; \n    return 0.5 + 0.5 * vec3(nx,ny,nz);\n}\n\n//--------------------------------------------------------------------------------------------------------\n//-- Gaussian Window Function ----------------------------------------------------------------------------  \nfloat gaussian(in vec2 st, in float c, in vec2 mu, in mat2 sig)\n{\n    vec2 p = st-mu;\n    float body = -0.5*dot(p,inverse(sig)*p);\n    return c*exp(body);\n}\n\n//--------------------------------------------------------------------------------------------------------\n//-- Local Random Phase Noise ----------------------------------------------------------------------------\nvec3 local_random_phase_noise(\n        in vec2  texcoords,\n        in float resolution,\n        in int   cosines,\n        in vec2  range_frequency,\n        in vec2  range_orientation,\n    \tin float time\n    )\n{\n    vec2  scaled_coords = texcoords * resolution;\n    vec2  cell_coords   = fract(scaled_coords);\n    vec2  cell_index    = floor(scaled_coords);\n    \n    ivec2 cell_ID;\n    uint  prng, seed;\n    \n    vec3  lrpn   = vec3(0.);\n    float weight = 1. / float(cosines);\n    mat2  sigma  = mat2( (1.33*1.33)/m_2_pi );\n\n    for (int m=-1; m<=+1; m++)\n    for (int n=-1; n<=+1; n++)\n    {\n        cell_ID.x = int(cell_index.x) + m;\n        cell_ID.y = int(cell_index.y) + n;\n        cell_ID.x = int(mod(float(cell_ID.x),resolution));\n        cell_ID.y = int(mod(float(cell_ID.y),resolution));\n        seed = cell_seed(cell_ID,LRPN_GLOBAL_SEED);\n        prng = wang_hash(seed);\n\n        vec2 xy = cell_coords - vec2(m,n) - vec2(0.5);\n        float d = dot(xy,xy);\n        \n        float sum_of_cosines    = 0.; \n        float sum_of_partial_x  = 0.; \n        float sum_of_partial_y  = 0.; \n        for(int k=0; k<cosines; k++)\n        {\n            float fr = myrand_uniform_m_M(prng,range_frequency.x,range_frequency.y) * resolution;   // Scaled Frequency \n            float or = myrand_uniform_m_M(prng,range_orientation.x,range_orientation.y);            // Orientation\n            //float ph = m_pi*(myrand_uniform_0_1(prng)*2.-1.);                                       // Phase\n            float ph = time;\n            float ff = m_2_pi * dot(xy, fr * vec2(cos(or),sin(or)) );                               // Oriented Frequency\n            \n            sum_of_cosines   += cos(ff+ph);\n            sum_of_partial_x += -m_2_pi * fr * cos(or) * sin(ff+ph);\n            sum_of_partial_y += -m_2_pi * fr * sin(or) * sin(ff+ph); \n        }\n\n        lrpn += gaussian(xy, 1., vec2(0.0), sigma) * weight * vec3(sum_of_cosines, sum_of_partial_x, sum_of_partial_y);\n    }\n    return vec3(lrpn); // vec3(Noise, Partial X, Partial Y); \n}\n\n", "buffer_a_code": "//--------------------------------------------------------------------------------------------------------\n//-- User Parameters -------------------------------------------------------------------------------------  \nconst int   LRPN_COSINES     = 10;\nconst float LRPN_RESOLUTION  = 10.0;\nconst float LRPN_SLOPE_SCALE = 0.1;\n//--------------------------------------------------------------------------------------------------------\n//-- Main ------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 texcoords = fragCoord.xy / iResolution.xy;\n    vec2 mouse = clamp(iMouse.xy / iResolution.xy, 0., 1.);\n\n    float Dx = 0.;\n    float Dy = 0.;\n    \n#ifdef ANIMATED_TEXTURE\n    vec2  F = vec2(0.5,0.6);    //~ Frequecy range [fmin;fmax]\n    vec2  O = vec2(0.,m_pi);   \t//~ Orientation range [omin;omax]\n    float R = LRPN_RESOLUTION;  //~ Grid resolution\n    int   K = LRPN_COSINES;     //~ Number of cosines\n\n    vec3  lrpn = local_random_phase_noise(texcoords,R,K,F,O,iTime);\n    Dx = lrpn.y * LRPN_SLOPE_SCALE;\n    Dy = lrpn.z * LRPN_SLOPE_SCALE;\n#else\n\tfloat H_00 = dot(vec3(0.333),texelFetch(iChannel3,(ivec2(fragCoord) + ivec2(0,0))%textureSize(iChannel3,0), 0).rgb)*5.; \n    float H_01 = dot(vec3(0.333),texelFetch(iChannel3,(ivec2(fragCoord) + ivec2(0,1))%textureSize(iChannel3,0), 0).rgb)*5.; \n    float H_10 = dot(vec3(0.333),texelFetch(iChannel3,(ivec2(fragCoord) + ivec2(1,0))%textureSize(iChannel3,0), 0).rgb)*5.; \n    \n    Dx = H_00 - H_01;\n    Dy = H_00 - H_10;\n#endif\n    \n    \n    fragColor.rgb = vec3(vec2(Dx,Dy),0.);\n}\n", "buffer_a_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//--------------------------------------------------------------------------------------------------------\n//-- Main ------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 texcoords = fragCoord.xy / iResolution.xy;\n    vec2 slope =  texture(iChannel0,texcoords).rg;\n    fragColor.rgb = vec3(slope.x*slope.x, slope.y*slope.y, slope.x*slope.y);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXfRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1473, 1719, 1843, 1843, 2378], [2380, 2380, 2503, 2503, 2937], [2939, 2939, 3068, 3068, 3719], [3722, 3882, 3936, 3936, 3991], [3993, 4153, 4194, 4194, 4220], [4221, 4221, 4261, 4261, 4287], [4288, 4288, 4328, 4328, 4354], [4356, 4516, 4573, 4573, 7702]], "test": "untested"}
{"id": "3dfBRn", "name": "Loading Ellipse", "author": "Paltoquet", "description": "A basic loading indicator, you can change the scale of the ellipse, the width of the border ...", "tags": ["loadingellipse"], "likes": 1, "viewed": 350, "published": 3, "date": "1587565314", "time_retrieved": "2024-07-30T21:11:13.306533", "image_code": "\n\n/***\nAuthor: Thibault Ober\nThere is no license attach feel free to enjoy  \n***/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float PI = 3.14159;\n    \n    vec3 color = vec3(0.448,0.800,0.785);\n    vec3 background = vec3(0.418,0.421,0.440);\n    \n    float width = iResolution.x;\n    float height = iResolution.y;\n    float ellipseScale = 2.0;\n    \n    float animationSpeed = 0.5;\n\t\n    float x = (fragCoord.x / iResolution.x);\n    float y = (fragCoord.y / iResolution.y);\n    \n    x = (x * 2.0) - 1.0;\n    y = (y * 2.0) - 1.0;\n    \n    float theta = atan(y, x);\n    float tanTheta = y/x;\n\t\n    float a = width / ellipseScale;\n    float b = height / ellipseScale;\n\n    //intersections with the ellipse and the function y = x * tan(theta) https://math.stackexchange.com/questions/22064/calculating-a-point-that-lies-on-an-ellipse-given-an-angle\n    float x1 = a*b / sqrt(b*b + a*a * tanTheta * tanTheta);\n    float y1 = a*b*tanTheta / sqrt(b*b + a*a * tanTheta * tanTheta);\n    \n    vec2 point = vec2(x, y) * max(width, height); // work in a square space\n    vec2 pointOnEllipse = vec2(x1, y1);\n    \n    float distanceToEllipse = abs(length(pointOnEllipse) - length(point)) / max(width, height);\n    float borderWidth = 0.120;\n    float r = 1.0 - (distanceToEllipse / borderWidth);\n    \n    float current = (theta + PI); //[0 - 360]\n    current = mod(current + PI / 2.0, 2.0 * PI);  //offset to put the beguining at the top\n    current = current / (2.0 * PI); //ratio for animation\n    float angular = mod(iTime * animationSpeed, 1.0); \n    if(current < angular){\n    \tfragColor = vec4(r * color, 1.0);\n    } else {\n        fragColor = vec4(r * background, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfBRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 84, 141, 141, 1687]], "test": "untested"}
{"id": "td2cDd", "name": "Doodle: 4D Rendering", "author": "blackle", "description": "playing around with the raymarching equation and SDFs in 4 dimensions", "tags": ["raymarching", "4d"], "likes": 9, "viewed": 517, "published": 3, "date": "1587563488", "time_retrieved": "2024-07-30T21:11:14.144293", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat smin(float a, float b, float k) {\n  float h = max(0., k-abs(a-b))/k;\n  return min(a,b)-h*h*h*k/6.;\n}\n\n//smooth triangle wave for smooth domain repetition https://www.desmos.com/calculator/ototv6tja8\nvec4 stri(vec4 p, float k) {\n  return asin(sin(p*3.14)*k)/3.14+0.5;\n}\n\nfloat scene(vec4 p) {\n  vec4 q = abs(p) - 1.;\n  float cube = length(max(q,0.0)) + min(max(max(q.x,q.w),max(q.y,q.z)),0.0) - 0.1;\n  float scale = 1.;\n  vec4 p2 = p+iTime*0.2;\n  p2 = (stri(p2/scale, .9)-0.5)*scale;\n  float spheres = length(p2)-0.2;\n  spheres = -smin(-(length(p) - 2.), -spheres, 0.1);\n  return smin(cube, spheres, 0.5);\n}\n\nvec4 norm(vec4 p) {\n  mat4 k = mat4(p,p,p,p) - mat4(0.001);\n  return normalize(scene(p) - vec4( scene(k[0]),scene(k[1]),scene(k[2]),scene(k[3]) ) );\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax,p,cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nvec3 srgb(float r, float g, float b) {\n  return pow(vec3(r,g,b),vec3(2.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n  vec2 mouse = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n\n  vec4 cam = normalize(vec4(1,uv,0));\n  vec4 init = vec4(-5,0,0,sin(iTime*0.1));\n\n  float wrot = cos(iTime*0.5);\n  float zrot = cos(iTime*0.25);\n  float yrot = sin(iTime*0.5);\n  float zrot2 = iTime;\n  if (iMouse.z > 0.) {\n    zrot = mouse.x*2.;\n    wrot = radians(45.0);\n    yrot = mouse.y*2.;\n    zrot2 = 0.;\n  }\n  cam.xyw = erot(cam.xyw, vec3(0,1,0), zrot);\n  init.xyw = erot(init.xyw, vec3(0,1,0), zrot);\n  cam.xyz = erot(cam.xyz, vec3(0,1,0), yrot);\n  init.xyz = erot(init.xyz, vec3(0,1,0), yrot);\n  cam.yzw = erot(cam.yzw, vec3(0,1,0), wrot);\n  init.yzw = erot(init.yzw, vec3(0,1,0), wrot);\n  cam.xyz = erot(cam.xyz, vec3(0,0,1), zrot2);\n  init.xyz = erot(init.xyz, vec3(0,0,1), zrot2);\n  \n  vec4 p = init;\n  bool hit = false;\n  for (int i = 0; i<200 && !hit;i++) {\n    float dist = scene(p);\n    hit = dist*dist < 1e-6;\n    p+=dist*cam;\n  }\n  vec4 n = norm(p);\n  vec4 r = reflect(cam,n);\n  vec4 aon = reflect(cam, norm(p+r*0.3));\n  float factor = length(sin(aon*3.)*0.5+0.5)/2.;\n  vec3 color = mix(srgb(0.1,0.1,0.2), srgb(0.2,0.6,0.9), factor) + pow(factor, 10.);\n  fragColor.xyz = hit ? color : srgb(0.1,0.1,0.1);\n  fragColor.xyz = sqrt(fragColor.xyz);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2cDd.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 194, 233, 233, 300], [302, 399, 427, 427, 468], [470, 470, 491, 491, 806], [808, 808, 827, 827, 958], [960, 960, 998, 998, 1060], [1062, 1062, 1100, 1100, 1138], [1140, 1140, 1197, 1197, 2486]], "test": "ok"}
{"id": "wd2cDt", "name": "Party Parrots", "author": "simatten", "description": "party!!!", "tags": ["raymarching"], "likes": 1, "viewed": 459, "published": 3, "date": "1587550514", "time_retrieved": "2024-07-30T21:11:15.008981", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n  vec3 p;\n  vec2 r=iResolution.xy;\n  float t=iTime;\n  float d,l,b1,b2,R=1.57;\n  \n  fragColor=vec4(.1,.3,.6,1.);\n  for(int i=0;i<77;i++)\n  {\n    p=vec3((gl_FragCoord.xy-r*.5)/r.y,1.)*l;\n    p.yz*=mat2(cos(-.2+vec4(0,-R,R,0)));\n    p+=vec3(0,3.,t);\n    p.y=mod(p.y-1.5,6.)-3.;\n    p.xz=mod(p.xz,1.)-.5;\n    b1=length(p-vec3(sin(t*R*12.)/5.,cos(t*R*12.)/8.-2.82,.0))-.1;\n    b2=length(p-vec3(0,-3.1,.0))-.2;\n    d=min(b1,b2);\n    l+=d;\n    if(d<.01||b1+b2<.19){fragColor+=vec4(sin(vec3(R*4./3.,R/3.*8.,0)+p.x+l*9.+t*30.)*2.+2.,1)/(l);break;};\n  }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2cDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 608]], "test": "untested"}
{"id": "WdjcDd", "name": "Voxel path tracing", "author": "loicvdb", "description": "a very simple scene, should run on most computers", "tags": ["gi", "voxel", "dof", "pathtracing", "ao"], "likes": 26, "viewed": 1173, "published": 3, "date": "1587549024", "time_retrieved": "2024-07-30T21:11:16.075131", "image_code": "vec3 ACESFilm(vec3 x){\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n\nmat3 gaussianFilter = mat3(41, 26, 7,\n                           26, 16, 4,\n                           7,  4,  1) / 273.;\n\nvec3 bloom(float scale, float threshold, vec2 fragCoord){\n    float logScale = log2(scale);\n    vec3 bloom = vec3(0);\n    for(int y = -2; y <= 2; y++)\n        for(int x = -2; x <= 2; x++)\n            bloom += gaussianFilter[abs(x)][abs(y)] * textureLod(iChannel0, (fragCoord+vec2(x, y)*scale)/iResolution.xy, logScale).rgb;\n    \n    return max(bloom - vec3(threshold), vec3(0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    Camera cam = getCam(iTime);\n    \n    vec4 col = vec4(0.);\n    \n    float frd = iResolution.y*cam.aperture*DoFClamping;\n    int rd = int(ceil(frd - .5));\n    for(int y = -rd; y <= rd; y++){\n        int ln = int(ceil(sqrt(frd*frd-float(y*y)) - .5));\n        for(int x = -ln; x <= ln; x++){\n            vec2 coords = clamp(fragCoord + vec2(x, y), vec2(0), iResolution.xy-1.);\n            vec4 p = texelFetch(iChannel0, ivec2(coords), 0);\n            float dof = min(abs(p.a-cam.focalDistance)/p.a, DoFClamping) * iResolution.y*cam.aperture;\n            col += vec4(p.rgb, 1.) * clamp((dof - length(vec2(x, y))) + .5, 0.0, 1.0) / (dof*dof+.1);\n    \t}\n    }\n    \n    col /= col.a;\n    \n    vec3 bloomSum = vec3(0.);\n    bloomSum += bloom(.05 * iResolution.y, .2, fragCoord) * .1;\n    \n    fragColor = vec4(ACESFilm(col.rgb + bloomSum), 1.);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define IndirectSamples 4\n#define SamplesLimit 256\n#define Bounces 2\n\n#define Pi 3.14159265359\n#define Epsilon .00002\n\n#define MaxStepsDirect 8\n#define MaxStepsIndirect 5\n#define MaxStepsShadow 4\n\n#define SceneRadius 2.0\n\n#define PixelAcceptance 2.\n#define PixelCheckDistance .75\n\n#define DoFClamping .2\n\n\nvec3 LightDir = normalize(vec3(.2, -1.9, -1.));\nvec3 LightColor = vec3(.7, .5, .4) * 7.0;\n\nstruct Camera {\n    vec3 pos, rot;\n    float focalLength, focalDistance, aperture;\n};\n\n\nmat3 rotationMatrix(vec3 rotEuler){\n    float c = cos(rotEuler.x), s = sin(rotEuler.x);\n    mat3 rx = mat3(1, 0, 0, 0, c, -s, 0, s, c);\n    c = cos(rotEuler.y), s = sin(rotEuler.y);\n    mat3 ry = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    c = cos(rotEuler.z), s = sin(rotEuler.z);\n    mat3 rz = mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n    \n    return rz * rx * ry;\n}\n\nCamera getCam(float time){\n    vec3 rot = vec3(.8, time*.3, 0.);\n    vec3 pos = vec3(.0, .0, -10.) * rotationMatrix(rot);\n    return Camera(pos, rot, 1.3, 8., .03);\n}\n\nvec3 uv2dir(Camera cam, vec2 uv){\n    return normalize(vec3(uv, cam.focalLength)) * rotationMatrix(cam.rot);\n}\n\nvec2 pos2uv(Camera cam, vec3 pos){\n    vec3 dir = normalize(pos - cam.pos) * inverse(rotationMatrix(cam.rot));\n    return dir.xy * cam.focalLength / dir.z;\n}\n\nvec3 dirFromUv(Camera cam, vec2 uv){\n    return normalize(vec3(uv, cam.focalLength)) * rotationMatrix(cam.rot);\n}\n\n\nbool isAir(in ivec3 voxel, out vec3 dc, out vec3 ec) {\n    if(voxel == ivec3(1, 0, -2)) {\n        dc = vec3(0.);\n        ec = vec3(1., 5., 15.);\n        return false;\n    }\n    if(voxel.x == -1 && voxel.y > -1) {\n        dc = vec3(1., .5, .2);\n        ec = vec3(0.);\n        return false;\n    }\n    if(voxel.y <= -1 || voxel.xz == ivec2(1, 1)) {\n        dc = vec3(1.);\n        ec = vec3(0.);\n        return false;\n    }\n    if(voxel.z == -1) {\n        dc = vec3(.2, 1., .2);\n        ec = vec3(0.);\n        return false;\n    }\n    return true;\n}\n\nivec3 closestVoxel(vec3 pos){\n    return ivec3(floor(pos));\n}\n\nivec3 nextVoxel(inout vec3 pos, vec3 dir){\n    \n    dir += (vec3(1.0)-abs(sign(dir)))*Epsilon; //prevent zeros\n    vec3 s = sign(dir);\n    vec3 l = (floor(pos + s*(.5+Epsilon) + .5) - pos) / dir;\n    float closest = min(min(l.x, l.y), l.z);\n    pos += dir*(closest+Epsilon);\n    return closestVoxel(pos);\n}\n\nbool isInScene(in vec3 pos, vec3 dir){\n    vec3 apos = abs(pos);\n    return max(max(apos.x, apos.y), apos.z) <= SceneRadius;\n}\n\nbool intersectScene(inout vec3 pos, in vec3 dir){\n    \n    dir += (vec3(1.0)-abs(sign(dir)))*Epsilon; //prevent zeros\n    \n    vec3 i1 = (-sign(dir)*(SceneRadius+2.*Epsilon)-pos) / dir;\n    float t = max(max(i1.x, i1.y), i1.z);\n    pos += dir*max(0., t);\n    return isInScene(pos+sign(dir)*4.*Epsilon, dir);\n}\n\nbool trace(inout vec3 ro, in vec3 rd, int maxSteps){\n    if(!intersectScene(ro, rd)) return false;\n    vec3 dc, ec;\n    for(int i = 0; i < maxSteps; i++){\n        if(!isAir(nextVoxel(ro, rd), dc, ec)){\n            ro -= rd*Epsilon*2.0;\n            return true;\n        }\n        if(!isInScene(ro, rd)) break;\n    }\n    return false;\n}\n\nvoid surfaceInfo(in vec3 pos, out vec3 normal, out vec3 dc, out vec3 ec){\n    vec3 d = fract(pos)-.5;\n    vec3 ad = abs(d);\n    float m = max(max(ad.x, ad.y), ad.z);\n    normal = (abs(sign(ad-m))-1.)*sign(d);\n    isAir(closestVoxel(pos-normal), dc, ec);\n}\n\nvec3 directLight(vec3 pos, vec3 normal){\n    vec3 dir = -LightDir;\n    float dotLight = dot(normal, dir);\n    if(dotLight < 0.0) return vec3(0);\n    return trace(pos, dir, MaxStepsShadow) ? vec3(0.) : LightColor * dotLight;\n}", "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    Camera cam = getCam(iTime);\n    \n    vec2 uv = (fragCoord-iResolution.xy/2.0) / iResolution.y;\n    vec3 dir = uv2dir(cam, uv);\n    vec3 pos = cam.pos;\n    \n    fragColor = vec4(0.);\n    if(trace(pos, dir, MaxStepsDirect)) fragColor = vec4(pos, 1.);\n}", "buffer_b_inputs": [], "buffer_c_code": "float seed;\n\nfloat randomFloat(){\n    return fract(sin(seed++)*43758.54536156);\n}\n\nvec3 ortho(vec3 v) {\n  return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);\n}\n\nvec3 getCosineWeightedSample(vec3 dir) {\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = vec2(randomFloat(), randomFloat());\n\tr.x = r.x * 2.0 * Pi;\n\tr.y = pow(r.y, .5);\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;\n}\n\n\nvec3 background(vec3 dir){\n    vec3 col = texture(iChannel3, dir).rgb;\n    return col*col+col;\n}\n\nvec3 sampleIndirectLight(vec3 pos, vec3 normal){\n    vec3 dir;\n    vec3 abso = vec3(1.), light = vec3(0.), dc, ec;\n    for(int i = 0; i < Bounces; i++){\n        dir = getCosineWeightedSample(normal);\n        if(!trace(pos, dir, MaxStepsIndirect)) return light + abso*background(dir);\n        surfaceInfo(pos, normal, dc, ec);\n        light += abso * (ec + dc*directLight(pos, normal));\n        abso *= dc;\n    }\n    return light;\n}\n\nfloat distancePixel(vec2 prevFragCoord, vec4 hit){\n    if(  min(iResolution.xy, prevFragCoord) != prevFragCoord\n      && max(vec2(0.)      , prevFragCoord) != prevFragCoord) return SceneRadius;\n    vec4 prevPos = texture(iChannel2, prevFragCoord/iResolution.xy);\n    Camera cam = getCam(iTime);\n    return length(prevPos-hit);\n}\n\nvec4 previousSample(vec4 hit){\n    vec2 prevUv = pos2uv(getCam(iTime-iTimeDelta), hit.xyz);\n    vec2 prevFragCoord = prevUv * iResolution.y + iResolution.xy/2.0;\n    \n    vec2 pfc, finalpfc;\n    float dist, finaldist = SceneRadius;\n    for(int x = -1; x <= 1; x++){\n        for(int y = -1; y <= 1; y++){\n            pfc = prevFragCoord + PixelCheckDistance*vec2(x, y);\n            dist = distancePixel(pfc, hit);\n            if(dist < finaldist){\n                finalpfc = pfc;\n                finaldist = dist;\n            }\n    \t}\n    }\n    \n    Camera cam = getCam(iTime);\n    if(finaldist < PixelAcceptance*length(hit.xyz-cam.pos)/cam.focalLength/iResolution.y)\n        return texture(iChannel0, finalpfc/iResolution.xy);\n    return vec4(0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    seed = cos(fragCoord.x+.25)+cos(fragCoord.y+.5)+cos(iTime+.75);\n    \n    Camera cam = getCam(iTime);\n    \n    vec4 hit = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    if(hit.a == 0.){\n        vec2 uv = (fragCoord-iResolution.xy/2.0) / iResolution.y;\n        fragColor = vec4(background(uv2dir(cam, uv)), 1.);\n    } else {\n        \n        #if 0\n        fragColor = previousSample(hit);\n        fragColor.rgb = fragColor.a == 0. ? vec3(1., 0., 0.) : vec3(0., 1., 0.);\n        fragColor.a = 1.;\n        #else\n        vec3 normal, phdc, phec;\n        surfaceInfo(hit.xyz, normal, phdc, phec);\n        \n        vec3 iLight = vec3(0.);\n        for(int i = 0; i < IndirectSamples; i++)\n            iLight += sampleIndirectLight(hit.xyz, normal)/float(IndirectSamples);\n        \n        \n        fragColor = previousSample(hit);\n        fragColor.a += fragColor.a > float(SamplesLimit) ? 0. : float(IndirectSamples);\n        fragColor.rgb = mix(fragColor.rgb, iLight, 1.0/(fragColor.a/float(IndirectSamples)));\n        #endif\n    }\n}", "buffer_c_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "float distancePixel(vec2 prevFragCoord, vec4 hit){\n    if(  min(iResolution.xy, prevFragCoord) != prevFragCoord\n      && max(vec2(0.)      , prevFragCoord) != prevFragCoord) return SceneRadius;\n    vec4 prevPos = texture(iChannel3, prevFragCoord/iResolution.xy);\n    Camera cam = getCam(iTime);\n    return length(prevPos-hit);\n}\n\nvec4 previousSample(vec4 hit){\n    vec2 prevUv = pos2uv(getCam(iTime-iTimeDelta), hit.xyz);\n    vec2 prevFragCoord = prevUv * iResolution.y + iResolution.xy/2.0;\n    \n    vec2 pfc, finalpfc;\n    float dist, finaldist = SceneRadius;\n    for(int x = -1; x <= 1; x++){\n        for(int y = -1; y <= 1; y++){\n            pfc = prevFragCoord + PixelCheckDistance*vec2(x, y);\n            dist = distancePixel(pfc, hit);\n            if(dist < finaldist){\n                finalpfc = pfc;\n                finaldist = dist;\n            }\n    \t}\n    }\n    \n    Camera cam = getCam(iTime);\n    if(finaldist < PixelAcceptance*length(hit.xyz-cam.pos)/cam.focalLength/iResolution.y)\n        return texture(iChannel2, finalpfc/iResolution.xy);\n    return vec4(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    Camera cam = getCam(iTime);\n    \n    vec4 col = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 hit = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    vec3 finalPos = hit.rgb;\n    col.a = length(cam.pos-finalPos);\n    \n    vec2 uv = (fragCoord-iResolution.xy/2.0) / iResolution.y;\n    vec3 dir = uv2dir(cam, uv);\n    \n    if(hit.a != 0.) {\n        vec3 normal, dc, ec;\n        surfaceInfo(finalPos, normal, dc, ec);\n        col.rgb = ec + dc * (col.rgb + directLight(finalPos, normal));\n    }\n    \n    // TXAA\n    vec4 oldCol = previousSample(hit);\n    float factor = oldCol.a == 0. ? 0. : .9;\n    col = oldCol * factor + (1. - factor) * col;\n\n    fragColor = col;\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdjcDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 162], [288, 288, 345, 345, 668], [670, 670, 726, 726, 1573]], "test": "untested"}
{"id": "wsjyWt", "name": "basic shadertoy template", "author": "dreness", "description": "The simplest possible shadertoy shader to test integrations.\n\n... and a fancy string to let you limit search results. It is:\n\nD56F4F257DFB43EAA43481246A226D71", "tags": ["test", "simple", "basic"], "likes": 0, "viewed": 325, "published": 3, "date": "1587532485", "time_retrieved": "2024-07-30T21:11:16.923862", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsjyWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]], "test": "untested"}
{"id": "wsScWt", "name": "Frostbite Material Render-Ref", "author": "TinyTexel", "description": "Basic implementation of Frostbite's material + relevant sampling strategies.\nCamera controls via mouse + shift key.\n\nhttps://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf", "tags": ["globalillumination", "pathtracing", "mis", "pbr", "ggx", "multipleimportancesampling", "frostbite"], "likes": 65, "viewed": 2405, "published": 3, "date": "1587506447", "time_retrieved": "2024-07-30T21:11:18.087750", "image_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\nBasic implementation of Frostbite's material + relevant sampling strategies.\nCamera controls via mouse + shift key.\n\nReferences:\n\thttps://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\thttps://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf\n\nThe bulk of the material specific code is in the Common tab; direct light sampling routines + rendering in BufferA. Tonemapping in Image.\n*/\n\n\n#if 1\nvec4 cubic2(float x)\n{\n\tfloat x2 = x * x;\n\tfloat x3 = x2 * x;\n\tvec4 w;\n\tw.x = -x3 + 3.0f * x2 - 3.0f * x + 1.0f;\n\tw.y = 3.0f * x3 - 6.0f * x2 + 4.0f;\n\tw.z = -3.0f * x3 + 3.0f * x2 + 3.0f * x + 1.0f;\n\tw.w = x3;\n\treturn w / 6.0f;\n}\n\nvec4 SampleCubic(vec2 mPos)\n{    \n\tmPos -= 0.5f;\n\n\tvec2 fuvw = fract(mPos);\n\tmPos -= fuvw;\n\n\tvec4 cubicX = cubic2(fuvw.x);\n\tvec4 cubicY = cubic2(fuvw.y);\n\n\tvec2 cX = mPos.xx + vec2(-0.5f, 1.5f);\n\tvec2 cY = mPos.yy + vec2(-0.5f, 1.5f);\n\n\tvec2 sX = cubicX.xz + cubicX.yw;\n\tvec2 sY = cubicY.xz + cubicY.yw;\n\n\tvec2 offsetX = cX + cubicX.yw / sX;\n\tvec2 offsetY = cY + cubicY.yw / sY;\n\n\tvec4 value0;\n\tvec4 value1;\n\tvec4 value2;\n\tvec4 value3;\n\n\tvalue0 = textureLod(iChannel0, vec2(offsetX.x, offsetY.x) / iResolution.xy, 0.0);\n\tvalue1 = textureLod(iChannel0, vec2(offsetX.y, offsetY.x) / iResolution.xy, 0.0);\n\tvalue2 = textureLod(iChannel0, vec2(offsetX.x, offsetY.y) / iResolution.xy, 0.0);\n\tvalue3 = textureLod(iChannel0, vec2(offsetX.y, offsetY.y) / iResolution.xy, 0.0);\n\n\tfloat lX = sX.x / (sX.x + sX.y);\n\tfloat lY = sY.x / (sY.x + sY.y);\n\n\treturn mix(mix(value3, value2, lX), mix(value1, value0, lX), lY);\n}\n#else\nfloat BSpline(float x)\n{\n    bool s = x < 0.0;\n    \n    x = abs(x);\n\n    bool c = x < 1.0;\n    \n    if(!c) x = 2.0 - x;\n    \n    float x2 = x  * x;\n    float x3 = x2 * x;\n\t\n    float r = x3 * (1.0/6.0);\n    \n    if(c) r = r * 3.0 - x2 + 2.0/3.0;\n    \n    return r;\n}\nvec2 BSpline(vec2 v)\n{\n    return vec2(BSpline(v.x), BSpline(v.y));\n}\n\nvec4 SampleCubic(vec2 uv)\n{\n    uv += 0.5;\n    vec2 uv0 = floor(uv);\n    vec2 fuv = fract(uv);\n    \n    vec4 col = vec4(0.0);\n    for(float y = 0.0; y < 4.0; ++y)\n    for(float x = 0.0; x < 4.0; ++x)\n    {\n        vec2 o = vec2(x, y);\n        vec2 w = 1.0 - abs(fuv - o);\n        w = BSpline(fuv - o+1.0);\n        \n    \tcol += texelFetch(iChannel0, ivec2(uv0+o)-2, 0) * (w.x*w.y);\n    }\n    \n    return col;\n}\n#endif\n\n\nvec3 sRGB_EOTF(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.0031308)), pow(rgb, vec3(1.0/2.4)) * 1.055 - 0.055, rgb * 12.92);\n}\n\n\n// ACES fit by Stephen Hill (@self_shadow)\n// https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl \n// more info: https://www.shadertoy.com/view/WltSRB\n\n// sRGB => XYZ => D65_2_D60 => AP1\nconst mat3 sRGBtoAP1 = mat3\n(\n\t0.613097, 0.339523, 0.047379,\n\t0.070194, 0.916354, 0.013452,\n\t0.020616, 0.109570, 0.869815\n);\n\n// AP1 => RRT_SAT\nconst mat3 RRT_SAT = mat3\n(\n\t0.970889, 0.026963, 0.002148,\n\t0.010889, 0.986963, 0.002148,\n\t0.010889, 0.026963, 0.962148\n);\n\n\n// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\nconst mat3 ACESInputMat = mat3\n(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3\n(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 ToneTF0(vec3 x)\n{\n    vec3 a = (x            + 0.0509184) * x;\n    vec3 b = (x * 0.973854 + 0.7190130) * x + 0.0778594;\n    \n    return a / b;\n}\n\nvec3 ToneTF1(vec3 x)\n{\n    vec3 a = (x          + 0.0961727) * x;\n    vec3 b = (x * 0.9797 + 0.6157480) * x + 0.213717;\n    \n    return a / b;\n}\n\nvec3 ToneTF2(vec3 x)\n{\n    vec3 a = (x            + 0.0822192) * x;\n    vec3 b = (x * 0.983521 + 0.5001330) * x + 0.274064;\n    \n    return a / b;\n}\n\nvec3 RRTAndODTFit(vec3 x)\n{\n    vec3 a = (x            + 0.0245786) * x;\n    vec3 b = (x * 0.983729 + 0.4329510) * x + 0.238081;\n    \n    return a / b;\n}\n\nvec3 Tonemap_ACESFitted(vec3 srgb)\n{\n    vec3 color = srgb * ACESInputMat;\n   \n   #if 1\n    color = ToneTF2(color);\n   #else\n    color = RRTAndODTFit(color);\n   #endif\n    \n    color = color * ACESOutputMat;\n\n    return color;\n}\n\nvec3 Tonemap_ACESFitted2(vec3 acescg)\n{\n    vec3 color = acescg * RRT_SAT;\n    \n   #if 1\n    color = ToneTF2(color);\n   #else\n    color = RRTAndODTFit(color);\n   #endif\n    \n    color = color * ACESOutputMat;\n\n    return color;\n}\n\nvec3 Tonemap(vec3 col)\n{\n    #if 1\n    #ifdef USE_ACESCG\n\tcol = Tonemap_ACESFitted2(col);\n    #else\n\tcol = Tonemap_ACESFitted(col);\n    #endif\n    #endif\n    \n    col = clamp01(col);\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 uv)\n{\n    float exposure = 3.0;\n    \n\tvec2 tex = uv / iResolution.xy;\n    \n    vec3 col = textureLod(iChannel0, tex, 0.0).rgb;\n\n    col = Tonemap(col * exp2(exposure));\n    \n    #if 1\n    {\n        /* oversample tonemapping; prevents aliased edges around very bright spots/light sources */\n        vec3 fcol = vec3(0.0);\n        vec3 fm = vec3(0.0);\n\n        const uint count = 8u; \n        for(uint i = 0u; i < count; ++i)\n        {\n            vec2 o = Float11(Roberts(uvec2(0u), i));\n            vec2 off = o * 0.75;\n            //off = vec2(Sample_Triangle(o.x), Sample_Triangle(o.y))*1.5;\n\n            //vec3 c0 = textureLod(iChannel0, (uv + off) / iResolution.xy, 0.0).rgb;\n            vec3 c0 = SampleCubic(uv + off).rgb;\n            c0 *= exp2(exposure);\n\n            vec3 c1 = Tonemap(c0);\n\n            fm += clamp01((c1 - c0)*(c1 - c0));\n\n            fcol += (c1);\n        }\n\n        fcol /= float(count);\n        fm /= float(count);\n\n        col = mix(col, fcol, 1.0-(1.0-fm)*(1.0-fm));\n        //col = mix(col, fcol, fm);\n    }\n    #endif\n    \n    #if 0\n    // vignetting:\n    vec2 s = abs(tex*2.0-1.0);\n    s.x = 1.0-Pow3(s.x);    s.y = 1.0-Pow3(s.y);\n    col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\n\t#endif\n    \n    fragColor = vec4(sRGB_EOTF(clamp(col, 0.0, 1.0)), 0.0);\n    //fragColor = vec4(col, 0.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\nBasic implementation of Frostbite's material + relevant sampling strategies.\nCamera controls via mouse + shift key.\n\nReferences:\n\thttps://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\thttps://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf\n\nThe bulk of the material specific code is in the Common tab; direct light sampling routines + rendering in BufferA. Tonemapping in Image.\n*/\n\n\n////////////////////////////////////////////////////////////\n//--------------------------------------------------------//\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_SHIFT 0x10\n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n\n#define KeyBoard iChannel1\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\n\n\n#define VarTex iChannel0\n#define OutCol outCol\n#define OutChannel w\n\n#define WriteVar(v, cx, cy) {if(uv.x == float(cx) && uv.y == float(cy)) OutCol.OutChannel = v;}\n#define WriteVar4(v, cx, cy) {WriteVar(v.x, cx, cy) WriteVar(v.y, cx, cy + 1) WriteVar(v.z, cx, cy + 2) WriteVar(v.w, cx, cy + 3)}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n//--------------------------------------------------------//\n////////////////////////////////////////////////////////////\n\n\n// settings for the spherical light sources:\nconst vec3 LightPos = vec3(0.0, 8.0, 0.0);\nconst float R2 = 16.1;// squared radius\nconst float Flux = 512.0;\n\nconst float A = R2 * 4.0 * Pi;\n\nconst float HemiSphProjOmega = Pi;\nconst float SphOmega = 4.0 * Pi;\n\nconst float Radiance = Flux / A / HemiSphProjOmega;\nconst float Intensity = Flux / SphOmega; // = Radiance * (HemiSphProjOmega * R2);\n\n\n// voxel-based, Cornell box-like scene:\nbool map(vec3 p)\n{\n    p += 0.5;\n    vec3 b = abs(p);\n    \n    bool r;\n    \n    r =      b.x < 8.0;\n    r = r && b.y < 8.0;\n    r = r && b.z < 8.0;\n    \n    r = r && !(b.x < 7.0 && b.y < 7.0 && p.z > -7.0);\n   \n    r = r || (p.x > 1.0 && p.x < 5.0 && p.z > 1.0 && p.z < 5.0 && p.y > -8.0 && p.y < -3.0);\n    r = r || (p.x >-5.0 && p.x <-1.0 && p.z > -5.0 && p.z <-1.0 && p.y > -8.0 && p.y < 0.0);\n    \n    float ws = 2.0;\n    //if(p.y > 7.0 && b.x < ws && b.z < ws) r = false;\n    \n    return r;\n}\n\n// albedo:\nvec3 mapC(vec3 p)\n{\n    p += 0.5;\n    vec3 b = abs(p);\n    \n    vec3 c = vec3(1.0);\n    \n    if(b.y < 7.0 && p.z > -7.0) \n        if(p.x < -7.0) \n            c = vec3(1.0, 0.2, 0.01);//orange wall\n        else if(p.x > 7.0) \n            c = vec3(0.01, 0.3, 1.0);// blue wall\n        \n\n    return c;\n}\n\nvec3 minmask(vec3 v)\n{\n    return vec3(v.x <= v.y && v.x <= v.z,\n                v.y <  v.z && v.y <  v.x,\n                v.z <  v.x && v.z <= v.y);\n}\n\n// modified version of iq's DDA implementation: https://www.shadertoy.com/view/4dfGzs\nbool VoxelRayCast(vec3 rp, vec3 rd, /**/ out vec3 vp, out vec3 n, out float t)\n{\n\tvec3 pos = floor(rp);\n\tvec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n\tvec3 off = (-rp + (rs * 0.5 + 0.5)) * ri;\n\n\tvec3 mm = vec3(0.0);\n    \n\tif(map(pos)) { t = 0.0; n = vec3(0.0); vp = pos; return true; }\n    \n\tbool hit = false;\n\tfor(int i = 0; i < 128; i++) \n\t{        \n        vec3 dis = pos * ri + off;\n\n        mm = minmask(dis);\n            \n        pos += mm * rs;\n        \n\t\tif(map(pos)) { hit = true; break; }\n\t}\n\t\n    // intersect the cube\t\n    vec3 mini = (pos - rs) * ri + off;   \n\tt = max(mini.x, max(mini.y, mini.z));\n\n\tn = -mm * rs;\n\tvp = pos;\n\n\treturn hit;\n}\n\n\nbool Intersect_Scene(vec3 rp, vec3 rd, bool isPrimaryRay,\n                     out float t, out vec3 n, out vec3 a, inout bool hitLight)\n{\n    bool doTestLight = hitLight;\n    hitLight = false;\n        \n    vec3 vp;\n    bool hit = VoxelRayCast(rp, rd, /*out*/ vp, n, t);\n    \n    //a = vec3(1.0);\n    a = mapC(vp);\n    \n\tif(doTestLight)    \n    {\n        vec2 t0;\n\t\tfloat hit0 = Intersect_Ray_Sphere(rp, rd, LightPos, R2, /*out*/ t0);\n        \n        if(hit0 == 1.0)\n        {\n            if(!hit || t0.x < t)\n            {\n                t = t0.x;\n                n = normalize(rp + rd * t0.x - LightPos);\n                a = vec3(1.0);\n                \n                hitLight = true;\n            }\n            \n            hit = true;\n        }\n    }\n    \n    return hit;\n}\n\n// --------------------------------------------------------------------------------------------------------------------------\nvec3 Sample_PointLight(vec3 V, vec3 p, vec3 N, vec3 albedo, float roughness, vec3 F0)\n{\n    float alpha = GGXAlphaFromRoughness(roughness);\n    \n    vec3 pl = LightPos;\n    vec3 vecl = pl - p;\n    vec3 L = normalize(vecl);\n    float d2 = dot(vecl, vecl);\n\n    float t2; vec3 n2; vec3 a2; bool hitLight2 = false;\n    bool hit = Intersect_Scene(p, L, false, /*out*/ t2, n2, a2, hitLight2);\n\n    if(hit && t2*t2 < d2) return vec3(0.0);\n        \n    float att = 1.0 / d2;\n\n    return Frostbite_R(V, N, L, albedo, roughness, F0) * att * Intensity;\n}\n\nvec3 Sample_DirLight(vec3 V, vec3 p, vec3 N, vec3 L, vec3 albedo, float roughness, vec3 F0)\n{\n    float alpha = GGXAlphaFromRoughness(roughness);\n    \n    float t2; vec3 n2; vec3 a2; bool hitLight2 = false;\n    bool hit = Intersect_Scene(p, L, false, /*out*/ t2, n2, a2, hitLight2);\n\n    if(hit) return vec3(0.0);\n\n    return Frostbite_R(V, N, L, albedo, roughness, F0) * (Intensity * Pow2(0.125));// just set brightness heuristically here based on point light intensity\n}\n\n\nvec3 Sample_SphLight_HemiSph(vec3 V, vec3 p, vec3 N, inout uint h, vec3 albedo, float roughness, vec3 F0)\n{\n    float alpha = GGXAlphaFromRoughness(roughness);\n    \n    vec3 L;\n    {\n        float h0 = Hash11(h);\n        float h1 = Hash01(h);\n        \t  \n        L = Sample_Sphere(h0, h1, N);\n    }\n\n    float t2; vec3 n2; vec3 a2; bool isLight2 = true;\n    bool hit = Intersect_Scene(p, L, false, /*out*/ t2, n2, a2, isLight2);\n\n    if(!isLight2) return vec3(0.0);\n    \n    float NoL = clamp01(dot(N, L));\n    \n    return Frostbite_R(V, N, L, albedo, roughness, F0) * Radiance * NoL * pi2;\n}\n\nvec3 Sample_SphLight_ClmpCos(vec3 V, vec3 p, vec3 N, inout uint h, vec3 albedo, float roughness, vec3 F0)\n{\n    float alpha = GGXAlphaFromRoughness(roughness);\n    \n    vec3 L;\n    {\n        float h0 = Hash11(h);\n        float h1 = Hash01(h);\n\n        L = Sample_ClampedCosineLobe(h0, h1, N);\n    }\n\n    float t2; vec3 n2; vec3 a2; bool isLight2 = true;\n    bool hit = Intersect_Scene(p, L, false, /*out*/ t2, n2, a2, isLight2);\n\n    if(!isLight2) return vec3(0.0);\n    \n    return Frostbite_R(V, N, L, albedo, roughness, F0) * Radiance * pi;\n}\n\n// s [0..1]\nvec3 Sample_SphLight_SolidAngle(vec2 s, vec3 V, vec3 p, vec3 N, vec3 albedo, float roughness, vec3 F0)\n{\n    float alpha = GGXAlphaFromRoughness(roughness);\n    \n    float ct; vec3 Lc, L; float sang;\n    Sample_SolidAngle(s, p, LightPos, R2, /*out*/ ct, /*out*/ Lc, /*out*/ L, /*out*/ sang);\n\n    float NoL = dot(N, L);\n\n    if(NoL <= 0.0) return vec3(0.0);\n    \n    float t2; vec3 n2; vec3 a2; bool isLight2 = true;\n    bool hit = Intersect_Scene(p, L, false, /*out: */ t2, n2, a2, isLight2);\n\n    if(!isLight2 && t2 < dot(LightPos-p, Lc)) return vec3(0.0);\n    \n    vec3 f = Frostbite_R(V, N, L, albedo, roughness, F0);\n    float rpdf = sang;\n\n    return f * rpdf * Radiance;\n}\n\n// s0 [0..1], s1 [0..1]\nvec3 Sample_SphLight_MIS(vec2 s0, vec2 s1, vec3 V, vec3 p, vec3 N, vec3 albedo, float roughness, vec3 F0)\n{\n    float alpha = GGXAlphaFromRoughness(roughness);\n    \n    float ct; vec3 Lc, L0; float sang;\n    Sample_SolidAngle(s0, p, LightPos, R2, /*out*/ ct, /*out*/ Lc, /*out*/ L0, /*out*/ sang);\n    float pdf00 = 1.0/sang;\n\n    vec3 L1; vec3 f1; float pdf11;\n    Sample_GGX_R(s1, V, N, alpha, F0, /*out*/ L1, /*out*/ f1, /*out*/ pdf11);\n\n    bool couldL1HitLight = dot(L1, Lc) > ct;\n    \n    vec3 f0 = Frostbite_R(V, N, L0, albedo, roughness, F0);\n         f1 = Frostbite_R(V, N, L1, albedo, roughness, F0);\n\n    float pdf01 = couldL1HitLight ? pdf00 : 0.0;\n    float pdf10 = EvalPDF_GGX_R(V, N, L0, alpha);\n\n    float w0, w1;\n    #if 1\n    w0 = (pdf00) / (Pow2(pdf00) + Pow2(pdf10));\n    w1 = (pdf11) / (Pow2(pdf11) + Pow2(pdf01));        \n    #else\n    w0 = 1.0 / (pdf00 + pdf23);\n    w1 = 1.0 / (pdf11 + pdf32);\n    #endif\n\n    float t2; vec3 n2; vec3 a2; bool isLight2 = true;\n    bool hit2 = Intersect_Scene(p, L0, false, /*out*/ t2, n2, a2, isLight2);\n\n    float t3; vec3 n3; vec3 a3; bool isLight3 = true;\n    bool hit3 = Intersect_Scene(p, L1, false, /*out*/ t3, n3, a3, isLight3);\n\n    if((isLight2 == false && t2 < dot(LightPos-p, Lc)) || dot(N, L0) <= 0.0) f0 = vec3(0.0);\n    if(couldL1HitLight == false || isLight3 == false) f1 = vec3(0.0);\n\n    vec3 res  = pdf00 == 0.0 ? vec3(0.0) : f0 * w0;\n         res += pdf11 == 0.0 ? vec3(0.0) : f1 * w1;\n\n    return res * Radiance;       \n}\n\n// single sample version of Sample_SphLight_MIS; use this if intersecting the scene is expensive\n// s0 [0..1], s1 [0..1], s2 [0..1]\nvec3 Sample_SphLight_MIS2(vec2 s0, vec2 s1, float s2, vec3 V, vec3 p, vec3 N, vec3 albedo, float roughness, vec3 F0)\n{\n    float alpha = GGXAlphaFromRoughness(roughness);\n    \n    float ct; vec3 Lc, L0; float sang;\n    Sample_SolidAngle(s0, p, LightPos, R2, /*out*/ ct, /*out*/ Lc, /*out*/ L0, /*out*/ sang);\n    float pdf00 = 1.0/sang;\n\n    vec3 L1; vec3 f1; float pdf11;\n    Sample_GGX_R(s1, V, N, alpha, F0, /*out*/ L1, /*out*/ f1, /*out*/ pdf11);\n\n    bool couldL1HitLight = dot(L1, Lc) > ct;\n    \n    vec3 f0 = Frostbite_R(V, N, L0, albedo, roughness, F0);\n         f1 = Frostbite_R(V, N, L1, albedo, roughness, F0);\n\n    float pdf01 = couldL1HitLight ? pdf00 : 0.0;\n    float pdf10 = EvalPDF_GGX_R(V, N, L0, alpha);\n\n    float w0, w1;\n    #if 1\n    w0 = Pow2(pdf00) / (Pow2(pdf00) + Pow2(pdf10));\n    w1 = Pow2(pdf11) / (Pow2(pdf11) + Pow2(pdf01));        \n    #elif 1\n    w0 = (pdf00) / ((pdf00) + (pdf10));\n    w1 = (pdf11) / ((pdf11) + (pdf01)); \n    #else\n    w0 = 0.5; \n    w1 = 1.0 - w1;\n    #endif\n\n    float wn = couldL1HitLight == false ? 1.0 : w0 / (w0 + w1);\n\n    bool doUseSmpl0 = s2 <= wn;\n\n    float denom = doUseSmpl0 ? pdf00 * wn : pdf11 * (1.0 - wn);\n\n    vec3 L = doUseSmpl0 ? L0 : L1;\n\n    if(dot(N, L) <= 0.0 || denom == 0.0) return vec3(0.0);\n    \n    float t2; vec3 n2; vec3 a2; bool isLight2 = true;\n    bool hit2 = Intersect_Scene(p, L, false, /*out*/ t2, n2, a2, isLight2);\n\n    if(hit2 && isLight2)\n    {\n        if(doUseSmpl0)\n            return f0 / denom * w0 * Radiance;\n        else\n            return f1 / denom * w1 * Radiance;\n    }\n}\n\n\n// sRGB => XYZ => D65_2_D60 => AP1\nconst mat3 sRGBtoAP1 = mat3\n(\n\t0.613097, 0.339523, 0.047379,\n\t0.070194, 0.916354, 0.013452,\n\t0.020616, 0.109570, 0.869815\n);\n\nvec3 MapColor(vec3 srgb)\n{\n    #ifdef USE_ACESCG\n    return srgb * sRGBtoAP1;\n    #else\n    return srgb;\n    #endif\n}\n\nvec3 UnitDiskToHemisphere(vec2 p)\n{\n    float s = dot(p, p);\n    float l = sqrt(2.0 - s);\n    \n    return vec3(p.x * l, 1.0 - s, p.y * l);\n}\n\n\nvoid mainImage(out vec4 outCol, in vec2 uvO)\n{     \n    float aspect = iResolution.x / iResolution.y;\n    \n    vec2 iResolution2 = iResolution.xy;\n    vec2 uv0 = uvO;\n    \n    bool isRight = false;\n    \n    #if 0\n    if(uv0.x >= iResolution.x * 0.5)\n    {\n       uv0.x -= iResolution.x * 0.5;\n       isRight = true;\n    }\n    \n    iResolution2.x = iResolution.x * 0.5;\n    #endif\n    \n    vec2 uv = uv0.xy - 0.5;\n\tvec2 tex = uv0.xy / iResolution2.xy;\n    vec2 tex21 = tex * 2.0 - vec2(1.0);\n    \n    vec4 mouseAccu  = ReadVar4(1, 0);\n    vec4 wasdAccu   = ReadVar4(2, 0);\n    float frameAccu = ReadVar (3, 0);\n\n\n    vec2 ang = vec2(-0.42 * Pi, -Pi * 0.08);\n    ang += mouseAccu.xy * 0.008;\n    \n    mat3 cmat;\n    {\n        float sinPhi   = sin(ang.x);\n        float cosPhi   = cos(ang.x);\n        float sinTheta = sin(ang.y);\n        float cosTheta = cos(ang.y);    \n\n        vec3 front = vec3(cosPhi * cosTheta, \n                                   sinTheta, \n                          sinPhi * cosTheta);\n\n        vec3 right = vec3(-sinPhi, 0.0, cosPhi);\n        \n        vec3 up    = vec3(-cosPhi * sinTheta,\n                                    cosTheta,\n                          -sinPhi * sinTheta);\n        \n        cmat = mat3(right, up, front);\n    }\n    \n    float cdist = exp2(2.5 + mouseAccu.w * 0.02);\n    vec3 cpos = -cmat[2] * cdist;\n    \n\n    uint frameNum = uint(frameAccu);\n    \n    uint h = WellonsHash(uvec3(uv, frameNum), 0u).x;\n    uvec2 hh = WellonsHash(uvec2(uv), 0u).xy;\n    uint hh1 = WellonsHash(uvec2(uv), 0u).z;\n    \n    vec2 tc;\n    {\n        vec2 off;\n        {\n            // filter kernel:\n            float h0 = Hash11(h);\n            float h1 = Hash11(h);\n            \n        \toff = vec2(Sample_Triangle(h0), \n                       Sample_Triangle(h1));\n        }\n\n       #ifdef USE_BLOOM\n       //if(false)\n        {\n            // heavy tail bloom kernel:\n            vec2 h01 = Float01(Roberts(hh, frameNum));\n            float h0 = h01.x*2.0-1.0;\n            float rr = h01.y;\n            \n            vec2 dir = AngToVec(h0 * Pi);\n            float r = sqrt(rr);\n            \n           #if 0\n           \n            r = sqrt(2.0*rr-rr*rr) / (1.0 - rr);\n            \n           #elif 0\n           \n            r = tan(r*Pi*0.5)/(Pi)*2.0;\n            r=r*r;\n            r*=0.125*0.125;\n            \n           #elif 1\n           \n            r = rr / (1.0 - rr);\n            \n            float s = 0.5;\n            r = (sqrt(s*s+r*r)-s)*(s+sqrt(1.0+s*s));\n            \n            r*= 0.0001 * iResolution.x;\n           \n           #elif 1\n           \n            r = log((1.0+r)/(1.0-r))*0.3;\n            r*=r;\n            r*=r;\n            r*=r;\n           \n           #endif\n           \n        \toff += AngToVec(h0 * Pi) * r;\n        }\n       #endif\n        \n       #ifdef USE_BLOOM\n       //if(false)\n        if(((frameNum + hh1) % 16u) == 0u) \n        {\n            // blobby bloom kernel:\n            vec2 h01 = Float01(Roberts(uvec2(0u), (frameNum + hh1) / 16u));\n            float h0 = h01.x*2.0-1.0;\n            float rr = h01.y;\n            \n            vec2 dir = AngToVec(h0 * Pi);\n            float r = sqrt(rr);\n            \n           #if 0\n           \n           float s = 64.0*(rr+.5);// * (rr*rr);\n           \n           float bump = pow(clamp01(1.0-Pow2(r*2.0-1.0)), 32.0);\n           //bump = 0.0;\n           \n           //rr = mix((cos(rr*s)+rr*s-1.0)/s, rr, 0.5);\n           \n           r = (sqrt(1.0/pow(1.0-rr, 8.0) - 1.0)-0.75*bump)*0.5;\n           \n           #elif 0\n           \n           r = sqrt(1.0/((rr*rr) * (rr*rr)) - 1.0)*0.25;\n           //r = sqrt(1.0/pow(rr, 8.0) - 1.0)*0.5;\n            //r = sqrt((2.0*rr-rr*rr)*(2.0-(2.0*rr-rr*rr))) / Pow2(rr - 1.0)*0.5;\n            \n           #elif 0\n           \n            r = sqrt(2.0*rr-rr*rr) / (1.0 - rr)*0.5;\n            \n           #elif 0\n           \n            r = sqrt(rr / sqrt(1.0 - rr*rr));\n           \n           #elif 1\n           \n            r = log((1.0+r)/(1.0-r));\n            r*=r;\n            r *= 0.125;\n            //r = pow(r, 1.25);\n           #endif           \n           \n        \toff += AngToVec(h0 * Pi) * r * (0.125 * iResolution.x);\n            \n           //vec2 gauss = Sample_Gauss2D(h01.x, h01.y*2.0-1.0);\n            \n            //off += gauss * (0.125*0.5  * iResolution.x);\n        }\n       #endif\n        \n        tc = (uv0.xy + off - iResolution2.xy * 0.5) / (iResolution2.xx * 0.5);\n    }\n    \n    vec3 lpos = vec3(0.0);\n    #if 0\n    {\n        // lens pos / dof:\n        float h0 = Hash11(h);\n        float h1 = Hash01(h);\n\t\t\n        vec2 lpos0 = Sample_Disk(h0, h1) * 0.1;\n        \n        lpos = cmat * vec3(lpos0, 0.0);\n    }\n    #endif\n\n    float focalLen = 0.6;// = 0.5 * tan(Pi05 - fov * 0.5)\n\n    #if 0\n    {\n        float c = 0.5;\n        float s = 0.7;\n        \n        tc.y *= c;\n        tc *= s;\n        \n        vec3 u = UnitDiskToHemisphere(tc);\n        tc = u.xz;\n        focalLen = u.y*0.9;\n        \n        tc /= s;\n        tc.y/=c;\n    }\n    #endif\n\n    float S1 = max(18.0, cdist);// focus plane dist / focalLen\n    S1 = 1.0;\n    vec3 rdir = normalize(cmat * (vec3(tc, focalLen) * S1) - lpos); \n \n    rdir = cmat * Pannini(tc, Pi*0.6, 0.5);\n    \n    #if 0\n    vec2 lightAng = vec2(Pi * 0.7, Pi * 0.1);\n    lightAng.x += (wasdAccu.y - wasdAccu.w) * 0.06; \n    lightAng.y += (wasdAccu.x - wasdAccu.z) * 0.04;    \n    \n    vec3 light0 = AngToVec(lightAng);\n    light0 = vec3(0.49292178644304296, 0.7169771439171534, 0.49292178644304296);\n    \n    vec3 light = light0;\n    {\n        float h0 = Hash11(h);\n        float h1 = Hash01(h);\n\n        h1 = mix(0.999, 1.0, h1);\n        h1 = 1.0;\n        \n        light = Sample_Sphere(h0, h1, light);\n    }\n    #endif\n    \n    vec3 W = vec3(1.0);\n    vec3 col = vec3(0.0);\n    \n    float t; vec3 N; vec3 color;\n    vec3 p = cpos + lpos;\n    vec3 dir = rdir;\n\n    vec2 tt; \n    float res = Intersect_Ray_Cube(p, dir, vec3(16.0) + vec3(1e-5), /*out:*/ tt);   \n    \n    if(res == 1.0)\n    {\n    \tp += dir * tt.x;\n    }\n    \n    if(res != -1.0)\n    {\n        uint GIBounceCount = 3u;\n        \n        for(uint i = 0u; i < GIBounceCount; ++i)\n        {\n            bool hitLight = true;\n            if(Intersect_Scene(p, dir, i == 0u, /*out:*/ t, N, color, hitLight))\n            {\n                if(t == 0.0) break;\n                \n                p += dir * t;\n                p += N * 0.0001;\n                p -= dir * min(t*0.5, 0.0001);\n\n                vec3 V = -dir;\n\n                vec3 albedo, F0; float roughness;\n                {\n                    float metalness = 0.0;\n                    float reflectance = 0.5;\n                    \n                   #if 0\n                    vec3 fp = fract(p);\n                    \n                    float s = 0.01;\n                    bool m;\n                    m =      (fp.x < s || fp.x > 1.0 - s || fp.y < s || fp.y > 1.0 - s);   \n                    m = m && (fp.x < s || fp.x > 1.0 - s || fp.z < s || fp.z > 1.0 - s);   \n                    m = m && (fp.z < s || fp.z > 1.0 - s || fp.y < s || fp.y > 1.0 - s);   \n\n                    color *= m ? 0.0 : 1.0;\n\t\t\t\t   #endif\n                    \n                    vec3 fp2 = fract((p - N * 0.001) * 0.5);\n                    bvec3 m2 = greaterThan(fp2, vec3(0.5));\n\n                    bool checker = m2.x != m2.y != m2.z;\n\n                    if((p.x > 0.0) != (p.y > 0.0) != (p.z > 0.0))\n                    {\n                        metalness = 1.0;\n                        //color = mix(color, vec3(1.0), 0.2);\n                        //roughness *= 0.5;\n                        roughness = 0.7;\n\n                        roughness = checker ? 0.4 : 0.1;\n\n                    }\n                    else\n                    {\n                        roughness = checker ? 0.6 : 0.1;\n                    }\n                    //alpha = 0.02;\n\t\t\t\t\tcolor = MapColor(color);\n                    \n\t\t\t\t\tConvertMtlParams(color, reflectance, metalness, /*out*/ albedo, /*out*/ F0);\n                }\n                \n                // -------------------------------------------------------------------------------------------------------------\n\n               #if 0\n                // implicit light sampling (for verification)\n                if(hitLight == true)\n                {\n                    col += W * Radiance;\n\n                    break;\n                }\n\n               #else\n\n                if(hitLight == true)\n                {\n                    if(i == 0u) \n                    col += W * Radiance;\n\n                    break;\n                }\n\n               #if 0\n\n                // make sure LightPos is not inside scene geometry when using this\n                col += Sample_PointLight(V, p, N, albedo, roughness, F0) * W;\n\n               #elif 0\n\n                col += Sample_DirLight(V, p, N, normalize(vec3(1.0, 1.0, 1.0)), albedo, roughness, F0) * W;\n\n               #elif 0\n\n                //col += Sample_SphLight_HemiSph(V, p, N, /*inout*/ h, albedo, roughness, F0) * W;      \n                col += Sample_SphLight_ClmpCos(V, p, N, /*inout*/ h, albedo, roughness, F0) * W;      \n\n               #elif 0\n\n                col += Sample_SphLight_SolidAngle(Hash01x2(h), V, p, N, albedo, roughness, F0) * W;      \n\n               #elif 1\n                {\n                    vec2  s0 = Hash01x2(h);\n                    vec2  s1 = Hash01x2(h);\n                    \n                   #ifdef USE_LDS\n                    if(i == 0u)\n                    {\n                        s0 = Float01(Roberts(hh ^ 0xFA760509u, frameNum));\n                        s1 = Float01(Roberts(hh ^ 0x82DD24D6u, frameNum));\n                    }\n                   #endif\n                    \n                \tcol += Sample_SphLight_MIS(s0, s1, V, p, N, albedo, roughness, F0) * W;      \n                }   \n               #elif 1\n                {\n                    vec2  s0 = Hash01x2(h);\n                    vec2  s1 = Hash01x2(h);\n                    float s2 = Hash01(h);\n                    \n                   #ifdef USE_LDS\n                    if(i == 0u)\n                    {\n                        s0 = Float01(Roberts(hh   ^ 0xFA760509u, frameNum));\n                        s1 = Float01(Roberts(hh   ^ 0x82DD24D6u, frameNum));\n                        s2 = Float01(Roberts(hh.x ^ 0x2FE84799u, frameNum));\n                    }\n                   #endif\n                    \n                \tcol += Sample_SphLight_MIS2(s0, s1, s2, V, p, N, albedo, roughness, F0) * W;      \n                }\n               #endif\n               #endif\n\n\n                {\n                    vec2  s0 = Hash01x2(h);\n                    vec2  s1 = Hash01x2(h);\n                    float s2 = Hash01(h);\n                    \n                   #ifdef USE_LDS\n                    if(i == 0u)\n                    {\n                        s0 = Float01(Roberts(hh   ^ 0x8CF64DC5u, frameNum));\n                        s1 = Float01(Roberts(hh   ^ 0xFED0592Du, frameNum));\n                        s2 = Float01(Roberts(hh.x ^ 0xAEDF2BF3u, frameNum));\n                    }\n                   #endif\n                    \n                   #if 1\n                    // appears to work better than the MIS version\n                    Sample_ScatteredDir(s0, s1, s2, /*inout*/dir, /*inout*/W, N, albedo, roughness, F0);\n                   #else\n                    Sample_ScatteredDirMIS(s0, s1, s2, /*inout*/dir, /*inout*/W, N, albedo, roughness, F0);\n                   #endif\n                }\n            } \n            else \n            {\n\t\t\t\t// sample sky box\n\n                break;\n            }\n        }\n    } \n    else \n    {\n\t\t// sample sky box\n    }\n    \n    vec3 colLast = textureLod(iChannel0, uvO.xy / iResolution.xy, 0.0).rgb;\n    \n    col = mix(colLast, col, 1.0 / (frameAccu + 1.0));    \n    \n    outCol = vec4(col, 0.0);\n    \n    \n    {\n        // persistent state stuff:\n        vec4 iMouseLast     = ReadVar4(0, 0);\n        vec4 iMouseAccuLast = ReadVar4(1, 0);\n        vec4 wasdAccuLast   = ReadVar4(2, 0);\n        float frameAccuLast = ReadVar (3, 0);\n\n\n        bool shift = ReadKey(KEY_SHIFT) != 0.0;\n\n        float kW = ReadKey(KEY_W);\n        float kA = ReadKey(KEY_A);\n        float kS = ReadKey(KEY_S);\n        float kD = ReadKey(KEY_D);\n\n        float left  = ReadKey(KEY_LEFT);\n        float right = ReadKey(KEY_RIGHT);\n        float up    = ReadKey(KEY_UP);\n        float down  = ReadKey(KEY_DOWN);\n        \n        \n        bool anyK = false;\n        \n        anyK = anyK || iMouse.z > 0.0;\n        anyK = anyK || shift;\n        anyK = anyK || kW != 0.0;\n        anyK = anyK || kA != 0.0;\n        anyK = anyK || kS != 0.0;\n        anyK = anyK || kD != 0.0;\n        anyK = anyK || left  != 0.0;\n        anyK = anyK || right != 0.0;\n        anyK = anyK || up    != 0.0;\n        anyK = anyK || down  != 0.0;\n        \n        \n        frameAccuLast += 1.0;\n        if(anyK) frameAccuLast = 0.0;\n        \n\n        vec4 wasdAccu = wasdAccuLast;\n        wasdAccu += vec4(kW, kA, kS, kD);\n        wasdAccu += vec4(up, left, down, right);        \n\n        \n        vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n\n        bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n        vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n        vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n\n        vec4 iMouseAccu = iMouseAccuLast + vec4(mouseDelta2, mouseDelta3);\n\n        \n        WriteVar4(iMouse,        0, 0);\n        WriteVar4(iMouseAccu,    1, 0);\n        WriteVar4(wasdAccu,      2, 0);\n        WriteVar (frameAccuLast, 3, 0);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\nBasic implementation of Frostbite's material + relevant sampling strategies.\nCamera controls via mouse + shift key.\n\nReferences:\n\thttps://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\thttps://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf\n\nThe bulk of the material specific code is in the Common tab; direct light sampling routines + rendering in BufferA. Tonemapping in Image.\n*/\n\n// render with sharp primaries so bounce light colors behave reasonably well ( https://www.shadertoy.com/view/WltSRB ):\n#define USE_ACESCG\n\n//#define USE_BLOOM\n\n// use low-discrepancy sequences for the first direct light sampling and scattered ray direction sampling (doesn't improve quality all that much)\n//#define USE_LDS\n\n// LDS sequences don't work when bloom is active since the bloom kernel use LDS sequences themselves\n#ifdef USE_BLOOM\n #undef USE_LDS\n#endif\n\n\n#define Frame float(iFrame)\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float RcpPi = 1.0 / Pi;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nvec3 AngToVec(vec2 ang)\n{\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    return vec3(cosPhi * cosTheta, \n                         sinTheta, \n                sinPhi * cosTheta); \n}\n\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\n\n\nuint  asuint2(float x) { return x == 0.0 ? 0u : floatBitsToUint(x); }\nuvec2 asuint2(vec2 x) { return uvec2(asuint2(x.x ), asuint2(x.y)); }\nuvec3 asuint2(vec3 x) { return uvec3(asuint2(x.xy), asuint2(x.z)); }\nuvec4 asuint2(vec4 x) { return uvec4(asuint2(x.xy), asuint2(x.zw)); }\n\nfloat Float01(uint x) { return float(    x ) * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nvec2 Float01(uvec2 x) { return vec2(      x ) * (1.0 / 4294967296.0); }\nvec2 Float11(uvec2 x) { return vec2(ivec2(x)) * (1.0 / 2147483648.0); }\n\nvec3 Float01(uvec3 x) { return vec3(      x ) * (1.0 / 4294967296.0); }\nvec3 Float11(uvec3 x) { return vec3(ivec3(x)) * (1.0 / 2147483648.0); }\n\nvec4 Float01(uvec4 x) { return vec4(      x ) * (1.0 / 4294967296.0); }\nvec4 Float11(uvec4 x) { return vec4(ivec4(x)) * (1.0 / 2147483648.0); }\n\nconst uint rPhi1  = 2654435761u;\n\nconst uint rPhi2a = 3242174893u;\nconst uint rPhi2b = 2447445397u;\n\nconst uint rPhi3a = 3518319149u;\nconst uint rPhi3b = 2882110339u;\nconst uint rPhi3c = 2360945581u;\n\nconst uint rPhi4a = 3679390609u;\nconst uint rPhi4b = 3152041517u;\nconst uint rPhi4c = 2700274807u;\nconst uint rPhi4d = 2313257579u;\n\nconst uvec2 rPhi2 = uvec2(rPhi2a, rPhi2b);\nconst uvec3 rPhi3 = uvec3(rPhi3a, rPhi3b, rPhi3c);\nconst uvec4 rPhi4 = uvec4(rPhi4a, rPhi4b, rPhi4c, rPhi4d);\n\nuint  Roberts(uint  off, uint n) { return off + rPhi1 * n; }\nuvec2 Roberts(uvec2 off, uint n) { return off + rPhi2 * n; }\nuvec3 Roberts(uvec3 off, uint n) { return off + rPhi3 * n; }\nuvec4 Roberts(uvec4 off, uint n) { return off + rPhi4 * n; }\n\n#define _SEED uvec4(0xCAF0FC2Eu, 0xEA18994Au, 0x4D86D399u, 0x10EB49F0u)\n\nuvec4 PhiHash(uint  v, uint seed) { return ((v   * rPhi2a)                                                    ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec2 v, uint seed) { return ((v.x * rPhi2a) ^ (v.y * rPhi2b)                                   ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec3 v, uint seed) { return ((v.x * rPhi3a) ^ (v.y * rPhi3b) ^ (v.z * rPhi3c)                  ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec4 v, uint seed) { return ((v.x * rPhi4a) ^ (v.y * rPhi4b) ^ (v.z * rPhi4c) ^ (v.w * rPhi4d) ^ (_SEED ^ uvec4(seed))) * rPhi1; }\n\nvec4 PhiHash01(float v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec2  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec3  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec4  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\n\nvec4 PhiHash11(float v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec2  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec3  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec4  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\n\nuint MixHash(uvec2 h)\n{\n    return ((h.x ^ (h.y >> 16u)) * rPhi2.x) ^ \n           ((h.y ^ (h.x >> 16u)) * rPhi2.y);\n}\n\nuint MixHash(uvec3 h)\n{\n    return ((h.x ^ (h.y >> 16u) ^ (h.z << 15u)) * rPhi3.x) ^ \n           ((h.y ^ (h.z >> 16u) ^ (h.y << 15u)) * rPhi3.y) ^\n           ((h.z ^ (h.y >> 16u) ^ (h.x << 15u)) * rPhi3.z);\n}\n\nuint MixHash(uvec4 h)\n{\n    return ((h.x ^ (h.y >> 16u) ^ (h.z << 15u)) * rPhi4.x) ^ \n           ((h.y ^ (h.z >> 16u) ^ (h.w << 15u)) * rPhi4.y) ^\n           ((h.z ^ (h.w >> 16u) ^ (h.x << 15u)) * rPhi4.z) ^\n           ((h.w ^ (h.x >> 16u) ^ (h.y << 15u)) * rPhi4.w);\n}\n\n// low bias version https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash(uint x)\n{\n    x ^= x >> 16u;\n    x *= 0x7feb352dU;\n    x ^= x >> 15u;\n    x *= 0x846ca68bU;\n    x ^= x >> 16u;\n\n    return x;\n}\n\nuvec2 WellonsHash(uvec2 h) { return uvec2(WellonsHash(h.x), WellonsHash(h.y)); }\nuvec3 WellonsHash(uvec3 h) { return uvec3(WellonsHash(h.x), WellonsHash(h.y), WellonsHash(h.z)); }\nuvec4 WellonsHash(uvec4 h) { return uvec4(WellonsHash(h.x), WellonsHash(h.y), WellonsHash(h.z), WellonsHash(h.w)); }\n\nuvec4 WellonsHash(uint  v, uint seed) { return WellonsHash(        v  ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec2 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec3 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec4 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\n\n// minimal bias version https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash2(uint x)\n{\n    x ^= x >> 17u;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11u;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15u;\n    x *= 0x31848babU;\n    x ^= x >> 14u;\n\n    return x;\n}\n\nuvec2 WellonsHash2(uvec2 h) { return uvec2(WellonsHash2(h.x), WellonsHash2(h.y)); }\nuvec3 WellonsHash2(uvec3 h) { return uvec3(WellonsHash2(h.x), WellonsHash2(h.y), WellonsHash2(h.z)); }\nuvec4 WellonsHash2(uvec4 h) { return uvec4(WellonsHash2(h.x), WellonsHash2(h.y), WellonsHash2(h.z), WellonsHash2(h.w)); }\n\nuvec4 WellonsHash2(uint  v, uint seed) { return WellonsHash2(        v  ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec2 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec3 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec4 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\n\n#undef _SEED\n\n\n// https://en.wikipedia.org/wiki/Linear_congruential_generator\nuint LCG(uint x) { return x * 22695477u + 1u; }\n\nfloat Hash01(inout uint h)\n{\n    h = LCG(h);\n\n    return Float01(h * rPhi1);\n}\n\nfloat Hash11(inout uint h)\n{\n    h = LCG(h);\n\n    return Float11(h * rPhi1);\n}\n\nuint HashU(inout uint h)\n{\n    h = LCG(h);\n\n    return h * rPhi1;\n}\n\nvec2 Hash01x2(inout uint h) { return vec2(Hash01(h), Hash01(h)); }\nvec3 Hash01x3(inout uint h) { return vec3(Hash01(h), Hash01(h), Hash01(h)); }\nvec4 Hash01x4(inout uint h) { return vec4(Hash01(h), Hash01(h), Hash01(h), Hash01(h)); }\n\nvec2 Hash11x2(inout uint h) { return vec2(Hash11(h), Hash11(h)); }\nvec3 Hash11x3(inout uint h) { return vec3(Hash11(h), Hash11(h), Hash11(h)); }\nvec4 Hash11x4(inout uint h) { return vec4(Hash11(h), Hash11(h), Hash11(h), Hash11(h)); }\n\nuvec2 HashUx2(inout uint h) { return uvec2(HashU(h), HashU(h)); }\nuvec3 HashUx3(inout uint h) { return uvec3(HashU(h), HashU(h), HashU(h)); }\nuvec4 HashUx4(inout uint h) { return uvec4(HashU(h), HashU(h), HashU(h), HashU(h)); }\n\n/* http://tksharpless.net/vedutismo/Pannini/panini.pdf */\nvec3 Pannini(vec2 tc, float fov, float d)\n{\n    float d2 = d*d;\n\n    {\n        float fo = Pi05 - fov * 0.5;\n\n        float f = cos(fo)/sin(fo) * 2.0;\n        float f2 = f*f;\n\n        float b = (sqrt(max(0.0, Pow2(d+d2)*(f2+f2*f2))) - (d*f+f)) / (d2+d2*f2-1.0);\n\n        tc *= b;\n    }\n    \n    float h = tc.x;\n    float v = tc.y;\n    \n    float h2 = h*h;\n    \n    float k = h2/Pow2(d+1.0);\n    float k2 = k*k;\n    \n    float discr = max(0.0, k2*d2 - (k+1.0)*(k*d2-1.0));\n    \n    float cosPhi = (-k*d+sqrt(discr))/(k+1.0);\n    float S = (d+1.0)/(d+cosPhi);\n    float tanTheta = v/S;\n    \n    float sinPhi = sqrt(max(0.0, 1.0-Pow2(cosPhi)));\n    if(tc.x < 0.0) sinPhi *= -1.0;\n    \n    float s = inversesqrt(1.0+Pow2(tanTheta));\n    \n    return vec3(sinPhi, tanTheta, cosPhi) * s;\n}\n\n/*\nSOURCE: \n\t\"Building an Orthonormal Basis from a 3D Unit Vector Without Normalization\"\n\t\thttp://orbit.dtu.dk/files/126824972/onb_frisvad_jgt2012_v2.pdf\n\t\t\n\t\"Building an Orthonormal Basis, Revisited\" \n\t\thttp://jcgt.org/published/0006/01/01/\n\t\n\t- modified for right-handedness here\n\t\nDESCR:\n\tConstructs a right-handed, orthonormal coordinate system from a given vector of unit length.\n\nIN:\n\tn  : normalized vector\n\t\nOUT:\n\tox\t: orthonormal vector\n\toz\t: orthonormal vector\n\t\nEXAMPLE:\n\tfloat3 ox, oz;\n\tOrthonormalBasis(N, OUT ox, oz);\n*/\nvoid OrthonormalBasisRH(vec3 n, out vec3 ox, out vec3 oz)\n{\n\tfloat sig = n.z < 0.0 ? 1.0 : -1.0;\n\t\n\tfloat a = 1.0 / (n.z - sig);\n\tfloat b = n.x * n.y * a;\n\t\n\tox = vec3(1.0 + sig * n.x * n.x * a, sig * b, sig * n.x);\n\toz = vec3(b, sig + n.y * n.y * a, n.y);\n}\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng05..1]\n// samples hemisphere if s1 [0..1]\nvec3 Sample_Sphere(float s0, float s1)\n{\n    float ang = Pi * s0;\n    float s1p = sqrt(1.0 - s1*s1);\n    \n    return vec3(cos(ang) * s1p, \n                           s1 , \n                sin(ang) * s1p);\n}\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng05..1]\nvec3 Sample_Sphere(float s0, float s1, vec3 normal)\n{\t \n    vec3 sph = Sample_Sphere(s0, s1);\n\n    vec3 ox, oz;\n    OrthonormalBasisRH(normal, ox, oz);\n\n    return (ox * sph.x) + (normal * sph.y) + (oz * sph.z);\n}\n\n// s0 [-1..1], s1 [-1..1]\nvec3 Sample_Hemisphere(float s0, float s1, vec3 normal)\n{\n    vec3 smpl = Sample_Sphere(s0, s1);\n\n    if(dot(smpl, normal) < 0.0)\n        return -smpl;\n    else\n        return smpl;\n}\n\n// s0 [-1..1], s1 [0..1]\nvec2 Sample_Disk(float s0, float s1)\n{\n    return vec2(cos(Pi * s0), sin(Pi * s0)) * sqrt(s1);\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_ClampedCosineLobe(float s0, float s1)\n{\t \n    vec2 d  = Sample_Disk(s0, s1);\n    float y = sqrt(clamp01(1.0 - s1));\n    \n    return vec3(d.x, y, d.y);\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_ClampedCosineLobe(float s0, float s1, vec3 normal)\n{\t \n    vec2 d  = Sample_Disk(s0, s1);\n    float y = sqrt(clamp01(1.0 - s1));\n\n    vec3 ox, oz;\n    OrthonormalBasisRH(normal, ox, oz);\n\n    return (ox * d.x) + (normal * y) + (oz * d.y);\n}\n\n// s [-1..1]\nfloat Sample_Triangle(float s) \n{ \n    float v = 1.0 - sqrt(1.0 - abs(s));\n    \n    return s < 0.0 ? -v : v; \n}\n\n// Box-Muller Transform: \n// https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform\n// u (0..1] | v [-1..1]\nvec2 Sample_Gauss2D(float u, float v)\n{\n    float l = sqrt(-2.0 * log(u));\n    \n    return vec2(cos(v * Pi), sin(v * Pi)) * l;\n}\n\nconst float pi      = 3.14159274;\nconst float rpi     = 0.31830989;\n\t\t\t\t   \nconst float pi2     = 6.28318530;\nconst float rpi2    = 0.15915494;\n\t\t\t\t   \nconst float pi05    = 1.57079632;\nconst float rpi05   = 0.63661977;\n\nconst float sqrt05  = 0.70710678;\nconst float rsqrt05 = 1.41421356;\n\nconst float phi     = 1.61803398;\nconst float rphi    = 0.61803398;\n\n\nfloat OrenNayar(vec3 V, vec3 N, vec3 L, float sigma)\n{\n    float NoL = clamp01(dot(N, L));\n    float NoV = clamp01(dot(N, V));\n    \n\tfloat sigma2 = sigma * sigma;\n\n\tfloat A = 1.0 - 0.5  * sigma2 / (sigma2 + 0.33);\n\tfloat B =       0.45 * sigma2 / (sigma2 + 0.09);\n\n\tfloat term0 = sqrt((1.0 - NoV * NoV) * (1.0 - NoL * NoL)) / max(NoL, NoV);\n\n\tvec3 V_proj = normalize(V - N * NoV);\n\tvec3 L_proj = normalize(L - N * NoL);\n\n\tfloat term1 = clamp01(dot(V_proj, L_proj));\n\n\treturn (A + (B * term1 * term0)) * NoL * rpi;\n}\n\n\n// float ct, sang; vec3 Lc, L;\n// Sample_SolidAngle(s, p, lp, lr2, /*out*/ ct, /*out*/ Lc, /*out*/ L, /*out*/ sang)\n// s [0..1]\nvoid Sample_SolidAngle(vec2 s, vec3 p, vec3 lp, float lr2, \n                       out float ct, out vec3 Lc, out vec3 L, out float sang)\n{\n    vec3 lvec = lp - p;\n    \n   \tfloat len2 = dot(lvec, lvec);\n    \n    if(len2 == 0.0)\n    {\n        ct = 0.0;\n        Lc = vec3(0.0, 1.0, 0.0);\n        L  = vec3(0.0, 1.0, 0.0);\n        sang = pi2;\n        \n        return;\n    }\n    \n\tfloat rlen = rsqrt(len2);\n\n    Lc = lvec * rlen;\n    \n    ct = sqrt(clamp01(1.0 - lr2 * (rlen * rlen)));\n    \n    L = Sample_Sphere(s.x * 2.0 - 1.0, mix(ct, 1.0, s.y), Lc);\n\n    sang = ct * -pi2 + pi2;\n}\n\n\nfloat FresnelSchlick(float ct, float f0)\n{\n\tfloat x = 1.0 - ct;\n    float w = (x*x) * (x*x) * x;\n\n    return f0 * (1.0 - w) + w;\n}\n\nvec3 FresnelSchlick(float ct, vec3 f0)\n{\n    float x = 1.0 - ct;\n    float w = (x*x) * (x*x) * x;\n\n    return f0 * (1.0 - w) + w;\n}\n\nfloat FresnelSchlick(float ct, float f0, float f90)\n{\n\tfloat x = 1.0 - ct;\n    float w = (x*x) * (x*x) * x;\n\n    return mix(f0, f90, w);\n}\n\nvec3 FresnelSchlick(float ct, vec3 f0, vec3 f90)\n{\n    float x = 1.0 - ct;\n    float w = (x*x) * (x*x) * x;\n\n    return mix(f0, f90, w);\n}\n\n\nfloat GGX_V(float NoL, float NoV, float alpha)\n{\n\tfloat aa = alpha*alpha;\n    \n\tfloat t0 = NoL * sqrt((-NoV * aa + NoV ) * NoV + aa);\n\tfloat t1 = NoV * sqrt((-NoL * aa + NoL ) * NoL + aa);\n\t\n    return 0.5 / (t0 + t1);\n}\n\nfloat GGX_G(float NoL, float NoV, float alpha)\n{\n\tfloat aa = alpha * alpha;\n    \n\tfloat t0 = NoL * sqrt((-NoV * aa + NoV ) * NoV + aa);\n\tfloat t1 = NoV * sqrt((-NoL * aa + NoL ) * NoL + aa);\n\t\n    return (NoL * NoV * 2.0) / (t0 + t1);\n}\n\nfloat GGX_D(float NoH, float alpha)\n{\n    float aa = alpha * alpha;\n    \n    float t = (NoH * aa - NoH) * NoH + 1.0;\n\n\treturn aa / (pi * (t * t));\n}\n\n/*\n#elif 0\nfloat GGX_D(float NoH, float a)\n{\n    //float t = (NoH * (a*a) - NoH) * NoH + 1.0;\n\t//return (a*a-1.0) / (log(a*a) * pi * (t));\n    \n    float t = (NoH * (a*a) - NoH) * NoH + 1.0;\n\treturn (a*a-1.0) / (log(a*a*2.0/(1.0+a*a)) * pi * (t))*0.5;\n}\n#else\nfloat GGX_D(float NoH, float a)\n{\n    float t = (NoH * (a*a) - NoH) * NoH + 1.0;\n\tfloat n = (a*a-1.0) / (log(a*a) * pi * (t));\n    \n    float t2 = (NoH * (a*a) - NoH) * NoH + 1.0;\n\tfloat n2 = (a*a) / (pi * (t2 * t2));\n    \n    return mix(n, n2, 0.99);\n}\n#endif\n*/\n\nfloat GGX_G(float ct, float alpha)\n{\n    float aa = alpha * alpha;\n    float ct2 = ct * ct;\n    \n    return 2.0 * ct / (ct + sqrt(aa + ct2 - aa * ct2));\n}\n\nvec3 GGX_BRDF(vec3 N, vec3 V, vec3 L, float alpha, vec3 f0)\n{\n    vec3 H  = normalize(V + L);\n    float VoH = clamp01(dot(V, H));\n    float NoH = clamp01(dot(N, H));\n    float NoV = clamp01(dot(N, V));\n    float NoL = clamp01(dot(N, L));\n    \n    float denom = NoV * NoL;\n\n    if (denom == 0.0) return vec3(0.0);\n\n    float D = GGX_D(NoH, alpha);\n    float G = GGX_G(NoL, NoV, alpha);\n    vec3  F = FresnelSchlick(VoH, f0);\n\n    return (F * G * D) * 0.25 / denom;\n}\n\nvec3 GGX_R(vec3 N, vec3 V, vec3 L, float alpha, vec3 f0)\n{\n    vec3 H  = normalize(V + L);\n    float VoH = clamp01(dot(V, H));\n    float NoH = clamp01(dot(N, H));\n    float NoV = clamp01(dot(N, V));\n    float NoL = clamp01(dot(N, L));\n    \n    float denom = NoV;\n\n    if (denom == 0.0) return vec3(0.0);\n\n    float D = GGX_D(NoH, alpha);\n    float G = GGX_G(NoL, NoV, alpha);\n    vec3  F = FresnelSchlick(VoH, f0);\n\n    return (F * G * D) * 0.25 / denom;\n}\n\n\nfloat GGXAlphaFromRoughness(float roughness) \n{\n    return roughness * roughness;\n}\n\nfloat F0FromReflectance(float reflectance)\n{\n    return reflectance * reflectance * 0.16;\n}\n\nvoid ConvertMtlParams(vec3 color, float reflectance, float metalness, out vec3 albedo, out vec3 F0)\n{\n    F0 = mix(vec3(F0FromReflectance(reflectance)), color, metalness);\n    \n    albedo = color * (1.0 - metalness);\n}\n                      \n\n/* https://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf */ \n/* https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf */\nfloat DisneyDiffuse_BRDF(float NoV, float NoL, float HoL, float linearRoughness)\n{\n\tfloat energyBias   = mix(0.0,     0.5 , linearRoughness);\n\tfloat energyFactor = mix(1.0, 1.0/1.51, linearRoughness);\n    \n\tfloat fd90 = energyBias + 2.0 * (HoL*HoL) * linearRoughness;\n    \n\tconst float f0 = 1.0;\n    \n\tfloat lightScatter = FresnelSchlick(NoL, f0, fd90);\n\tfloat viewScatter  = FresnelSchlick(NoV, f0, fd90);\n\t\n\treturn lightScatter * viewScatter * energyFactor * rpi;\n}\n\n/* https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf */\nvec3 Frostbite_R(vec3 V, vec3 N, vec3 L, vec3 albedo, float roughness, vec3 F0)\n{    \n    float alpha = GGXAlphaFromRoughness(roughness);\n    \n    vec3 H = normalize(V + L);\n    \n    float NoH = clamp01(dot(N, H));\n    float NoV = clamp01(dot(N, V));\n    float NoL = clamp01(dot(N, L));\n    float HoV = clamp01(dot(H, V));\n    \n    if(NoL == 0.0 || NoV == 0.0) return vec3(0.0);\n    \n    float D   = GGX_D(NoH,      alpha);\n    float Vis = GGX_V(NoL, NoV, alpha);\n    float G   = GGX_G(NoV, NoL, alpha);\n    \n    vec3 F = FresnelSchlick(HoV, F0);\n\n    vec3 diffuse = albedo * DisneyDiffuse_BRDF(NoV, NoL, HoV, roughness);\n\n    return (diffuse + D * F * Vis) * NoL;\n}\n\n\n/* Eric Heitz | Sampling the GGX Distribution of Visible Normals | http://jcgt.org/published/0007/04/01/ */\n// Input Ve: view direction\n// Input alpha_x, alpha_y: roughness parameters\n// Input U1, U2: uniform random numbers\n// Output Ne: normal sampled with PDF D_Ve(Ne) = G1(Ve) * max(0, dot(Ve, Ne)) * D(Ne) / Ve.z\nvec3 Sample_GGX_VNDF(vec3 Ve, float alpha_x, float alpha_y, float U1, float U2)\n{\n\t// Section 3.2: transforming the view direction to the hemisphere configuration\n\tvec3 Vh = normalize(Ve * vec3(alpha_x, alpha_y, 1.0));\n\t\n    // Section 4.1: orthonormal basis (with special case if cross product is zero)\n\tfloat lensq = (Vh.x*Vh.x) + (Vh.y*Vh.y);\n\tvec3 T1 = lensq > 0.0 ? vec3(-Vh.y, Vh.x, 0.0) * inversesqrt(lensq) : vec3(1.0, 0.0, 0.0);\n\tvec3 T2 = cross(Vh, T1);\n\t\n    // Section 4.2: parameterization of the projected area\n\tfloat r = sqrt(U1);\n\tfloat phi = 2.0 * pi * U2;\n\tfloat t1 = r * cos(phi);\n\tfloat t2 = r * sin(phi);\n\tfloat s = 0.5 * (1.0 + Vh.z);\n\tt2 = (1.0 - s)*sqrt(1.0 - t1*t1) + s*t2;\n    \n\t// Section 4.3: reprojection onto hemisphere\n\tvec3 Nh = t1*T1 + t2*T2 + sqrt(max(0.0, 1.0 - t1*t1 - t2*t2))*Vh;\n    \n\t// Section 3.4: transforming the normal back to the ellipsoid configuration\n\tvec3 Ne = normalize(vec3(Nh.xy, max(0.0, Nh.z)) * vec3(alpha_x, alpha_y, 1.0));\n    \n\treturn Ne;\n}\n\n#if 1\n// routines that sample the visible distribution of microfacet normals\n\n// s [0..1]\nvoid Sample_GGX_R(vec2 s, vec3 V, vec3 N, float alpha, vec3 F0, out vec3 L, out vec3 w)\n{\n    vec3 H;\n    {\n    \tvec3 ox, oz;\n\t\tOrthonormalBasisRH(N, /*out*/ ox, oz);\n    \t\n    \tvec3 Vp = vec3(dot(V, ox), dot(V, oz), dot(V, N));\n    \t\n        vec3 Hp = Sample_GGX_VNDF(Vp, alpha, alpha, s.x, s.y);\n    \t\n        H = ox*Hp.x + N*Hp.z + oz*Hp.y;\n    }\n    \n    vec3 F = FresnelSchlick(dot(H, V), F0);\n\n    L = 2.0 * dot(V, H) * H - V;\n    \n    float NoV = clamp01(dot(N, V));\n    float NoL = clamp01(dot(N, L));\n    \n    float G2 = GGX_G(NoV, NoL, alpha);\n    float G1 = GGX_G(NoV, alpha);\n    \n    w = G1 == 0.0 ? vec3(0.0) : F * G2 / G1;\n}\n\n// s [0..1]\nvoid Sample_GGX_R(vec2 s, vec3 V, vec3 N, float alpha, vec3 F0, out vec3 L, out vec3 f, out float pdf)\n{\n    vec3 H;\n    {\n    \tvec3 ox, oz;\n\t\tOrthonormalBasisRH(N, /*out*/ ox, oz);\n    \t\n    \tvec3 Vp = vec3(dot(V, ox), dot(V, oz), dot(V, N));\n    \t\n        vec3 Hp = Sample_GGX_VNDF(Vp, alpha, alpha, s.x, s.y);\n    \t\n        H = ox*Hp.x + N*Hp.z + oz*Hp.y;\n    }\n    \n    vec3 F = FresnelSchlick(dot(H, V), F0);\n\n    L = 2.0 * dot(H, V) * H - V;\n    \n    float NoV = clamp01(dot(N, V));\n    float NoL = clamp01(dot(N, L));\n    float HoV = clamp01(dot(H, V));\n    float NoH = clamp01(dot(N, H));\n    \n    float G1 = GGX_G(NoV, alpha);\n    float G2 = GGX_G(NoV, NoL, alpha);\n    float D  = GGX_D(NoH, alpha);\n    \n    f   = NoV == 0.0 ? vec3(0.0) : (F * G2 * D) * 0.25 / NoV;\n    pdf = NoV == 0.0 ?      0.0  : (    G1 * D) * 0.25 / NoV;\n}\n\nfloat EvalPDF_GGX_R(vec3 V, vec3 N, vec3 L, float alpha)\n{\n    vec3 H = normalize(V + L);\n    float NoH = clamp01(dot(N, H));\n    float NoV = clamp01(dot(N, V));\n    \n    /*\n    float G1 = GGX_G(NoV, alpha);\n    float D  = GGX_D(NoH, alpha);\n    \n    return (G1 * D) * 0.25 / NoV;\n    /*/\n    float alpha2 = alpha*alpha;\n    float NoV2 = NoV*NoV;\n    \n    float t0 =     (NoH  *  alpha2 - NoH) * NoH + 1.0;\n    float t1 = sqrt(NoV2 * -alpha2 + NoV2 + alpha2) + NoV;\n    \n    float denom = (t0*t0) * t1;\n    \n    return denom == 0.0 ? 0.0 : (alpha2 * rpi2) / denom;\n    //*/\n}\n\n#else\n// routines that sample the distribution of microfacet normals (ignoring visibility)\n\n// s [0..1]\nvoid Sample_GGX_R(vec2 s, vec3 V, vec3 N, float alpha, vec3 F0, out vec3 L, out vec3 w)\n{\n    float l = rsqrt((alpha*alpha)/s.y + 1.0 - (alpha*alpha));\n    \n    vec3 H = Sample_Sphere(s.x * 2.0 - 1.0, l, N);\n\n    L = 2.0 * dot(V, H) * H - V;\n    \n    float HoV = clamp01(dot(H, V));\n    float NoV = clamp01(dot(N, V));\n    float NoL = clamp01(dot(N, L));\n    float NoH = clamp01(dot(N, H));\n\n    vec3  F = FresnelSchlick(HoV, F0);  \n    float G = GGX_G(NoV, NoL, alpha);\n    \n    float denom = NoV * NoH;\n    \n    w = denom == 0.0 ? vec3(0.0) : F * G * HoV / denom;\n}\n\n// s [0..1]\nvoid Sample_GGX_R(vec2 s, vec3 V, vec3 N, float alpha, vec3 F0, out vec3 L, out vec3 f, out float pdf)\n{\n    float l = rsqrt((alpha*alpha)/s.y + 1.0 - (alpha*alpha));\n    \n    vec3 H = Sample_Sphere(s.x * 2.0 - 1.0, l, N);\n\n    L = 2.0 * dot(V, H) * H - V;\n    \n    float HoV = clamp01(dot(H, V));\n    float NoV = clamp01(dot(N, V));\n    float NoL = clamp01(dot(N, L));\n    float NoH = clamp01(dot(N, H));\n\n    vec3 F = FresnelSchlick(HoV, F0);  \n    float G = GGX_G(NoL, NoV, alpha);\n    float D = GGX_D(NoH, alpha);\n    \n    f   = NoV == 0.0 ? vec3(0.0) : (F * G  * D) * 0.25 / NoV;\n    pdf = HoV == 0.0 ?      0.0  : (   NoH * D) * 0.25 / HoV;\n}\n\nfloat EvalPDF_GGX_R(vec3 V, vec3 N, vec3 L, float alpha)\n{\n    vec3 H = normalize(V + L);\n    float NoH = clamp01(dot(N, H));\n    float HoV = clamp01(dot(H, V));\n    \n    float D  = GGX_D(NoH, alpha);\n    \n    return HoV == 0.0 ? 0.0 : (NoH * D) * 0.25 / HoV;\n}\n#endif\n\n\n// s0 [0..1], s1 [0..1], s2 [0..1]\nvoid Sample_ScatteredDir(vec2 s0, vec2 s1, float s2, inout vec3 rd, inout vec3 W, vec3 N, vec3 albedo, float roughness, vec3 F0)\n{\n    float alpha = GGXAlphaFromRoughness(roughness);\n    \n    vec3 V = -rd;\n\n    vec3 L0, w0;\n    {\n        vec3 L = Sample_ClampedCosineLobe(s0.x * 2.0 - 1.0, s0.y, N);\n        \n        vec3 H = normalize(V + L);\n        \n        float HoV = clamp01(dot(H, V));\n    \tfloat NoV = clamp01(dot(N, V));\n    \tfloat NoL = clamp01(dot(N, L));\n        \n    \tw0 = albedo * DisneyDiffuse_BRDF(NoV, NoL, HoV, roughness) * pi;\n        L0 = L;\n    }\n    \n    vec3 L1, w1;\n    {\n        vec3 L, w;\n    \tSample_GGX_R(s1, V, N, alpha, F0, /*out*/ L1, /*out*/ w1);\n    }\n\n    float w0s = dot(w0, vec3(0.2, 0.7, 0.1));\n    float w1s = dot(w1, vec3(0.2, 0.7, 0.1));\n    \n    if(w0s == 0.0 && w1s == 0.0)\n    {\n        W = vec3(0.0);\n        rd = L0;\n        \n        return;\n    }\n    \n    #if 0\n    w0s = 0.5;\n    w1s = 1.0 - w0s;\n    #elif 0\n    float wn = (w0s*w0s) / ((w0s*w0s) + (w1s*w1s));\n    #else\n    float wn = w0s / (w0s + w1s);\n\t#endif\n    \n    bool doUseSmpl0 = s2 <= wn;\n\n    float denom = doUseSmpl0 ? wn : (1.0 - wn);\n\n    rd = doUseSmpl0 ? L0 : L1;\n    W *= doUseSmpl0 ? w0 : w1;\n\n    W /= denom == 0.0 ? 1.0 : denom;\n}\n\n// s0 [0..1], s1 [0..1], s2 [0..1]\nvoid Sample_ScatteredDirMIS(vec2 s0, vec2 s1, float s2, inout vec3 rd, inout vec3 W, vec3 N, vec3 albedo, float roughness, vec3 F0)\n{\n    float alpha = GGXAlphaFromRoughness(roughness);\n    \n    vec3 V = -rd;\n\n    vec3 L0; float pdf00;\n    {\n        L0 = Sample_ClampedCosineLobe(s0.x * 2.0 - 1.0, s0.y, N);\n\t\tpdf00 = dot(N, L0) * rpi;        \n    }\n\n    vec3 L1; vec3 f1; float pdf11;\n    Sample_GGX_R(s1, V, N, alpha, F0, /*out*/ L1, /*out*/ f1, /*out*/ pdf11);\n\n    vec3 f0 = Frostbite_R(V, N, L0, albedo, roughness, F0);\n         f1 = Frostbite_R(V, N, L1, albedo, roughness, F0);\n\n    float pdf01 = dot(N, L1) * rpi;\n    float pdf10 = EvalPDF_GGX_R(V, N, L0, alpha);\n\n    float w0, w1;\n    #if 0\n    w0 = 0.5; \n    w1 = 1.0 - w1;\n    #elif 1\n    w0 = Pow2(pdf00) / (Pow2(pdf00) + Pow2(pdf10));\n    w1 = Pow2(pdf11) / (Pow2(pdf11) + Pow2(pdf01));        \n    #else\n    w0 = (pdf00) / ((pdf00) + (pdf10));\n    w1 = (pdf11) / ((pdf11) + (pdf01));  \n    #endif\n\n    #if 0\n    if(albedo.r == 0.0 && albedo.g == 0.0 && albedo.b == 0.0)\n    {\n    \tw0 = 0.0;\n    \tw1 = 1.0;\n    }\n    #endif\n    \n    float wn = w0 / (w0 + w1);\n\n    bool doUseSmpl0 = s2 <= wn;\n\n    float denom = doUseSmpl0 ? pdf00 *        wn : \n                               pdf11 * (1.0 - wn);\n\n    rd = doUseSmpl0 ? L0 : L1;\n\n    if(denom == 0.0)\n    {\n        W = vec3(0.0);\n        \n        return;\n    }\n    \n    if(doUseSmpl0)\n        W *= f0 * w0;\n    else\n        W *= f1 * w1;\n\n    W /= denom;\n}\n\n\n\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n\nfloat Intersect_Ray_Cube(vec3 rp, vec3 rd, vec3 cth, out vec2 t)\n{\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\tt.x = max(uf.x, max(uf.y, uf.z));\n\tt.y = min(ub.x, min(ub.y, ub.z));\n\t\n\tbool inside = t.x < 0.0 && t.y > 0.0;\n    \n\tif(inside) {return 0.0;}\n\t\n\treturn t.y < t.x ? -1.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsScWt.jpg", "access": "api", "license": "cc0-1.0", "functions": [[2453, 2453, 2479, 2479, 2585], [3417, 3417, 3439, 3439, 3566], [3568, 3568, 3590, 3590, 3712], [3714, 3714, 3736, 3736, 3862], [3864, 3864, 3891, 3891, 4017], [4019, 4019, 4055, 4055, 4247], [4249, 4249, 4288, 4288, 4478], [4480, 4480, 4504, 4504, 4685], [4687, 4687, 4735, 4735, 6054]], "test": "untested"}
{"id": "tsScDt", "name": "Colourful Apollonian", "author": "mla", "description": "Looking through some old files, found this nice colourful Apollonian gasket. Mouse moves things around. Change line 85 for the halfplane.", "tags": ["apollonian"], "likes": 12, "viewed": 562, "published": 3, "date": "1587499517", "time_retrieved": "2024-07-30T21:11:18.846720", "image_code": "////////////////////////////////////////////////////////////////////////////////\n// A colourful Apollonian Gasket\n// Just mouse control for this one\n// Matthew Arcus, mla, 2020.\n////////////////////////////////////////////////////////////////////////////////\n\nint AA = 2;\nfloat N = 3.0;\nconst int max_iterations = 100;\nconst float pi = 3.14159265;\n\nbool checkinverse(inout vec2 pos, vec3 c, float s, inout float mindist2) {\n  vec2 p = pos-c.xy;\n  float p2 = dot(p,p);\n  float d2 = s*p2 - s*c.z;\n  if (d2 > 0.0) {\n    mindist2 = min(d2,mindist2);\n    return false;\n  }\n  pos = p*c.z/p2 + c.xy;\n  return true;\n}\n  \nbool checkinverse(inout vec2 pos, vec3 c, float s) {\n  float mindist2;\n  return checkinverse(pos,c,s,mindist2);\n}\n\nvec2 invert(vec2 pos, vec3 c) {\n  vec2 p = pos-c.xy;\n  float p2 = dot(p,p);\n  return p*c.z/p2 + c.xy;\n}\n  \nvec4 gasket(vec2 pos){\n  float theta = pi/N;\n  float r = 1.0/cos(theta);\n  float s = tan(theta);\n  float r2min = 0.0;\n  for(int n = 0; n < max_iterations; n++){\n    float mindist2 = 1e8;\n    vec3 c1 = vec3(0,0,pow(r-s,2.0));\n    vec3 c2 = vec3(0,0,pow(r+s,2.0));\n    if (checkinverse(pos,c1,1.0,mindist2)) {\n    } else if (checkinverse(pos,c2,-1.0,mindist2)) {\n    } else {\n      bool found = false;\n      for (float i = 0.0; i < N; i++) {\n        float t = 0.2*iTime;\n        vec3 c = vec3(r*sin(2.0*i*theta+t), r*cos(2.0*i*theta+t), s*s);\n        if (checkinverse(pos,c,1.0,mindist2)) {\n          found = true;\n          break;\n        }\n      }\n      if (!found) return vec4(pos,n,mindist2);\n    }\n  }\n  return vec4(pos,max_iterations,r2min);\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 getCol(vec4 n){\n  float t = iTime;\n  return hsv2rgb(vec3(mod((t+n.z)/50.0,1.0),0.8,0.8));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 m = vec2(0,0.8);\n  if (iMouse.x != 0.0) {\n    m = 2.0 * iMouse.xy / iResolution.y - vec2(iResolution.x / iResolution.y, 1.0);\n  }\n  vec2 c = m*(1.0/dot(m,m));\n  vec3 col = vec3(0);\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 z = (2.0*fragCoord.xy+vec2(i,j)/float(AA)-iResolution.xy)/iResolution.y;\n      if (false) {\n        z.y += 1.0;\n        z = invert(z,vec3(0,-1,2)); // Map half plane to unit disk.\n      }\n      z = invert(z,vec3(c,dot(c,c)-1.0));\n      vec4 data = gasket(z);\n      float d = 1.0/(sqrt(data.w)+1.0);\n      col += 0.8*d*getCol(data);\n    }\n  }\n  col /= float(AA*AA);\n  fragColor = vec4(pow(col,vec3(0.4545)),1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsScDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[349, 349, 423, 423, 609], [613, 613, 665, 665, 726], [728, 728, 759, 759, 831], [835, 835, 857, 857, 1582], [1584, 1679, 1706, 1706, 1882], [1884, 1884, 1904, 1904, 1980], [1982, 1982, 2038, 2038, 2717]], "test": "untested"}
{"id": "Wd2yzt", "name": "ImSmile", "author": "Imene_BH", "description": "it is an animated smile", "tags": ["becreative"], "likes": 1, "viewed": 222, "published": 3, "date": "1587498182", "time_retrieved": "2024-07-30T21:11:19.614667", "image_code": "// ImSmile //\n\n#define S(a,b,t) smoothstep (a, b ,t)\n#define sat(x) clamp(x, 0. , 1.) \n\nfloat remap01 (float a, float b , float t){\n  \treturn sat((t-a) / (b-a) );\t\t\t\t\t\t\t\t\t\t// sat is used to be sure that the value returned  is between 0 & 1\n}\n\nfloat remap (float a , float b , float c , float d, float t ){\n    return sat(((t-a)/(b-a)) * (d-c)+c);\n\n}\n\nvec2 within (vec2 uv , vec4 rect ){ \t\t\t\t\t\t\t\t// return uv coordinate within that rectangle \n\treturn (uv-rect.xy)/(rect.zw-rect.xy);\n\n}\nvec4 Brow (vec2 uv){\n    \n\tfloat y = uv.y;\n    uv.y += uv.x*.1-2.;\n    uv.x-=.1;\n    uv -=.5;\n    \n    vec4 col = vec4(0.);\n    float blur =.1; \n    float d1 = length(uv);\n    float s1 = S (.40,.45-blur,d1);\n    float d2 = length(uv-vec2(1.,-.2)*.7);\n    float s2 = S(.5,.55-blur,d2);\n    float browMask = sat (s1-s2);\n      \n    vec4 browCol = vec4(.7,.5,.3,1.);\n    col = mix (col, browCol,S(.2,.4,browMask));\n\treturn col;\n}  \nvec4 Eye (vec2 uv,float side,vec2 m,float smile){\n\tuv -=.5;\n    uv.x *= side;\t\t\t\t\t\t\t\t\t\t\t\t\t// desable mirior effect for mvt eyes \n    float d = length(uv);\n    vec4 irisCol = vec4(.0,.6,.0,4.);\t\t\t\t\t\t\t\t// iris color\n    vec4 col = mix (vec4(1.),irisCol,S(.2,.50,d)*.6);\t\t\t\t// gradien in eye-white\n    col.a= S(.5,.48,d);// eye mask\n    col.rgb *= 1. - S(.45,.5,d)*.7*sat(-uv.y+uv.x);\t\t\t\t\t// add a little shadow , sat doesn't get negative in\n  \n    d = length(uv-m*.5);\t\t\t\t\t\t\t\t\t\t\t// distance of mouse mvt \n    col.rgb = mix (col.rgb,vec3(0.), S(.29,.15,d));\t\t\t\t\t// iris outline\n    \n    irisCol.rgb *= 1.2 + S(.35,.001,d);\n    col.rgb = mix (col.rgb,irisCol.rgb, S(.28,.12,d));\n    \n    float pupilSize=mix (.30,.18,smile);\t\t\t\t\t\t\t// pupil size is bigger if we're not smiling\n    d = length(uv-m*.65);\n    col.rgb = mix (col.rgb,vec3(0.), S(pupilSize,pupilSize*.95,d)); // blend\n    \n    //highlight\n    uv.x += sin(iTime+uv.y*20.)*.03;\n    float p = length(uv -vec2(-.11,.15));\n    float p2 = length(uv +vec2(-.06,.10));\n    \n    float highlight = S (.1,.07,p);\n    highlight += S(.1,.0001,p2);\n    col.rgb= mix (col.rgb, vec3(1.),highlight);\n    col.rgb= mix (col.rgb, vec3(1.),highlight);\n   \n    return col;\n}\nvec4 Mouth (vec2 uv,float smile){\n\tuv-=.5;//renormalize\n    vec4 col = vec4(.9,.1,.2,1.);\n\t   \n    uv.y*=1.5;\n    uv.y -= uv.x*uv.x*2.*smile;\n    uv.x *= mix(3.,1.,smile);\n    float d = length(uv);\n    col.rgb= mix (col.rgb,vec3(.2,.10,.05),S(.55,.45,d));\n    \n    float teeth = length(uv-vec2(0.005,.65));\n    vec3 toothcol= vec3(1.)*S(.9,.7,d);\n    col.rgb= mix(col.rgb,toothcol,S(.47,.35,teeth));\n    \n    float tongue = length(uv-vec2(-.005,-.55));\n    col.rgb = mix(col.rgb, vec3(1.,.5,.5),S(.5,.2,tongue));\n    \n    col.a= S(.6,.47,d);\n    return col;\n    \n}\n\nvec4 Head (vec2 uv){\n\tvec4 col = vec4(.9,.70, .1, 1.);    \n    float d = length(uv);\n    \n    col.a = S(.5,.49,d);\n    float edgeShade = remap01(.35,.5,d);\n    edgeShade *= edgeShade;\n    col.rgb *= 1.-edgeShade*.5;\n    \n    col.rgb = mix (col.rgb,vec3(.65,.4,.1),S(.48,.48,d));\t\t\t// draw \"contour\"\n    \n    float highlight = S(.41,.405,d)*.75;\n    highlight *=remap(.41,-.1,.75,0.,uv.y);\n    highlight *=S(.16,.18,length(uv-vec2(.207,.11)));\n    col.rgb = mix(col.rgb,vec3(1.),highlight);\n    \n    //cheek\n    d = length(uv-vec2(.30, -.17));\t\t\t\t\t\t\t\t\t// position of cheek in the image\n    float cheek= S(.20,.02,d)*.35;   \n    col.rgb = mix(col.rgb,vec3(1.,.1,.1),cheek);\n    \n    return col;\n}\n\nvec4 Smiley (vec2 uv,vec2 m,float smile,vec4 fragColor,vec2 fragCoord){\n\t\n    vec2 uv1 = (fragCoord*2.-iResolution.xy)/40.;\n    vec4 col = vec4(.2,0.4,0.3,.2);\n     col += vec4(sin(iTime*10.+3.141592653589793*2.)*0.5)*0.3+0.5;\n    col+=sin((uv1.x-uv1.y)*60.)/2.;\n   \n    //head\n    float side = sign (uv.x);\t\t\t\t\t\t\t\t\t\t\t// Every think on one side will be drawn on\n   \tuv.x=abs(uv.x);\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The other side too \"mirror x cordinates \n     \n    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n    vec4 Head = Head (uv);\t\t\t\t\t\t\t\t\t\t\t\t// The color from the head\n    vec4 Eye = Eye (within(uv,vec4(.03,-.05,.36,.26)),side,m,smile);\t// Make the eyes\n    vec4 Mouth = Mouth (within(uv,vec4(-.3,-.42,.28,-.1)),smile);\t\t// Make Mouth\n    vec4 Brow = Brow (within(uv,vec4(.03,.2,.30,.27)));\n   \n    //mix color\n    col = mix (col, Head,Head.a); \n    col = mix (col, Eye,Eye.a);\n    col = mix (col, Mouth,Mouth.a);\n    col = mix (col, Brow,Brow.a);\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv-= .5;\n    uv.x *=iResolution.x / iResolution.y;\n    \n\tvec2 m = iMouse.xy / iResolution.xy;\n    m -=.5;\n    uv-=m*(.5-dot(uv,uv));\t\t\t\t\t\t\t\t\t\t\t\t// expenential mvt\n    \n    // Output to screen\n    float smile= -sin(iTime)*.5+.5;\t\t\t\t\t\t\t\t\t\t//sinus function of time \n    fragColor = Smiley(uv,m,smile,fragColor,fragCoord);\n    \n    // sound \n    float t = iTime;\n     \n    // add wave form on top\t\n    vec3 col;\n\tcol -= 1. - smoothstep( 0.0, 0.15, smile );\n\t// output final color\n\tfragColor += vec4(col,1.0);\n    \n}", "image_inputs": [{"id": 22360, "src": "https://soundcloud.com/ladouceplaylist/la-douce-playlist-mixtape-14-nth-sound-mix", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2yzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 131, 131, 241], [243, 243, 305, 305, 349], [351, 351, 386, 441, 484], [485, 485, 505, 505, 911], [914, 914, 963, 963, 2123], [2124, 2124, 2157, 2157, 2688], [2690, 2690, 2710, 2710, 3384], [3386, 3386, 3457, 3457, 4320], [4323, 4323, 4380, 4430, 4988]], "test": "untested"}
{"id": "wdScWt", "name": "Rectangle Rotating", "author": "Jaman", "description": "Rectangle that rotates", "tags": ["rectangle"], "likes": 0, "viewed": 291, "published": 3, "date": "1587495890", "time_retrieved": "2024-07-30T21:11:20.366657", "image_code": "const float width = 0.05; // Width ratio of rectangle\nconst float height = 0.05; // Height ratio of rectangle\n\nvec2 func1(vec2 uv, float time) {\n\tfloat hypot = length(uv);\n    float uvang = atan(uv.y, uv.x);\n    float newang = uvang + time;\n\treturn hypot * vec2(cos(newang), sin(newang));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    fragColor = vec4(0.25, 0.25, 0.25, 1.0);\n    \n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord.xy -.5 * R) / R.y;\n    uv.x += cos(iTime) * 0.1;\n    \n    vec2 rot = func1(uv, iTime);\n    \n    rot = abs( rot ) - vec2( width, height );\n    if(rot.x <= width && rot.x >= -width && rot.y <= height && rot.y >= -height){\n        fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdScWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 111, 144, 144, 290], [292, 292, 346, 346, 726]], "test": "untested"}
{"id": "WsSyDt", "name": "unconnected pipes", "author": "yuntaRobo", "description": "I referenced Truchet Tiling from The Art of Code.\nhttps://www.youtube.com/watch?v=2R7h76GoIJM", "tags": ["raymarching", "truchet", "pipes"], "likes": 23, "viewed": 631, "published": 3, "date": "1587482652", "time_retrieved": "2024-07-30T21:11:21.121638", "image_code": "const float PI = 3.1415926;\nconst float E = 0.005;\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\n// Hash without Sine by Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3 = fract(p3 * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yxx) * p3.zyx);\n}\n\nmat2 rotate2D(float rad)\n{\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat2(c, s, -s, c);\n}\n\nvec3 rotate(vec3 p)\n{\n    p.xz *= rotate2D(iTime * 0.2);\n    p.yz *= rotate2D(0.5);\n    return p;\n}\n\nfloat deBlock(vec3 p)\n{\n    vec3 pb = p;\n\n    p.xz += 0.5;\n\tvec2 q = vec2(length(p.xz) - 0.5, p.y);\n\tfloat d = length(q) - 0.12;\n\t\n\tp = pb;\n\tp.yz -= 0.5;\n\tq = vec2(length(p.yz) - 0.5, p.x);\n\td = min(d, length(q) - 0.12);\n\t\n\tp = pb;\n\tp.xy -= vec2(0.5, -0.5);\n\tq = vec2(length(p.xy) - 0.5, p.z);\n\td = min(d, length(q) - 0.12);\n\t\n\td = abs(d) - 0.0125;\n\t\n\treturn d;\n}\n\nvec2 de(vec3 p)\n{\n    p = rotate(p);\n    \n    vec3 pb = p;\n    \n    vec3 id = floor(p);\n    p = fract(p) - 0.5;\n    \n    vec3 r = hash33(id);\n    if (r.x < 0.5)  p.x *= -1.0;\n\tif (r.y < 0.5)\tp.y *= -1.0;\n\tif (r.z < 0.5)\tp.z *= -1.0;\n\n    float d = deBlock(p);\n\tfloat offset = smoothstep(0.45, 0.5, length(p));\n\td -= offset * 0.03;\n    \n    p = pb;\n    d = max(max(d, abs(p.x) - 5.0), abs(p.z) - 5.0);\n    \n    return vec2(d * 0.75, offset);\n}\n\n// iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p)\n{\n    float h = E;\n    vec2 k = vec2(1.0, -1.0);\n    return normalize(\n            k.xyy * de(p + k.xyy * h).x + \n            k.yyx * de(p + k.yyx * h).x + \n            k.yxy * de(p + k.yxy * h).x + \n            k.xxx * de(p + k.xxx * h).x\n        );\n}\n\nfloat ao(Ray ray)\n{\n    float d = 0.0;\n    d += de(ray.pos + ray.dir * 1.0).x;\n    d += de(ray.pos + ray.dir * 2.0).x;\n    d += de(ray.pos + ray.dir * 3.0).x;\n    d += de(ray.pos + ray.dir * 4.0).x;\n    d += de(ray.pos + ray.dir * 5.0).x;\n    return pow(d / 15.0, 2.0);\n}\n\nfloat noiseValue3D(vec3 p, float div)\n{\n    p *= div;\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    float r1 = hash13((i + vec3(0.0, 0.0, 0.0)));\n    float r2 = hash13((i + vec3(1.0, 0.0, 0.0)));\n    float r3 = hash13((i + vec3(0.0, 1.0, 0.0)));\n    float r4 = hash13((i + vec3(1.0, 1.0, 0.0)));\n    float r5 = hash13((i + vec3(0.0, 0.0, 1.0)));\n    float r6 = hash13((i + vec3(1.0, 0.0, 1.0)));\n    float r7 = hash13((i + vec3(0.0, 1.0, 1.0)));\n    float r8 = hash13((i + vec3(1.0, 1.0, 1.0)));\n    return mix(\n            mix(mix(r1, r2, smoothstep(0.0, 1.0, f.x)), mix(r3, r4, smoothstep(0.0, 1.0, f.x)), smoothstep(0.0, 1.0, f.y)),\n            mix(mix(r5, r6, smoothstep(0.0, 1.0, f.x)), mix(r7, r8, smoothstep(0.0, 1.0, f.x)), smoothstep(0.0, 1.0, f.y)),\n            smoothstep(0.0, 1.0, f.z)\n        );\n}\nfloat noiseValueFbm3D(vec3 p, float div, int octaves, float amplitude)\n{\n    float o = 0.0;\n    float fbm_max = 0.0;\n    for(int i = 0; i >= 0; i++)\n    {\n        if(i >= octaves)    break;\n        float a = pow(amplitude, float(i));\n        o += a * noiseValue3D(p, div * pow(2.0, float(i)));\n        fbm_max += a;\n    }\n    return o / fbm_max;\n}\n\nvoid trace(Ray ray, inout vec3 color, float md)\n{\n    vec3 or = ray.pos;\n    \n    float ad = 0.0;\n    for (float i = 1.0; i > 0.0; i -= 1.0 / 120.0)\n    {\n        vec2 o = de(ray.pos);\n        if (o.x < E)\n        {\n            vec3 n = normal(ray.pos);\n\n            // diffuse\n            vec3 ld = normalize(vec3(1.0, 0.75, 0.5));\n            float l = pow(dot(n, ld) * 0.5 + 0.5, 3.0) * 3.0;\n            \n            // specular\n            vec3 h = normalize(ld + normalize(or - ray.pos));\n            float hn = max(dot(h, n), 0.0);\n            float s1 = pow(hn, 15.0) * 0.75;\n            float s2 = pow(hn, 50.0) * 15.0;\n            \n            // ao\n            Ray rayAo;\n            rayAo.pos = ray.pos;\n            rayAo.dir = n;\n            float a = ao(rayAo);\n            \n            // noise\n            vec3 p = rotate(ray.pos);\n            float ns = noiseValueFbm3D(p, 10.0, 4, 0.5);\n            ns = noiseValueFbm3D(p + vec3(ns), 10.0, 4, 0.5);\n\n            // color\n            color += mix(\n                    vec3(0.01, 0.1, 1.0) + s2 * ns * ns * ns, \n                    (mix(vec3(0.2, 0.2, 0.2), vec3(0.15, 0.15, 0.3), ns) + s1) * max(ns, 0.35), \n                    smoothstep(0.8, 1.0, 1.0 - o.y)\n                ) * l * a;\n            \n//            color = n * 0.5 + 0.5;\n//            color = vec3(a);\n\n            return;\n        }\n\n        ray.pos += ray.dir * o.x;\n        ad = ad + o.x;\n        if (ad > md)\n        {\n            break;\n        }\n    }\n\n    // background\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    // view\n    vec3 view = vec3(0.0, 0.0, 10.0);\n    vec3 at = normalize(vec3(0.0, 0.0, 0.0) - view);\n    vec3 right = normalize(cross(at, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, at);\n    float focallength = 1.75;\n    \n    // ray\n    Ray ray;\n    ray.pos = view;\n    ray.dir = normalize(right * p.x + up * p.y + at * focallength);\n\n    // ray marching\n    trace(ray, color, 20.0);\n\n    // cheap tonemapping\n    // https://www.desmos.com/calculator/adupt0spl8\n    float k = 0.75;\n    color = mix(color, 1.0 - exp(-(color - k) / (1.0 - k)) * (1.0 - k), step(k, color));\n\n    // gamma correction\n    color = pow(color, vec3(0.454545));\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsSyDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 175, 198, 198, 301], [302, 302, 324, 324, 455], [457, 457, 483, 483, 563], [565, 565, 586, 586, 664], [666, 666, 689, 689, 1029], [1031, 1031, 1048, 1048, 1473], [1475, 1513, 1534, 1534, 1785], [1787, 1787, 1806, 1806, 2058], [2060, 2060, 2099, 2099, 2874], [2875, 2875, 2947, 2947, 3222], [3224, 3224, 3273, 3273, 4733], [4735, 4735, 4792, 4792, 5567]], "test": "untested"}
{"id": "tsjcD3", "name": "glslpractice2", "author": "bigdra50", "description": "practice", "tags": ["practice"], "likes": 0, "viewed": 287, "published": 3, "date": "1587466634", "time_retrieved": "2024-07-30T21:11:21.951420", "image_code": "vec2 rot(vec2 p, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec2(p.x*c - p.y*-s, p.x*s+p.y*c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 c = vec3(0);\n    vec2 p = ((fragCoord.xy/iResolution.xy)-.5)*2.;\n    \n    c.yz = vec2(.04/abs(.03-length(p)));\n    p+=rot(c.xy, iTime);\n\n    float t = atan(p.y, p.x)+iTime*2.5;\n    p = rot(rot(p, iTime), t);\n    vec2 q = p;\n    q*= p*(1.2+sin(t*7.))*.5;  // -1 ~ 1 -> 0 ~ 1\n    q*= p*(1.2+cos(t*3.5))*5.;  // -1 ~ 1 -> 0 ~ 1\n    vec2 v = vec2(1.+cos(t*10.), 1.+tan(iTime*10.));\n    c.x = dot(p, v) / abs(.5-(length(q)*abs(length(q))));\n    c = smoothstep(0., .1, c);\n    c.yz += p;\n\n    fragColor = vec4(vec3(abs(.5-length(c.x+q.y)), 1.-(c.y*p.x), c.z+q.x+p.y), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjcD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 131], [133, 133, 188, 188, 765]], "test": "untested"}
{"id": "wsByWV", "name": "Voxel game Evolution", "author": "kastorp", "description": "my first shader.\nTHIS SHADER IS BASED ON  \"[SH16C] Voxel Game\" by fb39ca4  ", "tags": ["mc"], "likes": 307, "viewed": 27959, "published": 3, "date": "1587452922", "time_retrieved": "2024-07-30T21:11:23.373617", "image_code": "/*---------------------------------------------------------\n\tTHIS SHADER IS BASED ON  \"[SH16C] Voxel Game\" by fb39ca4  \n  \t\n\twhen switching to full screen press L until you get better performance (K for higher resolution)\n\nCONTROLS:\n    drag mouse to move view and select blocks\n    WASD or arrows to move\n    Space to jump\n    Double-tap space to start flying, use space and shift to go up and down.\n\n    mouse double click to select/unselect a block (doesn't work well with low framerate\n    Q + mouse button to place block \n    E + mouse button to destroy blocks \n\tR + mouse button to change shape of a block \n\tF + mouse button to rotate a shape on z axis \n\tG + mouse button to rotate a shape on y axis\n\tC + mouse button to select multiple blocks (hold on \"C\" to clear selection)\n\tdestroy,place, shape,rotate also work on selected blocks, without mouse button\n\n    mouse click on inventory to select a block type\n\tM to toggle map\n\tI to toggle inventory (hidden, simple, full)\n\n\tO,P to decrease/increase speed of day/night cycles   \n    k,L to decrease/increase pixel sizes \n\tT to teleport to a random location\n    Page Up/Down to increase or decrease zoom \n\tF7 enable/disable torch light diffusion (flickering on some GPUs)\n\tF8 enable/disable water flow\n\nBLOCK MECHANICS:\n\n\t TORCH= light\n\t TREE= grows if placed\n\t DIAMOND= illumninated if close to GOLD or other illuminated diamonds\n\t RED BLOCK= mirror \n\t WATER= semtrasparent, flows downwards\n\t SAND = falls if in empty space or with 4 horizontal steps\n\t PINK MARBLE= infinite water source\n\nCONFIGURATION:\n\tsee #define settings in \"Common\" file \n\nBUFFERS:\n    \"BUFFER A\": actions, collisions, settings, material textures\n    \"BUFFER B\": voxel cache, nearest blocks full height \n    \"BUFFER C\": surface voxel cache (just one block for every xy position)\n    \"BUFFER D\": rendering, map\n    \"IMAGE\"   : gui, stats\n\nCREDITS:\n\tVoxel game: @fb39ca4 https://shadertoy.com/view/MtcGDH\n\tVoxel traversal: @Iq https://www.shadertoy.com/view/4dfGzs\n\tGLSL Number Printing:  @P_Malin https://www.shadertoy.com/view/4sBSWW\n\tTextures: @Reinder https://www.shadertoy.com/view/4ds3WS\n\tencoding/decoding: @Eiffie https://www.shadertoy.com/view/wsBfzW\n\tgrass: @W23 https://www.shadertoy.com/view/MdsGzS\n\tNoise: @Makio64 https://shadertoy.com/view/Xd3GRf\n\twater reflection:@Reinder https://www.shadertoy.com/view/MdXGW2\n\nCHANGELOG & TODO: \n\tsee bottom of the file\n\n//-----------------------------------------------------*/\n\n\n#ifdef STATS\n\n// ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n// Creative Commons CC0 1.0 Universal (CC-0) \n// https://www.shadertoy.com/view/4sBSWW\nfloat DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue(const in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n    vec2 vStringCharCoords = (fragCoord.xy - vPixelCoords) / vFontSize;\n    if ((vStringCharCoords.y < 0.0) || (vStringCharCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCharCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n\t\t\t\tif(fDigitIndex < 0.0) fDigitIndex += 1.0;\n\t\t\t\tfloat fDigitValue = (abs(fValue / (pow(10.0, fDigitIndex))));\n                float kFix = 0.0001;\n                fCharBin = DigitBin(int(floor(mod(kFix+fDigitValue, 10.0))));\n\t\t\t}\t\t\n\t\t}\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCharCoords.x) * 4.0) + (floor(vStringCharCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n#endif\n\n\nvec4 drawSelectionBox(vec2 c) {\n\tvec4 o = vec4(0.);\n    float d = max(abs(c.x), abs(c.y));\n    if (d > 6. && d < 9.) {\n        o.a = 1.;\n        o.rgb = vec3(0.9);\n        if (d < 7.) o.rgb -= 0.3;\n        if (d > 8.) o.rgb -= 0.1;\n    }\n    return o;\n}\n\nmat2 inv2(mat2 m) {\n  return mat2(m[1][1],-m[0][1], -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nvec4 drawInventory(vec2 c) {\n    \n    float h= (load(_inventory).r>1.?NUM_ITEM_ROWS:1.);\n\tfloat scale = floor(iResolution.y / 128.);\n    c /= scale;\n    vec2 r = iResolution.xy / scale;\n    vec4 o = vec4(0);\n    float xStart = (r.x - 16. * NUM_ITEMS) / 2.;\n    c.x -= xStart;\n    float selected = load(_selectedInventory).r;\n    vec2 p = (fract(c / 16.) - .5) * 3.;\n    vec2 u = vec2(sqrt(3.)/2.,.5);\n    vec2 v = vec2(-sqrt(3.)/2.,.5);\n    vec2 w = vec2(0,-1);\n    if (c.x < NUM_ITEMS * 16. && c.x >= 0. && c.y < 16.* h ) {\n        float slot = floor(c.x / 16.) + NUM_ITEMS*floor(c.y / 16.) ;\n    \to = getTexture(48., fract(c / 16.));\n        vec3 b = vec3(dot(p,u), dot(p,v), dot(p,w));\n        vec2 texCoord;\n        //if (all(lessThan(b, vec3(1)))) o = vec4(dot(p,u), dot(p,v), dot(p,w),1.);\n        float top = 0.;\n        float right = 0.;\n        if (b.z < b.x && b.z < b.y) {\n        \ttexCoord = inv2(mat2(u,v)) * p.xy;\n            top = 1.;\n        }\n        else if(b.x < b.y) {\n        \ttexCoord = 1. - inv2(mat2(v,w)) * p.xy;\n            right = 1.;\n        }\n        else {\n        \ttexCoord = inv2(mat2(u,w)) * p.xy;\n            texCoord.y = 1. - texCoord.y;\n        }\n        if (all(lessThanEqual(abs(texCoord - .5), vec2(.5)))) {\n            float id = getInventory(slot);\n            if (id == 3.) id += top;\n            o.rgb = getTexture(id, texCoord).rgb * (0.5 + 0.25 * right + 0.5 * top);\n            o.a = 1.;\n        }\n    }\n    vec4 selection = drawSelectionBox(c - 8. - vec2(16. * mod(selected,NUM_ITEMS), 16.* floor(selected/NUM_ITEMS)));\n    o = mix(o, selection, selection.a);\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float pixelSize = load(_pixelSize).r;\n    vec2 renderResolution = ceil(iResolution.xy / pixelSize); \n    fragColor = texture(iChannel3, fragCoord * renderResolution / iResolution.xy / iResolution.xy);\n    //fragColor = texture(iChannel3, fragCoord);\n    \n    if(load(_inventory).r>.0){   \n   \t     vec4 gui = drawInventory(fragCoord);\n   \t    fragColor = mix(fragColor, gui, gui.a);\n    }\n    \n#ifdef STATS    \n    //DISPLAY STATS IF F3 IS TOGGGLED\n    float stats = load(_stats).r;    \n    if (stats >0.5) {\n        vec3 pos = load(_pos).xyz;\n        \n\n        //POS\n        fragColor = mix( fragColor, vec2(1,.5).xyyx, PrintValue(fragCoord, vec2(0., iResolution.y - 20.), vec2(8,15), pos.x, 5.0, 5.0));\n        fragColor = mix( fragColor, vec2(1,.5).yxyx, PrintValue(fragCoord, vec2(0., iResolution.y - 40.), vec2(8,15), pos.y, 5.0, 5.0));\n        fragColor = mix( fragColor, vec2(1,.5).xxyx, PrintValue(fragCoord, vec2(0., iResolution.y - 60.), vec2(8,15), pos.z, 5.0, 5.0));\n\n        //ANGLE\n        fragColor = mix( fragColor, vec2(1,.5).xyyx, PrintValue(fragCoord, vec2(0., iResolution.y -80.), vec2(8,15),  load(_angle).x, 5.0, 2.0));\n        fragColor = mix( fragColor, vec2(1,.5).xxxx, PrintValue(fragCoord, vec2(50., iResolution.y -80.), vec2(8,15),  load(_angle).y, 5.0, 2.0)); \n \n        //TIME\n        fragColor = mix( fragColor, vec2(1,.5).xxxx , PrintValue(fragCoord, vec2(0., iResolution.y -100.), vec2(8,15), load(_time).r, 5.0, 2.0));\n\n\n        \n        //if (fragCoord.x < 20.) fragColor.rgb = mix(fragColor.rgb, texture(iChannel0, fragCoord / iResolution.xy).rgb, texture(iChannel0, fragCoord / iResolution.xy).a);\n        \n        //FRAMERATE, MEMORY RANGE, HEIGHT LIMIT, RAY DISTANCE\n        fragColor = mix( fragColor, vec2(1,.5).xxyx, PrintValue(fragCoord, vec2(0.0, 105.), vec2(8,15), load(_pixelSize).r, 5.0, 1.0));\n        fragColor = mix( fragColor, vec2(1,.5).xxyx, PrintValue(fragCoord, vec2(0.0, 85.), vec2(8,15), 1./ iTimeDelta, 5.0, 1.0));\n\n#if SURFACE_CACHE>0\n        fragColor = mix( fragColor, vec2(1,.5).yxxx, PrintValue(fragCoord, vec2(0., 65.), vec2(8,15), calcLoadDist_C( iChannelResolution[2].xy), 5.0, 2.0));\n        fragColor = mix( fragColor, vec2(1,.5).xxxx, PrintValue(fragCoord, vec2(0., 45.), vec2(8,15),  heightLimit_C, 5.0, 2.0));\n#endif\n        fragColor = mix( fragColor, vec2(1,.5).xxxx, PrintValue(fragCoord, vec2(0., 25.), vec2(8,15),  load(_rayDistMax).r, 5.0, 2.0));\n\n    }\n\t\n    // \"BUFFER C\" DUMP\n    if(load(_stats).g>.5) {               \n        vec3 offset = floor(vec3(load(_pos).xy, 0.));\n        vec4  color= texture(iChannel2,fragCoord / iResolution.xy);\n        fragColor = color;       \n    }\n    //\"BUFFER A\" DUMP\n\n    if(load(_stats).b>.5) fragColor= texture(iChannel0, fragCoord /iResolution.xy/3.);\n\n#endif\n}\n/*\nCHANGELOG \n\t- 20200425: added elevators\n\t            added repeated towers\n                20200425-1902: fixed map key\n\t- 20200426: new materials; voxel.value to store user actions and prevent override\n         \t    select from inventory with mouse\n    \t \t    more realistic elevator, stabilizing adaptive pixelSize and renderDistance\n                fix: when placing & destroying a block, it becomes invisible\n                fix: tree grows correctly when placed\n                water block not solid and semi-transparent \n    - 20200427: structures are placed randomly; water in caves and water swimming\n                added optional \"#define FAST_COMPILE\" (uncomment row32 of file common to reduce compilation time by half)\n                Pyramids\n                water flow downward\n    - 20200428: water refraction and waves\n\t            fog and clouds\n\t- 20200429: cut compilation time - removed duplicated call to render() in buffer D\n\t- 20200501: compilation optimization and fixed inventory bug\n\t \t\t    replaced voxel traversal algorithm with the one described in \"Voxel Edge Occlusion\" by Iq\n\t \t\t\tskeleton for subvoxels\n\t- 20200502: revised light diffusion and default\n\t- 20200503: added shapes (change shape with \"R\")\n\t            shape rotation ( with \"F\")\n\t- 20200504: shape vertical rotation ( with \"G\") ... not always working\n\t            disabled unecessary keys\n\t            multiselection with \"C\" \n\t- 20200505: shadows; working but unfinished\n\t            fixed shadows (#ifdef SHADOW);now working\n\t- 20200509: webgl 1.0 compatibility and compilation optimization\n\t            compilation optimization\n\t- 20200510: tree detail (can be disable)\n\t            optimization: discard if unused texels in buffer A & C\n\t            revised textures (need to refine) \n\t            refactoring - merged buffer A & buffer C with better performances\n\t- 20200511: refactoring in buffer B neightbour scan; grass prototype\n\t            grass rendering from https://www.shadertoy.com/view/MdsGzS\n\t- 20200512: configurable cloud density , grass height & pathway\n\t- 20200513: inventory toggle with \"I\" \n\t            proof of concept: electriciy with gold=source, diamond=wire\n\t- 20200514: lighing of unconnected blocks or sand with more than 4 horizontal steps\n\t            falling sand if  more than 4 horizontal steps\n\t- 20200515: demo mode at start\n\t- 20200518: minimalist mirror (red block)\n\t- 20200520: revised encode/decodeVoxel in order to exploit al 64 pixel bits\n\t- 20200522: refactoring calcOcclusion()\n\t- 20200523: mouse double click \n\t- 20200524: refactoring: reused raycasting in buffer D for mouse pointer\n\t- 20200526: added buffer C(surface cache) and other refactoring\n\t- 20200603: added water physics and water source (pink marble) - work in progress\n\t- 20200608: performance optimization and revised subvoxel rendering with SUBTEXTURE\n\t- 20200609: refactoring calcOcclusion (less code & reduced compilation time)\n\t            refactoring reflection (mirror block) and refraction (water)\n\t- 20200611: heightmap cache in buffer C (much faster and many new possibilities)\n\t            far trees (work in progress)\n\t- 20200612: fixed shadows & occlusion  for subvoxels\n                map view rotation, detailed buildings, configurable building distance\n\t- 20200625: variable water level (50% of the territory is flooded)\n\t- 20200704: more realistic water refraction and reflection (inspired by Venice shader)\n\t- 20200712: pseudo Fresnel reflection \n\t- 20200723: enable/disable torch(F7) and water flow (F8)\n\nTODO LIST:\n\t- substitute buffer B/C with cubemap  (done but not working https://www.shadertoy.com/view/3t2yWR)\n\t- more shapes and materials \n\t- more menus (shape, rotation, etc..) \n\t- circuits (wire, gate, flip-flop, sensor, etc...) --> in a fork\n\t- portals\n    - constructions: bridge, tower,wall, road\n\t- explosions\n\n*/", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/* ----------------------------------------------------------\n\tCONFIGURABLE SETTINGS\n//----------------------------------------------------------*/\n//  MAX_PICK_DISTANCE: distance for block selection with mouse (default = 10)\n#define MAX_PICK_DISTANCE 10.\n//  FAST_NOISE: use cheaper noise function \n#define FAST_NOISE\n//\tOCCLUSION: enable voxel occlusion\n#define OCCLUSION\n//  SUBVOXEL: enable shapes actions with keys R,F,G\n#define SUBVOXEL\n//\tSUBTEXTURE: apply texture scaled on subvoxels (more detailed but aliased)\n//#define SUBTEXTURE\n//\tTREE_DETAIL: if enabled, tree blocks are detailed with subvoxels \n#define TREE_DETAIL\n//\tTREE SIZE: height of the trees \n#define TREE_SIZE 3.\n//  GRASS_DETAIL: enable grass\n#define GRASS_DETAIL\n//  SHADOW 0.=disabled else shadow intensity\n#define SHADOW 1.\n//  CLOUDS 0.=disabled else cloud density (*)\n//#define CLOUDS 1.5\n//  FALLING_SAND: sand blocks fall if unstable \n//#define FALLING_SAND\n//  MAP: map rendering\n#define MAP\n//\tHIGHLIGHT 0.=disabled else higlight of  unconnected blocks, sand with 4+ horizontal steps, cascading diamonds connected to gold\n#define HIGHLIGHT 0.\n//\tSURFACE_CACHE:  secondary cache mode with buffer C (1=surface blocks,2=heightmap,0=disabled)\n#define SURFACE_CACHE 2\n//\tSTRUCTURES: build pyramids & towers; values 0=none, 1=basic, 2=detailed\n#define STRUCTURES 2 \n//  STATS: display debug info if F3,F4,F5 keys pressed \n//#define STATS\n//\tFLAT: flat world\n//#define FLAT\n//  XRAY_MODE: fly mode, with no collisions and transparent blocks (*)\n//#define XRAY_MODE\n// \tEXCLUDE_CACHE:view only mode, with disabled buffer B \n//#define EXCLUDE_CACHE\n//\tWATER_LEVEL: level of water (10.=caves, 55.= islands); 50% of the areas use WATER_LEVEL2\n#define WATER_LEVEL 12.\n#define WATER_LEVEL2 45.\n//\tWATER_FLOW: enable water flow (value= levelling distance)\n#define WATER_FLOW 250.\n//  BUILD_DISTANCE average distance between costructions\n#define BUILD_DISTANCE 160.\n\n//use 124 bits per texel (it's warking but not necessary yet)\n//#define ENCODE124\n// flickering light from fireflies at night\n#define FIREFLIES\n\n//WIP MARCHING CUBES\n//#define MC\n//------------------------------------------------------\n\n//SHARED VARIABLES\n#define var(name, x, y) const vec2 name = vec2(x, y)\n#define varRow 0.\n#define load( coord)  texture(iChannel0, vec2((floor(coord) + 0.5) / iChannelResolution[0].xy)) \n#define getTexture( id,  c) texture(iChannel0, 16. * (clamp(c,0.001,.999) + vec2(mod(id, 8.), floor(id / 8.)+2.)) / iChannelResolution[0].xy, 0.0)\n\n//shared variables are stored in buffer A where  y=0\nvar(_pos, 0, varRow);//_old _pos\nvar(_angle, 2, varRow);\nvar(_mouse, 3, varRow);\nvar(_loadRange_B, 4, varRow);\nvar(_loadRange_C, 5, varRow);\nvar(_vel, 6, varRow);\nvar(_pick, 7, varRow);//_old _pick\nvar(_pickTimer, 8, varRow);  //_old _pickTimer\nvar(_renderScale, 9, varRow);\nvar(_selectedInventory, 10, varRow);\nvar(_flightMode, 11, varRow);\nvar(_sprintMode, 12, varRow);\nvar(_time, 13, varRow);\nvar(_stats, 14, varRow);\nvar(_rayDistMax,15,varRow);\nvar(_loadDistLimit,16,varRow);\nvar(_rayLimit,17,varRow);\nvar(_map,18,varRow);\nvar(_pixelSize,19,varRow);\nvar(_inventory,20,varRow);\nvar(_demo,21,varRow);\nvar(_mouseBusy,22,varRow);\nvar(_torch,23,varRow);\nvar(_flow,24,varRow);\n//old value are stored in rows with y=n where n is the iFrame difference\nvar(_old, 0, 1); \n\n//BUFFER B\nconst int  BUFFER_B = 1;\nconst vec2 packedChunkSize_B = vec2(13,7);\nconst float heightLimit_B = packedChunkSize_B.x * packedChunkSize_B.y;\n\n//BUFFER C\n#if SURFACE_CACHE==1\nconst int  BUFFER_C = 2;\nconst float SURFACE_C=45.;\nconst vec2 packedChunkSize_C = vec2(7,4);\nconst float heightLimit_C = packedChunkSize_C.x * packedChunkSize_C.y ;\n#elif SURFACE_CACHE==2\nconst int  BUFFER_C = 2;\nconst vec2 packedChunkSize_C = vec2(1,1);\nconst float heightLimit_C = packedChunkSize_C.x * packedChunkSize_C.y ;\n#endif\n\n\n//INVENTORY ITEMS FOR EACH ROW\nconst float NUM_ITEMS=8.;\n//INVENTORY ROWS\nconst float NUM_ITEM_ROWS=2.;\n//\nconst float N_SUBVOXEL=5.;\n// USED BY FALLING SANDS\nconst float MAX_GROUND=45.;\n\n   \n// VOXEL CACHE FUNCTION\nvec2 unswizzleChunkCoord(vec2 storageCoord) {\n \tvec2 s = floor(storageCoord);\n    float dist = max(s.x, s.y);\n    float offset = floor(dist / 2.);\n    float neg = step(0.5, mod(dist, 2.)) * 2. - 1.;\n    return neg * (s - offset);\n}\n\nvec2 swizzleChunkCoord(vec2 chunkCoord) {\n    vec2 c = chunkCoord;\n    float dist = max(abs(c.x), abs(c.y));\n    vec2 c2 = floor(abs(c - 0.5));\n    float offset = max(c2.x, c2.y);\n    float neg = step(c.x + c.y, 0.) * -2. + 1.;\n    return (neg * c) + offset;\n}\n\n\nfloat calcLoadDist_B(vec2 iResolutionxy) {\n    vec2  chunks = floor(iResolutionxy / packedChunkSize_B); \n    float gridSize = min(chunks.x, chunks.y);    \n    return floor((gridSize - 1.) / 2.);\n}\n\nvec4 calcLoadRange_B(vec2 pos,vec2 iResolutionxy, float border) {\n\tvec2 d = (calcLoadDist_B(iResolutionxy) - border)* vec2(-1,1);\n    return floor(pos).xxyy + d.xyxy;\n}\n\n#if SURFACE_CACHE>0\nfloat calcLoadDist_C(vec2 iResolutionxy) {\n    vec2  chunks = floor(iResolutionxy / packedChunkSize_C); \n    float gridSize = min(chunks.x, chunks.y);    \n    return floor((gridSize - 1.) / 2.);\n}\n\nvec4 calcLoadRange_C(vec2 pos,vec2 iResolutionxy, float border) {\n\tvec2 d = (calcLoadDist_C(iResolutionxy) - border)* vec2(-1,1);\n    return floor(pos).xxyy + d.xyxy;\n}\n#endif \n\nvec3 texToVoxCoord(vec2 textelCoord, vec3 offset,int bufferId) {\n#if SURFACE_CACHE>0\n    vec2 packedChunkSize= bufferId==1?packedChunkSize_B:packedChunkSize_C;\n#else\n    vec2 packedChunkSize= packedChunkSize_B;\n#endif\n\tvec3 voxelCoord = offset;\n    voxelCoord.xy += unswizzleChunkCoord(textelCoord / packedChunkSize);\n    voxelCoord.z += mod(textelCoord.x, packedChunkSize.x) + packedChunkSize.x * mod(textelCoord.y, packedChunkSize.y);\n    return voxelCoord;\n}\n\nvec2 voxToTexCoord(vec3 voxCoord,int bufferId) {\n#if SURFACE_CACHE>0\n    vec2 packedChunkSize= bufferId==1?packedChunkSize_B:packedChunkSize_C;\n#else\n    vec2 packedChunkSize= packedChunkSize_B;\n#endif\n    vec3 p = floor(voxCoord);\n    return swizzleChunkCoord(p.xy) * packedChunkSize + vec2(mod(p.z, packedChunkSize.x), floor(p.z / packedChunkSize.x));\n}\n\n\nstruct voxel {\n\tfloat id;\n    int value; //1=modified,2=selected,3=falling\n    vec2 light;\n    float life;\n    int shape;\n    float rotation;\n    float ground;\n    float surface;\n    int buffer;\n   \n     \n};\n#ifndef ENCODE124\n//from https://www.shadertoy.com/view/wsBfzW\nfloat gb(float c, float start, float bits){return mod(floor(c/pow(2.,start)),pow(2.,bits));}//get bits\n\n//lazy version:\n//#define sb(f,s,b,v) f+=(v-gb(f,s,b))*pow(2.,s)\n//strict version (use in case of strange behaviours):\n#define sb(f,s,b,v) f+=(clamp(floor(v+.5),0.,pow(2.,b)-1.)-gb(f,s,b))*pow(2.,s)\n//experimenting  124bit encode/decode functions from https://www.shadertoy.com/view/tsGBWy\n\nvoxel decodeVoxel(vec4 t) {\n\tvoxel o;\n    o.id        = gb(t.r,0., 6.);\n    o.value     = int(gb(t.r,6., 2.));\n    \n    o.light.s   = gb(t.g,0., 4.) ;\n    o.light.t   = gb(t.g,4., 4.);\n    o.life      = gb(t.g,8., 8.);\n    \n    o.shape     = int(gb(t.b,0., 4.));\n    o.rotation  = gb(t.b,4., 4.);\n    \n    o.ground    = gb(t.a,0., 8.);\n    o.surface   = gb(t.a,8., 8.);\n    return o;\n}\n\nvec4 encodeVoxel(voxel v) {\n\tvec4 t=vec4(0.);\n    sb(t.r,0.,6.,v.id);\n    sb(t.r,6.,2.,float(v.value));\n    \n    sb(t.g,0.,4.,v.light.s);\n    sb(t.g,4.,4.,v.light.t);\n    sb(t.g,8.,8.,v.life); \n    \n    sb(t.b,0.,4.,float(v.shape));\n    sb(t.b,4.,4.,v.rotation);\n    \n    sb(t.a,0.,8.,v.ground);\n    sb(t.a,8.,8.,v.surface);\n    return t;\n}\n#else\n#define BITS 32.\n#define MAXUINT  0xFFFFFFFFu \n\n\n// pixel is a 128 bit mask (0-31 -> x, 32-63 -> y, 64-95 -> z, 96-127 -> w)\nuint getBit(inout uvec4 bm, uint i)\n{\n    uint bv = i/uint(BITS),  bi= i%uint(BITS);\n       \n    return  (bm[bv]  &  (1u<<bi) )>0u?1u:0u;\n}\n\n//works only if n<=32u \nuint getBits(inout uvec4 bm, uint k, uint n){\n   \n    \n    uint bv = k/uint(BITS),  bi= k%uint(BITS);\n    if(n+bi<=32u){\n        //inside vec4 dimension\n        uint m = (1u<<n)-1u; \n        return (bm[bv] & (m<<bi) )>>bi;\n    }\n    else\n    {\n        //cross dimension\n        uint n1= 32u-bi, n2 = bi+n-32u;\n        uint m1 =(1u<<n1)-1u, m2= (1u<<n2)-1u;\n        return ((bm[bv] & (m1<<bi) )>>bi) \n             + ((bm[bv+1u] & m2 )<<n1);\n    }\n}\n\n// set bit value in a 128 bit mask \nvoid setBit(inout uvec4 bm, uint i, uint val){\n    uint bv = i/uint(BITS),  bi= i%uint(BITS);\n    bm[bv]  &= ( MAXUINT - (1u<<bi) );\n    if(val>0u)  bm[bv]  +=(1u<<bi);\n}\n\nvoid setBits(inout uvec4 bm, uint i, uint n, uint val){\n    val =clamp( val, 0u, (1u<<n)-1u) ;\n\n    //TODO REPLACE WITH A SINGLE EXPRESSION WITHOUT CYCLING\n    uint bv = i/uint(BITS),  bi= i%uint(BITS);\n    if(n+bi<=32u){\n        bm[bv]  &= ( MAXUINT - (((1u<<n)-1u ) <<bi) );\n        bm[bv]  +=(val<<bi);\n    }\n    else\n    {\n        for(uint j=0u; j<n;j++) \n        {\n            uint b = (val  &  (1u<<j) )>0u?1u:0u;\n            setBit(bm, i+j, b);\n        }\n    }\n}\n\nvoxel decodeVoxel(vec4 t) {\n\tvoxel o;\n    uvec4 iv =  floatBitsToUint(t);\n    o.id        = float(getBits(iv,0u,6u)); \n    o.value     = int(getBits(iv,6u,2u));   \n    o.light.s   = float(getBits(iv,8u, 4u) );\n    o.light.t   = float(getBits(iv,12u, 4u));\n    o.life      = float(getBits(iv,16u, 9u));\n    \n    o.shape     = int(getBits(iv,64u, 4u));\n    o.rotation  = float(getBits(iv,68u, 4u));\n    \n    o.ground    = float(getBits(iv,72u, 8u));\n    o.surface   = float(getBits(iv,80u, 8u));\n    return o;\n}\n\nvec4 encodeVoxel(voxel v) {\n\tuvec4 iv = uvec4(MAXUINT);\n    setBits(iv, 0u,6u,uint(v.id));\n    setBits(iv, 6u,2u,uint(v.value));    \n    setBits(iv,8u,4u,uint(v.light.s));\n    setBits(iv,12u,4u,uint(v.light.t));\n    setBits(iv,16u,9u,uint(v.life)); \n    iv.y=1u; //unused\n    setBits(iv,64u,4u,uint(v.shape));\n    setBits(iv,68u,4u,uint(v.rotation));\n    setBits(iv,72u,8u,uint(v.ground));\n    setBits(iv,80u,8u,uint(v.surface));\n    iv.w=1u; //unused\n    \n    uvec4 c = uvec4( getBits(iv,24u,7u),getBits(iv,56u,7u),getBits(iv,88u,7u),getBits(iv,120u,7u));\n    setBit(iv,31u,c.x==0u?1u:0u);setBit(iv,63u,c.y==0u?1u:0u);setBit(iv,95u,c.z==0u?1u:0u);setBit(iv,127u,c.w==0u?1u:0u);\n    \n    return uintBitsToFloat(iv);\n}\n#endif\n\nfloat lightDefault(float z){\n\tif(z>55.) return 15.;\n    else if(z>45.) return 14.; \n    else if(z>35.) return 11.; \n    else if(z>10.) return 8.;\n    else return 5.;\n}\n\nvoxel newVox(float z){\n    voxel vox;\n    vox.life=0.;\n    vox.rotation=0.;\n    vox.value=0;\n    vox.shape=0;\n    vox.ground=200.;\n    vox.surface=0.;\n\tvox.id=0.;\n    vox.light.t = z>10.? 0.:12.;\n    vox.light.s = lightDefault(z);\n \tvox.id=0.;\n    vox.buffer=0;\n    return vox;\n}\n\nvec4 readMapTex(vec2 pos, sampler2D iChannel,vec3 resolution) {\n    return texture(iChannel, (floor(pos) + 0.5) /  (floor (resolution.xy)), 0.0);   \n \n}\n\n\nvoxel getCachedVoxel(vec3 p,sampler2D iChannel,vec3 resolution,int bufferId) {\n    if(p.z>heightLimit_B || p.z<0.){voxel vox; vox.id=0.; return vox;}\n    voxel vox= decodeVoxel(readMapTex(voxToTexCoord(p, bufferId),iChannel,resolution));\n    vox.buffer=bufferId;\n    return vox;\n}\n\n\nfloat isSolidVoxel(voxel vox) {\n    \n    return (vox.id==0. || vox.id==12. ||vox.id==26.)?0.:1.;\n}\n\nfloat getInventory(float slot) {\n\treturn slot + 1. + step(2.5, slot);  \n}\n\n\n\n// WORLD GENERATION \n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\nconst float PI = 3.14159265359;\n\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n    \nfloat hash2(in vec2 p) { return hash(dot(p, vec2(87.1, 313.7))); }\n\nvec2 hash22(in float p) {\n\tfloat x = hash(p);\n\treturn vec2(x, hash(p+x));\n}\n//vec2 hash22(in vec2 p) { return hash2(dot(p, vec2(87.1, 313.7))); }\n\n\nvec2 hash22( vec2 p ) \n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\n\n\n// Fork of \"Optimized Ashima SimplexNoise3D\" by Makio64. https://shadertoy.com/view/Xd3GRf\n// 2020-04-23 14:52:01\n\n// Optimized AshimaSimplexNoise by @makio64 https://www.shadertoy.com/view/Xd3GRf\n// Original : https://github.com/ashima/webgl-noise/blob/master/src/noise3D.glsl\n\n#ifndef FAST_NOISE\nlowp vec4 permute(in lowp vec4 x){return mod(x*x*34.+x,289.);}\nlowp float snoise(in mediump vec3 v){\n  const lowp vec2 C = vec2(0.16666666666,0.33333333333);\n  const lowp vec4 D = vec4(0,.5,1,2);\n  lowp vec3 i  = floor(C.y*(v.x+v.y+v.z) + v);\n  lowp vec3 x0 = C.x*(i.x+i.y+i.z) + (v - i);\n  lowp vec3 g = step(x0.yzx, x0);\n  lowp vec3 l = (1. - g).zxy;\n  lowp vec3 i1 = min( g, l );\n  lowp vec3 i2 = max( g, l );\n  lowp vec3 x1 = x0 - i1 + C.x;\n  lowp vec3 x2 = x0 - i2 + C.y;\n  lowp vec3 x3 = x0 - D.yyy;\n  i = mod(i,289.);\n  lowp vec4 p = permute( permute( permute(\n\t  i.z + vec4(0., i1.z, i2.z, 1.))\n\t+ i.y + vec4(0., i1.y, i2.y, 1.))\n\t+ i.x + vec4(0., i1.x, i2.x, 1.));\n  lowp vec3 ns = .142857142857 * D.wyz - D.xzx;\n  lowp vec4 j = -49. * floor(p * ns.z * ns.z) + p;\n  lowp vec4 x_ = floor(j * ns.z);\n  lowp vec4 x = x_ * ns.x + ns.yyyy;\n  lowp vec4 y = floor(j - 7. * x_ ) * ns.x + ns.yyyy;\n  lowp vec4 h = 1. - abs(x) - abs(y);\n  lowp vec4 b0 = vec4( x.xy, y.xy );\n  lowp vec4 b1 = vec4( x.zw, y.zw );\n  lowp vec4 sh = -step(h, vec4(0));\n  lowp vec4 a0 = b0.xzyw + (floor(b0)*2.+ 1.).xzyw*sh.xxyy;\n  lowp vec4 a1 = b1.xzyw + (floor(b1)*2.+ 1.).xzyw*sh.zzww;\n  lowp vec3 p0 = vec3(a0.xy,h.x);\n  lowp vec3 p1 = vec3(a0.zw,h.y);\n  lowp vec3 p2 = vec3(a1.xy,h.z);\n  lowp vec3 p3 = vec3(a1.zw,h.w);\n  lowp vec4 norm = inversesqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  lowp vec4 m = max(.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.);\n  return -0.334 +.5 + 12. * dot( m * m * m, vec4( dot(p0,x0), dot(p1,x1),dot(p2,x2), dot(p3,x3) ) );\n}\n// Optimized Ashima Simplex noise2D by @makio64 https://www.shadertoy.com/view/4sdGD8\n// Original shader : https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\n// snoise return a value between 0 & 1\n\nlowp vec3 permute(in lowp vec3 x) { return mod( x*x*34.+x, 289.); }\nlowp float snoise(in lowp vec2 v) {\n  lowp vec2 i = floor((v.x+v.y)*.36602540378443 + v),\n      x0 = (i.x+i.y)*.211324865405187 + v - i;\n  lowp float s = step(x0.x,x0.y);\n  lowp vec2 j = vec2(1.0-s,s),\n      x1 = x0 - j + .211324865405187, \n      x3 = x0 - .577350269189626; \n  i = mod(i,289.);\n  lowp vec3 p = permute( permute( i.y + vec3(0, j.y, 1 ))+ i.x + vec3(0, j.x, 1 )   ),\n       m = max( .5 - vec3(dot(x0,x0), dot(x1,x1), dot(x3,x3)), 0.),\n       x = fract(p * .024390243902439) * 2. - 1.,\n       h = abs(x) - .5,\n      a0 = x - floor(x + .5);\n  return -0.278 + .5 + 65. * dot( pow(m,vec3(4.))*(- 0.85373472095314*( a0*a0 + h*h )+1.79284291400159 ), a0 * vec3(x0.x,x1.x,x3.x) + h * vec3(x0.y,x1.y,x3.y));\n}\n#endif\n\n#ifdef FAST_NOISE\nfloat snoise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash22(i+0.0)), dot(b,hash22(i+o)), dot(c,hash22(i+1.0)));\n    \n    return dot( n, vec3(70.0) );\n}\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,128.852))) * 43758.5453)*2.0-1.0;\n}\nfloat snoise(vec3 p)\n{\n \t\n\tfloat f3 = 1.0/3.0;\n\tfloat s = (p.x+p.y+p.z)*f3;\n\tint i = int(floor(p.x+s));\n\tint j = int(floor(p.y+s));\n\tint k = int(floor(p.z+s));\n\t\n\tfloat g3 = 1.0/6.0;\n\tfloat t = float((i+j+k))*g3;\n\tfloat x0 = float(i)-t;\n\tfloat y0 = float(j)-t;\n\tfloat z0 = float(k)-t;\n\tx0 = p.x-x0;\n\ty0 = p.y-y0;\n\tz0 = p.z-z0;\n\t\n\tint i1,j1,k1;\n\tint i2,j2,k2;\n\t\n\tif(x0>=y0)\n\t{\n\t\tif(y0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n\t\telse if(x0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n\t\telse { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }  // Z X Z order\n\t}\n\telse \n\t{ \n\t\tif(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n\t\telse if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n\t\telse { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n\t}\n\t\n\tfloat x1 = x0 - float(i1) + g3; \n\tfloat y1 = y0 - float(j1) + g3;\n\tfloat z1 = z0 - float(k1) + g3;\n\tfloat x2 = x0 - float(i2) + 2.0*g3; \n\tfloat y2 = y0 - float(j2) + 2.0*g3;\n\tfloat z2 = z0 - float(k2) + 2.0*g3;\n\tfloat x3 = x0 - 1.0 + 3.0*g3; \n\tfloat y3 = y0 - 1.0 + 3.0*g3;\n\tfloat z3 = z0 - 1.0 + 3.0*g3;\t\n\t\t\t\t \n\tvec3 ijk0 = vec3(i,j,k);\n\tvec3 ijk1 = vec3(i+i1,j+j1,k+k1);\t\n\tvec3 ijk2 = vec3(i+i2,j+j2,k+k2);\n\tvec3 ijk3 = vec3(i+1,j+1,k+1);\t\n            \n\tvec3 gr0 = normalize(vec3(noise3D(ijk0),noise3D(ijk0*2.01),noise3D(ijk0*2.02)));\n\tvec3 gr1 = normalize(vec3(noise3D(ijk1),noise3D(ijk1*2.01),noise3D(ijk1*2.02)));\n\tvec3 gr2 = normalize(vec3(noise3D(ijk2),noise3D(ijk2*2.01),noise3D(ijk2*2.02)));\n\tvec3 gr3 = normalize(vec3(noise3D(ijk3),noise3D(ijk3*2.01),noise3D(ijk3*2.02)));\n\t\n\tfloat n0 = 0.0;\n\tfloat n1 = 0.0;\n\tfloat n2 = 0.0;\n\tfloat n3 = 0.0;\n\n\tfloat t0 = 0.5 - x0*x0 - y0*y0 - z0*z0;\n\tif(t0>=0.0)\n\t{\n\t\tt0*=t0;\n\t\tn0 = t0 * t0 * dot(gr0, vec3(x0, y0, z0));\n\t}\n\tfloat t1 = 0.5 - x1*x1 - y1*y1 - z1*z1;\n\tif(t1>=0.0)\n\t{\n\t\tt1*=t1;\n\t\tn1 = t1 * t1 * dot(gr1, vec3(x1, y1, z1));\n\t}\n\tfloat t2 = 0.5 - x2*x2 - y2*y2 - z2*z2;\n\tif(t2>=0.0)\n\t{\n\t\tt2 *= t2;\n\t\tn2 = t2 * t2 * dot(gr2, vec3(x2, y2, z2));\n\t}\n\tfloat t3 = 0.5 - x3*x3 - y3*y3 - z3*z3;\n\tif(t3>=0.0)\n\t{\n\t\tt3 *= t3;\n\t\tn3 = t3 * t3 * dot(gr3, vec3(x3, y3, z3));\n\t}\n\treturn 96.0*(n0+n1+n2+n3);\n\t\n}\n\n#endif\n\nbool overworld(vec3 p) {\n\tfloat density = 48. - p.z;\n    density += mix(0., 40., pow(.5 + .5 * snoise(p.xy /557. + vec2(0.576, .492)), 2.)) * snoise(p / 31.51 + vec3(0.981, .245, .497));\n\n    return density > 0.;\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdCross( vec3 p, vec3 b )\n{\n  float d1 = length(max( abs(p) - b,0.));\n  float d2 = length(max( abs(p) - b.zyx,0.));\n  float d3 = length(max( abs(p) - b.xzy,0.));\n  return min(d1, min(d2,d3));\n}\n\n\nvoxel getGeneratedVoxel(vec3 voxelCoord,bool caves,int frame){\n\n    \tvoxel vox=newVox(voxelCoord.z);\n#ifdef FLAT\n    \tvox.id=(voxelCoord.z>=50.?0.:3.);\n#else \n    \n    \tbool layer[4];\n    \tfor (int i =0; i <=3 ; i++) {\n            float h;\n            if(i==1) h=1.; \n            else if(i==2) h=3.; \n            else if(i==3)  h=-1.; \n            else h=0.;\n            \n            layer[i+min(frame,0)]=overworld(voxelCoord+ vec3(0,0,h));\n            if(!layer[0]) break;\n        }\n         \n    \tbool solid = layer[0];\n    \n   \n        if (solid) {\n            //GRASS\n            vox.id = 3.;\n            \n                             \n            //DIRT\n            if (layer[1]) vox.id = 2.; \n            //ROCK\n            if (layer[2]) vox.id = 1.; \n            //TORCH\n            if (hash13(voxelCoord) > 0.98 && !layer[3]) {vox.id = 6.;vox.light.t = 15.;}\n \n            //TREE BASE\n            if (hash13(voxelCoord) > 0.98 && !layer[1]) {vox.id = 10.;vox.life = 2.+ TREE_SIZE; vox.shape=9;}\n\n             // CAVE\n            if(caves){\n                caves=snoise(voxelCoord / 27.99 + vec3(0.981, .245, .497).yzx * 17.) > 1. - (smoothstep(0., 5., voxelCoord.z) - 0.7 * smoothstep(32., 48., voxelCoord.z));\n\t        \tif (caves) {vox.id = 0.;}\n            }\n        } \n \t    \n    \t//WATER\n    \tif(vox.id == 0. && voxelCoord.z < WATER_LEVEL) {\n            vox.id=12.; \n            if(voxelCoord.z > WATER_LEVEL -2.) vox.shape=3;\n#ifdef WATER_FLOW\n            vox.life=WATER_FLOW;    \n#endif                \n         }\n        //GEMS\n        if (hash13(voxelCoord) > 0.995 && voxelCoord.z < 20.  &&  vox.id!=12. && vox.id!=0. ) {if(hash13(voxelCoord +vec3(1.))>.5) vox.id = 6.; else vox.id=8.;}    \n        //BEDROCK\n        if (voxelCoord.z < 1.) vox.id = 16.; \n    \n#if STRUCTURES>0    \n    \t// STRUCTURES REPEATED EVERY BUILD_DISTANCE SQUARE\n    \tvec3  buildCoord = vec3(floor((voxelCoord.xy -vec2(3260. -40.,9650. -40.))/BUILD_DISTANCE)*BUILD_DISTANCE,0.)   +vec3(3260.,9650.,50.);\n \t\t//RANDOM POSITION INSIDE THE 80x80 SQUARE\t buildCoord += hash33(buildCoord)\n    \tif(length(voxelCoord.xy -vec2(3260, 9650.))>50.) buildCoord += floor(hash33(buildCoord) *vec3(50.,50, .10)) -vec3(25.,25, 5.);\n   \n    \tfloat type =hash13(buildCoord);\n    \tfloat type2 =hash13(buildCoord+vec3(1.));\n        if(type2>.5 && vox.id == 0. && voxelCoord.z < WATER_LEVEL2) {\n            vox.id=12.; \n#ifdef WATER_FLOW\n            vox.life=WATER_FLOW;\n            \n            \n            if(voxelCoord.z > WATER_LEVEL2-2.) vox.shape=3; else vox.shape=0;\n#endif                \n         }\n    \tif(type<.2) {\n            //PYRAMID          \n            if(sdOctahedron(voxelCoord -  buildCoord -vec3(-2.,-3.,2.),30.)<=0.) vox.id=13.;\n\n        }\n    \telse{\n\n            //TOWER\n             if(length(voxelCoord.xy - buildCoord.xy - vec2(-2.,-3.))<2.  && voxelCoord.z <75.)  {vox.id=1.;  vox.light.t=8.;}\n            if(length(voxelCoord - buildCoord  - vec3(-2.,-3.,30.))<1.5)  {vox.id=6.;  vox.light.t=15.;}\n        }\n#endif\n    \n#endif\n        \n  \t\n        return vox;\n\t\t\n}\n\n\n\n// MIX PROCEDURAL AND MEMORY VOXEL\nbool inRange(vec2 p, vec4 r) {\n\treturn (p.x > r.x && p.x < r.y && p.y > r.z && p.y < r.w);\n}\n\n\n\nvoxel getVoxelData( vec3 voxelCoord,\n                    sampler2D iChannel_B, \n                    sampler2D iChannel_C, \n                    int frame, \n                    vec3 resolution_B, \n                    vec3 resolution_C,\n                    vec4 range_B,\n                    vec4 range_C,\n                    vec3 offset,\n                    bool caves,\n                    int caller){\n  \n#ifdef EXCLUDE_CACHE\n    return getGeneratedVoxel(voxelCoord,true,frame); \n#else    \n    \n \n    if (inRange(voxelCoord.xy,range_B) && frame > 0 && voxelCoord.z <heightLimit_B  \n        && (caller!=2)  //comment this line to enable persistence between cache (doesn't handle resolution change)\n       ) {\n        return getCachedVoxel(voxelCoord  - offset,iChannel_B,resolution_B,BUFFER_B); \n        \n    }\n#if SURFACE_CACHE==1     \n     if (inRange(voxelCoord.xy,range_C) && frame > 0  \n               &&  voxelCoord.z >= SURFACE_C\n         \t\t&& voxelCoord.z <heightLimit_C +SURFACE_C\n              //&& (caller!=1) //\n              \n             ) {\n        return getCachedVoxel(voxelCoord - vec3(0.,0.,SURFACE_C) - offset,iChannel_C,resolution_C,BUFFER_C); \n         \n    }\n#elif SURFACE_CACHE==2\n    if (inRange(voxelCoord.xy,range_C) && frame > 0){\n         if ( voxelCoord.z >= 0.&& voxelCoord.z <heightLimit_C  && (caller==2) ) {\n            // BUFFER C previous frame\n        \treturn getCachedVoxel(voxelCoord - offset,iChannel_C,resolution_C,BUFFER_C); \n         }\n        if(caller!=2){\n        \tvoxel vo= getCachedVoxel(vec3(voxelCoord.xy,0.) - offset,iChannel_C,resolution_C,BUFFER_C);\n         \tif(vo.ground>0. && vo.ground< heightLimit_B  ){\n                //Above max height of BUFFER C --> air\n                float h=voxelCoord.z-vo.ground;\n                if(h==0. ) {  return vo;}\n                \n                voxel vox=newVox(voxelCoord.z);\n             \tif(h>0. && caller==3) { \n                   \t//GRASS\n                    if(h==1. &&vo.id==3.) { vox.life=1.;}\n                    \n                    //TREE TRUNK\n                    if(h<TREE_SIZE+2. && vo.id==10. && vo.ground >= WATER_LEVEL-1.) {vox.id=10.; vox.life=2.+TREE_SIZE-h; ; vox.shape=9;}                   \n                    return vox;\n                }\n             \t\n                if(h>-3. && h<0. && vo.id==11. && caller==3) {\n                    //TREE LEAFS\n                    vox.id=11.; \n                    vox.shape=8;\n                    vox.life=0.;\n                    return vox;\n                }\n\t\t\t\t\t\n         \t}\n         }\n    }    \n#endif\n  \n    return getGeneratedVoxel(voxelCoord,caves,frame);\n#endif\n}\n\n#define getCVoxel(p,v,id)           \\\n\t{vec2 frame=(id!=3&&id!=0?_old:vec2(0.) );\\\n    vec4 range_B = load(frame+_loadRange_B);  \\\n    vec4 range_C = load(frame+_loadRange_C);  \\\n    vec3 offset =(id==0?vec3(0.): floor(vec3(load(frame+_pos).xy, 0.)));   \\\n    if(id==2)  v= getCachedVoxel(p-offset,iChannel2,iChannelResolution[2],2); \\\n    else v= getCachedVoxel(p-offset,iChannel1,iChannelResolution[1],1);}\n\n\n#define getVoxel(p,v,id)           \\\n\t{vec2 frame=(id!=3&&id!=0?_old:vec2(0.) );\\\n    vec4 range_B = load(frame+_loadRange_B);  \\\n    vec4 range_C = load(frame+_loadRange_C);  \\\n    vec3 offset =(id==0?vec3(0.): floor(vec3(load(frame+_pos).xy, 0.)));   \\\n    v= getVoxelData(p,iChannel1,iChannel2,iFrame,iChannelResolution[1],iChannelResolution[2],range_B,range_C,offset,true,id);}\n\n\n\nvoid structures(vec3 voxelCoord, inout voxel vox, vec3 oldOffset, int iFrame, float iTime){\n\n    // STRUCTURES REPEATED EVERY 80x80 SQUARE  \n    vec3  buildCoord = vec3(floor((oldOffset.xy -vec2(3260. -40.,9650. -40.))/BUILD_DISTANCE)*BUILD_DISTANCE,0.)   +vec3(3260.,9650.,50.);\n    //vec3  buildCoord= +vec3(3260.,9650.,50.);\n\n\n    //RANDOM POSITION INSIDE THE 80x80 SQUARE\n    if(length(oldOffset.xy -vec2(3260, 9650.))>50.) buildCoord += floor(hash33(buildCoord) *vec3(50.,50, .10)) -vec3(25.,25, 5.);\n    \n    //REBUILD EVERY 30 FRAMES\n\n    if(iFrame==0 || (mod(float(iFrame),30.)==0.)  && vox.value<1){\n\n   float type =hash13(buildCoord);\n#if STRUCTURES==2\n         \n    \tif(type<.2) {\n            //PYRAMID          \n\n            if(abs(sdOctahedron(voxelCoord -  buildCoord -vec3(-2.,-3.,2.),31.))<.5\n              && abs(voxelCoord.x-buildCoord.x+2.)<.5 && voxelCoord.y-buildCoord.y>-2.\n               && voxelCoord.z>48.\n              ) {vox.id=1.; vox.shape=6;}\n\n   \t\t }\n#endif\n    \n        //TOWER\n        if(length(voxelCoord.xy - buildCoord.xy - vec2(-2.,-3.))<2.  && voxelCoord.z <75.)  {vox.id=1.;vox.shape=0;}\n        if(length(voxelCoord.xy - buildCoord.xy - vec2(-2.,-3.))<1.  && voxelCoord.z <75.)  {vox.id=14.;vox.shape=0;}\n        if(WATER_LEVEL<35. ){\n            \n             //CAVE IF UNDER TERRAIN LEVEL\n            if(sdBox(voxelCoord-  buildCoord - vec3(0.,0.,-4.), vec3(10.,9.,4.)) <.5){ vox.id=1.;vox.shape=0;}\n       \t\t if(sdBox(voxelCoord-  buildCoord - vec3(0.,0.,-4.), vec3(8.,7.,2.)) <.5) vox.id=0.;\n            //HOUSE\n            float house=sdBox(voxelCoord- buildCoord - vec3(-0.5,5.,-4.5), vec3(2.5,3.,2.5));\n            if( abs(house) <.5 ) {vox.id=7.;vox.shape=0; }\n\n            if(sdBox(voxelCoord- buildCoord- vec3(.5,1.,-7.), vec3(6.,8.,0.5)) <.5) {vox.id=9.;vox.shape=0;}\n            if(sdBox(voxelCoord- buildCoord- vec3(2.,4.,-5.), vec3(.1,.1,1.5)) <.5) vox.id=0.;\n            if(sdBox(voxelCoord- buildCoord- vec3(2.,6.,-5.), vec3(.1,.1,1.5)) <.5) {vox.id=14.;vox.shape=0;}\n\n            if(length(voxelCoord - buildCoord - vec3(3.,5.,-2.))<0.5)  {vox.id=6.; vox.shape=0; vox.light.t=15.;}\n            if(length(voxelCoord - buildCoord- vec3(3.,3.,-2.))<0.5)  {vox.id=6.; vox.shape=0; vox.light.t=15.;}\n            if(length(voxelCoord - buildCoord- vec3(-2.,7.,-4.))<0.5)  {vox.id=6.; vox.shape=0; vox.light.t=15.;}\n\n\n            //WATER SOURCE\n            if(length(voxelCoord - buildCoord- vec3(+22.,4.,-8.))<0.5)  {vox.id=15.; vox.shape=0; }\n\n            //POOL\n            //if(sdBox(voxelCoord-  buildCoord - vec3(7.,10.,-9.), vec3(2.,2.,2.)) <.5) vox.id=12.;\n            if(sdBox(voxelCoord- buildCoord- vec3(8.,1.,-9.), vec3(3.,3.,1.5)) <.5) {vox.id=9.;vox.shape=0;}\n            if(sdBox(voxelCoord- buildCoord- vec3(8.,1.,-8.), vec3(2.,2.,1.5)) <.5) {vox.id=12.; vox.life=255.;vox.value=1;vox.shape=0;}\n\n       \n        }\n \n        //ELEVATOR PLATFORMS (3 LEVELS)\n        if(type>.2){\n            if(sdBox(voxelCoord-buildCoord- vec3(-1.5,-3.,23.), vec3(4.,5.,0.5)) <.5) {vox.id=9.;vox.shape=0;}\n            if(abs(sdBox(voxelCoord-buildCoord- vec3(-1.5,-3.,24.), vec3(4.,5.,0.5))) <.5) {vox.id=9.; vox.shape=4; vox.rotation=1.;}\n            if(abs(sdBox(voxelCoord-buildCoord- vec3(-1.5,-3.5,24.), vec3(3.5,5.,0.5))) <.5) {vox.id=9.; vox.shape=4;}\n\n\n            if(sdBox(voxelCoord- buildCoord-vec3(-1.5,-3.,-26.), vec3(4.,4.,0.5)) <.5) {vox.id=9.; vox.shape=0;}\n\n            if(length(voxelCoord.xy - buildCoord.xy - vec2(-2.,-5.))<2. && abs(voxelCoord.z -buildCoord.z -1.)<27. && voxelCoord.z>WATER_LEVEL)  {vox.id=0.;}\n            if(length(voxelCoord.xy - buildCoord.xy - vec2(-2.,-1.))<2. && abs(voxelCoord.z- buildCoord.z -1.)<27. && voxelCoord.z>WATER_LEVEL)  {vox.id=0.;}\n\n\n            // LIGHTs\n            //if(length(voxelCoord - buildCoord  - vec3(-2.,-3.,30.))<2.5)  {vox.id=6.;  vox.light.t=15.;}\n            if(length(voxelCoord - buildCoord - vec3(-2.,-3.,-26.))<2.5)  {vox.id=6.;  vox.light.t=15.;vox.shape=0;}\n        }\n    }\n\n\n    // ELEVATOR- UP\n    if(length(voxelCoord.xy - buildCoord.xy - vec2(-2.,-5.))<2. && abs(voxelCoord.z -buildCoord.z +26.-abs(mod((iTime-1.),100.)-50.) )<.5 )  {vox.id=0.;}\n    if(length(voxelCoord.xy - buildCoord.xy - vec2(-2.,-5.))<2. && abs(voxelCoord.z -buildCoord.z +26.-abs(mod((iTime),100.)-50.) )<.5 )  {vox.id=9.;vox.shape=0;}\n\n\n    //ELEVATOR DOWN\n    if(length(voxelCoord.xy - buildCoord.xy - vec2(-2.,-1.))<2. && abs(voxelCoord.z -buildCoord.z -24.+abs(mod((iTime-1.),100.)-50.) )<.5 )  {vox.id=0.;}\n    if(length(voxelCoord.xy - buildCoord.xy - vec2(-2.,-1.))<2. && abs(voxelCoord.z -buildCoord.z -24. +abs(mod((iTime),100.)-50.) )<.5 )  {vox.id=9.;vox.shape=0;}\n\n\n}\n\n", "buffer_a_code": "#define KEY_FORWARDS 87\n#define KEY_BACKWARDS 83\n#define KEY_LEFT 65\n#define KEY_RIGHT 68\n#define KEY_JUMP 32\n#define KEY_SNEAK 16\n#define KEY_PLACE 81\n#define KEY_DESTROY 69\n#define KEY_SHAPE 82\n#define KEY_ROTATE_Z 70\n#define KEY_ROTATE_Y 71\n#define KEY_MULTISELECT 67\n#define KEY_DECREASE_ZOOM 33\n#define KEY_INCREASE_ZOOM 34\n#define KEY_DECREASE_PIXELSIZE 75\n#define KEY_INCREASE_PIXELSIZE 76\n#define KEY_INCREASE_TIME_SCALE 80\n#define KEY_DECREASE_TIME_SCALE 79\n#define KEY_STATS 114\n#define KEY_DUMP1 115\n#define KEY_DUMP2 116\n#define KEY_TORCH 118\n#define KEY_FLOW 119\n#define KEY_TELEPORT 84\n#define KEY_INCREASE_PERFORMANCE 117\n#define KEY_WORLD 89\n#define KEY_MAP 77\n#define KEY_INVENTORY 73\n\n\n//ACTIONS \n\n\n\nbool inBox(vec2 coord, vec4 bounds) {\n    return coord.x >= bounds.x && coord.y >= bounds.y && coord.x < (bounds.x + bounds.z) && coord.y < (bounds.y + bounds.w);\n}\nvec2 currentCoord;\nvec4 outValue;\nbool store4(vec2 coord, vec4 value) {\n    if (inBox(currentCoord, vec4(coord, 1., 1.))) {\n        outValue = value;\n        return true;\n    }\n    else return false;\n}\nbool store3(vec2 coord, vec3 value) { return store4(coord, vec4(value, 1)); }\nbool store2(vec2 coord, vec2 value) { return store4(coord, vec4(value, 0, 1)); }\nbool store1(vec2 coord, float value) { return store4(coord, vec4(value, 0, 0, 1)); }\n\nfloat keyDown(int keyCode) {\n    return texture(iChannel2, vec2((float(keyCode) + 0.5) / 256., .5/3.), 0.0).r;   \n}\n\nfloat keyPress(int keyCode) {\n    return texture(iChannel2, vec2((float(keyCode) + 0.5) / 256., 1.5/3.), 0.0).r;   \n}\n\nfloat keySinglePress(int keycode) {\n    bool now = bool(keyDown(keycode));\n    bool previous = bool(texture(iChannel0, vec2(256. + float(keycode) + 0.5, 0.5) / iResolution.xy, 0.0).r);\n    return float(now && !previous);\n}\n\n\nfloat keyToggled(int keyCode) {\n    return texture(iChannel2, vec2((float(keyCode) + 0.5) / 256., 2.5/3.), 0.0).r;   \n}\n\nfloat rectangleCollide(vec2 p1, vec2 p2, vec2 s) {\n    return float(all(lessThan(abs(p1 - p2), s)));   \n}\n\nfloat horizontalPlayerCollide(vec2 p1, vec2 p2, float h) {\n    vec2 s = (vec2(1) + vec2(.6, h)) / 2.;\n    p2.y += h / 2.;\n    return rectangleCollide(p1, p2, s);\n}\n\n\n/*\nvoxel getCachedVoxel(vec3 p) {\n    return getCachedVoxel(p,iChannel1,iChannelResolution[1],BUFFER_B);\n}*/\n\nfloat isSolidVoxel(bool slope,vec3 p) {\n    voxel t;\n    getCVoxel(p,t,0);\n    return isSolidVoxel(t) * (!slope || t.shape!=6?1.:0.);\n}\n\nstruct rayCastResults {\n    bool hit;\n    vec3 mapPos;\n    vec3 normal;\n};\n\nrayCastResults  getMouseRay(){\n       \n   vec4 mouseRay=  texture(iChannel3, vec2(0.));\n   rayCastResults res;\n   res.hit = mouseRay.a!=0.;\n   res.mapPos = mouseRay.rgb;\n    \n   float eN = mouseRay.a -1.;\n   res.normal=vec3(mod(eN,3.),floor(mod(eN,9.)/3.),floor(eN/9.))- vec3(1.);  \n   return res;\n}\n\nfloat mouseSelect(vec2 c,float h) {\n\tfloat scale = floor(iResolution.y / 128.);\n    c /= scale;\n    vec2 r = iResolution.xy / scale;\n    float xStart = (r.x - 16. * NUM_ITEMS) / 2.;\n    c.x -= xStart;\n    if (c.x <NUM_ITEMS * 16. && c.x >= 0. && c.y < 16.*h) {\n        float slot = floor(c.x / 16.) + NUM_ITEMS*floor(c.y / 16.);\n    \treturn slot;\n    }\n\n    return -1.;\n}\n\nbool mouseDoubleClick(){\n    \n    if(iMouse.z <1. ) {\n   \n        int changeCount=0;\n        for(int i=0;i<20;i++){\n\n            int mouseChange=          \n               (load(_old *vec2(i) + _mouse ).z>0.?0:1)\n              +(load( _old * vec2(i+1) +_mouse ).z>0.?0:1);\n\n\n            if(mouseChange==1)changeCount++;\n            if(load(_mouseBusy).r>0.) {store1(_mouseBusy,float(1.));return false;}\n                               \n            if(changeCount>2){\n                //if(load(_time).r - load(_old*vec2(i) +_time).r<1.) return false;\n                if(length(load(_mouse).xy -load(_old * vec2(i+1) +_mouse).xy)>.05) return false;\n                store1(_mouseBusy,float(1.));\n                return true;\n\n            }         \n        }\n    }\n    store1(_mouseBusy,float(0.));\n    return false; \n}\n\n\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n//From https://www.shadertoy.com/view/4djGRh\nfloat tileableWorley(in vec2 p, in float numCells)\n{\n\tp *= numCells;\n\tfloat d = 1.0e10;\n\tfor (int xo = -1; xo <= 1; xo++)\n\t{\n\t\tfor (int yo = -1; yo <= 1; yo++)\n\t\t{\n\t\t\tvec2 tp = floor(p) + vec2(xo, yo);\n\t\t\ttp = p - tp - hash22(256. * mod(tp, numCells));\n\t\t\td = min(d, dot(tp, tp));\n\t\t}\n\t}\n\treturn sqrt(d);\n\t//return 1.0 - d;// ...Bubbles.\n}\n\nfloat crackingAnimation(vec2 p, float t) {\n    t = ceil(t * 8.) / 8.;\n\tfloat d = 1.0e10;\n    //t *= ;\n    for (float i = 0.; i < 25.; i++) {\n    \tvec2 tp = hash22(p )-.5; //texture(iChannel1, vec2(4, i) / 256.).xy - 0.5;\n        tp *= max(0., (length(tp) + clamp(t, 0., 1.) - 1.) / length(tp));\n        d = min(d, length(tp + 0.5 - p));\n    }\n    return pow(mix(clamp(1. - d * 3., 0., 1.), 1., smoothstep(t - 0.3, t + 0.3, max(abs(p.x - 0.5), abs(p.y - 0.5)) * 2.)), .6) * 1.8 - 0.8;\n}\n\nfloat brickPattern(vec2 c) {\n\tfloat o = 1.;\n    if (mod(c.y, 4.) < 1.) o = 0.;\n    if (mod(c.x - 4. * step(4., mod(c.y, 8.)), 8.) > 7.) o = 0.;\n    return o;\n}\nfloat woodPattern(vec2 c) {\n\tfloat o = 1.;\n    if (mod(c.y, 4.) < 1.) o = 0.;\n    if (mod(c.x + 2. - 6. * step(4., mod(c.y, 8.)), 16.) > 15.) o = 0.;\n    return o;\n}\n\n\n\n\n//textures from https://www.shadertoy.com/view/4ds3WS by Reinder\nvoid setTexture( out vec4 o, in vec2 fragCoord )\n{\n    \n \tif(fragCoord.x>8.*16. || fragCoord.y >10.*16.) discard;\n    vec2 gridPos = floor((fragCoord -vec2(0.,32.))/ 16.) ;\n    vec2 c = mod(fragCoord, 16.);\n    int id = int(gridPos.x + gridPos.y * 8.);\n \n   \n    vec2 uv = floor( c );\t\n    float h = hash12(uv +vec2(float(id)));\n    float br = 1. - h * (96./255.);\t\t\n\tfloat xm1 = mod((uv.x * uv.x * 3. + uv.x * 81.) / 4., 4.);\n\n    if (iFrame > 10 && iChannelResolution[0].x > 0. && id!=32  ) discard;\n    o.a = 1.;\n    if (id == 0) { //NO TEXTURE\n    \to = vec4(1,0,1,1);\n    }\n    if (id == 1) { //STONE\n       \n        o.rgb =  vec3( 127./255., 127./255., 127./255.) *br;        \n    }\n    if (id == 2) { //DIRT\n        \n        o.rgb =  vec3( 150./255., 108./255.,  74./255.) *br;\n    }\n    if (id == 3) { //GRASS LATERAL\n        \n        o.rgb =  vec3( 150./255., 108./255.,  74./255.) *br;\n        if (c.y  + hash( c.x*2.) *3.  > 14. ) \n         o.rgb =  vec3( 96./255., 157./255.,  59./255.)*br;\n    }\n    if (id == 4) { //GRASS UP\n   \t\t\n        o.rgb = vec3( 96./255., 157./255.,  59./255.)*br;\n    }\n    if (id == 5) { //ROCK\n       \n        o.rgb = vec3( 106./255., 170./255.,  64./255.)*br;\n        o.rgb = vec3(clamp(pow(1. - tileableWorley(c / 16., 4.), 2.), 0.2, 0.6) + 0.2 * tileableWorley(c / 16., 5.));\n \n    }\n    if (id == 6 || id == 26) {//LIGHT OR FIREFLY\n        float w = 1. - tileableWorley(c / 16., 4.);\n        float l = clamp(0.7 * pow(w, 4.) + 0.5 * w, 0., 1.);\n        o.rgb = mix(vec3(.3, .1, .05), vec3(1,1,.6), l);\n        if (w < 0.2) o.rgb = vec3(0.3, 0.25, 0.05);\n    }\n    if (id == 7) { //BRICK\n        o.rgb = vec3( 181./255.,  58./255.,  21./255.)*br; \n\t\tif ( mod(uv.x + (floor(uv.y / 4.) * 5.), 8.) == 0. || mod( uv.y, 4.) == 0.) {\n\t\t\to.rgb = vec3( 188./255., 175./255., 165./255.); \n\t\t}\n        \n    \t//o.rgb = -0.1 * hash12(c) + mix(vec3(.6,.3,.2) + 0.1 * (1. - brickPattern(c + vec2(-1,1)) * brickPattern(c)), vec3(0.8), 1. - brickPattern(c));\n    }\n    if (id == 8) {//GOLD\n    \to.rgb = mix(vec3(1,1,.2), vec3(1,.8,.1), sin((c.x - c.y) / 3.) * .5 + .5);\n        if (any(greaterThan(abs(c - 8.), vec2(7)))) o.rgb = vec3(1,.8,.1);\n    }\n    if (id == 9) { //WOOD\n        \n         o.rgb= vec3(0.5,0.4,0.25)*(0.5 + 0.5 * woodPattern(c))*br;        \n    }    \n    if (id == 10) {//TREE\n\t\t\n        if ( h < 0.5 ) {\n\t\t\tbr = br * (1.5 - mod(uv.x, 2.));\n\t\t}\n        o.rgb = vec3( 103./255., 82./255.,  49./255.)*br; \t\t\t\t\n\t}\t\n    if (id == 11) {//LEAF\n\t        o.rgb=  vec3(  40./255., 117./255.,  38./255.)*br;\t\t\n\t}\n    if (id == 12) {//WATER\t\t\n        o.rgb=vec3(  64./255.,  64./255., 255./255.)*br;\t\t\n\t}\t\n    if (id == 13) {//SAND\n\t\t//getMaterialColor(10,c,o.rgb);\n\t\to.rgb= vec3(0.74,0.78,0.65);\n\t}\t\n    if (id == 14) {//RED APPLE\t- MIRROR\t\n\t\to.rgb= vec3(.95,0.,0.05);\n       \n\t}\n    if (id == 15) {//PINK MARBLE\t\n        o.rgb= vec3(.95,0.5,.5)*br;\n    \t//o.rgb = mix(vec3(.2,1,1), vec3(1,.8,.1), sin((c.x - c.y) / 3.) * .5 + .5);\n       // if (any(greaterThan(abs(c - 8.), vec2(7)))) o.rgb = vec3(.1,.8,1);\n       \n\t}\n    if (id == 16) { //BEDROcK\n        \n    \n        o.rgb =   .2*vec3( 127./255., 127./255., 127./255.) *br;   \n    }\n    if (id == 17) {//DIAMOND\t\n       \n    \to.rgb = mix(vec3(.2,1,1), vec3(.1,.8,1), sin((c.x - c.y) / 3.) * .5 + .5);\n       if (any(greaterThan(abs(c - 8.), vec2(7)))) o.rgb = vec3(.1,.8,1);\n       \n\t}\n /*   \n    \n    if (id == 18) {//\t\n        o.rgb= vec3(0.04, 0.14, 0.42)*br;\n       \n\t}\n    if (id == 19) {//\t\n        o.rgb=  vec3(0.05, 0.50, 0.95)*br;\n       \n\t}\n    if (id == 20) {//\t\n        o.rgb= vec3(0.36, 0.72, 0.68)*br;\n       \n\t}\n    if (id == 21) {//\t\n        o.rgb= vec3(0.48, 0.46, 0.28)*br;\n       \n\t}\n    if (id == 22) {//\t\n        o.rgb= vec3(0.69, 0.58, 0.27)*br;\n       \n\t}\n    if (id == 23) {//\t\n        o.rgb= vec3(0.42, 0.51, 0.20)*br;\n       \n\t}    \n    if (id == 24) {//\t\n        o.rgb= vec3(0.23, 0.53, 0.16)*br;\n       \n\t}\n    if (id == 25) {//\t\n        o.rgb= vec3(0.06, 0.20, 0.07)*br;\n       \n\t}\n    if (id == 26) {//\t\n        o.rgb= vec3(0.32, 0.33, 0.27)*br;\n       \n\t}\n    if (id == 27) {//\t\n        o.rgb= vec3(0.25, 0.37, 0.41)*br;\n       \n\t}\n    if (id == 28) {//\t\n        o.rgb= vec3(0.44, 0.67, 0.74)*br;\n       \n\t}  \n    if (id == 29) {//\t\n        o.rgb= vec3(0.73, 0.86, 0.91)*br;\n       \n\t}  \n*/  \n\n    if (id == 32) { //DESTROYING BLOCK ANIMATION\n    \to.rgb = vec3(crackingAnimation(c / 16., load(_pickTimer).r));\n    }\n    if (id == 48) { \n    \to = vec4(vec3(0.2), 0.7);\n        vec2 p = c - 8.;\n        float d = max(abs(p.x), abs(p.y));\n        if (d > 6.) {\n            o.rgb = vec3(0.7);\n            o.rgb += 0.05 * hash12(c);\n            o.a = 1.;\n            if ((d < 7. && p.x < 6.)|| (p.x > 7. && abs(p.y) < 7.)) o.rgb -= 0.3;\n        }\n        o.rgb += 0.05 * hash12(c);\n        \n    }\n    \n}\n\n/*--------------------\n\nx=0 && y<256: global variables\nx=0 &&  256<=y<512: keyboard state for each ascii code with millisecs since laste change\n1<=x<16 y<512: previous values fo variables and keys\nx<= 128 && 16<=y< 140 : textures \n\n\n*///-------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    currentCoord = fragCoord;\n    if(fragCoord.x>512. || fragCoord.y >160.) discard;\n    vec2 texCoord = floor(fragCoord);\n    if (texCoord.x < 512. && texCoord.y<30.) {\n        if (texCoord.y == varRow) {\n            if (texCoord.x >= 256.) {\n                fragColor.r = texture(iChannel2, (fragCoord - 256.) / vec2(256,3)).r;\n                vec4 old = texture(iChannel0, (_old + fragCoord) / iChannelResolution[0].xy);\n                if (fragColor.r != old.r) old.a = 0.;\n                fragColor.a = old.a + iTimeDelta;\n            }\n            else {\n                vec3 pos = load(_pos).xyz;\n                vec3 oldPos = pos;\n                vec3 offset = vec3(floor(pos.xy), 0.);\n                vec2 angle = load(_angle).xy;\n                vec4 oldMouse = load(_mouse);\n                vec3 vel = load(_vel).xyz;\n                vec4 mouse = iMouse / length(iResolution.xy);\n                float renderScale = load(_renderScale).r;\n                vec2 time = load(_time).rg;\n                vec2 flightMode = load(_flightMode).rg;\n                vec2 sprintMode = load(_sprintMode).rg;\n                float selected = load(_selectedInventory).r;\n                float dt = min(iTimeDelta, .05);\n                float rayDistMax = max(load(_rayDistMax).r,50.);\n\t\t\t\t\n                float pixelSize =load(_pixelSize).r;\n                float inventory =load(_inventory).r;\n                float demo =load(_demo).r;\n\t\t\t\tfloat map=load(_map).r;;\n\n                    \n                if (iFrame <2  ) {\n#ifdef FAST_NOISE  \n                    pos = vec3(2952.8,10140.8,89.);\n                    offset = vec3(floor(pos.xy), 0.);\n                    oldPos = pos;\n                    angle = vec2(-0.6,1.8  );                   \n#else\n                    pos = vec3(3265.5,9654.5,50.);                   \n                    angle = vec2(-2.,1.6  );\n#endif                    \n                    demo=1.;\n                    oldMouse = vec4(-1);\n                    vel = vec3(0);\n                    renderScale = -2.;\n                    time = vec2(0.,4);\n                    selected = 0.;\n                    inventory=0.;\n                    rayDistMax=250.;\n                    map=1.;\n                    pixelSize=2.;\n                }\n                if(demo>0. && \n                   (keyDown(KEY_JUMP)>.0||keyDown(KEY_FORWARDS)>0. || iMouse.z>0. ))\n                {\n                    inventory=1.;\n                    map=1.;\n                    demo=0.;\n                }\n                \n                if ( bool(keyDown(KEY_TELEPORT))) {\n\t\t\t\t\t\n                    if(hash(iTime) <.5) pos=vec3(3221.5,10159.5,70.);\n                    else pos =vec3(hash33(pos).xy *10000.,72.); \n                       \n                    offset = vec3(floor(pos.xy), 0.);\n                    oldPos = pos;\n                    time.r=hash13(pos)*1200.;\n                    oldMouse = vec4(-1);\n                    vel = vec3(0);\n                    renderScale = -2.;                  \n                    selected = 0.;\n                    rayDistMax=250.;\n                }\n                if (oldMouse.z > 0. && iMouse.z > 0. && map<1.5)\n                    if(1==1){\n                        float zoom = pow(10., load(_renderScale).r/10.);\n                        angle += 5.*(mouse.xy - oldMouse.xy) * vec2(-1,-1)/zoom;\n                        angle.y = clamp(angle.y, 0.1, PI - 0.1);\n                    }\n                vec3 dir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y));\n                vec3 dirU = vec3(normalize(vec2(dir.y, -dir.x)), 0);\n                vec3 dirV = cross(dirU, dir);\n                vec3 move = vec3(0);\n\n                \n                vec3 dirFwd = vec3(cos(angle.x), sin(angle.x), 0);;\n                    vec3 dirRight = vec3(dirFwd.y, -dirFwd.x, 0);\n                vec3 dirUp = vec3(0,0,1);\n                \n                float inBlock = 0.;      \n                vec3  vColPos, hColPos;\n                \n                //z of closest  blocks below\n                float minHeight = 0.; \n                \n                //z of closest  blocks above\n                float maxHeight = 1000.;\n                \n                //XY of closest lateral blocks\n                float minX = pos.x - 1000.; \n                float maxX = pos.x + 1000.;\n                float minY = pos.y - 1000.;\n                float maxY = pos.y + 1000.;\n#ifndef XRAY_MODE\n                if(isSolidVoxel(false,pos-offset) >.5)  pos.z+=clamp(3./iTimeDelta,.3,1.);\n                \n                //DOWN\n                for (float i = 0.; i < 4.; i++) {\n                    vColPos = vec3(floor(pos.xy - 0.5), floor(pos.z - 1. - i));\n                    float solid=0.;\n                    for(int j=0;j<4;j++){\n                        solid+=\n                          isSolidVoxel(false,vColPos - offset + vec3(j/2,j%2,min(iFrame,0))) * rectangleCollide(vColPos.xy + vec2(0.5 +float(j/2),0.5+float(j%2)), pos.xy, vec2(.8));\n                    }\n                    if ( solid> .5) {\n                        minHeight = vColPos.z + 1.001; \n                        inBlock = 1.;\n                        break;\n                    }\n                }\n\t\t\t\t\n                //UP\n                vColPos = vec3(floor(pos.xy - 0.5), floor(pos.z + 1.8 + 1.));\n                float solidUp=0.;\n                for(int j=0;j<4;j++){\n                 \tsolidUp+= isSolidVoxel(false,vColPos - offset + vec3(j/2,j%2,min(iFrame,0))) * rectangleCollide(vColPos.xy + vec2(0.5 +float(j/2),0.5+float(j%2)), pos.xy, vec2(.8));\n                }\n\t\t\t\tif(  solidUp > .5) {\n                    maxHeight = vColPos.z - 1.8 - .001; \n                    inBlock = 1.;     \n\n                }\n               \n                //LATERAL\n                float solidL[4];\n                for(int i=0;i<4;i++){\n                    vec2 posL;\n                    vec2 hColPosL;\n                    if(i==0) {hColPos = vec3(floor(pos.xy - vec2(.3, .5)) + vec2(-1,0), floor(pos.z)); hColPosL=hColPos.yz;posL=pos.yz;}\n                    if(i==1) {hColPos = vec3(floor(pos.xy - vec2(-.3, .5)) + vec2(1,0), floor(pos.z));hColPosL=hColPos.yz;posL=pos.yz;}\n                    if(i==2) {hColPos = vec3(floor(pos.xy - vec2(.5, .3)) + vec2(0,-1), floor(pos.z));hColPosL=hColPos.xz;posL=pos.xz;}\n                    if(i==3) {hColPos = vec3(floor(pos.xy - vec2(.5, -.3)) + vec2(0,1), floor(pos.z));hColPosL=hColPos.xz;posL=pos.xz;}\n                    solidL[i]=0.;\n                    for(int j=0;j<6;j++){\n                        \n       \n                        solidL[i ] += isSolidVoxel(true,hColPos - offset + vec3((i/2)*(j%2),(1-i/2)*(j%2),(j/2)+min(iFrame,0))) \n                            * horizontalPlayerCollide(hColPosL + vec2(0.5+float(j%2), 0.5+float(j/2)), posL, 1.8);\n                    }\n                \n                    if(i==0 && solidL[i]>.5) minX = hColPos.x + 1.301;\n                    if(i==1 && solidL[i]>.5) maxX = hColPos.x - .301;\n                    if(i==2 && solidL[i]>.5) minY = hColPos.y + 1.301;\n                    if(i==3 && solidL[i]>.5) maxY = hColPos.y - .301;\n                }\n                \n\n                \n                if (abs(pos.z - minHeight) < 0.01) flightMode.r = 0.; \n#else\n                flightMode.rg=vec2(.3,1.);\n                if(iFrame==0) pos.z=65.;\n#endif\n                \n                if (bool(keySinglePress(KEY_JUMP))) {\n                    if (flightMode.g > 0.) {\n                        flightMode.r = 1.- flightMode.r;\n                        sprintMode.r = 0.;\n                    }\n                    flightMode.g = 0.3;\n                }\n                flightMode.g = max(flightMode.g - dt, 0.);\n\n                if (bool(keySinglePress(KEY_FORWARDS))) {\n                    if (sprintMode.g > 0.) sprintMode.r = 1.;\n                    sprintMode.g = 0.3;\n                }\n                if (!bool(keyDown(KEY_FORWARDS))) {\n                    if (sprintMode.g <= 0.) sprintMode.r = 0.;\n                }\n                sprintMode.g = max(sprintMode.g - dt, 0.);\n\n                vec3 stats =vec3(\n                    bool(keyToggled(KEY_STATS))?1.:0.,\n                    bool(keyToggled(KEY_DUMP1))?1.:0.,\n                    bool(keyToggled(KEY_DUMP2))?1.:0.\n                );\n                float torch = bool(keyToggled(KEY_TORCH))?1.:0.;\n                float flow = bool(keyToggled(KEY_FLOW))?1.:0.;\n                \n                map = mod( map +keyPress(KEY_MAP),3.);\n                inventory = floor(mod( inventory + keyPress(KEY_INVENTORY),3.));\n                if(inventory<2.) selected=clamp(selected,0., NUM_ITEMS-1.);\n\n                float loadDistLimit=80.;\n                float rayLimit=500.; \n                if(bool(keyToggled(KEY_INCREASE_PERFORMANCE))){        \n                    pixelSize=max(2.,pixelSize) ;\n                    loadDistLimit=50.;\n                    rayLimit=200.;\n                }\n                pixelSize=clamp( pixelSize  + keyPress(KEY_INCREASE_PIXELSIZE) - keyPress(KEY_DECREASE_PIXELSIZE)  ,1.,4.);\n\n\n                if (bool(flightMode.r)) {\n                    if (length(vel) > 0.) vel -= min(length(vel), 25. * dt) * normalize(vel);\n                    vel += 50. * dt * dirFwd * sign(keyDown(KEY_FORWARDS)-keyDown(KEY_BACKWARDS)+keyDown(38)-keyDown(40));\n                    vel += 50. * dt * dirRight * sign(keyDown(KEY_RIGHT)-keyDown(KEY_LEFT)+keyDown(39)-keyDown(37));\n                    vel += 50. * dt * dirUp * sign(keyDown(KEY_JUMP) - keyDown(KEY_SNEAK));\n                    if (length(vel) > 20.) vel = normalize(vel) * 20.;\n                }\n                else {\n                    vel.xy *= max(0., (length(vel.xy) - 25. * dt) / length(vel.xy));\n                    vel += 50. * dt * dirFwd * sign(keyDown(KEY_FORWARDS)-keyDown(KEY_BACKWARDS)+keyDown(38)-keyDown(40));\n                    vel += 50. * dt * dirFwd * 0.4 * sprintMode.r;\n                    vel += 50. * dt * dirRight * sign(keyDown(KEY_RIGHT)-keyDown(KEY_LEFT)+keyDown(39)-keyDown(37));\n                    if (abs(pos.z - minHeight) < 0.01) {\n                        vel.z = 9. * keyDown(32);\n                    }\n                    \n                    else {\n                        //voxel t;\n                        //getCVoxel(pos -offset,t,0);\n                        //bool isWater=(t.id ==12.);\n                        vel.z -= 32. * dt;\n                        vel.z = clamp(vel.z, -80., 30.);\n                    }\n\t\t\t\t\t\n                    if (length(vel.xy) > 4.317 * (1. + 0.4 * sprintMode.r)) vel.xy = normalize(vel.xy) * 4.317 * (1. + 0.4 * sprintMode.r);\n                }\n\n\n                pos += dt * vel; \n                if (pos.z < minHeight) {\n                    pos.z = minHeight;\n                    vel.z = 0.;\n                }\n                if (pos.z > maxHeight ) {\n                    pos.z = maxHeight;\n                    vel.z = 0.;\n                }\n                \n                if (pos.x < minX) {\n                    pos.x = minX;\n                    vel.x = 0.;\n                }\n                if (pos.x > maxX) {\n                    pos.x = maxX;\n                    vel.x = 0.;\n                }\n                if (pos.y < minY) {\n                    pos.y = minY;\n                    vel.y = 0.;\n                }\n                if (pos.y > maxY) {\n                    pos.y = maxY;\n                    vel.y = 0.;\n                }\n\n                float timer = load(_old+_pickTimer).r;\n                vec4 oldPick = load(_old+_pick);\n                vec4 pick;\n                float pickAction;\n                           \n                rayCastResults mousePointer = getMouseRay();\n            \n                bool dblClk =mouseDoubleClick();\n                if(dblClk){\n                    if (mousePointer.hit ) {\n                        \n                            pick.xyz = mousePointer.mapPos;\n                            pick.a = 7.;\n                  }                \n                }\n                \n                if (iMouse.z > 0. ) {                    \n                    \n                    float h= (inventory>1.?NUM_ITEM_ROWS:1.);\n                    float slot = mouseSelect(iMouse.xy,h);\n                    if(slot>= 0. && inventory>0. ){\n                        selected = slot;\n                    }\n                    else {\t\n                    \n                    if (mousePointer.hit ) {\n                        pick.xyz = mousePointer.mapPos;\n                        if (bool(keyDown(KEY_DESTROY))) {\n                            pick.a = 1.;\n                            store1(_pick,pick.a);\n                            timer += dt / 0.25;\n                        }\n                        else if (dblClk || bool(keySinglePress(KEY_PLACE))) {\n                            pick.a = 2.;\n                            pick.xyz += mousePointer.normal;                         \n                        }\n                        else if (bool(keySinglePress(KEY_SHAPE))) {\n                            pick.a = 3.;\n                        }\n                        else if (bool(keySinglePress(KEY_ROTATE_Z))) {\n                            pick.a = 4.;\n                         }\n                        else if (bool(keySinglePress(KEY_ROTATE_Y))) {\n                            pick.a = 5.;\n                        }\n                         else if (bool(keyDown(KEY_MULTISELECT))) {\n                            pick.a = 6.;\n                             store1(_pick,pick.a);\n                             timer += dt / 0.25;\n                        }\n                        if (oldPick != pick) timer = 0.;\n                    }\n                    else {\n                        //pick = vec4(-1,-1,-1,0);\n                        timer = 0.;\n                    }\n                }\n                }\n                else { \n                    \n                    // NO MOUSE KEY PRESSED  \n                    //pick = vec4(-1,-1,-1,0);\n\t\t\t\t\t\tif (bool(keyDown(KEY_DESTROY))) {\n                            pick.a = 1.;\n                            store1(_pick,pick.a);\n                            timer += dt / 0.25;\n                        }\n                        else if (bool(keySinglePress(KEY_PLACE))) {\n                            pick.a = 2.;\n                        }\n                        else if (bool(keySinglePress(KEY_SHAPE))) {\n                            pick.a = 3.;\n                         }\n                        else if (bool(keySinglePress(KEY_ROTATE_Z))) {\n                            pick.a = 4.;\n                        }\n                        else if (bool(keySinglePress(KEY_ROTATE_Y))) {\n                            pick.a = 5.;\n                        }\n                        else if (bool(keyDown(KEY_MULTISELECT))) {\n                            pick.a = 6.;\n                             store1(_pick,pick.a);\n                             timer += dt / 0.25;                   \n                        }else timer = 0.;\n                }\n\n\n                renderScale = clamp(renderScale + keySinglePress(KEY_DECREASE_ZOOM) - keySinglePress(KEY_INCREASE_ZOOM), -5., 10.);\n                time.g = clamp(time.g + keySinglePress(KEY_INCREASE_TIME_SCALE) - keyPress(KEY_DECREASE_TIME_SCALE), 0., 8.);\n                time.r = mod(time.r + dt * sign(time.g) * pow(2., time.g - 1.), 1200.);\n\n                bool still= length(pos-oldPos)<0.01 && length(angle -load(_angle).xy )<0.01  &&  iMouse.z<1.;\n                rayDistMax= rayLimit;/*clamp(rayDistMax  \n                                  +(still?10.:0.) \n                                  - ((iTimeDelta>0.03 && !still)?5.:0.)\n                                  -((iTimeDelta>0.1)?1.:0.) \n                                  -((iTimeDelta>0.1  && !still)?50.:0.) \n                                  + ((iTimeDelta<0.03 && still)?20.:0.)\n                                  ,loadDistLimit*2.5,rayLimit);*/\n\n\n                store3(_pos, pos);\n                store2(_angle, angle);\n                store4(_loadRange_B,calcLoadRange_B(pos.xy,iChannelResolution[1].xy,0.));\n#if SURFACE_CACHE>0\n                store4(_loadRange_C,calcLoadRange_C(pos.xy,iChannelResolution[1].xy,0.));\n#endif\n                store4(_mouse, mouse);\n                //store1(_inBlock, inBlock);\n                store3(_vel, vel);\n                store4(_pick, pick);\n                store1(_pickTimer, timer);\n                store1(_renderScale, renderScale);\n                store1(_selectedInventory, selected);\n                store2(_flightMode, flightMode);\n                store2(_sprintMode, sprintMode);\n                store2(_time, time);\n                store3(_stats, stats);\n                store1(_rayDistMax, rayDistMax);\n                store1(_loadDistLimit, loadDistLimit);\n                store1(_rayLimit, rayLimit);\n                store1(_map,map);\n                store1(_pixelSize,pixelSize);\n                store1(_inventory,inventory);\n                store1(_demo,demo);\n                store1(_torch,torch);\n                store1(_flow,flow);\n               \n\n\n                fragColor = outValue;\n            }\n        }  \n        else fragColor = texture(iChannel0, (fragCoord - _old) / iChannelResolution[0].xy);\n    }\n#ifdef MC    \n    else if (texCoord.x < 512. && texCoord.y<32.) {\n            if(iFrame>3) discard;\n            else if(texCoord.y<31.&& texCoord.x<256.)\n            {\n               int _edgeTable[256]= int[256](\n                -1   , 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c, 0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00, \n                0x190, 0x099, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c, 0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90, \n                0x230, 0x339, 0x033, 0x13a, 0x636, 0x73f, 0x435, 0x53c, 0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30, \n                0x3a0, 0x2a9, 0x1a3, 0x0aa, 0x7a6, 0x6af, 0x5a5, 0x4ac, 0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0, \n                0x460, 0x569, 0x663, 0x76a, 0x066, 0x16f, 0x265, 0x36c, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60, \n                0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0x0ff, 0x3f5, 0x2fc, 0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0, \n                0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x055, 0x15c, 0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950, \n                0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0x0cc, 0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0, \n                0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0x0cc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0, \n                0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c, 0x15c, 0x055, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650, \n                0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc, 0x2fc, 0x3f5, 0x0ff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0, \n                0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c, 0x36c, 0x265, 0x16f, 0x066, 0x76a, 0x663, 0x569, 0x460, \n                0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac, 0x4ac, 0x5a5, 0x6af, 0x7a6, 0x0aa, 0x1a3, 0x2a9, 0x3a0, \n                0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c, 0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x033, 0x339, 0x230, \n                0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c, 0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x099, 0x190, \n                0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c, 0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0\n               );\n               fragColor=vec4(_edgeTable[int(texCoord.x)]);\n           }\n           else if(texCoord.y<32.&& texCoord.x<256.){\n\n            int  _triTableCompact[1024] = int[1024](\n                65535,65535,65535,65535, 62336,65535,65535,65535, 63760,65535,65535,65535, 37761,65304,65535,65535, 64033,65535,65535,65535, \n                4992,65442,65535,65535, 2601,65426,65535,65535, 9090,39562,65528,65535, 62131,65535,65535,65535, 33456,65291,65535,65535, \n                8337,65459,65535,65535, 4785,35257,65531,65535, 45475,65338,65535,65535, 416 ,47272,65530,65535, 12435,43931,65529,65535, \n                43657,65464,65535,65535, 63604,65535,65535,65535, 28724,65347,65535,65535, 35088,65396,65535,65535, 18708,14103,65521,65535,\n                35361,65396,65535,65535, 14147,8512,65530,65535, 39465,18464,65527,65535, 10658,29305,18803,65535, 14152,65323,65535,65535,\n                46923,578 ,65524,65535, 33033,12916,65531,65535, 39796,47540,4754,65535, 12707,34731,65524,65535, 6833,436 ,19316,65535, 39028,\n                47536,12474,65535, 19316,47515,65530,65535, 62553,65535,65535,65535, 1113,65336,65535,65535, 5200,65285,65535,65535, 33880,4947,\n                65525,65535, 39457,65349,65535,65535, 6147,38050,65525,65535, 23077,1060,65522,65535, 13730,21330,33844,65535, 9305,65459,65535,\n                65535, 688 ,38072,65525,65535, 1104,12881,65531,65535, 9490,33413,22603,65535, 43834,22833,65524,65535, 1428,43032,43905,65535,\n                20549,46512,12474,65535, 22597,35496,65531,65535, 22649,65431,65535,65535, 36921,30005,65523,65535, 2160,20849,65527,65535, 13137,\n                65397,65535,65535, 39033,6773,65522,65535, 37402,13573,14160,65535, 33288,22610,9639,65535, 9634,21301,65527,65535, 30103,45976,\n                65522,65535, 38745,10535,46880,65535, 2866,29057,29976,65535, 45355,6001,65525,65535, 34905,6773,45987,65535, 20597,46992,40976,\n                61611, 45227,23088,28800,61557, 30123,65371,65535,65535, 62826,65535,65535,65535, 21376,65386,65535,65535, 20745,65386,65535,65535,\n                4993,42377,65526,65535, 9569,65302,65535,65535, 5473,866  ,65528,65535, 38249,8288,65526,65535, 22677,9512,33334,65535, 43826,65366,\n                65535,65535, 47115,27138,65525,65535, 10512,42419,65526,65535, 5797,47401,47250,65535, 27446,5429,65523,65535, 2944,20571,27473,65535,\n                1715,24675,38149,65535, 26966,39865,65528,65535, 18085,65415,65535,65535, 16436,22071,65530,65535, 20625,18538,65527,65535, 5482,\n                29049,18803,65535, 25110,29717,65528,65535, 21793,866 ,29748,65535, 38728,24656,25093,65535, 31031,9033,26969,63842, 29363,27208,\n                65525,65535, 18085,9255,46880,65535, 18704,12935,27227,65535, 37161,18731,19323,63141, 14152,21339,27473,65535, 23317,363 ,19323,\n                64320, 2384,12374,14006,63304, 26966,29881,39801,65535, 26954,65444,65535,65535, 18084,32937,65523,65535, 41226,17926,65520,65535,\n                33080,26721,41316,65535, 6465,25154,65524,65535, 6147,17042,17961,65535, 17440,65378,65535,65535, 33336,9282,65526,65535, 43338,\n                11078,65523,65535, 8832,38072,27210,65535, 691 ,24673,41316,65535, 24902,33953,45345,61880, 37993,6499,14003,65535, 33208,27393,\n                16785,61766, 14003,24582,65524,65535, 47174,65414,65535,65535, 30375,39080,65530,65535, 880,36986,42858,65535, 5994,29050,2072,\n                65535, 42858,28951,65523,65535, 5665,33158,30345,65535, 10594,30233,14601,63799, 28807,1632,65522,65535, 25143,65319,65535,65535,\n                43826,35462,30345,65535, 9986,37047,42855,63401, 4225,41351,42855,64306, 45355,27249,5985,65535, 34456,6518,14006,63025, 45456,\n                65398,65535,65535, 28807,45920,1712,65535, 63159,65535,65535,65535, 64359,65535,65535,65535, 47107,65383,65535,65535, 47376,65383,\n                65535,65535, 35096,31507,65526,65535, 25114,65403,65535,65535, 14881,46720,65527,65535, 8338,46746,65527,65535, 10166,35386,35235,\n                65535, 25383,65394,65535,65535, 30727,9734,65520,65535, 9842,4211,65529,65535, 4705,37224,26504,65535, 42618,12657,65527,65535, \n                5754,33191,32791,65535, 1840,41127,31337,65535, 31335,43146,65529,65535, 46214,65384,65535,65535, 15203,16480,65526,65535, 35688,\n                2404,65521,65535, 38473,14646,25521,65535, 25734,41611,65521,65535, 14881,24752,25611,65535, 18612,8374,39465,65535, 41882,18723,\n                25523,62308, 33576,25636,65522,65535, 16960,65318,65535,65535, 8337,16963,33606,65535, 5265,16932,65526,65535, 33560,18454,6758,\n                65535, 40986,1632,65524,65535, 17252,42627,37635,62362, 25754,65354,65535,65535, 30100,65462,65535,65535, 17280,31577,65526,65535,\n                20741,26372,65531,65535, 34427,21315,20788,65535, 42073,26401,65531,65535, 6070,32930,22851,65535, 23399,9380,8266,65535, 14403,\n                9029,9637,63099, 29479,17702,65529,65535, 1113,24680,30818,65535, 12899,20839,1104,65535, 26662,4728,22600,63569, 42073,29025,29462,\n                65535, 6753,359 ,1927,62553, 18948,12378,31338,64115, 31335,17802,43082,65535, 26006,35739,65529,65535, 2915,20534,22790,65535, \n                2224,4277,46677,65535, 25526,13651,65521,65535, 39457,47541,26040,65535, 944 ,37046,38486,64033, 46475,2149,9637,62752, 25526,\n                41555,13731,65535, 22917,25986,10290,65535, 38489,24582,65522,65535, 6225,25864,10296,63526, 9809,65377,65535,65535, 5681,33702,\n                38486,63128, 40986,22880,1616,65535, 22576,65446,65535,65535, 63066,65535,65535,65535, 31323,65461,65535,65535, 47707,14423,65520,\n                65535, 22453,37306,65520,65535, 42362,35195,4993,65535, 45595,22295,65521,65535, 4992,29042,45685,65535, 38265,2418,31522,65535, \n                29271,38322,33330,62089, 10834,29523,65525,65535, 32808,30757,21157,65535, 20745,13626,10807,65535, 37513,30738,21154,62039,\n                13617,65367,65535,65535, 1920,28951,65525,65535, 37641,13651,65527,65535, 22409,65401,65535,65535, 21637,47754,65528,65535, 21509,\n                42251,955 ,65535, 35088,43172,21675,65535, 42170,15188,5268,62483, 8530,45656,34120,65535, 2880,21563,6955,64277, 1312,45717,34117,\n                62859, 9545,65339,65535,65535, 14930,17189,18485,65535, 21157,9282,65520,65535, 12963,33701,34117,63760, 21157,37186,9362,65535, \n                34120,21301,65521,65535, 5440,65360,65535,65535, 34120,2357,21253,65535, 62793,65535,65535,65535, 18356,43449,65531,65535, 17280,\n                47481,47767,65535, 7073,16715,46192,65535, 13331,41348,46196,62650, 38836,10571,8603,65535, 38009,6523,6955,62336, 46203,16932,\n                65520,65535, 46203,14372,16948,65535, 10898,12951,38007,65535, 38825,10823,1927,63234, 14963,18218,2586,64004, 33441,65351,65535,\n                65535, 16788,6001,65523,65535, 16788,32881,6017,65535, 29444,65332,65535,65535, 63364,65535,65535,65535, 43177,65419,65535,65535,\n                14595,39865,65530,65535, 2576,43146,65531,65535, 47635,65443,65535,65535, 6945,47515,65528,65535, 14595,8633,39721,65535, 35616,\n                65456,65535,65535, 64291,65535,65535,65535, 10290,35496,65529,65535, 681 ,65321,65535,65535, 10290,4264,35352,65535, 62113,65535,\n                65535,65535, 38961,65409,65535,65535, 61840,65535,65535,65535, 63536,65535,65535,65535, 65535,65535,65535,65535\n            );\n\n             int id= int(texCoord.x)*4;\n             fragColor= vec4(_triTableCompact[id],_triTableCompact[id+1],_triTableCompact[id+2],_triTableCompact[id+3] );\n\n         }\n    }\n#endif    \n    else setTexture(fragColor,fragCoord);\n}\n\n\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void  lightDiffusion(inout voxel vox,in voxel temp ,vec3 rPos){\n    if(vox.id != 6. && vox.id != 26. ){\n \t   vox.light.s =  max( vox.light.s  ,  \ttemp.light.s  -(rPos.z==1.?0.:1.) - (vox.id==0.?0.: vox.id==11.?5.:15.));       \t\n \t   vox.light.t =  max( vox.light.t,   temp.light.t - (vox.id==0.|| vox.id==12.?1.:vox.id==11.? 5.:15.)); \n    \t\n    }        \n}\n\n//VOXEL MEMORY 1 - NEAR BLOCKS\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef EXCLUDE_CACHE\n    discard;\n#else\n   \n    vec2 textelCoord = floor(fragCoord);\n    vec3 offset = floor(vec3(load(_pos).xy, 0.));\n    vec3 voxelCoord = texToVoxCoord(textelCoord, offset,BUFFER_B); \n\n    vec4 newRange= calcLoadRange_B(offset.xy,iChannelResolution[1].xy,0.);\n    \n    if(!inRange(voxelCoord.xy, newRange)) {discard;}\n    \n    vec4 pick = load(_pick);   \n\n    voxel vox ; \n    getVoxel( voxelCoord,vox,1);\n\n    if (voxelCoord == pick.xyz || vox.value==2 )  {\n        if(vox.value==0)vox.value=1;\n        \n        if (pick.a == 1. &&  vox.id != 16. && load(_pickTimer).r > 1.) \n        {vox.value=1; \n                vox.id = 0.; \n                vox.shape=0;  \n         \t\tvox.light.t=0.;\n         \t\tvox.life=0.;\n         \t\tvox.ground=0.;\n        }\n        else if (pick.a == 2.) \n        {\n            vox.id = getInventory(load(_selectedInventory).r);\n            if(vox.id==10.) vox.life=3.;\n            else if (vox.id==12.)vox.life=64.;\n            else vox.life=0.;               \n            vox.value=1;\n            vox.shape=0;\n        } \n        else if (pick.a == 3. && vox.id != 10. && vox.id != 11. && vox.id != 12.) \n          { if(vox.shape<7) vox.shape++; else vox.shape=0;}\n        else  if (pick.a == 4. && vox.id != 10. && vox.id != 11. && vox.id != 12.) \n          {if(vox.rotation<3.) vox.rotation++; else vox.rotation=0.;}\n        else if (pick.a == 5. && vox.id != 10. && vox.id != 11. && vox.id != 12.) \n          { if(vox.rotation<12.) vox.rotation+=4.; else vox.rotation= mod(vox.rotation , 4.);}     \n    } \n        \n     if(voxelCoord == pick.xyz  &&  pick.a == 6. ) \n     {vox.value= 2 ;}\n    \n    if(voxelCoord == pick.xyz  &&  pick.a == 7. ) \n     {\n        if(vox.value==2) vox.value=1;\n         else vox.value=2;          \n     }\n    if(load(_pickTimer).r >1. && pick.a == 6. && vox.value==2)\n     {vox.value= 1 ;}\n\n   \t// SUN LIGHT SOURCES\n   \n    if (voxelCoord.z >= heightLimit_B - 2.) {\n        vox.light.s = 15.;   \n    } else  {\n        //vox.light.s=0.; //correct but initial value is better oon surface\n        vox.light.s = lightDefault(voxelCoord.z);       \n    }\n    \n    // TORCH LIGHT SOURCES\n    if(vox.id==12.) vox.light.t=max(2.,vox.light.t);\n    else if(vox.id==6.) vox.light.t=15.;\n    else vox.light.t=clamp(vox.light.t- (hash(iTime)>.5?1.:0.),0.,15.);\n     \n    if(length( load(_pos).xyz + vec3(0,0,3.)- voxelCoord.xyz) <2.) vox.light.t=max( 12.,vox.light.t);\n  \n        \n        \n    voxel temp;\n    float air=0.;\n    //int border=0;    \n    \n    //NEIGHBOURS 2=ABOVE 5=BELOW, 0-1-3-4= SIDES\n    float iE=0.;\n      \n    float g=MAX_GROUND;\n    //vox.surface=0.;\n    voxel next[9];\n    for(int j=0;j<=2;j++){\n        for(int i=0;i<3;i++){\n            vec3 n= vec3(i==0?1.:0. ,i==1?1.:0.,i==2?1.:0.) * vec3((j==0?1.:-1.));\n#ifdef WATER_FLOW            \n            // lateral voxels, random direction\n            if(j==2) {\n                int k= int(hash(iTime)*4.);// iFrame%4;\n            \tn = vec3(   (1- k/2) * (-1 +(k%2)*2), (k/2)* (-1 +(k%2)*2)  ,1-i);;\n            }\n#endif            \n            voxel temp;\n            getVoxel(voxelCoord + n ,temp,1 );           \n    \t\tnext[i+3*j]= temp;\n            \n            if(vox.id==0. && temp.id!=0.) vox.surface=1.;\n            if(vox.id!=0. && temp.id==0. ) vox.surface=1.;\n            \n            if(j!=2){\n                if(voxelCoord.z> 80.) {vox.light.s=15.;vox.light.t=0.;}\n                else  lightDiffusion(vox,temp,n);\n\n                //ELECTRICITY DIFFUSION\n                if(vox.id==17.){\n                    if(temp.id==8.) iE=10.;\n                    if(temp.id==17. && temp.life>1.) iE=max(iE,temp.life-1.);\n                }\n                //GROUND DISTANCE\n                if(vox.id!=0. && vox.id!=12. &&vox.id!=26.){\n                    if(voxelCoord.z <=1.) g=1.;\n                    if(temp.id!=0. && temp.id!=12. &&vox.id!=26. && temp.ground>0. )  g=min(g, temp.ground+(i+3*j==5?0.:vox.id==13.?10.:1.)); \n                }\n\n               if(temp.id==0.) air += pow(2., float(j*3+i));\n\n                //LEAFS:\n               if(temp.id==11.  && temp.life>0. &&vox.id==0.) {vox.id=11.;  vox.life=temp.life-1.; }  \n            }\n        }\n    }\n      \n    vec3 pos = load(_pos).xyz;\n    \n    //ELECTRICITIY\n    if(vox.id==17.){\n        vox.life=max(iE,vox.life-1.);\n        //if(iE>0.) vox.light.t=15.; else vox.light.t=0.;\n    }\n    \n    //GROUND CONNECTION: blocks not connected to the ground or sand with 4+ horizontal steps\n    if(vox.id!=0. && vox.id!=12. &&vox.id!=26.){\n        vox.ground=clamp(min(vox.ground+2.,g),0.,MAX_GROUND);\n                \n        //FALLING BLOCK\n#ifdef FALLING_SAND\n        if(vox.ground>=MAX_GROUND \n           && length(pos.xy-voxelCoord.xy)<load(_loadDistLimit).r -5.\n           &&  (next[5].id==0.|| next[5].id==12.)) vox.value=3;\n#endif        \n    }\n           \n\tif(sdBox(pos-voxelCoord -vec3(0.,0.,1.),vec3(.5,.5,.5))<=.01 &&vox.id==3.) vox.id=2.;\n       \n    //ABOVE    \n    if(next[2].id==0.  &&  vox.id==2.) {if(hash13(voxelCoord +iTime ) >.95 && hash(iTime)>.99) vox.id=3.;vox.life=0.;}\n    if(next[2].id==0.  &&  vox.id==3.) {if(hash13(voxelCoord +iTime+30.) >.95 && hash(iTime +30.)>.99) vox.life=clamp(vox.life+1.,0.,3.);}\n    if(next[2].id==3.  &&  vox.id==3.) {vox.id=2.;}\n    if(next[2].value==3 && (vox.id==0.|| vox.id==12.)) {vox.id=next[2].id;} \n    \n    //BELOW\n    if(next[5].id==10.  && next[5].life>0. && vox.id==0.) {vox.id=10.;  vox.life=next[5].life-1.; vox.ground=0.;}\n    if(next[5].id==10.  && next[5].life<1.) {vox.id=11.;  vox.life=TREE_SIZE;}\t\n    if((next[5].id!=3.|| next[5].shape!=0)  &&  vox.id==0.) {vox.life=0.;}\n    if((next[5].id!=0.|| next[5].id==12.)  &&  vox.value==3) {vox.id=0.; vox.value=0;vox.life=0.;}\n\n#ifdef WATER_FLOW\n    if(load(_flow).r>0.5) {\n    if(vox.id==0.) vox.life=0.;           \n    if(vox.id==12. || vox.id==0.){\n    \t\n        float w= vox.id==12.?vox.life:0.;\n        float w_new=w;\n        \n        float w_U  = next[2].id==12.?next[2].life:0.;//(next[2].id==0.? 0.:-1.);\n        float w_D  = next[5].id==12.?next[5].life:(next[5].id==0.? 0.:-1.);\n        float w_LU = next[6].id==12.?next[6].life:(next[6].id==0.? 0.:-1.);\n        float w_L  = next[7].id==12.?next[7].life:(next[7].id==0.? 0.:-1.);\n        float w_LD = next[8].id==12.?next[8].life:(next[8].id==0.? 0.:-1.);\n\n               \n        float OW=.0;\n        float FL=.9; // lateral flow\n        //TRANSITIONS \n     \t//porting from https://www.shadertoy.com/view/WdjBDV\n\t\t\n        \n        //RULE 1 OUT          \n        if( w>0. && w_D < WATER_FLOW && w_D>-1.) { w_new =max(0.,w +w_D -WATER_FLOW   ); }       \n        //RULE 1 IN    \n         if( w_U>0. && w<WATER_FLOW ) {w_new=min(WATER_FLOW, w + w_U);}\n\n            \n         // RULE2_OUT \n        if(w>0. && (w_LD>= WATER_FLOW*OW || w_D<0.) && (w_L < w -2. ) && w_L>=0. && w_LU <1. )\n        {w_new= w -floor(w-w_L)*FL;}\n\n        //RULE2 IN        \n        if( ( w_L >0. ) && (w_LD>=WATER_FLOW*(1.-OW*2.) || w_LD<0.) && (w<w_L-2.) && (w_U <1.))\n        {w_new  =  w + floor((w_L-w)*FL );}  \n\n\n        //INFINITE SOURCE\n        if(next[7].id==15. || next[5].id==15. || next[2].id==15. ){ w_new  =  WATER_FLOW; }\n        \n        \n    \tif(w_new >0. && vox.value==0) {vox.id=12.; vox.life= clamp(w_new,0.,WATER_FLOW);}\n    \tif(w_new <.1 &&  vox.value==0){vox.id=0.;vox.life= 0.;}\n        if( vox.value==1) {vox.value=0;}\n#ifdef SUBVOXEL\n        //surface water is half block\n        if( next[2].id!=12. && vox.id==12.){\n            if(vox.life < WATER_FLOW*.3) vox.shape=2;\n            else vox.shape=3;\n             \n        }\n        else  vox.shape=0;\n    \n#endif\n        \n    }\n\t}\n#endif\n    if(next[5].id==3.  &&  vox.id==0.) {vox.life=1.;}\n    \n#ifdef TREE_DETAIL\t\n    if(vox.id==11.) vox.shape=8;\n    if(vox.id==10.) {vox.shape=9;};\n#endif\n\n#ifdef FIREFLIES \n    //if(vox.id==26.){vox.id=0.;  vox.light.t=15.;}\n    if(vox.id==26.){if(vox.light.t>1.) vox.light.t--; else vox.id=0.;vox.light.s=15.; }\n    \n    if(voxelCoord.z<35. || abs(load(_time).r-750.)<250.)\n        if( air>=62. && (voxelCoord.z < heightLimit_B - 1.)){\n            if(vox.id==0.  && hash13(voxelCoord +vec3(iTime))>0.9999  ) {vox.id=26.;  vox.light.t=15.;}\n        } \n#endif\n    \n#if STRUCTURES>0\n    vec3 oldOffset = floor(vec3(load(_old+_pos).xy, 0.));\n\tstructures( voxelCoord,   vox,  oldOffset,  iFrame,  iTime);\n#endif\n    \n    fragColor = encodeVoxel(vox);\n#endif\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "/*\nVOXEL MEMORY 2 - SURFACE \n  mode = 1 it's just a copy of buffer B, working in a limited z range\n  mode = 2 stores onlythe surface block with the height, for a wider area\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef EXCLUDE_CACHE\n    discard;\n#endif\n    \n#ifndef SURFACE_CACHE\n    discard;\n#elif SURFACE_CACHE==2\n    vec2 textelCoord = floor(fragCoord);\n    vec3 offset = floor(vec3(load(_pos).xy, 0.));\n    vec3 voxelCoord = texToVoxCoord(textelCoord, offset,BUFFER_C); \n\n    vec4 newRange_C= calcLoadRange_C(offset.xy,iChannelResolution[1].xy,0.);\n\n    if(!inRange(voxelCoord.xy, newRange_C)) {\n        discard;\n     \n    }\n    voxel vox;  \n    getVoxel( voxelCoord,vox,2);\n\n    if(voxelCoord.z==0. && vox.ground >100.){\n    \tvoxel temp;\n        float h= vox.ground-100.;\n        getVoxel(vec3(voxelCoord.xy,h),temp,2);\n        float id = temp.id;\n        if(id !=0.){\n            vox=temp;\n            vox.ground=h;\n        }\n        else vox.ground--;           \n    } \t\n \n    //NEIGHBOURS\n    if(voxelCoord.z==0. && vox.ground<100.){\n       vec3 s = vec3(1.,0.,0. );\n       vec3 t = vec3(0.,1.,0. );    \n       voxel v[9];    \n       for (int i =-1; i <=1; i++) {\n            for (int j =-1; j <=1  ; j++) {\n               \n                getVoxel(voxelCoord + s* float(i)+t*float(j),v[4+ i+3*j +min(iFrame,0) ] ,2 ); \n                \n                voxel temp = v[4+ i+3*j ];\n                if(i+3*j !=0 && temp.id==10. && temp.ground <100. && temp.ground> vox.ground -TREE_SIZE -1.) {\n                \tvox.id=11.; vox.shape=8;vox.ground=temp.ground+TREE_SIZE+2.;vox.life=0.;\n                }\n            }\n        }\n    }\n    \n    fragColor = encodeVoxel(vox);\n\n#elif SURFACE_CACHE==1\n    vec2 textelCoord = floor(fragCoord);\n    vec3 offset = floor(vec3(load(_pos).xy, 0.));\n    vec3 voxelCoord = texToVoxCoord(textelCoord, offset,BUFFER_C); \n\n    voxelCoord.z+=SURFACE_C;\n\t//vec4 newrange_B = calcLoadRange_B(offset.xy,iChannelResolution[1].xy,1.);\n    vec4 newRange_C= calcLoadRange_C(offset.xy,iChannelResolution[1].xy,0.);\n    //if (inRange(voxelCoord.xy,newrange_B)  ||    \n    if(!inRange(voxelCoord.xy, newRange_C)) {\n        discard;       \n    }\n\n    voxel vox;    \n    getVoxel( voxelCoord,vox,2);\n\n   \t// SUN LIGHT SOURCES  \n    if (voxelCoord.z >= heightLimit_C- 2.) {\n        vox.light.s = 15.;   \n    } else  {\n        //vox.light.s=0.; //correct but initial value is better oon surface\n        vox.light.s = lightDefault(voxelCoord.z);       \n    }\n    \n    // TORCH LIGHT SOURCES\n    if(vox.id==12.) vox.light.t=max(2.,vox.light.t);\n    else if(vox.id==6.) vox.light.t=15.;\n    if(length( load(_pos).xyz + vec3(0,0,3.)- voxelCoord.xyz) <2.) vox.light.t=max( 12.,vox.light.t);\n    \n    \n        \n\t//LIGHT DIFFUSE\n    voxel temp;\n    float air=0.;\n    //int border=0;    \n    \n   \n    //NEIGHBOURS 2=ABOVE 5=BELOW, 0-1-3-4= SIDES\n    float iE=0.;\n       \n    float g=MAX_GROUND;\n    \n    voxel next[6];\n    for(int j=0;j<=1;j++){\n        for(int i=0;i<3;i++){\n            vec3 n= vec3(i==0?1.:0. ,i==1?1.:0.,i==2?1.:0.) * vec3((j==0?1.:-1.));\n      \n            if(voxelCoord.z >= heightLimit_C +SURFACE_C-1.) break;\n            if( voxelCoord.z <SURFACE_C +1.) break;\n            voxel temp;\n            getVoxel(voxelCoord + n,temp,2);//- vec3(0.,0.,SURFACE_C));\n            \n    \t\tnext[i+3*j]= temp;\n            \n            if(voxelCoord.z> heightLimit_C +SURFACE_C) vox.light.s=15.;\n                else lightDiffusion(vox,temp,n);\n            \n            //ELECTRICITY DIFFUSION\n            if(vox.id==17.){\n            \tif(temp.id==8.) iE=10.;\n                if(temp.id==17. && temp.life>1.) iE=max(iE,temp.life-1.);\n            }\n\n            \n           if(temp.id==0.) air += pow(2., float(j*3+i));\n            \n            //LEAFS:\n           if(temp.id==11.  && temp.life>0. &&vox.id==0.) {vox.id=11.;  vox.life=temp.life-1.; }\n     \n        }\n    }\n    \n    \n    vec3 pos = load(_pos).xyz;\n    \n    //ELECTRICITIY\n    if(vox.id==17.){\n        vox.life=max(iE,vox.life-1.);\n        //if(iE>0.) vox.light.t=15.; else vox.light.t=0.;\n    }\n        \n\tif(sdBox(pos-voxelCoord -vec3(0.,0.,1.),vec3(.5,.5,.5))<=.01 &&vox.id==3.) vox.id=2.;\n    \n    \n    //ABOVE    \n    if(next[2].id==0.  &&  vox.id==2.) {if(hash13(voxelCoord +iTime ) >.95 && hash(iTime)>.99) vox.id=3.;vox.life=0.;}\n    if(next[2].id==0.  &&  vox.id==3.) {if(hash13(voxelCoord +iTime+30.) >.95 && hash(iTime +30.)>.99) vox.life=clamp(vox.life+1.,0.,3.);}\n    if(next[2].id==3.  &&  vox.id==3.) {vox.id=2.;}\n    if(next[2].id==12. && vox.id==0.) {vox.id=12.;}\n    if(next[2].value==3 && (vox.id==0.|| vox.id==12.)) {vox.id=next[2].id;} \n    \n    //BELOW\n    if(next[5].id==10.  && next[5].life>0. && vox.id==0.) {vox.id=10.;  vox.life=next[5].life-1.; vox.ground=0.;}\n    if(next[5].id==10.  && next[5].life<1.) {vox.id=11.;  vox.life=TREE_SIZE;}\n    if((next[5].id!=3.|| next[5].shape!=0)  &&  vox.id==0.) {vox.life=0.;}\n    if((next[5].id!=0.|| next[5].id==12.)  &&  vox.value==3) {vox.id=0.; vox.value=0;vox.life=0.;}\n    if(next[5].id==3.  &&  vox.id==0.) {vox.life=1.;}\n    \n#ifdef TREE_DETAIL\t\n    if(vox.id==11.) vox.shape=8;\n    if(vox.id==10.) {vox.shape=9;};\n#endif\n\n\n    // FIREFLIES \n    //if(vox.id==26.){vox.id=0.;  vox.light.t=15.;}\n    if(vox.id==26.){if(vox.light.t>1.) vox.light.t--; else vox.id=0.;vox.light.s=15.; }\n    \n    if(voxelCoord.z<35. || abs(load(_time).r-750.)<250.)\n        if( air>=62. && (voxelCoord.z < heightLimit_C +SURFACE_C - 1.)){\n            if(vox.id==0.  && hash13(voxelCoord +vec3(iTime))>0.9999  ) {vox.id=26.;  vox.light.t=15.;}\n\n        } \n\n#ifdef STRUCTURES\n    vec3 oldOffset = floor(vec3(load(_old+_pos).xy, 0.));\n\tstructures( voxelCoord,   vox,  oldOffset,  iFrame,  iTime);\n#endif\n    \n    fragColor = encodeVoxel(vox);\n#endif\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "#ifdef MC\n\n\nint gFrame=0; \n\n//--------------------\n//porting of \"Marching Cubes\" algorithm by Paul Bourke (1994)\n//http://paulbourke.net/geometry/polygonise/ \n struct TRIANGLE {\n   vec3 p[3];\n} ;\n\n\n struct GRIDCELL{\n   vec3 p[8];\n   float val[8];\n} ;\n\n const vec3 VertexOffset[8] =vec3[8]\n(\n        vec3(0,0,0), vec3(1,0,0),vec3(1,1,0),vec3(0,1,0),\n        vec3(0,0,1), vec3(1,0,1),vec3(1,1,1),vec3(0,1,1)\n);\n\n\n//lookup tables retrieved from BufferA\n#define edgeTable(i) int(texelFetch(confChannel, ivec2(i,30),0).x)\n#define triTableRow(i) ivec4(texelFetch(confChannel, ivec2(i,31),0))\n#define triTableVal(tt,j) int((tt[j>>2]&(15*(1<<((j&3)*4))))>>((j&3)*4))\n\nconst int  vertexTable[24] =int[24](\n   0,1,   1,2,  2,3,   3,0, \n   4,5,   5,6,  6,7,   7,4,   \n   0,4,   1,5,  2,6,   3,7);\n   \n/*\n   Linearly interpolate the position where an isosurface cuts\n   an edge between two vertices, each with their own scalar value\n*/\nfloat  VertexWeight(float isolevel,float valp1, float valp2)\n{  \n   return  (isolevel - valp1) / (valp2 - valp1);\n}\n\n//input: isolevel value at 8 cube vertexs and isolevel threshold\n//output: number of triangles (-1= outside) and list of triangles (up to 5 in worst case)\nuvec4  Polygonise(inout GRIDCELL grid,float isolevel,inout TRIANGLE[5] triangles,sampler2D confChannel)\n{\n \n   /*\n      Determine the index into the edge table which\n      tells us which vertices are inside of the surface\n   */\n   int cubeindex = 0;\n   for(int i=gFrame;i<8;i++) if (grid.val[i] < isolevel) cubeindex |= 1<<i;\n\n   /* Cube is entirely in/out of the surface -1=IN, 0=OUT */\n   int e=edgeTable(cubeindex);\n   if ( e<= 0) return uvec4(e);\n\n   /* Find the vertices where the surface intersects the cube */\n   vec3 vertlist[12];\n   float vertW[12];\n\n\n   for(int i=0;i<12;i++)\n   if ((e & (1<<i))>0)  {\n       vertW[i]= VertexWeight(isolevel,grid.val[vertexTable[i*2]], grid.val[vertexTable[i*2+1]]);\n          \n       vertlist[i]= mix( grid.p[vertexTable[i*2]], grid.p[vertexTable[i*2+1]],vertW[i]);\n   }\n   /* Create the triangle */\n   uvec4 tridata=uvec4(0u); //x=number of triangles, yzw= tritable\n   \n   ivec4 ttr=triTableRow(cubeindex); \n   for (int i=gFrame;triTableVal(ttr,i)!=15 && i<15;i+=3) {\n       \n       for(int j=gFrame;j<3;j++)   {\n           uint k =uint(triTableVal(ttr,(i+j)));\n           int idx =(i+j);\n           if(idx<8) tridata.y +=  k*( 1u<<(idx*4));\n           else tridata.z += k*( 1u<<(idx*4-32));\n        \n           tridata.w+=  uint( floor(vertW[k]*4. )  ) \n                        *( 1u<<(idx*2));\n           triangles[tridata.x].p[j] = vertlist[k];\n       }\n      \n      tridata.x++;\n   }\n\n   return uvec4(tridata);\n}\n//-------------------------------------\n//Iq\nvec2 boxIntersection( in vec3 ro, in vec3 rd, in vec3 rad) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return vec2(-1.0); \n    \n    //vec3 normal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    return vec2( tN, tF );\n}\n\n\n// triangle degined by vertices v0, v1 and  v2\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n    vec3  n = cross( v1v0, v2v0 );\n    \n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n    if( u<0.0 || u>1.0 || v<0.0 || (u+v)>1.0 ) t = -1.0;\n    return vec3( t, u, v );\n}\n#endif\n//--------------------------\nvec2 max24(vec2 a, vec2 b, vec2 c, vec2 d) {\n\treturn max(max(a, b), max(c, d));   \n}\n\nfloat lightLevelCurve(float t) {\n    t = mod(t, 1200.);\n\treturn 1. - ( smoothstep(400., 700., t) - smoothstep(900., 1200., t));\n}\n\nvec3 lightmap(in vec2 light) {\n    light = 15. - light;\n\tif(load(_torch).r>0.5) light.t=13.;\n    \n    return clamp(mix(vec3(0), mix(vec3(0.11, 0.11, 0.21), vec3(1), lightLevelCurve(load(_time).r)), pow(.8, light.s)) + mix(vec3(0), vec3(1.3, 1.15, 1), pow(.75, light.t)), 0., 1.);   \n\n}\n\nfloat vertexAo(float side1, float side2, float corner) {\n\treturn 1. - (side1 + side2 + max(corner, side1 * side2)) / 5.0;\n}\n\nfloat opaque(float id) {\n\t//return id > .5 ? 1. : 0.;\n    return  id != 0. && id!= 12. && id!= 26. ? 1. :0.;\n}\n\nvec3 calcOcclusion(vec3 r,vec3 n, vec2 uv,voxel vox) {\n#ifndef OCCLUSION\n    return vec3(vox.light , .75);\n#else    \n \t//tangents:\n    vec3 s = vec3(step(.1,abs(n.y)), 1.- step( .1, abs(n.y)) ,0.                  );\n    vec3 t = vec3(step(.1,abs(n.z)), 0.                   ,1.- step(.1,abs(n.z)  ));\n    \n   //neightbours vector\n   //v[0],v[1],v[2]\n   //v[3],v[4],v[5]\n   //v[6],v[7],v[8]\n   voxel v[9]; \n   \n   for (int i =-1; i <=1; i++) {\n        for (int j =-1; j <=1  ; j++) {            \n             getVoxel(r +n + s* float(i)+t*float(j),v[4+ i+3*j +min(iFrame,0) ] ,3 );                     \t\n        }\n    }\n      \n    float aom, ao[4];\n    vec2 lightm,light[4];\n    for(int i=0;i<=3;i++){\n        \n        ivec4 ids;\n        if(i==0) ids=ivec4(6,7,3,4);\n        if(i==1) ids=ivec4(7,8,4,5);\n        if(i==2) ids=ivec4(3,4,0,1);\n        if(i==3) ids=ivec4(4,5,1,2);\n    \tlight[i +min(iFrame,0)] =max24(v[ids.x].light, v[ids.y].light, v[ids.z].light, v[ids.w].light);\n    }\n    lightm = mix(mix(light[2], light[3], uv.x), mix(light[0], light[1], uv.x), uv.y);\n    \n    for(int i=0;i<=3 ;i++){\n\n        ivec3 ids;\n        if(i==0) ids=ivec3(7,3,6);\n        if(i==1) ids=ivec3(7,5,8);\n        if(i==2) ids=ivec3(1,3,0);          \n        if(i==3) ids=ivec3(1,5,2);;\n        ao[i] = vertexAo(opaque(v[ids.x].id), opaque(v[ids.y].id), opaque(v[ids.z].id));\n    }\n    aom = mix(mix(ao[2], ao[3], uv.x), mix(ao[0], ao[1], uv.x), uv.y);\n   if(opaque(v[4].id)>0.) {aom*=0.75;}  \n    \n     \n    return vec3(lightm , aom);\n#endif    \n\n}\n\n// RENDERING\n\nvec3 rayDirection(vec2 angle, vec2 uv, vec2 renderResolution){\n    vec3 cameraDir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y));\n    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);\n    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) * renderResolution.y / renderResolution.x;\n\treturn normalize(cameraDir + uv.x * cameraPlaneU + uv.y * cameraPlaneV);\n\n}\n\nstruct rayCastResults {\n\tbool hit;\n    vec3 rayPos;\n    vec3 mapPos;\n    vec3 normal;\n    vec2 uv;\n#ifdef SUBTEXTURE  \n    vec2 uv_txt;\n#endif    \n    float dist;\n    voxel vox;\n    float water;\n    float fog;\n    bool grass;\n    bool mirror;\n    vec3 color;\n    float fresnel;\n\n};\nmat3 rotate(float theta,int axis) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    if (axis==1) return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, s),\n        vec3(0, -s, c)\n    );\n    if (axis==2) return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n    return mat3(\n        vec3(c, s, 0),\n        vec3(-s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n//From https://github.com/hughsk/glsl-hsv2rgb\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 sun(){\n    float t = load(_time).r;\n    float sunAngle = (t * PI * 2. / 1200.) + PI / 4.;\n    const float risingAngle=PI/6.;\n    return  vec4(cos(sunAngle)*sin(risingAngle), cos(sunAngle)*cos(risingAngle), sin(sunAngle),lightLevelCurve(t));\n}\n\n#ifdef CLOUDS \nfloat fogDensity(vec3 p) {\n\n\tfloat density = 2. - abs(p.z - 80.)*1.7;\n    //density += mix(0., 40., pow(.5 + .5 * snoise(p.xy /557. + vec2(0.576, .492)), 2.)) * snoise(p / 31.51 + vec3(0.981, .245, .497));\n    density += mix(0., 30., pow(.2 + 1.5 * snoise((p.xy +iTime)/207. + vec2(0.576 +iTime/200., .492)), 2.)) * snoise((p +iTime) / 30.99 + vec3(0.981, .245, .497 +iTime/2000.));\n\n     return clamp(density ,0.,50.);\n\n}\nvoid applyFog( inout vec3  rgb,       // original color of the pixel\n               in float distance ) // camera to point distance\n{\n    \n    float fogAmount = 1.0 - exp( -distance*0.015 );\n    vec3  fogColor  = vec3(0.5,0.6,0.7)*clamp(sun().w,.1,1.);\n    rgb= mix( rgb, fogColor, fogAmount );\n}\n#endif\n\n//-------------\n\nfloat noise(in vec2 p) {\n\tvec2 F = floor(p), f = fract(p);\n\tf = f * f * (3. - 2. * f);\n\treturn mix(\n\t\tmix(hash2(F), \t\t\t hash2(F+vec2(1.,0.)), f.x),\n\t\tmix(hash2(F+vec2(0.,1.)), hash2(F+vec2(1.)),\t  f.x), f.y);\n}\n\n//GRASS ADAPTED FROM POLYANKA by W23\n//https://www.shadertoy.com/view/MdsGzS\n#ifdef GRASS_DETAIL\nconst int c_grassmarch_steps = 48;\nconst float c_gscale = 37.;\nconst float c_gheight = 0.4;\n//const float c_rgslope = 2. / (c_gscale * c_gheight);\n\n\nvec2 noise2(in vec2 p) {\n\tvec2 F = floor(p), f = fract(p);\n\tf = f * f * (3. - 2. * f);\n\treturn mix(\n\t\tmix(hash22(F), \t\t\t  hash22(F+vec2(1.,0.)), f.x),\n\t\tmix(hash22(F+vec2(0.,1.)), hash22(F+vec2(1.)),\tf.x), f.y);\n}\n\nfloat fnoise(in vec2 p) {\n\treturn .5 * noise(p) + .25 * noise(p*2.03) + .125 * noise(p*3.99);\n}\n\nvec2 wind_displacement(in vec2 p) {\n\treturn noise2(p*.1+iTime)/100. - 0.005;\n}\n\nfloat grass_height(in vec3 p,float gheight) {\n\tfloat base_h= 0.15;\n\tfloat depth = 1. - (base_h - p.z) / gheight;\n\tvec2 gpos = (p.xy  + depth * wind_displacement(p.xy));\n\treturn base_h - noise(gpos * c_gscale) * gheight;\n}\n\n\nstruct xs_t {\n    bool hit;\n\tvec3 pos; \n\tfloat occlusion;\n    float dist;\n};\n\n\nxs_t trace_grass(vec3 o, vec3 d,vec3 mapPos,float gheight) {\n    bool hit=false;\n\tfloat L = .005;\n    //float Lmax= 1.8;\n\tfor (int i = 0; i < c_grassmarch_steps; ++i) {\n\t\tvec3 pos = o + d * L ;\n\t\tfloat h = grass_height(pos +mod(mapPos,10.),gheight);\n\t\tfloat dh = pos.z - h;\n        if (dh < .005) {hit=true; break;}\n\t\tL += dh * 2. / (c_gscale * gheight);\n        vec3  dist = abs(pos-.5);\n        //if (L > Lmax) break;\n\t\tif (max(dist.z, max(dist.x,dist.y))>.5) break;\n\t}\n\tvec3 pos = o + d * L;\n\tfloat occlusion = 1. - 2.*(0. - pos.z) / gheight;\n\treturn xs_t(hit, pos + mod(mapPos,99.),  (hit)?1.:min(1.,occlusion),L);\n}\n\nvec3 shade_grass(in xs_t xs) {\n    \n\tvec2 typepos = xs.pos.xy + wind_displacement(xs.pos.xy);\n\tfloat typemask1 = fnoise(2.5*typepos);\n\tfloat typemask2 = pow(fnoise(.4*typepos), 3.);\n\tfloat typemask3 = step(.71,fnoise(.8*typepos));\n\tvec3 col1 = vec3( 106./255., 170./255.,  64./255.);\n\tvec3 col2 = vec3(.7, .73, .3)*.3;\n\tvec3 col3 = vec3(1., 1., .1);\n\tvec3 col4 = vec3(1., .4, .7);\n\tvec3 color = mix(mix(mix(col1, col2, typemask1),\n\t\t\tcol3, typemask2), col4, typemask3) *.8;\n\tcolor *= xs.occlusion;\n\treturn color;\n}\t\n#endif\n//-----------------------------\n//water reflection: https://www.shadertoy.com/view/MdXGW2\n#define BUMPFACTOR 0.3\n#define EPSILON 0.1\n\nfloat waterHeightMap( vec2 pos ) {\n    return 0.9+.2*noise(pos +iTime/3.);\n    //better but requires more compilation time\n    //return 0.9+.1*snoise(vec3(pos,iTime/3.));\n}\n\nfloat fresnelR(vec3 d, vec3 n)\n{\n    //float a = clamp(1.0-dot(n,-d), 0.0, 1.0);   \n   // return clamp(exp((5.0*a)-5.0), 0.0, 1.0);\n    return pow( clamp( 1.0 + dot(d,n), 0.0, 1.0 ), 5.0 );\n}\n//------------------------*/\nvec4 VoxelHitPos(vec3 pos, vec3 ro, vec3 rd){\n    vec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n    vec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n    float t=  max ( mini.x, max ( mini.y, mini.z ) );\n    return vec4(t*rd+ro,t);\n}\n\n#ifdef SUBVOXEL\nrayCastResults raySubCast(vec3 rayPosOrig, vec3 rayDir, int shape,float rotation,vec3 seed){\n \n\trayCastResults  res;\n    \n    \n    vec3 c=vec3(.5);\n    float theta1= PI/2.*floor(mod(rotation,4.));\n    rayPosOrig = rotate( theta1,3) *(rayPosOrig-c) +c;\n    rayDir= rotate( theta1,3)*rayDir; \n    float theta2= PI/2.*(floor(rotation/4.));\n    rayPosOrig = rotate( theta2,2) *(rayPosOrig-c)+c;\n    rayDir= rotate( theta2,2)*rayDir; \n       \n     vec3 ro = (rayPosOrig) *N_SUBVOXEL;\n   \n\t//if(abs(ro.x -N/2.)>N/2. ||abs(ro.y -N/2.)>N/2. ||abs(ro.y -N/2.)>N/2.)return vec4(0.,0.,0.,1.);\n       \n\tvec3 ri = 1.0/rayDir;\n\tvec3 rs = sign(rayDir);\n    vec3 pos = floor(ro-rayDir*0.002);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tres.hit=false;\n\tvec3 mm = vec3(0.);\n    float t=0.;\n       \n\tfor( int i=0; i<int(N_SUBVOXEL)*3; i++ ) \n    {\t\n\t\tif(i>=0){\n       \t mm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);           \n        }\n         dis += mm * rs * ri;\n         pos += mm * rs;\n        \n        //if( sdBox( ro+t*rayDir-vec3(N_SUBVOXEL/2.),vec3(N_SUBVOXEL/2.) )>.05) {res.hit=false; break;}\n        \n        //float timestep= floor(mod(iTime,N_SUBVOXEL));\n        //SHAPES\n       \n        //SINGLE BLOCK\n        //if( sdBox( pos-vec3(x,x,x) +rs*0.001 ,vec3(.5,.5,.5) )<.01) {res.hit=true; break;}\n     \n\n        if(shape==1){// POLE\n        \tif( sdBox( pos-vec3(2.,2.,2.) ,vec3(.5,.5,2.5) )<.001) {res.hit=true; break;}\n\t      \n        }else if(shape==2){//STEP 1\n            if(sdBox( pos-vec3(2.,2.,0.)  ,vec3(2.5,2.5,0.5) )<.001) {res.hit=true; break;}\n          \n        }else if(shape==3){//STEP 2\n             if( sdBox( pos-vec3(2.,2.,0.) ,vec3(2.5,2.5,1.5) )<.001) {res.hit=true; break;}\n           \n        }else if(shape==4){//FENCE 1\n         \tif( sdBox( pos-vec3(2.,2.,2.)  ,vec3(.5,.5,2.5) )<.001) {res.hit=true; break;}\n          \tif( sdBox( pos-vec3(2.,2.,4.)  ,vec3(.5,2.5,.5) )<.001) {res.hit=true; break;}\n          \n        }else if(shape==5){//FENCE 2\n        \tif( sdBox( pos-vec3(2.,2.,2.) ,vec3(.5,.5,2.5) )<.001) {res.hit=true; break;}\n          \tif( sdBox( pos-vec3(1.,2.,4.)  ,vec3(1.5,.5,.5) )<.001) {res.hit=true; break;}\n          \tif( sdBox( pos-vec3(2.,1.,4.)  ,vec3(.5,1.5,.5) )<.001) {res.hit=true;break;}\n\n        }else if(shape==6){//SLOPE 1\n            if( dot(pos,  vec3(0.,sqrt(2.),sqrt(2.))) -6. <0.001 \n            && sdBox( pos-vec3(2.,2.,2.),vec3(2.5,2.5,2.5) )<.001  ) {res.hit=true; break;}\n            \n        }else if(shape==7){//PANEL\n            if(sdBox( pos-vec3(0.,2.,2.)  ,vec3(.5,2.5,2.5) )<.001) {res.hit=true; break;}\n            \n        }\n#ifdef TREE_DETAIL        \n        else if(shape==8){//TREE W LEAFS\n            \n     \t\tif( sdCross( pos-vec3(2.,2.,2.)  ,vec3(.5,.5,1.5) )<.001) {res.hit=true; res.vox.id=10.; break;}\n            vec3 applePos= vec3(1.,1.,1.);//floor(hash33(seed)*5.);\n            if( sdBox( pos-applePos  ,vec3(.5,.5,.5) )<.01 // && hash13(seed)<.95 \n                 ){res.hit=true; res.vox.id=14.; break;}\n\n            if( sdBox( pos-vec3(2.,2.,2.)  ,vec3(2.5,2.5,2.5) )<.001 && hash13(floor(pos)+seed+.5 )  >.75){res.hit=true; res.vox.id=11.; break;}\n    \n            //\n        }else if(shape==9){//TRUNK\n\t\t\tvec3 p=pos-vec3(2.,2.,2.);\n            //p= vec3(abs(p.x)+abs(p.y),max(p.x,p.y),p.z);\n            if(sdBox( p ,vec3(1.5,1.5,2.5) )<.001){res.hit=true; res.vox.id=10.; break;}\n         \n        }\n#endif        \n\t}\n\t\n\t\n    if(res.hit){\n        res.normal = - mm*rs; \n        vec4 hitPos=VoxelHitPos(pos,ro,rayDir);\n        res.dist=hitPos.a/N_SUBVOXEL;\n        vec3 xyz = hitPos.xyz - pos;\n        res.uv = vec2( dot(mm.yzx, xyz), dot(mm.zxy, xyz) );\n        if(abs(mm.x)>0.) res.uv=res.uv.yx; //invert xz \n        //relative to absolute normals:\n   \t\tres.normal  = rotate( -theta2,2) * rotate(- theta1,3) *res.normal;\n    }\n    return res;  \n}\n#endif\n\n\nvec3    g_n;\nvec2    g_uv;\n\nrayCastResults rayCast(vec3 rayPos0, vec3 rayDir,int maxRayDist,vec4 range,int rayType) {\n\t   \n    voxel vox;\n    vox.id=0.;\n    float waterDist=0.;\n    float fog=0.; \n    rayCastResults res;\n    res.hit = false;\n    res.color=vec3(-1.);\n    res.fresnel=0.;\n    res.mirror=false;\n    rayCastResults subRes;\n    subRes.hit=false;\n\n    vec3 raySign= sign(rayDir);\n    vec3 rayInv = 1./rayDir;\n\tvec3 rayPos=rayPos0;\n    \n    vec3 mapPos=floor(rayPos);\n    if ( rayPos.z >= heightLimit_B && rayDir.z<0.){\n       \n        //MAP RAY FROM ABOVE\n        float nstep= (rayPos.z - heightLimit_B)*rayInv.z;\n        mapPos = floor(rayPos-rayDir *nstep+ raySign*0.001);\n    }\n    vec3 sideDist = (mapPos-rayPos + 0.5 + sign(rayDir)*0.5) *rayInv;\n    vec3 mask=vec3(0.); \n\n    \n    //vec3 offset = floor(vec3(load(_pos).xy, 0.));\n    voxel currentVoxel;\n    getCVoxel( mapPos,currentVoxel,3);\n\tvec3 hitWater = (currentVoxel.id==12.? rayPos: vec3(0.));\n\tbool xRay=(currentVoxel.id!=0. && currentVoxel.id!=12.);\n        \n    for (int i = 0; i < 1000; i++) {\n\n        if(i>0){\n       \t\tmask = step(sideDist.xyz, sideDist.yzx) * step(sideDist.xyz, sideDist.zxy);\n\n        }\n\t\tsideDist += mask *  raySign *rayInv;\n        mapPos += mask *  raySign;\n        \n        if ( mapPos.z < 0. ) break;\n        if ( mapPos.z >= heightLimit_B && rayDir.z > 0.)  break;\n                   \n        getVoxel( mapPos, vox ,3 );\n        \n        //GRASS\n#ifdef  GRASS_DETAIL      \n        if(vox.id==0. && vox.life>0. && rayType==1 ){\n\t\t\tvec4 vd =VoxelHitPos(mapPos,rayPos,rayDir);\n            res.rayPos= vd.xyz;\n            res.dist=vd.a;\n    \t\tvec3 relativePos = res.rayPos -mapPos;\n            \n            float grass = c_gheight*vox.life;\n           \txs_t xs = trace_grass(relativePos,rayDir,mapPos,grass);\n            \n            if (xs.hit ) {\n                \n                //color = mix(color, c_skycolor, smoothstep(c_maxdist*.35, c_maxdist, xs.l));\n            \tres.hit = true;                \n                res.vox=vox;\n                res.grass=true;\n                res.color=shade_grass(xs);\n                res.mapPos = mapPos;\n                res.water =waterDist;\n    \t\t\tres.fog=fog;\n                res.normal = vec3(0,0,1);\n                res.dist+=  xs.dist ;\n    \t\t\tres.rayPos += rayDir * xs.dist ;\n                return res;\n            } \n\t\n        }\n#endif        \n       \n#ifdef SUBVOXEL        \n        if(vox.shape!=0 && vox.id!=0. ){ \n            //SUB VOXEL\n\n    \t\tvec3 hitVoxelPos = VoxelHitPos(mapPos,rayPos,rayDir).xyz;\n            \n            if( sdBox( mapPos+vec3(.5) -rayPos,vec3(.5,.5,.5) )<.001) hitVoxelPos=rayPos;\n            float rotation= vox.rotation;\n            \n             subRes = raySubCast( hitVoxelPos - mapPos ,  rayDir, vox.shape,rotation,mapPos);\n            if(subRes.hit && vox.id!=12.) { \t\t\n       \t\t \tres.hit = true; \n                if(subRes.vox.id!=0.) vox.id=subRes.vox.id;             \n                break;\n            }\n            else if(vox.id==12. && subRes.hit && rayType!=3) { \n            \t//nothing to do\n            }\n            else {vox.id=0.;res.hit = false;}\n        }\n         \n#endif \n#ifdef MC\n         if(vox.surface!=0. && rayType==1){ \n                gFrame=min(iFrame,0);\n                vec3 hitVoxelPos = VoxelHitPos(mapPos,rayPos,rayDir).xyz;\n                GRIDCELL g;\n                float csz=1.;\n                float mcid=0.;\n                bool surface=false;\n                for(int id=0;id<8;id++)\n                {\n                    g.p[id]=mapPos+  VertexOffset[id]*csz;\n                    voxel vt;\n                    getCVoxel(g.p[id],vt,3 );\n                    if(vt.id==3.) vt.id=4.;\n                    mcid =max(mcid,vt.id);\n                    g.val[id]= vt.id!=0.?1.:-1.;\n                    surface = surface || ( g.val[id]*g.val[0]<0.);\n                }    \n\n                if(surface ){\n\n                    TRIANGLE[5] triangles;\n\n                        //calculate vertexes & triangles (requires buffer A and B)\n\n                    uvec4 tridata = Polygonise(g,0.,triangles,iChannel0);\n\n                    int ntriangles=int(tridata.x);          \n                    float t = 1000.0; \n                    for(int i=min(iFrame,0);i<ntriangles;i++) {\n                        vec3 tri =triIntersect( hitVoxelPos,rayDir,triangles[i].p[0],triangles[i].p[1],triangles[i].p[2]);\n                        if(tri.x>0.  && tri.x <t) {\n                            t=tri.x;\n                             g_n=-normalize(cross(triangles[i].p[1]-triangles[i].p[0],triangles[i].p[2]-triangles[i].p[0]));\n                             g_uv= tri.yz;\n                         }\n                    }\n                    if(t< 1000. ) {\n                    \n                        subRes.hit = true; \n                        subRes.mapPos = mapPos;\n                        subRes.normal = g_n;\n                        subRes.uv=g_uv;\n                        subRes.rayPos = hitVoxelPos + rayDir*t;\n                        subRes.dist = length(rayPos0 - subRes.rayPos);\n                        vox.id=mcid;\n                        subRes.vox=vox;\n                        subRes.color = getTexture(mcid, g_uv).rgb *(.7 - .3*dot( sun().xyz,g_n));;             \n                        subRes.water =waterDist;                                     \n                        subRes.fog=fog;\n                        subRes.grass=true;\n                        return subRes;\n                        \n                        //res.hit = true;                        \n                        //break;\n                    }else vox.id=0.;\n                }\n                \n        }\n#endif       \n        if(vox.id==14. &&rayType!=3){ //&& length(rayPos-mapPos -vec3(0.,0.,1.))<=6.){\n            //MIRROR \n                \n            vec3 endRayPos = VoxelHitPos(mapPos,rayPos,rayDir).xyz;\n            rayDir*= (vec3(1.) - 2.* mask); \t\t\t\t\n            rayDir=normalize(rayDir);rayInv=1./rayDir;raySign= sign(rayDir);\n\n            sideDist = (mapPos-endRayPos + 0.5 + raySign*0.5) /rayDir;\n            vox.id=0.;\n            res.mirror=true;\n            rayPos=endRayPos;\n            continue;\n        }\n        if(vox.id==12.  ){ //vox.life < WATER && vox.life>0.){\n        \t//ENTERING WATER\n            if(hitWater.z<1.) {\n                \n                // deviate ray xy if intercept water NOT EXACT                \n    \t\t\tvec3 endRayPos = VoxelHitPos(mapPos,rayPos,rayDir).xyz;\n                vec3 n=mask;\n                if(subRes.hit) {\n                    \tendRayPos+=rayDir * subRes.dist;                    \t\n                        n=subRes.normal;\n                }\n     \t\t\thitWater=endRayPos;\n\n                if(abs(n.z)>0.) {\n                    vec2 coord = hitWater.xy;\n                    vec2 dx = vec2( EPSILON, 0. );\n                    vec2 dy = vec2( 0., EPSILON );\n                    float bumpfactor = BUMPFACTOR ;//* (1. - smoothstep( 0., BUMPDISTANCE, dist) );\n\n                    vec3 normal = vec3( 0., 0., 1. );\n                    normal.x = -bumpfactor * (waterHeightMap(coord + dx) - waterHeightMap(coord-dx) ) / (2. * EPSILON);\n                    normal.y = -bumpfactor * (waterHeightMap(coord + dy) - waterHeightMap(coord-dy) ) / (2. * EPSILON);\n                    normal = normalize( normal );\n                   \n                    vec3 rayDirOld=rayDir;\n                    \n                    res.fresnel=fresnelR(rayDir, normal);\n    \t\t\t\t\n                    \n                    rayDir = refract( rayDir, normal ,1.3);\n                    if(res.fresnel>.005){\n                        rayDir = reflect( rayDirOld, normal );\n                        hitWater=vec3(0.,0.,-1.);\n                    }\n                }else if(abs(n.x)>0.) rayDir.yz*=(0.7+.4*noise(endRayPos.yz+iTime));\n                else  rayDir.xz*=(0.7+.4*noise(endRayPos.xz+iTime));\n                rayDir=normalize(rayDir);rayInv=1./rayDir;raySign=sign(rayDir);\n\n                rayPos=endRayPos;\n                sideDist = (mapPos-endRayPos + 0.5 + raySign*0.5) /rayDir;\n                               \n            }\n            subRes.hit=false;\n            //vox.id=0.;\n            continue;\n        }\n        if( vox.id !=0. && vox.id!=26. && vox.id!=12. ){\n        \tif(xRay) continue;\n            else{\n            \tres.hit = true; \n                break;\n            }\n        } \n\n#ifdef CLOUDS         \n        //FOG & CLOUDS\n        if(CLOUDS>0.) {\n        \tfloat fogd= fogDensity(mapPos)/4.*CLOUDS;\n        \tif(fogd >4. && rayType!=2) break;        \n        \tfog += fogd;\n        }\n#endif        \n        //NO HIT\n        xRay=false; \n        if(hitWater.z>0. && vox.id==0.)  {waterDist +=length(hitWater-mapPos); hitWater=vec3(-1.);res.fresnel=.001;}\n        \n        if(!inRange(mapPos.xy, range) && i> maxRayDist) break;\n\n        if(i > int( load(_rayLimit).r)) break;\n\t}\n    if(hitWater.z>0.)  waterDist +=length(hitWater-mapPos);\n    if(hitWater.z<0.)  waterDist =0.;   //reflection\n    \n    \n    if(load(_stats).r>0.5){\n    \tvec4 range_B= calcLoadRange_B(rayPos.xy,iResolution.xy,1.);\n        if(res.hit && inRange(mapPos.xy, range)  && !inRange(mapPos.xy, range_B)) vox.id = 8.;    \n\n\n#if SURFACE_CACHE>0        \n        vec4 range_C1= calcLoadRange_C(rayPos.xy,iResolution.xy,1.);\n\t\tvec4 range_C0 = load(_old+_loadRange_C);\n        if(res.hit && inRange(mapPos.xy, range_C0)  && !inRange(mapPos.xy, range_C1)) vox.id = 17.;    \n#endif\n    }\n        \n    if(!res.hit  &&rayDir.z < 0. && !inRange(mapPos.xy, range)){\n        if(mapPos.z>55.) {vox.id = 0.; res.hit=false;}\n        else { vox.id=3.; res.hit = true;}\n    }\n    \n    res.mapPos = mapPos;\n    res.normal = res.hit? -raySign * mask:vec3(0.);\n    res.rayPos = VoxelHitPos(mapPos,rayPos,rayDir).xyz;\n    res.dist = length(rayPos0 - res.rayPos);\n    res.vox=vox;\n    res.water =waterDist;\n    res.fog=fog;\n    \n    if(subRes.hit){\n        \n       \tres.normal=  subRes.normal; \n      \tmask=abs(subRes.normal);\n        res.rayPos += rayDir * subRes.dist ;\n        res.dist = length(rayPos - res.rayPos);\n        \n#ifdef SUBTEXTURE\n        // uv coordinates are relative to subvoxel (more detailed but aliased)\n    \tres.uv_txt = subRes.uv ;\n    \t//return res;\n#endif\n    }\n    \n    //uv coordinates are relative to block (also with subvoxels)                       \n    if (abs(mask.x) > 0.) {\n        res.uv = fract(res.rayPos.yz);\n    }\n    else if (abs(mask.y) > 0.) {\n        res.uv = fract(res.rayPos.xz);\n    }\n    else {\n        res.uv = fract(res.rayPos.yx);\n    }  \n    if(res.hit && !res.grass){\n        float textureId = res.vox.id;\n        if (textureId == 3.) textureId += res.normal.z;\n        vec2 uv_txt= res.uv;\n#ifdef SUBTEXTURE                \n        if(res.vox.shape!=0) uv_txt= res.uv_txt;\n#endif               \n        res.color = getTexture(textureId, uv_txt).rgb;\n    \n    }   \n    return res;\n}\n\n\nvec3 skyColor(vec3 rayDir) {\n    \n    vec4 s= sun();\n    float lightLevel = s.w;\n\n    vec3 sunDir=s.xyz;\n    vec3 daySkyColor = vec3(.5,.75,1);\n    vec3 dayHorizonColor = vec3(0.8,0.8,0.9);\n    vec3 nightSkyColor = vec3(0.1,0.1,0.2) / 2.;\n    \n    vec3 skyColor = mix(nightSkyColor, daySkyColor, lightLevel);\n    vec3 horizonColor = mix(nightSkyColor, dayHorizonColor, lightLevel);\n    float sunVis = smoothstep(.99, 0.995, dot(sunDir, rayDir));\n    float moonVis = smoothstep(.999, 0.9995, dot(-sunDir, rayDir));\n    return mix(mix(mix(horizonColor, skyColor, clamp(dot(rayDir, vec3(0,0,1)), 0., 1.)), vec3(1,1,0.95), sunVis), vec3(0.8), moonVis);\n    \n}\n\n\n\n// ---- 8< -------- 8< -------- 8< -------- 8< ----\n\n\nvoid render( out vec4 fragColor, vec3 rayPos, vec3 rayDir ,int  maxRayDist, int rayType) {\n\n    vec4 range_B = load(_old+_loadRange_B);\n    vec3 sunDir = sun().xyz; sunDir *= sign(sunDir.z);\n      \n    rayCastResults rays[2] ;//0=view,1 =shadow\n    vec3 ro=rayPos;\n    vec3 rd=rayDir;\n    int rt=rayType;\n    for(int i=0; i<=1;i++){\n    \trays[i]=rayCast(ro, rd,maxRayDist,range_B,rt);\n\t\tif(!rays[i].hit) break;\n \t\tif(SHADOW<0.) break;\n        ro=rays[i].rayPos +rays[i].normal*0.01;\n        rd=sunDir;\n        maxRayDist=  25;//inRange(rays[i].rayPos.xy, range_B) ? 25:5;\n        rt=3;\n            \n    }\n    \n   rayCastResults res = rays[0];\n\t\n\tvec3 color = vec3(0.);\n    \n    if (res.hit) {\n        \n\t\t\t\n        float shadow =rays[1].hit?SHADOW:0.;\n\n        color=res.color;\n\n\n        if(rayType==1 ){\n            bool hB=(res.vox.ground>=MAX_GROUND && res.vox.id!=0. &&res.vox.buffer==BUFFER_B)  \n                   || (res.vox.id==17. && res.vox.life >0.) ;        \n                             \n            if(hB && HIGHLIGHT>0. ){              \n                color  *=(fract(iTime*4.)+.5);\n            }\n            \n            if(res.grass) {              \n            \tcolor *= lightmap( vec2(res.vox.light.s*(1.-shadow*.2),res.vox.light.t)   );                 \n            }else{\n              vec3 occ=calcOcclusion(res.mapPos, res.normal, res.uv,res.vox);\n                color *= lightmap(vec2(occ.x*(1.-shadow*.2),occ.y)) *occ.z; \n            }\n\t\t\t\n            // SELECTION AND MOUSE OVER\n            vec4 pick = load(_pick);\n            if (res.mapPos == pick.xyz || res.vox.value==2) {\n                if (pick.a == 1.) color *= getTexture(32., res.uv).r;\n                else if (res.vox.value==2) color = mix(color, vec3(1.,0.,0.), 0.5);\n                \n                else color = mix(color, vec3(1), 0.2);\n            }\n        }else\n        {\t\n            //MAP\n \t\t\t color *=  clamp( (res.mapPos.z-30.) /30.,0.,1.);\n            color = mix(color, vec3(1), 0.2);\n          \n        }\n        \n    }\n     else color = skyColor(rayDir);\n    \n    vec3 wcolor= vec3(.03,.1,.60)* lightmap( vec2(res.vox.light.s,res.vox.light.t)   );\n    //if(res.water>0.) color *= pow( wcolor ,vec3(sqrt(res.water)/(7. + res.fresnel*1000.)));\n    if(res.water>0.) {\n        color *= pow( wcolor ,vec3(sqrt(res.water)/7.));\n        color = mix(color,wcolor, clamp(res.fresnel*500.,0.3,1.));\n    }\n    else if(res.fresnel>0. ) color =mix(wcolor ,color,clamp(res.fresnel*4.,0.,.9));\n    if(res.mirror) color *= vec3(.9,.5,.5);\n    if(rayType==1) {\n#ifdef CLOUDS        \n        applyFog(color.rgb,res.fog);\n#endif\n        color = pow( color, vec3(0.9) );\n             \n    }\n    fragColor.rgb = color; //pow(color, vec3(1.));\n    \n    if(rayType==3 ) {\n        \n        float encodeNormal=14.+ res.normal.x + res.normal.y*3. + res.normal.z*9.;\n        fragColor=vec4(res.mapPos,(res.hit && res.dist >1. && res.dist <MAX_PICK_DISTANCE ? encodeNormal:0.));\n    }  \n     \n    //DEBUG:\n    //fragColor=vec4( vec2(1.- res.dist /50.),  res.hit?1.:0.,1.);\n    //fragColor=vec4( (1.-.5* sign(res.normal))* abs(res.normal) ,1.);\n    //fragColor=vec4( res.uv,max(abs(res.uv -.5).x,abs(res.uv-.5).y)<.5?1:0 ,1.);\n    //if(res.vox.id==12.) fragColor=vec4(vec2(res.vox.life<2. ? .5:0.),1.- res.vox.life/255.,1.);\n}\n\n\n#define NB 8\nfloat[] \n    camx = float[]   (2954. , 2952. , 2972. , 2972.,2971. ,2955. ,2955. ,2954.),\n\tcamy = float[]   (10139., 10140., 10151.,10151.,10152.,10151.,10153.,10139.),\n\tcamz = float[]   (71.   , 83.   , 48.   ,34.   ,50.   ,50.   ,71.   ,71.),\n    lookx = float[]  (2970. ,2972.  , 2972. ,2952. ,2955. ,2955. ,2954. ,2970.),\n\tlooky = float[]  (10152.,10153. , 10154.,10133.,10151.,10150.,10139.,10152.),\n\tlookz = float[]  (55.   , 50.   , 34.   ,27.   ,50.   ,71.   ,71.   ,55.); \n \n\nmat3 LookAt(in vec3 ro, in vec3 up){\n    vec3 fw=normalize(ro),\n    \t rt=normalize(cross(fw,up));\n    return mat3(rt, cross(rt,fw),fw);\n}\n\nvec3 RD(in vec3 ro, in vec3 cp, vec2 uv, vec2 res) {\n    return LookAt(cp-ro, vec3(0,0,1))*normalize(vec3((2.*uv-res.xy)/res.y, 3.5));\n}\n\nvoid getCam(in vec2 uv, in vec2 res, in float time, out vec3 ro, out vec3 rd) {\n       \n\tvec2 q = uv/res;\n    \n    float t = .16* time,\n\t\t kt = smoothstep(0.,1.,fract(t));\n\n    // - Interpolate positions  and direction\n    int  i0 = int(t)%NB, i1 = i0+1;\n    \n    vec3 cp = mix(vec3(lookx[i0],looky[i0],lookz[i0]), vec3(lookx[i1],looky[i1],lookz[i1]), kt); \n  \n    ro = mix(vec3(camx[i0],camy[i0],camz[i0]), vec3(camx[i1],camy[i1],camz[i1]), kt),\n    ro += vec3(.01*cos(2.*time), .01*cos(time),0.);\n    rd = RD(ro, cp, uv, res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \n    float pixelSize = load(_pixelSize).r;\n    vec2 renderResolution = ceil(iResolution.xy / pixelSize); \n    if (any(greaterThan(fragCoord, renderResolution))) {\n        fragColor = vec4(0);\n        return;\n    }\n        \n    vec3 cameraPos;    \n    vec3 cameraDir;\n    int  rayType = 1;\n \n#ifdef MAP    \n    float MAP_SIZE= iResolution.y/8./pixelSize; \n    vec2 MapCenter=vec2(iResolution.x/pixelSize -MAP_SIZE , iResolution.y/pixelSize - MAP_SIZE);\n    if(abs(load(_map).r-1.) <.1 && distance(fragCoord,MapCenter)<MAP_SIZE) rayType=2;\n    if(abs(load(_map).r-2.) <.1) {\n        rayType=2;\n        MapCenter=vec2(iResolution.x/pixelSize/2. , iResolution.y/pixelSize/2.);\n    }\n    \n#endif    \n    \n    if(max(fragCoord.x,fragCoord.y)<1. ) rayType=3;\n    if(rayType==3){\n        //MOUSE RAY\n        float zoom = pow(10., load(_renderScale).r/10.);///pixelSize;\n        vec2 renderResolution = iResolution.xy *zoom; \n        vec2 renderCenter=vec2(0.5);\n        vec2 uv = (iMouse.xy- renderCenter) / renderResolution - (renderCenter/zoom);//  /pixelSize;\n         cameraPos = load(_pos).xyz + vec3(0,0,1.6);    \n         cameraDir = rayDirection(load(_angle).xy,uv,renderResolution);\n  \n    } \n#ifdef MAP \n    else if(rayType==2){\n     \n        // MAP CAMERA\n        float cameraHeight =1500.;\n        float zoom = cameraHeight/iResolution.x/pixelSize*(load(_map).r>1.5?1.6:.4);\n        vec2 renderResolution = iResolution.xy *zoom; \n        vec2 renderCenter=MapCenter/iResolution.xy*pixelSize;\n        vec2 uv = (fragCoord.xy- renderCenter) / renderResolution - (renderCenter/zoom/pixelSize);    \n        vec2 angle = vec2(0.,PI);\n        if(load(_map).r>1.5){\n        \tangle=iMouse.xy/iResolution.xy*vec2(PI,-PI/3.)+vec2(0,PI);\n        }\n        cameraDir = rayDirection(angle,uv,renderResolution); \n        vec3 cameraCenterDir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y));\n        cameraPos = load(_pos).xyz -cameraCenterDir* cameraHeight;\n    }       \n#endif            \n    else if(rayType==1) \n    {    \n        // MAIN CAMERA\n        float zoom = pow(10., load(_renderScale).r/10.)/pixelSize;\n        vec2 renderResolution = iResolution.xy *zoom; \n        vec2 renderCenter=vec2(0.5);\n        vec2 uv = (fragCoord.xy- renderCenter) / renderResolution - (renderCenter/zoom/pixelSize);\n         cameraPos = load(_pos).xyz + vec3(0,0,1.6);    \n         cameraDir = rayDirection(load(_angle).xy,uv,renderResolution);\n     \n      //DEMO VIEW     \n         if(load(_demo).r >.5)\n             getCam((fragCoord.xy- renderCenter) , renderResolution, iTime, cameraPos, cameraDir);\n                  \n    }   \n\n    render(fragColor,cameraPos, cameraDir, int(load(_rayDistMax).r),rayType);\n       \n    //MAP BORDER:\n#ifdef MAP\n    if(rayType==2){\n        if(load(_map).r <1.5){\n        \tif(abs(distance(fragCoord,MapCenter)-MAP_SIZE)<1.) fragColor.rgb=vec3(0.);    \n        \tif(distance(fragCoord,MapCenter + vec2(sin( load(_angle).x), -cos( load(_angle).x))*MAP_SIZE )<3.) fragColor.rgb= vec3(1.,0.,0.);\n        }\n    }\n#endif        \n    //fragColor = texture(iChannel2, fragCoord / 3. / iResolution.xy);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsByWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3983, 3983, 4014, 4014, 4236], [4238, 4238, 4257, 4257, 4349], [4351, 4351, 4379, 4379, 5973], [5975, 5975, 6032, 6032, 8817]], "test": "untested"}
{"id": "tsjyDG", "name": "Spiral Glow Cube", "author": "JuliaPoo", "description": "This uses Linearly Transformed Cosines for the lighting because it's really fast. Didn't turn out as well as i hoped it'll be tho but ehh.", "tags": ["raytracing", "cube", "fog", "shadows", "diffuse", "vr", "webvr", "ltc"], "likes": 22, "viewed": 930, "published": 3, "date": "1587452409", "time_retrieved": "2024-07-30T21:11:24.313105", "image_code": "// LTC code modified from EvilRyu by JuliaPoo\n// \t\thttps://www.shadertoy.com/view/4tBBDK\n// Distance functions and softshadow are from inigo quilez\n// \t\thttps://iquilezles.org/articles/rmshadows\n//\t\thttps://iquilezles.org/articles/distfunctions\n\n\n// ###############################\n// ### STRUCTS and other stuff ###\n// ###############################\n\n#define LIGHT_WIDTH 1.\n#define CEIL_HEIGHT 20.\n#define N_LIGHTS 7\n#define END 50.\n\n#define TSCALE 0.5\n\n#define TAO 6.2831853\n#define PI 3.14159\n\n#define UNDEFINED_ID -1\n#define LIGHT_ID 0\n#define CURTAIN_ID 1\n#define FLOOR_ID 2\n\n#define LUTSIZE  8.0\n#define MATRIX_PARAM_OFFSET 8.0\n\n#define ep 0.005\n\nstruct CAM {\n    vec3 lookat;\n    vec3 ro;\n\n    vec3 forw;\n    vec3 up;\n    vec3 right;\n    \n    float field;\n};\n    \nstruct RAY {\n\tvec3 ro;       \n    vec3 rd;\n};\n\n/*\nstruct PETAL {\n    float curve1;\n    float curve2;\n    float curve3;\n    float curve4;\n    float curve5;\n    float wide;\n    float bound;\n    float opt;\n};\n*/    \n\nmat2 rot(float a)\n{\n    float c0 = cos(a);\n    float s0 = sin(a);\n    return mat2(\n        c0,-s0,\n        s0, c0\n    );\n}\n\nstruct LIGHT {\n    vec3 points[4];\n    vec3 col;\n    vec3 pos;\n};\n    \nint OBJ_ID = UNDEFINED_ID;\nLIGHT all_light[N_LIGHTS];\nCAM camera;\nfloat LDIST[N_LIGHTS-1] = float[N_LIGHTS-1](END, END, END, END, END, END);\nbool is_belowfloor = false;\n\n// #############\n// ### SCENE ###\n// #############\n\n// --- Useful Funcs ---\n    \nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n    \n/* well i dont need them for now so\n\nfloat ssub( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat sint( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n*/\n\n// --- PRIMITIVES ---   \n\nfloat sdBox( vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  //p.y -= clamp( p.y, 0.0, h );\n  return length( p.xz ) - r;\n}\n\n// --- Actual shapes ---\n\nfloat sdLightCube(vec3 P)\n{\n    vec3 p = P;\n    p.yz *= rot(-TSCALE*iTime*3.);\n    p.xy *= rot(-TSCALE*iTime);\n    \n    float d = sdBox(p, vec3(LIGHT_WIDTH));\n    return d;\n}\n\nfloat sdLight(vec3 P)\n{\n    float d = min(sdLightCube(P), abs(P.y - CEIL_HEIGHT));\n    return d;\n}\n\nfloat sdRods(vec3 p, float m, float thc)\n{\n    \n    float ang = TAO/m;\n    float a = mod(atan(p.z,p.x), ang) - ang/2.;\n    p.y /= 2.;\n    p.xz = vec2(length(p.xz), 0.) * rot(a);\n    p.y += 3.;\n    p.x += cos(p.y)*3.;\n\tfloat d = sdVerticalCapsule(p, 6., thc);\n    \n    return d*.4;\n}\n\nfloat sdCurtain(vec3 P)\n{\n    \n    float clamp1 = length(P) - 3.5;\n    if (clamp1 > 0.) return clamp1+ep;\n    //float clamp2 = length(P) - 2.;\n    //if (clamp2 < 0.) return END;\n    \n    vec3 p = P;\n    \n    p.yz *= rot(sin(TSCALE*iTime*.7)/4.);\n    float s = sin(TSCALE*iTime) + TSCALE*iTime;\n    p.xz *= rot(s);\n    \n    p.xz *= rot(cos(p.y));\n    float d = sdRods(p, 20., .03);\n    d = smin(d, sdRods(p, 12.36, .05), .1);\n    //d = smin(d, sdRods(p, 7.63, .07), .07);\n    //d = smin(d, sdRods(p, 4.72, .1), .05);\n    \n    return d;\n}\n\nfloat sdFloor(vec3 P)\n{\n    float a = P.y + 3.1;\n    if (abs(a) > .05) return abs(a);\n    return abs(a + texture(iChannel1, P.xz/10.).x*.04)*.8;\n}\n\nfloat sdScene(vec3 P)\n{\n    \n   \tfloat d0 = sdLight(P);\n    float d1 = sdCurtain(P);\n    float d2 = sdFloor(P);\n    \n    float d = d0;\n    OBJ_ID = LIGHT_ID;\n    \n    if (d > d1)\n    {\n        d = d1;\n        OBJ_ID = CURTAIN_ID;\n    }\n    \n    if (d > d2 && !is_belowfloor)\n    {\n        d = d2;\n        OBJ_ID = FLOOR_ID;\n    }\n    \n    return d;\n}\n\n// #################\n// ### RENDERING ###\n// #################\n\n// --- Camera ---\n\nvoid InitCamera(inout CAM c)\n{\n    vec2 M = (iMouse.xy/iResolution.xy - 0.5) * PI;\n    if (length(iMouse.xy) < ep) M = vec2(0., .3);\n    \n    // x,y,z = right, up, forw\n    c.lookat = vec3(0., .5, 0.);\n    \n    c.ro = vec3(0., 0., 9.);\n    c.ro.yz *= rot(M.y);\n    c.ro.xz *= rot(M.x);\n    \n    c.forw = normalize(c.lookat - c.ro);\n    c.right = normalize(cross(c.forw, vec3(0.0, 1.0, 0.0)));\n    c.up = normalize(cross(c.right, c.forw));\n    c.field = 2.;\n}\n\nvoid InitRay(inout RAY r, CAM c, vec2 uv)\n{\n    r.rd = normalize(uv.x*c.right + uv.y*c.up + c.field*c.forw);\n    r.ro = c.ro;\n}\n\nvoid InitLight(inout LIGHT all_light[N_LIGHTS])\n{\n    // These was a pain to type\n    \n    vec3 p0 = vec3( LIGHT_WIDTH, LIGHT_WIDTH, LIGHT_WIDTH);\n    vec3 p1 = vec3(-LIGHT_WIDTH, LIGHT_WIDTH, LIGHT_WIDTH);\n    vec3 p2 = vec3( LIGHT_WIDTH,-LIGHT_WIDTH, LIGHT_WIDTH);\n    vec3 p3 = vec3(-LIGHT_WIDTH,-LIGHT_WIDTH, LIGHT_WIDTH);\n    vec3 p4 = vec3( LIGHT_WIDTH, LIGHT_WIDTH,-LIGHT_WIDTH);\n    vec3 p5 = vec3(-LIGHT_WIDTH, LIGHT_WIDTH,-LIGHT_WIDTH);\n    vec3 p6 = vec3( LIGHT_WIDTH,-LIGHT_WIDTH,-LIGHT_WIDTH);\n    vec3 p7 = vec3(-LIGHT_WIDTH,-LIGHT_WIDTH,-LIGHT_WIDTH);\n    \n    vec3 pp0 = vec3( 0.,-LIGHT_WIDTH, 0.);\n    vec3 pp1 = vec3(-LIGHT_WIDTH, 0., 0.);\n    vec3 pp2 = vec3( 0., 0.,-LIGHT_WIDTH);\n    vec3 pp3 = vec3( 0., 0., LIGHT_WIDTH);\n    vec3 pp4 = vec3( LIGHT_WIDTH, 0., 0.);\n    vec3 pp5 = vec3( 0., LIGHT_WIDTH, 0.);\n    \n    mat2 m1 = rot(TSCALE*iTime);\n    mat2 m2 = rot(TSCALE*iTime*3.);\n    p0.xy *= m1; p0.yz *= m2;\n    p1.xy *= m1; p1.yz *= m2;\n    p2.xy *= m1; p2.yz *= m2;\n    p3.xy *= m1; p3.yz *= m2;\n    p4.xy *= m1; p4.yz *= m2;\n    p5.xy *= m1; p5.yz *= m2;\n    p6.xy *= m1; p6.yz *= m2; \n    p7.xy *= m1; p7.yz *= m2;\n    \n    pp0.xy *= m1; pp0.yz *= m2;\n    pp1.xy *= m1; pp1.yz *= m2;\n    pp2.yz *= m2;\n    pp3.yz *= m2;\n    pp4.xy *= m1; pp4.yz *= m2;\n    pp5.xy *= m1; pp5.yz *= m2;\n    \n    vec3 c = vec3(CEIL_HEIGHT, 10., -10.);\n    \n    all_light = LIGHT[N_LIGHTS](\n        \n        LIGHT(vec3[4](p0, p1, p5, p4), vec3(1., .5, .6), pp5),\n        LIGHT(vec3[4](p1, p0, p2, p3), vec3(.4, 1., .6), pp3),\n        LIGHT(vec3[4](p0, p4, p6, p2), vec3(.3, .4, 1.), pp4),\n        LIGHT(vec3[4](p3, p7, p5, p1), vec3(1., 1., .2), pp1),\n        LIGHT(vec3[4](p4, p5, p7, p6), vec3(.3, 1., 1.), pp2),\n        LIGHT(vec3[4](p2, p6, p7, p3), vec3(1., .4, 1.), pp0),\n        \n        LIGHT(vec3[4](c.yxy, c.yxz, c.zxz, c.zxy), 2.*vec3(.5, .3, .2), vec3(0., 10., 0.))\n        \n    );\n}\n\n// --- Raytracing ---\n\nvec3 get_normal(vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(sdScene(p + e.xyy)-sdScene(p - e.xyy), \n                          sdScene(p + e.yxy)-sdScene(p - e.yxy),\t\n                          sdScene(p + e.yyx)-sdScene(p - e.yyx)));\n}\n\nfloat Intersect(RAY r)\n{\n    float t = 0.01;\n    float ld; vec3 ln;\n    vec3 p;\n    for( int i=0; i<256; i++ )\n    {\n        p = r.ro + r.rd*t;\n        float c = sdScene(p);\n        \n        for (int i = 0; i < N_LIGHTS-1; ++i)\n        {\n            ln = normalize(all_light[i].pos);\n            ld = max(dot(ln, all_light[i].pos) - dot(ln, p), sdLightCube(p));\n            if (ld < LDIST[i]) LDIST[i] = ld;\n        }\n        \n        if( c < ep ) break;\n        t += c;\n        if( t>END ) return END;\n    }\n    return t;\n}\n\n// -- Shading --\n\nfloat IntegrateEdge(vec3 v1, vec3 v2)\n{\n    float cosTheta = dot(v1, v2);\n    float theta = acos(cosTheta);    \n    float res = cross(v1, v2).z * ((theta > 0.001) ? theta/sin(theta) : 1.0);\n\n    return res;\n}\n\nvoid ClipQuadToHorizon(inout vec3 L[5], out int n)\n{\n    // detect clipping config\n    int config = 0;\n    if (L[0].z > 0.0) config += 1;\n    if (L[1].z > 0.0) config += 2;\n    if (L[2].z > 0.0) config += 4;\n    if (L[3].z > 0.0) config += 8;\n\n    // clip\n    n = 0;\n\n    if (config == 0)\n    {\n        // clip all\n    }\n    else if (config == 1) // V1 clip V2 V3 V4\n    {\n        n = 3;\n        L[1] = -L[1].z * L[0] + L[0].z * L[1];\n        L[2] = -L[3].z * L[0] + L[0].z * L[3];\n    }\n    else if (config == 2) // V2 clip V1 V3 V4\n    {\n        n = 3;\n        L[0] = -L[0].z * L[1] + L[1].z * L[0];\n        L[2] = -L[2].z * L[1] + L[1].z * L[2];\n    }\n    else if (config == 3) // V1 V2 clip V3 V4\n    {\n        n = 4;\n        L[2] = -L[2].z * L[1] + L[1].z * L[2];\n        L[3] = -L[3].z * L[0] + L[0].z * L[3];\n    }\n    else if (config == 4) // V3 clip V1 V2 V4\n    {\n        n = 3;\n        L[0] = -L[3].z * L[2] + L[2].z * L[3];\n        L[1] = -L[1].z * L[2] + L[2].z * L[1];\n    }\n    else if (config == 5) // V1 V3 clip V2 V4) impossible\n    {\n        n = 0;\n    }\n    else if (config == 6) // V2 V3 clip V1 V4\n    {\n        n = 4;\n        L[0] = -L[0].z * L[1] + L[1].z * L[0];\n        L[3] = -L[3].z * L[2] + L[2].z * L[3];\n    }\n    else if (config == 7) // V1 V2 V3 clip V4\n    {\n        n = 5;\n        L[4] = -L[3].z * L[0] + L[0].z * L[3];\n        L[3] = -L[3].z * L[2] + L[2].z * L[3];\n    }\n    else if (config == 8) // V4 clip V1 V2 V3\n    {\n        n = 3;\n        L[0] = -L[0].z * L[3] + L[3].z * L[0];\n        L[1] = -L[2].z * L[3] + L[3].z * L[2];\n        L[2] =  L[3];\n    }\n    else if (config == 9) // V1 V4 clip V2 V3\n    {\n        n = 4;\n        L[1] = -L[1].z * L[0] + L[0].z * L[1];\n        L[2] = -L[2].z * L[3] + L[3].z * L[2];\n    }\n    else if (config == 10) // V2 V4 clip V1 V3) impossible\n    {\n        n = 0;\n    }\n    else if (config == 11) // V1 V2 V4 clip V3\n    {\n        n = 5;\n        L[4] = L[3];\n        L[3] = -L[2].z * L[3] + L[3].z * L[2];\n        L[2] = -L[2].z * L[1] + L[1].z * L[2];\n    }\n    else if (config == 12) // V3 V4 clip V1 V2\n    {\n        n = 4;\n        L[1] = -L[1].z * L[2] + L[2].z * L[1];\n        L[0] = -L[0].z * L[3] + L[3].z * L[0];\n    }\n    else if (config == 13) // V1 V3 V4 clip V2\n    {\n        n = 5;\n        L[4] = L[3];\n        L[3] = L[2];\n        L[2] = -L[1].z * L[2] + L[2].z * L[1];\n        L[1] = -L[1].z * L[0] + L[0].z * L[1];\n    }\n    else if (config == 14) // V2 V3 V4 clip V1\n    {\n        n = 5;\n        L[4] = -L[0].z * L[3] + L[3].z * L[0];\n        L[0] = -L[0].z * L[1] + L[1].z * L[0];\n    }\n    else if (config == 15) // V1 V2 V3 V4\n    {\n        n = 4;\n    }\n    \n    if (n == 3)\n        L[3] = L[0];\n    if (n == 4)\n        L[4] = L[0];\n}\n\n\nvec3 LTC_Evaluate(vec3 N, vec3 V, vec3 P, mat3 Minv, vec3 points[4])\n{\n    vec3 T1, T2;\n    T1 = normalize(V - N*dot(V, N));\n    T2 = cross(N, T1);\n\n    Minv = Minv * transpose(mat3(T1, T2, N));\n\n    vec3 L[5];\n    L[0] = Minv * (points[0] - P);\n    L[1] = Minv * (points[1] - P);\n    L[2] = Minv * (points[2] - P);\n    L[3] = Minv * (points[3] - P);\n\n    int n=0;\n    ClipQuadToHorizon(L, n);\n    \n    if (n == 0)\n        return vec3(0, 0, 0);\n\n    L[0] = normalize(L[0]);\n    L[1] = normalize(L[1]);\n    L[2] = normalize(L[2]);\n    L[3] = normalize(L[3]);\n    L[4] = normalize(L[4]);\n\n    float sum = 0.0;\n\n    sum += IntegrateEdge(L[0], L[1]);\n    sum += IntegrateEdge(L[1], L[2]);\n    sum += IntegrateEdge(L[2], L[3]);\n    if (n >= 4)\n        sum += IntegrateEdge(L[3], L[4]);\n    if (n == 5)\n        sum += IntegrateEdge(L[4], L[0]);\n\n    sum =  max(0.0, sum);\n\n    vec3 Lo_i = vec3(sum);\n\n    return Lo_i;\n}\n\n\nfloat shadow( in RAY r, float w )\n{\n    float t = 0.01;\n    float c = 0.;\n    float s = 1.;\n    for( int i=0; i<256; i++ )\n    {\n        vec3 p = r.ro + r.rd*t;\n        c = min(sdCurtain(p), sdLight(p));\n        s = min( s, 0.5+0.5*c/(w*t) );\n        if( c < ep) break;\n        t += c;\n        if( t > END ) break;\n    }\n    \n    s = min(max(s,0.0), 1.);\n    s = s*s*(3.0-2.0*s);\n    \n    return 1. - s;\n}\n\nvoid LTC_shading(float roughness, \n                 vec3 N, \n                 vec3 V, \n                 vec3 pos, \n                 vec3 m_spec, \n                 vec3 m_diff,\n                 LIGHT light,\n                 inout vec3 col)\n{\n    \n    \n    float theta = acos(dot(N, V));\n    vec2 uv = vec2(roughness, theta/(0.5*PI)) * float(LUTSIZE-1.);   \n    vec2 wx = uv/iChannelResolution[0].xy;\n            \n    uv += vec2(0.5);\n\n    vec4 params = texture(iChannel0, (uv+vec2(MATRIX_PARAM_OFFSET, 0.0))/iChannelResolution[0].xy);\n\n    mat3 Minv = mat3(\n        vec3(  1,        0,      params.y),\n        vec3(  0,     params.z,   0),\n        vec3(params.w,   0,      params.x)\n    );\n\n    vec3 spec = LTC_Evaluate(N, V, pos, Minv, light.points)*m_spec;\n\n    spec *= texture(iChannel0, uv/iChannelResolution[0].xy).x;\n\n    vec3 diff = LTC_Evaluate(N, V, pos, mat3(1), light.points)*m_diff; \n\n    RAY r = RAY(pos+.1*N, normalize(light.pos-pos));\n    float sha = shadow( r, .008 );\n\n    vec3 col0  = light.col * (m_spec*spec + m_diff*diff)*sha;\n    col0 /= 2.0*PI;\n    \n    // Some inaccuracy but it looks nicer so.\n    col += col0*2.;\n}\n\nvec3 Render(vec2 uv)\n{\n    \n    if (camera.ro.y < -3.1) is_belowfloor = true;\n    \n    RAY ray;\n    \n    InitLight(all_light);\n    InitRay(ray, camera, uv);\n    \n    float d = Intersect(ray);\n    vec3 P = d*ray.rd + ray.ro;\n    vec3 N = get_normal(P);\n    vec3 V = -ray.rd;\n    \n    vec3 n;\n    vec3 col = vec3(0);\n    \n    float roughness;\n    vec3 spec;\n    vec3 diff;\n    \n    for (int i = 0; i < N_LIGHTS-1; ++i)\n    {\n        // Add cheap af fog\n        col += pow(clamp(abs(1./LDIST[i])*0.03, 0., .5), .8)*all_light[i].col*.5;\n    }\n    \n    if (d == END || abs(P.y - CEIL_HEIGHT) < ep)\n    {\n        P = END*ray.rd + ray.ro;\n        float grad = P.y/(END);\n        col += vec3(grad*grad) *  2.*vec3(.5, .3, .2);\n        return col;\n    }\n    \n    if (OBJ_ID == CURTAIN_ID) \n    {\n        roughness = .3;\n        diff = vec3(1.);\n        spec = vec3(1.); \n    }\n    \n  \tif (OBJ_ID == FLOOR_ID)\n    {\n        roughness = 1. - texture(iChannel1, P.xz/10.).x - .1;\n        diff = vec3(1.);\n        spec = vec3(1.); \n    }\n    \n    if (OBJ_ID == LIGHT_ID)\n    {\n        \n        float ld;\n     \tfor (int i = 0; i < N_LIGHTS-1; ++i)\n        {\n            vec3 ln = normalize(all_light[i].pos);\n            ld = dot(ln, all_light[i].pos) - dot(ln, P);\n            if (ld < ep)\n            {\n                col += all_light[i].col;\n                return col;\n            }\n        }\n    }\n    \n    for (int i = 0; i < N_LIGHTS; ++i)\n    {\n    \tLTC_shading(roughness, N, V, P, diff, spec, all_light[i], col);\n    }\n    \n    \n    return col;\n}\n\n// #######################\n// ### POST PROCESSING ###\n// #######################\n\nvoid PostProcessing(inout vec3 col)\n{\n\tcol = pow(col, vec3(1.3));\n    col *= vec3(1.2,1.,1.);\n}\n\n// ############\n// ### MAIN ###\n// ############\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = -1.0 + 2.0 * uv;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    InitCamera(camera);\n    vec3 col = Render(uv);\n    \n    PostProcessing(col);\n    \n    fragColor = vec4(col,1.0);\n}\n\nvoid mainVR(out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir)\n{\n \tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = -1. + 4.0 * uv;\n    uv.x *= iResolution.x/iResolution.y;\n    uv.y -= .4;\n    \n    \n    // x,y,z = right, up, forw\n    vec2 M = (iMouse.xy/iResolution.xy - 0.5) * PI;\n    if (length(iMouse.xy) < ep) M = vec2(0., .3);\n    \n    camera.lookat = vec3(0., -.4, 0.) + fragRayOri;\n    camera.ro = vec3(0., .5, 6.) + fragRayDir;\n    camera.ro.zy *= rot(M.y);\n    camera.ro.xz *= rot(M.x);\n    camera.forw = normalize(camera.lookat - camera.ro);\n    camera.right = normalize(cross(camera.forw, vec3(0.0, 1.0, 0.0)));\n    camera.up = normalize(cross(camera.right, camera.forw));\n    camera.field = 2.;\n    \n    vec3 col = Render(uv);\n    \n    PostProcessing(col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// LTC code modified from EvilRyu by JuliaPoo\n// https://www.shadertoy.com/view/4tBBDK\n\n#define P fragCoord\n#define C fragColor\n#define v vec2\n#define V vec4\n#define B 8.\n\nvoid s(v pos, V val, v P, inout V C)\n{\n    if(abs(P.x-pos.x)<0.01&&abs(P.y-pos.y)<0.01)\n        C=val;\n}\n\nvoid setLUT(v P, inout V C)\n{\n    s(v(0.5, 0.5), V(1.000000), P, C);\n    s(v(1.5, 0.5), V(1.000000), P, C);\n    s(v(2.5, 0.5), V(0.999138), P, C);\n    s(v(3.5, 0.5), V(0.953919), P, C);\n    s(v(4.5, 0.5), V(0.855017), P, C);\n    s(v(5.5, 0.5), V(0.677721), P, C);\n    s(v(6.5, 0.5), V(0.475624), P, C);\n    s(v(7.5, 0.5), V(0.306905), P, C);\n    s(v(0.5, 1.5), V(1.000000), P, C);\n    s(v(1.5, 1.5), V(0.999990), P, C);\n    s(v(2.5, 1.5), V(0.995492), P, C);\n    s(v(3.5, 1.5), V(0.955938), P, C);\n    s(v(4.5, 1.5), V(0.852346), P, C);\n    s(v(5.5, 1.5), V(0.676815), P, C);\n    s(v(6.5, 1.5), V(0.478562), P, C);\n    s(v(7.5, 1.5), V(0.311751), P, C);\n    s(v(0.5, 2.5), V(1.000000), P, C);\n    s(v(1.5, 2.5), V(0.999952), P, C);\n    s(v(2.5, 2.5), V(0.993337), P, C);\n    s(v(3.5, 2.5), V(0.950365), P, C);\n    s(v(4.5, 2.5), V(0.844905), P, C);\n    s(v(5.5, 2.5), V(0.674537), P, C);\n    s(v(6.5, 2.5), V(0.487632), P, C);\n    s(v(7.5, 2.5), V(0.327273), P, C);\n    s(v(0.5, 3.5), V(1.000000), P, C);\n    s(v(1.5, 3.5), V(0.999865), P, C);\n    s(v(2.5, 3.5), V(0.991766), P, C);\n    s(v(3.5, 3.5), V(0.942684), P, C);\n    s(v(4.5, 3.5), V(0.831852), P, C);\n    s(v(5.5, 3.5), V(0.673589), P, C);\n    s(v(6.5, 3.5), V(0.505564), P, C);\n    s(v(7.5, 3.5), V(0.355949), P, C);\n    s(v(0.5, 4.5), V(1.000000), P, C);\n    s(v(1.5, 4.5), V(0.999665), P, C);\n    s(v(2.5, 4.5), V(0.986371), P, C);\n    s(v(3.5, 4.5), V(0.930421), P, C);\n    s(v(4.5, 4.5), V(0.813602), P, C);\n    s(v(5.5, 4.5), V(0.678975), P, C);\n    s(v(6.5, 4.5), V(0.537882), P, C);\n    s(v(7.5, 4.5), V(0.403271), P, C);\n    s(v(0.5, 5.5), V(1.000000), P, C);\n    s(v(1.5, 5.5), V(0.999025), P, C);\n    s(v(2.5, 5.5), V(0.973317), P, C);\n    s(v(3.5, 5.5), V(0.900245), P, C);\n    s(v(4.5, 5.5), V(0.804126), P, C);\n    s(v(5.5, 5.5), V(0.703751), P, C);\n    s(v(6.5, 5.5), V(0.594890), P, C);\n    s(v(7.5, 5.5), V(0.481143), P, C);\n    s(v(0.5, 6.5), V(1.000000), P, C);\n    s(v(1.5, 6.5), V(0.992850), P, C);\n    s(v(2.5, 6.5), V(0.926124), P, C);\n    s(v(3.5, 6.5), V(0.860745), P, C);\n    s(v(4.5, 6.5), V(0.833379), P, C);\n    s(v(5.5, 6.5), V(0.782873), P, C);\n    s(v(6.5, 6.5), V(0.703637), P, C);\n    s(v(7.5, 6.5), V(0.620129), P, C);\n    s(v(0.5, 7.5), V(0.987461), P, C);\n    s(v(1.5, 7.5), V(0.938899), P, C);\n    s(v(2.5, 7.5), V(0.942983), P, C);\n    s(v(3.5, 7.5), V(0.943682), P, C);\n    s(v(4.5, 7.5), V(0.943818), P, C);\n    s(v(5.5, 7.5), V(0.943681), P, C);\n    s(v(6.5, 7.5), V(0.943351), P, C);\n    s(v(7.5, 7.5), V(0.942877), P, C);\n\n    s(v(B+0.5, 0.5), V(0.000200, -0.000000, 1.000000, -0.000000), P, C);\n    s(v(B+1.5, 0.5), V(0.040821, -0.000000, 1.000000, -0.000000), P, C);\n    s(v(B+2.5, 0.5), V(0.163499, -0.000000, 1.000000, -0.000000), P, C);\n    s(v(B+3.5, 0.5), V(0.359810, -0.000000, 1.000000, -0.000000), P, C);\n    s(v(B+4.5, 0.5), V(0.608219, -0.000000, 1.000000, -0.000000), P, C);\n    s(v(B+5.5, 0.5), V(0.849327, -0.000000, 1.000000, -0.000000), P, C);\n    s(v(B+6.5, 0.5), V(1.026876, -0.000000, 1.000000, -0.000000), P, C);\n    s(v(B+7.5, 0.5), V(1.127918, -0.000000, 1.000000, -0.000000), P, C);\n    s(v(B+0.5, 1.5), V(0.000200, -0.000046, 1.052217, 0.228243), P, C);\n    s(v(B+1.5, 1.5), V(0.040821, -0.009316, 1.052066, 0.228242), P, C);\n    s(v(B+2.5, 1.5), V(0.163218, -0.036566, 1.051517, 0.228141), P, C);\n    s(v(B+3.5, 1.5), V(0.360871, -0.077435, 1.049110, 0.226851), P, C);\n    s(v(B+4.5, 1.5), V(0.608870, -0.112986, 1.040456, 0.216178), P, C);\n    s(v(B+5.5, 1.5), V(0.850681, -0.110371, 1.022363, 0.171798), P, C);\n    s(v(B+6.5, 1.5), V(1.033758, -0.063836, 1.011022, 0.089896), P, C);\n    s(v(B+7.5, 1.5), V(1.130218, 0.000062, 1.000010, -0.000080), P, C);\n    s(v(B+0.5, 2.5), V(0.000200, -0.000096, 1.232269, 0.481573), P, C);\n    s(v(B+1.5, 2.5), V(0.040829, -0.019653, 1.232083, 0.481559), P, C);\n    s(v(B+2.5, 2.5), V(0.163323, -0.077152, 1.229494, 0.481157), P, C);\n    s(v(B+3.5, 2.5), V(0.361362, -0.161748, 1.215935, 0.476966), P, C);\n    s(v(B+4.5, 2.5), V(0.602530, -0.224893, 1.149731, 0.444834), P, C);\n    s(v(B+5.5, 2.5), V(0.832866, -0.211716, 1.066321, 0.339254), P, C);\n    s(v(B+6.5, 2.5), V(1.033638, -0.123274, 1.025543, 0.170803), P, C);\n    s(v(B+7.5, 2.5), V(1.137644, 0.000154, 0.999953, -0.000082), P, C);\n    s(v(B+0.5, 3.5), V(0.000199, -0.000159, 1.627474, 0.797472), P, C);\n    s(v(B+1.5, 3.5), V(0.040836, -0.032524, 1.635685, 0.797401), P, C);\n    s(v(B+2.5, 3.5), V(0.164108, -0.127318, 1.628042, 0.795956), P, C);\n    s(v(B+3.5, 3.5), V(0.365844, -0.258932, 1.575327, 0.783120), P, C);\n    s(v(B+4.5, 3.5), V(0.602895, -0.339455, 1.372632, 0.710306), P, C);\n    s(v(B+5.5, 3.5), V(0.825683, -0.302224, 1.158343, 0.512880), P, C);\n    s(v(B+6.5, 3.5), V(1.030563, -0.173519, 1.049980, 0.243539), P, C);\n    s(v(B+7.5, 3.5), V(1.151713, 0.000105, 0.999957, -0.000055), P, C);\n    s(v(B+0.5, 4.5), V(0.000198, -0.000248, 2.529443, 1.253956), P, C);\n    s(v(B+1.5, 4.5), V(0.040880, -0.051100, 2.570697, 1.253684), P, C);\n    s(v(B+2.5, 4.5), V(0.166706, -0.198049, 2.542881, 1.248409), P, C);\n    s(v(B+3.5, 4.5), V(0.380361, -0.384441, 2.334701, 1.206127), P, C);\n    s(v(B+4.5, 4.5), V(0.617299, -0.459699, 1.772357, 1.025249), P, C);\n    s(v(B+5.5, 4.5), V(0.835445, -0.380695, 1.304201, 0.680722), P, C);\n    s(v(B+6.5, 4.5), V(1.040850, -0.213042, 1.089431, 0.306573), P, C);\n    s(v(B+7.5, 4.5), V(1.176060, 0.000010, 1.000023, -0.000021), P, C);\n    s(v(B+0.5, 5.5), V(0.000187, -0.000388, 4.301116, 2.076506), P, C);\n    s(v(B+1.5, 5.5), V(0.041070, -0.084546, 5.305590, 2.075270), P, C);\n    s(v(B+2.5, 5.5), V(0.175521, -0.321638, 5.161014, 2.051541), P, C);\n    s(v(B+3.5, 5.5), V(0.413187, -0.560077, 4.055352, 1.869406), P, C);\n    s(v(B+4.5, 5.5), V(0.665130, -0.580464, 2.432246, 1.376237), P, C);\n    s(v(B+5.5, 5.5), V(0.870094, -0.441204, 1.506300, 0.819691), P, C);\n    s(v(B+6.5, 5.5), V(1.068578, -0.241436, 1.137736, 0.354430), P, C);\n    s(v(B+7.5, 5.5), V(1.219174, -0.000534, 1.000063, 0.000162), P, C);\n    s(v(B+0.5, 6.5), V(0.000144, -0.000631, 6.468958, 4.381222), P, C);\n    s(v(B+1.5, 6.5), V(0.042200, -0.177353, 20.085962, 4.369584), P, C);\n    s(v(B+2.5, 6.5), V(0.209979, -0.606367, 16.868328, 4.106197), P, C);\n    s(v(B+3.5, 6.5), V(0.500901, -0.795643, 8.099620, 2.893355), P, C);\n    s(v(B+4.5, 6.5), V(0.769693, -0.688227, 3.439625, 1.659662), P, C);\n    s(v(B+5.5, 6.5), V(0.955036, -0.470746, 1.760819, 0.883184), P, C);\n    s(v(B+6.5, 6.5), V(1.134532, -0.254869, 1.190455, 0.377490), P, C);\n    s(v(B+7.5, 6.5), V(1.308330, -0.002944, 0.999844, 0.001275), P, C);\n    s(v(B+0.5, 7.5), V(0.000102, -0.118482, 1184.816772, 1184.816284), P, C);\n    s(v(B+1.5, 7.5), V(0.319603, -3.097308, 7133.888672, 23.645655), P, C);\n    s(v(B+2.5, 7.5), V(0.546638, -1.442077, 133.966263, 8.593670), P, C);\n    s(v(B+3.5, 7.5), V(0.837342, -1.129903, 20.226521, 3.658263), P, C);\n    s(v(B+4.5, 7.5), V(1.004258, -0.809128, 5.700182, 1.768790), P, C);\n    s(v(B+5.5, 7.5), V(1.117055, -0.531464, 2.269246, 0.923613), P, C);\n    s(v(B+6.5, 7.5), V(1.336692, -0.312752, 1.241618, 0.414403), P, C);\n    s(v(B+7.5, 7.5), V(1.670654, -0.056394, 0.998759, 0.033416), P, C);\n}\n\nvoid mainImage( out V C, in v P )\n{\n    V lastFrame = texture(iChannel0, v(.5));\n\n    if (lastFrame.a != 0. && iFrame > 2) {\n        C = lastFrame;\n        return;\n    }\n\n    if( P.x > 16. || P.y > 8. ) discard;\n\tsetLUT(P, C);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjyDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[986, 986, 1005, 1005, 1108], [1432, 1432, 1473, 1473, 1557], [1921, 1921, 1951, 1951, 2038], [2040, 2040, 2093, 2126, 2157], [2185, 2185, 2212, 2212, 2359], [2361, 2361, 2384, 2384, 2459], [2461, 2461, 2503, 2503, 2743], [2745, 2745, 2770, 2770, 3281], [3283, 3283, 3306, 3306, 3429], [3431, 3431, 3454, 3454, 3781], [3866, 3866, 3896, 3896, 4324], [4326, 4326, 4369, 4369, 4453], [4455, 4455, 4504, 4536, 6359], [6384, 6384, 6409, 6409, 6639], [6641, 6641, 6665, 6665, 7165], [7185, 7185, 7224, 7224, 7393], [7395, 7395, 7447, 7477, 10129], [10132, 10132, 10202, 10202, 11045], [11048, 11048, 11083, 11083, 11453], [11455, 11455, 11695, 11695, 12594], [12596, 12596, 12618, 12618, 14138], [14222, 14222, 14259, 14259, 14317], [14368, 14368, 14425, 14425, 14666], [14668, 14668, 14760, 14760, 15503]], "test": "untested"}
{"id": "Ws2cD3", "name": "glsl_practice2", "author": "bigdra50", "description": "glsl practice", "tags": ["practice"], "likes": 0, "viewed": 246, "published": 3, "date": "1587443951", "time_retrieved": "2024-07-30T21:11:25.072076", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = ((fragCoord.xy / iResolution.xy)-.5)*2.;\t// 0 ~ 1 -> -1 ~ 1\n\n    float d = length(pos);\n    vec3 col = vec3(1.-d*sin(iTime*2.5), 1.-d*sin(iTime*3.)+.3, 1.-d*sin(iTime*2.) - .2);\n\n    fragColor = vec4(abs(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2cD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 290]], "test": "untested"}
{"id": "WdjcW3", "name": "Chaotic standard map", "author": "Roninkoi", "description": "Standard map from chaos theory with varying K.", "tags": ["map", "chaos", "standard", "standardmap"], "likes": 5, "viewed": 463, "published": 3, "date": "1587436724", "time_retrieved": "2024-07-30T21:11:25.830049", "image_code": "#define PI 3.14159265\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float x0 = uv.x * 2. * PI;\n    float p0 = uv.y * 2. * PI;\n    \n    float k = sin(iTime * 0.2) + 1.0;\n    \n    float p = p0;\n    float x = x0;\n    \n    for (int i = 0; i < 50; ++i) {\n    \tp = mod(p + k * sin(x), 2. * PI);\n    \tx = mod(x + p, 2. * PI);\n    }\n    \n    float q = abs(p - p0);\n    \n    vec3 col = vec3(\n        sin(q), sin(q + PI / 3.), sin(q + 2. * (PI / 3.))\n    );\n    \n    fragColor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdjcW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 78, 78, 547]], "test": "untested"}
{"id": "wdSyD3", "name": "Clouds on Jupiter", "author": "jarble", "description": "This is an edit of my [url=https://www.shadertoy.com/view/3sBcD3]\"Kaleidoscopic Lava\"[/url] shader.", "tags": ["fractal", "clouds", "jupiter"], "likes": 4, "viewed": 385, "published": 3, "date": "1587414676", "time_retrieved": "2024-07-30T21:11:26.590018", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 15.0;\nconst float distortion_scale = mag*mag;\n\nconst int GREEN = 0;\nconst int BLUE = 1;\nconst int GRAY = 2;\nconst int YELLOW = 3;\nconst int WHITE = 4;\nconst int FOREST_GREEN = 5;\nconst int LIGHTBLUE = 6;\nconst int SKYBLUE = 7;\nconst int SNOW = 8;\nconst int WHITESMOKE = 9;\nconst int LIGHTGRAY = 10;\nconst int LIME = 11;\nconst int LIGHTYELLOW = 12;\nconst int BEIGE = 13;\nconst int SAND = 14;\nconst int TAN = 15;\nconst int ORANGE = 16;\nconst int RED = 17;\nconst int BLACK = 18;\nconst int DARKGRAY = 19;\nconst int ORANGERED = 20;\n\nconst int SWAMP_BIOME = 1;\nconst int GLACIER_BIOME = 2;\nconst int FORESTS_AND_MOUNTAINS = 3;\nconst int SAVANNA_BIOME = 4;\nconst int FOREST_BIOME = 5;\n\n//this function is from https://www.shadertoy.com/view/4djSRW\nint hash12(vec2 p,float num_colors)\n{\n    //set the number of colors to be randomly generated\n    p = sin(p.xx-p.yy);\n    vec3 p3 = (vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return int(floor(fract((p3.x + p3.y) * p3.z)*num_colors));\n}\n    \nint magnify(vec2 fragCoord,float mag,float num_colors){\n    //fragCoord += vec2(sin(fragCoord.y/(distortion_scale*mag)+iTime),sin(fragCoord.x/(distortion_scale*mag)+iTime))*10.0*mag*mag;\n\n    return hash12(floor(fragCoord/pow(3.0,mag)),num_colors);\n}\n\nivec4 get_neighbors(vec2 fragCoord,float mag,float colors){\n\treturn ivec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\n\nbool is_next_to(int color,ivec4 neighbors){\n\treturn (neighbors.x == color)\n        || (neighbors.y == color)\n        || (neighbors.z == color)\n        || (neighbors.w == color);\n}\n\nvec3 rgb(float r,float g,float b){\n\treturn vec3(r,g,b)/255.0;\n}\n\nvec3 get_color(int color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == FOREST_GREEN){\n    \treturn rgb(34.0,139.0,34.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n    else if(color == LIGHTBLUE){\n    \treturn rgb(173.0,216.0,230.0);\n   \t}\n    else if(color == SKYBLUE){\n    \treturn rgb(135.0,206.0,235.0);\n    }\n    else if(color == SNOW){\n    \treturn rgb(255.0,250.0,250.0);\n    }\n    else if(color == WHITESMOKE){\n    \treturn rgb(245.0,245.0,245.0);\n    }\n    else if(color == LIGHTGRAY){\n    \treturn rgb(211.0,211.0,211.0);\n    }\n    else if(color == LIME){\n    \treturn rgb(0.0,255.0,0.0);\n    }\n    else if(color == LIGHTYELLOW){\n    \treturn rgb(255.0,255.0,153.0);\n    }\n    else if(color == BEIGE){\n    \treturn rgb(245.0,245.0,220.0);\n    }\n    else if(color == TAN){\n    \treturn rgb(210.,180.,140.);\n    }\n    else if(color == ORANGE){\n    \treturn vec3(255,127,80)/255.0;\n    }\n    else if(color == RED){\n    \treturn vec3(1.0,0.0,0.0);\n   \t}\n    else if(color == DARKGRAY){\n    \treturn rgb(128.0,128.0,128.0);\n    }\n    else if(color == ORANGERED){\n    \treturn rgb(255.0,69.0,0.0);\n    }\n}\n\n\nint glacier_biome(inout int color1, ivec4 neighbors){\n\tint GREEN = 0;\n    int BLUE = 1;\n    int GRAY = 2;\n    int WHITE = 3;\n    int YELLOW = 4;\n    \n    return (color1 == GREEN && is_next_to(BLUE,neighbors))\n        ? GRAY\n    : (color1 == GREEN && is_next_to(WHITE,neighbors))\n        ? GRAY\n    : (color1 == BLUE && is_next_to(GREEN,neighbors))\n        ? WHITE\n    : (color1 == YELLOW && is_next_to(GREEN,neighbors))\n        ? GRAY\n    : (color1 == YELLOW && is_next_to(GRAY,neighbors))\n        ? BLUE\n    :(color1 == WHITE && is_next_to(YELLOW,neighbors))\n        ? GRAY\n    :(color1 == YELLOW && is_next_to(WHITE,neighbors))\n        ? WHITE\n    :(color1 == GRAY && is_next_to(BLUE,neighbors))\n        ? BLUE\n    :color1;\n}\n\nvoid biome(inout int color1, ivec4 neighbors,int biome){\n    color1 =\n        glacier_biome(color1,neighbors);\n}\n\nvec3 biome(in vec2 fragCoord,float mag,float zoom,int colors[5],int biome1){\n    fragCoord *= zoom;\n    fragCoord += vec2(sin(fragCoord.y/(distortion_scale*mag)+iTime),sin(fragCoord.x/(distortion_scale*mag)+iTime))*10.0*mag*mag;\n\n    float num_colors = float(colors.length());\n\n    int color1 = magnify(fragCoord,mag,num_colors);\n\n    \n    ivec4 neighbors;\n    vec3 color;\n    float steps = 0.0;\n    while(mag > 1.0){\n        float avg =(100.0*(mag/float(color1)));\n        fragCoord += vec2(sin(fragCoord.y/avg+iTime)*10.0,sin(fragCoord.x/avg+iTime)*10.0)*mag*mag;\n\n    neighbors = get_neighbors(fragCoord,mag,num_colors);\n    biome(color1, neighbors,biome1);\n    mag -= 1.0;\n    steps += 1.0;\n    color += get_color(colors[int(color1)]);\n\n    }\n\n    return color/steps;\n}\n\n\nvec3 glacier_biome(in vec2 fragCoord,float mag,float zoom,int[5] colors){\n    return biome(fragCoord,mag,zoom,colors,GLACIER_BIOME);\n}\n\nvec3 lava_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn glacier_biome(fragCoord,mag,zoom,int[](DARKGRAY,YELLOW,ORANGERED,ORANGE,ORANGERED));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = mag;\n    fragCoord *= zoom*(((iMouse.x-iMouse.y)*2.0+iResolution.x)/iResolution.x);\n    fragCoord = fragCoord + floor(iTime*100.0)*vec2(zoom,0.0);\n    \n\tvec3 biome = lava_biome(fragCoord,mag,1.0);\n    \n    fragColor = vec4(biome,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSyD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[742, 804, 841, 897, 1058], [1064, 1064, 1119, 1250, 1314], [1316, 1316, 1375, 1375, 1580], [1583, 1583, 1626, 1626, 1762], [1764, 1764, 1798, 1798, 1827], [1829, 1829, 1855, 1855, 3212], [3215, 3215, 3268, 3268, 3942], [3944, 3944, 4000, 4000, 4056], [4058, 4058, 4134, 4134, 4831], [5124, 5124, 5181, 5181, 5435]], "test": "untested"}
{"id": "wdjyWV", "name": "Font SDF fun", "author": "TekF", "description": "Use mouse to move camera (works when paused).", "tags": ["font"], "likes": 11, "viewed": 514, "published": 3, "date": "1587414470", "time_retrieved": "2024-07-30T21:11:27.439745", "image_code": "// Font SDF Fun\n\n// The MIT License\n// Copyright © 2020 Hazel Quantock\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n//vec4 bgTint = vec4(1); vec4 fgTint = vec4(1);\nvec4 bgTint = vec4(.1,.3,1,1); vec4 fgTint = vec4(1,.9,.2,1); // retro game-show colours!\n\n\n// use better filtering to clean up the font texture, so I can get cleaner isosurfaces which I can use for fancy effects\n\n// bicubic filter by IQ\nvec4 BS_A = vec4(   3.0,  -6.0,   0.0,  4.0 ) /  6.0;\nvec4 BS_B = vec4(  -1.0,   6.0, -12.0,  8.0 ) /  6.0;\nvec4 RE_A = vec4(  21.0, -36.0,   0.0, 16.0 ) / 18.0;\nvec4 RE_B = vec4(  -7.0,  36.0, -60.0, 32.0 ) / 18.0;\nvec4 CR_A = vec4(   3.0,  -5.0,   0.0,  2.0 ) /  2.0;\nvec4 CR_B = vec4(  -1.0,   5.0,  -8.0,  4.0 ) /  2.0;\n        \nvec4 powers( float x ) { return vec4(x*x*x, x*x, x, 1.0); }\n\nvec4 ca, cb;\n\nvec4 spline( float x, vec4 c0, vec4 c1, vec4 c2, vec4 c3 )\n{\n    // We could expand the powers and build a matrix instead (twice as many coefficients\n    // would need to be stored, but it could be faster.\n    return c0 * dot( cb, powers(x + 1.0)) + \n           c1 * dot( ca, powers(x      )) +\n           c2 * dot( ca, powers(1.0 - x)) +\n           c3 * dot( cb, powers(2.0 - x));\n}\n\n// I've removed the +0.5 so it samples between the pixels, effectively adding a 2x2 box filter\n// this improves the precision of the distance field value, which otherwise have really bad stepping\n// this helps, but diagonal lines still look a bit wobbly\n#define SAM(a,b)  texture(iChannel0, (i+vec2(float(a),float(b)) /*+0.5*/)/res, -99.0)\n\nvec4 texture_Bicubic( sampler2D tex, vec2 t )\n{\n    vec2 res = iChannelResolution[0].xy;\n    vec2 p = res*t - 0.5;\n    vec2 f = fract(p);\n    vec2 i = floor(p);\n\n    return spline( f.y, spline( f.x, SAM(-1,-1), SAM( 0,-1), SAM( 1,-1), SAM( 2,-1)),\n                        spline( f.x, SAM(-1, 0), SAM( 0, 0), SAM( 1, 0), SAM( 2, 0)),\n                        spline( f.x, SAM(-1, 1), SAM( 0, 1), SAM( 1, 1), SAM( 2, 1)),\n                        spline( f.x, SAM(-1, 2), SAM( 0, 2), SAM( 1, 2), SAM( 2, 2)));\n}\n\nvec4 SmoothTexture( sampler2D tex, vec2 uv )\n{\n    // bilinear\n//    return texture( tex, uv );\n    \n    // bicubic\n    \n    //ca=RE_A; cb=RE_B;\n    //ca=CR_A; cb=CR_B;\n    ca=BS_A; cb=BS_B; // this gives the smoothest result\n\n    return texture_Bicubic( tex, uv );\n}\n\nfloat LetterSDF( vec3 pos, int letter, int seed )\n{\n    // animate parameters\n    vec4 quasi4 = vec4( 0.856674883854, 0.733891856627, 0.628706721038, 0.538597257224 );\n    vec4 rand = fract(quasi4*float(seed));\n    \n    float rounding = mix( .0, .2, rand.z*rand.z );\n    float thickness = max(rounding, mix( .05, .2, rand.y*rand.y ) );\n    float fatness = .1*rand.x-.02;\n    \n    // letter SDF with bounds\n    vec2 fontuv = pos.xy;\n    fontuv += vec2( letter&15, (letter>>4)&15 );\n    fontuv = (fontuv+.5)/16.;//+.5;\n    float boundValue = .15;\n    float f = boundValue + max(abs(pos.x),abs(pos.y)) - .5;\n    if ( f < boundValue )\n    {\n    \tvec4 font = SmoothTexture( iChannel0, fontuv );\n    \tf = min( boundValue, (font.w - .5) );\n    }\n    \n    f = (f - fatness + rounding)*1.0; // value tuned to make 45 degree angles look right\n\n    if ( rand.w > .5 )\n    {\n        // hard bevel\n        f = max( f, (abs(pos.z)-.13*(rand.w*2.-1.)+f)*.7071 );\n        f = max( f, abs(pos.z)-.13 );\n    }\n    else\n    {\n        // smooth curve\n        float o = abs(pos.z)-thickness+rounding;\n        if ( f > .0 && o > .0 ) f = length(vec2(f,o));\n        else f = max( f, o );\n        f -= rounding;\n    }\n        \n    return f\n        * 1.; // reduce this if there's artefacts from stepping near bounds (e.g. bottom of \"g\")\n}\n\n\nvec4 Sky( vec3 ray, float blur )\n{\n    // rotate BG\n    ray.xz = -ray.zx*sqrt(3./4.) + sqrt(1./4.)*vec2(-1,1)*ray.xz;\n\treturn textureLod( iChannel1, ray, blur*8. );\n}\n\n\nconst float tau = 6.283185;\n\nvec3 SphereRand( int seed )\n{\n\t// quasirandom numbers based on http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n\t// expressed as fractions of 1<<32, so I get maximum precision and implicitly wrap them by overflowing the uint\n\tconst uvec2 quasi2 = uvec2( 3242174889, 2447445413 );\n\n    vec2 rand = vec2(quasi2*uint(seed+0x80000000))/exp2(32.);\n    \n    float height = rand.x * 2.-1.;\n    float angle = rand.y * tau;\n    \n    return vec3( height, sqrt(1.-height*height)*vec2( cos(angle),sin(angle) ) );\n}\n\n\n// quaternion maths\nvec4 AxisRotToQuat( vec3 axis, float angle )\n{\n    return vec4( axis*sin(angle/2.), cos(angle/2.) );\n}\n\nvec4 MulQ( vec4 a, vec4 b )\n{\n\treturn\n        vec4(\n        \t  a.x*b.w + a.y*b.z - a.z*b.y + a.w*b.x,\n        \t- a.x*b.z + a.y*b.w + a.z*b.x + a.w*b.y,\n        \t  a.x*b.y - a.y*b.x + a.z*b.w + a.w*b.z,\n        \t- a.x*b.x - a.y*b.y - a.z*b.z + a.w*b.w\n        );\n}\n\nvec4 InvQ( vec4 a )\n{\n    return vec4(-a.xyz,a.w);\n}\n\nvec3 RotateVecQ( vec4 rotation, vec3 vector )\n{\n\treturn MulQ( rotation, MulQ( vec4(vector,0), InvQ(rotation) ) ).xyz;\n}\n\n\nfloat SDF( vec3 pos )\n{\n    const float emissionRate = 2.5;\n    const float fallRate = 1.5;\n    const float spinRate = 2.;\n    \n    float t = iTime*emissionRate;\n    \n    float f = 1e30;\n    for ( int i=0; i<8; i++ )\n    {\n        int seed = i-int(floor(t));\n        vec3 uvw = pos;\n        \n        float fall = (fract(t)+float(i))*fallRate/emissionRate - 1.; // negative offsets to before peak of fall\n        uvw.y += fall*fall*.3-1.;\n        uvw.z += fall*.4;\n        uvw.x += fall*(fract(float(seed)*.618)-.5)*.5;\n        \n        // rotate randomly\n        vec3 axis = SphereRand(seed);\n        float angle = iTime*spinRate + float((seed*23)&32)*tau;\n        vec4 rot = AxisRotToQuat( axis, angle );\n        \n        uvw = RotateVecQ( rot, uvw );\n        \n    \tf = min( f, LetterSDF( uvw, (seed*157)&255, seed ) );\n    }\n\treturn f;\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy/iResolution.xy;\n\n    if ( iMouse.x < 1. && iMouse.y < 1. )\n        mouse = vec2(.53,.8);\n    \n    mouse += sin(vec2(1,.618)*iTime*.3)*.01;\n    \n\tvec2 camAngle = (mouse-.5)*vec2(1.3,-.4999)*6.283185;\n    \n    vec3 camTarget = vec3(0);\n    float camDistance = 5.;\n    float camZoom = 1.;\n\n    vec3 camPos = camDistance*vec3(-vec2(sin(camAngle.x),cos(camAngle.x))*cos(camAngle.y),sin(camAngle.y)).xzy;\n    vec3 camK = normalize( camTarget-camPos );\n    vec3 camI = normalize(cross(vec3(0,1,0),camK));\n    vec3 camJ = cross(camK,camI);\n    \n    vec3 ray = normalize( vec3( (fragCoord-iResolution.xy*.5)/iResolution.x, camZoom ) );\n    ray = ray.x*camI + ray.y*camJ + ray.z*camK;\n\n    \n    float t = 0.;\n    float h = 1000.;\n    for ( int i=0; i < 100; i++ )\n    {\n        h = SDF(ray*t + camPos);\n        t += h;\n        if ( h < .001 || t > 8. )\n        {\n            break;\n        }\n    }\n    \n    if ( h >= .001 ) { fragColour = Sky(ray,0.)*bgTint; return; }\n    \n    vec3 pos = ray*t+camPos;\n    \n    vec2 d = vec2(-1,1)*.001;\n    vec3 normal =\n        normalize(\n            SDF(pos+d.xxx)*d.xxx +\n            SDF(pos+d.yyx)*d.yyx +\n            SDF(pos+d.yxy)*d.yxy +\n            SDF(pos+d.xyy)*d.xyy\n        );\n \n    vec3 reflectRay = reflect(ray,normal);\n    fragColour = Sky(reflectRay,max(0.,dot(reflectRay,ray))) * fgTint;\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdjyWV.jpg", "access": "api", "license": "mit", "functions": [[1717, 1717, 1741, 1741, 1776], [1792, 1792, 1852, 1997, 2175], [2518, 2518, 2565, 2565, 3026], [3028, 3028, 3074, 3196, 3295], [3297, 3297, 3348, 3374, 4611], [4614, 4614, 4648, 4665, 4780], [4812, 4812, 4841, 5070, 5348], [5351, 5371, 5417, 5417, 5473], [5475, 5475, 5504, 5504, 5738], [5740, 5740, 5761, 5761, 5792], [5794, 5794, 5841, 5841, 5913], [5916, 5916, 5939, 5939, 6755], [6757, 6757, 6815, 6815, 8174]], "test": "untested"}
{"id": "tdBcW3", "name": "chain link fence SDF", "author": "FabriceNeyret2", "description": "mouse controls camera\nsimplified from  blackle's \"access control\" https://www.shadertoy.com/view/ttG3R1\n", "tags": ["sdf"], "likes": 12, "viewed": 536, "published": 3, "date": "1587410697", "time_retrieved": "2024-07-30T21:11:28.331361", "image_code": "// Simplified version of \"access control\" by blackle https://shadertoy.com/view/ttG3R1\n// to isolate the chain link fence SDF ( + add mouse rotation ).\n// ( And accidentally created a nice background effect :-p )\n\n\n#define rot(a)  mat2(cos(m.x + vec4(0,11,33,0)))     // $Fab from https://www.shadertoy.com/view/XlsyWX\n\nfloat linedist(float x, float y, float w) {\n // return length( vec2( x, y )); // same for abs(y) // $Fab just an helix\n\treturn length( vec2( x, max( 0., abs(y)-w) ));   // $Fab https://www.desmos.com/calculator/j8v2sxntdt\n}\n\nfloat scene(vec3 p) {\n    float s = 1.25,\n         mx = 1e9;\n\n    p.z +=  floor(p.y/s) *1.5707;\n    p.y = ( fract(p.y/s) -.5 ) *s;\n    \n    for (float i = -1.; i <= 1.; i++) // $Fab: left turn, main branches, right turn\n    // float i = -1.;                 // $Fab: to test each part\n    {\n        vec3   g = p + vec3(0., i*s, i*1.5707 );\n        float d1 = linedist(g.x, g.y, .2) - .5,\n        //greets to FabriceNeyret2 https://www.shadertoy.com/view/XsdBW8\n              d2 = abs( sin( atan(g.y,g.x)/2.-g.z ) ) * min(1.,length(g.xy)), // $Fab: helix\n               d = length(vec2(d1,d2)) / sqrt(2.) -.05;\n        mx = min(d,mx);\n    }\n    return mx;\n}\n\nvec3 norm(vec3 p) { \n\tmat3 k = mat3(p,p,p) - mat3(0.001); // $Fab: cool way to generate neighborh points !\n\treturn normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])) );\n}\n\nfloat scene_col(vec2 uv) {\n    vec2 m = length(iMouse.xy)==0. ? vec2(0)\n             : (2.*iMouse.xy/iResolution.xy -1.)*1.57;\n\tvec3 cam = normalize(vec3(1.6,uv)),\n        init = vec3(-35,0,3), \n           p = init;\n    cam.xy *= rot(m.x);                 // $Fab: mouse rotates cam\n    cam.xz *= rot(m.y);\n    \n\tfor (int i = 0; i < 50; i++) {\n\t\tfloat dist = scene(p);\n\t\tif (dist < 0.003 || distance(p,init) > 100.) break;\n\t\tp += dist*cam;\n\t}\n\n\tvec3 n = norm(p);\n\tfloat fakediff = length( sin(n*3.) *.5+.5 ) / sqrt(3.),\n\t       fakeref = pow( length( sin(reflect(cam,n)*4.) *.5+.5 ) / sqrt(3.), 10.),\n\t        bright = .6;\n\treturn fakediff*bright + fakeref*1.5;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n \tvec2 R = iResolution.xy,\n         U = (u - R*.5) / R.y; \n\tO = vec4( scene_col(U) );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdBcW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[320, 320, 363, 438, 543], [545, 545, 566, 566, 1201], [1203, 1203, 1222, 1222, 1385], [1387, 1387, 1413, 1413, 2050], [2052, 2052, 2090, 2090, 2178]], "test": "untested"}
{"id": "3dScWc", "name": "Bouncing Rings 2", "author": "dr2", "description": "Colliding rings (restarts automatically or by clicking upper-right)", "tags": ["collision", "dynamics", "physics"], "likes": 20, "viewed": 453, "published": 3, "date": "1587401701", "time_retrieved": "2024-07-30T21:11:29.394519", "image_code": "// \"Bouncing Rings 2\"  by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define SHOW_SPH 0  // show spheres that comprise the rings\n\nmat3 QtToRMat (vec4 q);\nmat3 StdVuMat (float el, float az);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Fbm2 (vec2 p);\nvec4 Loadv4 (int idVar);\n\nvec3 qHit, qnHit, ltDir;\nfloat dstFar, cylRad, cylWid;\nconst int nObj = 32;\nconst int nSphObj = 20;\nconst float pi = 3.14159;\n\n#if ! SHOW_SPH\n\nvec4 CylAnHit (vec3 ro, vec3 rd, float r, float h)\n{\n  vec3 s, vn;\n  float d, a, b, w, ww, ri, g;\n  d = dstFar;\n  ri = r - 2. * h;\n  a = dot (rd.xy, rd.xy);\n  b = dot (rd.xy, ro.xy);\n  ww = b * b - a * dot (ro.xy, ro.xy);\n  w = ww + a * r * r;\n  vn = vec3 (0.);\n  if (w > 0.) {\n    if (a > 0.) {\n      d = (- b - sqrt (w)) / a;\n      s = ro + d * rd;\n      if (abs (s.z) < h) vn.xy = s.xy;\n    } else s = vec3 (0., 0., h);\n    if (d < 0. || abs (s.z) > h) {\n      d = - (sign (rd.z) * ro.z + h) / abs (rd.z);\n      g = length (ro.xy + d * rd.xy);\n      if (d < 0. || g > r) d = dstFar;\n      else if (g < ri) {\n        w = ww + a * ri * ri;\n        if (w > 0.) {\n          d = (- b + sqrt (w)) / a;\n          s = ro + d * rd;\n          if (abs (s.z) < h) vn.xy = - s.xy;\n          else d = dstFar;\n        }\n      } else vn.z = - sign (rd.z);\n    }\n  }\n  return vec4 (d, vn);\n}\n\nfloat ObjHit (vec3 ro, vec3 rd)\n{\n  mat3 mRot;\n  vec4 cdn4;\n  vec3 rm, rom, rdm;\n  float dMin;\n  dMin = dstFar;\n  for (int n = 0; n < nObj; n ++) {\n    rm = Loadv4 (4 * n).xyz;\n    mRot = QtToRMat (Loadv4 (4 * n + 2));\n    rom = (ro - rm) * mRot;\n    rdm = rd * mRot;\n    cdn4 = CylAnHit (rom, rdm, cylRad, cylWid);\n    if (cdn4.x < dMin) {\n      dMin = cdn4.x;\n      qHit = rom + dMin * rdm;\n      qnHit = mRot * cdn4.yzw;\n    }\n  }\n  qnHit = normalize (qnHit);\n  return dMin;\n}\n\nfloat ObjHitSh (vec3 ro, vec3 rd, float rng)\n{\n  mat3 mRot;\n  vec4 cdn4;\n  vec3 rm, rom, rdm;\n  float dMin;\n  dMin = dstFar;\n  for (int n = 0; n < nObj; n ++) {\n    rm = Loadv4 (4 * n).xyz;\n    mRot = QtToRMat (Loadv4 (4 * n + 2));\n    rom = (ro - rm) * mRot;\n    rdm = rd * mRot;\n    cdn4 = CylAnHit (rom, rdm, cylRad, cylWid);\n    if (cdn4.x < dMin) dMin = cdn4.x;\n  }\n  return smoothstep (0.5 * rng, rng, dMin);\n}\n\n#else\n\nvec3 RSph (float s)\n{\n  vec3 r;\n  float a;\n  a = (2. * pi / float (nSphObj)) * s;\n  r = vec3 ((cylRad - 0.5) * cos (a), (cylRad - 0.5) * sin (a), 0.);\n  return r;\n}\n\nfloat ObjHit (vec3 ro, vec3 rd)\n{\n  mat3 mRot;\n  vec3 rm, v, vn;\n  float dMin, b, d, w, sz;\n  dMin = dstFar;\n  sz = 0.5;\n  for (int n = 0; n < nObj; n ++) {\n    rm = Loadv4 (4 * n).xyz;\n    mRot = QtToRMat (Loadv4 (4 * n + 2));\n    for (int j = 0; j < nSphObj; j ++) {\n      v = ro - (rm + mRot * RSph (float (j)));\n      b = dot (rd, v);\n      w = b * b + sz * sz - dot (v, v);\n      if (w >= 0.) {\n        d = - b - sqrt (w);\n        if (d > 0. && d < dMin) {\n          dMin = d;\n          vn = v + d * rd;\n        }\n      }\n    }\n  }\n  qnHit = vn / sz;\n  return dMin;\n}\n\nfloat ObjHitSh (vec3 ro, vec3 rd, float rng)\n{\n  mat3 mRot;\n  vec3 rm, v;\n  float dMin, b, d, w, sz;\n  dMin = dstFar;\n  sz = 0.5;\n  for (int n = 0; n < nObj; n ++) {\n    rm = Loadv4 (4 * n).xyz;\n    mRot = QtToRMat (Loadv4 (4 * n + 2));\n    for (int j = 0; j < nSphObj; j ++) {\n      v = ro - (rm + mRot * RSph (float (j)));\n      b = dot (rd, v);\n      w = b * b + sz * sz - dot (v, v);\n      if (w >= 0.) {\n        d = - b - sqrt (w);\n        if (d > 0. && d < dMin) dMin = d;\n      }\n    }\n  }\n  return smoothstep (0.5 * rng, rng, dMin);\n}\n\n#endif\n\nvec3 BgCol (vec3 ro, vec3 rd, float sh)\n{\n  vec3 col, c1, c2, ca;\n  float dst;\n  c1 = vec3 (0.7, 0.3, 0.1);\n  c2 = vec3 (0.4, 0.2, 0.1);\n  ca = mix (c1, c2, 0.5);\n  if (rd.y < 0.) {\n    dst = -ro.y / rd.y;\n    ro += dst * rd;\n    col = mix (c1, c2, Fbm2 (ro.xz * vec2 (1., 0.15))) *\n       (0.5 + 0.5 * smoothstep (0.05, 0.1, mod (ro.x, 4.)));\n    col = mix (col, ca, smoothstep (0.7, 1., dst / (4. * dstFar)));\n    col *= 0.2 + 0.8 * sh * max (ltDir.y, 0.);\n  } else col = mix (ca, vec3 (1.), 0.3);\n  return col;\n}\n\nvec3 ObjCol (vec3 rd, vec3 vn, float sh)\n{\n  vec4 col4;\n  vec3 col;\n  float r;\n  col4 = vec4 (0.2, 0.4, 0.6, 0.3);\n#if ! SHOW_SPH\n  r = length (qHit.xy);\n  if (abs (r - cylRad + cylWid) < 0.8 * cylWid || abs (qHit.z) < 0.8 * cylWid) {\n    col4.rgb *= 1. - 0.5 * SmoothBump (0.4, 0.6, 0.1, mod (((r > 0.51) ? 16. : 4.) *\n       atan (qHit.y, qHit.x) / pi, 1.));\n  } else col4.rgb *= 1.2;\n#endif\n  col = col4.rgb * (0.2 +  0.1 * max (dot (normalize (- ltDir.xz), vn.xz), 0.) +\n     0.8 * sh * pow (max (dot (vn, ltDir), 0.), 1.5)) +\n     col4.a * sh * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col, colR;\n  vec2 p;\n  float dstFlr, dstObj, sh;\n  bool isBg;\n  cylRad = Loadv4 (4 * nObj).z;\n  cylWid = 0.45;\n  dstFlr = (rd.y < 0.) ? - (ro.y - 0.5) / rd.y : dstFar;\n  dstObj = ObjHit (ro, rd);\n  isBg = false;\n  if (min (dstObj, dstFlr) < dstFar) {\n    if (dstFlr < dstObj) {\n      ro += dstFlr * rd;\n      vn = vec3 (0., 1., 0.);\n      isBg = true;\n    } else {\n      ro += dstObj * rd;\n      vn = qnHit;\n    }\n  } else isBg = true;\n  if (! isBg || rd.y < 0.) {\n    sh = ObjHitSh (ro + 0.01 * ltDir, ltDir, 20.);\n    sh = 0.4 + 0.6 * sh;\n  } else sh = 1.;\n  if (! isBg) col = ObjCol (rd, vn, sh);\n  else col = BgCol (ro, rd, sh);\n  if (isBg && rd.y < 0.) {\n    rd = reflect (rd, vn);\n    ro += 0.01 * rd;\n    dstObj = ObjHit (ro, rd);\n    if (dstObj < dstFar) {\n      ro += dstObj * rd;\n      vn = qnHit;\n      colR = ObjCol (rd, vn, 1.);\n    } else colR = vec3 (0.4, 0.4, 0.4);\n    col = mix (col, colR, 0.3);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 col, rd, ro;\n  vec2 canvas, uv;\n  float az, el, asp, zmFac, tCur;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  asp = canvas.x / canvas.y;\n  mPtr = Loadv4 (4 * nObj + 1);\n  dstFar = 200.;\n  az = 0.2 * pi * sin (0.02 * pi * tCur);\n  el = -0.15 * pi;\n  if (mPtr.z > 0. && (mPtr.x < 0.5 - 0.05 / asp || mPtr.y < 0.5 - 0.05)) {\n    el += 2. * mPtr.y;\n    az += pi * mPtr.x;\n  }\n  el = clamp (el, -0.45 * pi, -0.1 * pi);\n  zmFac = 3.5;\n  vuMat = StdVuMat (el, az);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  ro = vuMat * vec3 (0., 0., -80.);\n  ltDir = normalize (vec3 (1., 1.5, -1.));\n  col = ShowScene (ro, rd);\n  if (mPtr.z > 0. && min (uv.x - asp, uv.y - 1.) > -0.1)\n     col = mix (col, vec3 (1., 1., 0.), 0.3);\n  fragColor = vec4 (col, 1.);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Bouncing Rings 2\"  by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 DirToRMatT (vec3 vd, vec3 vu);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nmat3 LpStepMat (vec3 a);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nfloat cylRad, nRun;\nconst int nObj = 32;\nconst int nSphObj = 20;\nconst float txRow = 128.;\nconst float pi = 3.14159;\n\nvec3 RSph (float s)\n{\n  vec3 r;\n  float a;\n  a = (2. * pi / float (nSphObj)) * s;\n  r = vec3 ((cylRad - 0.5) * cos (a), (cylRad - 0.5) * sin (a), 0.);\n  return r;\n}\n\nvec3 FcFun (vec3 dr, float rSep, vec3 dv)\n{\n  vec3 f;\n  float vRel, fo, drv;\n  const float fOvlap = 1000., fricN = 1., fricT = 2., fricS = 10.;\n  fo = fOvlap * (1. / rSep - 1.);\n  drv = dot (dr, dv) / (rSep * rSep);\n  dv -= drv * dr;\n  vRel = length (dv);\n  fo = max (fo - fricN * drv, 0.);\n  f = fo * dr;\n  if (vRel > 0.001) f -= min (fricT, fricS * abs (fo) * rSep / vRel) * dv;\n  return f;\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  mat3 mRot, mRotN;\n  vec3 rmN, vmN, wmN, dr, dv, rts, rtsN, rms, vms, fc, am, wam, rMom;\n  float farSep, rSep, grav, dt;\n  grav = 10.;\n  dt = 0.01;\n  rm = Loadv4 (4 * mId).xyz;\n  vm = Loadv4 (4 * mId + 1).xyz;\n  qm = Loadv4 (4 * mId + 2);\n  wm = Loadv4 (4 * mId + 3).xyz;\n  mRot = QtToRMat (qm);\n  farSep = 2. * (cylRad + 1.);\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = 0; n < nObj; n ++) {\n    rmN = Loadv4 (4 * n).xyz;\n    if (n != mId && length (rm - rmN) < farSep) {\n      vmN = Loadv4 (4 * n + 1).xyz;\n      mRotN = QtToRMat (Loadv4 (4 * n + 2));\n      wmN = Loadv4 (4 * n + 3).xyz;\n      for (int j1 = 0; j1 < nSphObj; j1 ++) {\n        rts = mRot * RSph (float (j1));\n        rms = rm + rts;\n        vms = vm + cross (wm, rts);\n        dv = vms - vmN;\n        fc = vec3 (0.);\n        for (int j2 = 0; j2 < nSphObj; j2 ++) {\n          rtsN = mRotN * RSph (float (j2));\n          dr = rms - (rmN + rtsN);\n          rSep = length (dr);\n          if (rSep < 1.) fc += FcFun (dr, rSep, dv - cross (wmN, rtsN));\n        }\n        am += fc;\n        wam += cross (rts, fc);\n      }\n    }\n  }\n  rMom = vec3 (0.);\n  for (int j = 0; j < nSphObj; j ++) {\n    rts = RSph (float (j));\n    rMom += dot (rts, rts) - rts * rts + 1./6.;\n    rts = mRot * rts;\n    dr = rm + rts;\n    rSep = abs (dr.y);\n    if (rSep < 1.) {\n      fc = FcFun (vec3 (0., dr.y, 0.), rSep, vm + cross (wm, rts));\n      am += fc;\n      wam += cross (rts, fc);\n    }\n  }\n  rMom /= float (nSphObj);\n  wam = mRot * (wam * mRot / rMom);\n  am.y -=  grav;\n  vm += dt * am;\n  rm += dt * vm;\n  wm += dt * wam;\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  vec3 u;\n  float b;\n  b = 2. * Hashff (33.3 * float (mId) + nRun + 17.11) - 1.;\n  rm = vec3 (32. * sin (2. * pi * (float (mId) / float (nObj)) + vec2 (0.5 * pi, 0.)), 6.).xzy;\n  u = normalize (vec3 (rm.z, - rm.x, 0.)).xzy;\n  u.xz = Rot2D (u.xz, 0.1 * pi * b);\n  qm = RMatToQt (DirToRMatT (u, vec3 (0., 1., 0.)));\n  vm = vec3 (- 0.3 * (1. + 0.2 * b) * rm.xz, 1.5 * (1. + b)).xzy;\n  wm = -5. * u * b;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, stDat, qm;\n  vec3 rm, vm, wm;\n  vec2 iFrag, canvas;\n  float tCur, asp, mxStep, nStep;\n  int mId, pxId, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nObj + 2) discard;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  mId = (pxId < 4 * nObj) ? mId = pxId / 4 : -1;\n  doInit = false;\n  mxStep = 1800.;\n  if (iFrame <= 5) {\n    doInit = true;\n    cylRad = 3.;\n    nRun = 0.;\n  } else {\n    stDat = Loadv4 (4 * nObj);\n    nStep = stDat.x;\n    cylRad = stDat.z;\n    nRun = stDat.w;\n    ++ nStep;\n    if (nStep > mxStep || nStep > 100. && mPtr.z > 0. && mPtr.x > 0.5 - 0.05 / asp &&\n       mPtr.y > 0.5 - 0.05) doInit = true;\n  }\n  if (doInit) {\n    ++ nRun;\n    nStep = 0.;\n  }\n  if (mId >= 0) {\n    if (doInit || nStep < 10.) Init (mId, rm, vm, qm, wm);\n    else Step (mId, rm, vm, qm, wm);\n    kp = 4 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = qm;\n    else if (pxId == kp + 3) stDat = vec4 (wm, 0.);\n  } else {\n    kp = 4 * nObj;\n    if (pxId == kp) stDat = vec4 (nStep, mxStep, cylRad, nRun);\n    else if (pxId == kp + 1) stDat = vec4 (mPtr.xyz, 0.);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nmat3 DirToRMatT (vec3 vd, vec3 vu)\n{\n  vec3 vc;\n  vc = normalize (cross (vu, vd)); // assumes cross != 0\n  return mat3 (vc, cross (vd, vc), vd);\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \"Bouncing Rings 2\"  by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 DirToRMatT (vec3 vd, vec3 vu);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nmat3 LpStepMat (vec3 a);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nfloat cylRad, nRun;\nconst int nObj = 32;\nconst int nSphObj = 20;\nconst float txRow = 128.;\nconst float pi = 3.14159;\n\nvec3 RSph (float s)\n{\n  vec3 r;\n  float a;\n  a = (2. * pi / float (nSphObj)) * s;\n  r = vec3 ((cylRad - 0.5) * cos (a), (cylRad - 0.5) * sin (a), 0.);\n  return r;\n}\n\nvec3 FcFun (vec3 dr, float rSep, vec3 dv)\n{\n  vec3 f;\n  float vRel, fo, drv;\n  const float fOvlap = 1000., fricN = 1., fricT = 2., fricS = 10.;\n  fo = fOvlap * (1. / rSep - 1.);\n  drv = dot (dr, dv) / (rSep * rSep);\n  dv -= drv * dr;\n  vRel = length (dv);\n  fo = max (fo - fricN * drv, 0.);\n  f = fo * dr;\n  if (vRel > 0.001) f -= min (fricT, fricS * abs (fo) * rSep / vRel) * dv;\n  return f;\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  mat3 mRot, mRotN;\n  vec3 rmN, vmN, wmN, dr, dv, rts, rtsN, rms, vms, fc, am, wam, rMom;\n  float farSep, rSep, grav, dt;\n  grav = 10.;\n  dt = 0.01;\n  rm = Loadv4 (4 * mId).xyz;\n  vm = Loadv4 (4 * mId + 1).xyz;\n  qm = Loadv4 (4 * mId + 2);\n  wm = Loadv4 (4 * mId + 3).xyz;\n  mRot = QtToRMat (qm);\n  farSep = 2. * (cylRad + 1.);\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = 0; n < nObj; n ++) {\n    rmN = Loadv4 (4 * n).xyz;\n    if (n != mId && length (rm - rmN) < farSep) {\n      vmN = Loadv4 (4 * n + 1).xyz;\n      mRotN = QtToRMat (Loadv4 (4 * n + 2));\n      wmN = Loadv4 (4 * n + 3).xyz;\n      for (int j1 = 0; j1 < nSphObj; j1 ++) {\n        rts = mRot * RSph (float (j1));\n        rms = rm + rts;\n        vms = vm + cross (wm, rts);\n        dv = vms - vmN;\n        fc = vec3 (0.);\n        for (int j2 = 0; j2 < nSphObj; j2 ++) {\n          rtsN = mRotN * RSph (float (j2));\n          dr = rms - (rmN + rtsN);\n          rSep = length (dr);\n          if (rSep < 1.) fc += FcFun (dr, rSep, dv - cross (wmN, rtsN));\n        }\n        am += fc;\n        wam += cross (rts, fc);\n      }\n    }\n  }\n  rMom = vec3 (0.);\n  for (int j = 0; j < nSphObj; j ++) {\n    rts = RSph (float (j));\n    rMom += dot (rts, rts) - rts * rts + 1./6.;\n    rts = mRot * rts;\n    dr = rm + rts;\n    rSep = abs (dr.y);\n    if (rSep < 1.) {\n      fc = FcFun (vec3 (0., dr.y, 0.), rSep, vm + cross (wm, rts));\n      am += fc;\n      wam += cross (rts, fc);\n    }\n  }\n  rMom /= float (nSphObj);\n  wam = mRot * (wam * mRot / rMom);\n  am.y -=  grav;\n  vm += dt * am;\n  rm += dt * vm;\n  wm += dt * wam;\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  vec3 u;\n  float b;\n  b = 2. * Hashff (33.3 * float (mId) + nRun + 17.11) - 1.;\n  rm = vec3 (32. * sin (2. * pi * (float (mId) / float (nObj)) + vec2 (0.5 * pi, 0.)), 6.).xzy;\n  u = normalize (vec3 (rm.z, - rm.x, 0.)).xzy;\n  u.xz = Rot2D (u.xz, 0.1 * pi * b);\n  qm = RMatToQt (DirToRMatT (u, vec3 (0., 1., 0.)));\n  vm = vec3 (- 0.3 * (1. + 0.2 * b) * rm.xz, 1.5 * (1. + b)).xzy;\n  wm = -5. * u * b;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, stDat, qm;\n  vec3 rm, vm, wm;\n  vec2 iFrag, canvas;\n  float tCur, asp, mxStep, nStep;\n  int mId, pxId, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nObj + 2) discard;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  mId = (pxId < 4 * nObj) ? mId = pxId / 4 : -1;\n  doInit = false;\n  mxStep = 1800.;\n  if (iFrame <= 5) {\n    doInit = true;\n    cylRad = 3.;\n    nRun = 0.;\n  } else {\n    stDat = Loadv4 (4 * nObj);\n    nStep = stDat.x;\n    cylRad = stDat.z;\n    nRun = stDat.w;\n    ++ nStep;\n    if (nStep > mxStep || nStep > 100. && mPtr.z > 0. && mPtr.x > 0.5 - 0.05 / asp &&\n       mPtr.y > 0.5 - 0.05) doInit = true;\n  }\n  if (doInit) {\n    ++ nRun;\n    nStep = 0.;\n  }\n  if (mId >= 0) {\n    if (doInit || nStep < 10.) Init (mId, rm, vm, qm, wm);\n    else Step (mId, rm, vm, qm, wm);\n    kp = 4 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = qm;\n    else if (pxId == kp + 3) stDat = vec4 (wm, 0.);\n  } else {\n    kp = 4 * nObj;\n    if (pxId == kp) stDat = vec4 (nStep, mxStep, cylRad, nRun);\n    else if (pxId == kp + 1) stDat = vec4 (mPtr.xyz, 0.);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nmat3 DirToRMatT (vec3 vd, vec3 vu)\n{\n  vec3 vc;\n  vc = normalize (cross (vu, vd)); // assumes cross != 0\n  return mat3 (vc, cross (vd, vc), vd);\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dScWc.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[3570, 3570, 3611, 3611, 4085], [4087, 4087, 4129, 4129, 4707], [4709, 4709, 4744, 4744, 5705], [5707, 5707, 5763, 5763, 6614], [6616, 6616, 6641, 6641, 7016], [7018, 7018, 7054, 7054, 7260], [7262, 7262, 7319, 7319, 7402], [7496, 7496, 7521, 7521, 7649], [7683, 7683, 7707, 7707, 7837], [7839, 7839, 7864, 7864, 8050], [8052, 8052, 8073, 8073, 8228]], "test": "untested"}
{"id": "WsByWc", "name": "Sizzling Lava", "author": "jarble", "description": "This fractal is based on my [url=https://www.shadertoy.com/view/wdsyD8]\"Sea of Lava\"[/url] shader.", "tags": ["fractal", "lava"], "likes": 1, "viewed": 285, "published": 3, "date": "1587401240", "time_retrieved": "2024-07-30T21:11:30.289127", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 9.0;\nconst float distortion_scale = mag*mag;\n\nconst int GREEN = 0;\nconst int BLUE = 1;\nconst int GRAY = 2;\nconst int YELLOW = 3;\nconst int WHITE = 4;\nconst int FOREST_GREEN = 5;\nconst int LIGHTBLUE = 6;\nconst int SKYBLUE = 7;\nconst int SNOW = 8;\nconst int WHITESMOKE = 9;\nconst int LIGHTGRAY = 10;\nconst int LIME = 11;\nconst int LIGHTYELLOW = 12;\nconst int BEIGE = 13;\nconst int SAND = 14;\nconst int TAN = 15;\nconst int ORANGE = 16;\nconst int RED = 17;\nconst int BLACK = 18;\nconst int DARKGRAY = 19;\nconst int ORANGERED = 20;\n\nconst int SWAMP_BIOME = 1;\nconst int GLACIER_BIOME = 2;\nconst int FORESTS_AND_MOUNTAINS = 3;\nconst int SAVANNA_BIOME = 4;\nconst int FOREST_BIOME = 5;\n\n//this function is from https://www.shadertoy.com/view/4djSRW\nint hash12(vec2 p,float num_colors)\n{\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return int(floor(fract((p3.x + p3.y) * p3.z)*num_colors));\n}\n    \nint magnify(vec2 fragCoord,float mag,float num_colors){\n    fragCoord += vec2(sin(fragCoord.y/(distortion_scale*mag)+iTime),sin(fragCoord.x/(distortion_scale*mag)+iTime))*10.0*mag*mag;\n    return hash12(floor(fragCoord/pow(3.0,mag)),num_colors);\n}\n\nivec4 get_neighbors(vec2 fragCoord,float mag,float colors){\n\treturn ivec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\n\nbool is_next_to(int color,ivec4 neighbors){\n\treturn (neighbors.x == color)\n        || (neighbors.y == color)\n        || (neighbors.z == color)\n        || (neighbors.w == color);\n}\n\nvec3 rgb(float r,float g,float b){\n\treturn vec3(r,g,b)/255.0;\n}\n\nvec3 get_color(int color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == FOREST_GREEN){\n    \treturn rgb(34.0,139.0,34.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n    else if(color == LIGHTBLUE){\n    \treturn rgb(173.0,216.0,230.0);\n   \t}\n    else if(color == SKYBLUE){\n    \treturn rgb(135.0,206.0,235.0);\n    }\n    else if(color == SNOW){\n    \treturn rgb(255.0,250.0,250.0);\n    }\n    else if(color == WHITESMOKE){\n    \treturn rgb(245.0,245.0,245.0);\n    }\n    else if(color == LIGHTGRAY){\n    \treturn rgb(211.0,211.0,211.0);\n    }\n    else if(color == LIME){\n    \treturn rgb(0.0,255.0,0.0);\n    }\n    else if(color == LIGHTYELLOW){\n    \treturn rgb(255.0,255.0,153.0);\n    }\n    else if(color == BEIGE){\n    \treturn rgb(245.0,245.0,220.0);\n    }\n    else if(color == TAN){\n    \treturn rgb(210.,180.,140.);\n    }\n    else if(color == ORANGE){\n    \treturn vec3(255,127,80)/255.0;\n    }\n    else if(color == RED){\n    \treturn vec3(1.0,0.0,0.0);\n   \t}\n    else if(color == DARKGRAY){\n    \treturn rgb(128.0,128.0,128.0);\n    }\n    else if(color == ORANGERED){\n    \treturn rgb(255.0,69.0,0.0);\n    }\n}\n\n\nint glacier_biome(inout int color1, ivec4 neighbors){\n\tint GREEN = 0;\n    int BLUE = 1;\n    int GRAY = 2;\n    int WHITE = 3;\n    int YELLOW = 4;\n    \n    return (color1 == GREEN && is_next_to(BLUE,neighbors))\n        ? GRAY\n    : (color1 == GREEN && is_next_to(WHITE,neighbors))\n        ? GRAY\n    : (color1 == BLUE && is_next_to(GREEN,neighbors))\n        ? WHITE\n    : (color1 == YELLOW && is_next_to(GREEN,neighbors))\n        ? GRAY\n    : (color1 == YELLOW && is_next_to(GRAY,neighbors))\n        ? BLUE\n    :(color1 == WHITE && is_next_to(YELLOW,neighbors))\n        ? GRAY\n    :(color1 == YELLOW && is_next_to(WHITE,neighbors))\n        ? WHITE\n    :(color1 == GRAY && is_next_to(BLUE,neighbors))\n        ? BLUE\n    :color1;\n}\n\nvoid biome(inout int color1, ivec4 neighbors,int biome){\n    color1 =\n        glacier_biome(color1,neighbors);\n}\n\nint biome(in vec2 fragCoord,float mag,float zoom,int colors[5],int biome1){\n    fragCoord *= zoom;\n\n    \n    float num_colors = float(colors.length());\n    \n    int color1 = magnify(fragCoord,mag,num_colors);\n    \n    ivec4 neighbors;\n    \n    while(mag > 1.0){\n                float avg =(100.0*(mag/float(color1)));\n        fragCoord += vec2(sin(fragCoord.y/avg)*10.0,sin(fragCoord.x/avg)*10.0)*mag*mag;\n\n    neighbors = get_neighbors(fragCoord,mag,num_colors);\n    biome(color1, neighbors,biome1);\n    mag -= 1.0;\n    }\n    return colors[int(color1)];;\n}\n\n\nint glacier_biome(in vec2 fragCoord,float mag,float zoom,int[5] colors){\n    return biome(fragCoord,mag,zoom,colors,GLACIER_BIOME);\n}\n\nint lava_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn glacier_biome(fragCoord,mag,zoom,int[](DARKGRAY,YELLOW,ORANGERED,ORANGE,ORANGERED));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = mag*(((iMouse.x-iMouse.y)*2.0+iResolution.x)/iResolution.x);\n    fragCoord *= zoom;\n    fragCoord = fragCoord + floor(iTime*100.0)*vec2(zoom,0.0);\n\n\tint biome = lava_biome(fragCoord,mag,1.0);\n    \n    fragColor = vec4(get_color(biome),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsByWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[741, 803, 840, 896, 1044], [1050, 1050, 1105, 1105, 1297], [1299, 1299, 1358, 1358, 1563], [1566, 1566, 1609, 1609, 1745], [1747, 1747, 1781, 1781, 1810], [1812, 1812, 1838, 1838, 3195], [3198, 3198, 3251, 3251, 3925], [3927, 3927, 3983, 3983, 4039], [4041, 4041, 4116, 4116, 4598], [4889, 4889, 4946, 4946, 5206]], "test": "untested"}
{"id": "3sBcD3", "name": "Kaleidoscopic Lava", "author": "jarble", "description": "This is an edit of my [url=https://www.shadertoy.com/view/wsByzG]\"River of Fire\"[/url] shader.", "tags": ["fractal", "lava"], "likes": 2, "viewed": 345, "published": 3, "date": "1587397685", "time_retrieved": "2024-07-30T21:11:31.116914", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 9.0;\nconst float distortion_scale = mag*mag;\n\nconst int GREEN = 0;\nconst int BLUE = 1;\nconst int GRAY = 2;\nconst int YELLOW = 3;\nconst int WHITE = 4;\nconst int FOREST_GREEN = 5;\nconst int LIGHTBLUE = 6;\nconst int SKYBLUE = 7;\nconst int SNOW = 8;\nconst int WHITESMOKE = 9;\nconst int LIGHTGRAY = 10;\nconst int LIME = 11;\nconst int LIGHTYELLOW = 12;\nconst int BEIGE = 13;\nconst int SAND = 14;\nconst int TAN = 15;\nconst int ORANGE = 16;\nconst int RED = 17;\nconst int BLACK = 18;\nconst int DARKGRAY = 19;\nconst int ORANGERED = 20;\n\nconst int SWAMP_BIOME = 1;\nconst int GLACIER_BIOME = 2;\nconst int FORESTS_AND_MOUNTAINS = 3;\nconst int SAVANNA_BIOME = 4;\nconst int FOREST_BIOME = 5;\n\n//this function is from https://www.shadertoy.com/view/4djSRW\nint hash12(vec2 p,float num_colors)\n{\n    //set the number of colors to be randomly generated\n    p = sin(p.xx-p.yy);\n    vec3 p3 = (vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return int(floor(fract((p3.x + p3.y) * p3.z)*num_colors));\n}\n    \nint magnify(vec2 fragCoord,float mag,float num_colors){\n    return hash12(floor(fragCoord/pow(3.0,mag)),num_colors);\n}\n\nivec4 get_neighbors(vec2 fragCoord,float mag,float colors){\n\treturn ivec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\n\nbool is_next_to(int color,ivec4 neighbors){\n\treturn (neighbors.x == color)\n        || (neighbors.y == color)\n        || (neighbors.z == color)\n        || (neighbors.w == color);\n}\n\nvec3 rgb(float r,float g,float b){\n\treturn vec3(r,g,b)/255.0;\n}\n\nvec3 get_color(int color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == FOREST_GREEN){\n    \treturn rgb(34.0,139.0,34.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n    else if(color == LIGHTBLUE){\n    \treturn rgb(173.0,216.0,230.0);\n   \t}\n    else if(color == SKYBLUE){\n    \treturn rgb(135.0,206.0,235.0);\n    }\n    else if(color == SNOW){\n    \treturn rgb(255.0,250.0,250.0);\n    }\n    else if(color == WHITESMOKE){\n    \treturn rgb(245.0,245.0,245.0);\n    }\n    else if(color == LIGHTGRAY){\n    \treturn rgb(211.0,211.0,211.0);\n    }\n    else if(color == LIME){\n    \treturn rgb(0.0,255.0,0.0);\n    }\n    else if(color == LIGHTYELLOW){\n    \treturn rgb(255.0,255.0,153.0);\n    }\n    else if(color == BEIGE){\n    \treturn rgb(245.0,245.0,220.0);\n    }\n    else if(color == TAN){\n    \treturn rgb(210.,180.,140.);\n    }\n    else if(color == ORANGE){\n    \treturn vec3(255,127,80)/255.0;\n    }\n    else if(color == RED){\n    \treturn vec3(1.0,0.0,0.0);\n   \t}\n    else if(color == DARKGRAY){\n    \treturn rgb(128.0,128.0,128.0);\n    }\n    else if(color == ORANGERED){\n    \treturn rgb(255.0,69.0,0.0);\n    }\n}\n\n\nint glacier_biome(inout int color1, ivec4 neighbors){\n\tint GREEN = 0;\n    int BLUE = 1;\n    int GRAY = 2;\n    int WHITE = 3;\n    int YELLOW = 4;\n    \n    return (color1 == GREEN && is_next_to(BLUE,neighbors))\n        ? GRAY\n    : (color1 == GREEN && is_next_to(WHITE,neighbors))\n        ? GRAY\n    : (color1 == BLUE && is_next_to(GREEN,neighbors))\n        ? WHITE\n    : (color1 == YELLOW && is_next_to(GREEN,neighbors))\n        ? GRAY\n    : (color1 == YELLOW && is_next_to(GRAY,neighbors))\n        ? BLUE\n    :(color1 == WHITE && is_next_to(YELLOW,neighbors))\n        ? GRAY\n    :(color1 == YELLOW && is_next_to(WHITE,neighbors))\n        ? WHITE\n    :(color1 == GRAY && is_next_to(BLUE,neighbors))\n        ? BLUE\n    :color1;\n}\n\nvoid biome(inout int color1, ivec4 neighbors,int biome){\n    color1 =\n        glacier_biome(color1,neighbors);\n}\n\nint biome(in vec2 fragCoord,float mag,float zoom,int colors[5],int biome1){\n    fragCoord *= zoom;\n    float num_colors = float(colors.length());\n    \n    fragCoord += vec2(sin(fragCoord.y/(distortion_scale*mag)+iTime/5.0),sin(fragCoord.x/(distortion_scale*mag)+iTime/5.0))*10.0*mag*mag;\n    int color1 = magnify(fragCoord,mag,num_colors);\n    \n    ivec4 neighbors;\n    while(mag > 1.0){\n        float avg =(100.0*(mag/float(color1)));\n        fragCoord += vec2(sin(fragCoord.y/avg+iTime/5.0)*10.0,sin(fragCoord.x/avg+iTime/5.0)*10.0)*mag*mag;\n\n    neighbors = get_neighbors(fragCoord,mag,num_colors);\n    biome(color1, neighbors,biome1);\n    mag -= 1.0;\n    }\n    return colors[int(color1)];;\n}\n\n\nint glacier_biome(in vec2 fragCoord,float mag,float zoom,int[5] colors){\n    return biome(fragCoord,mag,zoom,colors,GLACIER_BIOME);\n}\n\nint lava_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn glacier_biome(fragCoord,mag,zoom,int[](DARKGRAY,YELLOW,ORANGERED,ORANGE,ORANGERED));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = mag*(((iMouse.x-iMouse.y)*2.0+iResolution.x)/iResolution.x);\n    fragCoord *= zoom;\n\n    fragCoord = fragCoord + floor(iTime*100.0)*vec2(zoom,0.0);\n    \n\tint biome = lava_biome(fragCoord,mag,1.0);\n    \n    fragColor = vec4(get_color(biome),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sBcD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[741, 803, 840, 896, 1057], [1063, 1063, 1118, 1118, 1181], [1183, 1183, 1242, 1242, 1447], [1450, 1450, 1493, 1493, 1629], [1631, 1631, 1665, 1665, 1694], [1696, 1696, 1722, 1722, 3079], [3082, 3082, 3135, 3135, 3809], [3811, 3811, 3867, 3867, 3923], [3925, 3925, 4000, 4000, 4620], [4911, 4911, 4968, 4968, 5233]], "test": "untested"}
{"id": "WsScD3", "name": "compare_two_image", "author": "jamelouis", "description": "compare two image", "tags": ["utils"], "likes": 2, "viewed": 273, "published": 3, "date": "1587396487", "time_retrieved": "2024-07-30T21:11:32.006535", "image_code": "struct Rect\n{\n    vec2 lb;\n    vec2 rt;\n};\n\nstruct Circle\n{\n    vec2 o;\n    float radius;\n};\n\nstruct Triangle\n{\n    vec2 a;\n    vec2 b;\n    vec2 c;\n};\n    \nbool intersect(Rect rect, vec2 pos)\n{\n    bool ret = pos.x > rect.lb.x && pos.x < rect.rt.x;\n    ret = ret && pos.y > rect.lb.y && pos.y < rect.rt.y;\n    \n    return ret;\n}\n\nbool intersect(Circle c, vec2 pos)\n{\n    return length(pos-c.o) < c.radius;\n}\n\nfloat at_line(vec2 a, vec2 b, vec2 pos)\n{\n    return (pos.y - a.y)*(b.x-a.x) - (pos.x - a.x) * (b.y-a.y);\n}\n\nbool intersect(Triangle tri, vec2 pos)\n{\n    bool ret = at_line(tri.a, tri.b, pos) > 0.0;\n    ret = ret && at_line(tri.b, tri.c, pos) > 0.0;\n    ret = ret && at_line(tri.c, tri.a, pos) > 0.0;\n    \n    return ret;\n}\n\nvec3 compare_two_image(vec3 col1, vec3 col2, float horizontal, vec2 pos)\n{\n    Rect rect = Rect(vec2(horizontal - 0.002, 0.0), vec2(horizontal + 0.002, 1.0));\n    Circle c = Circle(vec2(horizontal, 0.5), 0.08);\n    Circle c2 = Circle(vec2(horizontal, 0.5), 0.07);\n    Triangle tri1 = Triangle(vec2(horizontal - 0.01, 0.54), \n                             vec2(horizontal - 0.06, 0.5),\n                             vec2(horizontal - 0.01, 0.46));\n    Triangle tri2 = Triangle(vec2(horizontal + 0.01, 0.54),\n                             vec2(horizontal + 0.01, 0.46),\n                             vec2(horizontal + 0.06, 0.5)\n                             );\n    \n    bool flag = intersect(rect, pos);\n    flag = flag || (intersect(c, pos) && !intersect(c2, pos));\n    flag = flag || intersect(tri1, pos) || intersect(tri2, pos);\n    if(flag) return vec3(1.0);\n    \n    float factor = pos.x < horizontal ? 0.0 : 1.0f;\n    return mix(col1, col2, factor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n\tvec3 col1 = texture(iChannel0, uv).xyz;\n    vec3 col2 = texture(iChannel1, uv).xyz;\n    \n   \tvec3 col = compare_two_image(col1, col2, iMouse.x / iResolution.y, uv);\n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsScD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[156, 156, 193, 193, 328], [330, 330, 366, 366, 407], [409, 409, 450, 450, 516], [518, 518, 558, 558, 732], [734, 734, 808, 808, 1685], [1687, 1687, 1744, 1744, 2037]], "test": "untested"}
{"id": "wsjyDV", "name": "π decimals in 2D & color", "author": "fenoll", "description": "Computes decimals in base 16 with Plouffe's formula.\n\nGoal: visualize pi's decimals in 3D with https://github.com/voidstarHQ/voidstar", "tags": ["pi", "plouffe", "spigot"], "likes": 1, "viewed": 282, "published": 3, "date": "1587383050", "time_retrieved": "2024-07-30T21:11:32.884189", "image_code": "// https://www.shadertoy.com/view/wsjyDV\n// Inspired from https://www.shadertoy.com/view/XsyyzW\n// Pi by Plouffe spigot algorithm:\n// See also (en & fr) https://en.wikipedia.org/wiki/Bailey%E2%80%93Borwein%E2%80%93Plouffe_formula\n// Adapted from C code:  http://www.experimentalmath.info/bbp-codes/piqpr8.c\n// Another PI method (not parallel): https://www.shadertoy.com/view/MdtXWj\n// See also https://github.com/voidstarHQ/voidstar\n\n#define double float\n#define pow16(x) exp2(4.*(x))\n\n// expm = 16^p mod ak.\n// This routine uses the left-to-right binary exponentiation scheme.\ndouble expm(double p, double ak) {\n  int i, j;\n  double p1, pt, r;\n#define ntp 25\n#define tp(i) exp2(float(i))\n  if (ak == 1.) return 0.;\n\n  // Find the greatest power of two less than or equal to p.\n  // $FaN: why not using floor(log2(p)) ?\n  for (i = 0; i < ntp; i++)\n      if (tp(i) > p) break;\n\n  pt = tp(i-1);\n  p1 = p;\n  r = 1.;\n  // Perform binary exponentiation algorithm modulo ak.\n  for (j = 1; j <= i; j++){\n    if (p1 >= pt){\n      r = 16. * r;\n      r = mod(r,ak); // $FaN: is mod reliable ?\n      p1 -= pt;\n    }\n    pt /= 2.;\n    if (pt >= 1.){\n      r = r * r;\n      r = mod(r,ak);\n    }\n  }\n  return r;\n}\n\n// This routine evaluates the series  sum_k 16^(id-k)/(8*k+m)\n// using the modular exponentiation technique.\ndouble series(int m, int id) {\n  int k;\n  double ak, p, s, t;\n#define eps 1e-17 // maybe we could shorten it when using floats\n  s = 0.;\n\n  // Sum the series up to id.\n  for (k = 0; k < id; k++){\n    ak = float(8 * k + m);\n    p = float(id - k);\n    t = expm (p, ak) / ak;\n    s = fract(s+t);\n  }\n\n  // Compute a few terms where k >= id.\n#define M 8  // was 100. 8 seems sufficient to have the whole 10 hex digit ok ! 1 is still ok for 3 digits\n  for (k = id; k <= id + M; k++){\n    ak = float(8 * k + m);\n    t = pow16( float(id - k)) / ak;\n    if (t < eps) break;\n    s = fract(s+t);\n  }\n  return s;\n}\n\n// id is the digit position. Digits generated follow immediately after id.\nfloat digit(int id) {\n  if (id<0) return .1415926535897; // for test ( = ref )\n  double s1 = series(1, id);\n  double s2 = series(4, id);\n  double s3 = series(5, id);\n  double s4 = series(6, id);\n  double pid = 4. * s1 - 2. * s2 - s3 - s4;\n  return fract(pid);// NB: pid always <0 ?\n}\n\n\nvoid mainImage( out vec4 O, vec2 U ) {\n    O -= O;\n    ivec2 iU = ivec2(U/8.);\n    ivec2 iW = ivec2(iResolution.xy/32.);\n    if (iU.x>=iW.x || iU.y>=iW.y) return;\n\n    // Since only the fractional part is accurate,\n    // extracting the wanted digit requires that one removes\n    // the integer part of the final sum and multiplies by 16\n    // to \"skim off\" the hexadecimal digit at this position\n    // (in theory, the next few digits up to the accuracy of\n    // the calculations used would also be accurate).\n    //float r = 16. * digit(0 + iU.x + W.x*iU.y);\n    float r = digit(0 + iU.x + iW.x*iU.y);\n    float g = fract(100. * r);\n    float b = fract(100. * g);\n\n    O = vec4(r,g,b,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsjyDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[486, 578, 612, 612, 1199], [1201, 1310, 1340, 1340, 1913], [1915, 1990, 2011, 2011, 2273], [2276, 2276, 2314, 2314, 2969]], "test": "untested"}
{"id": "ts2yWV", "name": "Rainbow Temple, Ungolfed", "author": "mla", "description": "Ungolfed version of GregRostami's [url]https://www.shadertoy.com/view/3sjcDV[/url], derived from vahidk's [url]https://www.shadertoy.com/view/tdSyDG[/url].\n\nyoshin4004's original: [url]https://twitter.com/yosshin4004/status/1251357672504360966[/url]", "tags": ["raymarching", "tunnel", "ungolf"], "likes": 15, "viewed": 959, "published": 3, "date": "1587378205", "time_retrieved": "2024-07-30T21:11:33.775804", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Rainbow Temple, Ungolfed. Matthew Arcus, mla, 2020.\n//\n// Ungolfed and rationalized version of GregRostami's Rainbow Temple:\n// https://www.shadertoy.com/view/3sjcDV, which is derived from vahidk's\n// Infinite Tunnel: https://www.shadertoy.com/view/tdSyDG which is derived\n// from yoshin4004's original: https://twitter.com/yosshin4004/status/1251357672504360966\n//\n// <mouse>: look around\n// f: floor\n// l: change light direction\n// v: vary sphere overlap\n// z: move along z axis\n//\n// Logic is mostly the same, have dinked with the lighting a little.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\nfloat PI = 3.14159;\n\nvec3 transform(vec3 p) {\n  if (iMouse.x > 0.0) {\n    // Full range of rotation across the screen.\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,-theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  return p;\n}\n\nconst int CHAR_F = 70;\nconst int CHAR_L = 76;\nconst int CHAR_V = 86;\nconst int CHAR_Z = 90;\n\nbool key(int key) {\n  return texelFetch(iChannel3,ivec2(key,2),0).x != 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  // Orthographic projection - this is the ray direction\n  vec3 d = vec3((2.0*fragCoord-iResolution.xy)/iResolution.y, 1);\n  d = transform(d);\n  vec3 p = vec3(0); // Ray marching origin\n  if (!key(CHAR_Z)) p.z = 0.2*iTime;\n  vec3 q,p0 = p;\n  vec3 lightdir = vec3(1,1,1);\n  if (key(CHAR_L)) lightdir.xz = rotate(lightdir.xz,0.123*iTime);\n  for (int i = 0; i < 120; i++) {\n    float lfactor = 0.5;\n    float overlap = 0.65;\n    if (key(CHAR_V)) overlap += 0.1*sin(0.1*iTime);\n    float floorheight = 0.3;\n    float s = overlap-length(fract(p+0.5)-0.5);\n    if (!key(CHAR_F)) s = min(s, p.y + floorheight);\n    p += lfactor*d*s;\n    if (i == 80) {\n      // We must have hit the surface by now.\n      q = p; // Remember position\n      p -= d*.01; // Back up a little to stop self-shadowing\n      d = lightdir; // Light direction (for shadows)\n    }\n  }\n  ivec3 u = ivec3(q*5e2); // u in [0..255]\n  u = u.yzx^u.zxy;             // Mix up for chequer effect\n  u &= 255;\n  vec3 col = vec3(u)/255.0;\n  col *= 0.25*(length(p-q) + 0.9);\n  col += 0.1*(length(p-p0));\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2yWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[725, 756, 786, 786, 831], [854, 854, 878, 878, 1158], [1253, 1253, 1272, 1272, 1330], [1332, 1332, 1384, 1441, 2469]], "test": "untested"}
{"id": "3d2yRK", "name": "2D cloud tracing test", "author": "Leria", "description": "Trying to draw 1 cloud", "tags": ["noise", "cloud", "sky"], "likes": 0, "viewed": 337, "published": 3, "date": "1587376634", "time_retrieved": "2024-07-30T21:11:34.604589", "image_code": "//\n\n\nconst float blob_radius = 60.;\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n//quintique\nvec2 fade5(vec2 f) {return f * f * f * (f * (f * 6.0 - 15.0) + 10.0);}\n\n//cubique\nvec2 fade3(vec2 f) {return f*f*(3.0-2.0*f);}\n\nfloat noise(vec2 p)\n{\n \tvec2 i = floor( p );\n    vec2 f = fract( p );\n    \n    vec2 u = fade5(f);\n    \n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n        \n}\n\n\nfloat fractal_noise(vec2 p)\n{\n    float f = 0.0;\n\t\n    float a = 4.;\n    for(int i = 0; i < 5 ; i++)\n    {\n     \tf += a*(abs(noise(p))*2.-1.)/10.;\n        p = p*2.;\n        a /= 2.;\n    }\n    \n    return f;\n}\n\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n\tvec4 p = vec4(U.x, U.y/iResolution.y, 1, 1),\n    background = vec4(.4, .5, 1, 1),\n    towhite = vec4(.6, .7, 1, 1),\n\tcloud_color = vec4(1.);\n    O = mix(towhite, background, p);\n\n    vec2 seed = iResolution.xy/2.;\n    \n    float l = fractal_noise(U/1.);\n\n    float d = length(seed-U) - ( blob_radius + 7.*l );\n\n    vec4 c = mix(vec4(.95), vec4(1), l*cloud_color );\n\n    float total = (c.x + c.y + c.z)/3.;\n    \n    c = mix( O, c , smoothstep(.40,.77, total) );  // not sure what it does         \n    O = mix( O, c , smoothstep(10.,-10.,d) );             \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d2yRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 94, 94, 232], [234, 246, 266, 266, 316], [318, 328, 348, 348, 372], [374, 374, 395, 395, 803], [806, 806, 835, 835, 1014], [1018, 1018, 1056, 1056, 1614]], "test": "untested"}
{"id": "ws2yWK", "name": "Webcam mirror-dome-sphere #6", "author": "rasmuskaae", "description": "Inverted fish eye. Simple.", "tags": ["sphere", "webcam", "mirror", "dome"], "likes": 7, "viewed": 767, "published": 3, "date": "1587370411", "time_retrieved": "2024-07-30T21:11:35.379517", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 center = vec2(0.5, 0.5);    \n    float intensity = 1.5;\n    \n    vec2 normalized = uv - center;\n    float dist = 1.0-sqrt(normalized.x*normalized.x+normalized.y*normalized.y);\n    normalized *= dist;    \n    \n    fragColor = texture(iChannel0, normalized+center)*((dist*intensity));\n }", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2yWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 443]], "test": "untested"}
{"id": "ts2yWK", "name": "Webcam fisheye #5", "author": "rasmuskaae", "description": "Simple fisheye effect for webcam", "tags": ["fisheye", "webcam"], "likes": 1, "viewed": 567, "published": 3, "date": "1587370189", "time_retrieved": "2024-07-30T21:11:36.274124", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 center = vec2(0.5, 0.5);    \n    float intensity = 1.5;\n    \n    vec2 normalized = uv - center;\n    float dist = sqrt(normalized.x*normalized.x+normalized.y*normalized.y);\n    normalized *= dist;    \n    \n    fragColor = texture(iChannel0, normalized+center)*(1.0-(dist*intensity));\n }", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2yWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 443]], "test": "untested"}
{"id": "WdjyDV", "name": "Practicing Truchet Tiling", "author": "kstyler", "description": "Following The Art of Code's tutorial on Truchet Tiling https://www.youtube.com/watch?v=2R7h76GoIJM", "tags": ["maze"], "likes": 1, "viewed": 372, "published": 3, "date": "1587368347", "time_retrieved": "2024-07-30T21:11:37.069997", "image_code": "float hash(vec2 p){\n\tp = fract(p*vec2(1253.4,567.8));\t\n    p+= dot(p,p+91.011);\n    return fract(p.x*p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 uv = fragCoord/iResolution.x;\n    uv+=iTime*0.1;\n    uv*=mat2(.7,-.7,.7,.7)*20.;\n\n    vec2 id = floor(uv);\n\tuv = fract(uv)-0.5;\n \n    \n    float rnd = hash(id);\n    if(rnd <0.5){\n    \tuv.x*=-1.;\n    }\n    float thickness = 0.25;\n    float blur= 20./iResolution.x;\n    \n    vec3 col = min(smoothstep(thickness-blur,thickness+blur,abs(vec3(uv.x+uv.y)-0.5)),\n                   smoothstep(thickness-blur,thickness+blur,abs(vec3(uv.x+uv.y)+0.5)))*vec3(1,.84,0.);\n\n  \n    fragColor = vec4((col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdjyDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 108], [110, 110, 166, 166, 678]], "test": "untested"}
{"id": "3sjcDV", "name": "Rainbow Temple - 276 chars", "author": "GregRostami", "description": "All credits goes to @yosshin4004.\nhttps://twitter.com/yosshin4004/status/1251357672504360966\nThis is a fork of vahidk's Infinite Tunnel.\nI just LOVE the shadows!\n\nA BIG thanks to Fabrice for helping me reduce the original shader.", "tags": ["raymarching", "2tweets", "short", "golf", "infinitetunnel"], "likes": 19, "viewed": 709, "published": 3, "date": "1587363334", "time_retrieved": "2024-07-30T21:11:37.822984", "image_code": "// Fork of \"Infinite Tunnel\" by vahidk. https://shadertoy.com/view/tdSyDG\n// 2020-04-20 06:00:14\nvoid mainImage(out vec4 O, vec2 U)\n{\n    vec3 R=iResolution,\n         d=vec3((U+U-R.xy)/R.y,1),\n         p=R-R, q;\n    for(p.z=.1*iTime; R.z++<1e2;\n        p += .5 * d * min( .65-length(fract(p+.5)-.5),p.y+.3) )\n        R.z==65. ? q=p-=d*.01,d+=1.-d : q;\n    ivec3 u = ivec3(q*5e2)&255;\n    O = vec4(u.yzx^u.zxy,0)/1e3*(length(p-q)+.8)+p.z*.1-.01*iTime;\n}\n\n// 263 chars - Thanks to Fabrice, everything gets shorter!!\n/*\n#define mainImage(O,U)                                            \\\n    vec3  R = iResolution,                                        \\\n          d = vec3((U+U-R.xy)/R.y, 1),                            \\\n          q, p=R-R;                                               \\\n    for (p.z = .1*iTime; O.a++ < 99.;                             \\\n         p += .5*d * min( .65-length(fract(p+.5)-.5), p.y + .3) ) \\\n         O.a==65. ? q = p -= d*.01, d += 1.-d : q;                \\\n    ivec3 u = ivec3(q*5e2) & 255;                                 \\\n    O = vec4( u.yzx ^ u.zxy, 0) / 1e3                             \\\n        * (length(p-q)+.8) + p.z*.1-.01*iTime\n\n\n// 259 chars - Shortest version, but I don't like the floor.\n\n#define mainImage(O,U)                                            \\\n    vec3  R = iResolution,                                        \\\n          d = vec3((U+U-R.xy)/R.y, 1),                            \\\n          q, p=R-R;                                               \\\n    for (p.z = .1*iTime; O.a++ < 99.;                             \\\n         p += .5*d * min( .65-length(fract(p+.5)-.5), p.y + .3) ) \\\n         O.a==65. ? q = p -= d*.01, d += 1.-d : q;                \\\n    ivec3 u = ivec3(q*5e2) & 255;                                 \\\n    O = vec4( u ^ u.zxy, 0) / 1e3                             \\\n        * (length(p-q)+.9) + p.z*.1-.01*iTime\n\n\n// 278 chars - Greg's Original Fork\n\n#define mainImage(O,U)                                                           \\\n    vec3 R = iResolution, d = vec3((U+U-R.xy)/R.y, 1), q, p=d-d; p.z = iTime*.1; \\\n    for (int i=0; i++<99; p += .5*d* min( .65-length(fract(p+.5)-.5), p.y + .3)) \\\n        i==60 ? q = p -= d*.01, d += 1.-d : q;                                   \\\n    ivec3 u = ivec3(q*5e2) & 255;                                                \\\n    O = vec4(u.x^u.y,u.y^u.z,u.x^u.z,0)/2e3 * (length(p-q)+.9) + (p.z-iTime*.1)*.1\n*/", "image_inputs": [{"id": 22223, "src": "https://soundcloud.com/filipnikolaevic/jean-michel-jarre-oxygen-8-magnetik-rmx", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sjcDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 97, 133, 133, 452]], "test": "untested"}
{"id": "3s2cDK", "name": "Raycasting Editor", "author": "Plento", "description": "Left/Right (Q/E) = Look ---- Up/Down (W/S) = Walk forwards / backwards. (D/A) = Strafe ------ Press 2 to toggle grid. Click on the grid to place walls. Hold 1 and click to erase walls.  Blue lines show FOV. Wall texture in Buf A. ", "tags": ["raycast", "keyboard", "firstperson", "editor"], "likes": 12, "viewed": 524, "published": 3, "date": "1587347283", "time_retrieved": "2024-07-30T21:11:38.765463", "image_code": "// Plento\n\n// You can place and delete walls in the grid.\n\n// Image = Graphics\n// Buffer A = wall texture (Try out different ones! or make custom one from here)\n// Buffer C = grid traversal\n// Buffer B = Input and map data.\n// Various params in common\n\n// ---CONTROLS---\n\n// Left/Right or Q/E = turn left/right\n// Up/Down or W/S = Walk forwards/backwards. \n// A/D = Walk sideways\n// Press 2 to toggle grid. \n// Click on the grid to place walls. \n// Hold 1 and click to erase walls.  \n// Blue lines show FOV. \n// Wall texture in Buf A. \n\n// I learned the traversal algorithm from this article: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.42.3443&rep=rep1&type=pdf\n\n// This is still a work in progress\n\nvec2 R;\n\n\nvec4 t(vec2 p){\n    return texelFetch(iChannel1, ivec2(p), 0);\n}\n\nfloat ln( in vec2 p, in vec2 a, in vec2 b ){\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n\nfloat grid(vec2 uv){\n    float th = 0.18;\n    \n    float g = smoothstep(th, th + .0025 , abs(uv.x)) *\n        smoothstep(th - .0025, th + .0025, abs(uv.y));\n    \n    return g;\n}\n\nint GetTile(vec2 id){\n    vec2 vs = R / gs; // Pixel size of cells\n    vec2 coord = (vs * id) + 1.; // Jump to cell in question\n    float val = texelFetch(iChannel1, ivec2(coord), 0).w; // Get cell value\n    \n    if(val == 1.)\n        return 1;\n    else if(val == 2.)\n        return 2;\n    else if(val == 0.)\n        return 0;   \n    else\n        return 0;\n    \n}\n\n\nvec3 Editor(vec2 ruv, vec2 uv, vec2 id, vec2 p, float a){\n    vec3 col = vec3(1);\n    \n    int tile = GetTile(id);\n    \n    if(tile == 1)\n     \tcol = vec3(0.0, 0.6, 0.0);\t   \n    \n\tcol *= grid(ruv); // Grid\n    \n    // Test FOV lines\n    col = mix(vec3(0.0, 0.0, 1.0), col, \n              smoothstep(0.004, 0.0041,ln(uv, p, vec2(p.x + 1.*cos(a - (FOV/2.)), p.y + 1.*sin(a - (FOV/2.))))));  \n    col = mix(vec3(0.0, 0.0, 1.0), col, \n              smoothstep(0.004, 0.0041,ln(uv, p, vec2(p.x + 1.*cos(a + (FOV/2.)), p.y + 1.*sin(a + (FOV/2.))))));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 f, in vec2 u )\n{\n    R = iResolution.xy;\n    vec2 nv = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec2 uv = u / R;\n    uv *= zoom;\n   \n    vec2 m = iMouse.xy / R.xy-.5; \n    m.x *= R.x/R.y;\n    \n    vec3 topdown = vec3(1);\n    vec3 graphics = vec3(0);\n    vec3 col = vec3(1);\n    \n    vec2 ruv = fract(uv*gs);\n    vec2 id = floor(uv*gs);\n    \n    // User input\n    vec4 h = texture(iChannel1, u / R);\n    \n    // Raycast data\n    vec4 ray = texture(iChannel2, u / R);\n    \n    // Player cell ID\n    vec2 pid = floor(h.xy*gs);\n    \n    // Toggle value for editor\n    float TWO = texelFetch( iChannel3, ivec2(50,2), 0 ).x; \n    float THREE = texelFetch( iChannel3, ivec2(51,0), 0 ).x; \n    \n    // Map editor color\n    topdown = Editor(ruv, uv, id, h.xy, h.z);\n   \n    ////// 3D graphics ///////\n    float height = (2. / ray.x)*.1;\n  \t\n    height *= 1.-step(FAR, ray.x);\n    \n    float fog = smoothstep(2.9, 0.0, ray.x);\n    vec3 skyCol = vec3(0., 0.8, 0.8);\n    vec3 groundCol = vec3(0.5);\n    \n    float a = atan(h.y, h.x);\n    \n    // 3D grid lines\n    vec2 vg = fract(ray.zw*gs - 0.5);\n    vec3 vgCol = vec3(1.0, 0.0, 0.0) * smoothstep(0.027, 0.024, abs((vg.y - vg.x)));\n    \n    if(nv.y >= height/2.){ // We are ABOVE wall\n        graphics = skyCol;    \n    }\n    else if(nv.y <= -height/2.){ // We are BELOW wall\n        graphics = groundCol;\n    }\n    else{ // We are ON the wall so lets figure out texture coordinates\n \t\t\n        // Normalized distance from uv y-coord to bottom of wall.\n        float sDist = (-height/2. - nv.y) / height;\n        \n        // Texture coordinate\n        vec2 tc = vec2((ray.z*8.0 - ray.w*4.0), sDist);\n        \n        // Get wall texture\n        vec3 wallCol = texture(iChannel0, -tc).xyz; \n        \n        graphics = (wallCol * fog); // Walls\n        //graphics += vgCol; // 3D grid lines\n    }\n    \n    \n    if(TWO == 1.)\n        col = mix(topdown, graphics, 0.55);\n    else\n        col = graphics;\n          \n    f = vec4(col, 1.0);\n    \n}\n\n\n\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// User input and map generation\nvec2 R;\n\nvec4 b(vec2 p){return texture(iChannel1, p / R);   }\n\nint GetTile(vec2 id){\n    vec2 voxSize = vec2(R.x / gs, R.y / gs);\n    \n    vec2 coord = (voxSize * id) + 1.;\n    \n    float val = texelFetch(iChannel1, ivec2(coord), 0).w;\n    \n    if(val > 0.)\n        return 1;\n    else\n \t\treturn 0;   \n}\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n    vec2 uv = u / R;\n    \n    vec2 m = iMouse.xy / R;\n    \n    uv *= zoom;\n    m *= zoom;\n    \n    \n    \n    // Map texture generation\n    vec2 id = floor(uv*gs);\n    vec2 mid = floor(m*gs);\n    \n    float space = texture(iChannel1, u / R).w;\n    \n    \n    // Editor controls\n    float ONE = 1.-texelFetch( iChannel0, ivec2(49,0), 0 ).x; \n    float TWO = 1.-texelFetch( iChannel0, ivec2(50,0), 0 ).x; \n    \n    // Player Controls\n    float left = texelFetch( iChannel0, ivec2(37,0), 0 ).x;\n    float right = texelFetch( iChannel0, ivec2(39,0), 0 ).x;\n    float up = texelFetch( iChannel0, ivec2(38,0), 0 ).x;\n    float down = texelFetch( iChannel0, ivec2(40,0), 0 ).x;\n    \n    float A = texelFetch( iChannel0, ivec2(65,0), 0 ).x;\n    float D = texelFetch( iChannel0, ivec2(68,0), 0 ).x;\n    float W = texelFetch( iChannel0, ivec2(87,0), 0 ).x;\n    float S = texelFetch( iChannel0, ivec2(83,0), 0 ).x;\n    \n    float Q = texelFetch( iChannel0, ivec2(81,0), 0 ).x;\n    float E = texelFetch( iChannel0, ivec2(69,0), 0 ).x;\n    \n    if(id == mid && iMouse.z > 0.){\n        space = ONE;\n    }\n    \n    vec4 p = b(u); // (posX, posY, lookAngle, space)\n    \n    vec2 pid = floor(p.xy*gs);\n    \n    p.z -= turnSpeed * left;\n    p.z += turnSpeed * right;\n    \n    p.z -= turnSpeed * Q;\n    p.z += turnSpeed * E;\n    \n    \n    p.y += walkSpeed * up * sin(p.z);\n    p.y -= walkSpeed * down * sin(p.z);\n    p.x += walkSpeed * up * cos(p.z);\n    p.x -= walkSpeed * down * cos(p.z);\n    \n    p.y += walkSpeed * W * sin(p.z);\n    p.y -= walkSpeed * S * sin(p.z);\n    p.x += walkSpeed * W * cos(p.z);\n    p.x -= walkSpeed * S * cos(p.z);\n    \n    p.y -= walkSpeed * A * sin(p.z+pi/2.);\n    p.y += walkSpeed * D * sin(p.z+pi/2.);\n    p.x -= walkSpeed * A * cos(p.z+pi/2.);\n    p.x += walkSpeed * D * cos(p.z+pi/2.);\n    \n    \n    \n    \n     if(iFrame<5){\n        space = 0.;\n        p.x = 0.1;\n        p.y = 0.5;\n         \n        if(id.y == 10. || id.y == 20. || id.x == 26.)\n            space = 1.0;\n         \n         \n         \n     }\n    \n    f = vec4(p.xyz, space);\n}\n\n\n\n\n\n", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float pi = 3.14159;\n\nfloat gs = 32.; // Grid Size\nfloat zoom = 1.0;\n\nfloat steps = 90.; // Traversal steps\n\n#define FAR 100.\n\n// Player parameters\nfloat walkSpeed = 0.006;\nfloat turnSpeed = 0.01;\n\n//float FOV = 1.0708;\n//float FOV = 1.0;\n\nfloat FOV = pi/3.5;\nfloat DIST = 10.;", "buffer_c_code": "// Grid traversal and distance calculations\n\nvec2 R;\n\n\nvec4 t(vec2 p){\n    return texelFetch(iChannel1, ivec2(p), 0);   \n}\n\n\nint GetTile(vec2 id){\n    vec2 voxSize = vec2(R.x / gs, R.y / gs);\n    vec2 coord = (voxSize * id) + 1.;\n    float val = texelFetch(iChannel1, ivec2(coord), 0).w;\n    \n    if(val > 0.)\n        return 1;\n    else\n \t\treturn 0;   \n}\n\n\n// Voxel traversal\nvec4 ray(vec2 uv, vec2 p, vec2 pid, float a, float difa)\n{\n    // Set up a point which passes through the ray.\n    vec2 v = 1.*vec2(cos(a), sin(a));\n    vec2 rd = p + v;\n    \n    // The signs of ray direction which tells us which cell boundries to worry about.\n    float stepX = sign(v.x);\n    float stepY = sign(v.y);\n    \n    vec2 rp = p;\n    \n    float d = 0.;\n    float n = 0.;\n    \n    for(float i = 0.0; i < steps; i++){\n        // Determine where the lines we want to intersect are on the screen depending on what cell we're in. \n        // and the direction we're looking.\n    \tfloat offX = (step(0., stepX) + pid.x) / gs; // Vertical lines.\n    \tfloat offY = (step(0., stepY) + pid.y) / gs; // Horizontal lines.\t   \n        \n        // Calculate t value on ray for both the horizontal and vertical lines in question.\n        float tMaxX = (offX - p.x) / (v.x);\n    \tfloat tMaxY = (offY - p.y) / (v.y);\n        \n        // The minimum of the two tells us how far we can travel in the current cell without leaving it.\n        float t = (min(tMaxX, tMaxY));\n        \n        // Calculate intersection point.\n        rp = (0.9999 - t)*p + (t + 0.0001)*rd;\n        \n        // Set new cell id for the ray position.\n    \tpid = floor(rp*gs);\n        \n        \n        // Check if new id has an object in the way.\n        if(GetTile(pid)==1){\n            // Ray perpandicular distance to wall\n            d = length(rp - p);\n            d = d*cos(difa); // FIX FISHEYE\n            \n            // \"normal\" of wall\n            n = step(tMaxX, tMaxY);\n            \n            return vec4(d, n, rp);\n            \n     \t\tbreak;\t   \n        }\n    \t\n    }\n     \n    d = FAR;\n    \n    return vec4(d, n, pid);\n}\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n    vec2 uv = u / R;\n    uv *= zoom;\n    \n    // Player data\n    vec4 h = texture(iChannel1, u / R); // (posX, posY, angle, mapData)\n   \n    vec2 p = h.xy; // Player world coord\n    vec2 pid = floor(p*gs); // player cell id\n    \n    float adx = FOV / R.x; // Angular step: How much we rotate the ray over one X pixel coord. \n    \n    //float adx = atan((u.x - (R.x*.5)) / tan(h.z));\n    \n    float ra = h.z + (adx*u.x) - (FOV/2.); // Ray angle\n    float difa = ra - h.z; // The angle between the ray angle and the initial look angle is what we want to \n    \t\t\t\t\t\t// use to calculate the perpendicular distance to a wall. \n    \t\t\t\t\t\t \n    vec4 r = ray(uv, p, pid, ra, difa);\n    \n    f = vec4(r.x,r.y,r.zw); // (ray distance, wall \"normal\", hit location)\n}\n\n\n\n\n\n\n\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Texturing\n\nvec2 R;\n\n\nvoid mainImage( out vec4 f, in vec2 u )\n{\n    R = iResolution.xy;\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n   \n    vec4 col = vec4(1);\n    //uv.x *= .5;\n    \n    //vec2 id = floor(uv*10.);\n    //float checker = mod(id.x + id.y, 2.0);\n    //col = vec4(0.6, 0.3, 0.3,1.) * checker;\n    \n    col = texture(iChannel0, u / R);\n    \n    f = col;\n}", "buffer_a_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2cDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[724, 724, 739, 739, 788], [790, 790, 834, 834, 953], [955, 955, 974, 974, 1026], [1029, 1029, 1049, 1049, 1206], [1208, 1208, 1229, 1229, 1571], [1574, 1574, 1631, 1631, 2142], [2144, 2144, 2185, 2185, 4140]], "test": "untested"}
{"id": "3d2yDK", "name": "Temporal van Damme", "author": "michael0884", "description": "slicing van damme with the timey-wimey stuff thing", "tags": ["video", "slice"], "likes": 4, "viewed": 311, "published": 3, "date": "1587338227", "time_retrieved": "2024-07-30T21:11:39.526429", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 prev = texture(iChannel0, uv);\n    vec2 uvslice = vec2(uv.x, uv.y);\n    if(abs(fragCoord.y - mod(float(iFrame),iResolution.y)) < 1. )\n    {\n        fragColor = texture(iChannel1, uvslice);\n    }\n    else\n    {\n        fragColor = prev;\n    }\n}", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d2yDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 140]], "test": "untested"}
{"id": "3djyzt", "name": "S p a c e   T r a v e l", "author": "Plento", "description": "I hope somewhere out there something like this is happening all the time for no reason at all.", "tags": ["3d", "raymarch"], "likes": 13, "viewed": 399, "published": 3, "date": "1587337087", "time_retrieved": "2024-07-30T21:11:40.387128", "image_code": "vec2 R;\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n    vec2 nuv = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec2 uv = u / R;\n    \n    vec3 col = texture(iChannel0, u / R).xyz;\n    \n    float h = 0.0025;\n    float r = texture(iChannel0, uv+vec2(h, h)).x;\n    float g = texture(iChannel0, uv+vec2(0., 0.)).y;\n    float b = texture(iChannel0, uv+vec2(-h, -h)).z;\n    \n    float val = smoothstep(0.35, 0.0, length(nuv));\n    col = mix(col, vec3(r, g, b), val);\n   \n    f = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Plento\nvec2 R;\n\n#define ss(a, b, x) smoothstep(a, b, x)\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n#define doorX min(min(mod(iTime*.5, 2.), 0.4), mod(-iTime*.5, 2.))\n#define count floor(mod(iTime/4., 3.))\n\nfloat sdBox( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdTorus( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat map(vec3 rp){\n    float d = 999.;\n    \n    d = min(d, sdBox(rp - vec3(0.0, -0.6, 0.0), vec3(1., 0.1, 1.)));\n    d = min(d, sdBox(rp - vec3(0.0, 0.6, 0.0), vec3(1., 0.1, 1.)));\n    d = min(d, sdBox(rp - vec3(0.8, 0.0, 0.0), vec3(.1, .6, 1.0)));\n    d = min(d, sdBox(rp - vec3(-0.8, 0.0, 0.0), vec3(.1, .6, 1.0)));\n    \n    // Doors\n    d = min(d, sdBox(rp - vec3(0.7 + doorX, 0.0, 1.0), vec3(.7, .7, 0.01)));\n    d = min(d, sdBox(rp - vec3(-0.7 - doorX, 0.0, 1.0), vec3(.7, .7, 0.01)));\n    \n    vec3 p = rp - vec3(0., 0., 7.);\n    \n    if(count == 0.){\n        p.xz *= rot(iTime);\n    \td = min(d, sdBox(p, vec3(1., 1., 1.)));\n    }\n    else if(count == 1.){\n        p.xz *= rot(iTime*.4);\n        p = mod(p, vec3(2))-vec3(2)*0.5;\n        d = min(d, length(p) - 0.3);\n    }\n    else if(count == 2.)\n    {\n        p.yz *= rot(iTime*1.7 + p.x*1.4);\n     \td = min(d, sdTorus(p, vec2(1.4, 0.2)));   \n        \n    }\n        \n    return d;\n}\n\nvec3 normal( in vec3 pos ){\n    vec2 e = vec2(0.002, -0.002);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\nfloat march(vec3 rd, vec3 ro){\n \tfloat t = 0., d = 0.;   \n    \n    for(int i = 0; i < 64; i++){\n    \td = map(ro + rd*t); \t   \n        if(abs(d) < .002 || t > 64.){break;}\n        \n        t += d * .85;\n    }\n    \n    return t;\n}\n\nvec3 bg(vec3 rd){\n    rd.xy *= rot(iTime*0.15 - rd.z*5.);\n    vec3 col = vec3(0);\n    float scl = mod(-iTime*.1, 0.5);\n    float scl2 = mod(-iTime*.1 + .25, 0.5);\n    \n    col += ss(0.86, 0.99, texture(iChannel0, scl*rd.xy).x);\n    col *= ss(0.4, 0.1, scl);\n    \n    col += ss(0.86, 0.99, texture(iChannel0, scl2*rd.xy).x);\n    col *= ss(0.4, 0.1, scl2*0.65);\n    \n    return col;\n}\n\n\nvec3 color(vec3 p, vec3 rd, vec3 n, float t){\n    vec3 lp = vec3(0.2, -9.0, 4.0);\n    vec3 ld = normalize(lp-p);\n   \tvec3 ref = reflect(rd, n );\n    \n    float faloff = 1.-exp(-(4. / length(lp - p)));\n    float dom = ss(-0.0, 0.3, ref.y+.1);\n    float dif = max(dot(n, ld), .035);\n    \n    vec3 col = vec3(0);\n    vec3 mat = vec3(0);\n    vec3 lights = ((.15*dom*vec3(0.7,0.7,0.9)*dom) + (1.75*dif * faloff));\n    \n    if(p.z < 1.2){\n    \tif(abs(n.y) > 0.5){\n        \tvec2 id = floor(p.xz*7.);\n        \tfloat chk = mod(id.x+id.y,2.);\n            \n        \tcol = mix(vec3(0.1, 0.2, 0.3), vec3(0),chk);\n        \t\n    \t\tfloat x = abs(p.x);\n    \t\tfloat val = ss(x, x+0.03, doorX);\n        \tcol *= val+.02;\n        \t\n        \tcol = mix(col, (bg(ref)+0.01), val*.11*chk);   \n        }\n        else{\n    \t\tcol = vec3(.4)*abs(sin(p.y*3.16 + 1.57))+.0;\n    \t\tcol *= lights;\n        }\n    }\n    else{\n        if(count == 0.)\n            mat = vec3(0.8, 0.2, 0.2);\n        else if(count == 1.){\n            p.z -= 7.;\n            p.xz *= rot(iTime*.4);\n            mat = hash33(floor((p-.5)/3.)*102.4+342.);\n        }\n        else if(count == 2.)\n            mat = vec3(0.6, 0.4, 0.0);\n        \n        col = mat * lights;\n    \tcol = mix(col, bg(rd), step(10., t));   \t   \n    }\n    \n\treturn col;   \n}\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    vec3 rd = normalize(vec3(uv, 0.6));\n    vec3 ro = vec3(0., 0., -.4);\n    \n    rd.xy *= rot(sin(iTime*2.)*.07);\n    rd.yz *= rot(cos(iTime*2.)*.07);\n    \n    float t = march(rd, ro);\n    \n    vec3 n = normal(ro + rd*t);\n    vec3 col = color(ro + rd*t, rd, n, t);\n    \n    col *= ss(0.5, 0.3, abs(uv.y));\n    \n    f = vec4(sqrt(clamp(col, .0, 1.)), 1.);\n    \n}\n\n\n", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djyzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[9, 9, 49, 49, 498]], "test": "untested"}
{"id": "3djcWK", "name": "Celerity", "author": "wyatt", "description": "A study on the speed of sound and its correspondence to density. ", "tags": ["fluid"], "likes": 21, "viewed": 597, "published": 3, "date": "1587333875", "time_retrieved": "2024-07-30T21:11:41.217907", "image_code": "Main {\n    Neighborhood;\n    vec2 g = vec2(e.w*e.z-w.z*w.w,n.z*n.w-s.z*s.w);\n    vec3 no = normalize(vec3(g,.01));\n    vec3 re = reflect(no,vec3(0,0,1));\n\tQ = 0.5+0.5*(1.-100.*length(g))*sin(abs(A(U).wwww)*3.1+3.1+vec4(1,2,3,4));\n\tQ *= 0.8+0.2*texture(iChannel3,re);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n\n#define Main void mainImage(out vec4 Q, vec2 U) \n\n#define Neighborhood vec4 n = A(U+vec2(0,1)), e = A(U+vec2(1,0)), s = A(U-vec2(0,1)), w = A(U-vec2(1,0));\n\n#define Border if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.) Q.xy*=0.;", "buffer_a_code": "Main {\n\tQ = A(U);\n    Neighborhood;\n    Q.xy -= 0.25*vec2(e.z-w.z,n.z-s.z)*Q.w;\n    \n    if (iMouse.z>0.) {\n    \tif (length(U-iMouse.xy)<20.) Q.xyw=vec3(.2*cos(iTime),.2*sin(iTime),0.5+0.5*sin(iTime));\n    }\n    else if (length(U-vec2(.8,.2)*R)<10.)Q.xyw=vec3(-.3,.8,.6);\n    \n    Border;\n    if(iFrame < 1) Q = vec4(0,0,0,max(U.x/R.x-0.2,0.));\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n\tQ = A(U);\n    Neighborhood;\n    Q.z -= 0.25*(e.x*e.w-w.x*w.w+n.y*n.w-s.y*s.w);\n    Border;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n    Neighborhood;\n    U -= 0.25*(n.xy+e.xy+s.xy+w.xy);\n\tQ = A(U);\n    Border;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n    Neighborhood;\n\tQ = A(U);\n    Q.w -= 0.25*(n.w*n.y-s.w*s.y+e.x*e.w-w.x*w.w);\n    Border;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djcWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WdBcDV", "name": "LCH Chroma Key", "author": "pohlt", "description": "Green screen shader using LCH color space. Not yet fully done.", "tags": ["greenscreen", "chromakey"], "likes": 2, "viewed": 543, "published": 3, "date": "1587329723", "time_retrieved": "2024-07-30T21:11:42.080600", "image_code": "#define PI 3.141592653589793f\n#define PI_INV 0.3183098861837907f\n\n\nconst mat3x3 conv_rgb2xyz = mat3x3(0.4124, 0.3576, 0.1805,\n                                   0.2126, 0.7152, 0.0722,\n                                   0.0193, 0.1192, 0.9505);\n\nvec3 rgb2xyz(vec3 rgb) {\n    if (rgb.r > 0.04045)\n        rgb.r = pow(((rgb.r+0.055)/1.055), 2.4);\n    else\n        rgb.r = rgb.r / 12.92;\n\n    if (rgb.g > 0.04045)\n        rgb.g = pow(((rgb.g+0.055)/1.055), 2.4);\n    else\n        rgb.g = rgb.g / 12.92;\n\n    if (rgb.b > 0.04045)\n        rgb.b = pow(((rgb.b+0.055)/1.055), 2.4);\n    else\n        rgb.b = rgb.b / 12.92;\n\n    return rgb * conv_rgb2xyz;\n    \n    vec3 xyz;\n    xyz.x = rgb.r * 0.4124 + rgb.g * 0.3576 + rgb.b * 0.1805;\n\txyz.y = rgb.r * 0.2126 + rgb.g * 0.7152 + rgb.b * 0.0722;\n\txyz.z = rgb.r * 0.0193 + rgb.g * 0.1192 + rgb.b * 0.9505;\n\n    //xyz = rgb*conv_rgb2xyz;\n    return xyz;    \n}\n\n\nvec3 xyz2lab(vec3 xyz) {\n    // Observer= 2A, Illuminant= D65\n    // x_ref=95.047, y_ref=100., z_ref=108.883\n\n    const vec3 ref = vec3(0.95047, 1.0, 1.08883);\n\n    xyz /= ref;\n\n    if (xyz.x > 0.008856)\n        xyz.x = pow(xyz.x, 1.0/3.0);\n    else\n        xyz.x = (7.787*xyz.x) + (16.0/116.0);\n\n    if (xyz.y > 0.008856)\n        xyz.y = pow(xyz.y, 1.0/3.0);\n    else\n        xyz.y = (7.787*xyz.y) + (16.0/116.0);\n\n    if (xyz.z > 0.008856)\n        xyz.z = pow(xyz.z, 1.0/3.0);\n    else\n        xyz.z = (7.787*xyz.z) + (16.0/116.0);\n\n    return vec3(\n        (1.16 * xyz.y) - 0.16,\n    \t5.0 * (xyz.x - xyz.y),\n    \t2.0 * (xyz.y - xyz.z));\n}\n\n\nvec3 lab2lch(vec3 lab) {\n    return vec3(\n        lab.x,\n        length(lab.yz),\n        atan(lab.z, lab.y)*(0.5*PI_INV) + 0.5\n    );\n}\n\n\n#define LUM_MAX 1.2\n#define LUM_BLUR 0.1\n#define CHROMA_MIN 0.3\n#define CHROMA_BLUR 0.1\n#define HUE_MIN 0.82\n#define HUE_MAX 0.93\n//#define HUE_MIN 0.6\n//#define HUE_MAX 0.7\n#define HUE_BLUR 0.02\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 muv = iMouse.xy/iResolution.xy;\n\n    vec3 webcam = texture(iChannel2, uv).rgb;      // alpha: 0.0\n    webcam *= 0.75+0.25*sin(50.0*uv.x);\n    webcam.r += 0.15*sin(50.0*uv.y);\n    //webcam = vec3(uv, 0.5);\n    \n    vec3 background = texture(iChannel1, uv).rgb;  // alpha: 1.0\n    //background = vec3(1.0, 0, 0);\n        \n    vec3 webcam_lch = lab2lch(xyz2lab(rgb2xyz(webcam)));\n        \n    float delta_lum     = LUM_MAX - webcam_lch.x;\n    float delta_chroma  = webcam_lch.y - CHROMA_MIN;\n    float delta_hue_min = webcam_lch.z - HUE_MIN;\n    float delta_hue_max = HUE_MAX - webcam_lch.z;\n    \n    float alpha_lum    = smoothstep(0.0, LUM_BLUR, delta_lum);\n    float alpha_chroma = smoothstep(0.0, CHROMA_BLUR, delta_chroma);\n    float alpha_hue    = smoothstep(0.0, HUE_BLUR, min(delta_hue_min, delta_hue_max));\n    \n    float alpha = min(min(alpha_lum, alpha_chroma), alpha_hue);\n   \t//alpha = alpha_hue;\n    \n    fragColor = vec4(mix(webcam, background, alpha), 1);\n    \n    \n    if (muv.x < 0.1 || muv.x > 0.9) muv.x = 0.5+0.5*sin(iTime);\n    if (uv.x > muv.x) fragColor.rgb = webcam.rgb;\n    \n    // output LCH\n    //fragColor = vec4(lab2lch(xyz2lab(rgb2xyz(webcam))), 1);\n    //fragColor = vec4(webcam_lch.x, 0, 0, 1);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdBcDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[246, 246, 270, 270, 898], [901, 901, 925, 1009, 1542], [1545, 1545, 1569, 1569, 1680], [1881, 1881, 1938, 1988, 3264]], "test": "untested"}
{"id": "3sByRc", "name": "大龙猫 - Quicky#035", "author": "totetmatt", "description": "3Ding\nKind of like the unintentional  color / cellshading like effect ", "tags": ["quicky"], "likes": 4, "viewed": 339, "published": 3, "date": "1587322714", "time_retrieved": "2024-07-30T21:11:42.928333", "image_code": "\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n#define ITER 32.\n#define PI 3.141592\n#define bpm iTime * (130/60)\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\nmat2 r(float a){\n    float c=cos(a),s=sin(a);\n    return mat2(c,s,-s,c);\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat fig(vec3 p,float offset) {\n     p.yz = p.zy;\n     p.xy*=r(p.z*2.+iTime+offset);\n     \n     \n     //float t = fract(iTime*.1)*10. <= 5. ? iTime*8. : floor(iTime*8.) ;\n     float  t = iTime*4.;\n     return sdTorus(p,vec2(.4+sin(offset+t+atan(p.x,p.z)*6.)*.2+.75,.05))*.4;\n}\nvec2 SDF(vec3 p) {\n     float f = 100.;\n     float id = 0.;\n     for(float i=0.;i<=1.;i+=1./6.){\n         float o = fig(p,i*acos(-1.)/(4.+sin(iTime+i)));\n         \n         f = min(f,o);\n         if(f == o) id = i;\n     \n     }\n     \n     return vec2(id,f);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n     \n    vec3 ro =vec3(0.,0.,-3.),\n    p = ro,\n    rd = normalize(vec3(uv,1.)),\n    col = vec3(0);\n     \n    float shad = 0.;\n    bool hit = false;\n    vec2 d = vec2(0.);\n    for(float i=0.;i < ITER; i++) {\n        d = SDF(p);\n        if(d.y< 0.001) {\n            hit = true;\n            shad = i / ITER;\n            break;\n        }\n        p += d.y*rd;\n    }\n    \n    if(hit) {\n      \n        col = vec3(1.-shad*d.x,1.10*shad*(1./d.x),smoothstep(.1,0.9,d.x));\n      \n\n    }\n    \n     \n     \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sByRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 38, 38, 121], [188, 188, 241, 241, 300], [301, 301, 317, 317, 375], [376, 376, 409, 409, 474], [475, 475, 507, 507, 752], [753, 753, 771, 771, 1012], [1013, 1013, 1068, 1068, 1659]], "test": "untested"}
{"id": "wsSyWV", "name": "Ink-Marbling Fractal", "author": "jarble", "description": "This is based on my [url=https://www.shadertoy.com/view/tlGSDG]\"Swamps and Tundras\"[/url] fractal. It looks very much like suminagashi.\nClick and drag the mouse to zoom in and out!", "tags": ["fractal", "marbling", "suminagashi"], "likes": 1, "viewed": 332, "published": 3, "date": "1587322404", "time_retrieved": "2024-07-30T21:11:43.730190", "image_code": "\n//This parameter changes the number of iterations.\nconst float mag = 9.0;\nconst float GREEN = 0.;\nconst float BLUE = 1.;\nconst float GRAY = 2.;\nconst float YELLOW = 3.;\nconst float WHITE = 4.;\nconst float RED = 5.;\n\n\n//this function is from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n    float num_colors = 5.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return floor(fract((p3.x + p3.y) * p3.z)*num_colors);\n}\n    \n\n\nfloat magnify(vec2 fragCoord,float mag){\n    return hash12(floor(fragCoord/pow(3.0,mag)));\n}\n\nvec4 get_neighbors(vec2 fragCoord,float mag){\n    return vec4(magnify(fragCoord+vec2(0,1),mag),\n        magnify(fragCoord+vec2(1,0),mag),\n        magnify(fragCoord-vec2(0,1),mag),\n        magnify(fragCoord-vec2(1,0),mag));\n}\n\n\nbool is_next_to(float color,vec4 neighbors){\n\treturn (neighbors.x == color)\n        || (neighbors.y == color)\n        || (neighbors.z == color)\n        || (neighbors.w == color);\n}\n\n\n\nvec3 get_color(float color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == RED){\n    \treturn vec3(1.0,0.0,0.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n}\n\nvec3 iterations(float color1,in vec2 fragCoord,float mag){\n    float colors[] = float[](GREEN,BLUE,GRAY,YELLOW,WHITE,RED);\n    float mag1 = mag;\n    vec4 neighbors;\n    vec3 color;\n    float steps = 0.0;\n    while(mag > 1.0){\n        float avg =(100.0*(mag/color1));\n        fragCoord += vec2(sin(fragCoord.y/avg)*10.0,sin(fragCoord.x/(avg))*10.0)*mag*mag;\n\n        neighbors = get_neighbors(fragCoord,mag);\n    color1 = color1 == GREEN && is_next_to(BLUE,neighbors)\n    \t? YELLOW\n    :color1 == BLUE && is_next_to(GREEN,neighbors)\n        ? GREEN\n    :color1 == YELLOW && is_next_to(GRAY,neighbors)\n        ? BLUE\n    :color1 == GRAY && is_next_to(YELLOW,neighbors)\n        ? YELLOW\n    :color1 == WHITE && is_next_to(YELLOW,neighbors)\n        ? GRAY\n    :color1 == GRAY && is_next_to(BLUE,neighbors)\n        ? BLUE\n    :color1;\n\n    color += get_color(color1);\n    //mag -= 1.0+(sin(fragCoord.x+iTime)+cos(fragCoord.y+iTime))*0.0002;\n    mag -= 1.0;\n    steps += 1.0;\n\n    }\n    return color/steps;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord *= mag*(((iMouse.x-iMouse.y)+iResolution.x)/iResolution.x);\n    fragCoord = fragCoord + floor(iTime*100.0)*vec2(mag,0.0);\n    fragCoord += vec2(sin(fragCoord.y/(100.0*(mag)))*10.0,sin(fragCoord.x/(100.0*(mag)))*10.0)*mag*mag;\n\n    float color1 = magnify(fragCoord,mag);\n    //color1 = replace_pattern(mat2(1.0,1.0,1.0,1.0),mat2(0.0,2.0,2.0,0.0),fragCoord,mag);\n\n    vec3 color2 = iterations(color1,fragCoord,mag-1.0);\n\n    fragColor = vec4(color2,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsSyWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[218, 280, 302, 302, 529], [537, 537, 577, 577, 629], [631, 631, 676, 676, 855], [858, 858, 902, 902, 1038], [1042, 1042, 1070, 1070, 1484], [2491, 2491, 2547, 2547, 3016]], "test": "untested"}
{"id": "WdByDV", "name": "Sky Scattering (SS12)", "author": "angelo12", "description": "Sky Scattering based on https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky/simulating-colors-of-the-sky", "tags": ["shadersundays"], "likes": 6, "viewed": 1562, "published": 3, "date": "1587313616", "time_retrieved": "2024-07-30T21:11:44.915022", "image_code": "/*\n\tShader Sundays! (12/52) \n\t\"Sky Scattering\"\n\t\n\t!LEFT CLICK FOR FISHEYE LENS!\n\t\n\tHello There! I'm about 4 weeks late with this shader but I'm going to go ahead and \n\tblame the global pandemic for being late on this one. This time a rather simple shader\n\tin size, but not in scope. I still don't understand fully the background for volumetric\n\trendering but I'm happy with this as a first experiment. I've based most of the code\n\ton the teachings of scratchapixel but consulted many papers / articles / shaders in\n\tthe process.\n\t\n\tHere are the best ones I found: \n\thttps://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky/simulating-colors-of-the-sky\n\thttps://www.shadertoy.com/view/XtBXDz#\n\thttp://www.pbr-book.org/3ed-2018/Volume_Scattering.html\n\thttp://www-ljk.imag.fr/Publications/Basilic/com.lmc.publi.PUBLI_Article@11e7cdda2f7_f64b69/article.pdf\n\thttps://media.contentapi.ea.com/content/dam/eacom/frostbite/files/s2016-pbs-frostbite-sky-clouds-new.pdf\n\thttp://publications.lib.chalmers.se/records/fulltext/203057/203057.pdf\n\t\n\tNow, let's see how quickly can I make up for these missed four weeks....\n*/\n\n//const variables\nconst float S_Luminance = 20.0;\nconst float R_earth     = 6360e3;\nconst float R_atmo      = 6420e3;\nconst float H_Air       = 7994.0; \nconst float H_Aerosols  = 1200.0; \nconst vec3 betaRayleigh = vec3(3.8e-6f, 13.5e-6f, 33.1e-6f); \nconst vec3 betaMie = vec3(21.0e-6);\nconst int numSamples_View = 16;\nconst int numSamples_Sun  = 8;\n\n//uniforms\nfloat time = 0.0;\nvec3 sunDir = vec3(0.0);\n\nfloat\nrayleighPhaseFunction(float mu)\n{\n    return \n           3.0 * (1.0 + mu*mu)\n    / //----------------------\n            (16.0 * M_PI);\n}\n\nfloat\nhenyeyGreensteinPhaseFunc(float mu)\n{\n    const float g = 0.76;\n    return\n                        (1. - g*g)\n    / //---------------------------------------------\n        ((4. * M_PI) * pow(1. + g*g - 2.*g*mu, 1.5));\n}\n\nbool\nRayIntersectSphere(vec3 ro, vec3 rd, vec3 sOrigin, float r, inout float t0, inout float t1)\n{\n    ro -= sOrigin;\n    float A = dot(rd, rd);\n    float B = 2.0 * dot(ro, rd);\n    float C = dot(ro, ro) - r*r;\n    float discriminant = B*B - 4.0*A*C;\n\n    //Ray never hits sphere\n    if(discriminant < 0.0) return false;\n\n    t0 = (-B - sqrt(discriminant)) / 2.0*A ;\n    t1 = (-B + sqrt(discriminant)) / 2.0*A ;\n\n    return true;\n}\n\nvec3\nRender(vec3 ro, vec3 rd)\n{\n    //Ray setup -> view ray\n    float t0_View, t1_View;\n    vec3 densityAir_View, densityAerosols_View;\n    vec3 totalRayleigh, totalMie;\n\n    //Atmosphere intersection -> view ray\n    bool hit = RayIntersectSphere(ro, rd, vec3(0.0), R_atmo , t0_View, t1_View);\n    if(!hit) return totalRayleigh; //Empty value\n\n    //Phase functions\n    float mu = dot(rd, sunDir);\n    float phaseRayleigh = rayleighPhaseFunction(mu);\n    float phaseMie = henyeyGreensteinPhaseFunc(mu);\n\n    //Ray marching -> view ray\n    float stepSize_View = t1_View / float(numSamples_View);\n    float t_View = 0.0; \n    for(int i = 0; i < numSamples_View; ++i)\n    {\n        //Ray pos and height\n        vec3 pos_View = ro + rd*(t_View + stepSize_View * 0.5);\n        float height_View = length(pos_View) - R_earth;\n\n        //Density at current location\n        float airDensityAtPos_View = exp(- height_View / H_Air ) * stepSize_View;\n        float aerosolDensityAtPos_View = exp(-height_View / H_Aerosols) * stepSize_View;\n        densityAir_View += airDensityAtPos_View;\n        densityAerosols_View += aerosolDensityAtPos_View;\n\n        //Ray setup -> Sun ray\n        vec3 densityAir_Sun, densityAerosols_Sun;\n        float t0_Sun, t1_Sun;\n\n        //Atmosphere intersection -> Sun ray\n        RayIntersectSphere(pos_View, sunDir, vec3(0.0), R_atmo , t0_Sun, t1_Sun);\n\n        //Raymarching from point in view ray -> sunDir\n        float t_Sun = 0.0; \n        float stepSize_Sun = t1_Sun / float(numSamples_Sun);\n        bool hitGround = false;\n        for(int i =0; i < numSamples_Sun; ++i)\n        {\n            //Ray pos and height\n            vec3 pos_Sun = pos_View + sunDir * (t_Sun + stepSize_Sun * 0.5);\n            float height_Sun = length(pos_Sun) - R_earth;\n            \n            //Early out if you're in earth shadow\n            if(height_Sun < 0.)\n            {\n                 hitGround = true;\n                 break;\n            }\n\t\t\t\n            //Density at current location\n            densityAir_Sun      += exp(-height_Sun / H_Air)      * stepSize_Sun;\n            densityAerosols_Sun += exp(-height_Sun / H_Aerosols) * stepSize_Sun;\n\n            t_Sun += stepSize_Sun;\n        }\n\n        //Earth shadow\n        if(!hitGround) \n        {\n            //Multiplication of exponentials == sum of exponents\n            vec3 tau = betaRayleigh * (densityAir_View);\n            tau += betaMie * 1.1 * (densityAerosols_Sun + densityAerosols_View); \n            vec3 transmittance = exp(-tau);\n\n            //Total scattering from both view and sun ray direction up to this point\n            totalRayleigh += airDensityAtPos_View * transmittance;\n            totalMie      += aerosolDensityAtPos_View * transmittance;\n        }\n\t\t\n        t_View += stepSize_View;\n    }\n\n    return S_Luminance * (totalRayleigh * phaseRayleigh * betaRayleigh +\n                          totalMie * phaseMie * betaMie );\n}\n\nvoid \nmainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //Init common vars\n    time = iTime / 15.0;\n    const bool fishEye = true;\n    const bool mouseControl = false;\n\n    sunDir = normalize(vec3(cos(time), abs(sin(time)) - 0.2, 0.0));\n    if(mouseControl)\n        sunDir = normalize(vec3(iMouse.xy,0.0));\n    \n    vec3 col = vec3(0.0);\n\n    //Common Camera setup\n    vec3 rayOrigin = vec3(0, R_earth + 1.0 , 0.0);\n    vec2 uv = 2.0 *  (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n\n    vec3 rayDirection_WS;\n    if(fishEye && iMouse.z < 0.1)\n    {\n\t\t//Pinhole camera\n        vec3 target = rayOrigin + vec3(1.0, 0.0, 0.0);\n        const float nearPlane = 1.0;\n        rayDirection_WS = SetCamera(rayOrigin, target, 0.0) * normalize(vec3(uv, nearPlane));\n    }\n    else\n    {\n                //Fisheye camera\n        const float hemisphereRadius = 1.0;\n        float length2 = dot(uv, uv);\n        if(length2 > hemisphereRadius) return;\n        float phi = atan(uv.y, uv.x); \n        float theta = acos(sqrt((hemisphereRadius - length2)));\n        rayDirection_WS = vec3(sin(theta) * cos(phi),\n                           cos(theta),\n                           -sin(theta) * sin(phi));\n        \n    }\n\n    col = Render(rayOrigin, rayDirection_WS);\n\n    GAMMA(col);\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "#define INV_GAMMA  0.454545\n#define M_PI acos(-1.0)\n#define M_TAU M_PI*2.0\n\n//Comment this out if running this file on shadertoy\n#define SHADERTOY \n\n//------------------------------------------------------------------------------------\n//----------------------------------SDF Shaping functions-----------------------------\nfloat\nsdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat \nsdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat\nsdGroundPlane(vec3 p)\n{\n    return p.y;\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------SDF Joining functions-----------------------------\n#define UOP(dist, ID) res = uop(res, vec2(dist, ID))\nvec2\nuop(vec2 a, vec2 b)\n{\n    return (a.x < b.x) ? a : b;\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Rotation functions--------------------------------\nvec2 \nrotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Noise functions-----------------------------------\nfloat\nhash(float seed)\n{\n    uvec2 p = floatBitsToUint(vec2(seed+=.1,seed+=.1));\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    uint n = h32^(h32 >> 16);\n    return float(n)/float(0xffffffffU);\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Camera functions------------------------------\n\n/*\n    Camera to World transform\n*/\nmat3\nSetCamera(vec3 ro, vec3 ta, float roll)\n{\n    /*\n        Iñigos way:\n        vec3 cw = normalize(ta-ro);  \n        vec3 cp = vec3(sin(cr), cos(cr),0.0);\n        vec3 cu = normalize( cross(cw,cp) );\n        vec3 cv =          ( cross(cu,cw) );\n        return mat3( cu, cv, cw );\n    */\n#if 0\n    //My version\n    vec3 f, temp, r, u;\n    f = normalize(ta - ro); \n    temp = normalize(vec3(sin(roll), cos(roll), 0.0));\n    r = normalize(cross(temp, f));\n    u = (cross(f, r)); //\n\n    return mat3(r, u, f);\n#else\n    //Inigos version with other names\n    vec3 k = normalize(ta-ro);\n\tvec3 j_temp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 i = normalize( cross(k,j_temp) ); //This results in -i\n\tvec3 j =          ( cross(i,k) ); //This results in +j!\n    \n    /*\n        I don't use his because his camera results in a left-handed coordinate sytem.\n    */\n    return mat3( i, j, k ); // -i, +j, +k?\n#endif\n\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Path Trace functions------------------------------\nvec3\nCosineWeightedRay(vec3 N, float seed)\n{\n    float u = hash(seed + 70.93);\n    float v = hash(seed + 21.43);\n\n    float a = M_TAU*v;\n    u = 2.0*u - 1.0;\n\n    return(normalize(N + vec3(sqrt(1.0 - u*u)*vec2(cos(a), sin(a)), u)));\n}\n\n//--------------------------------------------------------------------------------------\n//----------------------------------Post processing functions----------------------------\n#define GAMMA(col) col = pow(col, vec3(INV_GAMMA))\n\n\n//---------------------------------------------------------------------------------------- \n//----------------------------------Basic functions---------------------------------------\n#ifdef SHADERTOY\n#define saturate(col) clamp(col, 0.0, 1.0)\n#endif\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdByDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1549, 1549, 1588, 1588, 1691], [1693, 1693, 1736, 1736, 1918], [1920, 1920, 2018, 2018, 2351], [2353, 2353, 2384, 2412, 5284], [5286, 5286, 5342, 5365, 6592]], "test": "untested"}
{"id": "WsBcWV", "name": "Soap", "author": "klk", "description": "Fake soap bubble dispersion", "tags": ["plasma", "color"], "likes": 14, "viewed": 657, "published": 3, "date": "1587311402", "time_retrieved": "2024-07-30T21:11:45.840547", "image_code": "// Created by Alex Kluchikov\n\n\nvec2 rot(vec2 p,float a)\n{\n    float c=cos(a*15.83);\n    float s=sin(a*15.83);\n    return p*mat2(s,c,c,-s);\n}\n\nvoid mainImage(out vec4 o, in vec2 uv)\n{\n    uv/=iResolution.xx;\n    uv=vec2(.125,.75)+(uv-vec2(.125,.75))*.015;\n    float T=iTime*.5;\n\n    vec3 c = normalize(.75-.25*vec3(\n        sin(length(uv-vec2(.1,0))*132.+T*3.3),\n        sin(length(uv-vec2(.9,0))*136.-T*2.5),\n        sin(length(uv-vec2(.5,1))*129.+T*4.1)\n        ));\n\n    vec3 c0=vec3(0);\n    float w0=0.;\n    float N=164.*(iMouse.y+1.)/iResolution.y;\n    for(float i=0.;i<N;i++)\n    {\n        float wt=(i*i/N/N-.2)*.3;\n        float wp=0.5+(i+1.)*(i+1.5)*0.001;\n        float wb=.1+i/N*0.05;\n        wb=.1*(iMouse.x+1.)/iResolution.x;\n    \tc.zx=rot(c.zx,1.6+T*0.65*wt+(uv.x+.7)*23.*wp);\n    \tc.xy=rot(c.xy,c.z*c.x*wb+1.7+T*wt+(uv.y+1.1)*15.*wp);\n    \tc.yz=rot(c.yz,c.x*c.y*wb+2.4-T*0.79*wt+(uv.x+uv.y*(fract(i/2.)-0.25)*4.)*17.*wp);\n    \tc.zx=rot(c.zx,c.y*c.z*wb+1.6-T*0.65*wt+(uv.x+.7)*23.*wp);\n    \tc.xy=rot(c.xy,c.z*c.x*wb+1.7-T*wt+(uv.y+1.1)*15.*wp);\n        float w=(1.5-i/N);\n        c0+=c*w;\n        w0+=w;\n    }\n    c0=c0/w0*2.+.5;//*(1.-pow(uv.y-.5,2.)*2.)*2.+.5;\n    \n\to=vec4(c0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBcWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 57, 57, 140], [142, 142, 182, 182, 1197]], "test": "untested"}
{"id": "3dSyWV", "name": "Interactive Droste Spiral", "author": "mla", "description": "A variation on @RadoKirov's [url]https://www.shadertoy.com/view/3sjyWG[/url], also incorporating many of Fabrice's suggestions.\n\nMouse sets spiral parameters, t,g,h,z also do things, see code. ", "tags": ["spiral", "droste"], "likes": 24, "viewed": 675, "published": 3, "date": "1587310896", "time_retrieved": "2024-07-30T21:11:46.628440", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Interactive Droste spiral\n// Matthew Arcus, mla, 2020\n//\n// Derived from @FabriceNeyret2's reworking of @RadoKirov's original:\n// https://www.shadertoy.com/view/3sjyWG\n//\n// Parameterized things, added mouse control etc.\n//\n// <mouse>: horizontal = scale factor, vertical = number of spirals\n// t: use texture\n// g,h: show major and minor grids\n// z: autozoom\n//\n////////////////////////////////////////////////////////////////////////////////\n\nint AA = 2;\n\nfloat N = 1.0;\n// There are M spirals\nfloat M = 2.0;\n// Scale factor for each turn\nfloat X = 2.0, logX = log(2.0);\n\n// Grid dimensions\nfloat majorGrid = 2.0;\nfloat minorGrid = 4.0;\nconst float speed = 3.0;\nconst float PI = 3.1415927;\n\nfloat grid(vec2 uv, float g, float r) {\n  uv *= g;\n  vec2  a = abs(fract(uv+0.5)-0.5);\n  // Antialiasing by Fabrice. Thanks.\n  float m = min(a.x,a.y)-r;\n  return smoothstep(-g,g,m*100.0*log(X*length(gl_FragCoord)));\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n  return z.x*w + vec2(-z.y*w.y,w.x*z.y);\n}\n\nvec2 polar(vec2 z) {\n  return vec2(log(length(z)), atan(z.y, z.x));\n}\n\nvec2 cartesian(vec2 z) {\n  return exp(z.x) * normalize(vec2(cos(z.y),sin(z.y)));\n}\n\nconst int CHAR_D = 68;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_M = 77;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_Z = 90;\n\nbool key(int key) {\n  return texelFetch(iChannel3,ivec2(key,2),0).x != 0.0;\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb(in vec3 c) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 getcolor(vec2 z) {\n  vec3 col = vec3(1);\n  col = hsv2rgb(vec3(0.5*z+0.5,1));\n  if (key(CHAR_T)) col = texture(iChannel0,0.5*z+0.5).xyz;\n  if (!key(CHAR_G)) col *= grid(z,majorGrid,0.06);\n  if (!key(CHAR_H)) col *= grid(z,minorGrid,0.06);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  vec2 m = vec2(0);\n  if (iMouse.x > 0.0) {\n    m = iMouse.xy/iResolution.xy;\n  }\n  X = 2.0+floor(16.1*m.y);\n  logX = log(X);\n  majorGrid = X;\n  minorGrid = 4.0*X;\n  M = floor(16.1*(m.x-0.5));\n  float t = iTime / speed;\n  vec3 col = vec3(0);\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 z = (2.0 * (fragCoord+vec2(i,j)/float(AA)) - iResolution.xy) / iResolution.y;\n      if (key(CHAR_Z)) z *= exp(-t); // Zooming it\n      vec2 e = vec2(N,M*logX/PI/2.0);\n      z = cmul(polar(z),e);\n      z = cartesian(z);\n      z /= exp(mod(t,logX));\n      // Multiply z to bring it into range, ie. find power of\n      // X that brings max(x,y) into range 1..X\n      float tt = ceil(log(max(abs(z.x),abs(z.y)))/logX);\n      z *= pow(X,-tt);\n      col += getcolor(z);\n    }\n  }\n  fragColor = vec4(col/float(AA*AA),1);\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dSyWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[780, 780, 819, 819, 997], [999, 999, 1026, 1026, 1069], [1071, 1071, 1091, 1091, 1140], [1142, 1142, 1166, 1166, 1224], [1457, 1457, 1476, 1476, 1534], [1536, 1631, 1656, 1656, 1832], [1834, 1834, 1857, 1857, 2092], [2094, 2094, 2147, 2147, 2984]], "test": "untested"}
{"id": "3djyWG", "name": "Web 2", "author": "aiekick", "description": "based on the [url=https://www.shadertoy.com/view/3d2cRV]Shader[/url] of notargs\n\nvariation of [url=https://www.shadertoy.com/view/WdSyWV]Web 1[/url]\n\nalso better in fullscreen", "tags": ["web", "trabeculum"], "likes": 9, "viewed": 469, "published": 3, "date": "1587308724", "time_retrieved": "2024-07-30T21:11:47.500110", "image_code": "// based on the shader of notargs\n// https://www.shadertoy.com/view/3d2cRV\n\n// Web 1 : https://www.shadertoy.com/view/WdSyWV\n// Web 2 : https://www.shadertoy.com/view/3djyWG#\n\n// final\nconst vec4 colorBalance = vec4(0.3,0.7,0.5,0.3);\nconst vec3 uColor = vec3(0.5,1,0);\nconst vec3 uFog = vec3(0.005,0.001,0.0035);\nconst vec3 uLightDir = vec3(-1,-1,1);\n\n// shape\nconst vec3 uRatio = vec3(-0.37762,0.36364,0);\nconst float uRot = 0.1;\nconst vec2 uvOffset = vec2(2.69231,1.71329);\n\nfloat camZ = 0.0;\n\nvec2 path(float t)\n{\n\treturn vec2(cos(t * uRot) * 0.7, \n                sin(t * uRot) * 0.5) * uvOffset;\t\n}\n\nfloat map(vec3 p)\n{\n\tfloat a = p.z * uRot;\n    p.xy *= mat2(cos(a),sin(a),-sin(a),cos(a));\n    float th = mix(0.001, 0.06, cos(camZ - p.z)*0.5+0.5);\n    return th-length(\n        sin(p.xyz)*uRatio.x+\n        sin(p.zxy)*uRatio.y+\n        sin(p.yzx)*uRatio.z);\n}\n\nvec3 nor(vec3 p, float prec)\n{\n\tvec3 e = vec3(prec,0,0);\n\treturn normalize(vec3(\n\t\tmap(p+e)-map(p-e),\n\t\tmap(p+e.yxz)-map(p-e.yxz),\n\t\tmap(p+e.zyx)-map(p-e.zyx)));\n}\n\nvoid mainImage(out vec4 e, in vec2 v)\n{\n    vec3 rd = normalize(.5 - vec3(v,1)/iResolution.y);\n    camZ = iTime * -5.0;\n\tvec3 ro = vec3(uvOffset + path(camZ),camZ);\n\tvec3 p = vec3(0);\n\t\n\tfloat d = 0.0, s = d;\n    for(int i=0;i<250;i++)\n    {\n\t\tif (abs(s)<d*d*1e-6) break;\n\t\td += s = map(p);\n\t\tp = ro + rd * d;\n    }\n\t\n\tvec3 ld = normalize(uLightDir);\n\tvec3 n = nor(p, 0.01);\n\tfloat diff = max(dot(n,-ld),0.0);\n\tfloat spec = max(dot(reflect(ld,n), rd),0.0);\n\tvec3 col = sin(d*uColor)*0.5+0.5;\n\tvec3 fog = exp(-uFog*d*d);\n    vec3 c = \n\t\tdiff * colorBalance.x * fog.x + \n\t\tcol * colorBalance.y * fog.y + \n\t\tsqrt(spec * colorBalance.z * 10.0) * colorBalance.w * fog.z;\n\t\n\te = vec4(c, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djyWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[496, 496, 516, 516, 603], [605, 605, 624, 624, 865], [867, 867, 897, 897, 1030], [1032, 1032, 1071, 1071, 1718]], "test": "untested"}
{"id": "WdSyWV", "name": "Web 1", "author": "aiekick", "description": "based on the [url=https://www.shadertoy.com/view/3d2cRV]Shader[/url] of notargs\n\nbetter in fullscreen :)", "tags": ["web", "trabeculum"], "likes": 10, "viewed": 438, "published": 3, "date": "1587308656", "time_retrieved": "2024-07-30T21:11:48.381752", "image_code": "// based on the shader of notargs\n// https://www.shadertoy.com/view/3d2cRV\n\n// final\nconst vec4 colorBalance = vec4(0.3,0.7,0.5,0.3);\nconst vec3 uColor = vec3(0.5,1,0);\nconst vec3 uFog = vec3(0.005,0.001,0.0035);\nconst vec3 uLightDir = vec3(-1,-1,1);\n\n// shape\nconst vec3 uRatio = vec3(-0.37762,0.36364,0);\nconst float uRot = 0.1;\nconst vec2 uvOffset = vec2(2.69231,1.71329);\n\nfloat camZ = 0.0;\n\nvec2 path(float t)\n{\n\treturn vec2(cos(t * uRot) * 0.7, \n                sin(t * uRot) * 0.5) * uvOffset;\t\n}\n\nfloat map(vec3 p)\n{\n\tfloat a = p.z * uRot;\n    p.xy *= mat2(cos(a),sin(a),-sin(a),cos(a));\n    return length(\n        sin(p.xyz)*uRatio.x+\n        sin(p.zxy)*uRatio.y+\n        sin(p.yzx)*uRatio.z)-0.04;\n}\n\nvec3 nor(vec3 p, float prec)\n{\n\tvec3 e = vec3(prec,0,0);\n\treturn normalize(vec3(\n\t\tmap(p+e)-map(p-e),\n\t\tmap(p+e.yxz)-map(p-e.yxz),\n\t\tmap(p+e.zyx)-map(p-e.zyx)));\n}\n\nvoid mainImage(out vec4 e, in vec2 v)\n{\n    vec3 rd = normalize(.5 - vec3(v,1)/iResolution.y);\n    camZ = iTime * 5.0;\n\tvec3 ro = vec3(uvOffset + path(camZ),camZ);\n\tvec3 p = vec3(0);\n\t\n\tfloat d = 0.0, s = d;\n    for(int i=0;i<150;i++)\n    {\n\t\tif (abs(s)<d*d*1e-4) break;\n\t\td += s = map(p);\n\t\tp = ro + rd * d;\n    }\n\t\n\tvec3 ld = normalize(uLightDir);\n\tvec3 n = nor(p, 0.01);\n\tfloat diff = max(dot(n,-ld),0.0);\n\tfloat spec = max(dot(reflect(ld,n), rd),0.0);\n\tvec3 col = sin(d*uColor)*0.5+0.5;\n\tvec3 fog = exp(-uFog*d*d);\n    vec3 c = \n\t\tdiff * colorBalance.x * fog.x + \n\t\tcol * colorBalance.y * fog.y + \n\t\tsqrt(spec * colorBalance.z * 10.0) * colorBalance.w * fog.z;\n\t\n\te = vec4(c, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdSyWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[396, 396, 416, 416, 503], [505, 505, 524, 524, 709], [711, 711, 741, 741, 874], [876, 876, 915, 915, 1561]], "test": "untested"}
{"id": "WsScDK", "name": "Cyber-Iris", "author": "Zauwara", "description": "wanted to play around with polar coordinates and made this abstract Sci-Fi Tech Circle thingy\nthe bloom effect is shamelessly stolen from robobo1221 (https://www.shadertoy.com/view/lsBfRc)", "tags": ["2d", "polarcoordinates"], "likes": 24, "viewed": 1242, "published": 3, "date": "1587306941", "time_retrieved": "2024-07-30T21:11:49.316254", "image_code": "#define colorRange 24.0\n\nvec3 jodieReinhardTonemap(vec3 c){\n    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));\n    vec3 tc = c / (c + 1.0);\n\n    return mix(c / (l + 1.0), tc, tc);\n}\n\nvec3 bloomTile(float lod, vec2 offset, vec2 uv){\n    return texture(iChannel1, uv * exp2(-lod) + offset).rgb;\n}\n\nvec3 getBloom(vec2 uv){\n\n    vec3 blur = vec3(0.0);\n\n    blur = pow(bloomTile(2., vec2(0.0,0.0), uv),vec3(2.2))       \t   \t+ blur;\n    blur = pow(bloomTile(3., vec2(0.3,0.0), uv),vec3(2.2)) * 1.3        + blur;\n    blur = pow(bloomTile(4., vec2(0.0,0.3), uv),vec3(2.2)) * 1.6        + blur;\n    blur = pow(bloomTile(5., vec2(0.1,0.3), uv),vec3(2.2)) * 1.9 \t   \t+ blur;\n    blur = pow(bloomTile(6., vec2(0.2,0.3), uv),vec3(2.2)) * 2.2 \t   \t+ blur;\n\n    return blur * colorRange;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = pow(texture(iChannel0, uv).rgb * colorRange, vec3(2.2));\n    color = pow(color, vec3(2.2));\n    color += pow(getBloom(uv), vec3(2.2));\n    color = pow(color, vec3(1.0 / 2.2));\n    \n    color = jodieReinhardTonemap(color);\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float linstep(float x0, float x1, float xn)\n{\n\treturn max(min((xn - x0) / (x1 - x0), 1.), 0.);\n}\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}", "buffer_a_code": "#define M_PI 3.1415926535897932384626433832795\n\nfloat timeScale = 0.2;\n\nvec3 mainColor = vec3(0.478431, 0.678431, 1.);\nvec3 secondaryColor = vec3(0.55, 0.0, 0.0);\n\n/*\n* Displays the sector of a ring based on:\n* \n* dist\t\t... distance to the center (/ radius)\n* width\t\t... width (along the radius)\n* apos\t\t... angular position (/ offset)\n* awidth\t... angular width (along the tangent)\n* puv\t\t... polar uv coordinates of the current fragment\n*\n* returns 1.0 if the given puv is part of the ringSector\n* returns 0.0 otherwise\n*/\nfloat ringSector(float dist, float width, float apos, float awidth, vec2 puv) {\n    \n    float ring = step(abs(puv.x - dist), width / 2.0);\n    \n    float sector = min(min(\n        abs(puv.y - mod(apos, 1.0)), \n    \tabs(puv.y - mod(apos, 1.0) - 1.0)), \n         abs(puv.y - mod(apos, 1.0) + 1.0));\n    sector = step(sector, awidth / 2.0);\n    \n    return ring * sector;\n}\n\n/*\n* Displays an array of ring sectors based on:\n* \n* dist\t\t... distance to the center (/ radius)\n* width\t\t... width (along the radius)\n* apos\t\t... angular position (/ offset)\n* awidth\t... angular width of the sector array (along the tangent)\n* segCount\t... how many ring sectors should be used to create the sector array\n* segWidth\t... the width of the individual ring sector (along the tangent; values between 0.0 and 1.0)\n* puv\t\t... polar uv coordinates of the current fragment\n*\n* returns 1.0 if the given puv is part of the sector array\n* returns 0.0 otherwise\n*/\nfloat ringSectors(float dist, float width, float apos, float awidth, int segCount, float segWidth, vec2 puv) {\n    float ret = 0.;\n    float sW = awidth / float(segCount);\n    float p = apos - float(segCount) / 2.0 * sW + sW/2.0;\n    \n    for(int i = 0; i < segCount; i++) {\n        ret += ringSector(dist, width, p + sW * float(i), sW * segWidth, puv);\n    }\n    \n    return ret;\n}\n\n/*\n* Displays an array of ring sectors with randomized angular position based on:\n* \n* dist\t\t... distance to the center (/ radius)\n* width\t\t... width (along the radius)\n* apos\t\t... angular position (/ offset)\n* awidth\t... the width of the individual ring segments (along the tangent)\n* segCount\t... how many ring sectors should randomly distributed\n* seed\t\t... seed used for the hash function\n* puv\t\t... polar uv coordinates of the current fragment\n*\n* returns 1.0 if the given puv is part of the randomized ring sectors\n* returns 0.0 otherwise\n*/\nfloat randSectors(float dist, float width, float apos, float awidth, int segCount, float seed, vec2 puv) {\n    float ret = 0.;\n    \n    for(int i = 0; i < segCount; i++) {\n        float rpos = hash11((float(i) + seed) * 10032.);\n        ret = max(ret, ringSector(dist, width, apos + rpos, awidth, puv));\n    }\n    \n    return ret;\n}\n\n/*\n* Displays a ring sector that incorporates two symmetrical slopes alongside the tangent based on:\n*\n* dist\t\t... distance to the center (/ radius)\n* w1\t\t... width of the sector before the slope (along the radius)\n* w2\t\t... width of the sector after the slope (along the radius)\n* apos\t\t... angular position (/ offset)\n* awidth\t... angular width (along the tangent)\n* t1\t\t... threshold 1 defines the relative start of the slope (value between 0.0 and 1.0)\n* t2\t\t... threshold 2 defines the relative end of the slope (value between 0.0 and 1.0)\n* innerC\t... set 1.0 so that the inner half of the sector gets drawn completely; set 0.0 otherwise \n* outerC\t... set 1.0 so that the outer half of the sector gets drawn completely; set 0.0 otherwise\n* puv\t\t... polar uv coordinates of the current fragment\n*\n* returns 1.0 if the given puv is part of the slanted sector\n* returns 0.0 otherwise\n*/\nfloat slantedSector(float dist, float w1, float w2, float apos, float awidth, float t1, float t2, float innerC, float outerC, vec2 puv) {\n    \n    float sector = min(min(\n        abs(puv.y - mod(apos, 1.0)), \n    \tabs(puv.y - mod(apos, 1.0) - 1.0)), \n         abs(puv.y - mod(apos, 1.0) + 1.0));\n    \n    float slopeProgress = linstep(t1 * awidth / 2., t2 * awidth / 2., sector);\n    \n    float ring = step(abs(puv.x - dist), mix(w2, w1, slopeProgress));\n    //float ring = step(abs(puv.x - dist), (slopeProgress * w1 + (1. - slopeProgress) * w2) / 2.0);\n    \n    // cover inner / outer half of ring\n    float w = max(w1, w2);\n    ring = max(ring, step(abs(puv.x - (dist + w / 2.)), w / 2.) * outerC);\n    ring = max(ring, step(abs(puv.x - (dist - w / 2.)), w / 2.) * innerC);\n    \n    sector = step(abs(sector), awidth / 2.0);\n    \n    return ring * sector;\n}\n\n/*\n* Displays a ring built from multiple slanted sectors based on:\n*\n* dist\t\t... distance to the center (/ radius)\n* w1\t\t... width of the sectors before the slope (along the radius)\n* w2\t\t... width of the sectors after the slope (along the radius)\n* apos\t\t... angular position (/ offset)\n* segCount\t... how many slanted sectors should be used to create the ring\n* t1\t\t... threshold 1 defines the relative start of the slope of each sector (value between 0.0 and 1.0)\n* t2\t\t... threshold 2 defines the relative end of the slope of each sector (value between 0.0 and 1.0)\n* innerC\t... set 1.0 so that the inner half of the ring gets drawn completely; set 0.0 otherwise \n* outerC\t... set 1.0 so that the outer half of the ring gets drawn completely; set 0.0 otherwise\n* puv\t\t... polar uv coordinates of the current fragment\n*\n*/\nfloat slantedRing(float dist, float w1, float w2, float apos, int segCount, float t1, float t2, float innerC, float outerC, vec2 puv) {\n    float ret = 0.;\n    \n    float segWidth = 1. / float(segCount);\n    \n    for(int i = 0; i < segCount; i++) {\n        ret += slantedSector(dist, w1, w2, apos + segWidth * float(i), segWidth, t1, t2, innerC, outerC, puv);\n    }\n    \n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv *= vec2(iResolution.x/iResolution.y, 1.0);\n    \n    // polar uv (x = radius, y = angle)\n    vec2 puv = vec2(length(uv), atan(uv.x, uv.y) / (M_PI * 2.0));\n    \n    \n    float t = iTime * timeScale;\n\t\n    float fill = 0.0;\n    float fill2 = 0.0;\n    \n    // inner\n    fill += ringSector(0.01, 0.004, t * 8., 0.4, puv);\n    fill += ringSector(0.006, 0.004, -t*4., 0.2, puv);\n    \n    // reactor\n    fill += ringSector(0.05, 0.025, -t, 0.575, puv);\n    fill += ringSector(0.05, 0.05, t * 0.5, 0.1, puv);\n    fill += ringSectors(0.05, 0.025, -t + 0.5, 0.4, 4, 0.8, puv);\n    fill += ringSector(0.05, 0.0125, 0., 1., puv);\n    \n    // train\n    fill += ringSectors(0.15, 0.01, -t, 0.25, 7, 0.7, puv);\n    \n    // trail\n    fill += ringSector(0.2, 0.015, t * 1.3, 0.15, puv);\n    fill += ringSector(0.2, 0.015, t * 1.3 + 0.1, 0.025, puv);\n\t\n\t// clock\n    fill += ringSectors(0.1, 0.02, t * 1.0, 1.0, 20, 0.1, puv);\n    fill += ringSectors(0.1, 0.03, t * 1.0 + 0.025, 1.0, 5, 0.025, puv);\n    \n    //stripes\n    fill += ringSectors(0.25, 0.005, t * 0.1, 0.3, 100, 0.5, puv);\n    \n    //shutter\n    /*\n    //float tj = max(min(-abs(mod(t * 6., 6.) - 3.) + 2., 1.), 0.);\n    //tj = pow(tj, 2.);\n    float tj = (sin(t * 5.) + 1.) /2.;\n    fill += ringSector(0.3, 0.01, 0.5 - tj * 0.08, 0.025, puv);\n    fill += ringSector(0.29, 0.002, 0.4 + tj * 0.025, 0.01, puv);\n    fill += ringSector(0.31, 0.002, 0.225 + tj * 0.2, 0.075, puv);\n\t*/\n    \n    // small gear\n    fill2 += slantedRing(0.35, 0.025, 0.0025, -t * 0.3, 3, 0.57, 0.6, 0., 1.,  puv);\n    //fill += ringSectors(0.38, 0.01, t * 0.02, 1., 100, 0.2, puv);\n    fill2 += slantedRing(0.395, 0.0125, 0.00125, t * 0.3, 6, 0.57, 0.6, 1., 0., puv);\n    \n    // barcode\n    fill += randSectors(0.45, 0.015, t * 0.1, 0.001, 50, 1., puv);\n    fill += randSectors(0.45, 0.015,-t * 0.1, 0.001, 50, 1.5, puv);\n    \n    // trinity\n    fill += ringSectors(0.550, 0.0025, -t * 0.9, 1.0, 3, 0.3, puv);\n    fill += ringSectors(0.560, 0.0025, -t * 0.9, 1.0, 3, 0.3, puv);\n    fill += ringSector(0.555, 0.0025, t * 2.4, 0.15, puv);\n    \n    // huge gear\n    float gt = t * 0.05;\n    fill += slantedRing(0.635, 0.01, 0., gt, 50, 0.4, 0.6, 0., 1., puv);\n    fill += slantedRing(0.675, 0.01, 0., gt, 5, 0.5, 0.55, 1., 0., puv);\n    fill += slantedRing(0.700, 0.01, 0., gt + 0.1, 5, 0.5, 0.55, 0., 1., puv);\n    fill += slantedRing(0.740, 0.01, 0., gt, 50, 0.4, 0.6, 1., 0., puv);\n    fill += ringSector(0.655, 0.02, gt, 1., puv);\n    fill += ringSector(0.720, 0.02, gt, 1., puv);\n    fill -= ringSectors(0.67, 0.0025, gt + 0.1, 1., 5, 0.4, puv);\n    fill -= ringSectors(0.705, 0.0025, gt, 1., 5, 0.4, puv);\n    fill -= ringSectors(0.63, 0.00125, gt, 1., 50, 0.3, puv);\n    fill -= ringSectors(0.745, 0.00125, gt, 1., 50, 0.3, puv);\n    \n    fragColor = vec4(mainColor * fill /5. + secondaryColor * fill2 /5., 1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "vec3 makeBloom(float lod, vec2 offset, vec2 bCoord){\n    \n    vec2 pixelSize = 1.0 / vec2(iResolution.x, iResolution.y);\n\n    offset += pixelSize;\n\n    float lodFactor = exp2(lod);\n\n    vec3 bloom = vec3(0.0);\n    vec2 scale = lodFactor * pixelSize;\n\n    vec2 coord = (bCoord.xy-offset)*lodFactor;\n    float totalWeight = 0.0;\n\n    if (any(greaterThanEqual(abs(coord - 0.5), scale + 0.5)))\n        return vec3(0.0);\n\n    for (int i = -5; i < 5; i++) {\n        for (int j = -5; j < 5; j++) {\n\n            float wg = pow(1.0-length(vec2(i,j)) * 0.125,6.0);\n\n            bloom = pow(texture(iChannel0,vec2(i,j) * scale + lodFactor * pixelSize + coord, lod).rgb,vec3(2.2))*wg + bloom;\n            totalWeight += wg;\n\n        }\n    }\n\n    bloom /= totalWeight;\n\n    return bloom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n\tvec3 blur = makeBloom(2.,vec2(0.0,0.0), uv);\n\t\tblur += makeBloom(3.,vec2(0.3,0.0), uv);\n\t\tblur += makeBloom(4.,vec2(0.0,0.3), uv);\n\t\tblur += makeBloom(5.,vec2(0.1,0.3), uv);\n\t\tblur += makeBloom(6.,vec2(0.2,0.3), uv);\n\n    fragColor = vec4(pow(blur, vec3(1.0 / 2.2)),1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsScDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 59, 59, 182], [184, 184, 232, 232, 295], [297, 297, 320, 320, 776], [778, 778, 835, 835, 1158]], "test": "untested"}
{"id": "td2cDy", "name": "Single Layer Glitter", "author": "qwert33", "description": "First step towards building a renderer for https://youtu.be/BtYKDamqo2I?t=334\n\nStep two: https://www.shadertoy.com/view/tsjyWV\nStep three: https://www.shadertoy.com/view/wdXfzN#", "tags": ["glitter"], "likes": 2, "viewed": 294, "published": 3, "date": "1587300959", "time_retrieved": "2024-07-30T21:11:50.139054", "image_code": "\n#define TAU 6.28318530718\n#define PI TAU/2\n    \n// biases x to be closer to 0 or 1\n// can act like a parameterized smoothstep\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat bias(float x, float b) {\n    x = clamp(x, 0., 1.);\n    b = -log2(1.0 - b);\n    return 1.0 - pow(1.0 - pow(x, 1./b), b);\n}\n\n// Dave Hoskins hash\nfloat hash13( in vec3 p3 ) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nconst vec3 default_debug = vec3(-100, -20, -10);\nvec3 debug = default_debug;\nconst vec3 orange = vec3(1., .5, 0.);\nconst vec3 cornflowerblue = vec3(100./255., 149./255., 237./255.);\n\nvec2 domsMouse;\n\nvec2 project(vec2 pixel) {\n    vec2 uv = pixel/iResolution.xy - vec2(0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv;\n}\n\n\nfloat circle(vec2 uv) {\n    //uv *= 2.;\n    if (length(uv)< 0.9) {\n        if (abs(uv.y) < .1) return .8;\n        return 0.3;\n    }\n    if (length(uv)< 1.) {\n        return 1.;\n    }\n    return 0.;\n    return clamp(length(uv)-8., 0., 1.);\n    return bias(1.-(abs(length(uv) - 1. +.018) / .02), .8);\n}\n// Returns a unit-length vector at a given rotation.\n// Analogous to e^(-i*theta)\n// i.e. rotate (1,0) anticlockwise for theta radians. (+y means facing up)\nvec2 e(float theta) {\n    return vec2(cos(theta), sin(theta));\n}\nfloat monochrome(vec2 uv) {\n    float height = 4.;\n    \n    const float cell_wd = 1.;\n    vec2 inner_uv = mod(uv+cell_wd, 2.*cell_wd) - cell_wd;  // position within grid cell.\n\tvec2 outer_uv = floor((uv+cell_wd)/ 2.*cell_wd);      // index of grid cell.\n    \n    \n    //vec2 angular_vel = vec2(outer_uv.yx);\n    vec2 outer_hash_pos = outer_uv + vec2(1030., 0);\n    float yaw = TAU * hash13(vec3(outer_hash_pos, 2.));\n    float angular_speed = 3. + hash13(vec3(outer_hash_pos, 3.));\n    vec2 angular_vel = angular_speed* vec2(cos(yaw), sin(yaw));\n    //if ( outer_uv.y < -1.1) debug = cornflowerblue;\n    float pitch = length(angular_vel) * (iTime+100.)*0.1;\n    vec2 a = normalize(angular_vel);  // axis of rotation\n    mat2 rot = mat2(a.x, a.y,\n                    -a.y, a.x);\n    inner_uv = rot * inner_uv;\n    inner_uv.y /= cos(pitch);\n    inner_uv = transpose(rot) * inner_uv;  // note: could be removed when our object is rotationally symmetric..\n    inner_uv *= 1.5; // don't make the circles take up the entire inner square\n\n    vec3 normal = vec3(0.0, sin(pitch), cos(pitch));\n    mat3 rot3 = mat3(a.x, a.y, 0.,\n                     -a.y, a.x, 0.,\n                     0., 0., 1.);\n    normal = transpose(rot3) * normal;\n    const vec3 LIGHT_DIR = normalize(vec3(1.5, -1.0, 2.0));\n    float light = \n        .2 + // ambient\n        .8 * smoothstep(.98, .99, abs(dot(normal, LIGHT_DIR)));  // cheap (wrong-ish) specular\n           \n    float acc = 0.;\n    acc += light * circle(inner_uv);\n    \n\treturn clamp(acc, 0., 1.);\n}\n\nfloat f(vec2 fragCoord) {\n    vec2 uv = project(fragCoord);\n    uv /= project(domsMouse.xy).xx / 3.;\n    return monochrome(uv);\n}\n\n// antialiasing\nfloat sampleSubpixel(vec2 pixels) {\n\tconst int size = 1; \n\tfloat disp = 1.0 / (float(size) + 2.0);\n\tfloat contrb = 0.0;\n\tfloat maxContrb = 0.0;\n\tfor (int j = -size; j <= size; j++) {\n\t\tfor (int i = -size; i <= size; i++) {\n\t\t\tcontrb += f(pixels + vec2(float(i) * (disp / 3.0), float(j) * disp));\n\t\t\tmaxContrb += 1.0;\n\t\t}\n\t}\n\treturn contrb / maxContrb;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    domsMouse = iMouse.xy;\n    if (iMouse.x == 0.) { domsMouse.x = iResolution.x * .5 + 30.; }\n    fragColor = vec4(orange * sampleSubpixel(fragCoord), 1.0);\n    if (debug != default_debug) fragColor.rgb = debug;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2cDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 365, 395, 395, 492], [494, 515, 543, 543, 646], [848, 848, 874, 874, 982], [985, 985, 1008, 1024, 1285], [1286, 1443, 1464, 1464, 1507], [1508, 1508, 1535, 1535, 3038], [3040, 3040, 3065, 3065, 3169], [3542, 3542, 3596, 3596, 3811]], "test": "untested"}
{"id": "wd2cDG", "name": "Neighbor graph SPH II", "author": "michael0884", "description": "idk more particle sims I guess\nlooks better accelerated 8x\nChange N in Commons to change particle number!", "tags": ["particles", "aabb", "sort"], "likes": 10, "viewed": 486, "published": 3, "date": "1587294817", "time_retrieved": "2024-07-30T21:11:51.038651", "image_code": "ivec4 get(ivec2 p)\n{\n    return floatBitsToInt(texel(ch0, p));\n}\n\nivec4 getb(int id)\n{\n    return floatBitsToInt(texel(ch2, i2xy(id)));\n}\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nvec2 Fv(vec4 p0, int pid)\n{\n    if(pid < 0 || pid >= tot_n) return vec2(0); \n   \tvec4 p1 = getParticle(pid);\n    vec2 viscosity = 0.0*(p1.zw - p0.zw)*clamp(exp(-0.3*distance(p1.xy,p0.xy)*distance(p1.xy,p0.xy)), 0.05,1.);\n    vec2 pressure = normalize(p1.xy-p0.xy)*F(distance(p1.xy,p0.xy));\n    return viscosity + pressure;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    N = ivec2(size*ss);\n    tot_n = N.x*N.y;\n    ivec4 nb = get(ivec2(pos));\n \tvec4 p0 = getParticle(nb.x);\n   \n    ivec4 nbm = get(ivec2(iMouse.xy));\n    ivec4 nbb = getb(nbm.x);\n    \n    float d = 0.;\n    for(int i = 0; i<4; i++)\n    {\n        vec4 pi = getParticle(nbb[i]);\n        d += exp(-distance(pos,pi.xy));\n    }\n    \n    vec4 d0 = vec4(0.);\n    vec2 F = Fv(vec4(pos,0,0), nb.x) +\n             Fv(vec4(pos,0,0), nb.y) +\n             Fv(vec4(pos,0,0), nb.z) +\n             Fv(vec4(pos,0,0), nb.w);\n    for(int i = 0; i<4; i++)\n    {\n        vec4 pi = getParticle(nb[i]);\n        d0 += 0.45*cos(2.*vec4(3,2,1,4)*min(log(1.+length(F)),1.))/(1.+0.3*distance(pos,pi.xy));\n    }\n    \n    fragColor = d0+ 1.5*sin(5.*vec4(4,3,2,1)*d);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define dt 1.0\n//particle array proportion \n#define ss 0.5\n\n#define istr 0.3\n#define limstr 1.\n#define visc 0.004\n#define grav 0.001\n\nfloat F(float d)\n{\n    return clamp(istr*(0.2/(1.+0.8*d*d) - 2.*exp(-0.9*d*d)), -limstr, limstr);\n}\n\nivec2 N;\nint tot_n;\n\nfloat hash11(float p)\n{\n    p = fract(p * 15.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p) - 0.5;\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nconst int k = 1664525;  \n\nivec4 hash( ivec4 x )\n{\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    return ivec4(x);\n}\n\nivec2 i2xy(int id)\n{\n    return ivec2(id%N.x, id/N.x);\n}\n\nint xy2i(ivec2 p)\n{\n    return p.x + p.y*N.x;\n}\n\nivec2 cross_distribution(int i)\n{\n    return (1<<(i/4)) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 );\n}", "buffer_a_code": "//particle buffer\n\nint cid;\n\nivec4 get(int id)\n{\n    return floatBitsToInt(texel(ch0, i2xy(id)));\n}\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nvec2 Fv(vec4 p0, int pid)\n{\n    if(pid < 0 || pid >= tot_n || pid == cid) return vec2(0); \n   \tvec4 p1 = getParticle(pid);\n    float d= distance(p0.xy, p1.xy);\n    vec2 dv = (p1.zw - p0.zw);\n    float dotv = dot(normalize(p1.xy-p0.xy), normalize(dv)); //divergence correction\n    vec2 antidivergence = 0.08*dv*abs(dotv)*exp(-0.5*d);\n    vec2 viscosity = visc*dv*dot(dv,dv)*exp(-0.1*d);\n    vec2 pressure = normalize(p1.xy-p0.xy)*F(d);\n    return viscosity + pressure + antidivergence;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    N = ivec2(size*ss);\n    tot_n = N.x*N.y;\n    if(p.x < N.x && p.y < N.y)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch1, pos);\n        int id = xy2i(p);\n        cid = id;\n        \n        //this pixel value\n        if(iFrame<10)\n        {\n            U.xy = size*hash22(pos);\n\t\t\tU.zw = 2.*(hash22(3.14159*pos) - 0.5);\n      \t\treturn;\n        }\n        \n        //neighbors\n   \t\tivec4 cp = get(id);\n   \t  \n        vec2 F = Fv(U, cp.x) +\n            \t Fv(U, cp.y) +\n            \t Fv(U, cp.z) +\n                 Fv(U, cp.w) + \n            \t grav*vec2(0.,-1.);\n        \n        if(iMouse.z > 0.) \n        {\n            float d = distance(iMouse.xy, U.xy);\n            F += 0.1*normalize(iMouse.xy - U.xy)/(sqrt(d)+2.);\n        }\n        \n        U.zw += F*dt;\n        U.xy += U.zw*dt;\n        U.zw = clamp(U.zw, vec2(-2),vec2(2));\n        \n        //border conditions\n        if(size.x - U.x < 2.) U.z = -abs(U.z);\n        if(U.x < 2.) U.z = abs(U.z);\n        if(size.y - U.y < 2.) U.w = -abs(U.w);\n        if(U.y < 2.) U.w = abs(U.w);\n \n        \n    }\n    else discard;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//sorting closest 4 particles in axis directions that make a bounding box\n//only in particle space, texture buffer not needed\n\nivec4 get(int id)\n{\n    return floatBitsToInt(texel(ch0, i2xy(id)));\n}\n\nvec4 save(ivec4 v)\n{\n    return intBitsToFloat(v);\n}\n\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //this particle position\nint tid;\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\n//insertion sort\nvoid sort(int utemp)\n{\n    if(utemp == tid || utemp < 0) return;\n       \n   \tvec4 part = getParticle(utemp);\n    vec2 dx = part.xy - pos;\n    float dtemp = length(dx);\n    //sorting\n    if(dx.x > abs(dx.y))\n    {\n        if(d.x > dtemp) \n        {\n            d.x = dtemp;\n        \tu.x = utemp;\n        }\n    }\n    else if(dx.x < -abs(dx.y))\n    {\n        if(d.y > dtemp) \n        {\n            d.y = dtemp;\n        \tu.y = utemp;\n        }\n    }\n    else if(dx.y > abs(dx.x))\n    {\n        if(d.z > dtemp) \n        {\n            d.z = dtemp;\n        \tu.z = utemp;\n        }\n    }\n    else if(d.w > dtemp) \n    {\n        d.w = dtemp;\n        u.w = utemp;\n    }\n}\n\nvoid sortneighbor(int id)\n{\n    ivec4 nb = get(id);\n    for(int j = 0; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{  \n    ivec2 p = ivec2(fragCoord);\n    N = ivec2(size*ss);\n    tot_n = N.x*N.y;\n    \n    if(p.x > N.x || p.y > N.y) discard;\n    \n    int id = xy2i(p);\n     \n    u = ivec4(-1); d = vec4(1e10); \n   \n    tid = id;\n    pos = getParticle(id).xy;\n    \n    sortneighbor(id); \n    \n    for(int i = 0; i < 16; i++)\n    {\n        sort(hash(ivec4(p, iFrame, i)).x%tot_n); //random sort    \n    }\n    \n    ivec4 nb = get(id);\n    for(int i = 0; i < 4; i++)\n    {\n        sortneighbor(nb[i]); \n    }\n    \n    if( any(lessThan(u, ivec4(-1))) || any(greaterThan(u, ivec4(tot_n))))\n    {\n        u = ivec4(0);\n    }\n    \n    \n    U = save(u);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//4th order voronoi particle tracking \n\nivec4 get(ivec2 p)\n{\n    return floatBitsToInt(texel(ch0, p));\n}\n\nivec4 getnb(int id)\n{\n    return floatBitsToInt(texel(ch2, i2xy(id)));\n}\n\nvec4 save(ivec4 v)\n{\n    return intBitsToFloat(v);\n}\n\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //pixel position\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id).xy, p);\n}\n\n//insertion sort\nvoid sort(int utemp)\n{\n    if(utemp == -1) return; \n   \tfloat dtemp = particleDistance(utemp, pos);\n    //sorting\n    if(d.x > dtemp)\n    {\n        d = vec4(dtemp, d.xyz);\n        u = ivec4(utemp, u.xyz);\n    }\n    else if(d.y > dtemp && dtemp > d.x)\n    {\n        d.yzw = vec3(dtemp, d.yz);\n        u.yzw = ivec3(utemp, u.yz);\n    }\n    else if(d.z > dtemp && dtemp > d.y)\n    {\n        d.zw = vec2(dtemp, d.z);\n        u.zw = ivec2(utemp, u.z);\n    }\n    else if(d.w > dtemp && dtemp > d.z)\n    {\n        d.w = dtemp;\n        u.w = utemp;\n    }\n}\n\nvoid sortpos(ivec2 p)\n{\n    ivec4 nb = get(p);\n    for(int j = 0; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{\n    pos = fragCoord;\n    N = ivec2(size*ss);\n    tot_n = N.x*N.y;\n    ivec2 p = ivec2(pos);\n     \n    u = ivec4(-1); d = vec4(1e10); \n   \n    //jump flood sorting \n    sortpos(p); //resort this position\n    for(int i = 0; i < 8; i++)\n    {\n        sortpos(p+cross_distribution(i)); \n    }\n    \n    ivec4 dnb = getnb(u.x);\n    for(int i = 0; i < 4; i++)\n    {\n        sort(dnb[i]); \n    }\n    \n    for(int i = 0; i < 2; i++)\n    {\n        sort(hash(ivec4(p, iFrame, i)).x%tot_n); //random sort    \n    }\n    \n    if( any(lessThan(u, ivec4(-1))) || any(greaterThan(u, ivec4(tot_n))) )\n    {\n        u = ivec4(0);\n    }\n    \n    U = save(u);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2cDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 64], [66, 66, 86, 86, 137], [139, 139, 165, 165, 200], [202, 202, 229, 229, 526], [529, 529, 580, 580, 1319]], "test": "untested"}
{"id": "3djcDy", "name": "Conformal Droste - 322 chars", "author": "FabriceNeyret2", "description": "antialiasing + golfing RadoKirov's shader [url]https://shadertoy.com/view/3sjyWG[/url] ( 1303 chars  )\n", "tags": ["droste", "escher", "short", "golf", "conformalmapping", "3tweets"], "likes": 20, "viewed": 518, "published": 3, "date": "1587279606", "time_retrieved": "2024-07-30T21:11:51.886382", "image_code": "// antialiasing + golfing RadoKirov's shader ( 1303 chars ) https://shadertoy.com/view/3sjyWG 2020-04-19\n\n// --- 322 again with analytic form of the version with \"even better antialiasing\" \n\n#define g(g,r) ( c = abs( fract(g/e +.5) -.5 ),                \\\n                 c = min(c,c.y) - r/20. ,                      \\\n                 smoothstep(-g, g, c*.4* l*R  ).x )           //\nvoid mainImage(out vec4 O, vec2 U) {\n    vec2  R = iResolution.xy,\n          c = U+U - R, l = length(c) / R,\n          e = mat2(.75, -.1103, .1103,.75)\n              * vec2( atan(c.y, c.x) , log(l) );\n    e  = exp( .7 * fract( iTime/2. ) -e.y )\n         / abs( cos( e.x + vec2(0,1.57)) );\n    e /= exp2( ceil( log( min(e,e.yx) ) / .7 ) );\n    O +=   g( 1.01, .7 )\n         * g( 3.  , .5 );\n}/*\n\n\n\n\n\n\n// --- +12 -8: analytic form of the version with \"even better antialiasing\" \n\n#define g(g,r) ( R = abs( fract(e*g +.5) -.5 ),                \\\n                 R = min(R,R.y) - r/20. ,                      \\\n                 smoothstep(-g, g, R*.4* length(c)  ).x )     //\n#define mainImage(O,U)                                         \\\n    vec2  R = iResolution.xy,                                  \\\n          c = U+U - R,                                         \\\n          e = mat2(.75, -.1103, .1103,.75)                     \\\n              * vec2( atan(c.y, c.x) , log( length(c) / R ) ); \\\n    e  = exp( e.y -.7 * fract( iTime/2. ) )                    \\\n         * abs( cos( e.x + vec2(0,1.57)) );                    \\\n    e *= exp2( ceil( -log( max(e.x,e.y) ) / .7 ) );            \\\n    O +=   g( 1.01, .7 )                                       \\\n         * g( 3.  , .5 )                                      /*\n\n\n\n\n\n// --- 334 chars : +12 : version with even better antialiasing\n\n#define g(e,r) ( c = abs( fract(e +.5) -.5 ),                  \\\n                 c = min(c,c.y) - r/20. ,                      \\\n                 smoothstep(-1., 1., c/fwidth(length(e)) ).x )//\n#define mainImage(O,U)                                         \\\n    vec2  R = iResolution.xy,                                  \\\n          c = U+U - R,                                         \\\n          e = mat2(.75, -.1103, .1103,.75)                     \\\n              * vec2( atan(c.y, c.x) , log( length(c) / R ) ); \\\n    e =   exp( e.y -.7 * fract( iTime/2. ) )                   \\\n        * abs( cos( e.x + vec2(0,1.57)) );                     \\\n    e *= exp2( ceil( -log( max(e.x,e.y) ) / .7 +.02) );        \\\n    O +=   g( e   , .7 )                                       \\\n         * g( e*3., .5 )                                      /*\n\n\n\n\n\n// --- 322 chars   ( with pretty good antialiasing )   < < <\n\n#define g(e,r) ( c = abs( fract(e +.5) -.5 ),                  \\\n                 c = min(c,c.y) - r/20. ,                      \\\n                 smoothstep(-1., 1., c/fwidth(c) ).x )        //\n#define mainImage(O,U)                                         \\\n    vec2  R = iResolution.xy,                                  \\\n          c = U+U - R,                                         \\\n          e = mat2(.75, -.1103, .1103,.75)                     \\\n              * vec2( atan(c.y, c.x) , log( length(c) / R ) ); \\\n    e =   exp( e.y -.7 * fract( iTime/2. ) )                   \\\n        * abs( cos( e.x + vec2(0,1.57)) );                     \\\n    e *= exp2( ceil( -log( max(e.x,e.y) ) / .7 ) );            \\\n    O +=   g( e   , .7 )                                       \\\n         * g( e*3., .5 )                                      /*\n\n\n\n\n\n// --- 327 chars\n\n#define g(g,r) ( c = abs( fract(e * g +.5) -.5 ),                \\\n                 c = min(c,c.y),                                 \\\n                 smoothstep(-1., 1., ( c - r ) / fwidth(c) ).x )//\n#define mainImage(O,U)                                           \\\n    vec2  R = iResolution.xy,                                    \\\n          c = U+U - R,                                           \\\n          e = mat2(.75, .1103, -.1103,.75)                       \\\n              * vec2( log(length(c)/R.x) , atan(c.y, c.x) );     \\\n    e =   exp(e.x -.7 * fract( iTime / 2.) )                     \\\n        * abs( cos( e.y + vec2(0,1.57)) );                       \\\n    e *= exp2( ceil( -log( max(e.x,e.y) ) / .7 ) );              \\\n    O +=   g(1., .035)                                           \\\n         * g(3., .025)                                          /*\n\n\n\n\n\n// --- 352 chars\n\n#define g(g,r) ( a = abs( fract(e * g +.5) -.5 ),              \\\n                 l = min(a.x,a.y),                             \\\n                 smoothstep(-1., 1., ( l - r ) / fwidth(l) ) )//\n#define mainImage(O,U)                                         \\\n    float l;                                                   \\\n    vec2  R = iResolution.xy, a,                               \\\n          c = ( U+U - R) / R.x,                                \\\n          e =  vec2( .75, .1103 );                             \\\n    e = mat2(e, -e.y,e.x)                                      \\\n        * vec2( log(length(c)) , atan(c.y, c.x) );             \\\n    e = exp(e.x) * abs( cos( e.y + vec2(0,1.57)) )             \\\n        / exp(.7 * fract( iTime / 2.) );                       \\\n    e *= exp2( ceil( -log( max(e.x,e.y) ) / .7 ) );            \\\n    O +=   g(1., .035)                                         \\\n         * g(3., .025)                                        /*\n\n\n\n\n\n// --- 372 chars\n\n#define g(g,r) ( a = abs( fract(e * g +.5) -.5 ),              \\\n             t = min(a.x,a.y),                                 \\\n             smoothstep(-1., 1., ( t - r ) / fwidth(t) ) )    //\n#define mainImage(O,U)                                         \\\n    float t = iTime / 3. , l = log(2.);                        \\\n    vec2  R = iResolution.xy, a,                               \\\n          c = (2. * U - R) / R.x,                              \\\n          e =  vec2( .75, l / 6.28 );                          \\\n    e = mat2(e, -e.y,e.x)                                      \\\n        * vec2( log(length(c)) , atan(c.y, c.x) );             \\\n    e = exp(e.x) * cos( e.y + vec2(0,1.57) )                   \\\n        / exp(l * fract(t / l) );                              \\\n    e *= exp2( floor( -log( max(abs(e.x),abs(e.y)) ) / l ) );  \\\n    O +=   g(2., .035)                                         \\\n         * g(6., .025)                                        /*\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djcDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[386, 386, 422, 422, 777]], "test": "untested"}
{"id": "Wd2yDy", "name": "Video Visualizer AMV Effect", "author": "colorindarkness", "description": "An Audio Responsive Music Video effect", "tags": ["fft", "audio", "glow", "visualizer", "chromaticabberation"], "likes": 7, "viewed": 731, "published": 3, "date": "1587277806", "time_retrieved": "2024-07-30T21:11:52.676271", "image_code": "#define freqStart -1.0\n#define freqInterval 0.01\n#define sampleSize 0.02           // How accurately to sample spectrum, must be a factor of 1.0\n\n\nfloat glow_radius = 0.00002;\nfloat glow_intens = 0.00125;\nfloat glow_blur_step = 0.5;\nfloat glow_num_steps = 1.0; // 1.0 is hollywood glow :)\n\nfloat fixcolor(float x) {\n    return 1.0-round(x*glow_num_steps)/glow_num_steps;\n}\n\nfloat getcolor(vec2 uv) {\n    vec4 c = texture(iChannel0, uv);\n    return max(fixcolor(c.r),max(fixcolor(c.g),fixcolor(c.b)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 v = fragCoord.xy / iResolution.xy;\n    float val = texture(iChannel1, vec2(.3,.152)).r;//;sin(iDate.w)/2.+.5;\n    float val2 = texture(iChannel1, vec2(.3,.152)).r;//;sin(iDate.w)/2.+.5;\n    vec2 offset = (v-.5)*val;\n    float dist = distance(v,vec2(.5));\n    vec2 uv = v-offset*dist;\n    //vec2 uv = fragCoord/iResolution.xy;\n    float mdst = dist/distance(vec2(.5), vec2(1.));\n    float distanceMul = ((((uv.x>1.)||(uv.x<0.))||((uv.y>1.)||(uv.y<0.)))?0.:1.);    \n    vec2 xy = fragCoord.xy / iResolution.xy;  \n    \n    \n    vec4 c = texture(iChannel0, uv)*val2;\n     \n    float d = 0.0;    \n    for (float x=0.0; x<1.0; x+=glow_blur_step) \n        for (float y=0.0; y<1.0; y+=glow_blur_step) {\n            d += getcolor(uv+glow_radius*vec2(x-0.5, y-0.5));\n        }\n    \n    float glow_intens2 = texture(iChannel1, vec2(1,0)).r;//;sin(iDate.w)/2.+.5;\n\n    d *= glow_intens2*.2;\n    \n    float intensity = 0.0;\n\tfor(float s = 0.0; s < freqInterval; s += freqInterval * sampleSize) {\n\t\tintensity += texture(iChannel1, vec2(freqStart + s, 0.0)).r;\n\t}\n    intensity = abs(intensity)*1.0;\n    intensity = pow((intensity*sampleSize),3.0)*4.0;\n    \n    \n    //set offsets\n    vec2 rOffset = vec2(-0.02,0)*intensity;\n    vec2 gOffset = vec2(0.0,0)*intensity;\n    vec2 bOffset = vec2(0.04,0)*intensity;\n    \n    vec4 rValue = texture(iChannel0, xy - rOffset);\n    vec4 gValue = texture(iChannel0, xy - gOffset);\n    vec4 bValue = texture(iChannel0, xy - bOffset);\n\n    \n    fragColor = vec4(rValue.r, gValue.g, bValue.b, 1.0)*0.6; //rgb effect\n    fragColor += distanceMul*texture(iChannel0,uv, (dist*val)*25.); //fisheye effect\n    fragColor += vec4(d,d,d,d)+c; //glow effect\n    \n    \n    \n}\n", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22129, "src": "https://soundcloud.com/witchhvnt/g0ne-forever/", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2yDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[290, 290, 315, 315, 372], [374, 374, 399, 399, 502], [504, 504, 561, 561, 2253]], "test": "untested"}
{"id": "3d2yWy", "name": "Live Code With Friends: Rings", "author": "blackle", "description": "live coded with some friends in about an hour over discord live c:", "tags": ["rings", "livecode"], "likes": 10, "viewed": 508, "published": 3, "date": "1587271841", "time_retrieved": "2024-07-30T21:11:53.543950", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat hash(float a, float b) {\n  return fract(sin(dot(vec2(a,b), vec2(12.9898, 78.233))) * 43758.5453)*2.-1.;\n}\n\nfloat id;\nfloat scene(vec3 p) {\n  float xscale = 1.;\n  id = floor(p.x*xscale);\n  p.x = (fract(p.x*xscale)-0.5)/xscale;\n  \n  float m1 = hash(id, 69.);\n  float m2 = hash(id, 38.);\n  float m3 = hash(id, 41.);\n  float myTime = iTime + m3*10.;\n  p.yz += vec2(m1,m2)*0.2 * sin(myTime*2.);\n  \n  return 0.8*(length(vec2(length(p.yz)-0.5, p.x))-0.1);\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(0.001);\n  return normalize(scene(p) - vec3(scene(k[0]), scene(k[1]), scene(k[2])));\n}\n\nvec3 srgb(float a, float b, float c) {\n  return pow(vec3(a,b,c), vec3(2.));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n  \n  float n1 = hash(hash(uv.x, uv.y), iTime * 11.);\n  float n2 = hash(hash(uv.x, uv.y), iTime * 23.);\n  uv += vec2(n1,n2)*0.002;\n\n  vec3 cam = normalize(vec3(1, uv));\n  float rot = iTime;\n  float shift = iTime;\n  float outside = smoothstep(0.0,0.5, asin(sin(iTime*acos(-1.)/4.)));\n  float look = mix(0.05, 0.4, outside);\n  vec3 init = vec3(shift,0,0) + vec3(0, sin(rot), cos(rot))*mix(0.15, 1., outside);\n  cam = erot(cam, vec3(0,1,0), cos(rot)*look);\n  cam = erot(cam, vec3(0,0,1), -sin(rot)*look);\n  vec3 p = init;\n  bool hit = false;\n  float mini = 100000.;\n  int i;\n  for (i = 0 ; i < 100 && !hit; i++) {\n    float dist = scene(p);\n    mini = min(dist, mini);\n    hit = dist*dist < 1e-6;\n    p+=dist*cam;\n  }\n  float glow = pow(exp(-mini*20.), 2.);\n  float idloc = id;\n  float fog = (float(i)/100.);\n  vec3 n = norm(p);\n  vec3 r = reflect(cam, n);\n  float diff = length(sin(n*2.)*0.5+0.5)/sqrt(3.);\n  float spec = length(sin(r*2.)*0.5+0.5)/sqrt(3.);\n  vec3 col = mix(srgb(0.4,0.1,0.2), srgb(0.9,0.7,0.4), spec);\n  col = abs(erot(col, normalize(vec3(1,7,1)), idloc)) + pow(spec, 15.)*2.;\n  vec3 bg = mix(srgb(0.5, 0.2, 0.3), srgb(0.2, 0.1, 0.3), sqrt(length(uv))) + glow*0.2;\n  fragColor.xyz = hit ? mix(col, bg, fog) : bg;\n  fragColor.xyz = sqrt(fragColor.xyz) + hash(hash(uv.x, uv.y), iTime)*0.04;\n  \n  fragColor.xyz = smoothstep(vec3(-0.1), vec3(1.1), fragColor.xyz);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d2yWy.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 194, 224, 224, 305], [317, 317, 338, 338, 650], [652, 652, 671, 671, 785], [787, 787, 825, 825, 864], [866, 866, 904, 904, 968]], "test": "untested"}
{"id": "3djyWy", "name": "Snakebird Portal Tribute", "author": "fyrn", "description": "An attempt to recreate the portal from the game \"Snakebird\"", "tags": ["2d", "metaball", "portal"], "likes": 9, "viewed": 363, "published": 3, "date": "1587271188", "time_retrieved": "2024-07-30T21:11:54.304916", "image_code": "const int num_colors = 7;\nconst float threshold = 2.5;\nconst float threshold_aa = 0.1;\n\nconst vec3 colors[num_colors] = vec3[num_colors](\n    vec3(0.960,0.321,0.521),\n    vec3(1.000,0.572,0.321),\n    vec3(0.949,0.917,0.321),\n    vec3(0.403,1.000,0.407),\n    vec3(0.321,0.909,0.949),\n    vec3(0.376,0.627,1.000),\n    vec3(0.694,0.423,0.972)\n);\n\n#define TAU 6.28318530\n#define PI  3.14159265\n\nconst float tauToColorRange = float(num_colors) / TAU;\n\nfloat phi(const float r, const vec2 pos) {\n    if (pos.y >= 0.0) {\n    \treturn acos(pos.x / r);\n    }\n    return -acos(pos.x / r);\n}\n\nvec3 rainbow(const vec2 polar) {\n    // Scale\n    float x = polar.x * 4.0;\n\n    // Rotate\n  \tfloat y = polar.y + iTime;\n\n    int index = int(mod(x * 0.9 + y * tauToColorRange, float(num_colors)));\n    return colors[index];\n}\n\nvec3 metaball(float time, float theta, float start) {\n    float theta_2 = mod(theta + time, TAU);\n    vec2 angle_vec = vec2(sin(theta_2), cos(theta_2));\n    float scale = mod((theta / PI) + time / 2.0, 1.5);\n    angle_vec *= 1.5 - scale;\n    scale /= 32.0;\n    return vec3(angle_vec, start);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 pos)\n{\n    // Center\n    pos -= iResolution.xy / 2.0;\n    \n    // Normalize\n    vec2 normPos = pos * 2.0 / iResolution.xy;\n    // Normalize aspect ratio\n    float aspectRatio = iResolution.x / iResolution.y;\n    normPos.x *= aspectRatio;\n\n    // Convert to polar coordinates\n    vec2 polar;\n    polar.x = length(normPos);\n    polar.y = phi(polar.x, normPos);\n\n    // vec3(x, y, radius);\n    vec3 metaballs[] = vec3[](\n        vec3(0.000000000000, 0.0000000, 0.100),\n      \tvec3(metaball(iTime, 0.0000000, 0.001)),\n        vec3(metaball(iTime, PI * 1.00, 0.001)),\n        vec3(metaball(iTime, PI * 0.50, 0.001)),\n        vec3(metaball(iTime, PI * 1.50, 0.001)),\n        vec3(metaball(iTime, PI * 0.30, 0.001)),\n        vec3(metaball(iTime, PI * 0.60, 0.001)),\n        vec3(metaball(iTime, PI * 1.70, 0.001)),\n      \tvec3(metaball(iTime, PI * 1.10, 0.01)),\n        vec3(metaball(iTime, PI * 0.10, 0.001)),\n        vec3(metaball(iTime, PI * 0.20, 0.001)),\n        vec3(metaball(iTime, PI * 1.30, 0.001)),\n        vec3(metaball(iTime, PI * 0.13, 0.001)),\n        vec3(metaball(iTime, PI * 0.56, 0.001)),\n        vec3(metaball(iTime, PI * 0.70, 0.001))\n    );\n    \n    // Sum all metaball strengths\n\tfloat value = 0.0;\n    for (int i = 0; i < metaballs.length(); i += 1) {\n        value += metaballs[i].z / pow(distance(metaballs[i].xy, normPos), 3.0);\n    }\n    \n    // Color based on metaball strength and threshold\n    if (value > threshold) {\n    \tfragColor.xyz = rainbow(polar);\n    } else if (value > threshold - threshold_aa) {\n        float t = smoothstep(threshold, threshold - threshold_aa, value);\n    \tfragColor.xyz = mix(rainbow(polar), vec3(0.0), t);\n    } else {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djyWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[447, 447, 489, 489, 579], [581, 581, 613, 626, 805], [807, 807, 860, 860, 1100]], "test": "untested"}
{"id": "WdjcDG", "name": "Circle radius perturbations", "author": "nickcody", "description": "Use mouse: y adjusts strength of sinusoidal perturbation of radius, x adjusts number of petals.\n", "tags": ["geometry", "basics"], "likes": 0, "viewed": 381, "published": 3, "date": "1587269562", "time_retrieved": "2024-07-30T21:11:55.058900", "image_code": "const vec3 white = vec3(1., 1., 1.);\nconst vec3 black = vec3(0., 0., 0.);\nconst vec3 gray  = vec3(.2, .2, .3);\n\n// circleTest\n//\n// coord      - pixel to test\n// center     - center of circle\n// radius     - radius of circle\n// width      - thickness of circle line\n// pixelWidth - blendiness\n\nvec3 circleTest(vec2 coord, vec2 center, float radius, float width, float pixelWidth) {\n    float delta = distance(coord, center)-radius;\n    \n    // From shadertoy default shader\n    vec3 inside = .5 + .5*cos(iTime+coord.xyx+vec3(0,2,4));\n    \n    float blend = smoothstep(0., pixelWidth, abs(delta) - width);\n    \n    if (delta  < 0.)\n        return mix(white, inside, blend); // rgb -> white (inside  edge)\n    else if (delta  > 0.)\n        return mix(white, black, blend);  // white -> black (outside edge)\n    else\n        return white;\t\t\t\t\t  // can't decide\n        \n}\n\n// Credit: https://thebookofshaders.com/edit.php#10/ikeda-simple-grid.frag\n//\nfloat grid(vec2 st, float res){\n    vec2 grid = fract(st*res);\n    return 1.-(step(res,grid.x) * step(res,grid.y));\n}\n\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord) {\n    \n    float aspect     = iResolution.y/iResolution.x,\n          pixelWidth = 1./iResolution.x,\n          width      = 2./iResolution.x,\n          maxPetals  = 12.,\n          br         = .1;\n\n    \n    vec2 dMouse = iMouse.xy == vec2(0) ? iResolution.xy/2. : iMouse.xy,\n         cen    = vec2(1., aspect) / 2.,\n    \t q      = fragCoord.xy/iResolution.x,\n    \t nq     = q - cen,\n    \t m      = dMouse.xy/iResolution.x,\n         nm     = m - cen;\n    \n    float a   = atan(nq.y,nq.x);\n    float p   = ceil(maxPetals * m.x);\n\tfloat vr  = 8. * br * aspect * nm.y; // -1./petals keeps bottom row as vr=0\n    float s   = sin(p * a);\n    float r   = br  + vr * s;\n    \n    vec3 c = circleTest(\n        q, \n        cen,\n        r,\n        width, \n        pixelWidth\n    );\n\t\n    c = c == vec3(0.) ? gray * grid(fragCoord, maxPetals/iResolution.x ) : c;\n    \n    out_color = vec4(c, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdjcDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[294, 294, 381, 381, 868], [870, 948, 979, 979, 1065], [1068, 1068, 1120, 1120, 2003]], "test": "untested"}
{"id": "wlXSR4", "name": "Busy crowd", "author": "zxxuan1001", "description": "Colorful stuff", "tags": ["2d", "trail"], "likes": 3, "viewed": 479, "published": 3, "date": "1587262422", "time_retrieved": "2024-07-30T21:11:56.012351", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy/iResolution.xy;\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    //fragColor = texture(iChannel0, p);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec3 render(in vec2 fragCoord, in float t) \n{\n    vec2 p = 2.0*fragCoord.xy/iResolution.xy-1.0;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 mo = 2.0*iMouse.xy/iResolution.xy-1.0;\n    mo.x *= iResolution.x/iResolution.y;\n    vec3 rpCol = draw(p, mo, SCALE, t);\n    return rpCol;\n}\n\n\nvec3 pixel(in ivec2 p)\n{\n    return texelFetch(iChannel0, p, 0).rgb; // not supported sometimes\n}\n\n\nvec3 pixel2(in vec2 p)\n{\n    return texture(iChannel0, p).rgb; // safe choice\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rpCol = render(fragCoord, iTime*SPEED);\n    ivec2 p = ivec2(fragCoord);\n    vec2 p1 = fragCoord;\n    vec2 r = iResolution.xy;\n    vec3 tex = vec3(0.0);\n    \n    \n\ttex += pixel(p+ivec2(-1,0));\n    tex += pixel(p+ivec2(1,0));\n    tex += pixel(p+ivec2(0,-1));\n    tex += pixel(p+ivec2(0,1));\n\t\n    /*\n    tex += pixel2((p1+vec2(-1.0, 0.0))/r);\n    tex += pixel2((p1+vec2(1.0, 0.0))/r);\n    tex += pixel2((p1+vec2(0.0, -1.0))/r);\n    tex += pixel2((p1+vec2(0.0, 1.0))/r);\n\t*/\n    tex *= 0.25;\n    \n    vec3 col = mix(rpCol, tex, TRAIL);\n    \n    fragColor = vec4(col, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define RIPPLE_NUM 24\n#define TRAIL 0.9\n#define SCALE 0.1\n#define SPEED 3.0\nfloat hash1(vec2 p)\n{\n\treturn fract(sin(dot(p.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\nvec3 ripple(vec2 p, vec2 cen, float r, float t) {\n    p -= cen;\n    float len = length(p)/r;\n    float len2 = len*len;\n    float n1 = cos(len-t+sin(cen.x+cen.y)) * exp(-0.65*len2);\n    float n2 = 0.7*cos(len-t+cen.x*1.0+cen.y*2.0) * exp(-0.63*len2);\n    float n3 = cos(len-t+cen.x*3.0-cen.y*1.0) * exp(-0.61*len2);\n    vec3 rp = vec3(n1,n2,n3) * 1.2;\n    return rp * rp;\n}\n\nvec3 draw(in vec2 uv, in vec2 mo, in float r, in float t) {\n    vec3 col = vec3(0.0);\n    float l = 1.0-length(uv);\n    col += vec3(0.0,0.05,0.1) * pow(32.0, l) * (0.6 + 0.4*sin(0.5*t));\n    col += ripple(uv, mo, r, t);\n    for (int i = 0; i < RIPPLE_NUM; i++) \n    {\n      float n = fract(float(i) * 1.731 + 0.131);\n      vec2 cen = -1.0 + 2.0*vec2(hash1(vec2(n*11.717, 10.0*n*n)), \n                               hash1(vec2(fract(n*11.511), sin(n))));\n      //vec2 cen = vec2(0.0);\n      cen +=  0.5*vec2(sin(1000.0*n + t), sin(100.0*cos(n) + t));\n      col += ripple(uv, cen, r + 0.2*sin(t+11.1*n)*r, t - 2.0*n);  \n    }\n    \n\treturn col;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXSR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 205]], "test": "untested"}
{"id": "WsByDy", "name": "Stateful Waves (click&wait)", "author": "brianhaak", "description": "Simple classical wave equation with non-trivial initializer and discrete lattice vibrating velocity (single mode frequency). Displacements are real values though to significantly increase lattice resolution. Based on Wyatt's \"Schrodinger Equation\"", "tags": ["physics", "computation"], "likes": 7, "viewed": 432, "published": 3, "date": "1587247065", "time_retrieved": "2024-07-30T21:11:57.225109", "image_code": "#define R iResolution.xy\nvoid mainImage( out vec4 pixel, in vec2 U )\n{\n    vec4 state = texture(iChannel0,U/R);\n\n    pixel.r = state.y;\n    pixel.g = abs(state.x * 0.0015);\n    pixel.b = -state.y;\n    \n    // Comment these two lines to visualise the discrete velocities\n    pixel.r = pixel.g;\n    pixel.b = pixel.g;\n\n    pixel.a = 1.0;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Based on Wyatt's https://www.shadertoy.com/view/Ws2XzR\n\n#define R iResolution.xy\nvec4 read_memory (vec2 U) {return texture(iChannel0, U / R);}\n\nvoid mainImage( out vec4 Q, in vec2 U ) {\n    \n    vec2 center = read_memory(U).xy;\n    float north_disp = read_memory(U + vec2(0, 1)).x;\n    float east_disp =  read_memory(U + vec2(1, 0)).x;\n    float south_disp = read_memory(U - vec2(0, 1)).x;\n    float west_disp =  read_memory(U - vec2(1, 0)).x;\n    \n    float old_displacement = center.x;\n    float old_velocity = center.y;\n    \n    \n    // Diffusion\n    //float new_displacement = 0.25 *\n    //    (north_disp + east_disp + south_disp + west_disp);\n    \n    // Wave or Schrodinger\n    float new_displacement = old_velocity +\n        0.25 * (north_disp + east_disp + south_disp + west_disp);\n    \n    // Schrodinger\n    //float new_velocity = 0.0 - old_displacement;\n    \n    // Classic wave\n    float new_velocity = new_displacement - old_displacement;\n    \n\n    Q.xy = vec2(new_displacement, new_velocity);\n    \n    Q.xy *= (U.x < 1. || U.y < 1. || R.x-U.x<1. || R.y-U.y<1.) ?\n        0.1 : 1.0;\n\n    \n    vec2 M = (U - iMouse.xy) / 2.5;\n    vec2 m = (iMouse.xy - iMouse.zw) / 2.5;\n    if (iMouse.z > 0.0 ) {\n        Q.xy = mix(\n            Q.xy,\n            vec2(\n                cos(m.x*M.x+m.y*M.y),\n                sin(m.x*M.x+m.y*M.y)),\n           \texp(-0.3 * dot(M, M))\n        );\n    }\n    \n    if (iFrame < 1) {\n        //vec2 D = (U - 0.5 * R) / 10.0;\n\t\t//Q.xy = 3.0 * exp(-dot(D, D))\n        //    * (vec2(cos(-9.*D.x+D.y),sin(-9.*D.x+D.y)));\n        \n    }\n    \n  \n    // Discrete velocity\n    Q.y = sign(Q.y);\n}\n\n\n\n\n/*\nvec4 average_neighborhood = 0.25 * (north + east + south + west);\n   \n    // float dt = 1.0;//0.05;\n\n\t// Classical Wave Equation :\n    //Q.x = dt * laplacian + center.x * mm[0].x + center.y * mm[0].y;\n    //Q.y = dt * laplacian + center.x * mm[1].x + center.y * mm[1].y;\n\n\t// laplacian - center.x\n\n    \n    //Q.x = dt * (average_neighborhood.x - center.x) + center.x + center.y;\n\n    //Q.y = dt * (average_neighborhood.x - center.x) + center.y;\n    \n    \n    // Q.x = average_neighborhood.x + center.y;\n\n    \n    //Q.y = average_neighborhood.x + center.y - center.x;\n\n\t//Q.x = Q.y + center.x;\n    \n    \n    \n    \n    // Q.y = average_neighborhood.x - center.x + center.y;\n    \n    //Q.y = average_neighborhood.x - center.x + center.y;\n    //Q.x = Q.y + center.x;\n\n\n\n\n    // Crazy system of rect filling (in the classic wave mode)\n    //new_displacement = Q.x > 0.0 ? 0.99 : 0.01;//00001;\n    //new_velocity = Q.y > 0.0 ? 0.0 : -0.5;\n    \n    //Q.xy = vec2(new_displacement, new_velocity);\n    \n    //Q.x = sign(Q.x);\n*/", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsByDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 70, 70, 337]], "test": "untested"}
{"id": "tsScWG", "name": "Sorting: Leonardo comb network", "author": "metalim", "description": "Trying to improve comb sorting network. Leonardo numbers seem to be well suited for distances.\nCycles still can be improved though, as currently they are just manually selected and not guaranteed to work for all inputs.\n\nSeems to be <= O(log(N)^2).", "tags": ["sort", "sorting", "parallel"], "likes": 4, "viewed": 329, "published": 3, "date": "1587243610", "time_retrieved": "2024-07-30T21:11:58.077828", "image_code": "/*\n\n==================== Sorting series ====================\n\nhttps://www.shadertoy.com/view/tsByzt - odd-even sorting network (aka parallel bubble sort).\nhttps://www.shadertoy.com/view/tsBczt - odd-even horizonta-vertical experiment.\nhttps://www.shadertoy.com/view/tdByzd - (2^N)-1 comb sorting network.\nhttps://www.shadertoy.com/view/tsScWG - Leonardo comb sorting network.\n\nPress 'R' to Reset.\nPress 'D' or hold left mouse button to see how much data is sorted.\n\nBuffer A - initial state of data to sort.\nBuffer B - test control variables (todo), currently just previous resolution.\nBuffer C - the sorting network.\nImage - display dataset number, current data state, current sorting state.\n\n*/\n\nint D(vec2 p, float n) {\n    int i=int(p.y), b=int(exp2(floor(30.-p.x-n*3.)));\n    i = ( p.x<0.||p.x>3.? 0:\n    i==5? 972980223: i==4? 690407533: i==3? 704642687: i==2? 696556137:i==1? 972881535: 0 )/b;\n \treturn i-i/2*2;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 muv = iMouse.xy/iResolution.xy;\n    if (iMouse.z>0. && muv.x+muv.y<uv.x+uv.y || iMouse.z<=0. && uv.x+uv.y>1.+.3*sin(iTime*.5) || texelFetch(iChannel1,ivec2(KEY_D,2),0).r>0.)\n        fragColor = lum(texelFetch(iChannel0,ivec2(fragCoord),0)) < lum(texelFetch(iChannel0,ivec2(fragCoord)-ivec2(1,0),0)) ? vec4(0.) : vec4(1.);\n    else\n\t    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n\n    // display dataset number\n    ivec4 conf = config(iResolution, iFrame);\n    vec2 i = fragCoord / 10.;\n    if ((i.x-=1.)<3. && i.y<7.) { fragColor += vec4(D(i,float(conf.w))); }\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//#define BW\n#define KEY_R 82\n#define KEY_D 68\n\nvec4 get(int index, sampler2D chan, vec3 res) {\n    ivec2 p;\n    p.x = index%int(res.x);\n    p.y = index/int(res.x);\n    return texelFetch(chan,p,0);\n}\n\nfloat lum(vec4 c)\n{\n    return dot(c.rgb*vec3(0.3,0.59,0.11),vec3(1.));\n}\n\nvec4 bw(vec4 col)\n{\n    col.r = (col.r+col.g+col.b)/3.;\n    return col.rrra;\n}\n\nvec4 init(sampler2D chan, vec2 uv)\n{\n    vec4 col = texture(chan, uv);\n#ifdef BW\n    return bw(col);\n#else\n    return col;\n#endif\n}\n\nbool isSorted(vec4 a, vec4 b)\n{\n    return lum(a) <= lum(b);\n}\n\nvec4 compareAndSwap(int i, int j, int isSecond, int size, sampler2D chan, vec3 res)\n{\n    vec4 a = get(i, chan, res);\n\tif (j<0 || j>=size) return a;\n    vec4 b = get(j, chan, res);\n\n    if (isSecond!=0)\n    {\n        // note we have to keep the order of comparison, or we will lose pixels!\n        // as we can have less(a,b)==less(b,a), both false.\n        if (isSorted(b,a)) return a;\n        return b;\n    }\n    if (isSorted(a,b)) return a;\n    return b;\n}\n\nivec4 config(vec3 res, int globFrame)\n{\n    int size = int(res.x)*int(res.y);\n    \n    int len = int(log2(float(size)));\n    len = len*len+60;\n    \n    int frame = globFrame%len;\n    \n\tint set = globFrame/len%9;\n    \n    return ivec4(size,len,frame,set);\n}\n\nint xy2i(vec2 pos, vec3 res)\n{\n    return int(pos.x)+int(res.x)*int(pos.y);\n}\n", "buffer_a_code": "\n/////////////////////////////////////////////////////////////////////////\n// common\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec4 conf = config(iResolution,iFrame);\n    int index = xy2i(fragCoord, iResolution);\n    vec2 uv = fragCoord/iResolution.xy;\n\n    if (conf.w==0)\n    {\n        // horizontal split, only 4 values\n        fragColor = vec4(float(int(fragCoord.x)*4/int(iResolution.x))/4.);\n    }\n    else if (conf.w==1)\n    {\n        // reversed\n        fragColor = vec4(float(conf.x-index-1)/float(conf.x));\n    }\n    else if (conf.w==2)\n    {\n        // color gradient\n        fragColor = vec4(1.-uv.y, 1.-uv.x, uv.y, 0.);\n    }\n    else if (conf.w==3)\n    {\n        // all sorted, but last element moved to front.\n        fragColor = vec4(float((index+conf.x-1)%conf.x)/float(conf.x));\n    }\n    else if (conf.w==4)\n    {\n        // even are sorted, odd are reversed\n        if (index%2==0)\n            fragColor = vec4(0.,float(index)/float(conf.x),0.,0.);\n        else\n            fragColor = vec4(float(conf.x-index-1)/float(conf.x),0.,0.,0.);\n    }\n    else if (conf.w==5)\n    {\n        // London texture\n        fragColor = vec4(init(iChannel0, uv).rgb,0.);\n    }\n    else if (conf.w==6)\n    {\n        // Alphabet texture\n        fragColor = vec4(init(iChannel1, uv).rgb,0.);\n    }\n    else if (conf.w==7)\n    {\n        // Blue noise texture\n        fragColor = vec4(init(iChannel2, uv).rgb,0.);\n    }\n    else\n    {\n        // RGB noise texture\n        fragColor = vec4(init(iChannel3, uv).rgb,0.);\n    }\n    fragColor.a = 0.; // frame number\n}\n", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(iResolution,0.);\n}\n\n", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\n// common\n\nvec4 get(int index)\n{\n    return get(index, iChannel0, iResolution);\n}\n\nvec4 compareAndSwap(int i, int j, int isSecond, int size)\n{\n    return compareAndSwap(i, j, isSecond, size, iChannel0, iResolution);\n}\n\n/////////////////////////////////////////////////////////////////////////\n// sorting\n\nint leonardo(int i)\n{\n    if(i<2) return 1;\n    int a=1;\n    int b=1;\n    for (;i>1;i--)\n    {\n        int t = b;\n        b += a+1;\n\t\ta = t;\n    }\n    return b;\n}\n\n#define max_step_power 24\n#define large_cycle 11\n#define small_cycle 5\n\nvec4 update(int i, int size, int frame)\n{\n    // All distances are odd, because we select odd-even pairs.\n    int isSecond = (i+frame)%2;\n    int k = frame/large_cycle - frame%small_cycle;\n    int dist = leonardo(max_step_power-k);\n    int j = i + dist*(1 - isSecond*2);\n\n    return compareAndSwap(i, j, isSecond, size);\n}\n\n/////////////////////////////////////////////////////////////////////////\n// common\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    ivec4 conf = config(iResolution,iFrame);\n\n    if (conf.z>=0 && conf.z<60 || get(0,iChannel1,iResolution).xy != iResolution.xy || texelFetch(iChannel3,ivec2(KEY_R,0),0).r>0.)\n    {\n        fragColor = texture(iChannel2,uv);\n    }\n    else\n    {\n        int index = xy2i(fragCoord, iResolution);\n        int frame = int(texelFetch(iChannel0,ivec2(fragCoord),0).a*256.);\n        fragColor = update(index, int(iResolution.x)*int(iResolution.y), frame);\n    \tfragColor.a = float(frame+1)/256.;\n    }\n}\n", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsScWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[698, 698, 722, 722, 920], [923, 923, 980, 980, 1603]], "test": "untested"}
{"id": "tsSyWG", "name": "Monochrome.", "author": "kaneta", "description": "Raymarching and Bytebeat\n\nImage based on https://www.shadertoy.com/view/3d2cRV", "tags": ["raymarching", "sound", "bytebeat"], "likes": 5, "viewed": 485, "published": 3, "date": "1587236872", "time_retrieved": "2024-07-30T21:11:58.985401", "image_code": "void mainImage( out vec4 o, in vec2 f ) {\n    vec3 w,p;\n    for(int i=0;i<32;++i)p=vec3((f*2.-iResolution.xy)/iResolution.y,1)*w+iTime,w+=length(cos(p.xx)+sin(p.yz)*mainSound( in int samp,iTime).x)*.3;\n    o=vec4(w*.1,1);\n}", "image_inputs": [], "sound_code": "", "sound_inputs": [], "common_code": "vec2 mainSound( in int samp,float t) {\n    int i=int(t*8000.);\n    return vec2(float((i>>4|(i*(bool(i>>4&128)?i>>10&i>>9:0)))&255)/512.-1.);\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsSyWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ts2yRd", "name": "Coloured Wallpaper", "author": "mla", "description": "The 12 non-hexagonal wallpaper groups, with colouring.\n\nSee code for controls.", "tags": ["wallpaper"], "likes": 3, "viewed": 438, "published": 3, "date": "1587235903", "time_retrieved": "2024-07-30T21:11:59.851087", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Coloured Wallpaper. Generate the 12 non-hexagonal wallpaper groups, and\n// use symmetries to generate a consistent colouring.\n// Matthew Arcus (mla), 2020\n//\n// <mouse>: change offset into texture\n// <up>/<down>: zoom in/out\n// <page up>/<page down>: number of colours, 1-8\n// <left>/<right>: select groups, default cycles through them all\n// c: colouring of regions\n// e: enlarge texture\n// r: use equilateral rhombus for basic tile\n// o: offset into texture\n// 1-6: draw various grid lines\n// \n////////////////////////////////////////////////////////////////////////////////\n\nbool docolor = true;\nbool dolines = true;\nfloat scale = 2.2;\nint ncolors = 5;\nfloat lod = 1.0;\n\nfloat PI = 3.141592654;\n\n// Map to lattice separately as it's useful to have the\n// resulting intermediate point.\nvec2 lattice(vec2 z, out ivec2 index) {\n  vec2 z1 = round(0.5*z);\n  index = ivec2(z1);\n  z -= 2.0*z1;\n  return z;\n}\n\nvoid try(inout vec2 z, inout int index, bool test, vec2 z1) {\n  index = (index << 1) | int(test);\n  if (test) z = z1;\n}\n\nvoid try(inout float x, inout int index, bool test, float x1) {\n  index = (index << 1) | int(test);\n  if (test) x = x1;\n}\n\nbool alert = false;\n\n// Wallpaper groups - also Conway's orbiform notation.\nint p1 = 1; // o\nint p2 = 2; // 2222\nint pm = 3; // **\nint pg = 4; // xx\nint cm = 5; // *x\nint pmm = 6; // *2222\nint pmg = 7; // 22*\nint pgg = 8; // 22x\nint cmm = 9; // 2*22\nint p4 = 10; // 442\nint p4m = 11; //*442\nint p4g = 12; // 4*2\n\n// How many bits for the index.\nint nbits[12] = int[](0,1,1,1,1,2,2,2,2,2,3,3);\n\nvec2 wallpaper(vec2 z, int type, out int index) {\n  index = 0;\n  if (type == p1) {\n    // Nothing to do\n  } else if (type == p2 || type == pgg) {\n    // 2-fold rotation\n    try(z,index,z.x < 0.0,-z); // Rotate 180 about 0\n    if (type == pgg) {\n      // (viii) reflect up, glide, then reflect back - pgg\n      bool p = z.y < 0.0;\n      if (p) z.y = -z.y;\n      try(z,index,z.x+z.y > 1.0,vec2(1.0-z.x,z.y-1.0));\n      if (p) z.y = -z.y;\n    }\n  } else if (type == pm || type == pmg) {\n    try(z.x,index,z.x < 0.0,-z.x); // Reflect in x=0 - pm\n    if (type == pmg) {\n      // (vii) reflect in x, then rotate about (0.5,0) - pmg\n      try(z,index,z.y < 0.0, vec2(1.0-z.x,-z.y));\n    }\n  } else if (type == pg) {\n    try(z,index,z.x < 0.0, vec2(z.x+1.0,-z.y)); // Glide along y=0\n  } else if (type == cm || type == cmm) {\n    try(z,index,z.x+z.y < 0.0,-z.yx); // reflect in x+y=0\n    if (type == cmm) {\n      // (ix) also reflect in x = y - cmm\n      try(z,index,z.y > z.x,z.yx);\n    }\n  } else if (type == pmm || type == p4m) { // Rhomboid\n    index |= 2*int(z.x < 0.0) + int(z.y < 0.0); // 2 bits\n    z = abs(z); // (vi) reflect quadrants - pmm\n    if (type == p4m) {\n      // (xi) 4 reflection axes - p4m\n      try(z,index,z.x + z.y > 1.0, 1.0-z.yx); // Reflect in x+y=1\n    }\n  } else if (type == p4 || type == p4g) {\n    // 4-fold rotation\n    // (x) rotate quadrants - p4\n    index |= 2*int(z.x < 0.0) + int(z.y < 0.0);\n    if (z.x < 0.0) { z = -z; } // Rotate 180 about 0\n    if (z.y < 0.0) z = vec2(-z.y,z.x); // Rotate 90 about 0\n    if (type == p4g) {\n      // (xii) additionally: reflect in x+y=1 - p4g\n      try(z,index,z.x+z.y > 1.0,1.0-z.yx); // Reflect in x+y=1\n    }\n  } else {\n    alert = true;\n  }\n  return z;\n}\n\nfloat linedist(vec2 pos, vec2 a, vec2 b) {\n  vec2 pa = pos - a;\n  vec2 ba = b - a;\n  float h = dot(pa, ba) / dot(ba, ba);\n  float d = length(pa - ba * h);\n  return d;\n}\n\nint mymod(int n, int m) {\n  // glsl % undefined for -ve arguments\n  if (n < 0) return m-1-(-n-1)%m;\n  else return n%m;\n}\n\nvec3 indexcolor(int index) {\n  index = mymod(index, ncolors);\n  vec3 col = vec3(0);\n  if (index == 0) col = vec3(1,0,0);\n  if (index == 1) col = vec3(1,1,0);\n  if (index == 2) col = vec3(0,1,0);\n  if (index == 3) col = vec3(0,0,1);\n  if (index == 4) col = vec3(0,1,1);\n  if (index == 5) col = vec3(1,0,1);\n  if (index == 6) col = vec3(1);\n  if (index == 7) col = vec3(0.5);\n  return 0.5+0.5*col;\n}\n\nbool dooffset = true;\nbool doenlarge = true;\n\nvec3 getcolor(vec2 z, int type, ivec4 ivector) {\n  vec2 offset = vec2(0);\n  if (dooffset) offset += vec2(sin(0.1*iTime),sin(0.123*iTime));\n  if (iMouse.x > 0.0) {\n    offset += 2.0*(2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n  }\n  vec2 uv = 0.5*z-0.5+offset;\n  if (doenlarge) uv *= 0.5;\n  vec4 tt = textureLod(iChannel0,uv,lod);\n  if (!docolor) return tt.xyz;\n  // Generate a colour from the index. Lots of ways this could\n  // be done, eg. just use z and w so whole tile gets same colour.\n  int index = 0;\n  int n = nbits[type];\n  if (n == 3) {\n    index = ivector.x;\n    // xor the top bit (bit 3) with the other bits\n    index ^= -((index>>2)&1);\n    index &= 3;\n    // offset for the tile\n    index += ivector.z + ivector.w;\n  } else {\n    index = ((ivector.z + ivector.w)<<n) - ivector.x;\n  }\n  vec3 color = indexcolor(index);\n  color *= length(tt.xyz);\n  return color;\n}\n\nconst int CHAR_0 = 48;\nconst int CHAR_C = 67;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_H = 72;\nconst int CHAR_M = 77;\nconst int CHAR_O = 79;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel3, ivec2(i,j),0);\n}\n\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\nbool key(int key) {\n  return texelFetch(iChannel2,ivec2(key,2),0).x != 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  int type = mymod(keycount(KEY_RIGHT)-keycount(KEY_LEFT),13);\n  if (type == 0) type = 1+int(0.2*iTime)%12;\n  ncolors = 1+mymod(5+keycount(KEY_PAGE_DOWN)-keycount(KEY_PAGE_UP),8);\n  docolor = !key(CHAR_C);\n  dooffset = !key(CHAR_O);\n  doenlarge = key(CHAR_E);\n  scale *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  lod = log2(scale*iChannelResolution[0].y/iResolution.y);\n  if (doenlarge) lod -= 1.0;\n  vec2 z = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  z *= scale;\n  mat2 m = mat2(1);\n  //m = mat2(-0.8,0.5,0.8,0.5);\n  // Use rhombus for basic tile - not all groups work with this.\n  if (key(CHAR_R)) m = 0.5*mat2(1,sqrt(3.0),-1,sqrt(3.0));\n  z = inverse(m)*z;\n  ivec4 index;\n  vec2 z0 = z;\n  z = lattice(z,index.zw);\n  vec2 z1 = m*z;\n  z = wallpaper(z,type,index.x);\n  z = m*z;\n  //if (z != z0) alert = true; // Show region\n  vec3 col = getcolor(z,type,index);\n  if (dolines) {\n    // Draw various grid lines.\n    float d = 1e8;\n    vec2 p = m*vec2(1,1);\n    vec2 q = m*vec2(1,-1);\n    vec2 r = m*vec2(-1,-1);\n    vec2 s = m*vec2(-1,1);\n    vec2 pq = 0.5*(p+q);\n    vec2 rs = 0.5*(r+s);\n    vec2 qr = 0.5*(q+r);\n    vec2 sp = 0.5*(s+p);\n    if (!key(CHAR_0+1)) {\n      d = min(d,linedist(z1,p,q));\n      d = min(d,linedist(z1,q,r));\n      d = min(d,linedist(z1,r,s));\n      d = min(d,linedist(z1,s,p));\n    }\n    if (key(CHAR_0+2)) d = min(d,linedist(z1,pq,rs));\n    if (key(CHAR_0+3)) d = min(d,linedist(z1,qr,sp));\n    if (key(CHAR_0+4)) d = min(d,linedist(z1,p,r));\n    if (key(CHAR_0+5)) d = min(d,linedist(z1,q,s));\n\n    if (key(CHAR_0+6)) {\n      d = min(d,linedist(z1,pq,qr));\n      d = min(d,linedist(z1,qr,rs));\n      d = min(d,linedist(z1,rs,sp));\n      d = min(d,linedist(z1,sp,pq));\n    }\n\n    col *= smoothstep(0.01,0.02,d);\n  }\n  if (alert) col *= 0.6;\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel2,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x);\n  int j = int(uv.y);\n  if ( iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel3,ivec2(i,j),0); // Get current state   \n  }  \n  if (i == 0) {\n    float w1 = keystate(j,2).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      t.x++;\n    }\n  }     \n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2yRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[786, 875, 914, 914, 990], [992, 992, 1053, 1053, 1111], [1113, 1113, 1176, 1176, 1234], [1630, 1630, 1679, 1679, 3355], [3357, 3357, 3399, 3399, 3525], [3527, 3527, 3552, 3592, 3647], [3649, 3649, 3677, 3677, 4046], [4094, 4094, 4142, 4142, 4972], [5385, 5385, 5410, 5410, 5458], [5460, 5460, 5483, 5483, 5515], [5517, 5517, 5536, 5536, 5594], [5596, 5596, 5653, 5653, 7468]], "test": "untested"}
{"id": "WdScDG", "name": "Bloom [skull]", "author": "tdhooper", "description": "Created for the Revision 2020 animated gif competition. You can enable DOF and shadows in the common tab if you have a powerful GPU.", "tags": ["zoom", "flower", "loop", "skull", "succulent"], "likes": 80, "viewed": 1585, "published": 3, "date": "1587221148", "time_retrieved": "2024-07-30T21:12:01.093764", "image_code": "/*\n\n    Bloom\n    -----\n\n\tCreated for the Revision 2020 animated gif competition, achieving 1st place.\n\tAs this gets rendered to a gif, image quality is given much more importance\n\tthan rendering speed and code size; so yes, this is a lot of code, it takes\n\ta long time to compile, and it runs slow.\n\n\tI’ve disabled shadows and the depth of field pass so this has a chance of\n\trunning, if you have a powerful GPU, you can enable them with the defines\n\tin common.\n\n\tMakes use of a few things I’ve worked on recently:\n\n\t\t* Uses a pseudo-3d texture to cache the skull distance function\n\t\t  https://www.shadertoy.com/view/WljSWz\n\n\t\t* Smooth fractal zoom to an arbitrary point and rotation\n\t\t  https://www.shadertoy.com/view/wslyzH\n\n\t\t* Parametric succulent model\n\t\t  https://www.shadertoy.com/view/WtGXWm\n\n\tThe skull was modelled on this https://sketchfab.com/3d-models/visible-interactive-human-exploding-skull-252887e2e755427c90d9e3d0c6d3025f,\n\tusing a method of overlaying my sdf model on the polygon model, and\n\tadjusting positions/sizes until the surfaces were close enough. It’s a slow\n\tand tedious process, I wouldn’t recommend it! I actually ran out of time to\n\tmodel the zygomatic arch.\n\n\tThis photo by Scott Webb was my colour reference:\n\thttps://www.pexels.com/photo/photo-of-succulent-plants-1903969/\n\n\tSpecial thanks to yx for giving me some serious competition with her entry:\n    http://moonbase.lgbt/misc/yx-hexahedral-recurrence.gif\n\n*/\n\n\n// http://tuxedolabs.blogspot.com/2018/05/bokeh-depth-of-field-in-single-pass.html\n\nvec2 uPixelSize; //The size of a pixel: vec2(1.0/width, 1.0/height)\nfloat uFar = .32; // Far plane\n\nconst float GOLDEN_ANGLE = 2.39996323;\nconst float MAX_BLUR_SIZE = 30.;\nconst float RAD_SCALE = .2; // Smaller = nicer blur, larger = faster\n\nfloat getBlurSize(float depth, float focusPoint, float focusScale) {\n    float coc = clamp((1.0 / focusPoint - 1.0 / depth)*focusScale, -1.0, 1.0);\n    return abs(coc) * MAX_BLUR_SIZE;\n}\n\nfloat dbg;\n\nvec3 depthOfField(vec2 texCoord, float focusPoint, float focusScale) {\n    vec4 centerTex = texture(iChannel0, texCoord);\n    float centerDepth = centerTex.a * uFar;\n    float centerSize = getBlurSize(centerDepth, focusPoint, focusScale);\n    vec3 color = centerTex.rgb;\n    \n    #ifdef DISABLE_DOF\n    \treturn color;\n    #endif\n\n    float tot = 1.0;\n\n    float radius = RAD_SCALE;\n    for (float ang = 0.; radius < MAX_BLUR_SIZE; ang += GOLDEN_ANGLE) {\n        dbg += 1.;\n        vec2 tc = texCoord + vec2(cos(ang), sin(ang)) * uPixelSize * radius;\n        vec4 sampleTex = texture(iChannel0, tc);\n        vec3 sampleColor = sampleTex.rgb;\n        float sampleDepth = sampleTex.a * uFar;\n        float sampleSize = getBlurSize(sampleDepth, focusPoint, focusScale);\n        //if (sampleSize < centerSize) break;\n        if (sampleDepth > centerDepth) {\n            sampleSize = clamp(sampleSize, 0.0, centerSize*2.0);\n        }\n        float m = smoothstep(radius-0.5, radius+0.5, sampleSize);\n        color += mix(color/tot, sampleColor, m);\n        tot += 1.0;\n        radius += RAD_SCALE/radius;\n        \n        // modification: exit early when we're in focus\n        if (centerDepth < uFar / 3. && m == 0.) break;\n    }\n    return color /= tot;\n}\n\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uPixelSize = vec2(.002) / (iResolution.xy / iResolution.y);\n\n    float focusA = .03 * 2.;\n    float focusAStart = .25;\n    float focusAEnd = .65;\n\n    float focusB = .045 * 2.;\n    float focusBStart = .65;\n    float focusBEnd = 1.;\n\n    float time = loopTime(iTime);\n    float blend = smoothstep(focusAStart, focusAEnd, time) - smoothstep(focusBStart, focusBEnd, time);\n    float focus = mix(focusB, focusA, blend);\n\n    dbg = 0.;\n    vec3 col = depthOfField(uv, focus, .05);\n\n    // fix banding\n    vec4 grain = texture(iChannel1, fragCoord.xy / iChannelResolution[1].x);\n\tcol += (grain.x * 2. - 1.) * .002;\n    \n    col = pow( col, vec3(0.4545) ) * sign(col);\n    col = aces(col);\n\n    fragColor = vec4(col, 1);    \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define DISABLE_DOF\n#define DISABLE_SHADOWS\n\nfloat loopTime(float iTime) {\n\treturn mod(iTime / 3. + .35, 1.);\n}\n\n// '3D' Texture Utils\n// https://www.shadertoy.com/view/WljSWz\n//--------------------------------------------------------\n\nvec2 texSubdivisions = vec2(8,2);\n\n#define MIRROR\n#define SCALE (vec3(4.1,1.8,1.75))\n#define OFFSET vec3(.95, .05, .05)\n\nint faceIdFromDir(vec3 v) {\n    vec3 va = abs(v);\n    int id = 0;\n    float m = va.x;\n    if (va.y > m) id = 1, m = va.y;\n    if (va.z > m) id = 2;\n    if (v[id] < 0.) id += 3;\n    return id;\n}\n\nvec3 dirFromFaceId(vec2 uv, int id) {\n    vec3 dir = vec3(.5, .5 - uv.yx);\n    dir = normalize(dir);\n    if (id == 4) dir.yz *= -1.;\n    if (id > 2) dir.xz *= -1., id -= 3;\n    if (id == 1) return (dir * vec3(1,-1,-1)).zxy;\n    if (id == 2) return (dir * vec3(1,1,-1)).zyx;    \n    return dir;\n}\n\nvec3 texToSpace(vec2 coord, int c, int id, vec2 size) {\n    vec2 sub = texSubdivisions;\n    vec2 subSize = floor(size / sub);\n    vec2 subCoord = floor(coord / subSize);\n    float z = 0.;\n    z += float(id) * 4. * sub.y * sub.x; // face offset\n    z += float(c) * sub.y * sub.x; // channel offset\n    z += subCoord.y * sub.x; // y offset\n    z += subCoord.x; // x offset\n    float zRange = sub.x * sub.y * 4. * 6. - 1.;\n    z /= zRange;\n    vec2 subUv = mod(coord / subSize, 1.);\n    vec3 p = vec3(subUv, z);\n    p = p * 2. - 1.; // range -1:1\n    return p;\n}\n\nmat4 texToSpace(vec2 coord, int id, vec2 size) {\n    return mat4(\n        vec4(texToSpace(coord, 0, id, size), 0),\n        vec4(texToSpace(coord, 1, id, size), 0),\n        vec4(texToSpace(coord, 2, id, size), 0),\n        vec4(texToSpace(coord, 3, id, size), 0)\n    );\n}\n\nvec4 spaceToTex(vec3 p, vec2 size) {\n    p = clamp(p, -1., 1.);\n    p = p * .5 + .5; // range 0:1\n\n    vec2 sub = texSubdivisions;\n    vec2 subSize = floor(size / sub);\n\n    float zRange = sub.x * sub.y * 4. * 6. - 1.;\n    float i = round(p.z * zRange);\n\n    vec2 coord = p.xy * subSize;\n\n    int faceId = int(floor(i / (4. * sub.y * sub.x)));\n    float channel = mod(floor(i / (sub.x * sub.y)), 4.);\n    float y = mod(floor(i / sub.x), sub.y);\n    float x = mod(i, sub.x);\n    \n    coord += vec2(x,y) * subSize;\n\tcoord /= size;\n    \n    vec3 dir = dirFromFaceId(coord, faceId);\n\n    return vec4(dir, channel);\n}\n\n\nfloat range(float vmin, float vmax, float value) {\n  return clamp((value - vmin) / (vmax - vmin), 0., 1.);\n}\n\nfloat mapTex(samplerCube tex, vec3 p, vec2 size) {\n    #ifdef MIRROR\n        p.x = clamp(p.x, -.95, .95);\n    #endif\n    vec2 sub = texSubdivisions;\n    float zRange = sub.x * sub.y * 4. * 6. - 1.;\n    float z = p.z * .5 + .5;\n    float zFloor = (floor(z * zRange) / zRange) * 2. - 1.;\n    float zCeil = (ceil(z * zRange) / zRange) * 2. - 1.;\n    vec4 uvcA = spaceToTex(vec3(p.xy, zFloor), size);\n    vec4 uvcB = spaceToTex(vec3(p.xy, zCeil), size);\n    float a = texture(tex, uvcA.xyz)[int(uvcA.w)];\n    float b = texture(tex, uvcB.xyz)[int(uvcB.w)];\n    return mix(a, b, range(zFloor, zCeil, p.z));\n}\n", "cube_a_code": "\n// Big un-optimised distance function, mekes heavy use\n// of HG_SDF, smooth min, and IQ's accurate ellipse distance\n\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat smin2(float a, float b, float r) {\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n    return max(r, min (a, b)) - length(u);\n}\n\nfloat smax2(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nfloat smin3(float a, float b, float k){\n    return min(\n        smin(a, b, k),\n        smin2(a, b, k)\n    );\n}\n\nfloat smax3(float a, float b, float k){\n    return max(\n        smax(a, b, k),\n        smax2(a, b, k)\n    );\n}\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n    p = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\nvec3 pRx(vec3 p, float a) {\n    pR(p.yz, a); return p;\n}\n\nvec3 pRy(vec3 p, float a) {\n    pR(p.xz, a); return p;\n}\n\nvec3 pRz(vec3 p, float a) {\n    pR(p.xy, a); return p;\n}\n\n\nfloat vmin(vec2 v) {\n    return min(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec2 v) {\n    return max(v.x, v.y);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fCorner(vec3 p, float r) {\n    vec3 d = p + r;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0))) - r;\n}\n\nfloat fCorner(vec2 p, float r) {\n    vec2 d = p + r;\n    return length(max(d, vec2(0))) + vmax(min(d, vec2(0))) - r;\n}\n\n\n// iq https://www.shadertoy.com/view/MldfWn\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n    p = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\n    float l = ab.y*ab.y - ab.x*ab.x;\n    \n    float m = ab.x*p.x/l; \n    float n = ab.y*p.y/l; \n    float m2 = m*m;\n    float n2 = n*n;\n    \n    float c = (m2 + n2 - 1.0)/3.0; \n    float c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx) + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = ab * vec2(co,si);\n    \n    return length(r-p) * sign(p.y-r.y);\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXXZ( in vec3 p, in vec2 r ) \n{\n    return sdEllipse( vec2( length(p.xy), p.z ), r );\n}\n\nfloat sdEllipsoidXXZPill(vec3 p, vec2 r) {\n    p.z = min(p.z, 0.);\n    return sdEllipsoidXXZ(p, r);\n}\n\nfloat fCone(vec3 p, float angle) {\n    vec2 c = vec2(length(p.xz), p.y);\n    pR(c, angle);\n    return length(max(c, vec2(0))) + vmax(min(c, vec2(0)));\n}\n\nfloat fPillHalf(vec3 p) {\n    p.y = min(p.y, 0.);\n    return length(p);\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n    vec3 ab = b - a;\n    float t = saturate(dot(p - a, ab) / dot(ab, ab));\n    return length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    return fLineSegment(p, a, b) - r;\n}\n\n// curve the x axis around the y axis\nvoid pCurve(inout vec3 p, float r) {\n    p.z -= r;\n    r = abs(r);\n    p = vec3(atan(p.x, -p.z) * r, p.y, length(p.xz) - r);\n}\n\nfloat fMaxillaCore(vec3 p) {\n    float d = 1e12;\n    vec3 pp = p;\n\n    // Core\n    p = pRx(p - vec3(0,.33,-.32), .3);\n    d = length(p.xz) - .18;\n    d = smax(d, -(length((p - vec3(0,0,.1)).xz) - .1), .1);\n    d = smax(d, p.y - .02, .1);\n    d = smax(d, -p.y - .1, .1);\n    p = pp;\n\n    // Gum\n    p = pRx(p - vec3(0,.42,-.29), .4);\n    d = smin(d, sdEllipsoidXXZ(p, vec2(.2, .27)), .07);\n    p = pp;\n\n    // Gum back inner\n    p = pRx(p - vec3(0,.42,-.29), .1);\n    float gumback = pRy(p, .55).z - .01;\n    gumback = smin(gumback, pRy(p, -.55).z - .08, .04);\n    d = smax(d, gumback, .08);\n    p = pp;\n\n    // Gum back outer\n    p = p - vec3(.17,.3,-.24);\n    float part = dot(p, normalize(vec3(1,-.2,1)));\n    d = smax(d, part, .03);\n    p = pp;\n\n    return d;\n}\n\nfloat fMaxillaBottom(vec3 p) {\n    float b = p.z + .15;\n    p = pRx(p - vec3(0,.42,-.29), .42);\n    pCurve(p.zxy, -.8);\n    float d = p.y;\n    return min(d, -b);\n}\n\nfloat fSocketBump(vec3 p) {\n    vec3 pp = p;\n    p = pRz(pp - vec3(.13,.04,-.35), .2);\n    float d = sdEllipsoidXXZ(p.xzy, vec2(.19,.13));\n    p = pp - vec3(.14,.15,-.35);\n    d = smin(d, sdEllipsoidXXZ(p, vec2(.19,.16)), .07);\n    p = pp - vec3(.24,.03,-.38);\n    d = smin(d, length(p) + .005, .15);\n    return d;\n}\n\nfloat fSocketInset(vec3 p) {\n    vec3 pp = p;\n    p = pRz(pp - vec3(.16,.08,-.4), .3);\n    p.z = max(p.z, 0.);\n    float d = sdEllipsoidXXZ(p.xzy, vec2(.08,.05));\n    p = pRz(pp - vec3(.18,.15,-.4), .2);\n    d = smin(d, sdEllipsoidXXZ(p.xzy, vec2(.042,.02)), .16);\n    p = pp - vec3(.235,.1,-.43);\n    d = smin(d, length(p) - .023, .08);\n    p = pp - vec3(.26,.11,-.36);\n    d = smax(d, dot(p, normalize(vec3(1,.2,1))) + .01, .04);\n    return d;\n}\n\nfloat fSocket(vec3 p) {\n    vec3 pp = p;\n    p = pRz(pp - vec3(.15,.06,-.38), .7);\n    float d = sdEllipsoidXXZ(p.xzy, vec2(.11,.08));\n    p = pRz(pp - vec3(.15,.16,-.38), -.15);\n    d = smin(d, sdEllipsoidXXZ(p.xzy, vec2(.08,.03)), .1);\n    p = pp - vec3(.26,.11,-.36);\n    d = smax(d, dot(p, normalize(vec3(1.5,.2,1))) + .01, .04);\n    return d;\n}\n\nfloat fNoseShape(vec3 p) {\n    p = pRz(p, -.4);\n    return sdEllipse(p.xy - vec2(-.055, 0), vec2(.1,.18));\n}\n\nfloat fNose(vec3 p) {\n    p = pRx(p - vec3(.0,.25,-.5), .4);\n    float d = smax(fNoseShape(p), fNoseShape(p * vec3(-1,1,1)), .02);\n    d = smax(d, p.y-.09, 0.04);\n    d = smax(d, -sdEllipse(p.xy - vec2(0,.18), vec2(.02,.1)), 0.03);\n    d = max(d, -p.z-.15);\n    d = smax(d, p.z-.05, .05);\n    return d;\n}\n\nfloat fNoseCut(vec3 p) {\n    float r = .3;\n    p = pRy(pRx(p - vec3(0,.49,-.57), -.45), .35);\n    return length(p.yz + vec2(0,r)) - r;\n}\n\nfloat fArchhole(vec3 p) {\n    p = pRz(pRy(p - vec3(.3,.15,-.25), -.4), .3);\n    vec3 pp = p;\n    p -= vec3(.045,0,0);\n    float d = dot(p, normalize(vec3(1,0,-.12))) + .01;\n    p = pp - vec3(0,0,-.085);\n    d = smax(d, -dot(p, normalize(vec3(0,-.14,1))), .05);\n    p = pRy(pRz(pRx(pp - vec3(.035,.1,-.08), -.29), -.2), .6);\n    float h = .1;\n    p.z += .013;\n    p.z -= h;\n    d = smin(d, sdEllipse(p.xz, vec2(.03, h)), .04);\n    p = pp - vec3(.015,-.29,0);\n    d = smax(d, -dot(p, normalize(vec3(-.1,1,.35))), .1); // top\n    p = pp - vec3(-.05,0,-.05);\n    d = smax(d, dot(p, normalize(vec3(-1,-.05,-.4))) - .005, .05);\n    p = pp - vec3(-.038,-.1,.05);\n    d = smax(d, dot(p, normalize(vec3(-.8,-.21,.08))) - .005, .03);\n    p = pRz(pRy(pp - vec3(0,-.084,.25), .4), -.27);\n    d = smax(d, -(length(p.zy) - .16), .15);\n    p = pp - vec3(0,.2,.04);\n    d = smax(d, dot(p, normalize(vec3(-.2,.8,1))), .05);\n    p = pp;\n    d = smax(d, p.y-.25, .1);\n    return d;\n}\n\nfloat sdSkull(vec3 p) {\n\n    p.x = abs(p.x);\n    vec3 pp = p;\n    float d = 1e12;\n    float back = sdEllipsoidXXZ(p - vec3(0,-.11,.16), vec2(.4, .32));\n    d = min(d, back);\n    float base = length(p - vec3(0,-.08,.25)) - .15;\n    d = smin(d, base, .3);\n    float baseside = length(p - vec3(.2,.1,.25)) - .05;\n    d = smin(d, baseside, .25);\n    float forehead = sdEllipsoidXXZ(pRx(p - vec3(0,-.15,-.14), .5), vec2(.35, .44) * .97);\n    d = smin(d, forehead, .22);\n    float foreheadside = length(p - vec3(.17,-.13,-.3)) - .05;\n    d = smin(d, foreheadside, .25);\n    float socketbump = smin(fSocketBump(p), fSocketBump(p * vec3(-1,1,1)), .15);\n    d = smin(d, socketbump, .09);\n\n    p = pRx(p - vec3(0,.23,-.45), -.55);\n    float bridge = sdEllipse(p.xz, vec2(.06, .15));\n    bridge = max(bridge, -p.y-.3);\n    d = smin(d, bridge, .1);\n    p = pp;\n\n    p = pRy(pRx(p - vec3(.22,.3,-.4), .4), -.1);\n    float cheek = smax(sdEllipsoidXXZ(p.zyx, vec2(.02, .05)), -p.z, 0.05);\n    d = smin(d, cheek, 0.1);\n    p = pp;\n    float maxilla = fMaxillaCore(p);\n    d = smin(d, maxilla, .08);\n    float foramen = fCone(pRx(pRy(p - vec3(.17,.27,-.465), .5), -.5) * vec3(1,-1,1), .6);\n    foramen = smax(foramen, p.y-.45, .1);\n    d = smax(d, -foramen - .01, .05);\n\n    float socketinset = smin(fSocketInset(p), fSocketInset(p * vec3(-1,1,1)), .2);\n    d = smax(d, -socketinset, .12);\n    float socket = fSocket(p);\n    d = smax(d, -socket, .04);\n    float backbump = sdEllipsoidXXZ(pRx(pRy(p - vec3(.27,-.29,.0), -.25), .0), vec2(.1, .5) * .25);\n    d = smin(d, backbump, .34);\n    float topbump = sdEllipsoidXXZ(p - vec3(0,-.33,-.05), vec2(.1, .15) * .5);\n    d = smin(d, topbump, .3);\n\n    float side = sdEllipsoidXXZ(pRz(p - vec3(.2,.05,-.0), .3).yzx, vec2(.1, .05));\n    d = smin(d, side, .25);\n\n    // bridge adjust\n    p = pRx(p - vec3(0,.2,-.5), -.2);\n    d = smin(d, max(length(p.xz) - .03, -p.y-.3), .05);\n    p = pp;\n\n    // canine socket\n    p = pRy(pRz(p - vec3(.14,.55,-.495), -.4), .5);\n    p.x = max(p.x, 0.);\n    float caninesocket = length(p.xz) - .01;\n    caninesocket = smax(caninesocket, -p.y-.2, .01);\n    d = smin(d, caninesocket, .03);\n    p = pp;\n\n    // Nose\n    float nos = fNose(p);\n    d = smin(d, nos-.01, .02);\n    p = pp;\n\n    float nosecut = smin(fNoseCut(p), fNoseCut(p * vec3(-1,1,1)), .04);\n    d = smax(d, -nosecut, .01);\n    p = pp;\n\n    // Nose hole\n    float nosb = fPillHalf((p - vec3(.0,.362,-.54)).xzy) - .005;\n    nosb = max(nosb, p.z+.4);\n    d = smin(d, nosb, .05);\n    d = smax(d, -nos+.005, .02);\n\n    p = pp;\n    d = smax(d, fMaxillaBottom(p), .02);\n    float roof = sdEllipsoidXXZ(p - vec3(0,.47,-.28), vec2(.13, .22));\n    d = smax(d, -roof, .03);\n\n    float temporal = sdEllipsoidXXZ(pRy(pRz(p - vec3(.25,.1,-.03), .2), -.4).yzx, vec2(.18, .08));\n    temporal = smax(temporal, dot(p.zy, normalize(vec2(-.3,1))) - .2, .1);\n    d = smin(d, temporal, .15);\n\n    float archhole = fArchhole(p);\n    d = smax(d, -archhole, .03);\n\n    return d;\n}\n\n\nfloat map(vec3 p) {\n    p -= OFFSET;\n    p /= SCALE;\n   \treturn sdSkull(p);\n\treturn length(p) - .45;\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    \n    int id = faceIdFromDir(rayDir);\n    \n    vec2 coord = fragCoord.xy;\n    vec2 size = iResolution.xy;\n    vec2 uv = coord / size;\n    \n    vec4 lastFrame = texture(iChannel0, rayDir);\n    if (lastFrame.x != 0. && iFrame > 2) {\n        fragColor = lastFrame;\n    \treturn;\n    }\n    \n    mat4 space = texToSpace(coord, id, size);\n    vec4 result = vec4(0);\n    \n    for (int i = 0; i < 4; i++) {\n    \tresult.x = map(space[i].xyz);\n        result = result.yzwx;\n    }\n    \n    fragColor = result;\n}\n", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define ZERO (min(iFrame,0))\n#define PI 3.1415926\n#define HALF_PI 1.5707963267948966\n\nmat3 basisMatrix(vec3 forward, vec3 up) {\n    vec3 ww = normalize(forward);\n    vec3 uu = normalize(cross(up,ww));\n    vec3 vv = normalize(cross(ww,uu));\n    return mat3(uu, vv, ww);\n}\n\nmat3 orientMatrix(vec3 up, vec3 forward) {\n    mat3 m = basisMatrix(up, forward);\n    return mat3(m[0], m[2], -m[1]);\n}\n\n\n\n//========================================================\n// Fractal camera loop\n// https://www.shadertoy.com/view/wslyzH\n//========================================================\n\nvec3 stepPosition;\nfloat stepScale;\nmat3 stepRotate;\n\n\n// Quaternions\n// https://github.com/mattatz/ShibuyaCrowd/blob/master/source/shaders/common/quaternion.glsl\nvec4 qmul(vec4 q1, vec4 q2) {\n    return vec4(\n        q2.xyz * q1.w + q1.xyz * q2.w + cross(q1.xyz, q2.xyz),\n        q1.w * q2.w - dot(q1.xyz, q2.xyz)\n    );\n}\nvec3 rotate_vector(vec3 v, vec4 r) {\n    vec4 r_c = r * vec4(-1, -1, -1, 1);\n    return qmul(r, qmul(vec4(v, 0), r_c)).xyz;\n}\nvec4 rotate_angle_axis(float angle, vec3 axis) {\n    float sn = sin(angle * 0.5);\n    float cs = cos(angle * 0.5);\n    return vec4(axis * sn, cs);\n}\n\nvec3 calcCylinderNormal(vec3 a, vec3 b, vec3 c) {\n    vec3 tangent = a - c;\n    vec3 binormal = cross(a - b, c - b);\n    vec3 normal = normalize(cross(tangent, binormal));\n    return normal;\n}\n\nvec3 calcAxis() {\n    vec3 v0 = vec3(0);\n    vec3 v1 = stepPosition;\n    vec3 v2 = v1 + stepRotate * stepPosition;\n    vec3 v3 = v2 + stepRotate * stepRotate * stepPosition;\n    vec3 n0 = calcCylinderNormal(v0, v1, v2);\n    vec3 n1 = calcCylinderNormal(v1, v2, v3);\n\tvec3 axis = normalize(cross(n0, n1));\n    return axis;\n}\n\nmat3 calcAxisMatrix(vec3 axis) {\n    return basisMatrix(axis, vec3(0,1,0));\n}\n\nfloat findAngle(vec2 a, vec2 b, vec2 c) {\n    return acos(dot(normalize(b - a), normalize(c - a)));\n}\n\nfloat calcSpokeAngle(vec2 a, vec2 b, vec2 c) {\n    float angle = findAngle(b, a, c);\n    angle = PI - angle;\n    float side = sign((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x));\n    return angle * -side;\n}\n\nfloat calcSpokeAngle(mat3 mAxis) {\n    vec3 v0 = vec3(0);\n    vec3 v1 = stepPosition;\n    vec3 v2 = v1 + stepRotate * stepPosition;\n    vec2 point0 = (v0 * mAxis).xy;\n    vec2 point1 = (v1 * mAxis).xy;\n    vec2 point2 = (v2 * mAxis).xy;\n    float spokeAngle = calcSpokeAngle(point0, point1, point2);\n    return spokeAngle;\n}\n\nvec2 rotate(vec2 p, float a) {\n    return cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\n\nvec2 calcCenter(vec2 point0, vec2 point1, float scale, float spokeAngle) {\n    float s = scale;\n    float side0 = distance(point0, point1);\n    float angle0 = spokeAngle;\n    float side1 = side0 / sqrt((s * s) - 2. * s * cos(angle0) + 1.);\n    float side2 = s * side1;\n    float angle2 = asin((side2 * sin(angle0)) / side0);\n    vec2 center = vec2(sin(angle2), cos(angle2)) * side1;\n    vec2 v = point1 - point0;\n    center = rotate(center, atan(v.x, v.y));\n    center += point0;    \n    return center;\n}\n\nvec3 calcApex(vec3 axis, mat3 mAxis, float spokeAngle) {\n    vec3 v0 = vec3(0);\n    vec3 v1 = stepPosition;\n    vec2 point0 = (v0 * mAxis).xy;\n    vec2 point1 = (v1 * mAxis).xy;\n    vec2 center2 = calcCenter(point0, point1, stepScale, spokeAngle);\n    vec3 center = vec3(center2, 0) * inverse(mAxis);\n    float v1Height = dot(v1, axis);\n    float v1Radius = distance(center, v1 - axis * v1Height);\n    vec3 apex = center + axis * v1Height * (length(center) / (length(center) - v1Radius));\n    return apex;\n}\n\nvec3 cameraAxis;\nfloat cameraAngle;\nvec3 cameraApex;\n\nvoid cameraPrecalc() {\n    cameraAxis = calcAxis();\n    mat3 mAxis = calcAxisMatrix(cameraAxis);\n    cameraAngle = calcSpokeAngle(mAxis);\n    cameraApex = calcApex(cameraAxis, mAxis, cameraAngle);\n}\n\nfloat tweenCamera(inout vec3 p, float t) {\n    float scale = 1. / pow(stepScale, t);\n    float angle = abs(cameraAngle) * t;\n    vec4 rot = rotate_angle_axis(angle, cameraAxis);\n    p -= cameraApex;\n    p = rotate_vector(p, rot);\n    p /= scale;    \n    p += cameraApex;\n    return scale;\n}\n\n\n//========================================================\n// Modelling\n//========================================================\n\n// Utils\n// HG_SDF, stack.gl\n//--------------------------------------------------------\n\nfloat easeOutSine(float t) {\n  return sin(t * HALF_PI);\n}\n\nfloat easeOutCirc(float t) {\n  return sqrt((2.0 - t) * t);\n}\n\nconst float PHI = 1.61803398875;\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec2 pR2d(vec2 p, float a) {\n    return cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat cmax(float a, float b, float r) {\n    return max(max(a, b), (a + r + b)*sqrt(0.5));\n}\n\nfloat rangec(float a, float b, float t) {\n    return clamp(range(a, b, t), 0., 1.);\n}\n\nmat3 rotX(float a) {\n\treturn mat3(\n    \t1, 0, 0,\n        0, cos(a), -sin(a),\n        0, sin(a), cos(a)\n    );\n}\n\nmat3 rotY(float a) {\n\treturn mat3(\n    \tcos(a), 0, sin(a),\n        0, 1, 0,\n        -sin(a), 0, cos(a)\n    );\n}\n\nmat3 rotZ(float a) {\n\treturn mat3(\n    \tcos(a), -sin(a), 0,\n        sin(a), cos(a), 0,\n        0, 0, 1\n    );\n}\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n\n// Types\n//--------------------------------------------------------\n\nstruct Model {\n    float d;\n    vec3 p;\n    bool isBound;\n    int id;\n    bool isBloom;\n    vec2 uv;\n    vec2 cell;\n    float wedges;\n    float slice;\n    float len;\n    float neg; // subtract from distance\n    float crackdepth;\n};\n\nModel newModel() {\n    return Model(1e12, vec3(0), false, 0, false, vec2(0), vec2(0), 0., 0., 0., 1e12, 0.);\n}\n\nModel opU(Model a, Model b) {\n    Model m = a;\n    if (b.d < a.d) {\n        m = b;\n    }\n    m.neg = min(a.neg, b.neg);\n    return m;\n}\n\n\n// Config\n//--------------------------------------------------------\n\nfloat skullOffset;\nfloat skullRadius;\nmat3 skullRotate;\nvec3 bloomPosition;\nmat3 bloomRotate;\nfloat delay;\n\nfloat time;\nbool lightingPass;\n\nfloat boundEps;\nfloat globalScale;\n\nconst float CUTOFF = 3.6; // remove old itrerations when they're out of view\n\nstruct BloomSpec {\n    vec2 density;\n    float thickness;\n    float width;\n    float pointy;\n    float size;\n    bool hideInside;\n};\n\nstruct BloomInstance {\n\tvec3 pos;\n    mat3 rot;\n    float offset;\n    float start;\n    float stop;\n    BloomSpec spec;\n};\n\nBloomInstance[4] bloomInstances;\n\nvoid precalcBloomInstances() {\n\n    bloomInstances[0] = BloomInstance(\n        vec3(-.2,.2,.25), //pos\n        orientMatrix(vec3(-1,.7,.9), vec3(0,1,0)), //rot\n        .02, //offset\n        -.8, //start\n        1., //stop\n        BloomSpec(\n            vec2(.08, 1.), //density\n            .11, //thickness\n            .39, //width\n            .4, //pointy\n            .11, //size\n            false //hideInside\n        )\n    );\n    \n\tbloomInstances[1] = BloomInstance(\n        vec3(-.135,.105,.35) * .98, //pos\n        orientMatrix(vec3(-.7,.2,.9), vec3(0,1,0)), //rot\n        .0, //offset\n        -1.1, //start\n        .8, //stop\n        BloomSpec(\n            vec2(.48, 1.8), //density\n            .08, //thickness\n            .45, //width\n            .0, //pointy\n            .07, //size\n            false //hideInside\n        )\n    );\n    \n\tbloomInstances[2] = BloomInstance(\n        vec3(.22,.23,.2), //pos\n        orientMatrix(vec3(.5,.3,.2), vec3(1,1,0)) * rotY(.3), //rot\n        .05, //offset\n        -.1, //start\n        1.5, //stop\n        BloomSpec(\n            vec2(.12, 1.45), //density\n            .07, //thickness\n            .17, //width\n            .0, //pointy\n            .14, //size\n            false //hideInside\n        )\n    );\n    \n\tbloomInstances[3] = BloomInstance(\n        vec3(.28,.07,.18) * .85, //pos\n        orientMatrix(vec3(1,-.3,.5), vec3(1,1,0)), //rot\n        .1176, //offset\n        -.5, //start\n        1.5, //stop\n        BloomSpec(\n            vec2(.15, 1.45), //density\n            .15, //thickness\n            .41, //width\n            .0, //pointy\n            .085, //size\n            false //hideInside\n        )\n    );   \n}\n\n\nstruct CrackInstance {\n    vec3 pos;\n    mat3 rot;\n    float start;\n    float stop;\n    vec2 weight;\n\n\tfloat angle;\n    vec2 offset;\n    vec2 size;\n    float lines;\n    float seed;\n};\n\nCrackInstance[7] crackInstances;\n\nvoid precalcCrackInstances() {\n\n    crackInstances[0] = CrackInstance(\n    \tvec3(.28,.1,.15), //pos\n    \torientMatrix(vec3(1,-.1,.2), vec3(1,1,0)) * rotY(2.2) * rotZ(.9), //rot\n    \t-.3, //start\n    \t.7, //stop\n    \tvec2(.001, .03), //weight\n\t\t0., //angle\n    \tvec2(.015,-.02), //offset\n    \tvec2(.15,.03), //size\n    \t18., //lines\n    \t11. //seed\n    );\n\n    crackInstances[1] = CrackInstance(\n    \tvec3(.28,.18,.18)*.98, //pos\n    \torientMatrix(vec3(1,.4,.4), vec3(1,1,0)), //rot\n    \t-.7, //start\n    \t.3, //stop\n    \tvec2(.001, .03), //weight\n\t\t1., //angle\n    \tvec2(0), //offset\n    \tvec2(.12,.03), //size\n    \t13., //lines\n    \t14. //seed\n    );\n    \n    crackInstances[2] = CrackInstance(\n    \tvec3(.28,.18,.18)*.98, //pos\n    \torientMatrix(vec3(1,.4,.4), vec3(1,1,0)), //rot\n    \t-.7, //start\n    \t.3, //stop\n    \tvec2(.001, .03), //weight\n\t\t3.6, //angle\n    \tvec2(0), //offset\n    \tvec2(.12,.03), //size\n    \t16., //lines\n    \t16. //seed\n    );\n    \n    crackInstances[3] = CrackInstance(\n        bloomInstances[0].pos - bloomInstances[0].rot * vec3(0,0,.02), //pos\n        bloomInstances[0].rot, //rot\n    \t-1., //start\n    \t.0, //stop\n    \tvec2(.001, .03)*1.2, //weight\n\t\t1., //angle\n    \tvec2(.015,-.02)*1.2, //offset\n    \tvec2(.12,.05)*1.2, //size\n    \t10., //lines\n    \t1. //seed\n    );\n    \n    crackInstances[4] = CrackInstance(\n        bloomInstances[0].pos - bloomInstances[0].rot * vec3(0,0,.02), //pos\n        bloomInstances[0].rot, //rot\n    \t-1., //start\n    \t.0, //stop\n    \tvec2(.001, .03)*1.2, //weight\n\t\t3., //angle\n    \tvec2(0), //offset\n    \tvec2(.12,.05)*1.2, //size\n    \t10., //lines\n    \t4. //seed\n    );\n    \n    crackInstances[5] = CrackInstance(\n        bloomInstances[0].pos - bloomInstances[0].rot * vec3(0,0,.02), //pos\n        bloomInstances[0].rot, //rot\n    \t-1., //start\n    \t.0, //stop\n    \tvec2(.001, .03)*1.2, //weight\n\t\t5.5, //angle\n    \tvec2(-.01,.02)*1.2, //offset\n    \tvec2(.08,.02)*1.2, //size\n    \t12., //lines\n    \t3. //seed\n    );\n    \n\n    crackInstances[6] = CrackInstance(\n        vec3(.3,.29,-.03), //pos\n        orientMatrix(vec3(.5,.3,.05), vec3(1,0,1)), //rot\n    \t-.7, //start\n    \t.6, //stop\n    \tvec2(.001, .1), //weight\n\t\t3.2, //angle\n    \tvec2(0), //offset\n    \tvec2(.18,.06), //size\n    \t15., //lines\n    \t17. //seed\n    );\n}\n\n\n// Bloom model\n// https://www.shadertoy.com/view/WtGXWm\n//--------------------------------------------------------\n\nModel leaf(vec3 p, vec3 cellData, float thickness, float pointy, float width, bool shrinkOuter) {\n    \n    vec2 cell = cellData.xy;\n    float cellTime = cellData.z;\n    \n    float d = 1e12;\n    float d2 = 1e12;\n    float slice = 1e12;\n    float wedge, wedges;\n\n    // orient\n    pR(p.xz, -cell.x);\n    pR(p.zy, cell.y);\n\n    vec3 pp = p;\n\n    cellTime = max(cellTime, 0.);\n\n    float core = length(p) - .1;\n\n    float len = max(cellTime*3. - .2, 0.);\n\n    if (shrinkOuter) {\n        len *= mix(.2, 1., rangec(-.5, .0, cell.y));\n    }\n\n    len = pow(len, .33);\n\n    float llen = len;\n\n    Model model = newModel();\n\n    if (cellTime > 0.) {\n\n        // wedge\n        float ins = .25;\n        p.z += ins;\n        vec3 n = normalize(vec3(1,0,.35));\n        wedge = -dot(p, n);\n        wedge = max(wedge, dot(p, n * vec3(1,1,-1)));\n        wedge = smax(wedge, p.z - len*1.12 - ins, len);\n        p.z -= ins;\n\n        // wedge2\n        ins = .2;\n        p.z += ins;\n        n = normalize(vec3(1,0,width));\n        float wedge2 = -dot(p, n);\n        wedge2 = smax(wedge2, dot(p, n * vec3(1,1,-1)), .1);\n        wedge2 = smax(wedge2, p.z - len*.95 - ins, len*.6);\n        p.z -= ins;\n\n        float r = len / 8.;\n\n        float top = p.y - len * .5;\n        float curve = smoothstep(0., .2, cellTime);\n\n        len *= mix(1.5, .65, curve);\n        pR(p.zy, -mix(.2, .7, curve));\n        slice = length(p - vec3(0,len,0)) - len;\n        d2 = abs(slice) - thickness;\n        d2 = max(d2, top);\n        \n        float wedgeT = smax(d2, wedge, thickness);\n        float wedgeT2 = smax(d2, wedge2, thickness);\n        d = mix(wedgeT2, smin(wedgeT, wedgeT2, .01), pointy);\n        wedges = mix(wedge2, wedge2, pointy);\n        \n        p = pp;\n        len = llen;\n        vec2 uv = p.xz / len;\n\n        model.p = p;\n        model.d = d;\n        model.isBloom = true;\n        model.uv = uv;\n        model.cell = cell;\n        model.wedges = mix(wedge2, smin(wedge, wedge2, .01), pointy);\n        model.slice = slice;\n        model.len = len;\n        model.neg = smax(max(slice, top), wedges, .01);\n        return model;\n    }\n\n    model.d = d;\n    model.p = p;\n    return model;\n}\n\nvec3 calcCellData(\n    vec2 cell,\n    vec2 offset,\n    float maxBloomOffset,\n    mat2 transform,\n    mat2 transformI,\n    float stretch,\n    float stretchStart,\n    float stretchEnd,\n    float t,\n    bool hideInside\n) {\n\n    float sz = maxBloomOffset + PI / 2.;\n\n    cell = transform * cell;\n\n    // Snap to cell center\n    cell = round(cell);\n    cell += offset;\n\n    // Hide leaves outside the growth area\n    cell = transformI * cell;\n    cell.y *= stretch / sz / stretchStart;\n    cell.y = max(cell.y, 4.4/stretchEnd); // clamp, not sure why this magic number\n    if (hideInside) {\n        cell.y = min(cell.y, 1.21/stretchStart); // clamp, not sure why this magic number\n    }\n    cell.y /= stretch / sz / stretchStart;\n    cell = transform * cell;\n\n    // Snap after clamp\n    cell = round(cell);\n\n    cell = transformI * cell;\n\n    // calculate cell time\n    float y = cell.y * (stretch / sz);\n    float cellAppearTime = (stretchStart - y) / (stretchStart - stretchEnd);\n    float cellTime = t - cellAppearTime;\n\n    cell.y -= maxBloomOffset;\n\n    return vec3(cell, cellTime);\n}\n\nmat2 phyllotaxis;\nvoid calcPhyllotaxis() {\n    vec2 cc = vec2(5., 8.);\n    float aa = atan(cc.x / cc.y);\n    float scale = (PI*2.) / sqrt(cc.x*cc.x + cc.y*cc.y);\n    mat2 mRot = mat2(cos(aa), -sin(aa), sin(aa), cos(aa));\n    mat2 mScale = mat2(1./scale,0,0,1./scale);\n    phyllotaxis = mRot * mScale;\n}\n\nModel drawBloom(\n    vec3 p,\n    float t,\n    vec2 density,\n    float thickness,\n    float pointy,\n    float width,\n    bool hideInside\n) {\n    pR(p.xz, .7);\n\n    Model model = newModel();\n\n    t = rangec(-.1, 1., t);\n\n    p.y -= mix(0., .25, t);\n\n    vec2 move = vec2(0, t);\n    float stretchStart = density.x;\n    float stretchEnd = density.y;\n    float stretch = mix(stretchStart, stretchEnd, t);\n    float maxBloomOffset = PI / 5.;\n\n    vec2 cell = vec2(\n        atan(p.x, p.z),\n        atan(p.y, length(p.xz)) + maxBloomOffset\n    );\n\n    mat2 mStretch = mat2(1,0,0,stretch);\n    mat2 transform = phyllotaxis * mStretch;\n    mat2 transformI = inverse(transform);\n    bool shrinkOuter = hideInside;\n\n    // compile speed optim from IQ\n    for( int m=ZERO; m<3; m++ )\n    for( int n=ZERO; n<3; n++ )\n    {\n        model = opU(model, leaf(\n            p,\n            calcCellData(cell, vec2(m,n)-1., maxBloomOffset, transform, transformI, stretch, stretchStart, stretchEnd, t, hideInside),\n            thickness,\n            pointy,\n            width,\n            shrinkOuter\n        ));\n    }\n\n    return model;\n}\n\nModel drawBloom(vec3 p, float t, BloomSpec spec) {\n    p /= spec.size;\n    globalScale *= spec.size;\n    Model model;\n    float bound = length(p) - mix(.7, mix(.8, 2.4, spec.width), t);\n    if ( ! lightingPass && bound > boundEps / globalScale) {\n\t\tmodel = newModel();\n        model.d = bound;\n        model.neg = bound;\n        model.isBound = true;\n    } else {\n        model = drawBloom(\n            p,\n            t,\n            spec.density,\n            spec.thickness,\n            spec.pointy,\n            spec.width,\n            spec.hideInside\n        );\n    }\n    model.d *= spec.size;\n    model.neg *= spec.size;\n    globalScale /= spec.size;\n\treturn model;\n}\n\n\n// Crack model\n//--------------------------------------------------------\n\nvec2 hash2(vec2 p) {\n    return textureLod( iChannel1, -(p+0.5)/256.0, 0.).xy;\n}\n\nfloat fLine(vec2 p, vec2 a, vec2 b) {\n\treturn dot(p - a, normalize(b - a) * mat2(0,-1,1,0));\n}\n\nvec2 getPoint(float x, int offset, float seed, vec2 size, vec2 scale) {\n   \tfloat cell = (floor(x / scale.x) + float(offset));\n    float inv = mod(cell, 2.) * 2. - 1.;\n   \tvec2 pos = hash2(vec2(cell, seed));\n    pos.y *= inv;\n    pos.y *= scale.y;\n    float ramp = cell / size.x * scale.x / 2.;\n    pos.y *= 1. - ramp;\n   \tpos += vec2(cell, 0.);\n    pos.x *= scale.x;\n    return pos;\n}\n\nfloat fCrack(vec2 p, vec2 size, float lines, float seed, float weight) {\n    float bound = max(-p.x - weight/2., p.x - size.x * 2.);\n    vec2 scale = vec2(size.x / lines * 4., size.y);\n    \n    if (bound > .01) {\n    \treturn bound;\n    }\n\n    vec2 p0 = getPoint(p.x, -2, seed, size, scale);\n    vec2 p1 = getPoint(p.x, -1, seed, size, scale);\n    vec2 p2 = getPoint(p.x, 0, seed, size, scale);\n    vec2 p3 = getPoint(p.x, 1, seed, size, scale);\n    vec2 p4 = getPoint(p.x, 2, seed, size, scale);\n    \n    float inv = mod(floor(p.x / scale.x), 2.) * 2. - 1.;\n    \n    float d = max(\n        min(\n        \tfLine(p, p0, p1) * inv,\n        \tfLine(p, p1, p2) * inv\n        ),\n        min(\n        \tfLine(p, p2, p3) * inv,\n        \tfLine(p, p3, p4) * inv\n        )\n    ) * inv;\n\n    // use less samples, introduces errors\n    //float d = max(fLine(p, p1, p2) * inv,fLine(p, p2, p3) * inv) * inv;\n\n    float w = weight;\n    \n    float weightRamp = (1. - p.x / size.x / 2.);\n    weight *= weightRamp;\n    d = (abs(d) - weight);\n    d = max(d, bound);\n        \n    return d;\n}\n\n\n// Skull model\n//--------------------------------------------------------\n\nModel sdSkull(vec3 p) {\n    Model model = newModel();\n    float rad = .3;\n    float bound = fBox(p - vec3(0,-.13,-.02), vec3(.45,.43,.54) - rad) - rad;\n    bound = smin(bound, fBox(p - vec3(0,.29,-.4), vec3(.25,.2,.18)), .2);\n    if ( ! lightingPass && bound > boundEps / globalScale) {\n        model.d = bound;\n        model.isBound = true;\n        return model;\n    }\n\n    p.x = -abs(p.x);\n    p += OFFSET / SCALE;\n    p *= SCALE;\n    model.d = mapTex(iChannel0, p, iChannelResolution[0].xy);\n\n    if (lightingPass && bound > .01) {\n        model.d += bound;\n        model.isBound = true;\n        return model;\n    }\n\n    return model;\n}\n\nModel drawSkull(vec3 p, float t) {\n    float scale = 2.5 * skullRadius;\n    p /= scale;\n    globalScale *= scale;\n    Model model = sdSkull((p.xyz * vec3(1,-1,-1)));\n    model.d *= scale;\n    globalScale /= scale;\n    return model;\n}\n\n\n// Composition\n//--------------------------------------------------------\n\nModel drawFinalBloom(vec3 p, float t) {\n    float bt = smoothstep(0., 2., t);\n    bt = easeOutCirc(bt);\n    pR(p.xz, .7 * PI * 2.);\n    Model bloom = drawBloom(\n        p,\n        bt,\n        BloomSpec(\n        \tvec2(.15, 2), //density\n            .05, //thickness\n            .4, //width\n            1., //pointy\n            1.4, //size\n            true //hideInside\n        )\n   \t);\n    bloom.id = 5;\n    return bloom;\n}\n\nfloat fTri(vec2 p, float radius) {\n    radius /= 2.;\n    vec2 a = normalize(vec2(1.6,1.));\n    return max(\n        dot(p, vec2(0,-1)) - radius,\n        max(\n        \tdot(p, a) - radius,\n        \tdot(p, a * vec2(-1,1)) - radius\n        )\n    );\n}\n\nModel skullWithBlooms(vec3 p, float t) {\n    \n    if (t <= .0 || globalScale <= 0.) {\n        return newModel();\n    }\n    \n    Model model = newModel();    \n    Model bloom;\n\n    if (t < CUTOFF) {\n        // skull with sub blooms\n        Model skull = drawSkull(p, t);\n        float skulld = skull.d;\n        skull.crackdepth = max(-skull.d, 0.);\n        float td = t - delay;\n        model = skull;\n        //return skull;\n        \n        vec3 pp = p;\n        \n        // cracks\n        if (skull.d < boundEps / globalScale) {\n\t        CrackInstance ci;\n\t        float cracks = 1e12;\n            float crack;\n            for (int i = ZERO; i < 7; i++) {\n                ci = crackInstances[i];\n                p -= ci.pos;\n                p *= ci.rot;\n                if (i == 6) {\n                \tcrack = min(crack, max(fTri(p.xz, .45), fTri(p.xz * vec2(1,-1), .3)));\n                } else {\n                    crack = 1e12;\n                }\n                pR(p.xz, ci.angle);\n                float blend = smoothstep(ci.start, ci.stop, td);\n                float weight = mix(ci.weight.x, ci.weight.y, blend);\n                float crack = min(crack, fCrack(p.xz - ci.offset, ci.size, ci.lines, ci.seed, weight));\n                crack += (1.-blend) * weight/2.;\n                crack -= min(skull.d * mix(1.5, .2, blend), 0.);\n                crack = max(crack, -(p.y + .25)); // stop it poking through the other side\n                cracks = min(crack, cracks);\n                p = pp;\n            }\n            cracks = max(cracks, -(skulld + .06)); // limit depth\n            skull.d = cmax(skull.d, -cracks, .003);\n      \t}\n        \n        // blooms\n\t    Model blooms = newModel();\n        BloomInstance bi;\n        for (int i = ZERO; i < 4; i++) {\n            bi = bloomInstances[i];\n            float bt = smoothstep(bi.start, bi.stop, td);\n            p -= bi.pos * (1. + bi.offset * bt);\n            p *= bi.rot;\n            bloom = drawBloom(p, bt, bi.spec);\n            bloom.id = i + 1;\n            skull.d = max(skull.d, -bloom.neg);\n            blooms = opU(blooms, bloom);\n            p = pp;\n        }\n\n        model = opU(skull, blooms);\n    }\n\n    return model;\n}\n\nvoid tweenSkull(inout vec3 p, float t) {\n    float skullHeight = mix(.2, skullOffset, easeOutSine(rangec(.55, 1.5, t)));\n    float skullScale = mix(.0, 1., easeOutSine(rangec(.45, 1., t)));\n    p.y -= skullHeight;\n    p *= skullRotate;\n\n    float rt = 1. - easeOutCirc(rangec(.0, 3., t));\n    pR(p.yz, rt * 5.);\n\n    p /= skullScale;\n    globalScale *= skullScale;\n}\n\nvoid stepTransform(inout vec3 p, inout float t) {\n    p -= bloomPosition;\n    p /= stepScale;\n    globalScale *= stepScale;\n    p *= bloomRotate;\n    t -= delay;\n}\n\nModel map(vec3 p) {\n\n    globalScale = 1.;\n    float t = time;\n\n    float off = .73;\n    \n    t += 1.;\n    float camScale = tweenCamera(p, t - (1.-off)/delay);\n    globalScale *= camScale;\n\n    Model model = newModel();\n    Model model2;\n\n    t *= delay;\n    t += off;\n\n    if (t < 2.6) {\n    \tmodel = drawFinalBloom(p, t);\n      \tmodel.d *= globalScale;\n    }\n\n    for (float i = 0.; i < 3.; i++) {\n\n        // scale\n        tweenSkull(p, t);\n\n        if (globalScale <= 0.) {\n\t\t\tbreak;\n        }\n\n        // skull\n        model2 = skullWithBlooms(p, t);\n        model2.d *= globalScale;\n        model = opU(model, model2);\n\n        // translate\n        stepTransform(p, t);\n        \n        // bloom\n        model2 = drawFinalBloom(p, t);\n        model2.d *= globalScale;\n        model2.neg *= globalScale;\n        if ( ! model2.isBound) {\n            model.d = smax(model.d, -model2.neg, .04 * globalScale);\n        }\n        model = opU(model, model2);\n    }\n\n    return model;\n}\n\n\n//========================================================\n// Rendering\n//========================================================\n\nmat4 cameraMatrix = mat4(\n    -.6729,.6207,.4012,0,\n    .7041,.3737,.6036,0,\n    .2249,.689,-.6883,0,\n    -.02,-.3813,-5.423,1\n);\n\nmat4 view = mat4(\n    -0.6729, 0.6207, 0.4012, 0,\n    0.7041, 0.3737, 0.6036, 0,\n    0.2249, 0.689, -0.6883, 0,\n    -0.02, -0.3813, -5.423, 1\n);\n\n// Shading\n//--------------------------------------------------------\n\n// compile speed optim from IQ https://www.shadertoy.com/view/Xds3zN\nvec3 calcNormal(vec3 pos){\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).d;\n    }\n    return normalize(n);\n}\n\n// https://www.shadertoy.com/view/lsKcDD\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    #ifdef DISABLE_SHADOWS\n        return 1.;\n    #endif\n    float res = 1.0;\n    float t = mint;\n    float ph = 1e10;\n    \n    for( int i=ZERO; i<256; i++ )\n    {\n        float h = map( ro + rd*t ).d;\n        res = min( res, 10.0*h/t );\n        t += h;\n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://www.shadertoy.com/view/Xds3zN\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    #ifdef DISABLE_SHADOWS\n        return 1.;\n    #endif\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).d;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 worldToCam(vec3 v) {\n    return (vec4(v, 1) * cameraMatrix).xyz;\n}\n\nvec3 doShading(vec3 pos, vec3 rd, Model model) {\n    vec3 col = vec3(.3);\n    float cracksha = rangec(.001, .0, model.crackdepth);\n\tfloat crackocc = rangec(.05, .0, model.crackdepth);\n\n    if (model.isBloom) {\n\t\tcrackocc = 1.;\n        cracksha = 1.;\n        col = vec3(.04,.09,.09);\n        col = mix(vec3(.07,.025,.06), col, smoothstep(-.2, .0, model.wedges) * model.uv.y);\n        if (model.id == 1) {\n            col = vec3(.1,.06,.1);\n            col = mix(col, vec3(.095,.02,.055), smoothstep(-.1, .0, model.wedges) * smoothstep(.5, 1., model.uv.y));\n        }\n        if (model.id == 2) {\n            col = vec3(.04,.07,.09);\n            col = mix(col, vec3(.005,.015,.02), smoothstep(.5, 1.3, model.cell.y));\n        }\n        if (model.id == 3) {\n            col = vec3(.04,.07,.09);\n            col = mix(col, vec3(.2), smoothstep(.4, 1., model.uv.y));\n        }\n        if (model.id == 4) {\n            col = vec3(.11,.05,.1);\n            col = mix(col, vec3(.5), smoothstep(.5, 2., model.cell.y));\n        }\n    }\n\n    vec3 nor = calcNormal(pos);\n    lightingPass = true;\n\n    // IQ's shading, I always find this so nice to work with\n    // https://www.shadertoy.com/view/Xds3zN\n    float occ = calcAO( pos, nor );\n    vec3  lig = normalize( worldToCam(vec3(.5, 1, .2)) );\n    vec3  lba = normalize( worldToCam(vec3(-.5, -.8, .1)) );\n    vec3  hal = normalize( lig - rd );\n    float amb = sqrt(clamp( 0.5+0.5*worldToCam(nor).y, 0.0, 1.0 ));\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, lba ), 0.0, 1.0 )*clamp( 1.0-worldToCam(nor).y,0.0,1.0);\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n    occ = mix(1., occ, .8) * mix(1., crackocc, .9);\n\n    float sha = softshadow( pos, lig, 0.001, .9 ) * cracksha;\n    dif *= sha;\n\n    float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n        dif *\n        (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n    vec3 lin = vec3(0.0);\n    lin += 3.80*dif*vec3(1.30,1.00,0.70);\n    lin += 0.55*amb*vec3(0.40,0.60,1.15)*occ;\n    lin += 0.55*bac*vec3(0.4,0.25,0.3)*occ;\n    lin += 0.15*fre*vec3(1.00,1.00,1.00)*occ;\n    col = col*lin;\n    col += 7.00*spe*vec3(1.10,0.90,0.70);\n\n    return col;\n}\n\n\n// Debug\n//--------------------------------------------------------\n\n// https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n// Main\n//--------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // Config\n\n    skullOffset = 1.8;\n    skullRadius = .3;\n    skullRotate = basisMatrix(vec3(.9,1,.9), vec3(1,0,1));\n\n    bloomPosition = vec3(.8,.8,-.1) * skullRadius * 1.1;\n    bloomRotate = basisMatrix(vec3(-.3,1,0), vec3(1,0,0));\n\n    stepPosition = vec3(0,skullOffset,0) + skullRotate * bloomPosition;\n    stepScale = .15;\n    stepRotate = skullRotate * bloomRotate;\n\n    delay = 1.5;\n\n    cameraPrecalc();\n    calcPhyllotaxis();\n    precalcBloomInstances();\n    precalcCrackInstances();\n\n    time = loopTime(iTime);\n\n    vec3 col;\n    float depth;\n    \n    // Camera\n\n    vec2 p = (-iResolution.xy + 2. * fragCoord) / iResolution.y;\n   \tvec3 eye = -(view[3].xyz) * mat3(view);\n    float fov = 1. / 3.0777;\n    vec3 dir = normalize(vec3(p.x * fov, p.y * fov, -1) * mat3(view));\n\n    // Raymarch (enhanced sphere tracing)\n    // https://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf\n\n    vec3 camPos = eye;\n    vec3 rayPosition = camPos;\n    vec3 rayDirection = normalize(dir);\n    float rayLength = 0.;\n    float stepLength = 0.;\n\n    bool bg = false;\n    lightingPass = false;\n\n    Model model;\n    Model candidateModel;\n    float error;\n    float candidateError = 1e12;\n    float canidateRayLength;\n    \n    const float MAX_DIST = 16.;\n    const int MAX_STEPS = 100;\n    float debugSteps = 0.;\n    \n    float pixelRadius = fwidth((camPos + rayDirection).x);\n\tfloat overstep = 1.1;\n    float radius;\n    float signedRadius;\n    float previousRadius;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        debugSteps = float(i);\n        \n        rayPosition = camPos + rayDirection * rayLength;\n        boundEps = pixelRadius * rayLength * 2.;\n        model = map(rayPosition);\n        \n        signedRadius = model.d;\n        radius = abs(signedRadius);\n\n        bool overshot = overstep > 1. && ! model.isBound && (radius + previousRadius) < stepLength;\n        if (overshot) {\n            stepLength -= overstep * stepLength;\n            overstep = 1.;\n        } else {\n            stepLength = signedRadius * overstep;\n        }\n\n        previousRadius = radius;\n\n        float error = radius / rayLength;\n        if ( ! model.isBound && ! overshot && error < candidateError) {\n            candidateModel = model;\n            candidateError = error;\n            canidateRayLength = rayLength;\n        }\n\n        if ( ! model.isBound && ! overshot && error < pixelRadius) {\n            break;\n        }\n        \n    \tif (rayLength > MAX_DIST) {\n            bg = true;\n            canidateRayLength = rayLength;\n            break;\n        }\n\n        rayLength += stepLength;\n    }\n    \n    model = candidateModel;\n    rayLength = canidateRayLength;\n\n    vec3 bgCol = vec3(.007,0,.007);\n    col = bgCol;\n\n    if ( ! bg) {\n        col = doShading(rayPosition, rayDirection, model);\n        float fog = 1. - exp((rayLength - 3.) * -.5);\n        col = mix(col, bgCol, clamp(fog, 0., 1.)); \n    }\n    \n    depth = rayLength / MAX_DIST;\n    depth = smin(depth, .8, .1); // stop the DOF 'pop' when background objects are removed\n\n    //col = spectrum(debugSteps / float(MAX_STEPS));\n\t//col = spectrum(depth);\n\n    fragColor = vec4(col, depth);\n}\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdScDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1786, 1786, 1854, 1854, 1972], [1986, 1986, 2056, 2056, 3237], [3239, 3239, 3258, 3258, 3449], [3452, 3452, 3507, 3507, 4276]], "test": "untested"}
{"id": "wsSyzt", "name": "Scuffed Copper cube", "author": "manon_graphics_witch", "description": "I think all the formulas are incorrect, but the result looks okayish =]\nThe IBL is based on Epic Games' Siggraph 2013 paper https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf", "tags": ["metal"], "likes": 1, "viewed": 342, "published": 3, "date": "1587207337", "time_retrieved": "2024-07-30T21:12:01.980394", "image_code": "#define VERY_SMOL 0.001\n#define PI 3.14159264\n#define TAU (PI*2.)\n#define MAX_DIST 8.0\n#define IBL 64\n#define MOUSE_CONTROLS 0\nfloat roughness = 1.;\nfloat sdf(vec3 p)\n{\n  vec3 q = abs(p) - vec3(2.);\n  return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\nfloat rayMarch(vec3 ro, vec3 rd, float start)\n{\n    float t = start;\n    for (int i = 0; i < 256; ++i)\n    {\n        float d = sdf(ro + rd * t);\n        if (d < VERY_SMOL)\n            return t;\n        t += d;\n        if (t >= MAX_DIST) return MAX_DIST;\n    }\n    return -t;\n}\nvec3 getNorm(vec3 p) {\n    return normalize(vec3(\n    \tsdf(vec3(p.x + VERY_SMOL, p.y, p.z)) - sdf(vec3(p.x - VERY_SMOL, p.y, p.z)),\n    \tsdf(vec3(p.x, p.y + VERY_SMOL, p.z)) - sdf(vec3(p.x, p.y - VERY_SMOL, p.z)),\n    \tsdf(vec3(p.x, p.y, p.z + VERY_SMOL)) - sdf(vec3(p.x, p.y, p.z - VERY_SMOL))\n    ));\n}\n\nvec2 hammersley(uint i, uint n) {\n\treturn vec2(\n        float(i) / float(n),\n    \tfloat(reverseuint(i)) * (1./4294967296.0)\n    );\n}\nvec3 importanceSampleGGX(vec2 xi, vec3 n)\n{\n    float a = roughness * roughness;\n    float phi = 2. * PI * xi.x;\n    float cos_theta = sqrt((1.-xi.y) / (1. + (a*a - 1.) * xi.y));\n    float sin_theta = sqrt(1. - cos_theta * cos_theta);\n    \n    vec3 h;\n    h.x = sin_theta * cos(phi);\n    h.y = sin_theta * sin(phi);\n    h.z = cos_theta;\n    \n    return h;\n}\n\nfloat gSmith(float NoV, float NoL)\n{\n    float a2 = roughness * roughness;\n    float lambda_v = (-1. + sqrt(a2 * (1. - NoL*NoL) / (NoL*NoL) + 1.)) * .5;\n    float lambda_l = (-1. + sqrt(a2 * (1. - NoV*NoV) / (NoV*NoV) + 1.)) * .5;\n    float g_smith = 1. / (1. + lambda_v + lambda_l);\n    return g_smith;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 scrpos = uv * 2. - 1.;\n    float aspect_ratio = iResolution.x / iResolution.y;\n\n    roughness = iMouse.x / iResolution.x;\n    \n  #if MOUSE_CONTROLS\n    mat4 view_mat =  rotY(-iMouse.x / iResolution.x * 2. * TAU) * rotX((iMouse.y / iResolution.y - PI) * 2. * TAU);\n  #else\n    mat4 view_mat =  rotY(iTime*.1 * TAU) * rotX(-.1 * TAU);  \n  #endif\n    \n    int seed = genSeed(int(fragCoord.x + fragCoord.y * iResolution.x) + genSeed(int(iTime * 1000.0)));\n    vec3 cam_pos = (view_mat * vec4(0.0, 0.0, -5.0, 1.0)).xyz;\n    vec3 color = vec3(0.0);\n    \n    vec3 ro = cam_pos;        \n    vec3 rd = (view_mat * vec4(normalize(vec3(\n        scrpos.x * aspect_ratio,\n        scrpos.y ,\n        1.0)), 0.0)).xyz;\n    float t = rayMarch(ro, rd, 0.01);\n    if (t >= MAX_DIST) //miss\n    {\n        color += texture(iChannel0, rd).xyz;\n    }\n    else //hit\n    {\n    \tvec3 ip = ro + rd * t;\n    \tvec3 n = getNorm(ip);\n        \n        //calculage tangents\n        vec3 up = abs(n.z) < 0.999 ? vec3(0,0,1) : vec3(1,0,0);\n        vec3 tangent = normalize(cross(up, n));\n        vec3 bitangent = cross(n, tangent);\n        \n        //sample roughness from a texture\n        vec2 texcoord = vec2(\n            dot(ip/4., tangent),\n            dot(ip/4., bitangent)) + vec2(0.5);\n        roughness = 1.-texture(iChannel1, texcoord).x;\n        //roughness = iMouse.x / iResolution.x;//\n        \n        //calculate specular\n        vec3 spec_color = vec3(.95, .64, .54);\n        vec3 spec = vec3(0);\n        vec3 diff = vec3(0);\n        for(int i = 0; i < IBL; ++i)\n        {\n            vec2 xi = hammersley(uint(i), uint(IBL));\n            vec3 h = importanceSampleGGX(xi, n);\n            h = tangent * h.x + bitangent * h.y + n * h.z;\n            \n            vec3 v = -rd;\n            vec3 l = 2. * dot(v, h) * h - v;\n            \n            float NoV = clamp(dot(n, v), 0., 1.);\n            float NoL = clamp(dot(n, l), 0., 1.);\n            float NoH = clamp(dot(n, h), 0., 1.);\n            float VoH = clamp(dot(v, h), 0., 1.);\n            \n            if(NoL > 0.)\n            {\n                vec3 sample_ = textureLod(iChannel0, l, 0.).xyz;\n                float g = gSmith(NoV, NoL);\n                float fc = pow(1.-VoH, 5.);\n                vec3 f = (1.-fc) * spec_color + vec3(fc);\n                spec += sample_ * f * g * VoH / (NoH * NoV);\n                diff += sample_ * NoL*spec_color;\n            }\n            \n        }\n        spec /= float(IBL);\n        diff /= float(IBL);\n        color += spec + diff;\n    }\n    \n    \n    \n    // Output to screen\n    fragColor = vec4(pow(color,vec3(1./2.2)),1.0);\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nint genSeed(int seed) {\n\tseed = (seed ^ 61) ^ (seed >> 16);\n    seed *= 9;\n    seed = seed ^ (seed >> 4);\n    seed *= 0x27d4eb2d;\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\nfloat rand(inout int seed) {\n\tseed ^= (seed << 13);\n\tseed ^= (seed >> 17);\n\tseed ^= (seed << 5);\n    return float(uint(seed)) * 2.3283064370807974e-10;\n}\nmat4 rotY(float r)\n{\n    float c = cos(r);\n    float s = sin(r);\n    return mat4(\n        vec4(c,0,s,1),\n        vec4(0,1,0,1),\n        vec4(-s,0,c,1),\n        vec4(0,0,0,1)\n    );\n}\nmat4 rotX(float r)\n{\n    float c = cos(r);\n    float s = sin(r);\n    return mat4(\n        vec4(1,0,0,0),\n        vec4(0,c,-s,0),\n        vec4(0,s,c,0),\n        vec4(0,0,0,1)\n    );\n}\nuint reverseuint(uint bits) {\n    bits = (bits << 16) | (bits >> 16);\n    bits = ((bits & 0x00ff00ffu) << 8) | ((bits & 0xff00ff00u) >> 8);\n    bits = ((bits & 0x0f0f0f0fu) << 4) | ((bits & 0xf0f0f0f0u) >> 4);\n    bits = ((bits & 0x33333333u) << 2) | ((bits & 0xccccccccu) >> 2);\n    bits = ((bits & 0x55555555u) << 1) | ((bits & 0xaaaaaaaau) >> 1);\n    return bits;   \n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsSyzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[149, 149, 168, 168, 260], [261, 261, 308, 308, 537], [538, 538, 560, 560, 842], [844, 844, 877, 877, 976], [977, 977, 1020, 1020, 1334], [1336, 1336, 1372, 1372, 1641], [1643, 1643, 1700, 1750, 4409]], "test": "untested"}
{"id": "ws2cRt", "name": "Simple frequency display", "author": "okh0056", "description": "simple audio frequency visualization", "tags": ["audiofrequency"], "likes": 6, "viewed": 566, "published": 3, "date": "1587191748", "time_retrieved": "2024-07-30T21:12:02.870016", "image_code": "vec3 COL1 = vec3(1.0,1.0,1.0);\nvec3 COL2 = vec3(0.0,0.0,1.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    float grid = float(mod(floor(uv.x * 500.0),14.0) < 0.5);\n    grid += float(mod(floor(uv.y * 200.0),11.0) < 0.4); \n    grid = float(grid>0.5);\n    \n    vec2 uvn = 1.6 * uv - 1.0;\n    grid *= 1.0-clamp(0.0,1.0,pow(length(uvn),0.3+0.1*sin(iTime)));\n    // aquire frequency\n    float fr = 0.01+ texture(iChannel0,vec2(uv.x*0.75,0.25)).x;\n    //atenuate\n    float i = pow(1.0-abs(uv.y-fr),20.0);\n    vec3 col = vec3(0.8,0.7,0.9)*grid+ vec3(i) * mix(COL1,COL2,uv.x);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2cRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 120, 120, 666]], "test": "untested"}
{"id": "ws2yRt", "name": "Audio wave form", "author": "okh0056", "description": "basic audio wave form", "tags": ["audiowavebasic"], "likes": 4, "viewed": 580, "published": 3, "date": "1587187210", "time_retrieved": "2024-07-30T21:12:03.721738", "image_code": "vec3 COL1 = vec3(0.6,0.0,0.0);\nvec3 COL2 = vec3(0.8,0.0,0.9);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    \n    float grid = float(mod(floor(uv.x * 500.0),14.0) < 0.5);\n    grid += float(mod(floor(uv.y * 200.0),11.0) < 0.5); \n    grid = float(grid>0.5);\n    \n    vec2 uvn = 2.0 * uv - 1.0;\n      \n     grid *= 1.0-clamp(0.0,1.0,pow(length(uvn),1.2));\n     \n    // aquire wave\n    float wa = texture(iChannel0,vec2(uv.x,0.75)).x;\n    \n    //attenuate\n    float i = pow(1.0-abs(uv.y-wa),20.0);\n    vec3 col = vec3(0.0,0.4,0.0)*grid+ vec3(i) * mix(COL1,COL2,i);\n    fragColor = vec4(col,0.7);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2yRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 120, 120, 653]], "test": "untested"}
{"id": "Wslyzs", "name": "ditherbrot", "author": "domrally", "description": "17 dither patterns to represent exit times in a Mandelbrot loop.\n[url=https://www.shadertoy.com/playlist/s3BcD1]FRACTAL PLAYLIST[/url]\n[url=https://www.shadertoy.com/playlist/fX2cWm]PIXEL PLAYLIST[/url]", "tags": ["fractal", "julia", "mandelbrot", "pixel", "dither", "bit", "lofi", "ordered"], "likes": 8, "viewed": 234, "published": 3, "date": "1587174500", "time_retrieved": "2024-07-30T21:12:04.838751", "image_code": "/// by Dom Mandy in 2020\n\n\n/*\nmandelbrot generating function\n*/\nvec2 quad(vec2 z, vec2 c) {\n    vec2 zNew;\n    zNew.x = z.x * z.x - z.y * z.y;\n    zNew.y = 2. * z.x * z.y;\n    \n    zNew += c;\n    \n    return zNew;\n}\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    // low res\n    const float derez = .5;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 r = derez * iResolution.xy;\n    fragCoord = .5 + floor(derez * fragCoord);\n    // composition\n    const float scale = 4.125;\n    // mouse controls as requested by FabriceNeyret2\n    vec2 zoom = step(iMouse.zw, vec2(0.01)) + step(0.01, iMouse.xy) * mix(1., .001, smoothstep(0., .25 * length(iResolution.xy), length(iMouse.zw - iMouse.xy)));\n    uv -= vec2(.5);\n    uv *= zoom;\n    // scale appropriatly\n    uv *= scale;\n    uv.x *= r.x / r.y;\n    // \n    uv += step(0.01, iMouse.xy) * scale * vec2(r.x / r.y, 1.) * mix(iMouse.zw / iResolution.xy - vec2(.5), vec2(0.), clamp(zoom, 0., 1.));\n    // mandelbrot\n    vec2 z = vec2(0.);\n    vec2 c = uv;\n    bool isValid = false;\n    float exit = 0.;\n    float count= 17.;\n    count += round(mix(40., 0., zoom.x));\n    for(int i = 0; float(i) < count; i++)\n    {\n        isValid = isValid || dot(z, z) > 4.;\n        exit = float(isValid) * exit + float(!isValid) * float(i);\n        z = quad(z, c);\n    }\n    exit /= float(count-1.);\n    // 4x4 bayer matrix yielding 17 tones to match the 17 potential exit times\n    float threshold = (texture(iChannel0, mod(fragCoord, 4.) / 8.).r * 63. - 3.) / (4. * 15.);\n\tvec3 color = vec3(float(threshold > exit));\n\n    fragColor = vec4(color, 1.);\n}\n\n\n/*\nFURTHER READING\n\nfractals\n\nhttps://en.wikipedia.org/wiki/Mandelbrot_set\nhttps://en.wikipedia.org/wiki/Complex_number#Multiplication_and_square\n\nrendering\n\nhttps://en.wikipedia.org/wiki/Ordered_dithering\n*/\n", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wslyzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 64, 91, 91, 215], [218, 218, 270, 285, 1596]], "test": "untested"}
{"id": "Wd2yRt", "name": "What is my colourspace?", "author": "ga354", "description": "sRGB should only be used for transmission/storage, largely abstracted away from the programmer. Seems like my display pipeline is interpreting my rendering intent as one with a nonlinearity applied.", "tags": ["color", "gamma", "colour", "colorspace", "srgb", "colourspace"], "likes": 3, "viewed": 1154, "published": 3, "date": "1587163813", "time_retrieved": "2024-07-30T21:12:05.611685", "image_code": "vec3 srgb2lin( vec3 cs )\n{\n\tvec3 c_lo = cs / 12.92;\n\tvec3 c_hi = pow( (cs + 0.055) / 1.055, vec3(2.4) );\n\tvec3 s = step(vec3(0.04045), cs);\n\treturn mix( c_lo, c_hi, s );\n}\nvec3 lin2srgb( vec3 cl )\n{\n\tvec3 c_lo = 12.92 * cl;\n\tvec3 c_hi = 1.055 * pow(cl,vec3(0.41666)) - 0.055;\n\tvec3 s = step( vec3(0.0031308), cl);\n\treturn mix( c_lo, c_hi, s );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //left, (0, 1) checkerboard pattern. averages on the retina to MAX_LUMINANCE/2.0 \n    if(gl_FragCoord.x/iResolution.x < .5){\n    \tfragColor = vec4(mod(gl_FragCoord.x + gl_FragCoord.y, 2.0));\n    }\n    else{\n        //top right 'should' blend in with the left hand side if you squint\n        fragColor = vec4( 1.0 / 2.0 ); //my intent is to display MAX_LUMINANCE/2.0 here, doesnt happen. \n        if(gl_FragCoord.y/iResolution.y < .5){\n            //bottom right. sadly does blend in with the left hand side better, cant know the display properties until we measure it\n        \tfragColor.xyz = lin2srgb(fragColor.xyz);\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2yRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 171], [172, 172, 198, 198, 345], [347, 347, 404, 490, 1044]], "test": "untested"}
{"id": "tdByzd", "name": "Sorting: (2^N)-1 comb network", "author": "metalim", "description": "Trying to do comb sorting network, using odd-even test to select paired direction.\nGets fast to \"nearly sorted\". Sorting by luminosity, right side shows how sorted array is.\n", "tags": ["sort", "sorting", "parallel"], "likes": 3, "viewed": 338, "published": 3, "date": "1587163194", "time_retrieved": "2024-07-30T21:12:06.474378", "image_code": "/*\n\n==================== Sorting series ====================\n\nhttps://www.shadertoy.com/view/tsByzt - odd-even sorting network (aka parallel bubble sort).\nhttps://www.shadertoy.com/view/tsBczt - odd-even horizontal-vertical experiment.\nhttps://www.shadertoy.com/view/tdByzd - (2^N)-1 comb sorting network.\nhttps://www.shadertoy.com/view/tsScWG - Leonardo comb sorting network.\n\nPress 'R' to Reset.\nHold 'D' or hold left mouse button to check neighbour Difference. To see how much sorted it is.\n\n*/\n\nint D(vec2 p, float n) {\n    int i=int(p.y), b=int(exp2(floor(30.-p.x-n*3.)));\n    i = ( p.x<0.||p.x>3.? 0:\n    i==5? 972980223: i==4? 690407533: i==3? 704642687: i==2? 696556137:i==1? 972881535: 0 )/b;\n \treturn i-i/2*2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    if (iMouse.z>0. && iMouse.x<fragCoord.x || iMouse.z<=0. && uv.x>.5+.3*sin(iTime*.5) || texelFetch(iChannel1,ivec2(68,0),0).r>0.)\n        fragColor = lum(texelFetch(iChannel0,ivec2(fragCoord),0)) < lum(texelFetch(iChannel0,ivec2(fragCoord)-ivec2(1,0),0)) ? vec4(0.) : vec4(1.);\n    else\n\t    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n\n    // sorting set number\n    vec2 i = fragCoord / 10.;\n    int size = int(iResolution.x)*int(iResolution.y);\n    int s1 = int(log2(float(size)));\n    int steps = s1*s1;\n    int set = iFrame/steps%6;\n    if ((i.x-=1.)<3. && i.y<7.) { fragColor += vec4(D(i,float(set))); }\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// common\n\nvec4 get(int index)\n{\n    return get(index, iChannel0, iResolution);\n}\n\nvec4 compareAndSwap(int i, int j, int isSecond, int size)\n{\n    return compareAndSwap(i, j, isSecond, size, iChannel0, iResolution);\n}\n\n/////////////////////////////////////////////////////////////////////////\n// sorting\n\n#define max_step_power 17\n#define large_cycle 15\n#define small_cycle 7\n\nvec4 update(int i, int size, int frame)\n{\n    // Selected distances: (2^N)-1, ... 63, 31, 15, 7, 3, 1, with cycles.\n    // All distances are odd, because we select odd-even pairs.\n\n    int isSecond = (i+frame)%2;\n    int k = frame/large_cycle - frame%small_cycle;\n    int dist = (((1<<max_step_power)-1)>>k)|1;\n    int j = i + dist*(1 - isSecond*2);\n\n    return compareAndSwap(i, j, isSecond, size);\n}\n\n/////////////////////////////////////////////////////////////////////////\n// common\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int size = int(iResolution.x)*int(iResolution.y);\n    int s1 = int(log2(float(size)));\n    int steps = s1*s1;\n    \n    if (iFrame%steps==0 || get(0,iChannel2,iResolution).xy != iResolution.xy || texelFetch(iChannel3,ivec2(82,0),0).r>0.)\n    {\n        int index = int(fragCoord.x)+int(iResolution.x)*int(fragCoord.y);\n        \n\n        int set = iFrame/steps%6;\n        if (set==0)\n        {\n            // horizontal split, only 4 values\n            fragColor = vec4(float(int(fragCoord.x)*4/int(iResolution.x))/4.);\n        }\n        else if (set==1)\n        {\n            // reversed\n            fragColor = vec4(float(size-index-1)/float(size));\n        }\n        else if (set==2)\n        {\n            // color gradient\n\t        fragColor = vec4(1.-fragCoord.y/iResolution.y, 1.-fragCoord.x/iResolution.x, fragCoord.y/iResolution.y, 0.);\n        }\n        else if (set==3)\n        {\n            // all sorted, but last element moved to front.\n            fragColor = vec4(float((index+size-1)%size)/float(size));\n        }\n        else if (set==4)\n        {\n            // even are sorted, odd are reversed\n            if (index%2==0)\n\t            fragColor = vec4(0.,float(index)/float(size),0.,0.);\n            else\n                fragColor = vec4(float(size-index-1)/float(size),0.,0.,0.);\n        }\n        else\n        {\n            // London texture\n        \tfragColor = vec4(init(iChannel1, fragCoord/iResolution.xy).rgb,0.);\n        }\n        fragColor.a = 0.; // frame number\n    }\n    else\n    {\n        int index = int(fragCoord.x)+int(iResolution.x)*int(fragCoord.y);\n        int frame = int(texelFetch(iChannel0,ivec2(fragCoord),0).a*256.);\n        fragColor = update(index, int(iResolution.x)*int(iResolution.y), frame);\n    \tfragColor.a = float(frame+1)/256.;\n    }\n}\n", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(iResolution,0.);\n}", "buffer_b_inputs": [], "common_code": "//#define BW\n\nvec4 get(int index, sampler2D chan, vec3 res) {\n    ivec2 p;\n    p.x = index%int(res.x);\n    p.y = index/int(res.x);\n    return texelFetch(chan,p,0);\n}\n\nfloat lum(vec4 c)\n{\n    return dot(c.rgb*vec3(0.3,0.59,0.11),vec3(1.));\n}\n\nvec4 bw(vec4 col)\n{\n    col.r = (col.r+col.g+col.b)/3.;\n    return col.rrra;\n}\n\nvec4 init(sampler2D chan, vec2 uv)\n{\n    vec4 col = texture(chan, uv);\n#ifdef BW\n    return bw(col);\n#else\n    return col;\n#endif\n}\n\nbool isSorted(vec4 a, vec4 b)\n{\n    return lum(a) <= lum(b);\n}\n\nvec4 compareAndSwap(int i, int j, int isSecond, int size, sampler2D chan, vec3 res)\n{\n    vec4 a = get(i, chan, res);\n\tif (j<0 || j>=size) return a;\n    vec4 b = get(j, chan, res);\n\n    if (isSecond!=0)\n    {\n        // note we have to keep the order of comparison, or we will lose pixels!\n        // as we can have less(a,b)==less(b,a), both false.\n        if (isSorted(b,a)) return a;\n        return b;\n    }\n    if (isSorted(a,b)) return a;\n    return b;\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdByzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[499, 499, 523, 523, 721], [723, 723, 780, 780, 1444]], "test": "untested"}
{"id": "tdBczd", "name": "Funny lil sea", "author": "Rondaar", "description": "Just my first lil, shadertoy-made shader. Coolio.", "tags": ["sea"], "likes": 2, "viewed": 283, "published": 3, "date": "1587160346", "time_retrieved": "2024-07-30T21:12:07.284213", "image_code": "#define PI 3.14\n#define col0 vec4(0.58,0.56,0.66,1.0)\n#define col1 vec4(0.39,0.29,0.4,1.0)\n#define col2 vec4(0.09,0.01,0.05,1.0)\n#define sunCol vec4(0.9,1.0,0.87,1.0)\n\nfloat waveAlpha(vec2 uv, float height, float rate, float amplitude, float xOffset, float yOffset, float yWaveAmount){\n    return step(uv.y-height+sin(iTime + yOffset)*yWaveAmount, (sin(uv.x*PI*rate+ sin(xOffset*iTime))*0.5 + 0.5)*amplitude);\n}\nfloat circleAlpha(vec2 uv, vec2 pos, float radius){\n    uv.y = uv.y*iResolution.y/iResolution.x;\n \treturn step(distance(uv,pos),radius);\n}\nfloat circleAlphaOutline(vec2 uv, vec2 pos, float radius){\n    uv.y = uv.y*iResolution.y/iResolution.x;\n \treturn clamp(1.0-distance(uv,pos)/radius,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat wave0 = waveAlpha(uv, 0.2, 8.0, 0.15, 0.25, 0.0, 0.01);\n\tfloat wave1 = waveAlpha(uv, 0.1, 8.0, 0.15, -0.5, 0.1, 0.025);\n    float wave2 = waveAlpha(uv, 0.0, 8.0, 0.15, 0.5, 0.2, 0.03);\n\tfloat circle = circleAlpha(uv, vec2(0.75,0.4), 0.1);\n    float circleOutline = circleAlphaOutline(uv, vec2(0.75,0.4), 0.4);\n    vec4 col = vec4(0.73,0.8, 0.8, 1.0);\n    col = mix(col,col0,wave0);\n    col = mix(col,col1, wave1);\n    col = mix(col,col2, wave2);\n    col = mix(col, sunCol, circle);\n    col = mix(col, sunCol, circleOutline);\n    //col += vec4(circleOutline);\n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdBczd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[168, 168, 285, 285, 411], [412, 412, 463, 463, 550], [551, 551, 609, 609, 709], [711, 711, 768, 818, 1471]], "test": "untested"}
{"id": "tsBczt", "name": "Sorting: experiment 1", "author": "metalim", "description": "An experiment, combining horizontal and vertical odd-even sort.\nDoesn't seem to make any sense at the moment. But is fun to watch at full screen.\nR - reset\nD - difference\nclick - difference\n", "tags": ["sort", "sorting", "parallel"], "likes": 2, "viewed": 340, "published": 3, "date": "1587157658", "time_retrieved": "2024-07-30T21:12:08.074101", "image_code": "/*\n\n==================== Sorting series ====================\n\nhttps://www.shadertoy.com/view/tsByzt - odd-even sorting network (aka parallel bubble sort).\nhttps://www.shadertoy.com/view/tsBczt - odd-even horizontal-vertical experiment.\nhttps://www.shadertoy.com/view/tdByzd - (2^N)-1 comb sorting network.\nhttps://www.shadertoy.com/view/tsScWG - Leonardo comb sorting network.\n\nPress 'R' to Reset.\nHold 'D' or hold left mouse button to check neighbour Difference. To see how much sorted it is.\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    if (iMouse.z>0. && iMouse.x<fragCoord.x || texelFetch(iChannel1,ivec2(68,0),0).r>0.)\n        fragColor = lum(texelFetch(iChannel0,ivec2(fragCoord),0)) < lum(texelFetch(iChannel0,ivec2(fragCoord)-ivec2(1,0),0)) ? vec4(0.) : vec4(1.);\n    else\n\t    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// common\n\nvec4 get(int index)\n{\n    return get(index, iChannel0, iResolution);\n}\n\nvec4 compareAndSwap(int i, int j, int isSecond, int size)\n{\n    return compareAndSwap(i, j, isSecond, size, iChannel0, iResolution);\n}\n\n/////////////////////////////////////////////////////////////////////////\n// sorting\n\n#define switch_after 2\n#define shift_right_when_vertical 1\n\nvec4 update(int i, int size, int frame)\n{\n    int width = int(iResolution.x);\n    int vertical = frame/switch_after%2;\n\n    int isSecond = (i+frame)%2;\n    int j = i + 1 - isSecond*2;\n\n    if (vertical!=0)\n    {\n        isSecond = (i/width+frame)%2;\n        j = i + (width + shift_right_when_vertical) * (1 - isSecond*2);\n    }\n\n    return compareAndSwap(i, j, isSecond, size);\n}\n\n/////////////////////////////////////////////////////////////////////////\n// common\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int index = int(fragCoord.x)+int(iResolution.x)*int(fragCoord.y);\n    if (iFrame<60 || get(0,iChannel2,iResolution).xy != iResolution.xy || texelFetch(iChannel3,ivec2(82,0),0).r>0.)\n        fragColor = vec4(init(iChannel1, fragCoord/iResolution.xy).rgb,0.);\n    else\n    {\n        int frame = int(texelFetch(iChannel0,ivec2(fragCoord),0).a*256.);\n        fragColor = update(index, int(iResolution.x)*int(iResolution.y), frame);\n    \tfragColor.a = float(frame+1)/256.;\n\n    }\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(iResolution,0.);\n}", "buffer_b_inputs": [], "common_code": "//#define BW\n\nvec4 get(int index, sampler2D chan, vec3 res) {\n    ivec2 p;\n    p.x = index%int(res.x);\n    p.y = index/int(res.x);\n    return texelFetch(chan,p,0);\n}\n\nfloat lum(vec4 c)\n{\n    return dot(c.rgb*vec3(0.3,0.59,0.11),vec3(1.));\n}\n\n\nvec4 bw(vec4 col)\n{\n    col.r = (col.r+col.g+col.b)/3.;\n    return col.rrra;\n}\n\nvec4 init(sampler2D chan, vec2 uv)\n{\n    vec4 col = texture(chan, uv);\n#ifdef BW\n    return bw(col);\n#else\n    return col;\n#endif\n}\n\nbool isSorted(vec4 a, vec4 b)\n{\n    return lum(a) <= lum(b);\n}\n\nvec4 compareAndSwap(int i, int j, int isSecond, int size, sampler2D chan, vec3 res)\n{\n    vec4 a = get(i, chan, res);\n\tif (j<0 || j>=size) return a;\n    vec4 b = get(j, chan, res);\n\n    if (isSecond!=0)\n    {\n        // note we have to keep the order of comparison, or we will lose pixels!\n        // as we can have less(a,b)==less(b,a), both false.\n        if (isSorted(b,a)) return a;\n        return b;\n    }\n    if (isSorted(a,b)) return a;\n    return b;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsBczt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[499, 499, 556, 556, 903]], "test": "untested"}
{"id": "tsBcRd", "name": "n4uj_GLPlotter", "author": "n4uj", "description": "Just plotting a sine function.", "tags": ["shader", "graph", "plot"], "likes": 1, "viewed": 414, "published": 3, "date": "1587155628", "time_retrieved": "2024-07-30T21:12:08.836064", "image_code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n\n\nfloat line = 0.1;\n\nfloat smin( float d1, float d2)\n{\n\tfloat k = 0.6521; k = 1.1;\n\tfloat h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n\treturn mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat f(vec2 uv)\n{\n\tfloat x = uv.x;\n\tfloat y = uv.y;\n    float f1 = cos((iTime + x)) - y;\n    float f2 = sin(iTime + x)*abs(cos(iTime)) - y;\n    //return smin(f1, f2);\n    return f1;\n}\n\nvec2 df( in vec2 x )\n\n{\n\tvec2 h = vec2( 0.01, 0.001 );\n\treturn vec2( f(x+h.xy) - f(x-h.xy), f(x+h.yx) - f(x-h.yx) )/(2.0*h.x);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv = fragCoord/iResolution.xy * vec2(10.0f, 10.0f);\n    uv += vec2(0.0, -4.0);\n\tfloat col = float (abs(f(uv))/length(df(uv)));\n\tcol = abs(f(uv))/sqrt(1.0 + pow(df(uv).x, 2.0));\n\tfragColor = vec4(smoothstep(0.98* line, line, col));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsBcRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 150, 150, 269], [271, 271, 289, 289, 455], [457, 457, 480, 480, 585], [588, 588, 645, 645, 885]], "test": "untested"}
{"id": "WdBcRV", "name": "NewtonFractal on sphere", "author": "elle", "description": "Newton fractal on sphere", "tags": ["fractal", "newton"], "likes": 2, "viewed": 325, "published": 3, "date": "1587153249", "time_retrieved": "2024-07-30T21:12:09.728677", "image_code": "vec4 sphere = vec4(0.0, 0.0, 1.0, 0.4);\nvec3 lightPos = vec3(-9.0, 8.0, -8.0);\nvec3 lightCol = vec3(1.0, 1.0, 1.0);\n\nfloat sphereDist1(vec3 ro, vec3 rd)\n{\n\tfloat R = sphere.w;\n\tvec3 d1 = sphere.xyz - ro;\n\tfloat b = dot(rd, d1);\n\tfloat d2 = dot(d1, d1) - b * b;\n\tfloat h2 = R * R - d2;\n    if (h2 <= 0.0)\n        return (-1.0);\n    return (b - sqrt(h2));\n}\n\nfloat sphereDist(vec3 p)\n{\n return (length(p - sphere.xyz) - sphere.w);   \n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0,4.0,2.0),6.0) - 3.0) - 1.0, 0.0, 1.0);\n\treturn (c.z * mix(vec3(1.0), rgb, c.y));\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat getShadow(vec3 ro, vec3 rd, float tmin, float tmax, const float k)\n{\n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i = 0; i < 50; i++)\n    {\n\t\tfloat h = sphereDist(ro + rd * t);\n        res = min(res, k * h / t);\n        t += clamp(h, 0.02, 0.20);\n        if(res < 0.005 || t > tmax)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 getNormal(vec3 pos)\n{\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0, -1.0) * 0.5773;\n    return normalize( e.xyy*sphereDist(pos + e.xyy*ep) + \n\t\t\t\t\t  e.yyx*sphereDist(pos + e.yyx*ep) + \n\t\t\t\t\t  e.yxy*sphereDist(pos + e.yxy*ep) + \n\t\t\t\t\t  e.xxx*sphereDist(pos + e.xxx*ep));\n}\n\n\nvec2 f(vec2 z)\n{\n    float mag = dot(z, z);\n    return (2.0 * z + vec2(z.x * z.x - z.y * z.y, -2.0 * z.x * z.y) / (mag * mag)) / 3.0;\n}\n\nvec2 roots[] = vec2[](vec2(1.0, 0.0), vec2(-0.5, 0.5 * sqrt(3.0)), vec2(-0.5, -0.5 * sqrt(3.0)));\n\nfloat newton(vec2 z) \n{\n    vec4 res;\n    for (int i = 0; i < 100; ++i)\n    {\n    \tz = f(z); \n        for (int root = 0; root < roots.length(); ++root)\n        {\n            vec2 differ = z - roots[root];\n            float dist = dot(differ, differ);\n            if (dist < 0.00001)\n\t\t\t\treturn (0.78 * cos(1.5 * log2(log(dist) / log(0.0001))));\n        }\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   vec2 aspectRatio = vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 uv = aspectRatio * (fragCoord.xy / iResolution.xy - 0.5);\n    vec2 mouse = 7.0 * (iMouse.xy / iResolution.xy - 0.5);  \n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    mouse.y += 0.3;\n\tfloat rot = -0.2;//iTime * 0.2;\n    mat3 rotX = mat3(\n        vec3(cos(mouse.x - rot), 0.0, sin(mouse.x - rot)),\n        vec3(0.0, 1.0, 0.0),\n        vec3(-sin(mouse.x - rot), 0.0, cos(mouse.x - rot)));  \n\tmat3 rotY = mat3(\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, cos(mouse.y), sin(mouse.y)),\n        vec3(0.0, -sin(mouse.y), cos(mouse.y)));\n\t\n    float dSphere = sphereDist1(ro, rd);\n\tvec3 pos = ro + dSphere * rd;\n\tvec3 normal = getNormal(pos);\n\tvec3 v3 = rotX * rotY * normal;\n    vec2 v2 = 9.0 * (cos(iTime * 0.2)) * v3.xy / abs(v3.z);\n    vec3 material;\n    if (dSphere < 0.0)\n        material = hsv2rgb(vec3(newton(v2), 0.8, 0.5));\n    else\n        material = hsv2rgb(vec3(newton(v2), 1.0, 1.2));\n    vec3 lightDir = normalize(vec3(lightPos - pos));\n    vec3 reflectDir = normalize(reflect(lightDir, normal));\n    float shadow = getShadow(pos, lightDir, 0.001, 1.0, 32.0);\n        \n    float diffuse = clamp(dot(normal, lightDir), 0.0, 1.0) * shadow * 0.4;\n    float ambient = 0.4 + 0.55 * normal.y;\n\tfloat specular = pow(clamp(dot(reflectDir, rd), 0.0, 1.0), 32.0) * 1.2 * shadow;\n        \n\tvec3 color = lightCol * material * (diffuse + specular + ambient);\n    color = sqrt(color);\n    color = pow(color, lightCol);\n    fragColor = vec4(color, 1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdBcRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 154, 154, 355], [357, 357, 383, 383, 433], [435, 435, 457, 457, 590], [592, 637, 711, 711, 991], [993, 1039, 1065, 1065, 1321], [1324, 1324, 1340, 1340, 1459], [1560, 1560, 1583, 1583, 1922], [1924, 1924, 1979, 1979, 3535]], "test": "untested"}
{"id": "tsByRd", "name": "n4uj_raymarcher", "author": "n4uj", "description": "It was about time I created my very own raymarcher.", "tags": ["ray", "sphere", "raymarcher", "march"], "likes": 0, "viewed": 311, "published": 3, "date": "1587152834", "time_retrieved": "2024-07-30T21:12:10.501610", "image_code": "#define MAX_STEPS 100\n#define ACCURACY 0.001\n#define MAX_DIST 100.0\n\n\nfloat GetDist(vec3 p)\n{\n\tvec4 s = vec4(0, 1, 6, 1); //(posx, posy, poz, radius)\n\tfloat sphereDist =  length(p - s.xyz) - s.w;\n\t\n\tfloat planeDist = p.y; //Plane formed by world x and world z\n\tfloat d = min(sphereDist, planeDist);\n\t\n\treturn d;\n}\n\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p);\n\tvec2 e = vec2(.01, 0);\n\t\n\tvec3 n = d - vec3(\tGetDist(p-e.xyy),\n\t\t\t\t\t\tGetDist(p-e.yxy),\n\t\t\t\t\t\tGetDist(p-e.yyx)\n\t\t\t\t\t );\n\t\n\treturn normalize(n);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd)\n{\n\tfloat traveled = 0.;\n\n\tfor (int i=0; i<MAX_STEPS; i++)\n\t{\n\t\tvec3 p = ro + rd*traveled;\n\t\tfloat dist = GetDist(p);\n\t\ttraveled += dist;\n\t\tif(traveled > MAX_DIST || dist < ACCURACY) break;\n\t}\n\n\treturn traveled;\n}\n\nfloat GetLight(vec3 p)\n{\n\n\tvec3 lightDir = normalize(vec3 (sin(iTime), 1.0 , cos(iTime)));\n\tvec3 normal = GetNormal(p);\n\tfloat diffuse = clamp(dot(lightDir, normal), 0.0, 1.0);\n\n\tfloat d = rayMarch(p + normal * ACCURACY * 2.0, lightDir);\t//If we didn't add normal * ACCURACY * 2.0, the whole plane will be in shade,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//since the rayMarch will return the min dist between dSphere and dPlane, that's why we offset it.\n\tif (d < length(lightDir)) diffuse *= .1;\n\n\treturn diffuse;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\t\n\tfloat fov = 1.0;\n\tvec3 ro = vec3(0.0, 1.0, 0.0);\n\tvec3 rd = normalize(vec3(uv.x, uv.y, fov));\n\n\tfloat d = rayMarch(ro, rd);\n\tvec3 p = ro + rd * d;\n\t\n\tvec3 col = vec3(uv.x, uv.y, 0.0);\n\tcol = vec3(p/10.0);\n\t// Output to screen\n\t//fragColor = vec4(col,1.0);\n\tfragColor = vec4(GetLight(p));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsByRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 93, 93, 313], [315, 315, 339, 339, 508], [510, 510, 544, 544, 755], [757, 757, 781, 781, 1249], [1251, 1251, 1308, 1308, 1662]], "test": "untested"}
{"id": "wd2czc", "name": "Experiment_2", "author": "okh0056", "description": "pattern attack", "tags": ["intro"], "likes": 3, "viewed": 364, "published": 3, "date": "1587149757", "time_retrieved": "2024-07-30T21:12:11.272549", "image_code": "float f(vec2 p, float featureSize)\n{\n\tp.x = cos(p.x*1.3+t*0.09)*tanh(t+p.x*0.13)*2.;\t\n    p += crd(p.x*1.5)*0.6;\n    return smoothstep(-0.02,featureSize,abs(p.y));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec3 c;\n    vec3 col;\n    vec2 uv;\n\tfloat l,z=t;\n    float aspect = iResolution.y/iResolution.x;\n    float featureSize = 135./((iResolution.x*aspect+iResolution.y));\n\n    vec2 p = fragCoord.xy / iResolution.xy*2.3;\n\tp.x *= aspect;\n\tp.y = abs(p.y);\n    for(int i=0;i<3;i++) {       \n\t   uv=p;\n\t   p+=coth(t*DELTA);\n\t   p.x*=r.x/r.y;\n       l=length(p)*aspect;\n\t   z+=log(t*DELTA);\t\t    \n\t   uv+=(sec(l)*abs(tan(z)));\n       \n\t\tc[i] = ANGLE*length(abs(mod(coth(uv),f(sec(p),atan(featureSize)))));\n        \n\t   \n    \n\t}\n      c -= (cos(vec3(0.5,2.5,1.6)* -0.15)*0.19)*(1.-f(p,featureSize));\n    \n\t   fragColor=vec4(c,1.);\n}", "image_inputs": [], "common_code": "\n#define t iTime\n#define r iResolution.xy\n#define ANGLE 1.25\n#define DELTA 0.00315\n#define XOFF .99\n\nfloat crd(float ang) {\n    return 2.*sin(ang/2.);\n}\nvec2 crd(vec2 ang) {\n    return 2.*sin(ang/2.);\n}\n\nfloat sec(float ang) {\n    return 1./cos(ang);\n}\nvec2 sec(vec2 ang) {\n    return 1./cos(ang);\n}\n\nfloat csc(float ang) {\n    return 1./sin(ang);\n}\nvec2 csc(vec2 ang) {\n    return 1./sin(ang);\n}\n\nfloat cot(float ang) {\n    return 1./tan(ang);\n}\nvec2 cot(vec2 ang) {\n    return 1./tan(ang);\n}\n\nfloat sech(float ang) {\n    return 1./cosh(ang);\n}\n\nvec2 sech(vec2 ang) {\n    return 1./cosh(ang);\n}\n\nfloat csch(float ang) {\n    return 1./sinh(ang);\n}\n\nvec2 csch(vec2 ang) {\n    return 1./sinh(ang);\n}\n\nfloat coth(float ang) {\n    return 1./tanh(ang);\n}\n\nvec2 coth(vec2 ang) {\n    return 1./tanh(ang);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2czc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 165], [168, 168, 224, 224, 846]], "test": "untested"}
{"id": "tsByzt", "name": "Sorting: odd-even network", "author": "metalim", "description": "The most basic sorting for GPU. And slowest one. O(n) frames.\n\nNOTE: we sort full image as a single linear array to show HOW SLOW this method really is.\n99120 frames for 420x236, at 60 FPS: 1652 seconds = 23.5 minutes.\nOr many hours for full-screen. :-)\n", "tags": ["sort", "sorting", "parallel"], "likes": 2, "viewed": 353, "published": 3, "date": "1587148835", "time_retrieved": "2024-07-30T21:12:12.068423", "image_code": "/*\n\n==================== Sorting series ====================\n\nhttps://www.shadertoy.com/view/tsByzt - odd-even sorting network (aka parallel bubble sort).\nhttps://www.shadertoy.com/view/tsBczt - odd-even horizontal-vertical experiment.\nhttps://www.shadertoy.com/view/tdByzd - (2^N)-1 comb sorting network.\nhttps://www.shadertoy.com/view/tsScWG - Leonardo comb sorting network.\n\nPress 'R' to Reset.\nHold 'D' or hold left mouse button to check neighbour Difference. To see how much sorted it is.\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    if (iMouse.z>0. && iMouse.x<fragCoord.x || iMouse.z<=0. && uv.x>.5+.3*sin(iTime*.5) || texelFetch(iChannel1,ivec2(68,0),0).r>0.)\n        fragColor = lum(texelFetch(iChannel0,ivec2(fragCoord),0)) < lum(texelFetch(iChannel0,ivec2(fragCoord)-ivec2(1,0),0)) ? vec4(0.) : vec4(1.);\n    else\n\t    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// common\n\nvec4 get(int index)\n{\n    return get(index, iChannel0, iResolution);\n}\n\nvec4 compareAndSwap(int i, int j, int isSecond, int size)\n{\n    return compareAndSwap(i, j, isSecond, size, iChannel0, iResolution);\n}\n\n/////////////////////////////////////////////////////////////////////////\n// sorting\n\nvec4 update(int i, int size, int frame)\n{\n    int isSecond = (i+frame)%2;\n    int j = i + 1 - isSecond*2;\n\n    return compareAndSwap(i, j, isSecond, size);\n}\n\n/////////////////////////////////////////////////////////////////////////\n// common\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int index = int(fragCoord.x)+int(iResolution.x)*int(fragCoord.y);\n    if (iFrame<60 || get(0,iChannel2,iResolution).xy != iResolution.xy || texelFetch(iChannel3,ivec2(82,0),0).r>0.)\n        fragColor = vec4(init(iChannel1, fragCoord/iResolution.xy).rgb,0.);\n    else\n    {\n        int frame = int(texelFetch(iChannel0,ivec2(fragCoord),0).a*256.);\n        fragColor = update(index, int(iResolution.x)*int(iResolution.y), frame);\n    \tfragColor.a = float(frame+1)/256.;\n    }\n}\n", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(iResolution,0.);\n}", "buffer_b_inputs": [], "common_code": "//#define BW\n\nvec4 get(int index, sampler2D chan, vec3 res) {\n    ivec2 p;\n    p.x = index%int(res.x);\n    p.y = index/int(res.x);\n    return texelFetch(chan,p,0);\n}\n\nfloat lum(vec4 c)\n{\n    return dot(c.rgb*vec3(0.3,0.59,0.11),vec3(1.));\n}\n\nvec4 bw(vec4 col)\n{\n    col.r = (col.r+col.g+col.b)/3.;\n    return col.rrra;\n}\n\nvec4 init(sampler2D chan, vec2 uv)\n{\n    vec4 col = texture(chan, uv);\n#ifdef BW\n    return bw(col);\n#else\n    return col;\n#endif\n}\n\nbool isSorted(vec4 a, vec4 b)\n{\n    return lum(a) <= lum(b);\n}\n\nvec4 compareAndSwap(int i, int j, int isSecond, int size, sampler2D chan, vec3 res)\n{\n    vec4 a = get(i, chan, res);\n\tif (j<0 || j>=size) return a;\n    vec4 b = get(j, chan, res);\n\n    if (isSecond!=0)\n    {\n        // note we have to keep the order of comparison, or we will lose pixels!\n        // as we can have less(a,b)==less(b,a), both false.\n        if (isSorted(b,a)) return a;\n        return b;\n    }\n    if (isSorted(a,b)) return a;\n    return b;\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsByzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[499, 499, 556, 556, 947]], "test": "untested"}
{"id": "WsSczd", "name": "Cursive", "author": "BackwardsCap", "description": "Writing in cursive", "tags": ["1tweet"], "likes": 1, "viewed": 252, "published": 3, "date": "1587148660", "time_retrieved": "2024-07-30T21:12:12.847339", "image_code": "void mainImage( out vec4 o, in vec2 f )\n{\n    vec2 p = (2.0*f-iResolution.xy)/iResolution.y+.5;\n    for(float t=iTime,s,c,i=1.;i<3.;i++){\n        s=sin(t/i),c=cos(t/i);\n\t\tp.yx=p/(dot(-p+cos(.001*i*(p.x-p.y)),p));\n\t\tp*=.25*(1.5+c)/2.*mat2(c,-s,s,c);\n    }\n    o.gb = p;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsSczd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 270]], "test": "untested"}
{"id": "wsByzt", "name": "Color Circle SmoothStep", "author": "nickcody", "description": "Click and drag to four corners: x-axis controls width of circle edge, y-axis controls blend.", "tags": ["circle", "geometry", "smoothstep"], "likes": 2, "viewed": 495, "published": 3, "date": "1587145663", "time_retrieved": "2024-07-30T21:12:13.616283", "image_code": "const vec3 white = vec3(1., 1., 1.);\nconst vec3 black = vec3(0., 0., 0.);\nconst float EDGE_SCALE = .02;\n\n// circleTest\n//\n// coord      - pixel to test\n// center     - center of circle\n// radius     - radius of circle\n// width      - thickness of circle line\n// pixelWidth - blendiness\nvec3 circleTest(vec2 coord, vec2 center, float radius, float width, float pixelWidth) {\n    float dist_to_center = sqrt(pow(coord.x - center.x, 2.) + pow(coord.y - center.y, 2.));\n    float delta = dist_to_center-radius;\n\n    // From shadertoy default shader\n    vec2 uv = gl_FragCoord.xy/iResolution.xy;\n    vec3 inside = .5 + .5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float blend = smoothstep(0., pixelWidth, abs(delta) - width);\n    \n    if (delta  < 0.) {\n    \t// rgb -> white (inside  edge)\n        return mix(white, inside, blend);\n    } else if (delta  > 0.) {\n    \t// white -> black (outside edge)\n        return mix(white, black, blend);\n    } else {\n        // can't decide\n        return white;\n    }\n        \n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord) {\n\tvec2 center = iResolution.xy/2.;\n    float pixelWidth;\n    float width;\n    \n    if (iMouse.xy == vec2(0)) {\n        pixelWidth = width = 1.;\n    } else {\n        pixelWidth = EDGE_SCALE * distance(iMouse.y, 0.);\n        width = EDGE_SCALE * distance(iMouse.x, 0.);\n    }\n    \n    vec3 c = circleTest(gl_FragCoord.xy, center, center.y/2., width, pixelWidth);\n\t\n    out_color = vec4(c, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsByzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 286, 373, 373, 1009], [1011, 1011, 1063, 1063, 1456]], "test": "untested"}
{"id": "3dByRd", "name": "Projective Torus", "author": "mla", "description": "Raymarched torus, transformed projectively. Uses analytic DE & gradient,\n\nMouse moves viewpoint, <up>, <down> steps in and out.\nSet torus type on lines 13-15.", "tags": ["torus", "analytic", "projective"], "likes": 9, "viewed": 371, "published": 3, "date": "1587133589", "time_retrieved": "2024-07-30T21:12:14.389216", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Projective Torus\n//\n// Matthew Arcus, mla, 2020.\n//\n// Regular, spindle and horn toruses (uncomment appropriate line down below),\n// raymarched with projective transformation and analytic DE and gradient.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// Torus params - uncomment line for selected type\n//const float R = 1.0, r = 0.5; // Regular torus\nconst float R = 0.5, r = 1.0; // Spindle torus\n//const float R = 0.75, r = 0.75; // Horn torus\nconst float R2 = R*R, r2 = r*r;\nconst vec4 X = vec4(1,1,1,R2-r2);\n\nint AA = 2; // Set to 1 for more speed\n\nfloat PI = 3.14159265;\nbool dorotate = true;\n\nvec3 lightdir = vec3(0,2,1);\n\nmat4 A = mat4(1); // Projective transformation\nfloat eyesign = 1.0; // Sign of distance field at eye.\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nfloat de(vec4 p) {\n  float len = length(p.xyz);\n  // This gets rid of \"plane at infinity\", which otherwise shrinks\n  // all distances to 0.\n  if (len > 100.0) p.xyz *= 100.0/len;\n  float t = dot(p*X,p);\n  float x = p.x, y = p.y, w = p.w;\n  float x2 = x*x, y2 = y*y, w2 = w*w;\n  return t*t - 4.0*R2*w2*(x2+y2);\n}\n\nvec4 grad(vec4 p) {\n  float t = dot(p*X,p);\n  float x = p.x, y = p.y, w = p.w;\n  float x2 = x*x, y2 = y*y;\n  return 4.0*t*X*p - 8.0*R2*w*vec4(x*w,y*w,0,x2+y2);\n}\n\nfloat eval(vec3 p3) {\n  vec4 p = vec4(p3,1);\n  p = A*p;\n  float d = de(p);\n  vec3 g = transpose(mat3x4(A))*grad(p);\n  d /= length(g); // Maybe use max here?\n  return eyesign*d;\n}\n\nvec3 getnormal(vec3 p) {\n  vec4 p4 = A*vec4(p,1);\n  return normalize(eyesign*transpose(mat3x4(A))*grad(p4));\n}\n  \nfloat maxdist = 10.0;\nfloat fogdist = 4.0;\nfloat march(vec3 q, vec3 r) {\n  float t = 0.1;\n  int numsteps = 200;\n  float precis = 1e-3;\n  for (int i = 0; i < numsteps; i++) {\n    //assert(i < 20);\n    vec3 p = q+t*r;\n    float d = eval(p);\n    //assert(d >= 0.0);\n    if (abs(d) < precis) return t;\n    d = min(0.5,d);\n    t += d;\n    if (t < 0.0 || t > maxdist) break;\n  }\n  return -1.0;\n}\n\n// 2d stuff for torus surface\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  vec2 pa = p - a;\n  vec2 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  float d = length(pa - ba * h);\n  return d;\n}\n\nvec3 regioncolor(int region) {\n#if 1\n  vec3 a = vec3(0.4);\n  vec3 b = vec3(0.6);\n  vec3 c = vec3(1);\n  vec3 d = vec3(0,0.4,0.5);\n  float t = float(region)/6.0;\n  // iq's most excellent palette technique\n  return a+b*cos(2.0*PI*(c*t+d));\n#else\n  vec3 col;\n  if (region == 0) col = vec3(0,1,0);\n  if (region == 1) col = vec3(0,1,1);\n  if (region == 2) col = vec3(1,1,0);\n  if (region == 3) col = vec3(1,0,0);\n  if (region == 4) col = vec3(0,0,1);\n  return col;\n#endif\n}\n\n// Which side of qr is p?\nbool g(vec2 p, vec2 q, vec2 r) {\n  vec2 n = (r-q).yx*vec2(-1,1);\n  return dot(p-q,n) < 0.0;\n}\n\nvec3 pattern(vec2 p) {\n  vec2 px = p;\n  p = mod(p,2.0);\n  p = min(p,2.0-p);\n  if (p.x+p.y > 1.0) p = 1.0-p.yx; // Reflect in x+y=1\n  bool fundamental = p == px;\n  p *= 5.878;\n  // p0a etc. are reflections in the walls of p0 etc.\n  vec2 p0 = vec2(1,0);\n  vec2 p0a = vec2(-1,0);\n  vec2 p1 = vec2(2,1.73);\n  vec2 p2 = vec2(1,3.46);\n  vec2 p2a = vec2(-1,3.46);\n  vec2 p2b = 5.878-p2.yx;\n  vec2 p3 = vec2(5.078,0.8);\n  vec2 p3a = vec2(5.078,-0.8);\n  vec2 p4 = vec2(3.878,2);\n  float d = 1e8;\n\n  int region = 0;\n  if (g(p,p3a,p3)) region = 1;\n  else if (g(p,p0,p1) && g(p,p1,p4)) region = 2;\n  else if (g(p,p1,p2) && g(p,p2,p2b)) region = 3;\n  else if (g(p,p2,p2a)) region = 4;  \n\n  vec3 col = regioncolor(region);\n  col = mix(vec3(1),col,0.5);\n  \n  //if (!fundamental) col *= 0.5;\n  d = min(d,segment(p,p0,p1));\n  d = min(d,segment(p,p1,p2));\n  d = min(d,segment(p,p2,p2a));\n  d = min(d,segment(p,p2,p2b));\n  d = min(d,segment(p,p0,p0a));\n  d = min(d,segment(p,p3,p3a));\n  d = min(d,segment(p,p3,p4));\n  d = min(d,segment(p,p1,p4));\n  col *= vec3(smoothstep(0.05,0.1,d));\n  return col;\n}\n\nvec3 getcolor(vec3 p) {\n  // Projectivize, transform and unprojectivize\n  vec4 p4 = A*vec4(p,1);\n  p = p4.xyz/p4.w;\n  // Coordinates on torus\n  float phi = atan(p.x,p.y);\n  float a = length(p.xy);\n  float z = p.z;\n  // There is some ambiguity about mapping x,y,z to torus\n  // coordinates for spindle toruses.\n  // z,a-> atan(z,a-R) or atan(z,a+R), since\n  // z^2 + (a-R)^2 = r^2 or z^2 + (a+R)^2 = r^2 ie.\n  // z^2 + a^2 - 2aR + R^2 - r^2 = 0 or\n  // z^2 + a^2 + 2aR + R^2 - r^2 = 0\n  float t = z*z + a*a + R2 - r2 > 0.0 ? a-R : a+R;\n  float rho = atan(z,t);\n  vec2 uv = 2.0*vec2(phi,rho)/PI; \n  uv *= 2.0*vec2(R+r,r); // (3,1)\n  return pattern(uv);\n}\n\nvoid init() {\n  float time = 0.4*iTime;\n  A = mat4(1);\n  A *= mat4(cos(time),0,0,sin(time),\n            0,1,0,0,\n            0,0,1,0,\n            -sin(time),0,0,cos(time));\n  A *= mat4(1,0,0,0,\n            0,cos(time),sin(time),0,\n            0,-sin(time),cos(time),0,\n            0,0,0,1);\n}\n\nvec3 raycolor(vec3 q, vec3 r) {\n  vec3 background = 0.1*regioncolor(5); //vec3(0.05,0,0);\n  float t = march(q,r);\n  if (t < 0.0) return background;\n  vec3 p = q+t*r;\n  vec3 normal = getnormal(p);\n  vec3 color = getcolor(p);\n  vec3 speccolor = color;\n  float ambient = 0.5;\n  float diffuse = 0.3*clamp(dot(normal,lightdir),0.0,1.0);\n  color *= ambient+diffuse;\n  float specular = pow(max(0.0,dot(reflect(lightdir,normal),r)),10.0);\n  color += 0.8*specular*speccolor;\n  color = mix(color,background,clamp((t-fogdist)/(maxdist-fogdist),0.0,1.0));\n  return color;\n}\n\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 rotateframe(vec3 p) {\n  if (iMouse.x > 0.0) {\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (dorotate) {\n    float t = iTime;\n    //p.yz = rotate(p.yz,t*0.125);\n    p.zx = rotate(p.zx,0.5*PI-t*0.02);\n  }\n  return p;\n}\n\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nbool key(int key) {\n   return texelFetch(iChannel2, ivec2(key,2),0).x != 0.0;\n}\nvec4 store(int i,int j) {\n  return texelFetch(iChannel3, ivec2(i,j),0);\n}\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n  init();\n  float eyedist = 4.0;\n  eyedist *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  fogdist = eyedist;\n  maxdist = 2.0*eyedist;\n  vec3 eye = vec3(0,0,eyedist);\n  eye = rotateframe(eye);\n  eyesign = sign(eval(eye));\n  lightdir = rotateframe(lightdir);\n  lightdir = normalize(lightdir);\n  vec3 col = vec3(0);\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 z = (2.0*(fragCoord+vec2(i,j)/float(AA))-iResolution.xy)/iResolution.y;\n      vec3 ray = vec3(z,-2);\n      ray = rotateframe(ray);\n      ray = normalize(ray);\n      col += raycolor(eye,ray);\n    }\n  }\n  col /= float(AA*AA);\n  col = pow(col,vec3(0.4545));\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel2,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x);\n  int j = int(uv.y);\n  if ( iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel3,ivec2(i,j),0); // Get current state   \n  }  \n  if (i == 0) {\n    float w1 = keystate(j,2).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      t.x++;\n    }\n  }     \n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dByRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[878, 878, 899, 899, 925], [927, 927, 945, 945, 1238], [1240, 1240, 1259, 1259, 1401], [1403, 1403, 1424, 1424, 1581], [1583, 1583, 1607, 1607, 1693], [1740, 1740, 1769, 1769, 2086], [2088, 2118, 2157, 2157, 2298], [2300, 2300, 2330, 2330, 2767], [2769, 2795, 2827, 2827, 2888], [2890, 2890, 2912, 2912, 3972], [3974, 3974, 3997, 4045, 4626], [4628, 4628, 4641, 4641, 4920], [4922, 4922, 4953, 4953, 5483], [5485, 5485, 5521, 5521, 5573], [5575, 5575, 5601, 5601, 5949], [6000, 6000, 6019, 6019, 6079], [6080, 6080, 6105, 6105, 6153], [6154, 6154, 6177, 6177, 6209], [6211, 6211, 6262, 6262, 6975]], "test": "untested"}
{"id": "Ws2cRc", "name": "refraction fun", "author": "manon_graphics_witch", "description": "water", "tags": ["glass"], "likes": 1, "viewed": 359, "published": 3, "date": "1587132549", "time_retrieved": "2024-07-30T21:12:15.175115", "image_code": "#define VERY_SMOL 0.001\n#define SMOL 0.001\n#define MAX_DIST  50.0\n#define SPP 8\n#define MAX_RAY_DEPTH 5\n#define PI 3.14159265358\n#define TAU (2.*PI)\nbool inside;\n//http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nint genSeed(int seed) {\n\tseed = (seed ^ 61) ^ (seed >> 16);\n    seed *= 9;\n    seed = seed ^ (seed >> 4);\n    seed *= 0x27d4eb2d;\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\nfloat rand(inout int seed) {\n\tseed ^= (seed << 13);\n\tseed ^= (seed >> 17);\n\tseed ^= (seed << 5);\n    return float(uint(seed)) * 2.3283064370807974e-10;\n}\nfloat sdf(vec3 p)\n{\n  //float result = length(p) - 1.0;\n  //vec2 t = vec2(1.0, 0.3);\n  //vec2 q = vec2(length(p.xz)-t.x,p.y);\n  //float result = length(q)-t.y;\n    \n    vec3 c = vec3(10.0);\n    vec3 q = p - c * round(p / c);\n    \n    \n  float d= 4.;\n  return length(q) - 1.0 + (sin(d*q.x+iTime)*sin(d*q.y+iTime)*sin(d*q.z+iTime)) * 0.1;\n  \n}\nfloat sdf2(vec3 p)\n{\n    float s = sdf(p);\n \treturn inside ? -s : s;   \n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float start, float end)\n{\n    float depth = start;\n    for (int i = 0; i < 256; ++i)\n    {\n        float distance = sdf2(ro + rd * depth);\n        if (distance < VERY_SMOL)\n            return depth;\n        depth += distance;\n        if (depth >= end) return end;\n    }\n    return -depth;\n}\nvec3 getNorm(vec3 p) {\n    return normalize(vec3(\n    \tsdf2(vec3(p.x + SMOL, p.y, p.z)) - sdf2(vec3(p.x - SMOL, p.y, p.z)),\n    \tsdf2(vec3(p.x, p.y + SMOL, p.z)) - sdf2(vec3(p.x, p.y - SMOL, p.z)),\n    \tsdf2(vec3(p.x, p.y, p.z + SMOL)) - sdf2(vec3(p.x, p.y, p.z - SMOL))\n    ));\n}\nfloat fresnel(float n1, float n2, vec3 normal, vec3 view)\n{\n  float r0 = (n1 - n2) / (n1 + n2);\n  r0 = r0 * r0;\n\n  float fresnel = r0 + (1.0 - r0) * pow(1.0 - dot(normal, view), 5.0);\n  return clamp(fresnel, 0.0, 1.0);\n}\nmat4 rotY(float r)\n{\n    float c = cos(r);\n    float s = sin(r);\n    return mat4(\n        vec4(c,0,s,1),\n        vec4(0,1,0,1),\n        vec4(-s,0,c,1),\n        vec4(0,0,0,1)\n    );\n}\nmat4 rotX(float r)\n{\n    float c = cos(r);\n    float s = sin(r);\n    return mat4(\n        vec4(1,0,0,0),\n        vec4(0,c,-s,0),\n        vec4(0,s,c,0),\n        vec4(0,0,0,1)\n    );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 scrpos = uv * 2. - 1.;\n    float aspect_ratio = iResolution.x / iResolution.y;\n\n    mat4 view_mat =  rotY(-iMouse.x / iResolution.x * 2. * TAU) * rotX((iMouse.y / iResolution.y - PI) * 2. * TAU);\n    \n    int seed = genSeed(int(fragCoord.x + fragCoord.y * iResolution.x) + genSeed(int(iTime * 1000.0)));\n    vec3 cam_pos = (view_mat * vec4(0.0, 0.0, -2.0, 1.0)).xyz;\n    vec3 color = vec3(0.0);\n    \n    for (int samp = 0; samp < SPP; ++samp)\n    {\n        vec3 ro = cam_pos;\n        \n        vec3 rd = (view_mat * vec4(normalize(vec3(\n                (scrpos.x + (2. * rand(seed) / iResolution.x)) * aspect_ratio,\n                (scrpos.y + (2. * rand(seed) / iResolution.y)),\n                1.0)), 0.0)).xyz;\n\n        vec3 throughput = vec3(1.0);\n        int depth;\n        for (depth = 0; depth < MAX_RAY_DEPTH; ++depth)\n        {\n        \tinside = sdf(ro) < 0.0;\n            \n            float t = rayMarch(ro, rd, 0.01, MAX_DIST);\n            if (t < 0.)\n            {\n                fragColor = vec4(vec3(-t / MAX_DIST),0);\n                return;\n            }\n            \n            if (t >= MAX_DIST) {\n                throughput *= texture(iChannel0, rd).xyz;\n                color += throughput;\n                break;\n            }\n\n            vec3 ip = ro + rd * t; //intersection point\n            vec3 norm = getNorm(ip);\n            \n            \n            float kRefract = 1.3333;\n            float n1 = 1.0;\n            float n2 = kRefract;\n            if(inside) {n2 = 1.0; n1 = kRefract;}\n            \n            \n            float f = fresnel(n1, n2, norm, -rd);\n            float r0 = rand(seed);\n            if (f > r0)\n            {\n            \tro = ip + norm * 0.01;\n                rd = normalize(reflect(rd, norm));\n            }\n            else\n            {\n                vec3 refr = (refract(rd, norm, n1 / n2));\n                if(abs(dot(refr, refr)) < VERY_SMOL)\n                {\n                    //handle total inner reflection\n                \tro = ip + norm * 0.01;\n                \trefr = reflect(rd, norm);\n                }\n                else\n                {\n                \tro = ip - norm * 0.01;\n                }\n                \n                rd = refr;   \n            }\n        }\n        \n        \n        //reached max depth, cheat by saying we hit the skybox =]\n        if(depth == MAX_RAY_DEPTH) color += texture(iChannel0, rd).xyz;\n    }\n    color *= (1.0 / float(SPP));\n    \n    \n    // Output to screen\n    fragColor = vec4(pow(color,vec3(1./2.2)),1.0);\n    //fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2cRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[162, 237, 260, 260, 417], [418, 418, 446, 446, 571], [572, 572, 591, 731, 913], [914, 914, 934, 934, 987], [989, 989, 1047, 1047, 1312], [1313, 1313, 1335, 1335, 1593], [1594, 1594, 1653, 1653, 1814], [1815, 1815, 1835, 1835, 1997], [1998, 1998, 2018, 2018, 2180], [2181, 2181, 2238, 2288, 4903]], "test": "untested"}
{"id": "3sBczt", "name": "Webcam motion pixelation #4", "author": "rasmuskaae", "description": "Pixelation of motion on webcam", "tags": ["webcam", "motion", "pixelation"], "likes": 5, "viewed": 651, "published": 3, "date": "1587129931", "time_retrieved": "2024-07-30T21:12:15.958022", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (1.0/32.0)*fragCoord/iResolution.xy;\n\n    vec4 a = texture(iChannel0, uv);\n    vec4 b = texture(iChannel0, vec2(uv.x+0.5,uv.y));\n    \n    vec4 c = a-b;\n    c *= c*4.0;\n    \n    \n    fragColor = c+texture(iChannel1,fragCoord/iResolution.xy);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float lag_control = 0.125;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    // lower left\n    if (uv.x<0.5 && uv.y<0.5) {\n\t    fragColor = texture(iChannel0, uv*32.0);\n    }\n\n    // lower right\n    if (uv.x>0.5 && uv.y<0.5) {\n         fragColor = mix(texture(iChannel1, uv),texture(iChannel1, vec2(uv.x, uv.y+0.5)),lag_control);\n    }\n\n    // upper right\n    if (uv.x>0.5 && uv.y>0.5) {\n        // fragColor = vec4(0.0,0.0,1.0,1.0);\n        fragColor = mix(texture(iChannel1, uv),texture(iChannel1, vec2(uv.x-0.5, uv.y)),lag_control);\n    }\n\n    // upper left\n    if (uv.x<0.5 && uv.y>0.5) {\n        fragColor = mix(texture(iChannel1, uv),texture(iChannel1, vec2(uv.x, uv.y-0.5)),lag_control);\n        // fragColor = vec4(0.0,1.0,0.0,1.0);\n    }\n    \n    \n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sBczt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 314]], "test": "untested"}
{"id": "ws2yzc", "name": "fast Gaussain Blur", "author": "indere", "description": "inspired by https://zhuanlan.zhihu.com/p/58182228", "tags": ["2d"], "likes": 1, "viewed": 618, "published": 3, "date": "1587111582", "time_retrieved": "2024-07-30T21:12:16.974304", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tif(uv.x > iMouse.x / iResolution.x)\n    \tfragColor = texture(iChannel0, uv);\n   \telse\n        fragColor = texture(iChannel1, uv);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float weight[5] = float[5](0.17620410973798, 0.28032472003769, 0.11089769144348, 0.019407096002609, 0.0010872322690537);\nfloat offset[5] = float[5](0.0, 1.4285714285714, 3.3333333333333, 5.2380952380952, 7.0);\nfloat blurTimes = 1.0;\n\nbool space() {\n    return texture(iChannel2, vec2(32.5/256.0, 0.5) ).x > 0.5;\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 sum_color = vec3(0.0);\n    sum_color = texture(iChannel1, uv).rgb* weight[0];\n    for(int i = 1; i < 5; ++i){\n        sum_color += texture(iChannel0, uv + vec2(0.0, offset[i] / iResolution.y)).rgb * weight[i];\n        sum_color += texture(iChannel0, uv - vec2(0.0, offset[i] / iResolution.y)).rgb * weight[i];\n    }\n    fragColor = vec4(sum_color, 1.0);\n    \n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "float weight[5] = float[5](0.17620410973798, 0.28032472003769, 0.11089769144348, 0.019407096002609, 0.0010872322690537);\nfloat offset[5] = float[5](0.0, 1.4285714285714, 3.3333333333333, 5.2380952380952, 7.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n   \tvec3 sum_color = texture(iChannel0, uv).rgb * weight[0];\n    for(int i = 1; i < 5; ++i){\n    \tsum_color += texture(iChannel0, uv + vec2(offset[i] / iResolution.x, 0.0)).rgb * weight[i];\n        sum_color += texture(iChannel0, uv - vec2(offset[i] / iResolution.x, 0.0)).rgb * weight[i];\n    }\n    fragColor = vec4(sum_color, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2yzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 280]], "test": "untested"}
{"id": "tsjcRc", "name": "Webcam zoomblur #3", "author": "rasmuskaae", "description": "Simple zoomblur on your webcam", "tags": ["webcam", "zoomblur"], "likes": 4, "viewed": 802, "published": 3, "date": "1587106349", "time_retrieved": "2024-07-30T21:12:17.929750", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 c = texture(iChannel2, uv);\n    \n    fragColor = c;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjcRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 160]], "test": "untested"}
{"id": "wsjczV", "name": "[4k] stuck by jetlag", "author": "w23", "description": "4k intro for Revision Online 2020\n\nmusic: keen\n\npouet: https://www.pouet.net/prod.php?which=85243", "tags": ["4k", "refraction", "caustics", "pathtracing", "dispersion", "revision2020"], "likes": 11, "viewed": 649, "published": 3, "date": "1587104668", "time_retrieved": "2024-07-30T21:12:19.002881", "image_code": "float t;\nuniform sampler2D Tex;\n\nvec3 E=vec3(0.,.01,1.);\n\nfloat hash1(float f){return fract(sin(f)*46347.4238);}\nfloat hash2(vec2 v){return hash1(dot(v,vec2(79.53248,31.4328)));}\n\nfloat noise2(vec2 v) {\n\tvec2 V=floor(v);v-=V;\n\tv*=v*(3.-2.*v);\n\treturn mix(\n\t\tmix(hash2(V+E.xx), hash2(V+E.zx), v.x),\n\t\tmix(hash2(V+E.xz), hash2(V+E.zz), v.x), v.y);\n}\n\n// Real 4k uses real GDI-generated texture\nfloat getchar(vec2 char_pos) {\n    const float J = 74., L = 76., S = 83.;\n    const float a = 97.,  b = 98.,  c = 99.,  d = 100., e = 101., f = 102., g = 103., h = 104.;\n    const float i = 105., j = 106., k = 107., l = 108., m = 109., n = 110., o = 111., p = 112.;\n    const float q = 113., r = 114., s = 115., t = 116., u = 117., v = 118., w = 119., x = 120.;\n    const float y = 121., z = 122.;\n    const float dash = 45., slash = 47.;\n    const float n0 = 48., n2 = 50.;\n    const float space = 32.;\n    float cursor = 0.;\n    #define C(c) if (cursor == char_pos.x) { return c; } else { cursor++; } \n    if (char_pos.y == 0.) { C(n) C(o) C(t) C(i) C(c) C(e) C(space) C(m) C(e) C(space) C(s) C(e) C(m) C(p) C(a) C(i) }\n    else if (char_pos.y == 1.) { C(a) C(l) C(c) C(a) C(t) C(r) C(a) C(z) }\n\telse if (char_pos.y == 2.) { C(c) C(o) C(n) C(s) C(p) C(i) C(r) C(a) C(c) C(y) }\n\telse if (char_pos.y == 3.) { C(c) C(t) C(r) C(l) C(dash) C(a) C(l) C(t) C(dash) C(t) C(e) C(s) C(t) }\n\telse if (char_pos.y == 4.) { C(f) C(a) C(i) C(r) C(l) C(i) C(g) C(h) C(t)  }\n\telse if (char_pos.y == 5.) { C(f) C(a) C(r) C(b) C(r) C(a) C(u) C(s) C(c) C(h)  }\n\telse if (char_pos.y == 6.) { C(L) C(J)  }\n\telse if (char_pos.y == 7.) { C(l) C(o) C(g) C(i) C(c) C(o) C(m) C(a)  }\n\telse if (char_pos.y == 8.) { C(m) C(e) C(r) C(c) C(u) C(r) C(y)  }\n\telse if (char_pos.y == 9.) { C(o) C(r) C(a) C(n) C(g) C(e)  }\n\telse if (char_pos.y == 10.) { C(p) C(r) C(i) C(s) C(m) C(b) C(e) C(i) C(n) C(g) C(s)  }\n\telse if (char_pos.y == 11.) { C(q) C(u) C(i) C(t) C(e)  }\n\telse if (char_pos.y == 12.) { C(S) C(a) C(n) C(d) C(S)  }\n\telse if (char_pos.y == 13.) { C(s) C(t) C(i) C(l) C(l)  }\n\telse if (char_pos.y == 14.) { C(t) C(dash) C(r) C(e) C(x)  }\n\telse if (char_pos.y == 15.) { C(t) C(h) C(r) C(o) C(b)  }\n\telse if (char_pos.y == 16.) { C(t) C(i) C(t) C(a) C(n)  }\n\telse if (char_pos.y == 17.) { C(j) C(e) C(t) C(l) C(a) C(g) C(slash) C(s) C(t) C(u) C(c) C(k)  }\n\telse if (char_pos.y == 18.) { C(k) C(e) C(e) C(n) C(space) C(p) C(r) C(o) C(v) C(o) C(d)  }\n\telse if (char_pos.y == 19.) { C(r) C(e) C(v) C(i) C(s) C(i) C(o) C(n) C(space) C(n2) C(n0) C(n2) C(n0)  }\n    return 32.;\n\n}\nfloat text(vec2 p) {\n    p *= 1024.;\n    const vec2 glyph_size = vec2(21., 44.);\n    vec2 char_pos = floor(p / glyph_size);\n    p = fract(p / glyph_size) - .5;\n    vec2 t_glyph_size = iChannelResolution[1].xy / 16.;\n    \n    char_pos.y = -1. - char_pos.y;\n    float char = getchar(char_pos);\n    vec2 t_glyph_pos = vec2(mod(char, 16.), 15. - floor(char / 16.));\n    p.x *= glyph_size.x / glyph_size.y;\n    return smoothstep(.53, .48, texture(iChannel1, (t_glyph_pos + .5 + p) * t_glyph_size / iChannelResolution[1].xy, -8.).a);\n}\n\nfloat mask(vec2 p) {\n\tif (t < 1016.) return 0.;\n\tif (p.x < 0. || p.x > 32.) return 0.;\n\tif (p.y > 2.8 ) return 0.;\n\tp -= 2.;\n\n\tfloat line = floor(p.y / 1.5);\n\tif (t < 1152.) {\n\t\tif (line == -1.) {\n\t\t} else if (line == -2.) {\n\t\t\tline = (t < 1056.) ? 0. : -2. - floor(t-1056.)/8.;\n\t\t} else {\n\t\t\treturn 0.;\n\t\t}\n\t} else {\n\t\tline -= 16.;\n\t}\n\tp.y = line * 1.5 + mod(p.y, 1.5);\n\treturn text(p/32.);\n}\n\nfloat w(vec3 p) { return min(p.y+2., length(p)-2.); }\nvec3 wn(vec3 p) { return normalize(vec3(\n\tw(p+E.yxx),w(p+E.xyx),w(p+E.xxy))-w(p));\n}\nfloat tr(vec3 O, vec3 D, float l, float L) {\n\tfor (float i = 0.; i < 40.; ++i) {\n\t\tfloat d = w(O + D * l);\n\t\tl += d;\n\t\tif (d < .001 || l > L) break;\n\t}\n\treturn l;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {        \n    t = 4. * iTime * 125. / 60.;\n    t = mod(t, 1232.);\n    //t = 4. * iChannelTime[0] * 125. / 60.; /* iChannelTime[0] is updated like 10 times per second :( */\n\tvec2 uv=(fragCoord.xy/iResolution.xy)*2.-1.;uv.x*=iResolution.x/iResolution.y;\n    \n\tvec3 c=vec3(0.);\n\tvec3 O, D, P, N;\n\tvec2 UV;\n\tfloat M;\n\tfloat l;\n\tfloat seed = fract(t + uv.x);\n\tfloat bar = floor(t/16.);\n\n\tvec3 sundir = normalize(vec3(1.));\n\tfloat dof = .4;\n\tfloat fov = 1. + 1. * fract(t/32.);\n\n\tvec3 ca = vec3(0., -1., 0.);\n\tvec3 cp = vec3(0., 1.9, 5.);\n\tcp.z += 4. * fract(t/32.);\n\tfloat lfoc = 0.;\n\n\tfloat mskymat = 0.;\n\tfloat mballmat = 0.;\n\tfloat mfloormat = 0.;\n\tfloat yu = 0.;\n\n\tif (t < 304.) {\n\t\tmskymat = 0.;\n\t\tmballmat = 0.;\n\t\tmfloormat = 0.;\n\t\tdof = .01;\n\t\tfov = 2.;\n\n\t\tca = vec3(0., 0., 0.);\n\t\tcp = vec3(0., 1., 5. + 2. * fract(t/16.));\n\t} else {\n\t\tca = vec3(\n\t\t\tsin(bar*3.) * 4.,\n\t\t\tsin(bar*4.),\n\t\t\tsin(bar*5.) * 4.);\n\n\t\tmskymat = 1.;\n\t\tmballmat = 0.;\n\t\tmfloormat = 0.;\n\t\tdof = .2;\n\t\tfov = 2.;\n\n\t\tcp = vec3(\n\t\t\tsin(bar) * 10.,\n\t\t\t2. + 2. * sin(bar*7.),\n\t\t\t10. * cos(bar*3.));\n\t}\n\n\tif (t > 362.) {\n\t\tmskymat = 1.;\n\t\tmfloormat = 3.;\n\t\tmballmat = 0.;\n\n\t\tfloat ph = fract((t-362.) / 128.);\n\t\tca = vec3(0., 0., 0.);\n\t\tcp = vec3(0., 1., 5. + 32. * ph);\n\t\tfov = 1. + 4. * ph;\n\t}\n\n\tif (t > 490.) {\n\t\tmballmat = 1.;\n\t\tdof = .4;\n\t}\n\n\tif (t > 580.) {\n\t\tca = vec3(\n\t\t\tsin(bar*3.) * 4.,\n\t\t\tsin(bar*4.),\n\t\t\tsin(bar*5.) * 4.);\n\t\tcp = vec3(\n\t\t\tsin(bar) * 10.,\n\t\t\t2. + 2. * sin(bar*7.),\n\t\t\t10. * cos(bar*3.));\n\t}\n\n\tif (t > 704.) {\n\t\tmballmat = 2.;\n\t\tmskymat = 2.;\n\t\tdof = .4;\n\t}\n\n\tif (t > 832.) {\n\t\t// FIXME proper material ranges\n\t\tmskymat = mod(floor(t/8.),4.);\n\t\tmballmat = mod(floor(t/4.)/*TODO beat sync, 4th beat is earlier*/,5.);\n\t\tmfloormat = mod(floor(t/6.),4.);\n\t\tif (mskymat == 3.)\n\t\t\tmfloormat = 1.;\n\n\t\tfloat ph = fract(t/16.);\n\t\tfloat a = sin(bar), b = sin(bar+3.);\n\t\tcp = ca + mix(\n\t\t\tvec3(cos(a)*10.,2.+2.*sin(bar*2.),sin(a)*10.),\n\t\t\tvec3(cos(b)*10.,2.+2.*sin(bar*3.),sin(b)*10.), ph * ph);\n\t\tcp *= max(1., 8. / length(cp));\n\t\tca = vec3(\n\t\t\tsin(bar*3.) * 2.,\n\t\t\tsin(bar*4.),\n\t\t\tsin(bar*5.) * 2.);\n\t\t\tyu = sin(bar*17.);\n\t}\n\n\tif (t > 1016.) {\n\t\tca = vec3(5., 1., 0.);\n\t\tcp.z = abs(cp.z);\n\t\tcp *= max(1., 8. / length(cp));\n\n\t\tfloat ph = fract(t/64.);\n\t\tfov = 1. + 2. * ph;\n\t\tcp = vec3(8. + 10. * sin(bar + t/16.), 2., 10.);\n\t}\n\n\tif (t > 1152.) {\n\t\tmskymat = 0.;\n\t\tcp = vec3(10., 2., 10.);\n\t\tyu = 0.;\n\t}\n\n\tif (t > 1184.) {\n\t\tmfloormat = 3.;\n\t}\n\n\tif (t > 1216.) {\n\t\tmballmat = 1.;\n\t}\n\n\tlfoc += length(ca-cp);\n\n\t// PATHTRACER STARTS\n    const float samples_per_pixel = 32.;\n\tfor (float s=0.;s<samples_per_pixel;++s) {\n\t\tD = normalize(cross(O = normalize(ca-cp), vec3(yu,1.,0.)));\n\t\tvec3 up = normalize(cross(D, O));\n\t\tmat3 mv = mat3(D, up, -O);\n\n\t\tif (t < 266.) {\n\t\t\tD = mv*normalize(vec3(uv/fov, -1.)*lfoc - O);\n\t\t\tO = mv*O + cp;\n\n\t\t\tfloat L = 100., l = tr(O, D, 0., L);\n\t\t\tif (l < L) {\n\t\t\t\tP = O + D * l;\n\t\t\t\tvec3 n = wn(P);\n\t\t\t\tif (bar < 2.) c = vec3(1.);\n\t\t\t\telse if (bar < 4.) c = vec3(l/L);\n\t\t\t\telse if (bar < 6.) c = P;\n\t\t\t\telse if (bar < 8.) c = fract(P);\n\t\t\t\telse if (bar < 10.) c = n;\n\t\t\t\telse {\n\t\t\t\t\tc += .8 * vec3(max(0., dot(n, sundir)));\n\t\t\t\t\tif (bar > 14.)\n\t\t\t\t\t\tc *= step(5., tr(P, sundir, .1, 5.));\n\t\t\t\t\tif (bar > 12.)\n\t\t\t\t\t\tc = vec3(.01) + .5 *c;\n\t\t\t\t}\n\t\t\t\tc *= samples_per_pixel;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tfloat a = hash1(seed+=O.x)*6.2831;\n\t\tO = vec3(vec2(cos(a),sin(a))*sqrt(hash1(seed+=uv.y))*dof,0.);\n\t\tD = mv*normalize(vec3(uv / fov, -1.)*lfoc - O);\n\t\tO = mv*O + cp;\n\n\t\tfloat ins = 1.;\n\t\tfloat hue = hash1(seed += P.x);\n\t\tvec3 kc = clamp(abs(fract(vec3(3.,2.,1.)/3. + hue)*6.-3.)-1.,0.,1.);\n\n\t\tfor (float i = 0.; i < 6.; ++i) {\n\t\t\tvec3 me = vec3(0.), ma = vec3(.8);\n\t\t\tfloat mr = 1.;\n\t\t\tvec2 mf = vec2(1., 1.);\n\t\t\tl = 1e6;\n\t\t\tM = 0.;\n\n\t\t\tif (D.y < 0.) {\n\t\t\t\tl = (-2. - O.y) / D.y;\n\t\t\t\tP = O + D * l;\n\t\t\t\tN = E.xzx;\n\t\t\t\tUV = P.xz;\n\t\t\t\tM = 1.;\n\t\t\t}\n\n\t\t\tfloat b = dot(-O, D);\n\t\t\tfloat det2 = b * b - dot(-O, -O) + 4.;\n\t\t\tif (det2 >= 0.) {\n\t\t\t\tdet2 = sqrt(det2);\n\t\t\t\tfloat t1 = b - det2, t2 = b + det2;\n\t\t\t\tif (t1 < 0.) t1 = 1e6;\n\t\t\t\tif (t2 < 0.) t2 = 1e6;\n\t\t\t\tfloat ls = min(t1, t2);\n\t\t\t\tif (ls < l) {\n\t\t\t\t\tl = ls;\n\t\t\t\t\tP = O + D * l;\n\t\t\t\t\tN = ins * normalize(P);\n\t\t\t\t\tM = 2.;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// text plane\n\t\t\tfloat lp = -O.z / D.z;\n\t\t\tif (lp > 0. && lp < l) {\n\t\t\t\tvec3 p = O + D * lp;\n\t\t\t\tif (mask(p.xy) > .5) {\n\t\t\t\t\tP = p;\n\t\t\t\t\tl = lp;\n\t\t\t\t\tN = E.xxz;\n\t\t\t\t\tUV = P.xy;\n\t\t\t\t\tM = 3.;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (M == 0.) { // SKY\n\t\t\t\tma = vec3(0.);\n\t\t\t\tif (mskymat == 0.) {\n\t\t\t\t\t\tme = vec3(100.) * pow(max(0., dot(D,sundir)), 300.);\n\t\t\t\t} else if (mskymat == 1.) {\n\t\t\t\t\tvec2 skp = D.xz*(10.-O.y)/D.y * .1;\n\t\t\t\t\tfloat sk = noise2(skp)*.5 + noise2(skp*12.1)*.125 + noise2(skp*3.8)*.125 + noise2(skp*9.)*.0625;\n\t\t\t\t\tme = .3 * vec3(.3,.5,.9)\n\t\t\t\t\t\t+ 400.*vec3(.9,.6,.2) * pow(max(0., dot(D,sundir)), 400.)\n\t\t\t\t\t\t+ vec3(smoothstep(.4,.6,sk));\n\t\t\t\t\t\t;\n\t\t\t\t} else if (mskymat == 2.) {\n\t\t\t\t\tme = 10. * vec3(step(abs(dot(D,sundir)+mod(t/16.,1.)-1.), .05));\n\t\t\t\t\tvec3 bd = normalize(vec3(-1., .5, .1));\n\t\t\t\t\tme += .2 * vec3(.4, .1, .3) * pow(max(0., dot(D,bd)), 3.);\n\t\t\t\t\tbd = normalize(vec3(1., .3, .3));\n\t\t\t\t\tme += .2 * vec3(.1, .5, .4) * pow(max(0., dot(D,bd)), 4.);\n\t\t\t\t}\n\t\t\t} else if (M == 2.) { // BALL\n\t\t\t\tif (mballmat == 0.) {\n\t\t\t\t} else if (mballmat == 1.) {\n\t\t\t\t\tma = vec3(.8);\n\t\t\t\t\tmf = vec2(.5, mix(.95,.8,hue)); // FIXME fresnel angle dependent?\n\t\t\t\t\tmr = .0;\n\t\t\t\t} else if(mballmat == 2.) {\n\t\t\t\t\tma = vec3(1.);\n\t\t\t\t\tmf = vec2(1.,1.);\n\t\t\t\t\tmr = .2;\n\t\t\t\t} else if(mballmat == 3.) {\n\t\t\t\t\tme = N;\n\t\t\t\t\tma = vec3(1.);\n\t\t\t\t\tmf = vec2(1.,1.);\n\t\t\t\t\tmr = .4;\n\t\t\t\t} else if(mballmat == 4.) {\n\t\t\t\t\tma = vec3(1.);\n\t\t\t\t\tmf = vec2(.0, mix(.85,.8,hue)); // FIXME fresnel angle dependent?\n\t\t\t\t\tmr = .4;\n\t\t\t\t}\n\t\t\t} else if (M == 1.) { // GROUND\n\t\t\t\tif (mfloormat == 0.) {\n\t\t\t\t} else if (mfloormat == 1.) {\n\t\t\t\t\tma = vec3(.9);\n\t\t\t\t\tmr = .5;\n\t\t\t\t\tUV *= 4.;\n\t\t\t\t\tvec2 cid = floor(UV);\n\t\t\t\t\tvec2 cc = fract(UV)*2. - 1.;\n\n\t\t\t\t\tvec2 rcid = vec2(floor(t/2.) + length(cid), atan(cid.x, cid.y));\n\n\t\t\t\t\tme += vec3(1.,.6,.3) * step(.97,hash2(rcid));\n\t\t\t\t\tme += vec3(.3,.4,.9) * step(.98,hash2(rcid+1.));\n\t\t\t\t\tme += vec3(.3,.8,.3) * step(.98,hash2(rcid+2.));\n\n\t\t\t\t\tme *= vec3(\n\t\t\t\t\t\tstep(length(cc),.8),\n\t\t\t\t\t\tstep(length(cc+vec2(.1,0.)),.8),\n\t\t\t\t\t\tstep(length(cc+vec2(.0,.1)),.8)\n\t\t\t\t\t);\n\t\t\t\t\tmr = .001 + hash2(cid)*.3;\n\t\t\t\t\tma *= step(abs(cc.x),.9)*step(abs(cc.y),.9);\n\n\t\t\t\t\tme *= 10.;\n\t\t\t\t} else if (mfloormat == 2.) {\n\t\t\t\t\tma = vec3(1.);\n\t\t\t\t\tfloat ns =\n\t\t\t\t\t\t.5 * noise2(UV)\n\t\t\t\t\t\t+ .25 * noise2(UV * 1.9)\n\t\t\t\t\t\t+ .125 * noise2(UV * 3.9)\n\t\t\t\t\t\t+ .0625 * noise2(UV * 9.);\n\t\t\t\t\tmr = .2 + .2 * ns;\n\t\t\t\t} else if (mfloormat == 3.) {\n\t\t\t\t\tma = vec3(1.);\n\t\t\t\t\tUV *= .7;\n\t\t\t\t\tfloat ns =\n\t\t\t\t\t\t.5 * noise2(UV)\n\t\t\t\t\t\t+ .25 * noise2(UV * 1.9)\n\t\t\t\t\t\t+ .125 * noise2(UV * 3.9)\n\t\t\t\t\t\t+ .0625 * noise2(UV * 9.);\n\t\t\t\t\tmr = .01 + .2 * smoothstep(.4, .5, ns);\n\t\t\t\t} else if (mfloormat == 4.) {\n\t\t\t\t\tma = vec3(1.);\n\t\t\t\t\tmr = .3;\n\t\t\t\t\tme = vec3(step(abs(P.z + 2. * floor(mod(t, 8.)) - 8.), 1.));\n\t\t\t\t}\n\t\t\t} else { // TEXT\n\t\t\t\tme = vec3(4.);\n\t\t\t\tma = vec3(0.);\n\t\t\t}\n\n\t\t\tc += kc * me;\n\t\t\tkc *= ma;\n\n\t\t\tif (all(lessThan(kc,vec3(.001)))) break;\n\n\t\t\tif (hash1(seed+=P.y) > mf.x) {\n\t\t\t\tO = P - .01 * N;\n\t\t\t\tD = normalize(refract(D, N, mf.y));\n\t\t\t\tins = -ins;\n\t\t\t} else {\n\t\t\t\tO = P + .01 * N;\n\t\t\t\tD = normalize(mix(\n\t\t\t\t\treflect(D, N),\n\t\t\t\t\tvec3(hash1(seed+=P.z),hash1(seed+=D.x),hash1(seed+=P.y))-.5, mr));\n\t\t\t\tD *= sign(dot(D, N));\n\t\t\t}\n\t\t}\n\t}\n\n\tfragColor=vec4(sqrt(c/samples_per_pixel), 0.);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22040, "src": "https://soundcloud.com/keensky/stuck", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsjczV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 79, 79, 112], [113, 113, 133, 133, 178], [180, 180, 202, 202, 347], [2545, 2545, 2565, 2565, 3074], [3076, 3076, 3096, 3096, 3469], [3471, 3471, 3488, 3488, 3524], [3525, 3525, 3542, 3542, 3609], [3610, 3610, 3654, 3654, 3774], [3776, 3776, 3831, 3831, 11269]], "test": "untested"}
{"id": "Wdjcz3", "name": "LearningShaderToy_Lesson01_Task", "author": "derko666", "description": "First learning shader", "tags": ["learningshaders"], "likes": 2, "viewed": 319, "published": 3, "date": "1587076535", "time_retrieved": "2024-07-30T21:12:19.839643", "image_code": "#define PI 3.14\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //Normalize    \n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) /iResolution.y;\n    \n    float pixelSize = 2.0 / iResolution.y;\n    \n    //Waves\n    float wave1 = sin (uv.x * 3.0 + iTime) * .1 + 0.1;\n    float wave2 = sin (uv.x * 2. + iTime * 2.0) * .1 - 0.2;\n    float wave3 = sin (uv.x * 1. + iTime * 4.0) * .1 - 0.6;\n    \n    //Fields\n    float land = 1.0 - step (wave1, uv.y);\n    float land2 = 1.0 - step (wave2, uv.y);\n    float land3 = 1.0 - step (wave3, uv.y);\n    \n    //Colors\n    vec4 sky = vec4(0.1, 0.6, 0.7, 0.0); \n    vec4 grass = vec4(0.0, 0.1, 0.04, 0.0);\n\tvec4 grass2 = vec4(0.01, .2, 0.09, 0.0);\n    vec4 grass3 = vec4(0.05, .25, 0.1, 0.0);\n    \n\n    \n    //Moon\n    vec2 moonCenter = vec2(cos (iTime),sin (iTime));\n    float radius = .250;\n    float dist = distance(uv, moonCenter);\n    float moon = 1.0 - smoothstep(radius - pixelSize, radius + pixelSize, dist);\n    \n    //MoonLight\n    float distGradient = distance(uv * 1.5, moonCenter * 1.5);\n    float moonLight = clamp((1. - distGradient),0.0, 1.0) / 1.5;\n    \n    //Sun\n    vec2 sunCenter = vec2(cos (iTime + PI),sin (iTime + PI));\n    float radiusSun = .30;\n    float distSun = distance(uv, sunCenter);\n    float sun = 1.0 - smoothstep(radiusSun - pixelSize, radiusSun + pixelSize, distSun);\n    \n    //SunLight\n    float distGradientSun = distance(uv, sunCenter);\n    float sunLight = clamp((1. - distGradientSun),0.0, 1.0) / 1.5;\n    vec4 sunLightColor = vec4(0.3,0.3,0.,0.);\n    sunLightColor = sunLightColor + vec4(clamp((sin(iTime  + PI)), 0.2, 1.0), clamp((sin(iTime + PI)), 0.1, 1.0),0.0,0.0);\n    \n    //Ambient addition   \n    moon += moonLight;\n    sun += sunLight;\n    \n    //gradient overlay\n    vec4 gradient = vec4(-1.,-1.,-1.,0.6);\n    vec4 gradientFront = vec4(-.2,-.2,-.2,0.6);\n    float daynight = clamp(sin(uv.y / 3. + iTime), 0.0, 0.3);\n    \n    \n    vec4 picture = sky;\n    picture = mix(picture, gradient, daynight);\n    picture = mix(picture,  vec4(1.0), moon);\n    picture = mix(picture, sunLightColor, sun);\n    picture = mix(picture, grass, land);\n    picture = mix(picture, grass2, land2);\n    picture = mix(picture, grass3, land3);\n    picture = mix(picture, gradientFront, daynight);\n    picture.rgb = pow(picture.rgb, vec3(1.0/2.2)); \n\n    \n    \n    fragColor = vec4(picture);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wdjcz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 74, 99, 2372]], "test": "untested"}
{"id": "tdByR3", "name": "Concentricity", "author": "mla", "description": "Concentric spheres, inspired by [url]https://www.shadertoy.com/view/wd2cWW[/url] by ZiMMaBuE.\n\nMouse moves things around, eg. changes the lighting and the lurid background.", "tags": ["escher", "concentric", "octahedral", "rinds"], "likes": 4, "viewed": 396, "published": 3, "date": "1587071271", "time_retrieved": "2024-07-30T21:12:20.860913", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Concentricity\n// Matthew Arcus, mla, 2020\n//\n// Octahedral symmetry again.\n//\n// Inspired by: https://www.shadertoy.com/view/wd2cWW\n//\n// Nested spherical disdyakis dodecahedrons (this is actually what they are\n// called: https://en.wikipedia.org/wiki/Disdyakis_dodecahedron)\n//\n////////////////////////////////////////////////////////////////////////////////\n\nint AA = 1; // Set to 2 for quality\n\nvec3 light = vec3(0,-2,1); // Position of light\nfloat eradius = 0.03; // Thickness of an edge\nfloat eyedist = 2.5;  // Eye is at (0,0,eyedist);\nfloat PI = 3.1415927; \n\n// Raymarching configuration.\nint maxsteps = 100;\nfloat precis = 1e-3; \n\nbool dorotate = false;\n\n// Find the distance to a spherical segment, encapsulated in m.\n// m maps p to nearest point in some subspace (ie. a plane).\nfloat ssegment(vec3 p, mat3 m) {\n  vec3 p1 = normalize(m*p);\n  // And return the 'distance' to the closest point.\n  float len = length(p);\n  float x = distance(p/len,p1);    // Distance on surface\n  float y = len-1.0; // Radial distance\n  return max(x,abs(y))-eradius;\n}\n\n// Matrix for segment through q and r - take a point p,\n// Use q and r as basis vectors for subspace, so first\n// take dot products with q and r, then map to coordinates\n// in that basis (matrix m), then map back to R3. This is\n// then the nearest point to p in the subspace.\n// Assumes q and r normalized\nmat3 mkmatrix(vec3 q, vec3 r) {\n  mat2 m = inverse(mat2(1,dot(q,r),dot(q,r),1));\n  return mat2x3(q,r)*m*transpose(mat2x3(q,r));\n}\n\nmat3 m0,m1,m2;\nvec4 q0,q1,q2,qbg,qlight;\n\nvoid init() {\n  vec3 A = vec3(1,0,0);\n  vec3 B = vec3(0,1,0);\n  vec3 C = vec3(0,0,1);\n  // The midpoints of the sides, named for opposites\n  vec3 A1 = normalize(0.5*(B+C));\n  vec3 B1 = normalize(0.5*(C+A));\n  vec3 C1 = normalize(0.5*(A+B));\n  m0 = mkmatrix(A,B);\n  m1 = mkmatrix(A,A1);\n  m2 = mkmatrix(C,C1);\n\n  float t = 0.1*iTime;\n  q0 = vec4(sin(t)*normalize(vec3(1,1,0)),cos(t));\n  q1 = vec4(sin(t)*normalize(-vec3(1,1,1)),cos(t));\n  q2 = vec4(sin(t)*normalize(vec3(0,1,1)),cos(t));\n  qbg = vec4(sin(t)*normalize(vec3(1,0,1)),cos(t));\n  qlight = vec4(sin(t)*normalize(vec3(0,1,0.5)),cos(t));\n}\n\nfloat de0(vec3 p, float k) {\n  p *= k;\n  p = abs(p); // Map to single face - skip this to see single face.\n  // Sort the coordinates to map to fundamental region.\n  if (p.x < p.y) p.xy = p.yx;\n  if (p.y < p.z) p.yz = p.zy;\n  if (p.x < p.y) p.xy = p.yx;\n\n  float d = 1e8;\n  d = min(d,ssegment(p,m0));\n  d = min(d,ssegment(p,m1));\n  d = min(d,ssegment(p,m2));\n  return d/k;\n}\n\n// Quaternion multiplication\nvec4 qmul(vec4 p, vec4 q) {\n  vec3 P = p.xyz, Q = q.xyz;\n  return vec4(p.w*Q+q.w*P+cross(P,Q),p.w*q.w-dot(P,Q));\n}\n\nvec4 qconj(vec4 p) {\n  return vec4(-p.xyz,p.w);\n}\n\n// Might be better to turn into a matrix.\nvec3 qrot(vec3 p, vec4 q) {\n  vec4 r = qmul(qconj(q),qmul(vec4(p,0),q));\n  return r.xyz;\n}\n\nfloat de(vec3 p) {\n  float d = 1e8;\n  float k = 1.2;\n  d = min(d,de0(qrot(p,q0),k));\n  d = min(d,de0(qrot(p,q1),1.0));\n  d = min(d,de0(qrot(p,q2),1.0/k));\n  return d;\n}\n\n// Get the normal of the surface at point p.\nvec3 getnormal(vec3 p) {\n  float eps = 0.001;\n  vec2 e = vec2(eps,0);\n  return normalize(vec3(de(p + e.xyy) - de(p - e.xyy),\n                        de(p + e.yxy) - de(p - e.yxy),\n                        de(p + e.yyx) - de(p - e.yyx)));\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\n// Rotate according to mouse position\nvec3 transformframe(vec3 p) {\n  if (iMouse.x > 0.0) {\n    // Full range of rotation across the screen.\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  // autorotation\n  if (dorotate) {\n    p.yz = rotate(p.yz,-iTime*0.125);\n    p.zx = rotate(p.zx,iTime*0.1);\n  }\n  return p;\n}\n\nvec3 getbasecolor(int type) {\n  return vec3(0.75,1,0.75);\n}\n\nvec3 getbackground(vec3 r) {\n  vec3 col = qrot(r,qbg);\n  col = abs(col);\n  col = pow(col,vec3(1.5));\n  return col; // Colourful fun\n  return vec3(0,0,0.1); // The more sober option.\n}\n\nfloat maxdist = 10.0;\nfloat march(vec3 q, vec3 r) {\n  float t = 0.0;\n  for (int i = 0; i < maxsteps; i++) {\n    vec3 p = q+t*r;\n    float d = de(p);\n    if (abs(d) < precis) return t; // Close enough to the surface.\n    t += d;\n    if (t > maxdist) break;\n  }\n  return -1.0;\n}\n\nvec3 raycolor(vec3 q, vec3 r) {\n  float t = march(q,r);\n  if (t < 0.0) return getbackground(r);\n  // Get the surface point that has been hit,\n  vec3 p = q+t*r;\n  // and the normal at that point.\n  vec3 normal = getnormal(p);\n  if (dot(normal,r) > 0.0) normal = vec3(0);\n  \n  // Apply lighting. This is a basic \"Lambertian\" model.\n  vec3 lightdir = normalize(light-p);\n  vec3 color = getbasecolor(0);\n  float ambient = 0.3;\n  float diffuse = 0.7*clamp(dot(normal,lightdir),0.0,1.0);\n  color *= ambient+ diffuse;\n  color = mix(color,getbackground(r),t/maxdist); // Fog\n  return color;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n  init();\n  maxdist = eyedist + 1.0;\n  vec3 eye = vec3(0,0,eyedist);\n  eye = transformframe(eye);\n  light = qrot(light,qlight);\n  light = transformframe(light);\n  vec3 col = vec3(0);\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 z = (2.0*(fragCoord+vec2(i,j)/float(AA))-iResolution.xy)/iResolution.y;\n      vec3 ray = vec3(z,-2);\n      ray = transformframe(ray);\n      ray = normalize(ray);\n      col += raycolor(eye,ray);\n    }\n  }\n  col /= float(AA*AA);\n  col = pow(col,vec3(0.4545)); // Gamma\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdByR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[750, 875, 907, 907, 1145], [1147, 1453, 1484, 1484, 1582], [1626, 1626, 1639, 1639, 2223], [2225, 2225, 2253, 2253, 2598], [2600, 2629, 2656, 2656, 2743], [2745, 2745, 2765, 2765, 2794], [2796, 2838, 2865, 2865, 2928], [2930, 2930, 2948, 2948, 3098], [3100, 3145, 3169, 3169, 3383], [3385, 3416, 3446, 3446, 3491], [3493, 3531, 3560, 3560, 3953], [3955, 3955, 3984, 3984, 4014], [4016, 4016, 4044, 4044, 4199], [4223, 4223, 4252, 4252, 4477], [4479, 4479, 4510, 4510, 5063], [5065, 5065, 5116, 5116, 5674]], "test": "untested"}
{"id": "tdScRc", "name": "Nayan Battle", "author": "wyatt", "description": "Nayans tripped too hard and now they are battling to be king of the galactic empire. ", "tags": ["graph"], "likes": 17, "viewed": 444, "published": 3, "date": "1587056947", "time_retrieved": "2024-07-30T21:12:21.903126", "image_code": "// Fork of \"Bouncing Julia\" by wyatt. https://shadertoy.com/view/tsScWw\n// 2020-04-15 18:21:55\n\n// Fork of \"Graph Network*\" by wyatt. https://shadertoy.com/view/wdjcDR\n// 2020-04-13 00:32:16\n\n// Fork of \"Graph Network\" by wyatt. https://shadertoy.com/view/tssyDS\n// 2020-04-09 20:04:37\n\nvec4 color (vec2 U, float q) {\n\nvec4 c = C(U), a = A(c.zw), cc = B(c.zw);\n    for (int x = -1; x<=1;x++)\n        for (int y = -1; y<=1;y++){\n        \tvec4 ccc = A(c.zw+O*vec2(x,y));\n            if (length(a.xy-A(ccc.xy).xy)<length(a.xy-A(cc.xy).xy))\n                cc=ccc;\n        }\n    vec4  b = A(cc.xy),\n         aa = (c.zwzw), bb = (cc.xyxy);\n    vec2 r = a.xy-b.xy, p = aa.xy-bb.xy;\n    float an = angle(r,p);\n    \n   \tvec2 u = U-a.xy;\n    vec4 t = B(c.zw+u);\n    t = A(t.xy);\n    float s = sg(U,a.xy,t.xy);\n    vec4 Q = D(aa.xy);\n    Q.x = floor(Q.w/1e4)/1e2;\n    Q.y = floor(mod(Q.w,1e4)/1e2)/1e2;\n    Q.z = floor(mod(Q.w,1e2))/1e2;\n    if (aa.x<0.5*R.x) Q = Q.xzyw;\n    u *= mat2(cos(an),sin(-an),sin(an),cos(an));\n    u = 2.*abs(u);\n    Q *= vec4(1)*smoothstep((1.+q)*O,(1.-q)*O,max(u.x,u.y));\n\treturn Q;\n}\n\nMain {\n    vec4 c1 = color(U,0.1), c2 = color(U+3.,.4), c3 = vec4(U/R*2.-3.,0,1);\n    for (int i = 0; i < 8; i++) {\n    \tc3.yz *= mat2(cos(.2*iTime),sin(-.2*iTime),sin(.2*iTime),cos(.2*iTime));\n        c3 = abs(c3/dot(c3.xyz,c3.xyz)-.2)-.2;\n        c3.zx *= mat2(cos(.9),sin(-.9),sin(.9),cos(.9));\n    \tc3=4.*sin(c3);\n    }\n    c3.xyz *= mat3(.6,.7,.7,.3,.6,.1,-.4,.9,.1);\n    Q = 0.15+0.85*c1+max(.1*c3-10.*length(c1),0.);\n    Q -= .1*length(c2)*max(1.-10.*c1,0.);\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 force (vec2 U, vec4 a, vec2 bb) {\n    vec4 b = A(bb);\n    if (b.x<5.&&b.y<5.||bb.x<5.||bb.y<5.) return vec2(0);\n    \n    vec2 r = b.xy-a.xy, v = b.zw-a.zw;\n    vec4 da = D(U), db = D(bb);\n\tvec2 q = da.xy-db.xy;\n    float l = length(r), j = length(q);\n    if (l < 1e-9) return vec2(0);\n    vec2 f = vec2(0);\n    if (l!=0.&&j!=0.){\n    if (sign(U.x-0.5*R.x)==sign(bb.x-0.5*R.x)&&(l-j)<O*3.)\n            f = r/l*(l-j)*exp(-0.01*j);\n    else f = -30.*smoothstep(1.5*O,0.5*O,l)*r/l;\n    }\n    return f;\n}\nMain {\n    vec2 u = shape(U);\n    Q = A(u);\n    if ((iFrame>100&&Q.x<1.&&Q.y<1.)||u.x+O>=R.x||u.y+O>=R.y||u.x<O||u.y<O||length(U-u)>1.) {Q=-1e8*R.xyxy;return;}\n    \n    vec2 f = vec2(0);\n    for (int x=-3;x<3; x++) {\n        for (int y=-3;y<3; y++) {\n            vec4 b = B(u+vec2(x,y));\n            f += (\n                force(U,Q,b.xy)+\n                force(U,Q,b.zw));\n        }\n\t}\n    for (int i=-10;i<=10;i++) {\n    \tf+=force(U,Q,U+3.*O*vec2(i,0));\n    \tf+=force(U,Q,U+3.*O*vec2(0,i));\n    }\n    f /= 100.;\n    Q.zw += f;\n    Q.xy += f+Q.zw*sqrt(7./(1.+dot(Q.zw,Q.zw)));\n    if (length(Q.zw)>3.)Q.zw = 3.*normalize(Q.zw);\n    if (iMouse.z>0.) Q.zw += 100.*(Q.xy-iMouse.xy)/dot(Q.xy-iMouse.xy,Q.xy-iMouse.xy);\n    \n    \tif (Q.x<5.) {Q.x=5.;Q.z = +abs(Q.z);}\n        if (R.x-Q.x<5.) {Q.x=R.x-5.;Q.z =-abs(Q.z);}\n        if (Q.y<5.) {Q.y=5.;Q.z=0.;Q.w = +abs(Q.w);}\n        if (R.y-Q.y<5.) {Q.y=R.y-5.;Q.w =-abs(Q.w);}\n\n    if (iFrame < 102) {\n    \tQ = vec4(D(U).xy,1.8,1.4);\n    }\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void X (inout vec4 Q, inout vec2 r, vec4 a, vec2 U, vec2 u, vec4 n) {\n\tfloat l = line(a.xy+U-u,a.xy,A(n.xy).xy),\n          ll = line(a.xy+U-u,a.xy,A(n.zw).xy);\n    if (l<r.x){\n        r = vec2(l,r.x);\n        Q=vec4(n.xy,Q.xy);\n    } else if (l<r.y) {\n    \tr.y = l;\n        Q.zw = n.xy;\n    }\n    if (ll<r.x){\n    \tr = vec2(ll,r.x);\n        Q=vec4(n.zw,Q.xy);\n    } else if (ll<r.y) {\n    \tr.y = ll;\n        Q.zw = n.zw;\n    }\n}\nMain {\n    vec2 u = shape(U);\n    vec4 a = A(u);\n\tQ = B(U);\n    vec2 r = vec2(line(a.xy+U-u,a.xy,A(Q.xy).xy)\n                 ,line(a.xy+U-u,a.xy,A(Q.zw).xy));\n    \n    \n    X(Q,r,a,U,u,B(U+vec2(1,1)));\n    X(Q,r,a,U,u,B(U+vec2(0,1)));\n    X(Q,r,a,U,u,B(U+vec2(1,0)));\n    X(Q,r,a,U,u,B(U-vec2(0,1)));\n    X(Q,r,a,U,u,B(U-vec2(1,0)));\n    X(Q,r,a,U,u,B(U+vec2(1,1)));\n    X(Q,r,a,U,u,B(U+vec2(1,-1)));\n    X(Q,r,a,U,u,B(U-vec2(1,1)));\n    X(Q,r,a,U,u,B(U-vec2(1,-1)));\n    \n    X(Q,r,a,U,u,B(Q.xy-U+u));\n    X(Q,r,a,U,u,B(Q.zw-U+u));\n    X(Q,r,a,U,u,B(Q.xy-U+u+vec2(0,1)));\n    X(Q,r,a,U,u,B(Q.xy-U+u+vec2(1,0)));\n    X(Q,r,a,U,u,B(Q.xy-U+u-vec2(0,1)));\n    X(Q,r,a,U,u,B(Q.xy-U+u-vec2(1,0)));\n    X(Q,r,a,U,u,B(Q.xy-U+u+vec2(1,1)));\n    X(Q,r,a,U,u,B(Q.xy-U+u+vec2(1,-1)));\n    X(Q,r,a,U,u,B(Q.xy-U+u-vec2(1,1)));\n    X(Q,r,a,U,u,B(Q.xy-U+u-vec2(1,-1)));\n    \n    X(Q,r,a,U,u,C(a.xy+2.*vec2(O,0)).zwxy);\n    X(Q,r,a,U,u,C(a.xy+2.*vec2(0,O)).zwxy);\n    X(Q,r,a,U,u,C(a.xy-2.*vec2(O,0)).zwxy);\n    X(Q,r,a,U,u,C(a.xy-2.*vec2(0,O)).zwxy);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\nvoid Y (inout vec4 Q, vec2 U, vec4 n) {\n\tfloat l = length(U-A(n.xy).xy),//sg(U,A(n.xy).xy,A(n.zw).xy),\n          ll = length(U-A(Q.xy).xy);//sg(U,A(Q.xy).xy,A(Q.zw).xy);\n    if (l<ll) Q.xy = n.xy;\n}\nvoid X (inout vec4 Q, vec2 U, vec4 n) {\n\tfloat l = length(U-A(n.zw).xy),//sg(U,A(n.xy).xy,A(n.zw).xy),\n          ll = length(U-A(Q.zw).xy);//sg(U,A(Q.xy).xy,A(Q.zw).xy);\n    if (l<ll) Q.zw = n.zw;\n}\nMain {\n\tQ = C(U).xyxy;\n    if (iFrame%N==0) Q.xy = U;\n    else {\n        float k = exp2(float(N-1-(iFrame%N)));\n    \tY(Q,U,C(U+vec2(0,k)));\n    \tY(Q,U,C(U+vec2(k,0)));\n    \tY(Q,U,C(U-vec2(0,k)));\n    \tY(Q,U,C(U-vec2(k,0)));\n    }\n\n\tX(Q,U,C(U+vec2(0,1)));\n    X(Q,U,C(U+vec2(1,0)));\n    X(Q,U,C(U-vec2(0,1)));\n    X(Q,U,C(U-vec2(1,0)));\n    \n    X(Q,U,C(U+vec2(3,3)));\n    X(Q,U,C(U+vec2(3,-3)));\n    X(Q,U,C(U-vec2(3,3)));\n    X(Q,U,C(U-vec2(3,-3)));\n    \n    X(Q,U,C(U+vec2(0,4)));\n    X(Q,U,C(U+vec2(4,0)));\n    X(Q,U,C(U-vec2(0,4)));\n    X(Q,U,C(U-vec2(4,0)));\n    \n    X(Q,U,C(U));\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n\tQ.xy = shape(U);\n    //Q.x += 0.5*O*mod(Q.y/O,2.);\n    vec4 nana = texture(iChannel0,Q.xy/R*vec2(.3,1.)-vec2(.38,-.1));\n    Q.z=nana.w;\n    if (Q.z<1e-4) Q.xy = -1e9*R;\n    Q.xy*=0.7;\n    Q.w = floor(nana.x*1e2)*1e4+floor(nana.y*1e2)*1e2+floor(nana.z*1e2);\n}", "buffer_d_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texelFetch(iChannel1,ivec2(U),0)\n#define C(U) texelFetch(iChannel2,ivec2(U),0)\n#define D(U) texelFetch(iChannel3,ivec2(U),0)\n#define Main void mainImage (out vec4 Q, vec2 U) \n#define Init if (iFrame < 1) \n#define Border if (U.x<1.||R.x-U.x<1.||U.y<1.||R.y-U.y<1.)\n#define O 6.\n#define shape(U) (round((U)/O)*O)\n#define N 12\n#define Z vec2(u)\nfloat angle (vec2 a, vec2 b) {\n\treturn atan(a.x*b.y-a.y*b.x,dot(a.xy,b.xy));\n}\nfloat sg (vec2 p, vec2 a, vec2 b) {\n    if (length(a-b)<1e-4||length(a)<1e-4||length(b)<1e-4) return 1e9;\n    \n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\tfloat l = (length(p-a-(b-a)*i));\n    return l;\n}\n\nfloat pie (vec2 p, vec2 a, vec2 b) {\n\tvec2 m = 0.5*(a+b); // midpoint\n    if (length(a-b)<1e-3) return 1e3; // ignore self\n\treturn abs(dot(p-m,b-m)/dot(b-m,b-m)); // pojection\n} \nfloat line (vec2 p, vec2 a, vec2 b) {\n    if (length(a-b)<1.||length(a)<1.||length(b)<1.) return 1e9;\n    \n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\tfloat l = (length(p-a-(b-a)*i));\n    l=(.1+l)*(pie(p,a,b));\n    return l;\n}", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdScRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[287, 287, 317, 317, 1103]], "test": "untested"}
{"id": "3lyGRt", "name": "Dem renderer", "author": "iapafoto", "description": "A way to render planets from dem texture (exemples in comment)\n\n   Earth:       https://www.ngdc.noaa.gov/mgg/global/\n   Planets:    https://astrogeology.usgs.gov/tools/map-a-planet-2", "tags": ["water", "planet", "ground"], "likes": 65, "viewed": 1344, "published": 3, "date": "1587048604", "time_retrieved": "2024-07-30T21:12:23.000193", "image_code": "// Created by sebastien durand - 04/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-------------------------------------------------------\n\n// Relief (low = big!) values : [2..20]\n#define H_COEFF 5.\n\n// With / Without water \n#define WITH_WATER\n\n#define WATER_OPACITY_COEFF 2.5\n#define WATER_OPACITY_INIT 1.\n\n#define WITH_MOUSE_CONTROL \n\n#define WITH_SHADOWS\n#define WITH_AO  // Good with a lot of rays but need multi pass\n#define NB_AO  4 // Reduce if slow\n\n\n// -------------------------------\n// DO NOT CHANGE\n// -------------------------------\n\n\n#define PI 3.14159265359\n\n#define NO_ID 0\n#define GROUND_ID 1\n#define DEEP_ID 2\n\n#define NO_INTERSECTION 9999.\n\n\n#define COLOR_BACK vec3(.42,.46,.48)\n#define COLOR_WATER vec3(.3, .12, .08) \n \nconst float dd = .02;     // ray step \n\n// ------------------------------------------------------------------------------\n\nint intersectSphere(vec3 ro, vec3 rd, float r, out float t1, out float t2) {\n    float b = dot(ro,rd), d = b*b - dot(ro,ro) + r*r;\n    if (d <= 0.) return -1;\n    t1 = -b-sqrt(d);\n    t2 = -2.*b-t1;\n    return t1 > 0. ? 1 : t2 > 0. ? 2 : 0;\n}\n\nvec3 toSpherical(vec3 p) {\n    float r = length(p);\n    return vec3(asin(p.z/r),               // lat\n                atan(p.y, p.x)+PI,         // lon\n                H_COEFF*(r-1.)); // alti (meters data)\n}\n\n// -------------------------------------------------------------------\n\nfloat hash1( float seed) {\n    return fract(sin(seed)*43758.545312);\n}\n\nvec2 hash2( float seed) {\n    return fract(sin(vec2(seed*43758.545312,(seed+.1)*22578.145912)));\n}\n\nfloat hash( const in vec3 p ) {\n    return fract(sin(dot(p,vec3(127.1,311.7,758.5453123)))*43758.5453123);\n}\n\n\nvec4 Loadv4 (int idVar)\n{\n  float fi = float (idVar);\n  return texture (iChannel0, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     iChannelResolution[0].xy);\n}\n\n// ------------------------------------------------------------------\n\nfloat altitudeMeter(vec3 p) {\n    vec3 s = toSpherical(p);\n    vec2 p2 = s.yx/PI;  // Lon, Lat, H in Grib\n    \n    // replace with your dem texture in EPSG:4326 projection\n    // ---------------------------------------------------\n    p2.y += 1.;\n    float h1 = (.9*texture(iChannel2, .5*p2).x + .5*texture(iChannel2, p2).x - .37 - mix(.5*texture(iChannel2, 4.*p2).x, .2, abs(p.z+p.x)));\n   \n    p.xyz = p.zxy;\n    s = toSpherical(p);\n    p2 = s.yx/PI;  // Lon, Lat, H in Grib\n    p2.y += 1.;\n  \n\tfloat h2 = (.9*texture(iChannel2, .5*p2).x + /*.5*texture(iChannel2, p2).x */-.2 - mix(.5*texture(iChannel2, 4.*p2).x, .2, abs(p.z+p.x)));\n    return 100.*mix(h1,h2, smoothstep(0.,1.,abs(p.x)));\n    // ---------------------------------------------------\n}\n\nfloat altitude(vec3 p) {\n    return H_COEFF*(length(p)-1.)-altitudeMeter(p)/100.;\n}\n\nvec3 normalAt( vec3 p) {\n    vec3 e = vec3 (.001, -.001, 0); \n    return normalize(e.xyy * altitude(p + e.xyy)\n                   + e.yyx * altitude(p + e.yyx)\n                   + e.yxy * altitude(p + e.yxy)\n                   + e.xxx * altitude(p + e.xxx));\n}\n\n// bisect\nfloat preciseSurfaceGround( vec3 ro,  vec3 rd, float dmin, float dmax) {\n    float dm = dmin;\n    vec3 p; \n    for (int j=0; j<6;j++) {\n        dm = (dmin + dmax)*.5;  \n        p = ro+rd*dm;\n        if (altitude(p) < 0.) dmax = dm;  \n        else dmin = dm;\n    }\n    return dm;  \n}\n\nvec2 rayGround(vec3 ro,  vec3 rd,  float dmin,  float dmax, out vec3 out_n, out float out_val) {\n    \n    float t1, t2;\n    // Test bounding sphere\n    int type = intersectSphere(ro, rd, .5/H_COEFF+1., t1, t2);\n    if (type > 0) {\n        dmin = max(dmin,t1);\n        dmax = min(dmax,t2);\n\n        // Go step by step until the ray traverse the ground\n        float d, h, rand = dd*hash1(dot(ro+rd*dmin,vec3(127.1,311.7,758.5453123)));\n        for(d = dmin+rand; d<dmax+dd; d += dd) {\n            h = altitude(ro+rd*d);\n            if (h <= 0.) break;\n        }\n\n        // Precise the true intersection point\n        if (d <= dmax) {\n            d = preciseSurfaceGround(ro, rd, max(dmin, d-dd), min(d,dmax));\n            out_n = normalAt(ro+rd*d);\t\t\t\t\n            out_val = altitude(ro+rd*d);\n            return vec2(d, GROUND_ID);\n        }\n    }\n\treturn vec2(NO_INTERSECTION, NO_ID);\n}\n\n\n#ifdef WITH_SHADOWS\nfloat doShadow( vec3 ro,  vec3 rd,  float dMax) {\n    vec3 n;\n    float val, dMin = dd*.1;\n    vec2 res = rayGround(ro, rd, dMin, dMax, n, val);\n    return res.x>dMin && res.x <= dMax ? 1. - clamp((dMax-res.x)/dMax,0.,1.) : 1.;\n}\n#endif\n\n\n#ifdef WITH_AO\nvec3 randomHemisphereDirection(vec3 n,  float seed) {\n    vec2 r = 2.*PI*hash2(seed);\n    vec3 dr = vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));\n    float k = dot(dr,n);\n    return k == 0. ? n : normalize(k*dr);\n}\n\nfloat doAmbiantOcclusion( vec3 ro,  vec3 n, float dMax) {\n    float val, ao = 0., seed = ro.x+ro.y+.12345*ro.z;\n    vec3 n2, rd;\n    vec2 res;\n    for (int i=0;i<NB_AO; i++){\n        rd = randomHemisphereDirection(n, seed);    \n        seed += .1;\n        res = rayGround(ro, rd, .03*dd, 1., n2, val);\n        if (int(res.y) != NO_ID && res.x > 0. && res.x < dMax) {\n            ao += clamp((dMax-res.x)/dMax,0.,1.);\n        }\n    }\n    return (1.-ao/float(NB_AO));\n}\n#endif\n\n\n// -----------------------------------------------------------------\n\n// Shading\nvec3 doShading(int id, vec3 rd, vec3 p, vec3 n, vec3 light,  vec3 col) { \n    float diffuse = max(0., dot(n, light)),\n          rimMatch =  1. - max( 0. , dot( n , -rd ) );\n    vec3 rimCol  = vec3 (.4,.6,1.)*rimMatch;\n\n    float occ = 1.;\n#ifdef WITH_AO\n    occ = doAmbiantOcclusion(p+n*.001/*.01*rd*dd*/, n, .08);\n#endif\n     \n    vec3 hal = normalize( light-rd );\n\tfloat \n        amb = clamp( .5, 0., 1. ),\n     \tdif = clamp( dot( n, light ), 0., 1. ),\n     \tbac = clamp( dot( n,-light), 0., 1. ),\n     \tfre = pow( clamp(1.0+dot(n,rd),0.,1.), 2. );\n        \n#ifdef WITH_SHADOWS\n    if (dif >0.) {\n        dif *= (doShadow(p-.2*rd*dd, light, .6));  \n    }\n#endif\n\n\tvec3 lin = vec3 (0.);\n    lin += .7*dif*vec3 (1.,.8,.55);\n    lin += .4*amb*vec3 (.4,.6,1.)*occ;\n    lin += .5*bac*vec3 (.25)*occ;\n    lin += .25*fre*vec3 (1)*occ;\n\n    float spe = max(0., dot(light, reflect(rd, n)));\n    spe = dif*pow(spe,29.);;              \n\n\tvec3 c = col*lin;\n\tc += (id==GROUND_ID?.1f:.5f)*spe;\n    c+= .2f * rimCol * occ;\n\n    return pow(c,vec3(.55f)); \t   \n}\n\n\n// Camera\nvec3 RD( vec3 ro, vec3 ta, vec3 up, vec2 uv, vec2 res, float h) {\n    vec2 p = (2.*uv-res)/res.y;\n    vec3 \n        w = normalize(ta - ro),\n        u = normalize(cross(w, up)),\n        v = normalize(cross(u,w));\n    return normalize( p.x*u + p.y*v + h*w );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 uv ) {\n    // Background\n    vec2 q = uv/iResolution.xy;\n    vec3 col = COLOR_BACK * pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y),.3f)\n    \t\t + .05*hash(vec3(q,1.));\n\n    // Camera\n#ifdef WITH_MOUSE_CONTROL\n    vec4 qtVu = Loadv4(1);\n    mat3 vuMat = QToRMat(qtVu);\n    vec3 rd = normalize (vec3((2.*uv-iResolution.xy)/iResolution.y, 3.5)) * vuMat,\n    \t ro = vec3 (0., 0., -4.5) * vuMat;\n#else\n\tvec3 ro = 4.5*normalize(vec3(cos(.5*iTime), sin(.5*iTime), .1*cos(.15*iTime))),\t\n         rd = RD(ro, vec3(0), vec3(1), uv, iResolution.xy, 3.5);\n#endif\n    // Light\n    vec3 n,p, lightDir = normalize(ro+vec3(0,10,10));\n\n    // Find intersection\n\tfloat val, tmax = 5.f;\n    vec2 res = rayGround(ro, rd, 0., tmax, n, val);\n\n    // Shading\n    if (res.x > 0. && res.x < NO_INTERSECTION) {\n       \n        if (int(res.y) == GROUND_ID) {\n            p = ro + res.x*rd;\n\t\t\tfloat h = altitudeMeter(p);\n \n            col = mix(.2*vec3(.6,.5,.4), texture(iChannel1, vec2(h/50.,.5)).xyz, .7);\n            col *= .8 +.3*hash(p); // a little bit dirty\n            col = pow(col, vec3(.7));\n\t\t\t\n#ifdef WITH_WATER\n            vec3 colw = texture(iChannel1, vec2(0)).xyz; \n            colw = colw*.25 + .75*exp(-COLOR_WATER*(-h*.002)); \n            col = mix(colw,col, smoothstep(-0.1,0.1,h));\n#endif\n            col = doShading(int(res.y), rd, p, n, lightDir, col);\n        }\n    }\n    \n#ifdef WITH_WATER\n\t// Add water effect\n\tfloat dminSea, dmaxSea;\n    if (intersectSphere(ro, rd, 1., dminSea, dmaxSea)>0) {\n        if (dminSea <= res.x) {\n            p = ro+rd*dminSea;\n            float dist = min(res.x,dmaxSea) - dminSea;\n            col = col * exp(-COLOR_WATER*(WATER_OPACITY_INIT + 20.*WATER_OPACITY_COEFF*dist));\n            n = normalize(p);\n            float specular = max(0., dot(lightDir, reflect(rd, n)));\n            specular = pow(specular,29.);\n            col += .4*specular;\n        }\n    }\n#endif\n\n    fragColor = vec4(col, 1.);\n}\n\n\n\n", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Mouse control\n//----------------------------------------------\n\nconst float pi = 3.14159;\n\n\nvec4 Loadv4 (int idVar)\n{\n  float fi = float (idVar);\n  return texture (iChannel0, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     iChannelResolution[0].xy);\n}\n/*\nvec4 QtMul(vec4 q1, vec4 q2) {\n    return vec4(cross(q1.xyz,q2.xyz) + q1.w*q2.xyz + q2.w*q1.xyz, q1.w*q2.w - dot(q1.xyz,q2.xyz));\n}\n*/\n\nvec4 QMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n     q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n     q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n   - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n   - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\n\nvec4 EulToQ (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\n\nvec4 qtVu;\n\n\nvec3 VInit (int n)\n{\n  float fn;\n  fn = float (n);\n  return 2. * normalize (vec3 (Hashff (fn), Hashff (fn + 0.3),\n     Hashff(fn + 0.6)) - 0.5);\n}\n\nvoid OrientVu (inout vec4 qtVu, vec4 mPtr, inout vec4 mPtrP, bool init)\n{\n  vec3 vq1, vq2;\n  vec2 dm;\n  float mFac;\n    \n  if (! init) {\n    qtVu = vec4 (0., 0., 0., 1.);\n    mPtrP = vec4 (99.,0., -1., 0.);\n      \n  } else {\n      \n    if (mPtr.z > 0.) {\n      if (mPtrP.x == 99.) mPtrP = mPtr;\n      mFac = 1.5;\n      dm = - mFac * mPtrP.xy;\n      vq1 = vec3 (dm, sqrt (max (1. - dot (dm, dm), 0.)));\n      dm = - mFac * mPtr.xy;\n      vq2 = vec3 (dm, sqrt (max (1. - dot (dm, dm), 0.)));\n      qtVu = normalize(QMul(vec4(cross (vq1, vq2), dot (vq1, vq2)), qtVu));\n      mPtrP = mPtr;\n    } else {\n        mPtrP = vec4 (99., 0., -1., 0.);\n    }\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat;\n  float tCur;\n  int pxId = int(fragCoord.x);\n \n  if (pxId > 2) discard;\n    \n  tCur = 5.*(1.+.5*sin(.5*iTime))+2.*iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n    \n  qtVu = Loadv4 (1);\n  mPtrP = Loadv4 (2);\n  \n  if (iFrame < 10) {\n    OrientVu(qtVu, mPtr, mPtrP, false);\n   \n  } else {\n      \n    OrientVu (qtVu, mPtr, mPtrP, true);\n    stDat = Loadv4(0);\n    ++stDat.x;\n      \n    if (mPtrP.z < 0.) \n        qtVu = normalize(QMul (EulToQ (0.2 * (tCur - stDat.z) * pi * vec3 (-0.27, -0.34, -0.11)), qtVu));\n      \n    stDat.z = tCur;\n  }\n\n  if (pxId == 1) stDat = qtVu;\n  else if (pxId == 2) stDat = mPtrP;\n        \n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nconst float txRow = 64.;\n\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi = float (idVar);\n  vec2 d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n\n\nmat3 QToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyGRt.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[910, 910, 986, 986, 1152], [1154, 1154, 1180, 1180, 1362], [1436, 1436, 1462, 1462, 1506], [1508, 1508, 1533, 1533, 1606], [1719, 1719, 1744, 1744, 1888], [1961, 1961, 1990, 1990, 2713], [2715, 2715, 2739, 2739, 2798], [2800, 2800, 2824, 2824, 3061], [3063, 3073, 3145, 3145, 3355], [3357, 3357, 3453, 3453, 4245], [5288, 5299, 5371, 5371, 6346], [6349, 6359, 6424, 6424, 6617], [6619, 6619, 6669, 6687, 8587]], "test": "untested"}
{"id": "tsSyR3", "name": "Webcam glow #2", "author": "rasmuskaae", "description": "Simple hollywood glow", "tags": ["glow", "webcam"], "likes": 3, "viewed": 675, "published": 3, "date": "1587043738", "time_retrieved": "2024-07-30T21:12:23.850918", "image_code": "float glow_radius = 0.2;\nfloat glow_intens = 0.00125;\nfloat glow_blur_step = 0.05;\nfloat glow_num_steps = 1.0; // 1.0 is hollywood glow :)\n\nfloat fixcolor(float x) {\n    return 1.0-round(x*glow_num_steps)/glow_num_steps;\n}\n\nfloat getcolor(vec2 uv) {\n    vec4 c = texture(iChannel0, uv);\n    return max(fixcolor(c.r),max(fixcolor(c.g),fixcolor(c.b)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 c = texture(iChannel0, uv);\n\n    \n\tfloat d = 0.0;    \n    for (float x=0.0; x<1.0; x+=glow_blur_step) \n        for (float y=0.0; y<1.0; y+=glow_blur_step) {\n            d += getcolor(uv+glow_radius*vec2(x-0.5, y-0.5));\n        }\n    \n    \n    d *= glow_intens;\n    \n    fragColor = vec4(d,d,d,d)+c;\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsSyR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 140, 165, 165, 222], [224, 224, 249, 249, 352], [354, 354, 411, 411, 761]], "test": "untested"}
{"id": "WsBczc", "name": "Circle section", "author": "sixclones", "description": "Quick explanation.", "tags": ["2d", "circle"], "likes": 3, "viewed": 187, "published": 3, "date": "1587043081", "time_retrieved": "2024-07-30T21:12:24.613879", "image_code": "// CONSTANTS & UTILS\n#define QP 0.785398163397448\n#define HP 1.570796326794897\n#define P 3.141592653589793\n#define TP 6.283185307179586\n\n#define t iTime\n#define ht 0.5 * t\n#define tt 0.1 * t\n\n\n// UTILS FN\n/* map a value `n` from a range `start1` -> `stop1` to a range `start2` -> `stop2` */\nfloat map(float n, float start1, float stop1, float start2, float stop2) {\n  \treturn (n - start1) / (stop1 - start1) * (stop2 - start2) + start2;\n}\n\n/* map a value `n` from the range -1.0 -> 1.0 to a range `start2` -> `stop2`\nto be used with cos/sin\n`map01(sin(x), 0.0, 1.0)`\n*/\nfloat map01(float n, float start2, float stop2) {\n  \treturn (0.5 * n + 0.5) * (stop2 - start2) + start2;\n}\n\n\n// MAIN\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  \tvec2 uv = fragCoord.xy / iResolution.xy;\n  \tvec2 uv0 = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n  \n  \tvec3 color = vec3(0.0);\n    vec3 palette = vec3(1.0, 1.0, 0.0);\n\t\n    // compute the angle from the center of the screen and the current pixel\n    float angle = atan(uv0.y, uv0.x);\n    // `atan` returns values from {-PI -> PI}, the mapping is just for conveniance\n    angle = map(angle, -P, P, 0.0, 1.0);\n    // define the section of the circle that is displayed\n    float section = map01(sin(t), 0.0, 0.125); \n    // section = 0.125;\n    \n    // signed distance field of a circle\n    float circSDF = length(uv0.xy);\n    // compute the circle drawing\n    float circ = 1.0 - step(0.5, circSDF);\n    \n    // cooking everything together and tadaa!\n    color += step(section, angle) * circ;\n    // pacman\n    color *= palette;\n    \n  \tfragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBczc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[193, 291, 365, 365, 438], [440, 570, 619, 619, 676], [679, 687, 742, 742, 1624]], "test": "untested"}
{"id": "tsScRK", "name": "another synthwave sunset thing", "author": "stduhpf", "description": "I was thinking of a way to make pseudo tesselation noise and i made this to illustrate it, i might not be the first one to come up with this solution.\n\nNow as a music visualizer! (channel 0, remove line 11)", "tags": ["raymarching", "sunset", "tesselation", "synthwave", "cineshader"], "likes": 198, "viewed": 246278, "published": 3, "date": "1587042330", "time_retrieved": "2024-07-30T21:12:25.397784", "image_code": "//#define AA 2\n//#define VAPORWAVE\n//#define stereo 1. // -1. for cross-eyed (defaults to parallel view)\n#define speed 10. \n#define wave_thing\n//#define city\n\n//you can add any sound texture in iChannel0 to turn it into a cool audio visualizer \n// (it looks better with lower speeds though)\n//you should commment out or remove the following line to enable it (it's disabled mainly for performance reasons):\n#define disable_sound_texture_sampling\n\n#ifndef disable_sound_texture_sampling\n    #undef speed \n    // lower value of speed when using as audio visualizer\n    #define speed 5.\n#endif\n\n//self-explainatory\n#define audio_vibration_amplitude .125\n\nfloat jTime;\n\n\n#ifdef disable_sound_texture_sampling\n#define textureMirror(a, b) vec4(0)\n#else\nvec4 textureMirror(sampler2D tex, vec2 c){\n    vec2 cf = fract(c);\n    return texture(tex,mix(cf,1.-cf,mod(floor(c),2.)));\n}\n#endif\n\n\nfloat amp(vec2 p){\n    return smoothstep(1.,8.,abs(p.x));   \n}\n\nfloat pow512(float a){\n    a*=a;//^2\n    a*=a;//^4\n    a*=a;//^8\n    a*=a;//^16\n    a*=a;//^32\n    a*=a;//^64\n    a*=a;//^128\n    a*=a;//^256\n    return a*a;\n}\nfloat pow1d5(float a){\n    return a*sqrt(a);\n}\nfloat hash21(vec2 co){\n    return fract(sin(dot(co.xy,vec2(1.9898,7.233)))*45758.5433);\n}\nfloat hash(vec2 uv){\n    float a = amp(uv);\n    #ifdef wave_thing\n    float w = a>0.?(1.-.4*pow512(.51+.49*sin((.02*(uv.y+.5*uv.x)-jTime)*2.))):0.;\n    #else\n    float w=1.;\n    #endif\n    return (a>0.?\n        a*pow1d5(\n        //texture(iChannel0,uv/iChannelResolution[0].xy).r\n        hash21(uv)\n        )*w\n        :0.)-(textureMirror(iChannel0,vec2((uv.x*29.+uv.y)*.03125,1.)).x)*audio_vibration_amplitude;\n}\n\nfloat edgeMin(float dx,vec2 da, vec2 db,vec2 uv){\n    uv.x+=5.;\n    vec3 c = fract((round(vec3(uv,uv.x+uv.y)))*(vec3(0,1,2)+0.61803398875));\n    float a1 = textureMirror(iChannel0,vec2(c.y,0.)).x>.6?.15:1.;\n    float a2 = textureMirror(iChannel0,vec2(c.x,0.)).x>.6?.15:1.;\n    float a3 = textureMirror(iChannel0,vec2(c.z,0.)).x>.6?.15:1.;\n\n    return min(min((1.-dx)*db.y*a3,da.x*a2),da.y*a1);\n}\n\nvec2 trinoise(vec2 uv){\n    const float sq = sqrt(3./2.);\n    uv.x *= sq;\n    uv.y -= .5*uv.x;\n    vec2 d = fract(uv);\n    uv -= d;\n\n    bool c = dot(d,vec2(1))>1.;\n\n    vec2 dd = 1.-d;\n    vec2 da = c?dd:d,db = c?d:dd;\n    \n    float nn = hash(uv+float(c));\n    float n2 = hash(uv+vec2(1,0));\n    float n3 = hash(uv+vec2(0,1));\n\n    \n    float nmid = mix(n2,n3,d.y);\n    float ns = mix(nn,c?n2:n3,da.y);\n    float dx = da.x/db.y;\n    return vec2(mix(ns,nmid,dx),edgeMin(dx,da, db,uv+d));\n}\n\n\nvec2 map(vec3 p){\n    vec2 n = trinoise(p.xz);\n    return vec2(p.y-2.*n.x,n.y);\n}\n\nvec3 grad(vec3 p){\n    const vec2 e = vec2(.005,0);\n    float a =map(p).x;\n    return vec3(map(p+e.xyy).x-a\n                ,map(p+e.yxy).x-a\n                ,map(p+e.yyx).x-a)/e.x;\n}\n\nvec2 intersect(vec3 ro,vec3 rd){\n    float d =0.,h=0.;\n    for(int i = 0;i<500;i++){ //look nice with 50 iterations\n        vec3 p = ro+d*rd;\n        vec2 s = map(p);\n        h = s.x;\n        d+= h*.5;\n        if(abs(h)<.003*d)\n            return vec2(d,s.y);\n        if(d>150.|| p.y>2.) break;\n    }\n    \n    return vec2(-1);\n}\n\n\nvoid addsun(vec3 rd,vec3 ld,inout vec3 col){\n    \n\tfloat sun = smoothstep(.21,.2,distance(rd,ld));\n    \n    if(sun>0.){\n        float yd = (rd.y-ld.y);\n\n        float a =sin(3.1*exp(-(yd)*14.)); \n\n        sun*=smoothstep(-.8,0.,a);\n\n        col = mix(col,vec3(1.,.8,.4)*.75,sun);\n    }\n}\n\n\nfloat starnoise(vec3 rd){\n    float c = 0.;\n    vec3 p = normalize(rd)*300.;\n\tfor (float i=0.;i<4.;i++)\n    {\n        vec3 q = fract(p)-.5;\n        vec3 id = floor(p);\n        float c2 = smoothstep(.5,0.,length(q));\n        c2 *= step(hash21(id.xz/id.y),.06-i*i*0.005);\n        c += c2;\n        p = p*.6+.5*p*mat3(3./5.,0,4./5.,0,1,0,-4./5.,0,3./5.);\n    }\n    c*=c;\n    float g = dot(sin(rd*10.512),cos(rd.yzx*10.512));\n    c*=smoothstep(-3.14,-.9,g)*.5+.5*smoothstep(-.3,1.,g);\n    return c*c;\n}\n\nvec3 gsky(vec3 rd,vec3 ld,bool mask){\n    float haze = exp2(-5.*(abs(rd.y)-.2*dot(rd,ld)));\n    \n\n    //float st = mask?pow512(texture(iChannel0,(rd.xy+vec2(300.1,100)*rd.z)*10.).r)*(1.-min(haze,1.)):0.;\n    //float st = mask?pow512(hash21((rd.xy+vec2(300.1,100)*rd.z)*10.))*(1.-min(haze,1.)):0.;\n    float st = mask?(starnoise(rd))*(1.-min(haze,1.)):0.;\n    vec3 back = vec3(.4,.1,.7)*(1.-.5*textureMirror(iChannel0,vec2(.5+.05*rd.x/rd.y,0.)).x\n    *exp2(-.1*abs(length(rd.xz)/rd.y))\n    *max(sign(rd.y),0.));\n    #ifdef city\n    float x = round(rd.x*30.);\n    float h = hash21(vec2(x-166.));\n    bool building = (h*h*.125*exp2(-x*x*x*x*.0025)>rd.y);\n    if(mask && building)\n        back*=0.,haze=.8, mask=mask && !building;\n    #endif\n    vec3 col=clamp(mix(back,vec3(.7,.1,.4),haze)+st,0.,1.);\n    if(mask)addsun(rd,ld,col);\n    return col;  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=vec4(0);\n    #ifdef AA\n    for(float x = 0.;x<1.;x+=1./float(AA)){\n    for(float y = 0.;y<1.;y+=1./float(AA)){\n    #else\n        const float AA=1.,x=0.,y=0.;\n    #endif\n    vec2 uv = (2.*(fragCoord+vec2(x,y))-iResolution.xy)/iResolution.y;\n    \n    const float shutter_speed = .25; // for motion blur\n\t//float dt = fract(texture(iChannel0,float(AA)*(fragCoord+vec2(x,y))/iChannelResolution[0].xy).r+iTime)*shutter_speed;\n    float dt = fract(hash21(float(AA)*(fragCoord+vec2(x,y)))+iTime)*shutter_speed;\n    jTime = mod(iTime-dt*iTimeDelta,4000.);\n    vec3 ro = vec3(0.,1,(-20000.+jTime*speed));\n    \n        #ifdef stereo\n            ro+=stereo*vec3(.2*(float(uv.x>0.)-.5),0.,0.); \n            const float de = .9;\n            uv.x=uv.x+.5*(uv.x>0.?-de:de);\n            uv*=2.;\n\t\t#endif\n        \n    vec3 rd = normalize(vec3(uv,4./3.));//vec3(uv,sqrt(1.-dot(uv,uv)));\n    \n    vec2 i = intersect(ro,rd);\n    float d = i.x;\n    \n    vec3 ld = normalize(vec3(0,.125+.05*sin(.1*jTime),1));\n\n    vec3 fog = d>0.?exp2(-d*vec3(.14,.1,.28)):vec3(0.);\n    vec3 sky = gsky(rd,ld,d<0.);\n    \n    vec3 p = ro+d*rd;\n    vec3 n = normalize(grad(p));\n    \n    float diff = dot(n,ld)+.1*n.y;\n    vec3 col = vec3(.1,.11,.18)*diff;\n    \n    vec3 rfd = reflect(rd,n); \n    vec3 rfcol = gsky(rfd,ld,true);\n    \n    col = mix(col,rfcol,.05+.95*pow(max(1.+dot(rd,n),0.),5.));\n    #ifdef VAPORWAVE\n    col = mix(col,vec3(.4,.5,1.),smoothstep(.05,.0,i.y));\n    col = mix(sky,col,fog);\n    col = sqrt(col);\n    #else\n    col = mix(col,vec3(.8,.1,.92),smoothstep(.05,.0,i.y));\n    col = mix(sky,col,fog);\n    //no gamma for that old cg look\n    #endif\n    if(d<0.)\n        d=1e6;\n    d=min(d,10.);\n    fragColor += vec4(clamp(col,0.,1.),d<0.?0.:.1+exp2(-d));\n     #ifdef AA\n    }\n    }\n    fragColor/=float(AA*AA);\n    #endif\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"another synthwave sunset thing\",\n\t\"description\": \"I was thinking of a way to make pseudo tesselation noise and i made this to illustrate it, i might not be the first one to come up with this solution.\",\n\t\"model\": \"car\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsScRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[881, 881, 899, 899, 943], [945, 945, 967, 967, 1104], [1105, 1105, 1127, 1127, 1151], [1152, 1152, 1174, 1174, 1241], [1242, 1242, 1262, 1262, 1655], [1657, 1657, 1706, 1706, 2052], [2054, 2054, 2077, 2077, 2544], [2547, 2547, 2564, 2564, 2628], [2630, 2630, 2648, 2648, 2813], [2815, 2815, 2847, 2847, 3143], [3146, 3146, 3190, 3190, 3433], [3436, 3436, 3461, 3461, 3933], [3935, 3935, 3972, 3972, 4783]], "test": "untested"}
{"id": "WdBczc", "name": "Webcam distort #1", "author": "rasmuskaae", "description": "very simple web cam distort", "tags": ["simple", "distort", "webcam"], "likes": 3, "viewed": 484, "published": 3, "date": "1587041541", "time_retrieved": "2024-07-30T21:12:26.348241", "image_code": "vec4 distortp(vec2 uv, float add) {\n    \n    float dist = (0.01+0.01*sin(round(iTime)+add))*sin(add+iTime+round((-0.5+uv.y)*(45.0+30.0*sin(-0.25+uv.y+iTime*0.1))));\n    uv.x += dist;\n    return texture( iChannel0, uv ) * (1.0+dist*10.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 c = vec2(uv.x-0.5, uv.y-0.5);\n    \n    float d = sqrt(c.x*c.x+c.y*c.y); d*=d*d*d;\n    \n    \n    \n    fragColor = distortp(vec2(uv.x,uv.y),0.0)*(1.5-10.0*d);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdBczc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 239], [241, 241, 298, 298, 506]], "test": "untested"}
{"id": "WdByzc", "name": "Mandelbrot on sphere", "author": "elle", "description": "mandelbrot on sphere", "tags": ["fractal", "mandelbrot"], "likes": 3, "viewed": 315, "published": 3, "date": "1587038656", "time_retrieved": "2024-07-30T21:12:27.240855", "image_code": "vec4 sphere = vec4(0.0, 0.0, 1.0, 0.4);\nvec3 lightPos = vec3(-9.0, 8.0, -8.0);\nvec3 lightCol = vec3(0.8, 0.9, 1.0);\n\nfloat sphereDist1(vec3 ro, vec3 rd)\n{\n\tfloat R = sphere.w;\n\tvec3 d1 = sphere.xyz - ro;\n\tfloat b = dot(rd, d1);\n\tfloat d2 = dot(d1, d1) - b * b;\n\tfloat h2 = R * R - d2;\n    if (h2 <= 0.0)\n        return (-1.0);\n    return (b - sqrt(h2));\n}\n\nfloat sphereDist(vec3 p)\n{\n return (length(p - sphere.xyz) - sphere.w);   \n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat getShadow(vec3 ro, vec3 rd, float tmin, float tmax, const float k)\n{\n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i = 0; i < 50; i++)\n    {\n\t\tfloat h = sphereDist(ro + rd * t);\n        res = min(res, k * h / t);\n        t += clamp(h, 0.02, 0.20);\n        if(res < 0.005 || t > tmax)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 getNormal(vec3 pos)\n{\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0, -1.0) * 0.5773;\n    return normalize( e.xyy*sphereDist(pos + e.xyy*ep) + \n\t\t\t\t\t  e.yyx*sphereDist(pos + e.yyx*ep) + \n\t\t\t\t\t  e.yxy*sphereDist(pos + e.yxy*ep) + \n\t\t\t\t\t  e.xxx*sphereDist(pos + e.xxx*ep));\n}\n\n//smooth color gradient - https://www.shadertoy.com/view/4df3Rn\nfloat mandelbrot(vec2 c)\n{\n    vec2 z = vec2(0.0);\n    const float B = 256.0;\n    float l = 0.0;\n    for (int i = 0; i < 512; i++)\n    {\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n        if (dot(z, z) > (B * B))\n            break;\n        l += 1.0;\n    }\n    if (l > 511.0)\n        return (0.0); \n    //float l = l - log(log(length(z))/log(B))/log(2.0);\n    l = l - log2(log2(dot(z, z))) + 4.0;\n    return (l);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 aspectRatio = vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 uv = aspectRatio * (fragCoord.xy / iResolution.xy - 0.5);\n    vec2 mouse = 7.0 * (iMouse.xy / iResolution.xy - 0.5);  \n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n\tfloat rot = iTime * 0.2;\n    mat3 rotX = mat3(\n        vec3(cos(mouse.x - rot), 0.0, sin(mouse.x - rot)),\n        vec3(0.0, 1.0, 0.0),\n        vec3(-sin(mouse.x - rot), 0.0, cos(mouse.x - rot)));  \n\tmat3 rotY = mat3(\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, cos(mouse.y), sin(mouse.y)),\n        vec3(0.0, -sin(mouse.y), cos(mouse.y)));\n\t\n    vec3 color = vec3(0.09 - uv.x, 0.38, uv.x + 0.4) * (0.9 - uv.x);\n    \n    float dSphere = sphereDist1(ro, rd);\n    if (dSphere < 0.0)\n    {\n\t\tfragColor = vec4(color, 1.0);\n\t\treturn;\n    }\n\tvec3 pos = ro + dSphere * rd;\n\tvec3 normal = getNormal(pos);\n\tvec3 v3 = rotX * rotY * normal;\n    vec2 v2 = 1.5 * v3.xy / abs(v3.z);\n    float dMb = mandelbrot(v2);\n        \n    vec3 material = 0.44 + 0.5 * cos(3.0 + dMb * 0.11 + vec3(0.0, 0.5, 1.0)); \n    vec3 lightDir = normalize(vec3(lightPos - pos));\n    vec3 reflectDir = normalize(reflect(lightDir, normal));\n    float shadow = getShadow(pos, lightDir, 0.001, 1.0, 8.0);\n        \n    float diffuse = clamp(dot(normal, lightDir), 0.0, 1.0) * shadow * 2.0;\n    float ambient = 0.6 + 0.6 * normal.y;\n\tfloat specular = pow(clamp(dot(reflectDir, rd), 0.0, 1.0), 16.0) * 2.2 * shadow;\n        \n\tcolor = lightCol * material * (diffuse + specular + ambient);\n    color = sqrt(color);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdByzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 154, 154, 355], [357, 357, 383, 383, 433], [435, 480, 554, 554, 834], [836, 882, 908, 908, 1164], [1166, 1230, 1256, 1256, 1662], [1664, 1664, 1719, 1719, 3299]], "test": "untested"}
{"id": "3dScRc", "name": "Slime Cube", "author": "donnerbrenn", "description": "Simple raymarching scene featuring a cube, sofshadows and some nice ligthning. My very first attempt in raymarching.", "tags": ["raymarching", "cube", "spheretracing"], "likes": 12, "viewed": 499, "published": 3, "date": "1587033515", "time_retrieved": "2024-07-30T21:12:28.076620", "image_code": "//rotate a vector... Not very happy with this huge function...\nmat3 rotateXYZ(vec3 t)\n{\n      float cx = cos(t.x);\n      float sx = sin(t.x);\n      float cy = cos(t.y);\n      float sy = sin(t.y);\n      float cz = cos(t.z);\n      float sz = sin(t.z);\n      mat3 m=mat3(\n        vec3(1, 0, 0),\n        vec3(0, cx, -sx),\n        vec3(0, sx, cx));\n\n      m*=mat3(\n        vec3(cy, 0, sy),\n        vec3(0, 1, 0),\n        vec3(-sy, 0, cy));\n\n      return m*mat3(\n        vec3(cz, -sz, 0),\n        vec3(sz, cz, 0),\n        vec3(0, 0, 1));\n}\n\n//SDF-Functions\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\nfloat softmin(float f1, float f2, float val)\n{\n      float e = max(val - abs(f1 - f2), 0.0);\n      return min(f1, f2) - e*e*0.25 / val;     \n}\n\nfloat map(vec3 p)\n{\n      vec3 rotPlane=(rotateXYZ(vec3(1.5,.0,.0))*p);\n      vec3 rotCube=(rotateXYZ(vec3(1,iTime,sin(iTime*.5)*.5))*p);\n      float myplane=sdRoundBox(rotPlane-vec3(.0,.0,1.5),vec3(20.,20,.01),.1);\n      float mycube=sdRoundBox(rotCube+vec3(0.,.5,0.),vec3(.75/2.),.1);\n      return(softmin(myplane,mycube,1.));\n}\n\n\nvec3 normal(vec3 p)\n{\n      vec2 eps=vec2(.005,0);\n      return normalize(vec3(map(p+eps.xyy)-map(p-eps.xyy),\n                            map(p+eps.yxy)-map(p-eps.yxy),\n                            map(p+eps.yyx)-map(p-eps.yyx)));\n}\n\n// LIGHT\nfloat diffuse_directional(vec3 n,vec3 l, float strength)\n{\n      return (dot(n,normalize(l))*.5+.5)*strength;\n}\n\nfloat specular_directional(vec3 n, vec3 l, vec3 v, float strength)\n{\n      vec3 r=reflect(normalize(l),n);\n      return pow(max(dot(v,r),.0),128.)*strength;\n}\n\nfloat ambient_omni(vec3 p, vec3 l)\n{\n      float d=1.-abs(length(p-l))/100.;\n      return pow(d,32.)*1.5;\n}\n\n\n\n//SHADOW\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.0001 )\n            return .0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n// MAINLOOP\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv= fragCoord.xy/iResolution.xy-.5;\n    uv.x/=iResolution.y/iResolution.x;\n    vec3 ro=vec3(.0,.0,-3.5); \n    vec3 p=ro;\n    vec3 rd=normalize(vec3(uv,1.));\n    float shading=.0;\n    bool hit=false;\n\n    vec3 color;\n    while(p.z<20.)\n    {\n        float d=map(p);\n        if(d<.0001)\n        {\n            hit=true;\n            break;\n        }\n        p += rd*d;\n    }\n\n    float t=length(ro-p);\n    if (hit)\n    {\n        shading=length(p*10.);\n        vec3 n=normal(p);\n        vec3 l1=vec3(1,.5,-.25);\n        float rl=ambient_omni(p,l1)*diffuse_directional(n,l1,.5)+specular_directional(n,l1,rd,.9);\n        color=vec3(rl)+vec3(.1,.4,.1);\n        color*=color;\n        vec3 pos = ro + t*rd;\n        color=mix(vec3(.0),color,softshadow(pos,normalize(l1),.01,10.0,20.)*.25+.75);\n    }\n    color*=mix(color,vec3(1.,1.,1.),1.-exp(-.1*pow(t,128.)));\n    color-=t*.05;\n    color=sqrt(color);\n\n    fragColor=vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dScRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 63, 87, 87, 533], [535, 551, 596, 596, 687], [690, 690, 736, 736, 832], [834, 834, 853, 853, 1164], [1167, 1167, 1188, 1188, 1398], [1400, 1409, 1467, 1467, 1520], [1522, 1522, 1590, 1590, 1680], [1682, 1682, 1718, 1718, 1789], [1793, 1802, 1879, 1879, 2205], [2207, 2219, 2275, 2275, 3211]], "test": "untested"}
{"id": "3sByR3", "name": "Spectrogram test", "author": "hojo", "description": "Classic spectrogram  - with the help of Shadertoy spectrum input.\nNEEDS A RESET at first run on Windows Browser (why? help!)\nColoring with note pitch within octave (press mouse button for pure intensity)", "tags": ["sound", "spectrogram", "microphone"], "likes": 4, "viewed": 388, "published": 3, "date": "1587031414", "time_retrieved": "2024-07-30T21:12:28.842572", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //display Buffer A output\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// (C) F. Claudel 2020\n// this buffer memorizes the background to draw over it\n// AUDIO FEED in iChanel1\n//   microphone ,\n//   soundcloud\n//    https://soundcloud.com/nemixmusic/valkyrie-profile-tomorrow-nemix-remix\n//    https://soundcloud.com/classical-piano-hits/waltz-chopin\n//\n// Get audio feed FFT, display as a Sppectrogram , frequencies on log scale\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //number of octaves, normally log2(512) => 9\n    float nbSamp = iChannelResolution[1].x;\n   \n    // number of octaves (first octave is spread on a just one value...)\n    float nbOct=log2(nbSamp);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // y Offset in screen for first pixel\n    float yOffscr = 0.5/iResolution.y;\n    // x offset in FF buffer\n    float xOffFFT = 0.5/nbSamp;\n    //low octaves to discard for LOGY display\n    float octOffRem = YLOG ? octOffLog : 0.0;\n        \n    // number of octaves to display\n\tfloat nbOctDisp = min(maxOctaves, nbOct-octOffRem);\n\n    \n    float pFreq; //posiiton inf FFT buffer (normalized 0=>1)\n    float phase; // note phase within octavbe, for coloring\n    if (YLOG) {\n    \t//compute for each Y the position in FOurier series (using log display)       \n    \tpFreq = exp2((uv.y-yOffscr)*nbOctDisp+octOffRem)/exp2(nbOct) + xOffFFT;\n        phase = mod((uv.y-yOffscr)*nbOctDisp, 1.0);\n    } else {\n        //linear frequency display\n        pFreq = (uv.y-yOffscr)/nbOct*nbOctDisp +xOffFFT;\n        phase = mod(-log2(uv.y-yOffscr)/log2(nbOctDisp),1.0);\n    }\n    \n    // Thickness of spetroram moving column (2 pixels, normalized)\n    float COLTHICK = 1./iResolution.x; \n     \n    // x position on screen depends time and preious time\n    float tSound= iTime;\n    float xpos1 = fract((tSound-iTimeDelta)*speedx); //fract => periodize\n    float xpos2 = fract((tSound)*speedx);\n    if (xpos1 > xpos2) xpos1 -= 1.0; //avoid carriage return\n    \n     // define smooth alpha on time + period+thickness : 1 during time, 0 out\n\tfloat alphaCol = smoothstep( 0.0, COLTHICK, uv.x - (xpos1-COLTHICK/2.0));\n    alphaCol -= smoothstep( 0.0, COLTHICK, uv.x - (xpos2+COLTHICK/2.0));\n    \n    // mix rgba with previous buffer\n    vec4 prevCol = texture(iChannel0, fragCoord/iResolution.xy).rgba;\n    float freqI = texture(iChannel1, vec2(pFreq,0.25)).r;\n    \n    //check mouse status to see if we inverse palettes\n    if (iMouse.z>0.001) { PALPHASE = !PALPHASE; }\n    \n    if (PALPHASE) {\n        // palette color is phase, amplify with intensity\n   \t\tfragColor = mix(prevCol,\n        \tpalettePhase(freqI, phase), \n       \t\talphaCol );\n    } else {\n        //palette inetnsity\n   \t\tfragColor = mix(prevCol,\n        \tpaletteSound(freqI), \n       \t\talphaCol );\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22424, "src": "https://soundcloud.com/classical-piano-hits/waltz-chopin", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "// LOG or linear frequency o Y axis : \n// use 1.0 for LOG dispolay,, else 0.0 for LINEAR\nconst bool YLOG = true;\n\n// Colouring with Note Phase in octave + intensity dimming\n//  else intensiy colouring\nbool PALPHASE = true; // also changed by clicking the mouse\n\n//speed of spectrogram : screen fraction per second\nconst float speedx = 1./15.;\n    \n//max number of octaves displayed (low octaves can be skipped in log mode)\nconst float maxOctaves = 9.0;\n//for log display, skip those octaves (not enough data in FFT)\nconst float octOffLog = 2.0; \n//Amplification of Spectrum\nconst float specAmpli = 1.0;\n\nvec4 paletteSound(in float x) {\n    // convert intensity to colors, alpha is 1.0\n    x*=specAmpli;\n    //x*=x;//adapt level\n\tvec3 p = vec3( x, 4.0*x*(1.0-x), 1.0-x ) * x;\n    return vec4(p,1.0); //alpha=1\n}\n\nvec4 palettePhase(in float intensity, in float phase) {\n    //phase is between 0 an 1\n    //periodic palette for notes pitch in octave, alpha is 1.0\n    // note : no gamma correction because FFT values seem non-linear...\n    \n    vec3 p = 0.5+0.5*sin(6.28318530718*(vec3(0.0,0.33,0.66)+phase));\n    // modulate by intensity              \n    return vec4( intensity*p ,1.0); //alpha=1\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sByR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 87, 151]], "test": "untested"}
{"id": "3sBcz3", "name": "Social Distancing", "author": "dr2", "description": "Correct behavior even on a distant icy planet...", "tags": ["space", "fibonacci", "penguin", "tux"], "likes": 11, "viewed": 734, "published": 3, "date": "1587029710", "time_retrieved": "2024-07-30T21:12:29.604535", "image_code": "// \"Social Distancing\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Correct behavior even on a distant icy planet...\n// (Pseudopenguins may absorb cp-violating neutrinos)\n\n#define AA  0   // optional antialiasing\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrEllipsDf (vec3 p, vec3 r);\nvec3 SphFib (vec3 v, float n);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec3 RotToDir (vec3 v1, vec3 v2, vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec3 Hashv3v3 (vec3 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir, qHit, pRand;\nfloat tCur, dstFar, plRot;\nint idObj;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat PengDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, dh, fAng;\n  fAng = -0.2 * pi + 0.1 * pi * SmoothBump (0.25, 0.75, 0.1, mod (0.2 * tCur + pRand.z, 1.)) *\n     sin (16. * pi * tCur);\n  p.y -= 1.5;\n  p.xz = Rot2D (p.xz, 2. * pi * (pRand.y - 0.5) * (1. + 0.05 * tCur));\n  q = p;\n  d = PrEllipsDf (q.xzy, vec3 (1.3, 1.2, 1.4));\n  q.y -= 1.5;\n  dh = PrEllipsDf (q.xzy, vec3 (0.8, 0.6, 1.3));\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.3, 2., -0.4);\n  d = SmoothMin (d, max (dh, - PrCylDf (q, 0.15, 0.3)), 0.2);\n  DMINQ (1);\n  q = p;\n  q.yz -= vec2 (1.6, -0.6);\n  d = max (PrEllipsDf (q, vec3 (0.4, 0.2, 0.6)), 0.01 - abs (q.y));\n  DMINQ (2);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.3, 2., -0.4);\n  d = PrSphDf (q, 0.15);\n  DMINQ (3);\n  q = p;\n  q.x = abs (q.x);\n  q.xy -= vec2 (0.4, -0.8);\n  d = PrCylDf (q.xzy, 0.12, 0.7);\n  DMINQ (4);\n  q -= vec3 (0.1, -0.67, -0.4);\n  q.xz = Rot2D (q.xz, -0.07 * pi);\n  d = PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05));\n  q.z -= 0.5;\n  q.xz = Rot2D (q.xz, 0.15 * pi);\n  q.z -= -0.5;\n  d = SmoothMin (d, PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05)), 0.05);\n  q.z -= 0.5;\n  q.xz = Rot2D (q.xz, -0.3 * pi);\n  q.z -= -0.5;\n  d = SmoothMin (d, PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05)), 0.05);\n  DMINQ (5);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (1.1, 0.3, -0.2);\n  q.yz = Rot2D (q.yz, -0.25 * pi);\n  q.xy = Rot2D (q.xy, fAng) - vec2 (0.1, -0.4);\n  d = PrEllipsDf (q.xzy, vec3 (0.05, 0.25, 0.9));\n  DMINQ (6);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qn, uf;\n  float dMin, d, rdFac, pszFac;\n  dMin = dstFar;\n  rdFac = 4.;\n  d = PrSphDf (p, rdFac * (1. + 0.14 * 4.));\n  if (d < 0.1) {\n    dMin /= rdFac;\n    q = p / rdFac;\n    q.xz = Rot2D (q.xz, plRot);\n    qn = normalize (q);\n    uf = SphFib (qn, 42.);\n    d = PrSphDf (q, 1.);\n    DMINQ (7);\n    q = RotToDir (uf, vec3 (0., 0., 1.), q - uf);\n    pRand = Hashv3v3 (41. * uf);\n    pszFac = 0.14 * (0.7 + 0.3 * pRand.x);\n    dMin = rdFac * pszFac * PengDf (q.xzy / pszFac, dMin / pszFac);\n  } else dMin = min (dMin, d);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.03 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.7 + 0.3 * sh;\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 16. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  vec2 vf;\n  float dstObj, sh;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    vf = vec2 (0.);\n    if (idObj == 1 || idObj == 6) vf = vec2 (64., 0.3);\n    else if (idObj == 7) vf = vec2 (16., 4.);\n    if (vf.x > 0.) {\n      vn.xz = Rot2D (vn.xz, plRot);\n      vn = VaryNf (vf.x * qHit, vn, vf.y);\n      vn.xz = Rot2D (vn.xz, - plRot);\n    }\n    if (idObj == 1) col4 = (qHit.z < -0.2 || qHit.z < 0. && length (qHit.xy) < 0.2) ?\n       vec4 (0.95, 0.95, 0.95, 0.05) : vec4 (0.2, 0.2, 0.25, 0.1);\n    else if (idObj == 2) col4 = (qHit.z > -0.3) ? vec4 (1., 0.8, 0.2, 0.2) : vec4 (0.3, 0.7, 1., 0.);\n    else if (idObj == 3) col4 = vec4 (0.15, 0.3, 0.1, 0.3);\n    else if (idObj == 4) col4 = vec4 (0.05, 0.1, 0.05, 0.1);\n    else if (idObj == 5) col4 = vec4 (0.9, 0.9, 0., 0.3);\n    else if (idObj == 6) col4 = vec4 (0.2, 0.2, 0.25, 0.1);\n    else if (idObj == 7) col4 = vec4 (0.7, 0.7, 0.75, 0.);\n    sh = (idObj == 7) ? ObjSShadow (ro, ltDir) : 1.;\n    col = col4.rgb * (0.2 + 0.2 * max (- dot (vn, ltDir), 0.) + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  } else {\n    col = StarPat (rd, 32.);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.2 * pi;\n  if (mPtr.z > 0.) {\n    az += 3. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -30. + 10. * sin (0.1 * pi * tCur));\n  zmFac = 4.;\n  dstFar = 80.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  plRot = 0.03 * pi * tCur;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.9)), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nvec3 SphFib (vec3 v, float n)\n{   // Keinert et al's inverse spherical Fibonacci mapping\n  vec4 b;\n  vec3 vf, vfMin;\n  vec2 ff, c;\n  float fk, ddMin, dd, a, z, ni;\n  const float phi = 1.618034;\n  ni = 1. / n;\n  fk = pow (phi, max (2., floor (log (n * pi * sqrt (5.) * dot (v.xy, v.xy)) /\n     log (phi + 1.)))) / sqrt (5.);\n  ff = vec2 (floor (fk + 0.5), floor (fk * phi + 0.5));\n  b = vec4 (ff * ni, pi * (fract ((ff + 1.) * phi) - (phi - 1.)));\n  c = floor ((0.5 * mat2 (b.y, - b.x, b.w, - b.z) / (b.y * b.z - b.x * b.w)) *\n     vec2 (atan (v.y, v.x), v.z - (1. - ni)));\n  ddMin = 4.1;\n  for (int j = 0; j < 4; j ++) {\n    a = dot (ff, vec2 (j - 2 * (j / 2), j / 2) + c);\n    z = 1. - (2. * a + 1.) * ni;\n    vf = vec3 (sin (2. * pi * fract (phi * a) + vec2 (0.5 * pi, 0.)) * sqrt (1. - z * z), z);\n    dd = dot (vf - v, vf - v);\n    if (dd < ddMin) {\n      ddMin = dd;\n      vfMin = vf;\n    }\n  }\n  return vfMin;\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec3 RotToDir (vec3 v1, vec3 v2, vec3 p)\n{\n  vec3 n;\n  float c;\n  n = normalize (cross (v1, v2));\n  c = dot (v1, v2);\n  return c * p + sqrt (1. - c * c) * cross (n, p) + (1. - c) * dot (n, p) * n;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec3 Hashv3v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec3 (0., cHashVA3.xy)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sBcz3.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[893, 893, 928, 928, 2354], [2356, 2356, 2378, 2378, 2924], [2926, 2926, 2959, 2959, 3136], [3138, 3138, 3159, 3159, 3409], [3411, 3411, 3448, 3448, 3670], [3672, 3672, 3707, 3707, 4161], [4163, 4163, 4198, 4198, 5496], [5498, 5498, 5554, 5554, 6574], [6576, 6576, 6609, 6609, 6636], [6638, 6638, 6680, 6680, 6731], [6733, 6733, 6768, 6768, 6830], [6832, 6832, 6863, 6920, 7749], [7751, 7751, 7773, 7773, 7811], [7813, 7813, 7858, 7858, 7961], [7963, 7963, 8020, 8020, 8103], [8105, 8105, 8147, 8147, 8303], [8305, 8305, 8341, 8341, 8547], [8549, 8549, 8579, 8579, 8692], [8726, 8726, 8750, 8750, 8862], [8864, 8864, 8888, 8888, 9006], [9008, 9008, 9033, 9033, 9219], [9221, 9221, 9242, 9242, 9397], [9399, 9399, 9428, 9428, 9640], [9642, 9642, 9681, 9681, 9866]], "test": "untested"}
{"id": "tsjyzV", "name": "Dithering Hardware Filtering", "author": "Dain", "description": " GPU uses 8 bit fixed point coordinates between texels, so when zooming in like with a noise texture, it becomes nearest neighbor.\n\nHere I am applying a dither to improve the situation, adjusting UV by  (1/resolution) *(1/256)*dither prior to sampling it\n", "tags": ["dither", "dithering", "bilinearfiltering"], "likes": 14, "viewed": 1078, "published": 3, "date": "1587011694", "time_retrieved": "2024-07-30T21:12:30.408386", "image_code": "// GPU uses 8 bit fixed point coordinates between texels, so when zooming in like you might with a noise texture, it becomes nearest neighbor eventually\n// Here I am applying a dither to improve the situation, adjusting UV by  (1/resolution) *(1/256)*dither prior to sampling it\n\n//Left side shows artifacts from GPU 8 bit fixed point interpolation\n//Right side uses dithering to (mostly) hide the artifacts\n\n//from: https://www.shadertoy.com/view/WtfSDS\nfloat VNoiseCell( in vec2 p ){\n\tvec2 uv = p;\n\n    //Fetch 4 value noises--\n    vec4 r = texture(iChannel0, uv/float(iChannelResolution[0])).rgba*2.0-1.0;\n    \n    //make some cells using geometric average\n    float t = abs(r.a*r.b*r.g*r.r);\n\n    float geo_avg = intBitsToFloat(798731503 + (floatBitsToInt(t)>>2)); \n    return geo_avg*2.0 -1.0;\n}\n//note: from https://github.com/Unity-Technologies/ScriptableRenderPipeline/blob/master/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/FinalPass.shader#L124\nfloat remap_pdf_tri_unity( float v )\n{\n    v = v*2.0-1.0;\n    return sign(v) * (1.0 - sqrt(1.0 - abs(v)));\n}\n\nvec2 GetFinalUV(vec2 uv){\n   return uv*(.13 + cos(iTime*.3)*.03)  + 1.1 + sin(iTime*.25)*.03; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0);\n    \n    vec2 bn = texture(iChannel1, fragCoord/vec2(iChannelResolution[1].xy) ).rg;\n    \n    //2 seperate trianglar mapped blue noise samples for high quality dither\n\tvec2 blueNoiseDither = vec2(remap_pdf_tri_unity(bn.x), remap_pdf_tri_unity(bn.y));\n    \n\tfloat f = 0.0;\n    float split = .5;\n    float midPt = split*(iResolution.x/iResolution.y);\n  \n    // left: noise withing dithering on UV coordinates\n\tif( p.x<split )\n\t{\n\n\t\tf = VNoiseCell( GetFinalUV(uv) );\n\t}\n    // right: dither the 8 bit fixed point GPU coordinates\n    else\t\n\t{\n        uv=uv-vec2(midPt,0.0);\n        \n        //8 bit fixed point so adjust sub pixel precision by 1/256\n    \tfloat ditherSize = (1.0/256.0);\n        \n\t\tf = VNoiseCell(GetFinalUV(uv) + blueNoiseDither*ditherSize);\n        \n\t}\n\t//from: https://www.shadertoy.com/view/lsf3WH\n\tf = 2.0 + 2.0*f;\n\t\n    f *= smoothstep( 0.0, 0.005, abs(p.x-split) );\t\n\t\n\tfragColor = vec4( f, f, f, 1.0 );\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjyzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[409, 455, 485, 485, 800], [801, 985, 1023, 1023, 1093], [1095, 1095, 1120, 1120, 1191], [1193, 1193, 1250, 1250, 2272]], "test": "untested"}
{"id": "ws2cRV", "name": "Apple (redux)", "author": "blackle", "description": "worked on this a lot more and ended up with something that looks a lot better!\n\nold version here. be warned that it compiles VERY slow: https://www.shadertoy.com/view/wsjczK", "tags": ["apple"], "likes": 72, "viewed": 1210, "published": 3, "date": "1587007786", "time_retrieved": "2024-07-30T21:12:31.175335", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nuniform int donttouch;\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(p,ax)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n  float k = dot(p-a, b-a)/dot(b-a,b-a);\n  return distance(p, mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat linedist(vec3 p, vec3 a, vec3 b) {\n  float k = dot(p-a, b-a)/dot(b-a,b-a);\n  return distance(p, mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat smin(float a, float b, float k) {\n  float h = max(0., k-abs(a-b))/k;\n  return min(a,b) - k*h*h*h/6.;\n}\n\nfloat hash(float a, float b) {\n  return fract(sin(dot(vec2(a,b), vec2(12.9898, 78.233))) * 43758.5453)*2.-1.;\n}\n\nfloat apple(vec3 p) {\n  p.x += sin(dot(p, vec3(4,2,5)))*0.02;\n  p.z += sin(dot(p, vec3(2,3,7)))*0.02;\n  p.y += sin(dot(p, vec3(2,6,2)))*0.01;\n  \n  vec2 cords = vec2(sqrt(pow(length(p.xy),2.)+0.005), p.z);\n  float sphere1 = length(cords-vec2(0.1,-0.1))-0.85;\n  float sphere2 = length(cords-vec2(0.6,0.6))-0.5;\n  float sphere3 = length(cords-vec2(0.4,-0.8))-0.3;\n  float profile = smin(smin(sphere1, sphere2, 0.9), sphere3, 0.5);\n  float linez = -1.2;\n  float linesub1 = linedist(p, vec3(0,-5,linez), vec3(0,5,linez)) - 0.2;\n  float linesub2 = linedist(p, vec3(-5,0,linez), vec3(5,0,linez)) - 0.2;\n  //return linedist(vec2(profile, p.x), vec2(0), vec2(-10,0))-0.1;\n  return -smin(-profile, smin(linesub1, linesub2, 0.3), 0.4);\n}\n\nvec3 globalstemcoords;\nfloat stem(vec3 p) {\n  float rad = 0.8;\n  float len = 0.6;\n  vec2 torcords = vec2(length(p.xz-vec2(rad,0))-rad, p.y);\n  float tor = length(torcords)-(smoothstep(0., len, p.z)*0.03+0.04);\n  float stemsurf = -smin(-tor, -length(p)+len, 0.06);\n  vec3 stemcords = vec3(atan(torcords.x, torcords.y)*0.1, atan(p.x-rad,p.z), tor);\n  globalstemcoords = stemcords;\n  return stemsurf;\n}\n\nint mat;\nfloat scene(vec3 p) {\n  float body = apple(p - vec3(0,0,1.15));\n  float stm = stem(erot(p, vec3(0,0,1), -0.8)-vec3(0,0,2));\n  float gnd = p.z;\n  float appl = min(stm,body);\n  if (appl < gnd) {\n    mat = 0;\n    if (stm < body) {\n      mat = 2;\n      return stm;\n    }\n    return appl;\n  }\n  mat = 1;\n  return gnd;\n}\n\nfloat scene_proxy(vec3 p) {\n  return min(p.z, min(length(abs(p)-vec3(0,0,1.3))-1., length(abs(p)-vec3(.1,.1,0.5))-0.5));\n}\n\nfloat noise_comp(vec2 p) {\n  vec2 id = floor(p);\n  p = fract(p);\n  float h1 = hash(id.x, id.y);\n  float h2 = hash(id.x+1., id.y);\n  float h3 = hash(id.x, id.y+1.);\n  float h4 = hash(id.x+1., id.y+1.);\n  return mix(mix(h1, h2, p.x), mix(h3, h4, p.x), p.y);\n}\n\nfloat noise(vec2 p) {\n  float n = 0.;\n  for (int i = 0; i < 6; i++) {\n    float h1 = hash(float(i), 8.);\n    float h2 = hash(h1, float(i));\n    float h3 = hash(h2, float(i));\n    n += noise_comp(erot(vec3(p*sqrt(float(i+1))/1.5 + vec2(h2, h3)*100.,0), vec3(0,0,1), h1*100.).xy);\n  }\n  return n/6.;\n}\n\nfloat dots(vec3 p, float scale) {\n  float m = 10000.;\n  for(int i = 0; i < 10; i++) {\n    float ax1 = hash(float(i),68.);\n    float ax2 = hash(ax1,float(i));\n    float ax3 = hash(ax2,float(i));\n    float rot = hash(ax3,float(i));\n    float off = hash(rot,float(i));\n    vec3 ax = normalize(tan(vec3(ax1, ax2, ax3)));\n    vec3 lp = erot(p + off, ax, rot*100.);\n    m = min(m, length((fract(lp/scale)-0.5)*scale));\n  }\n  return m;\n}\n\n/*\nvec3 norm(vec3 p) {\n  mat3 k  = mat3(p,p,p) - mat3(0.001);\n  return normalize(scene(p)-vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}*/\n// suggested from tdhooper. Thanks!\n// improve compilation time & overall fps.\nconst int NORMAL_STEPS = 6;\nvec3 norm(vec3 pos) {\n    vec3 eps = vec3(.01, 0, 0);\n    vec3 nor = vec3(0);\n    float invert = 1.;\n    for (int i = 0; i < NORMAL_STEPS; i++) {\n        nor += scene(pos + eps * invert) * eps * invert;\n        eps = eps.zxy;\n        invert *= -1.;\n    }\n    return normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 cam = normalize(vec3(2,uv));\n  vec3 init = vec3(-9,0,1.1);\n  \n  float yrot = 0.3;\n  float zrot = sin(iTime)*0.4-0.9;\n  cam = erot(cam, vec3(0,1,0), yrot);\n  init = erot(init, vec3(0,1,0), yrot);\n  cam = erot(cam, vec3(0,0,1), zrot);\n  init = erot(init, vec3(0,0,1), zrot);\n  vec3 p = init;\n  bool hit = false;\n  for (int i = 0; i < 200 + donttouch; i ++){\n    float dist = scene(p);\n    if (dist*dist < 1e-6) {\n      hit = true;\n      break;\n    }\n    p+=dist*cam;\n  }\n  vec3 localstemcoords = globalstemcoords;\n  int matloc = mat;\n  vec3 n = norm(p);\n  float ao = sqrt(scene_proxy(p+n*0.5)+0.5);\n  ao *= sqrt(scene_proxy(p+n*0.2)/0.2*0.5+0.5);\n  ao *= sqrt(scene_proxy(p+vec3(1))/sqrt(2.)*0.5+0.5);\n  ao *= sqrt(scene_proxy(p+vec3(.5))/sqrt(2.)+0.55);\n  //ao *= smoothstep(0., 0.5, length(p.xy))*0.2+0.8;\n  vec3 r = reflect(cam, n);\n  float wildness = 3.5;\n  float powr = 20.;\n  float specmult = 1.5;\n  vec3 darkcol;\n  vec3 litecol;\n\n  \n  float splaty = noise(p.zy*vec2(2,10))*0.3+0.6;\n  float splatx = noise(p.zx*vec2(2,10)+100.)*0.3+0.6;\n  float splatz = noise(vec2(length(p.xy), atan(p.x,p.y)*5.)+200.)*0.3+0.6;\n  float marble = mix(mix(splaty, splatx, abs(n.y)), splatz, abs(n.z));\n  if (matloc == 1) {\n    darkcol = vec3(0.01);\n    litecol = mix(vec3(1.,0.05,0.04), vec3(0.1), smoothstep(-1.2, 1.8, scene_proxy(p+r)/dot(r,n))*0.7+0.5);\n  } else if (matloc == 0) {\n    litecol = vec3(1.,0.05,0.04);\n    litecol = mix(vec3(1.,0.2,0.15), litecol, sqrt(marble*0.5+0.5));\n    float d = pow(smoothstep(0.01, 0.06, dots(p, 0.26)), 0.4);\n    litecol = mix(vec3(1.1,0.01,0.05), litecol, d);\n    litecol = mix(vec3(1.5,0.45,0.2), litecol, pow(d, 0.2));\n    litecol *= marble;\n    darkcol = litecol*0.02;\n\n    vec3 noffset = vec3(0);\n    noffset.x += cos(dot(p, 8.*vec3(3,2,2)));\n    noffset.z += cos(dot(p, 8.*vec3(4,1,8)));\n    noffset.y += cos(dot(p, 8.*vec3(4,2,2)));\n    noffset.z += cos(dot(p, 10.*vec3(5,2,4)));\n    noffset.y += cos(dot(p, 10.*vec3(1,1,6)));\n    noffset.y += cos(dot(p, 10.*vec3(1,6,2)));\n    noffset.x += cos(dot(p, 10.*vec3(2,1,5)));\n    noffset.x += cos(dot(p, 10.*vec3(3,6,1)));\n    n = normalize(n+noffset*0.01);\n  } else {\n    float grad = smoothstep(2.56, 2.3, p.z);\n    vec2 messscale = vec2(500.,50.);\n    float mess = noise(1.5+localstemcoords.xy*messscale);\n    float mess2 = noise(1.+localstemcoords.xy*messscale);\n    float mess3 = noise(0.5+localstemcoords.xy*messscale);\n    float stemmix = cos(localstemcoords.z*90.-0.8)*0.5+0.5;\n    n = normalize(n - normalize(tan(vec3(mess,mess2,mess3)))*0.3*(stemmix*0.5+0.5));\n    litecol = mix(vec3(0.5,0.07,0.02), vec3(0.4,0.03,0.025), grad);\n    litecol = mix(vec3(0.6,0.3,0.2), litecol, stemmix);\n    powr = 5.;\n    specmult = mix(0.25, 0.1, grad);\n    litecol *= marble;\n    darkcol = litecol*0.04;\n  }\n  r = reflect(cam, n);\n  float spec = pow(length(sin(r*wildness)*0.5+0.5)/sqrt(3.), powr)*specmult;\n  float diff = length(sin(n*wildness)*0.5+0.5)/sqrt(3.)*0.6;\n  vec3 diffcol = mix(darkcol, litecol, diff);\n  vec3 speccol = vec3(1,0.7,0.7)*spec;\n  fragColor.xyz = hit ? ao*(diffcol + speccol) : vec3(0.05);\n  fragColor.xyz = sqrt(fragColor.xyz);\n  fragColor.xyz = mix(fragColor.xyz, smoothstep(vec3(0),vec3(1), fragColor.xyz), 0.3) + hash(hash(uv.x, uv.y), iTime)*0.02;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2cRV.jpg", "access": "api", "license": "cc0-1.0", "functions": [[218, 218, 256, 256, 320], [322, 322, 362, 362, 451], [453, 453, 493, 493, 582], [584, 584, 623, 623, 692], [694, 694, 724, 724, 805], [807, 807, 828, 828, 1533], [1558, 1558, 1578, 1578, 1934], [1945, 1945, 1966, 1966, 2259], [2261, 2261, 2288, 2288, 2383], [2385, 2385, 2411, 2411, 2642], [2644, 2644, 2665, 2665, 2943], [2945, 2945, 2978, 2978, 3375], [3622, 3622, 3643, 3643, 3905], [3907, 3907, 3964, 3964, 7362]], "test": "untested"}
{"id": "ts2yzK", "name": "raymarching - step by step", "author": "Cewein", "description": "people at college asked to show how ray-marching work, so i did a little animation for them.\nnot the most optimise way to do animation through.\n\nbased on the shader deconstruction from IQ youtube channel, now i know how to send ray without heavy func. \n", "tags": ["raymarching", "time", "shadow", "light", "animation", "normal"], "likes": 1, "viewed": 536, "published": 3, "date": "1586995596", "time_retrieved": "2024-07-30T21:12:32.049996", "image_code": "float speed = 1.5;\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat map(in vec3 pos)\n{\n    float time = mod(iTime * speed,30.);\n    float box = sdBox(pos, vec3(0.4));\n    \n    float sphere = length(pos) - 0.5;\n    \n    float boxSphere = max(-sphere ,box);\n    \n    float flr = pos.y - (-0.30);\n    \n    if(time > 6. && time < 8.) return flr;\n    if(time > 8. && time < 10.) return min(box,flr);\n    if(time > 10.) return min(boxSphere,flr);\n    \n\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(0.0001,0.);\n    return normalize(vec3(map(pos + e.xyy)-map(pos-e.xyy),\n                          map(pos + e.yxy)-map(pos-e.yxy),\n                          map(pos + e.yyx)-map(pos-e.yyx))\n                    );\n}\n\nfloat castRay(in vec3 ro, in vec3 rd)\n{\n    float t = 0.;\n    for(int i = 0; i<120; i++)\n    {\n        vec3 pos = ro + t*rd;\n        \n        float h = map(pos);\n        \n        if(h < 0.001) break;\n        \n        t += h;\n        \n        if(t > 20.)\n        {\n            t = -1.; //set for the shadow\n            break;\n        }\n    }\n        \n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float time = mod(iTime * speed,30.);\n\t\n    float angle = 10.0*iMouse.x/iResolution.x;\n    \n    vec3 ro = vec3(1.5 * sin(angle),0.,1.5 * cos(angle));\n    vec3 ta = vec3(0.);\n    \n    vec3 ww = normalize(ta-ro); //front\n    vec3 uu = normalize(cross(ww,vec3(0.,1.,0.))); //right\n    vec3 vv = normalize(cross(uu,ww)); //up\n    \n    vec3 rd = normalize(uv.x*uu + uv.y*vv + 1.5*ww);\n    \n    vec3 col = vec3(0.5, 0.7, 1.) - max(rd.y,0.0)*0.5;\n    \n    float t = castRay(ro,rd);\n   \n    vec3 mate = vec3(0.2);\n    \n    if(t > 0.)\n    {\n        vec3 pos = ro + t*rd;\n        vec3 norm = calcNormal(pos);\n        \n        vec3 sunDir = normalize(vec3( 1.0,0.4,.2));\n       \tfloat sunDif = clamp( dot(norm, sunDir),0.,1.);\n        float skyDif = clamp( 0.5 + 0.5*dot(norm, vec3(0.,1.,0.)),0.,1.);\n        float sunSha = step(castRay(pos + norm * 0.001, sunDir),0.);\n        float bouceDif = clamp( 0.5 + 0.5*dot(norm, vec3(0.,-1.,0.)),0.,1.);\n        \n        if(time > 12. && time < 14.) col = vec3(t);\n        if(time > 14. && time < 16.) col = norm;\n        \n        if(time > 16. && time < 18.)\n        {\n            col =  mate*vec3(7.0,5.0,3.) * sunDif;\n        }\n        if(time > 18. && time < 20.)\n        {\n            col =  mate*vec3(7.0,5.0,3.) * sunDif * sunSha;\n        }\n        if(time > 20. && time < 22.)\n        {\n            col =  mate*vec3(7.0,5.0,3.) * sunDif * sunSha;\n            col += mate*vec3(0.5,0.8,0.9) * skyDif;        \n        }\n        if(time > 22.)\n        {\n            col =  mate*vec3(7.0,5.0,3.) * sunDif * sunSha;\n            col += mate*vec3(0.5,0.8,0.9) * skyDif;        \n            col += mate*vec3(0.7,0.5,0.3) * bouceDif;\n        }\n\n    }\n    \n    col = pow(col, vec3(0.4545)); \n    \n    if(time < 2.) col = vec3(uv,0.);\n    if(time > 2. && time < 4.) col = rd;\n    if(time > 4. && time < 12.) col = vec3(t);\n\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2yzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 51, 51, 138], [140, 140, 164, 164, 526], [528, 528, 558, 558, 790], [792, 792, 831, 831, 1157], [1159, 1159, 1216, 1216, 3169]], "test": "untested"}
{"id": "tsjcRK", "name": "Northern Lights Running Wild", "author": "TEttinger", "description": "A variant on my earlier plasma/noise ShaderToy (from over a year ago) that's less biased toward bright colors.", "tags": ["noise", "plasma", "lights", "northernlights", "northern"], "likes": 6, "viewed": 489, "published": 3, "date": "1586985247", "time_retrieved": "2024-07-30T21:12:32.956573", "image_code": "// CC0 licensed, do what thou wilt.\nconst float SEED = 42.0;\n\n// returns a float between -1.0 and 1.0\nfloat swayRandomized(float seed, float value)\n{\n    float f = floor(value);\n    float start = sin((cos(f * seed) + sin(f * 1024.)) * 345. + seed);\n    float end   = sin((cos((f+1.) * seed) + sin((f+1.) * 1024.)) * 345. + seed);\n    return mix(start, end, smoothstep(0., 1., value - f));\n}\n\n// returns a float betweeen -3.0 and 3.0. Does not modify con.\nfloat cosmic(float seed, vec3 con)\n{\n    float sum = swayRandomized(seed, con.z + con.x);\n    sum +=      swayRandomized(seed, con.x + con.y + sum);\n    sum +=      swayRandomized(seed, con.y + con.z + sum);\n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // aTime, s, and c could be uniforms in some engines.\n    float aTime = iTime * 0.16;\n    vec3 s = vec3(swayRandomized(-16405.31527, aTime - 1.11),\n                  swayRandomized(-77664.8142, aTime + 1.41),\n                  swayRandomized(-50993.5190, aTime + 2.61)) * 3. + 1.;\n    vec3 c = vec3(swayRandomized(-10527.92407, aTime - 1.11),\n                  swayRandomized(-61557.6687, aTime + 1.41),\n                  swayRandomized(-43527.8990, aTime + 2.61)) * 3. + 1.;\n    vec3 con = vec3(0.0004375, 0.0005625, 0.0008125) * aTime + c * uv.x + s * uv.y;\n    con.x = cosmic(SEED, con);\n    con.y = cosmic(SEED, con);\n    con.z = cosmic(SEED, con);\n    \n    fragColor = vec4(sin(con) * 0.5 + 0.5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjcRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 102, 149, 149, 390], [392, 455, 491, 491, 680], [682, 682, 739, 789, 1541]], "test": "untested"}
{"id": "3d2cRV", "name": "Cobwebs in 1 tweet", "author": "notargs", "description": "Minified shader for 1 tweet\nhttps://twitter.com/notargs/status/1250468645030858753?s=20", "tags": ["onetweetglsl"], "likes": 42, "viewed": 1168, "published": 3, "date": "1586975243", "time_retrieved": "2024-07-30T21:12:34.000781", "image_code": "void mainImage(out vec4 e, in vec2 v)\n{\n    vec3 d=.5-vec3(gl_FragCoord.xy,1)/iResolution.y,p,o;\n    for(int i=0;i<32;i++)\n    {\n        o=p;\n        o.z-=iTime*9.;\n        float a=o.z*.1;\n        o.xy*=mat2(cos(a),sin(a),-sin(a),cos(a));\n        p+=(.1-length(cos(o.xy)+sin(o.yz)))*d;\n    }\n    e=vec4((sin(p)+vec3(2,5,9))/length(p)*vec3(1), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d2cRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 348]], "test": "untested"}
{"id": "WsjcRV", "name": "Little Letters", "author": "wyatt", "description": "graph network of particles. They find each other by searching a directional graph. ", "tags": ["graph"], "likes": 26, "viewed": 705, "published": 3, "date": "1586975003", "time_retrieved": "2024-07-30T21:12:34.872450", "image_code": "// Fork of \"Bouncing Julia\" by wyatt. https://shadertoy.com/view/tsScWw\n// 2020-04-15 18:21:55\n\n// Fork of \"Graph Network*\" by wyatt. https://shadertoy.com/view/wdjcDR\n// 2020-04-13 00:32:16\n\n// Fork of \"Graph Network\" by wyatt. https://shadertoy.com/view/tssyDS\n// 2020-04-09 20:04:37\n\nvec4 color (vec2 U, float q) {\n\nvec4 c = C(U), cc = B(c.zw);\n    for (int x = -1; x<=1;x++)\n        for (int y = -1; y<=1;y++){\n        \tvec4 ccc = B(c.zw+vec2(x,y));\n            if (length(U-A(ccc.xy).xy)<length(U-A(cc.xy).xy))\n                cc=ccc;\n        }\n    vec4 a = A(c.zw), b = A(cc.xy),\n         aa = (c.zwzw), bb = (cc.xyxy);\n    vec2 r = a.xy-b.xy, p = aa.xy-bb.xy;\n    float an = angle(r,p);\n    \n   \tvec2 u = U-a.xy;\n    vec4 t = B(c.zw+u);\n    t = A(t.xy);\n    float s = sg(U,a.xy,t.xy);\n    vec4 Q = 0.7+0.5*sin(vec4(1,2,3,4)+(aa.x+aa.y)/R.x*6.2);\n    u *= mat2(cos(an),sin(-an),sin(an),cos(an));\n    u = 2.*abs(u);\n    Q *= vec4(1)*smoothstep((0.9+q)*O,(.9-q)*O,max(u.x,u.y));\n\treturn Q;\n}\n\nMain {\n    vec4 c1 = color(U,0.1), c2 = color(U+3.,2.);\n    Q = 0.15+0.85*c1+max(.1*C(U).zzzz/R.x-10.*length(c1),0.);\n    Q -= .1*length(c2)*max(1.-10.*c1,0.);\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texelFetch(iChannel1,ivec2(U),0)\n#define C(U) texelFetch(iChannel2,ivec2(U),0)\n#define D(U) texelFetch(iChannel3,ivec2(U),0)\n#define Main void mainImage (out vec4 Q, vec2 U) \n#define Init if (iFrame < 1) \n#define Border if (U.x<1.||R.x-U.x<1.||U.y<1.||R.y-U.y<1.)\n#define O 6.\n#define shape(U) (round((U)/O)*O)\n#define N 12\n#define Z vec2(u)\nfloat angle (vec2 a, vec2 b) {\n\treturn atan(a.x*b.y-a.y*b.x,dot(a.xy,b.xy));\n}\nfloat sg (vec2 p, vec2 a, vec2 b) {\n    if (length(a-b)<1e-4||length(a)<1e-4||length(b)<1e-4) return 1e9;\n    \n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\tfloat l = (length(p-a-(b-a)*i));\n    return l;\n}\n\nfloat pie (vec2 p, vec2 a, vec2 b) {\n\tvec2 m = 0.5*(a+b); // midpoint\n    if (length(a-b)<1e-3) return 1e3; // ignore self\n\treturn abs(dot(p-m,b-m)/dot(b-m,b-m)); // pojection\n} \nfloat line (vec2 p, vec2 a, vec2 b) {\n    if (length(a-b)<1.||length(a)<1.||length(b)<1.) return 1e9;\n    \n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\tfloat l = (length(p-a-(b-a)*i));\n    l=(pie(p,a,b));\n    return l;\n}", "buffer_a_code": "vec2 force (vec2 U, vec4 a, vec2 bb) {\n    vec4 b = A(bb);\n    if (b.x<5.&&b.y<5.||bb.x<5.||bb.y<5.) return vec2(0);\n    \n    vec2 r = b.xy-a.xy, v = b.zw-a.zw;\n    vec4 da = D(U), db = D(bb);\n\tvec2 q = da.xy-db.xy;\n    float l = length(r), j = length(q);\n    if (l < 1e-9) return vec2(0);\n    vec2 f = vec2(0);\n    if (l!=0.&&j!=0.){\n    if (j<2.*O) f = 0.5*r/l*(l-j)+v/l/l;\n    else f = -smoothstep(O,0.5*O,l)*r/l;\n    }\n    return f;\n}\nMain {\n    vec2 u = shape(U);\n    Q = A(u);\n    if ((iFrame>100&&Q.x<1.&&Q.y<1.)||u.x+O>=R.x||u.y+O>=R.y||u.x<O||u.y<O||length(U-u)>1.) {Q=-1e8*R.xyxy;return;}\n    \n    vec2 f = vec2(0);\n    for (int x=-3;x<3; x++) {\n        for (int y=-3;y<3; y++) {\n            vec4 b = B(u+vec2(x,y));\n            f += (\n                force(U,Q,b.xy)+\n                force(U,Q,b.zw));\n        }\n\t}\n    f /= 36.;\n    Q.zw += f;\n    Q.xy += f+Q.zw*sqrt(1./(1.+dot(Q.zw,Q.zw)));\n    if (iMouse.z>0.) Q.zw += .1*(Q.xy-iMouse.xy)/length(Q.xy-iMouse.xy);\n    \n    \tif (Q.x<5.) {Q.x=5.;Q.z = +abs(Q.z);}\n        if (R.x-Q.x<5.) {Q.x=R.x-5.;Q.z =-abs(Q.z);}\n        if (Q.y<5.) {Q.y=5.;Q.z=0.;Q.w = +abs(Q.w);}\n        if (R.y-Q.y<5.) {Q.y=R.y-5.;Q.w =-abs(Q.w);}\n\n    if (iFrame < 102) {\n    \tQ = vec4(D(U).xy,2.*(u-0.5*R)/R.x);\n    }\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void X (inout vec4 Q, inout vec2 r, vec4 a, vec2 U, vec2 u, vec4 n) {\n\tfloat l = line(a.xy+U-u,a.xy,A(n.xy).xy),\n          ll = line(a.xy+U-u,a.xy,A(n.zw).xy);\n    if (l<r.x){\n        r = vec2(l,r.x);\n        Q=vec4(n.xy,Q.xy);\n    } else if (l<r.y) {\n    \tr.y = l;\n        Q.zw = n.xy;\n    }\n    if (ll<r.x){\n    \tr = vec2(ll,r.x);\n        Q=vec4(n.zw,Q.xy);\n    } else if (ll<r.y) {\n    \tr.y = ll;\n        Q.zw = n.zw;\n    }\n}\nMain {\n    vec2 u = shape(U);\n    vec4 a = A(u);\n\tQ = B(U);\n    vec2 r = vec2(line(a.xy+U-u,a.xy,A(Q.xy).xy)\n                 ,line(a.xy+U-u,a.xy,A(Q.zw).xy));\n    \n    \n    X(Q,r,a,U,u,B(U+vec2(1,1)));\n    X(Q,r,a,U,u,B(U+vec2(0,1)));\n    X(Q,r,a,U,u,B(U+vec2(1,0)));\n    X(Q,r,a,U,u,B(U-vec2(0,1)));\n    X(Q,r,a,U,u,B(U-vec2(1,0)));\n    X(Q,r,a,U,u,B(U+vec2(1,1)));\n    X(Q,r,a,U,u,B(U+vec2(1,-1)));\n    X(Q,r,a,U,u,B(U-vec2(1,1)));\n    X(Q,r,a,U,u,B(U-vec2(1,-1)));\n    \n    X(Q,r,a,U,u,B(Q.xy-U+u));\n    X(Q,r,a,U,u,B(Q.zw-U+u));\n    X(Q,r,a,U,u,B(Q.xy-U+u+vec2(0,1)));\n    X(Q,r,a,U,u,B(Q.xy-U+u+vec2(1,0)));\n    X(Q,r,a,U,u,B(Q.xy-U+u-vec2(0,1)));\n    X(Q,r,a,U,u,B(Q.xy-U+u-vec2(1,0)));\n    X(Q,r,a,U,u,B(Q.xy-U+u+vec2(1,1)));\n    X(Q,r,a,U,u,B(Q.xy-U+u+vec2(1,-1)));\n    X(Q,r,a,U,u,B(Q.xy-U+u-vec2(1,1)));\n    X(Q,r,a,U,u,B(Q.xy-U+u-vec2(1,-1)));\n    \n    X(Q,r,a,U,u,vec4(U-O*vec2(1,0),U+O*vec2(1,0)));\n    X(Q,r,a,U,u,vec4(U-O*vec2(0,1),U+O*vec2(0,1)));\n\tX(Q,r,a,U,u,C(a.xy+2.*vec2(O,0)).zwxy);\n    X(Q,r,a,U,u,C(a.xy+2.*vec2(0,O)).zwxy);\n    X(Q,r,a,U,u,C(a.xy-2.*vec2(O,0)).zwxy);\n    X(Q,r,a,U,u,C(a.xy-2.*vec2(0,O)).zwxy);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\nvoid Y (inout vec4 Q, vec2 U, vec4 n) {\n\tfloat l = length(U-A(n.xy).xy),//sg(U,A(n.xy).xy,A(n.zw).xy),\n          ll = length(U-A(Q.xy).xy);//sg(U,A(Q.xy).xy,A(Q.zw).xy);\n    if (l<ll) Q.xy = n.xy;\n}\nvoid X (inout vec4 Q, vec2 U, vec4 n) {\n\tfloat l = length(U-A(n.zw).xy),//sg(U,A(n.xy).xy,A(n.zw).xy),\n          ll = length(U-A(Q.zw).xy);//sg(U,A(Q.xy).xy,A(Q.zw).xy);\n    if (l<ll) Q.zw = n.zw;\n}\nMain {\n\tQ = C(U).xyxy;\n    if (iFrame%N==0) Q.xy = U;\n    else {\n        float k = exp2(float(N-1-(iFrame%N)));\n    \tY(Q,U,C(U+vec2(0,k)));\n    \tY(Q,U,C(U+vec2(k,0)));\n    \tY(Q,U,C(U-vec2(0,k)));\n    \tY(Q,U,C(U-vec2(k,0)));\n    }\n\n\tX(Q,U,C(U+vec2(0,1)));\n    X(Q,U,C(U+vec2(1,0)));\n    X(Q,U,C(U-vec2(0,1)));\n    X(Q,U,C(U-vec2(1,0)));\n    \n    X(Q,U,C(U+vec2(1,1)));\n    X(Q,U,C(U+vec2(1,-1)));\n    X(Q,U,C(U-vec2(1,1)));\n    X(Q,U,C(U-vec2(1,-1)));\n    \n    X(Q,U,C(U+vec2(0,4)));\n    X(Q,U,C(U+vec2(4,0)));\n    X(Q,U,C(U-vec2(0,4)));\n    X(Q,U,C(U-vec2(4,0)));\n    \n    X(Q,U,C(U));\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n\tQ.xy = shape(U);\n    //Q.x += 0.5*O*mod(Q.y/O,2.);\n    Q.z=.5-20.*(texture(iChannel0,.5+.25*Q.xy/R).w-.5); \n    if (Q.z<.2) Q.xy = -1e9*R;\n    Q.xy*=0.66;\n    //Q.xy+=0.3*R;\n}", "buffer_d_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjcRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[287, 287, 317, 317, 995]], "test": "untested"}
{"id": "3djcRV", "name": "1Tweet xor-y thing", "author": "jeyko", "description": "You", "tags": ["1tweet"], "likes": 2, "viewed": 323, "published": 3, "date": "1586973891", "time_retrieved": "2024-07-30T21:12:35.754093", "image_code": "\nvoid mainImage(out vec4 C,vec2 U ){\n    #define f float\n    #define t iTime*0.05\n    U/=iResolution.xy;U-=0.5;f j,i=0.;for(;i <7.;i++){j=f(int(U.y*0.5)^int(U.x*10.));U=abs(U)-2.-j*0.15;U*=mat2(cos(i+t),-sin(i+t),sin(i+t),cos(i+t));}C=vec4(max(U.y,U.x)*40.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djcRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 36, 36, 260]], "test": "untested"}
{"id": "3djyzK", "name": "Voronoi Experimentation_", "author": "Pixdigit", "description": "A playground to play with voronoi tiling", "tags": ["voronoi"], "likes": 0, "viewed": 160, "published": 3, "date": "1586965908", "time_retrieved": "2024-07-30T21:12:36.710536", "image_code": "\nconst float cells = 40.;\nconst float subtile = 1.;\nconst bool boxed = true;\n\nvec2 N22(vec2 p) {\n    vec3 a = fract(p.xyx*vec3(123.34, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\n\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n\tfloat t = iTime * 0.2+200.;\n    \n    vec3 col;\n    \n    float id = 0.;\n    float minD = 1000.;\n    \n    if (boxed) {\n        vec2 guv = fract(uv*subtile)-.5;\n        vec2 gid = floor(uv*subtile);\n\t\tvec2 cid;\n        \n        for (float x = -1.; x < 2.; x++) {\n            for (float y = -1.; y < 2.; y++) {\n                vec2 off = vec2(x, y);\n                vec2 n = N22(gid+off);\n                vec2 p = off + sin(n * t*4.)*0.5;\n                vec2 dVec = guv-p;\n                float d = abs(dVec.x)+abs(dVec.y);\n                if (d < minD) {\n                    minD = d;\n                    cid = off+gid;\n                }\n            }\n        }\n        float h = N22(cid).x*0.2;\n        float s = smoothstep(1., -0.6, minD);\n        float b = 0.3+N22(cid).x*(1.-minD);\n\n        col = hsb2rgb(vec3(h, s, b));\n    } else {\n        for (float i = 0.; i < cells; i++) {\n            vec2 n = N22(vec2(i));\n            vec2 p = sin(n * t);\n            p.x *= iResolution.x / iResolution.y;\n            vec2 dVec = uv-p;\n            float d = abs(dVec.x)+abs(dVec.y);\n            if (d < minD) {\n                minD = d;\n                id = i / cells;\n            }\n            float h = id*0.2;\n            float s = smoothstep(0.7, -0.6, minD);\n            float b = 0.3+id*(1.-minD);\n\n            col = hsb2rgb(vec3(h, s, b));\n        }\n    }\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djyzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 96, 96, 222], [224, 224, 250, 250, 482], [484, 484, 541, 541, 1991]], "test": "untested"}
{"id": "tdBczV", "name": "Testing putpixel", "author": "Leria", "description": "Testing how to properly putpixel in Shadertoy", "tags": ["noise", "pixel", "circle", "putpixel"], "likes": 1, "viewed": 307, "published": 3, "date": "1586957613", "time_retrieved": "2024-07-30T21:12:37.693907", "image_code": "//Disclaimer : I use some parts of codes from @iq + I write some things in frenglish\n\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n//quintique\nvec2 fade5(vec2 f) {return f * f * f * (f * (f * 6.0 - 15.0) + 10.0);}\n\n//cubique\nvec2 fade3(vec2 f) {return f*f*(3.0-2.0*f);}\n\nfloat noise(vec2 p)\n{\n \tvec2 i = floor( p );\n    vec2 f = fract( p );\n    \n    vec2 u = fade5(f);\n    \n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n        \n}\n\nfloat dist(vec2 a, vec2 b) \n{\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 origin = vec2(iResolution.x/2., iResolution.y/2.);\n    float radius = 50.;\n    \n\tif(fragCoord.x == iResolution.x/2.)\n    {\n     \tif(fragCoord.y == iResolution.y/2.)   \n        {\n        \tfragColor = vec4(1., 1., 1., 1.);\n        }\n    }\n    \n    \n    if(dist(origin, fragCoord) < radius)\n    {\n        float l = noise(fragCoord);\n     \tfragColor = vec4(l, l, l, 1.);  \t\n    }\n    \n    \n    if(dist(origin, fragCoord) > radius)\n    {\n     \tfragColor = vec4(0., 0., 1., 1.);   \n    }\n    \n        \tif(fragCoord.x == fragCoord.y)\n        {\n         \tfragColor = vec4(1., 1., 1., 1.);\n        }\n    \n    \n        //perimeter\n    if(dist(origin, fragCoord) >= radius && (dist(origin, fragCoord)) <= (radius+1.))\n    {\n     \tfragColor = vec4(1., 0., 0., 1.);   \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdBczV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 86, 144, 144, 282], [284, 296, 316, 316, 366], [368, 378, 398, 398, 422], [424, 424, 445, 445, 853], [855, 855, 884, 884, 941], [943, 943, 1000, 1000, 1773]], "test": "untested"}
{"id": "wsSczV", "name": "Noise + blue color = jean look", "author": "Leria", "description": "Just add a powerful blue in z of color\n+trying to do fractal noise with iq method", "tags": ["noise", "blue", "jean"], "likes": 0, "viewed": 280, "published": 3, "date": "1586957591", "time_retrieved": "2024-07-30T21:12:38.456866", "image_code": "//Disclaimer : I use some parts of codes from @iq\n\nvec2 hash(vec2 p)  { return ( 2.* fract(sin( (p) * 78.233 ) * 43758.5453) -1. );}\n\n//quintique\nvec2 fade5(vec2 f) {return f * f * f * (f * (f * 6.0 - 15.0) + 10.0);}\n\n//cubique\nvec2 fade3(vec2 f) {return f*f*(3.0-2.0*f);}\n\nfloat noise(vec2 p)\n{\n \tvec2 i = floor( p );\n    vec2 f = fract( p );\n    \n    vec2 u = fade5(f);\n    \n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n        \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.x/3., fragCoord.y/2.);\n    \n\tfloat n = noise(fragCoord);\n    \n    vec2 uv = p*vec2(iResolution.x/iResolution.y,1.0);\n    \n    mat2 m = mat2( 0.6,  0.2, -0.2,  0.8 );\n    \n\tn  = 0.5000*noise( uv ); uv = m*uv;\n\tn += 0.2500*noise( uv ); uv = m*uv;\n\tn += 0.1250*noise( uv ); uv = m*uv;\n\tn += 0.0625*noise( uv ); uv = m*uv;\n\n\tn *= 0.5 + 0.5*n;\n\t\n    n *= smoothstep( 0.0, 0.005, abs(p.x-0.6) );\t\n\t    \n    fragColor = vec4(0.4*n, 0.5*n, n, 1.);\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsSczV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 71, 71, 132], [134, 146, 166, 166, 216], [218, 228, 248, 248, 272], [274, 274, 295, 295, 703], [706, 706, 763, 763, 1234]], "test": "untested"}
{"id": "tsSczV", "name": "Noise 1 to test parameters", "author": "Leria", "description": "Testing implemntation of gradient noise", "tags": ["noise", "gradient"], "likes": 2, "viewed": 298, "published": 3, "date": "1586957530", "time_retrieved": "2024-07-30T21:12:39.334520", "image_code": "//Disclaimer : I use some part of code from @iq\n\nvec2 hash(vec2 p)  { return ( 2.* fract(sin( dot(p, vec2(49.74459, 123.45678))*p.xy * 78.233 ) * 43758.5453) -1. );}\n\n//quintique\nvec2 fade5(vec2 f) {return f * f * f * (f * (f * 6.0 - 15.0) + 10.0);}\n\n//cubique\nvec2 fade3(vec2 f) {return f*f*(3.0-2.0*f);}\n\nfloat noise(vec2 p)\n{\n \tvec2 i = floor( p );\n    vec2 f = fract( p );\n    \n    vec2 u = fade5(f);\n    \n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord /= 10.;\n\n\tfloat n = .5+.5*noise(fragCoord);\n    \n    fragColor = vec4(n, n, n, 1.);\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsSczV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 69, 69, 165], [167, 179, 199, 199, 249], [251, 261, 281, 281, 305], [307, 307, 328, 328, 736], [738, 738, 795, 795, 899]], "test": "untested"}
{"id": "wdSyRV", "name": "waves different speed no collisi", "author": "lomateron", "description": "2 variables are need to create a circle\n1D space filled with varibles\npair neighbor variables to create circles\neach frame rotate circles a little bit\nnow create pairs with neighbors of neigbor\nrotate those circles a little bit too\nthis happens", "tags": ["fdtd"], "likes": 0, "viewed": 323, "published": 3, "date": "1586951813", "time_retrieved": "2024-07-30T21:12:40.176269", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = fragCoord/iResolution.xy;\n         u.x*= 256./iResolution.x;\n    \n    vec4 C = texture(iChannel0, u);\n    \n    vec4 b = u.y*vec4(8.)-vec4(1.,3.,5.,7.);\n    \n    float c = +float(b.x<C.x && b.x>0.)\n              +float(b.x>C.x && b.x<0.)\n              +float(b.y<C.y && b.y>0.)\n              +float(b.y>C.y && b.y<0.)\n              +float(b.z<C.z && b.z>0.)\n              +float(b.z>C.z && b.z<0.)\n              +float(b.w<C.w && b.w>0.)\n              +float(b.w>C.w && b.w<0.);\n\n    fragColor = vec4(c);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec2 m = vec2(256.,iResolution.y);\n    vec4 C = texture(iChannel0, mod(u+vec2(0,0),m)/iResolution.xy);\n    vec4 R = texture(iChannel0, mod(u+vec2(1,0),m)/iResolution.xy);\n    vec4 L = texture(iChannel0, mod(u-vec2(1,0),m)/iResolution.xy);\n    \n    float pi = 3.14159265359;\n    float s = .2;\n    int i = iFrame&1;\n    if(i==0)\n    {\n        C.x  = cos(atan(C.x,L.w)+s-vec2(0.,pi*.5)).y*length(vec2(L.w,C.x));\n        C.w  = cos(atan(R.x,C.w)+s-vec2(0.,pi*.5)).x*length(vec2(C.w,R.x));\n        C.yz = cos(atan(C.z,C.y)+s-vec2(0.,pi*.5))  *length(C.yz);\n        C.xy = cos(atan(C.y,C.x)+s-vec2(0.,pi*.5))  *length(C.xy);\n        C.zw = cos(atan(C.w,C.z)+s-vec2(0.,pi*.5))  *length(C.zw);\n    }\n    if(i==1)\n    {\n        C.x  = cos(atan(C.x,L.z)+s-vec2(0.,pi*.5)).y*length(vec2(L.z,C.x));\n        C.y  = cos(atan(C.y,L.w)+s-vec2(0.,pi*.5)).y*length(vec2(L.w,C.y));\n        C.z  = cos(atan(R.x,C.z)+s-vec2(0.,pi*.5)).x*length(vec2(C.z,R.x));\n        C.w  = cos(atan(R.y,C.w)+s-vec2(0.,pi*.5)).x*length(vec2(C.w,R.y));\n        C.xz = cos(atan(C.z,C.x)+s-vec2(0.,pi*.5))  *length(C.xz);\n        C.yw = cos(atan(C.w,C.y)+s-vec2(0.,pi*.5))  *length(C.yw);\n    }\n    \n    float uf = u.x-128.;\n    float ud = u.x- 64.;\n    float fr = float(iFrame)- 300.;\n    if(iFrame == 0) C = +exp(-uf*uf /32.)*vec4(1,-1,1,-1)\n                        +exp(-ud*ud /32.)*vec4(.5)\n                        +.0;\n    fragColor = C;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSyRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 576]], "test": "untested"}
{"id": "tsjcDw", "name": "John Byrom's Device", "author": "mla", "description": "Device from the title page of John Byrom's The Universal English Short-hand (1767):\n\n[url]https://books.google.co.uk/books?id=Azg5AAAAMAAJ&printsec=frontcover[/url]\n[url]https://en.wikipedia.org/wiki/John_Byrom[/url]", "tags": ["reproduction", "byrom"], "likes": 11, "viewed": 330, "published": 3, "date": "1586946377", "time_retrieved": "2024-07-30T21:12:41.202525", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// John Byrom: device from title page of \"The Universal English Short-hand\":\n// https://books.google.co.uk/books?id=Azg5AAAAMAAJ&printsec=frontcover\n// https://en.wikipedia.org/wiki/John_Byrom\n//\n// Matthew Arcus (mla), 2020\n//\n// 'r' shows fundamental region\n//\n// John Byrom, FRS (1692-1763): English poet and the inventor of a\n// revolutionary system of shorthand. He is most remembered as the\n// writer of the lyrics of the Anglican hymn 'Christians awake! Salute\n// the happy morn'.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nbool key(int code) {\n  return texelFetch(iChannel3, ivec2(code,2),0).x != 0.0;\n}\n\nconst int CHAR_R = 82;\n\nfloat circle(vec2 p, vec3 c) {\n  vec2 centre = c.xy;\n  float radius = c.z;\n  return abs(length(p-centre)-radius);\n}\n\nfloat byrom(vec2 p, float lwidth, out bool fundamental) {\n  float d = 1e8;\n  //p = p-3.0*round(p/3.0); // Repeat grid of [-1.5,1.5] squares\n  vec2 p0 = p;\n  p = abs(p);  // Reflect into primary quadrant\n\n  // Next line draws the 2 little circles on the x-axis.\n  // Do this before the reflection in x = 0.5\n  d = min(d,circle(p,vec3(0.94,0,0.06)));\n\n  p.x = min(p.x,1.0-p.x); // Reflect in x = 0.5\n\n  fundamental = p == p0;\n  \n  // The arcs of the larger circles - there are 3 in the fundamental\n  // region. Use a fixed circle and reflect p in y=0 and x=0.5 (could\n  // fix p and reflect the circle, but seems clearer this way round).\n  vec3 c = vec3(2.5,-1,2.5);\n  d = min(d,circle(p,c));\n  d = min(d,circle(vec2(1.0-p.x,p.y),c)); // x=0.5\n  d = min(d,circle(vec2(p.x,-p.y),c));    // y=0.0\n\n  // The small semicircles on top and bottom edges\n  d = min(d,circle(p,vec3(0.5,1,0.5)));\n\n  // The diagonal lines - translate to any point on line, then\n  // dot product with line normal. The compiler can do the\n  // normalization for use.\n  d = min(d,abs(dot(p-vec2(0.5,0),normalize(vec2(2,1)))));\n\n  // The grid lines\n  d = min(d,abs(p.y));\n  d = min(d,abs(p.y-1.0));\n  d = min(d,abs(p.x));\n  \n  // Clip to region, just the sides needed.\n  d = max(d,p.y-1.0);\n  d = max(d,-p.x);\n\n  // Surrounding circle - use original p0 for this and make circle\n  // slightly larger to ensure square corners are covered.\n  d = min(d,circle(p0,vec3(0,0,sqrt(2.0+2.0*lwidth))));\n  return d;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n   p *= 1.55; // scale\n    //p.x += iTime;\n  float lwidth = 0.012;\n  bool fundamental;\n  float d = byrom(p,lwidth,fundamental);\n\n  // Draw the line!\n  vec4 tt = texture(iChannel0,p);\n  float t = 1.0-smoothstep(0.0,lwidth*(1.0+tt.y),d);\n  t *= tt.x;\n  t = 1.0-t;\n  t *= 0.8+0.1*tt.z;\n  vec3 col = t*vec3(1,1,0.8);\n\n  // The fundamental region is the points that haven't moved.a\n  if (key(CHAR_R) &&  fundamental) col.gb *= 0.8;\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjcDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[677, 677, 698, 698, 724], [726, 726, 746, 746, 806], [832, 832, 862, 862, 947], [949, 949, 1006, 1006, 2422], [2424, 2424, 2476, 2476, 2989]], "test": "untested"}
{"id": "wsByzh", "name": "Filtering effect comparison", "author": "bartwronski", "description": "Comparing effect of different filters, starting from top and clockwise: bilinear, sinc, bicubic (bspline), biquadratic.\nBlog post: https://bartwronski.com/2020/04/14/bilinear-texture-filtering-artifacts-alternatives-and-frequency-domain-analysis/ ", "tags": ["filtering"], "likes": 10, "viewed": 1347, "published": 3, "date": "1586928668", "time_retrieved": "2024-07-30T21:12:42.145005", "image_code": "// Note: this code is unoptimal on purpose, zero optimizations, and demonstration only!\n\nvoid sharedGetUvAndInterp(in vec2 uv, out ivec2 uvi, out vec2 interp) {\n    uv *= iChannelResolution[0].xy;\n    uv -= 0.5;\n    interp = fract(uv);\n    uvi = ivec2(floor(uv));\n}\n\n\n#define PI 3.1415926\n\nfloat sinc(in float x) {\n\tif (x == 0.0)\n        return 1.0;\n    return sin(PI*x) / (PI*x);\n}\n\n\n\nvec3 sampleBilinear(in vec2 uv) {\n    ivec2 uvi; vec2 interp;\n    sharedGetUvAndInterp(uv, uvi, interp);\n    vec4 weights = vec4((1.0-interp.x) * (1.0-interp.y),\n                        interp.x * (1.0-interp.y),\n                        (1.0-interp.x) * interp.y,\n                        interp.x * interp.y);\n    return  texelFetch(iChannel0, uvi + ivec2(0,0),0).xyz * weights.x\n          + texelFetch(iChannel0, uvi + ivec2(1,0),0).xyz * weights.y\n          + texelFetch(iChannel0, uvi + ivec2(0,1),0).xyz * weights.z\n          + texelFetch(iChannel0, uvi + ivec2(1,1),0).xyz * weights.w;\n}\n\nvec3 sampleSinc(in vec2 uv) {\n    ivec2 uvi; vec2 interp;\n    sharedGetUvAndInterp(uv, uvi, interp);\n\n    vec3 col = vec3(0.0);\n    float weights = 0.0;\n    for (int y = -2; y <= 2; ++y) {\n        for (int x = -2; x <= 2; ++x) {\n            float effective_x = interp.x - float(x);\n            float effective_y = interp.y - float(y);\n            float window = 1.0;//sinc(effective_x / 4.0) * sinc(effective_y / 4.0);\n            float w = sinc(effective_x) * sinc(effective_y) * window;\n            col += texelFetch(iChannel0, uvi + ivec2(x,y),0).xyz * w;\n            weights += w;\n        }\n    }\n    return col / weights;\n}\n\nvec4 getBsplineWeights(in float x) {\n  \t// float w0 = 1.0/6.0 * (1.0-x) * (1.0-x) * (1.0-x);\n  \tfloat w1 = 2.0/3.0 - 0.5 * x*x * (2.0-x);\n  \tfloat w2 = 2.0/3.0 - 0.5 * (1.0-x)*(1.0-x) * (2.0-(1.0-x));\n  \tfloat w3 = 1.0/6.0 * x*x*x;\n\treturn vec4(1.0 - w3 - w1 - w2, w1, w2, w3);\n}\n\nvec3 sampleBSpline(in vec2 uv) {\n    ivec2 uvi; vec2 interp;\n    sharedGetUvAndInterp(uv, uvi, interp);\n\n    vec4 bspline_weights_x = getBsplineWeights(interp.x);\n    vec4 bspline_weights_y = getBsplineWeights(interp.y);\n    vec3 col = vec3(0.0);\n    for (int y = -1; y <= 2; ++y) {\n        for (int x = -1; x <= 2; ++x) {\n            col += texelFetch(iChannel0, uvi + ivec2(x,y),0).xyz * bspline_weights_x[x+1] * bspline_weights_y[y+1];\n        }\n    }\n    return col;\n}\n\nvec3 getBiquadraticWeights(in float x) {\n    return vec3(0.5 - x + 0.5 * x * x, x - x * x + 0.5, 0.5 * x * x);\n}\n\nvec3 sampleBiquadratic(in vec2 uv) {\n    ivec2 uvi; vec2 interp;\n    uv *= iChannelResolution[0].xy;\n    uv -= 0.5;\n    interp = uv - round(uv);\n    uvi = ivec2(round(uv));\n    \n    vec3 biquadratic_weights_x = getBiquadraticWeights(interp.x+0.5);\n    vec3 biquadratic_weights_y = getBiquadraticWeights(interp.y+0.5);\n    vec3 col = vec3(0.0);\n    \n    for (int y = -1; y <= 1; ++y) {\n        for (int x = -1; x <= 1; ++x) {\n            col += texelFetch(iChannel0, uvi + ivec2(x,y),0).xyz \n                * biquadratic_weights_x[x+1] * biquadratic_weights_y[y+1];\n        }\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 origUV = fragCoord/iResolution.xy;\n    vec2 uv = origUV / 5.0;\n    uv += vec2(0.5, 0.48);\n    uv *= iChannelResolution[0].xy;\n    if (fract(0.15 * iTime) < 0.8)\n    \tuv = round(uv);\n    uv /= iChannelResolution[0].xy;\n    uv += vec2(sin(iTime),cos(iTime)) / 150.0 * vec2(iResolution.y/iResolution.x, 1.0);\n    vec2 phase = fract(uv * iChannelResolution[0].xy - vec2(0.5));\n\n    vec3 col = vec3(0.0);\n\n    if (origUV.x > origUV.y) {\n        if (origUV.x > 1.0 - origUV.y) {\n        \tcol = sampleSinc(uv);\n        } else {\n            col = sampleBSpline(uv);\n        }\n    } else {\n        if (origUV.x > 1.0 - origUV.y) {\n        \tcol = sampleBilinear(uv);\n        } else {\n            col = sampleBiquadratic(uv);\n        }\n    }\n    if (abs(origUV.x - origUV.y) < 0.005 || abs(origUV.x - (1.0-origUV.y)) < 0.005)\n        col = vec3(1.0);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// Sharpen and increase contrast for better demo\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0.0);\n    col += texelFetch(iChannel0, ivec2(fragCoord), 0) * 2.0;\n    col += texelFetch(iChannel0, ivec2(fragCoord)+ivec2(-1,0), 0) * -0.25;\n    col += texelFetch(iChannel0, ivec2(fragCoord)+ivec2(1,0), 0) * -0.25;\n    col += texelFetch(iChannel0, ivec2(fragCoord)+ivec2(0,1), 0) * -0.25;\n    col += texelFetch(iChannel0, ivec2(fragCoord)+ivec2(0,-1), 0) * -0.25;\n    col = pow(abs(col), vec4(1.5)) * 1.5;\n    fragColor = col;\n}\n\n", "buffer_a_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsByzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 160, 160, 265], [290, 290, 314, 314, 382], [386, 386, 419, 419, 978], [980, 980, 1009, 1009, 1608], [1610, 1610, 1646, 1702, 1889], [1891, 1891, 1923, 1923, 2363], [2365, 2365, 2405, 2405, 2477], [2479, 2479, 2515, 2515, 3078], [3080, 3080, 3136, 3186, 4097]], "test": "untested"}
{"id": "3dSyRV", "name": "Gaming cube:234chars", "author": "butadiene", "description": "226chars  https://twitter.com/butadiene121/status/1250237898214928384?s=20", "tags": ["raymarching", "codegolf"], "likes": 3, "viewed": 435, "published": 3, "date": "1586925844", "time_retrieved": "2024-07-30T21:12:43.191208", "image_code": "#define l iTime\nvoid mainImage(out vec4 o,vec2 u){vec3 p=vec3(0),e,d=vec3(u/5e2-.5,.3);p.z+=l;for(int i=0;i<99;i++)p.yz+=.01*sin(p.zy+l),e.x=length(max(abs(mod(p,.8)-.4)-.2-.1*step(.5,sin(l)),0.)),p+=d*e.x;o=vec4(12.*e.x*sin(l+p),1);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dSyRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 16, 50, 50, 234]], "test": "untested"}
{"id": "3dByzK", "name": "h[sp]luv rational Fourier series", "author": "mattz", "description": "It's [url]https://www.shadertoy.com/view/tdBcRG[/url] but with rational Fourier series.\n\nNote: you can define ORDER to be 1 or 2 at the top of the file and see the change in fit.", "tags": ["colormap", "fourier", "hsluv", "hpluv", "fitcolormap"], "likes": 4, "viewed": 411, "published": 3, "date": "1586915496", "time_retrieved": "2024-07-30T21:12:44.252371", "image_code": "// fitting rational polynomials to HSLuv and HPLuv colormaps\n//\n// License CC0 (public domain) \n//   https://creativecommons.org/share-your-work/public-domain/cc0/\n//\n// like https://www.shadertoy.com/view/tdBcRG but with rational Fourier series\n//\n// outputs, bottom to top:\n//\n//   1) original HSLuv values computed from https://github.com/hsluv/hsluv-python\n//   2) rational Fourier series \n//   3) original HPLuv values from https://github.com/hsluv/hsluv-python\n//   4) rational Fourier series \n//\n// I am probably done playing with these fits for now :)\n\n#define ORDER 2\n\n#if ORDER == 2\n\nvec3 hsluv(float t) {\n\n    t *= 6.283185307179586;\n\n    vec2 cs1 = vec2(cos(t), sin(t));\n    vec2 cs2 = vec2(cos(2.0*t), sin(2.0*t));\n\n    vec3 n = vec3(0.4499723076135584, 0.609426607533859, 0.4288887656855271);\n    n += vec3(1.356958715978088, -0.6223492834243289, -0.2455749072607498)*cs1.x;\n    n += vec3(-0.2058207830435541, 0.4820199928163624, -0.8671833275731918)*cs1.y;\n    n += vec3(-0.2862391770341579, 0.05434355975084173, 0.4356605836093163)*cs2.x;\n    n += vec3(-0.5279746052180661, -0.1719661920391326, -0.2836479508431202)*cs2.y;\n\n    vec3 d = vec3(1.0);\n    d += vec3(0.7153502777378531, -0.9219020024148035, -0.2910109117528888)*cs1.x;\n    d += vec3(-0.3381133734426577, 0.7903005432576772, -0.3172368432843283)*cs1.y;\n    d += vec3(-0.2639897520454177, 0.06346650999193199, 0.5784878335459051)*cs2.x;\n    d += vec3(-0.3066564712099898, -0.2161956627263612, -0.2188031991633754)*cs2.y;\n\n    return n/d;\n\n}\n\nvec3 hpluv(float t) {\n\n    t *= 6.283185307179586;\n\n    vec2 cs1 = vec2(cos(t), sin(t));\n    vec2 cs2 = vec2(cos(2.0*t), sin(2.0*t));\n\n    vec3 n = vec3(0.6698260593431076, 0.5741866585654442, 0.6074284221076398);\n    n += vec3(0.8263467981452095, -0.2020418406514409, -0.06579882943043414)*cs1.x;\n    n += vec3(0.1278739528808921, 0.2055033211946446, -0.4912381708231384)*cs1.y;\n    n += vec3(0.1580550606222037, -0.002035314944658304, -0.03683228443676777)*cs2.x;\n    n += vec3(0.05270503006417088, -0.01747401166680522, 0.01104082480565293)*cs2.y;\n\n    vec3 d = vec3(1.0);\n    d += vec3(1.045501814882021, -0.227676649398989, -0.07644732041559271)*cs1.x;\n    d += vec3(0.2273682478445634, 0.3236347287584649, -0.4813798195577666)*cs1.y;\n    d += vec3(0.0975546708844913, -0.009724725764886694, 0.004645741124919443)*cs2.x;\n    d += vec3(0.06757418348606457, -0.01672661576390289, 0.002341600573231208)*cs2.y;\n\n    return n/d;\n\n}\n\n#elif ORDER == 1\n\nvec3 hsluv(float t) {\n\n    t *= 6.283185307179586;\n\n    vec2 cs1 = vec2(cos(t), sin(t));\n\n    vec3 n = vec3(0.5797973177237825, 0.5070337329322581, 0.568088401614339);\n    n += vec3(1.0661946905429, -0.3612919210066708, -0.2702317227311645)*cs1.x;\n    n += vec3(0.1902568810066575, 0.3342519202295906, -0.8188628836462595)*cs1.y;\n\n    vec3 d = vec3(1.0);\n    d += vec3(0.7181121891233868, -0.539840016051254, -0.3317617693164782)*cs1.x;\n    d += vec3(0.3425293649148586, 0.5875830371370718, -0.4730637426120308)*cs1.y;\n\n    return n/d;\n\n}\n\nvec3 hpluv(float t) {\n\n    t *= 6.283185307179586;\n\n    vec2 cs1 = vec2(cos(t), sin(t));\n\n    vec3 n = vec3(0.5832271348571118, 0.5669143498918592, 0.5688901803565138);\n    n += vec3(0.5579918385059167, -0.123397919673585, -0.04010425190513076)*cs1.x;\n    n += vec3(0.07377028386927893, 0.1108109634096618, -0.3122855451190785)*cs1.y;\n\n    vec3 d = vec3(1.0);\n    d += vec3(0.5048729122168087, -0.086202826156657, -0.02961476768472726)*cs1.x;\n    d += vec3(0.1355863216235928, 0.1557689334676045, -0.1491132071515487)*cs1.y;\n\n    return n/d;\n\n}\n\n#endif\n\nvec3 paletteLUT(float row, float u) {\n    \n    vec2 uv;\n    \n    uv.x = mix(0.5, 254.5, u);\n    uv.y = 0.5 + row;\n    \n    uv /= iResolution.xy;\n    \n    return texture(iChannel0, uv, 0.0).xyz;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    float u = fragCoord.x / iResolution.x;\n    \n    //fragColor = vec4(paletteLUT(2.0, u), 1);\n    \n    \n    float y;\n    vec2 uv;\n    \n    if (max(iMouse.z, iMouse.w) > 0.) {\n        \n        uv = fragCoord / iResolution.xy;\n        y = floor(iMouse.y * 4. / iResolution.y );\n        \n    } else {\n\n        const float m = 2.0;\n\n        vec2 dims = iResolution.xy - vec2(2.*m, 2.*m);\n\n        float h = floor(0.25*dims.y);\n\n        dims.y = 4.0*h;\n\n        fragCoord -= 0.5*(iResolution.xy-dims) + mod(m, 2.)*0.5;\n\n        y = floor(fragCoord.y / h);\n\n        uv = fragCoord / dims;\n\n        float b = mod(fragCoord.y + 0.5*h, h);\n\n        if (abs(b - 0.5*h) < 0.5*m || uv.x < 0. || uv.x >= 1.) {\n            y = -1.;\n        }\n        \n    }\n\n    fragColor = vec4(0, 0, 0, 1);\n    \n    if (y == 0.) {\n        fragColor.xyz = paletteLUT(1.0, uv.x);\n    } else if (y == 1.) {\n        fragColor.xyz = hsluv(uv.x);\n    } else if (y == 2.) {\n        fragColor.xyz = paletteLUT(2.0, uv.x);\n    } else if (y == 3.) {\n        fragColor.xyz = hpluv(uv.x);\n    }\n\n    \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// just some ugly code to store two 256-color palettes on the first frame\n// and then just recycle the same texture data over and over\n\nvec4 data = vec4(0);\nivec2 fc;\nivec2 dst_fc;\n\nvoid store(vec3 f) { \n\n    if (dst_fc == fc) {\n        data.xyz = f;\n    }\n    dst_fc.x += 1;\n    \n}\n    \n\nvoid store_all_data() {\n    \n    // initialization\n    dst_fc = ivec2(0, 0);\n    store(vec3(1));\n    \n    //  hsluv\n    dst_fc = ivec2(0, 1);\n\n    store(vec3(1.00000000, 0.30121629, 0.50494183));\n    store(vec3(1.00000000, 0.30424269, 0.48859814));\n    store(vec3(1.00000000, 0.30723827, 0.47150960));\n    store(vec3(1.00000000, 0.31020757, 0.45355707));\n    store(vec3(1.00000000, 0.31315497, 0.43459376));\n    store(vec3(1.00000000, 0.31608470, 0.41443505));\n    store(vec3(1.00000000, 0.31900088, 0.39284280));\n    store(vec3(1.00000000, 0.32190755, 0.36950044));\n    store(vec3(1.00000000, 0.32480869, 0.34397071));\n    store(vec3(1.00000000, 0.32770824, 0.31561901));\n    store(vec3(1.00000000, 0.33061011, 0.28346037));\n    store(vec3(1.00000000, 0.33351823, 0.24580988));\n    store(vec3(1.00000000, 0.33643658, 0.19930106));\n    store(vec3(1.00000000, 0.33936915, 0.13485350));\n    store(vec3(0.99938278, 0.34294341, 0.00000000));\n    store(vec3(0.98103890, 0.36328996, 0.00000000));\n    store(vec3(0.96398111, 0.38063200, 0.00000000));\n    store(vec3(0.94804995, 0.39566226, 0.00000000));\n    store(vec3(0.93311126, 0.40886353, 0.00000000));\n    store(vec3(0.91905123, 0.42058609, 0.00000000));\n    store(vec3(0.90577258, 0.43109219, 0.00000000));\n    store(vec3(0.89319158, 0.44058314, 0.00000000));\n    store(vec3(0.88123570, 0.44921665, 0.00000000));\n    store(vec3(0.86984172, 0.45711848, 0.00000000));\n    store(vec3(0.85895421, 0.46439037, 0.00000000));\n    store(vec3(0.84852436, 0.47111567, 0.00000000));\n    store(vec3(0.83850891, 0.47736349, 0.00000000));\n    store(vec3(0.82886937, 0.48319162, 0.00000000));\n    store(vec3(0.81957135, 0.48864889, 0.00000000));\n    store(vec3(0.81058393, 0.49377685, 0.00000000));\n    store(vec3(0.80187924, 0.49861111, 0.00000000));\n    store(vec3(0.79343202, 0.50318241, 0.00000000));\n    store(vec3(0.78521930, 0.50751744, 0.00000000));\n    store(vec3(0.77722010, 0.51163952, 0.00000000));\n    store(vec3(0.76941516, 0.51556910, 0.00000000));\n    store(vec3(0.76178675, 0.51932422, 0.00000000));\n    store(vec3(0.75431846, 0.52292090, 0.00000000));\n    store(vec3(0.74699506, 0.52637336, 0.00000000));\n    store(vec3(0.73980232, 0.52969434, 0.00000000));\n    store(vec3(0.73272689, 0.53289526, 0.00000000));\n    store(vec3(0.72575624, 0.53598642, 0.00000000));\n    store(vec3(0.71887847, 0.53897714, 0.00000000));\n    store(vec3(0.71208228, 0.54187587, 0.00000000));\n    store(vec3(0.70535689, 0.54469030, 0.00000000));\n    store(vec3(0.69869191, 0.54742748, 0.00000000));\n    store(vec3(0.69207733, 0.55009387, 0.00000000));\n    store(vec3(0.68550341, 0.55269543, 0.00000000));\n    store(vec3(0.67896066, 0.55523763, 0.00000000));\n    store(vec3(0.67243972, 0.55772559, 0.00000000));\n    store(vec3(0.66593138, 0.56016404, 0.00000000));\n    store(vec3(0.65942647, 0.56255741, 0.00000000));\n    store(vec3(0.65291579, 0.56490986, 0.00000000));\n    store(vec3(0.64639012, 0.56722529, 0.00000000));\n    store(vec3(0.63984010, 0.56950739, 0.00000000));\n    store(vec3(0.63325622, 0.57175966, 0.00000000));\n    store(vec3(0.62662870, 0.57398544, 0.00000000));\n    store(vec3(0.61994748, 0.57618791, 0.00000000));\n    store(vec3(0.61320212, 0.57837014, 0.00000000));\n    store(vec3(0.60638172, 0.58053508, 0.00000000));\n    store(vec3(0.59947486, 0.58268560, 0.00000000));\n    store(vec3(0.59246946, 0.58482449, 0.00000000));\n    store(vec3(0.58535273, 0.58695447, 0.00000000));\n    store(vec3(0.57811102, 0.58907823, 0.00000000));\n    store(vec3(0.57072965, 0.59119842, 0.00000000));\n    store(vec3(0.56319283, 0.59331768, 0.00000000));\n    store(vec3(0.55548341, 0.59543864, 0.00000000));\n    store(vec3(0.54758269, 0.59756393, 0.00000000));\n    store(vec3(0.53947016, 0.59969620, 0.00000000));\n    store(vec3(0.53112323, 0.60183817, 0.00000000));\n    store(vec3(0.52251683, 0.60399256, 0.00000000));\n    store(vec3(0.51362298, 0.60616218, 0.00000000));\n    store(vec3(0.50441030, 0.60834992, 0.00000000));\n    store(vec3(0.49484329, 0.61055876, 0.00000000));\n    store(vec3(0.48488160, 0.61279177, 0.00000000));\n    store(vec3(0.47447892, 0.61505220, 0.00000000));\n    store(vec3(0.46358172, 0.61734339, 0.00000000));\n    store(vec3(0.45212752, 0.61966890, 0.00000000));\n    store(vec3(0.44004269, 0.62203246, 0.00000000));\n    store(vec3(0.42723940, 0.62443802, 0.00000000));\n    store(vec3(0.41361153, 0.62688979, 0.00000000));\n    store(vec3(0.39902889, 0.62939226, 0.00000000));\n    store(vec3(0.38332885, 0.63195025, 0.00000000));\n    store(vec3(0.36630386, 0.63456891, 0.00000000));\n    store(vec3(0.34768201, 0.63725384, 0.00000000));\n    store(vec3(0.32709527, 0.64001106, 0.00000000));\n    store(vec3(0.30402406, 0.64284713, 0.00000000));\n    store(vec3(0.27769245, 0.64576921, 0.00000000));\n    store(vec3(0.24684646, 0.64878511, 0.00000000));\n    store(vec3(0.20920095, 0.65190340, 0.00000000));\n    store(vec3(0.15962948, 0.65513354, 0.00000000));\n    store(vec3(0.07929463, 0.65848596, 0.00000000));\n    store(vec3(-0.00000000, 0.65946658, 0.08707563));\n    store(vec3(-0.00000000, 0.65835467, 0.16265107));\n    store(vec3(-0.00000000, 0.65730351, 0.21004012));\n    store(vec3(-0.00000000, 0.65630709, 0.24593491));\n    store(vec3(-0.00000000, 0.65536010, 0.27517292));\n    store(vec3(-0.00000000, 0.65445788, 0.29995945));\n    store(vec3(-0.00000000, 0.65359632, 0.32151992));\n    store(vec3(-0.00000000, 0.65277173, 0.34061858));\n    store(vec3(-0.00000000, 0.65198085, 0.35776980));\n    store(vec3(-0.00000000, 0.65122074, 0.37333917));\n    store(vec3(-0.00000000, 0.65048877, 0.38759726));\n    store(vec3(-0.00000000, 0.64978257, 0.40075079));\n    store(vec3(-0.00000000, 0.64909997, 0.41296172));\n    store(vec3(-0.00000000, 0.64843902, 0.42435963));\n    store(vec3(-0.00000000, 0.64779795, 0.43504997));\n    store(vec3(-0.00000000, 0.64717512, 0.44511986));\n    store(vec3(-0.00000000, 0.64656904, 0.45464215));\n    store(vec3(-0.00000000, 0.64597833, 0.46367847));\n    store(vec3(-0.00000000, 0.64540172, 0.47228148));\n    store(vec3(-0.00000000, 0.64483805, 0.48049652));\n    store(vec3(-0.00000000, 0.64428620, 0.48836298));\n    store(vec3(-0.00000000, 0.64374517, 0.49591531));\n    store(vec3(-0.00000000, 0.64321401, 0.50318385));\n    store(vec3(-0.00000000, 0.64269180, 0.51019547));\n    store(vec3(-0.00000000, 0.64217771, 0.51697412));\n    store(vec3(-0.00000000, 0.64167095, 0.52354124));\n    store(vec3(-0.00000000, 0.64117075, 0.52991616));\n    store(vec3(-0.00000000, 0.64067638, 0.53611635));\n    store(vec3(-0.00000000, 0.64018716, 0.54215772));\n    store(vec3(-0.00000000, 0.63970242, 0.54805479));\n    store(vec3(-0.00000000, 0.63922152, 0.55382090));\n    store(vec3(-0.00000000, 0.63874383, 0.55946835));\n    store(vec3(-0.00000000, 0.63826874, 0.56500853));\n    store(vec3(-0.00000000, 0.63779567, 0.57045206));\n    store(vec3(-0.00000000, 0.63732402, 0.57580885));\n    store(vec3(-0.00000000, 0.63685323, 0.58108822));\n    store(vec3(-0.00000000, 0.63638270, 0.58629898));\n    store(vec3(-0.00000000, 0.63591188, 0.59144948));\n    store(vec3(-0.00000000, 0.63544019, 0.59654768));\n    store(vec3(-0.00000000, 0.63496705, 0.60160122));\n    store(vec3(-0.00000000, 0.63449188, 0.60661746));\n    store(vec3(-0.00000000, 0.63401408, 0.61160351));\n    store(vec3(-0.00000000, 0.63353304, 0.61656634));\n    store(vec3(-0.00000000, 0.63304814, 0.62151273));\n    store(vec3(-0.00000000, 0.63255874, 0.62644937));\n    store(vec3(-0.00000000, 0.63206417, 0.63138291));\n    store(vec3(-0.00000000, 0.63156373, 0.63631995));\n    store(vec3(-0.00000000, 0.63105670, 0.64126711));\n    store(vec3(-0.00000000, 0.63054232, 0.64623104));\n    store(vec3(-0.00000000, 0.63001980, 0.65121850));\n    store(vec3(-0.00000000, 0.62948827, 0.65623637));\n    store(vec3(-0.00000000, 0.62894685, 0.66129169));\n    store(vec3(-0.00000000, 0.62839457, 0.66639169));\n    store(vec3(-0.00000000, 0.62783043, 0.67154389));\n    store(vec3(-0.00000000, 0.62725331, 0.67675607));\n    store(vec3(-0.00000000, 0.62666204, 0.68203638));\n    store(vec3(-0.00000000, 0.62605535, 0.68739338));\n    store(vec3(-0.00000000, 0.62543185, 0.69283610));\n    store(vec3(-0.00000000, 0.62479005, 0.69837408));\n    store(vec3(-0.00000000, 0.62412831, 0.70401750));\n    store(vec3(-0.00000000, 0.62344485, 0.70977724));\n    store(vec3(-0.00000000, 0.62273770, 0.71566496));\n    store(vec3(-0.00000000, 0.62200470, 0.72169322));\n    store(vec3(-0.00000000, 0.62124347, 0.72787563));\n    store(vec3(-0.00000000, 0.62045135, 0.73422693));\n    store(vec3(-0.00000000, 0.61962541, 0.74076322));\n    store(vec3(-0.00000000, 0.61876235, 0.74750212));\n    store(vec3(-0.00000000, 0.61785849, 0.75446297));\n    store(vec3(-0.00000000, 0.61690969, 0.76166711));\n    store(vec3(-0.00000000, 0.61591125, 0.76913818));\n    store(vec3(-0.00000000, 0.61485787, 0.77690246));\n    store(vec3(-0.00000000, 0.61374346, 0.78498930));\n    store(vec3(-0.00000000, 0.61256110, 0.79343160));\n    store(vec3(-0.00000000, 0.61130279, 0.80226646));\n    store(vec3(-0.00000000, 0.60995926, 0.81153584));\n    store(vec3(-0.00000000, 0.60851972, 0.82128751));\n    store(vec3(-0.00000000, 0.60697156, 0.83157609));\n    store(vec3(-0.00000000, 0.60529985, 0.84246439));\n    store(vec3(-0.00000000, 0.60348686, 0.85402511));\n    store(vec3(-0.00000000, 0.60151136, 0.86634292));\n    store(vec3(-0.00000000, 0.59934768, 0.87951712));\n    store(vec3(-0.00000000, 0.59696448, 0.89366506));\n    store(vec3(-0.00000000, 0.59432308, 0.90892663));\n    store(vec3(-0.00000000, 0.59137524, 0.92547006));\n    store(vec3(-0.00000000, 0.58805989, 0.94349976));\n    store(vec3(-0.00000000, 0.58429861, 0.96326697));\n    store(vec3(-0.00000000, 0.57998894, 0.98508443));\n    store(vec3(0.08705126, 0.57476151, 1.00000000));\n    store(vec3(0.18908055, 0.56888970, 1.00000000));\n    store(vec3(0.25096602, 0.56299884, 1.00000000));\n    store(vec3(0.29857943, 0.55708036, 1.00000000));\n    store(vec3(0.33829712, 0.55112550, 1.00000000));\n    store(vec3(0.37286526, 0.54512525, 1.00000000));\n    store(vec3(0.40376097, 0.53907028, 1.00000000));\n    store(vec3(0.43188612, 0.53295087, 1.00000000));\n    store(vec3(0.45783917, 0.52675684, 1.00000000));\n    store(vec3(0.48204145, 0.52047745, 1.00000000));\n    store(vec3(0.50480322, 0.51410134, 1.00000000));\n    store(vec3(0.52636105, 0.50761639, 1.00000000));\n    store(vec3(0.54690057, 0.50100961, 1.00000000));\n    store(vec3(0.56657090, 0.49426702, 1.00000000));\n    store(vec3(0.58549429, 0.48737345, 1.00000000));\n    store(vec3(0.60377274, 0.48031241, 1.00000000));\n    store(vec3(0.62149273, 0.47306580, 1.00000000));\n    store(vec3(0.63872856, 0.46561370, 1.00000000));\n    store(vec3(0.65554499, 0.45793405, 1.00000000));\n    store(vec3(0.67199909, 0.45000225, 1.00000000));\n    store(vec3(0.68814176, 0.44179069, 1.00000000));\n    store(vec3(0.70401893, 0.43326824, 1.00000000));\n    store(vec3(0.71967246, 0.42439945, 1.00000000));\n    store(vec3(0.73514093, 0.41514376, 1.00000000));\n    store(vec3(0.75046027, 0.40545427, 1.00000000));\n    store(vec3(0.76566427, 0.39527632, 1.00000000));\n    store(vec3(0.78078506, 0.38454554, 1.00000000));\n    store(vec3(0.79585348, 0.37318522, 1.00000000));\n    store(vec3(0.81089946, 0.36110281, 1.00000000));\n    store(vec3(0.82595231, 0.34818486, 1.00000000));\n    store(vec3(0.84104101, 0.33428990, 1.00000000));\n    store(vec3(0.85619454, 0.31923765, 1.00000000));\n    store(vec3(0.87144208, 0.30279243, 1.00000000));\n    store(vec3(0.88681334, 0.28463600, 1.00000000));\n    store(vec3(0.90233881, 0.26432051, 1.00000000));\n    store(vec3(0.91805001, 0.24118003, 1.00000000));\n    store(vec3(0.93397988, 0.21414499, 1.00000000));\n    store(vec3(0.95016302, 0.18128547, 1.00000000));\n    store(vec3(0.96663608, 0.13835170, 1.00000000));\n    store(vec3(0.98343816, 0.07058422, 1.00000000));\n    store(vec3(0.99457977, 0.00000000, 0.99397528));\n    store(vec3(0.99884189, 0.00000000, 0.98126797));\n    store(vec3(1.00000000, 0.03358261, 0.96600934));\n    store(vec3(1.00000000, 0.07043814, 0.95019059));\n    store(vec3(1.00000000, 0.09512532, 0.93487684));\n    store(vec3(1.00000000, 0.11420839, 0.92001832));\n    store(vec3(1.00000000, 0.12993072, 0.90557000));\n    store(vec3(1.00000000, 0.14336377, 0.89149090));\n    store(vec3(1.00000000, 0.15511821, 0.87774352));\n    store(vec3(1.00000000, 0.16558115, 0.86429337));\n    store(vec3(1.00000000, 0.17501610, 0.85110852));\n    store(vec3(1.00000000, 0.18361198, 0.83815927));\n    store(vec3(1.00000000, 0.19150953, 0.82541781));\n    store(vec3(1.00000000, 0.19881690, 0.81285791));\n    store(vec3(1.00000000, 0.20561921, 0.80045473));\n    store(vec3(1.00000000, 0.21198482, 0.78818454));\n    store(vec3(1.00000000, 0.21796959, 0.77602452));\n    store(vec3(1.00000000, 0.22361981, 0.76395256));\n    store(vec3(1.00000000, 0.22897429, 0.75194710));\n    store(vec3(1.00000000, 0.23406599, 0.73998692));\n    store(vec3(1.00000000, 0.23892311, 0.72805097));\n    store(vec3(1.00000000, 0.24357002, 0.71611822));\n    store(vec3(1.00000000, 0.24802792, 0.70416746));\n    store(vec3(1.00000000, 0.25231543, 0.69217711));\n    store(vec3(1.00000000, 0.25644896, 0.68012503));\n    store(vec3(1.00000000, 0.26044310, 0.66798832));\n    store(vec3(1.00000000, 0.26431086, 0.65574306));\n    store(vec3(1.00000000, 0.26806394, 0.64336405));\n    store(vec3(1.00000000, 0.27171290, 0.63082451));\n    store(vec3(1.00000000, 0.27526733, 0.61809574));\n    store(vec3(1.00000000, 0.27873596, 0.60514668));\n    store(vec3(1.00000000, 0.28212680, 0.59194341));\n    store(vec3(1.00000000, 0.28544722, 0.57844860));\n    store(vec3(1.00000000, 0.28870405, 0.56462069));\n    store(vec3(1.00000000, 0.29190363, 0.55041305));\n    store(vec3(1.00000000, 0.29505187, 0.53577276));\n    store(vec3(1.00000000, 0.29815435, 0.52063914));\n    \n    //  hpluv\n    dst_fc = ivec2(0, 2);\n    \n    store(vec3(0.77376203, 0.48532689, 0.54388480));\n    store(vec3(0.77313847, 0.48631019, 0.53829628));\n    store(vec3(0.77241461, 0.48733840, 0.53268725));\n    store(vec3(0.77159145, 0.48841012, 0.52706005));\n    store(vec3(0.77066998, 0.48952391, 0.52141708));\n    store(vec3(0.76965122, 0.49067834, 0.51576076));\n    store(vec3(0.76853613, 0.49187197, 0.51009356));\n    store(vec3(0.76732568, 0.49310338, 0.50441802));\n    store(vec3(0.76602085, 0.49437113, 0.49873672));\n    store(vec3(0.76462257, 0.49567378, 0.49305231));\n    store(vec3(0.76313179, 0.49700992, 0.48736749));\n    store(vec3(0.76154942, 0.49837812, 0.48168505));\n    store(vec3(0.75987637, 0.49977699, 0.47600783));\n    store(vec3(0.75811354, 0.50120513, 0.47033879));\n    store(vec3(0.75626180, 0.50266116, 0.46468093));\n    store(vec3(0.75432202, 0.50414372, 0.45903738));\n    store(vec3(0.75229504, 0.50565146, 0.45341134));\n    store(vec3(0.75018169, 0.50718306, 0.44780612));\n    store(vec3(0.74798279, 0.50873720, 0.44222517));\n    store(vec3(0.74569912, 0.51031260, 0.43667200));\n    store(vec3(0.74333145, 0.51190800, 0.43115030));\n    store(vec3(0.74088056, 0.51352213, 0.42566386));\n    store(vec3(0.73834717, 0.51515379, 0.42021661));\n    store(vec3(0.73573200, 0.51680176, 0.41481262));\n    store(vec3(0.73303575, 0.51846487, 0.40945611));\n    store(vec3(0.73025911, 0.52014197, 0.40415147));\n    store(vec3(0.72740272, 0.52183193, 0.39890324));\n    store(vec3(0.72446723, 0.52353363, 0.39371611));\n    store(vec3(0.72145325, 0.52524600, 0.38859497));\n    store(vec3(0.71836139, 0.52696798, 0.38354486));\n    store(vec3(0.71519221, 0.52869853, 0.37857101));\n    store(vec3(0.71194628, 0.53043665, 0.37367883));\n    store(vec3(0.70862413, 0.53218135, 0.36887388));\n    store(vec3(0.70522628, 0.53393165, 0.36416194));\n    store(vec3(0.70175320, 0.53568663, 0.35954893));\n    store(vec3(0.69820538, 0.53744537, 0.35504094));\n    store(vec3(0.69458327, 0.53920696, 0.35064425));\n    store(vec3(0.69088728, 0.54097054, 0.34636524));\n    store(vec3(0.68711784, 0.54273526, 0.34221046));\n    store(vec3(0.68327531, 0.54450028, 0.33818656));\n    store(vec3(0.67936006, 0.54626480, 0.33430029));\n    store(vec3(0.67537244, 0.54802803, 0.33055848));\n    store(vec3(0.67131277, 0.54978920, 0.32696799));\n    store(vec3(0.66718133, 0.55154755, 0.32353570));\n    store(vec3(0.66297840, 0.55330236, 0.32026845));\n    store(vec3(0.65870425, 0.55505292, 0.31717305));\n    store(vec3(0.65435909, 0.55679852, 0.31425616));\n    store(vec3(0.64994315, 0.55853850, 0.31152431));\n    store(vec3(0.64545660, 0.56027218, 0.30898381));\n    store(vec3(0.64089962, 0.56199892, 0.30664074));\n    store(vec3(0.63627235, 0.56371809, 0.30450084));\n    store(vec3(0.63157492, 0.56542907, 0.30256951));\n    store(vec3(0.62680741, 0.56713127, 0.30085171));\n    store(vec3(0.62196992, 0.56882409, 0.29935196));\n    store(vec3(0.61706250, 0.57050695, 0.29807425));\n    store(vec3(0.61208519, 0.57217930, 0.29702200));\n    store(vec3(0.60703799, 0.57384058, 0.29619805));\n    store(vec3(0.60192091, 0.57549025, 0.29560457));\n    store(vec3(0.59673391, 0.57712779, 0.29524311));\n    store(vec3(0.59147694, 0.57875267, 0.29511452));\n    store(vec3(0.58614992, 0.58036439, 0.29521893));\n    store(vec3(0.58075276, 0.58196244, 0.29555583));\n    store(vec3(0.57528534, 0.58354634, 0.29612398));\n    store(vec3(0.56974752, 0.58511561, 0.29692147));\n    store(vec3(0.56413914, 0.58666975, 0.29794577));\n    store(vec3(0.55846000, 0.58820833, 0.29919369));\n    store(vec3(0.55270991, 0.58973086, 0.30066148));\n    store(vec3(0.54688862, 0.59123689, 0.30234485));\n    store(vec3(0.54099588, 0.59272598, 0.30423901));\n    store(vec3(0.53503142, 0.59419769, 0.30633873));\n    store(vec3(0.52899493, 0.59565158, 0.30863839));\n    store(vec3(0.52288609, 0.59708721, 0.31113203));\n    store(vec3(0.51670454, 0.59850415, 0.31381342));\n    store(vec3(0.51044991, 0.59990199, 0.31667608));\n    store(vec3(0.50412179, 0.60128030, 0.31971338));\n    store(vec3(0.49771976, 0.60263866, 0.32291855));\n    store(vec3(0.49124337, 0.60397666, 0.32628472));\n    store(vec3(0.48469214, 0.60529389, 0.32980500));\n    store(vec3(0.47806555, 0.60658994, 0.33347250));\n    store(vec3(0.47136307, 0.60786440, 0.33728035));\n    store(vec3(0.46458414, 0.60911687, 0.34122176));\n    store(vec3(0.45772815, 0.61034694, 0.34529000));\n    store(vec3(0.45079449, 0.61155421, 0.34947849));\n    store(vec3(0.44378249, 0.61273827, 0.35378076));\n    store(vec3(0.43669145, 0.61389874, 0.35819050));\n    store(vec3(0.42952065, 0.61503519, 0.36270155));\n    store(vec3(0.42226932, 0.61614725, 0.36730793));\n    store(vec3(0.41493666, 0.61723450, 0.37200384));\n    store(vec3(0.40752182, 0.61829656, 0.37678364));\n    store(vec3(0.40002391, 0.61933301, 0.38164191));\n    store(vec3(0.39244200, 0.62034346, 0.38657339));\n    store(vec3(0.38477510, 0.62132750, 0.39157302));\n    store(vec3(0.37702219, 0.62228475, 0.39663591));\n    store(vec3(0.36918217, 0.62321480, 0.40175737));\n    store(vec3(0.36125390, 0.62411724, 0.40693286));\n    store(vec3(0.35323617, 0.62499167, 0.41215802));\n    store(vec3(0.34512771, 0.62583770, 0.41742867));\n    store(vec3(0.33692715, 0.62665492, 0.42274078));\n    store(vec3(0.32863307, 0.62744292, 0.42809046));\n    store(vec3(0.32024395, 0.62820131, 0.43347398));\n    store(vec3(0.31175818, 0.62892967, 0.43888775));\n    store(vec3(0.30317404, 0.62962760, 0.44432830));\n    store(vec3(0.29448971, 0.63029470, 0.44979231));\n    store(vec3(0.28570321, 0.63093056, 0.45527656));\n    store(vec3(0.27681246, 0.63153478, 0.46077794));\n    store(vec3(0.26781520, 0.63210694, 0.46629346));\n    store(vec3(0.25870900, 0.63264665, 0.47182022));\n    store(vec3(0.24949124, 0.63315350, 0.47735542));\n    store(vec3(0.24015905, 0.63362708, 0.48289635));\n    store(vec3(0.23070936, 0.63406699, 0.48844036));\n    store(vec3(0.22113876, 0.63447283, 0.49398491));\n    store(vec3(0.21144355, 0.63484420, 0.49952751));\n    store(vec3(0.20161963, 0.63518070, 0.50506574));\n    store(vec3(0.19166248, 0.63548193, 0.51059723));\n    store(vec3(0.18156704, 0.63574750, 0.51611970));\n    store(vec3(0.17132768, 0.63597702, 0.52163090));\n    store(vec3(0.16093803, 0.63617010, 0.52712861));\n    store(vec3(0.15039088, 0.63632635, 0.53261069));\n    store(vec3(0.13967796, 0.63644540, 0.53807503));\n    store(vec3(0.12878977, 0.63652688, 0.54351954));\n    store(vec3(0.11771520, 0.63657040, 0.54894218));\n    store(vec3(0.10644119, 0.63657562, 0.55434095));\n    store(vec3(0.09495214, 0.63654217, 0.55971385));\n    store(vec3(0.08322912, 0.63646970, 0.56505893));\n    store(vec3(0.07124879, 0.63635787, 0.57037426));\n    store(vec3(0.05898167, 0.63620635, 0.57565793));\n    store(vec3(0.04638953, 0.63601482, 0.58090803));\n    store(vec3(0.03366588, 0.63578296, 0.58612270));\n    store(vec3(0.02268081, 0.63551047, 0.59130007));\n    store(vec3(0.01382801, 0.63519706, 0.59643829));\n    store(vec3(0.00713350, 0.63484245, 0.60153553));\n    store(vec3(0.00262228, 0.63444638, 0.60658996));\n    store(vec3(0.00031832, 0.63400859, 0.61159978));\n    store(vec3(0.00024447, 0.63352886, 0.61656317));\n    store(vec3(0.00242239, 0.63300695, 0.62147833));\n    store(vec3(0.00687250, 0.63244268, 0.62634348));\n    store(vec3(0.01361391, 0.63183585, 0.63115684));\n    store(vec3(0.02266434, 0.63118631, 0.63591662));\n    store(vec3(0.03404008, 0.63049391, 0.64062106));\n    store(vec3(0.04728712, 0.62975853, 0.64526839));\n    store(vec3(0.06042656, 0.62898006, 0.64985685));\n    store(vec3(0.07329774, 0.62815844, 0.65438469));\n    store(vec3(0.08593751, 0.62729361, 0.65885016));\n    store(vec3(0.09837384, 0.62638555, 0.66325152));\n    store(vec3(0.11062849, 0.62543427, 0.66758704));\n    store(vec3(0.12271870, 0.62443978, 0.67185498));\n    store(vec3(0.13465841, 0.62340216, 0.67605363));\n    store(vec3(0.14645892, 0.62232149, 0.68018128));\n    store(vec3(0.15812956, 0.62119790, 0.68423622));\n    store(vec3(0.16967804, 0.62003155, 0.68821676));\n    store(vec3(0.18111077, 0.61882263, 0.69212122));\n    store(vec3(0.19243307, 0.61757137, 0.69594792));\n    store(vec3(0.20364941, 0.61627803, 0.69969521));\n    store(vec3(0.21476348, 0.61494291, 0.70336145));\n    store(vec3(0.22577835, 0.61356636, 0.70694500));\n    store(vec3(0.23669653, 0.61214876, 0.71044426));\n    store(vec3(0.24752009, 0.61069053, 0.71385763));\n    store(vec3(0.25825067, 0.60919215, 0.71718354));\n    store(vec3(0.26888957, 0.60765413, 0.72042043));\n    store(vec3(0.27943775, 0.60607701, 0.72356677));\n    store(vec3(0.28989594, 0.60446141, 0.72662105));\n    store(vec3(0.30026458, 0.60280796, 0.72958180));\n    store(vec3(0.31054392, 0.60111738, 0.73244755));\n    store(vec3(0.32073401, 0.59939040, 0.73521689));\n    store(vec3(0.33083474, 0.59762782, 0.73788842));\n    store(vec3(0.34084582, 0.59583049, 0.74046077));\n    store(vec3(0.35076685, 0.59399930, 0.74293262));\n    store(vec3(0.36059728, 0.59213519, 0.74530268));\n    store(vec3(0.37033648, 0.59023918, 0.74756968));\n    store(vec3(0.37998369, 0.58831230, 0.74973243));\n    store(vec3(0.38953809, 0.58635566, 0.75178973));\n    store(vec3(0.39899877, 0.58437042, 0.75374047));\n    store(vec3(0.40836473, 0.58235779, 0.75558355));\n    store(vec3(0.41763496, 0.58031903, 0.75731794));\n    store(vec3(0.42680835, 0.57825545, 0.75894263));\n    store(vec3(0.43588377, 0.57616843, 0.76045669));\n    store(vec3(0.44486004, 0.57405937, 0.76185923));\n    store(vec3(0.45373596, 0.57192975, 0.76314941));\n    store(vec3(0.46251029, 0.56978109, 0.76432643));\n    store(vec3(0.47118177, 0.56761497, 0.76538957));\n    store(vec3(0.47974914, 0.56543299, 0.76633815));\n    store(vec3(0.48821113, 0.56323683, 0.76717156));\n    store(vec3(0.49656643, 0.56102821, 0.76788924));\n    store(vec3(0.50481377, 0.55880887, 0.76849069));\n    store(vec3(0.51295187, 0.55658063, 0.76897547));\n    store(vec3(0.52097945, 0.55434533, 0.76934320));\n    store(vec3(0.52889525, 0.55210485, 0.76959357));\n    store(vec3(0.53669803, 0.54986113, 0.76972634));\n    store(vec3(0.54438655, 0.54761611, 0.76974130));\n    store(vec3(0.55195962, 0.54537178, 0.76963835));\n    store(vec3(0.55941605, 0.54313018, 0.76941741));\n    store(vec3(0.56675469, 0.54089335, 0.76907850));\n    store(vec3(0.57397442, 0.53866336, 0.76862168));\n    store(vec3(0.58107417, 0.53644233, 0.76804709));\n    store(vec3(0.58805287, 0.53423235, 0.76735494));\n    store(vec3(0.59490953, 0.53203557, 0.76654547));\n    store(vec3(0.60164317, 0.52985413, 0.76561902));\n    store(vec3(0.60825287, 0.52769018, 0.76457599));\n    store(vec3(0.61473775, 0.52554588, 0.76341682));\n    store(vec3(0.62109698, 0.52342338, 0.76214203));\n    store(vec3(0.62732976, 0.52132485, 0.76075220));\n    store(vec3(0.63343538, 0.51925243, 0.75924798));\n    store(vec3(0.63941314, 0.51720825, 0.75763005));\n    store(vec3(0.64526241, 0.51519444, 0.75589919));\n    store(vec3(0.65098261, 0.51321309, 0.75405620));\n    store(vec3(0.65657321, 0.51126628, 0.75210196));\n    store(vec3(0.66203375, 0.50935606, 0.75003740));\n    store(vec3(0.66736380, 0.50748443, 0.74786350));\n    store(vec3(0.67256300, 0.50565337, 0.74558130));\n    store(vec3(0.67763105, 0.50386481, 0.74319188));\n    store(vec3(0.68256768, 0.50212063, 0.74069639));\n    store(vec3(0.68737271, 0.50042268, 0.73809601));\n    store(vec3(0.69204599, 0.49877271, 0.73539197));\n    store(vec3(0.69658743, 0.49717246, 0.73258555));\n    store(vec3(0.70099699, 0.49562358, 0.72967808));\n    store(vec3(0.70527469, 0.49412765, 0.72667091));\n    store(vec3(0.70942060, 0.49268619, 0.72356546));\n    store(vec3(0.71343485, 0.49130063, 0.72036315));\n    store(vec3(0.71731761, 0.48997234, 0.71706549));\n    store(vec3(0.72106909, 0.48870260, 0.71367397));\n    store(vec3(0.72468958, 0.48749260, 0.71019016));\n    store(vec3(0.72817938, 0.48634345, 0.70661562));\n    store(vec3(0.73153887, 0.48525618, 0.70295198));\n    store(vec3(0.73476846, 0.48423170, 0.69920088));\n    store(vec3(0.73786860, 0.48327086, 0.69536398));\n    store(vec3(0.74083978, 0.48237439, 0.69144297));\n    store(vec3(0.74368255, 0.48154294, 0.68743958));\n    store(vec3(0.74639748, 0.48077706, 0.68335555));\n    store(vec3(0.74898519, 0.48007720, 0.67919264));\n    store(vec3(0.75144632, 0.47944371, 0.67495264));\n    store(vec3(0.75378156, 0.47887685, 0.67063736));\n    store(vec3(0.75599162, 0.47837679, 0.66624860));\n    store(vec3(0.75807727, 0.47794357, 0.66178823));\n    store(vec3(0.76003927, 0.47757719, 0.65725808));\n    store(vec3(0.76187844, 0.47727751, 0.65266004));\n    store(vec3(0.76359560, 0.47704432, 0.64799599));\n    store(vec3(0.76519162, 0.47687733, 0.64326784));\n    store(vec3(0.76666736, 0.47677614, 0.63847750));\n    store(vec3(0.76802375, 0.47674028, 0.63362690));\n    store(vec3(0.76926168, 0.47676919, 0.62871798));\n    store(vec3(0.77038212, 0.47686225, 0.62375270));\n    store(vec3(0.77138599, 0.47701875, 0.61873303));\n    store(vec3(0.77227429, 0.47723791, 0.61366095));\n    store(vec3(0.77304798, 0.47751888, 0.60853846));\n    store(vec3(0.77370807, 0.47786075, 0.60336757));\n    store(vec3(0.77425556, 0.47826255, 0.59815030));\n    store(vec3(0.77469145, 0.47872325, 0.59288869));\n    store(vec3(0.77501676, 0.47924176, 0.58758481));\n    store(vec3(0.77523253, 0.47981696, 0.58224072));\n    store(vec3(0.77533977, 0.48044767, 0.57685852));\n    store(vec3(0.77533953, 0.48113266, 0.57144031));\n    store(vec3(0.77523282, 0.48187069, 0.56598824));\n    store(vec3(0.77502069, 0.48266046, 0.56050446));\n    store(vec3(0.77470416, 0.48350065, 0.55499115));\n    store(vec3(0.77428427, 0.48438992, 0.54945052));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    float ready = texelFetch(iChannel0, ivec2(0, 0), 0).x;\n    \n    \n    fc = ivec2(fragCoord);\n    data = texelFetch(iChannel0, fc, 0);\n    \n    if (ready != 1.0) {\n        store_all_data();\n    }\n    \n    fragColor = data;\n    \n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dByzK.jpg", "access": "api", "license": "libpng AND cc0-1.0", "functions": [[3563, 3563, 3600, 3600, 3763], [3765, 3765, 3822, 3822, 4890]], "test": "untested"}
{"id": "WsSyzK", "name": "h[sp]luv Fourier series", "author": "mattz", "description": "It's [url]https://www.shadertoy.com/view/tdBcRG[/url] but with Fourier series.", "tags": ["colormap", "fourier", "hsluv", "hpluv", "fitcolormap"], "likes": 2, "viewed": 320, "published": 3, "date": "1586915492", "time_retrieved": "2024-07-30T21:12:45.356419", "image_code": "// fitting rational polynomials to HSLuv and HPLuv colormaps\n//\n// License CC0 (public domain) \n//   https://creativecommons.org/share-your-work/public-domain/cc0/\n//\n// like https://www.shadertoy.com/view/tdBcRG but with rational polynomials \n//\n// outputs, bottom to top:\n//\n//   1) original HSLuv values computed from https://github.com/hsluv/hsluv-python\n//   2) Fourier fit \n//   3) original HPLuv values from https://github.com/hsluv/hsluv-python\n//   4) Fourier fit \n//\n// I might play around with other ways of approximating these functions\n\nvec3 hsluv(float t) {\n\n    t *= 6.283185307179586;\n\n    vec2 cs1 = vec2(cos(t), sin(t));\n    vec2 cs2 = vec2(cos(2.0*t), sin(2.0*t));\n    vec2 cs3 = vec2(cos(3.0*t), sin(3.0*t));\n\n    vec3 p = vec3(0.4583040035795564, 0.4226990280106653, 0.4727729414154237);\n    p += vec3(0.6170329948525921, -0.1888829613996365, -0.05349878095695151)*cs1.x;\n    p += vec3(-0.002078927113488328, 0.09658721174877186, -0.6178501553877714)*cs1.y;\n    p += vec3(-0.01706265814602095, -0.03406876642641538, 0.01381827001423946)*cs2.x;\n    p += vec3(-0.1136674359039428, 0.07588882701812819, -0.1422138970855871)*cs2.y;\n    p += vec3(-0.04646079965938044, 0.02472070929461941, -0.02796074953468969)*cs3.x;\n    p += vec3(-0.02750642491382323, 0.0318915903730297, -0.001136745851157035)*cs3.y;\n\n    return p;\n\n}\n\nvec3 hpluv(float t) {\n\n    t *= 6.283185307179586;\n\n    vec2 cs1 = vec2(cos(t), sin(t));\n    vec2 cs2 = vec2(cos(2.0*t), sin(2.0*t));\n    vec2 cs3 = vec2(cos(3.0*t), sin(3.0*t));\n\n    vec3 p = vec3(0.4968063059221627, 0.5618333859745097, 0.5510421819773226);\n    p += vec3(0.3066278796880508, -0.07557555979479245, -0.02393255205167453)*cs1.x;\n    p += vec3(0.006933868451596256, 0.02349037199369985, -0.2307307577234144)*cs1.y;\n    p += vec3(-0.1008581996939159, -0.00141048492710627, 0.01659010858020084)*cs2.x;\n    p += vec3(-0.02868887242067145, 0.006950707797190328, -0.005145635832538298)*cs2.y;\n    p += vec3(0.04088373861970857, 0.000405153310468609, 0.001758721162936079)*cs3.x;\n    p += vec3(0.01509681275315977, 0.0005140072119704242, 0.004740635303920903)*cs3.y;\n\n    return p;\n\n}\n\n\nvec3 paletteLUT(float row, float u) {\n    \n    vec2 uv;\n    \n    uv.x = mix(0.5, 254.5, u);\n    uv.y = 0.5 + row;\n    \n    uv /= iResolution.xy;\n    \n    return texture(iChannel0, uv, 0.0).xyz;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    float u = fragCoord.x / iResolution.x;\n    \n    //fragColor = vec4(paletteLUT(2.0, u), 1);\n    \n    \n    float y;\n    vec2 uv;\n    \n    if (max(iMouse.z, iMouse.w) > 0.) {\n        \n        uv = fragCoord / iResolution.xy;\n        y = floor(iMouse.y * 4. / iResolution.y );\n        \n    } else {\n\n        const float m = 2.0;\n\n        vec2 dims = iResolution.xy - vec2(2.*m, 2.*m);\n\n        float h = floor(0.25*dims.y);\n\n        dims.y = 4.0*h;\n\n        fragCoord -= 0.5*(iResolution.xy-dims) + mod(m, 2.)*0.5;\n\n        y = floor(fragCoord.y / h);\n\n        uv = fragCoord / dims;\n\n        float b = mod(fragCoord.y + 0.5*h, h);\n\n        if (abs(b - 0.5*h) < 0.5*m || uv.x < 0. || uv.x >= 1.) {\n            y = -1.;\n        }\n        \n    }\n\n    fragColor = vec4(0, 0, 0, 1);\n    \n    if (y == 0.) {\n        fragColor.xyz = paletteLUT(1.0, uv.x);\n    } else if (y == 1.) {\n        fragColor.xyz = hsluv(uv.x);\n    } else if (y == 2.) {\n        fragColor.xyz = paletteLUT(2.0, uv.x);\n    } else if (y == 3.) {\n        fragColor.xyz = hpluv(uv.x);\n    }\n\n    \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// just some ugly code to store two 256-color palettes on the first frame\n// and then just recycle the same texture data over and over\n\nvec4 data = vec4(0);\nivec2 fc;\nivec2 dst_fc;\n\nvoid store(vec3 f) { \n\n    if (dst_fc == fc) {\n        data.xyz = f;\n    }\n    dst_fc.x += 1;\n    \n}\n    \n\nvoid store_all_data() {\n    \n    // initialization\n    dst_fc = ivec2(0, 0);\n    store(vec3(1));\n    \n    //  hsluv\n    dst_fc = ivec2(0, 1);\n\n    store(vec3(1.00000000, 0.30121629, 0.50494183));\n    store(vec3(1.00000000, 0.30424269, 0.48859814));\n    store(vec3(1.00000000, 0.30723827, 0.47150960));\n    store(vec3(1.00000000, 0.31020757, 0.45355707));\n    store(vec3(1.00000000, 0.31315497, 0.43459376));\n    store(vec3(1.00000000, 0.31608470, 0.41443505));\n    store(vec3(1.00000000, 0.31900088, 0.39284280));\n    store(vec3(1.00000000, 0.32190755, 0.36950044));\n    store(vec3(1.00000000, 0.32480869, 0.34397071));\n    store(vec3(1.00000000, 0.32770824, 0.31561901));\n    store(vec3(1.00000000, 0.33061011, 0.28346037));\n    store(vec3(1.00000000, 0.33351823, 0.24580988));\n    store(vec3(1.00000000, 0.33643658, 0.19930106));\n    store(vec3(1.00000000, 0.33936915, 0.13485350));\n    store(vec3(0.99938278, 0.34294341, 0.00000000));\n    store(vec3(0.98103890, 0.36328996, 0.00000000));\n    store(vec3(0.96398111, 0.38063200, 0.00000000));\n    store(vec3(0.94804995, 0.39566226, 0.00000000));\n    store(vec3(0.93311126, 0.40886353, 0.00000000));\n    store(vec3(0.91905123, 0.42058609, 0.00000000));\n    store(vec3(0.90577258, 0.43109219, 0.00000000));\n    store(vec3(0.89319158, 0.44058314, 0.00000000));\n    store(vec3(0.88123570, 0.44921665, 0.00000000));\n    store(vec3(0.86984172, 0.45711848, 0.00000000));\n    store(vec3(0.85895421, 0.46439037, 0.00000000));\n    store(vec3(0.84852436, 0.47111567, 0.00000000));\n    store(vec3(0.83850891, 0.47736349, 0.00000000));\n    store(vec3(0.82886937, 0.48319162, 0.00000000));\n    store(vec3(0.81957135, 0.48864889, 0.00000000));\n    store(vec3(0.81058393, 0.49377685, 0.00000000));\n    store(vec3(0.80187924, 0.49861111, 0.00000000));\n    store(vec3(0.79343202, 0.50318241, 0.00000000));\n    store(vec3(0.78521930, 0.50751744, 0.00000000));\n    store(vec3(0.77722010, 0.51163952, 0.00000000));\n    store(vec3(0.76941516, 0.51556910, 0.00000000));\n    store(vec3(0.76178675, 0.51932422, 0.00000000));\n    store(vec3(0.75431846, 0.52292090, 0.00000000));\n    store(vec3(0.74699506, 0.52637336, 0.00000000));\n    store(vec3(0.73980232, 0.52969434, 0.00000000));\n    store(vec3(0.73272689, 0.53289526, 0.00000000));\n    store(vec3(0.72575624, 0.53598642, 0.00000000));\n    store(vec3(0.71887847, 0.53897714, 0.00000000));\n    store(vec3(0.71208228, 0.54187587, 0.00000000));\n    store(vec3(0.70535689, 0.54469030, 0.00000000));\n    store(vec3(0.69869191, 0.54742748, 0.00000000));\n    store(vec3(0.69207733, 0.55009387, 0.00000000));\n    store(vec3(0.68550341, 0.55269543, 0.00000000));\n    store(vec3(0.67896066, 0.55523763, 0.00000000));\n    store(vec3(0.67243972, 0.55772559, 0.00000000));\n    store(vec3(0.66593138, 0.56016404, 0.00000000));\n    store(vec3(0.65942647, 0.56255741, 0.00000000));\n    store(vec3(0.65291579, 0.56490986, 0.00000000));\n    store(vec3(0.64639012, 0.56722529, 0.00000000));\n    store(vec3(0.63984010, 0.56950739, 0.00000000));\n    store(vec3(0.63325622, 0.57175966, 0.00000000));\n    store(vec3(0.62662870, 0.57398544, 0.00000000));\n    store(vec3(0.61994748, 0.57618791, 0.00000000));\n    store(vec3(0.61320212, 0.57837014, 0.00000000));\n    store(vec3(0.60638172, 0.58053508, 0.00000000));\n    store(vec3(0.59947486, 0.58268560, 0.00000000));\n    store(vec3(0.59246946, 0.58482449, 0.00000000));\n    store(vec3(0.58535273, 0.58695447, 0.00000000));\n    store(vec3(0.57811102, 0.58907823, 0.00000000));\n    store(vec3(0.57072965, 0.59119842, 0.00000000));\n    store(vec3(0.56319283, 0.59331768, 0.00000000));\n    store(vec3(0.55548341, 0.59543864, 0.00000000));\n    store(vec3(0.54758269, 0.59756393, 0.00000000));\n    store(vec3(0.53947016, 0.59969620, 0.00000000));\n    store(vec3(0.53112323, 0.60183817, 0.00000000));\n    store(vec3(0.52251683, 0.60399256, 0.00000000));\n    store(vec3(0.51362298, 0.60616218, 0.00000000));\n    store(vec3(0.50441030, 0.60834992, 0.00000000));\n    store(vec3(0.49484329, 0.61055876, 0.00000000));\n    store(vec3(0.48488160, 0.61279177, 0.00000000));\n    store(vec3(0.47447892, 0.61505220, 0.00000000));\n    store(vec3(0.46358172, 0.61734339, 0.00000000));\n    store(vec3(0.45212752, 0.61966890, 0.00000000));\n    store(vec3(0.44004269, 0.62203246, 0.00000000));\n    store(vec3(0.42723940, 0.62443802, 0.00000000));\n    store(vec3(0.41361153, 0.62688979, 0.00000000));\n    store(vec3(0.39902889, 0.62939226, 0.00000000));\n    store(vec3(0.38332885, 0.63195025, 0.00000000));\n    store(vec3(0.36630386, 0.63456891, 0.00000000));\n    store(vec3(0.34768201, 0.63725384, 0.00000000));\n    store(vec3(0.32709527, 0.64001106, 0.00000000));\n    store(vec3(0.30402406, 0.64284713, 0.00000000));\n    store(vec3(0.27769245, 0.64576921, 0.00000000));\n    store(vec3(0.24684646, 0.64878511, 0.00000000));\n    store(vec3(0.20920095, 0.65190340, 0.00000000));\n    store(vec3(0.15962948, 0.65513354, 0.00000000));\n    store(vec3(0.07929463, 0.65848596, 0.00000000));\n    store(vec3(-0.00000000, 0.65946658, 0.08707563));\n    store(vec3(-0.00000000, 0.65835467, 0.16265107));\n    store(vec3(-0.00000000, 0.65730351, 0.21004012));\n    store(vec3(-0.00000000, 0.65630709, 0.24593491));\n    store(vec3(-0.00000000, 0.65536010, 0.27517292));\n    store(vec3(-0.00000000, 0.65445788, 0.29995945));\n    store(vec3(-0.00000000, 0.65359632, 0.32151992));\n    store(vec3(-0.00000000, 0.65277173, 0.34061858));\n    store(vec3(-0.00000000, 0.65198085, 0.35776980));\n    store(vec3(-0.00000000, 0.65122074, 0.37333917));\n    store(vec3(-0.00000000, 0.65048877, 0.38759726));\n    store(vec3(-0.00000000, 0.64978257, 0.40075079));\n    store(vec3(-0.00000000, 0.64909997, 0.41296172));\n    store(vec3(-0.00000000, 0.64843902, 0.42435963));\n    store(vec3(-0.00000000, 0.64779795, 0.43504997));\n    store(vec3(-0.00000000, 0.64717512, 0.44511986));\n    store(vec3(-0.00000000, 0.64656904, 0.45464215));\n    store(vec3(-0.00000000, 0.64597833, 0.46367847));\n    store(vec3(-0.00000000, 0.64540172, 0.47228148));\n    store(vec3(-0.00000000, 0.64483805, 0.48049652));\n    store(vec3(-0.00000000, 0.64428620, 0.48836298));\n    store(vec3(-0.00000000, 0.64374517, 0.49591531));\n    store(vec3(-0.00000000, 0.64321401, 0.50318385));\n    store(vec3(-0.00000000, 0.64269180, 0.51019547));\n    store(vec3(-0.00000000, 0.64217771, 0.51697412));\n    store(vec3(-0.00000000, 0.64167095, 0.52354124));\n    store(vec3(-0.00000000, 0.64117075, 0.52991616));\n    store(vec3(-0.00000000, 0.64067638, 0.53611635));\n    store(vec3(-0.00000000, 0.64018716, 0.54215772));\n    store(vec3(-0.00000000, 0.63970242, 0.54805479));\n    store(vec3(-0.00000000, 0.63922152, 0.55382090));\n    store(vec3(-0.00000000, 0.63874383, 0.55946835));\n    store(vec3(-0.00000000, 0.63826874, 0.56500853));\n    store(vec3(-0.00000000, 0.63779567, 0.57045206));\n    store(vec3(-0.00000000, 0.63732402, 0.57580885));\n    store(vec3(-0.00000000, 0.63685323, 0.58108822));\n    store(vec3(-0.00000000, 0.63638270, 0.58629898));\n    store(vec3(-0.00000000, 0.63591188, 0.59144948));\n    store(vec3(-0.00000000, 0.63544019, 0.59654768));\n    store(vec3(-0.00000000, 0.63496705, 0.60160122));\n    store(vec3(-0.00000000, 0.63449188, 0.60661746));\n    store(vec3(-0.00000000, 0.63401408, 0.61160351));\n    store(vec3(-0.00000000, 0.63353304, 0.61656634));\n    store(vec3(-0.00000000, 0.63304814, 0.62151273));\n    store(vec3(-0.00000000, 0.63255874, 0.62644937));\n    store(vec3(-0.00000000, 0.63206417, 0.63138291));\n    store(vec3(-0.00000000, 0.63156373, 0.63631995));\n    store(vec3(-0.00000000, 0.63105670, 0.64126711));\n    store(vec3(-0.00000000, 0.63054232, 0.64623104));\n    store(vec3(-0.00000000, 0.63001980, 0.65121850));\n    store(vec3(-0.00000000, 0.62948827, 0.65623637));\n    store(vec3(-0.00000000, 0.62894685, 0.66129169));\n    store(vec3(-0.00000000, 0.62839457, 0.66639169));\n    store(vec3(-0.00000000, 0.62783043, 0.67154389));\n    store(vec3(-0.00000000, 0.62725331, 0.67675607));\n    store(vec3(-0.00000000, 0.62666204, 0.68203638));\n    store(vec3(-0.00000000, 0.62605535, 0.68739338));\n    store(vec3(-0.00000000, 0.62543185, 0.69283610));\n    store(vec3(-0.00000000, 0.62479005, 0.69837408));\n    store(vec3(-0.00000000, 0.62412831, 0.70401750));\n    store(vec3(-0.00000000, 0.62344485, 0.70977724));\n    store(vec3(-0.00000000, 0.62273770, 0.71566496));\n    store(vec3(-0.00000000, 0.62200470, 0.72169322));\n    store(vec3(-0.00000000, 0.62124347, 0.72787563));\n    store(vec3(-0.00000000, 0.62045135, 0.73422693));\n    store(vec3(-0.00000000, 0.61962541, 0.74076322));\n    store(vec3(-0.00000000, 0.61876235, 0.74750212));\n    store(vec3(-0.00000000, 0.61785849, 0.75446297));\n    store(vec3(-0.00000000, 0.61690969, 0.76166711));\n    store(vec3(-0.00000000, 0.61591125, 0.76913818));\n    store(vec3(-0.00000000, 0.61485787, 0.77690246));\n    store(vec3(-0.00000000, 0.61374346, 0.78498930));\n    store(vec3(-0.00000000, 0.61256110, 0.79343160));\n    store(vec3(-0.00000000, 0.61130279, 0.80226646));\n    store(vec3(-0.00000000, 0.60995926, 0.81153584));\n    store(vec3(-0.00000000, 0.60851972, 0.82128751));\n    store(vec3(-0.00000000, 0.60697156, 0.83157609));\n    store(vec3(-0.00000000, 0.60529985, 0.84246439));\n    store(vec3(-0.00000000, 0.60348686, 0.85402511));\n    store(vec3(-0.00000000, 0.60151136, 0.86634292));\n    store(vec3(-0.00000000, 0.59934768, 0.87951712));\n    store(vec3(-0.00000000, 0.59696448, 0.89366506));\n    store(vec3(-0.00000000, 0.59432308, 0.90892663));\n    store(vec3(-0.00000000, 0.59137524, 0.92547006));\n    store(vec3(-0.00000000, 0.58805989, 0.94349976));\n    store(vec3(-0.00000000, 0.58429861, 0.96326697));\n    store(vec3(-0.00000000, 0.57998894, 0.98508443));\n    store(vec3(0.08705126, 0.57476151, 1.00000000));\n    store(vec3(0.18908055, 0.56888970, 1.00000000));\n    store(vec3(0.25096602, 0.56299884, 1.00000000));\n    store(vec3(0.29857943, 0.55708036, 1.00000000));\n    store(vec3(0.33829712, 0.55112550, 1.00000000));\n    store(vec3(0.37286526, 0.54512525, 1.00000000));\n    store(vec3(0.40376097, 0.53907028, 1.00000000));\n    store(vec3(0.43188612, 0.53295087, 1.00000000));\n    store(vec3(0.45783917, 0.52675684, 1.00000000));\n    store(vec3(0.48204145, 0.52047745, 1.00000000));\n    store(vec3(0.50480322, 0.51410134, 1.00000000));\n    store(vec3(0.52636105, 0.50761639, 1.00000000));\n    store(vec3(0.54690057, 0.50100961, 1.00000000));\n    store(vec3(0.56657090, 0.49426702, 1.00000000));\n    store(vec3(0.58549429, 0.48737345, 1.00000000));\n    store(vec3(0.60377274, 0.48031241, 1.00000000));\n    store(vec3(0.62149273, 0.47306580, 1.00000000));\n    store(vec3(0.63872856, 0.46561370, 1.00000000));\n    store(vec3(0.65554499, 0.45793405, 1.00000000));\n    store(vec3(0.67199909, 0.45000225, 1.00000000));\n    store(vec3(0.68814176, 0.44179069, 1.00000000));\n    store(vec3(0.70401893, 0.43326824, 1.00000000));\n    store(vec3(0.71967246, 0.42439945, 1.00000000));\n    store(vec3(0.73514093, 0.41514376, 1.00000000));\n    store(vec3(0.75046027, 0.40545427, 1.00000000));\n    store(vec3(0.76566427, 0.39527632, 1.00000000));\n    store(vec3(0.78078506, 0.38454554, 1.00000000));\n    store(vec3(0.79585348, 0.37318522, 1.00000000));\n    store(vec3(0.81089946, 0.36110281, 1.00000000));\n    store(vec3(0.82595231, 0.34818486, 1.00000000));\n    store(vec3(0.84104101, 0.33428990, 1.00000000));\n    store(vec3(0.85619454, 0.31923765, 1.00000000));\n    store(vec3(0.87144208, 0.30279243, 1.00000000));\n    store(vec3(0.88681334, 0.28463600, 1.00000000));\n    store(vec3(0.90233881, 0.26432051, 1.00000000));\n    store(vec3(0.91805001, 0.24118003, 1.00000000));\n    store(vec3(0.93397988, 0.21414499, 1.00000000));\n    store(vec3(0.95016302, 0.18128547, 1.00000000));\n    store(vec3(0.96663608, 0.13835170, 1.00000000));\n    store(vec3(0.98343816, 0.07058422, 1.00000000));\n    store(vec3(0.99457977, 0.00000000, 0.99397528));\n    store(vec3(0.99884189, 0.00000000, 0.98126797));\n    store(vec3(1.00000000, 0.03358261, 0.96600934));\n    store(vec3(1.00000000, 0.07043814, 0.95019059));\n    store(vec3(1.00000000, 0.09512532, 0.93487684));\n    store(vec3(1.00000000, 0.11420839, 0.92001832));\n    store(vec3(1.00000000, 0.12993072, 0.90557000));\n    store(vec3(1.00000000, 0.14336377, 0.89149090));\n    store(vec3(1.00000000, 0.15511821, 0.87774352));\n    store(vec3(1.00000000, 0.16558115, 0.86429337));\n    store(vec3(1.00000000, 0.17501610, 0.85110852));\n    store(vec3(1.00000000, 0.18361198, 0.83815927));\n    store(vec3(1.00000000, 0.19150953, 0.82541781));\n    store(vec3(1.00000000, 0.19881690, 0.81285791));\n    store(vec3(1.00000000, 0.20561921, 0.80045473));\n    store(vec3(1.00000000, 0.21198482, 0.78818454));\n    store(vec3(1.00000000, 0.21796959, 0.77602452));\n    store(vec3(1.00000000, 0.22361981, 0.76395256));\n    store(vec3(1.00000000, 0.22897429, 0.75194710));\n    store(vec3(1.00000000, 0.23406599, 0.73998692));\n    store(vec3(1.00000000, 0.23892311, 0.72805097));\n    store(vec3(1.00000000, 0.24357002, 0.71611822));\n    store(vec3(1.00000000, 0.24802792, 0.70416746));\n    store(vec3(1.00000000, 0.25231543, 0.69217711));\n    store(vec3(1.00000000, 0.25644896, 0.68012503));\n    store(vec3(1.00000000, 0.26044310, 0.66798832));\n    store(vec3(1.00000000, 0.26431086, 0.65574306));\n    store(vec3(1.00000000, 0.26806394, 0.64336405));\n    store(vec3(1.00000000, 0.27171290, 0.63082451));\n    store(vec3(1.00000000, 0.27526733, 0.61809574));\n    store(vec3(1.00000000, 0.27873596, 0.60514668));\n    store(vec3(1.00000000, 0.28212680, 0.59194341));\n    store(vec3(1.00000000, 0.28544722, 0.57844860));\n    store(vec3(1.00000000, 0.28870405, 0.56462069));\n    store(vec3(1.00000000, 0.29190363, 0.55041305));\n    store(vec3(1.00000000, 0.29505187, 0.53577276));\n    store(vec3(1.00000000, 0.29815435, 0.52063914));\n    \n    //  hpluv\n    dst_fc = ivec2(0, 2);\n    \n    store(vec3(0.77376203, 0.48532689, 0.54388480));\n    store(vec3(0.77313847, 0.48631019, 0.53829628));\n    store(vec3(0.77241461, 0.48733840, 0.53268725));\n    store(vec3(0.77159145, 0.48841012, 0.52706005));\n    store(vec3(0.77066998, 0.48952391, 0.52141708));\n    store(vec3(0.76965122, 0.49067834, 0.51576076));\n    store(vec3(0.76853613, 0.49187197, 0.51009356));\n    store(vec3(0.76732568, 0.49310338, 0.50441802));\n    store(vec3(0.76602085, 0.49437113, 0.49873672));\n    store(vec3(0.76462257, 0.49567378, 0.49305231));\n    store(vec3(0.76313179, 0.49700992, 0.48736749));\n    store(vec3(0.76154942, 0.49837812, 0.48168505));\n    store(vec3(0.75987637, 0.49977699, 0.47600783));\n    store(vec3(0.75811354, 0.50120513, 0.47033879));\n    store(vec3(0.75626180, 0.50266116, 0.46468093));\n    store(vec3(0.75432202, 0.50414372, 0.45903738));\n    store(vec3(0.75229504, 0.50565146, 0.45341134));\n    store(vec3(0.75018169, 0.50718306, 0.44780612));\n    store(vec3(0.74798279, 0.50873720, 0.44222517));\n    store(vec3(0.74569912, 0.51031260, 0.43667200));\n    store(vec3(0.74333145, 0.51190800, 0.43115030));\n    store(vec3(0.74088056, 0.51352213, 0.42566386));\n    store(vec3(0.73834717, 0.51515379, 0.42021661));\n    store(vec3(0.73573200, 0.51680176, 0.41481262));\n    store(vec3(0.73303575, 0.51846487, 0.40945611));\n    store(vec3(0.73025911, 0.52014197, 0.40415147));\n    store(vec3(0.72740272, 0.52183193, 0.39890324));\n    store(vec3(0.72446723, 0.52353363, 0.39371611));\n    store(vec3(0.72145325, 0.52524600, 0.38859497));\n    store(vec3(0.71836139, 0.52696798, 0.38354486));\n    store(vec3(0.71519221, 0.52869853, 0.37857101));\n    store(vec3(0.71194628, 0.53043665, 0.37367883));\n    store(vec3(0.70862413, 0.53218135, 0.36887388));\n    store(vec3(0.70522628, 0.53393165, 0.36416194));\n    store(vec3(0.70175320, 0.53568663, 0.35954893));\n    store(vec3(0.69820538, 0.53744537, 0.35504094));\n    store(vec3(0.69458327, 0.53920696, 0.35064425));\n    store(vec3(0.69088728, 0.54097054, 0.34636524));\n    store(vec3(0.68711784, 0.54273526, 0.34221046));\n    store(vec3(0.68327531, 0.54450028, 0.33818656));\n    store(vec3(0.67936006, 0.54626480, 0.33430029));\n    store(vec3(0.67537244, 0.54802803, 0.33055848));\n    store(vec3(0.67131277, 0.54978920, 0.32696799));\n    store(vec3(0.66718133, 0.55154755, 0.32353570));\n    store(vec3(0.66297840, 0.55330236, 0.32026845));\n    store(vec3(0.65870425, 0.55505292, 0.31717305));\n    store(vec3(0.65435909, 0.55679852, 0.31425616));\n    store(vec3(0.64994315, 0.55853850, 0.31152431));\n    store(vec3(0.64545660, 0.56027218, 0.30898381));\n    store(vec3(0.64089962, 0.56199892, 0.30664074));\n    store(vec3(0.63627235, 0.56371809, 0.30450084));\n    store(vec3(0.63157492, 0.56542907, 0.30256951));\n    store(vec3(0.62680741, 0.56713127, 0.30085171));\n    store(vec3(0.62196992, 0.56882409, 0.29935196));\n    store(vec3(0.61706250, 0.57050695, 0.29807425));\n    store(vec3(0.61208519, 0.57217930, 0.29702200));\n    store(vec3(0.60703799, 0.57384058, 0.29619805));\n    store(vec3(0.60192091, 0.57549025, 0.29560457));\n    store(vec3(0.59673391, 0.57712779, 0.29524311));\n    store(vec3(0.59147694, 0.57875267, 0.29511452));\n    store(vec3(0.58614992, 0.58036439, 0.29521893));\n    store(vec3(0.58075276, 0.58196244, 0.29555583));\n    store(vec3(0.57528534, 0.58354634, 0.29612398));\n    store(vec3(0.56974752, 0.58511561, 0.29692147));\n    store(vec3(0.56413914, 0.58666975, 0.29794577));\n    store(vec3(0.55846000, 0.58820833, 0.29919369));\n    store(vec3(0.55270991, 0.58973086, 0.30066148));\n    store(vec3(0.54688862, 0.59123689, 0.30234485));\n    store(vec3(0.54099588, 0.59272598, 0.30423901));\n    store(vec3(0.53503142, 0.59419769, 0.30633873));\n    store(vec3(0.52899493, 0.59565158, 0.30863839));\n    store(vec3(0.52288609, 0.59708721, 0.31113203));\n    store(vec3(0.51670454, 0.59850415, 0.31381342));\n    store(vec3(0.51044991, 0.59990199, 0.31667608));\n    store(vec3(0.50412179, 0.60128030, 0.31971338));\n    store(vec3(0.49771976, 0.60263866, 0.32291855));\n    store(vec3(0.49124337, 0.60397666, 0.32628472));\n    store(vec3(0.48469214, 0.60529389, 0.32980500));\n    store(vec3(0.47806555, 0.60658994, 0.33347250));\n    store(vec3(0.47136307, 0.60786440, 0.33728035));\n    store(vec3(0.46458414, 0.60911687, 0.34122176));\n    store(vec3(0.45772815, 0.61034694, 0.34529000));\n    store(vec3(0.45079449, 0.61155421, 0.34947849));\n    store(vec3(0.44378249, 0.61273827, 0.35378076));\n    store(vec3(0.43669145, 0.61389874, 0.35819050));\n    store(vec3(0.42952065, 0.61503519, 0.36270155));\n    store(vec3(0.42226932, 0.61614725, 0.36730793));\n    store(vec3(0.41493666, 0.61723450, 0.37200384));\n    store(vec3(0.40752182, 0.61829656, 0.37678364));\n    store(vec3(0.40002391, 0.61933301, 0.38164191));\n    store(vec3(0.39244200, 0.62034346, 0.38657339));\n    store(vec3(0.38477510, 0.62132750, 0.39157302));\n    store(vec3(0.37702219, 0.62228475, 0.39663591));\n    store(vec3(0.36918217, 0.62321480, 0.40175737));\n    store(vec3(0.36125390, 0.62411724, 0.40693286));\n    store(vec3(0.35323617, 0.62499167, 0.41215802));\n    store(vec3(0.34512771, 0.62583770, 0.41742867));\n    store(vec3(0.33692715, 0.62665492, 0.42274078));\n    store(vec3(0.32863307, 0.62744292, 0.42809046));\n    store(vec3(0.32024395, 0.62820131, 0.43347398));\n    store(vec3(0.31175818, 0.62892967, 0.43888775));\n    store(vec3(0.30317404, 0.62962760, 0.44432830));\n    store(vec3(0.29448971, 0.63029470, 0.44979231));\n    store(vec3(0.28570321, 0.63093056, 0.45527656));\n    store(vec3(0.27681246, 0.63153478, 0.46077794));\n    store(vec3(0.26781520, 0.63210694, 0.46629346));\n    store(vec3(0.25870900, 0.63264665, 0.47182022));\n    store(vec3(0.24949124, 0.63315350, 0.47735542));\n    store(vec3(0.24015905, 0.63362708, 0.48289635));\n    store(vec3(0.23070936, 0.63406699, 0.48844036));\n    store(vec3(0.22113876, 0.63447283, 0.49398491));\n    store(vec3(0.21144355, 0.63484420, 0.49952751));\n    store(vec3(0.20161963, 0.63518070, 0.50506574));\n    store(vec3(0.19166248, 0.63548193, 0.51059723));\n    store(vec3(0.18156704, 0.63574750, 0.51611970));\n    store(vec3(0.17132768, 0.63597702, 0.52163090));\n    store(vec3(0.16093803, 0.63617010, 0.52712861));\n    store(vec3(0.15039088, 0.63632635, 0.53261069));\n    store(vec3(0.13967796, 0.63644540, 0.53807503));\n    store(vec3(0.12878977, 0.63652688, 0.54351954));\n    store(vec3(0.11771520, 0.63657040, 0.54894218));\n    store(vec3(0.10644119, 0.63657562, 0.55434095));\n    store(vec3(0.09495214, 0.63654217, 0.55971385));\n    store(vec3(0.08322912, 0.63646970, 0.56505893));\n    store(vec3(0.07124879, 0.63635787, 0.57037426));\n    store(vec3(0.05898167, 0.63620635, 0.57565793));\n    store(vec3(0.04638953, 0.63601482, 0.58090803));\n    store(vec3(0.03366588, 0.63578296, 0.58612270));\n    store(vec3(0.02268081, 0.63551047, 0.59130007));\n    store(vec3(0.01382801, 0.63519706, 0.59643829));\n    store(vec3(0.00713350, 0.63484245, 0.60153553));\n    store(vec3(0.00262228, 0.63444638, 0.60658996));\n    store(vec3(0.00031832, 0.63400859, 0.61159978));\n    store(vec3(0.00024447, 0.63352886, 0.61656317));\n    store(vec3(0.00242239, 0.63300695, 0.62147833));\n    store(vec3(0.00687250, 0.63244268, 0.62634348));\n    store(vec3(0.01361391, 0.63183585, 0.63115684));\n    store(vec3(0.02266434, 0.63118631, 0.63591662));\n    store(vec3(0.03404008, 0.63049391, 0.64062106));\n    store(vec3(0.04728712, 0.62975853, 0.64526839));\n    store(vec3(0.06042656, 0.62898006, 0.64985685));\n    store(vec3(0.07329774, 0.62815844, 0.65438469));\n    store(vec3(0.08593751, 0.62729361, 0.65885016));\n    store(vec3(0.09837384, 0.62638555, 0.66325152));\n    store(vec3(0.11062849, 0.62543427, 0.66758704));\n    store(vec3(0.12271870, 0.62443978, 0.67185498));\n    store(vec3(0.13465841, 0.62340216, 0.67605363));\n    store(vec3(0.14645892, 0.62232149, 0.68018128));\n    store(vec3(0.15812956, 0.62119790, 0.68423622));\n    store(vec3(0.16967804, 0.62003155, 0.68821676));\n    store(vec3(0.18111077, 0.61882263, 0.69212122));\n    store(vec3(0.19243307, 0.61757137, 0.69594792));\n    store(vec3(0.20364941, 0.61627803, 0.69969521));\n    store(vec3(0.21476348, 0.61494291, 0.70336145));\n    store(vec3(0.22577835, 0.61356636, 0.70694500));\n    store(vec3(0.23669653, 0.61214876, 0.71044426));\n    store(vec3(0.24752009, 0.61069053, 0.71385763));\n    store(vec3(0.25825067, 0.60919215, 0.71718354));\n    store(vec3(0.26888957, 0.60765413, 0.72042043));\n    store(vec3(0.27943775, 0.60607701, 0.72356677));\n    store(vec3(0.28989594, 0.60446141, 0.72662105));\n    store(vec3(0.30026458, 0.60280796, 0.72958180));\n    store(vec3(0.31054392, 0.60111738, 0.73244755));\n    store(vec3(0.32073401, 0.59939040, 0.73521689));\n    store(vec3(0.33083474, 0.59762782, 0.73788842));\n    store(vec3(0.34084582, 0.59583049, 0.74046077));\n    store(vec3(0.35076685, 0.59399930, 0.74293262));\n    store(vec3(0.36059728, 0.59213519, 0.74530268));\n    store(vec3(0.37033648, 0.59023918, 0.74756968));\n    store(vec3(0.37998369, 0.58831230, 0.74973243));\n    store(vec3(0.38953809, 0.58635566, 0.75178973));\n    store(vec3(0.39899877, 0.58437042, 0.75374047));\n    store(vec3(0.40836473, 0.58235779, 0.75558355));\n    store(vec3(0.41763496, 0.58031903, 0.75731794));\n    store(vec3(0.42680835, 0.57825545, 0.75894263));\n    store(vec3(0.43588377, 0.57616843, 0.76045669));\n    store(vec3(0.44486004, 0.57405937, 0.76185923));\n    store(vec3(0.45373596, 0.57192975, 0.76314941));\n    store(vec3(0.46251029, 0.56978109, 0.76432643));\n    store(vec3(0.47118177, 0.56761497, 0.76538957));\n    store(vec3(0.47974914, 0.56543299, 0.76633815));\n    store(vec3(0.48821113, 0.56323683, 0.76717156));\n    store(vec3(0.49656643, 0.56102821, 0.76788924));\n    store(vec3(0.50481377, 0.55880887, 0.76849069));\n    store(vec3(0.51295187, 0.55658063, 0.76897547));\n    store(vec3(0.52097945, 0.55434533, 0.76934320));\n    store(vec3(0.52889525, 0.55210485, 0.76959357));\n    store(vec3(0.53669803, 0.54986113, 0.76972634));\n    store(vec3(0.54438655, 0.54761611, 0.76974130));\n    store(vec3(0.55195962, 0.54537178, 0.76963835));\n    store(vec3(0.55941605, 0.54313018, 0.76941741));\n    store(vec3(0.56675469, 0.54089335, 0.76907850));\n    store(vec3(0.57397442, 0.53866336, 0.76862168));\n    store(vec3(0.58107417, 0.53644233, 0.76804709));\n    store(vec3(0.58805287, 0.53423235, 0.76735494));\n    store(vec3(0.59490953, 0.53203557, 0.76654547));\n    store(vec3(0.60164317, 0.52985413, 0.76561902));\n    store(vec3(0.60825287, 0.52769018, 0.76457599));\n    store(vec3(0.61473775, 0.52554588, 0.76341682));\n    store(vec3(0.62109698, 0.52342338, 0.76214203));\n    store(vec3(0.62732976, 0.52132485, 0.76075220));\n    store(vec3(0.63343538, 0.51925243, 0.75924798));\n    store(vec3(0.63941314, 0.51720825, 0.75763005));\n    store(vec3(0.64526241, 0.51519444, 0.75589919));\n    store(vec3(0.65098261, 0.51321309, 0.75405620));\n    store(vec3(0.65657321, 0.51126628, 0.75210196));\n    store(vec3(0.66203375, 0.50935606, 0.75003740));\n    store(vec3(0.66736380, 0.50748443, 0.74786350));\n    store(vec3(0.67256300, 0.50565337, 0.74558130));\n    store(vec3(0.67763105, 0.50386481, 0.74319188));\n    store(vec3(0.68256768, 0.50212063, 0.74069639));\n    store(vec3(0.68737271, 0.50042268, 0.73809601));\n    store(vec3(0.69204599, 0.49877271, 0.73539197));\n    store(vec3(0.69658743, 0.49717246, 0.73258555));\n    store(vec3(0.70099699, 0.49562358, 0.72967808));\n    store(vec3(0.70527469, 0.49412765, 0.72667091));\n    store(vec3(0.70942060, 0.49268619, 0.72356546));\n    store(vec3(0.71343485, 0.49130063, 0.72036315));\n    store(vec3(0.71731761, 0.48997234, 0.71706549));\n    store(vec3(0.72106909, 0.48870260, 0.71367397));\n    store(vec3(0.72468958, 0.48749260, 0.71019016));\n    store(vec3(0.72817938, 0.48634345, 0.70661562));\n    store(vec3(0.73153887, 0.48525618, 0.70295198));\n    store(vec3(0.73476846, 0.48423170, 0.69920088));\n    store(vec3(0.73786860, 0.48327086, 0.69536398));\n    store(vec3(0.74083978, 0.48237439, 0.69144297));\n    store(vec3(0.74368255, 0.48154294, 0.68743958));\n    store(vec3(0.74639748, 0.48077706, 0.68335555));\n    store(vec3(0.74898519, 0.48007720, 0.67919264));\n    store(vec3(0.75144632, 0.47944371, 0.67495264));\n    store(vec3(0.75378156, 0.47887685, 0.67063736));\n    store(vec3(0.75599162, 0.47837679, 0.66624860));\n    store(vec3(0.75807727, 0.47794357, 0.66178823));\n    store(vec3(0.76003927, 0.47757719, 0.65725808));\n    store(vec3(0.76187844, 0.47727751, 0.65266004));\n    store(vec3(0.76359560, 0.47704432, 0.64799599));\n    store(vec3(0.76519162, 0.47687733, 0.64326784));\n    store(vec3(0.76666736, 0.47677614, 0.63847750));\n    store(vec3(0.76802375, 0.47674028, 0.63362690));\n    store(vec3(0.76926168, 0.47676919, 0.62871798));\n    store(vec3(0.77038212, 0.47686225, 0.62375270));\n    store(vec3(0.77138599, 0.47701875, 0.61873303));\n    store(vec3(0.77227429, 0.47723791, 0.61366095));\n    store(vec3(0.77304798, 0.47751888, 0.60853846));\n    store(vec3(0.77370807, 0.47786075, 0.60336757));\n    store(vec3(0.77425556, 0.47826255, 0.59815030));\n    store(vec3(0.77469145, 0.47872325, 0.59288869));\n    store(vec3(0.77501676, 0.47924176, 0.58758481));\n    store(vec3(0.77523253, 0.47981696, 0.58224072));\n    store(vec3(0.77533977, 0.48044767, 0.57685852));\n    store(vec3(0.77533953, 0.48113266, 0.57144031));\n    store(vec3(0.77523282, 0.48187069, 0.56598824));\n    store(vec3(0.77502069, 0.48266046, 0.56050446));\n    store(vec3(0.77470416, 0.48350065, 0.55499115));\n    store(vec3(0.77428427, 0.48438992, 0.54945052));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    float ready = texelFetch(iChannel0, ivec2(0, 0), 0).x;\n    \n    \n    fc = ivec2(fragCoord);\n    data = texelFetch(iChannel0, fc, 0);\n    \n    if (ready != 1.0) {\n        store_all_data();\n    }\n    \n    fragColor = data;\n    \n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsSyzK.jpg", "access": "api", "license": "libpng AND cc0-1.0", "functions": [[550, 550, 571, 571, 1338], [1340, 1340, 1361, 1361, 2132], [2135, 2135, 2172, 2172, 2335], [2337, 2337, 2394, 2394, 3462]], "test": "untested"}
{"id": "WdSyzK", "name": "h[sp]luv rational poly. fits", "author": "mattz", "description": "It's [url]https://www.shadertoy.com/view/tdBcRG[/url] but with rational polynomials. Same number of coefficients, just more accurate!", "tags": ["colormap", "polynomial", "rational", "hsluv", "hpluv", "fitcolormap"], "likes": 3, "viewed": 314, "published": 3, "date": "1586915488", "time_retrieved": "2024-07-30T21:12:46.437528", "image_code": "// fitting rational polynomials to HSLuv and HPLuv colormaps\n//\n// License CC0 (public domain) \n//   https://creativecommons.org/share-your-work/public-domain/cc0/\n//\n// like https://www.shadertoy.com/view/tdBcRG but with rational polynomials \n//\n// outputs, bottom to top:\n//\n//   1) original HSLuv values computed from https://github.com/hsluv/hsluv-python\n//   2) rational polynomial fit \n//   3) original HPLuv values from https://github.com/hsluv/hsluv-python\n//   4) rational polynomial fit \n//\n// I might play around with other ways of approximating these functions\n\nvec3 hsluv(float t) {\n\n    const vec3 n0 = vec3(1275.554287582255, 0.2356206875296278, 0.5314314932700273);\n    const vec3 n1 = vec3(95695.15043272317, 5.804371145618021, -10.99607420480514);\n    const vec3 n2 = vec3(-419158.8935247003, -14.11978033766759, 37.72362894910418);\n    const vec3 n3 = vec3(402449.1952667068, 8.215822679311859, -26.50421098884263);\n\n    vec3 num = n0+t*(n1+t*(n2+t*n3));\n\n    const vec3 d1 = vec3(118740.4629146444, 6.273896609959839, -1.468039758700077);\n    const vec3 d2 = vec3(-429488.4500615235, -18.0038243539569, 11.99227708890398);\n    const vec3 d3 = vec3(388362.8120573136, 11.06612403569916, -10.0995891932555);\n\n    vec3 denom = 1.0+t*(d1+t*(d2+t*d3));\n\n    return num/denom;\n\n}\n\nvec3 hpluv(float t) {\n\n    const vec3 n0 = vec3(0.7755223888597467, 0.4819666219768237, 0.551173411404921);\n    const vec3 n1 = vec3(0.2813802962619366, -0.7671094845567339, -3.216380071388543);\n    const vec3 n2 = vec3(-9.568788047994651, 0.3022781094227005, 8.202467388623468);\n    const vec3 n3 = vec3(11.91677649652787, 0.07208781864656497, -4.957255852700072);\n\n    vec3 num = n0+t*(n1+t*(n2+t*n3));\n\n    const vec3 d1 = vec3(1.28647580169279, -2.450901333406877, -2.708450209280833);\n    const vec3 d2 = vec3(-12.69228327425032, 2.470825420781031, 5.080029261806732);\n    const vec3 d3 = vec3(14.77069145126272, -0.8359320903961928, -2.287476595664842);\n\n    vec3 denom = 1.0+t*(d1+t*(d2+t*d3));\n\n    return num/denom;\n\n}\n\nvec3 paletteLUT(float row, float u) {\n    \n    vec2 uv;\n    \n    uv.x = mix(0.5, 254.5, u);\n    uv.y = 0.5 + row;\n    \n    uv /= iResolution.xy;\n    \n    return texture(iChannel0, uv, 0.0).xyz;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    float u = fragCoord.x / iResolution.x;\n    \n    //fragColor = vec4(paletteLUT(2.0, u), 1);\n    \n    \n    float y;\n    vec2 uv;\n    \n    if (max(iMouse.z, iMouse.w) > 0.) {\n        \n        uv = fragCoord / iResolution.xy;\n        y = floor(iMouse.y * 4. / iResolution.y );\n        \n    } else {\n\n        const float m = 2.0;\n\n        vec2 dims = iResolution.xy - vec2(2.*m, 2.*m);\n\n        float h = floor(0.25*dims.y);\n\n        dims.y = 4.0*h;\n\n        fragCoord -= 0.5*(iResolution.xy-dims) + mod(m, 2.)*0.5;\n\n        y = floor(fragCoord.y / h);\n\n        uv = fragCoord / dims;\n\n        float b = mod(fragCoord.y + 0.5*h, h);\n\n        if (abs(b - 0.5*h) < 0.5*m || uv.x < 0. || uv.x >= 1.) {\n            y = -1.;\n        }\n        \n    }\n\n    fragColor = vec4(0, 0, 0, 1);\n    \n    if (y == 0.) {\n        fragColor.xyz = paletteLUT(1.0, uv.x);\n    } else if (y == 1.) {\n        fragColor.xyz = hsluv(uv.x);\n    } else if (y == 2.) {\n        fragColor.xyz = paletteLUT(2.0, uv.x);\n    } else if (y == 3.) {\n        fragColor.xyz = hpluv(uv.x);\n    }\n\n    \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// just some ugly code to store two 256-color palettes on the first frame\n// and then just recycle the same texture data over and over\n\nvec4 data = vec4(0);\nivec2 fc;\nivec2 dst_fc;\n\nvoid store(vec3 f) { \n\n    if (dst_fc == fc) {\n        data.xyz = f;\n    }\n    dst_fc.x += 1;\n    \n}\n    \n\nvoid store_all_data() {\n    \n    // initialization\n    dst_fc = ivec2(0, 0);\n    store(vec3(1));\n    \n    //  hsluv\n    dst_fc = ivec2(0, 1);\n\n    store(vec3(1.00000000, 0.30121629, 0.50494183));\n    store(vec3(1.00000000, 0.30424269, 0.48859814));\n    store(vec3(1.00000000, 0.30723827, 0.47150960));\n    store(vec3(1.00000000, 0.31020757, 0.45355707));\n    store(vec3(1.00000000, 0.31315497, 0.43459376));\n    store(vec3(1.00000000, 0.31608470, 0.41443505));\n    store(vec3(1.00000000, 0.31900088, 0.39284280));\n    store(vec3(1.00000000, 0.32190755, 0.36950044));\n    store(vec3(1.00000000, 0.32480869, 0.34397071));\n    store(vec3(1.00000000, 0.32770824, 0.31561901));\n    store(vec3(1.00000000, 0.33061011, 0.28346037));\n    store(vec3(1.00000000, 0.33351823, 0.24580988));\n    store(vec3(1.00000000, 0.33643658, 0.19930106));\n    store(vec3(1.00000000, 0.33936915, 0.13485350));\n    store(vec3(0.99938278, 0.34294341, 0.00000000));\n    store(vec3(0.98103890, 0.36328996, 0.00000000));\n    store(vec3(0.96398111, 0.38063200, 0.00000000));\n    store(vec3(0.94804995, 0.39566226, 0.00000000));\n    store(vec3(0.93311126, 0.40886353, 0.00000000));\n    store(vec3(0.91905123, 0.42058609, 0.00000000));\n    store(vec3(0.90577258, 0.43109219, 0.00000000));\n    store(vec3(0.89319158, 0.44058314, 0.00000000));\n    store(vec3(0.88123570, 0.44921665, 0.00000000));\n    store(vec3(0.86984172, 0.45711848, 0.00000000));\n    store(vec3(0.85895421, 0.46439037, 0.00000000));\n    store(vec3(0.84852436, 0.47111567, 0.00000000));\n    store(vec3(0.83850891, 0.47736349, 0.00000000));\n    store(vec3(0.82886937, 0.48319162, 0.00000000));\n    store(vec3(0.81957135, 0.48864889, 0.00000000));\n    store(vec3(0.81058393, 0.49377685, 0.00000000));\n    store(vec3(0.80187924, 0.49861111, 0.00000000));\n    store(vec3(0.79343202, 0.50318241, 0.00000000));\n    store(vec3(0.78521930, 0.50751744, 0.00000000));\n    store(vec3(0.77722010, 0.51163952, 0.00000000));\n    store(vec3(0.76941516, 0.51556910, 0.00000000));\n    store(vec3(0.76178675, 0.51932422, 0.00000000));\n    store(vec3(0.75431846, 0.52292090, 0.00000000));\n    store(vec3(0.74699506, 0.52637336, 0.00000000));\n    store(vec3(0.73980232, 0.52969434, 0.00000000));\n    store(vec3(0.73272689, 0.53289526, 0.00000000));\n    store(vec3(0.72575624, 0.53598642, 0.00000000));\n    store(vec3(0.71887847, 0.53897714, 0.00000000));\n    store(vec3(0.71208228, 0.54187587, 0.00000000));\n    store(vec3(0.70535689, 0.54469030, 0.00000000));\n    store(vec3(0.69869191, 0.54742748, 0.00000000));\n    store(vec3(0.69207733, 0.55009387, 0.00000000));\n    store(vec3(0.68550341, 0.55269543, 0.00000000));\n    store(vec3(0.67896066, 0.55523763, 0.00000000));\n    store(vec3(0.67243972, 0.55772559, 0.00000000));\n    store(vec3(0.66593138, 0.56016404, 0.00000000));\n    store(vec3(0.65942647, 0.56255741, 0.00000000));\n    store(vec3(0.65291579, 0.56490986, 0.00000000));\n    store(vec3(0.64639012, 0.56722529, 0.00000000));\n    store(vec3(0.63984010, 0.56950739, 0.00000000));\n    store(vec3(0.63325622, 0.57175966, 0.00000000));\n    store(vec3(0.62662870, 0.57398544, 0.00000000));\n    store(vec3(0.61994748, 0.57618791, 0.00000000));\n    store(vec3(0.61320212, 0.57837014, 0.00000000));\n    store(vec3(0.60638172, 0.58053508, 0.00000000));\n    store(vec3(0.59947486, 0.58268560, 0.00000000));\n    store(vec3(0.59246946, 0.58482449, 0.00000000));\n    store(vec3(0.58535273, 0.58695447, 0.00000000));\n    store(vec3(0.57811102, 0.58907823, 0.00000000));\n    store(vec3(0.57072965, 0.59119842, 0.00000000));\n    store(vec3(0.56319283, 0.59331768, 0.00000000));\n    store(vec3(0.55548341, 0.59543864, 0.00000000));\n    store(vec3(0.54758269, 0.59756393, 0.00000000));\n    store(vec3(0.53947016, 0.59969620, 0.00000000));\n    store(vec3(0.53112323, 0.60183817, 0.00000000));\n    store(vec3(0.52251683, 0.60399256, 0.00000000));\n    store(vec3(0.51362298, 0.60616218, 0.00000000));\n    store(vec3(0.50441030, 0.60834992, 0.00000000));\n    store(vec3(0.49484329, 0.61055876, 0.00000000));\n    store(vec3(0.48488160, 0.61279177, 0.00000000));\n    store(vec3(0.47447892, 0.61505220, 0.00000000));\n    store(vec3(0.46358172, 0.61734339, 0.00000000));\n    store(vec3(0.45212752, 0.61966890, 0.00000000));\n    store(vec3(0.44004269, 0.62203246, 0.00000000));\n    store(vec3(0.42723940, 0.62443802, 0.00000000));\n    store(vec3(0.41361153, 0.62688979, 0.00000000));\n    store(vec3(0.39902889, 0.62939226, 0.00000000));\n    store(vec3(0.38332885, 0.63195025, 0.00000000));\n    store(vec3(0.36630386, 0.63456891, 0.00000000));\n    store(vec3(0.34768201, 0.63725384, 0.00000000));\n    store(vec3(0.32709527, 0.64001106, 0.00000000));\n    store(vec3(0.30402406, 0.64284713, 0.00000000));\n    store(vec3(0.27769245, 0.64576921, 0.00000000));\n    store(vec3(0.24684646, 0.64878511, 0.00000000));\n    store(vec3(0.20920095, 0.65190340, 0.00000000));\n    store(vec3(0.15962948, 0.65513354, 0.00000000));\n    store(vec3(0.07929463, 0.65848596, 0.00000000));\n    store(vec3(-0.00000000, 0.65946658, 0.08707563));\n    store(vec3(-0.00000000, 0.65835467, 0.16265107));\n    store(vec3(-0.00000000, 0.65730351, 0.21004012));\n    store(vec3(-0.00000000, 0.65630709, 0.24593491));\n    store(vec3(-0.00000000, 0.65536010, 0.27517292));\n    store(vec3(-0.00000000, 0.65445788, 0.29995945));\n    store(vec3(-0.00000000, 0.65359632, 0.32151992));\n    store(vec3(-0.00000000, 0.65277173, 0.34061858));\n    store(vec3(-0.00000000, 0.65198085, 0.35776980));\n    store(vec3(-0.00000000, 0.65122074, 0.37333917));\n    store(vec3(-0.00000000, 0.65048877, 0.38759726));\n    store(vec3(-0.00000000, 0.64978257, 0.40075079));\n    store(vec3(-0.00000000, 0.64909997, 0.41296172));\n    store(vec3(-0.00000000, 0.64843902, 0.42435963));\n    store(vec3(-0.00000000, 0.64779795, 0.43504997));\n    store(vec3(-0.00000000, 0.64717512, 0.44511986));\n    store(vec3(-0.00000000, 0.64656904, 0.45464215));\n    store(vec3(-0.00000000, 0.64597833, 0.46367847));\n    store(vec3(-0.00000000, 0.64540172, 0.47228148));\n    store(vec3(-0.00000000, 0.64483805, 0.48049652));\n    store(vec3(-0.00000000, 0.64428620, 0.48836298));\n    store(vec3(-0.00000000, 0.64374517, 0.49591531));\n    store(vec3(-0.00000000, 0.64321401, 0.50318385));\n    store(vec3(-0.00000000, 0.64269180, 0.51019547));\n    store(vec3(-0.00000000, 0.64217771, 0.51697412));\n    store(vec3(-0.00000000, 0.64167095, 0.52354124));\n    store(vec3(-0.00000000, 0.64117075, 0.52991616));\n    store(vec3(-0.00000000, 0.64067638, 0.53611635));\n    store(vec3(-0.00000000, 0.64018716, 0.54215772));\n    store(vec3(-0.00000000, 0.63970242, 0.54805479));\n    store(vec3(-0.00000000, 0.63922152, 0.55382090));\n    store(vec3(-0.00000000, 0.63874383, 0.55946835));\n    store(vec3(-0.00000000, 0.63826874, 0.56500853));\n    store(vec3(-0.00000000, 0.63779567, 0.57045206));\n    store(vec3(-0.00000000, 0.63732402, 0.57580885));\n    store(vec3(-0.00000000, 0.63685323, 0.58108822));\n    store(vec3(-0.00000000, 0.63638270, 0.58629898));\n    store(vec3(-0.00000000, 0.63591188, 0.59144948));\n    store(vec3(-0.00000000, 0.63544019, 0.59654768));\n    store(vec3(-0.00000000, 0.63496705, 0.60160122));\n    store(vec3(-0.00000000, 0.63449188, 0.60661746));\n    store(vec3(-0.00000000, 0.63401408, 0.61160351));\n    store(vec3(-0.00000000, 0.63353304, 0.61656634));\n    store(vec3(-0.00000000, 0.63304814, 0.62151273));\n    store(vec3(-0.00000000, 0.63255874, 0.62644937));\n    store(vec3(-0.00000000, 0.63206417, 0.63138291));\n    store(vec3(-0.00000000, 0.63156373, 0.63631995));\n    store(vec3(-0.00000000, 0.63105670, 0.64126711));\n    store(vec3(-0.00000000, 0.63054232, 0.64623104));\n    store(vec3(-0.00000000, 0.63001980, 0.65121850));\n    store(vec3(-0.00000000, 0.62948827, 0.65623637));\n    store(vec3(-0.00000000, 0.62894685, 0.66129169));\n    store(vec3(-0.00000000, 0.62839457, 0.66639169));\n    store(vec3(-0.00000000, 0.62783043, 0.67154389));\n    store(vec3(-0.00000000, 0.62725331, 0.67675607));\n    store(vec3(-0.00000000, 0.62666204, 0.68203638));\n    store(vec3(-0.00000000, 0.62605535, 0.68739338));\n    store(vec3(-0.00000000, 0.62543185, 0.69283610));\n    store(vec3(-0.00000000, 0.62479005, 0.69837408));\n    store(vec3(-0.00000000, 0.62412831, 0.70401750));\n    store(vec3(-0.00000000, 0.62344485, 0.70977724));\n    store(vec3(-0.00000000, 0.62273770, 0.71566496));\n    store(vec3(-0.00000000, 0.62200470, 0.72169322));\n    store(vec3(-0.00000000, 0.62124347, 0.72787563));\n    store(vec3(-0.00000000, 0.62045135, 0.73422693));\n    store(vec3(-0.00000000, 0.61962541, 0.74076322));\n    store(vec3(-0.00000000, 0.61876235, 0.74750212));\n    store(vec3(-0.00000000, 0.61785849, 0.75446297));\n    store(vec3(-0.00000000, 0.61690969, 0.76166711));\n    store(vec3(-0.00000000, 0.61591125, 0.76913818));\n    store(vec3(-0.00000000, 0.61485787, 0.77690246));\n    store(vec3(-0.00000000, 0.61374346, 0.78498930));\n    store(vec3(-0.00000000, 0.61256110, 0.79343160));\n    store(vec3(-0.00000000, 0.61130279, 0.80226646));\n    store(vec3(-0.00000000, 0.60995926, 0.81153584));\n    store(vec3(-0.00000000, 0.60851972, 0.82128751));\n    store(vec3(-0.00000000, 0.60697156, 0.83157609));\n    store(vec3(-0.00000000, 0.60529985, 0.84246439));\n    store(vec3(-0.00000000, 0.60348686, 0.85402511));\n    store(vec3(-0.00000000, 0.60151136, 0.86634292));\n    store(vec3(-0.00000000, 0.59934768, 0.87951712));\n    store(vec3(-0.00000000, 0.59696448, 0.89366506));\n    store(vec3(-0.00000000, 0.59432308, 0.90892663));\n    store(vec3(-0.00000000, 0.59137524, 0.92547006));\n    store(vec3(-0.00000000, 0.58805989, 0.94349976));\n    store(vec3(-0.00000000, 0.58429861, 0.96326697));\n    store(vec3(-0.00000000, 0.57998894, 0.98508443));\n    store(vec3(0.08705126, 0.57476151, 1.00000000));\n    store(vec3(0.18908055, 0.56888970, 1.00000000));\n    store(vec3(0.25096602, 0.56299884, 1.00000000));\n    store(vec3(0.29857943, 0.55708036, 1.00000000));\n    store(vec3(0.33829712, 0.55112550, 1.00000000));\n    store(vec3(0.37286526, 0.54512525, 1.00000000));\n    store(vec3(0.40376097, 0.53907028, 1.00000000));\n    store(vec3(0.43188612, 0.53295087, 1.00000000));\n    store(vec3(0.45783917, 0.52675684, 1.00000000));\n    store(vec3(0.48204145, 0.52047745, 1.00000000));\n    store(vec3(0.50480322, 0.51410134, 1.00000000));\n    store(vec3(0.52636105, 0.50761639, 1.00000000));\n    store(vec3(0.54690057, 0.50100961, 1.00000000));\n    store(vec3(0.56657090, 0.49426702, 1.00000000));\n    store(vec3(0.58549429, 0.48737345, 1.00000000));\n    store(vec3(0.60377274, 0.48031241, 1.00000000));\n    store(vec3(0.62149273, 0.47306580, 1.00000000));\n    store(vec3(0.63872856, 0.46561370, 1.00000000));\n    store(vec3(0.65554499, 0.45793405, 1.00000000));\n    store(vec3(0.67199909, 0.45000225, 1.00000000));\n    store(vec3(0.68814176, 0.44179069, 1.00000000));\n    store(vec3(0.70401893, 0.43326824, 1.00000000));\n    store(vec3(0.71967246, 0.42439945, 1.00000000));\n    store(vec3(0.73514093, 0.41514376, 1.00000000));\n    store(vec3(0.75046027, 0.40545427, 1.00000000));\n    store(vec3(0.76566427, 0.39527632, 1.00000000));\n    store(vec3(0.78078506, 0.38454554, 1.00000000));\n    store(vec3(0.79585348, 0.37318522, 1.00000000));\n    store(vec3(0.81089946, 0.36110281, 1.00000000));\n    store(vec3(0.82595231, 0.34818486, 1.00000000));\n    store(vec3(0.84104101, 0.33428990, 1.00000000));\n    store(vec3(0.85619454, 0.31923765, 1.00000000));\n    store(vec3(0.87144208, 0.30279243, 1.00000000));\n    store(vec3(0.88681334, 0.28463600, 1.00000000));\n    store(vec3(0.90233881, 0.26432051, 1.00000000));\n    store(vec3(0.91805001, 0.24118003, 1.00000000));\n    store(vec3(0.93397988, 0.21414499, 1.00000000));\n    store(vec3(0.95016302, 0.18128547, 1.00000000));\n    store(vec3(0.96663608, 0.13835170, 1.00000000));\n    store(vec3(0.98343816, 0.07058422, 1.00000000));\n    store(vec3(0.99457977, 0.00000000, 0.99397528));\n    store(vec3(0.99884189, 0.00000000, 0.98126797));\n    store(vec3(1.00000000, 0.03358261, 0.96600934));\n    store(vec3(1.00000000, 0.07043814, 0.95019059));\n    store(vec3(1.00000000, 0.09512532, 0.93487684));\n    store(vec3(1.00000000, 0.11420839, 0.92001832));\n    store(vec3(1.00000000, 0.12993072, 0.90557000));\n    store(vec3(1.00000000, 0.14336377, 0.89149090));\n    store(vec3(1.00000000, 0.15511821, 0.87774352));\n    store(vec3(1.00000000, 0.16558115, 0.86429337));\n    store(vec3(1.00000000, 0.17501610, 0.85110852));\n    store(vec3(1.00000000, 0.18361198, 0.83815927));\n    store(vec3(1.00000000, 0.19150953, 0.82541781));\n    store(vec3(1.00000000, 0.19881690, 0.81285791));\n    store(vec3(1.00000000, 0.20561921, 0.80045473));\n    store(vec3(1.00000000, 0.21198482, 0.78818454));\n    store(vec3(1.00000000, 0.21796959, 0.77602452));\n    store(vec3(1.00000000, 0.22361981, 0.76395256));\n    store(vec3(1.00000000, 0.22897429, 0.75194710));\n    store(vec3(1.00000000, 0.23406599, 0.73998692));\n    store(vec3(1.00000000, 0.23892311, 0.72805097));\n    store(vec3(1.00000000, 0.24357002, 0.71611822));\n    store(vec3(1.00000000, 0.24802792, 0.70416746));\n    store(vec3(1.00000000, 0.25231543, 0.69217711));\n    store(vec3(1.00000000, 0.25644896, 0.68012503));\n    store(vec3(1.00000000, 0.26044310, 0.66798832));\n    store(vec3(1.00000000, 0.26431086, 0.65574306));\n    store(vec3(1.00000000, 0.26806394, 0.64336405));\n    store(vec3(1.00000000, 0.27171290, 0.63082451));\n    store(vec3(1.00000000, 0.27526733, 0.61809574));\n    store(vec3(1.00000000, 0.27873596, 0.60514668));\n    store(vec3(1.00000000, 0.28212680, 0.59194341));\n    store(vec3(1.00000000, 0.28544722, 0.57844860));\n    store(vec3(1.00000000, 0.28870405, 0.56462069));\n    store(vec3(1.00000000, 0.29190363, 0.55041305));\n    store(vec3(1.00000000, 0.29505187, 0.53577276));\n    store(vec3(1.00000000, 0.29815435, 0.52063914));\n    \n    //  hpluv\n    dst_fc = ivec2(0, 2);\n    \n    store(vec3(0.77376203, 0.48532689, 0.54388480));\n    store(vec3(0.77313847, 0.48631019, 0.53829628));\n    store(vec3(0.77241461, 0.48733840, 0.53268725));\n    store(vec3(0.77159145, 0.48841012, 0.52706005));\n    store(vec3(0.77066998, 0.48952391, 0.52141708));\n    store(vec3(0.76965122, 0.49067834, 0.51576076));\n    store(vec3(0.76853613, 0.49187197, 0.51009356));\n    store(vec3(0.76732568, 0.49310338, 0.50441802));\n    store(vec3(0.76602085, 0.49437113, 0.49873672));\n    store(vec3(0.76462257, 0.49567378, 0.49305231));\n    store(vec3(0.76313179, 0.49700992, 0.48736749));\n    store(vec3(0.76154942, 0.49837812, 0.48168505));\n    store(vec3(0.75987637, 0.49977699, 0.47600783));\n    store(vec3(0.75811354, 0.50120513, 0.47033879));\n    store(vec3(0.75626180, 0.50266116, 0.46468093));\n    store(vec3(0.75432202, 0.50414372, 0.45903738));\n    store(vec3(0.75229504, 0.50565146, 0.45341134));\n    store(vec3(0.75018169, 0.50718306, 0.44780612));\n    store(vec3(0.74798279, 0.50873720, 0.44222517));\n    store(vec3(0.74569912, 0.51031260, 0.43667200));\n    store(vec3(0.74333145, 0.51190800, 0.43115030));\n    store(vec3(0.74088056, 0.51352213, 0.42566386));\n    store(vec3(0.73834717, 0.51515379, 0.42021661));\n    store(vec3(0.73573200, 0.51680176, 0.41481262));\n    store(vec3(0.73303575, 0.51846487, 0.40945611));\n    store(vec3(0.73025911, 0.52014197, 0.40415147));\n    store(vec3(0.72740272, 0.52183193, 0.39890324));\n    store(vec3(0.72446723, 0.52353363, 0.39371611));\n    store(vec3(0.72145325, 0.52524600, 0.38859497));\n    store(vec3(0.71836139, 0.52696798, 0.38354486));\n    store(vec3(0.71519221, 0.52869853, 0.37857101));\n    store(vec3(0.71194628, 0.53043665, 0.37367883));\n    store(vec3(0.70862413, 0.53218135, 0.36887388));\n    store(vec3(0.70522628, 0.53393165, 0.36416194));\n    store(vec3(0.70175320, 0.53568663, 0.35954893));\n    store(vec3(0.69820538, 0.53744537, 0.35504094));\n    store(vec3(0.69458327, 0.53920696, 0.35064425));\n    store(vec3(0.69088728, 0.54097054, 0.34636524));\n    store(vec3(0.68711784, 0.54273526, 0.34221046));\n    store(vec3(0.68327531, 0.54450028, 0.33818656));\n    store(vec3(0.67936006, 0.54626480, 0.33430029));\n    store(vec3(0.67537244, 0.54802803, 0.33055848));\n    store(vec3(0.67131277, 0.54978920, 0.32696799));\n    store(vec3(0.66718133, 0.55154755, 0.32353570));\n    store(vec3(0.66297840, 0.55330236, 0.32026845));\n    store(vec3(0.65870425, 0.55505292, 0.31717305));\n    store(vec3(0.65435909, 0.55679852, 0.31425616));\n    store(vec3(0.64994315, 0.55853850, 0.31152431));\n    store(vec3(0.64545660, 0.56027218, 0.30898381));\n    store(vec3(0.64089962, 0.56199892, 0.30664074));\n    store(vec3(0.63627235, 0.56371809, 0.30450084));\n    store(vec3(0.63157492, 0.56542907, 0.30256951));\n    store(vec3(0.62680741, 0.56713127, 0.30085171));\n    store(vec3(0.62196992, 0.56882409, 0.29935196));\n    store(vec3(0.61706250, 0.57050695, 0.29807425));\n    store(vec3(0.61208519, 0.57217930, 0.29702200));\n    store(vec3(0.60703799, 0.57384058, 0.29619805));\n    store(vec3(0.60192091, 0.57549025, 0.29560457));\n    store(vec3(0.59673391, 0.57712779, 0.29524311));\n    store(vec3(0.59147694, 0.57875267, 0.29511452));\n    store(vec3(0.58614992, 0.58036439, 0.29521893));\n    store(vec3(0.58075276, 0.58196244, 0.29555583));\n    store(vec3(0.57528534, 0.58354634, 0.29612398));\n    store(vec3(0.56974752, 0.58511561, 0.29692147));\n    store(vec3(0.56413914, 0.58666975, 0.29794577));\n    store(vec3(0.55846000, 0.58820833, 0.29919369));\n    store(vec3(0.55270991, 0.58973086, 0.30066148));\n    store(vec3(0.54688862, 0.59123689, 0.30234485));\n    store(vec3(0.54099588, 0.59272598, 0.30423901));\n    store(vec3(0.53503142, 0.59419769, 0.30633873));\n    store(vec3(0.52899493, 0.59565158, 0.30863839));\n    store(vec3(0.52288609, 0.59708721, 0.31113203));\n    store(vec3(0.51670454, 0.59850415, 0.31381342));\n    store(vec3(0.51044991, 0.59990199, 0.31667608));\n    store(vec3(0.50412179, 0.60128030, 0.31971338));\n    store(vec3(0.49771976, 0.60263866, 0.32291855));\n    store(vec3(0.49124337, 0.60397666, 0.32628472));\n    store(vec3(0.48469214, 0.60529389, 0.32980500));\n    store(vec3(0.47806555, 0.60658994, 0.33347250));\n    store(vec3(0.47136307, 0.60786440, 0.33728035));\n    store(vec3(0.46458414, 0.60911687, 0.34122176));\n    store(vec3(0.45772815, 0.61034694, 0.34529000));\n    store(vec3(0.45079449, 0.61155421, 0.34947849));\n    store(vec3(0.44378249, 0.61273827, 0.35378076));\n    store(vec3(0.43669145, 0.61389874, 0.35819050));\n    store(vec3(0.42952065, 0.61503519, 0.36270155));\n    store(vec3(0.42226932, 0.61614725, 0.36730793));\n    store(vec3(0.41493666, 0.61723450, 0.37200384));\n    store(vec3(0.40752182, 0.61829656, 0.37678364));\n    store(vec3(0.40002391, 0.61933301, 0.38164191));\n    store(vec3(0.39244200, 0.62034346, 0.38657339));\n    store(vec3(0.38477510, 0.62132750, 0.39157302));\n    store(vec3(0.37702219, 0.62228475, 0.39663591));\n    store(vec3(0.36918217, 0.62321480, 0.40175737));\n    store(vec3(0.36125390, 0.62411724, 0.40693286));\n    store(vec3(0.35323617, 0.62499167, 0.41215802));\n    store(vec3(0.34512771, 0.62583770, 0.41742867));\n    store(vec3(0.33692715, 0.62665492, 0.42274078));\n    store(vec3(0.32863307, 0.62744292, 0.42809046));\n    store(vec3(0.32024395, 0.62820131, 0.43347398));\n    store(vec3(0.31175818, 0.62892967, 0.43888775));\n    store(vec3(0.30317404, 0.62962760, 0.44432830));\n    store(vec3(0.29448971, 0.63029470, 0.44979231));\n    store(vec3(0.28570321, 0.63093056, 0.45527656));\n    store(vec3(0.27681246, 0.63153478, 0.46077794));\n    store(vec3(0.26781520, 0.63210694, 0.46629346));\n    store(vec3(0.25870900, 0.63264665, 0.47182022));\n    store(vec3(0.24949124, 0.63315350, 0.47735542));\n    store(vec3(0.24015905, 0.63362708, 0.48289635));\n    store(vec3(0.23070936, 0.63406699, 0.48844036));\n    store(vec3(0.22113876, 0.63447283, 0.49398491));\n    store(vec3(0.21144355, 0.63484420, 0.49952751));\n    store(vec3(0.20161963, 0.63518070, 0.50506574));\n    store(vec3(0.19166248, 0.63548193, 0.51059723));\n    store(vec3(0.18156704, 0.63574750, 0.51611970));\n    store(vec3(0.17132768, 0.63597702, 0.52163090));\n    store(vec3(0.16093803, 0.63617010, 0.52712861));\n    store(vec3(0.15039088, 0.63632635, 0.53261069));\n    store(vec3(0.13967796, 0.63644540, 0.53807503));\n    store(vec3(0.12878977, 0.63652688, 0.54351954));\n    store(vec3(0.11771520, 0.63657040, 0.54894218));\n    store(vec3(0.10644119, 0.63657562, 0.55434095));\n    store(vec3(0.09495214, 0.63654217, 0.55971385));\n    store(vec3(0.08322912, 0.63646970, 0.56505893));\n    store(vec3(0.07124879, 0.63635787, 0.57037426));\n    store(vec3(0.05898167, 0.63620635, 0.57565793));\n    store(vec3(0.04638953, 0.63601482, 0.58090803));\n    store(vec3(0.03366588, 0.63578296, 0.58612270));\n    store(vec3(0.02268081, 0.63551047, 0.59130007));\n    store(vec3(0.01382801, 0.63519706, 0.59643829));\n    store(vec3(0.00713350, 0.63484245, 0.60153553));\n    store(vec3(0.00262228, 0.63444638, 0.60658996));\n    store(vec3(0.00031832, 0.63400859, 0.61159978));\n    store(vec3(0.00024447, 0.63352886, 0.61656317));\n    store(vec3(0.00242239, 0.63300695, 0.62147833));\n    store(vec3(0.00687250, 0.63244268, 0.62634348));\n    store(vec3(0.01361391, 0.63183585, 0.63115684));\n    store(vec3(0.02266434, 0.63118631, 0.63591662));\n    store(vec3(0.03404008, 0.63049391, 0.64062106));\n    store(vec3(0.04728712, 0.62975853, 0.64526839));\n    store(vec3(0.06042656, 0.62898006, 0.64985685));\n    store(vec3(0.07329774, 0.62815844, 0.65438469));\n    store(vec3(0.08593751, 0.62729361, 0.65885016));\n    store(vec3(0.09837384, 0.62638555, 0.66325152));\n    store(vec3(0.11062849, 0.62543427, 0.66758704));\n    store(vec3(0.12271870, 0.62443978, 0.67185498));\n    store(vec3(0.13465841, 0.62340216, 0.67605363));\n    store(vec3(0.14645892, 0.62232149, 0.68018128));\n    store(vec3(0.15812956, 0.62119790, 0.68423622));\n    store(vec3(0.16967804, 0.62003155, 0.68821676));\n    store(vec3(0.18111077, 0.61882263, 0.69212122));\n    store(vec3(0.19243307, 0.61757137, 0.69594792));\n    store(vec3(0.20364941, 0.61627803, 0.69969521));\n    store(vec3(0.21476348, 0.61494291, 0.70336145));\n    store(vec3(0.22577835, 0.61356636, 0.70694500));\n    store(vec3(0.23669653, 0.61214876, 0.71044426));\n    store(vec3(0.24752009, 0.61069053, 0.71385763));\n    store(vec3(0.25825067, 0.60919215, 0.71718354));\n    store(vec3(0.26888957, 0.60765413, 0.72042043));\n    store(vec3(0.27943775, 0.60607701, 0.72356677));\n    store(vec3(0.28989594, 0.60446141, 0.72662105));\n    store(vec3(0.30026458, 0.60280796, 0.72958180));\n    store(vec3(0.31054392, 0.60111738, 0.73244755));\n    store(vec3(0.32073401, 0.59939040, 0.73521689));\n    store(vec3(0.33083474, 0.59762782, 0.73788842));\n    store(vec3(0.34084582, 0.59583049, 0.74046077));\n    store(vec3(0.35076685, 0.59399930, 0.74293262));\n    store(vec3(0.36059728, 0.59213519, 0.74530268));\n    store(vec3(0.37033648, 0.59023918, 0.74756968));\n    store(vec3(0.37998369, 0.58831230, 0.74973243));\n    store(vec3(0.38953809, 0.58635566, 0.75178973));\n    store(vec3(0.39899877, 0.58437042, 0.75374047));\n    store(vec3(0.40836473, 0.58235779, 0.75558355));\n    store(vec3(0.41763496, 0.58031903, 0.75731794));\n    store(vec3(0.42680835, 0.57825545, 0.75894263));\n    store(vec3(0.43588377, 0.57616843, 0.76045669));\n    store(vec3(0.44486004, 0.57405937, 0.76185923));\n    store(vec3(0.45373596, 0.57192975, 0.76314941));\n    store(vec3(0.46251029, 0.56978109, 0.76432643));\n    store(vec3(0.47118177, 0.56761497, 0.76538957));\n    store(vec3(0.47974914, 0.56543299, 0.76633815));\n    store(vec3(0.48821113, 0.56323683, 0.76717156));\n    store(vec3(0.49656643, 0.56102821, 0.76788924));\n    store(vec3(0.50481377, 0.55880887, 0.76849069));\n    store(vec3(0.51295187, 0.55658063, 0.76897547));\n    store(vec3(0.52097945, 0.55434533, 0.76934320));\n    store(vec3(0.52889525, 0.55210485, 0.76959357));\n    store(vec3(0.53669803, 0.54986113, 0.76972634));\n    store(vec3(0.54438655, 0.54761611, 0.76974130));\n    store(vec3(0.55195962, 0.54537178, 0.76963835));\n    store(vec3(0.55941605, 0.54313018, 0.76941741));\n    store(vec3(0.56675469, 0.54089335, 0.76907850));\n    store(vec3(0.57397442, 0.53866336, 0.76862168));\n    store(vec3(0.58107417, 0.53644233, 0.76804709));\n    store(vec3(0.58805287, 0.53423235, 0.76735494));\n    store(vec3(0.59490953, 0.53203557, 0.76654547));\n    store(vec3(0.60164317, 0.52985413, 0.76561902));\n    store(vec3(0.60825287, 0.52769018, 0.76457599));\n    store(vec3(0.61473775, 0.52554588, 0.76341682));\n    store(vec3(0.62109698, 0.52342338, 0.76214203));\n    store(vec3(0.62732976, 0.52132485, 0.76075220));\n    store(vec3(0.63343538, 0.51925243, 0.75924798));\n    store(vec3(0.63941314, 0.51720825, 0.75763005));\n    store(vec3(0.64526241, 0.51519444, 0.75589919));\n    store(vec3(0.65098261, 0.51321309, 0.75405620));\n    store(vec3(0.65657321, 0.51126628, 0.75210196));\n    store(vec3(0.66203375, 0.50935606, 0.75003740));\n    store(vec3(0.66736380, 0.50748443, 0.74786350));\n    store(vec3(0.67256300, 0.50565337, 0.74558130));\n    store(vec3(0.67763105, 0.50386481, 0.74319188));\n    store(vec3(0.68256768, 0.50212063, 0.74069639));\n    store(vec3(0.68737271, 0.50042268, 0.73809601));\n    store(vec3(0.69204599, 0.49877271, 0.73539197));\n    store(vec3(0.69658743, 0.49717246, 0.73258555));\n    store(vec3(0.70099699, 0.49562358, 0.72967808));\n    store(vec3(0.70527469, 0.49412765, 0.72667091));\n    store(vec3(0.70942060, 0.49268619, 0.72356546));\n    store(vec3(0.71343485, 0.49130063, 0.72036315));\n    store(vec3(0.71731761, 0.48997234, 0.71706549));\n    store(vec3(0.72106909, 0.48870260, 0.71367397));\n    store(vec3(0.72468958, 0.48749260, 0.71019016));\n    store(vec3(0.72817938, 0.48634345, 0.70661562));\n    store(vec3(0.73153887, 0.48525618, 0.70295198));\n    store(vec3(0.73476846, 0.48423170, 0.69920088));\n    store(vec3(0.73786860, 0.48327086, 0.69536398));\n    store(vec3(0.74083978, 0.48237439, 0.69144297));\n    store(vec3(0.74368255, 0.48154294, 0.68743958));\n    store(vec3(0.74639748, 0.48077706, 0.68335555));\n    store(vec3(0.74898519, 0.48007720, 0.67919264));\n    store(vec3(0.75144632, 0.47944371, 0.67495264));\n    store(vec3(0.75378156, 0.47887685, 0.67063736));\n    store(vec3(0.75599162, 0.47837679, 0.66624860));\n    store(vec3(0.75807727, 0.47794357, 0.66178823));\n    store(vec3(0.76003927, 0.47757719, 0.65725808));\n    store(vec3(0.76187844, 0.47727751, 0.65266004));\n    store(vec3(0.76359560, 0.47704432, 0.64799599));\n    store(vec3(0.76519162, 0.47687733, 0.64326784));\n    store(vec3(0.76666736, 0.47677614, 0.63847750));\n    store(vec3(0.76802375, 0.47674028, 0.63362690));\n    store(vec3(0.76926168, 0.47676919, 0.62871798));\n    store(vec3(0.77038212, 0.47686225, 0.62375270));\n    store(vec3(0.77138599, 0.47701875, 0.61873303));\n    store(vec3(0.77227429, 0.47723791, 0.61366095));\n    store(vec3(0.77304798, 0.47751888, 0.60853846));\n    store(vec3(0.77370807, 0.47786075, 0.60336757));\n    store(vec3(0.77425556, 0.47826255, 0.59815030));\n    store(vec3(0.77469145, 0.47872325, 0.59288869));\n    store(vec3(0.77501676, 0.47924176, 0.58758481));\n    store(vec3(0.77523253, 0.47981696, 0.58224072));\n    store(vec3(0.77533977, 0.48044767, 0.57685852));\n    store(vec3(0.77533953, 0.48113266, 0.57144031));\n    store(vec3(0.77523282, 0.48187069, 0.56598824));\n    store(vec3(0.77502069, 0.48266046, 0.56050446));\n    store(vec3(0.77470416, 0.48350065, 0.55499115));\n    store(vec3(0.77428427, 0.48438992, 0.54945052));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    float ready = texelFetch(iChannel0, ivec2(0, 0), 0).x;\n    \n    \n    fc = ivec2(fragCoord);\n    data = texelFetch(iChannel0, fc, 0);\n    \n    if (ready != 1.0) {\n        store_all_data();\n    }\n    \n    fragColor = data;\n    \n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdSyzK.jpg", "access": "api", "license": "libpng AND cc0-1.0", "functions": [[574, 574, 595, 595, 1293], [1295, 1295, 1316, 1316, 2022], [2024, 2024, 2061, 2061, 2224], [2226, 2226, 2283, 2283, 3351]], "test": "untested"}
{"id": "WdByzK", "name": "caramellspongebob", "author": "caramellseizure", "description": "made for playing in fullscreen with your monitor or tv pointed at your neighbors\n1 color change per beat\n\nhttps://www.youtube.com/watch?v=QOC7DyBdpog\n", "tags": ["beat", "audio", "rainbow", "meme", "caramelldansen"], "likes": 1, "viewed": 396, "published": 3, "date": "1586915453", "time_retrieved": "2024-07-30T21:12:47.270302", "image_code": "//#define DEBUG 0\n\n// Original is 138 BPM\n// Remixes are 160-170ish. Spongebob video is at 166\n// 166 / 60\n#define MULT 2.7666\n#define COLORS 4.\n\n// spongebob video also cycles green, blue, red, purple\n// hue scale goes green, blue, purple, red\n\n// with max saturation and value\n//vec3 hue2rgb(in float c) {\n//    vec3 rgb = clamp( abs(mod(c*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n//    rgb = rgb*rgb*(3.0-2.0*rgb);\n//    return mix( vec3(1.0), rgb, 1.);\n//}\n\n\n//void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n//    // One color step per beat\n//    //float hue = ceil(fract(iTime / COLORS * MULT) * COLORS) / COLORS;\n//    float hue = ceil(mod(iTime * MULT, COLORS)) / COLORS;\n//    #if DEBUG\n//        vec3 color = vec3(max(0.2, hue));\n//    #else\n//        vec3 color = hue2rgb(hue);\n//    #endif\n//\n//    fragColor = vec4(color, 1.0);\n//}\n\n\n// from FabriceNeyret2's comment\n#define mainImage(O,U)O=.5+.7*cos(6.3*mod(ceil(iTime*MULT),COLORS)/COLORS+vec4(0,4.2,2.1,0))\n// See https://www.desmos.com/calculator/sl6y9qpqz7\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdByzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "tdjyzG", "name": "Day 117", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 9, "viewed": 450, "published": 3, "date": "1586890251", "time_retrieved": "2024-07-30T21:12:48.165907", "image_code": "#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define dmin(a,b) a.x < b.x ? a : b\n\n#define pmod(p,j) mod(p,j) - 0.5*j\n\n\nvec3 glow = vec3(0);\n\n\nfloat getF(vec2 j){\n    float d = 0.;\n    \n    j *= 0.5;\n    \n    \n    \n    j *= 8.;\n    \n    vec3 p = vec3(j,1.);\n    \n    \n\tp.xy = pmod(p.xy, 7.5);\n    \n    p /= dot(p.xy,p.xy);\n    \n    vec2 b = vec2(1.7,0.85 + smoothstep(0.,1.,j.y*0.1));\n    \n    \n    for(int i = 0; i < 4; i++){\n        p.xy = abs(p.xy);\n        p.xy *= rot(0.125*pi);\n        p.x -= 0.0;\n    \t\n        //p.xy *= rot(0.125*pi);\n        \n    }\n    \n    for(int i = 0; i < 4; i++){\n        \n        float dpp = dot(p.xy,p.xy);\n        \n        dpp = clamp(dpp, 0.4,1.5);\n        \n        p /= dpp;\n    \tp.xy = abs(mod(p.xy - 0.5*b,b)) - 0.5*b;\n    \t\n        \n        p.xy *= rot(0.5*pi);\n        \n    }\n\t//p.xy = pmod(p.xy, 1.5);\n    \n    \n    d = length(p.x)/p.z - 0.01;\n    \n    //d = max(d,0.);\n    \n    //d = pow(d*1.1, 1.);\n    return d;\n\n}\n\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e7);\n\t\n    //p.xy *= rot(p.z*0.2*smoothstep(0.,1.,(p.z - 7.)*0.1' + iTime*0.1);\n    \n    p.xy *= rot(sin(p.x*20. + p.z*4.)*0.0);\n    \n    float W = 0.5;\n\n    float dF = -p.y + W;\n    \n    dF = min(dF, p.y + W);\n    \n    d = dmin(d, vec2(dF,1.));\n    \n    \n    d -= getF(p.xz)*0.2;\n    \n    \n    \n    \n    d.x *= 0.2;\n    \n    \n    d = abs(d) + 0.002;\n    \n    glow += 0.003/(0.001 + d.x*d.x*200.);\n\t\n    vec3 bp = p + vec3(0,0,-iTime);\n    \n    float bd = length(bp) - 0.1;\n    d = min(d, bd);\n    \n    float env =smoothstep(0.,1.,(iTime)*0.1);\n    float gb = 0.003/max((0.5 - env*0.5 + bd*bd*(1. - env*0.994 ) + abs(sin(iTime*200.))*0.1*pow(env, 4.)), 0.);\n    \n        \n    glow += gb;\n    \n    return d;\n}\n\nvec2 march(vec3 ro, vec3 rd,inout vec3 p,inout float t,inout bool hit){\n\tvec2 d = vec2(10e6);\n\n    p = ro; hit = false; t = 0.;\n    for(int i = 0; i < 90; i++){\n    \td = map(p);\n        \n        if(d.x < 0.001){\n            hit = true;\n        \t//break;\n        }\n        t += d.x;\n        p = ro + rd*t;\n    }\n    \n\treturn d;    \n}\n\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0,1,0),dir));\n\tvec3 up = normalize(cross(dir, right));\n    return normalize(dir + (right*uv.x - up*uv.y)*0.6);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\t\n    uv *= 1. - dot(uv,uv)*1.;\n    \n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0.00);\n    ro.z += iTime - 4.;\n    \n    //ro.x += iTime*0.5;\n    \n    vec3 lookAt = ro + vec3(-0.,-0.,1.);\n    //vec3 lookAt = ro + vec3(0.,0.5,1.);\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    vec3 p; float t; bool hit;\n\t\n    vec2 d = march(ro, rd, p, t, hit);\n    \n    \n    if(hit){\n    \n    \n    }\n\t    \n    \n    \n    col += glow*0.009;\n    \n    col.r *= 1.05 ;\n    \n    col *= 2.;\n    col = smoothstep(0.,1.,col);\n    col = smoothstep(0.,1.,col);\n    //col -= float(st);\n    col = max(col, 0.);\n    \n    col = pow(col, vec3(0.454545));\n    col = 1. - col;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "sound_code": "\n#define T true\n#define F false\n\n#define init vec2 s = vec2(0)\n#define ret return s\n\n\n\n#define TT (tau*t)\n#define tt (tau*t)\n\n#define S vec2 s = vec2(0);\n#define E return s;\n\n#define OFFS (msr*1.)*0.\n\n\nconst float scale = -4.;\n\nfloat[] probK = float[16](0.9,0.1,0.1,0.2,0.,0.1,0.1,0.2,0.9,0.2,0.4,0.2,0.2,0.9,0.4,0.5);\nbool[] pattK = bool[16](F,F,F,T,F,T,T,F,T,F,F,T,F,T,T,F);\nbool[] pattL = bool[16](T,F,T,F,T,F,T,F,T,F,F,T,F,T,T,F);\nconst vec4 cmin9 = vec4(0.,3.,10.,14.) + scale;\n\nconst vec4 cmin510 = vec4(0.,7.,10.,12.) + scale;\nconst vec4 cmin7 = vec4(0.,3.,7.,10.) + scale;\nconst vec4 cmin73 = vec4(0.,7.,10.,3.) + scale;\nconst vec4 cmin11 = vec4(0.,10.,14.,17.) + scale;\nconst vec4 cmaj9 = vec4(0.,4.,7.,14.) + scale;\nconst vec4 cmaj7 = vec4(0.,4.,7.,11.) + scale;\nconst vec4 cmaj14 = vec4(0.,4.,11.,12. + 7.) + scale;\nconst vec4 cmaj7f15 = vec4(0.,4.,6.,11.) + scale;\nconst vec4 cmaj7d = vec4(0.,4.,7.,10.) + scale;\nconst vec4 cmin7maj = vec4(0.,3.,7.,11.) + scale;\n\nconst int chordCnt = 8;\n\n\n\n\nvec4[] chords = vec4[chordCnt](\n    cmin510,\n    cmin73 + 1.,\n    cmaj9 - 1.,\n    cmaj14 - 3.,\n    cmin11,\n    cmaj14 + 1. - 7.,\n    cmaj7 - 1.,\n    cmaj7 - 5.\n);\n\n\n\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel0,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\n\nfloat gT;\nfloat sc;\n\nfloat note(float note, float octave){ \n\treturn 27.5*exp2(((octave*12. ) + note )/12.);//pow(2., );\n}\n\n\n\nvec2 hash22(vec2 p)   \n{\n    p  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n    return fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\nvec2 hash22a(vec2 p){\n    p *= 2000.;\n\treturn texture(iChannel0, vec2((p + 1./floor(p/256.)))/256.).xz;\n}\nvec2 noise(float t)\n{\n    return hash22(vec2(t, t * 1.423)) * 2.0 - 1.0;\n}\n\nvec2 lpnoise(float t, float fq)\n{\n    t *= fq;\n\n    float ft = fract(t);\n    float tn = t - ft;\n    ft = smoothstep(0.0, 1.0, ft);\n\n    vec2 n0 = noise(floor(tn + 0.0) / fq);\n    vec2 n1 = noise(floor(tn + 1.0) / fq);\n\n    return mix(n0, n1, ft);\n}\n\nvec2[8] N;\n\n\nvec2 leadb(float t){\n\tinit;\n\t\n    float to;\n    vec2 nn = N[0];\n    \n    \n    vec2 id;\n    float r = bar;\n    t = mod(t, r*float(chordCnt));\n    \n    id.x = floor(t/r);\n    \n    float att = float(pattL[int( mod(floor(t/(bar/(32./8.))), 8.) )]);\n    t = mod(t,bar);\n    float reps = 16./4.;\n    id.y = floor(t/(bar/reps));\n    \n    id.y = mod(id.y, 4.);\n    \n    t = mod(t,bar/reps);\n    \t\n\n    //sampleratereduction(t, (1.2*1./iSampleRate));\n    \n    float amt = 0.1;\n    float env = exp(-t*0.2);\n    \n    \n    \n\tfloat n = chords[int(id.x)][int(id.y)];\n    \n    \n    float oct = 2.5;\n    s += sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    s += sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 + nn*amt)*env;\n    s -= sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    \n    \n    \n    //bitreduction(s, 0.7);\n    s *= 1. - att;\n    s = smoothify(s, 0.9);\n    s = smoothify(s, 0.9);\n    s = smoothify(s, 1.9);\n    s *= 8.;\n    \n    s *= 0.05;\n    ret;\n}\n\n\n\n\nvec2 chord(float t, float mode){\n\tinit;\n    \n    \n    float r = bar*2.;\n    t = mod(t, r*float(chordCnt));\n    int id = int(floor(t/r));\n    \n    //sampleratereduction(t, (1./iSampleRate));\n    sampleratereduction(t, 0.00001 + t*0.);\n    \n    float env = exp(-mod(t,r));\n    float envb = smoothstep(0.,1.,mod(t,r));\n    \n    \n    vec2 nn = N[1];\n    nn += N[2]*0.9;\n    nn += N[7]*0.45;\n    \n    nn *= 0.03*sin(t);\n    float m = 1.;\n    float width = 15.;\n    s += sin( note(chords[id][0], 1.) *tt + nn.x*1.)*0.5;\n    s += sin( note(chords[id][0], 1.) *tt + nn.x*1.)*0.5;\n    float oct = 1.;\n    if(mode == 1.)\n        oct+= 0.;\n    for(float i = 0.; i < 8.; i++){\n        float a = (1. + i/5.);\n    \t//s += sin( note(chords[id].x, 3.) *tt + nn.x)*m;\n    \ts.x += sin( note(chords[id].x, oct) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].y, oct) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].z, oct) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].w, oct) *tt*a + nn.x)*m;\n    \ts.y += sin( note(chords[id].x, oct) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].y, oct) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].z, oct) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].w, oct) *tt*a + nn.y + width)*m;\n    \tm *= 0.5;\n    }\n    \n    \n    s *= env*envb;\n    //bitreduction(s, 0.05);\n    \n    s *= 0.03;\n    s = sin(s*10.);\n    s = clampify(s, 1.);\n    //s /= 2.;\n    //s = sin(s);\n\tret;\n}\n\n\nvec2 cReverb(float t){\n\tinit;\n    \n    //sampleratereduction(t, (8.2*1./iSampleRate));\n    \n    \n    float iters = 100.;\n    float size = 6050.;\n    \n    \n    for(float i = 0.; i < iters + min(iSampleRate,0.); i++ ){\n        float att = smoothstep(1.,0.8,i/iters);\n    \t//s += lead(t - size*i/iSampleRate + 10000.2*N[int(mod(i,7.))].x/iSampleRate )*(pow(sc,0.9))*att;\n        //float m = size*i/iSampleRate + noise(i ).x*200000./iSampleRate;\n        float m = size*i/iSampleRate + 0.*N[4].x*1.4/iSampleRate;\n        //s += chord(t + m )*(0.8 + pow(sc,0.9)*0.2)*att*0.05;\n        s += chord(t + m, 0. )*(0.8)*att*0.05;\n        //s += lead(t + m/8.)*0.003*att;\n        s += leadb(t + m/4.)*0.007*att*(0.8 + pow(sc,0.9)*0.4);\n        //s += hats(t + m)*(0.2 + pow(sc,1.4))*0.001;\n    }\n    s /= iters;\n    s *= 1.;\n    s *= 200.;\n    \n    s = clampify(s, 1.);\n    \n    //bitreduction(s, 0.0001);\n    \n    ret;\n}\n\n\n\n\n\n\n\n\nvec2 crash(float t){\n\tinit;\n\t\n    t = mod(t + 0., beat);\n    \n    vec2 nn = N[1];\n    \n    float amt = 10.;\n    float env = exp(-t*0.01);\n    float f =  sin(\n        (2000. )*tt)*exp(-t*0.4)*0.215 \n        +sin((4000. )*tt)*exp(-t*2.)*0.5 \n        + ( 1250. + exp(-t*60.)*100.)*tt +lpnoise(t, 200500.).x*1.;\n    s += sin( f )*env;\n    s += amt*sin( f + nn )*env;\n    s -= amt*sin( f )*env;\n    \n    \n    s *= 0.9;\n    bitreduction(s, 0.9);\n    \n    s *= 0.3;\n    ret;\n}\n\nvoid initNoise(float t){\n\t\t\n    N[0] = lpnoise(t, 400.);\n    N[1] = lpnoise(t, 500.);\n    N[2] = lpnoise(t, 700.);\n    N[3] = lpnoise(t, 1000.);\n    N[4] = lpnoise(t, 1400.);\n    N[5] = lpnoise(t, 1900.);\n    N[6] = lpnoise(t, 2500.);\n    N[7] = lpnoise(t, 5500.); \n    \n}\n\n\nvec2 lowKick(float t){\n    init;\n\tt = mod(t, beat*2.5);\n    float env = exp(-t*20.);\n    \n    s += sin(tt*40. + sin(tt*70.)*exp(-t*1.))*env;\n    //bitreduction(s, 0.0);\n\n    s = clamp(s,-1., 1.);\n\n    \n    //s = clampify(s, 20. + sin(gT)*0.3);\n    //s = powify(s, 0.4);\n    s = clampify(s, 2.);\n    \n    //smoothify(s, 1.);\n    \n    ret;\n}\n\nvec2 mainSound( in int samp, float t )\n{\n    vec2 s= vec2(0);\n    initNoise(t);\n    \n    /*\n    t += scoffs;\n    float amp = smoothstep(0.,1.,t);\n    gT = t;\n    //t += msr*4.;\n    \n    initKickPatt(t);\n    initNoise(t);\n\n    \n    vec2 k = kick(t,sc)*1.;\n    vec2 sn = snare(t);\n    \n    vec2 ha = hats(t)*(0.2 + pow(sc,1.4))*0.11;\n    vec2 hb = hatsb(t)*0.7;\n    \n    vec2 bass = bass(t)*(pow(sc,1.5))*0.3;\n    //vec2 cguit = cguit(t)*(pow(sc,1.))*0.5;\n    \n    vec2 revb = cReverbB(t);\n    //vec2 lb = leadb(t)*(pow(sc,0.9))*1.5;\n\t\n    */\n    \n    \n    vec2 lk = lowKick(t);\n    vec2 rev = cReverb(t);\n    vec2 cr = crash(t);\n    \n    \n    cr *= smoothstep(0.,1.,(t - 4.)/46.);\n    \n    s += rev;\n    //s += lk;\n    \n    s += cr*0.02;\n    \n    \n    s = clampify(s, 1.);\n    \n    \n    s = bitreduction(s, smoothstep(0.,1.,(t + -4.)/16./16.) + 0.0001);\n    \n    \n    return s;\n}\n\n\n\n\n\n\n\n\n", "sound_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define bpm (90.)\n\n#define tick (60./bpm)\n\n#define beat (tick)\n#define bar  (beat*4.)\n#define hbar  (bar/2.)\n#define msr  bar*4.\n#define hbeat tick/2.\n#define qbeat tick/4.\n\nfloat[] ts = float[11](16.,25.,32.,34.,msr*6.,msr*7.,msr*7.5, msr*8.25, msr*9.5, msr*10., msr*11.);\n#define scoffs ts[9]*1.\n\n#define PI acos(-1.)\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n\n#define bitreduction(s,amt) s = sign(s) * floor(abs(s)/(amt))*(amt)\n#define sampleratereduction(t, amt) t = floor(t/(amt))*(amt)\n#define smoothify(s, amt) mix(s,sign(s)*smoothstep(0.0,1.,abs(s)), amt)\n#define clampify(s, amt) clamp(s*amt,-1.,1.)\n#define powify(s, amt) pow(abs(s), vec2(amt))*sign(s)\n\n\n", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjyzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[189, 189, 208, 208, 1004], [1006, 1006, 1023, 1023, 1749], [1751, 1751, 1822, 1822, 2083], [2086, 2086, 2128, 2128, 2312], [2314, 2314, 2371, 2371, 3113]], "test": "untested"}
{"id": "wsjczG", "name": "Nine Point Conic on Sphere", "author": "mla", "description": "The Nine Point Conic, mapped projectively to a sphere (ie. (x,y,z) -> normalize(x,y,z). The line at infinity is a bit weird.\n\nSee also:\n\n[url]https://www.shadertoy.com/view/Wd2cRG[/url]\n[url]https://www.shadertoy.com/view/WsscRB[/url]", "tags": ["conic", "projective", "ninepoint"], "likes": 5, "viewed": 349, "published": 3, "date": "1586889121", "time_retrieved": "2024-07-30T21:12:49.445486", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// \"Nine Point Conic\" on a projective sphere.\n//\n// <mouse>: rotate\n// <up>/<down>: move in and out\n// b: show background\n// r: autorotation\n// s: show sphere\n\n// See also:\n// https://www.shadertoy.com/view/Wd2cRG\n// https://www.shadertoy.com/view/WsscRB\n//\n////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// The Nine Point Conic\n// Matthew Arcus, 2020.\n//\n// Given a triangle ABC and a point P, can draw a conic between:\n// The midpoints of the triangle sides\n// The midpoints of the lines from P to each vertex\n// The points where these lines cut the sides of the triangle\n//\n// The conic changes from ellipse to hyperbola when it crosses one of\n// the extended triangle sides, and becomes a circles when P coincides\n// with the orthocentre (intersection of altitudes).\n//\n////////////////////////////////////////////////////////////////////////////////\n\nbool check = false;\n\nvoid assert(bool b) { if (!b) check = true; }\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// Geometric constructions\n//\n// Homogeneous coordinates used throughout (so the lines and points are\n// \"projective\"):\n// (x,y,z) represents the point (x/z,y/z) for z != 0\n// (x,y,0) represents a \"point at infinity\" which acts like a direction.\n// (a,b,c) represents the line ax + by + cz = 0\n// (0,0,c) represents the \"line at infinity\"\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// The line between two projective points, or the intersection of two\n// projective lines, is just their cross product.\nvec3 join(vec3 p, vec3 q) {\n  return cross(p,q);\n}\n\n// The midpoint between p and q (also conjugate with point at infinity)\nvec3 midpoint(vec3 p, vec3 q) {\n  return p*q.z + p.z*q;\n}\n\nfloat distance2(vec3 p, vec3 q) {\n  p /= p.z; q /= q.z;\n  return abs(dot(p-q,p-q));\n}\n\n// Perpendicular bisector (a line)\nvec3 bisector(vec3 p,vec3 q) {\n  // (p-r).(p-r) = (q-r).(q-r) // r equidistant from p and q\n  // pp - 2pr + rr = qq - 2qr + rr\n  // pp - qq = 2pr - 2qr\n  // 2r.(p-q) = pp - qq\n  p /= p.z; q /= q.z;\n  return vec3(2.0*(p.xy-q.xy),dot(q,q)-dot(p,p));\n}\n\n// Drop perpendicular from p onto line q.\nvec3 perpendicular(vec3 p, vec3 q) {\n  // (p + kq.xy).q = 0\n  // p.q + k(q.yx).q = 0\n  float k = dot(p,q)/dot(q.xy,q.xy);\n  return p - k*vec3(q.xy,0);\n}\n\n// Find a projective mapping taking p0,p1,p2,p4 to\n// triangle of reference and unit point, ie:\n// p0 -> (1,0,0), p1 -> (0,1,0), p2 -> (0,0,1), p3 -> (1,1,1)\n// No three points collinear.\nmat3 rproject(vec3 p0, vec3 p1, vec3 p2, vec3 p3) {\n  // Just an inverse for the first three points\n  // (the triangle of reference). No inverse if collinear.\n  mat3 m = inverse(mat3(p0,p1,p2)); // column major!\n  vec3 p3a = m*p3;\n  // Then scale each row so the unit point (1,1,1) is correct\n  m = transpose(m);\n  // zero components here only if not collinear\n  m[0] /= p3a[0];\n  m[1] /= p3a[1];\n  m[2] /= p3a[2];\n  m = transpose(m);\n  return m;\n}\n\n// Construct the conic defined by 5 points.\n// Method taken from \"Geometry\", Brannan, Esplan & Gray, CUP, 2012\nmat3 solve(vec3 p0, vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n  // p takes p0,p1,p2,p3 to triangle of reference and unit point\n  mat3 p = rproject(p0,p1,p2,p3);\n  // Now construct a conic through the images of p0-p4,\n  vec3 p4a = p*p4;\n  float a = p4a.x, b = p4a.y, c = p4a.z;\n  float d = c*(a-b);\n  float e = b*(c-a);\n  float f = a*(b-c);\n  mat3 m = mat3(0,d,e,\n                d,0,f,\n                e,f,0);\n  // And combine the two.\n  mat3 res = transpose(p)*m*p;\n  assert(abs(determinant(res)) > 0.1);\n  return res;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Distance functions\n////////////////////////////////////////////////////////////////////////////////\n\nfloat point(vec3 p, vec3 q) {\n  float pz = p.z, qz = q.z;\n  p *= qz; q *= pz;\n  return distance(p,q)/abs(p.z);\n}\n\nfloat line(vec3 p, vec3 q) {\n  return abs(dot(p,q)/(p.z*length(q.xy)));\n}\n\nfloat line(vec3 p, vec3 q, vec3 r) {\n  return line(p,join(q,r));\n}\n\nfloat segment(vec3 p, vec3 q, vec3 r) {\n  p /= p.z; q /= q.z; r /= r.z; // normalize\n  vec3 pa = p-q;\n  vec3 ba = r-q;\n  float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n  float d = length(pa-h*ba);\n  return d;\n}\n\nfloat conic(vec3 p, mat3 m) {\n  float s = dot(p,m*p);\n  vec3 ds = 2.0*m*p; // Gradient\n  return abs(s/(p.z*length(ds.xy))); // Normalize for Euclidean distance\n}\n\nfloat circle(vec3 p, vec4 c) {\n  // (x-a)^2 + (y-b)^2 = r^2\n  // x2 -2ax + a2 + y2 -2by + b2 -r2 = 0\n  vec3 q = c.xyz;\n  float r2 = c.w;\n  q /= q.z;\n  return conic(p,mat3(1,0,-q.x,\n                      0,1,-q.y,\n                     -q.x,-q.y,dot(q.xy,q.xy)-r2));\n}\n\nfloat quad(vec3 p, vec3 a, vec3 b, vec3 c, vec3 d) {\n  float t = 1e8;\n  t = min(t,segment(p,a,b));\n  t = min(t,segment(p,b,c));\n  t = min(t,segment(p,c,d));\n  t = min(t,segment(p,d,a));\n  return t;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Drawing functions\n////////////////////////////////////////////////////////////////////////////////\n\nvoid getmin(inout float d, inout int index, int i, float t) {\n  if (t < d) { d = t; index = i; }\n}\n\nvec3 colors[] =\n  vec3[](vec3(1,0,0),\n         vec3(1,1,0),\n         vec3(0,0,1),\n         vec3(0,0.8,0),\n         vec3(0,1,1),\n         vec3(0.8),\n         vec3(1,0,1),\n         vec3(1,1,1)\n         );\n\nvec3 getcol(int i) {\n  return colors[i];\n}\n\nvec3 diagram(vec3 p, vec3 P) {\n  vec3 pcol = vec3(0.3);\n  float lwidth = 0.005;\n  float dwidth = 1.5*fwidth(p.x/p.z);\n  float pwidth = 0.03;\n  // The triangle (P is parameter)\n  vec3 A = vec3(1.0,1.0,1), B = vec3(-1.5,-0.5,1), C = vec3(1,-1,1);\n  vec3 AB = join(A,B), BC = join(B,C), CA = join(C,A);\n  vec3 PA = join(P,A), PB = join(P,B), PC = join(P,C);\n  vec3 mBC = midpoint(B,C), mCA = midpoint(C,A), mAB = midpoint(A,B);\n  vec3 mPA = midpoint(P,A), mPB = midpoint(P,B), mPC = midpoint(P,C);\n  vec3 aA = join(PA,BC), aB = join(PB,CA), aC = join(PC,AB);\n  vec3 pA = perpendicular(A,BC);\n  vec3 pB = perpendicular(B,CA);\n  vec3 pC = perpendicular(C,AB);\n  vec3 H = join(join(A,pA),join(B,pB));\n  mat3 X = solve(mAB,mBC,mCA,mPA,mPB);\n\n  vec3 bA = bisector(A,B);\n  vec3 bB = bisector(B,C);\n  // Intersect at the circumcentre\n  vec3 O = join(bA,bB);\n  // centre of the circumcircle.\n  vec4 C1 = vec4(O,distance2(O,A));\n  \n  float d = 1e8;\n  int index = -1;\n  getmin(d,index,0,line(p,AB));\n  getmin(d,index,0,line(p,BC));\n  getmin(d,index,0,line(p,CA));\n\n  getmin(d,index,1,line(p,PA));\n  getmin(d,index,1,line(p,PB));\n  getmin(d,index,1,line(p,PC));\n\n  getmin(d,index,4,line(p,A,pA));\n  getmin(d,index,4,line(p,B,pB));\n  getmin(d,index,4,line(p,C,pC));\n\n  if (false) {\n    getmin(d,index,3,quad(p,mAB,mCA,mPC,mPB));\n    getmin(d,index,3,quad(p,mBC,mAB,mPA,mPC));\n    getmin(d,index,3,quad(p,mCA,mBC,mPB,mPA));\n  }\n  getmin(d,index,2,conic(p,X));\n  getmin(d,index,5,circle(p,C1));\n\n  //vec3 bgcolor = 0.1*vec3(0.75,0.25,1); //vec3(1,1,0.8);\n  vec3 col = vec3(1,1,0.8);  \n  col = mix(0.9*getcol(index),col,smoothstep(lwidth,lwidth+dwidth,d));\n  d = 1e8;\n  getmin(d,index,0,point(p,P));\n\n  getmin(d,index,0,point(p,A));\n  getmin(d,index,0,point(p,B));\n  getmin(d,index,0,point(p,C));\n\n  getmin(d,index,0,point(p,mBC));\n  getmin(d,index,0,point(p,mCA));\n  getmin(d,index,0,point(p,mAB));\n\n  getmin(d,index,0,point(p,mPA));\n  getmin(d,index,0,point(p,mPB));\n  getmin(d,index,0,point(p,mPC));\n  \n  getmin(d,index,0,point(p,aA));\n  getmin(d,index,0,point(p,aB));\n  getmin(d,index,0,point(p,aC));\n\n  getmin(d,index,0,point(p,H));\n  \n  col = mix(pcol,col,smoothstep(pwidth,pwidth+dwidth,d));\n  return col;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// The Sphere\n////////////////////////////////////////////////////////////////////////////////\n\nconst float AA = 2.0;\nconst int maxiterations = 50;\n\nbool dobackground = true;\nbool dorotate = true;\nbool dosphere = true;\n\nconst float PI = 3.14159265;\n\n// R3 inversion in sphere, centre q, square radius r2.\nvec3 invert(vec3 p, vec3 q, float r2) {\n  p -= q;\n  p *= r2/dot(p,p);\n  p += q;\n  return p;\n}\n\nvec3 stereographic0(vec3 p) {\n  return invert(p,vec3(0,0,-1),2.0);\n}\n\n// Invert in sphere radius sqrt(2), centre (0,0,-1)\n// is stereographic projection from the unit sphere\n// to z=0 (and its inverse).\nvec2 stereographic(vec3 p) {\n  return stereographic0(p).xy;\n}\n\nvec3 istereographic(vec2 z) {\n  return stereographic0(vec3(z,0));\n}\n\nvec3 transform(in vec3 p);\n\nvec3 getspherecolor(vec3 p3) {\n  //if (p3.z < 0.0) return vec3(0,0,0.2);\n  // Map to the plane\n  p3 = transform(p3);\n  vec2 p = p3.xy/p3.z;\n  vec3 P = iMouse.x <= 0.0 ? vec3(0,0,1)\n    : vec3((2.0*iMouse.xy-iResolution.xy)/iResolution.y,1);\n  P = vec3(cos(iTime),sin(1.1*iTime),1);\n  return diagram(vec3(p,1),P);\n}\n\nstruct Ray {\n  vec3 q;               // origin\n  vec3 d;               // direction\n};\n\nstruct Hit {\n  float t;      // solution to p=q+t*d\n  vec3 n;       // normal\n};\n\nstruct Sphere {\n  vec3 p;       // centre\n  float r;      // radius\n};\n\nbool intersectSphere(Sphere s, Ray ray, out Hit hit[2]) {\n  vec3 p = s.p;\n  float r = s.r;\n  float c = length(p);\n  vec3 q = ray.q, d = ray.d;\n  // Formula for x^2 + 2Bx + C = 0\n  // |q + t*d - p|^2 = r^2\n  float B = dot(q-p,d);\n  float C = dot(q,q)-2.0*dot(q,p)+(c+r)*(c-r);\n  float D = B*B - C;\n  if (D < 0.0) return false;\n  D = sqrt(D);\n  float t0,t1;\n  if (B >= 0.0) {\n    t0 = -B-D; t1 = C/t0;\n  } else {\n    t1 = -B+D; t0 = C/t1;\n  }\n  hit[0] = Hit(t0,(q+t0*d-p)/r);\n  hit[1] = Hit(t1,(q+t1*d-p)/r);\n  return true;\n}\n\nbool intersectScene(Ray r, out Hit hit[2]) {\n  Sphere s = Sphere(vec3(0),1.0);\n  if (intersectSphere(s,r,hit)) {\n    return true;\n  }\n  return false;\n}\n\nvec3 light;\n\nvec3 solve(Ray r,vec2 uv) {\n  Hit hit[2];\n  vec3 c = vec3(0);\n  if (!dosphere || !intersectScene(r,hit)) {\n    if (dobackground) {\n      vec3 p = istereographic(uv);\n      c = getspherecolor(p);\n      c *= dosphere ? 0.2 : 0.8;\n    }\n  } else {\n    for (int i = 0; i < 2; i++) {\n      vec3 p = r.q+hit[i].t*r.d;\n      vec3 n = hit[i].n;\n      vec3 basecolor = getspherecolor(hit[i].n);\n      if (basecolor == vec3(0)) continue;\n      vec3 color = vec3(0);\n      float ambient = 0.5;\n      float diffuse = 0.5;\n      color += basecolor*ambient;\n      color += basecolor*diffuse*max(0.0,dot(light,n));\n      float specular = pow(max(0.0,dot(reflect(light,n),r.d)),5.0);\n      vec3 speccolor = basecolor; //vec3(1);\n      color += 1.0*specular*speccolor;\n      return color;\n    }\n  }\n  return c;\n}\n\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\n\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nbool key(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\n\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (dorotate) {\n    p.yz = rotate(p.yz,iTime * 0.125);\n    p.zx = rotate(p.zx,iTime * 0.2);\n  }\n  return p;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  dobackground = !key(CHAR_B);\n  dorotate = !key(CHAR_R);\n  dosphere = !key(CHAR_S);\n\n  light = vec3(0.5,1.0,1.0);\n  light = normalize(light);\n\n  vec3 p = vec3(0,0,6);\n  p.z *= exp(-0.1*float(keycount(KEY_UP)-keycount(KEY_DOWN)));\n  vec3 col = vec3(0);\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n      vec3 r = vec3(uv,-6);\n      r = normalize(r);\n      col += solve(Ray(p,r),uv);\n    }\n  }\n  col = pow(col/(AA*AA),vec3(0.4545));\n  //if (check) fragColor = 3(1,0,0);\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0) {\n      t = vec4(0);\n    } else {\n      t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsjczG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1080, 1080, 1101, 1101, 1125], [1635, 1755, 1782, 1782, 1805], [1807, 1879, 1910, 1910, 1936], [1938, 1938, 1971, 1971, 2023], [2025, 2060, 2090, 2235, 2309], [2311, 2353, 2389, 2437, 2505], [2507, 2695, 2746, 2853, 3143], [3145, 3256, 3313, 3378, 3773], [3960, 3960, 3989, 3989, 4072], [4074, 4074, 4102, 4102, 4147], [4149, 4149, 4185, 4185, 4215], [4217, 4217, 4256, 4256, 4428], [4430, 4430, 4459, 4459, 4591], [4593, 4593, 4623, 4693, 4859], [4861, 4861, 4913, 4913, 5060], [5246, 5246, 5307, 5307, 5344], [5550, 5550, 5570, 5570, 5592], [5594, 5594, 5624, 5624, 7790], [8123, 8178, 8217, 8217, 8271], [8273, 8273, 8302, 8302, 8341], [8343, 8476, 8504, 8504, 8537], [8539, 8539, 8568, 8568, 8606], [8636, 8636, 8666, 8730, 8950], [9194, 9194, 9251, 9251, 9717], [9719, 9719, 9763, 9763, 9870], [9885, 9885, 9912, 9912, 10680], [10898, 10898, 10918, 10918, 10978], [10980, 10980, 11005, 11005, 11053], [11055, 11055, 11078, 11078, 11110], [11112, 11207, 11234, 11234, 11410], [11412, 11412, 11442, 11442, 11494], [11496, 11496, 11523, 11523, 11852], [11854, 11854, 11906, 11906, 12512]], "test": "untested"}
{"id": "3sXyDS", "name": "大龙猫 - Quicky#031", "author": "totetmatt", "description": "quicky", "tags": ["quicky"], "likes": 7, "viewed": 353, "published": 3, "date": "1586884265", "time_retrieved": "2024-07-30T21:12:50.458777", "image_code": "float box(vec2 uv, vec2 size){\n    vec2 d = abs(uv)-size;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nmat2 r(float a){\n    float c=cos(a),s=sin(a);\n    return mat2(c,-s,s,c);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy -.5* iResolution.xy) / iResolution.y;\n    uv*=.8;\n    float d = 0.;\n    float limit = 12.;\n    vec3 col = vec3(0.);\n    for(float i=0.1;i<=1.;i+=1./limit){\n             \n         float q = mix(1.,5.,i)* box( uv*r(i*iTime+sin(iTime)) + vec2(i*.1*sin(iTime),i*.1*cos(iTime)) , vec2(.3*i,pow(i,2.)*.2+.1) );\n         q = abs(q) -(.02*i);\n         q = smoothstep(0.001,0.0009*i,q);\n         d += q;\n           col.g +=  clamp(1.,.0,q*(.02/ (.0001+fract(iTime*.5+i))));\n           col.b +=   fract(iTime+i)*q  ;\n       \n          }\n   \n  \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXyDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 114], [115, 115, 131, 131, 189], [190, 190, 245, 245, 840]], "test": "untested"}
{"id": "wd2yRG", "name": "Gotta Catch em All", "author": "Skatzogirous", "description": "teehee", "tags": ["gottacatchemall"], "likes": 1, "viewed": 255, "published": 3, "date": "1586882298", "time_retrieved": "2024-07-30T21:12:51.367348", "image_code": "    \nstruct Material\n{\n    vec3 albedo;\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n    \n};\n    \nstruct Sphere\n{\n    vec3 center;\n    float radius;\n    Material material;\n};\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float aspect_ratio = iResolution.x/iResolution.y;\n    \n    uv.x *= aspect_ratio;\n\n\tSphere sph;   \n\n\tfloat outlineLength = 0.006;\n    sph.center = vec3(0.5,0.5,5.0);\n    sph.center.x *= aspect_ratio;\n    sph.radius = 0.3;\n    \n    sph.material.albedo = vec3(1.0,0.1,0.1);\n    \n    sph.material.ambient = vec3(0.52,0.52,0.52);\n    \n    sph.material.diffuse = vec3(0.1,0.1,0.1);\n    \n    sph.material.specular = vec3(0.52,0.52,0.52);\n    sph.material.shininess = 16.0;\n    \n    vec3 camera = vec3 (0.5,0.5,0.0);\n    \n    float centerDist = 0.23;\n    vec3 lightPos = vec3(9.0 * sin(iTime)*0.5,6.0 * cos(iTime)*0.5,-5.0);\n    vec3 lightColor = vec3(1.0);\n    \n    vec3 col = vec3(0.0);\n    if(length(uv - vec2(sph.center.x,sph.center.y)) < sph.radius - centerDist)\n    {\n        if(length(uv - vec2(sph.center.x,sph.center.y)) > sph.radius - centerDist-0.015)\n        {\n            float custom_z = (sph.center.z - sqrt(pow(sph.radius,2.0) - pow(uv.y - sph.center.y,2.0)));\n        \n        vec3 uv_3D = vec3(uv,custom_z);\n\t\n        vec3 ambient = vec3(0.0);\n        vec3 diffuse = vec3(0.0);\n        vec3 specular = vec3(0.0);\n        \n        ambient = sph.material.ambient * vec3(0.1,0.1,0.1) * lightColor;\n        \n        vec3 normal = normalize(uv_3D - sph.center);\n        vec3 lightDir = normalize(lightPos - uv_3D);\n        float diff = max(dot(normal, lightDir),0.0);\n        \n        \n        diffuse = sph.material.albedo * vec3(0.0,0.0,0.0) * lightColor * diff;\n        \n        vec3 viewDir = normalize(camera - uv_3D);\n        vec3 reflectDir = reflect(-lightDir,normal); //might need normalize\n        float spec = pow(max(dot(viewDir, reflectDir),0.0),sph.material.shininess);\n        specular = vec3(0.2,0.2,0.2) * spec;\n        \n        col = ambient + diffuse + specular;\n        }\n        else if(length(uv - vec2(sph.center.x,sph.center.y)) > sph.radius - centerDist-0.035)\n        {\n           float custom_z = (sph.center.z - sqrt(pow(sph.radius,2.0) - pow(uv.y - sph.center.y,2.0)) + 0.8);\n        \n        vec3 uv_3D = vec3(uv,custom_z);\n\t\n        vec3 ambient = vec3(0.0);\n        vec3 diffuse = vec3(0.0);\n        vec3 specular = vec3(0.0);\n        \n        ambient = sph.material.ambient * vec3(1.0,1.0,1.0) * lightColor;\n        \n        vec3 normal = normalize(uv_3D - sph.center);\n        vec3 lightDir = normalize(lightPos - uv_3D);\n        float diff = max(dot(normal, lightDir),0.0);\n        \n        \n        diffuse = sph.material.albedo * sph.material.diffuse * lightColor * diff;\n        \n        vec3 viewDir = normalize(camera - uv_3D);\n        vec3 reflectDir = reflect(-lightDir,normal); //might need normalize\n        float spec = pow(max(dot(viewDir, reflectDir),0.0),sph.material.shininess);\n        specular = sph.material.specular * spec;\n        \n        col = ambient + diffuse + specular;\n        }\n        else\n        {\n            float custom_z = sph.center.z - sqrt(pow(sph.radius,2.0) - pow(uv.y - sph.center.y,2.0) + 1.0);\n        \n        vec3 uv_3D = vec3(uv,custom_z);\n\t\n        vec3 ambient = vec3(0.0);\n        vec3 diffuse = vec3(0.0);\n        vec3 specular = vec3(0.0);\n        \n        ambient = sph.material.ambient * vec3(0.98,0.98,0.98) * lightColor;\n        \n        vec3 normal = normalize(uv_3D - sph.center);\n        vec3 lightDir = normalize(lightPos - uv_3D);\n        float diff = max(dot(normal, lightDir),0.0);\n        \n        \n        diffuse = sph.material.albedo * sph.material.diffuse * lightColor * diff;\n        \n        vec3 viewDir = normalize(camera - uv_3D);\n        vec3 reflectDir = reflect(-lightDir,normal); //might need normalize\n        float spec = pow(max(dot(viewDir, reflectDir),0.0),sph.material.shininess);\n        specular = sph.material.specular * spec;\n        \n        col = ambient + diffuse + specular;\n        }\n       \n    }\n    if(length(uv - vec2(sph.center.x,sph.center.y)) <= sph.radius && length(uv - vec2(sph.center.x,sph.center.y)) >= sph.radius - outlineLength )\n    {\n        float custom_z = sph.center.z - sqrt(pow(sph.radius,2.0) - pow(uv.y - sph.center.y,2.0));\n        \n        vec3 uv_3D = vec3(uv,custom_z);\n\t\n        vec3 ambient = vec3(0.0);\n        vec3 diffuse = vec3(0.0);\n        vec3 specular = vec3(0.0);\n        \n        ambient = vec3(0.8,0.8,0.8) * lightColor;\n        \n        vec3 normal = normalize(uv_3D - sph.center);\n        vec3 lightDir = normalize(lightPos - uv_3D);\n        float diff = max(dot(normal, lightDir),0.0);\n        \n        \n        diffuse = sph.material.albedo * sph.material.diffuse * lightColor * diff;\n        \n        vec3 viewDir = normalize(camera - uv_3D);\n        vec3 reflectDir = reflect(-lightDir,normal); //might need normalize\n        float spec = pow(max(dot(viewDir, reflectDir),0.0),sph.material.shininess);\n        specular = sph.material.specular * spec;\n        \n        col = ambient + diffuse + specular;\n    }\n    if(length(uv - vec2(sph.center.x,sph.center.y)) < sph.radius - outlineLength && length(uv - vec2(sph.center.x,sph.center.y)) >= sph.radius - centerDist)\n    {\n        if(uv.y <= 0.485)\n        {\n            float custom_z = sph.center.z - sqrt(pow(sph.radius,2.0) - pow(uv.y - sph.center.y,2.0) + 0.8);\n        \n        vec3 uv_3D = vec3(uv,custom_z);\n\t\n        vec3 ambient = vec3(0.0);\n        vec3 diffuse = vec3(0.0);\n        vec3 specular = vec3(0.0);\n        \n        ambient = sph.material.ambient * vec3(1.0,1.0,1.0) * lightColor;\n        \n        vec3 normal = normalize(uv_3D - sph.center);\n        vec3 lightDir = normalize(lightPos - uv_3D);\n        float diff = max(dot(normal, lightDir),0.0);\n        \n        \n        diffuse = sph.material.albedo * sph.material.diffuse * lightColor * diff;\n        \n        vec3 viewDir = normalize(camera - uv_3D);\n        vec3 reflectDir = reflect(-lightDir,normal); //might need normalize\n        float spec = pow(max(dot(viewDir, reflectDir),0.0),sph.material.shininess);\n        specular = sph.material.specular * spec;\n        \n        col = ambient + diffuse + specular;\n        }else if (uv.y>=0.505)\n        {\n             float custom_z = sph.center.z - sqrt(pow(sph.radius,2.0) - pow(uv.y - sph.center.y,2.0) + 0.8);\n        \n        vec3 uv_3D = vec3(uv,custom_z);\n\t\n        vec3 ambient = vec3(0.0);\n        vec3 diffuse = vec3(0.0);\n        vec3 specular = vec3(0.0);\n        \n        ambient = sph.material.ambient * sph.material.albedo * lightColor;\n        \n        vec3 normal = normalize(uv_3D - sph.center);\n        vec3 lightDir = normalize(lightPos - uv_3D);\n        float diff = max(dot(normal, lightDir),0.0);\n        \n        \n        diffuse = sph.material.albedo * sph.material.diffuse * lightColor * diff;\n        \n        vec3 viewDir = normalize(camera - uv_3D);\n        vec3 reflectDir = reflect(-lightDir,normal); //might need normalize\n        float spec = pow(max(dot(viewDir, reflectDir),0.0),sph.material.shininess);\n        specular = sph.material.specular * spec;\n        \n        col = ambient + diffuse + specular;\n        }else\n        {\n            float custom_z = (sph.center.z - sqrt(pow(sph.radius,2.0) - pow(uv.y - sph.center.y,2.0)));\n        \n        vec3 uv_3D = vec3(uv,custom_z);\n\t\n        vec3 ambient = vec3(0.0);\n        vec3 diffuse = vec3(0.0);\n        vec3 specular = vec3(0.0);\n        \n        ambient = sph.material.ambient * vec3(0.1,0.1,0.1) * lightColor;\n        \n        vec3 normal = normalize(uv_3D - sph.center);\n        vec3 lightDir = normalize(lightPos - uv_3D);\n        float diff = max(dot(normal, lightDir),0.0);\n        \n        \n        diffuse = sph.material.albedo * vec3(0.0,0.0,0.0) * lightColor * diff;\n        \n        vec3 viewDir = normalize(camera - uv_3D);\n        vec3 reflectDir = reflect(-lightDir,normal); //might need normalize\n        float spec = pow(max(dot(viewDir, reflectDir),0.0),sph.material.shininess);\n        specular = vec3(0.2,0.2,0.2) * spec;\n        \n        col = ambient + diffuse + specular;\n        }\n       \n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2yRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[212, 212, 269, 319, 8396]], "test": "untested"}
{"id": "3sByD1", "name": "Birthday Wish", "author": "piyushslayer", "description": "This is how I'm wishing my friends and relatives a Happy Birthday from now on! ;)", "tags": ["2d", "sdf", "font", "birthday"], "likes": 8, "viewed": 1239, "published": 3, "date": "1586880957", "time_retrieved": "2024-07-30T21:12:52.334761", "image_code": "#define PI 3.1415926535\n#define SAT(x) clamp(0., 1., x)\n#define S(a, b, x) smoothstep(a, b, x)\n\nmat2 rot(float a)\n{\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat sdBox(vec2 p, vec2 b)\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.)) + min(max(d.x, d.y), 0.);\n}\n\nfloat sdA(vec2 uv, float ah, float al, float t, bool inner)\n{\n    uv *= rot(sin((iTime) * 4.) * .1);\n \tfloat a = 0.;\n    a = S(ah, al, sdBox(vec2(uv.x + .1, uv.y) * rot(PI * .08), vec2(t, .25 + t)));\n    a += S(ah, al, sdBox(vec2(uv.x - .1, uv.y) * rot(-PI * .08), vec2(t, .25 + t)));\n    a += S(ah, al, sdBox(vec2(uv.x, uv.y + .05), vec2(.1, t * .8)));\n    a = min(a, S(ah, al, sdBox(uv, vec2(.26, .26))));\n    if(inner)\n    \ta = min(a, S(ah, al, sdBox(uv, vec2(.26, .25))));\n    return a;\n}\n\nfloat sdB(vec2 uv, float ah, float al, float t, float inner)\n{\n\tuv *= rot(sin((iTime) * 4.) * .1);\n    float b = S(ah, al, sdBox(vec2(uv.x + .12, uv.y), vec2(t, .2 + t)));\n    b += S(ah, al, abs(sdBox(vec2(uv.x+t+inner, uv.y-.12), vec2(.1, .0001))-.09)-t*.9);\n    b += S(ah, al, abs(sdBox(vec2(uv.x+t+inner, uv.y+.12), vec2(.1, .0001))-.09)-t*.9);\n    b = min(b, S(ah, al, sdBox(vec2(uv.x - .04, uv.y), vec2(.22, .28))));\n    if (inner > 0.)\n        b = min(b, S(ah, al, sdBox(vec2(uv.x - .0435, uv.y), vec2(.21, .28))));\n    return b; \n}\n\nfloat sdD(vec2 uv, float ah, float al, float t, float inner)\n{\n    uv *= rot(sin(iTime * 4.) * .1);\n\tfloat d = S(ah, al, sdBox(vec2(uv.x + .12, uv.y), vec2(t, .2 + t)));\n    d += S(ah, al, abs(sdBox(vec2(uv.x+t+inner+.06, uv.y), vec2(.1, .0001))-.202)-t);\n    d = min(d, S(ah, al, sdBox(vec2(uv.x - .04, uv.y), vec2(.22, .28))));\n    if (inner > 0.)\n        d = min(d, S(ah, al, sdBox(vec2(uv.x - .07, uv.y), vec2(.236, .26))));\n    return d;\n}\n\nfloat sdH(vec2 uv, float ah, float al, float t)\n{\n    uv *= rot(sin(iTime * 4.) * .1);\n\tfloat h = 0.;\n    h = S(ah, al, sdBox(vec2(uv.x + .12, uv.y), vec2(t, .2 + t)));\n    h += S(ah, al, sdBox(vec2(uv.x - .12, uv.y), vec2(t, .2 + t)));\n    h += S(ah, al, sdBox(uv, vec2(.1, t)));\n    return h;\n}\n\nfloat sdI(vec2 uv, float ah, float al, float t)\n{\n    uv *= rot(sin(iTime * 4.) * .1);\n    return S(ah, al, sdBox(uv, vec2(t, .2 + t)));\n}\n\nfloat sdP(vec2 uv, float ah, float al, float t, float inner)\n{\n    uv *= rot(sin(iTime * 4.) * .1);\n    float p = S(ah, al, sdBox(vec2(uv.x + .12, uv.y), vec2(t, .2 + t)));\n    p += S(ah, al, abs(sdBox(vec2(uv.x+t+inner, uv.y-.106), vec2(.1, .0001))-.1)-t);\n    p = min(p, S(ah, al, sdBox(vec2(uv.x - .04, uv.y), vec2(.22, .28))));\n    if (inner > 0.)\n        p = min(p, S(ah, al, sdBox(vec2(uv.x - .043, uv.y), vec2(.21, .28))));\n    return p;\n}\n\nfloat sdR(vec2 uv, float ah, float al, float t, float inner)\n{\n    uv *= rot(sin(iTime * 4.) * .1);\n    float r = S(ah, al, sdBox(vec2(uv.x + .12, uv.y), vec2(t, .2 + t)));\n    r += S(ah, al, abs(sdBox(vec2(uv.x+t+inner, uv.y-.106), vec2(.1, .0001))-.1)-t);\n    r += S(ah, al, sdBox(vec2(uv.x - .1, uv.y + .18) * rot(-PI * .2), vec2(t, .2)));\n    r = min(r, S(ah, al, sdBox(vec2(uv.x - .04, uv.y - .02), vec2(.22, .28))));\n    if (inner > 0.)\n        r = min(r, S(ah, al, sdBox(vec2(uv.x-.04, uv.y-.02-inner), vec2(.207, .28))));\n    return r;\n}\n\nfloat sdT(vec2 uv, float ah, float al, float t, bool inner)\n{\n    uv *= rot(sin(iTime * 4.) * .1);\n\tfloat tt = S(ah, al, sdBox(vec2(uv.x, uv.y + .03), vec2(t, .23)));\n    tt += S(ah, al, sdBox(vec2(uv.x, uv.y - .2), vec2(.23, t)));\n    if(inner)\n        tt = min(tt, S(ah, al, sdBox(uv, vec2(.22, .25))));\n    return tt;\n}\n\nfloat sdY(vec2 uv, float ah, float al, float t, bool inner)\n{\n    uv *= rot(sin(iTime * 4.) * .1);\n    float y = S(ah, al, sdBox(vec2(uv.x, uv.y + .14), vec2(t, .12)));\n    y += S(ah, al, sdBox(vec2(uv.x + .1, uv.y - .14) * rot(PI * .86), vec2(t, .24)));\n    y += S(ah, al, sdBox(vec2(uv.x - .1, uv.y - .14) * rot(-PI * .86), vec2(t, .24)));\n    y = min(y, S(ah, al, sdBox(vec2(uv.x, uv.y + .2), vec2(.45))));\n    if (inner)\n        y = min(y, S(ah, al, sdBox(vec2(uv.x, uv.y + .005), vec2(.3, .245))));\n    return y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    // background **modified** from: https://www.shadertoy.com/view/wlBGDG\n    vec2 p = uv, o = p;\n    vec3 bk = vec3(0.);\n    float t = (iTime + 25.) * .075, e = length(o), k = o.y + o.x, l, r, a;\n    for(int i = 0; i < 40; ++i)\n    {\n        a = float(i);\n        r = fract(sin(a * 9.7)) * .75;\n        l = length(p = mod(p + vec2(sin(a + a - t), cos(t + a) + t * .1), 2.) - 1.);\n        bk += pow(mix(vec3(.32, .08 , .16), vec3(.4, .3, .1) + vec3(0, k, k) * .064, a / 40.),\n                vec3(3.)) * (pow(max(1. - abs(l - r + e * .2), 0.), 25.) * .2 + smoothstep(r, r - e * .2, l));\n    }\n    \n    vec3 col = mix(mix(vec3(.25, .1, .25), vec3(.35, .25, .015), dot(uv, vec2(.2, .7))), \n                    bk * 6.4, SAT(bk.r + bk.g + bk.b));\n    const vec3 white = vec3(1.);\n    const vec3 shadow = vec3(.1);\n    float shadowStr = .666;\n    float topGrad = SAT(sqrt(uv.y * 1.2));\n    float botGrad = SAT(pow(uv.y * .7 + .5, .24));\n    \n    vec2 st = vec2(uv.x + .76, uv.y - .4);\n\tcol = mix(col, shadow, shadowStr * sdH(st, .06, -.05, .06));\n    col = mix(col, white, sdH(st, .015, .005, .06));\n    col = mix(col, mix(white, vec3(.006, .08, .99), topGrad), \n              SAT(sdH(st, .015, .005, .048)));\n    \n    st = vec2(uv.x + .37, uv.y - .4);\n    col = mix(col, shadow, shadowStr * SAT(sdA(st, .05, -.05, .05, false)));\n    col = mix(col, white, sdA(st, .015, .005, .055, false));\n    col = mix(col, mix(white, vec3(.99, .001, .005), topGrad), \n              sdA(st, .015, .005, .044, true));\n    \n    st = vec2(uv.x, uv.y - .4);\n    col = mix(col, shadow, shadowStr * sdP(st, .06, -.06, .05, 0.));\n    col = mix(col, white, sdP(st, .015, .005, .06, 0.));\n    col = mix(col, mix(white, vec3(.02, .95, .06), topGrad),\n              sdP(st, .015, .005, .046, .01));\n    \n    st = vec2(uv.x - .34, uv.y - .4);\n    col = mix(col, shadow, shadowStr * sdP(st, .06, -.06, .05, 0.));\n    col = mix(col, white, sdP(st, .015, .005, .06, 0.));\n    col = mix(col, mix(white, vec3(.98, .42, .01), topGrad),\n              sdP(st, .015, .005, .046, .01));\n    \n    st = vec2(uv.x - .66, uv.y - .4);\n    col = mix(col, shadow, shadowStr * sdY(st, .05, -.05, .05, false));\n    col = mix(col, white, sdY(st, .015, .005, .06, false));\n    col = mix(col, mix(white, vec3(.98, .01, .34), topGrad), \n              sdY(st, .015, .005, .048, true));\n    \n    st = vec2(uv.x + 1.2, uv.y + .4);\n    col = mix(col, shadow, shadowStr * sdB(st, .06, -.06, .05, 0.));\n    col = mix(col, white, sdB(st, .015, .005, .06, 0.));\n    col = mix(col, mix(white, vec3(.99, .001, .005), botGrad),\n              sdB(st, .015, .005, .046, .01));\n    \n    st = vec2(uv.x + .96, uv.y + .4);\n    col = mix(col, shadow, shadowStr * sdI(st, .06, -.06, .06));\n    col = mix(col, white, sdI(st, .015, .005, .06));\n    col = mix(col, mix(white, vec3(.01, .56, .87), botGrad), \n              sdI(st, .015, .005, .048));\n    \n    st = vec2(uv.x + .71, uv.y + .4);\n    col = mix(col, shadow, shadowStr * sdR(st, .06, -.06, .05, .0));\n\tcol = mix(col, white, sdR(st, .015, .005, .06, .0));\n    col = mix(col, mix(white, vec3(.48, .005, .76), botGrad),\n              sdR(st, .015, .005, .046, .01));\n    \n    st = vec2(uv.x + .32, uv.y + .4);\n    col = mix(col, shadow, shadowStr * sdT(st, .06, -.06, .06, false));\n    col = mix(col, white, sdT(st, .015, .005, .06, false));\n    col = mix(col, mix(white, vec3(.97, .96, .006), botGrad), \n              SAT(sdT(st, .015, .005, .048, true)));\n    \n    st = vec2(uv.x - .08, uv.y + .4);\n    col = mix(col, shadow, shadowStr * sdH(st, .06, -.05, .06));\n    col = mix(col, white, sdH(st, .015, .005, .06));\n    col = mix(col, mix(white, vec3(.98, .01, .34), botGrad), \n              SAT(sdH(st, .015, .005, .048)));\n\n    st = vec2(uv.x - .45, uv.y + .4);\n    col = mix(col, shadow, shadowStr * sdD(st, .06, -.06, .05, 0.));\n    col = mix(col, white, sdD(st, .015, .005, .06, 0.));\n    col = mix(col, mix(white, vec3(.02, .95, .06), botGrad), \n              sdD(st, .015, .005, .046, .01));\n    \n    st = vec2(uv.x - .82, uv.y + .4);\n    col = mix(col, shadow, shadowStr * sdA(st, .05, -.05, .05, false));\n    col = mix(col, white, sdA(st, .015, .005, .055, false));\n    col = mix(col, mix(white, vec3(.006, .08, .99), botGrad), \n              sdA(st, .015, .005, .044, true));\n    \n    st = vec2(uv.x - 1.12, uv.y + .4);\n    col = mix(col, shadow, shadowStr * sdY(st, .05, -.05, .05, false));\n    col = mix(col, white, sdY(st, .015, .005, .06, false));\n    col = mix(col, mix(white, vec3(.98, .42, .01), botGrad), \n              sdY(st, .015, .005, .048, true));\n    \n    fragColor = vec4(pow(col, vec3(.8)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sByD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 115, 115, 167], [169, 169, 198, 198, 281], [283, 283, 344, 344, 775], [777, 777, 839, 839, 1315], [1317, 1317, 1379, 1379, 1761], [1763, 1763, 1812, 1812, 2059], [2061, 2061, 2110, 2110, 2199], [2201, 2201, 2263, 2263, 2647], [2649, 2649, 2711, 2711, 3194], [3196, 3196, 3257, 3257, 3518], [3520, 3520, 3581, 3581, 4039], [4041, 4041, 4098, 4098, 8781]], "test": "untested"}
{"id": "Ws2czy", "name": "fdtd but with cos sin", "author": "lomateron", "description": "shows 5 different code methods\nin Buf A uncomment //if(iFrame) to initialze with different type of waves", "tags": ["waves", "sound", "simulation", "light", "1d"], "likes": 3, "viewed": 414, "published": 3, "date": "1586879430", "time_retrieved": "2024-07-30T21:12:53.289209", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = fragCoord/iResolution.xy;\n         u.x*= 128./iResolution.x;\n    \n    vec4 C = texture(iChannel0, u);\n           C.z = length(C.xy);\n           C.w = atan(C.y,C.x)/3.14;\n\n    vec4 b = u.y*vec4(8.)-vec4(1.,3.,5.,7.);\n    \n    float c = +float(b.x<C.x && b.x>0.)\n              +float(b.x>C.x && b.x<0.)\n              +float(b.y<C.y && b.y>0.)\n              +float(b.y>C.y && b.y<0.)\n              +float(b.z<C.z && b.z>0.)\n              +float(b.z>C.z && b.z<0.)\n              +float(b.w<C.w && b.w>0.)\n              +float(b.w>C.w && b.w<0.);\n\n    fragColor = vec4(c);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec2 m = vec2(128.,iResolution.y);\n    vec4 C = texture(iChannel0, mod(u+vec2(0,0),m)/iResolution.xy);\n    vec4 R = texture(iChannel0, mod(u+vec2(1,0),m)/iResolution.xy);\n    vec4 L = texture(iChannel0, mod(u-vec2(1,0),m)/iResolution.xy);\n    \n    float pi = 3.14159265359;\n    \n    //method1 https://www.eecs.wsu.edu/~schneidj/ufdtd/\n    //if((iFrame&1) == 0) C.x += L.y* .1 + C.y*-.1;\n    //if((iFrame&1) != 0) C.y += R.x*-.1 + C.x* .1;\n    \n    //method2 similar to https://www.shadertoy.com/view/wllXWs\n    //if((iFrame&1) == 0) C.x += L.y* .05 + R.y*-.05;\n    //if((iFrame&1) != 0) C.y += L.x* .05 + R.x*-.05;\n    \n    //method3 chained rotating circles\n    C.x  = cos(atan(C.x,L.y)+.05-vec2(0.,pi*.5)).y*length(vec2(L.y,C.x));\n    C.y  = cos(atan(R.x,C.y)+.05-vec2(0.,pi*.5)).x*length(vec2(C.y,R.x));\n    C.xy = cos(atan(C.y,C.x)+.05-vec2(0.,pi*.5))  *length(C.xy);\n    \n    //method4 position in .x velocity in .y\n    //C.y += (L.x-C.x) + (R.x-C.x);\n    //C.x += C.y*.125;\n    \n    //method5 position in .x saving previous position in .y and use it to extract velocity\n    //float x = C.x;\n    //C.x = C.x*.6 + L.x*.2 + R.x*.2 + C.x-C.y;\n    //C.y = x;\n    \n    float uf = u.x-64.;\n    float fr = float(iFrame)- 100.;\n    if(iFrame == 0) C = exp(-uf*uf /32.)*vec4(1.,.0,.0,.0)+.5;\n    //if(iFrame == 0) C = exp(-uf*uf /64.)*cos((u.x-64.)*.5)+vec4(.5);\n    //if(iFrame == 0) C.x = (sin(u.x/128.5*pi*8.))+.5;\n    //if(iFrame == 0) C.x = fract(sin(u.x)*59233.83635962)+.5;\n    //if(iFrame == 0) C = vec4(u.x==64.5,0.,.0,.0)+.5;\n    //if(iFrame < 600 && u.x==60.5) C.x = exp(-fr*fr / 1000.);\n    \n    fragColor = C;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2czy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 640]], "test": "untested"}
{"id": "3djyzy", "name": "Random-Walking Blob", "author": "fisheep", "description": "Randomly Moving Blob, pixelized (quantilized?).\nThe next random position is generated from the time stamp.\n(It was probably better to get a regular random number, instead of building one from bits)", "tags": ["randomwalk", "pixelized"], "likes": 1, "viewed": 320, "published": 3, "date": "1586875888", "time_retrieved": "2024-07-30T21:12:54.155892", "image_code": "#define MASK 123459876\n#define Q 16.0\n#define INV_Q (1.0/Q)\n\n// Taken from \"Numerical Recipes In C\" Cambridge Uni. 2nd ed\nint rbit(inout int s)\n{\n    s ^= MASK;\n    int res = (s >> 17) & 1 ^\n        (s >> 4) & 1 ^ \n    \t(s >> 1) & 1 ^\n        s & 1;\n    s ^= MASK;\n    s = (s << 1) | res;\n    return res;\n}\n\nvec2 hash(float v)\n{\n    int s = int(v);\n    vec2 res = vec2(0);\n    for(int i =0;i<5;i++)\n    {\n        res.x += float(rbit(s)<<i);\n        res.y += float(rbit(s)<<i);\n    }\n    res.x *= (rbit(s) == 1? -1.0:1.0)/64.0;\n    res.y *= (rbit(s) == 1? -1.0:1.0)/64.0;\n    return res;\n}\n\nfloat hitAt(vec2 uv, float v)\n{\n    vec2 p = hash(floor(v));\n    vec2 np = hash(floor(v+1.0));\n    float m = fract(v);\n    m *= m*(3.0-2.0*m);\n    return length(uv - mix(p,np, m)) < 0.25? 1.0:0.0;\n}\n\nvec2 normal(vec2 uv, float s, float v)\n{\n    vec2 u = vec2(s,0.0);\n    return normalize(hitAt(uv,v)-vec2(hitAt(uv-u.xy,v), hitAt(uv-u.yx,v)));\n}\n\nvec3 scene(vec2 uv)\n{\n    uv = INV_Q*floor(Q*uv);\n    float t = iTime;\n    vec3 col = vec3(0,0.2,0.2);\n    col += hitAt(uv,t)*vec3(0,0,0.7);\n    vec2 n = 0.5+0.5*normal(uv,INV_Q, t);\n    return length(n)>0.5? 0.5*col:col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    fragColor = vec4(scene(uv),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djyzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 122, 145, 145, 306], [308, 308, 328, 328, 588], [590, 590, 621, 621, 788], [790, 790, 830, 830, 934], [936, 936, 957, 957, 1159], [1161, 1161, 1218, 1218, 1317]], "test": "untested"}
{"id": "WsjyRG", "name": "ChangeDetection 2", "author": "hojo", "description": "Change detection on video.\nUses one buffer for background, and another buffer for buffering changes.\nChanges are committed to the background when they are stable (~3 sec)\nTo change input (webcam, video), modify Buffer A-iChannel3", "tags": ["video", "detection", "webcam", "motion", "change"], "likes": 6, "viewed": 624, "published": 3, "date": "1586873681", "time_retrieved": "2024-07-30T21:12:54.922841", "image_code": "void mainImage( out vec4 O, in vec2 U )\n{\n    U /= iResolution.xy;\n    vec3 D =   texture(iChannel1,U).rgb - texture(iChannel0,U).rgb;\n    \n    \n    // TEST DISPLAY LT BACKGROUND (no motion)\n    //O =  texture(iChannel1,U);\n    \n    //Debug DISPLAY one channel\n\t//O = texture(iChannel2,U);\n    \n    //DISPLAY only changed parts on black background\n\t//O = (length(D)<changeThresh) ? COLBACK : texture(iChannel0,U);\n   \n    // Display Movements as inverse video\n    O = (length(D)<changeThresh) ? texture(iChannel1,U) : 1.-texture(iChannel0,U);\n\n    // ALTERNATIVE : Display change as RGB variations from grey 0.5\n    //O = .5 + 1.0*D;\n   \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{    \n// reads video data in channel3\n    vec2 texPos = U/iResolution.xy;\n    //Horiontal flip option\n    if (FLIPHZ) {\n    \ttexPos.x=1.0 - texPos.x;\n    }\n    \n    O = texture(iChannel3,texPos);   \n}\n", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// CHANGE DETECTION, F.Claudel 2020\n//define FLIPHZ for horzontal flip of video source (webcam)\nconst bool FLIPHZ = true;\n\n// vidoe time period (seconds)\nconst float dtFrame = 1.0/60.0; // 1./60 for 60 fps\n\n// changeThresh for background : normalized change on all colors (max sqrt(3))\nconst float changeThresh = 0.11;\n// changeThresh for detection buffer: normalized change on all colors (max sqrt(3))\nconst float changeDetThresh = 0.1;\n\n//time delay for integartion into background (seconds)\nconst float tInteg = 1.0;\n//time delay for integartion into detection buffer (seconds)\nconst float tIntegDet = 0.25;\n// max duration of stable detection (seonds), before switching to background\nconst float  tDetStable = 3.0;\n\n//max Number of stable 'etected frames' (before switching to backgound)\nconst float maxDetStableFrames = tDetStable / dtFrame;\n\n//weight ratio of new frame for background, when no detection (smoothes noise)\nconst float rNew  = 1.0-exp2(-3.0/(tInteg   /dtFrame));\nconst float rNewD = 1.0-exp2(-3.0/(tIntegDet/dtFrame));\n\n// color for background (unchanged)\nconst vec4 COLBACK = vec4(0.0, 0.0, 0.0, 1.0);\n\n// DETECTION FUNCTION, used for Buffer A and B\nvec4 doDetection(vec4 newFrame, vec4 backb, vec4 detb, bool isBack) {\n// isBack : true  to return updated background buffer,\n//          false to return updated detectiuon buffer\n\n    ///absolute norm of change/ref : min 0, max sqrt(3)\n    float change = length(backb.rgb - newFrame.rgb);\n\n    //if small change : incorporate into background at slow speed       \n    if (change <= changeThresh) {\n        //no significant change in new frame => incorporate in backb\n        backb.rgb = rNew *newFrame.rgb + (1.0-rNew)*backb.rgb;\n        backb.a   += 1.0;\n        //no dectection\n        detb.rgb  = COLBACK.rgb;\n        detb.a    = 0.0;\n    } else {\n        //check if newFrame is the same as stored detectionBufer\n        float chDet = length(detb.rgb - newFrame.rgb);\n        bool noChDet= (chDet <= changeDetThresh);\n        //detection of change in newFrame\n\n        if (noChDet) {\n            detb.a  += 1.0;\n            //update detb color slowly\n            detb.rgb =  rNewD *newFrame.rgb + (1.0-rNewD)*detb.rgb;\n        } else {\n            //reste counter to 0, and store new colour\n            detb.a    = 0.0;\n            detb.rgb  = newFrame.rgb;\n        }\n    }\n\n    //if detection buffer counter is large\n    if ((detb.a >= maxDetStableFrames) || (detb.a > backb.a))  {\n        // put detectionBufer into background\n        backb.rgb = detb.rgb;\n        backb.a   = detb.a;\n        //disable detection\n        detb.rgb = COLBACK.rgb;\n        detb.a = 0.0;                \n    }\n\n    //decide which buffer to return accoridng to caller option isBack\n    return (isBack) ? backb : detb;\n}\n", "buffer_c_code": "void mainImage( out vec4 O, in vec2 U )\n// Buffer C store a detection background\n// three first components : RGB color for detected change\n// 4th component counts frames used for change (1 after first change)\n{\n    U /= iResolution.xy;\n    if (iFrame<=1)\n    {\n        //no detetction at beginning\n        O.rgba = vec4(0.,0.,0.,0.);        \n    } else {\n        \n    \tO = doDetection( \n                texture(iChannel0,U), //live frame (buffer A)\n                texture(iChannel1,U), //background (buffer B)\n                texture(iChannel2,U), //detection  (buffer C)\n                false ); // isBack is false for detection\n    }\n}\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nvoid mainImage( out vec4 O, in vec2 U )\n{\n// Buffer B store a fixed background\n//three first components : RGB color \n//4th component counts frames used for change (1 after first change)\n//\n    U /= iResolution.xy;\n    if (iFrame<=1)\n    {\n        //no detetction at beginning\n        O.rgb = texture(iChannel0,U).rgb;\n        O.a   = 1.0;\n    } else {\n        \n    \tO = doDetection( texture(iChannel0,U), //live frame (buffer A)\n                texture(iChannel1,U), //background (buffer B)\n                texture(iChannel2,U), //detection  (buffer C)\n                true ); // isBack is true for background\n    }\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjyRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 639]], "test": "untested"}
{"id": "3d2czG", "name": "Neighbor graph SPH", "author": "michael0884", "description": "idk more particle sims I guess\nChange N in Commons to change particle number!", "tags": ["particles", "aabb", "sort"], "likes": 7, "viewed": 523, "published": 3, "date": "1586868778", "time_retrieved": "2024-07-30T21:12:55.875295", "image_code": "ivec4 get(ivec2 p)\n{\n    return floatBitsToInt(texel(ch0, p));\n}\n\nivec4 getb(int id)\n{\n    return floatBitsToInt(texel(ch2, i2xy(id)));\n}\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    ivec4 nb = get(ivec2(pos));\n \tvec4 p0 = getParticle(nb.x);\n   \n    ivec4 nbm = get(ivec2(iMouse.xy));\n    ivec4 nbb = getb(nbm.x);\n    \n    float d = 0.;\n    for(int i = 0; i<4; i++)\n    {\n        vec4 pi = getParticle(nbb[i]);\n        d += exp(-distance(pos,pi.xy));\n    }\n    \n    vec4 d0 = vec4(0.);\n    for(int i = 0; i<4; i++)\n    {\n        vec4 pi = getParticle(nb[i]);\n        d0 += (0.5*sin(vec4(1,2,3,4)*float(nb[i])) + 0.5)*\n               exp(-0.3*distance(pos,pi.xy)*distance(pos,pi.xy));\n    }\n    \n    fragColor = d0+ 1.5*sin(5.*vec4(4,3,2,1)*d);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define N ivec2(100,100)\n#define dt 0.7\n\n\nconst int tot_n = N.x*N.y;\n\nfloat hash11(float p)\n{\n    p = fract(p * 15.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p) - 0.5;\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nconst int k = 1664525;  \n\nivec4 hash( ivec4 x )\n{\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    return ivec4(x);\n}\n\nivec2 i2xy(int id)\n{\n    return ivec2(id%N.x, id/N.x);\n}\n\nint xy2i(ivec2 p)\n{\n    return p.x + p.y*N.x;\n}\n\nivec2 cross_distribution(int i)\n{\n    return (1<<(i/4)) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 );\n}", "buffer_a_code": "//particle buffer\n\nint cid;\n\nivec4 get(int id)\n{\n    return floatBitsToInt(texel(ch0, i2xy(id)));\n}\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat F(float d)\n{\n    return clamp(2.*exp(-0.02*d*d) - 2.1*exp(-0.04*d*d), -0.4,0.4);\n}\n\nvec2 Fv(vec4 p0, int pid)\n{\n    if(pid < 0 || pid >= tot_n || pid == cid) return vec2(0); \n   \tvec4 p1 = getParticle(pid);\n    vec2 viscosity = 0.1*(p1.zw - p0.zw)*clamp(exp(-0.3*distance(p1.xy,p0.xy)*distance(p1.xy,p0.xy)), 0.05,1.);\n    vec2 pressure = normalize(p1.xy-p0.xy)*F(distance(p1.xy,p0.xy));\n    return viscosity + pressure;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    if(p.x < N.x && p.y < N.y)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch1, pos);\n        int id = xy2i(p);\n        cid = id;\n        \n        //this pixel value\n        if(iFrame<10)\n        {\n            U.xy = size*hash22(pos);\n\t\t\tU.zw = 2.*(hash22(3.14159*pos) - 0.5);\n      \t\treturn;\n        }\n        \n        //neighbors\n   \t\tivec4 cp = get(id);\n   \t  \n        vec2 F = Fv(U, cp.x) +\n            \t Fv(U, cp.y) +\n            \t Fv(U, cp.z) +\n                 Fv(U, cp.w) + \n            \t vec2(0,-0.003);\n        \n        if(iMouse.z > 0.) \n        {\n            float d = distance(iMouse.xy, U.xy);\n            F += 0.1*normalize(iMouse.xy - U.xy)/(sqrt(d)+2.);\n        }\n        \n        U.zw += F*dt;\n        U.xy += U.zw*dt;\n        \n        //border conditions\n        if(size.x - U.x < 2.) U.z = -abs(U.z);\n        if(U.x < 2.) U.z = abs(U.z);\n        if(size.y - U.y < 2.) U.w = -abs(U.w);\n        if(U.y < 2.) U.w = abs(U.w);\n \n        \n    }\n    else discard;\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//sorting closest 4 particles in axis directions that make a bounding box\n//only in particle space, texture buffer not needed\n\nivec4 get(int id)\n{\n    return floatBitsToInt(texel(ch0, i2xy(id)));\n}\n\nvec4 save(ivec4 v)\n{\n    return intBitsToFloat(v);\n}\n\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //this particle position\nint tid;\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\n//insertion sort\nvoid sort(int utemp)\n{\n    if(utemp == tid || utemp < 0) return;\n       \n   \tvec4 part = getParticle(utemp);\n    vec2 dx = part.xy - pos;\n    float dtemp = length(dx);\n    //sorting\n    if(dx.x > abs(dx.y))\n    {\n        if(d.x > dtemp) \n        {\n            d.x = dtemp;\n        \tu.x = utemp;\n        }\n    }\n    else if(dx.x < -abs(dx.y))\n    {\n        if(d.y > dtemp) \n        {\n            d.y = dtemp;\n        \tu.y = utemp;\n        }\n    }\n    else if(dx.y > abs(dx.x))\n    {\n        if(d.z > dtemp) \n        {\n            d.z = dtemp;\n        \tu.z = utemp;\n        }\n    }\n    else if(d.w > dtemp) \n    {\n        d.w = dtemp;\n        u.w = utemp;\n    }\n}\n\nvoid sortneighbor(int id)\n{\n    ivec4 nb = get(id);\n    for(int j = 0; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{  \n    ivec2 p = ivec2(fragCoord);\n    \n    if(p.x > N.x || p.y > N.y) discard;\n    \n    int id = xy2i(p);\n     \n    u = ivec4(-1); d = vec4(1e10); \n   \n    tid = id;\n    pos = getParticle(id).xy;\n    \n    sortneighbor(id); \n    \n    for(int i = 0; i < 8; i++)\n    {\n        sort(hash(ivec4(p, iFrame, i)).x%tot_n); //random sort    \n    }\n    \n    ivec4 nb = get(id);\n    for(int i = 0; i < 4; i++)\n    {\n        sortneighbor(nb[i]); \n    }\n    \n    if( any(lessThan(u, ivec4(-1))) || any(greaterThan(u, ivec4(tot_n))))\n    {\n        u = ivec4(0);\n    }\n    \n    \n    U = save(u);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//4th order voronoi particle tracking \n\nivec4 get(ivec2 p)\n{\n    return floatBitsToInt(texel(ch0, p));\n}\n\nvec4 save(ivec4 v)\n{\n    return intBitsToFloat(v);\n}\n\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //pixel position\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id).xy, p);\n}\n\n//insertion sort\nvoid sort(int utemp)\n{\n    if(utemp == -1) return; \n   \tfloat dtemp = particleDistance(utemp, pos);\n    //sorting\n    if(d.x > dtemp)\n    {\n        d = vec4(dtemp, d.xyz);\n        u = ivec4(utemp, u.xyz);\n    }\n    else if(d.y > dtemp && dtemp > d.x)\n    {\n        d.yzw = vec3(dtemp, d.yz);\n        u.yzw = ivec3(utemp, u.yz);\n    }\n    else if(d.z > dtemp && dtemp > d.y)\n    {\n        d.zw = vec2(dtemp, d.z);\n        u.zw = ivec2(utemp, u.z);\n    }\n    else if(d.w > dtemp && dtemp > d.z)\n    {\n        d.w = dtemp;\n        u.w = utemp;\n    }\n}\n\nvoid sortpos(ivec2 p)\n{\n    ivec4 nb = get(p);\n    for(int j = 0; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{\n    pos = fragCoord;\n    ivec2 p = ivec2(pos);\n     \n    u = ivec4(-1); d = vec4(1e10); \n   \n    //jump flood sorting \n    sortpos(p); //resort this position\n    for(int i = 0; i < 12; i++)\n    {\n        sortpos(p+cross_distribution(i)); \n    }\n    \n    for(int i = 0; i < 4; i++)\n    {\n        sort(hash(ivec4(p, iFrame, i)).x%tot_n); //random sort    \n    }\n    \n    if( any(lessThan(u, ivec4(-1))) || any(greaterThan(u, ivec4(tot_n))) )\n    {\n        u = ivec4(0);\n    }\n    \n    U = save(u);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//particle buffer\n\nint cid;\n\nivec4 get(int id)\n{\n    return floatBitsToInt(texel(ch0, i2xy(id)));\n}\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat F(float d)\n{\n    return 6.*exp(-0.4*d) - 10.*exp(-.5*d);\n}\n\nvec2 Fv(vec4 p0, int pid)\n{\n    if(pid < 0 || pid >= tot_n || pid == cid) return vec2(0); \n   \tvec4 p1 = getParticle(pid);\n    vec2 flocking_force = 0.05*(p1.zw - p0.zw)*clamp(exp(-0.1*distance(p1.xy,p0.xy)), 0.05,1.);\n    vec2 interaction = normalize(p1.xy-p0.xy)*F(distance(p1.xy,p0.xy));\n    return flocking_force + interaction;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    if(p.x < N.x && p.y < N.y)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch1, pos);\n        int id = xy2i(p);\n        cid = id;\n        \n        //this pixel value\n        if(iFrame<10)\n        {\n            U.xy = size*hash22(pos);\n\t\t\tU.zw = 2.*(hash22(3.14159*pos) - 0.5);\n      \t\treturn;\n        }\n        \n        //neighbors\n   \t\tivec4 cp = get(id);\n   \t  \n        vec2 F = Fv(U, cp.x) +\n            \t Fv(U, cp.y) +\n            \t Fv(U, cp.z) +\n                 Fv(U, cp.w) + \n            \t vec2(0,-0.003);\n        \n        if(iMouse.z > 0.) \n        {\n            float d = distance(iMouse.xy, U.xy);\n            F += 0.1*normalize(iMouse.xy - U.xy)/(sqrt(d)+2.);\n        }\n        \n        U.zw += 0.5*F*dt;\n        U.zw = normalize(U.zw)*clamp(length(U.zw), 0.,2.); \n        //U.zw = normalize(U.zw);\n        U.xy += U.zw*dt;\n        \n        //border conditions\n        if(size.x - U.x < 2.) U.z = -abs(U.z);\n        if(U.x < 2.) U.z = abs(U.z);\n        if(size.y - U.y < 2.) U.w = -abs(U.w);\n        if(U.y < 2.) U.w = abs(U.w);\n \n        \n    }\n    else discard;\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d2czG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 64], [66, 66, 86, 86, 137], [139, 139, 165, 165, 200], [202, 202, 253, 253, 820]], "test": "untested"}
{"id": "Wd2cRG", "name": "Projective plane disk", "author": "NinjaKoala", "description": "Mapping the whole plane plus points at infinity to a finite disk.\nPoints on the border with the same color are the same points in the projective plane.", "tags": ["2d", "math", "geometry", "projective"], "likes": 9, "viewed": 409, "published": 3, "date": "1586867288", "time_retrieved": "2024-07-30T21:12:56.639252", "image_code": "/*\nMapping of the projective plane to a disk.\n\nThe whole affine plane is mapped to the disk without border,\nthe border is the line at infinity. Two opposing points on\nthe disk border are corresponding to just one point in the\nprojective plane. I gave two opposing points the same color\nto emphasize this.\n\nBasically, the lines parallel to the x axis are\nan interpolation between the x axis and the disk border,\nthose parallel to the y axis between y axis and disk border accordingly.\nEvery point can then be described as the intersection of two\nof those circles.\n(You can think of the disk border as third axis)\n\nThe animation shows how ellipses are those conic sections without\nintersections with the line at infinity,\nparabolas are those with exactly one intersection, and\nhyperbolas those with exactly two intersections.\n\n(Or optionally a triangle where one point is movable with mouse)\n(Or optionally an elliptic curve whose parameters you can change with mouse)\n\nI got the basic idea of the mapping from a prof of mine,\ni derived the exact formulas myself. I don't know\nhow this mapping is called, but this has certainly been done\nbefore.\n*/\n\n//#define TRIANGLE\n//#define ELLIPTIC_CURVE\n\nconst float pi=3.14159265358979;\n\nconst float eps=.000001;\n\nconst float t0=2.00001;\nconst float t1=4.00002;\nconst float t2=7.00003;\nconst float t3=9.00004;\nconst float tt=11.00005;\n//the perturbations are a workaround for https://gitlab.freedesktop.org/mesa/mesa/issues/2610\n\nfloat sgn(float a){\n\tif(a<0.){\n\t\treturn -1.;\n\t}\n\telse{\n\t\treturn 1.;\n\t}\n}\n\nvec2 from_projective(vec3 p, float stretch_factor, float radius, out vec2 int_p2){\n\tvec2 int_p;\n\n\tfloat a=p.x*p.x+p.y*p.y;\n\tfloat b=p.z*p.x/(stretch_factor*stretch_factor);\n\tfloat c=-p.x*p.x*radius*radius;\n\n\tfloat int_x=(-b+sgn(p.x)*sqrt(b*b-4.*a*c))/(2.*a);\n\tfloat int_y=int_x*p.y/p.x;\n\n\tint_p=vec2(int_x,int_y);\n\n\tif(abs(p.z)<eps){\n\t\tint_p2=-int_p;\n\t}\n\telse{\n\t\tint_p2=int_p;\n\t}\n\n\treturn int_p;\n}\n\nvec3 to_projective(vec2 p, float stretch_factor, float radius){\n\treturn vec3(p.xy,stretch_factor*stretch_factor*(radius*radius-dot(p,p)));\n}\n\nmat2x3 to_projective_jacobi(vec2 p, float stretch_factor, float radius){\n\tvec3 column1=vec3(1.,0.,-2.*stretch_factor*stretch_factor*p.x);\n\tvec3 column2=vec3(0.,1.,-2.*stretch_factor*stretch_factor*p.y);\n\n\treturn mat2x3(column1, column2);\n}\n\nfloat to_projective_line(float a, float b){\n\treturn -sgn(a)*sgn(b)*abs(a)/(abs(a)+abs(b));\n}\n\nvec2 from_projective_line(float a){\n\treturn vec2(a,1.-abs(a));\n}\n\nfloat line_dist(vec2 uv, const vec2 p0, vec2 p1){\n\tvec2 tang=p1-p0;\n\tvec2 nor=normalize(vec2(tang.y,-tang.x));\n\n\tif(dot(tang,uv)<dot(tang,p0)){\n\t\treturn distance(p0,uv);\n\t}\n\telse if(dot(tang,uv)>dot(tang,p1)){\n\t\treturn distance(p1,uv);\n\t}\n\telse{\n\t\treturn abs(dot(nor,uv)-dot(nor,p0));\n\t}\n}\n\nvec3 line(vec2 p_0, vec2 p_1){\n\tvec2 tan1 = p_1-p_0;\n\tvec2 nor1 = normalize(vec2(tan1.y,-tan1.x));\n\treturn vec3(nor1,-dot(nor1,p_0));\n}\n\nvec3 line(vec3 p_0, vec3 p_1){\n\treturn normalize(cross(p_0,p_1));\n}\n\n//mapping from barth's skript:\n//https://web.archive.org/web/20051104003320/http://www.mi.uni-erlangen.de/~barth/docs/geoset.ps (german)\n//it basically gives the formula and says:\n//by this formula, you see the projective plane can be bijectively mapped to a disk, but this is not too useful\n//the mapping does not have any favorably properties compared to the other one, i just implemented it for reference\nvec2 from_projective_barth(vec3 p, float radius, out vec2 int_p2){\n\tvec2 int_p = 2.*radius/pi*p.xy*atan(dot(p.xy,p.xy)/(p.z*p.z))/length(p.xy);\n\n\tif(abs(p.z)<eps){\n\t\tint_p=radius*normalize(p.xy);\n\t\tint_p2=-int_p;\n\t}\n\telse{\n\t\tint_p2=int_p;\n\t}\n\n\treturn int_p;\n}\n\nvec3 to_projective_barth(vec2 p, float radius){\n\treturn vec3(p.xy*sqrt(tan(pi/(2.*radius)*length(p))),length(p));\n}\n\nmat2x3 to_projective_jacobi_barth(vec2 p, float radius){\n\tfloat fac=pi/(2.*radius);\n\tfloat len=length(p);\n\n\tfloat tmp=tan(len*fac);\n\n\tfloat a11=.5*(tmp*tmp + 1.)*fac*p.x*p.x/(len*sqrt(tmp)) + sqrt(tmp);\n\tfloat a12=.5*(tmp*tmp + 1.)*fac*p.x*p.y/(len*sqrt(tmp));\n\tfloat a22=.5*(tmp*tmp + 1.)*fac*p.y*p.y/(len*sqrt(tmp)) + sqrt(tmp);\n\n\tvec3 column1=vec3(a11,a12,p.x/len);\n\tvec3 column2=vec3(a12,a22,p.y/len);\n\n\treturn mat2x3(column1,column2);\n}\n\n//elliptic degree is the same but for lines instead of points\nfloat elliptic_distance(vec3 p1, vec3 p2){\n\treturn acos(1./sqrt(dot(p1,p1)*dot(p2,p2))*dot(p1,p2));\n}\n\nfloat spectral(float x){\n        return clamp(abs(mod((x/pi+1.)*4.,8.)-4.)-2.,-.75,.75)*.5/.75+.5;\n}\n\nvec3 to_col(vec2 z){\n\tfloat direction = 2.*atan(z.x,z.y);\n\treturn vec3(spectral(direction),spectral(direction+pi/2.),spectral(direction-pi));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv-=.5;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\tmouse-=.5;\n\tmouse.x *= iResolution.x / iResolution.y;\n\n\tvec2 mouse2 = iMouse.zw / iResolution.xy;\n\tmouse2-=.5;\n\tmouse2.x *= iResolution.x / iResolution.y;\n    \n    #ifdef TRIANGLE\n    float animation=1.;\n    #else\n    #ifdef ELLIPTIC_CURVE\n    float animation=1.;\n    #else\n    float animation;\n    \n    float tc=abs(mod(iTime-tt,2.*tt)-tt);\n    \n    if(tc<t1){\n        animation=exp(mix(5.,0.,smoothstep(0.,t0,tc)));\n    }\n    else if(tc<.5*(t1+t2)){\n        animation=exp(mix(0.,5.,smoothstep(t1,.5*(t1+t2),tc)));\n    }\n    else if(tc<t3){\n        animation=exp(mix(5.,0.,smoothstep(.5*(t1+t2),t2,tc)));\n    }\n    else{\n        animation=exp(mix(0.,5.,smoothstep(t3,tt,tc)));\n    }\n    #endif\n    #endif\n    \n    float stretch_factor=1./animation;\n    float radius=.47*animation;\n\n\tconst float line_width = .001;\n\tconst float circle_width = .003;\n\tconst float grid_width = .0;\n\tconst float curve_width = .001;\n\tconst float dot_size = .005;\n\tconst float axis_width = .005;\n\n\tconst float grid_size = .8;\n\n\tconst vec3 bg_col = vec3(1,1,1);\n\tconst vec3 axis_col = vec3(0,0,0);\n\tconst vec3 grid_col = vec3(.75);\n\tconst vec3 line_col = vec3(0,1,0);\n\tconst vec3 curve_col = vec3(0,0,1);\n\tconst vec3 dot_col = vec3(1,0,0);\n\n\tvec3 circle_col = to_col(uv);\n\n    float border = 2./iResolution.y;\n\n\tfloat curve_dis = 1e38;\n\tfloat dot_dis = 1e38;\n\tfloat axis_dis = 1e38;\n\tfloat grid_dis = 1e38;\n\tfloat line_dis = 1e38;\n\tfloat circle_dis = 1e38;\n\n\tvec3 color=bg_col;\n\n\tcircle_dis=min(circle_dis,abs(length(uv)-radius)-circle_width);\n\n\taxis_dis=min(axis_dis,line_dist(uv,vec2(0,radius),vec2(0,-radius))-line_width);\n\taxis_dis=min(axis_dis,line_dist(uv,vec2(radius,0),vec2(-radius,0))-line_width);\n\n\tvec3 uv_p=to_projective(uv,stretch_factor,radius);\n\n\tmat2x3 jac=to_projective_jacobi(uv,stretch_factor,radius);\n\n    #ifdef TRIANGLE\n\tvec2 m0=normalize(mouse)*min(length(mouse),radius);\n\tvec3 p0=to_projective(m0,stretch_factor,radius);\n\tvec3 p1=vec3(2.7,2.2,1.);\n\tvec3 p2=vec3(2.,-2.,1.);\n    \n    vec2 int_p;\n\tvec2 int_p2;\n\n\tint_p = from_projective(p0,stretch_factor,radius,int_p2);\n\n\tdot_dis=min(dot_dis,distance(uv,int_p)-dot_size);\n\tdot_dis=min(dot_dis,distance(uv,int_p2)-dot_size);\n\n\tint_p = from_projective(p1,stretch_factor,radius,int_p2);\n\n\tdot_dis=min(dot_dis,distance(uv,int_p)-dot_size);\n\tdot_dis=min(dot_dis,distance(uv,int_p2)-dot_size);\n\n\tint_p = from_projective(p2,stretch_factor,radius,int_p2);\n\n\tdot_dis=min(dot_dis,distance(uv,int_p)-dot_size);\n\tdot_dis=min(dot_dis,distance(uv,int_p2)-dot_size);\n    \n    vec3 l1=line(p0,p1);\n\tvec3 l2=line(p1,p2);\n\tvec3 l3=line(p2,p0);\n    \n\tcurve_dis=min(curve_dis,abs(dot(uv_p,l1)/length(l1*jac)));\n\tcurve_dis=min(curve_dis,abs(dot(uv_p,l2)/length(l2*jac)));\n\tcurve_dis=min(curve_dis,abs(dot(uv_p,l3)/length(l3*jac)));\n    #else\n    #ifdef ELLIPTIC_CURVE\n    \n\tfloat g_2 = 10.*mouse.x;\n\tfloat g_3 = 10.*mouse.y;\n\n\tfloat elliptic_curve_val=(4.*uv_p.x*uv_p.x-g_2*uv_p.z*uv_p.z)*uv_p.x-(g_3*uv_p.z*uv_p.z+uv_p.y*uv_p.y)*uv_p.z;\n\tvec3 elliptic_curve_grad=vec3(12.*uv_p.x*uv_p.x-g_2*uv_p.z*uv_p.z,-2.*uv_p.y*uv_p.z,(-3.*g_3*uv_p.z-2.*g_2*uv_p.x)*uv_p.z-uv_p.y*uv_p.y);\n    \n    curve_dis=min(curve_dis,abs(elliptic_curve_val/length(elliptic_curve_grad*jac)));\n    #else\n\tfloat hyperbola_val=8.*uv_p.x*uv_p.x-4.*uv_p.y*uv_p.y+uv_p.z*uv_p.z;\n\tvec3 hyperbola_grad=vec3(8.*2.*uv_p.x,-4.*2.*uv_p.y,+2.*uv_p.z);\n\n\tfloat parabola_val=uv_p.x*uv_p.x-uv_p.y*uv_p.z;\n\tvec3 parabola_grad=vec3(2.*uv_p.x,-uv_p.z,-uv_p.y);\n\n\tfloat circle_val=uv_p.x*uv_p.x+uv_p.y*uv_p.y-uv_p.z*uv_p.z;\n\tvec3 circle_grad=vec3(2.*uv_p.x,2.*uv_p.y,-2.*uv_p.z);\n    \n\tfloat mix_val;\n\tvec3 mix_grad;\n    \n    mix_val=mix(circle_val,parabola_val,smoothstep(t0,t1,tc));\n\tmix_grad=mix(circle_grad,parabola_grad,smoothstep(t0,t1,tc));\n    \n    if(tc>t2){\n        mix_val=mix(parabola_val,hyperbola_val,smoothstep(t2,t3,tc));\n\t\tmix_grad=mix(parabola_grad,hyperbola_grad,smoothstep(t2,t3,tc));\n    }\n\n\tcurve_dis=min(curve_dis,abs(mix_val/length(mix_grad*jac)));\n    #endif\n    #endif\n\n\tvec3 grid_grad=vec3(1./uv_p.z,0.,-uv_p.x/(uv_p.z*uv_p.z));\n\tgrid_dis = min(grid_dis, abs(mod(uv_p.x/uv_p.z-grid_size*.5,grid_size)-grid_size*.5)/length(grid_grad*jac)-grid_width);\n\tgrid_grad=vec3(0.,1./uv_p.z,-uv_p.y/(uv_p.z*uv_p.z));\n\tgrid_dis = min(grid_dis, abs(mod(uv_p.y/uv_p.z-grid_size*.5,grid_size)-grid_size*.5)/length(grid_grad*jac)-grid_width);\n\n\tfloat d0=length(uv)-radius;\n\n\tgrid_dis=max(d0,grid_dis);\n\tcurve_dis=max(d0,curve_dis);\n\n\tcolor=vec3(mix(grid_col,color,smoothstep(0., border, grid_dis)));\n\tcolor=vec3(mix(axis_col,color,smoothstep(0., border, axis_dis)));\n\tcolor=vec3(mix(line_col,color,smoothstep(0., border, line_dis)));\n\tcolor=vec3(mix(circle_col,color,smoothstep(0., border, circle_dis)));\n\tcolor=vec3(mix(curve_col,color,smoothstep(0., border, curve_dis)));\n\tcolor=vec3(mix(dot_col,color,smoothstep(0., border, dot_dis)));\n\n\tfragColor = vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2cRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1469, 1469, 1488, 1488, 1541], [1543, 1543, 1625, 1625, 1940], [1942, 1942, 2005, 2005, 2082], [2084, 2084, 2156, 2156, 2323], [2325, 2325, 2368, 2368, 2417], [2419, 2419, 2454, 2454, 2483], [2485, 2485, 2534, 2534, 2774], [2776, 2776, 2806, 2806, 2911], [2913, 2913, 2943, 2943, 2980], [2982, 3390, 3456, 3456, 3649], [3651, 3651, 3698, 3698, 3766], [3768, 3768, 3824, 3824, 4209], [4211, 4273, 4315, 4315, 4374], [4376, 4376, 4400, 4400, 4476], [4478, 4478, 4498, 4498, 4621], [4623, 4623, 4677, 4677, 9676]], "test": "untested"}
{"id": "3sjczG", "name": "gamma gradient", "author": "Jespertheend", "description": "often when computers render gradients, they don't take gamma into account, causing the gradient become dark and ugly. In the shader try to change the first line between true and false to see the difference.", "tags": ["gradient", "gamma"], "likes": 1, "viewed": 318, "published": 3, "date": "1586867221", "time_retrieved": "2024-07-30T21:12:57.400218", "image_code": "#define USE_GAMMA ( uv.y > .5 )\n#define LEFT_COL vec3(1.0, 0.0, 0.0)\n#define RIGHT_COL vec3(0.0, 1.0, 0.0)\n#define GAMMA_FACTOR 2.2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col1 = LEFT_COL;\n    vec3 col2 = RIGHT_COL;\n    \n    if(USE_GAMMA){\n        col1 = pow(col1, vec3(GAMMA_FACTOR));\n        col2 = pow(col2, vec3(GAMMA_FACTOR));\n    }\n    vec3 col = mix(col1, col2, uv.x);\n\n    if(USE_GAMMA){\n        float invGamma = 1.0 / GAMMA_FACTOR;\n        col = pow(col, vec3(invGamma));\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sjczG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[133, 133, 190, 240, 699]], "test": "untested"}
{"id": "tdScRy", "name": "Square from memory", "author": "bikemule", "description": "After watching some tutorials recent, I started with a fresh sketch to try to draw a square without referring to anything else. Tried to add as many comments as possible, mostly for my own benefit, but hopefully for others' as well.", "tags": ["2d", "basic", "tutorial", "gradient", "square"], "likes": 1, "viewed": 470, "published": 3, "date": "1586847183", "time_retrieved": "2024-07-30T21:12:58.394559", "image_code": "/*\nDone from memory as an exercise.\n\nEven trying to find bits you remember when you have read several tutorials can\nbe problematic. It's a good way to make sure you know things.\n\nCredit to The Art of Code and Code Parade on YouTube, Inigo Quilez, The Book of Shaders, and many more.\n\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Move coordinate origin to center\n    // 0-1 * 2 gives a range of 0-2\n    // Subtracting 1 gives range of -1 to +1 with origin in the center\n    uv *= vec2(2.);\n    uv -= vec2(1.);\n    \n    // Correct perspective so the square appears square\n    // Screen res is usually higher horizontally than vertically, so\n    // multiply x by the x-axis proportion to the y-axis\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // This is the default color that will be returned.\n    vec3 pixel = vec3(0.);  // black\n    \n    // Gradient BG for fun.\n    // grayscale, so distance from origin determines the brightness\n    // uv/vec2(2.) is to normalize to our coords\n    // 1 - distance to start with black outside\n    vec3 gradient = vec3(1.-distance(uv/vec2(2.), vec2(0.,0.)));\n    pixel = gradient;\n    \n\n\t// Origin (0,0)is in center, so +/-0.5 will be a square in the center.\n    if(abs(uv.x)<= 0.5 && abs(uv.y)<=0.5)\n        pixel = vec3(0.);  // white\n    \n    // Output to screen, adding alpha value\n    fragColor = vec4(pixel,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdScRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 287, 344, 394, 1477]], "test": "untested"}
{"id": "tsSyRy", "name": "dice counter - golfed ( 254 ch )", "author": "FabriceNeyret2", "description": ".", "tags": ["2tweets", "digits", "short", "golf", "count"], "likes": 5, "viewed": 355, "published": 3, "date": "1586843171", "time_retrieved": "2024-07-30T21:12:59.205391", "image_code": "// Golfing https://shadertoy.com/view/wdBczG\n// See there for comments\n\n\n// --- new counting algorithm\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  R = iResolution.yy,\n          U = 3.*u/R  ,       F = floor(U),\n          D = 3.6*(U-F)-.3,   A = abs(D-1.5);\n    int t = int( iDate.w *pow(10.,F.x-4.*F.y) ) % 10;\n    max(A.x,A.y) < 1.5\n        ? O = min( vec4( int[](t-t%2,5,3,7,1)\n                            [ abs( int(D)%3+int(D.y)%3*3-4 ) ] < t ),\n                   1. - R.y/15.* ( length( fract(D)-.5 ) -.4 ))\n        : O; }                                                       /*\n\n\n\n\n\n// --- 264 chars\n\n#define mainImage(O,u)                                              \\\n    vec2  R = iResolution.yy,                                       \\\n          U = 3.*u/R  ,       F = floor(U),                         \\\n          D = 3.6*(U-F)-.3,   A = abs(D-1.5);                       \\\n    int t = int( iDate.w *pow(10.,F.x-4.*F.y) ) % 10;               \\\n    max(A.x,A.y) < 1.5                                              \\\n        ? O = min( vec4( int[](0,257,325,365,495)[t/2] + t%2 *16    \\\n                         >> int(D)%3+int(D.y)%3*3& 1 ),             \\\n                   1. - R.y/15.* ( length( fract(D)-.5 ) -.4 ))     \\\n        : O                                                        /*\n\n\n\n\n\n// --- 278 chars\n\n#define mainImage(O,u)                                              \\\n    vec2  R = iResolution.xy,                                       \\\n          U = 3.*u/R.y,       F = floor(U),                         \\\n          D = 3.6*(U-F)-.3,   A = abs(D-1.5);                       \\\n    ivec2 C = ivec2(D) % 3;                                         \\\n         max(A.x,A.y) < 1.5                                         \\\n    && ( int[](0,16,257,273,325,341,365,381,495,511)                \\\n              [ int( iDate.w *pow(10.,F.x-4.*F.y) ) % 10 ]          \\\n         >> C.x+3*C.y& 1                                            \\\n       ) > 0                                                        \\\n        ? O += min(1., 1. - R.y/15.* ( length( fract(D)-.5 ) -.4 )) \\\n        : O                                                        /*\n\n\n\n\n\n// --- 292 chars\n\n#define mainImage(O,u)                                              \\\n    vec2  R = iResolution.xy,                                       \\\n          U = 3.*u/R.y,                                             \\\n          F = floor(U),                                             \\\n          D = 3.6*(U-F)-.3, A = abs(D-1.5);                         \\\n    int t = int(iDate.w*pow(10.,F.x-4.*F.y)) % 10,                  \\\n        m = int[](0,16,257,273,325,341,365,381,495,511)[t];         \\\n    ivec2 C = ivec2(D) % 3;                                         \\\n    max(A.x,A.y) < 1.5 && ( m >> (C.x+3*C.y)  & 1 ) > 0             \\\n        ? O += min(1., 1. - R.y/15.* ( length( fract(D)-.5 ) -.4 )) \\\n        : O                                                        /*\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsSyRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "wdBczG", "name": "dice counter", "author": "FabriceNeyret2", "description": ".", "tags": ["digits", "short", "count"], "likes": 6, "viewed": 310, "published": 3, "date": "1586842181", "time_retrieved": "2024-07-30T21:13:00.008245", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    O -= O;\n    vec2  R = iResolution.xy, \n          U = 3.*u/R.y, A,\n          F = floor(U);                                               // cells\n    int t = int(iDate.w*pow(10.,F.x-4.*F.y)) % 10,                    // digit to display at cell\n        m = int[](0,16,257,273,325,341,365,381,495,511)[t];           // mask from dice table\n    U = 3.6*(U-F)-.3; ivec2 C = ivec2(U) % 3;                         // dot subcell\n    A = abs(U-1.5); max(A.x,A.y) < 1.5 &&                             // padding\n  //C.x+3*C.y < t                                                     // order count ( comment one\n    ( m >> (C.x+3*C.y)  & 1 ) > 0                                     // dice count    of these 2 )\n        ? O +=   smoothstep (20./R.y, 0., length( fract(U)-.5 ) -.4 ) // display dot\n               * vec4(1,F/3.,1)\n        : O;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdBczG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "wsByzG", "name": "River of Fire", "author": "jarble", "description": "This is an edit of my [url=https://www.shadertoy.com/view/wdsyD8]\"Sea of Lava\"[/url] shader.", "tags": ["fractal", "river", "pseudorandom"], "likes": 3, "viewed": 359, "published": 3, "date": "1586831013", "time_retrieved": "2024-07-30T21:13:00.902852", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 9.0;\nconst float distortion_scale = mag*mag;\n\nconst int GREEN = 0;\nconst int BLUE = 1;\nconst int GRAY = 2;\nconst int YELLOW = 3;\nconst int WHITE = 4;\nconst int FOREST_GREEN = 5;\nconst int LIGHTBLUE = 6;\nconst int SKYBLUE = 7;\nconst int SNOW = 8;\nconst int WHITESMOKE = 9;\nconst int LIGHTGRAY = 10;\nconst int LIME = 11;\nconst int LIGHTYELLOW = 12;\nconst int BEIGE = 13;\nconst int SAND = 14;\nconst int TAN = 15;\nconst int ORANGE = 16;\nconst int RED = 17;\nconst int BLACK = 18;\nconst int DARKGRAY = 19;\nconst int ORANGERED = 20;\n\nconst int SWAMP_BIOME = 1;\nconst int GLACIER_BIOME = 2;\nconst int FORESTS_AND_MOUNTAINS = 3;\nconst int SAVANNA_BIOME = 4;\nconst int FOREST_BIOME = 5;\n\n//this function is from https://www.shadertoy.com/view/4djSRW\nint hash12(vec2 p,float num_colors)\n{\n    //set the number of colors to be randomly generated\n    p = sin(p.xx-p.yy);\n    vec3 p3 = (vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return int(floor(fract((p3.x + p3.y) * p3.z)*num_colors));\n}\n    \nint magnify(vec2 fragCoord,float mag,float num_colors){\n    fragCoord += vec2(sin(fragCoord.y/(distortion_scale*mag)+iTime),sin(fragCoord.x/(distortion_scale*mag)+iTime))*10.0*mag*mag;\n    return hash12(floor(fragCoord/pow(3.0,mag)),num_colors);\n}\n\nivec4 get_neighbors(vec2 fragCoord,float mag,float colors){\n\treturn ivec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\n\nbool is_next_to(int color,ivec4 neighbors){\n\treturn (neighbors.x == color)\n        || (neighbors.y == color)\n        || (neighbors.z == color)\n        || (neighbors.w == color);\n}\n\nvec3 rgb(float r,float g,float b){\n\treturn vec3(r,g,b)/255.0;\n}\n\nvec3 get_color(int color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == FOREST_GREEN){\n    \treturn rgb(34.0,139.0,34.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n    else if(color == LIGHTBLUE){\n    \treturn rgb(173.0,216.0,230.0);\n   \t}\n    else if(color == SKYBLUE){\n    \treturn rgb(135.0,206.0,235.0);\n    }\n    else if(color == SNOW){\n    \treturn rgb(255.0,250.0,250.0);\n    }\n    else if(color == WHITESMOKE){\n    \treturn rgb(245.0,245.0,245.0);\n    }\n    else if(color == LIGHTGRAY){\n    \treturn rgb(211.0,211.0,211.0);\n    }\n    else if(color == LIME){\n    \treturn rgb(0.0,255.0,0.0);\n    }\n    else if(color == LIGHTYELLOW){\n    \treturn rgb(255.0,255.0,153.0);\n    }\n    else if(color == BEIGE){\n    \treturn rgb(245.0,245.0,220.0);\n    }\n    else if(color == TAN){\n    \treturn rgb(210.,180.,140.);\n    }\n    else if(color == ORANGE){\n    \treturn vec3(255,127,80)/255.0;\n    }\n    else if(color == RED){\n    \treturn vec3(1.0,0.0,0.0);\n   \t}\n    else if(color == DARKGRAY){\n    \treturn rgb(128.0,128.0,128.0);\n    }\n    else if(color == ORANGERED){\n    \treturn rgb(255.0,69.0,0.0);\n    }\n}\n\n\nint glacier_biome(inout int color1, ivec4 neighbors){\n\tint GREEN = 0;\n    int BLUE = 1;\n    int GRAY = 2;\n    int WHITE = 3;\n    int YELLOW = 4;\n    \n    return (color1 == GREEN && is_next_to(BLUE,neighbors))\n        ? GRAY\n    : (color1 == GREEN && is_next_to(WHITE,neighbors))\n        ? GRAY\n    : (color1 == BLUE && is_next_to(GREEN,neighbors))\n        ? WHITE\n    : (color1 == YELLOW && is_next_to(GREEN,neighbors))\n        ? GRAY\n    : (color1 == YELLOW && is_next_to(GRAY,neighbors))\n        ? BLUE\n    :(color1 == WHITE && is_next_to(YELLOW,neighbors))\n        ? GRAY\n    :(color1 == YELLOW && is_next_to(WHITE,neighbors))\n        ? WHITE\n    :(color1 == GRAY && is_next_to(BLUE,neighbors))\n        ? BLUE\n    :color1;\n}\n\nvoid biome(inout int color1, ivec4 neighbors,int biome){\n    color1 =\n        glacier_biome(color1,neighbors);\n}\n\nint biome(in vec2 fragCoord,float mag,float zoom,int colors[5],int biome1){\n    fragCoord *= zoom;\n\n    \n    float num_colors = float(colors.length());\n    \n    int color1 = magnify(fragCoord,mag,num_colors);\n    \n    ivec4 neighbors;\n    \n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,num_colors);\n    biome(color1, neighbors,biome1);\n    mag -= 1.0;\n    }\n    return colors[int(color1)];;\n}\n\n\nint glacier_biome(in vec2 fragCoord,float mag,float zoom,int[5] colors){\n    return biome(fragCoord,mag,zoom,colors,GLACIER_BIOME);\n}\n\nint lava_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn glacier_biome(fragCoord,mag,zoom,int[](DARKGRAY,YELLOW,ORANGERED,ORANGE,ORANGERED));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = mag*(((iMouse.x-iMouse.y)*2.0+iResolution.x)/iResolution.x);\n    fragCoord *= zoom;\n    fragCoord = fragCoord + floor(iTime*100.0)*vec2(zoom,0.0);\n\n\tint biome = lava_biome(fragCoord,mag,1.0);\n    \n    fragColor = vec4(get_color(biome),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsByzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[741, 803, 840, 896, 1057], [1063, 1063, 1118, 1118, 1310], [1312, 1312, 1371, 1371, 1576], [1579, 1579, 1622, 1622, 1758], [1760, 1760, 1794, 1794, 1823], [1825, 1825, 1851, 1851, 3208], [3211, 3211, 3264, 3264, 3938], [3940, 3940, 3996, 3996, 4052], [4054, 4054, 4129, 4129, 4466], [4757, 4757, 4814, 4814, 5074]], "test": "untested"}
{"id": "tdBcRG", "name": "hsluv and hpluv polynomial fits", "author": "mattz", "description": "Answering tbird's request in [url]https://www.shadertoy.com/view/3lBXR3[/url]", "tags": ["colormap", "polynomial", "hsluv", "hpluv", "fitcolormap"], "likes": 4, "viewed": 573, "published": 3, "date": "1586830490", "time_retrieved": "2024-07-30T21:13:02.060756", "image_code": "// fitting polynomials to HSLuv and HPLuv colormaps\n//\n// License CC0 (public domain) \n//   https://creativecommons.org/share-your-work/public-domain/cc0/\n//\n// answered tbird's request in https://www.shadertoy.com/view/3lBXR3\n// to do the HSLuv colormap (see https://www.hsluv.org/comparison/)\n// and threw in HPLuv too, for good measure\n//\n// not thrilled with the results, frankly -- the source colormaps are \n// much less smooth than inputs to my previous shader and the quality of \n// fit is not as good.\n//\n// partially this is also because the original HSLuv has some hard clipping\n// which the polynomial fit doesn't love.\n//\n// outputs, bottom to top:\n//\n//   1) original HSLuv values computed from https://github.com/hsluv/hsluv-python\n//   2) my polynomial fit - purple looks kind of like garbage :(\n//   3) original HPLuv values from https://github.com/hsluv/hsluv-python\n//   4) my polynomial fit - less garbage than the other polyfit\n//\n// I might play around with other ways of approximating these functions\n\nvec3 hsluv(float t) {\n\n    const vec3 c0 = vec3(1.112190141256249, 0.2892005552571448, 0.4533874092347643);\n    const vec3 c1 = vec3(-2.700459896899569, 1.230016915698432, -8.866692238834126);\n    const vec3 c2 = vec3(13.27461904052131, 9.770495221624461, 40.21502987811905);\n    const vec3 c3 = vec3(-81.52914608827041, -72.38313527130981, -70.91008175027898);\n    const vec3 c4 = vec3(160.2873495871779, 177.6692475972083, 72.98689200890533);\n    const vec3 c5 = vec3(-113.7533707882922, -191.0996400048753, -43.90364824070267);\n    const vec3 c6 = vec3(25.63678954693401, 74.92090437235763, 10.41364910112663);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n\n}\n\nvec3 hpluv(float t) {\n\n    const vec3 c0 = vec3(0.8498955002581585, 0.4832532405217748, 0.5421264483909258);\n    const vec3 c1 = vec3(-4.409059134214186, 0.389492555133492, -1.168238680182178);\n    const vec3 c2 = vec3(48.62277754887025, -0.1355162304606739, -7.080954185520974);\n    const vec3 c3 = vec3(-236.4070580335005, 2.645941964751115, 51.62563361795004);\n    const vec3 c4 = vec3(478.9041299570086, -8.918428894628779, -97.1930145700894);\n    const vec3 c5 = vec3(-423.6767542055926, 8.066163760207662, 75.49542389205953);\n    const vec3 c6 = vec3(136.9698973865875, -2.043826721347202, -21.67708580809141);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n\n}\n\nvec3 paletteLUT(float row, float u) {\n    \n    vec2 uv;\n    \n    uv.x = mix(0.5, 254.5, u);\n    uv.y = 0.5 + row;\n    \n    uv /= iResolution.xy;\n    \n    return texture(iChannel0, uv, 0.0).xyz;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    float u = fragCoord.x / iResolution.x;\n    \n    //fragColor = vec4(paletteLUT(2.0, u), 1);\n    \n    \n    float y;\n    vec2 uv;\n    \n    if (max(iMouse.z, iMouse.w) > 0.) {\n        \n        uv = fragCoord / iResolution.xy;\n        y = floor(iMouse.y * 4. / iResolution.y );\n        \n    } else {\n\n        const float m = 2.0;\n\n        vec2 dims = iResolution.xy - vec2(2.*m, 2.*m);\n\n        float h = floor(0.25*dims.y);\n\n        dims.y = 4.0*h;\n\n        fragCoord -= 0.5*(iResolution.xy-dims) + mod(m, 2.)*0.5;\n\n        y = floor(fragCoord.y / h);\n\n        uv = fragCoord / dims;\n\n        float b = mod(fragCoord.y + 0.5*h, h);\n\n        if (abs(b - 0.5*h) < 0.5*m || uv.x < 0. || uv.x >= 1.) {\n            y = -1.;\n        }\n        \n    }\n\n    fragColor = vec4(0, 0, 0, 1);\n    \n    if (y == 0.) {\n        fragColor.xyz = paletteLUT(1.0, uv.x);\n    } else if (y == 1.) {\n        fragColor.xyz = hsluv(uv.x);\n    } else if (y == 2.) {\n        fragColor.xyz = paletteLUT(2.0, uv.x);\n    } else if (y == 3.) {\n        fragColor.xyz = hpluv(uv.x);\n    }\n\n    \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// just some ugly code to store two 256-color palettes on the first frame\n// and then just recycle the same texture data over and over\n\nvec4 data = vec4(0);\nivec2 fc;\nivec2 dst_fc;\n\nvoid store(vec3 f) { \n\n    if (dst_fc == fc) {\n        data.xyz = f;\n    }\n    dst_fc.x += 1;\n    \n}\n    \n\nvoid store_all_data() {\n    \n    // initialization\n    dst_fc = ivec2(0, 0);\n    store(vec3(1));\n    \n    //  hsluv\n    dst_fc = ivec2(0, 1);\n\n    store(vec3(1.00000000, 0.30121629, 0.50494183));\n    store(vec3(1.00000000, 0.30424269, 0.48859814));\n    store(vec3(1.00000000, 0.30723827, 0.47150960));\n    store(vec3(1.00000000, 0.31020757, 0.45355707));\n    store(vec3(1.00000000, 0.31315497, 0.43459376));\n    store(vec3(1.00000000, 0.31608470, 0.41443505));\n    store(vec3(1.00000000, 0.31900088, 0.39284280));\n    store(vec3(1.00000000, 0.32190755, 0.36950044));\n    store(vec3(1.00000000, 0.32480869, 0.34397071));\n    store(vec3(1.00000000, 0.32770824, 0.31561901));\n    store(vec3(1.00000000, 0.33061011, 0.28346037));\n    store(vec3(1.00000000, 0.33351823, 0.24580988));\n    store(vec3(1.00000000, 0.33643658, 0.19930106));\n    store(vec3(1.00000000, 0.33936915, 0.13485350));\n    store(vec3(0.99938278, 0.34294341, 0.00000000));\n    store(vec3(0.98103890, 0.36328996, 0.00000000));\n    store(vec3(0.96398111, 0.38063200, 0.00000000));\n    store(vec3(0.94804995, 0.39566226, 0.00000000));\n    store(vec3(0.93311126, 0.40886353, 0.00000000));\n    store(vec3(0.91905123, 0.42058609, 0.00000000));\n    store(vec3(0.90577258, 0.43109219, 0.00000000));\n    store(vec3(0.89319158, 0.44058314, 0.00000000));\n    store(vec3(0.88123570, 0.44921665, 0.00000000));\n    store(vec3(0.86984172, 0.45711848, 0.00000000));\n    store(vec3(0.85895421, 0.46439037, 0.00000000));\n    store(vec3(0.84852436, 0.47111567, 0.00000000));\n    store(vec3(0.83850891, 0.47736349, 0.00000000));\n    store(vec3(0.82886937, 0.48319162, 0.00000000));\n    store(vec3(0.81957135, 0.48864889, 0.00000000));\n    store(vec3(0.81058393, 0.49377685, 0.00000000));\n    store(vec3(0.80187924, 0.49861111, 0.00000000));\n    store(vec3(0.79343202, 0.50318241, 0.00000000));\n    store(vec3(0.78521930, 0.50751744, 0.00000000));\n    store(vec3(0.77722010, 0.51163952, 0.00000000));\n    store(vec3(0.76941516, 0.51556910, 0.00000000));\n    store(vec3(0.76178675, 0.51932422, 0.00000000));\n    store(vec3(0.75431846, 0.52292090, 0.00000000));\n    store(vec3(0.74699506, 0.52637336, 0.00000000));\n    store(vec3(0.73980232, 0.52969434, 0.00000000));\n    store(vec3(0.73272689, 0.53289526, 0.00000000));\n    store(vec3(0.72575624, 0.53598642, 0.00000000));\n    store(vec3(0.71887847, 0.53897714, 0.00000000));\n    store(vec3(0.71208228, 0.54187587, 0.00000000));\n    store(vec3(0.70535689, 0.54469030, 0.00000000));\n    store(vec3(0.69869191, 0.54742748, 0.00000000));\n    store(vec3(0.69207733, 0.55009387, 0.00000000));\n    store(vec3(0.68550341, 0.55269543, 0.00000000));\n    store(vec3(0.67896066, 0.55523763, 0.00000000));\n    store(vec3(0.67243972, 0.55772559, 0.00000000));\n    store(vec3(0.66593138, 0.56016404, 0.00000000));\n    store(vec3(0.65942647, 0.56255741, 0.00000000));\n    store(vec3(0.65291579, 0.56490986, 0.00000000));\n    store(vec3(0.64639012, 0.56722529, 0.00000000));\n    store(vec3(0.63984010, 0.56950739, 0.00000000));\n    store(vec3(0.63325622, 0.57175966, 0.00000000));\n    store(vec3(0.62662870, 0.57398544, 0.00000000));\n    store(vec3(0.61994748, 0.57618791, 0.00000000));\n    store(vec3(0.61320212, 0.57837014, 0.00000000));\n    store(vec3(0.60638172, 0.58053508, 0.00000000));\n    store(vec3(0.59947486, 0.58268560, 0.00000000));\n    store(vec3(0.59246946, 0.58482449, 0.00000000));\n    store(vec3(0.58535273, 0.58695447, 0.00000000));\n    store(vec3(0.57811102, 0.58907823, 0.00000000));\n    store(vec3(0.57072965, 0.59119842, 0.00000000));\n    store(vec3(0.56319283, 0.59331768, 0.00000000));\n    store(vec3(0.55548341, 0.59543864, 0.00000000));\n    store(vec3(0.54758269, 0.59756393, 0.00000000));\n    store(vec3(0.53947016, 0.59969620, 0.00000000));\n    store(vec3(0.53112323, 0.60183817, 0.00000000));\n    store(vec3(0.52251683, 0.60399256, 0.00000000));\n    store(vec3(0.51362298, 0.60616218, 0.00000000));\n    store(vec3(0.50441030, 0.60834992, 0.00000000));\n    store(vec3(0.49484329, 0.61055876, 0.00000000));\n    store(vec3(0.48488160, 0.61279177, 0.00000000));\n    store(vec3(0.47447892, 0.61505220, 0.00000000));\n    store(vec3(0.46358172, 0.61734339, 0.00000000));\n    store(vec3(0.45212752, 0.61966890, 0.00000000));\n    store(vec3(0.44004269, 0.62203246, 0.00000000));\n    store(vec3(0.42723940, 0.62443802, 0.00000000));\n    store(vec3(0.41361153, 0.62688979, 0.00000000));\n    store(vec3(0.39902889, 0.62939226, 0.00000000));\n    store(vec3(0.38332885, 0.63195025, 0.00000000));\n    store(vec3(0.36630386, 0.63456891, 0.00000000));\n    store(vec3(0.34768201, 0.63725384, 0.00000000));\n    store(vec3(0.32709527, 0.64001106, 0.00000000));\n    store(vec3(0.30402406, 0.64284713, 0.00000000));\n    store(vec3(0.27769245, 0.64576921, 0.00000000));\n    store(vec3(0.24684646, 0.64878511, 0.00000000));\n    store(vec3(0.20920095, 0.65190340, 0.00000000));\n    store(vec3(0.15962948, 0.65513354, 0.00000000));\n    store(vec3(0.07929463, 0.65848596, 0.00000000));\n    store(vec3(-0.00000000, 0.65946658, 0.08707563));\n    store(vec3(-0.00000000, 0.65835467, 0.16265107));\n    store(vec3(-0.00000000, 0.65730351, 0.21004012));\n    store(vec3(-0.00000000, 0.65630709, 0.24593491));\n    store(vec3(-0.00000000, 0.65536010, 0.27517292));\n    store(vec3(-0.00000000, 0.65445788, 0.29995945));\n    store(vec3(-0.00000000, 0.65359632, 0.32151992));\n    store(vec3(-0.00000000, 0.65277173, 0.34061858));\n    store(vec3(-0.00000000, 0.65198085, 0.35776980));\n    store(vec3(-0.00000000, 0.65122074, 0.37333917));\n    store(vec3(-0.00000000, 0.65048877, 0.38759726));\n    store(vec3(-0.00000000, 0.64978257, 0.40075079));\n    store(vec3(-0.00000000, 0.64909997, 0.41296172));\n    store(vec3(-0.00000000, 0.64843902, 0.42435963));\n    store(vec3(-0.00000000, 0.64779795, 0.43504997));\n    store(vec3(-0.00000000, 0.64717512, 0.44511986));\n    store(vec3(-0.00000000, 0.64656904, 0.45464215));\n    store(vec3(-0.00000000, 0.64597833, 0.46367847));\n    store(vec3(-0.00000000, 0.64540172, 0.47228148));\n    store(vec3(-0.00000000, 0.64483805, 0.48049652));\n    store(vec3(-0.00000000, 0.64428620, 0.48836298));\n    store(vec3(-0.00000000, 0.64374517, 0.49591531));\n    store(vec3(-0.00000000, 0.64321401, 0.50318385));\n    store(vec3(-0.00000000, 0.64269180, 0.51019547));\n    store(vec3(-0.00000000, 0.64217771, 0.51697412));\n    store(vec3(-0.00000000, 0.64167095, 0.52354124));\n    store(vec3(-0.00000000, 0.64117075, 0.52991616));\n    store(vec3(-0.00000000, 0.64067638, 0.53611635));\n    store(vec3(-0.00000000, 0.64018716, 0.54215772));\n    store(vec3(-0.00000000, 0.63970242, 0.54805479));\n    store(vec3(-0.00000000, 0.63922152, 0.55382090));\n    store(vec3(-0.00000000, 0.63874383, 0.55946835));\n    store(vec3(-0.00000000, 0.63826874, 0.56500853));\n    store(vec3(-0.00000000, 0.63779567, 0.57045206));\n    store(vec3(-0.00000000, 0.63732402, 0.57580885));\n    store(vec3(-0.00000000, 0.63685323, 0.58108822));\n    store(vec3(-0.00000000, 0.63638270, 0.58629898));\n    store(vec3(-0.00000000, 0.63591188, 0.59144948));\n    store(vec3(-0.00000000, 0.63544019, 0.59654768));\n    store(vec3(-0.00000000, 0.63496705, 0.60160122));\n    store(vec3(-0.00000000, 0.63449188, 0.60661746));\n    store(vec3(-0.00000000, 0.63401408, 0.61160351));\n    store(vec3(-0.00000000, 0.63353304, 0.61656634));\n    store(vec3(-0.00000000, 0.63304814, 0.62151273));\n    store(vec3(-0.00000000, 0.63255874, 0.62644937));\n    store(vec3(-0.00000000, 0.63206417, 0.63138291));\n    store(vec3(-0.00000000, 0.63156373, 0.63631995));\n    store(vec3(-0.00000000, 0.63105670, 0.64126711));\n    store(vec3(-0.00000000, 0.63054232, 0.64623104));\n    store(vec3(-0.00000000, 0.63001980, 0.65121850));\n    store(vec3(-0.00000000, 0.62948827, 0.65623637));\n    store(vec3(-0.00000000, 0.62894685, 0.66129169));\n    store(vec3(-0.00000000, 0.62839457, 0.66639169));\n    store(vec3(-0.00000000, 0.62783043, 0.67154389));\n    store(vec3(-0.00000000, 0.62725331, 0.67675607));\n    store(vec3(-0.00000000, 0.62666204, 0.68203638));\n    store(vec3(-0.00000000, 0.62605535, 0.68739338));\n    store(vec3(-0.00000000, 0.62543185, 0.69283610));\n    store(vec3(-0.00000000, 0.62479005, 0.69837408));\n    store(vec3(-0.00000000, 0.62412831, 0.70401750));\n    store(vec3(-0.00000000, 0.62344485, 0.70977724));\n    store(vec3(-0.00000000, 0.62273770, 0.71566496));\n    store(vec3(-0.00000000, 0.62200470, 0.72169322));\n    store(vec3(-0.00000000, 0.62124347, 0.72787563));\n    store(vec3(-0.00000000, 0.62045135, 0.73422693));\n    store(vec3(-0.00000000, 0.61962541, 0.74076322));\n    store(vec3(-0.00000000, 0.61876235, 0.74750212));\n    store(vec3(-0.00000000, 0.61785849, 0.75446297));\n    store(vec3(-0.00000000, 0.61690969, 0.76166711));\n    store(vec3(-0.00000000, 0.61591125, 0.76913818));\n    store(vec3(-0.00000000, 0.61485787, 0.77690246));\n    store(vec3(-0.00000000, 0.61374346, 0.78498930));\n    store(vec3(-0.00000000, 0.61256110, 0.79343160));\n    store(vec3(-0.00000000, 0.61130279, 0.80226646));\n    store(vec3(-0.00000000, 0.60995926, 0.81153584));\n    store(vec3(-0.00000000, 0.60851972, 0.82128751));\n    store(vec3(-0.00000000, 0.60697156, 0.83157609));\n    store(vec3(-0.00000000, 0.60529985, 0.84246439));\n    store(vec3(-0.00000000, 0.60348686, 0.85402511));\n    store(vec3(-0.00000000, 0.60151136, 0.86634292));\n    store(vec3(-0.00000000, 0.59934768, 0.87951712));\n    store(vec3(-0.00000000, 0.59696448, 0.89366506));\n    store(vec3(-0.00000000, 0.59432308, 0.90892663));\n    store(vec3(-0.00000000, 0.59137524, 0.92547006));\n    store(vec3(-0.00000000, 0.58805989, 0.94349976));\n    store(vec3(-0.00000000, 0.58429861, 0.96326697));\n    store(vec3(-0.00000000, 0.57998894, 0.98508443));\n    store(vec3(0.08705126, 0.57476151, 1.00000000));\n    store(vec3(0.18908055, 0.56888970, 1.00000000));\n    store(vec3(0.25096602, 0.56299884, 1.00000000));\n    store(vec3(0.29857943, 0.55708036, 1.00000000));\n    store(vec3(0.33829712, 0.55112550, 1.00000000));\n    store(vec3(0.37286526, 0.54512525, 1.00000000));\n    store(vec3(0.40376097, 0.53907028, 1.00000000));\n    store(vec3(0.43188612, 0.53295087, 1.00000000));\n    store(vec3(0.45783917, 0.52675684, 1.00000000));\n    store(vec3(0.48204145, 0.52047745, 1.00000000));\n    store(vec3(0.50480322, 0.51410134, 1.00000000));\n    store(vec3(0.52636105, 0.50761639, 1.00000000));\n    store(vec3(0.54690057, 0.50100961, 1.00000000));\n    store(vec3(0.56657090, 0.49426702, 1.00000000));\n    store(vec3(0.58549429, 0.48737345, 1.00000000));\n    store(vec3(0.60377274, 0.48031241, 1.00000000));\n    store(vec3(0.62149273, 0.47306580, 1.00000000));\n    store(vec3(0.63872856, 0.46561370, 1.00000000));\n    store(vec3(0.65554499, 0.45793405, 1.00000000));\n    store(vec3(0.67199909, 0.45000225, 1.00000000));\n    store(vec3(0.68814176, 0.44179069, 1.00000000));\n    store(vec3(0.70401893, 0.43326824, 1.00000000));\n    store(vec3(0.71967246, 0.42439945, 1.00000000));\n    store(vec3(0.73514093, 0.41514376, 1.00000000));\n    store(vec3(0.75046027, 0.40545427, 1.00000000));\n    store(vec3(0.76566427, 0.39527632, 1.00000000));\n    store(vec3(0.78078506, 0.38454554, 1.00000000));\n    store(vec3(0.79585348, 0.37318522, 1.00000000));\n    store(vec3(0.81089946, 0.36110281, 1.00000000));\n    store(vec3(0.82595231, 0.34818486, 1.00000000));\n    store(vec3(0.84104101, 0.33428990, 1.00000000));\n    store(vec3(0.85619454, 0.31923765, 1.00000000));\n    store(vec3(0.87144208, 0.30279243, 1.00000000));\n    store(vec3(0.88681334, 0.28463600, 1.00000000));\n    store(vec3(0.90233881, 0.26432051, 1.00000000));\n    store(vec3(0.91805001, 0.24118003, 1.00000000));\n    store(vec3(0.93397988, 0.21414499, 1.00000000));\n    store(vec3(0.95016302, 0.18128547, 1.00000000));\n    store(vec3(0.96663608, 0.13835170, 1.00000000));\n    store(vec3(0.98343816, 0.07058422, 1.00000000));\n    store(vec3(0.99457977, 0.00000000, 0.99397528));\n    store(vec3(0.99884189, 0.00000000, 0.98126797));\n    store(vec3(1.00000000, 0.03358261, 0.96600934));\n    store(vec3(1.00000000, 0.07043814, 0.95019059));\n    store(vec3(1.00000000, 0.09512532, 0.93487684));\n    store(vec3(1.00000000, 0.11420839, 0.92001832));\n    store(vec3(1.00000000, 0.12993072, 0.90557000));\n    store(vec3(1.00000000, 0.14336377, 0.89149090));\n    store(vec3(1.00000000, 0.15511821, 0.87774352));\n    store(vec3(1.00000000, 0.16558115, 0.86429337));\n    store(vec3(1.00000000, 0.17501610, 0.85110852));\n    store(vec3(1.00000000, 0.18361198, 0.83815927));\n    store(vec3(1.00000000, 0.19150953, 0.82541781));\n    store(vec3(1.00000000, 0.19881690, 0.81285791));\n    store(vec3(1.00000000, 0.20561921, 0.80045473));\n    store(vec3(1.00000000, 0.21198482, 0.78818454));\n    store(vec3(1.00000000, 0.21796959, 0.77602452));\n    store(vec3(1.00000000, 0.22361981, 0.76395256));\n    store(vec3(1.00000000, 0.22897429, 0.75194710));\n    store(vec3(1.00000000, 0.23406599, 0.73998692));\n    store(vec3(1.00000000, 0.23892311, 0.72805097));\n    store(vec3(1.00000000, 0.24357002, 0.71611822));\n    store(vec3(1.00000000, 0.24802792, 0.70416746));\n    store(vec3(1.00000000, 0.25231543, 0.69217711));\n    store(vec3(1.00000000, 0.25644896, 0.68012503));\n    store(vec3(1.00000000, 0.26044310, 0.66798832));\n    store(vec3(1.00000000, 0.26431086, 0.65574306));\n    store(vec3(1.00000000, 0.26806394, 0.64336405));\n    store(vec3(1.00000000, 0.27171290, 0.63082451));\n    store(vec3(1.00000000, 0.27526733, 0.61809574));\n    store(vec3(1.00000000, 0.27873596, 0.60514668));\n    store(vec3(1.00000000, 0.28212680, 0.59194341));\n    store(vec3(1.00000000, 0.28544722, 0.57844860));\n    store(vec3(1.00000000, 0.28870405, 0.56462069));\n    store(vec3(1.00000000, 0.29190363, 0.55041305));\n    store(vec3(1.00000000, 0.29505187, 0.53577276));\n    store(vec3(1.00000000, 0.29815435, 0.52063914));\n    \n    //  hpluv\n    dst_fc = ivec2(0, 2);\n    \n    store(vec3(0.77376203, 0.48532689, 0.54388480));\n    store(vec3(0.77313847, 0.48631019, 0.53829628));\n    store(vec3(0.77241461, 0.48733840, 0.53268725));\n    store(vec3(0.77159145, 0.48841012, 0.52706005));\n    store(vec3(0.77066998, 0.48952391, 0.52141708));\n    store(vec3(0.76965122, 0.49067834, 0.51576076));\n    store(vec3(0.76853613, 0.49187197, 0.51009356));\n    store(vec3(0.76732568, 0.49310338, 0.50441802));\n    store(vec3(0.76602085, 0.49437113, 0.49873672));\n    store(vec3(0.76462257, 0.49567378, 0.49305231));\n    store(vec3(0.76313179, 0.49700992, 0.48736749));\n    store(vec3(0.76154942, 0.49837812, 0.48168505));\n    store(vec3(0.75987637, 0.49977699, 0.47600783));\n    store(vec3(0.75811354, 0.50120513, 0.47033879));\n    store(vec3(0.75626180, 0.50266116, 0.46468093));\n    store(vec3(0.75432202, 0.50414372, 0.45903738));\n    store(vec3(0.75229504, 0.50565146, 0.45341134));\n    store(vec3(0.75018169, 0.50718306, 0.44780612));\n    store(vec3(0.74798279, 0.50873720, 0.44222517));\n    store(vec3(0.74569912, 0.51031260, 0.43667200));\n    store(vec3(0.74333145, 0.51190800, 0.43115030));\n    store(vec3(0.74088056, 0.51352213, 0.42566386));\n    store(vec3(0.73834717, 0.51515379, 0.42021661));\n    store(vec3(0.73573200, 0.51680176, 0.41481262));\n    store(vec3(0.73303575, 0.51846487, 0.40945611));\n    store(vec3(0.73025911, 0.52014197, 0.40415147));\n    store(vec3(0.72740272, 0.52183193, 0.39890324));\n    store(vec3(0.72446723, 0.52353363, 0.39371611));\n    store(vec3(0.72145325, 0.52524600, 0.38859497));\n    store(vec3(0.71836139, 0.52696798, 0.38354486));\n    store(vec3(0.71519221, 0.52869853, 0.37857101));\n    store(vec3(0.71194628, 0.53043665, 0.37367883));\n    store(vec3(0.70862413, 0.53218135, 0.36887388));\n    store(vec3(0.70522628, 0.53393165, 0.36416194));\n    store(vec3(0.70175320, 0.53568663, 0.35954893));\n    store(vec3(0.69820538, 0.53744537, 0.35504094));\n    store(vec3(0.69458327, 0.53920696, 0.35064425));\n    store(vec3(0.69088728, 0.54097054, 0.34636524));\n    store(vec3(0.68711784, 0.54273526, 0.34221046));\n    store(vec3(0.68327531, 0.54450028, 0.33818656));\n    store(vec3(0.67936006, 0.54626480, 0.33430029));\n    store(vec3(0.67537244, 0.54802803, 0.33055848));\n    store(vec3(0.67131277, 0.54978920, 0.32696799));\n    store(vec3(0.66718133, 0.55154755, 0.32353570));\n    store(vec3(0.66297840, 0.55330236, 0.32026845));\n    store(vec3(0.65870425, 0.55505292, 0.31717305));\n    store(vec3(0.65435909, 0.55679852, 0.31425616));\n    store(vec3(0.64994315, 0.55853850, 0.31152431));\n    store(vec3(0.64545660, 0.56027218, 0.30898381));\n    store(vec3(0.64089962, 0.56199892, 0.30664074));\n    store(vec3(0.63627235, 0.56371809, 0.30450084));\n    store(vec3(0.63157492, 0.56542907, 0.30256951));\n    store(vec3(0.62680741, 0.56713127, 0.30085171));\n    store(vec3(0.62196992, 0.56882409, 0.29935196));\n    store(vec3(0.61706250, 0.57050695, 0.29807425));\n    store(vec3(0.61208519, 0.57217930, 0.29702200));\n    store(vec3(0.60703799, 0.57384058, 0.29619805));\n    store(vec3(0.60192091, 0.57549025, 0.29560457));\n    store(vec3(0.59673391, 0.57712779, 0.29524311));\n    store(vec3(0.59147694, 0.57875267, 0.29511452));\n    store(vec3(0.58614992, 0.58036439, 0.29521893));\n    store(vec3(0.58075276, 0.58196244, 0.29555583));\n    store(vec3(0.57528534, 0.58354634, 0.29612398));\n    store(vec3(0.56974752, 0.58511561, 0.29692147));\n    store(vec3(0.56413914, 0.58666975, 0.29794577));\n    store(vec3(0.55846000, 0.58820833, 0.29919369));\n    store(vec3(0.55270991, 0.58973086, 0.30066148));\n    store(vec3(0.54688862, 0.59123689, 0.30234485));\n    store(vec3(0.54099588, 0.59272598, 0.30423901));\n    store(vec3(0.53503142, 0.59419769, 0.30633873));\n    store(vec3(0.52899493, 0.59565158, 0.30863839));\n    store(vec3(0.52288609, 0.59708721, 0.31113203));\n    store(vec3(0.51670454, 0.59850415, 0.31381342));\n    store(vec3(0.51044991, 0.59990199, 0.31667608));\n    store(vec3(0.50412179, 0.60128030, 0.31971338));\n    store(vec3(0.49771976, 0.60263866, 0.32291855));\n    store(vec3(0.49124337, 0.60397666, 0.32628472));\n    store(vec3(0.48469214, 0.60529389, 0.32980500));\n    store(vec3(0.47806555, 0.60658994, 0.33347250));\n    store(vec3(0.47136307, 0.60786440, 0.33728035));\n    store(vec3(0.46458414, 0.60911687, 0.34122176));\n    store(vec3(0.45772815, 0.61034694, 0.34529000));\n    store(vec3(0.45079449, 0.61155421, 0.34947849));\n    store(vec3(0.44378249, 0.61273827, 0.35378076));\n    store(vec3(0.43669145, 0.61389874, 0.35819050));\n    store(vec3(0.42952065, 0.61503519, 0.36270155));\n    store(vec3(0.42226932, 0.61614725, 0.36730793));\n    store(vec3(0.41493666, 0.61723450, 0.37200384));\n    store(vec3(0.40752182, 0.61829656, 0.37678364));\n    store(vec3(0.40002391, 0.61933301, 0.38164191));\n    store(vec3(0.39244200, 0.62034346, 0.38657339));\n    store(vec3(0.38477510, 0.62132750, 0.39157302));\n    store(vec3(0.37702219, 0.62228475, 0.39663591));\n    store(vec3(0.36918217, 0.62321480, 0.40175737));\n    store(vec3(0.36125390, 0.62411724, 0.40693286));\n    store(vec3(0.35323617, 0.62499167, 0.41215802));\n    store(vec3(0.34512771, 0.62583770, 0.41742867));\n    store(vec3(0.33692715, 0.62665492, 0.42274078));\n    store(vec3(0.32863307, 0.62744292, 0.42809046));\n    store(vec3(0.32024395, 0.62820131, 0.43347398));\n    store(vec3(0.31175818, 0.62892967, 0.43888775));\n    store(vec3(0.30317404, 0.62962760, 0.44432830));\n    store(vec3(0.29448971, 0.63029470, 0.44979231));\n    store(vec3(0.28570321, 0.63093056, 0.45527656));\n    store(vec3(0.27681246, 0.63153478, 0.46077794));\n    store(vec3(0.26781520, 0.63210694, 0.46629346));\n    store(vec3(0.25870900, 0.63264665, 0.47182022));\n    store(vec3(0.24949124, 0.63315350, 0.47735542));\n    store(vec3(0.24015905, 0.63362708, 0.48289635));\n    store(vec3(0.23070936, 0.63406699, 0.48844036));\n    store(vec3(0.22113876, 0.63447283, 0.49398491));\n    store(vec3(0.21144355, 0.63484420, 0.49952751));\n    store(vec3(0.20161963, 0.63518070, 0.50506574));\n    store(vec3(0.19166248, 0.63548193, 0.51059723));\n    store(vec3(0.18156704, 0.63574750, 0.51611970));\n    store(vec3(0.17132768, 0.63597702, 0.52163090));\n    store(vec3(0.16093803, 0.63617010, 0.52712861));\n    store(vec3(0.15039088, 0.63632635, 0.53261069));\n    store(vec3(0.13967796, 0.63644540, 0.53807503));\n    store(vec3(0.12878977, 0.63652688, 0.54351954));\n    store(vec3(0.11771520, 0.63657040, 0.54894218));\n    store(vec3(0.10644119, 0.63657562, 0.55434095));\n    store(vec3(0.09495214, 0.63654217, 0.55971385));\n    store(vec3(0.08322912, 0.63646970, 0.56505893));\n    store(vec3(0.07124879, 0.63635787, 0.57037426));\n    store(vec3(0.05898167, 0.63620635, 0.57565793));\n    store(vec3(0.04638953, 0.63601482, 0.58090803));\n    store(vec3(0.03366588, 0.63578296, 0.58612270));\n    store(vec3(0.02268081, 0.63551047, 0.59130007));\n    store(vec3(0.01382801, 0.63519706, 0.59643829));\n    store(vec3(0.00713350, 0.63484245, 0.60153553));\n    store(vec3(0.00262228, 0.63444638, 0.60658996));\n    store(vec3(0.00031832, 0.63400859, 0.61159978));\n    store(vec3(0.00024447, 0.63352886, 0.61656317));\n    store(vec3(0.00242239, 0.63300695, 0.62147833));\n    store(vec3(0.00687250, 0.63244268, 0.62634348));\n    store(vec3(0.01361391, 0.63183585, 0.63115684));\n    store(vec3(0.02266434, 0.63118631, 0.63591662));\n    store(vec3(0.03404008, 0.63049391, 0.64062106));\n    store(vec3(0.04728712, 0.62975853, 0.64526839));\n    store(vec3(0.06042656, 0.62898006, 0.64985685));\n    store(vec3(0.07329774, 0.62815844, 0.65438469));\n    store(vec3(0.08593751, 0.62729361, 0.65885016));\n    store(vec3(0.09837384, 0.62638555, 0.66325152));\n    store(vec3(0.11062849, 0.62543427, 0.66758704));\n    store(vec3(0.12271870, 0.62443978, 0.67185498));\n    store(vec3(0.13465841, 0.62340216, 0.67605363));\n    store(vec3(0.14645892, 0.62232149, 0.68018128));\n    store(vec3(0.15812956, 0.62119790, 0.68423622));\n    store(vec3(0.16967804, 0.62003155, 0.68821676));\n    store(vec3(0.18111077, 0.61882263, 0.69212122));\n    store(vec3(0.19243307, 0.61757137, 0.69594792));\n    store(vec3(0.20364941, 0.61627803, 0.69969521));\n    store(vec3(0.21476348, 0.61494291, 0.70336145));\n    store(vec3(0.22577835, 0.61356636, 0.70694500));\n    store(vec3(0.23669653, 0.61214876, 0.71044426));\n    store(vec3(0.24752009, 0.61069053, 0.71385763));\n    store(vec3(0.25825067, 0.60919215, 0.71718354));\n    store(vec3(0.26888957, 0.60765413, 0.72042043));\n    store(vec3(0.27943775, 0.60607701, 0.72356677));\n    store(vec3(0.28989594, 0.60446141, 0.72662105));\n    store(vec3(0.30026458, 0.60280796, 0.72958180));\n    store(vec3(0.31054392, 0.60111738, 0.73244755));\n    store(vec3(0.32073401, 0.59939040, 0.73521689));\n    store(vec3(0.33083474, 0.59762782, 0.73788842));\n    store(vec3(0.34084582, 0.59583049, 0.74046077));\n    store(vec3(0.35076685, 0.59399930, 0.74293262));\n    store(vec3(0.36059728, 0.59213519, 0.74530268));\n    store(vec3(0.37033648, 0.59023918, 0.74756968));\n    store(vec3(0.37998369, 0.58831230, 0.74973243));\n    store(vec3(0.38953809, 0.58635566, 0.75178973));\n    store(vec3(0.39899877, 0.58437042, 0.75374047));\n    store(vec3(0.40836473, 0.58235779, 0.75558355));\n    store(vec3(0.41763496, 0.58031903, 0.75731794));\n    store(vec3(0.42680835, 0.57825545, 0.75894263));\n    store(vec3(0.43588377, 0.57616843, 0.76045669));\n    store(vec3(0.44486004, 0.57405937, 0.76185923));\n    store(vec3(0.45373596, 0.57192975, 0.76314941));\n    store(vec3(0.46251029, 0.56978109, 0.76432643));\n    store(vec3(0.47118177, 0.56761497, 0.76538957));\n    store(vec3(0.47974914, 0.56543299, 0.76633815));\n    store(vec3(0.48821113, 0.56323683, 0.76717156));\n    store(vec3(0.49656643, 0.56102821, 0.76788924));\n    store(vec3(0.50481377, 0.55880887, 0.76849069));\n    store(vec3(0.51295187, 0.55658063, 0.76897547));\n    store(vec3(0.52097945, 0.55434533, 0.76934320));\n    store(vec3(0.52889525, 0.55210485, 0.76959357));\n    store(vec3(0.53669803, 0.54986113, 0.76972634));\n    store(vec3(0.54438655, 0.54761611, 0.76974130));\n    store(vec3(0.55195962, 0.54537178, 0.76963835));\n    store(vec3(0.55941605, 0.54313018, 0.76941741));\n    store(vec3(0.56675469, 0.54089335, 0.76907850));\n    store(vec3(0.57397442, 0.53866336, 0.76862168));\n    store(vec3(0.58107417, 0.53644233, 0.76804709));\n    store(vec3(0.58805287, 0.53423235, 0.76735494));\n    store(vec3(0.59490953, 0.53203557, 0.76654547));\n    store(vec3(0.60164317, 0.52985413, 0.76561902));\n    store(vec3(0.60825287, 0.52769018, 0.76457599));\n    store(vec3(0.61473775, 0.52554588, 0.76341682));\n    store(vec3(0.62109698, 0.52342338, 0.76214203));\n    store(vec3(0.62732976, 0.52132485, 0.76075220));\n    store(vec3(0.63343538, 0.51925243, 0.75924798));\n    store(vec3(0.63941314, 0.51720825, 0.75763005));\n    store(vec3(0.64526241, 0.51519444, 0.75589919));\n    store(vec3(0.65098261, 0.51321309, 0.75405620));\n    store(vec3(0.65657321, 0.51126628, 0.75210196));\n    store(vec3(0.66203375, 0.50935606, 0.75003740));\n    store(vec3(0.66736380, 0.50748443, 0.74786350));\n    store(vec3(0.67256300, 0.50565337, 0.74558130));\n    store(vec3(0.67763105, 0.50386481, 0.74319188));\n    store(vec3(0.68256768, 0.50212063, 0.74069639));\n    store(vec3(0.68737271, 0.50042268, 0.73809601));\n    store(vec3(0.69204599, 0.49877271, 0.73539197));\n    store(vec3(0.69658743, 0.49717246, 0.73258555));\n    store(vec3(0.70099699, 0.49562358, 0.72967808));\n    store(vec3(0.70527469, 0.49412765, 0.72667091));\n    store(vec3(0.70942060, 0.49268619, 0.72356546));\n    store(vec3(0.71343485, 0.49130063, 0.72036315));\n    store(vec3(0.71731761, 0.48997234, 0.71706549));\n    store(vec3(0.72106909, 0.48870260, 0.71367397));\n    store(vec3(0.72468958, 0.48749260, 0.71019016));\n    store(vec3(0.72817938, 0.48634345, 0.70661562));\n    store(vec3(0.73153887, 0.48525618, 0.70295198));\n    store(vec3(0.73476846, 0.48423170, 0.69920088));\n    store(vec3(0.73786860, 0.48327086, 0.69536398));\n    store(vec3(0.74083978, 0.48237439, 0.69144297));\n    store(vec3(0.74368255, 0.48154294, 0.68743958));\n    store(vec3(0.74639748, 0.48077706, 0.68335555));\n    store(vec3(0.74898519, 0.48007720, 0.67919264));\n    store(vec3(0.75144632, 0.47944371, 0.67495264));\n    store(vec3(0.75378156, 0.47887685, 0.67063736));\n    store(vec3(0.75599162, 0.47837679, 0.66624860));\n    store(vec3(0.75807727, 0.47794357, 0.66178823));\n    store(vec3(0.76003927, 0.47757719, 0.65725808));\n    store(vec3(0.76187844, 0.47727751, 0.65266004));\n    store(vec3(0.76359560, 0.47704432, 0.64799599));\n    store(vec3(0.76519162, 0.47687733, 0.64326784));\n    store(vec3(0.76666736, 0.47677614, 0.63847750));\n    store(vec3(0.76802375, 0.47674028, 0.63362690));\n    store(vec3(0.76926168, 0.47676919, 0.62871798));\n    store(vec3(0.77038212, 0.47686225, 0.62375270));\n    store(vec3(0.77138599, 0.47701875, 0.61873303));\n    store(vec3(0.77227429, 0.47723791, 0.61366095));\n    store(vec3(0.77304798, 0.47751888, 0.60853846));\n    store(vec3(0.77370807, 0.47786075, 0.60336757));\n    store(vec3(0.77425556, 0.47826255, 0.59815030));\n    store(vec3(0.77469145, 0.47872325, 0.59288869));\n    store(vec3(0.77501676, 0.47924176, 0.58758481));\n    store(vec3(0.77523253, 0.47981696, 0.58224072));\n    store(vec3(0.77533977, 0.48044767, 0.57685852));\n    store(vec3(0.77533953, 0.48113266, 0.57144031));\n    store(vec3(0.77523282, 0.48187069, 0.56598824));\n    store(vec3(0.77502069, 0.48266046, 0.56050446));\n    store(vec3(0.77470416, 0.48350065, 0.55499115));\n    store(vec3(0.77428427, 0.48438992, 0.54945052));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    float ready = texelFetch(iChannel0, ivec2(0, 0), 0).x;\n    \n    \n    fc = ivec2(fragCoord);\n    data = texelFetch(iChannel0, fc, 0);\n    \n    if (ready != 1.0) {\n        store_all_data();\n    }\n    \n    fragColor = data;\n    \n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdBcRG.jpg", "access": "api", "license": "libpng AND cc0-1.0", "functions": [[1024, 1024, 1045, 1045, 1696], [1698, 1698, 1719, 1719, 2373], [2375, 2375, 2412, 2412, 2575], [2577, 2577, 2634, 2634, 3702]], "test": "untested"}
{"id": "tsScRG", "name": "Large scale flocking", "author": "michael0884", "description": "Flocking! This seems fun.", "tags": ["particles", "aabb", "sort"], "likes": 28, "viewed": 925, "published": 3, "date": "1586827749", "time_retrieved": "2024-07-30T21:13:02.956362", "image_code": "ivec4 get(ivec2 p)\n{\n    return floatBitsToInt(texel(ch0, p));\n}\n\nivec4 getb(int id)\n{\n    return floatBitsToInt(texel(ch2, i2xy(id)));\n}\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    ivec4 nb = get(ivec2(pos));\n \tvec4 p0 = getParticle(nb.x);\n   \n    ivec4 nbm = get(ivec2(iMouse.xy));\n    ivec4 nbb = getb(nbm.x);\n    \n    float d = 0.;\n    for(int i = 0; i<4; i++)\n    {\n         if(nbb[i]<1) continue;\n        vec4 pi = getParticle(nbb[i]);\n        d += exp(-distance(pos,pi.xy));\n    }\n    \n    float d0 = 0.;\n    for(int i = 0; i<4; i++)\n    {\n        if(nb[i]<0) continue;\n        vec4 pi = getParticle(nb[i]);\n        d0 += 0.24/(1.+0.3*distance(pos,pi.xy));\n    }\n    \n    fragColor = 2.5*sin(vec4(1,1,3,4)*d0 +\n                            5.*vec4(4,3,2,1)*d);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define N ivec2(32,32)\n#define dt 1.5\n\n\nconst int tot_n = N.x*N.y;\n\nfloat hash11(float p)\n{\n    p = fract(p * 15.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p) - 0.5;\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nconst int k = 1664525;  \n\nivec4 hash( ivec4 x )\n{\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    return ivec4(x);\n}\n\nivec2 i2xy(int id)\n{\n    return ivec2(id%N.x, id/N.x);\n}\n\nint xy2i(ivec2 p)\n{\n    return p.x + p.y*N.x;\n}\n\nivec2 cross_distribution(int i)\n{\n    return (1<<(i/4)) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 );\n}", "buffer_a_code": "//particle buffer\n\nint cid;\n\nivec4 get(int id)\n{\n    return floatBitsToInt(texel(ch0, i2xy(id)));\n}\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat F(float d)\n{\n    return 0.8/(1.+0.4*d) - 4.*exp(-0.5*d);\n}\n\nvec2 Fv(vec4 p0, int pid)\n{\n    if(pid < 0 || pid >= tot_n || pid == cid) return vec2(0); \n   \tvec4 p1 = getParticle(pid);\n    vec2 flocking_force = 0.3*(p1.zw - p0.zw)/(1.+1.*distance(p1.xy,p0.xy));\n    vec2 interaction = normalize(p1.xy-p0.xy)*F(distance(p1.xy,p0.xy));\n    return flocking_force + interaction;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    if(p.x < N.x && p.y < N.y)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch1, pos);\n        int id = xy2i(p);\n        cid = id;\n        \n        //this pixel value\n        if(iFrame<10)\n        {\n            U.xy = size*hash22(pos);\n\t\t\tU.zw = 2.*(hash22(3.14159*pos) - 0.5);\n      \t\treturn;\n        }\n        \n        //neighbors\n   \t\tivec4 cp = get(id);\n   \t  \n        vec2 F = Fv(U, cp.x) +\n            \t Fv(U, cp.y) +\n            \t Fv(U, cp.z) +\n                 Fv(U, cp.w);\n        \n        if(iMouse.z > 0.) \n        {\n            float d = distance(iMouse.xy, U.xy);\n            F += 2.*normalize(iMouse.xy - U.xy)/(sqrt(d)+2.);\n        }\n        \n        U.zw += (0.5*F)*dt;\n        U.zw = normalize(U.zw);\n        U.xy += U.zw*dt;\n        \n        //border conditions\n        /*if(size.x - U.x < 2.) U.z = -abs(U.z);\n        if(U.x < 2.) U.z = abs(U.z);\n        if(size.y - U.y < 2.) U.w = -abs(U.w);\n        if(U.y < 2.) U.w = abs(U.w);*/\n        \n        U.xy = mod(U.xy, size);\n \n        \n    }\n    else discard;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//sorting closest 4 particles in axis directions that make a bounding box\n//only in particle space, texture buffer not needed\n\nivec4 get(int id)\n{\n    return floatBitsToInt(texel(ch0, i2xy(id)));\n}\n\nvec4 save(ivec4 v)\n{\n    return intBitsToFloat(v);\n}\n\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //this particle position\nint tid;\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\n//insertion sort\nvoid sort(int utemp)\n{\n    if(utemp == tid || utemp < 0) return;\n       \n   \tvec4 part = getParticle(utemp);\n    vec2 dx = part.xy - pos;\n    float dtemp = length(dx);\n    //sorting\n    if(dx.x > abs(dx.y))\n    {\n        if(d.x > dtemp) \n        {\n            d.x = dtemp;\n        \tu.x = utemp;\n        }\n    }\n    else if(dx.x < -abs(dx.y))\n    {\n        if(d.y > dtemp) \n        {\n            d.y = dtemp;\n        \tu.y = utemp;\n        }\n    }\n    else if(dx.y > abs(dx.x))\n    {\n        if(d.z > dtemp) \n        {\n            d.z = dtemp;\n        \tu.z = utemp;\n        }\n    }\n    else if(d.w > dtemp) \n    {\n        d.w = dtemp;\n        u.w = utemp;\n    }\n}\n\nvoid sortneighbor(int id)\n{\n    ivec4 nb = get(id);\n    for(int j = 0; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{  \n    ivec2 p = ivec2(fragCoord);\n    \n    if(p.x > N.x || p.y > N.y) discard;\n    \n    int id = xy2i(p);\n     \n    u = ivec4(-1); d = vec4(1e10); \n   \n    tid = id;\n    pos = getParticle(id).xy;\n    \n    sortneighbor(id); \n    \n    for(int i = 0; i < 8; i++)\n    {\n        sort(hash(ivec4(p, iFrame, i)).x%tot_n); //random sort    \n    }\n    \n    ivec4 nb = get(id);\n    for(int i = 0; i < 4; i++)\n    {\n        sortneighbor(nb[i]); \n    }\n    \n    if( any(lessThan(u, ivec4(-1))) || any(greaterThan(u, ivec4(tot_n))))\n    {\n        u = ivec4(0);\n    }\n    \n    \n    U = save(u);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//4th order voronoi particle tracking \n\nivec4 get(ivec2 p)\n{\n    return floatBitsToInt(texel(ch0, p));\n}\n\nvec4 save(ivec4 v)\n{\n    return intBitsToFloat(v);\n}\n\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //pixel position\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id).xy, p);\n}\n\n//insertion sort\nvoid sort(int utemp)\n{\n    if(utemp <0) return; \n   \tfloat dtemp = particleDistance(utemp, pos);\n    //sorting\n    if(d.x > dtemp)\n    {\n        d = vec4(dtemp, d.xyz);\n        u = ivec4(utemp, u.xyz);\n    }\n    else if(d.y > dtemp && dtemp > d.x)\n    {\n        d.yzw = vec3(dtemp, d.yz);\n        u.yzw = ivec3(utemp, u.yz);\n    }\n    else if(d.z > dtemp && dtemp > d.y)\n    {\n        d.zw = vec2(dtemp, d.z);\n        u.zw = ivec2(utemp, u.z);\n    }\n    else if(d.w > dtemp && dtemp > d.z)\n    {\n        d.w = dtemp;\n        u.w = utemp;\n    }\n}\n\nvoid sortpos(ivec2 p)\n{\n    ivec4 nb = get(p);\n    for(int j = 0; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{\n    pos = fragCoord;\n    ivec2 p = ivec2(pos);\n     \n    u = ivec4(-1); d = vec4(1e10); \n   \n    //jump flood sorting \n    sortpos(p); //resort this position\n    for(int i = 0; i < 12; i++)\n    {\n        sortpos(p+cross_distribution(i)); \n    }\n    \n    for(int i = 0; i < 4; i++)\n    {\n        sort(hash(ivec4(p, iFrame, i)).x%tot_n); //random sort    \n    }\n    \n    if( any(lessThan(u, ivec4(-1))) || any(greaterThan(u, ivec4(tot_n))) )\n    {\n        u = ivec4(0);\n    }\n    \n    U = save(u);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsScRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 64], [66, 66, 86, 86, 137], [139, 139, 165, 165, 200], [202, 202, 253, 253, 844]], "test": "untested"}
{"id": "WdByRy", "name": "Sierpinski_pieces", "author": "elle", "description": "Sierpinski triangle", "tags": ["fractal", "sierpinski"], "likes": 3, "viewed": 293, "published": 3, "date": "1586821573", "time_retrieved": "2024-07-30T21:13:03.718325", "image_code": "float sierpinski(vec3 p)\n{\n    const int iter_cnt = 20;\n    float scale = clamp(sin((iTime - 7.0) * 0.2) + 2.02, 1.0, 2.0);\n    float offset = 1.0;\n    for (int n = 0; n < iter_cnt; n++)\n    {\n       if(p.x + p.y < 0.0) p.xy = -p.yx; // fold 1\n       if(p.x + p.z < 0.0) p.xz = -p.zx; // fold 2\n       if(p.y + p.z < 0.0) p.zy = -p.yz; // fold 3\t\n       p = p * scale - offset * (scale - 1.0);\n    }\n    return (length(p)) * pow(scale, -float(iter_cnt));\n}\n\nvec3 rotate(vec3 p, float angleX, float angleY)\n{\n    float cosA = cos(angleY);\n\tfloat sinA = sin(angleY);\n\tvec3 r = vec3(p.x, sinA * p.z + cosA * p.y, cosA * p.z - sinA * p.y);\n    cosA = cos(angleX);\n\tsinA = sin(angleX);\n\treturn (-vec3(cosA * r.x - sinA * r.z, r.y, sinA * r.x + cosA * r.z));\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0,4.0,2.0),6.0) - 3.0) - 1.0, 0.0, 1.0);\n\treturn (c.z * mix(vec3(1.0), rgb, c.y));\n}\n\nfloat distSphere(vec3 p, float r)\n{\n\treturn (length(p) - r);\n}\n\nfloat distPlane(vec3 p, vec4 n)\n{\n\treturn (dot(p, n.xyz) + n.w);\n}\n\nbool bgS = false;\nbool bgP = false;\nfloat distanceEstimate(vec3 p)\n{\n\tfloat dSphere = -distSphere(p, 30.0);\t\n\tfloat dFractal = sierpinski(p);\n    float dPlane = distPlane(p, normalize(vec4(-10.0, -10.0, 10.0, 10.1)));\n    bgP = dPlane < dFractal ? true : false;\n    bgS = dSphere < dPlane ? true : false;\n\treturn (min(min(dFractal, dPlane), dSphere));\n}\n\nvec3 getNormal(vec3 pos, float dist)\n{\n    vec2 eps = vec2(0.001, 0.0);\n\treturn normalize(vec3(\n           distanceEstimate(pos + eps.xyy),\n           distanceEstimate(pos + eps.yxy),\n           distanceEstimate(pos + eps.yyx)) - dist);\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd, in float k)\n{\n    float res = 1.0;\n    float t = 0.0;\n    for(int i = 0; i < 64; i++)\n    {\n        float d = distanceEstimate(ro + rd * t);\n        res = min(res, k * d/t);\n        if(res < 0.001)\n            break;\n        t += clamp(d, 0.01, 0.2);\n    }\n    return (clamp(res, 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 aspectRatio = vec2(iResolution.x/iResolution.y, 1.0);\n\tvec2 uv = aspectRatio * (fragCoord.xy / iResolution.xy - 0.5);\n    vec2 mouse = 4.0 * (iMouse.xy / iResolution.xy - 0.5);\n    mouse.x += 2.7;\n    mouse.y -= 0.4;\n    vec3 ro = rotate(vec3(0.0, -0.1, sin((iTime - 7.0) * 0.2) + 2.5), mouse.x, mouse.y);\n    vec3 rd = -rotate(vec3(uv, 1.0), mouse.x, mouse.y);  \n    vec3 light = rotate(vec3(0.7, -0.22, 0.5), mouse.x, mouse.y);\n    vec3 lightColor = vec3(0.9, 1.0, 1.0);\n    vec3 material;\n    vec3 color;\n    float eps = 0.002;\n\tfloat dist;\n\tfor(float n = 0.0; n < 200.0; n++)\n    {\n\t\tdist = distanceEstimate(ro);\n\t\tif(dist < eps)\n\t\t\tbreak;\n\t\tro += rd * dist * 0.5;\n\t}\n\tif(bgS == true)\n\t{ \n        color = vec3(1.0, 1.0, 0.5) * (1.0 + 0.9 * uv.y);\n\t\tfragColor = vec4(color, 1.0);\n\t\treturn;\n\t}\n    if(bgP == true) \n        material = hsv2rgb(vec3(dot(ro, ro) * 0.0001 + 0.52, ro.y, 0.4));\n    else\n        material = hsv2rgb(vec3(dot(ro, ro) * 0.11 + 0.62, 0.98, 1.2));\n\tvec3 norm = getNormal(ro, dist);\n\tvec3 lightDir = normalize(light - rd);   \n\tfloat shadow = softShadow(ro + 0.001 * norm, light, 20.0);\n    float ambient = 0.5;\n\tfloat diff = clamp(dot(light, norm), 0.0, 1.0) * shadow * 2.5;\n\tfloat spec = pow(clamp(dot(norm, lightDir), 0.0, 1.0), 32.0) * shadow * 2.0;\n \tcolor = (lightColor * (ambient + diff + spec) * material);   \n    color = pow(color, 0.9 * lightColor);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdByRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 456], [458, 458, 507, 507, 754], [756, 756, 778, 778, 911], [913, 913, 948, 948, 975], [977, 977, 1010, 1010, 1043], [1081, 1081, 1113, 1113, 1398], [1400, 1400, 1438, 1438, 1638], [1640, 1640, 1694, 1694, 1974], [1976, 1976, 2031, 2031, 3455]], "test": "untested"}
{"id": "3sBcRy", "name": "Tide", "author": "Kanata", "description": "tried some lengths", "tags": ["coomplexnumbers"], "likes": 0, "viewed": 283, "published": 3, "date": "1586815272", "time_retrieved": "2024-07-30T21:13:04.486271", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 res = iResolution.xy,\n          z = ( u* 2. - res) / min(res.x, res.y);\n\n    float t = iTime;\n    float scale = 1.;\n    z *= scale;\n    \n    vec2 a = vec2(cos(1.7 * t), sin(t));\n    vec2 b = vec2(-sin(t) + 0.3 * sin(6. * t), cos(2. * t));\n    vec2 c = vec2(sin(0.6 * t), -cos(1. * t));\n    \n    float p = 0.03;\n\n    float f =  p/abs(length(z-a) + length(z-b) - length(z-c)) + sin(t) - .1;\n    float g =  p/abs(length(z-a) -length(z-b) + length(z-c));\n    float h =  p/abs(-length(z-a) + length(z-b) + length(z-c));\n\n\n    O = vec4(vec3(f + g + h), 1.);\n}\n", "image_inputs": [], "common_code": "const float PI  = 3.141592653589793;\n\nvec3 hsvToRgb(float h, float s, float v) {\n    // h: -π - +π, s: 0.0 - 1.0, v: 0.0 - 1.0\n    h = (h + PI) / (2.* PI) * 360.;\n\n    float c = s; // float c = v * s;\n    float h2 = h / 60.0;\n    float x = c * (1.0 - abs(mod(h2, 2.0) - 1.0));\n    vec3 rgb = (v - c) * vec3(1.0, 1.0, 1.0);\n\n    if (0.0 <= h2 && h2 < 1.0) {\n        rgb += vec3(c, x, 0.0);\n    } else if (1.0 <= h2 && h2 < 2.0) {\n        rgb += vec3(x, c, 0.0);\n    } else if (2.0 <= h2 && h2 < 3.0) {\n        rgb += vec3(0.0, c, x);\n    } else if (3.0 <= h2 && h2 < 4.0) {\n        rgb += vec3(0.0, x, c);\n    } else if (4.0 <= h2 && h2 < 5.0) {\n        rgb += vec3(x, 0.0, c);\n    } else if (5.0 <= h2 && h2 < 6.0) {\n        rgb += vec3(c, 0.0, x);\n    }\n\n    return rgb;\n}\n// hsvToRgb borrowed from\n// https://qiita.com/sw1227/items/4be9b9f928724a389a85\n// (slightly modified by Kanata)\n\n//operations on complex numbers borrowed from\n//https://shadertoyunofficial.wordpress.com/2019/01/02/programming-tricks-in-shadertoy-glsl/\n\n#define re(a) vec2((a).x, 0.)\n#define im(a) vec2(0., (a).y)\n#define cmul(a,b) ( mat2(a, -(a).y, (a).x ) * (b) )\n#define conj(a)     vec2( (a).x, -(a).y)\n#define cinv(a)   ( conj(a) / dot(a, a) )\n#define cdiv(a,b) ( cmul(a, cinv(b)) )\n#define cexp(a)   ( exp((a).x)* vec2(cos((a).y), sin((a).y)) )\n#define clog(a)     vec2( log(length(a)), atan((a).y,(a).x) )\n#define arg(a)\t( atan(a.y, a.x) )\n#define cpow(a,n)   cexp( float(n)* clog(a) )", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sBcRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 601]], "test": "untested"}
{"id": "wdByDD", "name": "Opaq (4k Intro port)", "author": "spolsh", "description": "Web GL port of Opaq 4K Intro released at Revision 2020 demoparty (https://2020.revision-party.net/)\nhttps://www.pouet.net/prod.php?which=85234\nhttps://soundcloud.com/josh-revilo/k2-opaq-4kb-realtime-execute-music/s-gO96rwQ4qP6", "tags": ["3d", "raymarching", "sdf", "metaballs", "intro", "4k", "pathtracing", "revision", "multipass", "klos"], "likes": 14, "viewed": 940, "published": 3, "date": "1586812589", "time_retrieved": "2024-07-30T21:13:05.362927", "image_code": "/*\n''''''''''''''''''''''''''''''''''''''''''''        .revision 2020\n'''@@@@''''''''''@@@'''''@@@@@@@@@@@@@@@@'''\n'''@@@@'''''''''@@@@@'''@@@@@@@@@@@@@@@@@@''\n''@@@@@@''''''''@@@@@'''@@@@@@@@@@@@@@@@@@''  code  .klos\n''@@@@@@''''''''@@@@@'''@@@@@@@@@@@@@@@@@@''        .shx\n''@@@@@@''''''''@@@@@'''@@@@@@@@@@@@@@@@@@''        .pml\n''@@@@@@''''''''@@@@@''''''''''''''''@@@@@''\n''@@@@@@''''''''@@@@@''''''''''''''''@@@@@''  music .shx\n''@@@@@@''''''''@@@@@''''''''''''''''@@@@@''  \n''@@@@@@'''@@@@@@@@@@''''@@@@@@@@@@@@@@@@@''\n''@@@@@@'''@@@@@@@@@@'''@@@@@@@@@@@@@@@@@@''  gfx   .klos\n''@@@@@@''@@@@@@@@@@@'''@@@@@@@@@@@@@@@@@@''  \n''@@@@@@''@@@@@@@@@@@'''@@@@@@@@@@@@@@@@@@''\n'''@@@@''''@@@@@@@@@''''@@@@@@@@@@@@@@@@@@''  >>> Opaq <<<\n''''''''''''''''''''''''''''''''''''''''''''  \n''''''''''''''''''''''''''''''''''''''''''''\n'''@@@@''''@@@@@@@@@'''''@@@@@@@@@@@@@@@@'''  tools .crinkler\n'''@@@@''''@@@@@@@@@@'''@@@@@@@@@@@@@@@@@@''        .4klang\n''@@@@@@''@@@@@@@@@@@'''@@@@@@@@@@@@@@@@@@''        .shaderminifier\n''@@@@@@''@@@@@@@@@@@'''@@@@@@@@@@@@@@@@@@''        .opengl\n''@@@@@@'''@@@@@@@@@@'''@@@@@@@@@@@@@@@@@@''\n''@@@@@@''''''''@@@@@'''@@@@@'''''''''''''''  greets\n''@@@@@@''''''''@@@@@'''@@@@@'''''''''''''''    Aberration Creations,\n''@@@@@@''''''''@@@@@'''@@@@@'''''''''''''''    Abyss, Adapt, Alcatraz,\n''@@@@@@''''''''@@@@@'''@@@@@@@@@@@@@@@@@'''    Altair, Brain Control,\n''@@@@@@''''''''@@@@@'''@@@@@@@@@@@@@@@@@@''    Dekadence, Desire, FHI,\n''@@@@@@''''''''@@@@@'''@@@@@@@@@@@@@@@@@@''    Fulcrum, Hprg, Jetlag,\n''@@@@@@''''''''@@@@@'''@@@@@@@@@@@@@@@@@@''    LJ, Nuance, Prismbeings,\n'''@@@@'''''''''@@@@''''@@@@@@@@@@@@@@@@@@''    PVM, Rabenauge, Skyrunner,\n''''''''''''''''''''''''''''''''''''''''''''    Titan & everybody we forgot!\n*/\n\n// See Buffer A for sample count controls\n// Audio comes from soundcloud link, \n// \tmay need to wait a bit to load or refresh website\n\nvoid mainImage(out vec4 f, in vec2 fragCoord)\n{\n   vec2 k = min(vec2(1280., 720.), iResolution.xy);\n   vec2 uv = fragCoord.xy * k.xy / (iResolution.xy * iResolution.xy);\n   f = texture(iChannel0, uv);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n''''''''''''''''''''''''''''''''''''''''''''        .revision 2020\n'''@@@@''''''''''@@@'''''@@@@@@@@@@@@@@@@'''\n'''@@@@'''''''''@@@@@'''@@@@@@@@@@@@@@@@@@''\n''@@@@@@''''''''@@@@@'''@@@@@@@@@@@@@@@@@@''  code  .klos\n''@@@@@@''''''''@@@@@'''@@@@@@@@@@@@@@@@@@''        .shx\n''@@@@@@''''''''@@@@@'''@@@@@@@@@@@@@@@@@@''        .pml\n''@@@@@@''''''''@@@@@''''''''''''''''@@@@@''\n''@@@@@@''''''''@@@@@''''''''''''''''@@@@@''  music .shx\n''@@@@@@''''''''@@@@@''''''''''''''''@@@@@''  \n''@@@@@@'''@@@@@@@@@@''''@@@@@@@@@@@@@@@@@''\n''@@@@@@'''@@@@@@@@@@'''@@@@@@@@@@@@@@@@@@''  gfx   .klos\n''@@@@@@''@@@@@@@@@@@'''@@@@@@@@@@@@@@@@@@''  \n''@@@@@@''@@@@@@@@@@@'''@@@@@@@@@@@@@@@@@@''\n'''@@@@''''@@@@@@@@@''''@@@@@@@@@@@@@@@@@@''  >>> Opaq <<<\n''''''''''''''''''''''''''''''''''''''''''''  \n''''''''''''''''''''''''''''''''''''''''''''\n'''@@@@''''@@@@@@@@@'''''@@@@@@@@@@@@@@@@'''  tools .crinkler\n'''@@@@''''@@@@@@@@@@'''@@@@@@@@@@@@@@@@@@''        .4klang\n''@@@@@@''@@@@@@@@@@@'''@@@@@@@@@@@@@@@@@@''        .shaderminifier\n''@@@@@@''@@@@@@@@@@@'''@@@@@@@@@@@@@@@@@@''        .opengl\n''@@@@@@'''@@@@@@@@@@'''@@@@@@@@@@@@@@@@@@''\n''@@@@@@''''''''@@@@@'''@@@@@'''''''''''''''  greets\n''@@@@@@''''''''@@@@@'''@@@@@'''''''''''''''    Aberration Creations,\n''@@@@@@''''''''@@@@@'''@@@@@'''''''''''''''    Abyss, Adapt, Alcatraz,\n''@@@@@@''''''''@@@@@'''@@@@@@@@@@@@@@@@@'''    Altair, Brain Control,\n''@@@@@@''''''''@@@@@'''@@@@@@@@@@@@@@@@@@''    Dekadence, Desire, FHI,\n''@@@@@@''''''''@@@@@'''@@@@@@@@@@@@@@@@@@''    Fulcrum, Hprg, Jetlag,\n''@@@@@@''''''''@@@@@'''@@@@@@@@@@@@@@@@@@''    LJ, Nuance, Prismbeings,\n'''@@@@'''''''''@@@@''''@@@@@@@@@@@@@@@@@@''    PVM, Rabenauge, Skyrunner,\n''''''''''''''''''''''''''''''''''''''''''''    Titan & everybody we forgot!\n*/\n\n// LOW DETAILS: 8.\n// COMPO VERSION: 32.\n#define RAYS 8.\n\n #define F gl_FragCoord\n #define N normalize\n #define M(v)smoothstep(0.,1.,v)\n #define C(v)clamp(v,0.,1.)\n #define H(v)fract(sin(v)*43758.5453)\n #define U(v)floatBitsToUint(v)\n #define S float\n #define V vec3\n // uniform int v;\n // out vec4 f;\n S y,x=.005,z=1e+08,s=2.23333,c=3.582,a=3.14159,i,m,r,l;\n V k=V(1280,720,0),\n   o=V(1,-1,0);\n S n(V y)\n {\n   return abs(length(vec2(y.x,max(0.,abs(y.y)-.15)))-.25)+.4;\n }\n S t(V y)\n {\n   y=-y;\n   bool m=y.x<0.?y.y<0.:atan(y.x,y.y+.15)>2.;\n   return min(min(abs(length(vec2(max(0.,abs(y.x)-.05),y.y-.2))-.2)+.4,length(vec2(y.x+.25,max(0.,abs(y.y-.2)-.2)))+.4),m?n(y):length(vec2(y.x-.22734,y.y+.254))+.4);\n }\n S p(V y)\n {\n   return min(n(y),length(V(y.x+.25,max(0.,abs(y.y+.2)-.6),0))+.4);\n }\n S h(V y)\n {\n   return y.x=-y.x,p(y);\n }\n mat2 w(S y)\n {\n   return mat2(cos(y),-sin(y),sin(y),cos(y));\n }\n V d(S y)\n {\n   return o.xxx*.5+.5*cos(6.28318*(V(1.,.7,.4)*y*.1+V(0.,.15,.2)));\n }\n S d(S y,S x)\n {\n   S z=y*x;\n   return z*exp(1.-z);\n }\n V d(V y,V z,V m,V x)\n {\n   V s=(m-y)/z,c=(x-y)/z,o=min(s,c),a=max(s,c);\n   return V(max(max(o.x,o.y),o.z),min(min(a.x,a.y),a.z),0.);\n }\n S u(V y)\n {\n   V m=floor(y);\n   y-=m;\n   vec4 o=vec4(7,157,113,0),x=vec4(0,o.yz,o.y+o.z)+dot(m,o.xyz);\n   y=y*y*(3.-2.*y);\n   x=mix(H(x),H(x+o.x),y.x);\n   x.xy=mix(x.xz,x.yw,y.y);\n   return mix(x.x,x.y,y.z);\n }\n uint b(uvec3 y)\n {\n   y.xy=1103515245U*(y.xy>>1U^y.yx);\n   uint m=1103515245U*(y.x^y.y>>3U);\n   return m^m>>16;\n }\n V g(inout S y)\n {\n   uint s=b(U(V(y+=.1,y+=.1,0.)));\n   return V(uvec3(s,s*16807U,s*48271U)&uvec3(2147483647U))/float(2147483647);\n }\n S e(V x)\n {\n   x.y-=2.+.5*abs(sin(y));\n   S s=0.,m=z,o,i;\n   for(;s<3.;++s)\n     {\n       V l=abs(2.*V(H(s),H(s+1.),H(s+4.)));\n       i=length(x+M((y-80.)/11.)*V(cos(l.x*c*y/a),.5*cos(c*y/a),sin(l.y*c*y/a)))-.2-.5*l.z;\n       o=C(.5+.5*(i-m)/.5);\n       m=mix(i,m,o)-.5*o*(1.-o);\n     }\n   return m-.02*smoothstep(0.,1.,sin(y-2.*x.y)+.5)*u(20.*x);\n }\n S q(V y)\n {\n   if(l>0.)\n     return e(y);\n   else\n      return y.y+=.3,y.yz*=w(.114),y.xz=mod(y.xz,1.)-.5,y.y-=clamp(y.y,0.,4.),length(y)-.02;\n }\n void b(V m,V z,inout S i,out V b,out V g,out V k,out S n)\n {\n   k=o.zzz;\n   V p,t=o.yzy*6.,h=V(6,200,6),T=d(m,z,t,h),B=o*x;\n   if(T.y>0.&&T.y<i)\n     {\n       g=p=m+z*T.y;\n       i=T.y;\n       b=g.x<t.x+x?o.xzz:g.x>h.x-x?o.yzz:g.y<t.y+x?o.zxz:g.y>h.y-x?o.zyz:o.zzx;\n       S Z=M((u(10.*p)-.3)/.7),Y=min(M((u(.9*p)-.2)/.8),M(u(1.7*p)/.9)),X=step(.1,p.y),W=20.*(p.y-.1),R=.05+pow(Y*Z*M((fract(5.*p.y)-.31)/.01),.1),Q=d(fract(s*y),10.),P=X*H(floor(p.y*.1+s*y))*u(10.*V(p.y+.1*floor(.01*y*c),.1*y,p.y+.1*floor(.01*y*c)))>.5?1.:0.;\n       n=mix(min(.5+.5*Z,.02+Y),R,X);\n       k+=.5*step(W,1.)*step(0.,W);\n       if(y>30.&&y<175.)\n         k+=P,k*=Q+(y<90.||y>112.?d(5.*y+.2*p.y)*C(.01*(-p.y+50.)):o.xxx);\n     }\n   V Z=d(m,z,V(-3,.01,-3),V(3,5,3));\n   if(Z.y>0.&&Z.x>0.&&Z.x<Z.y&&Z.x<i)\n     {\n       S Y=0.,X=Z.y-Z.x;\n       V W=m+z*Z.x;\n       for(int Q=0;Q<50;Q++)\n         {\n           S P=q(W+z*Y);\n           if(abs(P)<x||Y>X)\n             break;\n           Y+=P;\n         }\n       Z.x+=Y;\n       if(Y<X&&Z.x<i)\n         {\n           n=.1-.09*l;\n           i=Z.x;\n           g=p=m+z*Z.x;\n           b=N(B.xyy*q(p+B.xyy)+B.yyx*q(p+B.yyx)+B.yxy*q(p+B.yxy)+B.xxx*q(p+B.xxx));\n           if(l>0.)\n             {\n               p.xy*=.5+4.*H(floor(s*y*2.));\n               p.xz*=w(s/8.*y);\n               S P=.8+.1*H(floor(y*s*2.));\n               k=o.xxx*M((fract(.5+2.*H(floor(y*s*2.))*(p.y+sin(p.x)*cos(p.z)))-P)/.01);\n             }\n           else\n             {\n               if(y>60.)\n                 {\n                   S P=e(p);\n                   k=o.xxx*(fract(.125*c*y)>.5?step(P,.5+M((sin(c*y/a)+.8)/1.6)):step(1.-5.*C(.1*P),.1));\n                 }\n               else\n                 {\n                   S P=.2+.2*M((cos(-c*y/a)+.7)/1.4),R=mix(7.,y,M(y-8.));\n                   V Q=p;\n                   Q.xz*=.5;\n                   Q.xz+=2.*R;\n                   k=o.xxx*C(M((abs(fract((.2+.2*M((sin(.4*R-10.)+.7)/1.4))*(Q.y+sin(Q.x)*cos(Q.z))+.5)-.5)-P)/(.15-P)));\n                 }\n             }\n           k*=r>3.?2.*step(u(floor(10.*p+s*s*y)),.1):1.;\n           k*=y<18.||y>90.&&y<112.?o.xxx:d(-10.*s*y+g.y);\n         }\n     }\n }\n\n V b(V y,V m)\n {\n   V s=o.xxx,k=o.zzz,c,p,l;\n   S P=1.,r=0.,B,Q;\n   for(;r<4.;++r)\n     {\n       Q=z;\n       b(y,m,Q,c,p,l,B);\n       if(Q<z)\n         {\n           V Z=g(i)*V(2,2.*a,1)-o.xzz;\n           S n=Z.y,R=pow(Z.z,1./3.);\n           y=p,m=N(reflect(m,c)+B*R*V(sqrt(1.-Z.x*Z.x)*V(sin(n),cos(n),0).xy,Z.x)),k+=s*l*P,P=(1.-B)*pow(C(dot(m,c)+1.),32.);\n         }\n       else\n          break;\n       if(dot(s,s)<x)\n         break;\n     }\n   return k;\n }\n\n// void main()\nvoid mainImage(out vec4 f, in vec2 fragCoord)\n{\n    f=o.zzzz;\n    k=min(k, iResolution.xyz);\n    if (fragCoord.x > k.x || fragCoord.y > k.y)\n\t\treturn;\n    // y=S(v)/44100.;\n    y = iChannelTime[0];\n    \n    if (iMouse.xy==vec2(0) && iFrame==0) // preview time\n        y=179.5;\n    \n    i=S(b(U(F.xyz)))/S(-1U)+y;\n    V x=(2.*(F.xyz+g(i)-.5)-k)/k.y;\n    r=y<17.5?0.:8.*H(fract(y/c)>=.7?y*s:0.);\n    m=y<17.3?0.:mod(s*y,4.)>2.?5.*pow(H(floor(.5*s*y)),2.):0.;\n    l=y>60.?y>112.?step(mod(y,c)/c,.5):1.:0.;\n    S P=.1+.05*y,R=.01+.4*(1.-M((y-1.)/5.)+M((y-179.)/5.)),B=H(floor(s*y));\n    vec4 Z=m>3.?vec4(-.1,1.,.5,-3.5):m>2.?vec4(1.5,1.,-.01,-.6):m>1.?vec4(.1+1.4*l,4.2,.6,-3.5):m>0.?vec4(.8+l,4.2,3.,-3.+B):vec4(1.5,11.,3.,-3.5);\n    V Q=V(Z.y*cos(P),Z.z,Z.y*sin(P)),W=N(o.zxz*Z.x-Q),u=N(cross(W,o.zxz));\n    mat3 Y=mat3(u,cross(u,W),-W);\n    V X=N(Y*V(x.xy,Z.w)),T=Q+X*length(o.zxz*Z.x-Q),w=g(i)*V(1,2.*a,0),q=F.xyz/k;\n    x*=3.;\n    x+=V(-1.5,1.5,0);\n    S e=floor(x.x),O=w.y,L=sqrt(w.x);\n    X=N(T-Q+Y*L*V(sin(O),cos(O),0)*R);\n    for(S K=0.;K<RAYS;++K)\n        f.xyz+=b(Q,X);\n    q*=1.-q.yxz;\n    x.x=fract(x.x)-.5;\n    f=vec4(pow((f.xyz/RAYS*(1.+(y>18.?.5*d(fract(s*y),10.):0.))+smoothstep(0.,1.,((-1.==e?n(x):0.==e?p(x):1.==e?t(x):2.==e?h(x):z)-.42)/-.01)*(1.-M((y-5.)/.01)+M((y-180.)/.01)))*M((y-1.)/3.)*M((y-184.)/-3.)*pow(q.x*q.y*15.,.1),V(.4545)),1.);\n}", "buffer_a_inputs": [{"id": 21956, "src": "https://soundcloud.com/josh-revilo/k2-opaq-4kb-realtime-execute-music", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdByDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1895, 1895, 1942, 1942, 2097]], "test": "untested"}
{"id": "WdSyRy", "name": "glitched marching", "author": "jemappelle", "description": "first submission to shadertoy, very much still learning. definitely credits to flopine and evvvvil for their seminar on shader coding. TY ^^b.", "tags": ["glitch"], "likes": 1, "viewed": 217, "published": 3, "date": "1586809077", "time_retrieved": "2024-07-30T21:13:06.135861", "image_code": "float opSubtract(float o0, float o1){return max(-o0,o1);}\n\nfloat opIntersection(float o0, float o1){return max(o0,o1);}\n\nfloat diffuse_directional(vec3 n, vec3 l){\n  \treturn dot(n, normalize(l))*.5 + .5;\n}\n\nfloat sphere(vec3 d, float r){\n  \t//d = mod(d, 2.)-2*0.5;  \n  \treturn length(d)-r;\n}\n\nfloat sdRoundedX(in vec2 d, in float w, in float r ){\n   \td = abs(d);\n   \treturn length(d-min(d.x+d.y,w)*0.5) - r;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h ){\n  \tconst vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  \tp = abs(p);\n  \tp.xy -= 2.0*min(dot(k.xy, p.xy), .0)*k.xy;\n  \tvec2 d = vec2(\n   \tlength(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),p.z-h.y );\n  \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat hexMap(vec3 d){\n    d = mod(d, 2.)-2.*0.5;  \n  \treturn opIntersection(-sdHexPrism(d, vec2(0.6, 1.0)), sdHexPrism(d, vec2(0.61, 1.)));\n}\n\nfloat map(vec3 d){\n  \td = mod(d, 2.)-2.*0.5;  \n  \treturn mix(sdRoundedX(d.xy, 0.3, 0.12), (sphere(d, 0.4)), cos(iTime*0.8*0.8));\n}\n\nvec3 get_normal(vec3 p){\n  \tvec2 eps = vec2(0.01,0.);\n  \treturn normalize(vec3(map(p+eps.xyy) - map(p-eps.xyy),\n    map(p+eps.yxy) - map(p-eps.yxy),  \n    map(p+eps.yyx) - map(p-eps.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv-=0.5;\n    uv/=vec2(iResolution.y/iResolution.x, 1);\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*sin(iTime+uv.xyx+vec3(0,2,4));\n \tfloat circle = smoothstep(0.05*uv.y, 0.5,length(uv.x));\n  \n  \tvec3 ro = vec3(0.+cos(iTime)/2.,0.,-8.+(iTime*4.)); \n  \tvec3 p = ro;\n  \tvec3 rd = normalize(vec3(uv,1.));\n  \n  \tbool hit = false;\n  \tbool hit2 = false;\n  \tfloat shading = 0.;\n  \n   \tfor(float i = 0.; i < 35.; i++){\n    \tfloat env = map(p);\n    \tfloat hex = hexMap(p);\n    \tfloat sp = sphere(p, 0.4);\n    \tif(hex<0.01){\n      \t\thit2 = true;\n      \t\tshading = i/50.;\n      \t\tbreak;\n    \t}\n    \t//p -= hex * rd;\n    \t//p += (env - (sin(-hex*iTime))) * rd;\n  \t}\n  \n  \tfor(float i = 0.; i < 35.; i++){\n    \tfloat env = map(p);\n    \tfloat hex = hexMap(p);\n    \tif(env<0.01){\n      \t\thit = true;\n      \t\tshading = i/100.;\n      \t\tbreak;\n    \t}\n    \tp += env * rd;\n    \t//p += (env * sin(-hex*time)) * rd;\n  \t}\n \n  \n  \t//Waving screen\n  \tuv.x += sin(uv.y*8.5)*0.5;\n  \tuv.y += sin(uv.x*8.5+iTime)*0.5;\n  \t//Screen split\n  \tuv.x = mod(uv.x, 0.2)-0.2*0.5;\n  \n  \t//Shape\n  \tfloat verLine = smoothstep(0.05, 0.2,length(uv.y+circle));\n  \n  \t//Color define\n  \tvec3 color = vec3(0.);\n  \n  \n  \t//Color from raymarch\n  \tif(hit){\n    \tvec3 n = get_normal(p);\n    \tvec3 l = vec3(0.5,2.,-2.);\n    \tcolor = get_normal(p) + vec3(shading);\n    \tcolor = mix(vec3(0.8,0.05,0.2), vec3(0.1,0.0,0.0), vec3(diffuse_directional(n,l)));\n    \thit = false;\n  \t}else if(hit2){\n    \tvec3 n = get_normal(p);\n    \tvec3 l = vec3(0.5,2.,-4.);\n    \tcolor = get_normal(p) + vec3(shading);\n    \tcolor = mix(vec3(0.65,0.65,0.7), vec3(0.1,0.0,0.0), mix(vec3(0.65,0.45,0.7), vec3(circle-verLine),\n    \tvec3(diffuse_directional(n,l))));\n    \thit2 = false;\n  \t}else{\n    \t//color = vec3(circle - verLine/shading);\n    \tcolor = vec3(circle -= atan(verLine)*iTime);\n  \t}\n  \tfloat t = length(ro*p);\n  \t//is final output for now\n  \tvec3 fog = mix(color, vec3(0.1,0.1,0.2), 1.*exp(-0.01*t*t));\n    \n  \tfragColor = vec4(fog, 1.) + vec4((color + circle / 1.5), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdSyRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 57], [59, 59, 100, 100, 119], [121, 121, 163, 163, 205], [207, 207, 237, 266, 291], [293, 293, 346, 346, 409], [411, 411, 446, 446, 712], [714, 714, 735, 735, 855], [857, 857, 875, 875, 987], [989, 989, 1013, 1013, 1180], [1182, 1182, 1239, 1286, 3349]], "test": "untested"}
{"id": "WsByzG", "name": "#724 - Daily Experiments", "author": "sixclones", "description": "One more day.", "tags": ["2d", "experiment", "daily", "everyday"], "likes": 5, "viewed": 214, "published": 3, "date": "1586804949", "time_retrieved": "2024-07-30T21:13:06.906800", "image_code": "/* Code by Sixclones\n\nMy boilerplate: https://www.shadertoy.com/view/wdsyzH */\n\n#define E 0.000001\n#define QP 0.785398163397448\n#define TRP 1.047197551196598\n#define HP 1.570796326794897\n#define P 3.141592653589793\n#define TP 6.283185307179586\n\n#define t iTime\n#define ht 0.5 * t\n#define tt 0.1 * t\n\n#define S(a, b, t) smoothstep(a, b, t)\n\nfloat map(float n, float start1, float stop1, float start2, float stop2) {\n  return (n - start1) / (stop1 - start1) * (stop2 - start2) + start2;\n}\n\nfloat map01(float n) {\n  return 0.5 * n + 0.5;\n}\n\nvec2 rotate2d(vec2 uv, float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a)) * uv;\n}\n\nfloat circleSDF(vec2 uv) {\n  return 2.0 * length(uv);\n}\n\nfloat rectSDF(vec2 uv, vec2 s) {\n  return 2.0 * max(abs(uv.x / s.x), abs(uv.y / s.y));\n}\n\nfloat fill(float x, float s, float p) {\n  p *= 0.1;\n  return 1.0 - S(s - p, s + p, x);\n}\n\nvoid mainImage(out vec4 FragColor, in vec2 FragCoord) {\n  vec4 uv = vec4(FragCoord.xy / iResolution.xy,\n    (FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y);\n  vec2 m = iMouse.xy / iResolution.xy;\n\n  float n = 8.0;\n  vec2 gv = fract(n * uv.xy);\n  vec2 id = floor(n * uv.xy);\n\n  vec3 color = vec3(0.0);\n  vec3 black = vec3(0.129);\n  vec3 white = vec3(0.925);\n  vec3 pal1 = vec3(0.95, 0.22, 0.31);\n  vec3 pal2 = vec3(0.21, 0.24, 0.63);\n\n  // ANIM\n  float speed = 0.75 * t;\n  // speed = 2.0 * m.x; // debug\n  /** ^ `x`\n      |      /\\            /\\            /\\            /\\      \n      |    /    \\        /    \\        /    \\        /    \\    \n      |  /        \\    /        \\    /        \\    /        \\  \n      |/____________\\/____________\\/____________\\/____________\\> `time` */\n  float timer = fract(mix(speed, -speed, step(1.0, mod(speed, 2.0))));\n\n  // SHAPES\n  // angle of the break\n  float angle = map(S(0.2, 0.8, fract(speed)), 0.0, 1.0, 3.0 * TP, 0.0) - QP;\n  // break between the two shapes\n  float breaker = step(0.0, rotate2d(uv.zw, angle).x);\n  // mix the shapes and the palettes\n  float mixer = S(0.45, 0.55, timer);\n\n  // BACKGROUND\n  // rotated uv\n  vec2 rv = rotate2d(uv.zw, -HP - QP);\n  // switch the bounds to change the direction of the rotation\n  vec2 bounds = mix(\n    vec2(1.0, E), vec2(E, 1.0),\n    step(1.0, mod(speed, 2.0))\n  );\n  // MIXERS - mix shapes, colors and background based on time\n  vec2 mixers = vec2(\n    S(0.45, 0.55, timer),\n    S(\n      S(0.5, 1.0, S(0.45, 0.65, timer)),\n      S(0.0, 0.5, S(0.25, 0.9, timer)),\n      map(atan(rv.y, rv.x), -P, P, bounds.x, bounds.y)\n    )\n  );\n\n  /* firstly compute the two sdf, circle and rectangle\n  then mix/interpolate them into a shape\n  finaly morph two values over time\n  */\n  // SDF\n  float circ = circleSDF(uv.zw);\n  float rect = rectSDF(uv.zw, vec2(1.0));\n  float shape = mix(circ, rect, mixers.x);\n  float shadow = rectSDF(rotate2d(uv.zw, angle), vec2(0.02, 0.25));\n  // FIILS\n  vec2 p = vec2(\n    0.1,\n    map(\n      S(0.4, 0.6, 2.0 * fract(mix(speed, -speed, step(0.5, mod(speed, 1.0))))),\n      0.0, 1.0,\n      1.75, 4.5\n    )\n  ); // precisions\n  // compute the fill of the two shapes, the sharp and the blurry7\n  vec2 shapefs = vec2(fill(shape, 0.5, p.x), fill(shape, 0.5, p.y));\n  // combine the two shapes to get this slashed render\n  float shapef = mix(shapefs.x, shapefs.y, breaker); // main effect\n  // compute the shadow\n  float shadowf = 0.125 * fill(shadow, 1.0, 51.0 * p.y);\n  color = mix(\n    mix(white, black, mixers.y),\n    mix(pal1, pal2, mixers.x) * shapef,\n    shapef\n  );\n  // add more depth with a shadow\n  color -= shapef * mix(shadowf, 0.0, breaker);\n\n  FragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsByzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[340, 340, 414, 414, 486], [488, 488, 510, 510, 536], [538, 538, 571, 571, 626], [628, 628, 654, 654, 683], [685, 685, 717, 717, 773], [775, 775, 814, 814, 863], [865, 865, 920, 920, 3568]], "test": "untested"}
{"id": "3sByzG", "name": "Implicit destination", "author": "gambhiro", "description": "Abstract raymarching", "tags": ["abstract"], "likes": 4, "viewed": 417, "published": 3, "date": "1586804556", "time_retrieved": "2024-07-30T21:13:07.694693", "image_code": "#define i_time iTime\n#define i_resolution iResolution\n\nfloat tt;\nvec3 ap, bp;\nfloat attr;\n\nmat2 rot2(float r) {\n  return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nfloat sd_cylinder(vec3 p, float r, float height) {\n  float d = length(p.xz) - r;\n  d = max(d, abs(p.y) - height);\n  return d;\n}\n\nfloat sd_box(vec3 p, vec3 b) {\n  vec3 q  = abs(p) - b;\n  return max(max(q.x, q.y), q.z);\n}\n\nfloat spiral(vec3 p) {\n  vec3 q = p - vec3(.0, 2.5, .0);\n  q.y *= 0.04;\n  q.xz *= rot2((sin(q.y + 3.0)-tt*.05)*20.0);\n  q.yz *= rot2(radians(20.0));\n  q.y *= 0.18;\n  q = abs(q) - vec3(0.3, -.55, 3.0);\n  q -= vec3(.5, .05, 0.);\n  float d = length(q) - .7;\n  return d*0.5;\n}\n\nvec2 rails(vec3 p) {\n  vec3 q = p;\n\n  q.y -= .4;\n  q = abs(q) - vec3(1.2, .2, 0.);\n  vec2 a = vec2(sd_box(q, vec3(.1, .3, 20.)), 1.0);\n\n  q = p;\n  q.z = abs(q.z) - 2.0;\n  q.xy *= rot2(radians(90.0));\n  vec2 b = vec2(sd_cylinder(q - vec3(.8, 0, 0), 0.2, 5.), 1.0);\n\n  a = (a.x < b.x) ? a : b;\n\n  a.x *= 0.8;\n  return a;\n}\n\nvec2 map(vec3 p) {\n  attr = max(0.0, (6.0 - (length(p + vec3(0., 0., 1.0-tt*2.5)) - 6.0)));\n\n  vec3 q = p;\n  vec2 a = vec2(length(q - vec3(0., 0., 10. + tt*2.5)) - 2.5, 2.0);\n\n  q = p;\n  q.z = mod(q.z - 1.0, 11.0);\n  q = abs(q) - vec3(0., 6., 11.);\n  for (int i=0; i<6; i++) {\n    q = abs(q) - vec3(2.0, 0.0, 0.5);\n    //q.xz *= rot2(radians(i*5));\n    q.xy *= rot2(radians(4.+float(i)*1.5));\n  }\n\n  vec2 b = rails(q);\n\n  a = (a.x < b.x) ? a : b;\n\n  float s = sin(tt*.5)*2.0 +  + 1.5;\n  float ss = cos(tt*.5)*2.0 +  + 1.5;\n  q = abs(q) - vec3(s, ss*2.0, 0.);\n  b = rails(q);\n\n  a = (a.x < b.x) ? a : b;\n\n  q = p;\n  q.yz *= rot2(radians(90.0));\n  b = vec2(spiral(q), 1.0);\n\n  a = (a.x < b.x) ? a : b;\n\n  return a;\n}\n\nvec2 trace(vec3 ro, vec3 rd) {\n  vec2 h, t = vec2(0.1);\n  for (int i=0; i<128; i++) {\n    h = map(ro+rd*t.x);\n    if (h.x < .0001 || t.x > 50.0) break;\n    t.x += h.x;\n    t.y = h.y;\n  }\n  if (t.x > 50.0) t.x = 0.0;\n  return t;\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n  vec2 uv = vec2(frag_coord.x / i_resolution.x, frag_coord.y / i_resolution.y);\n  uv -= 0.5;\n  uv /= vec2(i_resolution.y / i_resolution.x, 1);\n\n  tt = i_time*0.5;\n\n  vec3 ro = vec3(0., 1., -20.);\n  ro.z += tt*2.5;\n  // ro.xz *= rot2(tt*.5);\n\n  vec3 cam_target = vec3(0, 5, 0);\n  cam_target.z += tt*2.5;\n\n  vec3 cw = normalize(cam_target - ro);\n  vec3 cu = normalize(cross(cw, vec3(0,1,0)));\n  vec3 cv = normalize(cross(cu, cw));\n\n  vec3 rd = mat3(cu, cv, cw) * normalize(vec3(uv, 0.5));\n\n  vec3 ld = normalize(vec3(.3, .5, -.5));\n\n  // Fibonacci Blue #112358, R: 17, G: 35 B: 88\n\n  vec3 fog = vec3(.066, .137, .345) * (1.0 - (length(uv)-0.2));\n  vec3 col = fog;\n\n  vec2 scene = trace(ro, rd);\n  float t = scene.x;\n\n  if (t > 0.0) {\n    vec3 pp = ro+rd*t;\n\n    vec2 e = vec2(.00035, -.00035);\n    vec3 nor = normalize(e.xyy*map(pp+e.xyy).x +\n                         e.yyx*map(pp+e.yyx).x +\n                         e.xyx*map(pp+e.xyx).x +\n                         e.xxx*map(pp+e.xxx).x);\n\n    vec3 b0 = vec3(.1, .5, .8);\n    vec3 b1 = vec3(0.7, .8, .8);\n    vec3 base = mix(b0, b1, attr);\n\n    if (scene.y == 1.0) {\n\n      float diff = max(0., dot(nor, ld));\n\n      float aor = t/30.;\n      float ao = exp2(-2.*pow(max(0.,1.-map(pp+nor*aor).x/aor),2.));\n\n      float fr = pow(1.+dot(nor,rd),2.);\n\n      vec3 sss = vec3(0.5)*smoothstep(0.,1.,map(pp+ld*0.4).x/0.4);\n\n      col = base*(0.9*ao+0.2)*(diff+sss);\n      col = mix(col, b0, min(fr, 0.2));\n\n    }\n\n    col = mix(col, fog, 1.0 - exp(-.00005*t*t*t));\n\n    if (scene.y == 2.0) {\n      float fr = pow(1.+dot(nor,rd),5.);\n      col = mix(vec3(0.), base, min(fr, 0.8));\n    }\n\n  }\n\n  frag_color = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sByzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 91, 111, 111, 161], [163, 163, 213, 213, 290], [292, 292, 322, 322, 382], [384, 384, 406, 406, 656], [658, 658, 678, 678, 978], [980, 980, 998, 998, 1694], [1696, 1696, 1726, 1726, 1925], [1927, 1927, 1984, 1984, 3650]], "test": "untested"}
{"id": "3dSyzG", "name": "coffee and code challenge", "author": "adamburr", "description": "challenge: recreate https://www.instagram.com/p/B3dHAHCHSrv/\nvia: @DmC", "tags": ["coffee"], "likes": 2, "viewed": 262, "published": 3, "date": "1586801058", "time_retrieved": "2024-07-30T21:13:08.669088", "image_code": "// challenge: recreate https://www.instagram.com/p/B3dHAHCHSrv/\n// via: @DmC\n\n// easter colors:\nvec3 colorA = vec3(1., .4, .8);\nvec3 colorB = vec3(.8, 1., .4);\nvec3 colorC = vec3(.4, .8, 1.);\nconst float shade = .2;\n\n// animation:\nconst float persp = .9;\nconst float spin = .7;\nconst float dolly = .04;\n\n// constants:\nconst float pi = asin(1.);\nconst float bgDepth = 1e16;\n\nstruct Cylinder {\n    vec3 centers[2];\n    float radius;\n};\n\nstruct Ray {\n    vec3 position;\n    vec3 direction;\n};\n\nvoid hitPlane(vec3 position, vec3 normal, Ray ray, out float depth, out bool front)\n{\n    float nd = dot(normal, ray.direction);\n    depth = dot(position - ray.position, normal) / nd;\n    front = nd < 0.;\n}\n\nvoid hitCylinder(Cylinder cylinder, Ray ray, out float depth, out int faceId)\n{\n    // quadratic ray-cylinder intersection solve:\n    vec3 dir = normalize(cylinder.centers[0] - cylinder.centers[1]);\n    vec3 v0 = ray.position - cylinder.centers[0];\n    vec3 v1 = ray.direction - dot(ray.direction, dir) * dir;\n    vec3 v2 = v0 - dir * dot(v0, dir);\n    float a = dot(v1, v1);\n    float b = dot(v1, v2) * 2.;\n    float c = dot(v2, v2) - cylinder.radius * cylinder.radius;\n    float desc = b * b - 4. * a * c;\n    float sqrtDesc = sqrt(desc);\n    float d = .5 / a;\n    depth = desc > 0. ? (-b - sqrtDesc) * d : bgDepth;\n    float backDepth = desc > 0. ? (-b + sqrtDesc) * d : bgDepth;\n\n    // end caps:\n    faceId = 0;\n    for (int i = 0; i < 2; ++i) {\n        float hitDepth;\n        bool front;\n        hitPlane(cylinder.centers[i], dir, ray, hitDepth, front);\n        if (front != bool(i)) {\n            if (backDepth < hitDepth) {\n                depth = bgDepth;\n            } else if (depth < hitDepth) {\n                depth = hitDepth;\n                faceId = i + 1;\n            }\n        } else if (depth > hitDepth) {\n            depth = bgDepth;\n        }\n    }\n}\n\nvec4 shadeScene(vec2 uv)\n{\n    // spin angle:\n    float angle = iTime * spin + pi * .5;\n    float sinAngle = sin(angle);\n    float cosAngle = cos(angle);\n    bool phase = sinAngle > 0.;\n    \n    // camera dolly:\n    float dollyTime = iTime * iTime * dolly + 1.;\n\n    // this does the crazy ortho/persp blending:\n    Ray ray;\n    ray.position = vec3(uv * dollyTime, 0.);\n    float lens = abs(sinAngle); // <- this\n    ray.direction = normalize(vec3(uv * persp * lens, 1.));\n\n    // tiling selects which cylinders are drawn:\n    vec2 tile = floor((ray.position.xy - vec2(0., float(phase))) * .5 + .5);\n    vec3 tileCenter = vec3(tile * 2. + vec2(0., float(phase)), 0.);\n    \n    // draw 4 cylinders around empty center hole:\n    Cylinder cylinder;\n    cylinder.radius = .5;\n    float depth = bgDepth;\n    int colorId;\n    for (int dir = 0; dir < 2; ++dir) { // x or y\n        float endOffsetZ = bool(dir) == phase ? -sinAngle : sinAngle;\n        vec3 endOffset = vec3(0., cosAngle, endOffsetZ) * .5;\n        for (int sign = 0; sign < 2; ++sign) { // - or +\n            // draw a cylinder:\n            vec3 cylinderOffset = vec3(0.);\n            cylinderOffset[dir] = float(sign * 2 - 1);\n            cylinder.centers[0] = tileCenter + cylinderOffset + endOffset;\n            cylinder.centers[1] = tileCenter + cylinderOffset - endOffset;\n            float hitDepth;\n            int faceId;\n            hitCylinder(cylinder, ray, hitDepth, faceId);\n            // depth composite:\n            if (hitDepth < depth) {\n                depth = hitDepth;\n                colorId = faceId;\n            }\n        }\n    }\n\n    // colors:\n    vec3 modelColor = bool(colorId % 3) ? colorC : (phase ? colorB : colorA);\n    vec3 bgColor = phase ? colorA : colorB;\n\n    // depth lighting:\n    float light = mix(1., .5 - depth, shade);\n    float fill = 1. - shade * .5;\n    modelColor *= mix(fill, light, lens);\n    bgColor *= fill;\n\n    // final comp:\n    return vec4(depth < bgDepth ? modelColor : bgColor, 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // supersampling:\n    const int samplesSqrt = 2;\n    float xyScale = 1. / iResolution.y;\n    vec2 xy = (fragCoord.xy - iResolution.xy * .5) * xyScale;\n    float xyStep = xyScale / float(samplesSqrt);\n    fragColor = vec4(0.);\n    for (int i = 0; i < samplesSqrt; ++i) {\n        for (int j = 0; j < samplesSqrt; ++j) {\n            vec2 uv = xy + vec2(i, j) * xyStep - xyScale * .5;\n            fragColor += shadeScene(uv);\n        }\n    }\n    fragColor *= 1. / fragColor.a;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dSyzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[491, 491, 576, 576, 697], [699, 699, 778, 828, 1873], [1875, 1875, 1901, 1920, 3874], [3876, 3876, 3931, 3953, 4410]], "test": "untested"}
{"id": "tsjyDm", "name": "Weighted Normal Blending", "author": "Donzanoid", "description": "Weighted normal blending using @ZigguraVertigo test shader.", "tags": ["normals"], "likes": 7, "viewed": 470, "published": 3, "date": "1586793319", "time_retrieved": "2024-07-30T21:13:09.575664", "image_code": "\nvec4 RotationBetween(vec3 v0, vec3 v1)\n{\n    // Shortest arc\n    float d = dot(v0, v1);\n    float s = sqrt((1.0 + d) * 2.0);\n    float invs = 1.0 / s;\n    vec3 c = cross(v1, v0);\n    return vec4(c.xyz * invs, 0.5 * s);\n}\n\nvec4 RotationFromZ(vec3 v1)\n{\n    // Shortest arc from <0, 0, 1>\n    int x = floatBitsToInt(2.0 + v1.z * 2.0);\n    //x = 0x1FBD1DF5 + (x >> 1);\n    // rsqrt from Robin's new math paper, allows one less div\n    x = 0x5F37624F - (x >> 1);\n    float s = intBitsToFloat(x);\n    //return vec4(v1.y / s, -v1.x / s, 0.0, 0.5 * s);\n    return vec4(v1.y * s, -v1.x * s, 0.0, 0.5 / s);\n}\n\nvec4 nlerp(vec4 q0, vec4 q1, float t)\n{\n    return normalize(mix(q0, q1, t));\n}\n\nvec4 fnlerp(vec4 l, vec4 r, float t)\n{\n\tfloat ca = dot(l, r);\n\tfloat k = 0.931872f + ca * (-1.25654f + ca * 0.331442f);\n\tfloat ot = t + t * (t - 0.5f) * (t - 1.0) * k;\n    return normalize(mix(l, r, ot));\n}\n\nvec4 slerp(vec4 a, vec4 b, float t)\n{\n    // Get half-angle between quaternions\n    float cos_theta = clamp(dot(a, b), -1.0, 1.0);\n    float theta = acos(cos_theta);\n    float sin_theta = sqrt(1.0 - cos_theta * cos_theta);\n\n    // Slerp\n    float t0 = sin((1.0 - t) * theta) / sin_theta;\n    float t1 = sin(t * theta) / sin_theta;\n    vec4 r;\n    r.x = a.x * t0 + b.x * t1;\n    r.y = a.y * t0 + b.y * t1;\n    r.z = a.z * t0 + b.z * t1;\n    r.w = a.w * t0 + b.w * t1;\n    return r;\n}\n\nvec3 Transform(vec4 q, vec3 v)\n{\n    return v * (q.w * q.w - dot(q.xyz, q.xyz)) + 2.0 * q.xyz * dot(q.xyz, v) + 2.0 * q.w * cross(q.xyz, v);\n    //return v + 2.0 * cross(q.xyz, q.w * v + cross(q.xyz, v));\n}\n\nvec3 TransformZ(vec4 q)\n{\n    // Transforming <0,0,1> by q where q.z = 0 for tangent-space normal\n    vec3 r;\n    r.x = -2.0 * q.w * q.y;\n    r.y =  2.0 * q.w * q.x;\n    r.z =  q.w * q.w - dot(q.xy, q.xy);\n    return r;\n    \n    // c = cross(a, b)\n    // c.x = a.y * b.z - b.y * a.z\n    // c.y = a.z * b.x - b.z * a.x\n    // c.z = a.x * b.y - b.x * a.y\n}\n\nvec3 NormalBlend(vec3 n1, vec3 n2, float t)\n{\n    n1 = n1 * 2.0 - 1.0;\n    n2 = n2 * 2.0 - 1.0;\n    \n    //return n1;\n    \n    //return normalize(mix(n1, n2, 0.8));\n    \n    #if 1\n    \n    //vec4 q1 = RotationBetween(vec3(0.0, 0.0, 1.0), n1);\n    vec4 q1 = RotationFromZ(n1);\n        \n    //vec4 q2 = RotationBetween(vec3(0.0, 0.0, 1.0), n2);\n    vec4 q2 = RotationFromZ(n2);    \n    \n    vec4 qa = nlerp(q1, q2, t);\n    vec4 qb = fnlerp(q1, q2, t);\n    vec4 qc = slerp(q1, q2, t);\n    \n    //vec4 d = qc - qb;\n    //return vec3(abs(dot(d, d)) * 10000.0);\n    \n    //return Transform(qa, vec3(0.0, 0.0, 1.0));\n    return TransformZ(qa);\n    \n    #else\n    \n    vec4 q = RotationBetween(n1, n2);\n    \n    //vec4 qr = slerp(vec4(0.0, 0.0, 0.0, 1.0), q, 0.2);\n    vec4 qr = nlerp(vec4(0.0, 0.0, 0.0, 1.0), q, 1 - t);\n    \n    if (abs(qr.w) < 0.001) return vec3(1.0);\n    \n    //qr.z = 0.0;\n    \n    vec3 p = Transform(qr, n2);\n    \n    return p;\n    \n    #endif\n}\n\n\n// Compute base normal (since we don't have a texture)\nvec3 ComputeBaseNormal(vec2 uv) \n{\n    uv = fract(uv) * 2.0 - 1.0;    \n        \n    vec3 ret;\n    ret.xy = sqrt(uv * uv) * sign(uv);\n    ret.z = sqrt(abs(1.0 - dot(ret.xy,ret.xy)));\n    \n    ret = ret * 0.5 + 0.5;\n    return mix(vec3(0.5,0.5,1.0), ret, smoothstep(1.0,0.95,dot(uv,uv)));\n}\n\n// Compute a detail normal (since we don't have a texture)\nvec3 ComputeDetailNormal(vec2 uv)\n{\n    const vec4 avgRGB0 = vec4(1.0/3.0, 1.0/3.0, 1.0/3.0, 0.0);\n    const float scale = 0.02;\n    const vec2 du = vec2(1.0/512.0, 0.0);\n    const vec2 dv = vec2(0.0, 1.0/512.0);\n\n    float h0  = dot(avgRGB0, texture(iChannel0, uv)) * scale;\n    float hpx = dot(avgRGB0, texture(iChannel0, uv + du)) * scale;\n    float hmx = dot(avgRGB0, texture(iChannel0, uv - du)) * scale;\n    float hpy = dot(avgRGB0, texture(iChannel0, uv + dv)) * scale;\n    float hmy = dot(avgRGB0, texture(iChannel0, uv - dv)) * scale;\n    \n    float dHdU = (hmx - hpx) / (2.0 * du.x);\n    float dHdV = (hmy - hpy) / (2.0 * dv.y);\n    \n    return normalize(vec3(dHdU, dHdV, 1.0)) * 0.5 + 0.5;\n}\n//---------------------------------------------------------------------------------------------\n// Main\n//---------------------------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 uv = fragCoord.xy / iResolution.x;\n    \n    //---------------------------------------------------------------------------------------------------------\n    // [LEFT SIDE] - Combined normal, switches between technique\n    //---------------------------------------------------------------------------------------------------------\n    // Base Normal (Disk)\n    vec2 uvN = uv * (iResolution.x / iResolution.y) * 1.2 - vec2(0.12, 0.16);\n\n  \tvec3 BN = vec3(0.5, 0.5, 1.0);\n    if (uvN.x > 0.0 && uvN.x < 0.83 && uvN.y < 0.83 && uvN.y > 0.0)\n    {\n        BN = ComputeBaseNormal(uvN * vec2(1.2,1.2));\n    }\n    \n    // Detail Normal\n\tvec2 uvDN = uvN;\n    vec3 n1 = ComputeDetailNormal(uvDN);\n    \n    float t = 0.5;\n    t = fract(iTime * 0.1);\n \n\t// Combined Normal\n    vec3 N = NormalBlend(BN, n1, t);\n\n    //---------------------------------------------------------------------------------------------------------\n    // [RIGHT SIDE] - Combined normal with lighting, switches between technique\n    //---------------------------------------------------------------------------------------------------------\n    // Base Normal (Disk)\n    uvN = (uv + vec2(0.28, 0.0)) * (iResolution.x / iResolution.y) * 1.2 - vec2(0.12, 0.16);\n\n  \tBN = vec3(0.5, 0.5, 1.0);\n    if (uvN.x > 1.66 && uvN.y > 0.0 && uvN.y < 0.83 && uvN.x < 2.50)\n    {\n        BN = ComputeBaseNormal(uvN * vec2(1.2,1.2));\n    }\n    \n    // Detail Normal\n\tuvDN = uvN+vec2(0.33,0);\n    n1 = ComputeDetailNormal(uvDN);\n \n\t// Combined Normal\n    vec3 N2 = NormalBlend(BN, n1, t);\n   \t\n\tvec3 light = normalize(vec3(1.0, 0.0, 1.0));    \n    vec3 lit = vec3(clamp(dot(light, N2), 0.0, 1.0));\n\n    // Mix normal and lit result\n\tvec3 color = mix(N*0.5 + 0.5, lit, float(uv.x > 0.5));\n\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjyDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 41, 61, 221], [223, 223, 252, 287, 600], [602, 602, 641, 641, 681], [683, 683, 721, 721, 889], [891, 891, 928, 970, 1373], [1375, 1375, 1407, 1407, 1581], [1583, 1583, 1608, 1680, 1937], [1939, 1939, 1984, 1984, 2899], [2902, 2957, 2991, 2991, 3245], [3247, 3306, 3341, 3341, 4008], [4009, 4209, 4265, 4265, 6040]], "test": "untested"}
{"id": "ts2cWm", "name": "Primitive Portrait", "author": "yx", "description": "Released in the 4k Executable Graphics compo at Revision 2020. Placed 6th of 16 entries.\n\nDownload the executable version here: [url]https://www.pouet.net/prod.php?which=85265[/url]\n\nNote: All comments on how to minify the shader further will be deleted.", "tags": ["exegfx"], "likes": 140, "viewed": 6256, "published": 3, "date": "1586792222", "time_retrieved": "2024-07-30T21:13:10.500192", "image_code": "mat2 rotate(float a){\n    float c=cos(a),s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdRect(vec2 p, vec2 r)\n{\n    p=abs(p)-r;\n    return max(p.x,p.y);\n}\n\nfloat sdf(vec2 p)\n{\n    float d=1e9;\n    d=min(d,sdRect(p-vec2(3),vec2(7,1)));\n    d=min(d,sdRect(p-vec2(3),vec2(1,7)));\n    d=min(d,sdRect(p+vec2(3),vec2(1,7)));\n    d=min(d,sdRect(p+vec2(6,3),vec2(4,1)));\n    d=min(d,sdRect(p+vec2(9),vec2(1)));\n    d=min(d,sdRect(p-vec2(9),vec2(1)));\n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\tvec4 tex=texelFetch(iChannel0,ivec2(fragCoord),0);\n\n\t// divide by sample-count\n\tvec3 color=tex.rgb/tex.a;\n    \n    // each grayscale light is in a separate color channel\n    // so I can adjust the balance in post here\n    // comment this out for pretty debug colors\n    vec3 weights = vec3(1.5,.2,.2);\n    weights /= dot(weights,vec3(1));\n    color = vec3(dot(color,weights));\n    \n\t// vignette to darken the corners\n\tuv-=.5;\n\tcolor *= 1.-dot(uv,uv)*.8;\n\n    // exposure and tonemap\n    color *= 2.5;\n    color = 1.-exp(color*-2.);\n\n\t// gamma correction\n\tcolor = pow(color, vec3(.45));\n    \n    // raise the black level slightly\n    color = color*.98+.02;\n\n    // \"final\" color\n    fragColor = vec4(vec3(color),1);\n    \n\t// set up for logo overlay\n    uv.x*=iResolution.x/iResolution.y;\n    uv -= vec2(.8888,-.5); // assumes 16:9\n    uv *= 720.;\n    uv += vec2(20,-20);\n\tfloat threshold = abs(dFdx(uv.x)*.5);\n\tuv+=vec2(8,0);\n    uv*=rotate(acos(-1.)*.25);\n\n    // logo overlay\n\tfragColor.rgb *= smoothstep(-threshold,threshold,sdf(uv))*.2+.8;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define pi acos(-1.)\n\nmat2 rotate(float b)\n{\n    float c = cos(b),s = sin(b);\n    return mat2(c,-s,s,c);\n}\n\nvec2 hash2(float n) {\n\treturn fract(sin(vec2(n,n+1.))*vec2(43758.5453123));\n}\n\nfloat sdIcosahedron(vec3 p, float r)\n{\n    const float q = (sqrt(5.)+3.)/2.;\n\n    const vec3 n1 = normalize(vec3(q,1,0));\n    const vec3 n2 = vec3(sqrt(3.)/3.);\n\n    p = abs(p);\n    float d = dot(p, n2.xyz);\n    p=p*n1.x+p.yzx*n1.y;\n    return max(max(p.x,p.y),max(p.z,d))-n1.x*r;\n}\n\nfloat sdOctahedron(vec3 p, float r)\n{\n    return (dot(abs(p),vec3(1))-r)/sqrt(3.);\n}\n\nfloat sdDodecahedron(vec3 p, float r)\n{\n\tconst float phi = (1.+sqrt(5.))*.5;\n    p = abs(p);\n    p += phi*p.zxy;\n    return (max(max(p.x,p.y),p.z)-r*phi) / sqrt(phi*phi+1.);\n}\n\nstruct prim_t {\n    vec3 pos;\n    float size;\n    float rxy;\n    float ryz;\n};\n\n// where the magic numbers live:\nconst prim_t icosa[]=prim_t[](\n\tprim_t(vec3(3.36,-.23,0),1.2,-.65,0.),\n\tprim_t(vec3(2.0,-1.,0),.71,.2,0.),\n\tprim_t(vec3(1.2,-3.1,0),.71,-.08,0.),\n\tprim_t(vec3(1.75,1.36,-.2),.63,0.,0.03)\n    \n    // not necessary for the shadow effect,\n    // added late for aesthetic reasons\n\t,prim_t(vec3(4.1,1.66,0),.3,0.,0.0)\n\t,prim_t(vec3(5.8,-.2,0),.3,7.,0.0)\n);\nconst prim_t dodec[]=prim_t[](\n\tprim_t(vec3(.97,-1.55,0),.55,-.05,0.),\n\tprim_t(vec3(.90,-1.95,0),.51,.0,0.),\n\tprim_t(vec3(2.2,2.1,.2),1.2,.0,.08),\n\tprim_t(vec3(1.45,-2.4,0),.7,0.,0.)\n    \n    // see earlier comment\n\t,prim_t(vec3(3.0,-2.4,0),.4,.3,0.)\n);\nconst prim_t octah[]=prim_t[](\n\tprim_t(vec3(.68,3.2,0),1.05,0.,-.47),\n\tprim_t(vec3(.5,-3.75,0),.8,0.,.45),\n\tprim_t(vec3(.8,.93,0),.8,0.,.72),\n\tprim_t(vec3(.18,-2.2,0),.4,1.5,0.5),\n\tprim_t(vec3(.2,-2.6,0),.5,0.,0.5)\n);\n\nvec3 primTransform(vec3 p, prim_t b) {\n\tp-=b.pos;\n    p.xy*=rotate(b.rxy);\n    p.yz*=rotate(b.ryz);\n    return p;\n}\n\nfloat scene(vec3 p)\n{\n    float d = 1e9;\n    \n    float ground = -p.z;\n    if (abs(ground)<.01){\n    \t// plaster wall surface, just two octaves of subtle noise\n    \tground -= texture(iChannel1,p.xy*.125).r*.0025;\n    \tground -= texture(iChannel1,p.xy*.25).r*.0025;\n    }\n\n    // avoid evaluating expensive geometry if possible\n    if (p.x > -2. && p.x < 6.5 && abs(p.y) < 5.) {\n        for(int i=0;i<6;++i){\n            d=min(d,sdIcosahedron(\n                primTransform(p,icosa[i]),\n                icosa[i].size\n            ));\n        }\n        for(int i=0;i<5;++i){\n            d=min(d,sdDodecahedron(\n                primTransform(p,dodec[i]),\n                dodec[i].size\n            ));\n        }\n        for(int i=0;i<5;++i){\n            d=min(d,sdOctahedron(\n                primTransform(p,octah[i]),\n                octah[i].size\n            ));\n        }\n    }\n    \n    return min(d,ground);\n}\n\nvec2 rv2;\n\nvec3 ortho(vec3 a){\n    vec3 b=cross(vec3(-1,-1,.5),a);\n    // assume b is nonzero\n    return (b);\n}\n\n// various bits of lighting code \"borrowed\" from \n// http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec3 getSampleBiased(vec3  dir, float power) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = rv2;\n\tr.x=r.x*2.*pi;\n\tr.y=pow(r.y,1.0/(power+1.0));\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nvec3 getConeSample(vec3 dir, float extent) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r =  rv2;\n\tr.x=r.x*2.*pi;\n\tr.y=1.0-r.y*extent;\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nvec3 sky(vec3 viewDir) {\n    float toplight = step(.5, dot(viewDir,vec3(0,1,-.2)));\n    float sidelight = step(.5, dot(viewDir,normalize(vec3(1,0,-1))));\n    return vec3(0,toplight,sidelight);\n}\n\nbool trace5(vec3 cam, vec3 dir, float EPS, out vec3 h, out vec3 n, out float k) {\n\tfloat t=0.;\n    for(int i=0;i<100;++i)\n    {\n        k = scene(cam+dir*t);\n        t += k;\n        if (abs(k) < EPS)\n            break;\n    }\n\n    h = cam+dir*t;\n\t\n    // if we hit something\n    if(abs(k)<EPS)\n    {\n        vec2 o = vec2(EPS, 0);\n        k=scene(h);\n        n = normalize(vec3(\n            scene(h+o.xyy),\n            scene(h+o.yxy),\n            scene(h+o.yyx) \n        )-k);\n        return true;\n    }\n    return false;\n}\n\nvec3 trace2(vec3 cam, vec3 dir)\n{\n    const vec3 sunPos = vec3(20,0,-5);\n    const float sunSize = 1e-3;\n    vec3 sunColor = vec3(1,0,0);\n    \n    vec3 accum = vec3(1);\n    vec3 direct = vec3(0);\n    for(int ibounce=0;ibounce<5;++ibounce)\n    {\n        vec3 h,n;\n        float k;\n        if (trace5(cam,dir,.001,h,n,k))\n        {\n            cam = h+n*.002;\n            dir=getSampleBiased(n,1.);\n             \n            vec3 sunDirection = sunPos-h;\n            vec3 sunSampleDir = getConeSample(sunDirection,sunSize);\n            float sunLight = dot(n, sunSampleDir);\n            vec3 dummy0,dummy1;\n            float dummy2;\n            if (sunLight>0.0 && !trace5(h + n*.01,sunSampleDir,.01,dummy0,dummy1,dummy2)) {\n                direct += accum*sunLight*sunColor;\n            }\n            rv2=hash2(rv2.y);\n        }\n        else if (abs(k) > .1) {\n            return direct + sky(dir) * accum;\n        } else {\n            break;\n        }\n    }\n    \n    // deliberately fail the pixel\n    return vec3(-1.);\n}\n\nvec2 bokeh(){\n\tvec2 a=rv2;\n    if(a.y>a.x)\n        a=1.-a;\n    a.y*=pi*2./a.x;\n    return a.x*vec2(cos(a.y),sin(a.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // recover previous frame for iterative rendering\n   \tfragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\t\n    \n    // get UVs\n    vec2 uv = fragCoord.xy/iResolution.xy-.5;\n\n    // seed per-pixel\n\trv2 = hash2( iTime+(uv.x+iResolution.x*uv.y)*1.51269341231 );\n    \n    // jitter for antialiasing\n    uv += 2.*(rv2-.5)/iResolution.xy;\n    \n    // correct UVs for aspect ratio\n    uv.x*=iResolution.x/iResolution.y;\n\t\n    // camera params\n    const vec3 camPos = vec3(-.5,-.2,-10);\n    const vec3 lookAt = vec3(-.5,-.2,0);\n    const float focusDistance=distance(camPos,lookAt);\n    const vec2 apertureRadius=vec2(1,2)*.1;\n   \n    // make a camera\n    vec3 cam = vec3(0);\n    vec3 dir = normalize(vec3(uv,1.));\n    \n    // slight bokeh\n    vec2 bokehJitter=bokeh();\n    cam.xy+=bokehJitter*apertureRadius;\n    dir.xy-=bokehJitter*apertureRadius*dir.z/focusDistance;\n\n    // rotate/move the camera\n    vec3 lookDir = lookAt-camPos;\n    float pitch = -atan(lookDir.y,length(lookDir.xz));\n    float yaw = -atan(lookDir.x,lookDir.z);\n    cam.yz *= rotate(pitch);\n    dir.yz *= rotate(pitch);\n    cam.xz *= rotate(yaw);\n    dir.xz *= rotate(yaw);\n    cam += camPos;\n    \n    // compute the pixel color\n\tvec3 pixel = trace2(cam,dir);\n        \n    if (iMouse.z > 0.) {\n        fragColor = vec4(0);\n    }\n\n    fragColor += (!isnan(pixel.r) && pixel.r >= 0.) ? vec4(vec3(pixel),1) : vec4(0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n~ Primitive Portrait\n  by yx/Polarity\n\n~ 2.6kb executable graphics\n  released at Revision 2020\n\n~ inspired by Kumi Yamashita's works of light and shadow\n\n~ should take no longer than 15 seconds to render\n\n~ tools:\n  crinkler 2.1a by loonies & tbc\n  shader minifier by llb\n\n~ greetings:\n  alia\n  alkama\n  blackle\n  cpdt\n  evvvvil\n  fizzer\n  flopine\n  noby\n  nusan\n  slerpy\n  tdhooper\n  wrighter\n*/", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2cWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 79], [81, 81, 111, 111, 154], [156, 156, 175, 175, 458], [460, 460, 512, 512, 1596]], "test": "untested"}
{"id": "wd2cWm", "name": "Cable Vortex", "author": "blinry", "description": "I'm quite happy with this, but there is some distortion going on in the background (most visible in the lower left). What can I do to avoid that? -> decreasing the step size to 70% as suggested by ilyaev helped a lot! :)", "tags": ["raymarching", "question", "cables"], "likes": 9, "viewed": 614, "published": 3, "date": "1586791609", "time_retrieved": "2024-07-30T21:13:11.331968", "image_code": "vec3 cell;\nfloat g;\nfloat time;\nfloat pi = 3.14159;\n\nfloat noise(vec3 p) {\n    return fract(sin(dot(p, vec3(4.3243241, 34.234, 234.23))) * 342.234);\n}\n\nmat2 rotate(float r) { return mat2(cos(r), sin(r), -sin(r), cos(r)); }\n\nfloat scene(vec3 p) {\n    p.x += p.z * p.z * 0.02 * sin(time * 2. * pi);\n\n    p.z += time * 40. * pi;\n    p.xy *= rotate(p.z * 0.10);\n\n    vec3 cellsize = vec3(4, 4, 0);\n    cell = floor(p / cellsize);\n\n    p = mod(p, cellsize) - cellsize / 2.;\n\n    return length(p.xy) - 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    time = mod(iTime / 10., 1.);\n\n    vec3 cam = vec3(0, 0, -5);\n    vec3 dir = normalize(vec3(uv, 1));\n\n    float t = 0.;\n    for (int i = 0; i < 128; ++i) {\n        t += scene(cam + dir * t) * .7;\n        if (t < 0.0001 || t > 50.)\n            break;\n    }\n\n    vec3 h = cam + dir * t;\n    vec2 o = vec2(.001, 0);\n    vec3 n = normalize(vec3(scene(h + o.xyy) - scene(h - o.xyy),\n                            scene(h + o.yxy) - scene(h - o.yxy),\n                            scene(h + o.yyx) - scene(h - o.yyx)));\n\n    vec3 light = normalize(vec3(0, 1, 1));\n    float diffuse = max(0., dot(n, light));\n    vec3 albedo =\n        0.05 + 0.95 * vec3(noise(cell.xyy), noise(cell.yxy), noise(cell.yyx));\n    float specular = pow(max(dot(normalize(light + -dir), n), 0.), 10000.);\n    float ambient = 0.4;\n    float fresnel = min(0.5, pow(1. + dot(n, dir), 4.));\n    vec3 bg = vec3(0.001);\n    vec3 col = mix((ambient + diffuse) * albedo + specular * vec3(1, 0.5, 0.5),\n                   bg, fresnel);\n\n    col = mix(col, bg, 1. - exp(-.0001 * t * t * t)); // apply fog\n\n    col = pow(col, vec3(.454)); // gamma correction\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2cWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 74, 74, 150], [152, 152, 174, 174, 222], [224, 224, 245, 245, 502], [504, 504, 561, 561, 1827]], "test": "untested"}
{"id": "wdjyDw", "name": "Grid002", "author": "caracal", "description": "fork of https://www.shadertoy.com/view/MtlcWX", "tags": ["grid"], "likes": 2, "viewed": 323, "published": 3, "date": "1586781924", "time_retrieved": "2024-07-30T21:13:12.200646", "image_code": "\nvoid stroke(float dist, vec3 color, inout vec3 fragColor, float thickness, float aa)\n{\n    float alpha = smoothstep(0.5 * (thickness + aa), 0.5 * (thickness - aa), abs(dist));\n    fragColor = mix(fragColor, color, alpha);\n}\n\n\n\nvoid renderGrid(vec2 pos, out vec3 fragColor)\n{\n    vec3 background = vec3(1.0);\n    vec3 axes = vec3(0.4);\n    vec3 lines = vec3(0.7);\n    vec3 sublines = vec3(0.95);\n    float subdiv = 8.0;\n\n    float thickness = 0.003;\n    float aa = length(fwidth(pos));\n\n    fragColor = background;\n\n    vec2 toSubGrid = pos - floor(pos*subdiv+0.5)/subdiv;\n    stroke(min(abs(toSubGrid.x), abs(toSubGrid.y)), sublines, fragColor, thickness, aa);\n\n    vec2 toGrid = pos - floor(pos+0.5);\n    stroke(min(abs(toGrid.x), abs(toGrid.y)), lines, fragColor, thickness, aa);\n\n    stroke(min(abs(pos.x), abs(pos.y)), axes, fragColor, thickness, aa);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float aspect = iResolution.x / iResolution.y;\n\tvec2 pos = (fragCoord / iResolution.y) * 1.3 - vec2((1.3*aspect - 1.0)/2.0, 0.15);\n\n\n    fragColor.a = 1.0;\n\trenderGrid(pos, fragColor.rgb);\n\n}\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdjyDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 87, 87, 224], [228, 228, 275, 275, 858], [862, 862, 917, 917, 1112]], "test": "untested"}
{"id": "ts2cWw", "name": "Grid001", "author": "caracal", "description": "fork of https://www.shadertoy.com/view/MtlcWX", "tags": ["grid"], "likes": 1, "viewed": 299, "published": 3, "date": "1586781450", "time_retrieved": "2024-07-30T21:13:12.991531", "image_code": "\nvoid stroke(float dist, vec3 color, inout vec3 fragColor, float thickness, float aa)\n{\n    float alpha = smoothstep(0.5 * (thickness + aa), 0.5 * (thickness - aa), abs(dist));\n    fragColor = mix(fragColor, color, alpha);\n}\n\n\n\nvoid renderGrid(vec2 pos, out vec3 fragColor)\n{\n    vec3 background = vec3(1.0);\n    vec3 axes = vec3(0.4);\n    vec3 lines = vec3(0.7);\n    vec3 sublines = vec3(0.95);\n    float subdiv = 8.0;\n\n    float thickness = 0.003;\n    float aa = length(fwidth(pos));\n\n    fragColor = background;\n\n    vec2 toSubGrid = pos - floor(pos*subdiv + 0.5)/subdiv;\n    stroke(min(abs(toSubGrid.x), abs(toSubGrid.y)), sublines, fragColor, thickness, aa);\n\n    vec2 toGrid = pos - floor(pos + 0.5);\n    stroke(min(abs(toGrid.x), abs(toGrid.y)), lines, fragColor, thickness, aa);\n\n    stroke(min(abs(pos.x), abs(pos.y)), axes, fragColor, thickness, aa);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float aspect = iResolution.x / iResolution.y;\n\tvec2 pos = (fragCoord / iResolution.y) * 1.3 - vec2((1.3*aspect - 1.0)/2.0, 0.15);\n\n\n    fragColor.a = 1.0;\n\trenderGrid(pos, fragColor.rgb);\n\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2cWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 87, 87, 224], [228, 228, 275, 275, 862], [866, 866, 921, 921, 1116]], "test": "untested"}
{"id": "wd2yWw", "name": "Grid000", "author": "caracal", "description": "fork of https://www.shadertoy.com/view/MtlcWX", "tags": ["grid"], "likes": 1, "viewed": 305, "published": 3, "date": "1586780549", "time_retrieved": "2024-07-30T21:13:13.949969", "image_code": "\nvoid stroke(float dist, vec3 color, inout vec3 fragColor, float thickness, float aa)\n{\n    float alpha = smoothstep(0.5 * (thickness + aa), 0.5 * (thickness - aa), abs(dist));\n    fragColor = mix(fragColor, color, alpha);\n}\n\n\n\nvoid renderGrid(vec2 pos, out vec3 fragColor)\n{\n    vec3 background = vec3(1.0);\n    vec3 axes = vec3(0.4);\n    vec3 lines = vec3(0.7);\n    vec3 sublines = vec3(0.95);\n    float subdiv = 8.0;\n\n    float thickness = 0.003;\n    float aa = length(fwidth(pos));\n\n    fragColor = background;\n\n    vec2 toSubGrid = pos - round(pos*subdiv)/subdiv;\n    stroke(min(abs(toSubGrid.x), abs(toSubGrid.y)), sublines, fragColor, thickness, aa);\n\n    vec2 toGrid = pos - round(pos);\n    stroke(min(abs(toGrid.x), abs(toGrid.y)), lines, fragColor, thickness, aa);\n\n    stroke(min(abs(pos.x), abs(pos.y)), axes, fragColor, thickness, aa);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float aspect = iResolution.x / iResolution.y;\n\tvec2 pos = (fragCoord / iResolution.y) * 1.3 - vec2((1.3*aspect - 1.0)/2.0, 0.15);\n\n\n    fragColor.a = 1.0;\n\trenderGrid(pos, fragColor.rgb);\n\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2yWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 87, 87, 224], [228, 228, 275, 275, 850], [854, 854, 909, 909, 1104]], "test": "untested"}
{"id": "3sjcWm", "name": "Chiptune-118366712", "author": "klk", "description": "8 bit nostalgy", "tags": ["sound"], "likes": 14, "viewed": 548, "published": 3, "date": "1586777055", "time_retrieved": "2024-07-30T21:13:14.721904", "image_code": "// Fork of \"Waterdrops song\" by None. https://shadertoy.com/view/-1\n// 2020-04-13 11:07:43\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0.0);\n\n    float beat=(1024./SND_HZ)/4./.68;\n    float time=trunc(iTime/beat)*beat+uv.x/64.;\n    \n    float vol=0.;\n    vec2 music=tune(time);\n    \n    col+=vec3(.2,.5,1)*\n        clamp\n        (1.0-\n         abs(iResolution.y/2.0-fragCoord.y)+abs(music.x)*iResolution.y/2.0\n         ,0.0,1.0);\n    col+=vec3(1,.8,0)*\n        clamp\n        (1.0-\n         abs(iResolution.y/2.0-fragCoord.y)+abs(music.y)*iResolution.y/2.0\n         ,0.0,1.0);\n\t\n    col=clamp(col,vec3(0.),vec3(1.));\n\n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define M_PI 3.141592\n#define SND_HZ 48000.\n\nfloat s(float t)\n{\n\treturn sin(t*2.*M_PI)*.25;\n}\n\nfloat s1(float t)\n{\n\tif(t<.2)\n    {\n        t/=.2;\n        return sin(t*2.*M_PI)*.25;\n    }\n\treturn 0.;\n}\n\nint l1a[16]=int[16](0,8,6,7,6,0,4,3,5,6,6,0,2,1,2,1);\nint l1b[16]=int[16](0,1,2,0,4,2,1,0,1,2,0,3,4,2,0,0);\nint l2a[16]=int[16](0,1,0,2,0,3,0,1,0,2,0,3,0,1,2,0);\nint l2b[16]=int[16](2,4,3,2,1,4,2,3,2,4,1,2,3,3,2,6);\n\nfloat sndVal(float ft)\n{\n//    original oneliners\n//\tint i1=(t*(\"0867604356602121\"[(t>>12)&15]-'0')*(\"0120421012034200\"[(t>>16)&15]-'0'));\n//\tint i2=(t*(\"0102030102030120\"[(t>>12)&15]-'0')*(\"2432142624123326\"[(t>>17)&15]-'0'));\n    int idx1=int(ft/4096. )&15;\n    int idx2=int(ft/65536.)&15;\n    int idx3=int(ft/65536./2.)&15;\n\n    float i1=ft*float(l1a[idx1]*l1b[idx2]);\n\tfloat i2=ft*float(l2a[idx1]*l2b[idx3]*4);\n\n    return (\n        s(mod(i1,1024.)/1024.)*.5\n        -s(mod(i1,256.)/256.)*.25\n        +s1(mod(i2,2048.)/2048.)*.25\n    )\n    \n    ;\n}\n\nvec2 tune0(float time)\n{\n    vec2 val=vec2(0);\n    float vib=time*M_PI/2.;\n    val.x=sndVal((time*SND_HZ+sin(vib)*250.));\n    val.y=sndVal((time*SND_HZ-sin(vib)*250.));\n    return val;\n}\n\nconst float delay=1024.*8./SND_HZ;\n\n\nvec2 tune(float time)\n{\n    time*=.68;\n    // synchronize echo with beats\n    float echomin=0.75;\n    vec2 val=tune0(time);\n    //val=vec2(0.);\n    //if(false)\n    for(float ex=1.;ex<=8.1;ex+=1.)\n    {\n        val+=pow(echomin,ex)*tune0(time-ex*delay);\n    }\n    return val;\n}", "sound_code": "vec2 mainSound( in int samp, float time )\n{\n\treturn tune(time);\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sjcWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 92, 149, 149, 729]], "test": "untested"}
{"id": "WsjyWm", "name": "Disco Star Tunnel", "author": "mrange", "description": "License: CC0\nStar tunnel created while randomly coding while listening to 90s music\nCode is kind of crappy but I liked the visual result so I decided to share it.", "tags": ["tunnel", "disco"], "likes": 48, "viewed": 1590, "published": 3, "date": "1586774850", "time_retrieved": "2024-07-30T21:13:15.483867", "image_code": "// License: CC0\n//  Star tunnel created while randomly coding while listening to 90s music\n//  Code is kind of crappy but I liked the visual result so I decided to share it.\n\n\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvec2 offset(float time, float z) {\n  z *= 0.1*sqrt(0.5);\n  vec2 o = vec2(0.0);\n  vec2 r = vec2(2.0);\n  o += r*vec2(cos(z), sin((sqrt(0.5))*z + pow(0.5 + 0.5*sin(sqrt(0.25)*z),5.0)));\n  return o;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nconst float smallRadii = pow(0.5, 6.0);\nconst float largeRadii = 1.0 + 2.0*smallRadii;\nconst float reps = float(int(largeRadii*TAU/(2.0*smallRadii)));\nconst float degree = TAU/reps;\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat star5(vec2 p, float r, float rf) {\n  const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n  const vec2 k2 = vec2(-k1.x,k1.y);\n  p.x = abs(p.x);\n  p -= 2.0*max(dot(k1,p),0.0)*k1;\n  p -= 2.0*max(dot(k2,p),0.0)*k2;\n  p.x = abs(p.x);\n  p.y -= r;\n  vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n  float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n  return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nvec3 df(vec2 p, int gi) {\n  float divend = 2.0*smallRadii + 0.5*pow(1.0 - cos(0.0), 2.0);\n  float dx = largeRadii - 0.5*divend;\n  vec2 op = p;\n  vec2 pp = toPolar(p);\n  float ny = pp.y;\n  pp.y +=-0.33*smallRadii*float(gi);\n  pp.x -= dx;\n  float nx = pp.x/divend;\n  pp.x = mod(pp.x, divend);\n  pp.x += dx;\n  float nny = mod1(pp.y, degree);\n  pp.y += PI/2.0;\n  p = toRect(pp);\n  \n  p -= vec2(0.0, largeRadii);\n  \n  float ymul = mod(nny, 2.0) > 0.0 ? 1.0 : -1.0;\n  float xmul = mod(float(int(nx)), 2.0) > 0.0 ? 1.0 : -1.0;\n  \n  rot(p, ymul*xmul*TIME*TAU/5.0);\n\n  float d = star5(p, smallRadii, 0.25);\n  float id = circle(op, largeRadii - smallRadii);\n  d = max(d, -id);\n\n  return vec3(d, nx, ny);\n}\n\nvec3 tunnelEffect(vec2 p) {\n  vec3 col = vec3(0.0);\n \n  float smoothPixel = 5.0/iResolution.x;\n \n  const vec3 baseCol = vec3(1.0);\n  const float zbase  = 10.0;\n  const float zdtime = 0.25;\n  const float zspeed = 10.0;\n  float gtime   = TIME*0.5;\n  float gz      = zspeed*gtime;\n  vec2 outerOff = offset(gtime, gz);\n  float fgtime  = mod(gtime, zdtime);\n  for (int i = 22; i >= -2; --i) {\n    int   gi      = i + int(gtime/zdtime);\n    float lz      = zspeed*(zdtime*float(i) - fgtime);\n    float zscale  = zbase/(zbase + lz);\n\n    float iz      = gz + lz;\n    vec2 innerOff = offset(gtime, iz);\n    \n    vec2 ip       = p + 0.5*zscale*(-innerOff + outerOff);\n    float ld      = length(ip)/zscale;\n\n    vec3 ddd      = df(ip/zscale, gi)*zscale;\n    float d       = ddd.x;    \n    vec3 scol = baseCol*vec3(0.6 + 0.4*sin(TAU*ddd.y*0.005 - 0.2*iz), pow(0.6 + 0.4*cos(-2.0*abs(ddd.z)-0.4*iz-0.5*gtime), 1.0), 0.8);\n    \n    float diff = exp(-0.0125*lz)*(1.0 - 1.0*tanh(pow(0.4*max(ld - largeRadii, 0.0), 2.0) + 3.0*smallRadii*max(ddd.y, 0.0)));\n    \n    vec4 icol = diff*vec4(scol, smoothstep(0.0, -smoothPixel, d));\n\n    icol.w += diff*diff*diff*0.75*clamp(1.0 - 30.0*d, 0.0, 1.0);\n    icol.w += tanh(0.125*0.125*lz)*0.5*ld*clamp(1.5 - ld, 0.0, 1.0);\n    \n    col = mix(col, icol.xyz, clamp(icol.w, 0.0, 1.0));\n  }\n \n \n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= iResolution.x/iResolution.y;\n  \n  vec3 col = tunnelEffect(p);\n \n  col = postProcess(col, q);\n \n  fragColor = vec4(col.xyz, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjyWm.jpg", "access": "api", "license": "cc0-1.0", "functions": [[277, 277, 316, 316, 441], [443, 443, 477, 477, 639], [641, 641, 674, 674, 759], [761, 761, 783, 783, 827], [829, 829, 850, 850, 895], [1080, 1080, 1111, 1111, 1137], [1139, 1139, 1179, 1179, 1537], [1539, 1539, 1564, 1564, 2234], [2236, 2236, 2263, 2263, 3567], [3569, 3569, 3605, 3605, 3854], [3857, 3857, 3912, 3912, 4114]], "test": "untested"}
{"id": "tsByDm", "name": "short MineSweeper ( 548/508 ch)", "author": "FabriceNeyret2", "description": "Click on cell to try the neighborhood.   \nDots: number of mines around.\nBlue: you touched a bomb : dead !\nGreen: safe\n\ngolfing:  \neasy to turn void mainImage into #define              -> -12 chars\nthen to move bufA and Image #main in Common  -> -28 chars", "tags": ["game", "short", "minesweeper"], "likes": 9, "viewed": 546, "published": 3, "date": "1586772712", "time_retrieved": "2024-07-30T21:13:16.363515", "image_code": "void mainImage(out vec4 O, vec2 U) { O = T(U); }   // ; O.r +=O.a  // debug: show data", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(U) texelFetch( iChannel0, ivec2(U) ,0 )", "buffer_a_code": "// O.rgb = display of cells (zoomed, compared to data)\n// O.w  = tested cell ( = data )\n// H(c) = bomb in cell ( 0/1 )\n\n#define H(P) ( fract(1e4*sin(dot(P,R-1.))) > .9 ? 1 : 0 ) // presence of a mine at P\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = T(u);                                  // previous state\n    vec2 R = iResolution.xy, s = round(R.yy/20.), // scaling\n         c = u-.5, P,                          // integer pixel value\n         C = c / s,\n         U = ceil( C ),                        // cell corresponding to display area\n         M = ceil( iMouse.xy / s );            // cell pointed by mouse\n    \n    int n=0, p=0, m=0, k=0;\n    for( ; k<9; k++)                           // browse neighborhood\n        P  = vec2(k%3,k/3) -1.,                // neighbor cell\n        n += H(c+P),                           // count mines around data cell\n        m += H(U+P),                           // count mines around displayed cell\n        p += int(T(c+P).w);                    // count marked cells around (for propagation)\n\n    if ( M == c || p > 0 )                     // mark if clicked or propagates from marked area\n        O.w = n > 0 ? .7 : 1.;                 // n=0: safe area (to propag).  n>0: next-to-bomb.\n    O.g = T(U).w;                              // display clicked cell\n\n    if ( M == c && H(c) > 0 ) O.w = 0.;        // clicked on a bomb -> dead ! ( -> no mark & propag )\n    \n    ivec2 Q = ivec2( 3.*C ) % 3;               // mine-mark location in displayed area\n    O.rgb +=  M == U && H(U) > 0 ? vec3(0,0,1) // click on bomb -> dead: display in blue\n            : T(U).w > 0. && Q.x+3*Q.y < m              // mine-mark id < number of bombs: \n                  ? vec3( length(fract(3.*C)-.5) < .4 ) // show mines count\n            : vec3(0);\n    c = mod(c,s); if ( c.x*c.y < 1.) O.rgb++;  // grid\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsByDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 48]], "test": "untested"}
{"id": "wsjcWW", "name": "Projective Transformation + SDF", "author": "mla", "description": "Showing the distance field for my \"Projective Easter Egg\": [url]https://www.shadertoy.com/view/ws2yWz[/url], which combines raymarching with a projective transformation (a 4x4 matrix applied to homogenous coordinates).\n", "tags": ["sdf", "projective"], "likes": 2, "viewed": 385, "published": 3, "date": "1586769509", "time_retrieved": "2024-07-30T21:13:17.125478", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Projective Easter Egg, Distance Field\n// Matthew Arcus, mla, 2020.\n//\n// Shows a slice through the distance field. Note the prominent \"plane\n// at infinity\" (type 'i' to disable infinity handling).\n//\n// Mouse changes direction of slice.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nbool handleinfinity = true;\n\nfloat PI = 3.14159;\n\nvec3 lightdir = vec3(0,2,1);\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nfloat segment(vec3 p, vec3 q, vec3 r) {\n  // Rebase to origin at q  \n  p -= q; r -= q;\n  // t*r is orthogonal projection of p onto qr.\n  float t = clamp(dot(p,r)/dot(r,r), 0.0, 1.0);\n  return distance(p,t*r);\n}\n\nfloat scene(vec3 p, out int type) {\n  p = abs(p);\n  if (p.x < p.y) p.xy = p.yx;\n  if (p.y < p.z) p.yz = p.zy;\n  if (p.x < p.y) p.xy = p.yx;\n  float d = 1e8,d1;\n  d1 = length(p)-1.0;\n  if (d1 < d) { d = d1; type = 0; }\n  d1 = segment(p,vec3(1,1,1),vec3(1,1,-1))-0.1;\n  if (d1 < d) { d = d1; type = 1; }\n  d1 = distance(p,vec3(1,1,1))-0.2;\n  if (d1 < d) { d = d1; type = 2; }\n  return d;\n}\n\nfloat de(vec4 p) {\n  p /= p.w;\n  float t = length(p.xyz);\n  // This gets rid of \"plane at infinity\", which otherwise shrinks\n  // all distances to 0.\n  if (handleinfinity && t > 100.0) p.xyz *= 100.0/t;\n  int type;\n  return scene(p.xyz,type);\n}\n\nvec4 grad(vec4 p) {\n  // 4 dimensional gradient of distance field\n  // First order seems to be OK for our purposes -\n  // just want to scale the distance field.\n  float eps = 1.0/256.0;\n  vec2 e = vec2(eps, 0.0);\n  float t = de(p);\n  return vec4(de(p + e.xyyy) - t,\n              de(p + e.yxyy) - t,\n              de(p + e.yyxy) - t,\n              de(p + e.yyyx) - t)/eps;\n}\n\nmat4 A = mat4(0.8,0,0,0,\n              0,1,0,0,\n              0,0,1,0,\n              0,0,0,1);\n\nfloat eyesign = 1.0; // Sign of distance field at eye.\n\nfloat eval(vec4 p) {\n  p = A*p;\n  float d = de(p);\n  vec3 g = transpose(mat3x4(A))*grad(p);\n  d /= length(g);\n  return eyesign*d;\n}\n\nfloat eval(vec3 p) {\n  return eval(vec4(p,1));\n}\n\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid init() {\n  float time = 0.5*iTime;\n  A *= mat4(cos(time),0,0,sin(time),\n            0,1,0,0,\n            0,0,1,0,\n            -sin(time),0,0,cos(time));\n  A *= mat4(1,0,0,0,\n            0,cos(time),sin(time),0,\n            0,-sin(time),cos(time),0,\n            0,0,0,1);\n}\n\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 rotateframe(vec3 p) {\n  if (iMouse.x > 0.0) {\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  {\n    float t = 0.0; // iTime;\n    p.yz = rotate(p.yz,0.5+t*0.125);\n    p.zx = rotate(p.zx,0.5+t*0.1);\n  }\n  return p;\n}\n\nconst int CHAR_I = 73;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nbool key(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n  handleinfinity = handleinfinity != key(CHAR_I);\n  init();\n  vec2 z = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec3 x = vec3(0,0,1);\n  vec3 y = vec3(1,0,0);\n  x = rotateframe(x);\n  y = rotateframe(y);\n  float d = eval(10.0*(z.x*x + z.y*y));\n  vec3 col = hsv2rgb(vec3(2.0*atan(0.1*d)/PI,1,1));\n  col *= 0.5+0.5*sin(10.0*d);\n  if (d < 0.01) col = vec3(1);\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsjcWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[510, 510, 531, 531, 557], [559, 559, 598, 627, 769], [771, 771, 806, 806, 1158], [1160, 1160, 1178, 1178, 1404], [1406, 1406, 1425, 1566, 1780], [1934, 1934, 1954, 1954, 2065], [2067, 2067, 2087, 2087, 2115], [2117, 2117, 2144, 2144, 2320], [2322, 2322, 2335, 2335, 2599], [2601, 2601, 2637, 2637, 2689], [2691, 2691, 2717, 2717, 3057], [3131, 3131, 3151, 3151, 3211], [3213, 3213, 3238, 3238, 3286], [3287, 3287, 3310, 3310, 3342], [3344, 3344, 3395, 3395, 3812]], "test": "untested"}
{"id": "Wd2yWw", "name": "Divine Light", "author": "dr2", "description": "Truchet tubing +...", "tags": ["sunbeam", "truchet"], "likes": 18, "viewed": 653, "published": 3, "date": "1586766755", "time_retrieved": "2024-07-30T21:13:17.949275", "image_code": "// \"Divine Light\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat Minv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv3 (vec3 p);\nfloat Noisefv3 (vec3 p);\nfloat Fbm1 (float p);\n\nvec3 ltPos, ltAx;\nvec2 trkAx, trkAy, trkFx, trkFy;\nfloat dstFar, tCur;\nconst float pi = 3.14159;\n\nvec3 TrackPath (float t)\n{\n  return vec3 (dot (trkAx, sin (trkFx * t)), dot (trkAy, sin (trkFy * t)), t);\n}\n\nvec3 TrackVel (float t)\n{\n  return vec3 (dot (trkAx * trkFx, cos (trkFx * t)), dot (trkAy * trkFy, cos (trkFy * t)), 1);\n}\n\nfloat TubeDist (vec3 p)\n{\n  vec2 s, t;\n  float w, a;\n  t = p.xy;\n  t *= t;\n  s = vec2 (sqrt (sqrt (dot (t, t))), p.z) - 0.5;\n  t = cos (64. * pi * s);\n  w = 0.03 * (1. + 0.1 * t.x * t.y);\n  a = 2. * pi * (floor (16. * (atan (p.y, - p.x) / (2. * pi)) + 0.5) / 16.);\n  return min (SmoothMax (PrRoundBox2Df (s, vec2 (w), 0.03),\n     0.04 - abs (dot (p.yx, sin (a + vec2 (0.5 * pi, 0.)))), 0.01),\n     PrRoundBox2Df (s, vec2 (0.5 * w), 0.03));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, db;\n  float r;\n  q = p;\n  q.xy -= TrackPath (q.z).xy;\n  r = floor (8. * Hashfv3 (floor (q)));\n  q = fract (q);\n  if (r >= 4.) q = q.yxz;\n  r = mod (r, 4.);\n  if (mod (r, 2.) == 0.) q.x = 1. - q.x;\n  if (abs (r - 1.5) == 0.5) q.y = 1. - q.y;\n  db = vec3 (TubeDist (q), TubeDist (vec3 (q.z, 1. - q.x, q.y)), TubeDist (vec3 (1. - q.yz, q.x)));\n  return 0.7 * Minv3 (db);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 BgCol (vec3 rd)\n{\n  float t, gd, b;\n  t = 4. * tCur;\n  b = dot (vec2 (atan (rd.x, rd.y), 0.5 * pi - acos (rd.z)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return mix (vec3 (0.8, 0.5, 0.), vec3 (0.9, 0.4, 0.2), 0.5 + 0.5 * rd.z) *\n     (0.12 + 0.22 * (rd.z + 1.) * (rd.z + 1.)) * (2. + 0.3 * gd);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, bgCol, vn, ltVec, ltDir;\n  float dstObj, nDotL, ltDist, atten;\n  dstObj = ObjRay (ro, rd);\n  bgCol = BgCol (rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = vec4 (mix (vec3 (0.75, 0.7, 0.7), vec3 (0.8, 0.7, 0.7),\n       smoothstep (0.45, 0.55, Noisefv3 (32. * ro))), 0.1);\n    ltVec = ltPos - ro;\n    ltDist = length (ltVec);\n    ltDir = ltVec / ltDist;\n    atten = min (1., 0.2 + smoothstep (0.7, 0.95, dot (ltAx, - ltDir))) / (1. + 0.2 * ltDist * ltDist);\n    nDotL = max (dot (vn, ltDir), 0.);\n    col = atten * (col4.rgb * (0.2 + 0.8 * nDotL * nDotL) +\n       col4.a * pow (max (dot (reflect (rd, vn), ltDir), 0.), 32.));\n    col = mix (col, bgCol, 0.1 + 0.9 * smoothstep (0., 0.85, dstObj / dstFar));\n  } else col = bgCol;\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv;\n  float az, el, zmFac, fSpd, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  }\n  trkAx = 0.07 * vec2 (2., 0.9);\n  trkAy = 0.07 * vec2 (1.3, 0.66);\n  trkFx = vec2 (0.2, 0.23);\n  trkFy = vec2 (0.17, 0.24);\n  fSpd = 1.;\n  t = fSpd * tCur;\n  ro = TrackPath (t);\n  ro.xy += 0.05 * sin (0.05 * pi * tCur);\n  vd = normalize (TrackVel (t));\n  vuMat = StdVuMat (el + sin (vd.y), az + atan (vd.x, vd.z));\n  zmFac = 2.5;\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  rd.xy = Rot2D (rd.xy, 0.07 * pi * (Fbm1 (0.2 * tCur) - 0.5));\n  ltPos = ro + vuMat * vec3 (0.1, 0.1, 0.);\n  ltAx = vuMat * vec3 (0., 0., 1.);\n  dstFar = 50.;\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xyz)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2yWw.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[515, 515, 541, 541, 622], [624, 624, 649, 649, 746], [748, 748, 773, 773, 1189], [1191, 1191, 1213, 1213, 1593], [1595, 1595, 1628, 1628, 1804], [1806, 1806, 1827, 1827, 2077], [2079, 2079, 2101, 2101, 2520], [2522, 2522, 2557, 2557, 3378], [3380, 3380, 3433, 3433, 4397], [4399, 4399, 4446, 4446, 4493], [4495, 4495, 4517, 4517, 4555], [4557, 4557, 4602, 4602, 4705], [4707, 4707, 4752, 4752, 4790], [4792, 4792, 4828, 4828, 5034], [5036, 5036, 5066, 5066, 5179], [5213, 5213, 5237, 5237, 5302], [5304, 5304, 5328, 5328, 5381], [5383, 5383, 5407, 5407, 5526], [5528, 5528, 5553, 5553, 5699], [5701, 5701, 5726, 5726, 5951], [5953, 5953, 5975, 5975, 6129]], "test": "untested"}
{"id": "Wly3Wh", "name": "TRSi Megademo bouncing scroller", "author": "toomuchvoltage", "description": "I really really really wanted to replicate the TRSi Megademo colored bouncing scroller some day :D\n\nRe-play audio and re-wind the shader.\n\nhttps://youtu.be/oTmpqBn4dfA?t=1204", "tags": ["amiga", "megademo", "trsi", "redsector", "tristar"], "likes": 3, "viewed": 462, "published": 3, "date": "1586757408", "time_retrieved": "2024-07-30T21:13:18.774070", "image_code": "/***********************************************************\n\n   I really really really wanted to replicate the TRSi Megademo colored bouncing scroller :D\n   See the demo here: https://youtu.be/oTmpqBn4dfA?t=1204\n   2D Simplex by iq: https://www.shadertoy.com/view/Msf3WH\n   3D Simplex by nikat: https://www.shadertoy.com/view/XsX3zB\n\n   Everything else covered under the MIT license:\n\n   Copyright (c) 2020 Baktash Abdollah-shamshir-saz.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Mastodon: https://mastodon.gamedev.place/@toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\n#define M_PI 3.1415926535\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nvec2 toSpherical(vec3 inpVec)\n{\n\tvec2 inpVecOnXZ = ((inpVec.xz == vec2 (0.0)) ? vec2 (0.0) : normalize (inpVec.xz));\n\tfloat phi = acos(clamp (inpVecOnXZ.x, -1.0, 1.0));\n\tif (inpVecOnXZ.y < 0.0) phi = (2.0 * M_PI) - phi;\n\tfloat theta = acos(clamp (inpVec.y, -1.0, 1.0));\n\treturn vec2(phi / (2.0*M_PI), theta / M_PI);\n}\n\nconst uint textArr0[34] = uint[](3503345872u,2511917264u,2558840969u,3734340245u,3000032990u,2441386897u,2563807363u,3516236437u,2194717136u,2627506581u,2508378249u,2308742289u,2442494672u,3498679452u,2224984455u,2228262037u,2508378271u,2510000541u,2576909520u,2676215939u,2496697757u,3504245137u,2241319097u,3498279829u,2224134276u,2308019408u,3498285520u,2442436484u,3100696201u,3499458719u,3498418057u,2510002588u,3498351056u,3504265674u);\n\n#define _1_OVER_16 0.0625\n\nfloat worldDensity (vec3 inpCoord, vec3 scale, out float azimuth)\n{\n    if ( iChannelTime[0] > 38.0 )\n    {\n        float fieldForce = pow ((dot (normalize (inpCoord), vec3 (sign(sin(iTime * 5.0)), 0.0, 0.0)) + 1.0) * 0.5, 1.0);\n        float fieldForceRemap = (clamp (fieldForce, 0.5, 1.0) - 0.5) * 2.0;\n        inpCoord = normalize (inpCoord) * (length(inpCoord) + fieldForceRemap * 0.7 * abs(sin(iTime * 5.0))); // Apply force to field\n    \n\t    inpCoord.x -= sin(iTime * 5.0);\n    }\n\n    float icLen = length (inpCoord);\n    if ( icLen < 1.0 || icLen > 2.0 ) return 0.0;\n    vec3 icNorm = inpCoord / icLen;\n    vec2 icNormSph = toSpherical (icNorm);\n    azimuth = icNormSph.x;\n    vec3 sphCoord = vec3 (icNormSph, icLen) * scale;\n    float timeTnt;\n    if ( iChannelTime[0] > 7.75 ) sphCoord.y += sin(iChannelTime[0] + sphCoord.x * 3.0) * 0.5;\n    if ( iChannelTime[0] > 23.0 ) sphCoord.y += sin(iChannelTime[0] + sphCoord.x * 15.0) * 0.1;\n    vec3 intPart;\n    vec3 localCoord = modf (sphCoord, intPart);\n    if ( intPart.y != 5.0 ) return 0.0;\n   \n\n    float textOffset = sphCoord.x + iTime;\n    float textOffsetIntPart;\n    float textOffsetFractPart = modf (textOffset, textOffsetIntPart);\n    int charIndex = int(textOffsetIntPart);\n    int arrIndex = (charIndex / 4) % 34;\n    uint wordFetch = textArr0[arrIndex];\n    uint charFetch = (wordFetch >> ((charIndex % 4) * 8)) & 0x000000FFu;\n    float charX = float (int (charFetch & 0x0000000Fu)     );\n    float charY = float (int (charFetch & 0x000000F0u) >> 4);\n    vec2 charCoords = vec2(charX, charY);\n    \n    vec2 charUVBase = vec2 (_1_OVER_16, _1_OVER_16) * charCoords;\n\tcharUVBase.y = 1.0 + charUVBase.y;\n    return texture (iChannel1, charUVBase + vec2 (textOffsetFractPart, localCoord.z) * vec2(_1_OVER_16, _1_OVER_16)).x;\n}\n\n\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat worldOpaque (vec3 inpCoord, out float azimuth)\n{\n\treturn worldDensity (inpCoord, vec3 (10.0, 10.0, 1.0), azimuth) > 0.5 ? 1.0 : 0.0;\n}\n\nvec2 rotate(vec2 v, float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y / iResolution.x;\n    \n    vec3 curEye = vec3 (0.0, 3.0, -3.0);\n    float timeInt;\n    vec3 curLook = normalize (-curEye);\n    vec3 curSide = normalize (cross (curLook, vec3 (0.0, 1.0, 0.0)));\n    vec3 curUp = cross (curSide, curLook);\n    \n    vec3 sampleDirNorm = normalize (curLook + curUp * uv.y + curSide * uv.x);\n    vec3 sampleDir = sampleDirNorm * 0.01;\n    vec3 samplePt = curEye + sampleDir;\n\n    for (int i = 0; i != 650; i++)\n    {\n        float hitAzimuth;\n        if ( worldOpaque (samplePt, hitAzimuth) == 1.0 )\n        {\n            vec3 azimuthColor;\n            azimuthColor.x = abs (noise(vec2 (iTime * 0.25)));\n            azimuthColor.y = abs (noise(vec2 (iTime * 0.25 + 100.0)));\n            azimuthColor.z = abs (noise(vec2 (iTime * 0.25 + 200.0)));\n            azimuthColor = azimuthColor * 3.0;\n            fragColor.rgb = clamp (samplePt.y + 1.0, 0.0, 1.0) * azimuthColor;\n            return;\n        }\n        samplePt += sampleDir;\n    }\n    \n    float shiftedTime = iTime + 1000.0; // Better noise around here...\n    vec3 tunnelDir = normalize (vec3 (uv.x, uv.y, 1.0));\n    tunnelDir.xy = rotate(tunnelDir.xy, shiftedTime);\n\n    float uvLen = length(tunnelDir.xy);\n    if ( uvLen == 0.0 )\n    {\n        fragColor.rgb = vec3 (0.0);\n        return ;\n    }\n\tvec3 sampleLoc = (10.0 / uvLen) * tunnelDir;\n    sampleLoc.z += shiftedTime * 60.0;\n    fragColor.rgb = vec3 (max(simplex3d(sampleLoc) - 0.75, 0.0) * 10.0) * uvLen;\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 21942, "src": "https://soundcloud.com/user-322280034/scrollertrsimegademo", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wly3Wh.jpg", "access": "api", "license": "mit", "functions": [[1827, 1827, 1884, 1884, 1999], [2001, 2001, 2027, 2027, 2506], [2508, 2508, 2530, 2530, 2703], [2764, 2764, 2789, 3042, 3959], [3961, 3961, 3992, 3992, 4278], [4751, 4751, 4818, 4818, 6541], [6544, 6544, 6589, 6589, 7217], [7219, 7219, 7273, 7273, 7359], [7361, 7361, 7391, 7391, 7475], [7477, 7477, 7534, 7534, 9062]], "test": "untested"}
{"id": "tsSyDw", "name": "Another Mandelbrot Visualizer", "author": "koi", "description": "Drag your mouse to change the exponent.\nUncomment line 32 for more fun colouring.", "tags": ["mandelbrot", "interactive", "visualizer"], "likes": 0, "viewed": 189, "published": 3, "date": "1586740008", "time_retrieved": "2024-07-30T21:13:19.592881", "image_code": "const int maxCount = 99;\nconst float maxRadius = 2.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 C = (fragCoord*2.0 - iResolution.xy) / iResolution.x;\n    C *= 2.0;\n    C.x -= 0.5;\n    \n    float a = C.x;\n    float b = C.y;\n    float r = length(C);\n    int count = 0;\n    \n    float k = iMouse.x/iResolution.x * 2.0 + 2.0;\n    \n    for(; count < maxCount && r < maxRadius; count++)\n    {\n        //float an = a*a - b*b + C.x;\n        //float bn = 2.0 * a * b + C.y;\n        //a = an;\n        //b = bn;\n        \n        float theta = atan(b, a);        \n        a = pow(r, k) * cos(theta * k) + C.x;\n        b = pow(r, k) * sin(theta * k) + C.y;\n        r = sqrt(a*a + b*b);\n    }\n    \n    float v = log(float(count+1)) / log(10.0) / 2.0;\n    fragColor = vec4(vec3(v), 1.0);\n    //fragColor = vec4(vec3(log(float(count)) / 8.0, float(count) / 100.0, log(float(count)) / 8.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsSyDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 112, 112, 907]], "test": "untested"}
{"id": "tsScWw", "name": "Bouncing Julia", "author": "wyatt", "description": "graph network of particles. They find each other by searching a directional graph. ", "tags": ["graph"], "likes": 27, "viewed": 538, "published": 3, "date": "1586738020", "time_retrieved": "2024-07-30T21:13:20.504444", "image_code": "// Fork of \"Graph Network*\" by wyatt. https://shadertoy.com/view/wdjcDR\n// 2020-04-13 00:32:16\n\n// Fork of \"Graph Network\" by wyatt. https://shadertoy.com/view/tssyDS\n// 2020-04-09 20:04:37\n\nMain {\n    vec4 c = C(U), cc = B(c.zw);\n    for (int x = -1; x<=1;x++)\n        for (int y = -1; y<=1;y++){\n        \tvec4 ccc = B(c.zw+vec2(x,y));\n            if (length(U-A(ccc.xy).xy)<length(U-A(cc.xy).xy))\n                cc=ccc;\n        }\n    vec4 a = A(c.zw), b = A(cc.xy),\n         aa = D(c.zw), bb = D(cc.xy);\n    vec2 r = a.xy-b.xy, p = aa.xy-bb.xy;\n    float an = angle(r,p);\n    \n   \tvec2 u = U-a.xy;\n    \n    u *= length(p)/length(r)*mat2(cos(an),sin(-an),sin(an),cos(an));\n    u += aa.xy;\n    Q.zw = vec2(0,1);\n    u = 2.5*(u-0.5*R)/R.y;\n    vec2 z = vec2(.8,.2);\n    Q =vec4(0);\n    for (float i = 1.;i<100.;i++){\n    \tu = vec2(u.x*u.x-u.y*u.y,2.*u.x*u.y)-Z;\n    \tQ  += .05*(.3+sin(10.*length(u)+vec4(1,2,3,4))*exp(-(dot(u,u)*vec4(1,2,3,4))));\n        if (length(u)>4.) break;\n    }\n    Q *= 1.5*smoothstep(5.*O,1.2*O,length(U-a.xy));\n\t//Q = B(U)/R.x*2.;\n    //Q *= 19.*exp(-dot(U-a.xy,U-a.xy));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texelFetch(iChannel1,ivec2(U),0)\n#define C(U) texelFetch(iChannel2,ivec2(U),0)\n#define D(U) texelFetch(iChannel3,ivec2(U),0)\n#define Main void mainImage (out vec4 Q, vec2 U) \n#define Init if (iFrame < 1) \n#define Border if (U.x<1.||R.x-U.x<1.||U.y<1.||R.y-U.y<1.)\n#define O 6.\n#define shape(U) (round((U)/O)*O)\n#define N 11\n#define Z vec2(.8,.2)\nfloat angle (vec2 a, vec2 b) {\n\treturn atan(a.x*b.y-a.y*b.x,dot(a.xy,b.xy));\n}\nfloat sg (vec2 p, vec2 a, vec2 b) {\n    if (length(a-b)<1e-4||length(a)<1e-4||length(b)<1e-4) return 1e9;\n    \n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\tfloat l = (length(p-a-(b-a)*i));\n    return l;\n}\n\nfloat pie (vec2 p, vec2 a, vec2 b) {\n\tvec2 m = 0.5*(a+b); // midpoint\n    if (length(a-b)<1e-3) return 1e3; // ignore self\n\treturn abs(dot(p-m,b-m)/dot(b-m,b-m)); // pojection\n} \nfloat line (vec2 p, vec2 a, vec2 b) {\n    if (length(a-b)<1e-4||length(a)<1e-4||length(b)<1e-4) return 1e9;\n    \n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\tfloat l = (length(p-a-(b-a)*i));\n    l=(l+1.)*(pie(p,a,b));\n    return l;\n}", "buffer_a_code": "vec2 force (vec2 U, vec4 a, vec2 bb) {\n    vec4 b = A(bb);\n    \n    vec2 r = b.xy-a.xy, v = b.zw-a.zw,\n         da = D(U).xy, db = D(bb).xy,\n         q = db-da;\n    float l = length(r), j = length(q);\n    \n    if (l>R.x*2.||b.x<1.||b.y<1.||db.x<1.||db.y<1.) return vec2(0);\n    if (l < 1e-9) return vec2(0);\n    return  0.5*r/l*(l-j);\n}\nMain {\n    vec2 u = shape(U);\n    Q = A(u);\n    if ((iFrame>1&&Q.x<1.&&Q.y<1.)||u.x+O>=R.x||u.y+O>=R.y||u.x<O||u.y<O||length(U-u)>1.) {Q=-1e8*R.xyxy;return;}\n    \n    vec2 f = vec2(0);\n    for (int x=-4;x<4; x++) {\n        for (int y=-4;y<4; y++) {\n            vec4 b = B(u+vec2(x,y));\n            f += (\n                force(U,Q,b.xy)+\n                force(U,Q,b.zw));\n        }\n\t}\n    f /= 64.;\n    f.y -= 0.01;\n    Q.zw += f;\n    Q.xy += f+Q.zw*sqrt(3./(1.+dot(Q.zw,Q.zw)));\n    if (iMouse.z>0.) Q.zw += (Q.xy-iMouse.xy)/length(Q.xy-iMouse.xy);\n    \n    \tif (Q.x<5.) {Q.x=5.;Q.z = +abs(Q.z);}\n        if (R.x-Q.x<5.) {Q.x=R.x-5.;Q.z =-abs(Q.z);}\n        if (Q.y<5.) {Q.y=5.;Q.w = +abs(Q.w);}\n        if (R.y-Q.y<5.) {Q.y=R.y-5.;Q.w =-abs(Q.w);}\n\n    if (iFrame < 2) {\n    \tQ = vec4(D(U).xy,0,0);\n    }\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void X (inout vec4 Q, inout vec2 r, vec4 a, vec2 U, vec2 u, vec4 n) {\n\tfloat l = line(a.xy-U+u,a.xy,A(n.xy).xy),\n          ll = line(a.xy-U+u,a.xy,A(n.zw).xy);\n    if (l<r.x){\n        r = vec2(l,r.x);\n        Q=vec4(n.xy,Q.xy);\n    } else if (l<r.y) {\n    \tr.y = l;\n        Q.zw = n.xy;\n    }\n    if (ll<r.x){\n    \tr = vec2(ll,r.x);\n        Q=vec4(n.zw,Q.xy);\n    } else if (ll<r.y) {\n    \tr.y = ll;\n        Q.zw = n.zw;\n    }\n}\nMain {\n    vec2 u = shape(U);\n    vec4 a = A(u);\n\tQ = B(U);\n    vec2 r = vec2(line(a.xy-U+u,a.xy,A(Q.xy).xy)\n                 ,line(a.xy-U+u,a.xy,A(Q.zw).xy));\n    \n    X(Q,r,a,U,u,B(Q.xy+U-u));\n    X(Q,r,a,U,u,B(Q.zw+U-u));\n    \n    X(Q,r,a,U,u,B(U+vec2(1,1)));\n    X(Q,r,a,U,u,B(U+vec2(0,1)));\n    X(Q,r,a,U,u,B(U+vec2(1,0)));\n    X(Q,r,a,U,u,B(U-vec2(0,1)));\n    X(Q,r,a,U,u,B(U-vec2(1,0)));\n    X(Q,r,a,U,u,B(U+vec2(1,1)));\n    X(Q,r,a,U,u,B(U+vec2(1,-1)));\n    X(Q,r,a,U,u,B(U-vec2(1,1)));\n    X(Q,r,a,U,u,B(U-vec2(1,-1)));\n    X(Q,r,a,U,u,B(Q.xy+U-u+vec2(0,1)));\n    X(Q,r,a,U,u,B(Q.xy+U-u+vec2(1,0)));\n    X(Q,r,a,U,u,B(Q.xy+U-u-vec2(0,1)));\n    X(Q,r,a,U,u,B(Q.xy+U-u-vec2(1,0)));\n    X(Q,r,a,U,u,B(Q.xy+U-u+vec2(1,1)));\n    X(Q,r,a,U,u,B(Q.xy+U-u+vec2(1,-1)));\n    X(Q,r,a,U,u,B(Q.xy+U-u-vec2(1,1)));\n    X(Q,r,a,U,u,B(Q.xy+U-u-vec2(1,-1)));\n    X(Q,r,a,U,u,vec4(U-O*vec2(1,0),U+O*vec2(1,0)));\n    X(Q,r,a,U,u,vec4(U-O*vec2(0,1),U+O*vec2(0,1)));\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\nvoid Y (inout vec4 Q, vec2 U, vec4 n) {\n\tfloat l = length(U-A(n.xy).xy),//sg(U,A(n.xy).xy,A(n.zw).xy),\n          ll = length(U-A(Q.xy).xy);//sg(U,A(Q.xy).xy,A(Q.zw).xy);\n    if (l<ll) Q.xy = n.xy;\n}\nvoid X (inout vec4 Q, vec2 U, vec4 n) {\n\tfloat l = length(U-A(n.zw).xy),//sg(U,A(n.xy).xy,A(n.zw).xy),\n          ll = length(U-A(Q.zw).xy);//sg(U,A(Q.xy).xy,A(Q.zw).xy);\n    if (l<ll) Q.zw = n.zw;\n}\nMain {\n\tQ = C(U).xyxy;\n    if (iFrame%N==0) Q.xy = U;\n    else {\n        float k = exp2(float(N-1-(iFrame%N)));\n    \tY(Q,U,C(U+vec2(0,k)));\n    \tY(Q,U,C(U+vec2(k,0)));\n    \tY(Q,U,C(U-vec2(0,k)));\n    \tY(Q,U,C(U-vec2(k,0)));\n    }\n\n\tX(Q,U,C(U+vec2(0,1)));\n    X(Q,U,C(U+vec2(1,0)));\n    X(Q,U,C(U-vec2(0,1)));\n    X(Q,U,C(U-vec2(1,0)));\n    \n    X(Q,U,C(U+vec2(1,1)));\n    X(Q,U,C(U+vec2(1,-1)));\n    X(Q,U,C(U-vec2(1,1)));\n    X(Q,U,C(U-vec2(1,-1)));\n    \n    X(Q,U,C(U+vec2(0,4)));\n    X(Q,U,C(U+vec2(4,0)));\n    X(Q,U,C(U-vec2(0,4)));\n    X(Q,U,C(U-vec2(4,0)));\n    \n    X(Q,U,C(U));\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n\tQ.xy = shape(U);\n    Q.x += 0.5*O*mod(Q.y/O,2.);\n    vec2 u = 2.5*(Q.xy-0.5*R)/R.y;\n    for (float i = 0.;i<15.;i++){\n    \tu = vec2(u.x*u.x-u.y*u.y,2.*u.x*u.y)-Z;\n    \tif (length(u)>4.) Q = vec4(-1e2*R,0,0);\n    }\n}", "buffer_d_inputs": [], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsScWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "wdScWw", "name": "Twitch: CupWorld(tm)", "author": "blackle", "description": "live coded on twitch in 1 hour. https://www.twitch.tv/videos/590568063\n\ncan you survive the incessant clanging in cupworld?", "tags": ["terrain", "cups", "livecode", "coffeecup"], "likes": 6, "viewed": 418, "published": 3, "date": "1586737894", "time_retrieved": "2024-07-30T21:13:21.268401", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat linedist(vec3 p, vec3 a, vec3 b) {\n  float k = dot(p-a, b-a)/dot(b-a, b-a);\n  return distance(p, mix(a, b, clamp(k,0.,1.)));\n}\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n  float k = dot(p-a, b-a)/dot(b-a, b-a);\n  return distance(p, mix(a, b, clamp(k,0.,1.)));\n}\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(float a, float b) {\n  int x = FK(a);int y = FK(b);\n  return float((x*x-y)*(y*y+x)-y)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nvec3 idglob;\nfloat hsglob;\nint mat;\n\nfloat hillheight(vec2 p) {\n  float hillscale = 0.5;\n  return cos(dot(p.xy*hillscale, vec2(0.05,0.02)))*2.5\n  + cos(dot(p.xy*hillscale, vec2(0.01,0.03)))*2.5\n  + cos(dot(p.xy*hillscale, vec2(0.02,0.05)))*2.5\n  + cos(dot(p.xy*hillscale, vec2(0.08,0.05)))*2.5;\n}\n\nfloat scene(vec3 p) {\n  p.z += hillheight(p.xy);\n  float fl = p.z;\n\n  float scale = 10.;\n  vec2 id = floor(p.xy/scale);\n  idglob = idglob;\n  p.xy = (fract(p.xy/scale)-0.5)*scale;\n\n  \n  float seed = hash(id.x, id.y);\n  float h1 = hash(seed, seed);\n  float h2 = hash(h1, seed);\n  float h3 = hash(h2, seed);\n  float h4 = hash(h3, seed);\n  float h5 = hash(h4, seed);\n  float h6 = hash(h5, seed);\n  float arcx = fract(iTime+h6*5.);\n  p.z -= arcx*(1.-arcx)*10.;\n  hsglob = hash(h5, h5);\n  vec3 ax = normalize(tan(vec3(h1, h2, h3)));\n  vec3 off = vec3(0, 0, 1.2);\n  p -= off;\n  p = erot(p, ax, h4*100. + iTime);\n  \n  p = erot(p, vec3(0,0,1), h5*100.);\n  p.x += asin(sin(iTime*0.5*acos(-1.)));\n  p += off;\n  \n  float sphere = length(p.xy)-1.;\n  float crds = linedist(vec2(sphere, p.z), vec2(0,2.2), vec2(0,0))/sqrt(2.);\n  float bottom = linedist(vec2(length(p.xy), p.z), vec2(-0.5,0), vec2(1.,0))/sqrt(2.);\n  \n  float handle_skel = linedist(vec2(max(p.y,1.3), p.z), vec2(1.3,1.4), vec2(1.3,0.9))-0.3;\n  float handle = linedist(vec2(p.x, handle_skel), vec2(-0.2, 0.), vec2(0.2, 0.))/sqrt(2.);\n  handle = max(1.-p.y, handle);\n  float cup = 0.9*min(crds, min(bottom,handle))-0.05;\n  mat = 0;\n  if (fl < cup) {\n    mat = 1;\n    return fl;\n  }\n  return cup;\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(0.001);\n  return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\n#define ITERCOUNT 500\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n\n  vec3 cam =normalize(vec3(1,uv));\n  vec3 init = vec3(0,0,10);\n  float rot = 0.1;\n  float zrot = cos(iTime)*0.4-0.5;\n  cam = erot(cam, vec3(0,1,0), rot);\n  init = erot(init, vec3(0,1,0), rot);\n  cam = erot(cam, vec3(0,0,1), zrot);\n  init = erot(init, vec3(0,0,1), zrot);\n  init += fract(iTime/100.)*2000.*vec3(1,1,0);\n  init.z -= hillheight(init.xy) + sin(iTime)*5.;\n  vec3 p = init;\n  bool hit = false;\n  int i;\n  for (i = 0; i < ITERCOUNT && !hit; i++) {\n    float dist = scene(p);\n    hit = hit || dist*dist < 1e-6;\n    p += cam*dist;\n  }\n  float perc = float(i)/float(ITERCOUNT);\n  \n  vec3 idloc = idglob;\n  float hsloc = hsglob;\n  int matloc = mat;\n  \n  float fog = pow(exp(-distance(init, p)*0.05), .05);\n \n  vec3 n = norm(p);\n  vec3 r = reflect(cam, n);\n  float ao = sqrt(sqrt(scene(p+n*0.5)+0.5));\n  \n  vec3 col = pow(vec3(0.2,0.1,0.05), vec3(2));\n  col = abs(erot(col,vec3(1,0,0), hsloc*400.));\n  if (matloc == 1) {\n    col = abs(erot(col,vec3(0,1,0), hsloc*900.));\n  } else {\n    col = abs(erot(col,vec3(0,1,0), hsloc*1800.));\n  }\n  float factor = ao*length(sin(r*3.)*0.5+0.5)/sqrt(3.);\n  vec3 brass = mix(col, col*10., factor) + pow(factor, 7.);\n  vec3 bgcol = mix(vec3(0.6,0.3,0.8), vec3(0.3,0.6,.9), smoothstep(0., 1., uv.y+0.5));\n  \n  fragColor.xyz = hit ? mix(bgcol, brass, 1.-perc) : bgcol;\n  fragColor.xyz = sqrt(fragColor.xyz) + hash(hash(uv.x,uv.y),iTime)*0.02;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdScWw.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 194, 234, 234, 326], [327, 327, 367, 367, 459], [516, 516, 546, 546, 621], [623, 623, 661, 661, 725], [764, 764, 790, 790, 1023], [1025, 1025, 1046, 1046, 2271], [2273, 2273, 2292, 2292, 2404], [2428, 2428, 2485, 2485, 3927]], "test": "untested"}
{"id": "wdSyWw", "name": "Day 115", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 19, "viewed": 382, "published": 3, "date": "1586732660", "time_retrieved": "2024-07-30T21:13:22.034353", "image_code": "\n#define pi acos(-1.)\n\n#define tau (2.*pi)\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\nvec3 glow = vec3(0);\n\n\n\nfloat minRadius2 = 0.9;\nfloat fixedRadius2 = 5.7 ;\nfloat foldingLimit = 1.3;\n\nint Iterations = 7;\nfloat Scale = 2.;\n\nvoid sphereFold(inout vec3 z, inout float dz) {\n\tfloat r2 = dot(z,z);\n\tif (r2<minRadius2) { \n\t\t// linear inner scaling\n\t\tfloat temp = (fixedRadius2/minRadius2);\n\t\tz *= temp;\n\t\tdz*= temp;\n\t} else if (r2<fixedRadius2) { \n\t\t// this is the actual sphere inversion\n\t\tfloat temp =(fixedRadius2/r2);\n\t\tz *= temp;\n\t\tdz*= temp;\n\t}\n}\n\nvoid boxFold(inout vec3 z, inout float dz) {\n\tz = clamp(z, -foldingLimit, foldingLimit) * 2.0 - z;\n}\n\n\n#define pmod(p,j) mod(p,j) - 0.5*j\n\nfloat map(vec3 z, float t){\n\tfloat d = 10e7;\n\tvec3 p = z;\n    z.z = pmod(z.z, 10.);\n    \n    \n    for(int i = 0; i < 4;i ++){\n    \tz = abs(z);\n        \n        z.xy *= rot(0.125*pi);\n        //z.t -= 0.2;\n        //z.z -= 0.3;\n    }\n    \n    \n    vec3 q = vec3(z);\n    \n    vec3 j;\n    float jdr;\n    \n\tvec3 offset = z;\n\tfloat dr = 1.;\n\tfor (int n = 0; n < Iterations; n++) {\n\t\tboxFold(z,dr);       // Reflect\n\t\tsphereFold(z,dr);    // Sphere Inversion\n        \n        if(n == 2){\n            j = z;\n            jdr = dr;\n        }\n \t\t\n                z=Scale*z + offset;  // Scale & Translate\n                dr = dr*abs(Scale)+1.0;\n\t}\n    \n    \n    //z = abs(z);\n    //z.y -= 10.4;\n    \n\tfloat r = length(z);\n    \n    \n    \n    d = r/abs(dr);\n    \n    d *= 0.7;\n    \n    d += smoothstep(1.,0.,t*0.75)*0.15;\n    \n    float db = length(j)/abs(jdr);;\n    \n    glow += 0.5/(0.6 + pow( (abs(d) + 0.001)*0.7,2.)*800000.)*0.9;\n    \n    db += 0.001;\n    \n    \n    float att = pow(abs(sin(p.z + iTime + length(p.xy))),50.);\n    glow -= 0.92/(0.04 + pow( (abs(db) + 0.001)*0.7,2.)*16000.)*vec3(0.5,0.9,1.4)*att;\n    \n    \n    \n    d = min(d, db);\n        \n    //d *= 0.7;\n    d = abs(d) + 0.001;\n    \n    //glow -= 0.01/(0.1 + d*d*10.)*vec3(0.7,0.4,0.8);\n    //glow += 0.12/(0.001 + d*d*4000.);\n    \n    \n    return d;\n    \n    \n    //float da = length(z.xyz)/q.w - 0.01;\n    \n        \n    \n    float sc = 0.5;\n    //d = min(d,da);\n    d *= sc;\n    d += smoothstep(1.,0.,t*.5)*0.7;\n    d = abs(d) + 0.003;\n    \n    vec3 c = vec3(1,1.,1.);\n    return d;\n}\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0.,1.,0), dir));\n\tvec3 up = normalize(cross( dir, right));\n\treturn normalize(dir + right*uv.x + up*uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    \n    \n    vec3 col = vec3(0.9,0.6,0.4);\n\n    vec3 ro = vec3(0);\n    ro.z += iTime;\n    \n    //ro.xz -= 4.6;\n    \n    float T = iTime*1./tau + pi*0.25;\n    ro.xy += vec2(cos(T), sin(T))*0.7;\n    \n    vec3 lookAt = vec3(0.001);\n    \n    lookAt.z = ro.z + 4.;\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    float d;\n    vec3 p = ro; float t = 0.; bool hit = false;\n    \n    for(int i = 0; i < 120; i++){\n    \td = map(p, t);\n        if(d < 0.001){\n        \thit = true;\n            //break;\n        }\n\t\tt += d;\n    \tp = ro + rd*t;\n    }\n    \n    \n    col -= glow*0.07;\n    \n    col = max(col, 0.);\n    \n    col = pow(col, vec3(1. + dot(uv,uv)*1.));\n    \n    //col = smoothstep(0.,1.,col);\n    \n    col = pow(col, vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSyWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[290, 290, 337, 337, 613], [615, 615, 659, 659, 715], [754, 754, 781, 781, 2301], [2302, 2302, 2344, 2344, 2523], [2525, 2525, 2582, 2582, 3416]], "test": "untested"}
{"id": "WsScDm", "name": "Spinning lights", "author": "Kanata", "description": "After some absence, I started writing shaders again.", "tags": ["complexnumbers"], "likes": 3, "viewed": 318, "published": 3, "date": "1586729166", "time_retrieved": "2024-07-30T21:13:22.901036", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 res = iResolution.xy,\n          z = ( u* 2. - res) / min(res.x, res.y);\n\n    float t = iTime;\n    float scale = 1.;\n    z *= scale;\n    \n    vec2 a = vec2(cos(1.7 * t), sin(t));\n    vec2 b = vec2(-sin(t), cos(2. * t));\n    \n    float f =  .1/abs(length(z-a) - length(z-b));\n    float g =  .1/abs(length(z-a) + length(z-b));\n\n    O = vec4(vec3(g/f), 1.);\n}\n", "image_inputs": [], "common_code": "const float PI  = 3.141592653589793;\n\nvec3 hsvToRgb(float h, float s, float v) {\n    // h: -π - +π, s: 0.0 - 1.0, v: 0.0 - 1.0\n    h = (h + PI) / (2.* PI) * 360.;\n\n    float c = s; // float c = v * s;\n    float h2 = h / 60.0;\n    float x = c * (1.0 - abs(mod(h2, 2.0) - 1.0));\n    vec3 rgb = (v - c) * vec3(1.0, 1.0, 1.0);\n\n    if (0.0 <= h2 && h2 < 1.0) {\n        rgb += vec3(c, x, 0.0);\n    } else if (1.0 <= h2 && h2 < 2.0) {\n        rgb += vec3(x, c, 0.0);\n    } else if (2.0 <= h2 && h2 < 3.0) {\n        rgb += vec3(0.0, c, x);\n    } else if (3.0 <= h2 && h2 < 4.0) {\n        rgb += vec3(0.0, x, c);\n    } else if (4.0 <= h2 && h2 < 5.0) {\n        rgb += vec3(x, 0.0, c);\n    } else if (5.0 <= h2 && h2 < 6.0) {\n        rgb += vec3(c, 0.0, x);\n    }\n\n    return rgb;\n}\n// hsvToRgb borrowed from\n// https://qiita.com/sw1227/items/4be9b9f928724a389a85\n// (slightly modified by Kanata)\n\n//operations on complex numbers borrowed from\n//https://shadertoyunofficial.wordpress.com/2019/01/02/programming-tricks-in-shadertoy-glsl/\n\n#define re(a) vec2((a).x, 0.)\n#define im(a) vec2(0., (a).y)\n#define cmul(a,b) ( mat2(a, -(a).y, (a).x ) * (b) )\n#define conj(a)     vec2( (a).x, -(a).y)\n#define cinv(a)   ( conj(a) / dot(a, a) )\n#define cdiv(a,b) ( cmul(a, cinv(b)) )\n#define cexp(a)   ( exp((a).x)* vec2(cos((a).y), sin((a).y)) )\n#define clog(a)     vec2( log(length(a)), atan((a).y,(a).x) )\n#define arg(a)\t( atan(a.y, a.x) )\n#define cpow(a,n)   cexp( float(n)* clog(a) )", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsScDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 403]], "test": "untested"}
{"id": "wsSyWW", "name": "Leapmotion on shadertoy", "author": "z0rg", "description": "Use leapmotion on shadertoy through a chrome extension !\nFor the moment it's stable enough to load it as a developer so go check the github page ;).\nhttps://github.com/seb776/ShadertoyLeapmotion\n\n", "tags": ["shadertoy", "leapmotion"], "likes": 3, "viewed": 258, "published": 3, "date": "1586722044", "time_retrieved": "2024-07-30T21:13:23.763729", "image_code": "// The extension code can be found here along with a minituto https://github.com/seb776/ShadertoyLeapmotion\n// Chrome extension https://chrome.google.com/webstore/detail/gadhelfebmbbjkjmnkgpajjaachobjbf/\n// Video demo https://www.youtube.com/watch?v=9G-Jb9_HNrU\n\n// ##### Start of code copied from the chrome extension (button \"Copy GLSL code to clipboard\")\nuniform vec3 LeftHand[28]; uniform vec3 RightHand[28];uniform float LeftConfidence;uniform float RightConfidence;uniform float LeftAvailable; uniform float RightAvailable;\nconst int ELBOW = 0, WRIST = 1, PALM = 2;\nconst int FINGER_THUMB = 3, FINGER_INDEX = 8, FINGER_MIDDLE = 13, FINGER_RING = 18, FINGER_PINKY = 23;\nconst int CARP_POS = 0, MCP_POS = 1, PIP_POS = 2, DIP_POS = 3, TIP_POS = 4;\n// ##### End of code copied from the chrome extension\n\n// ----- LeftHand[N] or RightHand[N]\n// you can use LeftHand[N] or RightHand[N] where N can be ELBOW,WRIST,PALM or\n// FINGER_XXX + YYY_POS to retrieve joints positions.\n// eg :\n// LeftHand[FINGER_MIDDLE + TIP_POS]\n// RightHand[ELBOW]\n//\n// ----- LeftAvailable or RightAvailable\n// 0.0 if not currently tracking 1.0 if it is.\n//\n// ----- LeftConfidence or RightConfidence\n// The confidence parameter (from 0.0 to 1.0) given by the leapmotion SDK.\n// It tells the confidence of the current tracking.\n\n// ##### Any code under this is not specific to the extension\n\n// Function to translate coordinates to our current coordinates\nvec3 coordMix(vec3 p) \n{\n    return p.xzy;\n}\n\n// RAYMARCHING FUNCTIONS\nfloat _add(float a, float b)\n{\n    return min(a, b);\n}\nfloat sph(vec3 p)\n{\n    return length(p)-.1;\n}\n\nvec3 lookat(vec2 uv, vec3 dir)\n{\n  float fov = 1.;\n  uv *= fov;\n  dir = normalize(dir);\n  vec3 right = normalize(cross(dir, vec3(0.,1.,0.)));\n  vec3 up = normalize(cross(dir, right));\n\n  return dir + uv.x * right + uv.y*up;\n}\n\n\n// Raymarching SDF composition\nfloat map(vec3 p)\n{\n    vec3 off = vec3(0.,-2.,0.);\n\tfloat szf = -0.02;\n    vec3 sz = vec3(1.,1.,1.)*szf;\n    float acc = 10.0;\n    if (LeftAvailable > .5)\n    \tacc = min(acc, sph(off+szf*coordMix(LeftHand[0])+p));\n    if (RightAvailable > .5)\n    \tacc = min(acc, sph(off+szf*coordMix(RightHand[0])+p));\n    for (int i = 1; i < 27; ++i)\n    {\n        if (LeftAvailable > .5)\n        \tacc = min(acc, sph(off+szf*coordMix(LeftHand[i])+p));\n        if (RightAvailable > .5)\n        \tacc = min(acc, sph(off+szf*coordMix(RightHand[i])+p));\n    }\n   return acc;\n}\n\nvec3 normal(vec3 p, float d)\n{\n  float xPos = map(p+EPS.xyy);\n  float yPos = map(p+EPS.yxy);\n  float zPos = map(p+EPS.yyx);\n  return (vec3(xPos, yPos,zPos)-d)/EPS.x;\n  return vec3(map(p+EPS.xyy)-map(p-EPS.xyy),\n    map(p+EPS.yxy)-map(p-EPS.yxy),\n    map(p+EPS.yyx)-map(p-EPS.yyx));\n}\n\nvec4 rdr3D(vec2 uv)\n{\n  vec3 orig = vec3(0.,0.,-10.);\n  vec3 lookatpos = vec3(0.);\n  vec3 dir = normalize(lookat(uv, lookatpos-orig));\n  vec3 p = orig + dir;\n\n  for (int i = 0; i <64;++i)\n  {\n    float d = map(p);\n\n    if (d < 0.01)\n    {\n      vec3 norm = normal(p,d);\n      return vec4(norm*.5+.5,1.);\n      vec3 lPos = 3.*vec3(sin(iTime),cos(iTime),0.);\n       return vec4(dot(norm,normalize(lPos-p))*vec3(1.),1.);\n    }\n    p+= dir*d;\n  }\n  return vec4(0.);\n}\n\nvec3 rdrScn(vec2 uv)\n{\n  vec3 land;\n  vec3 light = vec3(100.,200.,197.)/255.;\n  land = mix(vec3(.1,.1,.2),light,sat(1.-length(uv)));\n  vec4 col = rdr3D(uv);\n  land = mix(land, col.xyz, col.w);\n  return land;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xx;\n    \n  uv -= vec2(.5)*iResolution.xy/iResolution.xx;\n  uv*= 1.2;\n    \n  vec3 col = rdrScn(uv);\n\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "const vec3 EPS = vec3(0.01,0.,0.);\n\n\nfloat sat(float a)\n{\n  return clamp(a,0.,1.);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsSyWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1368, 1432, 1456, 1456, 1476], [1478, 1503, 1533, 1533, 1557], [1558, 1558, 1577, 1577, 1604], [1606, 1606, 1638, 1638, 1831], [1834, 1865, 1884, 1884, 2422], [2424, 2424, 2454, 2454, 2707], [2709, 2709, 2730, 2730, 3172], [3174, 3174, 3196, 3196, 3383], [3385, 3385, 3442, 3442, 3613]], "test": "untested"}
{"id": "WdlyRs", "name": "[4kb] The 8th Seal", "author": "evvvvil", "description": "A bleak apocalyptic Swedish fantasy-drama in 4096 bytes.\ncode: evvvvil / DESiRE ^ REBELS ^ HANDSOME HOOLIGANS\nmusic: Virgill / ALCATRAZ\nReleased at Revision 2020.", "tags": ["terrain", "demoscene", "glow", "organic", "monster", "particle", "death", "journey", "4kb", "gloomy", "dismantled", "arthouse"], "likes": 27, "viewed": 985, "published": 3, "date": "1586711951", "time_retrieved": "2024-07-30T21:13:24.870770", "image_code": "//\n//        ¬_______________________¬\n//        [   -----------------   ]\n//        [   evvvvil + Virgill   ]\n//        [   -----------------   ]\n//        ¬_______________________¬\n//\n//         p  r  e  s  e  n  t  s\n//\n//     \t       \"The 8th Seal\"\n//       A bleak apocalyptic Swedish\n//       fantasy-drama in 4096 bytes\n//\n//              code: evvvvil\n//              music: Virgill\n//\n//          g  r  e  e  t  i  n  g  s\n//\n//   Deadliners, Dascon, Mr Vux, Ferris, UNC, LJ\n//   Ponk, Flopine, Alkama, Slerpy, Nusan, yx, Noby\n//   Hoffman, Crundle, Haptix, Blackle, Alia, Subi\n//   Las, Poo-brain, Conspiracy, ASD, Smash, RamonB5\n//   Fairlight, Wrighter, Dan, Soundy, Anat, Razor1911\n//   Bossman, Hellmood, Sensastahl, Farbrausch, Fizzer\n//   Still, Ronny, Triace, Gopher, iq, RGBA, Pixtur\n//   Peisik, Mercury, Slimey, Mantratronic, Alcatraz\n\n#define res iResolution\n\nconst mat2 rot = mat2(cos(2.399),sin(2.399),-sin(2.399),cos(2.399));\n\nvec3 dof(sampler2D tex,vec2 uv,float rad)// Simplyfied version of Dave Hoskins blur\n{\n\tvec3 acc=vec3(0);\n    vec2 pixel=vec2(.005*res.y/res.x,.005),angle=vec2(0,rad);\n   \n\tfor (int j=0;j<80;j++){  \n\t    angle*=rot;\n        vec4 col=texture(tex,uv+pixel*angle);\n\t\tacc+=col.xyz;}\n\treturn acc/80.;\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tvec2 uv = gl_FragCoord.xy / res.xy;\n\tfragColor=vec4(dof(iChannel0,uv,texture(iChannel0,uv).w),1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 21683, "src": "https://soundcloud.com/evvvvil-evvvvil/the-8th-seal", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "//Yeah I promise I will comment all this code line by line, too hungover now, come back another day...\nvec3 t; int scene; vec3 ro,bro; vec4 s1,s2,s3; float tt,g,g2; //uniform vec3 t;    \nfloat smin(float a,float b,float h){float k=clamp((a-b)/h*.5+.5,0.,1.);return mix(a,b,k)-k*(1.-k)*h;}\nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);}\nfloat noi(vec3 p){\n    vec3 f=floor(p),s=vec3(7,157,113); \n    p-=f;vec4 h=vec4(0,s.yz,s.y+s.z)+dot(f,s);\n    p=p*p*(3.-2.*p);\n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z);\n}\nfloat a(float v){ return clamp(t.x-v,0.,5.)*.2;} \nvec2 mp( vec3 p ) \n{\n    vec3 bp,pp;bp=pp=p;bp.z=mod(pp.z+s2.w,50.)-25.;\n    bro=vec3(-noi(p*10.)*.03+noi(p)*.3,noi(5.*sin(p.y)*vec3(noi(1.5*p+tt*.5)))*.2,noi(p*.1)*7.);\n    bp+=bro.x+bro.y-vec3(0,0,sin(p.y*.5+tt)*1.5+sin(p.z*.1)*3.);    \n    vec2 h,t=vec2(bp.y+15.-bro.z*abs(sin(p.x*.1)),5);        \n    t.x=smin(t.x,.6*length(abs(bp.xy)-2.+vec2(-6,s1.x)-bro.z*2.)-4.,5.);\n    pp.z=mod(pp.z+34.,72.)-36.;\n    if(scene>4)t.x=smin(t.x,.63*length(abs(pp.xz+(bro.x+bro.z)*2.-vec2(6,0))-s2.x)-\n             (2.+sin(p.y*.2+s1.w)*2.+sin(p.y*20.)*.03),7.);\n    if(scene<9||p.z>0.)\n    {\n        h=vec2(.7*length(abs(bp.xy-vec2(0,-5))-vec2(0,9))-.1,6);\n        g+=.1/(.1*h.x*h.x*4.+4.*abs(sin(p.z*.1+tt)));\n        t=t.x<h.x?t:h;\n    }\n    pp=p-vec3(0,14,0);\n    if(scene>7){\n        for(int i=0;i<3;i++) {\n            pp=abs(pp)-vec3(2,3,6.+cos(p.y*.1+1.3)*2.);\n            pp.xy*=mat2(cos(1.),sin(1.),-sin(1.),cos(1.));\n        }\n        h=vec2(bo(pp,vec3(130,1,1)),5); t=t.x<h.x?t:h;\n        h=vec2(bo(pp,vec3(130,.5,2.5)),3); t=t.x<h.x?t:h; \n        h=vec2(length(abs(pp.yz)-vec2(1.5,0)),6);\n        g2+=.1/(.1+h.x*h.x*(4.-sin(p.y*p.z*.005+tt*4.)*3.5));t=t.x<h.x?t:h;t.x=max(t.x,-(length(p.xz)-6.));\n    }\n    if(scene>3){\n        h=vec2(s3.x*length(cos(pp*s3.y+bro.z*s3.z+vec3(-s3.w,tt,s3.w))),6);\n        g2+=.1/(.1+h.x*h.x*400.);\n        t=t.x<h.x?t:h;\n    }\n    h=vec2(length(bp+vec3(0,6.+s2.y,-1))-(5.-2.33*sin(p.y*(.4)+3.71-s2.y/2.)-cos(p.z*p.x*2.)*.03),3);\n    t=t.x<h.x?t:h;h=vec2(.8*length(bp+vec3(0,-s2.y,0))-(1.72+.7*sin(p.y*1.2+5.7)),6);\n    h.x=smin(h.x,length(abs(bp.xz)-vec2(s2.z,1))-.1,.5);\n    h.x=max(h.x,-(length(abs(bp+vec3(0,.04-s2.y,1.35))-vec3(.8-abs(sin(p.y*1.62+1.77))*.8,1,0))-.8));    \n    t=t.x<h.x?t:h; t.x*=.6;return t;  \n}\nconst vec4 camArr[] = vec4[13](vec4(37,0,0,-1),vec4(13.4,17,-12.6,-1),vec4(17,0,-5,-1),vec4(-5,-12,-10,1)\n,vec4(-4,1,42,-3),vec4(5,-4,-15,2),vec4(25,0,0,-3),vec4(-5,-5,-30,2),vec4(18,-2,37,-1),vec4(0,-10,-20,3)\n,vec4(0,15,22,2),vec4(0,40,15,2),vec4(0,30,15,2));\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ //Length of 1 bar: 2.8235 second; LENGTH OF ONE SCENE = 4 BAR = 11.294 SECONDS... TOTAL LENGTH 135.528 \t\n    t=vec3(iTime,iResolution.xy);tt=mod(t.x,67.764),scene=int(floor(t.x/11.294));      \n    vec2 h=vec2(smoothstep(0.,1.,a(69.))),z=vec2(.1,camArr[scene].w),\n    uv=(fragCoord.xy/t.yz-.5)/vec2(t.z/t.y,1),e=vec2(.0035,-.0035);  \t\n    s1=mix(vec4(.35,0,.001,-3),vec4(-14,1,.01,0),h.x-abs(sin(a(84.)*3.14)));\n    s2=vec4(14.,max(0.,t.x-106.)*2.,mix(vec2(.5,tt*3.),vec2(-.5,125),a(102.)));\n    s3=mix(vec4(.5,.14,4.4,0),vec4(1,.5,.5,9),h.x);\n    if(scene>7) s1.xw=vec2(-20,7.5),s2.x=23.5;\n    ro=camArr[scene].xyz;\n    ro[abs(int(z.y))-1]+=sign(z.y)*max(0.,t.x-float(scene)*11.294); \n    vec3 cw=normalize(scene==6?vec3(-10,0,0):scene>9?vec3(0,20.+max(0.,t.x-124.234)*4.,-10)-ro:-ro),\n    cu=normalize(cross(cw,vec3(0,1,0))),rd=mat3(cu,normalize(cross(cu,cw)),cw)*normalize(vec3(uv,.5)),\n    al=vec3(5.*vec2(abs(atan(rd.y-1.1,rd.x)),rd.z+tt*.1),0),po,no,lp,co,fo;\n    h.x=0.; for(int i=2;i<5;i++) h.x+=1./float(i)*noi(al*float(i));\n    co=fo=mix(vec3(.1),vec3(.1,.2,.3)+rd.y*.2,s1.y)-length(uv*.7)*.2+h.x*.05;\n  \tfor(int i=0;i<128;i++){\n        h=mp(ro+rd*z.x);\n        if(h.x<s1.z||z.x>120.) break;\n        z.x+=h.x;z.y=h.y;\n    }\n    po=ro+rd*z.x;lp=ro+vec3(0,5,0)-po;\n    no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x);\n    al=z.y==5.?mix(vec3(1.+cos((bro.x+bro.y)*5.)),vec3(.1,.2,.3)+noi(bro),s1.y):vec3(z.y<5.?0:1);\n    co=mix(al*(clamp(mp(po+no*.1).x/.1,0.,1.)*clamp(mp(po+no*.3).x/.3,0.,1.)+.2)*\n           (max(0.,dot(no,normalize(lp)))+smoothstep(0.,1.,mp(po+normalize(lp)*4.1).x/4.1)),\n           fo,min(pow(1.+dot(no,rd),4.),.5));\n    co=mix(fo,co*(1.04-pow(min(1.,length(lp)/(mix(15.,40.,s1.y))),4.)),\n           exp(-.0001*(2.-s1.y*1.5)*z.x*z.x*z.x))-a(137.);   \n  \tfragColor = vec4(pow(co+g*.03*(scene>3?1.:1.-ceil(sin(10.*fract(mod(tt,1.06)))))+g2*(1.-a(141.))*.1,\n                      vec3(.65,.7,.7)),-.5+clamp(z.x*.1+.5,0.,.9));\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlyRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[955, 955, 1040, 1040, 1251], [1252, 1252, 1306, 1306, 1408]], "test": "untested"}
{"id": "ttG3R1", "name": "access control", "author": "blackle", "description": "needs 1920x1080 to look right. press space to re-render\n\nhttps://www.pouet.net/prod.php?which=85263", "tags": ["revision2020"], "likes": 13, "viewed": 679, "published": 3, "date": "1586701437", "time_retrieved": "2024-07-30T21:13:26.032663", "image_code": "#define RADIUS 2.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n\t// algorithm stolen from the gimp oilify filter :3\n\tfloat hist[256];\n\tfor (int i = 0 ; i < 256 ; i++ ) hist[i] = 0.;\n\tfloat histmax = 0.;\n\tfloat rad = RADIUS;\n\n\tfloat mainsamp = 0.;\n\tfor(float i = -rad; i <= rad; i+=1.){\n\t\tfor(float j = -rad; j <= rad; j+=1.){\n\t\t\tvec2 off = vec2(i,j);\n\t\t\tif (length(off) > rad) continue;\n\t\t\tfloat samp = pow(clamp(texelFetch(iChannel0, ivec2(fragCoord.xy + off), 0).x,0.,1.),2.);\n\t\t\tif (i == 0. && j == 0.) mainsamp = samp;\n\t\t\tint pos = int(samp*254.);\n\t\t\thist[pos] += 1.;\n\t\t\thistmax =max(histmax,hist[pos]);\n\t\t  }\n\t}\n\tfloat color = 0.;\n\tfloat acc = 0.;\n\tfor (int i = 0; i < 255; i++ ){\n\t\tfloat weight = pow(hist[i]/histmax, 8.);\n\t\tcolor += (float(i)/255.) * weight;\n\t\tacc += weight;\n\t}\n\t\n\tfragColor = vec4(sqrt(mix(color/acc, mainsamp, 0.25)));\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttG3R1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3djcDh", "name": "Digital Uhr", "author": "Janniboy", "description": "This is a basic digital clock that shows hours, minutes and seconds.", "tags": ["clock", "uhr"], "likes": 1, "viewed": 365, "published": 3, "date": "1586700105", "time_retrieved": "2024-07-30T21:13:27.145687", "image_code": "#define red vec3(1.0,0.0,0.0)\n#define green vec3(0.0,1.0,0.0)\n#define blue vec3(0.0,0.0,1.0)\n#define yellow vec3(1.0,1.0,0.0)\n\nconst bool gradient = true; //if the lines should have rounded edges\n\nvec4 BG(vec2 fragCoord) {\n\tvec4 rgi = mix(vec4(vec3(1.0,0.0,0.0),1.0), vec4(vec3(0.0,1.0,0.0),1.0), fragCoord.x/iResolution.x);\n    vec4 byi = mix(vec4(vec3(0.0,0.0,1.0),1.0), vec4(vec3(1.0,1.0,0.0),1.0), fragCoord.x/iResolution.x);\n    return mix(rgi, byi, fragCoord.y/iResolution.y);\n}\n\nvec4 CombineLayers(vec4 topl, vec4 bottoml) {\n\treturn mix(bottoml, topl, topl.a);\n}\n\nfloat DistLinePoint(vec2 P1, vec2 P2, vec2 P0) {\n\treturn abs((P2.y-P1.y)*P0.x-(P2.x-P1.x)*P0.y+P2.x*P1.y-P1.x*P2.y)/sqrt(pow((P2.y-P1.y), 2.0)+pow((P2.x-P1.x),2.0));\n}\n\nfloat Line(vec2 L1, vec2 L2, float width, vec2 fragCoord) {\n    float outval = 1.0;\n    float lengthL = distance(L1, L2);\n    \n    float deltax = L1.x-L2.x;\n    float deltay = L1.y-L2.y;\n    \n    vec2 borderPoint1 = vec2(L1.x+deltay, L1.y-deltax);\n    vec2 borderPoint2 = vec2(L2.x+deltay, L2.y-deltax);\n    \n    if (max(DistLinePoint(L1, borderPoint1, fragCoord), DistLinePoint(L2, borderPoint2, fragCoord)) > lengthL) {\n    \toutval = min(distance(L1, fragCoord), distance(L2, fragCoord)) / width;\n    } else {\n    \toutval = DistLinePoint(L1, L2, fragCoord) / width;\n    }\n    if (gradient) {\n    \treturn min(1.0, 1.0 - outval);\n    } else {\n        if (1.0 - outval >= 0.5) {\n        \treturn 1.0;\n        } else {\n        \treturn 0.0;\n        }\n    }\n}\nfloat Dot(float r, float width, vec2 fragCoord) {\n\tif (gradient) {\n    \treturn min(1.0, 1.0 - ( distance(iResolution.xy/2.0, fragCoord) - r ) / width);\n    } else {\n        if (1.0 - ( distance(iResolution.xy/2.0, fragCoord) - r ) / width >= 0.5) {\n        \treturn 1.0;\n        } else {\n        \treturn 0.0;\n        }\n    }\n}\nfloat Circle(float r, float width, vec2 fragCoord) {\n    if (gradient) {\n    \treturn min(1.0, 1.0 - abs( distance(iResolution.xy/2.0, fragCoord) - r ) / width);\n    } else {\n        if (1.0 - abs( distance(iResolution.xy/2.0, fragCoord) - r ) / width >= 0.5) {\n        \treturn 1.0;\n        } else {\n        \treturn 0.0;\n        }\n    }\n    \n}\nfloat CircleLine(float r, float angle, float width, vec2 fragCoord) {\n    float deltax = sin(radians(angle))*r;\n\tfloat deltay = cos(radians(angle))*r;\n    vec2 P2 = vec2((iResolution.xy/2.0).x+deltax, (iResolution.xy/2.0).y+deltay);\n    return Line(iResolution.xy/2.0, P2, width, fragCoord);\n}\nfloat CircleLineSegment(float r1, float r2, float angle, float width, vec2 fragCoord) {\n\tfloat deltax1 = sin(radians(angle))*r1;\n\tfloat deltay1 = cos(radians(angle))*r1;\n    vec2 P1 = vec2((iResolution.xy/2.0).x+deltax1, (iResolution.xy/2.0).y+deltay1);\n    \n    float deltax2 = sin(radians(angle))*r2;\n\tfloat deltay2 = cos(radians(angle))*r2;\n    vec2 P2 = vec2((iResolution.xy/2.0).x+deltax2, (iResolution.xy/2.0).y+deltay2);\n    \n    return Line(P1, P2, width, fragCoord);\n}\n\nfloat getHours() {\n\treturn floor(iDate[3]/3600.0);\n}\nfloat getMinutes() {\n\treturn floor((iDate[3]-getHours()*3600.0)/60.0);\n}\nfloat getSeconds() {\n\treturn floor(iDate[3]-getHours()*3600.0-getMinutes()*60.0);\n}\n\nfloat HourHand(vec2 fragCoord) {\n\treturn CircleLine(min(iResolution.x*5.0/12.0, iResolution.y/2.0-30.0)/2.0, mod(30.0*getHours(), 360.0), min(iResolution.x*5.0/12.0, iResolution.y/2.0-30.0)*4.0/150.0, fragCoord);\n}\nfloat MinuteHand(vec2 fragCoord) {\n\treturn CircleLine(min(iResolution.x*5.0/12.0, iResolution.y/2.0-30.0)*2.0/3.0, getMinutes()*6.0, min(iResolution.x*5.0/12.0, iResolution.y/2.0-30.0)*4.0/150.0, fragCoord);\n}\nfloat SecondHand(vec2 fragCoord) {\n\treturn CircleLine(min(iResolution.x*5.0/12.0, iResolution.y/2.0-30.0)*22.0/30.0, getSeconds()*6.0, min(iResolution.x*5.0/12.0, iResolution.y/2.0-30.0)*2.0/150.0, fragCoord);\n}\n\nfloat HourMarks(vec2 fragCoord) {\n    float maxVal = 0.0;\n    for (int i = 0; i < 12; i++) {\n    \tmaxVal = max(maxVal, CircleLineSegment(min(iResolution.x*5.0/12.0, iResolution.y/2.0-30.0)*13.0/15.0, min(iResolution.x*5.0/12.0, iResolution.y/2.0-30.0), float(i)*30.0, min(iResolution.x*5.0/12.0, iResolution.y/2.0-30.0)*3.0/150.0, fragCoord));\n    }\n\treturn maxVal;\n}\nfloat MinuteMarks(vec2 fragCoord) {\n\tfloat maxVal = 0.0;\n    for (int i = 0; i<60; i++) {\n        if (mod(float(i), 5.0) != 0.0) {\n        \tmaxVal = max(maxVal, CircleLineSegment(min(iResolution.x*5.0/12.0, iResolution.y/2.0-30.0)*13.0/15.0, min(iResolution.x*5.0/12.0, iResolution.y/2.0-30.0)*27.0/30.0, float(i)*6.0, min(iResolution.x*5.0/12.0, iResolution.y/2.0-30.0)*3.0/150.0, fragCoord));\n        }\n    }\n    return maxVal;\n}\n\nfloat Dial(vec2 fragCoord) {\n\tfloat circ = Circle(min(iResolution.x*5.0/12.0, iResolution.y/2.0-30.0), min(iResolution.x*5.0/12.0, iResolution.y/2.0-30.0)*3.0/150.0, fragCoord);\n    float HourMarks = HourMarks(fragCoord);\n    float MinuteMarks = MinuteMarks(fragCoord);\n    float MiddleAxis = Dot(min(iResolution.x*5.0/12.0, iResolution.y/2.0-30.0)/150.0, min(iResolution.x*5.0/12.0, iResolution.y/2.0-30.0)*4.0/150.0, fragCoord);\n    return max(circ, max(HourMarks, max(MinuteMarks, MiddleAxis)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float HourH = HourHand(fragCoord);\n    float MinuteH = MinuteHand(fragCoord);\n    float SecondH = SecondHand(fragCoord);\n    float Dial = Dial(fragCoord);\n    \n    float mask = max(Dial, max(HourH, max(MinuteH, SecondH)));\n    \n    float circle = float(distance(iResolution.xy/2.0, fragCoord) < min(iResolution.x*5.0/12.0, iResolution.y/2.0-30.0));\n    \n    fragColor = CombineLayers(vec4(mask), BG(fragCoord)*(1.0-circle)+BG(fragCoord)*0.7*circle);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djcDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[197, 197, 222, 222, 484], [486, 486, 531, 531, 569], [571, 571, 619, 619, 738], [740, 740, 799, 799, 1494], [1495, 1495, 1544, 1544, 1820], [1821, 1821, 1873, 1873, 2163], [2164, 2164, 2233, 2233, 2457], [2458, 2458, 2545, 2545, 2935], [2937, 2937, 2955, 2955, 2989], [2990, 2990, 3010, 3010, 3062], [3063, 3063, 3083, 3083, 3146], [3148, 3148, 3180, 3180, 3362], [3363, 3363, 3397, 3397, 3572], [3573, 3573, 3607, 3607, 3784], [3786, 3786, 3819, 3819, 4153], [4154, 4154, 4189, 4189, 4585], [4587, 4587, 4615, 4615, 5087], [5089, 5089, 5146, 5146, 5602]], "test": "untested"}
{"id": "td2cDW", "name": "Collapse", "author": "WaifuFarmer", "description": "My first public shader, I'm playing around with twists and lattices at the moment, want to do 3D fractally stuff next, if you have any resources I'll gladly accept to read them :)\n\nPlease roast me in an educative way, I'm willing to learn :)", "tags": ["3d", "raymarching", "raymarching", "ray", "cube", "cubes", "marching"], "likes": 12, "viewed": 650, "published": 3, "date": "1586696921", "time_retrieved": "2024-07-30T21:13:28.039298", "image_code": "#define MAX_STEPS 1280\n#define MAX_DIST 1280.\n#define E 0.01\n#define PI 3.141592\n#define MYTIME iTime * 1.\n\n// Turn to 1 to activate displacement mapping\n#define DISPLACEMENT_MAPPING 1\n\nvec3 rotX(vec3 v, float a)\n{\n    return vec3(v.x, v.y * cos(a) - v.z * sin(a), v.y * sin(a) + v.z * cos(a));\n}\n\nvec3 rotY(vec3 v, float a)\n{\n    return vec3(v.x * cos(a) + v.z * sin(a), v.y, v.z * cos(a) - v.x * sin(a));\n}\n\nvec3 rotZ(vec3 v, float a)\n{\n    return vec3(v.x * cos(a) - v.y * sin(a), v.x * sin(a) + v.y * cos(a), v.z);\n}\n\nvec3 modSDF(vec3 p, vec3 c)\n{\n    return mod(p + 0.5 * c, c) - 0.5 * c;\n}\n\nvec3 modSDFlim( in vec3 p, in float c, in vec3 l)\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\nvec3 twistSDF(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return q;\n}\n\nfloat sdfBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// blackbody by aiekick : https://www.shadertoy.com/view/lttXDn\n\n// -------------blackbody----------------- //\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\n\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// -------------blackbody----------------- //\n\n\nfloat scene(vec3 p)\n{\n    float d = 10000.;\n    float bd1 = sdfBox(\n        twistSDF(\n            modSDFlim(\n                twistSDF(p - vec3(0., 12., 0.), smoothstep(0.30, 0.20, abs(sin(MYTIME))) * 0.02),\n                12., vec3(1. + smoothstep(0.45, 0.55, abs(sin(MYTIME))) * floor(abs(mod(MYTIME / (PI), 16.) - 8.)), 1. + smoothstep(0.45, 0.55, abs(sin(MYTIME))) * floor(abs(mod(MYTIME / (PI), 16.) - 8.)), 1. + smoothstep(0.45, 0.55, abs(sin(MYTIME))))), smoothstep(0.70, 0.80, abs(sin(MYTIME))) * -0.1),\n                       vec3(4. + smoothstep(0.25, 0.75, abs(sin(MYTIME * 2.))),4. + smoothstep(0.25, 0.75, abs(sin(MYTIME * 2.))),4. + smoothstep(0.25, 0.75, abs(sin(MYTIME * 2.)))));\n    if (DISPLACEMENT_MAPPING == 1)\n    \tbd1 += sin(p.x / 2. * abs(mod(iTime, 6.) - 3.)) * 1. * sin(p.y / 2. * abs(mod(iTime, 6.) - 3.)) * 1. * sin(p.z / 2. * abs(mod(iTime, 6.) - 3.)) * 1.;\n    float bd2 = sdfBox(modSDF(p - vec3(0., -24., 0.), vec3(10., 0., 10.)), vec3(4.5,4.5,4.5)) * 1.;\n    d = min(bd1, d);\n    d = min(bd2, d);\n    return d;\n}\n\n\nvec2 march(vec3 ro, vec3 rd)\n{\n    float dO = 0.;\n    float mind = 10000.;\n    for (int steps = 0; steps < MAX_STEPS; steps++)\n    {\n        vec3 p = ro + rd * dO;\n        float dS = scene(p);\n        if (steps == 3)\n            mind = dS;\n        dO += dS;\n        if (dS < E || dO > MAX_DIST)\n            break;\n    }\n    return vec2(dO, mind);\n}\n\nvec3 normal(vec3 p)\n{\n    float d = scene(p);\n    vec2 e = vec2(0.001, 0);\n    \n    vec3 n = d - vec3(\n        \t\tscene(p - e.xyy),\n                scene(p - e.yxy),\n                scene(p - e.yyx));\n    return (normalize(n));\n}\n\nfloat light(vec3 p, vec3 n)\n{\n    vec3 lightPos = vec3(-250. * sin(MYTIME), 75., -250. * cos(MYTIME));\n    vec3 l = normalize(lightPos - p);\n    \n    float dif = clamp(dot(l, n), 0., 1.);\n    vec2 d = march(p+n*E * 30., l);\n    if (d.x < length(lightPos - p))\n        \tdif *= 0.1;\n    \n    return (dif*0.3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord - .5 * iResolution.xy) / iResolution.y);\n    \n    vec3 ro = vec3(-235. * sin(iTime / 2.), 15. + sin(iTime / 2.) * 15., -235. * cos(iTime / 2.));\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n    //rd = rotX(rd, PI / 8.);\n    rd = rotY(rd, iTime / 2.);\n    \n    vec2 d = march(ro, rd);\n    \n    vec3 p = ro + rd * d.x;\n    vec3 n = normal(p);\n    p += n * E * 10.;\n    float dif = light(p, n);\n\tvec3 col = vec3(0);\n    if (d.x < MAX_DIST * 0.9)\n    {\n    \tcol = blackbody(d.y* (p.y + 19.2) * 2. * (50. - abs(mod(p.y + MYTIME * 50., 100.) - 50.)));\n        col.xyz = col.zyx;\n        col.xy *= 0.5;\n        col.x *= uv.x;\n        col.y *= uv.y;\n        if (col.z > 0.001)\n        {\n        \tcol = 0.5 * (1. - col);\n            col = vec3(col.z, col.z, (col.x + col.y) / 2.);\n      \t    col.x = col.x / 2. + col.z * uv.x;\n      \t    col.y = col.y / 2. + col.z * uv.y;\n        }\n        col /= 2.;\n    }\n    col +=  vec3(dif / 2.,dif / 2., dif / 2.);\n    vec3 rr = rd - (2. * n * (dot(rd, n)));\n    vec2 d2 = march(p, rr);\n    vec3 p2 = p + rr * d2.x;\n    vec3 n2 = normal(p2);\n    dif = light(p2, n2);\n    if (d.x < MAX_DIST * 0.9)\n    {\n    \tvec3 col2 = blackbody(d2.y* (p.y + 19.2) * 2. * (50. - abs(mod(p.x * p.z / 30. + 25. + MYTIME * 50., 100.) - 50.)));\n        col2 /= 1.2;\n        col += col2;\n    }\n    col += vec3(dif / 2., dif / 2., dif / 2.);\n    //col = pow(col, vec3(0.454545));\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2cDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[186, 186, 214, 214, 296], [298, 298, 326, 326, 408], [410, 410, 438, 438, 520], [522, 522, 551, 551, 595], [597, 597, 648, 648, 689], [691, 691, 727, 727, 857], [859, 859, 891, 891, 978], [1314, 1314, 1342, 1342, 1667], [1717, 1717, 1738, 1738, 2760], [2763, 2763, 2793, 2793, 3111], [3113, 3113, 3134, 3134, 3341], [3343, 3343, 3372, 3372, 3652], [3654, 3654, 3711, 3711, 5162]], "test": "untested"}
{"id": "tdjyDW", "name": "A point of view", "author": "abelu", "description": "Playing around virtual camera and pseudo-3d.", "tags": ["pseudo3d", "3dtranslation"], "likes": 3, "viewed": 339, "published": 3, "date": "1586693966", "time_retrieved": "2024-07-30T21:13:28.842151", "image_code": "#define MAX_ITEMS_HALF 3.0\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nvec3 rotate_3d(vec3 item, vec3 rotation) {\n    vec2 x = vec2(cos(rotation.x), sin(rotation.x));\n    vec2 y = vec2(cos(rotation.y), sin(rotation.y));\n    vec2 z = vec2(cos(rotation.z), sin(rotation.z));\n\n    return item *= mat3(\n        1., 0., 0.,\n        0., x.x, -x.y,\n        0., x.y, x.x\n    ) * mat3(\n        y.x, 0., y.y,\n        0., 1., 0.,\n        -y.y, 0., y.x\n    ) * mat3(\n        z.x, -z.y, 0.,\n        z.y, z.x, 0.,\n        0., 0., 1.\n    );\n}\n\nvec3 get_intersection_point(\n    vec2 st,\n    vec3 origin, \n    vec3 look_at, \n    float zoom\n) {\n    vec3 forward = normalize(look_at - origin);\n    vec3 right = cross(forward, vec3(0., 1., 0.));\n    vec3 up = cross(forward, right);\n\n    vec3 center = origin + forward * zoom;\n\n    return center + right * st.x + up * st.y;\n}\n\nfloat get_point_distance(vec3 point, vec3 origin, vec3 direction) {\n    return length(cross(point - origin, direction)) / length(direction);\n}\n\nfloat animate(float from, float to, float current_step) {\n    return sin(smoothstep(from, to, current_step) * PI * 0.5);\n}\n\nfloat get_point_color(\n    vec3 point, \n    vec3 origin, \n    vec3 direction,\n    float animation_step\n) {\n    float distance = get_point_distance(point, origin, direction);\n\n    return \n        smoothstep(0.2, 0.05, distance) * (\n            1.2 -\n            animate(0., 0.5, animation_step) + \n            animate(0.6, 1.0, animation_step)\n        ) +\n        smoothstep(0.1, 0.07, distance);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord/iResolution.xy;\n\n    float animation_step = fract(iTime * 0.2);\n\n    vec3 rotation = vec3(\n        0.0, \n        animate(0.3, 0.6, animation_step) * PI * 0.5,\n        animate(0.6, 1.1, animation_step) * PI * 0.5\n    );\n\n    st -= vec2(0.5);\n    st.x *= iResolution.x / iResolution.y;\n\n    vec3 look_at = vec3(0.0);\n    vec3 ray_origin = rotate_3d(\n        vec3(0.0, 0.0, -0.1 + animate(0.0, 0.33, animation_step) * -4.0),\n        rotation\n    );\n    vec3 intersection = get_intersection_point(\n        st,\n        ray_origin,\n        look_at,\n        1.0\n    );\n    vec3 ray_direction = intersection - ray_origin;\n\n    float color = 0.0;\n\n    color += length(st) * 0.5;\n\n    for (float i = -MAX_ITEMS_HALF; i <= MAX_ITEMS_HALF; i += 1.0) {\n        for (float j = -MAX_ITEMS_HALF; j <= MAX_ITEMS_HALF; j += 1.0) {\n            for (float k = -MAX_ITEMS_HALF; k <= MAX_ITEMS_HALF; k += 1.0) {\n                color += get_point_color(\n                    vec3(i, j, k),\n                    ray_origin, \n                    ray_direction,\n                    animation_step\n                );        \n            }\n        }\n    }\n\n    st += vec2(0.5);\n\n    fragColor = vec4(\n        vec3(color * st.y, color * st.x, color),\n        1.0\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjyDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 124, 124, 538], [540, 540, 637, 637, 866], [868, 868, 935, 935, 1010], [1012, 1012, 1069, 1069, 1134], [1136, 1136, 1242, 1242, 1533], [1535, 1535, 1590, 1590, 2856]], "test": "untested"}
{"id": "ws2yWz", "name": "Projective Easter Egg", "author": "mla", "description": "It's Easter, it's an egg, it's projective.", "tags": ["egg", "projective", "easter"], "likes": 4, "viewed": 335, "published": 3, "date": "1586669845", "time_retrieved": "2024-07-30T21:13:29.617079", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Projective Easter Egg\n// Matthew Arcus, mla, 2020.\n//\n// Mouse, <up> and <down> to move around\n//\n////////////////////////////////////////////////////////////////////////////////\n\nvec3 lightdir = vec3(0,2,1);\n\nfloat PI = 3.14159;\n\nfloat segment(vec3 p, vec3 q, vec3 r) {\n  // Rebase to origin at q  \n  p -= q; r -= q;\n  // t*r is orthogonal projection of p onto qr.\n  float t = clamp(dot(p,r)/dot(r,r), 0.0, 1.0);\n  return distance(p,t*r);\n}\n\nfloat scene(vec3 p, out int type) {\n  p = abs(p);\n  if (p.x < p.y) p.xy = p.yx;\n  if (p.y < p.z) p.yz = p.zy;\n  if (p.x < p.y) p.xy = p.yx;\n  float d = 1e8,d1;\n  d1 = length(p)-1.0;\n  if (d1 < d) { d = d1; type = 0; }\n  d1 = segment(p,vec3(1,1,1),vec3(1,1,-1))-0.1;\n  if (d1 < d) { d = d1; type = 1; }\n  d1 = distance(p,vec3(1,1,1))-0.2;\n  if (d1 < d) { d = d1; type = 2; }\n  return d;\n}\n\nfloat de(vec4 p) {\n  p /= p.w;\n  float t = length(p.xyz);\n  // This gets rid of \"line at infinity\", which otherwise shrinks\n  // all distances to 0.\n  if (t > 100.0) p.xyz *= 100.0/t;\n  int type;\n  return scene(p.xyz,type);\n}\n\nvec4 grad(vec4 p) {\n  // 4 dimensional gradient of distance field\n  // First order seems to be OK for our purposes -\n  // just want to scale the distance field.\n  float eps = 1.0/256.0;\n  vec2 e = vec2(eps, 0.0);\n  float t = de(p);\n  return vec4(de(p + e.xyyy) - t,\n              de(p + e.yxyy) - t,\n              de(p + e.yyxy) - t,\n              de(p + e.yyyx) - t)/eps;\n}\n\nmat4 A = mat4(0.8,0,0,0,\n              0,1,0,0,\n              0,0,1,0,\n              0,0,0,1);\n\nfloat eyesign = 1.0; // Sign of distance field at eye.\n\nfloat eval(vec4 p) {\n  p = A*p;\n  float d = de(p);\n  vec3 g = transpose(mat3x4(A))*grad(p);\n  d /= length(g);\n  return eyesign*d;\n}\n\nfloat eval(vec3 p) {\n  return eval(vec4(p,1));\n}\n\nvec3 getnormal(vec3 p) {\n  float eps = 0.0125;\n  vec2 e = vec2(eps, 0.0);\n  return normalize(vec3(eval(p + e.xyy) - eval(p - e.xyy),\n                        eval(p + e.yxy) - eval(p - e.yxy),\n                        eval(p + e.yyx) - eval(p - e.yyx)));\n}\n\nfloat maxdist = 10.0;\nfloat fogdist = 4.0;\nfloat march(vec3 q, vec3 r) {\n  float t = 0.1;\n  int numsteps = 200;\n  float precis = 1e-3;\n  for (int i = 0; i < numsteps; i++) {\n    vec3 p = q+t*r;\n    float d = eval(p);\n    if (abs(d) < precis) return t;\n    t += min(0.5,0.8*d);\n    if (t < 0.0 || t > maxdist) break;\n  }\n  return -1.0;\n}\n\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 getcolor(vec3 p) {\n  int type;\n  vec4 p4 = A*vec4(p,1);\n  p = p4.xyz/p4.w;\n  scene(p,type);\n  if (type == 0) {\n    float phi = atan(p.x/length(p.yz)); //[-PI/2..+PI/2]\n    float rho = atan(p.y,p.z);\n    vec3 color = hsv2rgb(vec3(0.3+0.4*(0.5+phi/PI),1,1));\n    //vec3 color = hsv2rgb(vec3(0.5+phi/PI,1,1));\n    color *= 0.5+0.5*cos(32.0*phi+rho);\n    return color;\n  } else if (type == 1) {\n    return vec3(0.02);\n  } else if (type == 2) {\n    return 0.5*vec3(1,0.75,0);\n  } else {\n    return vec3(0,1,1);\n  }\n}\n\nvoid init() {\n  float time = 0.5*iTime;\n  A *= mat4(cos(time),0,0,sin(time),\n            0,1,0,0,\n            0,0,1,0,\n            -sin(time),0,0,cos(time));\n  A *= mat4(1,0,0,0,\n            0,cos(time),sin(time),0,\n            0,-sin(time),cos(time),0,\n            0,0,0,1);\n}\n\nvec3 background = vec3(0,0,0.01);\n\nvec3 raycolor(vec3 q, vec3 r) {\n  float t = march(q,r);\n  if (t < 0.0) return background;\n  vec3 p = q+t*r;\n  vec3 normal = getnormal(p);\n  if (dot(normal,r) > 0.0) normal = vec3(0);\n  vec3 color = getcolor(p);\n  vec3 speccolor = color;\n  float ambient = 0.5;\n  float diffuse = 0.3*clamp(dot(normal,lightdir),0.0,1.0);\n  color *= ambient+diffuse;\n  float specular = pow(max(0.0,dot(reflect(lightdir,normal),r)),10.0);\n  color += 0.8*specular*speccolor;\n  color = mix(color,background,clamp((t-fogdist)/(maxdist-fogdist),0.0,1.0));\n  return color;\n}\n\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 rotateframe(vec3 p) {\n  if (iMouse.x > 0.0) {\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  {\n    float t = 0.0; // iTime;\n    p.yz = rotate(p.yz,0.5+t*0.125);\n    p.zx = rotate(p.zx,0.5+t*0.1);\n  }\n  return p;\n}\n\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n  init();\n  vec2 z = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  float eyedist = 4.0;\n  eyedist *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  fogdist = eyedist;\n  maxdist = 2.0*eyedist;\n  vec3 eye = vec3(0,0,eyedist);\n  vec3 ray = vec3(z,-2);\n  eye = rotateframe(eye);\n  eyesign = sign(eval(eye));\n  ray = rotateframe(ray);\n  ray = normalize(ray);\n  lightdir = rotateframe(lightdir);\n  lightdir = normalize(lightdir);\n  vec3 col = raycolor(eye,ray);\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0) {\n      t = vec4(0);\n    } else {\n      t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2yWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[318, 318, 357, 386, 528], [530, 530, 565, 565, 917], [919, 919, 937, 937, 1144], [1146, 1146, 1165, 1306, 1520], [1674, 1674, 1694, 1694, 1805], [1807, 1807, 1827, 1827, 1855], [1857, 1857, 1881, 1881, 2111], [2156, 2156, 2185, 2185, 2449], [2451, 2451, 2478, 2478, 2654], [2656, 2656, 2679, 2679, 3172], [3174, 3174, 3187, 3187, 3451], [3488, 3488, 3519, 3519, 4036], [4038, 4038, 4074, 4074, 4126], [4128, 4128, 4154, 4154, 4494], [4545, 4545, 4570, 4570, 4618], [4619, 4619, 4642, 4642, 4674], [4676, 4676, 4727, 4727, 5253]], "test": "untested"}
{"id": "WdjcDW", "name": "blade", "author": "lennyjpg", "description": "dfgdfgdfgdfg", "tags": ["dfgdfgdfg"], "likes": 1, "viewed": 273, "published": 3, "date": "1586661280", "time_retrieved": "2024-07-30T21:13:30.469801", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;    \n    uv.x+=uv.y*0.2;\n    float t = iTime * 0.2;\n    t*= uv.y > fract(uv.x*2.0)? 1.0: -1.0;\n    uv.x += t;\n    float y = uv.y;\n    float e = uv.x*40.;\n    float d = tan(e)*0.1+0.4+sin(uv.x*5.5)*0.1;\n    float k = smoothstep(abs(y+0.5)*0.5,y*0.3,d);\n    fragColor = vec4(k);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdjcDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 375]], "test": "untested"}
{"id": "wsByzw", "name": "Mandelbulb_rainbow", "author": "elle", "description": "3D fractal -> http://blog.hvidtfeldts.net/index.php/2011/06/distance-estimated-3d-fractals-part-i/\nhsv2rgb -> https://www.shadertoy.com/view/MsS3Wc", "tags": ["fractal", "mandelbulb"], "likes": 5, "viewed": 386, "published": 3, "date": "1586657482", "time_retrieved": "2024-07-30T21:13:31.240738", "image_code": "vec3 rotate(vec3 p, float angleX, float angleY)\n{\n    float cosA = cos(angleY);\n\tfloat sinA = sin(angleY);\n\tvec3 r = vec3(p.x, sinA * p.z + cosA * p.y, cosA * p.z - sinA * p.y);\n    cosA = cos(angleX);\n\tsinA = sin(angleX);\n\treturn (-vec3(cosA * r.x - sinA * r.z, r.y, sinA * r.x + cosA * r.z));\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0,4.0,2.0),6.0) - 3.0) - 1.0, 0.0, 1.0);\n\treturn (c.z * mix(vec3(1.0), rgb, c.y));\n}\n\nfloat distSphere(vec3 p, float r)\n{\n\treturn (length(p) - r);\n}\n\nbool backgr = false;\n\nfloat distanceEstimate(vec3 p)\n{\n    float bailout = 2.0;\n\tfloat dSphere = -distSphere(p, 12.0);\t\n\tvec3 v = p;\n\tfloat r = 0.0;\n\tfloat dr = 1.0;\n\tfloat power = abs(cos(iTime * 0.02)) * 10.0 + 2.0;\n\tfor(float n = 0.0; n <= 8.0; n++)\n\t{\n\t\tr = length(v);\n\t\tif(r > bailout)\n            break;\n        // convert to polar coordinate\n\t\tfloat theta = acos(v.z / r);\n\t\tfloat phi = atan(v.y, v.x);\n\t\tdr = pow(r, power - 1.0) * power * dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat vr = pow(r, power);\n\t\ttheta = theta * power;\n\t\tphi = phi * power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tv = vr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n        \n        v += p;\n\t}\n\tfloat dFractal = 0.50 * log(r) * r / dr;\t\n\tbackgr = dSphere < dFractal ? true : false;\n\treturn (min(dFractal, dSphere));\n}\n\nvec3 getNormal(vec3 pos, float dist)\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n\treturn normalize(vec3(\n           distanceEstimate(pos + eps.xyy),\n           distanceEstimate(pos + eps.yxy),\n           distanceEstimate(pos + eps.yyx)) - dist);\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd, in float k)\n{\n    float res = 1.0;\n    float t = 0.0;\n    for(int i = 0; i < 64; i++)\n    {\n        float d = distanceEstimate(ro + rd * t);\n        res = min(res, k * d/t);\n        if(res < 0.001)\n            break;\n        t += clamp(d, 0.01, 0.2);\n    }\n    return (clamp(res, 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 aspectRatio = vec2(iResolution.x/iResolution.y, 1.0);\n\tvec2 uv = aspectRatio * (fragCoord.xy / iResolution.xy - 0.5);\n    vec2 mouse = 7.0 * (iMouse.xy / iResolution.xy - 0.5);\n    vec3 ro = rotate(vec3(0.0, 0.0, 2.5), mouse.x, mouse.y);\n    vec3 rd = -rotate(vec3(uv, 1.0), mouse.x, mouse.y);  \n    vec3 light = rotate(vec3(0.0, 0.3, 0.77), mouse.x, mouse.y);\n    vec3 lightColor = vec3(0.8, 0.9, 1.0);\n    vec3 material;\n    vec3 color;\n    float eps = 0.002;\n\tfloat dist;\n\tfor(float n = 0.0; n < 200.0; n++)\n    {\n\t\tdist = distanceEstimate(ro);\n\t\tif(dist < eps)\n\t\t\tbreak;\n\t\tro += rd * dist * 0.5;\n\t}\n\tif(backgr == true)\n\t{ \n        color = vec3(0.3, 0.8, 1.0) * (0.5 - 0.4 * uv.x);\n\t\tfragColor = vec4(color, 1.0);\n\t\treturn;\n\t}\n\tvec3 norm = getNormal(ro, dist);\n\tmaterial = hsv2rgb(vec3(dot(ro, ro) - 0.27, 1.2, 1.0));\n\tvec3 lightDir = normalize(light - rd);   \n\tfloat shadow = softShadow(ro + 0.001 * norm, light, 5.0);\n    float ambient = 0.22;\n\tfloat diff = clamp(dot(light, norm), 0.0, 1.0) * shadow * 0.9;\n\tfloat spec = pow(clamp(dot(norm, lightDir), 0.0, 1.0), 32.0) * shadow * 1.8;\n \tcolor = (lightColor * (ambient + diff + spec) * material);  \n\tcolor = pow(color, lightColor); \n\tvec2 fd = (6.0 * fragCoord - iResolution.xy) / iResolution.y;   \n    color *= 1.0 - length(fd) * 0.07;\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsByzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 49, 49, 296], [298, 298, 320, 320, 453], [455, 455, 490, 490, 517], [541, 541, 573, 573, 1357], [1359, 1359, 1397, 1397, 1602], [1604, 1604, 1658, 1658, 1938], [1940, 1940, 1995, 1995, 3329]], "test": "untested"}
{"id": "3djcWW", "name": "ping", "author": "lennyjpg", "description": "ping", "tags": ["grid", "radius"], "likes": 4, "viewed": 333, "published": 3, "date": "1586652471", "time_retrieved": "2024-07-30T21:13:32.054562", "image_code": "# define PI 3.141592653589793\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.y;\n    uv.y+=iTime*0.1;\n    \n    vec2 u = fract(uv.xy*5.)-0.5;\n    \n   \n    float z = 5.;\n    vec2 g = iTime*.02 + floor(uv * z);\n    float b =  rand(floor(g + 3.321))*3.;\n    float r =.7;\n    float angle = PI*0.25+floor(rand(floor(g))*4.)*PI*0.5;      \n    u.x+=sin(angle)*r;\n    u.y+=cos(angle)*r;\n    float d = length(u*.3);\n //\tfloat k = smoothstep(d,d*1.01,0.5);\n    float k = fract(d*3.0-iTime*(b-0.5)*0.2);\n    k += sin(iTime * r + angle);\n    k = sin(fract(k*.13)*1.5)*1.2;\n    vec3 cc = mix( vec3(.08, 0.15, 0.3), vec3(1.2, 0.13, 0.2), k);\n    fragColor = vec4(cc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djcWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 50, 50, 122], [124, 124, 181, 181, 801]], "test": "untested"}
{"id": "wsBcWD", "name": "Day 114", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 11, "viewed": 359, "published": 3, "date": "1586648717", "time_retrieved": "2024-07-30T21:13:32.991058", "image_code": "\n#define pi acos(-1.)\n\n#define tau (2.*pi)\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\nvec3 glow = vec3(0);\n\n\n\n\nfloat map(vec3 p, float t){\n\tfloat d = 10e7;\n\t\n    vec4 q = vec4(p, 1.);\n    \n    float id = floor(p.z);\n    \n    \n    \n    for(float i = 0.; i <0. ; i++){\n    \tq.xyz = abs(q.xyz);\n        q.xy *= rot(0.125*pi + i);\n    \n        q -= 0.1;\n    }\n    \n    \n    float dpp = dot(q.xyz,q.xyz);\n    \n    \n    //    q = q/dpp;\n    \n    vec4 j;\n    \n    //q /= dot(q.xyz,q.xyz);\n    vec3 b = vec3(2.4, 0.6, 1.);\n    \n    for(int i = 0; i <4 ; i++){\n    \tq.xyz = abs(q.xyz);\n        q.xy *= rot(0.25*pi);\n        q.xz *= rot(1.5);\n    \tq.x += 0.1;\n    }\n    \n    for(float i = 0.; i < 10.; i++){\n    \tq.xyz = abs(mod(q.xyz - 0.5*b, b) )- 0.5*b;\n        \n        float dpp = dot(q.xyz,q.xyz);\n        \n        \n        dpp = clamp(dpp, 0. ,1.54);\n        if(i == 2.)\n            j = q;\n        \n        q = q/dpp;\n        if(i == 20.)\n        \tq.xz *= rot(0.7 );\n        \n    }\n    \n    q.xyz *= 1. ;\n    \n    float db = length(j.yx)/q.w - 0.01;\n    \n        \n\tfloat da = length(q.yz)/q.w - 0.02;\n    \n    float sc = 0.5;\n    d = min(db,da);\n    //d = da;\n    d *= 0.5;\n    d += smoothstep(1.,0.,t*.5)*0.7;\n    d = abs(d) + 0.003;\n    \n    //d += exp(-t*4.)*0.7;\n    \n    \n    vec3 c = vec3(1,1.,1.);\n    da *= 0.5;\n    db *= 0.5;\n    da = abs(da) + 0.003;\n    db = abs(db) + 0.003;\n    glow += 0.9/(0.01 + da*da*1500.)*c;\n    glow -= 0.9/(0.01 + db*db*2000.)*c*vec3(0.,0.8,2.);\n    return d;\n}\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0.,1.,0), dir));\n\tvec3 up = normalize(cross( dir, right));\n\treturn normalize(dir + right*uv.x + up*uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.9,0.6,0.4);\n\n    vec3 ro = vec3(0);\n    ro.z += iTime;\n    \n    float T = iTime*0.2;\n    ro.xy += vec2(cos(T), sin(T))*3.;\n    \n    vec3 lookAt = vec3(0);\n    \n    lookAt.z = ro.z + 4.;\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    float d;\n    vec3 p = ro; float t = 0.; bool hit = false;\n    \n    for(int i = 0; i < 60; i++){\n    \td = map(p, t);\n        if(d < 0.001){\n        \thit = true;\n            //break;\n        }\n\t\tt += d;\n    \tp = ro + rd*t;\n    }\n    \n    \n    col -= glow*0.001;\n    \n    col = pow(col, vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsBcWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 174, 201, 201, 1558], [1559, 1559, 1601, 1601, 1780], [1782, 1782, 1839, 1839, 2500]], "test": "untested"}
{"id": "3djyWW", "name": "Small way to get random vectors", "author": "blackle", "description": "on the left is points generated with normalize(V) and on the right is normalize(tan(V))", "tags": ["random", "vectors", "sizecode"], "likes": 13, "viewed": 1478, "published": 3, "date": "1586648072", "time_retrieved": "2024-07-30T21:13:34.038258", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//with a random vector V in the range [-1, 1], you can get a relatively\n//uniformly distributed unit vector by doing normalize(tan(V)). this is\n//because normalizing a gaussian distributed vector will give you a\n//uniformly distributed unit vector, and tan(V) will make our vector\n//more gaussian. it's not perfect, but it helps a lot\n\n//on the left is points generated with normalize(V)\n//and on the right is normalize(tan(V))\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nvec3 hash3(float a) {\n    float h = hash(a, a+32.23);\n    return vec3(hash(a,h), hash(a+h,h*a), hash(a+h,h));\n}\n\nfloat sphere(vec3 p) {\n    return length(p)-1.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.x*2.;\n    bool fix = uv.x > 0.;\n    uv.x = fract(uv.x)-0.5;\n    \n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-5,0,0);\n    cam = erot(cam, vec3(0,1,0), cos(iTime));\n    init = erot(init, vec3(0,1,0), cos(iTime));\n    cam = erot(cam, vec3(0,0,1), iTime);\n    init = erot(init, vec3(0,0,1), iTime);\n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 100; i++) {\n        float dist = sphere(p);\n        if (dist*dist < 0.00001) {hit = true; break;}\n        p+=dist*cam;\n    }\n\n    if (hit) {\n        vec2 uv = map_from_sphere(p);\n        if (fix) {\n    \t\tfragColor = texture(iChannel1, uv);\n        } else {\n    \t\tfragColor = texture(iChannel0, uv);\n        }\n    } else {\n        fragColor.xyz = vec3(0.0);\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PI = 3.141592653;\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a); int y = FK(b);\n    return float((x*x+y)*(y*y-x)+x)/2.14e9;\n}\n\nvec3 randvec(float seed) {\n    float h1 = hash(seed, seed);\n    float h2 = hash(h1, seed);\n    float h3 = hash(h2, seed);\n    return vec3(h1,h2,h3);\n}\n\nvec3 map_to_sphere(vec2 p)\n{\n    float theta = (p.x-0.5)*PI*2.;\n    float phi = (p.y-0.5)*PI*2.;\n    return vec3(sin(phi)*sin(theta), sin(phi)*cos(theta), cos(phi));\n}\n\nvec2 map_from_sphere(vec3 p)\n{\n    p = normalize(p);\n    return vec2(atan(p.x,p.y)/PI/2.+0.5, acos(p.z)/PI/2.+0.5);\n}\n\nvec4 bufferImage( vec2 uv, vec4 data, float frame, bool fix ) {\n    for (int i = 0; i < 50; i++) {\n        vec3 rnd = randvec(hash(float(i), frame));\n        if (fix) {\n            rnd = tan(rnd);\n        }\n        rnd = normalize(rnd);\n        vec3 proj = map_to_sphere(uv);\n        data *= smoothstep(0.0, 0.015, distance(rnd, proj));\n    }\n    return data;\n}", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n    vec4 data = texelFetch(iChannel0,ivec2(fragCoord),0);\n    if (iFrame == 0) data = vec4(1.);\n    \n    fragColor = bufferImage(uv, data, float(iFrame), false);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n    vec4 data = texelFetch(iChannel0,ivec2(fragCoord),0);\n    if (iFrame == 0) data = vec4(1.);\n    \n    fragColor = bufferImage(uv, data, float(iFrame), true);\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djyWW.jpg", "access": "api", "license": "cc0-1.0", "functions": [[623, 623, 661, 661, 727], [729, 729, 750, 750, 840], [842, 842, 864, 864, 891], [894, 894, 951, 1001, 1801]], "test": "untested"}
{"id": "wsSyWD", "name": "Red Only II", "author": "ManuManu", "description": "Another try to have a sin city like effect.\n\nStill very dependant of the lighting conditions and your webcam", "tags": ["red", "webcam", "sincity"], "likes": 4, "viewed": 466, "published": 3, "date": "1586640733", "time_retrieved": "2024-07-30T21:13:34.897960", "image_code": "\nvec4 convertToUYUV(vec4 inputColor )\n{\n\tmat4 RGBtoYUV = mat4(0.257,  0.439, -0.148, 0.0,\n    \t                 0.504, -0.368, -0.291, 0.0,\n        \t             0.098, -0.071,  0.439, 0.0,\n            \t         0.0625, 0.500,  0.500, 1.0 );\n    return RGBtoYUV * inputColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 wantedColor =  vec4( 1.0, .0, .0, 1. );\n    //Rvec4 wantedColor =  vec4( .0, 1.0, .0, 1. );\n\t\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n  \tvec4 color = texture(iChannel0, uv);\n \tfloat grey = dot(vec3( color), vec3(0.299, 0.587, 0.114) );\n    vec4 greyColor = vec4(vec3(grey), 1.);\n  \n\tvec4 wantedColor_YUV =  convertToUYUV( wantedColor );\n    vec4 input_color_YUV = convertToUYUV( color );\n\n    float chromaDist = distance( wantedColor_YUV.gb, input_color_YUV.gb );\n    \n    float threshold = .3;\n    float threshold_high = threshold + .1;\n    \n    float boost = .1f;\n    color += dot( color, wantedColor) * wantedColor * boost; // Boost wanted color\n    \n    fragColor = mix( greyColor, color,  smoothstep( threshold_high , threshold, chromaDist) );\n}\n", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsSyWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 39, 39, 277], [279, 279, 336, 336, 1095]], "test": "untested"}
{"id": "wsScWW", "name": "Trying 2 Style Transfer", "author": "wyatt", "description": "set buffer D in buffer A and C to the same texture to experiment - buffer D in buffer D is the destination. \nSource and destination are the same by default - theoretically the picture shouldn't change.. but it definitely does.", "tags": ["experiment"], "likes": 5, "viewed": 517, "published": 3, "date": "1586630550", "time_retrieved": "2024-07-30T21:13:35.665907", "image_code": "// Fork of \"Trying 2 AI\" by wyatt. https://shadertoy.com/view/tdBczw\n// 2020-04-09 22:38:44\n\n// Fork of \"Graph Network\" by wyatt. https://shadertoy.com/view/tssyDS\n// 2020-04-07 18:45:05\n\nMain {\n    //if (iFrame%I<I-1)discard;\n\tQ = D(U);\n    //Q*=Q.w;\n    //Q *= smoothstep(2.,3.,length(U-Q.xy*R));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texelFetch(iChannel3,ivec2(U),0)\n#define Main void mainImage (out vec4 Q, vec2 U) \n#define Init if (iFrame < 1) \n#define Border if (U.x<1.||R.x-U.x<1.||U.y<1.||R.y-U.y<1.)\n#define T(U,t) texelFetch((t),ivec2(U),0)\n#define f(U,t) length(T((U),(t)).xyz)\n#define I 11\n#define Neighborhood vec4 n = A(U+vec2(0,1)), e = A(U+vec2(1,0)), s = A(U-vec2(0,1)), w = A(U-vec2(1,0)), m = 0.25*(n+e+s+w);\n\nvec2 convo (vec2 U, sampler2D t) {\n\tvec2 r = vec2(0); float d = 0., m=f(U,t);\n    for (int x = -4;x<=4;x++)\n        for (int y = -4;y<=4;y++) {\n        \tvec2 v = vec2(x,y);\n            float z = f(U+v,t);\n            float e = exp(-.01*dot(v,v));\n            r += (z-m)*v*e;\n            d += (z-m)*e;\n        }\n    return vec2(.04*length(r),0.5+.06*(d));\n}\n// Dave H\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n", "buffer_a_code": "Main {\n    U =0.5*iChannelResolution[3].xy+0.5*U*iChannelResolution[3].x/R.x;\n    Q.xy = convo(U,iChannel3);\n    Q.zw = U;\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void X(inout vec4 Q, vec2 U, vec4 n) {\n\tif (length(U-n.xy*R)<length(U-Q.xy*R))\n        Q = n;\n}\nMain {\n\tif (iFrame%I==0) Q=A(U);\n    else {\n    \tQ = B(U);\n        float k = exp2(float(I-1-iFrame%I));\n        X(Q,U,B(U+vec2(0,k)));\n        X(Q,U,B(U+vec2(k,0)));\n        X(Q,U,B(U-vec2(0,k)));\n        X(Q,U,B(U-vec2(k,0)));\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n\tQ = C(U);\n    vec4 b = B(U);\n    float e = 1./(1.+0.1*length(U-b.xy*R));\n    if (e>Q.w){\n    \tQ = D(b.zw);\n        Q *= Q.w;\n        Q.w = e;\n    }\n    \n    if (iFrame < 1) Q = vec4(0);\n\t\n}", "buffer_c_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n\tQ = A(U);\n    \n    vec2 co = convo(U,iChannel0);\n    vec4 color = C(co*R);\n    for (int x = -2; x<=2; x++) \n        for (int y = -2; y<=2; y++) {\n            vec4 z = C(co*R+2.*vec2(x,y));\n        \tif (length(color.xyz-z.xyz)>length(color.xyz-Q.xyz))\n                color = z;\n        }\n    vec4 dQ = color-Q;\n    Neighborhood;\n   \tQ += (1.-Q.w)*(m-Q);\n    if (length(dQ)>0.)\n    Q += 0.006*sign(dQ)*(color.w*color.w);\n    Q = mix(Q,D(U),\n            0.005);\n    Q.w = color.w;\n    \n    if ((iMouse.z>0.&&length(U-iMouse.xy)<20.)||iFrame < 10) {\n    \tQ = D(U);\n        Q.w=0.;\n    }\n}", "buffer_d_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsScWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WsBcDD", "name": "tie dye anim", "author": "_sans_titre", "description": "tweaking this one : https://www.shadertoy.com/view/WtBXz1\n\nclick and drag", "tags": ["psyche"], "likes": 0, "viewed": 367, "published": 3, "date": "1586624765", "time_retrieved": "2024-07-30T21:13:36.461778", "image_code": "#define PI 3.14159\n\nvec3 palette(float l) {\n    float m = 2.0*PI * l;\n\treturn vec3(\n    \tcos(m),\n        cos(m + 2.0 * PI / 3.0),\n        cos(m + 3.0 * PI / 3.0)\n    );\n}\n\nvec4 m = vec4(0.3);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iMouse.x > 0.0)\n    \tm = iMouse / iResolution.xyxy;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    //uv += vec2(0.0, -1.5);\n    float th = atan(uv.y, uv.x);\n    float baseLength = length(uv*0.1);\n    vec2 wavy = vec2(\n        sin(th * 1.0 + iTime),\n        cos(th * 23.0 + iTime)\n    );\n    float waveScale = max(0.01*m.x*100.01, baseLength * 0.2);\n    wavy *= waveScale * m.y * 5.;\n    float f = length(uv + wavy);\n    f -= iTime / 10.0;\n    f = floor(8.4 * f)/8.0;\n\n    vec3 col = palette(f);\n    col = pow(col, vec3(1.0/( m.y * 10.0)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBcDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 43, 43, 170], [193, 193, 250, 250, 929]], "test": "untested"}
{"id": "wdjyWh", "name": "Meow Final", "author": "michael0884", "description": "Correctly ray marching a cat mesh, meow.", "tags": ["triangles", "marching", "graph", "mesh"], "likes": 4, "viewed": 475, "published": 3, "date": "1586613863", "time_retrieved": "2024-07-30T21:13:37.574803", "image_code": "//Graph is in Buf A, graph traversal is in Buf B\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    fragColor = texel(ch1, pos);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define N ivec2(6,108)\n#define sN ivec2(32,3)\n#define dt 0.\n\n#define maxN 2048\n\n#define loop(x) for(int i = min(0, iFrame); i < x; i++)\n\nconst int tot_n = N.x*N.y;\n\nivec2 i2xy(ivec3 sid)\n{\n    return sN*ivec2(sid.x%N.x, sid.x/N.x) + sid.yz;\n}\n\nivec3 xy2i(ivec2 p)\n{\n    ivec2 pi = p/sN;\n    return ivec3(pi.x + pi.y*N.x, p.x%sN.x, p.y%sN.y);\n}\n\nfloat toF(vec4 A, int i)\n{\n    return (i<4)?mod(A[i], float(maxN)):(A[i%4]/float(maxN));\n}\n\nint toI(vec4 A, int i)\n{\n    return (i<4)?(int(A[i])%maxN):(int(A[i%4])/maxN);\n}\n\nfloat F(float d)\n{\n    return 1./(0.1*d*d+1.) - 1.*exp(-1.*d);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nconst int k = 1664525;  \n\nivec4 hash( ivec4 x )\n{\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    return ivec4(x);\n}\n\n#define link0 32\n\nconst float PHI = 0.5*(sqrt(5.) + 1.);\n\nvec2 inverseSF( vec3 p, float n ) \n{\n    float m = 1.0 - 1.0/n;\n    \n    float phi = min(atan(p.y, p.x), PI), cosTheta = p.z;\n    \n    float k  = max(2.0, floor( log(n * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))/ log(PHI+1.0)));\n    float Fk = pow(PHI, k)/sqrt(5.0);\n    vec2  F  = vec2( round(Fk), round(Fk * PHI) ); // k, k+1\n\n    vec2 ka = 2.0*F/n;\n    vec2 kb = 2.0*PI*( fract((F+1.0)*PHI) - (PHI-1.0) );    \n    \n    mat2 iB = mat2( ka.y, -ka.x, \n                    kb.y, -kb.x ) / (ka.y*kb.x - ka.x*kb.y);\n    \n    vec2 c = floor( iB * vec2(phi, cosTheta - m));\n    float d = 8.0;\n    float j = 0.0;\n    for( int s=0; s<4; s++ ) \n    {\n        vec2 uv = vec2( float(s-2*(s/2)), float(s/2) );\n        \n        float i = round(dot(F, uv + c)); // all quantities are ingeters (can take a round() for extra safety)\n        \n        float phi = 2.0*PI*fract(i*PHI);\n        float cosTheta = m - 2.0*i/n;\n        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n        \n        vec3 q = vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta );\n        float squaredDistance = dot(q-p, q-p);\n        if (squaredDistance < d) \n        {\n            d = squaredDistance;\n            j = i;\n        }\n    }\n    return vec2( j, sqrt(d) );\n}\n\nvec4 iSF( vec3 p, float n ) \n{\n    float m = 1.0 - 1.0/n;\n    \n    float phi = min(atan(p.y, p.x), PI), cosTheta = p.z;\n    \n    float k  = max(2.0, floor( log(n * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))/ log(PHI+1.0)));\n    float Fk = pow(PHI, k)/sqrt(5.0);\n    vec2  F  = vec2( round(Fk), round(Fk * PHI) ); // k, k+1\n\n    vec2 ka = 2.0*F/n;\n    vec2 kb = 2.0*PI*( fract((F+1.0)*PHI) - (PHI-1.0) );    \n    \n    mat2 iB = mat2( ka.y, -ka.x, \n                    kb.y, -kb.x ) / (ka.y*kb.x - ka.x*kb.y);\n    \n    vec2 c = floor( iB * vec2(phi, cosTheta - m));\n    float d = 8.0;\n    float j = 0.0;\n    vec4 o;\n    for( int s=0; s<4; s++ ) \n    {\n        vec2 uv = vec2( float(s-2*(s/2)), float(s/2) );\n        \n        o[s] = dot(F, uv + c); \n    }\n    return o;\n}\n\nvec3 fibonacci_sphere(int i, int n)\n{\n    vec2 pt = vec2(2.*PI*mod((float(i))/PHI, 1.), acos(1. - float(2*i+1)/float(n)));\n    return vec3(cos(pt.x)*sin(pt.y), sin(pt.x)*sin(pt.y), cos(pt.y)); \n}\n\n    \nstruct object\n{\n    int id;\n    vec3 X;\n    float bR;\n    vec3 a;\n    vec3 b;\n    vec3 c;\n};\n\nvec3 qtransform(vec4 q, vec3 v)\n{ \n\treturn v + 2.0*cross(cross(v, q.xyz) + q.w*v, q.xyz);\n} \n\n//intersection with the bisector plane\nfloat rayBisectDist(vec3 p, vec3 d, vec3 a, vec3 b)\n{\n    vec3 n = b - a;\n    float D = length(n);\n    float cosnd = dot(n, d)/D; //ray plane normal angle cosine\n    float l = D*.5 - dot(p - a, n)/D;\n    float t = l/cosnd; //ray parameter\n    return (cosnd>0.)?t:1e10;\n}\n\nfloat dirBisectDist(vec3 d, vec3 a, vec3 b, float G)\n{\n    float cosnd = dot(normalize(b - a), d); //ray plane normal angle cosine\n    return (cosnd>0.)?(distance(a,b)*.5)*max(1./cosnd - G, 1.):1e10;\n}\n\n//iq's triangle sdf \nfloat dot2( vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat bisectDist(vec3 p, vec3 a, vec3 b)\n{\n    return distance(a,b)*0.5 - dot(p - a, normalize(b - a));\n}\n", "buffer_a_code": "//triangle and triangle neighbor directional graph buffer \n\nvec3[] vertecies = vec3[](\nvec3(-995.8304  ,  75.5037  ,   -608.4150),\nvec3(-992.0101  ,  115.6586 ,    -568.2448),\nvec3(-948.9031  ,  122.7461 ,    -586.1746),\nvec3(-808.0504  ,  82.2768  ,   -504.0376),\nvec3(-829.8732  ,  90.4546  ,   -495.4801),\nvec3(-815.5106  ,  55.3138  ,   -483.6030),\nvec3(-827.6768  ,  4.7252   ,   -550.7932),\nvec3(-926.4594  ,  -11.3236 ,    -509.0985),\nvec3(-924.9203  ,  4.9779   ,   -555.2147),\nvec3(-699.9360  ,  47.5303  ,   -579.6901),\nvec3(-725.3939  ,  13.6954  ,   -604.4670),\nvec3(-739.4488  ,  72.5684  ,   -610.5344),\nvec3(-1034.0753 ,  -11.3236 ,    -534.3847),\nvec3(-1060.0525 ,  17.3272  ,   -541.3537),\nvec3(-1038.5428 ,  29.1891  ,   -575.5334),\nvec3(-1000.9319 ,  78.8761  ,   -383.3885),\nvec3(-930.1043  ,  71.7035  ,   -351.5857),\nvec3(-920.2565  ,  109.7136 ,    -404.0531),\nvec3(-702.3473  ,  16.8526  ,    -571.5159),\nvec3(-728.9493  ,  -11.3236 ,    -558.9595),\nvec3(-724.4047  ,  -11.3236 ,    -589.9592),\nvec3(-717.2055  ,  41.9075  ,   -502.3305),\nvec3(-735.5786  ,  47.5303  ,   -491.1331),\nvec3(-733.9127  ,  18.3676  ,   -496.1548),\nvec3(-733.9399  ,  96.2936  ,   -552.8721),\nvec3(-694.6128  ,  66.2405  ,   -544.0293),\nvec3(-727.1962  ,  94.3858  ,   -574.8710),\nvec3(-925.7615  ,  126.6104 ,    -513.3122),\nvec3(-853.2005  ,  115.3310 ,    -545.4424),\nvec3(-894.0300  ,  131.5131 ,    -564.8028),\nvec3(-790.0053  ,  -4.9984  ,   -523.5698),\nvec3(-788.1220  ,  -4.3065  ,   -488.5588),\nvec3(-795.1429  ,  6.2171   ,   -449.4353),\nvec3(-840.2600  ,  20.1157  ,   -360.7992),\nvec3(-841.6091  ,  -1.1064  ,   -353.7490),\nvec3(-798.4716  ,  -11.3236 ,    -394.9299),\nvec3(-836.6793  ,  74.1277  ,   -450.3682),\nvec3(-832.0030  ,  64.3311  ,   -416.8673),\nvec3(-815.2516  ,  34.6305  ,   -481.9950),\nvec3(-832.3073  ,  9.2289   ,   -452.2656),\nvec3(-789.5191  ,  55.1783  ,   -621.8122),\nvec3(-795.7584  ,  20.4113  ,   -616.7018),\nvec3(-853.6783  ,  -11.3236 ,    -657.0101),\nvec3(-814.8730  ,  -5.0179  ,   -583.5240),\nvec3(-1012.5013 ,  -11.3236 ,    -419.7687),\nvec3(-990.1320  ,  -1.7048  ,   -373.5935),\nvec3(-1004.2960 ,  44.1512  ,   -365.5110),\nvec3(-855.9658  ,  10.3450  ,   -380.9660),\nvec3(-803.1211  ,  -11.3236 ,    -401.7929),\nvec3(-906.3935  ,  -0.5085  ,   -358.5250),\nvec3(-957.7062  ,  114.9286 ,    -436.9630),\nvec3(-977.6108  ,  130.2673 ,    -533.3871),\nvec3(-738.3090  ,  5.0845   ,   -507.1984),\nvec3(-709.8657  ,  -11.3236 ,    -526.8616),\nvec3(-710.5553  ,  1.5324   ,   -511.1166),\nvec3(-747.3311  ,  0.0296   ,   -472.9264),\nvec3(-749.3085  ,  11.8466  ,   -475.1376),\nvec3(-792.2325  ,  17.3739  ,   -396.8396),\nvec3(-878.4414  ,  35.7717  ,   -642.8316),\nvec3(-989.6032  ,  17.0865  ,   -621.6263),\nvec3(-944.0946  ,  58.0384  ,   -642.5948),\nvec3(-851.3480  ,  63.6161  ,   -648.0112),\nvec3(-785.4418  ,  72.5684  ,   -496.2609),\nvec3(-793.9230  ,  105.7400 ,    -489.6239),\nvec3(-805.3693  ,  49.2849  ,   -493.7585),\nvec3(-707.0358  ,  66.2405  ,   -513.1634),\nvec3(-781.2529  ,  20.6106  ,   -610.5267),\nvec3(-752.0867  ,  49.2849  ,   -626.1438),\nvec3(-764.1007  ,  4.7729   ,   -624.7463),\nvec3(-782.7896  ,  109.1638 ,    -561.5859),\nvec3(-755.0754  ,  109.5690 ,    -604.1262),\nvec3(-778.0606  ,  97.3133  ,   -596.8195),\nvec3(-1035.4617 ,  94.9357  ,   -465.6595),\nvec3(-962.6334  ,  117.6223 ,    -475.3002),\nvec3(-1042.7870 ,  48.9679  ,   -403.3333),\nvec3(-1073.9026 ,  52.3123  ,   -485.0486),\nvec3(-1056.9429 ,  9.7043   ,   -458.5848),\nvec3(-768.6208  ,  -8.2751  ,   -504.6131),\nvec3(-771.2246  ,  5.6477   ,   -497.4490),\nvec3(-706.1431  ,  -11.3236 ,    -536.1108),\nvec3(-695.7332  ,  1.5324   ,   -547.9435),\nvec3(-699.7588  ,  -1.4693  ,   -532.1415),\nvec3(-703.2778  ,  44.4115  ,   -511.2145),\nvec3(-690.5525  ,  44.4115  ,   -542.8315),\nvec3(-806.4027  ,  26.4766  ,   -417.1291),\nvec3(-779.1372  ,  17.1613  ,   -493.2779),\nvec3(-882.1035  ,  74.7240  ,   -366.3839),\nvec3(-821.3383  ,  74.7946  ,   -638.8068),\nvec3(-867.0529  ,  24.4554  ,   -668.6847),\nvec3(-784.6449  ,  106.3202 ,    -578.2576),\nvec3(-831.2065  ,  104.9587 ,    -620.3184),\nvec3(-783.5483  ,  7.4472   ,   -469.5750),\nvec3(-764.3502  ,  -11.3236 ,    -481.8925),\nvec3(-792.4278  ,  -8.2995  ,   -418.0562),\nvec3(-743.1558  ,  106.7015 ,    -584.4225),\nvec3(-685.2125  ,  17.4394  ,   -530.0173),\nvec3(-697.9792  ,  37.3655  ,   -539.4918),\nvec3(-690.5497  ,  17.4394  ,   -516.7567),\nvec3(-712.0912  ,  13.6706  ,   -585.8790),\nvec3(-996.4185  ,  -11.3236 ,    -539.4856),\nvec3(-1024.4155 ,  0.8627   ,   -577.6360),\nvec3(-798.4020  ,  1.7822   ,   -616.4513),\nvec3(-829.1520  ,  -11.3236 ,    -598.7313),\nvec3(-873.5256  ,  -0.4193  ,   -622.8918),\nvec3(-728.0101  ,  64.0319  ,   -495.0735),\nvec3(-744.3813  ,  95.5499  ,   -520.9390),\nvec3(-761.2942  ,  88.9008  ,   -508.1789),\nvec3(-781.7170  ,  26.8159  ,   -493.0542),\nvec3(-901.6669  ,  -11.3236 ,    -398.2102),\nvec3(-767.1221  ,  11.5533  ,   -493.6247),\nvec3(-751.5170  ,  13.1415  ,   -492.4418),\nvec3(-780.6548  ,  14.4846  ,   -472.4714),\nvec3(-1060.7682 ,  61.4407  ,   -446.4903),\nvec3(-1051.7577 ,  95.4428  ,   -514.2819),\nvec3(-1039.2488 ,  61.4143  ,   -568.5452),\nvec3(-854.7079  ,  94.0548  ,   -504.5181),\nvec3(-929.0150  ,  119.9958 ,    -442.1982),\nvec3(-864.1474  ,  97.4144  ,   -420.7776),\nvec3(-870.3384  ,  96.9634  ,   -459.3782),\nvec3(-780.8250  ,  4.2498   ,   -601.9772),\nvec3(-741.7265  ,  -11.3236 ,    -599.0881),\nvec3(-721.0571  ,  7.8997   ,   -601.0405),\nvec3(-703.8851  ,  -1.0353  ,   -617.8672),\nvec3(-942.1671  ,  7.3515   ,   -341.2048),\nvec3(-921.3945  ,  19.8009  ,   -333.6794),\nvec3(-943.1711  ,  -11.3236 ,    -350.5991),\nvec3(-838.6180  ,  27.0678  ,   -411.9889),\nvec3(-863.2388  ,  18.6852  ,   -406.0000),\nvec3(-814.4047  ,  16.0976  ,   -411.6389),\nvec3(-694.4426  ,  41.9075  ,   -558.8868),\nvec3(-710.5289  ,  22.1320  ,   -509.3748),\nvec3(-706.3202  ,  37.3655  ,   -518.7678),\nvec3(-696.0511  ,  42.0174  ,   -536.3110),\nvec3(-1036.4375 ,  -11.3236 ,    -459.7409),\nvec3(-770.0264  ,  106.7015 ,    -517.6603),\nvec3(-792.2722  ,  109.5690 ,    -511.7077),\nvec3(-779.3687  ,  119.6276 ,    -475.8542),\nvec3(-758.4063  ,  103.6384 ,    -502.1507),\nvec3(-784.4563  ,  107.8258 ,    -494.3299),\nvec3(-783.4283  ,  78.5575  ,   -513.7649),\nvec3(-883.1703  ,  -3.6364  ,   -655.2727),\nvec3(-730.2901  ,  88.9008  ,   -585.2112),\nvec3(-697.2075  ,  64.0319  ,   -571.6052),\nvec3(-750.1225  ,  78.5575  ,   -596.5160),\nvec3(-737.4004  ,  107.8258 ,    -611.2444),\nvec3(-724.0314  ,  103.6384 ,    -587.5582),\nvec3(-782.6500  ,  -11.3236 ,    -570.2200),\nvec3(-900.4669  ,  96.2424  ,   -633.2571),\nvec3(-897.0970  ,  120.3056 ,    -610.5399),\nvec3(-833.9095  ,  115.4948 ,    -598.8503),\nvec3(-853.0287  ,  122.5423 ,    -581.7062),\nvec3(-759.3208  ,  -11.3236 ,    -457.8283),\nvec3(-742.3607  ,  -11.3236 ,    -526.3356),\nvec3(-694.5074  ,  22.1320  ,   -549.1814),\nvec3(-839.2968  ,  22.8362  ,   -391.3108),\nvec3(-820.5211  ,  30.1974  ,   -389.5576),\nvec3(-829.5941  ,  38.5166  ,   -409.1643),\nvec3(-836.8793  ,  47.4207  ,   -386.5396),\nvec3(-869.9812  ,  46.1542  ,   -482.3823),\nvec3(-890.2067  ,  70.0660  ,   -483.5094),\nvec3(-909.9105  ,  98.4824  ,   -473.5333),\nvec3(-937.6815  ,  103.8339 ,    -483.5974),\nvec3(-804.8950  ,  95.6823  ,   -518.2141),\nvec3(-829.9017  ,  105.1277 ,    -539.1833),\nvec3(-733.7024  ,  -11.3236 ,    -611.5656),\nvec3(-738.7223  ,  10.7529  ,   -610.3510),\nvec3(-720.5469  ,  -9.4244  ,   -620.4963),\nvec3(-945.2722  ,  87.9113  ,   -629.4183),\nvec3(-995.0536  ,  46.6390  ,   -622.5880),\nvec3(-707.1171  ,  0.0891   ,   -521.4265),\nvec3(-701.2590  ,  1.7814   ,   -528.7713),\nvec3(-696.3574  ,  18.3020  ,   -516.0935),\nvec3(-705.5143  ,  32.6190  ,   -518.7469),\nvec3(-746.8992  ,  89.1834  ,   -623.5667),\nvec3(-774.1794  ,  85.3090  ,   -610.5543),\nvec3(-749.5588  ,  79.4633  ,   -607.6957),\nvec3(-735.9028  ,  86.8596  ,   -621.5189),\nvec3(-796.1419  ,  90.7038  ,   -608.0107),\nvec3(-1030.2487 ,  110.2389 ,    -493.4697),\nvec3(-984.0498  ,  122.4129 ,    -486.0958),\nvec3(-1026.7104 ,  102.5003 ,    -546.5026),\nvec3(-790.7665  ,  79.4633  ,   -505.3118),\nvec3(-790.4939  ,  86.8596  ,   -485.8827),\nvec3(-772.3555  ,  -4.7332  ,   -484.7859),\nvec3(-770.9318  ,  12.4502  ,   -486.0145),\nvec3(-896.9176  ,  -11.3236 ,    -454.9405),\nvec3(-770.0953  ,  -11.3236 ,    -537.9039),\nvec3(-692.3391  ,  11.6189  ,   -522.3785),\nvec3(-688.5785  ,  13.9763  ,   -545.0641),\nvec3(-874.0591  ,  -11.3236 ,    -597.7254),\nvec3(-950.8364  ,  118.9327 ,    -489.5284),\nvec3(-830.0552  ,  34.2774  ,   -389.5935),\nvec3(-711.2487  ,  -11.3236 ,    -613.0066),\nvec3(-704.1648  ,  -6.0835  ,   -597.8587),\nvec3(-806.8093  ,  28.4912  ,   -497.3588),\nvec3(-697.3834  ,  32.6190  ,   -538.9485),\nvec3(-1069.4880 ,  24.5603  ,   -494.2723),\nvec3(-973.8975  ,  -1.5557  ,   -607.4702),\nvec3(-997.2460  ,  -11.3236 ,    -558.3713),\nvec3(-688.9415  ,  18.3020  ,   -534.5188),\nvec3(-871.4866  ,  -11.3236 ,    -650.8430),\nvec3(-793.2932  ,  109.4704 ,    -565.8134),\nvec3(-800.0500  ,  103.8140 ,    -523.6841),\nvec3(-736.8707  ,  111.9007 ,    -616.0329),\nvec3(-729.2321  ,  106.4699 ,    -623.9708),\nvec3(-720.9323  ,  119.6276 ,    -621.0443),\nvec3(-800.4397  ,  14.8650  ,   -433.0968),\nvec3(-710.6121  ,  -11.3236 ,    -601.5969),\nvec3(-736.1279  ,  -4.1757  ,   -606.0648),\nvec3(-783.3688  ,  5.3768   ,   -498.0137),\nvec3(-703.4008  ,  13.9763  ,   -508.2369),\nvec3(-787.3816  ,  106.4699 ,    -479.4933),\nvec3(-869.6447  ,  -11.3236 ,    -352.0651),\nvec3(-849.2291  ,  -11.3236 ,    -613.3991),\nvec3(-715.2297  ,  1.1529   ,    -625.7358),\nvec3(-843.8202  ,  -11.3236 ,    -359.5085),\nvec3(-892.2355  ,  102.2551 ,    -392.7515),\nvec3(-748.9401  ,  -11.3236 ,    -575.4650),\nvec3(-778.8455  ,  -11.3236 ,    -431.0151),\nvec3(-922.5539  ,  -11.3236 ,    -344.4546));\n\n\nint triz = 459;\n\n    \nint[] triangles = int[](459, 460, 461,\n\n\n462, 463, 464, \n465, 466, 467, \n468, 469, 470, \n471, 472, 473, \n474, 475, 476, \n477, 478, 479, \n480, 481, 482, \n483, 484, 485, \n486, 487, 488, \n489, 490, 491, \n492, 493, 494, \n495, 496, 497, \n498, 466, 465, \n499, 500, 501, \n465, 467, 502, \n503, 504, 505, \n506, 507, 508, \n476, 509, 474, \n486, 488, 510, \n511, 512, 513, \n514, 515, 516, \n517, 518, 519, \n519, 520, 517, \n521, 522, 523, \n484, 483, 524, \n525, 526, 527, \n528, 529, 530, \n526, 525, 499, \n531, 474, 532, \n533, 534, 535, \n536, 537, 489, \n538, 539, 540, \n524, 541, 542, \n496, 543, 544, \n545, 475, 492, \n546, 547, 520, \n548, 530, 549, \n550, 551, 552, \n552, 491, 550, \n462, 523, 522, \n553, 528, 483, \n493, 492, 475, \n554, 555, 556, \n557, 469, 468, \n466, 558, 467, \n518, 559, 473, \n560, 561, 501, \n562, 518, 517, \n470, 469, 526, \n528, 553, 529, \n563, 564, 565, \n521, 566, 481, \n508, 567, 506, \n568, 481, 566, \n569, 570, 543, \n571, 572, 534, \n573, 472, 572, \n574, 487, 486, \n575, 576, 577, \n578, 527, 579, \n580, 557, 581, \n505, 582, 583, \n493, 583, 584, \n498, 585, 586, \n507, 506, 587, \n477, 468, 588, \n542, 484, 524, \n480, 482, 589, \n590, 556, 591, \n497, 496, 544, \n566, 521, 523, \n471, 592, 472, \n593, 594, 595, \n596, 597, 598, \n599, 562, 517, \n547, 499, 501, \n600, 601, 470, \n602, 603, 604, \n579, 605, 578, \n502, 578, 605, \n549, 606, 607, \n548, 608, 609, \n610, 611, 511, \n539, 538, 477, \n477, 588, 612, \n613, 614, 587, \n615, 587, 543, \n543, 496, 615, \n616, 615, 496, \n495, 617, 618, \n619, 620, 575, \n621, 622, 574, \n594, 593, 528, \n623, 624, 625, \n461, 626, 459, \n627, 519, 518, \n513, 628, 629, \n630, 631, 589, \n632, 633, 529, \n603, 634, 635, \n636, 546, 549, \n526, 499, 636, \n510, 637, 638, \n573, 639, 460, \n492, 616, 545, \n614, 516, 515, \n640, 641, 521, \n521, 563, 565, \n576, 575, 476, \n576, 545, 616, \n544, 537, 568, \n642, 643, 537, \n537, 643, 568, \n491, 490, 550, \n498, 586, 644, \n502, 605, 465, \n536, 489, 645, \n646, 513, 629, \n647, 646, 540, \n502, 467, 648, \n574, 649, 620, \n618, 617, 574, \n510, 488, 461, \n607, 609, 608, \n512, 511, 611, \n517, 547, 599, \n520, 547, 517, \n509, 532, 474, \n620, 532, 509, \n650, 613, 615, \n613, 586, 585, \n505, 583, 475, \n475, 583, 493, \n469, 625, 624, \n526, 469, 624, \n651, 581, 652, \n623, 625, 651, \n653, 497, 566, \n462, 464, 523, \n591, 556, 555, \n612, 588, 654, \n475, 474, 505, \n533, 474, 531, \n590, 591, 541, \n631, 480, 589, \n534, 572, 472, \n655, 535, 534, \n656, 467, 657, \n467, 656, 648, \n656, 657, 471, \n511, 513, 482, \n515, 569, 614, \n646, 647, 658, \n612, 654, 658, \n524, 564, 563, \n563, 541, 524, \n501, 599, 547, \n562, 599, 659, \n596, 595, 597, \n595, 594, 522, \n470, 526, 632, \n633, 632, 526, \n543, 570, 544, \n490, 544, 570, \n537, 536, 642, \n602, 600, 470, \n470, 635, 634, \n639, 637, 510, \n531, 572, 571, \n492, 614, 650, \n614, 613, 650, \n596, 565, 564, \n564, 528, 593, \n660, 609, 487, \n487, 661, 660, \n662, 663, 635, \n664, 529, 553, \n604, 600, 602, \n483, 485, 553, \n491, 498, 489, \n585, 498, 665, \n598, 565, 596, \n521, 565, 598, \n538, 540, 628, \n661, 622, 621, \n594, 621, 522, \n484, 542, 601, \n601, 485, 484, \n466, 498, 644, \n617, 464, 463, \n497, 617, 495, \n652, 479, 666, \n510, 638, 486, \n486, 649, 574, \n533, 505, 474, \n505, 533, 503, \n516, 494, 514, \n624, 667, 527, \n624, 527, 526, \n490, 668, 544, \n489, 668, 490, \n636, 549, 530, \n529, 633, 530, \n589, 482, 513, \n513, 646, 669, \n518, 562, 656, \n559, 518, 656, \n460, 459, 573, \n473, 627, 518, \n499, 525, 500, \n578, 502, 500, \n606, 549, 520, \n546, 520, 549, \n630, 669, 646, \n646, 554, 556, \n665, 587, 585, \n552, 587, 665, \n494, 516, 492, \n614, 492, 516, \n635, 663, 603, \n603, 664, 604, \n597, 670, 641, \n641, 640, 597, \n652, 581, 557, \n652, 557, 479, \n520, 519, 606, \n459, 626, 519, \n477, 612, 539, \n540, 539, 647, \n671, 508, 507, \n499, 547, 546, \n499, 546, 636, \n659, 672, 562, \n562, 648, 656, \n465, 489, 498, \n645, 489, 465, \n581, 673, 580, \n673, 581, 651, \n561, 502, 648, \n560, 502, 561, \n667, 624, 623, \n576, 496, 495, \n616, 496, 576, \n567, 644, 586, \n506, 567, 586, \n643, 570, 569, \n643, 642, 550, \n609, 607, 488, \n609, 488, 487, \n588, 601, 542, \n588, 542, 555, \n493, 674, 494, \n584, 674, 493, \n531, 532, 638, \n638, 649, 486, \n476, 675, 576, \n475, 675, 476, \n600, 485, 601, \n485, 600, 604, \n510, 460, 639, \n461, 460, 510, \n514, 511, 515, \n515, 511, 569, \n543, 614, 569, \n614, 543, 587, \n579, 676, 605, \n575, 509, 476, \n509, 575, 620, \n551, 677, 552, \n636, 633, 526, \n636, 530, 633, \n535, 503, 533, \n541, 563, 480, \n590, 541, 480, \n630, 556, 590, \n630, 646, 556, \n528, 660, 661, \n530, 548, 528, \n477, 538, 478, \n607, 608, 549, \n549, 608, 548, \n482, 481, 568, \n482, 568, 511, \n501, 500, 560, \n500, 502, 560, \n582, 505, 504, \n503, 584, 504, \n617, 497, 464, \n523, 464, 497, \n544, 668, 537, \n489, 537, 668, \n615, 585, 587, \n585, 615, 613, \n641, 522, 521, \n641, 670, 522, \n618, 619, 495, \n495, 577, 576, \n661, 621, 594, \n661, 594, 528, \n557, 477, 479, \n557, 468, 477, \n630, 589, 669, \n513, 669, 589, \n501, 659, 599, \n506, 586, 613, \n506, 613, 587, \n635, 470, 632, \n635, 632, 662, \n463, 462, 621, \n522, 621, 462, \n497, 653, 523, \n566, 523, 653, \n671, 678, 508, \n567, 508, 678, \n492, 650, 616, \n615, 616, 650, \n491, 552, 665, \n491, 665, 498, \n569, 511, 568, \n568, 643, 569, \n470, 601, 468, \n588, 468, 601, \n667, 623, 579, \n579, 527, 667, \n470, 634, 602, \n634, 603, 602, \n598, 597, 640, \n598, 640, 521, \n655, 472, 592, \n472, 655, 534, \n587, 552, 507, \n507, 552, 677, \n461, 607, 606, \n607, 461, 488, \n529, 662, 632, \n662, 529, 664, \n610, 514, 494, \n511, 514, 610, \n620, 618, 574, \n619, 618, 620, \n469, 673, 625, \n625, 673, 651, \n628, 512, 538, \n628, 513, 512, \n656, 471, 559, \n473, 559, 471, \n637, 639, 572, \n572, 639, 573, \n487, 574, 622, \n661, 487, 622, \n531, 571, 533, \n533, 571, 534, \n612, 647, 539, \n647, 612, 658, \n574, 463, 621, \n463, 574, 617, \n562, 672, 648, \n475, 545, 675, \n675, 545, 576, \n651, 652, 666, \n467, 558, 657, \n469, 580, 673, \n469, 557, 580, \n503, 535, 592, \n535, 655, 592, \n572, 531, 637, \n638, 637, 531, \n583, 582, 584, \n582, 504, 584, \n568, 566, 544, \n544, 566, 497, \n595, 596, 593, \n596, 564, 593, \n553, 604, 664, \n553, 485, 604, \n500, 525, 578, \n527, 578, 525, \n524, 483, 564, \n528, 564, 483, \n591, 542, 541, \n555, 542, 591, \n473, 573, 459, \n472, 573, 473, \n609, 660, 548, \n548, 660, 528, \n570, 550, 490, \n575, 577, 619, \n495, 619, 577, \n590, 631, 630, \n590, 480, 631, \n646, 629, 540, \n628, 540, 629, \n551, 550, 642, \n554, 646, 658, \n555, 554, 658, \n658, 654, 555, \n654, 588, 555, \n620, 649, 532, \n638, 532, 649, \n481, 563, 521, \n563, 481, 480, \n670, 597, 595, \n670, 595, 522, \n664, 603, 663, \n662, 664, 663, \n606, 626, 461, \n626, 606, 519, \n459, 627, 473, \n519, 627, 459, \n605, 645, 465);\n\nconst vec3 shift = vec3(-908.0101  ,  64.0319  ,   -495.0735);\nconst float scale = 150.;\n\nobject obj; vec3 vertex;\nvec4 lnk0, lnk1;  \nvec4 d0, d1;\n\nfloat sdObj(vec3 p, in object o)\n{\n    return udTriangle(p, o.a, o.b, o.c) - 0.002;\n}\n\nvec4 objNorm(vec3 p, float dx, in object o) {\n\tconst vec3 k = vec3(1,-1,0);\n\treturn   (k.xyyx*sdObj(p + k.xyy*dx, o) +\n\t\t\t k.yyxx*sdObj(p + k.yyx*dx, o) +\n\t\t\t k.yxyx*sdObj(p + k.yxy*dx, o) +\n\t\t\t k.xxxx*sdObj(p + k.xxx*dx, o))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\nvoid insertion_sort(float t, int id)\n{\n    if(d0.x > t)\n    {\n        d1 = vec4(d0.w, d1.xyz); d0 = vec4(t, d0.xyz);\n        lnk1 = vec4(lnk0.w, lnk1.xyz); lnk0 = vec4(id, lnk0.xyz);\n    } else if(d0.y > t)\n    {\n        d1 = vec4(d0.w, d1.xyz); d0.yzw = vec3(t, d0.yz); \n        lnk1 = vec4(lnk0.w, lnk1.xyz); lnk0.yzw = vec3(id, lnk0.yz);\n    } else if(d0.z > t)\n    {\n        d1 = vec4(d0.w, d1.xyz); d0.zw = vec2(t, d0.z); \n        lnk1 = vec4(lnk0.w, lnk1.xyz); lnk0.zw = vec2(id, lnk0.z);\n    }else if(d0.w > t)\n    {\n        d1 = vec4(d0.w, d1.xyz); d0.w = t; \n        lnk1 = vec4(lnk0.w,lnk1.xyz); lnk0.w = float(id); \n    }else if(d1.x > t)\n    {\n        d1 = vec4(t, d1.xyz);\n        lnk1 = vec4(id, lnk1.xyz);\n    }else if(d1.y > t)\n    {\n        d1.yzw = vec3(t, d1.yz);\n        lnk1.yzw = vec3(id, lnk1.yz);\n    }else if(d1.z > t)\n    {\n        d1.zw = vec2(t, d1.z);\n        lnk1.zw = vec2(id, lnk1.z);\n    }else if(d1.w > t)\n    {\n        d1.w = t;\n        lnk1.w = float(id);\n    }\n}\n\nfloat dangle;\n/*\n#define dpd 5\nconst float GA =2.46;\nconst mat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\n\nivec2 idb[dpd];\nvec2 db[dpd];\n\n//sort 2 closest bisector planes in dpd directions\nvoid direction_sort(vec3 dir, in object o)\n{\n    vec3 pdir = normalize(cross(dir, vec3(0,0,1)));\n    vec3 tdir = normalize(cross(dir, pdir));\n    vec2 angle=vec2(0,1./sqrt(float(dpd)));\n    float rad=1.;\n\tfor (int j=0;j<dpd;j++)\n    {  \n        if(any(equal(ivec2(o.id),idb[j]))) continue;\n        rad += 1./rad;\n\t    angle*=rot;\n        vec3 cdir = normalize(dir + dangle*(angle.x*pdir + angle.y*tdir));\n        float t = dirBisectDist(cdir, obj.X, o.X);\n        if(t < db[j].x)\n        {\n            db[j] = vec2(t,db[j].x);\n            idb[j] = vec2(o.id,idb[j].x);\n        } \n        else if(t < db[j].y)\n        {\n            db[j].y = t;\n            idb[j].y = o.id;\n        }    \n    }\n}\n\nvoid insert()\n{\n    for (int j=0;j<dpd;j++)\n    {\n\t\t        \n    }\n}*/\n\nint ID; float avgR; float bd; vec3 dir;\n\nobject getObject(int id)\n{\n    object o;\n    if(id == maxN-1) id = 0;\n    \n    vec4 a = texel(ch0, i2xy(ivec3(id, 0, 0))); \n    o.X = a.xyz; o.bR = a.w;\n    o.a = texel(ch0, i2xy(ivec3(id, 1, 0))).xyz;\n    o.b = texel(ch0, i2xy(ivec3(id, 2, 0))).xyz;\n    o.c = texel(ch0, i2xy(ivec3(id, 3, 0))).xyz;\n    \n    o.id = id;\n    return o;\n}\n\nvec4 saveObject(int i)\n{\n    switch(i)\n    {\n    case 0:  \n        return vec4(obj.X, obj.bR);\n    case 1:\n        return vec4(obj.a, 0.);\n    case 2:\n        return vec4(obj.b, 0.);\n    case 3:\n        return vec4(obj.c, 0.);\n    }\n}\n\nvoid sort(int idtemp, int R, int T);\nvoid sortlinks(int id, int R, int R0, int T);\nvoid sortneighbors(int id, int R, int T);\nvoid sortrandom(int id, int R, int T);\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(floor(pos));\n    if(any(greaterThan(p, sN*N-1)) || iFrame>400) discard;\n   \n    ivec3 sid = xy2i(p); ID = sid.x;\n    vertex = texel(ch0, i2xy(ivec3(ID, 4, 0))).xyz;\n    obj = getObject(ID);\n   \tif(sid.z == 0) //object computation\n    {    \n        if(sid.y < 4) //object buffer\n        { \n            obj.X = (obj.a + obj.b + obj.c)/3.; \n            \n            //bounding sphere\n            obj.bR = max(distance(obj.X, obj.a),\n                     max(distance(obj.X, obj.b), \n                         distance(obj.X, obj.c)));\n            \n            if(iFrame<1 && ID < 418) //initial conditions\n            { \n                obj.a = vertecies[triangles[ID*3]-triz]/scale;\n                obj.b = vertecies[triangles[ID*3+1]-triz]/scale;\n                obj.c = vertecies[triangles[ID*3+2]-triz]/scale;\n\n                obj.a -= shift/scale;\n                obj.b -= shift/scale;\n                obj.c -= shift/scale;\n\n                obj.a = obj.a.xzy;\n                obj.b = obj.b.xzy;\n                obj.c = obj.c.xzy;\n            } \n            \n            U = saveObject(sid.y);\n        }\n        else if(sid.y == 4)//vertex buffer\n        {   \n            if(iFrame==2) //initial conditions\n            {\n                if(ID < 418)\n                {\n                    vertex = obj.X;  \n                }\n                else if(ID < 418 + 218)\n                {\n                    vertex = (vertecies[ID - 418] - shift)/scale;  \n            \t\tvertex = vertex.xzy;\n                }\n            }    \n            \n            U = vec4(vertex, 0);\n        }\n    }\n    else //graph computation\n    {\n        dangle = 0.5*distance(fibonacci_sphere(0, link0), fibonacci_sphere(1, link0)); \n        d0 = vec4(1e6); d1 = vec4(1e6);\n        lnk0 = vec4(maxN-1); lnk1 = vec4(maxN-1);\n        \n        dir = fibonacci_sphere(sid.y, link0);\n        vec4 nb = texel(ch0, i2xy(ivec3(ID, sid.y, 1)));\n        vec3 nbo = texel(ch0, i2xy(ivec3(toI(nb, 0), 4, 0))).xyz;\n        bd = dirBisectDist(dir, vertex, nbo, 0.);\n       \n        sortlinks(ID, sid.y, sid.y, sid.z);\n        \n        sortneighbors(ID, sid.y, sid.z);\n        \n        sortrandom(ID, sid.y, sid.z);\n        \n        U = lnk0 + lnk1*float(maxN);\n    }\n}\n\n\nbool iscoincidence(int id)\n{\n    return (id == maxN-1) || \n           any(equal(lnk0,vec4(id))) || \n           any(equal(lnk1,vec4(id)));\n}\n\nfloat bisectmarch(vec3 p, vec3 d, float D, in object o)\n{\n    p += d*D*0.005;\n    float DE = 1e10; float td = 0.;\n    for(int i = 0; i < 5; i++)\n    {\n        float sd = sdObj(p, o);\n        p += sd*d;\n        DE = min(sd, DE);\n        td+= sd;\n        if(td > D || sd < 0.001) break;\n    }\n    return DE;\n}\n\nvoid sort(int idtemp, int R, int T) //sort closest objects in N directions\n{\n    if(iscoincidence(idtemp)) return; //particle already sorted\n    float t = 1e10;\n    dir = fibonacci_sphere(R, link0);\n    switch(T)\n    {\n    case 1: //sort by bisector distance\n        if(idtemp == ID) return;\n        vec3 vpos = texel(ch0, i2xy(ivec3(idtemp, 4, 0))).xyz;\n      \n        vec2 pa = iMouse.xy/size;\n        t = dirBisectDist(dir, vertex, vpos, 0.5*dangle);\n        \n        if(t < 0.) return;\n        break;\n    case 2: //sort by sdf distance to this bisector line\n        object o = getObject(idtemp);\n       \n        bd = min(abs(bd), 3.);\n        float f = bd; float ii = 0.;\n        for(; f > 0.;) //find closest point on ray\n        {\n            float dd = 0.9*sdObj(vertex + f*dir, o) - 5.*f*dangle;\n            if(dd < 0.01) \n            {\n                t = bd - f + 0.1*dd;\n                break;\n            }\n            ii++;\n            f-=dd;\n        }\n        if(f <= 0. || ii > 5.) return;\n        break;\n    }\n    \n    insertion_sort(t, idtemp);\n}\n\nvoid sortlinks(int id, int R, int R0, int T)\n{\n    vec4 nb = texel(ch0, i2xy(ivec3(id, R, T)));\n    for(int i = min(0, iFrame); i<8; i++) \n        sort(toI(nb, i), R0, T);\n}\n\nvoid sortneighbors(int id, int R, int T)\n{\n    vec4 d4 = iSF(dir, float(link0));\n    for(int i = min(0, iFrame); i < 4; i++)\n    {\n         vec4 nb = texel(ch0, i2xy(ivec3(id, int(d4[i]), 1)));\n    \t for(int j = min(0, iFrame); j < 2; j++) \n         {\n            int nbid = toI(nb, j);\n            if(nbid == maxN-1) break;\n         \tsortlinks(nbid, (32*iFrame+8*j+i)%link0, R, T); \n         }\n    }  \n}\n\nvoid sortrandom(int id, int R, int T)\n{\n    for(int i = min(0, iFrame); i<5; i++) sort(int(float(tot_n)*hash13(vec3(iFrame, id, i))), R, T);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//prev closest triangle buffer\n//render\n\nfloat sdObj(vec3 p, in object o)\n{\n    float d = distance(p, o.X) - o.bR;\n    if(d > o.bR) return d;\n    return udTriangle(p, o.a, o.b, o.c) - 0.002;\n}\n\nobject getObject(int id)\n{\n    object o;\n    if(id == maxN-1) return o;\n    vec4 a = texel(ch0, i2xy(ivec3(id, 0, 0))); \n    o.X = a.xyz; o.bR = a.w;\n    o.a = texel(ch0, i2xy(ivec3(id, 1, 0))).xyz;\n    o.b = texel(ch0, i2xy(ivec3(id, 2, 0))).xyz;\n    o.c = texel(ch0, i2xy(ivec3(id, 3, 0))).xyz;\n    o.id = id;\n    return o;\n}\n\nfloat sdObjID(vec3 p, int id)\n{\n    vec4 X = texel(ch0, i2xy(ivec3(id, 0, 0)));\n    float d = distance(p, X.xyz) - X.w;\n    if(d > X.w || id > tot_n) return d;\n    return mix(udTriangle(p, texel(ch0, i2xy(ivec3(id, 1, 0))).xyz,\n                      \t texel(ch0, i2xy(ivec3(id, 2, 0))).xyz,\n                         texel(ch0, i2xy(ivec3(id, 3, 0))).xyz) - 0.002, d, clamp(d/X.w, 0., 1.));\n}\n\nstruct vtx\n{\n    vec3 X;\n    int id;\n};\n\nvtx getVertex(vec3 p, int i)\n{\n    vtx a;\n    a.X = p;\n    a.id = i;\n    return a;\n}\n\nvoid findClosest(vec3 p, inout vtx co, int mit)\n{    \n    float t = distance(p, co.X); \n    for(int s = min(0,iFrame); s < mit; s++)\n    {\n    \tint pid = co.id;\n        int dir = int(inverseSF(normalize(p - co.X), float(link0)).x);\n        vec4 nb = texel(ch0, i2xy(ivec3(co.id, dir%link0, 1)));\n        for(int i = min(0,iFrame); i<4; i++)\n        {\n            vec3 vpos = texel(ch0, i2xy(ivec3(toI(nb, i), 4, 0))).xyz;\n            float tt = distance(p, vpos);\n            if(tt < t)\n            {\n                t = tt;\n                co = getVertex(vpos, toI(nb, i));\n            }\n        }   \n        \n        if(pid == co.id) break;\n    }\n}\n\n#define maxd 20.\n#define mind 0.003\n#define maxs 64\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n\nfloat map(vec3 p, vec3 d, inout vtx co)\n{\n    //find closest vertex\n    findClosest(p, co, 5);\n \t\n    float DE = distance(co.X, p) - 0.001;\n    float a = 1. + 0.15*clamp(dot(normalize(p - co.X), d), -1., 0.);\n    \n    //compute sdf in this direction to the vertex\n    int dir = int(inverseSF(normalize(p - co.X), float(link0)).x);\n    vec4 nb = texel(ch0, i2xy(ivec3(co.id, dir%link0, 2)));\n    for(int i = 0; i < 5; i++)\n    {\n        DE = min(DE, sdObjID( p, toI(nb, i)));\n    }\n    \n    return min(a*DE, p.z+0.5);\n}\n\nvec4 calcNormal(vec3 p, float dx, in vtx co) {\n\tconst vec3 k = vec3(1,-1,0);\n\treturn   (k.xyyx*map(p + k.xyy*dx, vec3(0,0,1), co) +\n\t\t\t k.yyxx*map(p + k.yyx*dx,vec3(0,0,1), co) +\n\t\t\t k.yxyx*map(p + k.yxy*dx,vec3(0,0,1), co) +\n\t\t\t k.xxxx*map(p + k.xxx*dx,vec3(0,0,1), co))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\nvec3 col(vec3 p, in vtx co)\n{\n    //voronoi neighbors projected on the sphere surface\n    float t = 1e10;\n    vec3 D = normalize(p - co.X);\n    int cid = co.id;\n    int dir = int(inverseSF(D, float(link0)).x);\n    vec4 nb = texel(ch0, i2xy(ivec3(co.id, dir%link0, 1)));\n    for(int i = min(0,iFrame); i<0; i++)\n    {\n        vec3 vpos = texel(ch0, i2xy(ivec3(toI(nb, i), 4, 0))).xyz;\n        float tt = dirBisectDist(D, co.X, vpos, 0.);\n        if(tt < t)\n        {\n            t = tt;\n            cid = toI(nb, i);\n        }\n    }   \n   \n    return 0.5 + 0.5 * sin(vec3(1,2,3)*float(cid));\n}\n\n\n//voronoi diagram ray marching\nvec4 rayMarch(vec3 p, vec3 d, inout vtx co)\n{    \n    float td = 0.; float DE = 1e10;\n    for(int i = min(0, iFrame); i < maxs; i++)\n    {\n        //march\n        DE = map(p, d, co);\n        \n        p += DE*d;\n        td += DE;\n        \n        //outide of the scene\n        if(td > maxd) return vec4(p, -1.);\n        //has hit the surface\n        if(DE < mind*td)\n        {\n            p += - mind*td*d;\n            break;\n        }\n    }\n    return vec4(p, DE);\n}\n\nfloat shadow_march(vec4 pos, vec4 dir, float distance2light, float light_angle, inout vtx co)\n{\n\tfloat light_visibility = 1.;\n\tfloat ph = 1e5;\n    float td = dir.w;\n\tpos.w = map(pos.xyz, dir.xyz, co);\n\tfor (int i = min(0, iFrame); i < 20; i++) \n    {\n\t\tdir.w += pos.w;\n\t\tpos.xyz += pos.w*dir.xyz;\n\t\tpos.w = map(pos.xyz, dir.xyz, co);\n\t\tfloat y = pos.w*pos.w/(2.0*ph);\n        float d = (pos.w+ph)*0.5;\n\t\tfloat angle = d/(max(0.00001,dir.w-y-td)*light_angle);\n        light_visibility = min(light_visibility, angle);\n\t\tph = pos.w;\n\t\tif(dir.w >= distance2light) break;\n\t\tif(dir.w > maxd || pos.w < mind*dir.w) return 0.;\n    }\n\treturn 0.5 - 0.5*cos(PI*light_visibility);\n}\n\n\n#define FOV 2.\nmat3 getRot(vec2 a)\n{\n    \n   mat3 theta_rot = mat3(1, 0, 0,\n                         0, cos(a.y), sin(a.y),\n                         0, -sin(a.y), cos(a.y)); \n        \n   mat3 phi_rot = mat3(cos(a.x), sin(a.x), 0,\n        \t\t       -sin(a.x), cos(a.x), 0,\n        \t\t        0, 0, 1); \n   return transpose(phi_rot*theta_rot);\n}\n\nvec3 getRay(vec2 angles, vec2 pos)\n{\n    mat3 camera = getRot(angles);\n    return normalize(transpose(camera)*vec3(FOV*pos.x, FOV*pos.y, 1.));\n}\n\n\n#define ldir vec3(cos(iTime*0.1)*sin(PI*0.4),sin(iTime*0.1)*sin(PI*0.4), cos(PI*0.4))\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 HDRmapping(vec3 color, float exposure)\n{\n\t// Exposure tone mapping\n    vec3 mapped = ACESFilm(color * exposure);\n    // Gamma correction \n    return pow(mapped, vec3(1.0 / 2.2));\n}\n\nconst float Br = 0.0025;\nconst float Bm = 0.0003;\nconst float g =  0.9800;\nconst vec3 nitrogen = vec3(0.650, 0.570, 0.475);\nconst vec3 Kr = Br / pow(nitrogen, vec3(4.0));\nconst vec3 Km = Bm / pow(nitrogen, vec3(0.84));\n\nvec3 sky_color(in vec3 pos)\n{\n\t// Atmosphere Scattering\n\tvec3 fsun = ldir.xzy;\n\tfloat brightnees = exp(-sqrt(pow(abs(min(5.*(pos.y-0.1),0.)),2.)+0.1));\n\tif(pos.y < 0.)\n\t{\n\t\tpos.y = 0.;\n\t\tpos.xyz = normalize(pos.xyz);\n\t}\n    float mu = dot(normalize(pos), normalize(fsun));\n\t\n\tvec3 extinction = mix(exp(-exp(-((pos.y + fsun.y * 4.0) * (exp(-pos.y * 16.0) + 0.1) / 80.0) / Br) * (exp(-pos.y * 16.0) + 0.1) * Kr / Br) * exp(-pos.y * exp(-pos.y * 8.0 ) * 4.0) * exp(-pos.y * 2.0) * 4.0, vec3(1.0 - exp(fsun.y)) * 0.2, -fsun.y * 0.2 + 0.5);\n\tvec3 sky_col = brightnees* 3.0 / (8.0 * 3.14) * (1.0 + mu * mu) * (Kr + Km * (1.0 - g * g) / (2.0 + g * g) / pow(1.0 + g * g - 2.0 * g * mu, 1.5)) / (Br + Bm) * extinction;\n\tsky_col = 0.4*clamp(sky_col,0.,10.);\n\treturn pow(sky_col,vec3(1./1.5)); \n}\n\nvec3 ambient_sky_color(in vec3 pos)\n{\n\tfloat y = pos.y;\n\tpos.xyz = normalize(vec3(1,0,0));\n\treturn sky_color(pos)*exp(-abs(y));\n}\n\nvec4 ambient_occlusion(in vec4 pos, in vec4 norm, in vec4 dir, in vtx co)\n{\t\n\tvec3 pos0 = pos.xyz;\n\tvec3 ambient_color = ambient_sky_color(norm.xyz);\n\tpos.xyz += 0.03*dir.w*norm.xyz;\n    pos.w = map(pos.xyz,  dir.xyz, co);\n\tpos.xyz += pos.w*norm.xyz;\n\tnorm.w = length(pos0 - pos.xyz);\n\tfloat occlusion_angle = clamp(pos.w/norm.w,0.,1.);\n\treturn vec4(ambient_color,1.)*(0.5-cos(3.14159265*occlusion_angle)*0.5);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = (pos - size*0.5)/size.y;\n    vec2 angles = (iMouse.z>0.)?(iMouse.xy/iResolution.xy)*vec2(2.*PI, PI):vec2(-0.3*iTime, PI*0.55);\n    \n    vec3 d = getRay(angles, uv);\n    vec3 p = 0.*texel(ch0, i2xy(ivec3(94, 4, 0))).xyz-2.*getRay(angles, vec2(0.));\n    vec4 prev = pixel(ch1, pos);\n    if(iFrame < 1) prev.w = 0.;\n    int cid = int(prev.w)%tot_n;\n    vtx co = getVertex(texel(ch0, i2xy(ivec3(cid, 4, 0))).xyz,cid);\n    findClosest(p, co, 16);\n    cid = co.id;\n    \n    vec4 rm = rayMarch(p, d, co);\n    float td = distance(rm.xyz, p);\n    if(rm.w >= 0.) //hit object\n    {\n        vec3 color = 0.75+0.5*col(rm.xyz, co);\n    \tvec3 n = normalize(calcNormal(rm.xyz, mind*td,co).xyz);\n        vec4 ao = ambient_occlusion(rm, vec4(n, rm.w), vec4(d, td), co);\n        float sh = shadow_march(vec4(rm.xyz+n*td*mind, rm.w), vec4(ldir,td), 10., 0.12, co);\n        U.xyz = color*(sh*sky_color(ldir.xzy)*max(dot(ldir, n),0.) + ao.xyz);\n    }\n    else //background\n    {\n        U.xyz = sky_color(d.xzy);\n    }\n    \n    U.xyz = HDRmapping(U.xyz, 0.5);\n    U.w = float(cid);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdjyWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 101, 101, 136]], "test": "untested"}
{"id": "ws2yDh", "name": "Cubic Smootherstep", "author": "TinyTexel", "description": "Invertible smootherstep (C2 continuous s-curve) build from 3 cubic segments.\nred: cubic | blue: inverse | black: traditional | translucent: second derivatives (scaled)", "tags": ["smoothstep", "interpolation", "smootherstep", "scurve"], "likes": 7, "viewed": 500, "published": 3, "date": "1586578924", "time_retrieved": "2024-07-30T21:13:38.393613", "image_code": "// The MIT License\n// Copyright © 2020 Mirko Salm\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/*\nInvertible smootherstep (C2 continuous s-curve) build from 3 cubic segments.\n\n red  : cubic smootherstep\n blue : inverse of cubic smootherstep\n black: traditional quintic smootherstep\n(green: sine based smootherstep)\n\nSecond derivatives scaled by 1/8 are plotted in the background.\n*/\n\n#define PLOT_SECONDDERIVATIVES\n//#define PLOT_SINSMOOTHERSTEP\n\n\nfloat Smoothstep(float x)\n{\n    x = clamp(x, 0.0, 1.0);\n    \n    return (x*x) * (x * -2.0 + 3.0);\n}\n\n// https://www.shadertoy.com/view/MsSBRh\nfloat InverseSmoothstep(float y)\n{\n    return 0.5 - sin(asin(1.0-2.0*y)/3.0);\n}\n\n// traditional quintic smootherstep\nfloat Smootherstep(float x)\n{\n    x = clamp(x, 0.0, 1.0);\n    \n    return (x*x*x) * (x * (x * 6.0 - 15.0) + 10.0);\n}\n\n// sine based smootherstep\nfloat SinSmootherstep(float x)\n{\n    x = clamp(x, 0.0, 1.0);\n    \n    return x - sin(x * Pi2)/Pi2;\n}\n\nfloat CubicSmootherstep(float x)\n{\n    x = clamp(x, 0.0, 1.0);\n    \n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 16.0/3.0;\n    \n    if(x > 0.25)\n    {\n        a = 1.0/6.0;\n        b = -2.0;\n        c = 8.0;\n        d = -16.0/3.0;\n    }\n    \n    if(x > 0.75)\n    {\n        a = -13.0/3.0;\n        b = 16.0;\n        c = -16.0;\n        d = 16.0/3.0;\n    }\n    \n    return a + x * (b + x * (c + d * x));\n}\n\nfloat InverseCubicSmootherstep(float y)\n{\n    y = clamp(y, 0.0, 1.0);\n    \n    if(y > 1.0/12.0 && y < 11.0/12.0)\n    \treturn InverseSmoothstep(y * 1.0606601717798212 - 0.030330085889910707) * 0.7071067811865475 + 0.14644660940672627;\n           \n    float s = y < 0.5 ? 0.0 : 1.0;\n    \n    return abs(s - 0.5723571212766659 * pow(abs(s - y), 1.0/3.0));\n}\n\n// second derivatives\nfloat SmootherstepD2(float x)\n{\n\treturn x * (60.0 + x * (-180.0 + 120.0 * x));    \n}\n\nfloat CubicSmootherstepD2(float x)\n{\n    if(x < 0.25) return 32.0*x;\n    if(x > 0.75) return -32.0+32.0*x;\n    \n    return 16.0-32.0*x;\n}\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n\tvec2 uv = uv0 - 0.5;\n    uv0 += 0.0;\n    \n    vec2 tex = uv0;\n    tex -= iResolution.xy * 0.125;\n    tex /= iResolution.xx * 0.125;\n\n    tex *= 0.25+0.0375;\n\n    vec3 col = vec3(0.0);\n    \n\tcol = mix(vec3(1.0), vec3(0.9), Grid(tex.xy * 4.0, 0.0));        \n\tcol = mix(col, vec3(0.5), Grid(tex.xy * 1.0, 0.0));        \n\tcol = mix(col, vec3(0.125), Cross(tex.xy * 1.0, 0.)); \t\n    \n    \n    \n    #ifdef PLOT_SECONDDERIVATIVES\n    col = mix(col, vec3(0.0), 0.2*Graph(SmootherstepD2(tex.x)*0.125 - tex.y, 1.125));       \n    col = mix(col, vec3(1.0, 0.1, 0.1), 0.2*Graph(CubicSmootherstepD2(tex.x)*0.125 - tex.y, 1.125));       \n    \n    #ifdef PLOT_SINSMOOTHERSTEP\n    col = mix(col, vec3(0.0, 1.0, 0.2), 0.3*Graph(sin(tex.x*Pi2)*Pi2*0.125 - tex.y, 1.125));       \n    #endif\n    #endif\n    \n    col = mix(col, vec3(0.0), 0.90*Graph(Smootherstep(tex.x) - tex.y, 0.5));       \n\n    col = mix(col, vec3(0.0, 0.5, 1.0), 1.0*Graph(InverseCubicSmootherstep(tex.x) - tex.y, 0.5));       \n    col = mix(col, vec3(1.0, 0.1, 0.1), 1.0*Graph(CubicSmootherstep(tex.x) - tex.y, 0.5));   \n    \n    #ifdef PLOT_SINSMOOTHERSTEP\n    col = mix(col, vec3(0.0, 1.0, 0.2), 0.75*Graph(SinSmootherstep(tex.x) - tex.y, 0.5));       \n\t#endif\n    \n    \n    \n    #if 1\n    vec2 s = (uv0/iResolution.xy*2.0-1.0);\n    s.x = 1.0-Pow2(s.x);    s.y = 1.0-Pow2(s.y);\n    col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\n    #endif\n    \n    outCol = vec4(GammaEncode(clamp01(col)), 1.0);    \n\n}", "image_inputs": [], "common_code": "#define PixelCount iResolution.xy\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define rsqrt inversesqrt\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\nconst float Pi2  = Pi * 2.0;\nconst float RcpPi= 1.0 / Pi;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\nfloat ddxyLen(float v) { return length(vec2(dFdx(v), dFdy(v))); }\nfloat ddxyRcpLen(float v) { return rsqrt( Pow2(dFdx(v)) + Pow2(dFdy(v)) ); }\n\n\nfloat rescale(float v) { return v * ddxyRcpLen(v); }\n\nfloat Graph(float f, float b)\n{\n    return clamp01(1.0 - (abs(rescale(f))-0.5-b)); \n}\n\n\nfloat Line(float u, float b) { return Graph(u, b); }\nfloat Lines(float u, float b) { return Graph(sin(u * Pi), b); }\n\nfloat Grid(vec2 uv, float b)\n{\n    float xl = Lines(uv.x, b);    \n    float yl = Lines(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Cross(vec2 uv, float b)\n{\n    float xl = Line(uv.x, b);    \n    float yl = Line(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Dot(vec2 uv, vec2 dp, float dr)\n{\n    float v = length(uv - dp) - dr;\n    \n    if(v > dr) return 0.0;\n    \n    v *= ddxyRcpLen(v);\n    v = 1.0 - clamp(v * 1.0, 0.0, 1.0);\n    \n    return v;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2yDh.jpg", "access": "api", "license": "mit", "functions": [[1429, 1429, 1456, 1456, 1528], [1530, 1571, 1605, 1605, 1650], [1652, 1688, 1717, 1717, 1804], [1806, 1833, 1865, 1865, 1933], [1935, 1935, 1969, 1969, 2361], [2363, 2363, 2404, 2404, 2717], [2719, 2741, 2772, 2772, 2825], [2827, 2827, 2863, 2863, 2964], [2967, 2967, 3015, 3015, 4472]], "test": "untested"}
{"id": "3sBcDh", "name": "Root Between Cubic Extrema", "author": "TinyTexel", "description": "Using the inverse of smoothstep to analytically find a root bounded by two unique extrema of a cubic polynomial.\nred: polynomial | orange: rescaled smoothstep | magenta: root | blue: derivative of polynomial", "tags": ["smoothstep", "cubic", "quadratic"], "likes": 6, "viewed": 388, "published": 3, "date": "1586576033", "time_retrieved": "2024-07-30T21:13:39.351054", "image_code": "// The MIT License\n// Copyright © 2020 Mirko Salm\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/*\nUsing the inverse of smoothstep to analytically find a root bounded by two unique extrema of a cubic polynomial.\n\nred    : cubic polynomial\norange : smoothstep rescaled to match the polynomial (only works with two unique extrema)\nmagenta: root found using inverse smoothstep, see RootBetweenCubicExtrema(..)\nblue   : derivative of polynomial\n*/\n\n\nfloat cubic(float x) { return x*x*(3.0-2.0*x); }\nfloat ilerp(float a, float b, float y) { return (y - a) / (b - a); }\n\nvec4 Poly3Coeffs(float v0, float d0, float v1, float d1)\n{\n    vec4 C;\n\n    C.x = v0;\n    C.y = d0;\n    C.z = -2.0 * d0 - d1 - 3.0 * (v0 - v1);\n    C.w = d0 + d1 + 2.0 * (v0 - v1);\n\n    return C;\n}\n\nvec3 Poly3D1Coeffs(float v0, float d0, float v1, float d1)\n{\n    vec3 C;\n\n    C.x = d0;\n    C.y = -4.0 * d0 - 2.0 * d1 - 6.0 * (v0 - v1);\n    C.z = 3.0 * (d0 + d1) + 6.0 * (v0 - v1);\n\n    return C;\n}\n\n\nfloat EvalPoly(float x, vec3 C)\n{\n    return C.x + x * (C.y + x * C.z);\n}\n\nfloat EvalPoly(float x, vec4 C)\n{\n    return C.x + x * (C.y + x * (C.z + x * C.w));\n}\n\n// https://math.stackexchange.com/questions/866331/numerically-stable-algorithm-for-solving-the-quadratic-equation-when-a-is-very\nbool QuadraticRoots(inout vec2 roots, float c, float b, float a)\n{\n    roots = vec2(0.0);\n\n    if (a == 0.0)\n    {\n        if (b == 0.0)\n        {\n            return c == 0.0;\n        }\n\n        roots.x = roots.y = -c / b;\n\n        return true;\n    }\n\n    float D = b * b - 4.0 * a * c;\n\n    if (D < 0.0) return false;\n\n    //roots = (-b + vec2(1.0,-1.0)*sqrt(D)) / (2.0*a);\n    roots.x = (-b - sign(b) * sqrt(D)) / (2.0 * a);\n    roots.y = c / (a * roots.x);\n\n    return true;\n}\n\nbool QuadraticRoots(inout vec2 roots, vec3 C)\n{\n    return QuadraticRoots(roots, C.x, C.y, C.z);\n}\n\nbool CubicExtrema(inout vec4 extrema, float v0, float d0, float v1, float d1)\n{\n    extrema = vec4(0.0);\n\n    vec4 C = Poly3Coeffs(v0, d0, v1, d1);\n\n    if (C.w == 0.0) return false;\n\n    vec2 roots;\n    bool DoRootsExist = QuadraticRoots(roots, C.yzw * vec3(1.0, 2.0, 3.0));\n\n    if (DoRootsExist == false) return false;\n\n    extrema.xy = vec2(roots.x, EvalPoly(roots.x, C));\n    extrema.zw = vec2(roots.y, EvalPoly(roots.y, C));\n\n    return true;\n}\n\nbool IsCubicSegSomeNeg(float v0, float d0, float v1, float d1)\n{\n    if (v0 < 0.0 || v1 < 0.0) return true;\n\n    vec4 extrema;\n    bool DoExtremaExist = CubicExtrema(extrema, v0, d0, v1, d1);\n\n    if (DoExtremaExist == false) return false;\n\n    if ((extrema.x >= 0.0 && extrema.x <= 1.0 && extrema.y < 0.0) ||\n        (extrema.z >= 0.0 && extrema.z <= 1.0 && extrema.w < 0.0)) return true;\n\n    return false;\n}\n\nbool IsCubicSegSomeNeg(vec2 vd0, vec2 vd1)\n{\n    return IsCubicSegSomeNeg(vd0.x, vd0.y, vd1.x, vd1.y);\n}\n\n// https://iquilezles.org/articles/ismoothstep\nfloat inverse_smoothstep(float y)\n{\n    return 0.5 - sin(asin(1.0-2.0*y)/3.0);\n}\n\nfloat RootBetweenCubicExtrema(vec4 extrema)\n{\n    // solve: mix(extrema.y, extrema.w, cubic(ilerp(extrema.x, extrema.z, x))) == 0\n    \n    return mix(extrema.x, extrema.z, inverse_smoothstep(ilerp(extrema.y, extrema.w, 0.0)));\n}\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n\tvec2 uv = uv0 - 0.5;\n    uv0 += 0.0;\n    \n    vec2 tex = uv0;\n    tex -= iResolution.xy * vec2(0.1, 0.4);\n    tex /= iResolution.xx * 0.125;\n\n    tex *= 0.25+0.0375;\n    \n\n    vec3 col = vec3(0.0);\n    \n\tcol = mix(vec3(1.0), vec3(0.9), Grid(tex.xy * 4.0, 0.0));        \n\tcol = mix(col, vec3(0.5), Grid(tex.xy * 1.0, 0.0));        \n\tcol = mix(col, vec3(0.125), Cross(tex.xy * 1.0, 0.)); \t\n    \n    #if 0\n    float v0 = 0.5;\n    float d0 = 2.0;\n    float v1 = -0.125;\n    float d1 = 1.0;\n    #elif 0\n    float v0 = 0.5;\n    float d0 = -3.0;\n    float v1 = 0.125;\n    float d1 = 0.4;\n    #else\n    float v0 = 0.5;\n    float v1 = 0.;\n    float d0 = v1-v0;\n    float d1 = d0;\n    #endif   \n      \n    v1 = sin(float(iTime))*0.5;\n    \n    #if 0\n    if(IsCubicSegSomeNeg(v0, d0, v1, d1))\n    {\n        col = mix(col, vec3(0.5, 1.0, 0.0), 0.5*Dot(tex.xy, vec2(0.5, 0.5), 0.25));       \n    }\n    #endif\n    \n    vec4 extrema;\n    bool DoExtremaExist = CubicExtrema(extrema, v0, d0, v1, d1);\n    \n    vec4 C  = Poly3Coeffs(v0, d0, v1, d1);\n    vec3 Cd = Poly3D1Coeffs(v0, d0, v1, d1);\n    \n    vec2 roots;\n    bool DoRootsExist = QuadraticRoots(roots, Cd);\n\n    col = mix(col, vec3(0.0, 0.5, 1.0), 0.5*Graph(EvalPoly(tex.x, Cd) - tex.y, 0.5));       \n    \n    if(DoRootsExist)\n    {\n        col = mix(col, vec3(0.0, 0.5, 1.0), 0.5*Dot(tex.xy, vec2(roots.x, 0.0), 0.02));       \n    \tcol = mix(col, vec3(0.0, 0.5, 1.0), 0.5*Dot(tex.xy, vec2(roots.y, 0.0), 0.02));  \n        \n        #if 1\n        if(DoExtremaExist)\n        {\n    \t\tcol = mix(col, vec3(1.0, 0.5, 0.0), 0.5 * Graph(mix(extrema.y, extrema.w, cubic(ilerp(extrema.x, extrema.z, tex.x))) - tex.y, 7.0));       \n            \n            float x0 = RootBetweenCubicExtrema(extrema);\n    \t\tcol = mix(col, vec3(1.0, 0.5, 1.0), 0.5* Dot(tex.xy, vec2(x0, 0.0), 0.05));       \n    \t\tcol = mix(col, vec3(1.0, 0.0, 1.0), Dot(tex.xy, vec2(x0, 0.0), 0.02));       \n                \n    \t\tcol = mix(col, vec3(1.0, 0.0, 0.0), Dot(tex.xy, extrema.xy, 0.02));       \n    \t\tcol = mix(col, vec3(1.0, 0.0, 0.0), Dot(tex.xy, extrema.zw, 0.02));   \n        }\n        #else\n    \tcol = mix(col, vec3(1.0, 0.0, 0.0), Dot(tex.xy, vec2(roots.x, EvalPoly(roots.x, C)), 0.02));       \n    \tcol = mix(col, vec3(1.0, 0.0, 0.0), Dot(tex.xy, vec2(roots.y, EvalPoly(roots.y, C)), 0.02));       \n        #endif\n    }\n    \n    col = mix(col, vec3(1.0, 0.0, 0.0), Graph(EvalPoly(tex.x, C) - tex.y, 0.5));       \n    \n    #if 1\n    vec2 s = (uv0/iResolution.xy*2.0-1.0);\n    s.x = 1.0-Pow2(s.x);    s.y = 1.0-Pow2(s.y);\n    col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\n    #endif\n    \n    outCol = vec4(GammaEncode(clamp01(col)), 1.0);    \n\n}", "image_inputs": [], "common_code": "\n#define PixelCount iResolution.xy\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define rsqrt inversesqrt\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\nconst float Pi2  = Pi * 2.0;\nconst float RcpPi= 1.0 / Pi;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\nfloat ddxyLen(float v) { return length(vec2(dFdx(v), dFdy(v))); }\nfloat ddxyRcpLen(float v) { return rsqrt( Pow2(dFdx(v)) + Pow2(dFdy(v)) ); }\n\n\nfloat rescale(float v) { return v * ddxyRcpLen(v); }\n\nfloat Graph(float f, float b)\n{\n    return clamp01(1.0 - (abs(rescale(f))-0.5-b)); \n}\n\n\nfloat Line(float u, float b) { return Graph(u, b); }\nfloat Lines(float u, float b) { return Graph(sin(u * Pi), b); }\n\nfloat Grid(vec2 uv, float b)\n{\n    float xl = Lines(uv.x, b);    \n    float yl = Lines(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Cross(vec2 uv, float b)\n{\n    float xl = Line(uv.x, b);    \n    float yl = Line(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Dot(vec2 sp, vec2 dp, float dr)\n{\n    float v = length(sp - dp) - dr;\n    \n    if(v > dr) return 0.0;\n    \n    v *= ddxyRcpLen(v);\n    v = 1.0 - clamp(v * 1.0, 0.0, 1.0);\n    \n    return v;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sBcDh.jpg", "access": "api", "license": "mit", "functions": [[1426, 1426, 1448, 1448, 1474], [1475, 1475, 1515, 1515, 1543], [1545, 1545, 1603, 1603, 1742], [1744, 1744, 1804, 1804, 1943], [1946, 1946, 1979, 1979, 2019], [2021, 2021, 2054, 2054, 2106], [2108, 2238, 2304, 2304, 2717], [2719, 2719, 2766, 2766, 2817], [2819, 2819, 2898, 2898, 3269], [3271, 3271, 3335, 3335, 3681], [3683, 3683, 3727, 3727, 3787], [3789, 3836, 3871, 3871, 3916], [3918, 3918, 3963, 4047, 4146], [4148, 4148, 4196, 4196, 6857]], "test": "untested"}
{"id": "td2yWh", "name": "Sonic Salad", "author": "blackle", "description": "an impromptu shader live coded in 30 minutes in front of my roommate. I was inspired by shader showdown and wanted to try it out. programmed on my phone with a bluetooth keyboard which was immensely frustrating", "tags": ["livecode"], "likes": 16, "viewed": 665, "published": 3, "date": "1586566028", "time_retrieved": "2024-07-30T21:13:40.255635", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n#define time iTime\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n\treturn mix(dot(p,ax)*ax,p,cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n  float k = dot(p-a,b-a)/dot(b-a,b-a);\n  return distance(p, mix(a, b, clamp(k,0.,1.) ));\n}\n\nfloat hash(float a, float b) {\n\treturn -1.+2.*fract(sin(dot(vec2(a,b), vec2(12.4348,74.38483)))*48573.2394);\n}\n\nfloat scene(vec3 p ) {\n\tfloat scale  = 0.2;\n\tvec3 id = floor(p*scale);\n    float idhash = hash(hash(id.y, id.x), id.z);\n\tfloat hash1 = hash(idhash, id.y)*6.28;\n\tfloat hash2 = hash(id.x, idhash)*6.28;\n\tvec3 ax = normalize(vec3(cos(hash1), sin(hash1)*cos(hash2), sin(hash1)*sin(hash2)));\n\tfloat ro = hash(hash1+id.y, idhash)*6.28;\n\tp = (fract(p*scale)-0.5)/scale;\n\tp = erot(p, ax, ro+time*0.7);\n\tp += vec3(hash(hash1,hash2+6.), hash(hash1+5.,hash2), hash(hash2,hash1+3.))*1.;\n\tfloat sphere = length(p)-1.;\n\treturn min(.5,linedist(vec2(p.z, sphere), vec2(-0.1,0.), vec2(0.1,0.))-0.1);\n}\n\nvec3 norm(vec3 p) {\n\tmat3 k = mat3(p,p,p) - mat3(0.01);\n\treturn normalize(scene(p) - vec3(scene(k[0]), scene(k[1]), scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n  uv = erot(vec3(uv,0.), vec3(0,0,1), cos(time*0.5)*0.5).xy;\n  vec3 cam = normalize(vec3(1,uv));\n  vec3 init = vec3(time,0,cos(time*0.4)*2.);\n  cam=erot(cam,vec3(0,1,0),cos(time/8.)*0.3);\n  cam=erot(cam,vec3(0,0,1),time/4.);\n  vec3 p = init;\n  bool hit = false;\n  for (int i = 0; i< 100; i++) {\n  \tfloat dist = scene(p);\n  \tif (dist*dist < 0.00001) { hit = true; break; }\n  \tif (distance(p,init)>30.) break;\n  \tp+=cam*dist;\n  }\n\n  uv *=32.;\n  uv += vec2(sin(time*1.), cos(time*1.5))*2.;\n  //uv = erot(vec3(uv,0.), vec3(0,0,1), cos(time*0.5)*0.5).xy;\n\n  fragColor = cos(uv.y)*cos(uv.x) < 0. ? vec4(0.2,0.5,0.9,1.) : vec4(0.);\n  if (hit) {\n  \tvec3 n = norm(p);\n  \tvec3 rf = reflect(cam, n);\n    float shadow = scene(p+rf) + .5;\n  \tfloat factor = shadow*length(sin(rf*3.)*0.5+0.5)/sqrt(2.);\n  \tvec3 col = mix(vec3(0.3,0.25,0.1), vec3(0.8,0.6,0.2), factor) + pow(factor*0.8, 6.);\n    fragColor.xyz = mix(col, fragColor.xyz, pow(distance(p, init)/30., 50.));\n  }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2yWh.jpg", "access": "api", "license": "cc0-1.0", "functions": [[214, 214, 252, 252, 313], [315, 315, 355, 355, 446], [448, 448, 478, 478, 558], [560, 560, 582, 582, 1143], [1145, 1145, 1164, 1164, 1277], [1279, 1279, 1336, 1336, 2354]], "test": "untested"}
{"id": "3sjyD1", "name": "Awaken", "author": "dashsc", "description": "Infinite zoom", "tags": ["2d"], "likes": 1, "viewed": 335, "published": 3, "date": "1586559189", "time_retrieved": "2024-07-30T21:13:41.099379", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).rgb;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "mat2 rotate2d(float a) {\n    return mat2(sin(a),cos(a),-cos(a),sin(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 col = vec3(0.);\n    vec2 tv = uv;\n    float time = iTime*0.5;\n    //tv *= time;\n    //tv -= 0.5;\n    //tv *= fract(time*0.5)*10.;\n    //tv += 0.5;\n    vec2 ug = fract(tv*20.);\n    vec2 ug1 = fract(tv*22.);\n    //ug *= fract(time);\n    //ug1 *= fract(time*0.1);\n    ug -= 0.5;\n    //ug *= time;\n    //float steps = 8.;\n    //float steps = time*fract(time);\n    float steps = time*fract(length(tv-0.5)+time*0.01);\n    //float steps = time*sin(length(tv-0.5));\n    //steps *= 1.-(1./((time*0.1)+1.));\n    //col += length(ug);\n    //col = vec3(0.5);\n    if (steps > 1000.) {\n        steps = 10.;\n    }\n    steps += 3.;\n    for (float i=0.; i<steps; i++) {\n        float tt = fract((time+i*0.5)*0.5);\n        vec2 sv = tv;\n        tt *= 1.;\n        //sv = fract(tv*10.);\n        sv -= 0.5;\n        sv *= tt*rotate2d(i*time*0.001+time*0.1);\n        sv += 0.5;\n        sv = fract(sv*10.*i);\n        //col += mix(col.r,length(sv-0.5),abs(tt*0.5)*2.);\n        col += mix(length(sv-0.5),0.5,(abs(tt-0.5)*2.))*(1./steps);\n    }\n    vec3 bak = texture(iChannel0, tv).rgb;\n    col = mix(col,bak,0.01);\n    //col = sin(bak);\n    //col *= bak.r;\n    col.rg = sin(col.bb*5.+time*0.5)*0.5+0.5;\n    col.gb = sin(col.rb*10.+time)*0.5+0.5;\n    col = mix(col,bak,.94);\n    col = fract(col+0.002);\n    //col -= 0.3;\n    //col *= 100.;\n    //col += length(ug1-0.5);\n    //col += sin(uv.x*200+time);\n    //col = fract(col*10.);\n    \n    fragColor = vec4(col, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sjyD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 256]], "test": "untested"}
{"id": "Ws2cW1", "name": "Day 113", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 7, "viewed": 410, "published": 3, "date": "1586558683", "time_retrieved": "2024-07-30T21:13:41.970051", "image_code": "\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n// from https://necessarydisorder.wordpress.com/\nfloat ease(float p, float g) {\n    if(p < 0.){\n        return 0.;\n    } else if(p > 1.){\n    \treturn 1.;\n    } else {\n        if (p < 0.5) \n            return 0.5 * pow(2.*p, g);\n        else\n            return 1. - 0.5 * pow(2.*(1. - p), g);\n    }\n}\n\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat smaxi( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n#define iTime mod(iTime, 2.37)\n\n    float d = 10e7;\n    \n    float range = 1.;\n    \n    float w = 20.5;\n    \n    p.x -= w*1.;\n    float sdPl = sdBox( p, vec2(w,2.));\n    \n    p.x += w*1.;\n    vec2 bp = vec2(0);\n    \n    float ea = ease(iTime,3.);\n    float eb = ease(iTime- 1.,3.);\n    \n    float ec = ease((iTime- 2.)*2./0.65,1.);\n    \n    bp.x -= range*0.5;\n    bp.x += ea;\n    bp.x -= eb;\n    \n    float sz = 0.15;\n    \n    float sdB = length(p - bp) - sz;\n    \n \n    float amt = 0.4;\n    \n    d = min(d, sdPl);\n    //d = min(d, length(p - bp) - 0.1);\n    \n    \n    //col += smoothstep(0.,0.001,-d);\n    \n    \n    d = mix(\n        d = smin(d, sdB, amt),\n        d = smaxi(d, -sdB, amt),\n        ea\n    );\n    \n    if(iTime > 2.){\n    \n        bp -= bp;\n        bp.x -= range/2.*ec;\n        d = sdPl;\n    \t//sdB = length(p - bp) - ec*0.4+ (0.)*(1. - pow(ec, 0.2));\n        sdB = length(p - bp) - ec*sz+ (sz)*(1. - pow(ec, 0.6));\n    \t//d = smin(d, sdB, ec*1.*amt);\n        d = smin(d, sdB, 1.*amt);\n        \n        \n    }\n    \n    \n    \n    \n    //d = min(d, sdPl);\n    \n    //d = min(d, smaxi(sdPl, -sdPl, 0.4));\n    //d = max(d, -smaxi(sdB, sdPl, amt*0.3));\n    \n    //d = smin(d, min(length(p - bp) - 0.1, -sdPl), 0.3);\n    \n    \n    //d = min(d, -sdPl);\n    \n    col += smoothstep(0.,0.004,-d);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2cW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 38, 38, 118], [120, 120, 165, 165, 256], [258, 307, 337, 337, 557], [560, 560, 603, 603, 702], [705, 705, 748, 748, 848], [850, 850, 894, 894, 993], [996, 996, 1053, 1053, 2479]], "test": "untested"}
{"id": "Wd2cDh", "name": "Smiley Shadertoy Discord server", "author": "soundmasteraj", "description": "Come join us: https://discord.gg/XtmMN6E forked it to animate it", "tags": ["smiley", "discord", "community", "chat"], "likes": 3, "viewed": 445, "published": 3, "date": "1586554987", "time_retrieved": "2024-07-30T21:13:43.071107", "image_code": "// Fork of \"Shadertoy Discord server\" by nimitz. https://shadertoy.com/view/tljGDh\n// 2020-04-10 21:41:47\n\n// Procedural Discord logo\n// by nimitz 2019 (twitter: @stormoid)\n// the Discord logo is a property of Discord inc.\n\n/*\n\tShadertoy now has a discord server!\n\n\tCome join iq, poljere, fizzer, paniq, P_Malin, mmalex, mattz, reinder, rez and nimitz (me)\n\tand many more of us (and even more as they join) to discuss shader development and\n\treal-time rendering related topics, share resources, advancements and your own work.\n\t\n\tLink: https://discord.gg/XtmMN6E\n\tLink also on the shadertoy about page: https://www.shadertoy.com/about\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = gl_FragCoord.xy/iResolution.xy;\n    vec2 p = (gl_FragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    float rx = abs(p.x);\n    float rx2 = rx*rx, rx3 = rx*rx*rx;\n    float rx4 = rx2*rx2;\n    float pds = p.y + 0.2;\n    float logo = abs(pds*pds)*2.0 + rx*3.6 - 1.2; //sides\n    logo = max(logo, rx3*8. + p.y*4.04 + - 0.75); // topmost\n    logo = max(logo, rx*rx4*24. - p.y*4.0 - 0.84); // bottommost\n    logo = max(logo, 0.72 - clamp(rx-0.19,-0.01,3.)*4. - p.y*3.2 + rx*0.4 -1.2); // chin\n    logo = max(logo, 0.8 - clamp(rx-0.1, 0., 3.)*4. + p.y*3.2 - 1.2); // forehead\n    float sinVal = (.25-(abs(sin(iTime*2.0))*.5-.25)+ .45 ); // lol sine\n    logo = max(logo, (.5-abs(p.y*6.7 + 1.8 - 7.*rx2))*sinVal- rx*rx4*16. + 0.21); // mouth\n    logo = max(logo, (.5 - abs(p.y*7. - 1.85 + 6.5*rx2))*0.5 - rx*rx4*17.5 + 0.21); // brow\n    float upEyes = sinVal*-.025; // nudge eyes up\n    logo = 1.-min(1.-logo, 4.*length(vec2(abs(p.x*1.14)-0.16, p.y+.05+upEyes))+.24); //eyes\n    \n    vec3 col = mix(vec3(0.97), vec3(0.435, 0.521, 0.831), smoothstep(0.4, 0.41 + 1.5/iResolution.y, logo));\n    col *= pow(30.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1)*0.5 + 0.5;\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2cDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[640, 640, 697, 697, 1890]], "test": "untested"}
{"id": "wdScD1", "name": "Stairway to Heaven", "author": "Chusy", "description": "Glowing circles", "tags": ["glowcircles"], "likes": 2, "viewed": 293, "published": 3, "date": "1586550554", "time_retrieved": "2024-07-30T21:13:44.069438", "image_code": "\n// CIRCLES\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 coord = fragCoord.xy / iResolution.xy;\n    vec3 color = vec3(0.0);\n    vec2 translate = vec2(-0.5);\n    coord += translate;\n\n    color.r += abs(0.1 + length(coord) - 0.6 * abs(sin(iTime * 0.9) /.95));\n    color.g += abs(0.1 + length(coord) - 0.6 * abs(sin(iTime * 0.6) * .85));\n    color.b += abs(0.1 + length(coord) - 0.6 * abs(sin(iTime * 0.8) * .49));\n    \n\n    fragColor = vec4(0.05 / color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdScD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[13, 13, 67, 67, 480]], "test": "untested"}
{"id": "3d2yWh", "name": "The eye of ellipse", "author": "andretugan", "description": "Ellipse generation with perpendicular bisectors.\n", "tags": ["lines", "ellipse"], "likes": 4, "viewed": 339, "published": 3, "date": "1586544438", "time_retrieved": "2024-07-30T21:13:44.932131", "image_code": "// Author: https://www.shadertoy.com/user/andretugan\n// Creative Commons Attribution-NonCommercial 3.0 Unported License\n// https://creativecommons.org/licenses/by-nc/3.0\n\n#define NUM_CHORDS 32\n\n#define M_PI 3.14159265358\n#define M_2_PI (2. * 3.14159265358)\n\n#define FADE_INNER_RADIUS 0.8\n#define FADE_OUTER_RADIUS 1.1\n#define LINE_WIDTH 4.\n\n// Function from Inigo Quilez\n// https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat DrawLine(vec2 uv, vec2 origin, vec2 dir_not_normed) {\n    float proj = dot(uv - origin, dir_not_normed) / dot(dir_not_normed, dir_not_normed);\n    vec2 perp = origin + proj * dir_not_normed - uv;\n    float dist2 = dot(perp, perp);\n    \n    float line_width = LINE_WIDTH / iResolution.y;        \n                                \n    float val = smoothstep(line_width * line_width, line_width * line_width * 0.5, dist2);        \n    val *= smoothstep(FADE_OUTER_RADIUS * FADE_OUTER_RADIUS, FADE_INNER_RADIUS * FADE_INNER_RADIUS, dot(uv, uv));        \n    return val;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{           \n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    float uv2 = dot(uv, uv);\n    if (dot(uv, uv) > FADE_OUTER_RADIUS * FADE_OUTER_RADIUS) { \n    \tfragColor = vec4(0.0,0.0,0.0,1.0);\n        return;\n    }\n               \n    float focus_radius = 0.4 + 0.4 * sin(iTime * 0.23) * cos(iTime * 0.17);\n    float focus_angle = M_PI + M_PI * sin(iTime * 0.29) * cos(iTime * 0.19);\n    vec2 focus = vec2(focus_radius * cos(focus_angle), focus_radius * sin(focus_angle));\n    \n          \n    float val = 0.;\n\n    for (int i = 0; i < NUM_CHORDS; ++i) {\n        float angle = M_2_PI / float(NUM_CHORDS) * float(i);\n        \n        vec2 point = vec2(cos(angle), sin(angle));\t                               \n        vec2 diff = point - focus;\n        vec2 perp = vec2(diff.y, -diff.x);\n        \n        vec2 mid = 0.5 * (point + focus);\n       \n        val += DrawLine(uv, point, diff);\n        val += DrawLine(uv, mid, perp);        \n    }\n    \n    val *= 10. / float(NUM_CHORDS);\n    val = pow(val, 0.5);\n    \n    float hue = sin(iTime * 0.02 + uv2 * 0.3);     \t    \n    fragColor = vec4(hsv2rgb(vec3(hue, 1. - 0.8 * uv2, val)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d2yWh.jpg", "access": "api", "license": "cc-by-3.0", "functions": [[341, 412, 439, 439, 617], [619, 619, 678, 678, 1191], [1193, 1193, 1249, 1249, 2397]], "test": "untested"}
{"id": "tdScD1", "name": "Psychedelic Dodec experiment", "author": "mrange", "description": "License: CC0\nResults after some random coding while listening to online concert", "tags": ["2d", "dodec"], "likes": 41, "viewed": 1164, "published": 3, "date": "1586539198", "time_retrieved": "2024-07-30T21:13:45.856659", "image_code": "// License: CC0\n//  Results after some random coding while listening to online concert\n\n// Experiment with these parameters for variants\nconst float size  = 0.75 ;\nconst float offc  = 1.05;\nconst float width = 0.0125;\nconst int   rep   = 15 ;\n\n#define PHI   (.5*(1.+sqrt(5.)))\n#define PI    3.141592654\n#define TAU   (2.0*PI)\n#define TTIME (TAU*iTime)\n\nconst vec3 plnormal = normalize(vec3(1, 1, -1));\nconst vec3 n1 = normalize(vec3(-PHI,PHI-1.0,1.0));\nconst vec3 n2 = normalize(vec3(1.0,-PHI,PHI+1.0));\nconst vec3 n3 = normalize(vec3(0.0,0.0,-1.0));\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat dodec(in vec3 z) {\n  vec3 p = z;\n  float t;\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=2.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=2.0*t*n2; }\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=2.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=2.0*t*n2; }\n  z = abs(z);\n\n  float dmin=dot(z-vec3(size,0.,0.),plnormal);\n        \n  dmin = abs(dmin) - width*7.5*(0.55 + 0.45*sin(10.0*length(p) - 0.5*p.y + TTIME/9.0));\n        \n  return dmin;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat df(vec2 p) {\n  float d = 100000.0;\n  float off = 0.30  + 0.25*(0.5 + 0.5*sin(TTIME/11.0));\n  for (int i = 0; i < rep; ++i) {\n    vec2 ip = p;\n    rot(ip, float(i)*TAU/float(rep));\n    ip -= vec2(offc*size, 0.0);\n    vec2 cp = ip;\n    rot(ip, TTIME/73.0);\n    float dd = dodec(vec3(ip, off*size));\n    float cd = length(cp - vec2(0.25*sin(TTIME/13.0), 0.0)) - 0.125*size;\n    cd = abs(cd) - width*0.5;\n    d = pmin(d, dd, 0.05);\n    d = pmin(d, cd, 0.025);\n  }\n  return d;\n}\n\nvec3 postProcess(vec3 col, vec2 q, vec2 p) {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  const float r = 1.5;\n  float d = max(r - length(p), 0.0)/r;\n  col *= vec3(1.0 - 0.25*exp(-200.0*d*d));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord.xy / iResolution.xy;\n  vec2 p = 2.0*(q - 0.5);\n  p.x *= iResolution.x/iResolution.y;\n  float d = df(p);\n\n  float fuzzy = 0.0025;\n    \n  vec3 col = vec3(0.0);\n\n  const vec3 baseCol = vec3(240.0, 175.0, 20.0)/255.0;\n  \n  col += 0.9*baseCol*vec3(smoothstep(fuzzy, -fuzzy, d));\n\n  vec3 rgb = 0.5 + 0.5*vec3(sin(TAU*vec3(50.0, 49.0, 48.0)*(d - 0.050) + TTIME/3.0));\n\n  col += baseCol.xyz*pow(rgb, vec3(8.0, 9.0, 7.0)); \n  col *= 1.0 - tanh(0.05+length(8.0*d));\n\n  float phase = TAU/4.0*(-length(p) - 0.5*p.y) + TTIME/11.0;\n \n  float wave = sin(phase);\n  float fwave = sign(wave)*pow(abs(wave), 0.75);\n \n  col = abs(0.79*(0.5 + 0.5*fwave) - col);\n  col = pow(col, vec3(0.25, 0.5, 0.75));\n  col = postProcess(col, q, p);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdScD1.jpg", "access": "api", "license": "cc0-1.0", "functions": [[552, 552, 591, 591, 680], [682, 682, 706, 706, 1116], [1118, 1118, 1151, 1151, 1236], [1238, 1238, 1256, 1256, 1717], [1719, 1719, 1763, 1763, 2045], [2047, 2047, 2102, 2102, 2870]], "test": "untested"}
{"id": "wdSyDh", "name": "❤️ for lug00ber", "author": "Alie", "description": "Just ❤️ for lug00ber :P\n\nQuick hack as a background for the revision 2020 livestream during his DJ set. Expect code to look like a quick hack.", "tags": ["raymarching", "heart"], "likes": 0, "viewed": 313, "published": 3, "date": "1586531549", "time_retrieved": "2024-07-30T21:13:46.661508", "image_code": "\n// Rotation\n#define R(p,a) p=cos(a)*p+sin(a)*vec2(-p.y,p.x);\n#define kPI 3.141592\n\n// maximum iteration count\n#define kMAXITERS 100\n#define kEPSILON 0.001\n    \nfloat dist(in vec3 p){\n    // Rotate\n    R(p.xz, iTime*.3);\n    // Scale Z to flatten\n    p.z *= 1.7;\n    // Shift on Y to form heart\n    //p.y -= smoothstep(0., 1., abs(p.x)) / 2.;\n    //p.y -=pow(abs(p.x)/2.,1.7)*1.3;\n    p.y -=pow(abs(p.x)/2.,-p.y*.3+1.5)*1.3;\n    // Scale X to widen\n    p.x *=.8;\n \treturn length(p) - 1.5;   \n}\n\n// Gets the normal\nvec3 normal(in vec3 p) {\n    vec2 eps = vec2(0.0001, 0);\n    float baseDist = dist(p);\n \treturn normalize(vec3(\n        dist(p + eps.xyy) - baseDist,\n        dist(p + eps.yxy) - baseDist,\n        dist(p + eps.yyx) - baseDist\n        ));\n}\n\n// Calulcate a fresnel term for reflections\nfloat fresnelTerm(in vec3 d, in vec3 n, in float power) {\n\tfloat fresnel = min(1., dot(d, n) + 1.0);\n\tfresnel = pow(fresnel, power);\n    return fresnel;\n}\n\nvec4 iC(vec3 p, vec3 d,vec3 ba, vec3 bb){\n\tvec3 a=(ba-p)/d, // near\n\tb=(bb-p)/d, // far\n\tf=max(a,b), // furthest\n\tn=min(a,b); // nearest\n\tfloat x=min(f.x,min(f.y,f.z)), // furthest plane\n\tdist=max(n.x,max(n.y,n.z)), // nearest plane\n\to=dist<0.?x:dist; // nearest in front\n\t//if(dist>=x||o<0.) return vec4(0,0,0,-100.); // d>=x = invalid, o>t = behind other geometry, o<0 behind\n\t\n\tvec3 normal = normalize(step(kEPSILON,abs(a-dist))-step(kEPSILON,abs(b-dist)))*sign(dist);\n\t//h.m=m;\n    return vec4(normal, dist);\n}\n\nvec3 bkg(in vec3 p, in vec3 d, bool heart, vec2 uv) {\n    vec4 box = iC(p, d, vec3(-100.), vec3(100.));\n    p += d * box.w;\n    if (heart) {\n    \t//float spec = (p.y < -99. && p.x>10. && abs(p.z+30.) < 30.) ? 1. : 0.;\n    \tfloat spec = p.y > -99. ? 0. : \n        (1.-smoothstep(40., 50., abs(p.x-50.))) * (1.-smoothstep(30., 40., abs(p.z+30.)));\n        //    && p.x>10. && abs(p.z+30.) < 30.) ? 1. : 0.;\n        return vec3(1,.2,.2) * (dot(d, normalize(vec3(3,2,-1)))*.3+.7) + spec;\n    }\n    \n    vec3 col = vec3(d.y *.5 + .5);\n    \n    return col;\n  //  return abs(box.zxy); \n}\n\n// The main marching loop\nvec3 marchRay(in vec3 p, in vec3 d, vec2 uv) {\n    float td = 0.;\n    \n    for (int i=0; i<kMAXITERS; i++) {\n        // Get distance to nearest surface\n        float result = dist(p);\n        td += result;\n        if ((p.z) > 3.0) { break; }\n        \n        p += d * result * 0.6;\n        \n        if (result < kEPSILON * td) {\n            // colision\n            // normal\n            // Get the normal, then clamp the intersection to the surface\n    \t\tvec3 n = normal(p);\n            d = reflect(d, n);\n            return bkg(p, d, true, uv);\n        }\n    }\n    // Ray did not hit, background\n    vec3 col = bkg(p, d, false, uv)*.6 + vec3(.2, .3, 1.);\n    \n\tcol = col*pow(clamp(0., 1., 1.2-length(uv)),.75);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy)*2.-1.;\n    vec2 uv2 = uv;\n    uv.y *= iResolution.y/iResolution.x;\n    vec3 cp = vec3(0,.5,-4.5);\n    vec3 rd = normalize(vec3(uv, 1)); \n\n    // Time varying pixel color\n    vec3 col = marchRay(cp, rd, uv2);\n\t//col = col*pow(clamp(0., 1., 1.-length(uv2)),.75);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSyDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 161, 183, 197, 493], [495, 514, 538, 538, 752], [754, 798, 855, 855, 952], [954, 954, 995, 995, 1468], [1470, 1470, 1523, 1523, 2050], [2052, 2078, 2124, 2124, 2807], [2809, 2809, 2866, 2916, 3275]], "test": "untested"}
{"id": "WsByW1", "name": "Poincaré Disc Tilings II", "author": "mla", "description": "Sequel to [url]https://www.shadertoy.com/view/Wdjyzm[/url]\n\nMore colour, more triangles, see code for details. If the \"null rotations\" are distracting, type 'n'. If the colours are too garish, type 'a'.", "tags": ["disc", "poincare"], "likes": 22, "viewed": 662, "published": 3, "date": "1586531297", "time_retrieved": "2024-07-30T21:13:47.614958", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Tiling the Poincare Disc II\n//\n// Construct P,Q,R hyperbolic triangle, centred at the origin, with\n// straight sides at angle PI/P at origin, and a circular side\n// making angles PI/Q and PI/R with the first two sides. Fold into\n// triangle by iterated reflection in its sides (so the triangle is a\n// fundamental region for the group of reflections).\n//\n// Lots of options:\n// 1,2,3: show different edge types\n// a: alternative palette\n// c: clip to unit disc\n// h: halfplane\n// i: colour by index\n// m: mouse isometry\n// n: null rotation\n// p: progressive folding\n// s: show sequence\n// t: show parity\n// z: exponential zoom out (halfplane only)\n//\n// This one does the folds in layers, so we can index and colour the\n// tiles according to what layer they are in.\n//\n// Any P,Q,R with 1/P + 1/Q + 1/R < 1 can be used, and Q and R may be\n// set to 0, which actually means \"infinity\", ie. a dihedral angle of\n// 0 (so the triangle points are ideal).\n//\n// This one really shows up any inaccuracy in the GPUs cos and sin,\n// so we use a table of cos(PI/n) for n = 0 up to 15. Note that the\n// table has cos(PI/0) = 1.0 as 0 really means \"infinity\" here.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nint P = 5, Q = 2, R = 4;\nint NSTEPS = 100; // Max number of folding steps\nint PSTEPS = 50; // Number of \"progressive\" steps\nint CYCLETIME = 2; // Time to show each triangle\nbool dotwotone = true;       // Show parity of fundamental regions\nbool doedge1 = true;         // Show x-axis edge\nbool doedge2 = true;         // Show y-axis edge\nbool doedge3 = true;         // Show circular edge\nbool donullrotation = false; // Do a \"null rotation\"\nbool domouse = true;         // Invert origin to mouse position\nbool dozoom = false;         // Zoom out, in halfplane mode only\nbool dohalfplane = false;    // Show the halfplane model, instead of the disc\nbool doprogressive = false;   // Progressively increase max number of folds\nbool doclip = true;         // Clip to unit disc\nbool dosequence = true;      // Show sequence of tilings\nbool doindexing = true;      // Use index for colour\nbool dopalette = false;      // Use alternative palette\n\nfloat PI = 3.141592654;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\n// Approximate equality. Used for assertion checks.\n// Maybe use relative error here?\nbool eq(float a, float b) {\n  return abs(a-b) < 1e-4;\n}\n\nfloat dihedral(vec2 n, vec2 m) {\n  return -dot(n,m);\n}\n\n// The dihedral angle between a plane and a spherical face. If d is\n// the perpendicular distance to plane, and s the sphere radius, then\n// angle is acos(d/s)\nfloat dihedral(vec2 n, vec2 C, float s) {\n  return dot(C,n)/s;\n}\n\nfloat COS[] =\n  // Look who doesn't trust cos on the GPU: cos(PI/n) for n = 0..31\n  float[](1.0,-1.0,0.0,0.5,0.7071067812,0.8090169944,0.8660254038,\n          0.9009688679,0.9238795325,0.9396926208,0.9510565163,0.9594929736,\n          0.9659258263,0.9709418174,0.9749279122,0.9781476007,0.9807852804,\n          0.9829730997,0.984807753,0.9863613034,0.9876883406,0.9888308262,\n          0.9898214419,0.990685946,0.9914448614,0.9921147013,0.9927088741,\n          0.9932383577,0.9937122099,0.9941379572,0.9945218954,0.9948693234);\n\nfloat mycos(int p) {\n  // cos(PI/p)\n  if (p < COS.length()) return COS[p];\n  return cos(PI/float(p));\n}\n                        \nfloat mysin(int p) {\n  // sin(PI/p)\n  float t = mycos(p);\n  return sqrt(1.0-t*t);\n}\n\nvec2 A,B,C; // Fundamental mirrors, C is circle centre\nfloat S,S2; // Circle radius and squared radius\n// Constructing the fundamental region:\n//\n// A and B have dihedral p, then want a circle (C,s) such that:\n// dihedral(A,C,s) = r\n// dihedral(B,C,s) = q\n// (q and r this way round for aesthetic reasons).\n//\n// Since the triangle can be any size, we solve for s = 1 and then scale:\n// dot(C,A) = cos(r)\n// dot(C,B) = cos(q)\n// or, with matrices:\n// transpose(mat2(A,B))*C = vec2(cos(r),cos(q))\n//\n// How the final scaling works is left as an exercise for the reader.\n// We could optimize a little since m has a simple form, but it's neat\n// doing it like this and the compiler might well do the optimization\n// for us (fairly simple inlining and constant folding would do).\nvoid solve(int p, int q, int r) {\n  // Use the y-axis for the first side, for bilateral symmetry.\n  A = vec2(1,0);\n  B = vec2(-mycos(p),mysin(p));\n  mat2 m = inverse(mat2(A,B));\n  C = vec2(mycos(r),mycos(q))*m; // multiply by transpose\n  // and set the correct radius = 1.0\n  S2 = 1.0/(dot(C,C)-1.0);\n  S = sqrt(S2);\n  C *= S;\n  assert(eq(dihedral(A,B),mycos(p)));\n  assert(eq(dihedral(B,C,S),mycos(q)));\n  assert(eq(dihedral(A,C,S),mycos(r)));\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 background = vec3(0.1);\n\nvec3 diagram(vec2 z, vec2 mouse) {\n  assert(P >= 2);\n  assert(Q == 0 || Q >= 2);\n  assert(R == 0 || R >= 2);\n  assert(Q == 0 || R == 0 || (Q*R + R*P + P*Q) < P*Q*R);\n  solve(P,Q,R);\n  if (dohalfplane) {\n    z.y += 1.0;\n    if (dozoom) z *= exp(iTime);\n    z.y += 1.0;\n    z *= 2.0/dot(z,z);\n    z.y -= 1.0;\n  }\n  // Map screen coordinate at mouse position to origin\n  // We do this by inverting in an imaginary circle centred\n  // at the mouse position to take the mouse to infinity,\n  // then invert in the imaginary unit circle to bring it\n  // back to the origin. Both circles are orthogonal to the\n  // (real) unit circle, and so are hyperbolic lines and\n  // the inversions are isometries.\n  if (domouse && mouse != vec2(0)) {\n    vec2 c = mouse;\n    z -= c;\n    z *= (dot(c,c)-1.0)/dot(z,z);\n    z += c;\n    z *= -1.0/dot(z,z);\n  }\n  if (donullrotation) {\n    // One ideal fixed point: do with reflection in x = 0 and an\n    // inversion in a circle going through (0,1).\n    float theta = PI*iTime/float(CYCLETIME);\n    if (theta != 0.0) {\n      z.x = -z.x;\n      float r = 1.0/tan(theta);\n      r = (r<0.0?-1.0:1.0)*max(1e-2,abs(r));\n      vec2 c = vec2(r,1);\n      z -= c;\n      z *= r*r/dot(z,z);\n      z += c;\n    }\n  }\n  if (dot(z,z) > 1.0) {\n    if (doclip) return background;\n    z /= dot(z,z); // Map exterior to interior if displaying.\n  }\n  int nsteps = NSTEPS, folds = 0, index = -1;\n  if (doprogressive) nsteps = 1+int(iTime)%PSTEPS;\n  for (index = 0; index < nsteps; index++) {\n    if (P == 2) {\n      // This optimization may not be worth it.\n      folds += int(z.x < 0.0) + int(z.y < 0.0);\n      z = abs(z);\n    } else {\n      // Enough folds to do the central region\n      for (int i = 0; i < (P+1)/2; i++) {\n        // A is (1,0) so maybe optimize this, or again, just let the\n        // compiler do it.\n        {\n          float t = dot(z,A);\n          if (t < 0.0) {\n            z -= 2.0*t*A;\n            folds++;\n          }\n        }\n        {\n          float t = dot(z,B);\n          if (t < 0.0) {\n            z -= 2.0*t*B;\n            folds++;\n          }\n        }\n      }\n    }\n    {\n      vec2 z1 = z-C;\n      float t = dot(z1,z1);\n      if (t >= S2) break;\n      z1 *= S2/t;\n      z = z1+C;\n      folds++;\n    }\n  }\n  if (index == nsteps) return background;\n  // We have now folded the original point z into the fundamental\n  // region, now draw whatever should be in there. Things get smaller\n  // as we move outwards in the disc, so need a scale factor.\n  float scalefactor = abs(1.0 - dot(z,z));\n  // Euclidean distances to edge of fundamental regions\n  float d1 = abs(dot(z,A));\n  float d2 = abs(dot(z,B));\n  float d3 = abs(length(z-C)-S);\n  // Desired widths, appropriately scaled.\n  float ewidth = 0.5*scalefactor*0.02;\n  float lwidth = 0.5*scalefactor*0.02;\n  vec3 col = vec3(0,1,1);\n  if (doindexing) {\n    if (dopalette) col = 0.5 + 0.5*cos(float(index)*PI/3.0 + vec3(2, 1, 0));\n    else col = hsv2rgb(vec3(float(index)/6.0,1,1));\n  }\n  // Haven't worked out how to do smooth colour transition yet.\n  // If nearest to edge 1 or 2, then same colour, else\n  // it's either colour index+1 or index-1 depending on what?\n  if (dotwotone && folds%2 != 0) col *= 0.5;\n  if (doedge1 || doedge2 || doedge3) {\n    // Draw the edges of the region, if desired.\n    float d = 1e8;\n    if (doedge1) d = min(d,d1);\n    if (doedge2) d = min(d,d2);\n    if (doedge3) d = min(d,d3);\n    col = mix(vec3(0),col,smoothstep(0.0,lwidth/*+fwidth(z.x)*/,d));\n  }\n  assert(!isnan(dot(col,col)));\n  return col;\n}\n\nbool key(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_C = 67;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_P = 80;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_Z = 90;\n\nivec3 sequence[] =\n  ivec3[](ivec3(2,3,7),ivec3(3,2,7),ivec3(7,2,3),\n          ivec3(4,4,4),ivec3(3,2,0),ivec3(2,0,0));\n                          \nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  dotwotone = dotwotone != key(CHAR_T);\n  doedge1 = doedge1 != key(CHAR_0+1);\n  doedge2 = doedge2 != key(CHAR_0+2);\n  doedge3 = doedge3 != key(CHAR_0+3);\n  donullrotation = donullrotation != key(CHAR_N); \n  domouse = domouse != key(CHAR_M); \n  dozoom = dozoom != key(CHAR_Z); // halfplane only\n  dohalfplane = dohalfplane != key(CHAR_H);\n  doprogressive = doprogressive != key(CHAR_P);\n  doclip = doclip != key(CHAR_C);\n  dosequence = dosequence != key(CHAR_S);\n  doindexing = doindexing != key(CHAR_I);\n  dopalette = dopalette != key(CHAR_A);\n  \n  if (dosequence) {\n    int N = CYCLETIME;\n    if (doprogressive) N = PSTEPS;\n    int i = int(iTime/float(N))%sequence.length();\n    ivec3 pqr = sequence[i];\n    P = pqr.x; Q = pqr.y; R = pqr.z;\n  }\n  vec2 mouse = iMouse.x <= 0.0 ? vec2(0)\n    : vec2((2.0*iMouse.xy-iResolution.xy)/iResolution.y);\n  int AA = 2;\n  vec3 col = vec3(0);\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 p = vec2((2.0*(fragCoord+vec2(i,j)/float(AA))-iResolution.xy)/iResolution.y);\n      col += diagram(p,mouse);\n    }\n  }\n  col /= float(AA*AA);\n  col = pow(col,vec3(0.4545));\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsByW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2311, 2311, 2332, 2332, 2358], [2360, 2446, 2473, 2473, 2501], [2503, 2503, 2535, 2535, 2557], [2559, 2719, 2760, 2760, 2783], [3314, 3314, 3334, 3349, 3417], [3443, 3443, 3463, 3478, 3526], [3540, 4304, 4337, 4401, 4750], [4752, 4847, 4874, 4874, 5050], [5082, 5082, 5116, 5116, 8608], [8610, 8610, 8630, 8630, 8690], [9093, 9093, 9146, 9146, 10334]], "test": "untested"}
{"id": "wsByDh", "name": "Epicycloids - Cremona method", "author": "andretugan", "description": "Cremona method of epicycloid generation. https://en.wikipedia.org/wiki/Cardioid#Cardioid_as_envelope_of_a_pencil_of_lines", "tags": ["lines", "epicycloid"], "likes": 2, "viewed": 408, "published": 3, "date": "1586529714", "time_retrieved": "2024-07-30T21:13:48.661161", "image_code": "// Author: https://www.shadertoy.com/user/andretugan\n// Creative Commons Attribution-NonCommercial 3.0 Unported License\n// https://creativecommons.org/licenses/by-nc/3.0\n\n#define NUM_CHORDS 128\n\n#define M_PI 3.14159265358\n#define M_2_PI (2. * 3.14159265358)\n\n#define FADE_INNER_RADIUS 0.8\n#define FADE_OUTER_RADIUS 1.1\n#define LINE_WIDTH 4.\n\n// Function from Inigo Quilez\n// https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;                   \n    float uv2 = dot(uv, uv);        \n    if (uv2 > FADE_OUTER_RADIUS * FADE_OUTER_RADIUS) { \n    \tfragColor = vec4(0.0,0.0,0.0,1.0);\n        return;\n    }\n               \n    float multiplier = 1.99 + 5. * (.5 - .5 * cos(iTime * 0.03));\n    float start = multiplier * M_PI * 0.25;\n    float val = 0.;\n\n    for (int i = 0; i < NUM_CHORDS; ++i) {\n        float angle1 = start + M_2_PI / float(NUM_CHORDS) * float(i);\n        float angle2 = multiplier * angle1;\n        vec2 point1 = vec2(cos(angle1), sin(angle1));\t                       \n        vec2 point2 = vec2(cos(angle2), sin(angle2));\n\n        vec2 diff = point2 - point1;\n        vec2 perp = point1 + (dot(uv - point1, diff) / dot(diff, diff)) * diff - uv;\n        float dist2 = dot(perp, perp);\n        \n        float line_width = LINE_WIDTH / iResolution.y;                                        \n    \tfloat add_val = smoothstep(line_width * line_width, line_width * line_width * 0.5, dist2);                                                 \n        add_val *= smoothstep(FADE_OUTER_RADIUS * FADE_OUTER_RADIUS, FADE_INNER_RADIUS * FADE_INNER_RADIUS, uv2);        \n        val += add_val;\n    }\n    \n    val *= 20. / float(NUM_CHORDS);\n    val = pow(val, 0.5);\n    \n    float hue = sin(iTime * 0.05 + uv2 * 0.3);                                  \n    fragColor = vec4(hsv2rgb(vec3(hue, 1., val)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsByDh.jpg", "access": "api", "license": "cc-by-3.0", "functions": [[342, 413, 440, 440, 618], [620, 620, 676, 676, 2123]], "test": "ok"}
{"id": "3dScD1", "name": "Hypercube VJ", "author": "BoyC", "description": "For lug00ber", "tags": ["raymarching"], "likes": 19, "viewed": 917, "published": 3, "date": "1586517237", "time_retrieved": "2024-07-30T21:13:49.732297", "image_code": "vec4 blurY( out vec4 fragColor, in vec2 fragCoord )\n{\n    float BlurWeights[31] = float[31](\n   0.000001,\t0.000003,\n        0.000012,\t0.000048,\t0.000169,\t0.000538,\t0.001532,\t0.003906,\t0.00892,\t0.018246,\t0.033431,\n        0.054865,\t0.080656,\t0.106209,\t0.125279\t,0.132368,\t0.125279,\t0.106209\t,0.080656,\t0.054865,\t0.033431,\n        0.018246,\t0.00892,\t0.003906,\t0.001532,\t0.000538,\t0.000169,\t0.000048,\t0.000012,\t0.000003,\t0.000001\n);\n    \n    vec2 uv=fragCoord.xy/iResolution.xy;\n    vec4 color = vec4(0.0);\n    \n    float kernelSize = 31.0;\n    int counter=0;\n    float blurSize = 3.0;\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n\n    for (int x=0; x<int(kernelSize); x++)\n        {\n            vec4 col = texture(iChannel0, uv + vec2(0.0, float(x)-kernelSize/2.0)*blurSize/iResolution.xy) * BlurWeights[int(x)];\n    \t\tfloat l = dot(luma,col.xyz);\n\t\t    //if (l>0.9)\n            {\n            \tcolor+=col;\n                counter++;\n            }\n        }\n        \n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 blurred = blurY(fragColor, fragCoord);\n    \n    vec2 uv=fragCoord.xy/iResolution.xy;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n\n    vec4 col = texture(iChannel1,uv);\n    \n    float threshold = 0.6;\n    float intensity = 2.0;\n    vec4 bloom = (blurred-vec4(threshold))*intensity+vec4(threshold);\n    bloom = clamp(bloom,vec4(0.0),vec4(1.0)) * 0.5;\n    \n\tfragColor = bloom + col;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float vmax(vec3 v)\n{\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\nfloat fBox(vec3 p, vec3 b) \n{\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat sdf(vec3 pos)\n{\n    return fBox(pos, vec3(1.0,1.0,1.0));\n}\n\nfloat edgeSize = 0.1;\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\nvec3 pMod3(inout vec3 p, vec3 size) \n{\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\nfloat sdf2(vec3 pos)\n{\n    pMod3(pos,vec3(2.0));\n    \n    return min(min(fBox2(pos.xy, vec2(edgeSize)),fBox2(pos.xz, vec2(edgeSize))),fBox2(pos.yz, vec2(edgeSize)));\n}\n\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n\tvec2 halfsize = size*0.5;\n\tvec2 c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tp *= mod(c,vec2(2))*2.0 - vec2(1);\n\treturn c;\n}\n\nvec4 iqColor(vec3 a, vec3 b, vec3 c, vec3 d, float t)\n{\n    return vec4( a + b * cos( 2.0 *3.14152965 * (c*t+d) ), 1);\n}\n\nvec4 discoStrip( float x )\n{\n    float patternLength = 30.0;\n    float timePos = mod(iTime,patternLength);\n    \n    float pattern = mod((iTime / patternLength),6.0);\n    \n    float c = clamp(sin(iTime*4.0 + x)*5.0,0.0,1.0);\n    vec4 color = vec4(c*0.7,c*0.5,c,1);\n    \n    if (pattern>=1.0)\n        color = iqColor(vec3(0.5),vec3(0.5),vec3(1.0),vec3(0.00, 0.33, 0.67) + vec3(x)/5.0, iTime) * vec4(1.3,0.8,0.2,1.0);;\n    if (pattern>=2.0)\n        color = iqColor(vec3(0.5),vec3(0.5),vec3(1.0, 1.0, 0.5),vec3(0.80, 0.90, 0.30) + vec3(x)/6.0, iTime);\n    if (pattern>=3.0)\n        color = vec4(sin(iTime*5.0 + x)*0.5+0.5,cos(iTime*5.0 + x)*0.7+0.3,cos(iTime*7.0 + x)*0.3+0.5,1);\n    if (pattern>=4.0)\n        color = iqColor(vec3(0.5),vec3(0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) + vec3(x)/3.0*1.5, iTime) * vec4(0.3,0.8,1.5,1.0);\n    if (pattern>=5.0)\n        color = iqColor(vec3(0.5),vec3(0.5),vec3(1.0, 1.0, 0.5),vec3(0.80, 0.90, 0.30) + vec3(x)/6.0, iTime) * vec4(0.7,1.5,0.3,1.0);/**/\n    \n    float fade = clamp(-(abs(timePos-patternLength/2.0)-patternLength/2.0)-0.5,0.0,1.0);\n        \n    return color*fade;\n}\n\nvec4 dotPattern( vec2 d )\n{   \n    d-=vec2(11.0);\n    \n    d=mod(d,40.0);\n    if (d.x>=20.0) d.x=39.0-d.x;\n    if (d.y>=20.0) d.y=39.0-d.y;\n    \n    if (d.x-0.0 == 0.0 )\n        return discoStrip( d.y );\n    if (d.x-19.0 == 0.0 )\n        return discoStrip( d.y );\n    \n    if (d.y-0.0 == 0.0 )\n        return discoStrip( d.x );\n    if (d.y-19.0 == 0.0 )\n        return discoStrip( d.x );\n    \n    return vec4(0.0);\n}\n\nvec4 discoPattern( vec2 pos )\n{    \n    pos+=vec2(edgeSize*0.5);\n    vec2 idx = pMod2(pos,vec2(edgeSize*1.0));\n    float l = length(pos)*3.0;\n    \n    vec4 dotColor = clamp(dotPattern(idx),vec4(0.0),vec4(1.0));\n    \n    return l<edgeSize ? dotColor : vec4(0);\n}\n\nvec4 disco(vec3 pos, vec3 dir)\n{\n\tvec3 n=normalize(vec3(sdf2(pos+vec3(0.01,0,0))-sdf2(pos+vec3(-0.01,0,0)),\n\t\t\t\t\t\t  sdf2(pos+vec3(0,0.01,0))-sdf2(pos+vec3(0,-0.01,0)),\n\t\t\t\t\t\t  sdf2(pos+vec3(0,0,0.01))-sdf2(pos+vec3(0,0,-0.01))));\n\n    n=abs(n);\n    \n    vec4 c = vec4(0);\n    if (n.x > n.y && n.x > n.z)\n        c=discoPattern(pos.yz);\n    if (n.y > n.x && n.y > n.z)\n        c=discoPattern(pos.xz);\n    if (n.z > n.y && n.z > n.x)\n        c=discoPattern(pos.xy);\n    \n    return c;\n}\n\nvec4 magicCube( vec3 pos, vec3 dir )\n{\n  vec3 oPos = pos;\n\n  float dist = sdf2(pos+1.0);\n  if (dist<0.000001)\n  \treturn vec4(0);\n  \n  for (int x=0; x<100; x++)\n  {\n      dist = sdf2(pos+1.0);\n\n      float distFade = max(0.0, 1.0-length(pos-oPos)*0.05 );\n      \n      if (distFade==0.0)\n          break;\n      \n      if (dist<0.00001)\n      {\n          return mix(disco(pos, dir),vec4(1.0),1.0-distFade);\n      }\n      pos += dir * abs(dist);       \n  }\n    \n  return vec4(1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time=iTime/3.0;//+43.63/3.0;\n\n    // cam that goes in the cube\n    /*float rotationTime = sin(time/5.35886)*3.14152965;\n    float y = 1.0*sin(time + sin(time/5.0)*3.14152965);\n    vec3 Pos=vec3(2.0*sin(rotationTime), y, 2.0*cos(rotationTime))*(1.3+sin(time)*( sin(time/7.86463) * 0.5 + 0.5 ) );/**/\n    \n    // cam that doesn't go in the cube\n    float rotationTime = sin(time/5.35886)*3.14152965;\n    float y = 1.0*sin(time + sin(time/5.0)*3.14152965);\n    vec3 Pos=vec3(2.0*sin(rotationTime), y, 2.0*cos(rotationTime))*(2.0+sin(time)*( sin(time/7.86463) * 0.1 + 0.1 ) );\n    \n    vec3 camPos = Pos;\n\tvec3 CamDir=normalize(-Pos);\n\tvec3 CamRight=normalize(cross(CamDir,vec3(0,1,0)));\n\tvec3 CamUp=normalize(cross(CamRight,CamDir));\t\n\tmat3 cam=transpose(mat3(CamRight,CamUp,CamDir));\n\n\t//ray calculation\t\n    float distroPower = clamp((sin(time/2.1373)-0.95)*20.0,0.0,1.0);\n\tvec2 uv=2.0*fragCoord.xy/iResolution.xy-1.0;// + 0.01*vec2(sin((fragCoord.x+iTime)*10000.0),sin((fragCoord.x+iTime*2.0)*10000.0)) * distroPower;\n\tfloat aspect=iResolution.x/iResolution.y;\n\t\n\tvec3 Dir=normalize(vec3(uv*vec2(aspect,1.0),2.0))*cam;\n    \n    float dist = 10000.0f;\n\n    for (int x=0; x<100; x++)\n    {\n        dist = sdf(Pos);\n        if (dist<=0.01)\n        {\n            break;\n        }\n        Pos += Dir * abs(dist);        \n    }\n    \n    if (dist<=0.01)\n    {\n        float camDist = length(camPos);\n        fragColor = magicCube(Pos,Dir);\n    }\n    else\n    {\n        float vignette = clamp(1.0 - pow(length( (fragCoord.xy/iResolution.xy - 0.5) * 2.0 ),5.0),0.0,1.0);\n    \tfragColor = (discoStrip(Dir.x*5.0) + discoStrip(Dir.y*5.0) + discoStrip(Dir.z*5.0))/3.0*0.5 * vignette*0.7;// vec4(Dir*0.5+0.5,1.0);/**/\n    }\n}", "buffer_a_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// FXAA code from: http://www.geeks3d.com/20110405/fxaa-fast-approximate-anti-aliasing-demo-glsl-opengl-test-radeon-geforce/3/\n\n#define FXAA_SPAN_MAX 8.0\n#define FXAA_REDUCE_MUL   (1.0/FXAA_SPAN_MAX)\n#define FXAA_REDUCE_MIN   (1.0/128.0)\n#define FXAA_SUBPIX_SHIFT (1.0/32.0)\n\nvec3 FxaaPixelShader( vec4 uv, sampler2D tex, vec2 rcpFrame) {\n    \n    vec3 rgbNW = textureLod(tex, uv.zw, 0.0).xyz;\n    vec3 rgbNE = textureLod(tex, uv.zw + vec2(1,0)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSW = textureLod(tex, uv.zw + vec2(0,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSE = textureLod(tex, uv.zw + vec2(1,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbM  = textureLod(tex, uv.xy, 0.0).xyz;\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max(\n        (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\n        FXAA_REDUCE_MIN);\n    float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n    \n    dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n          max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n          dir * rcpDirMin)) * rcpFrame.xy;\n\n    vec3 rgbA = (1.0/2.0) * (\n        textureLod(tex, uv.xy + dir * (1.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + dir * (2.0/3.0 - 0.5), 0.0).xyz);\n    vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\n        textureLod(tex, uv.xy + dir * (0.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + dir * (3.0/3.0 - 0.5), 0.0).xyz);\n    \n    float lumaB = dot(rgbB, luma);\n\n    if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;\n    \n    return rgbB; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 rcpFrame = 1./iResolution.xy;\n  \tvec2 uv2 = fragCoord.xy / iResolution.xy;\n        \n   \tvec4 uv = vec4( uv2, uv2 - (rcpFrame * (0.5 + FXAA_SUBPIX_SHIFT)));\n    fragColor = vec4( FxaaPixelShader( uv, iChannel0, 1./iResolution.xy ), 1.0);\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float BlurWeights[31] = float[31](\n   0.000001,\t0.000003,\n        0.000012,\t0.000048,\t0.000169,\t0.000538,\t0.001532,\t0.003906,\t0.00892,\t0.018246,\t0.033431,\n        0.054865,\t0.080656,\t0.106209,\t0.125279\t,0.132368,\t0.125279,\t0.106209\t,0.080656,\t0.054865,\t0.033431,\n        0.018246,\t0.00892,\t0.003906,\t0.001532,\t0.000538,\t0.000169,\t0.000048,\t0.000012,\t0.000003,\t0.000001\n);\n    \n    vec2 uv=fragCoord.xy/iResolution.xy;\n    vec4 color = vec4(0.0);\n    \n    float kernelSize = 31.0;\n    int counter=0;\n    float blurSize = 3.0;\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n\n    for (int x=0; x<int(kernelSize); x++)\n        {\n            vec4 col = texture(iChannel0, uv + vec2(float(x)-kernelSize/2.0,0.0)*blurSize/iResolution.xy) * BlurWeights[int(x)];\n    \t\tfloat l = dot(luma,col.xyz);\n\t\t    //if (l>0.9)\n            {\n            \tcolor+=col;\n                counter++;\n            }\n        }\n        \n\tfragColor = color*1.0;//+texture(iChannel0, uv);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dScD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 979], [981, 981, 1038, 1038, 1428]], "test": "untested"}
{"id": "WdScD1", "name": "Invasion Of The Covoids", "author": "dr2", "description": "Close encounters of a different kind", "tags": ["space", "symmetry", "flight", "virus"], "likes": 7, "viewed": 431, "published": 3, "date": "1586514486", "time_retrieved": "2024-07-30T21:13:51.132553", "image_code": "// \"Invasion Of The Covoids\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsAnDf (vec3 p, float r, float w, float h);\nvec3 SphFib (vec3 v, float n);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 VToRMat (vec3 v, float a);\nvec3 RotToDir (vec3 v1, vec3 v2, vec3 p);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nfloat Hashfv3 (vec3 p);\nvec4 Hashv4v3 (vec3 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nmat3 flMat, obMat;\nvec4 obRnd;\nvec3 trkAx, trkAy, trkFx, trkFy, sunDir, flPos, cId, qHit, obDisp, crMid;\nvec2 scrMid;\nfloat bGrid, tCur, dstFar, spd, obOcc, nSpk, obSzFac, rScrn;\nint idObj;\nconst int idCage = 1, idScrn = 2, idVbal = 3, idVspk = 4, idVcap = 5;\nconst float pi = 3.14159;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvec3 TrackPath (float t)\n{\n  return vec3 (dot (trkAx, cos (trkFx * t)), dot (trkAy, cos (trkFy * t)), t);\n}\n\nvec3 TrackVel (float t)\n{\n  return vec3 (- dot (trkFx * trkAx, sin (trkFx * t)),\n     - dot (trkFy * trkAy, sin (trkFy * t)), 1.);\n}\n\nvec3 TrackAcc (float t)\n{\n  return vec3 (- dot (trkFx * trkFx * trkAx, cos (trkFx * t)),\n     - dot (trkFy * trkFy * trkAy, cos (trkFy * t)), 0.);\n}\n\nvoid ObjState ()\n{\n  obRnd = Hashv4v3 (cId + 17.11);\n  obDisp = 0.5 * bGrid * (obRnd.xyz - 0.5);\n  obMat = VToRMat (normalize (obRnd.xyz - 0.5), (0.2 + 0.8 * obRnd.w) * tCur);\n  nSpk = floor (100. + 40. * obRnd.y);\n  obSzFac = 0.4 + 0.2 * obRnd.y;\n}\n\nfloat VbalDf (vec3 p, float dMin)\n{\n  vec3 q, qn, uf;\n  float d, rad, len, h;\n  dMin /= 0.6 * obSzFac;\n  q = p / obSzFac;\n  rad = 1.;\n  qn = normalize (q);\n  uf = SphFib (qn, nSpk);\n  d = PrSphDf (q, rad * (1. - 0.05 * smoothstep (0.1, 0.2, length (qn - uf))));\n  DMIN (idVbal);\n  q = RotToDir (uf, vec3 (0., 0., 1.), q - uf);\n  h = Hashfv3 (41. * uf);\n  len = 0.3 * (1. - 0.2 * h);\n  q.z -= len;\n  d = PrCylDf (q, 0.04 * (1. - 0.1 * q.z / len), len);\n  DMIN (idVspk);\n  q.z -= len + 0.05;\n  q.xy = Rot2D (q.xy, pi * h / 3.);\n  q.xy = Rot2D (q.xy, 2. * pi * floor (3. * atan (q.y, - q.x) / (2. * pi) + 0.5) / 3.);\n  q.x += 0.08;\n  d = PrSphDf (q * vec3 (1., 1., 1.3), 0.1);\n  DMIN (idVcap);\n  return 0.6 * obSzFac * dMin;\n}\n\nfloat ObjCDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p - obDisp;\n  d = PrSphDf (q, 1.7 * obSzFac);\n  if (d < 0.05) dMin = VbalDf (obMat * q, dMin);\n  else dMin = min (dMin, d);\n  return dMin;\n}\n\nfloat ObjCRay (vec3 ro, vec3 rd)\n{\n  vec3 cIdP, p, s, rdi;\n  float dHit, d, eps;\n  eps = 0.0005;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  rdi = 1. / rd;\n  cIdP = vec3 (-999.);\n  dHit = eps;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    cId = floor (p / bGrid);\n    if (cId != cIdP) {\n      ObjState ();\n      cIdP = cId;\n    }\n    s = (bGrid * (cId + step (0., rd)) - p) * rdi;\n    d = abs (Minv3 (s)) + eps;\n    if (obRnd.x < obOcc && length (cId.xy - floor (TrackPath (bGrid * cId.z).xy / bGrid)) >= 1.)\n       d = min (d, ObjCDf (p - (bGrid * (cId + 0.5))));\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjCNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjCDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, len, rad, s, b;\n  dMin = dstFar;\n  len = 1.;\n  rad = 0.8;\n  p = flMat * (p - flPos);\n  q = p;\n  q.yz -= vec2 (-0.1 * rad, 0.3 * len);\n  b = length (q.xy);\n  s = (q.z > len) ? 16. * (atan (q.z - len, b) / (2. * pi) + 0.5) : 2. * q.z / len;\n  s = min (abs (fract (s) - 0.5), abs (fract (12. * atan (q.y, - q.x) / (2. * pi)) - 0.5));\n  d = 0.7 * max (max (PrCapsAnDf (q, rad, 0.01 * (1.5 - clamp (20. * s, 0.5, 1.75)), len),\n     -1.25 * len - 0.03 - q.z), 0.2 * rad - b);\n  DMINQ (idCage);\n  q = p;\n  q.yz -= vec2 (-0.17, 0.5);\n  scrMid = q.xy;\n  q.xy = Rot2D (q.xy, pi / 4.);\n  q.xy -= 1.02 * rScrn * sign (q.xy);\n  d = PrCylDf (q, rScrn, 0.003);\n  DMINQ (idScrn);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 5. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 ErCol (vec3 rd)\n{\n  vec3 erDir, col, vn;\n  float erRad, bs, ts;\n  erDir = normalize (vec3 (0.02, -0.04, 1.));\n  erRad = 0.04;\n  col = vec3 (0.);\n  bs = dot (rd, erDir);\n  ts = bs * bs - 1. + erRad * erRad;\n  if (ts > 0.) {\n    ts = bs - sqrt (ts);\n    if (ts > 0.) {\n      vn = normalize ((ts * rd - erDir) / erRad);\n      col = mix (vec3 (0.3, 0.4, 0.8), vec3 (1., 1., 0.95),\n         smoothstep (0.2, 0.8, Fbm2 (6. * vn.xy + 7.1))) * (0.5 + 0.5 * max (- dot (vn, rd), 0.)) *\n         (0.2 + 0.8 * max (dot (vn, sunDir), 0.));\n    }\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  vec2 vf;\n  float dstObj, nDotS, t;\n  bool isScrn, showBg;\n  rScrn = 0.03;\n  isScrn = false;\n  showBg = true;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == idCage) {\n      col = mix (vec3 (0.45, 0.5, 0.5), vec3 (0.5, 0.5, 0.6), smoothstep (0.4, 0.6,\n         Fbm3 (64. * qHit)));\n      vn = VaryNf (128. * qHit, vn, 0.2);\n    } else if (idObj == idScrn) {\n      if (length (qHit.xy) < 0.95 * rScrn) {\n        qHit.xy = Rot2D (qHit.xy, - pi / 4.);\n        if (min (abs (qHit.x), abs (qHit.y)) > 0.03 * rScrn) {\n          ro = flPos;\n          rd = normalize (vec3 (qHit.xy, - rScrn)).xzy;\n          if (abs (scrMid.y) > abs (scrMid.x)) rd.yz = Rot2D (rd.yz, -0.25 * pi * sign (scrMid.y));\n          else rd.xy = Rot2D (rd.xy, 0.25 * pi * sign (scrMid.x));\n          ro += 0.5 * rd;\n          isScrn = true;\n        } else col = vec3 (0.7, 0.7, 0.8) * (0.7 + 0.3 * sin (4096. * length (qHit.xy)));\n      } else {\n        col = vec3 (0.5, 0.5, 0.6) * (0.7 + 0.3 * sin (256. * atan (qHit.y, qHit.x)));\n      }\n    }\n    if (! isScrn) {\n      nDotS = max (dot (vn, sunDir), 0.);\n      nDotS *= nDotS;\n      col = col * (0.3 + 0.3 * max (- dot (vn, sunDir), 0.) + 0.7 * nDotS * nDotS);\n      showBg = false;\n    }\n  }\n  if (dstObj >= dstFar || isScrn) {\n    dstObj = ObjCRay (ro, rd);\n    if (dstObj < dstFar) {\n      ro += dstObj * rd;\n      cId = floor (ro / bGrid);\n      ObjState ();\n      ro -= bGrid * (cId + 0.5);\n      vn = ObjCNf (ro);\n      vf = vec2 (0.);\n      if (idObj == idVbal) {\n        col4 = vec4 (0.5, 0.4, 0.2, 0.1);\n        vf = vec2 (8., 8.);\n      } else if (idObj == idVspk) {\n        col4 = vec4 (0.5, 0.6, 0.5, 0.4);\n        vf = vec2 (64., 0.1);\n      } else if (idObj == idVcap) {\n        col4 = vec4 (1., 0.2, 0.2, 0.3);\n        vf = vec2 (64., 2.);\n      }\n      if (! isScrn) {\n        t = 0.3 * tCur + obRnd.z;\n        if (idObj == idVbal) col4.rgb = mix (col4.rgb, vec3 (0.2, 1., 0.2), \n           SmoothBump (0.45, 0.55, 0.005, mod (t, 1.)));\n        else if (idObj == idVspk || idObj == idVcap) col4.rgb = mix (col4.rgb, vec3 (1., 1., 0.7),\n           SmoothBump (0.49, 0.51, 0.005, mod (0.5 * length (ro - obDisp) - t, 1.)));\n        if (vf.x > 0.) vn = VaryNf (vf.x * (obMat * (ro - obDisp)), obMat * vn, vf.y) * obMat;\n      }\n      col = col4.rgb * (0.2 + 0.2 * max (- dot (vn, sunDir), 0.) + 0.8 * max (dot (vn, sunDir), 0.)) +\n          col4.a * pow (max (dot (reflect (rd, vn), sunDir), 0.), 16.);\n      if (! isScrn) {\n        col = mix (col, ErCol (rd), smoothstep (0.6, 1., dstObj / dstFar));\n      } else {\n        col = mix (col, vec3 (0.), smoothstep (0.6, 1., dstObj / dstFar));\n        col = sqrt (Maxv3 (col)) * vec3 (0.5, 0.5, 1.);\n      }\n      showBg = false;\n    } else {\n      col = vec3 (0.);\n      if (! isScrn) col += ErCol (rd);\n    }\n  }\n  if (showBg) {\n    col = ErCol (rd);\n    if (length (col) < 0.03) col += StarPat (rd, 8.);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid FlyerPM (float s, float rl, float vu)\n{\n  vec3 vel, ort, ca, sa;\n  float el, az;\n  flPos = TrackPath (s);\n  vel = normalize (TrackVel (s));\n  el = -0.2 * asin (vel.y);\n  az = 0.2 * (atan (vel.z, vel.x) - 0.5 * pi);\n  rl = clamp (rl - 0.5 * TrackAcc (s).x, -0.3 * pi, 0.3 * pi);\n  ort = (vu >= 0.) ? vec3 (el, az, rl) : vec3 (- el, az + pi, - rl);\n  ca = cos (ort);\n  sa = sin (ort);\n  flMat = mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n          mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n}\n\n#define AA  0\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = mod (tCur, 1800.) + 10.;\n  az = 0.;\n  el = -0.03 * pi;\n  if (mPtr.z > 0.) {\n    az += 1.5 * pi * mPtr.x;\n    el += 1.5 * pi * mPtr.y;\n    az = clamp (az, -0.5 * pi, 0.5 * pi);\n    el = clamp (el, -0.4 * pi, 0.4 * pi);\n  }\n  vuMat = StdVuMat (el, az);\n  spd = -2.;\n  obOcc = 0.4;\n  bGrid = 4.;\n  trkAx = 0.5 * vec3 (0.7, 0.8, 1.2);\n  trkAy = 0.5 * vec3 (1., 1.1, 0.9);\n  trkFx = vec3 (0.43, 0.33, 0.23);\n  trkFy = vec3 (0.41, 0.31, 0.12);\n  FlyerPM (spd * tCur, 0.1 * pi * (Fbm1 (0.01 * tCur) - 0.5), 1.);\n  ro = flPos;\n  zmFac = 2.6;\n  dstFar = 60.;\n  sunDir = normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    rd = vuMat * (rd * flMat);\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.9)), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsAnDf (vec3 p, float r, float w, float h)\n{\n  p.z = abs (p.z);\n  return max (length (p - vec3 (0., 0., min (p.z, h + w))) - r,\n     - length (p - vec3 (0., 0., min (p.z, h - w))) + r) - w;\n}\n\nvec3 SphFib (vec3 v, float n)\n{   // Keinert et al's inverse spherical Fibonacci mapping\n  vec4 b;\n  vec3 vf, vfMin;\n  vec2 ff, c;\n  float fk, ddMin, dd, a, z, ni;\n  const float phi = 1.618034;\n  ni = 1. / n;\n  fk = pow (phi, max (2., floor (log (n * pi * sqrt (5.) * dot (v.xy, v.xy)) /\n     log (phi + 1.)))) / sqrt (5.);\n  ff = vec2 (floor (fk + 0.5), floor (fk * phi + 0.5));\n  b = vec4 (ff * ni, pi * (fract ((ff + 1.) * phi) - (phi - 1.)));\n  c = floor ((0.5 * mat2 (b.y, - b.x, b.w, - b.z) / (b.y * b.z - b.x * b.w)) *\n     vec2 (atan (v.y, v.x), v.z - (1. - ni)));\n  ddMin = 4.1;\n  for (int j = 0; j < 4; j ++) {\n    a = dot (ff, vec2 (j - 2 * (j / 2), j / 2) + c);\n    z = 1. - (2. * a + 1.) * ni;\n    vf = vec3 (sin (2. * pi * fract (phi * a) + vec2 (0.5 * pi, 0.)) * sqrt (1. - z * z), z);\n    dd = dot (vf - v, vf - v);\n    if (dd < ddMin) {\n      ddMin = dd;\n      vfMin = vf;\n    }\n  }\n  return vfMin;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 VToRMat (vec3 v, float a)\n{\n  mat3 m;\n  vec2 cs;\n  float a1, a2;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  m[0][0] = (1. - cs.x) * v.x * v.x + cs.x;\n  m[1][1] = (1. - cs.x) * v.y * v.y + cs.x;\n  m[2][2] = (1. - cs.x) * v.z * v.z + cs.x;\n  a1 = (1. - cs.x) * v.x * v.y;\n  a2 = - cs.y * v.z;\n  m[0][1] = a1 + a2;\n  m[1][0] = a1 - a2;\n  a1 = (1. - cs.x) * v.z * v.x;\n  a2 = - cs.y * v.y;\n  m[2][0] = a1 + a2;\n  m[0][2] = a1 - a2;\n  a1 = (1. - cs.x) * v.y * v.z;\n  a2 = - cs.y * v.x;\n  m[1][2] = a1 + a2;\n  m[2][1] = a1 - a2;\n  return m;\n}\n\nvec3 RotToDir (vec3 v1, vec3 v2, vec3 p)\n{\n  vec3 n;\n  float c;\n  n = normalize (cross (v1, v2));\n  c = dot (v1, v2);\n  return c * p + sqrt (1. - c * c) * cross (n, p) + (1. - c) * dot (n, p) * n;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xyz)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdScD1.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1134, 1134, 1160, 1160, 1241], [1243, 1243, 1268, 1268, 1375], [1377, 1377, 1402, 1402, 1525], [1527, 1527, 1545, 1545, 1776], [1778, 1778, 1813, 1813, 2501], [2503, 2503, 2526, 2526, 2717], [2719, 2719, 2753, 2753, 3469], [3471, 3471, 3493, 3493, 3751], [3753, 3753, 3775, 3775, 4483], [4485, 4485, 4518, 4518, 4711], [4713, 4713, 4734, 4734, 4991], [4993, 4993, 5028, 5028, 5481], [5483, 5483, 5505, 5505, 6041], [6043, 6043, 6078, 6078, 9098], [9100, 9100, 9144, 9144, 9680], [9697, 9697, 9753, 9753, 11104], [11106, 11106, 11139, 11139, 11166], [11168, 11168, 11210, 11210, 11261], [11263, 11263, 11317, 11317, 11464], [11466, 11466, 11497, 11554, 12383], [12385, 12385, 12421, 12421, 12627], [12629, 12629, 12651, 12651, 12689], [12691, 12691, 12713, 12713, 12751], [12753, 12753, 12810, 12810, 12893], [12895, 12895, 12927, 12927, 13433], [13435, 13435, 13477, 13477, 13633], [13635, 13635, 13665, 13665, 13778], [13812, 13812, 13836, 13836, 13901], [13903, 13903, 13927, 13927, 13980], [13982, 13982, 14006, 14006, 14118], [14120, 14120, 14144, 14144, 14263], [14265, 14265, 14290, 14290, 14436], [14438, 14438, 14463, 14463, 14649], [14651, 14651, 14676, 14676, 14901], [14903, 14903, 14925, 14925, 15079], [15081, 15081, 15102, 15102, 15257], [15259, 15259, 15280, 15280, 15435], [15437, 15437, 15466, 15466, 15678], [15680, 15680, 15719, 15719, 15899]], "test": "untested"}
{"id": "ws2cWR", "name": "Day 112", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 21, "viewed": 532, "published": 3, "date": "1586467905", "time_retrieved": "2024-07-30T21:13:52.479951", "image_code": "// Fork of \"Day 98\" by jeyko. https://shadertoy.com/view/wdXczX\n// 2020-04-06 10:18:27\n\n\n\n// radiual blur in this buffer\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n\tfragColor = vec4(0);\n    // Radial blur\n    float steps = 26.;\n    float scale = 0.00 + pow(dot(uvn,uvn),1.1)*0.04;\n    //float chromAb = smoothstep(0.,1.,pow(length(uv - 0.5), 0.3))*1.1;\n    float chromAb = pow(length(uv - 0.5),1.5)*0.4;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n        scale *= 0.97;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1.4/iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    fragColor += radial;\n    \n    //fragColor.b *= 0.97 + dot(uvn,uvn)*0.4;\n    //fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.6);\n    \n    fragColor.t *= 1.  - smoothstep(0.,1.,dot(uvn,uvn))*0.;\n    \n    \n    //fragColor.b *= 1. + uv.x*0.02;\n    //fragColor.g *= 1. + uv.t*0.05;\n    fragColor *= 1. - dot(uvn,uvn)*2.;\n    \n    fragColor = max(fragColor, 0.);\n    fragColor = pow(fragColor, vec4(0.4545 ));\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define pi acos(-1.)\n\n#define tau (2.*pi)\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define dmin(a,b) a.x < b.x ? a : b\n\n#define pmod(p,z) mod(p,z) - 0.5*z\n\n#define pal(a,b,d,e,f) ((a) + (b)*sin((d) * (e) + (f)))\n\nfloat sdBox(vec3 p, vec3 s){\n\tp = abs(p) - s;\n    return max(p.x,max(p.y,p.z));\n}\n\nvec3 glow = vec3(0);\n\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e7);\n    vec3 j = p;\n    p.z = pmod(p.z, 10.);\n\n    \n    \n    for(int i = 0; i < 4; i++){\n    \tp = abs(p);\n        p.x -= 2.;\n        p.xy *= rot(0.25*pi);\n        \n        p.t -= 1.;\n        p.z += 0.2;\n        \n        \n    }\n    vec3 glown = vec3(0);\n    \n    //float dB = length(p) - 0.4;\n    \n    p = abs(p);\n    p.xy -= 0.3;\n    \n    p = abs(p);\n    p.y -= 0.2;\n    p = abs(p);\n    p.x -= 0.5;\n    p = abs(p);\n    p.x -= 0.5;\n    \n    float attd = pow(abs(sin(j.z*0.5 + iTime*0.4)), 10.);; \n    float atte = pow(abs(sin(j.z*0.5 + iTime*10.4)), 100.)*attd; \n    \n    vec3 q = p;\n    \n    q.x -= 0.4;\n    q = abs(q);\n    q.x -= 0.4;\n\n    q.y -= 0.4;\n    \n    vec3 sz = vec3(0.02,0.02,20.5);\n    float dB = sdBox(q, sz)*1.2;\n    \n    d = dmin(d, vec2(dB, 2.));\n    float att = pow(abs(sin(j.z*0.1 + iTime*0.5 + sin(j.x*4.)*0.2)), 400.);\n    \n    //glow += 0.9/(0.001 + dB*dB*2000.)*vec3(1.8 + attd*8.,0.9,0.7)*att;\n    glown += 0.9/(0.0001 + dB*dB*10.)*vec3(2.8 + attd*8.,0.9,0.7)*att;\n    \n    p.z -= 1.5;\n    \n    p = abs(p);\n    p.z -= 0.2;\n    //p.xz *= rot(0.5);\n    float dC = sdBox(p, vec3(0.02,2000.7,0.02));\n    d = dmin(d, vec2(dC, 2.));\n    float attb = pow(abs(sin(p.x*0.4 + iTime - 1.)), 10.);\n    //glown += 7.9/(0.04 + dC*dC*2000.)*vec3(1.,1.,1.7)*attb;\n\tglown += 2.9/(0.001 - - atte*2. + dC*dC*400.)*vec3(1.,1.,1.7)*attb;\n\n    //glow += 2.9/(0.001 + dC*dC*400.)*vec3(1.,1.,1.7)*attb;\n    \n    p.x -= 0.4;\n    p = abs(p);\n    p.x += 0.1;\n    p.y -= 0.2;\n    p.xy *= rot(-0.25*pi);\n    p.z -= 1.;\n    //p -= 0.4;\n    p.x -= 0.3;\n    \n    float dD = sdBox(p, vec3(0.02,1.7,0.02));\n    d = dmin(d, vec2(dD, 2.));\n    float attc = pow(abs(sin(p.y*0.4 + iTime + 4.)), 10.);\n    //glow += 10.9/(0.01 + dD*dD*2000.)*sin(vec3(0.1,0.8,0.7) + vec3(0,0,attd*2.))*attc;\n    //glow += 0.7/(0.001 + dD*dD*100.)*sin(vec3(0.1,0.1,0.9) + vec3(0,0,attd*2.))*attc;\n    \n    \n    //glown += 0.7/(0.0001 + dD*dD*100.)*sin(vec3(0.1,1.1,0.9) + vec3(0,0,attd*1.))*attc;\n    //glown += 0.7/(0.001 + dD*dD*(60. - atte*59.))*sin(vec3(0.,1. - atte*0.6,1.9) + vec3(0,0,attd*1.))*attc*vec3(1,1,1.5)*0.8;\n    //glown += 0.7/(0.001 + dD*dD*(60. - atte*59.))*sin(vec3(0.,0.4 - atte*0.6,1.9) + vec3(0,0,attd*1.))*attc*vec3(1,1,1.5)*0.8;\n    glown += 0.7/(0.001 + dD*dD*(60. - atte*59.))*sin(vec3(0.1,0.4 - atte*0.6,1.1) + vec3(0,0,attd*0.))*attc*vec3(1,1,1.)*0.8;\n    \n    \n    d.x = abs(d.x) + 0.002;\n    \n    \n    \n    glow += glown;\n    \n    d.x *= 0.4;\n    \n    return d;\n}\nint it = 0;\n\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tvec2 d = vec2(10e7);\n    \n    t = 0.; hit = false; p = ro;\n    \n    for(it = 0; it< 60 + min(iFrame,0); it++){\n    \td = map(p);\n        \n        if(d.x < 0.001){\n        \thit = true;\n        \tbreak;\n        }\n    \tt += d.x;\n        p = ro + rd*t;\n    }\n    \n    \n    return d;\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    return normalize(dir + (right*uv.x + up*uv.y)*0.6);\n}\n\nvec3 getNormal(vec3 p){\n    vec2 t = vec2(0.001,0.);\n    return -normalize(vec3(\n    \tmap(p - t.xyy).x - map(p + t.xyy).x,\n    \tmap(p - t.yxy).x - map(p + t.yxy).x,\n    \tmap(p - t.yyx).x - map(p + t.yyx).x\n    ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n\tuv *= 1. - dot(uv,uv)*0.06;\n    \n    vec3 ro = vec3(0);\n    \n    ro.z += iTime*1.;\n    \n    vec3 lookAt = vec3(0);\n    \n    lookAt.z = ro.z + 2.;\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    vec3 p; float t; bool hit;\n    \n    vec2 d = march(ro, rd, p, t, hit);\n    \n    if (d.x < 0.001){\n    \tvec3 n = getNormal(p);\n        vec3 l = normalize(vec3(1));\n        float dnh = max(dot(n,normalize(l - rd)),0.);\n        float diff = max(dot(n,l),0.);\n        float spec = pow(max(dot(n,normalize(l - rd)),0.), 20.);\n        float fres = pow(1. - dnh, 5.);\n    \n        \n        //col *= fres;\n        \n    }\n    \n    //col += float(it)*0.003;\n    \n    \n    col += glow*0.001;\n    col = mix(col, vec3(0.1,0.1,0.16 + (uv.x + 0.5)*0.1)*0.02, smoothstep(0.,1.,t*0.04 ));\n    \n    \n    \n    //col += pal(0.5,0.6,vec3(0.7,0.3,0.7), 0.7,0.6)*smoothstep(1.,0.,length(glow)*0.3);;\n    col = max(col, 0.);\n    \n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2cWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 122, 179, 179, 1364]], "test": "untested"}
{"id": "wdjcDR", "name": "Graph Network*", "author": "wyatt", "description": "graph network of particles. They find each other by searching a directional graph. ", "tags": ["graph"], "likes": 19, "viewed": 651, "published": 3, "date": "1586462733", "time_retrieved": "2024-07-30T21:13:53.417444", "image_code": "// Fork of \"Graph Network\" by wyatt. https://shadertoy.com/view/tssyDS\n// 2020-04-09 20:04:37\n\nMain {\n    U -= 0.5*R;\n    //U*=0.1;\n    U += 0.5*R;\n\tQ = vec4(0);\n    for (int x = -1; x<=1; x++)\n        for (int y = -1; y<=1; y++) {\n        \tvec4 d = C(U+vec2(x,y));\n            vec4 a = A(d.zw), b = A(d.zw);\n            Q += .2/(1.+(.7-abs(d.z/R.x-0.5))*dot(U-a.xy,U-a.xy))*(.6+0.4*sin(5.*d.z/R.x+vec4(1,2,3,4)));\n         }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texelFetch(iChannel1,ivec2(U),0)\n#define C(U) texelFetch(iChannel2,ivec2(U),0)\n#define D(U) texelFetch(iChannel3,ivec2(U),0)\n#define Main void mainImage (out vec4 Q, vec2 U) \n#define Init if (iFrame < 1) \n#define Border if (U.x<1.||R.x-U.x<1.||U.y<1.||R.y-U.y<1.)\n#define O 6.\n#define shape(U) (round((U)/O)*O)\n#define N 12\n#define Z vec2(u)\nfloat angle (vec2 a, vec2 b) {\n\treturn atan(a.x*b.y-a.y*b.x,dot(a.xy,b.xy));\n}\nfloat sg (vec2 p, vec2 a, vec2 b) {\n    if (length(a-b)<1e-4||length(a)<1e-4||length(b)<1e-4) return 1e9;\n    \n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\tfloat l = (length(p-a-(b-a)*i));\n    return l;\n}\n\nfloat pie (vec2 p, vec2 a, vec2 b) {\n\tvec2 m = 0.5*(a+b); // midpoint\n    if (length(a-b)<1e-3) return 1e3; // ignore self\n\treturn abs(dot(p-m,b-m)/dot(b-m,b-m)); // pojection\n} \nfloat line (vec2 p, vec2 a, vec2 b) {\n    if (length(a-b)<1.||length(a)<1.||length(b)<1.) return 1e9;\n    \n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\tfloat l = (length(p-a-(b-a)*i));\n    l=(pie(p,a,b));\n    return l;\n}", "buffer_a_code": "vec2 force (vec2 U, vec4 a, vec2 bb) {\n    vec4 b = A(bb);\n    if (b.x<5.&&b.y<5.) return vec2(0);\n    \n    vec2 r = b.xy-a.xy, v = b.zw-a.zw,\n         q = D(U).xy-D(bb).xy;\n    float l = length(r), j = length(q);\n    if (l < 1e-9) return vec2(0);\n    vec2 f = vec2(0);\n    if (l!=0.&&j!=0.){\n    f += -10.*(U.x/R.x-0.5)*(bb.x/R.x-0.5)*(2.+dot(a.zw,b.zw))*r/max(1.,l*l*l);\n    f += 10.*r/max(10.,l*l*l*l);\n    f -= (100.)*r/max(10.,l*l*l*l*l);\n    }\n    if (length(f)>1.) return normalize(f);\n    return f;\n}\nMain {\n    vec2 u = shape(U);\n    if (u.x+O>=R.x||u.y+O>=R.y||u.x<O||u.y<O||length(U-u)>1.) discard;\n    Q = A(u);\n    vec2 f = vec2(0);\n    for (int x=-2;x<2; x++) {\n        for (int y=-2;y<2; y++) {\n            vec4 b = B(u+vec2(x,y));\n            f += (\n                force(U,Q,b.xy)+\n                force(U,Q,b.zw));\n        }\n\t}\n    f /= 16.;\n    Q.zw += f-0.001*Q.zw;\n    Q.w -= 0.002;\n    Q.xy += f+Q.zw*sqrt(1./(1.+dot(Q.zw,Q.zw)));\n    if (length(Q.zw)>5.)Q.zw=5.*normalize(Q.zw);\n    if (iMouse.z>0.) Q.zw += 10.*(Q.xy-iMouse.xy)/dot(Q.xy-iMouse.xy,Q.xy-iMouse.xy);\n    if (Q.x<5.) {Q.x=5.;Q.z = +abs(Q.z);}\n    if (R.x-Q.x<5.) {Q.x=R.x-5.;Q.z =-abs(Q.z);}\n    if (Q.y<5.) {Q.y=5.;Q.w = +abs(Q.w);}\n    //if (R.y-Q.y<5.) {Q.y=R.y-5.;Q.w =-abs(Q.w);}\n    if (iFrame < 50) {\n    \tQ = vec4(u+0.5*O,0,0);\n    }\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void X (inout vec4 Q, inout vec2 r, vec4 a, vec2 U, vec2 u, vec4 n) {\n\tfloat l = line(a.xy-U+u,a.xy,A(n.xy).xy),\n          ll = line(a.xy-U+u,a.xy,A(n.zw).xy);\n    if (l<r.x){\n        r = vec2(l,r.x);\n        Q=vec4(n.xy,Q.xy);\n    } else if (l<r.y) {\n    \tr.y = l;\n        Q.zw = n.xy;\n    }\n    if (ll<r.x){\n    \tr = vec2(ll,r.x);\n        Q=vec4(n.zw,Q.xy);\n    } else if (ll<r.y) {\n    \tr.y = ll;\n        Q.zw = n.zw;\n    }\n}\nMain {\n    vec2 u = shape(U);\n    vec4 a = A(u);\n\tQ = B(U);\n    vec2 r = vec2(line(a.xy-U+u,a.xy,A(Q.xy).xy)\n                 ,line(a.xy-U+u,a.xy,A(Q.zw).xy));\n    \n    X(Q,r,a,U,u,B(Q.xy+U-u));\n    X(Q,r,a,U,u,B(Q.zw+U-u));\n    \n    X(Q,r,a,U,u,B(U+vec2(1,1)));\n    X(Q,r,a,U,u,B(U+vec2(0,1)));\n    X(Q,r,a,U,u,B(U+vec2(1,0)));\n    X(Q,r,a,U,u,B(U-vec2(0,1)));\n    X(Q,r,a,U,u,B(U-vec2(1,0)));\n    X(Q,r,a,U,u,B(U+vec2(1,1)));\n    X(Q,r,a,U,u,B(U+vec2(1,-1)));\n    X(Q,r,a,U,u,B(U-vec2(1,1)));\n    X(Q,r,a,U,u,B(U-vec2(1,-1)));\n    X(Q,r,a,U,u,B(Q.xy+U-u+vec2(0,1)));\n    X(Q,r,a,U,u,B(Q.xy+U-u+vec2(1,0)));\n    X(Q,r,a,U,u,B(Q.xy+U-u-vec2(0,1)));\n    X(Q,r,a,U,u,B(Q.xy+U-u-vec2(1,0)));\n    X(Q,r,a,U,u,B(Q.xy+U-u+vec2(1,1)));\n    X(Q,r,a,U,u,B(Q.xy+U-u+vec2(1,-1)));\n    X(Q,r,a,U,u,B(Q.xy+U-u-vec2(1,1)));\n    X(Q,r,a,U,u,B(Q.xy+U-u-vec2(1,-1)));\n    X(Q,r,a,U,u,vec4(U-O*vec2(1,0),U+O*vec2(1,0)));\n    X(Q,r,a,U,u,vec4(U-O*vec2(0,1),U+O*vec2(0,1)));\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\nvoid Y (inout vec4 Q, vec2 U, vec4 n) {\n\tfloat l = length(U-A(n.xy).xy),//sg(U,A(n.xy).xy,A(n.zw).xy),\n          ll = length(U-A(Q.xy).xy);//sg(U,A(Q.xy).xy,A(Q.zw).xy);\n    if (l<ll) Q.xy = n.xy;\n}\nvoid X (inout vec4 Q, vec2 U, vec4 n) {\n\tfloat l = length(U-A(n.zw).xy),//sg(U,A(n.xy).xy,A(n.zw).xy),\n          ll = length(U-A(Q.zw).xy);//sg(U,A(Q.xy).xy,A(Q.zw).xy);\n    if (l<ll) Q.zw = n.zw;\n}\nMain {\n\tQ = C(U).xyxy;\n    if (iFrame%N==0) Q.xy = U;\n    else {\n        float k = exp2(float(N-1-(iFrame%N)));\n    \tY(Q,U,C(U+vec2(0,k)));\n    \tY(Q,U,C(U+vec2(k,0)));\n    \tY(Q,U,C(U-vec2(0,k)));\n    \tY(Q,U,C(U-vec2(k,0)));\n    }\n\n\tX(Q,U,C(U+vec2(0,1)));\n    X(Q,U,C(U+vec2(1,0)));\n    X(Q,U,C(U-vec2(0,1)));\n    X(Q,U,C(U-vec2(1,0)));\n    \n    X(Q,U,C(U+vec2(1,1)));\n    X(Q,U,C(U+vec2(1,-1)));\n    X(Q,U,C(U-vec2(1,1)));\n    X(Q,U,C(U-vec2(1,-1)));\n    \n    X(Q,U,C(U+vec2(0,4)));\n    X(Q,U,C(U+vec2(4,0)));\n    X(Q,U,C(U-vec2(0,4)));\n    X(Q,U,C(U-vec2(4,0)));\n    \n    X(Q,U,C(U));\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n\tQ.xy = 0.3*shape(U);\n}", "buffer_d_inputs": [], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdjcDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "tdjyzz", "name": "Tree in the wind", "author": "Maurogik", "description": "Falling leaves and a full day/night cycle.\nOnce again, it started as a simple tree experiment and got complicated really fast.", "tags": ["landscape", "tree", "leaf"], "likes": 364, "viewed": 14644, "published": 3, "date": "1586448367", "time_retrieved": "2024-07-30T21:13:54.645161", "image_code": "//   _____                 _         _   _                     _           _ \n//  /__   \\_ __ ___  ___  (_)_ __   | |_| |__   ___  __      _(_)_ __   __| |\n//    / /\\/ '__/ _ \\/ _ \\ | | '_ \\  | __| '_ \\ / _ \\ \\ \\ /\\ / / | '_ \\ / _` |\n//   / /  | | |  __/  __/ | | | | | | |_| | | |  __/  \\ V  V /| | | | | (_| |\n//   \\/   |_|  \\___|\\___| |_|_| |_|  \\__|_| |_|\\___|   \\_/\\_/ |_|_| |_|\\__,_|\n//                                                                                                       \n//\n//----------------------------------------------------------------------------------------\n//     ___                                                    _  _    \n//    / __\\ _   _     /\\/\\    __ _  _   _  _ __  ___    __ _ (_)| | __\n//   /__\\//| | | |   /    \\  / _` || | | || '__|/ _ \\  / _` || || |/ /\n//  / \\/  \\| |_| |  / /\\/\\ \\| (_| || |_| || |  | (_) || (_| || ||   < \n//  \\_____/ \\__, |  \\/    \\/ \\__,_| \\__,_||_|   \\___/  \\__, ||_||_|\\_\\\n//          |___/                                      |___/          \n//\n//----------------------------------------------------------------------------------------\n\n//The day/night cyle takes around 1 a minute, so sit back and relax.\n\n//Text ascii art using : http://patorjk.com/software/taag/\n\nfloat tonemapOp(float v)\n{\n    v = pow(v, 2.0);\n    v = v / (1.0 + v);\n    return pow(v, 1.0/2.0) * 1.025;\n}\n\nvec3 tonemap(vec3 colour)\n{\n    float inputLuminance = max(0.0001, rbgToluminance(colour));\n    vec3 normalisedColour = colour / inputLuminance;\n    \n    vec3 tonemapColour;\n    tonemapColour.r = tonemapOp(colour.r);\n    tonemapColour.g = tonemapOp(colour.g);\n    tonemapColour.b = tonemapOp(colour.b);\n    float tonemappedLuminance = tonemapOp(inputLuminance);\n    \n    tonemapColour = (tonemapColour / max(0.0001, rbgToluminance(tonemapColour)));\n    \n    return tonemappedLuminance * mix(normalisedColour, tonemapColour, min(1.0, 0.35*inputLuminance));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n      \n\tvec4 colour = texture(iChannel0, uv);\n    \n    //Vignette\n    colour.rgb *= smoothstep(1.15, 0.3, length(uv - 0.5*oz.xx));\n    \n\t//Tonemap\n    float toeStrength = 1.25;\n    colour.rgb = tonemap(colour.rgb * toeStrength); colour.rgb = pow(colour.rgb, toeStrength*oz.xxx);\n    \n    //Gamma\n    colour = pow(colour, vec4(1.0/2.2));\n    fragColor = colour;\n    \n    //Dithering\n    fragColor += ((hash12(fragCoord)) - 0.5)*4.0/255.0;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 21838, "src": "https://soundcloud.com/musa-muh-nur/nature-sounds-beautiful", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "//   __  _                            _                   _       \n//  / _\\| |__    __ _  _ __  ___   __| |   ___  ___    __| |  ___ \n//  \\ \\ | '_ \\  / _` || '__|/ _ \\ / _` |  / __|/ _ \\  / _` | / _ \\\n//  _\\ \\| | | || (_| || |  |  __/| (_| | | (__| (_) || (_| ||  __/\n//  \\__/|_| |_| \\__,_||_|   \\___| \\__,_|  \\___|\\___/  \\__,_| \\___|\n//                                                                \n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// SDF functions from mercury : http://mercury.sexy/hg_sdf/ //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define PI 3.14159265359\n\n////////////////////////////////////////////////////////////////\n//\n//             PRIMITIVE DISTANCE FUNCTIONS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that is a distance function is called fSomething.\n// The first argument is always a point in 2 or 3-space called <p>.\n// Unless otherwise noted, (if the object has an intrinsic \"up\"\n// side or direction) the y axis is \"up\" and the object is\n// centered at the origin.\n//\n////////////////////////////////////////////////////////////////\n\nfloat fSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// Capsule: A Cylinder with round caps on both sides\nfloat fCapsule(vec3 p, float r, float c)\n{\n    return mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b)\n{\n    vec3  ab = b - a;\n    float t  = saturate(dot(p - a, ab) / dot(ab, ab));\n    return length((ab * t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    return fLineSegment(p, a, b) - r;\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height)\n{\n    vec2  q         = vec2(length(p.xz), p.y);\n    vec2  tip       = q - vec2(0.0, height);\n    vec2  mantleDir = normalize(vec2(height, radius));\n    float mantle    = dot(tip, mantleDir);\n    float d         = max(mantle, -q.y);\n    float projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\n    // distance to tip\n    if((q.y > height) && (projected < 0.0))\n    {\n        d = max(d, length(tip));\n    }\n\n    // distance to base ring\n    if((q.x > radius) && (projected > length(vec2(height, radius))))\n    {\n        d = max(d, length(q - vec2(radius, 0.0)));\n    }\n    return d;\n}\n\n\n////////////////////////////////////////////////////////////////\n//\n//                DOMAIN MANIPULATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that modifies the domain is named pSomething.\n//\n// Many operate only on a subset of the three dimensions. For those,\n// you must choose the dimensions that you want manipulated\n// by supplying e.g. <p.x> or <p.zx>\n//\n// <inout p> is always the first argument and modified in place.\n//\n// Many of the operators partition space into cells. An identifier\n// or cell index is returned, if possible. This return value is\n// intended to be optionally used e.g. as a random seed to change\n// parameters of the distance functions inside the cells.\n//\n// Unless stated otherwise, for cell index 0, <p> is unchanged and cells\n// are centered on the origin so objects don't have to be moved to fit.\n//\n//\n////////////////////////////////////////////////////////////////\n\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a)\n{\n    p = cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions)\n{\n    float angle = 2.0 * PI / repetitions;\n    float a     = atan(p.y, p.x) + angle / 2.;\n    float r     = length(p);\n    float c     = floor(a / angle);\n    a           = mod(a, angle) - angle / 2.;\n    p           = vec2(cos(a), sin(a)) * r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if(abs(c) >= (repetitions / 2.0))\n        c = abs(c);\n    return c;\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size)\n{\n    vec2 c = floor((p + size * 0.5) / size);\n    p      = mod(p + size * 0.5, size) - size * 0.5;\n    return c;\n}\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size)\n{\n    vec3 c = floor((p + size * 0.5) / size);\n    p      = mod(p + size * 0.5, size) - size * 0.5;\n    return c;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Intersectors and other things from IQ\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n\n// vertical\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdOctogon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623 );\n    p = abs(p);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\n// plane degined by p (p.xyz must be normalized)\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat opExtrusion( in vec3 p, in float dist, in float h )\n{\n    vec2 w = vec2( dist, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\n//From https://iquilezles.org/articles/sphereshadow\nfloat sphSoftShadow( in vec3 ro, in vec3 rd, in vec3 sph, in float ra, in float k )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n\n    return (b>0.0) ? step(-0.0001,c) : smoothstep( -0.5, 0.5, h*k/b );\n}\n\nvec3 opCheapBend( in vec3 p, float bend )\n{\n    float k = bend;\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Hashes from Dave Hopkins \n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Common Shader Code\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n#define NON_CONST_ZERO (min(iFrame,0)) \n#define NON_CONST_ZERO_U uint(min(iFrame,0)) \n\nconst vec2 oz = vec2(1.0, 0.0);\n\nconst float kGoldenRatio = 1.618;\nconst float kGoldenRatioConjugate = 0.618;\n\nconst float kPI         = 3.14159265359;\nconst float kTwoPI      = 2.0 * kPI;\n\nconst float kMaxDist = 10000.;\nconst float kTimeScale = 1.0;\n\nfloat kIsotropicScatteringPhase = (1.0 / (4.0 * kPI));\n\nvec3 roughFresnel(vec3 f0, float cosA, float roughness)\n{\n    // Schlick approximation\n    return f0 + (oz.xxx - f0) * (pow(1.0 - cosA, 5.0)) * (1.0 - roughness);\n}\n\nfloat linearstep(float start, float end, float x)\n{\n    float range = end - start;\n    return saturate((x - start) / range);\n}\n\nfloat henyeyGreensteinPhase_schlick(float cosA, float g)\n{\n    float k = 1.55*g - 0.55*g*g*g;\n    float f = 1.0 - k * cosA;\n\treturn (1.0 - k * k) / (4.0 * kPI * f*f);\n}\n\nfloat henyeyGreensteinPhase(float cosA, float g)\n{\n    return henyeyGreensteinPhase_schlick(cosA, g);\n\t/*float g2 = g*g;\n    return 1.0 / (4.0 * kPI) *\n        ((1.0 - g2)/pow(1.0 + g2 - 2.0*g*cosA, 1.5));*/\n}\n\nfloat rayleighPhase(float rayDotSun)\n{\n    float k = (3.0 / 4.0) * kIsotropicScatteringPhase;\n    return k * (1.0 + rayDotSun * rayDotSun);\n}\n\nfloat rbgToluminance(vec3 rgb)\n{\n    return (rgb.r * 0.3) + (rgb.g * 0.59) + (rgb.b * 0.11);\n}\n\nvec3 fixNormalBackFacingness(vec3 rayDirWS, vec3 normalWS)\n{\n    normalWS -= max(0.0, dot(normalWS, rayDirWS)) * rayDirWS;\n    return normalWS;\n}\n\n//This is NOT a good way of converting from wavelgnth to RGB\nvec3 wavelengthToRGB(float wavelength)\n{\n    const float kLambdaR = 680.0;\n    const float kLambdaG = 550.0;\n    const float kLambdaB = 440.0;\n    \n    vec3 colour = oz.xxx - saturate(vec3(abs(wavelength-kLambdaR), abs(wavelength-kLambdaG), abs(wavelength-kLambdaB))/150.0);\n\treturn colour;  \n}\n\n\n#define USE_SPHERE 0\n#define USE_TUBE 0\n#define USE_SKY 1\n#define USE_ATM 1\n#define USE_SUN 1\n\n\nconst float kSunRadius = 1.0/180.0*kPI;\nconst float kCosSunRadius = cos(kSunRadius);\nconst float kTanSunRadius = tan(kSunRadius);\nconst float kSunDiskSolidAngle = 2.0*kPI*(1.0 - kCosSunRadius);\n\nconst float kAtmDensity = 1.0;\n\nconst vec3 kRayleighScatteringCoefsKm = vec3(5.8e-3, 1.35e-2, 3.31e-2) * kAtmDensity;\nconst float kRayleighAtmHeightKm = 8.0;\n\nconst float kMieAtmHeightKm = 1.2;\nconst float kMieScatteringCoefsKm = 0.0075 * kAtmDensity * 2.0;\n\nconst float kEarthRadiusKm = 6000.0;\n\nconst float kMultipleScatteringFakery = 0.5;\n\n\nvec3 s_dirToSunWS = normalize(vec3(0.4, -0.01, 0.5));\nvec3 s_sunColour = oz.yyy;\nvec3 s_cloudSunColour = oz.yyy;\nvec3 s_sunRadiance  = oz.yyy;\nvec3 s_averageSkyColour = oz.yyy;\nfloat s_timeOfDay = 0.0f;\nfloat s_time = 0.0f;\nfloat s_earthRotationRad = 0.0f;\nvec3 s_eyePositionWS = oz.xxx;\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Shared SDF\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nconst float kMatMapleLeaf = 0.0;\nconst float kMatFallingMapleLeaf = 1.0;\nconst float kMatMapleBark = 2.0;\nconst float kMatGrass = 3.0;\nconst float kMatMountains = 4.0;\nconst float kMatPines = 5.0;\n\nconst uint kRenderFilter = 0u;\nconst uint kShadowMapFilter = 1u;\n\nconst vec3 kWindVelocityWS = -oz.xyy * 0.75;\n\nconst vec3 kTreePosWS = vec3(0.0, 0.0, -8.0);\n\n//2 triangles and some displacement\nfloat fMapleLeaf(vec3 posLeaf, float scale, float rand, bool doDetail, out vec4 material)\n{\n    posLeaf = opCheapBend(posLeaf.xzy, (rand-0.5) * 10.0).xzy;\n    \n    float normalisedHeight = saturate(0.5 + (posLeaf.y/scale));\n    material = vec4(kMatMapleLeaf, 1.0, 0.0, 0.0);\n    \n    vec3 posTri = posLeaf - oz.yxy * scale;\n    posTri.y = -posTri.y;\n    \n    if(doDetail)\n    {\n    \tposTri.y += max(0.0, cos(abs(posTri.x)*6.0*kPI)) * 0.035;\n    }\n\n    float pointyBits = 0.0;\n    float dist2D = sdTriangleIsosceles(posTri.xy, vec2(scale*1.2, scale*2.0));\n    float innerStick = linearstep(0.01, 0.0, abs(posTri.x));\n    innerStick = max(innerStick, linearstep(0.02, 0.0, abs(abs(posTri.x)-1.75*(posTri.y-1.4*scale))));\n        \n    if(doDetail)\n    {\n        pointyBits = abs(fract((-0.08 + posTri.y + abs(posTri.x)*2.0)*8.0) - 0.5) * 0.1 \n            * saturate(1.0 - abs(-posTri.y/scale + 0.4)*1.);\n\n        dist2D -= pointyBits;\n    }\n    \n    float distToMid = (1.0 - 2.0*abs(normalisedHeight - 0.2));\n    dist2D += distToMid*0.02;\n\n    posTri.y -= scale * 0.75;\n    posTri.x = abs(posTri.x) - scale * 1.3;\n    pR(posTri.xy,  kPI * 0.35);\n    \n    float distTriSides = sdTriangleIsosceles(posTri.xy, vec2(scale*0.55, scale*1.3));\n    innerStick = max(innerStick, linearstep(0.01, 0.0, abs(posTri.x)));\n    if(doDetail)\n    {    \n        pointyBits = abs(fract((-0.03 + posTri.y + abs(posTri.x)*2.0)*8.0) - 0.5) * 0.1 \n            * saturate(1.0 - abs(-posTri.y/scale + 0.35)*2.5);\n        distTriSides -= pointyBits;\n    }\n\tdist2D = min(dist2D, distTriSides);\n    \n    float inside = max(0.0, -dist2D/scale);\n    material.z = inside;\n    material.w = floor(rand * 100.0) + innerStick*0.99;\n    \n    if(doDetail)\n    {\n    \tdist2D -= abs(fract((posLeaf.y/scale)*5.0)-0.5) * 0.02;\n    }\n    \n    float minDist = opExtrusion(posLeaf, dist2D, 0.005);\n    \n    if(doDetail)\n    {\n        vec3 posStick = posLeaf + oz.yxy * scale * 0.5;\n        float stickProgress = saturate(-posStick.y/scale);\n        posStick.z += stickProgress*stickProgress*scale*0.3*(rand - 0.5);\n    \tfloat stickDist = fCapsule(posStick, -oz.yxy * scale * 1.0, oz.yyy, 0.003);\n        if(stickDist < minDist)\n        {\n            minDist = stickDist;\n        }        \n    }\n    \n    return minDist;\n}\n\nfloat fBranchSDF(vec3 posBranch, float len, float rad, float rand, out vec4 material)\n{\n    float branchHalfLen = len * 0.5;\n    float progressAlong = posBranch.y / (2.0*branchHalfLen);    \n    float branchRad = rad * (1.0 - progressAlong * 0.8);\n    \n    float wave = sin((rand + posBranch.y)/len * 12.0)*0.25*rad;\n    posBranch.xz += oz.xx * wave;\n\tfloat minDist = fCapsule(posBranch - oz.yxy * branchHalfLen, branchRad, branchHalfLen);\n    \n    float u = atan(posBranch.z, posBranch.x);\n    material = vec4(kMatMapleBark, 0.0/*overriden for AO*/, u, progressAlong);\n\n    return minDist;\n}\n\nfloat fBranchSDF(vec3 posWS, float scale, float rand, out vec4 material)\n{\n    float branchLen = 1.0 * scale;\n    float branchRad = 0.03 * scale;\n\n    return fBranchSDF(posWS, branchLen, branchRad, rand, material);\n}\n\nfloat fSmallBranchesSDF(vec3 posWS, float branchDist, float branchProgress, out vec4 material)\n{\n    float branchLen = clamp(branchDist * 2.0, 0.5, 2.0);\n    \n    //Shift until it looks good\n    posWS += vec3(0.53, 1.0, 0.53);\n    \n    vec3 posBranches = posWS;\n    vec3 id = pMod3(posBranches, oz.xxx * 2.0);\n    id.x += pModPolar(posBranches.yz, 3.0);\n    float rand = hash13(id * 789.5336);\n    posBranches.xz += sin((posBranches.y + rand) * 2.0 * kPI) * 0.05;\n    pR(posBranches.xy, (rand - 0.5) * kPI * 0.25);\n    float rad = 0.05 * (1.3 - ((posBranches.y/branchLen) + 0.5));\n    float minDist = fCapsule(posBranches, rad, branchLen);\n    \n    posBranches = posWS + oz.xxx;\n    id = oz.xxx * 235.68 + pMod3(posBranches, oz.xxx * 2.0);\n    id.x += pModPolar(posBranches.yx, 3.0);\n    rand = hash13(id * 789.5336);\n    posBranches.xz += sin((posBranches.y + rand) * 2.0 * kPI) * 0.05;\n    pR(posBranches.yz, (rand - 0.5) * kPI * 0.25);\n    rad = 0.05 * (1.3 - ((posBranches.y/branchLen) + 0.5));\n    minDist = min(minDist, fCapsule(posBranches, rad, branchLen));\n    \n    //Remove branches near the center of the tree\n    minDist += saturate(0.7 - branchProgress);\n    \n    //Remove small branches away from main branches\n    minDist = smax(minDist, branchDist - 3.0, 0.75);\n    //Remove small branches past the end of the main branch\n    minDist += saturate((branchProgress - 1.4)*3.0);\n    \n    material = vec4(kMatMapleBark, 0.0/*overriden for AO*/, 0.001, branchProgress);\n    return minDist;\n}\n\nfloat fCanopy(vec3 posTreeSpace, float branchesDist, vec4 branchMaterial, out vec4 material)\n{\n    const float leafSize = 0.15;\n    const float leafRep = 0.4;\n    \n    vec3 leavesPos = posTreeSpace;\n    vec3 leafId = pMod3(leavesPos, oz.xxx * leafRep);\n    float leafRand = hash13(leafId * 347.0468);\n    leavesPos.xzy += (leafRand - 0.5) * oz.xxx * leafRep * 0.5;\n    pR(leavesPos.xz, leafRand * kPI);\n    float leavesDist = fMapleLeaf(leavesPos, leafSize, leafRand, false, material);\n    \n    leavesPos = posTreeSpace + oz.xxx * leafRep * 0.5;\n    pR(leavesPos.xz, kGoldenRatio * kPI);\n    leafId = pMod3(leavesPos, oz.xxx * leafRep);\n    leafRand = hash13(leafId * 347.0468);\n    pR(leavesPos.xz, leafRand * kPI);\n    leavesPos.xzy += (leafRand - 0.5) * oz.xxx * leafRep * 0.2;\n    leavesDist = min(leavesDist, fMapleLeaf(leavesPos, leafSize, leafRand, false, material));\n    \n    //Remove leaves that are too far from branches, and too close to the trunk, and to far past the main branches\n    float branchStart = linearstep(0.6, 0.4, branchMaterial.w);\n    float branchEnd = linearstep(1.3, 1.42, branchMaterial.w);\n    leavesDist = max(leavesDist, branchesDist - (0.27 - branchEnd*0.17) + branchStart);\n    \n    return leavesDist;\n}\n\nfloat fFallenLeavesSet(vec3 posTreeSpace, float iter, float groundY, out vec4 material)\n{\n    float iterRand = fract(iter * kGoldenRatio);\n    float repSize = 0.25 + iter * 0.2;\n    vec3 leafPos = posTreeSpace - iter * kWindVelocityWS * 4.0;\n    leafPos.y = groundY - min(0.25, 0.75 - dot(leafPos.xz, leafPos.xz)*(0.01 - iter*0.002)*0.75);\n    vec2 leafId = pMod2(leafPos.xz, oz.xx * repSize);\n    float rand = hash12((leafId + oz.xx*iterRand*25.0) * 93.67);\n\n    leafPos.xz += (rand - 0.5) * oz.xx * repSize * (0.5);\n\tleafPos.y += abs(rand-0.5)*2.0 * 0.75;\n    \n    pR(leafPos.yz, kPI * (0.2 + rand * 0.8));\n    pR(leafPos.xy, kPI * 2.0 * rand);\n\n    return fMapleLeaf(leafPos, 0.15, rand, true, /*out*/material);\n}\n\nfloat fFallenLeaves(vec3 posTreeSpace, float groundY, out vec4 material)\n{\n    float minDist = kMaxDist;\n    \n    if(groundY < 1.)\n    {\n        vec4 fallenLeavesMaterial;\n        float fallenLeavesDist = fFallenLeavesSet(posTreeSpace, 0.0, groundY - 0.3, /*out*/fallenLeavesMaterial);\n        if(fallenLeavesDist < minDist)\n        {\n            minDist = fallenLeavesDist;\n            material = fallenLeavesMaterial;\n        }\n\n        fallenLeavesDist = fFallenLeavesSet(posTreeSpace, 1.0, groundY - 0.2, /*out*/fallenLeavesMaterial);\n        if(fallenLeavesDist < minDist)\n        {\n            minDist = fallenLeavesDist;\n            material = fallenLeavesMaterial;\n        }\n\n        fallenLeavesDist = fFallenLeavesSet(posTreeSpace, 2.0, groundY, /*out*/fallenLeavesMaterial);\n        if(fallenLeavesDist < minDist)\n        {\n            minDist = fallenLeavesDist;\n            material = fallenLeavesMaterial;\n        }  \n   \n    }\n    else\n    {\n        minDist = min(minDist, groundY - 0.75);\n    }\n    \n    return minDist;\n}\n\nfloat fTreeSDF(vec3 posTreeSpace, float groundY, out vec4 material)\n{\n    float minDist = kMaxDist;\n    float treeBoundingSphereDist = fSphere(posTreeSpace - oz.yxy * 8.0, 9.0);\n    \n    // If we're far from the tree and falling leaves, bail\n    if(treeBoundingSphereDist > 12.0)\n    {\n        return treeBoundingSphereDist - 10.0;\n    }\n    \n    // Falling leaves\n    {\n        vec3 leafPos = posTreeSpace - oz.yxy * 10.0;\n        pR(leafPos.xy, -kPI * 0.25);//Rotate to match wind direction\n        float leafId = pModPolar(leafPos.xz, 9.0);\n        float leafRand = hash11(leafId * 68.76);\n        leafPos.x -= 4.0 + leafRand * 2.0;\n        float fallDuration = 20.0;\n        float fallTime = (s_time*1.75 + leafRand * fallDuration);\n        float iter = floor(fallTime / fallDuration);\n        fallTime = fallTime - iter * fallDuration;\n\t\t\n        leafPos.y += 2.0 + fallTime;\n        float xOff = sin(fallTime * 0.75 + iter * kPI) + cos(fallTime * 1.5 + iter * kPI) * 0.5;\n        leafPos.x += xOff*1.0;\n        \n        if(length(leafPos) > 0.3)\n        {\n            minDist = length(leafPos) - 0.2;\n        }\n        else\n        {\n            pR(leafPos.yz, xOff * 0.5 * kPI);\n            pR(leafPos.xy, fallTime * (leafRand + 1.0) + iter * kPI);\n\n            vec4 fallingLeavesMaterial;\n            float fallingLeavesDist = fMapleLeaf(leafPos, 0.15, leafRand, true, /*out*/fallingLeavesMaterial);\n            fallingLeavesMaterial.x = kMatFallingMapleLeaf;\n            if(fallingLeavesDist < minDist)\n            {\n                minDist = fallingLeavesDist;\n                material = fallingLeavesMaterial;\n            }\n        }\n    }\n    \n    // If we're far from the tree, bail early\n    if(treeBoundingSphereDist > 1.0)\n    {\n        return min(minDist, treeBoundingSphereDist);\n    }\n    \n    vec4 trunkMaterial;\n    vec3 trunkPos = posTreeSpace;\n    \n    float trunkDist = fBranchSDF(trunkPos, 10.0, 0.5, 0.0, trunkMaterial);\n        \n    if(trunkDist < minDist)\n    {\n        minDist = trunkDist;\n        material = trunkMaterial;\n    }\n    \n    float minBranchDist = kMaxDist;\n    vec4 minBranchMaterial;\n    \n    \n    float winFlexOffset = dot(sin(posTreeSpace * 0.1), oz.xxx) * 2.0 * kPI;\n    float windFlexAmount = min(8.0, trunkDist)/8.0;\n    vec3 windOffset = vec3(kWindVelocityWS.x, 0.5, kWindVelocityWS.z) * \n        (sin(s_time * 4.0 + winFlexOffset)) * \n        0.05 * windFlexAmount;\n        \n    \n    vec4 branchMaterial;\n    vec3 branchPos;\n    float branchDist, id, rand;\n    \n    branchPos = trunkPos;\n    id = pModPolar(branchPos.xz, 6.0);\n    rand = hash11(id * 736.884);\n    branchPos.y -= 4.0 + 1.0 * rand;\n    pR(branchPos.xy, -kPI * (0.32 + rand * 0.1));\n    \n    branchDist = fBranchSDF(branchPos, 5.75, rand, branchMaterial);\n    if(branchDist < minBranchDist)\n    {\n        minBranchDist = branchDist;\n        minBranchMaterial = branchMaterial;\n    }\n    \n    branchPos = trunkPos;\n    pR(branchPos.xz, -kPI * 0.35);\n    id = pModPolar(branchPos.xz, 5.0);\n    rand = hash11(id * 736.884);\n    branchPos.y -= 7.5 + 1.0 * rand;\n    pR(branchPos.xy, -kPI * (0.35 - rand * 0.05));\n   \n    branchDist = fBranchSDF(branchPos, 5.0, 0.0, branchMaterial);\n    if(branchDist < minBranchDist)\n    {\n        minBranchDist = branchDist;\n        minBranchMaterial = branchMaterial;\n    }\n    \n    branchPos = trunkPos;\n    pR(branchPos.xz, -kPI * 0.65);\n    id = pModPolar(branchPos.xz, 3.0);\n    rand = hash11(id * 736.884);\n    branchPos.y -= 9.5 + 0.5 * rand;\n    pR(branchPos.xy, -kPI * (0.22 - 0.1 * rand));\n    \n    branchDist = fBranchSDF(branchPos, 4.0, 0.0, branchMaterial);\n    if(branchDist < minBranchDist)\n    {\n        minBranchDist = branchDist;\n        minBranchMaterial = branchMaterial;\n    }\n    \n    if(minBranchDist < minDist)\n    {\n        minDist = minBranchDist;\n        material = minBranchMaterial;\n    }\n    \n    \n    vec4 smallBranchesMaterial;\n    float smallBranchesDist = fSmallBranchesSDF(trunkPos + windOffset * 0.25, minBranchDist, minBranchMaterial.w, \n                                                /*out*/smallBranchesMaterial);\n    if(smallBranchesDist < minDist)\n    {\n        minDist = smallBranchesDist;\n        material = smallBranchesMaterial;\n    }\n\n    vec4 leavesMaterial;\n\tfloat leavesDist = fCanopy(trunkPos + windOffset, smallBranchesDist, minBranchMaterial, \n                               /*out*/leavesMaterial);\n    \n    if(leavesDist < minDist)\n    {\n        minDist = leavesDist;\n        material = leavesMaterial;\n    }\n    \n\t// Ambient occlusion is stronger at the center of the tree\n    vec3 posToCanopyCenter = vec3(0.0, 10.0, 0.0) - posTreeSpace;\n    material.y = min(1.0, dot(posToCanopyCenter, posToCanopyCenter) / 36.0);\n\n    return minDist;\n}\n\nfloat fGrassBladeSet(vec3 grassPosWS, float iter, float scale, float flattenAmount, inout vec4 material)\n{\n    float iterRand = hash11(iter * 967.367);\n\tfloat height = 0.45 * max(1.0, scale);\n    vec2 repSize = vec2(0.15, 0.15) * scale;\n    \n    \n    float windOffset = iterRand * 5.0 + cos(grassPosWS.z * 2.0)*1.0;\n    float wind = sin(s_time * 2.5 + windOffset + 2.0 * grassPosWS.x) * (1.0 - flattenAmount);\n    \n    //Offset each set to prevet overlap\n    grassPosWS.xz += repSize * kGoldenRatio * iter * oz.xx;\n    //Rotate each set in a different direction\n    pR(grassPosWS.xz, (0.25 + (iterRand - 0.5) * 0.5) * kPI);\n    \n    vec2 id = pMod2(grassPosWS.xz, repSize);\n    float rand = hash12(id);\n    \n    float normalisedHeight = saturate(grassPosWS.y / height);\n        \n    //Rotate/bend each blade with the wind\n    pR(grassPosWS.yz, (normalisedHeight * (0.05 + rand * 0.1) + wind * 0.025) * kPI);\n    grassPosWS.xz += (hash22(id * 37.3468) - 0.5*oz.xx) * repSize * 0.75;\n    \n    //Rotate the blade arount Y to get a variety of normal directions\n    pR(grassPosWS.xz, (rand - 0.5) * 2.0 * kPI);\n    \n    const float kConeInvAngle = 0.485*PI;\n    const vec2 kRefConeSinCos = vec2(sin(kConeInvAngle), cos(kConeInvAngle));\n    float grassD = sdCone(grassPosWS - oz.yxy*height, vec3(kRefConeSinCos, height));  \n    grassD = max(grassD, abs(grassPosWS.x) - 0.005);\n    \n    grassD += flattenAmount * 0.2;\n    \n    float ambientVis = min(1.0, 1.7 * normalisedHeight)*(1.0-flattenAmount);\n    material = vec4(kMatGrass, normalisedHeight, min(material.z, ambientVis), rand);\n    \n    return grassD * 0.8;\n}\n\nfloat fGrass(vec3 posWS, float groundY, float leavesDist, out vec4 material)\n{      \n    vec3 grassPosWS;\n    \n    grassPosWS = posWS;\n    grassPosWS.y = groundY + max(0.0, length(posWS.xz - s_eyePositionWS.xz) - 15.0) / 60.0;\n    \n    // Early ouut if far from the ground\n    if(grassPosWS.y > 1.0)\n    {\n        return grassPosWS.y - 0.2;\n    }\n    \n    material.z = 1.0;\n    \n    float flattenAmount = linearstep(0.1, 0.0, leavesDist);\n    float grassDist = kMaxDist;    \n    \n\tgrassDist = min(grassDist, fGrassBladeSet(grassPosWS, 1.0, 1.0, flattenAmount, /*out*/material));\n    grassDist = min(grassDist, fGrassBladeSet(grassPosWS, 2.0, 2.0, flattenAmount, /*out*/material));\n    \n    material.z *= linearstep(0.0, 0.3, leavesDist);\n\n    return grassDist;\n}\n\nfloat noiseFbm(vec2 uv, sampler2D noiseSampler)\n{\n    float fbm = 0.0;\n    float noise;\n    \n    noise = textureLod(noiseSampler, uv * 1.0, 0.0).r;\n    fbm += noise * 1.0;\n    noise = textureLod(noiseSampler, uv * 1.5, 0.0).r;\n    fbm += noise * 0.55;\n    noise = textureLod(noiseSampler, uv * 3.0, 0.0).r;\n    fbm += noise * 0.35;\n    noise = textureLod(noiseSampler, uv * 4.5, 0.0).r;\n    fbm += noise * 0.25;    \n    return fbm;\n}\n\nfloat fSDF(vec3 posWS, uint filterId, sampler2D noiseSampler, out vec4 material)\n{    \n    float mountainNoise = noiseFbm(posWS.xz * 0.0001 + oz.xx * 0.28, noiseSampler);\n    \n\tfloat minDist = kMaxDist;\n    \n    float groundY = fSphere(posWS - vec3(-10.0, -500.0, -20.0), 500.0);\n    \n    float distantGroundDist = (mountainNoise - 0.25) * 30.0 + fSphere(posWS - vec3(100.0, -4995.0, 500.0), 5000.0);\n    \n    float allMountainsDist = kMaxDist;\n    // Distant mountains\n    if(filterId != kShadowMapFilter)\n    {\n        // Far left\n        float scale = 1.65;\n        vec3 moutainPosWS = posWS - scale*vec3(300.0, -100.0, 1400.0);\n        float mountainDist = mountainNoise * 60.0 * scale * linearstep(-scale*150.0, scale*100.0, posWS.y) +\n            fCone(moutainPosWS, scale*700.0, scale*600.0); \n        if(mountainDist < allMountainsDist)\n        {\n            allMountainsDist = mountainDist;\n            material = vec4(kMatMountains, scale, mountainNoise, 100.0);\n        }\n\n        // A bit to the right\n        scale = 2.7;\n        moutainPosWS = posWS - scale*vec3(600.0, -100.0, 1000.0);\n        mountainDist = mountainNoise * 40.0 * scale * linearstep(-scale*100.0, scale*100.0, posWS.y) +\n            fCone(moutainPosWS, scale*500.0, scale*340.0); \n        if(mountainDist < allMountainsDist)\n        {\n            allMountainsDist = mountainDist;\n            material = vec4(kMatMountains, scale, mountainNoise, 100.0);\n        }\n\n        scale = 4.45;\n        moutainPosWS = posWS - scale*vec3(1000.0, -200.0, 900.0);\n        mountainDist = mountainNoise * 40.0 * scale * linearstep(-scale*100.0, scale*100.0, posWS.y) +\n            fCone(moutainPosWS, scale*550.0, scale*400.0); \n        if(mountainDist < allMountainsDist)\n        {\n            allMountainsDist = mountainDist;\n            material = vec4(kMatMountains, scale, mountainNoise, 100.0);\n        }\n\n        scale = 0.85;\n        moutainPosWS = posWS - scale*vec3(50.0, -120.0, 850.0);\n        mountainDist = mountainNoise * 80.0 * scale +\n            fCone(moutainPosWS, scale*700.0, scale*250.0); \n        if(mountainDist < allMountainsDist)\n        {\n            allMountainsDist = mountainDist;\n            material = vec4(kMatMountains, scale, mountainNoise, 100.0);\n        }\n\n        // Far right\n        scale = 4.0;\n        moutainPosWS = posWS - scale*vec3(1480.0, -100.0, -700.0);\n        mountainDist = mountainNoise * 50.0 * scale +\n            fCone(moutainPosWS, scale*300.0, scale*350.0); \n        if(mountainDist < allMountainsDist)\n        {\n            allMountainsDist = mountainDist;\n            material = vec4(kMatMountains, scale, mountainNoise, 100.0);\n        }\n\n        scale = 2.0;\n        moutainPosWS = posWS - scale*vec3(1700.0, -200.0, -600.0);\n        mountainDist = mountainNoise * 50.0 * scale +\n            fCone(moutainPosWS, scale*600.0, scale*350.0); \n        if(mountainDist < allMountainsDist)\n        {\n            allMountainsDist = mountainDist;\n            material = vec4(kMatMountains, scale, mountainNoise, 100.0);\n        }\n        \n        minDist = min(allMountainsDist, minDist);\n\t}\n    \n    // Fallen leaves\n    float fallenLeavesDist = kMaxDist;\n    if(filterId != kShadowMapFilter)\n    {\n        vec4 fallenLeavesMat;\n        fallenLeavesDist = fFallenLeaves(posWS - kTreePosWS, groundY, /*out*/ fallenLeavesMat);\n        \n        if(fallenLeavesDist < minDist)\n        {\n            minDist = fallenLeavesDist;\n            material = fallenLeavesMat;\n        }\n    }\n    \n    // Grass\n    vec4 grassMaterial;\n    float grassDist = kMaxDist;\n    if(filterId != kShadowMapFilter)\n    {\n        grassDist = fGrass(posWS, groundY, fallenLeavesDist, /*out*/ grassMaterial);\n        \n        if(grassDist < minDist)\n        {\n            minDist = grassDist;\n            material = grassMaterial;\n        }\n    }\n    \n    if(filterId != kShadowMapFilter && \n       groundY < minDist)\n    {\n        minDist = groundY;\n    \tmaterial = vec4(kMatGrass, 0.0, saturate(grassDist / 0.2) * 0.3, 0.0);\n        //material = vec4(kMatMountains, 0.01, mountainNoise, grassDist*50.0);\n    }\n    \n    // Tree\n    vec4 treeMaterial;\n\tfloat treeDist = fTreeSDF(posWS - kTreePosWS, groundY, /*out*/ treeMaterial);\n    \n    if(treeDist < minDist)\n    {\n        minDist = treeDist;\n        material = treeMaterial;\n    }\n    \n    // Pine cones\n    float pineDist = kMaxDist;\n\n    if(filterId != kShadowMapFilter)\n    {\n        float pineGroundDist = min(distantGroundDist, allMountainsDist + \n                                   max(0.0, posWS.y - min(300.0, (1.0 - mountainNoise)*1000.0)) * 0.05);\n        \n        if(pineGroundDist > 25.0)\n        {\n            pineDist = pineGroundDist - 15.0;\n        }\n        else\n        {\n            vec3 posPine = posWS;\n            posPine.y = pineGroundDist;\n            vec2 pineId = pMod2(posPine.xz, oz.xx * 25.0);\n            posPine .xz += hash22(pineId * 17.12) * 10.0;\n            pineDist = fCone(posPine, 2.0, 15.0 + 4.0 * hash12(pineId * 17.12));\n\n            posPine = posWS + oz.xxx * 12.5;\n            posPine.y = pineGroundDist;\n            pineId = pMod2(posPine.xz, oz.xx * 15.0);\n            posPine .xz += hash22(pineId * 17.12) * 5.0;\n            pineDist = min(pineDist, fCone(posPine, 2.0, 10.0 + 2.0 * hash12(pineId * 17.12)));\n        }\n        \n        if( pineDist < minDist)\n        {\n            minDist = pineDist;\n            material = vec4(kMatPines, pineGroundDist, mountainNoise, 1.0);\n        }\n    }\n\t\n    \n    if(filterId != kShadowMapFilter && \n       distantGroundDist < minDist)\n    {\n        minDist = distantGroundDist;\n        material = vec4(kMatMountains, 1.0, mountainNoise, pineDist);\n    }\n    \n    return minDist;\n}\n\nfloat fSDF(vec3 p, sampler2D noiseSampler)\n{\n    vec4 mat;\n    return fSDF(p, kRenderFilter, noiseSampler, mat);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Lighting\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nvec3 getSky(vec3 rayDirWS, float roughness, out vec3 transmittance)\n{\n    float r = max(0.0001, (rayDirWS.y + 0.1)/1.1);\n    float cosineLobeAverage = 2.0/kPI;\n    r = mix(r, cosineLobeAverage, roughness);\n    \n    float normalisedTravelledDensity = exp(-r)/r;\n    \n\tfloat rayDotSun = dot(rayDirWS, s_dirToSunWS);\n    float sr = max(0.0001, (s_dirToSunWS.y + 0.12)/1.12);    \n    \n    float rayleighPhase = rayleighPhase(rayDotSun) / kIsotropicScatteringPhase;\n    rayleighPhase = mix(rayleighPhase, 1.0, roughness);\n        \n    vec3 rayleighTransmittance = exp(-(kRayleighScatteringCoefsKm) * kRayleighAtmHeightKm * normalisedTravelledDensity);\n    vec3 rayleighScattering = oz.xxx - rayleighTransmittance;\n    vec3 rMsCoefs = kRayleighScatteringCoefsKm * kRayleighScatteringCoefsKm * 1000.0;\n    vec3 rayleighMultipleScattering = kMultipleScatteringFakery * mix(rayleighScattering, s_averageSkyColour, 0.5);\n    \n    //Hand tweaked earth shadowing / sky darkening\n    float earthShadow = smoothstep(-0.15, 0.1, s_dirToSunWS.y + rayDotSun*0.02);\n    \n\tvec3 sunTransmittance = max(0.00025*oz.xxx, //Max to prevent the sky from being pitch black at night\n\t\tearthShadow * mix(rayleighTransmittance, oz.xxx, 0.2 + 0.8*saturate((s_dirToSunWS.y)*3.0)));\n        \n    vec3 sky = (rayleighScattering * sunTransmittance + \n                earthShadow * rayleighTransmittance * rayleighMultipleScattering) *\n        rayleighPhase;\n\n    float mieTransmittance = exp(-kMieScatteringCoefsKm*kMieAtmHeightKm*normalisedTravelledDensity);\n    float mieG = 0.75 - roughness*0.6;\n    sky = sky * mieTransmittance + henyeyGreensteinPhase_schlick(rayDotSun, mieG) / kIsotropicScatteringPhase\n        * s_cloudSunColour * earthShadow * (1.0 - mieTransmittance);\n   \n    transmittance = mieTransmittance * rayleighTransmittance;\n    return sky;\n}\n\nvec3 getSky(vec3 rayDirWS, float roughness)\n{\n    vec3 unused;\n    return getSky(rayDirWS, roughness, unused);\n}\n\nvoid initScene(vec3 eyePosWS, float time)\n{\n    s_eyePositionWS = eyePosWS;\n    s_time = time * 1.0;\n    s_dirToSunWS = normalize(vec3(0.4, 0.0, 0.5));\n    \n    float sunRotationPhase = kPI * 0.025;\n    s_timeOfDay = fract(0.5 + (s_time * sunRotationPhase / (2.0 * kPI))) - 0.5;\n    s_earthRotationRad = s_time * sunRotationPhase - sin(s_time * sunRotationPhase*2.0)*0.4;\n    \n    pR(s_dirToSunWS.yz, s_earthRotationRad);\n    \n    float sr = max(0.0001, (s_dirToSunWS.y + 0.0)/1.0);\n    \n    s_sunColour = float(USE_SUN) * exp(-kRayleighScatteringCoefsKm*kRayleighAtmHeightKm*\n        exp(-sr)/sr);\n\ts_sunRadiance = s_sunColour*5.0 / kSunDiskSolidAngle;\n\n    sr = max(0.02, (s_dirToSunWS.y + 0.01)/1.01);\n    s_cloudSunColour = float(USE_SUN) * exp(-kRayleighScatteringCoefsKm*kRayleighAtmHeightKm*\n        exp(-sr)/sr);\n        \n\ts_averageSkyColour = getSky(oz.yxy, 0.5);\n}\n\nvec3 applyAtmosphere(vec3 sceneColour, vec3 rayDirWS, float travelledDist, float shadow)\n{   \n    float rayDotSun = dot(rayDirWS, s_dirToSunWS);\n    float rayleighPhase = rayleighPhase(rayDotSun) / kIsotropicScatteringPhase;\n    \n    float r = max(0.05, (rayDirWS.y + 0.1)/1.1);\n    float normalisedTravelledDensity = exp(-r)/r;\n    \n    float distKm = min(kRayleighAtmHeightKm, travelledDist / 1000.0);\n    vec3 rayleighTransmittance = exp(-kRayleighScatteringCoefsKm*distKm*normalisedTravelledDensity);\n    \n    float sr = max(0.0001, (s_dirToSunWS.y + 0.12)/1.12);\n    \n    //Hand tweaked earth shadowing / sky darkening\n\tfloat earthShadow = smoothstep(-0.15, 0.1, s_dirToSunWS.y + rayDotSun*0.02);\n    \n\tvec3 sunTransmittance = max(0.00025*oz.xxx, //Max to prevent the sky from being pitch black at night\n\t\tearthShadow * mix(rayleighTransmittance, oz.xxx, 0.2 + 0.8*saturate((s_dirToSunWS.y)*3.0)));   \n    \n    vec3 rayleighLighting = mix(s_averageSkyColour, rayleighPhase * sunTransmittance, shadow);\n    vec3 rayleighInscatter = rayleighLighting * (oz.xxx - rayleighTransmittance);\n\n    distKm = min(kMieAtmHeightKm, travelledDist / 1000.0);\n    float mieTransmittance = exp(-kMieScatteringCoefsKm*distKm*normalisedTravelledDensity);\n    float mieG = 0.7;\n    vec3 mieLighting = mix(s_averageSkyColour, henyeyGreensteinPhase_schlick(rayDotSun, mieG) * \n        s_cloudSunColour * earthShadow * 4.0 * kPI, shadow);\n    vec3 mieInscatter = mieLighting * (1.0 - mieTransmittance);\n    \n    vec3 atmTransmittance = rayleighTransmittance*mieTransmittance;\n    vec3 atmInscatter = rayleighInscatter*mieTransmittance + mieInscatter;\n    sceneColour = sceneColour * atmTransmittance + atmInscatter;\n    \n    \n    return sceneColour;\n}\n\n\nfloat diskLight(vec3 rayDirWS, vec3 dirToLightWS,\n           float cosAngularRadius, float roughness)\n{    \n    float brdfDiskSolidAngle = 2.0*kPI*(1.0 - (cosAngularRadius-roughness*1.0));\n    float diskSolidAngle = 2.0*kPI*(1.0 - cosAngularRadius);\n    float brightness = (max(0.00001, diskSolidAngle)/max(0.00001, brdfDiskSolidAngle));\n    \n    float sharpness = 1.0 - roughness;\n\n    float vDotL = dot(rayDirWS, dirToLightWS);\n    \n    float cosRadiusStart = cosAngularRadius - 0.0001 - roughness*1.0;\n    float cosRadiusEnd = cosAngularRadius + 0.0001 + roughness*1.0;\n    float diskVisibility = linearstep(\n        cosRadiusStart, \n        cosRadiusEnd,\n    \tvDotL)*2.0;\n    \n    float brdfPower = 7.0 - 6.0*sqrt(roughness);\n\n    diskVisibility = pow(diskVisibility, brdfPower);\n\n    //Integral S = (x^n dx) is F = x^(n+1) * 1/(n+1)\n    //Integral over range [A, B] is F(B) - F(A)\n    float powIntegral = 1.0/(brdfPower + 1.0);\n\tfloat normalisationFactor = powIntegral;\n    //Renormalize\n    diskVisibility /= max(0.00001, normalisationFactor);\n    \n    diskVisibility = min(1.0, diskVisibility * brightness);\n\n    return diskVisibility;\n}\n\nvec3 getSun(vec3 rayDirWS, vec3 normalWS, float roughness)\n{\n    float sharpness = 1.0 - roughness;\n\n    float vDotL = dot(rayDirWS, s_dirToSunWS);\n    \n    vec3 sunDisk = diskLight(rayDirWS, \n                             s_dirToSunWS, kCosSunRadius, roughness)\n        * s_sunRadiance;\n    \n    float bloomBlend = linearstep(\n        kCosSunRadius - (1.0 - kCosSunRadius)*10.0 - roughness * 1.0,\n        kCosSunRadius + roughness * 1.0,\n        vDotL);\n    \n    sunDisk += pow(bloomBlend, 4.0) * s_sunColour * 2.0 * sharpness;\n    return sunDisk;\n}\n\nvec3 getSkyAndSun(vec3 rayDirWS)\n{\n    vec3 sky = getSky(rayDirWS, 0.0);\n    sky += getSun(rayDirWS, s_dirToSunWS, 0.0);\n    \n    return sky;\n}\n\nvec3 computeSphereLighting(vec3 posWS, vec3 coneDirWS, float roughness, vec4 lightSphere, vec3 colour,\n                      out float visibility)\n{\n    vec3 posToSphereWS = lightSphere.xyz - posWS;\n    float distToSphereCenter = length(posToSphereWS);\n    float sqDistToSphere = distToSphereCenter * distToSphereCenter;\n    float sqSphereRadius = lightSphere.a * lightSphere.a;\n    \n    float distToDisk = (1.0/max(0.001, distToSphereCenter)) * max(0.001, sqDistToSphere - sqSphereRadius);\n    float diskRadius = (lightSphere.a/distToSphereCenter)*sqrt(max(0.001, sqDistToSphere - sqSphereRadius));\n    \n    float cosSphereAngularRadius = clamp(distToDisk/sqrt(distToDisk*distToDisk + \n                                        diskRadius*diskRadius), -1.0, 1.0);\n    vec3 posToSphereDirWS = posToSphereWS/distToSphereCenter;\n    \n    float sphereLighting = diskLight(coneDirWS, posToSphereDirWS, \n                                     cosSphereAngularRadius, roughness);\n    \n    //The point to light can be inside the sphere, blend to 1.0 at the center\n    sphereLighting = mix(1.0, sphereLighting, min(1.0, sqDistToSphere/sqSphereRadius));\n    \n\tvisibility = sphereLighting;\n    \n    return colour * sphereLighting;\n}\n\nvec3 computeLighting(vec3 posWS, vec3 rayDirWS, vec3 normalWS, float roughness, float ambientVis, float shadow)\n{\n    vec3 lightingConeDirWS = normalize(mix(rayDirWS, normalWS, roughness*roughness*0.75));\n    \n    vec3 sky = getSky(lightingConeDirWS, roughness);\n\n    vec3 ambient = sky;\n    \n#if USE_ATM\n    vec3 skyUpColour = s_averageSkyColour;\n#else\n    vec3 skyUpColour = getSky(oz.yxy, 1.0);\n#endif        \n    \n    vec4 treeSphere = vec4(kTreePosWS + oz.yxy * 9.5, 5.5);\n    \n    vec3 groundPosWS = posWS + lightingConeDirWS * (posWS.y/max(0.0001, -lightingConeDirWS.y));\n    \n    float treeShadow;\n    computeSphereLighting(groundPosWS, s_dirToSunWS, roughness, vec4(treeSphere.xyz, treeSphere.a + 2.0), oz.yyy, treeShadow);\n    vec3 vecToTreePosWS = posWS - kTreePosWS;\n    vec3 treeLeavesAlbedo = vec3(0.5, 0.0075, 0.005);\n    \n    vec3 sunLight = smoothstep(0.05, 0.15, s_dirToSunWS.y) * s_sunColour;\n    vec3 groundAlbedo = vec3(0.005, 0.35, 0.015);\n\n    vec3 groundColour = (groundAlbedo * 0.63 + 0.04) * ((1.0 - treeShadow) * sunLight + skyUpColour);\n    ambient = mix(ambient, groundColour, \n                  smoothstep(0.001+roughness*1.5, -0.001-roughness*1.5, lightingConeDirWS.y));\n\n\t//Fallen leaves lighting\n    {\n        vec3 leavesCenterWS = kTreePosWS - oz.yxy * 0.5;\n        vec3 posToDiskCenterWS = leavesCenterWS - posWS;\n        vec3 posToDiskCenterDirWS =  normalize(posToDiskCenterWS);\n\n        vec3 leavesLighting = treeLeavesAlbedo * (0.35 * (1.0 - treeShadow) * sunLight + skyUpColour);\n\n        float diff = linearstep(-1.0 + min(1.0, -posToDiskCenterWS.y/10.0), \n                                0.0 + min(1.0, -posToDiskCenterWS.y/10.0), \n                                dot(posToDiskCenterDirWS, lightingConeDirWS));\n        diff *= 1.0 - min(1.0, dot(posToDiskCenterWS, posToDiskCenterWS)/150.0);\n        ambient *= 1.0 - diff;  \n        ambient += diff * leavesLighting;           \n    }\n    \n    float sphereVisibility;\n    vec3 sphereLight = computeSphereLighting(posWS, lightingConeDirWS, roughness, \n                                         treeSphere, treeLeavesAlbedo * (skyUpColour + 0.5 * sunLight), \n                                         sphereVisibility);\n    ambient *= mix(1.0 - sphereVisibility, 1.0, 0.0*roughness);\n    ambient += sphereLight;\n    \n    ambient *= ambientVis;\n    ambient += getSun(lightingConeDirWS, normalWS, roughness) * shadow;\n\n    return ambient;\n}\n\nvec3 computeLighting(vec3 posWS, vec3 rayDirWS, vec3 normalWS, float roughness)\n{\n    return computeLighting(posWS, rayDirWS, normalWS, roughness, 1.0, 1.0);\n}\n\n\n/////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////\n//////////////////////////// Cameras ////////////////////////////////\n/////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////\n\nconst float kCameraPlaneDist = 1.35;\n\nfloat s_pixelConeWithAtUnitLength = 0.0;\n\nvec2 getScreenspaceUvFromRayDirectionWS(\n    vec3 rayDirectionWS,\n\tvec3 cameraForwardWS,\n\tvec3 cameraUpWS,\n\tvec3 cameraRightWS,\n\tfloat aspectRatio)\n{\n    vec3 eyeToCameraPlaneCenterWS = cameraForwardWS * kCameraPlaneDist;\n    // project rayDirectionWs onto camera forward\n    float projDist                 = dot(rayDirectionWS, cameraForwardWS);\n    vec3  eyeToPosOnCameraPlaneWS = rayDirectionWS / projDist * kCameraPlaneDist;\n    vec3  vecFromPlaneCenterWS       = eyeToPosOnCameraPlaneWS - eyeToCameraPlaneCenterWS;\n\n    float xDist = dot(vecFromPlaneCenterWS, cameraRightWS);\n    float yDist = dot(vecFromPlaneCenterWS, cameraUpWS);\n    \n    xDist /= aspectRatio;\n    xDist = xDist * 0.5 + 0.5;\n    yDist = yDist * 0.5 + 0.5;\n\n    return vec2(xDist, yDist);\n}\n\nvoid computeCamera(float time, vec2 mouseNorm, vec4 iMouse, vec2 iResolution,\n                   out vec3 rayOriginWS,\n                   out vec3 cameraForwardWS,\n                   out vec3 cameraUpWS,\n                   out vec3 cameraRightWS\n                  )\n{\n\ts_pixelConeWithAtUnitLength = (1.0 / iResolution.y) / kCameraPlaneDist;\n\n    rayOriginWS = vec3(-17.8, 2.0, -9.07);\n    \n\tvec3 lookAtTarget = vec3( 0.0, 5.0, 0.0);\n\t\n    cameraForwardWS = normalize(lookAtTarget - rayOriginWS);\n\n    cameraRightWS = normalize(cross(oz.yxy, cameraForwardWS));\n    cameraUpWS = normalize(cross(cameraForwardWS, cameraRightWS));\n}\n\n/////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////\n//////////////////////// Shadow mapping /////////////////////////////\n/////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////\n\nconst float kShadowMapRangeWS = 14.0;\n\nvec3 getShadowForwardDirWS(vec3 dirToSunWS)\n{\n    vec3 shadowPlaneForwardWS = dirToSunWS;\n    shadowPlaneForwardWS.y = max(0.005, shadowPlaneForwardWS.y);\n    shadowPlaneForwardWS = normalize(shadowPlaneForwardWS);\n    \n    return shadowPlaneForwardWS;\n}\n\nvec3 getShadowUvFromPosWS(vec3 posWS)\n{\n    vec3 shadowPlaneForwardWS = getShadowForwardDirWS(s_dirToSunWS);\n    vec3 shadowPlaneRightWS = normalize(cross(oz.yxy, shadowPlaneForwardWS));\n    vec3 shadowPlaneUpWS = cross(shadowPlaneForwardWS, shadowPlaneRightWS);\n    \n    vec3 shadowPlaneCenterWS = kTreePosWS + oz.yxy * 7.0 - oz.xyy * 4.0;   \n    \n    vec3 centerToPosWS = posWS - shadowPlaneCenterWS;\n    \n    vec3 uvSNorm;\n    uvSNorm.x = dot(centerToPosWS, shadowPlaneRightWS);\n    uvSNorm.y = dot(centerToPosWS, shadowPlaneUpWS);\n    uvSNorm.z = dot(shadowPlaneForwardWS, centerToPosWS);\n    \n    uvSNorm /= kShadowMapRangeWS;\n    \n    return vec3(uvSNorm.xy * 0.5 + 0.5*oz.xx, uvSNorm.z);\n}\n\nvec3 uvSNormToShadowRayStartWS(vec2 uvSNorm, vec3 shadowPlaneForwardWS)\n{   \n    vec3 shadowPlaneRightWS = normalize(cross(oz.yxy, shadowPlaneForwardWS));\n    vec3 shadowPlaneUpWS = cross(shadowPlaneForwardWS, shadowPlaneRightWS);\n    \n    vec3 rayStartWS = kTreePosWS + oz.yxy * 7.0 - oz.xyy * 4.0 +\n        (uvSNorm.x * shadowPlaneRightWS + uvSNorm.y * shadowPlaneUpWS) * kShadowMapRangeWS;\n    \n    return rayStartWS;\n}\n", "buffer_a_code": "//   __  _                 _                                           \n//  / _\\| |__    __ _   __| |  ___ __      __  _ __ ___    __ _  _ __  \n//  \\ \\ | '_ \\  / _` | / _` | / _ \\\\ \\ /\\ / / | '_ ` _ \\  / _` || '_ \\ \n//  _\\ \\| | | || (_| || (_| || (_) |\\ V  V /  | | | | | || (_| || |_) |\n//  \\__/|_| |_| \\__,_| \\__,_| \\___/  \\_/\\_/   |_| |_| |_| \\__,_|| .__/ \n//                                                              |_|    \n\n\n#define ITER_SHADOW 128\nfloat marchShadow(vec3 rayOriginWS, vec3 rayDirWS, float t, float mt, out float lastDist)\n{\n    float d;\n    float minVisibility = 1.0;\n    lastDist = 100.0;\n    \n    vec4 material;\n    \n    for(int i = NON_CONST_ZERO; i < ITER_SHADOW && t < mt; ++i)\n    {\n        float coneWidth = max(0.00001, kTanSunRadius * t);\n        \n        vec3 posWS = rayOriginWS + rayDirWS*t;\n        d = fSDF(posWS, kShadowMapFilter, iChannel2, material);\n        \n        float stepMinVis = (d) / max(0.0001, coneWidth * 0.5);\n        if(stepMinVis <= minVisibility)\n        {\n            minVisibility = stepMinVis;\n            lastDist = t;\n        }\n        \n        t += max(0.01, d);           \n        \n        if(minVisibility < 0.01)\n        {\n            minVisibility = 0.0;\n        }\n    }\n      \n    return smoothstep(0.0, 1.0, minVisibility);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvSNorm = uv * 2.0 - oz.xx;\n    \n    initScene(oz.xxx, iTime);\n        \n    vec3 shadowPlaneForwardWS = getShadowForwardDirWS(s_dirToSunWS);\n    \n\tvec3 rayStartWS = uvSNormToShadowRayStartWS(uvSNorm, shadowPlaneForwardWS);\n    \n    float offsetFromShadowPlane = min(100.0, rayStartWS.y/shadowPlaneForwardWS.y);\n    rayStartWS -= shadowPlaneForwardWS * offsetFromShadowPlane;\n    \n    float shadowDist = 0.0;\n    float shadow = marchShadow(rayStartWS, shadowPlaneForwardWS, offsetFromShadowPlane - kShadowMapRangeWS, offsetFromShadowPlane + 100., shadowDist);\n    \n    shadowDist -= offsetFromShadowPlane;\n\n    fragColor = vec4(shadow, shadowDist/kShadowMapRangeWS, 0.0, 1.0);\n}\n", "buffer_a_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//   __                                                                           _      _               \n//  / _\\  ___  ___  _ __    ___   _ __  __ _  _   _  _ __ ___    __ _  _ __  ___ | |__  (_) _ __    __ _ \n//  \\ \\  / __|/ _ \\| '_ \\  / _ \\ | '__|/ _` || | | || '_ ` _ \\  / _` || '__|/ __|| '_ \\ | || '_ \\  / _` |\n//  _\\ \\| (__|  __/| | | ||  __/ | |  | (_| || |_| || | | | | || (_| || |  | (__ | | | || || | | || (_| |\n//  \\__/ \\___|\\___||_| |_| \\___| |_|   \\__,_| \\__, ||_| |_| |_| \\__,_||_|   \\___||_| |_||_||_| |_| \\__, |\n//                                            |___/                                                |___/ \n\nfloat fMaterialSDF(vec3 samplePosWS, float dist, vec4 material)\n{\n    if(abs(material.x - kMatMountains) < 0.1)\n    {\n        vec2 uv = samplePosWS.xz * 0.0015;\n       \tfloat mountainNoise = noiseFbm(uv / material.y, iChannel2);\n        \n        dist -= mountainNoise * 5.0 * material.y;\n    }\n    else if(abs(material.x - kMatMapleBark) < 0.1)\n    {\n        float progressAlongBranch = material.w;\n        float u = material.z/kPI;\n\n        vec2 branchUv = vec2(u * 0.5, progressAlongBranch * 0.5);\n\n        dist -= textureLod(iChannel2, branchUv, 0.0).r * 0.05; \n    }\n    else if(abs(material.x - kMatPines) < 0.1)\n    {\n        float pineGroundDist = material.y;\n        float mountainNoise = material.z;\n        dist -= sin(pineGroundDist*kPI)*0.5*(1.0 - pineGroundDist/20.0);\n    }\n    return dist;\n}\n\nvec3 getNormalWS(vec3 p, float dt)\n{\n    vec3 normalWS = oz.yyy;\n    for( int i = NON_CONST_ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        vec3 samplePosWS = p + e * dt;\n        vec4 mat;\n        float dist = fSDF(samplePosWS, kRenderFilter, iChannel2, mat);\n        normalWS += e*fMaterialSDF(samplePosWS, dist, mat);\n    }\n    return normalize(normalWS);    \n}\n\nfloat sampleShadowMap(vec3 p, float startOffset)\n{\n    float shadowMapRangeWS = 14.0;\n    \n    vec3 uv_depth = getShadowUvFromPosWS(p);\n    \n    vec2 shadow_depth = textureLod(iChannel1, uv_depth.xy, 0.0).xy;\n    \n    if(shadow_depth.y > (uv_depth.z + startOffset / kShadowMapRangeWS))\n    {\n        return shadow_depth.x;\n    }\n    else\n    {\n        return 1.0;\n    }\n}\n\nfloat globalShadow(vec3 posWS, vec3 rayDirWS)\n{    \n    float softness = 0.01;\n    \n    // Far left\n    float scale = 1.65;\n    vec3 moutainPosWS = scale*vec3(300.0, -100.0, 1400.0);\n    moutainPosWS += scale*vec3(-200.0, 100.0, 0.0);\n    float mountainShadow = sphSoftShadow(posWS, rayDirWS, moutainPosWS, scale*600.0 * 0.85, softness);\n\n    // A bit to the right\n    scale = 2.7;\n    moutainPosWS = scale*vec3(600.0, -100.0, 1000.0);\n    moutainPosWS += scale*vec3(-50.0, 0.0, 0.0);\n    mountainShadow *= sphSoftShadow(posWS, rayDirWS, moutainPosWS, scale*500.0 * 0.6, softness);\n\n    scale = 4.45;\n    moutainPosWS = scale*vec3(1000.0, -200.0, 900.0);\n    mountainShadow *= sphSoftShadow(posWS, rayDirWS, moutainPosWS, scale*500.0 * 0.7, softness);\n\n    return mountainShadow;;\n   \n}\n\nfloat getShadow(vec3 p, vec3 sd)\n{\n\treturn sampleShadowMap(p, 0.1);\n}\n\nfloat cloudNoiseFbm(vec2 uv)\n{\n    float maxNoise = 0.0;\n    float noise = 0.0;\n    \n    float amplitude = 1.0;\n    float scale = 1.0;\n    \n    vec2 windOffset = oz.yy;\n    \n    for(int i = NON_CONST_ZERO; i < 7; ++i)\n    {\n        windOffset += s_time/scale * 0.0015 * kWindVelocityWS.xz;\n        \n        noise += amplitude * textureLod(iChannel2, uv*scale - windOffset, 0.0).r;\n    \tmaxNoise += amplitude;\n    \tamplitude *= 0.5;\n        scale *= 2.0;\n    }\n    \n    return noise / maxNoise;\n}\n\nvec3 computeFinalLighting(float marchedDist, vec3 rayOriginWS, vec3 rayDirWS,\n                          vec4 material)\n{    \n    vec3 endPointWS = rayOriginWS + rayDirWS * marchedDist;\n\n    vec3 sceneColour = oz.yyy;\n    \n    if(marchedDist < kMaxDist)\n    {\n        float coneWidth = max(0.001, s_pixelConeWithAtUnitLength * (marchedDist - 10.0));\n        float normalDt = coneWidth;\n        vec3 normalWS = getNormalWS(endPointWS, normalDt);\n        normalWS = fixNormalBackFacingness(rayDirWS, normalWS);\n        \n        vec3 worldShadowOffset = oz.yxy * 1000.0 * linearstep(0.1, 0.2, s_timeOfDay);\n        float worldShadow = globalShadow(endPointWS + worldShadowOffset, s_dirToSunWS);\n        float atmShadow = saturate(worldShadow + (s_dirToSunWS.y - 0.0615)*15.0);\n     \tfloat shadow = getShadow(endPointWS, s_dirToSunWS) * worldShadow;        \n        \n        vec3 albedo = oz.xyx;\n        vec3 f0Reflectance = oz.xxx * 0.04;\n        float roughness = 0.6;\n        vec4 emissive = oz.yyyy;\n        float ambientVis = 1.0;\n\n        if(abs(material.x - kMatMapleLeaf) < 0.1\n               || abs(material.x - kMatFallingMapleLeaf) < 0.1)\n        {\n            ambientVis = max(0.25, material.y);\n            shadow *= material.y;\n            \n            float inside = material.z;\n            float leafRand = floor(material.w) / 100.0;\n            float tint = min(1.0, leafRand*leafRand*0.5 + inside);\n                \n            albedo = mix(vec3(0.5, 0.0075, 0.005), vec3(0.5, 0.15, 0.005), tint*tint);\n\n            float stick = max(0.0, fract(material.w) - 0.75*inside);\n\t\t\talbedo = mix(albedo, vec3(0.2, 0.04, 0.005), stick);\n            //Backlighting\n            emissive.rgb = henyeyGreensteinPhase(dot(s_dirToSunWS, rayDirWS), 0.5)\n                * shadow * albedo * albedo * s_sunColour * (1.0 - stick) * 4.0;\n            //emissive.a = 1.0;\n            vec2 uv = material.yz;\n\n            roughness = 0.7 - stick*0.2;\n        }\n        else if(abs(material.x - kMatMapleBark) < 0.1)\n        {\n            float progressAlongBranch = material.w;\n            ambientVis = max(0.25, material.y);\n            float u = material.z;\n            \n            vec2 branchUv = vec2(u, progressAlongBranch);\n            roughness = 0.6;\n\n            albedo = vec3(0.2, 0.04, 0.005);\n        }\n        else if(abs(material.x - kMatGrass) < 0.1)\n        {\n            float normalisedHeight = material.y;\n            ambientVis = 0.15 + 0.85*material.z;\n            shadow *= min(1.0, material.z * 3.0);\n            float grassRand = material.w;\n            \n            albedo = mix(vec3(0.005, 0.35, 0.015), vec3(0.1, 0.35, 0.015), \n                         saturate(normalisedHeight*normalisedHeight + (grassRand - 0.5)));\n\n            //Backlighting\n            emissive.rgb = henyeyGreensteinPhase(dot(s_dirToSunWS, rayDirWS), 0.5)\n                * shadow * albedo * albedo * s_sunColour * 4.0 * normalisedHeight;\n            \n            roughness = 0.75;\n        }\n        else if(abs(material.x - kMatMountains) < 0.1)\n        {\n            float mountainNoise = material.z;\n            float mountainScale = material.y;\n            float detailNoise = noiseFbm(endPointWS.xz * (0.002 / mountainScale), iChannel2);\n            float noise = (detailNoise * 0.5 + mountainNoise) / 1.5;\n            float treeDist = material.w;\n            \n            albedo = 0.5*vec3(0.15, 0.025, 0.001);\n            roughness = 0.85;\n            \n            float rocks = linearstep(1.15, 1.3, detailNoise * 0.3 + noise * 0.7);\n            albedo = mix(albedo, oz.xxx * 0.1, rocks);\n            roughness = mix(0.85, 0.5, rocks);\n            \n            float snowAmount = saturate((noise - 0.5)*2.0 + (endPointWS.y - 550.0)/300.0);\n            albedo = mix(albedo, oz.xxx, snowAmount);\n            roughness = mix(roughness, 1.0, snowAmount);\n            \n            ambientVis = (0.5 + 0.5*saturate(treeDist*0.1));\n            shadow *= saturate(treeDist*0.1);\n        }\n        else if(abs(material.x - kMatPines) < 0.1)\n        {\n            float mountainNoise = material.z;\n            float bottomToTop = material.y / 20.0;\n            \n            albedo = mix(0.5*vec3(0.005, 0.15, 0.01), 0.25*vec3(0.005, 0.1, 0.05), linearstep(1.0, 1.2, mountainNoise));\n            ambientVis = (0.5 + 0.5*bottomToTop);\n            shadow *= saturate(bottomToTop * 5.0);\n            roughness = 0.85;\n        }        \n            \n        //Lighting part\n        {            \n            vec3 reflectedRayDirWS = reflect(rayDirWS, normalWS);\n            float rDotN = max(0.0001, dot(reflectedRayDirWS, normalWS));\n            vec3 fresnelReflectance = roughFresnel(f0Reflectance, rDotN, roughness);\n\n            vec3 diffuse = albedo * computeLighting(endPointWS, normalWS, normalWS, 1.0, ambientVis, shadow);\n            vec3 specular = computeLighting(endPointWS, reflectedRayDirWS, normalWS, roughness, ambientVis, shadow);\n            vec3 surfaceLighting = mix(diffuse, specular, fresnelReflectance);\n            sceneColour = surfaceLighting * (1.0 - emissive.a) + emissive.rgb;\n        }\n        \n        sceneColour = applyAtmosphere(sceneColour, rayDirWS, marchedDist, atmShadow);\n    }\n    else\n    {\n        vec3 skyColour = getSkyAndSun(rayDirWS);\n    \tsceneColour = skyColour;\n        \n        //Stars\n        float scale = 3.0;\n        vec3 stars = oz.yyy;\n        for(uint i = NON_CONST_ZERO_U; i < 4u; ++i)\n        {\n            vec3 rd = rayDirWS;\n            rd.y = max(0.0001, (rd.y + 0.5) / 1.5);\n            vec2 uv = rd.xz/rd.y;\n            uv.y += s_earthRotationRad;\n            uv += oz.xx * float(i) * kGoldenRatio;\n            \n            vec2 id = pMod2(uv, oz.xx * 0.1 * scale) + oz.xx * float(i) * kGoldenRatio;\n\n            vec2 rand = hash22(id * 73.157);\n            uv += (rand - 0.5*oz.xx) * 0.1 * scale;\n            \n            float starHeat = hash12(id * 73.157);\n            vec3 starColour = oz.xxx * 0.75 + 0.5 * hash32(id * 953.56);\n\t\t\tstarHeat *= starHeat;\n            float startFade = linearstep((0.5 + starHeat*0.5)*0.003/rd.y, 0.0, length(uv));\n            stars += startFade * startFade * starColour * 0.04 * (0.5 + starHeat*starHeat) * scale * scale;\n            \n            scale *= 0.5;\n        }\n        \n        vec3 skyTransmittance;\n        getSky(rayDirWS, 0.0, skyTransmittance);\n        stars = stars * skyTransmittance;\n        \n        float cloudPlaneInterDist = 4000.0/max(0.0001, rayDirWS.y + 0.13);\n        vec3 cloudPosWS = rayOriginWS + rayDirWS * cloudPlaneInterDist;\n        \n        float rayDotSun = dot(s_dirToSunWS, rayDirWS);\n        float earthShadow = smoothstep(-0.06, -0.04, s_dirToSunWS.y + (rayDotSun - 0.5)*0.035);\n        \n        vec2 cloudUv = fract(cloudPosWS.xz * 0.0000035); \n        vec2 cloudShadowUv = cloudUv + s_dirToSunWS.xz * 0.002; \n        \n        float cloudNoise = cloudNoiseFbm(cloudUv);\n        \n        float phase = henyeyGreensteinPhase_schlick(dot(rayDirWS, s_dirToSunWS), 0.7);\n        float cloudTransmittance = 1.0 - smoothstep(0.6, 0.7, cloudNoise);\n        float cloudShadow = 1.0 - 0.9*smoothstep(0.5, 0.8, cloudNoiseFbm(cloudShadowUv));\n        vec3 cloudInscatter = s_averageSkyColour + max(oz.xxx * 0.00035, s_cloudSunColour * earthShadow) *\n            (1.0 + phase * 1.0 * kPI) * cloudShadow;\n        \n        cloudInscatter = applyAtmosphere(cloudInscatter, rayDirWS, cloudPlaneInterDist, 1.0);\n        \n        sceneColour += stars;\n        sceneColour = sceneColour * cloudTransmittance + (1.0 - cloudTransmittance) * cloudInscatter;\n    }\n    \n    return sceneColour;\n}\n\nfloat fogNoiseFbm(vec3 uvw)\n{\n    float maxNoise = 0.0;\n    float noise = 0.0;\n    \n    float amplitude = 1.0;\n    \n    for(int i = NON_CONST_ZERO; i < 3; ++i)\n    {\n        noise += amplitude * textureLod(iChannel3, uvw, 0.0).r;\n    \tmaxNoise += amplitude;\n    \tamplitude *= 0.5;\n        uvw *= 2.0;\n    }\n    \n    return noise / maxNoise;\n}\n\n#define ITER 1024\nfloat march(vec3 rayOriginWS, vec3 rayDirWS, float rand, out vec3 sceneColour, out float responsiveness)\n{\n    float phase = 4.0 * kPI * \n        (henyeyGreensteinPhase_schlick(dot(rayDirWS, s_dirToSunWS), 0.7) + \n        kIsotropicScatteringPhase);\n        \n    vec4 material;\n    \n    vec3 inscatter = oz.yyy;\n    float transmittance = 1.0;\n    \n    float t = 0.001;\n    float d;\n    \n    for(int i = NON_CONST_ZERO; i < ITER; ++i)\n    {\n        float coneWidth = max(0.001, s_pixelConeWithAtUnitLength * (t - 10.0));\n        \n        vec3 posWS = rayOriginWS + rayDirWS*t;\n        d = fSDF(posWS, kRenderFilter, iChannel2, material);\n        \n        t += d;\n        \n        if(i >= ITER - 1)\n        {\n            t = kMaxDist;\n        }              \n        \n        if(d < coneWidth || t >= kMaxDist)\n        {\n            break;\n        }\n        \n        \n        // Add some fog at the bottom of the tree, because shadowing from leaves looks cool !\n#if 1\n        vec3 fogVolumeCenterWs = kTreePosWS - oz.yxy * 99.0;\n        float distToFogVolume = fCapsule(posWS, fogVolumeCenterWs, \n                                         fogVolumeCenterWs,\n                                         100.0);\n        float distToTree = length((kTreePosWS - s_dirToSunWS * oz.xyx * 5.0) - posWS);\n        \n        float densityBias = ( max(0.0, distToTree - 2.0) * 0.035 + 0.2 ) +\n            linearstep(0.0, 10.0, distToFogVolume);\n        \n        if(densityBias < 1.0)\n        {\n            float fogNoise = fogNoiseFbm((posWS - oz.yxy * 0.75 * s_time) * 0.025);\n            fogNoise = max(0.0, fogNoise - densityBias);\n            fogNoise = saturate(fogNoise * 2.0);\n\n            float scatteringCoef = fogNoise * 0.1;\n\n            float stepTransmittance = exp(-scatteringCoef*d);\n\n            posWS = rayOriginWS + rayDirWS*(t - d*rand);\n            float shadow = sampleShadowMap(posWS, 0.0) * linearstep(0.0575, 0.1, s_dirToSunWS.y);;\n\n                vec3 stepLighting =  s_sunColour * shadow * phase;\n            stepLighting += s_averageSkyColour;\n\n            inscatter += transmittance * (1.0 - stepTransmittance) * stepLighting;\n            transmittance *= stepTransmittance;\n        }\n#endif\n        \n    }\n      \n    sceneColour = computeFinalLighting(t, rayOriginWS, rayDirWS, material);\n    \n    sceneColour = sceneColour * transmittance + inscatter;\n    \n    responsiveness = abs(material.x - kMatFallingMapleLeaf) < 0.1 ? 1.0f : 0.0f;\n    \n    return t;\n}\n\n\nvec3 applyBloom(vec3 colour, vec2 uv, vec2 subPixelJitter)\n{\n#if 1\n    float totalWeight = 0.0;\n    vec3 bloom = oz.yyy;\n    \n    float kernel = 1.0;\n    //Super sample low mips to get less blocky bloom\n    for(float xo = -kernel; xo < kernel + 0.1; xo += 0.5)\n    {\n        for(float yo = -kernel; yo < kernel + 0.1; yo += 0.5)\n        {\n            vec2 vo = vec2(xo, yo);\n            float weight = (kernel*kernel*2.0) - dot(vo, vo);\n            vo += 0.5 * (subPixelJitter);\n            vec2 off = vo*(0.5/kernel)/iResolution.xy;\n            \n            if(weight > 0.0)\n            {\n                float maxBloom = 5.0;\n                bloom += weight * min(maxBloom*oz.xxx, textureLod(iChannel0, uv + off*exp2(5.0), 5.0).rgb);totalWeight += weight;\n                bloom += weight * min(maxBloom*oz.xxx, textureLod(iChannel0, uv + off*exp2(6.0), 6.0).rgb);totalWeight += weight;\n                bloom += weight * min(maxBloom*oz.xxx, textureLod(iChannel0, uv + off*exp2(7.0), 7.0).rgb);totalWeight += weight;\n            }\n        }\n    }\n\n    bloom.rgb /= totalWeight;\n    \n    colour.rgb = colour.rgb * 0.8 + pow(bloom, oz.xxx*1.5) * 0.3;\n#endif\n    \n    return colour;\n}\n\n\n#define TAA 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 subPixelJitter = fract(hash22(fragCoord)\n                                + float(iFrame%256) * kGoldenRatio * oz.xx) - 0.5*oz.xx;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float jitterAmount = float(TAA);\n    \n    vec2 uvJittered = (fragCoord.xy + jitterAmount * subPixelJitter) / iResolution.xy;\n    \n    float aspectRatio = iResolution.x/iResolution.y;\n    vec2 uvSNorm = uvJittered * 2.0 - vec2(1.0);\n    uvSNorm.x *= aspectRatio;\n    \n    vec2 mouseUNorm = iMouse.xy/iResolution.xy;\n    vec2 mouseNorm = mouseUNorm*2.0 - vec2(1.0);\n    \n    vec3 rayOriginWS;\n    \n    // ---- Camera setup ---- //\n    vec3 cameraForwardWS, cameraUpWS, cameraRightWS;\n    computeCamera(iTime, mouseNorm, iMouse, iResolution.xy, rayOriginWS, cameraForwardWS, cameraUpWS, cameraRightWS);\n    vec3  rayDirWS = normalize(uvSNorm.x*cameraRightWS + uvSNorm.y*cameraUpWS + kCameraPlaneDist*cameraForwardWS);\n    \n    initScene(rayOriginWS, iTime);\n    \n    // ---- TAA part ---- //  \n    float prevTime = iTime - iTimeDelta;\n    vec3 prevCameraPosWS, prevCameraForwardWS, prevCameraUpWS, prevCameraRightWS;\n    computeCamera(prevTime, mouseNorm, iMouse, iResolution.xy, prevCameraPosWS, \n                  prevCameraForwardWS, prevCameraUpWS, prevCameraRightWS);\n    \n    // ---- Render scene ---- //\n    float responsiveness;\n    vec3 sceneColour;\n    float tt = march(rayOriginWS, rayDirWS, hash12(fragCoord), sceneColour, responsiveness);\n    \n    float nightTimeStrength = linearstep(-0.15, -0.6, s_dirToSunWS.y);\n    \n    float exposure = 1.0 + nightTimeStrength*150.0;\n    sceneColour *= exposure;\n    \n    sceneColour = applyBloom(sceneColour, uv, subPixelJitter);\n        \n    // ---- Flares ---- //\n    {\n        float sunVisibility = sampleShadowMap(rayOriginWS, 0.0) * globalShadow(rayOriginWS, s_dirToSunWS);\n        float numApertureBlades = 8.0;\n\n        vec2 sunUv = getScreenspaceUvFromRayDirectionWS(s_dirToSunWS,\n                                                           cameraForwardWS, cameraUpWS, cameraRightWS, aspectRatio);\n        vec2 sunUvSNorm = sunUv * 2.0 - vec2(1.0);\n    \tsunUvSNorm.x *= aspectRatio;\n        \n        vec2 sunUvDirSNorm = normalize(sunUvSNorm);\n        \n        float rDotL = dot(rayDirWS, s_dirToSunWS);\n        \n        vec2 uvToSunSNorm = sunUvSNorm - uvSNorm;\n        float starBurst = 0.5 + 0.5*cos(1.5 * kPI + atan(uvToSunSNorm.x, uvToSunSNorm.y) * numApertureBlades);\n        float startFade = linearstep(0.97, 1.0, rDotL);\n        float starWidth = linearstep(0.5, 1.0, rDotL);\n        starBurst = pow(starBurst, max(1.0, 500.0 - starWidth*starWidth * 501.0))*startFade;\n\n        vec3 totalFlares = starBurst * 1.5 * linearstep(0.875, 1.0, rDotL*rDotL) * oz.xxx;\n\n        vec2 flareCenterUvSNorm;\n        \n        flareCenterUvSNorm = sunUvSNorm * 2.0;\n        totalFlares += 0.5 * vec3(0.1, 0.15, 0.01) * \n            linearstep(0.05, 0.0, sdOctogon(flareCenterUvSNorm - uvSNorm, 0.35));\n        \n        flareCenterUvSNorm = sunUvSNorm * 1.5;\n        totalFlares += 0.65 * vec3(0.015, 0.12, 0.09) * \n            linearstep(0.03, 0.0, sdOctogon(flareCenterUvSNorm - uvSNorm, 0.2));\n        \n        flareCenterUvSNorm = sunUvSNorm * 0.25;\n        totalFlares += 2.5 * vec3(0.1, 0.1, 0.1) * \n            linearstep(0.01, 0.0, sdOctogon(flareCenterUvSNorm - uvSNorm, 0.1));\n        \n        flareCenterUvSNorm = sunUvSNorm * 0.1;\n        totalFlares += 4.0 * vec3(0.11, 0.11, 0.1) * \n            linearstep(0.02, 0.0, sdOctogon(flareCenterUvSNorm - uvSNorm, 0.05));\n        \n        flareCenterUvSNorm = sunUvSNorm * -0.12;\n        totalFlares += 3.5 * vec3(0.15, 0.05, 0.025) * \n            linearstep(0.01, 0.0, sdOctogon(flareCenterUvSNorm - uvSNorm, 0.15));\n        \n        flareCenterUvSNorm = sunUvSNorm * -0.25;\n        totalFlares += 0.8 * vec3(0.02, 0.15, 0.1) * \n            linearstep(0.02, 0.0, sdOctogon(flareCenterUvSNorm - uvSNorm, 0.25));\n        \n        //First coloured circle\n        {\n            flareCenterUvSNorm = sunUvSNorm * 0.5;\n\n            float distToDisk = length(flareCenterUvSNorm - uvSNorm) - length(flareCenterUvSNorm * 2.0);\n            float ci = smoothstep(0.2, 0.01, abs(distToDisk));\n            float colourRamp = linearstep(-0.2, 0.2, distToDisk);\n            vec2 uvToSunDir = normalize(uvToSunSNorm);\n            vec3 repColour = wavelengthToRGB(300.0 + colourRamp * 500.0);\n\n            totalFlares += 0.25 * repColour * ci * linearstep(0.75, 1.0, dot(sunUvDirSNorm, uvToSunDir));\n        }\n        \n        //Second coloured circle\n        {\n            flareCenterUvSNorm = sunUvSNorm * 0.5;\n\n            float distToDisk = length(flareCenterUvSNorm - uvSNorm) - length(flareCenterUvSNorm * 1.6);\n            float ci = smoothstep(0.4, 0.0, abs(distToDisk));\n            float colourRamp = linearstep(-0.8, 0.8, distToDisk);\n\t\t\tvec2 uvToSunDir = normalize(uvToSunSNorm);\n            vec3 repColour = wavelengthToRGB(300.0 + colourRamp * 500.0);\n            totalFlares += 0.25 * repColour * ci * linearstep(0.98, 1.0, dot(sunUvDirSNorm, uvToSunDir));\n        }\n        \n        \n        flareCenterUvSNorm = sunUvSNorm * -1.4;\n        totalFlares += 0.8 * vec3(0.1, 0.15, 0.075) * \n            linearstep(0.015, 0.0, sdOctogon(flareCenterUvSNorm - uvSNorm, 0.17));\n        \n        \n        flareCenterUvSNorm = sunUvSNorm * -2.0;\n        totalFlares += 3.0 * vec3(0.1, 0.05, 0.02) * \n            linearstep(0.4, 0.0, sdOctogon(flareCenterUvSNorm - uvSNorm, 0.1));\n        \n        sceneColour += totalFlares * 0.2 * s_sunColour * sunVisibility * linearstep(3.2, 2.0, length(sunUvSNorm));\n    }\n    \n    vec2 prevFrameUv = uv;\n    vec4 prevData = texture(iChannel0, prevFrameUv);\n    \n    float defaultBlendToCurrent = (2.0/9.0)*max(1.0, iTimeDelta/0.066);\n    float blendedResp = mix(prevData.a, responsiveness, defaultBlendToCurrent);\n    float blendToCurrent = mix(defaultBlendToCurrent, 1.0, blendedResp);\n    //Increase TAA at night to get stars trails\n    blendToCurrent = min(1.0, mix(blendToCurrent, iTimeDelta, nightTimeStrength));\n    \n#if !TAA    \n    blendToCurrent = 1.0;\n#endif\n    \n    //Clamp to prevent the sun from leaving a trail\n    sceneColour = min(oz.xxx * 3.0, sceneColour);\n    sceneColour = max(oz.yyy, mix(prevData.rgb, sceneColour, blendToCurrent));\n    \n    fragColor = vec4(sceneColour, responsiveness);\n}", "buffer_b_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjyzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1241, 1241, 1267, 1267, 1349], [1351, 1351, 1378, 1378, 1908], [1910, 1910, 1967, 1967, 2449]], "test": "untested"}
{"id": "tdSyDz", "name": "Conics from Projective Pencils", "author": "mla", "description": "The dual of [url]https://www.shadertoy.com/view/Ws2cRh[/url] - generate conics from intersections of corresponding lines of two pencils.\n\nMouse changes correspondence and so changes the conic.", "tags": ["pencil", "conic", "projective", "loopless"], "likes": 5, "viewed": 505, "published": 3, "date": "1586422129", "time_retrieved": "2024-07-30T21:13:55.625540", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Conics as Intersections of Pencils of Lines\n// Matthew Arcus, mla, 2020\n//\n// Companion piece to https://www.shadertoy.com/view/Ws2cRh: here we\n// have a correspondence between to two pencils of lines (a pencil of\n// lines is just the set of all lines through a given point), where\n// the points of intersection of corresponding lines outline the\n// conic (corresponding lines have the same colour).\n//\n// Mouse changes the parameters of the correspondence, generating\n// different conics.\n//\n// A projective mapping of parameter t, 0 <= t < PI to the lines\n// in a pencil (as the angle with some axis) is:\n//\n// g(t) = atan(A*tan(t+B)+C)\n//\n// and since tan(t+B) =  we see that:\n//\n// g(t) = atan(A*(tan(t)+tan(B))/(1-tan(t)*tan(B))+C)\n//      = atan(f(tan(t))) where f(x) = A*(x+tan(B))/(1-x*tan(B)) + C\n// \n// (so f(x) is a 1d real Mobius tranformation: f(x) = (ax+b)/(cx+d),\n// but we have parametrized it with (A,B,C) rather than (a,b,c,d) -\n// think of stereographic projection from a circle to a line).\n//\n// Given two pencils, we can establish a correspondence with two\n// mappings g1, g2 as above, and then line g1(t) in pencil 1\n// corresponds with line g2(t) in pencil 2. Here, g1(t) is the\n// identity map, with A=1,B=C=0, and g2(t) has A = 1 and derives B and\n// C from mouse position. Only N regularly spaced lines from [0..PI]\n// are displayed.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\n\nvec3 join(vec3 p, vec3 q) {\n  // Return either intersection of lines p and q\n  // or line through points p and q, r = kp + jq\n  return cross(p,q);\n}\n\nfloat point(vec3 p, vec3 q) {\n  if (abs(p.z) <= 1e-4) return 1e8;\n  p /= p.z; q /= q.z; // Normalize\n  return distance(p.xy,q.xy);\n}\n\nfloat line(vec3 p, vec3 q) {\n  return abs(dot(p,q)/(p.z*length(q.xy)));\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat N = 50.0;\n\n// Find parameter t of the nearest displayed line from the pencil.\n// t is actually in range [0,1)\nfloat nearestline(vec2 p, vec2 centre, vec3 mobius, out float index) {\n  float A = mobius.x, B = mobius.y, C = mobius.z;\n  p -= centre;\n  float t = p.y/p.x;\n  // Look out for infinities here\n  if (p.x == 0.0) sign(p.y)*1e4;\n  //t = atan(A*tan(t+B)+C);\n  t = A*(t+B)/(1.0-t*B)+C;\n  t = atan(t);\n  // Add time offset and round to nearest line\n  t = t/PI+0.05*iTime;\n  t *= N;\n  t = mod(round(t),N);\n  index = t;\n  t /= N;\n  return t;\n}\n\n// Make line coordinates for the line with parameter t in the given pencil.\nvec3 makelinecoords(float t, vec2 centre, vec3 mobius) {\n  float A = mobius.x, B = mobius.y, C = mobius.z;\n  t -= 0.05*iTime;\n  t = (tan(t*PI)-C)/A;\n  // Infinities!\n  if (abs(t) > 1e4) t = sign(t)*1e4;\n  t = (t-B)/(1.0+t*B);\n  return join(vec3(centre,1),vec3(centre+vec2(1,t),1));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  vec2 p = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n  float scale = 3.0;\n  float A = 1.0, B = 1.4, C = -0.5;\n  if (iMouse.x > 0.0) {\n    vec2 m = (2.0*iMouse.xy - iResolution.xy)/iResolution.y;\n    B = tan(0.5*PI*m.y); // B represents angular offset\n    C = m.x; // C is linear offset\n  }\n  p *= scale;\n  vec2 centre1 = vec2(1,0);\n  vec2 centre2 = vec2(-1,0);\n  vec3 mobius1 = vec3(1,0,0);\n  vec3 mobius2 = vec3(A,B,C);\n  float index1,index2;\n  float t1 = nearestline(p,centre1,mobius1,index1);\n  vec3 l1 = makelinecoords(t1,centre1,mobius1);\n  vec3 l12 = makelinecoords(t1,centre2,mobius2);\n  vec3 p1 = join(l1,l12);\n\n  float t2 = nearestline(p,centre2,mobius2,index2);\n  vec3 l2 = makelinecoords(t2,centre2,mobius2);\n  vec3 l21 = makelinecoords(t2,centre1,mobius1);\n  vec3 p2 = join(l2,l21);\n  \n  float lwidth0 = 0.0;\n  float pwidth0 = 0.02;\n  float lwidth1 = 0.015;\n  lwidth1 = max(lwidth1,1.5*fwidth(p.x));\n  float pwidth1 = max(0.05,fwidth(p.x));\n  pwidth1 = max(pwidth1,fwidth(p.x));\n  vec3 col = vec3(0);\n  vec3 pcolor = vec3(0.8);\n  float d;\n  d = line(vec3(p,1),l2);\n  col = mix(hsv2rgb(vec3(index2/N,1,1)),col,smoothstep(lwidth0,lwidth1,d));\n  d = line(vec3(p,1),l1);\n  col = mix(hsv2rgb(vec3(index1/N,1,1)),col,smoothstep(lwidth0,lwidth1,d));\n  d = point(vec3(p,1),p1);\n  col = mix(pcolor,col,smoothstep(pwidth0,pwidth1,d));\n  d = point(vec3(p,1),p2);\n  col = mix(pcolor,col,smoothstep(pwidth0,pwidth1,d));\n  fragColor = vec4(pow(col,vec3(0.4545)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdSyDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1564, 1564, 1591, 1689, 1712], [1714, 1714, 1743, 1743, 1846], [1848, 1848, 1876, 1876, 1921], [1923, 2018, 2045, 2045, 2221], [2240, 2339, 2409, 2409, 2772], [2774, 2850, 2906, 2906, 3133], [3135, 3135, 3188, 3188, 4660]], "test": "untested"}
{"id": "wsByWz", "name": "Perlin/gradient noise explained", "author": "FabriceNeyret2", "description": "random gradients at nodes (dash)\nare multiplied by a (blue) smooth interpolation kernel ( -> red/pink, green/cyan)\nand summed to form the smooth noise function (white), \nmuch like base functions in Finite Elements Method used to form the smooth solution.", "tags": ["noise", "perlin", "gradient", "tuto", "short", "wavelet", "finiteelements", "functionbase"], "likes": 13, "viewed": 833, "published": 3, "date": "1586419260", "time_retrieved": "2024-07-30T21:13:56.594949", "image_code": "#define hash(p)   ( 2.* fract(sin( (p) * 78.233 ) * 43758.5453) -1. )\n                                                                // interpolation kernel\nfloat P(float x)  { x = clamp(x,0.,1.); return x*x*(3.-2.*x); } // = smoothstep, BTW ;-)\n\n#define draw(v,w)   max(0., w - abs(v-U.y) / fwidth(v-U.y) )    // antialiased curve y = v(x)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float Z = 1.;\n    vec2 R = iResolution.xy,\n         U = Z * ( 2.*u - R ) / R.y; \n    \n    float x = U.x + 0.*iTime, \n          i = floor(x), f = fract(x),                   // node id, local coord in cell\n         g0 = hash(i),                                  // random slopes at nodes\n         g1 = hash(i+1.),\n         K0 = P(1.-f),                                  // gradients (i.e. tangents)\n         K1 = P(f),\n         P0 = g0* f     * K0,                           // gradients * kernels\n         P1 = g1*(f-1.) * K1,\n          d = sin(62.28*f),                             // for dashs (applied to gradients)\n         c0 = max( draw(P0,1.), draw(g0* f    ,.7) *d ),// left curve + gradient in cell\n         c1 = max( draw(P1,1.), draw(g1*(f-1.),.7) *d ),// right curve + gradient in cell\n#define C(i) mod(floor((i)/2.),2.)\n          c = C(i)*c0 + C(i+1.)*c1                      // to visually separate neighbor wavelets\n              + max( draw(K0,.7) , draw(K1,.7 ));\n    \n    O = mod(i,2.) == 0.                                 // for consistant wavelet coloring \n        ? vec4( c0, c1, c, 1 )                          // draw wavelets ( in red &  green \n        : vec4( c1, c0, c, 1 );                         // + blue tint to separate from neighbors )\n    O += draw( P0+P1, 1.5 )                             // reconstructed smooth noise function\n      +  float( floor(u-R/2.).y == 0.) *d               // axis\n      + max(0., 5.-R.y/Z/2.* length( vec2(fract(x+.5)-.5, U.y)) ); // nodes\n    //+ .2* step(abs(U.y),1.);                          // [-1,1] range in grey\n    \n    O = pow(O, vec4(1./2.2) );                          // to sRGB\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsByWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[134, 158, 177, 177, 221]], "test": "untested"}
{"id": "wdByWz", "name": "noise_screen", "author": "AHS1222", "description": "asdf", "tags": ["noise"], "likes": 1, "viewed": 288, "published": 3, "date": "1586415572", "time_retrieved": "2024-07-30T21:13:57.592283", "image_code": "float hash( float n )\n{\n\treturn fract( sin(n)*500000.);\n}\n\nfloat noise( vec2 p )\n{\n\treturn hash( p.x + p.y * 40.*iTime*.2 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat n = noise(uv);\n\tfragColor = vec4(vec3(n),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdByWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 57], [59, 59, 82, 82, 126], [128, 128, 185, 185, 283]], "test": "untested"}
{"id": "wdScDR", "name": "HW-Filtering Precision Test", "author": "TinyTexel", "description": "left: hardware | right: manual\nEven when sampling from float textures hardware filtering is a low-precision operation.", "tags": ["filtering"], "likes": 6, "viewed": 607, "published": 3, "date": "1586412447", "time_retrieved": "2024-07-30T21:13:58.533765", "image_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n/*\n    left: hardware | right: manual\n    Even when sampling from float textures hardware filtering is a low-precision operation.\n    https://iquilezles.org/articles/hwinterpolation\n\n    https://twitter.com/adamjmiles/status/1248190466090323968\n*/\n\nfloat cubic(float x) { return x*x*(3.0-2.0*x); }\n\nfloat Read(vec2 uv)\n{\n    float v = texelFetch(iChannel0, ivec2(uv), 0).x;\n\n    return v;\n}\n\n  //  #define EMULATE_LOW_PRECISION\n\nfloat texLoad(vec2 tex)\n{\n    vec2 uv = tex * iResolution.xy;\n    \n    uv += 0.5;\n    \n    vec2 uvI = floor(uv);\n    vec2 uvF = fract(uv);\n\n#ifdef EMULATE_LOW_PRECISION\n    {\n        float s = 256.0;\n        uvF = round(uvF * s) / s;\n    }\n#endif\n    \n    float v = mix(mix(Read(uvI + vec2(0.0, 0.0)), Read(uvI + vec2(1.0, 0.0)), uvF.x),\n                  mix(Read(uvI + vec2(0.0, 1.0)), Read(uvI + vec2(1.0, 1.0)), uvF.x), uvF.y);\n    \n#ifdef EMULATE_LOW_PRECISION\n    {\n        float s = 256.0;\n        v = floor(v * s) / s;\n    }\n#endif\n    \n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 uv0 )\n{\n\tvec2 tex = uv0.xy / iResolution.xy;\n    vec2 tex2= tex * 0.004+0.008;\n    \n#if 0\n    // quantize uvF\n    {\n        vec2 uv = tex2 * iResolution.xy;\n        vec2 uvI = floor(uv);\n        vec2 uvF = fract(uv);\n        {\n            float s = 16.0;\n            uvF = round(uvF * s) / s;\n        }        \n        tex2 = (uvI + uvF) / iResolution.xy;\n    }\n#endif\n\n    vec3 col = textureLod(iChannel0, tex2, 0.0).rgb;\n    \n    if(tex.x > 0.5)\n    col = vec3(texLoad(tex2));\n    \n    //col = vec3(col.r > 0.5 ? 1.0 : 0.0);\n\tfor(float i = 0.0; i < 9.0; ++i)\n    col = vec3(cubic(col.r));\n    \n#if 0\n    // vis error\n    {\n        vec3 col2 = vec3(texLoad(tex2));\n        \n        for(float i = 0.0; i < 9.0; ++i)\n        col2 = vec3(cubic(col2.r));\n        \n        col = col.r != col2.r ? vec3(1.0) : vec3(0.0);\n        //col = vec3(abs(col.r - col2.r) * exp2(22.0));\n    }\n#endif\n\n    //fragColor = vec4(pow(col, vec3(1.0/2.2)), 0.0);\n    fragColor = vec4(col, 0.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    uvec2 uv2 = uvec2(uv0);\n    \n    vec3 col = vec3(((uv2.x ^ uv2.y) & 1u) == 0u ? 1.0 : 0.0);\n    //col = vec3((uv2.y & 1u) == 0u ? 1.0 : 0.0);\n    \n    outCol = vec4(col, 1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdScDR.jpg", "access": "api", "license": "cc0-1.0", "functions": [[318, 318, 340, 340, 366], [368, 368, 389, 389, 459], [498, 498, 523, 523, 1058], [1060, 1060, 1111, 1111, 2077]], "test": "untested"}
{"id": "wdBcWR", "name": "My First Simple Raytracer Shader", "author": "mrmcsoftware", "description": "Here's a raytracer I wrote which is a GLSL version of a trimmed down C version of my C raytracer (trimmed down version was the basis for my assembly language versions (my own CPU design and x86)) - except no reflection/refraction (no recursion in GLSL).", "tags": ["raytracer", "animation"], "likes": 0, "viewed": 330, "published": 3, "date": "1586404606", "time_retrieved": "2024-07-30T21:13:59.409423", "image_code": "//#version 130\n//#extension GL_EXT_gpu_shader4 : enable\n//#define GAMMAC 1.0/2.2   // Uncomment this line to apply gamma correction\n#define SPEED 4.0  // speed adjustment - MODIFY AS NEEDED\n\n#define SMALL .001\n#define SMALL3 .000001\n\n#define SPHERE 0\n#define PLANE 1\n#define LIGHT 2\n\nstruct Ray\n\t{\n\tvec3 p;\n\tvec3 v;\n\t};\n\nstruct Rgb\n\t{\n\tfloat r,g,b;\n\t};\n\nstruct View\n\t{\n\tvec3 e,a,u;\n\t};\n\nstruct Light\n\t{\n\tvec3 p;\n\tfloat k,dist,r;\n\tRgb i;\n\t};\n\nstruct Info\n\t{\n\tvec3 v1,v2,v3,v4;\n\tfloat f1,f2,f3;\n\t};\n\nstruct Object\n\t{\n\tint type,id;\n\tRgb amb,diff,spec,tran;\n\tfloat ka,ks,kd,kn,kr,kt,n;\n\tInfo info;\n\t};\n\nstruct Hit\n\t{\n\tObject object;\n\tvec3 normal,pt;\n\tfloat t;\n\tRgb col;\n\t};\n\n#define MAXFLOAT\t3.37E+38\n\nView V;\nint xres,yres;\nint CXc,CYc,xc,yc;\nRgb bg=Rgb(0.0,0.0,0.0),ambient;\nint numlights=0;\nLight light[2];\nint numobj=0;\nObject objs[10];\nint maxlevel=0; // fix it (can't do recursion in GPU)\nfloat ka=.15,ks=.10,kd=.415,kn=8.0,kr=0.0,textoff=32.0,gn=1.0,ior,kt=0.0;\nRgb diff,spec,tran;\nHit hit;\nvec3 pol[3];\nfloat flengthx=1150.0,flengthy=1150.0,min_weight=.05;\nvec3 dir,right;\nInfo infoblank;\nRgb gat;\nfloat gt;\nvec3 gpt;\n\nRgb trace(Ray,int);\nvoid pushobj(int,Info);\n\n/* I'll use GLSL's functions instead, but these do work */\n/*\n\nfloat Dot(vec3 v1,vec3 v2)\n{\nfloat f;\n\nf=v1.x*v2.x+v1.y*v2.y+v1.z*v2.z;\nreturn(f);\n}\n\nfloat Mag(vec3 v1)\n{\nfloat d;\n\nd=sqrt(v1.x*v1.x+v1.y*v1.y+v1.z*v1.z);\nreturn(d);\n}\n\nvec3 Normalize(vec3 v1)\n{\nfloat d;\nvec3 res;\n\nd=sqrt(v1.x*v1.x+v1.y*v1.y+v1.z*v1.z);\nres.x=v1.x/d;\nres.y=v1.y/d;\nres.z=v1.z/d;\nreturn(res);\n}\n\nvec3 CrossProduct(vec3 v2,vec3 v3)\n{\nvec3 res;\n\nres.x=v2.y*v3.z-v2.z*v3.y;\nres.y=v2.z*v3.x-v2.x*v3.z;\nres.z=v2.x*v3.y-v2.y*v3.x;\nreturn(res);\n}\n\n*/\n\nbool sphereinter(Object obj,Ray ray)\n{\nfloat a,b,c,d,spht0,spht1,t;\nvec3 P;\n\nP=ray.p-obj.info.v1;\nc=dot(P,P)-obj.info.f1*obj.info.f1;\nb=2.0*dot(ray.v,P);\na=dot(ray.v,ray.v);\nd=b*b-4.0*a*c;\nif (d<=0.0) { return(false); }\nd=sqrt(d);\nif (a==0.0) { return(false); }\nspht0=(-b+d)/(a+a);\nspht1=(-b-d)/(a+a);\nif ((spht1<spht0)&&(spht1>SMALL)) t=spht1;\nelse t=spht0;\nif (t>SMALL)\n\t{\n\tgpt=P+t*ray.v;\n\tgt=t;\n\treturn(true);\n\t}\nreturn(false);\n}\n\nvec3 spherenorm(Object obj,Ray ray)\n{\nvec3 n,pt;\n\nn=gpt;\ngpt+=obj.info.v1;\nn=normalize(n);\nreturn(n);\n}\n\nbool triinter(Object obj,Ray ray)\n{\nfloat in1,in2,f1,t;\n\nf1=dot(obj.info.v3,ray.v);\nif (abs(f1)<SMALL) return(false);\nin1=obj.info.f3;\nin2=dot(obj.info.v3,ray.p);\nt=(in1-in2)/f1;\nif (t<SMALL) return(false); /* ?? */\ngpt=ray.p+t*ray.v;\nreturn(true);\n}\n\nvec3 trinorm(Object obj,Ray ray)\n{\nvec3 n,pt;\n\nreturn(obj.info.v3);\n}\n\nvoid planarobj(int t)\n{\nInfo info;\n\ninfo=infoblank;\ninfo.v1=pol[1]-pol[0];\ninfo.v2=pol[2]-pol[0];\ninfo.v3=cross(info.v1,info.v2);\ninfo.v3=normalize(info.v3);\ninfo.v4=pol[0];\ninfo.f1=dot(info.v1,info.v1);\ninfo.f2=dot(info.v2,info.v2);\ninfo.f3=dot(info.v3,info.v4);\npushobj(t,info);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\nInfo info;\nfloat r,g,b;\nRay eye_ray;\nfloat xf,yf;\nRgb col;\n\nnumobj=0;\nV.a=vec3(0,0,0);\nV.e=vec3(1,10,20);\nV.u=vec3(0,1,0);\nCXc=(xres/2); CYc=(yres/2);\ndir=V.a-V.e;\ndir=normalize(dir);\nright=cross(V.u,dir);\nright=normalize(right);\nV.u=cross(dir,right);\nV.u=normalize(V.u);\n\n\t/* magenta sphere */\nka=.1; ks=0.0; kd=.6; kn=40.0; ambient=Rgb(.99,.99,.99);\nspec=Rgb(255.0,255.0,255.0);\nks=.5;\ninfo.v1=vec3(1.0,1.0,0.0); info.f1=1.0;\ndiff=Rgb(255.0,0.0,255.0);\nkr=.5;\npushobj(SPHERE,info);\n\t/* green sphere */\nks=0.0;\ninfo.v1=vec3(-1.0,1.0,2.0);\ndiff=Rgb(0.0,255.0,0.0);\nkt=1.0; /*.58;*/ ior=1.75; kd=.07; ks=.4; kr=.26; /*0;*/ /*.1;*/ kn=100.0;\ntran=Rgb(0.0,255.0,0.0);\nka=0.0;\n/* adjust to no refraction possible */\nkt=0.0; ka=.1; kd=.6;\npushobj(SPHERE,info);\n\t/* yellow sphere */\nkt=0.0; kd=.6; ks=0.0; /*.5;*/ kr=.5; kn=40.0;\nka=.1;\ninfo.v1=vec3(.75,1.0,3.25);\ndiff=Rgb(255.0,255.0,0.0);\npushobj(SPHERE,info);\n\t/* light 1 */\nlight[numlights].p=vec3(-2.0,6.0,8.0);\nlight[numlights].i=Rgb(.2,.2,.2);\nlight[numlights].k=0.0; light[numlights].dist=9.0; light[numlights].r=.25;\n//normalize(light[numlights].p); light[numlights].r=0;\ninfo.v1=light[numlights].p;\ninfo.f1=light[numlights].r;\npushobj(LIGHT,info);\nnumlights++;\n\t/* light 2 */\nlight[numlights].p=vec3(2.0,8.0,7.0);\nlight[numlights].i=Rgb(.99,.99,.99);\nlight[numlights].k=0.0; light[numlights].dist=9.0; light[numlights].r=.25;\n//normalize(light[numlights].p); light[numlights].r=0;\ninfo.v1=light[numlights].p;\ninfo.f1=light[numlights].r;\npushobj(LIGHT,info);\nnumlights++;\n\t/* plane */\ndiff=Rgb(255.0,255.0,255.0); ks=.8; kd=.4;\npol[0]=vec3(0.0,0.0,0.0);\npol[1]=vec3(0.0,0.0,1.0);\npol[2]=vec3(1.0,0.0,0.0);\n//kr=0;\nplanarobj(PLANE);\n\n\t/* adjust movements through time */\nfloat iGlobalTime=iTime-1.0;\nif (iGlobalTime<0.0) { iGlobalTime=0.0; }\niGlobalTime*=SPEED;\n//iGlobalTime=0.0;\nobjs[0].info.v1+=vec3(0,0,(iGlobalTime)*.2);\nobjs[1].info.v1+=vec3((iGlobalTime)*-.1,0,0);\nobjs[2].info.v1+=vec3((iGlobalTime)*.2,0,0);\nlight[1].p+=vec3((iGlobalTime)*-1.0,0,0);\n\nCXc=int(iResolution.x/2.0);\nCYc=int(iResolution.y/2.0);\nvec2 q=fragCoord.xy;\nq.y=iResolution.y-q.y-1.0;\nxc=int(q.x); yc=int(q.y);\nflengthx=flengthy=iResolution.y/1.5*750.0/256.0;\n//flengthx=flengthy=150.0/256.0*5.0;\nxf=float(CXc-xc)/flengthx;\nyf=float(CYc-yc)/flengthy;\neye_ray.v=dir+xf*right+yf*V.u;\neye_ray.p=V.e;\ncol=trace(eye_ray,0);\nr=clamp(col.r/255.0,0.0,1.0);\ng=clamp(col.g/255.0,0.0,1.0);\nb=clamp(col.b/255.0,0.0,1.0);\n#ifdef GAMMAC\nr=pow(r,GAMMAC);\ng=pow(g,GAMMAC);\nb=pow(b,GAMMAC);\n#endif\nfragColor=vec4(r,g,b,1);\n}\n\nfloat shadow(Object obj,vec3 p,vec3 vv,float vd)\n{\nRay v;\nfloat t;\nint j;\nbool i;\n\nv.p=p;\nv.v=vv;\nfor (j=0;j<numobj;j++)\n\t{\n\tObject ptr=objs[j];\n\tif ((ptr.id!=obj.id)&&(ptr.type!=LIGHT)&&(ptr.type!=PLANE))\n\t\t{\n\t\tif (ptr.type==SPHERE) { i=sphereinter(ptr,v); }\n\t\telse { i=false; }\n\t\tif (i)\n\t\t\t{\n\t\t\tif (t<vd)\n\t\t\t\t{\n\t\t\t\tif (ptr.kt<min_weight) { return(0.0); }\n\t\t\t\tgat.r*=ptr.kt*ptr.tran.r/255.0;\n\t\t\t\tgat.g*=ptr.kt*ptr.tran.g/255.0;\n\t\t\t\tgat.b*=ptr.kt*ptr.tran.b/255.0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nreturn(1.0);\n}\n\nRgb shade(Ray ray,Object obj,vec3 N,vec3 pt,int level)\n{\nRgb color,dcol;\nfloat t2,f;\nfloat t,t3;\nint i;\nvec3 L,ipoint;\nRay R,T;\nfloat light_dist=0.0; /* ?? */\nRgb at;\n\ndcol=hit.col;\nipoint=pt;\nif (obj.type==LIGHT) { color.r=color.g=color.b=0.0; return(color); }\ncolor.r=obj.ka*obj.amb.r*dcol.r;\ncolor.g=obj.ka*obj.amb.g*dcol.g;\ncolor.b=obj.ka*obj.amb.b*dcol.b;\n\nfor (i=0;i<numlights;i++)\n\t{\n\tL=light[i].p-pt;\n\tlight_dist=length(L);\n\tL=normalize(L);\n\tf=dot(N,L);\n\tgat.r=gat.g=gat.b=1.0;\n\tif (shadow(obj,pt,L,light_dist)>0.0)\n\t\t{\n\t\tt3=light[i].dist/(light_dist+light[i].k);\n\t\tif ((f>0.0)||(obj.kt>min_weight))\n\t\t\t{\n\t\t\tt=t3*f*obj.kd;\n\t\t\tif ((obj.kt>min_weight)&&(f<0.0)) { t=-t; }\n\t\t\tcolor.r+=light[i].i.r*dcol.r*t*gat.r;\n\t\t\tcolor.g+=light[i].i.g*dcol.g*t*gat.g;\n\t\t\tcolor.b+=light[i].i.b*dcol.b*t*gat.b;\n\t\t\tt2=2.0*f;\n\t\t\tR.v=t2*N-L;\n\t\t\tt2= -dot(R.v,ray.v);\n\t\t\tif (t2>0.0)\n\t\t\t\t{\n\t\t\t\tt2=t3*pow(t2,obj.kn)*obj.ks;\n\t\t\t\tcolor.r+=light[i].i.r*obj.spec.r*t2*gat.r;\n\t\t\t\tcolor.g+=light[i].i.g*obj.spec.g*t2*gat.g;\n\t\t\t\tcolor.b+=light[i].i.b*obj.spec.b*t2*gat.b;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nif (level<maxlevel)\n\t{\n\tif (obj.kr>min_weight)\n\t\t{\n\t\tRgb spcolor;\n\n\t\tf= -2.0*dot(N,ray.v);\n\t\tR.v=f*N+ray.v;\n\t\tR.p=pt+SMALL3*R.v;\n\t\t//spcolor=trace(R,level+1); // fix it (can't do recursion in GPU)\n\t\tcolor.r+=obj.kr*spcolor.r;\n\t\tcolor.g+=obj.kr*spcolor.g;\n\t\tcolor.b+=obj.kr*spcolor.b;\n\t\t}\n\tif (obj.kt>min_weight)\n\t\t{\n\t\tRgb spcolor;\n\t\tfloat n;\n\n\t\tf=dot(N,ray.v);\n\t\tif (f<0.0) { n=gn/obj.n; f= -f; }\n\t\telse { n=obj.n/gn; N=-N; }\n\t\tt=n*f;\n\t\tt3=1.0-n*n*(1.0-f*f);\n\t\tif (t3<0.0) // TIR\n\t\t\t{\n\t\t\tf= -2.0*dot(N,ray.v);\n\t\t\tR.v=f*N+ray.v;\n\t\t\tR.p=ipoint+SMALL3*R.v;\n\t\t\t//spcolor=trace(R,level+1);  // fix it (can't do recursion in GPU)\n\t\t\tcolor.r+=obj.kt*spcolor.r*dcol.r/255.0;\n\t\t\tcolor.g+=obj.kt*spcolor.g*dcol.g/255.0;\n\t\t\tcolor.b+=obj.kt*spcolor.b*dcol.b/255.0;\n\t\t\treturn(color);\n\t\t\t}\n\t\tt2=t-sqrt(t3);\n\t\tT.v=t2*N+n*ray.v;\n\t\tT.p=ipoint+SMALL3*T.v;\n\t\t//spcolor=trace(T,level+1);  // fix it (can't do recursion in GPU)\n\t\tcolor.r+=obj.kt*spcolor.r*dcol.r/255.0;\n\t\tcolor.g+=obj.kt*spcolor.g*dcol.g/255.0;\n\t\tcolor.b+=obj.kt*spcolor.b*dcol.b/255.0;\n\t\t}\n\t}\nreturn(color);\n}\n\nbool intersect(Ray ray)\n{\nObject ptr,p;\nint j;\nbool inter=false,i=false;\nfloat t;\nvec3 pt,gpts;\nfloat mint=MAXFLOAT;\nRgb col,colm;\n\nfor (j=0;j<numobj;j++)\n\t{\n\tptr=objs[j];\n\tif (ptr.type==SPHERE) { i=sphereinter(ptr,ray); }\n\telse if (ptr.type==PLANE) { i=triinter(ptr,ray); }\n\telse { i=false; }\n\tif (i)\n\t\t{\n\t\tinter=true;\n\t\tif (gt<mint)\n\t\t\t{\n\t\t\tp=ptr; mint=gt; gpts=gpt;\n\t\t\tcolm=ptr.diff;\n\t\t\t}\n\t\t}\n\t}\nif (inter)\n\t{\n\thit.object=p;\n\thit.t=mint;\n\tgpt=gpts;\n\tif (p.type==SPHERE) { hit.normal=spherenorm(p,ray); }\n\telse if (p.type==PLANE) { hit.normal=trinorm(p,ray); }\n\thit.pt=gpt;\n\tif (p.type==PLANE)\n\t\t{\n\t\tint ibx,ibz;\n\n\t\tibx=int(gpt.x+textoff);\n\t\tibz=int(gpt.z+textoff);\n\t\tif (((ibx+ibz)%2)==1) { colm.r=colm.g=colm.b=128.0; }\n\t\telse { colm.r=colm.g=colm.b=255.0; }\n\t\t}\n\thit.col=colm;\n\t}\nreturn(inter);\n}\n\nRgb trace(Ray ray,int level)\n{\nvec3 pt,N;\nObject obj;\n\nray.v=normalize(ray.v);\nif (intersect(ray))\n\t{\n\tobj=hit.object;\n\tN=hit.normal;\n\tpt=hit.pt;\n\treturn(shade(ray,obj,N,pt,level));\n\t}\nelse\n\t{\n\treturn(bg);\n\t}\n}\n\nvoid pushobj(int type,Info info)\n{\nobjs[numobj].id=numobj;\nobjs[numobj].type=type;\nif (type!=LIGHT)\n\t{\n\tobjs[numobj].ka=ka;\n\tobjs[numobj].ks=ks;\n\tobjs[numobj].kd=kd;\n\tobjs[numobj].kn=kn;\n\tobjs[numobj].kr=kr;\n\tobjs[numobj].kt=kt;\n\tobjs[numobj].n=ior;\n\tobjs[numobj].diff=diff;\n\tobjs[numobj].tran=tran;\n\tobjs[numobj].amb.r=ambient.r;\n\tobjs[numobj].amb.g=ambient.g;\n\tobjs[numobj].amb.b=ambient.b;\n\tobjs[numobj].spec=spec;\n\t}\nobjs[numobj].info=info;\nnumobj++;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdBcWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1693, 1693, 1731, 1731, 2125], [2127, 2127, 2164, 2164, 2230], [2232, 2232, 2267, 2267, 2482], [2484, 2484, 2518, 2518, 2553], [2555, 2555, 2578, 2578, 2837], [2839, 2839, 2893, 2893, 5433], [5435, 5435, 5485, 5485, 5932], [5934, 5934, 5990, 5990, 8056], [8058, 8058, 8083, 8083, 8859], [8861, 8861, 8891, 8891, 9071], [9073, 9073, 9107, 9107, 9529]], "test": "untested"}
{"id": "wdScWR", "name": "surfaceBlur", "author": "indere", "description": "use soble and gaussian blur to  achieve surface blur.  inspired by  https://www.shadertoy.com/view/4sVyzR", "tags": ["2d"], "likes": 2, "viewed": 476, "published": 3, "date": "1586401584", "time_retrieved": "2024-07-30T21:14:00.432687", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = vec4(texture(iChannel0, uv));\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define kernelSize 39\n#define halfKernelSize 19\n\n#define blurStrength 1.0\n#define blurEdge 0.3\n\nvec3 fastSurfaceBlur( sampler2D inputColor, sampler2D inputEdge, vec2 uv, vec2 blurStep)\n{\n\t// Normalized gauss kernel\n\tfloat blurKernel[kernelSize] = float[kernelSize](\n\t\t1.9576873456045e-10,\n        2.6102497941393e-09,\n        2.5449935492859e-08,\n        1.9341950974573e-07,\n        1.192753643432e-06,\n        6.134161594793e-06,\n        2.6836956977219e-05,\n        0.00010138405969172,\n        0.00033456739698267,\n        0.00097328697304049,\n        0.0025143246803546,\n        0.0058022877238952,\n        0.012019024570926,\n        0.022435512532395,\n        0.037859927398416,\n        0.057903418374049,\n        0.080421414408401,\n        0.10158494451587,\n        0.11682268619326,\n        0.12238567125008,\n        0.11682268619326,\n        0.10158494451587,\n        0.080421414408401,\n        0.057903418374049,\n        0.037859927398416,\n        0.022435512532395,\n        0.012019024570926,\n        0.0058022877238952,\n        0.0025143246803546,\n        0.00097328697304049,\n        0.00033456739698267,\n        0.00010138405969172,\n        2.6836956977219e-05,\n        6.134161594793e-06,\n        1.192753643432e-06,\n        1.9341950974573e-07,\n        2.5449935492859e-08,\n        2.6102497941393e-09,\n        1.9576873456045e-10\n   \t);\n\t\n\tvec3 result = blurEdge*blurKernel[halfKernelSize]*texture(inputColor,uv).rgb;\n\tfloat norma = blurEdge*blurKernel[halfKernelSize];\n\t\n\tfloat mainEdge = texture(inputEdge,uv).x;\n\t\n\t// Right direction\n\tfloat weight = blurEdge;\n\tfor(int i = 1; i<halfKernelSize; i++){\n\t\tvec2 currentPos = uv+float(i)*blurStep;\n\t\t\n\t\tweight-=abs(texture(inputEdge,currentPos).x-mainEdge)/blurStrength;\n\t\tif(weight<=0.0) continue;\n\t\t\n\t\tfloat coef = weight*blurKernel[halfKernelSize+i];\n\t\tresult+=coef*texture(inputColor,currentPos).rgb;\n\t\tnorma+=coef;\n\t}\n\t// Left direction\n\tweight = blurEdge;\n\tfor(int i = 1; i<halfKernelSize; i++){\n\t\tvec2 currentPos = uv-float(i)*blurStep;\n\t\t\n\t\tweight-=abs(texture(inputEdge,currentPos).x-mainEdge)/blurStrength;\n\t\tif(weight<=0.0) continue;\n\t\t\n\t\tfloat coef = weight*blurKernel[halfKernelSize-i];\n\t\tresult+=coef*texture(inputColor,currentPos).rgb;\n\t\tnorma+=coef;\n\t}\n    return result/norma;\n}", "buffer_a_code": "// Sobel edge detection from https://gist.github.com/Hebali/6ebfc66106459aacee6a9fac029d0115\n#define texture2D texture\n\nvoid make_kernel(inout vec4 n[9], sampler2D tex, vec2 coord)\n{\n\tfloat w = 1.0 / iResolution.x;\n\tfloat h = 1.0 / iResolution.y;\n\n\tn[0] = texture2D(tex, coord + vec2( -w, -h));\n\tn[1] = texture2D(tex, coord + vec2(0.0, -h));\n\tn[2] = texture2D(tex, coord + vec2(  w, -h));\n\tn[3] = texture2D(tex, coord + vec2( -w, 0.0));\n\tn[4] = texture2D(tex, coord);\n\tn[5] = texture2D(tex, coord + vec2(  w, 0.0));\n\tn[6] = texture2D(tex, coord + vec2( -w, h));\n\tn[7] = texture2D(tex, coord + vec2(0.0, h));\n\tn[8] = texture2D(tex, coord + vec2(  w, h));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 n[9];\n\tmake_kernel( n, iChannel0, fragCoord/iResolution.xy );\n\n\tvec4 sobel_edge_h = n[2] + (2.0*n[5]) + n[8] - (n[0] + (2.0*n[3]) + n[6]);\n  \tvec4 sobel_edge_v = n[0] + (2.0*n[1]) + n[2] - (n[6] + (2.0*n[7]) + n[8]);\n\tvec4 sobel = sqrt((sobel_edge_h * sobel_edge_h) + (sobel_edge_v * sobel_edge_v));\n    \n    fragColor = vec4(clamp((sobel.rgb),0.0,1.0),1.0);\n}", "buffer_a_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 result;\n\tresult = fastSurfaceBlur(iChannel0,iChannel1,fragCoord/iResolution.xy,vec2(1.0/iResolution.x,0.0)).rgb;\n    \n    fragColor = vec4(result.rgb,1.0);\n}\n", "buffer_b_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 originColor = texture(iChannel0,uv).rgb;\n    vec3 bluredColor = fastSurfaceBlur(iChannel2,iChannel1,fragCoord/iResolution.xy,vec2(0.0,1.0/iResolution.y)).rgb;\n    \n    vec3 e = texture(iChannel1,uv).rgb;\n    float edge = texture(iChannel1,uv).r;\n    //float edge = max(e.r, max(e.g, e.b));\n    edge = pow(edge,2.0);\n    bluredColor = mix(bluredColor,originColor,edge);\n    \n\tvec3 finalColor;\n    if(fragCoord.x < mod(iTime * 150.0, iResolution.x))\n        finalColor = bluredColor;\n    else\n        finalColor = originColor;\n    fragColor = vec4(finalColor,1.0);\n}", "buffer_c_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdScWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 196]], "test": "untested"}
{"id": "WdByDz", "name": "Happy Emoji", "author": "GabrielFelix", "description": "A smiling emoji to help brighten up our dark days.\n\nA tutorial by 'Art of Code'", "tags": ["beginner", "emoji"], "likes": 5, "viewed": 362, "published": 3, "date": "1586395548", "time_retrieved": "2024-07-30T21:14:01.451962", "image_code": "float remap01(float minInput, float maxInput, float domain)\n{\n    return clamp( (domain - minInput) / (maxInput - minInput), 0., 1.); \n}\n\nfloat remap(float minInput, float maxInput, float minOutput, float maxOutput, float domain)\n{\n    //return minOutput * (1 - remap01) + maxOutput * remap01;\n    return remap01(minInput, maxInput, domain) * (maxOutput - minOutput) + minOutput;\n}\n\nvec2 bound(vec2 uv, vec4 boundingBox)\n{\n\treturn (uv - boundingBox.xy) / (boundingBox.zw - boundingBox.xy);\n}\n\nvec4 Head (vec2 uv)\n{\n   \t//Constants\n    float len = length(uv);\n    \n    vec4 mainCol = vec4(.9, .7, 0., 1.);\n    vec3 outlineCol = vec3(0.75, 0.5, 0.);\n    vec3 cheekCol = vec3(1., 0.1, 0.1);\n    \n    float radius = 0.5;\n    float cheekRadius = 0.2;\n    \n    float blur = 0.01;\n    float shadingAttenuation = 0.5;\n    \n    //mainCircle\n    mainCol.a = smoothstep(radius, radius - blur, len);\n    \n    //Adding radial gradient\n    float edgeShading = remap01(radius / 1.5, radius, len);\n    edgeShading *= edgeShading;\n    mainCol.rgb *= 1. - edgeShading * shadingAttenuation;\n    \n    //Adding outline\n    mainCol.rgb = mix(mainCol.rgb, outlineCol, smoothstep(radius - (blur * 3.), radius - (blur * 2.), len));\n    \n    //Adding highlights\n    float highlight = smoothstep(radius - (blur * 9.), radius - (blur * 9.5), len);\n    highlight *= remap(radius - (blur * 9.), -0.1 , 0.75, 0., uv.y);\n    mainCol.rgb = mix(mainCol.rgb, vec3(1.), highlight);\n    \n    //Adding cheeks\n    len = length(uv - vec2(.225, -.175));\n    float cheek = smoothstep(cheekRadius, cheekRadius * .2, len)  * .3;\n    cheek *= smoothstep( cheekRadius - (cheekRadius * 3.), cheekRadius - (cheekRadius * 2.), len);\n    mainCol.rgb = mix(mainCol.rgb, cheekCol, cheek);\n    \n \treturn mainCol;\n}\n    \nvec4 Eye(vec2 uv)\n{\n    uv -= .5;\n    //uv.y += uv.x * uv.x * cos(iTime); \n    \n    float len = length(uv);\n    float eyeRadius = 0.5;\n    float irisRadius = 0.3 ;\n    float pupilRadius = 0.15 * ( cos(iTime)   *0.5 + 1.25 );\n    float highlightRadius = 0.1;\n    float blur = 0.02;\n    \n    //base eye\n    vec3 irisCol = vec3(0.25, 0.25, 0.75);\n    vec4 mainCol = mix( vec4(1.) , vec4(irisCol, 1.) , smoothstep(.1, .7, len) * 0.5);\n    vec3 highlightCol = vec3(1.);\n    \n    //eye shadow\n    mainCol *= 1. - smoothstep(eyeRadius - (blur * 5.), eyeRadius, len) * .3 * clamp(-uv.y -uv.x, 0., 1.);\n    \n    //iris and outline\n    irisCol *= 1. + smoothstep(irisRadius, irisRadius * 0.1, len);\n    \n    mainCol.rgb = mix(mainCol.rgb, vec3(0.), smoothstep(irisRadius, irisRadius - blur, len));\n    mainCol.rgb = mix(mainCol.rgb, irisCol, smoothstep(irisRadius - blur, irisRadius - (blur * 2.), len));\n    \n    //pupil\n    mainCol.rgb = mix(mainCol.rgb, vec3(0.), smoothstep(pupilRadius, pupilRadius - blur, len));\n    \n    //highlighs\n    float highlight = smoothstep(highlightRadius, highlightRadius - (blur * 3.), length(uv - vec2(-.15, .15)));\n    highlight += smoothstep(highlightRadius/1.5, highlightRadius/1.5 - (blur * 3.), length(uv - vec2(.1, -.1)));\n    mainCol.rgb = mix(mainCol.rgb, highlightCol, highlight);\n    \n    //\n    mainCol.a = smoothstep(eyeRadius, eyeRadius - blur, len);\t\n    return mainCol;\n}\n\nvec4 Mouth(vec2 uv)\n{\n    uv -= .5;\n    uv.y *= ( cos(iTime ) * 0.25 + 1.75);//2, 1,5, \n    uv.x *= ( cos(iTime + 3.) * 0.5 + 1.5) ; //2, 1\n    uv.y -= uv.x * uv.x * (cos(iTime) + 1.);\n    float len = length(uv);\n    \n    vec4 mainCol = vec4(.5, .2, .1, .1);\n    float mouthRadius = 0.5;\n    float blur = 0.02;\n    \n    //teeth\n    float newLen = length(uv - vec2(0, 0.5));\n    vec3 teethCol = vec3(1.) * smoothstep(.6, .35, len);\n  \n    mainCol.rgb = mix(mainCol.rbg, teethCol, smoothstep(.4, .4 - blur, newLen));\n    \n    //tongue\n    newLen = length(uv - vec2(0, -0.5));\n    vec3 tongueCol = vec3(1., 0.1, 0.1);\n    \n   \tmainCol.rgb = mix(mainCol.rbg, tongueCol, smoothstep(.5, .1, newLen));\n    \n    mainCol.a = smoothstep(mouthRadius, mouthRadius - blur, len);\n    return mainCol;\n}\n\nvec4 Smiley (vec2 uv)\n{\n    vec4 col = vec4(0.);\n    \n    uv.x = abs(uv.x);\n    \n\tvec4 head = Head(uv);\n    vec4 eye = Eye( bound(uv, vec4(.03, -.1, .37, .25)) );\n    vec4 mouth = Mouth( bound(uv, vec4(-.3, -.4, .3, -.1)) );\n        \n    col = mix(col, head, head.a);\n    col = mix(col, eye, eye.a);\n    col = mix(col, mouth, mouth.a);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *=(cos(iTime + 3.) *0.5 + 1.5);\n\n    fragColor = vec4(Smiley(uv));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdByDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 61, 61, 136], [138, 138, 231, 293, 381], [383, 383, 422, 422, 491], [493, 493, 514, 530, 1761], [1767, 1767, 1786, 1786, 3178], [3180, 3180, 3201, 3201, 3967], [3969, 3969, 3992, 3992, 4327], [4329, 4329, 4386, 4386, 4557]], "test": "untested"}
{"id": "WsBcDR", "name": "Live by The Sword", "author": "kstyler", "description": "Going through a tunnel of swords.", "tags": ["raymarch", "sdf", "sword"], "likes": 3, "viewed": 450, "published": 3, "date": "1586385663", "time_retrieved": "2024-07-30T21:14:03.195301", "image_code": "\nint matID = 0;\n\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos( 6.28318*(c*t+d) +iTime);\n}\nmat2 rotate(float a){\n\treturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}\n\nfloat sdfBox( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdfSphere(vec3 p,float size){\n\treturn length(p)-size;\n}\n\nfloat sdfCutAwayBox(vec3 translate,mat2 rot){\n    translate.xz*= rot;\n    float a = 0.5;\n    float b = 0.2;\n    float height = 4.0;\n    \n    float a2= length(vec2(a/1.5,b/2.)); \n     \n\treturn sdfBox(translate,vec3(a2,height,b));\n}\n\nfloat sdfPlane(vec3 p){\n    return p.y +15.5;\n}\n\nfloat sdfSword(vec3 p){\n    vec3 tip = p;\n    tip-=vec3(0,2,1.4);\n    tip.zy*=rotate((-12.*3.14)/180.);\n    vec3 tip2 = p;\n    tip2-=vec3(0,2,-1.4);\n    tip2.zy*=rotate((12.*3.14)/180.);\n    \n    vec3 tip3 = p;\n    tip3-=vec3(2.5,2,0);\n    tip3.xy*=rotate((-24.*3.14)/180.);\n    vec3 tip4 = p;\n    tip4-=vec3(-2.5,2,0);\n    tip4.xy*=rotate((24.*3.14)/180.);\n    \n    \n    float a = 0.5;\n    float b = 0.2;\n    float height = 4.;\n    \n    float a2= length(vec2(a/2.,b/2.)); \n    float box = sdfBox(p+vec3(0,-1,0),vec3(a,height,b));\n    \n    float box2 = sdfCutAwayBox(p+vec3(-0.53,-1,-0.3),rotate((20.*3.14)/180.));\n    float box3 = sdfCutAwayBox(p+vec3(-0.53,-1,0.3),rotate((-20.*3.14)/180.));\n    \n    float box4 = sdfCutAwayBox(p+vec3(0.53,-1,-0.3),rotate((-20.*3.14)/180.));\n    float box5 = sdfCutAwayBox(p+vec3(0.53,-1,0.3),rotate((20.*3.14)/180.));\n    float box6 = sdfBox(tip,vec3(2,2,1.2));\n    float box7 = sdfBox(tip2,vec3(2,2,1.2));\n    float box8 = sdfBox(tip3,vec3(2,4,1.2));\n    float box9 = sdfBox(tip4,vec3(2,4,1.2));\n    \n    float crossGuard = sdfBox(p+vec3(0.,3.3,0.),vec3(1.,0.3,0.3));\n    float pom = sdfSphere(p+vec3(0,6.4,0),0.4);\n    p.xz*=rotate(p.y*8.);\n    float handle = sdfBox(p+vec3(0.,4.8,0),vec3(0.2,1.3,0.2));\n \n  \n    float best = max(min(handle,min(crossGuard,min(pom,box))),\n                     -min(box8,min(box6,min(box9,min(box5,min(box4,min(box3,min(box2,box7))))))));\n    \n\n    return best;\n}\n\nfloat map(vec3 p){    \n    p.x+=sin(iTime*2.)*1.5;\n    float plane = sdfPlane(p);\n    float plane2 = sdfPlane(p*vec3(1,-1,1));\n  \n    float ang = 6.283185/13.0;\n    float sector = round(atan(p.x,p.y)/ang);\n    float c = 44.;\n    vec3 r = mod(p+0.5*c,c)-0.5*c;\n    vec3 q = p;\n    q.z = r.z;\n    \n    float an = sector*ang;\n    \n    q.xy *= rotate(an);\n    \n    q.zy *=rotate((180.*3.14)/180.);\n    vec3 q2 = q;\n    q2.zy*=rotate((180.*3.14)/180.);\n    \n   \n    float sword = sdfSword(q+ vec3(0,6,0));\n    float sword2 = sdfSword(q2- vec3(0,10,22));\n    float best = min(plane,min(plane2,min(sword2,sword)));\n    if(best == sword || best == sword2){\n    \tmatID=1;\n    } else if(best == plane || best == plane2){matID=2;}\n    return best;\n}\n\nvec3 normal(vec3 p){\n    vec2 e= vec2(0,0.01);\n\treturn normalize(vec3(map(p+e.yxx)-map(p-e.yxx),\n                          map(p+e.xyx)-map(p-e.xyx),\n                          map(p+e.xxy)-map(p-e.xxy)));\n}\n\nvec3 march(vec3 ro, vec3 rd){\n    float total = 0.;\n    float dist = 0.;\n    for(int i = 0; i<100; i++){\n        dist = map(ro+rd*total);\n        total+=dist;\n        if(dist < 0.1){\n        \tbreak;\n        }\n    }\n    \n   \n    return (ro+rd*total);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n   \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\tvec3 ro = vec3(0,0,iTime*20.);\n    vec3 rd = normalize(vec3(uv,1.));\n    vec2 st = uv*5.*sin(iTime);\n    st*=rotate(iTime);\n    st = fract(st);\n    \n    ro.xy*= rotate(iTime*.5);\n    rd.xy*= rotate(iTime*.5);\n    \n   \n    vec3 col = (march(ro,rd));\n    vec3 p = (march(ro,rd));\n    vec3 n = normal(p);\n    \n  \tif(matID ==1){\n        col = 1.-pal((max(dot(normalize(ro-p),n),0.)),vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );\n    }\n     if(matID ==2){\n         col = mix(vec3(0.04,0.14,0.15),vec3(0.04,0.33,0.32),vec3(smoothstep(0.2,0.19,length(st-0.5))));\n    }\n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBcDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 57, 124, 124, 173], [174, 174, 195, 195, 241], [243, 243, 274, 274, 361], [363, 363, 398, 398, 424], [426, 426, 471, 471, 656], [658, 658, 681, 681, 705], [707, 707, 730, 730, 2141], [2143, 2143, 2161, 2161, 2881], [2883, 2883, 2903, 2903, 3089], [3091, 3091, 3120, 3120, 3347], [3349, 3349, 3405, 3405, 4100]], "test": "untested"}
{"id": "3sSyDR", "name": "Day 111", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 26, "viewed": 566, "published": 3, "date": "1586381071", "time_retrieved": "2024-07-30T21:14:04.180666", "image_code": "// THIS IS LOGPOLAR MAPPING. THERE IS A REALLY NICE ARTICLE ON HOW TO DO IT. FUN STUFF.\n// https://www.osar.fr/notes/logspherical/\n\n// glow from here https://www.shadertoy.com/view/XlBSRz\n// pallete - inigo quilez\n// dither, ao - nusan\n// \n\n// radiual chromab in this buffer\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n\tfragColor = vec4(0);\n    // Radial blur\n    float steps = 30.;\n    float scale = 0.00 + pow(dot(uvn,uvn),5.5)*0.4;\n    float chromAb = pow(length(uv - 0.5),2.9)*0.1;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n        scale *= 0.97;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1.4/iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    fragColor += radial;\n    \n    //fragColor = 1. - fragColor;\n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.6);\n    //fragColor = pow(fragColor, vec4(1. + dot(uvn,uvn))*1. );\n    fragColor = max(fragColor, 0.);\n    //fragColor.b *= 1. + uv.x*0.4;\n    //fragColor *= 1. - dot(uvn,uvn)*2.;\n    fragColor *= 1. - dot(uvn*0.7,uvn*0.7)*1.;\n    fragColor = max(fragColor*1.1, 0.);\n    fragColor = pow(fragColor, vec4(0.4545 ));\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define dmin(a,b) a.x < b.x ? a : b\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n\n#define pmod(p,z) mod(p,z) - 0.5*z\n\nvec3 glow = vec3(0);\n\nfloat sdBox(vec3 p, vec3 s){\n\tp = abs(p) - s;\n    return max(p.x,max(p.y,p.z));\n}\t\n\n\nvec3 qG;\nvec2 idG;\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e8);\n\n    vec3 q = p;\n    \n    float modD = 1.;\n    float reps = 10.;\n    \n    q = vec3(reps*atan(q.z,q.x)/tau ,log(length(q.xz)) ,q.y);\n    \n    //q.\n    \n    //q.z += length(p.xz)*0.6;\n    //q.z += exp(length(p.xz)*0.4)*0.1;\n    float h = exp(length(p.xz)*0.7)*0.2;\n    q.z -= h;\n    q.z += exp(-length(p.xz)*4.)*0.7;\n    //q.y *=  1. - exp(-length(p.xz)*5.)*6.4;\n    q.y *= reps/tau;\n    q.y += iTime;\n    \n    float id = floor(q.y);\n    //q *= 1.;\n    \n    q.x += iTime*0.4 + id*0.6 + q.y*0.1;\n    \n    //q.xy *= rot(0.1 + id);\n    idG = floor(q.xy/modD);\n    q.xy = pmod(q.xy, modD);\n    \n    qG = q;\n    \n    //q.xz = sin(q.xz);\n    float bW = 0.6;\n    \n    //float dB = length(q) - 0.3;\n    //for()\n    \n    q.xy *= rot(0.25*pi);\n    \n    float dB = sdBox(q, vec3(bW*2.,bW*2.,bW));\n    //dB = max(dB, -sdBox(q, vec3(0.1, bW*0.2,0.7)));\n    float s = 0.2*bW;\n    dB = min(dB, sdBox(q, vec3(bW*s, bW*s,bW*1.2)));\n    \n    s *= 2.;\n    \n    q.xy *= rot(0.5);\n    float dBb = sdBox(q, vec3(bW*s, bW*s,bW*1.1));\n    d = dmin(d,vec2(dBb, 1.) );\n    \n    \n    \n    d = dmin(d, vec2(dB, 2.));\n    \n    \n    s = 0.2*bW;\n    q.xy *= rot(0.5*pi);\n    float dC = sdBox(q, vec3(bW*s*1., bW*s*1.,bW*1.3));\n    d = dmin(d, vec2(dC, 3.));\n    \n    \n    \n    q = abs(q);\n    //q.xz -= 0.;\n    //q.yz *= rot(0.25*pi);\n    \n    q.z -= 0.4;\n    float dD = sdBox(q, vec3(bW*s*1., bW*s*1.,bW*20.5));\n    \n    \n    //glow += 0.8/(0.01 + dD*dD*20.)*pal(0., 0.9,vec3(0.9,0.4,0.8), 0.7,1.2);\n    p.y -= h;\n    glow += 1.8/(0.06 + dD*dD*200.)*sin(vec3(0.8,0.5,0.1) + vec3(0,-0. - length(p.xz)*0.1,0))*pow(abs(sin(iTime + idG.y)), 20.)* smoothstep(1.,0.,length(p.y)*0.6)* pow(smoothstep(0.,1.,length(p.xz)*4.2),7.); // pow(smoothstep(0.,1.,length(p.xz)*1.2),7.);\n    \n    dD = abs(dD) + 0.006 + smoothstep(0.,1.,length(p.y)*0.05);\n    d = dmin(d, vec2(dD, 3.));\n    //= dmin(d, vec2(length(p)- 0.1, 2.));\n    d.x *= 0.4;\n    \n    d.x *= exp(log(length(p.xz) + 0.1)/1.5);\n    \n    return d;\n}\n\nfloat dith;\n\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tvec2 d= vec2(10e8);\n\n    t = 0.; hit = false; p = ro;\n    \n    for(int i = 0; i < 150; i++){\n    \td = map(p);\n        d.x *= dith;\n        \n        if(d.x < 0.001){\n        \thit = true;\n            break;\n        }\n        t += d.x;\n        p = ro + rd*t;\n    }\n    \n    return d;\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.0001,0.);\n    return normalize(\n    \tvec3(\n        \tmap(p + t.xyy).x - map(p - t.xyy).x,\n        \tmap(p + t.yxy).x - map(p - t.yxy).x,\n        \tmap(p + t.yyx).x - map(p - t.yyx).x\n        )\n    );\n\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0,1,0), dir));\n\tvec3 up = normalize(cross(dir, right));\n    return normalize(dir + right*uv.x + up*uv.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    uv *= 1. + dot(uv,uv)*0.1;\n    \n    vec3 col = vec3(0);\n    dith = mix(0.96,1.,texture(iChannel0, iResolution.x*(uv/256.)).x);\n    \n    vec3 ro = vec3(2.501,3,0.001);\n    vec3 lookAt = vec3(0.05);\n    \n    lookAt.xz += vec2(sin(iTime)*1.2,cos(iTime)*0.5)*0.4;\n\tvec3 rd = getRd(ro, lookAt, uv); \n    vec3 p;float t; bool hit;\n    \n    vec2 d = march(ro, rd, p, t, hit);\n    \n    \n    if(hit){\n    \tvec3 n = getNormal(p);\n        vec3 l = normalize(vec3(1));\n        \n        \n        #define AO(a) clamp(map(p + n*a).x/a,0.,1.)\n        float dnrd = max(dot(n, - rd),0.);\n        \n        float diff = max(dot(n, l),0.);\n        float spec = pow(max(dot(n, normalize(l - rd)),0.), 20.);\n        float fres = pow(1.- dnrd, 5.);\n        \n    \t//col += (0.5 + n*0.5)*2.;\n        \n        vec3 q = qG;\n        \n        float modD = 0.1;\n        q = abs(q);\n        \n        q.xy *= rot(0.25*pi);\n        q.y -= 0.5;\n        \n        q = abs(q);\n        q.xy *= rot(0.25*pi);\n        q = abs(q);\n        q.x -= 0.5;\n        q.xy *= rot(-0.25*pi);\n        \n        \n        float ao = mix(0.4,AO(0.1)*AO(0.2)/0.26,smoothstep(0.,1.,length(p.xz)*1.));\n        //float ao = AO(0.2)*AO(0.4)*AO(0.3)/0.16;\n        //float ao = AO(0.2)*AO(2.4)*AO(0.8)/0.3*3.;\n        float idc = floor(max(q.x,q.y)/ modD + iTime*4.*0.25);\n        \n        \n        \n        if(d.y == 2. || d.y == 1.){\n            //col += pal(0.5,1., vec3(.7,0.1,-0.3),0.8,idc*1.5 + idG.y*0.5 + iTime*0.1);\n            col += pal(0.,0.9, vec3(.7,0.1,-0.3),0.8,idc*1.5 + length(p.xz)*1. + iTime*1.);\n\t\t\n\n            col = max(col, 0.);\n        } else if(d.y == 3.) {\n            //col += pal(0.5,1., vec3(.7,0.2,0.),0.8,idc*1.5 + idG.y*0.5);\n            col += 0.4*fres;\n\n            \n            \n            //col += shiftHue(col, 0.98).xyz;\n        }\n        //col += pal(0.5,0.5, vec3(.1,0.9,1.8),0.8,idc*1.5 );\n        if(d.y == 1.){\n        \t//col = sin(col*10.);\n        }\n        \n        \n        //col *= 0.2+ ao;\n        col *= ao*1.4;\n        \n        col *= smoothstep(0.,1.,length(p.xz)*1.);\n        \n        //q.xz\n        \n        //col += qG;\n        \n    \t    \n    }\n    \n    \n    col += glow*0.005;\n    \n    //col = pow(col, vec3(0.454545));\n\n    col = mix(col,vec3(0.06,0.02,0.05), smoothstep(0.,1.,t*0.04));\n    \n    //col *= 1. - dot(uv,uv)*0.7;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sSyDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[276, 276, 333, 333, 1465]], "test": "untested"}
{"id": "3sScWR", "name": "Bezout Basins", "author": "NinjaKoala", "description": "Visualizing the basins of attraction of an alternating gradient descent to two different curves.\nFor many curve combinations, the resulting image is fractal.", "tags": ["2d", "fractal", "math", "curve"], "likes": 6, "viewed": 345, "published": 3, "date": "1586377183", "time_retrieved": "2024-07-30T21:14:05.045355", "image_code": "/*\nVisualization of the basins of attraction of an alternating gradient descent\nto two different algebraic curves.\nThis iteration can be used to find the intersections of these curves.\n\nIf the curves have intersections, points near these intersections converge\nto these intersections, but there are also other points of attraction sometimes.\n\nFor every pixel, the color is choosen according to the point\nto which the pixel coordinate converges under the iteration,\nquite similar to newton fractals.\n\nThe name i've choosen comes from the related Bezout's Theorem\n(see https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem)\nand because it's an alliteration, of course!\n\nYou can play around with different curve combinations below.\n\nIf you uncomment MOUSE_ITERATION, the point to which the\ncurrent mouse position converges is shown.\n*/\n\nfloat fac;\nconst float pi=3.14159265358979;\n\nconst int num_iterations=24;\nconst int aa=2;\n\n//#define MOUSE_ITERATION\n\n#define CURVE1(p,grad) saddle(p,grad)\n#define CURVE2(p,grad) circle(p,grad)\n\n//#define CURVE1(p,grad) parabola(p,grad)\n//#define CURVE2(p,grad) circle(p,grad)\n\n//#define CURVE1(p,grad) trifoil(p*fac,grad);grad*=fac\n//#define CURVE2(p,grad) deltoid(p,grad)\n\n//#define CURVE1(p,grad) deltoid(p,grad)\n//#define CURVE2(p,grad) deltoid(p*vec2(-1,1)*fac,grad);grad*=fac*vec2(-1,1)\n\n//#define CURVE1(p,grad) lemniscate(p,grad)\n//#define CURVE2(p,grad) parabola(p,grad)\n\n//#define CURVE1(p,grad) circle(p,grad)\n//#define CURVE2(p,grad) bicorn(p,grad)\n\n//#define CURVE1(p,grad) devil(p,grad)\n//#define CURVE2(p,grad) lemniscate(p,grad)\n\n//#define CURVE1(p,grad) kappa(p,grad)\n//#define CURVE2(p,grad) deltoid(p,grad)\n\n//#define CURVE1(p,grad) neile(p,grad)\n//#define CURVE2(p,grad) lemniscate(p,grad)\n\n//#define CURVE1(p,grad) trisectrix(p.yx,grad);grad=grad.yx\n//#define CURVE2(p,grad) parabola(p,grad)\n\n//#define CURVE1(p,grad) ampersand(p.yx*fac,grad);grad=grad.yx*fac\n//#define CURVE2(p,grad) bicorn(p*vec2(1,-1),grad);grad*=vec2(1,-1)\n\n//#define CURVE1(p,grad) saddle(p,grad)\n//#define CURVE2(p,grad) squircle(p*fac,grad);grad=grad*fac\n\n//#define CURVE1(p,grad) hyperbola(p,grad)\n//#define CURVE2(p,grad) saddle(p,grad)\n\nfloat hyperbola(vec2 p, out vec2 grad){\n\tgrad = p.yx;\n\n\treturn p.x*p.y-fac*fac;\n}\n\nfloat squircle(vec2 p, out vec2 grad){\n\tfloat x_2 = p.x*p.x;\n\tfloat y_2 = p.y*p.y;\n\n\tgrad = 4.*vec2(x_2*p.x,y_2*p.y);\n\t\n\treturn x_2*x_2+y_2*y_2-.27;\n}\n\nfloat ampersand(vec2 p, out vec2 grad){\n\tfloat x_2 = p.x*p.x;\n\tfloat y_2 = p.y*p.y;\n\n\tgrad=vec2(((-24.*p.x+63.)*p.x-38.-12.*y_2)*p.x+11.*y_2,(-16.*y_2+(-12.*p.x+22.)*p.x+6.)*p.y);\n\t\n\tfloat tmp=(x_2+y_2-2.*p.x);\n\treturn (y_2-x_2)*(p.x-1.)*(2.*p.x-3.)-4.*tmp*tmp;\n}\n\nfloat trisectrix(vec2 p, out vec2 grad){\n\tfloat x_2 = p.x*p.x;\n\tfloat y_2 = p.y*p.y;\n\n\tgrad=2.*vec2((p.x-fac)*3.*p.x+y_2,(fac+2.*p.x)*p.y);\n\n\treturn 2.*p.x*(x_2+y_2)-fac*(3.*x_2-y_2);\n}\n\nfloat trifoil(vec2 p, out vec2 grad){\n\tfloat y_2=p.y*p.y;\n\n\tgrad=vec2(((4.*p.x-3.)*p.x+4.*y_2)*p.x+3.*y_2,(4.*y_2+(4.*p.x+6.)*p.x)*p.y);\n\n    return (((p.x - 1. )*p.x+2.*y_2)*p.x+3.*y_2)*p.x + y_2*y_2;\n}\n\nfloat deltoid(vec2 p, out vec2 grad){\n\tfloat y_2=p.y*p.y;\n\n\tgrad = vec2(((-4.*p.x+24.)*p.x+(-4.*y_2-36.))*p.x -24.*y_2,  (-4.*y_2 + (-4.*p.x-48.)*p.x -36.  ) * p.y);\n\n\treturn (((-p.x+8.)*p.x-18.-2.*y_2)*p.x-24.*y_2)*p.x + (-y_2-18.)*y_2+27.;\n}\n\nfloat circle(vec2 p, out vec2 grad){\n\tgrad = vec2(2.*p.x,2.*p.y);\n\treturn p.x*p.x+p.y*p.y-.27*.27;\n}\n\nfloat saddle(vec2 p, out vec2 grad){\n\tgrad = vec2(fac*3.*p.x*p.x,-1.);\n\treturn fac*p.x*p.x*p.x-p.y;\n}\n\nfloat parabola(vec2 p, out vec2 grad){\n\tgrad = vec2(2.*p.x,-1.);\n\treturn p.x*p.x-p.y;\n}\n\nfloat kappa(vec2 p, out vec2 grad){\n\tfloat x_2=p.x*p.x;\n\tfloat y_2=p.y*p.y;\n\n\tgrad = vec2((2.*x_2+y_2)*2.*p.x,(x_2-fac*fac)*2.*p.y);\n\treturn x_2*(x_2+y_2) - fac*fac * y_2;\n}\n\nfloat neile(vec2 p, out vec2 grad){\n\tgrad = vec2(-3.*fac*fac*p.x*p.x,2.*p.y);\n\treturn p.y*p.y-fac*fac*p.x*p.x*p.x;\n}\n\nfloat lemniscate(vec2 p, out vec2 grad){\n\tfloat x_2 = p.x*p.x;\n\tfloat y_2 = p.y*p.y;\n\n\tgrad = vec2((x_2+(y_2-fac*fac))*4.*p.x,(y_2+x_2+fac*fac)*4.*p.y);\n\n\treturn (x_2+y_2)*(x_2+y_2)-2.*fac*fac*(x_2-y_2);\n}\n\nfloat bicorn(vec2 p, out vec2 grad){\n\tfloat x_2=p.x*p.x;\n\tfloat y_2=p.y*p.y;\n\n\tgrad = vec2((-2.*x_2+(2.*fac-4.*p.y)*fac-y_2)*p.x,((2.*fac-3.*p.y)*fac-2.*x_2)*fac-x_2*p.y)*2.;\n\n\tfloat tmp=x_2+2.*fac*p.y-fac*fac;\n\treturn y_2*(fac*fac-x_2)-tmp*tmp;\n}\n\nfloat devil(vec2 p, out vec2 grad){\n\tfloat x_2=p.x*p.x;\n\tfloat y_2=p.y*p.y;\n\n\tgrad = 2.*vec2((-2.*x_2+1.)*p.x,(2.*y_2-fac*fac)*p.y);\n\n\treturn (-x_2+1.)*x_2+(y_2-fac*fac)*y_2;\n}\n\nmat2 rot(float angle){\n\treturn mat2(cos(angle),sin(angle),-sin(angle),cos(angle));\n}\n\nvec2 iteration(vec2 p){\n\tfloat p_val1, p_val2;\n\tvec2 p_grad1, p_grad2;\n\n\tp_val1=CURVE1(p,p_grad1);\n\tp-=(p_grad1*p_val1)/dot(p_grad1,p_grad1);\n\n\tp_val2=CURVE2(p,p_grad2);\n\tp-=(p_grad2*p_val2)/dot(p_grad2,p_grad2);\n\n\treturn p;\n}\n\nfloat spectral(float x){\n        return clamp(abs(mod((x/pi+1.)*4.,8.)-4.)-2.,-.75,.75)*.5/.75+.5;\n}\n\nvec3 to_col(vec2 z){\n\tfloat direction =atan(z.x,z.y);\n\treturn vec3(spectral(direction),spectral(direction+pi/2.),spectral(direction-pi));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat aspect_ratio = iResolution.x / iResolution.y;\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv-=.5;\n\tuv.x *= aspect_ratio;\n\n\tvec2 mouse = (iMouse.xy+1.) / iResolution.xy;\n\tmouse-=.5;\n\tmouse.x *= aspect_ratio;\n\n\tvec2 mouse2 = iMouse.zw / iResolution.xy;\n\tmouse2-=.5;\n\tmouse2.x *= aspect_ratio;\n\n\tconst float curve_width = .001;\n\tconst float dot_size = .005;\n\n\tconst float axis_width = .005;\n\n\tvec3 bg_col = vec3(0);\n\tconst vec3 axis_col = vec3(0,0,0);\n\tconst vec3 curve_col = vec3(0,0,1);\n\tconst vec3 second_curve_col = vec3(0,1,1);\n\tconst vec3 dot_col = vec3(1,0,0);\n\n    float border = 2./iResolution.y;\n\n\t#ifdef MOUSE_ITERATION\n\tfac=exp(mouse2.y*10.);\n\tfloat zoom = exp(mouse2.x*10.);\n\n\tvec2 p0=zoom*mouse;\n\t#else\n    float zoom;\n    if(iMouse.xy==vec2(0)){\n        fac=7.1;\n        zoom=1.;\n    }\n    else{\n\t\tfac=exp(mouse.y*10.);\n\t\tzoom = exp(mouse.x*10.);\n    }\n\t#endif\n\n\tuv*=zoom;\n\tborder*=zoom;\n\n\tfloat curve_dis = 1e38;\n\tfloat second_curve_dis = 1e38;\n\tfloat dot_dis = 1e38;\n\tfloat axis_dis = 1e38;\n\n\tconst mat2 aa_rot=mat2(1.,.5,-.5,1.);\n\n\tvec3 col_sum=vec3(0);\n\n\tfor(int x=0;x<aa;x++){\n\t\tfor(int y=0;y<aa;y++){\n\t\t\tvec2 aa_offset=(vec2(x,y)-.5*(float(aa)-1.))/float(aa);\n\t\t\taa_offset*=zoom*vec2(aspect_ratio,1)/iResolution.xy;\n\t\t\tvec2 p1=uv+aa_offset;\n\n\t\t\tfor(int i=0;i<num_iterations;i++){\n\t\t\t\tp1=iteration(p1);\n\t\t\t}\n\n\t\t\tcol_sum+=pow(to_col(p1),vec3(2.2));\n\t\t}\n\t}\n\n\tbg_col=pow(col_sum/(float(aa)*float(aa)),vec3(1.0/2.2));\n\tbg_col*=.75;\n\n\t#ifdef MOUSE_ITERATION\n\tdot_dis=min(dot_dis,distance(uv,p0)-dot_size*zoom);\n\tfloat p0_val1, p0_val2;\n\tvec2 p0_grad1, p0_grad2;\n\tfor(int i=0;i<num_iterations;i++){\n\t\tp0=iteration(p0);\n\t}\n\n\tdot_dis=min(dot_dis,distance(uv,p0)-dot_size*zoom);\n\t#endif\n\n\tfloat val1, val2;\n\tvec2 grad1, grad2;\n\n\tval1=CURVE1(uv,grad1);\n\tcurve_dis=min(curve_dis,abs(val1)/length(grad1));\n\n\tval2=CURVE2(uv,grad2);\n\tsecond_curve_dis=min(second_curve_dis,abs(val2)/length(grad2));\n\n\taxis_dis=min(axis_dis, abs(uv.x));\n\taxis_dis=min(axis_dis, abs(uv.y));\n\n\tvec3 color = bg_col;\n\tcolor=vec3(mix(axis_col,color,smoothstep(0., border, axis_dis)));\n\tcolor=vec3(mix(second_curve_col,color,smoothstep(0., border, second_curve_dis)));\n\tcolor=vec3(mix(curve_col,color,smoothstep(0., border, curve_dis)));\n\tcolor=vec3(mix(dot_col,color,smoothstep(0., border, dot_dis)));\n\n\tfragColor = vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sScWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2169, 2169, 2208, 2208, 2250], [2252, 2252, 2290, 2290, 2402], [2404, 2404, 2443, 2443, 2667], [2669, 2669, 2709, 2709, 2854], [2856, 2856, 2893, 2893, 3059], [3061, 3061, 3098, 3098, 3304], [3306, 3306, 3342, 3342, 3406], [3408, 3408, 3444, 3444, 3509], [3511, 3511, 3549, 3549, 3598], [3600, 3600, 3635, 3635, 3773], [3775, 3775, 3810, 3810, 3891], [3893, 3893, 3933, 3933, 4098], [4100, 4100, 4136, 4136, 4347], [4349, 4349, 4384, 4384, 4525], [4527, 4527, 4549, 4549, 4611], [4613, 4613, 4636, 4636, 4839], [4841, 4841, 4865, 4865, 4941], [4943, 4943, 4963, 4963, 5082]], "test": "untested"}
{"id": "wd2yRm", "name": "Pixel sorting with vector field", "author": "ciphered", "description": "This technique is described in this article I wrote: \nhttps://ciphered.xyz/2020/04/08/pixel-sorting-on-shader-using-well-crafted-sorting-filters-glsl/", "tags": ["pixel", "field", "vector", "sort", "sorting", "diagonal"], "likes": 33, "viewed": 7394, "published": 3, "date": "1586372449", "time_retrieved": "2024-07-30T21:14:05.977368", "image_code": "// @author ciphrd <https://instagram.com/ciphrd>\n// @license MIT\n//\n// To understand how this technique works, I wrote an illustrated article on\n// my blog, check it out if you are interested:\n//\n// https://ciphered.xyz/2020/04/08/pixel-sorting-on-shader-using-well-crafted-sorting-filters-glsl/\n// \n//\n// Buffer A, B, C generates the 2 different sorting filters,\n// Buffer C is where the filter selection happens,\n// Buffer D sorts\n//\n// This shader displays the result of the sort, and overlays the vector\n// field given the Y position of the mouse\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 color = texture(iChannel0, uv);\n    vec4 vfield = texture(iChannel1, uv);\n    \n    float s = step(1. - iMouse.y / iResolution.y, 1.-uv.y);\n    \n    color.rgb+= vfield.rgb * s;\n    \n    fragColor = color;\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// @author ciphrd <https://instagram.com/ciphrd>\n// @license MIT\n//\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord / iResolution.xy;\n\tvec4 color = vec4(1.0);\n    float _Frame = float(iFrame);\n\n\t\n\tvec2 dir = vec2(1, 1);\n\t\n\t// size of a texel\n\tvec2 texelSize = vec2(1./iResolution.x, 1./iResolution.y);\n\t\n\t// we differentiate 1/2 pixels on the y axis\n\tvec2 iuv = floor(uv * iResolution.xy);\n\tfloat r = mod(iuv.y, 2.0) * 2. - 1.; // r = -1.0 or 1.0\n\t\n\t// here goes the rules to define the displacement map\n\tdir*= r * (mod(_Frame, 2.0) * 2. - 1.);\n\t\n\t// we create \"bands\", and swap correctly the direction \n\tfloat b = mod(floor(uv.y * 5.0), 2.0) * 2. - 1.;\n\tdir*= vec2(b, 1);\n\t\n\t// color defined by the direction, and b encodes the direction of the sort\n\tcolor = vec4(dir, b, 1.0);\n\t\n\t\n\tfragColor = color;\n}", "buffer_a_inputs": [], "buffer_b_code": "// @author ciphrd <https://instagram.com/ciphrd>\n// @license MIT\n//\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec4 color = vec4(0, 0, 0, 1);\n    float _Frame = float(iFrame);\n    \n    // uvs\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 uv05 = uv - 0.5;\n    vec2 uva = abs(uv05);\n    vec2 uvf = mod(floor(uva * iResolution.xy) + _Frame, 2.0);\n    \n    \n    // directions\n\tvec2 topright = vec2(1, 1);\n\tvec2 bottomright = vec2(1, -1);\n    \n    // diagonal quadrant\n\tfloat dQuad = sign(uv05.x) * sign(uv05.y) * 0.5 + 0.5;\n\tfloat l = mix(uvf.x, uvf.y, dQuad);\n    \n    // direction depends on the quadrant\n\tvec2 dir = mix(topright, bottomright, dQuad);\n\tdir*= sign(uv05.y);\n    \n    // direction is nverted 1/2\n\tdir*= mod(floor(uv.y * iResolution.y) + _Frame, 2.0) * 2. - 1.;\n    color.rg = dir;\n    \n    // blue channel defines the direction of the swap\n\tcolor.b = uv05.y < 0.0 ? 1.0 : 0.0;\n    // we adjust the swap direction outside of the square to give a nice effect\n\tcolor.b+= round(uva.x + uva.y);\n\tif (color.b > 1.5) color.b = 0.0;\n\tcolor.b = 1. - color.b;\n\t\n\t// alpha channel defines if there is a sort or not on the line\n\tfloat isTopLeft = uv05.x > 0.0 && uv05.y > 0.0 ? 1.0 : 0.0;\n\tfloat nosort = isTopLeft;\n\tnosort*= uv05.y * iResolution.y > 1.0 ? 0.0 : 1.0;\n\tcolor.a-= nosort;\n    \n    \n    fragColor = color;\n}", "buffer_b_inputs": [], "buffer_c_code": "// @author ciphrd <https://instagram.com/ciphrd>\n// @license MIT\n//\n// This buffer both generates a sort filter and picks which one should be used \n// between A, B and C, given the time\n//\n// Output of this buffer will be the vector field used by the sort buffer (D)\n//\n\n\nvec4 getVfield (vec2 uv) {\n\tvec4 color = vec4(1.0);\n\n\tvec2 topright = vec2(1.0, 1.0);\n\t\n\t// size of a texel\n\tvec2 texelSize = vec2(1./iResolution.x, 1./iResolution.y);\n\t\n\t// we differentiate 1/2 pixels on the y axis\n\tvec2 iuv = floor(uv * iResolution.xy);\n\tfloat r = mod(iuv.y, 2.0) * 2. - 1.; // r = -1 or 1.0\n\t\n\t// here goes the rules to define the displacement map\n\tvec2 dir = topright * r * (mod(float(iFrame), 2.0) * 2. - 1.);\n    \n    // we invert on the left to preserve consistency\n    dir*= round(uv.x) * 2. - 1.;\n\t\n\t// color defined by the direction\n\tcolor = vec4(dir, round(uv.x), 1.0);\n\t\n\t// we stop on the middle\n\tfloat m = step(1./iResolution.x, abs(uv.x-0.5));\n\tcolor.a = m;\n\t\n\treturn color;   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // sample buffer A & B\n    vec4 vfieldA = texture(iChannel0, uv);\n    vec4 vfieldB = texture(iChannel1, uv);\n    vec4 vfieldC = getVfield(uv);\n    \n    // the vector field changes periodically\n    float t = mod(iTime, 15.0);\n    \n    vec4 color = vfieldA;\n    \n    if (t > 10.0) {\n    \tcolor = vfieldC;   \n    } else if (t > 5.0) {\n     \tcolor = vfieldB;   \n    }\n    \n    // we swap the blue channel to change the direction of the sort\n    float t2 = mod(iTime, 30.0);\n    if (t2 > 15.0) {\n    \tcolor.b = 1. - color.b;   \n    }\n    \n    fragColor = color;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// @author ciphrd <https://instagram.com/ciphrd>\n// @license MIT\n//\n// This is where the sort happens\n// \n// A sorting filter (vector field), is grabbed from the buffer C.\n// Buffer C controls which buffer is picked\n//\n\n\n// returns a grayscale based on the average of the 3 components\nfloat gscale (in vec3 color) {\n\treturn (color.r + color.g + color.b) / 3.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uvs \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // threshold is defined by the mouse x\n    float threshold = 0.04; //+ 0.98 * iMouse.x/iResolution.x;\n    \n    // initialization\n    if (iFrame < 30) {\n     \tfragColor = texture(iChannel0, uv);\n        return;\n    }\n\n    \n    \n    vec4 vfield = texture(iChannel2, uv);\n    vec2 dr = vfield.xy / iResolution.xy; // pixel space to square space\n    vec2 p = uv + dr;\n    \n    // we make p loop on x\n    if (p.x < 0.0) p.x = 1. - p.x;\n    if (p.x > 1.0) p.x = fract(p.x);\n    \n    // sample the pixels to test\n    vec4 actv = texture(iChannel1, uv);\n    vec4 comp = texture(iChannel1, p);\n    \n    // if we are next to a border on the Y-axis, the prevent the sort from happening\n    if (uv.y+dr.y < 0.0 || uv.y+dr.y > 1.0) {\n    \tfragColor = actv;\n        return;\n    }\n    \n    // sample the vector field of the texel to compare, to get blue and alpha\n    vec4 vfieldComp = texture(iChannel2, uv + dr);\n    \n    // the alpha component encodes if whether or not a sort is possible\n    if (vfield.a < 0.5 || vfieldComp.a < 0.5) {\n\t\tfragColor = actv;\n        return;\n    }\n    \n    \n    // we can sort the texel with the other one\n    vec4 color = actv;\n    float gAct = gscale(actv.rgb);\n    float gCom = gscale(comp.rgb);\n    \n    // we separate the vector field dir into 2 \"categories\"\n    float classed = sign(dr.x*2. + dr.y);\n    \n    if (classed < 0.0) {\n        // given the blue component value, we sort one way or the other\n\t\tif (vfield.b > 0.5) {\n\t\t\tif (gCom > threshold && gAct > gCom) {\n\t\t\t\tcolor = comp;\n\t\t\t}\n\t\t} else {\n\t\t\tif (gAct > threshold && gAct < gCom) {\n\t\t\t\tcolor = comp;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (vfield.b > 0.5) {\n\t\t\tif (gAct > threshold && gAct < gCom) {\n\t\t\t\tcolor = comp;\n\t\t\t}\n\t\t} else {\n\t\t\tif (gCom > threshold && gAct > gCom) {\n\t\t\t\tcolor = comp;\n\t\t\t}\n\t\t}\n\t}\n    \n    fragColor = color;\n}", "buffer_d_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2yRm.jpg", "access": "api", "license": "mit", "functions": [[555, 555, 612, 612, 872]], "test": "untested"}
{"id": "wdjcRm", "name": "old? horror movie", "author": "TimoKinnunen", "description": "I was mucking about trying figure out how this shader works when instead I came up with this :) All credit to florian berger (flockaroo)!", "tags": ["blood", "horror", "writing", "handwriting"], "likes": 14, "viewed": 837, "published": 3, "date": "1586366346", "time_retrieved": "2024-07-30T21:14:07.175165", "image_code": "// Fork of \"writings from hell\" by flockaroo. https://shadertoy.com/view/XltSzj\n// 2020-04-08 16:55:16\n\n// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// writings from hell with spooky hell sound.\n// use your mouse if you prefer a heart instead of a pentagram... ;-)\n// make fullscreen within the first 2 seconds\n\nfloat getVign(vec2 fragCoord)\n{\n\tfloat vign=1.;\n    \n\tfloat rs=length(fragCoord-iResolution.xy*.5)/iResolution.x/.7;\t\n    vign*=1.-rs*rs*rs;\n    \n    vec2 co=2.*(fragCoord.xy-.5*iResolution.xy)/iResolution.xy;\n\tvign*=cos(0.75*length(co));\n    vign*=0.5+0.5*(1.-pow(co.x*co.x,16.))*(1.-pow(co.y*co.y,16.));\n    \n    return vign;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera rattle\n    vec4 rattle=texture(iChannel2,vec2(iTime*.1234*.5,.5/256.));\n\tvec2 uv = fract(((fragCoord.xy / iResolution.xy-.5)*(1.+rattle.z*.01)+.5) + rattle.xy*.005);\n    vec4 c = texture(iChannel1,uv);\n    // brightness flickering\n    vec4 flicker=texture(iChannel2,vec2(iTime*.2,.5/256.))*\n        mat4(+0.33,+0.11,+0.11,0.,\n             +0.11,+0.33,+0.11,0.,\n             +0.11,+0.11,+0.33,0.,\n             0.,0.,0.,1.);;\n    fragColor=c;\n    fragColor*=(flicker*.25+.75)*2.3*fragColor;     // fragColor^2 contrast\n    fragColor*=getVign(fragCoord);                  // vignetting\n\n    vec4 iMouse1 = vec4(11,6,771,189)/vec4(800,450,800,450);\n    vec4 k = iMouse1*8.0-4.0;\n    k.w = 3.8*smoothstep(0.0,0.1,sin(iTime*0.25+0.1)+flicker.x*flicker.y*flicker.z-k.w);\n    fragColor += vec4((texture(iChannel0,fragCoord.xy/iResolution.xy).xy*\n        mat2(k.x,k.z,\n             k.y,k.w)).xyy,1);\n}\n", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// writing random endless scribbles\n// by summing up low band noised curvature\n\n// fragColor: red = writing, blue = burn mask\n\n#define PI2 6.28318530717959\n#define PNUM 20\n\nvec2 filterUV1(vec2 uv) \n{\n    // iq's improved texture filtering (https://www.shadertoy.com/view/XsfGDn)\n\tvec2 x=uv*iChannelResolution[1].xy;\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return (p+f)/iChannelResolution[1].xy;\n}\n\nvec4 getPixel(int x, int y)\n{\n    return texture(iChannel0,vec2(float(x)+.5,float(y)+.5)/iChannelResolution[0].xy);\n}\n\nbool isPixel(int x, int y, vec2 fragCoord)\n{\n    vec2 c=fragCoord/iResolution.xy*iChannelResolution[0].xy;\n    return ( int(c.x)==x && int(c.y)==y );\n}\n\nvec2 readPos(int i)\n{\n    return getPixel(i,0).xy;\n}\n\nbool writePos(vec2 pos, int i, inout vec4 fragColor, vec2 fragCoord)\n{\n    if (isPixel(i,0,fragCoord)) { fragColor.xy=pos; return true; }\n    return false;\n}\n\nvec4 getRand(vec2 pos)\n{\n    return texture(iChannel1,filterUV1(pos/vec2(400,300)));\n}\n\nfloat dotDist(vec2 pos,vec2 fragCoord)\n{\n    return length(pos-fragCoord);\n}\n\n// iq: https://iquilezles.org/articles/distfunctions\nfloat lineDist(vec2 a,vec2 b,vec2 p)\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec4 drawDot(vec2 pos,float r, vec2 fragCoord)\n{\n    return vec4(clamp(r-length(pos-fragCoord),0.,1.)/r*3.);\n}\n\n#define N(x) (x.yx*vec2(1,-1))\n\n// gives a parametric position on a pentagram with radius 1 within t=0..5\n// (maybe there's more elegant ways to do this...)\nvec2 pentaPos(float t)\n{\n    float w=sqrt((5.+sqrt(5.))*.5);\n    float s=sqrt(1.-w*w*.25);\n    float ang=-floor(t)*PI2*2./5.;\n    vec2 x=vec2(cos(ang),sin(ang));\n    return -N(x)*s+x*w*(fract(t)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time=float(iFrame)*1./60.;\n    vec2 uv=fragCoord/iResolution.xy;\n    float v=0.;\n    for(int i=0;i<50;i++) v+=texture(iChannel0,getRand(vec2(i,0)).xy).x/50.;\n    fragColor = texture(iChannel0,uv);\n    int pnum = int(min(iResolution.y/50.0,float(PNUM-1)));\n    bool write=false;\n    for(int i=0;i<PNUM;i++)\n    {\n        bool isMouse = (i==pnum);\n        // breaking here if i>pnum didnt work in windows (failed to unloll loop)\n        if(i<=pnum) {\n        vec2 pos;\n            \n\t    pos=readPos(i);\n        vec2 oldpos=pos;\n        \n    \tfloat ang = (getRand(pos)+getRand(pos+vec2(1,3)*time)).x*PI2;\n    \tpos+=vec2(.7,0)\n            +vec2(4,5)*vec2(cos(15.*time+float(i)),\n                            .5*sin(15.*time+float(i)+.5)+\n                            .5*sin(21.*time+float(i)+.5))*getRand(pos).x;\n            //+vec2(.2,2)*vec2(cos(ang),sin(ang));\n    \t//vec4 c = drawDot(mod(pos,iResolution.xy),2.5,fragCoord);\n\n        if(isMouse) \n        {\n            pos=iMouse.xy;\n            if(iMouse.xy==vec2(0) && mod(iTime+5.,37.7)>18.)\n            {\n                pos=pentaPos(iTime*.5)*.45*iResolution.y+iResolution.xy*.5;\n                pos+=(getRand(pos*.6+iTime*vec2(.1,1.)).xy-.5)*7./500.*iResolution.y;\n            }\n        \tif(length(oldpos-pos)>40.) oldpos=pos;\n        }\n                \n        vec2 mpos=mod(pos,iResolution.xy);\n        //float dd = dotDist(mpos,fragCoord);\n        float dd = lineDist(mpos,oldpos-(pos-mpos),fragCoord);\n    \tvec4 c = vec4(clamp((isMouse?5.:3.)-dd,0.,1.9),0,max(0.,1.-dd/40.),0);\n        if(mpos==oldpos-(pos-mpos)) c=vec4(0.); // ignore 0-length segments\n        if(getRand(pos*.3+time).z>.8 && !isMouse) \n            pos+=vec2(10,0);\n        else\n    \t\tfragColor = max(fragColor,c);        \n\n        if(writePos(pos, i, fragColor,fragCoord)) write=true;\n        }\n    }\n\n    if(!write)\n    {\n       fragColor.z=max(-1.,fragColor.z-.002);\n       fragColor.x=max(0.,fragColor.x-.003);\n    }\n        \n    if(iTime<7.) \n    {\n        fragColor=vec4(0,0,.6,0);\n\t    for(int i=0;i<PNUM;i++)\n    \t{\n            if(i<=pnum-int((iTime-5.0)*0.125*float(PNUM))){\n                vec4 rnd=texture(iChannel1,vec2(float(i)+.5,.5)/iChannelResolution[1].xy);\n        \t    writePos(vec2(0.+rnd.x*80.,iResolution.y/float(pnum)*float(i+1)),i,fragColor,fragCoord);     \n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 7\n#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n#define keyTex iChannel3\n#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 m = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nvec2 getGradBlue(vec2 pos)\n{\n    float eps=1.4;\n    vec2 d=vec2(eps,0);\n    return vec2(\n\t\t texture(iChannel0,fract((pos+d.xy)/Res.xy)).z\n        -texture(iChannel0,fract((pos-d.xy)/Res.xy)).z,\n\t\t texture(iChannel0,fract((pos+d.yx)/Res.xy)).z\n        -texture(iChannel0,fract((pos-d.yx)/Res.xy)).z\n    )/(eps*2.);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        vec2 v=texture(iChannel0,fract((pos+p)/Res.xy)).xy;\n\n        rot+=dot(v,p.yx*vec2(1,-1));\n        p = m*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvec4 getC2(vec2 uv) \n{\n    // line 0 holds writer infos so take 1st line instead\n    if(uv.y*iChannelResolution[2].y<1.) uv.y+=1./iChannelResolution[2].y;\n\treturn texture(iChannel2,uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y*1.; bbMax*=bbMax;\n    for(int l=0;l<8;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = m*p;\n        }\n        b*=2.0;\n    }\n    vec4 c2=getC2(fract(uv));\n    float strength = clamp(1.-1.*c2.z,0.,1.);\n    fragColor=texture(iChannel0,fract((pos-v*strength*(2./*+2.*iMouse.y/Res.y*/)*vec2(0,1)*1.0)/Res.xy));\n    fragColor=mix(fragColor,c2.xxzw*vec4(1,-1,1,1),.3*clamp(1.-strength,0.,1.));\n    \n    // damping\n    fragColor.xy=mix(fragColor.xy,vec2(.0),.02);\n    \n    // add a little \"motor\" in the center\n    //vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n    //fragColor.xy += (0.01*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n    if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n", "buffer_b_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat getVign(vec2 fragCoord)\n{\n\tfloat vign=1.;\n    \n\tfloat rs=length(fragCoord-iResolution.xy*.5)/iResolution.x/.7;\t\n    vign*=1.-rs*rs*rs;\n    \n    vec2 co=2.*(fragCoord.xy-.5*iResolution.xy)/iResolution.xy;\n\tvign*=cos(0.75*length(co));\n    vign*=0.5+0.5*(1.-pow(co.x*co.x,16.))*(1.-pow(co.y*co.y,16.));\n    \n    return vign;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera rattle\n    vec4 rattle=texture(iChannel2,vec2(iTime*.1234*.5,.5/256.));\n\tvec2 uv = fract(((fragCoord.xy / iResolution.xy-.5)*(1.+rattle.z*.01)+.5) + rattle.xy*.005);\n    vec4 c = texture(iChannel0,uv);\n    vec4 old = texture(iChannel1,fragCoord.xy / iResolution.xy);\n    // brightness flickering\n    vec4 flicker=texture(iChannel2,vec2(iTime*.2,.5/256.));\n    \n    // yellow-red fade\n    fragColor= 1.5*mix(abs(c.xxww*vec4(1,.2,0,1)),.6*abs(c.xxxw),(1.-smoothstep(.35,.45,c.z))*(1.-smoothstep(.25,.35,c.x)));\n    \n    fragColor+=\n        +abs(c.yyyw)*vec4(.4,.4,.3,1)                            // bright core\n        +(.8+.2*flicker)*vec4(1,1,.5,1)*clamp(c.zzzw-.5,0.,1.);  // halo\n    \n    // mix bg image\n    fragColor=mix(vec4(1),vec4(.2,.12,.06,0)*1.2+.4*texture(iChannel3,uv).x*vec4(1,1,1,0),-fragColor+1.1);\n\n    fragColor*=(flicker*.25+.75)*2.3*fragColor;     // fragColor^2 contrast\n    fragColor*=getVign(fragCoord);                  // vignetting\n    fragColor=mix(fragColor,old*vec4(.7,1,1,1),.6); // slight motion blur (camera latency)\n}", "buffer_c_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec2 mainSound( in int samp, float time )\n{\n    float t=.1*time;\n    vec4 r=texture(iChannel0,fract(vec2(t,t*.01)));\n    t=time/iChannelResolution[0].x*iSampleRate*.015;\n    vec4 r2=texture(iChannel0,fract(vec2(t,.5/256.+t/200.)))-.5;\n    bool penta=mod(time+5.,37.7)>18.;\n    return .3*clamp(vec2(\n        // some higher pitch when pentagram is painted\n        + (penta?1.5:1.)*r.xy*sin(6.2831*(penta?333.0:220.)*time)\n        // some low pitch sines modulated with some random loudness\n        + r.yz*sin(6.2831*140.0*time)\n        + r.yz*sin(6.2831*20.0*time)\n        // some low pitch grumbling noise\n        + 3.*r2.xy \n\t),-1.,1.)*clamp(time*.1,0.,1.);\n}", "sound_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdjcRm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[403, 403, 434, 434, 732], [734, 734, 791, 812, 1698]], "test": "untested"}
{"id": "3slyWf", "name": "Psychedelic  Kaleidoscope", "author": "brechrt", "description": "Kaleidoscope", "tags": ["psychedelic", "kaleidoscope"], "likes": 8, "viewed": 452, "published": 3, "date": "1586362713", "time_retrieved": "2024-07-30T21:14:08.081741", "image_code": "#define PI 3.14159265\n#define TWO_PI 6.28318530\n\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\nuint hash( uvec2 v ) { \n    return hash( v.x ^ hash(v.y)); \n}\n\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\nfloat random( vec2  v ) { \n    return floatConstruct(hash(floatBitsToUint(v)));\n}\n\nfloat noise(vec2 uv){\n\tvec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat noise( vec2 uv, float detail){\n\tfloat n = 0.;\n    float m = 0.;\n\n    for(float i = 0.; i < detail; i++){\n    \tfloat x = pow(2., i);\n        float y = 1./x;\n        \n        n += noise(uv*x+y)*y;\n        m += y;\n    }\n    \n    return n/m;\n    \n}\nmat2 rot(float a){\n\tfloat c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 selectColor(float b){\n    float n = 4.;\n    vec3 cols[5];\n    cols[0] = vec3( 0.9490196078431372, 0.5686274509803921, 0.23529411764705882);\n    cols[1] = vec3( 0.2627450980392157, 0, 0.39215686274509803);\n    cols[2] = vec3( 0.8784313725490196, 0.08627450980392157, 0.4823529411764706);\n    cols[3] = vec3( 0, 0.7137254901960784, 0.7372549019607844);\n    cols[4] = vec3( 1, 0.5019607843137255, 0);\n    \n    float i = floor(b*n);\n    float f = fract(b*n);\n    f = f*f*(3.-2.*f);\n    int i1 = int(i);\n    int i2 = int(i) + 1;\n    vec3 col = mix(cols[i1], cols[i2], f);\n    //col = col*col*(3.0-2.0*col);\n    \n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec2 gv = vec2(length(uv), atan(uv.y, uv.x)+iTime*.5);\n\t//gv.y += gv.x*.5*sin(iTime*.1);\n    gv.y = (gv.y+PI)/TWO_PI;\n    \n    gv.y = abs(fract(gv.y*5.)-.5);\n    gv.x *= 1.;\n    gv.x += sin(iTime*.05)*sin(iTime*.08+.4)*7.-7.;\n    \n    gv *= rot(noise(gv,2.));\n    float n = noise(gv*5., 1.);\n    vec3 col = selectColor(n*n);//hsv2rgb(vec3(n*n,1.,1.));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slyWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 70, 70, 201], [202, 202, 224, 224, 263], [265, 265, 297, 297, 717], [718, 718, 743, 743, 799], [801, 801, 822, 822, 1336], [1338, 1338, 1374, 1374, 1588], [1589, 1589, 1607, 1607, 1680], [1682, 1682, 1708, 1708, 2316], [2318, 2318, 2375, 2375, 2849]], "test": "untested"}
{"id": "ts2yzw", "name": "shadow mandelbrot", "author": "sanderoneil", "description": "another way to visualize overflow from set", "tags": ["mandelbrot"], "likes": 0, "viewed": 289, "published": 3, "date": "1586357575", "time_retrieved": "2024-07-30T21:14:08.858664", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    \n    uv=uv/(iTime*iTime)*100.0;\n    \n    uv+=(iMouse.xy-iResolution.xy/2.0)/100.0;\n    \n    vec3 iro = vec3(uv.xy,0);\n\tfloat sq=0.0;\n    float sq2=0.0;\n    while (iro.z < 1.0){\n        sq=iro.x*iro.x;\n        sq2=iro.y*iro.y;\n        if (sq+sq2>10.0){\n            break;}\n        iro.x=sq-sq2+uv.x;\n        iro.y=2.0*iro.x*iro.y+uv.y;\n        iro.z+=.1;\n    }\n    \n    // Output to screen\n    fragColor = vec4((sq+sq2-10.0)/10.0,(sq+sq2-10.0)/10.0,iro.z,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2yzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 616]], "test": "untested"}
{"id": "tsjyzw", "name": "Mandelbrot with mouse control", "author": "sanderoneil", "description": "my first shader", "tags": ["mandelbrot"], "likes": 1, "viewed": 306, "published": 3, "date": "1586357040", "time_retrieved": "2024-07-30T21:14:09.702408", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    \n    uv=uv/(iTime)*100.0;\n    \n    uv+=(iMouse.xy-iResolution.xy/2.0)/100.0;\n    \n    vec3 iro = vec3(uv.xy,0);\n\tfloat sq=0.0;\n    float sq2=0.0;\n    while (iro.z < 1.0){\n        sq=iro.x*iro.x;\n        sq2=iro.y*iro.y;\n        if (sq+sq2>10.0){\n            break;}\n        iro.x=sq-sq2+uv.x;\n        iro.y=2.0*iro.x*iro.y+uv.y;\n        iro.z+=.1;\n    }\n    \n    // Output to screen\n    fragColor = vec4(cos(sq),cos(sq2),iro.z,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjyzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 589]], "test": "untested"}
{"id": "Wdjyzm", "name": "Poincaré Disc Tilings", "author": "mla", "description": "The Poincaré disc model of 2d hyperbolic space. Lots of controls, see code header.\n\nInspired by discussion here: [url]https://www.shadertoy.com/view/3d2cz1[/url]", "tags": ["disc", "hyperbolic", "poincare"], "likes": 12, "viewed": 666, "published": 3, "date": "1586349483", "time_retrieved": "2024-07-30T21:14:10.579064", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Tiling the Poincare Disc\n//\n// Construct 2,P,Q hyperbolic triangle, centred at the origin, with\n// sides on the x and y axes, and a circular side making angles PI/P\n// and PI/Q with the first two sides. Fold into triangle by iterated\n// reflection in its sides (so the triangle is a fundamental region\n// for the group of reflections). Show resulting tiling.\n//\n// Lots of options:\n// 1,2,3: show different edge types\n// c: clip to unit disc\n// h: halfplane\n// i: use ideal triangle (2,inf,inf)\n// m: mouse isometry\n// n: null rotation\n// p: progressive folding\n// t: show parity\n// z: exponential zoom out (halfplane only)\n//\n////////////////////////////////////////////////////////////////////////////////\n\nint P = 7, Q = 4; // Triangle is (2,P,Q) with 1/P + 1/Q < 1/2\n\nbool dotwotone = true;      // Show parity of fundamental regions\nbool doedge1 = true;        // Show x-axis edge\nbool doedge2 = true;        // Show y-axis edge\nbool doedge3 = true;        // Show circular edge\nbool donullrotation = true; // Do a \"null rotation\"\nbool domouse = true;        // Invert origin to mouse position\nbool dozoom = false;        // Zoom out, in halfplane mode only\nbool dohalfplane = false;   // Show the halfplane model, instead of the disc\nbool doideal = false;       // Use ideal (2,inf,inf) triangle instead of (2,P,Q)\nbool doprogressive = false; // Progressively increase max number of folds\nbool doclip = true;        // Clip to unit disc\n\nfloat PI = 3.141592654;\n\n// Compute parameters for hyperbolic triangle, with angles 2,a,b. You\n// might want to draw a picture for this. Triangle sides are x=0,y=0\n// and a circular arc, centre (x,y) and radius r (with r2 = r*r). The\n// arc needs to be a \"straight line\" in the disc model, which means it\n// must intersect the unit disc at right angles. This results in\n// condition (i) by Pythagoras' Theorem. The arc must intersect the\n// x-axis at angle a, and the y-axis at angle b, which give conditions\n// (ii) and (iii).\n\nvec4 solve(float a, float b) {\n  // (i) r^2 + 1 = x^2 + y^2 - condition to be orthogonal to unit circle\n  // (ii) r cos(a) = x => x = r/cos(a)\n  // (iii) r cos(b) = y => y = r/cos(b)\n  float r2 = 1.0/(cos(a)*cos(a) + cos(b)*cos(b) - 1.0);\n  float r = sqrt(r2);\n  float x = r*cos(a);\n  float y = r*cos(b);\n  return vec4(x,y,r,r2);\n}\n\nfloat ds;\nvec3 diagram(vec2 z, vec2 m) {\t\n    ds = max(1.0,abs(1.0-dot(z,z)));\n    ds /= (0.5*iResolution.y);\n  vec4 T = doideal ? solve(PI/3.0,0.0) : solve(PI/float(P),PI/float(Q));\n  if (dohalfplane) {\n    z.y += 1.0;\n    if (dozoom) z *= exp(0.41*iTime);\n    z.y += 1.0;\n    z *= 2.0/dot(z,z);\n    z.y -= 1.0;\n  }\n  // Map origin to m with an inversion\n  if (domouse && m != vec2(0)) {\n    float k = 1.0/dot(m,m);\n    vec2 c = k*m; // m inverted in unit circle\n    float t = (k-1.0)/dot(z-c,z-c);\n    z = t*z+(1.0-t)*c;\n    z.x = -z.x; // Keep chirality\n  }\n  if (doclip && dot(z,z) > 1.0) return vec3(0);\n  if (donullrotation) {\n    // Can't do this with an inversion, so map to halfplane, where\n    // it's just a  translation.\n    vec2 c = vec2(0,-1);\n    z -= c;\n    z *= 2.0/dot(z,z);\n    z.x += 0.2*iTime;\n    z *= 2.0/dot(z,z);\n    z += c;\n  }\n  vec2 a = T.xy; float r = T.z, r2 = T.w;\n  int nsteps = !doprogressive ? 50 : min(50,int(iTime));\n  int i, folds = 0;\n  for (i = 0; i < nsteps; i++) {\n    int folds1 = int(z.x < 0.0) + int(z.y < 0.0);\n    z = abs(z);\n    float k = dot(z-a,z-a);\n    if (k < r2) {\n      folds1++;\n      z = r2*(z-a)/k + a;\n    }\n    if (folds1 == 0) break;\n    folds += folds1;\n  }\n  if (i == nsteps) return vec3(0);\n  // We have now folded the original point z into the fundamental\n  // region, now draw whatever should be in there. Things get smaller\n  // as we move outwards in the disc, so need a scale factor.\n  float scalefactor = abs(1.0 - dot(z,z));\n  vec3 col = vec3(1,1,0);\n  // Euclidean distances to edge of fundamental regions\n  float d1 = abs(z.x);\n  float d2 = abs(z.y);\n  float d3 = abs(length(z-a)-r);\n    //ds = fwidth(length(z));\n  // Desired widths, appropriately scaled.\n  float ewidth = scalefactor*0.00+ds;\n  float lwidth = scalefactor*0.005;\n  if (dotwotone) {\n    // Keep Fabrice happy with a smooth blend between tiles\n    // This is easy with only two tile colours.\n    float d = min(min(d1,d2),d3);\n    col *= 0.5+0.5*smoothstep(-ewidth,+ewidth, folds%2 == 0 ? d : -d);\n  }\n  if (doedge1 || doedge2 || doedge3) {\n    // Draw the edges of the region, if desired.\n    float d = 1e8;\n    if (doedge1) d = min(d,d1);\n    if (doedge2) d = min(d,d2);\n    if (doedge3) d = min(d,d3);\n    // But make him unhappy with a pixel-independent minimum line width.\n    col = mix(vec3(0),col,smoothstep(0.5*lwidth,lwidth+2.0*ds,d));\n    //if (fwidth(length(z)) > 0.1) col = vec3(0);\n  }\n  return col;\n}\n\nbool key(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nconst int CHAR_0 = 48;\nconst int CHAR_C = 67;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_P = 80;\nconst int CHAR_T = 84;\nconst int CHAR_Z = 90;\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  dotwotone = dotwotone != key(CHAR_T);\n  doedge1 = doedge1 != key(CHAR_0+1);\n  doedge2 = doedge2 != key(CHAR_0+2);\n  doedge3 = doedge3 != key(CHAR_0+3);\n  donullrotation = donullrotation != key(CHAR_N); \n  domouse = domouse != key(CHAR_M); \n  dozoom = dozoom != key(CHAR_Z); // halfplane only\n  dohalfplane = dohalfplane != key(CHAR_H);\n  doideal = doideal != key(CHAR_I);\n  doprogressive = doprogressive != key(CHAR_P);\n  doclip = doclip != key(CHAR_C);\n  \n  vec2 p = vec2((2.0*fragCoord-iResolution.xy)/iResolution.y);\n  vec2 P = iMouse.x <= 0.0 ? vec2(0)\n    : vec2((2.0*iMouse.xy-iResolution.xy)/iResolution.y);\n  vec3 col = diagram(p,P);\n  fragColor = vec4(pow(col,vec3(0.4545)),1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wdjyzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2060, 2060, 2090, 2242, 2391], [2403, 2403, 2433, 2433, 4844], [4846, 4846, 4866, 4866, 4926], [5136, 5136, 5189, 5189, 5880]], "test": "untested"}
{"id": "tdBczm", "name": "incomplete circle experiment", "author": "benhardy", "description": "just circles and stuff, using the kind of min/max distance functions used in raymarching to perform csg in 2d.\n\nridiculous overkill on the antialiasing.", "tags": ["2d", "geometry"], "likes": 4, "viewed": 296, "published": 3, "date": "1586345911", "time_retrieved": "2024-07-30T21:14:11.557448", "image_code": "float circle(vec2 pos, vec2 centre, float radius) {\n\n\treturn length(pos - centre) - radius;\n}\n\nfloat edge(float dist, float thickness) {\n    return abs(dist) - thickness;\n}\n\n#define ID_LEFT 1.0\n#define ID_MIDDLE 2.0\n#define ID_RIGHT 3.0\n\nvec2 measure(vec2 uv )\n{ \n    vec3 col = vec3(0);\n    vec2 center = vec2(0);\n    float rad = 0.25;\n    float thicc = 0.005;\n    vec2 movingCentre = 0.125 * vec2( sin(iTime), cos(iTime*1.1));\n    \n    // the red one\n\tfloat c1 = circle(uv, vec2(-0.25, 0), 0.252);\n    // the blue one\n\tfloat c4 = circle(uv, vec2(0.25, 0), 0.252);\n    // the green one\n    float c3 = circle(uv, movingCentre, 0.202);\n    // the hole around the green one\n    float hole = circle(uv, movingCentre, 0.252);\n\n    float left = max(c1, -hole);\n    if (left <= 0.0) {\n        return vec2(left, ID_LEFT);\n    }\n    \n    float right = max(c4, -hole);\n    if (right <= 0.0) {\n        return vec2(right, ID_RIGHT);\n    }\n    if (c3 <= 0.0) {\n        return vec2(c3, ID_MIDDLE);\n    }\n}\n\n#define THICC 0.005\n#define NORM_DELTA 0.00001\n\nvec3 trace(vec2 uv) {\n    vec2 di = measure(uv);\n    vec2 dx = measure(uv + vec2(-NORM_DELTA, 0));\n    vec2 dy = measure(uv + vec2(0, -NORM_DELTA));\n    vec2 dx2 = measure(uv + vec2(NORM_DELTA, 0));\n    vec2 dy2 = measure(uv + vec2(0, NORM_DELTA));\n    vec2 normal = normalize(vec2(dx2.x - dx.x, dy2.x - dy.x));\n    vec2 toLight = normalize(vec2(-0.5, 1.0));\n    float lightD = dot(normal, toLight);\n    vec3 lighting =  vec3(lightD, lightD, lightD);\n    vec3 col = vec3(0);\n    \n    if (di.y == ID_LEFT) {\n        if (di.x < -THICC) {\n            float m = fract(di.x*50.0);\n            col = vec3(0.5,0.1,0.1);\n            if (m < 0.15) {\n                col *= 0.7;\n            }\n        } else {\n            col = vec3(1,1,1);\n        }\n    }\n    \n    if (di.y == ID_RIGHT) {\n        if (di.x < -THICC) {\n            float m = fract(di.x*50.0);\n            col = vec3(0.1,0.1,0.5);\n            if (m < 0.15) {\n                col *= 0.7;\n            }\n        } else {\n            col = vec3(1,1,1);\n        }\n    }\n    \n    if (di.y == ID_MIDDLE) {\n        if (di.x < -THICC) {\n            float m = fract(di.x*50.0);\n            col = vec3(0.1,0.5,0.1);\n            if (m < 0.15) {\n                col *= 0.7;\n            }\n        } else {\n            col = vec3(1,1,1);\n        }\n    }\n    \n    if (di.x < -THICC && di.y > 0.0) {\n        float ratio = cos(di.x * 10.0);\n\t\tcol += lighting * 0.5 * ratio;\n    }\n    return clamp(col, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    float aspect = iResolution.y / iResolution.x;\n    \n    \n    vec3 col = vec3(0);\n    for (int i=-2; i <= 2; i++) {\n        float dx = 0.20 * float(i);\n\t    for (int j = -2; j <= 2; j++) {\n            float dy = 0.20 * float(j);\n            vec2 subpixel = fragCoord+vec2(dx,dy);\n\t\t    vec2 uv = (subpixel/iResolution.xy-vec2(0.5)) \n                * vec2(1, aspect);\n            col += trace(uv);\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col / 25.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdBczm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 93], [95, 95, 136, 136, 172], [238, 238, 262, 262, 992], [1042, 1042, 1063, 1063, 2493], [2495, 2495, 2552, 2552, 3035]], "test": "untested"}
{"id": "Wdjczm", "name": "Stretchy plasma", "author": "aolsystemmsg", "description": "Far out man", "tags": ["trippy", "acid"], "likes": 2, "viewed": 328, "published": 3, "date": "1586345293", "time_retrieved": "2024-07-30T21:14:12.541816", "image_code": "#define PI 3.1415926535897932384626433832795\n\n//#define u_k vec2(.001, .001)\n#define in_w = 449\n#define in_h = 483\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat v = 0.0;\n    vec2 u_k = vec2(sin(iTime * 2.0) * .05 + .051, cos(iTime * 2.0) * .050 + .051);\n    vec2 c = fragCoord * u_k - u_k/2.0;\n    v += sin((c.x+iTime));\n    v += sin((c.y+iTime)/2.0);\n    v += sin((c.x+c.y+iTime)/2.0);\n    c += u_k/2.0 * vec2(sin(iTime/3.0), cos(iTime/2.0));\n    v += sin(sqrt(c.x*c.x+c.y*c.y+1.0)+iTime);\n    v = v/2.0;\n    vec3 col = vec3(1, sin(PI*v), cos(PI*v));\n\n    // Output to screen\n    fragColor = vec4(col*.5 + .5, 1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wdjczm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 174, 174, 637]], "test": "untested"}
{"id": "Wd2yzm", "name": "Big Momavirus", "author": "dr2", "description": "You have been warned...", "tags": ["voronoi", "tunnel", "texture", "heightmap", "virus"], "likes": 10, "viewed": 432, "published": 3, "date": "1586344462", "time_retrieved": "2024-07-30T21:14:13.632899", "image_code": "// \"Big Momavirus\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// You have been warned...\n\n// See \"Scrolling Texture Heightmap\" for tunnel construction.\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrTorus4Df (vec3 p, float ri, float rc);\nvec3 SphFib (vec3 v, float n);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec3 RotToDir (vec3 v1, vec3 v2, vec3 p);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv3 (vec3 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (vec2 vId);\nvec4 LoadTx (vec2 uv);\n\nvec3 ltDir, vbalPos;\nvec2 trkFx, trkFy, trkAx, trkAy, trkFw, trkAw;\nfloat dstFar, tCur, tunRad, lmpSep, txOrg, txAsp, vbalSpn, vbalDir;\nint idObj;\nconst int idWal = 1, idFlr = 2, idLmp = 3, idArch = 4, idRail = 5, idTie = 6,\n   idVbal = 7, idVspk = 8, idVcap = 9;\nconst float pi = 3.14159;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nvec3 TrackPos (float z)\n{\n  return vec3 (dot (trkAx, sin (trkFx * z)), dot (trkAy, sin (trkFy * z)), z);\n}\n\nvec3 TrackVel (float z)\n{\n  return normalize (vec3 (dot (trkAx, trkFx * cos (trkFx * z)),\n     dot (trkAy, trkFy * cos (trkFy * z)), 1.));\n}\n\nfloat TSurfHt (vec2 tc)\n{\n  return LoadTx (tc * txAsp).x;\n}\n\nfloat RdTun (vec3 p)\n{\n  float a, rh;\n  a = 0.5 * (atan (- p.x, p.y) / pi + 1.);\n  rh = TSurfHt (vec2 ((p.z - txOrg) / (2. * pi * tunRad), a));\n  return tunRad + dot (trkAw, sin (trkFw * p.z)) -\n     rh * (1. - 0.5 * smoothstep (0.5, 1., p.y / tunRad));\n}\n\nfloat TunDf (vec3 p)\n{\n  vec3 q;\n  vec2 rt;\n  float dMin, d;\n  dMin = dstFar;\n  p.xy -= TrackPos (p.z).xy;\n  d = RdTun (p) - length (p.xy);\n  DMIN (idWal);\n  d = (0.82 - 0.02 * p.x * p.x) * tunRad + p.y;\n  DMIN (idFlr);\n  return 0.5 * dMin;\n}\n\nfloat TunRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 160; j ++) {\n    d = TunDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 TunNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.001, -0.001);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = TunDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat VbalDf (vec3 p, float dMin)\n{\n  vec3 q, qn, uf;\n  float d, rad, len, h, sbFac;\n  sbFac = 1.7;\n  dMin /= 0.6 * sbFac;\n  q = p / sbFac;\n  rad = 1.;\n  qn = normalize (q);\n  uf = SphFib (qn, 120.);\n  d = PrSphDf (q, rad * (1. - 0.05 * smoothstep (0.1, 0.2, length (qn - uf))));\n  DMIN (idVbal);\n  q = RotToDir (uf, vec3 (0., 0., 1.), q - uf);\n  h = Hashfv3 (41. * uf);\n  len = 0.3 * (1. - 0.2 * h);\n  q.z -= len;\n  d = PrCylDf (q, 0.04 * (1. - 0.1 * q.z / len), len);\n  DMIN (idVspk);\n  q.z -= len + 0.05;\n  q.xy = Rot2D (q.xy, pi * h / 3.);\n  q.xy = Rot2D (q.xy, 2. * pi * floor (3. * atan (q.y, - q.x) / (2. * pi) + 0.5) / 3.);\n  q.x += 0.08;\n  d = PrSphDf (q * vec3 (1., 1., 1.3), 0.1);\n  DMIN (idVcap);\n  return 0.6 * sbFac * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d;\n  dMin = dstFar;\n  qq = p;\n  qq.xy -= TrackPos (qq.z).xy;\n  q = qq;\n  d = length (max (abs (vec2 (abs (q.x) - 0.8, q.y + 0.82 * tunRad)) -\n      vec2 (0.06, 0.25), 0.));\n  DMIN (idRail);\n  q.y -= -0.82 * tunRad - 0.05;\n  q.z = mod (q.z + 1., 2.) - 1.;\n  d = PrBoxDf (q, vec3 (1., 0.2, 0.1));\n  DMIN (idTie);\n  q = qq;\n  q.z = mod (q.z + lmpSep, 2. * lmpSep) - lmpSep;\n  d = PrTorus4Df (q, 0.16, tunRad - 0.16) - 0.15 *\n     (0.7 + 0.3 * sqrt (abs (sin (31. * atan (q.y, q.x)))));\n  DMIN (idArch);\n  q.y -= tunRad - 0.5;\n  d = PrSphDf (q, 0.3);\n  DMIN (idLmp);\n  q = p - vbalPos;\n  d = PrSphDf (q, tunRad - 0.9);\n  if (d < 0.1) {\n    q.yz = Rot2D (q.yz, vbalSpn);\n    q.xz = Rot2D (q.xz, vbalDir);\n    dMin = VbalDf (q, dMin);\n  } else dMin = min (dMin, d);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.001, -0.001);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat RippleHt (vec2 p)\n{\n  vec2 q;\n  float s1, s2;\n  q = Rot2D (p, -0.02 * pi);\n  s1 = abs (sin (4. * pi * abs (q.y + 1.5 * Fbm2 (0.7 * q))));\n  s1 = (1. - s1) * (s1 + sqrt (1. - s1 * s1));\n  q = Rot2D (p, 0.01 * pi);\n  s2 = abs (sin (3.1 * pi * abs (q.y + 1.9 * Fbm2 (0.5 * q))));\n  s2 = (1. - s2) * (s2 + sqrt (1. - s2 * s2));\n  return mix (s1, s2, 0.1 + 0.8 * smoothstep (0.3, 0.7, Fbm2 (2. * p)));\n}\n\nvec3 RippleNorm (vec2 p, vec3 vn, float f)\n{\n  vec2 e;\n  float h;\n  e = vec2 (0.002, 0.);\n  h = RippleHt (p);\n  vn.xy = Rot2D (vn.xy, f * (RippleHt (p + e) - h));\n  vn.zy = Rot2D (vn.zy, f * (RippleHt (p + e.yx) - h));\n  return vn;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 vn, col, q;\n  vec2 vf;\n  float dstObj, dstTun, dFac, s, att;\n  dstTun = TunRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  if (min (dstTun, dstObj) < dstFar) {\n    if (dstTun < dstObj) {\n      ro += dstTun * rd;\n      vn = TunNf (ro);\n      dFac = (1. - smoothstep (0.2, 0.5, dstTun / dstFar));\n      q.xy = TrackPos (ro.z).xy;\n      ro.xy -= q.xy;\n      if (idObj == idWal) {\n        vn = VaryNf (8. * ro, vn, 8. * dFac * dFac * (1. - 0.5 * smoothstep (0.7, 1., - vn.y)));\n        s = Fbm3 (32. * ro);\n        col4 = vec4 (mix (vec3 (0.4, 0.4, 0.45), vec3 (0.45, 0.4, 0.3), smoothstep (0.4, 0.5, s)), 0.05);\n      } else if (idObj == idFlr) {\n        s = dFac * (1. - smoothstep (-0.2, -0.1, dot (rd, vn)));\n        vn = RippleNorm (ro.zx, vn, 4. * s);\n        vn = VaryNf (16. * ro, vn, s);\n        col4 = vec4 (vec3 (0.5, 0.35, 0.2) * (1. - 0.2 * smoothstep (0.4, 0.85,\n           length (vec2 (ro.x, mod (ro.z + lmpSep, 2. * lmpSep) - lmpSep)) / tunRad)), 0.);\n      }\n      ro.xy += q.xy;\n    } else {\n      ro += dstObj * rd;\n      q = ro - vbalPos;\n      vn = ObjNf (ro);\n      if (idObj >= idVbal) {\n        q.yz = Rot2D (q.yz, vbalSpn);\n        q.xz = Rot2D (q.xz, vbalDir);\n      }\n      if (idObj == idLmp) {\n        col4 = vec4 (vec3 (1., 1., 0.7) * 0.5 * (1. - vn.y), -1.);\n      } else if (idObj == idRail) {\n        col4 = vec4 (0.5, 0.5, 0.55, 0.3);\n      } else if (idObj == idTie) {\n        col4 = vec4 (0.25, 0.15, 0., 0.);\n      } else if (idObj == idArch) {\n        col4 = vec4 (0.3, 0.3, 0.25, 0.05);\n        vn = VaryNf (32. * ro, vn, 2.);\n      } else if (idObj == idVbal) {\n        col4 = vec4 (0.5, 0.3, 0.1, 0.1);\n        vf = vec2 (8., 8.);\n      } else if (idObj == idVspk) {\n        col4 = vec4 (0.5, 0.6, 0.5, 0.4);\n        vf = vec2 (64., 0.1);\n      } else if (idObj == idVcap) {\n        col4 = vec4 (0.9, 0., 0., 0.3);\n        vf = vec2 (64., 2.);\n      }\n      if (idObj == idVbal || idObj == idVspk || idObj == idVcap) {\n        if (idObj == idVbal) col4.rgb = mix (col4.rgb, 1.5 * vec3 (0.2, 0.2, 1.), \n           SmoothBump (0.45, 0.55, 0.005, mod (0.7 * tCur, 1.)));\n        else if (idObj == idVspk || idObj == idVcap) col4.rgb = mix (col4.rgb, 1.5 * vec3 (1., 1., 0.9),\n           SmoothBump (0.49, 0.51, 0.005, mod (0.5 * length (q) - 0.7 * tCur, 1.)));\n        vn.yz = Rot2D (vn.yz, vbalSpn);\n        vn.xz = Rot2D (vn.xz, vbalDir);\n        vn = VaryNf (vf.x * q, vn, vf.y);\n        vn.xz = Rot2D (vn.xz, - vbalDir);\n        vn.yz = Rot2D (vn.yz, - vbalSpn);\n      }\n      if (col4.a >= 0.) col4.rgb *= (1. - 0.4 * smoothstep (0.4, 0.85,\n         abs (mod (ro.z + lmpSep, 2. * lmpSep) - lmpSep) / tunRad));\n      else col = col4.rgb;\n    }\n    if (col4.a >= 0.) col = col4.rgb * (0.2 + 0.1 * max (vn.y, 0.) + 0.8 * max (dot (vn, ltDir), 0.) +\n       col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.));\n    if (idObj == idFlr || idObj == idRail || idObj == idTie)\n       col *= 0.9 + 0.1 * smoothstep (0., 0.5, length (ro.xz - vbalPos.xz) - 2.);\n    s = min (dstTun, dstObj);\n    att = SmoothMin (350. / pow (s, 2.), 1., 0.5) * (1. - smoothstep (60., 70., s));\n    col *= att;\n  } else col = vec3 (0.);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat;\n  vec3 ro, rd, vd;\n  vec2 uv;\n  float el, az, tunPos, zmFac, t;\n  uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  stDat = Loadv4 (vec2 (0., 0.));\n  tunPos = stDat.y;\n  txOrg = stDat.z;\n  txAsp = stDat.w;\n  stDat = Loadv4 (vec2 (1., 0.));\n  tunRad = stDat.y;\n  az = stDat.z;\n  el = stDat.w;\n  stDat = Loadv4 (vec2 (2., 0.));\n  tCur = stDat.y;\n  trkFx = 2. * pi * vec2 (0.005, 0.0087);\n  trkAx = tunRad * vec2 (2.2, 1.7);\n  trkFy = 2. * pi * vec2 (0.017, 0.0227);\n  trkAy = tunRad * vec2 (0.13, 0.07);\n  trkFw = 2. * pi * vec2 (0.05, 0.028);\n  trkAw = tunRad * vec2 (0.07, 0.04);\n  vd = TrackVel (tunPos);\n  az += 0.5 * pi + atan (- vd.z, vd.x);\n  el += asin (vd.y) - 0.02 * pi;\n  zmFac = 3.5 - 0.5 * SmoothBump (0.3, 0.7, 0.1, abs (az) / pi);\n  t = tunPos + tunRad * sign (0.5 * pi - abs (az)) * (4. + clamp (6. * (Fbm1 (0.02 * tCur) - 0.5), -2.5, 2.5));\n  vbalPos = TrackPos (t);\n  vd = TrackVel (t);\n  vbalDir = -0.5 * pi - atan (vd.z, - vd.x);\n  vbalSpn = -0.5 * pi * tCur;\n  vuMat = StdVuMat (el, az);\n  ro = TrackPos (tunPos) + vuMat * vec3 (0., 0.15, - 0.5) * tunRad;\n  dstFar = 100.;\n  lmpSep = 10.;\n  ltDir = vuMat * normalize (vec3 (0., 0.5, -1.));\n  rd = vuMat * normalize (vec3 (uv , zmFac));\n  rd.zx = Rot2D (rd.zx, 0.1 * atan (ro.x));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrTorus4Df (vec3 p, float ri, float rc)\n{\n  vec2 q;\n  q = vec2 (length (p.xy) - rc, p.z);\n  q *= q;\n  return sqrt (sqrt (dot (q * q, vec2 (1.)))) - ri;\n}\n\nvec3 SphFib (vec3 v, float n)\n{   // Keinert et al's inverse spherical Fibonacci mapping\n  vec4 b;\n  vec3 vf, vfMin;\n  vec2 ff, c;\n  float fk, ddMin, dd, a, z, ni;\n  const float phi = 1.618034;\n  ni = 1. / n;\n  fk = pow (phi, max (2., floor (log (n * pi * sqrt (5.) * dot (v.xy, v.xy)) /\n     log (phi + 1.)))) / sqrt (5.);\n  ff = vec2 (floor (fk + 0.5), floor (fk * phi + 0.5));\n  b = vec4 (ff * ni, pi * (fract ((ff + 1.) * phi) - (phi - 1.)));\n  c = floor ((0.5 * mat2 (b.y, - b.x, b.w, - b.z) / (b.y * b.z - b.x * b.w)) *\n     vec2 (atan (v.y, v.x), v.z - (1. - ni)));\n  ddMin = 4.1;\n  for (int j = 0; j < 4; j ++) {\n    a = dot (ff, vec2 (j - 2 * (j / 2), j / 2) + c);\n    z = 1. - (2. * a + 1.) * ni;\n    vf = vec3 (sin (2. * pi * fract (phi * a) + vec2 (0.5 * pi, 0.)) * sqrt (1. - z * z), z);\n    dd = dot (vf - v, vf - v);\n    if (dd < ddMin) {\n      ddMin = dd;\n      vfMin = vf;\n    }\n  }\n  return vfMin;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec3 RotToDir (vec3 v1, vec3 v2, vec3 p)\n{\n  vec3 n;\n  float c;\n  n = normalize (cross (v1, v2));\n  c = dot (v1, v2);\n  return c * p + sqrt (1. - c * c) * cross (n, p) + (1. - c) * dot (n, p) * n;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 LoadTx (vec2 uv)\n{\n  return texture (txBuf, uv);\n}\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Big Momavirus\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat SmoothMin (float a, float b, float r);\nvoid HexVorInit ();\nvec4 HexVor (vec2 p);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst float pi = 3.14159;\n\nfloat TSurfHt (vec2 tc)\n{\n  vec4 vc;\n  vc = HexVor (tc);\n  return max (0.3 * SmoothMin (0.4, 0.3 * vc.x, 0.1) * (1. - 0.3 * dot (vc.yz, vc.yz)) *\n     (1. + 2.5 * vc.w), 0.);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, stDat, dateCur;\n  vec2 canvas, pxIv;\n  float tCur, tBgn, az, el, tunRad, tunPos, s, si, txOrg, txAsp;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  pxIv = floor (fragCoord);\n  txAsp = 3./8.;\n  if (pxIv.x >= txSize.x || pxIv.y >= txAsp * txSize.x) discard;\n  if (iFrame <= 5) tBgn = mod (floor (337. * dateCur.w), 3600.);\n  else tBgn = Loadv4 (vec2 (2., 0.)).z;\n  tCur = mod (tCur, 3600.) + tBgn;\n  az = pi;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    el = clamp (el + 0.5 * pi * mPtr.y, -0.1 * pi, 0.1 * pi);\n    az = mod (az + pi + 2. * pi * mPtr.x, 2. * pi) - pi;\n  }\n  tunRad = 4.;\n  tunPos = 6. * tCur;\n  HexVorInit ();\n  txOrg = tunPos;\n  s = 2. * pi * tunRad / txAsp;\n  if (abs (az) > 0.6 * pi) txOrg -= s - tunRad;\n  else if (abs (az) > 0.4 * pi) txOrg -= 0.5 * s;\n  else txOrg -= tunRad;\n  si = txSize.x / (2. * s);\n  txOrg = floor (txOrg * si) / si;\n  stDat = vec4 (TSurfHt (2. * ((s * pxIv / txSize + vec2 (txOrg, 0.)))), 0., 0., 0.);\n  if (pxIv.y == 0.) {\n    if (pxIv.x == 0.) stDat.yzw = vec3 (tunPos, txOrg, txAsp);\n    else if (pxIv.x == 1.) stDat.yzw = vec3 (tunRad, az, el);\n    else if (pxIv.x == 2.) stDat.yz = vec2 (tCur, tBgn);\n  }\n  Savev4 (pxIv, stDat, fragColor, fragCoord);\n}\n\nvec2 gVec[7], hVec[7];\nconst float sqrt3 = 1.73205;\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  amp = 0.8;\n  p = p.yx;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * vec2 (cos (a), sin (a)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  return vec4 (SmoothMin (sd.y, sd.z, 0.3) - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2yzm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1132, 1132, 1157, 1157, 1238], [1240, 1240, 1265, 1265, 1380], [1382, 1382, 1407, 1407, 1441], [1443, 1443, 1465, 1465, 1698], [1700, 1700, 1722, 1722, 1942], [1944, 1944, 1977, 1977, 2154], [2156, 2156, 2177, 2177, 2420], [2422, 2422, 2457, 2457, 3161], [3163, 3163, 3185, 3185, 3990], [3992, 3992, 4025, 4025, 4202], [4204, 4204, 4225, 4225, 4468], [4470, 4470, 4495, 4495, 4874], [4876, 4876, 4920, 4920, 5109], [5111, 5111, 5146, 5146, 8352], [8354, 8354, 8410, 8410, 9773], [9775, 9775, 9807, 9807, 9907], [9909, 9909, 9942, 9942, 9969], [9971, 9971, 10013, 10013, 10064], [10066, 10066, 10113, 10113, 10225], [10227, 10227, 10258, 10315, 11144], [11146, 11146, 11191, 11191, 11294], [11296, 11296, 11353, 11353, 11436], [11438, 11438, 11474, 11474, 11680], [11682, 11682, 11724, 11724, 11880], [11882, 11882, 11912, 11912, 12025], [12059, 12059, 12083, 12083, 12148], [12150, 12150, 12174, 12174, 12227], [12229, 12229, 12253, 12253, 12365], [12367, 12367, 12391, 12391, 12611], [12613, 12613, 12638, 12638, 12784], [12786, 12786, 12811, 12811, 12997], [12999, 12999, 13024, 13024, 13249], [13251, 13251, 13273, 13273, 13427], [13429, 13429, 13450, 13450, 13605], [13607, 13607, 13628, 13628, 13783], [13785, 13785, 13814, 13814, 14026], [14028, 14028, 14067, 14067, 14252], [14319, 14319, 14342, 14342, 14374], [14376, 14376, 14400, 14400, 14450]], "test": "untested"}
{"id": "3s2cRm", "name": "Hexagram Vesica", "author": "Dain", "description": "Pretty basic, vesica is used for tips of hexagram", "tags": ["hexagram", "vesica"], "likes": 5, "viewed": 349, "published": 3, "date": "1586343218", "time_retrieved": "2024-07-30T21:14:14.484622", "image_code": "// The MIT License\n\nfloat sdHexagramVesica(vec2 p, float r, float d)\n{ \n    //Hexagram stuff by iq\n \tconst vec4 k = vec4(-0.5,0.86602540378,0.57735026919,1.73205080757);\n\t\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n \tp -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    \n   // p = abs(p) - r;//optional fun\n    p = abs(p);//abs again to prevent wigging out on inside, and make it hollow\n\t\n    //IQ Vesica code\n    float b = sqrt(r*r-d*d);  // can delay this sqrt by rewriting the comparison\n    return ((p.y-b)*d > p.x*b) ? length(p-vec2(0.0,b))*sign(d)\n                               : length(p-vec2(-d,0.0))-r;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n\tfloat d = sdHexagramVesica( p, 0.37, -0.25*abs(cos(iTime)) )- 0.2*(sin(iTime*1.3));\n\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-4.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(140.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.005,abs(d)) );\n\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2cRm.jpg", "access": "api", "license": "mit", "functions": [[20, 20, 70, 98, 655], [656, 656, 713, 713, 1141]], "test": "untested"}
{"id": "wsSyzm", "name": "Outside Rounds", "author": "nickcody", "description": "Sound reactive geometry (under construction)", "tags": ["music", "geometry"], "likes": 1, "viewed": 246, "published": 3, "date": "1586318616", "time_retrieved": "2024-07-30T21:14:15.286478", "image_code": "#define NUM_CIRCLES 10\n\nint test(vec2 coord, vec2 center, float radius, float tolerance) {\n    float dist_to_center = sqrt(pow(coord.x - center.x,2.0) + pow(coord.y - center.y,2.0));\n    float delta =dist_to_center-radius;\n\n    if (abs(delta) < tolerance)\n        return 0;\n    else if (delta < 0.0)\n        return -1;\n    else\n        return 1;\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord) {\n    vec3 white = vec3(1.0, 1.0, 1.0);\n    vec3 black = vec3(0.0, 0.0, 0.0);\n\n    vec2 normCoord = fragCoord.xy/iResolution.x;\n\tfloat cw = 1.0/float(NUM_CIRCLES);\n    int i = int(normCoord.x * float(NUM_CIRCLES));\n    vec2 center = vec2((cw*float(i) + cw*float(i+1))/2.0, 0.3);\n    \n    float scale = 0.25;\n    float M = 48000.0;\n    #define freq(f) abs( (f)/(M/4.)  -normCoord.x) * iResolution.x * scale\n    \n    float s = float(512.0 * normCoord.x);\n    vec4 o = texture(iChannel0,vec2(s,.25));\n\n    \n    float radius = o.x / 2.0;\n\n    int t = test(normCoord, center, radius, .001);\n\n    if (t > 0)\n        out_color = vec4( black, 1.0);\n    else if (t == 0)\n        out_color = vec4( white, 1.0);\n    else {\n        vec3 col = 0.5 + 0.5*cos(iTime+normCoord.xyx+vec3(0,2,4));\n        out_color = vec4(col,1.0);\n    }\n\t    \n}", "image_inputs": [{"id": 21819, "src": "https://soundcloud.com/talariel/outside", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsSyzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 90, 90, 347], [349, 349, 401, 401, 1227]], "test": "untested"}
{"id": "tsByRm", "name": "the army of balls", "author": "hazenn", "description": "bluh", "tags": ["raymarching"], "likes": 3, "viewed": 440, "published": 3, "date": "1586301149", "time_retrieved": "2024-07-30T21:14:16.057417", "image_code": "\n#define MAX_STEPS 1000\n#define MAX_DIST 1000.\n#define SURF_DIST .01\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\nfloat smin( float a, float b)\n{\n\n    return smin(a,b,25.);\n}\n\nstruct RM{\n    float d;\n    int steps;\n};\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat GetDist(in vec3 p){\n    float d = MAX_DIST;\n    p = fract(abs(p)/3.)*3.-1.5;\n    d = length(p)-(0.2+0.4*abs(cos(iTime)));\n    d = smin(d,\n            length(p+0.2)-(0.2+0.4*abs(sin(iTime)))\n            );\n    d = smin(d,\n            length(p-0.5)-(0.2+0.4*abs(sin(iTime)+1.))\n            );\n    return d;\n}\n\n\n\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);\n    vec2 e = vec2(0.1,0);\n    vec3 n = d - vec3(\n    \tGetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    return normalize(n);\n    \n}\nRM RayMarch(vec3 ro, vec3 rd){\n    float d0 = 0.;\n    int steps = 0;\n    for(int i=0;i<MAX_STEPS;i++){\n        steps = i;\n        vec3 p = ro + rd*d0;\n        float dS = GetDist(p);\n        d0 += dS;\n        if (d0>MAX_DIST || dS < SURF_DIST) break;\n    }\n\n    return RM(d0,steps);\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.yy;\n    vec3 ro = vec3(10.*uv+2.,-iTime);\n    vec3 rd = (rot(vec3(0.,1.,0.),-(1.+abs(sin(iTime))))*vec4(0.75, uv.y, uv.x,1.)).xyz;\n    RM rm = RayMarch(ro,rd);\n    \n    float d = rm.d;\n    \n    \n    \n    \n    vec3 col = vec3(0);\n\t\n    col+= 1.-0.30*float(rm.steps);\n    col += 0.1*d;\n    col /= 10.;\n    col += 0.5+0.5*GetNormal(ro+rd*d); //normals\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "mat4 rot(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsByRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 111, 111, 185], [186, 186, 217, 217, 246], [290, 290, 344, 344, 446], [448, 448, 473, 473, 760], [764, 764, 787, 787, 970], [971, 971, 1001, 1001, 1254], [1260, 1260, 1317, 1317, 1786]], "test": "untested"}
{"id": "tdBczw", "name": "Trying 2 AI", "author": "wyatt", "description": "Again trying to use a metric map to texture synthesize", "tags": ["experiment"], "likes": 13, "viewed": 497, "published": 3, "date": "1586294547", "time_retrieved": "2024-07-30T21:14:16.841321", "image_code": "// Fork of \"Graph Network\" by wyatt. https://shadertoy.com/view/tssyDS\n// 2020-04-07 18:45:05\n\nMain {\n    //if (iFrame%I<I-1)discard;\n\tQ = D(U);\n    Q*=0.5+.5*Q.w;\n    //Q *= smoothstep(2.,3.,length(U-Q.xy*R));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texelFetch(iChannel3,ivec2(U),0)\n#define Main void mainImage (out vec4 Q, vec2 U) \n#define Init if (iFrame < 1) \n#define Border if (U.x<1.||R.x-U.x<1.||U.y<1.||R.y-U.y<1.)\n#define T(U,t) texelFetch((t),ivec2(U),0)\n#define f(U,t) length(T((U),(t)).xyz)\n#define I 11\n#define Neighborhood vec4 n = A(U+vec2(0,1)), e = A(U+vec2(1,0)), s = A(U-vec2(0,1)), w = A(U-vec2(1,0)), m = 0.25*(n+e+s+w);\n\nvec2 convo (vec2 U, sampler2D t) {\n\tvec2 r = vec2(0); float d = 0., m=f(U,t);\n    for (int x = -4;x<=4;x++)\n        for (int y = -4;y<=4;y++) {\n        \tvec2 v = vec2(x,y);\n            float z = f(U+v,t);\n            r += (z-m)*v;\n            d += z;\n        }\n    r /= 81.; d /= 81.;\n    return vec2(0.5*length(r),0.3+0.5*(d-m));\n}\n// Dave H\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n", "buffer_a_code": "Main {\n    U *= iChannelResolution[3].x/R.x;\n    Q.xy = convo(U,iChannel3);\n    Q.zw = U;\n}", "buffer_a_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void X(inout vec4 Q, vec2 U, vec4 n) {\n\tif (length(U-n.xy*R)<length(U-Q.xy*R))\n        Q = n;\n}\nMain {\n\tif (iFrame%I==0) Q=A(U);\n    else {\n    \tQ = B(U);\n        float k = exp2(float(I-1-iFrame%I));\n        X(Q,U,B(U+vec2(0,k)));\n        X(Q,U,B(U+vec2(k,0)));\n        X(Q,U,B(U-vec2(0,k)));\n        X(Q,U,B(U-vec2(k,0)));\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n\tQ = C(U);\n    vec4 b = B(U);\n    float e = 1./(1.+.5*length(U-b.xy*R));\n    if (e>Q.w){\n    \tQ = D(b.zw);\n        Q *= Q.w;\n        Q.w = e;\n    }\n    \n    if (iFrame < 1) Q = vec4(0);\n\t\n}", "buffer_c_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n    vec2 v = U;\n    vec2 o = 0.5*R;\n    if (iMouse.z>0.)o=iMouse.xy;\n    v -= o;float a = 0.005;\n    v *= 0.995*mat2(cos(a),sin(-a),sin(a),cos(a));\n    v += o;\n    //if (iMouse.z>0.)v=U;\n\tQ = A(v);\n    \n    vec2 co = convo(U,iChannel0);\n    vec4 color = C(co*R);\n    for (int x = -2; x<=2; x++) \n        for (int y = -2; y<=2; y++) {\n            vec4 z = C(co*R+2.*vec2(x,y));\n        \tif (length(color.xyz-z.xyz)>length(color.xyz-Q.xyz))\n                color = z;\n        } \n    vec4 dQ = color-Q;\n    Neighborhood;\n    //if (iMouse.z>0.) Q += 0.5*Q.w*(m-Q);\n    if (length(dQ)>0.)\n    Q += 0.005*sign(dQ)*(color.w);\n    \n    \n    if (iFrame < 10) {\n    \tQ = D(2.+.8*U*iChannelResolution[3].y/R.y);\n        Q.w=1.;\n    }\n}", "buffer_d_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdBczw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "tdSczw", "name": "Sphere Stanford Bunny", "author": "michael0884", "description": "why", "tags": ["marching", "graph", "mesh"], "likes": 10, "viewed": 684, "published": 3, "date": "1586293830", "time_retrieved": "2024-07-30T21:14:18.300419", "image_code": "//Graph is in Buf A, graph traversal is in Buf B\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    fragColor = texel(ch1, pos);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define N ivec2(17,150)\n#define sN ivec2(36,2)\n#define dt 0.\n\n#define loop(x) for(int i = min(0, iFrame); i < x; i++)\n\nconst int tot_n = N.x*N.y;\n\nivec2 i2xy(ivec3 sid)\n{\n    return sN*ivec2(sid.x%N.x, sid.x/N.x) + sid.yz;\n}\n\nivec3 xy2i(ivec2 p)\n{\n    ivec2 pi = p/sN;\n    return ivec3(pi.x + pi.y*N.x, p.x%sN.x, p.y%sN.y);\n}\n\nfloat F(float d)\n{\n    return 1./(0.1*d*d+1.) - 1.*exp(-1.*d);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nconst int k = 1664525;  \n\nivec4 hash( ivec4 x )\n{\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    return ivec4(x);\n}\n\n#define link0 36\n\nconst float PHI = 0.5*(sqrt(5.) + 1.);\n\nvec2 inverseSF( vec3 p, float n ) \n{\n    float m = 1.0 - 1.0/n;\n    \n    float phi = min(atan(p.y, p.x), PI), cosTheta = p.z;\n    \n    float k  = max(2.0, floor( log(n * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))/ log(PHI+1.0)));\n    float Fk = pow(PHI, k)/sqrt(5.0);\n    vec2  F  = vec2( round(Fk), round(Fk * PHI) ); // k, k+1\n\n    vec2 ka = 2.0*F/n;\n    vec2 kb = 2.0*PI*( fract((F+1.0)*PHI) - (PHI-1.0) );    \n    \n    mat2 iB = mat2( ka.y, -ka.x, \n                    kb.y, -kb.x ) / (ka.y*kb.x - ka.x*kb.y);\n    \n    vec2 c = floor( iB * vec2(phi, cosTheta - m));\n    float d = 8.0;\n    float j = 0.0;\n    for( int s=0; s<4; s++ ) \n    {\n        vec2 uv = vec2( float(s-2*(s/2)), float(s/2) );\n        \n        float i = dot(F, uv + c); // all quantities are ingeters (can take a round() for extra safety)\n        \n        float phi = 2.0*PI*fract(i*PHI);\n        float cosTheta = m - 2.0*i/n;\n        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n        \n        vec3 q = vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta );\n        float squaredDistance = dot(q-p, q-p);\n        if (squaredDistance < d) \n        {\n            d = squaredDistance;\n            j = i;\n        }\n    }\n    return vec2( j, sqrt(d) );\n}\n\nvec4 iSF( vec3 p, float n ) \n{\n    float m = 1.0 - 1.0/n;\n    \n    float phi = min(atan(p.y, p.x), PI), cosTheta = p.z;\n    \n    float k  = max(2.0, floor( log(n * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))/ log(PHI+1.0)));\n    float Fk = pow(PHI, k)/sqrt(5.0);\n    vec2  F  = vec2( round(Fk), round(Fk * PHI) ); // k, k+1\n\n    vec2 ka = 2.0*F/n;\n    vec2 kb = 2.0*PI*( fract((F+1.0)*PHI) - (PHI-1.0) );    \n    \n    mat2 iB = mat2( ka.y, -ka.x, \n                    kb.y, -kb.x ) / (ka.y*kb.x - ka.x*kb.y);\n    \n    vec2 c = floor( iB * vec2(phi, cosTheta - m));\n    float d = 8.0;\n    float j = 0.0;\n    vec4 o;\n    for( int s=0; s<4; s++ ) \n    {\n        vec2 uv = vec2( float(s-2*(s/2)), float(s/2) );\n        \n        o[s] = dot(F, uv + c); \n    }\n    return o;\n}\n\nvec3 fibonacci_sphere(int i, int n)\n{\n    vec2 pt = vec2(2.*PI*mod(float(i)/PHI, 1.), acos(1. - float(2*i+1)/float(n)));\n    return vec3(cos(pt.x)*sin(pt.y), sin(pt.x)*sin(pt.y), cos(pt.y)); \n}\n\n    \nstruct object\n{\n    int id;\n    vec3 X;\n    float bR;\n    vec3 a;\n    vec3 b;\n    vec3 c;\n};\n\nvec3 qtransform(vec4 q, vec3 v)\n{ \n\treturn v + 2.0*cross(cross(v, q.xyz) + q.w*v, q.xyz);\n} \n\n//intersection with the bisector plane\nfloat rayBisectDist(vec3 p, vec3 d, vec3 a, vec3 b)\n{\n    vec3 n = b - a;\n    float D = length(n);\n    float cosnd = dot(n, d)/D; //ray plane normal angle cosine\n    float l = D*.5 - dot(p - a, n)/D;\n    float t = l/cosnd; //ray parameter\n    return (cosnd>0.)?t:1e10;\n}\n\nfloat dirBisectDist(vec3 d, vec3 a, vec3 b, float dist)\n{\n    float cosnd = dot(normalize(b - a), d); //ray plane normal angle cosine\n    return (cosnd>0.)?(dist*.5)/cosnd:1e10;\n}\n\n//iq's triangle sdf \nfloat dot2( vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat bisectDist(vec3 p, vec3 a, vec3 b)\n{\n    return distance(a,b)*0.5 - dot(p - a, normalize(b - a));\n}\n\nfloat sdObj(vec3 p, in object o)\n{\n    float d = distance(p, o.X);\n    return d - o.bR; \n}", "buffer_a_code": "//triangle and triangle neighbor directional graph buffer \n\nvec3[] vertecies = vec3[](\nvec3(-3.4101800e-003,1.3031957e-001,2.1754370e-002),\nvec3(-8.1719160e-002,1.5250145e-001,2.9656090e-002),\nvec3(-3.0543480e-002,1.2477885e-001,1.0983400e-003),\nvec3(-2.4901590e-002,1.1211138e-001,3.7560240e-002),\nvec3(-1.8405680e-002,1.7843055e-001,-2.4219580e-002),\nvec3(1.9067940e-002,1.2144925e-001,3.1968440e-002),\nvec3(6.0412000e-003,1.2494359e-001,3.2652890e-002),\nvec3(-1.3469030e-002,1.6299355e-001,-1.2000020e-002),\nvec3(-3.4393240e-002,1.7236688e-001,-9.8213000e-004),\nvec3(-8.4314160e-002,1.0957263e-001,3.7097300e-003),\nvec3(-4.2233540e-002,1.7211574e-001,-4.1799800e-003),\nvec3(-6.3308390e-002,1.5660615e-001,-1.3838790e-002),\nvec3(-7.6903950e-002,1.6708033e-001,-2.6931360e-002),\nvec3(-7.2253920e-002,1.1539550e-001,5.1670300e-002),\nvec3(1.2981330e-002,1.1366375e-001,3.8302950e-002),\nvec3(-3.7857280e-002,1.7010102e-001,1.4236000e-003),\nvec3(4.8689400e-003,3.7962370e-002,4.5867630e-002),\nvec3(-5.7180550e-002,4.0918830e-002,4.6301340e-002),\nvec3(-4.5209070e-002,3.8839100e-002,4.4503770e-002),\nvec3(-3.3761490e-002,1.2617876e-001,1.7132300e-003),\nvec3(-5.0242270e-002,1.5773747e-001,9.3944500e-003),\nvec3(-2.1216950e-002,1.5887938e-001,-4.6923700e-003),\nvec3(-5.6472950e-002,1.5778406e-001,8.1786500e-003),\nvec3(-5.2802060e-002,4.1319860e-002,4.6169800e-002),\nvec3(-4.9960340e-002,4.3101950e-002,4.4462650e-002),\nvec3(-2.9748750e-002,3.6539860e-002,5.2493310e-002),\nvec3(-3.5438900e-003,4.2659770e-002,4.7541530e-002),\nvec3(4.9304900e-003,4.1982660e-002,4.5723390e-002),\nvec3(-3.9088180e-002,1.6872020e-001,-1.1924680e-002),\nvec3(-5.6901000e-002,4.5437000e-002,4.3236960e-002),\nvec3(-4.1244880e-002,4.3098890e-002,4.2129560e-002),\nvec3(-2.6471980e-002,4.5034530e-002,5.1219460e-002),\nvec3(-2.1866970e-002,4.4022930e-002,5.3243800e-002),\nvec3(-3.6996250e-002,1.6899301e-001,1.3256300e-003),\nvec3(-6.7216590e-002,1.6171340e-001,-1.3733710e-002),\nvec3(4.9760060e-002,7.0235220e-002,2.3732020e-002),\nvec3(-4.9186640e-002,4.6411230e-002,4.1170040e-002),\nvec3(-4.4590380e-002,4.3797990e-002,4.2685460e-002),\nvec3(-4.3686470e-002,4.7154500e-002,4.0286310e-002),\nvec3(-2.2491950e-002,4.6513620e-002,5.1885310e-002),\nvec3(-6.5174200e-003,4.5036200e-002,4.7502780e-002),\nvec3(3.7699000e-004,4.4935790e-002,4.6519930e-002),\nvec3(3.4023920e-002,1.1353879e-001,2.4595280e-002),\nvec3(-2.6467900e-002,1.8104250e-001,-8.0811700e-003),\nvec3(-1.7533470e-002,4.7964250e-002,4.8829630e-002),\nvec3(-7.0012600e-003,4.6416520e-002,4.7485540e-002),\nvec3(5.9862300e-003,4.6689140e-002,4.9073620e-002),\nvec3(9.1007200e-003,4.8474490e-002,4.9353190e-002),\nvec3(-3.5453700e-002,1.1244769e-001,3.5055410e-002),\nvec3(-7.5983200e-002,1.3820800e-001,4.9216580e-002),\nvec3(3.4838440e-002,4.3153410e-002,2.8954310e-002),\nvec3(-5.2655550e-002,4.8494220e-002,3.8731190e-002),\nvec3(-4.7378940e-002,4.8456670e-002,3.9126790e-002),\nvec3(-3.8933750e-002,4.6364270e-002,4.0364780e-002),\nvec3(-2.6468940e-002,4.7816430e-002,4.9322590e-002),\nvec3(-2.2365790e-002,4.8073650e-002,5.0126500e-002),\nvec3(-1.3373430e-002,4.7892410e-002,4.7883850e-002),\nvec3(-1.2193490e-002,4.9470300e-002,4.9484490e-002),\nvec3(-6.3364000e-004,4.7193060e-002,4.9136900e-002),\nvec3(2.0656800e-003,5.0104680e-002,5.2290220e-002),\nvec3(-2.2749270e-002,4.9883880e-002,4.6605520e-002),\nvec3(-1.8002080e-002,4.9917850e-002,4.6947970e-002),\nvec3(-7.8036800e-003,5.0169310e-002,5.0988650e-002),\nvec3(-2.6843800e-003,5.1247420e-002,5.3186790e-002),\nvec3(-6.3875650e-002,1.6140094e-001,-2.0064210e-002),\nvec3(3.2434000e-002,4.5333970e-002,3.0316760e-002),\nvec3(-8.8064570e-002,1.2496764e-001,5.7412000e-004),\nvec3(-4.1503710e-002,1.6748512e-001,3.2765900e-003),\nvec3(-6.4457010e-002,1.5342891e-001,-5.1180400e-003),\nvec3(-3.4303190e-002,5.0520150e-002,3.8286020e-002),\nvec3(-2.2949400e-002,5.1020650e-002,4.3926450e-002),\nvec3(-1.4354710e-002,5.4428200e-002,5.0710310e-002),\nvec3(1.3773100e-003,5.2302710e-002,5.3149010e-002),\nvec3(3.6285000e-003,5.3198640e-002,5.3422710e-002),\nvec3(8.0723800e-003,5.1574140e-002,5.1773560e-002),\nvec3(-7.2665890e-002,1.3005582e-001,5.1668200e-002),\nvec3(3.7992780e-002,4.9793200e-002,3.1902020e-002),\nvec3(3.8497260e-002,4.8062400e-002,3.1737450e-002),\nvec3(2.1503510e-002,1.2563988e-001,2.1252620e-002),\nvec3(-7.6481330e-002,1.4827412e-001,-8.9376200e-003),\nvec3(-8.7240410e-002,1.1967213e-001,-1.7813000e-004),\nvec3(-4.3719960e-002,1.6822738e-001,2.3425000e-003),\nvec3(-4.0652200e-002,1.2266506e-001,2.6290300e-002),\nvec3(-4.6686180e-002,5.4570720e-002,3.7587370e-002),\nvec3(-4.4071750e-002,5.1058250e-002,3.8977810e-002),\nvec3(-3.8144110e-002,5.0599600e-002,3.9302160e-002),\nvec3(-1.9875770e-002,5.1607710e-002,4.6142000e-002),\nvec3(-1.6911250e-002,5.1843550e-002,4.8459320e-002),\nvec3(-1.6249190e-002,5.4292110e-002,5.0306940e-002),\nvec3(-1.0446540e-002,5.3685970e-002,5.1958610e-002),\nvec3(-4.3090900e-003,5.4467500e-002,5.3908250e-002),\nvec3(7.8152700e-003,5.5050680e-002,5.2750250e-002),\nvec3(3.7955090e-002,1.0488710e-001,-3.2031800e-003),\nvec3(-7.9003790e-002,1.2850550e-001,5.3149340e-002),\nvec3(-7.9778990e-002,1.3448894e-001,5.0990290e-002),\nvec3(-5.9129700e-002,1.5039712e-001,3.4489540e-002),\nvec3(-6.5691790e-002,1.4961818e-001,3.8160980e-002),\nvec3(-3.1951660e-002,1.2518394e-001,1.9400580e-002),\nvec3(-6.9372590e-002,1.6061775e-001,-9.1905000e-003),\nvec3(-4.5225500e-002,1.2935459e-001,2.0377520e-002),\nvec3(-4.1879110e-002,5.6164390e-002,3.9796700e-002),\nvec3(-3.0614840e-002,5.4412650e-002,3.6694290e-002),\nvec3(-2.4787600e-002,5.2606220e-002,4.0839760e-002),\nvec3(-2.1588860e-002,5.6836920e-002,4.5467040e-002),\nvec3(-2.4264000e-004,5.4536020e-002,5.4641200e-002),\nvec3(-8.0900510e-002,1.2558713e-001,5.2155370e-002),\nvec3(-2.9996210e-002,1.7811137e-001,-5.2358200e-003),\nvec3(3.5515390e-002,5.0449570e-002,3.1439830e-002),\nvec3(4.3315550e-002,5.2145550e-002,3.2492110e-002),\nvec3(-6.3938540e-002,1.5262699e-001,3.4481070e-002),\nvec3(-4.4489440e-002,6.1077710e-002,3.9545320e-002),\nvec3(-3.8979900e-002,5.7996270e-002,4.0151390e-002),\nvec3(-7.9087730e-002,1.7044488e-001,-4.1373170e-002),\nvec3(-4.6247300e-003,5.7759650e-002,5.3990710e-002),\nvec3(-1.4985500e-003,5.5925480e-002,5.4630800e-002),\nvec3(5.1981700e-003,5.7017990e-002,5.3423530e-002),\nvec3(3.0920000e-005,1.2315746e-001,3.4749660e-002),\nvec3(3.3568300e-002,1.1523716e-001,2.1798410e-002),\nvec3(3.8686300e-002,5.6450590e-002,3.1188930e-002),\nvec3(-3.4385780e-002,5.4096000e-002,3.8060290e-002),\nvec3(-8.5308300e-003,6.0159420e-002,5.5308950e-002),\nvec3(-4.4024000e-004,5.8343410e-002,5.4483410e-002),\nvec3(-9.1078730e-002,1.1506037e-001,4.0141810e-002),\nvec3(4.0775480e-002,5.4557490e-002,3.2014740e-002),\nvec3(4.5636880e-002,5.7402620e-002,3.1992220e-002),\nvec3(2.0358850e-002,1.2448747e-001,2.5906340e-002),\nvec3(-1.4169700e-002,1.2767892e-001,1.3080500e-003),\nvec3(-1.1987590e-002,5.7493210e-002,5.2752420e-002),\nvec3(3.2514500e-003,5.9828640e-002,5.5464300e-002),\nvec3(-1.2395240e-002,1.2264726e-001,3.3588280e-002),\nvec3(1.3813780e-002,1.2322188e-001,3.2502590e-002),\nvec3(-7.7004310e-002,1.5521281e-001,2.4534770e-002),\nvec3(-2.8001360e-002,6.1075420e-002,3.7471210e-002),\nvec3(-8.5480000e-004,6.0593520e-002,5.5824810e-002),\nvec3(-3.8050200e-002,1.1527068e-001,3.3178540e-002),\nvec3(-1.6231340e-002,1.2382942e-001,2.9576990e-002),\nvec3(-2.5373550e-002,1.5840012e-001,-1.4801300e-003),\nvec3(-6.7818590e-002,1.5454353e-001,3.0233720e-002),\nvec3(-4.3082600e-003,6.1418570e-002,5.5688490e-002),\nvec3(-3.1958900e-003,1.1912518e-001,3.8349580e-002),\nvec3(-6.4292400e-003,1.2201090e-001,3.5740890e-002),\nvec3(4.2312960e-002,5.9099150e-002,3.0848420e-002),\nvec3(4.8510010e-002,6.1780760e-002,3.0347250e-002),\nvec3(5.0412290e-002,6.0312610e-002,3.0245060e-002),\nvec3(-3.9185590e-002,6.3074530e-002,4.1382890e-002),\nvec3(-3.4448660e-002,6.0780500e-002,3.9543990e-002),\nvec3(-1.4746030e-002,6.5583910e-002,5.3730860e-002),\nvec3(2.6645200e-003,6.2700010e-002,5.6525210e-002),\nvec3(-1.3991610e-002,1.1962575e-001,3.6251540e-002),\nvec3(1.9659170e-002,1.1236219e-001,3.7545270e-002),\nvec3(-3.2597160e-002,1.7498725e-001,-2.5953100e-003),\nvec3(-2.1513900e-003,9.9437380e-002,4.9849750e-002),\nvec3(-5.6001390e-002,6.1830670e-002,2.7931150e-002),\nvec3(-5.4707260e-002,6.3461570e-002,3.1670590e-002),\nvec3(-5.1307940e-002,6.0521660e-002,3.1434930e-002),\nvec3(-4.1979320e-002,6.9629980e-002,4.1824930e-002),\nvec3(-3.0272490e-002,6.2474660e-002,3.7982220e-002),\nvec3(-1.1387860e-002,6.4742460e-002,5.4918000e-002),\nvec3(6.9544900e-003,6.4700130e-002,5.5599150e-002),\nvec3(4.3015090e-002,9.7690960e-002,1.0258300e-003),\nvec3(4.0635900e-002,6.1574860e-002,2.9841250e-002),\nvec3(4.6183560e-002,6.1910110e-002,3.0223400e-002),\nvec3(3.7552960e-002,1.0685291e-001,2.6303470e-002),\nvec3(-7.8640730e-002,1.6387238e-001,-2.8387790e-002),\nvec3(-6.1996240e-002,1.4761484e-001,-4.3256800e-003),\nvec3(-5.7499800e-003,6.5488980e-002,5.6173390e-002),\nvec3(2.5369000e-004,6.5741170e-002,5.6569260e-002),\nvec3(-2.0542550e-002,1.1979518e-001,3.3003670e-002),\nvec3(4.3155900e-003,1.2782561e-001,2.8646880e-002),\nvec3(-4.6549580e-002,6.7652130e-002,3.9635790e-002),\nvec3(-1.7420580e-002,6.9659490e-002,5.4089530e-002),\nvec3(-1.5242190e-002,7.0909900e-002,5.5004790e-002),\nvec3(-1.0282890e-002,6.8926360e-002,5.5289610e-002),\nvec3(-1.1289000e-004,6.9288200e-002,5.6579790e-002),\nvec3(-3.6309330e-002,1.1876943e-001,3.0674020e-002),\nvec3(-7.0325800e-002,6.3367770e-002,1.9809180e-002),\nvec3(4.3023100e-002,6.3795810e-002,2.8039210e-002),\nvec3(4.2831110e-002,8.5556040e-002,2.7873760e-002),\nvec3(1.6981600e-002,1.2715003e-001,2.2931490e-002),\nvec3(-4.2121490e-002,1.2825104e-001,1.0751500e-003),\nvec3(1.6329230e-002,1.2251895e-001,3.1375390e-002),\nvec3(-8.1264160e-002,1.5381172e-001,2.5897830e-002),\nvec3(-3.2257870e-002,8.8192600e-002,-2.5130960e-002),\nvec3(-1.3774950e-002,7.0887950e-002,5.4695630e-002),\nvec3(5.2929600e-003,6.8006030e-002,5.5670490e-002),\nvec3(7.6962500e-003,7.2375600e-002,5.6062150e-002),\nvec3(3.4830600e-003,1.2002635e-001,3.6911950e-002),\nvec3(6.6532500e-003,1.1673563e-001,3.8716340e-002),\nvec3(4.6086570e-002,6.6473930e-002,2.6808990e-002),\nvec3(5.2327290e-002,6.4327070e-002,2.8281890e-002),\nvec3(-6.1897630e-002,1.2297065e-001,-8.7725500e-003),\nvec3(-6.3934700e-003,1.0524472e-001,-2.2841900e-002),\nvec3(-3.5218330e-002,6.8559830e-002,4.1381470e-002),\nvec3(-3.2689880e-002,6.7729720e-002,4.0124390e-002),\nvec3(-2.9245440e-002,6.9551520e-002,3.9369010e-002),\nvec3(-5.0024500e-003,6.9655000e-002,5.6892510e-002),\nvec3(1.6573960e-002,1.1890153e-001,3.5042300e-002),\nvec3(-8.9385100e-002,9.9024040e-002,1.7521830e-002),\nvec3(4.5719230e-002,6.9489400e-002,2.3549340e-002),\nvec3(5.4537210e-002,6.8796720e-002,2.4517690e-002),\nvec3(-4.4989450e-002,7.1577330e-002,4.1929250e-002),\nvec3(-4.2439400e-003,1.2914902e-001,2.5829230e-002),\nvec3(-7.3880090e-002,1.2091638e-001,5.3395800e-002),\nvec3(-7.4033870e-002,1.4406894e-001,4.4994970e-002),\nvec3(5.0400010e-002,6.7292480e-002,2.6851470e-002),\nvec3(-5.4056890e-002,1.5671602e-001,-2.4865900e-003),\nvec3(2.6148110e-002,1.2014725e-001,2.7308010e-002),\nvec3(-1.0736490e-002,1.2990285e-001,1.0993790e-002),\nvec3(-4.5078840e-002,8.7261130e-002,-2.1865520e-002),\nvec3(-3.8340900e-002,6.8843770e-002,4.1846470e-002),\nvec3(-2.9255580e-002,7.5169210e-002,4.1186430e-002),\nvec3(-4.7311210e-002,1.6296037e-001,6.0740300e-003),\nvec3(-1.1866030e-002,7.3183750e-002,5.6250050e-002),\nvec3(-6.3734600e-003,7.2184340e-002,5.7972980e-002),\nvec3(-2.9935300e-003,7.2186440e-002,5.8167190e-002),\nvec3(-2.5781060e-002,9.3778180e-002,-2.8388220e-002),\nvec3(-1.6692560e-002,1.1568553e-001,3.7853150e-002),\nvec3(-8.4123410e-002,1.0832050e-001,2.4730980e-002),\nvec3(-7.4294080e-002,1.6356850e-001,-1.5534220e-002),\nvec3(-9.4297150e-002,1.2617744e-001,1.9224650e-002),\nvec3(-3.5207090e-002,1.2505219e-001,2.1635690e-002),\nvec3(-4.9495940e-002,7.3436340e-002,4.1673570e-002),\nvec3(-3.3064160e-002,7.6654840e-002,4.1277900e-002),\nvec3(-7.3157300e-003,7.3919590e-002,5.7971690e-002),\nvec3(2.1850000e-005,7.3496040e-002,5.7696650e-002),\nvec3(4.1934400e-003,7.2915170e-002,5.6298730e-002),\nvec3(-7.7256080e-002,1.4565854e-001,4.3122930e-002),\nvec3(4.1073260e-002,8.8724320e-002,-9.7879400e-003),\nvec3(3.7418710e-002,1.0850822e-001,3.3973000e-004),\nvec3(-5.5111380e-002,7.4687840e-002,4.1939740e-002),\nvec3(-4.2740230e-002,7.6995340e-002,4.2804080e-002),\nvec3(-6.8531190e-002,1.5630045e-001,2.0997710e-002),\nvec3(-9.9440200e-003,7.6343100e-002,5.7388560e-002),\nvec3(-3.2479200e-003,7.5710690e-002,5.8714640e-002),\nvec3(1.3414380e-002,9.3073740e-002,5.1467750e-002),\nvec3(-7.3504440e-002,9.3883340e-002,-1.4751720e-002),\nvec3(-7.4471830e-002,1.3507476e-001,5.0688900e-002),\nvec3(-2.5851310e-002,1.2182948e-001,2.6079670e-002),\nvec3(-3.4022940e-002,1.7597076e-001,-3.7271600e-003),\nvec3(-7.5405850e-002,1.6839072e-001,-2.6792980e-002),\nvec3(-3.6658410e-002,7.5087300e-002,4.2006940e-002),\nvec3(-1.7795480e-002,7.7486190e-002,5.6087240e-002),\nvec3(-1.1378660e-002,7.9877150e-002,5.7698880e-002),\nvec3(-1.0415000e-004,7.6881950e-002,5.8190740e-002),\nvec3(2.7381400e-003,7.9105680e-002,5.6719190e-002),\nvec3(5.5681200e-003,7.6397140e-002,5.6327220e-002),\nvec3(-6.1895860e-002,1.5424247e-001,-1.9018600e-002),\nvec3(-7.2646960e-002,1.4098943e-001,4.6976640e-002),\nvec3(1.5799740e-002,1.2901416e-001,1.3236870e-002),\nvec3(-1.1703420e-002,9.7355720e-002,5.1592080e-002),\nvec3(-5.8922160e-002,7.7545490e-002,4.2961390e-002),\nvec3(-5.3121320e-002,7.7912430e-002,4.3334920e-002),\nvec3(-5.0745740e-002,7.6148400e-002,4.3137630e-002),\nvec3(-4.7401820e-002,7.5550340e-002,4.2630140e-002),\nvec3(-4.5055620e-002,7.8796280e-002,4.2341310e-002),\nvec3(-3.9517650e-002,7.8127780e-002,4.2918620e-002),\nvec3(-1.5245570e-002,8.2940770e-002,5.6934590e-002),\nvec3(-1.4557790e-002,7.6582160e-002,5.6493250e-002),\nvec3(-5.9406000e-003,7.9038240e-002,5.7969830e-002),\nvec3(3.7176540e-002,1.1064404e-001,1.8811330e-002),\nvec3(2.3929700e-003,1.3162713e-001,1.1955100e-002),\nvec3(-9.3644210e-002,1.1789378e-001,1.8662080e-002),\nvec3(-6.3939810e-002,7.8621830e-002,4.2083520e-002),\nvec3(-4.5376460e-002,8.2383550e-002,4.3282120e-002),\nvec3(-3.6505460e-002,8.1152260e-002,4.3162320e-002),\nvec3(-3.3244340e-002,8.2266590e-002,4.1852180e-002),\nvec3(-3.0800650e-002,8.0068420e-002,4.1798070e-002),\nvec3(-2.0578500e-003,8.0998290e-002,5.7553840e-002),\nvec3(8.1848100e-003,8.0756170e-002,5.5374510e-002),\nvec3(-1.2953370e-002,1.1593580e-001,3.8920230e-002),\nvec3(-7.8081470e-002,1.2351940e-001,5.2136990e-002),\nvec3(-2.6580930e-002,1.5567694e-001,-4.1963400e-003),\nvec3(-8.2471600e-002,1.1624130e-001,-2.3236300e-003),\nvec3(-2.7538480e-002,7.9964780e-002,4.7697210e-002),\nvec3(1.2556400e-003,8.3845570e-002,5.7446440e-002),\nvec3(6.1508300e-003,8.3406240e-002,5.6463500e-002),\nvec3(-6.2433240e-002,8.4035270e-002,4.4203120e-002),\nvec3(-5.9867170e-002,8.0540510e-002,4.3277090e-002),\nvec3(-5.5238340e-002,8.1999450e-002,4.4984770e-002),\nvec3(-5.4000400e-002,8.0568410e-002,4.4601460e-002),\nvec3(-5.0027020e-002,8.1311330e-002,4.4264180e-002),\nvec3(-4.1996120e-002,8.1083670e-002,4.2456150e-002),\nvec3(-3.9357940e-002,8.3631380e-002,4.3502350e-002),\nvec3(-8.6161480e-002,1.0838594e-001,1.8244920e-002),\nvec3(-8.6723010e-002,9.9917250e-002,3.5537100e-003),\nvec3(-2.2413700e-002,8.3283520e-002,5.5590700e-002),\nvec3(-1.6993180e-002,8.2555820e-002,5.7523880e-002),\nvec3(-1.2406010e-002,8.5222570e-002,5.7267780e-002),\nvec3(-7.4442100e-003,1.1693417e-001,3.9283850e-002),\nvec3(-2.1452000e-003,1.1143287e-001,4.2436620e-002),\nvec3(-7.5718220e-002,1.2522734e-001,5.3087330e-002),\nvec3(-7.7056660e-002,1.3193469e-001,5.2462430e-002),\nvec3(-6.1121040e-002,1.5569660e-001,2.2517050e-002),\nvec3(-3.7538540e-002,1.2744127e-001,1.5320870e-002),\nvec3(-2.0516700e-003,1.0093469e-001,4.5625920e-002),\nvec3(-6.4992150e-002,8.4550900e-002,4.4120060e-002),\nvec3(-5.7861950e-002,8.3944360e-002,4.4186030e-002),\nvec3(-4.5681080e-002,8.4988010e-002,4.4159500e-002),\nvec3(-3.5022640e-002,8.2888160e-002,4.2912760e-002),\nvec3(-2.9982010e-002,8.5402300e-002,4.3745080e-002),\nvec3(-8.8892260e-002,9.9209100e-002,9.5703200e-003),\nvec3(-1.9135300e-002,8.3474800e-002,5.7217390e-002),\nvec3(-8.3489710e-002,1.0724729e-001,7.5790000e-004),\nvec3(-7.0112800e-002,1.1790350e-001,5.2714160e-002),\nvec3(-3.5526320e-002,1.7595563e-001,-4.8676200e-003),\nvec3(-7.0831390e-002,1.2254425e-001,5.3274880e-002),\nvec3(4.5133810e-002,9.3630690e-002,6.2336800e-003),\nvec3(-5.3616700e-002,8.5346850e-002,4.5332470e-002),\nvec3(-4.9000840e-002,8.6221680e-002,4.5352040e-002),\nvec3(-3.6744880e-002,8.6083690e-002,4.3612890e-002),\nvec3(-1.0872600e-002,8.8826770e-002,5.6665490e-002),\nvec3(-3.8450200e-003,8.4787810e-002,5.7197980e-002),\nvec3(-4.9020070e-002,1.1771293e-001,3.1581430e-002),\nvec3(-4.2914400e-002,1.1835991e-001,3.0645040e-002),\nvec3(-5.7684530e-002,1.5561695e-001,1.2983110e-002),\nvec3(-2.5411730e-002,1.2472533e-001,1.2886000e-004),\nvec3(1.9012230e-002,1.2736197e-001,1.7786580e-002),\nvec3(-5.9498600e-002,8.8845470e-002,4.5109290e-002),\nvec3(-5.6931050e-002,8.8101500e-002,4.4692930e-002),\nvec3(3.5765600e-003,1.3138981e-001,7.2086000e-003),\nvec3(-1.6683350e-002,8.7266690e-002,5.6741190e-002),\nvec3(-8.4980800e-003,8.3990470e-002,5.7605220e-002),\nvec3(3.5078200e-003,8.6339520e-002,5.7048320e-002),\nvec3(-2.8398700e-002,1.8070650e-001,-7.8469500e-003),\nvec3(-7.6565830e-002,1.1674037e-001,5.1489350e-002),\nvec3(1.7869430e-002,9.0898610e-002,4.8712940e-002),\nvec3(-4.0342100e-002,1.1669551e-001,3.2460200e-002),\nvec3(5.9105700e-003,1.3140929e-001,1.6823750e-002),\nvec3(-8.5777550e-002,9.1701370e-002,-4.6970000e-005),\nvec3(-5.0372230e-002,8.8844660e-002,4.5188000e-002),\nvec3(-4.4434130e-002,8.7654530e-002,4.3477620e-002),\nvec3(-4.2056390e-002,8.6711520e-002,4.2534630e-002),\nvec3(-3.3058460e-002,8.6185500e-002,4.2560350e-002),\nvec3(-2.9241910e-002,9.0453360e-002,4.4236610e-002),\nvec3(-6.8964100e-003,8.4432910e-002,5.7168580e-002),\nvec3(-6.6210600e-003,9.0415250e-002,5.6879750e-002),\nvec3(-1.2439100e-003,8.9093200e-002,5.6552120e-002),\nvec3(9.4076000e-003,9.0328050e-002,5.4214140e-002),\nvec3(4.0194810e-002,1.0231597e-001,-2.0048600e-003),\nvec3(-8.6227130e-002,1.1466841e-001,2.2102000e-003),\nvec3(-8.9495490e-002,9.5632430e-002,1.4234810e-002),\nvec3(-6.7132160e-002,1.5709447e-001,-6.2032000e-003),\nvec3(-5.2935640e-002,9.0913520e-002,4.4568870e-002),\nvec3(-3.6744910e-002,8.8886950e-002,4.3312050e-002),\nvec3(-1.3626110e-002,8.9787930e-002,5.6674380e-002),\nvec3(2.3337130e-002,1.2353449e-001,2.4874140e-002),\nvec3(-3.7053790e-002,1.2715094e-001,3.5474000e-004),\nvec3(-7.3696690e-002,1.5613015e-001,1.4359790e-002),\nvec3(-6.5592380e-002,9.1042400e-002,4.4092080e-002),\nvec3(-5.8997380e-002,9.2030670e-002,4.5335270e-002),\nvec3(-3.3238910e-002,8.8573580e-002,4.3697040e-002),\nvec3(-3.1834990e-002,9.0722970e-002,4.4173460e-002),\nvec3(-2.0022170e-002,8.8032110e-002,5.5589350e-002),\nvec3(-1.1213830e-002,9.2366370e-002,5.6105260e-002),\nvec3(3.9108440e-002,1.0829072e-001,1.3142330e-002),\nvec3(2.8675700e-002,1.1959600e-001,2.4545910e-002),\nvec3(-6.8940210e-002,1.5652777e-001,-1.9716000e-003),\nvec3(-6.2615110e-002,9.1126880e-002,4.5090730e-002),\nvec3(3.0444560e-002,1.1886441e-001,2.0821750e-002),\nvec3(-1.5241090e-002,9.1821720e-002,5.5817230e-002),\nvec3(-5.6221700e-003,9.3235010e-002,5.5893630e-002),\nvec3(4.7989900e-003,9.1654840e-002,5.4715170e-002),\nvec3(-6.8282400e-002,9.2376840e-002,4.2388730e-002),\nvec3(-5.5623730e-002,9.2187420e-002,4.5054970e-002),\nvec3(-5.1901030e-002,9.5457620e-002,4.3937650e-002),\nvec3(-4.8809030e-002,9.1083890e-002,4.4456690e-002),\nvec3(-4.5411560e-002,9.1002130e-002,4.3252770e-002),\nvec3(-4.4514550e-002,9.4860420e-002,4.2972490e-002),\nvec3(-3.9430320e-002,8.9597620e-002,4.3177890e-002),\nvec3(-3.5642240e-002,9.2617410e-002,4.4238490e-002),\nvec3(-1.2246000e-004,9.3201160e-002,5.5398380e-002),\nvec3(9.5104600e-003,9.5483870e-002,5.0910600e-002),\nvec3(2.1441660e-002,9.1354960e-002,4.8043360e-002),\nvec3(-8.9830300e-003,1.6926449e-001,-2.2683480e-002),\nvec3(-7.3019050e-002,1.5602104e-001,2.2419340e-002),\nvec3(-6.4760430e-002,1.5311588e-001,-2.0371200e-003),\nvec3(-6.9368510e-002,9.5242790e-002,4.2129000e-002),\nvec3(-6.0117140e-002,9.5552910e-002,4.4183820e-002),\nvec3(-2.9241690e-002,9.4290440e-002,4.4821190e-002),\nvec3(-2.6561430e-002,9.3289510e-002,4.4975420e-002),\nvec3(-1.4394030e-002,9.4587640e-002,5.3993500e-002),\nvec3(-8.8691600e-003,9.5400260e-002,5.4445980e-002),\nvec3(-1.2188700e-003,9.6201750e-002,5.3815910e-002),\nvec3(4.0479000e-003,9.5817360e-002,5.2936770e-002),\nvec3(-4.6019400e-003,1.2428544e-001,3.3471960e-002),\nvec3(-7.8436460e-002,1.3928013e-001,4.8329360e-002),\nvec3(1.0774610e-002,1.3079162e-001,1.4341740e-002),\nvec3(-5.6623730e-002,9.6322170e-002,4.3667910e-002),\nvec3(-3.6298870e-002,9.5695620e-002,4.3580310e-002),\nvec3(-2.4379930e-002,9.5866450e-002,4.4434530e-002),\nvec3(1.0915500e-002,1.2633629e-001,2.9857020e-002),\nvec3(-5.8622700e-003,9.7350210e-002,5.2743650e-002),\nvec3(1.6973450e-002,9.7106620e-002,4.7440920e-002),\nvec3(-6.7231980e-002,9.9173950e-002,4.1593880e-002),\nvec3(-5.4994210e-002,9.9640820e-002,4.2955230e-002),\nvec3(-4.8617990e-002,9.6452700e-002,4.4183060e-002),\nvec3(-5.5369000e-002,1.5442476e-001,1.6160650e-002),\nvec3(-9.4243550e-002,1.2207432e-001,2.3568470e-002),\nvec3(1.3242990e-002,9.6738240e-002,4.8750160e-002),\nvec3(2.0639290e-002,9.6602480e-002,4.6971000e-002),\nvec3(7.3429700e-003,1.2098188e-001,3.5973430e-002),\nvec3(-1.3493870e-002,1.2882438e-001,5.9690700e-003),\nvec3(-2.0110640e-002,1.2504545e-001,2.3588310e-002),\nvec3(-6.9438450e-002,1.6479930e-001,-1.7218700e-002),\nvec3(-6.4028050e-002,9.7838670e-002,4.2565330e-002),\nvec3(-5.1996350e-002,9.9707850e-002,4.2716590e-002),\nvec3(-4.3990880e-002,9.9425460e-002,4.2383430e-002),\nvec3(-3.9738250e-002,1.0215357e-001,4.0574410e-002),\nvec3(-3.5931490e-002,9.9809950e-002,4.2335800e-002),\nvec3(-3.0867600e-002,9.6914680e-002,4.4651400e-002),\nvec3(-2.8342070e-002,9.7782680e-002,4.3761280e-002),\nvec3(-2.5622580e-002,9.8713420e-002,4.4210890e-002),\nvec3(-8.5236620e-002,1.1077356e-001,2.4537670e-002),\nvec3(7.1936000e-003,9.8859470e-002,4.8419510e-002),\nvec3(9.6509200e-003,1.0108782e-001,4.7373080e-002),\nvec3(1.3487100e-002,1.0076420e-001,4.7454290e-002),\nvec3(7.7389800e-003,1.3147500e-001,1.1682970e-002),\nvec3(8.0905000e-004,1.1633319e-001,4.0167560e-002),\nvec3(-7.2652570e-002,1.6567918e-001,-1.8212480e-002),\nvec3(-5.6009400e-003,1.3076674e-001,1.0516060e-002),\nvec3(-2.6303720e-002,1.2518875e-001,1.7392980e-002),\nvec3(-4.7590430e-002,1.0081180e-001,4.2349150e-002),\nvec3(-4.1460830e-002,9.8544800e-002,4.1778620e-002),\nvec3(-3.3582070e-002,1.0383908e-001,4.0737990e-002),\nvec3(-2.2870240e-002,1.0284737e-001,4.3544750e-002),\nvec3(-2.2361970e-002,9.8207610e-002,4.4765940e-002),\nvec3(-1.8870510e-002,9.8973200e-002,4.4489280e-002),\nvec3(-7.1433690e-002,7.7573520e-002,3.8060760e-002),\nvec3(-7.3001150e-002,1.1826712e-001,5.3034590e-002),\nvec3(-6.8466430e-002,1.3498146e-001,-8.3359800e-003),\nvec3(-7.4683810e-002,1.0786100e-001,-9.0477100e-003),\nvec3(-6.4958960e-002,1.5852021e-001,-1.2595320e-002),\nvec3(-7.8931700e-002,1.5093057e-001,3.5151900e-002),\nvec3(-7.4113550e-002,9.9442520e-002,3.8337710e-002),\nvec3(-7.0456930e-002,1.0098777e-001,3.9794060e-002),\nvec3(-5.9058760e-002,1.0041260e-001,4.2725130e-002),\nvec3(-4.9187330e-002,1.0452012e-001,4.0301390e-002),\nvec3(-2.9151180e-002,1.0197369e-001,4.2633060e-002),\nvec3(-1.1599720e-002,1.0107813e-001,4.4191660e-002),\nvec3(5.1450400e-003,1.0163906e-001,4.5423010e-002),\nvec3(-5.1495700e-002,1.0496738e-001,4.0347210e-002),\nvec3(-2.0218210e-002,1.0214391e-001,4.3701160e-002),\nvec3(4.2515900e-003,1.0523743e-001,4.2563550e-002),\nvec3(1.6832800e-002,1.0337487e-001,4.5287270e-002),\nvec3(-2.5661080e-002,1.2562669e-001,4.5537500e-003),\nvec3(-7.2141950e-002,1.0536685e-001,3.7523210e-002),\nvec3(-6.4984570e-002,1.0371550e-001,4.0647810e-002),\nvec3(-6.0652480e-002,1.0467197e-001,4.0906390e-002),\nvec3(-5.5308980e-002,1.0365394e-001,4.1516690e-002),\nvec3(-4.4243240e-002,1.0431726e-001,4.1339990e-002),\nvec3(-1.5513340e-002,1.0436131e-001,4.2919420e-002),\nvec3(-7.6323200e-003,1.0304531e-001,4.3710640e-002),\nvec3(-7.8046900e-003,1.0516619e-001,4.3825460e-002),\nvec3(9.7163200e-003,1.0523506e-001,4.3603830e-002),\nvec3(3.0300390e-002,1.1553645e-001,2.8685010e-002),\nvec3(-4.7496910e-002,1.0635662e-001,4.0165640e-002),\nvec3(-3.8978950e-002,1.0683037e-001,3.8247660e-002),\nvec3(-2.5869310e-002,1.0426705e-001,4.2207540e-002),\nvec3(-1.8057930e-002,1.0503919e-001,4.2802830e-002),\nvec3(-1.5180030e-002,1.0807750e-001,4.2350430e-002),\nvec3(-3.8981500e-003,1.0566175e-001,4.4047190e-002),\nvec3(2.6820000e-005,1.0446731e-001,4.3775910e-002),\nvec3(1.1978350e-002,1.0403629e-001,4.5396310e-002),\nvec3(1.5004970e-002,1.0726898e-001,4.1811990e-002),\nvec3(2.6488060e-002,1.2230287e-001,2.0398110e-002),\nvec3(-3.6225630e-002,1.0634244e-001,3.8644860e-002),\nvec3(-2.1126780e-002,1.0932290e-001,4.0715320e-002),\nvec3(-1.2819810e-002,1.0457100e-001,4.3465690e-002),\nvec3(5.2847900e-003,1.0943666e-001,4.1674980e-002),\nvec3(8.9403700e-003,1.0710645e-001,4.1243400e-002),\nvec3(-5.1839670e-002,1.6062039e-001,7.1421300e-003),\nvec3(-5.4201370e-002,1.1451730e-001,3.4843990e-002),\nvec3(1.3226250e-002,1.2958070e-001,1.9689610e-002),\nvec3(-6.9382410e-002,1.0865787e-001,3.7507800e-002),\nvec3(-6.7691040e-002,1.0734145e-001,3.8018440e-002),\nvec3(-6.3782400e-002,1.1037270e-001,3.7579790e-002),\nvec3(-5.0749390e-002,1.0928682e-001,3.8297580e-002),\nvec3(-9.3936200e-003,1.0742813e-001,4.3454570e-002),\nvec3(1.1760100e-003,1.0932531e-001,4.2662800e-002),\nvec3(9.8020300e-003,1.1003994e-001,3.9945400e-002),\nvec3(2.0131290e-002,1.0732778e-001,4.0323840e-002),\nvec3(-2.7872800e-003,1.0577531e-001,-2.2459030e-002),\nvec3(-5.4996890e-002,1.0774199e-001,3.9424590e-002),\nvec3(-4.5966740e-002,1.0905146e-001,3.8754110e-002),\nvec3(-4.2324540e-002,1.0737278e-001,3.9456440e-002),\nvec3(-3.2161240e-002,1.0896504e-001,3.8102720e-002),\nvec3(-3.0770180e-002,1.1597313e-001,3.2858800e-002),\nvec3(-1.1608610e-002,1.0983707e-001,4.2475330e-002),\nvec3(-2.9428320e-002,9.3166620e-002,-2.4931860e-002),\nvec3(-8.0043570e-002,9.2080160e-002,-9.4198200e-003),\nvec3(-4.9797430e-002,1.1342104e-001,3.5117920e-002),\nvec3(-4.3723850e-002,1.6191369e-001,5.7713400e-003),\nvec3(-5.7981740e-002,1.0943152e-001,3.7997640e-002),\nvec3(-4.1491180e-002,1.1224766e-001,3.5873450e-002),\nvec3(-2.4929830e-002,1.1592775e-001,3.4094730e-002),\nvec3(-2.0881690e-002,1.1409528e-001,3.7872990e-002),\nvec3(-7.5519700e-003,1.1183813e-001,4.2039690e-002),\nvec3(3.7667200e-003,1.1240547e-001,4.1494710e-002),\nvec3(-6.2829620e-002,1.5189480e-001,-9.2373400e-003),\nvec3(-5.9195950e-002,1.1320797e-001,3.6234680e-002),\nvec3(-5.1079080e-002,9.3892810e-002,-2.1761690e-002),\nvec3(-7.3945370e-002,8.4374880e-002,-1.5154490e-002),\nvec3(-7.2146240e-002,1.3486431e-001,-7.7592200e-003),\nvec3(-1.9408870e-002,1.7041104e-001,-2.0994830e-002),\nvec3(-5.5530450e-002,1.4905531e-001,-1.9602100e-003),\nvec3(1.6688460e-002,3.6976600e-002,4.3000600e-002),\nvec3(-5.2277330e-002,1.1775075e-001,3.3769460e-002),\nvec3(-6.9201380e-002,9.3039200e-002,-1.6486120e-002),\nvec3(2.6579210e-002,1.1702438e-001,3.0867940e-002),\nvec3(-2.3574310e-002,3.7036910e-002,5.4144750e-002),\nvec3(-7.3775100e-003,3.8988430e-002,4.8929450e-002),\nvec3(1.3234660e-002,3.8453060e-002,4.4501470e-002),\nvec3(1.9487350e-002,4.0809290e-002,4.2641060e-002),\nvec3(-6.3953930e-002,1.4694729e-001,3.8484200e-002),\nvec3(-4.9579470e-002,3.6096540e-002,4.5955360e-002),\nvec3(-4.3323650e-002,3.6286400e-002,4.4042360e-002),\nvec3(-2.9047200e-002,1.2556338e-001,7.7617700e-003),\nvec3(-1.7343100e-003,3.9476800e-002,4.7262900e-002),\nvec3(-3.1358130e-002,1.5362199e-001,-4.6738900e-003),\nvec3(2.5822000e-003,1.0747582e-001,-2.0606030e-002),\nvec3(-5.6802300e-002,1.4514674e-001,3.1740300e-002),\nvec3(-5.6464330e-002,3.7683110e-002,4.6819640e-002),\nvec3(-5.0964750e-002,3.8312290e-002,4.6286140e-002),\nvec3(-5.0980410e-002,1.3486613e-001,2.7585000e-002),\nvec3(-2.5647410e-002,3.8860730e-002,5.4161390e-002),\nvec3(-2.2542110e-002,4.0615780e-002,5.3986030e-002),\nvec3(-1.7618010e-002,3.8911170e-002,5.2403440e-002),\nvec3(-1.9711750e-002,1.6829145e-001,-1.3020960e-002),\nvec3(2.3780070e-002,9.5222940e-002,4.6347330e-002),\nvec3(1.4744290e-002,4.2716950e-002,4.4510310e-002),\nvec3(2.1691360e-002,4.0161530e-002,4.0846450e-002),\nvec3(-6.4067240e-002,9.0172190e-002,-1.8855520e-002),\nvec3(2.0319150e-002,1.0041961e-001,4.5760520e-002),\nvec3(-3.6425000e-002,9.3630690e-002,-2.3534630e-002),\nvec3(-1.4981170e-002,4.2571420e-002,5.1404530e-002),\nvec3(-5.7335340e-002,1.2340101e-001,4.0231470e-002),\nvec3(-5.4172560e-002,1.2337919e-001,3.7576440e-002),\nvec3(2.2625210e-002,4.3621680e-002,4.0904580e-002),\nvec3(2.8810520e-002,4.3352290e-002,3.2157720e-002),\nvec3(-4.2764160e-002,1.5727487e-001,5.2016200e-003),\nvec3(9.2231900e-003,4.4125090e-002,4.5057440e-002),\nvec3(1.5048210e-002,4.5755840e-002,4.3793870e-002),\nvec3(-6.3757290e-002,1.0251144e-001,-1.7484400e-002),\nvec3(-3.4070430e-002,1.6148975e-001,-1.3786960e-002),\nvec3(-8.2191500e-002,7.5610200e-002,1.6542620e-002),\nvec3(-6.6299420e-002,1.2337119e-001,5.0615920e-002),\nvec3(-1.5510100e-002,4.5283110e-002,5.0653040e-002),\nvec3(1.8928020e-002,4.4249610e-002,4.3009830e-002),\nvec3(2.5821800e-002,4.6326610e-002,3.8277230e-002),\nvec3(2.7268700e-002,4.4547790e-002,3.6152520e-002),\nvec3(-4.5301340e-002,1.5695057e-001,7.2036900e-003),\nvec3(2.3855760e-002,1.0616625e-001,3.9378080e-002),\nvec3(2.1632670e-002,4.8127270e-002,4.0694430e-002),\nvec3(4.3785360e-002,4.8803700e-002,3.1343420e-002),\nvec3(4.8074790e-002,4.8969960e-002,2.8165490e-002),\nvec3(5.2663090e-002,4.7673620e-002,2.1201270e-002),\nvec3(-5.2722450e-002,4.4722850e-002,4.4143250e-002),\nvec3(-3.0071610e-002,1.7258324e-001,-6.3597700e-003),\nvec3(-3.4508050e-002,1.5447469e-001,1.6504600e-003),\nvec3(1.0629710e-002,4.6711810e-002,4.6472020e-002),\nvec3(1.6743440e-002,4.8439000e-002,4.3678630e-002),\nvec3(2.8827050e-002,9.2133370e-002,4.3920090e-002),\nvec3(-5.9937100e-002,1.2726188e-001,4.0771270e-002),\nvec3(-3.6752090e-002,1.5802075e-001,4.1862000e-003),\nvec3(-3.7885390e-002,1.6199719e-001,2.4686000e-004),\nvec3(-2.2047790e-002,1.8348586e-001,-1.2094990e-002),\nvec3(-2.4364620e-002,1.8096836e-001,-9.8312000e-003),\nvec3(-4.4882280e-002,1.5052959e-001,7.6451700e-003),\nvec3(2.6996760e-002,5.1317780e-002,3.8752040e-002),\nvec3(4.7735750e-002,5.2751040e-002,3.0797290e-002),\nvec3(5.1703790e-002,4.8857380e-002,2.4147970e-002),\nvec3(-6.7504360e-002,1.1424088e-001,4.8036050e-002),\nvec3(-1.6257520e-002,1.6031250e-001,-9.6926000e-003),\nvec3(-6.3926300e-002,1.6792441e-001,-4.0730420e-002),\nvec3(-4.1665290e-002,1.4996141e-001,4.5405000e-003),\nvec3(-3.5203230e-002,1.6493551e-001,-2.6810000e-003),\nvec3(4.1318770e-002,9.9496740e-002,2.4275750e-002),\nvec3(1.4055220e-002,5.2523910e-002,4.8593880e-002),\nvec3(1.9421220e-002,5.1321300e-002,4.4798910e-002),\nvec3(2.3677990e-002,5.1474390e-002,4.1053270e-002),\nvec3(3.4258130e-002,5.1930810e-002,3.2757880e-002),\nvec3(5.5957340e-002,5.3147410e-002,2.3197720e-002),\nvec3(-3.9937960e-002,1.4922850e-001,1.6017200e-003),\nvec3(-4.6988800e-002,1.2600802e-001,2.6985500e-002),\nvec3(-2.7708370e-002,9.0081290e-002,-3.1911460e-002),\nvec3(1.9204630e-002,5.5166510e-002,4.7722150e-002),\nvec3(2.1886000e-002,5.3927560e-002,4.5102460e-002),\nvec3(3.1286270e-002,5.2863840e-002,3.6913620e-002),\nvec3(4.6661160e-002,5.4719230e-002,3.1976810e-002),\nvec3(5.1823730e-002,5.3276700e-002,2.7927010e-002),\nvec3(-2.9264880e-002,1.6140418e-001,-2.1039500e-003),\nvec3(-6.8700770e-002,1.4463537e-001,4.3041630e-002),\nvec3(-5.6070060e-002,1.5000706e-001,2.9867640e-002),\nvec3(4.4717850e-002,9.4802660e-002,1.2024710e-002),\nvec3(-4.1804090e-002,1.5582081e-001,6.4548200e-003),\nvec3(-6.8369340e-002,1.2289287e-001,5.2437860e-002),\nvec3(-6.4114810e-002,9.5509880e-002,-1.8114610e-002),\nvec3(-1.8383130e-002,1.8543664e-001,-1.7136370e-002),\nvec3(1.1745400e-002,5.6678340e-002,5.1914060e-002),\nvec3(-5.9375360e-002,1.1998238e-001,4.0548240e-002),\nvec3(5.9092080e-002,5.7956980e-002,2.0270120e-002),\nvec3(4.3547740e-002,9.7389400e-002,1.7314650e-002),\nvec3(-2.6291780e-002,1.5963381e-001,-5.1845000e-004),\nvec3(1.4904780e-002,5.6350380e-002,4.9522780e-002),\nvec3(2.4286200e-002,5.4958580e-002,4.3086850e-002),\nvec3(2.8952610e-002,5.6125250e-002,4.0388970e-002),\nvec3(-4.9507770e-002,1.2949500e-001,3.0259270e-002),\nvec3(4.0824790e-002,9.5170220e-002,2.8657920e-002),\nvec3(1.7774800e-002,5.8243780e-002,4.8864720e-002),\nvec3(3.3573840e-002,5.8515260e-002,3.8310990e-002),\nvec3(3.6385040e-002,5.6996480e-002,3.3601460e-002),\nvec3(-6.4205010e-002,1.2243894e-001,4.8008340e-002),\nvec3(-6.5424500e-002,1.4011279e-001,4.1308960e-002),\nvec3(5.0801340e-002,5.7308080e-002,3.0001390e-002),\nvec3(5.6671750e-002,5.6970820e-002,2.4291920e-002),\nvec3(-4.9349930e-002,1.4913519e-001,1.1274060e-002),\nvec3(-6.9760570e-002,1.3442855e-001,4.8265220e-002),\nvec3(1.9537060e-002,6.0003780e-002,4.8576140e-002),\nvec3(2.7013910e-002,5.9952790e-002,4.3454420e-002),\nvec3(5.7679430e-002,6.1392970e-002,2.4201790e-002),\nvec3(-5.6916540e-002,1.2623512e-001,3.9426610e-002),\nvec3(2.3469280e-002,1.1656262e-001,3.3537270e-002),\nvec3(-5.8298640e-002,1.3885500e-001,3.2937460e-002),\nvec3(6.4598400e-003,6.0297430e-002,5.4780030e-002),\nvec3(1.0406020e-002,5.9162400e-002,5.2484370e-002),\nvec3(2.3183950e-002,5.8654360e-002,4.5871060e-002),\nvec3(3.3040360e-002,6.1773840e-002,3.9781440e-002),\nvec3(-6.4348220e-002,1.2628088e-001,4.6650200e-002),\nvec3(-5.7031440e-002,1.1562007e-001,3.6494880e-002),\nvec3(5.4451560e-002,5.8342890e-002,2.7653010e-002),\nvec3(-3.0134400e-002,1.7011322e-001,-7.3591600e-003),\nvec3(-3.7077100e-002,1.5986369e-001,1.6096500e-003),\nvec3(-5.6032760e-002,1.3731083e-001,3.1970590e-002),\nvec3(-6.7676470e-002,1.4150325e-001,4.3868140e-002),\nvec3(9.9911700e-003,6.2735270e-002,5.4009240e-002),\nvec3(1.4521510e-002,6.1382890e-002,5.0500900e-002),\nvec3(3.0051740e-002,6.2169610e-002,4.1545810e-002),\nvec3(3.7519170e-002,6.1062710e-002,3.4366020e-002),\nvec3(5.3944010e-002,6.1391550e-002,2.8268530e-002),\nvec3(5.9119900e-002,6.3128810e-002,2.1561830e-002),\nvec3(-2.4366390e-002,1.7693266e-001,-1.1719630e-002),\nvec3(-1.3253420e-002,1.6627152e-001,-1.4120370e-002),\nvec3(3.9218740e-002,1.0669250e-001,2.0450190e-002),\nvec3(-1.7968980e-002,1.8078031e-001,-1.8103430e-002),\nvec3(2.1902390e-002,6.0875970e-002,4.7282360e-002),\nvec3(3.5341750e-002,6.1630030e-002,3.7606020e-002),\nvec3(-6.2145620e-002,1.3599775e-001,3.6700970e-002),\nvec3(5.6820620e-002,6.3691150e-002,2.5286090e-002),\nvec3(-3.2800040e-002,1.5948699e-001,2.1962800e-003),\nvec3(1.1212140e-002,6.6584120e-002,5.3982180e-002),\nvec3(1.2919590e-002,6.4203580e-002,5.2441150e-002),\nvec3(2.0126950e-002,6.3851330e-002,4.7919660e-002),\nvec3(3.5971760e-002,6.6669610e-002,3.7781400e-002),\nvec3(3.9906940e-002,6.4361260e-002,3.1686660e-002),\nvec3(-6.6702350e-002,1.3210600e-001,4.5480940e-002),\nvec3(-4.1601430e-002,1.5978000e-001,3.5374700e-003),\nvec3(3.3044580e-002,1.0766252e-001,3.1916150e-002),\nvec3(2.4672100e-002,6.3694500e-002,4.5204640e-002),\nvec3(2.6108660e-002,6.8007640e-002,4.3902690e-002),\nvec3(3.3363940e-002,6.7054760e-002,3.9729480e-002),\nvec3(4.2915790e-002,6.6707700e-002,2.6994720e-002),\nvec3(5.4714960e-002,6.4697160e-002,2.6979680e-002),\nvec3(-1.6530940e-002,1.6325000e-001,-9.2475200e-003),\nvec3(-1.7891600e-002,1.6113800e-001,-6.7072700e-003),\nvec3(4.1118120e-002,9.7491260e-002,-3.9756700e-003),\nvec3(2.3386770e-002,7.0075990e-002,4.7012620e-002),\nvec3(3.8102900e-002,6.5678440e-002,3.5132520e-002),\nvec3(1.0145240e-002,1.2221678e-001,3.4718950e-002),\nvec3(5.8392410e-002,6.6741240e-002,2.1979460e-002),\nvec3(3.8302050e-002,8.4549140e-002,-1.4478830e-002),\nvec3(3.4126440e-002,9.7053980e-002,3.7590390e-002),\nvec3(-3.1355740e-002,1.5809888e-001,1.9128800e-003),\nvec3(-5.8259510e-002,1.4099493e-001,3.2440640e-002),\nvec3(-6.6817230e-002,1.1951525e-001,5.1490220e-002),\nvec3(-6.8090040e-002,1.1647050e-001,5.1151230e-002),\nvec3(1.6568300e-002,6.6269890e-002,5.1009890e-002),\nvec3(2.9362870e-002,6.6509780e-002,4.2289380e-002),\nvec3(3.7027180e-002,9.3949630e-002,-1.1674040e-002),\nvec3(5.6412730e-002,6.7659930e-002,2.3969320e-002),\nvec3(-6.1295740e-002,1.4519988e-001,3.7137830e-002),\nvec3(8.3873000e-003,1.1336223e-001,3.9792610e-002),\nvec3(1.1807030e-002,7.0920980e-002,5.4240490e-002),\nvec3(2.9741730e-002,7.0647100e-002,4.1653890e-002),\nvec3(3.6294410e-002,7.1220700e-002,3.7114610e-002),\nvec3(3.9899680e-002,7.0294820e-002,3.2720020e-002),\nvec3(-6.2763130e-002,1.3778012e-001,3.6678590e-002),\nvec3(-1.5815440e-002,1.7504938e-001,-1.8654160e-002),\nvec3(-9.2268990e-002,1.1475156e-001,1.7017380e-002),\nvec3(-9.4964000e-004,1.0141111e-001,4.4290070e-002),\nvec3(-6.3712920e-002,1.1274250e-001,3.8006760e-002),\nvec3(-6.1096020e-002,1.1701650e-001,3.9654020e-002),\nvec3(2.0991870e-002,6.9335450e-002,4.9003540e-002),\nvec3(2.5658530e-002,7.0550460e-002,4.4539930e-002),\nvec3(3.2978560e-002,7.3500690e-002,4.0486510e-002),\nvec3(4.2156130e-002,6.9717580e-002,2.8318230e-002),\nvec3(-5.5516860e-002,1.2956070e-001,3.6598450e-002),\nvec3(-4.0802290e-002,1.6436059e-001,3.7448800e-003),\nvec3(-6.2546500e-003,1.0121650e-001,4.4322030e-002),\nvec3(-1.0986820e-002,1.6621199e-001,-1.6047550e-002),\nvec3(-3.0351420e-002,1.6448158e-001,-5.3291400e-003),\nvec3(2.6110920e-002,1.0088990e-001,4.1733260e-002),\nvec3(-6.5599940e-002,1.1329504e-001,4.2318710e-002),\nvec3(2.8814660e-002,9.6712680e-002,4.2257700e-002),\nvec3(1.5263280e-002,7.1571940e-002,5.2717390e-002),\nvec3(2.8982400e-002,7.4088480e-002,4.3447240e-002),\nvec3(4.4872540e-002,7.5516710e-002,2.3155250e-002),\nvec3(-7.8225230e-002,1.4962481e-001,-2.5019400e-003),\nvec3(-4.6094940e-002,1.5296850e-001,9.0029700e-003),\nvec3(-5.2369030e-002,1.4682913e-001,1.8934650e-002),\nvec3(-2.1592100e-002,1.5763440e-001,-6.8623600e-003),\nvec3(1.7176770e-002,7.3066230e-002,5.1826600e-002),\nvec3(2.2687500e-002,7.5149180e-002,4.9312500e-002),\nvec3(3.5472040e-002,7.3076670e-002,3.8482270e-002),\nvec3(-8.9480840e-002,1.3839976e-001,2.5061450e-002),\nvec3(-5.3216730e-002,1.3221978e-001,3.2978380e-002),\nvec3(-3.7776780e-002,1.5551947e-001,4.3700800e-003),\nvec3(-9.0549380e-002,1.3511875e-001,2.1680550e-002),\nvec3(-6.3366580e-002,1.3037076e-001,4.1669940e-002),\nvec3(1.4074270e-002,7.6651720e-002,5.4221350e-002),\nvec3(1.8109790e-002,7.5806590e-002,5.2488260e-002),\nvec3(4.2209940e-002,7.8861480e-002,2.9187200e-002),\nvec3(-5.2115930e-002,1.4179906e-001,2.0510310e-002),\nvec3(2.9063090e-002,1.1149602e-001,3.3805790e-002),\nvec3(-5.4731460e-002,1.4267229e-001,2.8980480e-002),\nvec3(2.5903640e-002,7.5536040e-002,4.6416650e-002),\nvec3(3.1298760e-002,7.5907440e-002,4.2699060e-002),\nvec3(3.8446170e-002,7.5649430e-002,3.5050640e-002),\nvec3(4.6351670e-002,7.4079520e-002,1.8354320e-002),\nvec3(-4.7656560e-002,1.3077525e-001,2.5523570e-002),\nvec3(-1.1447430e-002,1.7131059e-001,-1.9602980e-002),\nvec3(-3.6647240e-002,1.6640131e-001,-2.8167000e-004),\nvec3(-4.6653530e-002,1.5917824e-001,7.8019000e-003),\nvec3(-4.5569890e-002,1.4663612e-001,5.6514200e-003),\nvec3(4.1438880e-002,9.2365100e-002,-7.4587000e-003),\nvec3(-6.4287420e-002,1.3463625e-001,3.9945640e-002),\nvec3(-6.1128890e-002,1.3178328e-001,3.8915910e-002),\nvec3(-4.7843540e-002,1.2215063e-001,2.8833160e-002),\nvec3(-4.9536830e-002,1.2491344e-001,3.1778440e-002),\nvec3(-7.1135380e-002,1.3817656e-001,4.7853960e-002),\nvec3(1.0113870e-002,7.6468110e-002,5.5256790e-002),\nvec3(1.7897450e-002,7.9516550e-002,5.2759530e-002),\nvec3(2.1740850e-002,8.0250650e-002,5.0425390e-002),\nvec3(2.5271590e-002,7.8724920e-002,4.8026570e-002),\nvec3(3.0885040e-002,7.8999480e-002,4.3388770e-002),\nvec3(-6.2441930e-002,1.4084781e-001,3.6965840e-002),\nvec3(-6.2165060e-002,1.5666850e-001,-1.7837760e-002),\nvec3(2.0657260e-002,1.0416830e-001,4.3004680e-002),\nvec3(-6.3602800e-002,1.1571453e-001,4.2572290e-002),\nvec3(1.4424020e-002,8.0085500e-002,5.3755600e-002),\nvec3(2.8779340e-002,8.2553250e-002,4.4527350e-002),\nvec3(4.4450130e-002,8.1846900e-002,2.4552920e-002),\nvec3(4.5541990e-002,8.3338380e-002,1.9700850e-002),\nvec3(-4.9665810e-002,1.2063801e-001,3.2163270e-002),\nvec3(-2.9177290e-002,1.7619959e-001,-5.6241100e-003),\nvec3(-5.8203130e-002,1.3270975e-001,3.6918680e-002),\nvec3(3.8997050e-002,9.7088220e-002,-7.7799300e-003),\nvec3(-5.4725800e-002,1.2071262e-001,3.7451450e-002),\nvec3(1.3189120e-002,8.4211180e-002,5.3065830e-002),\nvec3(-1.9926300e-002,1.6489742e-001,-9.9900200e-003),\nvec3(2.0153130e-002,1.1849719e-001,3.4271250e-002),\nvec3(-5.5859940e-002,1.1774313e-001,3.7253480e-002),\nvec3(1.8045260e-002,8.3623160e-002,5.1285840e-002),\nvec3(-6.3757130e-002,1.5912175e-001,-5.0155730e-002),\nvec3(-1.8527620e-002,1.7653197e-001,-1.7043540e-002),\nvec3(2.8734400e-002,1.0360053e-001,3.8035240e-002),\nvec3(4.1414010e-002,1.0284216e-001,1.6578920e-002),\nvec3(2.4411730e-002,9.8016880e-002,4.4687400e-002),\nvec3(2.0925180e-002,8.6311430e-002,4.9433120e-002),\nvec3(3.0445010e-002,8.4959560e-002,4.3011090e-002),\nvec3(3.3030090e-002,8.3781640e-002,4.1636930e-002),\nvec3(3.6975090e-002,7.9876480e-002,3.7198390e-002),\nvec3(-7.7721460e-002,1.1355888e-001,4.8155990e-002),\nvec3(2.9250000e-002,1.0651935e-001,3.6590330e-002),\nvec3(-5.3078180e-002,1.3754688e-001,2.8266470e-002),\nvec3(-6.2990590e-002,1.1999459e-001,4.5235530e-002),\nvec3(-6.5398320e-002,1.1751956e-001,4.8735570e-002),\nvec3(3.3373910e-002,1.1227890e-001,2.7788130e-002),\nvec3(3.8413590e-002,8.7489930e-002,3.5185850e-002),\nvec3(-6.1945930e-002,1.6479234e-001,-5.6647670e-002),\nvec3(-2.2876480e-002,1.7392813e-001,-1.3431140e-002),\nvec3(4.3766230e-002,8.8390020e-002,-3.5708800e-003),\nvec3(3.9291530e-002,1.0125969e-001,2.7550520e-002),\nvec3(1.0936230e-002,8.6027290e-002,5.4732670e-002),\nvec3(2.4108720e-002,8.4492600e-002,4.8292310e-002),\nvec3(3.6758390e-002,9.9195470e-002,3.2837670e-002),\nvec3(-5.1941640e-002,1.2565987e-001,3.4587860e-002),\nvec3(-3.1582110e-002,1.6641850e-001,-5.7320000e-003),\nvec3(7.6405900e-003,8.6427230e-002,5.6117850e-002),\nvec3(1.6771020e-002,8.8644690e-002,5.0522960e-002),\nvec3(3.4404610e-002,8.6932850e-002,4.0574270e-002),\nvec3(3.6143820e-002,8.4439200e-002,3.7936930e-002),\nvec3(4.1258830e-002,1.0361081e-001,2.6760600e-003),\nvec3(2.4766140e-002,1.1081111e-001,3.6728360e-002),\nvec3(-2.2601590e-002,1.6250449e-001,-6.0717000e-003),\nvec3(-1.2893670e-002,1.7879041e-001,-2.2624750e-002),\nvec3(-2.4939150e-002,1.7031135e-001,-1.1329700e-002),\nvec3(-4.8468630e-002,1.4559606e-001,8.3661500e-003),\nvec3(1.2534490e-002,8.9593930e-002,5.3394630e-002),\nvec3(2.5872860e-002,8.8482290e-002,4.6655260e-002),\nvec3(3.2756470e-002,8.8969130e-002,4.2215450e-002),\nvec3(-2.3343620e-002,1.6103450e-001,-3.1862400e-003),\nvec3(-9.2594970e-002,1.1943826e-001,2.6802950e-002),\nvec3(-7.4314840e-002,1.3761738e-001,-6.6698800e-003),\nvec3(-9.2499230e-002,1.2131500e-001,2.9256200e-002),\nvec3(-7.7378260e-002,1.5764266e-001,-1.4133650e-002),\nvec3(-9.2907340e-002,1.2307021e-001,3.6523230e-002),\nvec3(2.8423340e-002,8.8011080e-002,4.4234200e-002),\nvec3(3.5251680e-002,9.0836820e-002,3.9183920e-002),\nvec3(1.5760560e-002,9.3203560e-002,4.9939310e-002),\nvec3(3.8785530e-002,9.4954300e-002,3.2520220e-002),\nvec3(-6.1511220e-002,1.2373565e-001,4.3062680e-002),\nvec3(-6.8145120e-002,1.2748676e-001,5.0148970e-002),\nvec3(-2.0616710e-002,1.8237588e-001,-1.4299100e-002),\nvec3(1.5137190e-002,1.1571495e-001,3.7031980e-002),\nvec3(-5.0718270e-002,1.5276300e-001,1.1816680e-002),\nvec3(3.0168690e-002,1.0048686e-001,3.9404710e-002),\nvec3(-8.7426500e-002,9.5469530e-002,4.0312400e-003),\nvec3(-6.0010390e-002,1.4284463e-001,3.5449690e-002),\nvec3(-5.8603310e-002,1.4637237e-001,3.3808800e-002),\nvec3(3.2411650e-002,9.3736150e-002,4.0890240e-002),\nvec3(-7.5917780e-002,1.4997690e-001,-1.6842050e-002),\nvec3(1.8596570e-002,3.5293940e-002,-8.6782200e-003),\nvec3(1.7209800e-002,3.5259400e-002,-1.4685160e-002),\nvec3(4.4326540e-002,9.0818120e-002,2.2097520e-002),\nvec3(3.8335910e-002,3.8830830e-002,3.0938100e-003),\nvec3(2.2192920e-002,3.6775320e-002,-2.0919300e-003),\nvec3(1.9636020e-002,3.8234010e-002,-1.2507670e-002),\nvec3(2.3682120e-002,3.9762540e-002,3.7148760e-002),\nvec3(4.6693280e-002,4.2465320e-002,6.5649500e-003),\nvec3(2.1621110e-002,3.7657240e-002,-4.7021600e-003),\nvec3(1.6638610e-002,3.8196090e-002,-1.9884930e-002),\nvec3(-9.0253980e-002,1.1366307e-001,3.7720210e-002),\nvec3(-9.0593870e-002,1.1373094e-001,1.0276770e-002),\nvec3(-6.2541690e-002,1.7679461e-001,-5.7821820e-002),\nvec3(-1.1091940e-002,1.7992082e-001,-2.5996430e-002),\nvec3(-6.2263130e-002,1.5219935e-001,-2.2578880e-002),\nvec3(-4.2276760e-002,9.4982570e-002,-2.2562420e-002),\nvec3(4.3293410e-002,4.1864140e-002,2.0634400e-003),\nvec3(4.3779590e-002,4.4530720e-002,-1.2622500e-003),\nvec3(2.1696990e-002,4.0427270e-002,-9.4629500e-003),\nvec3(-1.1183700e-002,1.6450000e-001,-1.6151690e-002),\nvec3(-6.2372570e-002,1.5313041e-001,-2.8997120e-002),\nvec3(-9.2489300e-003,1.7725850e-001,-2.8270200e-002),\nvec3(4.1477400e-002,8.5509410e-002,-9.1575000e-003),\nvec3(-8.1268710e-002,1.0879438e-001,2.9440660e-002),\nvec3(4.9575680e-002,4.3815900e-002,1.4582960e-002),\nvec3(5.2987960e-002,4.7747690e-002,5.0420000e-003),\nvec3(2.1977540e-002,4.2855330e-002,-1.4536230e-002),\nvec3(1.8505700e-002,3.8294100e-002,-1.7136500e-002),\nvec3(-3.5100500e-002,1.5203437e-001,-1.3279000e-004),\nvec3(4.8749130e-002,4.5265000e-002,2.3023500e-003),\nvec3(3.1912900e-002,9.9870060e-002,-1.4620980e-002),\nvec3(-1.4222520e-002,1.6167426e-001,-1.3349060e-002),\nvec3(-4.8663640e-002,1.3638523e-001,6.8063900e-003),\nvec3(-9.5837200e-003,1.7426102e-001,-2.8390760e-002),\nvec3(5.2801850e-002,4.6539940e-002,1.0427720e-002),\nvec3(5.1433800e-002,4.8485200e-002,1.0401000e-003),\nvec3(2.3911240e-002,9.8021670e-002,-2.0807290e-002),\nvec3(2.4567060e-002,4.4130110e-002,-1.0820840e-002),\nvec3(2.0356810e-002,4.3662400e-002,-2.0456280e-002),\nvec3(-2.1882420e-002,1.1087418e-001,-1.9695320e-002),\nvec3(-5.3831800e-002,1.4981693e-001,2.5066610e-002),\nvec3(5.4114210e-002,4.7773090e-002,1.7484000e-002),\nvec3(5.6730570e-002,5.0515740e-002,1.0627080e-002),\nvec3(4.5941820e-002,4.8138820e-002,-3.8715700e-003),\nvec3(-8.3817760e-002,1.1109094e-001,2.8524490e-002),\nvec3(2.9207770e-002,4.7450250e-002,-8.5081800e-003),\nvec3(2.8454920e-002,4.8067390e-002,-1.2847240e-002),\nvec3(2.6637260e-002,4.7607100e-002,-1.6427740e-002),\nvec3(2.2040110e-002,4.4992500e-002,-1.7528500e-002),\nvec3(1.9120080e-002,4.7167750e-002,-2.2114680e-002),\nvec3(-1.5782200e-002,1.0072957e-001,-2.3724130e-002),\nvec3(-6.2514170e-002,1.7213119e-001,-5.2788100e-002),\nvec3(-6.2345600e-002,1.4745498e-001,-7.6600200e-003),\nvec3(4.5598180e-002,8.8151720e-002,1.3124070e-002),\nvec3(-4.9422610e-002,1.4283525e-001,8.9728300e-003),\nvec3(-8.2761860e-002,1.1162341e-001,4.4221460e-002),\nvec3(-5.2166220e-002,1.5013661e-001,1.7448750e-002),\nvec3(-6.3616740e-002,1.4801371e-001,-2.0170260e-002),\nvec3(-5.1492690e-002,1.3796388e-001,2.3662180e-002),\nvec3(-6.1517580e-002,1.7517449e-001,-6.0631700e-002),\nvec3(5.6524870e-002,5.0125660e-002,1.5564490e-002),\nvec3(5.5257900e-002,5.1416260e-002,3.2062600e-003),\nvec3(5.0318130e-002,5.2786370e-002,-3.4166300e-003),\nvec3(-6.2681950e-002,1.6744086e-001,-4.5713890e-002),\nvec3(5.6520150e-002,5.1179900e-002,1.9940560e-002),\nvec3(5.6907980e-002,5.1578130e-002,7.2538300e-003),\nvec3(5.2854160e-002,5.1898670e-002,-6.2070000e-004),\nvec3(-3.8921140e-002,3.3767390e-002,-2.9042560e-002),\nvec3(2.9740700e-002,5.0324690e-002,-1.3990860e-002),\nvec3(-6.8796190e-002,3.5117720e-002,-5.2067400e-003),\nvec3(5.8826020e-002,5.5503780e-002,1.8647920e-002),\nvec3(-2.6160570e-002,1.2309988e-001,-4.4735500e-003),\nvec3(-5.3341960e-002,1.4401200e-001,2.4261390e-002),\nvec3(5.8177390e-002,5.2821320e-002,1.5182420e-002),\nvec3(5.9798140e-002,5.6840180e-002,1.3342730e-002),\nvec3(5.4549870e-002,5.6044630e-002,-6.6158000e-004),\nvec3(2.6775460e-002,5.1423450e-002,-2.0234060e-002),\nvec3(-8.6960400e-003,1.7291588e-001,-2.6708770e-002),\nvec3(-7.7039560e-002,7.1967020e-002,2.6405070e-002),\nvec3(-6.3069890e-002,1.5897471e-001,-4.2951850e-002),\nvec3(3.5706690e-002,5.6083040e-002,-8.9993300e-003),\nvec3(3.2600380e-002,5.3707520e-002,-1.1006150e-002),\nvec3(2.9739960e-002,5.2538430e-002,-1.6224950e-002),\nvec3(5.9238530e-002,5.6362780e-002,9.4530800e-003),\nvec3(5.7421750e-002,5.6012210e-002,4.0245600e-003),\nvec3(2.9062990e-002,5.5210580e-002,-1.8042060e-002),\nvec3(-1.7224410e-002,9.5214090e-002,-3.2085300e-002),\nvec3(-8.5911380e-002,1.0968787e-001,7.6582400e-003),\nvec3(6.0594930e-002,6.1677210e-002,1.5591560e-002),\nvec3(5.9531640e-002,6.0504600e-002,5.8397000e-003),\nvec3(5.7306470e-002,5.9944620e-002,1.8886400e-003),\nvec3(3.8829380e-002,5.9839830e-002,-6.4252500e-003),\nvec3(3.0662770e-002,5.7300390e-002,-1.6518370e-002),\nvec3(-2.7762070e-002,1.2068537e-001,-9.0152900e-003),\nvec3(-8.8194590e-002,1.0314633e-001,1.7509020e-002),\nvec3(6.0778800e-002,6.1646560e-002,1.0463990e-002),\nvec3(3.5915080e-002,5.9916380e-002,-1.1966510e-002),\nvec3(2.4251860e-002,5.6457470e-002,-2.4254800e-002),\nvec3(-6.1954390e-002,1.6865320e-001,-5.2621160e-002),\nvec3(-9.0557930e-002,1.1275994e-001,1.6141030e-002),\nvec3(-8.8469220e-002,1.1124294e-001,1.2679160e-002),\nvec3(5.9558010e-002,6.3099260e-002,5.9471000e-003),\nvec3(3.0940440e-002,6.0518080e-002,-1.8132720e-002),\nvec3(-9.3575750e-002,1.2474629e-001,2.6213300e-002),\nvec3(-9.3189820e-002,1.2019919e-001,3.7913720e-002),\nvec3(-9.2296100e-003,1.7314463e-001,-2.4197660e-002),\nvec3(-8.1739460e-002,7.6861340e-002,2.3313610e-002),\nvec3(-3.6992750e-002,1.5063932e-001,-2.0372300e-003),\nvec3(6.0093570e-002,6.5693450e-002,1.8533320e-002),\nvec3(5.9837240e-002,6.6423180e-002,8.5139400e-003),\nvec3(4.0706180e-002,6.4475310e-002,-5.5920300e-003),\nvec3(3.4745940e-002,6.3261340e-002,-1.4646740e-002),\nvec3(-6.1879660e-002,1.6000450e-001,-2.5806250e-002),\nvec3(-7.6537810e-002,1.5344875e-001,-1.2898750e-002),\nvec3(3.8111070e-002,6.4811810e-002,-1.1142000e-002),\nvec3(3.1909340e-002,6.4657050e-002,-1.8473410e-002),\nvec3(-8.3159350e-002,1.4674277e-001,3.0757900e-003),\nvec3(-8.7055900e-002,1.0562761e-001,9.7651100e-003),\nvec3(-7.1448330e-002,1.8105301e-001,-5.5478550e-002),\nvec3(-8.5632110e-002,1.2461094e-001,-2.7335800e-003),\nvec3(6.0728970e-002,6.5806600e-002,1.3974830e-002),\nvec3(3.9909650e-002,6.8171740e-002,-9.5698200e-003),\nvec3(3.4981790e-002,6.7740790e-002,-1.5683210e-002),\nvec3(-9.1822030e-002,1.2747346e-001,3.6458650e-002),\nvec3(-6.2425420e-002,1.6366637e-001,-4.9667290e-002),\nvec3(-7.1168950e-002,1.4740156e-001,-2.7590940e-002),\nvec3(-5.0364760e-002,1.3715763e-001,1.9526100e-003),\nvec3(-5.0492650e-002,1.4159899e-001,1.6291740e-002),\nvec3(5.9886670e-002,6.8513050e-002,1.6171610e-002),\nvec3(-6.1406990e-002,1.7268822e-001,-5.8265750e-002),\nvec3(2.4990740e-002,6.5897320e-002,-2.3568270e-002),\nvec3(-7.4852750e-002,1.4993112e-001,-2.7752940e-002),\nvec3(-6.2225690e-002,6.0265200e-002,2.0449290e-002),\nvec3(-6.2001940e-002,3.6435020e-002,4.3918940e-002),\nvec3(5.8374570e-002,7.1186410e-002,1.3072740e-002),\nvec3(-3.6125040e-002,1.2286688e-001,-8.2927900e-003),\nvec3(2.9216510e-002,6.7850250e-002,-2.0418570e-002),\nvec3(-4.1681700e-002,1.2575112e-001,-7.0193300e-003),\nvec3(-7.4226550e-002,1.6437012e-001,-3.8240340e-002),\nvec3(-9.7845700e-003,1.6928488e-001,-2.4756660e-002),\nvec3(-8.9577950e-002,1.2078310e-001,3.5229100e-003),\nvec3(-6.2311930e-002,1.6371109e-001,-4.0623990e-002),\nvec3(4.3514770e-002,9.1519890e-002,-2.6468100e-003),\nvec3(-4.8434350e-002,1.3754973e-001,1.3244980e-002),\nvec3(-8.9313160e-002,1.3653006e-001,3.0458750e-002),\nvec3(-7.4230190e-002,1.5652681e-001,-2.5167090e-002),\nvec3(3.7378600e-002,7.3093410e-002,-1.2635370e-002),\nvec3(2.6321810e-002,7.0240650e-002,-2.3878680e-002),\nvec3(-4.8023620e-002,1.4426649e-001,4.2498600e-003),\nvec3(-9.2019580e-002,1.1611534e-001,3.5842730e-002),\nvec3(-7.1305510e-002,7.3899020e-002,3.5969780e-002),\nvec3(-6.2059290e-002,1.5697807e-001,-3.3784580e-002),\nvec3(-9.7015300e-003,1.6738863e-001,-1.9360250e-002),\nvec3(4.3342140e-002,7.1676120e-002,-2.2304600e-003),\nvec3(4.1772460e-002,6.9568020e-002,-6.1596000e-003),\nvec3(3.3505410e-002,7.2809860e-002,-1.7034800e-002),\nvec3(2.9665000e-002,7.1506830e-002,-2.1282340e-002),\nvec3(-2.9460160e-002,1.5550263e-001,-1.1914700e-003),\nvec3(-8.6396440e-002,1.0479356e-001,5.9820600e-003),\nvec3(-5.4910700e-002,1.4662313e-001,2.8438970e-002),\nvec3(4.4203810e-002,8.5204260e-002,-2.1170500e-003),\nvec3(4.3264350e-002,7.5810540e-002,-3.8843900e-003),\nvec3(1.3096990e-002,9.1126480e-002,-2.9269770e-002),\nvec3(-6.7069210e-002,9.1144610e-002,-1.7425950e-002),\nvec3(-9.0821680e-002,1.2276896e-001,6.0998500e-003),\nvec3(4.5620000e-002,7.4684430e-002,2.6073900e-003),\nvec3(-9.3039800e-002,1.2026416e-001,1.1216820e-002),\nvec3(4.4635590e-002,9.2794290e-002,1.7832070e-002),\nvec3(-1.1243390e-002,1.6457514e-001,-1.8240780e-002),\nvec3(4.5511190e-002,8.6953050e-002,3.8865500e-003),\nvec3(4.6252720e-002,7.7373870e-002,6.9140800e-003),\nvec3(4.0281640e-002,7.2637130e-002,-9.2881000e-003),\nvec3(4.3218200e-002,9.9486740e-002,5.0153300e-003),\nvec3(-5.1108270e-002,1.4520219e-001,1.4279480e-002),\nvec3(4.4692980e-002,9.2688550e-002,2.2466700e-003),\nvec3(4.3422540e-002,9.1860370e-002,2.4538450e-002),\nvec3(4.0751360e-002,1.0554729e-001,7.5074100e-003),\nvec3(-8.5613030e-002,9.6277110e-002,-6.6514000e-004),\nvec3(4.0721470e-002,7.8475530e-002,-8.2130000e-003),\nvec3(3.5538080e-002,7.6062960e-002,-1.4434750e-002),\nvec3(-9.2736510e-002,1.2073095e-001,3.2692730e-002),\nvec3(-6.2278520e-002,1.5166598e-001,-1.4672730e-002),\nvec3(4.4960220e-002,8.0942630e-002,6.1119000e-004),\nvec3(3.7814740e-002,7.9698150e-002,-1.3289630e-002),\nvec3(3.3864490e-002,7.8656690e-002,-1.7632490e-002),\nvec3(-9.1044280e-002,1.4199862e-001,2.1729630e-002),\nvec3(-7.4004450e-002,1.7818523e-001,-5.3916320e-002),\nvec3(-6.1768650e-002,1.6067957e-001,-3.4046350e-002),\nvec3(-4.9747450e-002,1.4112519e-001,5.2937500e-003),\nvec3(4.1065440e-002,9.0460700e-002,2.9888620e-002),\nvec3(-7.2916360e-002,6.5057400e-002,1.8794620e-002),\nvec3(-9.0949690e-002,1.3895375e-001,1.7371130e-002),\nvec3(4.2879050e-002,1.0093777e-001,9.4753200e-003),\nvec3(-7.2455480e-002,1.7610676e-001,-5.3535420e-002),\nvec3(-7.5862940e-002,1.5071299e-001,-9.0209000e-003),\nvec3(-8.5269820e-002,1.0267793e-001,1.3935600e-003),\nvec3(-7.7025570e-002,1.1396763e-001,-4.6168100e-003),\nvec3(4.6280880e-002,7.8702020e-002,1.4786330e-002),\nvec3(4.2106910e-002,8.1533160e-002,-6.6690900e-003),\nvec3(3.6523880e-002,8.1991750e-002,-1.6229590e-002),\nvec3(-3.7420220e-002,4.5428500e-002,-2.4226790e-002),\nvec3(-8.5148910e-002,1.3965520e-001,2.4808500e-003),\nvec3(-6.3313300e-002,1.6503258e-001,-3.2895120e-002),\nvec3(-6.1591410e-002,1.5681572e-001,-2.5945630e-002),\nvec3(4.5918540e-002,8.7036220e-002,8.4236300e-003),\nvec3(4.4631140e-002,8.4178380e-002,8.2665000e-004),\nvec3(-4.4842870e-002,1.4629393e-001,1.7114800e-003),\nvec3(-6.4124180e-002,1.7953625e-001,-5.8730420e-002),\nvec3(-6.7070300e-002,1.8072682e-001,-5.6618620e-002),\nvec3(-6.4793760e-002,1.7885275e-001,-5.5883250e-002),\nvec3(-6.4371030e-002,1.7296209e-001,-4.9225660e-002),\nvec3(-7.0381530e-002,1.8071180e-001,-5.3172590e-002),\nvec3(-7.5269270e-002,1.5232949e-001,3.4374060e-002),\nvec3(-1.6273090e-002,1.2844514e-001,1.6683610e-002),\nvec3(-6.2116150e-002,1.5600787e-001,1.8034420e-002),\nvec3(-5.6010790e-002,1.5381662e-001,2.5369280e-002),\nvec3(-3.7277920e-002,1.7289068e-001,-8.6627000e-004),\nvec3(-7.4158700e-002,1.7987275e-001,-5.0794750e-002),\nvec3(-7.9039960e-002,1.5537445e-001,1.5141810e-002),\nvec3(-7.2505530e-002,1.5459529e-001,2.9588830e-002),\nvec3(-6.7738180e-002,1.7728865e-001,-5.0375960e-002),\nvec3(-7.5346900e-003,1.0021302e-001,4.7488700e-002),\nvec3(-5.9575620e-002,1.5472401e-001,2.6373250e-002),\nvec3(-7.7382710e-002,1.5346600e-001,3.0894990e-002),\nvec3(-8.1496670e-002,1.5473104e-001,1.9697340e-002),\nvec3(-7.2223320e-002,1.5896734e-001,-5.4242300e-003),\nvec3(-1.3708500e-002,1.8491150e-001,-2.5549550e-002),\nvec3(-4.3465340e-002,1.2451145e-001,2.2518890e-002),\nvec3(-6.9103650e-002,1.5559479e-001,1.6370800e-003),\nvec3(-7.3748080e-002,1.5539253e-001,2.3491700e-003),\nvec3(-6.8192410e-002,1.7439828e-001,-4.5365870e-002),\nvec3(-6.0052850e-002,1.5280350e-001,3.2887630e-002),\nvec3(-2.3459490e-002,1.2615386e-001,1.6613770e-002),\nvec3(-7.2777220e-002,1.7854465e-001,-4.8208800e-002),\nvec3(-7.6595580e-002,1.7753227e-001,-4.7118080e-002),\nvec3(1.3906410e-002,1.2790838e-001,2.5110240e-002),\nvec3(-8.6367510e-002,1.0906537e-001,1.1980640e-002),\nvec3(-3.1358850e-002,1.2140977e-001,2.5971090e-002),\nvec3(-4.9104590e-002,1.3666879e-001,1.9314030e-002),\nvec3(-4.2930640e-002,1.2928436e-001,9.2700700e-003),\nvec3(-6.5320350e-002,1.5390322e-001,9.1386000e-004),\nvec3(-3.7606490e-002,1.2422605e-001,2.4313530e-002),\nvec3(9.5078400e-003,1.3041865e-001,2.0715020e-002),\nvec3(-1.7976800e-003,1.3117283e-001,1.6360660e-002),\nvec3(3.6231700e-003,1.3076791e-001,2.1168600e-002),\nvec3(-9.2674700e-002,1.1701945e-001,1.1889520e-002),\nvec3(-6.5739720e-002,1.5565338e-001,2.6017600e-002),\nvec3(-8.6561940e-002,1.4249188e-001,8.4326800e-003),\nvec3(-7.0731530e-002,1.5569959e-001,6.9058200e-003),\nvec3(-8.0840700e-003,1.3030537e-001,1.6872280e-002),\nvec3(-4.4286250e-002,1.2606625e-001,2.0795220e-002),\nvec3(-7.0222260e-002,1.5143521e-001,3.6718910e-002),\nvec3(-1.5210690e-002,1.8463639e-001,-2.2057240e-002),\nvec3(-1.7270750e-002,1.8699602e-001,-1.9977570e-002),\nvec3(-8.3560950e-002,1.5255943e-001,7.6806700e-003),\nvec3(-8.8130280e-002,9.7540510e-002,5.6788000e-003),\nvec3(-8.8399240e-002,1.3899000e-001,1.0640660e-002),\nvec3(-6.7780550e-002,1.5614453e-001,1.4276320e-002),\nvec3(-6.5864600e-003,1.2641717e-001,3.0226390e-002),\nvec3(-8.8746180e-002,1.3625578e-001,7.1477800e-003),\nvec3(-7.7206730e-002,1.5639950e-001,-1.8972540e-002),\nvec3(-9.3176480e-002,1.1821016e-001,2.3362360e-002),\nvec3(-2.3506850e-002,1.2672006e-001,1.0996900e-002),\nvec3(-6.6546650e-002,1.7171115e-001,-4.2127770e-002),\nvec3(-6.9136000e-002,1.7247836e-001,-3.9013330e-002),\nvec3(5.7180270e-002,7.1107690e-002,8.0307600e-003),\nvec3(-7.5390870e-002,1.7952824e-001,-5.2402050e-002),\nvec3(-3.1828840e-002,1.2639115e-001,1.0013410e-002),\nvec3(-8.9888800e-003,1.2952269e-001,2.2026810e-002),\nvec3(3.4325880e-002,1.1193312e-001,-2.2406500e-003),\nvec3(-8.1414950e-002,9.7100250e-002,-6.8745800e-003),\nvec3(-2.3298830e-002,1.8324307e-001,-1.7923000e-002),\nvec3(-6.1641660e-002,1.5582039e-001,1.1099820e-002),\nvec3(-8.8826450e-002,9.0483320e-002,2.1204700e-002),\nvec3(5.8373130e-002,6.8067590e-002,5.7247600e-003),\nvec3(-4.3045630e-002,1.2785122e-001,1.6842260e-002),\nvec3(3.0835720e-002,1.1554234e-001,-3.1785500e-003),\nvec3(-8.8631270e-002,9.4881200e-002,7.9337600e-003),\nvec3(-9.1715140e-002,1.1709957e-001,3.0809400e-002),\nvec3(-7.2083780e-002,1.7499844e-001,-4.1930320e-002),\nvec3(-6.9540630e-002,1.5308527e-001,3.3865720e-002),\nvec3(6.0078690e-002,6.8129260e-002,1.1454500e-002),\nvec3(-4.0081060e-002,1.2628381e-001,1.9607250e-002),\nvec3(3.2819930e-002,1.1655625e-001,4.4458600e-003),\nvec3(-7.2823220e-002,1.4510601e-001,-1.5654680e-002),\nvec3(-8.5270210e-002,1.0551770e-001,2.3290940e-002),\nvec3(-7.6051320e-002,1.1103825e-001,-6.2722100e-003),\nvec3(-8.6537730e-002,1.5154801e-001,2.5875370e-002),\nvec3(5.5888480e-002,7.2579250e-002,1.0669650e-002),\nvec3(-5.4642360e-002,1.5522963e-001,1.2612400e-002),\nvec3(3.6729960e-002,1.1116756e-001,3.8670600e-003),\nvec3(3.1501870e-002,1.1725172e-001,1.6855100e-003),\nvec3(-7.8751550e-002,9.5240290e-002,-1.0600670e-002),\nvec3(-8.9408160e-002,1.4352815e-001,3.0924750e-002),\nvec3(-2.0891130e-002,1.8595338e-001,-1.5037360e-002),\nvec3(-7.0863560e-002,1.6136525e-001,-9.7324600e-003),\nvec3(-7.0919760e-002,1.7136688e-001,-3.2763750e-002),\nvec3(-3.0771290e-002,1.2564075e-001,1.6594770e-002),\nvec3(-5.4454180e-002,1.5297699e-001,2.2505190e-002),\nvec3(-1.5539500e-003,1.2754717e-001,2.9232870e-002),\nvec3(2.9130550e-002,1.2027445e-001,6.1117500e-003),\nvec3(2.5725940e-002,1.2122705e-001,-3.6150000e-005),\nvec3(-8.9318970e-002,9.9546980e-002,1.3418110e-002),\nvec3(-7.5429500e-002,1.7095605e-001,-3.2879890e-002),\nvec3(-2.8596020e-002,1.1901156e-001,2.9888170e-002),\nvec3(2.1069780e-002,1.2497756e-001,1.0998100e-003),\nvec3(-9.2240760e-002,1.1816838e-001,4.1201730e-002),\nvec3(2.4094600e-003,1.0016785e-001,4.6938070e-002),\nvec3(-5.6627620e-002,1.5270606e-001,2.9629030e-002),\nvec3(-5.7264800e-002,1.5506250e-001,1.9322430e-002),\nvec3(-3.6452070e-002,1.2199869e-001,2.7670650e-002),\nvec3(-7.4108160e-002,1.7355729e-001,-3.7986840e-002),\nvec3(5.1537130e-002,7.3496690e-002,1.2698700e-002),\nvec3(-6.6096040e-002,1.5532529e-001,7.1561800e-003),\nvec3(3.6102000e-002,1.1266103e-001,1.0491780e-002),\nvec3(1.6715210e-002,1.2689851e-001,2.2331000e-004),\nvec3(-8.0767920e-002,1.4301400e-001,-1.5312800e-003),\nvec3(-9.1757600e-002,1.4334588e-001,1.7790710e-002),\nvec3(-8.6824940e-002,1.5280775e-001,1.5521450e-002),\nvec3(-6.5808100e-002,1.6764344e-001,-3.0558670e-002),\nvec3(-7.8217340e-002,1.6873975e-001,-3.3564250e-002),\nvec3(-7.2567060e-002,1.4753230e-001,4.1714090e-002),\nvec3(5.8439960e-002,7.0200810e-002,1.7779620e-002),\nvec3(5.6847560e-002,7.2017160e-002,1.7139380e-002),\nvec3(5.4919390e-002,7.3161610e-002,1.5223590e-002),\nvec3(4.7446900e-002,7.3691410e-002,1.2430020e-002),\nvec3(1.2319360e-002,1.2903768e-001,1.3336200e-003),\nvec3(-7.9790640e-002,1.0351662e-001,-6.6275400e-003),\nvec3(-7.6655210e-002,1.5509766e-001,7.9686300e-003),\nvec3(2.1747320e-002,1.2118456e-001,3.0878810e-002),\nvec3(-7.5260490e-002,1.4938613e-001,3.9175980e-002),\nvec3(-2.5919610e-002,1.8272826e-001,-1.3541090e-002),\nvec3(-6.7983790e-002,1.6974781e-001,-3.1627490e-002),\nvec3(1.6831110e-002,1.2487146e-001,2.8425580e-002),\nvec3(5.4016490e-002,7.2883850e-002,1.8678010e-002),\nvec3(5.0522750e-002,7.3397910e-002,1.6166890e-002),\nvec3(-5.9582440e-002,1.5623338e-001,7.9209900e-003),\nvec3(2.5343500e-002,1.2374750e-001,9.9818800e-003),\nvec3(1.9262750e-002,1.2689390e-001,5.5552100e-003),\nvec3(-9.0758520e-002,1.4223375e-001,2.6008130e-002),\nvec3(-4.6548490e-002,1.3320769e-001,1.6889630e-002),\nvec3(-2.4106950e-002,1.8380887e-001,-1.1544760e-002),\nvec3(8.6784400e-003,1.2894574e-001,2.6156880e-002),\nvec3(2.4919200e-003,1.2983563e-001,2.4847110e-002),\nvec3(5.7345150e-002,6.9482720e-002,2.1153510e-002),\nvec3(-8.5329840e-002,1.5339912e-001,2.0378290e-002),\nvec3(3.2877320e-002,1.1691463e-001,9.2957500e-003),\nvec3(2.4246630e-002,1.2377758e-001,4.8764500e-003),\nvec3(-4.7765650e-002,1.3301969e-001,2.2874020e-002),\nvec3(-6.3541830e-002,1.6332115e-001,-2.5912990e-002),\nvec3(-6.6605200e-002,1.6477375e-001,-2.0670760e-002),\nvec3(-6.8504220e-002,1.6732018e-001,-2.3959570e-002),\nvec3(-7.2759160e-002,1.6965906e-001,-2.7013420e-002),\nvec3(4.8206850e-002,7.2698580e-002,1.6994630e-002),\nvec3(-2.7383180e-002,1.2324257e-001,2.1658860e-002),\nvec3(-4.5077500e-002,1.3124443e-001,1.1145770e-002),\nvec3(2.9253150e-002,1.2057701e-001,1.2299330e-002),\nvec3(1.3677610e-002,1.2967262e-001,6.9327400e-003),\nvec3(8.4210900e-003,1.3090986e-001,6.2754400e-003),\nvec3(9.6836000e-004,1.3064303e-001,2.5865900e-003),\nvec3(3.0802000e-003,9.8307360e-002,5.0535640e-002),\nvec3(-5.2420170e-002,1.5310101e-001,1.2927370e-002),\nvec3(-7.0359720e-002,1.6906988e-001,-2.6144260e-002),\nvec3(5.4359390e-002,7.1467260e-002,2.1381250e-002),\nvec3(4.5161440e-002,7.1030380e-002,2.2530690e-002),\nvec3(1.9320440e-002,1.2738348e-001,1.1296310e-002),\nvec3(-9.3281210e-002,1.2691094e-001,1.3505010e-002),\nvec3(-8.7405060e-002,1.0593990e-001,1.3645920e-002),\nvec3(-2.2851640e-002,9.0635040e-002,5.2280460e-002),\nvec3(-6.2099370e-002,1.5406697e-001,3.0837360e-002),\nvec3(-4.5851560e-002,1.2072981e-001,2.7665040e-002),\nvec3(5.0781670e-002,7.2155170e-002,2.0680180e-002),\nvec3(-8.9607270e-002,1.3971105e-001,2.9308560e-002),\nvec3(-5.3323050e-002,1.5273520e-001,1.6213860e-002),\nvec3(-1.5227080e-002,1.2784878e-001,2.1545200e-002),\nvec3(3.3663540e-002,1.1574212e-001,1.7181290e-002),\nvec3(2.4000260e-002,1.2468761e-001,1.5517930e-002),\nvec3(-8.4166840e-002,9.7756820e-002,-3.2761900e-003),\nvec3(-3.6223590e-002,1.2777519e-001,9.8501500e-003),\nvec3(-3.9189580e-002,1.2828193e-001,5.0346300e-003),\nvec3(-3.3674050e-002,1.7774449e-001,-8.1799500e-003),\nvec3(-7.4488620e-002,1.5649443e-001,-2.5954600e-003),\nvec3(-4.6755620e-002,1.3284294e-001,8.1212800e-003),\nvec3(-8.4970410e-002,1.5322309e-001,1.2654460e-002),\nvec3(-1.0866210e-002,1.2691699e-001,2.7575440e-002),\nvec3(-3.1074000e-003,1.3072898e-001,5.6428500e-003),\nvec3(-8.8760540e-002,9.7037440e-002,2.1079040e-002),\nvec3(-6.4811320e-002,3.4530640e-002,1.5508440e-002),\nvec3(-6.4300260e-002,3.5086450e-002,2.4272050e-002),\nvec3(-6.6727020e-002,3.5895770e-002,3.3849430e-002),\nvec3(1.9838510e-002,9.6518890e-002,-2.2785880e-002),\nvec3(-3.8670510e-002,1.6070199e-001,-1.2357760e-002),\nvec3(-7.6890090e-002,1.3041906e-001,-6.9570100e-003),\nvec3(-7.2539730e-002,3.5399270e-002,7.0298800e-003),\nvec3(-6.9209050e-002,3.5454810e-002,1.2042140e-002),\nvec3(-6.4160810e-002,3.5900770e-002,1.7687570e-002),\nvec3(-6.6804150e-002,3.7377740e-002,3.3296290e-002),\nvec3(-6.2928350e-002,3.9061660e-002,4.2707680e-002),\nvec3(-7.1752230e-002,3.6789350e-002,8.6966700e-003),\nvec3(-6.5171380e-002,3.7289500e-002,2.5953770e-002),\nvec3(-6.6392030e-002,3.7712350e-002,2.9621950e-002),\nvec3(-6.4558720e-002,3.9639900e-002,3.9411530e-002),\nvec3(-6.0145790e-002,4.1202050e-002,4.4293830e-002),\nvec3(-6.0318430e-002,3.8442990e-002,4.5245950e-002),\nvec3(-3.6756310e-002,8.8663360e-002,-2.3868800e-002),\nvec3(-3.9494750e-002,3.7551570e-002,4.2870900e-002),\nvec3(-7.2016030e-002,3.7572700e-002,3.9789400e-003),\nvec3(-7.1693630e-002,3.9461000e-002,6.0145000e-003),\nvec3(-7.1165950e-002,3.9366310e-002,8.1142100e-003),\nvec3(-6.9000300e-002,3.8467710e-002,1.0768900e-002),\nvec3(-6.7253420e-002,3.8142160e-002,1.3533960e-002),\nvec3(-6.1125670e-002,3.7790050e-002,1.9710900e-002),\nvec3(-3.9179680e-002,4.2406740e-002,4.1476070e-002),\nvec3(-3.5145960e-002,3.8585920e-002,4.7732690e-002),\nvec3(-2.8950940e-002,3.9285940e-002,5.3309090e-002),\nvec3(-1.8223900e-002,9.7494570e-002,4.6847940e-002),\nvec3(-6.6916260e-002,1.2278907e-001,-8.9077400e-003),\nvec3(-6.3754640e-002,3.8250120e-002,1.6593500e-002),\nvec3(-6.4415760e-002,4.1283840e-002,2.8243480e-002),\nvec3(-8.5856340e-002,9.7025390e-002,2.7414960e-002),\nvec3(-3.7501130e-002,4.0221900e-002,4.4296550e-002),\nvec3(-3.4333970e-002,4.0923630e-002,4.8425810e-002),\nvec3(-3.1172890e-002,4.0294330e-002,5.1312460e-002),\nvec3(-6.9997320e-002,4.2073080e-002,6.6897800e-003),\nvec3(-8.0379330e-002,9.7800660e-002,3.3645750e-002),\nvec3(-2.6273160e-002,7.7631160e-002,4.8356180e-002),\nvec3(-3.7501450e-002,4.2736690e-002,4.2988400e-002),\nvec3(-2.6177500e-002,4.2498930e-002,5.3315220e-002),\nvec3(-6.9637250e-002,4.1881270e-002,3.1825800e-003),\nvec3(-6.7156510e-002,4.1972860e-002,1.0240940e-002),\nvec3(-8.7405510e-002,1.0205209e-001,2.2020360e-002),\nvec3(-2.3944380e-002,7.8800140e-002,5.3534730e-002),\nvec3(-6.0902360e-002,4.3429500e-002,4.2678530e-002),\nvec3(-3.1217880e-002,4.3847510e-002,4.9780920e-002),\nvec3(-7.5729440e-002,1.0354026e-001,3.6070970e-002),\nvec3(-6.2425320e-002,4.1885720e-002,1.4646770e-002),\nvec3(-6.1051660e-002,4.4392230e-002,1.2421940e-002),\nvec3(2.5855060e-002,8.9610660e-002,-2.2701840e-002),\nvec3(-7.7644960e-002,8.2214940e-002,3.5797660e-002),\nvec3(-6.0381270e-002,4.5921420e-002,4.0088740e-002),\nvec3(-2.4982010e-002,8.1777650e-002,5.3421060e-002),\nvec3(-3.4453850e-002,4.4563960e-002,4.5422990e-002),\nvec3(-2.9842910e-002,4.6782280e-002,4.7746920e-002),\nvec3(-1.5119580e-002,9.9930020e-002,4.4500270e-002),\nvec3(-6.7306470e-002,4.4176830e-002,7.5958300e-003),\nvec3(-5.7852990e-002,4.6444500e-002,1.1062610e-002),\nvec3(-5.1815260e-002,1.6392582e-001,1.7488800e-003),\nvec3(-5.5174130e-002,4.8383880e-002,3.8517780e-002),\nvec3(-7.8849150e-002,1.1867375e-001,5.0622870e-002),\nvec3(-2.7229070e-002,8.7991480e-002,4.7909730e-002),\nvec3(-7.5536880e-002,1.5977062e-001,-1.0438650e-002),\nvec3(-3.6151280e-002,4.6505140e-002,4.0740900e-002),\nvec3(-2.5439220e-002,9.0677870e-002,4.8852330e-002),\nvec3(-8.0050370e-002,1.1670406e-001,4.8762460e-002),\nvec3(-5.2513640e-002,4.7577880e-002,1.4858440e-002),\nvec3(-3.2043560e-002,5.0461830e-002,3.9341520e-002),\nvec3(-3.1487770e-002,4.6930210e-002,4.5253210e-002),\nvec3(-2.0321500e-002,9.3999570e-002,5.1588540e-002),\nvec3(-7.2145040e-002,9.1556450e-002,4.1494780e-002),\nvec3(-5.3644200e-002,4.9358170e-002,1.2201850e-002),\nvec3(-8.2403890e-002,1.2186563e-001,4.9365030e-002),\nvec3(-4.9754420e-002,4.9738300e-002,3.7037110e-002),\nvec3(-3.2332060e-002,4.8672840e-002,4.2523960e-002),\nvec3(-2.3122950e-002,9.4515900e-002,4.7358870e-002),\nvec3(-8.6347140e-002,9.1722090e-002,2.6811080e-002),\nvec3(-5.7713110e-002,4.8717820e-002,7.2765100e-003),\nvec3(-8.6970360e-002,8.8912090e-002,2.4879860e-002),\nvec3(-9.2237750e-002,1.2488519e-001,4.0786530e-002),\nvec3(-1.5862800e-002,9.7021620e-002,5.0139360e-002),\nvec3(-2.7720040e-002,5.0502090e-002,4.3340720e-002),\nvec3(-8.5918770e-002,1.4263412e-001,3.9849810e-002),\nvec3(-7.5097360e-002,9.0073560e-002,3.9581000e-002),\nvec3(-8.9430840e-002,1.4730552e-001,2.7694960e-002),\nvec3(-5.3288350e-002,5.1925760e-002,1.1730350e-002),\nvec3(-5.0168720e-002,5.3462260e-002,1.6255440e-002),\nvec3(-8.5986050e-002,1.4670902e-001,3.4827030e-002),\nvec3(-6.9937250e-002,8.6076860e-002,4.2175690e-002),\nvec3(-5.0399320e-002,5.1831330e-002,3.4037400e-002),\nvec3(-8.3298980e-002,1.4960772e-001,3.3740890e-002),\nvec3(-2.9174820e-002,5.2264530e-002,3.7637320e-002),\nvec3(-8.8763730e-002,1.1944938e-001,4.6560090e-002),\nvec3(-7.7693460e-002,1.7367969e-001,-4.1478670e-002),\nvec3(-8.3418140e-002,9.4127440e-002,3.0898450e-002),\nvec3(-5.6067510e-002,5.3470630e-002,7.3718200e-003),\nvec3(-7.8935630e-002,1.4817228e-001,3.9463070e-002),\nvec3(-6.7902770e-002,8.7817230e-002,4.3526990e-002),\nvec3(-4.4111240e-002,9.2883990e-002,-2.2373210e-002),\nvec3(-8.6605100e-002,1.3226807e-001,4.6783020e-002),\nvec3(-9.2654280e-002,1.2084025e-001,4.1629650e-002),\nvec3(-5.0887310e-002,5.2727900e-002,1.4455790e-002),\nvec3(-4.9763410e-002,5.6241200e-002,3.3624250e-002),\nvec3(-8.9771330e-002,1.2904861e-001,4.3022990e-002),\nvec3(-2.8054240e-002,5.4551030e-002,3.6786850e-002),\nvec3(-2.5867080e-002,5.6689210e-002,3.9182240e-002),\nvec3(-8.3702200e-002,1.2226381e-001,-3.7301400e-003),\nvec3(-8.1455470e-002,1.3012213e-001,5.2117660e-002),\nvec3(-5.1458550e-002,5.5878150e-002,1.5900350e-002),\nvec3(-7.8597700e-002,1.7441574e-001,-4.6607580e-002),\nvec3(-5.2909820e-002,5.7043070e-002,2.0988410e-002),\nvec3(-5.2978500e-002,5.9553770e-002,2.6211920e-002),\nvec3(-5.2130640e-002,5.6302970e-002,2.6672460e-002),\nvec3(-4.7714500e-002,6.1944520e-002,3.6705820e-002),\nvec3(-8.3539790e-002,8.1169560e-002,2.7014070e-002),\nvec3(-1.8340000e-002,5.7489970e-002,4.9763020e-002),\nvec3(-8.0069810e-002,9.0586130e-002,3.4593070e-002),\nvec3(-8.3812250e-002,8.6337700e-002,2.9223270e-002),\nvec3(-5.5436650e-002,5.9420250e-002,2.3018970e-002),\nvec3(-8.2227680e-002,1.4513771e-001,4.0600080e-002),\nvec3(-2.4187580e-002,7.2269150e-002,4.7681090e-002),\nvec3(-2.5353150e-002,6.2567200e-002,4.0642170e-002),\nvec3(-9.1132110e-002,1.2282100e-001,4.4115160e-002),\nvec3(-4.6076290e-002,1.6819719e-001,7.3744000e-004),\nvec3(-8.7829280e-002,1.4351461e-001,3.5707670e-002),\nvec3(-8.6990640e-002,1.3812326e-001,4.2316550e-002),\nvec3(-1.5715900e-002,6.0822970e-002,5.2365440e-002),\nvec3(-8.3803580e-002,1.2561100e-001,5.0440490e-002),\nvec3(-6.2786680e-002,1.1274190e-001,-1.3605440e-002),\nvec3(-8.1033840e-002,8.4698180e-002,3.3106400e-002),\nvec3(-8.8563540e-002,1.1624535e-001,4.5392840e-002),\nvec3(-2.0268380e-002,6.2266810e-002,4.8212120e-002),\nvec3(-1.2619630e-002,6.1635030e-002,5.4424080e-002),\nvec3(-7.0491190e-002,8.1818160e-002,4.0609890e-002),\nvec3(-8.3882520e-002,1.3331465e-001,4.9113540e-002),\nvec3(-5.6560350e-002,4.8355540e-002,3.6607050e-002),\nvec3(9.9444900e-003,1.0919723e-001,-1.9472810e-002),\nvec3(-5.5928250e-002,3.5917310e-002,4.6376100e-002),\nvec3(-7.6003260e-002,1.6361344e-001,-1.8021110e-002),\nvec3(-8.3798850e-002,1.0290691e-001,2.8038330e-002),\nvec3(-8.8252110e-002,1.2692730e-001,4.6141300e-002),\nvec3(-7.9126720e-002,1.0619883e-001,3.2050700e-002),\nvec3(-8.8206230e-002,9.4485700e-002,2.3744010e-002),\nvec3(-8.9110330e-002,1.3851394e-001,3.7658780e-002),\nvec3(-1.9321360e-002,9.2123890e-002,5.3820650e-002),\nvec3(-5.8265630e-002,9.0926390e-002,-2.0948690e-002),\nvec3(-2.7046310e-002,6.7014450e-002,3.9672140e-002),\nvec3(-2.1416300e-002,1.7977662e-001,-2.1732520e-002),\nvec3(-7.8240000e-003,1.0924112e-001,-2.2185670e-002),\nvec3(-2.3988340e-002,8.5995590e-002,5.3716430e-002),\nvec3(-6.0483580e-002,1.5567975e-001,4.3343800e-003),\nvec3(-8.6389150e-002,1.2168475e-001,4.8412440e-002),\nvec3(-7.4084360e-002,1.4987744e-001,-3.2610050e-002),\nvec3(-2.0580600e-002,7.9572500e-002,5.6013880e-002),\nvec3(-8.3837500e-002,1.3927865e-001,4.4893850e-002),\nvec3(-2.2933960e-002,3.5632910e-002,5.2865490e-002),\nvec3(-8.6153620e-002,1.2735612e-001,4.8563960e-002),\nvec3(-6.5728590e-002,1.0709818e-001,-1.4317670e-002),\nvec3(-2.1481090e-002,7.4194460e-002,5.2857680e-002),\nvec3(-7.6423900e-002,1.5736285e-001,-9.0354600e-003),\nvec3(-7.7216010e-002,8.5594880e-002,3.7420770e-002),\nvec3(-8.4150830e-002,1.2955013e-001,5.0483700e-002),\nvec3(-8.1221440e-002,8.1003250e-002,3.1255840e-002),\nvec3(-8.1704000e-002,1.0167226e-001,3.0939660e-002),\nvec3(-8.6252730e-002,1.0106846e-001,2.5413770e-002),\nvec3(-8.0944970e-002,1.3903572e-001,4.7359080e-002),\nvec3(-7.8908350e-002,9.4830900e-002,3.5435500e-002),\nvec3(-7.3440160e-002,9.5412600e-002,4.0210650e-002),\nvec3(-5.2675780e-002,8.8220740e-002,-2.1886300e-002),\nvec3(-7.6440670e-002,7.7511060e-002,3.3748300e-002),\nvec3(-2.1791140e-002,1.0658035e-001,-2.2327000e-002),\nvec3(-8.8360940e-002,1.4996706e-001,2.6044170e-002),\nvec3(-2.4078870e-002,6.7906700e-002,4.5178370e-002),\nvec3(-2.0018090e-002,6.7569300e-002,5.1565340e-002),\nvec3(-8.3577750e-002,1.2052625e-001,4.9177500e-002),\nvec3(-1.4655950e-002,1.7456543e-001,-2.5972690e-002),\nvec3(-2.7395940e-002,8.4108300e-002,4.8745680e-002),\nvec3(-4.1933580e-002,8.8463400e-002,-2.2126350e-002),\nvec3(-3.1693900e-002,1.0261265e-001,-2.2352310e-002),\nvec3(-2.7890200e-002,1.0440703e-001,-2.2830920e-002),\nvec3(-7.3790400e-002,1.2016662e-001,-7.8851200e-003),\nvec3(-4.6124160e-002,1.0506369e-001,-2.0457580e-002),\nvec3(-2.7412650e-002,7.3269450e-002,4.2641380e-002),\nvec3(-4.5532880e-002,3.4736480e-002,-2.1363200e-002),\nvec3(-4.4993030e-002,3.9017010e-002,-2.1097830e-002),\nvec3(-4.6462610e-002,3.6800270e-002,-1.7778710e-002),\nvec3(-8.8366460e-002,1.1361863e-001,5.8227800e-003),\nvec3(5.1746240e-002,7.2897250e-002,9.0647400e-003),\nvec3(-7.0385250e-002,3.7450300e-002,-9.3190000e-004),\nvec3(-6.0923170e-002,3.8621820e-002,2.2468850e-002),\nvec3(-7.7696720e-002,1.7027889e-001,-4.3117910e-002),\nvec3(-4.3793210e-002,1.6955506e-001,-7.3026400e-003),\nvec3(-7.7587180e-002,1.7717875e-001,-5.0221090e-002),\nvec3(-4.0541880e-002,3.8886010e-002,-2.7364950e-002),\nvec3(-4.4215850e-002,3.6131460e-002,-2.4252210e-002),\nvec3(-6.6634880e-002,4.0430310e-002,-5.0180700e-003),\nvec3(-6.9242120e-002,4.1474050e-002,1.9289000e-004),\nvec3(-7.5640690e-002,1.5930400e-001,-2.6908460e-002),\nvec3(-6.3087030e-002,3.9614170e-002,2.5181560e-002),\nvec3(-7.2303020e-002,1.5186699e-001,-4.1544310e-002),\nvec3(-4.1051490e-002,4.1528620e-002,-2.4061000e-002),\nvec3(-4.6990580e-002,3.8892380e-002,-1.4016920e-002),\nvec3(-8.9559690e-002,1.2851666e-001,4.5457500e-003),\nvec3(-7.6987340e-002,1.5369375e-001,-2.2970800e-003),\nvec3(-7.0121670e-002,1.6882633e-001,-5.1173650e-002),\nvec3(-6.4792610e-002,4.1724530e-002,3.1616900e-002),\nvec3(-4.2148060e-002,1.2409627e-001,-9.5602500e-003),\nvec3(-4.8069700e-002,1.2493027e-001,-8.4076400e-003),\nvec3(-4.2150480e-002,4.3343970e-002,-2.1508710e-002),\nvec3(-6.7315160e-002,4.4034000e-002,1.5741800e-003),\nvec3(-7.3386640e-002,1.5463418e-001,-2.9943830e-002),\nvec3(-5.5352770e-002,4.2936210e-002,1.9135490e-002),\nvec3(-6.0067770e-002,4.1419500e-002,2.2953280e-002),\nvec3(-6.5488460e-002,4.0937780e-002,3.5315470e-002),\nvec3(-8.0066400e-002,1.5039650e-001,6.0518000e-004),\nvec3(-4.4031300e-002,4.1949070e-002,-1.7993960e-002),\nvec3(-4.5186510e-002,4.2453420e-002,-1.4193620e-002),\nvec3(-8.3109430e-002,1.0265445e-001,-3.2933400e-003),\nvec3(-6.5472800e-002,4.5627570e-002,4.5575400e-003),\nvec3(-7.5427730e-002,1.5201213e-001,-1.4393690e-002),\nvec3(-5.4473420e-002,4.5937510e-002,2.3612600e-002),\nvec3(-6.2464100e-002,4.3722000e-002,2.8493310e-002),\nvec3(-6.2832600e-002,4.5182750e-002,3.4622890e-002),\nvec3(-6.3538130e-002,4.3524020e-002,3.7974010e-002),\nvec3(-6.0255260e-002,4.4749620e-002,-4.1316200e-003),\nvec3(-6.3242050e-002,4.5549700e-002,4.8428000e-004),\nvec3(-6.2249430e-002,4.6540050e-002,7.1903500e-003),\nvec3(-9.1003650e-002,1.4885725e-001,2.1507030e-002),\nvec3(-5.7094130e-002,4.5996540e-002,2.6865280e-002),\nvec3(-5.7276490e-002,4.7299580e-002,2.9889950e-002),\nvec3(-3.9519900e-002,1.7385855e-001,-7.5752600e-003),\nvec3(-8.9641110e-002,1.3841920e-001,3.4141800e-002),\nvec3(-9.2601430e-002,1.3018652e-001,2.5183580e-002),\nvec3(-9.2280860e-002,1.2762053e-001,2.9751670e-002),\nvec3(-3.3957310e-002,4.1025060e-002,-2.9660250e-002),\nvec3(-9.0199540e-002,1.1657506e-001,5.6754900e-003),\nvec3(-5.8515890e-002,4.7731310e-002,2.1246000e-004),\nvec3(-7.1723560e-002,1.4617438e-001,-2.1567820e-002),\nvec3(-5.2389820e-002,4.5449130e-002,1.7686300e-002),\nvec3(-5.9414350e-002,4.7277990e-002,3.4172420e-002),\nvec3(-5.7520620e-002,1.5877600e-001,4.1621200e-003),\nvec3(-8.0959140e-002,1.0926674e-001,-2.0189900e-003),\nvec3(-5.1904000e-002,4.6100060e-002,1.9421290e-002),\nvec3(-5.1830050e-002,4.8568730e-002,2.1647030e-002),\nvec3(-7.7650400e-002,1.5658012e-001,-1.6599150e-002),\nvec3(-3.7416450e-002,4.7682130e-002,-1.7147280e-002),\nvec3(-7.8876110e-002,1.5347012e-001,3.9875800e-003),\nvec3(-5.7635420e-002,5.0425540e-002,4.6108400e-003),\nvec3(-5.2625440e-002,5.0434620e-002,2.9046740e-002),\nvec3(-5.2998720e-002,4.9169020e-002,3.3967600e-002),\nvec3(-7.3502600e-002,1.6871934e-001,-4.4791800e-002),\nvec3(-5.4420720e-002,4.7836520e-002,-5.9186900e-003),\nvec3(-5.2312740e-002,5.1085350e-002,2.4485690e-002),\nvec3(-7.9129930e-002,1.6736568e-001,-3.5506230e-002),\nvec3(9.4115700e-003,1.2350285e-001,-9.8291000e-003),\nvec3(-3.2715700e-002,1.0896631e-001,-1.8941410e-002),\nvec3(-3.1133380e-002,4.9607260e-002,-1.9406940e-002),\nvec3(4.5997330e-002,6.9814450e-002,3.0143300e-003),\nvec3(3.3525460e-002,1.0966209e-001,-6.9894800e-003),\nvec3(-5.5047160e-002,5.2767560e-002,-3.9461300e-003),\nvec3(-5.6897890e-002,4.9655570e-002,-1.5319000e-003),\nvec3(-5.0290500e-002,4.9098930e-002,1.7164780e-002),\nvec3(-5.0595170e-002,4.9923270e-002,1.9174130e-002),\nvec3(-5.1887420e-002,5.3324670e-002,2.8705560e-002),\nvec3(-6.7684480e-002,1.6533627e-001,-5.5466400e-002),\nvec3(-3.0271440e-002,5.2106080e-002,-1.7676140e-002),\nvec3(-9.1087300e-003,1.1141669e-001,-2.0543230e-002),\nvec3(-5.7069360e-002,5.4424380e-002,2.3395500e-003),\nvec3(-3.2748380e-002,1.7759875e-001,-1.1627470e-002),\nvec3(-2.9009580e-002,5.1265290e-002,-2.2175780e-002),\nvec3(-3.1383130e-002,5.1791310e-002,-1.3886800e-002),\nvec3(-5.5673960e-002,5.6983850e-002,-3.3510400e-003),\nvec3(-5.0916050e-002,5.3813610e-002,1.9753140e-002),\nvec3(-8.8875380e-002,1.5169443e-001,2.0086580e-002),\nvec3(-7.7153050e-002,1.7378676e-001,-4.7867620e-002),\nvec3(-7.8577770e-002,1.6420639e-001,-3.1825860e-002),\nvec3(-2.7545910e-002,5.4021570e-002,-2.5147390e-002),\nvec3(-5.4463660e-002,5.5357450e-002,1.0326840e-002),\nvec3(-8.7041410e-002,1.3058932e-001,9.1161000e-004),\nvec3(-9.0009340e-002,1.3278082e-001,5.9220600e-003),\nvec3(-9.2232620e-002,1.3195400e-001,1.5430650e-002),\nvec3(-4.8639980e-002,1.6472475e-001,-5.0591500e-003),\nvec3(-5.4066480e-002,5.9959350e-002,-7.5992200e-003),\nvec3(-5.7434090e-002,5.7683500e-002,8.7259700e-003),\nvec3(-8.6794730e-002,1.3850688e-001,4.5575900e-003),\nvec3(-9.2989530e-002,1.3092307e-001,1.9919290e-002),\nvec3(-9.1282030e-002,1.3311897e-001,2.4688630e-002),\nvec3(2.1815020e-002,1.1770533e-001,-1.0015300e-002),\nvec3(-2.9647120e-002,5.8104260e-002,-2.1311320e-002),\nvec3(-3.1289530e-002,5.5208570e-002,-1.4387840e-002),\nvec3(-5.9002160e-002,5.9234620e-002,2.6140800e-003),\nvec3(-9.0241700e-002,1.3575994e-001,1.4149160e-002),\nvec3(-6.1569420e-002,1.7084875e-001,-6.1679170e-002),\nvec3(-6.6070180e-002,1.6557822e-001,-5.8644080e-002),\nvec3(-2.4539930e-002,1.8005865e-001,-1.8726950e-002),\nvec3(-1.6131750e-002,1.8298848e-001,-2.6037190e-002),\nvec3(-3.0809390e-002,5.6998040e-002,-1.7835020e-002),\nvec3(1.0464280e-002,9.6180450e-002,-2.5898970e-002),\nvec3(-5.7491630e-002,5.9530160e-002,-1.0786100e-003),\nvec3(-8.9146460e-002,1.3650500e-001,2.5952780e-002),\nvec3(4.3714500e-003,1.0391901e-001,-2.1515100e-002),\nvec3(-9.0377040e-002,1.3252490e-001,3.1082650e-002),\nvec3(-9.0795450e-002,1.3855232e-001,2.0562560e-002),\nvec3(-9.4237710e-002,1.2615419e-001,2.2201450e-002),\nvec3(-9.0336910e-002,1.3119830e-001,3.8138790e-002),\nvec3(-4.5082610e-002,1.2218447e-001,-1.1569430e-002),\nvec3(1.1348010e-002,9.8243750e-002,-2.3024250e-002),\nvec3(-3.9227920e-002,9.9184630e-002,-2.1912720e-002),\nvec3(-6.5509530e-002,1.5857325e-001,-5.5600270e-002),\nvec3(-7.7409510e-002,1.6260515e-001,-2.0754580e-002),\nvec3(-4.8580010e-002,1.6689211e-001,-2.5256100e-003),\nvec3(-7.6922910e-002,1.5351394e-001,-9.0785600e-003),\nvec3(-6.7750580e-002,1.5734825e-001,-5.3982110e-002),\nvec3(5.2906410e-002,6.5230450e-002,-5.1112000e-004),\nvec3(-2.9054820e-002,6.1084120e-002,-2.4918230e-002),\nvec3(-3.1066920e-002,6.5058860e-002,-2.2751080e-002),\nvec3(2.4249720e-002,1.0266151e-001,-1.8313830e-002),\nvec3(-5.5473660e-002,1.6050213e-001,1.3763500e-003),\nvec3(-6.6642850e-002,1.6040875e-001,-5.6842680e-002),\nvec3(-7.8200320e-002,1.6073213e-001,-2.3999690e-002),\nvec3(-1.8320680e-002,1.1968625e-001,-1.1110660e-002),\nvec3(2.1712970e-002,1.0956342e-001,-1.5081090e-002),\nvec3(-6.8382640e-002,1.5980248e-001,-5.4208800e-002),\nvec3(-2.5445620e-002,6.0208550e-002,-3.0864700e-002),\nvec3(-2.6540330e-002,6.5084000e-002,-3.1664870e-002),\nvec3(-2.8425710e-002,6.2199610e-002,-2.7938500e-002),\nvec3(-3.2605750e-002,6.1264600e-002,-1.5453010e-002),\nvec3(-7.0872290e-002,1.1611638e-001,-7.9563700e-003),\nvec3(-6.9780530e-002,1.5938570e-001,-4.9418240e-002),\nvec3(-3.0324870e-002,6.7694720e-002,-2.7654950e-002),\nvec3(-3.2977370e-002,6.6365180e-002,-1.8385530e-002),\nvec3(1.3533490e-002,1.0255388e-001,-2.1579310e-002),\nvec3(4.4408530e-002,6.9758860e-002,9.4765000e-004),\nvec3(-2.1999000e-003,1.1215881e-001,-1.9658660e-002),\nvec3(-7.2028500e-002,6.7046610e-002,-7.2256000e-004),\nvec3(-7.8699630e-002,1.7313910e-001,-4.2720470e-002),\nvec3(-8.3211970e-002,1.5072131e-001,4.2128500e-003),\nvec3(-8.7439060e-002,1.3374875e-001,2.3974700e-003),\nvec3(2.6348020e-002,8.4562230e-002,-2.3151710e-002),\nvec3(-7.4901490e-002,7.0419350e-002,-2.2854300e-003),\nvec3(-5.4576350e-002,9.1562950e-002,-2.2098700e-002),\nvec3(-7.3242520e-002,1.5231332e-001,-3.5703520e-002),\nvec3(-7.4550960e-002,1.7218738e-001,-4.7551010e-002),\nvec3(-2.8680680e-002,6.8283500e-002,-3.0610160e-002),\nvec3(1.7372900e-002,1.0246037e-001,-2.1487700e-002),\nvec3(-8.1257430e-002,7.3025200e-002,7.1020400e-003),\nvec3(-7.4982300e-002,1.5407794e-001,-1.8974470e-002),\nvec3(-9.1556500e-002,1.3196262e-001,1.0638150e-002),\nvec3(-8.2448000e-004,9.5165120e-002,-3.2056320e-002),\nvec3(-7.7618830e-002,7.3999130e-002,-5.3263500e-003),\nvec3(-7.9858790e-002,7.2755040e-002,3.0420200e-003),\nvec3(-8.1627470e-002,7.3470610e-002,1.1161690e-002),\nvec3(-7.3679290e-002,1.4785987e-001,-2.0236290e-002),\nvec3(-9.1309820e-002,1.4848588e-001,1.6270070e-002),\nvec3(-9.0850140e-002,1.4625613e-001,1.4809050e-002),\nvec3(-6.8543890e-002,1.7513008e-001,-5.7187900e-002),\nvec3(-2.7253960e-002,1.0747453e-001,-2.1279680e-002),\nvec3(2.1443580e-002,1.2273826e-001,-2.9316700e-003),\nvec3(-7.9061200e-002,7.3724300e-002,-8.4521000e-004),\nvec3(-8.2063500e-002,7.5993670e-002,1.7615500e-003),\nvec3(-8.3736580e-002,7.6771840e-002,8.9586000e-003),\nvec3(-9.0205720e-002,1.4947775e-001,1.3035090e-002),\nvec3(8.4818000e-004,1.1670025e-001,-1.7337090e-002),\nvec3(-7.4577550e-002,1.5164041e-001,-2.8647990e-002),\nvec3(-2.9087460e-002,7.2924630e-002,-3.3354470e-002),\nvec3(-3.1184020e-002,7.3989530e-002,-3.0339870e-002),\nvec3(-3.2606620e-002,7.1955620e-002,-2.4866580e-002),\nvec3(-8.0575990e-002,7.6607800e-002,-2.9879400e-003),\nvec3(-8.9491020e-002,1.4392581e-001,1.2488490e-002),\nvec3(-7.7388410e-002,1.4656426e-001,-4.3543000e-003),\nvec3(-7.2896160e-002,1.5834962e-001,-3.4109420e-002),\nvec3(7.1346500e-003,1.1468229e-001,-1.8345640e-002),\nvec3(-3.4502610e-002,7.6130020e-002,-2.2373150e-002),\nvec3(-8.3890740e-002,8.0789530e-002,2.2951400e-003),\nvec3(-8.3740480e-002,7.7240270e-002,4.6673300e-003),\nvec3(-8.6204620e-002,8.0930750e-002,1.0535420e-002),\nvec3(-8.6061500e-002,7.9931100e-002,1.4440780e-002),\nvec3(-8.1542760e-002,7.7950660e-002,2.6727280e-002),\nvec3(2.6666170e-002,1.1268609e-001,-1.0509540e-002),\nvec3(-7.6041430e-002,1.5663068e-001,-2.1420480e-002),\nvec3(-9.0012110e-002,1.5083344e-001,1.5752740e-002),\nvec3(-7.1156510e-002,1.6335125e-001,-4.5360530e-002),\nvec3(-3.3210960e-002,7.6873190e-002,-2.7708380e-002),\nvec3(-7.3263090e-002,7.9983830e-002,-1.3749940e-002),\nvec3(-7.9285950e-002,8.0048830e-002,-7.0125500e-003),\nvec3(-8.6034510e-002,8.2645720e-002,1.9542680e-002),\nvec3(-8.4335410e-002,8.0729950e-002,2.2180460e-002),\nvec3(-7.1351460e-002,1.5727092e-001,-4.2183090e-002),\nvec3(-7.3548450e-002,1.6120822e-001,-3.5288420e-002),\nvec3(1.6732620e-002,1.0991230e-001,-1.7020040e-002),\nvec3(-3.0978770e-002,7.7020860e-002,-3.2816490e-002),\nvec3(-6.2359240e-002,1.7544824e-001,-6.1485990e-002),\nvec3(-1.7587870e-002,1.1491318e-001,-1.7205040e-002),\nvec3(-8.2354050e-002,8.0876320e-002,-2.4038900e-003),\nvec3(-7.8578910e-002,1.4050129e-001,-4.6031000e-003),\nvec3(-2.8931080e-002,7.9247620e-002,-3.5049800e-002),\nvec3(-3.1225710e-002,8.0413100e-002,-3.2182320e-002),\nvec3(-3.3258680e-002,7.9621670e-002,-2.7146060e-002),\nvec3(-4.4697400e-002,1.1791537e-001,-1.4725860e-002),\nvec3(-7.9723740e-002,8.4226660e-002,-8.7608600e-003),\nvec3(-8.5042160e-002,8.3817830e-002,-7.7640000e-005),\nvec3(-8.6776400e-002,8.4344860e-002,1.2419030e-002),\nvec3(-8.6674670e-002,8.2665010e-002,1.5174340e-002),\nvec3(-8.5106250e-002,8.5176580e-002,2.5679440e-002),\nvec3(-7.6975760e-002,8.2935940e-002,-1.1450630e-002),\nvec3(-8.2776390e-002,8.3430890e-002,-4.3687000e-003),\nvec3(-8.6180440e-002,8.2572150e-002,6.3639000e-003),\nvec3(-9.1160820e-002,1.4144362e-001,1.5673910e-002),\nvec3(-7.4638800e-002,1.4398484e-001,-7.1504600e-003),\nvec3(-8.3448500e-002,1.3393299e-001,-1.6873200e-003),\nvec3(-7.5804700e-002,1.5134475e-001,-1.9881200e-002),\nvec3(-7.4924140e-002,1.5273013e-001,-1.9397440e-002),\nvec3(-5.2314440e-002,1.2159646e-001,-1.0798060e-002),\nvec3(-3.0734050e-002,8.5427560e-002,-3.0506670e-002),\nvec3(-3.2590560e-002,8.1942660e-002,-2.9100210e-002),\nvec3(-8.6454830e-002,8.6940490e-002,9.1667000e-004),\nvec3(-1.2501820e-002,1.0634409e-001,-2.2360190e-002),\nvec3(-8.8585880e-002,1.4605869e-001,9.8780000e-003),\nvec3(-8.5609750e-002,1.4712513e-001,6.5981100e-003),\nvec3(-8.7511210e-002,1.5061504e-001,1.0152460e-002),\nvec3(-6.0113540e-002,3.5550440e-002,4.4907580e-002),\nvec3(-8.8284200e-002,8.6869110e-002,8.1029200e-003),\nvec3(-8.8812560e-002,8.7765490e-002,1.4226540e-002),\nvec3(-8.8001070e-002,8.6626430e-002,1.5466680e-002),\nvec3(-8.6991110e-002,8.6444700e-002,2.2420950e-002),\nvec3(-7.4609990e-002,1.4727815e-001,-1.4172380e-002),\nvec3(-3.4707910e-002,8.4035880e-002,-2.4302260e-002),\nvec3(-8.4964900e-002,8.9962540e-002,-3.0068000e-003),\nvec3(-8.8091450e-002,8.7741580e-002,4.8489900e-003),\nvec3(-9.1490470e-002,1.4543178e-001,2.2277220e-002),\nvec3(-9.4380420e-002,1.2183919e-001,1.7904340e-002),\nvec3(-2.9164530e-002,8.5393440e-002,-3.3666780e-002),\nvec3(-3.0557790e-002,8.8625920e-002,-2.7550670e-002),\nvec3(-7.7770550e-002,8.7844840e-002,-1.1694810e-002),\nvec3(-8.0728260e-002,8.8204150e-002,-7.8003100e-003),\nvec3(-8.3272540e-002,8.9476690e-002,-5.6502900e-003),\nvec3(-8.9398710e-002,8.9539000e-002,1.1645550e-002),\nvec3(-8.9698390e-002,1.3971257e-001,1.3774760e-002),\nvec3(-7.7134890e-002,1.5151225e-001,-5.5823000e-003),\nvec3(-5.1121410e-002,1.6374125e-001,-2.6640500e-003),\nvec3(-8.6442960e-002,1.2767438e-001,-1.4864100e-003),\nvec3(-6.9605590e-002,1.5490763e-001,-5.0188670e-002),\nvec3(-8.7265180e-002,9.2110030e-002,4.2059000e-003),\nvec3(-8.9086250e-002,9.2377120e-002,1.0569860e-002),\nvec3(-8.9612340e-002,9.1599880e-002,1.7812280e-002),\nvec3(-8.2732460e-002,1.4196856e-001,1.2529100e-003),\nvec3(-7.2618370e-002,1.4368135e-001,-1.0987100e-002),\nvec3(-7.7677230e-002,1.6610992e-001,-3.6777320e-002),\nvec3(-1.5078060e-002,9.3863440e-002,-3.4317310e-002),\nvec3(-7.1057280e-002,1.5476885e-001,-4.5778530e-002),\nvec3(-9.2331920e-002,1.2523886e-001,9.1589500e-003),\nvec3(-7.6046700e-002,9.1037250e-002,-1.3643150e-002),\nvec3(-8.2942810e-002,9.3291700e-002,-6.1856300e-003),\nvec3(-1.0411170e-002,9.4592340e-002,-3.3784850e-002),\nvec3(-2.9331140e-002,1.1476230e-001,-1.5844640e-002),\nvec3(-3.7218250e-002,1.1594244e-001,-1.5173050e-002),\nvec3(-1.2429920e-002,1.0286006e-001,-2.3822480e-002),\nvec3(6.6509600e-003,8.8144500e-002,-3.2945810e-002),\nvec3(-6.4119900e-003,9.2876210e-002,-3.4817640e-002),\nvec3(1.5800150e-002,1.1996558e-001,-1.1415630e-002),\nvec3(2.9102740e-002,1.0247506e-001,-1.5768380e-002),\nvec3(4.2080690e-002,6.3480630e-002,-2.5405300e-003),\nvec3(2.8723120e-002,9.7943220e-002,-1.7497350e-002),\nvec3(-1.9987640e-002,1.0278313e-001,-2.3392920e-002),\nvec3(3.3748350e-002,8.3644140e-002,-1.8630450e-002),\nvec3(-1.8685680e-002,1.8689625e-001,-2.0248700e-002),\nvec3(6.4154900e-003,1.1790181e-001,-1.6282740e-002),\nvec3(5.6305210e-002,6.7769910e-002,2.6525000e-003),\nvec3(-5.3608300e-003,1.1289400e-001,-1.9613290e-002),\nvec3(4.5769430e-002,6.4628800e-002,-1.2166100e-003),\nvec3(-1.0090870e-002,9.8229650e-002,-2.7731360e-002),\nvec3(-6.0458520e-002,1.1755645e-001,-1.1354580e-002),\nvec3(1.2933940e-002,1.1887250e-001,-1.3979370e-002),\nvec3(1.5235680e-002,9.4977900e-002,-2.4437140e-002),\nvec3(-3.0892950e-002,4.7409030e-002,-2.4954000e-002),\nvec3(-1.7766190e-002,1.8572344e-001,-2.3049280e-002),\nvec3(-1.3034890e-002,1.1002855e-001,-2.0161170e-002),\nvec3(-7.1206550e-002,3.8608570e-002,7.7218000e-004),\nvec3(1.7904800e-002,1.0627709e-001,-1.7729250e-002),\nvec3(-3.3623490e-002,1.1840428e-001,-1.1927480e-002),\nvec3(-4.9906840e-002,1.1788332e-001,-1.4402480e-002),\nvec3(-6.6878100e-003,1.1747209e-001,-1.5359280e-002),\nvec3(-1.5451470e-002,1.8597600e-001,-2.4795870e-002),\nvec3(-3.0603900e-002,3.8038460e-002,-3.0123840e-002),\nvec3(-1.3220270e-002,1.8397188e-001,-2.7519460e-002),\nvec3(-4.7859450e-002,1.1162729e-001,-1.7482120e-002),\nvec3(-1.3098990e-002,9.0776040e-002,-3.6659270e-002),\nvec3(-6.3117340e-002,1.5425437e-001,2.9730400e-003),\nvec3(-5.5139750e-002,1.1051601e-001,-1.7672740e-002),\nvec3(-1.1096770e-002,1.8202324e-001,-2.8042450e-002),\nvec3(-2.6568900e-002,3.4695830e-002,-2.9113750e-002),\nvec3(-6.6396600e-003,1.0222209e-001,-2.3519320e-002),\nvec3(-5.6996400e-002,1.5741713e-001,6.0244000e-004),\nvec3(1.9076550e-002,9.1870620e-002,-2.4890230e-002),\nvec3(1.3473090e-002,1.2429893e-001,-6.8361400e-003),\nvec3(-2.1730490e-002,9.8410960e-002,-2.4306850e-002),\nvec3(-1.7142170e-002,9.8057460e-002,-2.4924330e-002),\nvec3(-5.8698110e-002,1.5137318e-001,-6.5801000e-004),\nvec3(3.5641100e-003,1.2764883e-001,-4.4672400e-003),\nvec3(-8.5369800e-003,9.9921220e-002,-2.4351070e-002),\nvec3(-1.2171980e-002,1.8125102e-001,-2.9061170e-002),\nvec3(-6.1113980e-002,1.5305212e-001,9.9983000e-004),\nvec3(-2.9570620e-002,1.1713871e-001,-1.3675530e-002),\nvec3(3.0530110e-002,1.1221207e-001,-8.1860600e-003),\nvec3(-3.1714100e-002,3.5111530e-002,-3.0658990e-002),\nvec3(-1.3691130e-002,1.7914707e-001,-2.8126410e-002),\nvec3(1.1620840e-002,1.1548972e-001,-1.6385680e-002),\nvec3(-6.1993570e-002,1.5028063e-001,-1.6297100e-003),\nvec3(3.6684020e-002,1.0099570e-001,-9.8485900e-003),\nvec3(4.8512670e-002,7.1798180e-002,6.0005000e-003),\nvec3(-4.6583000e-004,1.1983662e-001,-1.3610580e-002),\nvec3(1.6747170e-002,9.0113950e-002,-2.7127190e-002),\nvec3(6.9832400e-003,9.7730080e-002,-2.4800310e-002),\nvec3(-4.3226830e-002,4.6263570e-002,-1.1771730e-002),\nvec3(-8.3562500e-003,1.1373600e-001,-1.8239810e-002),\nvec3(-1.2354410e-002,1.1556773e-001,-1.6486930e-002),\nvec3(4.6834470e-002,7.4354100e-002,1.0139500e-002),\nvec3(2.5319170e-002,1.0931725e-001,-1.3579660e-002),\nvec3(-4.2459500e-002,1.1392482e-001,-1.6188050e-002),\nvec3(5.7744640e-002,6.4158440e-002,2.6277600e-003),\nvec3(-5.9710530e-002,3.6535780e-002,-9.4949000e-003),\nvec3(-3.2078400e-003,1.0962100e-001,-2.1523850e-002),\nvec3(2.7020740e-002,6.1345700e-002,-2.2292060e-002),\nvec3(7.1030200e-003,1.0191162e-001,-2.1230990e-002),\nvec3(-3.8225680e-002,1.2465525e-001,-7.3257400e-003),\nvec3(2.5941540e-002,1.1576352e-001,-8.2193900e-003),\nvec3(-6.1297960e-002,3.3900220e-002,-9.3216600e-003),\nvec3(-5.9466670e-002,1.4743956e-001,-1.8885400e-003),\nvec3(1.0506610e-002,1.0087700e-001,-2.2109510e-002),\nvec3(3.3081340e-002,1.0273382e-001,-1.2787210e-002),\nvec3(1.2517840e-002,1.0475378e-001,-1.9915960e-002),\nvec3(2.3087990e-002,9.3998720e-002,-2.2210680e-002),\nvec3(3.1555430e-002,9.2484730e-002,-1.8204280e-002),\nvec3(6.2723100e-003,9.9910370e-002,-2.2296890e-002),\nvec3(-4.0917240e-002,4.6121780e-002,-1.7942580e-002),\nvec3(3.5407360e-002,9.8188850e-002,-1.2008970e-002),\nvec3(9.4135900e-003,1.2121902e-001,-1.2937780e-002),\nvec3(5.3735190e-002,7.2027350e-002,6.8010000e-003),\nvec3(2.5620340e-002,1.1880719e-001,-5.0330800e-003),\nvec3(-3.8150260e-002,4.2466610e-002,-2.6893990e-002),\nvec3(-2.8212410e-002,1.1116862e-001,-1.8001930e-002),\nvec3(-6.0253590e-002,1.4339100e-001,-3.7906300e-003),\nvec3(1.9016880e-002,1.0401450e-001,-1.9333120e-002),\nvec3(7.5446700e-003,9.1682150e-002,-3.1643140e-002),\nvec3(-7.0760800e-003,1.2240119e-001,-1.1364410e-002),\nvec3(-1.9047500e-002,9.6562130e-002,-2.7579900e-002),\nvec3(-1.6953390e-002,1.0669256e-001,-2.2002990e-002),\nvec3(-6.7307000e-004,1.0119875e-001,-2.2857770e-002),\nvec3(-9.0179300e-003,1.2528031e-001,-7.7912000e-003),\nvec3(-6.8136180e-002,1.8006113e-001,-5.8816050e-002),\nvec3(-2.3600190e-002,1.1513818e-001,-1.5577390e-002),\nvec3(-5.9831220e-002,4.2842260e-002,-6.6469100e-003),\nvec3(5.3124070e-002,5.9012380e-002,-2.8853800e-003),\nvec3(-3.6931840e-002,3.7107370e-002,-2.9714170e-002),\nvec3(-5.6215140e-002,1.4139213e-001,-2.8027300e-003),\nvec3(3.6695880e-002,1.0372844e-001,-7.9621500e-003),\nvec3(-3.5885070e-002,1.2040038e-001,-1.0640470e-002),\nvec3(-9.3569500e-003,8.5423730e-002,-3.8112540e-002),\nvec3(-6.0127340e-002,1.2041391e-001,-9.3791100e-003),\nvec3(-3.9842790e-002,1.2156113e-001,-1.1570310e-002),\nvec3(2.8322200e-002,1.0847957e-001,-1.2623390e-002),\nvec3(-1.8733500e-003,1.1593910e-001,-1.7169430e-002),\nvec3(3.8648150e-002,9.0153340e-002,-1.2549680e-002),\nvec3(-1.7359200e-003,9.2244170e-002,-3.4310460e-002),\nvec3(5.0000820e-002,6.1612070e-002,-3.4649900e-003),\nvec3(5.5858960e-002,6.2910170e-002,6.9037000e-004),\nvec3(2.0461520e-002,1.1515372e-001,-1.3103780e-002),\nvec3(-1.5165840e-002,1.1798075e-001,-1.4465520e-002),\nvec3(-7.0859540e-002,7.1510150e-002,3.3895100e-002),\nvec3(2.2674030e-002,8.6606050e-002,-2.4925490e-002),\nvec3(3.5358840e-002,8.7438890e-002,-1.7109050e-002),\nvec3(1.8400920e-002,1.2145507e-001,-7.6804200e-003),\nvec3(-2.5425900e-002,4.1421010e-002,-2.9204830e-002),\nvec3(-8.2085100e-003,9.6777440e-002,-3.0809780e-002),\nvec3(-5.6810660e-002,3.3873940e-002,-1.1166310e-002),\nvec3(-3.4588640e-002,4.4744960e-002,-2.7122900e-002),\nvec3(-4.0251680e-002,1.1827531e-001,-1.3674080e-002),\nvec3(1.6387020e-002,1.1402346e-001,-1.5496900e-002),\nvec3(4.2635280e-002,6.0797460e-002,-3.4583700e-003),\nvec3(-5.0687200e-002,3.5935870e-002,-1.2380790e-002),\nvec3(7.3446800e-003,9.4509570e-002,-2.9683220e-002),\nvec3(-1.9706700e-002,9.2917340e-002,-3.4636880e-002),\nvec3(-1.2083040e-002,1.2219229e-001,-9.7120900e-003),\nvec3(4.8805930e-002,6.8457810e-002,1.6952900e-003),\nvec3(-3.0869700e-003,9.8402500e-002,-2.7403170e-002),\nvec3(-5.3198790e-002,1.3672896e-001,-1.6580500e-003),\nvec3(-4.7290060e-002,1.3055355e-001,1.6909100e-003),\nvec3(4.4651700e-003,1.2044039e-001,-1.3931400e-002),\nvec3(-2.3850100e-003,1.2290534e-001,-1.0382460e-002),\nvec3(-2.4833330e-002,9.5858030e-002,-2.5162110e-002),\nvec3(-4.2296900e-002,3.6291920e-002,-2.7253600e-002),\nvec3(-5.4388260e-002,1.3404922e-001,-3.9920400e-003),\nvec3(-5.0539380e-002,1.3336659e-001,-1.0872200e-003),\nvec3(2.6040300e-003,9.6942660e-002,-2.8407060e-002),\nvec3(-7.8163100e-003,1.2821209e-001,-1.9430400e-003),\nvec3(6.5111700e-003,1.3002517e-001,9.2881000e-004),\nvec3(3.4742860e-002,9.2274140e-002,-1.5654590e-002),\nvec3(-6.7787700e-002,1.8088887e-001,-5.8191050e-002),\nvec3(-3.3715410e-002,1.1151566e-001,-1.8078440e-002),\nvec3(4.4630400e-003,1.2427294e-001,-9.4291400e-003),\nvec3(-2.3370170e-002,9.3392760e-002,-3.2031820e-002),\nvec3(-4.8982070e-002,1.2980647e-001,-1.3229400e-003),\nvec3(-7.8164000e-004,1.2822918e-001,-3.2490000e-003),\nvec3(2.4960400e-003,8.9857600e-002,-3.3628450e-002),\nvec3(7.4553300e-003,1.1196790e-001,-1.9554260e-002),\nvec3(2.8791140e-002,9.1157340e-002,-2.0370210e-002),\nvec3(-5.3590150e-002,1.2437450e-001,-7.3470400e-003),\nvec3(-4.7743630e-002,1.2064432e-001,-1.2812990e-002),\nvec3(-1.9616230e-002,1.2109197e-001,-9.5487700e-003),\nvec3(-6.5047370e-002,1.7999148e-001,-5.9758600e-002),\nvec3(-5.1704160e-002,3.7620360e-002,-1.1763450e-002),\nvec3(-5.2124270e-002,1.2929832e-001,-4.1187000e-003),\nvec3(-4.5334450e-002,1.2891494e-001,1.5819100e-003),\nvec3(-3.0471200e-003,1.2919453e-001,-1.0688000e-003),\nvec3(7.2129600e-003,1.2721957e-001,-5.2073700e-003),\nvec3(1.1669320e-002,1.2720154e-001,-3.1850900e-003),\nvec3(5.3056400e-002,6.9708830e-002,3.1291400e-003),\nvec3(-6.3021150e-002,1.7810951e-001,-6.0393570e-002),\nvec3(2.8204800e-002,6.4391270e-002,-2.0698040e-002),\nvec3(3.4400180e-002,1.0503000e-001,-1.0224920e-002),\nvec3(3.0975190e-002,1.0790250e-001,-1.1058430e-002),\nvec3(-4.8984390e-002,1.1480518e-001,-1.5966690e-002),\nvec3(-3.2821710e-002,1.2300500e-001,-5.9088300e-003),\nvec3(-5.0792860e-002,1.2716487e-001,-4.8183200e-003),\nvec3(-3.5301670e-002,1.2547815e-001,-3.1542800e-003),\nvec3(5.6455250e-002,6.9951490e-002,4.9191700e-003),\nvec3(-1.6240450e-002,1.2512177e-001,-3.6499700e-003),\nvec3(-1.6970400e-002,1.1119793e-001,-1.9586410e-002),\nvec3(-5.4088120e-002,3.9781210e-002,-1.0544680e-002),\nvec3(-3.4190490e-002,4.7514010e-002,-2.2301500e-002),\nvec3(1.3699090e-002,9.3914220e-002,-2.6427690e-002),\nvec3(8.8000000e-004,9.9234930e-002,-2.4355670e-002),\nvec3(-4.6459460e-002,1.2723953e-001,-4.8843300e-003),\nvec3(-4.1735500e-002,1.2687599e-001,-4.1742000e-003),\nvec3(-2.1000480e-002,1.2313643e-001,-6.1190100e-003),\nvec3(-1.2130450e-002,1.2572568e-001,-5.2007900e-003),\nvec3(-4.3822400e-003,1.2640753e-001,-6.9495200e-003),\nvec3(1.4085700e-003,3.4781990e-002,-2.3265200e-002),\nvec3(-1.4846200e-002,3.5070930e-002,-2.6071900e-002),\nvec3(-2.1399500e-002,3.4795120e-002,-2.7958820e-002),\nvec3(1.2009220e-002,3.5961900e-002,-2.1735750e-002),\nvec3(3.8249200e-003,3.6129220e-002,-2.3878090e-002),\nvec3(-5.1139560e-002,9.6617580e-002,-2.2095120e-002),\nvec3(-5.4813320e-002,9.8102480e-002,-2.1425370e-002),\nvec3(-2.7597040e-002,1.6979824e-001,-1.8170420e-002),\nvec3(1.3359870e-002,3.9377410e-002,-2.2496330e-002),\nvec3(4.3919300e-003,3.8674430e-002,-2.4170290e-002),\nvec3(-6.8478200e-003,3.6444540e-002,-2.5177120e-002),\nvec3(-1.3280260e-002,3.7699590e-002,-2.6391810e-002),\nvec3(-4.7672760e-002,3.6116650e-002,-1.3301210e-002),\nvec3(-4.5590120e-002,1.0853826e-001,-1.8796680e-002),\nvec3(-5.0095670e-002,1.0990925e-001,-1.8504510e-002),\nvec3(-6.5766640e-002,3.6469550e-002,-7.2073000e-003),\nvec3(-2.3455840e-002,1.6824727e-001,-1.8822880e-002),\nvec3(-4.5918000e-003,3.8404570e-002,-2.5412870e-002),\nvec3(-2.4954130e-002,3.7441060e-002,-2.9152720e-002),\nvec3(2.9007770e-002,3.7358220e-002,-2.7474000e-004),\nvec3(-7.9468800e-003,4.1489920e-002,-2.5911270e-002),\nvec3(-1.6803800e-002,3.9753810e-002,-2.7565350e-002),\nvec3(-6.5156150e-002,1.4034537e-001,-7.6848600e-003),\nvec3(-4.7080100e-002,4.0700690e-002,-1.1869830e-002),\nvec3(-6.8470630e-002,3.7477700e-002,-4.9557400e-003),\nvec3(3.7326850e-002,4.0209510e-002,-8.5850000e-004),\nvec3(3.5349870e-002,4.1257050e-002,-2.8075100e-003),\nvec3(5.1820700e-003,4.1536320e-002,-2.4065670e-002),\nvec3(1.8660660e-002,1.0030784e-001,-2.2127290e-002),\nvec3(-6.0510780e-002,1.0748450e-001,-1.7042300e-002),\nvec3(-6.2374340e-002,4.0146090e-002,-7.4040200e-003),\nvec3(2.5456950e-002,3.9483890e-002,-4.0251400e-003),\nvec3(-2.2828000e-004,4.3394940e-002,-2.5124420e-002),\nvec3(-8.1088400e-003,4.3439060e-002,-2.6140070e-002),\nvec3(-1.7362450e-002,4.3237420e-002,-2.7665190e-002),\nvec3(-2.6416670e-002,4.4674020e-002,-2.8209740e-002),\nvec3(3.8064500e-003,1.0944331e-001,-2.0203790e-002),\nvec3(-5.8232370e-002,9.5690400e-002,-2.0616030e-002),\nvec3(-6.6122370e-002,4.2341260e-002,-2.7538800e-003),\nvec3(-6.0959920e-002,9.4173040e-002,-1.9015670e-002),\nvec3(3.1352250e-002,4.2649280e-002,-4.6745000e-003),\nvec3(-3.3540900e-002,3.6342620e-002,4.9089960e-002),\nvec3(1.7252780e-002,4.4335610e-002,-2.3067190e-002),\nvec3(1.0637660e-002,4.4161560e-002,-2.4926170e-002),\nvec3(4.3843100e-003,4.5806710e-002,-2.6788990e-002),\nvec3(-8.2506400e-003,4.5148720e-002,-2.8441070e-002),\nvec3(-1.5748410e-002,4.5043860e-002,-2.7877790e-002),\nvec3(2.8990330e-002,4.4697850e-002,-6.1863000e-003),\nvec3(8.1686400e-003,4.5053030e-002,-2.5178740e-002),\nvec3(-9.6291000e-004,4.5378230e-002,-2.7308280e-002),\nvec3(-1.7033400e-003,4.7819200e-002,-2.9928930e-002),\nvec3(-3.1535830e-002,4.4740410e-002,-2.8079410e-002),\nvec3(-3.3619650e-002,1.5691468e-001,-1.1024870e-002),\nvec3(-5.0751180e-002,4.3109620e-002,-1.0018680e-002),\nvec3(3.6890890e-002,4.7353200e-002,-6.1057100e-003),\nvec3(2.4975630e-002,4.2644580e-002,-7.0169900e-003),\nvec3(2.4562420e-002,4.8369560e-002,-1.9672760e-002),\nvec3(1.3964040e-002,4.5579170e-002,-2.4706510e-002),\nvec3(1.3376130e-002,4.8630300e-002,-2.6551500e-002),\nvec3(3.7308900e-003,4.8127990e-002,-2.9025970e-002),\nvec3(-8.7947000e-003,4.7056850e-002,-2.9881630e-002),\nvec3(-1.3753770e-002,5.1865060e-002,-3.2243480e-002),\nvec3(-2.1200840e-002,4.6657090e-002,-2.7951320e-002),\nvec3(3.9693540e-002,4.5658580e-002,-4.5274100e-003),\nvec3(3.3627400e-002,4.8717730e-002,-6.3904600e-003),\nvec3(-6.5352120e-002,9.9294570e-002,-1.6820150e-002),\nvec3(1.2868100e-003,5.0383670e-002,-3.0357440e-002),\nvec3(-8.1797500e-003,4.9845800e-002,-3.1071390e-002),\nvec3(-1.7184350e-002,4.8210500e-002,-2.9741930e-002),\nvec3(-2.6049450e-002,4.7692500e-002,-2.6149500e-002),\nvec3(-8.4747010e-002,1.1078350e-001,3.9488380e-002),\nvec3(-5.1316870e-002,4.8270690e-002,-7.9310500e-003),\nvec3(-8.2506510e-002,1.2765487e-001,-4.6796400e-003),\nvec3(3.8663690e-002,5.1696670e-002,-6.6910200e-003),\nvec3(-7.5643160e-002,9.9440450e-002,-1.1927610e-002),\nvec3(2.0284470e-002,5.1349190e-002,-2.4895380e-002),\nvec3(5.9436000e-003,5.0976660e-002,-2.9119360e-002),\nvec3(-2.5528290e-002,5.1472710e-002,-2.6884680e-002),\nvec3(-3.5562670e-002,4.9399890e-002,-1.2865040e-002),\nvec3(-4.2818980e-002,1.6220182e-001,-1.0337510e-002),\nvec3(-6.5593600e-002,1.7665711e-001,-6.0504730e-002),\nvec3(-3.4151080e-002,1.7442797e-001,-1.3312550e-002),\nvec3(4.3673180e-002,5.0162230e-002,-5.9843500e-003),\nvec3(-5.0342410e-002,1.5546197e-001,-5.1927700e-003),\nvec3(2.5464180e-002,5.4029700e-002,-2.1691010e-002),\nvec3(1.0149790e-002,4.9258540e-002,-2.7750590e-002),\nvec3(-2.2043190e-002,5.3612020e-002,-3.0135610e-002),\nvec3(-3.2875520e-002,5.1677630e-002,-1.0888650e-002),\nvec3(-3.7613820e-002,4.9534770e-002,-1.1626140e-002),\nvec3(-4.0750630e-002,4.9285110e-002,-1.1286200e-002),\nvec3(-4.6385170e-002,4.7490850e-002,-1.0085980e-002),\nvec3(4.4473170e-002,5.3293010e-002,-6.3327900e-003),\nvec3(3.3205620e-002,5.1020650e-002,-7.2382500e-003),\nvec3(1.5678350e-002,5.1169270e-002,-2.6397810e-002),\nvec3(6.8341700e-003,5.5010170e-002,-3.0561130e-002),\nvec3(2.1424700e-003,5.5502800e-002,-3.1334400e-002),\nvec3(5.9285000e-004,5.2867950e-002,-3.0513830e-002),\nvec3(-3.6481400e-003,5.1869000e-002,-3.1457940e-002),\nvec3(-9.4245600e-003,5.5399220e-002,-3.3653980e-002),\nvec3(-1.9302150e-002,5.8224770e-002,-3.3919700e-002),\nvec3(-6.1084270e-002,1.3386190e-001,-7.2248900e-003),\nvec3(-4.3309760e-002,5.5656840e-002,-1.1402110e-002),\nvec3(-6.1080540e-002,1.6833773e-001,-5.9192060e-002),\nvec3(4.7574690e-002,5.2943630e-002,-5.1300300e-003),\nvec3(-3.7403030e-002,1.1150775e-001,-1.8243310e-002),\nvec3(1.9972490e-002,5.4409710e-002,-2.7108230e-002),\nvec3(5.3974800e-003,5.8382570e-002,-3.0903760e-002),\nvec3(-1.0603590e-002,5.3602910e-002,-3.3403350e-002),\nvec3(-3.4998290e-002,5.2331560e-002,-1.0347380e-002),\nvec3(-4.6471230e-002,5.1304340e-002,-9.8299800e-003),\nvec3(-6.7945360e-002,1.1493603e-001,-9.5107300e-003),\nvec3(-7.1048210e-002,1.5161088e-001,-4.4679270e-002),\nvec3(-5.8903800e-003,3.4790620e-002,-2.4224470e-002),\nvec3(1.6842140e-002,5.5555670e-002,-2.8284560e-002),\nvec3(1.0711040e-002,5.4687610e-002,-2.9767520e-002),\nvec3(-1.1826800e-003,5.9492420e-002,-3.3360920e-002),\nvec3(-5.2325900e-003,5.5688960e-002,-3.2840220e-002),\nvec3(-5.1705830e-002,5.2470760e-002,-7.4047200e-003),\nvec3(-5.2626360e-002,6.0043760e-002,-8.9566900e-003),\nvec3(-7.2598590e-002,9.7762720e-002,-1.4434510e-002),\nvec3(4.4331260e-002,5.5818010e-002,-6.0362700e-003),\nvec3(3.8463400e-002,5.4934820e-002,-6.1822500e-003),\nvec3(3.8838620e-002,5.7808260e-002,-5.2584800e-003),\nvec3(-9.2015400e-003,5.9510130e-002,-3.4437110e-002),\nvec3(-3.5262560e-002,5.5284900e-002,-1.0545060e-002),\nvec3(-3.8336450e-002,5.4503540e-002,-1.0905320e-002),\nvec3(-1.7727540e-002,3.6289540e-002,5.2222250e-002),\nvec3(5.0006490e-002,5.8095800e-002,-4.6211800e-003),\nvec3(4.6133970e-002,5.9278810e-002,-4.7769600e-003),\nvec3(1.5110300e-002,5.9819840e-002,-2.8645750e-002),\nvec3(1.0312380e-002,5.7586530e-002,-2.9995250e-002),\nvec3(-6.1353400e-003,6.0256790e-002,-3.4695830e-002),\nvec3(-1.2318220e-002,5.9396390e-002,-3.5268510e-002),\nvec3(-1.4466910e-002,6.3136020e-002,-3.6865870e-002),\nvec3(-4.6650260e-002,5.9840950e-002,-1.2135840e-002),\nvec3(-5.6572080e-002,1.2480275e-001,-7.1885700e-003),\nvec3(-7.9237500e-002,1.2055419e-001,-5.6744800e-003),\nvec3(-7.9334790e-002,1.2560650e-001,-6.1175900e-003),\nvec3(2.2340000e-002,5.8492230e-002,-2.6014120e-002),\nvec3(7.6270400e-003,6.2098330e-002,-3.1135840e-002),\nvec3(3.3101700e-003,6.0456840e-002,-3.2481070e-002),\nvec3(-1.6811880e-002,6.1275230e-002,-3.5929330e-002),\nvec3(-3.2491910e-002,5.7196350e-002,-1.2104730e-002),\nvec3(-3.4108240e-002,6.1466560e-002,-1.3053130e-002),\nvec3(-3.3896980e-002,5.7025330e-002,-1.1047570e-002),\nvec3(-3.8623580e-002,5.8303290e-002,-1.1505750e-002),\nvec3(-4.5008400e-002,6.2723940e-002,-1.3390450e-002),\nvec3(-5.6896010e-002,1.3398739e-001,-5.6270700e-003),\nvec3(-4.4853890e-002,1.5746031e-001,-8.6731600e-003),\nvec3(-7.8609550e-002,6.9656870e-002,1.1810740e-002),\nvec3(-2.3730020e-002,1.0186156e-001,-2.3836400e-002),\nvec3(-2.8122930e-002,9.9322390e-002,-2.3580130e-002),\nvec3(-5.0076720e-002,1.4997652e-001,-3.6419700e-003),\nvec3(-3.3048420e-002,9.5958590e-002,-2.3426460e-002),\nvec3(1.9520390e-002,6.2064770e-002,-2.7292470e-002),\nvec3(-3.8864710e-002,1.0333987e-001,-2.0641400e-002),\nvec3(-4.8952940e-002,5.6281090e-002,-1.0220880e-002),\nvec3(-5.3993040e-002,1.4498656e-001,-1.1093400e-003),\nvec3(-4.5530560e-002,9.8510850e-002,-2.1729510e-002),\nvec3(-5.0910960e-002,1.0074570e-001,-2.1619430e-002),\nvec3(2.3245830e-002,6.2792530e-002,-2.5047990e-002),\nvec3(9.7412800e-003,6.3181400e-002,-3.1141370e-002),\nvec3(-8.6614000e-004,6.4559630e-002,-3.4490930e-002),\nvec3(-8.5264000e-003,6.4001730e-002,-3.5850480e-002),\nvec3(-4.8451500e-002,6.4794120e-002,-1.3029910e-002),\nvec3(-5.2325160e-002,1.0614813e-001,-1.9271240e-002),\nvec3(-5.5265350e-002,1.0216682e-001,-1.9897100e-002),\nvec3(-5.9042010e-002,9.9032210e-002,-1.9222950e-002),\nvec3(-5.7846760e-002,1.0433496e-001,-1.8525740e-002),\nvec3(-2.7113460e-002,1.7332156e-001,-1.8538890e-002),\nvec3(2.2832000e-002,6.7082570e-002,-2.6297510e-002),\nvec3(1.4519060e-002,6.4595540e-002,-2.9855690e-002),\nvec3(1.1471330e-002,6.7581440e-002,-3.0901170e-002),\nvec3(-1.7739360e-002,6.6260830e-002,-3.7657310e-002),\nvec3(-6.5059750e-002,1.3452104e-001,-8.0899900e-003),\nvec3(-7.5829320e-002,1.4244605e-001,-5.8090000e-003),\nvec3(-4.1362350e-002,6.1637330e-002,-1.2813770e-002),\nvec3(-5.6147890e-002,6.1921550e-002,-5.7541100e-003),\nvec3(-6.2126110e-002,6.2845360e-002,-4.5202600e-003),\nvec3(-3.7292480e-002,1.6449057e-001,-1.3627050e-002),\nvec3(-1.9818920e-002,1.6509494e-001,-1.7608980e-002),\nvec3(6.2881100e-003,6.5416350e-002,-3.2563040e-002),\nvec3(-5.9250500e-003,6.9515630e-002,-3.5933480e-002),\nvec3(-1.0538630e-002,6.7999180e-002,-3.6517060e-002),\nvec3(-3.5385700e-002,6.6817430e-002,-1.5434860e-002),\nvec3(-5.3994500e-002,6.4638700e-002,-9.3254900e-003),\nvec3(-6.3852310e-002,6.5572310e-002,-6.9393300e-003),\nvec3(-6.3920880e-002,1.2774242e-001,-8.5494600e-003),\nvec3(-2.6940700e-002,3.6184050e-002,5.3351850e-002),\nvec3(1.9618650e-002,6.7007390e-002,-2.8356120e-002),\nvec3(1.2275180e-002,6.9933940e-002,-3.1553160e-002),\nvec3(5.4265100e-003,6.8247960e-002,-3.2730520e-002),\nvec3(-4.4084200e-003,6.6619200e-002,-3.4870250e-002),\nvec3(-2.1911350e-002,6.7144790e-002,-3.6535750e-002),\nvec3(-4.5643150e-002,1.5466949e-001,-7.2969400e-003),\nvec3(-5.1673460e-002,6.6850660e-002,-1.2120350e-002),\nvec3(-5.8105180e-002,6.6465950e-002,-1.0044340e-002),\nvec3(-5.6992260e-002,1.4311862e-001,-2.2403000e-003),\nvec3(-8.0651110e-002,1.3119854e-001,-4.4397800e-003),\nvec3(-5.6544310e-002,1.2850938e-001,-6.2014700e-003),\nvec3(1.7758080e-002,7.0138540e-002,-2.9404680e-002),\nvec3(6.4980500e-003,7.0791870e-002,-3.3525310e-002),\nvec3(7.5831000e-004,7.0434460e-002,-3.4462560e-002),\nvec3(-1.3235950e-002,6.9292820e-002,-3.7917490e-002),\nvec3(-6.7390780e-002,1.1889688e-001,-8.7301400e-003),\nvec3(-3.8119520e-002,6.4162310e-002,-1.3829140e-002),\nvec3(1.8527400e-003,1.1303356e-001,-1.9794270e-002),\nvec3(-7.5950810e-002,6.8170610e-002,1.8117970e-002),\nvec3(-1.0001990e-002,7.2671480e-002,-3.7661370e-002),\nvec3(-1.7976070e-002,7.0613770e-002,-3.8443880e-002),\nvec3(-2.3035990e-002,7.2778460e-002,-3.8072640e-002),\nvec3(-2.6120100e-002,7.1177480e-002,-3.5451530e-002),\nvec3(-6.8535420e-002,1.3929375e-001,-7.8046600e-003),\nvec3(-3.5263040e-002,7.1067650e-002,-1.8011860e-002),\nvec3(-4.1558180e-002,6.9774010e-002,-1.6774100e-002),\nvec3(-5.2831730e-002,7.0298920e-002,-1.4864960e-002),\nvec3(-6.6978850e-002,6.7638980e-002,-6.8094400e-003),\nvec3(-1.0244470e-002,1.7895826e-001,-2.9538870e-002),\nvec3(-7.5272650e-002,1.2680098e-001,-8.0241700e-003),\nvec3(-8.7359900e-002,1.1248315e-001,4.2049490e-002),\nvec3(8.7503000e-003,7.4301560e-002,-3.3398210e-002),\nvec3(-6.4249520e-002,1.6045024e-001,-5.7041470e-002),\nvec3(-4.4354010e-002,7.3372220e-002,-1.7874430e-002),\nvec3(-4.5762580e-002,6.9445320e-002,-1.5928780e-002),\nvec3(-4.7957440e-002,7.2542990e-002,-1.6106990e-002),\nvec3(-5.7822630e-002,6.9538010e-002,-1.4416470e-002),\nvec3(-7.2071600e-002,7.1538150e-002,-7.4714400e-003),\nvec3(2.5472930e-002,7.4094500e-002,-2.4938540e-002),\nvec3(1.5719730e-002,7.3756350e-002,-2.9747770e-002),\nvec3(4.8214000e-003,7.3763980e-002,-3.4552450e-002),\nvec3(-2.2528600e-003,7.3921320e-002,-3.5887190e-002),\nvec3(-7.3834900e-003,7.4799620e-002,-3.7223830e-002),\nvec3(-2.0225340e-002,7.7095190e-002,-3.9044290e-002),\nvec3(-3.4016180e-002,7.2101270e-002,-2.0823150e-002),\nvec3(-3.8493370e-002,7.2839870e-002,-1.7502230e-002),\nvec3(-6.4392550e-002,7.3116330e-002,-1.5335340e-002),\nvec3(-6.4480660e-002,7.0187350e-002,-1.2261750e-002),\nvec3(-2.3854330e-002,1.6164528e-001,-1.4504190e-002),\nvec3(2.2104450e-002,7.2692600e-002,-2.6900140e-002),\nvec3(1.5532370e-002,7.6586960e-002,-2.9606940e-002),\nvec3(1.1574050e-002,7.4860570e-002,-3.1383860e-002),\nvec3(-1.4731560e-002,7.7640750e-002,-3.8490670e-002),\nvec3(-1.6018820e-002,7.4288800e-002,-3.8864420e-002),\nvec3(-5.1103620e-002,7.3071950e-002,-1.6243060e-002),\nvec3(-5.7989540e-002,7.4017880e-002,-1.7522320e-002),\nvec3(-6.9608380e-002,7.2322890e-002,-1.0934430e-002),\nvec3(-7.5996110e-002,1.1714132e-001,-6.5577200e-003),\nvec3(-3.7987660e-002,1.0751453e-001,-1.9975760e-002),\nvec3(1.0696210e-002,7.9889200e-002,-3.2009580e-002),\nvec3(-5.3433400e-003,7.8264580e-002,-3.7476940e-002),\nvec3(-2.6081990e-002,7.6191290e-002,-3.6780200e-002),\nvec3(-3.9161040e-002,1.5718885e-001,-1.0580510e-002),\nvec3(-6.5609880e-002,7.5860010e-002,-1.6750060e-002),\nvec3(-7.0177600e-002,7.5663330e-002,-1.3839210e-002),\nvec3(-7.4291360e-002,7.4808360e-002,-9.3537900e-003),\nvec3(-6.3428890e-002,1.7185387e-001,-6.1412170e-002),\nvec3(3.0684890e-002,7.5726870e-002,-2.0778090e-002),\nvec3(1.9305010e-002,7.9017870e-002,-2.7743990e-002),\nvec3(-8.5992100e-003,7.9338730e-002,-3.7905180e-002),\nvec3(-2.3200110e-002,7.6568500e-002,-3.8386500e-002),\nvec3(-3.8117820e-002,7.6390120e-002,-1.8644360e-002),\nvec3(-4.4231130e-002,7.7664130e-002,-1.9026580e-002),\nvec3(-5.1025500e-002,7.5705070e-002,-1.8186900e-002),\nvec3(-7.0595130e-002,1.2994832e-001,-8.7629200e-003),\nvec3(2.8147660e-002,7.8785370e-002,-2.2432450e-002),\nvec3(7.6016000e-003,7.9435920e-002,-3.3714560e-002),\nvec3(4.9502400e-003,7.8027250e-002,-3.4409750e-002),\nvec3(-1.5858350e-002,8.1165550e-002,-3.9185590e-002),\nvec3(-1.8502080e-002,8.3343870e-002,-3.9010720e-002),\nvec3(-7.9739350e-002,1.3606854e-001,-4.1482100e-003),\nvec3(-3.0980180e-002,1.6634656e-001,-1.6241160e-002),\nvec3(-3.5749800e-002,7.7248350e-002,-1.9374020e-002),\nvec3(-4.8944740e-002,7.9086360e-002,-1.9575700e-002),\nvec3(-5.5065860e-002,7.8089190e-002,-1.9755480e-002),\nvec3(2.3706000e-002,8.0240410e-002,-2.5450120e-002),\nvec3(1.2254110e-002,8.3456700e-002,-3.0771580e-002),\nvec3(1.8549900e-003,8.4692790e-002,-3.4838500e-002),\nvec3(-2.0857000e-004,7.8941410e-002,-3.5782080e-002),\nvec3(-4.2710000e-004,8.2947370e-002,-3.6380660e-002),\nvec3(-4.4101600e-003,8.2794510e-002,-3.7467250e-002),\nvec3(-3.3202320e-002,1.0578320e-001,-2.0647590e-002),\nvec3(-3.9206970e-002,8.1536380e-002,-2.0571000e-002),\nvec3(-6.0355410e-002,7.9766610e-002,-1.9375540e-002),\nvec3(-4.1771830e-002,1.0396706e-001,-2.0832940e-002),\nvec3(-1.1204010e-002,8.2713320e-002,-3.8489610e-002),\nvec3(-2.3181500e-002,8.1686990e-002,-3.8329160e-002),\nvec3(-2.7233190e-002,8.0570950e-002,-3.6620670e-002),\nvec3(-3.5470180e-002,8.0196070e-002,-2.2325910e-002),\nvec3(-4.4864210e-002,8.1997900e-002,-2.0473520e-002),\nvec3(-5.0647890e-002,8.2309430e-002,-2.1365890e-002),\nvec3(-5.5522610e-002,8.1927600e-002,-2.1353790e-002),\nvec3(-8.8089610e-002,1.1135484e-001,1.8516150e-002),\nvec3(-7.2036080e-002,1.1107918e-001,4.5361400e-002),\nvec3(-3.3359780e-002,1.6986395e-001,-1.5448990e-002),\nvec3(-6.6839030e-002,6.2170510e-002,2.1576840e-002),\nvec3(3.0730560e-002,8.1968990e-002,-2.0040460e-002),\nvec3(1.6224320e-002,8.6480380e-002,-2.8952010e-002),\nvec3(-6.9855630e-002,1.0027892e-001,-1.4847830e-002),\nvec3(-6.3836170e-002,8.1704600e-002,-1.8908860e-002),\nvec3(-6.7914820e-002,8.0136290e-002,-1.7128200e-002),\nvec3(-4.5752080e-002,1.6340754e-001,-8.1780500e-003),\nvec3(1.1727540e-002,8.8010780e-002,-3.0860110e-002),\nvec3(7.3334800e-003,8.5270000e-002,-3.2829380e-002),\nvec3(-3.4356500e-003,8.7017890e-002,-3.6461000e-002),\nvec3(-2.6964110e-002,8.4512810e-002,-3.6361740e-002),\nvec3(-3.6553370e-002,8.5316190e-002,-2.2576200e-002),\nvec3(-3.8791090e-002,8.5232710e-002,-2.1917600e-002),\nvec3(-5.7676940e-002,8.6258340e-002,-2.1098320e-002),\nvec3(-6.2581810e-002,8.6394530e-002,-1.9169290e-002),\nvec3(-7.1395340e-002,1.2468846e-001,-8.5944200e-003),\nvec3(1.4801570e-002,9.9040900e-002,-2.2842920e-002),\nvec3(-2.1162860e-002,1.7491852e-001,-2.1977110e-002),\nvec3(-1.4824250e-002,8.7288840e-002,-3.8317070e-002),\nvec3(-2.3285750e-002,8.9468030e-002,-3.6027250e-002),\nvec3(-5.1595650e-002,8.4422070e-002,-2.1600960e-002),\nvec3(-6.9481040e-002,8.5656460e-002,-1.7198420e-002),\nvec3(-7.0917210e-002,1.0754846e-001,-1.1496630e-002),\nvec3(3.0145320e-002,8.6284000e-002,-2.0408140e-002),\nvec3(-5.5578110e-002,1.1567692e-001,-1.4645990e-002),\nvec3(-8.0981100e-003,8.9070080e-002,-3.6552200e-002),\nvec3(-8.1206310e-002,1.1205088e-001,-8.8299000e-004),\nvec3(-1.8772170e-002,8.9838040e-002,-3.6991710e-002),\nvec3(-2.1100420e-002,8.6587670e-002,-3.7849050e-002),\nvec3(-2.5809910e-002,8.8889590e-002,-3.5082250e-002),\nvec3(-4.8984800e-002,9.0731760e-002,-2.1817170e-002),\nvec3(-3.5874870e-002,3.4776000e-002,-3.0845200e-002),\nvec3(-3.3164390e-002,3.3606540e-002,-2.9721880e-002),\nvec3(-2.5964020e-002,3.3487000e-002,-2.6321120e-002),\nvec3(-1.6717530e-002,3.3611640e-002,-2.4625420e-002),\nvec3(-5.3486300e-003,3.3829010e-002,-2.2600430e-002),\nvec3(6.4843500e-003,3.4293000e-002,-2.0854930e-002),\nvec3(1.3950350e-002,3.4880000e-002,-1.8612870e-002),\nvec3(-4.2465980e-002,3.4189100e-002,-2.7260650e-002),\nvec3(-3.3241100e-002,3.3578760e-002,-2.6719450e-002),\nvec3(6.2813500e-003,3.4165800e-002,-1.8764230e-002),\nvec3(-4.4265790e-002,3.3663660e-002,-2.1914420e-002),\nvec3(-2.3671460e-002,3.3630970e-002,-2.3217760e-002),\nvec3(-1.1558580e-002,3.3895430e-002,-2.1054260e-002),\nvec3(-2.0406400e-003,3.4053940e-002,-1.9331070e-002),\nvec3(1.7323900e-003,3.4459660e-002,-1.6607870e-002),\nvec3(-2.7316070e-002,3.3910070e-002,-2.1353750e-002),\nvec3(-1.3371080e-002,3.4361580e-002,-1.9023720e-002),\nvec3(9.5887300e-003,3.4207220e-002,-1.5424050e-002),\nvec3(-1.4981540e-002,3.5878180e-002,-1.7992380e-002),\nvec3(-2.3474300e-003,3.5903130e-002,-1.5929740e-002),\nvec3(2.2544300e-003,3.6411540e-002,-1.4783970e-002),\nvec3(-3.5199130e-002,3.3835210e-002,-2.0508290e-002),\nvec3(-2.6075450e-002,3.5918600e-002,-1.9405170e-002),\nvec3(8.2740600e-003,3.5645200e-002,-1.2648700e-002),\nvec3(1.0473640e-002,3.4742600e-002,-1.1262870e-002),\nvec3(1.4055380e-002,3.4483430e-002,-1.4495730e-002),\nvec3(-3.6970520e-002,3.5680360e-002,-1.5007790e-002),\nvec3(-2.4719500e-003,3.8408770e-002,-1.4159030e-002),\nvec3(-3.9481890e-002,3.3618220e-002,-2.3612470e-002),\nvec3(-4.1091510e-002,3.4006000e-002,-1.1997540e-002),\nvec3(-3.1589810e-002,3.5592330e-002,-1.9204150e-002),\nvec3(-2.0086310e-002,3.8064450e-002,-1.7220790e-002),\nvec3(-1.1113250e-002,3.8290290e-002,-1.5646360e-002),\nvec3(4.4522600e-003,3.7705190e-002,-1.2957650e-002),\nvec3(1.5870480e-002,3.4416230e-002,-2.9666500e-003),\nvec3(-4.7872000e-002,3.4136300e-002,-1.5418250e-002),\nvec3(-4.7521640e-002,3.3622720e-002,-1.2804590e-002),\nvec3(-3.3407340e-002,3.7577040e-002,-1.6158190e-002),\nvec3(-2.7851470e-002,3.8404330e-002,-1.7210420e-002),\nvec3(-8.5065300e-003,3.9028950e-002,-1.3000800e-002),\nvec3(6.4552500e-003,3.8165190e-002,-1.0164860e-002),\nvec3(7.4147100e-003,3.4659190e-002,-3.0116800e-003),\nvec3(1.1966200e-002,3.4335400e-002,-5.9571300e-003),\nvec3(2.0414820e-002,3.5567580e-002,-3.7806900e-003),\nvec3(-1.9288780e-002,3.8762570e-002,-1.4202620e-002),\nvec3(-1.1390100e-003,3.9176760e-002,-1.0381370e-002),\nvec3(3.8149200e-003,3.9024470e-002,-8.0827300e-003),\nvec3(7.5208200e-003,3.6733400e-002,-6.7614300e-003),\nvec3(1.9968120e-002,3.4843990e-002,-1.8984900e-003),\nvec3(-4.5058400e-002,3.3600490e-002,-1.2527510e-002),\nvec3(-3.0754850e-002,3.8639810e-002,-1.4050770e-002),\nvec3(-5.1499810e-002,3.3729110e-002,-1.2082510e-002),\nvec3(-2.3756860e-002,3.8585750e-002,-1.1093270e-002),\nvec3(3.9734700e-003,3.8208550e-002,-3.7963500e-003),\nvec3(9.5485400e-003,3.4232620e-002,1.7162000e-003),\nvec3(2.9086550e-002,3.5799990e-002,3.5630900e-003),\nvec3(-5.5965200e-002,3.3529910e-002,-9.1246200e-003),\nvec3(-1.9523510e-002,3.8505210e-002,-4.5434500e-003),\nvec3(1.6363470e-002,3.4394790e-002,2.2948600e-003),\nvec3(2.1324740e-002,3.4624040e-002,5.6444000e-003),\nvec3(-3.9670300e-002,3.6174000e-002,-7.3397700e-003),\nvec3(-1.4251730e-002,3.8648030e-002,-4.3030400e-003),\nvec3(2.3262300e-003,3.5348200e-002,2.3246000e-003),\nvec3(1.4014300e-002,3.5703800e-002,3.8878900e-003),\nvec3(1.5322800e-002,3.6239700e-002,3.6628500e-003),\nvec3(2.3753130e-002,3.4670710e-002,3.9885300e-003),\nvec3(3.2369180e-002,3.5816010e-002,7.0246300e-003),\nvec3(-6.3715900e-002,3.3776930e-002,-8.0065600e-003),\nvec3(-6.4266880e-002,3.3562500e-002,-5.1253200e-003),\nvec3(-3.8066600e-002,3.8518600e-002,-7.3079600e-003),\nvec3(-9.4308800e-003,3.8887690e-002,-7.4848700e-003),\nvec3(3.9677800e-003,3.4200210e-002,4.9754500e-003),\nvec3(9.4292600e-003,3.6030400e-002,4.5275100e-003),\nvec3(2.9859020e-002,3.4980130e-002,9.8349300e-003),\nvec3(-5.2730060e-002,3.3497900e-002,-1.8117500e-003),\nvec3(-4.1271000e-002,3.3855400e-002,-1.8800800e-003),\nvec3(-3.1105000e-003,3.8946190e-002,-2.7793900e-003),\nvec3(6.2194100e-003,3.5134100e-002,6.5492800e-003),\nvec3(2.0897900e-002,3.5937100e-002,8.7849000e-003),\nvec3(3.5606010e-002,3.6526640e-002,9.8155300e-003),\nvec3(-6.7078340e-002,3.3840100e-002,-6.1688300e-003),\nvec3(-8.1140000e-004,3.7424170e-002,4.7721500e-003),\nvec3(3.1492300e-003,3.4125310e-002,1.1762220e-002),\nvec3(4.9172000e-003,3.3997100e-002,9.1666100e-003),\nvec3(2.5130800e-002,3.4546910e-002,1.1012580e-002),\nvec3(2.8248620e-002,3.5046370e-002,1.6016700e-002),\nvec3(-6.7032970e-002,6.5145960e-002,2.7292860e-002),\nvec3(-4.6380170e-002,3.3605230e-002,-8.9435000e-004),\nvec3(-3.3163400e-002,3.8195400e-002,-5.2520000e-004),\nvec3(-3.2074200e-002,3.8323400e-002,-4.2109000e-004),\nvec3(-2.1692690e-002,3.8266010e-002,4.5100800e-003),\nvec3(2.3930750e-002,3.4816710e-002,1.7739160e-002),\nvec3(4.2719120e-002,3.9977070e-002,8.9321600e-003),\nvec3(-5.8604080e-002,3.3462230e-002,-2.1667000e-004),\nvec3(-3.7314400e-002,3.3633000e-002,4.5724700e-003),\nvec3(-1.0423990e-002,3.8488570e-002,6.2292700e-003),\nvec3(-1.3896900e-003,3.8651360e-002,2.3966500e-003),\nvec3(-3.0845000e-004,3.5462480e-002,8.2607200e-003),\nvec3(-1.4089000e-003,3.6193080e-002,1.2944550e-002),\nvec3(2.2252900e-002,3.6583300e-002,1.3979700e-002),\nvec3(-7.0961830e-002,3.4345730e-002,-7.8374000e-004),\nvec3(-6.9066180e-002,3.3717630e-002,-1.9761000e-004),\nvec3(-6.4825640e-002,3.3505860e-002,2.8222500e-003),\nvec3(-4.7059660e-002,3.3501860e-002,3.5646400e-003),\nvec3(-3.6953800e-003,3.8172780e-002,1.3046800e-002),\nvec3(3.3475850e-002,3.6447340e-002,1.6266960e-002),\nvec3(3.7249610e-002,3.7509920e-002,1.4815820e-002),\nvec3(-4.5675940e-002,3.3703640e-002,6.4300300e-003),\nvec3(-3.8639270e-002,3.3937310e-002,8.5506500e-003),\nvec3(-9.5064100e-003,3.8352640e-002,1.5570660e-002),\nvec3(2.1499800e-002,3.5807100e-002,1.8169400e-002),\nvec3(4.4876460e-002,4.1230990e-002,1.6008250e-002),\nvec3(-7.2474010e-002,3.6255930e-002,1.5532600e-003),\nvec3(-7.1498130e-002,3.4452970e-002,4.2026500e-003),\nvec3(-2.7790900e-002,3.8062900e-002,7.9376100e-003),\nvec3(-1.6556410e-002,3.8286470e-002,1.0215790e-002),\nvec3(8.1043500e-003,3.4842900e-002,1.8134600e-002),\nvec3(2.3589460e-002,3.5890600e-002,2.5337690e-002),\nvec3(4.1261350e-002,4.0585070e-002,2.0751930e-002),\nvec3(-5.1350870e-002,3.3645700e-002,8.0329400e-003),\nvec3(-4.7104300e-002,3.5549500e-002,8.0803900e-003),\nvec3(-1.4103500e-003,3.6999940e-002,1.6982030e-002),\nvec3(9.1714000e-004,3.4803380e-002,1.5634690e-002),\nvec3(2.8887900e-003,3.4636250e-002,1.8849770e-002),\nvec3(1.3279200e-002,3.4379500e-002,2.1423700e-002),\nvec3(1.4322700e-002,3.4425500e-002,2.1593200e-002),\nvec3(1.7490100e-002,3.4646300e-002,2.2040900e-002),\nvec3(2.9868460e-002,3.6248820e-002,1.9872200e-002),\nvec3(-3.9222000e-002,3.6326200e-002,1.0789900e-002),\nvec3(-3.0307100e-002,3.3995400e-002,1.4706400e-002),\nvec3(2.0081230e-002,3.5172700e-002,2.8018770e-002),\nvec3(2.4989010e-002,3.8104580e-002,2.9429570e-002),\nvec3(3.3584130e-002,3.8303930e-002,2.2928670e-002),\nvec3(4.9015720e-002,4.4573630e-002,2.0659450e-002),\nvec3(-5.8225970e-002,6.6607310e-002,3.5050280e-002),\nvec3(-6.7330830e-002,3.3846440e-002,8.7266300e-003),\nvec3(-3.4692330e-002,3.3828710e-002,1.2438580e-002),\nvec3(-2.9803200e-002,3.4287000e-002,1.6353100e-002),\nvec3(1.7023800e-003,3.6310890e-002,2.1179600e-002),\nvec3(4.5137020e-002,4.4625440e-002,2.5516510e-002),\nvec3(-6.8876490e-002,1.1022176e-001,3.9004630e-002),\nvec3(-5.7680560e-002,3.3622690e-002,1.4040310e-002),\nvec3(-5.3210500e-002,3.3585300e-002,1.3987000e-002),\nvec3(-3.5711600e-002,3.5891600e-002,1.5502900e-002),\nvec3(-2.8861500e-002,3.5396700e-002,1.7350000e-002),\nvec3(-2.6580500e-002,3.7742600e-002,1.5705300e-002),\nvec3(-1.0974400e-003,3.8147840e-002,2.0427010e-002),\nvec3(3.5047710e-002,4.0973940e-002,2.6970390e-002),\nvec3(-6.9685460e-002,3.4478780e-002,9.7984300e-003),\nvec3(-5.4019000e-002,3.3309900e-002,1.5848000e-002),\nvec3(4.4816800e-003,3.7117830e-002,2.4755300e-002),\nvec3(6.6605500e-003,3.5204730e-002,2.4315930e-002),\nvec3(8.3833000e-003,3.4748700e-002,2.4057310e-002),\nvec3(3.8883100e-002,4.1032980e-002,2.4976570e-002),\nvec3(-2.6441900e-003,3.8727070e-002,2.5131260e-002),\nvec3(3.2222300e-003,3.8708440e-002,2.5898750e-002),\nvec3(9.0016500e-003,3.6890930e-002,2.8482190e-002),\nvec3(1.3196980e-002,3.4835790e-002,3.1630980e-002),\nvec3(2.2291600e-002,3.7053310e-002,3.3101020e-002),\nvec3(2.8948390e-002,3.9160020e-002,2.7234810e-002),\nvec3(-8.7773470e-002,1.1181412e-001,3.7144310e-002),\nvec3(-1.7870490e-002,3.8203890e-002,2.0243220e-002),\nvec3(1.0087420e-002,3.7047690e-002,3.0822500e-002),\nvec3(4.2296550e-002,4.5435770e-002,2.9040920e-002),\nvec3(-8.4341340e-002,1.1388013e-001,4.6513480e-002),\nvec3(-7.3795710e-002,1.0895629e-001,3.9217250e-002),\nvec3(-5.1243340e-002,6.4239200e-002,3.4258040e-002),\nvec3(-6.1777390e-002,3.4017860e-002,1.6900580e-002),\nvec3(-3.6665100e-002,3.5304200e-002,2.3032000e-002),\nvec3(-1.4930180e-002,3.8643510e-002,2.9378330e-002),\nvec3(-8.0894520e-002,1.0967225e-001,3.7910230e-002),\nvec3(-8.9822620e-002,1.1387199e-001,3.2845310e-002),\nvec3(-6.9655510e-002,6.8728370e-002,3.1127880e-002),\nvec3(-7.8449800e-002,1.0988832e-001,4.2517920e-002),\nvec3(-7.5824140e-002,1.0794900e-001,3.7128750e-002),\nvec3(-5.5740630e-002,3.4128050e-002,2.6674360e-002),\nvec3(-3.8279600e-002,3.5429000e-002,2.4380600e-002),\nvec3(-3.5283340e-002,3.4179780e-002,2.2744860e-002),\nvec3(-2.5798070e-002,3.7865000e-002,1.9981460e-002),\nvec3(6.9064300e-003,3.9004270e-002,2.9548510e-002),\nvec3(1.5448990e-002,3.4852440e-002,3.6984890e-002),\nvec3(1.9128230e-002,3.5640640e-002,3.6642280e-002),\nvec3(-6.3664970e-002,6.6047840e-002,3.1828080e-002),\nvec3(3.9604800e-002,4.4939530e-002,2.9992360e-002),\nvec3(-8.0294310e-002,7.1702430e-002,1.5995300e-002),\nvec3(-5.4185430e-002,6.7322700e-002,3.6935610e-002),\nvec3(-7.3110210e-002,1.4847168e-001,-2.8748470e-002),\nvec3(-5.8999980e-002,7.3751550e-002,4.1197080e-002),\nvec3(-5.9520730e-002,6.1040260e-002,-2.3753800e-003),\nvec3(-6.2791800e-002,3.4596760e-002,2.3505640e-002),\nvec3(-4.1895500e-002,3.3668300e-002,2.6940000e-002),\nvec3(8.9808200e-003,3.7639400e-002,3.3900800e-002),\nvec3(8.5287800e-003,3.4888000e-002,3.6265100e-002),\nvec3(-8.9803890e-002,1.1498106e-001,4.2771650e-002),\nvec3(-6.5545420e-002,7.4430370e-002,3.9168070e-002),\nvec3(-6.4644190e-002,6.1723230e-002,2.2552000e-004),\nvec3(5.2496900e-003,3.9507100e-002,3.3271200e-002),\nvec3(2.0250320e-002,3.7033170e-002,3.9327190e-002),\nvec3(-6.7006400e-002,6.3292870e-002,-1.7493900e-003),\nvec3(-6.4479770e-002,6.0651470e-002,4.2343200e-003),\nvec3(-5.7219630e-002,5.7000470e-002,4.9175800e-003),\nvec3(-7.4362810e-002,7.2437050e-002,3.1430040e-002),\nvec3(-6.2019000e-002,3.4343180e-002,3.1883280e-002),\nvec3(-4.6870820e-002,3.4444130e-002,3.0513130e-002),\nvec3(-2.0814280e-002,3.8400960e-002,2.7868430e-002),\nvec3(1.6439350e-002,3.5635110e-002,4.1281040e-002),\nvec3(-6.9087160e-002,1.1205014e-001,4.5320060e-002),\nvec3(-7.1811570e-002,1.4861318e-001,-3.4639490e-002),\nvec3(-6.9538770e-002,6.3074750e-002,3.5758200e-003),\nvec3(-8.4863890e-002,7.8392100e-002,1.6462010e-002),\nvec3(-9.1188780e-002,1.1588893e-001,2.4705540e-002),\nvec3(-8.8827760e-002,1.1359169e-001,2.3873640e-002),\nvec3(-7.1302830e-002,1.1325363e-001,4.9444530e-002),\nvec3(-5.4876950e-002,7.0282330e-002,3.8828200e-002),\nvec3(-7.7208880e-002,1.0715887e-001,3.4738290e-002),\nvec3(-6.1241780e-002,5.9007440e-002,8.0916600e-003),\nvec3(-6.5885650e-002,3.5025080e-002,2.9416520e-002),\nvec3(-5.7889430e-002,3.4419570e-002,3.6265760e-002),\nvec3(-5.1847710e-002,3.4470270e-002,3.4635180e-002),\nvec3(-3.4834600e-002,3.4721400e-002,3.4578200e-002),\nvec3(-3.0984700e-002,3.8191900e-002,3.2390100e-002),\nvec3(-4.9613100e-003,3.9364900e-002,3.6702200e-002),\nvec3(1.2224170e-002,3.5177480e-002,4.2620580e-002),\nvec3(-7.4898220e-002,1.1458863e-001,5.0776480e-002),\nvec3(-8.0469100e-002,1.1357963e-001,4.6643440e-002),\nvec3(-7.4107560e-002,6.9586030e-002,2.7264400e-002),\nvec3(-7.9002620e-002,7.6339320e-002,2.9248090e-002),\nvec3(-6.5297080e-002,3.4778970e-002,3.3744340e-002),\nvec3(-3.3656400e-002,3.4344100e-002,3.6914100e-002),\nvec3(4.9318500e-003,3.4814800e-002,4.3462110e-002),\nvec3(1.1347440e-002,3.6213020e-002,4.4652280e-002),\nvec3(-6.0569260e-002,7.1154540e-002,3.8653760e-002),\nvec3(-8.8979470e-002,1.1450869e-001,2.8446030e-002),\nvec3(-6.8543520e-002,6.1090480e-002,1.0557760e-002),\nvec3(-8.2710960e-002,1.1648975e-001,4.8518530e-002),\nvec3(-4.1913210e-002,3.4467720e-002,3.3200040e-002),\nvec3(-1.1289800e-002,3.9529200e-002,3.8844100e-002),\nvec3(-2.8261900e-003,3.4885340e-002,4.5611410e-002),\nvec3(-6.4561210e-002,5.9484140e-002,1.3061680e-002),\nvec3(-5.8581440e-002,5.7801460e-002,1.3429540e-002),\nvec3(-2.3320000e-002,3.9169500e-002,3.8473300e-002),\nvec3(-1.8159900e-002,3.9322300e-002,3.9402900e-002),\nvec3(-1.6471400e-002,3.4812800e-002,4.3684700e-002),\nvec3(3.2906600e-003,3.5833470e-002,4.6024610e-002),\nvec3(-8.5229630e-002,1.1200712e-001,3.0416940e-002),\nvec3(-8.5644730e-002,1.1131719e-001,3.4234780e-002),\nvec3(-7.4530360e-002,6.6680690e-002,4.6953300e-003),\nvec3(-7.1112970e-002,6.2751470e-002,8.7995500e-003),\nvec3(-6.1149380e-002,5.8834410e-002,1.6539440e-002),\nvec3(-4.6912270e-002,3.4627180e-002,3.9739710e-002),\nvec3(-4.0760350e-002,3.4668230e-002,4.0492530e-002),\nvec3(-2.6323100e-002,3.4658000e-002,4.3473500e-002),\nvec3(-3.1836600e-003,3.6229910e-002,4.7873100e-002),\nvec3(-7.9940490e-002,1.0916678e-001,3.4119800e-002),\nvec3(-5.9712170e-002,6.3165280e-002,2.8789180e-002),\nvec3(-5.1176600e-002,6.8061880e-002,3.7398330e-002),\nvec3(-5.0126580e-002,7.0933150e-002,3.9481010e-002),\nvec3(-7.2790130e-002,6.4399880e-002,1.5205950e-002),\nvec3(-6.8511230e-002,6.1214650e-002,1.5354080e-002),\nvec3(-3.9343210e-002,3.5440180e-002,4.2492560e-002),\nvec3(-8.1305900e-003,3.5008350e-002,4.7502400e-002),\nvec3(-6.6080670e-002,7.0202740e-002,3.5552860e-002),\nvec3(-6.8602600e-002,1.4992277e-001,-4.0051350e-002),\nvec3(-7.1722100e-002,6.7023040e-002,2.4959750e-002),\nvec3(-7.5115010e-002,6.6557040e-002,1.0244090e-002),\nvec3(-6.5146650e-002,3.5945650e-002,3.9775080e-002),\nvec3(-3.6898600e-002,3.5924640e-002,4.4794170e-002),\nvec3(-9.4780400e-003,3.5977600e-002,4.9434210e-002),\nvec3(-8.5175960e-002,1.1706809e-001,4.8139420e-002),\nvec3(-6.3366400e-002,6.2790260e-002,2.5647610e-002),\nvec3(-6.6633330e-002,6.1001700e-002,1.8101240e-002),\nvec3(-5.8167590e-002,5.9985190e-002,2.2606060e-002),\nvec3(-6.4212210e-002,3.4992560e-002,3.9401920e-002),\nvec3(-5.3425790e-002,3.4560020e-002,4.2782420e-002),\nvec3(-1.8031490e-002,3.4859970e-002,4.9264760e-002),\nvec3(-1.1440410e-002,3.7640770e-002,5.0275730e-002),\nvec3(-7.5165320e-002,1.1154286e-001,4.6707180e-002),\nvec3(-7.7168390e-002,6.9826450e-002,5.0605600e-003),\nvec3(-7.2801360e-002,6.4382590e-002,1.2089080e-002),\nvec3(-7.8022000e-002,7.0995160e-002,2.1322150e-002),\nvec3(-6.1263370e-002,3.4690410e-002,4.1994900e-002),\nvec3(-5.4403750e-002,3.5007310e-002,4.4874590e-002),\nvec3(-4.5754280e-002,3.5206980e-002,4.3518120e-002),\nvec3(-3.3832440e-002,3.5168820e-002,4.6957890e-002),\nvec3(-2.8657630e-002,3.5083380e-002,5.0549440e-002),\nvec3(-1.5306440e-002,3.5246410e-002,5.0133810e-002),\nvec3(-6.5283650e-002,1.5592447e-001,-4.9865930e-002),\nvec3(-6.6467860e-002,1.4871539e-001,-3.1579300e-002),\nvec3(-6.2095980e-002,1.6388324e-001,-5.8385930e-002),\nvec3(-6.3274890e-002,1.5245731e-001,-3.2221730e-002),\nvec3(-4.3755720e-002,1.4773408e-001,-2.1433200e-003),\nvec3(-6.5696940e-002,1.4561631e-001,-1.8974710e-002),\nvec3(-6.6713650e-002,1.5358824e-001,-4.9097100e-002),\nvec3(-1.0482810e-002,1.6668287e-001,-2.1746090e-002),\nvec3(-6.2744510e-002,1.6397531e-001,-5.9398280e-002),\nvec3(-7.0413230e-002,1.4129200e-001,-8.4590800e-003),\nvec3(-6.1530380e-002,1.4037628e-001,-6.2734700e-003),\nvec3(-1.1452460e-002,1.7220633e-001,-2.6844980e-002),\nvec3(-6.3731140e-002,1.6577037e-001,-6.0103610e-002),\nvec3(-2.8218820e-002,1.5758144e-001,-1.0999490e-002),\nvec3(-1.8471270e-002,1.5967716e-001,-1.1169510e-002),\nvec3(-6.6700710e-002,1.5236775e-001,-4.5266390e-002),\nvec3(-4.9896410e-002,1.4670859e-001,-1.8614200e-003),\nvec3(-3.1449640e-002,1.5460463e-001,-7.6802300e-003),\nvec3(-6.7447660e-002,1.5507675e-001,-5.1594250e-002),\nvec3(-1.0906650e-002,1.7649301e-001,-2.9246300e-002),\nvec3(-7.2083600e-002,1.4965550e-001,-3.9265860e-002),\nvec3(-6.4230830e-002,1.4877806e-001,-2.5899710e-002),\nvec3(-6.3056640e-002,1.4341650e-001,-7.4907700e-003),\nvec3(-5.3043350e-002,1.4092550e-001,-4.7408000e-004),\nvec3(-3.9269410e-002,1.5205232e-001,-6.6203800e-003),\nvec3(-6.4796930e-002,1.5210615e-001,-3.6185520e-002),\nvec3(-6.4400320e-002,1.5834400e-001,-5.4256370e-002),\nvec3(-6.6178120e-002,1.4218350e-001,-9.3766300e-003),\nvec3(-6.7751430e-002,1.4605207e-001,-2.3333300e-002),\nvec3(-6.4731580e-002,1.5410067e-001,-4.0464820e-002),\nvec3(-2.4265590e-002,1.5687690e-001,-7.8509300e-003),\nvec3(-1.5723180e-002,1.6312344e-001,-1.6396570e-002),\nvec3(-7.0887660e-002,1.4404618e-001,-1.4908480e-002),\nvec3(-4.4341830e-002,1.5113809e-001,-5.6859800e-003),\nvec3(-6.2896810e-002,1.4694778e-001,-1.3098620e-002),\nvec3(-6.3755400e-002,1.4428875e-001,-1.1395730e-002),\nvec3(-6.8214560e-002,1.4390932e-001,-1.4984170e-002),\nvec3(-5.0271440e-002,1.4336563e-001,1.5153000e-003),\nvec3(-2.8535590e-002,1.6208479e-001,-1.4786030e-002),\nvec3(-6.5810700e-002,1.4359119e-001,-1.2585380e-002),\nvec3(-5.6179200e-002,1.3774406e-001,-4.0674300e-003),\nvec3(-6.8866880e-002,1.4723338e-001,-2.8739870e-002),\nvec3(-6.0965420e-002,1.7002113e-001,-6.0839390e-002),\nvec3(-1.3895490e-002,1.6787168e-001,-2.1897230e-002),\nvec3(-6.9413000e-002,1.5121847e-001,-4.4538540e-002),\nvec3(-5.5039800e-002,5.7309700e-002,1.6990900e-002));\n\nconst vec3 shift = vec3(0.,0.07,0.);\nconst float scale = 0.09;\n\nobject obj; vec4 lnk; \n\nvec4 d; int ID; float avgR;\n\nobject getObject(int id)\n{\n    object o;\n    if(id<0) id = 0;\n    \n    vec4 a = texel(ch0, i2xy(ivec3(id, 0, 0))); \n    o.X = a.xyz; o.bR = a.w;\n    o.a = texel(ch0, i2xy(ivec3(id, 1, 0))).xyz;\n    o.b = texel(ch0, i2xy(ivec3(id, 2, 0))).xyz;\n    o.c = texel(ch0, i2xy(ivec3(id, 3, 0))).xyz;\n    \n    o.id = id;\n    return o;\n}\n\nvec4 saveObject(int i)\n{\n    switch(i)\n    {\n    case 0:  \n        return vec4(obj.X, obj.bR);\n    case 1:\n        return vec4(obj.a, 0.);\n    case 2:\n        return vec4(obj.b, 0.);\n    case 3:\n        return vec4(obj.c, 0.);\n    }\n}\n\nvoid sort(int idtemp, int R, int T);\nvoid sortlinks(int id, int R, int R0, int T);\nvoid sortneighbors(int id, int R, int T);\nvoid sortrandom(int id, int R, int T);\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(floor(pos));\n    if(any(greaterThan(p, sN*N-1))) discard;\n   \n    ivec3 sid = xy2i(p); ID = sid.x;\n    obj = getObject(ID);\n   \tif(sid.z == 0) //object computation\n    {    \n        if(sid.y < 4)\n        {\n            //bounding sphere\n            obj.bR = 0.03;\n            if(iFrame<1) //initial conditions\n            {\n                if(ID < 2500 && ID >= 0)\n                {\n                    obj.X = (vertecies[ID]-shift)/scale;\n                    obj.X = obj.X.xzy;\n                }\n            }  \n            \n            U = saveObject(sid.y);\n        }\n    }\n    else //graph computation\n    {\n        d = vec4(1e6);\n        lnk = vec4(-1);\n       \n        sortlinks(ID, sid.y, sid.y, sid.z);\n        \n        sortneighbors(ID, sid.y, sid.z);\n        \n        sortrandom(sid.x, sid.y, sid.z);\n        \n        U = lnk;\n    }\n}\n\n\nbool iscoincidence(int id)\n{\n    return (id == ID) || (id < 0) || any(equal(lnk,vec4(id)));\n}\n\nfloat dist2bisector(vec3 dir, int i)\n{\n    vec4 nb = texel(ch0, i2xy(ivec3(obj.id, i, 1)));\n    object nbo = getObject(int(nb.x));  \n    return dirBisectDist(dir, obj.X, nbo.X, distance(nbo.X, obj.X));\n}\n\nvoid sort(int idtemp, int R, int T) //sort closest objects in N directions\n{\n    if(iscoincidence(idtemp)) return; //particle already sorted\n    object o = getObject(idtemp);\n    vec3 dir = fibonacci_sphere(R, link0);\n    \n    float t = 1e10;\n    switch(T)\n    {\n    case 1: //sort by bisector distance\n        t = dirBisectDist(dir, obj.X, o.X, distance(o.X, obj.X));\n        if(t > 1e9) return;\n        break;\n    case 2: //sort by sdf distance to this bisector line\n        float bd = dist2bisector(dir, R);\n        t = min(t, 4.*sdObj(obj.X + 0.37*dir*bd, o));\n        t = min(t, 2.*sdObj(obj.X + 0.75*dir*bd, o));\n        //t = min(t, sdObj(obj.X + dir*bd, o));\n        break;\n    }\n   \n    //insertion sort\n    if(d.x > t)\n    {\n        d = vec4(t, d.xyz);\n        lnk = vec4(idtemp, lnk.xyz);\n    }\n    else if(d.y > t)\n    {\n        d.yzw = vec3(t, d.yz);\n        lnk.yzw = vec3(idtemp, lnk.yz);\n    }\n    else if(d.z > t)\n    {\n        d.zw = vec2(t, d.z);\n        lnk.zw = vec2(idtemp, lnk.z);\n    }\n    else if(d.w > t)\n    {\n        d.w = t;\n        lnk.w = float(idtemp);\n    }\n}\n\nvoid sortlinks(int id, int R, int R0, int T)\n{\n    vec4 nb = texel(ch0, i2xy(ivec3(id, R, T)));\n    for(int i = min(0, iFrame); i<4; i++) \n        sort(int(nb[i]), R0, T);\n}\n\nvoid sortneighbors(int id, int R, int T)\n{\n    vec3 dir = fibonacci_sphere(R, link0);\n    vec4 d4 = iSF(dir, float(link0));\n    for(int i = min(0, iFrame); i < 4; i++)\n    {\n         int dir = int(d4[i]);\n         vec4 nb = texel(ch0, i2xy(ivec3(id, dir, T)));\n    \t for(int j = min(0, iFrame); j < 4; j++) \n         {\n         \tsortlinks(int(nb[j]), (16*iFrame+4*j+i)%link0, R, T); \n         }\n    }  \n}\n\nvoid sortrandom(int id, int R, int T)\n{\n    for(int i = min(0, iFrame); i<2; i++) sort((12*iFrame+ID+i)%tot_n, R, T);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//prev closest triangle buffer\n//render\n\nobject getObject(int id)\n{\n    object o;\n    if(id<0) id = 0;\n    \n    vec4 a = texel(ch0, i2xy(ivec3(id, 0, 0))); \n    o.X = a.xyz; o.bR = a.w;\n    o.a = texel(ch0, i2xy(ivec3(id, 1, 0))).xyz;\n    o.b = texel(ch0, i2xy(ivec3(id, 2, 0))).xyz;\n    o.c = texel(ch0, i2xy(ivec3(id, 3, 0))).xyz;\n    \n    o.id = id;\n    return o;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat findClosest(vec3 p, inout object co, int mit)\n{    \n    float t = distance(p, co.X); \n    float st = t;\n    for(int s = min(0,iFrame); s < mit; s++)\n    {\n    \tint pid = co.id;\n        \n        int dir = int(inverseSF(normalize(p - co.X), float(link0)).x);\n        st = t;\n        vec4 nb = texel(ch0, i2xy(ivec3(co.id, dir%link0, 1)));\n        for(int i = min(0,iFrame); i<4; i++)\n        {\n            object o = getObject(int(nb[i]));\n            float tt = distance(p, o.X);\n            \n            st = smin(st, tt, 0.01);\n            if(tt < t)\n            {\n                t = tt;\n                co = o;\n            }\n        }   \n        \n        if(pid == co.id) break;\n    }\n    return st - co.bR;\n}\n\n#define maxd 20.\n#define mind 0.003\n#define maxs 128\n\nfloat map(vec3 p, inout object co)\n{\n    //find closest voronoi cell\n    float DE = 0.5*findClosest(p, co, 64); //works well for spheres\n    \n    return min(DE, p.z+0.5);\n}\n\nvec4 calcNormal(vec3 p, float dx, in object co) {\n\tconst vec3 k = vec3(1,-1,0);\n\treturn   (k.xyyx*map(p + k.xyy*dx, co) +\n\t\t\t k.yyxx*map(p + k.yyx*dx, co) +\n\t\t\t k.yxyx*map(p + k.yxy*dx, co) +\n\t\t\t k.xxxx*map(p + k.xxx*dx, co))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\nvec3 col(vec3 p, in vec4 cobj)\n{\n    //voronoi neighbors projected on the sphere surface\n    return vec3(1.);\n}\n\n//voronoi diagram ray marching\nvec4 rayMarch(vec3 p, vec3 d, inout object co)\n{\n    if(co.id < 0)\n    {\n        co = getObject(0);\n    }\n    \n    float td = 0.; float DE = 1e10;\n    for(int i = min(0, iFrame); i < maxs; i++)\n    {\n        //march\n        DE = map(p, co);\n        \n        p += DE*d;\n        td += DE;\n        \n        //outide of the scene\n        if(td > maxd) return vec4(p, -1.);\n        //has hit the surface\n        if(DE < mind*td) break;\n    }\n    return vec4(p, DE);\n}\n\nfloat shadow_march(vec4 pos, vec4 dir, float distance2light, float light_angle, inout object co)\n{\n\tfloat light_visibility = 1.;\n\tfloat ph = 1e5;\n    float td = dir.w;\n\tpos.w = map(pos.xyz, co);\n\tfor (int i = min(0, iFrame); i < 32; i++) \n    {\n\t\tdir.w += pos.w;\n\t\tpos.xyz += pos.w*dir.xyz;\n\t\tpos.w = map(pos.xyz, co);\n\t\tfloat y = pos.w*pos.w/(2.0*ph);\n        float d = (pos.w+ph)*0.5;\n\t\tfloat angle = d/(max(0.00001,dir.w-y-td)*light_angle);\n        light_visibility = min(light_visibility, angle);\n\t\tph = pos.w;\n\t\tif(dir.w >= distance2light) break;\n\t\tif(dir.w > maxd || pos.w < mind*dir.w) return 0.;\n    }\n\treturn 0.5 - 0.5*cos(PI*light_visibility);\n}\n\n\n#define FOV 2.\nmat3 getRot(vec2 a)\n{\n    \n   mat3 theta_rot = mat3(1, 0, 0,\n                         0, cos(a.y), sin(a.y),\n                         0, -sin(a.y), cos(a.y)); \n        \n   mat3 phi_rot = mat3(cos(a.x), sin(a.x), 0,\n        \t\t       -sin(a.x), cos(a.x), 0,\n        \t\t        0, 0, 1); \n   return transpose(phi_rot*theta_rot);\n}\n\nvec3 getRay(vec2 angles, vec2 pos)\n{\n    mat3 camera = getRot(angles);\n    return normalize(transpose(camera)*vec3(FOV*pos.x, FOV*pos.y, 1.));\n}\n\n\n#define ldir vec3(cos(iTime*0.1)*sin(PI*0.4),sin(iTime*0.1)*sin(PI*0.4), cos(PI*0.4))\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 HDRmapping(vec3 color, float exposure)\n{\n\t// Exposure tone mapping\n    vec3 mapped = ACESFilm(color * exposure);\n    // Gamma correction \n    return pow(mapped, vec3(1.0 / 2.2));\n}\n\nconst float Br = 0.0025;\nconst float Bm = 0.0003;\nconst float g =  0.9800;\nconst vec3 nitrogen = vec3(0.650, 0.570, 0.475);\nconst vec3 Kr = Br / pow(nitrogen, vec3(4.0));\nconst vec3 Km = Bm / pow(nitrogen, vec3(0.84));\n\nvec3 sky_color(in vec3 pos)\n{\n\t// Atmosphere Scattering\n\tvec3 fsun = ldir.xzy;\n\tfloat brightnees = exp(-sqrt(pow(abs(min(5.*(pos.y-0.1),0.)),2.)+0.1));\n\tif(pos.y < 0.)\n\t{\n\t\tpos.y = 0.;\n\t\tpos.xyz = normalize(pos.xyz);\n\t}\n    float mu = dot(normalize(pos), normalize(fsun));\n\t\n\tvec3 extinction = mix(exp(-exp(-((pos.y + fsun.y * 4.0) * (exp(-pos.y * 16.0) + 0.1) / 80.0) / Br) * (exp(-pos.y * 16.0) + 0.1) * Kr / Br) * exp(-pos.y * exp(-pos.y * 8.0 ) * 4.0) * exp(-pos.y * 2.0) * 4.0, vec3(1.0 - exp(fsun.y)) * 0.2, -fsun.y * 0.2 + 0.5);\n\tvec3 sky_col = brightnees* 3.0 / (8.0 * 3.14) * (1.0 + mu * mu) * (Kr + Km * (1.0 - g * g) / (2.0 + g * g) / pow(1.0 + g * g - 2.0 * g * mu, 1.5)) / (Br + Bm) * extinction;\n\tsky_col = 0.4*clamp(sky_col,0.,10.);\n\treturn pow(sky_col,vec3(1./1.5)); \n}\n\nvec3 ambient_sky_color(in vec3 pos)\n{\n\tfloat y = pos.y;\n\tpos.xyz = normalize(vec3(1,0,0));\n\treturn sky_color(pos)*exp(-abs(y));\n}\n\nvec4 ambient_occlusion(in vec4 pos, in vec4 norm, in vec4 dir, in object co)\n{\t\n\tvec3 pos0 = pos.xyz;\n\tvec3 ambient_color = ambient_sky_color(norm.xyz);\n\tpos.xyz += 0.03*dir.w*norm.xyz;\n    pos.w = map(pos.xyz, co);\n\tpos.xyz += pos.w*norm.xyz;\n\tnorm.w = length(pos0 - pos.xyz);\n\tfloat occlusion_angle = clamp(pos.w/norm.w,0.,1.);\n\treturn vec4(ambient_color,1.)*(0.5-cos(3.14159265*occlusion_angle)*0.5);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = (pos - size*0.5)/size.y;\n    vec2 angles = (iMouse.z>0.)?(iMouse.xy/iResolution.xy)*vec2(2.*PI, PI):vec2(-0.4*iTime, PI*0.6);\n    \n    vec3 d = getRay(angles, uv);\n    vec3 p = vec3(0,0,0.7)-1.5*getRay(angles, vec2(0.));\n    vec4 prev = pixel(ch1, pos);\n    if(iFrame < 1) prev.w = 0.;\n    object co = getObject(int(prev.w));\n    findClosest(p, co, 16);\n    float closest = float(co.id);\n    vec4 rm = rayMarch(p, d, co);\n    float td = distance(rm.xyz, p);\n    if(rm.w >= 0.) //hit object\n    {\n    \tvec3 n = normalize(calcNormal(rm.xyz, mind*td,co).xyz);\n        vec4 ao = ambient_occlusion(rm, vec4(n, rm.w), vec4(d, td), co);\n        float sh = shadow_march(vec4(rm.xyz+n*0.01, rm.w), vec4(ldir,0.), 10., 0.12, co);\n        U.xyz = sh*sky_color(ldir.xzy)*max(dot(ldir, n),0.) + ao.xyz;\n    }\n    else //background\n    {\n        U.xyz = sky_color(d.xzy);\n    }\n    U.xyz = HDRmapping(U.xyz, 0.5);\n    U.w = closest;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdSczw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 101, 101, 136]], "test": "untested"}
{"id": "wdBcRw", "name": "Day 110", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 18, "viewed": 569, "published": 3, "date": "1586293642", "time_retrieved": "2024-07-30T21:14:19.187049", "image_code": "// glow - balkhan EDIT: it's actually from here https://www.shadertoy.com/view/XlBSRz\n// pallete and smooth union - inigo quilez\n// step epsilon - noby\n// dither - nusan\n\n\n// This is a modified and rotated apollonian-type fractal\n\n// radiual chromab in this buffer\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n\tfragColor = vec4(0);\n    // Radial blur\n    float steps = 40.;\n    float scale = 0.00 + pow(dot(uvn,uvn),1.5)*0.1;\n    float chromAb = pow(length(uv - 0.5),1.9)*3.;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n        scale *= 0.97;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1.4/iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    fragColor += radial;\n    \n    //fragColor = 1. - fragColor;\n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.4);\n    fragColor = pow(fragColor, vec4(1. + dot(uvn,uvn))*1. );\n    fragColor = max(fragColor, 0.);\n    //fragColor.b *= 1. + uv.x*0.4;\n    fragColor *= 1. - dot(uvn,uvn)*2.;\n    fragColor = pow(fragColor, vec4(0.4545 ));\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define tsp iTime\n\n\n#define pmod(p,z) mod(p,z) - 0.5*z\n#define dmin(a,b) a.x < b.x ? a : b\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x)) \n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\nvec3 glow = vec3(0);\n\nvec3 path (float z){\n    z *= 0.29;\n\treturn vec3(0. + sin(z),0. + cos(z),0.)*1.;\n}\n\nfloat sdBox(vec3 p, vec3 s){\n\tp = abs(p) - s;\n\treturn max(p.y, max(p.z,p.x));\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nvec2 map(vec3 p){\n\tvec2 d= vec2(10e7);\n    \n    vec3 k = p;\n    p -= path(p.z);\n    \n    \n    p.z *= 0.5;\n    \n    \n    vec3 par = vec3(2.8,2.14,0.9);\n    vec4 q = vec4(p.xyz, 1.);\n    \n    \n    for(float i = 0.; i < 9.;i++){\n        q.xyz = abs(mod(q.xyz - par*0.5,par) - 0.5*par);\n        \n    \tfloat dpp = dot(q.xyz, q.xyz);\n        \n        q.xy *= rot(0.4);\n        q = q/dpp;\n    }\n    \n    float dF = length(q.xz)/q.w;\n    d.x = min(d.x, dF);\n    \n    d.x = opSmoothIntersection( d.x, -length(p.xy) + 0.36 , 0.4 );\n    \n    d.x -= 0.04;\n    d.x = abs(d.x) + 0.003;\n    glow -= 0.1/(0.001 + d.x*d.x*200.);\n    \n    \n    \n    float dL = length(q.zx)/q.w;\n\n    d.x = max(d.x,  -length(p.xy) + 0.2 );\n    \n    d.x *= 0.45;\n    \n    \n    return d;\n}\n\nfloat dith;\n\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tvec2 d = vec2(10e7);\n    \n    p = ro;; t = 0.; hit = false;\n    \n    for(float i = 0.; i < 150.; i++){\n    \td = map(p)*dith;\n        float eps = 0.001 + 0.001*5.0*pow(float(i)/200.0,2.0);\n        if(d.x < eps){\n            t += 0.005;\n        }\n        \n    \tt += d.x;\n        p = ro + rd*t;\n    }\n    return d;\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    return normalize(dir + right*uv.x + up*uv.y);\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.001, 0.);\n    return -normalize(vec3(\n        map(p - t.xyy).x - map(p + t.xyy).x,\n        map(p - t.yxy).x - map(p + t.yxy).x,\n        map(p - t.yyx).x - map(p + t.yyx).x\n    ));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    uv *= rot(sin(iTime*0.5)*0.6);\n    \n    uv *= 1. - dot(uv,uv)*.1;\n    \n    dith = mix(0.95,1.,texture(iChannel0,iResolution.xy*(uv + iTime*10.)/256.).x);\n    \n    vec3 col = vec3(0);\n\n\tvec3 ro = vec3(0);\n    \n    ro.z += iTime*1.7;\n    \n    ro += path(ro.z);\n    \n    vec3 lookAt = vec3(0);\n    lookAt.z = ro.z + 2.;\n    lookAt += path(lookAt.z + .5);\n    \n    vec3 rd = getRd(ro, lookAt,uv);\n    \n    \n    vec3 p; float t; bool hit;\n    vec2 d = march(ro, rd, p, t, hit);\n    \n    col += glow*0.001;\n    \n    vec3 fc = pal(0.6,0.5,vec3(1.,0.5,0.6) + cos(rd.xyz)*1., 1.7  - dot(uv,uv)*0.2,-2.1 - dot(uv,uv)*0.2);\n    fc = max(fc,0.);\n    col = mix(col,fc, smoothstep(0.,1.,t*0.1));\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdBcRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[266, 266, 323, 323, 1363]], "test": "untested"}
{"id": "wdSyzw", "name": "Simple Color Circle", "author": "nickcody", "description": "Click and drag to expand/contract circle radius. Its the default color cycle for shadertoy in a circle boundary.", "tags": ["geometry", "basics"], "likes": 0, "viewed": 287, "published": 3, "date": "1586289330", "time_retrieved": "2024-07-30T21:14:20.066697", "image_code": "vec3 white = vec3(1.0, 1.0, 1.0);\nvec3 black = vec3(0.0, 0.0, 0.0);\nconst float R = 40.;\nconst float pixelWidth = 1.;\nconst float thickness = .5;\n\n//\n// coord - pixel to test\n// center - center of circle\n// radius - radius of circle\n// tolerance - thickness of circle line\nvec3 test(vec2 coord, vec2 center, float radius, float thickness) {\n    float dist_to_center = sqrt(pow(coord.x - center.x, 2.) + pow(coord.y - center.y, 2.));\n    float delta = dist_to_center-radius;\n\n    vec2 uv = gl_FragCoord.xy/iResolution.xy;\n    vec3 inside = .5 + .5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float blend = smoothstep(0., pixelWidth, abs(delta) - thickness);\n    if (delta == 0.) {\n        return black;\n    } else if (delta  < 0.) {\n        return mix(white, inside, blend);\n    } else if (delta  > 0.) {\n        return mix(white, black, blend);\n    }\n        \n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord) {\n\tvec2 center = iResolution.xy/2.;\n    float r;\n    \n    if (iMouse.xy == vec2(0) ) r = R; else r = distance(center, iMouse.xy);\n        \n    vec3 c = test(gl_FragCoord.xy.xy, center, r, thickness);\n\t\n    out_color = vec4(c, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSyzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 273, 340, 340, 857], [859, 859, 911, 911, 1142]], "test": "untested"}
{"id": "ltXyD7", "name": "Geode", "author": "KilledByAPixel", "description": "Continuing experiments with my pixel zoom code to make cool endless zooming fractals.", "tags": ["fractal", "zoom", "recursion"], "likes": 8, "viewed": 429, "published": 3, "date": "1586285596", "time_retrieved": "2024-07-30T21:14:21.057050", "image_code": "//////////////////////////////////////////////////////////////////////////////////\n// Eye of God Zoom - Copyright 2017 Frank Force\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\nconst float zoomSpeed\t\t\t= 10.0;\t// how fast to zoom (negative to zoom out)\nconst float zoomScale\t\t\t= 0.00001;\t// how much to multiply overall zoom (closer to zero zooms in)\nconst int recursionCount\t\t= 8;\t// how deep to recurse\nconst int glyphSize\t\t\t\t= 3;\t// width & height of glyph in pixels\nconst float curvature\t\t\t= -16.0;\t// time warp to add curvature\n\n//////////////////////////////////////////////////////////////////////////////////\n// Precached values and math\n\nconst float glyphSizeF = float(glyphSize);\nconst float glyphSizeLog = log(glyphSizeF);\n\nconst float e = 2.718281828459;\nconst float pi = 3.14159265359;\nfloat RandFloat(int i) { return (fract(sin(float(i)) * 43758.5453)); }\nint RandInt(int i) { return int(100000.0*RandFloat(i)); }\n\nvec3 HsvToRgb(vec3 c) \n{\n    float s = c.y * c.z;\n    float s_n = c.z - s * .5;\n    return vec3(s_n) + vec3(s) * cos(2.0 * pi * (c.x + vec3(1.0, 0.6666, .3333)));\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Color and image manipulation\n\nfloat GetRecursionFade(int r, float timePercent)\n{\n    if (r > recursionCount)\n        return timePercent;\n    \n    // fade in and out recusion\n    float rt = max(float(r) - timePercent, 0.0);\n    float rc = float(recursionCount);\n    return rt / rc;\n}\n\nvec3 InitPixelColor() { return vec3(0); }\nvec3 CombinePixelColor(vec3 color, float timePercent, int i, int r, vec2 pos, ivec2 glyphPos, ivec2 glyphPosLast)\n{\n    i = (i+r) + (glyphPosLast.y + glyphPos.y);\n\n    vec3 myColor = vec3\n    (\n    \tmix(-0.05, 0.05, RandFloat(i)),\n    \tmix(0.0, 0.2, RandFloat(i + 10)),\n        mix(0.0, 0.2, RandFloat(i + 20))\n    );\n\n    // combine with my color\n    float f = GetRecursionFade(r, timePercent);\n    //myColor.y = pow(myColor.y, 2.0);\n    //myColor.z = pow(myColor.z, 2.0);\n    color += myColor*f;\n    return color;\n}\n\nvec3 FinishPixel(vec3 color, vec2 uv)\n{\n    // color wander\n    color.x += 0.01*iTime;\n    \n    // convert to rgb\n    color = HsvToRgb(color);\n    return color;\n}\n\nvec2 InitUV(vec2 uv)\n{\n    // spin\n    float theta = pi/2.0;//0.05*iTime;\n\tfloat c = cos(theta);\n\tfloat s = sin(theta);\n\tuv = vec2((uv.x*c - uv.y*s), (uv.x*s + uv.y*c));\n    \n\t// wave\n\tuv.x += 0.05*sin(10.0*uv.y + 0.17*iTime);\n\tuv.y += 0.05*sin(10.0*uv.x + 0.13*iTime);\n\tuv.x += 0.2*sin(1.0*uv.y + 0.31*iTime);\n\tuv.y += 0.2*sin(1.0*uv.x + 0.27*iTime);\n    return uv;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////\n// Fractal functions\n\nivec2 GetFocusPos(int i) { return ivec2(glyphSize/2); }\n      \n// get color of pos, where pos is 0-1 point in the glyph\nvec3 GetPixelFractal(vec2 pos, int iterations, float timePercent)\n{\n\tivec2 glyphPosLast = GetFocusPos(-2);\n\tivec2 glyphPos =     GetFocusPos(-1);\n\tvec3 color = InitPixelColor();\n    \n\tfor (int r = 0; r <= recursionCount + 1; ++r)\n\t{\n        color = CombinePixelColor(color, timePercent, iterations, r, pos, glyphPos, glyphPosLast);\n        if (r > recursionCount)\n\t\t\treturn color;\n           \n        // update pos\n        pos *= glyphSizeF;\n\n        // get glyph and pos within that glyph\n        glyphPosLast = glyphPos;\n        glyphPos = ivec2(pos);\n        \n        // next glyph\n\t\tpos -= vec2(floor(pos));\n\t}\n}\n \n//////////////////////////////////////////////////////////////////////////////////\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// use square aspect ratio\n\tvec2 uv = fragCoord;\n\tuv = fragCoord / iResolution.y;\n\tuv -= vec2(0.5*iResolution.x / iResolution.y, 0.5);\n    uv = InitUV(uv);\n    \n    // time warp\n    float time = iTime + curvature*pow(length(uv), 0.2);\n    \n\t// get time \n\tfloat timePercent = time*zoomSpeed;\n\tint iterations = int(floor(timePercent));\n\ttimePercent -= float(iterations);\n\t\n\t// update zoom, apply pow to make rate constant\n\tfloat zoom = pow(e, -glyphSizeLog*timePercent);\n\tzoom *= zoomScale;\n    \n\t// get offset\n\tvec2 offset = vec2(0);\n    const float gsfi = 1.0 / glyphSizeF;\n\tfor (int i = 0; i < 13; ++i)\n\t\toffset += (vec2(GetFocusPos(i)) * gsfi) * pow(gsfi,float(i));\n    \n\t// apply zoom & offset\n    vec2 uvFractal = uv * zoom + offset;\n\t\n\t// check pixel recursion depth\n\tvec3 pixelFractalColor = GetPixelFractal(uvFractal, iterations, timePercent);\n    pixelFractalColor = FinishPixel(pixelFractalColor, uv);\n    \n\t// apply final color\n\tfragColor = vec4(pixelFractalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltXyD7.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[923, 923, 947, 947, 993], [994, 994, 1014, 1014, 1051], [1053, 1053, 1077, 1077, 1217], [1335, 1335, 1385, 1385, 1587], [1589, 1589, 1612, 1612, 1630], [1631, 1631, 1746, 1746, 2148], [2150, 2150, 2189, 2209, 2312], [2314, 2314, 2336, 2348, 2682], [2790, 2790, 2816, 2816, 2845], [2853, 2910, 2977, 2977, 3526], [3614, 3614, 3671, 3699, 4655]], "test": "untested"}
{"id": "3sSczw", "name": "Meow II", "author": "michael0884", "description": "Correctly ray marching a cat mesh, meow.", "tags": ["triangles", "marching", "graph", "mesh"], "likes": 8, "viewed": 436, "published": 3, "date": "1586274015", "time_retrieved": "2024-07-30T21:14:22.205978", "image_code": "//Graph is in Buf A, graph traversal is in Buf B\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    fragColor = texel(ch1, pos);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define N ivec2(5,92)\n#define sN ivec2(64,3)\n#define dt 0.\n\n#define loop(x) for(int i = min(0, iFrame); i < x; i++)\n\nconst int tot_n = N.x*N.y;\n\nivec2 i2xy(ivec3 sid)\n{\n    return sN*ivec2(sid.x%N.x, sid.x/N.x) + sid.yz;\n}\n\nivec3 xy2i(ivec2 p)\n{\n    ivec2 pi = p/sN;\n    return ivec3(pi.x + pi.y*N.x, p.x%sN.x, p.y%sN.y);\n}\n\nfloat F(float d)\n{\n    return 1./(0.1*d*d+1.) - 1.*exp(-1.*d);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nconst int k = 1664525;  \n\nivec4 hash( ivec4 x )\n{\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    return ivec4(x);\n}\n\n#define link0 64\n\nconst float PHI = 0.5*(sqrt(5.) + 1.);\n\nvec2 inverseSF( vec3 p, float n ) \n{\n    float m = 1.0 - 1.0/n;\n    \n    float phi = min(atan(p.y, p.x), PI), cosTheta = p.z;\n    \n    float k  = max(2.0, floor( log(n * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))/ log(PHI+1.0)));\n    float Fk = pow(PHI, k)/sqrt(5.0);\n    vec2  F  = vec2( round(Fk), round(Fk * PHI) ); // k, k+1\n\n    vec2 ka = 2.0*F/n;\n    vec2 kb = 2.0*PI*( fract((F+1.0)*PHI) - (PHI-1.0) );    \n    \n    mat2 iB = mat2( ka.y, -ka.x, \n                    kb.y, -kb.x ) / (ka.y*kb.x - ka.x*kb.y);\n    \n    vec2 c = floor( iB * vec2(phi, cosTheta - m));\n    float d = 8.0;\n    float j = 0.0;\n    for( int s=0; s<4; s++ ) \n    {\n        vec2 uv = vec2( float(s-2*(s/2)), float(s/2) );\n        \n        float i = dot(F, uv + c); // all quantities are ingeters (can take a round() for extra safety)\n        \n        float phi = 2.0*PI*fract(i*PHI);\n        float cosTheta = m - 2.0*i/n;\n        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n        \n        vec3 q = vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta );\n        float squaredDistance = dot(q-p, q-p);\n        if (squaredDistance < d) \n        {\n            d = squaredDistance;\n            j = i;\n        }\n    }\n    return vec2( j, sqrt(d) );\n}\n\nvec4 iSF( vec3 p, float n ) \n{\n    float m = 1.0 - 1.0/n;\n    \n    float phi = min(atan(p.y, p.x), PI), cosTheta = p.z;\n    \n    float k  = max(2.0, floor( log(n * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))/ log(PHI+1.0)));\n    float Fk = pow(PHI, k)/sqrt(5.0);\n    vec2  F  = vec2( round(Fk), round(Fk * PHI) ); // k, k+1\n\n    vec2 ka = 2.0*F/n;\n    vec2 kb = 2.0*PI*( fract((F+1.0)*PHI) - (PHI-1.0) );    \n    \n    mat2 iB = mat2( ka.y, -ka.x, \n                    kb.y, -kb.x ) / (ka.y*kb.x - ka.x*kb.y);\n    \n    vec2 c = floor( iB * vec2(phi, cosTheta - m));\n    float d = 8.0;\n    float j = 0.0;\n    vec4 o;\n    for( int s=0; s<4; s++ ) \n    {\n        vec2 uv = vec2( float(s-2*(s/2)), float(s/2) );\n        \n        o[s] = dot(F, uv + c); \n    }\n    return o;\n}\n\nvec3 fibonacci_sphere(int i, int n)\n{\n    vec2 pt = vec2(2.*PI*mod(float(i)/PHI, 1.), acos(1. - float(2*i+1)/float(n)));\n    return vec3(cos(pt.x)*sin(pt.y), sin(pt.x)*sin(pt.y), cos(pt.y)); \n}\n\n    \nstruct object\n{\n    int id;\n    vec3 X;\n    float bR;\n    vec3 a;\n    vec3 b;\n    vec3 c;\n};\n\nvec3 qtransform(vec4 q, vec3 v)\n{ \n\treturn v + 2.0*cross(cross(v, q.xyz) + q.w*v, q.xyz);\n} \n\n//intersection with the bisector plane\nfloat rayBisectDist(vec3 p, vec3 d, vec3 a, vec3 b)\n{\n    vec3 n = b - a;\n    float D = length(n);\n    float cosnd = dot(n, d)/D; //ray plane normal angle cosine\n    float l = D*.5 - dot(p - a, n)/D;\n    float t = l/cosnd; //ray parameter\n    return (cosnd>0.)?t:1e10;\n}\n\nfloat dirBisectDist(vec3 d, vec3 a, vec3 b, float dist)\n{\n    float cosnd = dot(normalize(b - a), d); //ray plane normal angle cosine\n    return (cosnd>0.)?(dist*.5)/cosnd:1e10;\n}\n\n//iq's triangle sdf \nfloat dot2( vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat bisectDist(vec3 p, vec3 a, vec3 b)\n{\n    return distance(a,b)*0.5 - dot(p - a, normalize(b - a));\n}\n\nfloat sdObj(vec3 p, in object o)\n{\n    float d = distance(p, o.X);\n    if(d > 1.5*o.bR) return d - o.bR; //outside 1.5x bounding sphere\n    return udTriangle(p, o.a, o.b, o.c) - 0.005;\n}", "buffer_a_code": "//triangle and triangle neighbor directional graph buffer \n\nvec3[] vertecies = vec3[](\nvec3(-995.8304  ,  75.5037  ,   -608.4150),\nvec3(-992.0101  ,  115.6586 ,    -568.2448),\nvec3(-948.9031  ,  122.7461 ,    -586.1746),\nvec3(-808.0504  ,  82.2768  ,   -504.0376),\nvec3(-829.8732  ,  90.4546  ,   -495.4801),\nvec3(-815.5106  ,  55.3138  ,   -483.6030),\nvec3(-827.6768  ,  4.7252   ,   -550.7932),\nvec3(-926.4594  ,  -11.3236 ,    -509.0985),\nvec3(-924.9203  ,  4.9779   ,   -555.2147),\nvec3(-699.9360  ,  47.5303  ,   -579.6901),\nvec3(-725.3939  ,  13.6954  ,   -604.4670),\nvec3(-739.4488  ,  72.5684  ,   -610.5344),\nvec3(-1034.0753 ,  -11.3236 ,    -534.3847),\nvec3(-1060.0525 ,  17.3272  ,   -541.3537),\nvec3(-1038.5428 ,  29.1891  ,   -575.5334),\nvec3(-1000.9319 ,  78.8761  ,   -383.3885),\nvec3(-930.1043  ,  71.7035  ,   -351.5857),\nvec3(-920.2565  ,  109.7136 ,    -404.0531),\nvec3(-702.3473  ,  16.8526  ,    -571.5159),\nvec3(-728.9493  ,  -11.3236 ,    -558.9595),\nvec3(-724.4047  ,  -11.3236 ,    -589.9592),\nvec3(-717.2055  ,  41.9075  ,   -502.3305),\nvec3(-735.5786  ,  47.5303  ,   -491.1331),\nvec3(-733.9127  ,  18.3676  ,   -496.1548),\nvec3(-733.9399  ,  96.2936  ,   -552.8721),\nvec3(-694.6128  ,  66.2405  ,   -544.0293),\nvec3(-727.1962  ,  94.3858  ,   -574.8710),\nvec3(-925.7615  ,  126.6104 ,    -513.3122),\nvec3(-853.2005  ,  115.3310 ,    -545.4424),\nvec3(-894.0300  ,  131.5131 ,    -564.8028),\nvec3(-790.0053  ,  -4.9984  ,   -523.5698),\nvec3(-788.1220  ,  -4.3065  ,   -488.5588),\nvec3(-795.1429  ,  6.2171   ,   -449.4353),\nvec3(-840.2600  ,  20.1157  ,   -360.7992),\nvec3(-841.6091  ,  -1.1064  ,   -353.7490),\nvec3(-798.4716  ,  -11.3236 ,    -394.9299),\nvec3(-836.6793  ,  74.1277  ,   -450.3682),\nvec3(-832.0030  ,  64.3311  ,   -416.8673),\nvec3(-815.2516  ,  34.6305  ,   -481.9950),\nvec3(-832.3073  ,  9.2289   ,   -452.2656),\nvec3(-789.5191  ,  55.1783  ,   -621.8122),\nvec3(-795.7584  ,  20.4113  ,   -616.7018),\nvec3(-853.6783  ,  -11.3236 ,    -657.0101),\nvec3(-814.8730  ,  -5.0179  ,   -583.5240),\nvec3(-1012.5013 ,  -11.3236 ,    -419.7687),\nvec3(-990.1320  ,  -1.7048  ,   -373.5935),\nvec3(-1004.2960 ,  44.1512  ,   -365.5110),\nvec3(-855.9658  ,  10.3450  ,   -380.9660),\nvec3(-803.1211  ,  -11.3236 ,    -401.7929),\nvec3(-906.3935  ,  -0.5085  ,   -358.5250),\nvec3(-957.7062  ,  114.9286 ,    -436.9630),\nvec3(-977.6108  ,  130.2673 ,    -533.3871),\nvec3(-738.3090  ,  5.0845   ,   -507.1984),\nvec3(-709.8657  ,  -11.3236 ,    -526.8616),\nvec3(-710.5553  ,  1.5324   ,   -511.1166),\nvec3(-747.3311  ,  0.0296   ,   -472.9264),\nvec3(-749.3085  ,  11.8466  ,   -475.1376),\nvec3(-792.2325  ,  17.3739  ,   -396.8396),\nvec3(-878.4414  ,  35.7717  ,   -642.8316),\nvec3(-989.6032  ,  17.0865  ,   -621.6263),\nvec3(-944.0946  ,  58.0384  ,   -642.5948),\nvec3(-851.3480  ,  63.6161  ,   -648.0112),\nvec3(-785.4418  ,  72.5684  ,   -496.2609),\nvec3(-793.9230  ,  105.7400 ,    -489.6239),\nvec3(-805.3693  ,  49.2849  ,   -493.7585),\nvec3(-707.0358  ,  66.2405  ,   -513.1634),\nvec3(-781.2529  ,  20.6106  ,   -610.5267),\nvec3(-752.0867  ,  49.2849  ,   -626.1438),\nvec3(-764.1007  ,  4.7729   ,   -624.7463),\nvec3(-782.7896  ,  109.1638 ,    -561.5859),\nvec3(-755.0754  ,  109.5690 ,    -604.1262),\nvec3(-778.0606  ,  97.3133  ,   -596.8195),\nvec3(-1035.4617 ,  94.9357  ,   -465.6595),\nvec3(-962.6334  ,  117.6223 ,    -475.3002),\nvec3(-1042.7870 ,  48.9679  ,   -403.3333),\nvec3(-1073.9026 ,  52.3123  ,   -485.0486),\nvec3(-1056.9429 ,  9.7043   ,   -458.5848),\nvec3(-768.6208  ,  -8.2751  ,   -504.6131),\nvec3(-771.2246  ,  5.6477   ,   -497.4490),\nvec3(-706.1431  ,  -11.3236 ,    -536.1108),\nvec3(-695.7332  ,  1.5324   ,   -547.9435),\nvec3(-699.7588  ,  -1.4693  ,   -532.1415),\nvec3(-703.2778  ,  44.4115  ,   -511.2145),\nvec3(-690.5525  ,  44.4115  ,   -542.8315),\nvec3(-806.4027  ,  26.4766  ,   -417.1291),\nvec3(-779.1372  ,  17.1613  ,   -493.2779),\nvec3(-882.1035  ,  74.7240  ,   -366.3839),\nvec3(-821.3383  ,  74.7946  ,   -638.8068),\nvec3(-867.0529  ,  24.4554  ,   -668.6847),\nvec3(-784.6449  ,  106.3202 ,    -578.2576),\nvec3(-831.2065  ,  104.9587 ,    -620.3184),\nvec3(-783.5483  ,  7.4472   ,   -469.5750),\nvec3(-764.3502  ,  -11.3236 ,    -481.8925),\nvec3(-792.4278  ,  -8.2995  ,   -418.0562),\nvec3(-743.1558  ,  106.7015 ,    -584.4225),\nvec3(-685.2125  ,  17.4394  ,   -530.0173),\nvec3(-697.9792  ,  37.3655  ,   -539.4918),\nvec3(-690.5497  ,  17.4394  ,   -516.7567),\nvec3(-712.0912  ,  13.6706  ,   -585.8790),\nvec3(-996.4185  ,  -11.3236 ,    -539.4856),\nvec3(-1024.4155 ,  0.8627   ,   -577.6360),\nvec3(-798.4020  ,  1.7822   ,   -616.4513),\nvec3(-829.1520  ,  -11.3236 ,    -598.7313),\nvec3(-873.5256  ,  -0.4193  ,   -622.8918),\nvec3(-728.0101  ,  64.0319  ,   -495.0735),\nvec3(-744.3813  ,  95.5499  ,   -520.9390),\nvec3(-761.2942  ,  88.9008  ,   -508.1789),\nvec3(-781.7170  ,  26.8159  ,   -493.0542),\nvec3(-901.6669  ,  -11.3236 ,    -398.2102),\nvec3(-767.1221  ,  11.5533  ,   -493.6247),\nvec3(-751.5170  ,  13.1415  ,   -492.4418),\nvec3(-780.6548  ,  14.4846  ,   -472.4714),\nvec3(-1060.7682 ,  61.4407  ,   -446.4903),\nvec3(-1051.7577 ,  95.4428  ,   -514.2819),\nvec3(-1039.2488 ,  61.4143  ,   -568.5452),\nvec3(-854.7079  ,  94.0548  ,   -504.5181),\nvec3(-929.0150  ,  119.9958 ,    -442.1982),\nvec3(-864.1474  ,  97.4144  ,   -420.7776),\nvec3(-870.3384  ,  96.9634  ,   -459.3782),\nvec3(-780.8250  ,  4.2498   ,   -601.9772),\nvec3(-741.7265  ,  -11.3236 ,    -599.0881),\nvec3(-721.0571  ,  7.8997   ,   -601.0405),\nvec3(-703.8851  ,  -1.0353  ,   -617.8672),\nvec3(-942.1671  ,  7.3515   ,   -341.2048),\nvec3(-921.3945  ,  19.8009  ,   -333.6794),\nvec3(-943.1711  ,  -11.3236 ,    -350.5991),\nvec3(-838.6180  ,  27.0678  ,   -411.9889),\nvec3(-863.2388  ,  18.6852  ,   -406.0000),\nvec3(-814.4047  ,  16.0976  ,   -411.6389),\nvec3(-694.4426  ,  41.9075  ,   -558.8868),\nvec3(-710.5289  ,  22.1320  ,   -509.3748),\nvec3(-706.3202  ,  37.3655  ,   -518.7678),\nvec3(-696.0511  ,  42.0174  ,   -536.3110),\nvec3(-1036.4375 ,  -11.3236 ,    -459.7409),\nvec3(-770.0264  ,  106.7015 ,    -517.6603),\nvec3(-792.2722  ,  109.5690 ,    -511.7077),\nvec3(-779.3687  ,  119.6276 ,    -475.8542),\nvec3(-758.4063  ,  103.6384 ,    -502.1507),\nvec3(-784.4563  ,  107.8258 ,    -494.3299),\nvec3(-783.4283  ,  78.5575  ,   -513.7649),\nvec3(-883.1703  ,  -3.6364  ,   -655.2727),\nvec3(-730.2901  ,  88.9008  ,   -585.2112),\nvec3(-697.2075  ,  64.0319  ,   -571.6052),\nvec3(-750.1225  ,  78.5575  ,   -596.5160),\nvec3(-737.4004  ,  107.8258 ,    -611.2444),\nvec3(-724.0314  ,  103.6384 ,    -587.5582),\nvec3(-782.6500  ,  -11.3236 ,    -570.2200),\nvec3(-900.4669  ,  96.2424  ,   -633.2571),\nvec3(-897.0970  ,  120.3056 ,    -610.5399),\nvec3(-833.9095  ,  115.4948 ,    -598.8503),\nvec3(-853.0287  ,  122.5423 ,    -581.7062),\nvec3(-759.3208  ,  -11.3236 ,    -457.8283),\nvec3(-742.3607  ,  -11.3236 ,    -526.3356),\nvec3(-694.5074  ,  22.1320  ,   -549.1814),\nvec3(-839.2968  ,  22.8362  ,   -391.3108),\nvec3(-820.5211  ,  30.1974  ,   -389.5576),\nvec3(-829.5941  ,  38.5166  ,   -409.1643),\nvec3(-836.8793  ,  47.4207  ,   -386.5396),\nvec3(-869.9812  ,  46.1542  ,   -482.3823),\nvec3(-890.2067  ,  70.0660  ,   -483.5094),\nvec3(-909.9105  ,  98.4824  ,   -473.5333),\nvec3(-937.6815  ,  103.8339 ,    -483.5974),\nvec3(-804.8950  ,  95.6823  ,   -518.2141),\nvec3(-829.9017  ,  105.1277 ,    -539.1833),\nvec3(-733.7024  ,  -11.3236 ,    -611.5656),\nvec3(-738.7223  ,  10.7529  ,   -610.3510),\nvec3(-720.5469  ,  -9.4244  ,   -620.4963),\nvec3(-945.2722  ,  87.9113  ,   -629.4183),\nvec3(-995.0536  ,  46.6390  ,   -622.5880),\nvec3(-707.1171  ,  0.0891   ,   -521.4265),\nvec3(-701.2590  ,  1.7814   ,   -528.7713),\nvec3(-696.3574  ,  18.3020  ,   -516.0935),\nvec3(-705.5143  ,  32.6190  ,   -518.7469),\nvec3(-746.8992  ,  89.1834  ,   -623.5667),\nvec3(-774.1794  ,  85.3090  ,   -610.5543),\nvec3(-749.5588  ,  79.4633  ,   -607.6957),\nvec3(-735.9028  ,  86.8596  ,   -621.5189),\nvec3(-796.1419  ,  90.7038  ,   -608.0107),\nvec3(-1030.2487 ,  110.2389 ,    -493.4697),\nvec3(-984.0498  ,  122.4129 ,    -486.0958),\nvec3(-1026.7104 ,  102.5003 ,    -546.5026),\nvec3(-790.7665  ,  79.4633  ,   -505.3118),\nvec3(-790.4939  ,  86.8596  ,   -485.8827),\nvec3(-772.3555  ,  -4.7332  ,   -484.7859),\nvec3(-770.9318  ,  12.4502  ,   -486.0145),\nvec3(-896.9176  ,  -11.3236 ,    -454.9405),\nvec3(-770.0953  ,  -11.3236 ,    -537.9039),\nvec3(-692.3391  ,  11.6189  ,   -522.3785),\nvec3(-688.5785  ,  13.9763  ,   -545.0641),\nvec3(-874.0591  ,  -11.3236 ,    -597.7254),\nvec3(-950.8364  ,  118.9327 ,    -489.5284),\nvec3(-830.0552  ,  34.2774  ,   -389.5935),\nvec3(-711.2487  ,  -11.3236 ,    -613.0066),\nvec3(-704.1648  ,  -6.0835  ,   -597.8587),\nvec3(-806.8093  ,  28.4912  ,   -497.3588),\nvec3(-697.3834  ,  32.6190  ,   -538.9485),\nvec3(-1069.4880 ,  24.5603  ,   -494.2723),\nvec3(-973.8975  ,  -1.5557  ,   -607.4702),\nvec3(-997.2460  ,  -11.3236 ,    -558.3713),\nvec3(-688.9415  ,  18.3020  ,   -534.5188),\nvec3(-871.4866  ,  -11.3236 ,    -650.8430),\nvec3(-793.2932  ,  109.4704 ,    -565.8134),\nvec3(-800.0500  ,  103.8140 ,    -523.6841),\nvec3(-736.8707  ,  111.9007 ,    -616.0329),\nvec3(-729.2321  ,  106.4699 ,    -623.9708),\nvec3(-720.9323  ,  119.6276 ,    -621.0443),\nvec3(-800.4397  ,  14.8650  ,   -433.0968),\nvec3(-710.6121  ,  -11.3236 ,    -601.5969),\nvec3(-736.1279  ,  -4.1757  ,   -606.0648),\nvec3(-783.3688  ,  5.3768   ,   -498.0137),\nvec3(-703.4008  ,  13.9763  ,   -508.2369),\nvec3(-787.3816  ,  106.4699 ,    -479.4933),\nvec3(-869.6447  ,  -11.3236 ,    -352.0651),\nvec3(-849.2291  ,  -11.3236 ,    -613.3991),\nvec3(-715.2297  ,  1.1529   ,    -625.7358),\nvec3(-843.8202  ,  -11.3236 ,    -359.5085),\nvec3(-892.2355  ,  102.2551 ,    -392.7515),\nvec3(-748.9401  ,  -11.3236 ,    -575.4650),\nvec3(-778.8455  ,  -11.3236 ,    -431.0151),\nvec3(-922.5539  ,  -11.3236 ,    -344.4546));\n\n\nint triz = 459;\n\n    \nint[] triangles = int[](459, 460, 461,\n\n\n462, 463, 464, \n465, 466, 467, \n468, 469, 470, \n471, 472, 473, \n474, 475, 476, \n477, 478, 479, \n480, 481, 482, \n483, 484, 485, \n486, 487, 488, \n489, 490, 491, \n492, 493, 494, \n495, 496, 497, \n498, 466, 465, \n499, 500, 501, \n465, 467, 502, \n503, 504, 505, \n506, 507, 508, \n476, 509, 474, \n486, 488, 510, \n511, 512, 513, \n514, 515, 516, \n517, 518, 519, \n519, 520, 517, \n521, 522, 523, \n484, 483, 524, \n525, 526, 527, \n528, 529, 530, \n526, 525, 499, \n531, 474, 532, \n533, 534, 535, \n536, 537, 489, \n538, 539, 540, \n524, 541, 542, \n496, 543, 544, \n545, 475, 492, \n546, 547, 520, \n548, 530, 549, \n550, 551, 552, \n552, 491, 550, \n462, 523, 522, \n553, 528, 483, \n493, 492, 475, \n554, 555, 556, \n557, 469, 468, \n466, 558, 467, \n518, 559, 473, \n560, 561, 501, \n562, 518, 517, \n470, 469, 526, \n528, 553, 529, \n563, 564, 565, \n521, 566, 481, \n508, 567, 506, \n568, 481, 566, \n569, 570, 543, \n571, 572, 534, \n573, 472, 572, \n574, 487, 486, \n575, 576, 577, \n578, 527, 579, \n580, 557, 581, \n505, 582, 583, \n493, 583, 584, \n498, 585, 586, \n507, 506, 587, \n477, 468, 588, \n542, 484, 524, \n480, 482, 589, \n590, 556, 591, \n497, 496, 544, \n566, 521, 523, \n471, 592, 472, \n593, 594, 595, \n596, 597, 598, \n599, 562, 517, \n547, 499, 501, \n600, 601, 470, \n602, 603, 604, \n579, 605, 578, \n502, 578, 605, \n549, 606, 607, \n548, 608, 609, \n610, 611, 511, \n539, 538, 477, \n477, 588, 612, \n613, 614, 587, \n615, 587, 543, \n543, 496, 615, \n616, 615, 496, \n495, 617, 618, \n619, 620, 575, \n621, 622, 574, \n594, 593, 528, \n623, 624, 625, \n461, 626, 459, \n627, 519, 518, \n513, 628, 629, \n630, 631, 589, \n632, 633, 529, \n603, 634, 635, \n636, 546, 549, \n526, 499, 636, \n510, 637, 638, \n573, 639, 460, \n492, 616, 545, \n614, 516, 515, \n640, 641, 521, \n521, 563, 565, \n576, 575, 476, \n576, 545, 616, \n544, 537, 568, \n642, 643, 537, \n537, 643, 568, \n491, 490, 550, \n498, 586, 644, \n502, 605, 465, \n536, 489, 645, \n646, 513, 629, \n647, 646, 540, \n502, 467, 648, \n574, 649, 620, \n618, 617, 574, \n510, 488, 461, \n607, 609, 608, \n512, 511, 611, \n517, 547, 599, \n520, 547, 517, \n509, 532, 474, \n620, 532, 509, \n650, 613, 615, \n613, 586, 585, \n505, 583, 475, \n475, 583, 493, \n469, 625, 624, \n526, 469, 624, \n651, 581, 652, \n623, 625, 651, \n653, 497, 566, \n462, 464, 523, \n591, 556, 555, \n612, 588, 654, \n475, 474, 505, \n533, 474, 531, \n590, 591, 541, \n631, 480, 589, \n534, 572, 472, \n655, 535, 534, \n656, 467, 657, \n467, 656, 648, \n656, 657, 471, \n511, 513, 482, \n515, 569, 614, \n646, 647, 658, \n612, 654, 658, \n524, 564, 563, \n563, 541, 524, \n501, 599, 547, \n562, 599, 659, \n596, 595, 597, \n595, 594, 522, \n470, 526, 632, \n633, 632, 526, \n543, 570, 544, \n490, 544, 570, \n537, 536, 642, \n602, 600, 470, \n470, 635, 634, \n639, 637, 510, \n531, 572, 571, \n492, 614, 650, \n614, 613, 650, \n596, 565, 564, \n564, 528, 593, \n660, 609, 487, \n487, 661, 660, \n662, 663, 635, \n664, 529, 553, \n604, 600, 602, \n483, 485, 553, \n491, 498, 489, \n585, 498, 665, \n598, 565, 596, \n521, 565, 598, \n538, 540, 628, \n661, 622, 621, \n594, 621, 522, \n484, 542, 601, \n601, 485, 484, \n466, 498, 644, \n617, 464, 463, \n497, 617, 495, \n652, 479, 666, \n510, 638, 486, \n486, 649, 574, \n533, 505, 474, \n505, 533, 503, \n516, 494, 514, \n624, 667, 527, \n624, 527, 526, \n490, 668, 544, \n489, 668, 490, \n636, 549, 530, \n529, 633, 530, \n589, 482, 513, \n513, 646, 669, \n518, 562, 656, \n559, 518, 656, \n460, 459, 573, \n473, 627, 518, \n499, 525, 500, \n578, 502, 500, \n606, 549, 520, \n546, 520, 549, \n630, 669, 646, \n646, 554, 556, \n665, 587, 585, \n552, 587, 665, \n494, 516, 492, \n614, 492, 516, \n635, 663, 603, \n603, 664, 604, \n597, 670, 641, \n641, 640, 597, \n652, 581, 557, \n652, 557, 479, \n520, 519, 606, \n459, 626, 519, \n477, 612, 539, \n540, 539, 647, \n671, 508, 507, \n499, 547, 546, \n499, 546, 636, \n659, 672, 562, \n562, 648, 656, \n465, 489, 498, \n645, 489, 465, \n581, 673, 580, \n673, 581, 651, \n561, 502, 648, \n560, 502, 561, \n667, 624, 623, \n576, 496, 495, \n616, 496, 576, \n567, 644, 586, \n506, 567, 586, \n643, 570, 569, \n643, 642, 550, \n609, 607, 488, \n609, 488, 487, \n588, 601, 542, \n588, 542, 555, \n493, 674, 494, \n584, 674, 493, \n531, 532, 638, \n638, 649, 486, \n476, 675, 576, \n475, 675, 476, \n600, 485, 601, \n485, 600, 604, \n510, 460, 639, \n461, 460, 510, \n514, 511, 515, \n515, 511, 569, \n543, 614, 569, \n614, 543, 587, \n579, 676, 605, \n575, 509, 476, \n509, 575, 620, \n551, 677, 552, \n636, 633, 526, \n636, 530, 633, \n535, 503, 533, \n541, 563, 480, \n590, 541, 480, \n630, 556, 590, \n630, 646, 556, \n528, 660, 661, \n530, 548, 528, \n477, 538, 478, \n607, 608, 549, \n549, 608, 548, \n482, 481, 568, \n482, 568, 511, \n501, 500, 560, \n500, 502, 560, \n582, 505, 504, \n503, 584, 504, \n617, 497, 464, \n523, 464, 497, \n544, 668, 537, \n489, 537, 668, \n615, 585, 587, \n585, 615, 613, \n641, 522, 521, \n641, 670, 522, \n618, 619, 495, \n495, 577, 576, \n661, 621, 594, \n661, 594, 528, \n557, 477, 479, \n557, 468, 477, \n630, 589, 669, \n513, 669, 589, \n501, 659, 599, \n506, 586, 613, \n506, 613, 587, \n635, 470, 632, \n635, 632, 662, \n463, 462, 621, \n522, 621, 462, \n497, 653, 523, \n566, 523, 653, \n671, 678, 508, \n567, 508, 678, \n492, 650, 616, \n615, 616, 650, \n491, 552, 665, \n491, 665, 498, \n569, 511, 568, \n568, 643, 569, \n470, 601, 468, \n588, 468, 601, \n667, 623, 579, \n579, 527, 667, \n470, 634, 602, \n634, 603, 602, \n598, 597, 640, \n598, 640, 521, \n655, 472, 592, \n472, 655, 534, \n587, 552, 507, \n507, 552, 677, \n461, 607, 606, \n607, 461, 488, \n529, 662, 632, \n662, 529, 664, \n610, 514, 494, \n511, 514, 610, \n620, 618, 574, \n619, 618, 620, \n469, 673, 625, \n625, 673, 651, \n628, 512, 538, \n628, 513, 512, \n656, 471, 559, \n473, 559, 471, \n637, 639, 572, \n572, 639, 573, \n487, 574, 622, \n661, 487, 622, \n531, 571, 533, \n533, 571, 534, \n612, 647, 539, \n647, 612, 658, \n574, 463, 621, \n463, 574, 617, \n562, 672, 648, \n475, 545, 675, \n675, 545, 576, \n651, 652, 666, \n467, 558, 657, \n469, 580, 673, \n469, 557, 580, \n503, 535, 592, \n535, 655, 592, \n572, 531, 637, \n638, 637, 531, \n583, 582, 584, \n582, 504, 584, \n568, 566, 544, \n544, 566, 497, \n595, 596, 593, \n596, 564, 593, \n553, 604, 664, \n553, 485, 604, \n500, 525, 578, \n527, 578, 525, \n524, 483, 564, \n528, 564, 483, \n591, 542, 541, \n555, 542, 591, \n473, 573, 459, \n472, 573, 473, \n609, 660, 548, \n548, 660, 528, \n570, 550, 490, \n575, 577, 619, \n495, 619, 577, \n590, 631, 630, \n590, 480, 631, \n646, 629, 540, \n628, 540, 629, \n551, 550, 642, \n554, 646, 658, \n555, 554, 658, \n658, 654, 555, \n654, 588, 555, \n620, 649, 532, \n638, 532, 649, \n481, 563, 521, \n563, 481, 480, \n670, 597, 595, \n670, 595, 522, \n664, 603, 663, \n662, 664, 663, \n606, 626, 461, \n626, 606, 519, \n459, 627, 473, \n519, 627, 459, \n605, 645, 465);\n\nconst vec3 shift = vec3(-908.0101  ,  64.0319  ,   -495.0735);\nconst float scale = 150.;\n\nobject obj; vec4 lnk; \n\nvec4 d; int ID; float avgR;\n\nobject getObject(int id)\n{\n    object o;\n    if(id<0) id = 0;\n    \n    vec4 a = texel(ch0, i2xy(ivec3(id, 0, 0))); \n    o.X = a.xyz; o.bR = a.w;\n    o.a = texel(ch0, i2xy(ivec3(id, 1, 0))).xyz;\n    o.b = texel(ch0, i2xy(ivec3(id, 2, 0))).xyz;\n    o.c = texel(ch0, i2xy(ivec3(id, 3, 0))).xyz;\n    \n    o.id = id;\n    return o;\n}\n\nvec4 saveObject(int i)\n{\n    switch(i)\n    {\n    case 0:  \n        return vec4(obj.X, obj.bR);\n    case 1:\n        return vec4(obj.a, 0.);\n    case 2:\n        return vec4(obj.b, 0.);\n    case 3:\n        return vec4(obj.c, 0.);\n    }\n}\n\nvoid sort(int idtemp, int R, int T);\nvoid sortlinks(int id, int R, int R0, int T);\nvoid sortneighbors(int id, int R, int T);\nvoid sortrandom(int id, int R, int T);\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(floor(pos));\n    if(any(greaterThan(p, sN*N-1))) discard;\n   \n    ivec3 sid = xy2i(p); ID = sid.x;\n    obj = getObject(ID);\n   \tif(sid.z == 0) //object computation\n    {    \n        if(sid.y < 4)\n        {\n            obj.X = (obj.a + obj.b + obj.c)/3.; \n            \n            //bounding sphere\n            obj.bR = max(distance(obj.X, obj.a),\n                     max(distance(obj.X, obj.b), \n                         distance(obj.X, obj.c)));\n            \n            if(iFrame<1) //initial conditions\n            {\n                if(ID < 410 && ID >= 0)\n                {\n                    obj.a = vertecies[triangles[ID*3]-triz]/scale;\n                    obj.b = vertecies[triangles[ID*3+1]-triz]/scale;\n                    obj.c = vertecies[triangles[ID*3+2]-triz]/scale;\n\n                    obj.a -= shift/scale;\n                    obj.b -= shift/scale;\n                    obj.c -= shift/scale;\n\n                    obj.a = obj.a.xzy;\n                    obj.b = obj.b.xzy;\n                    obj.c = obj.c.xzy;\n                }\n            } \n            \n            \n            U = saveObject(sid.y);\n        }\n    }\n    else //graph computation\n    {\n        d = vec4(1e6);\n        lnk = vec4(-1);\n       \n        sortlinks(ID, sid.y, sid.y, sid.z);\n        \n        sortneighbors(ID, sid.y, sid.z);\n        \n        sortrandom(sid.x, sid.y, sid.z);\n        \n        U = lnk;\n    }\n}\n\n\nbool iscoincidence(int id)\n{\n    return (id == ID) || (id < 0) || any(equal(lnk,vec4(id)));\n}\n\nfloat dist2bisector(vec3 dir, int i)\n{\n    vec4 nb = texel(ch0, i2xy(ivec3(obj.id, i, 1)));\n    object nbo = getObject(int(nb.x));  \n    return dirBisectDist(dir, obj.X, nbo.X, distance(nbo.X, obj.X));\n}\n\nvoid sort(int idtemp, int R, int T) //sort closest objects in N directions\n{\n    if(iscoincidence(idtemp)) return; //particle already sorted\n    object o = getObject(idtemp);\n    vec3 dir = fibonacci_sphere(R, link0);\n    \n    float t = 1e10;\n    switch(T)\n    {\n    case 1: //sort by bisector distance\n        t = dirBisectDist(dir, obj.X, o.X, distance(o.X, obj.X));\n        break;\n    case 2: //sort by sdf distance to this bisector line\n        vec2 par = (iMouse.xy/size)*vec2(8., 8.);\n        float bd = dist2bisector(dir, R);\n        t = min(t, 1.875*sdObj(obj.X + 0.24*dir*bd, o));\n        t = min(t, 1.044*sdObj(obj.X + 0.96*dir*bd, o));\n        //t = min(t, sdObj(obj.X + dir*bd, o));\n        break;\n    }\n   \n    //insertion sort\n    if(d.x > t)\n    {\n        d = vec4(t, d.xyz);\n        lnk = vec4(idtemp, lnk.xyz);\n    }\n    else if(d.y > t)\n    {\n        d.yzw = vec3(t, d.yz);\n        lnk.yzw = vec3(idtemp, lnk.yz);\n    }\n    else if(d.z > t)\n    {\n        d.zw = vec2(t, d.z);\n        lnk.zw = vec2(idtemp, lnk.z);\n    }\n    else if(d.w > t)\n    {\n        d.w = t;\n        lnk.w = float(idtemp);\n    }\n}\n\nvoid sortlinks(int id, int R, int R0, int T)\n{\n    vec4 nb = texel(ch0, i2xy(ivec3(id, R, T)));\n    for(int i = min(0, iFrame); i<4; i++) \n        sort(int(nb[i]), R0, T);\n}\n\nvoid sortneighbors(int id, int R, int T)\n{\n    vec3 dir = fibonacci_sphere(R, link0);\n    vec4 d4 = iSF(dir, float(link0));\n    for(int i = min(0, iFrame); i < 4; i++)\n    {\n         int dir = int(d4[i]);\n         vec4 nb = texel(ch0, i2xy(ivec3(id, dir, T)));\n    \t for(int j = min(0, iFrame); j < 4; j++) \n         {\n         \tsortlinks(int(nb[j]), (16*iFrame+4*j+i)%link0, R, T); \n         }\n    }  \n}\n\nvoid sortrandom(int id, int R, int T)\n{\n    for(int i = min(0, iFrame); i<2; i++) sort((12*iFrame+ID+i)%tot_n, R, T);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//prev closest triangle buffer\n//render\n\nobject getObject(int id)\n{\n    object o;\n    if(id<0) id = 0;\n    \n    vec4 a = texel(ch0, i2xy(ivec3(id, 0, 0))); \n    o.X = a.xyz; o.bR = a.w;\n    o.a = texel(ch0, i2xy(ivec3(id, 1, 0))).xyz;\n    o.b = texel(ch0, i2xy(ivec3(id, 2, 0))).xyz;\n    o.c = texel(ch0, i2xy(ivec3(id, 3, 0))).xyz;\n    \n    o.id = id;\n    return o;\n}\n\n/*//find closest voronoi cell / closest object by its center \nint findClosest(vec3 p, inout object co, int mit)\n{    \n    float t = distance(p, co.X); \n    int dir = 0;\n    for(int s = min(0,iFrame); s < mit; s++)\n    {\n    \tint pid = co.id;\n        dir = int(inverseSF(normalize(p - co.X), float(link0)).x);\n        //voronoi neighbors in this direction\n        vec4 nb = texel(ch0, i2xy(ivec3(co.id, dir%link0, 1)));\n        for(int i = min(0,iFrame); i<4; i++)\n        {\n            object o = getObject(int(nb[i]));\n            float tt = distance(p, o.X);\n            if(tt < t)\n            {\n                co = o;\n            }\n        }   \n        if(pid == co.id) break;\n    }\n    return dir;\n}*/\n\nvoid findClosest(vec3 p, inout object co, int mit)\n{    \n    for(int s = min(0,iFrame); s < mit; s++)\n    {\n    \tint pid = co.id;\n        \n        int dir = int(inverseSF(normalize(p - co.X), float(link0)).x);\n        float t = distance(p, co.X); \n        vec4 nb = texel(ch0, i2xy(ivec3(co.id, dir%link0, 1)));\n        for(int i = min(0,iFrame); i<4; i++)\n        {\n            object o = getObject(int(nb[i]));\n            float tt = distance(p, o.X);\n            \n            if(tt < t)\n            {\n                co = o;\n            }\n        }   \n        \n        if(pid == co.id) break;\n    }\n}\n\n#define maxd 20.\n#define mind 0.003\n#define maxs 128\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat map(vec3 p, inout object co)\n{\n    //find closest voronoi cell\n    findClosest(p, co, 32);\n    float DE = sdObj(p, co); //works well for spheres\n    \n    //improve distance estimate by using \n    //4 closest objects by sdf in this voronoi cell \n    //in this direction\n    //you need this for arbitrary sdfs, like triangles\n    int dir = int(inverseSF(normalize(p - co.X), float(link0)).x);\n    vec4 nb = texel(ch0, i2xy(ivec3(co.id, dir%link0, 2)));\n    for(int i = min(0, iFrame); i < 4; i++)\n    {\n        DE = min(DE, sdObj( p, getObject(int(nb[i])) ));\n    }\n    \n    return min(DE, p.z+0.5);\n}\n\nvec4 calcNormal(vec3 p, float dx, in object co) {\n\tconst vec3 k = vec3(1,-1,0);\n\treturn   (k.xyyx*map(p + k.xyy*dx, co) +\n\t\t\t k.yyxx*map(p + k.yyx*dx, co) +\n\t\t\t k.yxyx*map(p + k.yxy*dx, co) +\n\t\t\t k.xxxx*map(p + k.xxx*dx, co))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\nvec3 col(vec3 p, in vec4 cobj)\n{\n    //voronoi neighbors projected on the sphere surface\n    return vec3(1.);\n}\n\n//voronoi diagram ray marching\nvec4 rayMarch(vec3 p, vec3 d, inout object co)\n{\n    if(co.id < 0)\n    {\n        co = getObject(0);\n    }\n    \n    float td = 0.; float DE = 1e10;\n    for(int i = min(0, iFrame); i < maxs; i++)\n    {\n        //march\n        DE = map(p, co);\n        \n        p += DE*d;\n        td += DE;\n        \n        //outide of the scene\n        if(td > maxd) return vec4(p, -1.);\n        //has hit the surface\n        if(DE < mind*td) break;\n    }\n    return vec4(p, DE);\n}\n\nfloat shadow_march(vec4 pos, vec4 dir, float distance2light, float light_angle, inout object co)\n{\n\tfloat light_visibility = 1.;\n\tfloat ph = 1e5;\n\tpos.w = map(pos.xyz, co);\n\tfor (int i = min(0, iFrame); i < 32; i++) \n    {\n\t\tdir.w += pos.w;\n\t\tpos.xyz += pos.w*dir.xyz;\n\t\tpos.w = map(pos.xyz, co);\n\t\tfloat y = pos.w*pos.w/(2.0*ph);\n        float d = (pos.w+ph)*0.5;\n\t\tfloat angle = d/(max(0.00001,dir.w-y)*light_angle);\n        light_visibility = min(light_visibility, angle);\n\t\tph = pos.w;\n        if(i >= 31) return 0.;\n\t\tif(dir.w >= distance2light) break;\n\t\tif(dir.w > maxd || pos.w < max(mind*dir.w, 0.0001)) return 0.;\n    }\n\tlight_visibility = clamp(2.*light_visibility - 1.,-1.,1.);\n\treturn  0.5 + (light_visibility*sqrt(1.-light_visibility*light_visibility) + asin(light_visibility))/3.14159265; //looks better and is more physically accurate(for a circular light source)\n}\n\n\n#define FOV 2.\nmat3 getRot(vec2 a)\n{\n    \n   mat3 theta_rot = mat3(1, 0, 0,\n                         0, cos(a.y), sin(a.y),\n                         0, -sin(a.y), cos(a.y)); \n        \n   mat3 phi_rot = mat3(cos(a.x), sin(a.x), 0,\n        \t\t       -sin(a.x), cos(a.x), 0,\n        \t\t        0, 0, 1); \n   return transpose(phi_rot*theta_rot);\n}\n\nvec3 getRay(vec2 angles, vec2 pos)\n{\n    mat3 camera = getRot(angles);\n    return normalize(transpose(camera)*vec3(FOV*pos.x, FOV*pos.y, 1.));\n}\n\n\n#define ldir vec3(cos(iTime*0.1)*sin(PI*0.4),sin(iTime*0.1)*sin(PI*0.4), cos(PI*0.4))\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 HDRmapping(vec3 color, float exposure)\n{\n\t// Exposure tone mapping\n    vec3 mapped = ACESFilm(color * exposure);\n    // Gamma correction \n    return pow(mapped, vec3(1.0 / 2.2));\n}\n\nconst float Br = 0.0025;\nconst float Bm = 0.0003;\nconst float g =  0.9800;\nconst vec3 nitrogen = vec3(0.650, 0.570, 0.475);\nconst vec3 Kr = Br / pow(nitrogen, vec3(4.0));\nconst vec3 Km = Bm / pow(nitrogen, vec3(0.84));\n\nvec3 sky_color(in vec3 pos)\n{\n\t// Atmosphere Scattering\n\tvec3 fsun = ldir.xzy;\n\tfloat brightnees = exp(-sqrt(pow(abs(min(5.*(pos.y-0.1),0.)),2.)+0.1));\n\tif(pos.y < 0.)\n\t{\n\t\tpos.y = 0.;\n\t\tpos.xyz = normalize(pos.xyz);\n\t}\n    float mu = dot(normalize(pos), normalize(fsun));\n\t\n\tvec3 extinction = mix(exp(-exp(-((pos.y + fsun.y * 4.0) * (exp(-pos.y * 16.0) + 0.1) / 80.0) / Br) * (exp(-pos.y * 16.0) + 0.1) * Kr / Br) * exp(-pos.y * exp(-pos.y * 8.0 ) * 4.0) * exp(-pos.y * 2.0) * 4.0, vec3(1.0 - exp(fsun.y)) * 0.2, -fsun.y * 0.2 + 0.5);\n\tvec3 sky_col = brightnees* 3.0 / (8.0 * 3.14) * (1.0 + mu * mu) * (Kr + Km * (1.0 - g * g) / (2.0 + g * g) / pow(1.0 + g * g - 2.0 * g * mu, 1.5)) / (Br + Bm) * extinction;\n\tsky_col = 0.4*clamp(sky_col,0.,10.);\n\treturn pow(sky_col,vec3(1./1.5)); \n}\n\nvec3 ambient_sky_color(in vec3 pos)\n{\n\tfloat y = pos.y;\n\tpos.xyz = normalize(vec3(1,0,0));\n\treturn sky_color(pos)*exp(-abs(y));\n}\n\nvec4 ambient_occlusion(in vec4 pos, in vec4 norm, in vec4 dir, in object co)\n{\t\n\tvec3 pos0 = pos.xyz;\n\tvec3 ambient_color = ambient_sky_color(norm.xyz);\n\tpos.xyz += 0.03*dir.w*norm.xyz;\n    pos.w = map(pos.xyz, co);\n\tpos.xyz += pos.w*norm.xyz;\n\tnorm.w = length(pos0 - pos.xyz);\n\tfloat occlusion_angle = clamp(pos.w/norm.w,0.,1.);\n\treturn vec4(ambient_color,1.)*(0.5-cos(3.14159265*occlusion_angle)*0.5);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = (pos - size*0.5)/size.y;\n    vec2 angles = (iMouse.z>0.)?(iMouse.xy/iResolution.xy)*vec2(2.*PI, PI):vec2(-0.4*iTime, PI*0.5);\n    \n    vec3 d = getRay(angles, uv);\n    vec3 p = 0.*texel(ch0, i2xy(ivec3(6, 0, 0))).xyz-2.*getRay(angles, vec2(0.));\n    vec4 prev = pixel(ch1, pos);\n    if(iFrame < 1) prev.w = 0.;\n    object co = getObject(int(prev.w));\n    findClosest(p, co, 16);\n    float closest = float(co.id);\n    vec4 rm = rayMarch(p, d, co);\n    float td = distance(rm.xyz, p);\n    if(rm.w >= 0.) //hit object\n    {\n    \tvec3 n = normalize(calcNormal(rm.xyz, mind*td,co).xyz);\n        vec4 ao = ambient_occlusion(rm, vec4(n, rm.w), vec4(d, td), co);\n        float sh = shadow_march(vec4(rm.xyz+n*0.01, rm.w), vec4(ldir,0.), 10., 0.12, co);\n        U.xyz = sh*sky_color(ldir.xzy)*max(dot(ldir, n),0.) + ao.xyz;\n    }\n    else //background\n    {\n        U.xyz = sky_color(d.xzy);\n    }\n    U.xyz = HDRmapping(U.xyz, 0.5);\n    U.w = closest;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sSczw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 101, 101, 136]], "test": "untested"}
{"id": "WdBczw", "name": "Sound of blood", "author": "hazenn", "description": "weird sound from a few fbms and sine waves. anyone knows why the sound stops after 160~ ?", "tags": ["sound"], "likes": 3, "viewed": 383, "published": 3, "date": "1586270649", "time_retrieved": "2024-07-30T21:14:23.075652", "image_code": "\nvec2 sound( float time )\n{\n    return 0.1*vec2(sin(time)*(\n                     sin(440.*time)  + \n                     sin(261.63*time)+\n                     sin(622.25*time)+\n                     noise(vec2(sin(time),1000.)*time,time)\n                    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.yy;\n    //vec2 pt = fract(abs(uv)*2.)-0.5;\n    vec2 pt = uv;\n    float time = iTime;\n    vec2 a = (sound(time)+0.1*sound(2.*time+1.)+0.1*sound(4.*time+1.))/2.;\n    vec2 b = vec2(0);\n    b = noise(vec2(1000.,cos(time))*time,time);\n    float d = distance(pt,0.5*a*b)-0.1*length(noise(uv,iTime));\n    \n    vec3 col = vec3(0);\n    col += smoothstep(0.2,0.25,sin(3.*d+iTime+length(a*b)));\n    col.r += 0.2;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "sound_code": "\n\n\nvec2 sound( float time )\n{\n    return 0.1*vec2(sin(time)*(\n                     sin(440.*time)  + \n                     sin(261.63*time)+\n                     sin(622.25*time)+\n                     noise(vec2(sin(time),1000.)*time,time)\n                    ));\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    vec2 a = (sound(time)+0.1*sound(2.*time+1.)+0.1*sound(4.*time+1.))/2.;\n    vec2 b = vec2(0);\n    b = noise(vec2(1000.,cos(time))*time,time);\n    return a*b;\n}", "sound_inputs": [], "common_code": "\nvec2 random(vec2 pt , float t){\n    return vec2(\n        fract(456512.6161616*cos(dot(vec3(pt,t) , vec3(150.9898944,30.54614646,151.054608))) ),\n    \tfract(566516.6161616*cos(dot(vec3(pt,t) , vec3(135.54568544,-12540.50540,642.5419840))) ));\n}\n\n\nvec2 noise(vec2 st, float t){\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\tfloat it = floor(t);\n    float ft = fract(t);\n    // Four corners in 2D of a tile\n    vec2 a = random(i,it);\n    vec2 b = random(i + vec2(1.0, 0.0),it);\n    vec2 c = random(i + vec2(0.0, 1.0),it);\n    vec2 d = random(i + vec2(1.0, 1.0),it);\n\tvec2 as = random(i,it+1.);\n    vec2 bs = random(i + vec2(1.0, 0.0),it+1.);\n    vec2 cs = random(i + vec2(0.0, 1.0),it+1.);\n    vec2 ds = random(i + vec2(1.0, 1.0),it+1.);\n    vec2 u = f*f*(3.0-2.0*f);\n\t//float ut = ft*ft*(3.0-2.0*ft);\n\tfloat ut = ft;\n\treturn mix(mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y\n        ,\n        mix(as, bs, u.x) +\n            (cs - as)* u.y * (1.0 - u.x) +\n            (ds - bs) * u.x * u.y\n        ,ut);\n}\n", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdBczw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 27, 27, 263], [265, 265, 322, 322, 814]], "test": "untested"}
{"id": "wdjyzW", "name": "Truncation of 16-Cell to 24-Cell", "author": "mla", "description": "A 16-cell can be truncated to a 24-cell, an interesting polytope wth no regular 3d analogue.\n\nSome keyboard controls added, see code header.", "tags": ["polytope", "24cell", "16cell"], "likes": 6, "viewed": 344, "published": 3, "date": "1586264527", "time_retrieved": "2024-07-30T21:14:24.099913", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// 16- to 24-cell truncation\n//\n// Matthew Arcus, 2020.\n//\n// A modification of https://www.shadertoy.com/view/WdfcW2, showing a\n// 16-cell being truncated to become a 24-cell (a very interesting\n// regular polytope which has no 3d regular equivalent - Matt Parker\n// likes it: https://www.youtube.com/watch?v=oJ7uOj2LRso).\n//\n// <mouse>: rotation\n// <up>/<down>: move in and out\n// <left>/<right>: select polytope, 0=morph, 1=24-cell, 2=intermediate, 3=16-cell\n// c: clifford translation\n// f: faces\n// x: fold\n// r: rotation\n//\n// Also illustrates adding faces to the polytope (the 24-cell has, as\n// you might guess, 24 octahedral cells, but 16 of them are the\n// truncated cells of the original 16-cell, but 8 are from vertex\n// figure of the 16-cell. We draw faces for the 8 vertex figure so the\n// picture doesn't get too cluttered. Turning off folding with 'x'\n// helps to see what is going on.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// As before. Start off with some global variables.\n\nbool dorotate = false;  // Autorotate scene\nbool doclifford = true; // Do Clifford translation\nbool dofaces = true;\nint ktype = 0; // 0 = morphing, 1 = 24-cell, 2 = ???, 3 = 16-cell\n\n// To see what is going on better, set the 'nofold' option to just see a single\n// tetrahedral hyperface. Reduce eyedist eg. to 2.0 to see this better.\nbool nofold = false;\nfloat eyedist = 2.0;     // Distance of eye from origin\nvec3 light = vec3(0,2,1); // Light direction\nint numsteps = 200;       // Maximum raymarching steps\nfloat precis = 1e-3;      // Raymarching precision\nfloat lfactor = 0.3;      // \"Lipschitz\" factor (note new fudge calculation in march())\nfloat eradius = 0.03;    // Radius of edge\nfloat pradius = 0.1;     // Radius of point\nfloat fradius = 0.01;    // \"Radius\" of face - ie. thickness\n\nfloat PI = 3.1415927;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n//#define assert(x)\n\n// The outer wrapper is the same as the octahedron shader, so let's\n// start with the DE function.\n\n// Auxiliary functions\n// Spherical distance between points on hypersphere\nfloat sdistance(vec4 p, vec4 q);\n// Spherical distance from p to great circle through q and r\nfloat ssegment(vec4 p, vec4 q, vec4 r); \n\nvec4 stereographic(vec3 p3, inout float scale); // Stereographic projection\nvec4 qmul(vec4 p, vec4 q); // Quaternion multiplication\n\n// q should be a normalized normal to face.\nfloat facedist(vec4 p, vec4 q) {\n  vec4 p0 = p - dot(p,q)*q;\n  p0 = normalize(p0);\n  float t = sdistance(p,p0);\n  return t;\n}\n\n// Distance to a triangular face, vertices q,r,s. These define a 3d\n// subspace, map to that subspace and clamp to the bounds of the\n// triangle, which gives the closest point on the triangle, then\n// return the spherical distance to that point.  Note that the inverse\n// matrix could be precalculated if q,r,s are fixed.\nfloat facedist(vec4 p, vec4 q, vec4 r, vec4 s) {\n  mat3 m = mat3(dot(q,q),dot(q,r),dot(q,s),\n                dot(q,r),dot(r,r),dot(r,s),\n                dot(q,s),dot(r,s),dot(s,s));\n  vec3 a = inverse(m)*vec3(dot(p,q),dot(p,r),dot(p,s));\n  a = max(a,0.0);\n  vec4 p0 = a[0]*q+a[1]*r+a[2]*s;\n  p0 = normalize(p0);\n  float t = sdistance(p,p0);\n  return t;\n}\n\nfloat de(vec3 p3, out int type) {\n  float scale = 1.0;\n  vec4 p = stereographic(p3,scale);\n\n  if (doclifford) {\n    float t = 0.1*iTime;\n    // The 'normalize' here shouldn't be necessary, but sin and cos\n    // can be relatively inaccurate.\n    vec4 Q = normalize(vec4(-sin(t)*vec3(0,1,0),cos(t)));\n    p = qmul(Q,p);\n  }\n\n  // Exactly as with the octahedron, set p = abs(p), reflecting\n  // everything into the positive sector and into a single\n  // (tetrahedral) hyperface. Then sort the coordinates to\n  // take everything into a small sector around vertex A(1,0,0,0).\n  if (!nofold) {\n    p = abs(p);\n  }\n  // Sort the coordinates\n  if (p.x < p.y) p.xy = p.yx;\n  if (p.z < p.w) p.zw = p.wz;\n  if (p.x < p.z) p.xz = p.zx;\n  if (p.y < p.w) p.yw = p.wy;\n  if (p.y < p.z) p.yz = p.zy;\n  \n  // Check all is well. On my laptop there is a weird bug where if\n  // these assertions are removed, the sort doesn't get done\n  // properly.\n  assert(p.x >= p.y);\n  assert(p.y >= p.z);\n  assert(p.z >= p.w);\n  \n  // The tetrahedron is on the hyperplane x+y+z+w = 1, but we need to\n  // project everything onto the hypersphere, with |p| = 1, so though\n  // we do our calculations on the hyperplane, we normalize\n  // before drawing anything (we could do this in the drawing\n  // functions, but it's more efficient to do it once and for all\n  // here).\n\n  // The main tetrahedron, (A,B,C,D). Just a normal R3 equilateral\n  // tetrahedron with side length sqrt(2), it just happens to be in\n  // R4 rather than R3 (like the equilateral triangle side of the\n  // octahedron in the earlier shader).\n  vec4 A = vec4(1,0,0,0);\n  vec4 B = vec4(0,1,0,0);\n  vec4 C = vec4(0,0,1,0);\n  vec4 D = vec4(0,0,0,1);\n  // To truncate, slice off the 'corner' tetrahedron, (A1,B1,C1,D1).\n  // We can do this gradually with parameter K - K = 0, no truncation,\n  // K = 0.5, full truncation, K = 1/3, an intermediate uniform\n  // polytope (must look up its name).\n  float t = mod(0.5*iTime,4.0);\n  t = clamp(min(t,3.0-t),0.0,1.0);\n  float K = 0.5*smoothstep(0.0,1.0,t);\n  if (ktype == 1) K = 0.5;\n  if (ktype == 2) K = 0.3333;\n  if (ktype == 3) K = 0.0;\n  float K1 = 1.0-K;\n  vec4 A1 = A;\n  vec4 B1 = K1*A+K*B;\n  vec4 C1 = K1*A+K*C;\n  vec4 D1 = K1*A+K*D;\n\n  // Normalize to hypersphere for drawing. I expect the compiler\n  // can constant fold these.\n  A1 = normalize(A1);\n  B1 = normalize(B1);\n  C1 = normalize(C1);\n\n  // Now draw the points and lines.\n  float d = 1e8, d0 = d;\n  d = min(d,ssegment(p,B1,B)-eradius);\n  if (d < d0) type = 2; d0 = d;\n  d = min(d,ssegment(p,B1,C1)-eradius);\n  if (d < d0) type = 0; d0 = d;\n  d = min(d,sdistance(p,B1)-pradius);\n  if (d < d0) type = 1; d0 = d;\n\n  if (dofaces) {\n    d = min(d,facedist(p,B1,C1,D1)-fradius);\n    if (d < d0) type = 3; d0 = d;\n  }\n  \n  // Finally return the distance, but taking into account the\n  // scaling factor from the stereographic projection.\n  return d/scale;\n}\n\n// The revised raymarcher - this now has a much harder job to do - the\n// surface can now extend out as far as the eye can see and even pass\n// through the eye point itself, and the surface itself is more\n// complex so we must tread carefully. As mentioned above, its a good\n// idea to use a 'Lipschitz' factor to reduce the step size and also\n// keep the step below some limit. To avoid many inefficient small\n// steps when stepping out to a distant point, the limit should be\n// dependent on the distance travelled so far, and the desired\n// precision should also be distance dependent for similar reasons.\n\n// Another problem to deal with here is negative steps, which as our\n// DE function is signed, will happen and are usually a good thing -\n// but if we find ourselves stepping backwards past the eye point,\n// then we should give up - this can easily happen if the surface can\n// passes through the eye point, for example.\n\n// Of course, all these cautious changes means that we might\n// need to do more steps, so increase numsteps accordingly - we can\n// still use our assertion to see how many steps are actually being\n// taken and find that 50 or fewer usually suffice.\n\nfloat de(vec3 p) { int t; return de(p,t); }\n\nfloat maxdist = 10.0;\nfloat march(vec3 q, vec3 r) {\n  float t = 0.01; // Total distance so far.\n  maxdist = eyedist + 10.0;\n  for (int i = 0; i < numsteps; i++) {\n    //assert(i < 50);\n    vec3 p = q+t*r;\n    float d = de(p);\n    if (abs(d) < t*precis) return t;\n    t += d/(1.0+lfactor*d);\n    // We can go backwards!\n    if (t < 0.0 || t > maxdist) break;\n  }\n  return -1.0;\n}\n\n// Measuring distances on the hypersphere: this is done just like on a R3\n// sphere, measuring along a great circle route, so the dot product of\n// the two vectors gives the cosine of the angle between them, and the\n// spherical distance is just that angle.\nfloat sdistance(vec4 p, vec4 q) {\n  // acos gives the correct answer, but the Euclidean distance\n  // is a good approximation, particularly up close. The result is\n  // visually indistinguishable and acos is expensive (the Euclidean\n  // distance is an underestimate of the spherical distance, which is\n  // just what we want for raymarching).\n  //return acos(clamp(dot(p,q),-1.0,1.0));\n  return distance(p,q);\n}\n\n// Find the (spherical) distance from p to the line (great circle)\n// through q and r. Again, this is almost the same calculation as in\n// R3 - find the nearest point on the line to p by projecting p onto\n// the qr-plane and normalizing, then after checking the point is in\n// bounds, return the spherical distance to that point.\nfloat ssegment(vec4 p, vec4 q, vec4 r) {\n  // Map p to the plane defined by q and r (and the origin):\n  // p = aq + br + x, where q.x = r.x = 0 so:\n  // p.q = aq.q + br.q and:\n  // p.r = aq.r + br.r\n  // Solve by inverting a 2x2 matrix.\n  mat2 m = inverse(mat2(dot(q,q),dot(q,r),dot(q,r),dot(r,r)));\n  vec2 ab = m*vec2(dot(p,q),dot(p,r));\n  // p1 in plane of q,r, on hypersphere\n  ab = max(ab,0.0); // Clip to segment\n  vec4 p1 = normalize(ab[0]*q + ab[1]*r);\n  // And return the distance to the closest point.\n  return sdistance(p,p1);\n}\n\n// Get the normal of the surface at point p.\nvec3 getnormal(vec3 p, float t) {\n  float eps = 1e-3;\n  vec2 e = vec2(eps,0);\n  return normalize(vec3(de(p + e.xyy) - de(p - e.xyy),\n                        de(p + e.yxy) - de(p - e.yxy),\n                        de(p + e.yyx) - de(p - e.yyx)));\n}\n\nvec4 invert(vec4 p, vec4 q, float r2, inout float scale) {\n  // Invert p in circle, centre q, radius square r2.\n  // Return inverted point and multiply scale by scaling factor.\n  p -= q;\n  float k = r2/dot(p,p);\n  p *= k;\n  scale *= k;\n  p += q;\n  return p;\n}\n\nvec4 stereographic(vec3 p, inout float scale) {\n  return invert(vec4(p,0),vec4(0,0,0,-1),2.0,scale);\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\n// Quaternion multiplication\n// (p+P)(q+Q) = pq + pQ + qP + PQ\nvec4 qmul(vec4 p, vec4 q) {\n  vec3 P = p.xyz, Q = q.xyz;\n  return vec4(p.w*Q+q.w*P+cross(P,Q),p.w*q.w-dot(P,Q));\n}\n\nvec3 getbackground(vec3 r) {\n  return vec3(0.5);\n  return r; // Colourful fun\n  return vec3(0); // The more sober option.\n}\n\nvec3 getbasecolor(int type) {\n  assert(type >= 0);\n  if (type == 0) return vec3(1,1,0.45);\n  if (type == 1) return vec3(0.2);\n  if (type == 2) return vec3(1,0,0);\n  return vec3(1,0,1);\n}\n\n// Rotate according to mouse position\nvec3 transformframe(vec3 p) {\n  if (iMouse.x > 0.0) {\n    // Full range of rotation across the screen.\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  // autorotation - we always rotate a little as otherwise nothing can\n  // be seen (since the z-axis is part of the model).\n  float t = 1.0;\n  if (dorotate) t += iTime;\n  p.yz = rotate(p.yz,-t*0.125);\n  p.zx = rotate(p.zx,-t*0.1);\n  return p;\n}\n\n// Follow ray from q, direction r.\nvec3 raycolor(vec3 q, vec3 r) {\n  float t = march(q,r);\n  if (t < 0.0) return getbackground(r);\n  vec3 p = q+t*r;\n  vec3 normal = getnormal(p,t);\n  int type;\n  de(p,type); // Just to get the object type\n  vec3 color = getbasecolor(type);\n  float ambient = 0.3;\n  float specular = type == 0 ? 0.0 : 0.1;\n  vec3 speccolor = type == 1 ? color : vec3(1);\n  float specularpow = 4.0;\n  vec3 lightdir = normalize(light);\n  float diffuse = 0.7*clamp(dot(normal,lightdir),0.0,1.0);\n  color *= ambient+ diffuse;\n  float s = pow(max(0.0,dot(reflect(light,normal),r)),specularpow);\n  color += specular*s*speccolor;\n  color = mix(color,getbackground(r),t/maxdist);\n  return color;\n}\n\n// Get the colour for a screen point (with normalized coordinates)\nvec3 screencolor(vec2 z) {\n  vec3 eye = vec3(0,0,eyedist);\n  vec3 ray = vec3(z,-2);\n  eye = transformframe(eye);\n  ray = transformframe(ray);\n  light = transformframe(light);\n  ray = normalize(ray);\n  vec3 col = raycolor(eye,ray);\n  col = pow(col,vec3(0.4545)); // Gamma correction - see elsewhere\n  return col;\n}\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_F = 70;\nconst int CHAR_R = 82;\nconst int CHAR_T = 84;\nconst int CHAR_X = 88;\n\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nbool keypress(int key) {\n   return texelFetch(iChannel0, ivec2(key,2),0).x != 0.0;\n}\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\n\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\nint mymod(int n, int m) {\n  // glsl % undefined for -ve arguments\n  if (n < 0) return m-1-(-n-1)%m;\n  else return n%m;\n}\n\n// The main function called by Shadertoy\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n  // Set up options\n  dofaces = !keypress(CHAR_F);\n  dorotate = !keypress(CHAR_R);\n  doclifford = !keypress(CHAR_C);\n  nofold = keypress(CHAR_X);\n  eyedist *= 1.0+0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP));\n  ktype = mymod(keycount(KEY_RIGHT)-keycount(KEY_LEFT),4);\n  vec2 z = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec3 col = screencolor(z);\n  if (alert) col.r = 1.0; // Check nothing has gone wrong.\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0) {\n      t = vec4(0);\n    } else {\n      t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdjyzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1967, 1967, 1988, 1988, 2014], [2480, 2524, 2556, 2556, 2649], [2651, 2973, 3021, 3021, 3327], [3329, 3329, 3362, 3362, 6227], [7411, 7411, 7429, 7429, 7454], [7478, 7478, 7507, 7507, 7834], [7836, 8094, 8127, 8480, 8506], [8508, 8838, 8878, 9074, 9376], [9378, 9423, 9456, 9456, 9669], [9671, 9671, 9729, 9847, 9930], [9932, 9932, 9979, 9979, 10034], [10036, 10067, 10097, 10097, 10142], [10144, 10207, 10234, 10234, 10321], [10323, 10323, 10351, 10351, 10446], [10448, 10448, 10477, 10477, 10634], [10636, 10674, 10703, 10703, 11215], [11217, 11252, 11283, 11283, 11921], [11923, 11990, 12016, 12016, 12303], [12613, 12613, 12637, 12637, 12697], [12699, 12699, 12724, 12724, 12772], [12774, 12774, 12797, 12797, 12829], [12831, 12831, 12856, 12896, 12951], [12953, 12994, 13045, 13065, 13489]], "test": "untested"}
{"id": "WdSczh", "name": "Glass Cube", "author": "ChrisK", "description": "Tried to create something aesthetically pleasing while teaching myself the math for raytracing AABB's and transparent objects.\n\nI annotated every line mostly just because I felt like it, but hopefully it can help someone else who's learning this stuff.", "tags": ["3d", "raytracing", "reflections", "translucency", "annotated"], "likes": 33, "viewed": 927, "published": 3, "date": "1586234188", "time_retrieved": "2024-07-30T21:14:24.973578", "image_code": "#define ABSORBTION vec3(0.1, 5.0, 2.0)\n#define IOR 1.5\n#define TIMESCALE 0.35\n#define INTERNAL_REFLECTIONS 5\n\n\nvec3 rotate ( vec3 p, vec3 r ) {\n\tp = vec3( p.x,                       p.y*cos(r.x)-p.z*sin(r.x), p.y*sin(r.x)+p.z*cos(r.x) );\t// x-axis rotation\n    p = vec3( p.x*cos(r.y)+p.z*sin(r.y), p.y,                      -p.x*sin(r.y)+p.z*cos(r.y) );\t// y-axis rotation\n    p = vec3( p.x*cos(r.z)-p.y*sin(r.z), p.x*sin(r.z)+p.y*cos(r.z), p.z \t\t\t\t\t  );\t// z-axis rotation\n    return p;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// return rotated vector\n}\n\n\nfloat IntersectCube ( vec3 ro, vec3 rd ) {\n    vec3 tmin = (vec3( 0.5)-ro)/rd;\t\t\t\t\t\t// distances to positive bounding planes for an axis-aligned unit cube at (0,0,0)\n    vec3 tmax = (vec3(-0.5)-ro)/rd;\t\t\t\t\t\t// distances to negative bounding planes for an axis-aligned unit cube at (0,0,0)\n    vec3 rmin = min(tmin, tmax);\t\t\t\t\t\t// distances to front-facing planes\n    vec3 rmax = max(tmin, tmax);\t\t\t\t\t\t// distances to back-facing planes\n    float dback  = min( min(rmax.x, rmax.y), rmax.z );\t// distance to nearest back-facing side\n    float dfront = max( max(rmin.x, rmin.y), rmin.z );\t// distance to furthest front-facing side (possible collision distance)\n    return dback>=dfront ? dfront : -1.0;\t\t\t\t// distance to front of cube (-1.0 if miss)\n}\n\n\nfloat InteriorCubeReflection ( vec3 ro, vec3 rd ) {\n    vec3 tmin = (vec3( 0.5)-ro)/rd;\t\t\t\t\t\t// distances to positive bounding planes for an axis-aligned unit cube at (0,0,0)\n    vec3 tmax = (vec3(-0.5)-ro)/rd;\t\t\t\t\t\t// distances to negative bounding planes for an axis-aligned unit cube at (0,0,0)\n    vec3 rmax = max(tmin, tmax);\t\t\t\t\t\t// distances to back-facing planes\n    return min( min(rmax.x, rmax.y), rmax.z );\t\t\t// distance to nearest back-facing side\n}\n\n\nfloat GetReflectance ( vec3 i, vec3 t, vec3 nor, float iora, float iorb ) {\n\tfloat cosi = dot(i,nor);\t\t\t\t\t\t\t\t\t\t\t\t\t// cosine of angle between incoming ray and normal\n    float cost = dot(t,nor);\t\t\t\t\t\t\t\t\t\t\t\t\t// cosine of angle between refracted ray and normal\n    float spr = pow( (cosi/iorb - cost/iora) / (cosi/iorb + cost/iora), 2.0 );\t// calculate r-polarized Fresnel reflectance\n    float spp = pow( (cost/iorb - cosi/iora) / (cost/iorb + cosi/iora), 2.0 );\t// calculate p-polarized Fresnel reflectance\n    return ( spr + spp ) / 2.0;\t\t\t\t\t\t\t\t\t\t\t\t\t// average polarized reflectances for unpolarized light\n}\n\n\nvec3 GetSky ( vec3 rd ) {\n    rd = rotate(rd, vec3(3.1415/4.0));\t\t\t\t\t\t\t\t\t\t\t// rotate sky (for more interesting reflections in cube)\n    vec3 room = vec3( max( max( abs(rd).x, abs(rd).y ), abs(rd).z ) );\t\t\t// draw quick 'box' (white on axes, darker 'corners')\n    room = pow( room, vec3(1.5) );\t\t\t\t\t\t\t\t\t\t\t\t// darken shadows in corners\n    if( abs(rd).x>max(abs(rd).y,abs(rd).z) ) room -= vec3(0.5,0.0,1.0);\t\t\t// paint x-axis walls green\n    if( abs(rd).y>max(abs(rd).x,abs(rd).z) ) room -= vec3(0.8,0.3,0.0); \t\t// paint y-axis walls blue\n    return room;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// return sky colour\n}\n\n\nvec3 GetRenderSample ( vec3 ro, vec3 rd ) {\n\tfloat rl = IntersectCube( ro, rd );\t\t\t\t\t\t\t\t\t// find intersection distance between camera ray and cube\n    \n    if ( rl > 0.0 ) {\t\t\t\t\t\t\t\t\t\t\t\t\t// did the camera ray hit the cube?\n        \n        vec3 xyz = ro + rd*rl;\t\t\t\t\t\t\t\t\t\t\t// ray hit the cube - get intersection coordinates\n        vec3 nor = round( xyz*1.00001 );\t\t\t\t\t\t\t\t// calculate surface normal for axis-aligned unit cube\n        vec3 power = vec3(1.0);\t\t\t\t\t\t\t\t\t\t\t// attenuated contribution of light path\n        vec3 refractd = refract( rd, nor, 1.0/IOR );\t\t\t\t\t// get ray vector refracted into cube\n        vec3 reflectd = reflect( rd, nor );\t\t\t\t\t\t\t\t// get ray vector reflected off of cube\n        float refl = GetReflectance ( rd, refractd, nor, 1.0, IOR );\t// get fraction of light that is reflected\n        vec3 c = GetSky(reflectd) * refl;\t\t\t\t\t\t\t\t// calculate colour of ray reflected off surface of cube\n        power *= 1.0-refl;\t\t\t\t\t\t\t\t\t\t\t\t// attenuate influence of refracted ray\n        rd = refractd;\t\t\t\t\t\t\t\t\t\t\t\t\t// reorient camera ray along refracted ray path\n\n        for ( int i=0; i<INTERNAL_REFLECTIONS; i++ ) {\t\t\t\t\t// for each light ray traced inside of the cube...\n        \trl = InteriorCubeReflection( xyz, rd );\t\t\t\t\t\t// get length of reflected ray inside cube\n        \txyz += rd*rl;\t\t\t\t\t\t\t\t\t\t\t\t// move to new intersection coordinates\n            nor = round( xyz*1.00001 );\t\t\t\t\t\t\t\t\t// calculate surface normal for axis-aligned unit cube\n        \trefractd = refract( rd, -nor, 1.0/IOR );\t\t\t\t\t// get refracted ray direction\n        \treflectd = reflect( rd, -nor );\t\t\t\t\t\t\t\t// get reflected ray direction\n        \trefl = GetReflectance ( rd, refractd, -nor, IOR, 1.0 );\t\t// get fraction of light that is reflected\n        \tpower *= exp( -ABSORBTION * rl );\t\t\t\t\t\t\t// calculate absorbtion with Beer's Law\n            c += GetSky(refractd) * (1.0-refl) * power;\t\t\t\t\t// add light that is refracted out of cube\n            power *= refl;\t\t\t\t\t\t\t\t\t\t\t\t// attenuate influence of next reflected ray\n            rd = reflectd;\t\t\t\t\t\t\t\t\t\t\t\t// move to reflected path for next calculation\n        }\n        return c;\t\t\t\t\t\t\t\t\t\t\t\t\t\t// return cube colour along camera ray\n    } else {\n    \treturn GetSky(rd);\t\t\t\t\t\t\t\t\t\t\t\t// ray missed the cube - return background colour\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy/iResolution.xy*2.0 - 1.0;\t\t\t\t\t// get camera-space position of pixel (-1 => 1)\n    uv.y *= iResolution.y/iResolution.x;\t\t\t\t\t\t\t\t// stretch y-axis to equalize length of x and y units\n    \n    vec3 campos = vec3(0.0, 0.0, -2.5);\t\t\t\t\t\t\t\t\t// set camera back -2.5 units from center of cube\n    vec3 camray = normalize( vec3(uv,1.0) );\t\t\t\t\t\t\t// get camera ray vector for camera pointed at origin (FOV = PI/2)\n    campos = rotate(campos, vec3(iTime*TIMESCALE));\t\t\t\t\t\t// rotate camera around cube\n    camray = rotate(camray, vec3(iTime*TIMESCALE));\t\t\t\t\t\t// rotate camera rays to face cube\n    \n    vec3 col = GetRenderSample( campos, camray );\t\t\t\t\t\t// get pixel colour along camera ray path\n    \n    //col = smoothstep(0.0, 1.0, col);\t\t\t\t\t\t\t\t\t// quick tonemapping - saturate colours\n    col = pow( col, vec3(0.4545) );\t\t\t\t\t\t\t\t\t\t// gamma correction\n    fragColor = vec4( col, 1.0 );\t\t\t\t\t\t\t\t\t\t// return final pixel colour\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdSczh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 111, 143, 143, 535], [538, 538, 580, 580, 1286], [1289, 1289, 1340, 1340, 1750], [1753, 1753, 1828, 1828, 2360], [2363, 2363, 2388, 2388, 2954], [2957, 2957, 3000, 3000, 5234], [5237, 5237, 5294, 5294, 6233]], "test": "untested"}
{"id": "3djcRW", "name": "Day 109", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 12, "viewed": 468, "published": 3, "date": "1586206950", "time_retrieved": "2024-07-30T21:14:25.819316", "image_code": "// HYPERBOLIC CODE FROM http://roy.red/generating-spherical-and-hyperbolic-tilings-in-glsl-.html#generating-spherical-and-hyperbolic-tilings-in-glsl\n// Super interesting read, I am still in the process of understanding all of it, so I copied the UV generation\n// and added some textures on top to make it shiny\n\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n#define PI acos(-1.)\n\n#define pi acos(-1.)\n#define tau (1.*pi)\n\n// Adjust p, q, r\nconst float p = 3.; const float q=4.; const float r=3.;\nfloat space = float(sign(q*r+p*r+p*q-p*q*r));\nvec3 fold( vec3 p, in vec3 dir, inout int n) {\n// Reflect if we're outside the fundamental region\n    float dt = dot(p,dir);\n    if (dt < 0.) {\n        n = n + 1;\n        return p-2.*dt*dir*vec3(1,1,space);\n    }\n    return p;\n}\nfloat sdBox(vec2 p, vec2 s){\n\tfloat d = 10e8;\n    p = abs(p) - s;\n    d = max(p.x,p.y);\n    return d;\n}\nfloat xor(float a, float b){\n\treturn float(int(a)^ int(b));\n}\nvec4 noise(float t){return texture(iChannel0,vec2(floor(t), floor(t))/256.);}\n\nvec3 get(vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec2 z = uv;\n    z *= 2.5;\n    \n    // - HYPERBOLIC UV - //\n    \n    if(length(z) > 1.)\n    \tz /= dot(z,z);\n    \n    // Stereographically project\n    vec3 w=vec3(2.*z,1.-space*dot(z,z))*1./(1.+space*dot(z,z));\n    \n    // Hyperbolic rotation\n    float amt = mod(iTime, 2.45*2.);\n    \n    float envA = smoothstep(0.,1.,amt/2.45)*0.2;\n    float envB = smoothstep(0.,1.,amt/2.45 - 1.)*0.2;\n    \n    if(amt > 2.45)\n        amt -= 2.45*2.;\n    w.yz *= mat2(cosh(amt), sinh(amt), sinh(amt),cosh(amt));\n    //w.yz *= mat2(cosh(amt), sinh(amt), sinh(amt),cosh(amt));\n    // Calculate cutting planes\n    float ab = -cos(PI/p);\n    float bc = -cos(PI/q);\n    float ac = -cos(PI/r);\n    vec3 a = vec3(1.,0.,0);\n    vec3 b = vec3(ab,sin(PI/p),0.);\n    float c0 = ac;\n    float c1 = (bc-b[0]*c0)/b[1];\n    vec3 c = vec3(c0,c1,sqrt(abs(1.-c0*c0-c1*c1)));\n    if (space==0.)\n        c[2] = .5;\n\n    // Fold across the planes a few times\n    int n=0; int m = 0;\n    for (int i=0;i<10;i++){\n        w = fold(w,a,m);\n        w = fold(w,b,m);\n        w = fold(w,c,n);\n    }\n\n    \n    // - COLORING - //\n    //w.x += iTime;\n    \n    float d = 10e7;\n    vec4 no = noise(float(n + m));\n    vec2 p = w.xy;\n    //p = sin(p*7.);\n    #define pmod(p,x) (mod(p,x) - 0.5*x)\n    //vec2 j = pmod(p, 20.);\n    vec2 j = p;\n    j.x -= 2.5;\n    j = sin(j*7.);\n    vec3 col = vec3(0);\n    //col += w*1.;\n    \n    \n    vec3 ff = 1. - vec3(1.)*(dot(w*1.,a*8.));\n    \n    ff = clamp(ff, 0.,1.);\n    //col += ff*0.1;\n\t\n    p.x -= 0.5;\n    float db = sdBox(j, vec2(0.2,0.9));\n    #define pal(a,b,c,d,e) (a + b*sin((c)*(d)+(e)))\n    vec3 cc = pal(0., 0.5, vec3(4.7,4.4,3.4), 1.7,.4 + w*2. + iTime*0.);\n    \n    cc = texture(iChannel1,w.xy, 1.3 + dot(uv*0.5,uv*0.5)*5.).xyz;\n    \n    cc = sin(cc*(5.4) + vec3(0.,0. ,.4 - envB + envA));\n    cc = max(cc, 0.);\n    \n    //cc.bg *= 0.2 +  pow(1. - length(w.x), 2.)*0.8;\n    float bb = length(cc) * pow(1. - length(w), 1.)*1.;\n    cc = sin(cc*1.  + bb*20.);\n    cc *= pow(1. - length(w.x)*1.25, 1.)*1.;\n    cc = smoothstep(0.,1.,cc);\n    cc = smoothstep(0.,1.,cc);\n    col += cc;\n    \n    \n    col -= smoothstep(0.,1.*dFdy(uv.x),-db );\n    col = max(col, 0.);\n    vec3 cb = smoothstep(0.,1.*dFdy(uv.x),-db )*pal(0.5, 0.5, vec3(0.7,0.4,0.9), 0.7 ,0.4 + uv.x + iTime);\n    \n    //col += cb;\n    \n    col = clamp(col, 0., 1.);\n    \n    //col = vec3(1);\n    \n    //col *= 1. - exp2(-abs(length(uv) - 0.4)*20.)*1.;\n    //col *= 1. - exp2(-abs(length(uv) - 0.4)*20.)*1.;\n    \n    float edge = exp2(-abs (length(uv) - 0.4)*50.)*1.;\n    \n    edge = smoothstep(0.,1.,edge);\n    edge = smoothstep(0.,1.,edge);\n    //edge = smoothstep(0.,1.,edge);\n    \n    //col = pow(col, vec3(1. + pow(edge, 0.5)));\n    col = max(col, 0.);\n    col.gb = pow(col.gb, vec2(1. + pow(edge, 0.5) ));\n    \n    col *= 1. - edge*1.0;\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;  \n    vec3 col = vec3(0);\n    \n    float aa = 4.;\n    \n    for(float i =0.; i < aa*aa + min(float(iFrame),0.); i++){\n    \tcol += get(fragCoord + vec2(mod(i,aa),floor(i/aa))/aa);\n    }\n    col /= aa*aa;\n    \n    col = clamp(col, 0., 1.);\n    //col *= 0.999;\n    //col = 1. - col;\n    \n    \n    \n    //col *= max((1. + 1.*cos(iTime*1.+length(uv)*2.+vec3(4,2.5,1.5)))*1., 0.);\n    //col *= max((1.5 + 1.4*cos(iTime+length(uv)*2.+vec3(1,1.5,1.5)))*1., 0.);\n    col *= 2.;\n    col *= 1. - pow(smoothstep(0.,1.,dot(uv,uv)*0.9),0.9)*1.;\n    //col = 1. - col;\n    col = max(col, 0.);\n    \n    col = pow(col, vec3(0.45454));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djcRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[548, 548, 594, 645, 776], [777, 777, 805, 805, 880], [881, 881, 909, 909, 942], [943, 943, 963, 963, 1020], [1022, 1022, 1048, 1048, 3944], [3947, 3947, 4004, 4004, 4715]], "test": "untested"}
{"id": "Ws2cRW", "name": "Polar of elliptic curve", "author": "NinjaKoala", "description": "Visualization of the Polar curve of an elliptic curve with respect to the mouse point", "tags": ["2d", "math", "ellipticcurve"], "likes": 5, "viewed": 328, "published": 3, "date": "1586203072", "time_retrieved": "2024-07-30T21:14:26.583274", "image_code": "/*\nVisualization of the Polar Curve of an elliptic curve\nwith respect to the mouse point.\n\nThe Polar of a Curve (degree n) with respect to a point p\nis a curve with degree n-1 which goes through all\nsingularities (none for an elliptic curve)\nand all points on the curve whose tangents pass through p.\n\nFor a projective curve given by a homogenous equation\nits homogenous equation can be calculated by computing the dot product of\nthe projective coordinates of a point with the curve's gradient.\n\nThe blue curve is the elliptic curve\nThe green dot is the mouse point\nThe cyan curve is the Polar of the elliptic curve with respect to the mouse point\nThe red dots are the intersection points of the elliptic curve and its Polar\nThe green lines are the tangents at the intersection points of the elliptic curve and its Polar\n\nFor some mouse positions the iterative computation of the\nintersection points fail.\n\nsee https://en.wikipedia.org/wiki/Polar_curve\n*/\n\n//#define SHOW_BASINS\n//#define SHOW_INITAL_POINTS\n//#define ANIMATE_CURVE\n\nconst int grad_descent_iterations=12;\n\nfloat border;\n\nconst float eps = .005;\n\nconst float pi=3.14159265358979;\n\nfloat spectral(float x){\n        return clamp(abs(mod((x/pi+1.)*4.,8.)-4.)-2.,-.75,.75)*.5/.75+.5;\n}\n\nvec3 to_col(vec2 z){\n\tfloat direction =atan(z.x,z.y);\n\treturn vec3(spectral(direction),spectral(direction+pi/2.),spectral(direction-pi));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat aspect_ratio = iResolution.x / iResolution.y;\n\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n\tuv-=.5;\n\tuv.x *= aspect_ratio;\n\n\tvec2 mouse = (iMouse.xy+1.) / iResolution.xy;\n\tmouse-=.5;\n\tmouse.x *= aspect_ratio;\n\n\tconst float line_width = .001;\n\tconst float curve_width = .001;\n\tconst float dot_size = .01;\n\n\tconst float axis_width = .005;\n\n\tconst vec3 bg_col = vec3(1,1,1);\n\tconst vec3 axis_col = vec3(0,0,0);\n\tconst vec3 line_col = vec3(0,1,0);\n\tconst vec3 curve_col = vec3(0,0,1);\n\tconst vec3 polar_curve_col = vec3(0,1,1);\n\tconst vec3 dot_col = vec3(1,0,0);\n\tconst vec3 initial_dot_col = vec3(0,0,0);\n\tconst vec3 mouse_dot_col = vec3(0,1,0);\n\n    border = 2./iResolution.y;\n\n\tfloat curve_dis = 1e38;\n\tfloat polar_curve_dis = 1e38;\n\tfloat dot_dis = 1e38;\n\tfloat initial_dot_dis = 1e38;\n\tfloat mouse_dot_dis = 1e38;\n\tfloat axis_dis = 1e38;\n\tfloat line_dis = 1e38;\n\n\t//elliptic curve parameters (weierstrass normal form)\n\n\t#ifdef ANIMATE_CURVE\n\tfloat anim=sin(mod(iTime*.1,2.*pi));\n\n\tfloat g_2 = .3 + .2*anim;\n\tfloat g_3 = -.05 + .05*anim;\n\t#else\n\tfloat g_2 = .3;\n\tfloat g_3 = -.05;\n\t#endif\n\n\tvec2 p0=mouse;\n\n\t//initial approximations of the intersection points\n\tvec2[6] int_pnts=vec2[](vec2(.0,.25),vec2(.0,-.25),\n\t                        vec2(-.25*aspect_ratio,.25),vec2(-.25*aspect_ratio,-.25),\n\t                        vec2(.25*aspect_ratio,.25),vec2(.25*aspect_ratio,-.25));\n\n\t//compute intersection points by alternately gradient descenting to curve and polar of curve\n\tfloat int_p_val, polar_int_p_val, p1_val, polar_p1_val;\n\tvec2 int_p_grad, polar_int_p_grad, p1_grad, polar_p1_grad;\n\n\t#ifdef SHOW_BASINS\n\tvec2 p1=uv;\n\t#endif\n\n\t#ifdef SHOW_INITAL_POINTS\n\tfor(int i=0;i<6;i++){\n\t\tinitial_dot_dis=min(initial_dot_dis,distance(int_pnts[i],uv)-dot_size);\n\t}\n\t#endif\n\n\tfor(int i=0;i<grad_descent_iterations;i++){\n\t\tfor(int j=0;j<6;j++){\n\t\t\tint_p_val = int_pnts[j].y*int_pnts[j].y - (( 4.*int_pnts[j].x*int_pnts[j].x - g_2 ) * int_pnts[j].x - g_3);\n\t\t\tint_p_grad = vec2(-12.*int_pnts[j].x*int_pnts[j].x+g_2,2.*int_pnts[j].y);\n\t\t\tint_pnts[j]-=(int_p_grad*int_p_val)/dot(int_p_grad,int_p_grad);\n\n\t\t\tpolar_int_p_val=p0.x*(12.*int_pnts[j].x*int_pnts[j].x-g_2)+p0.y*(-2.*int_pnts[j].y)+(-2.*g_2*int_pnts[j].x-int_pnts[j].y*int_pnts[j].y-3.*g_3);\n\t\t\tpolar_int_p_grad=vec2(p0.x*24.*int_pnts[j].x-2.*g_2,-2.*p0.y-2.*int_pnts[j].y);\n\t\t\tint_pnts[j]-=(polar_int_p_grad*polar_int_p_val)/dot(polar_int_p_grad,polar_int_p_grad);\n\t\t}\n\n\t\t#ifdef SHOW_BASINS\n\t\tp1_val = p1.y*p1.y - (( 4.*p1.x*p1.x - g_2 ) * p1.x - g_3);\n\t\tp1_grad = vec2(-12.*p1.x*p1.x+g_2,2.*p1.y);\n\t\tp1-=(p1_grad*p1_val)/dot(p1_grad,p1_grad);\n\n\t\tpolar_p1_val=p0.x*(12.*p1.x*p1.x-g_2)+p0.y*(-2.*p1.y)+(-2.*g_2*p1.x-p1.y*p1.y-3.*g_3);\n\t\tpolar_p1_grad=vec2(p0.x*24.*p1.x-2.*g_2,-2.*p0.y-2.*p1.y);\n\t\tp1-=.1*(polar_p1_grad*polar_p1_val)/dot(polar_p1_grad,polar_p1_grad);\n\t\t#endif\n\t}\n\n\tmouse_dot_dis=min(mouse_dot_dis,distance(p0,uv)-dot_size);\n\n\tfor(int i=0;i<6;i++){\n\t\tint_p_val = int_pnts[i].y*int_pnts[i].y - (( 4.*int_pnts[i].x*int_pnts[i].x - g_2 ) * int_pnts[i].x - g_3);\n\t\tif(abs(int_p_val)<eps){\n\t\t\tdot_dis=min(dot_dis,distance(int_pnts[i],uv)-dot_size);\n\t\t\tint_p_grad = vec2(-12.*int_pnts[i].x*int_pnts[i].x+g_2,2.*int_pnts[i].y);\n\t\t\tvec3 tangent=vec3(normalize(int_p_grad),0);\n\t\t\ttangent.z=-dot(int_pnts[i],tangent.xy);\n\n\t\t\tline_dis=min(line_dis,abs(dot(vec3(uv,1),tangent)));\n\t\t}\n\t}\n\n\tfloat uv_val = uv.y*uv.y - (( 4.*uv.x*uv.x - g_2 ) * uv.x - g_3);\n\tvec2 uv_grad = vec2(-12.*uv.x*uv.x+g_2,2.*uv.y);\n\n\tcurve_dis=min(curve_dis, abs(uv_val)/length(uv_grad)-curve_width);\n\n\tfloat polar_uv_val=p0.x*(12.*uv.x*uv.x-g_2)+p0.y*(-2.*uv.y)+(-2.*g_2*uv.x-uv.y*uv.y-3.*g_3);\n\tvec2 polar_uv_grad=vec2(p0.x*24.*uv.x-2.*g_2,-2.*p0.y-2.*uv.y);\n\n\tpolar_curve_dis=min(polar_curve_dis, abs(polar_uv_val)/length(polar_uv_grad)-curve_width);\n\n\taxis_dis=min(axis_dis, abs(uv.x));\n\taxis_dis=min(axis_dis, abs(uv.y));\n\n\tvec3 color = bg_col;\n\n\t#ifdef SHOW_BASINS\n\tcolor=to_col(p1)*.5;\n\t#endif\n\n\tcolor=vec3(mix(axis_col,color,smoothstep(0., border, axis_dis)));\n\tcolor=vec3(mix(line_col,color,smoothstep(0., border, line_dis)));\n\tcolor=vec3(mix(polar_curve_col,color,smoothstep(0., border, polar_curve_dis)));\n\tcolor=vec3(mix(curve_col,color,smoothstep(0., border, curve_dis)));\n\tcolor=vec3(mix(dot_col,color,smoothstep(0., border, dot_dis)));\n\tcolor=vec3(mix(initial_dot_col,color,smoothstep(0., border, initial_dot_dis)));\n\tcolor=vec3(mix(mouse_dot_col,color,smoothstep(0., border, mouse_dot_dis)));\n\n\tfragColor = vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2cRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1146, 1146, 1170, 1170, 1246], [1248, 1248, 1268, 1268, 1387]], "test": "untested"}
{"id": "Wd2yRW", "name": "Hyperbolic Zoom", "author": "mla", "description": "From one extreme to the other: zooming into the hyperbolic half plane (two of them).\n\nVariation on sl2c's excellent [url]https://www.shadertoy.com/view/3d2cz1[/url]", "tags": ["zoom", "hyperbolic", "halfplane"], "likes": 6, "viewed": 414, "published": 3, "date": "1586200289", "time_retrieved": "2024-07-30T21:14:27.362191", "image_code": "// Original by sl2c: https://www.shadertoy.com/view/3d2cz1\n// Zooming modification by Matthew Arcus, mla, 2020.\n\n#define swap(x,y) {t=x;x=y;y=t;}\n\n\nvec3 color(vec2 z) {\n    float pi = 3.14159265359;\n    float theta = pi/9.0;\n    // someday I'll explain the cross-ratio magic that got me these numbers\n    float r = 2.0 / (1.0 - sqrt(1.0 - 4.0 * sin(theta) * sin(theta)));\n    float p = - r * cos(theta);\n    bool fl = false;\n    vec3[3] colors;\n    colors[0] = vec3(1.0,0.0,0.0);\n    colors[1] = vec3(0.0,1.0,0.0);\n    colors[2] = vec3(0.0,0.0,1.0);\n    vec3 t; // for temp space\n    for(int i=0;i<100;i++) {\n        if (z.x < 0.0) {\n            z.x = -z.x;\n            colors[2] = 1.0 - colors[2];\n            fl = !fl;\n            continue;\n        }\n        if (dot(z,z) < 1.0) {\n            z /= dot(z,z);\n            fl = !fl;\n            swap(colors[0],colors[1]);\n            continue;\n        }\n        z.x -= p;\n        if (dot(z,z) > r*r) {\n            z *= r * r / dot(z,z);\n            fl = !fl;\n            z.x += p;\n            swap(colors[1],colors[2]);\n            continue;\n        }\n        z.x += p;\n        vec3 col = colors[0];\n        if (fl) {\n            col = 0.5 * col;\n        }\n    return col;\n    }\n    return vec3(1.0,1.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    uv *= exp(50.0-mod(iTime,50.0)-24.0);\n        //uv.x += 1.0 * iTime;\n        fragColor = vec4(color(uv),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2yRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1261, 1261, 1318, 1318, 1504]], "test": "untested"}
{"id": "tdBczD", "name": "Equidistant point calculation", "author": "michael0884", "description": "finding the equidistant point between 2 sdf's in a direction, I need that to approximate the voronoi diagram for sdfs.", "tags": ["2d", "sdf"], "likes": 6, "viewed": 345, "published": 3, "date": "1586194896", "time_retrieved": "2024-07-30T21:14:28.124154", "image_code": "float sdRoundedX( in vec2 p, in float w, in float r )\n{\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\nfloat sdHexagram( in vec2 p, in float r )\n{\n    const vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nstruct object\n{\n    vec2 p;\n    vec2 r;\n    int i;\n};\n    \nfloat sdObj(vec2 p, in object o)\n{\n    switch(o.i)\n    {\n    case 0:\n    \treturn sdBox(p - o.p, o.r);\n    case 1:\n    \treturn sdHexagram(p - o.p, o.r.x);\n    case 2:\n    \treturn sdRoundedX(p - o.p, o.r.x, o.r.y);\n    default:\n        return distance(p, o.p) - o.r.x;\n    }\n}\n\nfloat eqDist(vec2 d, in object a, in object b)\n{\n    vec2 p = a.p;\n    float td = 0.;\n    for(int i = 0; i < 10; i++)\n    {\n        float dd = sdObj(p, b) - sdObj(p, a);\n        p += dd*d;\n        td += dd;\n    }\n    return td;\n}\n\nvec2 scale(vec2 pix)\n{\n    return 0.2*(pix - iResolution.xy*0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = scale(fragCoord);\n\n    object a, b;\n    a.p = vec2(0); a.r = vec2(14,1); a.i = 2;\n    b.p = 15.*vec2(sin(0.1*iTime),1.3*cos(0.1*iTime)); b.r = vec2(5.); b.i = 1;\n    \n \tfloat de0 = sdObj(uv, a);\n    float de1 = sdObj(uv, b);\n    vec3 cc;\n    if(de0 < de1) cc = vec3(1,1.02,1.05);\n    else cc =vec3(1.05,1.02,1.);\n  \tfloat de = min(de0, de1);\n    vec2 d = normalize(scale(iMouse.xy) - a.p);\n    float dd = eqDist(d, a, b);\n    float e = exp(-sdSegment(uv, a.p, a.p + dd*d));\n\n    vec3 col = smoothstep(0.4,0.6,0.5+0.5*sin(cc*de))/de \n               + vec3(0,0,1)*exp(-abs(de1-de0))\n               + e*vec3(1,0.5,0.2);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdBczD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 118], [120, 120, 163, 163, 404], [406, 406, 443, 443, 523], [525, 525, 577, 577, 696], [757, 757, 791, 791, 1031], [1033, 1033, 1081, 1081, 1262], [1264, 1264, 1286, 1286, 1331], [1333, 1333, 1390, 1390, 2059]], "test": "untested"}
{"id": "wdSyRD", "name": "Cave Dolphins", "author": "dr2", "description": "Relax with the dolphins; mouse provides non-panoramic view.", "tags": ["voronoi", "truchet", "fish", "panorama"], "likes": 29, "viewed": 753, "published": 3, "date": "1586184892", "time_retrieved": "2024-07-30T21:14:29.105530", "image_code": "// \"Cave Dolphins\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat Minv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv3 (vec3 p);\nvec3 Hashv3v3 (vec3 p);\nfloat Noisefv3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 fishPos, ltPos, ltAx;\nvec2 trkAx, trkAy, trkFx, trkFy;\nfloat fishAngH, fishAngV, fishAngI, dstFar, tCur;\nint idObj;\nbool isSh, isPano;\nconst float pi = 3.14159;\n\nvec3 TrackPath (float t)\n{\n  return vec3 (dot (trkAx, sin (trkFx * t)), dot (trkAy, sin (trkFy * t)), t);\n}\n\nvec3 TrackVel (float t)\n{\n  return vec3 (dot (trkAx * trkFx, cos (trkFx * t)), dot (trkAy * trkFy, cos (trkFy * t)), 1);\n}\n\nfloat VPoly (vec3 p)\n{\n  vec3 ip, fp, a, w;\n  p *= 14.;\n  ip = floor (p);\n  fp = fract (p);\n  a = vec3 (4.);\n  for (float gz = -1.; gz <= 1.; gz ++) {\n    for (float gy = -1.; gy <= 1.; gy ++) {\n      for (float gx = -1.; gx <= 1.; gx ++) {\n        w = vec3 (gx, gy, gz) + 0.8 * Hashv3v3 (ip + vec3 (gx, gy, gz)) - fp;\n        a.z = dot (w, w);\n        if (a.z < a.x) a.xy = a.zx;\n        else a.y = min (a.z, a.y);\n      }\n    }\n  }\n  return sqrt (a.y - a.x);\n}\n\nfloat FishDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float szFac, dm, dBodyF, dBodyB, dMouth, dFinT, dFinP, dFinD, dEye;\n  int id;\n  szFac = 0.25;\n  dMin /= szFac;\n  p = (p - fishPos) / szFac;\n  p.xz = Rot2D (p.xz, fishAngH);\n  p.yz = Rot2D (p.yz, fishAngV);\n  p.x = abs (p.x);\n  p.z -= 0.2;\n  p.yz = Rot2D (p.yz, 0.2 * fishAngI);\n  q = p;\n  q.z -= -0.06;\n  dBodyF = PrEllipsDf (q, vec3 (0.07, 0.08, 0.24));\n  q = p;\n  q.z -= -0.12;\n  q.yz = Rot2D (q.yz, fishAngI);\n  q.z -= -0.16;\n  dBodyB = PrEllipsDf (q, vec3 (0.035, 0.05, 0.25));\n  q.z -= -0.22;\n  q.yz = Rot2D (q.yz, 2. * fishAngI);\n  q.xz -= vec2 (0.05, -0.05);\n  q.xz = Rot2D (q.xz, 0.4);\n  dFinT = PrEllipsDf (q, vec3 (0.08, 0.007, 0.04));\n  q = p;\n  q.yz -= vec2 (-0.03, 0.17);\n  q.yz = Rot2D (q.yz, 0.1);\n  q.y = abs (q.y) - 0.004;\n  dMouth = PrEllipsDf (q, vec3 (0.025, 0.012, 0.06));\n  q = p;\n  q.yz -= vec2 (0.07, -0.1);\n  q.yz = Rot2D (q.yz, 0.6);\n  dFinD = PrEllipsDf (q, vec3 (0.005, 0.1, 0.035));\n  q = p;\n  q.xy = Rot2D (q.xy, 0.8);\n  q.xz -= vec2 (0.07, -0.01);\n  q.xz = Rot2D (q.xz, 0.6);\n  dFinP = PrEllipsDf (q, vec3 (0.09, 0.004, 0.03));\n  q = p;\n  q -= vec3 (0.04, 0.01, 0.11);\n  dEye = PrSphDf (q, 0.015);\n  dm = SmoothMin (dBodyF, dBodyB, 0.03);\n  dm = SmoothMin (dm, dFinT, 0.01);\n  dm = SmoothMin (dm, dMouth, 0.015);\n  dm = SmoothMin (dm, dFinD, 0.002);\n  dm = SmoothMin (dm, dFinP, 0.002);\n  if (dm < dEye) id = 2;\n  else {\n    dm = dEye;\n    id = 3;\n  }\n  if (dm < dMin) {\n    dMin = dm;\n    idObj = id;\n  }\n  return dMin * szFac;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, db;\n  float dMin, r, b;\n  const float dSzFac = 15.;\n  q = p;\n  q.xy -= TrackPath (q.z).xy;\n  r = floor (8. * Hashfv3 (floor (q)));\n  q = fract (q);\n  if (r >= 4.) q = q.yxz;\n  r = mod (r, 4.);\n  if (mod (r, 2.) == 0.) q.x = 1. - q.x;\n  if (abs (r - 1.5) == 0.5) q.y = 1. - q.y;\n  db = vec3 (length (vec2 (length (q.xy) - 0.5, q.z - 0.5)),\n     length (vec2 (length (vec2 (q.z, 1. - q.x)) - 0.5, q.y - 0.5)),\n     length (vec2 (length (1. - q.yz) - 0.5, q.x - 0.5)));\n  dMin = 0.7 * (Minv3 (db) - 0.1 - 0.017 * VPoly (p));\n  idObj = 1; \n  if (! isSh) dMin = FishDf (p, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float ltDist)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 20; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.03 * d, h));\n    d += h;\n    if (sh < 0.05 || d > ltDist) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat WatShd (vec3 rd)\n{\n  vec2 p;\n  float t, h;\n  if (rd.y == 0.) rd.y = 0.0001;\n  p = 20. * rd.xz / rd.y;\n  t = tCur * 2.;\n  h = sin (2. * p.x + 0.77 * t + sin (0.73 * p.y - t)) + sin (0.81 * p.y - 0.89 * t +\n     sin (0.33 * p.x + 0.34 * t)) + 0.5 * (sin (1.43 * p.x - t) + sin (0.63 * p.y + t));\n  h *= 0.04 * smoothstep (0.5, 1., rd.y);\n  return h;\n}\n\nvec3 BgCol (vec3 rd)\n{\n  float t, gd, b;\n  t = tCur * 4.;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return mix (vec3 (0., 0.5, 0.8), vec3 (0.25, 0.4, 1.), 0.5 + 0.5 * rd.y) *\n     (0.24 + 0.44 * (rd.y + 1.) * (rd.y + 1.)) * (1. + gd * 0.05);\n}\n\nfloat TurbLt (vec3 p, vec3 n, float t)\n{\n  vec4 b;\n  vec2 q, qq;\n  float c, tt;\n  q = 2. * pi * mod (vec2 (dot (p.yzx, n), dot (p.zxy, n)), 1.) - 256.;\n  t += 11.;\n  c = 0.;\n  qq = q;\n  for (int j = 1; j <= 7; j ++) {\n    tt = t * (1. + 1. / float (j));\n    b = sin (tt + vec4 (- qq + vec2 (0.5 * pi, 0.), qq + vec2 (0., 0.5 * pi)));\n    qq = q + tt + b.xy + b.wz;\n    c += 1. / length (q / sin (qq + vec2 (0., 0.5 * pi)));\n  }\n  return clamp (pow (abs (1.25 - abs (0.167 + 40. * c)), 8.), 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, bgCol, vn, vno, roo, ltVec, ltDir;\n  float dstObj, ltDist, sh, atten, eDark, aDotL;\n  roo = ro;\n  isSh = false;\n  dstObj = ObjRay (ro, rd);\n  bgCol = BgCol (rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    vno = vn;\n    if (idObj == 1) {\n      col4 = vec4 (mix (vec3 (0.7, 0.75, 0.7), vec3 (0.7, 0.7, 0.75),\n         smoothstep (0.45, 0.55, Noisefv3 (41.1 * ro))), 0.3);\n      col4 *= 1. - 0.2 * Noisefv3 (19.1 * ro);\n      vn = VaryNf (64. * ro, vn, 2.);\n    } else if (idObj == 2) {\n      col4 = vec4 (vec3 (0.95, 0.8, 0.7) * (1. - 0.3 * smoothstep (-0.5, -0.4, vn.y)), 0.2);\n    } else if (idObj == 3) {\n      col4 = vec4 (0.5, 1., 0.5, -1.);\n    }\n    ltVec = roo + ltPos - ro;\n    ltDist = length (ltVec);\n    ltDir = ltVec / ltDist;\n    aDotL = dot (ltAx, - ltDir);\n    atten = min (1., 0.3 + (isPano ? smoothstep (-1., 0., aDotL) :\n       smoothstep (0.6, 0.9, aDotL)) / (1. + 0.3 * ltDist * ltDist));\n    if (col4.a >= 0.) {\n      isSh = true;\n      eDark = (idObj == 1) ? 0.8 + 0.2 * smoothstep (0.2, 0.3, VPoly (ro)) : 1.;\n      sh = ObjSShadow (ro, ltDir, ltDist);\n      col = atten * col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.) +\n         col4.a * step (0.95, sh) * pow (max (dot (reflect (rd, vn), ltDir), 0.), 64.)) * eDark;\n    } else col = col4.rgb;\n    col += 0.2 * step (0.95, sh) * TurbLt (0.05 * ro, abs (vno), 0.5 * tCur) *\n       (1. - smoothstep (0.5, 0.8, dstObj / dstFar)) * smoothstep (-0.2, -0.1, vno.y);\n    col = mix (col, bgCol, 0.1 + 0.9 * smoothstep (0., 0.85, dstObj / dstFar));\n  } else col = bgCol + WatShd (rd);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv;\n  float az, el, zmFac, fSpd, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  isPano = (mPtr.z <= 0.);\n  if (isPano) az = pi;\n  else {\n    t = mod (0.02 * tCur, 2.);\n    az = pi * SmoothBump (0.25, 0.75, 0.07, mod (t, 1.)) * (2. * floor (t) - 1.);\n  }\n  el = 0.;\n  if (! isPano && mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  if (abs (uv.y) < 0.85) {\n    trkAx = vec2 (2., 0.9);\n    trkAy = vec2 (1.3, 0.66);\n    trkFx = vec2 (0.2, 0.23);\n    trkFy = vec2 (0.17, 0.24);\n    fSpd = 0.2;\n    t = fSpd * tCur;\n    ro = TrackPath (t);\n    ro.xy += 0.05 * sin (0.05 * pi * tCur);\n    vd = normalize (TrackVel (t));\n    vuMat = StdVuMat (el + sin (vd.y), az + atan (vd.x, vd.z));\n    t += (isPano ? 0.2 : 0.4) * sign (0.5 * pi - abs (az));\n    fishPos = TrackPath (t);\n    vd = normalize (TrackVel (t));\n    fishAngH = atan (vd.x, vd.z);\n    fishAngV = sin (vd.y);\n    fishAngI = 0.1 * sin (pi * tCur);\n    zmFac = isPano ? 0.6 : 2.2;\n    uv /= zmFac;\n    rd = vuMat * normalize (isPano ? vec3 (sin (uv.x + vec2 (0., 0.5 * pi)), uv.y).xzy : vec3 (uv, 1.));\n    ltPos = vuMat * vec3 (0., 0.3, 0.);\n    ltAx = vuMat * vec3 (0., 0., 1.);\n    dstFar = 16.;\n    col = ShowScene (ro, rd);\n  } else col = vec3 (0.);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec3 Hashv3v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec3 (0., cHashVA3.xy)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSyRD.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[659, 659, 685, 685, 766], [768, 768, 793, 793, 890], [892, 892, 914, 914, 1354], [1356, 1356, 1391, 1391, 2865], [2867, 2867, 2889, 2889, 3491], [3493, 3493, 3526, 3526, 3702], [3704, 3704, 3725, 3725, 3973], [3975, 3975, 4026, 4026, 4262], [4264, 4264, 4288, 4288, 4619], [4621, 4621, 4643, 4643, 5063], [5065, 5065, 5105, 5105, 5565], [5567, 5567, 5602, 5602, 7247], [7249, 7249, 7302, 7302, 8757], [8759, 8759, 8792, 8792, 8819], [8820, 8820, 8855, 8855, 8917], [8919, 8919, 8941, 8941, 8979], [8981, 8981, 9026, 9026, 9129], [9131, 9131, 9188, 9188, 9271], [9273, 9273, 9309, 9309, 9515], [9517, 9517, 9547, 9547, 9660], [9694, 9694, 9718, 9718, 9783], [9785, 9785, 9809, 9809, 9939], [9941, 9941, 9965, 9965, 10083], [10085, 10085, 10109, 10109, 10329], [10331, 10331, 10356, 10356, 10542], [10544, 10544, 10569, 10569, 10794], [10796, 10796, 10825, 10825, 11037], [11039, 11039, 11078, 11078, 11258]], "test": "untested"}
{"id": "wdBczW", "name": "Noise test for academic use", "author": "Leria", "description": "Testing to implement noise", "tags": ["test", "noise"], "likes": 0, "viewed": 182, "published": 3, "date": "1586183482", "time_retrieved": "2024-07-30T21:14:29.876469", "image_code": "#define size2 2\n#define size3 3\n\n//Begin lerp\nfloat linear_interpolation(float x, float low, float high)\n{\n    return (1.0 - x)*low + x*high;\n}\n//End lerp\n\n//Begin unexval\nfloat unexpected_value(){return (iTimeDelta);}\n//End unexval\n\n\n//Begin Fade\nhighp float fade(float t) { return t * t * t * (t * (t * 6.0 - 15.0) + 10.0); }\n//End Fade\n\n//Begin some random function\nfloat stochastic_float(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n//End some random function\n\n\nfloat noise(vec2 coord)\n{\n    vec2 tmp_coord = floor(coord);\n    \n    coord -= tmp_coord;\n    \n    vec2 uv = vec2(fade(coord.x), fade(coord.y));\n    \n    float out_value = mix(\n        \tmix(stochastic_float(tmp_coord), stochastic_float(tmp_coord+vec2(1,0)), uv.x),\n            mix(stochastic_float(tmp_coord+vec2(0,1)), stochastic_float(tmp_coord+vec2(1,1)), uv.x),\n    \t\tcoord.y);\n                                              ;\n                                            \n   \treturn out_value;\n}\n\n\n//Begin MainImage\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    fragCoord /= 5.0;\n    float lambda = noise(fragCoord);\n\tfragColor = vec4(lambda, lambda, lambda, 1.);\n}\n//End MainImage", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdBczW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 46, 106, 106, 143], [156, 172, 197, 197, 218], [340, 369, 402, 402, 474], [504, 504, 529, 529, 1002], [1005, 1023, 1080, 1080, 1189]], "test": "untested"}
{"id": "wsSczW", "name": "Rotating Voronoise", "author": "nickcody", "description": "Compliments the great Voronoise/noise combo algorithm by Inigo Quilez.\n\nClick on four qudrants to adjust u/v as in http://iquilezles.org/articles/voronoise/voronoise.htm", "tags": ["noise", "voronoise"], "likes": 4, "viewed": 340, "published": 3, "date": "1586183305", "time_retrieved": "2024-07-30T21:14:30.636437", "image_code": "float u_rotated_scale        = 0.05;\nfloat u_primary_scale        = 0.01;\nfloat u_rot_left_timescale   = 0.1;\nfloat u_rot_right_timescale  = 0.2;\nfloat u_timescale            = 0.1;\nint   u_showComponents       = 0;\n\n// Voronoise\n// https://iquilezles.org/articles/voronoise\n// by inigo quilez\n//\nvec3 hash3( vec2 p ){\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)),\n    dot(p,vec2(269.5,183.3)),\n    dot(p,vec2(419.2,371.9)) );\n    return fract(sin(q)*43758.5453);\n}\n\nfloat iqnoise( in vec2 x, float u, float v ){\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    float k = 1.0+63.0*pow(1.0-v,4.0);\n\n    float va = 0.0;\n    float wt = 0.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n        vec3 o = hash3( p + g )*vec3(u,u,1.0);\n        vec2 r = g - f + o.xy;\n        float d = dot(r,r);\n        float ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n        va += o.z*ww;\n        wt += ww;\n    }\n\n    return va/wt;\n}\n\nvec2 rotate(vec2 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    return m * v;\n}\n\nvec2 rotateOrigin(vec2 v, vec2 center, float a) {\n    vec2 t = v - center;\n    vec2 r = rotate(t, a);\n    return r + center;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 white = vec3(1.0, 1.0, 1.0);\n    vec3 black = vec3(0.0, 0.0, 0.0);\n\n    vec2 rotated_resolution = iResolution.xy * u_rotated_scale;\n    vec2 primary_resolution = iResolution.xy * u_primary_scale;\n\n    vec2 rotated_fragCoord = fragCoord.xy * u_rotated_scale;\n    vec2 primary_fragCoord = fragCoord.xy * u_primary_scale;\n\n    vec2 left_rotated_center = rotated_resolution.xy/4.0;\n    vec2 right_rotated_center = 3.0 * rotated_resolution.xy/4.0;\n    vec2 primary_center = primary_resolution.xy/2.0;\n\n    float time3d     = iTime * u_timescale;\n    float timeLeft   = iTime * u_rot_left_timescale;\n    float timeRight  = iTime * u_rot_right_timescale;\n\n    vec2 coord0 = vec2( rotateOrigin(primary_fragCoord, primary_center,time3d));\n    vec2 coord1 = vec2( rotateOrigin(rotated_fragCoord, left_rotated_center, timeLeft));\n    vec2 coord2 = vec2( rotateOrigin(rotated_fragCoord, right_rotated_center, timeRight));\n\n    vec2 uv = iMouse.xy/iResolution.xy;\n    float n0 = iqnoise(coord0, uv.x, uv.y);\n    float n1 = iqnoise(coord1, uv.x, uv.y);\n    float n2 = iqnoise(coord2, uv.x, uv.y);\n\n    vec3 color;\n\n    if (u_showComponents == 0) {\n        float brighten = 1.5;\n        float c = (n1+n2)/2.0;\n        float n = iqnoise(coord0 * c, 0.0, 1.0);\n\n        vec3 col = 0.5 + 0.5*cos(iTime+coord0.xyx+vec3(0,2,4));\n\n        color = mix(vec3(n, n, n), col, c);\n    } else {\n        color = vec3(n0, n1, n2);\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsSczW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[217, 297, 318, 318, 464], [466, 466, 511, 511, 987], [989, 989, 1019, 1019, 1115], [1117, 1117, 1166, 1166, 1243], [1245, 1245, 1302, 1302, 2755]], "test": "untested"}
{"id": "wsBcRW", "name": "Hyperbolic Pappus", "author": "mla", "description": "Pappus' theorem on the hyperbolic plane, using the hyperboloid model.", "tags": ["hyperbolic", "pappus", "hyperboloid"], "likes": 6, "viewed": 357, "published": 3, "date": "1586180129", "time_retrieved": "2024-07-30T21:14:31.408373", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Pappus's theorem on Hyperbolic Plane.\n//\n// Doing geometry on the hyperbolic plane.\n//\n// No animation, just the mouse, which moves things around.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nbool halfspace = false; // Set true for the half-plane model!\n\nfloat rdot(vec3 r1, vec3 r2) {\n  // Minkowski inner product\n  return dot(vec3(1,1,-1)*r1,r2);\n}\n\n// Normalize a point\nvec3 hnormalize(vec3 p) {\n  if (p.z < 0.0) p = -p;\n  return p/sqrt(-rdot(p,p));\n}\n\n// Normalize a line\nvec3 lnormalize(vec3 p) {\n  return p/sqrt(rdot(p,p));\n}\n\n// Distance from point\n// cosh(x) = y = 1 + 0.5*x*x + O(x^4)\n// so for x close to 1 (so y is small)\n// acosh(y) = x = sqrt(2*(y-1)) is good approximation\nfloat hpoint(vec3 p, vec3 q) {\n  //return acosh(-rdot(p,q));\n  return sqrt(-2.0*(rdot(p,q)+1.0));\n}\n\n// Distance from line\nfloat hline(vec3 p, vec3 q) {\n  return abs(rdot(p,q));\n}\n\n// We want that rdot(p,hcross(p,q)) = rdot(q,hcross(p,q)) = 0\nvec3 hcross(vec3 p, vec3 q) {\n  return cross(p,q)*vec3(-1,-1,1);\n}\n\nvec3 linejoin(vec3 p, vec3 q) {\n  return lnormalize(hcross(p,q));\n}\n\nvec3 pointjoin(vec3 p, vec3 q) {\n  return hnormalize(hcross(p,q));\n}\n\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 color(vec3 p, float time) {\n  vec3 col = vec3(0.2);\n  vec3 A0 = hnormalize(vec3(-0.5,0.8,1));\n  vec3 C0 = hnormalize(vec3(0.4,0.9,1));\n  float k0 = 0.5;\n  vec3 B0 = hnormalize(k0*A0+(1.0-k0)*C0);\n  vec3 A1 = hnormalize(vec3(-0.5,-0.8,1));\n  vec3 C1 = hnormalize(vec3(0.9,-0.3,1));\n  float k1 = 0.6;\n  vec3 B1 = hnormalize(k1*A1+(1.0-k1)*C1);\n  vec3 L0 = linejoin(A0,C0);\n  vec3 L1 = linejoin(A1,C1);\n  vec3 AB0 = linejoin(A0,B1);\n  vec3 AB1 = linejoin(A1,B0);\n  vec3 BC0 = linejoin(B0,C1);\n  vec3 BC1 = linejoin(B1,C0);\n  vec3 CA0 = linejoin(C0,A1);\n  vec3 CA1 = linejoin(C1,A0);\n  vec3 P = pointjoin(AB0,AB1);\n  vec3 Q = pointjoin(BC0,BC1);\n  \n  if (true) {\n    float d = 1e8;\n    d = min(d,hline(p,L0));\n    d = min(d,hline(p,L1));\n    d = min(d,hline(p,AB0));\n    d = min(d,hline(p,AB1));\n    d = min(d,hline(p,BC0));\n    d = min(d,hline(p,BC1));\n    d = min(d,hline(p,CA0));\n    d = min(d,hline(p,CA1));\n    d = min(d,hline(p,linejoin(P,Q)));\n    col = mix(vec3(1,1,0),col,smoothstep(0.01,0.02,d));\n  }\n  if (true) {\n    float d = 1e8;\n    d = min(d,hpoint(p,A0));\n    d = min(d,hpoint(p,B0));\n    d = min(d,hpoint(p,C0));\n    d = min(d,hpoint(p,A1));\n    d = min(d,hpoint(p,B1));\n    d = min(d,hpoint(p,C1));\n    d = min(d,hpoint(p,P));\n    d = min(d,hpoint(p,Q));\n    d = min(d,hpoint(p,pointjoin(CA0,CA1)));\n    col = mix(vec3(1,0,0),col,smoothstep(0.05,0.06,d));\n  }\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 aacol = vec3(0);\n  float AA = 2.0;\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      // Normalized pixel coordinates (from 0 to 1)\n      vec2 z = (2.0 * (fragCoord+vec2(i,j)/AA) - iResolution.xy)/iResolution.y;\n      if (halfspace) {\n        z.y += 2.0;\n        z *= 2.0/dot(z,z);\n        z.y -= 1.0;\n      }\n      if (iMouse.x > 0.0) {\n        vec2 m = (2.0 * iMouse.xy -iResolution.xy) / iResolution.y;\n        // Map origin to m with an inversion\n        float k = 1.0/dot(m,m);\n        vec2 c = k*m; // m inverted in unit circle\n        z -= c;\n        z *= (k-1.0)/dot(z,z);\n        z += c;\n        z.x = -z.x;\n      }\n      z = rotate(z,0.1*iTime);\n      float r2 = dot(z,z);\n      vec3 col = vec3(0);\n      if (r2 < 1.0) {\n        vec3 p = vec3(2.0*z,1.0+r2)/(1.0-r2);\n        col = color(p,iTime*0.2);\n      }\n      aacol += col;\n    }\n  }\n  fragColor = vec4(aacol/(AA*AA),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsBcRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[382, 382, 412, 441, 477], [479, 500, 525, 525, 581], [583, 603, 628, 628, 658], [660, 814, 844, 874, 913], [915, 937, 966, 966, 993], [995, 1057, 1086, 1086, 1123], [1125, 1125, 1156, 1156, 1192], [1194, 1194, 1226, 1226, 1262], [1264, 1264, 1300, 1300, 1352], [1354, 1354, 1386, 1386, 2749], [2751, 2751, 2808, 2808, 3736]], "test": "untested"}
{"id": "WsSczD", "name": "Morphahedron", "author": "Shapkofil", "description": "Morphing between a sphere and a octahedron using a simple displacement transition", "tags": ["raymarching", "simple", "displacement", "sphere", "spheretracing", "octahedron"], "likes": 2, "viewed": 374, "published": 3, "date": "1586169689", "time_retrieved": "2024-07-30T21:14:32.247130", "image_code": "float max_distance = 1000.;\nfloat plank = .001;\nint max_iter = 128;\nfloat EPSILON = .001;\n\n\n\n\nfloat displacement(vec3 p, float scale)\n{\n    return sin(scale*p.x)*sin(scale*p.y)*sin(scale*p.z);\n}\n\nfloat octahedronSDF( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\nfloat sceneSDF(vec3 p)\n{\n    return (length(p) - .8)*(cos(iTime)*.5+.5) + octahedronSDF(p,.8)*(cos(iTime+3.14)*.5+.5) + (sin(iTime * 2. - 3.14*.5)*.5+.5) * displacement(p,5.) / 3.;\n}\n\nvec3 estimateNormal(vec3 p)\n{\n\treturn normalize(vec3(\n\t\tsceneSDF(vec3(p.x+EPSILON,p.y,p.z)) - sceneSDF(vec3(p.x-EPSILON,p.y,p.z)),\n\t\tsceneSDF(vec3(p.x,p.y+EPSILON,p.z)) - sceneSDF(vec3(p.x,p.y-EPSILON,p.z)),\n\t\tsceneSDF(vec3(p.x,p.y,p.z+EPSILON)) - sceneSDF(vec3(p.x,p.y,p.z-EPSILON))\n\t\t));\n}\n\nvec3 calculateDeffuse(vec3 p)\n{\n\tvec3 deffuse = vec3(0, 0, 0);\n    vec3 normal = estimateNormal(p);\n    vec3 lightdir = normalize(vec3(2.,2.,-3.) - p);\n    float diff = max(dot(normal,lightdir),0.0);\n    deffuse += diff * (1.,1.,1.);\n\treturn deffuse;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2. - iResolution.xy)/iResolution.x;\n    vec3 rd = vec3(uv, 1.);\n    \n    vec3 ro = vec3(.0,0.,-3.);\n    \n    vec3 col = vec3(167, 147, 204);\n    \n    for(int iter=0; iter<max_iter; iter++)    \n    {\n        float curr = sceneSDF(ro);\n        \n        //Hit condition\n        if(plank > curr)\n        {\n            col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n            col*= (.1 + calculateDeffuse(ro));\n        }\n            \n        \n        ro += rd*curr;\n    }\n        \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsSczD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 135, 135, 194], [196, 196, 235, 235, 288], [289, 289, 313, 313, 471], [473, 473, 502, 502, 764], [766, 766, 797, 797, 1018], [1024, 1024, 1081, 1131, 1692]], "test": "untested"}
{"id": "3dd3RB", "name": "Jeux de la Vie (John Conway)", "author": "pascalballet", "description": "Implémentation très simple du jeux de la vie. Very simple Game Of Life implementation.", "tags": ["gameoflife"], "likes": 0, "viewed": 301, "published": 3, "date": "1586167041", "time_retrieved": "2024-07-30T21:14:33.106832", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xyz; // Lecture du buffer\n    fragColor = vec4(col,1.0); // Ecriture dans l'image courante (ViewPort)\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Génération d'un nombre aléatoire\n// en fonction de la position dans le buffer\n// Pour plus d'info voir https://www.shadertoy.com/view/XtX3D4\n// Thanks to Michael Pohoreski https://www.shadertoy.com/user/MichaelPohoreski\nfloat random( vec2 p )\n{\n    vec2 K1 = vec2(23.14069263277926, 2.665144142690225); // 23.14=e^pi (Gelfond's constant) et 2.66=2^sqrt(2) (Gelfond–Schneider constant)\n    return fract( cos( dot(p,K1) ) * 12345.6789 );\n}\n\n// Fonction principale\n// du Jeux de la Vie\n// par John Conway vers l'année 1965\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col;\n    if( iFrame == 0 ) { // Initialisation\n        if(random(fragCoord) < 0.5) {\n    \t\tcol = vec3(0.0, 0.0, 0.0);\n        } else {\n            col = vec3(1.0, 1.0, 1.0);\n        }\n    } else { // Execution\n     \tcol = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xyz;\n        vec3 col_g = texelFetch( iChannel0, ivec2(fragCoord + vec2(-1.0, 0.0) ), 0 ).xyz;\n        vec3 col_d = texelFetch( iChannel0, ivec2(fragCoord + vec2( 1.0, 0.0) ), 0 ).xyz;\n        vec3 col_h = texelFetch( iChannel0, ivec2(fragCoord + vec2( 0.0, 1.0) ), 0 ).xyz;\n        vec3 col_b = texelFetch( iChannel0, ivec2(fragCoord + vec2( 0.0,-1.0) ), 0 ).xyz;\n        vec3 col_gb = texelFetch( iChannel0, ivec2(fragCoord + vec2(-1.0,-1.0) ), 0 ).xyz;\n        vec3 col_db = texelFetch( iChannel0, ivec2(fragCoord + vec2( 1.0,-1.0) ), 0 ).xyz;\n        vec3 col_gh = texelFetch( iChannel0, ivec2(fragCoord + vec2(-1.0, 1.0) ), 0 ).xyz;\n        vec3 col_dh = texelFetch( iChannel0, ivec2(fragCoord + vec2( 1.0, 1.0) ), 0 ).xyz;\n        \n        int nbVivants = 0;\n        if( col_g == vec3(1.0,1.0,1.0)) nbVivants++;\n        if( col_d == vec3(1.0,1.0,1.0)) nbVivants++;\n        if( col_h == vec3(1.0,1.0,1.0)) nbVivants++;\n        if( col_b == vec3(1.0,1.0,1.0)) nbVivants++;\n        if( col_gb == vec3(1.0,1.0,1.0)) nbVivants++;\n        if( col_db == vec3(1.0,1.0,1.0)) nbVivants++;\n        if( col_gh == vec3(1.0,1.0,1.0)) nbVivants++;\n        if( col_dh == vec3(1.0,1.0,1.0)) nbVivants++;\n        \n        if(col == vec3(0.0, 0.0, 0.0) ) { // MORT\n            if( nbVivants == 3) col = vec3(1.0, 1.0, 1.0); // NAISSANCE\n        } else { // VIVANT\n   \t\t\tif( nbVivants < 2) col = vec3(0.0, 0.0, 0.0); // MORT PAR ISOLEMENT\n            if( nbVivants == 2 || nbVivants == 3) col = vec3(1.0, 1.0, 1.0);\n            if( nbVivants > 3) col = vec3(0.0, 0.0, 0.0); // MORT PAR SURPOPULATION\n        }\n    }    \n    fragColor = vec4(col, 1.0); // Ecriture de la nouvelle cellule dans le buffer de sortie\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dd3RB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 221]], "test": "untested"}
{"id": "3dByRD", "name": "Julia Glassblower Recoloured", "author": "mla", "description": "Variant on [url]https://www.shadertoy.com/view/tdjczh[/url] - a more colourful background, also added mouse rotation.", "tags": ["glassblower"], "likes": 6, "viewed": 423, "published": 3, "date": "1586162002", "time_retrieved": "2024-07-30T21:14:33.869792", "image_code": "// Created by David Gallardo - xjorma/2019\n// Modified Matthew Arcus - mla/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#if HW_PERFORMANCE==0\n#else\n#define AA\n#endif\n\n#define BIASED_NORMAL \t1\n#define MAX_BOUNCES     4\n#define MAX_DIST\t\t4.\n#define ABSORB\t\t\tvec3(0., 0.5, 1.3)\n\nconst int maxIterations = 6;\n\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat saturate(float c)\n{\n    return clamp(c,0.,1.);\n}\n\n\n// http://www.cs.cmu.edu/~kmcrane/Projects/QuaternionJulia/paper.pdf\n\nvec4 quatMult( vec4 q1, vec4 q2 )\n{\n    vec4 r;\n    r.x = q1.x*q2.x - dot( q1.yzw, q2.yzw );\n    r.yzw = q1.x*q2.yzw + q2.x*q1.yzw + cross( q1.yzw, q2.yzw );\n    return r;\n}\n\nvec4 quatSq( vec4 q )\n{\n    vec4 r;\n    r.x = q.x*q.x - dot( q.yzw, q.yzw );\n    r.yzw = 2.*q.x*q.yzw;\n    return r;\n}\n\n#define ESCAPE_THRESHOLD 1e1\n\nvoid iterateIntersect( inout vec4 q, inout vec4 qp, vec4 c, int maxIterations )\n{\n    for( int i=0; i<maxIterations; i++ )\n    {\n        qp = 2.0 * quatMult(q, qp);\n        q = quatSq(q) + c;\n        if( dot( q, q ) > ESCAPE_THRESHOLD )\n        {\n            break;\n        }\n    }\n}\n\n\nfloat map(in vec3 p)\n{\n    vec4 z = vec4( p, 0 );\n\tvec4 zp = vec4( 1, 0, 0, 0 );\n    float t = iTime * 0.1;\n    vec4 c = 0.5*vec4(cos(t),cos(t*1.1),cos(t*2.3),cos(t*3.1));\n\titerateIntersect( z, zp, c, maxIterations );\n\tfloat normZ = length( z );\n\tfloat d = 0.5 * normZ * log( normZ ) / length( zp ); //lower bound on distance to surface\n    return d;\n}\n\n\nvec3 getSkyColor(vec3 rd)\n{\n    return rd;\n    //vec3 col = texture(iChannel0, rd).rgb;\n    //return col*col;\n}\n\n\nfloat rayMarch(in float sgn, in vec3 ro, in vec3 rd, in float offT)\n{\n  float t = offT;\n  for (int i = 0; i < 60; i++)\n  {\n    float h = sgn * map(ro + rd * t);\n    t += h;\n    if (h < 0.001 || t > MAX_DIST)\n        break;\n  }\n  return t;\n}\n\n#define EPS  0.02\n\n#if BIASED_NORMAL\nvec3 calcNormal(vec3 pos)\n{\n    float\tref;\n    float\ttrans;\n    vec3\tabsorb;\n    vec3\tcol;\n    vec2\teps = vec2(EPS, 0);\n\tfloat d = map(pos);\n\treturn normalize(vec3(map(pos + eps.xyy) - d, map(pos + eps.yxy) - d, map(pos + eps.yyx) - d));\n}\n#else\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = EPS;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ) );\n}\n#endif\n\nvec3 Render(in vec3 ro, in vec3 rd)\n{\n    float sgn = 1.;\n    float cref = 0.7;\n    vec3  col = vec3(0);\n    vec3  rel = vec3(1);\n    float transp = 0.9;\n    vec3  absorb = ABSORB;\n    for(int i = 0; i < MAX_BOUNCES; i++)\n    {\n        float t = rayMarch(sgn, ro, rd, 0.02);\n        if( t> MAX_DIST)\n        {\n            col += rel * getSkyColor(rd);\n            break;\n        }\n        vec3 rabs = mix(absorb, vec3(0), (sgn + 1.) / 2.);\n        vec3 beerlamb = exp(-rabs * t);\n        vec3 p = ro + rd * t;\n        vec3 n = sgn * calcNormal(p);\n        vec3 refl = reflect(rd, n);\n        vec3 refr = refract(rd, n, cref);\n        //float fresnel = 1.0 - pow(dot(n, -rd), 2.);\n        float fresnel = pow(1.0 - abs(dot(n, rd)), 2.0);\n        float reflectorFactor = mix (0.2, 1.0, fresnel);\n        float refractionFactor = mix (transp, 0., fresnel);\n    \n    \tcol += (1.0 - refractionFactor) * rel * beerlamb * getSkyColor(refl) * reflectorFactor;\n    \trel *= refractionFactor * beerlamb;     \n        \n       \tro = p;     \n        if (refr == vec3(0.0))\n        {\n            rd = refl;\n        }\n        else\n        {\n            rd = refr; \n            sgn *= -1.;\n            cref = 1. / cref;\n        }        \n    }\n    col += rel * getSkyColor(rd);\n    return col;\n}\n\nvec3 contrast( in vec3 color, in float c)\n{\n    float t = 0.5 - c * 0.5; \n    return color * c + t;\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvec3 postProcess(in vec3 col, in vec2 q)\n{\n\tcol = pow(col, vec3(0.9));\n\tcol = contrast(col, 1.2);\n\t//col = vignette(col, q, 0.8);\n\treturn col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nmat3 genMat(in vec3 dir,in vec3 up)\n{\n\tvec3 cw = normalize(dir);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nbool dorotate = true;\nfloat PI = 3.14159;\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = -(2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = -(2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,-theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  if (dorotate) {\n    float t = iTime;\n    p.yz = rotate(p.yz,t*0.125);\n    p.zx = rotate(p.zx,t * 0.2);\n  }\n  return p;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 tot = vec3(0.0);\n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n        //float theta\t= radians(90. + iTime*10.);\n        //float phi\t= radians(90.);\n        \n        //float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5);\n        //float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5)-1.;\n        //float theta\t= radians(90.);\n        //float phi\t= radians(50.);\n        vec3 ro = 2.0*vec3(0,0,1); //vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n\n        ro = transform(ro);\n        rd = transform(rd);\n        rd = normalize(rd);\n        vec3 col = Render(ro ,rd);\n        \n\n        tot += col;\n            \n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n        \n    tot = postProcess(tot,fragCoord / iResolution.xy);\n    \n\tfragColor = vec4( sqrt(tot), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dByRD.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[337, 386, 421, 421, 445], [447, 447, 472, 472, 501], [574, 574, 609, 609, 747], [749, 749, 772, 772, 867], [899, 899, 980, 980, 1182], [1185, 1185, 1207, 1207, 1537], [1540, 1540, 1567, 1567, 1651], [1654, 1654, 1723, 1723, 1894], [2451, 2451, 2488, 2488, 3729], [3731, 3731, 3774, 3774, 3832], [3834, 3834, 3878, 3878, 3977], [3979, 3979, 4021, 4021, 4123], [4126, 4126, 4168, 4168, 4332], [4334, 4334, 4371, 4371, 4507], [4508, 4508, 4544, 4544, 4596], [4641, 4641, 4668, 4668, 5010]], "test": "untested"}
{"id": "WdSczW", "name": "color depth aberration illusion ", "author": "FabriceNeyret2", "description": "Because refraction index of our eye lens is wavelength dependent, blue rays focalise before red rays, as if coming from further away. Depth difference is about 16mm at 80cm... if pupil not too open (since a counter effect then appears). Better in fullscre", "tags": ["illusion", "perception"], "likes": 6, "viewed": 384, "published": 3, "date": "1586156823", "time_retrieved": "2024-07-30T21:14:34.702565", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 5.*(u-.5*R)/R.y, U0 = U;\n\n    U = fract(U)*2.-1.;                        // tiling\n    float y = U0.y,\n          v = length(U)-.5;                    // disks\n    v /= fwidth(v);                            // antialiasing\n    if (U0.x<0.) v = 1.-v;                     // left: change background instead\n    if (abs(U0.x)<1.) y=0.;                    // central colum: blue instead or red/green\n    O = mix(vec4( y>0., y<0., y==0., 0),       // bottom: green instead of red\n            vec4( 0, 0, abs(U0.x)>2., 0),      // mid columns: black instead of blue\n            clamp(v,0.,1.));\n    \n    if ( abs(y)>1.5 && (int(u.x/2.)+int(u.y/2.)) % 2 == 0 ) O *= .8;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdSczW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WdByRW", "name": "Voxel Flower", "author": "Roninkoi", "description": "Trying to figure out voxels", "tags": ["raymarching", "flower", "voxel"], "likes": 6, "viewed": 468, "published": 3, "date": "1586147673", "time_retrieved": "2024-07-30T21:14:35.470512", "image_code": "#define PI 3.14159265\n#define MAXIT 180\n#define EPSILON 0.05\n \n#define minx4(a, b) ((a.w) < (b.w) ? (a) : (b))\n#define minx2(a, b) ((a.x) < (b.x) ? (a) : (b))\n\nmat3 rotX(float a)\n{\n    return mat3(\n        1., 0., 0.,\n        0., cos(a), -sin(a),\n        0., sin(a), cos(a)\n    );\n}\n \nmat3 rotY(float a)\n{\n    return mat3(\n        cos(a), 0.0, -sin(a),\n        0., 1., 0.,\n        sin(a), 0.0, cos(a)\n    );\n}\n \nmat3 rotZ(float a)\n{\n    return mat3(\n        cos(a), -sin(a), 0.,\n        sin(a), cos(a), 0.,\n        0., 0., 1.\n    );\n}\n \nfloat t;\n \nfloat sphere(vec3 r, float a)\n{\n    return length(r) - a;\n}\n \nfloat torus(vec3 r, vec2 a)\n{\n    vec2 p = vec2(length(r.xz) - a.x, r.y);\n    return length(p) - a.y;\n}\n \nfloat plane(vec3 r, vec3 o, vec3 n) {\n    return dot(r - o, n);\n}\n\nfloat cylinder(vec3 r, vec2 a)\n{\n\tvec2 p = abs(vec2(length(r.xz), r.y)) - a;\n\t\n\treturn min(max(p.x, p.y), 0.0) + length(max(p, 0.));\n}\n \nfloat bud(vec3 r, float a)\n{\n\tr.xz += cos((r.y + r.z) * 3.) * 0.2;\n\t\n\tr.y += sin(length(r.xzx) * 6.) * 0.2;\n\t\n    return length(r) - a + sin(length(r.xz) * 12.) * 0.4;\n}\n\nfloat stem(vec3 r, vec2 a)\n{\n\tr.xz += cos(r.y) * 0.15 + sin(r.y * 1.5) * 0.3;\n\tr.xz += cos(r.y * 0.25) * 1.;\n\t\n\tvec2 p = abs(vec2(length(r.xz), r.y)) - a;\n\t\n\treturn min(max(p.x, p.y), 0.0) + length(max(p, 0.));\n}\n\nfloat leaf(vec3 r, vec3 a)\n{\n\tr.xz += sin(length(r.xz + 1.) * 1.5);\n\tr.y += (r.x + r.z) * 0.5;\n\tr.x *= 0.9;\n\t\n    vec3 p = abs(r) - a;\n\t\n    return length(max(p, 0.));\n}\n\nfloat box(vec3 r, vec3 a)\n{\n    vec3 p = (abs(r) - a);\n    return length(max(p, 0.));\n}\n \nfloat shade(vec3 n, vec3 rd)\n{\n    return clamp(max(dot(n, -rd), 0.) + 1., 0., 1.);\n}\n \nvec3 fog(float z, vec3 col, vec3 fogCol)\n{\n    return mix(fogCol, col, exp(-z));\n}\n \nfloat hash(vec2 r) {\n    return fract(sin(dot(r, vec2(15.5921, 96.654654))) * 23626.3663);\n}\n\nmat3 obj;\n \nvec2 map(vec3 r)\n{\n    float b = 0.05;\n    vec3 rr = vec3(0.);\n    rr.x = floor(r.x / b) * b;\n    rr.y = floor(r.y / b) * b;\n    rr.z = floor(r.z / b) * b;\n\t\n    vec3 rb1 = obj * rr;\n    \n    vec2 b1 = vec2(\n        bud(rotX(0.6) * rotZ(-0.1) * rb1, 2.),\n        (int(sin(rb1.xyz * 5.) * cos(rb1.yxz * 5.) * 2.) % 2)\n    );\n\tvec2 s1 = vec2(\n        stem(rb1 + vec3(0., 7., 1.), vec2(.3, 6.81)),\n        (int(sin(rb1.y * 3.1) * 2.) % 2) + 2\n    );\n\t\n\tvec2 l1 = vec2(\n        leaf(rb1 + vec3(1.5, 5., 2.2), vec3(1., 0.1, 1.0)),\n        (int(sin(rb1.x * rb1.z * 4.1) * 2.) % 2) + 4\n    );\n    \n    return minx2(l1, minx2(b1, s1));\n}\n\nvec3 matCol(vec2 o)\n{\n    if (o.y == 0.)\n        return normalize(vec3(1., 0., .0));\n   \n    if (o.y == 1.)\n        return normalize(vec3(1.1, 0., .6));\n    \n    if (o.y == 2.)\n        return (vec3(0.4, .5, 0.));\n    \n    if (o.y == 3.)\n        return normalize(vec3(.2, 1., 0.4));\n    \n    if (o.y == 4.)\n        return (vec3(0.8, .5, 0.));\n    \n    if (o.y == 5.)\n        return normalize(vec3(.5, .5, 0.));\n   \n    return vec3(0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    t = -iTime * 0.4;\n    \n    obj = rotY(t);\n    obj *= mat3(2.);\n   \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n   \n    mat3 cam = rotY(-PI) * rotX(0.3);\n       \n    vec3 ro = vec3(0., 0.5, -3.3);\n    vec3 rd = cam * normalize(vec3(uv * 2., -1.));\n    vec3 r = ro;\n   \n    vec3 bcol = normalize(vec3(.8, 2., 0.7)) * (.7 + cos(length(uv.xy) * 1.5) * .6) * 0.8;\n    vec4 col = vec4(0.);\n    col.rgb = bcol;\n   \n    float sh = 1.;\n   \n    for (int i = 0; i < MAXIT; ++i) {\n        vec2 d = map(r);\n        float z = length(r - ro);\n       \n        if (d.x < EPSILON) {\n            col.rgb = mix(col.rgb, \n\t\t\t\tmatCol(d), \n\t\t\t\tshade(normalize(r), rd));\n            col.rgb = fog(z * 0.1, col.rgb, bcol);\n            break;\n        }\n       \n        d.x *= 0.7 - 0.1 * hash(uv);\n\t\tr += rd * d.x * 0.15;\n       \n        sh = (float(i) / float(MAXIT));\n    }\n   \n    if (sh < 0.8)\n\t\tcol.rgb *= exp(-sqrt(sh) * 1.2);\n   \n    fragColor = vec4(col.rgb, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdByRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 160, 180, 180, 282], [285, 285, 305, 305, 409], [412, 412, 432, 432, 534], [548, 548, 579, 579, 607], [610, 610, 639, 639, 713], [716, 716, 753, 753, 781], [783, 783, 815, 815, 917], [920, 920, 948, 948, 1089], [1091, 1091, 1119, 1119, 1303], [1305, 1305, 1333, 1333, 1474], [1476, 1476, 1503, 1503, 1563], [1566, 1566, 1596, 1596, 1651], [1654, 1654, 1696, 1696, 1736], [1739, 1739, 1759, 1759, 1831], [2476, 2476, 2497, 2497, 2912]], "test": "untested"}
{"id": "ts2yR1", "name": "Broken Meow", "author": "michael0884", "description": "Kinda ray marching a cat mesh, meow.", "tags": ["triangles", "marching", "graph", "mesh"], "likes": 10, "viewed": 390, "published": 3, "date": "1586137471", "time_retrieved": "2024-07-30T21:14:36.422966", "image_code": "//Graph is in Buf A, graph traversal is in Buf B\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    fragColor = texel(ch1, pos);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define N ivec2(10,42)\n#define sN ivec2(32,2)\n#define dt 0.\n\n#define loop(x) for(int i = min(0, iFrame); i < x; i++)\n\nconst int tot_n = N.x*N.y;\n\nivec2 i2xy(ivec3 sid)\n{\n    return sN*ivec2(sid.x%N.x, sid.x/N.x) + sid.yz;\n}\n\nivec3 xy2i(ivec2 p)\n{\n    ivec2 pi = p/sN;\n    return ivec3(pi.x + pi.y*N.x, p.x%sN.x, p.y%sN.y);\n}\n\nfloat F(float d)\n{\n    return 1./(0.1*d*d+1.) - 1.*exp(-1.*d);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nconst int k = 1664525;  \n\nivec4 hash( ivec4 x )\n{\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    return ivec4(x);\n}\n\n#define link0 32\n\nconst float PHI = 0.5*(sqrt(5.) + 1.);\n\nvec2 inverseSF( vec3 p, float n ) \n{\n    float m = 1.0 - 1.0/n;\n    \n    float phi = min(atan(p.y, p.x), PI), cosTheta = p.z;\n    \n    float k  = max(2.0, floor( log(n * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))/ log(PHI+1.0)));\n    float Fk = pow(PHI, k)/sqrt(5.0);\n    vec2  F  = vec2( round(Fk), round(Fk * PHI) ); // k, k+1\n\n    vec2 ka = 2.0*F/n;\n    vec2 kb = 2.0*PI*( fract((F+1.0)*PHI) - (PHI-1.0) );    \n    \n    mat2 iB = mat2( ka.y, -ka.x, \n                    kb.y, -kb.x ) / (ka.y*kb.x - ka.x*kb.y);\n    \n    vec2 c = floor( iB * vec2(phi, cosTheta - m));\n    float d = 8.0;\n    float j = 0.0;\n    for( int s=0; s<4; s++ ) \n    {\n        vec2 uv = vec2( float(s-2*(s/2)), float(s/2) );\n        \n        float i = dot(F, uv + c); // all quantities are ingeters (can take a round() for extra safety)\n        \n        float phi = 2.0*PI*fract(i*PHI);\n        float cosTheta = m - 2.0*i/n;\n        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n        \n        vec3 q = vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta );\n        float squaredDistance = dot(q-p, q-p);\n        if (squaredDistance < d) \n        {\n            d = squaredDistance;\n            j = i;\n        }\n    }\n    return vec2( j, sqrt(d) );\n}\n\nvec4 iSF( vec3 p, float n ) \n{\n    float m = 1.0 - 1.0/n;\n    \n    float phi = min(atan(p.y, p.x), PI), cosTheta = p.z;\n    \n    float k  = max(2.0, floor( log(n * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))/ log(PHI+1.0)));\n    float Fk = pow(PHI, k)/sqrt(5.0);\n    vec2  F  = vec2( round(Fk), round(Fk * PHI) ); // k, k+1\n\n    vec2 ka = 2.0*F/n;\n    vec2 kb = 2.0*PI*( fract((F+1.0)*PHI) - (PHI-1.0) );    \n    \n    mat2 iB = mat2( ka.y, -ka.x, \n                    kb.y, -kb.x ) / (ka.y*kb.x - ka.x*kb.y);\n    \n    vec2 c = floor( iB * vec2(phi, cosTheta - m));\n    float d = 8.0;\n    float j = 0.0;\n    vec4 o;\n    for( int s=0; s<4; s++ ) \n    {\n        vec2 uv = vec2( float(s-2*(s/2)), float(s/2) );\n        \n        o[s] = dot(F, uv + c); \n    }\n    return o;\n}\n\nvec3 fibonacci_sphere(int i, int n)\n{\n    vec2 pt = vec2(2.*PI*mod(float(i)/PHI, 1.), acos(1. - float(2*i+1)/float(n)));\n    return vec3(cos(pt.x)*sin(pt.y), sin(pt.x)*sin(pt.y), cos(pt.y)); \n}\n\n    \nstruct object\n{\n    int id;\n    vec3 X;\n    float bR;\n    vec3 a;\n    vec3 b;\n    vec3 c;\n};\n\nvec3 qtransform(vec4 q, vec3 v)\n{ \n\treturn v + 2.0*cross(cross(v, q.xyz) + q.w*v, q.xyz);\n} \n\n//intersection with the bisector plane\nfloat rayBisectDist(vec3 p, vec3 d, vec3 a, vec3 b)\n{\n    vec3 n = b - a;\n    float D = length(n);\n    float cosnd = dot(n, d)/D; //ray plane normal angle cosine\n    float l = D*.5 - dot(p - a, n)/D;\n    float t = l/cosnd; //ray parameter\n    return (cosnd>0.)?t:1e10;\n}\n\nfloat dirBisectDist(vec3 d, vec3 a, vec3 b, float dist)\n{\n    float cosnd = dot(normalize(b - a), d); //ray plane normal angle cosine\n    return (cosnd>0.)?(dist*.5)/cosnd:1e10;\n}\n\n//iq's triangle sdf \nfloat dot2( vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat bisectDist(vec3 p, vec3 a, vec3 b)\n{\n    return distance(a,b)*0.5 - dot(p - a, normalize(b - a));\n}\n\nfloat dist2obj(vec3 p, in object o)\n{\n    return udTriangle(p, o.a, o.b, o.c) - 0.003;\n}\n\nfloat equidistantPoint(vec3 d, object o0, object o1)\n{\n    \n    return 0.;\n}\n", "buffer_a_code": "//triangle and triangle neighbor directional graph buffer \n\nvec3[] vertecies = vec3[](\nvec3(-995.8304  ,  75.5037  ,   -608.4150),\nvec3(-992.0101  ,  115.6586 ,    -568.2448),\nvec3(-948.9031  ,  122.7461 ,    -586.1746),\nvec3(-808.0504  ,  82.2768  ,   -504.0376),\nvec3(-829.8732  ,  90.4546  ,   -495.4801),\nvec3(-815.5106  ,  55.3138  ,   -483.6030),\nvec3(-827.6768  ,  4.7252   ,   -550.7932),\nvec3(-926.4594  ,  -11.3236 ,    -509.0985),\nvec3(-924.9203  ,  4.9779   ,   -555.2147),\nvec3(-699.9360  ,  47.5303  ,   -579.6901),\nvec3(-725.3939  ,  13.6954  ,   -604.4670),\nvec3(-739.4488  ,  72.5684  ,   -610.5344),\nvec3(-1034.0753 ,  -11.3236 ,    -534.3847),\nvec3(-1060.0525 ,  17.3272  ,   -541.3537),\nvec3(-1038.5428 ,  29.1891  ,   -575.5334),\nvec3(-1000.9319 ,  78.8761  ,   -383.3885),\nvec3(-930.1043  ,  71.7035  ,   -351.5857),\nvec3(-920.2565  ,  109.7136 ,    -404.0531),\nvec3(-702.3473  ,  16.8526  ,    -571.5159),\nvec3(-728.9493  ,  -11.3236 ,    -558.9595),\nvec3(-724.4047  ,  -11.3236 ,    -589.9592),\nvec3(-717.2055  ,  41.9075  ,   -502.3305),\nvec3(-735.5786  ,  47.5303  ,   -491.1331),\nvec3(-733.9127  ,  18.3676  ,   -496.1548),\nvec3(-733.9399  ,  96.2936  ,   -552.8721),\nvec3(-694.6128  ,  66.2405  ,   -544.0293),\nvec3(-727.1962  ,  94.3858  ,   -574.8710),\nvec3(-925.7615  ,  126.6104 ,    -513.3122),\nvec3(-853.2005  ,  115.3310 ,    -545.4424),\nvec3(-894.0300  ,  131.5131 ,    -564.8028),\nvec3(-790.0053  ,  -4.9984  ,   -523.5698),\nvec3(-788.1220  ,  -4.3065  ,   -488.5588),\nvec3(-795.1429  ,  6.2171   ,   -449.4353),\nvec3(-840.2600  ,  20.1157  ,   -360.7992),\nvec3(-841.6091  ,  -1.1064  ,   -353.7490),\nvec3(-798.4716  ,  -11.3236 ,    -394.9299),\nvec3(-836.6793  ,  74.1277  ,   -450.3682),\nvec3(-832.0030  ,  64.3311  ,   -416.8673),\nvec3(-815.2516  ,  34.6305  ,   -481.9950),\nvec3(-832.3073  ,  9.2289   ,   -452.2656),\nvec3(-789.5191  ,  55.1783  ,   -621.8122),\nvec3(-795.7584  ,  20.4113  ,   -616.7018),\nvec3(-853.6783  ,  -11.3236 ,    -657.0101),\nvec3(-814.8730  ,  -5.0179  ,   -583.5240),\nvec3(-1012.5013 ,  -11.3236 ,    -419.7687),\nvec3(-990.1320  ,  -1.7048  ,   -373.5935),\nvec3(-1004.2960 ,  44.1512  ,   -365.5110),\nvec3(-855.9658  ,  10.3450  ,   -380.9660),\nvec3(-803.1211  ,  -11.3236 ,    -401.7929),\nvec3(-906.3935  ,  -0.5085  ,   -358.5250),\nvec3(-957.7062  ,  114.9286 ,    -436.9630),\nvec3(-977.6108  ,  130.2673 ,    -533.3871),\nvec3(-738.3090  ,  5.0845   ,   -507.1984),\nvec3(-709.8657  ,  -11.3236 ,    -526.8616),\nvec3(-710.5553  ,  1.5324   ,   -511.1166),\nvec3(-747.3311  ,  0.0296   ,   -472.9264),\nvec3(-749.3085  ,  11.8466  ,   -475.1376),\nvec3(-792.2325  ,  17.3739  ,   -396.8396),\nvec3(-878.4414  ,  35.7717  ,   -642.8316),\nvec3(-989.6032  ,  17.0865  ,   -621.6263),\nvec3(-944.0946  ,  58.0384  ,   -642.5948),\nvec3(-851.3480  ,  63.6161  ,   -648.0112),\nvec3(-785.4418  ,  72.5684  ,   -496.2609),\nvec3(-793.9230  ,  105.7400 ,    -489.6239),\nvec3(-805.3693  ,  49.2849  ,   -493.7585),\nvec3(-707.0358  ,  66.2405  ,   -513.1634),\nvec3(-781.2529  ,  20.6106  ,   -610.5267),\nvec3(-752.0867  ,  49.2849  ,   -626.1438),\nvec3(-764.1007  ,  4.7729   ,   -624.7463),\nvec3(-782.7896  ,  109.1638 ,    -561.5859),\nvec3(-755.0754  ,  109.5690 ,    -604.1262),\nvec3(-778.0606  ,  97.3133  ,   -596.8195),\nvec3(-1035.4617 ,  94.9357  ,   -465.6595),\nvec3(-962.6334  ,  117.6223 ,    -475.3002),\nvec3(-1042.7870 ,  48.9679  ,   -403.3333),\nvec3(-1073.9026 ,  52.3123  ,   -485.0486),\nvec3(-1056.9429 ,  9.7043   ,   -458.5848),\nvec3(-768.6208  ,  -8.2751  ,   -504.6131),\nvec3(-771.2246  ,  5.6477   ,   -497.4490),\nvec3(-706.1431  ,  -11.3236 ,    -536.1108),\nvec3(-695.7332  ,  1.5324   ,   -547.9435),\nvec3(-699.7588  ,  -1.4693  ,   -532.1415),\nvec3(-703.2778  ,  44.4115  ,   -511.2145),\nvec3(-690.5525  ,  44.4115  ,   -542.8315),\nvec3(-806.4027  ,  26.4766  ,   -417.1291),\nvec3(-779.1372  ,  17.1613  ,   -493.2779),\nvec3(-882.1035  ,  74.7240  ,   -366.3839),\nvec3(-821.3383  ,  74.7946  ,   -638.8068),\nvec3(-867.0529  ,  24.4554  ,   -668.6847),\nvec3(-784.6449  ,  106.3202 ,    -578.2576),\nvec3(-831.2065  ,  104.9587 ,    -620.3184),\nvec3(-783.5483  ,  7.4472   ,   -469.5750),\nvec3(-764.3502  ,  -11.3236 ,    -481.8925),\nvec3(-792.4278  ,  -8.2995  ,   -418.0562),\nvec3(-743.1558  ,  106.7015 ,    -584.4225),\nvec3(-685.2125  ,  17.4394  ,   -530.0173),\nvec3(-697.9792  ,  37.3655  ,   -539.4918),\nvec3(-690.5497  ,  17.4394  ,   -516.7567),\nvec3(-712.0912  ,  13.6706  ,   -585.8790),\nvec3(-996.4185  ,  -11.3236 ,    -539.4856),\nvec3(-1024.4155 ,  0.8627   ,   -577.6360),\nvec3(-798.4020  ,  1.7822   ,   -616.4513),\nvec3(-829.1520  ,  -11.3236 ,    -598.7313),\nvec3(-873.5256  ,  -0.4193  ,   -622.8918),\nvec3(-728.0101  ,  64.0319  ,   -495.0735),\nvec3(-744.3813  ,  95.5499  ,   -520.9390),\nvec3(-761.2942  ,  88.9008  ,   -508.1789),\nvec3(-781.7170  ,  26.8159  ,   -493.0542),\nvec3(-901.6669  ,  -11.3236 ,    -398.2102),\nvec3(-767.1221  ,  11.5533  ,   -493.6247),\nvec3(-751.5170  ,  13.1415  ,   -492.4418),\nvec3(-780.6548  ,  14.4846  ,   -472.4714),\nvec3(-1060.7682 ,  61.4407  ,   -446.4903),\nvec3(-1051.7577 ,  95.4428  ,   -514.2819),\nvec3(-1039.2488 ,  61.4143  ,   -568.5452),\nvec3(-854.7079  ,  94.0548  ,   -504.5181),\nvec3(-929.0150  ,  119.9958 ,    -442.1982),\nvec3(-864.1474  ,  97.4144  ,   -420.7776),\nvec3(-870.3384  ,  96.9634  ,   -459.3782),\nvec3(-780.8250  ,  4.2498   ,   -601.9772),\nvec3(-741.7265  ,  -11.3236 ,    -599.0881),\nvec3(-721.0571  ,  7.8997   ,   -601.0405),\nvec3(-703.8851  ,  -1.0353  ,   -617.8672),\nvec3(-942.1671  ,  7.3515   ,   -341.2048),\nvec3(-921.3945  ,  19.8009  ,   -333.6794),\nvec3(-943.1711  ,  -11.3236 ,    -350.5991),\nvec3(-838.6180  ,  27.0678  ,   -411.9889),\nvec3(-863.2388  ,  18.6852  ,   -406.0000),\nvec3(-814.4047  ,  16.0976  ,   -411.6389),\nvec3(-694.4426  ,  41.9075  ,   -558.8868),\nvec3(-710.5289  ,  22.1320  ,   -509.3748),\nvec3(-706.3202  ,  37.3655  ,   -518.7678),\nvec3(-696.0511  ,  42.0174  ,   -536.3110),\nvec3(-1036.4375 ,  -11.3236 ,    -459.7409),\nvec3(-770.0264  ,  106.7015 ,    -517.6603),\nvec3(-792.2722  ,  109.5690 ,    -511.7077),\nvec3(-779.3687  ,  119.6276 ,    -475.8542),\nvec3(-758.4063  ,  103.6384 ,    -502.1507),\nvec3(-784.4563  ,  107.8258 ,    -494.3299),\nvec3(-783.4283  ,  78.5575  ,   -513.7649),\nvec3(-883.1703  ,  -3.6364  ,   -655.2727),\nvec3(-730.2901  ,  88.9008  ,   -585.2112),\nvec3(-697.2075  ,  64.0319  ,   -571.6052),\nvec3(-750.1225  ,  78.5575  ,   -596.5160),\nvec3(-737.4004  ,  107.8258 ,    -611.2444),\nvec3(-724.0314  ,  103.6384 ,    -587.5582),\nvec3(-782.6500  ,  -11.3236 ,    -570.2200),\nvec3(-900.4669  ,  96.2424  ,   -633.2571),\nvec3(-897.0970  ,  120.3056 ,    -610.5399),\nvec3(-833.9095  ,  115.4948 ,    -598.8503),\nvec3(-853.0287  ,  122.5423 ,    -581.7062),\nvec3(-759.3208  ,  -11.3236 ,    -457.8283),\nvec3(-742.3607  ,  -11.3236 ,    -526.3356),\nvec3(-694.5074  ,  22.1320  ,   -549.1814),\nvec3(-839.2968  ,  22.8362  ,   -391.3108),\nvec3(-820.5211  ,  30.1974  ,   -389.5576),\nvec3(-829.5941  ,  38.5166  ,   -409.1643),\nvec3(-836.8793  ,  47.4207  ,   -386.5396),\nvec3(-869.9812  ,  46.1542  ,   -482.3823),\nvec3(-890.2067  ,  70.0660  ,   -483.5094),\nvec3(-909.9105  ,  98.4824  ,   -473.5333),\nvec3(-937.6815  ,  103.8339 ,    -483.5974),\nvec3(-804.8950  ,  95.6823  ,   -518.2141),\nvec3(-829.9017  ,  105.1277 ,    -539.1833),\nvec3(-733.7024  ,  -11.3236 ,    -611.5656),\nvec3(-738.7223  ,  10.7529  ,   -610.3510),\nvec3(-720.5469  ,  -9.4244  ,   -620.4963),\nvec3(-945.2722  ,  87.9113  ,   -629.4183),\nvec3(-995.0536  ,  46.6390  ,   -622.5880),\nvec3(-707.1171  ,  0.0891   ,   -521.4265),\nvec3(-701.2590  ,  1.7814   ,   -528.7713),\nvec3(-696.3574  ,  18.3020  ,   -516.0935),\nvec3(-705.5143  ,  32.6190  ,   -518.7469),\nvec3(-746.8992  ,  89.1834  ,   -623.5667),\nvec3(-774.1794  ,  85.3090  ,   -610.5543),\nvec3(-749.5588  ,  79.4633  ,   -607.6957),\nvec3(-735.9028  ,  86.8596  ,   -621.5189),\nvec3(-796.1419  ,  90.7038  ,   -608.0107),\nvec3(-1030.2487 ,  110.2389 ,    -493.4697),\nvec3(-984.0498  ,  122.4129 ,    -486.0958),\nvec3(-1026.7104 ,  102.5003 ,    -546.5026),\nvec3(-790.7665  ,  79.4633  ,   -505.3118),\nvec3(-790.4939  ,  86.8596  ,   -485.8827),\nvec3(-772.3555  ,  -4.7332  ,   -484.7859),\nvec3(-770.9318  ,  12.4502  ,   -486.0145),\nvec3(-896.9176  ,  -11.3236 ,    -454.9405),\nvec3(-770.0953  ,  -11.3236 ,    -537.9039),\nvec3(-692.3391  ,  11.6189  ,   -522.3785),\nvec3(-688.5785  ,  13.9763  ,   -545.0641),\nvec3(-874.0591  ,  -11.3236 ,    -597.7254),\nvec3(-950.8364  ,  118.9327 ,    -489.5284),\nvec3(-830.0552  ,  34.2774  ,   -389.5935),\nvec3(-711.2487  ,  -11.3236 ,    -613.0066),\nvec3(-704.1648  ,  -6.0835  ,   -597.8587),\nvec3(-806.8093  ,  28.4912  ,   -497.3588),\nvec3(-697.3834  ,  32.6190  ,   -538.9485),\nvec3(-1069.4880 ,  24.5603  ,   -494.2723),\nvec3(-973.8975  ,  -1.5557  ,   -607.4702),\nvec3(-997.2460  ,  -11.3236 ,    -558.3713),\nvec3(-688.9415  ,  18.3020  ,   -534.5188),\nvec3(-871.4866  ,  -11.3236 ,    -650.8430),\nvec3(-793.2932  ,  109.4704 ,    -565.8134),\nvec3(-800.0500  ,  103.8140 ,    -523.6841),\nvec3(-736.8707  ,  111.9007 ,    -616.0329),\nvec3(-729.2321  ,  106.4699 ,    -623.9708),\nvec3(-720.9323  ,  119.6276 ,    -621.0443),\nvec3(-800.4397  ,  14.8650  ,   -433.0968),\nvec3(-710.6121  ,  -11.3236 ,    -601.5969),\nvec3(-736.1279  ,  -4.1757  ,   -606.0648),\nvec3(-783.3688  ,  5.3768   ,   -498.0137),\nvec3(-703.4008  ,  13.9763  ,   -508.2369),\nvec3(-787.3816  ,  106.4699 ,    -479.4933),\nvec3(-869.6447  ,  -11.3236 ,    -352.0651),\nvec3(-849.2291  ,  -11.3236 ,    -613.3991),\nvec3(-715.2297  ,  1.1529   ,    -625.7358),\nvec3(-843.8202  ,  -11.3236 ,    -359.5085),\nvec3(-892.2355  ,  102.2551 ,    -392.7515),\nvec3(-748.9401  ,  -11.3236 ,    -575.4650),\nvec3(-778.8455  ,  -11.3236 ,    -431.0151),\nvec3(-922.5539  ,  -11.3236 ,    -344.4546));\n\n\nint triz = 459;\n\n    \nint[] triangles = int[](459, 460, 461,\n\n\n462, 463, 464, \n465, 466, 467, \n468, 469, 470, \n471, 472, 473, \n474, 475, 476, \n477, 478, 479, \n480, 481, 482, \n483, 484, 485, \n486, 487, 488, \n489, 490, 491, \n492, 493, 494, \n495, 496, 497, \n498, 466, 465, \n499, 500, 501, \n465, 467, 502, \n503, 504, 505, \n506, 507, 508, \n476, 509, 474, \n486, 488, 510, \n511, 512, 513, \n514, 515, 516, \n517, 518, 519, \n519, 520, 517, \n521, 522, 523, \n484, 483, 524, \n525, 526, 527, \n528, 529, 530, \n526, 525, 499, \n531, 474, 532, \n533, 534, 535, \n536, 537, 489, \n538, 539, 540, \n524, 541, 542, \n496, 543, 544, \n545, 475, 492, \n546, 547, 520, \n548, 530, 549, \n550, 551, 552, \n552, 491, 550, \n462, 523, 522, \n553, 528, 483, \n493, 492, 475, \n554, 555, 556, \n557, 469, 468, \n466, 558, 467, \n518, 559, 473, \n560, 561, 501, \n562, 518, 517, \n470, 469, 526, \n528, 553, 529, \n563, 564, 565, \n521, 566, 481, \n508, 567, 506, \n568, 481, 566, \n569, 570, 543, \n571, 572, 534, \n573, 472, 572, \n574, 487, 486, \n575, 576, 577, \n578, 527, 579, \n580, 557, 581, \n505, 582, 583, \n493, 583, 584, \n498, 585, 586, \n507, 506, 587, \n477, 468, 588, \n542, 484, 524, \n480, 482, 589, \n590, 556, 591, \n497, 496, 544, \n566, 521, 523, \n471, 592, 472, \n593, 594, 595, \n596, 597, 598, \n599, 562, 517, \n547, 499, 501, \n600, 601, 470, \n602, 603, 604, \n579, 605, 578, \n502, 578, 605, \n549, 606, 607, \n548, 608, 609, \n610, 611, 511, \n539, 538, 477, \n477, 588, 612, \n613, 614, 587, \n615, 587, 543, \n543, 496, 615, \n616, 615, 496, \n495, 617, 618, \n619, 620, 575, \n621, 622, 574, \n594, 593, 528, \n623, 624, 625, \n461, 626, 459, \n627, 519, 518, \n513, 628, 629, \n630, 631, 589, \n632, 633, 529, \n603, 634, 635, \n636, 546, 549, \n526, 499, 636, \n510, 637, 638, \n573, 639, 460, \n492, 616, 545, \n614, 516, 515, \n640, 641, 521, \n521, 563, 565, \n576, 575, 476, \n576, 545, 616, \n544, 537, 568, \n642, 643, 537, \n537, 643, 568, \n491, 490, 550, \n498, 586, 644, \n502, 605, 465, \n536, 489, 645, \n646, 513, 629, \n647, 646, 540, \n502, 467, 648, \n574, 649, 620, \n618, 617, 574, \n510, 488, 461, \n607, 609, 608, \n512, 511, 611, \n517, 547, 599, \n520, 547, 517, \n509, 532, 474, \n620, 532, 509, \n650, 613, 615, \n613, 586, 585, \n505, 583, 475, \n475, 583, 493, \n469, 625, 624, \n526, 469, 624, \n651, 581, 652, \n623, 625, 651, \n653, 497, 566, \n462, 464, 523, \n591, 556, 555, \n612, 588, 654, \n475, 474, 505, \n533, 474, 531, \n590, 591, 541, \n631, 480, 589, \n534, 572, 472, \n655, 535, 534, \n656, 467, 657, \n467, 656, 648, \n656, 657, 471, \n511, 513, 482, \n515, 569, 614, \n646, 647, 658, \n612, 654, 658, \n524, 564, 563, \n563, 541, 524, \n501, 599, 547, \n562, 599, 659, \n596, 595, 597, \n595, 594, 522, \n470, 526, 632, \n633, 632, 526, \n543, 570, 544, \n490, 544, 570, \n537, 536, 642, \n602, 600, 470, \n470, 635, 634, \n639, 637, 510, \n531, 572, 571, \n492, 614, 650, \n614, 613, 650, \n596, 565, 564, \n564, 528, 593, \n660, 609, 487, \n487, 661, 660, \n662, 663, 635, \n664, 529, 553, \n604, 600, 602, \n483, 485, 553, \n491, 498, 489, \n585, 498, 665, \n598, 565, 596, \n521, 565, 598, \n538, 540, 628, \n661, 622, 621, \n594, 621, 522, \n484, 542, 601, \n601, 485, 484, \n466, 498, 644, \n617, 464, 463, \n497, 617, 495, \n652, 479, 666, \n510, 638, 486, \n486, 649, 574, \n533, 505, 474, \n505, 533, 503, \n516, 494, 514, \n624, 667, 527, \n624, 527, 526, \n490, 668, 544, \n489, 668, 490, \n636, 549, 530, \n529, 633, 530, \n589, 482, 513, \n513, 646, 669, \n518, 562, 656, \n559, 518, 656, \n460, 459, 573, \n473, 627, 518, \n499, 525, 500, \n578, 502, 500, \n606, 549, 520, \n546, 520, 549, \n630, 669, 646, \n646, 554, 556, \n665, 587, 585, \n552, 587, 665, \n494, 516, 492, \n614, 492, 516, \n635, 663, 603, \n603, 664, 604, \n597, 670, 641, \n641, 640, 597, \n652, 581, 557, \n652, 557, 479, \n520, 519, 606, \n459, 626, 519, \n477, 612, 539, \n540, 539, 647, \n671, 508, 507, \n499, 547, 546, \n499, 546, 636, \n659, 672, 562, \n562, 648, 656, \n465, 489, 498, \n645, 489, 465, \n581, 673, 580, \n673, 581, 651, \n561, 502, 648, \n560, 502, 561, \n667, 624, 623, \n576, 496, 495, \n616, 496, 576, \n567, 644, 586, \n506, 567, 586, \n643, 570, 569, \n643, 642, 550, \n609, 607, 488, \n609, 488, 487, \n588, 601, 542, \n588, 542, 555, \n493, 674, 494, \n584, 674, 493, \n531, 532, 638, \n638, 649, 486, \n476, 675, 576, \n475, 675, 476, \n600, 485, 601, \n485, 600, 604, \n510, 460, 639, \n461, 460, 510, \n514, 511, 515, \n515, 511, 569, \n543, 614, 569, \n614, 543, 587, \n579, 676, 605, \n575, 509, 476, \n509, 575, 620, \n551, 677, 552, \n636, 633, 526, \n636, 530, 633, \n535, 503, 533, \n541, 563, 480, \n590, 541, 480, \n630, 556, 590, \n630, 646, 556, \n528, 660, 661, \n530, 548, 528, \n477, 538, 478, \n607, 608, 549, \n549, 608, 548, \n482, 481, 568, \n482, 568, 511, \n501, 500, 560, \n500, 502, 560, \n582, 505, 504, \n503, 584, 504, \n617, 497, 464, \n523, 464, 497, \n544, 668, 537, \n489, 537, 668, \n615, 585, 587, \n585, 615, 613, \n641, 522, 521, \n641, 670, 522, \n618, 619, 495, \n495, 577, 576, \n661, 621, 594, \n661, 594, 528, \n557, 477, 479, \n557, 468, 477, \n630, 589, 669, \n513, 669, 589, \n501, 659, 599, \n506, 586, 613, \n506, 613, 587, \n635, 470, 632, \n635, 632, 662, \n463, 462, 621, \n522, 621, 462, \n497, 653, 523, \n566, 523, 653, \n671, 678, 508, \n567, 508, 678, \n492, 650, 616, \n615, 616, 650, \n491, 552, 665, \n491, 665, 498, \n569, 511, 568, \n568, 643, 569, \n470, 601, 468, \n588, 468, 601, \n667, 623, 579, \n579, 527, 667, \n470, 634, 602, \n634, 603, 602, \n598, 597, 640, \n598, 640, 521, \n655, 472, 592, \n472, 655, 534, \n587, 552, 507, \n507, 552, 677, \n461, 607, 606, \n607, 461, 488, \n529, 662, 632, \n662, 529, 664, \n610, 514, 494, \n511, 514, 610, \n620, 618, 574, \n619, 618, 620, \n469, 673, 625, \n625, 673, 651, \n628, 512, 538, \n628, 513, 512, \n656, 471, 559, \n473, 559, 471, \n637, 639, 572, \n572, 639, 573, \n487, 574, 622, \n661, 487, 622, \n531, 571, 533, \n533, 571, 534, \n612, 647, 539, \n647, 612, 658, \n574, 463, 621, \n463, 574, 617, \n562, 672, 648, \n475, 545, 675, \n675, 545, 576, \n651, 652, 666, \n467, 558, 657, \n469, 580, 673, \n469, 557, 580, \n503, 535, 592, \n535, 655, 592, \n572, 531, 637, \n638, 637, 531, \n583, 582, 584, \n582, 504, 584, \n568, 566, 544, \n544, 566, 497, \n595, 596, 593, \n596, 564, 593, \n553, 604, 664, \n553, 485, 604, \n500, 525, 578, \n527, 578, 525, \n524, 483, 564, \n528, 564, 483, \n591, 542, 541, \n555, 542, 591, \n473, 573, 459, \n472, 573, 473, \n609, 660, 548, \n548, 660, 528, \n570, 550, 490, \n575, 577, 619, \n495, 619, 577, \n590, 631, 630, \n590, 480, 631, \n646, 629, 540, \n628, 540, 629, \n551, 550, 642, \n554, 646, 658, \n555, 554, 658, \n658, 654, 555, \n654, 588, 555, \n620, 649, 532, \n638, 532, 649, \n481, 563, 521, \n563, 481, 480, \n670, 597, 595, \n670, 595, 522, \n664, 603, 663, \n662, 664, 663, \n606, 626, 461, \n626, 606, 519, \n459, 627, 473, \n519, 627, 459, \n605, 645, 465);\n\n\nobject obj; vec4 lnk; \n\nvec4 d; int ID; float avgR;\nobject getObject(int id)\n{\n    object o;\n    o.X = texel(ch0, i2xy(ivec3(id, 0, 0))).xyz;\n    o.a = texel(ch0, i2xy(ivec3(id, 1, 0))).xyz;\n    o.b = texel(ch0, i2xy(ivec3(id, 2, 0))).xyz;\n    o.c = texel(ch0, i2xy(ivec3(id, 3, 0))).xyz;\n    return o;\n}\n\nvec4 saveObject(int i)\n{\n    switch(i)\n    {\n    case 0:  \n        return vec4(obj.X, 0.);\n    case 1:\n        return vec4(obj.a, 0.);\n    case 2:\n        return vec4(obj.b, 0.);\n    case 3:\n        return vec4(obj.c, 0.);\n    }\n}\n\nvoid sort(int idtemp, int R);\nvoid sortlinks(int id, int R, int R0);\nvoid sortneighbors(int id, int R);\nvoid sortrandom(int id, int R);\nconst vec3 shift = vec3(-908.0101  ,  64.0319  ,   -495.0735);\nconst float scale = 150.;\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(floor(pos));\n    if(any(greaterThan(p, sN*N-1))) discard;\n   \n    ivec3 sid = xy2i(p); ID = sid.x;\n    obj = getObject(ID);\n   \tif(sid.z == 0) //object computation\n    {    \n        if(sid.y < 4)\n        {\n            obj.X = (obj.a + obj.b + obj.c)/3.; \n            \n            if(iFrame<1) //initial conditions\n            {\n                if(ID < 410 && ID >= 0)\n                {\n                    obj.a = vertecies[triangles[ID*3]-triz]/scale;\n                    obj.b = vertecies[triangles[ID*3+1]-triz]/scale;\n                    obj.c = vertecies[triangles[ID*3+2]-triz]/scale;\n\n                    obj.a -= shift/scale;\n                    obj.b -= shift/scale;\n                    obj.c -= shift/scale;\n\n                    obj.a = obj.a.xzy;\n                    obj.b = obj.b.xzy;\n                    obj.c = obj.c.xzy;\n                }\n            } \n            \n            \n            U = saveObject(sid.y);\n        }\n    }\n    else //graph computation\n    {\n        d = vec4(1e6);\n        lnk = vec4(-1);\n       \n        sortlinks(ID, sid.y, sid.y);\n        \n        sortneighbors(ID, sid.y);\n        \n        sortrandom(sid.x, sid.y);\n        \n        U = lnk;\n    }\n}\n\n\nbool iscoincidence(int id)\n{\n    return (id == ID) || (id < 0) || any(equal(lnk,vec4(id)));\n}\n\nvoid sort(int idtemp, int R) //sort closest objects in N directions\n{\n    if(iscoincidence(idtemp)) return; //particle already sorted\n    object o = getObject(idtemp);\n    //float dd = dist2obj(obj.X, o);\n    vec3 dir = fibonacci_sphere(R, link0);\n    float t = dirBisectDist(dir, obj.X, o.X, distance(o.X, obj.X));\n    //insertion sort\n    if(d.x > t)\n    {\n        d = vec4(t, d.xyz);\n        lnk = vec4(idtemp, lnk.xyz);\n    }\n    else if(d.y > t)\n    {\n        d.yzw = vec3(t, d.yz);\n        lnk.yzw = vec3(idtemp, lnk.yz);\n    }\n    else if(d.z > t)\n    {\n        d.zw = vec2(t, d.z);\n        lnk.zw = vec2(idtemp, lnk.z);\n    }\n    else if(d.w > t)\n    {\n        d.w = t;\n        lnk.w = float(idtemp);\n    }\n}\n\nvoid sortlinks(int id, int R, int R0)\n{\n    vec4 nb = texel(ch0, i2xy(ivec3(id, R, 1)));\n    for(int i = min(0, iFrame); i<4; i++) \n        sort(int(nb[i]), R0);\n}\n\nvoid sortneighbors(int id, int R)\n{\n    vec3 dir = fibonacci_sphere(R, link0);\n    vec4 d4 = iSF(dir, float(link0));\n    for(int i = min(0, iFrame); i < 4; i++)\n    {\n         int dir = int(d4[i]);\n         vec4 nb = texel(ch0, i2xy(ivec3(id, dir, 1)));\n    \t for(int j = min(0, iFrame); j < 4; j++) \n         {\n         \tsortlinks(int(nb[j]), (16*iFrame+4*j+i)%link0, R); \n         }\n    }  \n}\n\nvoid sortrandom(int id, int R)\n{\n    for(int i = min(0, iFrame); i<2; i++) sort((12*iFrame+ID+i)%tot_n, R);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//prev closest triangle buffer\n//render\n\nobject getObject(int id)\n{\n    object o;\n    if(id<0) id = 0;\n    \n    o.X = texel(ch0, i2xy(ivec3(id, 0, 0))).xyz;\n    o.a = texel(ch0, i2xy(ivec3(id, 1, 0))).xyz;\n    o.b = texel(ch0, i2xy(ivec3(id, 2, 0))).xyz;\n    o.c = texel(ch0, i2xy(ivec3(id, 3, 0))).xyz;\n    \n    o.id = id;\n    return o;\n}\n\n//find closest voronoi cell \nfloat findClosest(vec3 p, inout object co, int mit)\n{    \n    float DE = dist2obj(p, co);\n    for(int s = min(0,iFrame); s < mit; s++)\n    {\n    \tint pid = co.id;\n        \n        int dir = int(inverseSF(normalize(p - co.X), float(link0)).x);\n        float t = distance(p, co.X); \n        vec4 nb = texel(ch0, i2xy(ivec3(co.id, dir%link0, 1)));\n        for(int i = min(0,iFrame); i<4; i++)\n        {\n            object o = getObject(int(nb[i]));\n            float tt = distance(p, o.X);\n            DE = min(DE, dist2obj(p, o));\n            if(tt < t)\n            {\n                co = o;\n            }\n        }   \n        \n        if(pid == co.id) break;\n    }\n    return DE;\n}\n\n#define maxd 4.\n#define mind 0.003\n#define maxs 128\n\nfloat map(vec3 p, inout object co)\n{\n    return min(findClosest(p, co, 32), p.z+0.5);\n}\n\nvec4 calcNormal(vec3 p, float dx, in object co) {\n\tconst vec3 k = vec3(1,-1,0);\n\treturn   (k.xyyx*map(p + k.xyy*dx, co) +\n\t\t\t k.yyxx*map(p + k.yyx*dx, co) +\n\t\t\t k.yxyx*map(p + k.yxy*dx, co) +\n\t\t\t k.xxxx*map(p + k.xxx*dx, co))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\nvec3 col(vec3 p, in vec4 cobj)\n{\n    //voronoi neighbors projected on the sphere surface\n    return vec3(1.);\n}\n\n//voronoi diagram ray marching\nvec4 rayMarch(vec3 p, vec3 d, inout object co)\n{\n    if(co.id < 0)\n    {\n        co = getObject(0);\n    }\n    \n    float td = 0.; float DE = 1e10;\n    for(int i = min(0, iFrame); i < maxs; i++)\n    {\n        //march\n        DE = map(p, co);\n        \n        p += DE*d;\n        td += DE;\n        \n        //outide of the scene\n        if(td > maxd) return vec4(p, -1.);\n        //has hit the surface\n        if(DE < mind*td) break;\n    }\n    return vec4(p, DE);\n}\n\n#define shadow_steps 20\nfloat shadow_march(vec4 pos, vec4 dir, float distance2light, float light_angle, inout object co)\n{\n\tfloat light_visibility = 1.;\n\tfloat ph = 1e5;\n\tpos.w = map(pos.xyz, co);\n\tint i = min(0, iFrame);\n\tfor (; i < shadow_steps; i++) {\n\t\n\t\tdir.w += pos.w;\n\t\tpos.xyz += pos.w*dir.xyz;\n\t\tpos.w = map(pos.xyz, co);\n\t\t\n\t\tfloat y = pos.w*pos.w/(2.0*ph);\n        float d = (pos.w+ph)*0.5;\n\t\tfloat angle = d/(max(0.00001,dir.w-y)*light_angle);\n\t\t\n        light_visibility = min(light_visibility, angle);\n\t\t\n\t\tph = pos.w;\n\t\t\n\t\tif(dir.w >= distance2light)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif(dir.w > maxd || pos.w < max(mind*dir.w, 0.0001))\n\t\t{\n\t\t\treturn 0.;\n\t\t}\n\t}\n\t\n\tif(i >= shadow_steps)\n\t{\n\t\tlight_visibility=0.;\n\t}\n\t//return light_visibility; //bad\n\tlight_visibility = clamp(2.*light_visibility - 1.,-1.,1.);\n\treturn  0.5 + (light_visibility*sqrt(1.-light_visibility*light_visibility) + asin(light_visibility))/3.14159265; //looks better and is more physically accurate(for a circular light source)\n}\n\n\n#define FOV 2.\nmat3 getRot(vec2 a)\n{\n    \n   mat3 theta_rot = mat3(1, 0, 0,\n                         0, cos(a.y), sin(a.y),\n                         0, -sin(a.y), cos(a.y)); \n        \n   mat3 phi_rot = mat3(cos(a.x), sin(a.x), 0,\n        \t\t       -sin(a.x), cos(a.x), 0,\n        \t\t        0, 0, 1); \n   return transpose(phi_rot*theta_rot);\n}\n\nvec3 getRay(vec2 angles, vec2 pos)\n{\n    mat3 camera = getRot(angles);\n    return normalize(transpose(camera)*vec3(FOV*pos.x, FOV*pos.y, 1.));\n}\n\n\n#define ldir vec3(cos(iTime*0.1)*sin(PI*0.4),sin(iTime*0.1)*sin(PI*0.4), cos(PI*0.4))\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 HDRmapping(vec3 color, float exposure)\n{\n\t// Exposure tone mapping\n    vec3 mapped = ACESFilm(color * exposure);\n    // Gamma correction \n    return pow(mapped, vec3(1.0 / 2.2));\n}\n\nconst float Br = 0.0025;\nconst float Bm = 0.0003;\nconst float g =  0.9800;\nconst vec3 nitrogen = vec3(0.650, 0.570, 0.475);\nconst vec3 Kr = Br / pow(nitrogen, vec3(4.0));\nconst vec3 Km = Bm / pow(nitrogen, vec3(0.84));\n\nvec3 sky_color(in vec3 pos)\n{\n\t// Atmosphere Scattering\n\tvec3 fsun = ldir.xzy;\n\tfloat brightnees = exp(-sqrt(pow(abs(min(5.*(pos.y-0.1),0.)),2.)+0.1));\n\tif(pos.y < 0.)\n\t{\n\t\tpos.y = 0.;\n\t\tpos.xyz = normalize(pos.xyz);\n\t}\n    float mu = dot(normalize(pos), normalize(fsun));\n\t\n\tvec3 extinction = mix(exp(-exp(-((pos.y + fsun.y * 4.0) * (exp(-pos.y * 16.0) + 0.1) / 80.0) / Br) * (exp(-pos.y * 16.0) + 0.1) * Kr / Br) * exp(-pos.y * exp(-pos.y * 8.0 ) * 4.0) * exp(-pos.y * 2.0) * 4.0, vec3(1.0 - exp(fsun.y)) * 0.2, -fsun.y * 0.2 + 0.5);\n\tvec3 sky_col = brightnees* 3.0 / (8.0 * 3.14) * (1.0 + mu * mu) * (Kr + Km * (1.0 - g * g) / (2.0 + g * g) / pow(1.0 + g * g - 2.0 * g * mu, 1.5)) / (Br + Bm) * extinction;\n\tsky_col = 0.4*clamp(sky_col,0.,10.);\n\treturn pow(sky_col,vec3(1./1.5)); \n}\n\nvec3 ambient_sky_color(in vec3 pos)\n{\n\tfloat y = pos.y;\n\tpos.xyz = normalize(vec3(1,0,0));\n\treturn sky_color(pos)*exp(-abs(y));\n}\n\nvec4 ambient_occlusion(in vec4 pos, in vec4 norm, in vec4 dir, in object co)\n{\t\n\tvec3 pos0 = pos.xyz;\n\t\n\tfloat occlusion_angle = 0.;\n\tvec3 direction = norm.xyz;\n\tvec3 ambient_color = ambient_sky_color(norm.xyz);\n\t//step out\n\tpos.xyz += 0.05*dir.w*direction;\n\t//march in the direction of the normal\n\tfor(int i = min(0,iFrame); i < 1; i++)\n\t{\n\t\tpos.xyz += pos.w*direction;\n\t\tpos.w = map(pos.xyz, co);\n\t\t\n\t\tnorm.w = length(pos0 - pos.xyz);\n\t\tocclusion_angle += clamp(pos.w/norm.w,0.,1.);\n\t}\n\t\n\tocclusion_angle /= 2.; // average weighted by importance\n\treturn vec4(ambient_color,1.)*(0.5-cos(3.14159265*occlusion_angle)*0.5);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = (pos - size*0.5)/size.y;\n    vec2 angles = (iMouse.z>0.)?(iMouse.xy/iResolution.xy)*vec2(2.*PI, PI):vec2(-0.4*iTime, PI*0.5);\n    \n    vec3 d = getRay(angles, uv);\n    vec3 p = 0.*texel(ch0, i2xy(ivec3(6, 0, 0))).xyz-2.*getRay(angles, vec2(0.));\n    vec4 prev = pixel(ch1, pos);\n    if(iFrame < 1) prev.w = 0.;\n    object co = getObject(int(prev.w));\n    findClosest(p, co, 16);\n    float closest = float(co.id);\n    vec4 rm = rayMarch(p, d, co);\n    float td = distance(rm.xyz, p);\n    if(rm.w >= 0.) //hit object\n    {\n    \tvec3 n = normalize(calcNormal(rm.xyz, mind*td,co).xyz);\n        vec4 ao = ambient_occlusion(rm, vec4(n, rm.w), vec4(d, td), co);\n        float sh = shadow_march(vec4(rm.xyz+n*0.06, rm.w), vec4(ldir,0.), 1., 0.12, co);\n        U.xyz = sh*sky_color(ldir.xzy)*max(dot(ldir, n),0.) + ao.xyz;\n    }\n    else //background\n    {\n        U.xyz = sky_color(d.xzy);\n    }\n    U.xyz = HDRmapping(U.xyz, 0.5);\n    U.w = closest;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2yR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 101, 101, 136]], "test": "untested"}
{"id": "tdjczh", "name": "Julia Glassblower", "author": "xjorma", "description": "When looking for another thing I felt onto this paper:\n\nhttp://www.cs.cmu.edu/~kmcrane/Projects/QuaternionJulia/paper.pdf\n\nWanted to give it a try.\n\nNeed a beefy GPU. \n", "tags": ["julia", "glass", "quaternion"], "likes": 20, "viewed": 890, "published": 3, "date": "1586128238", "time_retrieved": "2024-07-30T21:14:37.316576", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#if HW_PERFORMANCE==0\n#else\n#define AA\n#endif\n\n#define BIASED_NORMAL \t1\n#define MAX_BOUNCES     4\n#define MAX_DIST\t\t4.\n#define ABSORB\t\t\tvec3(0., 0.5, 1.3)\n\nconst int maxIterations = 6;\n\n// http://www.cs.cmu.edu/~kmcrane/Projects/QuaternionJulia/paper.pdf\n\nvec4 quatMult(vec4 q1, vec4 q2)\n{\n    vec4 r;\n    r.x = q1.x * q2.x - dot(q1.yzw, q2.yzw);\n    r.yzw = q1.x * q2.yzw + q2.x * q1.yzw + cross(q1.yzw, q2.yzw);\n    return r;\n}\n\nvec4 quatSq(vec4 q)\n{\n    vec4 r;\n    r.x = q.x * q.x - dot( q.yzw, q.yzw );\n    r.yzw = 2. * q.x * q.yzw;\n    return r;\n}\n\n#define ESCAPE_THRESHOLD 10.\n\nfloat JuliaQuaternion(vec3 p, vec4 c)\n{\n    vec4 q = vec4( p, 0 );\n\tvec4 qp = vec4( 1, 0, 0, 0 );\n    for(int i = 0; i < maxIterations; i++)\n    {\n        qp = 2.0 * quatMult(q, qp);\n        q = quatSq(q) + c;\n        if( dot( q, q ) > ESCAPE_THRESHOLD )\n        {\n            break;\n        }\n    }\n\tfloat nQ = length( q );\n    return 0.5 * nQ * log( nQ ) / length( qp ); //lower bound on distance to surface;\n}\n\nfloat map(in vec3 p)\n{\n    float t = iTime * 0.1;\n    vec4 c = 0.5 * vec4(cos(t), cos(t * 1.1), cos(t * 2.3), cos(t * 3.1));\n\treturn JuliaQuaternion(p, c);\n}\n\n\nvec3 getSkyColor(vec3 rd)\n{\n    vec3 col = texture(iChannel0, rd).rgb;\n    return col*col;\n}\n\n\nfloat rayMarch(in float sgn, in vec3 ro, in vec3 rd, in float offT)\n{\n  float t = offT;\n  for (int i = 0; i < 60; i++)\n  {\n    float h = sgn * map(ro + rd * t);\n    t += h;\n    if (h < 0.001 || t > MAX_DIST)\n        break;\n  }\n  return t;\n}\n\n#define EPS  0.02\n\n#if BIASED_NORMAL\nvec3 calcNormal(vec3 pos)\n{\n    float\tref;\n    float\ttrans;\n    vec3\tabsorb;\n    vec3\tcol;\n    vec2\teps = vec2(EPS, 0);\n\tfloat d = map(pos);\n\treturn normalize(vec3(map(pos + eps.xyy) - d, map(pos + eps.yxy) - d, map(pos + eps.yyx) - d));\n}\n#else\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = EPS;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ) );\n}\n#endif\n\nvec3 Render(in vec3 ro, in vec3 rd)\n{\n    float sgn = 1.;\n    float cref = 0.7;\n    vec3  col = vec3(0);\n    vec3  rel = vec3(1);\n    float transp = 0.9;\n    vec3  absorb = ABSORB;\n    for(int i = 0; i < MAX_BOUNCES; i++)\n    {\n        float t = rayMarch(sgn, ro, rd, 0.02);\n        if( t> MAX_DIST)\n        {\n            col += rel * getSkyColor(rd);\n            break;\n        }\n        vec3 rabs = mix(absorb, vec3(0), (sgn + 1.) / 2.);\n        vec3 beerlamb = exp(-rabs * t);\n        vec3 p = ro + rd * t;\n        vec3 n = sgn * calcNormal(p);\n        vec3 refl = reflect(rd, n);\n        vec3 refr = refract(rd, n, cref);\n        //float fresnel = 1.0 - pow(dot(n, -rd), 2.);\n        float fresnel = pow(1.0 - abs(dot(n, rd)), 2.0);\n        float reflectorFactor = mix (0.2, 1.0, fresnel);\n        float refractionFactor = mix (transp, 0., fresnel);\n    \n    \tcol += (1.0 - refractionFactor) * rel * beerlamb * getSkyColor(refl) * reflectorFactor;\n    \trel *= refractionFactor * beerlamb;     \n        \n       \tro = p;     \n        if (refr == vec3(0.0))\n        {\n            rd = refl;\n        }\n        else\n        {\n            rd = refr; \n            sgn *= -1.;\n            cref = 1. / cref;\n        }        \n    }\n    col += rel * getSkyColor(rd);\n    return col;\n}\n\nvec3 contrast( in vec3 color, in float c)\n{\n    float t = 0.5 - c * 0.5; \n    return color * c + t;\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvec3 postProcess(in vec3 col, in vec2 q)\n{\n\tcol = pow(col, vec3(0.8));\n\tcol = contrast(col, 1.2);\n\tcol = vignette(col, q, 0.8);\n\treturn col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nmat3 genMat(in vec3 dir,in vec3 up)\n{\n\tvec3 cw = normalize(dir);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 tot = vec3(0.0);\n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n        float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5) + iTime*.2;\n        float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5)-1.;\n        vec3 ro = 2.5*vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        vec3 col = Render(ro ,rd);\n        \n\n        tot += col;\n            \n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n        \n    tot = postProcess(tot,fragCoord / iResolution.xy);\n    \n\tfragColor = vec4( sqrt(tot), 1.0 );\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjczh.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[369, 369, 402, 402, 542], [544, 544, 565, 565, 666], [698, 698, 737, 737, 1110], [1112, 1112, 1134, 1134, 1269], [1272, 1272, 1299, 1299, 1364], [1367, 1367, 1436, 1436, 1607], [2164, 2164, 2201, 2201, 3442], [3444, 3444, 3487, 3487, 3545], [3547, 3547, 3591, 3591, 3690], [3692, 3692, 3734, 3734, 3834], [3837, 3837, 3879, 3879, 4043], [4045, 4045, 4082, 4082, 4218]], "test": "untested"}
{"id": "wd2czh", "name": "Day 108", "author": "jeyko", "description": "looks like a trans-dimentional turd", "tags": ["mdtmjvm"], "likes": 9, "viewed": 390, "published": 3, "date": "1586124832", "time_retrieved": "2024-07-30T21:14:38.158325", "image_code": "\n// radiual chromab in this buffer\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n\tfragColor = vec4(0);\n    // Radial blur\n    float steps = 40.;\n    float scale = 0.00 + pow(dot(uvn,uvn),2.)*0.;\n    float chromAb = pow(length(uv - 0.5),0.9)*0.;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n        scale *= 0.97;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1.4/iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    fragColor += radial;\n    \n    //fragColor = 1. - fragColor;\n    fragColor *= 3.5;\n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.1);\n    fragColor = max(fragColor, 0.);\n    //fragColor.b *= 1. + uv.x*0.4;\n    fragColor *= 1. - dot(uvn,uvn)*1.;\n    fragColor = pow(fragColor, vec4(0.4545 ));\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvec4 valueNoise(float m, float p){\n\treturn mix(\n        texture(iChannel0, vec2(floor(m))/256.),\n        texture(iChannel0, vec2(floor(m + 1.))/256.),\n        pow(smoothstep(0.,1.,fract(m)),p)\n    );\t\n}\n#define dmin(a,b) a.x < b.x ? a : b\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define pmod(p,x) mod(p,x) - 0.5*x\n#define pi acos(-1.)\n#define tau (2.*pi)\nvec4 N;\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e6);\n\t\n    \n    vec3 q = p;\n    \n    \n    //float m = sin(p.y*10. +  sin(p.x*20.)*1. + iTime );\n    float m = sin(p.x*4. +  sin(p.x*20. - cos(p.z*20.)*1. - iTime*0.)*1. + iTime );\n    \n    p -= m*0.04;\n    //p -= m*0.04;\n    float b = length(p) - 0.5 ;\n    float bb = length(p - vec3(0.5 - N.z*0.5,0.1 - N.x*0.7,0.5)) - 0.2 - N.z*0.1 ;\n    float bbb = length(p + vec3(0.3,0. - N.y*0.4,0.2)) - 0.1 - N.y*0.1 ;\n    float bbc = length(p + vec3(0.2,-0.3 - N.x*0.4,-0.4)) - 0.2 - N.y*0.1 ;\n    \n    \n    b = opSmoothUnion( b, bb, 0. + N.z) ;\n    b = opSmoothUnion( b, bbb, 0. + N.w*1.) ;\n    b = opSmoothUnion( b, bbc, 0. + N.y*1.) ;\n    \n    d = dmin(d, vec2(b, 2.));\n    \n    \n    \n    p = q;\n    float mb = sin(p.x*10. + iTime*4. + sin(p.y)*10.  + cos(p.x*1. + iTime)*1.);\n    \n    p -= mb*0.06;\n    float c = -length(p.xz)+ 2.4;\n    \n    d = dmin(d, vec2(c, 3.));\n    \n    d.x *= 0.6;\n    \n    return d;\n}\n\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.0001,0.);\n    return -normalize(vec3(\n    \tmap(p - t.xyy).x - map(p + t.xyy).x,\n    \tmap(p - t.yxy).x - map(p + t.yxy).x,\n    \tmap(p - t.yyx).x - map(p + t.yyx).x\n    ));\n}\n\nvec2 march(vec3 ro,vec3  rd, inout vec3  p,inout float t,inout bool hit){\n\tt = 0.; hit = false; p = ro;\n\tvec2 d;\n    for(int i = 0;i < 150; i++){\n    \td = map(p);\n        \n        if(d.x < 0.00001){\n        \thit = true;\n            break;\n        }\n        \n        t += d.x;\n    \tp = ro + rd*t;\n    }\n\treturn d;\n}\n\nfloat fov;\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0,1,0), dir));\n\tvec3 up = normalize(cross(dir, right));\n    return normalize(dir + (right*uv.x + up*uv.y)*fov);\n}\n\n#define mx (iMouse.x/iResolution.x)*2.\n#define my (iMouse.y/iResolution.x)*0.5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n\tvec3 ro = vec3(0);\n    \n    uv *= 1. - dot(uv,uv)*0.1;\n    \n    N = valueNoise(iTime*0.5, 1.)*1.5;\n    vec4 NB = valueNoise(iTime*0.25, 1.);\n    \n    ro.xz += vec2(sin(NB.x*6. + mx),cos( NB.x*6. + mx))*(2. + my);\n    ro.y += NB.y*1.;\n    fov = 0.7 + NB.x*0.3;\n    uv.xy *= rot(0.7);\n    \n    vec3 lookAt = vec3(0.);\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n\tvec3 p; float t; bool hit;\n    vec2 d = march(ro, rd, p, t, hit);\n\n    #define AO(h) smoothstep(0.,1.,map(p + n*h).x/h)\n    #define SSS(h) clamp(map(p + normalize(vec3(1.))*h).x/h,0.,1.)\n    #define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e))) \n    \n    \n    if(hit){\n    \tvec3 n = getNormal(p);\n        \n        float ao = AO(0.6)*AO(0.9)*AO(0.1);\n        float sss = SSS(0.6)*SSS(0.9);\n        \n        ao *= (0.1 + sss)*30.;\n        //ao *= 2.;\n        \n        float dnrd = max(dot(n, -rd), 0.);\n        float fres = pow(1.-dnrd,5.);\n        //float antifres = smoothstep(0.,1., (1. - pow(1.-dnrd,1.))* 5.);\n        float antifres = 1. - smoothstep(0.,1., (pow(1.-dnrd,5.))* 2.4);\n        \n        //antifres = 1.;\n        if(d.y == 2.){\n        \tvec3 p = pal(0.5,vec3(0.5,0.6,0.5), vec3(0.1,0.5,0.9), 0.7 + acos(rd)*0., + dnrd*20. + iTime)*fres*antifres;\n        \tvec3 pp = pal(0.5,0.5, vec3(1.6,0.5,0.9), 0.7 + acos(rd)*0.2, acos(rd)*0.2 + dnrd*90.)*(smoothstep(0.,1., pow(dnrd,50.)));\n        \tcol += p*2.;\n        \tcol += pp*0.06;\n        } else if(d.y == 3.){\n        \tvec3 p = pal(0.5,0.5, vec3(0.2,0.5,0.7), 0.7, + dnrd*20.)*pow(fres, 0.6)*antifres;\n            //vec3 p = pal(0.5,0.5, vec3(0.2,3.5,2.), 0.7, + dnrd*20.)*pow(fres, 0.6)*antifres;\n        \tcol += p*0.1;\n        }\n    \n        //col += fres;\n        \n        col *= ao;\n        \n        \n    }\n    \n    \n    \n    fragColor = vec4(col,t);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2czh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 93, 93, 1092]], "test": "untested"}
{"id": "ts2cRh", "name": "Equalizer devel", "author": "TimoKinnunen", "description": "Developing sound analysis.", "tags": ["sound", "visualization"], "likes": 6, "viewed": 377, "published": 3, "date": "1586120101", "time_retrieved": "2024-07-30T21:14:39.556587", "image_code": "vec4 lightColumn(vec4 O, vec2 U) {\n    O *= O.g-O.r;\n//    O += O*U.y/R.y;\n    return O;\n}\nvec4 lightColumn(vec2 U) {\n    float w = R.x-512.;\n    float x = (U.x-512.)/w;\n    x -= 0.5;\n    x *= 1.0-0.875*U.y/R.y*U.y/R.y;\n    x += 0.5;\n    ivec2 pos = ivec2(x*512.,0);\n    return lightColumn(texelFetch(iChannel0,pos,0),U);\n}\n\nvec4 image(vec2 U) {\n    vec4 O;\n    if(iMouse.z>0.) {\n        ivec2 pos = ivec2(U);\n        vec4 O1 = texelFetch(iChannel1,pos,0);\n        O1 = clamp(O1-0.03125,0.,1.);\n        O1 += O1*O1*1.25-0.0625;\n        pos = ivec2(mod(U.x,R.x/16.)+floor(U.y/R.y*16.)*R.x/16.,U.y);\n        vec4 O2 = texelFetch(iChannel1,pos,0);\n        O2 = clamp(O2-0.03125,0.,1.);\n        O2 += O2*O2*1.25-0.0625;\n        O=0.5*(O1+O2);\n    } else if(U.y*2.>R.y) {\n        ivec2 pos = ivec2(U.x,mod(U.y,0.5*R.y));\n        O = texelFetch(iChannel1,pos,0);\n        O = clamp(O-0.03125,0.,1.);\n        O += O*O*1.25-0.0625;\n    } else if(U.x>512.) {\n        ivec2 pos = ivec2((U.x-512.)/(R.x-512.)*512.,0);\n        O = vec4(0);\n        O += lightColumn(U-vec2(2,0));\n        O += lightColumn(U+vec2(2,0));\n        O *= 4.*U.y/R.y*U.y/R.y;\n        O += lightColumn(U-vec2(1,0));\n        O += lightColumn(U+vec2(1,0));\n        O *= 4.*U.y/R.y*U.y/R.y;\n        O += lightColumn(U);\n        pos.y = int(U.y/R.y*2.*0.125*450.);\n        O.rgb += max(texelFetch(iChannel0,pos,0).bgr*2.-0.5,0.)*exp2(-4.*U.y/R.y);\n        O = clamp(O,0.,1.);\n        if(iMouse.x>5.) {\n            pos=ivec2((floor(iMouse.x/R.x*16.)+(U.x-512.)/(R.x-512.))/16.*R.x,0);\n            O.rgb += clamp((texelFetch(iChannel1,pos,0).rgb-0.25)*4.0,0.,1.);\n            pos=ivec2((floor(iMouse.y/R.y*16.)+(U.x-512.)/(R.x-512.))/16.*R.x,0);\n            O.rgb += clamp((texelFetch(iChannel1,pos,0).rgb-0.25)*4.0,0.,1.);\n        } else {\n            pos=ivec2((mod(floor(iTime/3.75*4.0+0.875)+1.,16.)+(U.x-512.)/(R.x-512.))/16.*R.x,0);\n            O.rgb += clamp(texelFetch(iChannel1,pos,0).rgb-0.25,0.,1.);\n            pos=ivec2((mod(floor(iTime/3.75*2.0+0.875)+1.,16.)+(U.x-512.)/(R.x-512.))/16.*R.x,0);\n            O.rgb += clamp(texelFetch(iChannel1,pos,0).rgb-0.25,0.,1.);\n        }\n        //O.rgb += clamp(0.5*texelFetch(iChannel1,ivec2((mod(floor(iTime*0.4)+9.,16.)+0.5)/16.*R.x,0.5*R.y+1.5),0).rgb-0.125,0.,1.);\n        O *= exp2(-2.*U.y/R.y);\n    } else { \n        ivec2 pos = ivec2(U);\n        O = texelFetch(iChannel0,pos,0);\n        O += 2.0*smoothstep(min(O.r,O.b),max(O.r,O.b)+1.,O.g);\n        //O *= vec4(0,1.-4.*(O.r+O.b),0,0);\n    }\n    return O;\n}\nMAIN", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 image(vec2 U) {\n    ivec2 pos = ivec2(U);\n    if(pos.x>511) return vec4(0);\n    if(pos.y>0) return texelFetch(iChannel0,pos-ivec2(0,1),0);\n    float acc1 = 0.0;\n    #ifdef INACCURATE\n    for(int i = 0; i <= pos.x; i++) {\n        acc1 += texelFetch(iChannel3,ivec2(i,0),0).x;\n    }\n    #else\n    for(int i1 = 0; i1 <= pos.x;) {\n        float acc2 = 0.0;\n        for(int i2 = 0; i2 < 2 && i1 <= pos.x; i2++) {\n            float acc3 = 0.0;\n            for(int i3 = 0; i3 < 2 && i1 <= pos.x; i3++) {\n                float acc4 = 0.0;\n                for(int i4 = 0; i4 < 2 && i1 <= pos.x; i4++) {\n                    float acc5 = 0.0;\n                    for(int i5 = 0; i5 < 2 && i1 <= pos.x; i5++) {\n                        float acc6 = 0.0;\n                        for(int i6 = 0; i6 < 2 && i1 <= pos.x; i6++) {\n                            float acc7 = 0.0;\n                            for(int i7 = 0; i7 < 2 && i1 <= pos.x; i7++) {\n                                float acc8 = 0.0;\n                                for(int i8 = 0; i8 < 2 && i1 <= pos.x; i8++) {\n                                    float acc9 = 0.0;\n                                    for(int i9 = 0; i9 < 2 && i1 <= pos.x; i9++, i1++) {\n                                        acc9 += texelFetch(iChannel3,ivec2(i1,0),0).x;\n                                    }\n                                    acc8 += acc9;\n                                }\n                                acc7 += acc8;\n                            }\n                            acc6 += acc7;\n                        }\n                        acc5 += acc6;\n                    }\n                    acc4 += acc5;\n                }\n                acc3 += acc4;\n            }\n            acc2 += acc3;\n        }\n        acc1 += acc2;\n    }\n    #endif\n    acc1 /= floor(U.x+1.);\n    return vec4(texelFetch(iChannel3,ivec2(pos.x,0),0).x,0,acc1,0);\n}\nMAIN", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 21790, "src": "https://soundcloud.com/sonnfried-rodewald/mike-foyle-shipwrecked-sonnfried-rodewald-remix", "ctype": "musicstream", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "\n#define DEBUG2\n\nvec2 printNum2_ZOOM;\n#ifdef DEBUG2\n//const vec2 printNum2_ZOOM = vec2(2,2);\nconst vec2 printNum2_FONT = vec2(4,5);\nconst vec2 printNum2_ORIGIN = vec2(0,0);\nconst float printNum2_LINE_BORDER = 1.0;\nconst float printNum2_LINE_HEIGHT = printNum2_FONT.y+printNum2_LINE_BORDER*2.0;\nconst float printNum2_GROUP_SIZE = 3.;\nconst float printNum2_GROUP_SEPARATOR_HEIGHT = 1.+0.*printNum2_LINE_HEIGHT;\nconst float printNum2_GROUP_HEIGHT = printNum2_LINE_HEIGHT*printNum2_GROUP_SIZE+printNum2_GROUP_SEPARATOR_HEIGHT;\n#define ints int[]\n#define int1 int\n#define floats float[]\n#define float1 float\nint printNum2_glyph(int ch) {\n\t/* Font:\n⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫\n⚫⚫⚫⚫⚫⚫⚪⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚫⚪⚪⚫⚪⚫⚫⚫⚫⚪⚫⚫⚫⚪⚫⚫⚫⚫⚪⚫⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚪\n⚫⚫⚫⚫⚫⚫⚪⚪⚫⚪⚫⚪⚫⚪⚪⚪⚫⚪⚪⚫⚫⚫⚫⚪⚫⚪⚫⚪⚫⚫⚪⚫⚫⚫⚪⚫⚫⚫⚪⚫⚫⚪⚫⚪⚫⚫⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚪\n⚫⚫⚫⚫⚫⚫⚪⚫⚫⚫⚫⚫⚫⚪⚫⚪⚫⚪⚪⚪⚫⚫⚪⚫⚫⚫⚪⚪⚫⚫⚫⚫⚫⚫⚪⚫⚫⚫⚪⚫⚫⚫⚪⚫⚫⚪⚪⚪⚫⚫⚫⚫⚫⚪⚪⚪⚫⚫⚫⚫⚫⚫⚪⚫\n⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚪⚪⚪⚫⚫⚪⚪⚫⚪⚫⚫⚫⚪⚫⚪⚫⚫⚫⚫⚫⚫⚪⚫⚫⚫⚪⚫⚫⚪⚫⚪⚫⚫⚪⚫⚫⚫⚪⚫⚫⚫⚫⚫⚫⚪⚪⚫⚫⚪⚫⚫\n⚫⚫⚫⚫⚫⚫⚪⚫⚫⚫⚫⚫⚫⚪⚫⚪⚫⚪⚪⚫⚫⚫⚫⚪⚫⚪⚪⚪⚫⚫⚫⚫⚫⚫⚫⚪⚫⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚪⚫⚫⚫⚫⚫⚫⚫⚪⚪⚫⚫⚪⚫⚫\n⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫\n⚫⚪⚪⚪⚫⚫⚪⚫⚫⚪⚪⚫⚫⚪⚪⚫⚫⚫⚫⚪⚫⚪⚪⚪⚫⚫⚪⚪⚫⚪⚪⚪⚫⚪⚪⚪⚫⚪⚪⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚪⚫⚫⚫⚫⚫⚪⚫⚫⚫⚪⚪⚫\n⚫⚪⚫⚪⚫⚪⚪⚫⚫⚫⚫⚪⚫⚫⚫⚪⚫⚫⚪⚪⚫⚪⚫⚫⚫⚪⚫⚫⚫⚫⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚫⚪⚫⚫⚫⚪⚫⚫⚫⚪⚫⚫⚪⚪⚪⚫⚫⚪⚫⚫⚫⚫⚪\n⚫⚪⚫⚪⚫⚫⚪⚫⚫⚫⚪⚫⚫⚫⚪⚪⚫⚪⚫⚪⚫⚪⚪⚫⚫⚪⚪⚪⚫⚫⚪⚫⚫⚪⚪⚪⚫⚪⚪⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫⚪⚫⚫⚪⚫\n⚫⚪⚫⚪⚫⚫⚪⚫⚫⚪⚫⚫⚫⚫⚫⚪⚫⚪⚪⚪⚫⚫⚫⚪⚫⚪⚫⚪⚫⚪⚫⚫⚫⚪⚫⚪⚫⚫⚫⚪⚫⚫⚪⚫⚫⚫⚪⚫⚫⚫⚪⚫⚫⚪⚪⚪⚫⚫⚪⚫⚫⚫⚫⚫\n⚫⚪⚪⚪⚫⚪⚪⚪⚫⚪⚪⚪⚫⚪⚪⚫⚫⚫⚫⚪⚫⚪⚪⚫⚫⚪⚪⚪⚫⚪⚫⚫⚫⚪⚪⚪⚫⚪⚪⚫⚫⚫⚫⚫⚫⚪⚫⚫⚫⚫⚫⚪⚫⚫⚫⚫⚫⚪⚫⚫⚫⚫⚪⚫\n⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫\n⚫⚫⚪⚪⚫⚪⚪⚫⚫⚪⚪⚫⚫⚫⚪⚪⚫⚪⚪⚫⚫⚫⚪⚪⚫⚫⚪⚪⚫⚫⚪⚪⚫⚪⚫⚪⚫⚪⚪⚪⚫⚫⚪⚪⚫⚪⚫⚪⚫⚪⚫⚫⚫⚪⚫⚪⚫⚪⚪⚫⚫⚫⚪⚫\n⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚫⚫⚪⚫⚪⚫⚪⚫⚫⚫⚪⚫⚫⚫⚪⚫⚫⚫⚪⚫⚪⚫⚫⚪⚫⚫⚫⚫⚪⚫⚪⚫⚪⚫⚪⚫⚫⚫⚪⚪⚪⚫⚪⚫⚪⚫⚪⚫⚪\n⚫⚪⚫⚪⚫⚪⚪⚪⚫⚪⚪⚫⚫⚪⚫⚫⚫⚪⚫⚪⚫⚪⚪⚫⚫⚪⚪⚫⚫⚪⚫⚪⚫⚪⚪⚪⚫⚫⚪⚫⚫⚫⚫⚪⚫⚪⚪⚫⚫⚪⚫⚫⚫⚪⚪⚪⚫⚪⚫⚪⚫⚪⚫⚪\n⚫⚪⚫⚫⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚫⚫⚪⚫⚪⚫⚪⚫⚫⚫⚪⚫⚫⚫⚪⚫⚪⚫⚪⚫⚪⚫⚫⚪⚫⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚫⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪\n⚫⚫⚪⚪⚫⚪⚫⚪⚫⚪⚪⚫⚫⚫⚪⚪⚫⚪⚪⚫⚫⚫⚪⚪⚫⚪⚫⚫⚫⚫⚪⚪⚫⚪⚫⚪⚫⚪⚪⚪⚫⚫⚪⚪⚫⚪⚫⚪⚫⚪⚪⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚫⚪⚫\n⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫\n⚫⚪⚪⚫⚫⚫⚪⚫⚫⚪⚪⚫⚫⚫⚪⚪⚫⚪⚪⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚪⚪⚫⚫⚪⚪⚫⚪⚫⚫⚫⚪⚪⚫⚫⚫⚪⚫⚫⚫⚫⚫\n⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚫⚫⚫⚪⚫⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚫⚫⚪⚫⚫⚪⚫⚫⚪⚫⚫⚫⚫⚪⚫⚫⚪⚫⚪⚫⚫⚫⚫\n⚫⚪⚪⚫⚫⚪⚫⚪⚫⚪⚪⚫⚫⚫⚪⚫⚫⚫⚪⚫⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚪⚪⚫⚫⚪⚫⚫⚪⚪⚪⚫⚫⚪⚫⚫⚫⚪⚫⚫⚫⚪⚫⚫⚫⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫\n⚫⚪⚫⚫⚫⚪⚪⚫⚫⚪⚫⚪⚫⚫⚫⚪⚫⚫⚪⚫⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚪⚪⚫⚪⚫⚪⚫⚫⚪⚫⚫⚪⚫⚫⚫⚫⚪⚫⚫⚫⚫⚪⚫⚫⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫\n⚫⚪⚫⚫⚫⚫⚪⚪⚫⚪⚫⚪⚫⚪⚪⚫⚫⚫⚪⚫⚫⚪⚪⚪⚫⚫⚪⚫⚫⚪⚫⚪⚫⚪⚫⚪⚫⚫⚪⚫⚫⚪⚪⚪⚫⚫⚪⚪⚫⚫⚫⚪⚫⚪⚪⚫⚫⚫⚫⚫⚫⚪⚪⚪\n⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫\n⚫⚫⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚪⚫⚫⚫⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫\n⚫⚫⚫⚪⚫⚫⚪⚫⚫⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫⚪⚫⚫⚪⚪⚫⚫⚪⚫⚫⚫⚪⚪⚫⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚪⚫⚫⚫⚪⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫\n⚫⚫⚫⚫⚫⚪⚫⚪⚫⚪⚪⚫⚫⚫⚪⚪⚫⚫⚪⚪⚫⚪⚫⚪⚫⚪⚪⚪⚫⚪⚫⚪⚫⚪⚪⚫⚫⚪⚪⚫⚫⚫⚪⚫⚫⚪⚫⚪⚫⚫⚪⚫⚫⚪⚪⚪⚫⚪⚪⚫⚫⚫⚪⚫\n⚫⚫⚫⚫⚫⚪⚪⚪⚫⚪⚫⚪⚫⚪⚫⚫⚫⚪⚫⚪⚫⚪⚪⚫⚫⚫⚪⚫⚫⚫⚫⚪⚫⚪⚫⚪⚫⚫⚪⚫⚫⚫⚪⚫⚫⚪⚪⚫⚫⚫⚪⚫⚫⚪⚪⚪⚫⚪⚫⚪⚫⚪⚫⚪\n⚫⚫⚫⚫⚫⚪⚫⚪⚫⚪⚪⚫⚫⚫⚪⚪⚫⚫⚪⚪⚫⚫⚪⚪⚫⚫⚪⚫⚫⚪⚪⚪⚫⚪⚫⚪⚫⚫⚪⚫⚫⚪⚫⚫⚫⚪⚫⚪⚫⚫⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚫⚪⚫\n⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫\n⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚪⚪⚫⚫⚪⚫⚫⚪⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫\n⚫⚪⚪⚫⚫⚫⚪⚪⚫⚫⚫⚫⚫⚫⚪⚪⚫⚫⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚪⚪⚫⚫⚫⚪⚫⚫⚫⚪⚫⚫⚫⚪⚫⚫⚫⚪⚪⚫⚫⚫⚫\n⚫⚪⚫⚪⚫⚪⚫⚪⚫⚫⚪⚪⚫⚪⚪⚫⚫⚪⚪⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚫⚪⚫⚫⚪⚫⚫⚫⚫⚪⚫⚫⚫⚫⚪⚫⚪⚪⚫⚫⚫⚫⚫\n⚫⚪⚪⚫⚫⚫⚪⚪⚫⚪⚫⚫⚫⚫⚪⚪⚫⚫⚪⚫⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚪⚪⚫⚫⚪⚫⚫⚫⚪⚪⚫⚪⚫⚫⚫⚫⚪⚫⚫⚫⚪⚫⚫⚫⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫\n⚫⚪⚫⚫⚫⚫⚫⚪⚫⚪⚫⚫⚫⚪⚪⚫⚫⚫⚪⚪⚫⚫⚪⚪⚫⚫⚪⚫⚫⚪⚪⚪⚫⚪⚫⚪⚫⚪⚪⚫⚫⚪⚪⚫⚫⚫⚪⚪⚫⚫⚪⚫⚫⚪⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫\n⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫\n\t */\n\treturn ch < 0x20 || ch > 127 ? 0 : ints(/*Q*/\n        0x00000,0x33202,0x55000,0x57575,0x36736,0x41241,0x25357,0x22000,0x12221,0x42224,0x05250,0x02720,0x00024,0x00700,0x00066,0x11244,\n        0x75557,0x26227,0x61247,0x61316,0x13571,0x74616,0x34757,0x71244,0x75757,0x75716,0x02020,0x02024,0x12421,0x07070,0x42124,0x61202,\n        0x35543,0x65755,0x65656,0x34443,0x65556,0x34643,0x34644,0x34553,0x55755,0x72227,0x31153,0x55655,0x44447,0x57755,0x65555,0x25552,\n        0x65644,0x25563,0x65655,0x34216,0x72222,0x55557,0x55552,0x55775,0x55255,0x55722,0x71247,0x32223,0x44211,0x62226,0x25000,0x00007,\n        0x21000,0x02575,0x04656,0x00343,0x01353,0x03563,0x12722,0x03517,0x04655,0x20622,0x20224,0x04565,0x06221,0x00775,0x00655,0x00252,\n        0x06564,0x03531,0x00344,0x03636,0x02723,0x00553,0x00552,0x00577,0x00525,0x00536,0x06246,0x32423,0x22222,0x62126,0x03600,0x00000\n        /*E*/)[ch-0x20];\n}\nfloat printNum2_glyphPixel(int cbits, vec2 p) {\n\tint bitshift = 4 * int1(floor(5.0 * p.y)) + int1(floor(4.0 * fract(-p.x)));\n\tfloat bit1 = float1(cbits >> bitshift & 1);\n\tfloat bit2 = float1(cbits >> (4 + bitshift) & 1);\n\treturn bit1 - (1. - bit1) * 0.125 * bit2;\n}\nvec4 printNum2_offset(vec2 U) {\n\tvec2 pos = U/printNum2_ZOOM - printNum2_ORIGIN;\n    float group = floor(pos.y/printNum2_GROUP_HEIGHT);\n    pos.y -= group*printNum2_GROUP_HEIGHT;\n    float line = floor(pos.y/printNum2_LINE_HEIGHT);\n    pos.y -= line*printNum2_LINE_HEIGHT;\n    return vec4(pos,group,line);\n}\nfloat printNum2_line(vec2 U) {\n    vec4 offsetData = printNum2_offset(U);\n    float group = offsetData.z;\n    float line = offsetData.w;\n\treturn line+group*(printNum2_GROUP_SIZE+1.);\n}\nfloat printNum2_IsInside;\nvec2 printNum2(vec2 uv, float value) {\n\tvec2 p2 = printNum2_offset(uv).xy;\n\tprintNum2_IsInside = 0.0;\n\tif(p2.y < 0.0 || p2.y >= printNum2_LINE_HEIGHT) return vec2(0.0,printNum2_IsInside);\n\tprintNum2_IsInside = 1.0;\n\tvec2 p = (p2 - vec2(0,printNum2_LINE_BORDER))/printNum2_FONT;\n\tint index = int1(floor(p.x)),ch,bits;\n\tif(index < 0) {\n\t\tprintNum2_IsInside = 0.0;\n\t\tch = -1;\n\t} else if((bits = floatBitsToInt(value)) << 1 == 0) {\n\t\tprintNum2_IsInside = float1(index <= 4);\n\t\tch = index > 3 ? -1 : ints(bits < 0 ? 0x2D : 0x20, 0x30, 0x2E, 0x30)[index];// [ -]0.0\n\t} else if((bits & 0x7FFFFFFF) - 0x7F800000 == 0) {\n\t\tprintNum2_IsInside = float1(index <= 9);\n\t\tch = index > 8 ? -1 : ints(bits < 0 ? 0x2D : 0x2B,\n                                   0x49, 0x6E, 0x66, 0x69, 0x6E, 0x69, 0x74, 0x79)[index];// [+-]Infinity\n\t} else if((bits & 0x7F800000) - 0x7F800000 == 0) {\n\t\t//printNum2_IsInside = float1(index <= 12);\n\t\t//ch = index > 11 ? -1 : ints(0x4E, 0x6F, 0x74, 0x2D, 0x61, 0x2D, 0x4E, 0x75, 0x6D, 0x62, 0x65, 0x72)[index];// Not-a-Number\n\t\tprintNum2_IsInside = float1(index <= 3);\n\t\tch = index > 2 ? -1 : ints(0x4E, 0x61, 0x4E)[index];// NaN\n\t} else if(bits < 0 && index == 0) {\n\t\tch = 0x2D;\n\t} else if(index == 0) {\n\t\tch = 0x20;\n\t} else {\n\t\t// Subnormal numbers: exponent is effectively one higher, but there's no extra normalization bit in the mantissa.\n\t\t// Normal numbers: leave exponent as it is, but add extra bit to the front of the mantissa.\n\t\t// Exponent: it's actually biased by 127, but we're treating the mantissa as m.0 rather than 0.m,\n\t\t// so we need to subtract another 23 from it. Mantissa: normalize even mantissa to odd.\n\t\tint last1 = (bits | 0xFF800000) & -(bits | 0xFF800000);\n\t\tint numTrail0s = \n            ((-(last1 & 0x55555555) >> 31) + 1) |\n            ((-(last1 & 0x33333333) >> 31) + 1) << 1 |\n            ((-(last1 & 0x0F0F0F0F) >> 31) + 1) << 2 |\n            ((-(last1 & 0x00FF00FF) >> 31) + 1) << 3 |\n            ((-(last1 & 0x0000FFFF) >> 31) + 1) << 4;\n\t\tint m = (bits & 0x7FFFFF | (-(bits >> 23 & 0xFF) >> 8 & 0x800000)) >> numTrail0s;\n\t\tint e = (bits >> 23 & 0xFF) - 149 + (-(bits >> 23 & 0xFF) >> 31) + numTrail0s;\n\t\tint[] to10 = ints(1, 10, 100, 1000, 10000, 100000, 1000000, 10000000);\n\t\tint len;\n\t\tfor(len = 1; len < 8; len++) {\n\t\t\tif(m < to10[len]) break;\n\t\t}\n\t\tint align = (5 * (max(0, e) + len)) % 6;\n\t\tint at21 = len > 6 ? m % to10[len - 6] * to10[12 - len] : 0;\n\t\tint at01 = len > 6 ? m / to10[len - 6] : m * to10[6 - len];\n\t\t/* Fill digits array */\n\t\tint[] digits01 = ints(\n            at01 / to10[align],\n            at01 % to10[align] * to10[6 - align] + at21 / to10[align],\n\t\t\tat21 % to10[align] * to10[6 - align], /*Q*/0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0/*E*/);\n\t\tint mulBy = e < 0 ? 5 : 2;\n\t\tint divBy = e < 0 ? 2 : 5;\n\t\tint first = align;\n\t\tfor(int i = 0, n = abs(e); i < n; i++) {\n\t\t\tint indexN = first / 6;\n\t\t\tif(digits01[indexN] < divBy * to10[5 - first % 6]) {\n\t\t\t\tfirst++;\n\t\t\t}\n\t\t\tfor(int index0 = (len + align + i - 1) / 6; index0 >= indexN; index0--) {\n\t\t\t\tint value0 = digits01[index0];\n\t\t\t\tdigits01[index0 + 1] += (value0 * mulBy) % 10 * 100000;\n\t\t\t\tdigits01[index0] = value0 / divBy;\n\t\t\t}\n\t\t}\n\t\tint mid = max(0, e) + len + align;\n\t\tint beg = index + min(first, mid - 1) - 1;\n\t\tint sep = mid - beg;\n\t\tif(sep < min(-1, e)) {\n\t\t\tprintNum2_IsInside = float1(sep == -1 + min(-1, e));\n\t\t\tch = -1;\n\t\t} else if(sep == 0) {\n\t\t\tch = 0x2E;\n\t\t} else {\n\t\t\tint digitIndex = beg + (sep >> 31);\n\t\t\tch = 0x30 + digits01[digitIndex / 6] / to10[5 - (digitIndex % 6)] % 10;\n\t\t}\n\t}\n\treturn vec2(printNum2_glyphPixel(printNum2_glyph(ch), p), printNum2_IsInside);\n}\nvec3 printNum2_print6(vec2 U, vec3 color, vec4 val5, vec4 val4, vec4 val3, vec4 val2, vec4 val1, vec4 val0) {\n\tfloat line = printNum2_line(U);\n\tint index = int1(line - floor(line * 1.0/(printNum2_GROUP_SIZE+1.0)));\n\tif(index >= 0 && index < 24 && mod(line, printNum2_GROUP_SIZE+1.0) < printNum2_GROUP_SIZE) {\n\t\tfloat val = floats(val0.w, val0.z, val0.y, val0.x, val1.w, val1.z, val1.y, val1.x,\n                           val2.w, val2.z, val2.y, val2.x, val3.w, val3.z, val3.y, val3.x,\n                           val4.w, val4.z, val4.y, val4.x, val5.w, val5.z, val5.y, val5.x)[index];\n\t\tvec2 printed = printNum2(U, val);\n\t\tif(printed.y > 0.5) {\n\t\t\tcolor = clamp(clamp(color, 0., 1.) * 0.75 + printed.x, 0., 1.);\n\t\t}\n\t}\n\treturn color;\n}\nvec3 printNum2_print8(vec2 U, vec3 color, vec3 val7, vec3 val6, vec3 val5, vec3 val4, vec3 val3, vec3 val2, vec3 val1, vec3 val0) {\n    return printNum2_print6(U,color,\n                            vec4(val7,val6.x),vec4(val6.yz,val5.xy),vec4(val5.z,val4),\n                            vec4(val3,val2.x),vec4(val2.yz,val1.xy),vec4(val1.z,val0));\n}\n#undef ints\n#undef int1\n#undef floats\n#undef float1\n#endif\n\n\nvec2 R;\n#define MAIN void mainImage(out vec4 O, vec2 U) {R=iResolution.xy;O=image(U);}\nfloat sinpi(float v) {return sin(radians(180.0)*v);}\nvec2  sinpi(vec2  v) {return sin(radians(180.0)*v);}\nvec3  sinpi(vec3  v) {return sin(radians(180.0)*v);}\nvec4  sinpi(vec4  v) {return sin(radians(180.0)*v);}\nfloat cospi(float v) {return cos(radians(180.0)*v);}\nvec2  cospi(vec2  v) {return cos(radians(180.0)*v);}\nvec3  cospi(vec3  v) {return cos(radians(180.0)*v);}\nvec4  cospi(vec4  v) {return cos(radians(180.0)*v);}\nfloat tanpi(float v) {return tan(radians(180.0)*v);}\nvec2  tanpi(vec2  v) {return tan(radians(180.0)*v);}\nvec3  tanpi(vec3  v) {return tan(radians(180.0)*v);}\nvec4  tanpi(vec4  v) {return tan(radians(180.0)*v);}\nfloat atanpi(vec2 v) {return atan(v.y,v.x)/radians(180.0);}\nfloat vmax(vec2 v) {return max(v.x, v.y);}\nfloat vmax(vec3 v) {return max(max(v.x, v.y), v.z);}\nfloat vmax(vec4 v) {return max(max(v.x, v.y), max(v.z, v.w));}\nfloat vmin(vec2 v) {return min(v.x, v.y);}\nfloat vmin(vec3 v) {return min(min(v.x, v.y), v.z);}\nfloat vmin(vec4 v) {return min(min(v.x, v.y), min(v.z, v.w));}\nfloat sgn(float x) {return (x<0.)?-1.:1.;}\nvec2 sgn(vec2 v) {return vec2(sgn(v.x),sgn(v.y));}\nvec3 sgn(vec3 v) {return vec3(sgn(v.x),sgn(v.y),sgn(v.z));}\nvec4 sgn(vec4 v) {return vec4(sgn(v.x),sgn(v.y),sgn(v.z),sgn(v.w));}\n\n", "buffer_b_code": "vec4 image(vec2 U) {\n    ivec2 p = ivec2(U);\n    vec4 O = texelFetch(iChannel1,ivec2(U.x,max(U.y-1.,0.)),0);\n    if(p.y==0) {\n        vec4 tex = texelFetch(iChannel0,ivec2(U.x,0),0);\n        float curr = max(tex.x-texelFetch(iChannel0,ivec2(511,0),0).z,0.);\n        float prev = max(texelFetch(iChannel0,ivec2(U.x,1),0).x-texelFetch(iChannel0,ivec2(511,1),0).z,0.);\n        O.rgb = vec3(curr,max(curr-prev,0.),prev) * vec3(2,8,1) + vec3(0,0.75*O.g,0);\n        O = clamp(O,0.,1.);\n    }\n    return O;\n}\nMAIN", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "vec4 image(vec2 U) {\n    ivec2 p = ivec2(U);\n    vec4 O = vec4(0);\n    if(p.y==0) {\n        int which = int(U.x*16./R.x);\n        p.x = int(mod(U.x*16.,R.x)/R.x*512.);\n        vec4 curr1 = texelFetch(iChannel0,ivec2(p.x,0),0);\n        vec4 curr2 = texelFetch(iChannel0,ivec2(511,0),0);\n        vec4 prev1 = texelFetch(iChannel0,ivec2(p.x,1),0);\n        vec4 prev2 = texelFetch(iChannel0,ivec2(511,1),0);\n        float tC = curr2.z;\n        float lC = curr1.z;\n        float rC = (tC*512.-lC*float(p.x+1))/max(512.-float(p.x+1),1.);\n        float tP = prev2.z;\n        float lP = prev1.z;\n        float rP = (tP*512.-lP*float(p.x+1))/max(512.-float(p.x+1),1.);\n        O.r=-0.25/16.;\n        int which1=0;\n        if(which==  0) {which1=  0;O.r = 0.125*max(tC-rC,0.);}\n        if(which==  1) {which1=  1;O.r = max(tC-tP,0.);}\n        if(which==  2) {which1=  2;O.r = 0.125*max(tC-rP,0.);}\n        if(which==  3) {which1=  3;O.r = 0.125*max(lC-rC,0.);}\n        if(which==  4) {which1=  4;O.r = 0.125*max(lC-tP,0.);}\n        if(which==  5) {which1=  5;O.r = max(lC-lP,0.);}\n        if(which==  6) {which1=  6;O.r = 0.125*max(lC-rP,0.);}\n        if(which==  7) {which1=  7;O.r = max(rC-rP,0.);}\n        if(which==  8) {which1=  8;O.r = 0.125*max(tP-rP,0.);}\n        if(which==  9) {which1=  9;O.r = 0.125*max(lP-rP,0.);}\n        if(which== 10) {which1= 10;O.r = 0.125*max(lC-tC,0.);}\n        if(which== 11) {which1= 11;O.r = max(tP-tC,0.);}\n        if(which== 12) {which1= 12;O.r = 0.125*max(lP-tC,0.);}\n        if(which== 13) {which1= 13;O.r = max(lP-lC,0.);}\n        if(which== 14) {which1= 14;O.r = max(rP-rC,0.);}\n        if(which== 15) {which1= 15;O.r = 0.125*max(lP-tP,0.);}\n\n        O.rgb = 32.*O.r+vec3(0.25);\n        if((which1&7)==0) O.rgb *= 1.*vec3(3,0,1)*0.25+0.25;\n        if((which1&7)==1) O.rgb *= 1.*vec3(3,1,0)*0.25+0.25;\n        if((which1&7)==2) O.rgb *= 1.*vec3(3,2,0)*0.25+0.25;\n        if((which1&7)==3) O.rgb *= 1.*vec3(1,3,0)*0.25+0.25;\n        if((which1&7)==4) O.rgb *= 1.*vec3(0,3,2)*0.25+0.25;\n        if((which1&7)==5) O.rgb *= 1.*vec3(0,2,3)*0.25+0.25;\n        if((which1&7)==6) O.rgb *= 1.*vec3(0,1,3)*0.25+0.25;\n        if((which1&7)==7) O.rgb *= 1.*vec3(2,0,3)*0.25+0.25;\n\n        //        O.rgb = vec3(0.0625*curr.x,8.0*abs(curr.x-prev.x),0.0625*max(curr.x-curr.z,0.));\n    } else {\n        vec4 next = texelFetch(iChannel1,p-ivec2(0,1),0);\n        O.rgb = next.xyz;\n    }\n    O.a = 0.0;\n    O = clamp(O,0.,1.);\n    //O = floor(max(2.-abs(texelFetch(iChannel0,ivec2(U.x,1),0).yxzw*R.y-U.y),0.));\n    //O = p.y==0 ? texelFetch(iChannel0,uv,0) : vec4(texelFetch(iChannel1,ivec2(U.x,U.y-1.),0).x,O.yzw);\n    return O;\n}\nMAIN", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2cRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 90], [91, 91, 117, 117, 323], [325, 325, 345, 345, 2524]], "test": "untested"}
{"id": "WdscRf", "name": "大龙猫 - Quicky#029", "author": "totetmatt", "description": "I know, one day I'll need to learn a Ray marching by heart to start 3D :D ", "tags": ["instagram", "quicky"], "likes": 5, "viewed": 330, "published": 3, "date": "1586117848", "time_retrieved": "2024-07-30T21:14:40.549931", "image_code": "float fig(vec2 uv,float nb){\n    return smoothstep(0.005,0.01,abs(length(uv)-0.3+sin(iTime+atan(uv.x,uv.y)*nb)*.15)-.02);\n}\nmat2 r(float a){\n    float c=cos(a),s=sin(a);\n    return mat2(c,-s,s,c);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy -.5* iResolution.xy)/iResolution.y;\n    uv*=1.5;\n    float d = fig(uv,4.0);\n     float b = 0.;\n    for(float i=0.;i<=1.;i+=1./4.){\n        uv  = abs(uv)-.2;\n        uv *= r(i*3.14);\n        b +=fig(uv*r(i-iTime),3.0)*1./4.;\n    }\n      uv*=r(floor(length(sin(uv*10.)*.9)*10.));\n     float q = fig(uv,10.0);\n    vec3 col = vec3( (.5/d*b) + q ,(.3/d*b) + q  ,((sin(iTime+length(uv*10.))*.1+.2)/d*b) + q   );\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdscRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 123], [124, 124, 140, 140, 198], [199, 199, 254, 254, 721]], "test": "untested"}
{"id": "ws2yRh", "name": "Night Skyline Buffered", "author": "unclenorton", "description": "A version of the night skyline shader. This is essentially a mash-up of three different shaders with some tweaks:\nSkyline: https://www.shadertoy.com/view/4tXSRM\nRays: https://www.shadertoy.com/view/4djBDR\nHexagon: https://www.shadertoy.com/view/lsBfRc", "tags": ["night", "buffer", "skyline"], "likes": 7, "viewed": 488, "published": 3, "date": "1586117581", "time_retrieved": "2024-07-30T21:14:41.368742", "image_code": "// Based off https://www.shadertoy.com/view/4tXSRM\n\n#define MAX_DEPTH 20\n\n// Courtesy of http://www.science-and-fiction.org/rendering/noise.html\nfloat noise(vec2 p) {\n\treturn fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 456367.5453);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Scale coordinates to [0, 1]\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    \n    vec4 vCol = vec4(0.);\n    vec4 peaks = vec4(1.);\n    \n    // Start from the back buildings and work forward, so buildings in the front cover the ones in the back\n    \n    int shootingLevel = int(floor(noise(vec2(float(iFrame))) * float(MAX_DEPTH)));\n    \n\tfor (int i = 1; i < MAX_DEPTH; i++) {\n        // This is really \"inverse\" depth since we start from the back\n\t\tfloat depth = float(i);\n        \n        // Create a step function where the width of each step is constant at each depth, but increases as\n        // the depth increases (as we move forward). We will get the same step value for multiple p.x\n        // values, which will give our building width. iTime creates the scrolling effect.\n\t\tfloat step = floor(400. * p.x / depth + 100. * depth + iTime);\n        \n        // Use the noise function to get the y coordinate of the top of the building, and decrease this\n        // height the closer we are to the front. If our pixel is below this height, we set its color\n        // depending on it's depth. \n        float threshold = noise(vec2(step)) - depth * .04;\n\t\tif (p.y <= threshold) {\n            if (threshold - p.y < 0.001) {\n                // Draw the lights on top\n                vCol = vec4(1., 0.9, 0.2, 1.0) * noise(vec2(p.y));\n            } else {\n                // Generate a randomised base color\n                vec4 randomColor = vec4(noise(vec2(step / 50.))*.7, 0.1, noise(vec2(step / 10.))*1.25, 1.0);\n                // Apply the color as a gradient\n\t\t\t\tvCol = randomColor * vec4(depth / 6. * p.y) * noise(vec2(step));\n            }\n\t\t}\n\n        if (i == 7) {\n            vec4 triangle = texelFetch(iChannel1, ivec2(fragCoord),0);\n            vCol += vec4(triangle.x / 1.5 + 0.01, triangle.y / 1.2, triangle.z + 0.05, 0.);\n        }\n        \n        if (i == shootingLevel - 5) {\n        \tpeaks = texelFetch(iChannel0, ivec2(fragCoord),0);\n        \tvCol += vec4(peaks.x, peaks.y * noise(vec2(step/10.)), peaks.z * 0.15, 1.);\n        }\n\t}\n    \n    //fragColor = vec4(vCol, 1.);\n    fragColor = vec4(vCol.x, vCol.y, vCol.z, 1.);\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Based on https://www.shadertoy.com/view/4djBDR\n\nvoid mainImage( out vec4 f, vec2 g )\n{\n    f.xyz = iResolution;\n    vec2 v = (g+g-f.xy)/f.y*10.;\n    f *= texture(iChannel0, g/f.xy) / length(f);\n    g = vec2(iFrame/50 + 10, iFrame/5);\n    g = v - sin(g) * fract(iTime*.1 + 10.*sin(g))*50.;\n    f += .05 / max(abs(g.x), g.y);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Based on https://www.shadertoy.com/view/lsBfRc\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nfloat getTriangle(vec2 p, vec2 rp) {\n    p -= rp;\n\n    vec3 color = vec3(0.0);\n    float d = 0.0;\n    \n    // the sound texture is 512x2\n    int tx = int(p.y*512.0);\n    \n    // second row is the sound wave, one texel is one mono sample\n    float wave = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n\n    // Number of sides of your shape\n    // FIXME: this is not achieving the result intended\n    int N = int(5. + smoothstep(wave, wave + 0.1, 1.) * 1.);\n\n    // Angle and radius from the current pixel\n    float a = atan(p.x,p.y)+PI * abs(sin(wave/16.)) - iTime / 1.5;\n    float r = TWO_PI/float(N);\n\n    // Shaping function that modulate the distance\n    d = cos(floor(sin(iTime)+a/r)*r-a)*length(p);\n\n    return smoothstep(.15,d,0.)-smoothstep(.144,d, 0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // create pixel coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 ctr = uv - vec2(0.5,0.65);\n    // Make it a circle by applying the aspect ratio\n    ctr.x *= iResolution.x / iResolution.y;\n\n    float triangle = getTriangle(ctr, vec2(0.0, -0.25 + sin(iTime)/10.));\n    fragColor = vec4(triangle);\n}", "buffer_b_inputs": [{"id": 21792, "src": "https://soundcloud.com/subroomerrecords/cihangir-aslan-rituel", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2yRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 145, 166, 166, 235], [237, 237, 292, 327, 2446]], "test": "untested"}
{"id": "WlGXzz", "name": "BotMaricarmen", "author": "glk7", "description": "A procedural 3D model of BotMaricarmen ([url]https://twitter.com/botMaricarmen[/url]). Original design by LabRat ([url]https://twitter.com/Lab___Rat[/url]). \n\nSelf reflections can be enabled/disabled setting the SELF_REFLECTION macro.", "tags": ["sdf", "modeling", "vndf"], "likes": 18, "viewed": 637, "published": 3, "date": "1586112769", "time_retrieved": "2024-07-30T21:14:42.409958", "image_code": "// Created by genis sole - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n// Visuals are based on a desing by LabRat (https://twitter.com/Lab___Rat) \n\n\n#define ZERO min(0, iFrame)\n\n#define AA 0\n#define SELF_REFLECTION 1\n\nconst int REFLECTION_SAMPLES = 10;\n\nconst float PI = 3.1415926536;\n\n\n//from https://www.shadertoy.com/view/4djSRW\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 cylIntersect( vec3 ro, vec3 rd, float r )\n{\n    float a = 1.0 - rd.y*rd.y;\n    float b = dot(ro, rd) - ro.y*rd.y;\n    float c = dot(ro, ro) - ro.y*ro.y - r*r;\n    float h = b*b - a*c;\n    \n    if( h < 0.0 ) return vec2(-1.0);\n    \n    h = sqrt(h);\n    \n    return vec2(-b-h,-b+h)/a;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/smin\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n// https://iquilezles.org/articles/distfunctions\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\n//https://iquilezles.org/articles/distfunctions2d\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p);\n    float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdHeadRivetes(vec3 p, float d)\n{\n    p.x -= 0.2;\n    vec2 xp = vec2(length(p.yz), atan(p.z, p.y));\n    float tp = mod(xp.y + 0.05, 2.0*PI/15.) - PI/15.;\n    \n    vec3 tpp = vec3(p.x, sin(tp)*xp.x, cos(tp)*xp.x);\n\n   \treturn smax(length(tpp.yx) - 0.07, (d - 0.04), 0.03);\n}\n\nfloat sdArmsOverlay(vec3 p, float d)\n{\n    p.x = abs(p.x);\n    float o = sdEllipsoid(p - vec3(0.5, 1.1, 0.0), vec3(0.3, 1.0, 0.5));\n    \n    return smax((abs(d) - 0.02), o, 0.05);\n}\n\nfloat sdBodyOverlay(vec3 p, float d)\n{\n    float o = sdEllipsoid(p - vec3(2.0, -4.9, -0.5), vec3(1., 1.8, 1.5));\n   \t//float o = sdEllipsoid(p - vec3(1.9, -4.9, -0.5), vec3(1., 1.8, 1.9));\n    return smax((abs(d) - 0.02), o, 0.05);\n}\n\nfloat sdArmsRivetes(vec3 p, float d)\n{\n    float c = abs(p.y-1.1) - 1.0;\n    p.y = mod(p.y - 0.2, 0.6) - 0.5*0.6;\n    float rivetes = length(p.yz) - 0.085;\n    rivetes = smax((d - 0.05), rivetes, 0.05);\n    rivetes = max(c, rivetes);\n\n    return rivetes;\n}\n\nfloat sdBodyRivetes(vec3 p, float d)\n{ \n    float c = p.y-1.5;\n    \n    p.z = -abs(p.z + 0.4);\n    p.xz = (mat2(4, -3, 3, 4) / 5.0) * p.xz;\n \tp.z += 0.15;\n    \n    p.y = mod(p.y + 0.3, 0.7) - 0.5*0.5;\n    float r = length(p.yz) - 0.085;\n    r = smax(d - 0.05, r, 0.05); \n    \n    return max(c, r);\n}\n\nfloat sdHeadBase(vec3 p)\n{\n    float skull = sdEllipsoid(p - vec3(0.0, -1.1, 0.0), vec3(2.15, 1.5, 1.8));\n    skull = smin(sdEllipsoid(p - vec3(0.0, -0.35, 0.0), vec3(2.07, 2.07, 1.8)), skull,  0.5);\n    skull = smax(-p.y-1.8, skull, 1.0) - 0.505;\n    \n    return skull;\n}\n\nvec3 transformHeadSeam(vec3 p)\n{\n    p = p - vec3(0.8, -0.8, 0.0);\n    p.xz = (mat2(15,-8,8, 15) / 17.0) * p.xz;\n    p.x = abs(p.x);\n    return p;\n}\n\nfloat sdHeadSeam(vec3 p, float d)\n{\n    return max(p.x - 0.025, abs(d) - 0.1);\n}\n\nfloat sdMouthGap(vec3 p, float d)\n{\n    vec2 mp = p.xy - vec2(0.38, -0.64);\n    float mouth = abs(abs(mp.x - 0.45)) - 0.015;\n    mouth = max(mp.y + 0.05, mouth);\n    mouth = smax(abs(d) - 0.2, mouth, 0.15);\n\n    float tmouth = max(abs(p.z + 4.5) - 4.9, abs(length(mp.xy) - 0.45) - 0.03);\n    tmouth = smax(mp.y - 0.05, tmouth, 0.02);\n    tmouth = smax(min(-(p.x + 0.45), p.y + 0.4), tmouth, 0.05);\n    \n    tmouth = smax(abs(d) - 0.4, tmouth, 0.05);\n    return min(tmouth, mouth);\n}\n\nfloat sdHead(vec3 p, float d)\n{\n    vec3 bs = p - vec3(0.0, -1., 2.5);\n    bs.yz = (mat2(15,-8,8, 15) / 17.0) * bs.yz;\n    \n    d = smax(bs.z + 0.2, d, 0.7); \n\n    return d;\n}\n\nfloat sdEars(vec3 p)\n{\n    vec3 eap = p - vec3(0.9, 2.15, 0.0);\n    eap.xy = (mat2(3, 4, -4, 3) / 5.0) * eap.xy;\n    float ears = sdEllipsoid(eap, vec3(1.98, 1.4, 0.8)*1.17);\n    ears = smax(-length(eap.xy + vec2(12.38, 0.12)) + 12.5, ears, 0.6);\n    \n    float f = sdEllipsoid(eap - vec3(-4.5, 0., 0.15), vec3(5.0, 5.0, 0.3));\n    f = smax(ears, f, 0.2) - 0.03;\n    \n    \n    ears = smax(-eap.z, abs(ears - 0.05) - 0.08, 0.35);\n\tears = smin(f, ears, 0.02);\n    \n    return ears;\n    /*\n    vec3 pe = eap - vec3(1.3, -0.6, 0.3); \n    pe.xy = (mat2(187, -84, 84, 187)/ 205.0) * pe.xy;\n    \n    float pr1 = sdTriPrism(pe, vec2(1.5, 0.01));\n  \tpr1 = smax(pe.x, pr1, 0.05);\n    \n    float pr2 = sdTriPrism(pe - vec3(0.15, 0.0, 0.0), vec2(1.2, 0.01));\n    pr2 = smax(pe.x - 0.15, pr2, 0.05);\n    \n    return smin(ears, smin(pr1, pr2, 0.01) - 0.04, 0.01);*/\n}\n\nfloat sdCollar(vec3 p)\n{\n    vec3 cp = p - vec3(0.0, -1.4, -0.1);\n    float collar = smax(abs(cp.y) - 0.01, length(cp.xz) - 1.3, 0.1) - 0.15;\n    return collar;\n}\n\nfloat sdMedallion(vec3 p)\n{\n  \tvec3 mp = p - vec3(0.0, -2.0, -1.45);\n    mp.z = abs(mp.z);\n    float medallion = length(mp.xy) - 0.6;\n    medallion = max(medallion, (length(mp - vec3(0.0,0.0,-1.25)) - 1.5));//, 0.03);\n    \n    \n    float g = (length(mp.xy) - 0.23);\n    g = min(max(mp.y, abs(mp.x) - 0.03), g);\n    g = max((abs(medallion) - 0.1), g) - 0.01;\n    medallion = smax(-g, medallion, 0.05);\n    \n    return medallion;\n}\n\nvec3 transformTail(vec3 p)\n{\n    p -= vec3(0.0, -3.7, 1.65);\n    p.yz = (mat2(4, 3, -3, 4) / 5.0) * p.yz;\n    return p;\n}\n\nfloat sdTailRod(vec3 p)\n{\n\treturn max(abs(p.z + 0.1) - 0.3, length(p.xy) - 0.06);\n}\n\nfloat sdTailSphere(vec3 p)\n{\n    return length(p - vec3(0.0, 0.0, 0.1)) - 0.3;\n}\n\nfloat sdFeet(vec3 p, float d)\n{\n    float s = abs(max(p.z, d)) - 0.1;\n    s = max(abs(abs(p.x -0.7) - 0.2) - 0.0325, s);\n    s = smax(p.y + 6., s, 0.05);\n  \n    return smax(-s, d, 0.02);\n}\n\nvec3 transformArms(vec3 p)\n{\n    vec3 ap = p - vec3(2.4, -4.2, -0.3);\n    ap.xy = (mat2(187, -84, 84, 187)/ 205.0) * ap.xy;\n    ap.xz = (mat2(4, 3, -3, 4) / 5.0) * ap.xz;\n    \n    const float k = -0.07;\n    float c = cos(k*(p.y));\n    float s = sin(k*(p.y));\n    \n    mat2  m = mat2(c,s,-s,c);\n \tap = vec3(m*ap.yx,ap.z).yxz;\n    \n    return ap;\n}\n    \nfloat sdArms(vec3 p)\n{\n   \treturn sdRoundCone(p, 0.6, 0.3, 3.3);\n}\n\nfloat sdBodyBase(vec3 p)\n{\n\tvec3 ubp = p - vec3(0.0, -4., -0.2);\n\n    vec2 q = vec2(length(ubp.xz), ubp.y);  \n    \n    return sdRhombus(q, vec2(1.17, 6.0)) - 0.5;\n}\n\nfloat sdBody(vec3 p, float d)\n{\n    vec3 ubp = p - vec3(0.0, -4.2, -0.2);\n\n    float body = d;\n    float ls =  (length(ubp.xy - vec2(+6.2, -1.7)) - 5.975);\n    ls = smin(-(ubp.y + 0.2), ls, 0.2);\n   \n    body = smax(ls, body, 0.2);\n\n    body = smax(length(ubp.zy - vec2(5.8, 1.5)) - 7.0, body, 0.5);\n    body = smax(-(length(ubp.zy - vec2(4.0, -2.5)) - 3.5), body, 0.5);\n    body = smax((length(ubp.xy - vec2(-5.1, 0.3)) - 7.0), body, 0.5);\n    //body = smax((length(ubp - vec3(-5.0, 0.3, 0.0)) - 7.0), body, 0.5);\n\n    body = smax(-(ubp.y + 2.2), body, 0.1);\n    \n    return body;\n}\n\n/*\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n//from https://iquilezles.org/articles/palettes\nvec3 colorPalette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n*/\n\nvec3 background(vec3 p, float lod)\n{   \n    \n    return textureLod(iChannel0, normalize(p), lod).rgb;\n    /*\n    vec2 uv = vec2((atan(p.z, p.x) + PI) * (21.0/(2.0*PI)), (21.0 * p.y) / (2.0*PI*20.0));\n   \tvec2 id = vec2(floor(uv.x/1.5), 0.0);\n    \n    float ry = (hash23(vec3(id.x, 388.0, 342.0)).x - 0.5) * 2.0;\n    \n    uv.y += iTime*ry;\n    id.y = floor(uv.y/1.5);\n\n    vec2 t = hash23(vec3(id, 321.0));\n    \n    uv = vec2(mod(uv.x, 1.5) - 0.75, mod(uv.y, 1.5) - 0.75);\n     \n   \tfloat d0 = max(sdBox(uv, vec2(0.2, 0.4)) - 0.2, -(sdBox(uv, vec2(0.1, 0.3)) - 0.14));\n    float d1 = sdBox(uv - vec2(0.0, 0.0), vec2(0.1, 0.6));\n    \n    float d = mix(d0, d1, step(t.x, 0.5));\n    \n    vec3 c = colorPalette(t.x, vec3(1.0), vec3(0.7), vec3(1.0), vec3(0.0, 0.333, 0.666));\n    c *= smoothstep(0.1, 0.0, d);\n    return (c*c)*0.8 + 0.1;*/\n\n    \n}\n\nvec4 material(vec3 p, float lod)\n{\n    if (dot(p.xz, p.xz) > 19.0*19.0) return vec4(background(p, lod), -1.0);\n    \n    p.x = abs(p.x);\n    \n    if (p.y+6.4 < 0.002) return vec4(0.56, 0.57, 0.58, 0.1)*0.5;\n    \n    if (p.y < -1.2) {\n        if (p.z > 1.2) {\n            if (sdTailSphere(transformTail(p)) < 0.002) {\n                return vec4(0.93, 0.2, 0.3, 0.6);\n            }\n        }\n       \t\n        if (p.y > -2.6) {\n            float collar = sdCollar(p);\n    \t\tfloat medallion = smax(-collar, sdMedallion(p), 0.05);\n        \tif (medallion < 0.002) return vec4(1.00, 0.71, 0.29, 0.05);\n        \n    \t\tif (collar < 0.002) return vec4(0.95, 0.2, 0.2, 0.7);\n        }\n        \n        vec3 ap = transformArms(p);\n    \tfloat arms = sdArms(ap);\n    \tif (arms < 0.1) {\n            float aoverlay = sdArmsOverlay(ap, arms);\n            float arivetes = sdArmsRivetes(ap, aoverlay);;\n\n            if (aoverlay < 0.002) return vec4(0.56, 0.57, 0.58, 0.1);\n            if (arivetes < 0.002) return vec4(0.56, 0.57, 0.58, 0.3) *0.6;\n    \t}\n        \n        vec3 lp = p - vec3(0.925, -5.1, 0.0);\n        lp.xy = (mat2(-144, 17, 17, 144) / 145.0) * lp.xy;\n\n        float body = sdBody(p, sdBodyBase(p));\n        if (body < 0.1) {\n            \n            float feet = smax(lp.y + 0.3, body, 0.05);\n\t\t\tif (feet < 0.002) return vec4(0.56, 0.57, 0.58, 0.5);\n            \n            body = max(-(lp.y + 0.3), body);\n\t\t\tfloat boverlay = sdBodyOverlay(p, body);\n            float brivetes = sdBodyRivetes(lp, boverlay);\n            \n\t\t\tif (boverlay < 0.002) return vec4(0.56, 0.57, 0.58, 0.1);\n            if (brivetes < 0.002) return vec4(0.56, 0.57, 0.58, 0.3) *0.6;\n        }\n    }\n \n    if (p.y > -1.5 && p.z < 0.0) {\n        vec3 hp = p - vec3(0.0, 1.0, 0.0);\n    \tfloat head = sdHeadBase(hp);\n        vec3 hrp = transformHeadSeam(hp);\n        \n        if (hrp.x - 0.3 < 0.0) {\n            //return vec4(1.0);\n            if (sdHeadRivetes(hrp, head) < 0.002) {\n                return vec4(0.56, 0.57, 0.58, 0.3*0.6);\n            }\n        }\n    }\n    \n    return vec4(0.91, 0.92, 0.92, 0.35);\n}\n\nfloat map(vec3 p)\n{\n    p.x = abs(p.x);\n    \n    float head = -(p.y + 1.3);\n    if (head < 0.1) {\n    \tvec3 hp = p - vec3(0.0, 1.0, 0.0);\n    \thead = sdHeadBase(hp);\n    \n        if (head < 0.1 ) {\n            head = sdHead(hp, head);\n            if (p.z < 0.0) {\n                vec3 st = transformHeadSeam(hp);\n                float front = max(p.z + 0.15, head);\n            \tif (st.x < 0.3) {\n            \t\tfloat hs = sdHeadSeam(st, front);\n            \t\tfloat hr = sdHeadRivetes(st, front);\n                \thead = smax(head, -hs, 0.02);\n                    head = min(head, hr);\n                }\n                if (p.x < 1.0 && p.y < 0.5) {\n                    float hm = sdMouthGap(hp, front);\n                    head = smax(head, -hm, 0.02);\n                }\n            }\n        }\n        \n        float ears = min(length(p - vec3(1.9, 2.6, 0.6)) - 1.55, (head - 0.1));\n\n        if (ears < 0.1) {\n           //head = min(head, sdEars(hp));\n           ears = sdEars(p - vec3(0.0, 1.0, 0.0));\n           //if (ears < 0.1) ;\n        }\n        head = min(head, ears);\n    }\n\n    \n    float bodys = -min( -(p.y + 1.2), p.y + 6.4) ;\n    if (bodys < 0.1) {\n      \tfloat bbody = sdBodyBase(p);\n        float body = bbody;\n        \n        if (bbody < 0.1) {\n            body = sdBody(p, bbody);\n            if (body < 0.1) {\n                vec3 lp = p - vec3(0.925, -5.1, 0.0);\n                lp.xy = (mat2(-144, 17, 17, 144) / 145.0) * lp.xy;\n\n                float feet = 1000.0;\n                if (lp.y < 0.3) {\n                \tfeet = smax((lp.y + 0.3), body, 0.06);\n                \tfeet = max(sdFeet(p, feet), feet);\n                }\n                \n                body = smax(-(lp.y + 0.3), body, 0.06);\n\n                float boverlay = sdBodyOverlay(p, body);\n                \n                if (boverlay < 0.1) {\n                \tbody = smax(-(boverlay - 0.03), body, 0.03);\n                    body = min(boverlay, body);\n                    body = min(sdBodyRivetes(lp, body), body);\n                }\n                \n                body = min(feet, body);\n            }\n        }\n        \n        float collar = max(-p.y - 2.5, bbody - 0.3);\n        if(collar < 0.1) {\n       \t\tcollar = sdCollar(p);\n        \tfloat medallion = sdMedallion(p);\n            collar = min(body, min(collar, smax(-collar, medallion, 0.05)));\n        }\n        \n        float tail = max(-(p.z - 1.3), body - 0.6);\n        if (tail < 0.1) {\n            vec3 tp = transformTail(p);\n            tail = smin(body, sdTailRod(tp), 0.1);\n            tail = min(tail, sdTailSphere(tp));\n        }\n        \n        float arms = max(abs(p.z + 0.3) - 0.7, max(-(body + 0.1), bbody - 1.3));\n        if (arms < 0.2) {\n            vec3 ap = transformArms(p);\n            arms = sdArms(ap);\n            if (arms < 0.2) {\n            \tfloat aoverlay = sdArmsOverlay(ap, arms);\n                arms = smax(-(aoverlay - 0.02), arms, 0.02);\n                arms = min(aoverlay, arms);\n               \tarms = min(arms, sdArmsRivetes(ap, arms)); \n            }\n        }\n        \n        bodys = min(tail, min(arms, min(body, collar)));\n\t}\n    \n    \n    float base = p.y + 6.4;\n    if (base < 0.1) {\n     \tbase = smax(base, length(p.xz) - 3.4, 0.1);\n    }\n    \n    return min(head, min(base, bodys));\n\n}\n\nvec4 eyes(vec2 uv)\n{       \n    float l = length(uv);\n    vec2 uvw = fwidth(uv);\n    float duv = max(uvw.x, uvw.y);\n    \n    \n    if (l > 1.0 + duv + 0.02) return vec4(0.0);\n    \n\tvec4 oc = vec4(vec3(0.0), smoothstep(0.01,duv+0.02, -l + 1.0));\n    vec4 ic = vec4(vec3(1.0), smoothstep(0.01, duv+0.1, -l + 0.56));\n    \n    uv -= 0.5;\n    \n    float v = uv.y*10.0;\n    const float k = 2.;\n    float x = mod(iTime*35.0 + v, 45.)*0.01 + 1.5;\n    float h = (2.0*sqrt(k)*x/(1.0+k*x*x)) * (((abs(sin(uv.y*40.0 + iTime*1.0))) * 0.25)) ;\n    \n\treturn vec4(mix(oc.rgb, ic.rgb, ic.a), min(1.0, oc.a*(h + 0.8)));\n}\n\nvec3 normal(vec3 p)\n{\n    const float e = 0.001;\n    const vec2 s = vec2(1.0, -1.0);\n\n    return normalize( \n        s.xyy * map(p + s.xyy*e) + \n        s.yyx * map(p + s.yyx*e) + \n        s.yxy * map(p + s.yxy*e) + \n        s.xxx * map(p + s.xxx*e));\n}\n\nfloat ambient_occlusion(vec3 ro, vec3 n)\n{   \n    float occ = 0.0;\n    float ff = 1.0;\n    \n    for( int i = 0; i < 5; ++i ){\n        float d = 0.1 + 0.03*float(i);\n        \n        float sd = map(ro + n*d);\n        \n        occ += (sd - d)*-ff;\n        ff *= 0.4;\n    }\n    \n    return clamp(1.0 - 2.0*occ, 0.0, 1.0);    \n}\n\nfloat shadow_traversal(vec3 ro, vec3 rd)\n{   \n    float ci = cylIntersect(ro, rd, 3.5).y;\n    \n    float d = 0.0;\n    float s = 1.0;\n    \n    for( int i = ZERO; i < 1 << 7; ++i ){\n        float sd = map(ro + rd*d);\n        \n        if (sd < 0.0001) return 0.0;\n        \n        d += sd;\n        s = min(s, sd*64.0/d);\n        \n        if (d > ci || d > 10.) break;\n    }\n    \n    return s;\n}\n\nfloat traversal(vec3 ro, vec3 rd)\n{\n    vec2 ci = cylIntersect(ro, rd, 3.5);\n    \n   \tfloat sd = max(0.0, ci.x);\n    \n    float d = 1000.0;\n    for( int i = ZERO; i < 1 << 8; ++i ){\n        if (d < 0.001 || sd > ci.y) break;\n        \n        d = map(ro + rd*sd);\n        sd += d;\n    }\n    \n    if (d < 0.001) return sd;\n    \n    return cylIntersect(ro, rd, 20.).y;\n}\n\n//from http://jcgt.org/published/0007/04/01/paper.pdf\nvec3 ggx_vndf_normal(vec3 v, float alpha, vec2 xi)\n{\n\tv = normalize(vec3(alpha*v.xz, v.y).xzy);\n\n    vec3 t1 = v.y < 0.9999 ? normalize(cross(v, vec3(0.0, 1.0, 0.0))) : vec3(0.0, 0.0, 1.0);\n    vec3 t2 = cross(t1, v);\n    \n\tfloat a = 1.0 / (1.0 + v.y);\n\tfloat r = sqrt(xi.x);\n    float phi = (xi.y < a) ? (xi.y/a) * PI : PI + ((xi.y-a)/(1.0-a)) * PI; \n    \n\tfloat p1 = r*cos(phi);\n\tfloat p2 = r*sin(phi) * ((xi.y < a) ? 1.0 : v.y);\n\n\tvec3 n = p1*t1 + p2*t2 + sqrt(max(0.0, 1.0 - p1*p1 - p2*p2))*v;\n\t\n    return normalize(vec3(alpha * n.xz, max(0.0, n.y)).xzy);\n}\n\nfloat ggx_sample_lod(float ndoth, float alpha2, float inv_sa_alpha2)\n{\n\tfloat dd = ((ndoth * ndoth) * (alpha2 - 1.0) + 1.0);\n\n  \treturn 0.5 * log2(dd*dd*inv_sa_alpha2 + 0.0001);  \n}\n\nvec3 ggx_sample(vec3 ro, vec3 rd, vec3 n, vec4 mat)\n{\n    float a2 = mat.a*mat.a;\n    \n    mat3 b;\n    b[0] = (abs(n.y) < 0.9999) ? normalize(cross(n, vec3(0.0, 1.0, 0.0))) : vec3(0.0, 0.0, 1.0);\n    b[1] = n;\n    b[2] = cross(n, b[0]);\n\n    vec3 v = rd*b;\n    vec3 c = vec3(0.0);\n    \n    ro += n*0.01;\n    \n    float inv_sa_alpha2 = (1024.0*1024.0*6.0) / (float(REFLECTION_SAMPLES) * a2);\n    for (int i = ZERO; i < REFLECTION_SAMPLES; ++i){\n        \n        vec2 xi = hash23(ro*500.0 + float(i));\n        vec3 m = ggx_vndf_normal(-v, mat.a, xi.xy);\n \n        vec3 r = reflect(v, m);\n        \n        float rdotm = max(0.0, dot(r, m)); \n        \n        float g = 2.0 / (sqrt(1.0 + (a2*dot(r.xz, r.xz) / (r.y*r.y))) + 1.0); \n        \n        vec3 sd = b*r;\n        vec4 smat = vec4(0.0);\n        float lod = ggx_sample_lod(m.y, a2, inv_sa_alpha2);\n\n#if SELF_REFLECTION   \n        float d = abs(traversal(ro + sd*0.01, sd));\n       \n        vec3 p = ro + sd*(d+0.01);\n        \n        smat = material(p, lod);\n        \n        if (smat.a > 0.0) {\n            smat.rgb *= 0.3*ambient_occlusion(p, normal(p));// - xi.x*0.05; \n        }\n#else  \n        float bi = cylIntersect(ro, sd, 20.0).y;\n        smat.rgb = background(ro + bi*sd, lod);\n#endif\n        c += vec3(smat.rgb*g*rdotm);\n    }\n\n    vec3 scol = (c.rgb/float(REFLECTION_SAMPLES));    \n/*    \n#if !SELF_REFLECTION\n    vec3 refd = normalize(reflect(rd, n));\n    float d = abs(traversal(ro + refd*0.01, refd));\n    vec3 p = ro + refd*(d+0.01);\n    \n    vec4 rmat = material(p, 0.0);\n                                                              \n    if (rmat.a > 0.0) {\n        vec3 rcol = rmat.rgb*0.2*ambient_occlusion(p, normal(p));\n        \n        scol = mix(scol, rcol*mat.rgb, pow(1.0 - mat.a, 8.0));\n    }  \t\n#endif\n*/   \n   return scol;                        \n}    \n    \nvec3 shade(vec3 p, vec3 rd, float d)\n{\n    const vec3 l = normalize(vec3(0.0, 2.0, -2.0));\n    \n    vec4 mat = material(p, 0.0);\n    if (mat.a < 0.0) return mat.rgb + pow(max(0.0, dot(l, rd)), 20.0);\n    \n    vec3 n = normal(p);\n    \n    vec3 h = normalize(l - rd);\n    \n    float ndotv = max(0.0, dot(n, -rd));\n    float ndotl = max(0.0, dot(n, l));\n    float ndoth = max(0.0, dot(n, h));\n    \n    float a = mat.a;\n    float a2 = a*a;\n    float dd = (ndoth*ndoth * (a2 - 1.0) + 1.0);\n    float ggx_d = a2 / (PI * dd * dd);\n    \n    float r = a + 1.0;\n    float k = (r*r) / 8.0;\n\t\n    float ggx1 = ndotv / (ndotv * (1.0 - k) + k);\n    float ggx2 = ndotl / (ndotl * (1.0 - k) + k);\n \n    vec3 fr = mat.rgb;\n   \t//vec3 fr = f0 + (max(vec3(1.0 - a), f0) - f0) * pow(1.0 - ndoth, 5.0);\n    //fr = f0;\n    \n    vec3 spec = (ggx_d * ggx1 * ggx2 * fr) / \n        max(0.001, (4.0 * ndotv * ndotl));\n    \n    float s = shadow_traversal(p + l*0.05, l);\n    float ao = ambient_occlusion(p, n);\n    \n    vec3 refc = ggx_sample(p, rd, n, mat); \n    \n    return 0.6*spec*s*ndotl + ao*fr*0.25 + refc*mat.rgb;\n}\n\nmat3 camera(vec3 p, vec3 t)\n{\n\tvec3 uu = normalize(p - t);\n    vec3 vv = normalize(vec3(uu.z, 0.0001, -uu.x));\n    return mat3(vv, cross(uu, vv), uu);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float e = 1.0/iResolution.x;\n    vec2 uv = (fragCoord - iResolution.xy*0.5) * e;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 t = vec3(0.0);\n    vec3 ro = vec3(0.0);\n   \n    \n    if (dot(m, m) < 0.001) {\n        float k = iTime*0.8;\n        \n     \tm.xy = vec2(sin(k*0.5)*0.02 + 0.5, cos(k*0.4)*0.05 +  0.35);    \n    }\n    \n    m.x = (m.x - 0.5)*(3.0*PI) + PI;\n    \n    ro = vec3(sin(m.x), sin(m.y)*0.75 - 0.2, cos(m.x))*25.0;\n    mat3 cam = camera(ro, t);\n    \n    vec3 rd0 = cam * normalize(vec3(uv, -0.8));\n    \n    float d0 = traversal(ro, rd0);\n    vec3 c = shade(ro + rd0*abs(d0), rd0, abs(d0));\n\n#if AA > 0\n    for (int i = ZERO; i < 1 << (AA << 1); ++i)\n    {\n        vec2 so = (vec2(i & ((1 << AA) - 1), i >> AA) + 0.5) / float(1 << AA) - 0.5;\n        vec3 rd = cam * normalize(vec3(uv + so * e, -0.8));\n\n        float d = traversal(ro, rd);\n        c += shade(ro + rd*d, rd, d);\n    }\n\n    c /= float((1 << (AA << 1)) + 1);\n#endif\n   \n    float ed = -(ro.z + 2.23)/rd0.z;\n    vec2 ep = (ro + rd0*ed).xy;\n    ep.x = abs(ep.x);\n    ep = (ep * 1.38) - vec2(1.9, 1.75);\n    vec4 ec = eyes(ep);\n    c.rgb = mix(c.rgb, ec.rgb, step(ed, d0) * ec.a); \n        \n    vec2 v = uv*0.5;\n    c.rgb = clamp(c.rgb * (1.0 - dot(v, v)*10.0) , 0.0, 1.0);\n    c.rgb += hash23(vec3(uv * 500.0, 221.0)).x * 0.005;\n    \n    fragColor = vec4(pow(c.rgb, vec3(0.4545)), 1.0);\n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "const float PI = 3.1415926536;\n\n\n//from https://www.shadertoy.com/view/4djSRW\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n//from https://iquilezles.org/articles/palettes\nvec3 color_palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 background(vec3 p)\n{   \n    vec2 uv = vec2((atan(p.z, p.x) + PI) * (21.0/(2.0*PI)), (21.0 * p.y) / (2.0*PI*20.0));\n   \tvec2 id = vec2(floor(uv.x/1.5), 0.0);\n    \n    float ry = (hash23(vec3(id.x, 388.0, 342.0)).x - 0.5) * 2.0;\n    \n    uv.y += iTime*ry;\n    id.y = floor(uv.y/1.5);\n\n    vec2 t = hash23(vec3(id, 321.0));\n    \n    uv = vec2(mod(uv.x, 1.5) - 0.75, mod(uv.y, 1.5) - 0.75);\n     \n   \tfloat d0 = max(sdBox(uv, vec2(0.2, 0.4)) - 0.2, -(sdBox(uv, vec2(0.1, 0.3)) - 0.14));\n    float d1 = sdBox(uv - vec2(0.0, 0.0), vec2(0.1, 0.6));\n    \n    float d = mix(d0, d1, step(t.x, 0.5));\n    \n    vec3 c = color_palette(t.x,\n                        vec3(1.0), vec3(0.7), vec3(1.0), vec3(0.0, 0.333, 0.666));\n    c *= smoothstep(0.1, 0.00, d);\n    return c*c*0.8 + 0.1;\n}\n\nvec2 cylIntersect( vec3 ro, vec3 rd, float r )\n{\n    float a = 1.0 - rd.y*rd.y;\n    float b = dot(ro, rd) - ro.y*rd.y;\n    float c = dot(ro, ro) - ro.y*ro.y - r*r;\n    float h = b*b - a*c;\n    \n    if( h < 0.0 ) return vec2(-1.0);\n    \n    h = sqrt(h);\n    \n    return vec2(-b-h,-b+h)/a;\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    vec3 col = background(rayOri - rayDir*cylIntersect(rayOri, -rayDir, 20.0).x);\n    \n    fragColor = vec4(col,1.0);\n}", "cube_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGXzz.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[333, 378, 400, 400, 519], [521, 521, 569, 569, 810], [812, 852, 893, 893, 965], [967, 1007, 1045, 1045, 1142], [1144, 1184, 1225, 1225, 1297], [1299, 1348, 1383, 1383, 1409], [1411, 1460, 1493, 1493, 1558], [1560, 1609, 1646, 1646, 1729], [1730, 1779, 1817, 1817, 1986], [1988, 2037, 2095, 2095, 2359], [2361, 2411, 2440, 2440, 2468], [2469, 2469, 2511, 2511, 2706], [2708, 2757, 2793, 2793, 3143], [3145, 3145, 3183, 3183, 3423], [3425, 3425, 3463, 3463, 3606], [3608, 3608, 3646, 3646, 3841], [3843, 3843, 3881, 3881, 4099], [4101, 4101, 4139, 4139, 4400], [4402, 4402, 4428, 4428, 4674], [4676, 4676, 4708, 4708, 4824], [4826, 4826, 4861, 4861, 4906], [4908, 4908, 4943, 4943, 5390], [5392, 5392, 5423, 5423, 5567], [5569, 5569, 5591, 5591, 6422], [6424, 6424, 6448, 6448, 6586], [6588, 6588, 6615, 6615, 7017], [7019, 7019, 7047, 7047, 7140], [7142, 7142, 7167, 7167, 7225], [7227, 7227, 7255, 7255, 7307], [7309, 7309, 7340, 7340, 7497], [7499, 7499, 7527, 7527, 7845], [7851, 7851, 7873, 7873, 7917], [7919, 7919, 7945, 7945, 8083], [8085, 8085, 8116, 8116, 8668], [8964, 8964, 9000, 9000, 9805], [9807, 9807, 9841, 9841, 11898], [11900, 11900, 11919, 11919, 15187], [15189, 15189, 15209, 15209, 15791], [15793, 15793, 15814, 15814, 16046], [16048, 16048, 16090, 16090, 16372], [16374, 16374, 16416, 16416, 16765], [16767, 16767, 16802, 16802, 17134], [17136, 17190, 17242, 17242, 17752], [17754, 17754, 17824, 17824, 17935], [19776, 19776, 19814, 19814, 20871], [20873, 20873, 20902, 20902, 21025], [21027, 21027, 21084, 21084, 22454]], "test": "untested"}
{"id": "3djyz1", "name": "Elliptic curve associativity", "author": "NinjaKoala", "description": "Visualization of a geometric proof of the associativity of the operation\non an elliptic curve as constructed in https://www.shadertoy.com/view/Wd2cR1\n\nMove mouse to animate\n\nSee header comment for verbose explanation", "tags": ["2d", "math", "group", "ellipticcurve"], "likes": 4, "viewed": 379, "published": 3, "date": "1586110662", "time_retrieved": "2024-07-30T21:14:43.635680", "image_code": "/*\nProof of associativity of the group operation on elliptic curves\nfrom\nhttps://www.mathematik.uni-marburg.de/~tbauer/Barth_Ebene_Algebraische_Kurven.pdf\n(which is german, so i translate it here)\n\nSee https://www.shadertoy.com/view/Wd2cR1 for notes on the definition of this operation.\n\nLet p,q,r be points on the curve.\nDefine:\n\nL  := pq\t\t    a := p * q\nM  := 0a\t\tp + q := 0 * a\nN  := (p+q)r\t    b := (p+q) * r\n----------------------------------\nL' := qr\t\t   a' := q * r\nM' := a'0\t\tq + r := a' * 0\nN' := (q+r)p\t   b' := (q+r) * p\n\nThen (p + q) + r = 0 * b and\np + (q + r) = 0 * b'\n\nSo it suffices to show that b = b',\nor equivalently, that p, b and q + r are collinear.\nWe consider the pencil of cubics defined by\n\nλC + μLM'N\n\n(where we identify the pairs (λ',μ') and (λ,μ)\niff there is an real number a such that λ'=aλ and μ'=aμ)\n( <=> (λ:μ) is an element of the projective line )\n\nIf you intersect the curve C with the curve LM'N\nyou get the 9 points:\n\np,q,a in L\nq+r,0,a' in M'\np+q,r,b in N\n\nEvery cubic curve in the pencil goes through this 9 points.\nThere is a cubic curve in the pencil such that\nthe curve intersects L' in q,r,a'\n(which belong to the 9 points above)\nand in a fourth point.\n\nBy Bezout's Theorem, this is only possible when\nC' is the union of L' and a conic section Q.\n\n(https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem)\n\nNone of the remaining 6 Points lie on L'.\nSo they must lie on Q. Because p+q,0,a on M\nare collinear, Q must be the union of two lines, say\nQ is the union of M and L''.\nThe remaining 3 points p,q+r,b not lying on M\nmust then lie on L'', which means they are\ncollinear, which proofs associativity.\n\nThe letters are from the Latin Modern font (https://en.wikipedia.org/wiki/Computer_Modern#Latin_Modern)\nconverted to shader with https://gist.github.com/Ninja-Koala/74fa7652fb4de248949ce1e27b989c14\n\n*/\n\n//#define ZERO 0\n#define ZERO min(0,iFrame)\n\nfloat border;\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n\n\t// normal form: x^2 + px + q = 0\n\tfloat p = coeffs[1] / 2.;\n\tfloat q = coeffs[0];\n\n\tfloat D = p * p - q;\n\n\tif (D < 0.){\n\t\treturn 0;\n\t}\n\telse{\n\t\troots[0] = -sqrt(D) - p;\n\t\troots[1] = sqrt(D) - p;\n\n\t\treturn 2;\n\t}\n}\n\n//From Trisomie21\n//But instead of his cancellation fix i'm using a newton iteration\nint solve_cubic(vec3 coeffs, inout vec3 r){\n\n\tfloat a = coeffs[2];\n\tfloat b = coeffs[1];\n\tfloat c = coeffs[0];\n\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0) { // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = sign(u)*pow(abs(u),1.0/3.0);\n\t\tv = sign(v)*pow(abs(v),1.0/3.0);\n\t\tr[0] = offset + u + v;\t\n\n\t\t//Single newton iteration to account for cancellation\n\t\tfloat f = ((r[0] + a) * r[0] + b) * r[0] + c;\n\t\tfloat f1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\t\tr[0] -= f / f1;\n\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t//Single newton iteration to account for cancellation\n\t//(once for every root)\n\tr[0] = offset + u * (m + m);\n\tr[1] = offset - u * (n + m);\n\tr[2] = offset + u * (n - m);\n\n\tvec3 f = ((r + a) * r + b) * r + c;\n\tvec3 f1 = (3. * r + 2. * a) * r + b;\n\n\tr -= f / f1;\n\n\treturn 3;\n}\n\nfloat cubic_bezier_normal_iteration(float t, vec2 a0, vec2 a1, vec2 a2, vec2 a3){\n\t//horner's method\n\tvec2 a_2=a2+t*a3;\n\tvec2 a_1=a1+t*a_2;\n\tvec2 b_2=a_2+t*a3;\n\n\tvec2 uv_to_p=a0+t*a_1;\n\tvec2 tang=a_1+t*b_2;\n\n\tfloat l_tang=dot(tang,tang);\n\treturn t-dot(tang,uv_to_p)/l_tang;\n}\n\nfloat cubic_bezier_dis_approx_sq(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec2 a3 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a2 = (3. * p0 - 6. * p1 + 3. * p2);\n\tvec2 a1 = (-3. * p0 + 3. * p1);\n\tvec2 a0 = p0 - uv;\n\n\tfloat d0 = 1e38;\n\n\tfloat t;\n\tvec3 params=vec3(0,.5,1);\n\n\tif(all(lessThan(uv,max(max(p0,p1),max(p2,p3))+border)) && all(greaterThan(uv,min(min(p0,p1),min(p2,p3))-border))){\n\t\tfor(int i=ZERO;i<3;i++){\n\t\t\tt=params[i];\n\t\t\tfor(int j=ZERO;j<3;j++){\n\t\t\t\tt=cubic_bezier_normal_iteration(t,a0,a1,a2,a3);\n\t\t\t}\n\t\t\tt=clamp(t,0.,1.);\n\t\t\tvec2 uv_to_p=((a3*t+a2)*t+a1)*t+a0;\n\t\t\td0=min(d0,dot(uv_to_p,uv_to_p));\n\t\t}\n\t}\n\n\treturn d0;\n}\n\n//segment_dis_sq by iq\nfloat length2( vec2 v ) { return dot(v,v); }\n\nfloat segment_dis_sq( vec2 p, vec2 a, vec2 b ){\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length2( pa - ba*h );\n}\n\nint segment_int_test(vec2 uv, vec2 p0, vec2 p1){\n\tp0-=uv;\n\tp1-=uv;\n\n\tint ret;\n\t\n\tif(p0.y*p1.y<0.){\n\t\tvec2 nor=p0-p1;\n\t\tnor=vec2(nor.y,-nor.x);\n\t\t\n\t\tfloat sgn;\n\t\t\n\t\tif(p0.y>p1.y){\n\t\t\tsgn=1.;\n\t\t}\n\t\telse{\n\t\t\tsgn=-1.;\n\t\t}\n\n\t\tif(dot(nor,p0)*sgn<0.){\n\t\t\tret=0;\n\t\t}\n\t\telse{\n\t\t\tret=1;\n\t\t}\n\t}\n\telse{\n\t\tret=0;\n\t}\n\n\treturn ret;\n}\n\nint cubic_bezier_int_test(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\n\tfloat cu = (-p0.y + 3. * p1.y - 3. * p2.y + p3.y);\n\tfloat qu = (3. * p0.y - 6. * p1.y + 3. * p2.y);\n\tfloat li = (-3. * p0.y + 3. * p1.y);\n\tfloat co = p0.y - uv.y;\n\n\tvec3 roots = vec3(1e38);\n\tint n_roots;\n\n\tint n_ints=0;\n\n\tif(uv.x<min(min(p0.x,p1.x),min(p2.x,p3.x))){\n\t\tif(uv.y>=min(p0.y,p3.y) && uv.y<=max(p0.y,p3.y)){\n\t\t\tn_ints=1;\n\t\t}\n\t}\n\telse{\n\t\tif(abs(cu) < .0001){\n\t\t\tn_roots = solve_quadric(vec2(co/qu,li/qu),roots.xy);\n\t\t}\n\t\telse{\n\t\t\tn_roots = solve_cubic(vec3(co/cu,li/cu,qu/cu),roots);\n\t\t}\n\n\t\tfor(int i=ZERO;i<n_roots;i++){\n\t\t\tif(roots[i] >= 0. && roots[i] <= 1.){\n\t\t\t\tfloat x_pos = -p0.x + 3. * p1.x - 3. * p2.x + p3.x;\n\t\t\t\tx_pos = x_pos * roots[i] + 3. * p0.x - 6. * p1.x + 3. * p2.x;\n\t\t\t\tx_pos = x_pos * roots[i] + -3. * p0.x + 3. * p1.x;\n\t\t\t\tx_pos = x_pos * roots[i] + p0.x;\n\n\t\t\t\tif(x_pos > uv.x){\n\t\t\t\t\tn_ints++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn n_ints;\n}\n\nvec3 line(vec2 p_0, vec2 p_1){\n\tvec2 tan1 = p_1-p_0;\n\tvec2 nor1 = normalize(vec2(tan1.y,-tan1.x));\n\treturn vec3(nor1,-dot(nor1,p_0));\n}\n\nvec2 third_intersection(vec2 p0, vec2 p1, float g_2, float g_3){\n\tvec2 tang=p1-p0;\n\tfloat p0_val = p0.y*p0.y - (( 4.*p0.x*p0.x - g_2 ) * p0.x - g_3);\n\n\tfloat co=p0_val;\n\tfloat li=-12.*p0.x*p0.x*tang.x + g_2*tang.x + 2.*p0.y*tang.y;\n\tfloat qu=-12.*p0.x*tang.x*tang.x+tang.y*tang.y;\n\tfloat cu=-4.*tang.x*tang.x*tang.x;\n\n\tvec3 roots = vec3(1e38);\n\tint n_roots = solve_cubic(vec3(co/cu,li/cu,qu/cu),roots);\n\n\tvec2 p2=vec2(1e38);\n\n\tfor(int i=ZERO;i<n_roots;i++){\n\t\tvec2 tmp=p0+roots[i]*tang;\n\t\tif(distance(tmp,p0)>0.0001 && distance(tmp,p1)>0.0001){\n\t\t\tp2=tmp;\n\t\t}\n\t}\n\n\treturn p2;\n}\n\nfloat L_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[61] p=vec2[](vec2(0.0217975,-0.00740799),\n\t                  vec2(0.0217975,-0.00647717),\n\t                  vec2(0.0208666,-0.00647717),\n\t                  vec2(0.0206339,-0.00647717),\n\t                  vec2(0.019703,-0.00647717),\n\t                  vec2(0.0196255,-0.00670981),\n\t                  vec2(0.0190825,-0.0081837),\n\t                  vec2(0.0166002,-0.0150875),\n\t                  vec2(0.0132647,-0.0240857),\n\t                  vec2(0.00116365,-0.0240857),\n\t                  vec2(-0.00511958,-0.0240857),\n\t                  vec2(-0.0075243,-0.0240857),\n\t                  vec2(-0.0075243,-0.0238531),\n\t                  vec2(-0.0075243,-0.02331),\n\t                  vec2(-0.0075243,-0.0228446),\n\t                  vec2(-0.00729166,-0.0220689),\n\t                  vec2(-0.00721382,-0.0216035),\n\t                  vec2(0.00333581,0.020595),\n\t                  vec2(0.00403395,0.02331),\n\t                  vec2(0.0044994,0.0240857),\n\t                  vec2(0.0107826,0.0240857),\n\t                  vec2(0.0115583,0.0240857),\n\t                  vec2(0.012877,0.0240857),\n\t                  vec2(0.0137303,0.0240857),\n\t                  vec2(0.0137303,0.0255596),\n\t                  vec2(0.0137303,0.0264904),\n\t                  vec2(0.012877,0.0264904),\n\t                  vec2(0.0125667,0.0264904),\n\t                  vec2(0.00907606,0.0264904),\n\t                  vec2(0.00543022,0.0262578),\n\t                  vec2(0.00186196,0.0262578),\n\t                  vec2(-0.00131842,0.0262578),\n\t                  vec2(-0.00457642,0.0264904),\n\t                  vec2(-0.00767923,0.0264904),\n\t                  vec2(-0.00814464,0.0264904),\n\t                  vec2(-0.00915308,0.0264904),\n\t                  vec2(-0.00915308,0.0250166),\n\t                  vec2(-0.00915308,0.0240857),\n\t                  vec2(-0.00853252,0.0240857),\n\t                  vec2(-0.00705867,0.0240857),\n\t                  vec2(-0.00465395,0.0240857),\n\t                  vec2(-0.00255954,0.0240857),\n\t                  vec2(-0.00255954,0.022767),\n\t                  vec2(-0.00255954,0.0225344),\n\t                  vec2(-0.00255954,0.0223791),\n\t                  vec2(-0.00286958,0.0212932),\n\t                  vec2(-0.0133416,-0.0208277),\n\t                  vec2(-0.0139622,-0.0234651),\n\t                  vec2(-0.0144277,-0.0240857),\n\t                  vec2(-0.0197024,-0.0240857),\n\t                  vec2(-0.0209436,-0.0240857),\n\t                  vec2(-0.0217969,-0.0240857),\n\t                  vec2(-0.0217969,-0.0255596),\n\t                  vec2(-0.0217969,-0.0264904),\n\t                  vec2(-0.0210987,-0.0264904),\n\t                  vec2(-0.0198576,-0.0264904),\n\t                  vec2(0.0133427,-0.0264904),\n\t                  vec2(0.0150493,-0.0264904),\n\t                  vec2(0.0151268,-0.026413),\n\t                  vec2(0.0155922,-0.0250941),\n\t                  vec2(0.0214876,-0.00841643));\n\n\tivec2[7] seg=ivec2[](ivec2(9,10),\n\t                     ivec2(16,17),\n\t                     ivec2(20,21),\n\t                     ivec2(45,46),\n\t                     ivec2(55,56),\n\t                     ivec2(59,60),\n\t                     ivec2(60,0));\n\n\tivec4[18] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(3,4,5,6),\n\t                        ivec4(6,7,8,9),\n\t                        ivec4(10,11,12,13),\n\t                        ivec4(13,14,15,16),\n\t                        ivec4(17,18,19,20),\n\t                        ivec4(21,22,23,24),\n\t                        ivec4(24,25,26,27),\n\t                        ivec4(27,28,29,30),\n\t                        ivec4(30,31,32,33),\n\t                        ivec4(33,34,35,36),\n\t                        ivec4(36,37,38,39),\n\t                        ivec4(39,40,41,42),\n\t                        ivec4(42,43,44,45),\n\t                        ivec4(46,47,48,49),\n\t                        ivec4(49,50,51,52),\n\t                        ivec4(52,53,54,55),\n\t                        ivec4(56,57,58,59));\n\n\tif(all(lessThan(uv,vec2(0.0217975,0.0264904)+border)) && all(greaterThan(uv,vec2(-0.0217969,-0.0264904)-border))){\n\t\tfor(int i=ZERO;i<7;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<18;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat M_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[99] p=vec2[](vec2(0.0236592,-0.0250941),\n\t                  vec2(0.0236592,-0.0240857),\n\t                  vec2(0.0231162,-0.0240857),\n\t                  vec2(0.0215648,-0.0240857),\n\t                  vec2(0.0170657,-0.0240857),\n\t                  vec2(0.0170657,-0.0234652),\n\t                  vec2(0.0170657,-0.022767),\n\t                  vec2(0.0170657,-0.022767),\n\t                  vec2(0.0170657,-0.0221465),\n\t                  vec2(0.0173757,-0.0209829),\n\t                  vec2(0.0278478,0.0209829),\n\t                  vec2(0.0284683,0.0234651),\n\t                  vec2(0.0290889,0.0240857),\n\t                  vec2(0.0339759,0.0240857),\n\t                  vec2(0.0356049,0.0240857),\n\t                  vec2(0.036303,0.0240857),\n\t                  vec2(0.036303,0.025482),\n\t                  vec2(0.036303,0.0264904),\n\t                  vec2(0.0356824,0.0264904),\n\t                  vec2(0.0343637,0.0264904),\n\t                  vec2(0.0244347,0.0264904),\n\t                  vec2(0.0227281,0.0264904),\n\t                  vec2(0.0224954,0.0264904),\n\t                  vec2(0.0216421,0.0250941),\n\t                  vec2(-0.00473192,-0.0187333),\n\t                  vec2(-0.0090759,0.0247838),\n\t                  vec2(-0.00923114,0.0264904),\n\t                  vec2(-0.00938638,0.0264904),\n\t                  vec2(-0.0112479,0.0264904),\n\t                  vec2(-0.0215648,0.0264904),\n\t                  vec2(-0.0228059,0.0264904),\n\t                  vec2(-0.0236592,0.0264904),\n\t                  vec2(-0.0236592,0.0250166),\n\t                  vec2(-0.0236592,0.0240857),\n\t                  vec2(-0.0230386,0.0240857),\n\t                  vec2(-0.0215648,0.0240857),\n\t                  vec2(-0.0191601,0.0240857),\n\t                  vec2(-0.0170657,0.0240857),\n\t                  vec2(-0.0170657,0.022767),\n\t                  vec2(-0.0170657,0.0225344),\n\t                  vec2(-0.0170657,0.0223791),\n\t                  vec2(-0.0173757,0.0212932),\n\t                  vec2(-0.0273048,-0.0186558),\n\t                  vec2(-0.0283908,-0.0229997),\n\t                  vec2(-0.0313385,-0.0239306),\n\t                  vec2(-0.0348292,-0.0240857),\n\t                  vec2(-0.0354497,-0.0240857),\n\t                  vec2(-0.036303,-0.0241631),\n\t                  vec2(-0.036303,-0.0255596),\n\t                  vec2(-0.036303,-0.0262577),\n\t                  vec2(-0.0358376,-0.0264904),\n\t                  vec2(-0.0352946,-0.0264904),\n\t                  vec2(-0.0329675,-0.0264904),\n\t                  vec2(-0.0303301,-0.0262578),\n\t                  vec2(-0.0279254,-0.0262578),\n\t                  vec2(-0.0254431,-0.0262578),\n\t                  vec2(-0.0227281,-0.0264904),\n\t                  vec2(-0.0203234,-0.0264904),\n\t                  vec2(-0.019858,-0.0264904),\n\t                  vec2(-0.0189272,-0.0264904),\n\t                  vec2(-0.0189272,-0.0250941),\n\t                  vec2(-0.0189272,-0.0241633),\n\t                  vec2(-0.0194702,-0.0240857),\n\t                  vec2(-0.020401,-0.0240857),\n\t                  vec2(-0.0248225,-0.0239305),\n\t                  vec2(-0.0249777,-0.0219138),\n\t                  vec2(-0.0249777,-0.0207502),\n\t                  vec2(-0.0249777,-0.0205176),\n\t                  vec2(-0.0249777,-0.0200521),\n\t                  vec2(-0.0246674,-0.0188109),\n\t                  vec2(-0.0143505,0.0223792),\n\t                  vec2(-0.0142731,0.0223792),\n\t                  vec2(-0.00954126,-0.0246287),\n\t                  vec2(-0.00938602,-0.0259474),\n\t                  vec2(-0.00938602,-0.0264904),\n\t                  vec2(-0.00822257,-0.0264904),\n\t                  vec2(-0.00721417,-0.0264904),\n\t                  vec2(-0.00682629,-0.0259474),\n\t                  vec2(-0.00636088,-0.0250941),\n\t                  vec2(0.022573,0.0230773),\n\t                  vec2(0.0226504,0.0230773),\n\t                  vec2(0.0117129,-0.0208277),\n\t                  vec2(0.0110924,-0.0234652),\n\t                  vec2(0.010627,-0.0240857),\n\t                  vec2(0.00535212,-0.0240857),\n\t                  vec2(0.004111,-0.0240857),\n\t                  vec2(0.00325771,-0.0240857),\n\t                  vec2(0.00325771,-0.0255596),\n\t                  vec2(0.00325771,-0.0264904),\n\t                  vec2(0.004111,-0.0264904),\n\t                  vec2(0.00434372,-0.0264904),\n\t                  vec2(0.00721385,-0.0264904),\n\t                  vec2(0.0102391,-0.0262578),\n\t                  vec2(0.0131868,-0.0262578),\n\t                  vec2(0.0161345,-0.0262578),\n\t                  vec2(0.0193149,-0.0264904),\n\t                  vec2(0.022185,-0.0264904),\n\t                  vec2(0.022728,-0.0264904),\n\t                  vec2(0.0236588,-0.0264904));\n\n\tivec2[12] seg=ivec2[](ivec2(9,10),\n\t                      ivec2(19,20),\n\t                      ivec2(23,24),\n\t                      ivec2(24,25),\n\t                      ivec2(28,29),\n\t                      ivec2(41,42),\n\t                      ivec2(69,70),\n\t                      ivec2(70,71),\n\t                      ivec2(71,72),\n\t                      ivec2(78,79),\n\t                      ivec2(79,80),\n\t                      ivec2(80,81));\n\n\tivec4[29] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(3,4,5,6),\n\t                        ivec4(6,7,8,9),\n\t                        ivec4(10,11,12,13),\n\t                        ivec4(13,14,15,16),\n\t                        ivec4(16,17,18,19),\n\t                        ivec4(20,21,22,23),\n\t                        ivec4(25,26,27,28),\n\t                        ivec4(29,30,31,32),\n\t                        ivec4(32,33,34,35),\n\t                        ivec4(35,36,37,38),\n\t                        ivec4(38,39,40,41),\n\t                        ivec4(42,43,44,45),\n\t                        ivec4(45,46,47,48),\n\t                        ivec4(48,49,50,51),\n\t                        ivec4(51,52,53,54),\n\t                        ivec4(54,55,56,57),\n\t                        ivec4(57,58,59,60),\n\t                        ivec4(60,61,62,63),\n\t                        ivec4(63,64,65,66),\n\t                        ivec4(66,67,68,69),\n\t                        ivec4(72,73,74,75),\n\t                        ivec4(75,76,77,78),\n\t                        ivec4(81,82,83,84),\n\t                        ivec4(84,85,86,87),\n\t                        ivec4(87,88,89,90),\n\t                        ivec4(90,91,92,93),\n\t                        ivec4(93,94,95,96),\n\t                        ivec4(96,97,98,0));\n\n\tif(all(lessThan(uv,vec2(0.036303,0.0264904)+border)) && all(greaterThan(uv,vec2(-0.036303,-0.0264904)-border))){\n\t\tfor(int i=ZERO;i<12;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<29;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat N_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[82] p=vec2[](vec2(0.0306406,0.025482),\n\t                  vec2(0.0306406,0.0261026),\n\t                  vec2(0.0303302,0.0264904),\n\t                  vec2(0.0296322,0.0264904),\n\t                  vec2(0.0272275,0.0264904),\n\t                  vec2(0.0246677,0.0262578),\n\t                  vec2(0.0221854,0.0262578),\n\t                  vec2(0.0197031,0.0262578),\n\t                  vec2(0.0170657,0.0264904),\n\t                  vec2(0.014661,0.0264904),\n\t                  vec2(0.0142731,0.0264904),\n\t                  vec2(0.0132648,0.0264904),\n\t                  vec2(0.0132648,0.0250166),\n\t                  vec2(0.0132648,0.0241633),\n\t                  vec2(0.0139629,0.0240857),\n\t                  vec2(0.014661,0.0240857),\n\t                  vec2(0.0186947,0.0239305),\n\t                  vec2(0.0193153,0.0223792),\n\t                  vec2(0.0193153,0.0207502),\n\t                  vec2(0.0193153,0.0200521),\n\t                  vec2(0.01916,0.0195091),\n\t                  vec2(0.0190048,0.0188885),\n\t                  vec2(0.0104719,-0.0151651),\n\t                  vec2(-0.00403374,0.0251717),\n\t                  vec2(-0.00449915,0.0264129),\n\t                  vec2(-0.00457673,0.0264904),\n\t                  vec2(-0.00620573,0.0264904),\n\t                  vec2(-0.015902,0.0264904),\n\t                  vec2(-0.0171432,0.0264904),\n\t                  vec2(-0.0179964,0.0264904),\n\t                  vec2(-0.0179964,0.0250166),\n\t                  vec2(-0.0179964,0.0240857),\n\t                  vec2(-0.0173759,0.0240857),\n\t                  vec2(-0.015902,0.0240857),\n\t                  vec2(-0.015359,0.0240857),\n\t                  vec2(-0.0111702,0.0240857),\n\t                  vec2(-0.0111702,0.0234652),\n\t                  vec2(-0.0111702,0.0234652),\n\t                  vec2(-0.0111702,0.0232325),\n\t                  vec2(-0.0114029,0.0224567),\n\t                  vec2(-0.0216422,-0.0186558),\n\t                  vec2(-0.0227282,-0.0229222),\n\t                  vec2(-0.0255983,-0.0239306),\n\t                  vec2(-0.0291666,-0.0240857),\n\t                  vec2(-0.0297872,-0.0240857),\n\t                  vec2(-0.0306405,-0.0241631),\n\t                  vec2(-0.0306405,-0.0255596),\n\t                  vec2(-0.0306405,-0.0262577),\n\t                  vec2(-0.030175,-0.0264904),\n\t                  vec2(-0.029632,-0.0264904),\n\t                  vec2(-0.0273049,-0.0264904),\n\t                  vec2(-0.0246675,-0.0262578),\n\t                  vec2(-0.0222628,-0.0262578),\n\t                  vec2(-0.0197805,-0.0262578),\n\t                  vec2(-0.0170655,-0.0264904),\n\t                  vec2(-0.0146609,-0.0264904),\n\t                  vec2(-0.0141954,-0.0264904),\n\t                  vec2(-0.0132646,-0.0264904),\n\t                  vec2(-0.0132646,-0.0250941),\n\t                  vec2(-0.0132646,-0.0241633),\n\t                  vec2(-0.0138076,-0.0240857),\n\t                  vec2(-0.0147384,-0.0240857),\n\t                  vec2(-0.0191599,-0.0239305),\n\t                  vec2(-0.0193151,-0.0219137),\n\t                  vec2(-0.0193151,-0.0207502),\n\t                  vec2(-0.0193151,-0.0205175),\n\t                  vec2(-0.0193151,-0.020052),\n\t                  vec2(-0.0190046,-0.0188109),\n\t                  vec2(-0.00899801,0.021138),\n\t                  vec2(0.0076797,-0.0251717),\n\t                  vec2(0.00806758,-0.0263353),\n\t                  vec2(0.00814515,-0.0264904),\n\t                  vec2(0.00923112,-0.0264904),\n\t                  vec2(0.0100844,-0.0264904),\n\t                  vec2(0.0103947,-0.026413),\n\t                  vec2(0.0107825,-0.024939),\n\t                  vec2(0.0216424,0.018811),\n\t                  vec2(0.0228836,0.0237754),\n\t                  vec2(0.0272275,0.0240082),\n\t                  vec2(0.0294771,0.0240857),\n\t                  vec2(0.0297097,0.0240857),\n\t                  vec2(0.0306407,0.0241631));\n\n\tivec2[7] seg=ivec2[](ivec2(21,22),\n\t                     ivec2(22,23),\n\t                     ivec2(26,27),\n\t                     ivec2(39,40),\n\t                     ivec2(67,68),\n\t                     ivec2(68,69),\n\t                     ivec2(75,76));\n\n\tivec4[25] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(3,4,5,6),\n\t                        ivec4(6,7,8,9),\n\t                        ivec4(9,10,11,12),\n\t                        ivec4(12,13,14,15),\n\t                        ivec4(15,16,17,18),\n\t                        ivec4(18,19,20,21),\n\t                        ivec4(23,24,25,26),\n\t                        ivec4(27,28,29,30),\n\t                        ivec4(30,31,32,33),\n\t                        ivec4(33,34,35,36),\n\t                        ivec4(36,37,38,39),\n\t                        ivec4(40,41,42,43),\n\t                        ivec4(43,44,45,46),\n\t                        ivec4(46,47,48,49),\n\t                        ivec4(49,50,51,52),\n\t                        ivec4(52,53,54,55),\n\t                        ivec4(55,56,57,58),\n\t                        ivec4(58,59,60,61),\n\t                        ivec4(61,62,63,64),\n\t                        ivec4(64,65,66,67),\n\t                        ivec4(69,70,71,72),\n\t                        ivec4(72,73,74,75),\n\t                        ivec4(76,77,78,79),\n\t                        ivec4(79,80,81,0));\n\n\tif(all(lessThan(uv,vec2(0.0306407,0.0264904)+border)) && all(greaterThan(uv,vec2(-0.0306405,-0.0264904)-border))){\n\t\tfor(int i=ZERO;i<7;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<25;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat prime_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[9] p=vec2[](vec2(0.00421962,0.00845522),\n\t                 vec2(0.0046075,0.00985149),\n\t                 vec2(0.00375421,0.0109375),\n\t                 vec2(0.00235794,0.0109375),\n\t                 vec2(0.000961663,0.0109375),\n\t                 vec2(-0.000512186,0.00985149),\n\t                 vec2(-0.000744913,0.00845522),\n\t                 vec2(-0.00431317,-0.0109375),\n\t                 vec2(-0.00198604,-0.0109375));\n\n\tivec2[3] seg=ivec2[](ivec2(6,7),\n\t                     ivec2(7,8),\n\t                     ivec2(8,0));\n\n\tivec4[2] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                       ivec4(3,4,5,6));\n\n\tif(all(lessThan(uv,vec2(0.0046075,0.0109375)+border)) && all(greaterThan(uv,vec2(-0.00431317,-0.0109375)-border))){\n\t\tfor(int i=ZERO;i<3;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<2;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat plus_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[32] p=vec2[](vec2(0.0257924,-0.0),\n\t                  vec2(0.0257924,0.00155143),\n\t                  vec2(0.0243185,0.00155143),\n\t                  vec2(0.0232326,0.00155143),\n\t                  vec2(0.00159032,0.00155143),\n\t                  vec2(0.00159032,0.0232712),\n\t                  vec2(0.00159032,0.0243572),\n\t                  vec2(0.00159032,0.0258311),\n\t                  vec2(3.88912e-05,0.0258311),\n\t                  vec2(-0.00151253,0.0258311),\n\t                  vec2(-0.00151253,0.0243572),\n\t                  vec2(-0.00151253,0.0232712),\n\t                  vec2(-0.00151253,0.00155143),\n\t                  vec2(-0.0232323,0.00155143),\n\t                  vec2(-0.0243183,0.00155143),\n\t                  vec2(-0.0257922,0.00155143),\n\t                  vec2(-0.0257922,-0.0),\n\t                  vec2(-0.0257922,-0.00155143),\n\t                  vec2(-0.0243183,-0.00155143),\n\t                  vec2(-0.0232323,-0.00155143),\n\t                  vec2(-0.00151253,-0.00155143),\n\t                  vec2(-0.00151253,-0.0232712),\n\t                  vec2(-0.00151253,-0.0243572),\n\t                  vec2(-0.00151253,-0.0258311),\n\t                  vec2(3.88912e-05,-0.0258311),\n\t                  vec2(0.00159032,-0.0258311),\n\t                  vec2(0.00159032,-0.0243572),\n\t                  vec2(0.00159032,-0.0232712),\n\t                  vec2(0.00159032,-0.00155143),\n\t                  vec2(0.0232326,-0.00155143),\n\t                  vec2(0.0243185,-0.00155143),\n\t                  vec2(0.0257924,-0.00155143));\n\n\tivec2[8] seg=ivec2[](ivec2(3,4),\n\t                     ivec2(4,5),\n\t                     ivec2(11,12),\n\t                     ivec2(12,13),\n\t                     ivec2(19,20),\n\t                     ivec2(20,21),\n\t                     ivec2(27,28),\n\t                     ivec2(28,29));\n\n\tivec4[8] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                       ivec4(5,6,7,8),\n\t                       ivec4(8,9,10,11),\n\t                       ivec4(13,14,15,16),\n\t                       ivec4(16,17,18,19),\n\t                       ivec4(21,22,23,24),\n\t                       ivec4(24,25,26,27),\n\t                       ivec4(29,30,31,0));\n\n\tif(all(lessThan(uv,vec2(0.0257924,0.0258311)+border)) && all(greaterThan(uv,vec2(-0.0257922,-0.0258311)-border))){\n\t\tfor(int i=ZERO;i<8;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<8;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat zero_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[48] p=vec2[](vec2(0.0163288,-0.000155151),\n\t                  vec2(0.0163288,0.00605055),\n\t                  vec2(0.0159409,0.0122562),\n\t                  vec2(0.013226,0.0179964),\n\t                  vec2(0.0096577,0.0254432),\n\t                  vec2(0.00329689,0.0266843),\n\t                  vec2(3.89352e-05,0.0266843),\n\t                  vec2(-0.00461534,0.0266843),\n\t                  vec2(-0.010278,0.0246675),\n\t                  vec2(-0.0134584,0.0174534),\n\t                  vec2(-0.0159407,0.012101),\n\t                  vec2(-0.0163286,0.00605055),\n\t                  vec2(-0.0163286,-0.000155151),\n\t                  vec2(-0.0163286,-0.00597297),\n\t                  vec2(-0.0160181,-0.0129543),\n\t                  vec2(-0.0128379,-0.0188497),\n\t                  vec2(-0.00950234,-0.0251329),\n\t                  vec2(-0.00383967,-0.0266843),\n\t                  vec2(-3.86845e-05,-0.0266843),\n\t                  vec2(0.00415014,-0.0266843),\n\t                  vec2(0.0100455,-0.0250554),\n\t                  vec2(0.0134586,-0.0176862),\n\t                  vec2(0.0159409,-0.0123337),\n\t                  vec2(0.0163287,-0.00628323),\n\t                  vec2(0.00989038,0.000775669),\n\t                  vec2(0.00989038,-0.00504211),\n\t                  vec2(0.00989038,-0.0103169),\n\t                  vec2(0.00903714,-0.0152815),\n\t                  vec2(0.00787359,-0.0226507),\n\t                  vec2(0.003452,-0.0249778),\n\t                  vec2(-3.86405e-05,-0.0249778),\n\t                  vec2(-0.00306392,-0.0249778),\n\t                  vec2(-0.00764062,-0.0230385),\n\t                  vec2(-0.00903685,-0.0155917),\n\t                  vec2(-0.00989013,-0.0109375),\n\t                  vec2(-0.00989013,-0.00380099),\n\t                  vec2(-0.00989013,0.000775669),\n\t                  vec2(-0.00989013,0.00574025),\n\t                  vec2(-0.00989013,0.0108599),\n\t                  vec2(-0.00926957,0.0150488),\n\t                  vec2(-0.00779577,0.0242797),\n\t                  vec2(-0.0019779,0.0249778),\n\t                  vec2(-3.86405e-05,0.0249778),\n\t                  vec2(0.00252114,0.0249778),\n\t                  vec2(0.00764087,0.0235816),\n\t                  vec2(0.00911472,0.015902),\n\t                  vec2(0.00989038,0.0115581),\n\t                  vec2(0.00989038,0.00566267));\n\n\tivec4[16] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(3,4,5,6),\n\t                        ivec4(6,7,8,9),\n\t                        ivec4(9,10,11,12),\n\t                        ivec4(12,13,14,15),\n\t                        ivec4(15,16,17,18),\n\t                        ivec4(18,19,20,21),\n\t                        ivec4(21,22,23,0),\n\t                        ivec4(24,25,26,27),\n\t                        ivec4(27,28,29,30),\n\t                        ivec4(30,31,32,33),\n\t                        ivec4(33,34,35,36),\n\t                        ivec4(36,37,38,39),\n\t                        ivec4(39,40,41,42),\n\t                        ivec4(42,43,44,45),\n\t                        ivec4(45,46,47,24));\n\n\tif(all(lessThan(uv,vec2(0.0163288,0.0266843)+border)) && all(greaterThan(uv,vec2(-0.0163286,-0.0266843)-border))){\n\t\tfor(int i=ZERO;i<16;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat a_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[65] p=vec2[](vec2(0.0165615,-0.00562388),\n\t                  vec2(0.0165615,-0.00484817),\n\t                  vec2(0.0159409,-0.00484817),\n\t                  vec2(0.0153979,-0.00484817),\n\t                  vec2(0.014467,-0.00484817),\n\t                  vec2(0.0143895,-0.00492557),\n\t                  vec2(0.0139241,-0.00663228),\n\t                  vec2(0.012838,-0.0109763),\n\t                  vec2(0.0113642,-0.0158632),\n\t                  vec2(0.00872679,-0.0158632),\n\t                  vec2(0.00670996,-0.0158632),\n\t                  vec2(0.00670996,-0.0137688),\n\t                  vec2(0.00670996,-0.0126828),\n\t                  vec2(0.00670996,-0.0121398),\n\t                  vec2(0.00670996,-0.0108987),\n\t                  vec2(0.00725294,-0.00872669),\n\t                  vec2(0.0125278,0.0123726),\n\t                  vec2(0.0128383,0.0134585),\n\t                  vec2(0.0128383,0.0136137),\n\t                  vec2(0.0128383,0.0140015),\n\t                  vec2(0.0128383,0.0156305),\n\t                  vec2(0.0115195,0.0160184),\n\t                  vec2(0.0107438,0.0160184),\n\t                  vec2(0.00826156,0.0160184),\n\t                  vec2(0.00771857,0.013381),\n\t                  vec2(0.007641,0.0129931),\n\t                  vec2(0.00616715,0.0163287),\n\t                  vec2(0.0036849,0.0175698),\n\t                  vec2(0.00120261,0.0175698),\n\t                  vec2(-0.00740776,0.0175698),\n\t                  vec2(-0.0165611,0.00577904),\n\t                  vec2(-0.0165611,-0.00554631),\n\t                  vec2(-0.0165611,-0.0121398),\n\t                  vec2(-0.0129928,-0.0175698),\n\t                  vec2(-0.00717503,-0.0175698),\n\t                  vec2(-0.00438248,-0.0175698),\n\t                  vec2(-0.000969373,-0.0159408),\n\t                  vec2(0.00213348,-0.0121398),\n\t                  vec2(0.00298677,-0.0159408),\n\t                  vec2(0.00585689,-0.0175698),\n\t                  vec2(0.00857186,-0.0175698),\n\t                  vec2(0.011442,-0.0175698),\n\t                  vec2(0.0130709,-0.0156305),\n\t                  vec2(0.0142345,-0.0132258),\n\t                  vec2(0.0156308,-0.0102781),\n\t                  vec2(0.0165616,-0.00562388),\n\t                  vec2(0.00267629,-0.00709773),\n\t                  vec2(0.00205573,-0.00957998),\n\t                  vec2(-0.00275366,-0.0158632),\n\t                  vec2(-0.00702005,-0.0158632),\n\t                  vec2(-0.0106659,-0.0158632),\n\t                  vec2(-0.0112865,-0.0112866),\n\t                  vec2(-0.0112865,-0.00895942),\n\t                  vec2(-0.0112865,-0.00508085),\n\t                  vec2(-0.00888178,0.00399493),\n\t                  vec2(-0.00748551,0.00725288),\n\t                  vec2(-0.00554625,0.0119847),\n\t                  vec2(-0.00197799,0.0158632),\n\t                  vec2(0.00120244,0.0158632),\n\t                  vec2(0.00461555,0.0158632),\n\t                  vec2(0.00655481,0.0118295),\n\t                  vec2(0.00655481,0.00857158),\n\t                  vec2(0.00655481,0.00857158),\n\t                  vec2(0.00647741,0.0080286),\n\t                  vec2(0.00632217,0.00756314));\n\n\tivec2[2] seg=ivec2[](ivec2(15,16),\n\t                     ivec2(64,46));\n\n\tivec4[21] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(3,4,5,6),\n\t                        ivec4(6,7,8,9),\n\t                        ivec4(9,10,11,12),\n\t                        ivec4(12,13,14,15),\n\t                        ivec4(16,17,18,19),\n\t                        ivec4(19,20,21,22),\n\t                        ivec4(22,23,24,25),\n\t                        ivec4(25,26,27,28),\n\t                        ivec4(28,29,30,31),\n\t                        ivec4(31,32,33,34),\n\t                        ivec4(34,35,36,37),\n\t                        ivec4(37,38,39,40),\n\t                        ivec4(40,41,42,43),\n\t                        ivec4(43,44,45,0),\n\t                        ivec4(46,47,48,49),\n\t                        ivec4(49,50,51,52),\n\t                        ivec4(52,53,54,55),\n\t                        ivec4(55,56,57,58),\n\t                        ivec4(58,59,60,61),\n\t                        ivec4(61,62,63,64));\n\n\tif(all(lessThan(uv,vec2(0.0165616,0.0175698)+border)) && all(greaterThan(uv,vec2(-0.0165611,-0.0175698)-border))){\n\t\tfor(int i=ZERO;i<2;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<21;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat b_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[60] p=vec2[](vec2(0.0133423,-0.00430514),\n\t                  vec2(0.0133423,0.00399493),\n\t                  vec2(0.00868805,0.00779591),\n\t                  vec2(0.00403377,0.00779591),\n\t                  vec2(0.00108607,0.00779591),\n\t                  vec2(-0.00155132,0.00616691),\n\t                  vec2(-0.00418872,0.00368467),\n\t                  vec2(0.00124123,0.0254044),\n\t                  vec2(0.00131863,0.0256371),\n\t                  vec2(0.00147387,0.0264129),\n\t                  vec2(0.00147387,0.0264129),\n\t                  vec2(0.00147387,0.027111),\n\t                  vec2(0.00100846,0.0273438),\n\t                  vec2(0.000387894,0.0273438),\n\t                  vec2(0.000155255,0.0273438),\n\t                  vec2(-0.000620546,0.0272664),\n\t                  vec2(-0.000853229,0.0271885),\n\t                  vec2(-0.00853274,0.0265679),\n\t                  vec2(-0.0094636,0.0264905),\n\t                  vec2(-0.0103169,0.0264127),\n\t                  vec2(-0.0103169,0.0249389),\n\t                  vec2(-0.0103169,0.0240857),\n\t                  vec2(-0.00954118,0.0240857),\n\t                  vec2(-0.0084552,0.0240857),\n\t                  vec2(-0.00473179,0.0240857),\n\t                  vec2(-0.00457664,0.0235427),\n\t                  vec2(-0.00457664,0.022767),\n\t                  vec2(-0.00457664,0.0225343),\n\t                  vec2(-0.00480928,0.0214483),\n\t                  vec2(-0.00480928,0.0214483),\n\t                  vec2(-0.0124888,-0.00919219),\n\t                  vec2(-0.0125662,-0.00942483),\n\t                  vec2(-0.0133421,-0.0126053),\n\t                  vec2(-0.0133421,-0.015553),\n\t                  vec2(-0.0133421,-0.022069),\n\t                  vec2(-0.0100841,-0.0273437),\n\t                  vec2(-0.00442145,-0.0273437),\n\t                  vec2(0.0042665,-0.0273437),\n\t                  vec2(0.0133423,-0.0157081),\n\t                  vec2(0.00380109,-0.0182679),\n\t                  vec2(0.00287023,-0.0202071),\n\t                  vec2(-0.000465307,-0.0256371),\n\t                  vec2(-0.00442145,-0.0256371),\n\t                  vec2(-0.00636071,-0.0256371),\n\t                  vec2(-0.00892053,-0.0240081),\n\t                  vec2(-0.00892053,-0.0181903),\n\t                  vec2(-0.00892053,-0.0147772),\n\t                  vec2(-0.00822239,-0.0120622),\n\t                  vec2(-0.00597283,-0.00321917),\n\t                  vec2(-0.00542984,-0.00135744),\n\t                  vec2(-0.00542984,-0.00120229),\n\t                  vec2(-0.00426629,0.00034909),\n\t                  vec2(-0.00201673,0.00345194),\n\t                  vec2(0.000930967,0.00608934),\n\t                  vec2(0.00387867,0.00608934),\n\t                  vec2(0.00736931,0.00608934),\n\t                  vec2(0.00814502,0.00166779),\n\t                  vec2(0.00814502,-0.000814457),\n\t                  vec2(0.00814502,-0.00407241),\n\t                  vec2(0.00605061,-0.0133033));\n\n\tivec2[3] seg=ivec2[](ivec2(6,7),\n\t                     ivec2(16,17),\n\t                     ivec2(29,30));\n\n\tivec4[19] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(3,4,5,6),\n\t                        ivec4(7,8,9,10),\n\t                        ivec4(10,11,12,13),\n\t                        ivec4(13,14,15,16),\n\t                        ivec4(17,18,19,20),\n\t                        ivec4(20,21,22,23),\n\t                        ivec4(23,24,25,26),\n\t                        ivec4(26,27,28,29),\n\t                        ivec4(30,31,32,33),\n\t                        ivec4(33,34,35,36),\n\t                        ivec4(36,37,38,0),\n\t                        ivec4(39,40,41,42),\n\t                        ivec4(42,43,44,45),\n\t                        ivec4(45,46,47,48),\n\t                        ivec4(48,49,50,51),\n\t                        ivec4(51,52,53,54),\n\t                        ivec4(54,55,56,57),\n\t                        ivec4(57,58,59,39));\n\n\tif(all(lessThan(uv,vec2(0.0133423,0.0273438)+border)) && all(greaterThan(uv,vec2(-0.0133421,-0.0273437)-border))){\n\t\tfor(int i=ZERO;i<3;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<19;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat p_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[84] p=vec2[](vec2(0.0192376,0.0125665),\n\t                  vec2(0.0192376,0.0208666),\n\t                  vec2(0.0145834,0.0246675),\n\t                  vec2(0.00992917,0.0246675),\n\t                  vec2(0.00612818,0.0246675),\n\t                  vec2(0.00279265,0.021875),\n\t                  vec2(0.000543133,0.0192375),\n\t                  vec2(-0.000387731,0.0237367),\n\t                  vec2(-0.00387846,0.0246675),\n\t                  vec2(-0.00581768,0.0246675),\n\t                  vec2(-0.00861022,0.0246675),\n\t                  vec2(-0.0101616,0.0228834),\n\t                  vec2(-0.0114028,0.0205563),\n\t                  vec2(-0.0128766,0.0174535),\n\t                  vec2(-0.013885,0.0127216),\n\t                  vec2(-0.013885,0.0127216),\n\t                  vec2(-0.013885,0.0119459),\n\t                  vec2(-0.0131093,0.0119459),\n\t                  vec2(-0.0127215,0.0119459),\n\t                  vec2(-0.0117131,0.0119459),\n\t                  vec2(-0.0116355,0.0120233),\n\t                  vec2(-0.0112477,0.0137301),\n\t                  vec2(-0.00985139,0.01916),\n\t                  vec2(-0.0083775,0.022961),\n\t                  vec2(-0.00597287,0.022961),\n\t                  vec2(-0.00395599,0.022961),\n\t                  vec2(-0.00395599,0.0207114),\n\t                  vec2(-0.00395599,0.0198581),\n\t                  vec2(-0.00395599,0.0193927),\n\t                  vec2(-0.00395599,0.0181516),\n\t                  vec2(-0.00449902,0.0159796),\n\t                  vec2(-0.0133421,-0.0195478),\n\t                  vec2(-0.0139626,-0.0219525),\n\t                  vec2(-0.0145832,-0.0221852),\n\t                  vec2(-0.0176085,-0.0222628),\n\t                  vec2(-0.0183066,-0.0222628),\n\t                  vec2(-0.0192375,-0.0222628),\n\t                  vec2(-0.0192375,-0.0237366),\n\t                  vec2(-0.0192375,-0.0242796),\n\t                  vec2(-0.0188496,-0.0246675),\n\t                  vec2(-0.0183066,-0.0246675),\n\t                  vec2(-0.0162122,-0.0246675),\n\t                  vec2(-0.0139626,-0.0244348),\n\t                  vec2(-0.0117906,-0.0244348),\n\t                  vec2(-0.0093084,-0.0244348),\n\t                  vec2(-0.00667101,-0.0246675),\n\t                  vec2(-0.00426629,-0.0246675),\n\t                  vec2(-0.00380088,-0.0246675),\n\t                  vec2(-0.00279244,-0.0246675),\n\t                  vec2(-0.00279244,-0.0231936),\n\t                  vec2(-0.00279244,-0.0222628),\n\t                  vec2(-0.00356816,-0.0222628),\n\t                  vec2(-0.00465413,-0.0222628),\n\t                  vec2(-0.00861027,-0.0222628),\n\t                  vec2(-0.00861027,-0.0217974),\n\t                  vec2(-0.00861027,-0.0210216),\n\t                  vec2(-0.00861027,-0.0205562),\n\t                  vec2(-0.00806728,-0.0185394),\n\t                  vec2(-0.00775698,-0.0172983),\n\t                  vec2(-0.00496443,-0.00597293),\n\t                  vec2(-0.00442145,-0.00729163),\n\t                  vec2(-0.00248219,-0.010472),\n\t                  vec2(0.00155153,-0.010472),\n\t                  vec2(0.0100067,-0.010472),\n\t                  vec2(0.0192376,0.00100844),\n\t                  vec2(0.00969645,-0.00139623),\n\t                  vec2(0.00876563,-0.00333553),\n\t                  vec2(0.00543005,-0.00876552),\n\t                  vec2(0.00147395,-0.00876552),\n\t                  vec2(-0.00302517,-0.00876552),\n\t                  vec2(-0.00380088,-0.00217194),\n\t                  vec2(-0.00380088,-0.00155138),\n\t                  vec2(-0.00380088,-0.00131874),\n\t                  vec2(-0.00372348,-0.00108597),\n\t                  vec2(-0.00356825,-0.000465454),\n\t                  vec2(7.75911e-05,0.0141955),\n\t                  vec2(0.000698152,0.0168328),\n\t                  vec2(0.00550754,0.022961),\n\t                  vec2(0.00977393,0.022961),\n\t                  vec2(0.0132646,0.022961),\n\t                  vec2(0.0140403,0.0185394),\n\t                  vec2(0.0140403,0.0160572),\n\t                  vec2(0.0140403,0.0127992),\n\t                  vec2(0.011946,0.00356826));\n\n\tivec2[3] seg=ivec2[](ivec2(30,31),\n\t                     ivec2(58,59),\n\t                     ivec2(74,75));\n\n\tivec4[27] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(3,4,5,6),\n\t                        ivec4(6,7,8,9),\n\t                        ivec4(9,10,11,12),\n\t                        ivec4(12,13,14,15),\n\t                        ivec4(15,16,17,18),\n\t                        ivec4(18,19,20,21),\n\t                        ivec4(21,22,23,24),\n\t                        ivec4(24,25,26,27),\n\t                        ivec4(27,28,29,30),\n\t                        ivec4(31,32,33,34),\n\t                        ivec4(34,35,36,37),\n\t                        ivec4(37,38,39,40),\n\t                        ivec4(40,41,42,43),\n\t                        ivec4(43,44,45,46),\n\t                        ivec4(46,47,48,49),\n\t                        ivec4(49,50,51,52),\n\t                        ivec4(52,53,54,55),\n\t                        ivec4(55,56,57,58),\n\t                        ivec4(59,60,61,62),\n\t                        ivec4(62,63,64,0),\n\t                        ivec4(65,66,67,68),\n\t                        ivec4(68,69,70,71),\n\t                        ivec4(71,72,73,74),\n\t                        ivec4(75,76,77,78),\n\t                        ivec4(78,79,80,81),\n\t                        ivec4(81,82,83,65));\n\n\tif(all(lessThan(uv,vec2(0.0192376,0.0246675)+border)) && all(greaterThan(uv,vec2(-0.0192375,-0.0246675)-border))){\n\t\tfor(int i=ZERO;i<3;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<27;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat q_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[74] p=vec2[](vec2(0.00981294,-0.0231936),\n\t                  vec2(0.00981294,-0.0222628),\n\t                  vec2(0.00903727,-0.0222628),\n\t                  vec2(0.00795126,-0.0222628),\n\t                  vec2(0.00399516,-0.0222628),\n\t                  vec2(0.00399516,-0.0217974),\n\t                  vec2(0.00399516,-0.0210216),\n\t                  vec2(0.00399516,-0.0204787),\n\t                  vec2(0.0041504,-0.0200908),\n\t                  vec2(0.0042278,-0.0196254),\n\t                  vec2(0.014855,0.0227283),\n\t                  vec2(0.0149324,0.0229609),\n\t                  vec2(0.0150876,0.0237367),\n\t                  vec2(0.0150876,0.0237367),\n\t                  vec2(0.0150876,0.0244348),\n\t                  vec2(0.0144671,0.02459),\n\t                  vec2(0.0142344,0.02459),\n\t                  vec2(0.0133811,0.02459),\n\t                  vec2(0.0105885,0.021875),\n\t                  vec2(0.00934736,0.019703),\n\t                  vec2(0.00841654,0.0219525),\n\t                  vec2(0.0063997,0.0246675),\n\t                  vec2(0.00267629,0.0246675),\n\t                  vec2(-0.00593408,0.0246675),\n\t                  vec2(-0.0150874,0.0128768),\n\t                  vec2(-0.0150874,0.00155143),\n\t                  vec2(-0.0150874,-0.00504211),\n\t                  vec2(-0.0115192,-0.010472),\n\t                  vec2(-0.00570136,-0.010472),\n\t                  vec2(-0.00252097,-0.010472),\n\t                  vec2(0.000349194,-0.00845522),\n\t                  vec2(0.00252114,-0.00636081),\n\t                  vec2(0.000969711,-0.0124113),\n\t                  vec2(0.00104729,-0.0124113),\n\t                  vec2(-0.000504094,-0.0185394),\n\t                  vec2(-0.00135738,-0.0218749),\n\t                  vec2(-0.00143491,-0.0221852),\n\t                  vec2(-0.00639949,-0.0222628),\n\t                  vec2(-0.00740793,-0.0222628),\n\t                  vec2(-0.00826122,-0.0222628),\n\t                  vec2(-0.00826122,-0.0237366),\n\t                  vec2(-0.00826122,-0.0244348),\n\t                  vec2(-0.00779577,-0.0246675),\n\t                  vec2(-0.00725278,-0.0246675),\n\t                  vec2(-0.00477054,-0.0246675),\n\t                  vec2(-0.00205552,-0.0244348),\n\t                  vec2(0.000504345,-0.0244348),\n\t                  vec2(0.00306412,-0.0244348),\n\t                  vec2(0.00585671,-0.0246675),\n\t                  vec2(0.008339,-0.0246675),\n\t                  vec2(0.00880441,-0.0246675),\n\t                  vec2(0.00981277,-0.0246675),\n\t                  vec2(0.00407269,-0.000155107),\n\t                  vec2(0.00345218,-0.00255978),\n\t                  vec2(-0.00127972,-0.00876548),\n\t                  vec2(-0.00554612,-0.00876548),\n\t                  vec2(-0.00919191,-0.00876548),\n\t                  vec2(-0.00981247,-0.00418878),\n\t                  vec2(-0.00981247,-0.00186164),\n\t                  vec2(-0.00981247,0.00201688),\n\t                  vec2(-0.0074078,0.0110927),\n\t                  vec2(-0.00601153,0.0143506),\n\t                  vec2(-0.00407227,0.0190825),\n\t                  vec2(-0.000504007,0.022961),\n\t                  vec2(0.00267642,0.022961),\n\t                  vec2(0.00329698,0.022961),\n\t                  vec2(0.00508109,0.0228836),\n\t                  vec2(0.00647736,0.0207114),\n\t                  vec2(0.00725308,0.0194703),\n\t                  vec2(0.00802879,0.0172207),\n\t                  vec2(0.00802879,0.0157469),\n\t                  vec2(0.00802879,0.0155143),\n\t                  vec2(0.00795139,0.0152039),\n\t                  vec2(0.00779615,0.0147385));\n\n\tivec2[2] seg=ivec2[](ivec2(9,10),\n\t                     ivec2(73,52));\n\n\tivec4[24] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(3,4,5,6),\n\t                        ivec4(6,7,8,9),\n\t                        ivec4(10,11,12,13),\n\t                        ivec4(13,14,15,16),\n\t                        ivec4(16,17,18,19),\n\t                        ivec4(19,20,21,22),\n\t                        ivec4(22,23,24,25),\n\t                        ivec4(25,26,27,28),\n\t                        ivec4(28,29,30,31),\n\t                        ivec4(31,32,33,34),\n\t                        ivec4(34,35,36,37),\n\t                        ivec4(37,38,39,40),\n\t                        ivec4(40,41,42,43),\n\t                        ivec4(43,44,45,46),\n\t                        ivec4(46,47,48,49),\n\t                        ivec4(49,50,51,0),\n\t                        ivec4(52,53,54,55),\n\t                        ivec4(55,56,57,58),\n\t                        ivec4(58,59,60,61),\n\t                        ivec4(61,62,63,64),\n\t                        ivec4(64,65,66,67),\n\t                        ivec4(67,68,69,70),\n\t                        ivec4(70,71,72,73));\n\n\tif(all(lessThan(uv,vec2(0.0150876,0.0246675)+border)) && all(greaterThan(uv,vec2(-0.0150874,-0.0246675)-border))){\n\t\tfor(int i=ZERO;i<2;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<24;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat r_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[56] p=vec2[](vec2(0.015747,0.0126828),\n\t                  vec2(0.015747,0.0167165),\n\t                  vec2(0.0107048,0.0175698),\n\t                  vec2(0.00814502,0.0175698),\n\t                  vec2(0.00279261,0.0175698),\n\t                  vec2(5.93691e-08,0.0136913),\n\t                  vec2(-0.00124106,0.0119847),\n\t                  vec2(-0.00209435,0.0160959),\n\t                  vec2(-0.00511958,0.0175698),\n\t                  vec2(-0.00767945,0.0175698),\n\t                  vec2(-0.010472,0.0175698),\n\t                  vec2(-0.0120234,0.0157857),\n\t                  vec2(-0.0132646,0.0134585),\n\t                  vec2(-0.0147383,0.0103557),\n\t                  vec2(-0.0157468,0.00562388),\n\t                  vec2(-0.0157468,0.00562388),\n\t                  vec2(-0.0157468,0.00484822),\n\t                  vec2(-0.0149711,0.00484822),\n\t                  vec2(-0.0145832,0.00484822),\n\t                  vec2(-0.0135748,0.00484822),\n\t                  vec2(-0.0134972,0.00492561),\n\t                  vec2(-0.0131094,0.00663232),\n\t                  vec2(-0.0117132,0.0120623),\n\t                  vec2(-0.0102393,0.0158633),\n\t                  vec2(-0.00783455,0.0158633),\n\t                  vec2(-0.00581772,0.0158633),\n\t                  vec2(-0.00581772,0.0136137),\n\t                  vec2(-0.00581772,0.0127604),\n\t                  vec2(-0.00581772,0.0115193),\n\t                  vec2(-0.00605036,0.0100454),\n\t                  vec2(-0.00636075,0.00880431),\n\t                  vec2(-0.0121786,-0.0144669),\n\t                  vec2(-0.0123338,-0.0149323),\n\t                  vec2(-0.0124112,-0.0153202),\n\t                  vec2(-0.0124112,-0.0155529),\n\t                  vec2(-0.0124112,-0.0164062),\n\t                  vec2(-0.0117907,-0.0175697),\n\t                  vec2(-0.0102393,-0.0175697),\n\t                  vec2(-0.00791213,-0.0175697),\n\t                  vec2(-0.00736914,-0.0153202),\n\t                  vec2(-0.00721399,-0.0146996),\n\t                  vec2(-0.00217193,0.00562388),\n\t                  vec2(-0.00209453,0.00585652),\n\t                  vec2(0.00139633,0.0158633),\n\t                  vec2(0.00806744,0.0158633),\n\t                  vec2(0.00845532,0.0158633),\n\t                  vec2(0.0106273,0.0158633),\n\t                  vec2(0.0121787,0.0147772),\n\t                  vec2(0.00946372,0.013924),\n\t                  vec2(0.00923099,0.0114417),\n\t                  vec2(0.00923099,0.0110539),\n\t                  vec2(0.00923099,0.0100454),\n\t                  vec2(0.00992913,0.00857158),\n\t                  vec2(0.011946,0.00857158),\n\t                  vec2(0.0133422,0.00857158),\n\t                  vec2(0.015747,0.0096576));\n\n\tivec2[2] seg=ivec2[](ivec2(30,31),\n\t                     ivec2(40,41));\n\n\tivec4[18] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(3,4,5,6),\n\t                        ivec4(6,7,8,9),\n\t                        ivec4(9,10,11,12),\n\t                        ivec4(12,13,14,15),\n\t                        ivec4(15,16,17,18),\n\t                        ivec4(18,19,20,21),\n\t                        ivec4(21,22,23,24),\n\t                        ivec4(24,25,26,27),\n\t                        ivec4(27,28,29,30),\n\t                        ivec4(31,32,33,34),\n\t                        ivec4(34,35,36,37),\n\t                        ivec4(37,38,39,40),\n\t                        ivec4(41,42,43,44),\n\t                        ivec4(44,45,46,47),\n\t                        ivec4(47,48,49,50),\n\t                        ivec4(50,51,52,53),\n\t                        ivec4(53,54,55,0));\n\n\tif(all(lessThan(uv,vec2(0.015747,0.0175698)+border)) && all(greaterThan(uv,vec2(-0.0157468,-0.0175697)-border))){\n\t\tfor(int i=ZERO;i<2;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<18;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat aspect_ratio = iResolution.x / iResolution.y;\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv-=.5;\n\tuv.x *= aspect_ratio;\n\n\tvec2 mouse = (iMouse.xy+1.) / iResolution.xy;\n\n\tconst float line_width = .001;\n\tconst float curve_width = .001;\n\tconst float dot_size = .005;\n\n\tconst float axis_width = .005;\n\n\tconst vec3 bg_col = vec3(1,1,1);\n\tconst vec3 axis_col = vec3(0,0,0);\n\tconst vec3 line_col = vec3(0,1,0);\n\tconst vec3 second_line_col = vec3(1,1,0);\n\tconst vec3 curve_col = vec3(0,0,1);\n\tconst vec3 second_curve_col = vec3(0,1,1);\n\tconst vec3 dot_col = vec3(1,0,0);\n\tconst vec3 text_col = vec3(0,0,0);\n\n    border = 2./iResolution.y;\n\n\tfloat curve_dis = 1e38;\n\tfloat second_curve_dis = 1e38;\n\tfloat dot_dis = 1e38;\n\tfloat axis_dis = 1e38;\n\tfloat line_dis = 1e38;\n\tfloat second_line_dis = 1e38;\n\tfloat text_dis_sq = 1e38;\n\tfloat text_dis = 1e38;\n\n\tconst float pi=3.14159265358979;\n\tfloat anim=smoothstep(0.,1.,mouse.y);\n\n\t//elliptic curve parameters (weierstrass normal form)\n\tfloat g_2 = .3+anim*.04;\n\tfloat g_3 = -.05-anim*.01;\n\t//float g_2 = .3;\n\t//float g_3 = -.05;\n\n\t//initial approximations for various points (not exactly lying on the curve)\n\t//you can play around with these values, but the gradient descent\n\t//can get unstable if the points are too far away from the curve\n\n\tvec2 p0=vec2(0.043,-0.193); //0: the inflection point\n\tvec2 p1=vec2(-.2,.12); //p\n\tvec2 p2=vec2(.0189,.2106); //q\n\tvec2 p3=vec2(.42,.32); //r\n\n\t//compute points lying exactly on the curve by gradient descent\n\tconst int grad_descent_iterations=7;\n\tfloat p0_val, hesse_p0_val, p1_val, p2_val, p3_val;\n\tvec2 p0_grad, hesse_p0_grad, p1_grad, p2_grad, p3_grad;\n\n\tfor(int i=ZERO;i<grad_descent_iterations;i++){\n\t\tp0_val = p0.y*p0.y - (( 4.*p0.x*p0.x - g_2 ) * p0.x - g_3);\n\t\tp0_grad = vec2(-12.*p0.x*p0.x+g_2,2.*p0.y);\n\t\tp0-=(p0_grad*p0_val)/dot(p0_grad,p0_grad);\n\n\t\t//compute inflection point by alternately gradient descenting to curve and hessian of curve\n\t\thesse_p0_val = -96.*g_2*p0.x*p0.x + 96.*p0.x*p0.y*p0.y - 8.*g_2*g_2 - 288.*g_3*p0.x;\n\t\thesse_p0_grad = vec2(-192.*g_2*p0.x + 96.*p0.y*p0.y - 288.*g_3,192.*p0.x*p0.y);\n\t\tp0-=(hesse_p0_grad*hesse_p0_val)/dot(hesse_p0_grad,hesse_p0_grad);\n\n\t\tp1_val = p1.y*p1.y - (( 4.*p1.x*p1.x - g_2 ) * p1.x - g_3);\n\t\tp1_grad = vec2(-12.*p1.x*p1.x+g_2,2.*p1.y);\n\t\tp1-=(p1_grad*p1_val)/dot(p1_grad,p1_grad);\n\n\t\tp2_val = p2.y*p2.y - (( 4.*p2.x*p2.x - g_2 ) * p2.x - g_3);\n\t\tp2_grad = vec2(-12.*p2.x*p2.x+g_2,2.*p2.y);\n\t\tp2-=(p2_grad*p2_val)/dot(p2_grad,p2_grad);\n\n\t\tp3_val = p3.y*p3.y - (( 4.*p3.x*p3.x - g_2 ) * p3.x - g_3);\n\t\tp3_grad = vec2(-12.*p3.x*p3.x+g_2,2.*p3.y);\n\t\tp3-=(p3_grad*p3_val)/dot(p3_grad,p3_grad);\n\t}\n\n\tvec2 p4=third_intersection(p2,p3,g_2,g_3);\n\tvec2 p5=third_intersection(p1,p2,g_2,g_3);\n\tvec2 p6=third_intersection(p0,p5,g_2,g_3);\n\tvec2 p7=third_intersection(p0,p4,g_2,g_3);\n\tvec2 p8=third_intersection(p1,p7,g_2,g_3);\n\n\tdot_dis=min(dot_dis,distance(p0,uv)-dot_size); //0\n\tdot_dis=min(dot_dis,distance(p1,uv)-dot_size); //p\n\tdot_dis=min(dot_dis,distance(p2,uv)-dot_size); //q\n\tdot_dis=min(dot_dis,distance(p3,uv)-dot_size); //r\n\tdot_dis=min(dot_dis,distance(p4,uv)-dot_size); //a'\n\tdot_dis=min(dot_dis,distance(p5,uv)-dot_size); //a\n\n\t//dot_dis=min(dot_dis,distance(p6,uv)-dot_size); //p+q\n\n\tdot_dis=min(dot_dis,distance(p7,uv)-dot_size); //q+r\n\tdot_dis=min(dot_dis,distance(p8,uv)-dot_size); //b/b'\n\n\tvec3 l0=line(p1,p2); //L\n\tvec3 l1=line(p0,p4); //M'\n\tvec3 l2=line(p6,p3); //N\n\n\tvec3 l3=line(p0,p5); //M\n\tvec3 l4=line(p2,p3); //L'\n\tvec3 l5=line(p1,p7); //N'\n\n\tline_dis=min(line_dis,abs(dot(vec3(uv,1),l0))); //L\n\tline_dis=min(line_dis,abs(dot(vec3(uv,1),l1))); //M'\n\tline_dis=min(line_dis,abs(dot(vec3(uv,1),l2))); //N\n\n\tsecond_line_dis=min(second_line_dis,abs(dot(vec3(uv,1),l3))); //M\n\tsecond_line_dis=min(second_line_dis,abs(dot(vec3(uv,1),l4))); //L'\n\tsecond_line_dis=min(second_line_dis,abs(dot(vec3(uv,1),l5))); //N'\n\n\tfloat uv_val = uv.y*uv.y - (( 4.*uv.x*uv.x - g_2 ) * uv.x - g_3);\n\tvec2 uv_grad = vec2(-12.*uv.x*uv.x+g_2,2.*uv.y);\n\n\tcurve_dis=min(curve_dis, abs(uv_val)/length(uv_grad)-curve_width);\n\n\tfloat d0=dot(vec3(uv,1),l0);\n\tfloat d1=dot(vec3(uv,1),l1);\n\tfloat d2=dot(vec3(uv,1),l2);\n\n\tfloat uv_val2=d0*d1*d2;\n\tvec2 uv_grad2=d0*d1*l2.xy+d0*l1.xy*d2+l0.xy*d1*d2;\n\n\tfloat t0=mouse.x;\n\n\tsecond_curve_dis=min(second_curve_dis,abs(mix(uv_val,uv_val2,t0))/length(mix(uv_grad,uv_grad2,vec2(t0)))-curve_width);\n\n\taxis_dis=min(axis_dis, abs(uv.x));\n\taxis_dis=min(axis_dis, abs(uv.y));\n\n\t//compute reference points for line labels\n\tvec3 L0_point = cross(l0,vec3(1.,0.,-aspect_ratio/2.));\n\tL0_point/=L0_point.z;\n\tL0_point.xy+=l0.yx*vec2(1.,-1.)*.085;\n\n\tvec3 L1_point = cross(l4,vec3(1.,0.,aspect_ratio/2.));\n\tL1_point/=L1_point.z;\n\tL1_point.xy+=l4.yx*vec2(-1.,1.)*.085;\n\n\tvec3 M0_point = cross(l3,vec3(0.,1.,.5));\n\tM0_point/=M0_point.z;\n\tM0_point.xy+=l3.yx*vec2(-1.,1.)*.085;\n\n\tvec3 M1_point = cross(l1,vec3(1.,0.,aspect_ratio/2.));\n\tM1_point/=M1_point.z;\n\tM1_point.xy+=l1.yx*vec2(1.,-1.)*.085;\n\n\tvec3 N0_point = cross(l2,vec3(0.,1.,.5));\n\tN0_point/=N0_point.z;\n\tN0_point.xy+=l2.yx*vec2(1.,-1.)*.085;\n\n\tvec3 N1_point = cross(l5,vec3(0.,1.,-.5));\n\tN1_point/=N1_point.z;\n\tN1_point.xy+=l5.yx*vec2(-1.,1.)*.085;\n\n\tvec2[2] L_positions=vec2[](vec2(-.01,-.05)-L0_point.xy,vec2(.0,.05)-L1_point.xy);\n\tvec2[2] M_positions=vec2[](vec2(.07,.0)-M0_point.xy,vec2(-.06,-.03)-M1_point.xy);\n\tvec2[2] N_positions=vec2[](vec2(-.08,-.06)-N0_point.xy,vec2(-.08,.0)-N1_point.xy);\n\n\tvec2[2] a_positions=vec2[](vec2(.022,-.037)-p5,vec2(.035,.042)-p4);\n\tvec2[2] q_positions=vec2[](vec2(-.003,.042)-p2,vec2(-.04,-.03)-p7);\n\tvec2[2] r_positions=vec2[](vec2(-.03,.03)-p3,q_positions[1]+vec2(-.1,0.));\n\n\tvec2[4] prime_positions=vec2[](L_positions[1]+vec2(-.035,-.025),M_positions[1]+vec2(-.05,-.025),N_positions[1]+vec2(-.043,-.025),a_positions[1]+vec2(-.023,-.023));\n\n\tvec2 plus_position=q_positions[1]+vec2(-.05,1e-7);\n\tvec2 zero_position=vec2(.003,.0425)-p0;\n\tvec2 b_position=vec2(-.03,-.045)-p8;\n\tvec2 p_position=vec2(-.022,.031)-p1;\n\n\ttext_dis_sq=min(text_dis_sq,plus_dis_sq(uv+plus_position));\n\ttext_dis_sq=min(text_dis_sq,zero_dis_sq(uv+zero_position));\n\ttext_dis_sq=min(text_dis_sq,b_dis_sq(uv+b_position));\n\ttext_dis_sq=min(text_dis_sq,p_dis_sq(uv+p_position));\n\n\tfor(int i=ZERO;i<2;i++){\n\t\ttext_dis_sq=min(text_dis_sq,L_dis_sq(uv+L_positions[i]));\n\t\ttext_dis_sq=min(text_dis_sq,M_dis_sq(uv+M_positions[i]));\n\t\ttext_dis_sq=min(text_dis_sq,N_dis_sq(uv+N_positions[i]));\n\n\t\ttext_dis_sq=min(text_dis_sq,a_dis_sq(uv+a_positions[i]));\n\t\ttext_dis_sq=min(text_dis_sq,q_dis_sq(uv+q_positions[i]));\n\t\ttext_dis_sq=min(text_dis_sq,r_dis_sq(uv+r_positions[i]));\n\t}\n\tfor(int i=ZERO;i<4;i++){\n\t\ttext_dis_sq=min(text_dis_sq,prime_dis_sq(uv+prime_positions[i]));\n\t}\n\n\ttext_dis=sign(text_dis_sq)*sqrt(abs(text_dis_sq));\n\n\tvec3 color = bg_col;\n\n\tcolor=vec3(mix(axis_col,color,smoothstep(0., border, axis_dis)));\n\tcolor=vec3(mix(line_col,color,smoothstep(0., border, line_dis)));\n\tcolor=vec3(mix(second_line_col,color,smoothstep(0., border, second_line_dis)));\n\tcolor=vec3(mix(second_curve_col,color,smoothstep(0., border, second_curve_dis)));\n\tcolor=vec3(mix(curve_col,color,smoothstep(0., border, curve_dis)));\n\tcolor=vec3(mix(dot_col,color,smoothstep(0., border, dot_dis)));\n\tcolor=vec3(mix(text_col,color,smoothstep(-border/2., border/2., text_dis)));\n\n\tfragColor = vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djyz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1922, 2043, 2092, 2127, 2307], [2309, 2394, 2437, 2437, 3446], [3448, 3448, 3529, 3548, 3723], [3725, 3725, 3803, 3803, 4361], [4363, 4386, 4411, 4411, 4430], [4432, 4432, 4479, 4479, 4590], [4592, 4592, 4640, 4640, 4910], [4912, 4912, 4983, 4983, 5847], [5849, 5849, 5879, 5879, 5984], [5986, 5986, 6050, 6050, 6563]], "test": "untested"}
{"id": "Wd2cR1", "name": "Elliptic curve group operation", "author": "NinjaKoala", "description": "Visualization of the construction of the group operation on elliptic curves.\nSee header comment for a verbose explanation", "tags": ["2d", "math", "group", "ellipticcurve"], "likes": 6, "viewed": 337, "published": 3, "date": "1586110228", "time_retrieved": "2024-07-30T21:14:44.748705", "image_code": "/*\nVisualization of the group structure construction\nfor an elliptic curve.\n\nGiven two points p and q on the curve,\np * q is the third intersection of the\nline through p and q with the curve.\n(Tangent if p=q)\n\nDefine 0 to be an inflection point of the curve.\n\nWe want an abelian (commutative) group on the points of the\ncurve such that 0 is the neutral element and\nfor three points p,q,r\np + q + r = 0 <=> p,q,r collinear\n\nFor a point p, define q := 0 * p\nThen p, q and 0 are collinear and therefore\np + 0 + q = 0 => p + q = 0 => -p = q = 0 * p\n\nSo if there is an inverse element, it has to be 0 * p\nfor each point p on the curve\n\nAssume there is indeed an inverse element, and\nlet now p,q be arbitrary points on the curve, then\np + q + (p*q) = 0 => p + q = -(p*q) = 0 * (p*q)\n\nSo the only operation \"+\" that fulfills the above requirements\nis defined by: p + q := 0 * (p * q)\n\nWe can now test if -p is indeed the inverse element:\np + (-p) = 0 * (p * (-p)) = 0 * (p * (0*p)) = 0 * 0\n                                \\_________/\n                                     v\n                                    = 0\n\nSo \"-p\" is an inverse exactly when 0 = 0 * 0,\nwhich means 0 is the only intersection of the\ncurves tangent in 0 with the curve,\nwhich is the defining property of an inflection point.\n\nFor a geometric proof of associativity, see:\nhttps://www.shadertoy.com/view/3djyz1\n\nNote:\nIt is standard to take the inflection point at infinity\nas neutral element. In that case, 0 * p\nbecomes the reflection of p at the x axis.\nThis leads to an particularly easy computation of\nthe operation. However, i decided to use an\ninflection point that can be actually seen.\n\nThe letters are from the Latin Modern font\n(https://en.wikipedia.org/wiki/Computer_Modern#Latin_Modern)\nconverted to shader with\nhttps://gist.github.com/Ninja-Koala/74fa7652fb4de248949ce1e27b989c14\n*/\n\n//#define ZERO 0\n#define ZERO min(0,iFrame)\n\nfloat border;\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n\n\t// normal form: x^2 + px + q = 0\n\tfloat p = coeffs[1] / 2.;\n\tfloat q = coeffs[0];\n\n\tfloat D = p * p - q;\n\n\tif (D < 0.){\n\t\treturn 0;\n\t}\n\telse{\n\t\troots[0] = -sqrt(D) - p;\n\t\troots[1] = sqrt(D) - p;\n\n\t\treturn 2;\n\t}\n}\n\n//From Trisomie21\n//But instead of his cancellation fix i'm using a newton iteration\nint solve_cubic(vec3 coeffs, inout vec3 r){\n\n\tfloat a = coeffs[2];\n\tfloat b = coeffs[1];\n\tfloat c = coeffs[0];\n\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0) { // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = sign(u)*pow(abs(u),1.0/3.0);\n\t\tv = sign(v)*pow(abs(v),1.0/3.0);\n\t\tr[0] = offset + u + v;\t\n\n\t\t//Single newton iteration to account for cancellation\n\t\tfloat f = ((r[0] + a) * r[0] + b) * r[0] + c;\n\t\tfloat f1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\t\tr[0] -= f / f1;\n\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t//Single newton iteration to account for cancellation\n\t//(once for every root)\n\tr[0] = offset + u * (m + m);\n\tr[1] = offset - u * (n + m);\n\tr[2] = offset + u * (n - m);\n\n\tvec3 f = ((r + a) * r + b) * r + c;\n\tvec3 f1 = (3. * r + 2. * a) * r + b;\n\n\tr -= f / f1;\n\n\treturn 3;\n}\n\nfloat cubic_bezier_normal_iteration(float t, vec2 a0, vec2 a1, vec2 a2, vec2 a3){\n\t//horner's method\n\tvec2 a_2=a2+t*a3;\n\tvec2 a_1=a1+t*a_2;\n\tvec2 b_2=a_2+t*a3;\n\n\tvec2 uv_to_p=a0+t*a_1;\n\tvec2 tang=a_1+t*b_2;\n\n\tfloat l_tang=dot(tang,tang);\n\treturn t-dot(tang,uv_to_p)/l_tang;\n}\n\nfloat cubic_bezier_dis_approx_sq(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec2 a3 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a2 = (3. * p0 - 6. * p1 + 3. * p2);\n\tvec2 a1 = (-3. * p0 + 3. * p1);\n\tvec2 a0 = p0 - uv;\n\n\tfloat d0 = 1e38;\n\n\tfloat t;\n\tvec3 params=vec3(0,.5,1);\n\n\tif(all(lessThan(uv,max(max(p0,p1),max(p2,p3))+border)) && all(greaterThan(uv,min(min(p0,p1),min(p2,p3))-border))){\n\t\tfor(int i=ZERO;i<3;i++){\n\t\t\tt=params[i];\n\t\t\tfor(int j=ZERO;j<3;j++){\n\t\t\t\tt=cubic_bezier_normal_iteration(t,a0,a1,a2,a3);\n\t\t\t}\n\t\t\tt=clamp(t,0.,1.);\n\t\t\tvec2 uv_to_p=((a3*t+a2)*t+a1)*t+a0;\n\t\t\td0=min(d0,dot(uv_to_p,uv_to_p));\n\t\t}\n\t}\n\n\treturn d0;\n}\n\n//segment_dis_sq by iq\nfloat length2( vec2 v ) { return dot(v,v); }\n\nfloat segment_dis_sq( vec2 p, vec2 a, vec2 b ){\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length2( pa - ba*h );\n}\n\nint segment_int_test(vec2 uv, vec2 p0, vec2 p1){\n\tp0-=uv;\n\tp1-=uv;\n\n\tint ret;\n\t\n\tif(p0.y*p1.y<0.){\n\t\tvec2 nor=p0-p1;\n\t\tnor=vec2(nor.y,-nor.x);\n\t\t\n\t\tfloat sgn;\n\t\t\n\t\tif(p0.y>p1.y){\n\t\t\tsgn=1.;\n\t\t}\n\t\telse{\n\t\t\tsgn=-1.;\n\t\t}\n\n\t\tif(dot(nor,p0)*sgn<0.){\n\t\t\tret=0;\n\t\t}\n\t\telse{\n\t\t\tret=1;\n\t\t}\n\t}\n\telse{\n\t\tret=0;\n\t}\n\n\treturn ret;\n}\n\nint cubic_bezier_int_test(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\n\tfloat cu = (-p0.y + 3. * p1.y - 3. * p2.y + p3.y);\n\tfloat qu = (3. * p0.y - 6. * p1.y + 3. * p2.y);\n\tfloat li = (-3. * p0.y + 3. * p1.y);\n\tfloat co = p0.y - uv.y;\n\n\tvec3 roots = vec3(1e38);\n\tint n_roots;\n\n\tint n_ints=0;\n\n\tif(uv.x<min(min(p0.x,p1.x),min(p2.x,p3.x))){\n\t\tif(uv.y>=min(p0.y,p3.y) && uv.y<=max(p0.y,p3.y)){\n\t\t\tn_ints=1;\n\t\t}\n\t}\n\telse{\n\t\tif(abs(cu) < .0001){\n\t\t\tn_roots = solve_quadric(vec2(co/qu,li/qu),roots.xy);\n\t\t}\n\t\telse{\n\t\t\tn_roots = solve_cubic(vec3(co/cu,li/cu,qu/cu),roots);\n\t\t}\n\n\t\tfor(int i=ZERO;i<n_roots;i++){\n\t\t\tif(roots[i] >= 0. && roots[i] <= 1.){\n\t\t\t\tfloat x_pos = -p0.x + 3. * p1.x - 3. * p2.x + p3.x;\n\t\t\t\tx_pos = x_pos * roots[i] + 3. * p0.x - 6. * p1.x + 3. * p2.x;\n\t\t\t\tx_pos = x_pos * roots[i] + -3. * p0.x + 3. * p1.x;\n\t\t\t\tx_pos = x_pos * roots[i] + p0.x;\n\n\t\t\t\tif(x_pos > uv.x){\n\t\t\t\t\tn_ints++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn n_ints;\n}\n\nvec3 line(vec2 p_0, vec2 p_1){\n\tvec2 tan1 = p_1-p_0;\n\tvec2 nor1 = normalize(vec2(tan1.y,-tan1.x));\n\treturn vec3(nor1,-dot(nor1,p_0));\n}\n\nvec2 third_intersection(vec2 p0, vec2 p1, float g_2, float g_3){\n\tvec2 tang=p1-p0;\n\tfloat p0_val = p0.y*p0.y - (( 4.*p0.x*p0.x - g_2 ) * p0.x - g_3);\n\n\tfloat co=p0_val;\n\tfloat li=-12.*p0.x*p0.x*tang.x + g_2*tang.x + 2.*p0.y*tang.y;\n\tfloat qu=-12.*p0.x*tang.x*tang.x+tang.y*tang.y;\n\tfloat cu=-4.*tang.x*tang.x*tang.x;\n\n\tvec3 roots = vec3(1e38);\n\tint n_roots = solve_cubic(vec3(co/cu,li/cu,qu/cu),roots);\n\n\tvec2 p2=vec2(1e38);\n\n\tfor(int i=ZERO;i<n_roots;i++){\n\t\tvec2 tmp=p0+roots[i]*tang;\n\t\tif(distance(tmp,p0)>0.0001 && distance(tmp,p1)>0.0001){\n\t\t\tp2=tmp;\n\t\t}\n\t}\n\n\treturn p2;\n}\n\nfloat plus_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[32] p=vec2[](vec2(0.0257924,-0.0),\n\t                  vec2(0.0257924,0.00155143),\n\t                  vec2(0.0243185,0.00155143),\n\t                  vec2(0.0232326,0.00155143),\n\t                  vec2(0.00159032,0.00155143),\n\t                  vec2(0.00159032,0.0232712),\n\t                  vec2(0.00159032,0.0243572),\n\t                  vec2(0.00159032,0.0258311),\n\t                  vec2(3.88912e-05,0.0258311),\n\t                  vec2(-0.00151253,0.0258311),\n\t                  vec2(-0.00151253,0.0243572),\n\t                  vec2(-0.00151253,0.0232712),\n\t                  vec2(-0.00151253,0.00155143),\n\t                  vec2(-0.0232323,0.00155143),\n\t                  vec2(-0.0243183,0.00155143),\n\t                  vec2(-0.0257922,0.00155143),\n\t                  vec2(-0.0257922,-0.0),\n\t                  vec2(-0.0257922,-0.00155143),\n\t                  vec2(-0.0243183,-0.00155143),\n\t                  vec2(-0.0232323,-0.00155143),\n\t                  vec2(-0.00151253,-0.00155143),\n\t                  vec2(-0.00151253,-0.0232712),\n\t                  vec2(-0.00151253,-0.0243572),\n\t                  vec2(-0.00151253,-0.0258311),\n\t                  vec2(3.88912e-05,-0.0258311),\n\t                  vec2(0.00159032,-0.0258311),\n\t                  vec2(0.00159032,-0.0243572),\n\t                  vec2(0.00159032,-0.0232712),\n\t                  vec2(0.00159032,-0.00155143),\n\t                  vec2(0.0232326,-0.00155143),\n\t                  vec2(0.0243185,-0.00155143),\n\t                  vec2(0.0257924,-0.00155143));\n\n\tivec2[8] seg=ivec2[](ivec2(3,4),\n\t                     ivec2(4,5),\n\t                     ivec2(11,12),\n\t                     ivec2(12,13),\n\t                     ivec2(19,20),\n\t                     ivec2(20,21),\n\t                     ivec2(27,28),\n\t                     ivec2(28,29));\n\n\tivec4[8] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                       ivec4(5,6,7,8),\n\t                       ivec4(8,9,10,11),\n\t                       ivec4(13,14,15,16),\n\t                       ivec4(16,17,18,19),\n\t                       ivec4(21,22,23,24),\n\t                       ivec4(24,25,26,27),\n\t                       ivec4(29,30,31,0));\n\n\tif(all(lessThan(uv,vec2(0.0257924,0.0258311)+border)) && all(greaterThan(uv,vec2(-0.0257922,-0.0258311)-border))){\n\t\tfor(int i=ZERO;i<8;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<8;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat minus_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[14] p=vec2[](vec2(0.0257924,-4.39771e-08),\n\t                  vec2(0.0257924,0.00155138),\n\t                  vec2(0.0243185,0.00155138),\n\t                  vec2(0.0232326,0.00155138),\n\t                  vec2(-0.0232323,0.00155138),\n\t                  vec2(-0.0243183,0.00155138),\n\t                  vec2(-0.0257922,0.00155138),\n\t                  vec2(-0.0257922,-4.39771e-08),\n\t                  vec2(-0.0257922,-0.00155143),\n\t                  vec2(-0.0243183,-0.00155143),\n\t                  vec2(-0.0231548,-0.00155143),\n\t                  vec2(0.023155,-0.00155143),\n\t                  vec2(0.0243185,-0.00155143),\n\t                  vec2(0.0257924,-0.00155143));\n\n\tivec2[2] seg=ivec2[](ivec2(3,4),\n\t                     ivec2(10,11));\n\n\tivec4[4] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                       ivec4(4,5,6,7),\n\t                       ivec4(7,8,9,10),\n\t                       ivec4(11,12,13,0));\n\n\tif(all(lessThan(uv,vec2(0.0257924,0.00155138)+border)) && all(greaterThan(uv,vec2(-0.0257922,-0.00155143)-border))){\n\t\tfor(int i=ZERO;i<2;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<4;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat asterisk_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[57] p=vec2[](vec2(0.0143119,-0.00725288),\n\t                  vec2(0.0143119,-0.0063996),\n\t                  vec2(0.0140015,-0.00577904),\n\t                  vec2(0.0126829,-0.00515847),\n\t                  vec2(0.00174542,-3.87878e-05),\n\t                  vec2(0.0125278,0.00508085),\n\t                  vec2(0.0140016,0.00577899),\n\t                  vec2(0.0143119,0.00632202),\n\t                  vec2(0.0143119,0.00725284),\n\t                  vec2(0.0143119,0.00826128),\n\t                  vec2(0.0134586,0.00942483),\n\t                  vec2(0.0122175,0.00942483),\n\t                  vec2(0.0116745,0.00942483),\n\t                  vec2(0.0115193,0.00942483),\n\t                  vec2(0.00950251,0.00795098),\n\t                  vec2(0.000892179,0.00159017),\n\t                  vec2(0.00205573,0.0147772),\n\t                  vec2(0.00205573,0.0159408),\n\t                  vec2(0.00104729,0.0167165),\n\t                  vec2(3.88912e-05,0.0167165),\n\t                  vec2(-0.00120223,0.0167165),\n\t                  vec2(-0.00205552,0.0157856),\n\t                  vec2(-0.00205552,0.0147772),\n\t                  vec2(-0.000891973,0.00159017),\n\t                  vec2(-0.0105107,0.00857154),\n\t                  vec2(-0.0115967,0.00942483),\n\t                  vec2(-0.0117519,0.00942483),\n\t                  vec2(-0.0122173,0.00942483),\n\t                  vec2(-0.0134584,0.00942483),\n\t                  vec2(-0.0143117,0.00826128),\n\t                  vec2(-0.0143117,0.00725284),\n\t                  vec2(-0.0143117,0.0063996),\n\t                  vec2(-0.0140012,0.00577899),\n\t                  vec2(-0.0126827,0.00515843),\n\t                  vec2(-0.00174522,3.87878e-05),\n\t                  vec2(-0.0125276,-0.0050809),\n\t                  vec2(-0.0140014,-0.00577904),\n\t                  vec2(-0.0143117,-0.00632202),\n\t                  vec2(-0.0143117,-0.00725288),\n\t                  vec2(-0.0143117,-0.00725288),\n\t                  vec2(-0.0143117,-0.00942487),\n\t                  vec2(-0.0117519,-0.00942487),\n\t                  vec2(-0.000891973,-0.00159021),\n\t                  vec2(-0.00205552,-0.0147772),\n\t                  vec2(-0.00205552,-0.0159408),\n\t                  vec2(-0.00104708,-0.0167165),\n\t                  vec2(-3.86845e-05,-0.0167165),\n\t                  vec2(0.00120244,-0.0167165),\n\t                  vec2(0.00205573,-0.0157857),\n\t                  vec2(0.00205573,-0.0147772),\n\t                  vec2(0.000892179,-0.00159021),\n\t                  vec2(0.0109764,-0.00895942),\n\t                  vec2(0.0113642,-0.00919206),\n\t                  vec2(0.0115969,-0.00942487),\n\t                  vec2(0.0122175,-0.00942487),\n\t                  vec2(0.0134586,-0.00942487),\n\t                  vec2(0.0143119,-0.00826128));\n\n\tivec2[12] seg=ivec2[](ivec2(3,4),\n\t                      ivec2(4,5),\n\t                      ivec2(14,15),\n\t                      ivec2(15,16),\n\t                      ivec2(22,23),\n\t                      ivec2(23,24),\n\t                      ivec2(33,34),\n\t                      ivec2(34,35),\n\t                      ivec2(41,42),\n\t                      ivec2(42,43),\n\t                      ivec2(49,50),\n\t                      ivec2(50,51));\n\n\tivec4[15] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(5,6,7,8),\n\t                        ivec4(8,9,10,11),\n\t                        ivec4(11,12,13,14),\n\t                        ivec4(16,17,18,19),\n\t                        ivec4(19,20,21,22),\n\t                        ivec4(24,25,26,27),\n\t                        ivec4(27,28,29,30),\n\t                        ivec4(30,31,32,33),\n\t                        ivec4(35,36,37,38),\n\t                        ivec4(38,39,40,41),\n\t                        ivec4(43,44,45,46),\n\t                        ivec4(46,47,48,49),\n\t                        ivec4(51,52,53,54),\n\t                        ivec4(54,55,56,0));\n\n\tif(all(lessThan(uv,vec2(0.0143119,0.0167165)+border)) && all(greaterThan(uv,vec2(-0.0143117,-0.0167165)-border))){\n\t\tfor(int i=ZERO;i<12;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<15;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat zero_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[48] p=vec2[](vec2(0.0163288,-0.000155151),\n\t                  vec2(0.0163288,0.00605055),\n\t                  vec2(0.0159409,0.0122562),\n\t                  vec2(0.013226,0.0179964),\n\t                  vec2(0.0096577,0.0254432),\n\t                  vec2(0.00329689,0.0266843),\n\t                  vec2(3.89352e-05,0.0266843),\n\t                  vec2(-0.00461534,0.0266843),\n\t                  vec2(-0.010278,0.0246675),\n\t                  vec2(-0.0134584,0.0174534),\n\t                  vec2(-0.0159407,0.012101),\n\t                  vec2(-0.0163286,0.00605055),\n\t                  vec2(-0.0163286,-0.000155151),\n\t                  vec2(-0.0163286,-0.00597297),\n\t                  vec2(-0.0160181,-0.0129543),\n\t                  vec2(-0.0128379,-0.0188497),\n\t                  vec2(-0.00950234,-0.0251329),\n\t                  vec2(-0.00383967,-0.0266843),\n\t                  vec2(-3.86845e-05,-0.0266843),\n\t                  vec2(0.00415014,-0.0266843),\n\t                  vec2(0.0100455,-0.0250554),\n\t                  vec2(0.0134586,-0.0176862),\n\t                  vec2(0.0159409,-0.0123337),\n\t                  vec2(0.0163287,-0.00628323),\n\t                  vec2(0.00989038,0.000775669),\n\t                  vec2(0.00989038,-0.00504211),\n\t                  vec2(0.00989038,-0.0103169),\n\t                  vec2(0.00903714,-0.0152815),\n\t                  vec2(0.00787359,-0.0226507),\n\t                  vec2(0.003452,-0.0249778),\n\t                  vec2(-3.86405e-05,-0.0249778),\n\t                  vec2(-0.00306392,-0.0249778),\n\t                  vec2(-0.00764062,-0.0230385),\n\t                  vec2(-0.00903685,-0.0155917),\n\t                  vec2(-0.00989013,-0.0109375),\n\t                  vec2(-0.00989013,-0.00380099),\n\t                  vec2(-0.00989013,0.000775669),\n\t                  vec2(-0.00989013,0.00574025),\n\t                  vec2(-0.00989013,0.0108599),\n\t                  vec2(-0.00926957,0.0150488),\n\t                  vec2(-0.00779577,0.0242797),\n\t                  vec2(-0.0019779,0.0249778),\n\t                  vec2(-3.86405e-05,0.0249778),\n\t                  vec2(0.00252114,0.0249778),\n\t                  vec2(0.00764087,0.0235816),\n\t                  vec2(0.00911472,0.015902),\n\t                  vec2(0.00989038,0.0115581),\n\t                  vec2(0.00989038,0.00566267));\n\n\tivec4[16] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(3,4,5,6),\n\t                        ivec4(6,7,8,9),\n\t                        ivec4(9,10,11,12),\n\t                        ivec4(12,13,14,15),\n\t                        ivec4(15,16,17,18),\n\t                        ivec4(18,19,20,21),\n\t                        ivec4(21,22,23,0),\n\t                        ivec4(24,25,26,27),\n\t                        ivec4(27,28,29,30),\n\t                        ivec4(30,31,32,33),\n\t                        ivec4(33,34,35,36),\n\t                        ivec4(36,37,38,39),\n\t                        ivec4(39,40,41,42),\n\t                        ivec4(42,43,44,45),\n\t                        ivec4(45,46,47,24));\n\n\tif(all(lessThan(uv,vec2(0.0163288,0.0266843)+border)) && all(greaterThan(uv,vec2(-0.0163286,-0.0266843)-border))){\n\t\tfor(int i=ZERO;i<16;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat p_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[84] p=vec2[](vec2(0.0192376,0.0125665),\n\t                  vec2(0.0192376,0.0208666),\n\t                  vec2(0.0145834,0.0246675),\n\t                  vec2(0.00992917,0.0246675),\n\t                  vec2(0.00612818,0.0246675),\n\t                  vec2(0.00279265,0.021875),\n\t                  vec2(0.000543133,0.0192375),\n\t                  vec2(-0.000387731,0.0237367),\n\t                  vec2(-0.00387846,0.0246675),\n\t                  vec2(-0.00581768,0.0246675),\n\t                  vec2(-0.00861022,0.0246675),\n\t                  vec2(-0.0101616,0.0228834),\n\t                  vec2(-0.0114028,0.0205563),\n\t                  vec2(-0.0128766,0.0174535),\n\t                  vec2(-0.013885,0.0127216),\n\t                  vec2(-0.013885,0.0127216),\n\t                  vec2(-0.013885,0.0119459),\n\t                  vec2(-0.0131093,0.0119459),\n\t                  vec2(-0.0127215,0.0119459),\n\t                  vec2(-0.0117131,0.0119459),\n\t                  vec2(-0.0116355,0.0120233),\n\t                  vec2(-0.0112477,0.0137301),\n\t                  vec2(-0.00985139,0.01916),\n\t                  vec2(-0.0083775,0.022961),\n\t                  vec2(-0.00597287,0.022961),\n\t                  vec2(-0.00395599,0.022961),\n\t                  vec2(-0.00395599,0.0207114),\n\t                  vec2(-0.00395599,0.0198581),\n\t                  vec2(-0.00395599,0.0193927),\n\t                  vec2(-0.00395599,0.0181516),\n\t                  vec2(-0.00449902,0.0159796),\n\t                  vec2(-0.0133421,-0.0195478),\n\t                  vec2(-0.0139626,-0.0219525),\n\t                  vec2(-0.0145832,-0.0221852),\n\t                  vec2(-0.0176085,-0.0222628),\n\t                  vec2(-0.0183066,-0.0222628),\n\t                  vec2(-0.0192375,-0.0222628),\n\t                  vec2(-0.0192375,-0.0237366),\n\t                  vec2(-0.0192375,-0.0242796),\n\t                  vec2(-0.0188496,-0.0246675),\n\t                  vec2(-0.0183066,-0.0246675),\n\t                  vec2(-0.0162122,-0.0246675),\n\t                  vec2(-0.0139626,-0.0244348),\n\t                  vec2(-0.0117906,-0.0244348),\n\t                  vec2(-0.0093084,-0.0244348),\n\t                  vec2(-0.00667101,-0.0246675),\n\t                  vec2(-0.00426629,-0.0246675),\n\t                  vec2(-0.00380088,-0.0246675),\n\t                  vec2(-0.00279244,-0.0246675),\n\t                  vec2(-0.00279244,-0.0231936),\n\t                  vec2(-0.00279244,-0.0222628),\n\t                  vec2(-0.00356816,-0.0222628),\n\t                  vec2(-0.00465413,-0.0222628),\n\t                  vec2(-0.00861027,-0.0222628),\n\t                  vec2(-0.00861027,-0.0217974),\n\t                  vec2(-0.00861027,-0.0210216),\n\t                  vec2(-0.00861027,-0.0205562),\n\t                  vec2(-0.00806728,-0.0185394),\n\t                  vec2(-0.00775698,-0.0172983),\n\t                  vec2(-0.00496443,-0.00597293),\n\t                  vec2(-0.00442145,-0.00729163),\n\t                  vec2(-0.00248219,-0.010472),\n\t                  vec2(0.00155153,-0.010472),\n\t                  vec2(0.0100067,-0.010472),\n\t                  vec2(0.0192376,0.00100844),\n\t                  vec2(0.00969645,-0.00139623),\n\t                  vec2(0.00876563,-0.00333553),\n\t                  vec2(0.00543005,-0.00876552),\n\t                  vec2(0.00147395,-0.00876552),\n\t                  vec2(-0.00302517,-0.00876552),\n\t                  vec2(-0.00380088,-0.00217194),\n\t                  vec2(-0.00380088,-0.00155138),\n\t                  vec2(-0.00380088,-0.00131874),\n\t                  vec2(-0.00372348,-0.00108597),\n\t                  vec2(-0.00356825,-0.000465454),\n\t                  vec2(7.75911e-05,0.0141955),\n\t                  vec2(0.000698152,0.0168328),\n\t                  vec2(0.00550754,0.022961),\n\t                  vec2(0.00977393,0.022961),\n\t                  vec2(0.0132646,0.022961),\n\t                  vec2(0.0140403,0.0185394),\n\t                  vec2(0.0140403,0.0160572),\n\t                  vec2(0.0140403,0.0127992),\n\t                  vec2(0.011946,0.00356826));\n\n\tivec2[3] seg=ivec2[](ivec2(30,31),\n\t                     ivec2(58,59),\n\t                     ivec2(74,75));\n\n\tivec4[27] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(3,4,5,6),\n\t                        ivec4(6,7,8,9),\n\t                        ivec4(9,10,11,12),\n\t                        ivec4(12,13,14,15),\n\t                        ivec4(15,16,17,18),\n\t                        ivec4(18,19,20,21),\n\t                        ivec4(21,22,23,24),\n\t                        ivec4(24,25,26,27),\n\t                        ivec4(27,28,29,30),\n\t                        ivec4(31,32,33,34),\n\t                        ivec4(34,35,36,37),\n\t                        ivec4(37,38,39,40),\n\t                        ivec4(40,41,42,43),\n\t                        ivec4(43,44,45,46),\n\t                        ivec4(46,47,48,49),\n\t                        ivec4(49,50,51,52),\n\t                        ivec4(52,53,54,55),\n\t                        ivec4(55,56,57,58),\n\t                        ivec4(59,60,61,62),\n\t                        ivec4(62,63,64,0),\n\t                        ivec4(65,66,67,68),\n\t                        ivec4(68,69,70,71),\n\t                        ivec4(71,72,73,74),\n\t                        ivec4(75,76,77,78),\n\t                        ivec4(78,79,80,81),\n\t                        ivec4(81,82,83,65));\n\n\tif(all(lessThan(uv,vec2(0.0192376,0.0246675)+border)) && all(greaterThan(uv,vec2(-0.0192375,-0.0246675)-border))){\n\t\tfor(int i=ZERO;i<3;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<27;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat q_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[74] p=vec2[](vec2(0.00981294,-0.0231936),\n\t                  vec2(0.00981294,-0.0222628),\n\t                  vec2(0.00903727,-0.0222628),\n\t                  vec2(0.00795126,-0.0222628),\n\t                  vec2(0.00399516,-0.0222628),\n\t                  vec2(0.00399516,-0.0217974),\n\t                  vec2(0.00399516,-0.0210216),\n\t                  vec2(0.00399516,-0.0204787),\n\t                  vec2(0.0041504,-0.0200908),\n\t                  vec2(0.0042278,-0.0196254),\n\t                  vec2(0.014855,0.0227283),\n\t                  vec2(0.0149324,0.0229609),\n\t                  vec2(0.0150876,0.0237367),\n\t                  vec2(0.0150876,0.0237367),\n\t                  vec2(0.0150876,0.0244348),\n\t                  vec2(0.0144671,0.02459),\n\t                  vec2(0.0142344,0.02459),\n\t                  vec2(0.0133811,0.02459),\n\t                  vec2(0.0105885,0.021875),\n\t                  vec2(0.00934736,0.019703),\n\t                  vec2(0.00841654,0.0219525),\n\t                  vec2(0.0063997,0.0246675),\n\t                  vec2(0.00267629,0.0246675),\n\t                  vec2(-0.00593408,0.0246675),\n\t                  vec2(-0.0150874,0.0128768),\n\t                  vec2(-0.0150874,0.00155143),\n\t                  vec2(-0.0150874,-0.00504211),\n\t                  vec2(-0.0115192,-0.010472),\n\t                  vec2(-0.00570136,-0.010472),\n\t                  vec2(-0.00252097,-0.010472),\n\t                  vec2(0.000349194,-0.00845522),\n\t                  vec2(0.00252114,-0.00636081),\n\t                  vec2(0.000969711,-0.0124113),\n\t                  vec2(0.00104729,-0.0124113),\n\t                  vec2(-0.000504094,-0.0185394),\n\t                  vec2(-0.00135738,-0.0218749),\n\t                  vec2(-0.00143491,-0.0221852),\n\t                  vec2(-0.00639949,-0.0222628),\n\t                  vec2(-0.00740793,-0.0222628),\n\t                  vec2(-0.00826122,-0.0222628),\n\t                  vec2(-0.00826122,-0.0237366),\n\t                  vec2(-0.00826122,-0.0244348),\n\t                  vec2(-0.00779577,-0.0246675),\n\t                  vec2(-0.00725278,-0.0246675),\n\t                  vec2(-0.00477054,-0.0246675),\n\t                  vec2(-0.00205552,-0.0244348),\n\t                  vec2(0.000504345,-0.0244348),\n\t                  vec2(0.00306412,-0.0244348),\n\t                  vec2(0.00585671,-0.0246675),\n\t                  vec2(0.008339,-0.0246675),\n\t                  vec2(0.00880441,-0.0246675),\n\t                  vec2(0.00981277,-0.0246675),\n\t                  vec2(0.00407269,-0.000155107),\n\t                  vec2(0.00345218,-0.00255978),\n\t                  vec2(-0.00127972,-0.00876548),\n\t                  vec2(-0.00554612,-0.00876548),\n\t                  vec2(-0.00919191,-0.00876548),\n\t                  vec2(-0.00981247,-0.00418878),\n\t                  vec2(-0.00981247,-0.00186164),\n\t                  vec2(-0.00981247,0.00201688),\n\t                  vec2(-0.0074078,0.0110927),\n\t                  vec2(-0.00601153,0.0143506),\n\t                  vec2(-0.00407227,0.0190825),\n\t                  vec2(-0.000504007,0.022961),\n\t                  vec2(0.00267642,0.022961),\n\t                  vec2(0.00329698,0.022961),\n\t                  vec2(0.00508109,0.0228836),\n\t                  vec2(0.00647736,0.0207114),\n\t                  vec2(0.00725308,0.0194703),\n\t                  vec2(0.00802879,0.0172207),\n\t                  vec2(0.00802879,0.0157469),\n\t                  vec2(0.00802879,0.0155143),\n\t                  vec2(0.00795139,0.0152039),\n\t                  vec2(0.00779615,0.0147385));\n\n\tivec2[2] seg=ivec2[](ivec2(9,10),\n\t                     ivec2(73,52));\n\n\tivec4[24] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(3,4,5,6),\n\t                        ivec4(6,7,8,9),\n\t                        ivec4(10,11,12,13),\n\t                        ivec4(13,14,15,16),\n\t                        ivec4(16,17,18,19),\n\t                        ivec4(19,20,21,22),\n\t                        ivec4(22,23,24,25),\n\t                        ivec4(25,26,27,28),\n\t                        ivec4(28,29,30,31),\n\t                        ivec4(31,32,33,34),\n\t                        ivec4(34,35,36,37),\n\t                        ivec4(37,38,39,40),\n\t                        ivec4(40,41,42,43),\n\t                        ivec4(43,44,45,46),\n\t                        ivec4(46,47,48,49),\n\t                        ivec4(49,50,51,0),\n\t                        ivec4(52,53,54,55),\n\t                        ivec4(55,56,57,58),\n\t                        ivec4(58,59,60,61),\n\t                        ivec4(61,62,63,64),\n\t                        ivec4(64,65,66,67),\n\t                        ivec4(67,68,69,70),\n\t                        ivec4(70,71,72,73));\n\n\tif(all(lessThan(uv,vec2(0.0150876,0.0246675)+border)) && all(greaterThan(uv,vec2(-0.0150874,-0.0246675)-border))){\n\t\tfor(int i=ZERO;i<2;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<24;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat aspect_ratio = iResolution.x / iResolution.y;\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv-=.5;\n\tuv.x *= aspect_ratio;\n\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\tmouse-=.5;\n\tmouse.x *= iResolution.x / iResolution.y;\n\n\tvec2 mouse2 = iMouse.zw / iResolution.xy;\n\tmouse2-=.5;\n\tmouse2.x *= iResolution.x / iResolution.y;\n\n\tconst float line_width = .001;\n\tconst float curve_width = .001;\n\tconst float dot_size = .005;\n\n\tconst float axis_width = .005;\n\n\tconst vec3 bg_col = vec3(1,1,1);\n\tconst vec3 axis_col = vec3(0,0,0);\n\tconst vec3 line_col = vec3(0,1,0);\n\tconst vec3 second_line_col = vec3(1,1,0);\n\tconst vec3 curve_col = vec3(0,0,1);\n\tconst vec3 dot_col = vec3(1,0,0);\n\tconst vec3 text_col = vec3(0,0,0);\n\n    border = 2./iResolution.y;\n\n\tfloat curve_dis = 1e38;\n\tfloat second_curve_dis = 1e38;\n\tfloat dot_dis = 1e38;\n\tfloat axis_dis = 1e38;\n\tfloat line_dis = 1e38;\n\tfloat second_line_dis = 1e38;\n\tfloat text_dis_sq = 1e38;\n\tfloat text_dis = 1e38;\n\n\t//elliptic curve parameters (weierstrass normal form)\n\tfloat g_2 = .3;\n\tfloat g_3 = -.05;\n\n\t//initial approximations for various points (not exactly lying on the curve)\n\t//you can play around with these values, but the gradient descent\n\t//can get unstable if the points are too far away from the curve\n\n\tvec2 p0=vec2(0.043,-0.193); //0: the inflection point\n\tvec2 p1=vec2(-.3,.05*sin(mod(iTime,6.28318530717959))); //p\n\tvec2 p2=vec2(.1,-.1); //q\n\n\t//compute points lying exactly on the curve by gradient descent\n\tconst int grad_descent_iterations=8;\n\tfloat p0_val, hesse_p0_val, p1_val, p2_val;\n\tvec2 p0_grad, hesse_p0_grad, p1_grad, p2_grad;\n\n\tfor(int i=ZERO;i<grad_descent_iterations;i++){\n\t\tp0_val = p0.y*p0.y - (( 4.*p0.x*p0.x - g_2 ) * p0.x - g_3);\n\t\tp0_grad = vec2(-12.*p0.x*p0.x+g_2,2.*p0.y);\n\t\tp0-=(p0_grad*p0_val)/dot(p0_grad,p0_grad);\n\n\t\t//compute inflection point by alternately gradient descenting to curve and hessian of curve\n\t\thesse_p0_val = -96.*g_2*p0.x*p0.x + 96.*p0.x*p0.y*p0.y - 8.*g_2*g_2 - 288.*g_3*p0.x;\n\t\thesse_p0_grad = vec2(-192.*g_2*p0.x + 96.*p0.y*p0.y - 288.*g_3,192.*p0.x*p0.y);\n\t\tp0-=(hesse_p0_grad*hesse_p0_val)/dot(hesse_p0_grad,hesse_p0_grad);\n\n\t\tp1_val = p1.y*p1.y - (( 4.*p1.x*p1.x - g_2 ) * p1.x - g_3);\n\t\tp1_grad = vec2(-12.*p1.x*p1.x+g_2,2.*p1.y);\n\t\tp1-=(p1_grad*p1_val)/dot(p1_grad,p1_grad);\n\n\t\tp2_val = p2.y*p2.y - (( 4.*p2.x*p2.x - g_2 ) * p2.x - g_3);\n\t\tp2_grad = vec2(-12.*p2.x*p2.x+g_2,2.*p2.y);\n\t\tp2-=(p2_grad*p2_val)/dot(p2_grad,p2_grad);\n\t}\n\n\tvec2 p3=third_intersection(p1,p2,g_2,g_3); //p*q\n\tvec2 p4=third_intersection(p0,p3,g_2,g_3); //p+q\n\tvec2 p5=third_intersection(p0,p1,g_2,g_3); //-p\n\n\tdot_dis=min(dot_dis,distance(p0,uv)-dot_size); //0\n\tdot_dis=min(dot_dis,distance(p1,uv)-dot_size); //p\n\tdot_dis=min(dot_dis,distance(p2,uv)-dot_size); //q\n\tdot_dis=min(dot_dis,distance(p3,uv)-dot_size); //p*q\n\tdot_dis=min(dot_dis,distance(p4,uv)-dot_size); //p+q\n\tdot_dis=min(dot_dis,distance(p5,uv)-dot_size); //-p\n\n\tvec3 l0=line(p1,p2);\n\tvec3 l1=line(p0,p4);\n\n\tline_dis=min(line_dis,abs(dot(vec3(uv,1),l0)));\n\tline_dis=min(line_dis,abs(dot(vec3(uv,1),l1)));\n\n\tvec3 l2=line(p1,p5);\n\n\tp0_grad = vec2(-12.*p0.x*p0.x+g_2,2.*p0.y);\n\tvec3 tangent=vec3(normalize(p0_grad),0);\n\ttangent.z=-dot(p0,tangent.xy);\n\n\tsecond_line_dis=min(second_line_dis,abs(dot(vec3(uv,1),l2)));\n\tsecond_line_dis=min(second_line_dis,abs(dot(vec3(uv,1),tangent)));\n\n\tfloat uv_val = uv.y*uv.y - (( 4.*uv.x*uv.x - g_2 ) * uv.x - g_3);\n\tvec2 uv_grad = vec2(-12.*uv.x*uv.x+g_2,2.*uv.y);\n\n\tcurve_dis=min(curve_dis, abs(uv_val)/length(uv_grad)-curve_width);\n\n\taxis_dis=min(axis_dis, abs(uv.x));\n\taxis_dis=min(axis_dis, abs(uv.y));\n\n\tvec2[4] p_positions=vec2[](vec2(.03,.05)-p1,vec2(-.04,-.03)-p3,vec2(.13,.03)-p4,vec2(.03,.03)-p5);\n\tvec2[3] q_positions=vec2[](vec2(-.01,-.05)-p2,p_positions[1]+vec2(-.1,.0),p_positions[2]+vec2(-.1,.0));\n\n\tvec2 plus_position=p_positions[2]+vec2(-.05,1e-7);\n\tvec2 minus_position=p_positions[3]+vec2(.05,1e-7);\n\tvec2 zero_position=vec2(.003,.0425)-p0;\n\tvec2 asterisk_position=p_positions[1]+vec2(-.05,0.);\n\n\ttext_dis_sq=min(text_dis_sq,plus_dis_sq(uv+plus_position));\n\ttext_dis_sq=min(text_dis_sq,minus_dis_sq(uv+minus_position));\n\ttext_dis_sq=min(text_dis_sq,asterisk_dis_sq(uv+asterisk_position));\n\ttext_dis_sq=min(text_dis_sq,zero_dis_sq(uv+zero_position));\n\n\tfor(int i=ZERO;i<4;i++){\n\t\ttext_dis_sq=min(text_dis_sq,p_dis_sq(uv+p_positions[i]));\n\t}\n\tfor(int i=ZERO;i<3;i++){\n\t\ttext_dis_sq=min(text_dis_sq,q_dis_sq(uv+q_positions[i]));\n\t}\n\n\ttext_dis=sign(text_dis_sq)*sqrt(abs(text_dis_sq));\n\n\tvec3 color = bg_col;\n\n\tcolor=vec3(mix(axis_col,color,smoothstep(0., border, axis_dis)));\n\tcolor=vec3(mix(line_col,color,smoothstep(0., border, line_dis)));\n\tcolor=vec3(mix(second_line_col,color,smoothstep(0., border, second_line_dis)));\n\tcolor=vec3(mix(curve_col,color,smoothstep(0., border, curve_dis)));\n\tcolor=vec3(mix(dot_col,color,smoothstep(0., border, dot_dis)));\n\tcolor=vec3(mix(text_col,color,smoothstep(-border/2., border/2., text_dis)));\n\n\tfragColor = vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2cR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1921, 2042, 2091, 2126, 2306], [2308, 2393, 2436, 2436, 3445], [3447, 3447, 3528, 3547, 3722], [3724, 3724, 3802, 3802, 4360], [4362, 4385, 4410, 4410, 4429], [4431, 4431, 4478, 4478, 4589], [4591, 4591, 4639, 4639, 4909], [4911, 4911, 4982, 4982, 5846], [5848, 5848, 5878, 5878, 5983], [5985, 5985, 6049, 6049, 6562]], "test": "untested"}
{"id": "Ws2cRh", "name": "Projective Conic Envelope", "author": "mla", "description": "An ellipse, constructed as an envelope of tangent lines.\n\nDual to: [url]https://www.shadertoy.com/view/tdSyDz[/url]\n\nMouse changes ellipse.", "tags": ["envelope", "conic", "projective", "loopless"], "likes": 16, "viewed": 575, "published": 3, "date": "1586100203", "time_retrieved": "2024-07-30T21:14:45.578487", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Projective Conic Envelope\n//\n// Copyright (c) Matthew Arcus, 2020\n// MIT License: https://opensource.org/licenses/MIT\n//\n// More projective magic - generate an ellipse as an envelope of lines.\n// In fact, we start with the ellipse and find a network of lines\n// enveloping it: at each point p, find tangents to the ellipse,\n// intersect these with a fixed axis at x = -3 - this will be the\n// source of the rays. From axis intersection point, map to a radial\n// parameter, then find closest displayed ray, map that back to the\n// axis and find the tangents from there & these are the lines that\n// actually get displayed.\n//\n// Mouse changes size and orientation of ellipse.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\n\nvec3 join(vec3 p, vec3 q) {\n  // Return either intersection of lines p and q\n  // or line through points p and q, r = kp + jq\n  return cross(p,q);\n}\n\nfloat line(vec3 p, vec3 q) {\n  return abs(dot(p,q)/(p.z*length(q.xy)));\n}\n\n// Set tan1 and tan2 to the two tangents to conic X from point p.\n// Return false if no tangents (eg. inside an ellipse).\nbool tangents(vec3 p, mat3 X, out vec3 tan1, out vec3 tan2) {\n  vec3 polar = X*p; // Line between tangents\n  float a = polar.x, b = polar.y, c = polar.z;\n  // Two points on the polar line. Q is the nearest point to origin,\n  // R is at infinity, ie. is direction vector.\n  vec3 Q = vec3(a,b,-(a*a+b*b)/c);\n  vec3 R = vec3(-b,a,0);\n\n  // Find intersection of QR with conic, ie. dot(Q+kR,X*(Q+kR)) = 0\n  float A = dot(R,X*R), B = dot(Q,X*R), C = dot(Q,X*Q);\n  float D = B*B-A*C;\n  if (D < 0.0) return false;\n  D = sqrt(D);\n  float k1,k2;\n  if (B > 0.0) {\n    k1 = (-B-D)/A; k2 = C/(A*k1);\n  } else {\n    k2 = (-B+D)/A; k1 = C/(A*k2);\n  }\n  tan1 = join(p,Q+k1*R); tan2 = join(p,Q+k2*R);\n  return true;\n}\n\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  float scale = 3.0;\n  float t = 0.2*iTime+PI/6.0;\n  float A = 0.25, B = 1.0;\n  if (iMouse.x > 0.0) {\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    t += PI*(m.y);\n    B = exp(-m.x);\n  }\n  float cost = cos(t), sint = sin(t);\n  // Conic matrix - conic is points p with pXp = 0\n  mat3 X = mat3(A,0,0,0,B,0,0,0,-1);\n  // Apply tranformation to conic matrix.\n  mat3 P = mat3(cost,sint,0, -sint,cost,0, 0,0,1);\n  X = transpose(P)*X*P;\n\n  vec3 p = vec3(scale*(2.0*fragCoord - iResolution.xy)/iResolution.y,1);\n\n  vec3 col = vec3(0);\n  \n  float lwidth0 = 0.0;\n  float lwidth1 = max(0.02,fwidth(p.x));\n\n  vec3 tan1,tan2,tan11,tan12,tan21,tan22;\n  if (tangents(p,X,tan1,tan2)) {\n    float N = 64.0;\n    vec3 axis = vec3(1,0,3);\n    float index1,index2;\n\n    vec3 p1 = join(tan1,axis);\n    float t1 = atan(p1.y/p1.z);\n    t1 += 0.1*iTime;\n    t1 *= N/PI; t1 = round(t1); index1 = t1; t1 *= PI/N;\n    t1 -= 0.1*iTime;\n    p1 = vec3(-3,tan(t1),1);\n    p1.y = sign(p1.y)*min(abs(p1.y),1e4); // Fix up silly values\n    if (tangents(p1,X,tan11,tan12)) {\n      vec3 c1 = hsv2rgb(vec3(index1/N,1,1));\n      float d = line(p,tan11);\n      col = mix(c1,col,smoothstep(lwidth0,lwidth1,d));\n      float tt = dot(normalize(tan2.xy),normalize(tan12.xy));\n      // Try not to get the wrong tangent here. There must be a better\n      // way of doing this.\n      if (abs(tt) < 0.99) {\n        d = line(p,tan12);\n        col = mix(c1,col,smoothstep(lwidth0,lwidth1,d));\n      }\n    }\n\n    vec3 p2 = join(tan2,axis);\n    float t2 = atan(p2.y/p2.z);\n    t2 += 0.1*iTime;\n    t2 *= N/PI; t2 = round(t2); index2 = t2; t2 *= PI/N;\n    t2 -= 0.1*iTime;\n    p2 = vec3(-3,tan(t2),1);\n    p2.y = sign(p2.y)*min(abs(p2.y),1e4); // Fix up silly values\n    if (tangents(p2,X,tan21,tan22)) {\n      vec3 c2 = hsv2rgb(vec3(index2/N,1,1));\n      float d = line(p,tan22);\n      col = mix(c2,col,smoothstep(lwidth0,lwidth1,d));\n      float tt = dot(normalize(tan1.xy),normalize(tan21.xy));\n      // Try not to get the wrong tangent here.\n      if (abs(tt) < 0.99) {\n        d = line(p,tan21);\n        col = mix(c2,col,smoothstep(lwidth0,lwidth1,d));\n      }\n    }\n  }\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2cRh.jpg", "access": "api", "license": "mit", "functions": [[879, 879, 906, 1004, 1027], [1029, 1029, 1057, 1057, 1102], [1104, 1226, 1287, 1287, 1926], [1928, 1928, 1955, 1955, 2131], [2133, 2133, 2186, 2186, 4385]], "test": "ok"}
{"id": "tsScR1", "name": "truchet all my own", "author": "scry", "description": "First truchet done with no tutorial or reference (except of course the noise/rand functions). messy code of course as a result, but fact is the goal was reached!", "tags": ["2d"], "likes": 2, "viewed": 308, "published": 3, "date": "1586081759", "time_retrieved": "2024-07-30T21:14:46.446166", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0,uv).rgb*3.;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define time iTime\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n    \n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res*res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    vec2 ouv = fragCoord/iResolution.xy;\n    vec2 uv = -1. + 2. * ouv;\n    float ar = iResolution.x/iResolution.y;\n    float scroll = time*0.05;\n    vec2 itv = uv;\n    vec2 tuv = itv;\n    itv += scroll;\n    vec2 tv = itv;\n    tv.x *= ar;\n    itv.x *= ar;\n\n    vec3 col = vec3(0.);\n    float s = 3.;\n    col.rg = floor(tv*s)/s;\n    float rt = noise(col.rg*10.);\n    float rt1 = noise(col.rg*1000.);\n    float checker = mod(floor(itv*s).x+floor(itv*s).y,2.);\n    col *= 0.;\n    vec2 uvu = tv;\n    vec2 fv = fract(tv*s)-0.5;\n    vec2 t2 = tv;\n    bool cm = false;\n    if (rt > 0.5) {\n        tv.x = 1.- tv.x;\n        cm = true;\n    }\n    if (rt1 > 0.3) {\n        t2.x = 1.- t2.x;\n    }\n    vec2 sl = fract(tv*s);\n    vec2 sv = mod(floor(itv*s),2.);\n    vec2 slc = sl;\n    if (sl.x+sl.y > 1.) {\n        sl = 1.-sl;\n\n    }\n    float c= length(sl);\n    float c2 = length(1.-sl);\n    if (checker < 1.) {\n        sl = -sl.yx;\n        c = 1.-c;\n    }\n    if (cm == true) {\n        c = 1.-c;\n    }\n    float l = 0.2;\n    vec2 cuv = vec2(sin(atan(sl.x,sl.y)*4.+time*3.)*0.5+0.5,c);\n    \n    cuv.y *= 4.;\n    cuv *= 0.25;\n    float sn = 0.;\n    if (c > 0.5-l && c < 0.5+l || c2 > 0.5-l && c2 < 0.5+l) {\n        col += 1.;\n        sn += 1.;\n    }\n    col *= c*0.5;\n    col += sin(cuv.y*60.);\n\n    col.rg -= sin(cuv.x*20.)*0.5;\n    col.bg = vec2(sin(col.r*3.5),sin(col.b*2.));\n    col.rgb = col.rrb;\n    vec3 bak = texture(iChannel0,tuv).rgb;\n    //cuv -= scroll*0.25;\n    cuv *= 0.1;\n    float ra = 0.45;\n    cuv *= mat2(sin(ra),cos(ra),\n                -cos(ra),sin(ra));\n    cuv = sin(cuv*4.);\n    cuv += 0.5;\n    cuv -= 0.5;\n    cuv *= 8.;\n    cuv *= 0.15;\n    cuv -= scroll*0.5;\n    cuv = mix(cuv,tuv,0.89);\n    vec3 tex = texture(iChannel1,cuv).rgb;\n    vec3 sbak = texture(iChannel0,cuv).rgb;\n    col += 1.;\n    col *= 0.005;\n    col = sbak+0.05;\n    col *= sn;\n    //col.rg = vec2(sin(col.r),cos(col.g))*0.1;\n\n    fragColor = vec4(col,1.);\n    \n    //fragColor = vec4(0.0,0.0,1.0,1.0);\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsScR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 283]], "test": "untested"}
{"id": "tsByR1", "name": "just playing around", "author": "scry", "description": "haha yes", "tags": ["2d"], "likes": 2, "viewed": 340, "published": 3, "date": "1586080703", "time_retrieved": "2024-07-30T21:14:47.212119", "image_code": "vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{//from https://iquilezles.org/articles/palettes\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 tv = uv;\n    uv = -1. + 2. * uv;\n    //vec2 tv = inData.v_texcoord;\n    vec3 col = vec3(0.);\n    float time = iTime;\n    //float stime = sin(time);\n    //float ptime = -4.2+time;\n    time += 90.;\n    time = abs(mod(time*1.,180.)-90.);\n    //uv.x += time*0.1;\n  \t\n    //uv = tv;\n    //uv = mix(uv,tv,0.99);\n    \n    //uv.y += sin(uv.x*2.);\n    //uv.y += abs(fract(uv.x*4.)-0.5);\n    float us = 0.1*sin(time*0.04);\n    float tc = clamp(iTime,60.5,iTime+1.)-60.5;\n    float tc1 = clamp(iTime,24.,iTime+1.)-24.;\n    uv.x *= tc1*0.05;\n    //uv *= 1.+(100./(iTime+10.));\n    //uv.y += time;\n    uv.y -= time*0.05;\n    for (float i=0.;i<12.;i++) {\n        uv.y += sin(uv.x*i)*us;\n        uv.x += time*0.002*sin(time*0.01);\n        uv.y += abs(fract(uv.x*4.*i)-0.5)*us;\n    }\n    //uv.y += time*10.;\n    \n    //uv.y *= sin(time*10.)*.5+0.5;\n    uv = mix((tv*sin((iTime+2.2)*3.14159*(0.5*(1./(time+1.))))),uv,0.1);\n    //uv *= 0.1;\n    //time = abs(mod(time,74.)-74.);\n    uv *= vec2(sin((uv.y+uv.x)*1.));\n    col += uv.y;\n    col.r += time*0.01;\n    time -= 4.2;\n    //time *= 0.9;\n    //col = abs(col);\n    //col.r = col.r*col.r*-1.;\n    col = palette(col.r*((time-tc*0.5)),vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.,0.15,.2));\n    col *= vec3(0.6,0.6,1.);\n    //col.rg = fract(uv*2.);\n    fragColor = vec4(col,1.);\n}", "image_inputs": [{"id": 21788, "src": "https://soundcloud.com/georgeclanton/bleed", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsByR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 72, 119, 162], [164, 164, 221, 221, 1603]], "test": "untested"}
{"id": "tsjyzz", "name": "PerfectEgg", "author": "Arseny", "description": "egg", "tags": ["raymarching"], "likes": 2, "viewed": 321, "published": 3, "date": "1586080347", "time_retrieved": "2024-07-30T21:14:47.983057", "image_code": "// template copied form inigo quilez - iq/2019\n\n//   Step 1: https://www.shadertoy.com/view/ws3GD2\n\n\n#define AA 2\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat f(float x){\n    x *= 1.02;\n    float ans = (x - 0.6) * (x - 0.6) + 0.37;\n    ans = smin(ans, 0.5, 0.05);\n    ans = smin(ans, -(x * 2. - 0.25) * (x * 2. - 0.25)  + 0.51, -0.05);\n    return ans;\n}\n\nfloat sdSphere( in vec3 p, in float r )\n{\n    return length(p)-r;\n}\n\nfloat sdEgg(in vec3 p, in float r, in float h){\n    //p.z += 0.5;\n    vec3 off = p - vec3(0., 0.5, 0.);\n    float ans = 0.;\n    //float x = -acos(dot(normalize(off), vec3(0., 0., 1.)));\n    float angle = 1. - acos(dot(normalize(off), vec3(0, 1, 0))) / 3.1415;\n    return length(off) - f(angle);\n    //length(off) - f(x / 3.1415)\n    //ans = p.y - f(p.z) + 0.5;\n//    ans = max(ans, );\n    //return ans;\n    //return y - f;\n}\n\n//float sdTransOct(in vec3 p, in vec3\n\nvec4 map( in vec3 p, float time )\n{\n    //float d = sdSphere( p, 0.1 );\n    float d = sdEgg( p, 0.1, 0.1 );\n    //d = min(d, length(p.xy) - 0.01);\n    //d = min(d, length(p.yz) - 0.01);\n    d = min(d, p.y - 0.01);\n    return vec4( d, p );\n}\n\n#define ZERO min(iFrame,0)\n\nvec3 calcNormal( in vec3 pos, in float time )\n{\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e,time).x;\n    }\n    return normalize(n);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in float time )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos+h*nor, time ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float k, in float time )\n{\n    float res = 1.0;\n    \n    float tmax = 20.0;\n    float t    = 0.001;\n    for( int i=0; i<64; i++ )\n    {\n        float h = map( ro + rd*t, time ).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.012, 0.2 );\n        if( res<0.001 || t>tmax ) break;\n    }\n    \n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 getLight(in float time){\n    return vec3(3, 2, 1);\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd, in float time )\n{\n    vec4 res = vec4(-1.0);\n    \n    float t = 0.001;\n    float tmax = 1000.0;\n    for( int i=0; i<128 && t<tmax; i++ )\n    {\n        vec4 h = map(ro+t*rd,time);\n        if( abs(h.x)<0.0001 ) { res=vec4(t,h.yzw); break; }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float time = iTime;\n        #endif\n\n\t    // camera\t\n        float an = 6.2831*time/30.0;\n        vec3 ta = vec3( 0.0, 0.5, 0.0 );\n        vec3 ro = ta + vec3( 1.8*cos(an), 0.4*cos(an) + 0.4, 0.8 );\n        \n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        \n        // ray direction\n        float fl = 2.0;\n        vec3 rd = ca * normalize( vec3(p,fl) );\n\n        // background\n        vec3 col = vec3(1.0+rd.y)*0.03;\n        \n        // raymarch geometry\n        vec4 tuvw = intersect( ro, rd, time );\n        if( tuvw.x>0.0 )\n        {\n            // shading/lighting\t\n            vec3 pos = ro + tuvw.x*rd;\n            vec3 nor = calcNormal(pos, time);\n            \n            //col = 0.5 + 0.5*nor;\n            col = vec3(max(dot(normalize(ro - pos), normalize(nor)), 0.1));\n            //col = vec3(0.5);\n            col *= calcSoftshadow(pos + normalize(nor) * 0.01, normalize(getLight(iTime) - pos), 10., iTime) * 0.1 + 0.9;\n            col *= min(1., 1. / length(ro - pos) * 4.);\n            //col = vec3(pow(dot(nor, vec3(1.)), 2.1));\n        }\n        \n        \n        // gamma        \n\t    tot += pow(col,vec3(0.45) );\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n    \n   /* tot *= 0.;\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy)/iResolution.y * 2.;\n    uv = fragCoord.xy / iResolution.y;\n    tot = vec3(uv.xy, 0.);\n    float x = uv.x;\n    float y = uv.y;\n    //float f = f(x);\n    //tot = vec3(step(0., y - f));\n    \n    tot = (uv.y > 0.99) ? vec3(0., 1., 0.) : tot;\n    tot = (abs(uv.x) < 0.01) ? vec3(0., 1., 0.) : tot;\n    tot = (abs(uv.x - 1.) < 0.002) ? vec3(0., 1., 0.) : tot;\n    tot = (abs(uv.x - 0.2) < 0.002) ? vec3(0., 1., 0.) : tot;\n    //tot = (abs(uv.y - 0.5) < 0.005) ? vec3(0., 1., 0.) : tot;\n    \n    tot *= 0.;\n   \tvec2 off = uv - vec2(0.5, 0.);\n    //float x_ = 1. - atan(off.y, off.x) / 3.1415;\n    float x_ = 1. - acos(dot(normalize(off), vec2(1, 0))) / 3.1415;\n    tot = vec3(step(0., length(off) - f(x_)));\n*/\n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjyzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[115, 115, 156, 156, 249], [251, 251, 268, 268, 451], [453, 453, 494, 494, 520], [522, 522, 569, 587, 946], [987, 987, 1022, 1058, 1227], [1257, 1257, 1304, 1304, 1513], [1515, 1515, 1572, 1572, 1837], [1839, 1839, 1914, 1914, 2226], [2228, 2228, 2257, 2257, 2285], [2287, 2287, 2344, 2344, 2612], [2614, 2614, 2666, 2666, 2843]], "test": "untested"}
{"id": "wdByR1", "name": "The Hessian of an elliptic curve", "author": "NinjaKoala", "description": "Visualization of the Hessian curve of an elliptic curve.\n\nYou can change the elliptic curve parameters with mouse,\nbut for some parameters the iterative computation of the inflection points fails,\nyou can try changing the initial approximations then.", "tags": ["2d", "curves", "geometry", "elliptic"], "likes": 3, "viewed": 364, "published": 3, "date": "1586077111", "time_retrieved": "2024-07-30T21:14:48.790897", "image_code": "/*\nVisualization of the Hessian of an elliptic curve.\nThe Hessian is the set of points where the\ndeterminant of the Hessian Matrix of the curve vanishes.\nIt has the interesting property that it passes through all\nthe inflection points of the curve.\n\n(An inflection point is a point on the curve where the\ncurve tangent is intersecting the curve with multiplicity >=3)\n\nThe blue curve is the elliptic curve\nThe cyan curve is the Hessian of the elliptic curve\nThe red dots are the inflection points\nThe green lines are the tangents at the inflection points\n\nMove mouse to change curve parameters\n\nFor some curve parameters the iterative computation of the\ninflection points fails.\n\nsee https://en.wikipedia.org/wiki/Polar_curve#The_Hessian\n*/\n\nconst int grad_descent_iterations=16;\n\nfloat border;\n\nfloat halley_iteration4(vec4 coeffs, float x){\n\n\tfloat f = (((x + coeffs[3]) * x + coeffs[2]) * x + coeffs[1]) * x + coeffs[0];\n\tfloat f1 = ((4. * x + 3. * coeffs[3]) * x + 2. * coeffs[2]) * x + coeffs[1];\n\tfloat f2 = (12. * x + 6. * coeffs[3]) * x + 2. * coeffs[2];\n\n\treturn x-(2.*f*f1)/(2.*f1*f1-f*f2);\n}\n\nfloat eval_poly4(vec4 coeffs, float x){\n\n\tfloat f = (((x + coeffs[3]) * x + coeffs[2]) * x + coeffs[1]) * x + coeffs[0];\n\n\treturn f;\n}\n\nvec2 compute_inflection_point_gradient_descent(float g_2, float g_3){\n\n\tvec2 p0=vec2(0.5,0.5);//initial approximation of the inflection point\n\n\t//compute inflection points by alternately gradient descenting to curve and hessian of curve\n\tfloat p0_val, hesse_p0_val;\n\tvec2 p0_grad, hesse_p0_grad;\n\n\tfor(int i=0;i<grad_descent_iterations;i++){\n\t\tp0_val = p0.y*p0.y - (( 4.*p0.x*p0.x - g_2 ) * p0.x - g_3);\n\t\tp0_grad = vec2(-12.*p0.x*p0.x+g_2,2.*p0.y);\n\t\tp0-=(p0_grad*p0_val)/dot(p0_grad,p0_grad);\n\n\t\thesse_p0_val = -96.*g_2*p0.x*p0.x + 96.*p0.x*p0.y*p0.y - 8.*g_2*g_2 - 288.*g_3*p0.x;\n\t\thesse_p0_grad = vec2(-192.*g_2*p0.x + 96.*p0.y*p0.y - 288.*g_3,192.*p0.x*p0.y);\n\t\tp0-=(hesse_p0_grad*hesse_p0_val)/dot(hesse_p0_grad,hesse_p0_grad);\n\t}\n\n\treturn p0;\n}\n\nvec2 compute_inflection_point_halley(float g_2, float g_3){\n\n\tvec4 coeffs = vec4(-1./48.*g_2*g_2,-g_3,-1./2.*g_2,0.);\n\n\tbool swap=false;\n\n\tif(eval_poly4(coeffs,1.)<0.){\n\t\tswap=true;\n\t\tcoeffs=vec4(1.,coeffs[3],coeffs[2],coeffs[1])/coeffs[0];\n\t}\n\n\tfloat lb=0.;\n\tfloat ub=1.;\n\n\tfor(int i=0;i<4;i++){\n\t\tif(eval_poly4(coeffs,.5*lb+.5*ub)>0.){\n\t\t\tub=.5*lb+.5*ub;\n\t\t}\n\t\telse{\n\t\t\tlb=.5*lb+.5*ub;\n\t\t}\n\t}\n\n\tfloat x_0=.5*lb+.5*ub;\n\n\tfor(int i=0;i<2;i++){\n\t\tx_0=halley_iteration4(coeffs,x_0);\n\t}\n\n\tif(swap){\n\t\tx_0=1./x_0;\n\t}\n\n\tfloat y_0 = sqrt(( 4.*x_0*x_0 - g_2 ) * x_0 - g_3);\n\n\treturn vec2(x_0,y_0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat aspect_ratio = iResolution.x / iResolution.y;\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv-=.5;\n\tuv.x *= aspect_ratio;\n\n\tvec2 mouse = (iMouse.xy+1.) / iResolution.xy;\n\tmouse-=.5;\n\n\tconst float line_width = .001;\n\tconst float curve_width = .001;\n\tconst float dot_size = .005;\n\n\tconst float axis_width = .005;\n\n\tconst vec3 bg_col = vec3(1,1,1);\n\tconst vec3 axis_col = vec3(0,0,0);\n\tconst vec3 line_col = vec3(0,1,0);\n\tconst vec3 curve_col = vec3(0,0,1);\n\tconst vec3 hesse_curve_col = vec3(0,1,1);\n\tconst vec3 dot_col = vec3(1,0,0);\n\n    border = 2./iResolution.y;\n\n\tfloat curve_dis = 1e38;\n\tfloat hesse_curve_dis = 1e38;\n\tfloat dot_dis = 1e38;\n\tfloat axis_dis = 1e38;\n\tfloat line_dis = 1e38;\n\n\t//elliptic curve parameters (weierstrass normal form)\n\n\tfloat g_2, g_3;\n\n\tif(iMouse.x > 0.0){\n\t\tg_2 = .3+mouse.x;\n\t\tg_3 = -.05+mouse.y;\n\t}\n\telse{\n\t\tg_2 = .3;\n\t\tg_3 = -.05;\n\t}\n\n\t//vec2 p0=compute_inflection_point_gradient_descent(g_2,g_3);\n\tvec2 p0=compute_inflection_point_halley(g_2,g_3);\n\tvec2 p1=p0*vec2(1.,-1.);\n\n\tdot_dis=min(dot_dis,distance(p0,uv)-dot_size);\n\tdot_dis=min(dot_dis,distance(p1,uv)-dot_size);\n\n\tvec2 p0_grad = vec2(-12.*p0.x*p0.x+g_2,2.*p0.y);\n\tvec3 tangent1=vec3(normalize(p0_grad),0);\n\ttangent1.z=-dot(p0,tangent1.xy);\n\n\tline_dis=min(line_dis,abs(dot(vec3(uv,1),tangent1)));\n\n\tvec2 p1_grad = vec2(-12.*p1.x*p1.x+g_2,2.*p1.y);\n\tvec3 tangent2=vec3(normalize(p1_grad),0);\n\ttangent2.z=-dot(p1,tangent2.xy);\n\n\tline_dis=min(line_dis,abs(dot(vec3(uv,1),tangent2)));\n\n\tfloat uv_val = uv.y*uv.y - (( 4.*uv.x*uv.x - g_2 ) * uv.x - g_3);\n\tvec2 uv_grad = vec2(-12.*uv.x*uv.x+g_2,2.*uv.y);\n\n\tcurve_dis=min(curve_dis, abs(uv_val)/length(uv_grad)-curve_width);\n\n\tfloat hesse_uv_val = -96.*g_2*uv.x*uv.x + 96.*uv.x*uv.y*uv.y - 8.*g_2*g_2 - 288.*g_3*uv.x;\n\tvec2 hesse_uv_grad = vec2(-192.*g_2*uv.x + 96.*uv.y*uv.y - 288.*g_3,192.*uv.x*uv.y);\n\n\thesse_curve_dis=min(hesse_curve_dis, abs(hesse_uv_val)/length(hesse_uv_grad)-curve_width);\n\n\taxis_dis=min(axis_dis, abs(uv.x));\n\taxis_dis=min(axis_dis, abs(uv.y));\n\n\tvec3 color = bg_col;\n\n\tcolor=vec3(mix(axis_col,color,smoothstep(0., border, axis_dis)));\n\tcolor=vec3(mix(line_col,color,smoothstep(0., border, line_dis)));\n\tcolor=vec3(mix(hesse_curve_col,color,smoothstep(0., border, hesse_curve_dis)));\n\tcolor=vec3(mix(curve_col,color,smoothstep(0., border, curve_dis)));\n\tcolor=vec3(mix(dot_col,color,smoothstep(0., border, dot_dis)));\n\n\tfragColor = vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdByR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[796, 796, 842, 842, 1102], [1104, 1104, 1143, 1143, 1238], [1240, 1240, 1309, 1309, 1991], [1993, 1993, 2052, 2052, 2585], [2587, 2587, 2641, 2641, 5059]], "test": "untested"}
{"id": "WsByR1", "name": "The Live Coders Conference - 3", "author": "mrange", "description": "The Live Coders Conference - Online on twitch.tv April 9, 2020 - https://captcalli.github.io/LiveCodersConf/\n\nCreated a few shaders inspired by the online event, these shaders are not officially adopted just made for fun and to promote the event.", "tags": ["2d", "fbm", "tlc"], "likes": 10, "viewed": 459, "published": 3, "date": "1586036143", "time_retrieved": "2024-07-30T21:14:49.610706", "image_code": "// Created by mrange/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 Unported License.\n\n// The Live Coders Conference - Online on twitch.tv April 9, 2020 - https://captcalli.github.io/LiveCodersConf/\n// Created a few shaders inspired by the online event, these shaders are not officially adopted just made for fun and to promote the event.\n\n// 2D shape created by combining 2D primitives from IQ's blog:\n//  https://iquilezles.org/articles/distfunctions2d\n// pmin from IQ's blog on smooth minimum functions:\n//  https://iquilezles.org/articles/smin\n// warped fbms from IQ's blog:\n//  https://iquilezles.org/articles/warp\n\n#define PI     3.141592654\n#define TAU    (2.0*PI)\n#define SCA(a) vec2(sin(a), cos(a))\n#define TIME   (iTime+120.0)\n#define TTIME  (TIME*TAU)\n#define PERIOD 600.0\n\nconst float a1 = PI/2.0;\nconst float a2 = PI*4.5/6.0;\n\nconst vec2 sca1 = SCA(a1);\nconst vec2 sca2 = SCA(a2);\n\nconst mat2 frot = mat2(0.80, 0.60, -0.60, 0.80);\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat noise(vec2 p) {\n  float a = sin(p.x);\n  float b = sin(p.y);\n  float c = 0.5 + 0.5*cos(p.x + p.y);\n  float d = mix(a, b, c);\n  return d;\n}\n\nfloat fbm(vec2 p) {    \n  float f = 0.0;\n  float a = 1.0;\n  float s = 0.0;\n  float m = 2.0-0.1;\n  for (int x = 0; x < 4; ++x) {\n    f += a*noise(p); p = frot*p*m;\n    m += 0.01;\n    s += a;\n    a *= 0.45;\n  }\n  return f/s;\n}\n\nfloat warp(vec2 p, float offset, out vec2 v, out vec2 w) {\n  vec2 vx = vec2(0.0, 0.0);\n  vec2 vy = vec2(3.2, 1.3);\n\n  vec2 wx = vec2(1.7, 9.2);\n  vec2 wy = vec2(8.3, 2.8);\n\n  vec2 off = (1.75 + 0.5*cos(TTIME/60.0))*vec2(-5, 5);\n\n  p += mix(vec2(0.0), off, 0.5 + 0.5*tanh(offset));\n\n  rot(vx, TTIME/1000.0);\n  rot(vy, TTIME/900.0);\n\n  rot(wx, TTIME/800.0);\n  rot(wy, TTIME/700.0);\n\n  vec2 vv = vec2(fbm(p + vx), fbm(p + vy));  \n  vec2 ww = vec2(fbm(p + 3.0*vv + wx), fbm(p + 3.0*vv + wy));\n\n  float f = fbm(p + 2.25*ww);\n\n\n  v = vv;\n  w = ww;\n\n//  return tanh(f);\n  return f;\n}\n\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = max(k-abs(a-b), 0.0)/k;\n  return min(a, b) - h*h*k*(1.0/4.0);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat box(vec2 p, vec2 b, vec4 r) {\n  r.xy = (p.x>0.0)?r.xy : r.zw;\n  r.x  = (p.y>0.0)?r.x  : r.y;\n  vec2 q = abs(p)-b+r.x;\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat arc(vec2 p, vec2 sca, vec2 scb, float ra, float rb) {\n  p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n  p.x = abs(p.x);\n  float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n  return sqrt(dot(p,p) + ra*ra - (2.0 - 0.000001)*ra*k) - rb;\n}\n\nfloat spokes(vec2 p, float s) {\n  vec2 pp = toPolar(p);\n  pp.y += TTIME*10.0/PERIOD;\n  mod1(pp.y, TAU/10.0);\n  pp.y += PI/2.0;\n  p = toRect(pp);\n  float ds = box(p, s*vec2(0.075, 0.5), s*vec4(0.04));\n  return ds;\n}\n\nfloat arcs(vec2 p, float s) {\n  \n  float d1 = arc(p, sca1, sca2, s*0.275, s*0.025);\n  float d2 = arc(p, sca1, sca2, s*0.18, s*0.025);\n  \n  return min(d1, d2);\n}\n\nfloat meeple(vec2 p, float s) {\n  float dh = box(p - s*vec2(0.0, -0.035), s*vec2(0.07, 0.1), s*vec4(0.065));\n  float dc = box(p - s*vec2(0.0, -0.22), s*vec2(0.15, 0.04), s*vec4(0.05, 0.02, 0.05, 0.02));\n  \n  return pmin(dh, dc, s*0.115);\n}\n\nfloat theLiveCoders(vec2 p, float s) {\n  float ds = spokes(p, s);\n  float dc = circle(p, 0.375*s);\n  float da = arcs(p, s);\n  float dm = meeple(p, s);\n  \n  float d = ds;\n  d = min(d, dc);\n  d = max(d, -da);\n  d = max(d, -dm);\n  \n  return d;\n}\n\nfloat df(vec2 p) {  \n  return theLiveCoders(p, 3.0);\n}\n\nvec3 normal(vec2 p, float offset) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(0.0001, 0);\n  \n  vec3 n;\n  n.x = warp(p + e.xy, offset, v, w) - warp(p - e.xy, offset, v, w);\n  n.y = 2.0*e.x;\n  n.z = warp(p + e.yx, offset, v, w) - warp(p - e.yx, offset, v, w);\n  \n  return normalize(n);\n}\n\n\nvec3 postProcess(vec3 col) {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75));\n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= iResolution.x/iResolution.y;\n\n  p *= 1.65;\n  vec3 col = vec3(1.0);\n \n  float d = df(p);\n  p += -0.025*TTIME*vec2(-1.0, 1.0);\n \n  vec2 v;\n  vec2 w;\n \n  float f = warp(p, d, v, w);\n  vec3 n = normal(p, d);\n\n  vec3 lig = normalize(vec3(0.6, -0.4, -0.4));\n//  rot(lig.xz, TTIME/100.0);\n  float dif = max(dot(lig, n), 0.5);\n\n  const vec3 col1 = vec3(0.1, 0.3, 0.8);\n  const vec3 col2 = vec3(0.7, 0.3, 0.5);\n  \n  float c1 = dot(normalize(lig.xz), v)/length(v);\n  float c2 = dot(normalize(lig.xz), w)/length(w);\n  \n  col = pow(dif, 0.75)*tanh(pow(abs(f + 0.5), 1.5)) + c1*col1 + c2*col2;\n  col += 0.25*vec3(smoothstep(0.0, -0.0125, d));\n\n  col = postProcess(col);\n\n  col *= smoothstep(0.0, 16.0, iTime*iTime);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsByR1.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[972, 972, 1005, 1005, 1090], [1092, 1092, 1113, 1113, 1235], [1237, 1237, 1256, 1256, 1461], [1463, 1463, 1521, 1521, 2039], [2041, 2041, 2080, 2080, 2205], [2207, 2207, 2229, 2229, 2273], [2275, 2275, 2296, 2296, 2341], [2343, 2343, 2382, 2382, 2458], [2460, 2460, 2491, 2491, 2517], [2519, 2519, 2554, 2554, 2703], [2705, 2705, 2764, 2764, 2951], [2953, 2953, 2984, 2984, 3167], [3169, 3169, 3198, 3198, 3329], [3331, 3331, 3362, 3362, 3570], [3572, 3572, 3610, 3610, 3814], [3816, 3816, 3834, 3834, 3870], [3872, 3872, 3907, 3907, 4151], [4154, 4154, 4182, 4182, 4358], [4360, 4360, 4412, 4412, 5221]], "test": "untested"}
{"id": "3dByR1", "name": "Day 107", "author": "jeyko", "description": "potato", "tags": ["mograph", "motiongraphics"], "likes": 27, "viewed": 565, "published": 3, "date": "1586035830", "time_retrieved": "2024-07-30T21:14:50.439489", "image_code": "// Fork of \"Day 102\" by jeyko. https://shadertoy.com/view/3dfcW2\n// 2020-04-04 21:09:03\n\n// Fork of \"Day 101\" by jeyko. https://shadertoy.com/view/WslyWS\n// 2020-03-30 07:59:19\n\n// radiual chromab in this buffer\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n\tfragColor = vec4(0);\n    // Radial blur\n    float steps = 1.;\n    float scale = 0.00 + pow(dot(uvn,uvn),1.)*0.05;\n    float chromAb = pow(length(uv - 0.5),2.9)*0.2;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n        scale *= 0.97;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1.4/iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    fragColor += radial;\n    \n    //fragColor = 1. - fragColor;\n    //fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.5);\n    fragColor = max(fragColor, 0.);\n    //fragColor.b *= 1. + uv.x*0.4;\n    fragColor *= 1. - dot(uvn,uvn)*1.;\n    fragColor = 1.-exp(-fragColor*3.5);\n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor)*1.4,0.5);\n    \n    \n    float n1d = texelFetch(iChannel2,ivec2(mod(fragCoord + vec2(float(iFrame)*0.,0.),256.)),0).x*0.5;\n    vec3 n  = texelFetch(iChannel2,ivec2(mod(fragCoord + n1d*200. ,256.)),0).xyz*0.6;\n    \n    fragColor.xyz += smoothstep(1.,0.,length(fragColor.xyz))*n*0.004;\n    \n    fragColor.xyz -= smoothstep(0.,1.,length(fragColor.xyz))*n*0.4;\n    \n    fragColor = pow(abs(fragColor), vec4(0.4545 ));\n}\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// from https://necessarydisorder.wordpress.com/\nfloat ease(float p, float g) {\n    if(p < 0.){\n        return 0.;\n    } else if(p > 1.){\n    \treturn 1.;\n    } else {\n        if (p < 0.5) \n            return 0.5 * pow(2.*p, g);\n        else\n            return 1. - 0.5 * pow(2.*(1. - p), g);\n    }\n}\n\n#define iTime (iTime*0.8)\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\tvec2 suv = uv;\n    \n    uv *= 1. - dot(uv,uv)*0.05;\n    \n    \n    vec3 col = vec3(0.004,0.001,0.0);\n    col = smoothstep(0.,1.,col);\n\n    float t = mod(iTime, 3.5);\n    \n    float enva = ease(t*2., 2.);\n    float envb = ease((t - 1.)*2., 2.);\n    float envc = ease((t - 2.)*2., 2.);\n    \n    uv += sin(vec2(3,2)*iTime*0.5)*0.01;\n    //uv.xy *= rot(0.5*pi);\n    uv.xy *= rot(-pi*pow(enva, 1.)*0.5   - 0.5*envc*pi);\n    \n    uv *= 1.;\n    \n    uv.x += enva*0.2;\n    uv.x -= envb*0.4;\n    uv.x += envc*0.2;\n    \n    vec3 p = vec3(uv, 1.);\n    p /= dot(p.xy,p.xy);\n    //p.xy -= sin(enva *pi*0.5 - 0.5*envb*tau - 0.5*envc*pi - pi*0.)*tau;\n    \n    p.x -= sin(enva *pi*0.5 - 0.5*envb*tau - 0.5*envc*pi - pi*0.)*tau*0.94;\n    #define xor(a,b) a < (b) ? max(a,-(b)) : min(a,(b))\n    \n    float d = 10e8;\n    float b = 3.1 + enva*0.2 - envc*0.2;\n    \n    for(float i = 0.; i < 20.; i++){\n    \tfloat dpp = dot(p.xy,p.xy);\n        \n        //dpp = clamp(dpp, .1,25.);\n        //if(mod(i - 9., 9.) == 0.)\n        //dpp = clamp(dpp, 1.- i*0.4,1.8 );\n        dpp = clamp(dpp, 0.1,20. );\n        \n        p = (2. - i*0.05)*p/dpp;\n         \n        \n        //b *= 0.99;\n        p.xy = abs((mod(p.yx- 0.5*b, b) ) - 0.5*b);\n        \n        if(i == 2.)\n    \t\tp.x -= 1.1 - pow(enva, 0.6)*0.5 + envb*0.25 + envc*0.25;\n    \n    }\n    \n    #define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n    \n    \n    float s = 0.002;\n    \n    \n    //col += smoothstep(0.0,0.004*p.z, d  + 0.2);\n    //col += smoothstep(0.0,0.13, -d);\n    //col += smoothstep(0.0,0.01, -d + 0.);\n    \n    \n    \n\t//col += smoothstep(0.0,0.00002*iResolution.y, -length(p.xy)/p.z + s*4. );\n\t//col += smoothstep(0.0,0.00001*iResolution.y, -length(max(p.x, -p.y))/p.z + s );\n    //col += smoothstep(0.0,0.000005*iResolution.y, -abs(length(p.x)/p.z) + s ) * vec3(1.9,0.9,0.6);\n    //col += smoothstep(0.0,1.*fwidth(suv.x), -abs(length(p.x)/p.z) + s ) * vec3(1.9,0.9,0.6);\n    \n    col += smoothstep(abs(fwidth(suv.x)),0., abs(abs(p.x)/p.z) + 0.0005 ) * vec3(1.9,0.9,0.6)*0.6;\n    \n    \n    col += pow(smoothstep(0.01,0., abs(abs(p.x)/p.z) ),2.) * vec3(1.9,0.9,0.6)*0.05;\n    col += pow(smoothstep(0.05,0., abs(abs(p.x)/p.z) ),2.5) * vec3(1.9,0.9,0.6)*0.002;\n    //col += pow(smoothstep(0.1,0., abs(abs(p.x)/p.z) ),2.5) * vec3(1.9,0.9,0.6)*0.002;\n    //col += pow(smoothstep(0.2,0., abs(abs(p.x)/p.z) ),2.5) * vec3(1.9,0.9,0.6)*0.001;\n    //col += smoothstep(5.*fwidth(suv.x),0., abs(abs(p.x)/p.z) +0.0001 ) * vec3(1.9,0.9,0.6)*0.05;\n    \n    \n    float g = smoothstep(0.0,dFdx(suv.x), -length(min(p.y, p.x))/p.z + s );\n    //col += 2.*max(g*pow(abs(sin( 3.5*(uv.x + sin(uv.y*10. - uv.x*10. - t*5.))/tau)), 6.)*2.*pal(0.5,0.5,vec3(4.,.44,.04),0.7,(5. + sin( 3.5*(suv.xxx*1. + t)/tau)*1.)), 0.);\n    col += 5.*max(\n        \tg*pow(abs(sin( 3.5*(uv.x + sin(uv.y*10. - uv.x*20. - t/1.5*tau))/tau)), 6.)*2.\n        \t*pal(0.,0.5,vec3(4.,.44,.04),0.7,(5. + 1.*sin(suv.xxx*1. + t/.5*tau))), \n        0.)*vec3(0.2,1,1);\n    g = smoothstep(0.0,0.1, -length(min(p.y, p.x))/p.z + s*10. );\n    \n    col += 2.*max(\n        g*pow(abs(sin( 3.5*(uv.x + sin(uv.y*10. - uv.x*20. - t/1.5*tau))/tau)), 6.)*2.\n        *pal(0.,0.5,vec3(4.,.44,.04),0.7,(5. + 1.*sin(suv.xxx*1. + t/.5*tau))), \n    0.)*vec3(0.5,1,1)*1.;\n    g = smoothstep(0.0,dFdx(suv.x), -length(min(p.y, p.x))/p.z + s );\n    \n    \n    col += 0.02*max(\n        g, \n    0.)*vec3(0.1,0.1,0.)*1.;\n\n\t\n    \n    \n    col = pow(abs(col), vec3(1. + dot(suv*1.4,suv*1.4)*0.));\n    \n    col = max(col, 0.);\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dByR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[213, 213, 270, 270, 1715]], "test": "untested"}
{"id": "3sSyR1", "name": "bad shapes 0", "author": "KilledByAPixel", "description": "bad shapes 1", "tags": ["badshapes1"], "likes": 0, "viewed": 300, "published": 3, "date": "1586034408", "time_retrieved": "2024-07-30T21:14:51.258300", "image_code": "// ZzArt - Generation: 112-E (1574121639091)\n\nfloat audio_freq( in float f) { return texture( iChannel0, vec2(f, 0.25) ).x; }\nfloat audio_ampl( in float t) { return texture( iChannel0, vec2(t, 0.75) ).x; }\n\nconst float PI=3.141592653589793;\nvec3 SmoothHSV(vec3 c) { vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1.,0.,1.); return c.z * mix( vec3(1), rgb*rgb*(3.-2.*rgb), c.y); }\nvec4 lengthA(vec4 a)      { return vec4(length(a)); }\nvec4 asinA(vec4 a)        { return asin(clamp(a,-1.,1.)); }\nvec4 acosA(vec4 a)        { return acos(clamp(a,-1.,1.)); }\nvec4 logA(vec4 a)         { return log(abs(a)); }\nvec4 log2A(vec4 a)        { return log2(abs(a)); }\nvec4 sqrtA(vec4 a)        { return sqrt(abs(a)); }\nvec4 inversesqrtA(vec4 a) { return inversesqrt(abs(a)); }\nvec4 pow2(vec4 a)         { return a*a; }\nvec4 pow3(vec4 a)         { return a*a*a; }\n\nvoid mainImage(out vec4 a, in vec2 p)\n{\n    a=p.xyxy/iResolution.xyxy;\n    a.xywz *= vec2(2.279, 3.527).xyxy;\n    a.xywz += vec2(-4.296, -7.673).xyxy;\n    vec4 b = a;\n\n    // Generated Code - Line Count: 14\n    b.xywz *= (b).zxwz;\n    a.wzyx = cos(b+iTime).xyww;\n    a.yzxw -= exp2(a).yxwy;\n    b.xwzy = (a).wyzy;\n    b.xywz += (b).wwxz;\n    b.xwzy /= sign(b).yyyy;\n    a.xwzy /= fract(vec4(-1.035, -4.122, 0.418, -0.302)).zzyz;\n\n    a.z += audio_freq(a.x+a.w);\n    a.wyxz /= (a).xzxx;\n    a.yxzw -= log2(b).wwxx;\n    a.yzwx -= normalize(b).xywy;\n    a.zwyx += (b).wwzz;\n\n\n    //a.x = audio_freq(a.x);\n    //a.z = a.z - audio_freq(a.z);\n\n\n    // Smooth HSV by iq\n    a.x = a.x * -0.150+0.618;\n    a.y *= 0.124;\n    a.xyz = SmoothHSV(a.xyz);\n}", "image_inputs": [{"id": 34, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sSyR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 77, 77, 125], [126, 126, 157, 157, 205], [241, 241, 265, 265, 384], [385, 385, 412, 412, 438], [439, 439, 466, 466, 498], [499, 499, 526, 526, 558], [559, 559, 586, 586, 608], [609, 609, 636, 636, 659], [660, 660, 687, 687, 710], [711, 711, 738, 738, 768], [769, 769, 796, 796, 810], [811, 811, 838, 838, 854], [856, 856, 895, 895, 1598]], "test": "untested"}
{"id": "WsSczh", "name": "Voronoi graph ray marching", "author": "michael0884", "description": "A graph sorting acceleration structure designed to work efficiently with ray marching. The graph sorts an approximation of the voronoi diagram by storing the closest intersection with the bisector plane, which gives the voronoi neighbor in this direction.", "tags": ["marching", "particles", "objects"], "likes": 8, "viewed": 502, "published": 3, "date": "1586032604", "time_retrieved": "2024-07-30T21:14:52.241671", "image_code": "//Graph is in Buf A, graph traversal is in Buf B\n//You can pause the simulation by setting dt in Common to 0.\n//Change the number of particles by changing N in Common\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    fragColor = texel(ch1, pos);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define N ivec2(8,32)\n#define sN ivec2(32,2)\n#define dt 1.\n\n#define loop(x) for(int i = min(0, iFrame); i < x; i++)\n\nconst int tot_n = N.x*N.y;\n\nivec2 i2xy(ivec3 sid)\n{\n    return sN*ivec2(sid.x%N.x, sid.x/N.x) + sid.yz;\n}\n\nivec3 xy2i(ivec2 p)\n{\n    ivec2 pi = p/sN;\n    return ivec3(pi.x + pi.y*N.x, p.x%sN.x, p.y%sN.y);\n}\n\nfloat F(float d)\n{\n    return 1./(0.1*d*d+1.) - 1.*exp(-1.*d);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nconst int k = 1664525;  \n\nivec4 hash( ivec4 x )\n{\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    return ivec4(x);\n}\n\n#define link0 32\n\nconst float PHI = 0.5*(sqrt(5.) + 1.);\n\nvec2 inverseSF( vec3 p, float n ) \n{\n    float m = 1.0 - 1.0/n;\n    \n    float phi = min(atan(p.y, p.x), PI), cosTheta = p.z;\n    \n    float k  = max(2.0, floor( log(n * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))/ log(PHI+1.0)));\n    float Fk = pow(PHI, k)/sqrt(5.0);\n    vec2  F  = vec2( round(Fk), round(Fk * PHI) ); // k, k+1\n\n    vec2 ka = 2.0*F/n;\n    vec2 kb = 2.0*PI*( fract((F+1.0)*PHI) - (PHI-1.0) );    \n    \n    mat2 iB = mat2( ka.y, -ka.x, \n                    kb.y, -kb.x ) / (ka.y*kb.x - ka.x*kb.y);\n    \n    vec2 c = floor( iB * vec2(phi, cosTheta - m));\n    float d = 8.0;\n    float j = 0.0;\n    for( int s=0; s<4; s++ ) \n    {\n        vec2 uv = vec2( float(s-2*(s/2)), float(s/2) );\n        \n        float i = dot(F, uv + c); // all quantities are ingeters (can take a round() for extra safety)\n        \n        float phi = 2.0*PI*fract(i*PHI);\n        float cosTheta = m - 2.0*i/n;\n        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n        \n        vec3 q = vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta );\n        float squaredDistance = dot(q-p, q-p);\n        if (squaredDistance < d) \n        {\n            d = squaredDistance;\n            j = i;\n        }\n    }\n    return vec2( j, sqrt(d) );\n}\n\nvec4 iSF( vec3 p, float n ) \n{\n    float m = 1.0 - 1.0/n;\n    \n    float phi = min(atan(p.y, p.x), PI), cosTheta = p.z;\n    \n    float k  = max(2.0, floor( log(n * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))/ log(PHI+1.0)));\n    float Fk = pow(PHI, k)/sqrt(5.0);\n    vec2  F  = vec2( round(Fk), round(Fk * PHI) ); // k, k+1\n\n    vec2 ka = 2.0*F/n;\n    vec2 kb = 2.0*PI*( fract((F+1.0)*PHI) - (PHI-1.0) );    \n    \n    mat2 iB = mat2( ka.y, -ka.x, \n                    kb.y, -kb.x ) / (ka.y*kb.x - ka.x*kb.y);\n    \n    vec2 c = floor( iB * vec2(phi, cosTheta - m));\n    float d = 8.0;\n    float j = 0.0;\n    vec4 o;\n    for( int s=0; s<4; s++ ) \n    {\n        vec2 uv = vec2( float(s-2*(s/2)), float(s/2) );\n        \n        o[s] = dot(F, uv + c); \n    }\n    return o;\n}\n\nvec3 fibonacci_sphere(int i, int n)\n{\n    vec2 pt = vec2(2.*PI*mod(float(i)/PHI, 1.), acos(1. - float(2*i+1)/float(n)));\n    return vec3(cos(pt.x)*sin(pt.y), sin(pt.x)*sin(pt.y), cos(pt.y)); \n}\n\n    \nstruct object\n{\n    vec3 X;\n    vec4 q;\n    vec3 P;\n    vec3 L;\n    int type;\n    float m;\n};\n\nvec3 qtransform(vec4 q, vec3 v)\n{ \n\treturn v + 2.0*cross(cross(v, q.xyz) + q.w*v, q.xyz);\n} \n\n//intersection with the bisector plane\nfloat rayBisectDist(vec3 p, vec3 d, vec3 a, vec3 b)\n{\n    vec3 n = b - a;\n    float D = length(n);\n    float cosnd = dot(n, d)/D; //ray plane normal angle cosine\n    float l = D*.5 - dot(p - a, n)/D;\n    float t = l/cosnd; //ray parameter\n    return (cosnd>0.)?t:1e10;\n}\n\nfloat dirBisectDist(vec3 d, vec3 a, vec3 b)\n{\n    float cosnd = dot(normalize(b - a), d); //ray plane normal angle cosine\n    return (cosnd>0.)?(distance(b,a)*.5)/cosnd:1e10;\n}", "buffer_a_code": "//particle and particle neighbor directional graph buffer \n\nobject obj; vec4 lnk; \n\nvec4 d; int ID; float avgR;\n\nobject getObject(int id)\n{\n    object o;\n    vec4 p = texel(ch0, i2xy(ivec3(id, 0, 0)));\n    o.X = p.xyz; o.type = int(p.w);\n    o.q = texel(ch0, i2xy(ivec3(id, 1, 0)));\n    p = texel(ch0, i2xy(ivec3(id, 2, 0)));\n    o.P = p.xyz;\n    o.m = p.w;\n    o.L = texel(ch0, i2xy(ivec3(id, 3, 0))).xyz;\n    return o;\n}\n\nvec4 getParticlePos(int id);\n\nvec4 saveObject(int i)\n{\n    switch(i)\n    {\n    case 0:  \n        return vec4(obj.X, obj.type);\n    case 1:\n        return obj.q;\n    case 2:\n        return vec4(obj.P, obj.m);\n    case 3:\n        return vec4(obj.L, 0.);\n    }\n}\n\n \nfloat dist2p(vec3 p, int id);\nvoid sort(int idtemp, int R);\nvoid sortlinks(int id, int R, int R0);\nvoid sortneighbors(int id, int R);\nvoid sortrandom(int id, int R);\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(floor(pos));\n    if(any(greaterThan(p, sN*N-1))) discard;\n    \n    ivec3 sid = xy2i(p); ID = sid.x;\n    obj = getObject(ID);\n   \tif(sid.z == 0) //object computation\n    {    \n        if(sid.y > 3) discard;\n        \n        //compute the force and the torque\n        //TODO\n        vec3 F = -0.0002*obj.X;\n\n        obj.P += F*dt;\n        obj.X += obj.P*dt/obj.m;\n        \n        if(iFrame<1) //initial conditions\n        {\n            obj.X = 2.*(hash33(pos.xyx + pos.yyx*4.5743) - 0.5);\n            obj.P = 0.01*2.*(hash33(pos.yxy + pos.xxy*PI) - 0.5);\n            obj.L = vec3(0.);\n            obj.q = vec4(0.);\n            obj.type = 0;\n            obj.m = 1.;\n        } \n        \n        U = saveObject(sid.y);\n    }\n    else //graph computation\n    {\n        d = vec4(1e6);\n        lnk = vec4(-1);\n       \n        sortlinks(ID, sid.y, sid.y);\n        \n        sortneighbors(ID, sid.y);\n        \n        sortrandom(sid.x, sid.y);\n        \n        U = lnk;\n    }\n}\n\nvec4 getParticlePos(int id)\n{ \n    return texel(ch0, i2xy(ivec3(id, 0, 0)));\n}\n\nfloat dist2p(vec3 p, int id)\n{\n    return distance(getParticlePos(id).xyz,p);\n}\n\nbool iscoincidence(int id)\n{\n    bool c = (id == ID) || (id < 0) || any(equal(lnk,vec4(id)));\n    return c;\n}\n\nvoid sort(int idtemp, int R) //sort closest objects in N directions\n{\n    if(iscoincidence(idtemp)) return; //particle already sorted\n    vec4 px = getParticlePos(idtemp);\n    vec3 dir = fibonacci_sphere(R, link0);\n    float t = dirBisectDist(dir, obj.X, px.xyz);\n    //insertion sort\n    if(d.x > t)\n    {\n        d = vec4(t, d.xyz);\n        lnk = vec4(idtemp, lnk.xyz);\n    }\n    else if(d.y > t && t > d.x)\n    {\n        d.yzw = vec3(t, d.yz);\n        lnk.yzw = vec3(idtemp, lnk.yz);\n    }\n    else if(d.z > t && t > d.y)\n    {\n        d.zw = vec2(t, d.z);\n        lnk.zw = vec2(idtemp, lnk.z);\n    }\n    else if(d.w > t && t > d.z)\n    {\n        d.w = t;\n        lnk.w = float(idtemp);\n    }\n}\n\nvoid sortlinks(int id, int R, int R0)\n{\n    vec4 nb = texel(ch0, i2xy(ivec3(id, R, 1)));\n    for(int i = min(0, iFrame); i<4; i++) \n        sort(int(nb[i]), R0);\n}\n\nvoid sortneighbors(int id, int R)\n{\n    vec3 dir = fibonacci_sphere(R, link0);\n    vec4 d4 = iSF(dir, float(link0));\n    for(int i = min(0, iFrame); i < 4; i++)\n    {\n         int dir = int(d4[i]);\n         vec4 nb = texel(ch0, i2xy(ivec3(id, dir, 1)));\n    \t for(int j = min(0, iFrame); j < 4; j++) \n         {\n         \tsortlinks(int(nb[j]), (16*iFrame+4*j+i)%link0, R); \n         }\n    }  \n}\n\nvoid sortrandom(int id, int R)\n{\n    for(int i = min(0, iFrame); i<2; i++) sort((12*iFrame+ID+i)%tot_n, R);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//prev closest particle buffer\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat bisectDist(vec3 p, vec3 a, vec3 b)\n{\n    return distance(a,b)*0.5 - dot(p - a, normalize(b - a));\n}\n\nvoid check_neighbors(vec3 p, inout vec3 cxy, inout int cid)\n{\n    int dir = int(inverseSF(normalize(p - cxy), float(link0)).x);\n    float t = distance(p, cxy);\n    vec4 nb = texel(ch0, i2xy(ivec3(cid, dir, 1)));\n    for(int i = min(0,iFrame); i<4; i++)\n    {\n        vec3 X = texel(ch0, i2xy(ivec3(nb[i], 0, 0))).xyz;\n        float tt = distance(p, X);\n        if(tt < t)\n        {\n            t = tt;\n            cxy = X;\n            cid = int(nb[i]);\n        } \n    }\n}\n\n//find closest voronoi cell \nvoid findClosest(vec3 p, inout vec4 cobj, int mit)\n{    \n    int cid = int(cobj.w);\n    vec3 cxy = cobj.xyz;\n\n    for(int s = min(0,iFrame); s < mit; s++)\n    {\n    \tint pid = cid;\n        check_neighbors(p, cxy, cid);          \n        if(pid == cid) break;\n    }\n   \n    cobj = vec4(cxy,cid);\n}\n\n#define maxd 4.\n#define mind 0.003\n#define maxs 128\n\nfloat map(vec3 p, inout vec4 cobj)\n{\n    findClosest(p, cobj, 32);\n    return sdSphere(p - cobj.xyz, 0.06);\n}\n\nvec3 col(vec3 p, in vec4 cobj)\n{\n    //voronoi neighbors projected on the sphere surface\n    int cid = -1;\n    vec3 D = normalize(p - cobj.xyz);\n    int dir = int(inverseSF(D, float(link0)).x);\n    float t = 1e10;\n    vec4 nb = texel(ch0, i2xy(ivec3(cobj.w, dir, 1)));\n    for(int i = 0; i<4; i++)\n    {\n        vec3 X = texel(ch0, i2xy(ivec3(nb[i], 0, 0))).xyz;\n        float tt = dirBisectDist(D, cobj.xyz, X);\n        if(tt < t)\n        {\n            t = tt;\n            cid = int(nb[i]);\n        } \n    }\n    return 0.5 + 0.5 * sin(vec3(1,2,3)*float(cid));\n}\n\n//voronoi diagram ray marching\nvec4 rayMarch(vec3 p, vec3 d, inout vec4 cobj)\n{\n    if(cobj.w < 0.)\n    {\n        cobj = vec4(texel(ch0, i2xy(ivec3(0, 0, 0))).xyz, 0.);\n    }\n    \n    float td = 0.; \n    for(int i = 0; i < maxs; i++)\n    {\n        //march\n        float DE = map(p, cobj);\n        \n        p += DE*d;\n        td += DE;\n        \n        //outide of the scene\n        if(td > maxd) return vec4(p, -1);\n        //has hit the surface\n        if(DE < mind*td) break;\n    }\n    return vec4(p, cobj.w);\n}\n\n#define FOV 2.\nmat3 getRot(vec2 a)\n{\n    \n   mat3 theta_rot = mat3(1, 0, 0,\n                         0, cos(a.y), sin(a.y),\n                         0, -sin(a.y), cos(a.y)); \n        \n   mat3 phi_rot = mat3(cos(a.x), sin(a.x), 0,\n        \t\t       -sin(a.x), cos(a.x), 0,\n        \t\t        0, 0, 1); \n   return transpose(phi_rot*theta_rot);\n}\n\nvec3 getRay(vec2 angles, vec2 pos)\n{\n    mat3 camera = getRot(angles);\n    return normalize(transpose(camera)*vec3(FOV*pos.x, FOV*pos.y, 1.));\n}\n\n#define ldir vec3(1,0,0)\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = (pos - size*0.5)/size.y;\n    vec2 angles = (iMouse.z>0.)?(iMouse.xy/iResolution.xy)*vec2(2.*PI, PI):vec2(0.1*iTime, PI*0.5);\n    \n    vec3 d = getRay(angles, uv);\n    vec3 p = 0.*texel(ch0, i2xy(ivec3(6, 0, 0))).xyz-2.*getRay(angles, vec2(0.));\n    vec4 prev = pixel(ch1, pos);\n    if(iFrame < 1) prev.w = 0.;\n    vec4 cobj = vec4(texel(ch0, i2xy(ivec3(prev.w, 0, 0))).xyz, prev.w);\n    findClosest(p, cobj, 16);\n    float closest = cobj.w;\n    vec4 rm = rayMarch(p, d, cobj);\n    if(rm.w >= 0.) //hit object\n    {\n        vec3 pp = texel(ch0, i2xy(ivec3(rm.w, 0, 0))).xyz;\n    \tvec3 n = 0.2*normalize(rm.xyz - pp) + 0.8;\n        vec3 c = col(rm.xyz, cobj);\n        U.xyz = c*vec3(clamp(dot(ldir, n),0.,1.));\n    }\n    else //background\n    {\n        U = texture(iChannel2,  d.yzx);\n    }\n    U.w = closest;\n}", "buffer_b_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsSczh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[168, 168, 219, 219, 254]], "test": "untested"}
{"id": "3dSyzh", "name": "Heritable xenobiotic (edit 2)", "author": "jarble", "description": "Here's another edit of the [url=https://www.shadertoy.com/view/tdlyD2]\"Heritable xenobiotic\"[/url] shader. I only modified the \"sph\" function to change the geometry.", "tags": ["raymarching"], "likes": 1, "viewed": 292, "published": 3, "date": "1586028068", "time_retrieved": "2024-07-30T21:14:53.124311", "image_code": "//-------------------------------------------------------------------\n// Trying out ShaderToy and trying to get to grips with ray marching.\n// Inspired by the amazing creations of Evvvvil, Nusan and Shane\n//-------------------------------------------------------------------\n\n#define MD 30.\t\t// max distance\n#define SD 0.0001    // surface distance\n#define MS 250      // max number of steps to march\n#define EPS 0.0001   // distance used for sampling the gradient\n\nfloat time;\n\n// always handy to have PI available\nconst float PI = acos(-1.);\nconst float TWOPI = 2.*PI;\n\n// fog color.\nconst vec3 fog = vec3(.05,.25, .05);\n\n// always need some glow!\nfloat glw = 0.;\n\n// sphere SDF\nfloat sph(vec3 p, float r){return length(p)-r/sin(p.y);}\n\n// min and max which preserve material\nvec2 mmin(vec2 a, vec2 b) {return a.x < b.x ? a:b;}\nvec2 mmax(vec2 a, vec2 b) {return a.x > b.x ? a:b;}\n\n\n// 2d rotation\nvoid rot(inout vec2 p, float a) {\n    float c=cos(a), s=sin(a);\n    p *= mat2(c,-s,s,c);\n}\n\n// I was going to do something complicated here,\n// but ended up doing a sphere!\nvec2 prim(vec3 p) {\n    return vec2(sph(p, .5), 5);\n}\n\n// the SDF for the scene\nvec2 map(vec3 p) {\n    \n    // wiggle x\n    p.x += sin(p.z + time*.2)*.5;\n    // spiral\n    rot(p.xy, sin(p.z / 3.));\n    // scroll along z\n    p.z -= time/3.;\n    \n    // repeat everything\n    vec3 mp;\n    mp.x = mod(p.x, 2.3)-1.15;\n    mp.y = mod(p.y, 2.3)-1.15;\n    mp.z = mod(p.z,.6)-.3;\n    \n    // fractal (ish)\n    vec4 ap = vec4(mp,1.);\n    // big purple sphere\n    vec2 a=prim(mp);\n    a.x *= .6;\n    // smaller black spheres\n    int n=4;\n    for(int i=1; i<=n; ++i) {\n    \tap *= 2.5; // scale\n        ap.xyz = abs(ap.xyz)-vec3(.8); // symmetry\n        rot(ap.xy, ap.z*.1 + time*.5); // movement\n        vec2 b = prim(ap.xyz); // sphere\n        b.x /= ap.w; // correct for scaling\n        b.x *= .6;   // patch up the SDF\n        b.y= 1.;     // paint it black\n        a=mmin(a, b);\n        \n    }\n    \n    // Sparkles. Lots of them.\n    rot(p.xy, time*.3);\n    vec2 b = vec2(length(cos(p*1.+vec3(1.5+p.z*.05*sin(time),1.7+sin(time)*.2,time*2.)))-.001 ,6.);\n    glw += .1/(.1*b.x*b.x*10000.);\n    b.x *= .6;\n    \n    // final distance\n    vec2 d=mmin(a,b);\n    return d;\n}\n\n// determine the normal at point p by sampling the gradient of the SDF\nvec3 normal(vec3 p) {\n \tvec2 off = vec2(EPS, 0.);\n    return normalize(map(p).x - vec3(map(p-off.xyy).x,map(p-off.yxy).x,map(p-off.yyx).x));\n}\n\n//-------------------------------------------------------------\n// lighting and colour,\n// heavily based on Evvvvil's Micro Lighting Engine Broski (TM)\n//-------------------------------------------------------------\n\n// shortcuts for calculating fake ambient occlusion and subsurface scattering\n#define aoc(d) clamp(map(p + n * d).x/d, 0., 1.)\n#define sss(d) smoothstep(0.,1.,map(p+ld*d).x/d)\n\nvec3 surface(vec3 ro, vec3 rd, vec2 hit) {\n\tfloat d=hit.x;         // distance from ray origin\n    float m = hit.y;       // materialID\n    \n    // albedo, or base color, based on material ID\t\n    vec3 al = m < 5. ? vec3(0) : \n    \t\tm > 5. ? vec3(1) :\n    \t\tvec3(.1,.1,.4);\n    \n    vec3 p = ro + rd * d;  // the point in space\n    vec3 n = normal(p);    // normal of the SDF at point p\n    \n    vec3 ld = normalize(vec3(-1));     // light direction\n    float diff = max(0., dot(n, -ld)); // diffuse illumination\n    \n    vec3 lr = reflect(ld, n);          // reflected light ray\n    float spec = pow(max(0., dot(lr,-rd)),32.); // specular component\n \n    float frz = pow(max(0.1, 1. - dot(n,-rd)),4.)*.5; // freznel)\n\t\n    float ao = aoc(.1); // fake AO\n    float ss = sss(1.); // fake subsurface scattering\n    \n    vec3 col =  al * ao * (diff + ss) + spec; // combine it all together\n    col = mix(col, fog, frz);         // fog the edges\n    \n    return col; // the final color\n}\n\n// ray marching loop\nvec3 march(vec3 ro, vec3 rd) {\n\tfloat dd=0.1;\t\t// start with a slight z offset\n    vec3 col=vec3(0);   // no color initially\n    vec3 p=ro + rd * dd;// current point\n    \n    for(int i=0; i<MS; ++i) {  // start marching\n     \tvec2 d = map(p);  // distance to SDF\n        \n        if(d.x < SD) { // close to a surface\n            // get the color of the surface\n            col += d.y > 0. ? surface(ro, rd, vec2(dd, d.y)) : vec3(0.);\n            break; // we're done\n        }\n        \n        if(dd > MD) { // we've reached the max draw distance,\n            dd = MD;\n            break;    // and we're done\n        }\n        \n        dd += d.x;     // track the total distance\n        p += rd * d.x; // and update the current position\n    }\n    \n    // blend in some distance-based fog and return\n    return mix(fog * pow(max(0., dot(rd, vec3(0,0,-1))),20.), col, exp(-0.003*dd*dd*dd));\n}\n\n\n// given the ray origin, lookat point and uv's, calculate the ray direction\nvec3 raydir(vec3 ro, vec3 la, vec2 uv) {\n    // x,y and z axes\n    vec3 cz = normalize(la-ro);\n    vec3 cx = normalize(cross(cz,vec3(0,1,0)));\n    vec3 cy = normalize(cross(cx,cz));\n    // project and normalize\n    return normalize(cx*uv.x + cy*uv.y + cz);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    // make sure that the pixels are square\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    // get rid of some artifacts\n    time = mod(iTime, 62.39);\n    \n    // setup the ray\n    vec3 ro = vec3(0,0,1);\n    vec3 rd = raydir(ro, vec3(0)-ro, uv);\n    \n    // march\n    vec3 col = march(ro, rd);\n\n    col += glw;\n    // exposure\n    col = vec3(1) - exp(-col * 1.1);\n    // gamma\n    col = pow(col, vec3(1./2.2));\n    // final color\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dSyzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[667, 681, 708, 708, 737], [739, 778, 805, 805, 829], [830, 830, 857, 857, 881], [884, 899, 932, 932, 989], [991, 1072, 1091, 1091, 1125], [1127, 1152, 1170, 1191, 2233], [2235, 2306, 2327, 2327, 2448], [2844, 2844, 2886, 2886, 3827], [3829, 3850, 3880, 3880, 4740], [4743, 4819, 4859, 4881, 5077], [5080, 5080, 5137, 5187, 5712]], "test": "untested"}
{"id": "3sScRh", "name": "Heritable xenobiotic (edit)", "author": "jarble", "description": "I edited the \"prim\" function in the [url=https://www.shadertoy.com/view/tdlyD2]\"Heritable xenobiotic\"[/url] shader. The geometry seems much more complex now.", "tags": ["raymarching"], "likes": 1, "viewed": 283, "published": 3, "date": "1586025301", "time_retrieved": "2024-07-30T21:14:54.026897", "image_code": "//-------------------------------------------------------------------\n// Trying out ShaderToy and trying to get to grips with ray marching.\n// Inspired by the amazing creations of Evvvvil, Nusan and Shane\n//-------------------------------------------------------------------\n\n#define MD 30.\t\t// max distance\n#define SD 0.0001    // surface distance\n#define MS 250      // max number of steps to march\n#define EPS 0.0001   // distance used for sampling the gradient\n\nfloat time;\n\n// always handy to have PI available\nconst float PI = acos(-1.);\nconst float TWOPI = 2.*PI;\n\n// fog color.\nconst vec3 fog = vec3(.05,.25, .05);\n\n// always need some glow!\nfloat glw = 0.;\n\n// sphere SDF\nfloat sph(vec3 p, float r){return length(p)-r;}\n\n// min and max which preserve material\nvec2 mmin(vec2 a, vec2 b) {return a.x < b.x ? a:b;}\nvec2 mmax(vec2 a, vec2 b) {return a.x > b.x ? a:b;}\n\n\n// 2d rotation\nvoid rot(inout vec2 p, float a) {\n    float c=cos(a), s=sin(a);\n    p *= mat2(c,-s,s,c);\n}\n\n// I was going to do something complicated here,\n// but ended up doing a sphere!\nvec2 prim(vec3 p) {\n    return vec2(sph(p, .5)*(1.0+sin(p.x)), 5)*10.0;\n}\n\n// the SDF for the scene\nvec2 map(vec3 p) {\n    \n    // wiggle x\n    p.x += sin(p.z + time*.2)*.5;\n    // spiral\n    rot(p.xy, sin(p.z / 3.));\n    // scroll along z\n    p.z -= time/3.;\n    \n    // repeat everything\n    vec3 mp;\n    mp.x = mod(p.x, 2.3)-1.15;\n    mp.y = mod(p.y, 2.3)-1.15;\n    mp.z = mod(p.z,.6)-.3;\n    \n    // fractal (ish)\n    vec4 ap = vec4(mp,1.);\n    // big purple sphere\n    vec2 a=prim(mp);\n    a.x *= .6;\n    // smaller black spheres\n    int n=4;\n    for(int i=1; i<=n; ++i) {\n    \tap *= 2.5; // scale\n        ap.xyz = abs(ap.xyz)-vec3(.8); // symmetry\n        rot(ap.xy, ap.z*.1 + time*.5); // movement\n        vec2 b = prim(ap.xyz); // sphere\n        b.x /= ap.w; // correct for scaling\n        b.x *= .6;   // patch up the SDF\n        b.y= 1.;     // paint it black\n        a=mmin(a, b);\n        \n    }\n    \n    // Sparkles. Lots of them.\n    rot(p.xy, time*.3);\n    vec2 b = vec2(length(cos(p*1.+vec3(1.5+p.z*.05*sin(time),1.7+sin(time)*.2,time*2.)))-.001 ,6.);\n    glw += .1/(.1*b.x*b.x*10000.);\n    b.x *= .6;\n    \n    // final distance\n    vec2 d=mmin(a,b);\n    return d;\n}\n\n// determine the normal at point p by sampling the gradient of the SDF\nvec3 normal(vec3 p) {\n \tvec2 off = vec2(EPS, 0.);\n    return normalize(map(p).x - vec3(map(p-off.xyy).x,map(p-off.yxy).x,map(p-off.yyx).x));\n}\n\n//-------------------------------------------------------------\n// lighting and colour,\n// heavily based on Evvvvil's Micro Lighting Engine Broski (TM)\n//-------------------------------------------------------------\n\n// shortcuts for calculating fake ambient occlusion and subsurface scattering\n#define aoc(d) clamp(map(p + n * d).x/d, 0., 1.)\n#define sss(d) smoothstep(0.,1.,map(p+ld*d).x/d)\n\nvec3 surface(vec3 ro, vec3 rd, vec2 hit) {\n\tfloat d=hit.x;         // distance from ray origin\n    float m = hit.y;       // materialID\n    \n    // albedo, or base color, based on material ID\t\n    vec3 al = m < 5. ? vec3(0) : \n    \t\tm > 5. ? vec3(1) :\n    \t\tvec3(.1,.1,.4);\n    \n    vec3 p = ro + rd * d;  // the point in space\n    vec3 n = normal(p);    // normal of the SDF at point p\n    \n    vec3 ld = normalize(vec3(-1));     // light direction\n    float diff = max(0., dot(n, -ld)); // diffuse illumination\n    \n    vec3 lr = reflect(ld, n);          // reflected light ray\n    float spec = pow(max(0., dot(lr,-rd)),32.); // specular component\n \n    float frz = pow(max(0.1, 1. - dot(n,-rd)),4.)*.5; // freznel)\n\t\n    float ao = aoc(.1); // fake AO\n    float ss = sss(1.); // fake subsurface scattering\n    \n    vec3 col =  al * ao * (diff + ss) + spec; // combine it all together\n    col = mix(col, fog, frz);         // fog the edges\n    \n    return col; // the final color\n}\n\n// ray marching loop\nvec3 march(vec3 ro, vec3 rd) {\n\tfloat dd=0.1;\t\t// start with a slight z offset\n    vec3 col=vec3(0);   // no color initially\n    vec3 p=ro + rd * dd;// current point\n    \n    for(int i=0; i<MS; ++i) {  // start marching\n     \tvec2 d = map(p);  // distance to SDF\n        \n        if(d.x < SD) { // close to a surface\n            // get the color of the surface\n            col += d.y > 0. ? surface(ro, rd, vec2(dd, d.y)) : vec3(0.);\n            break; // we're done\n        }\n        \n        if(dd > MD) { // we've reached the max draw distance,\n            dd = MD;\n            break;    // and we're done\n        }\n        \n        dd += d.x;     // track the total distance\n        p += rd * d.x; // and update the current position\n    }\n    \n    // blend in some distance-based fog and return\n    return mix(fog * pow(max(0., dot(rd, vec3(0,0,-1))),20.), col, exp(-0.003*dd*dd*dd));\n}\n\n\n// given the ray origin, lookat point and uv's, calculate the ray direction\nvec3 raydir(vec3 ro, vec3 la, vec2 uv) {\n    // x,y and z axes\n    vec3 cz = normalize(la-ro);\n    vec3 cx = normalize(cross(cz,vec3(0,1,0)));\n    vec3 cy = normalize(cross(cx,cz));\n    // project and normalize\n    return normalize(cx*uv.x + cy*uv.y + cz);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    // make sure that the pixels are square\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    // get rid of some artifacts\n    time = mod(iTime, 62.39);\n    \n    // setup the ray\n    vec3 ro = vec3(0,0,1);\n    vec3 rd = raydir(ro, vec3(0)-ro, uv);\n    \n    // march\n    vec3 col = march(ro, rd);\n\n    col += glw;\n    // exposure\n    col = vec3(1) - exp(-col * 1.1);\n    // gamma\n    col = pow(col, vec3(1./2.2));\n    // final color\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sScRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[667, 681, 708, 708, 728], [730, 769, 796, 796, 820], [821, 821, 848, 848, 872], [875, 890, 923, 923, 980], [982, 1063, 1082, 1082, 1136], [1138, 1163, 1181, 1202, 2244], [2246, 2317, 2338, 2338, 2459], [2855, 2855, 2897, 2897, 3838], [3840, 3861, 3891, 3891, 4751], [4754, 4830, 4870, 4892, 5088], [5091, 5091, 5148, 5198, 5723]], "test": "untested"}
{"id": "wd2yzz", "name": "Something go wrongv3", "author": "Arseny", "description": "yes", "tags": ["raymarching"], "likes": 0, "viewed": 358, "published": 3, "date": "1586019726", "time_retrieved": "2024-07-30T21:14:54.799831", "image_code": "// template copied form inigo quilez - iq/2019\n\n//   Step 1: https://www.shadertoy.com/view/ws3GD2\n\n\n#define AA 2\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere( in vec3 p, in float r )\n{\n    return length(p)-r;\n}\n\nfloat sdEgg(in vec3 p, in float r, in float h){\n    float x = p.y;\n   \tfloat y = length(p.xz);\n    x = pow(x, 0.8);\n    x /= h;\n    float f = sqrt(1. - (x * 2. - 1.) * (x * 2. - 1.));\n    return y - f;\n}\n\n//float sdTransOct(in vec3 p, in vec3\n\nvec4 map( in vec3 p, float time )\n{\n    //float d = sdSphere( p, 0.1 );\n    float d = sdEgg( p, 0.1, 0.1 );\n    d = min(d, length(p.xy));\n    return vec4( d, p );\n}\n\n#define ZERO min(iFrame,0)\n\nvec3 calcNormal( in vec3 pos, in float time )\n{\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e,time).x;\n    }\n    return normalize(n);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in float time )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos+h*nor, time ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float k, in float time )\n{\n    float res = 1.0;\n    \n    float tmax = 2.0;\n    float t    = 0.001;\n    for( int i=0; i<64; i++ )\n    {\n        float h = map( ro + rd*t, time ).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.012, 0.2 );\n        if( res<0.001 || t>tmax ) break;\n    }\n    \n    return clamp( res, 0.0, 1.0 );\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd, in float time )\n{\n    vec4 res = vec4(-1.0);\n    \n    float t = 0.001;\n    float tmax = 10.0;\n    for( int i=0; i<128 && t<tmax; i++ )\n    {\n        vec4 h = map(ro+t*rd,time);\n        if( h.x<0.0001 ) { res=vec4(t,h.yzw); break; }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float time = iTime;\n        #endif\n\n\t    // camera\t\n        float an = 6.2831*time/30.0;\n        vec3 ta = vec3( 0.0, 0.0, 0.0 );\n        vec3 ro = ta + vec3( 0.5*cos(an), 0.5, 0.5*sin(an) );\n        \n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        \n        // ray direction\n        float fl = 2.0;\n        vec3 rd = ca * normalize( vec3(p,fl) );\n\n        // background\n        vec3 col = vec3(1.0+rd.y)*0.03;\n        \n        // raymarch geometry\n        vec4 tuvw = intersect( ro, rd, time );\n        if( tuvw.x>0.0 )\n        {\n            // shading/lighting\t\n            vec3 pos = ro + tuvw.x*rd;\n            vec3 nor = calcNormal(pos, time);\n                        \n            col = 0.5 + 0.5*nor;\n        }\n        \n        \n        // gamma        \n\t    tot += pow(col,vec3(0.45) );\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2yzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[115, 115, 156, 156, 249], [251, 251, 292, 292, 318], [320, 320, 367, 367, 523], [564, 564, 599, 635, 728], [758, 758, 805, 805, 1014], [1016, 1016, 1073, 1073, 1338], [1340, 1340, 1415, 1415, 1726], [1728, 1728, 1785, 1785, 2046], [2048, 2048, 2100, 2100, 2277]], "test": "untested"}
{"id": "tsjcRz", "name": "vodka runner copperworld", "author": "flockaroo", "description": "lada on weird copper planet...\nASDW for driving +/- for zoom\n...also try other worlds (uncomment in Common-Tab)", "tags": ["simulation", "galaxy", "universe", "car"], "likes": 50, "viewed": 1410, "published": 3, "date": "1586017998", "time_retrieved": "2024-07-30T21:14:56.114317", "image_code": "// created by florian berger (flockaroo) - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// vodka runner (modification of \"whiskey runner\" with lada niva on weird planet)\n\n// ASDW for driving +/- for zoom\n\n\n//uncomment this if you want proper materials and lighting...\n//...might not compile well in windows (...the actual reason for the weird copper style)\n\n//#define ENABLE_MATERIALS \n\n\n#ifdef ENABLE_MATERIALS \n#define SHADOW\n#endif\n#define SCRATCHES\n#define RENDER_GLASS\n//#define RENDERED_REFECTIONS\n//#define RENDER_BBOX\n#define Res  (iResolution.xy)\n\n#define RandTex iChannel0\n#define PhysTex iChannel1\n\n#ifdef SHADEROO\n#include Include_A.glsl\n#endif\nvec4 myRandInterpol(vec2 uv)\n{\n    //#define COARSE_TERRAIN\n    #ifdef COARSE_TERRAIN\n    return textureLod(RandTex,uv,0.);\n    #endif\n    uv=fract(uv);\n    ivec2 c0 = ivec2(fract(uv        )*256.);\n    ivec2 c1 = ivec2(fract(uv+1./256.)*256.);\n    vec2  f = fract(uv*256.);\n    vec4 c00=texelFetch(RandTex,ivec2(c0.x,c0.y),0);\n    vec4 c10=texelFetch(RandTex,ivec2(c1.x,c0.y),0);\n    vec4 c01=texelFetch(RandTex,ivec2(c0.x,c1.y),0);\n    vec4 c11=texelFetch(RandTex,ivec2(c1.x,c1.y),0);\n    //f=mix(f,.5-.5*cos(f*PI2*.5),.5);\n    f=.5-.5*cos(f*PI2*.5);\n    return mix(mix(c00,c10,f.x),mix(c01,c11,f.x),f.y);\n}\n\nconst vec3 terrbbpos=vec3(0,.0,.0);\n#ifdef CHAIN_WORLD\nconst vec3 terrbbsize=vec3(260.,260.,60.)*2.+50.;\n#else\nconst vec3 terrbbsize=vec3(0);\n#endif\n\nfloat distTerr(vec3 p)\n{\n    vec3 p2=p*.0001;\n    vec4 noise = vec4(0);\n    float sc;\n    sc=1.; \n    for(int i=0;i<3;i++)\n    {\n        noise += (myRandInterpol(p2.xy*sc)-.5)/sc;\n        noise += (myRandInterpol(p2.yz*sc)-.5)/sc;\n        noise += (myRandInterpol(p2.zx*sc)-.5)/sc;\n        sc*=2.;\n    }\n    noise += abs(myRandInterpol(p2.xy*sc*5.)-.5)/sc/5.;\n    noise += abs(myRandInterpol(p2.yz*sc*5.)-.5)/sc/5.;\n    noise += abs(myRandInterpol(p2.zx*sc*5.)-.5)/sc/5.;\n    \n    #if   defined(CHAIN_WORLD)\n    return distChainCircle(p+noise.xyz*10.,200., 6, 60.,20.,20.);\n    #elif defined(TORUS2_WORLD)\n    return min(distTorus(p+noise.xyz*10.,100.,40.),distTorus((p-vec3(100,0,0)).zxy+noise.xyz*10.,100.,40.));\n    #elif defined(TORUS_WORLD)\n    return distTorus(p+noise.xyz*10.,100.,40.);\n    #elif defined(HOLLOW_SPHERE_WORLD)\n    return -length(p+noise.xyz*10.)+100.;\n    #elif defined(SPHERE_WORLD)\n    return length(p+noise.xyz*10.)-60.;\n    #elif defined(PLANE_WORLD)\n    return dot(p+noise.xyz*10.,normalize(vec3(1,.5,.7)));\n    #elif defined(HOLLOW_TORUS)\n    return -distTorus(p+noise.xyz*10.,100.,40.);\n    #else\n    return p.z+noise.x;\n    #endif\n}\n\n/// my own version of a looped getGrad()\nvec3 getGradTerr4loop(vec3 p,float delta)\n{\n    vec4 d=vec4(0,0,0,1); \n    vec3 s=vec3(0);\n    // use a loop here keep compiler from inlining this in win (thanks iq for the hint!)\n    for(int i=min(0,iFrame);i<4;i++)\n    {\n      \ts+=(d.xyz-d.w)*distTerr(p+d.xyz*delta);\n        d=d.wxyz;\n    }\n    return s/delta;\n}\n\n// straight fwd gradient - windows dont like this... wtf...\nvec3 getGradTerr0(vec3 p,float delta)\n{\n    vec3 d=vec3(delta*.5,0,0);\n    return vec3(\n        distTerr(p+d.xyz)-distTerr(p-d.xyz),\n        distTerr(p+d.zxy)-distTerr(p-d.zxy),\n        distTerr(p+d.yzx)-distTerr(p-d.yzx)\n        )/delta;\n}\n\n// cheap tetrahedral gradient\nvec3 getGradTerrTetr(vec3 p,float delta)\n{\n    vec3 g=vec3(0);\n    for(int i=min(0,iFrame);i<4;i++) { vec3 v=vec3((i&1)*2-1,(i/2)*2-1,1); vec3 d=v.xxz*v.zyy;  g+=d*distTerr(p+d*delta*.289); }\n    return g/(delta*1.732);\n}\n\n// full straight fwd grad as loop\nvec3 getGradTerr6loop(vec3 p,float delta)\n{\n    vec3 g=vec3(0);\n    vec3 d=vec3(delta*.5,0,0);\n    for(int i=min(0,iFrame);i<6;i++) { g+=d*distTerr(p+d); d=-d.zxy; }\n    return g/(.5*delta*delta);\n}\n\nvec3 getGradTerr(vec3 p,float delta)\n{\n    return getGradTerr6loop(p,delta);\n}\n\n// transform to car coords\nvec3 carTrafo(vec3 p, float translate)\n{\n#ifdef USE_SIMDATA\n    vec4 q=texelFetch(PhysTex,ivec2(3,0),0);\n    vec3 pos=texelFetch(PhysTex,ivec2(0,0),0).xyz;\n    ///offs.z=-hTerr(-offs);\n    //q=multQuat(getTiltQuat(-offs),q);\n    return transformVecByQuat(p-translate*pos,inverseQuat(q));\n#else\n    return p;\n#endif\n}\n\nvec3 carTrafo(vec3 p)\n{\n    return carTrafo(p,1.0);\n}\n\n// transform to world coords\nvec3 carTrafoInv(vec3 p, float translate)\n{\n#ifdef USE_SIMDATA\n    vec4 q=texelFetch(PhysTex,ivec2(3,0),0);\n    vec3 pos=texelFetch(PhysTex,ivec2(0,0),0).xyz;\n    //offs.z=-hTerr(-offs);\n    //q=multQuat(getTiltQuat(-offs),q);\n    return transformVecByQuat(p,q)+pos*translate;\n#else\n    return p;\n#endif\n}\n\nvec3 camTrafoInv(vec3 p, float translate)\n{\n#ifdef USE_SIMDATA\n    vec4 q=texelFetch(PhysTex,ivec2(6,0),0);\n    vec3 pos=texelFetch(PhysTex,ivec2(0,0),0).xyz;\n    //offs.z=-hTerr(-offs);\n    //q=multQuat(getTiltQuat(-offs),q);\n    return transformVecByQuat(p,q)+pos*translate;\n#else\n    return p;\n#endif\n}\n\nvoid calcWheelOffsets(float clmin, float clmax)\n{\n    vec3 wp;\n    wp=carTrafoInv(WheelPosFL*vec3(1,1,1)+vec3(0,0,-.3),1.); WheelOffsFL = clamp(-distTerr(wp),clmin,clmax);\n    wp=carTrafoInv(WheelPosFR*vec3(1,1,1)+vec3(0,0,-.3),1.); WheelOffsFR = clamp(-distTerr(wp),clmin,clmax);\n    wp=carTrafoInv(WheelPosRL*vec3(1,1,1)+vec3(0,0,-.3),1.); WheelOffsRL = clamp(-distTerr(wp),clmin,clmax);\n    wp=carTrafoInv(WheelPosRR*vec3(1,1,1)+vec3(0,0,-.3),1.); WheelOffsRR = clamp(-distTerr(wp),clmin,clmax);\n    //hTerr(wp)-wp.z\n}\n\n\n#define BG 0.\n#define CARBODY 1.\n#define GUMMI 2.\n#define RIM 3.\n#define FLOOR 4.\n#define CHROME 5.\n#define INTERIOR 6.\n#define CHASSIS 7.\n#define BLACKPLASTIC 8.\n#define GLASS 9.\n#define REDGLASS 10.\n#define ORANGEGLASS 11.\n#define DBG_GREEN 12.\n#define DBG_RED 13.\n\n#ifdef ENABLE_MATERIALS\n//#define SET_PREV_MAT(x) mat=(abs(d-d_mat)>.0001)?(x):mat; d_mat=d;\n//#define SET_PREV_MAT(x) mat=mix(mat,x,step(.0001,abs(d-d_mat))); d_mat=d;\n//#define SET_PREV_MAT(x) mat+=step(.0001,abs(d-d_mat))*(-mat+x); d_mat=d;\n#define SET_PREV_MAT(x) if(abs(d-d_mat)>.0001) mat=(x); d_mat=d;\n#else\n#define SET_PREV_MAT(x) \n#endif\n\nstruct Material{\n    vec3 col;\n    float refl;\n    float scratchy;\n    vec2  scratchScale;\n};\n\n//#define MAT_CARBODY    Material(vec3(.8, .05, .1),    -1.,   0.6, vec2(1,.01))\n#define MAT_BG         Material(vec3(-1,-1,-1),       -1.,   0.0, vec2(1,.01))\n#define MAT_CARBODY    Material(vec3(.32, .4, .25)+.05,    -1.,   .6, vec2(1,.01))\n//#define MAT_CARBODY    Material(vec3(.85),    -1.,   .6, vec2(1,.01))\n//#define MAT_CARBODY    Material(vec3(.5),    1.,   1., vec2(1,.03))\n#define MAT_GUMMI      Material(vec3(.25),    -0.35, 1.0, vec2(1,.1)*.3)\n#define MAT_BLACKPLASTIC Material(vec3(.13),    -.9, 1.0, vec2(1,.1)*.3)\n#define MAT_RIM        Material(vec3(.3),          -1.,   0.6, vec2(1,.01))\n#define MAT_FLOOR      Material(vec3(.36,.35,.34)*1.2,            -0.2, 0.0, vec2(1,.01))\n#define MAT_CHROME     Material(vec3(.8),              1.,   0.1, vec2(1,.1))\n#define MAT_INTERIOR   Material(vec3(.9,.7,.5)*.3,    -0.0,  0.0, vec2(1,.01))\n#define MAT_REDGLASS   Material(vec3(1,0,0),          -1.,   0.6, vec2(1,.01))\n#define MAT_ORANGEGLASS Material(vec3(1,.5,0),          -1.,   0.6, vec2(1,.01))\n#define MAT_GLASS      Material(vec3(1),              -1.,   0.6, vec2(1,.01))\n#define MAT_CHASSIS    Material(vec3(.45),              1.,  1.0, vec2(1,.01)*.5)\n#define MAT_DBG_GREEN  Material(vec3(0,1,0), -1.,  0.0, vec2(1,.01))\n#define MAT_DBG_RED    Material(vec3(1,0,0), -1.,  0.0, vec2(1,.01))\n\n#define USE_MTL_ARRAY \n#ifdef USE_MTL_ARRAY\nconst Material mat[14] = Material[] (\nMAT_BG        ,\nMAT_CARBODY   ,\nMAT_GUMMI     ,\nMAT_RIM       ,\nMAT_FLOOR     ,\nMAT_CHROME    ,\nMAT_INTERIOR  ,\nMAT_CHASSIS   ,\nMAT_BLACKPLASTIC ,\nMAT_GLASS     ,\nMAT_REDGLASS  ,\nMAT_ORANGEGLASS ,\nMAT_DBG_GREEN ,\nMAT_DBG_RED\n);\nMaterial getMaterial(float mtl) { return mat[int(mtl)]; }\n#else\nMaterial getMaterial(float mtl)\n{\n    if(mtl==BG)           return MAT_BG        ;\n    if(mtl==CARBODY)      return MAT_CARBODY   ;\n    if(mtl==BLACKPLASTIC) return MAT_BLACKPLASTIC ;\n    if(mtl==GUMMI)        return MAT_GUMMI     ;\n    if(mtl==RIM)          return MAT_RIM       ;\n    if(mtl==FLOOR)        return MAT_FLOOR     ;\n    if(mtl==CHROME)       return MAT_CHROME    ;\n    if(mtl==INTERIOR)     return MAT_INTERIOR  ;\n    if(mtl==GLASS)        return MAT_GLASS     ;\n    if(mtl==REDGLASS)     return MAT_REDGLASS  ;\n    if(mtl==ORANGEGLASS)  return MAT_ORANGEGLASS ;\n    if(mtl==CHASSIS)      return MAT_CHASSIS   ;\n    if(mtl==DBG_GREEN)    return MAT_DBG_GREEN ;\n    if(mtl==DBG_RED)      return MAT_DBG_RED   ;\n}\n#endif\n\n#define DESERT FLOOR\n#define TIRE GUMMI\n#define GRILL CHROME\n\nbool enable_glass=true;\n\n#ifndef RandTex \n#define RandTex iChannel1\n#endif\n\nvec4 rand3d(vec3 uv)\n{\n    float pz=uv.z*256.;\n    float z=floor(pz);\n    vec2 uv1=uv.xy+z*vec2(17,31)/256.;\n    vec2 uv2=uv1+vec2(17,31)/256.;\n    return mix(textureLod(RandTex,uv1,0.),textureLod(RandTex,uv2,0.),pz-z);\n}\n\nvec4 getRand(vec2 coord)\n{\n    vec4 c=vec4(0);\n    c+=texture(RandTex,coord+.003*iTime);\n    c+=texture(RandTex,coord/2.+.003*iTime)*2.;\n    c+=texture(RandTex,coord/4.+.003*iTime)*4.;\n    c+=texture(RandTex,coord/8.+.003*iTime)*8.;\n    return c/(1.+2.+4.+8.);\n}\n\nvoid getTriSubDiv(vec3 pos, inout vec3 p1, inout vec3 p2, inout vec3 p3)\n{\n    mat3 m = mat3((p2-p1)*.5,(p3-p1)*.5,p1);\n    vec3 q = inverse(m)*pos;\n    q/=q.z;\n    vec3 qf=floor(q);\n    float f=step(1.,q.x-qf.x+q.y-qf.y);\n    p1 = m*vec3( qf.xy+f,            1 );\n    p2 = m*vec3( qf.xy+vec2(1.-f,f), 1 );\n    p3 = m*vec3( qf.xy+vec2(f,1.-f), 1 );\n    p1=normalize(p1);\n    p2=normalize(p2);\n    p3=normalize(p3);\n}\n\nvoid getOctaTri(vec3 dir, inout vec3 p1, inout vec3 p2, inout vec3 p3)\n{\n    vec3 s=sign(dir); p1=vec3(s.x,0,0); p2=vec3(0,s.y,0); p3=vec3(0,0,s.z);\n    if(s.x*s.y*s.z>0.) { s=p2;p2=p3;p3=s; }\n}\n\nvec3 galaxy(vec3 dir, vec3 p1, vec3 p2, vec3 p3, vec2 offs, float rot, float quench, float size)\n{\n    vec3 pm=normalize(p1+p2+p3);\n    vec3 bx=normalize(p2-p1);\n    vec3 bz=normalize(cross(p2-p1,p3-p1));\n    vec3 by=normalize(cross(bz,bx));\n    //vec3 by=normalize(p3-(p1+p2)*.5);\n    dir=(dir-pm)*mat3(bx,by,bz);\n    float lavg=sqrt(length(cross(p2-p1,p3-p1)));\n    dir.xy-=offs*lavg;\n    float ang=atan(dir.y,dir.x);\n    dir=rotZ(rot,dir);\n    dir*=vec3(1./(1.-quench),1,1);\n    float l=length(dir.xy);\n    lavg*=size;\n    float m=(1.-smoothstep(.0,.2*lavg,l))*(exp2(-(l/lavg))+.5*abs(cos(l/lavg*60.+ang)));\n    // fade out smaller tha 1 pixel galaxies\n    m*=min(.35/fwidth(l/(.2*lavg)),1.);\n    return vec3(m);\n}\n\nvec3 mySpaceEnv(vec3 dir)\n{\n    vec3 p1,p2,p3;\n    vec3 col=vec3(0);\n    dir=(normalize(dir));\n    vec3 bx=normalize(vec3(1,2,3)), by=normalize(bx.yxz*vec3(-1,1,0)), bz=cross(bx,by);\n    mat3 m=mat3(bx,by,bz);\n    getOctaTri(dir,p1,p2,p3);\n    vec3 c = normalize((p1+p2+p3)), cp=vec3(0);\n    vec2 offs; float rot; float quench=0.;\n    vec3 br=vec3(1.);\n    float size=1.;\n    vec3 allbr=vec3(1.);\n    for(int i=0;i<10;i++)\n    {\n        c = normalize(p1+p2+p3);\n        vec3 rc=m*c;\n        if (abs(rc.z)<abs(rc.y) || abs(rc.z)<abs(rc.x)) rc=rc.zxy;\n        if (abs(rc.z)<abs(rc.y) || abs(rc.z)<abs(rc.x)) rc=rc.zxy;\n        vec2 ruv=(rc.xy/rc.z*.5+.5)*7.;\n        vec4 r=(textureLod(RandTex,ruv,0.));\n        vec4 r2=(textureLod(RandTex,ruv+.3,0.));\n        offs=(r.xy-.5)*.3;\n        rot=r.y*PI2;\n        quench=r.z;\n        size=1.3*r.w;\n        allbr=br*(r2.xyz*.5+1.);\n        if(length(cp-c)>.0001) \n            col+=allbr*galaxy(dir,p1,p2,p3,offs,rot,quench,size);\n        getTriSubDiv(dir, p1, p2, p3);\n        cp=c;\n        br*=.97*vec3(.9,.86,.82); // decay with distance and red shift for more distant galaxies\n    }\n    col+=allbr*galaxy(dir,p1,p2,p3,offs,rot,quench,size);\n    return col;\n}\n\n#define FloorZ -.66\n//#define HomePos vec3(0,0,-FloorZ*1.5)\n//#define CamDist0 18.\n\n// environment just a sky and some dark floor\nvec4 myenv(vec3 pos, vec3 dir, float period_)\n{\n    #ifndef ENABLE_MATERIALS\n        vec3 light=normalize(getLightDir());\n        float d=max(0.,dot(light,dir));\n        vec3 bx=normalize(vec3(light.yx*vec2(1,-1),0));\n        vec3 by=normalize(cross(bx,light));\n        vec2 d2=vec2(dot(dir,by),dot(dir,bx));\n        float ang=atan(d2.y,d2.x);\n        vec4 r=textureLod(RandTex,vec2(ang,length(d2)*2.),0.);\n        float ampl=mix((.7+.3*sin(ang+24.*length(d2)))*(r.x*.4+.8),1.,exp2(-dot(d2,d2)*40.));\n        return vec4(\n            vec3(1,.8,.5)*ampl*1.2*(4.*pow(d,20.)+1.*pow(d,4.))+mySpaceEnv(dir)\n            ,1);\n    #endif\n    vec3 sun = normalize(getLightDir());\n    vec3 skyPos=pos+dir/abs(dir.z)*(120.-pos.z);\n    float cloudPat=(1.+.4*(getRand(skyPos.xy*.0002).x-.5));\n    vec3 colHor=vec3(.3,.4,.5)+.4;\n    float dirl=dot(dir,sun);\n    vec3 clouds=mix(vec3(1.)*(1.-2.*dirl),vec3(.8,1.,1.2),cloudPat);\n    vec3 colSky=mix(vec3(1.5,.75,0.)*3.,clouds,clamp(7.*dir.z,0.,1.));\n    //colSky=mix(colSky,vec3(1),cloudPat);\n    //colSky*=mix(1.,cloudPat,dir.z*5.);\n    vec3 colFloor=vec3(.45);\n    \n    vec3 col=mix(colSky,colFloor,1.-smoothstep(-.01,.01,dir.z));\n    col=mix(colHor,col,clamp(abs(dir.z*5.)-.1,0.,1.));\n    \n    col*=.9;\n    \n    //float sunang=acos(dot(dir,sun));\n    float sunang=atan(length(cross(dir,sun)),dot(dir,sun));\n    col+=15.*clamp(2.*exp(-sunang/.02),0.,1.);\n    col+=2.*clamp(2.*exp(-sunang/.20),0.,1.);\n    \n    return vec4(col,1);\n}\n\n\nfloat distTire(vec3 p, float r)\n{\n    p=abs(p);\n    float d=1000.;\n    d=min(d,length(p)-r);\n    float ang = atan(p.z,p.y);\n    float l=length(p.zy);\n    p.x+=cos(ang*100.)*.005*smoothstep(.87*r,1.*r,l);\n    d=max(d,distTorus(p.yzx+vec3(0,0,.03),r*.78,r*.28));\n    d=max(d,-l+r*.61);\n    float dx=.04;\n    float xfr=mod(p.x,dx);\n    float x=p.x-xfr+dx*.5;\n    d=max(d,-distTorus(p.yzx-vec3(0,0,x),sqrt(r*r-x*x),.01));\n    return d;\n}\n\n\nfloat distRim(vec3 p, float r)\n{\n    r*=.6;\n    vec3 p0=p;\n    p.x=abs(p.x);\n    //p.yz=(p.y>p.z)?p.zy:p.yz; // only first 1/8 segment\n    p=p.zxy;\n    float d=1000.;\n    d=min(d,sdRoundedCylinder(p,r,.01,.6*r));\n    p-=vec3(0,.6*r,0);\n    d=-smin(-d,sdRoundedCylinder(p,.97*r,.01,.6*r),.015);\n    d=-smin(-d,sdRoundedCylinder(p,.89*r,.01,.8*r),.015);\n    float d_i=sdRoundedCylinder(p,.77*r,.01,1.9*r);\n    d=-smin(-d,d_i,.015);\n    \n    float d2=length(p0-vec3(-r*.6,0,0))-r*1.05;\n    d2=max(d2,d_i);\n    d2=-smin(-d2,sdRoundedCylinder(p,.4*r,.01,.8*r),.1);\n    d2=abs(d2)-.005;\n    d2=max(d2,-p0.x);\n\n    float mang,ang;\n    float ang0 = atan(p.z,p.x);\n    float dang=PI2/5.;\n    mang=mod(ang0,dang);\n    ang=ang0-mang+dang*.5;\n\n    d2=-smin(-d2,(length(p.xz-.95*r*cos(ang-vec2(0,1.57)))-.25*r),.01);\n    d=min(d,d2);\n    dang=PI2/5.;\n    mang=mod(ang0,dang);\n    ang=ang0-mang+dang*.5;\n    d=min(d,max(abs(p.y+.6*r)-.22*r,(length(p.xz-.3*r*cos(ang-vec2(0,1.57)))-.05*r)));\n    d=min(d,sdRoundedCylinder(p-vec3(0,-.23,0),.1*r,.01,.25));\n    float l=length(p0.zx);\n    d=min(d,sdRoundedCylinder(p0.zxy-vec3(0,-.06,0),.7*r,.02,.05-.015*fermi((length(p.xz)-.6*r)/.003)));\n    return d;\n}\n\nconst vec3 bbpos=vec3(0,.0,.0);\nconst vec3 bbsize=vec3(1.68,3.74,1.64)+.2;\nconst vec3 bbpos1=vec3(0,.04,-.231);\nconst vec3 bbsize1=vec3(ALLW*1.08,3.68,1.23);\nconst vec3 bbpos2=vec3(0,.23,.33);\nconst vec3 bbsize2=vec3(ALLW*.83,1.25,.7);\n\nfloat rille2(float d, float w)\n{ \n    return w*exp2(-d*d*2./w/w);\n}\nfloat rille(float d, float w)\n{\n    ///// gauss\n    //return w*exp2(-d*d*2./w/w);\n    ///// exp\n    return w*exp2(-abs(d)*1.44/w);\n    ///// linear\n    //return max(abs(d)-w,0.);\n}\n\n#ifdef USE_SIMDATA\n#define SteerAng (texelFetch(iChannel1,ivec2(4,0),0).x)\n#define WheelRot (texelFetch(iChannel1,ivec2(5,0),0))\n#define CamDistFact (texelFetch(iChannel1,ivec2(4,0),0).y)\n#else\nuniform float SteerAng;\nconst vec4 WheelRot=vec4(0);\n#define CamDistFact 1.0\n#endif\n\n\n#ifdef ENABLE_MATERIALS \nvec2 distCarM(vec3 p)   \n#else\nfloat distCar(vec3 p)   \n#endif\n{\n    p=transformVecByQuat(p,axAng2Quat(vec3(1,0,0),.023));\n    float d=100000.,d2;\n    vec3 p00=p;\n    p.x=abs(p.x);\n    vec3 p0=p;\n    vec3 psq=p*p;\n\n    #ifdef ENABLE_MATERIALS \n    float d_mat=1001., mat=-1.;\n    #endif\n    SET_PREV_MAT(BG);\n    \n//##IMG##ENCLZ:44aF7oGGzaDom4DtmI3sgbfhgInpu7XikaDulqDgsIPjgIHsgKPgpIPriJDinJnnqJbgpbrlgYDimbjZoOKmnsKx7buf4biE74m24K+A4ayI6oq86oKM6Y+d6KK+xZnplKvssq3qnL7ui5fmqaflvbnkqYfrr6ripL/llL7lm4bnmJXhoafhkbjmgozmmI7orLbmhKTrmpbYpuyejMus4KSu4Z6G4KKs2KvuiJjqg4foi4nilI3sv6runaDup67sp6PHqu6LhuSYpdGQ5KqZ7ImM6qOF4LuC5Lip4oOB5Jyd5ZGC7piD5JGL4rCD7ImF5J2L4Z+Z7ouJ5ZSI7KeD5JSG6ruJ47mI7K+V3L7ulLbkqYbjiYLomYXkkZLojYXkqYDklr7iiY7lho7gtIfSiui8iOS6vOyTme6rhuSbgOSdmeuviOeKhuqPiuSKjeKPhuOFgeSDjuWhi+q4hu6ypO2ioO2ikOi2rOmli+2FguSnhOidmuOiieasp+GEpeKTpOeeneGyieKdouKjmuGxruGEmOCjgeeNmeGhquKojeCop+iKouWUmOq4stSV7KqL7K2V7bmQ5o6S45eH44+666SB5rCozJrhlJPigYrskJvjmLDhsZjqhaDtgZDoqY7hs5jkh4Xvp5XhpJvmma/snanvh5viqbbmvLLpkKzqn4vioZLlgpXIuOqxoOSQhu+TreyUk+m1iuqJge6ErO6riuSOjuuNg+S+qeK0jtKO4bWc6I6X4LmU74Kb45qj4Y6t5YOg6YKI54yS1Kjor7XouIrsmJblpbLnvZzpurbll7rrqr7pkLjrt47ivJrvq5boqZXgt6HkqoHkj4TigovouJrugaHqp6Hsk5HsvIPkqZ3tr4PhkLTtm6HjioHtnYblgZLgo73kpJvrrrvth6Hqp4TklJ7jvYDpp6vhh4bnoZvomI/hj43kp7rjjKrnsZfim47th4njpZLtu73iqKDjuLvthKLnp4nmkaHhsaPok4Xigonrr5ruuL/mjaLjppDvgrjqsqLrm5jhl4boibrklIngqrjtgKThtYTvg5rinK3qmLDvgovqi6rroZLsqLHsgqPtkYPrlY/lgZLroYbuvrvimYPpqJzprJzskLLmoKnhkYTjnKTjrpDhkofqsaHkq7Xjrq/onrrprLLoqprhsITknqDgrLzpurfiqIbmgJAK7qeA5IS3xIPmjIjulIjovKbno7bivILujLjjiIjoi6Lvqprko6PqnqLjqajmuqTpi5HphIzql5DlkJ7ouabqqbThk4zpiKjorJ3pq6Pgs5zinozpgrnsiIvgrKPskKnhkY/thJTlhJzqmKHooKHilIzGqOGSiOS/keiCnuOAgu6WqOKwi+ipk+KSlOK8rOmAnu6kouiVguWjguO9guKPtOKmiOiWuOuiiuGMhuyAiOSwpeC7geqjpOKinueJie2Jtc6k4qeq5rKT6pOa7riM5rKm5Yim4pSj5omS5qmL6ImB6aOC4amk6oq275W44oKR7oO054mH5ION4rCb7oen5KOk46mG7IqG7bin7pqX5LSu4p6d45WQ7o2U6biJ6bCA4Y6ny4DjlpDqro/thqjppK/Lp+yxseO9gOCihOyIke6wguKgvOG+hO+UuO+Jquq3gOW7rOOMhe+nsNC36qGC6pqy4LOh64iw4rqK4LOD5amP5r+L4ouh5Iqy6LKr5KOi4ois6Ka87ZWI6ZOA6IeT5IS35KGs4qW645ST5pih5JuM44m855iU6reD64KH4KOS4YKc5Yqz6qu76quk5pWC6qeh6par4beM5pin4YOn56Kz57SC4aay4rCn4oeFw5DQuOuyqeixkOKkg9KQ4YuO6qqX64Oi7bqO4rew4K2K67Cja+Oth+WGjOWEteSsouuhteO1qOWHtOqKnuyeku+RlM6L7YW06rix7JGA46Gz44aK7oqQ4LSA6oeq66Oc6rKO5r6w5rC27IeV6J6R4ZSC5Yue3pXis7nliaLjpIvnp77kh53guKLilaPrnIvmno7Hhui0o+acjuK1mueene6Cn+Sao+ShveGzmOeKmeiTsuaBuOOvpuW7i+SgsOWQge6Qr+O5o+G0reOdlO2YtO2egOm1p+eSlueAgO6ap+acgMeb5Kay6ZGI4KK546y34LCC57CL7oCo6qWC6Kq34qKo5Lm25pK46pKc4pij45ai4ru945qF5Yap67SU7q6/7qe247WG5oms7pCP7YWD4qeV76OM772v4q2y5Jiw5JuJ4r2K4auF4ZCjbe2iiOSXqO6IiOKmkOeEheGTquK6guiglOmjoeSQhuCyoMiq4ZOw4bST7YyI5ZCQ5IGc6LKy74iy7Yag46m04bCJ5ICo75Og4Y+K56u04YKK6JeC64iJ4KCn6amD67WP5LSh6oKC6JmK6a6Z4oOQ4r2M6YWI4aiW5Kij7LG65L2S7qi15YGg6LqC5IWT5oS+5KKm5IGi64ym6pqS46Sj4bGx4YuA4bib6YiC7a+P4KKw552I7IeU57Gm7bm04YeL64GG4aqp4ZSq6o+w5Ji774aw6Lqg65C66rGR7Yuy6JuG5aCA4Z+g4Z6j4KKI44WG4qOE4bah7oOY4KyD7oKB4Y6H7IOk6I+h6ZK75JmS6LSZ5KW55aSA7LGn6pqi6KSh7Jm65Yi46aC47IC67I6g5KSs6IO475aC6I+26YSL7oWT7YKA6JCv7ICx6pC726jhhKflr7Dnoq3jg7zqlZLvh5Pgr4bjgaLplLXtoITkipLtpKTon7Dou4TqoqLhi5LooLrthqLlgITqlJDhnozkn5bnioLigpTvspLhhYbms5bHieG9m+eSiOqiouSIl+iBnuiYgNiY54Ko5oOo5oaB6KO14r6C6JCO4LeQ74SI5J2456y97oOF44SQy4TnoZPhh73hhbrso4DhjIXpiJjorLDmsozsjLHjiqrpoKLqnKHqopLjmoLvso/kk7jrmL/svbTuiojnj5TmoaHuhqHqpKDto4LGmOyKkeCgqOmwlOqDsuyqg+ylgue1reajtuafge+Houm0huCoj0XtspbsiojmiL3qg7LhiZLsorrknITmobzSqeiAm9ek5rCP6KeW6KSH5aWF4ZuK7Y2I5qWy5ae6442E4bKB7LuB6aKR5LqC65CR44+S46CX6KW45a2N7KWi4Kqr6LCO4KO55qWj7oip47CM7oCA562j6pSB7J6w75C64bab5Kad4LSJ5oGh4rKA45ep7JGB64Cs5Lmq6aCe6Iiq6JWa5qeY44SF7bWE44ej65SO5Y6B7pCzyoLmsIrgrrDjhY/kirjphIzjg5TqsoXtqJPEleSgkeCqqeiVguKrrOaqgOeHhu+gpeKGp+qcgOOgpuquhuWhksKI74qV5JmS45CK76em7ZWJ77GM4Lmk44Kd24LpgIzskprooJbogq3olrnjiKjklI/lqJXmhabmtpXqjZvimbrpmYHsoJHks5jpmq7hl4DohIXlh7jjjqfqm47poqnkiYrqmKPmlZvin6DrkJbpn5Toop7jh6npnoTjhLTjiLXkkZXtmIDpsJbnhrDtsJ/mgojjiYbmhonhuoTlg6TgsqvuiZjli6DlnIfKve2Mi+Sgtuq0oeGKtOi9rOOVieiNgOmhs+qogOOVluqnleGdiOqZkOG4oeyEvMik6paI4piY5qCk6LCg7pyQ7oOQ7aqS5IWOHuqsteeare2XuOGojeSHt+iUh+yhle6rvOWeouKmoOK/nOidv+aTlOmAnMuX7ZOF4LSG7ZCy6JuU5aSkzJDquZHtp4jnpZXmgIrrhqjrh5jliI3mhbPWheK8ne6GqOWloOWFkeCspuGMgua2k+ShmeKqseCgkuuCk+S0guS+uuKIgOeQmuiEgOKJouGBjui0pOKGpumomOiPuOaQkeSEoiPho7njkoPomJvhvqPkiI3omqfstLXDmOG9iOeCquCki+aduOOWo+aAu+iqmu+BseSlgO2chuyQkO2ynuaGsuSUiO6mh8SF5JKyy4zqrKXjqZ3olo3srbjkgZfui4jooZbHou2Pp+uxj+mxku+QpOulpum8leGInOqUhOWktuGFrOKxhuu7g+ONveGEle+RjOyfkcSB4a6q6qG9ybLvmp/og5/lvILolK3mpaLjgJXmh4DmlI7kjaDntJHoiZDjurvjk7runqLploznvIDroLDsjJnmpafon6Toiqbjj7TiiY/jn6Lln4TmgpLUge+oteuSsO2bkuSEs+2qh+S9geOoi+uAh+CohOewrtSC6YuI64eZ776BxpTji4bli5rnjL3lgYLssaDjoofmmZvgoZPjo6jos4nsk73rlbnktYrntLDokL7vk6PgrIjlh6PjqInjuqjTk+2luOiuhuq5gOCmreeHhOSnhuqintSf5paR5qaX4pO94rmC6Z2y4KqE5ay645Sl6amZ46CM4YCg6bCK5LOE6oaB46iL44qX6oej76qyxovpk7LgrrrnmJvjqajinZDlq4fmoqLuuIvtj4bkt4/um5TgrKLqorDqn5LllJ/krKrqgbHlioHUpu+hteioju+Dr+mLhuqgkem+remEn+mKmeOtl+SVvOiWleaHq+yGou+hju+JpNKE4qae4L2J6ri445i14a+U4K6e6p224KKj6KO9472Y5a2r5bqZ5rmp6Ja47Kqe7rm36LKe6Yew5aSN6oqg46SN4ZCE5IC+6pm+6ISs4puU56CP7bKO6Lyz7Kak7KSl6IOx4rmI74mM7qmq4pOB5KeC66a74oup7o2N4Km46J2AybrknYLRnu+Pjei/j+CgoOujkOm6hOypuuKSjuyKluOsiO2sqe6yhuyKouKtkuGvmeGoneaRreu5jeSDs96D7pSr4ZGA56GQ55ar6qq376+H5omI66SS5YqS5KWB47uA4omg74OB6Kih7IK105DgsJrjo5Dtj7/GgOaKou6VqeS+huqmvuSyjOyCvu+hhue9neWlluiSgeiNi+KAsuqwm+WkvuKor+6RnOG/v+OHv+Wkl++uqOG/pemmo+i7leqgoeKfiOeOseWYp+SFluaVg+OZn+iKluO8seWZhOSXi+WRheGgguKBluKVosiT5oGW4pKD5IOL74+75Yuh6amU6Yig55KW5LG26J2M4o2m5LG95pWY47aV5qCI6IKt5YKn5LGb6Y6o4Z2g5KiW7YWI5pOH5KCc7Jqy44uB4YCe7oGl44qw77C+6IGb5I6D67G+5ZWu44OB6rG/44qO5JiF4oGW7pOR4oaD76Wt6JeX5IOw75CC64mQ6Iim46Gp5out44CL5pCV5omI5JuH5IKG55mM46WA6rSg6oeM4oKj6oiv4Zqu5JWG46G65JOy47qA74ii6IKy55yA6qylyqvjpIHrmKTtiaTik5HjmInogafntInhg4DhiJDugIPpoIDos5jhhI7ooL7ohZnkurbjpZHmhIjhu6PpkKDou6jjtoXrpLrsjqHkraPviJDoqIjkhI/koKnmi7DnhaDFo+aAmOesjuW5veCrsOqKh+OYkuGciOqTgOqjge2RsOapleu8m+2FluakhO6Bo+aRqOybhOajkeiIqeKlouKkheaQpOSbhe6NqOiopOOEi+qBoui4vueaj+OUleaGteGVo+WJoMmD5q+y6bml75KQ6p+C5aGS2orkg4HpkLrJvOajhuOgsN+y44m374mf65u94ZCy6bmgxLbmioXsjLTsjoHmjofgoIXosIjogJPksK/grYzmo4TqoZ7rmabimI7qvZfoqJzmrJHguLTsh4jkqbDpnLTskYzhqrDmjYbrhrjmgIHvgb3mlaXmppN+6YOw4YOR5KS55IaIxoLgqb3mlrnlgqDooKTkupnntpTrhaDqh7LjgIfkoKjqiIjivKTmhJThj7DhkJHtqJThk5HniYjvuKrlm7HhupLpqbjomLjqooPqhJzlg53hmY7oqJnpioTpgoHqlIrhlqTurJfqlZHrmITvuYjmqIfimZ/kioflvKrlg6TphYjpkrDohrLhoofsuKDqjIDkhYjhvZHhlJTsl6fpvZXkvqXhnqTmk6PpkZTurofogKAA\n    vec3 frontWheelPos=vec3(1.44*.5,1.25,-.45);\n    vec3 rearWheelPos=vec3(1.42*.5,-1.05,-.5);\n    \n    //d=min(d,distBox(p-vec3(0,0,-.05),vec3(1.65,3.45,.7)*.5));\n    //d=min(d,distBox(p-vec3(0,-.5,.55),vec3(1.65,2.4,.55)*.5));\n    bool front = p0.y>0.; \n    vec3 pwheel = front?frontWheelPos:rearWheelPos;\n    // -- 15 ----- wheel cases (precalc) ------------\n    float dWheelcases=distCylR((p-pwheel+vec3(0,0,-.1-(front?-.018:.0))).zyx,.4,.7,.1);\n    \n    float wcext=.01+(p.z+.5)*.1;\n\n    // -- 0 ---------- main box -------------\n    d=min(d,\n          distBoxR(p-vec3(0,0,.2),\n                   vec3(1.63-(psq.y*psq.y*.1+1.)*psq.y*.01-psq.z*.521-smoothstep(0.25,0.35,p.z)*(p.z-.25)*.0\n                        +wcext*(1.-smoothstep(wcext*.3,wcext,dWheelcases))\n//                        +wcext*exp(-dWheelcases*dWheelcases/wcext/wcext)\n                        ,\n                        3.6- min(psq.z*psq.z*20.*step(0.,p.y),.1) - (psq.z+psq.x)*.1  -step(0.,-p.y)*smoothstep(0.,.2,p.z)*max(p.z-.2,0.)*1.1,\n                        1.3-psq.y*psq.y*psq.y*.015*(.5+.5*step(0.,-p.z))-step(0.,p.z)*(psq.x*.2+psq.y*.035+p.y*.04))*.5,\n                        .03-min(p.y*.03,0.)));\n    float dmainBox=d;\n    \n    // -- 1 ---------- hood/windshield cut -------------\n    float dwin =dot(p-vec3(0,1.5-psq.x*(.3-(p.z-.8)*.4),0.7)*.5,normalize(vec3(0,1.,1)));\n    float dhood=dot(p-vec3(0,1.5-psq.x*(2.-(p.y-.75)*1.),0.74-.1*(p.y-.75)*(p.y-.75))*.5,normalize(vec3(0,.07,1)));\n    //dwin=10000.;\n    d=-smin_(-d,-smin_(dwin,dhood,.03),max(.001,.05-.0*(p.y*.01)));\n    //d=-min(-d,-min(dwin,dhood));\n\n    float dwin2 =dot(p-vec3(0,1.64-psq.x*.3,0.7)*.5,normalize(vec3(0,1.5,1)));\n    float dhood2=dot(p-vec3(0,1.5,0.36)*.5,normalize(vec3(0,.04,1)));\n    d2=-min(-d,-min(dwin2,dhood2));\n    d+=exp(-abs(d2)/.006)*.006;\n    \n    p=p-vec3(0,0,-.01*psq.y);\n\n    // -------- absatz hood ---------------    \n    d2=distBoxR(p-vec3(0.,1.37,.3),vec3(.9,1,.5)*.5,.07);\n    d+=.015*(1.-smoothstep(-.015,.015,d2))*clamp(1.7-p0.y,0.,1.);\n    \n    // -- 2 ---------- side versenkung windows --------------\n    d2=distBoxR(p-vec3(.9-p.z*.2,0,.57),vec3(.1,3.25-p.z*.75,.59)*.5+.02,.15)-.02;\n    d=-smin_(-d,d2,.01);\n\n    SET_PREV_MAT(CARBODY);\n    \n    float dwincut=1000.;\n    // -- 3 ---------- side win rear -----------\n    p=p-vec3(0,-.88,.55);\n    d2=distBoxR(p,vec3(3.,.82-.8*(p.z)*step(0.,-p.y),.37)*.5,.063-p.y*.05);\n    //d+=clamp(-d2,0.,.01);\n    //d+=smoothstep(0.,1.,-d2/.01)*.01;\n    ////d+=exp(-abs(d2)/.006)*.006;\n#ifdef ENABLE_MATERIALS \n    //if(enable_glass) { SET_PREV_MAT(GLASS); }\n#endif\n    dwincut=min(dwincut,d2);\n    p=p0;\n\n    // -- 4 ---------- side stripe --------------\n    d2=distBox(p-vec3(0,0,.16-.01*(p.y+.4)*(p.y+.4)),vec3(3.,3.3,.07)*.5);\n    //d+=clamp(-d2,0.,.01);\n    d+=smoothstep(0.,1.,-d2/.01)*.01;\n\n    // -- 5 ---------- door -------------\n    d2=distBoxR(p-vec3(0,.1,.235),vec3(3.,1.03,1.09)*.5,.07-.1*(p.z+.3));\n    d2=-smin_(-(dwin+.03),-d2,.07);\n    d+=exp(-abs(d2)/.006)*.01;\n    SET_PREV_MAT(CARBODY);\n\n    // -- 6 ---------- side win front -----------\n    d2=-smin_(-d2-.05,p.z-.36,.03);\n    //d+=clamp(-d2,0.,.01);\n    //d+=smoothstep(0.,1.,-d2/.01)*.01;\n    ////d+=exp(-abs(d2)/.006)*.006;\n    dwincut=min(dwincut,d2);\n    \n    // -- 7 ---------- front window -----------\n    p=p0-vec3(0,0,.53);\n    //d2=distBoxR(p,vec3(1.4,5.,.37)*.5,.05);\n    d2=dmainBox+.065-psq.x*.1*p.z;\n    d2=-smin(-d2,dhood-.015,.05);\n    //d+=clamp(-d2,0.,.01);\n    //d+=smoothstep(0.,1.,-d2/.015)*.01;\n    dwincut=min(dwincut,d2);\n#ifdef ENABLE_MATERIALS \n    //if(enable_glass) { SET_PREV_MAT(GLASS); }\n#endif\n\n    // -- 8 ---------- rear window -----------\n    p=p0-vec3(0,-1.7,.5);\n    d2=distBoxR(p,vec3(1.15-p.z*.3,1.,.35)*.48,.07);\n    d+=smoothstep(0.,1.,-(d2-.03+.03*p.z)/.01)*.01;\n    SET_PREV_MAT(CARBODY);\n    //d+=smoothstep(0.,1.,-d2/.01)*.01;\n    dwincut=min(dwincut,d2);\n    //d=max(d,-d2);\n#ifdef ENABLE_MATERIALS \n    //if(enable_glass) { SET_PREV_MAT(GLASS); }\n#endif\n\n    // ------- bottom absatz ------------\n    d2=p0.z+.345;\n    d+=.02*min(exp2(-d2/.02),1.);\n\n    // -- 15 ----- wheel cases (apply) ------------\n    d=-smin_(-d,dWheelcases,.005);\n    \n    SET_PREV_MAT(p0.z<-.345?GUMMI:CARBODY);\n\n    // ------------- cut out interior, cutout windows, add windows + window lips\n    float d_inner=d+.06;\n    d=max(d,-d_inner); SET_PREV_MAT(BLACKPLASTIC); \n    d=-smin_(-d,dwincut,.01);\n    SET_PREV_MAT(CARBODY); \n    d=min(d,length(vec2(dwincut,d_inner-.045))-.01);\n    SET_PREV_MAT(GUMMI); \n    d=min(d,length(vec2(dwincut,d_inner-.045)+vec2(1,-1)*.008)-.0025);\n    SET_PREV_MAT(CHROME); \n    if(enable_glass) { d=min(d,d_inner-.045); SET_PREV_MAT(GLASS); }\n    \n    // -- 9 ---------- rear door -----------\n    p=p0-vec3(0,-1.7,.25);\n    d2=distBoxR(p,vec3(1.35-psq.z*.35,.5+p0.z*.5,.97)*.5,.07);\n    d+=exp(-abs(d2)/.006)*.01;\n\n    // -- 11 ---------- rear license plate box -----------\n    p=p0-vec3(0,-1.885,.04);\n    d2=distBoxR(p,vec3(.65+p.z*.3,.2,.2)*.5,.03);\n    d=max(d,-d2);\n    SET_PREV_MAT(CARBODY);\n    p=p0-vec3(0,-1.775,.14);\n    d2=distBoxR(p,vec3(.68,.05,.04)*.5,.005);\n    d=min(d,d2);\n\n    // -- 10 ---------- rear blinker -----------\n    p=p0-vec3(.68,-1.8,.0);\n    d2=distBoxR(p,vec3(.2-p.z*.2*step(0.,-p.x),.3,.3)*.5,.03);\n    d=min(d,d2);\n    d=max(d,dmainBox-.01);\n    SET_PREV_MAT(BLACKPLASTIC);\n    d-=smoothstep(.007,.01,-d2)*.001;\n    SET_PREV_MAT(p.z<0.06?(p.x>0.0?(p.z>-.05?GLASS:ORANGEGLASS):REDGLASS):REDGLASS);\n    \n    // -- 12 ---------- front blinker -----------\n    p=p0-vec3(.6,1.75,.15);\n    d2=distBoxR(p,vec3(.25,.095,.12)*.5,.03);\n    d=max(d,-d2);\n    SET_PREV_MAT(BLACKPLASTIC);\n    d=min(d,-smin_(-d2-.025,-p.y+.01,.01));\n    SET_PREV_MAT(p.x<0.03?ORANGEGLASS:GLASS);\n\n    // -- 13 ---------- grill -----------\n    p=p0-vec3(.0,1.78-psq.x*.05,-.05);\n    d2=distBoxR(p,vec3(1.48+.02-p.y*.3,.2,.265-psq.x*.03+.02-p.y*.3)*.5,.06-p.z*.15);\n    d=max(d,-d2);\n    // ----- einbuchtung rund um scheinwerfer -----\n    float d2b=-smin_(-d2,p.x-.48,.02);\n    vec2 pl=(p-vec3(.61,0,0)).xz; float lpl=length(pl);\n    float yo=mix(.02,max(-d2b-.016,0.)*.5,1.-exp2((-lpl+.1)/.0075));\n    d2=-smin_(-d2,-.1+lpl,.005);\n    d2=-smin_(-d2,-abs(p.y-.01)+.035-yo,.005);\n    // ----- cooling slits -----\n    vec3 pi=vec3(0,0,(clamp(floor(p.z/.029),-4.,3.)+.5)*.029);\n    d2=-smin_(-d2,distBox(p-pi,vec3(.96,.2,.02)*.5),.01);\n    // ----- lada logo -------\n    p.y-=.03;\n    d2=min(d2,distBoxR(p,vec3(.04+p.z*.1,.02,.07),.005));\n    d=min(d,d2);\n    SET_PREV_MAT(BLACKPLASTIC);\n\n    // ----- scheinwerfer -----\n    float lsph=length(p-vec3(.61,-.273-.03,0));\n    d=min(d,max(max(lsph-.3,-p0.y+1.65),lpl-.09));\n    SET_PREV_MAT(CHROME);\n\n    // -- 14 ---------- bumpers -----------\n    p=p0; p.y=abs(p.y);\n    p=p-vec3(0,1.87-.03*psq.x,-.25);\n    d2=distBoxR(p,vec3(1.62,.1,.1)*.5,.02);\n    d=min(d,d2);\n    SET_PREV_MAT(CHROME);\n    p-=vec3(.76-p.y*.15,-.065,0);\n    d2=distBoxR(p,vec3(.113,.25,.113)*.5,.02);\n    d2=max(d2,dot(p,vec3(-1,-.4,0))-.03);\n    d=min(d,d2);\n    SET_PREV_MAT(GUMMI);\n    \n    // ------- wheels, axes ------------\n    //d=max(d,-distCylR((p-rearWheelPos+vec3(0,0,-.1)).zyx,.4,.7,.1));\n    // ------- axes ------\n    #if 0\n    p=(p0-pwheel*vec3(0,1,1));\n#ifdef USE_SIMDATA\n    float leftSgn=sign(p00.x);\n    float rear=front?0.:1.;\n    vec3 wo=vec3(mix(WheelDistF,WheelDistR,rear)*.5,0,0);\n\n    // wheel offsets\n    vec4 qf=axAng2Quat(vec3(0,1,0),(WheelOffsFL-WheelOffsFR)/WheelDistF*leftSgn);\n    vec4 qr=axAng2Quat(vec3(0,1,0),(WheelOffsRL-WheelOffsRR)/WheelDistR*leftSgn);\n    vec4 axQuat=front?qf:qr;\n    float axOffs=mix(WheelOffsFR+WheelOffsFL,WheelOffsRR+WheelOffsRL,rear)*.5;\n\n    p=transformVecByQuat(p,axQuat);\n    p.z-=axOffs;\n#endif\n    d=min(d,distCylR(p.zyx,.12*(1.-.6*smoothstep(0.05,.2,p.x)),1.44,.05));\n    #endif\n    p=(p0-pwheel);\n\n#ifdef USE_SIMDATA\n    float leftSgn=sign(p00.x);\n    float rear=front?0.:1.;\n    vec3 wo=vec3(mix(WheelDistF,WheelDistR,rear)*.5,0,0);\n\n    // wheel offsets\n    vec4 qf=axAng2Quat(vec3(0,1,0),(WheelOffsFL-WheelOffsFR)/WheelDistF*leftSgn);\n    vec4 qr=axAng2Quat(vec3(0,1,0),(WheelOffsRL-WheelOffsRR)/WheelDistR*leftSgn);\n    vec4 axQuat=front?qf:qr;\n    float axOffs=mix(WheelOffsFR+WheelOffsFL,WheelOffsRR+WheelOffsRL,rear)*.5;\n    // wheel axis rot + offset\n    p=transformVecByQuat(p+wo,axQuat)-wo;\n    p.z-=axOffs;\n    d=min(d,distCyl(p.zyx-vec3(0,0,-.72),.12*(1.-.6*smoothstep(0.05,.2,p.x+.72)),1.55));\n    SET_PREV_MAT(CHASSIS);\n    // steering rotation of front wheels\n    vec4 q=axAng2Quat(vec3(0,0,1),leftSgn*(1.-.1*leftSgn*sign(SteerAng))*-SteerAng*(front?1.:0.));\n    p=transformVecByQuat(p+vec3(.1,0,0),q)-vec3(.1,0,0);\n    // wheel rotations\n    float rot=-WheelRot.x*.7;\n    p=transformVecByQuat(p,axAng2Quat(vec3(1,0,0),rot));\n#endif\n#define PROPER_WHEELS\n#ifndef PROPER_WHEELS\n    d=min(d,distCylR(p.zyx,.35,.2,.05));\n#else\n    //d=min(d, distWheelDim((p0-pwheel).yzx,185.,75.,16.,12.,.2));\n    d=min(d, distWheelDim(p.yzx,175.,80.,16.,12.,.2));\n#endif\n    SET_PREV_MAT(length(p.yz)<.215?CHROME:GUMMI);\n    \n#ifdef ENABLE_MATERIALS \n    return vec2(d,mat);\n#else\n    return d;\n#endif\n}\n\n#ifndef ENABLE_MATERIALS\nvec2 distCarM(vec3 p) {return vec2(distCar(p),1.); }\n#endif\n\nbool enable_car=true;\nbool enable_terr=true;\n\nfloat lorentz(float x) { return 1./(1.+x*x); }\n\nvec2 distM(vec3 p)\n{\n    float d=1000., mat=-1., d_mat=d;\n    \n    if(enable_car)\n    {\n        vec2 dm=distCarM(carTrafo(p)*vec3(1,-1,1));\n        d=dm.x; mat=dm.y; d_mat=d;\n    }\n    \n    if(enable_terr)\n    {\n        d=min(d,distTerr(p));\n    }\n    \n    SET_PREV_MAT(FLOOR);\n    \n    //#define DEBUG\n    #ifdef DEBUG\n    vec3 accFrontAxe = texelFetch(PhysTex,ivec2(7,0),0).xyz;\n    vec3 accRearAxe  = texelFetch(PhysTex,ivec2(8,0),0).xyz;\n    d=min(d,sdLine(p,carTrafoInv((WheelPosFL+WheelPosFR)*.3,1.),carTrafoInv((WheelPosFL+WheelPosFR)*.3,1.)+accFrontAxe)-.1);\n    d=min(d,sdLine(p,carTrafoInv((WheelPosRL+WheelPosRR)*.4,1.),carTrafoInv((WheelPosRL+WheelPosRR)*.4,1.)+accRearAxe)-.1);\n    SET_PREV_MAT(DBG_GREEN);\n    #endif\n    \n    return vec2(d,mat);\n}\n\nfloat dist(vec3 p) { return distM(p).x; }\n\nvec3 getGradOld(vec3 p,float delta)\n{\n    float v=dist(p);\n    vec2 d=vec2(delta,0); return vec3( dist(p+d.xyy)-v,\n                                       dist(p+d.yxy)-v,\n                                       dist(p+d.yyx)-v )/delta;\n}\n\n/// my own version of a looped getGrad() (is asymmetric)\nvec3 getGrad2(vec3 p,float delta)\n{\n    vec4 d=vec4(0,0,0,1); \n    vec3 s=vec3(0);\n    // use a loop here keep compiler from inlining this in win (thanks iq for the hint!)\n    for(int i=min(0,iFrame);i<4;i++)\n    {\n      \ts+=(d.xyz-d.w)*dist(p+d.xyz*delta);\n        d=d.wxyz;\n    }\n    return s/delta;\n}\n\n// cheap tetrahedral gradient (is symmetric)\nvec3 getGrad(vec3 p,float delta)\n{\n    vec3 g=vec3(0);\n    for(int i=min(0,iFrame);i<4;i++) { vec3 v=vec3((i&1)*2-1,(i/2)*2-1,1); vec3 d=v.xxz*v.zyy;  g+=d*dist(p+d*delta*.289); }\n    return g/(delta*1.732);\n}\n\nfloat march(inout vec3 p, vec3 dir)\n{\n    //if(!intersectBox(p-bbpos,dir,bbsize)) { enable_car=false; }\n    vec3 pc=carTrafo(p);\n    vec3 pdir=carTrafo(dir,0.);\n    //enable_car=true;\n    if(!intersectBox(pc-bbpos,pdir,bbsize)) { enable_car=false; }\n    if(terrbbsize!=vec3(0) && (!intersectBox(p-terrbbpos,dir,terrbbsize))) { enable_terr=false; }\n    //if(!(intersectBox(pc-bbpos1,pdir,bbsize1)||intersectBox(pc-bbpos2,pdir,bbsize2))) { enable_car=false; }\n    vec3 p0=p;\n    float eps=.001;\n    float dmin=100000.;\n    bool findmin=false;\n    float d=dist(p);\n    vec3 pmin=p;\n    for(int i=min(0,iFrame);i<150;i++)  // min(0,iFrame) avoids unrolling of loop - thx Dave_Hoskins\n    {\n        float dp=d;\n        d=dist(p);\n        p+=dir*d*.7;\n#ifdef SHADOW\n        if (d<dp) findmin=true;\n        if (findmin && d<dmin) { dmin=d; pmin=p; }\n#endif\n        if (d<eps) return 0.;\n#ifndef SHADOW\n        if (dmin<50. && d>50.) break;\n#else\n        if (dmin<150. && d>150.) break;\n#endif\n        //if (length(p)>100.) break;\n    }\n    float lmin=length(pmin-p0);\n    return clamp(dmin/lmin/.05,0.,1.);\n}\n\nfloat wstep(float w, float thr, float x)\n{\n    return smoothstep(thr-w*.5,thr+w*.5,x);\n}\n\nfloat getAO(vec3 pos, vec3 n)\n{    \n    float ao=1.;\n    float sc=.025;\n    float amb=.3;\n    // use loop here to keep compiler from inlining this in win (thanks iq for the hint!)\n    for( int i=min(iFrame,0); i<5; i++ )\n    {\n    \tao*=mix(dist(pos+n*sc)/sc*1.4,1.,amb);\n    \tao=clamp(ao,0.,1.);\n        sc*=2.;\n        amb=min(amb+.1,.5);\n    }\n    return ao;\n   \t/*\n    ao*=dist(pos+n*.02)/.02*1.4*.7+.3;\n   \tao=clamp(ao,0.,1.);\n    ao*=dist(pos+n*.05)/.05*1.4*.6+.4;\n    ao=clamp(ao,0.,1.);\n    ao*=dist(pos+n*.1)/.1*1.4*.5+.5;\n    ao=clamp(ao,0.,1.);\n    ao*=dist(pos+n*.2)/.2*1.4*.5+.5;\n    ao=clamp(ao,0.,1.);\n    ao*=dist(pos+n*.4)/.4*1.4*.5+.5;\n    ao=clamp(ao,0.,1.);*/\n}\n\nvec3 lighting(vec3 pos, vec3 dir, vec3 pos0, float reflections, inout float outfres, inout float outao)\n{\n    vec3 pc=carTrafo(pos);\n    vec3 glasspos=vec3(1000.);\n    vec3 glassn=vec3(0.);\n    float mat=distM(pos).y;\n    if(mat==GLASS)\n    {\n        glasspos=pos;\n        glassn=normalize(getGrad(pos,.001));\n        enable_glass=false;\n        march(pos,dir);\n    }\n    mat=distM(pos).y;\n    \n    vec3 light=getLightDir();\n    float sh=1.;\n#ifdef SHADOW\n    vec3 posS=pos+.017*light;\n    enable_car=true;\n    sh=march(posS,light);\n#endif\n    enable_car=true;\n    vec3 n=getGrad(pos,.001);\n    if (length(n)<.001) n=vec3(0,0,1);\n    n=normalize(n);\n    if(mat==BG) n=vec3(0,0,1);\n\n    float ao=1.;\n    ao=getAO(pos,n);\n    //ao=pow(ao,.5);\n    ao=ao*.7+.3;\n    //ao=clamp(ao*2.-1.,0.,1.);\n\n    //vec3 light = normalize(vec3(-.5,.5,2));\n    float diff=clamp(dot(n,light),0.,1.);\n\n    diff=min(diff,sh);\n    \n    // no ao in lighted areas\n    ao=mix(ao,1.,diff);\n    ao=clamp(ao,0.,1.);\n    //return vec3((diff*.6+.4)*(ao));\n    \n\n    Material mtrl=getMaterial(mat);\n\n    // evironmental reflection\n    n=normalize(n);\n    if(mat==CARBODY) // brushed metal surface\n    {\n        vec4 r1=rand3d(pc*.1);\n        vec4 r2=rand3d(pc*.05);\n        // scramble normals randomly\n        //n+=clamp((r1.xyz-.5)*5.,0.,1.)*.015 + clamp((r2.xyz-.5)*5.,0.,1.)*.015;\n        // darken randomly\n        //n*=clamp(r1.w*3.-1.,0.,1.)*.05 + clamp(r2.w*3.-1.,0.,1.)*.07 + .88;\n    }\n    vec3 R=reflect(dir,n);\n    vec3 refl=myenv(pos,R.xyz,1.).xyz;\n    //refl=refl*1.2+.3;\n    float fres=abs(dot(R,n));\n    fres=1.-fres;\n    fres*=fres*fres;\n    fres=fres*.9+.1;\n    float fres0=fres;\n    #ifdef SCRATCHES\n    vec3 n0=n;\n    int numscr=7;\n    float dang=1.57*2./float(numscr);\n    float ang=.5;\n    refl*=1.;\n    vec3 drefl=vec3(0);\n    float sum=0.;\n    vec3 pi=pc;\n    vec3 heading=vec3(0,0,1);\n    vec3 tan1=vec3(1,0,0);\n    vec3 tan2=vec3(0,1,0);\n    // ...trying to implement some micro scratches\n    for(int i=0;i<numscr*3;i++)\n    {\n        n=n0;\n        vec2 cs=cos(ang+vec2(0,-1.57));\n        mat2 m=mat2(cs,cs.yx*vec2(-1,1));\n        //dFdx()\n        vec2 dn2d=(texture(iChannel0,(m*pi.xy)*vec2(6.,.1)*mtrl.scratchScale+vec2(0,.5/256.)).x-.5)*mtrl.scratchScale;\n        dn2d=pow(abs(dn2d),vec2(.7))*sign(dn2d);\n        dn2d=dn2d*m;\n        //dn2d=dn2d.yx*vec2(1,-1);\n        n+=abs(dot(n0,heading))*carTrafoInv(dn2d.x*tan1+dn2d.y*tan2,0.);\n        n=normalize(n);\n        R=reflect(dir,n);\n        float fres=abs(dot(R,n));\n        fres=1.-fres;\n        fres*=fres*fres;\n        fres=fres*.4+.6;\n        float fact=(abs(dot(n0,-dir))*.8+.2)*fres;\n        //fact=.2;\n        drefl+=fact*myenv(pos,R.xyz,1.).xyz;\n        sum+=fact;\n        ang+=dang;\n        pi=pi.zxy;\n        heading=heading.yzx;\n        tan1=tan1.yzx;\n        tan2=tan2.yzx;\n    }\n    drefl/=float(numscr);\n    refl=mix(refl,drefl,mtrl.scratchy);\n    #endif\n    \n    #ifdef RENDER_GLASS\n    vec3 Rg=reflect(dir,glassn);\n    vec3 glassrefl=myenv(pos,Rg.xyz,1.).xyz;\n    //glassrefl=glassrefl*1.2+.3;\n    float glassfres=abs(dot(Rg,glassn));\n    glassfres=1.-glassfres;\n    glassfres*=glassfres*glassfres;\n    glassfres=glassfres*.7+.3;\n    if(glassn==vec3(0)) glassfres=0.;\n    #endif\n\n    vec3 rcol=vec3(1);\n    fres=(mtrl.refl<0.)?fres*-mtrl.refl:mtrl.refl;\n    rcol=(mtrl.refl<0.)?vec3(1):mtrl.col;\n    vec3 col=mtrl.col;\n    if(mat==FLOOR) {\n        col+=(texture(iChannel0,pos.xy*2.,-1.2).x-.5)*.3;\n        //col*=.9+.2*texture(iChannel2,pos.xy*.2).xyz;\n        #ifdef WET_ASPHALT\n        col*=.35+.65*step(-.66,pos.z);\n        fres=fres0*mix(-mtrl.refl,1.,(1.-smoothstep(-.661,-.659,pos.z))*exp(-length(pos.xy)/50.));\n        #endif\n    }\n\n    float zr=length(pos-pos0)/300.;\n    //diff=sqrt(diff);\n\n    outfres=fres;\n    if(glassfres!=0.) outfres=glassfres;\n    fres*=reflections;\n    glassfres*=reflections;\n\n    outao=ao;\n    \n\tvec3 bg=myenv(pos0,dir,1.).xyz;\n\t// diff, ao, refl\n\tvec3 finalcol = mix(col,rcol*refl,fres)*mix(vec3(1.2,1.4,1.5)*.35,vec3(1.,1,.9),diff)*ao*1.5;\n\t//finalcol=col;\n\t// fog\n\t//finalcol = mix(finalcol,bg,1.-exp(-zr));\n\tfinalcol = mix(finalcol,vec3(.35),1.-clamp(exp(-(zr-.1)/2.5),0.,1.));\n\t#ifdef RENDER_GLASS\n\tfinalcol=mix(finalcol*sqrt(1.-glassfres),glassrefl,glassfres);\n\t#endif\n\treturn finalcol;\n}\n\n#ifdef CAM_ANIM\nvec4 camAnim[8] = vec4[] (\n    vec4( 1.5, -2.75,-0.25 ,1.), vec4(0,1.,.1, 0.),\n    vec4(-1.5, -2.75,-0.25 ,1.), vec4(.5,1.,.1, 0.),\n    //vec4(-2., -1.5,-0.25 ,1.), vec4(1.,0.,.1, 0.),\n    vec4(-2., 3.,-0.35 ,1.), vec4(.5,-1,.1, 0.),\n    vec4(-2., 3.,-0.35 ,1.), vec4(.5,-1,.1, 0.)\n    );\n    \nvec3 getCamAnimPos(float t)\n{\n    t*=.1;\n    int i_f=int(t); float fact=fract(t); int i_c=i_f+1;\n    i_c=min(3,i_c);\n    i_f=min(3,i_f);\n    return mix(camAnim[i_f*2].xyz,camAnim[i_c*2].xyz,fact);\n}\n\nvec3 getCamAnimDir(float t)\n{\n    t*=.1;\n    int i_f=int(t); float fact=fract(t); int i_c=i_f+1;\n    i_c=min(3,i_c);\n    i_f=min(3,i_f);\n    return mix(camAnim[i_f*2+1].xyz,camAnim[i_c*2+1].xyz,fact);\n}\n\nfloat getCamAnimBr(float t)\n{\n    t*=.1;\n    int i_f=int(t); float fact=fract(t); int i_c=i_f+1;\n    i_c=min(3,i_c);\n    i_f=min(3,i_f);\n    return mix(camAnim[i_f*2].w,camAnim[i_c*2].w,fact);\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 sc=(fragCoord-Res*.5)/Res.x;\n    \n    float zoom=1.5+(500.*exp2(-iTime));\n    #ifdef SHADEROO\n    zoom=exp(-iMouseData.z/5000.);\n    #endif\n    zoom*=CamDistFact;\n\n    vec3 CarPos = carTrafoInv(vec3(0),1.);\n    vec3 pos=vec3(0,0,4.5)*zoom;\n    vec3 dir=normalize(vec3(sc,-.8));\n    \n    calcWheelOffsets(-.1,.2);\n    \n    vec4 q=vec4(0,0,0,1);\n    float th=-(iMouse.y-Res.y*.5)/Res.y*6.;\n    float ph=-(iMouse.x-Res.x*.5)/Res.x*10.;\n    if(iMouse.x<1.) { th=1.45; ph=-iTime*.25; }\n    //th=clamp(th,-1.65,1.65);\n    q=multQuat(q,axAng2Quat(vec3(0,0,1),ph));\n    q=multQuat(q,axAng2Quat(vec3(1,0,0),th));\n    pos=transformVecByQuat(pos,q)-vec3(0,0,.2);\n    dir=transformVecByQuat(dir,q);\n    pos=camTrafoInv(pos,1.);\n    // get camera out of terrain\n    for(int i=0; i<50 ; i++) {  float d=distTerr(pos); if (d>.1) break; pos+=normalize(getGradTerr(pos,.01))*max(d,.1); }\n    // make sure cam is always above ground\n    //pos.z=max(hTerr(pos)-.6,pos.z);\n    dir=camTrafoInv(dir,0.);\n\n    #ifdef CAM_ANIM\n    if(iMouse.x<1.)\n    {\n        pos=getCamAnimPos(iTime);\n        dir=normalize(getCamAnimDir(iTime));\n        vec3 right=normalize(cross(dir,vec3(0,0,1)));\n        vec3 up=cross(right,dir);\n        dir=normalize(dir+right*sc.x+up*sc.y);\n    }\n    #endif\n\n    vec3 pos0=pos;\n    float m=march(pos,dir);\n    \n    float refl=1.;\n    #ifdef RENDERED_REFECTIONS\n    refl=0.;\n    #endif\n    \n    float fres=0., ao=0.;\n    #ifdef ENABLE_MATERIALS\n        fragColor.xyz=lighting(pos,dir,pos0,refl,fres,ao);\n    #else\n        vec3 g=getGrad(pos,.001);\n        vec3 n=g/(length(g)+.00001);\n        enable_car=true;\n        ao=.5*clamp(dist(pos+n*.5)/.5,0.,1.)+.5*clamp(dist(pos+n*.25)/.25,0.,1.);\n        //ao=clamp(dist(pos+n*.5)/.5,0.,1.)*clamp(dist(pos+n*.25)/.25,0.,1.);\n        vec3 rdir=reflect(dir,n);\n        //pos+=n*.001;\n        //float sh=march(pos,reflect(dir,n));\n        fres=1.-abs(dot(rdir,n));\n        fres*=fres*fres;\n        fres=fres*.7+.3;\n        vec3 r=myenv(vec3(0),rdir,1.).xyz*.5;\n        //fragColor.xyz=mix((.3*n+.6)*(ao*.7+.3),r,fres);\n        //fragColor.xyz=vec3(1,.85,.6)*(dot(n,normalize(vec3(1,-1,1)))*.4+.1*n+.5)*(ao*.7+.3)+r*fres;\n        fragColor.xyz=mix(\n                        vec3(1.,.6,.4)*(1.+r*.6),\n                        vec3(.2,.4,.3)*.6,\n                        1.-(ao)*.7\n                        )*(dot(n,normalize(vec3(1,-1,1)))*.3+.1*n+.7)*1.;\n        //fragColor.xyz=mix(fragColor.xyz,vec3(.8,.9,1),.25*exp(-m));\n        //*(ao*.7+vec3(.1,.4,.2))*(.5+r*2.);\n    #endif\n    \n    #ifdef RENDERED_REFECTIONS\n    enable_glass=true;\n    vec3 n=getGrad(pos,.001);\n    if (length(n)<.001) n=vec3(0,0,1);\n    n=normalize(n);\n    fragColor.xyz=n*.5+.5;\n    dir=reflect(dir,n);\n    pos+=dir*.003;\n    float mat=distM(pos).y;\n    march(pos,dir);\n    float dummyfres,dummyao;\n    vec3 lcol=lighting(pos,dir,pos0,1.,dummyfres,dummyao);\n    fragColor.xyz=mix(fragColor.xyz,lcol,(m!=0.)?0.:fres);\n\n    #ifdef CAM_ANIM\n    fragColor*=1.-exp(-getCamAnimBr(iTime)*getCamAnimBr(iTime)/.01);\n    #endif\n    //fragColor=myRandInterpol(fragCoord/iResolution.xy*.1);\n    #endif\n\n    fragColor.xyz=mix(myenv(vec3(0),dir,1.).xyz,fragColor.xyz,exp2(-abs(dist(pos))/10.));\n    \n\tfragColor.w=1.;\n}\n\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// created by florian berger (flockaroo) - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// physics driving sim\n\n//#ShaderooNumPasses 1\n#define NumPasses 1\n\n#define RandTex iChannel2\n#define PhysTex iChannel0\n#ifdef SHADEROO\n#include Include_A.glsl\n#endif\nvec4 myRandInterpol(vec2 uv)\n{\n    //#define COARSE_TERRAIN\n    #ifdef COARSE_TERRAIN\n    return textureLod(RandTex,uv,0.);\n    #endif\n    uv=fract(uv);\n    ivec2 c0 = ivec2(fract(uv        )*256.);\n    ivec2 c1 = ivec2(fract(uv+1./256.)*256.);\n    vec2  f = fract(uv*256.);\n    vec4 c00=texelFetch(RandTex,ivec2(c0.x,c0.y),0);\n    vec4 c10=texelFetch(RandTex,ivec2(c1.x,c0.y),0);\n    vec4 c01=texelFetch(RandTex,ivec2(c0.x,c1.y),0);\n    vec4 c11=texelFetch(RandTex,ivec2(c1.x,c1.y),0);\n    //f=mix(f,.5-.5*cos(f*PI2*.5),.5);\n    f=.5-.5*cos(f*PI2*.5);\n    return mix(mix(c00,c10,f.x),mix(c01,c11,f.x),f.y);\n}\n\nconst vec3 terrbbpos=vec3(0,.0,.0);\n#ifdef CHAIN_WORLD\nconst vec3 terrbbsize=vec3(260.,260.,60.)*2.+50.;\n#else\nconst vec3 terrbbsize=vec3(0);\n#endif\n\nfloat distTerr(vec3 p)\n{\n    vec3 p2=p*.0001;\n    vec4 noise = vec4(0);\n    float sc;\n    sc=1.; \n    for(int i=0;i<3;i++)\n    {\n        noise += (myRandInterpol(p2.xy*sc)-.5)/sc;\n        noise += (myRandInterpol(p2.yz*sc)-.5)/sc;\n        noise += (myRandInterpol(p2.zx*sc)-.5)/sc;\n        sc*=2.;\n    }\n    noise += abs(myRandInterpol(p2.xy*sc*5.)-.5)/sc/5.;\n    noise += abs(myRandInterpol(p2.yz*sc*5.)-.5)/sc/5.;\n    noise += abs(myRandInterpol(p2.zx*sc*5.)-.5)/sc/5.;\n    \n    #if   defined(CHAIN_WORLD)\n    return distChainCircle(p+noise.xyz*10.,200., 6, 60.,20.,20.);\n    #elif defined(TORUS2_WORLD)\n    return min(distTorus(p+noise.xyz*10.,100.,40.),distTorus((p-vec3(100,0,0)).zxy+noise.xyz*10.,100.,40.));\n    #elif defined(TORUS_WORLD)\n    return distTorus(p+noise.xyz*10.,100.,40.);\n    #elif defined(HOLLOW_SPHERE_WORLD)\n    return -length(p+noise.xyz*10.)+100.;\n    #elif defined(SPHERE_WORLD)\n    return length(p+noise.xyz*10.)-60.;\n    #elif defined(PLANE_WORLD)\n    return dot(p+noise.xyz*10.,normalize(vec3(1,.5,.7)));\n    #elif defined(HOLLOW_TORUS)\n    return -distTorus(p+noise.xyz*10.,100.,40.);\n    #else\n    return p.z+noise.x;\n    #endif\n}\n\n/// my own version of a looped getGrad()\nvec3 getGradTerr4loop(vec3 p,float delta)\n{\n    vec4 d=vec4(0,0,0,1); \n    vec3 s=vec3(0);\n    // use a loop here keep compiler from inlining this in win (thanks iq for the hint!)\n    for(int i=min(0,iFrame);i<4;i++)\n    {\n      \ts+=(d.xyz-d.w)*distTerr(p+d.xyz*delta);\n        d=d.wxyz;\n    }\n    return s/delta;\n}\n\n// straight fwd gradient - windows dont like this... wtf...\nvec3 getGradTerr0(vec3 p,float delta)\n{\n    vec3 d=vec3(delta*.5,0,0);\n    return vec3(\n        distTerr(p+d.xyz)-distTerr(p-d.xyz),\n        distTerr(p+d.zxy)-distTerr(p-d.zxy),\n        distTerr(p+d.yzx)-distTerr(p-d.yzx)\n        )/delta;\n}\n\n// cheap tetrahedral gradient\nvec3 getGradTerrTetr(vec3 p,float delta)\n{\n    vec3 g=vec3(0);\n    for(int i=min(0,iFrame);i<4;i++) { vec3 v=vec3((i&1)*2-1,(i/2)*2-1,1); vec3 d=v.xxz*v.zyy;  g+=d*distTerr(p+d*delta*.289); }\n    return g/(delta*1.732);\n}\n\n// full straight fwd grad as loop\nvec3 getGradTerr6loop(vec3 p,float delta)\n{\n    vec3 g=vec3(0);\n    vec3 d=vec3(delta*.5,0,0);\n    for(int i=min(0,iFrame);i<6;i++) { g+=d*distTerr(p+d); d=-d.zxy; }\n    return g/(.5*delta*delta);\n}\n\nvec3 getGradTerr(vec3 p,float delta)\n{\n    return getGradTerr6loop(p,delta);\n}\n\n// transform to car coords\nvec3 carTrafo(vec3 p, float translate)\n{\n#ifdef USE_SIMDATA\n    vec4 q=texelFetch(PhysTex,ivec2(3,0),0);\n    vec3 pos=texelFetch(PhysTex,ivec2(0,0),0).xyz;\n    ///offs.z=-hTerr(-offs);\n    //q=multQuat(getTiltQuat(-offs),q);\n    return transformVecByQuat(p-translate*pos,inverseQuat(q));\n#else\n    return p;\n#endif\n}\n\nvec3 carTrafo(vec3 p)\n{\n    return carTrafo(p,1.0);\n}\n\n// transform to world coords\nvec3 carTrafoInv(vec3 p, float translate)\n{\n#ifdef USE_SIMDATA\n    vec4 q=texelFetch(PhysTex,ivec2(3,0),0);\n    vec3 pos=texelFetch(PhysTex,ivec2(0,0),0).xyz;\n    //offs.z=-hTerr(-offs);\n    //q=multQuat(getTiltQuat(-offs),q);\n    return transformVecByQuat(p,q)+pos*translate;\n#else\n    return p;\n#endif\n}\n\nvec3 camTrafoInv(vec3 p, float translate)\n{\n#ifdef USE_SIMDATA\n    vec4 q=texelFetch(PhysTex,ivec2(6,0),0);\n    vec3 pos=texelFetch(PhysTex,ivec2(0,0),0).xyz;\n    //offs.z=-hTerr(-offs);\n    //q=multQuat(getTiltQuat(-offs),q);\n    return transformVecByQuat(p,q)+pos*translate;\n#else\n    return p;\n#endif\n}\n\nvoid calcWheelOffsets(float clmin, float clmax)\n{\n    vec3 wp;\n    wp=carTrafoInv(WheelPosFL*vec3(1,1,1)+vec3(0,0,-.3),1.); WheelOffsFL = clamp(-distTerr(wp),clmin,clmax);\n    wp=carTrafoInv(WheelPosFR*vec3(1,1,1)+vec3(0,0,-.3),1.); WheelOffsFR = clamp(-distTerr(wp),clmin,clmax);\n    wp=carTrafoInv(WheelPosRL*vec3(1,1,1)+vec3(0,0,-.3),1.); WheelOffsRL = clamp(-distTerr(wp),clmin,clmax);\n    wp=carTrafoInv(WheelPosRR*vec3(1,1,1)+vec3(0,0,-.3),1.); WheelOffsRR = clamp(-distTerr(wp),clmin,clmax);\n    //hTerr(wp)-wp.z\n}\n\n#define keyTex iChannel1\n#define KEY_I (texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_A (texture(keyTex,vec2((65.5+ 0.)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_W (texture(keyTex,vec2((65.5+22.)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_R (texture(keyTex,vec2((65.5+17.)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_S (texture(keyTex,vec2((65.5+18.)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_D (texture(keyTex,vec2((65.5+ 3.)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_F (texture(keyTex,vec2((65.5+ 5.)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_PLUS  (texture(keyTex,vec2((187.5)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_MINUS (texture(keyTex,vec2((189.5)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_LEFT  (texture(keyTex,vec2(( 37.5)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_RIGHT (texture(keyTex,vec2(( 39.5)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_DOWN  (texture(keyTex,vec2(( 40.5)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_UP    (texture(keyTex,vec2(( 38.5)/256.0,(0.5+0.0)/3.0)).x)\n\n#define CalcTorque(a,r) cross((r),transformVecByQuat((a),iquat)*Mass)/I\n\nfloat mypow(float a, float b) { return exp2(log2(a)*b); }\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    #ifdef ZZT_AS_TEX\n    vec2 uv = fragCoord.xy / Res0;\n    fragColor = zztop((uv*2.-.75)*11.,-1.);\n    #endif\n    \n    if (fragCoord.x>10.) discard;\n    if (fragCoord.y>1.) discard;\n\n    vec3  pos      = texelFetch(PhysTex,ivec2(0,0),0).xyz;\n    vec3  vel      = texelFetch(PhysTex,ivec2(1,0),0).xyz;\n    vec3  omega    = texelFetch(PhysTex,ivec2(2,0),0).xyz;\n    vec4  quat     = texelFetch(PhysTex,ivec2(3,0),0);\n    float SteerAng = texelFetch(PhysTex,ivec2(4,0),0).x;\n    float camDist  = texelFetch(PhysTex,ivec2(4,0),0).y;\n    vec4  wheelRot = texelFetch(PhysTex,ivec2(5,0),0);\n    vec4  camQuat  = texelFetch(PhysTex,ivec2(6,0),0);\n    vec4  iquat = inverseQuat(quat);\n    \n    calcWheelOffsets(-1.2,1.2);\n    \n    float dt=min(max(iTimeDelta/float(NumPasses),.0001),.03);\n    \n    float axDist=3.5;\n    vec3 rearAxPos = vec3(0,1.7,0);\n    \n    //quat=vec4(0,0,0,1);\n    vec3 bx=transformVecByQuat(vec3(1,0,0),quat);\n    vec3 by=transformVecByQuat(vec3(0,1,0),quat);\n    vec3 bz=transformVecByQuat(vec3(0,0,1),quat);\n    \n    vec3 acc=vec3(0);\n    vec3 alpha=vec3(0);\n    \n    float Mass=1000.;\n    vec3 S=vec3(2.,3.2,1.5);\n    vec3 I=vec3(S.y*S.y+S.z*S.z, S.z*S.z+S.x*S.x, S.x*S.x+S.y*S.y)*Mass/12.;\n    float mu = .7;\n    #define GRAVITY 9.81\n    //acc+=GRAVITY*vec3(0,0,-1);\n    acc+=GRAVITY*-normalize(getGradTerr(pos,10.));\n    float SpringOmega=10.;\n    float SpringGamma=20.;\n    \n    vec3 n=normalize(getGradTerr(pos,2.));\n    \n    //float dTerr = (pos.z-hTerr(pos))*n.z;\n    float dTerr1=distTerr(pos+by*1.1-bz*.8);\n    float dTerr2=distTerr(pos-by*1.1-bz*.8);\n    float dTerr = (dTerr1+dTerr2)*.5;\n    \n    float grip=step(0.,.1-dTerr);\n    //float grip=max(step(0.,.1-dTerr1),step(0.,.1-dTerr2));\n    \n    // FIXME: just one central springforce for now\n    //float dTerr=(pos.z-hTerr(pos))*n.z;\n    acc += grip*(0.*GRAVITY+SpringOmega*SpringOmega*(.1-dTerr))*n;\n        \n    // FIXME: just angular spring for now... (use wheel forces instead)\n    alpha -= 150.*grip*cross(transformVecByQuat(n,iquat)*Mass,normalize(vec3(0,.0,1)))/I;\n\n    vec3 dacc=vec3(0);\n    vec3 dalpha=vec3(0);\n    \n    dacc-=30.*grip*(max(KEY_W,KEY_UP)-max(KEY_S,KEY_DOWN))*by;\n    acc+=dacc;\n    \n    // FIXME: get rid of tweak-constant 0.15\n    alpha-=.2*grip*cross(transformVecByQuat(dacc,iquat)*Mass,.5*(WheelPosRL+WheelPosRR))/I;\n        \n    SteerAng*=.91;\n    SteerAng-=(max(KEY_A,KEY_LEFT)-max(KEY_D,KEY_RIGHT))*.05;\n    camDist*=(1.-.02*KEY_PLUS);\n    camDist*=(1.+.02*KEY_MINUS);\n    \n    //quat=multQuat(quat,axAng2Quat(vec3(0,0,1),+.001*SteerAng*dot(vel,by)));\n    \n    vec3 accFrontAxe;\n    vec3 accRearAxe;\n    \n    // friction on front/back tire (one virtual middle tire)\n    for(int i=0;i<2;i++)\n    {\n        vec3 fricDir=vec3(cos(SteerAng),-sin(SteerAng),0);\n        vec3 fricPos=.5*(WheelPosFL+WheelPosFR);\n        if (i==1)\n        {\n            fricDir=vec3(1,0,0);\n            fricPos=.5*(WheelPosRL+WheelPosRR);\n        }\n        // FIXME: this should be +omega ?!\n        vec3 dv = cross(omega,fricPos) + transformVecByQuat(vel,iquat); // speed of wheelpos (by car rotation) + car speed\n        dv = clamp(dot(dv,fricDir)*1.,-4.,4.)*fricDir;  // just component normal to wheel\n        dacc   = -transformVecByQuat(dv,quat)*mu*GRAVITY*grip*.5;\n        dalpha = CalcTorque(dacc,fricPos);\n        if(i==0) accFrontAxe=dacc;\n        if(i==1) accRearAxe=dacc;\n        acc+=dacc;\n        alpha+=dalpha;\n    }\n    \n    // very unphysical mix - so careful with timedelta (or NumPasses)!\n    //camQuat=normalize(mix(quat,camQuat,.95));\n    camQuat=normalize(mix(quat,camQuat,mypow(.95,dt/.0166)));\n\n    if(dTerr<0.) vel-=dot(vel,n)*n*.5;\n    //pos.z=.5+hTerr(pos);\n    //quat=multQuat(getTiltQuat(pos),quat);\n    acc-=.03*vel*length(vel);\n    alpha-=grip*2.*omega*length(omega);\n\n    vel+=acc*dt*.5;\n    pos+=vel*dt;\n    vel+=acc*dt*.5;\n#if 1\n    omega+=alpha*dt*.5;\n    //if (length(omega)>.1) omega=normalize(omega)*.1;\n    if (length(omega)>.001)\n        quat=multQuat(quat,angVec2Quat(omega*dt));\n    omega+=alpha*dt*.5;\n#endif\n    \n    //if(pos.z<hTerr(pos)) \n    vec3 omegaN=dot(omega,n)*n;\n    omega=mix(omegaN,omega,mypow(mix(.98,.85,grip),dt/.0166));\n    omega*=mypow(.99,dt/.0166);\n    //omega=mix(omegaN,omega,mix(.98,.85,grip));\n    //omega*=.99;\n    //vel*=.99;\n    if(length(vel)>.001) vel-=normalize(vel)*.005*dt/.0166;\n    //if(length(vel)<.1) vel=vec3(0);\n    //if(length(omega)<.01) omega=vec3(0);\n    \n    float wheelRadius=(WheelRadiusF+WheelRadiusR)*.5*.5;\n    wheelRot-=-dot(vel,by)*dt/wheelRadius;\n    \n    if(iFrame==0)\n    {\n        pos=vec3(10,300,150);\n        pos-=normalize(getGradTerr(pos,.5))*distTerr(pos);\n        pos-=normalize(getGradTerr(pos,.5))*distTerr(pos);\n        pos-=normalize(getGradTerr(pos,.5))*distTerr(pos);\n        pos-=normalize(getGradTerr(pos,.5))*distTerr(pos);\n        pos+=normalize(getGradTerr(pos,.5))*3.;\n        //pos.z=hTerr(pos)+1.;\n        vel=vec3(0,0,0);\n        quat=normalize(vec4(0.03,0.02,0,1));\n        camQuat=quat;\n        omega=vec3(0);\n        SteerAng=0.;\n        wheelRot=vec4(0);\n        camDist=1.;\n    }\n    \n    if (ivec2(fragCoord)==ivec2(0,0)) fragColor = vec4(pos,1.0);\n    if (ivec2(fragCoord)==ivec2(1,0)) fragColor = vec4(vel,1.0);\n    if (ivec2(fragCoord)==ivec2(2,0)) fragColor = vec4(omega,1.0);\n    if (ivec2(fragCoord)==ivec2(3,0)) fragColor = vec4(quat);\n    if (ivec2(fragCoord)==ivec2(4,0)) fragColor = vec4(SteerAng,camDist,0,1);\n    if (ivec2(fragCoord)==ivec2(5,0)) fragColor = vec4(wheelRot);\n    if (ivec2(fragCoord)==ivec2(6,0)) fragColor = vec4(camQuat);\n    if (ivec2(fragCoord)==ivec2(7,0)) fragColor = vec4(accFrontAxe,0);\n    if (ivec2(fragCoord)==ivec2(8,0)) fragColor = vec4(accRearAxe,0);\n}\n\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// created by florian berger (flockaroo) - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// vodka runner\n\n#define CHAIN_WORLD\n//#define TORUS2_WORLD\n//#define TORUS_WORLD\n//#define HOLLOW_SPHERE_WORLD\n//#define SPHERE_WORLD\n//#define PLANE_WORLD\n//#define HOLLOW_TORUS\n\n// helper functions\n\n#define USE_SIMDATA\n\n#define PI2 6.283185\n#define PIH 1.57079632679\n\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n\n#define ROTM(ang) mat2(cos(ang-vec2(0,PIH)),-sin(ang-vec2(0,PIH)))\n\nvec3 rotZ(float ang, vec3 p) { return vec3(ROTM(ang)*p.xy,p.z); }\nvec3 rotX(float ang, vec3 p) { return rotZ(ang,p.yzx).zxy; }\n\nvec3 getLightDir() { return normalize(1.*vec3(cos(1.+/*iTime+*/vec2(0,1.6)),.81)); }\n\nvec2 scuv(vec2 uv) {\n    float zoom=1.;\n    return (uv-.5)*1.2*zoom+.5; \n}\n\nvec2 uvSmooth(vec2 uv,vec2 res)\n{\n    // no interpolation\n    //return uv;\n    // sinus interpolation\n    return uv+1.*sin(uv*res*PI2)/(res*PI2);\n    // iq's polynomial interpolation\n    vec2 f = fract(uv*res);\n    return (uv*res+.5-f+3.*f*f-2.0*f*f*f)/res;\n}\n\nvec4 inverseQuat(vec4 q)\n{\n    //return vec4(-q.xyz,q.w)/length(q);\n    // if already normalized this is enough\n    return vec4(-q.xyz,q.w);\n}\n\nvec4 multQuat(vec4 a, vec4 b)\n{\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return (v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v ));\n}\n\nvec4 angVec2Quat(vec3 ang)\n{\n    float lang=length(ang);\n    return vec4(ang/lang,1) * sin(vec2(lang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\nvec4 axAng2Quat(vec3 ax, float ang)\n{\n    return vec4(normalize(ax),1)*sin(vec2(ang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\n// iq's sdf primitives\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - (b-r);\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundRect( vec2 p, vec2 b, float r )\n{\n  vec2 q = abs(p) - (b-r);\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\nvec2 sdRoundRect2( vec4 p, vec4 b, vec2 r )\n{\n  vec4 q = abs(p) - (b-r.xxyy);\n  vec4 qp=max(q,0.0);\n  return sqrt(qp.xz*qp.xz+qp.yw*qp.yw) + min(max(q.xz,q.yw),vec2(0)) - r;\n}\n\nfloat sdHalfRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - (b-r);\n  return max((length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r),-p.z);\n}\n\nfloat sdRoundedCylinder( vec3 p, float R, float r, float h )\n{\n  vec2 d = vec2( length(p.xz)-R, abs(p.y) - h*.5 );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n}\n\n// iq's capsule\nfloat sdLine( vec3 p, vec3 a, vec3 b)\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nfloat distTorus(vec3 p, float R, float r)\n{\n    return length(p-vec3(normalize(p.xy),0)*R)-r;\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n  // c is the sin/cos of the angle\n  float q = length(p.xy);\n  return dot(c,vec2(q,p.z));\n}\n\nfloat dDirLine(vec3 p, vec3 c, vec3 dir, float l)\n{\n    p-=c;\n    dir=normalize(dir);\n    float dp=dot(p,dir);\n    //return length(p-dp*dir);\n    return max(max(length(p-dp*dir),-dp),dp-l);\n}\n\nfloat distBox( vec3 p, vec3 halfSize)\n{\n    vec3 q = abs(p) - halfSize;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat distBoxR( vec3 p, vec3 halfSize, float r) { return distBox( p, halfSize-r ) - r ; }\n\nfloat distCyl( vec3 p, float r, float h )\n{\n  vec2 d = vec2( length(p.xy)-r, abs(p.z) - h*.5 );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat distCylR( vec3 p, float r, float h, float R )\n{\n  vec2 d = vec2( length(p.xy)-(r-R), abs(p.z) - (h*.5-R) );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0))-R;\n}\n\n// my own distance experiments...\nfloat distChainSeg(vec3 p, float R, float r, float lh)\n{\n    return length(vec2(length(vec2(max(abs(p.x)-lh,0.),p.y))-R,p.z))-r;\n}\n\nfloat distChainCircle(vec3 p, float RR, int numh, float R, float r, float lh)\n{\n    float ang0=atan(p.y,p.x);\n    float dang=PI2/float(numh)/2.;\n    float fidx=floor(ang0/dang);\n    float angi =(fidx+0.)*dang;\n    float angi2=(fidx+1.)*dang;\n    vec3 pi =vec3(cos(angi -vec2(0,PIH))*RR,0);\n    vec3 pi2=vec3(cos(angi2-vec2(0,PIH))*RR,0);\n    float d=10000.;\n    d=min(d,distChainSeg(rotX(PIH*(fidx+0.),rotZ(-(angi +PIH),p-pi )),R,r,lh));\n    d=min(d,distChainSeg(rotX(PIH*(fidx+1.),rotZ(-(angi2+PIH),p-pi2)),R,r,lh));\n    return d;\n}\n\n// iq's exponantial smooth-min func\nfloat smin( float a, float b, float k )\n{\n    k=3./k;\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n// iq's polynomial smooth-min func\nfloat smin_( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// flatness: // 0->sphere, 100-> nearly cylindric\nfloat distTire(vec3 p, float r, float w, float h, float flatness)\n{\n    float l=length(p.xy);\n    //p=abs(p);\n    float d=1000.;\n    // outer sphere\n    float rfl=r*(1.+flatness);\n    d=min(d,length(vec2(l+rfl-r,p.z))-rfl);\n    float rz=-(rfl-r)+sqrt(rfl*rfl-p.z*p.z);\n    //d=min(d,l-rz);\n    float ang = atan(p.x,p.y);\n    p.z+=cos(ang*64.)*w*.01*smoothstep(.87*r,1.*r,l);\n    // main torus\n    d=max(d,length(vec2(l-r+h*.5,p.z))-w*.5);\n    //d=max(d,-l+r*.61);\n    float w_l=sqrt(w*w-h*h); // w_laufflaeche\n    float dz=.243*w_l;\n    float zfr=mod(p.z,dz);\n    float z=p.z-zfr+dz*.5;\n    // rillen\n    d=max(d,-length(vec2(l-rz,p.z-z))+dz*.2);\n    // rim radius\n    d=max(d,-(l-(r-h)));\n    return d;\n}\n\nfloat distRim(vec3 p, float r, float w, float sh)  // outer rim radius, rim width;\n{\n    vec3 p0=p;\n    p.z=abs(p.z);\n    float ang0 = atan(p.y,p.x);\n\n    float d=1000.,d2,d3;\n    float dmain=length(p.xy)-r-sh;\n    float dplane=-p.z+w*.5;\n    d=-smin_(dplane,-dmain,.005);\n    \n    d2=-smin_(-(dmain+.005),-(dplane-.005),.01);\n    d=-smin_(-d,d2,.01);\n    \n    d2=-smin_(-(dmain+.02),-(dplane-.02),.01);\n    d=-smin_(-d,d2,.01);\n    \n    d2=dmain+.04;\n    d=-smin_(-d,d2,.01);\n    \n    dplane=-p0.z+w*.5;\n    d2=-smin_(-(dmain+.04),dplane+.015,.1);\n    float c5=cos(ang0*5.);\n    c5=-c5*.5+.5;\n    c5*=c5;\n    c5*=c5;\n    c5=1.-c5;\n    c5=mix(c5,0.,1.-clamp(((dmain+r+sh)-.045)/.03,0.,1.));\n    d3=-smin_(-(dmain+.115),-(dplane-.01*(.8+.5*c5)),.04);\n    d2=abs(-smin_(-d2,d3,.01))-.0015;\n    d2=max(d2,-p0.z-.01);\n    //d2=min(d2,);\n    d=min(d,d2);\n    \n    //d2=-smin_(-(dmain+.125),-(dplane-.015),.02);\n    //d=-smin_(-d,d2,.01);\n    \n    //return d;\n\n    ////d=max(d,-(distCyl(p-vec3(0,0,w*.5),r-sh*.5-.005,w*.05-.005)-.005));\n    //d2=length(p-vec3(0,0,+w*.03+r*1.5))-r*1.5;\n    //d2=-smin_(-d2,-(distCyl(p-vec3(0,0,0),r-sh*1.2-.005,w*1.-.005)-.005),.005);\n    //d=-smin(-d,d2,.01);\n    //return d;\n\n    float mang,ang;\n    float dang;\n\n    // rim holes\n    dang=PI2/12.;\n    mang=mod(ang0,dang);\n    ang=ang0-mang+dang*.5;\n    vec2 cs=cos(ang-vec2(0,PIH));\n    d=max(d,-distCyl(p-vec3(r*.65*cs*(1.+3.*p.z),0.),.085*r,w*1.5));\n    \n    p=p0-vec3(0,0,.07);\n    \n    // screw holes\n    dang=PI2/5.;\n    mang=mod(ang0+dang*.5,dang);\n    ang=ang0-mang+dang*.5;\n    d2=distCyl(p-vec3(r*.3*cos(ang-vec2(0,PIH)),w*.05),.016,w*.19);\n    //d=max(d,-d2);\n    // screws\n    d=min(d, d2+.005);\n\n    // axle\n    d=min(d, distCyl(p,.045-.01,w*.25-.01)-.01);\n    return d;\n}\n\nfloat distWheelDim(vec3 p, float w_mm, float h_perc, float rimD_inch, float shoulder_mm, float flatness)\n{\n    float w=w_mm*.001;\n    float h=w*h_perc/100.;\n    float d=10000.,d2;\n    float rrim=rimD_inch*.5*.0254;\n    d2=distTire(p, rrim+h, w, h, flatness );\n    d=min(d,d2);\n    float rimw=sqrt(w*w-h*h)+shoulder_mm*.001*2.5;\n    d2=distRim(p, rrim, rimw, shoulder_mm*.001 );\n    d=min(d,d2);\n    return d;\n}\n\n\nbool intersectBox(vec3 p, vec3 dir, vec3 size)\n{\n    size*=.5*sign(dir);\n\n    vec3 vmin = (-size-p)/dir;\n    vec3 vmax = ( size-p)/dir;\n    \n    float tmin=vmin.x, tmax=vmax.x;\n    \n    if ((tmin > vmax.y) || (vmin.y > tmax)) return false; \n    tmin=max(tmin,vmin.y);\n    tmax=min(tmax,vmax.y);\n \n    if ((tmin > vmax.z) || (vmin.z > tmax)) return false; \n    tmin=max(tmin,vmin.z);\n    tmax=min(tmax,vmax.z);\n \n    return true; \n}\n\nvec2 ROT(float ang, vec2 v) \n{ \n    vec2 cs=sin(vec2(1.6,0)+ang); \n    return mat2(cs,cs.yx*vec2(-1,1))*v;\n}\n\nfloat bigZ(vec2 p)\n{\n    vec2 p0=p;\n    \n    p=ROT(-.05,p);\n    \n    p+=vec2(0,.7);\n    //float falloff=exp(-dot(p,p));\n    float falloff=1./(1.+dot(p,p)*2.);\n    p=ROT(-PI2*.2*falloff*p.y,p-vec2(0,.7));   // locally rotate around x by 180 degrees\n\n    p.x+=.7*p.y;\n    \n    //p.x-=p.y;\n    p=-sign(p.y+p.x)*p;\n    \n    float d=abs(max(-p.y-.5,p.x));\n    d-=.04+.1/(1.+dot(p0,p0)*3.)+.03*min(p0.x,0.);\n    return d;\n}\n\nfloat fermi(float x)\n{\n    return 1./(1.+exp(-x));\n}\n\n\n#define RUMPFW 1.3\n#define ALLW (RUMPFW*1.3)\n\n#define WheelDistF (1.44)\n#define WheelDistR (1.42)\n#define WheelPosFR (vec3(-WheelDistF*.5,-1.25,-.50))\n#define WheelPosRL (vec3( WheelDistR*.5, 1.05,-.50))\n#define WheelPosFL (vec3( WheelDistF*.5,-1.25,-.50))\n#define WheelPosRR (vec3(-WheelDistR*.5, 1.05,-.50))\n\nvec4 wheelOffs=vec4(0);\n#define WheelOffsRL wheelOffs.x\n#define WheelOffsRR wheelOffs.y\n#define WheelOffsFL wheelOffs.z\n#define WheelOffsFR wheelOffs.w\n\n#define WheelRadiusF .62\n#define WheelRadiusR .7\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjcRz.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[705, 705, 735, 764, 1314], [1466, 1466, 1490, 1490, 2629], [2631, 2672, 2715, 2715, 2987], [2989, 3049, 3088, 3088, 3289], [3291, 3321, 3363, 3363, 3542], [3544, 3578, 3621, 3621, 3776], [3778, 3778, 3816, 3816, 3856], [3858, 3885, 3925, 3925, 4201], [4203, 4203, 4226, 4226, 4256], [4258, 4287, 4330, 4330, 4592], [4594, 4594, 4637, 4637, 4899], [4901, 4901, 4950, 4950, 5422], [8697, 8697, 8719, 8719, 8918], [8920, 8920, 8946, 8946, 9182], [9184, 9184, 9258, 9258, 9600], [9602, 9602, 9674, 9674, 9796], [9798, 9798, 9896, 9896, 10515], [10517, 10517, 10544, 10544, 11720], [11806, 11852, 11899, 11899, 13319], [13322, 13322, 13355, 13355, 13755], [13758, 13758, 13790, 13790, 14945], [15184, 15184, 15216, 15216, 15251], [15252, 15252, 15283, 15347, 15432]], "test": "untested"}
{"id": "tdjyRz", "name": "Domain Remapping Example", "author": "GabrielFelix", "description": "Just an exemple of how domain remapping can be applied;", "tags": ["beginner"], "likes": 4, "viewed": 506, "published": 3, "date": "1586015777", "time_retrieved": "2024-07-30T21:14:57.083724", "image_code": "float domainRemapping(float minInput, float maxInput, float minOutput, float maxOutput, float domain)\n{\n    //normalize domain (put it into the 0-1 range)\n    float normalizedDomain = (domain - minInput) / (maxInput - minInput);\n    \n    //use lerp\n    return minOutput * (1. - normalizedDomain) + maxOutput * normalizedDomain;\n    \n    //I found a new method today thay requires less calculations, very interesting!\n    //return normalizedDomain * (maxOutput - minOutput) + minOutput;  \n}\n\n\nvec3 Rectangle(vec2 uv, vec4 size, vec3 color, vec2 position, float blur)\n{\n\t//size input order: left right up down\n    uv -= position;\n    \n    float left = smoothstep(size.x - blur, size.x + blur, uv.x);\n    float right = smoothstep(size.y + blur, size.y - blur, uv.x);\n    \n    float up = smoothstep(size.z - blur, size.z + blur, uv.y);\n    float down = smoothstep(size.w + blur, size.w - blur, uv.y);\n    \n    \n    return (left * right * up * down) * color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    //building the rectangle\n    vec4 size = vec4(-.3, .3, -.3, .3);\n    vec3 color = vec3(1., 1., 1.);\n    vec2 position = vec2(0., 0.);\n    float blur = domainRemapping(-.3, .3, 0.001, 0.1, uv.y);\n    \n    vec3 rect = Rectangle(uv, size, color, position, blur); \n    \n    // Output to screen\n    fragColor = vec4( rect ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjyRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 103, 154, 489], [492, 492, 567, 607, 955], [958, 958, 1015, 1015, 1441]], "test": "untested"}
{"id": "WdfcW2", "name": "Hyperoctahedron Tutorial", "author": "mla", "description": "Follow up to [url]https://www.shadertoy.com/view/wdfyDj[/url]. As promised, here's a 4D version, ie. a hyperoctahedron or 16-cell. Mouse moves things around.", "tags": ["tutorial", "sierpinski", "hyperoctahedron"], "likes": 10, "viewed": 390, "published": 3, "date": "1586012672", "time_retrieved": "2024-07-30T21:14:58.102002", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Sierpinski Hyperoctahedron Tutorial\n//\n// Matthew Arcus, 2020.\n//\n// A follow on to https://www.shadertoy.com/view/wdfyDj, in which we\n// do essentially the same thing, the Sierpinski construction on an\n// octahedron, but going up to 4-dimensional space (R4) and using\n// stereographic projection to get back to 3 dimensions (R3). Now we\n// are dealing with a hyperoctahedron or 16-cell, but the calculations\n// remain essential the same.\n//\n// As before, heavily annotated in tutorial style. The main changes\n// are in the DE function itself and the raymarcher, which now has a\n// more demanding job to do.\n//\n// No controls, apart from mouse rotation: config changes need recompilation.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// As before. Start off with some global variables.\n\nbool dorotate = false;  // Autorotate scene\nbool ctranslate = true; // Do Clifford translation\n\n// To see what is going on better, set the 'nofold' option to just see a single\n// tetrahedral hyperface. Reduce eyedist eg. to 2.0 to see this better.\nbool nofold = false;\nfloat eyedist = 10.0;     // Distance of eye from origin\nvec3 light = vec3(0,2,1); // Light direction\nint numsteps = 200;       // Maximum raymarching steps\nfloat precis = 1e-3;      // Raymarching precision\nfloat lfactor = 0.8;      // \"Lipschitz\" factor\nfloat eradius = 0.015;    // Radius of edge\nfloat pradius = 0.05;     // Radius of point\n\nint level = 2;            // Sierpinski division level, 0, 1 or 2\n\nfloat PI = 3.1415927;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n//#define assert(x)\n\n// The outer wrapper is the same as the octahedron shader, so let's\n// start with the DE function.\n\n// Auxiliary functions\n// Spherical distance between points on hypersphere\nfloat sdistance(vec4 p, vec4 q);\n// Spherical distance from p to great circle through q and r\nfloat ssegment(vec4 p, vec4 q, vec4 r); \n\nvec4 stereographic(vec3 p3, inout float scale); // Stereographic projection\nvec4 qmul(vec4 p, vec4 q); // Quaternion multiplication\n\n// To draw a 4-dimensional figure, we use stereographic projection to\n// map the figure into R3 (or rather, use the inverse to find what\n// point in R4 is mapped to the R3 point under consideration).\n//\n// Inverse stereographic projection uses a projection point of\n// (0,0,0,1), (the 'north hyperpole') to project points on the w=0\n// hyperplane (ie. the normal embedding of R3 in R4) onto the unit\n// hypersphere. We can also represent this as an inversion in a\n// sphere, centre (0,0,0,1), radius sqrt(2) and that is how we\n// calculate it here.\n\n// The stereographic projection, and inversions generally, are\n// conformal, in that at each point the scale factor is the same in\n// all directions - this is important for ray marching as it means\n// that after applying a conformal map, we just need to multiply the\n// DE by the appropriate scale factor to get a coherent DE for the\n// mapped surface, with the caveat that the scale factor will vary\n// over the course of the ray, but provided it doesn't vary too much,\n// we can deal with this by reducing the step size by a small fiddle\n// factor, or by ensuring that large steps get clamped to something\n// less likely to lead to overshooting the surface. ('Lipschitz\n// continuity' is very relevant here).\n\nfloat de(vec3 p3, out int type) {\n  float scale = 1.0;\n  vec4 p = stereographic(p3,scale);\n\n  if (ctranslate) {\n    // Apply a rotation in R4 with a quaternion.\n    // Quaternions represent rotations (and reflections) in R4 just as\n    // well as in R3, with p -> qpr, for quaternions q and r\n    // representing a general rotation. Here we multiply by a single\n    // quaternion, giving a \"Clifford translation\" which after\n    // stereographic projection appears as a screw motion - a rotation\n    // combined with a translation along the rotation axis (here the\n    // vertical y-axis).\n    // https://en.wikipedia.org/wiki/William_Kingdon_Clifford\n    float t = 0.1*iTime;\n    // The 'normalize' here shouldn't be necessary, but sin and cos\n    // can be relatively inaccurate.\n    vec4 Q = normalize(vec4(sin(t)*vec3(0,1,0),cos(t)));\n    p = qmul(p,Q);\n  }\n\n  // Exactly as with the octahedron, set p = abs(p), reflecting\n  // everything into the positive sector and into a single\n  // (tetrahedral) hyperface. Then sort the coordinates to\n  // take everything into a small sector around vertex A(1,0,0,0).\n  if (!nofold) p = abs(p);\n  // Sort the coordinates\n  if (p.x < p.y) p.xy = p.yx;\n  if (p.z < p.w) p.zw = p.wz;\n  if (p.x < p.z) p.xz = p.zx;\n  if (p.y < p.w) p.yw = p.wy;\n  if (p.y < p.z) p.yz = p.zy;\n  // Check all is well. On my laptop there is a weird bug where if\n  // these assertions are removed, the sort doesn't get done\n  // properly.\n  assert(p.x >= p.y);\n  assert(p.y >= p.z);\n  assert(p.z >= p.w);\n\n  // The tetrahedron is on the hyperplane x+y+z+w = 1, but we need to\n  // project everything onto the hypersphere, with |p| = 1, so though\n  // we do our calculations on the hyperplane, we normalize\n  // before drawing anything (we could do this in the drawing\n  // functions, but it's more efficient to do it once and for all\n  // here).\n\n  // The main tetrahedron, (A,B,C,D). Just a normal R3 equilateral\n  // tetrahedron with side length sqrt(2), it just happens to be in\n  // R4 rather than R3 (like the equilateral triangle side of the\n  // octahedron in the earlier shader).\n  vec4 A = vec4(1,0,0,0);\n  vec4 B = vec4(0,1,0,0);\n  vec4 C = vec4(0,0,1,0);\n  vec4 D = vec4(0,0,0,1);\n  // The 'corner' tetrahedron, (A1,B1,C1,D1), that we want to\n  // subdivide in turn.\n  vec4 A1 = A;\n  vec4 B1 = 0.5*(A+B);\n  vec4 C1 = 0.5*(A+C);\n  vec4 D1 = 0.5*(A+D);\n\n  //  It has 6 edges, with 6 midpoints, but we only need these 4.\n  vec4 AB1 = 0.5*(A1+B1);\n  vec4 AC1 = 0.5*(A1+C1);\n  vec4 BC1 = 0.5*(B1+C1);\n  vec4 BD1 = 0.5*(B1+D1);\n\n  // Normalize to hypersphere for drawing. I expect the compiler\n  // can constant fold these.\n  A1 = normalize(A1);\n  B1 = normalize(B1);\n  C1 = normalize(C1);\n  D1 = normalize(D1);\n\n  AB1 = normalize(AB1);\n  AC1 = normalize(AC1);\n  BC1 = normalize(BC1);\n  BD1 = normalize(BD1);\n\n  // Now draw the points and lines, to the desired level.\n  float d = 1e8, d0 = d;\n  for (;;) { \n    d = min(d,ssegment(p,A,B)-eradius);\n    if (level == 0) break;\n    d = min(d,ssegment(p,B1,C1)-eradius);\n    if (level == 1) break;\n    d = min(d,ssegment(p,AB1,BC1)-eradius);\n    d = min(d,ssegment(p,AC1,AB1)-eradius);\n    d = min(d,ssegment(p,BC1,BD1)-eradius);\n    break;\n  }\n  if (d < d0) type = 0; d0 = d;\n\n  for (;;) { \n    d = min(d,sdistance(p,A)-pradius);\n    if (level == 0) break;\n    d = min(d,sdistance(p,B1)-pradius);\n    if (level == 1) break;\n    d = min(d,sdistance(p,AB1)-pradius);\n    d = min(d,sdistance(p,BC1)-pradius);\n    break;\n  }\n  if (d < d0) type = 1; d0 = d;\n\n  // Finally return the distance, but taking into account the\n  // scaling factor from the stereographic projection.\n  return d/scale;\n}\n\n// The revised raymarcher - this now has a much harder job to do - the\n// surface can now extend out as far as the eye can see and even pass\n// through the eye point itself, and the surface itself is more\n// complex so we must tread carefully. As mentioned above, its a good\n// idea to use a 'Lipschitz' factor to reduce the step size and also\n// keep the step below some limit. To avoid many inefficient small\n// steps when stepping out to a distant point, the limit should be\n// dependent on the distance travelled so far, and the desired\n// precision should also be distance dependent for similar reasons.\n\n// Another problem to deal with here is negative steps, which as our\n// DE function is signed, will happen and are usually a good thing -\n// but if we find ourselves stepping backwards past the eye point,\n// then we should give up - this can easily happen if the surface can\n// passes through the eye point, for example.\n\n// Of course, all these cautious changes means that we might\n// need to do more steps, so increase numsteps accordingly - we can\n// still use our assertion to see how many steps are actually being\n// taken and find that 50 or fewer usually suffice.\n\nfloat de(vec3 p) { int t; return de(p,t); }\n\nfloat march(vec3 q, vec3 r) {\n  float t = 0.01; // Total distance so far.\n  float maxdist = eyedist + 10.0;\n  for (int i = 0; i < numsteps; i++) {\n    //assert(i < 50);\n    vec3 p = q+t*r;\n    float d = de(p);\n    if (abs(d) < t*precis) return t;\n    d = min(d,max(0.5,0.5*t));\n    t += lfactor*d;\n    // We can go backwards!\n    if (t < 0.0 || t > maxdist) break;\n  }\n  return -1.0;\n}\n\n// Measuring distances on the hypersphere: this is done just like on a R3\n// sphere, measuring along a great circle route, so the dot product of\n// the two vectors gives the cosine of the angle between them, and the\n// spherical distance is just that angle.\nfloat sdistance(vec4 p, vec4 q) {\n  // acos gives the correct answer, but the Euclidean distance\n  // is a good approximation, particularly up close. The result is\n  // visually indistinguishable and acos is expensive (the Euclidean\n  // distance is an underestimate of the spherical distance, which is\n  // just what we want for raymarching).\n  //return acos(clamp(dot(p,q),-1.0,1.0));\n  return distance(p,q);\n}\n\n// Find the (spherical) distance from p to the line (great circle)\n// through q and r. Again, this is almost the same calculation as in\n// R3 - find the nearest point on the line to p by projecting p onto\n// the qr-plane and normalizing, then after checking the point is in\n// bounds, return the spherical distance to that point.\nfloat ssegment(vec4 p, vec4 q, vec4 r) {\n  // Map p to the plane defined by q and r (and the origin):\n  // p = aq + br + x, where q.x = r.x = 0 so:\n  // p.q = aq.q + br.q and:\n  // p.r = aq.r + br.r\n  // Solve by inverting a 2x2 matrix.\n  mat2 m = inverse(mat2(dot(q,q),dot(q,r),dot(q,r),dot(r,r)));\n  vec2 ab = m*vec2(dot(p,q),dot(p,r));\n  ab = max(ab,0.0); // Clamp to segment\n  // p1 in plane of q,r, on hypersphere\n  vec4 p1 = normalize(ab[0]*q + ab[1]*r);\n  // And return the distance to the closest point.\n  return sdistance(p,p1);\n}\n\n// Get the normal of the surface at point p.\nvec3 getnormal(vec3 p, float t) {\n  float eps = 1e-2;\n  vec2 e = vec2(eps,0);\n  return normalize(vec3(de(p + e.xyy) - de(p - e.xyy),\n                        de(p + e.yxy) - de(p - e.yxy),\n                        de(p + e.yyx) - de(p - e.yyx)));\n}\n\nvec4 invert(vec4 p, vec4 q, float r2, inout float scale) {\n  // Invert p in circle, centre q, radius square r2.\n  // Return inverted point and multiply scale by scaling factor.\n  p -= q;\n  float k = r2/dot(p,p);\n  p *= k;\n  scale *= k;\n  p += q;\n  return p;\n}\n\nvec4 stereographic(vec3 p, inout float scale) {\n  return invert(vec4(p,0),vec4(0,0,0,1),2.0,scale);\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\n// Quaternion multiplication\n// (p+P)(q+Q) = pq + pQ + qP + PQ\nvec4 qmul(vec4 p, vec4 q) {\n  vec3 P = p.xyz, Q = q.xyz;\n  return vec4(p.w*Q+q.w*P+cross(P,Q),p.w*q.w-dot(P,Q));\n}\n\nvec3 getbackground(vec3 r) {\n  //return r; // Colourful fun\n  return vec3(0); // The more sober option.\n}\n\nvec3 getbasecolor(int type) {\n  assert(type >= 0);\n  if (type == 0) return vec3(1,1,0.45);\n  if (type == 1) return vec3(0.2);\n  return vec3(1,0,1);\n}\n\n// Rotate according to mouse position\nvec3 transformframe(vec3 p) {\n  if (iMouse.x > 0.0) {\n    // Full range of rotation across the screen.\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  // autorotation - we always rotate a little as otherwise nothing can\n  // be seen (since the z-axis is part of the model).\n  float t = 1.0;\n  if (dorotate) t += iTime;\n  p.yz = rotate(p.yz,-t*0.125);\n  p.zx = rotate(p.zx,-t*0.1);\n  return p;\n}\n\n// Follow ray from q, direction r.\nvec3 raycolor(vec3 q, vec3 r) {\n  float t = march(q,r);\n  if (t < 0.0) return getbackground(r);\n  vec3 p = q+t*r;\n  vec3 normal = getnormal(p,t);\n  int type;\n  de(p,type); // Just to get the object type\n  vec3 color = getbasecolor(type);\n  float ambient = 0.3;\n  vec3 lightdir = normalize(light);\n  float diffuse = 0.7*clamp(dot(normal,lightdir),0.0,1.0);\n  color *= ambient+ diffuse;\n  return color;\n}\n\n// Get the colour for a screen point (with normalized coordinates)\nvec3 screencolor(vec2 z) {\n  vec3 eye = vec3(0,0,eyedist);\n  vec3 ray = vec3(z,-2);\n  eye = transformframe(eye);\n  ray = transformframe(ray);\n  light = transformframe(light);\n  ray = normalize(ray);\n  vec3 col = raycolor(eye,ray);\n  col = pow(col,vec3(0.4545)); // Gamma correction - see elsewhere\n  return col;\n}\n\n// The main function called by Shadertoy\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n  vec2 z = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec3 col = screencolor(z);\n  if (alert) col.r = 1.0; // Check nothing has gone wrong.\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfcW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1639, 1639, 1660, 1660, 1686], [3414, 3414, 3447, 3447, 7074], [8258, 8258, 8276, 8276, 8301], [8303, 8303, 8332, 8332, 8688], [8690, 8948, 8981, 9334, 9360], [9362, 9692, 9732, 9928, 10231], [10233, 10278, 10311, 10311, 10524], [10526, 10526, 10584, 10702, 10785], [10787, 10787, 10834, 10834, 10888], [10890, 10921, 10951, 10951, 10996], [10998, 11061, 11088, 11088, 11175], [11177, 11177, 11205, 11236, 11282], [11284, 11284, 11313, 11313, 11433], [11435, 11473, 11502, 11502, 12014], [12016, 12051, 12082, 12082, 12453], [12455, 12522, 12548, 12548, 12835], [12837, 12878, 12929, 12929, 13103]], "test": "untested"}
{"id": "td2yRR", "name": "Some Simple Waves", "author": "GabrielFelix", "description": "Some Waves", "tags": ["waves", "beginner"], "likes": 2, "viewed": 358, "published": 3, "date": "1586010175", "time_retrieved": "2024-07-30T21:14:58.913831", "image_code": "vec3 Rect(vec2 uv, vec4 size, float blur, vec2 position, vec3 color){\n\t//position: left right up down\n    uv -= position;\n    \n    float left = smoothstep(size.x - blur, size.x + blur, uv.x);\n    float right = smoothstep(size.y + blur, size.y - blur, uv.x);\n    \n    float up = smoothstep(size.z - blur, size.z + blur, uv.y);\n    float down = smoothstep(size.w + blur, size.w - blur, uv.y);\n    \n    \n    return (left * right * up * down) * color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Setup\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //Drawing\n    uv.y += cos(cos(iTime + uv.x) );  \n    vec3 col = Rect(vec2(uv.x, uv.y), vec4(-1., 1, -0.5, 0.1), 0.001, vec2(0., 0.5), vec3(0., 1., 1.));\n    \n    // Output\n    fragColor = vec4(col ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2yRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 69, 101, 449], [452, 452, 509, 521, 831]], "test": "untested"}
{"id": "td2yzR", "name": "Icecream warped FBM", "author": "mrange", "description": "License: CC0\nResult after playing around with warped FBMs for a few hours\nBased on: https://iquilezles.org/articles/warp/warp.htm\n", "tags": ["2d", "fbm", "warp"], "likes": 12, "viewed": 536, "published": 3, "date": "1586007627", "time_retrieved": "2024-07-30T21:14:59.773533", "image_code": "// License: CC0\n//   Result after playing around with warped FBMs for a few hours\n//   Based on: https://iquilezles.org/articles/warp\n\n#define PI    3.141592654\n#define TAU   (2.0*PI)\n#define TTIME (iTime*TAU)\n\nconst mat2 frot = mat2(0.80, 0.60, -0.60, 0.80);\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat noise(vec2 p) {\n  float a = sin(p.x);\n  float b = sin(p.y);\n  float c = 0.5 + 0.5*cos(p.x + p.y);\n  float d = mix(a, b, c);\n  return d;\n}\n\nfloat fbm(vec2 p) {    \n  float f = 0.0;\n  float a = 1.0;\n  float s = 0.0;\n  float m = 2.0;\n  for (int x = 0; x < 4; ++x) {\n    f += a*noise(p); p = frot*p*m;\n    m += 0.01;\n    s += a;\n    a *= 0.5;\n  }\n  return f/s;\n}\n\nfloat warp(vec2 p, out vec2 v, out vec2 w) {\n\n  vec2 vx = vec2(0.0, 0.0);\n  vec2 vy = vec2(3.2, 1.3);\n\n  vec2 wx = vec2(1.7, 9.2);\n  vec2 wy = vec2(8.3, 2.8);\n\n  rot(vx, TTIME/1000.0);\n  rot(vy, TTIME/900.0);\n\n  rot(wx, TTIME/800.0);\n  rot(wy, TTIME/700.0);\n\n  v = vec2(fbm(p + vx), fbm(p + vy));\n  \n  w = vec2(fbm(p + 3.0*v + wx), fbm(p + 3.0*v + wy));\n  \n  return fbm(p + 2.25*w);\n}\n\nvec3 normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(0.0001, 0);\n  \n  vec3 n;\n  n.x = warp(p + e.xy, v, w) - warp(p - e.xy, v, w);\n  n.y = 2.0*e.x;\n  n.z = warp(p + e.yx, v, w) - warp(p - e.yx, v, w);\n  \n  return normalize(n);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= iResolution.x/iResolution.y;\n\n  p += TTIME*0.01;\n  p *= 2.0;\n  vec3 col = vec3(1.0);\n \n  vec2 v;\n  vec2 w;\n \n  float f = warp(p, v, w);\n  vec3 n = normal(p);\n\n  vec3 lig = normalize(vec3(0., 0.2, -0.4));\n  rot(lig.xy, TTIME/10.0);\n  float dif = max(dot(lig, n), 0.5);\n\n  const vec3 col1 = vec3(0.1, 0.7, 0.8);\n  const vec3 col2 = vec3(0.7, 0.3, 0.5);\n  \n  col = pow(dif, 0.75)*tanh(pow(abs(f + 0.5), 1.5)) + (length(v)*col1 + length(w)*col2);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2yzR.jpg", "access": "api", "license": "cc0-1.0", "functions": [[261, 261, 294, 294, 379], [381, 381, 402, 402, 524], [526, 526, 545, 545, 745], [747, 747, 791, 791, 1131], [1133, 1133, 1154, 1154, 1366], [1368, 1368, 1423, 1423, 1970]], "test": "untested"}
{"id": "WslcDj", "name": "KIFS fractal from a tutorial", "author": "maksy", "description": "KIFS fractal based on BigWing's tutorial\nhttps://www.youtube.com/watch?v=il_Qg9AqQkE", "tags": ["kifs"], "likes": 1, "viewed": 344, "published": 3, "date": "1586000733", "time_retrieved": "2024-07-30T21:15:00.740946", "image_code": "vec2 N(float angle) {\n\treturn vec2(sin(angle), cos(angle));\n}\n\n// Rotate around an arbitrary line by the given angle\nvec2 rotate(vec2 uv, vec2 center, float angle, bool side) {\n\n  \t// reflects a point to the other side of a line. Distance to the line\n   \t// is given by dot(uv, n) where n is the orientation of the line\n   \t// min/max makes sure that the only one side of the line will be reflected\n    \n    vec2 n = N(angle * 3.14159);\n    float d = dot(uv - center, n);\n    \n    if (side) {\n\t    uv -= n * max(0., d) * 2.;\n    } else {\n        uv -= n * min(0., d) * 2.;\n    }\n    return uv;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n   \n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.);\n    \n    // zoom out\n    uv *= 1.25;\n    \n    // mirror on y axis. This adds the folded line to the lower left corner also\n    uv.x = abs(uv.x);\n    \n    // the original curve lies on the zero line so shift the \n    // the whole thing upper in order to get it in the middle\n    uv.y += tan((5./6.)*3.14159)*.5;\n    \n    // reflect the line by rotating uv around a line passing through (.5, 0)\n    // by 5/6 degrees. This adds the line segment to the lower right corner alse\n    uv = rotate(uv, vec2(.5, 0), (5./6.), true);\n\n\t// folds the space to create the upside down 'V' shapes\n    float scale = 1.; // keeps track how many times uv space is folded\n    uv.x += 0.5; // undo the first shift in the loop to keep the fractal in the middle\n    for (int i=0; i<4; i++) {\n    \t\n        // resets the uv coordinates before folding the next upside down 'V' shape\n        uv *= 3.;\n        scale *= 3.;\n        uv.x -= 1.5; // shift the origo in the middle of the line segment\n        \n        // this widens the line segment to 3 units of which the centermost is folded\n        uv.x = abs(uv.x); // mirror around the center\n        uv.x -= .5; // add .5 to the both ends of the line to make it 3 units wide\n        \n        uv = rotate(uv, vec2(0., 0.0) ,(2./3.), false);    \t\n    }\n    \n    // Draw the line by calculating distance to a line lying on the y axis and \n    // which x position ranges from -1 to 1\n    float d = length(uv - vec2(clamp(uv.x, -1., 1.), 0.));\n      \n    // make the fractal more trippy by making it go inside out \n    // and rotating by time\n    uv *= sin(iTime * 0.3);\n    uv = rotate(uv, vec2(0., 0.), sin(iTime*0.5), true);\n    \n    // smooths out the line segment so its thick and narrower.\n    // Division by iResolution.y makes sure its resolution independent and always 1 pixel wide\n    col += smoothstep(1./iResolution.y, 0., d/scale); \n    \n    uv /= scale;\n    \n    // let the magic happen\n    col += texture(iChannel0, uv*3.2-iTime*0.2).rgb;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WslcDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 61], [63, 117, 176, 398, 595], [596, 596, 653, 716, 2820]], "test": "untested"}
{"id": "WsjyRz", "name": "Lights in the Sky", "author": "Roninkoi", "description": "Raymarching experiments", "tags": ["raymarching", "glow"], "likes": 5, "viewed": 379, "published": 3, "date": "1585977963", "time_retrieved": "2024-07-30T21:15:01.648520", "image_code": "#define PI 3.14159265\n#define MAXIT 128\n#define EPSILON 0.001\n \n#define minx4(a, b) ((a.w) < (b.w) ? (a) : (b))\n#define minx2(a, b) ((a.x) < (b.x) ? (a) : (b))\n \n#define MAT0 0.0\n#define MAT1 1.0\n \nmat3 rotX(float a)\n{\n    return mat3(\n        1., 0., 0.,\n        0., cos(a), -sin(a),\n        0., sin(a), cos(a)\n    );\n}\n \nmat3 rotY(float a)\n{\n    return mat3(\n        cos(a), 0.0, -sin(a),\n        0., 1., 0.,\n        sin(a), 0.0, cos(a)\n    );\n}\n \nmat3 rotZ(float a)\n{\n    return mat3(\n        cos(a), -sin(a), 0.,\n        sin(a), cos(a), 0.,\n        0., 0., 1.\n    );\n}\n \nfloat t;\n \nfloat sphere(vec3 r, float a)\n{\n    return length(r) - a;\n}\n \nfloat torus(vec3 r, vec2 a)\n{\n    a.y += sin(length(r.xy + t) * 7.) * 0.09;\n    vec2 p = vec2(length(r.xz) - a.x, r.y);\n    return length(p) - a.y;\n}\n \nfloat plane(vec3 r, vec3 o, vec3 n) {\n    return dot(r - o, n);\n}\n \nfloat box(vec3 r, vec3 a)\n{\n    vec3 p = abs(r) - a;\n    return length(max(p - p.x * 0.4 - p.y * 0.4, 0.)) + min(max(p.x - p.y * 0.5, max(p.y, p.z) - p.x * 0.3), 0.);\n}\n \nfloat shade(vec3 n, vec3 rd)\n{\n    return clamp(max(dot(n, -rd), 0.) + 1., 0., 1.);\n}\n \nvec3 fog(float z, vec3 col, vec3 fogCol)\n{\n    return mix(fogCol, col, exp(-z));\n}\n \nmat3 obj;\n \nvec2 map(vec3 r)\n{\n    obj = rotZ((-t + r.z * 0.2) * 0.3) * rotY(1. * t);\n   \n    vec2 b1 = vec2(\n        box(obj * obj * (r) + vec3(0., sin(2. * t) * 1., 0.), vec3(.75, .5, .5)),\n        MAT0\n    );\n   \n    vec2 t1 = vec2(\n        torus(- obj *r, vec2(2.0, 0.1)),\n        MAT1\n    );\n   \n    return minx2(b1, t1);\n}\n \nfloat hash(vec2 r) {\n    return fract(sin(dot(r, vec2(15.5921, 96.654654))) * 23626.3663);\n}\n \nvec3 matCol(vec2 o)\n{\n    if (o.y == MAT0)\n        return normalize(vec3(1., 0.5, .0));\n   \n    if (o.y == MAT1)\n        return normalize(vec3(0., 1.7, 0.0));\n   \n    return vec3(0.);\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    t = iTime;\n   \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n   \n    mat3 cam = rotY(t * 0. - PI);\n       \n    vec3 ro = vec3(0., 0., -3.0);\n    vec3 rd = cam * normalize(vec3(uv * 2., -1.));\n    vec3 r = ro;\n   \n    vec3 bcol = normalize((vec3(1., 0., 1.0) + 0.5) * (uv.y + 0.3) * (sin(t) + 1.) * 1.5 + vec3(0., 0.5, 1.0)) * 1.5 + 0.4;\n    vec4 col = vec4(0.);\n    col.rgb = bcol;\n   \n    vec2 c = vec2(10000., MAT0);\n   \n    float sh = 1.;\n   \n    float glow = 0.;\n   \n    vec3 gcol = bcol;\n   \n    for (int i = 0; i < MAXIT; ++i) {\n        vec2 d = map(r);\n        float z = length(r - ro);\n       \n        glow += exp(-d.x * 5.);\n        gcol += matCol(d) * exp(-d.x * 1.);\n       \n        if (d.x < EPSILON) {\n            col.rgb = mix(col.rgb, matCol(d), shade(normalize(r), rd));\n            col.rgb = fog(z * 0.1, col.rgb, bcol);\n            break;\n        }\n       \n        d.x *= 0.7 - 0.1 * hash(uv);\n        r += rd * clamp(d.x, -0.5, 0.5) * 0.7;\n       \n        sh = (float(i) / float(MAXIT));\n    }\n   \n    col.rgb *= exp(-sh * .9);\n    col.rgb = mix(col.rgb, gcol, glow * 0.005);\n   \n    fragColor = vec4(col.rgb, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjyRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[198, 198, 218, 218, 320], [323, 323, 343, 343, 447], [450, 450, 470, 470, 572], [586, 586, 617, 617, 645], [648, 648, 677, 677, 797], [800, 800, 837, 837, 865], [868, 868, 895, 895, 1036], [1039, 1039, 1069, 1069, 1124], [1127, 1127, 1169, 1169, 1209], [1224, 1224, 1242, 1242, 1540], [1543, 1543, 1563, 1563, 1635], [1638, 1638, 1659, 1659, 1823]], "test": "untested"}
{"id": "WdjyzR", "name": "yet another ripple effect", "author": "lambmeow", "description": "using fbm technique to create a cool ripple effect", "tags": ["fbm", "water", "ripple"], "likes": 6, "viewed": 610, "published": 3, "date": "1585961734", "time_retrieved": "2024-07-30T21:15:02.515202", "image_code": "vec2 random(vec2 uv)\n{\n    return fract(vec2(dot(uv, vec2(435.6,534.3)), dot(uv, vec2(358.463,246.3))) );\n}\n\nfloat noise(vec2 uv)\n{\n    \n    //get decimal and integer portions from position\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    \n    //randomize each position around current position\n    vec2 a = random(i);\n    vec2 b = random(i + vec2(1.0, 0.0));\n    vec2 c = random(i + vec2(0.0, 1.0));\n    vec2 d = random(i + vec2(1.0, 1.0));\n    \n    //interpolate decimal position\n    vec2 m = smoothstep(0.0,1.0,f);\n    \n    //apply interpolation to 4 corners and return result.\n    return mix(mix(dot(a,f), dot(b, f-vec2(1.0,0.0)), m.x),\n               mix(dot(c,f - vec2(0.0, 1.0)), dot(d,f - vec2(1,1)), m.x), m.y);\n}\n\n\nfloat fbm(vec2 uv)\n{\n\n    //store the final value \n    float v = 0.;\n    \n    //store the current amplitude for the noise texture\n    float a =.9;\n    \n    for(int i = 0; i < 6; i++)\n    {\n        v += a * noise(uv);\n        a *= 0.5;\n        uv *= 2.0;\n    }\n    \n    return v;\n}\n\nvec2 rip(vec2 uv)\n{\n    return uv + fbm(uv + iTime);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    uv = rip(uv * 10.0)/10.;\n    // Time varying pixel color\n  \tvec4 col = texture(iChannel0, uv);\n\n    // Output to screen\n    fragColor = vec4(col);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdjyzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 107], [109, 109, 131, 189, 724], [727, 727, 747, 777, 1007], [1009, 1009, 1028, 1028, 1063], [1065, 1065, 1122, 1172, 1367]], "test": "untested"}
{"id": "3sjyRR", "name": "Chocolate Waterfall", "author": "propagant", "description": "Simple chocolate waterfall using traditional raymarching methods", "tags": ["raymarching", "chocolate"], "likes": 1, "viewed": 453, "published": 3, "date": "1585954674", "time_retrieved": "2024-07-30T21:15:03.388866", "image_code": "// By Matej Vanco 2020 - for educational purposes & for fun!\n\n#define MAX_RENDER 64\n#define MIN_RENDER 16.\n#define EPSILON 0.001\n\nstruct ray\n{\n\tvec3 o;\n    vec3 d;\n    float l;\n};\n\n//---Iq's smooth opu\nvec4 opu(vec4 a, vec4 b)\n{\n    float k = 0.35;\n    float d1 = a.w;\n    float d2 = b.w;\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return vec4(mix(b.rgb,a.rgb,h),mix( d2, d1, h ) - k*h*(1.0-h));\n}\n\n//---'Geometry' calculation\nvec4 geo(vec3 p)\n{   \n    float fsin = sin(iTime * 1. + p.y * 8.); //---'Chocolate effect'\n\tvec4 s = vec4(vec3(0.5,0.3,0.1)*0.5, pow(length(p - vec3(fsin*0.5,0.2,1.5)) - 0.2,2.)); //---'Sphere'\n\n    vec4 pp = vec4(vec3(0.5,0.3,0.1)*0.2, p.y + 0.25); //---Ground\n    \n    vec4 g0 = opu(s,pp); //---Combine\n    return g0;\n}\n\n//---Normals calculation\nvec3 normal(vec3 p)\n{\n\tvec2 of = vec2(EPSILON,0.);\n    float copy = geo(p).w;\n    return normalize(copy - vec3(geo(p - of.xyy).w, geo(p - of.yxy).w, geo(p - of.yyx).w)); //---Subtract from copy\n}\n\n//---Soft shadows\nfloat shadow(vec3 ro, vec3 rd, float b)\n{\n\tfloat t = EPSILON;\n    float r = 1.;\n    for(int i = 0; i < 16; i++)\n    {\n        float g = geo(ro + rd * t).w;\n        r = min(r, b * g / t);\n        t += g;\n        if(g < EPSILON)\n            break;\n        \n        if(g >= 4.)\n            break;\n    }\n    return clamp(r,0.4,1.);\n}\n\n//---Traditional Lambert lighting model + Phong reflection specular\nfloat lighting(vec3 p)\n{\n\tvec3 lpos = vec3(2.5,2.5,-2.5);\n    vec3 lposVec = normalize(p - lpos);\n    vec3 n = normal(p);\n    \n    float spec = pow(max(dot(p, reflect(lposVec,n))*1.5,1.0),2.);\n    \n    float light = clamp(dot(lposVec, p),0.,1.) * shadow(p, lpos,0.4) * spec;\n    return light;\n}\n\n\n//---Ray-march\nvec4 march(ray r)\n{\n\tvec3 col = vec3(1.);\n    for(int i = 0; i < MAX_RENDER; i++)\n    {\n        vec3 p = r.o + r.d * r.l;\n        vec4 g = geo(p);\n        r.l += g.w;\n        col = g.rgb;\n    \tif(r.l > MIN_RENDER)\n        \tbreak;   \n    }\n    return vec4(col, r.l);\n}\n\n// Final img\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    ray r;\n    r.o = vec3(0.);\n    r.d = vec3(uv, 1.);\n    vec4 m = march(r);\n    vec3 col = m.rgb * lighting(r.o + r.d * m.w);\n    col*=exp(-0.1 * m.w * m.w * m.w); //---Fog\n    if(m.w > 2.5)\n        col = mix(col,vec3(0.5,0.3,0.), uv.y+0.2); //---'Gradient' background\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sjyRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[181, 202, 228, 228, 412], [414, 442, 460, 460, 763], [765, 790, 811, 811, 985], [987, 1005, 1046, 1046, 1334], [1336, 1404, 1428, 1428, 1698], [1701, 1716, 1735, 1735, 1983], [1985, 1998, 2055, 2055, 2427]], "test": "untested"}
{"id": "wt3XDj", "name": "Castaway", "author": "P_Malin", "description": "SPACE = Toggle Flycam\nWASD / click + mouse to move\nShift = Move faster", "tags": ["raymarch", "sea", "water", "sky", "beach"], "likes": 140, "viewed": 4800, "published": 3, "date": "1585951890", "time_retrieved": "2024-07-30T21:15:04.652488", "image_code": "//     _____             _                                \n//    / ____|           | |                               \n//   | |      __ _  ___ | |_  __ _ __      __ __ _  _   _ \n//   | |     / _` |/ __|| __|/ _` |\\ \\ /\\ / // _` || | | |\n//   | |____| (_| |\\__ \\| |_| (_| | \\ V  V /| (_| || |_| |\n//    \\_____|\\__,_||___/ \\__|\\__,_|  \\_/\\_/  \\__,_| \\__, |\n//                                                   __/ |\n//                                                  |___/ \n\n// Castaway by @P_Malin\n\n// https://www.shadertoy.com/view/wt3XDj\n\n// Controls:\n// SPACE = Toggle Flycam\n// WASD / click + mouse to move\n// Shift = Move faster\n\n// YouTube Video Here: https://youtu.be/bSg5nb_UTVM\n\n// ASCII Comments: http://patorjk.com/software/taag/#p=display&h=2&c=c%2B%2B&f=Big&t=My%20Comment\n\n//    _____                               _____ _               _                      _____          _   ______    \n//   |_   _|                             / ____| |             | |                    |  __ \\        | | |  ____|   \n//     | |  _ __ ___   __ _  __ _  ___  | (___ | |__   __ _  __| | ___ _ __   ______  | |__) |__  ___| |_| |____  __\n//     | | | '_ ` _ \\ / _` |/ _` |/ _ \\  \\___ \\| '_ \\ / _` |/ _` |/ _ \\ '__| |______| |  ___/ _ \\/ __| __|  __\\ \\/ /\n//    _| |_| | | | | | (_| | (_| |  __/  ____) | | | | (_| | (_| |  __/ |             | |  | (_) \\__ \\ |_| |   >  < \n//   |_____|_| |_| |_|\\__,_|\\__, |\\___| |_____/|_| |_|\\__,_|\\__,_|\\___|_|             |_|   \\___/|___/\\__|_|  /_/\\_\\\n//                           __/ |                                                                                  \n//                          |___/                                                                                   \n\nfloat Vignette( vec2 uv, float size )\n{\n    float d = length( (uv - 0.5f) * 2.0f ) / length(vec2(1.0));\n    \n    d /= size;\n    \n    float s = d * d * ( 3.0f - 2.0f * d );\n    \n    float v = mix ( d, s, 0.6f );\n    \n    return max(0.0, 1.0f - v);\n}\n\n\nvec3 PostProcessColour( vec3 color )\n{\n#if EQUIRECTANGULAR_PROJECTION\n    float exposure = 0.5f;    \n    color = color * exposure;\n    \n    float gamma = 2.2f;    \n    color = pow( color, vec3( 1.0f / gamma ) );    \n#else\n    float exposure = 1.0f;    \n    color = color * exposure;\n    \n    color = 1.0f - exp( -color );    \n    float gamma = 2.2f;    \n    color = pow( color, vec3( 1.0f / gamma ) );\n            \n#endif\n    return color;\n}\n\n\n#define ENABLE_DOF\n\nfloat GetCoC( float fDistance, float fPlaneInFocus )\n{\n#ifdef ENABLE_DOF    \n\t// http://http.developer.nvidia.com/GPUGems/gpugems_ch23.html\n\n    float fAperture = min(1.0, fPlaneInFocus * fPlaneInFocus * 0.5);\n    float fFocalLength = 0.05;\n    \n\treturn abs(fAperture * (fFocalLength * (fDistance - fPlaneInFocus)) /\n          (fDistance * (fPlaneInFocus - fFocalLength)));  \n#else\n    return 0.0f;\n#endif    \n}\n\nvec3 SampleWithDOF( ivec2 pos, float planeInFocus )\n{\n\tvec4 vCenterSample = texelFetch( iChannel0, pos, 0 );    \n    \n    //return vec3(1) /vCenterSample.w;\n    \n    float CoC = GetCoC( vCenterSample.w, planeInFocus );\n        \n\t#define DOF_SIZE 6\n    #define DOF_SIZE_F float( DOF_SIZE )\n    \n    #define DOF_BLOOM_STRENGTH 2.0\n    \n    CoC = CoC * 500.0;\n        \n    float testRadius = CoC * CoC;\n    \n    bool bloom = false;\n    if ( CoC <= 1.0f )\n    {\n        testRadius = DOF_SIZE_F;\n        bloom = true;\n    }\n    \n\tvec3 vResult = vec3(0.0);    \n    float fTot = 0.0;\n    \n    {\n        float fY = -DOF_SIZE_F;\n        for( int y=-DOF_SIZE; y<=DOF_SIZE; y++ )\n        {\n            float fX = -DOF_SIZE_F;\n            for( int x=-DOF_SIZE; x<=DOF_SIZE; x++ )\n            {            \n                vec2 vOffset = vec2( fX, fY );\n                float r2 = dot( vOffset, vOffset );\n                if ( r2 < testRadius )\n                {                \n                    ivec2 iOffset = ivec2( x,y );\n                    vec4 vTapSample = texelFetch( iChannel0, pos + iOffset, 0 );\n                    \n                    float fWeight = 1.0f;\n                    \n                    if ( bloom )\n                    {\n\t\t            \tfWeight = exp2( -r2 * DOF_BLOOM_STRENGTH );                        \n                    }\n                    \n                    vResult += vTapSample.rgb * fWeight;\n                    fTot += fWeight;\n                }\n                fX+=1.0f;\n            }\n            fY+=1.0f;\n        }\n    }\n    \n    vResult = vResult / fTot;\n    \n    return vResult;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n\tvec4 vCenterScreenSample = texelFetch( iChannel0, ivec2(iResolution.xy / 2.), 0 );\n    float planeInFocus = vCenterScreenSample.w;\n    \n#if EQUIRECTANGULAR_PROJECTION\n    vec3 sceneColour = texelFetch( iChannel0, ivec2( fragCoord ), 0 ).rgb;\n    //vec3 sceneColour = SampleWithDOF( ivec2( fragCoord ), planeInFocus );\n    sceneColour*= 0.5;\n#else\n    vec3 sceneColour = SampleWithDOF( ivec2( fragCoord ), planeInFocus );\n    sceneColour.rgb *= 0.2 + 0.8 * Vignette( uv, 1.0 );\n#endif\n    \n    \n    vec3 outputColour = PostProcessColour( sceneColour.rgb );    \n\n#if 0\n    CameraState cam;\n    Cam_LoadState( cam, iChannel3, ivec2(0,0) );\n    \n    Cam_DebugOverlay( outputColour, cam, uv, planeInFocus );\n#endif\n        \n    fragColor = vec4(outputColour, 1.0);    \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 21772, "src": "https://soundcloud.com/soundsofnaturewhitenoisesoundeffects/waves-tropical-ocean-waves", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "//     _____                                           \n//    / ____|                                          \n//   | |      ___   _ __ ___   _ __ ___    ___   _ __  \n//   | |     / _ \\ | '_ ` _ \\ | '_ ` _ \\  / _ \\ | '_ \\ \n//   | |____| (_) || | | | | || | | | | || (_) || | | |\n//    \\_____|\\___/ |_| |_| |_||_| |_| |_| \\___/ |_| |_|\n//                                                     \n//                                                     \n\n#define PI\t3.141592654\n#define TAU 6.283185308\n\n#define ZERO (min(0,iFrame))\n\n\n#define IOR_AIR \t1.0f\n#define IOR_WATER \t1.33f\n\n#define EQUIRECTANGULAR_PROJECTION 0\n\nfloat RadianceChange( float IA, float IB )\n{\n    float x = IB / IA;\n    return x * x;\n}\n\n\n//  ____        _          ____  _                             \n// |  _ \\  __ _| |_ __ _  / ___|| |_ ___  _ __ __ _  __ _  ___ \n// | | | |/ _` | __/ _` | \\___ \\| __/ _ \\| '__/ _` |/ _` |/ _ \\\n// | |_| | (_| | || (_| |  ___) | || (_) | | | (_| | (_| |  __/\n// |____/ \\__,_|\\__\\__,_| |____/ \\__\\___/|_|  \\__,_|\\__, |\\___|\n//                                                  |___/      \n//\n\nvec4 LoadVec4( sampler2D sampler, in ivec2 addr )\n{\n    return texelFetch( sampler, addr, 0 );\n}\n\nvec3 LoadVec3( sampler2D sampler, in ivec2 addr )\n{\n    return LoadVec4( sampler, addr ).xyz;\n}\n\nbool AtAddress( ivec2 p, ivec2 c ) { return all( equal( p, c ) ); }\n\nvoid StoreVec4( in ivec2 addr, in vec4 value, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, addr ) ? value : fragColor;\n}\n\nvoid StoreVec3( in ivec2 addr, in vec3 value, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( addr, vec4( value, 0.0 ), fragColor, fragCoord );\n}\n\n//\n//  ____       _        _   _             \n// |  _ \\ ___ | |_ __ _| |_(_) ___  _ __  \n// | |_) / _ \\| __/ _` | __| |/ _ \\| '_ \\ \n// |  _ < (_) | || (_| | |_| | (_) | | | |\n// |_| \\_\\___/ \\__\\__,_|\\__|_|\\___/|_| |_|\n//                                        \n//\n\nvec3 RotateX( const in vec3 pos, const in float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    \n    vec3 result = vec3( pos.x, c * pos.y + s * pos.z, -s * pos.y + c * pos.z );\n    \n    return result;\n}\n\nvec3 RotateY( const in vec3 pos, const in float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    \n    vec3 result = vec3( c * pos.x + s * pos.z, pos.y, -s * pos.x + c * pos.z );\n    \n    return result;\n}\n\nvec3 RotateZ( const in vec3 pos, const in float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    \n    vec3 result = vec3( c * pos.x + s * pos.y, -s * pos.x + c * pos.y, pos.z );\n    \n    return result;\n}\n\n\nmat3 MatFromAngles( vec3 angles )\n{\n    mat3 rotX = mat3(1.0, 0.0, 0.0, \n                     0.0, cos(angles.x), sin(angles.x), \n                     0.0, -sin(angles.x), cos(angles.x));\n    \n    mat3 rotY = mat3(cos(angles.y), 0.0, -sin(angles.y), \n                     0.0, 1.0, 0.0, \n                     sin(angles.y), 0.0, cos(angles.y));    \n\n    mat3 rotZ = mat3(cos(angles.z), sin(angles.z), 0.0,\n                     -sin(angles.z), cos(angles.z), 0.0,\n                     0.0, 0.0, 1.0 );\n    \n    \n    mat3 m = rotY * rotX * rotZ;\n    \n    return m;\n}\n\n\n//   ___              _                  _             \n//  / _ \\ _   _  __ _| |_ ___ _ __ _ __ (_) ___  _ __  \n// | | | | | | |/ _` | __/ _ \\ '__| '_ \\| |/ _ \\| '_ \\ \n// | |_| | |_| | (_| | ||  __/ |  | | | | | (_) | | | |\n//  \\__\\_\\\\__,_|\\__,_|\\__\\___|_|  |_| |_|_|\\___/|_| |_|\n//                                                     \n//\n\nvec4 QuatMul( vec4 lhs, vec4 rhs ) \n{\n      return vec4( lhs.y * rhs.z - lhs.z * rhs.y + lhs.x * rhs.w + lhs.w *rhs.x,\n                   lhs.z * rhs.x - lhs.x * rhs.z + lhs.y * rhs.w + lhs.w *rhs.y,\n                   lhs.x * rhs.y - lhs.y * rhs.x + lhs.z * rhs.w + lhs.w *rhs.z,\n                   lhs.w * rhs.w - lhs.x * rhs.x - lhs.y * rhs.y - lhs.z *rhs.z );\n}\n\nvec4 QuatFromAxisAngle( vec3 axis, float angle )\n{\n\treturn vec4( normalize(axis) * sin( angle ), cos( angle ) );    \n}\n\nvec4 QuatFromVec3( vec3 rot )\n{\n    float l = length( rot );\n    if ( l <= 0.0 )\n    {\n        return vec4( 0.0, 0.0, 0.0, 1.0 );\n    }\n    return QuatFromAxisAngle( rot, l );\n}\n\nmat3 QuatToMat3( const in vec4 q )\n{\n\tvec4 qSq = q * q;\n\tfloat xy2 = q.x * q.y * 2.0;\n\tfloat xz2 = q.x * q.z * 2.0;\n\tfloat yz2 = q.y * q.z * 2.0;\n\tfloat wx2 = q.w * q.x * 2.0;\n\tfloat wy2 = q.w * q.y * 2.0;\n\tfloat wz2 = q.w * q.z * 2.0;\n \n\treturn mat3 (\t\n     qSq.w + qSq.x - qSq.y - qSq.z, xy2 - wz2, xz2 + wy2,\n     xy2 + wz2, qSq.w - qSq.x + qSq.y - qSq.z, yz2 - wx2,\n     xz2 - wy2, yz2 + wx2, qSq.w - qSq.x - qSq.y + qSq.z );\n}\n\nvec3 QuatMul( vec3 v, vec4 q )\n{\n    // TODO Validate vs other quat code\n    vec3 t = 2.0 * cross(q.xyz, v);\n\treturn v + q.w * t + cross(q.xyz, t);\n}\n\n//\n//  _  __          _                         _ \n// | |/ /___ _   _| |__   ___   __ _ _ __ __| |\n// | ' // _ \\ | | | '_ \\ / _ \\ / _` | '__/ _` |\n// | . \\  __/ |_| | |_) | (_) | (_| | | | (_| |\n// |_|\\_\\___|\\__, |_.__/ \\___/ \\__,_|_|  \\__,_|\n//           |___/                             \n//\n\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\nconst int KEY_1 = \t49;\nconst int KEY_2 = \t50;\nconst int KEY_3 = \t51;\nconst int KEY_ENTER = 13;\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL  = 17;\nconst int KEY_ALT   = 18;\nconst int KEY_TAB\t= 9;\n\nbool Key_IsPressed( sampler2D samp, int key )\n{\n    return texelFetch( samp, ivec2(key, 0), 0 ).x > 0.0;    \n}\n\nbool Key_IsToggled(sampler2D samp, int key )\n{\n    return texelFetch( samp, ivec2(key, 2), 0 ).x > 0.0;    \n}\n\n// ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n// Creative Commons CC0 1.0 Universal (CC-0) \n// https://www.shadertoy.com/view/4sBSWW\n\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces )\n{       \n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n    \n    bool bNeg = ( fValue < 0.0 );\n\tfValue = abs(fValue);\n    \n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n\t\t\t\tfloat fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n\t\t\t}\n        }\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n\nvec3 CylinderProjectionToDir( vec2 uv )\n{\n    float theta = uv.x * TAU + 2.0;\n    float sy = sin(uv.y * PI);\n    float cy = -cos(uv.y * PI);\n    \n    vec2 mapDir = vec2( sin(theta), cos(theta) );\n    vec3 dir = vec3(mapDir.x * sy, cy, mapDir.y * sy);\n    return dir;\n}\n\n// ---- 8< -------- 8< -------- 8< -------- 8< ----\n\n\n//\n//   ____                               \n//  / ___|__ _ _ __ ___   ___ _ __ __ _ \n// | |   / _` | '_ ` _ \\ / _ \\ '__/ _` |\n// | |__| (_| | | | | | |  __/ | | (_| |\n//  \\____\\__,_|_| |_| |_|\\___|_|  \\__,_|\n//                                      \n\n\nstruct CameraState\n{\n    vec3 vPos;\n    vec3 vTarget;\n    vec3 vUp;\n    float fFov;\n    vec2 vJitter;\n    float fPlaneInFocus;\n};\n    \nvoid Cam_LoadState( out CameraState cam, sampler2D sampler, ivec2 addr )\n{\n    vec4 vPos = LoadVec4( sampler, addr + ivec2(0,0) );\n    cam.vPos = vPos.xyz;\n    vec4 targetFov = LoadVec4( sampler, addr + ivec2(1,0) );\n    cam.vTarget = targetFov.xyz;\n    cam.fFov = targetFov.w;\n    vec4 vUp = LoadVec4( sampler, addr + ivec2(2,0) );\n    cam.vUp = vUp.xyz;\n    \n    vec4 jitterDof = LoadVec4( sampler, addr + ivec2(3,0) );\n    cam.vJitter = jitterDof.xy;\n    cam.fPlaneInFocus = jitterDof.z;\n}\n\nvoid Cam_StoreState( ivec2 addr, const in CameraState cam, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( addr + ivec2(0,0), vec4( cam.vPos, 0 ), fragColor, fragCoord );\n    StoreVec4( addr + ivec2(1,0), vec4( cam.vTarget, cam.fFov ), fragColor, fragCoord );    \n    StoreVec4( addr + ivec2(2,0), vec4( cam.vUp, 0 ), fragColor, fragCoord );    \n    StoreVec4( addr + ivec2(3,0), vec4( cam.vJitter, cam.fPlaneInFocus, 0 ), fragColor, fragCoord );    \n}\n\nmat3 Cam_GetWorldToCameraRotMatrix( const CameraState cameraState )\n{\n    vec3 vForward = normalize( cameraState.vTarget - cameraState.vPos );\n\tvec3 vRight = normalize( cross( cameraState.vUp, vForward) );\n\tvec3 vUp = normalize( cross(vForward, vRight) );\n    \n    return mat3( vRight, vUp, vForward );\n}\n\nvec2 Cam_GetViewCoordFromUV( vec2 vUV, float fAspectRatio )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= fAspectRatio;\n\n\treturn vWindow;\t\n}\n\nvoid Cam_GetCameraRay( const vec2 vUV, const float fAspectRatio, const CameraState cam, out vec3 vRayOrigin, out vec3 vRayDir )\n{\n    vec2 vView = Cam_GetViewCoordFromUV( vUV, fAspectRatio );\n    vRayOrigin = cam.vPos;\n    float fPerspDist = 1.0 / tan( radians( cam.fFov ) );\n    vRayDir = normalize( Cam_GetWorldToCameraRotMatrix( cam ) * vec3( vView, fPerspDist ) );\n    #if EQUIRECTANGULAR_PROJECTION\n    vRayDir = CylinderProjectionToDir(vUV);\n    #endif\n}\n\n// fAspectRatio = iResolution.x / iResolution.y;\nvec2 Cam_GetUVFromWindowCoord( const in vec2 vWindow, float fAspectRatio )\n{\n    vec2 vScaledWindow = vWindow;\n    vScaledWindow.x /= fAspectRatio;\n\n    return (vScaledWindow * 0.5 + 0.5);\n}\n\nvec2 Cam_WorldToWindowCoord(const in vec3 vWorldPos, const in CameraState cameraState )\n{\n    vec3 vOffset = vWorldPos - cameraState.vPos;\n    vec3 vCameraLocal;\n\n    vCameraLocal = vOffset * Cam_GetWorldToCameraRotMatrix( cameraState );\n\t\n    vec2 vWindowPos = vCameraLocal.xy / (vCameraLocal.z * tan( radians( cameraState.fFov ) ));\n    \n    return vWindowPos;\n}\n\nvoid Cam_DebugOverlay( inout vec3 colour, CameraState cam, vec2 uv, float depth )\n{\n    vec2 pos = uv * vec2(80,30);\n    pos.x -= 2.0;\n    pos.y -= 28.0;\n    \n    if ( pos.x > -0.5 && pos.y < 1.5 && pos.x < 40.5 && pos.y > -4.5 )\n    {\n        colour = vec3(0);\n    }\n    \n    vec2 hpos = pos;\n    colour = mix( colour, vec3(0,0,1), PrintValue( hpos, cam.vPos.x, 3.0, 3.0 ) );\n    hpos.x -= 10.0;\n    colour = mix( colour, vec3(0,0,1), PrintValue( hpos, cam.vPos.y, 3.0, 3.0 ) );\n    hpos.x -= 10.0;\n    colour = mix( colour, vec3(0,0,1), PrintValue( hpos, cam.vPos.z, 3.0, 3.0 ) );\n    hpos.x -= 10.0;\n    \n    pos.y += 1.3;\n    \n\thpos = pos;\n    colour = mix( colour, vec3(1,0,1), PrintValue( hpos, cam.vTarget.x, 3.0, 3.0 ) );\n    hpos.x -= 10.0;\n    colour = mix( colour, vec3(1,0,1), PrintValue( hpos, cam.vTarget.y, 3.0, 3.0 ) );\n    hpos.x -= 10.0;\n    colour = mix( colour, vec3(1,0,1), PrintValue( hpos, cam.vTarget.z, 3.0, 3.0 ) );\n    hpos.x -= 10.0;\n    \n    pos.y += 1.3;\n    \n\thpos = pos;\n    colour = mix( colour, vec3(0,1,0), PrintValue( hpos, cam.fFov, 3.0, 3.0 ) );\n    hpos.x -= 10.0;\n    colour = mix( colour, vec3(0,1,0), PrintValue( hpos, depth, 3.0, 3.0 ) );\n    \n    \n    vec3 vDir = normalize(cam.vTarget - cam.vPos);\n    vec3 vTarget2 = cam.vPos + vDir * depth;\n    \n    pos.y += 1.3;\n    \n\thpos = pos;\n    colour = mix( colour, vec3(0,1,1), PrintValue( hpos, vTarget2.x, 3.0, 3.0 ) );\n    hpos.x -= 10.0;\n    colour = mix( colour, vec3(0,1,1), PrintValue( hpos, vTarget2.y, 3.0, 3.0 ) );\n    hpos.x -= 10.0;\n    colour = mix( colour, vec3(0,1,1), PrintValue( hpos, vTarget2.z, 3.0, 3.0 ) );\n    hpos.x -= 10.0;    \n}\n\n//  _   _           _       _____                 _   _                 \n// | | | | __ _ ___| |__   |  ___|   _ _ __   ___| |_(_) ___  _ __  ___ \n// | |_| |/ _` / __| '_ \\  | |_ | | | | '_ \\ / __| __| |/ _ \\| '_ \\/ __|\n// |  _  | (_| \\__ \\ | | | |  _|| |_| | | | | (__| |_| | (_) | | | \\__ \\\n// |_| |_|\\__,_|___/_| |_| |_|   \\__,_|_| |_|\\___|\\__|_|\\___/|_| |_|___/\n//                                                                      \n\n// From: Hash without Sine by Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n//#define HASHSCALE1 .1031\n//#define HASHSCALE3 vec3(.1031, .1030, .0973)\n//#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n//----------------------------------------------------------------------------------------\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n// https://iquilezles.org/articles/intersectors\n// sphere of size ra centered at point ce\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\n///////////////////////////////////////////////////////////\n// Smoothnoise\n\nvec2 SmoothNoise22( vec2 o ) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tvec2 a = hash21(n+  0.0);\n\tvec2 b = hash21(n+  1.0);\n\tvec2 c = hash21(n+ 57.0);\n\tvec2 d = hash21(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\n\tvec2 res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n    return res;\n}\n\n\nvec3 SmoothNoise32( vec2 o ) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tvec3 a = hash31(n+  0.0);\n\tvec3 b = hash31(n+  1.0);\n\tvec3 c = hash31(n+ 57.0);\n\tvec3 d = hash31(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\n\tvec3 res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n    return res;\n}\n\n////////////////////////////////////////////\n// Sky / Environment sampling\n\t   \nstruct EnvironmentSettings\n{\n    float time;\n    \n    vec3 skyZenithCol;\n    vec3 skyHorizonCol;\n    \n    vec3 sunDiscCol;\n    vec3 sunLightCol;\n    \n    vec3 ambientCol;\n    \n    float sunElevation;\n    float sunHeading;\n    vec3 sunDir;\n    \n    vec3 fogCol;\n    float fogDensity;\n    float skyFogDensity;\n};\n\nfloat CloudSample( sampler2D iChannel, vec2 uv, float time, float spread )\n{\n    vec2 cloudUV0 = uv;\n    cloudUV0 += time * 0.0005;\n    vec2 cloudUV1 = cloudUV0 * 2.0f; \n    cloudUV1 += time * 0.0005;\n    float cloudSampleA0 = texture( iChannel, cloudUV0, spread ).r;    \n    float cloudSampleA1 = texture( iChannel, cloudUV1, spread ).b;\n\tfloat cloudDensityA = cloudSampleA0 * 0.7 + cloudSampleA1 * 0.3;\n    \n    return cloudDensityA;\n}\n\nvec4 TraceSky( EnvironmentSettings env, sampler2D iChannel, vec3 dir, float time, float spread, bool sunDisc )\n{       \n    // sky gradient\n    float f = clamp( 1.0 - dir.y, 0.0f, 1.0f );    \n    f = f * f * f * f;\n    vec3 col = mix( env.skyZenithCol, env.skyHorizonCol, f );    \n    \n    // sun disc\n    float VdotL = dot( dir, env.sunDir );        \n    \n    if ( sunDisc )\n    {\n        const float a0 = cos( radians( 1.0 ) );\n        const float a1 = cos( radians( 0.8 ) );\n\n        float sunBlend = smoothstep( a0, a1, VdotL );\n        col = mix( col, env.sunDiscCol, sunBlend );    \n    }\n    \n    float dist = 100000.0;\n    \n    // cloud layer \n    if ( dir.y > 0.0 )\n    {\n        float earthRadius = 6371000.0f;\n        vec3 earthOrigin = vec3(0.0f, -earthRadius, 0.0f );\n        float cloudHeight = 6000.0f;\n        float cloudRadius = earthRadius + cloudHeight;\n\n        vec2 cloudInt = sphIntersect( vec3(0), dir, earthOrigin, cloudRadius );\n        float cloudT = cloudInt.y;\n        \n        dist = cloudT;\n\n\n        vec3 cloudPos = dir * cloudT;\n\n        vec3 cloudN = normalize( cloudPos - earthOrigin );\n\n        vec2 cloudUV = cloudPos.xz * 0.00001f;\n        float cloudDensityA = CloudSample( iChannel, cloudUV, time, spread );\n        float bumpOffset = 0.0003f;\n        float cloudDensityB = CloudSample( iChannel, cloudUV - env.sunDir.xz * bumpOffset, time, spread );\n\n        float cloudDensity = (cloudDensityA + cloudDensityB) * 0.5;\n\n        // bumpmap towards sun\n        float cloudBumpLight = max( 0.0f, (cloudDensityB - cloudDensityA) * 1.5 + 0.5);\n\n        float sunThicknessFactor = 1.0 / dot( cloudN, env.sunDir );\n        \n        sunThicknessFactor = abs( sunThicknessFactor );\n\n\n        float toSunFactor = 1.0 - max( 0.0, dot(dir, env.sunDir));\n        float toSunAmount = exp( toSunFactor * -20.0 );\n        \n        float cloudSunLight = cloudBumpLight * (1.0 + toSunAmount * 2.5);\n\n        float viewThicknessFactor = 1.0 / dot( cloudN, dir );\n\n        float cover = 0.2;\n        float density = 0.1;\n\n        float thickness = max( 0.0, (cloudDensity - cover) / (1.0 - cover) );\n\n        float cloudOpticalDepth = thickness * viewThicknessFactor;\n        float sunCloudOpticalDepth = thickness * sunThicknessFactor;\n        \n        vec3 litCloudCol = env.sunLightCol * cloudSunLight * ( exp( sunCloudOpticalDepth * -density ) ) * 10.0; \n        vec3 cloudCol = litCloudCol + env.ambientCol;\n\n\n        float cloudBlend = 1.0 - exp( cloudOpticalDepth * -density );\n        col = mix( col, cloudCol, cloudBlend );       \n    }\n    \n    return vec4( col, dist );   \n}\n\n/////////////////////////////////////////////////\n// Terrain Height\n\n\nfloat Terrain_GetShape( vec2 mapPos )\n{\n    float d = length(mapPos);\n        \n    float h = SmoothNoise22( mapPos * 0.02 ).x * 100.0 + 50.0;\n\n   \treturn min( h, d );\n}\n\nfloat Terrain_GetBaseHeight( vec2 mapPos )\n{\n    float dist = Terrain_GetShape( mapPos );\n    float hIsland = 2.0 - dist * dist * 0.0005;\n\n\treturn hIsland;\n}\n\nvec3 GetRockSample( sampler2D rockSampler, vec2 mapPos, float mipLod )\n{\n    vec2 uv = mapPos * 0.1;\n    vec3 textureSample = textureLod( rockSampler, uv.yx, mipLod ).rgb;\n    //textureSample.r = (textureSample.r - textureSample.g) / (1.0f - textureSample.g);\n    return textureSample = textureSample * textureSample;\n}\n\n\n\nvec2 Terrain_GetHeights( sampler2D rockSampler,vec2 mapPos, bool detail )\n{\n    //h = 1.0 - exp( h * -1. );\n    //float dist = length( mapPos );\n    \n    vec2 smoothNoise = SmoothNoise22( mapPos * 20.0 );\n        \n    float h0 = Terrain_GetBaseHeight( mapPos );\n    \n    float rockRelief = 0.05;\n    \n    // + smoothNoise.y\n    float rockScale = smoothstep( 2.0, -2.5, h0 );\n    //rockScale -= (smoothNoise.y - 0.5) * 0.25;\n    vec3 rockSample = GetRockSample( rockSampler, mapPos, 0.0 );\n    float rockh = h0 + ((rockSample.g * rockSample.b) - 1.0 + rockScale * 1.5 ) * rockRelief ;// + rockScale - 2.0 * (1.0 - rockScale);\n    \n    //h += hIsland + 10.0;\n    //h = smax( h, hIsland, 0.5 );\n\n    //h= hIsland - h;\n    \n    //h = 1.0 - exp( h * -0.5 );\n    float h = h0 + smoothNoise.x * 0.001;\n    \n    if ( detail )\n    {\n        float sandWaveBlend = smoothstep( 0.5, 1.5, h );\n        float f = mapPos.y * 20.0 + sin( mapPos.x * 0.3) * 10.0+ cos( mapPos.x * 0.5) * 10.0;\n        \n    \tfloat w = sin(f) * 0.5 + 0.5;\n    \n    \tw = pow ( 1.0 - w, 1.5 );        \n        \n        float wave = w * 0.005 * sandWaveBlend;\n        \n        float rough = SmoothNoise22( mapPos * 2.0 ).x * 0.03;\n        \n        h += mix( wave, rough, smoothstep( 1.3, 1.5, h ) );\n        \n        h += SmoothNoise22( mapPos * 1.0 ).x * 0.02;\n\t    h += SmoothNoise22( mapPos * 1000.0 ).x * 0.001;\t\n    \n        // todo: footsteps?\n        //h += (0.5 - textureLod( iChannel2, mapPos * 0.1, 0.0 ).r) * 0.1;\n    \n#if 1\n        if ( h > rockh )\n        {\n\t        float delta = h - rockh;\n            float amount = exp2( -delta * 50.0 );\n            h -= amount * 0.01;\n        }\n#endif     \n            \n    }\n    \n    return vec2(h,rockh);\n}\n\n\nfloat Terrain_GetHeight( sampler2D rockSampler, vec2 mapPos, bool detail, bool onlySand )\n{\n    vec2 heights = Terrain_GetHeights( rockSampler, mapPos, detail );   \n\n    if ( onlySand )\n        return heights.x;\n    \n    return max( heights.x, heights.y );\n}\n\n", "buffer_a_code": "//     _____                                       _____  _          _        \n//    / ____|                                     / ____|| |        | |       \n//   | |      __ _  _ __ ___    ___  _ __  __ _  | (___  | |_  __ _ | |_  ___ \n//   | |     / _` || '_ ` _ \\  / _ \\| '__|/ _` |  \\___ \\ | __|/ _` || __|/ _ \\\n//   | |____| (_| || | | | | ||  __/| |  | (_| |  ____) || |_| (_| || |_|  __/\n//    \\_____|\\__,_||_| |_| |_| \\___||_|   \\__,_| |_____/  \\__|\\__,_| \\__|\\___|\n//                                                                            \n//                                                                            \n\n#define iChannelState\t\t\tiChannel0\n#define iChannelRockTexture\t\tiChannel1\n#define iChannelKeyboard \t\tiChannel3\n\n#define FLY_CAM_INVERT_Y 1\n\n//   __          __             _           _                _____                               \n//   \\ \\        / /            | |         (_)              / ____|                              \n//    \\ \\  /\\  / /_ _ _ __   __| | ___ _ __ _ _ __   __ _  | |     __ _ _ __ ___   ___ _ __ __ _ \n//     \\ \\/  \\/ / _` | '_ \\ / _` |/ _ \\ '__| | '_ \\ / _` | | |    / _` | '_ ` _ \\ / _ \\ '__/ _` |\n//      \\  /\\  / (_| | | | | (_| |  __/ |  | | | | | (_| | | |___| (_| | | | | | |  __/ | | (_| |\n//       \\/  \\/ \\__,_|_| |_|\\__,_|\\___|_|  |_|_| |_|\\__, |  \\_____\\__,_|_| |_| |_|\\___|_|  \\__,_|\n//                                                   __/ |                                       \n//                                                  |___/                                        \n\nstruct WanderCamState\n{\n    vec3 pos;\n    vec3 lookAt;\n    \n    float targetAngle;\n    float lookAtAngle;\n    \n    float eyeHeight;\n\n    float timer;\n    \n    float shoreDistance;\n    \n    int iSitting;\n    \n    float lookAtElevation;\n};\n\nvoid WanderCam_LoadState( out WanderCamState wanderCam, sampler2D sampler, ivec2 addr )\n{\n    vec4 vPos = LoadVec4( sampler, addr + ivec2(0,0) );\n    wanderCam.pos = vPos.xyz;\n    vec4 vLookAt = LoadVec4( sampler, addr + ivec2(1,0) );\n    wanderCam.lookAt = vLookAt.xyz;\n    vec4 vMisc = LoadVec4( sampler, addr + ivec2(2,0) );    \n    wanderCam.targetAngle = vMisc.x;\n    wanderCam.lookAtAngle = vMisc.y;\n    wanderCam.eyeHeight = vMisc.z;\n    wanderCam.timer = vMisc.w;\n    \n    vec4 vMisc2 = LoadVec4( sampler, addr + ivec2(3,0) );    \n    wanderCam.iSitting = int( vMisc2.y );\n    wanderCam.shoreDistance = vMisc2.z;\n    wanderCam.lookAtElevation = vMisc2.w;\n}\n\nvoid WanderCam_StoreState( ivec2 addr, const WanderCamState wanderCam, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( addr + ivec2(0,0), vec4( wanderCam.pos, 0 ), fragColor, fragCoord );\n    StoreVec4( addr + ivec2(1,0), vec4( wanderCam.lookAt, 0 ), fragColor, fragCoord );\n    StoreVec4( addr + ivec2(2,0), vec4( wanderCam.targetAngle, wanderCam.lookAtAngle, wanderCam.eyeHeight, wanderCam.timer ), fragColor, fragCoord );\n    StoreVec4( addr + ivec2(3,0), vec4( 0, wanderCam.iSitting, wanderCam.shoreDistance, wanderCam.lookAtElevation ), fragColor, fragCoord );\n}\n\nvoid WanderCam_Init( inout WanderCamState wanderCam )\n{\n    if ( iFrame == 0 )\n    {\n        wanderCam.pos = vec3(0, 2, 40);\n        wanderCam.lookAt = vec3(0,2,10);\n        wanderCam.targetAngle = 0.;\n        wanderCam.lookAtAngle = 0.3;\n        wanderCam.lookAtElevation = -0.3;\n        wanderCam.eyeHeight = 1.5;\n\t\twanderCam.timer = 5.0;\n        wanderCam.iSitting = 0;\n        wanderCam.shoreDistance = 5.;\n    }\n}\n\nvec2 WanderCam_GetTarget( WanderCamState wanderCam )\n{\n    float theta = wanderCam.targetAngle;\n    return vec2( sin( theta ), cos( theta ) ) * (60.0 - wanderCam.shoreDistance);\n}\n\nvec3 WanderCam_GetLookAt( WanderCamState wanderCam )\n{\n    float theta = wanderCam.lookAtAngle;\n    float phi = wanderCam.lookAtElevation;\n    return vec3( sin( theta ) * cos(phi), sin(phi), cos( theta ) * cos(phi) );\n}\n\nvoid WanderCam_Update( inout WanderCamState wanderCam )\n{\n    vec2 target = WanderCam_GetTarget( wanderCam );\n    vec2 toTarget = target - wanderCam.pos.xz;\n    \n    float len = length( toTarget );\n    \n    if ( len > 0.0 )\n    {\n        float moveRate = min( len * 0.5, 1.0 );\n\t    float currSpeed = 0.04f * moveRate;\n        \n        float speed = min( len, currSpeed );\n        vec2 delta = normalize( toTarget ) * speed;\n\n        wanderCam.pos.xz += delta;\n    }\n    \n    if ( len < 0.1 )\n    {\n        wanderCam.timer -= iTimeDelta;\n        if ( wanderCam.timer < 0.0 )\n        {\n            // do something different\n            float rnd = hash11(iTime + 31.);\n\n            if ( rnd < 0.1 )                \n            {\n                // extend timer\n                wanderCam.timer = 2.0;\n            }\n\t\t\telse\n            if ( rnd < 0.4 )\n            {\n                // change lookat target\n                wanderCam.lookAtAngle = hash11(iTime+7.) * 2. - 1.;\n                wanderCam.lookAtElevation = hash11(iTime+29.) * -0.6 + 0.1;\n                wanderCam.timer = 2.0;\n            }\n            else\n            {\n                // random chance to sit here if we haven't\n                float rndSit = hash11(iTime + 45.);\n                if ( wanderCam.iSitting == 0 && rndSit < 0.25 )\n                {\n                    wanderCam.iSitting = 1;\n                    wanderCam.timer = 1.5;\n                }\n                else\n                {\n                    if ( wanderCam.iSitting == 1 )\n                    {\n\t                    // stand up\n                        wanderCam.iSitting = -1; // don't sit again\n                        wanderCam.timer = 1.5;\n                    }\n                    else\n                    {\n                        // Move to a different location\n                        wanderCam.targetAngle += (hash11(iTime) - 0.5) * 0.5;\n                        wanderCam.targetAngle = clamp( wanderCam.targetAngle, -1.5, 1.5);\n                        wanderCam.shoreDistance = hash11(iTime+27.) * 5.0;\n                        wanderCam.timer = 5.0;\n                    }                    \n                }                \n            }           \n        }        \n    }\n    else\n    {\n        wanderCam.iSitting = 0;\n    }\n\n    float targeth = 1.5;\n    if ( wanderCam.iSitting != 0 )\n    {\n    \ttargeth = 0.9;\n    }\n    \n    wanderCam.eyeHeight = wanderCam.eyeHeight + (targeth - wanderCam.eyeHeight) * 0.03;\n    \n    wanderCam.pos.y = Terrain_GetHeight( iChannelRockTexture, wanderCam.pos.xz, false, true );\n    wanderCam.pos.y += wanderCam.eyeHeight;\n\n    vec3 lookAt = WanderCam_GetLookAt( wanderCam );\n    \n    vec3 idealLookAt = lookAt;\n    wanderCam.lookAt = wanderCam.lookAt + (idealLookAt - wanderCam.lookAt) * 0.01;\n}\n\n//    _____ _          ____                \n//   |  ___| |_   _   / ___|__ _ _ __ ___  \n//   | |_  | | | | | | |   / _` | '_ ` _ \\ \n//   |  _| | | |_| | | |__| (_| | | | | | |\n//   |_|   |_|\\__, |  \\____\\__,_|_| |_| |_|\n//            |___/                        \n//\n\nstruct FlyCamState\n{\n    vec3 vPos;\n    vec3 vAngles;\n    vec4 vPrevMouse;\n};\n\nvoid FlyCam_LoadState( out FlyCamState flyCam, sampler2D sampler, ivec2 addr )\n{\n    vec4 vPos = LoadVec4( sampler, addr + ivec2(0,0) );\n    flyCam.vPos = vPos.xyz;\n    vec4 vAngles = LoadVec4( sampler, addr + ivec2(1,0) );\n    flyCam.vAngles = vAngles.xyz;\n    vec4 vPrevMouse = LoadVec4( sampler, addr + ivec2(2,0) );    \n    flyCam.vPrevMouse = vPrevMouse;\n}\n\nvoid FlyCam_StoreState( ivec2 addr, const in FlyCamState flyCam, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( addr + ivec2(0,0), vec4( flyCam.vPos, 0 ), fragColor, fragCoord );\n    StoreVec4( addr + ivec2(1,0), vec4( flyCam.vAngles, 0 ), fragColor, fragCoord );\n    StoreVec4( addr + ivec2(2,0), vec4( iMouse ), fragColor, fragCoord );\n}\n\nmat3 Mat_FromAngles( vec3 vAngles )\n{\n    mat3 rotX = mat3(1.0, 0.0, 0.0, \n                     0.0, cos(vAngles.x), sin(vAngles.x), \n                     0.0, -sin(vAngles.x), cos(vAngles.x));\n    \n    mat3 rotY = mat3(cos(vAngles.y), 0.0, -sin(vAngles.y), \n                     0.0, 1.0, 0.0, \n                     sin(vAngles.y), 0.0, cos(vAngles.y));    \n\n    mat3 rotZ = mat3(cos(vAngles.z), sin(vAngles.z), 0.0,\n                     -sin(vAngles.z), cos(vAngles.z), 0.0,\n                     0.0, 0.0, 1.0 );\n    \n    \n    return rotY * rotX * rotZ;    \n}\n\nvoid FlyCam_GetAxes( FlyCamState flyCam, out vec3 vRight, out vec3 vUp, out vec3 vForwards )\n{\n    vec3 vAngles = flyCam.vAngles;\n    \n    mat3 m = Mat_FromAngles( vAngles );\n    \n    vRight = m[0];\n    vUp = m[1];\n    vForwards = m[2];\n}\n\nvoid FlyCam_Init( inout FlyCamState flyCam, vec3 vStartPos, vec3 vStartAngles )\n{\n    if ( iFrame == 0 )\n    {\n        flyCam.vPos = vStartPos;\n        flyCam.vAngles = vStartAngles;\n        flyCam.vPrevMouse = iMouse;    \n    }\n}\n\nvoid FlyCam_Update( inout FlyCamState flyCam )\n{    \n    //float fMoveSpeed = 0.01;\n    float fMoveSpeed = iTimeDelta * 4.0;\n    float fRotateSpeed = 3.0;\n    \n    if ( Key_IsPressed( iChannelKeyboard, KEY_SHIFT ) )\n    {\n        fMoveSpeed *= 4.0;\n    }\n          \n    vec3 vMove = vec3(0.0);\n        \n    if ( Key_IsPressed( iChannelKeyboard, KEY_W ) )\n    {\n        vMove.z += fMoveSpeed;\n    }\n    if ( Key_IsPressed( iChannelKeyboard, KEY_S ) )\n    {\n        vMove.z -= fMoveSpeed;\n    }\n\n    if ( Key_IsPressed( iChannelKeyboard, KEY_A ) )\n    {\n        vMove.x -= fMoveSpeed;\n    }\n    if ( Key_IsPressed( iChannelKeyboard, KEY_D ) )\n    {\n        vMove.x += fMoveSpeed;\n    }\n    \n    vec3 vForwards, vRight, vUp;\n    FlyCam_GetAxes( flyCam, vRight, vUp, vForwards );\n        \n    flyCam.vPos += vRight * vMove.x + vForwards * vMove.z;\n    \n    vec3 vRotate = vec3(0);\n    \n    bool bMouseDown = iMouse.z > 0.0;\n    bool bMouseWasDown = flyCam.vPrevMouse.z > 0.0;\n    \n    if ( bMouseDown && bMouseWasDown )\n    {\n    \tvRotate.yx += ((iMouse.xy - flyCam.vPrevMouse.xy) / iResolution.xy) * fRotateSpeed;\n    }\n    \n#if FLY_CAM_INVERT_Y    \n    vRotate.x *= -1.0;\n#endif    \n    \n    if ( Key_IsPressed( iChannelKeyboard, KEY_E ) )\n    {\n        vRotate.z -= fRotateSpeed * 0.01;\n    }\n    if ( Key_IsPressed( iChannelKeyboard, KEY_Q ) )\n    {\n        vRotate.z += fRotateSpeed * 0.01;\n    }\n        \n\tflyCam.vAngles += vRotate;\n    \n    flyCam.vAngles.x = clamp( flyCam.vAngles.x, -PI * .5, PI * .5 );\n}\n\n\n\n///////////////////////////////////////////////\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iAddr = ivec2(fragCoord.xy);\n    if ( iAddr.y != 0 || iAddr.x > 16 ) \n    {\n        discard; \n        return;\n    }\n    \n\tfragColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);\n    \n   // Setup Cam\n    CameraState cam;\n    \n    // Set defaults\n    \n    vec3 vCameraInitialPos = vec3(-0.1, 5.0, 3.5);\n    \n    cam.vPos = vCameraInitialPos;\n    cam.vTarget =  vCameraInitialPos + vec3(0,0, 3.0);\n    cam.vUp = vec3(0,1,0);\n    cam.fFov = 25.0;\n    cam.fPlaneInFocus = length(cam.vTarget - cam.vPos);\n    cam.vJitter = vec2(0.0);        \n        \n    WanderCamState wanderCam;\n    WanderCam_LoadState( wanderCam, iChannelState, ivec2(11,0) );\n    \n    WanderCam_Init( wanderCam );\n \n    \n    // Update FlyCam\n    FlyCamState flyCam;\n    FlyCam_LoadState( flyCam, iChannelState, ivec2(8,0) );\n    \n    float pitch = 0.1;\n    \n\tFlyCam_Init( flyCam, vCameraInitialPos, vec3(pitch, 0.0, 0) );    \n\n    if ( Key_IsToggled( iChannelKeyboard, KEY_SPACE ) )\n    {    \n        FlyCam_Update( flyCam );\n\n        vec3 vForwards, vRight, vUp;\n        FlyCam_GetAxes( flyCam, vRight, vUp, vForwards );\n\n        cam.vPos = flyCam.vPos;\n        cam.vTarget = flyCam.vPos + vForwards;\n        cam.vUp = vUp;\n        cam.fPlaneInFocus = length(flyCam.vPos);        \n\n        cam.fPlaneInFocus = -1.0; // auto focus\n    }\n    else\n    {\n\t\tWanderCam_Update( wanderCam );\n        \n        // set cam from wander cam\n        cam.vPos = wanderCam.pos;\n        cam.vTarget = wanderCam.pos + wanderCam.lookAt;\n        \n        vec3 vNoise = SmoothNoise32( cam.vPos.xz + iTime * 0.5 );\n        \n        vec3 vShakyCamAngles = (vNoise - 0.5) * vec3( 0.05, 0.03, 0.01 );\n        mat3 m = Mat_FromAngles( vShakyCamAngles );\n        \n        vec3 vToTarget = cam.vTarget - cam.vPos;\n        cam.vTarget = cam.vPos + vToTarget * m;\n        \n        cam.vUp = vec3(0,1,0) * m;\n        \n        // update flycam position from wander cam\n        flyCam.vPos = cam.vPos;\n        vec3 vDir = cam.vTarget - cam.vPos;\n        flyCam.vAngles = vec3( 0, atan(vDir.x, vDir.z), 0);\n    }\n\n    \n#ifdef ENABLE_TAA_JITTER\n    cam.vJitter = hash21( fract( iTime ) ) - 0.5f;\n#endif    \n\n\tCam_StoreState( ivec2(0), cam, fragColor, iAddr );    \n    FlyCam_StoreState( ivec2(8,0), flyCam, fragColor, iAddr );\n    WanderCam_StoreState( ivec2(11,0), wanderCam, fragColor, iAddr );\n}", "buffer_a_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//    __  __         _           _____                           _____                   _             \n//   |  \\/  |       (_)         / ____|                         |  __ \\                 | |            \n//   | \\  / |  __ _  _  _ __   | (___    ___  ___  _ __    ___  | |__) | ___  _ __    __| |  ___  _ __ \n//   | |\\/| | / _` || || '_ \\   \\___ \\  / __|/ _ \\| '_ \\  / _ \\ |  _  / / _ \\| '_ \\  / _` | / _ \\| '__|\n//   | |  | || (_| || || | | |  ____) || (__|  __/| | | ||  __/ | | \\ \\|  __/| | | || (_| ||  __/| |   \n//   |_|  |_| \\__,_||_||_| |_| |_____/  \\___|\\___||_| |_| \\___| |_|  \\_\\\\___||_| |_| \\__,_| \\___||_|   \n//                                                                                                     \n//                                                                                                     \n\n#define iChannelState\t\t\tiChannel0\n#define iChannelRockTexture\t\tiChannel1\n\n\nEnvironmentSettings GetEnvironmentSettings()\n{\n    EnvironmentSettings env;\n    \n    env.time = iTime;\n\n    env.sunElevation = (0.2f * PI * 0.5);\n    env.sunHeading = (PI * 0.15);\n    \n#if 1\n    // day\n    env.skyZenithCol = vec3( 0.005f, 0.1f, 1.0f ) * 0.3;\n    env.skyHorizonCol = vec3( 0.1f, 0.4f, 1.0f ) * 1.0;\n    \n\tvec3 sunCol = vec3(1.0f, 0.95f, 0.65f);\n    \n    env.fogCol =  vec3( 0.6, 0.85, 0.9 ) * 2.0;\n    \n    env.sunDiscCol = sunCol * 4096.0;\n    env.sunLightCol = sunCol * 2.0;\n    \n#endif\n    \n#if 0\n    // sunset-ish\n    env.sunElevation = (0.05f * PI * 0.5);\n    \n    env.skyZenithCol = vec3(1,0.2,0) * 0.25;\n    env.skyHorizonCol = vec3( 1,0,0);\n    \n\tvec3 sunCol = vec3(1.0f, 0.25f, 0.001f);\n    \n    env.fogCol =  vec3( 1.0, 0.5, 0.0 );\n    \n    env.sunDiscCol = sunCol * 64.0;\n    env.sunLightCol = sunCol * 2.0;\n    \n#endif\n    \n#if 0\n    // night-ish\n    env.skyZenithCol = vec3(0,0,0.001);\n    env.skyHorizonCol = vec3( 0,0.01,0.05);\n    \n\tvec3 sunCol = vec3(0.2f);\n    env.sunElevation = (0.1f * PI * 0.5);\n    \n    env.fogCol =  env.skyHorizonCol;\n    \n    env.sunDiscCol = sunCol * 32.0;\n    env.sunLightCol = sunCol;// * 2.0;\n    \n#endif\n    \n#if 0\n    // Hello darkness my old friend. I've found some bugs with you again.\n    env.skyZenithCol = vec3(0);\n    env.skyHorizonCol = vec3( 0);\n    \n\tvec3 sunCol = vec3(0.0f);\n    env.sunElevation = (0.1f * PI * 0.5);\n    \n    env.fogCol =  env.skyHorizonCol;\n    \n    env.sunDiscCol = sunCol * 32.0;\n    env.sunLightCol = sunCol;// * 2.0;\n    \n#endif    \n    \n    env.ambientCol = (env.skyZenithCol + env.skyHorizonCol) * 0.5 * 0.25;\n        \n    env.ambientCol =env.fogCol;\n    env.fogDensity = 0.001f;\n    env.skyFogDensity = 0.00001f;\n        \n    //env.sunElevation = iMouse.y * PI * 0.5 / iResolution.y;\n    //env.sunHeading = iMouse.x * TAU / iResolution.x;\n\n    float se = sin( env.sunElevation );\n    float ce = cos( env.sunElevation );\n    float sh = sin( env.sunHeading );\n    float ch = cos( env.sunHeading );\n    \n    env.sunDir = normalize( vec3( ce * sh, se, ce * ch ) );\n    \n    return env;\n}\n\n\nvec3 GetExtinction( vec2 mapPos )\n{\n// https://aslopubs.onlinelibrary.wiley.com/doi/pdf/10.4319/lo.1997.42.2.0379\n// green seawater\n    vec3 extA = vec3( 0.29, 0.10, 0.43 );\n    \n    vec3 extB = vec3( 0.3, 0.11, 0.11 );    \n    float blend = SmoothNoise22( mapPos * 0.01 ).x;    \n    return mix( extA, extB, blend );\n}\n\nvec3 GetSunGlow( EnvironmentSettings env, vec3 dir )\n{\n\tfloat VdotL = dot( dir, env.sunDir );\n    \n    VdotL = VdotL * 0.5 + 0.5;\n        \n    float gf = 1.0 - VdotL;\n    \n    float scale = (1.0 / (gf * 150.0 + 0.45));\n    \n    //float scale = (1.0 / (gf * 1000.0 + 1.0));\n\n    return env.sunLightCol * scale;    \n}\n\n\nvec2 GetShorelineWaves( vec2 pos, float water_terrain_dh )\n{\n    //return vec2(0);\n    water_terrain_dh = max( 0.0f, water_terrain_dh );\n    float p = water_terrain_dh * 8.0 + iTime * 1.5;\n    //float p = pos.y;\n    //p *= water_terrain_dh * 0.05 + 1.0;\n    //p += iTime * 2.0;\n    \n    vec2 noise = SmoothNoise22( pos * 0.1 );\n    \n    p = p + noise.x * 4.0;\n    \n    float waveMag = exp( -water_terrain_dh * 0.7);\n    \n    \n    float sw = sin( p + cos(p) * (1.0 - waveMag) ) * -0.5 + 0.5;    \n    \n    //float chop = 3.0 - waveMag * 3.0;\n    //sw = pow ( 1.0 - sw, chop );    \n    \n    float fm = (sin( p - PI * 0.85 ) * 0.5 + 0.5);\n        \n    return vec2( sw * sqrt( waveMag ), fm * waveMag ) * noise.y ;\n}\n\n\nfloat Water_WaveShape( vec2 uv, float chop )\n{\n\tuv += SmoothNoise22( uv * 0.6) * 2.0;\n    \n    vec2 w = sin(uv * 2.0) * 0.5 + 0.5;\n    \n    w = 1.0 - pow ( 1.0 - w, vec2(chop) );\n    \n    float h = (w.x + w.y) * 0.5;\n    \n    return h;//pow( h, 0.1 );\n}\n\nfloat Water_GetWaves( vec2 mapPos, int waterOctaves, float time )\n{\n    float a = 1.0f;\n    \n    float h = 0.0f;\n    \n    float tot = 0.0;\n    \n    float r = 2.5f;\n    mat2 rm = mat2( cos(r), -sin(r), sin(r), cos(r) ) * 2.1f;\n    \n    vec2 aPos = mapPos;\n    \n    float waveTime = time;\n    \n    float chopA = 0.7;\n    float chopB = 0.9;\n    \n    int maxOctaveCount = 8;\n        \n    for ( int octave = 0; octave < maxOctaveCount; octave++ )\n    {            \n        if ( octave > waterOctaves )\n            break;\n\n        float chop = mix(chopA, chopB, float(octave) / float(waterOctaves-1));\n        \n        h += Water_WaveShape( aPos + waveTime , chop ) * a;\n        tot += a;\n                \n        aPos = aPos * rm;\n                \n        a *= .3;\n        \n        waveTime *= 1.6;\n        \n    }\n    \n    return h / tot;    \n}\n\nfloat Water_GetHeight( vec2 origMapPos, int waterOctaves, float time )\n{\n    \n#if EQUIRECTANGULAR_PROJECTION    \n    return -1000.0;\n#endif    \n    vec2 mapPos = origMapPos / 4.0;\n            \n\tfloat h = Water_GetWaves( mapPos, waterOctaves, time );\n    \n    bool detail = false;\n    float terrainHeight = Terrain_GetHeight( iChannelRockTexture, origMapPos, false, true );\n    float waveScale = smoothstep( 0.0, -2.0, terrainHeight ) * 0.8 + 0.2;\n    //waveScale = 0.0f;\n    \n    //waveScale *= 1.0 - smoothstep( 1.8f, 1.9f, terrainHeight );\n    \n    //waveScale = 1.0f;\n    \n    float result = h * waveScale;\n\n    float shorelineWaves = GetShorelineWaves(origMapPos, -terrainHeight).x * waveScale * 1.5;\n    \n    float water_terrain_dh = result - terrainHeight;\n#if 0\n    float foamFactor = smoothstep( 0.3, 0.0f, water_terrain_dh );\n    \n    float t= ( foamFactor * foamFactor *  foamFactor ) *  1.5;\n    float bump = 3.0 * t * t - 2.0f * t * t * t;\n    result += bump * 0.1;\n#endif  \n    \n#if 1\n    float edge = (water_terrain_dh+shorelineWaves*0.5+0.02)*5.;\n    edge = clamp(1.0-edge, 0.0, 1.0);    \n    edge = sqrt( 1.0 - edge * edge );\n    //edge = smoothstep( 0.0, 1.0, edge );\n    result += edge * 0.1;\n#endif\n    \n    //result = 0.0f;\n    \n    result += shorelineWaves;\n    \n    return result;\n}\n\nstruct MapHeight\n{\n    float height;\n    int objectId;\n};\n\nMapHeight Map_GetHeight( vec2 mapPos, int waterOctaves, bool detail )\n{\n    float groudHeight = Terrain_GetHeight( iChannelRockTexture, mapPos, detail, false );\n    MapHeight result = MapHeight( groudHeight, 0 );\n    \n    if ( waterOctaves > 0 )\n    {\n        float waterHeight = Water_GetHeight(mapPos, waterOctaves, iTime );\n        if (waterHeight > result.height )\n        {\n            result.height = waterHeight;\n            result.objectId = 1;\n        }\n    }\n    \n    return result;\n}\n\nMapHeight Map_GetAltitude( vec3 pos, int waterOctaves, bool detail )\n{\n    MapHeight mapHeight = Map_GetHeight( pos.xz, waterOctaves, detail );\n    return MapHeight( pos.y - mapHeight.height, mapHeight.objectId );    \n}\n\nvec3 Map_GetNormal( vec3 pos )\n{\n    const float delta = 0.01;\n    \n    const int normalOctaves = 8;\n    vec3 normal = vec3(1.0f, 0.0f, 1.0f) * Map_GetHeight( pos.xz, normalOctaves, true ).height\n           + Map_GetHeight( pos.xz + vec2(delta, 0.0f), normalOctaves, true ).height * vec3(-1.0f, 0.0, 0.0)\n        + Map_GetHeight( pos.xz + vec2(0.0f, delta), normalOctaves, true ).height * vec3(0.0f, 0.0, -1.0) + vec3(0.0, delta, 0.0);\n    \n    return normalize( normal );\n} \n\nstruct MapTraceResult\n{\n    float dist;\n    int objectId;\n};\n\nMapTraceResult Map_Trace( vec3 rayOrigin, vec3 rayDir, int waterOctaves, bool detail )\n{\n    MapTraceResult result = MapTraceResult( -1., -1 );\n    //if ( rayDir.y > 0.0f )\n    //{\n        //return -1.0f;\n    //}\n        \n    float minT;\n    vec3 minPos;\n    float minH;\n    \n    float maxT = 0.0f;\n    vec3 maxPos = rayOrigin + rayDir * maxT;\n\tMapHeight mapHeight = Map_GetAltitude( maxPos, waterOctaves, detail );\n    float maxH = mapHeight.height;    \n    result.dist = maxT;    \n    result.objectId = mapHeight.objectId;  \n\n    float yMax = 2.0f;\n    float yMin = -8.0f;\n    \n    yMax = min( yMax, rayOrigin.y );\n    \n    int maxIterA = 16;\n    \n    //float traceStep = 1.0;\n    \n    for( int iter = 1; iter <= maxIterA; iter++ )\n    {\n        minT = maxT;\n        minH = maxH;\n\n        float fr = float(iter) / float(maxIterA);\n        float y = yMax + (yMin - yMax) * fr;\n        \n        maxT = (y - rayOrigin.y) / rayDir.y;               \n        \n        maxPos = rayOrigin + rayDir * maxT;\n\t\tMapHeight mapHeight = Map_GetAltitude( maxPos, waterOctaves, detail );\n        maxH = mapHeight.height;\n        \n        result.dist = maxT;\n\t    result.objectId = mapHeight.objectId;  \n                \n        if ( maxH < 0.0 )\n        {\n            break;\n        }        \n    }    \n    \n    \n    int maxIterB = 11;\n    \n    for( int iter = 0; iter < maxIterB; iter++ )\n    {\n        float midT = (minT + maxT) * 0.5f;        \n        //float midT = mix( minT, maxT, ( (maxH + minH) * 0.5 - minH ) / (maxH-minH) );\n        \n        vec3 midPos = rayOrigin + rayDir * midT;\n\t\tMapHeight mapHeight = Map_GetAltitude( midPos, waterOctaves, detail );\n        float midH = mapHeight.height;\n        \n        if ( midH < 0.0f )\n        {\n            maxT = midT;\n            maxH = midH;\n            result.dist = maxT;\n\t\t    result.objectId = mapHeight.objectId;  \n        }\n        else\n        {\n            minT = midT;\n            minH = midH;\n        }      \n        \n        if ( abs( minH - maxH ) < 0.001)\n        {\n            break;\n        }\n    }\n    \n    return result;\n}\n\nvec3 GetSkyColour( EnvironmentSettings env, vec3 rayOrigin, vec3 rayDir, float mipLod, bool sunDisc )\n{\n    vec4 skyResult = TraceSky( env, iChannel1, rayDir, iTime * 3.0, mipLod, sunDisc );\n    \n    \n    vec3 result = skyResult.rgb;\n\n    float dist = skyResult.w;\n    \n    float fogFactor = 1.0 - exp( dist * -env.skyFogDensity );\n    result = mix ( result, env.fogCol, fogFactor );\n    return result; \n}\n\nvec3 GetInscatter( EnvironmentSettings env, float heading, float cosRefract, vec3 extinction )\n{\n    // hardcode LUT\n    vec3 result = vec3(0.0, 0.0, 0.0);\n\n    // some average sky color\n    vec3 skyCol = (env.skyHorizonCol * 3.0f + env.skyZenithCol * 1.0f) / 4.0f;       \n\n    // Parameters:\n    float lightIntensity = 0.07f; // overall intensity of result - don't just rely on extinction to darken color\n    float scatteringScale = 40.0f;\n    float scatteringOffset = 4.0f;\n    ///////\n\n\n    float cosSunHeading = cos( heading - env.sunHeading );\n\n    float spread = -0.5 -cosRefract * 1.5; // wrap sunlight more with \"depth\"\n\n    float sunIntensityX = cosSunHeading * ( 1.0f - spread ) + spread;\n    sunIntensityX = max( 0.0f, sunIntensityX );\n\n    float sunIntensityY = max( 0.0f, -cosRefract );\n\n\n    float sunIntensity = sunIntensityX * sunIntensityX + sunIntensityY * sunIntensityY;\n    sunIntensity *= (1.0 + cosRefract) * 8.0; // decrease sun intensity with \"spread\"\n\n    vec3 light = env.sunLightCol * sunIntensity + skyCol;\n\n    light *= lightIntensity;        \n\n    float dist = (cosRefract * cosRefract) * scatteringScale + scatteringOffset;\n\n    result.rgb = light * (exp( dist * -extinction)); // could be exp2 if we change scatteringScale and scatteringOffset values\n\n    return result;\n}\n\nfloat GIV( float dotNV, float k)\n{\n\treturn 1.0 / ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\n\nvec4 GetSandCol( vec3 pos, float mipLod )\n{\n    vec3 textureSample = textureLod( iChannel1, pos.zx * 2.0, mipLod ).rgb;\n    textureSample = textureSample * textureSample;\n\n    // darker, browner sand\n    vec3 sandColA = vec3( 0.9f, 0.63f, 0.4f );\n    sandColA = sandColA * sandColA;\n    \n    // ligher, whiter sand\n    vec3 sandColB = vec3( 1.0f, 0.8f, 0.6f );\n    sandColB = sandColB * sandColB;    \n    \n    // todo - pass in sand type factor - define regions somewhere\n    \n    float blendFactor = smoothstep(1.2, 2.0, pos.y);\n        \n\tvec3 sandCol = mix( sandColA, sandColB, blendFactor );\n    \n    //float rockFactor = clamp(-pos.y +textureSample.g * 0.75 + 0.25 + 0.0, 0.0, 1.0);\n    \n    vec2 heights = Terrain_GetHeights( iChannelRockTexture, pos.xz, true );\n        \n    float rockFactor = clamp( (heights.y - heights.x + 0.01) * 500.0, 0.0f, 1.0 );\n    \n#if EQUIRECTANGULAR_PROJECTION    \n    rockFactor = 0.0;\n#endif       \n    \n    sandCol = mix( sandCol, textureSample, rockFactor );\n    \n    //vec3 textureSampleB = textureLod( iChannel1, uv * 10.0, mipLod ).rgb;\n    //sandCol *= (textureSample.g * 0.5 + textureSampleB.r * 0.5);\n    \n    return vec4( sandCol, rockFactor );\n    /*\n    col = col * col;            \n    \n    float rawCol = col.r;\n    \n    float fade = clamp( 0.5 + pos.y, 0.0f, 1.0);\n\tfade = 0.3 + fade * 0.6f;\n    \n    col = col * (1.0f - fade) + fade;\n    col *= vec3( 1.0f, 0.85f, 0.5f );\n    \n    return vec4( col, rawCol );\n    */\n}\n\nvec3 WaterCaustics( EnvironmentSettings env, vec3 pos )\n{    \n    //return sunLightCol; // no caustics\n    \n    float h = Water_GetWaves( pos.xz, 3, iTime * 3.0 );\n    float i = 0.5f + 0.7f * h * h;\n    return env.sunLightCol * i;\n}\n\nvec3 GetSceneColour( EnvironmentSettings env, vec3 rayOrigin, vec3 rayDir, out float sceneDist )\n{\n    vec3 result = vec3(0);\n\n    float wetDiffuseFactor = 0.5;\n    \n    int waterOctaves = 3;\n    MapTraceResult mapTrace = Map_Trace( rayOrigin, rayDir, waterOctaves, false );\n    \n    if ( mapTrace.dist < 0.0 )\n    {        \n        result.rgb = GetSkyColour( env, rayOrigin, rayDir, 0.0f, true );\n        sceneDist = 10000.0;\n    }\n    else\n    if ( mapTrace.dist >= 0.0 )\n    {        \n        sceneDist = mapTrace.dist;\n        \n        vec3 hitPos = rayOrigin + rayDir * mapTrace.dist;\n        vec3 normal = Map_GetNormal( hitPos );\n                \n\n        float vR0 = 0.02f;\n        \n        float roughness = 0.0002f;\n\n        vec3 albedo = vec3(1);\n        float transparency = 1.0f;\n        vec3 colTransmitted = vec3(0);\n        \n        if ( mapTrace.objectId == 1 )\n        {\n            vec3 waterExtinction = GetExtinction( hitPos.xz );\n            {\n                \n                float terrainHeight = Terrain_GetHeight( iChannelRockTexture, hitPos.xz, false, true );\n                \n                float water_terrain_dh = hitPos.y - terrainHeight;\n                \n                float foamAmount = clamp( 1.0 - water_terrain_dh * (1.0f / 0.5f), 0.0f, 1.0f );\n                foamAmount = foamAmount * foamAmount;\n                \n\t\t\t\tfloat waveFactor = GetShorelineWaves( hitPos.xz, water_terrain_dh ).y;\n                \n                foamAmount = max( foamAmount, waveFactor );\n\n                vec2 foamMapUV = hitPos.xz; //mix(hitPos.xz, refractHitPos.xz, 0.25);\n                foamMapUV = foamMapUV * 20.0 + water_terrain_dh * 100.0;\n                \n                \n\t            //normal.xz += (SmoothNoise2( foamMapUV * 2.0) * 2.0f - 1.0f) * foamAmount * 0.2;\n                //normal = normalize( normal );\n                \n\t            vec3 rayRefracted = refract( rayDir, normal, 1.0f / 1.3333f );\n                \n                \n                \n                MapTraceResult refractTrace = Map_Trace( hitPos, rayRefracted, 0, false );\n                vec3 refractHitPos = hitPos + rayRefracted * refractTrace.dist;\n                \n                float dh = refractHitPos.y - hitPos.y;\n\n                vec3 diffuseCol = GetSandCol( refractHitPos, (log( refractTrace.dist )+1.) * 4.0).rgb;\n                \n                diffuseCol *= wetDiffuseFactor;\n\n                vec3 seabedLighting = WaterCaustics( env, refractHitPos );\n                \n                float seabedNdotL = env.sunDir.y;\n                vec3 diffuseLight  = seabedNdotL * seabedLighting * exp( (-dh / -env.sunDir.y) * waterExtinction );\n                \n                diffuseLight += env.ambientCol * exp( dh * waterExtinction );\n                                \n                colTransmitted = diffuseLight * diffuseCol;\n                \n                vec3 extinction = exp( (-refractTrace.dist ) * waterExtinction );\n\n                \n                colTransmitted *= extinction;  \n\n                {\n                    float inscatterFactor = clamp( 1.0 - rayRefracted.y, 0.0f, 1.0f );\n\n                    //vec3 inscatterScale =  exp( -inscatterFactor * waterExtinction * inscatterScaleFactor );\n\n                    float lookupU = atan(rayRefracted.x, rayRefracted.z);\n                             \n\n                    float lookupV = clamp( -rayRefracted.y, 0.0f, 1.0f);\n                    vec3 inscatterScale = GetInscatter( env, lookupU, lookupV, waterExtinction );\n\t\t\t\t\tcolTransmitted += inscatterScale;\n                }\n            //}\n            \n\t\t\t\t//colTransmitted *= RadianceChange( IOR_AIR, IOR_WATER );                \n\t            //colTransmitted *= RadianceChange( IOR_WATER, IOR_AIR );\n                \n            //{\n\n                \n                //float foam = SmoothNoise2( foamMapUV ).x;\n                vec2 foamSampleUV = foamMapUV * 0.005 + iTime * 0.1;\n                vec4 foamSample = texture( iChannel1, foamSampleUV, 0.0 );\n                float foam = foamSample.x;\n                \n                \n                foam = 1.f - foam;\n                foam = 1.f - foam* foam;\n                \n                float foamFactor = foamAmount * 0.8f;\n                \n                foamFactor = max( 0.0, foamFactor - foam * (1.0f - foamFactor));\n                \n                //foamFactor *= 0.25 + 0.75 * SmoothNoise2( hitPos.xz * 10000.0 ).x;\n                                \n                float foamThicknessFactor = 1.0;\n                //if ( abs( dh ) < 0.02 ) { foamThicknessFactor = 0.5; }\n                \n                // foam shadow\n                colTransmitted *= 1.0 - foamFactor * foamThicknessFactor;\n                \n                // foam bubbles\n                //colTransmitted += diffuseLight * exp( -foamAmount * waterExtinction * 10.0 ) * foamSample.b * 0.2;\n                \n                //albedo = vec3( SmoothNoise2( hitPos.xz * 10000.0 ).x * 0.5 + 0.5 );\n                albedo = vec3( 1.0f );\n                \n                normal.x += (foamSample.x - texture( iChannel1, foamSampleUV - vec2(0.2, 0), 0.0 ).x) * foamFactor * 0.4;\n                normal.z += (foamSample.x - texture( iChannel1, foamSampleUV - vec2(0, 0.2), 0.0 ).x) * foamFactor * 0.4;\n                normal = normalize( normal );\n                \n                \n                transparency = 1.0 - foamFactor * foamThicknessFactor;                                \n                roughness = mix( roughness, 0.3f, foamFactor * foamFactor );                \n            }            \n        }\n        else\n        {\n            vec3 mapPos = rayOrigin + rayDir * mapTrace.dist;\n            \n            vec4 sandColSample = GetSandCol( mapPos, 0.0f );\n            albedo = sandColSample.rgb;\n            transparency = 0.0f;\n            \n            float wetness = 0.0f;\n            \n            vec2 noiseLow = SmoothNoise22(mapPos.xz * 0.2);\n\n            roughness = 1.0f - sandColSample.a * (0.5 + sandColSample.r * 0.5);\n            \n            //float roughnessHeight = smoothstep( 2.0, 1.2, mapPos.y );            \n            //roughness = mix( roughness, noiseLow.y * 0.08, roughnessHeight );\n            \n#if 1\n            \n            \n            //float wetRoughness = mix( 2.0f, 1.2f, noiseLow.x );\n            float wetnessHeightFactor = smoothstep( 1.5, 0.6, mapPos.y );\n            float wetnessHeight = mix( wetness, 0.8+noiseLow.x * 0.2, wetnessHeightFactor);\n            \n            wetness = max( wetness, wetnessHeight );\n                        \n                        \n                                                \n#endif      \n            \n\t        float waterOldHeight = Water_GetHeight(mapPos.xz, 2, iTime - 0.05 );                        \n            float wetnessShorline = smoothstep( 0.4, 0.0, mapPos.y - waterOldHeight);\n            \n            wetnessShorline *= 1.0;\n                \n            wetness = max( wetness, wetnessShorline );\n            \n            \n            roughness = mix ( roughness, 0.001, wetness );            \n            albedo *= (1.0 - wetness ) * (1.0f - wetDiffuseFactor) + wetDiffuseFactor;\n            \n            //albedo = clamp( albedo + max(0.0f, wetnessShorline - 0.9), 0.0, 1.0); // attempt to hack persistent foam\n        }\n\n        vec3 h = normalize( -rayDir + env.sunDir );\n        float NdotL = max( 0.0f, dot( normal, env.sunDir ) );\n        float NdotH = dot( h, normal );\n        float NdotV = dot( rayDir, normal );\n               \n        vec3 diffuseIntensity = (NdotL * env.sunLightCol + env.ambientCol) * albedo;\n\n        colTransmitted = mix( diffuseIntensity, colTransmitted, transparency );\n        \n        roughness = roughness * 0.995 + 0.005;\n        \n        float gloss = (1.0f - roughness);\n        float glossFactor = pow( gloss, 20.0 );\n        \n        vec3 rayReflected = reflect( rayDir, normal );\n        \n        vec3 colReflected = GetSkyColour( env, hitPos, rayReflected, glossFactor * 16.0, false );\n        \n        {\n\t\t\tfloat alpha = roughness;\n            float alphaSqr = alpha * alpha;\n            float denom = NdotH * NdotH * (alphaSqr - 1.0) + 1.0f;\n            float k = alpha / 2.0;\n            float vis = GIV(NdotL, k) * GIV(NdotV, k);\n            float f = alphaSqr / (PI * denom * denom);\n            colReflected += f * NdotL * env.sunLightCol;\n        }\n        \n        \n        {\n            float NdotV = max( 0.0, dot( rayDir, -normal ) );\n\n            vec3 fresnel = vR0 + (vec3(1.0) - vR0) * pow( 1.0 - NdotV, 5.0 ) * glossFactor;\n\n            result.rgb = mix( colTransmitted, colReflected, fresnel );\n        }            \n        \n    \n        float dist = mapTrace.dist;\n        float fogFactor = 1.0 - exp( dist * -env.fogDensity );\n        result.rgb = mix ( result.rgb, env.fogCol, fogFactor );\n\t}\n\n    vec3 sunGlow = GetSunGlow( env, rayDir );\n    result.rgb += sunGlow;\n\n    return result;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n    vec2 uv = fragCoord.xy / iResolution.xy;;\n\n    CameraState cam;\n\tCam_LoadState( cam, iChannelState, ivec2(0,0) );\n    \n    // Trace Scene\n    float fAspectRatio = iResolution.x / iResolution.y;            \n    \n    vec3 rayOrigin, rayDir;\n    vec2 vJitterUV = uv + cam.vJitter / iResolution.xy;\n    Cam_GetCameraRay( vJitterUV, fAspectRatio, cam, rayOrigin, rayDir );    \n\n\tEnvironmentSettings env = GetEnvironmentSettings();\n    \n    float dist;\n    vec3 sceneColor = GetSceneColour( env, rayOrigin, rayDir, dist );\n    \n    fragColor = vec4(sceneColor,dist);\n}\n", "buffer_c_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3XDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1723, 1723, 1762, 1762, 1971], [1974, 1974, 2012, 2012, 2415], [2438, 2438, 2492, 2492, 2849], [2851, 2851, 2904, 2904, 4464], [4467, 4467, 4524, 4524, 5337]], "test": "untested"}
{"id": "wsSczz", "name": "Lockdown", "author": "ocb", "description": "Long time I haven't been on shadertoy.\nGlad to hear from you.\n\nStill drifting in a desolate space journey...\n\nMusic Koyaanisqatsi, Philip Glass, 1983\n", "tags": ["fbm", "space", "planet", "crater"], "likes": 37, "viewed": 765, "published": 3, "date": "1585951075", "time_retrieved": "2024-07-30T21:15:05.754541", "image_code": "// Author: \t\tocb\n// Title: \t\tLockdown\n\n// Ray-marching + FBM is twice a slow process.\n// Moreover, computing hard shadows needs the same process again (twice slow again)\n// To maintain acceptable speed perfos:\n// 1- The crater shape function is ray-marched first (with no fbm)\n// \t  and when close to the final surface the FBM is included in the ray-march process.\n// 2- The hard shadows are pre-computed in buffer A.\n//    Using the 4 channels (4 squared sectors around origin) to increase resolution.\n// \t  Hard shadows are just added at the end of the color process.\n//    A trick is used to detect screen size (resolution) changes.\n//\n// More comments are included in Common to manage some parameters.\n\n\n\n/*****************************    Image   *****************************/\n\nvec3 skyCol(vec3 ray){\n    float lit = dot(ray,LIGHT);\n    return vec3(1,.5,0)*(.6-max(0.,ray.y))*(.7+.3*lit) + .002/(1.002-lit);\n}\n  \n/************************************************************************/\n/*\t\t\t\t\t\t\tGround fct\t\t\t\t\t\t\t\t\t*/\n/************************************************************************/\n\n// mapping global crater shape\nfloat shape(vec2 g){\n\tfloat a = .000001*(g.x*g.x + g.y*g.y);\n    float h = smin(a*a,abs(1./a),.2)+.8/(50.*a+1.);\n    return h;\n}\n\n// mapping accurate ground, adding shape + fbm + texture\nfloat ground(vec2 g, float t){\n\tfloat len = max(abs(g.x),abs(g.y));\n    if(len>5000.) return .5; \n    float h = shape(g);\n    float m = fbm(vec3(g.x,maxHill*h,g.y));\n    m *= 1.-linstep(3000.,5000.,len);\n    \n    // scaling texture\n    float tex,trans,dump;\n    if(t>300.){\n    \tfloat dump = 1.-linstep(300.,2000.,t);\n        tex = dump*1.5*texture(iChannel0,.00125*g.xy+.5).r;\n    }\n    else if(t>100.){\n    \ttrans = linstep(100.,300.,t);\n        tex = trans*1.5*texture(iChannel0,.00125*g.xy+.5).r+(1.-trans)*.3*texture(iChannel0,.01*g.xy+.5).r;\n    }\n    else if(t>50.){\n        tex = .3*texture(iChannel0,.01*g.xy+.5).r;\n    }\n    else{\n    \ttrans = linstep(20.,50.,t);\n        tex = trans*.3*texture(iChannel0,.01*g.xy+.5).r+(1.-trans)*.05*texture(iChannel0,.05*g.xy+.5).r;\n    }\n        \n    return maxHill*(.4*h*m+.2*m+.4*h)+ tex;\n}\n\n\nvec3 getGndNormal(vec3 p, float t){\n    vec2 e = vec2(.1-.075*step(t,50.),0.);\t// step() to adjust accuracy to the scale\n\tfloat dx = ground(p.xz+e.xy,t) - p.y;\n    float dy = ground(p.xz+e.yx,t) - p.y;\n    return normalize(vec3(dx,-e.x,dy));    \n}\n\n\n// Fast marching to the global shape\nfloat traceShape(in vec3 pos, in vec3 ray){\n    float t = 0., dh;\n    vec3 p = pos;\n    for(int i=0;i<60;i++){\n        dh = p.y-maxHill*shape(p.xz)*1.15;\n        if(dh<10.)break;\n        t += dh;\n        p = pos+t*ray;\n        if(p.y > 1.5*maxHill && ray.y>=0.){\n            t = INFINI;\n            break;\n        }\n    }\n    return t;\n}\n\n// Marching:\n// step 1 = fast marching to the shape\n// step 2 = fine tunning on the ground\nfloat traceGround(in vec3 pos, in vec3 ray){\n    float t = 0.;\n\n    float dh = pos.y-ground(pos.xz,t);\n    if(dh<.1) return .0001;\n    \n    if(pos.y > maxHill*shape(pos.xz)*1.15) t = traceShape(pos, ray);    \n    if(t == INFINI) return INFINI;\n    \n    vec3 p = pos + t*ray;\n    for(int i=0; i<70;i++){\n        dh = p.y-ground(p.xz,t);\n        if(abs(dh)<.1-.075*step(t,50.)) break;\n        t += .9*dh;\n        p = pos+t*ray;\n        if(p.y > 1.5*maxHill && ray.y>=0.){\n            t = INFINI;\n            break;\n        }\n    }\n    return t;\n}\n\n\n\nvec3 PaintCrater(vec3 p, vec3 ray, float tg, vec3 norm){\n    \n    // scaling texture\n    float trans;\n    vec3 tex;\n    if(max(abs(p.x),abs(p.z))>3000.){\n        tex = texture(iChannel0,.0000625*p.xz+.5).rgb;\n    }\n \telse if(tg>100.){\n    \ttrans = linstep(100.,300.,tg);\n        tex = trans*texture(iChannel0,.00125*p.xz+.5).rgb+(1.-trans)*texture(iChannel0,.01*p.xz+.5).rgb;\n    }\n    else if(tg>50.){\n        tex = texture(iChannel0,.01*p.xz+.5).rgb;\n    }\n    else{\n    \ttrans = linstep(20.,50.,tg);\n        tex = trans*texture(iChannel0,.01*p.xz+.5).rgb+(1.-trans)*texture(iChannel0,.05*p.xz+.5).rgb;\n    }\n    \n    // setting color and shade\n    vec3 col = vec3(.5,.25,.0)*(.8+max(0.,p.y)/maxHill)+ tex;\n    col *= dot(-norm,LIGHT);\n\n    // fog\n    float tt = 3000./tg;\n    col *= min(1.,tt);\n    col = mix(skyCol(ray), col, min(.7,tt));\n\n    return col;\n}\n\nfloat groundShadows(vec2 p){\n    float txg;\n    vec2 e = vec2(.001,0.), f = vec2(-.001,.001);\n    vec2 g = abs(p.xy)/2000.;\n    if(sign(p.x)>0.){\n        if(sign(p.y)>0.){\n            txg = texture(iChannel1,g+e.xx).x\t// Simple triangular interpolation\n                + texture(iChannel1,g+f.xy).x\t// is enough and reduce workload\n                + texture(iChannel1,g-e.yx).x\n                - 3.*iResolution.x;\t\t\t\t// removing resolution info (stored in buffer A)\n        }\n        else{\n            txg = texture(iChannel1,g+e.xx).y\n                + texture(iChannel1,g+f.xy).y\n                + texture(iChannel1,g-e.yx).y;\n        }\n    }\n    else{\n        if(sign(p.y)>0.){\n            txg = texture(iChannel1,g+e.xx).w\n                + texture(iChannel1,g+f.xy).w\n                + texture(iChannel1,g-e.yx).w;\n        }\n        else{\n            txg = texture(iChannel1,g+e.xx).z\n                + texture(iChannel1,g+f.xy).z\n                + texture(iChannel1,g-e.yx).z;\n        }\n    }\n    return txg *= .333333;\n}\n\n/************************************************************************/\n/*\t\t\t\t\t\t\tDome fct\t\t\t\t\t\t\t\t\t*/\n/************************************************************************/\n\n// coord. change\nvec2 polar(vec3 p){ return vec2(atan(p.z/p.x)+PI*step(p.x,0.),atan(length(p.xz)/p.y)); }\n\nvec3 cartesian(vec2 i){float s = sin(i.y); return vec3(s*cos(i.x),cos(i.y),s*sin(i.x));}\n\n// Raycasting\nvec2 sphere(in vec3 p, in vec3 O, in float r, in vec3 ray){\n    vec2 t = vec2(INFINI);\n    vec3 d = O - p;\n    float b = dot(d, ray);\n    \n    if (b >= 0.){\n        float c = dot(d,d) - r*r;\n    \tfloat D = b*b - c;\n    \tif (D >= 0.){\n        \tfloat VD = sqrt(D);\n            t.x= b - VD;\n            t.y= b + VD;\n        }\n    }\n    return t;\n}\n\n// Black structure on sphere, depending on scale\nfloat structure(vec3 p, float scale){\n    vec2 a = polar(p)/PIdiv2;\n    a.y *= 3.;\n    float iy = floor(a.y);\n    a.x *= 2.*scale;\n    a.x += 1./pow(scale,scale);\n    a.x += mod(iy,2.)*.5;\n    a = fract(a)-vec2(.5,0.);\n    float d = 2.*abs(a.x);\n    /*if(iy<scale-6.) d = 1.;\n    else*/ if(iy<scale-5.) d -= smoothstep(.0,.1,a.y)-.05;\n    else d -= smoothstep(-0.12,.5,a.y)-.05;\n\n    return d;\n}\n\n// Black structure on sphere.\n// Call twice at 2 differents scales (thick and thin) \nfloat frame(vec3 p){\n        \n    float d = structure(p,2.);\n    float c = smoothstep(-.04,-.02,-abs(d));\n\n    d = structure(p,4.);\n    c = max(c,smoothstep(-.03,-.01,-abs(d)));\n    \n    return c;\n}\n\nvec3 DrawStruct(vec3 p, vec3 ray, vec3 C){\n\tvec3 col = vec3(.0);\n    p -= C;\t\t// origin of the coord set on the center of sphere\n    \n    col -= frame(p);\t// blacken the frame\n    \n    vec2 tile = WINTILE/PIdiv2;\t\t// number of window glass\n    vec2 a = tile*polar(p);\t\t\t// tiling polar coordinates\n    vec2 i = floor(a.xy)/tile;\n    vec2 f = abs(fract(a.xy)-.5);\n    \n    float d = smoothstep(.48,.5,max(f.x,f.y));\t\t\t// draw thin contour of each window\n    col -= d;\n        \n    vec3 norm = cartesian(i);\t\t// back to cartesian. Same normal for the whole window (i = floor)\n    vec3 refl = reflect(ray,norm);\t\n    \n    float spec = .2/(1.1-dot(LIGHT,refl));\t\t// calculating sky reflection\n    col += spec*skyCol(refl);\t\t\t\t\t// and specular light\n    col += spec*d;\t\t\t\t\t\t\t\t// sky reflection is used on the whole surface to set the golden color of the dome\n    \n    p += C;\n    float t = traceGround(p,refl);\t\t\t\t// Adding ground reflection using the\n    if(t<INFINI){\t\t\t\t\t\t\t\t// window normal\n        p += t*refl;\t\t\t\t\t\t\t\t\n        p.y = ground(p.xz,t);\t\t\t\t\t\t\t\t\n    \tvec3 n = getGndNormal(p,t);\n    \tcol += .5*PaintCrater(p,refl,t,n)*groundShadows(p.xz);\n    }\n    else col += skyCol(refl);\n    \n    return col;\n}\n\n\n/************************************************************************/\n/*\t\t\t\t\t\t\tCamera\t\t\t\t\t\t\t\t\t\t*/\n/************************************************************************/\n\n\nvec3 getCamPos(in vec3 camTarget){\n    \n #ifdef FREE_CAM\n    float \trau = RAU,\n            alpha = iMouse.x/iResolution.x*4.*PI,\n            theta = (iMouse.y+.001)/iResolution.y*PI+ (PI/2.0001);\t// +0.001 to avoid black horizontal line\n #else\n    float ti = TIME_SET;\n    float cs = (1.-cos(ti*.09-PI));\n    //float s = smoothstep(25.,120.,abs(ti-60.));\n    float rau = 25. + 2500.*smoothstep(25.,120.,abs(ti-90.))*(1.-smoothstep(180.,280.,ti)),\n    \t  alpha = ti*.12-1.,\n    \t  theta = .1*cs*cs*cs+.05;\n #endif\n            \n    return rau*vec3(-cos(theta)*sin(alpha),sin(theta),cos(theta)*cos(alpha))+camTarget;\n}\n\nvec3 getRay(in vec2 st, in vec3 pos, in vec3 camTarget){\n    float \tfocal = 1.;\n    vec3 ww = normalize( camTarget - pos);\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0)) ) ;\n    vec3 vv = cross(uu,ww);\n\treturn normalize( st.x*uu + st.y*vv + focal*ww );\n}\n\n\n/************************************************************************/\n/*\t\t\t\t\t\t\t\tMain\t\t\t\t\t\t\t\t\t*/\n/************************************************************************/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 C = vec3(1.);\n    C.y = ground(C.xz,1.);\n    \n    //vec3 camTarget = TARGET;\n    vec3 camTarget = C + vec3(0.,3.,0.);\n    vec3 pos = getCamPos(camTarget);\n    pos.y = max(pos.y, 1.05*ground(pos.xz,1.));\n    vec3 ray = getRay(st, pos,camTarget);\n\t\t\n    vec3 col = vec3(.0);\n    vec3 coldom = vec3(.0);\n    vec3 norm;\n    \n    float tg = INFINI;\n    vec2 ts;\n        \n    tg = traceGround(pos,ray);\n    \n    if(tg<INFINI){\t\t\t\t\t\t// Ground is touched\n        \n        vec3 p = pos + tg*ray;\n        p.y = ground(p.xz,tg);\t\t\t// recalculating p.y (vertical) to be more accurate on position\n\t\t\t\t\t\t\t\t\t\t// needed due to the fine details\n        norm = getGndNormal(p,tg);\n\n        col += PaintCrater(p,ray,tg, norm);\n        \n        float txg=1., txs=1.;\t\t\t\t\t\t\t// finally, adding shadows pre-calculated on the buffer A\n        if(max(abs(p.x),abs(p.z))<2000.){\t\t\t\t \n            \n            txg = groundShadows(p.xz);\n            \n            vec2 tss = sphere(p+.2*norm,C,R,LIGHT);\t\t// And finally to finally, adding the dome\n            if(tss.x<INFINI){\t\t\t\t\t\t\t// shadow, only the frame, as windows are \n                p += tss.x*LIGHT-C;\t\t\t\t\t\t// supposed to be partially transparent.\n                txs = .1+.8*dot(normalize(p),-LIGHT);\t// dot() is to simulate more thickness on the edges\n                txs *= .6-.6*frame(p);\n                //txs *= 1.-.8*frame(p+(tss.y-tss.x)*LIGHT);\n            }\n            \n            col *= min(txs,txg);\n\n    \t}\n    }\n \n    else col += skyCol(ray);\t\t\t\t\t\t// no hit = sky\n\n    \n    ts = sphere(pos,C,R,ray);\n    \n\tif(ts.x < tg){\t\t\t\t\t\t// Dome is touched\n        \n        vec3 p = pos + ts.x*ray;\n        coldom += DrawStruct(p,ray,C);\t// draw frame and color\n        \n        if(ts.y<tg){\t\t\t\t\t// draw the other side of the dome\n            p = pos + ts.y*ray;\t\t\t// visible by transparency\n            p-=C;\n            coldom = mix(coldom,vec3(-frame(p)),.2);\n            col*=.1;\n        }\n        \n    if(tg < ts.y) col = vec3(0.);\t// center of the dome is black\n    col = mix(col,coldom,0.6);\t\t// mixing sphere and color behind for the partial transparency\n    }\n    \n    fragColor = vec4(1.5*col,1.0);\n}\n\n", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 21773, "src": "https://soundcloud.com/ilya2184/philip-glass-koyaanisqatsi", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "#define PI 3.141592653589793\n#define PIdiv2 1.57079632679489\n#define TwoPI 6.283185307179586\n#define INFINI 1000000.\n\n// Ground def\n#define STEP 6.\n#define maxHill 200.\n\n// Dome def\n#define R 10.\n//#define C vec3(0.,128.,0.)    // defined in main image\n#define WINTILE vec2(32.,16.)\n\n/*************************************/\n/*          GROUND CONTROL           */\n/*************************************/\n\t\t\t\t\t\t\t\t\t\t// if terrain is inappropriate, ie center hill too high\n\t\t\t\t\t\t\t\t\t\t// or dome on the back-side, or too much collisions cam-terrain\n\t\t\t\t\t\t\t\t\t\t// change the offset of the fbm, as random result depends on each\n\t\t\t\t\t\t\t\t\t\t// GPU.\n#define FBM_OFFSET vec2(-.5,.5)\t\t\n\n\n\n/*************************************/\n/*            CAM CONTROL            */\n/*************************************/\n\t\t\t\t\t\t\t\t\t\t\t\t// Select one of the time set below.\n\t\t\t\t\t\t\t\t\t\t\t\t// time depending on iTime\n\t\t\t\t\t\t\t\t\t\t\t\t// or time depending on mouse \n#define TIME_SET 1.5*iTime\n//#define TIME_SET iMouse.x/iResolution.x*280.\n\n\n\t\t\t\t\t\t\t// Uncomment FREE_CAM to have mouse controle\n\t\t\t\t\t\t\t// Change RAU value to set the distance to the visual center (target)\n//#define FREE_CAM\n\n#define RAU 25.\n\n/* centered on dome */\n//#define TARGET C + vec3(0.,3.,0.);\t// defined in main image\n\n/* centered on dome shadow */\n//#define TARGET vec3(380.,20.,380.);\n\n/* following crater cliff (in) */\n//#define TARGET vec3(800.*cos(.1*iTime)+300.,250.,800.*sin(.1*iTime));\n// * following crater cliff (out) */\n//#define TARGET vec3(1200.*cos(.1*iTime)+300.,250.,1200.*sin(.1*iTime));\n\n\n/********************************************************************/\n/********************************************************************/\n\n\n#define LIGHT vec3(-0.691714463866075,0.207514339159822,-0.691714463866075)\n\n\n\n\nfloat H2(in vec2 st) { \t\t\t\t\t\t\n    return fract(sin(dot(st,vec2(12.9898,8.233))) * 43758.5453123);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n/* linear step = poor smoothstep but faster */\nfloat linstep(float a, float b, float x){\n    return clamp((x-a)/(b-a),0.,1.);\n}\n\n\nfloat fbm(vec3 p){\n    p*= .0035;\n    vec2 uv = p.xz+FBM_OFFSET;\n\tfloat a = 1., Hz = 1., m = 1., h= p.y;\t\t\t\t\t\n    vec2 d = vec2(1.,0.);\n    for(float i=1.;i<=STEP; i++){\n        vec2 e = floor(uv*Hz), f = fract(uv*Hz);\n        f = smoothstep(0.,1.,f);\n        h += mix(\n            \tmix(H2(e),H2(e+d.xy),f.x)*a,\n            \tmix(H2(e+d.yx),H2(e+d.xx),f.x)*a,\n            \tf.y);\n        \n        a *= .2+.1*h+.05*i;\n        //a *= .5;\n        Hz *= 2.+.2*p.y;\n        m += a;\n    }\n    h/=m;\n    \n    h *= h;\n    \n    return h;\n}\n\n", "buffer_a_code": "/*******************    buffer A    *********************/\n/*\t\t\t\t\t\t\t\t\t\t\t\t\t\t*/\n/*               Shadows pre-calculation                */\n/* The 4 channels are used to increase map resolution   */\n/* \t\t\t\t\t\t\t\t\t\t\t\t\t\t*/\n/********************************************************/\n\n\nfloat ground(vec2 p){\n    \n    float a = .000001*(p.x*p.x + p.y*p.y);\n    float h =smin(a*a,abs(1./a),.2)+.8/(50.*a+1.);\n    float m = fbm(vec3(p.x,maxHill*h,p.y));\n    return maxHill*(.4*h*m+.2*m+.4*h)+ texture(iChannel0,.00125*p.xy+.5).r;\n}\n\nvec3 getGndNormal(vec3 p){\n    vec2 e = vec2(.1,0.);\n\tfloat dx = ground(p.xz+e.xy) - p.y;\n    float dy = ground(p.xz+e.yx) - p.y;\n    return normalize(vec3(dx,-e.x,dy));    \n}\n\n\nfloat traceGround(in vec3 pos, in vec3 ray){\n    float t = 0.;\n    float dh = pos.y-ground(pos.xz);\n    if(dh<.1) return .0001;\n    for(int i=0; i<75;i++){\n        vec3 p = pos;\n        t += .9*dh;\n        p = pos+t*ray;\n        if(p.y > 1.6*maxHill && ray.y>=0.){\n            t = INFINI;\n            break;\n        }\n        dh = p.y-ground(p.xz);\n        if(dh<.1)break;\n    }\n    return t;\n}\n\n\nfloat shad(vec3 p){\n    \n        p.y = ground(p.xz);\n        vec3 norm = getGndNormal(p);\n        p -= .2*norm;\n        float t = traceGround(p,LIGHT);\n        if(t<INFINI) return .2;    \n        else return 1.;    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float check = floor(texelFetch(iChannel1,ivec2(fragCoord),0).x -.1);\t// checking if resolution has changed\n    if(check == iResolution.x){\t\t\t\t\t\t\t\t\t\t\t\t// in order to manage screen size change.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// if no change, just reading pre-calculated shadows\n        fragColor = texture(iChannel1,fragCoord/iResolution.xy);\t\t\t// stored in Buffer A\n    }\n\n    else{   \n        vec2 st = 2000.*fragCoord.xy/iResolution.xy;\t\t\t\t// if screen size has changed, bufferA size changed too \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// shadows must be recalculated.\n        vec3 p = vec3(st.x,0.,st.y);\n        fragColor.x = shad(p)+iResolution.x;\t\t\t\t\t\t// storing new resolution info\n\n        p.z = -p.z;\n        fragColor.y = shad(p);\n\n        p.x = -p.x;\n        fragColor.z = shad(p);\n\n        p.z = -p.z;\n        fragColor.w = shad(p);\n    } \n}\n\n", "buffer_a_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsSczz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[783, 783, 805, 805, 914], [1100, 1131, 1151, 1151, 1259], [1261, 1318, 1348, 1348, 2157], [2160, 2160, 2195, 2195, 2407], [2410, 2447, 2490, 2490, 2784], [2786, 2877, 2921, 2921, 3421], [3425, 3425, 3481, 3509, 4286], [4288, 4288, 4316, 4316, 5315], [5497, 5514, 5533, 5533, 5602], [5604, 5604, 5627, 5627, 5692], [5694, 5708, 5767, 5767, 6052], [6054, 6103, 6140, 6140, 6498], [6500, 6585, 6605, 6605, 6783], [6785, 6785, 6827, 6827, 7992], [8175, 8175, 8209, 8209, 8790], [8792, 8792, 8848, 8848, 9052], [9232, 9232, 9289, 9289, 11512]], "test": "untested"}
{"id": "tdBczR", "name": "Test CubeA bitwise accuracy", "author": "Observer", "description": "Testing how many bits we can store in a CubeA texture.\nOn my system I get error in ranges 7C00..7FFF and FC00..FFFF.\nPlease let me know if it is different on your system!", "tags": ["test", "glitch", "cubea"], "likes": 3, "viewed": 437, "published": 3, "date": "1585943091", "time_retrieved": "2024-07-30T21:15:06.729933", "image_code": "const int marginL = 42;\nconst int marginR = 16;\nconst int marginT = 16;\nconst int marginB = 24;\n\nint[] hex = int[] ( 432534, 287812, 431151, 492679, 630664, 989063, 923542, 1016866, 431766, 433799, 434073, 497559, 921886, 498071, 988959, 988945);\n\nbool drawHex4(in int value, in vec2 coord, in vec2 pos)\n{\n    if (coord.x < pos.x || coord.y < pos.y) return false;\n    ivec2 p = ivec2((coord - pos) / 2.);\n    int dig = p.x / 5;\n    p.x = p.x - dig * 5;\n    if (dig >= 0 && dig < 4 && p.y < 5 && p.x < 4)\n    {\n        int v = hex[(value >> (12 - dig * 4)) & 15];\n        return (v & (1 << (p.x + p.y * 4))) != 0;\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float lineColor = 0.0;\n    float textColor = 0.0;\n    float graphColor = 0.0;\n    float graphError = 0.0;\n\n    ivec2 res = ivec2(iResolution.xy);\n    ivec2 size = res - ivec2(marginL + marginR, marginT + marginB);\n    ivec2 coord = (ivec2(fragCoord) - ivec2(marginL, marginB)) * ivec2(maxStep - minStep) / size + ivec2(minStep);\n    \n    // Nr of itermediate steps\n    ivec2 stp = ivec2(maxStep - minStep) / size + 1;\n\n    // Min distance between grid lines\n    int sc = 32 << int(log(float(stp.x))/log(2.));\n    \n    bool fnd = false;\n\n    if (coord.y >= minStep && coord.y <= maxStep && coord.x >= minStep && coord.x <= maxStep)\n    {\n        for (int sx = 0; sx < stp.x; sx++)\n        {\n            int vx = coord.x + sx;\n            ivec2 tcoord = ivec2(vx % 1024, vx / 1024);\n            vec3 rd = vec3(float(tcoord.x * 2 - 1023), 1024.0, float(tcoord.y * 2 - 1023));\n            vec4 state = texture(iChannel0, rd);\n\n            int vy = int(packHalf2x16(vec2(state.b, 0.0)));\n            if (coord.y == vy)\n            {\n                fnd = true;\n                graphColor = 1.0;\n            } else\n            if (vx != vy)\n            {                \n                graphError = 0.2;\n            }\n        }\n        \n        // Grid lines\n    \tif (coord.x >= minStep && coord.x <= maxStep)\n    \t{\n            coord += stp/2;\n    \t\tif (coord.x % sc < stp.x) lineColor += 0.1;\n    \t\tif (coord.x % (sc << 2) < stp.x) lineColor += 0.2;\n    \t\tif (coord.x % (sc << 4) < stp.x) lineColor += 0.3;\n    \t\tif (coord.x % (sc << 6) < stp.x) lineColor += 0.4;\n    \t\tif (coord.y % sc < stp.y) lineColor += 0.1;\n    \t\tif (coord.y % (sc << 2) < stp.y) lineColor += 0.2;\n    \t\tif (coord.y % (sc << 4) < stp.y) lineColor += 0.3;\n    \t\tif (coord.y % (sc << 6) < stp.y) lineColor += 0.4;\n        }\n \n\t}\n    \n    // Axis labels\n    int addrStep = sc << 2;\n    ivec2 textoffset = ivec2(20, 5) * (maxStep - minStep) / size;\n    if (fragCoord.y < float(marginB))\n    {\n        int adr = ((coord.x + textoffset.x) / addrStep) * addrStep;\n\t    textColor += float(drawHex4(adr, fragCoord, vec2((adr - minStep - textoffset.x) * size.x / (maxStep - minStep) + marginL, 8)));\n    }\n    if (fragCoord.x < float(marginL))\n    {\n        int adr = ((coord.y + textoffset.y) / addrStep) * addrStep;\n\t    textColor += float(drawHex4(adr, fragCoord, vec2(0, (adr - minStep - textoffset.y) * size.y / (maxStep - minStep) + marginB)));\n    }\n    \n    fragColor.rgb = vec3(1.0 - (lineColor + textColor + graphColor)) * vec3(1.0, 1.0 - graphError, 1.0 - graphError);\n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// The CubeA is a great texture which can hold a lot of data. Being fixed sized, \n// it is ideal to store all kinds of large structures.\n// It contains 6 planes of 1024x1024 pixels. A CubeA pixel consist of 4 low-precision\n// components (4x16 bits), so in theory we could store 384 Mbit = 48 MByte there!\n// There is one important limitation: we cannot use all 16 bits of a component.\n// By using unpackHalf2x16 and packHalf2x16 we can pack 2x 16-bit uints into 2x low precision\n// floats and vice-versa. However we seem to loose some precision, maybe because converting low\n// precision float to high precision floats (the native type in GLSL) and back.\n// Not every bit combination seems to lead to a valid float (think of NaN).\n//\n// At my system (Windows 10, both Firefox and Chrome, ANGLE) this has the effect that in a range\n// of 0..FFFF there are two ranges that will not be correctly converted: 7C00..7FFF and FC00..FFFF\n// (indicated by the two red bars in the graph).\n// So effectively we can only use 15 of the 16 bits (not using bit 14).\n//\n// I'm curious if this is videocard/GLSL version dependent and if everybody experiences the same\n// effect. If that's the case, we can still store 360 MBit = 45 MByte, which is still a huge amount!\n\n// Doesn't seem to have effect:\nprecision lowp float;\n\n// - Zoom in on first range 7C00..7FFF\n// const int minStep = 0x7B00;\n// const int maxStep = 0x8100;\n\n// - Zoom in on second range FC00..FFFF\n// const int minStep = 0xFB00;\n// const int maxStep = 0xFFFF;\n\n// - Complete range to test\nconst int minStep = 0x0000;\nconst int maxStep = 0xFFFF;", "cube_a_code": "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    ivec2 coord = ivec2(fragCoord);\n    int a = (coord.x + coord.y * 1024) & 0xFFFF;\n    fragColor.b = unpackHalf2x16(uint(a)).x;\n}", "cube_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdBczR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[248, 248, 305, 305, 638], [640, 640, 697, 697, 3243]], "test": "untested"}
{"id": "tsSyzR", "name": "Circle with sigmoid falloff", "author": "nickcody", "description": "Basic circle, experimenting with geometry and edges ---> CLICK! \n\nHold mouse down and Y-axis adjusts thickness and X-axis adjusts fuzziness.", "tags": ["circle", "geometry", "basics", "sigmoid"], "likes": 2, "viewed": 471, "published": 3, "date": "1585940481", "time_retrieved": "2024-07-30T21:15:07.546749", "image_code": "const float E = 2.7182818284590452353602875;\n\nfloat sigmoid(float x) {\n    return 1.0/(1.0+pow(E, -x));\n}\n\n// Maps\n// 0 -> 0.5 -> 1 to 0 -> 1.0 -> 0\n//\nfloat sigmoidToFalloff(float s) {\n    return abs(1.0 - (s * 2.0));\n}\n\n//\n// coord - pixel to test\n// center - center of circle\n// radius - radius of circle\n// tolerance - thickness of circle line\n// sharpness - 1.0 blurry, 0.0001 sharp\nfloat test(vec2 coord, vec2 center, float radius, float thickness, float sharpness) {\n    float d = sqrt(pow(coord.x - center.x,2.0) + pow(coord.y - center.y,2.0));\n    float d1 = abs(d-radius);\n\n    if (d1 < thickness)\n        return 0.0;\n    else\n        return sigmoidToFalloff(sigmoid((d1-thickness)*sharpness));\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord) {\n    vec3 white = vec3(1.0, 1.0, 1.0);\n    vec3 black = vec3(0.0, 0.0, 0.0);\n    float scale = 1.0;\n    float radius = iResolution.x/5.0;\n\n    vec2 center = (iResolution.xy * scale)/2.0;\n    vec2 st = (fragCoord.xy * scale);\n    \n    float thickness;\n    float sharpness;\n\n    if (iMouse.xy == vec2(0)) {\n        thickness = 1.;\n        sharpness = 2.;\n    } else {\n\t    thickness = iMouse.y/iResolution.y * 30.0 * scale;\n    \tsharpness = iMouse.x/iResolution.x * scale;\n    }\n    \n    \n    float t = test(st, center, radius, thickness, sharpness);\n    out_color = vec4( mix(white, black, t), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsSyzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 70, 70, 105], [107, 152, 185, 185, 220], [222, 388, 473, 473, 706], [708, 708, 760, 760, 1360]], "test": "untested"}
{"id": "wdlyDX", "name": "Graph acceleration structure 3D", "author": "michael0884", "description": "A graph sorting acceleration structure designed to work efficiently with ray marching. Currently thinking how to optimize it without braking hmmm....", "tags": ["marching", "particles", "objects"], "likes": 7, "viewed": 483, "published": 3, "date": "1585937424", "time_retrieved": "2024-07-30T21:15:08.579987", "image_code": "//Graph is in Buf A, graph traversal is in Buf B\n//You can pause the simulation by setting dt in Common to 0.\n//Change the number of particles by changing N in Common\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    fragColor = texel(ch1, pos);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define N ivec2(64,64)\n#define sN ivec2(4,2)\n#define dt 0.\n\n#define loop(x) for(int i = min(0, iFrame); i < x; i++)\n\nconst int tot_n = N.x*N.y;\n\nivec2 i2xy(ivec3 sid)\n{\n    return sN*ivec2(sid.x%N.x, sid.x/N.x) + sid.yz;\n}\n\nivec3 xy2i(ivec2 p)\n{\n    ivec2 pi = p/sN;\n    return ivec3(pi.x + pi.y*N.x, p.x%sN.x, p.y%sN.y);\n}\n\nfloat F(float d)\n{\n    return 1./(0.1*d*d+1.) - 1.*exp(-1.*d);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nconst int k = 1664525;  \n\nivec4 hash( ivec4 x )\n{\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    return ivec4(x);\n}\n\n#define link0 16\n#define linkN 16\n\nstruct links\n{\n    int ids[linkN];\n};\n    \nconst float PHI = 0.5*(sqrt(5.) + 1.);\n\nvec2 inverseSF( vec3 p, float n ) \n{\n    float m = 1.0 - 1.0/n;\n    \n    float phi = min(atan(p.y, p.x), PI), cosTheta = p.z;\n    \n    float k  = max(2.0, floor( log(n * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))/ log(PHI+1.0)));\n    float Fk = pow(PHI, k)/sqrt(5.0);\n    vec2  F  = vec2( round(Fk), round(Fk * PHI) ); // k, k+1\n\n    vec2 ka = 2.0*F/n;\n    vec2 kb = 2.0*PI*( fract((F+1.0)*PHI) - (PHI-1.0) );    \n    \n    mat2 iB = mat2( ka.y, -ka.x, \n                    kb.y, -kb.x ) / (ka.y*kb.x - ka.x*kb.y);\n    \n    vec2 c = floor( iB * vec2(phi, cosTheta - m));\n    float d = 8.0;\n    float j = 0.0;\n    for( int s=0; s<4; s++ ) \n    {\n        vec2 uv = vec2( float(s-2*(s/2)), float(s/2) );\n        \n        float i = dot(F, uv + c); // all quantities are ingeters (can take a round() for extra safety)\n        \n        float phi = 2.0*PI*fract(i*PHI);\n        float cosTheta = m - 2.0*i/n;\n        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n        \n        vec3 q = vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta );\n        float squaredDistance = dot(q-p, q-p);\n        if (squaredDistance < d) \n        {\n            d = squaredDistance;\n            j = i;\n        }\n    }\n    return vec2( j, sqrt(d) );\n}\n    \nstruct object\n{\n    vec3 X;\n    vec4 q;\n    vec3 P;\n    vec3 L;\n    int type;\n    float m;\n};\n\nvec3 qtransform(vec4 q, vec3 v)\n{ \n\treturn v + 2.0*cross(cross(v, q.xyz) + q.w*v, q.xyz);\n} ", "buffer_a_code": "//particle and particle neighbor directional graph buffer \n\nobject obj; vec4 lnk; \n\nvec4 d; int ID; float avgR;\n\n\nobject getObject(int id)\n{\n    object o;\n    vec4 p = texel(ch0, i2xy(ivec3(id, 0, 0)));\n    o.X = p.xyz; o.type = int(p.w);\n    o.q = texel(ch0, i2xy(ivec3(id, 1, 0)));\n    p = texel(ch0, i2xy(ivec3(id, 2, 0)));\n    o.P = p.xyz;\n    o.m = p.w;\n    o.L = texel(ch0, i2xy(ivec3(id, 3, 0))).xyz;\n    return o;\n}\n\nlinks getGraphLinks(int id);\nvec4 getParticlePos(int id);\n\nvec4 saveObject(int i)\n{\n    switch(i)\n    {\n    case 0:  \n        return vec4(obj.X, obj.type);\n    case 1:\n        return obj.q;\n    case 2:\n        return vec4(obj.P, obj.m);\n    case 3:\n        return vec4(obj.L, 0.);\n    }\n}\n\n \nfloat dist2p(vec3 p, int id);\nvoid sort(int idtemp, int R);\nvoid sortlinks(in links nb, int R);\nvoid sortneighbors(int id, int R);\nvoid sortrandom(int id, int R);\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(floor(pos));\n    if(any(greaterThan(p, sN*N-1))) discard;\n    \n    ivec3 sid = xy2i(p); ID = sid.x;\n    obj = getObject(ID);\n    links nb = getGraphLinks(ID); //neighbor links\n   \tif(sid.z == 0) //object computation\n    {\n        //compute the force and the torque\n        //TODO\n        vec3 F = vec3(0);\n\n        obj.P += F*dt;\n        obj.X += obj.P*dt/obj.m;\n        \n        if(iFrame<1) //initial conditions\n        {\n            obj.X = 2.*(hash33(pos.xyx + pos.yyx*4.5743) - 0.5);\n            obj.P = 0.001*2.*(hash33(pos.yxy + pos.xxy*PI) - 0.5);\n            obj.L = vec3(0.);\n            obj.q = vec4(0.);\n            obj.type = 0;\n            obj.m = 1.;\n        } \n        \n        U = saveObject(sid.y);\n    }\n    else //graph computation\n    {\n        d = vec4(1e6);\n        lnk = vec4(-1);\n         \n        //local average distance/density\n        avgR = 0.; float NN = 0.;\n        for(int i = min(0,iFrame); i < link0; i++)\n        {\t\n            if(nb.ids[i] >= 0) \n            {\n                NN++;\n        \t\tavgR += dist2p(obj.X, nb.ids[i]);    \n            }\n        }\n        avgR /= NN;\n       \n        sortlinks(nb, sid.y);\n        \n        for(int i = min(0,iFrame); i < linkN; i++)\n        \tsortneighbors(nb.ids[i], sid.y);\n        \n        sortrandom(sid.x, sid.y);\n        \n        U = lnk;\n    }\n}\n\nlinks getGraphLinks(int id)\n{ \n    links L;\n    for(int j = 0; j < linkN/4; j++)\n    {\n        vec4 side0 = texel(ch0, i2xy(ivec3(id, j, 1)));\n        for(int i = j*4; i < j*4 + 4; i++)\n        {\n            L.ids[i] = int(side0[i%4]);\n        }   \n    }\n    return L;\n}\n\nvec4 getParticlePos(int id)\n{ \n    return texel(ch0, i2xy(ivec3(id, 0, 0)));\n}\n\nfloat dist2p(vec3 p, int id)\n{\n    return distance(getParticlePos(id).xyz,p);\n}\n\nbool iscoincidence(int id, int num)\n{\n    bool c = (id == ID) || (id < 0) || any(equal(lnk,vec4(id)));\n    return c;\n}\n\nvoid sort(int idtemp, int R) //sort closest objects in N directions\n{\n    if(iscoincidence(idtemp, R)) return; //particle already sorted\n    vec4 px = getParticlePos(idtemp);\n    vec3 dx = px.xyz - obj.X;\n    \n    if(R < link0/4) //closest\n    {\n        int dir = int(inverseSF(dx, float(link0)).x); \n        int diri = dir%4;\n        int dirR = dir/4;\n        float nd = length(dx);\n        if(dirR == R && nd < d[diri])\n        {\n            d[diri] = nd;\n            lnk[diri] = float(idtemp);\n        }\n    } \n    else // far particles\n    {\n        int dir = int(inverseSF(dx, 4.).x); \n        int diri = dir%4;\n        int rad = R;\n        int dirR = rad;\n        float nd = abs(length(dx) - exp2(float(rad))*avgR);\n        if(dirR == R && nd < d[diri])\n        {\n            d[diri] = nd;\n            lnk[diri] = float(idtemp);\n        }\n    }\n}\n\nvoid sortlinks(in links nb, int R)\n{\n    for(int i = min(0, iFrame); i<linkN; i++) sort(nb.ids[i], R);\n}\n\nvoid sortneighbors(int id, int R)\n{\n    links nb = getGraphLinks(id);\n    sortlinks(nb, R);\n}\n\nvoid sortrandom(int id, int R)\n{\n    for(int i = min(0, iFrame); i<2; i++) sort((12*iFrame+ID+i)%tot_n, R);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//prev closest particle buffer\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n//intersection with the bisector plane\nfloat rayBisectDist(vec3 p, vec3 d, vec3 a, vec3 b)\n{\n    vec3 n = b - a;\n    float D = length(n);\n    float cosnd = dot(n, d)/D; //ray plane normal angle cosine\n    float l = D*.5 - dot(p - a, n)/D;\n    float t = l/cosnd; //ray parameter\n    return (cosnd>0.)?t:1e10;\n}\n\n//closest voronoi cell and ray intersection\nvec4 findClosestIntersection(vec3 p, vec3 d, vec4 cobj, int mit)\n{\n    int id = int(cobj.w);\n    if(id < 0)\n    {\n        id = 0;\n        cobj.xyz = texel(ch0, i2xy(ivec3(id, 0, 0))).xyz;\n    }\n    \n    int cid = id;\n    vec3 cxy = cobj.xyz;\n \tfloat cd = distance(p, cxy);\n    \n    for(int s = 0; s < mit; s++)\n    {\n        vec3 pxy = cxy;\n        int pid = cid;\n        //t = 1e10;\n        for(int j = 0; j < linkN/4; j++)\n   \t    {\n            vec4 nb = texel(ch0, i2xy(ivec3(pid, j, 1)));\n            for(int i = 0; i < 4; i++)\n            {\n                if(nb[i]<0.) continue; \n                vec3 X = texel(ch0, i2xy(ivec3(nb[i], 0, 0))).xyz;\n                float td = distance(p, X);\n                if(td < cd) \n                {\n                    cd = td;\n                    cxy = X;\n                    cid = int(nb[i]);\n                }\n            }\n        }\n       \n        if(pid == cid) break; //found closest voronoi cell\n    }\n   \n    return vec4(cxy,cid);\n}\n\n#define maxd 4.\n#define mind 0.001\n#define maxs 128\n\n//implicit voronoi diagram ray marching\nvec4 rayMarch(vec3 p, vec3 d, int cobjid)\n{\n    float td = 0.; \n    float ld = 0.; \n    float t = 0.;\n   \n    vec4 cobj = vec4(texel(ch0, i2xy(ivec3(cobjid, 0, 0))).xyz, cobjid);\n    cobj = findClosestIntersection(p, d, cobj, 20);\n    int n = 0;\n    for(int i = 0; i < maxs; i++)\n    {\n        //march\n        float DE = sdSphere(p + ld*d - cobj.xyz, 0.05);\n        ld+=DE; td+=DE;\n        \n        //update position\n        p += ld*d; ld = 0.; n++;\n        //find new closest object\n        cobj = findClosestIntersection(p, d, cobj, 4);\n        \n        //outide of the scene\n        if(td > maxd) return vec4(p+ld*d, -1);\n        //has hit the surface\n        if(DE < mind*td) break;\n    }\n    return vec4(p + ld*d, cobj.w);\n}\n\n#define FOV 2.\nmat3 getRot(vec2 a)\n{\n    \n   mat3 theta_rot = mat3(1, 0, 0,\n                         0, cos(a.y), sin(a.y),\n                         0, -sin(a.y), cos(a.y)); \n        \n   mat3 phi_rot = mat3(cos(a.x), sin(a.x), 0,\n        \t\t       -sin(a.x), cos(a.x), 0,\n        \t\t        0, 0, 1); \n   return transpose(phi_rot*theta_rot);\n}\n\nvec3 getRay(vec2 angles, vec2 pos)\n{\n    mat3 camera = getRot(angles);\n    return normalize(transpose(camera)*vec3(FOV*pos.x, FOV*pos.y, 1.));\n}\n\n#define ldir vec3(1,0,0)\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = (pos - size*0.5)/size.y;\n    vec2 angles = (iMouse.z>0.)?(iMouse.xy/iResolution.xy)*vec2(2.*PI, PI):vec2(0.1*iTime, PI*0.5);\n    \n    vec3 d = getRay(angles, uv);\n    vec3 p = -2.*getRay(angles, vec2(0.));\n    vec4 prev = pixel(ch1, pos);\n    if(iFrame < 1) prev.w = 0.;\n    vec4 rm = rayMarch(p, d, int(prev.w));\n    if(rm.w >= 0.) //hit object\n    {\n        vec3 pp = texel(ch0, i2xy(ivec3(rm.w, 0, 0))).xyz;\n    \tvec3 n = 0.5*normalize(rm.xyz - pp) + 0.5;\n        U.xyz = vec3(clamp(dot(ldir, n),0.,1.));\n    }\n    else //background\n    {\n        U = texture(iChannel2,  d.yzx);\n    }\n    U.w = rm.w;\n}", "buffer_b_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlyDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[168, 168, 219, 219, 254]], "test": "untested"}
{"id": "WdByRz", "name": "大龙猫 - Bolygones", "author": "totetmatt", "description": "I found this book on a flea market : Graphisme Scientifique sur Micro Ordinateur de la 2e à la 3e Dimention en Basic.\n\nThat's a really old computer graphic book with example in basic ! There is a chapter with \"Bolygones\"", "tags": ["bolygones"], "likes": 49, "viewed": 875, "published": 3, "date": "1585924639", "time_retrieved": "2024-07-30T21:15:09.397800", "image_code": "//      v---- Day 22 for me :D\n#define CHAT 0.0\n#define PI 3.141592\n#define TAU PI*2.\n \nvec2 circleCoord(float r, float theta) {\n    return  vec2(r*cos(theta),r*sin(theta));\n}\nmat2 r(float a){\n    float c=cos(a),s=sin(a);\n    return mat2(c,-s,s,c);\n}\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\nfloat hash21(vec2 p) {\n    p = fract(p * vec2(233.34, 851.74));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/ iResolution.y;\n    uv*=4.;\n    float steps = 200.;\n    float d  = .0;\n\n     vec2 id = floor(uv);\n     uv = fract(uv)-.5;\n     uv *=2.2;\n\nfloat n = 20.+sin(iTime*.01+hash21(id))*10.;\n    for(float i =0.;i<TAU;i+=TAU/steps) {\n   \n        vec2 coord = uv +circleCoord(1.,i);\n        \n        float s = 8./iResolution.y;\n        d += smoothstep(s,s-0.01,sdSegment(coord,vec2(.0,.0),2.*vec2(cos(n*i),sin(n*i))))/3.;\n       \n    }\n    \n \n    vec3 col = vec3(d)*1.-step(1.,length(uv));\n    col = mix(vec3(0.0,.0,.0),vec3(hash21(id+iTime*.0000001),0.5,0.5),col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdByRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 128, 128, 175], [176, 176, 192, 192, 250], [251, 251, 303, 303, 422], [423, 423, 445, 445, 545], [546, 546, 601, 601, 1237]], "test": "untested"}
{"id": "wslcDS", "name": "Motion Tweening", "author": "Shane", "description": "Creating a looping magnetized block animation using basic motion tweening techniques. ", "tags": ["motion", "tweening", "keyframe"], "likes": 66, "viewed": 1398, "published": 3, "date": "1585918944", "time_retrieved": "2024-07-30T21:15:10.440013", "image_code": "/*\n\n\n\tMotion Tweening\n\t---------------\n\n\tCreating a looping animation with magnetized blocks utilizing basic motion \n    tweening techniques. The animation sequence itself is a rough recreation \n    of a sequence I've seen around in GIF form on the internet. I'm not sure \n    where the original came from, but if I were to take a guess, I'd say it was \n    created by Andreas Wannerstedt, who produces a lot of mesmerizing looping \n    animations... but I wouldn't quote me on it.\n\n    I've been away for a while, so wanted to start with something relatively\n\tsimple. Motion tweening requires a bit of effort, but is relatively easy\n\trepetitive work. Demosceners do stuff like this all the time, but for those \n\tnot familar with the process, you just choose a total looping time \n    (tm = mod(iTime, totalTime)), then partition it into individual time segments \n    using a case statement, or some if-elseif statements. The segment intervals \n    themselves are filled with interpolated motion, distortion, morphing, etc.\n\n    As you can see, none of the individual movements are particularly complex;\n    rotations, pivots, translations, etc -- A lot of it was made up on the fly,\n\tso I'd imagine there'd be more efficient ways to achieve the same. One thing\n\tto note is that the colored cube moves in conjunction with the larger one, \n    which might throw some people off, but that's just a simple case of moving \n    the chrome looking box, setting the cube coordinates to the chrome box \n\tcoordinate system (p = pPrevious), then peforming more simple operations.\n\t\n    I seem to say this a lot, but apologies in advance for the extended compile\n\ttime. This should run pretty quickly, but the lengthy decision-making logic\n\tinside the raymarching loop taxes the compiler, which is amplified with the \n\treflection pass. By the way, you could simplify the objects and use IQ's \n    raytraced rounded-box intersection formulas to make this way, way more\n\tefficient. However, keeping track of the rotations for normal calculations, \n    and so forth, would get pretty tiresome... It's the kind of thing I'll leave \n    for Dr2 to do. :)\n\n\n\n    Other examples:\n\n\n    // This is one of the most clever and innovative examples on here.\n    [SH18] Human Document - reinder\n    https://www.shadertoy.com/view/XtcyW4\n\n*/\n\n#define FAR 30.\n\nvec4 vObjID;\nint objID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. :)\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n// Time variables.\nfloat tm, t, t2;\n\n// Animation segment ID.\nint segID = 0;\n\n// The motion tween block. There's another withing the raymarching loop. \n// We're performing whatever nonpositional lengthy calculations we can outside \n// the raymarching loop. Usually, declaring things locally can help speed things\n// up, but there is a point where precalculation is necessary. In any case, taking\n// things outside the raymarching loop should reduce compile time... Although,\n// with GPUs, who knows. A lot of it's hit and miss.\n//\nvoid doTweenTime(){\n    \n    \n    // The total loop time. We're starting after the ten second mark.\n    tm = mod(iTime + 10., 10.25);\n    \n    if(tm<1.){ // if(tm>=0. && tm<1.)\n        \n        // Normalize to the zero to one range: Time minus start time, divide total time;\n        t = tm;//(tm - 0.)/(1. - 0.);\n        // At this point, you can perform whatever kind of easing function, etc, on the \n        // normalized figures. \n        t = bounceOut(t);\n          \n        // Afterwards, adjust according to start value and end value.\n        // In this case, we wish to rotate from zero to PI/2.\n        t = mix(0., PI/2., t);\n        \n        // Setting a segment ID. This isn't really necessary, but I wanted the logic\n        // inside the raymarching loop as simple as possible. The theory being that\n        // \"if(segID == 0)\" should compile better than \"if(tm<1.),\" but it also allows\n        // for \"switch\" statement usage.\n        segID = 0;\n        \n    }\n    else if(tm<2.){ // if(tm>=1. && tm<2.)\n        \n        t = tm - 1.; // (tm - 1.)/(2. - 1.);\n        t2 = exponentialInOut(t);\n        t = easeInOutCubic(t);\n        \n        segID = 1;\n      \n    }      \n    else if(tm<3.){\n        \n        t = tm - 2.; // (tm - 2.)/(3. - 2.);\n        t2 = t;\n        t = exponentialOut(t);\n        \n        \n        segID = 2;\n  \n    }    \n    else if(tm<4.){\n         \n        // Normalize to the zero to one range: Time minus start time, divide total time;\n        t = tm - 3.; // (tm - 3.)/(4. - 3.);\n        t2 = t; // easeOutQuad(t);\n        t = bounceOut(t);\n        t = mix(0., PI/2., t);\n        \n        segID = 3;\n    }\n    else if(tm<5.){\n        \n        t = tm - 4.; // (tm - 4.)/(5. - 4.);\n        t2 = easeInQuad(t);\n        t = easeInOutCubic(t);\n        t = mix(PI/2., 0., t);\n        \n        segID = 4;\n        \n     }\n    else if(tm<6.){\n        \n        // Time minus start time, divide total time;\n        t = tm - 5.; // (tm - 5.)/(6. - 5.);\n        t2 = t;\n        // Easing.\n        t = easeInOutCubic(t);\n        // We're performing a half turn.\n        t = mix(0., PI/1., t);\n        \n         segID = 5;\n \n    }\n    else if(tm<7.){\n       \n        // Time minus start time, divide total time;\n        t = tm - 6.; // (tm - 6.)/(7. - 6.);\n        // Easing.\n        t = bounceOut(t);\n        // We're performing a half turn.\n        t = mix(0., -PI/2., t);\n        \n        segID = 6;\n    }\n    else if(tm<8.){\n       \n        // Gold cube pivot to join the left leaning larger block.\n        t = tm - 7.; // (tm - 7.)/(8. - 7.);\n        t = easeInOutCubic(t);\n        t2 = t;\n        \n        segID = 7;\n       \n    }\n    else if(tm<9.){\n       \n        t = tm - 8.; // (tm - 8.)/(9. - 8.);\n        t2 = t;\n        t = easeInOutCubic(t);\n        t = mix(PI/2., 0., t);\n        \n        segID = 8;\n        \n     }  \n    else if(tm<10.){\n       \n        t = tm - 9.; // (tm - 9.)/(10. - 9.);\n        t2 = easeOutQuad(t);\n        \n        segID = 9;\n           \n    }\n    else if(tm<10.25){\n     \n        segID = 10;\n    }    \n    \n    \n}\n\n\nvoid move(in vec3 p, inout vec3 q, inout vec3 q2, inout vec3 svDim, in vec3 bDim2){\n\n    // Make a copy of the large box dimensions to account for varying length.\n    vec3 bDim = svDim;\n    \n        // I debated over whether to use a switch statement versus the else-if mess you see here. \n    // They say switches are faster with more that a few items, but for whatever reason, my \n    // compiler hated the switch statement... When all's said and done, I know of a much,\n    // much faster way, but it'll require some considerable restructuring.\n    \n    if(segID == 0){\n        \n        \n        // \"segID == 0\" corresponds to the time period between zero and one second. The\n        //  time, \"t,\" has been normalized to the zero to one range (trivial, in this case)\n        // and has been passed through an easing function. Which easing function is chosen \n        // depends on the movement style you're after; ease-in, exponential-out, bounce, etc. \n\n        \n        \n        // Begin with the large box at floor level.\n        q.y -= bDim.y;\n        \n        // Lean down right.\n        // This is a pivot motion. Basically, you offset the position to the pivot point,\n        // whilst rotating and offsetting by the pivot amount. In this case, the pivot\n        // point is at moved from the middle pivot position, vec3(0) to vec3(bDim.x, bDim.y, 0),\n        // which represents the middle of the lower left edge, and we're rotating about the\n        // XY plane. By the way, 3D rotations could be utilized, but I'm trying to stick to\n        // the basics.\n        q.xy = rot2(-t)*(q.xy - vec2(bDim.x, -bDim.y)) - vec2(-bDim.x, bDim.y);\n        \n        // Gold cube pivotal flip, with respect to the larger cube's preoriented transform.\n        //\n        // Set the colored cube coordinates to the chrome boxes coordinats. Using a second \n        // variable for the second objects coordinates isn't absolutely necessary, but I think\n        // it reads better.\n        q2 = q; \n        q2.y -= -bDim2.y; // Move into position with respect to the chrome cube.\n        // Pivot -- See the pivot explanation above.\n        q2.xy = rot2(-t)*(q2.xy - vec2(-bDim2.x, bDim2.y)) - vec2(-bDim2.x, -bDim2.y);\n   \n        \n    }\n    else if(segID == 1){\n        \n        \n        // Slide and shrink the height.\n        q.x -= mix(0., -bDim.x*3., t);\n        q.y -= bDim.y;\n        svDim.y = mix(bDim.y, bDim.y/2., t);\n        \n        q.xy = rot2(-PI/2.)*(q.xy - vec2(bDim.x, -bDim.y)) - vec2(-bDim.x, bDim.y);\n        \n        // Gold cube slide.\n        // Move the cube relative to the large block position, q.\n        q2 = q;\n        q2.x -= -bDim.x*2.; \n        q2.y -= mix(bDim.x, 0., t);\n\n        // Spinning relative to the q axes -- The global XZ axes to the viewer, but the\n        // YZ axes from the perspective of the chrome cube.\n        q2.yz = rot2(t2*PI*2.)*q2.yz;\n     \n    }      \n    else if(segID == 2){\n        \n        // Grow taller.\n        svDim.y = mix(bDim.y/2., bDim.y, t);\n        \n        q.y -= svDim.y;\n        q.xy = rot2(0.)*(q.xy - vec2(bDim.x, -svDim.y)) - vec2(-bDim.x, svDim.y);\n        \n        \n         \n        // Gold cube jump and flip.\n        q2 = p;\n        q2.y -= svDim.y*2. + bDim2.y;//mix(bDim.y/2., bDim.y, t)*2.; // Grow with the bottom object.\n        \n        \n        if(t2<.35) q2.y -= t2/.35*bDim.y*.7; // Ascend from the top of the object below.\n        else q2.y -= (bDim.y - bounceOut((t2 - .35)/.65)*bDim.y)*.7; // Decend back to the top.\n              \n       \n        q2.yz = rot2(-t2*PI/1.)*(q2.yz); // Front flip.\n  \n  \n    }    \n    else if(segID == 3){\n       \n\n        \n        // Lean down right.\n        q.y -= svDim.y;\n        q.xy = rot2(-t)*(q.xy - vec2(bDim.x, -bDim.y)) - vec2(-bDim.x, bDim.y);\n        \n        q2 = q;\n        q2.y -= bDim.y + bDim2.y;\n        // Pivot the gold cube anticlockwise from the top by 2 PI.\n        q2.xy = rot2(t*2.)*(q2.xy - vec2(-bDim2.x, -bDim2.y)) - vec2(bDim2.x, bDim2.y);\n \n        //\n    }\n    else if(segID == 4){\n        \n        \n        // Lean up left.\n        q.y -= bDim.y;\n        q.xy = rot2(-t)*(q.xy - vec2(bDim.x, -bDim.y)) - vec2(-bDim.x, bDim.y);\n        \n        // Gold cube: Slide from top to bottom.\n        q2 = q;\n        q2.x -= -bDim2.x*2.;\n        q2.y -= mix(bDim2.y, -bDim2.y, t2);\n        \n    }\n    else if(segID == 5){\n        \n        \n        q.y -= bDim.y;\n        q.xz = rot2(t)*(q.xz - vec2(bDim.x, bDim.z)) - vec2(-bDim.x, -bDim.z);\n        \n        \n        // Gold cube.\n        q2 = q;\n        q2.y -= -bDim2.y; // Move into position.\n        q2.x -= -bDim2.x*2.; // Move into position.\n        \n        q2.xz = rot2(-t)*(q2.xz - vec2(bDim.x, bDim.z)) - vec2(-bDim.x, -bDim.z);\n\n    }\n    else if(segID == 6){\n        \n        \n        //Lean down left (one cell up).\n        q.y -= bDim.y;\n        q.x -= bDim.x*2.;\n        q.z -= bDim.z*2.;\n        q.xy = rot2(-t)*(q.xy - vec2(-bDim.x, -bDim.y)) - vec2(bDim.x, bDim.y);\n        //q.z -= bDim.z;\n        \n        // Gold cube: Leave stationary.\n        q2 = p; // Detatch from the larger box coordinate system, and use the global one.\n        q2.y -= bDim2.y; // Move into position.\n        q2.x -= bDim2.x*2.;\n        \n    }\n    else if(segID == 7){\n       \n       \n        //From a down left position (one cell up), slide to the right.\n        q.y -= bDim.y;\n        //q.x -= bDim.x*2.;\n        q.x -= mix(bDim.x*2., bDim.x*4., t);\n        q.z -= bDim.z*2.;\n        q.xy = rot2(PI/2.)*(q.xy - vec2(-bDim.x, -bDim.y)) - vec2(bDim.x, bDim.y);\n        \n        // Gold cube.\n        q2 = q; \n        q2.y -= -bDim2.y*3.; \n        q2.z -= -bDim2.z*2.; \n        \n        // Whilst sliding, pivot the gold cube to the top of the larger object.\n        q2.yz = rot2(-t2*PI/2.)*(q2.yz - vec2(bDim.x, bDim.z)) - vec2(-bDim.x, -bDim.z);\n       \n    }\n    else if(segID == 8){\n       \n        \n        // Move the chrome cube into this frame's position.\n        q.y -= bDim.y;\n        q.x -= -bDim.x*2.;\n        q.z -= bDim.z*2.;\n        \n        // Pivot about XZ.\n   \t\tq.xz = rot2(t2*PI/1.)*(q.xz - vec2(bDim.x, -bDim.z)) - vec2(-bDim.x, bDim.z);           \n        // Pivot about XY.\n        q.xy = rot2(-t)*(q.xy - vec2(bDim.x, -bDim.y)) - vec2(-bDim.x, bDim.y);\n \n        \n        // Gold cube flip back down a level.\n        q2 = q; \n        \n        q2.xy = rot2(t2*PI)*(q2.xy - vec2(-bDim.x, bDim.y)) - vec2(bDim.x, -bDim.y);\n        q2.y -= bDim2.y*3.;\n        \n    }  \n    else if(segID == 9){\n       \n         \n        //Rotate and slide back to the original position.\n        q.y -= bDim.y;\n       \n        // Rotate about XZ with no pivoting.\n        q.xz = rot2(t*PI/2.)*(q.xz);           \n         \n        \n        // Pivot the gold cube about XZ whilst sliding back down to the ground.\n        q2 = q;\n        q2.x -= bDim.x*2.;\n        q2.y -= mix(bDim2.y, -bDim2.y, t2);\n      \n        q2.xz = rot2(t*PI)*(q2.xz - vec2(-bDim.x, bDim.z)) - vec2(bDim.x, -bDim.z);\n          \n    }\n    else {\n        \n        // Pause briefly before continuing the looping process again.\n        q.y -= bDim.y;\n        \n        q2 = q;\n        q2.y -= -bDim2.y;\n        q2.x -= -bDim.x*2.;\n        \n    }\n\n}\n\n// Distance function: This one is pretty simple.\nfloat map(vec3 p){\n\n\n    // Floor.\n    float fl = p.y;  //-sBoxS(p - vec3(0, 3, 0), vec3(6, 3, 6),.04);//min(p.y, -p.y + 3.8);\n    \n    \n\n    // Object dimensions.\n    vec3 bDim = vec3(.25, .5, .25); // Large box.\n    const vec3 bDim2 = vec3(.25, .25, .25); // Small cube.\n   \n    // Local coordinates for each moving object.\n    vec3 q = p, q2 = p;\n    \n    // Move the objects.\n    move(p, q, q2, bDim, bDim2);\n \n    \n    // The rendering portion is the easy bit; Just some standard distance\n    // field operations with IQ's box formula.\n    \n    \n    // The chrome box.\n    float obj = sBox(q, bDim, .04);\n    \n    // The colored cube.\n    float obj2 = sBox(q2, bDim2, .04); \n    \n    // Chrome box grooves.\n    //obj = max(obj, -sBox(q, bDim*vec3(.25, .667, 1.2), .04));   \n    //obj = max(obj, -sBox(q, bDim*vec3(.25, 1.2, .25), .04)); \n    //obj = max(obj, -sBox(q, bDim*vec3(1.2, .667, .25), .04)); \n    obj = max(obj, -sBox(q.xy, bDim.xy*vec2(.25, .667), .04));   \n    obj = max(obj, -sBox(q.xz, bDim.xz*vec2(.25, .25), .04)); \n    obj = max(obj, -sBox(q.yz, bDim.yz*vec2(.667, .25), .04)); \n    \n    // Colored box nodules.\n    obj = min(obj, sBox(q2, bDim2*vec3(.25, .25, 1.2), .04));   \n    obj = min(obj, sBox(q2, bDim2*vec3(.25, 1.2, .25), .04)); \n    obj = min(obj, sBox(q2, bDim2*vec3(1.2, .25, .25), .04));\n    \n    // Center of the chrome box.\n    obj = min(obj, sBox(q, bDim*vec3(.833), .04)); \n\n \n\n    // Store the floor, chrome box and gold cube positions for sorting\n    // and surface identification outside the loop.\n    vObjID = vec4(fl, obj, obj2, 0);\n    \n    \n    // Return the minimum object.\n    return min(min(fl, obj), obj2);\n}\n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i = min(0, iFrame); i<80; i++){\n\n        d = map(ro + rd*t);\n        \n        // Using the hacky \"abs,\" trick, for more accuracy. \n        if(abs(d)<.001 || t>FAR) break;        \n        \n        t += d;  // Using more accuracy, in the first pass.\n    }\n    \n    return t;\n}\n\n// Second pass, which is the first, and only, reflected bounce. \n// Virtually the same as above, but with fewer iterations and less \n// accuracy.\n//\n// The reason for a second, virtually identical equation is that \n// raymarching is usually a pretty expensive exercise, so since the \n// reflected ray doesn't require as much detail, you can relax things \n// a bit - in the hope of speeding things up a little.\nfloat traceRef(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    \n    for (int i = min(0, iFrame); i<48; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.002 || t>FAR) break;\n        \n        t += d;\n    }\n    \n    return t;\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing repeat objects - in a setting like this - with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .002;    \n    float end = max(length(rd), .001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(0, iFrame); i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, .2), \n        // clamp(h, .02, stepDist*2.), etc.\n        dist += clamp(h, .01, .25);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist>end) break; \n        //if (h<.001 || dist > end) break; // If you're prepared to put up with more artifacts.\n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me.\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 1.5, occ = 0.;\n    for( int i = min(0, iFrame); i<5; i++ ){\n    \n        float hr = float(i + 1)*.25/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        \n        if(occ>1e5) break; // Fake break to get compile time down.\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n    //                      m(p + e.yyx) - m(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(0, iFrame); i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n\n\n// The floor, chrome cube, and colored cube materials. These ones are pretty\n// basic, but you could put more effort in.\n//\nvec3 getObjectColor(vec3 p, vec3 r, vec3 n){\n    \n    \n    vec3 col;\n        \n    if(objID == 0) {\n       \n        // The floor.\n        vec3 tx = texture(iChannel0, p.xz/4.).xyz; tx *= tx;\n        col = tx*vec3(1, .7, .5)*.5;\n        \n    }\n    else if(objID == 1) {\n        \n        // The chrome colored box. It's something I tend to get, but tinging\n        // things blue can help bring about a metallic color... kind of. :)\n        col = vec3(.65, .85, 1);\n    }\n    else {\n        \n        // The cube. \n        col = vec3(2, .9, .45); // Redish gold.\n        //col = vec3(.7, 1.2, .3); // Green.\n        //col = vec3(2, .35, .85); // Pink.\n        //col = vec3(.3, 1, 2.5); // Blue.\n        //col = vec3(.3); // Grey\n    }\n    \n\n    // Adding some fake cube mapping information. The science is terrible, but it \n    // adds a bit of shine. :)\n    vec3 cTx = tex3D(iChannel0, reflect(r, n)/1.5, n);\n    cTx *= vec3(1, .8, .6);\n    \n    // Add a dose of fake reflection to the box and cube, and just a bit to the floor.\n    if(objID>0) col *= cTx*2.;\n    else col += cTx*.1;\n    \n    return col;\n\n}\n\n// Using the hit point, unit direction ray, etc, to color the \n// scene. Diffuse, specular, falloff, etc. It's all pretty \n// standard stuff.\nvec3 doColor(in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, float t){\n    \n    \n    // Initiate the scene color to zero.\n    vec3 sceneCol = vec3(0);\n    \n    if(t<FAR){\n        \n        vec3 ld = lp - sp; // Light direction vector.\n        float lDist = max(length(ld), .0001); // Light to surface distance.\n        ld /= lDist; // Normalizing the light vector.\n        \n        float ao = calcAO(sp, sn);\n\n        // Attenuating the light, based on distance.\n        float atten = 1./(1. + lDist*.2 + lDist*lDist*.05);\n\n        // Standard diffuse term.\n        float diff = max(dot(sn, ld), 0.);\n        // Standard specualr term.\n        float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.), 8.);\n        \n        // Ramp up the diffuse value. Sometimes, it can help things look metallic.\n        diff = pow(diff, 4.)*2.;\n\n        // Coloring the object. You could set it to a single color, to\n        // make things simpler, if you wanted.\n        vec3 objCol = getObjectColor(sp, rd, sn);\n        \n\n        // Combining the above terms to produce the final scene color.\n        sceneCol = objCol*((diff + ao*.2) + vec3(1, .97, .92)*spec*4.);\n        \n        // Apply the attenuation and ambient occlusion.\n        sceneCol *= atten*ao;\n        \n    }\n    \n    \n    // Fog factor -- based on the distance from the camera.\n    float fogF = smoothstep(0., .9, t/FAR);\n    //\n    // Applying the background fog. Just black, in this case, but you could\n    // render sky, etc, as well.\n    sceneCol = mix(sceneCol, vec3(0), fogF); \n\n    \n    // Return the color. Performed once every pass... of which there are\n    // only two, in this particular instance.\n    return sceneCol;\n    \n}\n\n\nvec3 getRd(vec2 u, vec3 ro){\n   \n    // Camera Setup.     \n    vec3 lk = vec3(0, .5, 0);  // \"Look At\" position.\n\n \n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159265/3.; // FOV - Field of view.\n    vec3 fw = normalize(lk - ro);\n    vec3 rt = normalize(vec3(fw.z, 0, -fw.x )); \n    vec3 up = cross(fw, rt);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(fw + (u.x*rt + u.y*up)*FOV);\n    // Warping the ray to give that curved lens effect.\n    //rd = normalize(vec3(rd.xy, rd.z*(1. - length(rd.xy)*.25)));\n    \n    return rd;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\n    // Aspect correct screen coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    \n    // Slight barrel distortion.\n    float r = dot(uv, uv);\n    uv *= 1. + .2*(r*r + r);\n    \n    float cTm = iTime/2.;\n    vec3 ro = vec3(sin(cTm)*2.65, cos(tm)*sin(cTm)*.25 + 2.25, cos(cTm)*2.65);//vec3(0, 0, 0);\n    //vec3 ro = vec3(sin(cTm)*.75, cos(tm)*sin(cTm)*.25 + 2.25, -2.65);//vec3(0, 0, 0);\n \n    \n    vec3 rd = getRd(uv, ro);\n    \n    // Ray origin. Doubling as the surface position, in this particular example.\n    // I hope that doesn't confuse anyone.\n\n    vec3 lp = vec3(1, 3, -1); // Light position. Set in the vicinity the ray origin.\n\n \n    // Movement calculations -- Outside the loop, in an attempt to save on compiler time.\n    doTweenTime();\n    \n    \n    \n    // FIRST PASS.\n    \n    // Raymarch.\n    float t = trace(ro, rd);\n \n    // Obtain the current object ID.\n    objID = vObjID.x < vObjID.y && vObjID.x < vObjID.z? 0 : vObjID.y < vObjID.z? 1 : 2;\n    \n    // Advancing the ray origin, \"ro,\" to the new hit point.\n    ro += rd*t;\n    \n    // Retrieving the normal at the hit point.\n    vec3 sn = getNormal(ro);\n    \n    // Retrieving the color at the hit point, which is now \"ro.\" I agree, reusing \n    // the ray origin to describe the surface hit point is kind of confusing. The reason \n    // we do it is because the reflective ray will begin from the hit point in the \n    // direction of the reflected ray. Thus the new ray origin will be the hit point. \n    // See \"traceRef\" below.\n    vec3 sceneColor = doColor(ro, rd, sn, lp, t);\n    \n    // Checking to see if the surface is in shadow. Ideally, you'd also check to\n    // see if the reflected surface is in shadow. However, shadows are expensive, so\n    // it's only performed on the first pass. If you pause and check the reflections,\n    // you'll see that they're not shadowed. OMG! Better call the shadow police. :)\n    float sh = softShadow(ro +  sn*.0015, lp, 12.);\n    sh = min(sh + .3, 1.);\n    \n    \n    // SECOND PASS - REFLECTED RAY\n    \n    // Standard reflected ray, which is just a reflection of the unit\n    // direction ray off of the intersected surface. You use the normal\n    // at the surface point to do that. Hopefully, it's common sense.\n    rd = reflect(rd, sn);\n    \n    \n    // The reflected pass begins where the first ray ended, which is the suface\n    // hit point, or in a few cases, beyond the far plane. By the way, for the sake\n    // of simplicity, we'll perform a reflective pass for non hit points too. Kind\n    // of wasteful, but not really noticeable. The direction of the new ray will\n    // obviously be in the direction of the reflected ray. See just above.\n    //\n    // To anyone who's new to this, don't forgot to nudge the ray off of the \n    // initial surface point. Otherwise, you'll intersect with the surface\n    // you've just hit. After years of doing this, I still forget on occasion.\n    t = traceRef(ro +  sn*.003, rd);\n    \n\n    // Obtain the current object ID.\n    objID = vObjID.x < vObjID.y && vObjID.x < vObjID.z? 0 : vObjID.y < vObjID.z? 1 : 2;\n    \n    // Advancing the ray origin, \"ro,\" to the new reflected hit point.\n    ro += rd*t;\n    \n    // Retrieving the normal at the reflected hit point.\n    sn = getNormal(ro);\n    \n    // Coloring the reflected hit point, then adding a portion of it to the final scene color.\n    // How much you add, and how you apply it is up to you, but I'm simply adding 35 percent.\n    //sceneColor += doColor(ro, rd, sn, lp, t)*.5;\n    // Other combinations... depending what you're trying to achieve.\n    vec3 rCol = doColor(ro, rd, sn, lp, t);\n    sceneColor = sceneColor + rCol*.75;\n    \n    \n    // APPLYING SHADOWS\n    //\n    // Multiply the shadow from the first pass by the final scene color. Ideally, you'd check to\n    // see if the reflected point was in shadow, and incorporate that too, but we're cheating to\n    // save cycles and skipping it. It's not really noticeable anyway. By the way, ambient\n    // occlusion would make it a little nicer, but we're saving cycles and keeping things simple.\n    sceneColor *= sh;\n    \n    \n    // Extra coloring.\n    //sceneColor *= vec3(1.1, 1, .9);\n\n    // Clamping the scene color, performing some rough gamma correction (the \"sqrt\" bit), then \n    // presenting it to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneColor, 0., 1.)), 1);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Easing functions are their own topic, but a lot of it is straight forward.\n// Usage is easy. Normalize the time between zero and one, then choose the \n// one you're after.\n\nconst float PI = 3.14159265358979;\n\n// Robert Penner's easing functions in GLSL.\n// Available as a module for glslify. http://stack.gl/glsl-easings/\n\nfloat easeInOutCubic(float t){\n\n    return t<0.5 ? 4.*t*t*t : (t - 1.)*(2.*t - 2.)*(2.*t - 2.) + 1.;\n}\n\nfloat easeInOutQuint(float t){\n\n    return t<.5 ? 16.*t*t*t*t*t : 1. +16.*(--t)*t*t*t*t;\n}\n\nfloat easeOutQuad(float t) {\n    return -1. * t * (t - 2.);\n}\n\nfloat easeInQuad(float t) {\n    return t * t;\n}\n\n \nfloat bounceOut(float t) {\n    \n  const float a = 4.0 / 11.0;\n  const float b = 8.0 / 11.0;\n  const float c = 9.0 / 10.0;\n\n  const float ca = 4356.0 / 361.0;\n  const float cb = 35442.0 / 1805.0;\n  const float cc = 16061.0 / 1805.0;\n\n  float t2 = t * t;\n\n  return t < a\n    ? 7.5625 * t2\n    : t < b\n      ? 9.075 * t2 - 9.9 * t + 3.4\n      : t < c\n        ? ca * t2 - cb * t + cc\n        : 10.8 * t * t - 20.52 * t + 10.72;\n}\n\nfloat bounceInOut(float t) {\n  return t < 0.5\n    ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0))\n    : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;\n}\n\nfloat bounceIn(float t) {\n  return 1.0 - bounceOut(1.0 - t);\n}\n\n\nfloat elasticOut(float t) {\n  return sin(-13.0 * (t + 1.0) * PI/2.) * pow(2.0, -10.0 * t) + 1.0;\n}\n\nfloat circularInOut(float t) {\n  return t < 0.5\n    ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n    : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nfloat exponentialIn(float t) {\n  return t == 0.0 ? t : pow(2.0, 10.0 * (t - 1.0));\n}\n\nfloat exponentialInOut(float t) {\n  return t == 0.0 || t == 1.0\n    ? t\n    : t < 0.5\n      ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n      : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\n\n// IQ's unsigned box formula.\nfloat sBox(in vec3 p, in vec3 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n\n// IQ's unsigned rectangle formula.\nfloat sBox(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n\n/*\n// IQ's signed box formula.\nfloat sBoxS(in vec3 p, in vec3 b, in float sf){\n\n  vec3 d = abs(p) - b + sf;\n  return min(max(max(d.x, d.y), d.z), 0.) + length(max(d, 0.)) - sf;\n}\n*/\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslcDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2361, 2394, 2416, 2416, 2474], [2477, 2631, 2681, 2983, 3892], [3972, 4425, 4444, 4524, 7502], [7505, 7505, 7588, 7667, 14713], [14715, 14764, 14782, 14798, 16423], [16425, 16458, 16488, 16488, 16806], [16808, 17218, 17251, 17251, 17457], [17460, 17675, 17719, 17836, 19131], [19134, 19286, 19321, 19321, 19661], [20475, 20599, 20643, 20643, 21703], [21705, 21847, 21917, 21968, 23537], [23540, 23540, 23568, 23598, 24117], [24120, 24120, 24176, 24224, 28576]], "test": "untested"}
{"id": "ttcSD8", "name": "Swiss Alps", "author": "piyushslayer", "description": "My first attempt at volumetric clouds based on Horizon Zero Dawn clouds. Most of the logic for the clouds is in buffer C. Use the mouse to drag around the sun for different times of the day, or click at the bottom for an automated day/night cycle.", "tags": ["noise", "terrain", "volume", "clouds", "perlin", "volumetric", "worley", "scattering"], "likes": 227, "viewed": 10306, "published": 3, "date": "1585915249", "time_retrieved": "2024-07-30T21:15:11.536083", "image_code": "/**\n  My first attempt at rendering volumetric clouds and ray marched terrain. Terrain is\n  rendered based on ray marching techniques by iq, and the clouds are rendered based\n  on techniques by Nathan Vos and Andrew Schneider(Guerrilla), and Sébastien Hillaire\n  (Epic), see buffer C for more details. \n\n  This main image tab mostly apples some post-process effects to the terrain and cloud\n  textures, including a gaussian blue for the clouds to hide noise/ray marching\n  artifacts, and some lens flares and light scattering effects, along with a\n  luminance based reinhard tonemapper. \n*/\n\n//-------------------------------------------------------------------------------------\n// Gaussian Blur\n//-------------------------------------------------------------------------------------\n\n#define texelOffset vec2(1.75 / iResolution.xy)\n\nconst float kernel[9] = float[]\n(\n\t.0625, .125, .0625,\n    .125,  .25,  .125,\n    .0625, .125, .0625  \n);\n\nvec4 gaussianBlur(sampler2D buffer, vec2 uv)\n{\n    vec4 col = vec4(0.);\n    \n \tvec2 offsets[9] = vec2[](\n        vec2(-texelOffset.x,  texelOffset.y),  // top-left\n        vec2( \t\t\t0.,   texelOffset.y),  // top-center\n        vec2( texelOffset.x,  texelOffset.y),  // top-right\n        vec2(-texelOffset.x,  \t\t\t 0.),  // center-left\n        vec2( \t\t\t0.,\t\t\t \t 0.),  // center-center\n        vec2( texelOffset.x,  \t \t\t 0.),  // center-right\n        vec2(-texelOffset.x,  -texelOffset.y), // bottom-left\n        vec2( \t\t\t0.,   -texelOffset.y), // bottom-center\n        vec2( texelOffset.x,  -texelOffset.y)  // bottom-right    \n    );\n    \n    for(int i = 0; i < 9; i++)\n    {\n        col += textureLod(buffer, uv + offsets[i], 0.) * kernel[i];\n    }\n    \n    return col;\n}\n\n//-------------------------------------------------------------------------------------\n// Lens Flare (from shadertoy.com/view/XdfXRX)\n//-------------------------------------------------------------------------------------\n\n#define ORB_FLARE_COUNT\t8\n#define DISTORTION_BARREL 1.3\n\nvec2 GetDistOffset(vec2 uv, vec2 pxoffset)\n{\n    vec2 tocenter = uv.xy;\n    vec3 prep = normalize(vec3(tocenter.y, -tocenter.x, 0.0));\n    \n    float angle = length(tocenter.xy) * 2.221 * DISTORTION_BARREL;\n    vec3 oldoffset = vec3(pxoffset, 0.);\n    \n    vec3 rotated = oldoffset * cos(angle) + cross(prep, oldoffset)\n        * sin(angle) + prep * dot(prep, oldoffset) * (1. - cos(angle));\n    \n    return rotated.xy;\n}\n\nvec3 flare(vec2 uv, vec2 pos, float dist, float size)\n{\n    pos = GetDistOffset(uv, pos);\n    \n    float r = max(.01 - pow(length(uv + (dist - .05)*pos), 2.4) \n                  *(1. / (size * 2.)), 0.) * 6.0;\n\tfloat g = max(.01 - pow(length(uv +  dist       *pos), 2.4) \n                  *(1. / (size * 2.)), 0.) * 6.0;\n\tfloat b = max(.01 - pow(length(uv + (dist + .05)*pos), 2.4) \n                  *(1. / (size * 2.)), 0.) * 6.0;\n    \n    return vec3(r, g, b);\n}\n\nvec3 ring(vec2 uv, vec2 pos, float dist)\n{\n    vec2 uvd = uv*(length(uv));\n    \n    float r = max(1. / (1. + 32. * pow(length(uvd + (dist - .05)\n\t\t\t\t  * pos), 2.)), 0.) * .25;\n\tfloat g = max(1. / (1. + 32. * pow(length(uvd +  dist       \n\t\t\t\t  * pos), 2.)), 0.) * .23;\n\tfloat b = max(1. / (1. + 32. * pow(length(uvd + (dist + .05)\n\t\t\t\t  * pos), 2.)), 0.) * .21;\n    \n    return vec3(r,g,b);\n}\n\nvec3 lensflare(vec2 uv,vec2 pos, float brightness, float size)\n{\n\t\n    vec3 c = flare(uv, pos, -1., size) * 3.;\n    c += flare(uv, pos, .5, .8 * size) * 2.;\n    c += flare(uv, pos, -.4, .8 * size);\n    \n    c += ring(uv, pos, -1.) * .5 * size;\n    c += ring(uv, pos, 1.) * .5 * size;\n    \n    return c * brightness;\n}\n\n//-------------------------------------------------------------------------------------\n// Light Scattering\n//-------------------------------------------------------------------------------------\n\n#define NUM_SAMPLES 48\n#define DENSITY .768\n#define WEIGHT .14\n#define DECAY .97\n\nvec3 lightScattering(vec2 uv, vec2 lightPos, vec3 sun)\n{    \n    vec2 deltauv = vec2(uv - lightPos);\n    vec2 st = uv;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    deltauv *= 1. /  float(NUM_SAMPLES) * DENSITY;\n    float illuminationDecay = 1.;\n    vec3 result = vec3(0.);\n\n    for(int i = 0; i < NUM_SAMPLES; i++)\n    {\n        st -= deltauv;\n        float lightStep = textureLod(iChannel1, st, 0.).a\n            \t\t* smoothstep(2.5, -1., length(uv-sun.xy));\n\n        lightStep *= illuminationDecay * WEIGHT;\n\n        result += lightStep;\n\n        illuminationDecay *= DECAY;\n    }\n    \n    return result * (SUN_COLOR) * .2;\n}\n\n//-------------------------------------------------------------------------------------\n// Tone mapping\n//-------------------------------------------------------------------------------------\n\nvec3 luminanceReinhard(vec3 color)\n{\n\tfloat lum = dot(color, vec3(.2126, .7152, .0722));\n\tfloat toneMappedLum = lum / (1. + lum);\n\tcolor *= toneMappedLum / lum;\n\treturn color;\n}\n\n//-------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 st = fragCoord/iResolution.xy;\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 mouse = (2. * iMouse.xy - iResolution.xy) / iResolution.y;\n    vec3 sun = getSun(mouse, iTime);\n\n\tvec4 terrain = textureLod(iChannel0, vec2(st.x, st.y - 1. / iResolution.y), 0.);\n    vec4 clouds = gaussianBlur(iChannel1, st);\n    float cloudsAlphaMask = clouds.a + (terrain.a > CAMERA_FAR ? 0. : 1.);\n    \n    vec2 lightPosScreenSpace = vec2(sun.x * iResolution.y/iResolution.x, sun.y) * .5 + .5;\n    float lensflareMask = textureLod(iChannel1, lightPosScreenSpace, 0.).a;\n    \n    vec3 col = vec3(0.);\n    col = vec3(clouds.rgb + terrain.rgb * cloudsAlphaMask);\n    col += lightScattering(st, lightPosScreenSpace, sun) * smoothstep(.01, .16, sun.z)\n        \t\t* smoothstep(.3, 1.5, terrain.a);\n\tcol += lensflare(uv, sun.xy, .8, 4.) * vec3(1.4, 1.2, 1.) * lensflareMask;\n    col = mix(col, pow(luminanceReinhard(col), vec3(.4545)), .75);\n    col += hash12(fragCoord) * .004;\n\n    fragColor = vec4(col, 1.);\n    \n    // hide the ugly red pixel\n    if (fragCoord.y < 2. && fragCoord.x < 2.)\n        fragColor = vec4(.6) * sun.z;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/**\n  Common tab contains all the control values for the terrain, clouds, sky etc, along\n  with all the helper functions used in multiple buffers. \n*/\n\n\n#define PI 3.1415926535\n\n#define SAT(x) clamp(x, 0., 1.)\n\n#define TERRAIN_FREQ .1\n#define TERRAIN_HEIGHT 3.\n#define HQ_OCTAVES 12\n#define MQ_OCTAVES 7\n\n#define CAMERA_NEAR .001\n#define CAMERA_FAR 200.\n#define CAMERA_FOV 75.\n#define CAMERA_HEIGHT 1.6\n#define CAMERA_PITCH .15\n#define CAMERA_ZOOM -2.\n#define CAMERA_DEPTH -1125.\n\n#define FOG_B .3\n#define FOG_C .1\n\n#define SUN_INTENSITY 6.66\n#define SUN_COLOR vec3(1.2, 1., .6)\n#define SKY_COLOR vec3(.25, .5, 1.75)\n#define SUN_SPEED .04\n\n#define EARTH_RADIUS 6378100. \n#define CLOUD_BOTTOM 3200.\n#define CLOUD_TOP 4800.\n#define CLOUD_COVERAGE .48 // lower means more cloud coverage, and vice versa\n#define CLOUD_BASE_FREQ .00005\n#define CLOUD_DETAIL_FREQ .0015\n#define CLOUD_STEPS 18\n#define CLOUD_LIGHT_STEPS 6\n#define CLOUD_TOP_OFFSET 250.\n#define CLOUD_ABSORPTION_TOP 1.8\n#define CLOUD_ABSORPTION_BOTTOM 3.6\n\n#define WIND_DIR vec3(.4, .1, 1.)\n#define WIND_SPEED 75.\n\n#define CLOUDS_AMBIENT_TOP vec3(1., 1.2, 1.6)\n#define CLOUDS_AMBIENT_BOTTOM vec3(.6, .4, .8)\n\n#define BAYER_LIMIT 16\n#define BAYER_LIMIT_H 4\n\n// 4 x 4 Bayer matrix\nconst int bayerFilter[BAYER_LIMIT] = int[]\n(\n\t 0,  8,  2, 10,\n\t12,  4, 14,  6,\n\t 3, 11,  1,  9,\n\t15,  7, 13,  5\n);\n\nstruct Ray\n{\n\tvec3 origin, direction;   \n};\n    \n//-------------------------------------------------------------------------------------\n//  Helper functions\n//-------------------------------------------------------------------------------------\n    \nfloat remap(float x, float a, float b, float c, float d)\n{\n    return (((x - a) / (b - a)) * (d - c)) + c;\n}\n\nfloat remap01(float x, float a, float b)\n{\n\treturn ((x - a) / (b - a));   \n}\n\nbool writeToPixel(vec2 fragCoord, int iFrame)\n{\n    ivec2 iFragCoord = ivec2(fragCoord);\n    int index = iFrame % BAYER_LIMIT;\n    return (((iFragCoord.x + BAYER_LIMIT_H * iFragCoord.y) % BAYER_LIMIT)\n            == bayerFilter[index]);\n\t\t\n}\n\n//-------------------------------------------------------------------------------------\n//  Camera stuff\n//-------------------------------------------------------------------------------------\n\nmat3 getCameraMatrix(vec3 origin, vec3 target)\n{\n    vec3 lookAt = normalize(target - origin);\n    vec3 right = normalize(cross(lookAt, vec3(0., 1., 0.)));\n    vec3 up = normalize(cross(right, lookAt));\n    return mat3(right, up, -lookAt);\n}\n\nRay getCameraRay(vec2 uv, float t)\n{\n    uv *= (CAMERA_FOV / 360.) * PI; // fov\n    vec3 origin = vec3(0., CAMERA_HEIGHT, CAMERA_DEPTH);\n    vec3 target = vec3(0., origin.y + CAMERA_PITCH,  CAMERA_DEPTH - 1.2);\n    mat3 camera = getCameraMatrix(origin, target);\n    vec3 direction = normalize(camera * vec3(uv, CAMERA_ZOOM));\n    return Ray(origin, direction);\n}\n\nvec3 getSun(vec2 mouse, float iTime)\n{\n    vec2 sunPos = mouse;\n    \n    if (mouse.y < -.95)\n    {\n        sunPos = vec2(cos(mod(iTime * SUN_SPEED, PI)) * .7, 0.);\n    \tsunPos.y = 1. - 3.05 * sunPos.x * sunPos.x;\n    }\n    \n    float sunHeight = (max(0., sunPos.y * .75 + .25));\n    \n    return vec3(sunPos, sunHeight);\n}\n\n//-------------------------------------------------------------------------------------\n//  Atmospheric Scattering\n//-------------------------------------------------------------------------------------\n\n/** Slightly modified version of robobo1221's fake atmospheric scattering\n \t(https://www.shadertoy.com/view/4tVSRt)\n*/\nvec3 miePhase(float dist, vec3 sunL)\n{\n    return max(exp(-pow(dist, .3)) * sunL - .4, 0.);\n}\n\nvec3 atmosphericScattering(vec2 uv, vec2 sunPos, bool isSun)\n{\n    \n    float sunDistance = distance(uv, sunPos);\n\tfloat scatterMult = SAT(sunDistance);\n\tfloat dist = uv.y;\n\tdist = (.5 * mix(scatterMult, 1., dist)) / dist;\n    vec3 mieScatter = miePhase(sunDistance, vec3(1.)) * SUN_COLOR;\n\tvec3 color = dist * SKY_COLOR;\n    color = max(color, 0.);\n    vec3 sun = .0002 / pow(length(uv-sunPos), 1.7) * SUN_COLOR;\n    \n\tcolor = max(mix(pow(color, .8 - color),\n\tcolor / (2. * color + .5 - color * 1.3),\n\tSAT(sunPos.y * 2.5)), 0.)\n\t+ (isSun ? (sun + mieScatter) : vec3(0.));\n    \n\tcolor *=  (pow(1. - scatterMult, 5.) * 10. * SAT(.666 - sunPos.y)) + 1.5;\n\tfloat underscatter = distance(sunPos.y, 1.);\n\tcolor = mix(color, vec3(0.), SAT(underscatter));\n\t\n\treturn color;\t\n}\n\n//-------------------------------------------------------------------------------------\n//  Hash Functions\n//-------------------------------------------------------------------------------------\n    \n// Hash functions by Dave_Hoskins\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1. / float(0xffffffffU))\n\nvec3 hash33(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn -1. + 2. * vec3(q) * UIF;\n}\n\nfloat hash13(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq *= UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\n\nfloat hash12(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\n//-------------------------------------------------------------------------------------\n// Noise generation\n//-------------------------------------------------------------------------------------\n\n// Iq's value noise, and its analytical derivatives\nvec3 valueNoiseDerivative(vec2 x, sampler2D smp)\n{\n    vec2 f = fract(x);\n    vec2 u = f * f * (3. - 2. * f);\n\n#if 1\n    // texel fetch version\n    ivec2 p = ivec2(floor(x));\n    float a = texelFetch(smp, (p + ivec2(0, 0)) & 255, 0).x;\n\tfloat b = texelFetch(smp, (p + ivec2(1, 0)) & 255, 0).x;\n\tfloat c = texelFetch(smp, (p + ivec2(0, 1)) & 255, 0).x;\n\tfloat d = texelFetch(smp, (p + ivec2(1, 1)) & 255, 0).x;\n#else    \n    // texture version    \n    vec2 p = floor(x);\n\tfloat a = textureLod(smp, (p + vec2(.5, .5)) / 256., 0.).x;\n\tfloat b = textureLod(smp, (p + vec2(1.5, .5)) / 256., 0.).x;\n\tfloat c = textureLod(smp, (p + vec2(.5, 1.5)) / 256., 0.).x;\n\tfloat d = textureLod(smp, (p + vec2(1.5, 1.5)) / 256., 0.).x;\n#endif\n    \n\treturn vec3(a + (b - a) * u.x + (c - a) * u.y + (a - b - c + d) * u.x * u.y,\n\t\t\t\t6. * f * (1. - f) * (vec2(b - a, c - a) + (a - b - c + d) * u.yx));\n}\n\nfloat valueNoise(vec3 x, float freq)\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3. - 2. * f);\n\t\n    return mix(mix(mix(hash13(mod(i + vec3(0, 0, 0), freq)),  \n                       hash13(mod(i + vec3(1, 0, 0), freq)), f.x),\n                   mix(hash13(mod(i + vec3(0, 1, 0), freq)),  \n                       hash13(mod(i + vec3(1, 1, 0), freq)), f.x), f.y),\n               mix(mix(hash13(mod(i + vec3(0, 0, 1), freq)),  \n                       hash13(mod(i + vec3(1, 0, 1), freq)), f.x),\n                   mix(hash13(mod(i + vec3(0, 1, 1), freq)),  \n                       hash13(mod(i + vec3(1, 1, 1), freq)), f.x), f.y), f.z);\n}\n\n// Tileable 3D worley noise\nfloat worleyNoise(vec3 uv, float freq, bool tileable)\n{    \n    vec3 id = floor(uv);\n    vec3 p = fract(uv);\n    float minDist = 10000.;\n    \n    for (float x = -1.; x <= 1.; ++x)\n    {\n        for(float y = -1.; y <= 1.; ++y)\n        {\n            for(float z = -1.; z <= 1.; ++z)\n            {\n                vec3 offset = vec3(x, y, z);\n                vec3 h = vec3(0.);\n                if (tileable)\n                    h = hash33(mod(id + offset, vec3(freq))) * .4 + .3; // [.3, .7]\n\t\t\t\telse\n                    h = hash33(id + offset) * .4 + .3; // [.3, .7]\n    \t\t\th += offset;\n            \tvec3 d = p - h;\n           \t\tminDist = min(minDist, dot(d, d));\n            }\n        }\n    }\n    \n    // inverted worley noise\n    return 1. - minDist;\n}\n\n// Fbm for Perlin noise based on iq's blog\nfloat perlinFbm(vec3 p, float freq, int octaves)\n{\n    float G = exp2(-.85);\n    float amp = 1.;\n    float noise = 0.;\n    for (int i = 0; i < octaves; ++i)\n    {\n        noise += amp * valueNoise(p * freq, freq);\n        freq *= 2.;\n        amp *= G;\n    }\n    \n    return noise;\n}\n\n// Tileable Worley fbm inspired by Andrew Schneider's Real-Time Volumetric Cloudscapes\n// chapter in GPU Pro 7.\nfloat worleyFbm(vec3 p, float freq, bool tileable)\n{\n    float fbm = worleyNoise(p * freq, freq, tileable) * .625 +\n        \t \tworleyNoise(p * freq * 2., freq * 2., tileable) * .25 +\n        \t \tworleyNoise(p * freq * 4., freq * 4., tileable) * .125;\n    return max(0., fbm * 1.1 - .1);\n}", "buffer_a_code": "/**\n  Buffer A generates Perlin-Worley and Worley fbm noises used for modeling clouds\n  in buffer C. This buffer only writes to texture at the beginning or whenever the\n  viewport resolution is changed.\n*/\n\nbool resolutionChanged() {\n    return int(texelFetch(iChannel1, ivec2(0), 0).r) != int(iResolution.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (resolutionChanged())\n    {\n        vec2 uv = fragCoord / iResolution.xy;\n        vec4 col = vec4(0.);\n        col.r += perlinFbm(vec3(uv, .4), 4., 15) * .5;\n        col.r = abs(col.r * 2. - 1.);\n        col.r = remap(col.r,  worleyFbm(vec3(uv, .2), 4., true) - 1., 1., 0., 1.);\n        col.g += worleyFbm(vec3(uv, .5), 8., true) * .625 + \n            \t worleyFbm(vec3(uv, .5), 16., true) * .25  +\n            \t worleyFbm(vec3(uv, .5), 32., true) * .125;\n        col.b = 1. - col.g;\n        fragColor = col;\n    }\n    else\n    {\n\t\tfragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);   \n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/**\n  Buffer B ray marches and shades the terrain using iq's 3 light model and improved\n  height fog. This buffer only updates 1 pixel in a 4x4 grid per frame, and the rest\n  are reprojected.\n*/\n\n// Iq's slightly modified terrain fbm\nconst mat2 m2 = mat2(.8, -.6, .6, .8);\n\nfloat terrainFbm(vec2 uv, int octaves, sampler2D smp)\n{\n    vec2  p = uv * TERRAIN_FREQ;\n    float a = 0.;\n    float b = 1.;\n\tvec2  d = vec2(0.);\n    \n    for (int i = 0; i < octaves; ++i)\n    {\n        vec3 n = valueNoiseDerivative(p, smp);\n        d += n.yz;\n        a += b * n.x / (1. + dot(d, d));\n\t\tb *= .5;\n        p = m2 * p * 2.;\n    }\n    \n    a = abs(a) * 2. - 1.;\n    \n    return smoothstep(-.95, .5, a) * a * TERRAIN_HEIGHT;\n}\n\nvec3 calcNormal(vec3 pos, float freq, float t)\n{\n    vec2 eps = vec2( 0.002 * t, 0.0 );\n    int norLod = int(max(5., float(HQ_OCTAVES) - (float(HQ_OCTAVES) - 1.)\n                         * t / CAMERA_FAR));\n    return normalize( \n        vec3(terrainFbm(pos.xz - eps.xy, norLod, iChannel0) - terrainFbm(pos.xz\n\t\t\t\t\t+ eps.xy, norLod, iChannel0),\n             2.0 * eps.x,\n             terrainFbm(pos.xz - eps.yx, norLod, iChannel0) - terrainFbm(pos.xz\n\t\t\t\t\t+ eps.yx, norLod, iChannel0)));\n}\n\nfloat raymarchShadow(Ray ray)\n{\n    float shadow = 1.;\n\tfloat t = CAMERA_NEAR;\n    vec3 p = vec3(0.);\n    float h = 0.;\n    for(int i = 0; i < 80; ++i)\n\t{\n\t    p = ray.origin + t * ray.direction;\n        h = p.y - terrainFbm(p.xz, MQ_OCTAVES, iChannel0);\n\t\tshadow = min(shadow, 8. * h / t);\n\t\tt += h;\n\t\tif (shadow < 0.001 || p.z > CAMERA_FAR) break;\n\t}\n\treturn SAT(shadow);\n}\n\nfloat raymarchTerrain(Ray ray)\n{\n\tfloat t = CAMERA_NEAR, h = 0.;\n    for (int i = 0; i < 200; ++i)\n    {\n    \tvec3 pos = ray.origin + ray.direction * t;\n        h = pos.y - terrainFbm(pos.xz, MQ_OCTAVES, iChannel0);\n        if (abs(h) < (t * .002) || t > CAMERA_FAR)\n            break;\n        t += h * .5;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord / iResolution.xy;\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 mouse = (2. * iMouse.xy - iResolution.xy) / iResolution.y;\n    \n    bool updatePixel = writeToPixel(fragCoord, iFrame);\n    \n    vec4 col = textureLod(iChannel1, st, 0.);\n    \n    if(updatePixel) // only draw 1/16th resolution per frame\n    {\n        Ray ray = getCameraRay(uv, iTime);\n    \n        float terrainDist = raymarchTerrain(ray);\n\n        vec3 sun = getSun(mouse, iTime);\n        vec3 sunDir = normalize(vec3(sun.x, sun.z, -1.));\n        vec3 sunHalf = normalize(sunDir+ray.direction);\n        float sunDot = max(0., dot(ray.direction, sunDir));\n        \n\t\tvec3 terrainNormal = vec3(0.);\n        \n        col *= 0.;\n        \n        if (terrainDist > CAMERA_FAR)\n        {\n            // sky\n            col.rgb += atmosphericScattering(uv * .5 + .225, sun.xy * .5 + .225, true);\n            col.gb += .006 - uv.y * .0048; // slight night time blue-green tint\n\n            // stars\n            float t = iTime * .15;\n            float stars = pow(hash12(fragCoord), 4. * iResolution.x);\n            float twinkle = sin(t * 3.7 + uv.x - sin(uv.y * 20. + t) * 10.) * 2.;\n            twinkle *= cos(uv.y + t * 4.4 - sin(uv.x * 15. + t) * 7.) * 1.5;\n            twinkle = twinkle * .5 + .5;\n            col += max(0., stars * twinkle * smoothstep(.075, 0., sun.z) * 2.);\n        }\n        else\n        {\n            vec3 marchPos = ray.origin + ray.direction * terrainDist;\n            terrainNormal += calcNormal(marchPos, TERRAIN_FREQ, terrainDist); \n\t\t\t\n            // terrain colors\n            vec3 rock = vec3(.1, .1, .08);\n            vec3 snow = vec3(.9);\n            vec3 grass = vec3(.02, .1, .05);\n\n            vec3 albedo = mix(grass, rock, smoothstep(0., .1 * TERRAIN_HEIGHT,\n\t\t\t\t\t\t\t\tmarchPos.y)); \n            albedo = mix(albedo, snow, smoothstep(.4 * TERRAIN_HEIGHT,\n\t\t\t\t\t\t\t1.4 * TERRAIN_HEIGHT, marchPos.y));\n            albedo = mix(rock, albedo, smoothstep(.4, .7, terrainNormal.y));\n\n            float terrainShadow = clamp(raymarchShadow(Ray(marchPos - sunDir * .001, \n\t\t\t\t\t\t\t\t\t\tsunDir)), 0., 8.) + .2;\n\n            float diffuse = max(dot(sunDir, terrainNormal), 0.) * terrainShadow;\n            float specular = SAT(dot(sunHalf, ray.direction));\n            float skyAmbient = SAT(.5 + .5 * terrainNormal.y);\n\n            col.rgb += SUN_INTENSITY * SUN_COLOR * diffuse; // sun diffuse\n            // sky ambient\n            col.rgb += vec3(.5, .7, 1.2) * skyAmbient;\n            // backlight ambient\n            col.rgb += SUN_COLOR * (SAT(.5 + .5 * dot(\n                normalize(vec3(-sunDir.x, sunDir.y, sunDir.z)), terrainNormal)));\n            // terrain tex color\n            col.rgb *= albedo;\n\n            // specular\n            col.rgb += SUN_INTENSITY * .4 * SUN_COLOR * diffuse \n                \t\t\t* pow(SAT(specular), 16.);\n\n            // Iq's height based density fog\n            float fogMask = FOG_C * exp(-ray.origin.y * FOG_B) *\n                (1. - exp(-pow(terrainDist * FOG_B, 1.5) * ray.direction.y))\n                / ray.direction.y;\n            vec3 fogCol = mix(atmosphericScattering(uv * .5 + .75, sun.xy * .5 + .225,\n\t\t\t\t\t\t\t\tfalse) * .75, vec3(.8, .6, .3), pow(sunDot, 8.));\n            // shitty night time fog hack\n            fogCol = mix(vec3(.4, .5, .6), fogCol, smoothstep(0., .1, sun.z));\n            col.rgb = mix(col.rgb, fogCol, SAT(fogMask));\n\n            col.rgb *= max(.0, sun.z)\n                + mix(vec3(smoothstep(.1, 0., sun.z)) * terrainNormal.y, fogCol, \n                      SAT(fogMask)) * (.012, .024, .048);\n        }\n        col.a = terrainDist;\n    }\n    \n    fragColor = col;\n    \n    if (fragCoord.x < 1. && fragCoord.y < 1.)\n    {\n    \tfragColor = vec4(iResolution.x, vec3(0.));   \n    }\n}", "buffer_b_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "/**\n  Buffer C draws the clouds in the sky. The texture from buffer A is used to model the\n  clouds in the ray march and the light march loops. Just like buffer B, only 1 out 16\n  pixels are processed per frame and the rest are reprojected. If anyone's interested,\n  I've compiled a useful list of resources for rendering realtime volumetric clouds\n  here: https://gist.github.com/pxv8270/e3904c49cbd8ff52cb53d95ceda3980e\n*/\n\nconst vec3 noiseKernel[6u] = vec3[] \n(\n\tvec3( .38051305,  .92453449, -.02111345),\n\tvec3(-.50625799, -.03590792, -.86163418),\n\tvec3(-.32509218, -.94557439,  .01428793),\n\tvec3( .09026238, -.27376545,  .95755165),\n\tvec3( .28128598,  .42443639, -.86065785),\n\tvec3(-.16852403,  .14748697,  .97460106)\n);\n\n//-------------------------------------------------------------------------------------\n// Clouds modeling\n//-------------------------------------------------------------------------------------\n\nfloat raySphereIntersect(Ray ray, float radius)\n{\n    // note to future me: don't need \"a\" bcuz rd is normalized and dot(rd, rd) = 1\n \tfloat b = 2. * dot(ray.origin, ray.direction);\n    float c = dot(ray.origin, ray.origin) - radius * radius;\n    float d = sqrt(b * b - 4. * c);\n    return (-b + d) * .5;\n}\n\nfloat cloudGradient(float h)\n{\n    return smoothstep(0., .05, h) * smoothstep(1.25, .5, h);\n}\n\nfloat cloudHeightFract(float p)\n{\n\treturn (p - EARTH_RADIUS - CLOUD_BOTTOM) / (CLOUD_TOP - CLOUD_BOTTOM);\n}\n\nfloat cloudBase(vec3 p, float y)\n{\n    vec3 noise = textureLod(iChannel2, (p.xz - (WIND_DIR.xz * iTime * WIND_SPEED))\n                            * CLOUD_BASE_FREQ, 0.).rgb;\n    float n = y * y * noise.b + pow(1. - y, 12.);\n    float cloud = remap01(noise.r - n, noise.g - 1., 1.);\n    return cloud;\n}\n\nfloat cloudDetail(vec3 p, float c, float y)\n{\n    p -= WIND_DIR * 3. * iTime * WIND_SPEED;\n    // this is super expensive :(\n    float hf = worleyFbm(p, CLOUD_DETAIL_FREQ, false) * .625 +\n        \t   worleyFbm(p, CLOUD_DETAIL_FREQ*2., false) * .25 +\n        \t   worleyFbm(p, CLOUD_DETAIL_FREQ*4., false) * .125;\n    hf = mix(hf, 1. - hf, y * 4.);\n    return remap01(c, hf * .5, 1.);\n}\n\nfloat getCloudDensity(vec3 p, float y, bool detail)\n{\n    p.xz -= WIND_DIR.xz * y * CLOUD_TOP_OFFSET;\n    float d = cloudBase(p, y);\n    d = remap01(d, CLOUD_COVERAGE, 1.) * (CLOUD_COVERAGE);\n    d *= cloudGradient(y);\n    bool cloudDetailTest = (d > 0. && d < .3) && detail; \n    return ((cloudDetailTest) ? cloudDetail(p, d, y) : d);\n}\n\n//-------------------------------------------------------------------------------------\n// Clouds lighting\n//-------------------------------------------------------------------------------------\n\nfloat henyeyGreenstein( float sunDot, float g) {\n\tfloat g2 = g * g;\n\treturn (.25 / PI) * ((1. - g2) / pow( 1. + g2 - 2. * g * sunDot, 1.5));\n}\n\nfloat marchToLight(vec3 p, vec3 sunDir, float sunDot, float scatterHeight)\n{\n    float lightRayStepSize = 11.;\n\tvec3 lightRayDir = sunDir * lightRayStepSize;\n    vec3 lightRayDist = lightRayDir * .5;\n    float coneSpread = length(lightRayDir);\n    float totalDensity = 0.;\n    for(int i = 0; i < CLOUD_LIGHT_STEPS; ++i)\n    {\n        // cone sampling as explained in GPU Pro 7 article\n     \tvec3 cp = p + lightRayDist + coneSpread * noiseKernel[i] * float(i);\n        float y = cloudHeightFract(length(p));\n        if (y > .95 || totalDensity > .95) break; // early exit\n        totalDensity += getCloudDensity(cp, y, false) * lightRayStepSize;\n        lightRayDist += lightRayDir;\n    }\n    \n    return 32. * exp(-totalDensity * mix(CLOUD_ABSORPTION_BOTTOM,\n\t\t\t\tCLOUD_ABSORPTION_TOP, scatterHeight)) * (1. - exp(-totalDensity * 2.));\n}\n\n//-------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord / iResolution.xy;\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 mouse = (2. * iMouse.xy - iResolution.xy) / iResolution.y;\n    float terrainDist = texelFetch(iChannel0, ivec2(fragCoord), 0).w;\n    vec4 prevCol = textureLod(iChannel1, st, 0.);\n    vec4 col = vec4(0.);\n    \n    bool updatePixel = writeToPixel(fragCoord, iFrame);\n    \n    if (updatePixel) // only draw 1/16th resolution per frame\n    {\n        \n        Ray ray = getCameraRay(uv, iTime);\n        vec3 sun = getSun(mouse, iTime);\n        // clouds don't get blindingly bright with sun at zenith\n        sun.z = clamp(sun.z, 0., .8);\n        vec3 sunDir = normalize(vec3(sun.x, sun.z, -1.));\n        float sunDot = max(0., dot(ray.direction, sunDir));\n        float sunHeight = smoothstep(.01, .1, sun.z + .025);\n        \n        if (terrainDist > CAMERA_FAR)\n        {\n\n            // clouds\n            ray.origin.y = EARTH_RADIUS;\n            float start = raySphereIntersect(ray, EARTH_RADIUS + CLOUD_BOTTOM);\n            float end = raySphereIntersect(ray, EARTH_RADIUS + CLOUD_TOP);\n            float cameraRayDist = start;\n            float cameraRayStepSize = (end - start) / float(CLOUD_STEPS);\n            \n            // blue noise offset\n            cameraRayDist += cameraRayStepSize * texelFetch(iChannel3,\n\t\t\t\t\t\t\t(ivec2(fragCoord) + iFrame * ivec2(113, 127)) & 1023, 0).r;\n            vec3 skyCol = atmosphericScattering(vec2(0.15, 0.05),\n                                vec2(.5, sun.y*.5+.25), false);\n            skyCol.r *= 1.1;\n\t\t\tskyCol = SAT(pow(skyCol * 2.1, vec3(4.2)));\n            float sunScatterHeight = smoothstep(.15, .4, sun.z);\n            float hgPhase = mix(henyeyGreenstein(sunDot, .4),\n                                henyeyGreenstein(sunDot, -.1), .5);\n            // sunrise/sunset hack\n            hgPhase = max(hgPhase, 1.6 * henyeyGreenstein(sqrt(sunDot),\n\t\t\t\t\t\t\tSAT(.8 - sunScatterHeight)));\n            // shitty night time hack\n            hgPhase = mix(pow(sunDot, .25), hgPhase, sunHeight);\n            \n            vec4 intScatterTrans = vec4(0., 0., 0., 1.);\n            vec3 ambient = vec3(0.);\n            for (int i = 0; i < CLOUD_STEPS; ++i)\n            {\n                vec3 p = ray.origin + cameraRayDist * ray.direction;\n                float heightFract = cloudHeightFract(length(p));\n                float density = getCloudDensity(p, heightFract, true);\n                if (density > 0.)\n                {\n                    ambient = mix(CLOUDS_AMBIENT_BOTTOM, CLOUDS_AMBIENT_TOP, \n                                  \theightFract);\n\t\t\t\t\t\n                    // cloud illumination\n                    vec3 luminance = (ambient * SAT(pow(sun.z + .04, 1.4))\n\t\t\t\t\t\t+ skyCol * .125 + (sunHeight * skyCol + vec3(.0075, .015, .03))\n\t\t\t\t\t\t* SUN_COLOR * hgPhase\n\t\t\t\t\t\t* marchToLight(p, sunDir, sunDot, sunScatterHeight)) * density;\n\n                    // improved scatter integral by Sébastien Hillaire\n                    float transmittance = exp(-density * cameraRayStepSize);\n                    vec3 integScatter = (luminance - luminance * transmittance)\n                        * (1. / density);\n                    intScatterTrans.rgb += intScatterTrans.a * integScatter; \n                    intScatterTrans.a *= transmittance;\n\n                }\n\n                if (intScatterTrans.a < .05)\n                    break;\n                cameraRayDist += cameraRayStepSize;\n            }\n\n            // blend clouds with sky at a distance near the horizon (again super hacky)\n            float fogMask = 1. - exp(-smoothstep(.15, 0., ray.direction.y) * 2.);\n            vec3 fogCol = atmosphericScattering(uv * .5 + .2, sun.xy * .5 + .2, false);\n            intScatterTrans.rgb = mix(intScatterTrans.rgb,\n                                      fogCol * sunHeight, fogMask);\n            intScatterTrans.a = mix(intScatterTrans.a, 0., fogMask);\n\n            col = vec4(max(vec3(intScatterTrans.rgb), 0.), intScatterTrans.a);\n            \n            //temporal reprojection\n    \t\tcol = mix(prevCol, col, .5);\n        }\n    }\n    else\n    {\n\t\tcol = prevCol;\n    }\n    \n    fragColor = col;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "/**\n  Buffer D performs TXAA on the clouds from buffer C to hide some blue noise and\n  ghosting artifacts.\n*/\n\nconst ivec2 offsets[8u] = ivec2[]\n(\n    ivec2(-1,-1), ivec2(-1, 1), \n\tivec2(1, -1), ivec2(1, 1), \n\tivec2(1, 0), ivec2(0, -1), \n\tivec2(0, 1), ivec2(-1, 0)\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 currentBuffer = textureLod(iChannel0, uv, 0.);\n    vec4 historyBuffer = textureLod(iChannel1, uv, 0.);\n\n    vec4 colorAvg = currentBuffer;\n    vec4 colorVar = currentBuffer * currentBuffer;\n    \n    // Marco Salvi's Implementation (by Chris Wyman)\n    for(int i = 0; i < 8; i++)\n    {\n        vec4 neighborTexel = texelFetch(iChannel0, ivec2(fragCoord.xy) + offsets[i], 0);\n        colorAvg += neighborTexel;\n        colorVar += neighborTexel * neighborTexel;\n    }\n    colorAvg /= 9.;\n    colorVar /= 9.;\n    float gColorBoxSigma = .75;\n\tvec4 sigma = sqrt(max(vec4(0.), colorVar - colorAvg * colorAvg));\n\tvec4 colorMin = colorAvg - gColorBoxSigma * sigma;\n\tvec4 colorMax = colorAvg + gColorBoxSigma * sigma;\n    \n    historyBuffer = clamp(historyBuffer, colorMin, colorMax);\n\n\tfragColor = mix(currentBuffer, historyBuffer, 0.95);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcSD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1996, 1996, 2040, 2040, 2417], [2419, 2419, 2474, 2474, 2885], [2887, 2887, 2929, 2929, 3279], [3281, 3281, 3345, 3345, 3598], [3879, 3879, 3935, 3935, 4530], [4725, 4725, 4761, 4761, 4902], [4993, 4993, 5048, 5048, 6190]], "test": "untested"}
{"id": "tsscDs", "name": "Day 106", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 5, "viewed": 343, "published": 3, "date": "1585908235", "time_retrieved": "2024-07-30T21:15:12.295054", "image_code": "#define pi acos(-1.)\n#define tau (2.*pi)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n#define timeStep (1./30.)\n#define motionBlurSteps 100\n\n// USING YX/LUNA'S AWESOME DITHERED MOTION BLUR - https://www.shadertoy.com/view/wsfcWX\n// I modified it to not be framerate dependent like the original.\n\n\nfloat bayer8(ivec2 uv)\n{   \n    uv %= 8;\n\treturn texelFetch(iChannel1,uv,0).r;\n}\n\n// from https://necessarydisorder.wordpress.com/\nfloat ease(float p, float g) {\n    if(p < 0.){\n        return 0.;\n    } else if(p > 1.){\n    \treturn 1.;\n    } else {\n        if (p < 0.5) \n            return 0.5 * pow(2.*p, g);\n        else\n            return 1. - 0.5 * pow(2.*(1. - p), g);\n    }\n}\n\nfloat ease(float p, float power, float jump, float offs, float end) {\n    float j = p;\n    p *= offs;\n    float r = (1.-cos(pi*p))/2.*jump;\n    r = pow(r, power);\n    r = mix(r, 1., pow(smoothstep(0.,1.,j),end));\n\treturn r;\n}\n\nvec3 get(  vec2 uv, float t, inout float edge )\n{\n    \n    float modD = 3.;\n    \n    t *= 1.;\n    t = mod(t, 1.);\n    vec3 col = vec3(0);\n\n    vec2 uvv = uv * 1.9;\n    //uv *= 1. - dot(uvv,uvv)*0.1;\n    \n    uv *= 1.;\n    \n    edge = dFdx(uv.x)*(1. + exp(-length(uv)*30.)*2500.);    \n    float dpp = dot(uv,uv);\n    \n    uv /= dpp;\n    \n    uv.y +=  (floor(t) + ease(fract(t), 3.))*modD*modD + modD*2.;\n    //uv.x += t;\n    \n    vec2 id = floor(mod(uv/modD, modD));\n    uv = mod(uv,modD) - modD*0.5;\n    //uv = sin(uv*22./8./2.);\n\n    \n    float d = length(uv) - modD*0.2;\n    if(id.y < 1. || mod(abs(id.x), 2.) == 1.)\n    \tcol = vec3(d);\n    else \n        col = vec3(10);    \n    //col = vec3\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;  \n    vec3 col = vec3(0.);\n    \n    \n    float e = 0.;\n    for (int i = 0; i < motionBlurSteps  ; ++i) {\n        float subsample = bayer8(ivec2(fragCoord));\n        float time = iTime + ((float(i)+subsample)/float(motionBlurSteps)-.5) * timeStep;\n        float edge;\n        vec3 d = get(uv,time, edge);\n        col += smoothstep(-edge,edge,-d);\n        e += exp(-abs(d.x)*40.);\n    }\n    col/=float(motionBlurSteps);\n    e/=float(motionBlurSteps);\n    \n    col *= 0.999;\n    \n    \n    \n    col *= 1. - exp(-length(uv)*100.)*2.;\n    col *= vec3(2.,0.4,0.1);\n    \n    col.gb -= e;\n    col = clamp(col, 0., 1.);\n    col = mix(col, vec3(0.06,0.1,0.4)*0.02, smoothstep(1.,0.,length(col)*1.));\n    \n    //col *= max((1. + 1.*cos(sin(0.25*tau*iTime)*tau+length(uv)*2.+vec3(4,2.5,1.5)))*1., 0.);\n    //col *= max((1.5 + 1.4*cos(iTime+length(uv)*2.+vec3(1,1.5,1.5)))*1., 0.);\n    \n    \n    \n    \n    col *= 1. - pow(smoothstep(0.,1.,length(uv)*1.),1.)*1.;\n    \n    col = pow(col, vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsscDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[303, 303, 327, 327, 383], [385, 434, 464, 464, 684], [686, 686, 755, 755, 911], [913, 913, 962, 962, 1629]], "test": "untested"}
{"id": "3dfcDX", "name": "Poncelet's Porism", "author": "mla", "description": "Poncelet's Porism: [url]https://en.wikipedia.org/wiki/Poncelet%27s_closure_theorem[/url] or a nice talk by Joe Harris: [url]https://www.youtube.com/watch?v=P7E_YOiuDvI[/url] (not that I follow all the details).\n\nMouse changes the conics.", "tags": ["projective", "poncelet", "porism"], "likes": 7, "viewed": 326, "published": 3, "date": "1585907455", "time_retrieved": "2024-07-30T21:15:13.053027", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Poncelet's Porism\n// Matthew Arcus, 2020.\n//\n// Another gem of projective geometry. Given a pair of conics, if an\n// n-gon can be inscribed in one such that it circumscribes the other,\n// then there are an infinite number of such n-gons. It's difficult in\n// general to find such an n-gon in the first place, but here's an\n// easy special case.\n//\n// Inscribe a regular m/n-gon in a circle, find the incircle of the\n// polygon and then apply a projective transformation. Here, we map\n// points (-1,0),(0,1) and (0,-1) on the unit circle to themselves,\n// and the point (1,0) to the mouse position.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nfloat N = 11.0, M = 5.0; // Polygon parameters\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// Geometric constructions\n//\n// Homogeneous coordinates used throughout (so the lines and points are\n// \"projective\"):\n// (x,y,z) represents the point (x/z,y/z) for z != 0\n// (x,y,0) represents a \"point at infinity\" which acts like a direction.\n// (a,b,c) represents the line ax + by + cz = 0\n// (0,0,c) represents the \"line at infinity\"\n//\n////////////////////////////////////////////////////////////////////////////////\n\nfloat PI = 3.14159;\n\n// The line between two projective points, or the intersection of two\n// projective lines, is just their cross product.\nvec3 join(vec3 p, vec3 q) {\n  return cross(p,q);\n}\n\n// Find a projective mapping taking p0,p1,p2,p4 to\n// triangle of reference and unit point, ie:\n// p0 -> (1,0,0), p1 -> (0,1,0), p2 -> (0,0,1), p3 -> (1,1,1)\n// No three points collinear.\nmat3 rproject(vec3 p0, vec3 p1, vec3 p2, vec3 p3) {\n  // Just an inverse for the first three points\n  // (the triangle of reference). No inverse if collinear.\n  mat3 m = inverse(mat3(p0,p1,p2)); // column major!\n  vec3 p3a = m*p3;\n  // Then scale each row so the unit point (1,1,1) is correct\n  m = transpose(m);\n  // zero components here only if not collinear\n  m[0] /= p3a[0];\n  m[1] /= p3a[1];\n  m[2] /= p3a[2];\n  m = transpose(m);\n  return m;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Distance functions\n////////////////////////////////////////////////////////////////////////////////\n\nfloat point(vec3 p, vec3 q) {\n  float pz = p.z, qz = q.z;\n  p *= qz; q *= pz;\n  return distance(p,q)/abs(p.z);\n}\n\nfloat line(vec3 p, vec3 q) {\n  return abs(dot(p,q)/(p.z*length(q.xy)));\n}\n\nfloat line(vec3 p, vec3 q, vec3 r) {\n  return line(p,join(q,r));\n}\n\nfloat conic(vec3 p, mat3 m) {\n  float s = dot(p,m*p);\n  vec3 ds = 2.0*m*p; // Gradient\n  return abs(s/(p.z*length(ds.xy))); // Normalize for Euclidean distance\n}\n\nmat3 circlemat(vec4 c) {\n  // (x-a)^2 + (y-b)^2 = r^2\n  // x2 -2ax + a2 + y2 -2by + b2 -r2 = 0\n  vec3 q = c.xyz;\n  float r2 = c.w;\n  q /= q.z;\n  return mat3(1,0,-q.x,\n              0,1,-q.y,\n              -q.x,-q.y,dot(q.xy,q.xy)-r2);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Drawing functions\n////////////////////////////////////////////////////////////////////////////////\n\nvec3 diagram(vec3 p, vec3 P) {\n  vec3 A = vec3(0,-1,1), B = vec3(-1,0,1), C = vec3(0,1,1);\n  mat3 X = rproject(A,B,C,P), Y = rproject(A,B,C,vec3(1,0,1));\n  mat3 T = inverse(X)*Y, S = inverse(T);\n  float theta = PI/N; // Segment half angle\n  float lmin = 0.005, lmax = 0.008+fwidth(p.x);\n  float pmin = 0.01, pmax = 0.02;\n  float r = cos(M*theta);\n  mat3 c1 = circlemat(vec4(0,0,1,1));\n  mat3 c2 = circlemat(vec4(0,0,1,r*r));\n  vec3 col = vec3(1,1,0.8);\n  col = mix(vec3(0.5),col,0.75+0.75*smoothstep(lmin,lmax,conic(p,c1)));\n  //col = mix(vec3(0,0,1),col,0.5+0.5*smoothstep(lmin,lmax,conic(p,c2)));\n  col = mix(vec3(1,0,0),col,smoothstep(lmin,lmax,conic(p,transpose(S)*c1*S)));\n  col = mix(vec3(0,0,1),col,smoothstep(lmin,lmax,conic(p,transpose(S)*c2*S)));\n  float t = 0.2*iTime;\n  for (float i = 0.0; i < N; i++) {\n    vec3 p0 = vec3(cos(2.0*i*theta+t),sin(2.0*i*theta+t),1);\n    vec3 p1 = vec3(cos(2.0*(i+M)*theta+t),sin(2.0*(i+M)*theta+t),1);\n    //col = mix(vec3(0,0.5,0),col,0.5+0.5*smoothstep(lmin,lmax,line(p,p0,p1)));\n    col = mix(vec3(0,1,0),col,0.5+0.5*smoothstep(lmin,lmax,line(p,T*p0,T*p1)));\n  }\n  for (float i = 0.0; i < N; i++) {\n    vec3 p0 = vec3(cos(2.0*i*theta+t),sin(2.0*i*theta+t),1);\n    //col = mix(vec3(0.5),col,smoothstep(pmin,pmax,point(p,p0)));\n    col = mix(vec3(0),col,smoothstep(pmin,pmax,point(p,T*p0)));\n  }\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  float scale = 1.2;\n  vec3 p = vec3(scale*(2.0*fragCoord-iResolution.xy)/iResolution.y,1.0);\n  vec3 P = iMouse.x <= 0.0 ? vec3(-0.5,0,1)\n    : vec3(scale*(2.0*iMouse.xy-iResolution.xy)/iResolution.y,1);\n  vec3 col = diagram(p,P);\n  fragColor = vec4(pow(col,vec3(0.4545)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfcDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1347, 1467, 1494, 1494, 1517], [1519, 1707, 1758, 1865, 2155], [2342, 2342, 2371, 2371, 2454], [2456, 2456, 2484, 2484, 2529], [2531, 2531, 2567, 2567, 2597], [2599, 2599, 2628, 2628, 2760], [2762, 2762, 2786, 2856, 2998], [3184, 3184, 3214, 3214, 4540], [4542, 4542, 4595, 4595, 4873]], "test": "untested"}
{"id": "wslcWs", "name": "Attack of the Bats", "author": "Roninkoi", "description": "Bats are evil", "tags": ["raymarching", "pillars", "bats"], "likes": 4, "viewed": 320, "published": 3, "date": "1585888969", "time_retrieved": "2024-07-30T21:15:13.799033", "image_code": "#define PI 3.14159265\n#define MAXIT 128\n#define EPSILON 0.001\n\n#define minx(a, b) ((a.w) < (b.w) ? (a) : (b))\n#define maxx(a, b) ((a.w) > (b.w) ? (a) : (b))\n\nfloat t;\n\nfloat sphere(vec3 r, float a)\n{\n\treturn length(r) - a;\n}\n\nfloat bat(vec3 r, float a)\n{\n\tr *= mat3(\n\t\tcos((r.x * sin(t * 20.) * 0.5) * 1.), -sin((r.x * sin(t * 20.) * 0.5) * 1.), 0., \n\t\tsin((r.x * sin(t * 20.) * 0.5) * 1.), cos((r.x * sin(t * 20.) * 0.5) * 1.), 0.,\n\t\t0., 0., 1.\n\t);\n\tfloat d = (abs(r.x*r.y)*3. + 1./a) * (abs(sqrt(r.y+0.1) * r.y) + sin(r.y) + 1./a) * (abs(r.z) + 1./a);\n\treturn length(r) - 1./ d;\n}\n\nfloat plane(vec3 r, vec3 o, vec3 n) {\n\treturn dot(r - o, n);\n}\n\nfloat box(vec3 r, vec3 a)\n{\n\tr.x += sin(r.y * PI) * 0.1;\n\tvec3 p = abs(r) - a * (sin(length(abs(abs(r)*4. - 2.) * 8.)) + 2.);\n\treturn length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat shade(vec3 n, vec3 rd)\n{\n\treturn clamp(max(dot(n, -rd), 0.) + 1., 0., 1.);\n}\n\nvec3 fog(float z, vec3 col, vec3 fogCol)\n{\n\treturn mix(fogCol, col, exp(-z));\n}\n\nmat3 obj;\n\nvec4 map(vec3 r)\n{\n\tobj = mat3(\n\t\tcos(sin(-t + r.z * 0.2) * 0.31), -sin(sin(-t+r.z * 0.2) * 0.51), 0., \n\t\tsin(sin(-t + r.z * 0.2) * 0.41), cos(sin(-t+r.z * 0.2) * 0.51), 0.,\n\t\t0., 0., 1.\n\t);\n\t\n\tfloat z = r.z;\n\t\n\tvec4 s0 = vec4(\n\t\tvec3(0.0, 0.8, 0.) * 0.8,\n\t\tbat(mat3(3.) * (obj * mod(r + 1. - vec3(cos(t*2. * 0.785 + z) * 0.5+ 0.5, sin(t*2. * 0.785 + z) * 0.25, t) + 0.45, 4.) - 1.), 1.3)\n\t);\n\tvec4 b1 = vec4(\n\t\tvec3(0.3, 0.1, 2.3) * 0.12,\n\t\tbox((mod(r + 3.0, 4.) - 1.0), vec3(0.1, 4., 0.1))\n\t);\n\t\n\treturn minx(s0, b1);\n}\n\nfloat hash(vec2 r) {\n\treturn fract(sin(dot(r, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tt = iTime;\n\t\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv -= 0.5;\n\tuv.x *= iResolution.x / iResolution.y;\n\t\n\tmat3 cam = mat3(\n\t\tcos(sin(t) * 0.1), -sin(sin(t) * 0.1), 0., \n\t\tsin(sin(t) * 0.1), cos(sin(t) * 0.1), 0.,\n\t\t0., 0., 1.\n\t) * mat3(\n\t\t1., 0., 0.,\n\t\t0., cos(0.15), -sin(0.15), \n\t\t0., sin(0.15), cos(0.15)\n\t);\n\t\t\n\tvec3 ro = vec3(0., - 0.5, - 1.0 + t);\n\tvec3 rd = cam * normalize(vec3(uv, -1.));\n\tvec3 r = ro;\n\t\n\tvec4 col = vec4(1.);\n\tvec3 bcol = vec3(1., 0.0, 0.2) + 0.0;\n\t\n\tvec4 c = vec4(bcol, 1.);\n\t\n\tfloat sh = 1.;\n\t\n\tfloat rs = 0.;\n\t\n\tfor (int i = 0; i < MAXIT; ++i) {\n\t\tvec4 d = map(r);\n\t\tfloat z = length(r - ro);\n\t\t\n\t\tvec4 nc = minx(c, d);\n\t\tc.rgb = mix(nc.rgb, c.rgb, nc.w / c.w);\n\t\tc.w = nc.w;\n\t\t\n\t\tif (d.w < EPSILON) {\n\t\t\tcol.rgb = d.rgb * shade(normalize(r), rd);\n\t\t\tcol.rgb = d.rgb;\n\t\t\tcol.rgb = fog(z * 0.1, col.rgb, bcol);\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\td.w *= 0.7 - 0.1 * hash(uv);\n\t\tr += rd * clamp(d.w, -0.5, 0.5) * 0.7;\n\t\t\n\t\tsh += (float(i) / float(MAXIT));\n\t}\n\t\n\tcol.rgb *= exp(-sh * sh * 0.02);\n\t\n\tif (c.w > EPSILON) {\n\t\tcol.rgb = fog(c.w, c.rgb, bcol * 0.1) * 0.2;\n\t}\n\t\n\tfragColor = vec4(col.rgb, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslcWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[168, 168, 199, 199, 224], [226, 226, 254, 254, 582], [584, 584, 621, 621, 646], [648, 648, 675, 675, 838], [840, 840, 870, 870, 922], [924, 924, 966, 966, 1003], [1016, 1016, 1034, 1034, 1537], [1539, 1539, 1559, 1559, 1625]], "test": "untested"}
{"id": "WslyDl", "name": "[TWITCH] Energy Confinement", "author": "evvvvil", "description": "Energy Confinement - Result of improvised live code session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["demoscene", "space", "spline", "beam", "glow", "alien", "vortex", "scifi", "pyramid", "tentacle", "inside", "structure", "industrial", "twitch", "improv"], "likes": 22, "viewed": 1338, "published": 3, "date": "1585850306", "time_retrieved": "2024-07-30T21:15:14.547033", "image_code": "// Energy Confinement - Result of an improvised live code session on Twitch\n\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\n// https://www.twitch.tv/evvvvil_\n\n// \"Seven continents in the shit, smoking like it's fuckin London\" - EL-P\n\nvec2 z,v,e=vec2(.00035,-.00035); float t,tt,b,bb,g,grow,gg,ps;vec3 pp,np,cp,xp,po,no,al,ld;//global vars. \nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);} //box primitive function. \nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));} //rotate function. \nfloat octa( vec3 p, float s){  p = abs(p); return (p.x+p.y+p.z-s)*0.57735027;} //dumb octagone function. Clearly not as cool as Dr Octagon, but then nobody really is...\nvec2 fb( vec3 p,float s, float f,float gs) // fb \"fucking bit\" function make a base geometry which we use to make weird spliune network\n{ //I will comment all this shit later...\n  b=sin(p.y*.2+1.57)+sin(p.y+tt*5.)*.15;\n  vec2 h,t=vec2(length(p.xz)-(1.+b),5);\n  t.x=min(length(abs(p.xz)-(1.+b)*.7)-(.2+b*.2),t.x);\n  pp=p; pp.y=mod(p.y,1.)-0.5;\n  h=vec2(length(pp.xy)-(.2),3);\n  h.x=max(h.x,length(p.xz)-(1.2+b));\n  t=t.x<h.x?t:h;\n  t.x=max(abs(t.x)-.2,-bo(p+vec3(0,0,0),vec3(3,s,3)));  \n  h=vec2(length(p.xz)-(1.1+b),6);\n  t=t.x<h.x?t:h;\n  t.x=max(abs(t.x)-.05,-bo(p,vec3(3,s-.5,3)));  \n  h=vec2(length(p.xz)-(.1+b*.3*f),6);\n  h.x=max(h.x,bo(p,vec3(3,12.3,3)));  \n  g+=0.2/(0.1+(h.x/gs)*(h.x/gs)*(80.-sin(p.y*.3-tt*3.)*79.));  \n  t=t.x<h.x?t:h;  \n  pp=p; pp.xz*=r2(sin(p.y*.3+tt));\n  h=vec2(length(abs(pp.xz)-(1.+b)*.2+sin(p.y*.3)*.2)-(.2*f),6);  \n  t=t.x<h.x?t:h;  \n  h=vec2(length(abs(pp.xz)-(1.+b)*.5+sin(p.y*.3)*.2)-((1.+b*2.)*.05)*f,3);  \n  t=t.x<h.x?t:h; \n  t.x*=0.7;return t;\n}\nvec2 pyra(vec3 p,float s,float of,float m,float o){  \n  p*=(1.-grow*.1);\n  pp=p;pp.xz*=r2(.785); \n  vec2 h,t=vec2(octa(pp+vec3(0,grow*15.,0),s),m); //PYRA TOP  \n  t.x=max(abs(t.x)-o,p.y+grow*15.+of);    \n  h=vec2(octa(pp+vec3(0,-grow*15.,0),s),m); //PYRA BOTTOM\n  h.x=max(abs(h.x)-o,-p.y+grow*15.+of);  \n  t=t.x<h.x?t:h;\n  t.x=max(t.x,-(length(p.xz)-5.)); //CYLINDER CUT\n  if(s>24.) {\n    pp=abs(abs(abs(p)-vec3(0,8.+grow*15.,0))-vec3(0,2,0))-vec3(0,1,0);\n    t.x=max(t.x,-bo(pp,vec3(20,.3,20))); //THIN RECTANGLE CUT\n  }else{\n    gg+=0.15/(0.1+t.x*t.x*(20.-abs(sin(p.y*.2-tt*3.))*19.));//GLOW ONLY THE INSIDE PYRAMID\n  } return t;\n}\nvec2 mp( vec3 p )\n{ \n  bb=cos(p.y*.1);  ps=(1.-grow*.4);\n  cp=p*ps;cp.xz*=r2(grow*10.+sin(p.y*.05));    \n  np=cp;  np.xz*=r2(.785);  np.xz=abs(np.xz);  \n  np.xz-=(2.5+bb*4.*grow);\n  vec2 h,t=fb(np,4.5,1.,1.); h.x/=ps; //TWIRLS MIDDLE 4\n  h=fb(p*.42,2.,1.,.42); h.x/=.42; //TWIRLS MIDDLE SMALL\n  t=t.x<h.x?t:h; \n  h=fb(p*.105,2.+grow*8.,0.,.35); h.x*=6.; //TWIRLS HUGE\n  t=t.x<h.x?t:h; \n  h=fb(abs(p*.7)-(15.+grow*7.+bb*2.,11.,15.+grow*7.+bb*2.),2.,1.,.7); h.x/=.7; //TWIRLS outter 4\n  xp=p; t=t.x<h.x?t:h; \n  pp=cp;pp.xz=abs(pp.xz)-vec2(5.+bb*6.,5.+bb*6.)*grow;\n  h=fb(pp*.6,4.5,1.,.6); h.x/=(.7*ps); t=t.x<h.x?t:h;  //TWIRLS BIG 4\n  h=vec2(.9*length(cos(abs(p*.4)-vec3(0.,tt*4.+grow*10.,0.)+np*.04)),6); //PARTICLES\n  h.x=max(h.x,length(p.xz)-(14.+bb*3.+grow*6.));\n  gg+=0.1/(0.1+h.x*h.x*100.); t=t.x<h.x?t:h; \n  bb=15.+grow*18.;\n  h=vec2(bo(p,vec3(bb,10.,bb)),6); //ROAD WHITE  \n  h.x=max(abs(h.x)-2.5,bo(p,vec3(bb+.5,.5,bb+.5)));\n  gg+=0.1/(0.1+h.x*h.x*50.); t=t.x<h.x?t:h;  \n  h=vec2(bo(p,vec3(bb-1.,10.,bb-1.)),3); //ROAD BLACK\n  h.x=max(abs(abs(h.x)-.6)-.3,bo(p,vec3(bb,.7,bb)));\n  t=t.x<h.x?t:h;  \n  h=pyra(p,25.,0.,3.,1.); t=t.x<h.x?t:h; //OUTTER PYRA BLACK\n  h=pyra(p,24.,1.,6.,0.2); t=t.x<h.x?t:h;  //INNER PYRA BLUE\n  return t;// Add central structure and return the whole shit\n}\nvec2 tr( vec3 ro, vec3 rd ) // main trace / raycast / raymarching loop function \n{\n  vec2 h,t= vec2(.1); //Near plane because when it all started the hipsters still lived in Norwich and they only wore tweed.\n  for(int i=0;i<128;i++){ //Main loop de loop \n    h=mp(ro+rd*t.x); //Marching forward like any good fascist army: without any care for culture theft. (get distance to geom)\n    if(h.x<.0001||t.x>250.) break; //Conditional break we hit something or gone too far. Don't let the bastards break you down!\n    t.x+=h.x;t.y=h.y; //Huge step forward and remember material id. Let me hold the bottle of gin while you count the colours.\n  }\n  if(t.x>250.) t.y=0.;//If we've gone too far then we stop, you know, like Alexander The Great did when he realised his wife was sexting some Turkish bloke. (10 points whoever gets the reference)\n  return t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )//2 lines above are a = ambient occlusion and s = sub surface scattering\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //get UVs, nothing fancy, \n  tt=mod(5.+iTime*.5,31.41); //Time variable, modulo'ed to avoid ugly artifact. Imagine moduloing your timeline, you would become a cry baby straight after dying a bitter old man. Christ, that's some fucking life you've lived, Steve.\n  grow=smoothstep(0.,1.,.5+.5*sin(tt));\n  vec3 ro=mix(vec3(1),vec3(-1.2,-2,1),ceil(sin(tt)))*vec3(cos(tt*.2+.2)*38.,5,sin(tt*.2)*38.),//Ro=ray origin=camera position We build camera right here broski. Gotta be able to see, to peep through the keyhole.\n  cw=normalize(vec3(0)-ro), cu=normalize(cross(cw,vec3((sin(grow*.2))*2.,1,0))),cv=normalize(cross(cu,cw)),\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5+grow*.1)),lp=vec3(0,0,0)-ro,co,fo;//rd=ray direction (where the camera is pointing), co=final color, fo=fog color\n  ld=normalize(vec3(1,5,0)), //ld=light direction\n  co=fo=vec3(.15)-length(uv*1.1)*.15-rd.y*vec3(.05,.05,.1);//background is dark blueish with vignette and subtle vertical gradient based on ray direction y axis. \n  z=tr(ro,rd);t=z.x; //Trace the trace in the loop de loop. Sow those fucking ray seeds and reap them fucking pixels.\n  if(z.y>0.){ //Yeah we hit something, unlike you at your best man speech.\n    po=ro+rd*t; //Get ray pos, know where you at, be where you is.\n    no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x); //Make some fucking normals. You do the maths while I count how many instances of Holly Willoughby there really is.\n    al=mix(vec3(0.7,0.05,.0),vec3(.8,.2,.0),.5+.5*sin(xp*.3)); //al=albedo=base color, by default it's a gradient between red and orange. \n    if(z.y<5.) al=vec3(0); //material ID < 5 makes it black\n    if(z.y>5.) al=vec3(1); //material ID > 5 makes it white\n    float dif=max(0.,dot(no,ld)), //Dumb as fuck diffuse lighting\n    attn=1.-pow(min(1.,length(lp-po)/(20.+grow*70.)),4.),\n    fr=pow(1.+dot(no,rd),4.), //Fr=fresnel which adds background reflections on edges to composite geometry better\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),30.); //Sp=specular, stolen from Shane\n    co=attn*mix(sp+al*(a(.1)*a(.3)+.2)*(dif+s(2.)),fo,min(fr,.2)); //Building the final lighting result, compressing the fuck outta everything above into an RGB shit sandwich\n    co=mix(fo,co,exp(-.000005*t*t*t));//Fog soften things, but it won't stop your mother from being unimpressed by your current girlfriend\n  } ps=.07+.13*grow;\n  fragColor = vec4(pow(co+gg*ps*mix(vec3(0.1,0.2,.4),vec3(.1,.3,.6),.5+.5*sin(xp*.3))+g*ps*mix(vec3(0.7,0.05,.0),vec3(.8,.2,.0),.5+.5*sin(xp*.3)),vec3(.55)),1);// Naive gamma correction and glow applied at the end. Glow switches from blue to red hues - nice idea by Haptix - cheers broski\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WslyDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[354, 370, 394, 394, 435], [436, 463, 480, 480, 523], [524, 544, 573, 573, 622], [623, 713, 850, 890, 1696], [1697, 1697, 1748, 1748, 2330], [2331, 2331, 2350, 2350, 3621], [3622, 3622, 3704, 3704, 4472], [4562, 4562, 4691, 4691, 7447]], "test": "untested"}
{"id": "3dlcDl", "name": "Simple Dartboard", "author": "roberthoenig", "description": "A black-and-white dartboard on gray background.", "tags": ["dartboard"], "likes": 1, "viewed": 336, "published": 3, "date": "1585849885", "time_retrieved": "2024-07-30T21:15:15.293038", "image_code": "#define M_PI 3.1415927\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy,\n        uv = (2.*U - R ) / R.y;\n    float ring = sin (3.14* length(uv)                     *8.),\n      rotation = sin((3.14*(atan(uv.y/uv.x)+M_PI/2.0)/M_PI)*8.);\n\n    O = vec4 ( mix(ring * rotation / fwidth(ring * rotation), .5, 1./(exp(-1000.*(length(uv)-1.))+1.)) );  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlcDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 62, 62, 364]], "test": "untested"}
{"id": "3dlcWl", "name": "30 torus", "author": "XT95", "description": "Pouet", "tags": ["torus", "neon", "demostyle"], "likes": 75, "viewed": 1657, "published": 3, "date": "1585841211", "time_retrieved": "2024-07-30T21:15:16.107859", "image_code": "// helpers\nfloat hash(float s) { return fract(sin(s)*42422.42); }\nmat2 rot(float v) { float a = cos(v), b = sin(v); return mat2(a,b,-b,a); }\nfloat torus(vec3 p, vec2 q) { return length( vec2(length(p.xz)-q.x,p.y) ) - q.y; } \n\n// global + params\n#define att 15.\nfloat time;\nfloat id;\nvec3 glow;\n\n// distance function\nfloat map( vec3 p ) {\n    // rotate the world\n\tp.xy *= rot(time*.1);\n\tp.xz *= rot(time*.2);\n    \n    // small point light on the center\n\tfloat d =  length(p);\n\tglow += vec3(1.) / ( .1 + d*200.);\n    \n    // 30 torus\n\tfloat s = .25;\n\tfor(int i=0; i<30; i++) {\n    \ts += .25;\n    \tp.xy *= rot(time*.05);\n    \tp.xz *= rot(time*.1);\n        \n    \tfloat d2 = torus(p,vec2(s, 0.14));\n        \n        // we accumulate the lighting here\n    \tfloat intensity = 1. / ( 1. + pow(abs(d2*att),1.3));\n    \tif(i == 6 && id == 0.) {\n    \t\tglow += vec3(1.,.3,1.) * intensity;\n    \t} else if(i == 15 && id == 1.) {\n      \t\tglow += vec3(1.,1.,.1) * intensity;\n    \t} else if(i == 20 && id == 2.) {\n      \t\tglow += vec3(.1,1.,.1) * intensity;\n    \t} else if(i == 25 && id == 3.) {\n      \t\tglow += vec3(.1,1.,1.) * intensity;\n    \t}\n        \n    \td = min(d, d2);\n\t}\n\treturn d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ttime = iTime + 10.;\n    \n    // uv stuff\n    vec2 uv = fragCoord/iResolution.xy;\n  \tvec2 v = uv*2.-1.;\n  \tv.x /= iResolution.y / iResolution.x;\n\n    // which torus is on ?\n\tid = floor(hash(floor(iTime*5.*hash(floor(time*.2))))*5.);\n    \n    // ray setup\n  \tvec3 ro = vec3(0.,0.,-10.);\n  \tvec3 rd = normalize(vec3(v, 1.));\n\n\n    // raymarching by distance field\n  \tvec3 p = ro+rd ;\n  \tglow = vec3(0.);\n  \tfor(int i=0; i<32; i++) {\n    \tp += rd * map(p);\n  \t}\n    \n    // glow + vignetting + gamma correction\n  \tvec3 col = glow;\n  \tcol *= pow(uv.x*uv.y*(1.-uv.x)*(1.-uv.y), .8)*2.;\n  \tcol = pow(col,vec3(1./2.2));\n    \n  \tfragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlcWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 11, 32, 32, 65], [66, 66, 85, 85, 140], [141, 141, 170, 170, 223], [295, 316, 337, 361, 1174], [1178, 1178, 1235, 1235, 1884]], "test": "untested"}
{"id": "tsXyWs", "name": "Compound of Five Tetrahedra", "author": "mla", "description": "Took a while to work out chiral forms for the \"excavated dodecahedra\" from yesterday - turns out, there is fundamentally only one set of planes that fit together coherently to make a chiral form, and they make the compound of five tetrahedra.", "tags": ["tetrahedra", "dodecahedra", "excavated"], "likes": 12, "viewed": 386, "published": 3, "date": "1585839031", "time_retrieved": "2024-07-30T21:15:16.899742", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Compound of Five Tetrahedra as Excavated Dodecahedron\n//\n// Matthew Arcus, 2020\n//\n// Take an icosahedral kaleidoscope (using precalculated values), and\n// take slices through the fundamental region with planes through the\n// vertices of a dodecahedron. The result is a great range of shapes -\n// stellations, facetings and other more irregular but pretty shapes.\n//\n// Here we see the compound of five tetrahedra as a chiral excavation.\n//\n// <mouse>: rotation\n// <up>/<down>: move in/out\n// c: clip at x=0\n// r: autorotation\n// \n//\n////////////////////////////////////////////////////////////////////////////////\n\nbool dorotate = true;\nbool doclip = false;\nconst float PI\t= 3.14159265359;\nint NFOLDS = 5;\nbool alert = false;\n\nbool dosubtract = false;\n\nvoid assert(bool test) {\n  if (!test) alert = true;\n}\n\n// Face plane normals, dot(A,B) = -cos(PI/P) etc.\nvec3 A = vec3(1,0,0);\nvec3 B = vec3(-0.5,0.866025,0);\nvec3 C = vec3(-0.809017,-0.467086,0.356822);\n\n// Unit length vertices of fundamental trihedron\nvec3 a = vec3(0.309017,0.178411,0.934172);\nvec3 b = vec3(0,0.607062,0.794654);\nvec3 c = vec3(0,0,1);\n\nvec3 vertices[20] =\n  vec3[](vec3(0,0,1), // 0\n\n         vec3(0.57735,0.333333,0.745356), // 0.713644\n         vec3(0,-0.666667,0.745356), // 0.713644\n         vec3(-0.57735,0.333333,0.745356), // 0.713644\n\n         vec3(0.356822,0.872678,0.333333), // 1.1547\n         vec3(0.934172,-0.127322,0.333333), // 1.1547\n         vec3(0.57735,-0.745356,0.333333), // 1.1547\n         vec3(-0.577351,-0.745356,0.333333), // 1.1547\n         vec3(-0.934172,-0.127322,0.333333), // 1.1547\n         vec3(-0.356822,0.872678,0.333333), // 1.1547\n\n         vec3(0.57735,0.745356,-0.333334), // 1.63299\n         vec3(0.934172,0.127322,-0.333334), // 1.63299\n         vec3(0.356822,-0.872678,-0.333334), // 1.63299\n         vec3(-0.356822,-0.872678,-0.333334), // 1.63299\n         vec3(-0.934172,0.127322,-0.333334), // 1.63299\n         vec3(-0.57735,0.745356,-0.333334), // 1.63299\n\n         vec3(0,0.666666,-0.745356), // 1.86834\n         vec3(0.57735,-0.333334,-0.745356), // 1.86834\n         vec3(-0.57735,-0.333334,-0.745356), // 1.86834\n         vec3(0,0,-1) // 2\n         );\n\n// Could use an ivec3 and count different types of flip\nvec3 fold(vec3 pos, out int flips) {\n  // We want to know the number of actual reflections made\n  // so keep track of that in flips.\n  flips = 0;\n  for (int i = 0; i < NFOLDS; i++) {\n    float k;\n    k = dot(pos,A);\n    if (k < 0.0) {\n      flips += 1;\n      pos -= 2.0*k*A;\n    }\n    k = dot(pos,B);\n    if (k < 0.0) {\n      flips += 1;\n      pos -= 2.0*k*B;\n    }\n    k = dot(pos,C);\n    if (k < 0.0) {\n      flips += 1;\n      pos -= 2.0*k*C;\n    }\n  }\n  return pos;\n}\n\n// Perpendicular distance from p to segment ab\nfloat segment(vec3 p, vec3 a, vec3 b) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  float d = length(pa - ba * h);\n  return d;\n}\n\nvec4 makeplane(vec3 p, vec3 q, vec3 r) {\n  // dot(vec4(s,1),makeplane(p,q,r)) gives distance from plane\n  vec3 n = cross(q-p,r-p);\n  n = normalize(n);\n  float k = -dot(p,n);\n  // Fix so that away from origin is +ve distance\n  // If k is 0, then plane through origin & the order of p,q,r\n  // determine +ve direction (how?)\n  if (k > 0.0) { k = -k; n = -n; }\n  return vec4(n,k);\n}\n\nvoid mindistance(float d, int t, inout float dmin, inout int type) {\n  if (d < dmin) { dmin = d; type = t; }\n}\nvoid maxdistance(float d, inout float dmax) {\n  if (d > dmax) { dmax = d; }\n}\nvoid triangle(vec3 p0, vec3 p, vec3 q, vec3 r, float radius, int t, inout float dmin, inout int type) {\n  mindistance(segment(p0,p,q)-radius,t,dmin,type);\n  mindistance(segment(p0,q,r)-radius,t,dmin,type);\n  mindistance(segment(p0,r,p)-radius,t,dmin,type);\n}\n\nfloat cradius = 0.1; // Sphere at origin\nfloat pradius = 0.05; // Sphere at main vertex\nfloat rradius = 0.03; // Sphere at other region vertices\nfloat sradius = 0.01;\n\n// The achiral scene.\nfloat scene1(vec3 p, inout int type, inout float d) {\n  vec3 a1 = a*dot(a,c);\n  vec3 b1 = b*dot(b,c);\n  vec3 c1 = c;\n  vec3 O = vec3(0);\n\n  // Always draw the dodecahedron vertices\n    float k = 1.0 + pradius;\n  mindistance(length(p-k*c) - pradius,0,d,type);\n  if (true) {\n    // Dodecahedron edges\n    mindistance(segment(p,k*c,reflect(k*c,C))-0.03,1,d,type);\n  }\n  return d;\n}\n\n// The chiral scene. There is only one set of planes that can be split\n// up into coherent chiral parts, that in fact form the compound of\n// five tetrahedra.\nfloat scene0(vec3 p, inout int type, inout float d) {\n  float d1 = -1e8;\n  maxdistance(dot(vec4(p,1),makeplane(vertices[0],vertices[14],vertices[10])),d1);\n  maxdistance(dot(vec4(p,1),makeplane(vertices[0],vertices[12],vertices[10])),d1);\n  if (d1 < d) { d = d1; type = 3; }\n  return d;\n}\n\nfloat scene(vec3 p0, out vec2 uv, out int type) {\n  type = 0;\n  int flips = 0;\n  float d = 1e8;\n  vec3 p = fold(p0,flips);\n  uv = p.xy;\n  if (flips%2 == 0) {\n    scene0(p,type,d);\n  } else {\n    scene0(reflect(p,A),type,d);\n    scene0(reflect(p,B),type,d);\n    scene0(reflect(p,C),type,d);\n  }\n  scene1(p,type,d);\n  assert(type >= 0 && type <= 3);\n  if (doclip && p0.x > d) {\n    d = p0.x;\n  }\n  //if (type == 0 && distance(p0,c) < 0.2) type = 4;\n  //return max(d,dot(p,b)-dot(b,c)); // Clip to dodecahedron\n  return d;\n}\n\nvoid getcolor(int type, vec2 uv, out vec3 color, out float specularity) {\n  specularity = 0.3;\n  color = vec3(1,0,1);\n  if (type == 0) { color = vec3(0.3,0.1,0.1); specularity = 0.0; }\n  if (type == 1) color = vec3(0.8,0.8,0.5);\n  if (type == 2) color = vec3(0.5,0.5,0);\n  if (type == 3) { color = texture(iChannel2,uv).rgb; specularity = 0.0; }\n}  \n\nfloat map(vec3 p) {\n  int type; vec2 uv;\n  return scene(p,uv,type);\n}\n\nvec3 calcnormal(vec3 p) {\n  const vec2 e = vec2(0.001, 0.0);\n  vec3 n = vec3(map(p + e.xyy) - map(p - e.xyy),\n                map(p + e.yxy) - map(p - e.yxy),\n                map(p + e.yyx) - map(p - e.yyx));\n  return normalize(n);\n}\n\nfloat march(in vec3 ro, in vec3 rd) {\n  float maxd = length(ro) + 1.0;\n  float precis = 0.001;\n  float t = 0.0;\n  float res = -1.0;\n  for (int i = 0; i < 100; i++) {\n    //assert(i < 20);\n    float h = map(ro+rd*t);\n    if (abs(h) < precis) return t;\n    t += h;\n    if (t < 0.0 || t > maxd) break;\n  }\n  return -1.0;\n}\n\n//-------------------------------------------------\n//From https://www.shadertoy.com/view/XtXGRS#\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (dorotate) {\n    p.yz = rotate(p.yz,iTime * 0.125);\n    p.zx = rotate(p.zx,iTime * 0.2);\n  }\n  return p;\n}\n\nbool keypress(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\n\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\nconst int CHAR_C = 67;\nconst int CHAR_N = 78;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  dorotate = !keypress(CHAR_R);\n  doclip = keypress(CHAR_C);\n  dosubtract = keypress(CHAR_S);\n  bool dotexture = keypress(CHAR_T);\n  bool calcnormals = !keypress(CHAR_N);\n  vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec3 col = vec3(0.1 - 0.1*p.y);\n  float camera = 2.5;\n  camera *= 1.0 + 0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP));\n  vec3 ro = vec3(0.0, 0.0, camera);\n  vec3 rd = vec3(p, -2.0);\n  vec3 light = normalize(vec3(0.5, 1.0, 3.0));\n  ro = transform(ro);\n  rd = transform(rd);\n  light = transform(light);\n  rd = normalize(rd);\n  float t = march(ro, rd);\n  if (t > 0.0) {\n    vec3 pos = ro + t * rd;\n    int type;\n    vec2 uv;\n    scene(pos,uv,type);\n    vec3 n = calcnormal(pos);\n    //assert(dot(n,rd) <= 0.0);\n    float specularity = 0.0;\n    getcolor(type,uv,col,specularity);\n    float diffuse = clamp(dot(n, light), 0.0, 1.0);\n    col *= 0.2+0.8*diffuse;\n    float specular = pow(max(0.0,dot(reflect(light,n),rd)),50.0);\n    col += specularity*specular*vec3(1);\n  }\n  col = pow(col, vec3(0.4545));\n  if (alert) col.x = 1.0;\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0) {\n      t = vec4(0);\n    } else {\n      t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXyWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[841, 841, 865, 865, 894], [2262, 2318, 2354, 2450, 2788], [2790, 2837, 2876, 2876, 3017], [3019, 3019, 3059, 3122, 3398], [3400, 3400, 3468, 3468, 3510], [3511, 3511, 3556, 3556, 3588], [3589, 3589, 3692, 3692, 3847], [4017, 4039, 4092, 4092, 4417], [4419, 4578, 4631, 4631, 4866], [4868, 4868, 4917, 4917, 5389], [5391, 5391, 5464, 5464, 5738], [5742, 5742, 5761, 5761, 5811], [5813, 5813, 5838, 5838, 6046], [6048, 6048, 6085, 6085, 6367], [6369, 6467, 6503, 6503, 6555], [6557, 6557, 6584, 6584, 6913], [6915, 6915, 6940, 6940, 7000], [7002, 7002, 7027, 7027, 7075], [7077, 7077, 7100, 7100, 7132], [7298, 7298, 7355, 7355, 8443]], "test": "untested"}
{"id": "wslyzS", "name": "Baby Duck", "author": "GabrielFelix", "description": "an image of a duck", "tags": ["begginer", "animals"], "likes": 1, "viewed": 299, "published": 3, "date": "1585838173", "time_retrieved": "2024-07-30T21:15:17.657716", "image_code": "\nvec3 Circle(vec2 uv, vec2 position, float radius, float blurAmount, vec3 color){\n    \n    float distance = length(uv - position);\n    \n    float result = smoothstep(radius, radius - blurAmount, distance);\n    \n    return result * color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    ////Vertical Movement\n    float walkingSpeed = 2.;\n    float yOffset = .9;\n    float yStepHeight = 2.;\n    \n    float yMovement = cos( cos(iTime * walkingSpeed) / yStepHeight);\n    yMovement -= yOffset;\n    \n    \n    ////Horitontal Movement\n    float xMovement = tan(iTime);\n    \n\n     \n    ////Drawing Circles\n    //head\n    vec3 result = Circle(uv , vec2(.1 - xMovement, .0 - yMovement) , .3 , 0.01, vec3(1.0, 1.0, 1.0));\n    \n     //beak\n    result += Circle(uv , vec2(-.225 - xMovement, .05 - yMovement) , .1 , 0.01, vec3(1.0, .5, 0.));\n    \n     //eye\n    result -= Circle(uv , vec2(-.03 - xMovement, .05 - yMovement) , .1 , 0.01, vec3(1., 1., 1.));\n    \n     //body\n    result += Circle(uv , vec2(.4 - xMovement, -.6 - yMovement) , .5 , 0.01, vec3(1.0, 1.0, 1.0));\n    \n    \n    \n   \n    ////Output to screen\n    fragColor = vec4(result ,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslyzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 81, 81, 239], [242, 242, 299, 348, 1308]], "test": "untested"}
{"id": "wsfyDs", "name": "Amiga Balls", "author": "dr2", "description": "The Amiga and its ever-present ball", "tags": ["amiga", "bounce", "recursion", "computer"], "likes": 17, "viewed": 484, "published": 3, "date": "1585835552", "time_retrieved": "2024-07-30T21:15:18.594212", "image_code": "// \"Amiga Balls\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// The Amiga and its ever-present ball\n\n// The Amiga was the best graphics PC when it first appeared.\n\n#define AA   1   // optional antialiasing\n\n#define GURU 0   // optional guru meditation message\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvoid PxInit ();\nvoid PxBgn (vec2 p);\nfloat PxText (vec2 p, int txt);\nfloat PxChar (vec2 p, vec4 c);\n\nmat3 vuMat;\nvec3 ltDir, bPos;\nvec2 sSize, cSpace;\nfloat dstFar, tCur, sMidHt;\nint idObj, nRec;\nconst int nRecMax = 6;\nconst float pi = 3.14159;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, h;\n  dMin = dstFar;\n  q = p;\n  q.y -= 0.35;\n  d = PrRoundBoxDf (q, vec3 (1., 0.16, 0.7), 0.01);\n  q = p - vec3 (0.7, 0.4, -0.72);\n  d = max (d, - PrBoxDf (q, vec3 (0.17, 0.01, 0.2)));\n  q.y -= -0.02;\n  d = max (d, - PrBoxDf (q, vec3 (0.08, 0.08, 0.03)));\n  q.y -= 0.01;\n  d = max (d, - PrBoxDf (q, vec3 (0.045, 0.05, 0.05)));\n  q = p;\n  q.yz -= vec2 (0.3, -0.72);\n  d = max (d, - PrBoxDf (q, vec3 (1.1, 0.01, 0.03)));\n  q = p;\n  q.x = abs (q.x) - 0.4;\n  q.yz -= vec2 (0.35, -0.72);\n  d = max (d, - PrBoxDf (q, vec3 (0.01, 0.17, 0.03)));\n  q = p;\n  q.x = abs (q.x) - 1.;\n  q.yz -= vec2 (0.35, 0.05);\n  d = max (d, - PrBoxDf (q, vec3 (0.02, 0.007, 0.7)));\n  DMIN (1);\n  q = p;\n  q.x = abs (q.x) - 0.95;\n  q.y -= 0.09;\n  q.x -= 0.02 * q.y;\n  d = PrRoundBoxDf (q, vec3 (0.025 + 0.02 * q.y, 0.09, 0.6), 0.005);\n  q = p;\n  q -= vec3 (-0.05, 0.09, 0.3);\n  d = min (d, PrRoundBoxDf (q, vec3 (0.9, 0.09, 0.02), 0.005));\n  DMIN (2);\n  q = p;\n  q.yz -= vec2 (0.55, 0.05);\n  q.xz = abs (q.xz) - vec2 (0.55, 0.4);\n  d = PrCylDf (q.xzy, 0.05, 0.05);\n  DMIN (3);\n  q = p;\n  q.yz -= vec2 (0.71 + sSize.y, -0.45);\n  d = 0.9 * max (PrRoundBoxDf (q, vec3 (sSize.x + 0.16, sSize.y + 0.12, 0.13), 0.03),\n     - PrRoundBox2Df (q.xy, sSize + 0.01, 0.03));\n  DMIN (4);\n  q = p - vec3 (0.7, 0.4, -0.55);\n  d = PrBoxDf (q, vec3 (0.16, 0.008, 0.16));\n  DMIN (5);\n  q = p;\n  h = sSize.y + 0.05 - 0.1 * (q.z - 0.05);\n  q.yz -= vec2 (0.6 + h, 0.05);\n  d = 0.9 * PrRoundBoxDf (q, vec3 (sSize.x + 0.12, h, 0.6), 0.03);\n  DMIN (6);\n  q = p;\n  q.x = mod (q.x + 1., 2.) - 1.;\n  q -= bPos;\n  d = PrSphDf (q, 0.2);\n  DMIN (11);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = VAR_ZERO; j < 8; j ++) {\n    d = float (j + 1) / 16.;\n    ao += max (0., d - 3. * ObjDf (ro + d * rd));\n  }\n  return 0.4 + 0.6 * clamp (1. - 0.2 * ao, 0., 1.);\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  vec2 q;\n  float d;\n  if (rd.y >= 0.) col = vec3 (0.1, 0.2, 0.3) + 0.2 * pow (1. - rd.y, 5.);\n  else {\n    d = - ro.y / rd.y;\n    q = ro.xz + d * rd.xz;\n    col = mix (mix (vec3 (0.3, 0.1, 0.), vec3 (0.4, 0.2, 0.), smoothstep (0.4, 0.6, Fbm2 (q * vec2 (1., 4.)))),\n       vec3 (0.3, 0.4, 0.5), 1. - min (1., exp2 (2. - 8. * d / dstFar)));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro)\n{\n  vec4 col4;\n  vec3 col, rd, roh, vn, q;\n  vec2 sb, a;\n  float dstObj, ao;\n  bool isBg, isScrn;\n  isBg = false;\n  isScrn = true;\n  for (int k = VAR_ZERO; k <= nRecMax; k ++) {\n    rd = normalize (vec3 (ro.xy, 7.));\n    if (k == 0) ro.xy = vec2 (0.);\n    ro.z -= 20. * sSize.y;\n    rd = vuMat * rd;\n    ro = vuMat * ro;\n    ro.y += sMidHt;\n    dstObj = ObjRay (ro, rd);\n    if (dstObj >= dstFar) isBg = true;\n    else {\n      ro += dstObj * rd;\n      roh = ro;\n      if (idObj != 6) isScrn = false;\n      else {\n        ro.y -= sMidHt;\n        sb = abs (ro.xy) - sSize;\n#if GURU\n        isScrn = (max (sb.x, sb.y) < 0. && ro.z < -0.5 && k < nRec);\n#else\n        isScrn = (max (sb.x, sb.y) < 0. && ro.z < -0.5);\n#endif\n      } \n    }\n#if GURU\n    if (! isScrn || isBg || k == nRec) break;\n#else\n    if (! isScrn || isBg) break;\n#endif\n  }\n  if (isBg) {\n    col = BgCol (ro, rd);\n    if (rd.y < 0.) {\n      roh = ro - (ro.y / rd.y) * rd;\n      if (length (roh.xz) < 2.) col *= ObjAO (roh, vec3 (0., 1., 0.));\n    }\n  } else {\n    col4 = vec4 (0.8, 0.81, 0.79, 0.);\n    PxInit ();\n    if (idObj < 11) {\n      if (idObj == 1) {\n        if (ro.z < -0.65) {\n          col4.rgb *= 1.2;\n          sb = ro.xy - vec2 (-0.82, 0.42);\n          sb.x -= 0.2 * sb.y;\n          if (PxText (sb * 260., 1) > 0.) col4 = vec4 (0.1);\n          else if (PxText ((ro.xy - vec2 (-0.75, 0.21)) * 240., 2) > 0.)\n             col4 = vec4 (0.1, 0.1, 0.8, 0.3);\n          else if (abs (abs (ro.x) - 0.9) < 0.02 && abs (ro.y - 0.3) < 0.008)\n             col4 = (ro.x < 0.) ? vec4 (0., 1., 0., -1.) : ((mod (0.33 * tCur, 1.) < 0.3) ?\n             vec4 (1., 0., 0., -1.) : vec4 (0.4, 0.4, 0.4, 0.1));\n        }\n      } else if (idObj == 2) {\n        col4 *= 0.9;\n      } else if (idObj == 3) {\n        col4.rgb = vec3 (0.4, 0.3, 0.1);\n      } else if (idObj == 4) {\n        if (ro.z < -0.45) col4 *= 1.2;\n        if (ro.z < -0.6 && abs (ro.x) < sSize.x + 0.15 &&\n           abs (ro.y - sMidHt) < sSize.y + 0.11) col4 *= 0.8;\n      } else if (idObj == 5) {\n        col4.rgb = vec3 (0.1);\n      } else if (idObj == 6) {\n        if (length (ro.yz - vec2 (-0.4, -0.05)) < 0.15 &&\n           mod (ro.y + 0.4 - 0.01, 0.04) < 0.02) col4 *= 0.4;\n        else if (ro.z < -0.5) {\n          col4 = vec4 (0.1);\n#if GURU\n          sb = (ro.xy - vec2 (0., 0.6 * sSize.y)) * 340.;\n          if (PxText (sb, 0) > 0.) col4 = vec4 (1., 0., 0., -1.);\n          else if (mod (tCur, 1.) < 0.5) {\n            ro.xy = (abs (sb - vec2 (0., -1.5) * cSpace) - vec2 (29., 7.) * cSpace);\n            if (max (ro.x, ro.y) < 1.25 &&\n               (min (abs (ro.x), abs (ro.y)) < 1.25)) col4 = vec4 (1., 0., 0., -1.);\n          }\n#endif\n        }\n      }\n    }\n    if (! isScrn) {\n      if (col4.a >= 0.) {\n        vn = ObjNf (roh);\n        if (idObj < 11) vn = VaryNf (128. * roh, vn, 0.2);\n        else {\n          sb = Rot2D (vn.xy, -0.1 * pi);\n          a = sign (mod (floor (8. * vec2 (atan (sb.x, vn.z) + 0.6 * pi * tCur, asin (sb.y)) / pi), 2.) - 0.5);\n          col4 = mix (vec4 (1., 0., 0., 0.2), vec4 (0.95, 0.95, 1., 0.2), step (0., a.x * a.y));\n        }\n        ao = ObjAO (roh, vn);\n        col = ao * (col4.rgb * (0.2 + 0.1 * max (0., - dot (vn, normalize (vec3 (ltDir.xz, 0.).xzy))) +\n           0.8 * (max (0., dot (vn, ltDir)))) + col4.a * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.));\n      } else col = col4.rgb;\n    }\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ut;\n  float el, az, zmFac, sr, ds, s, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  ut = abs (uv) - vec2 (1.33, 1.);\n  if (max (ut.x, ut.y) > 0.003) col = vec3 (0.82);\n  else {\n    dstFar = 60.;\n    ltDir = normalize (vec3 (1., 3., -1.));\n    ds = SmoothBump (0.2, 0.8, 0.1, mod (0.043 * tCur, 1.));\n    az = -0.07 * pi * (2. * floor (mod (0.043 * tCur + 0.5, 2.)) - 1.) * (1. - ds);\n    el = -0.01 * pi * (1. - ds);\n    if (mPtr.z > 0.) {\n      az += pi * mPtr.x;\n      el += 0.3 * pi * mPtr.y;\n    }\n    az = clamp (az, -0.4 * pi, 0.4 * pi);\n    vuMat = StdVuMat (clamp (el, -0.4 * pi, 0.01 * pi), az);\n    sSize = 0.55 * vec2 (1.33, 1.);\n    sMidHt = 1.26;\n    nRec = int ((1. - abs (2. * mod (0.1 * tCur, 1.) - 1.)) * float (nRecMax + 1));\n    zmFac = 12. * sSize.y * ds;\n    t = mod (0.3 * tCur, 2.);\n    s = sign (2. * floor (t) - 1.);\n    t = mod (t, 1.);\n    bPos = vec3 (1.5 * s * (0.5 - t), 0.2 + 8. * t * (1. - t), -5.);\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif  \n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      col += (1. / naa) * ShowScene (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n         sr * (0.667 * a + 0.5) * pi), zmFac));\n    }\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n/*\n Text derived from 8x12 Font shader by Flyguy (Mt2GWD)\n Glyph bitmaps generated from 8x12 font sheet\n   http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n*/\n\n#define g_spc  0\n#define g_exc  1\n#define g_quo  2\n#define g_hsh  3\n#define g_dol  4\n#define g_pct  5\n#define g_amp  6\n#define g_apo  7\n#define g_lbr  8\n#define g_rbr  9\n#define g_ast 10\n#define g_crs 11\n#define g_com 12\n#define g_dsh 13\n#define g_per 14\n#define g_lsl 15\n#define g_0   16\n#define g_1   17\n#define g_2   18\n#define g_3   19\n#define g_4   20\n#define g_5   21\n#define g_6   22\n#define g_7   23\n#define g_8   24\n#define g_9   25\n#define g_col 26\n#define g_scl 27\n#define g_les 28\n#define g_equ 29\n#define g_grt 30\n#define g_que 31\n#define g_ats 32\n#define g_A   33\n#define g_B   34\n#define g_C   35\n#define g_D   36\n#define g_E   37\n#define g_F   38\n#define g_G   39\n#define g_H   40\n#define g_I   41\n#define g_J   42\n#define g_K   43\n#define g_L   44\n#define g_M   45\n#define g_N   46\n#define g_O   47\n#define g_P   48\n#define g_Q   49\n#define g_R   50\n#define g_S   51\n#define g_T   52\n#define g_U   53\n#define g_V   54\n#define g_W   55\n#define g_X   56\n#define g_Y   57\n#define g_Z   58\n#define g_lsb 59\n#define g_rsl 60\n#define g_rsb 61\n#define g_pow 62\n#define g_usc 63\n#define g_a   64\n#define g_b   65\n#define g_c   66\n#define g_d   67\n#define g_e   68\n#define g_f   69\n#define g_g   70\n#define g_h   71\n#define g_i   72\n#define g_j   73\n#define g_k   74\n#define g_l   75\n#define g_m   76\n#define g_n   77\n#define g_o   78\n#define g_p   79\n#define g_q   80\n#define g_r   81\n#define g_s   82\n#define g_t   83\n#define g_u   84\n#define g_v   85\n#define g_w   86\n#define g_x   87\n#define g_y   88\n#define g_z   89\n#define g_lpa 90\n#define g_bar 91\n#define g_rpa 92\n#define g_tid 93\n#define g_lar 94\n\n#define C(g) s += PxChar (p, glph[g]);\n\n#define _spc C(g_spc)  \n#define _exc C(g_exc)\n#define _quo C(g_quo)\n#define _hsh C(g_hsh) \n#define _dol C(g_dol) \n#define _pct C(g_pct) \n#define _amp C(g_amp) \n#define _apo C(g_apo) \n#define _lbr C(g_lbr) \n#define _rbr C(g_rbr) \n#define _ast C(g_ast) \n#define _crs C(g_crs) \n#define _com C(g_com) \n#define _dsh C(g_dsh) \n#define _per C(g_per) \n#define _lsl C(g_lsl) \n#define _0   C(g_0) \n#define _1   C(g_1) \n#define _2   C(g_2) \n#define _3   C(g_3) \n#define _4   C(g_4) \n#define _5   C(g_5) \n#define _6   C(g_6) \n#define _7   C(g_7) \n#define _8   C(g_8) \n#define _9   C(g_9) \n#define _col C(g_col) \n#define _scl C(g_scl) \n#define _les C(g_les) \n#define _equ C(g_equ) \n#define _grt C(g_grt) \n#define _que C(g_que) \n#define _ats C(g_ats) \n#define _A   C(g_A) \n#define _B   C(g_B) \n#define _C   C(g_C) \n#define _D   C(g_D) \n#define _E   C(g_E) \n#define _F   C(g_F) \n#define _G   C(g_G) \n#define _H   C(g_H) \n#define _I   C(g_I) \n#define _J   C(g_J) \n#define _K   C(g_K) \n#define _L   C(g_L) \n#define _M   C(g_M) \n#define _N   C(g_N) \n#define _O   C(g_O) \n#define _P   C(g_P) \n#define _Q   C(g_Q) \n#define _R   C(g_R) \n#define _S   C(g_S) \n#define _T   C(g_T) \n#define _U   C(g_U) \n#define _V   C(g_V) \n#define _W   C(g_W) \n#define _X   C(g_X) \n#define _Y   C(g_Y) \n#define _Z   C(g_Z) \n#define _lsb C(g_lsb) \n#define _rsl C(g_rsl) \n#define _rsb C(g_rsb) \n#define _pow C(g_pow) \n#define _usc C(g_usc) \n#define _a   C(g_a) \n#define _b   C(g_b) \n#define _c   C(g_c) \n#define _d   C(g_d) \n#define _e   C(g_e) \n#define _f   C(g_f) \n#define _g   C(g_g) \n#define _h   C(g_h) \n#define _i   C(g_i) \n#define _j   C(g_j) \n#define _k   C(g_k) \n#define _l   C(g_l) \n#define _m   C(g_m) \n#define _n   C(g_n) \n#define _o   C(g_o) \n#define _p   C(g_p) \n#define _q   C(g_q) \n#define _r   C(g_r) \n#define _s   C(g_s) \n#define _t   C(g_t) \n#define _u   C(g_u) \n#define _v   C(g_v) \n#define _w   C(g_w) \n#define _x   C(g_x) \n#define _y   C(g_y) \n#define _z   C(g_z) \n#define _lpa C(g_lpa) \n#define _bar C(g_bar) \n#define _rpa C(g_rpa) \n#define _tid C(g_tid) \n#define _lar C(g_lar) \n\nvec4 glph[95];\nvec2 cPos;\n\nfloat PxChar (vec2 p, vec4 c)\n{\n  vec2 cb;\n  float pOn, b;\n  p = floor (p - cPos);\n  if (min (p.x, p.y) >= 0. && max (p.x - 8., p.y - 12.) < 0.) {\n    b = 8. * (p.y + 1.) - (p.x + 1.);\n    if (b < 48.) cb = (b < 24.) ? vec2 (c.w, b) : vec2 (c.z, b - 24.);\n    else cb = (b < 72.) ? vec2 (c.y, b - 48.) : vec2 (c.x, b - 72.);\n    pOn = mod (floor (cb.x / exp2 (cb.y)), 2.);\n  } else pOn = 0.;\n  cPos.x += cSpace.x;\n  return pOn;\n}\n\nvoid PxBgn (vec2 p)\n{\n  cPos = floor (p * cSpace);\n}\n\nfloat PxText (vec2 p, int txt)\n{\n  float s;\n  s = 0.;\n  if (txt == 0) {\n#if GURU\n    PxBgn (- vec2 (27., -1.));\n    _S _o _f _t _w _a _r _e _spc _F _a _i _l _u _r _e _per _spc _P _r _e _s _s _spc \n    _l _e _f _t _spc _m _o _u _s _e _spc _b _u _t _t _o _n _spc _t _o _spc \n    _c _o _n _t _i _n _u _e _per\n    PxBgn (- vec2 (17., 1.));\n    _G _u _r _u _spc _M _e _d _i _t _a _t _i _o _n _spc _hsh\n    _8 _2 _0 _1 _0 _0 _0 _3 _per _D _E _A _D _B _E _E _F\n    PxBgn (- vec2 (7., 5.));\n    _B _e _w _a _r _e _exc _spc _C _O _R _O _N _A _exc _exc \n#endif\n  } else if (txt == 1) {\n    PxBgn (- vec2 (2., 0.));\n    _A _M _I _G _A\n  } else if (txt == 2) {\n    PxBgn (- vec2 (4., 0.));\n    _C _o _m _m _o _d _o _r _e\n   }\n  return s;\n}\n\nvoid PxInit ()\n{\n  glph[g_spc] = vec4 (0x000000, 0x000000, 0x000000, 0x000000);\n  glph[g_exc] = vec4 (0x003078, 0x787830, 0x300030, 0x300000);\n  glph[g_quo] = vec4 (0x006666, 0x662400, 0x000000, 0x000000);\n  glph[g_hsh] = vec4 (0x006C6C, 0xFE6C6C, 0x6CFE6C, 0x6C0000);\n  glph[g_dol] = vec4 (0x30307C, 0xC0C078, 0x0C0CF8, 0x303000);\n  glph[g_pct] = vec4 (0x000000, 0xC4CC18, 0x3060CC, 0x8C0000);\n  glph[g_amp] = vec4 (0x0070D8, 0xD870FA, 0xDECCDC, 0x760000);\n  glph[g_apo] = vec4 (0x003030, 0x306000, 0x000000, 0x000000);\n  glph[g_lbr] = vec4 (0x000C18, 0x306060, 0x603018, 0x0C0000);\n  glph[g_rbr] = vec4 (0x006030, 0x180C0C, 0x0C1830, 0x600000);\n  glph[g_ast] = vec4 (0x000000, 0x663CFF, 0x3C6600, 0x000000);\n  glph[g_crs] = vec4 (0x000000, 0x18187E, 0x181800, 0x000000);\n  glph[g_com] = vec4 (0x000000, 0x000000, 0x000038, 0x386000);\n  glph[g_dsh] = vec4 (0x000000, 0x0000FE, 0x000000, 0x000000);\n  glph[g_per] = vec4 (0x000000, 0x000000, 0x000038, 0x380000);\n  glph[g_lsl] = vec4 (0x000002, 0x060C18, 0x3060C0, 0x800000);\n  glph[g_0]   = vec4 (0x007CC6, 0xD6D6D6, 0xD6D6C6, 0x7C0000);\n  glph[g_1]   = vec4 (0x001030, 0xF03030, 0x303030, 0xFC0000);\n  glph[g_2]   = vec4 (0x0078CC, 0xCC0C18, 0x3060CC, 0xFC0000);\n  glph[g_3]   = vec4 (0x0078CC, 0x0C0C38, 0x0C0CCC, 0x780000);\n  glph[g_4]   = vec4 (0x000C1C, 0x3C6CCC, 0xFE0C0C, 0x1E0000);\n  glph[g_5]   = vec4 (0x00FCC0, 0xC0C0F8, 0x0C0CCC, 0x780000);\n  glph[g_6]   = vec4 (0x003860, 0xC0C0F8, 0xCCCCCC, 0x780000);\n  glph[g_7]   = vec4 (0x00FEC6, 0xC6060C, 0x183030, 0x300000);\n  glph[g_8]   = vec4 (0x0078CC, 0xCCEC78, 0xDCCCCC, 0x780000);\n  glph[g_9]   = vec4 (0x0078CC, 0xCCCC7C, 0x181830, 0x700000);\n  glph[g_col] = vec4 (0x000000, 0x383800, 0x003838, 0x000000);\n  glph[g_scl] = vec4 (0x000000, 0x383800, 0x003838, 0x183000);\n  glph[g_les] = vec4 (0x000C18, 0x3060C0, 0x603018, 0x0C0000);\n  glph[g_equ] = vec4 (0x000000, 0x007E00, 0x7E0000, 0x000000);\n  glph[g_grt] = vec4 (0x006030, 0x180C06, 0x0C1830, 0x600000);\n  glph[g_que] = vec4 (0x0078CC, 0x0C1830, 0x300030, 0x300000);\n  glph[g_ats] = vec4 (0x007CC6, 0xC6DEDE, 0xDEC0C0, 0x7C0000);\n  glph[g_A]   = vec4 (0x003078, 0xCCCCCC, 0xFCCCCC, 0xCC0000);\n  glph[g_B]   = vec4 (0x00FC66, 0x66667C, 0x666666, 0xFC0000);\n  glph[g_C]   = vec4 (0x003C66, 0xC6C0C0, 0xC0C666, 0x3C0000);\n  glph[g_D]   = vec4 (0x00F86C, 0x666666, 0x66666C, 0xF80000);\n  glph[g_E]   = vec4 (0x00FE62, 0x60647C, 0x646062, 0xFE0000);\n  glph[g_F]   = vec4 (0x00FE66, 0x62647C, 0x646060, 0xF00000);\n  glph[g_G]   = vec4 (0x003C66, 0xC6C0C0, 0xCEC666, 0x3E0000);\n  glph[g_H]   = vec4 (0x00CCCC, 0xCCCCFC, 0xCCCCCC, 0xCC0000);\n  glph[g_I]   = vec4 (0x007830, 0x303030, 0x303030, 0x780000);\n  glph[g_J]   = vec4 (0x001E0C, 0x0C0C0C, 0xCCCCCC, 0x780000);\n  glph[g_K]   = vec4 (0x00E666, 0x6C6C78, 0x6C6C66, 0xE60000);\n  glph[g_L]   = vec4 (0x00F060, 0x606060, 0x626666, 0xFE0000);\n  glph[g_M]   = vec4 (0x00C6EE, 0xFEFED6, 0xC6C6C6, 0xC60000);\n  glph[g_N]   = vec4 (0x00C6C6, 0xE6F6FE, 0xDECEC6, 0xC60000);\n  glph[g_O]   = vec4 (0x00386C, 0xC6C6C6, 0xC6C66C, 0x380000);\n  glph[g_P]   = vec4 (0x00FC66, 0x66667C, 0x606060, 0xF00000);\n  glph[g_Q]   = vec4 (0x00386C, 0xC6C6C6, 0xCEDE7C, 0x0C1E00);\n  glph[g_R]   = vec4 (0x00FC66, 0x66667C, 0x6C6666, 0xE60000);\n  glph[g_S]   = vec4 (0x0078CC, 0xCCC070, 0x18CCCC, 0x780000);\n  glph[g_T]   = vec4 (0x00FCB4, 0x303030, 0x303030, 0x780000);\n  glph[g_U]   = vec4 (0x00CCCC, 0xCCCCCC, 0xCCCCCC, 0x780000);\n  glph[g_V]   = vec4 (0x00CCCC, 0xCCCCCC, 0xCCCC78, 0x300000);\n  glph[g_W]   = vec4 (0x00C6C6, 0xC6C6D6, 0xD66C6C, 0x6C0000);\n  glph[g_X]   = vec4 (0x00CCCC, 0xCC7830, 0x78CCCC, 0xCC0000);\n  glph[g_Y]   = vec4 (0x00CCCC, 0xCCCC78, 0x303030, 0x780000);\n  glph[g_Z]   = vec4 (0x00FECE, 0x981830, 0x6062C6, 0xFE0000);\n  glph[g_lsb] = vec4 (0x003C30, 0x303030, 0x303030, 0x3C0000);\n  glph[g_rsl] = vec4 (0x000080, 0xC06030, 0x180C06, 0x020000);\n  glph[g_rsb] = vec4 (0x003C0C, 0x0C0C0C, 0x0C0C0C, 0x3C0000);\n  glph[g_pow] = vec4 (0x10386C, 0xC60000, 0x000000, 0x000000);\n  glph[g_usc] = vec4 (0x000000, 0x000000, 0x000000, 0x00FF00);\n  glph[g_a]   = vec4 (0x000000, 0x00780C, 0x7CCCCC, 0x760000);\n  glph[g_b]   = vec4 (0x00E060, 0x607C66, 0x666666, 0xDC0000);\n  glph[g_c]   = vec4 (0x000000, 0x0078CC, 0xC0C0CC, 0x780000);\n  glph[g_d]   = vec4 (0x001C0C, 0x0C7CCC, 0xCCCCCC, 0x760000);\n  glph[g_e]   = vec4 (0x000000, 0x0078CC, 0xFCC0CC, 0x780000);\n  glph[g_f]   = vec4 (0x00386C, 0x6060F8, 0x606060, 0xF00000);\n  glph[g_g]   = vec4 (0x000000, 0x0076CC, 0xCCCC7C, 0x0CCC78);\n  glph[g_h]   = vec4 (0x00E060, 0x606C76, 0x666666, 0xE60000);\n  glph[g_i]   = vec4 (0x001818, 0x007818, 0x181818, 0x7E0000);\n  glph[g_j]   = vec4 (0x000C0C, 0x003C0C, 0x0C0C0C, 0xCCCC78);\n  glph[g_k]   = vec4 (0x00E060, 0x60666C, 0x786C66, 0xE60000);\n  glph[g_l]   = vec4 (0x007818, 0x181818, 0x181818, 0x7E0000);\n  glph[g_m]   = vec4 (0x000000, 0x00FCD6, 0xD6D6D6, 0xC60000);\n  glph[g_n]   = vec4 (0x000000, 0x00F8CC, 0xCCCCCC, 0xCC0000);\n  glph[g_o]   = vec4 (0x000000, 0x0078CC, 0xCCCCCC, 0x780000);\n  glph[g_p]   = vec4 (0x000000, 0x00DC66, 0x666666, 0x7C60F0);\n  glph[g_q]   = vec4 (0x000000, 0x0076CC, 0xCCCCCC, 0x7C0C1E);\n  glph[g_r]   = vec4 (0x000000, 0x00EC6E, 0x766060, 0xF00000);\n  glph[g_s]   = vec4 (0x000000, 0x0078CC, 0x6018CC, 0x780000);\n  glph[g_t]   = vec4 (0x000020, 0x60FC60, 0x60606C, 0x380000);\n  glph[g_u]   = vec4 (0x000000, 0x00CCCC, 0xCCCCCC, 0x760000);\n  glph[g_v]   = vec4 (0x000000, 0x00CCCC, 0xCCCC78, 0x300000);\n  glph[g_w]   = vec4 (0x000000, 0x00C6C6, 0xD6D66C, 0x6C0000);\n  glph[g_x]   = vec4 (0x000000, 0x00C66C, 0x38386C, 0xC60000);\n  glph[g_y]   = vec4 (0x000000, 0x006666, 0x66663C, 0x0C18F0);\n  glph[g_z]   = vec4 (0x000000, 0x00FC8C, 0x1860C4, 0xFC0000);\n  glph[g_lpa] = vec4 (0x001C30, 0x3060C0, 0x603030, 0x1C0000);\n  glph[g_bar] = vec4 (0x001818, 0x181800, 0x181818, 0x180000);\n  glph[g_rpa] = vec4 (0x00E030, 0x30180C, 0x183030, 0xE00000);\n  glph[g_tid] = vec4 (0x0073DA, 0xCE0000, 0x000000, 0x000000);\n  glph[g_lar] = vec4 (0x000000, 0x10386C, 0xC6C6FE, 0x000000);\n  cSpace = vec2 (8., 13.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfyDs.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1041, 1041, 1063, 1063, 2698], [2700, 2700, 2733, 2733, 2916], [2918, 2918, 2939, 2939, 3194], [3196, 3196, 3228, 3228, 3431], [3433, 3433, 3464, 3464, 3836], [3838, 3838, 3864, 3864, 7283], [7285, 7285, 7341, 7341, 8882], [8884, 8884, 8916, 8916, 9016], [9018, 9018, 9064, 9064, 9111], [9113, 9113, 9160, 9160, 9207], [9209, 9209, 9242, 9242, 9269], [9271, 9271, 9313, 9313, 9364], [9366, 9366, 9402, 9402, 9608], [9610, 9610, 9640, 9640, 9753], [9755, 9755, 9812, 9812, 9895], [9929, 9929, 9953, 9953, 10065], [10067, 10067, 10092, 10092, 10278], [10280, 10280, 10301, 10301, 10456], [10458, 10458, 10487, 10487, 10699], [10701, 10701, 10740, 10740, 10920], [14858, 14858, 14889, 14889, 15287], [15289, 15289, 15310, 15310, 15341], [16072, 16072, 16088, 16088, 22102]], "test": "untested"}
{"id": "tsfyWs", "name": "Mandelbrot fluid", "author": "michael0884", "description": "Combining the best of both worlds. Use mouse to distort the fractal.", "tags": ["fractal", "fluid"], "likes": 13, "viewed": 505, "published": 3, "date": "1585829457", "time_retrieved": "2024-07-30T21:15:19.358169", "image_code": "vec2 sqr(vec2 x)\n{\n    return vec2(x.x*x.x - x.y*x.y, 2.*x.x*x.y); \n}\n\nfloat mandelbrot(vec2 x)\n{\n    vec2 z = vec2(0), dz = vec2(0);\n    for(int i = 0; i < 128; i++)\n    {\n        dz = 2.*vec2(dot(z, dz*a.yz), dot(z, dz.yx)) + a.yx;\n        z = sqr(z) + x;\n        if(length(z)>32.) break;\n    }\n    return 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n}\n\nvoid mainImage( out vec4 U, in vec2 p )\n{\n    vec2 uv = pixel(ch0, p).zw;\n    vec2 mouse = (iMouse.z > 0.)?iMouse.xy:size*0.5;\n\t//if(all(lessThan(p, size.xx*0.25))) uv = pixel(ch0, 0.1*p+iMouse.xy).zw;\n   \n    \n    U = sin(vec4(1.,1.2,1.3,4)*log(0.0001 + 0.1*mandelbrot(uv)));\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//definitions\n#define size iResolution.xy\n#define pixel(a, p) texture(a, vec2(p)/vec2(size))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n#define dt 1.\n\nconst vec3 a = vec3(0, 1, -1);\n", "buffer_a_code": "void mainImage( out vec4 U, in vec2 p )\n{\n    //advection\n\tU = pixel(ch0, p - dt*pixel(ch0, p).xy); \n    //pressure gradient\n    U.xy -= dt*0.25*vec2(pixel(ch1, p+a.yx).x - pixel(ch1, p+a.zx).x,\n                      pixel(ch1, p+a.xy).x - pixel(ch1, p+a.xz).x);\n    \n    \n    \n    //border\n    float dx = min(p.x, size.x - 1. - p.x);\n    float dy = min(p.y, size.y - 1. - p.y);\n    U.xy -= U.xy*vec2(exp(-0.5*dy*dy),exp(-0.5*dx*dx));\n    float d = min(dx,dy);\n    U.xy -= U.xy*exp(-d*d);\n    \n    if(iFrame < 1)\n    {\n        vec2 dx = p - size*0.5;\n        U.xy = exp(-0.0005*dot(dx,dx))*vec2(sin(iTime),cos(iTime));\n        U.zw = (p - size*vec2(2.,0.5))/size.x;\n    }\n    \n    if(iMouse.z>0.)\n    {\n        vec2 dx = p - iMouse.xy;\n        U.xy +=\t0.1*exp(-0.01*dot(dx,dx))*vec2(sin(iTime),cos(iTime));\n    }\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 p )\n{\n    //advection\n    U = pixel(ch1, p - dt*pixel(ch0, p).xy); \n    //velocity divergence \n    U.x -= dt*0.25*(pixel(ch0, p+a.yx).x - pixel(ch0, p+a.zx).x + \n                    pixel(ch0, p+a.xy).y - pixel(ch0, p+a.xz).y);\n    if(iFrame < 1)\n    {\n        U.x = 0.;\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 U, in vec2 p )\n{\n    vec2 uv = (p - size*vec2(2.,0.5))/size.x;\n    //advection\n\tU = pixel(ch0, p - dt*pixel(ch0, p).xy); \n    //pressure gradient\n    U.xy -= dt*0.25*vec2(pixel(ch1, p+a.yx).x - pixel(ch1, p+a.zx).x,\n                      pixel(ch1, p+a.xy).x - pixel(ch1, p+a.xz).x);\n    \n    \n    \n    //border\n    float dx = min(p.x, size.x - 1. - p.x);\n    float dy = min(p.y, size.y - 1. - p.y);\n    U.xy -= U.xy*vec2(exp(-0.5*dy*dy),exp(-0.5*dx*dx));\n    float d = min(dx,dy);\n    U.xy -= U.xy*exp(-d*d);\n    \n    U.zw = mix(uv, U.zw, 0.995);\n    \n    if(iFrame < 1)\n    {\n        vec2 dx = p - size*0.5;\n        U.xy = exp(-0.0005*dot(dx,dx))*vec2(sin(iTime),cos(iTime));\n        U.zw = uv;\n    }\n    \n    if(iMouse.z>0.)\n    {\n        vec2 dx = p - iMouse.xy;\n        U.xy +=\t0.1*exp(-0.01*dot(dx,dx))*vec2(sin(iTime),cos(iTime));\n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 U, in vec2 p )\n{\n    //advection\n    U = pixel(ch1, p - dt*pixel(ch0, p).xy); \n    //velocity divergence \n    U.x -= dt*0.25*(pixel(ch0, p+a.yx).x - pixel(ch0, p+a.zx).x + \n                 pixel(ch0, p+a.xy).y - pixel(ch0, p+a.xz).y);\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfyWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 69], [71, 71, 97, 97, 354], [356, 356, 397, 397, 634]], "test": "untested"}
{"id": "tdfcDl", "name": "Day 105", "author": "jeyko", "description": "potato", "tags": ["mograph", "motiongraphics", "mdtmjvm"], "likes": 23, "viewed": 621, "published": 3, "date": "1585827391", "time_retrieved": "2024-07-30T21:15:20.106169", "image_code": "// Fork of \"Day 104\" by jeyko. https://shadertoy.com/view/WdlcDX\n// 2020-04-02 10:14:03\n\n\n// USING YX/LUNA'S AWESOME DITHERED MOTION BLUR - https://www.shadertoy.com/view/wsfcWX\n// I modified it to not be framerate dependent like the original.\n\n\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n#define timeStep (1./60.)\n#define motionBlurSteps 10\n\n\nfloat bayer8(ivec2 uv)\n{   \n    uv %= 8;\n\treturn texelFetch(iChannel1,uv,0).r;\n}\n\n\n// from https://necessarydisorder.wordpress.com/\nfloat ease(float p, float g) {\n    if(p < 0.){\n        return 0.;\n    } else if(p > 1.){\n    \treturn 1.;\n    } else {\n        if (p < 0.5) \n            return 0.5 * pow(2.*p, g);\n        else\n            return 1. - 0.5 * pow(2.*(1. - p), g);\n    }\n}\n\nfloat ease(float p, float power, float jump, float offs, float end) {\n    float j = p;\n    p *= offs;\n    float r = (1.-cos(pi*p))/2.*jump;\n    r = pow(r, power);\n    r = mix(r, 1., pow(smoothstep(0.,1.,j),end));\n\treturn r;\n}\nfloat smease(float p, float g) {\n    float s = p;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n\n\nfloat sdBox(vec2 p, vec2 s){\n\tp = abs(p) - s;\n\treturn max(p.x, p.y);\n}\nfloat sdCirc(vec2 p, float s){\n    return length(p) - s;\n}\n\nfloat sdEquilateralTriangle(  vec2 p, float s )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - s;\n    p.y = p.y + s/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d = -length(p)*sign(p.y);\n    \n    return d;\n}\nconst float speed = 0.28;\nfloat[] scenes = float[4](3.2*speed,1.7*speed, 2.6*speed, 1.2*speed); \n\nconst float S = 1.;\n\nvec3 get( vec2 uv, float t  )\n{\n vec2 suv = uv;   \n    //uv += S*0.05;\n    uv *= 2.;\n    \n    uv.y += S*0.25;\n    float col = 0.;\n    \n    float d = 10e6;\n    \n    float bA;\n    float bB;\n    float bC;\n    float bD;\n    float bE;\n    \n    float pl;\n    \n    \n    //col += smoothstep(0.5,0.1, abs(uv.y));\n    \n    //t += scenes[0];\n    //t += scenes[1] - 0.1;\n    //t += scenes[2] - 0.1;\n    t = mod(t, scenes[0] + scenes[1] + scenes[2] + scenes[3]  );\n    \n    \n    float iters = 45.;\n           \n    float sep = 5.;\n    float pp = 1.645;\n    \n    #define sc(x) vec2(sin((x)*tau), cos((x)*tau))\n    \n    if(t < scenes[0]){\n        float lsp = 1.2;\n        float env = ease(t/scenes[0]*lsp, 3.);  \n        \n        for(float i = 0.; i < iters + min(float(iFrame),0.); i++){\n            vec2 suv = uv;\n            if(i != iters - 1.){\n            \tsuv *= rot((iters - i)*1.65*env/pi);\n            }\n            float dTriA = sdEquilateralTriangle(  suv, S/exp((iters - i)/sep) );\n        \n            d = max(d, dTriA);\n        \td = min(d, abs(dTriA) - dFdx(uv.x)/2.);\n        \n        }\n    } else if(t < scenes[0] + scenes[1]){\n        t -= scenes[0];\n        float lsp = 1.2;\n        float env = ease(t/scenes[1]*lsp, 3.);  \n        \n           \n        for(float i = 0.; i < iters + min(float(iFrame),0.); i++){\n            vec2 suv = uv;\n            if(i != iters - 1.){\n            \tsuv *= rot((iters - i)*pp/pi + (iters - i)*pp/pi*env);\n            }\n            float dTriA = sdEquilateralTriangle(  suv, S/exp((iters - i)/sep) );\n        \n            d = max(d, dTriA);\n        \td = min(d, abs(dTriA) - dFdx(uv.x)/2.);\n        \n        }\n    } else if(t < scenes[0] + scenes[1] + scenes[2]){\n        t -= scenes[0] + scenes[1];\n        float lsp = 1.2;\n        float env = ease(t/scenes[2]*lsp, 3.);  \n        \n        for(float i = 0.; i < iters + min(float(iFrame),0.); i++){\n            vec2 suv = uv;\n            if(i != iters - 1.){\n            \tsuv *= rot((iters - i)*pp/pi + (iters - i)*pp/pi + (iters - i)*pp/pi*env*2. );\n            }\n            float dTriA = sdEquilateralTriangle(  suv, S/exp((iters - i)/sep) );\n        \n            d = max(d, dTriA);\n        \td = min(d, abs(dTriA) - dFdx(uv.x)/2.);\n        \n        }\n    }else if(t < scenes[0] + scenes[1] + scenes[2] + scenes[3]){\n        t -= scenes[0] + scenes[1] + scenes[2];\n        float lsp = 1.2;\n        float env = ease(t/scenes[3]*lsp, 3.)*smoothstep(1.,0.,t/scenes[3]*lsp)*0.05;  \n        \n        for(float i = 0.; i < iters + min(float(iFrame),0.); i++){\n            vec2 suv = uv;\n            if(i != iters - 1.){\n            }\n            float dTriA = sdEquilateralTriangle(  suv, (S + env)/exp((iters - i )/(sep - env*1. )) );\n        \n            d = max(d, dTriA);\n        \td = min(d, abs(dTriA) - dFdx(uv.x)/2.);\n        \n        }\n    }\n    \n    //d = min(d, abs(suv.y) - 0.001);\n    //d = min(d, abs(suv.x) - 0.001);\n    return vec3(d);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;  \n    vec3 col = vec3(0);\n    \n    float edge = dFdx(uv.x)*1.;\n    \n    for (int i = 0; i < motionBlurSteps  ; ++i) {\n        float subsample = bayer8(ivec2(fragCoord));\n        float time = iTime + ((float(i)+subsample)/float(motionBlurSteps)-.5) * timeStep;\n        col += smoothstep(-edge,edge,-get(uv,time));\n    }\n    col/=float(motionBlurSteps);\n    \n    col = clamp(col, 0., 1.);\n    col *= 0.999;\n    \n    //col *= max((1. + 1.*cos(sin(0.25*tau*iTime/(scenes[0] + scenes[1] ))*tau+length(uv)*2.+vec3(4,2.5,1.5)))*1., 0.);\n    //col *= max((1.5 + 1.4*cos(iTime+length(uv)*2.+vec3(1,1.5,1.5)))*1., 0.);\n    \n    col *= 1. - pow(smoothstep(0.,1.,dot(uv,uv)*0.9),0.9)*1.;\n    \n    col = pow(col, vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdfcDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[394, 394, 418, 418, 474], [477, 526, 556, 556, 776], [778, 778, 847, 847, 1003], [1004, 1004, 1036, 1036, 1140], [1143, 1143, 1171, 1171, 1213], [1214, 1214, 1244, 1244, 1272], [1274, 1274, 1323, 1323, 1552], [1672, 1672, 1703, 1703, 4606]], "test": "untested"}
{"id": "wsXyWs", "name": "max headroom zoom background", "author": "benhardy", "description": "Hey they said dress for the job you want and since I'm working from home I wanted to be Max Headroom in zoom\n\nIt should be noted that using raymarching for something this simple is total overkill., shoulda just raytraced it.", "tags": ["80s", "remotework", "workingfromhome", "maxheadroom"], "likes": 7, "viewed": 1002, "published": 3, "date": "1585826135", "time_retrieved": "2024-07-30T21:15:20.993796", "image_code": "#define MAX_DIST 1000.0\n#define MAX_STEPS 1000\n#define EPSILON 0.01\n#define STEP_RATIO 0.75\n\n\n#define NORMAL_DELTA 0.001\n\nvec2 measure(vec3 point) {\n    vec3 rv = vec3(mod(point.x+5.0, 10.0)-5.0, \n                  point.y, \n                  point.z);\n    \n    float r = max(length(rv.xy) - 0.75,\n    \tmax(point.z,-point.x-0.5));\n\tvec2 closest = vec2(r, 1.0);\n    \n    vec3 gv = vec3(point.x,\n        mod(point.y+5.0, 10.0)-5.0, \n        point.z);\n    float g = max(length(gv.yz) - 0.50,\n\t    max(-point.x+0.5, -point.y-5.5));\n    if (g < closest.x) {\n        closest = vec2(g, 2.0);\n    }\n    // yellow\n    vec3 bv = vec3(point.x,\n        point.y,\n        mod(point.z+5.0, 10.0)-5.0);\n    float b = max(length(bv.zx) - 0.75,\n    \tmax(point.z-5.5, -point.y+0.5));\n    if (b < closest.x) {\n        closest = vec2(b, 3.0);\n    }\n    \n    return closest;\n}\n\nvec3 calc_surface_normal(vec3 hit) {\n\treturn normalize(vec3(\n            measure(hit+vec3(NORMAL_DELTA, 0.0, 0.0)).x - measure(hit-vec3(NORMAL_DELTA, 0.0, 0.0)).x,\n            measure(hit+vec3(0.0, NORMAL_DELTA, 0.0)).x - measure(hit-vec3(0.0, NORMAL_DELTA, 0.0)).x,\n            measure(hit+vec3(0.0, 0.0, NORMAL_DELTA)).x - measure(hit-vec3(0.0, 0.0, NORMAL_DELTA)).x\n    ));\n}\n\nvec4 aaTrace(in vec2 fragCoord )\n{\n    // apply smooth sawtooth time distortion for eye\n    // this makes the eye move very slow, then fast, over and over\n    float eyeTime = iTime*2.0/3.1415926536 + sin(iTime) \n        +sin(iTime*2.0) / 4.0\n        +sin(iTime*3.0) / 9.0\n        +sin(iTime*4.0) / 16.0\n        +sin(iTime*5.0) / 25.0;\n    vec3 eye = vec3(\n        sin(eyeTime*0.11)* 150.0 + 300.0,\n        sin(eyeTime*0.05)* 150.0 + 300.0,\n        cos(eyeTime*0.13)* 150.0 - 300.0\n    );\n    // minor time distortion for whatever we're looking at\n    float lookTime = 4.0*(iTime + sin(iTime+2.0));\n    // keep us looking more or less at the back corner but\n    // move your around a bit\n    vec3 look_at = vec3(\n        sin(lookTime*0.0730)*50.0+50.0,\n        sin(lookTime*0.0101)*20.0+30.0,\n        cos(lookTime*0.0710)*50.0+50.0\n    );\n    // let's do the time warp again\n    float upTime = iTime + sin(iTime*1.7+1.0);\n    // get a bit of roll going by adjusting the up vector too\n    vec3 up = normalize(vec3(\n        sin(upTime*0.0610)*1.0,\n        sin(upTime*0.0430)*1.0+3.0,\n        cos(upTime*0.0310)*1.0\n    ));\n    vec3 ray = calculateRay(iResolution, fragCoord, eye, look_at, up);\n    \n    vec3 where = eye;\n    float total_dist = 0.0;\n    vec2 current;\n    int who = 0;\n    float current_dist = 0.0;\n    float best_dist = MAX_DIST;\n    // main raymarching loop\n    for(int steps =0;steps < MAX_STEPS; steps++) {\n        // lazy bailout if we go past the back walls\n        if (where.y < -1.0 || where.x < -1.0 || where.z > 1.0) {\n            break;\n        }\n        current = measure(where);\n        current_dist = current.x;\n        if (current_dist < EPSILON) {\n            who = int(current.y);\n            break;\n        }\n        if (current_dist < best_dist) {\n            best_dist = current_dist;\n        }\n        total_dist += current_dist * STEP_RATIO;\n        if (total_dist > MAX_DIST) {\n            break;\n        }\n        where = eye + total_dist * ray;\n    }\n    if (who == 1){\n        float glow = clamp(15.0 - best_dist, 0.0, 15.0) / 15.0;\n        vec3 pink = vec3(1.0, 0.6, 0.5);\n        return vec4(glow * pink, 1.0);\n    }\n    if (who == 2){\n        float glow = clamp(1.0 - best_dist, 0.0, 1.0);\n        vec3 green = vec3(0.5, 1.0, 0.5);\n        return vec4(glow * green, 1.0);\n    }\n    if (who == 3){\n        float glow = clamp(1.0 - best_dist, 0.0, 1.0);\n        vec3 cc = vec3(0.8, 0.8, 0.2);\n        return vec4(glow * cc, 1.0);\n    }\n    return vec4(0);\n}\n\n#define AA_JITTER 0.1\n#define AA_SPREAD 1.0\n#define AA_DEPTH  4\n#define AA_DEPTH_F 4.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    for (int aax = 0; aax < AA_DEPTH; aax++) {\n\t    for (int aay = 0; aay < AA_DEPTH; aay++) {\n            vec2 dp = AA_SPREAD * vec2(float(aax), float(aay)) / AA_DEPTH_F;\n            vec2 subpixel = dp + fragCoord;\n            ivec2 ip = ivec2(int(subpixel.x * AA_DEPTH_F), int(subpixel.y*AA_DEPTH_F));\n            vec2 jitter = vec2(\n                float(((2621 * ip.x + ip.y) * 1709) &255) / 256.0 - 0.5,\n            \tfloat(((1999 * ip.x + ip.y) * 3119) &255) / 256.0 - 0.5\n            ) * AA_JITTER;\n            fragColor += aaTrace(subpixel + jitter);\n        }\n    }\n    fragColor /= 16.0;\n}", "image_inputs": [], "common_code": "#define MAX_FLOAT 3.402823466e+38\n#define MIN_FLOAT 1.175494351e-38\n#define MAX_DOUBLE 1.7976931348623158e+308\n#define MIN_DOUBLE 2.2250738585072014e-308\n\n// Indicate to 'repeat' function that we don't wish to\n#define NEVER 1000000.0\n\n/**\n * Common vectors\n */\nconst vec3 ORIGIN = vec3(0,0,0);\nconst vec3 X = vec3(1,0,0);\nconst vec3 Y = vec3(0,1,0);\nconst vec3 Z = vec3(0,0,1);\n\n/**\n * Common color values\n */\nconst vec3 BLACK = vec3(0,0,0);\nconst vec3 WHITE = vec3(1,1,1);\nconst vec3 RED   = vec3(1,0,0);\nconst vec3 GREEN = vec3(0,1,0);\nconst vec3 BLUE  = vec3(0,0,1);\nconst vec3 YELLOW  = vec3(1,1,0);\nconst vec3 CYAN    = vec3(0,1,1);\nconst vec3 MAGENTA = vec3(1,0,1);\n\n/**\n * For the given 2d screen position, figure out the ray vector\n */\nvec3 calculateRay(vec3 res, vec2 screenPos, \n                  vec3 eye, vec3 look_at, vec3 up) {\n\tvec2 screen_pos = screenPos.xy / res.xy;\n    float aspect = res.y / res.x;\n    screen_pos -= 0.5;\n    screen_pos.y *= aspect;\n    vec3 look_center = normalize(look_at - eye);\n    vec3 look_right = cross(up, look_center);\n    vec3 look_up = cross(look_center, look_right);\n        \n\tvec3 newRay = normalize(look_center + screen_pos.x * look_right + screen_pos.y * look_up);\n    return newRay;\n}\n\n\n\n/*\n * Signed distance functions for object primitives\n */\nfloat sphere(vec3 where, vec3 center, float radius) {\n  return length(where - center) - radius;\n}\n\n//float torus_around_x(vec3 where, float major, float minor) {\n    \n\nfloat round_box( vec3 where, vec3 sizes, float roundness ) {\n\treturn length(max(abs(where)-sizes,0.0))-roundness;\n}\n\nvec3 repeat(vec3 where, vec3 repetition) {\n\n    return mod(where, repetition);\n}\nvec3 repeat_x(vec3 where, float r) {\n\n    where.x = mod(where.x, r);\n    return where;\n}\n\n\n#define PI 3.141592653589793\nvec3 radial_symmetry_xz(vec3 where, float count) {\n    float ang = mod(atan(where.x, where.z) + PI, 2.0 *PI /count);\n    float r = length(where.xz);\n    return vec3(r *cos(ang), where.y, r * sin(ang));\n}\n\n// polynomial smooth min (k = 0.1);\nfloat blend( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*0.25/k;\n}\n\n\nint hash(int x) {\n    x = ((x >> 16) ^ x) * 0x45d9f3b;\n    x = ((x >> 16) ^ x) * 0x45d9f3b;\n    x = (x >> 16) ^ x;\n    return x;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXyWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 122, 148, 148, 854], [856, 856, 892, 892, 1234], [1236, 1236, 1270, 1390, 3732], [3822, 3822, 3879, 3879, 4503]], "test": "untested"}
{"id": "tsXyDl", "name": "Glow intro 2", "author": "Tomza", "description": "rework of first shader 2 times less chars!", "tags": ["star", "neon"], "likes": 8, "viewed": 456, "published": 3, "date": "1585821467", "time_retrieved": "2024-07-30T21:15:21.815599", "image_code": "#define Rot(a) mat2(cos(a), -sin(a),sin(a), cos(a))\n#define PI 3.141592\n#define tau 6.283185\n\nfloat sdCapsule( vec2 p, vec2 a, vec2 b)\n{\n  vec2 pa = p - a;\n  vec2 ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nfloat Branch(vec2 p, float zoom)\n{\n    p*=Rot(0.945);\n    p -= zoom*vec2(0.31,0.43);\n    float d = sdCapsule(p, vec2(0.,0.), zoom*vec2(1.,0.));\n    d = min(d,sdCapsule(p* -Rot(tau/5.), vec2(0.,0.), zoom*vec2(1.,0.)));\n    return d;\n}\n\nvec3 Star(vec2 p, float zoom, vec3 col)\n{\n    p*=Rot(tau/4.);\n    \n    float an = tau/5.;\n    float sector = round(atan(p.y,p.x)/an);\n    vec2 q = p;\n    \n    q.xy = Rot(an*sector)*p.xy;\n\n    return 0.02/abs(Branch(q,zoom))*col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.*(2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 m,col = vec3(0.);\n    \n    for(float i=0.;i<10.;i++)\n    {     \n        m = max(m,Star(uv, mod(2.5*iTime-i,10.)+0.01,vec3(0.86-mod(i,10.)*0.2,0.0,0.48+0.02*mod(i,10.))));   \n    }\n    \n    col = m;\n\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXyDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 136, 136, 260], [262, 262, 296, 296, 495], [497, 497, 538, 538, 727], [730, 730, 787, 787, 1090]], "test": "untested"}
{"id": "tsfcWl", "name": "Glowy lattices", "author": "Roninkoi", "description": "Trying out raymarching. Low iteration count = glow!", "tags": ["raymarching", "lattice"], "likes": 1, "viewed": 309, "published": 3, "date": "1585818459", "time_retrieved": "2024-07-30T21:15:22.573572", "image_code": "#define PI 3.14159265\n#define MAXIT 50\n#define EPSILON 0.01\n\n#define minx(a, b) ((a.w) < (b.w) ? (a) : (b))\n\nfloat sphere(vec3 r, float a)\n{\n\treturn length(r) - a;\n}\n\nfloat pointy(vec3 r, float a)\n{\n\tfloat d = (abs(r.x*3.) + 1./a) * (abs(r.y) + 1./a) * (abs(r.z) + 1./a);\n\treturn length(r) - 1./ d;\n}\n\nfloat plane(vec3 r, vec3 o, vec3 n) {\n\treturn dot(r - o, n);\n}\n\nfloat box(vec3 r, vec3 a)\n{\n\tvec3 p = abs(r) - a;\n\treturn length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat shade(vec3 n, vec3 rd)\n{\n\treturn clamp(max(dot(n, -rd), 0.) + 1., 0., 1.);\n}\n\nvec3 fog(float z, vec3 col, vec3 fogCol)\n{\n\treturn mix(fogCol, col, exp(-z));\n}\n\nmat3 obj;\nfloat t;\n\nvec4 map(vec3 r)\n{\n\tvec4 s0 = vec4(\n\t\tvec3(1.0, 0.2, 0.) * 1.2,\n\t\tpointy(obj * (mod(r + 1.0, 4.) - 1.0), 1.0)\n\t);\n\tvec4 s1 = vec4(\n\t\tvec3(0., 1., 1.) * 1.2,\n\t\tsphere(mod(r + 3.0 + vec3(\n\t\t\tcos(t*10.) * 0.2, \n\t\t\tsin(t*10.) * 0.2, \n\t\t\tsin(t)*1.5 + 2.), 4.) - 1.0, 0.05)\n\t);\n\tvec4 b0 = vec4(\n\t\tvec3(0., 0.4, 1.0) * 1.2,\n\t\tbox(mod(r + 3.0, 4.) - 1.0, vec3(4., 0.05, 0.05))\n\t);\n\tvec4 b1 = vec4(\n\t\tvec3(0., 0.4, 1.0) * 1.2,\n\t\tbox(mod(r + 3.0, 4.) - 1.0, vec3(0.05, 4., 0.05))\n\t);\n\tvec4 b2 = vec4(\n\t\tvec3(0., 0.4, 1.0) * 1.2,\n\t\tbox(mod(r + 3.0, 4.) - 1.0, vec3(0.05, 0.05, 4.))\n\t);\n\t\n\treturn minx(s0, minx(s1, minx(b0, minx(b1, b2))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tt = iTime;\n\t\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv -= 0.5;\n\tuv.x *= iResolution.x / iResolution.y;\n\t\n\tmat3 cam = mat3(\n\t\tcos(t * 0.2), 0., sin(t * 0.2),\n\t\t0., 1., 0.,\n\t\t-sin(t * 0.2), 0., cos(t * 0.2)\n\t) * mat3(\n\t\tcos(t * 0.2), -sin(t * 0.2), 0., \n\t\tsin(t * 0.2), cos(t * 0.2), 0.,\n\t\t0., 0., 1.\n\t);\n\t\n\tobj = mat3(\n\t\tcos(t * 2.), 0., sin(t * 2.),\n\t\t0., 1., 0.,\n\t\t-sin(t * 2.), 0., cos(t * 2.)\n\t) * mat3(\n\t\tcos(t * 1.5), -sin(t * 1.5), 0., \n\t\tsin(t * 1.5), cos(t * 1.5), 0.,\n\t\t0., 0., 1.\n\t);\n\t\n\tvec3 ro = vec3(t, 0., .75 * sin(t * 0.785) - 2.);\n\tvec3 rd = cam * normalize(vec3(uv, 1.));\n\tvec3 r = ro;\n\t\n\tvec4 col = vec4(1.);\n\tvec3 bcol = vec3(1., 0.5, 0.0) + 0.2;\n\t\n\tvec4 c = vec4(bcol, 1.);\n\t\n\tfloat sh = 1.;\n\t\n\tfor (int i = 0; i < MAXIT; ++i) {\n\t\tvec4 d = map(r);\n\t\tfloat z = length(r - ro);\n\t\t\n\t\tvec4 nc = minx(c, d);\n\t\tc.rgb = mix(nc.rgb, c.rgb, nc.w / c.w);\n\t\tc.w = nc.w;\n\t\t\n\t\tif (d.w < EPSILON) {\t\t\t\n\t\t\tcol.rgb = d.rgb * shade(normalize(r), rd);\n\t\t\tcol.rgb = fog(z * 0.1, col.rgb, bcol);\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tr += rd * (clamp(d.w, -1., 1.)) * 0.8;\n\t\tsh += (float(i) / float(MAXIT)) / max(z, 1.);\n\t}\n\t\n\tcol.rgb *= exp(-sh * sh * 0.03);\n\t\n\tif (c.w > EPSILON) {\n\t\tcol.rgb = fog(c.w * 2., c.rgb, bcol);\n\t}\n    \n\tfragColor = vec4(col.rgb, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfcWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 140, 140, 165], [167, 167, 198, 198, 300], [302, 302, 339, 339, 364], [366, 366, 393, 393, 480], [482, 482, 512, 512, 564], [566, 566, 608, 608, 645], [667, 667, 685, 685, 1297]], "test": "untested"}
{"id": "WdfyDl", "name": "Banana Feeder", "author": "propagant", "description": "The legend says that he is still eating bananas to this day", "tags": ["raymarching", "cartoon"], "likes": 3, "viewed": 431, "published": 3, "date": "1585795445", "time_retrieved": "2024-07-30T21:15:23.331546", "image_code": "// Made by Matej Vanco just for fun\n\nstruct ray\n{\n\tvec3 o;\n\tvec3 d;\n\tfloat l;\n};\n\t\nmat2 rot(float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n\nvec4 opu(vec4 a, vec4 b)\n{\n\treturn (a.w < b.w) ? a : b;\t\n}\n\nfloat nnn(float p, float a, float b, float c)\n{\n\treturn cos(-p*a + iTime * b)*c;\n}\n\t\nvec4 geo(vec3 p)\n{\n\tvec3 color_head = mix(vec3(0.0,1.0,0.0), vec3(1.0,1.0,0.0), cos(iTime * 11.));\n\n\tfloat height = -0.1;\n    \n\tvec4 head = vec4(color_head,length(p - vec3(0.75,height,1.5))-0.4) \n        + nnn(p.x,4.2,10.5,0.2);\n\tvec4 eye = vec4(vec3(1.0),length(p - vec3(0.75,height+0.15,1.3))-0.25) \n        + nnn(p.x, 4.2, 10.5, 0.2);\n\tvec4 eyeB = vec4(vec3(0.),length(p - vec3(0.6,height+0.18,1.28))-0.15) \n        + clamp(nnn(p.x, 4.2, 10.5, 0.2),-0.9,0.15);\n\tvec4 plane = vec4(0.2,0.6,0.4,(p.y + 0.55));\n\tvec3 bRot = p;\n\tbRot.yz *= rot(0.4);\n\tvec4 box = vec4(1.0,1.0,0.0,length(\n        max(abs(bRot - vec3(-0.9,-0.6,1.3)) - vec3(1.15,0.02,0.02),0.0) + nnn(p.x, 2.1, 10.5, 0.2)) - 0.06);\n\n\tvec4 g = opu(head, plane);\n\tvec4 g2 = opu(g, box);\n\tvec4 g3 = opu(g2, eye);\n\tvec4 g4 = opu(g3, eyeB);\n\treturn g4;\n}\n\nvec4 march(ray r)\n{\n\tvec3 col = vec3(1.0);\n\tfor(int i = 0; i < 64; i++)\n\t{\n\t\tvec3 p = r.o + r.d * r.l;\n\t\tvec4 g = geo(p);\n\t\tr.l += g.w;\n\t\tcol = g.rgb;\n\t\tif(r.l > 32.)\n\t\t\tbreak;\n\t}\n\treturn vec4(col, r.l);\n}\n\nvec3 normal(vec3 p)\n{\n\tvec2 of = vec2(0.001, 0.0);\n\tfloat copy = geo(p).w;\n\treturn normalize(copy - vec3(geo(p - of.xyy).w, geo(p - of.yxy).w, geo(p - of.yyx).w));\n}\n\nfloat shadow(vec3 ro, vec3 rd, float b)\n{\n\tfloat t = 0.01;\n\tfloat res = 1.;\n\tfor(int i = 0; i < 16; i++)\n\t{\n\t\tfloat copy = geo(ro + rd * t).w;\n\t\tres = min(res, b * copy/t);\n\t\tif(copy < 0.001)\n\t\t\tbreak;\t\n\t\tt += copy;\n\t\tif(t < 0.01 || t > 3.)\n\t\t\tbreak;\n\t}\n\treturn clamp(res,0.2,1.);\n}\n\nfloat lighting(vec3 p)\n{\n\tvec3 lp = vec3(1.0,2.,-1.);\n\tvec3 lPos = normalize(lp - p);\n\tvec3 n = normal(p);\n\t\n\tfloat light = clamp(dot(lPos, n), 0.1,1.);\n\treturn light * shadow(p, lp, 0.8);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord -0.5 *iResolution.xy)/iResolution.y;\n    \n   \tray r;\n\tr.o = vec3(0.);\n\tuv.xy += sin(iTime * 25.)*0.015;\n\tr.d = vec3(uv, 1.0);\n\tvec4 m = march(r);\n\tvec3 mm = r.o + r.d * m.w;\n    \n    vec2 p = mm.xz;\n    p.x-=iTime * 6.;\n    if(m.rgb == vec3(0.2,0.6,0.4))\n    {\n     \tif(fract(sin(p.x*0.5)*0.5)>0.45) m.rgb = mix(m.rgb,vec3(0.6,0.6,0.3)*2.,uv.x); \n    }\n    \n\tvec3 col = m.rgb * lighting(mm);\n    col *= exp(-0.05 * pow(m.w, 3.));\n\tcol += (vec3(0.2,0.35,0.25) * 0.6) / 1.5;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfyDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 102, 102, 169], [171, 171, 197, 197, 229], [231, 231, 278, 278, 313], [316, 316, 334, 334, 1127], [1129, 1129, 1148, 1148, 1334], [1336, 1336, 1357, 1357, 1501], [1503, 1503, 1544, 1544, 1785], [1787, 1787, 1811, 1811, 1977], [1980, 1980, 2037, 2037, 2568]], "test": "untested"}
{"id": "wslcDf", "name": "Rorschach Ink Test", "author": "xjorma", "description": "I know it's not the first implementation, but that was the mood of the day.", "tags": ["ink", "psy", "rorschach", "cineshader"], "likes": 27, "viewed": 9820, "published": 3, "date": "1585791486", "time_retrieved": "2024-07-30T21:15:24.080543", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n//\tSimplex 3D Noise by Ian McEwan, Ashima Arts\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat fbm(vec3 p, int octaveNum)\n{\n\tfloat acc = 0.0;\t\n\tfloat freq = 1.0;\n\tfloat amp = 0.5;\n\tfor (int i = 0; i < octaveNum; i++)\n\t{\n\t\tacc += snoise(p) * amp;\n        p = p * 2.0;\n        amp *= 0.5;\n\t}\n\treturn acc;\n}\n\nfloat hash21(vec2 uv)\n{\n\treturn fract(sin(dot(uv.xy ,vec2(532.1231,1378.3453))) * 53211.1223);\n}\n\nconst vec3\tinkColor1  = vec3( 28,   28,  40) / 255.;\nconst vec3\tinkColor2  = vec3(255,   68,  23) / 255.;\nconst vec3\tpaperColor = vec3( 252, 232, 225) / 255.;\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2\tp = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec2\tsp = p;\n    sp.x = abs(sp.x);\n    \n    vec3 col = paperColor; \n    col += hash21(p) / 20.;   // grain\n    \n    float i1 = smoothstep(.03, 0., fbm(vec3(sp, iTime * 0.05 + 30.), 7) - 0.2 + length(p) * 0.5);\n    float i2 = smoothstep(.03, 0., fbm(vec3(sp, iTime * 0.04 + 16.), 7) + length(p) * 0.5);\n    \n    col = mix(col, inkColor2, i2 * (0.4 + 0.6 * (fbm(vec3(p * 0.75, iTime * 0.04 + 256.), 5))));\n    col = mix(col, inkColor1, i1 * (0.4 + 0.6 * (fbm(vec3(p * 0.75, iTime * 0.04 + 2445.), 5))));\n    \n    col = vignette(col, fragCoord / iResolution.xy, 0.3);\n\n    // Output to screen\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslcDf.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[114, 161, 182, 182, 219], [220, 220, 247, 247, 295], [297, 297, 318, 318, 2154], [2156, 2156, 2190, 2190, 2371], [2373, 2373, 2396, 2396, 2469], [2631, 2631, 2675, 2675, 2774], [2776, 2776, 2833, 2833, 3520]], "test": "untested"}
{"id": "tsfcWX", "name": "Korobeiniki (Sound Shader)", "author": "BigETI", "description": "This audio shader plays Tetris Type A using a Famicom/NES style audio player.\nThe included image shader contains tetriminoes dancing to the music.", "tags": ["sound", "music", "audio"], "likes": 16, "viewed": 726, "published": 3, "date": "1585789575", "time_retrieved": "2024-07-30T21:15:25.204539", "image_code": "const float fallSpeed = 2.0;\n\nconst float steerAmplitude = 2.0;\n\nconst float steerFrequency = 0.5;\n\nconst float turnSpeed = 2.5;\n\nconst float doublePi = 6.28318530718;\n\nconst uint numTetriminoBlocks = 12U;\n\nconst uint tetriminoBlockWidth = 4U;\n\nconst uint tetriminoBlockHeight = 4U;\n\nconst uint numTetriminoes = 7U;\n\nconst uint tetriminoWidth = 4U;\n\nconst uint tetriminoHeight = 4U;\n\n// 0: Normal\n// 1: Light\n// 2: Dark\nconst ivec3[] tetriminoBlocksColors = ivec3[]\n(\n    // Cyan\n    ivec3(0x00FFFFFF, 0xA3FFFFFF, 0x008A8AFF),\n    \n    // Red\n    ivec3(0xFF0000FF, 0xFF8D8DFF, 0x7A0000FF),\n    \n    // Green\n    ivec3(0x00FF00FF, 0x99FF99FF, 0x008A00FF),\n    \n    // Yellow\n    ivec3(0xFFFF00FF, 0xFFFFA3FF, 0x8A8A00FF),\n    \n    // Blue\n    ivec3(0x0000FFFF, 0x8383FFFF, 0x000082FF),\n    \n    // Orange\n    ivec3(0xFF8000FF, 0xFFC993FF, 0x864300FF),\n    \n    // Rose\n    ivec3(0xFF00FFFF, 0xFF89FFFF, 0x7A007AFF),\n    \n    // Pink\n    ivec3(0x8000FFFF, 0xC285FFFF, 0x45008AFF),\n    \n    // White\n    ivec3(0xE9E9E9FF, 0xFFFFFFFF, 0xB3B3B3FF),\n    \n    // Black\n    ivec3(0x454545FF, 0x868686FF, 0x000000FF),\n    \n    // Brown\n    ivec3(0x944114FF, 0xD46832FF, 0x421C0AFF),\n    \n    // Dark green\n    ivec3(0x008000FF, 0x1AC81AFF, 0x002C00FF)\n);\n\nconst uint tetriminoBlockColorIndices = 0xA9818195U;\n\nconst ivec4 tetriminoes = ivec4\n(\n    // Low: I\n    // High: L\n    0x62202222,\n    \n    // Low: Reverse L\n    // High: Square\n    0x06606440,\n    \n    // Low: T\n    // High: S\n    0x06300470,\n    \n    // Low: Z\n    // High: Nothing\n    0x00000360\n);\n\nvec4 RGBAToColor(const int color)\n{\n    return vec4(float((color >> 24) & 0xFF) / 255.0, float((color >> 16) & 0xFF) / 255.0, float((color >> 8) & 0xFF) / 255.0, float(color & 0xFF) / 255.0);\n}\n\nbool IsABlock(const uint xIndex, const uint yIndex, const uint tetriminoIndex)\n{\n    return (tetriminoes[tetriminoIndex / 2U] & int(0x1U << (((tetriminoIndex % 2U) * 16U) + (yIndex * tetriminoWidth) + xIndex))) > 0;\n}\n\nint GetBlockRGBA(const uint xIndex, const uint yIndex, const uint blockIndex)\n{\n    return tetriminoBlocksColors[blockIndex][(tetriminoBlockColorIndices >> ((yIndex * 8U) + (xIndex * 2U))) & 0x3U];\n}\n\nvec4 Tetrimino(const uint tetriminoIndex, const uint blockIndex, const uint rotation, const vec2 uv)\n{\n    vec4 ret = vec4(0.0);\n    vec2 flipped_uv = vec2(uv.x, 1.0 - uv.y);\n    if ((uv.x >= 0.0) && (uv.x < 1.0) && (uv.y >= 0.0) && (uv.y < 1.0))\n    {\n        uint x_index = uint(flipped_uv.x * float(tetriminoWidth));\n        uint y_index = uint(flipped_uv.y * float(tetriminoHeight));\n        uint temp;\n        switch (rotation % 4U)\n        {\n            case 1U:\n            \ttemp = tetriminoHeight - y_index - 1U;\n            \ty_index = x_index;\n            \tx_index = temp;\n            \tbreak;\n            case 2U:\n            \tx_index = tetriminoWidth - x_index - 1U;\n            \ty_index = tetriminoHeight - y_index - 1U;\n            \tbreak;\n            case 3U:\n            \ttemp = y_index;\n            \ty_index = tetriminoWidth - x_index - 1U;\n            \tx_index = temp;\n            \tbreak;\n        }\n        if (IsABlock(x_index, y_index, tetriminoIndex))\n        {\n        \tvec2 block_uv = vec2(fract(flipped_uv.x * float(tetriminoWidth)), fract(flipped_uv.y * float(tetriminoHeight)));\n            uint block_x_index = uint(block_uv.x * float(tetriminoBlockWidth));\n            uint block_y_index = uint(block_uv.y * float(tetriminoBlockHeight));\n            ret = RGBAToColor(GetBlockRGBA(block_x_index, block_y_index, blockIndex));\n        }\n        \n    }\n    return ret;\n}\n\nint Random(const int seed)\n{\n    return (843314861 * seed + 453816693) % 1073741824;\n}\n\nvec4 AlphaBlend(const vec4 bottom, const in vec4 top)\n{\n    float alpha = top.a + bottom.a * (1.0 - top.a);\n    return vec4((top.rgb * top.a + bottom.rgb * bottom.a * (1.0 - top.a)) / alpha, alpha);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 view_uv = fragCoord / iResolution.y;\n    vec2 uv = ((fragCoord - (iResolution.xy * 0.5)) * 10.0) / iResolution.y;\n    vec2 world_uv = vec2(uv.x + 100.25 + (sin(iTime * steerFrequency * doublePi) * steerAmplitude * 0.5), uv.y + 100.0 + (iTime * fallSpeed));\n    vec2 tetrimino_uv = fract(world_uv) * 1.5f;\n    int random = Random(int(world_uv.x) + (int(world_uv.y) * int(numTetriminoes)));\n    fragColor = vec4(AlphaBlend(mix(vec4(0.0, 0.0625, 0.125, 1.0), vec4(0.0, 0.0, 0.0, 1.0), view_uv.y), Tetrimino(uint(abs(random)) % numTetriminoes, uint(abs(random)) % numTetriminoBlocks, uint(abs(random) + int((((random % 2) == 0) ? iTime : -iTime) * turnSpeed)) % 4U, tetrimino_uv)).xyz, 1.0);\n}", "image_inputs": [], "sound_code": "struct AudioEffects\n{\n    float duration;\n    float volume;\n    float leftRight;\n    float fadeInTime;\n    float falloffTime;\n};\n\nstruct SquareNote\n{\n    float frequency;\n    float highRatio;\n    float playAtTime;\n    uint audioEffectsIndex;\n};\n\nstruct TriangleNote\n{\n    float frequency;\n    float triangleOffset;\n    float playAtTime;\n    uint audioEffectsIndex;\n};\n\nstruct SineNote\n{\n    float frequency;\n    float playAtTime;\n    uint audioEffectsIndex;\n};\n\nstruct WhiteNoiseNote\n{\n    float playAtTime;\n    uint audioEffectsIndex;\n};\n\nconst float repeatMusicTime = 38.4;\n\nconst uint repeatMusic = 4U;\n\nconst float musicPlayTime = repeatMusicTime * float(repeatMusic);\n\nconst uint antiAliasing = 4U;\n\nconst float halfPi = 1.57079632679;\n\nconst float pi = 3.14159265359;\n\nconst float doublePi = 6.28318530718;\n\nconst float c1 = 32.70319566257483;\n\nconst float cS1 = 34.64782887210902;\n\nconst float d1 = 36.70809598967594;\n\nconst float dS1 = 38.89087296526011;\n\nconst float e1 = 41.20344461410874;\n\nconst float f1 = 43.653528929125486;\n\nconst float fS1 = 46.24930283895431;\n\nconst float g1 = 48.999429497718666;\n\nconst float gS1 = 51.91308719749314;\n\nconst float a1 = 55.0;\n\nconst float aS1 = 58.27047018976124;\n\nconst float b1 = 61.7354126570155;\n\nconst float c2 = 65.40639132514966;\n\nconst float cS2 = 69.29565774421803;\n\nconst float d2 = 73.41619197935188;\n\nconst float dS2 = 77.78174593052022;\n\nconst float e2 = 82.40688922821748;\n\nconst float f2 = 87.30705785825097;\n\nconst float fS2 = 92.49860567790861;\n\nconst float g2 = 97.99885899543733;\n\nconst float gS2 = 103.82617439498628;\n\nconst float a2 = 110.0;\n\nconst float aS2 = 116.54094037952248;\n\nconst float b2 = 123.47082531403103;\n\nconst float c3 = 130.8127826502993;\n\nconst float cS3 = 138.59131548843604;\n\nconst float d3 = 146.8323839587038;\n\nconst float dS3 = 155.56349186104043;\n\nconst float e3 = 164.81377845643496;\n\nconst float f3 = 174.61411571650194;\n\nconst float fS3 = 184.99721135581723;\n\nconst float g3 = 195.99771799087463;\n\nconst float gS3 = 207.65234878997256;\n\nconst float a3 = 220.0;\n\nconst float aS3 = 233.08188075904496;\n\nconst float b3 = 246.94165062806206;\n\nconst float c4 = 261.6255653005986;\n\nconst float cS4 = 277.1826309768721;\n\nconst float d4 = 293.6647679174076;\n\nconst float dS4 = 311.12698372208087;\n\nconst float e4 = 329.6275569128699;\n\nconst float f4 = 349.2282314330039;\n\nconst float fS4 = 369.99442271163446;\n\nconst float g4 = 391.99543598174927;\n\nconst float gS4 = 415.3046975799451;\n\nconst float a4 = 440.0;\n\nconst float aS4 = 466.1637615180899;\n\nconst float b4 = 493.8833012561241;\n\nconst float c5 = 523.2511306011972;\n\nconst float cS5 = 554.3652619537442;\n\nconst float d5 = 587.3295358348151;\n\nconst float dS5 = 622.2539674441618;\n\nconst float e5 = 659.2551138257398;\n\nconst float f5 = 698.4564628660078;\n\nconst float fS5 = 739.9888454232689;\n\nconst float g5 = 783.9908719634986;\n\nconst float gS5 = 830.6093951598903;\n\nconst float a5 = 880.0;\n\nconst float aS5 = 932.3275230361799;\n\nconst float b5 = 987.7666025122483;\n\nconst AudioEffects[] audioEffectsArray = AudioEffects[]\n(\n    AudioEffects(0.6, 0.03125, 0.5,  0.0,               0.25),\n    AudioEffects(0.3, 0.03125, 0.5,  0.0,               0.25),\n    AudioEffects(0.2, 0.03125, 0.5,  0.03125 * 0.03125, 0.25),\n    AudioEffects(0.1, 0.03125, 0.5,  0.03125 * 0.03125, 0.25),\n    AudioEffects(0.2, 0.0625,  0.25, 0.0,               0.0625),\n    AudioEffects(0.1, 0.0625,  0.25, 0.03125 * 0.03125, 0.0625),\n    AudioEffects(0.1, 0.0625,  0.75, 0.03125 * 0.03125, 0.0625),\n    AudioEffects(0.0, 0.0,     0.0,  0.0,               0.0),\n    AudioEffects(0.0, 0.125,   0.75, 0.03125 * 0.125,   0.125)\n);\n\nconst uint longerSquareAudioEffectsIndex = 0U;\n\nconst uint longSquareAudioEffectsIndex = 1U;\n\nconst uint shortSquareAudioEffectsIndex = 2U;\n\nconst uint shorterSquareAudioEffectsIndex = 3U;\n\nconst uint leftLongTriangleAudioEffectsIndex = 4U;\n \nconst uint leftShortTriangleAudioEffectsIndex = 5U;\n\nconst uint rightShortTriangleAudioEffectsIndex = 6U;\n\nconst uint sineAudioEffectsIndex = 7U;\n\nconst uint whiteNoiseAudioEffectsIndex = 8U;\n\nconst SquareNote[] squareNotes = SquareNote[]\n(\n    // Tetris Type A\n    \n    // Part 1\n    SquareNote(e5, 0.5, 0.0, longSquareAudioEffectsIndex),\n    SquareNote(b4, 0.5, 0.4, shortSquareAudioEffectsIndex),\n    SquareNote(c5, 0.5, 0.6, shortSquareAudioEffectsIndex),\n    SquareNote(d5, 0.5, 0.8, shortSquareAudioEffectsIndex),\n    SquareNote(e5, 0.5, 1.0, shorterSquareAudioEffectsIndex),\n    SquareNote(d5, 0.5, 1.1, shorterSquareAudioEffectsIndex),\n    SquareNote(c5, 0.5, 1.2, shortSquareAudioEffectsIndex),\n    SquareNote(b4, 0.5, 1.4, shortSquareAudioEffectsIndex),\n    SquareNote(a4, 0.5, 1.6, longSquareAudioEffectsIndex),\n    SquareNote(a4, 0.5, 2.0, shortSquareAudioEffectsIndex),\n    SquareNote(c5, 0.5, 2.2, shortSquareAudioEffectsIndex),\n    SquareNote(e5, 0.5, 2.4, shortSquareAudioEffectsIndex),\n    SquareNote(e5, 0.5, 2.6, shorterSquareAudioEffectsIndex),\n    SquareNote(e5, 0.5, 2.7, shorterSquareAudioEffectsIndex),\n    SquareNote(d5, 0.5, 2.8, shortSquareAudioEffectsIndex),\n    SquareNote(c5, 0.5, 3.0, shortSquareAudioEffectsIndex),\n    SquareNote(b4, 0.5, 3.2, longSquareAudioEffectsIndex),\n    SquareNote(b4, 0.5, 3.6, shortSquareAudioEffectsIndex),\n    SquareNote(c5, 0.5, 3.8, shortSquareAudioEffectsIndex),\n    SquareNote(d5, 0.5, 4.0, longSquareAudioEffectsIndex),\n    SquareNote(e5, 0.5, 4.4, longSquareAudioEffectsIndex),\n    SquareNote(c5, 0.5, 4.8, longSquareAudioEffectsIndex),\n    SquareNote(a4, 0.5, 5.2, longSquareAudioEffectsIndex),\n    SquareNote(a4, 0.5, 5.6, longSquareAudioEffectsIndex),\n    SquareNote(d5, 0.5, 6.6, longSquareAudioEffectsIndex),\n    SquareNote(f5, 0.5, 7.0, shortSquareAudioEffectsIndex),\n    SquareNote(a5, 0.5, 7.2, shortSquareAudioEffectsIndex),\n    SquareNote(a5, 0.5, 7.4, shorterSquareAudioEffectsIndex),\n    SquareNote(a5, 0.5, 7.5, shorterSquareAudioEffectsIndex),\n    SquareNote(g5, 0.5, 7.6, shortSquareAudioEffectsIndex),\n    SquareNote(f5, 0.5, 7.8, shortSquareAudioEffectsIndex),\n    SquareNote(e5, 0.5, 8.0, longSquareAudioEffectsIndex),\n    SquareNote(c5, 0.5, 8.6, shortSquareAudioEffectsIndex),\n    SquareNote(e5, 0.5, 8.8, shortSquareAudioEffectsIndex),\n    SquareNote(e5, 0.5, 9.0, shorterSquareAudioEffectsIndex),\n    SquareNote(e5, 0.5, 9.1, shorterSquareAudioEffectsIndex),\n    SquareNote(d5, 0.5, 9.2, shortSquareAudioEffectsIndex),\n    SquareNote(c5, 0.5, 9.4, shortSquareAudioEffectsIndex),\n    SquareNote(b4, 0.5, 9.6, longSquareAudioEffectsIndex),\n    SquareNote(b4, 0.5, 10.0, shortSquareAudioEffectsIndex),\n    SquareNote(c5, 0.5, 10.2, shortSquareAudioEffectsIndex),\n    SquareNote(d5, 0.5, 10.4, longSquareAudioEffectsIndex),\n    SquareNote(e5, 0.5, 10.8, longSquareAudioEffectsIndex),\n    SquareNote(c5, 0.5, 11.2, longSquareAudioEffectsIndex),\n    SquareNote(a4, 0.5, 11.6, longSquareAudioEffectsIndex),\n    SquareNote(a4, 0.5, 12.0, longSquareAudioEffectsIndex),\n    \n    // Part 2\n    SquareNote(e5, 0.875, 0.0 + 12.8, longSquareAudioEffectsIndex),\n    SquareNote(b4, 0.875, 0.4 + 12.8, shortSquareAudioEffectsIndex),\n    SquareNote(c5, 0.875, 0.6 + 12.8, shortSquareAudioEffectsIndex),\n    SquareNote(d5, 0.875, 0.8 + 12.8, shortSquareAudioEffectsIndex),\n    SquareNote(e5, 0.875, 1.0 + 12.8, shorterSquareAudioEffectsIndex),\n    SquareNote(d5, 0.875, 1.1 + 12.8, shorterSquareAudioEffectsIndex),\n    SquareNote(c5, 0.875, 1.2 + 12.8, shortSquareAudioEffectsIndex),\n    SquareNote(b4, 0.875, 1.4 + 12.8, shortSquareAudioEffectsIndex),\n    SquareNote(a4, 0.875, 1.6 + 12.8, longSquareAudioEffectsIndex),\n    SquareNote(a4, 0.875, 2.0 + 12.8, shortSquareAudioEffectsIndex),\n    SquareNote(c5, 0.875, 2.2 + 12.8, shortSquareAudioEffectsIndex),\n    SquareNote(e5, 0.875, 2.4 + 12.8, shortSquareAudioEffectsIndex),\n    SquareNote(e5, 0.875, 2.6 + 12.8, shorterSquareAudioEffectsIndex),\n    SquareNote(e5, 0.875, 2.7 + 12.8, shorterSquareAudioEffectsIndex),\n    SquareNote(d5, 0.875, 2.8 + 12.8, shortSquareAudioEffectsIndex),\n    SquareNote(c5, 0.875, 3.0 + 12.8, shortSquareAudioEffectsIndex),\n    SquareNote(b4, 0.875, 3.2 + 12.8, longSquareAudioEffectsIndex),\n    SquareNote(b4, 0.875, 3.6 + 12.8, shortSquareAudioEffectsIndex),\n    SquareNote(c5, 0.875, 3.8 + 12.8, shortSquareAudioEffectsIndex),\n    SquareNote(d5, 0.875, 4.0 + 12.8, longSquareAudioEffectsIndex),\n    SquareNote(e5, 0.875, 4.4 + 12.8, longSquareAudioEffectsIndex),\n    SquareNote(c5, 0.875, 4.8 + 12.8, longSquareAudioEffectsIndex),\n    SquareNote(a4, 0.875, 5.2 + 12.8, longSquareAudioEffectsIndex),\n    SquareNote(a4, 0.875, 5.6 + 12.8, longSquareAudioEffectsIndex),\n    SquareNote(d5, 0.75, 6.6 + 12.8, longSquareAudioEffectsIndex),\n    SquareNote(f5, 0.75, 7.0 + 12.8, shortSquareAudioEffectsIndex),\n    SquareNote(a5, 0.75, 7.2 + 12.8, shortSquareAudioEffectsIndex),\n    SquareNote(a5, 0.75, 7.4 + 12.8, shorterSquareAudioEffectsIndex),\n    SquareNote(a5, 0.75, 7.5 + 12.8, shorterSquareAudioEffectsIndex),\n    SquareNote(g5, 0.75, 7.6 + 12.8, shortSquareAudioEffectsIndex),\n    SquareNote(f5, 0.75, 7.8 + 12.8, shortSquareAudioEffectsIndex),\n    SquareNote(e5, 0.75, 8.0 + 12.8, longSquareAudioEffectsIndex),\n    SquareNote(c5, 0.75, 8.6 + 12.8, shortSquareAudioEffectsIndex),\n    SquareNote(e5, 0.75, 8.8 + 12.8, shortSquareAudioEffectsIndex),\n    SquareNote(e5, 0.75, 9.0 + 12.8, shorterSquareAudioEffectsIndex),\n    SquareNote(e5, 0.75, 9.1 + 12.8, shorterSquareAudioEffectsIndex),\n    SquareNote(d5, 0.75, 9.2 + 12.8, shortSquareAudioEffectsIndex),\n    SquareNote(c5, 0.75, 9.4 + 12.8, shortSquareAudioEffectsIndex),\n    SquareNote(b4, 0.75, 9.6 + 12.8, longSquareAudioEffectsIndex),\n    SquareNote(b4, 0.75, 10.0 + 12.8, shortSquareAudioEffectsIndex),\n    SquareNote(c5, 0.75, 10.2 + 12.8, shortSquareAudioEffectsIndex),\n    SquareNote(d5, 0.75, 10.4 + 12.8, longSquareAudioEffectsIndex),\n    SquareNote(e5, 0.75, 10.8 + 12.8, longSquareAudioEffectsIndex),\n    SquareNote(c5, 0.75, 11.2 + 12.8, longSquareAudioEffectsIndex),\n    SquareNote(a4, 0.75, 11.6 + 12.8, longSquareAudioEffectsIndex),\n    SquareNote(a4, 0.75, 12.0 + 12.8, longSquareAudioEffectsIndex),\n    \n    // Part 3\n    SquareNote(e4,  0.5, 25.6, longerSquareAudioEffectsIndex),\n    SquareNote(c4,  0.5, 26.4, longerSquareAudioEffectsIndex),\n    SquareNote(d4,  0.5, 27.2, longerSquareAudioEffectsIndex),\n    SquareNote(b3,  0.5, 28.0, longerSquareAudioEffectsIndex),\n    SquareNote(c4,  0.5, 28.8, longerSquareAudioEffectsIndex),\n    SquareNote(a3,  0.5, 29.6, longerSquareAudioEffectsIndex),\n    SquareNote(gS3, 0.5, 30.4, longerSquareAudioEffectsIndex),\n    SquareNote(b3,  0.5, 31.2, longerSquareAudioEffectsIndex),\n    SquareNote(e4,  0.5, 32.0, longerSquareAudioEffectsIndex),\n    SquareNote(c4,  0.5, 32.8, longerSquareAudioEffectsIndex),\n    SquareNote(d4,  0.5, 33.6, longerSquareAudioEffectsIndex),\n    SquareNote(b3,  0.5, 34.4, longerSquareAudioEffectsIndex),\n    SquareNote(c5,  0.5, 35.2, longSquareAudioEffectsIndex),\n    SquareNote(e5,  0.5, 35.6, longSquareAudioEffectsIndex),\n    SquareNote(a5,  0.5, 36.0, longerSquareAudioEffectsIndex),\n    SquareNote(gS5, 0.5, 36.8, longerSquareAudioEffectsIndex)\n);\n\nconst TriangleNote[] triangleNotes = TriangleNote[]\n(\n    // Tetris Type A\n    \n    // Part 1\n    TriangleNote(e2,  0.5, 0.0,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(e3,  0.5, 0.2,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(e2,  0.5, 0.4,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(e3,  0.5, 0.6,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(e2,  0.5, 0.8,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(e3,  0.5, 1.0,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(e2,  0.5, 1.2,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(e3,  0.5, 1.4,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(a2,  0.5, 1.6,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(a3,  0.5, 1.8,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(a2,  0.5, 2.0,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(a3,  0.5, 2.2,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(a2,  0.5, 2.4,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(a3,  0.5, 2.6,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(a2,  0.5, 2.8,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(a3,  0.5, 3.0,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(gS2, 0.5, 3.2,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(gS3, 0.5, 3.4,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(gS2, 0.5, 3.6,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(gS3, 0.5, 3.8,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(e2,  0.5, 4.0,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(e3,  0.5, 4.2,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(e2,  0.5, 4.4,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(e3,  0.5, 4.6,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(a2,  0.5, 4.8,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(a3,  0.5, 5.0,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(a2,  0.5, 5.2,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(a3,  0.5, 5.4,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(a2,  0.5, 5.6,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(a3,  0.5, 5.8,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(b3,  0.5, 6.0,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(c4,  0.5, 6.2,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(d2,  0.5, 6.4,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(d3,  0.5, 6.6,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(d2,  0.5, 6.8,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(d3,  0.5, 7.0,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(d2,  0.5, 7.2,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(d3,  0.5, 7.4,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(d2,  0.5, 7.6,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(d3,  0.5, 7.8,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(c2,  0.5, 8.0,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(c3,  0.5, 8.2,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(c2,  0.5, 8.4,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(c3,  0.5, 8.6,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(c2,  0.5, 8.8,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(c3,  0.5, 9.0,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(c2,  0.5, 9.2,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(c3,  0.5, 9.4,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(b2,  0.5, 9.6,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(b3,  0.5, 9.8,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(b2,  0.5, 10.0, leftShortTriangleAudioEffectsIndex),\n    TriangleNote(b3,  0.5, 10.2, rightShortTriangleAudioEffectsIndex),\n    TriangleNote(e2,  0.5, 10.4, leftShortTriangleAudioEffectsIndex),\n    TriangleNote(e3,  0.5, 10.6, rightShortTriangleAudioEffectsIndex),\n    TriangleNote(e2,  0.5, 10.8, leftShortTriangleAudioEffectsIndex),\n    TriangleNote(e3,  0.5, 11.0, rightShortTriangleAudioEffectsIndex),\n    TriangleNote(a2,  0.5, 11.2, leftShortTriangleAudioEffectsIndex),\n    TriangleNote(a3,  0.5, 11.4, rightShortTriangleAudioEffectsIndex),\n    TriangleNote(a2,  0.5, 11.6, leftShortTriangleAudioEffectsIndex),\n    TriangleNote(a3,  0.5, 11.8, rightShortTriangleAudioEffectsIndex),\n    TriangleNote(a2,  0.5, 12.0, leftLongTriangleAudioEffectsIndex),\n    \n    // Part 2\n    TriangleNote(e2,  0.5, 0.0 + 12.8,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(e3,  0.5, 0.2 + 12.8,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(e2,  0.5, 0.4 + 12.8,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(e3,  0.5, 0.6 + 12.8,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(e2,  0.5, 0.8 + 12.8,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(e3,  0.5, 1.0 + 12.8,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(e2,  0.5, 1.2 + 12.8,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(e3,  0.5, 1.4 + 12.8,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(a2,  0.5, 1.6 + 12.8,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(a3,  0.5, 1.8 + 12.8,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(a2,  0.5, 2.0 + 12.8,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(a3,  0.5, 2.2 + 12.8,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(a2,  0.5, 2.4 + 12.8,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(a3,  0.5, 2.6 + 12.8,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(a2,  0.5, 2.8 + 12.8,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(a3,  0.5, 3.0 + 12.8,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(gS2, 0.5, 3.2 + 12.8,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(gS3, 0.5, 3.4 + 12.8,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(gS2, 0.5, 3.6 + 12.8,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(gS3, 0.5, 3.8 + 12.8,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(e2,  0.5, 4.0 + 12.8,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(e3,  0.5, 4.2 + 12.8,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(e2,  0.5, 4.4 + 12.8,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(e3,  0.5, 4.6 + 12.8,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(a2,  0.5, 4.8 + 12.8,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(a3,  0.5, 5.0 + 12.8,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(a2,  0.5, 5.2 + 12.8,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(a3,  0.5, 5.4 + 12.8,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(a2,  0.5, 5.6 + 12.8,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(a3,  0.5, 5.8 + 12.8,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(b3,  0.5, 6.0 + 12.8,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(c4,  0.5, 6.2 + 12.8,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(d2,  0.5, 6.4 + 12.8,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(d3,  0.5, 6.6 + 12.8,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(d2,  0.5, 6.8 + 12.8,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(d3,  0.5, 7.0 + 12.8,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(d2,  0.5, 7.2 + 12.8,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(d3,  0.5, 7.4 + 12.8,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(d2,  0.5, 7.6 + 12.8,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(d3,  0.5, 7.8 + 12.8,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(c2,  0.5, 8.0 + 12.8,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(c3,  0.5, 8.2 + 12.8,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(c2,  0.5, 8.4 + 12.8,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(c3,  0.5, 8.6 + 12.8,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(c2,  0.5, 8.8 + 12.8,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(c3,  0.5, 9.0 + 12.8,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(c2,  0.5, 9.2 + 12.8,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(c3,  0.5, 9.4 + 12.8,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(b2,  0.5, 9.6 + 12.8,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(b3,  0.5, 9.8 + 12.8,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(b2,  0.5, 10.0 + 12.8, leftShortTriangleAudioEffectsIndex),\n    TriangleNote(b3,  0.5, 10.2 + 12.8, rightShortTriangleAudioEffectsIndex),\n    TriangleNote(e2,  0.5, 10.4 + 12.8, leftShortTriangleAudioEffectsIndex),\n    TriangleNote(e3,  0.5, 10.6 + 12.8, rightShortTriangleAudioEffectsIndex),\n    TriangleNote(e2,  0.5, 10.8 + 12.8, leftShortTriangleAudioEffectsIndex),\n    TriangleNote(e3,  0.5, 11.0 + 12.8, rightShortTriangleAudioEffectsIndex),\n    TriangleNote(a2,  0.5, 11.2 + 12.8, leftShortTriangleAudioEffectsIndex),\n    TriangleNote(a3,  0.5, 11.4 + 12.8, rightShortTriangleAudioEffectsIndex),\n    TriangleNote(a2,  0.5, 11.6 + 12.8, leftShortTriangleAudioEffectsIndex),\n    TriangleNote(a3,  0.5, 11.8 + 12.8, rightShortTriangleAudioEffectsIndex),\n    TriangleNote(a2,  0.5, 12.0 + 12.8, leftLongTriangleAudioEffectsIndex),\n    \n    // Part 3\n    TriangleNote(e2,  0.5, 0.0 + 25.6,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(e3,  0.5, 0.2 + 25.6,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(e2,  0.5, 0.4 + 25.6,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(e3,  0.5, 0.6 + 25.6,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(e2,  0.5, 0.8 + 25.6,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(e3,  0.5, 1.0 + 25.6,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(e2,  0.5, 1.2 + 25.6,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(e3,  0.5, 1.4 + 25.6,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(a2,  0.5, 1.6 + 25.6,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(a3,  0.5, 1.8 + 25.6,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(a2,  0.5, 2.0 + 25.6,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(a3,  0.5, 2.2 + 25.6,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(a2,  0.5, 2.4 + 25.6,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(a3,  0.5, 2.6 + 25.6,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(a2,  0.5, 2.8 + 25.6,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(a3,  0.5, 3.0 + 25.6,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(gS2, 0.5, 3.2 + 25.6,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(gS3, 0.5, 3.4 + 25.6,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(gS2, 0.5, 3.6 + 25.6,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(gS3, 0.5, 3.8 + 25.6,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(e2,  0.5, 4.0 + 25.6,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(e3,  0.5, 4.2 + 25.6,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(e2,  0.5, 4.4 + 25.6,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(e3,  0.5, 4.6 + 25.6,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(a2,  0.5, 4.8 + 25.6,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(a3,  0.5, 5.0 + 25.6,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(a2,  0.5, 5.2 + 25.6,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(a3,  0.5, 5.4 + 25.6,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(a2,  0.5, 5.6 + 25.6,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(a3,  0.5, 5.8 + 25.6,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(b3,  0.5, 6.0 + 25.6,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(c4,  0.5, 6.2 + 25.6,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(d2,  0.5, 6.4 + 25.6,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(d3,  0.5, 6.6 + 25.6,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(d2,  0.5, 6.8 + 25.6,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(d3,  0.5, 7.0 + 25.6,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(d2,  0.5, 7.2 + 25.6,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(d3,  0.5, 7.4 + 25.6,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(d2,  0.5, 7.6 + 25.6,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(d3,  0.5, 7.8 + 25.6,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(c2,  0.5, 8.0 + 25.6,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(c3,  0.5, 8.2 + 25.6,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(c2,  0.5, 8.4 + 25.6,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(c3,  0.5, 8.6 + 25.6,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(c2,  0.5, 8.8 + 25.6,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(c3,  0.5, 9.0 + 25.6,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(c2,  0.5, 9.2 + 25.6,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(c3,  0.5, 9.4 + 25.6,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(b2,  0.5, 9.6 + 25.6,  leftShortTriangleAudioEffectsIndex),\n    TriangleNote(b3,  0.5, 9.8 + 25.6,  rightShortTriangleAudioEffectsIndex),\n    TriangleNote(b2,  0.5, 10.0 + 25.6, leftShortTriangleAudioEffectsIndex),\n    TriangleNote(b3,  0.5, 10.2 + 25.6, rightShortTriangleAudioEffectsIndex),\n    TriangleNote(e2,  0.5, 10.4 + 25.6, leftShortTriangleAudioEffectsIndex),\n    TriangleNote(e3,  0.5, 10.6 + 25.6, rightShortTriangleAudioEffectsIndex),\n    TriangleNote(e2,  0.5, 10.8 + 25.6, leftShortTriangleAudioEffectsIndex),\n    TriangleNote(e3,  0.5, 11.0 + 25.6, rightShortTriangleAudioEffectsIndex),\n    TriangleNote(a2,  0.5, 11.2 + 25.6, leftShortTriangleAudioEffectsIndex),\n    TriangleNote(a3,  0.5, 11.4 + 25.6, rightShortTriangleAudioEffectsIndex),\n    TriangleNote(a2,  0.5, 11.6 + 25.6, leftShortTriangleAudioEffectsIndex),\n    TriangleNote(a3,  0.5, 11.8 + 25.6, rightShortTriangleAudioEffectsIndex),\n    TriangleNote(a2,  0.5, 12.0 + 25.6, leftLongTriangleAudioEffectsIndex)\n);\n\nconst SineNote[] sineNotes = SineNote[]\n(\n    // Empty\n    SineNote(0.0, 0.0, sineAudioEffectsIndex)\n);\n\nconst WhiteNoiseNote[] whiteNoiseNotes = WhiteNoiseNote[]\n(\n    // Tetris Type A\n    \n    // Part 1\n    WhiteNoiseNote(0.0,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(0.2,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(0.4,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(0.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(0.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(1.0,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(1.1,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(1.2,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(1.4,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(1.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(1.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(2.0,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(2.2,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(2.4,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(2.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(2.7,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(2.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(3.0,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(3.2,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(3.4,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(3.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(3.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(4.0,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(4.2,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(4.3,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(4.4,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(4.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(4.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(5.0,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(5.2,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(5.4,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(5.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(5.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(5.9,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(6.0,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(6.2,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(6.4,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(6.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(6.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(7.0,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(7.2,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(7.4,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(7.5,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(7.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(7.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(8.0,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(8.2,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(8.4,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(8.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(8.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(9.0,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(9.1,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(9.2,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(9.4,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(9.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(9.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(10.0, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(10.2, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(10.4, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(10.6, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(10.7, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(10.8, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(11.0, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(11.2, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(11.4, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(11.6, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(11.8, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(12.0, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(12.2, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(12.3, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(12.4, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(12.6, whiteNoiseAudioEffectsIndex),\n    \n    // Part 2\n    WhiteNoiseNote(0.0 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(0.2 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(0.4 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(0.6 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(0.8 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(1.0 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(1.1 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(1.2 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(1.4 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(1.6 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(1.8 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(2.0 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(2.2 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(2.4 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(2.6 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(2.7 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(2.8 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(3.0 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(3.2 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(3.4 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(3.6 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(3.8 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(4.0 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(4.2 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(4.3 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(4.4 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(4.6 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(4.8 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(5.0 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(5.2 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(5.4 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(5.6 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(5.8 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(5.9 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(6.0 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(6.2 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(6.4 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(6.6 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(6.8 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(7.0 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(7.2 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(7.4 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(7.5 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(7.6 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(7.8 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(8.0 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(8.2 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(8.4 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(8.6 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(8.8 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(9.0 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(9.1 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(9.2 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(9.4 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(9.6 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(9.8 + 12.8,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(10.0 + 12.8, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(10.2 + 12.8, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(10.4 + 12.8, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(10.6 + 12.8, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(10.7 + 12.8, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(10.8 + 12.8, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(11.0 + 12.8, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(11.2 + 12.8, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(11.4 + 12.8, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(11.6 + 12.8, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(11.8 + 12.8, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(12.0 + 12.8, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(12.2 + 12.8, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(12.3 + 12.8, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(12.4 + 12.8, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(12.6 + 12.8, whiteNoiseAudioEffectsIndex),\n    \n    // Part 3\n    WhiteNoiseNote(0.0 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(0.2 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(0.4 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(0.6 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(0.8 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(1.0 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(1.1 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(1.2 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(1.4 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(1.6 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(1.8 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(2.0 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(2.2 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(2.4 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(2.6 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(2.7 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(2.8 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(3.0 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(3.2 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(3.4 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(3.6 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(3.8 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(4.0 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(4.2 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(4.3 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(4.4 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(4.6 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(4.8 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(5.0 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(5.2 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(5.4 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(5.6 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(5.8 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(5.9 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(6.0 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(6.2 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(6.4 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(6.6 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(6.8 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(7.0 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(7.2 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(7.4 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(7.5 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(7.6 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(7.8 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(8.0 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(8.2 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(8.4 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(8.6 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(8.8 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(9.0 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(9.1 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(9.2 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(9.4 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(9.6 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(9.8 + 25.6,  whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(10.0 + 25.6, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(10.2 + 25.6, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(10.4 + 25.6, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(10.6 + 25.6, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(10.7 + 25.6, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(10.8 + 25.6, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(11.0 + 25.6, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(11.2 + 25.6, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(11.4 + 25.6, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(11.6 + 25.6, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(11.8 + 25.6, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(12.0 + 25.6, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(12.2 + 25.6, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(12.3 + 25.6, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(12.4 + 25.6, whiteNoiseAudioEffectsIndex),\n    WhiteNoiseNote(12.6 + 25.6, whiteNoiseAudioEffectsIndex)\n);\n\nbool IsInTime(const float duration, const float playAtTime, const float time, out float relativeTime)\n{\n    relativeTime = time - playAtTime;\n    return ((time >= playAtTime) && ((time - duration) < playAtTime));\n}\n\nvec2 ProcessLeftRight(const float leftRight)\n{\n    return vec2((leftRight > 0.5) ? cos((leftRight - 0.5) * pi) : 1.0, (leftRight < 0.5) ? cos((0.5 - leftRight) * pi) : 1.0);\n}\n\nfloat ProcessFadeIn(const float fadeInTime, const float time)\n{\n    return (((time < fadeInTime) && (fadeInTime > 0.0)) ? (1.0 - cos((time * halfPi) / fadeInTime)) : 1.0);\n}\n\nfloat ProcessFalloff(const float falloffTime, const float time)\n{\n    return (((falloffTime > 0.0) && time >= 0.0) ? exp((-time * doublePi) / falloffTime) : 1.0);\n}\n\nfloat SquareWave(const float frequency, const float highRatio, const float time)\n{\n    float beats_per_second = 1.0 / frequency;\n    float normalized_square_time = mod(time, beats_per_second) / beats_per_second;\n    return ((normalized_square_time > highRatio) ? -1.0 : 1.0);\n}\n\nfloat TriangleWave(const float frequency, const float triangleAlignment, const float time)\n{\n    float ret = 1.0;\n    float beats_per_second = 1.0 / frequency;\n    float normalized_triangle_time = mod(time, beats_per_second) / beats_per_second;\n    if (normalized_triangle_time < triangleAlignment)\n    {\n        ret = (clamp(normalized_triangle_time / triangleAlignment, 0.0, 1.0) * 2.0) - 1.0;\n    }\n    else if (normalized_triangle_time > triangleAlignment)\n    {\n        ret = 1.0 - (clamp((normalized_triangle_time - triangleAlignment) / (1.0 - triangleAlignment), 0.0, 1.0) * 2.0);\n    }\n    return ret;\n}\n\nfloat SineWave(const float frequency, const float time)\n{\n    return sin(time * doublePi * frequency);\n}\n\nfloat WhiteNoiseWave(const float time)\n{\n    return (fract(sin(mod(time, 1.0) * 12865.9898) * 43758.5453) * 2.0) - 1.0;\n}\n\nvec2 ProcessAudioEffects(const uint audioEffectsIndex, const float time)\n{\n    AudioEffects audio_effects = audioEffectsArray[audioEffectsIndex];\n    return ProcessLeftRight(audio_effects.leftRight) * (audio_effects.volume * ProcessFadeIn(audio_effects.fadeInTime, time) * ProcessFalloff(audio_effects.falloffTime, time - audio_effects.fadeInTime - audio_effects.duration));\n}\n\nfloat GetDuration(const uint audioEffectsIndex)\n{\n    AudioEffects audio_effects = audioEffectsArray[audioEffectsIndex];\n    return audio_effects.fadeInTime + audio_effects.duration + audio_effects.falloffTime;\n}\n\nvec2 PlayNotes(const float time)\n{\n    vec2 ret = vec2(0.0);\n    SquareNote square_note;\n    TriangleNote triangle_note;\n    SineNote sine_note;\n    WhiteNoiseNote white_noise_note;\n    float duration;\n    float relative_time;\n    int note_index;\n    for (note_index = 0; note_index < squareNotes.length(); note_index++)\n    {\n\t\tsquare_note = squareNotes[note_index];\n        duration = GetDuration(square_note.audioEffectsIndex);\n        if (IsInTime(duration, square_note.playAtTime, time, relative_time))\n        {\n            ret += SquareWave(square_note.frequency, square_note.highRatio, time) * ProcessAudioEffects(square_note.audioEffectsIndex, relative_time);\n        }\n    }\n    for (note_index = 0; note_index < triangleNotes.length(); note_index++)\n    {\n\t\ttriangle_note = triangleNotes[note_index];\n        duration = GetDuration(triangle_note.audioEffectsIndex);\n        if (IsInTime(duration, triangle_note.playAtTime, time, relative_time))\n        {\n            ret += TriangleWave(triangle_note.frequency, triangle_note.triangleOffset, time) * ProcessAudioEffects(triangle_note.audioEffectsIndex, relative_time);\n        }\n    }\n    for (note_index = 0; note_index < sineNotes.length(); note_index++)\n    {\n\t\tsine_note = sineNotes[note_index];\n        duration = GetDuration(sine_note.audioEffectsIndex);\n        if (IsInTime(duration, sine_note.playAtTime, time, relative_time))\n        {\n            ret += SineWave(sine_note.frequency, time) * ProcessAudioEffects(sine_note.audioEffectsIndex, relative_time);\n        }\n    }\n    for (note_index = 0; note_index < whiteNoiseNotes.length(); note_index++)\n    {\n\t\twhite_noise_note = whiteNoiseNotes[note_index];\n        duration = GetDuration(white_noise_note.audioEffectsIndex);\n        if (IsInTime(duration, white_noise_note.playAtTime, time, relative_time))\n        {\n            ret += WhiteNoiseWave(time) * ProcessAudioEffects(white_noise_note.audioEffectsIndex, relative_time);\n        }\n    }\n    return ret;\n}\n\nvec2 mainSound(in int samp, float time)\n{\n    if (time >= musicPlayTime)\n    {\n        return vec2(0.0);\n    }\n    vec2 volume = vec2(0.0);\n    float music_time = mod(time, repeatMusicTime);\n    for (uint anti_aliasing_index = 0U; anti_aliasing_index != antiAliasing; anti_aliasing_index++)\n    {\n        volume += PlayNotes(music_time - (float(anti_aliasing_index) / (iSampleRate * float(antiAliasing))));\n    }\n    return volume / float(antiAliasing);\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfcWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1552, 1552, 1587, 1587, 1745], [1747, 1747, 1827, 1827, 1964], [1966, 1966, 2045, 2045, 2165], [2167, 2167, 2269, 2269, 3560], [3562, 3562, 3590, 3590, 3648]], "test": "untested"}
{"id": "tsscDf", "name": "Trying to AI ", "author": "wyatt", "description": "Mapping the divergence and gradient of a picture to the color, then using the map to attempt to evolve some cellular automata back into the original photo. I wouldn't call it a success, but it was a fun idea. \n\nSet the pic in Buffer A, then restart ", "tags": ["experiment"], "likes": 9, "viewed": 582, "published": 3, "date": "1585782295", "time_retrieved": "2024-07-30T21:15:25.982458", "image_code": "// Fork of \"JFA Caustic\" by wyatt. https://shadertoy.com/view/wdsyDH\n// 2020-04-01 19:31:15\n\nMain {\n    Q = D(U);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texelFetch(iChannel3,ivec2(U),0)\n#define Main void mainImage (out vec4 Q, vec2 U) \n#define Init if (iFrame < 1) \n#define Border if (U.x<1.||R.x-U.x<1.||U.y<1.||R.y-U.y<1.)\n#define T(U) A((U)-dt*A(U).xy)\n#define NeighborhoodT vec4 n = T(U+vec2(0,1)), e = T(U+vec2(1,0)), s = T(U-vec2(0,1)), w = T(U-vec2(1,0)), m = 0.25*(n+e+s+w);\n#define Neighborhood vec4 n = A(U+vec2(0,1)), e = A(U+vec2(1,0)), s = A(U-vec2(0,1)), w = A(U-vec2(1,0)), m = 0.25*(n+e+s+w);\n#define grd 0.25*vec2(e.z-w.z,n.z-s.z)\n#define div 0.25*(e.x-w.x+n.y-s.y)\nfloat pack (vec2 u) {\n\treturn fract(u.x)+ceil(u.y*1e3);\n}\nvec2 unpack (float u) {\n\treturn vec2(fract(u),ceil(u)/1e3);\n}\n#define I 16\n//Dave H :\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}", "buffer_a_code": "float f (vec2 U) {\n    vec4 c = D(U);\n\treturn length(c.xyz);\n}\nvec2 grad (vec2 U) {\n\tfloat \n        n = f(U+vec2(0,1)),\n        e = f(U+vec2(1,0)),\n        s = f(U-vec2(0,1)),\n        w = f(U-vec2(1,0));\n    return vec2(e-w,n-s);\n}\nvec2 convo (vec2 U) {\n\tvec2 r = vec2(0);\n    float d = 0.;\n    for (int x = -2; x<=2; x++) {\n        for (int y = -2; y<=2; y++) {\n            vec2 v = vec2(x,y);\n            r += v*f(v+U);\n            d += dot(v,grad(v+U));\n        }\n    }\n    r/=25.;d/=25.;\n    return vec2(2.*dot(r,r),0.5*d+0.5);\n}\n\nMain {\n    Q.xy = convo(U);\n    Q.xy = clamp(Q.xy,0.,1.);\n    vec4 c = D(U);\n    Q.zw = vec2(c.x,pack(c.yz));\n    \n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void X (inout vec4 Q, vec2 U, vec4 n) {\n\tif (length((n.xy)*R-U)<length((Q.xy)*R-U))\n        Q = n;\n}\nMain {\n    if (iFrame%I==0) {\n        Q = A(U);\n    } else {\n    \tfloat k = exp2(float(I-1-(iFrame%I)));\n        X(Q,U,B(U+vec2(0,k)));\n        X(Q,U,B(U+vec2(k,0)));\n        X(Q,U,B(U-vec2(0,k)));\n        X(Q,U,B(U-vec2(k,0)));\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void X (inout vec4 Q, vec2 U, vec4 n) {\n\tif (length((n.xy)*R-U)<length((Q.xy)*R-U))\n        Q = n;\n}\nMain {\n    Q = B(U);\n    X(Q,U,C(U+vec2(0,1)));\n    X(Q,U,C(U+vec2(1,0)));\n    X(Q,U,C(U-vec2(0,1)));\n    X(Q,U,C(U-vec2(1,0)));\n    \n    X(Q,U,C(U+vec2(1,1)));\n    X(Q,U,C(U+vec2(1,-1)));\n    X(Q,U,C(U-vec2(1,1)));\n    X(Q,U,C(U-vec2(1,-1)));\n    \n    \n    X(Q,U,C(U+vec2(0,2)));\n    X(Q,U,C(U+vec2(2,0)));\n    X(Q,U,C(U-vec2(0,2)));\n    X(Q,U,C(U-vec2(2,0)));\n    \n    \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "float f (vec2 U) {\n\treturn length(A(U).xyz);\n}\nvec2 grad (vec2 U) {\n\tfloat \n        n = f(U+vec2(0,1)),\n        e = f(U+vec2(1,0)),\n        s = f(U-vec2(0,1)),\n        w = f(U-vec2(1,0));\n    return vec2(e-w,n-s);\n}\nvec2 convo (vec2 U) {\n\tvec2 r = vec2(0);\n    float d = 0.;\n    for (int x = -2; x<=2; x++) {\n        for (int y = -2; y<=2; y++) {\n            vec2 v = vec2(x,y);\n            r += v*f(v+U);\n            d += dot(v,grad(v+U));\n        }\n    }\n    r/=25.;d/=25.;\n    return vec2(2.*dot(r,r),.5*d+0.5);\n}\nMain {\n    U -= 0.5*R;\n    float a = -1e-3-2e-3*cos(length(U)*.01);\n    U *= (1.-.005*exp(-4e-3*length(U)))*mat2(cos(a),sin(-a),sin(a),cos(a));\n    U += 0.5*R;\n\tQ = A(U);\n    Neighborhood;\n    vec2 u = convo(U);\n    vec4 c = C(u*R);\n    c.x = c.z;\n    c.yz = unpack(c.w);\n    if (length(c.xyz)>0.0&&length(c.xyz)<1.4)\n\tQ = mix(Q,c,0.01);\n    if (iFrame < 100||iMouse.z>0.) {\n        Q = C(U);\n    \n    \tQ=vec4(Q.z,unpack(Q.w),1);//*smoothstep(2.,1.,length(U-Q.xy*R));\n   \t\n        Q = clamp(Q,0.,1.);\n\n    }\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsscDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "wslcWf", "name": "Probabilistic quadtree filter", "author": "ciphered", "description": "Mouse.x drives the threshold on which quad are divided.", "tags": ["filter", "tree", "tree", "quad", "quadtree"], "likes": 28, "viewed": 3392, "published": 3, "date": "1585781494", "time_retrieved": "2024-07-30T21:15:26.740431", "image_code": "// @license MIT\n// @author ciphrd\n// \n// This algorithm is sort of a probabilistic quad tree construction where quad divisions are \n// added if the color variation (variance) in a quad is too important.\n// \n// The color variation is computed by taking n samples within the quad, and then we compute the \n// variance on each color component of the samples.\n//\n//\n// Limitations\n// \n// If a certain area, which is large, has a small section of it being detailed while the rest\n// is pretty much linear, divisions might not be added. Because this algorithm picks random\n// points in the quad, the small detailed section has little to no infuence on the overall\n// variations of the colors in the quad.\n// You can observe this behavior on the Google logo when it appears.\n//\n\n\n// the number of divisions at the start\n#define MIN_DIVISIONS 4.0\n\n// the numer of possible quad divisions\n#define MAX_ITERATIONS 6\n\n// the number of samples picked fter each quad division\n#define SAMPLES_PER_ITERATION 30\n#define F_SAMPLES_PER_ITERATION 30.\n\n// useless, kept it for reference for a personal usage \n#define MAX_SAMPLES 200\n\n// threshold min, max given the mouse.x\n#define THRESHOLD_MIN 0.0001\n#define THRESHOLD_MAX 0.01\n\n\n// taken from http://glslsandbox.com/e#41197.0\nvec2 hash22(vec2 p) { \n    float n = sin(dot(p, vec2(41, 289)));\n    return fract(vec2(262144, 32768)*n);    \n}\n\n\n// Computes the color variation on a quad division of the space\n// Basically, this method takes n random samples in a given quad, compute the average \n// of each color component of the samples.\n// Then, it computes the variance of the samples\n// This is the way I thought for computing the color variation, there might be others,\n// and there must be better ones\nvec4 quadColorVariation (in vec2 center, in float size) {\n    // this array will store the grayscale of the samples\n    vec3 samplesBuffer[SAMPLES_PER_ITERATION];\n    \n    // the average of the color components\n    vec3 avg = vec3(0);\n    \n    // we sample the current space by picking pseudo random samples in it \n    for (int i = 0; i < SAMPLES_PER_ITERATION; i++) {\n        float fi = float(i);\n        // pick a random 2d point using the center of the active quad as input\n        // this ensures that for every point belonging to the active quad, we pick the same samples\n        vec2 r = hash22(center.xy + vec2(fi, 0.0)) - 0.5;\n        vec3 sp = texture(iChannel0, center + r * size).rgb;\n        avg+= sp;\n        samplesBuffer[i] = sp;\n    }\n    \n    avg/= F_SAMPLES_PER_ITERATION;\n    \n    // estimate the color variation on the active quad by computing the variance\n    vec3 var = vec3(0);\n    for (int i = 0; i < SAMPLES_PER_ITERATION; i++) {\n    \tvar+= pow(samplesBuffer[i], vec3(2.0));\n    }\n    var/= F_SAMPLES_PER_ITERATION;\n    var-= pow(avg, vec3(2.0));\n        \n    return vec4(avg, (var.x+var.y+var.z)/3.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float threshold = mix(THRESHOLD_MIN, THRESHOLD_MAX, iMouse.x / iResolution.x);\n    \n    // number of space divisions\n    float divs = MIN_DIVISIONS;\n\n    // the center of the active quad - we initialze with 2 divisions\n    vec2 quadCenter = (floor(uv * divs) + 0.5) / divs;\n    float quadSize = 1. / divs; // the length of a side of the active quad\n    \n    // we store average and variance here\n    vec4 quadInfos = vec4(0);\n    \n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n    \tquadInfos = quadColorVariation(quadCenter, quadSize);\n        \n    \t// if the variance is lower than the threshold, current quad is outputted\n        if (quadInfos.w < threshold) break;\n        \n        // otherwise, we divide the space again\n        divs*= 2.0;\n        quadCenter = (floor(uv * divs) + 0.5) / divs;\n        quadSize/= 2.0;\n    }\n    \n\n    \n    vec4 color = texture(iChannel0, uv);\n    \n    // the coordinates of the quad\n    vec2 nUv = fract(uv * divs);\n    \n    // we create lines from the uv coordinates\n    vec2 lWidth = vec2(1./iResolution.x, 1./iResolution.y);\n    vec2 uvAbs = abs(nUv-0.5);\n    float s = step(0.5-uvAbs.x, lWidth.x*divs) + step(0.5-uvAbs.y, lWidth.y*divs);\n    \n    // we smooth the color between average and texture initial\n    //color.rgb = mix(color.rgb, quadInfos.rgb, uv.x);\n    \n    // we smooth the lines over the x axis\n    //s*= pow(1. - uv.x, 4.0);\n    \n    // for black lines, we just subtract\n    color-= s;\n\n    // Output to screen\n    fragColor = color;\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslcWf.jpg", "access": "api", "license": "mit", "functions": [[1211, 1258, 1279, 1279, 1369], [1372, 1735, 1792, 1850, 2864], [2867, 2867, 2924, 2974, 4517]], "test": "untested"}
{"id": "tslyWf", "name": "Gentle Bloby Thing", "author": "propagant", "description": "No idea what this could be, so I call it a gentle bloby thing... Just for fun.", "tags": ["raymarching", "blob", "softshadows"], "likes": 4, "viewed": 375, "published": 3, "date": "1585770189", "time_retrieved": "2024-07-30T21:15:27.600133", "image_code": "//#define WALLS_ENABLED\n\nstruct ray\n{\n\tvec3 o;\n\tvec3 d;\n\tfloat l;\n};\n    \n#define opu(a, b) a.w < b.w ? a : b\n\nvec4 geo(vec3 p)\n{\n    float sXsin = sin(iTime * 0.8)*0.3; // Horizontal movement\n    float sXsin2 = sin(iTime * 0.8)*0.23;\n    float sXsinDouble = 0.2+sin(iTime * 1.5 )*0.1; // Horizontal movement 2xSpeed\n    float sBlob = sin(iTime * 3. + p.y * 8.); // 'Sphere blob'\n    \n\tvec4 o0 = vec4(0.2,0.6,1.0, length(p - vec3(sXsin,0.,1.5)) - 0.2 + sBlob * 0.0999);\n    o0.w *= smoothstep(0.1,0.05, -p.y-0.22) + clamp(abs(sXsin),0.05,0.2); // The 'slimy' effect below the 'blob'\n    \n    #ifdef WALLS_ENABLED\n    o0.w *= smoothstep(0.02,0.01, abs(p.x)*0.02); // The 'Wall' generation\n    #endif\n    \n\tvec4 o0eye = vec4(vec3(1.0,1.0,1.0)*1.5, abs(length(p - vec3(sXsin,sXsinDouble,1.2)) - 0.01 + clamp(sBlob,-0.3,-0.1) * 0.0999)*0.45);\n    vec4 o0eyeb = vec4(vec3(0.0,0.0,0.0)*1.5, abs(length(p - vec3(sXsin2,sXsinDouble,1.15)) - 0.08 * 0.0999)*0.5);\n    vec4 o2 = vec4(0.2,0.4,0.5, p.y + 0.35);\n\t\n    // Final mix\n    vec4 g = opu(o2, o0);\n    vec4 g2 = opu(g, o0eye);\n    vec4 g3 = opu(g2, o0eyeb);\n    return g3;\n}\n\nvec4 march(ray r)\n{\n\tvec3 col = vec3(1.0);\n\tfor(int i = 0; i < 16; i++)\n\t{\n\t\tvec3 p = r.o + r.d * r.l;\n\t\tvec4 g = geo(p);\n\t\tr.l += g.w;\n\t\tcol = g.rgb;\n\t\tif(r.l > 8.)\n\t\t\tbreak;\n\t}\n\treturn vec4(col, r.l);\n}\n\nvec3 normal(vec3 p)\n{\n\tvec2 of = vec2(0.001,0.0);\n\tvec4 copy = geo(p);\n\treturn normalize(copy.w - vec3(geo(p - of.xyy).w, geo(p - of.yxy).w, geo(p - of.yyx).w));\n}\n\nfloat shadows(vec3 ro, vec3 rd, float b)\n{\n\tfloat t = 0.01;\n\tfloat res = 1.0;\n\tfor(int i = 0; i < 32; i++)\n\t{\n\t\tfloat g = geo(ro+rd*t).w;\n\t\tres = min(res, b * g / t); // Soft shadows\n\t\tt += g;\n\t\tif(g < 0.0005|| g > 3.0)\n        {\n\t\t\tbreak;\n        }\n\t}\n\treturn clamp(res,0.1,1.0);\n}\n\nfloat lighting(vec3 p, vec3 lp)\n{\n\tvec3 lPos = normalize(lp - p);\n\tvec3 n = normal(p);\n    \n    float spec = pow(max(dot(lPos, n),0.),80.)*0.2; // BlinnPhong\n\t\n\tfloat light = clamp(dot(n, lPos), 0.6, 1.); // Lambert\n\treturn light * shadows(p, normalize(lp), 1.0) + spec;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy) / iResolution.y;\n\n    ray r;\n\tr.o = vec3(0.);\n\tr.d = vec3(uv, 1.0);\n\tvec4 mm = march(r);\n\n\tvec3 m = r.o + r.d * mm.w;\n\tvec3 lPos = vec3(0.,2.5,1.);\n    #ifdef WALLS_ENABLED\n    #else\n        lPos = vec3(sin(iTime * 1.0)*1.5,1.5,cos(iTime * 1.0)*1.5);\n    #endif\n\tvec3 col = mm.rgb * lighting(m, lPos);\n\tcol *= exp(-0.2 * mm.w * mm.w * mm.w * mm.w) *  5.; // Fog + quick gamma\n    if(mm.w > 2.5) col = mix(col, vec3(0.2,0.3,0.8), uv.y-0.1); // Simple background gradient\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslyWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 111, 129, 129, 1120], [1122, 1122, 1141, 1141, 1326], [1328, 1328, 1349, 1349, 1491], [1493, 1493, 1535, 1535, 1775], [1777, 1777, 1810, 1810, 2049], [2051, 2051, 2108, 2108, 2657]], "test": "untested"}
{"id": "wdscDX", "name": "caramellseizure", "author": "caramellseizure", "description": "made for playing in fullscreen with your monitor or tv pointed at your neighbors\nshifts through the whole spectrum every beat\n\nhttps://www.youtube.com/watch?v=QQfXqKF6l24\n", "tags": ["beat", "audio", "epilepsy", "rainbow", "meme", "caramelldansen"], "likes": 1, "viewed": 459, "published": 3, "date": "1585768046", "time_retrieved": "2024-07-30T21:15:28.359103", "image_code": "// Original is 138 BPM\n// Remixes are 160-170ish\n// 138 / 60\n#define MULT 2.3\n\n\n// with max saturation and value\nvec3 hue2rgb(in float c) {\n    vec3 rgb = clamp( abs(mod(c*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return mix( vec3(1.0), rgb, 1.);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float hue = fract(iTime * MULT);\n    vec3 color = hue2rgb(hue);\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdscDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 113, 139, 139, 292], [295, 295, 350, 350, 454]], "test": "untested"}
{"id": "wssyDX", "name": "[sound] Heliostasis", "author": "jeyko", "description": "banana", "tags": ["sound", "music", "diffusion", "feedback"], "likes": 29, "viewed": 759, "published": 3, "date": "1585765665", "time_retrieved": "2024-07-30T21:15:29.289616", "image_code": "// check out wyatt, Flexi and michael's shaders to learn how to do buffer feedback stuff :) \n\n// i don't like the last chord\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor = (sin(fragColor*5. + vec4(-3.4,0.1,-0.2,0.4) + sin(iTime)*0.1));\n    fragColor = smoothstep(0.,0.7,fragColor );\n    \n    fragColor *= 1. - dot(uv,uv)*0.7;\n    fragColor = max(fragColor, 0.);\n    fragColor = pow(fragColor, vec4(0.45454));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nvec2 noise(vec2 id){\n    float r = fract(sin(id.y*21422.125)*31455.31531);\n    float rb = fract(sin(id.x*21422.125)*31455.31531);\n    return vec2(r, rb);\n}\n\nvec3 get( vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0);\n\n    #define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n    \n    vec2 id = floor(uv*1000.);\n    \n    //vec2 n = noise(vec2(id.x + iTime*0.00001,id.y - iTime*0.000000));\n    vec2 n = noise(vec2(id.x + iTime*0.00001,id.y - iTime*0.000000));\n    \n    //col += pal(-0., 3., vec3(0.8,8.9,4.3), 1. + id.x *20. + n.y*2000.,0.9 + id.y*20.4 + n.x*20. + iTime);\n    //col += pal(-0., 3., vec3(0.8,8.9,4.3), 1. + sin(id.x *20.) + sin(n.y*2000.),0.9 + id.y*20.4 + n.x*20. + iTime);\n    col += pal(-0., 5., vec3(4.8,2.9,9.3), 4. + sin(id.x *20.) + sin(n.y*2000.),0.9 + id.y*20.4 + n.x*20. + iTime);\n    \n    \n    //col = smoothstep(0.,1.,col);\n    \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n \n    vec2 cuv = fragCoord/iResolution.xy;   \n    \n    vec3 col = vec3(0);\n    \n    vec3 g = get(fragCoord);\n  \n    vec2 nc = fragCoord/iResolution.xy - 0.*(0. + length(uv)*2.)*normalize(uv)/iResolution.xy*iTimeDelta;\n\t    \n\tvec2 st = 30./iResolution.xy;\n    \n    vec2 lc = nc;\n    vec4 u = texture(iChannel1, lc + vec2(0,st.y) );\n    vec4 d = texture(iChannel1, lc + vec2(0,-st.y) );\n    vec4 l = texture(iChannel1, lc + vec2(-st.x,0) );\n    vec4 r = texture(iChannel1, lc + vec2(st.x,0) );\n    \n    vec2 grb = (vec2( r.b - l.b, u.b - d.b));\n    vec2 gr = normalize(vec2( r.r - l.r, u.r - d.r));\n    #define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n    \n    gr *= rot(3.14/4.);\n    grb *= rot(3.14/8./8.);\n    //ddb *= rot(3.14/2. - 3. - sin(iTime)*0.5 - 0.1);\n    \n    nc += grb*st*2.9;\n    //nc += grb*st*2.9*iTimeDelta*100.;\n    //nc -= gr*st*0.;\n    \n    if(iFrame > 0)\n    \tcol = mix(g, texture(iChannel1,nc).xyz, 0.999);\n    if(iFrame == 0)\n        col = vec3(0);\n\n    if(iMouse.z > 0.){\n    \t//C = mix(C, vec4(1,1,1,1)*(sin(Q.xyyx*4.2))*1., mouse );\n        float mouse = smoothstep(0.1,0.001,length(iMouse.xy/iResolution.x - fragCoord/iResolution.x));\n        \n        col = mix(col, vec3(0.),mouse*0.07);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "float gT;\n    float sc;\nfloat note(float note, float octave){ \n\treturn 27.5*exp2(((octave*12. ) + note )/12.);//pow(2., );\n}\n\nvec4 r11(float x){return texture(iChannel0,vec2(x)/256.);}\nvec2 hash22(vec2 p)   \n{\n    p  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n    return fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\nvec2 hash22a(vec2 p){\n    p *= 2000.;\n\treturn texture(iChannel0, vec2((p + 1./floor(p/256.)))/256.).xz;\n}\n\nvec2 noise(float t)\n{\n    return hash22(vec2(t, t * 1.423)) * 2.0 - 1.0;\n}\n\nvec2 lpnoise(float t, float fq)\n{\n    t *= fq;\n\n    float ft = fract(t);\n    float tn = t - ft;\n    ft = smoothstep(0.0, 1.0, ft);\n\n    vec2 n0 = noise(floor(tn + 0.0) / fq);\n    vec2 n1 = noise(floor(tn + 1.0) / fq);\n\n    return mix(n0, n1, ft);\n}\n\n#define bitreduction(s,amt) s = sign(s) * floor(abs(s)/amt)*amt\n#define sampleratereduction(t, amt) t = floor(t/(amt))*(amt)\n#define smoothify(s, amt) mix(s,sign(s)*smoothstep(0.0,1.,abs(s)), amt)\n#define clampify(s, amt) clamp(s*amt,-1.,1.)/amt\nvec2[8] N;\n\n\n\nvec2 kick(float t, inout float sc){\n\tinit;\n\t\n    sampleratereduction(t, 0.000006);\n    \n    float md = beat/4.;\n    float pl = 16.;\n    t = mod(t, md*pl);\n    float idx = floor(t/md);\n    t = mod(t, md);\n    \n    float env = exp(-t*40.7);\n    s += sin((exp2(-t*80.1)*340. + 60.)*tt )*env;\n    \n    s = mix(s,sin(s*2.)*1., 0.5);\n    \n    \n    //bitreduction(s, 0.001);\n    \n    //s = sign(s)*smoothstep(0.,1.,abs(s));\n    \n    \n    s = clamp(s,-1., 1.);\n    \n    \n    float att = float(pattK[int(idx)]);\n    s *= att;\n    sc = 1. - pow(env, 0.15)*att;\n    sc = smoothstep(0.,1.,sc);\n    ret;\n}\n\nvec2 snare(float t){\n\tinit;\n    \n    \n    float md = beat;\n    float pl = 8.;\n    t = mod(t, md*pl);\n    float idx = floor(t/md);\n    t = mod(t, md);\n    \n    float env = exp2(-t*70.);\n    \n    vec2 n =lpnoise(t,10000.5);\n    vec2 nb =lpnoise(t,20000.5);\n    float f = 400.+ 500.*exp2(-t*80.)+ n.x*6.5 ;\n    \n    \n    s += sin(f*tt + n.x*0.25 + nb.x*0.5*exp(-t*20.))*env;\n    s += sin(f*tt*4. + n.x*0.25 + nb.x*4.2*exp(-t*10.))*pow(env, 0.8)*0.03;\n    \n    s += (n + nb)*0.1*exp(-t*15.);\n    \n    s = smoothify(s, 0.1);\n    \n    s *= float(pattS[int(idx)]);\n    ret;\n}\n\nvec2 lead(float t){\n\tinit;\n\t\n    float to;\n    vec2 nn = N[0];\n    nn += N[1]*0.9;\n    nn += N[5]*0.45;\n    nn += N[7]*0.1;\n    \n    \n    vec2 id;\n    float r = bar;\n    \n    t = mod(t, r*float(chordCnt));\n    \n    id.x = floor(t/r);\n    \n    t = mod(t,bar);\n    float reps = 32./16.;\n    id.y = floor(t/(bar/reps));\n    \n    id.y = mod(id.y, 4.);\n    \n    t = mod(t,bar/reps);\n    \t\n\n    \n    if (gT > msr*2.)\n    \tsampleratereduction(t, (1.2*1./iSampleRate));\n    \n    float amt = 0.9;\n    float env = exp(-t*0.2);\n    \n    \n    \n\tfloat n = chords[int(id.x)][int(id.y)];\n    \n    \n    float oct = 5.;\n    s += sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    s += sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 + nn*amt)*env;\n    s -= sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    \n    \n    \n    bitreduction(s, 0.1);\n    s *= float(pattL[int(id.y)]);\n    \n    \n    s *= 1.;\n    ret;\n}\n\n\nvec2 leadb(float t){\n\tinit;\n\t\n    float to;\n    vec2 nn = N[0];\n    \n    \n    vec2 id;\n    float r = bar;\n    t = mod(t, r*float(chordCnt));\n    \n    id.x = floor(t/r);\n    \n    float att = float(pattL[int( mod(floor(t/(bar/(32./8.))), 8.) )]);\n    t = mod(t,bar);\n    float reps = 32./2.;\n    id.y = floor(t/(bar/reps));\n    \n    id.y = mod(id.y, 4.);\n    \n    t = mod(t,bar/reps);\n    \t\n\n    //sampleratereduction(t, (1.2*1./iSampleRate));\n    \n    float amt = 0.1;\n    float env = exp(-t*0.2);\n    \n    \n    \n\tfloat n = chords[int(id.x)][int(id.y)];\n    \n    \n    float oct = 5.;\n    s += sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    s += sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 + nn*amt)*env;\n    s -= sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    \n    \n    \n    //bitreduction(s, 0.7);\n    s *= 1. - att;\n    \n    s = smoothify(s, 0.9);\n    s = smoothify(s, 0.9);\n    s = smoothify(s, 0.9);\n    \n    s *= 0.05;\n    ret;\n}\n\nvec2 leadc(float t){\n\tinit;\n\t\n    float to;\n    vec2 nn = N[0];\n    \n    \n    vec2 id;\n    float r = bar;\n    t = mod(t, r*float(chordCnt));\n    \n    id.x = floor(t/r);\n    \n    float att = float(pattL[int( mod(floor(t/(bar/(32./8.))), 8.) )]);\n    t = mod(t,bar);\n    float reps = 32./2.;\n    id.y = floor(t/(bar/reps));\n    \n    id.y = mod(id.y, 4.);\n    \n    t = mod(t,bar/reps);\n    \t\n\n    if (gT > msr*2.)\n    \tsampleratereduction(t, (1.2*1./iSampleRate));\n    \n    float amt = 0.1;\n    float env = exp(-t*0.2);\n    \n    \n    \n\tfloat n = chords[int(id.x)][int(id.y)];\n    \n    \n    float oct = 4.;\n    s += sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    s += sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 + nn*amt)*env;\n    s -= sin( note(n, oct) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    \n    \n    \n    if (gT > msr*2.)\n    \tbitreduction(s, 0.7);\n    s *= 1. - att;\n    \n    \n    s *= 0.1;\n    ret;\n}\n\n\n\n\n\n\nvec2 tri(float t,float f){\n    return vec2(abs(fract(f*t) - 0.5));\n}\n\nvec2 bass(float t){\n\tinit;\n\t\n    float to;\n    \n    \t\n    vec2 id;\n    float r = bar;\n    t = mod(t, r*4.);\n    \n    id.x = floor(t/r);\n    \n    t = mod(t,r);\n    float reps = 1.;\n    id.y = floor(t/(bar/reps));\n    \n    id.y = mod(id.y, 4.);\n    \n    t = mod(t,bar/reps);\n    \n    \n    sampleratereduction(t, (10./iSampleRate)*(1.1 + sin(t)));\n    sampleratereduction(t, (20./iSampleRate)*0.1);\n    \n    float env = exp(-t*0.04);\n    \n\tfloat n = chords[int(id.x)][int(id.y)];\n    \n    //n += floor(id.y/4.)*12.;\n    \n    s += sin( note(n, 1.) *tt \n             +sin(note(n, 4.) *tt + \n             \t+sin(note(n, 2.) *tt)*exp(-t*0.2)*0.1 \n                 \n                 )*exp(-t*0.5)*0.4\n             +sin(note(n, 1.) *tt + \n             \t+sin(note(n, 10.) *tt)*exp(-t*0.2)*0.\n                 )*exp(-t*0.5)*0.4\n            )*env;\n    \n    \n    s *= 1.;\n    \n    vec2 oS = s;\n    \n    bitreduction(s, (0.2 + sin(gT)*0.1));\n    \n    s = mix(oS, s, 0.6);\n    \n    \n    s = sin(s*2.5);\n    \n    s = smoothify(s, 1.);\n    s = smoothify(s, 1.);\n    s = smoothify(s, 1.);\n    s = smoothify(s, 1.);\n    //s = mix(s,sqrt(abs(s)*1.)*sign(s)*1., 1. );\n    \n    s *= 0.7*0.6; // what is maths\n    ret;\n}\n\n\n\nvec2 chord(float t){\n\tinit;\n    \n    \n    float r = bar;\n    t = mod(t, r*float(chordCnt));\n    int id = int(floor(t/r));\n    \n    //sampleratereduction(t, (1./iSampleRate));\n    sampleratereduction(t, 0.00003);\n    \n    vec2 nn = N[1];\n    nn += N[2]*0.9;\n    nn += N[7]*0.45;\n    \n    nn *= 0.01*sin(t);\n    float m = 1.;\n    float width = 15.;\n    s += sin( note(chords[id][1], 4.) *tt + nn.x*1.)*0.5;\n    s += sin( note(chords[id][1], 4.) *tt + nn.x*1.)*0.5;\n    float oct = 3.;\n    for(float i = 0.; i < 4.; i++){\n        float a = (1. + i/2.);\n    \t//s += sin( note(chords[id].x, 3.) *tt + nn.x)*m;\n    \ts.x += sin( note(chords[id].x, oct) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].y, oct) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].z, oct) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].w, oct) *tt*a + nn.x)*m;\n    \ts.y += sin( note(chords[id].x, oct) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].y, oct) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].z, oct) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].w, oct) *tt*a + nn.y + width)*m;\n    \tm *= 0.5;\n    }\n    \n    //bitreduction(s, 0.01);\n    \n    s *= 0.03;\n    s = sin(s*3.);\n    //s /= 2.;\n    //s = sin(s);\n\tret;\n}\n\n\n\n\nvec2 cguit(float t){\n\tinit;\n    \n    \n    float r = bar;\n    t = mod(t, r*float(chordCnt));\n    int id = int(floor(t/r));\n    \n    \n    float rb = bar/8.;\n    float env = exp(-mod(t, rb)*2.)*float(pattG[int(mod(floor(t/rb*2.), r*4.))]);\n    \n    //sampleratereduction(t, (1./iSampleRate));\n    //sampleratereduction(t, (2./iSampleRate));\n    if(gT < msr*6.)\n    \tsampleratereduction(t, 0.0005);\n    \n    vec2 nn = N[0];\n    nn += N[1]*0.9;\n    nn += N[3]*0.45;\n    \n    nn *= 0.01*sin(t);\n    float m = 1.;\n    float width = 15.;\n    s += sin( note(chords[id][1], 3.) *tt + nn.x*1.);\n    s += sin( note(chords[id][1], 3.) *tt + nn.x*1.);\n    float oct = 3.;  \n    for(float i = 0.; i < 5. ; i++){\n        float a = (1. + i/1.);\n    \t//s += sin( note(chords[id].x, 3.) *tt + nn.x)*m;\n    \ts.x += sin( note(chords[id].x, oct) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].y, oct) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].z, oct) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].w, oct) *tt*a + nn.x)*m;\n    \ts.y += sin( note(chords[id].x, oct) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].y, oct) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].z, oct) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].w, oct) *tt*a + nn.y + width)*m;\n    \tm *= 0.75;\n    }\n    s *= env;\n    if(gT < msr*4.)\n    \tbitreduction(s, 0.4);\n    \n    s *= 0.04;\n    //s = sin(s*3.);\n    //s /= 2.;\n    //s = sin(s);\n\tret;\n}\n\n\nvec2 hats(float t){\n\tinit;\n\t\n    float r = hbeat;\n    t = mod(t + 0., r);\n    \n    float o = offsH[int(mod(floor(t/hbeat), 7.))]*r;\n    t -= o;\n    \n    \n    sampleratereduction(t, 1./iSampleRate);\n    vec2 nn = N[0] + N[1]  + N[2] + N[3]  ;\n    \n    float amt = 0.1;\n    float env = exp(-t*7.4);\n    //float f =  sin((12000. )*tt)*exp(-t*0.4)*0.215 +sin((3000. )*tt)*exp(-t*2.)*0.5 + ( 2000. + exp(-t*60.)*100.)*tt +lpnoise(t, 200500.).x*1.;\n    float f =  sin((11000. )*tt)*exp(-t*0.4)*0.215 +sin((3000. )*tt)*exp(-t*2.)*0.5 + ( 3000. + exp(-t*60.)*100.)*tt +lpnoise(t, 2500.).x*1.;\n    s += sin( f )*env;\n    s += amt*sin( f + nn )*env;\n    s -= amt*sin( f )*env;\n    \n    bitreduction(s, 0.7);\n    s *= 1.;\n    s *= min(floor(t) + 1., 1.);\n    ret;\n}\nvec2 hatsb (float t){\n\tinit;\n\t\n    t = mod(t + 0., hbeat/2.);\n    \n\n    vec2 nn = N[0] + N[4]*0.87  + N[2]*0.6 + N[3]*0.5  ;\n    \n    float amt = 0.5;\n    float env = exp(-t*10.);\n    float f =  sin(\n        (7000. )*tt)*exp(-t*0.4)*0.215 \n        +sin((4000. )*tt)*exp(-t*2.)*0.5 \n        + ( 1250. + exp(-t*60.)*100.)*tt +N[6].x*1.;\n    s += sin( f )*env;\n    s += amt*sin( f + nn )*env;\n    s -= amt*sin( f )*env;\n    \n    \n    s *= 0.08;\n    ret;\n}\n\nvec2 crash(float t){\n\tinit;\n\t\n    t = mod(t + 0., msr/2.);\n    \n    vec2 nn = N[1];\n    \n    float amt = 2.;\n    float env = exp(-t*0.2);\n    float f =  sin(\n        (2000. )*tt)*exp(-t*0.4)*0.215 \n        +sin((4000. )*tt)*exp(-t*2.)*0.5 \n        + ( 1250. + exp(-t*60.)*100.)*tt +lpnoise(t, 200500.).x*1.;\n    s += sin( f )*env;\n    s += amt*sin( f + nn )*env;\n    s -= amt*sin( f )*env;\n    \n    \n    s *= 0.9;\n    bitreduction(s, 0.9);\n    \n    s *= 0.4;\n    ret;\n}\n\nvec2 cReverb(float t){\n\tinit;\n    \n    //sampleratereduction(t, (8.2*1./iSampleRate));\n    \n    \n    float iters = 100.;\n    float size = 150.;\n    \n    if(gT > msr *8.)\n        iters *= 4.;\n    \n    for(float i = 0.; i < iters ; i++ ){\n        float att = smoothstep(1.,0.9,i/iters);\n    \t//s += lead(t - size*i/iSampleRate + 10000.2*N[int(mod(i,7.))].x/iSampleRate )*(pow(sc,0.9))*att;\n        float m = size*i/iSampleRate + noise(i).x*100./iSampleRate;\n        s += lead(t + m )*(pow(sc,0.9))*att*0.05;\n        s += leadb(t + m);\n        s += hats(t + m)*(0.2 + pow(sc,1.4))*0.001;\n    }\n    s /= iters;\n    s *= 3.;\n    \n    if (gT > msr*2.)\n    \ts = mix(s,s * (pow(sc,0.9)), 0.5);\n    //bitreduction(s, 0.0001);\n    \n    ret;\n}\n\n\nvoid initKickPatt(float t){\n\t\n    float r = beat/4.;\n    \n    float id = floor(t/r);\n    \n    \n    for(int i = 0; i < 16; i++){\n        \n        vec4 r = r11(id + float(i));\n        \n    \tpattK[i] = r.x < probK[i];\n        \n    }\n}\n\n\nvoid initNoise(float t){\n\t\t\n    N[0] = lpnoise(t, 400.);\n    N[1] = lpnoise(t, 500.);\n    N[2] = lpnoise(t, 700.);\n    N[3] = lpnoise(t, 1000.);\n    N[4] = lpnoise(t, 1400.);\n    N[5] = lpnoise(t, 1900.);\n    N[6] = lpnoise(t, 2500.);\n    N[7] = lpnoise(t, 5500.); \n    \n}\nvec2 mainSound( in int samp, float t )\n{\n    t += OFFS;\n    gT = t;\n    //t += msr*4.;\n    vec2 s= vec2(0);\n    \n    initKickPatt(t);\n    initNoise(t);\n\n    \n    vec2 k = kick(t,sc)*1.;\n    vec2 sn = snare(t);\n    \n    vec2 ha = hats(t)*(0.2 + pow(sc,1.4))*0.01;\n    vec2 hb = hatsb(t)*0.7;\n    \n    vec2 drums = k + sn*1. + ha*3. ;\n    //drums *= 0.5;\n    drums = sin(drums*1.2);\n    //drums = smoothify(drums, 0.2);\n    //vec2 hb= hatsb(t)*(pow(sc,4.4))*0.1;\n    vec2 bass = bass(t)*(pow(sc,1.))*0.3;\n    vec2 c = chord(t)*(pow(sc,1.))*0.4;\n    vec2 cguit = cguit(t)*(pow(sc,1.))*0.5;\n    //vec2 l = lead(t)*(pow(sc,0.9))*0.4;\n    //vec2 lb = leadb(t)*(pow(sc,0.9))*0.4;\n    //vec2 lc = leadc(t)*(pow(sc,0.9))*0.4;\n\t//vec2 cr = crash(t);\n    \n    vec2 rev = cReverb(t);\n    vec2 lb = leadb(t)*(pow(sc,0.9))*1.5;\n    vec2 cr = crash(t)*(pow(sc,0.9))*0.1;\n    \n    if(t > msr*8.){\n    \tt = mod(t,msr*2.*4.) + msr*8.;\n    }\n\t\n    if(t < msr*2.){\n    \ts += rev*4.;\n    \ts += lb;\n        if(t > msr*1.){\n    \t\ts += cr;\n        }\n    } else if(t < msr*4.) {\n    \ts += lb;\n\t\ts += hb;\n        s += c;\n        if(t > msr*3.){\n            s += k;\n        \ts += cguit;\n            s -= c;\n        \ts += rev*3.;\n        }\n    }else if(t < msr*6.) {\n    \ts += drums;\n        s += bass;\n\t\ts += rev*3.;\n        if(t > msr*5.){\n        \ts += hb;\n        }\n    }else if(t < msr*8.) {\n        s += cr;\n    \ts += drums;\n        s += bass;\n\t\ts += rev*3.;\n        s += cguit*1.7;\n    }else if(t < msr*10.) {\n        s += cr;\n    \ts += drums;\n        s += bass;\n        s += lb;\n\t\ts += rev*3.;\n        s += cguit;\n    }else if(t < msr*12.) {\n        s += cr;\n        s += c;\n    \ts += drums;\n        s += bass;\n        s += lb;\n\t\t//s += rev*3.;\n        s += cguit;\n    }\n    \n    \n    s *= 0.9;\n    \n    s = smoothify(s, 0.3);\n    s = smoothify(s, 0.1);\n    \n    s = clampify(s, 1.7);\n    \n    \n    s *= 0.5;\n    \n    return s;\n}", "sound_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI acos(-1.)\n\n#define T true\n#define F false\n\n#define init vec2 s = vec2(0)\n#define ret return s\n#define bpm (170.)\n\n#define tick (60./bpm)\n\n#define beat (tick)\n#define bar  (beat*4.)\n#define hbar  (bar/2.)\n#define msr  bar*4.\n#define hbeat tick/2.\n#define qbeat tick/4.\n\n\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define TT (tau*t)\n#define tt (tau*t)\n\n#define S vec2 s = vec2(0);\n#define E return s;\n\n#define OFFS (msr*1.)*0.\n\n//float[] probK = float[16](0.1,0.9,0.1,0.9,0.4,0.9,0.1,0.3,0.9,0.4,0.9,0.,0.9,0.1,0.4,0.5);\nfloat[] probK = float[16](0.9,0.1,0.1,0.2,0.,0.1,0.1,0.2,0.9,0.2,0.4,0.2,0.2,0.9,0.4,0.5);\nbool[] pattK = bool[16](F,F,F,T,F,T,T,F,T,F,F,T,F,T,T,F);\nbool[] pattL = bool[16](T,F,T,F,T,F,T,F,T,F,F,T,F,T,T,F);\nbool[] pattS = bool[8](F,T,F,T,F,T,F,T);\nbool[] pattG = bool[8](F,T,F,F,T,F,T,T);\n\n\nfloat[] offsH = float[8](0.02,0.1,0.1,0.02,0.29,0.1,0.0,0.02); \n\n\nfloat[] notesLB = float[8](2.,1.,0.,2.,0.,2.,0.,3.);\nint[] notesB = int[8](0,1,2,3,0,1,2,3);\n\nconst float scale = -4.;\n\nconst vec4 cmin9 = vec4(0.,3.,10.,14.) + scale;\n\nconst vec4 cmin510 = vec4(0.,7.,10.,12.) + scale;\nconst vec4 cmin7 = vec4(0.,3.,7.,10.) + scale;\nconst vec4 cmin73 = vec4(0.,7.,10.,3.) + scale;\nconst vec4 cmin11 = vec4(0.,10.,14.,17.) + scale;\nconst vec4 cmaj9 = vec4(0.,4.,7.,14.) + scale;\nconst vec4 cmaj7 = vec4(0.,4.,7.,11.) + scale;\nconst vec4 cmaj14 = vec4(0.,4.,11.,12. + 7.) + scale;\nconst vec4 cmaj7f15 = vec4(0.,4.,6.,11.) + scale;\nconst vec4 cmaj7d = vec4(0.,4.,7.,10.) + scale;\nconst vec4 cmin7maj = vec4(0.,3.,7.,11.) + scale;\n\nconst int chordCnt = 8;\n\n\nvec4[] chords = vec4[chordCnt](\n    cmin510,\n    cmin73 + 1.,\n    cmaj9 - 1.,\n    cmaj14 - 3.,\n    cmin11,\n    cmaj14 + 1. - 7.,\n    cmaj7 - 1.,\n    cmaj7 - 5.\n);\n\nvec4[] chordsbb = vec4[chordCnt](\n    cmin11,\n    cmaj14 + 2. - 7.,\n    cmin7 - 2.,\n    cmaj7 + 1.,\n    cmaj14 - 3.,\n    cmaj7f15 + 3.,\n    cmin9 + 2. - 4.,\n    cmaj7f15 - 4.\n);\n\nvec4[] chordsb = vec4[chordCnt](\n    cmin9,\n    cmaj7 + 1.,\n    cmaj7f15 - 2.,\n    cmaj7 - 3.,\n    cmaj14 - 2.,\n    cmaj7f15 + 3.,\n    cmaj9 - 1.,\n    cmaj7f15 - 4.\n);\nvec4[] chordsa = vec4[chordCnt](\n    cmin9,\n    cmaj7f15 - 2.,\n    cmaj9 - 3.,\n    cmin7maj - 5.,\n    cmaj14 - 2.,\n    cmaj7f15 + 3.,\n    cmaj9 - 1.,\n    cmaj7f15 - 2.\n);\n", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wssyDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 126, 183, 183, 565]], "test": "untested"}
{"id": "3dscWf", "name": "Excavated Dodecahedra", "author": "mla", "description": "An icosahedral kaleidoscope, showing planes through the vertices of a dodecahedron.\n\nToday is my 14th wedding anniversary, so I've tried to give things an ivory look.", "tags": ["dodecahedron", "dodecahedra", "excavate"], "likes": 13, "viewed": 358, "published": 3, "date": "1585757164", "time_retrieved": "2024-07-30T21:15:30.045594", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Excavated Dodecahedra\n//\n// Matthew Arcus, 2020\n//\n// Take an icosahedral kaleidoscope (using precalculated values), and\n// take slices through the fundamental region with planes through the\n// vertices of a dodecahedron. The result is a great range of shapes -\n// stellations, facetings and other more irregular but pretty shapes.\n//\n// <mouse>: rotation\n// <up>/<down>: move in/out\n// c: clip at x=0\n// n: compare numerical normal with exact\n// r: autorotation\n// s: subtract one of the planes (or the half space it bounds)\n// t: apply texturing\n// \n// Each plane (we combine two) goes through he main vertex of the\n// fundamental region, and cuts off a half space and the two half\n// spaces are intersected (as well as being clipped to the\n// dodecahedron). The display sequences through all 'interesting'\n// combinations.\n\n// Pressing 's' subtracts one of the spaces rather than doing an intersection,\n// which gives interesting results, but sometimes we end up with no\n// polyhedron at all.\n//\n// Experimenting with exact normals - compare with the usual numerical\n// procedure with 'n' - still problems where the ray has hit a\n// backface and we get the wrong normal.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nbool dorotate = true;\nbool doclip = false;\nbool dosubtract = false;\n\nconst float PI\t= 3.14159265359;\nint NFOLDS = 5;\n\nbool alert = false;\nvoid assert(bool test) {\n  if (!test) alert = true;\n}\n\n// Face plane normals, dot(A,B) = -cos(PI/P) etc.\nvec3 A = vec3(1,0,0);\nvec3 B = vec3(-0.5,0.866025,0);\nvec3 C = vec3(-0.809017,-0.467086,0.356822);\n\n// Unit length vertices of fundamental trihedron\nvec3 a = vec3(0.309017,0.178411,0.934172);\nvec3 b = vec3(0,0.607062,0.794654);\nvec3 c = vec3(0,0,1);\n\nvec3 vertices[20] =\n  vec3[](vec3(0,0,1), // 0\n         vec3(0.57735,0.333333,0.745356), // 0.713644\n         vec3(-0.57735,0.333333,0.745356), // 0.713644\n         vec3(0,-0.666667,0.745356), // 0.713644\n         vec3(0.356822,0.872678,0.333333), // 1.1547\n         vec3(0.934172,-0.127322,0.333333), // 1.1547\n         vec3(-0.356822,0.872678,0.333333), // 1.1547\n         vec3(-0.934172,-0.127322,0.333333), // 1.1547\n         vec3(0.57735,-0.745356,0.333333), // 1.1547\n         vec3(-0.577351,-0.745356,0.333333), // 1.1547\n         vec3(0.57735,0.745356,-0.333334), // 1.63299\n         vec3(0.934172,0.127322,-0.333334), // 1.63299\n         vec3(-0.57735,0.745356,-0.333334), // 1.63299\n         vec3(-0.934172,0.127322,-0.333334), // 1.63299\n         vec3(0.356822,-0.872678,-0.333334), // 1.63299\n         vec3(-0.356822,-0.872678,-0.333334), // 1.63299\n         vec3(0,0.666666,-0.745356), // 1.86834\n         vec3(0.57735,-0.333334,-0.745356), // 1.86834\n         vec3(-0.57735,-0.333334,-0.745356), // 1.86834\n         vec3(0,0,-1) // 2\n         );\n\nvec4 makeplane(vec3 p, vec3 q, vec3 r) {\n  vec3 n = cross(q-p,r-p);\n  n = normalize(n);\n  float k = dot(p,n);\n  // Fix so that away from origin is +ve distance\n  if (k < 0.0) { k = -k; n = -n; }\n  return vec4(n,k);\n}\n\n// Could use an ivec3 and count different types of flip\nvec3 fold(vec3 pos, out int flips, out mat3 trans) {\n  mat3 mA = mat3(reflect(vec3(1,0,0),A),\n                 reflect(vec3(0,1,0),A),\n                 reflect(vec3(0,0,1),A));\n  mat3 mB = mat3(reflect(vec3(1,0,0),B),\n                 reflect(vec3(0,1,0),B),\n                 reflect(vec3(0,0,1),B));\n  mat3 mC = mat3(reflect(vec3(1,0,0),C),\n                 reflect(vec3(0,1,0),C),\n                 reflect(vec3(0,0,1),C));\n  // We want to know the number of actual reflections made\n  // so keep track of that in flips.\n  flips = 0;\n  trans = mat3(1,0,0,\n               0,1,0,\n               0,0,1);\n  for (int i = 0; i < NFOLDS; i++) {\n    float k;\n    k = dot(pos,A);\n    if (k < 0.0) {\n      flips += 1;\n      pos -= 2.0*k*A;\n      trans = trans*mA; // Note order\n    }\n    k = dot(pos,B);\n    if (k < 0.0) {\n      flips += 1;\n      pos -= 2.0*k*B;\n      trans = trans*mB;\n    }\n    k = dot(pos,C);\n    if (k < 0.0) {\n      flips += 1;\n      pos -= 2.0*k*C;\n      trans = trans*mC;\n    }\n  }\n  return pos;\n}\n\nivec2 combos[] =\n  // Seem to be 23 different \"excavations\" with a single plane,\n  // excluding the dodecahedron itself and a couple where the face\n  // goes through the centre, so the volume is zero.\n  ivec2[](ivec2(2,10),ivec2(10,11),ivec2(2,5),ivec2(6,8),ivec2(11,13),ivec2(12,17),ivec2(14,16), // Stars\n          ivec2(1,12),ivec2(1,7),\n          ivec2(4,5),ivec2(3,4),ivec2(11,14),ivec2(15,19),ivec2(3,11),ivec2(9,19),ivec2(8,10), // Pentagram sides\n          ivec2(4,7),ivec2(4,9),ivec2(4,19),ivec2(9,10),ivec2(10,18),ivec2(15,16), // Incised pentagrams\n          //ivec2(1,19),ivec2(3,16), // Face through centre - no interesting combinations\n          ivec2(10,12) // Compound\n          );\n\nfloat faces(vec3 pos, int t, out vec3 n) {\n  int N = combos.length();\n  float sgn = dosubtract ? -1.0 : 1.0;\n  int X = combos[t%N].x;\n  int Y = combos[t%N].y;\n  int X1 = combos[t/N%N].x;\n  int Y1 = combos[t/N%N].y;\n  //int X1 = combos[5].x;\n  //int Y1 = combos[5].y;\n  //int X2 = combos[0].x;\n  //int Y2 = combos[0].y;\n  vec4 plane0 = makeplane(vertices[0],vertices[X],vertices[Y]);\n  vec4 plane1 = makeplane(vertices[0],vertices[X1],vertices[Y1]);\n  //vec4 plane2 = makeplane(vertices[0],vertices[X2],vertices[Y2]);\n  float d = -1e8,d1;\n  d1 = dot(vec4(pos,-1),plane0);\n  if (d1 > d) { d = d1; n = plane0.xyz; }\n  d1 = sgn*dot(vec4(pos,-1),plane1);\n  if (d1 > d) { d = d1; n = sgn*plane1.xyz; }\n  //d1 = dot(vec4(pos,-1),plane2);\n  //if (d1 > d) { d = d1; n = plane2.xyz; }\n  d1 = dot(pos,b)-dot(b,c); // Clip to dodecahedron\n  if (d1 > d) { d = d1; n = b; }\n  return d;\n}\n\n#if 0\nbool chiral = false; // Chiral needs some work.\nfloat faces(vec3 pos, int parity) {\n  float d;\n  if (!chiral || parity == 0) {\n    d = faces0(pos);\n  } else {\n    d = min(faces0(reflect(pos,A)),\n            min(faces0(reflect(pos,B)),\n                faces0(reflect(pos,C))));\n  }\n  d = max(d,(dot(pos,b)-dot(b,c))); // Clip to dodecahedron\n  return d;\n}\n#endif\n\nfloat polyhedron(vec3 pos, out vec3 n, out vec2 uv) {\n  int flips = 0;\n  vec3 pos0 = pos;\n  mat3 m; // Rotation matrix to apply to normal\n  pos = fold(pos,flips,m);\n  uv = pos.xy;\n  int parity = flips%2;\n  float t = iTime;\n  vec3 n1,n2;\n  float d1 = faces(pos,int(t)/4,n1);\n  float d2 = faces(pos,(int(t)+1)/4,n2);\n  float d = mix(d1,d2,fract(t));\n  n = mix(n1,n2,fract(t));\n  n = m*n; // Transform to world coordinates\n  normalize(n); // Keep normalized!\n  if (doclip && pos0.x > d) {\n    d = pos0.x;\n    n = vec3(1,0,0);\n  }\n  return d;\n}\n\n//-------------------------------------------------\n//From https://www.shadertoy.com/view/XtXGRS#\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nfloat map(vec3 p) {\n  vec3 n; vec2 uv; // Don't need these here - hopefully get optimized away.\n  return polyhedron(p,n,uv);\n}\n\nvec3 calcnormal(vec3 p) {\n  const vec2 e = vec2(0.001, 0.0);\n  vec3 n = vec3(map(p + e.xyy) - map(p - e.xyy),\n                map(p + e.yxy) - map(p - e.yxy),\n                map(p + e.yyx) - map(p - e.yyx));\n  return normalize(n);\n}\n\nfloat march(in vec3 ro, in vec3 rd) {\n  float maxd = length(ro) + 1.0;\n  float precis = 0.001;\n  float t = 0.0;\n  float res = -1.0;\n  for (int i = 0; i < 100; i++) {\n    //assert(i < 20);\n    float h = map(ro+rd*t);\n    if (abs(h) < precis) return t;\n    t += h;\n    if (t < 0.0 || t > maxd) break;\n  }\n  return -1.0;\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (dorotate) {\n    p.yz = rotate(p.yz,iTime * 0.125);\n    p.zx = rotate(p.zx,iTime * 0.2);\n  }\n  return p;\n}\n\nbool keypress(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\n\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\nconst int CHAR_C = 67;\nconst int CHAR_N = 78;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  dorotate = !keypress(CHAR_R);\n  doclip = keypress(CHAR_C);\n  dosubtract = keypress(CHAR_S);\n  bool dotexture = keypress(CHAR_T);\n  bool calcnormals = keypress(CHAR_N);\n  vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec3 col = vec3(0.1 - 0.1*p.y);\n  p *= 0.5;\n  float camera = 4.0;\n  camera *= 1.0 + 0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP));\n  vec3 ro = vec3(0.0, 0.0, camera);\n  vec3 rd = vec3(p, -2.0);\n  vec3 light = normalize(vec3(0.5, 1.0, 3.0));\n  ro = transform(ro);\n  rd = transform(rd);\n  light = transform(light);\n  rd = normalize(rd);\n  float t = march(ro, rd);\n  if (t > 0.0) {\n    vec3 pos = ro + t * rd;\n    vec2 uv; vec3 n;\n    polyhedron(pos,n,uv);\n    if (calcnormals) n = calcnormal(pos);\n    //assert(dot(n,rd) <= 0.0);\n    col = vec3(0.5, 0.5, 0.3);\n    if (dotexture) col = texture(iChannel2,uv).xyz;\n    float diffuse = clamp(dot(n, light), 0.0, 1.0);\n    col *= 0.2+0.8*diffuse;\n    float specular = pow(max(0.0,dot(reflect(light,n),rd)),50.0);\n    col += 0.3*specular*vec3(1);\n  }\n  col = pow(col, vec3(0.4545));\n  if (alert) col.x = 1.0;\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0) {\n      t = vec4(0);\n    } else {\n      t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dscWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1484, 1484, 1508, 1508, 1537], [2901, 2901, 2941, 2941, 3117], [3119, 3175, 3227, 3227, 4186], [4887, 4887, 4929, 4929, 5760], [6673, 6771, 6807, 6807, 6859], [6861, 6861, 6880, 6880, 6987], [6989, 6989, 7014, 7014, 7222], [7224, 7224, 7261, 7261, 7543], [7545, 7545, 7572, 7572, 7901], [7903, 7903, 7928, 7928, 7988], [7990, 7990, 8015, 8015, 8063], [8065, 8065, 8088, 8088, 8120], [8286, 8286, 8343, 8343, 9457]], "test": "untested"}
{"id": "tsfcWf", "name": "kraken", "author": "yuntaRobo", "description": "Inspired by glow-in-the-dark figures.\nThe luminescent effect is derived from the pseudo-SSS technique.", "tags": ["raymarching", "sss", "kraken", "octopus", "luminous"], "likes": 14, "viewed": 546, "published": 3, "date": "1585756827", "time_retrieved": "2024-07-30T21:15:30.794592", "image_code": "const float PI = 3.1415926;\nconst float E = 0.005;\n\nconst vec3 light_dir = normalize(vec3(-0.6, 0.2, -1.0));\nconst vec3 light_color = vec3(0.3, 0.6, 1.0);\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nmat2 rotate2D(float rad)\n{\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat2(c, s, -s, c);\n}\n\n// https://iquilezles.org/articles/smin\nvec2 smin(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return vec2(mix(d2, d1, h) - k * h * (1.0 - h), h);\n}\n\n// https://gaz.hateblo.jp/entry/2019/05/17/231141\nvec2 spfold4(vec2 p, float k)\n{\n    const int n = 4;\n    for(int i = 0; i < n; i++)\n    {\n        float a = PI / exp2(float(i));\n        vec2 v = vec2(cos(a), sin(a));  \n        p -= 2.0 * smin(0.0, dot(p, v), k).x * v;\n    }\n    return p;\n}\n\nfloat deBody(vec3 p, float t)\n{\n    float a = atan(p.z, p.x);\n    p *= vec3(1.0, 0.7, 1.0);\n    p += vec3(0.0, 0.7 - sin(t) * 0.25, 0.0);\n    float d = length(p) - 0.9 - sin(a * 20.0) * 0.05;\n    d = abs(d) - 0.2;\n    return d;\n}\n\nfloat deLeg(vec3 p, float h, float r)\n{\n    float a = atan(p.z, p.x);\n    p.y -= clamp(p.y, 0.0, h);\n    float d = length(p) - r - sin(a * 10.0) * pow(r, 0.8) * 0.05;\n    return d;\n}\n\nfloat deOctopus(vec3 p)\n{\n    float t = iTime - pow(length(p), 0.5) * 1.5;\n    \n    p.y *= -1.0;\n    p.xz *= rotate2D(0.45);\n    p.yz *= rotate2D(1.2 + sin(iTime * 0.333) * 0.25);\n    \n    float body = deBody(p, t);\n    \n    p.xz *= rotate2D(0.4);\n    p.xz = spfold4(p.xz, 0.04);\n    float h = 5.0;\n    float r = exp(-length(p) * 0.7) * 0.75;\n    mat2 m = rotate2D(0.35 + cos(length(p) * 1.75 + t) * 0.1);\n    p.yz *= m;\n    float leg = deLeg(p, h, r);\n    p.yz *= m;\n    leg = smin(leg, deLeg(p, h, r), 0.04).x;\n\n    float d = smin(body, leg, 0.3).x;\n    d *= 0.5;\n    \n    return d;\n}\n\nfloat deSea(vec3 p)\n{\n    float t = iTime - pow(length(p), 0.5) * 1.5;\n    \n    p.xz *= rotate2D(t);\n    float d = p.y + 0.2\n        - sin(p.x * 2.0) * 0.05\n        - sin(p.z * 3.111) * 0.05\n        - (sin(t * 0.333) * 0.5 + 0.5) * 0.5;\n    return d;\n}\n\nvec2 de(vec3 p)\n{\n    vec2 o = smin(deOctopus(p), deSea(p), 0.1);\n    return o;\n}\n\nfloat sss(vec3 o, vec3 dir, float ed, float la)\n{\n    const int ei = 4;\n    float accum = 0.0;\n    float st = ed / float(ei);\n    float d = st;\n    for (int i = 0; i < ei; i++)\n    {\n        accum += max(de(o + dir * d).x, 0.0);\n        d += st;\n    }\n    accum = clamp(accum / ed / (float(ei) * 0.5 + 0.5), 0.0, 1.0);\n    return exp(-(1.0 - accum) * la);\n}\n\nfloat luminous(vec3 o, vec3 dir, float ed, float la)\n{\n    const int ei = 16;\n    float accum = 0.0;\n    float st = ed / float(ei);\n    float d = st;\n    for (int i = 0; i < ei; i++)\n    {\n        accum += max(-de(o + dir * d).x / d, 0.0);\n        d += st;\n    }\n    accum = clamp(accum / float(ei), 0.0, 1.0);\n    return exp(-(1.0 - accum) * la);\n}\n\n// iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p)\n{\n    float h = E;\n    vec2 k = vec2(1.0, -1.0);\n    return normalize(\n            k.xyy * de(p + k.xyy * h).x + \n            k.yyx * de(p + k.yyx * h).x + \n            k.yxy * de(p + k.yxy * h).x + \n            k.xxx * de(p + k.xxx * h).x\n        );\n}\n\nvoid trace(Ray ray, inout vec3 color, float md)\n{\n    float ad = 0.0;\n    for (float i = 1.0; i > 0.0; i -= 1.0 / 150.0)\n    {\n        vec2 o = de(ray.pos);\n        if (o.x < E)\n        {\n            // normal\n            vec3 n = normal(ray.pos);\n            \n            // fresnel\n            float f0 = 0.075;\n            float f = f0 + (1.0 - f0) * pow(1.0 - max(dot(-ray.dir, n), 0.0), 5.0);\n            \n            // color\n            vec3 em = vec3(0.1, 1.0, 0.3);\n            \n            vec3 color1 = luminous(ray.pos, ray.dir, 0.35, 7.5) * em * 60.0;\n            color1 += sss(ray.pos, light_dir, 0.35, 5.0) * light_color * 5.0;\n            \n            vec3 color2 = sss(ray.pos, ray.dir, 0.5, 5.0) * vec3(0.0, 0.0, 1.0) * 2.0 * f;\n            color2 += sss(ray.pos, light_dir, 0.5, 6.0) * light_color * 0.3 * f;\n            color2 += exp(-deOctopus(ray.pos) * 17.5) * (em + light_color) * 0.01 * exp(-length(ray.pos) * 0.25);\n            \n            color += mix(color2, color1, pow(o.y, 5.0));\n            \n            color *= exp(-ad * ad * 0.03);\n            \n            return;\n        }\n\n        ray.pos += ray.dir * o.x;\n        ad = ad + o.x;\n        if (ad > md)\n        {\n            break;\n        }\n    }\n\n    // background\n    color += pow(max(dot(ray.dir, light_dir), 0.0), 800.0) * light_color * 3.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    // view\n    vec3 view = vec3(-1.0, 1.0, 6.75);\n    vec3 at = normalize(vec3(-2.0, 0.0, 0.0) - view);\n    vec3 right = normalize(cross(at, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, at);\n    float focallength = 2.25;\n\n    // ray\n    Ray ray;\n    ray.pos = view;\n    ray.dir = normalize(right * p.x + up * p.y + at * focallength);\n\n    // ray marching\n    trace(ray, color, 20.0);\n\n    // cheap tonemapping\n    // https://www.desmos.com/calculator/adupt0spl8\n    float k = 0.75;\n    color = mix(color, 1.0 - exp(-(color - k) / (1.0 - k)) * (1.0 - k), step(k, color));\n\n    // gamma correction\n    color = pow(color, vec3(0.454545));\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfcWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[201, 201, 227, 227, 307], [309, 349, 389, 389, 505], [507, 557, 588, 588, 798], [800, 800, 831, 831, 1029], [1031, 1031, 1070, 1070, 1213], [1215, 1215, 1240, 1240, 1801], [1803, 1803, 1824, 1824, 2055], [2057, 2057, 2074, 2074, 2138], [2499, 2499, 2553, 2553, 2848], [2850, 2888, 2909, 2909, 3160], [3162, 3162, 3211, 3211, 4497], [4499, 4499, 4556, 4556, 5332]], "test": "untested"}
{"id": "3sscWf", "name": "Helical Ramps with Spiders", "author": "dr2", "description": " Spiders on a double helix ramp - from Leonardo's Chateau de Chambord staircase;\n normal and panoramic views - mouseable.\n", "tags": ["helix", "spider", "symmetry", "walk"], "likes": 15, "viewed": 378, "published": 3, "date": "1585749667", "time_retrieved": "2024-07-30T21:15:31.807882", "image_code": "// \"Helical Ramps with Spiders\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define N_SPD  5  // Number of spiders per turn (1-20, roughly)\n\n#define AA  0   // optional antialiasing\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrEETapCylDf (vec3 p, vec3 v1, vec3 v2, float r, float rf);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat Maxv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm2 (vec2 p);\n\nvec3 footPos[8], kneePos[8], hipPos[8], ltDir, qHit;\nfloat tCur, dstFar, legLenU, legLenD, bdyHt, spdVel, nSpd, vGap, radExt, radRmp;\nint idObj;\nconst int idRmp = 1, idCol = 2, idWalI = 3, idWalM = 4, idWalO = 5, idBm = 6,\n   idBdy = 11, idHead = 12, idEye = 13, idAnt = 14, idLegU = 15, idLegD = 16;\nconst float pi = 3.14159;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat SpdDf (vec3 p, float dMin, int tpId)\n{\n  vec3 q;\n  float d, s, len, szFac;\n  szFac = 0.22;\n  p /= szFac;\n  dMin /= szFac; \n  p.y -= bdyHt + 0.8;\n  q = p - vec3 (0., -0.15, 0.2);\n  d = PrEllipsDf (q, vec3 (0.7, 0.5, 1.3));\n  DMINQ (idBdy + tpId);\n  q = p - vec3 (0., 0.1, 1.1);\n  d = PrEllipsDf (q, vec3 (0.2, 0.4, 0.5));\n  DMINQ (idHead + tpId);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.15, 0.25, 1.5);\n  d = PrSphDf (q, 0.13);\n  DMINQ (idEye + tpId);\n  q -= vec3 (0., 0.15, -0.3);\n  d = PrEETapCylDf (q, 1.3 * vec3 (0.3, 1.1, 0.4), vec3 (0.), 0.07, 0.7);\n  DMINQ (idAnt + tpId);\n  p.y += bdyHt;\n  for (int j = VAR_ZERO; j < 8; j ++) {\n    q = p - hipPos[j];\n    d = 0.6 * PrEETapCylDf (q, kneePos[j], hipPos[j], 0.25, 0.3);\n    DMINQ (idLegU + tpId);\n    q = p - kneePos[j];\n    d = 0.6 * PrEETapCylDf (q, footPos[j] - vec3 (0.3), kneePos[j] - vec3 (0.3), 0.2, 1.2);\n    DMINQ (idLegD + tpId);\n  }\n  return dMin * szFac;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, widRmp, aRot, r, a, ai, s;\n  dMin = dstFar;\n  widRmp = 1.2;\n  r = length (p.xz);\n  a = (r > 0.) ? atan (p.z, - p.x) / (2. * pi) + 0.5 : 0.;\n  q = p;\n  q.y = mod (q.y + (0.5 - 2. * a) * vGap, vGap) - 0.5 * vGap;\n  d = PrBox2Df (vec2 (r - radRmp, q.y), vec2 (widRmp, 0.1));\n  DMIN (idRmp);\n  d = max (PrBox2Df (vec2 (r - 0.5 * radRmp, q.y + 0.2), vec2 (0.1, 0.5)),\n     - PrBox2Df (vec2 (abs (mod (7. * a, 1.) - 0.5), q.y + 0.2), vec2 (0.3, 0.2)));\n  DMIN (idWalI);\n  d = PrBox2Df (vec2 (abs (r - radRmp) - widRmp, q.y - 0.2), vec2 (0.07, 0.3));\n  DMIN (idWalM);\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (7. * a + 0.5) / 7. - 0.5));\n  q.x += 0.5 * radRmp;\n  d = length (q.xz) - 0.2;\n  DMIN (idCol);\n  q.x += 0.25 * radRmp + 0.5 * widRmp;\n  s = -0.03 * q.x;\n  q.y = mod (q.y + 0.15 + (0.5 - 2. * a) * vGap, vGap) - 0.5 * vGap - s;\n  d = PrBoxDf (q, vec3 (0.25 * radRmp + 0.5 * widRmp, 0.15 - s, 0.1));\n  DMIN (idBm);\n  q = p;\n  d = max (abs (length (q.xz) - radExt - 0.2) - 0.2,\n     - PrBox2Df (mod (vec2 (21. * (0.5 + a), 0.125 * q.y) + 0.5, 1.) - 0.5, vec2 (0.2, 0.3)));\n  DMIN (idWalO);\n  aRot = atan (vGap / (2. * pi * radRmp));\n  for (float k = float (VAR_ZERO); k <= 1.; k ++) {\n    s = sign (1. - 2. * k);\n    q = p;\n    a = s * spdVel * tCur / (2. * pi * radRmp);\n    q.xz = Rot2D (q.xz, a);\n    ai = 2. * pi * floor (nSpd * ((r > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.) + 0.5) / nSpd;\n    q.xz = Rot2D (q.xz, ai);\n    q.y = mod (q.y + 0.2 + k * vGap + (1. - (ai + a) / pi) * vGap, 2. * vGap) - vGap;\n    q.yz = Rot2D (q.yz, aRot);\n    q.x += radRmp;\n    q.xz *= s;\n    if (PrCylDf (q.xzy, 1., 0.7) < dMin) dMin = SpdDf (q, dMin, int (10. * k));\n  }\n  return 0.8 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.002, -0.002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dstLim)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.03 * d, h));\n    d += clamp (2. * h, 0.05, 0.3);\n    if (sh < 0.05 || d > dstLim) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 SpdCol ()\n{\n  vec3 col, c[2];\n  vec2 cc;\n  cc = vec2 (1., 0.2);\n  if (idObj >= idBdy + 10) {\n    idObj -= 10;\n    c[0] = cc.xxy;\n    c[1] = cc.xyy;\n  } else {\n    c[0] = cc.yyx;\n    c[1] = cc.yxy;\n  }\n  if (idObj == idBdy) {\n    col = mix (c[0], c[1], SmoothBump (0.2, 0.7, 0.05, mod (4. * qHit.z, 1.)));\n  } else if (idObj == idHead) {\n    col = c[1];\n    if (qHit.z > 0.4) col *= 0.2 + 0.8 * smoothstep (0.02, 0.04, abs (qHit.x));\n  } else if (idObj == idEye) {\n    col = cc.xxx;\n  } else if (idObj == idLegU || idObj == idLegD) {\n    col = mix (c[1], c[0],  SmoothBump (0.4, 1., 0.2, fract (3.5 * length (qHit))));\n  } else if (idObj == idAnt) {\n    col = cc.xyx;\n  }\n  return col;\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 16. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 ShStagGrid (vec2 p)\n{\n  vec2 q, sq, ss;\n  q = p;\n  if (2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.05, 0.1, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.25 * smoothstep (0.3, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, bgCol, vn, rg;\n  float dstObj, vDotL, sh, atten, a, s, sa, saa;\n  bgCol = StarPat (rd, 12.);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    a = atan (ro.z, - ro.x) / (2. * pi);\n    vn = ObjNf (ro);\n    if (idObj == idRmp) {\n      col4 = vec4 (0.4, 0.4, 0.45, 0.1) * (0.7 + 0.3 * Fbm2 (64. * ro.xz));\n    } else if (idObj == idWalI) {\n      col4 = vec4 (0.7, 0.7, 0.2, 0.2);\n    } else if (idObj == idCol) {\n      col4 = vec4 (0.7, 0.7, 0.2, 0.2) * (0.7 + 0.3 * smoothstep (0.05, 0.1, mod (4. * ro.y, 1.)));\n    } else if (idObj == idWalM) {\n      col4 = (vn.y < 0.9) ? vec4 (0.8, 0.75, 0.75, 0.1) : vec4 (0.7, 0.7, 0.2, 0.2);\n      col4.rgb *= (0.7 + 0.3 * smoothstep (0.05, 0.1, 0.5 * (1. + sin (256. * pi * a))));\n    } else if (idObj == idBm) {\n      col4 = vec4 (0.8, 0.75, 0.75, 0.);\n    } else if (idObj == idWalO) {\n      col4 = vec4 (0.7, 0.7, 0.6, 0.) * (0.7 + 0.3 * step (length (ro.xz), radExt + 0.01)); \n      s = mod (21. * (0.5 + a) + 0.5, 1.) - 0.5;\n      if (abs (s) < 0.08) {\n        sa = mod (1.5 * ro.y + 0.5, 1.) - 0.5;\n        saa = smoothstep (0., 0.1, abs (sa));\n        col4 *= 0.8 + 0.2 * saa;\n        vn.y = -0.3 * (1. - saa) * sign (sa);\n        vn.xz *= sqrt (1. - vn.y * vn.y);\n        vn.xz = Rot2D (vn.xz, asin (pi * clamp (4. * s, -0.5, 0.5)));\n      } else {\n        rg = ShStagGrid (3. * vec2 (42. * a, ro.y));\n        col4 *= rg.y;\n        rg.xz *= sign ((abs (vn.x) > 0.5) ? vn.x : vn.z);\n        if (abs (vn.x) > 0.5) {\n          if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n          else vn.xz = Rot2D (vn.xz, rg.x);\n        } else {\n          if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n          else vn.zx = Rot2D (vn.zx, rg.x);\n        }\n      }\n    } else {\n      col4 = vec4 (SpdCol (), 0.3);\n    } \n    vDotL = max (dot (vn, ltDir), 0.);\n    if (idObj >= idBdy) vDotL *= vDotL;\n    atten = min (1., 1.2 / (1. + 0.2 * dstObj * dstObj / (radExt * radExt)));\n    sh = 1.;\n    if (idObj != idWalO) sh = ObjSShadow (ro, ltDir, dstObj);\n    if (col4.a >= 0.) col = atten * (col4.rgb * (0.2 + 0.8 * sh * vDotL) +\n       step (0.95, sh) * col4.a * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.));\n    else col = atten * col4.rgb;\n    col = mix (col, bgCol, smoothstep (0.8, 1., abs (ro.y) / (2. * radExt)));\n  } else {\n    col = bgCol;\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid SpdSetup (float gDisp)\n{\n  vec3 v;\n  float a, az, fz, d, ll;\n  nSpd = float (N_SPD);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    a = 0.2 * (1. + float (j)) * pi;\n    hipPos[j] = 0.5 * vec3 (- sin (a), 0., 1.5 * cos (a));\n    hipPos[j + 4] = hipPos[j];\n    hipPos[j + 4].x *= -1.;\n  }\n  bdyHt = 1.5;\n  legLenU = 2.2;\n  legLenD = 3.;\n  ll = legLenD * legLenD - legLenU * legLenU;\n  for (int j = VAR_ZERO; j < 8; j ++) {\n    fz = fract ((gDisp + 0.93 + ((j < 4) ? -1. : 1.) + mod (7. - float (j), 4.)) / 3.);\n    az = smoothstep (0.7, 1., fz);\n    footPos[j] = 5. * hipPos[j];\n    footPos[j].x *= 1.7;\n    footPos[j].y += 0.7 * sin (pi * clamp (1.4 * az - 0.4, 0., 1.));\n    footPos[j].z += ((j < 3) ? 0.5 : 1.) - 3. * (fz - az);\n    hipPos[j] += vec3 (0., bdyHt - 0.3, 0.2);\n    v = footPos[j] - hipPos[j];\n    d = length (v);\n    a = asin ((hipPos[j].y - footPos[j].y) / d);\n    kneePos[j].y = footPos[j].y + legLenD *\n       sin (acos ((d * d + ll) / (2. * d *  legLenD)) + a);\n    kneePos[j].xz = hipPos[j].xz + legLenU * sin (acos ((d * d - ll) /\n       (2. * d *  legLenU)) + 0.5 * pi - a) * normalize (v.xz);\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv, ut, mSize, mMid, msw;\n  float el, az, zmFac, asp, sr, regId;\n  int vuMode;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  mSize = (1./6.) * vec2 (asp, 1.);\n  mMid = vec2 (asp * (1. - mSize.y), - 1. + mSize.y);\n  ut = abs (uv - mMid) - mSize;\n  vuMode = 0;\n  if (max (ut.x, ut.y) < 0.) {\n    uv = (uv - mMid) / mSize.y;\n    vuMode = 1;\n  }\n  az = 0.05 * pi * (floor (0.2 * tCur) + smoothstep (0.9, 1., mod (0.2 * tCur, 1.)));\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    regId = 0.;\n    msw = (mPtr.xy * vec2 (asp, 1.) - 0.5 * mMid) / mSize;\n    if (max (abs (msw.x), abs (msw.y)) < 0.5) regId = 1.;\n    else msw = mPtr.xy;\n    if (vuMode == 0) {\n      az += 2. * pi * msw.x;\n      el += pi * msw.y;\n    }\n    if (regId == 1.) vuMode = 1 - vuMode;\n  }\n  if (length (uv * vec2 (1. / asp, 1.)) < 1.5 * SmoothBump (0.25, 0.75, 0.1,\n     mod (0.03 * tCur, 1.))) vuMode = 1 - vuMode;\n  if (vuMode == 0) el = clamp (el, -0.25 * pi, 0.25 * pi);\n  vuMat = StdVuMat (el, az);\n  spdVel = 2.5;\n  SpdSetup (spdVel * tCur);\n  radExt = 15.;\n  radRmp = 6.;\n  vGap = 3.;\n  if (vuMode == 0) {\n    ro = vuMat * vec3 (0., 0., - (radExt - 0.2));\n    zmFac = 2.2;\n  } else if (vuMode == 1) {\n    ro = vec3 (0.);\n    zmFac = 0.5;\n  }\n  dstFar = 4. * radExt;\n  ltDir = vuMat * normalize (vec3 (0.5, 0.5, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi)) / zmFac;\n    if (vuMode == 0) rd = normalize (vec3 (uvv, 1.));\n    else rd = normalize (vec3 (sin (uvv.x + vec2 (0., 0.5 * pi)), uvv.y).xzy);\n    rd = vuMat * rd;\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  if (vuMode == 1) col = pow (col, vec3 (0.9));\n  if (max (ut.x, ut.y) < 0. && min (abs (ut.x), abs (ut.y)) * canvas.y < 2.) col = vec3 (0.2, 0.5, 0.2);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrEETapCylDf (vec3 p, vec3 v1, vec3 v2, float r, float rf)\n{\n  vec3 v;\n  float s;\n  v = v1 - v2;\n  s = clamp (dot (p, v) / dot (v, v), 0., 1.);\n  return length (p - s * v) - r * (1. - rf * s * s);\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sscWf.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1140, 1140, 1184, 1184, 2071], [2073, 2073, 2095, 2095, 3810], [3812, 3812, 3845, 3845, 4028], [4030, 4030, 4051, 4051, 4306], [4308, 4308, 4359, 4359, 4626], [4628, 4628, 4644, 4644, 5319], [5321, 5321, 5356, 5356, 5810], [5812, 5812, 5838, 5838, 6189], [6191, 6191, 6226, 6226, 8599], [8601, 8601, 8630, 8630, 9724], [9726, 9726, 9782, 9782, 12000], [12002, 12002, 12034, 12034, 12134], [12136, 12136, 12169, 12169, 12258], [12260, 12260, 12293, 12293, 12320], [12322, 12322, 12364, 12364, 12415], [12417, 12417, 12483, 12483, 12621], [12623, 12623, 12658, 12658, 12720], [12722, 12722, 12744, 12744, 12782], [12784, 12784, 12820, 12820, 13026], [13028, 13028, 13085, 13085, 13168], [13170, 13170, 13200, 13200, 13313], [13347, 13347, 13371, 13371, 13483], [13485, 13485, 13510, 13510, 13696], [13698, 13698, 13719, 13719, 13874]], "test": "untested"}
{"id": "WdlcDX", "name": "Day 104", "author": "jeyko", "description": "potato", "tags": ["mograph", "motiongraphics", "mdtmjvm"], "likes": 10, "viewed": 445, "published": 3, "date": "1585738205", "time_retrieved": "2024-07-30T21:15:32.587797", "image_code": "\n// USING YX/LUNA'S AWESOME DITHERED MOTION BLUR - https://www.shadertoy.com/view/wsfcWX\n// I modified it to not be framerate dependent like the original.\n\n\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n#define timeStep (1./30.)\n#define motionBlurSteps 100\n\n\nfloat bayer8(ivec2 uv)\n{   \n    uv %= 8;\n\treturn texelFetch(iChannel1,uv,0).r;\n}\n\n\n// from https://necessarydisorder.wordpress.com/\nfloat ease(float p, float g) {\n    if(p < 0.){\n        return 0.;\n    } else if(p > 1.){\n    \treturn 1.;\n    } else {\n        if (p < 0.5) \n            return 0.5 * pow(2.*p, g);\n        else\n            return 1. - 0.5 * pow(2.*(1. - p), g);\n    }\n}\n\nfloat ease(float p, float power, float jump, float offs, float end) {\n    float j = p;\n    p *= offs;\n    float r = (1.-cos(pi*p))/2.*jump;\n    r = pow(r, power);\n    r = mix(r, 1., pow(smoothstep(0.,1.,j),end));\n\treturn r;\n}\nfloat smease(float p, float g) {\n    float s = p;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n\n\nfloat sdBox(vec2 p, vec2 s){\n\tp = abs(p) - s;\n\treturn max(p.x, p.y);\n}\nfloat sdCirc(vec2 p, float s){\n    return length(p) - s;\n}\n\nfloat sdEquilateralTriangle(  vec2 p, float s )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - s;\n    p.y = p.y + s/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d = -length(p)*sign(p.y);\n    \n    d = abs(d) - 0.001;\n    return d;\n}\nconst float speed = 0.44;\nfloat[] scenes = float[3](2.*speed,1.7*speed, 0.6*speed); \n\nconst float W = 0.4;\nconst float dotW = 0.05;\nconst float triS = W*0.85;\n\nvec3 get( vec2 uv, float t  )\n{\n    uv *= 2.;\n    float col = 0.;\n    \n    float d = 10e6;\n    \n    float bA;\n    float bB;\n    float bC;\n    float bD;\n    float bE;\n    \n    float pl;\n    \n    \n    //t += scenes[0];\n    //t += scenes[1] - 0.1;\n    //t += scenes[2] - 0.1;\n    t = mod(t, scenes[0] + scenes[1] /* + scenes[2]*/  );\n    \n    \n    \n    if(t < scenes[0]){\n        float lsp = 1.3;\n        float env = ease(t/scenes[0]*lsp, 1., 1.05, 0.98, 1.);  \n        \n        \n        d = min(d, sdCirc(uv - vec2(0,1)*W, dotW));\n        d = min(d, sdCirc(uv - vec2(sin(tau*1./3.),cos(tau*1./3.))*W, dotW));\n        d = min(d, sdCirc(uv - vec2(sin(tau*2./3.),cos(tau*2./3.))*W, dotW));\n        \n        d = 10e6;\n        for(float i = 1.; i < 4.; i++){\n        \n        }\n        \n        vec2 uvo = uv;\n        uv.y += W;\n        uv *= rot(tau/2.);\n        uv *= rot(tau*1./3.);\n        uv.y -= W;\n        uv *= rot(env*pi*4./3.);\n        uv.y += W;\n        \n        d = min(d,  sdEquilateralTriangle( uv, triS ));\n        \n        uv = uvo;\n        uv *= rot(tau/3.);\n        uv *= rot(tau*2./3.);\n        uv.y -= W;\n        uv *= rot(env*pi*4./3. + pi/3.);\n        uv.y += W;\n        d = min(d,  sdEquilateralTriangle( uv, triS ));\n        \n        uv = uvo;\n        uv *= rot(tau*3.);\n        uv *= rot(tau*1./3.);\n        uv.y -= W;\n        uv *= rot(env*pi*4./3. + pi/3.);\n        uv.y += W;\n        d = min(d,  sdEquilateralTriangle( uv, triS ));\n        \n    } else if(t < scenes[1] + scenes[0]){\n        t -= scenes[0];\n        \n        float lsp = 1.8;\n        float env = ease(t/scenes[1]*lsp, 1., 1.14, 0.96, 10.)*smoothstep(1.,0.,t/scenes[1]*lsp);\n\n        float mov = env*0.3;\n        \n        d = min(d, sdCirc(uv - vec2(0,1)*W, dotW));\n        d = min(d, sdCirc(uv - vec2(sin(tau*1./3.),cos(tau*1./3.))*W, dotW));\n        d = min(d, sdCirc(uv - vec2(sin(tau*2./3.),cos(tau*2./3.))*W, dotW));\n        \n        d = 10e6;\n        \n        vec2 uvo = uv;\n        uv.y += W;\n        \n        \n        uv.y += mov;\n        uv *= rot(tau/2.);\n        uv *= rot(tau*1./3.);\n        d = min(d,  sdEquilateralTriangle( uv, triS ));\n        \n        uv = uvo;\n        uv *= rot(tau/3.);\n        uv.y += mov;\n        uv *= rot(tau*2./3.);\n        uv.y -= W;\n        uv *= rot(pi/3.);\n        uv.y += W;\n        d = min(d,  sdEquilateralTriangle( uv, triS ));\n        \n        uv = uvo;\n        uv *= rot(tau*1./3.);\n        uv.y -= W;\n        uv *= rot(pi/3.);\n        uv.y += mov*0.5;\n        uv.x += mov;\n        uv.y += W;\n        d = min(d,  sdEquilateralTriangle( uv, triS ));\n                \n        \n    }  \n    \n    return vec3(d);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;  \n    vec3 col = vec3(0);\n    \n    float edge = dFdx(uv.x)*1.;\n    \n    for (int i = 0; i < motionBlurSteps + min(iFrame,0); ++i) {\n        float subsample = bayer8(ivec2(fragCoord));\n        float time = iTime + ((float(i)+subsample)/float(motionBlurSteps)-.5) * timeStep;\n        col += smoothstep(-edge,edge,-get(uv,time));\n    }\n    col/=float(motionBlurSteps);\n    \n    col = clamp(col, 0., 1.);\n    col *= 0.999;\n    \n    col *= max((1. + 1.*cos(sin(0.25*tau*iTime/(scenes[0] + scenes[1] ))*tau+length(uv)*2.+vec3(4,2.5,1.5)))*1., 0.);\n    //col *= max((1.5 + 1.4*cos(iTime+length(uv)*2.+vec3(1,1.5,1.5)))*1., 0.);\n    \n    col *= 1. - pow(smoothstep(0.,1.,dot(uv,uv)*0.9),0.9)*1.;\n    \n    col = pow(col, vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlcDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[306, 306, 330, 330, 386], [389, 438, 468, 468, 688], [690, 690, 759, 759, 915], [916, 916, 948, 948, 1052], [1055, 1055, 1083, 1083, 1125], [1126, 1126, 1156, 1156, 1184], [1186, 1186, 1235, 1235, 1488], [1649, 1649, 1680, 1680, 4294]], "test": "untested"}
{"id": "WssyDX", "name": "Cheap Integer Hash", "author": "tomoe", "description": "3-times XorShift and 2-times multiplication.", "tags": ["hash"], "likes": 10, "viewed": 896, "published": 3, "date": "1585733302", "time_retrieved": "2024-07-30T21:15:33.457472", "image_code": "uvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u); //large odd digits, 0 and 1 are fully mixed\n\nfloat hash11(uint n){\n    n ^= (n << 9);\n    n ^= (n >> 1);\n    n ^= (n << 1);\n    n *= k.x;\n    return float(n) / float(0xffffffffu);\n}\nvec2 hash22(uvec2 n){\n    n ^= (n.yx << 9);\n    n ^= (n.yx >> 1);\n    n *= k.xy;\n    n ^= (n.yx << 1);\n    n *= k.xy;\n    return vec2(n) / float(0xffffffffu);\n}\nvec3 hash33(uvec3 n) {\n    n ^= (n.yzx << 9);\n    n ^= (n.yzx >> 1);\n    n *= k;\n    n ^= (n.yzx << 1);\n    n *= k;\n    return vec3(n) / float(0xffffffffu);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy + vec2(iFrame);\n    vec3 col;\n    if (fragCoord.x < 0.33 * iResolution.x){ \n        col = vec3(hash11(floatBitsToUint(p.x)));\n    } else if (fragCoord.x < 0.66 * iResolution.x){\n        col = vec3(hash22(floatBitsToUint(p)), 1.0);\n    } else {\n        col = vec3(hash33(floatBitsToUint(vec3(p, iFrame))));\n    }\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WssyDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 122, 122, 237], [238, 238, 259, 259, 398], [399, 399, 421, 421, 557], [559, 559, 616, 616, 988]], "test": "untested"}
{"id": "wsXyWf", "name": "Presumed bug", "author": "lubosz", "description": "Forked to expose over API\nSee https://www.reddit.com/r/vulkan/comments/fskrs6/amd_vulkan_drivers_has_lots_of_very_critical_bugs/fm2srmg/", "tags": ["test"], "likes": 0, "viewed": 257, "published": 3, "date": "1585708833", "time_retrieved": "2024-07-30T21:15:34.284262", "image_code": "void main2()\n{\n    int i=0;\n    if(i==0)return;\n    else return;\n    for (int i=0; i < 1; i++) {\n    }\n    return;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    main2();\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXyWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 14, 14, 116], [118, 118, 175, 175, 217]], "test": "untested"}
